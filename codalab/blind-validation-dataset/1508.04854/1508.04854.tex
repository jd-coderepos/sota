\documentclass[submission,copyright,creativecommons]{eptcs}
\providecommand{\event}{ICE 2015}

\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{times}
\usepackage{txfonts}
\usepackage{stmaryrd}
\usepackage{url}
\usepackage{amsfonts}
\usepackage{code}
\setlength\hfuzz{3pt}
\usepackage{mathrsfs}
\DeclareMathAlphabet{\mathpzc}{OT1}{pzc}{m}{it}
\let\mathpzc\mathscr
\let\mathpzc\mathcal
\def\BNF{\ \  | \ \  }
\def\bondi{{\bf bondi}}
\def\ltrans{[\![}
\def\rtrans{]\!]}


\usepackage{prooftree}
\usepackage{macros}


\pagestyle{plain} 


\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{remark}[theorem]{Remark}

\newenvironment{definition}[1][Definition]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newenvironment{example}[1][Example]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}


\renewcommand{\beq}{\simeq}
\renewcommand{\rew}{\redar}

\makeatletter
\def \rightarrowfill{\m@th\mathord{\smash-}\mkern-6mu\cleaders\hbox{}\hfill
  \mkern-6mu\mathord\to}
\makeatother
\makeatletter
\def \Rightarrowfill{\m@th\mathord{\smash=}\mkern-6mu\cleaders\hbox{}\hfill
  \mkern-6mu\mathord\Rightarrow}
\makeatother
\def \overstackrel#1#2{\mathrel{\mathop{#1}\limits^{#2}}}


\newcommand{\ifte}[4]{{\bf if}\ #1=#2\ {\bf then}\ #3\ {\bf else}\ #4}
\newcommand{\ift}[3]{{\bf if}\ #1=#2\ {\bf then}\ #3}
\newcommand{\join}[1]{(#1)\rhd }
\newcommand\rn{{\sf rn}}
\newcommand{\cood}[1]{\,\mbox{\sc Cd}(#1)}

\title{On the Expressiveness of Joining}

\author{Thomas Given-Wilson
\institute{Inria, France}
\and
Axel Legay
\institute{Inria, France}
}


\def\titlerunning{On the Expressiveness of Joining}
\def\authorrunning{T. Given-Wilson \& A. Legay}

\begin{document}
\makeatactive

\maketitle  

\begin{abstract}
The expressiveness of communication primitives has been explored in a common framework
based on the -calculus by considering
four features:
{\em synchronism} (asynchronous vs synchronous),
{\em arity} (monadic vs polyadic data),
{\em communication medium} (shared dataspaces vs channel-based),
and {\em pattern-matching} (binding to a name vs testing name equality  vs intensionality).
Here another dimension {\em coordination} is considered that accounts for the number of
processes required for an interaction to occur.
Coordination generalises binary languages such as -calculus to {\em joining} languages
that combine inputs such as the Join Calculus and general rendezvous calculus.
By means of possibility/impossibility of encodings, this paper shows coordination is unrelated to the other features.
That is, joining languages are more expressive than binary languages, and no combination
of the other features can encode a joining language into a binary language.
Further, joining is not able to encode any of the other features unless they could be encoded
otherwise.
\end{abstract}

\section{Introduction}

The expressiveness of process calculi based upon their choice of communication primitives
has been explored before
\cite{Palamidessi:2003:CEP:966707.966709,journals/iandc/BusiGZ00,DeNicola:2006:EPK:1148743.1148750,G:IC08,GivenWilsonPHD,givenwilson:hal-01026301}.
In \cite{G:IC08} and \cite{givenwilson:hal-01026301} this is detailed by examining combinations
of four features, namely:
{\em synchronism}, asynchronous versus synchronous;
{\em arity}, monadic versus polyadic;
{\em communication medium}, shared dataspaces versus channels;
and {\em pattern-matching}, purely binding names versus name equality versus intensionality.
These features are able to represent many popular calculi \cite{G:IC08,givenwilson:hal-01026301} such as:
asynchronous or synchronous,  monadic or polyadic -calculus
  \cite{Milner:1992:CMP:162037.162038,Milner:1992:CMP:162037.162039,milner:polyadic-tutorial};
\Linda~\cite{Gel85};
Mobile Ambients  \cite{DBLP:conf/fossacs/CardelliG98};
{\sc Klaim} \cite{10.1109/32.685256};
semantic- \cite{Castagna:2008:SSP:1367144.1367262};
and asymmetric concurrent pattern calculus \cite{DBLP:journals/corr/Given-Wilson14}.
Also the intensional features capture significant aspects of
Concurrent Pattern Calculus (CPC) \cite{GivenWilsonGorlaJay10,givenwilson:hal-00987578}
and variations \cite{GivenWilsonPHD,DBLP:journals/corr/Given-Wilson14};
and Psi calculi \cite{BJPV11} and sorted Psi calculi \cite{DBLP:conf/tgc/BorgstromGPVP13}.

Typically interaction in process calculi is a binary relation, where two processes interact
and reduce to a third process. For example in -calculus the interaction rule is

Here the processes  and  interact and reduce to a new process .
However, there are process calculi that are not binary with their interactions.
For example, Concurrent Constraint Programming (CCP) has no direct interaction primitives, instead interactions are between a single process and the constraint environment \cite{Saraswat:1991:SFC:99583.99627}.
In the other direction Join Calculus \cite{Fournet_thereflexive}, general rendezvous calculus \cite{Bocchi2004119}, and m-calculus \cite{DBLP:conf/popl/SchmittS03}
allow any number of processes to join in a single interaction. 

This paper abstracts away from specific calculi in the style of \cite{G:IC08,givenwilson:hal-01026301}
to provide a general account of the expressiveness of the {\em coordination} of
communication primitives.
Here coordination can be either {\em binary} between an explicit input and output (as above),
or {\em joining} where the input may interact with unbounded outputs (but at least one).
For example, consider the reduction

where the join  interacts when the two outputs  and  can
match the two parts of the input  and , respectively.


By adding the dimension of coordination, the original 24 calculi of
\cite{G:IC08,givenwilson:hal-01026301}
are here expanded to 48.
This paper details the relations between these calculi, with the following key results.

Joining cannot be encoded into a binary language. This is formalised via the {\em coordination degree}
of a language that is the least upper bound on the number of processes required to yield a reduction.
In general a language with a greater coordination degree cannot be encoded into a language with a
lesser coordination degree. That is, the joining languages with  coordination degree cannot be
encoded into the binary languages with coordination degree 2.

Joining synchronous languages can be encoded into joining asynchronous languages when their binary
counterparts allow an encoding from a synchronous language into an asynchronous one.
In the other direction synchronous languages cannot be encoded into
asynchronous languages that differ only by the addition of joining over binary communication.

Polyadic languages that cannot be encoded into monadic languages in the binary setting cannot be
encoded into monadic languages simply with the addition of joining. Indeed, coordination is
unrelated to arity despite being similar in having a base case (monadic/binary) and an unbounded
case (polyadic/joining).

Channel-based languages cannot be encoded into dataspace-based languages by the addition of joining
unless they could be encoded already. In the other direction, the addition of channels does not allow
a joining language to be encoded into a binary language.

Intensionality cannot be encoded by joining regardless of other features, this result mirrors
the general result that intensionality cannot be represented by any combination of the first four
features \cite{givenwilson:hal-01026301}.
Name-matching cannot be encoded by joining into a
language without any name-matching, despite the possibility of matching unbounded numbers of
names via joining on an unbounded number of channels.

Overall, the results of this paper prove that joining is orthogonal to all the other features,
and that joining languages are strictly more expressive than binary languages.

The structure of the paper is as follows.
Section~\ref{sec:calculi} introduces the 48 calculi considered here.
Section~\ref{sec:encoding} revises the criteria used for encoding and comparing calculi.
Section~\ref{sec:join_only} defines the coordination degree of a language and formalises the
relation between binary and joining languages.
Section~\ref{sec:join_synch} considers the relation between synchronism and coordination.
Section~\ref{sec:join_arity} relates arity and coordination.
Section~\ref{sec:join_comm} presents results contrasting communication medium with coordination.
Section~\ref{sec:join_pattern} formalises the relation between pattern-matching and coordination.
Section~\ref{sec:conclude} concludes, discusses future and related work, and provides some motivations
for intensional calculi.

\section{Calculi}
\label{sec:calculi}

This section defines the syntax, operational, and behavioural semantics of the calculi
considered here. This relies heavily on the well-known notions developed for the
-calculus (the reference framework) and adapts them when necessary to cope with
different features. With the exception of the joining constructs this is a repetition
of prior definitions from \cite{givenwilson:hal-01026301}.

Assume a countable set of names  ranged over by . Traditionally in 
-calculus-style calculi names are used for channels, input bindings, and output data. However, here these are generalised to account for structure. Then, define the {\em terms} (denoted with ) to be
.
Terms consist of names such as , or of {\em compounds}  that combines two terms into one.
The choice of the  as compound operator is similar to Concurrent Pattern Calculus, and also to be clearly distinct from the traditional comma-separated tuples of polyadic calculi.

The input primitives of different languages will exploit different kinds of {\em input patterns}.
The non-pattern-matching languages will simply use binding names (denoted ).
The {\em name-matching} patterns, denoted  and defined by

consist of either a {\em binding name} , or a {\em name-match} .
Lastly the {\em intensional patterns} (denoted ) will also consider structure and are defined by
.
The binding names  and name-match  are contained in  from the name-matching calculi,
the {\em compound pattern}  combines  and  into a single pattern, and is left associative.
The free names and binding names of name-matching and intensional patterns are as expected, taking
the union of sub-patterns for compound patterns. Note that an intensional pattern is well-formed
if and only if all binding names within the pattern are pairwise distinct.
The rest of this paper will only consider well-formed intensional patterns.

The (parametric) syntax for the languages is:

The different languages are obtained by replacing the output  and input  with the various definitions.
The rest of the process forms are as usual:
 denotes the null process;
restriction  restricts the visibility of  to ;
and parallel composition  allows independent evolution of  and .
The  represents conditional equivalence with  used when  is .
The~ represents replication of the process .
Finally, the  is used to represent a success process or state, exploited for reasoning about
encodings as in \cite{G:CONCUR08,GivenWilsonPHD}.

This paper considers the possible combinations of five features for communication:
{\em synchronism} (asynchronous vs synchronous),
{\em arity} (monadic vs polyadic data),
{\em communication medium} (dataspace-based vs channel-based),
{\em pattern-matching} (simple binding vs name equality vs intensionality),
and {\em coordination} (binary vs joining).
As a result there exist 48 languages denoted as  whose generic element is denoted as  where:
\begin{itemize}
\item  for asynchronous communication, and  for synchronous communication.
\item  for monadic data, and  for polyadic data.
\item  for dataspace-based communication, and  for channel-based communications.
\item  for no matching capability,  for name-matching, and  for intensionality.
\item  for binary communication, and  for joining communication.
\end{itemize}
For simplicity a dash  will be used when the instantiation of that feature is unimportant.

\begin{figure}[t]

\caption{Syntax of Languages.}
\label{fig:syntax}
\vspace{-0.3cm}
\end{figure}

Thus the syntax of every language is obtained from the productions in Figure~\ref{fig:syntax}.
The denotation  represents a sequence of the form  and can be used for names, terms, and input patterns.

As usual  and  and  and  bind  in .
Observe that in  and 
neither  nor  bind in , both are free.
The corresponding notions of free and bound names of a process, denoted  and ,
are as usual.
Also note that -equivalence, denoted  is assumed in the usual manner.
Lastly, an input is well-formed if all binding names in that input occur exactly once. This paper shall only consider well-formed inputs.
Finally, the structural equivalence relation  is defined by: 


Observe that , , , and 
align with the communication
primitives of the asynchronous/synchronous monadic/polyadic -calculus
\cite{Milner:1992:CMP:162037.162038,Milner:1992:CMP:162037.162039,milner:polyadic-tutorial}.
The language  aligns with \Linda \cite{Gel85};
the languages  and  with the monadic/polyadic Mobile Ambients \cite{DBLP:conf/fossacs/CardelliG98};
and  with that of {\sc Klaim} \cite{10.1109/32.685256} or semantic- \cite{Castagna:2008:SSP:1367144.1367262}.
The intensional languages do not exactly match any well-known calculi.
However,
the language  has been mentioned in \cite{GivenWilsonPHD}, as a variation of Concurrent Pattern Calculus \cite{GivenWilsonGorlaJay10,GivenWilsonPHD},
and has a behavioural theory as a specialisation of \cite{GivenWilsonGorla13}.
Similarly, the language  is very similar to pattern-matching Spi calculus
\cite{Haack:2006:PS:1165126.1165127}
and Psi calculi \cite{BJPV11},
albeit without the assertions or the possibility of repeated binding names in patterns.
There are also similarities between  and the polyadic synchronous -calculus of
\cite{Carbone:2003:EPP:941344.941346}, although the intensionality is limited to the
channel, i.e.~inputs and outputs of the form  and  respectively.
For the joining languages:
 represents Join Calculus \cite{Fournet_thereflexive};
and  the general rendezvous calculus \cite{Bocchi2004119},
and m-calculus \cite{DBLP:conf/popl/SchmittS03}, although the latter has higher order constructs and
other aspects that are not captured within the features here.

\begin{remark}
\label{rem:leq}
The languages  can be easily ordered; in particular
 can be encoded into
 if it holds that
 and
 and
 and
 and
, where  is the least reflexive relation satisfying the following axioms:

This can be understood as the lesser language variation being a special case of the more general language.
Asynchronous communication is synchronous communication with all outputs followed by .
Monadic communication is polyadic communication with all tuples of arity one.
Dataspace-based communication is channel-based communication with all -ary tuples communicating with channel name .
All name-matching communication is intensional communication without any compounds,
and no-matching capability communication is both without any compounds and with only binding names
in patterns.
Lastly, binary communication is joining communication with all joining inputs having only a single input pattern.
\end{remark}


The operational semantics of the languages is given here via reductions as in
\cite{milner:polyadic-tutorial,Honda95onreduction-based,givenwilson:hal-01026301}.
An alternative style is via a {\em labelled transition system} (LTS) such as \cite{G:IC08}.
Here the reduction based style is to simplify having to define here the (potentially complex)
labels that occur when both intensionality and joining are in play. However, the LTS style can be
used for intensional languages \cite{BJPV11,GivenWilsonPHD,GivenWilsonGorla13}, and indeed
captures many\footnote
{Perhaps all of the binary languages here, although this has not been proven.}
of the languages here \cite{GivenWilsonGorla13}.
For the joining languages the techniques used in \cite{Fournet99bisimulationsin} can be used for
the no-matching joining languages, with the techniques of \cite{GivenWilsonGorla13} used to extend
intensionality\footnote{This has not been proven as yet, however there appears no reason it should not be
straightforward albeit very tedious.}.

Substitutions, denoted , in non-pattern-matching and name-matching
languages are mappings (with finite domain) from names to names. For intensional languages
substitutions are mappings (also finite domain) from names to terms.
The application of a substitution  to a pattern  is defined by: 
Where substitution is as usual on names, and on the understanding that the name-match
syntax can be applied to any term as follows
 and .


Given a substitution  and a process , denote with  the
(capture-avoiding) application of  to  that behaves in the usual manner.
Note that capture can always be avoided by exploiting -equivalence, which can
in turn be assumed \cite{UBN07}. 

\renewcommand{\match}[2]{\{#1/\!\!/#2\}}

Interaction between processes is handled by matching some terms  with
some patterns , and possibly also equivalence of channel-names.
This is handled in two parts. The first part is the {\em match} rule  of a single term 
with a single pattern  to create a substitution .
That is defined as follows:

Any term  can be matched with a binding name  to generate a substitution from the
binding name to the term .
A single name  can be matched with a name-match for that name  to yield the
empty substitution.
A compound term  can be matched by a compound pattern  when
the components match to yield substitutions  and ,
the resulting substitution is the unification of  and .
Observe that since patterns are well-formed, the substitutions of components will always have
disjoint domain.
Otherwise the match is undefined.


The second part is then the {\em poly-match} rule  that
determines matching of a sequence of terms  with a sequence of patterns ,
defined below.

The empty sequence matches with the empty sequence to produce the empty substitution.
Otherwise when there is a sequence of terms  and a sequence of patterns ,
the first elements are matched  and the remaining sequences use the poly-match rule.
If both are defined and yield substitutions, then the union of substitutions is the
result.
(Like the match rule, the union is ensured disjoint domain by well-formedness of inputs.)
Otherwise the poly-match rule is undefined, for example when a single match fails, or the
sequences are of unequal arity.

Interaction is now defined by the following axiom for the binary languages:

and for the joining languages:

In both axioms, the 's are omitted in the asynchronous languages,
and the 's are omitted for the dataspace-based languages.
The axioms state that when the poly-match of the terms of the output(s)  match with the
input pattern(s) of the input  (and in the channel-based setting the output and input pattern(s)
are along the same channels) yields a substitution , then reduce to ((s) in the synchronous languages
in parallel with)  applied to .

The general reduction relation  includes the interaction axiom for the language in question
as well as the following three rules:

The reflexive transitive closure of  is denoted by .

Lastly, for each language let  denote
a reduction-sensitive reference behavioural equivalence for that language, e.g.~a barbed equivalence.
For the non-intensional languages these are mostly already known, either by
their equivalent language in the literature, such as asynchronous/synchronous monadic/polyadic
-calculus or Join Calculus, or from \cite{G:IC08}.
For the intensional languages the results in \cite{GivenWilsonGorla13} can be used.
For the other joining languages the techniques used in \cite{Fournet99bisimulationsin} can be used for
the no-matching joining languages, with the techniques of \cite{GivenWilsonGorla13} used to extend
intensionality\footnote{This has not been proven as yet, however there appears no reason it should not be
possible, and the results here rely upon the existence of an equivalence relation, not any particular one.}.

\section{Encodings}
\label{sec:encoding}

This section recalls the definition of valid encodings as well as some
useful theorems (details in \cite{G:CONCUR08}) for formally relating process calculi.
The validity of such criteria in developing expressiveness studies emerges from the
various works \cite{G:IC08,G:DC10,G:CONCUR08}, that have also recently inspired similar works
\cite{LPSS10,Lanese:2010:EPP:2175486.2175506,gla12}. 

An {\em encoding} of a language  into another language  is a pair
 where  translates every -process into
an -process and  maps every name (of the source language) into a tuple
of  names (of the target language), for .
The translation  turns every term of the source language into a term of the
target; in doing this, the translation may fix some names to play a precise r\^ole 
or may translate a single name into a tuple of names. This can be obtained
by exploiting .

Now consider only encodings that satisfy the following properties.
Let a {\em -ary context}  be a term where 
occurrences of  are linearly replaced by the holes  (every one of the  holes must occur once and only once).
Denote with  and  
the relations  and  in language ;
denote with  an infinite sequence of reductions in .
Moreover, let  denote the reference behavioural equivalence for language .
Also, let  mean that there exists  such that  and ,
for some .
Finally, to simplify reading, let  range
over processes of the source language (viz., ) and  range
over processes of the target language (viz., ).

\begin{definition}[Valid Encoding]
\label{def:ve}
An encoding  of  into 
is {\em valid} if it satisfies the following five properties:
\begin{enumerate}
\item {\em Compositionality:} for every -ary operator  of 
and for every subset of names ,
there exists a -ary context  of 
such that, for all  with , it holds
that .

\item {\em Name invariance:}
for every  and substitution , it holds that
 if  is injective and
 otherwise
where  is such that 

for every name .

\item {\em Operational correspondence:}
\begin{itemize}
\item for all , it holds that ;
\item for all , there exists  such that  
and .
\end{itemize}

\item {\em Divergence reflection:}
for every  such that 
, it holds that   \mbox{}.

\item {\em Success sensitiveness:}
for every , it holds that  if and only if .
\end{enumerate}
\end{definition}

Now recall two results concerning valid encodings that are useful for later proofs.

\begin{proposition}[Proposition 5.5 from \cite{G:CONCUR08}]
\label{prop:deadlock}
Let  be a valid encoding; then, 
implies that .
\end{proposition}

\begin{proposition}[Proposition 5.6 from \cite{G:CONCUR08}]
\label{prop:ctx_top}
Let  be a valid encoding; then for every set of names ,
it holds that  has both its holes at top-level.
\end{proposition}

\section{Joining vs Binary}
\label{sec:join_only}

This section considers the expressive power gained by joining. It turns out that joining adds expressive
power that cannot be represented by binary languages regardless of other features.

The expressive power gained by joining can be captured by the concept of the {\em coordination degree} of a language , denoted ,
as the least upper bound on the number of processes that must coordinate to yield a reduction in .
For example, all the binary languages  have coordination degree 2 since their
reduction axiom is only defined for two processes.
By contrast, the coordination degree of the joining languages is  since there is no bound on the
number of inputs that can be part of a join. 

\begin{theorem}\label{thm:int_deg_gt}
If  then there exists no valid encoding  from  into .
\end{theorem}
\begin{proof}
By contradiction, assume there is a valid encoding .
Pick  processes  to  where  such that all these processes
must coordinate to yield a reduction and yield success.
That is, 
but not if any  (for ) is replaced by the null process .
By validity of the encoding it must be that 
and .

By compositionality of the encoding 
 where
 must be of the form\linebreak
.
Now consider the reduction  that can be at most between 
processes by the coordination degree of .
If the reduction does {\em not} involve some process  then it follows that

(by replacing the  in the context  with ).
By construction of  and  there must
exist some such .
However, this contradicts the validity of the encoding since
.
The only other possibility is if  blocks the reduction by blocking some .
This can only occur when  is either underneath an interaction primitive
(e.g.~) or inside a conditional (e.g.~).
Both require that  not be top level in , which can be proven contradictory
by  applications of Proposition~\ref{prop:ctx_top}.
\end{proof}

\begin{corollary}
\label{cor:join_gt_bin}
There exists no valid encoding from  into .
\end{corollary}

In the other direction the result is ensured by Remark~\ref{rem:leq}.
Thus for any two languages which differ only by one being binary and the other joining, the
joining language is strictly more expressive than the binary language.

\section{Joining and Synchronicity}
\label{sec:join_synch}

This section considers the relation between joining and synchronicity. It turns out that
the two are orthogonal and do not influence the other's expressiveness.

It is sufficient to consider the languages  and
 and .
The other asynchronous joining languages can encode their synchronous joining
counterparts in the usual manner \cite{honda1991object}. 
For example, the encoding from  into 
given by

can be adapted in the obvious manner for
 into  as follows

The idea for binary languages is that the encoded output creates a fresh name  and sends it to the encoded input.
The encoded input creates a fresh name  and sends it to the encoded output along channel name .
The encoded output now knows it has communicated and evolves to  in parallel with the
original  sent to the encoded input along channel name .
When the encoded input receives this it can evolve to .
The joining version is similar except the join synchronises with all the encoded outputs at once,
sends the fresh names  in parallel, and then synchronises on all the  in the last step.

The encoding above is shown for  into 
and is the identity on all other process forms. This can be proven to be a valid encoding.

\begin{lemma}
\label{lem:minussynch-match}
Given a  input 
and output 
then  if and only if .
\end{lemma}

\begin{lemma}
\label{lem:minussynch-equiv}
If  then .
Conversely, if  then  for some .
\end{lemma}

\begin{lemma}
\label{lem:minussynch-red}
The translation  from  into  preserves
and reflects reductions.
\end{lemma}

\begin{theorem}
\label{thm:synch}
There is a valid encoding from  into .
\end{theorem}
\begin{proof}
Compositionality and name invariance hold by construction.
Operational correspondence (with structural equivalence in the place of )
and divergence reflection follow from Lemma~\ref{lem:minussynch-red}.
Success sensitiveness can be proved as follows:  means that there exists  and
 such that ; by exploiting Lemma~\ref{lem:minussynch-red}
 times and Lemma~\ref{lem:minussynch-equiv} obtain that
 where  can be determined from the
instantiations of Lemma~\ref{lem:minussynch-equiv},
i.e.~that .
The converse implication can be proved similarly.
\end{proof}

\begin{corollary}
If there exists a valid encoding from  into 
then there exists a valid encoding from  into .
\end{corollary}
\begin{proof}
Theorem~\ref{thm:synch} applies directly for all channel-based languages.
The only other cases can encode channels and so use encodings of the channel-based solution above.
For the polyadic and name-matching languages this holds by Proposition~4.1 of \cite{G:IC08},
otherwise for the intensional languages this holds by Theorem~6.4 of \cite{givenwilson:hal-01026301}.
\end{proof}

The following results complete the formalisation that coordination is orthogonal to synchronicity.

\begin{theorem}
\label{thm:no_synch_2_asynch}
There exists no valid encoding from  into .
\end{theorem}
\begin{proof}
The proof is by contradiction. Consider two processes
 (where  is a divergent process) and .
Since  by validity of the encoding  and this must be
between some  for some  and . 
Observe that  cannot be a reduct of either  or  since then
either  or  would reduce and this contradicts Proposition~\ref{prop:deadlock}.

If  arises from  then it can be shown that  must also include a top level
join since otherwise there would be no join in  that can bind some name to  and
name invariance or divergence reflection would be shown to fail
(i.e.~ and  while
 does no inputs on any part of 
and so must always or never diverge regardless of interaction with ).
Thus  must include a top level join and further it must include an input pattern
 for some  since otherwise if the join was only
 for some  and  then
 for  instances of  would reduce while 
does not contradicting Proposition~\ref{prop:deadlock}.
It follows that  must include  as part of some join under which there
must be an output that is able to send at least one name to  via an output  for some 
(this could be any number of names, but assume 1 here for simplicity).
Now consider the name .
If  then  and this contradicts validity of the encoding since .
If  then  is not bound in  and so it can be shown that either: this fails name invariance
or divergence reflection
(again by  and );
or there must be a further input in  that is binding as in the next case.
If  and  then it can be shown that  can reduce such that the
input under consideration interacts with the  from the other 
and this ends up contradicting operational correspondence.

If  arises from  then it can be shown that  must also include a top level
join since otherwise when  then  would always diverge or never diverge 
regardless of interaction with  and this contradicts divergence reflection.
Thus  must include a top level join and further it must include an input pattern
 for some  since otherwise if the join was only
 for some  and  then
 for  instances of  would reduce while 
does not contradicting Proposition~\ref{prop:deadlock}.
Now consider when  and the substitution .
Clearly  where either:
 and ; or  and .
However it can be shown that the top level join in  is not able to discriminate and
thus that there exist two possible reductions  to an 
where either:
 and ; or  and ;
both of which contradict divergence reflection and success sensitiveness.
\end{proof}

\begin{theorem}
There exists no valid encoding from  into .
\end{theorem}
\begin{proof}
This is proved in the same manner as Theorem~\ref{thm:no_synch_2_asynch}.
\end{proof}

That joining does not allow for an encoding of synchronous communication alone is not surprising,
since there is no control in the input of which outputs are interacted with (without some other
control such as channel names or pattern-matching). Thus, being able to consume more outputs in
a single interaction does not capture synchronous behaviours.



\section{Joining and Arity}
\label{sec:join_arity}

This section considers the relation between joining and arity. It turns out that these are
orthogonal.
Although there appear to be some similarities in that both have a base case (monadic or binary),
and an unbounded case (polyadic or joining, respectively), these cannot be used to encode one-another.
This is captured by the following result.


\begin{theorem}
\label{thm:no_poly_2_join}
There exists no valid encoding from  into .
\end{theorem}
\begin{proof}
The proof is by contradiction, assume there exists a valid encoding .
Consider the  processes  and .
Clearly it holds that  and so  and 
by validity of the encoding. Now consider the reduction .

The reduction must be of the form

for some  and  and  and .
Now consider the process whose encoding produces ,
assume  although the results do not rely on this assumption.
If any  are also from the encoding of  then it follows that the encoding of
 instances of  in parallel will reduce, i.e.~, while
.
Now consider two fresh processes  and  such that  with some arity that is not 
and  and .
It follows that  (and  and )
and  must include at least one  to do so.
This  must arise from either  or , and conclude by showing that
the encoding of  instances of either  or  in parallel with  reduces, while the
un-encoded processes do not.
\end{proof}

\begin{corollary}
If there exists no valid encoding from
 into , then there exists
no valid encoding from  into .
\end{corollary}
\begin{proof}
The technique in Theorem~\ref{thm:no_poly_2_join} applies to all dataspace-based no-matching languages.
Dataspace-based name-matching languages build upon Theorem~\ref{thm:no_poly_2_join} with
 to then ensure that binding occurs and not only name-matching,
the proof is concluded via contradiction of name invariance and success sensitiveness as in
Theorem~\ref{thm:no_synch_2_asynch}.
For the channel-based communication it is easier to refer to Theorem~\ref{thm:no_chan_2_join} to
illustrate that this is not possible than to extend the proof above.
\end{proof}

Thus joining does not allow for encoding polyadicity in a monadic language unless it could already be
encoded by some other means.
In the other direction, the inability to encode joining into a binary language is already 
ensured by Corollary~\ref{cor:join_gt_bin}.


\section{Joining and Communication Medium}
\label{sec:join_comm}

This section considers the relation between joining and communication medium. Again joining turns out
to be orthogonal to communication medium and neither can encode the other.
The key to this is captured in the following result.


\begin{theorem}
\label{thm:no_chan_2_join}
There exists no valid encoding from  into .
\end{theorem}
\begin{proof}
The proof is by contradiction, assume there exists a valid encoding .
Consider the  processes  and .
Clearly it holds that  and so  and 
by validity of the encoding. Now consider the reduction .

The reduction must be of the form

for some  and  and  and .
Now consider the process whose encoding produces ,
assume  although the results do not rely on this assumption.
If any  are also from the encoding of  then it follows that the encoding of
 instances of  in parallel will reduce, i.e.~, while
.
Now consider two fresh processes  and .
Since  it follows that  and must include at least one
 to do so.
This  must arise from either  or , and conclude by showing that
the encoding of  instances of either  or  in parallel with  reduces, while the
un-encoded processes do not.
\end{proof}


\begin{corollary}
If there exists no valid encoding from
 into , then there exists
no valid encoding from  into .
\end{corollary}
\begin{proof}
The technique in Theorem~\ref{thm:no_chan_2_join} applies to all monadic languages
(the addition of name-matching can be proved using the techniques as in Theorem~\ref{thm:no_synch_2_asynch}).
For the polyadic no-matching setting the result above holds by observing that the arity must
remain fixed for an encoding, i.e.~ is\linebreak
encoded to inputs/outputs all of
some arity . If the arity is not uniform then the encoding fails\linebreak
either operational correspondence
(i.e.~)
or divergence reflection as in sub-case (2) of Theorem~\ref{thm:no_int_2_join} except here with
arity instead of number of names.
\end{proof}

Thus joining does not allow for encoding channels in a dataspace-based language unless it could already be
encoded by some other means.
In the other direction, the inability to encode joining into a binary language is already 
ensured by Corollary~\ref{cor:join_gt_bin}.


\section{Joining and Pattern-Matching}
\label{sec:join_pattern}

This section considers the relations between joining and pattern-matching.
The great expressive power of name matching \cite{G:IC08} and intensionality \cite{givenwilson:hal-01026301}
prove impossible to encode with joining.
In the other direction, joining cannot be encoded by any form of pattern-matching.

The first result is to prove that intensionality cannot be encoded by joining.
Recall that since intensionality alone can encode all other features aside from joining,
it is sufficient to consider .

\begin{theorem}
\label{thm:no_int_2_join}
There exists no valid encoding from  into  where .
\end{theorem}
\begin{proof}
The proof is by contradiction and similar to Theorem~7.1 of \cite{givenwilson:hal-01026301}.
Assume there exists a valid encoding  from  into
 for some  and  and  and 
where .
Consider the encoding of the processes  and .
Clearly   since .
There exists a reduction  that must be between a
join and some outputs that have combined maximal arity .
(The combined arity is the sum of the arities of all the input-patterns of the join involved,
e.g.~ has combined arity 3.)

Now define the following processes 

and

where  outputs  distinct names in a single term, and  matches all of these names in
a single intensional pattern.
Since  it must be that 
for the encoding to be valid.
Now consider the maximal combined arity of the reduction .
\begin{itemize}
\item If the arity is  
  consider the reduction  with the combined maximal arity  which
  must exist since .
  Now consider the relationship of  and .
  \begin{enumerate}
  \item If  
    then the upper bound on the number of names that are matched in the
    reduction is  (when each name is matched via a distinct channel).
    Since not all  tuples of names from  can be matched in the reduction then
    there must be at least one tuple  for  that is not being
    matched in the interaction .
    Now construct  that differs from  only by swapping one such name  with
    : .
    Now consider the context 
    where .
    Clearly neither  nor
     as this would contradict
    Proposition~\ref{prop:deadlock}.
    However, since  and  differ only by the position of one name whose tuple 
    does not appear in the
    reduction , it follows that the reason 
     must be due to a structural
    congruence difference between 
    and .
    Further, by compositionality of the encoding the difference can only be between
     and .
    Since Proposition~\ref{prop:deadlock} ensures that 
    and , the only possibility is a structural difference
    between  and .
    Now exploiting 
    
    such that 
    yields contradiction.
\item If  then obtain that \encode{ must be able to interact with both
    combined arity  and combined arity .
    That is, 
    where  and that
     reduces with combined arity  and
     reduces with combined arity .
    Now it is straightforward, if tedious, to show that since 
    that  can perform the same initial
    reductions as either
     or 
    
    by exploiting operational correspondence and Proposition~\ref{prop:deadlock}.
Thus, it can be shown that  can perform both
    the  combined arity reduction of  and
    the  combined arity reduction of .
    Now by exploiting the structural congruence rules it follows that neither of these
    initial reductions can prevent the other occurring.
    Thus,
     must be able to do both of these 
    initial reductions in any order.
Now consider the process  that has performed both of these initial reductions.
    By operational correspondence it must be that  since
    .
    Therefore,  must be able to roll-back the initial step with combined arity ;
    i.e~reduce to a state that is equivalent to the reduction not occurring.
    (Or the initial step with arity , but either one is sufficient as
    by operational correspondence .)
Now consider how many names are being matched in the initial reduction with combined arity .
    If  the technique of differing on one name used in the case of  can be used
    to show that this would introduce divergence on the potential roll-back and thus contradict
    a valid encoding.
Therefore it must be that .
    Finally, by exploiting name invariance and substitutions like
     applied to  and 
    it follows that either  or both  and  must have
    infinitely many initial reductions which yields divergence.
  \end{enumerate}
\item If the combined arity is not  then proceed like the second case above.
\end{itemize}
\vspace{-0.6cm}
\end{proof}

\begin{corollary}
If there exists no valid encoding from
 into , then there exists
no valid encoding from  into .
\end{corollary}

It follows that joining cannot represent intensionality in a language that does not have intensionality
already (including name-matching or no-matching languages).

The next result shows that name matching is insufficient to encode joining.

\begin{theorem}
\label{thm:no_name_2_join}
There exists no valid encoding from  into
.
\end{theorem}
\begin{proof}
The proof is by contradiction, assume there exists a valid encoding .
Consider the  processes  and
.
Clearly it holds that  and  and so
 and  by validity of the encoding.
Now consider .
\begin{itemize}
\item If  then consider 
the substitution , it is clear that 
and so , however the only possibility that this holds is
when  is blocked from interacting.
It is then straightforward if tedious to show that any such blocking of reduction would either
imply  or 
and thus contradict the validity of the encoding.


\item Otherwise it must be that . Now consider the reduction 
that must be of the form

for some  and  and  and  and .
Again consider the substitution , it is clear that 
and so . The only way this can occur without contradicting
the validity of the encoding (as in the previous case) is when there is at least one  in the
domain of some  where  and 
by definition of the encoding.
Now consider the process ,
clearly  and so  as well.
The reduction  must be from the form

for some  and  and  and  and .
Now if  it follows that for each  then .
However, this contradicts the validity of the encoding since there is some  in the domain of 
such that  and  while .
Otherwise it must be that  (otherwise if  then )
and that .
Now consider when , 
clearly  and  and so
 diverges and .
Now it can be shown that  while
 and diverges since 
can satisfy the first  input patterns of  and  the remaining
, leaving the first  input patterns of  to interact with 
and yield divergence.
The only other possibility is that .
However, this requires that  check some binding name in  for equality with
 before yielding success (i.e.~). This can in turn be shown
to contradict the validity of the encoding by adding another instance of .
\end{itemize}
\vspace*{-0.6cm}
\end{proof}


\begin{corollary}
If there exists no valid encoding from
 into , then there exists
no valid encoding from  into .
\end{corollary}



Thus joining does not allow for encoding name-matching into a no-matching language unless it could already be
encoded by some other means.
In the other direction, the inability to encode joining into a binary language is already 
ensured by Corollary~\ref{cor:join_gt_bin}.

\section{Conclusions and Future Work}
\label{sec:conclude}

Languages with non-binary coordination have been considered before, although
less often than binary languages.
It turns out that increases in coordination degree correspond to increases in expressive power.
For example, an intensional binary language
cannot be encoded by a non-intensional joining language.
However, encodings from lower coordination degree languages into higher coordination degree
languages are still dependent upon other features.

This formalises that languages like the Join Calculus, general rendezvous calculus, and m-calculus
cannot be validly encoded into binary languages, regardless of other features.
Although there exist encodings from (for example) Join Calculus into -calculus
\cite{Fournet_thereflexive}
these do not meet the criteria for a {\em valid encoding} used here.
The general approach used in such encodings is to encode joins by
,
however this can easily fail operational correspondence, divergence reflection, or success sensitivity.
For example
 will either report success or diverge, but its encoding can deadlock.
Even ordering the channel names to prevent this can be shown to fail under substitutions.

Future work along this line can consider coordination not merely to be binary or joining.
Indeed, a {\em splitting} language could be one where several output terms can be combined into
a split  while inputs remain of the form .
Further, languages could support both joining and splitting primitives for full coordination.

\paragraph{Acknowledgments.} We would like to thank the reviewers for their constructive and helpful criticism.

\bibliographystyle{eptcs}
\bibliography{local}

\end{document}
