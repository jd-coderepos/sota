\documentclass{article} \usepackage{iclr2020_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{hyperref}
\usepackage{url}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{wrapfig}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{booktabs}
\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{pdfpages}

\usepackage{xargs}                  
\newcommand{\nop}[1]{}

\title{TabFact: A Large-scale Dataset for Table-based Fact Verification}



\author{Wenhu Chen, Hongmin Wang, Jianshu Chen, Yunkai Zhang, Hong Wang, \\
\textbf{Shiyang Li, Xiyou Zhou, William Yang Wang}\\
University of California, Santa Barbara, CA, USA\\
Tencent AI Lab, Bellevue, WA, USA\\
{\tt \{wenhuchen,hongmin\_wang,yunkai\_zhang,hongwang600,william\}@ucsb.edu}\\
{\tt \{shiyangli,xiyou\}@cs.ucsb.edu jianshuchen@tencent.com}
}




\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}
The problem of verifying whether a textual hypothesis holds based on the given evidence, also known as fact verification, plays an important role in the study of natural language understanding and semantic representation. However, existing studies are mainly restricted to dealing with unstructured evidence (e.g., natural language sentences and documents, news, etc), while verification under structured evidence, such as tables, graphs, and databases, remains under-explored. This paper specifically aims to study the fact verification given semi-structured data as evidence. To this end, we construct a large-scale dataset called TabFact with 16k Wikipedia tables as the evidence for 118k human-annotated natural language statements, which are labeled as either ENTAILED or REFUTED. TabFact is challenging since it involves both soft linguistic reasoning and hard symbolic reasoning. To address these reasoning challenges, we design two different models: Table-BERT and Latent Program Algorithm (LPA). Table-BERT leverages the state-of-the-art pre-trained language model to encode the linearized tables and statements into continuous vectors for verification. LPA parses statements into programs and executes them against the tables to obtain the returned binary value for verification. Both methods achieve similar accuracy but still lag far behind human performance. We also perform a comprehensive analysis to demonstrate great future opportunities. The data and code of the dataset are provided in \url{https://github.com/wenhuchen/Table-Fact-Checking}.
\end{abstract}

\section{Introduction}
Verifying whether a textual hypothesis is entailed or refuted by the given evidence is a fundamental problem in natural language understanding~\citep{katz1963structure,van2008brief}. It can benefit many downstream applications like misinformation detection, fake news detection, etc. Recently, the first-ever end-to-end fact-checking system has been designed and proposed in~\cite{hassan2017claimbuster}. The verification problem has been extensively studied under different natural language tasks such as recognizing textual entailment (RTE)~\citep{dagan2005pascal}, natural language inference (NLI)~\citep{bowman2015large}, claim verification~\citep{popat2017truth,hanselowski2018ukp,thorne2018fever} and multimodal language reasoning (NLVR/NLVR2)~\citep{suhr2017corpus,suhr2019corpus}. RTE and NLI view a premise sentence as the evidence, claim verification views passage collection like Wikipedia\footnote{\url{https://www.wikipedia.org/}} as the evidence, NLVR/NLVR2 views images as the evidence. These problems have been previously addressed using a variety of techniques including logic rules, knowledge bases, and neural networks. Recently large-scale pre-trained language models~\citep{devlin2018bert,peters2018deep,yang2019xlnet,liu2019roberta} have surged to dominate the other algorithms to approach human performance on several textual entailment tasks~\citep{wang2018glue,wang2019superglue}. 
\begin{figure}
    \centering
    \includegraphics[width=0.95\linewidth]{table.pdf}
    \vspace{-2ex}
    \caption{Examples from the \textsc{TabFact} dataset. The top table contains the semi-structured knowledge facts with caption "United...". The left and right boxes below provide several entailed and refuted statements. The error parts are highlighted with red font.}
    \vspace{-3ex}
    \label{fig:table}
\end{figure}

However, existing studies are restricted to dealing with unstructured text as the evidence, which would not generalize to the cases where the evidence has a highly structured format. Since such structured evidence (graphs, tables, or databases) are also ubiquitous in real-world applications like database systems, dialog systems, commercial management systems, social networks, etc, we argue that the fact verification under structured evidence forms is an equivalently important yet under-explored problem. Therefore, in this paper, we are specifically interested in studying fact verification with semi-structured Wikipedia tables~\citep{bhagavatula2013methods}\footnote{In contrast to the database tables, where each column has strong type constraint, the cell records in our semi-structured tables can be string/data/integer/floating/phrase/sentences.} as evidence owing to its structured and ubiquitous nature~\citep{jauhar2016tables,zhong2017seq2sql,pasupat2015compositional}. To this end, we introduce a large-scale dataset called \textsc{TabFact}, which consists of 118K manually annotated statements with regard to 16K Wikipedia tables, their relations are classified as {\tt ENTAILED} and {\tt REFUTED}\footnote{we leave out NEUTRAL due to its low inter-worker agreement, which is easily confused with REFUTED.}. The entailed and refuted statements are both annotated by human workers. With some examples in~\autoref{fig:table}, we can clearly observe that unlike the previous verification related problems, \textsc{TabFact} combines two different forms of reasoning in the statements, (i) \emph{Linguistic Reasoning}: the verification requires semantic-level understanding. For example, ``John J. Mcfall failed to be re-elected though being unopposed." requires understanding over the phrase ``lost renomination ...'' in the table to correctly classify the entailment relation. Unlike the existing QA datasets~\citep{zhong2017seq2sql,pasupat2015compositional}, where the linguistic reasoning is dominated by paraphrasing, \textsc{TabFact} requires more linguistic inference or common sense. (ii) \emph{Symbolic Reasoning}: the verification requires symbolic execution on the table structure. For example, the phrase ``There are three Democrats incumbents" requires both condition operation (where condition) and arithmetic operation (count). Unlike question answering, a statement could contain compound facts, all of these facts need to be verified to predict the verdict. For example, the "There are ..." in~\autoref{fig:table} requires verifying three QA pairs (total count=5, democratic count=2, republic count=3). The two forms of reasoning are interleaved across the statements making it challenging for existing models.

In this paper, we particularly propose two approaches to deal with such mixed-reasoning challenge: (i) \emph{Table-BERT}, this model views the verification task completely as an NLI problem by linearizing a table as a premise sentence , and applies state-of-the-art language understanding pre-trained model to encode both the table and statements  into distributed representation for classification. This model excels at linguistic reasoning like paraphrasing and inference but lacks symbolic reasoning skills. (ii) \emph{Latent Program Algorithm}, this model applies lexical matching to find linked entities and triggers to filter pre-defined APIs (e.g. argmax, argmin, count, etc). We adopt bread-first-search with memorization to construct the potential program candidates, a discriminator is further utilized to select the most ``consistent" latent programs. This model excels at the symbolic reasoning aspects by executing database queries, which also provides better interpretability by laying out the decision rationale. We perform extensive experiments to investigate their performances: the best-achieved accuracy of both models are reasonable, but far below human performance. Thus, we believe that the proposed table-based fact verification task can serve as an important new benchmark towards the goal of building powerful AI that can reason over both soft linguistic form and hard symbolic forms. To facilitate future research, we released all the data, code with the intermediate results. 


\section{Table Fact Verification Dataset}
First, we follow the previous Table-based Q\&A datasets \citep{pasupat2015compositional,zhong2017seq2sql} to extract web tables~\citep{bhagavatula2013methods} with captions from WikiTables\footnote{\url{http://websail-fe.cs.northwestern.edu/wikiTables/about/}}. Here we filter out overly complicated and huge tables (e.g. multirows, multicolumns, latex symbol) and obtain~18K relatively clean tables with less than 50 rows and 10 columns. 

For crowd-sourcing jobs, we follow the human subject research protocols\footnote{\url{https://en.wikipedia.org/wiki/Minimum_wage_in_the_United_States}} to pay Amazon Mechanical Turk\footnote{\url{https://www.mturk.com/}} workers from the native English-speaking countries ``US, GB, NZ, CA, AU" with approval rates higher than 95\% and more than 500 accepted HITs. Following WikiTableQuestion~\citep{pasupat2015compositional}, we provide the annotators with the corresponding table captions to help them better understand the background. To ensure the annotation quality, we develop a pipeline of ``positive two-channel annotation''  ``negative statement rewriting''  ``verification'', as described below. 


\subsection{Positive Two-Channel Collection \& Negative Rewriting Strategy}
To harvest statements of different difficulty levels, we design a two-channel collection process:\vspace{3px}\\
\noindent \textbf{Low-Reward Simple Channel}: the workers are paid 0.45 USD for annotating one Human Intelligent Task (HIT) that requires writing five statements. The workers are encouraged to produce plain statements meeting the requirements: (i) corresponding to a single row/record in the table with unary fact without involving compound logical inference. (ii) mention the cell values without dramatic modification or paraphrasing. The average annotation time of a HIT is 4.2 min.\vspace{3px}\\
\noindent \textbf{High-Reward Complex Channel}: the workers are paid 0.75 USD for annotating a HIT (five statements). They are guided to produce more sophisticated statements to meet the requirements: (i) involving multiple rows in the tables with higher-order semantics like argmax, argmin, count, difference, average, summarize, etc. (ii) rephrase the table records to involve more semantic understanding. The average annotation time of a HIT is 6.8 min.
The data obtained from the complex channel are harder in terms of both linguistic and symbolic reasoning, the goal of the two-channel split is to help us understand the proposed models can reach under different levels of difficulty.

As suggested in~\citep{zellers2018swag}, there might be annotation artifacts and conditional stylistic patterns such as length and word-preference biases, which can allow shallow models (e.g. bag-of-words) to obtain artificially high performance. Therefore, we design a negative rewriting strategy to minimize such linguistic cues or patterns. Instead of letting the annotators write negative statements from scratch, we let them rewrite the collected entailed statements. During the annotation, the workers are explicitly guided to modify the words, phrases or sentence structures but retain the sentence style/length to prevent artificial cues. We disallow naive negations by adding ``not, never, etc" to revert the statement polarity in case of obvious linguistic patterns.
\subsection{Quality Control}
To control the quality of the annotation process, we review a randomly sampled statement from each HIT to decide whether the whole annotation job should be rejected during the annotation process. Specifically, a HIT must satisfy the following criteria to be accepted: (i) the statements should contain neither typos nor grammatical errors. (ii) the statements do not contain vague claims like “might”, “few”, etc. (iii) the claims should be explicitly supported or contradicted by the table without requiring the additional knowledge, no middle ground is permitted. After the data collection, we re-distribute all the annotated samples to further filter erroneous statements, the workers are paid 0.05 USD per statement to decide whether the statement should be rejected. The criteria we apply are similar: no ambiguity, no typos, explicitly supported or contradictory. Through the post-filtering process, roughly 18\% entailed and 27\% refuted instances are further abandoned due to poor quality.
\begin{figure}[thb]
    \centering
    \includegraphics[width=0.9\linewidth]{distribution.pdf}
    \caption{Proportion of different higher-order operations from the simple/complex channels.}
    \vspace{-2ex}
    \label{fig:channel}
\end{figure}

\begin{table}[thb]
    \centering
    \small
    \begin{tabular}{lcccc|ccccc} 
    \toprule
Channel & \#Sentence & \#Table & Len(Ent) & Len(Ref) & Split & \#Sentence &  Table & Row & Col\\
    \midrule
     Simple                             & 50,244                                       & 9,189                                          & 13.2 & 13.1  & Train & 92,283 & 13,182 & 14.1 & 5.5       \\
    Complex                             & 68,031                                       & 7,392                                          & 14.2 & 14.2  & Val & 12,792 & 1,696 & 14.0 & 5.4        \\
    Total                               &      118,275                                 & 16,573                                         & 13.8 & 13.8 & Test & 12,779 & 1,695 & 14.2 & 5.4        \\
    \bottomrule
    \end{tabular}
    \caption{Basic statistics of the data collected from the simple/complex channel and the division of Train/Val/Test Split in the dataset, where ``Len" denotes the averaged sentence length.}
    \label{tab:train_val_test}
\vspace{-4ex}
\end{table}

\subsection{Dataset Statistics}
\textbf{Inter-Annotator Agreement}: 
After the data collection pipeline, we merged the instances from two different channels to obtain a diverse yet clean dataset for table-based fact verification. We sample 1000 annotated (table, statement) pairs and re-distribute each to 5 individual workers to re-label them as either {\tt ENTAILED} or {\tt REFUTED}. We follow the previous works~\citep{thorne2018fever,bowman2015large} to adopt the Fleiss Kappa ~\citep{fleiss1971measuring} as an indicator, where Fleiss  is computed from from the observed agreement  and the agreement by chance . We obtain a Fleiss , which indicates strong inter-annotator agreement and good-quality. 

\noindent \textbf{Dataset Statistics}: As shown in~\autoref{tab:train_val_test}, the amount of data harvested via the complex channel slightly outnumbers the simple channel, the averaged length of both the positive and negative samples are indistinguishable. More specifically, to analyze to which extent the higher-order operations are included in two channels, we group the common higher-order operations into 8 different categories. As shown in ~\autoref{fig:channel}, we sample 200 sentences from two different channels to visualize their distribution. We can see that the complex channel overwhelms the simple channel in terms of the higher-order logic, among which, count and superlatives are the most frequent. We split the whole data roughly with 8:1:1 into train, validation\footnote{We filter roughly 400 sentences from abnormal tables including hyperlinks, math symbols, etc}, and test splits and shows their statistics in~\autoref{tab:train_val_test}. Each table with an average of 14 rows and 5-6 columns corresponds to 2-20 different statements, while each cell has an average of 2.1 words. In the training split, the positive instances slightly outnumber the negative instances, while the validation and test split both have rather balanced distributions over positive and negative instances. 

\section{Models}
With the collected dataset, we now formally define the table-based fact verification task: the dataset is comprised of triple instances  consisting of a table , a natural language statement  and a verification label . The table  has  rows and  columns with the  being the content in the -th cell.  could be a word, a number, a phrase, or even a natural language sentence. The statement S describes a fact to be verified against the content in the table . If it is entailed by , then , otherwise the label . \autoref{fig:table} shows some entailed and refuted examples. During training, the model and the learning algorithm are presented with  instances like  from the training split. In the testing stage, the model is presented with  and supposed to predict the label as . We measure the performance by the prediction accuracy  on the test set. Before building the model, we first perform entity linking to detect all the entities in the statements. Briefly, we first lemmatize the words and search for the longest sub-string matching pairs between statements and table cells/captions, where the matched phrases are denoted as the linked entities. To focus on statement verification against the table, we do not feed the caption to the model and simply mask the phrases in the statements which link to the caption with placeholders. The details of the entity linker are listed in the Appendix. We describe our two proposed models as follows.

\subsection{Latent Program Algorithm (LPA)}
In this approach, we formulate the table fact verification as a program synthesis problem, where the latent program algorithm is not given in \textsc{TabFact}. Thus, it can be seen as a weakly supervised learning problem as discussed in~\citet{liang2017neural,lao2011random}. Under such a setting, we propose to break down the verification into two stages: (i) latent program search, (ii) discriminator ranking. 
In the first program synthesis step, we aim to parse the statement into programs to represent its semantics. We define the plausible API set to include roughly 50 different functions like \textit{min, max, count, average, filter, and} and realize their interpreter with Python-Pandas. Each API is defined to take arguments of specific types (\emph{number, string, bool, and view (e.g sub-table)}) to output specific-type variables. During the program execution, we store the generated intermediate variables to different-typed caches  (Num, Str, Bool, View). At each execution step, the program can fetch the intermediate variable from the caches to achieve semantic compositionality. In order to shrink the search space, we follow NSM~\citep{liang2017neural} to use trigger words to prune the API set and accelerate the search speed. The definitions of all API, trigger words can be found in the Appendix. 
\begin{algorithm}[thb]
\small
\caption{Latent Program Search with Comments}\label{alg:LPA}
\begin{algorithmic}[1]
\State Initialize Number Cache , String Cache , Bool Cache , View Cache  
\State Push linked numbers, strings from the given statement  into , and push  into 
\State Initialize the result collector  and an empty program trace 
\State Initialize the Queue , we use  to store the intermediate states
\State Use trigger words to find plausible function set , for example,  will trigger  function.
\While{loop over time }:
\While{}:
\While{loop over function set }:
\If {arguments of  are in the caches}
\State Pop out the required arguments  for different cachess.
\State Execute  and concatenate the program trace .
\If {Type(A)=Bool}
\If {}
\State  \# The program  is valid since it consumes all the variables.
\State  \# Collect the valid program  into set  and reset 
\Else
\State  \# The intermediate boolean value is added to the bool cache
\State  \# Add the refreshed state to the queue again
\EndIf
\EndIf
\If {Type(A)  \{Num, Str, View\}}
\If {}
\State ;break \# The program ends without consuming the cache, throw it.
\Else
\State push  into  or  or  \# Add the refreshed state to the queue for further search
\State 
\EndIf
\EndIf
\EndIf
\EndWhile
\EndWhile
\EndWhile
\State Return the triple  \# Return (Table, Statement, Program Set)
\end{algorithmic}
\end{algorithm}
The comprehensive the latent program search procedure is summarized in Algorithm~\ref{alg:LPA}, and  the searching procedure is illustrated in~\autoref{fig:program}. 
\begin{figure*}[thb]
    \centering
    \includegraphics[width=0.90\linewidth]{program.pdf}
    \caption{The program  synthesis procedure for the table in~\autoref{fig:table}. We link the entity (e.g. \textit{democratic}, \textit{republican}), and then composite functions on the fly to return the values from the table.}
    \vspace{-3ex}
    \label{fig:program}
\end{figure*}

After we collected all the potential program candidates  for a given statement  (where  refers to -th candidate), we need to learn a discriminator to identify the ``appropriate" traces from the set from many erroneous and spurious traces. Since we do not have the ground truth label about such discriminator, we use a weakly supervised training algorithm by viewing all the label-consistent programs as positive instances   and the label-inconsistent program as negative instances  to minimize the cross-entropy of discriminator  with the weakly supervised label.  Specifically, we build our discriminator with a Transformer-based two-way encoder~\citep{vaswani2017attention}, where the statement encoder encodes the input statement  as a vector  with dimension , while the program encoder encodes the program  as another vector , we concatenate these two vectors and feed it into a linear projection layer to compute  as the relevance between S and  with weight . At test time, we use the discriminator  to assign confidence  to each candidate , and then either aggregate the prediction from all hypothesis with the confidence weights or rank the highest-confident hypothesis and use their outputs as the prediction. 

\subsection{Table-BERT}
In this approach, we view the table verification problem as a two-sequence binary classification problem like NLI or MPRC~\citep{wang2018glue} by linearizing a table  into a sequence and treating the statement as another sequence. Since the linearized table can be extremely long surpassing the limit of sequence models like LSTM, Transformers, etc. We propose to shrink the sequence by only retaining the columns containing entities linked to the statement to alleviate such a memory issue. In order to encode such sub-table as a sequence, we propose two different linearization methods, as is depicted in~\autoref{fig:BERT}. (i) Concatenation: we simply concatenate the table cells with SEP tokens in between and restart position counter at the cell boundaries; the column name is fed as another type embedding to the input layer. Such design retains the table information in its machine format. (ii) Template: we adopt simple natural language templates to transform a table into a ``somewhat natural" sentence. Taking the horizontal scan as an example, we linearize a table as ``row one's game is 51; the date is February; ..., the score is 3.4 (ot). row 2 is ...". The isolated cells are connected with punctuations and copula verbs in a language-like format. 

After obtaining the linearized sub-table , we concatenate it with the natural language statement S and prefix a [CLS] token to the sentence to obtain the sequence-level representation , with  from pre-trained BERT~\citep{devlin2018bert}. The representation is further fed into multi-layer perceptron  to obtain the entailment probability , where  is the sigmoid function. We finetune the model  (including the parameters of BERT and MLP)  to minimize the binary cross entropy  on the training set.
\begin{figure*}
    \centering
    \includegraphics[width=0.95\linewidth]{BERT.pdf}
    \vspace{-2ex}
    \caption{The diagram of Table-BERT with horizontal scan, two different linearizations are depicted. }
    \label{fig:BERT}
    \vspace{-2ex}
\end{figure*}
At test time, we use the trained BERT model to compute the matching probability between the (table, statement) pair, and classify it as {\tt ENTAILED} statement when  is greater than 0.5.

\section{Experiments}
\label{Sec:Experiments}
In this section, we aim to evaluate the proposed methods on \textsc{TabFact}. Besides the standard validation and test sets, we also split the test set into a simple and a complex partition based on the channel from which they were collected. This facilitates analyzing how well the model performs under different levels of difficulty. Additionally, we also hold out a small test set with 2K samples for human evaluation, where we distribute each (table, statement) pair to 5 different workers to approximate human judgments based on their majority voting, the results are reported in~\autoref{tab:result}.
\begin{table*}[thb]
\centering
\small
\begin{tabular}{lccccc} 
\toprule
Model & \multicolumn{1}{l}{Val} & \multicolumn{1}{l}{Test} & Test (simple) & Test (complex) & Small Test  \\ 
\midrule
BERT classifier w/o Table                  & 50.9                    & 50.5 & 51.0 &      50.1               & 50.4        \\ 
\midrule
Table-BERT-Horizontal-F+T-Concatenate   & 50.7           & 50.4          & 50.8          &  50.0          & 50.3                  \\
Table-BERT-Vertical-F+T-Template    & 56.7           & 56.2          & 59.8          &  55.0          & 56.2                \\
Table-BERT-Vertical-T+F-Template    & 56.7           & 57.0          & 60.6          &  54.3          & 55.5               \\ 
Table-BERT-Horizontal-F+T-Template  & 66.0           & 65.1          & 79.0          &  58.1          & 67.9               \\
Table-BERT-Horizontal-T+F-Template  & \textbf{66.1}  & \textbf{65.1} & \textbf{79.1} &  \textbf{58.2} & \textbf{68.1}      \\ 
\midrule
NSM w/ RL (Binary Reward) & 54.1 &  54.1 & 55.4 & 53.1  &  55.8 \\
NSM w/ LPA-guided ML + RL & 63.2 &  63.5 & 77.4 & 56.1  &  66.9 \\
LPA-Voting w/o Discriminator  &     57.7                &                 58.2 & 68.5  &  53.2        &       61.5     \\
LPA-Weighted-Voting  &          62.5     &  63.1    &   74.6 &    57.3       &         66.8   \\
LPA-Ranking w/ Discriminator          & \textbf{65.2}                    & 65.0                 &  78.4 &    \textbf{58.5}      & 68.6         \\ 
LPA-Ranking w/ Discriminator (Caption)  & 65.1                    & \textbf{65.3}                 &  \textbf{78.7} &    \textbf{58.5}      & \textbf{68.9}         \\ 
\midrule
Human Performance                  &  -                      &      -  &  - & -      & \textbf{92.1}                      \\
\bottomrule
\end{tabular} 
\caption{The results of different models, the numbers are in percentage. T+F means table followed by fact, while F+T means fact followed by table. NSM is modified from~\cite{liang2017neural}.}
\label{tab:result}
\vspace{-3ex}
\end{table*}


\noindent \textbf{NSM}
We follow~\cite{liang2017neural} to modify their approach to fit the setting of \textsc{TabFact}. Specifically, we adopt an LSTM as an encoder and another LSTM with copy mechanism as a decoder to synthesize the program. However, without any ground truth annotation for the intermediate programs, directly training with reinforcement learning is difficult as the binary reward is under-specified, which is listed in~\autoref{tab:result} as "NSM w/ RL". Further, we use LPA as a teacher to search the top programs for the NSM to bootstrap and then use reinforcement learning to finetune the model, which achieves reasonable performance on our dataset listed as "NSM w/ ML + RL". \vspace{3px}\\
\noindent \textbf{Table-BERT}
We build Table-BERT based on the open-source implementation of BERT\footnote{\url{https://github.com/huggingface/pytorch-pretrained-BERT}} using the pre-trained model with 12-layer, 768-hidden, 12-heads, and 110M parameters trained in 104 languages. We use the standard BERT tokenizer to break the words in both statements and tables into subwords and join the two sequences with a [SEP] token in between. The representation corresponding to [CLS] is fed into an MLP layer to predict the verification label. We finetune the model on a single TITAN X GPU with a mini-batch size of 6. The best performance is reached after about 3 hours of training (around 10K steps). We implement and compare the following variants of the Table-BERT model including (i) Concatenation vs. Template: whether to use natural language templates during linearization. (ii) Horizontal vs. Vertical: scan direction in linearization. \vspace{3px}\\
\noindent \textbf{LPA}
We run the latent program search in a distributed fashion on three 64-core machines to generate the latent programs. The search terminates once the buffer has more than 50 traces or the path length is larger than 7. The average search time for each statement is about 2.5s. For the discriminator model, we design two transformer-based encoders (3 layers, 128-dimension hidden embedding, and 4 heads at each layer) to encode the programs and statements, respectively. The variants of LPA models considered include (i) Voting: assign each program with equal weight and vote without the learned discriminator. (ii) Weighted-Voting: compute a weighted-sum to aggregate the predictions of all latent programs with the discriminator confidence as the weights. (iii) Ranking: rank all the hypotheses by the discriminator confidence and use the top-rated hypothesis as the output. (Caption) means feeding the caption as a sequence of words to the discriminator during ranking. \vspace{3px}\\
\noindent \textbf{Preliminary Evaluation}
In order to test whether our negative rewriting strategy eliminates the artifacts or shallow cues, we also fine-tune a pre-trained BERT~\citep{devlin2018bert} to classify the statement  without feeding in table information. The result is reported as ``BERT classifier w/o Table" in~\autoref{tab:result}, which is approximately the majority guess and reflects the effectiveness of the rewriting strategy. Before presenting the experiment results, we first perform a preliminary study to evaluate how well the entity linking system, program search, and the statement-program discriminator perform. Since we do not have the ground truth labels for these models, we randomly sample 100 samples from the dev set to perform the human study. For the entity linking, we evaluate its accuracy as the number of correctly linked sentences / total sentences. For the latent program search, we evaluate whether the ``true" programs are included in the candidate set  as recall score.
\nop{
\begin{table}[thb]
\small
\centering
\begin{tabular}{lcc|cccc} 
\toprule
Steps  & Accuracy\% & Recall\% & Discriminator  & HITS@1 & HITS@3 & HITS@5\\
\midrule
Entity Linking & 58 & - & LSTM & 17 & 24  & 29 \\
\midrule
Systematic Search & - & 51 & Transformer & 19 & 28  & 32 \\
\bottomrule
\end{tabular}
\caption{Case Study results on different components, including the entity linking accuracy, systematic search recall (when the entity linking is correct, the chance of correct program included in the top 100 program candidates), and discriminator accuracy.}
\label{tab:case_study}
\vspace{-4ex}
\end{table}
}
\paragraph{Results}
We report the performance of different methods as well as human performance in~\autoref{tab:result}. First of all, we observe that the naive serialized model fails to learn anything effective (same as the Majority Guess). It reveals the importance of template when using the pre-trained BERT~\citep{devlin2018bert} model: the ``natural" connection words between individual cells is able to unleash the power of the large pre-trained language model and enable it to perform reasoning on the structured table form. Such behavior is understandable given the fact that BERT is pre-trained on purely natural language corpora. In addition, we also observe that the horizontal scan excels in the vertical scan because it better captures the convention of human expression. Among different LPA methods, we found that LPA-Ranking performs the best since it can better suppress the spurious programs than the voting-based algorithm. Overall, the LPA model is on par with Table-BERT on both simple and test split without any pre-training on external corpus, which reflects the effectiveness of LPA to leverage symbolic operations in the verification process.  

Through our human evaluation, we found that only 58\% of sentences have been correctly linked without missing-link or over-link, while the systematic search has a recall of 51\% under the cases where the sentence is correctly linked. With that being said, the chance for LPA method to cover the correct program (rationale) is roughly under 30\%. After the discriminator's re-ranking step, the probability of selecting these particular oracle program is even much lower. However, we still observe a final overall accuracy of 65\%, which indicates that the spurious problem is quite severe in LPA, where the correct label is predicted based on the wrong reason.  

Through our human evaluation, we also observe that Table-BERT exhibits poor consistency as it can misclassify simple cases but correctly-classify hard cases. These two major weaknesses are yet to be solved in future studies. In contrast, LPA behaves much more consistently and provides a clear latent rationale for its decision. But, such a pipeline system requires laborious handcrafting of API operations and is also very sensitive to the entity linking accuracy. Both methods have pros and cons; how to combine them still remains an open question.

\paragraph{Program Annotation}
To further promote the development of different models in our dataset, we collect roughly 1400 human-annotated programs paired with the original statements. These statements include the most popular logical operations like superlative, counting, comparison, unique, etc. We provide these annotations in Github\footnote{\url{https://github.com/wenhuchen/Table-Fact-Checking/tree/master/bootstrap}}, which can either be used to bootstrap the semantic parsers or provide the rationale for  NLI models.  


\section{Related Work}
\noindent \textbf{Natural Language Inference \& Reasoning:}
Modeling reasoning and inference in human language is a fundamental and challenging problem towards true natural language understanding. There has been extensive research on RTE in the early years~\citep{dagan2005pascal} and more recently shifted to NLI~\citep{bowman2015large,williams2017broad}. NLI seeks to determine whether a natural language hypothesis  can be inferred from a natural language premise . With the surge of deep learning, there have been many powerful algorithms like the Decomposed Model~\citep{parikh2016decomposable}, Enhanced-LSTM~\citep{chen2017enhanced} and BERT~\citep{devlin2018bert}. Besides the textual evidence, NLVR~\citep{suhr2017corpus} and NLVR2~\citep{suhr2019corpus} have been proposed to use images as the evidence for statement verification on multi-modal setting. Our proposed fact verification task is closely related to these inference tasks, where our semi-structured table can be seen as a collection of ``premises" exhibited in a semi-structured format. Our proposed problem hence could be viewed as the generalization of NLI under the semi-structured domain.\vspace{3px}\\
\noindent \textbf{Table Question Answering:}
Another line of research closely related to our task is the table-based question answering, such as MCQ~\citep{jauhar2016tables}, WikiTableQuestion~\citep{pasupat2015compositional}, Spider~\citep{yu2018spider}, Sequential Q\&A~\citep{iyyer2017search}, and WikiSQL~\citep{zhong2017seq2sql}, for which approaches have been extended to handle large-scale tables from Wikipedia~\citep{bhagavatula2013methods}. However, in these Q\&A tasks, the question types typically provide strong signals needed for identifying the type of answers, while \textsc{TabFact} does not provide such specificity. The uniqueness of \textsc{TabFact} lies in two folds: 1) a given fact is regarded as a false claim as long as any part of the statement contains misinformation. Due to the conjunctive nature of verification, a fact needs to be broken down into several sub-clauses or (Q, A) pairs to separate evaluate their correctness. Such a compositional nature of the verification problem makes it more challenging than a standard QA setting. On one hand, the model needs to recognize the multiple QA pairs and their relationship. On the other hand, the multiple sub-clauses make the semantic form longer and logic inference harder than the standard QA setting. 2) some facts cannot even be handled using semantic forms, as they are driven by linguistic inference or common sense. In order to verify these statements, more inference techniques have to be leveraged to enable robust verification. We visualize the above two characteristics of \textsc{TabFact} in~\autoref{fig:difference}.
\begin{figure*}
    \centering
    \includegraphics[width=0.95\linewidth]{Diff-QA.pdf}
    \vspace{-2ex}
    \caption{The two uniqueness of Table-based fact verification against standard QA problems. }
    \label{fig:difference}
    \vspace{-2ex}
\end{figure*}

\noindent \textbf{Program Synthesis \& Semantic Parsing:}
There have also been great interests in using program synthesis or logic forms to solve different natural language processing problems like question answering~\citep{liang2013learning,berant2013semantic,berant2014semantic}, visual navigation~\citep{artzi2014learning,artzi2013weakly}, code generation~\citep{yin2017syntactic,dong2016language}, SQL synthesis~\citep{yu2018spider}, etc. The traditional semantic parsing papers~\citep{artzi2014learning,artzi2013weakly,zettlemoyer2005learning,liang2013learning,berant2013semantic} greatly rely on rules, lexicon to parse natural language sentences into different forms like lambda calculus, DCS, etc. More recently, researchers strive to propose neural models to directly perform end-to-end formal reasoning like Theory Prover~\citep{riedel2016programming,rocktaschel2017end}, Neural Turing Machine~\citep{graves2014neural}, Neural Programmer~\citep{neelakantan2016neural,neelakantan2017learning} and Neural-Symbolic Machines~\citep{liang2017neural,liang2018memory,agarwal2019learning}. The proposed \textsc{TabFact} serves as a great benchmark to evaluate the reasoning ability of different neural reasoning models. Specifically, \textsc{TabFact} poses the following challenges: 1) spurious programs (i.e., wrong programs with the true returned answers): since the program output is only a binary label, which can cause serious spurious problems and misguide the reinforcement learning with the under-specified binary rewards. 2) decomposition: the model needs to decompose the statement into sub-clauses and verify the sub-clauses one by one, which normally requires the longer logic inference chains to infer the statement verdict. 3) linguistic reasoning like inference and paraphrasing.  \vspace{3px}\\

\noindent \textbf{Fact Checking}
The problem of verifying claims and hypotheses on the web has drawn significant attention recently due to its high social influence. Different fact-checking pioneering studies have been performed including LIAR~\citep{wang2017liar}, PolitiFact~\citep{vlachos2014fact}, FEVER~\citep{thorne2018fever} and AggChecker~\citep{jo2019aggchecker}, etc. The former three studies are mainly based on textual evidence on social media or Wikipedia, while AggChecker is closest to ours in using relational databases as the evidence. Compared to AggChecker, our paper proposes a much larger dataset to benchmark the progress in this direction. 

\section{Conclusion}
This paper investigates a very important yet previously under-explored research problem: semi-structured fact verification. We construct a large-scale dataset and proposed two methods, Table-BERT and LPA, based on the state-of-the-art pre-trained natural language inference model and program synthesis. In the future, we plan to push forward this research direction by inspiring more sophisticated architectures that can perform both linguistic and symbolic reasoning. 

\bibliography{iclr2020_conference}
\bibliographystyle{iclr2020_conference}

\appendix
\clearpage
\section{Appendix}
\subsection{Function Description}
We list the detailed function description in~\autoref{fig:functions}.
\begin{figure}[htb]
    \centering
    \includegraphics[width=1.0\linewidth]{APIs.pdf}
    \caption{The function definition used in TabFact.}
    \label{fig:functions}
\end{figure}
We also visualize the functionality of the most typical functions and their input/output examples in~\autoref{fig:diagram}.
\begin{figure}[htb]
    \centering
    \includegraphics[width=1.0\linewidth]{function-diagram.pdf}
    \caption{The visualization of different functions.}
    \label{fig:diagram}
\end{figure}

We list all the trigger words for different functions in~\autoref{fig:triggers}
\begin{figure}[htb]
    \centering
    \includegraphics[width=1.0\linewidth]{trigger.pdf}
    \caption{The trigger words used to shrink the search space.}
    \label{fig:triggers}
\end{figure}

\section{Higher-order Operations}
\label{app-ops}
\begin{enumerate}
    \item Aggregation: the aggregation operation refers to sentences like ``the averaged age of all ....", ``the total amount of scores obtained in ...", etc.
    \item Negation: the negation operation refers to sentences like ``xxx did not get the best score", ``xxx has never obtained a score higher than 5".
    \item Superlative: the superlative operation refers to sentences like ``xxx achieves the highest score in", ``xxx is the lowest player in the team".
    \item Comparative: the comparative operation refers to sentences like ``xxx has a higher score than yyy".
    \item Ordinal: the ordinal operation refers to sentences like ``the first country to achieve xxx is xxx", ``xxx is the second oldest person in the country".
    \item Unique: the unique operation refers to sentences like ``there are 5 different nations in the tournament, ", ``there are no two different players from U.S"
    \item All: the for all operation refers to sentences like ``all of the trains are departing in the morning", ``none of the people are older than 25."
    \item None: the sentences which do not involve higher-order operations like ``xxx achieves 2 points in xxx game", ``xxx player is from xxx country".
\end{enumerate}

\section{Error Analysis}
Before we quantitatively demonstrate the error analysis of the two methods, we first theoretically analyze the bottlenecks of the two methods as follows:
\paragraph{Symbolic}
We first provide a case in which the symbolic execution can not deal with theoretically in~\autoref{fig:error_case}. The failure cases of symbolic are either due to the entity link problem or function coverage problem. For example, in the given statement below, there is no explicit mention of "7-5, 6-4" cell. Therefore, the entity linking model fails to link to this cell content. Furthermore, even though we can successfully link to this string, there is no defined function to parse "7-5, 6-5" as "won two games" because it requires linguistic/mathematical inference to understand the implication from the string. Such cases are the weakness of symbolic reasoning models.
\begin{figure}[thb]
    \centering
    \includegraphics[width=1.0\linewidth]{error-case.pdf}
    \caption{The error case of symbolic reasoning model}
    \label{fig:error_case}
\end{figure}
\paragraph{BERT}
In contrast, Table-BERT model seems to have no coverage problem as long as it can feed the whole table content. However, due to the template linearization, the table is unfolded into a long sequence as depicted in~\autoref{fig:error_case2}. The useful information, "clay" are separated in a very long span of unrelated words. How to grasp such a long dependency and memorize the history information poses a great challenge to the Table-BERT model.
\begin{figure}[thb]
    \centering
    \includegraphics[width=1.0\linewidth]{error-case2.pdf}
    \caption{The error case of BERT NLI model}
    \label{fig:error_case2}
\end{figure}
\paragraph{Statistics}
Here we pick 200 samples from the validation set which only involve single semantic and divide them into different categories. We denote the above-mentioned cases as "linguistic inference", and the sentences which only describe information from one row as "Trivial", the rest are based on their logic operation like Aggregation, Superlative, Count, etc. We visualize the accuracy of LPA and Table-BERT in~\autoref{fig:error_bar}. From which we can observe that the statements with linguistic inference are much better handled with the BERT model, while LPA achieves an accuracy barely higher than a random guess. The BERT model can deal with trivial cases well as it uses a horizontal scan order. In contrast, the LPA model outperforms BERT on higher-order logic cases, especially when the statement involves operations like Count and Superlative. 
\begin{figure}[thb]
    \centering
    \includegraphics[width=0.8\linewidth]{error-bar.pdf}
    \caption{The error analysis of two different models}
    \label{fig:error_bar}
\end{figure}

\section{Reasoning Depth}
Given that our LPA has the breadth to cover a large semantic space. Here we also show the reasoning depth in terms of how many logic inference steps are required to tackle verify the given claims. We visualize the histogram in~\autoref{fig:depth} and observe that the reasoning steps are concentrated between 4 to 7. Such statistics indicate the difficulty of fact verification in our \textsc{TabFact} dataset.
\begin{figure}[thb]
    \centering
    \includegraphics[width=0.7\linewidth]{reasoning-depth.pdf}
    \caption{The histogram of reasoning steps required to verify the claims}
    \label{fig:depth}
\end{figure}

\section{Whether to keep Wikipedia context}
Before crowd-sourcing the annotation for the tables, we observed that the previous WikiTableQuestion~\cite{pasupat2015compositional} provides context (Wikipedia title) during annotation while the WikiSQL~\cite{zhong2017seq2sql} does not. Therefore, we particularly design ablation annotation tasks to compare the annotation quality between w/ and w/o Wikipedia title as context. We demonstrate a typical example in~\autoref{fig:context}, where a Wiki table\footnote{\url{https://en.wikipedia.org/wiki/Dennis_Ralston}} aims to describe the achievements of a tennis player named Dennis, but itself does not provide any explicit hint about ``Tennis Player Dennis". Unsurprisingly, the sentence fluency and coherence significantly drop without such information. Actually, a great portion of these Wikipedia tables requires background knowledge (like sports, celebrity, music, etc) to understand. We perform a small user study to measure the fluency of annotated statements. Specifically, we collected 50 sentences from both annotation w/ and w/o title context and randomly shuffle them as pairs, which are distributed to the 8 experts without telling them their source to compare the language fluency. It turns out that the experts ubiquitously agree that the statements with Wikipedia titles are more human-readable. Therefore, we argue that such a context is necessary for annotators to understand the background knowledge to write more fluent sentences. On the other end, we also hope to minimize the influence of the textual context in the table-based verification task, therefore, we design an annotation criterion: the Wikipedia title is provided to the workers during the annotation, but they are explicitly banned from bringing any unrelated background information other than the title into the annotation. As illustrated in~\autoref{fig:context}, the title only acts as a placeholder in the statements to make it sound more natural.
\begin{figure}[!h]
    \centering
    \includegraphics[width=0.9\linewidth]{with_without_context.pdf}
    \caption{Comparison of worker annotation w/ and w/o Wikipedia title as context}
    \label{fig:context}
\end{figure}

\section{Entity Linking}
Here we propose to use the longest string match to find all the candidate entities in the table, when multiple candidates coexist, we select the one with the minimum edit distances. The visualization is demonstrated in~\autoref{fig:entity}.
\begin{figure}[!h]
    \centering
    \includegraphics[width=0.9\linewidth]{entity-linking.pdf}
    \caption{Entity Linking System.}
    \label{fig:entity}
\end{figure}

\section{The program candidates}
\label{app-apis}
Here we demonstrate some program candidates in~\autoref{fig:rerank}, and show how our proposed discriminator is designed to compute the matching probability between the statement and program. Specifically, we employ two transformer-based encoder~\cite{vaswani2017attention}, the left one is aimed to encode the program sequence and the right one is aimed to encode the statement sequence. Their output from [CLS] position is concatenated and fed into an MLP to classify the verification label. 
\begin{figure}[!h]
    \centering
    \includegraphics[width=1.0\linewidth]{re-ranking.pdf}
    \caption{We demonstrate the top program candidates and use the discriminator to rank them.}
    \label{fig:rerank}
\end{figure}

\section{HIT Interface}
We provide the human intelligent task interface on AMT in the following. Very detailed instructions on what are trivial statements and what are non-trivial statements. Comprehensive examples have been given to guide the Turkers to write well-formed while logically plausible statements. In order to harvest fake statements without statistical cues, we also provide detailed instructions on how to re-write the "fake" statements. During the annotation, we hire 8 experts to perform sanity checks on each of the HIT to make sure that the annotated dataset is clean and meets our requirements. 
\clearpage
\includepdf[pages=-]{HIT-Interface.pdf}
\includepdf[pages=-]{HIT-Interface-fake.pdf}


\end{document}
