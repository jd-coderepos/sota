

\ifx\SubmitVer\undefined
   \newcommand{\InSubmitVer}[1]{}\newcommand{\InNotSubmitVer}[1]{#1}\else
   \def\ProofInAppendix{TRUE}
   \newcommand{\InSubmitVer}[1]{#1}\newcommand{\InNotSubmitVer}[1]{}\fi


\InSubmitVer{\documentclass[11pt]{article}}
\InNotSubmitVer{\documentclass[12pt]{article}}



\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[cm]{fullpage}

\usepackage{paralist}
\usepackage{graphicx}   
\usepackage{caption}
\usepackage{color}
\usepackage{xspace}
\usepackage{picins}


\usepackage[cmyk]{xcolor}

\usepackage{hyperref}\hypersetup{breaklinks,ocgcolorlinks,
   colorlinks=true,linkcolor=[rgb]{0.45,0.0,0.0},citecolor=[rgb]{0,0,0.45}
}

\usepackage{euscript}\usepackage{amsmath}\usepackage[amsmath,amsthm,thmmarks]{ntheorem}
\theoremseparator{.}

\renewcommand\proofSymbol{\ensuremath{\rule{2mm}{2mm}}}

\usepackage{titlesec}
\titlelabel{\thetitle. }

\InSubmitVer{\usepackage{lineno}}


\numberwithin{figure}{section}
\numberwithin{table}{section}
\numberwithin{equation}{section}




\newtheorem{theorem}{Theorem}[section] \newtheorem{lemma}[theorem]{Lemma}

{\theorembodyfont{\rm}\newtheorem{defn}[theorem]{Definition}\newtheorem{observation}[theorem]{Observation}
   \newtheorem{problem}[theorem]{Problem}
}

\newlength{\savedparindent}
\newcommand{\SaveIndent}{\setlength{\savedparindent}{\parindent}}
\newcommand{\RestoreIndent}{\setlength{\parindent}{\savedparindent}}

\renewcommand{\Re}{{\rm I\!\hspace{-0.025em} R}}
\newcommand{\figlab}[1]{\label{fig:#1}}
\newcommand{\figref}[1]{Figure~\ref{fig:#1}}

\newcommand{\eqlab}[1]{\label{equation:#1}}
\newcommand{\Eqref}[1]{Eq.~(\ref{equation:#1})}
\newcommand{\Eqrefpage}[1]{Eq.~(\ref{equation:#1})}

\newcommand{\apndlab}[1]{\label{apnd:#1}}
\newcommand{\apndref}[1]{Appendix~\ref{apnd:#1}}

\newcommand{\lemlab}[1]{\label{lemma:#1}}
\newcommand{\lemref}[1]{Lemma~\ref{lemma:#1}}

\newcommand{\obslab}[1]{\label{observation:#1}}
\newcommand{\obsref}[1]{Observation~\ref{observation:#1}}

\newcommand{\seclab}[1]{\label{section:#1}}
\newcommand{\secref}[1]{Section~\ref{section:#1}}
\newcommand{\thmlab}[1]{\label{theorem:#1}}
\newcommand{\thmref}[1]{Theorem~\ref{theorem:#1}}
\newcommand{\thmrefpage}[1]{Theorem~\ref{theorem:#1}}

\providecommand{\deflab}[1]{\label{def:#1}}
\newcommand{\defref}[1]{Definition~\ref{def:#1}}
\newcommand{\defrefpage}[1]{Definition~\ref{def:#1}}


\newcommand{\blockerY}[2]{\mathrm{blocker{}Set}\pth{#1, #2}}

\newcommand{\CapSet}{\mathcal{C}}
\newcommand{\coneY}[2]{\mathrm{cone}\pth{#1, #2}}

\newcommand{\Term}[1]{\textsf{#1}}
\newcommand{\PTAS}{\Term{PTAS}\xspace}

\DefineNamedColor{named}{RedViolet} {cmyk}{0.07,0.90,0,0.34}

\newcommand{\AlgorithmI}[1]{{\textcolor[named]{RedViolet}{\texttt{\bf{#1}}}}}
\newcommand{\Algorithm}[1]{{\AlgorithmI{#1}\index{algorithm!#1@{\AlgorithmI{#1}}}}}

\newcommand{\GreedySeparator}{\Algorithm{GreedySeparator}\xspace}
\newcommand{\ConvexProjection}{\Algorithm{ConvexProjection}\xspace}

\newcommand{\etal}{\textit{et~al.}\xspace}

\newcommand{\inducedBall}[1]{\mathrm{ball}_{\mathrm{in}}\pth{#1}}
\newcommand{\Ring}{\mathcal{R}}

\newcommand{\emphind}[1]{\emph{#1}\index{#1}}
\definecolor{blue25}{rgb}{0,0,0.85}\newcommand{\emphic}[2]{\textcolor{blue25}{\textbf{\emph{#1}}}\index{#2}}

\newcommand{\emphi}[1]{\emphic{#1}{#1}}


\newcommand{\pth}[2][\!]{#1\left({#2}\right)}

\newcommand{\VorX}[1]{\mathcal{V} \pth{#1}}\newcommand{\VorCell}[2]{\mathcal{C}_{#2} \pth{#1}}\newcommand{\brc}[1]{\left\{ {#1} \right\}}\newcommand{\sep}[1]{\,\left|\, {#1} \MakeBig\right.}\newcommand{\dist}[2]{\left\| {#1} - {#2}  \right\|}

\newcommand{\distChar}{\mathsf{d}}\newcommand{\distSet}[2]{\distChar\pth{#1, #2}}
\newcommand{\MakeBig} {\rule[-.2cm]{0cm}{0.4cm}}
\newcommand{\MakeSBig}{\rule[0.0cm]{0.0cm}{0.39cm}} \newcommand{\MakesBig}{\rule[0.0cm]{0.0cm}{0.385cm}} 

\newcommand{\bisectorX}[2]{\beta_{#1, #2}}
\newcommand{\pencilX}[2]{\mathrm{pencil}\pth{#1, #2}}
\newcommand{\pencilF}[1]{\mathrm{pencil}\pth{#1}}
\newcommand{\pencilPnt}[2]{\mathrm{pencil}_{#1}\pth{#2}}
\newcommand{\pencilSet}[2]{\mathrm{pencil}_{#1}\pth{#2}}

\newcommand{\trailX}[1]{\mathrm{trail}\pth{#1}}

\newcommand{\mbX}[1]{\mathrm{mb}\pth{#1}}


\newcommand{\SarielThanks}[1]{\thanks{Department of Computer Science; University of Illinois; 201 N. Goodwin Avenue; Urbana, IL, 61801, USA; {\tt \url{http://sarielhp.org}.} #1}
}

\newcommand{\VijayThanks}[1]{\thanks{Department of Computer Science; University of Illinois; 201 N. Goodwin Avenue; Urbana, IL, 61801, USA; {\tt \url{http://vspvijay.com}.} #1
   }
}
\newcommand{\Sariel}[1]{{\XSays{Sariel}{#1}}}
\newcommand{\Vijay}[1]{{\XSays{Vijay}{#1}}}
\newcommand{\Ex}[2][\!]{\mathop{\mathbf{E}}#1\pbrcx{#2}}
\newcommand{\Prob}[1]{\mathop{\mathbf{Pr}}\!\pbrcx{#1}}
\newcommand{\XSays}[2]{{
      {\textcolor{red}{}\fbox{\tt
            #1:} }
      \textcolor{blue}{\bf #2}
      \marginpar{\textcolor{red}{#1}}
      {\textcolor{green}{\fbox{\tt
            end}}}
      }
   }
\newcommand{\cardin}[1]{\left| {#1} \right|}\newcommand{\si}[1]{#1}

\newcommand{\CHX}[1]{\mathcal{CH}\pth{#1}}
\newcommand{\eps}{{\varepsilon}}



\newcommand{\PntSet}{\mathsf{P}}\newcommand{\PntSetB}{\mathsf{Q}}

\newcommand{\SetL}{\mathsf{L}}\newcommand{\SetO}{\mathsf{O}}


\newcommand{\SetX}{\mathsf{X}}\newcommand{\SetY}{\mathsf{Y}}



\newcommand{\SepSet}{\mathcal{Z}}

\newcommand{\pnt}{\mathsf{p}}\newcommand{\pntA}{\mathsf{q}}\newcommand{\pntB}{\mathsf{s}}\newcommand{\pntC}{\mathsf{t}}

\newcommand{\setA}{\mathsf{X}}
\newcommand{\setB}{\mathsf{Y}}

\newcommand{\ballX}[2]{\mathrm{ball}\pth{#1, #2}}

\newcommand{\ballA}{b}
\newcommand{\ballB}{b'}

\newcommand{\leftover}{f}
\newcommand{\Leftover}{F}

\newcommand{\cenA}{\psi}


\newcommand{\sphereB}{\ensuremath{\mathbb{S}}}

\newcommand{\sphereC}{\sphereB'}

\newcommand{\radiusX}[1]{\mathrm{radius}\pth{#1}}

\newcommand{\radA}{{r}}
\newcommand{\radB}{{r}'}

\providecommand{\pbrc}[2][\!\!]{#1\left[ {#2} \MakeBig \right]}
\providecommand{\pbrcS}[2][]{\left[ {#2} \right]}
\providecommand{\pbrcx}[1]{\left[ {#1} \right]}


\providecommand{\ceil}[1]{\left\lceil {#1} \right\rceil}
\providecommand{\floor}[1]{\left\lfloor {#1} \right\rfloor}


\newcommand{\radN}{\ell}

\newcommand{\dblCd}{c^d_{\mathrm{dbl}}}
\newcommand{\constSep}{c_{\mathrm{sep}}}


\newcommand{\VV}{\mathcal{V}}
\newcommand{\List}{L}
\newcommand{\ListA}{L'}

\newcommand{\infdist}[2]{\left\| {#1} - {#2}  \right\|_\infty}

\newcommand{\nGuard}{\mathrm{g}}
\newcommand{\maxGuard}{\mathsf{b}}

\newcommand{\SetofSystems}{\mathcal{S}}
\newcommand{\System}{\mathrm{S}}
\newcommand{\bSystem}{\mathrm{S_{big}}}

\newcommand{\handleX}[2]{\mathrm{handle}\pth{#1, #2}}
\newcommand{\HH}{\mathcal{H}}\newcommand{\HHB}{\mathcal{G}}



\newcommand{\coreX}[2]{\mathrm{core}\pth{#1, #2}}
\newcommand{\CC}{\mathcal{C}}
\newcommand{\districtX}[2]{\mathrm{district}\pth{#1, #2}}

\newcommand{\lockx}[3]{X\pth{#1, #2, #3}}
\newcommand{\locky}[3]{Y\pth{#1, #2, #3}}

\newcommand{\PP}{\mathcal{P}}


\newcommand{\circlef}[3]{\mathcal{C}^{#1,#2,#3}}
\newcommand{\linef}[2]{\mathcal{L}^{#1,#2}}

\newcommand{\lineX}[2]{\overline{#1#2}}
\newcommand{\linesegX}[2]{\overline{#1#2}}

\newcommand{\lock}[3]{I\pth{#1,#2,#3}}
\newcommand{\substleq}[2]{J\pth{#1,#2}}
\newcommand{\oppsides}[3]{L\pth{#1,#2,#3}}

\newcommand{\grd}{\mathsf{g}}

\newcommand{\minseg}[1]{\mathcal{M}\pth{#1}}
\newcommand{\minsege}[1]{\mathcal{M'}\pth{#1}}
\newcommand{\minsegpt}[1]{\mathcal{M}_g\pth{#1}}
\newcommand{\minsegpte}[1]{\mathcal{M'}_g\pth{#1}}

\newcommand{\BadBallsA}{\mathcal{B}}
\newcommand{\BadBalls}[3]{\mathcal{B}\pth{#1, #2, #3}}
\newcommand{\violatorX}[3]{\mathcal{BP}\pth{#1, #2, #3}}
\newcommand{\bFeaturesX}[4][\!]{\mathcal{F}_{\mathrm{bad}}\pth[#1]{#2, #3,
      #4}}

\newcommand{\BallSetA}{X}

\newcommand{\Grid}{\mathsf{G}}
\newcommand{\Cell}{C}
\newcommand{\projY}[2]{\mathsf{nn}\pth{#1,#2}}
\newcommand{\projX}[1]{\mathsf{nn}\pth{#1}}


\newcommand{\lengthX}[1]{\mathrm{len}\pth{#1}}

\newcommand{\feature}{\mathsf{f}}
\newcommand{\sitesX}[1]{\mathrm{sites}\pth{#1}}

\newcommand{\spanF}[1]{\mathrm{span}\pth{#1}}

\newcommand{\bisectorF}[1]{\mathrm{bisector}\pth{#1}}
\newcommand{\halfspaceX}[2]{\mathcal{H}\pth{#1,#2}}



\newcommand{\shellF}[1]{\mathrm{shell}\pth{#1}}

\newcommand{\indet}[2]{\mathcal{ID}\pth{#1,#2}}


\newcommand{\annihilateF}[2]{\mathcal{A}_{#1}\pth{#2}}
\newcommand{\annihilateFX}[1]{\mathcal{A}_{#1}}

\newcommand{\Flat}{\mathsf{F}}

\newcommand{\annihilateX}[1]{\mathcal{A}\pth{#1}}

\newcommand{\Graph}{\mathsf{G}}\newcommand{\Vertices}{\mathsf{V}}\newcommand{\Edges}{\mathsf{E}}

\newcommand{\hitSetSizeX}[1]{\nu\pth{#1}}


\renewcommand{\th}{\si{th}\xspace}



\newcommand{\simplex}{\Delta}
\newcommand{\nnX}[2]{\mathsf{nn}\pth{#1, #2}}

\newcommand{\iffT}{if and only if\xspace}


\newcommand{\OPTH}[1]{\mathrm{OPT}_{#1}}



\DefineNamedColor{named}{OliveGreen}{cmyk}{0.64, 0, 0.95, 0.40}


\providecommand{\ComplexityClass}[1]{{{\textcolor[named]{OliveGreen}{\textsc{#1}}}}}

 
\providecommand{\NPHard}{{\ComplexityClass{NP-Hard}}\index{NP!hard}\xspace}

\newcommand{\remove}[1]{}

\newcommand{\oSepSetB}{T}

\newcommand{\leftoverSep}{\mathsf{Z}}

\newcommand{\oSepSet}{\SepSet^{\sphereB}}\newcommand{\SetXX}{\Xi}

\newcommand{\itemlab}[1]{\label{item:#1}}
\newcommand{\itemref}[1]{(\ref{item:#1})}

\newcommand{\pitemlab}[1]{\label{p:item:#1}}
\newcommand{\pitemref}[1]{(P\ref{p:item:#1})}

\newcommand{\pitemrefpage}[1]{(P\ref{p:item:#1})}


\newcommand{\lSize}{\ell}

\newcommand{\Lopt}{\mathcal{L}}
\newcommand{\Opt}{\mathcal{O}}

\newcommand{\SetBalls}{\EuScript{B}}\newcommand{\SetBallsIn}[1]{\SetBalls^{\mathrm{in}}_{#1}}
\newcommand{\SetBallsBd}[1]{\SetBalls^{\partial}_{#1}}

\newcommand{\ds}{\displaystyle}

\newcommand{\ArrX}[1]{\mathcal{A}\pth{#1}}

\newcommand{\Assign}{:=}

\providecommand{\CodeComment}[1]{\textcolor{blue}{\texttt{#1}}}


\newenvironment{myprogram}{
   \begin{minipage}{4.0in}
   \begin{tabbing}
       \ \ \ \ \= \ \ \ \= \ \ \ \ \= \ \ \ \ \= \ \ \ \ \=
      \ \ \ \ \= \ \ \ \ \= \ \ \ \ \= \ \ \ \ \=
      \ \ \ \ \= \ \ \ \ \= \ \ \ \ \= \ \ \ \ \= \kill
}{
   \end{tabbing}
   \end{minipage}
}

\newcommand{\AlgorithmBox}[1]{
   \fbox{\begin{myprogram} 
          #1
          \end{myprogram}
       }
   }
\newcommand{\Do}{{\small\bf do}\ }
\newcommand{\End}{{\small\bf end}\ }
\newcommand{\Return}{{\small\bf return\ }}
\newcommand{\Proc}[1]{#1\+}
\newcommand{\Returns}{{\small\bf returns}}
\newcommand{\Procbegin}{{\small\bf begin}}
\newcommand{\If}{{\small\bf if}\ }
\newcommand{\Then}{{\small\bf then}\ }
\newcommand{\Else}{{\small\bf else}\ }
\newcommand{\rElse}{{\small\bf else}\ }
\newcommand{\Elseif}{{\small\bf elseif}\ }
\newcommand{\Foreach}{{\small\bf for each}\ }
\newcommand{\Endif}{{\small\bf end\ if\ }}
\newcommand{\Break}{{\small\bf break }}
\newcommand{\Endproc}[1]{{\small\bf end} #1}
\newcommand{\For}{{\small\bf for}\ }
\newcommand{\Endfor}{{\small\bf end\ for}}
\newcommand{\While}{{\small\bf while}\ }
\newcommand{\Endwhile}{{\small\bf end\ while}}
\newcommand{\LogAnd}{{\small\bf and}}

\newcommand{\Repeat}{{\small\bf repeat}\ }
\newcommand{\Until}{{\small\bf Until}}
\newcommand{\Loop}{{\bf loop}\ }
\newcommand{\Endloop}{{\bf end\ loop}\ }

\newcommand{\algClusterLocal}{\Algorithm{ClusterLocalOpt}\xspace}

\newcommand{\lChuckSize}{\lambda}

\newcommand{\Iterations}{I}









\begin{document}

\InSubmitVer{\linenumbers}

\title{Separating a Voronoi Diagram via Local Search\footnote{Work on this paper by the second author was partially supported
      by NSF AF award CCF-0915984, and NSF AF award CCF-1217462.}}

\author{Vijay V. S. P.  Bhattiprolu\VijayThanks{}\and Sariel Har-Peled\SarielThanks{}}\date{\today}

\maketitle

\begin{abstract}
    Given a set  of  points in , we show how to
    insert a set  of  additional points,
    such that  can be broken into two sets  and
    , of roughly equal size, such that in the Voronoi
    diagram , the cells of  do
    not touch the cells of ; that is,  separates
     from  in the Voronoi diagram (or in the
    dual Delaunay triangulation).  Given such a partition
     of , we present approximation
    algorithms to compute the minimum size separator realizing this
    partition.

    Finally, we present a simple local search algorithm that is a
    \PTAS for geometric hitting set of fat objects (which can also be
    used to approximate the optimal Voronoi partition).
\end{abstract}


\InSubmitVer{\thispagestyle{empty}\newpage \setcounter{page}{1}}


\section{Introduction}

\paragraph{Divide and conquer.}
Many algorithms work by partitioning the input into a small number of
pieces, of roughly equal size, with little interaction between the
different pieces, and then recursing on these pieces. One natural way
to compute such partitions for graphs is via the usage of separators.

\paragraph{Separators.}
A (vertex) separator of a graph ,
informally, is a ``small'' set  whose
removal breaks the graph into two or more connected subgraphs, each of
which is of size at most , where  is some constant larger than
one. As a concrete example, any tree with  vertices has a single
vertex, which can be computed in linear time, such that its removal
breaks the tree into subtrees, each with at most  vertices.

\paragraph{Separators in planar graphs.}

In 1977, Lipton and Tarjan \cite{lt-stpg-77, lt-stpg-79} proved that
any planar graph with  vertices contains a separator of size
, and it can be computed in linear time.
Specifically, there exists a separator of size  that
partitions the graph into two disjoint subgraphs each containing at
most  vertices.

There has been a substantial amount of work on planar separators in
the last four decades, and they are widely used in data-structures and
algorithms for planar graphs, including
\begin{inparaenum}[(i)]
    \item shortest paths \cite{fr-pgnwe-06},
    \item distance oracles \cite{svy-dosg-09},
    \item max flow \cite{ek-ltamf-13}, and
    \item approximation algorithms for TSP \cite{k-ltast-08}.
\end{inparaenum}
This list is a far cry from being exhaustive, and is a somewhat
arbitrary selection of some recent results on the topic.


\paragraph{Planar separators via geometry.}

Any planar graph can be realized as a set of interior disjoint disks,
where a pair of disks touch each other, if and only if the
corresponding vertices have an edge between them. This is known as the
circle packing theorem \cite{pa-cg-95}, sometimes referred to in the
literature as Koebe-Andreev-Thurston theorem. Its original proof goes
back to Koebe's work in 1936 \cite{k-kdka-36}.

Surprisingly, the existence of a planar separator is an easy
consequence of the circle packing theorem. This was proved by Miller
\etal \cite{mttv-sspnng-97}, and their proof was recently simplified
by Har-Peled \cite{h-speps-11}. Among other things, Miller \etal
showed that given a set of  balls in , such that no point is
covered more than  times, the intersection graph of the balls has a
separator of size . This in turn implies
that the -nearest neighbor graph of a set of points in , has
a small separator \cite{mttv-sspnng-97, h-speps-11}.  Various
extensions of this technique were described by Smith and Wormald
\cite{sw-gsta-98}.


\paragraph{Other separators.}

Small separators are known to exist for many other families of
graphs. These include graphs
\begin{inparaenum}[(i)]
    \item with bounded tree width \cite{bptw-betsu-10},
    \item with bounded genus \cite{ght-stgbg-84},
    \item that are minor free \cite{ast-stgem-90}, and
    \item that are grids.
\end{inparaenum}


\begin{figure}
    \centerline{\begin{tabular}{\si{ccccc}}
           \begin{minipage}{0.5cm}
               \vspace{-6cm} (A) \vspace{3cm}
           \end{minipage}
           & \includegraphics[page=1,scale=0.8]{figs/alligator}
           &
           &
           \begin{minipage}{0.5cm}
               \vspace{-6cm} (B) \vspace{3cm}
           \end{minipage}&\includegraphics[page=2,scale=0.8]{figs/alligator}
       \end{tabular}}\vspace{-0.5cm}\caption{(A) A Voronoi partition. (B) A separator realizing it.}\figlab{v:partition}
\end{figure}


\paragraph{Voronoi separators.}

In this paper, we are interested in geometric separation in a Voronoi
diagram. Voronoi diagrams are fundamental geometric structure, see
\cite{akl-vddt-13}. Specifically, given a set  of points in
, we are interested in inserting a small set of new points
, such that there is a balanced partition of  into two
sets , such that no cell of  touches
a cell of  in the Voronoi diagram . Note, that such a set  also separates 
and  in the Delaunay triangulation of .


\paragraph{Why Voronoi separators are interesting?}

Some meshing algorithms rely on computing a Delaunay triangulation of
geometric models to get good triangulations that describe solid
bodies. Such meshes in turn are fed into numerical solvers to simulate
various physical processes. To get good triangulations, one performs a
Delaunay refinement that involves inserting new points into the
triangulations, to guarantee that the resulting elements are well
behaved. Since the underlying geometric models can be quite
complicated and these refinement processes can be computationally
intensive, it is natural to try and break up the data in a balanced
way, and Voronoi separators provide one way to do so.

More generally, small Voronoi separators provide a way to break up a
point set in such a way that there is limited interaction between two
pieces of the data.


\paragraph{Geometric hitting set.}

Given a set of objects in , the problem of finding a small
number of points that stab all the objects is an instance of geometric
hitting set. There is quite a bit of research on this problem. In
particular, the problem is \NPHard for almost any natural instance,
but a polynomial time -approximation algorithm is known for
the case of balls in  \cite{c-ptasp-03}, where one is allowed
to place the stabbing points anywhere. The discrete variant of this
problem, where there is a set of allowable locations to place the
stabbing points, seems to be significantly harder and only weaker
results are known \cite{hl-wgscp-12}.

One of the more interesting versions of the geometric hitting set
problem, is the art gallery problem, where one is given a simple
polygon in the plane, and one has to select a set of points (inside or
on the boundary of the polygon) that ``see'' the whole polygon.  While
much research has gone into variants of this problem \cite{o-agta-87},
nothing is known as far as an approximation algorithm (for the general
problem). The difficulty arises from the underlying set system being
infinite, see \cite{eh-ggt-06} for some efforts in better
understanding this problem.


\paragraph{Geometric local search.}

Relatively little is known regarding local search methods for
geometric approximation problems. Arya \etal \cite{agkmp-lshkm-01}
gave a local search method for approximating -median clustering by
a constant factor, and this was recently simplified by Gupta and
Tangwongsan \cite{gt-salsa-08}.

Closer to our settings, Mustafa and Ray \cite{mr-pghsp-09} gave a
local search algorithm for the discrete hitting set problem over
pseudo disks and -admissible regions in the plane, which yields a 
\PTAS.  Chan and Har-Peled \cite{ch-aamis-12} gave a local search \PTAS 
for the independent set problem over fat objects, and for pseudodisks 
in the plane. Both works use separators in proving the quality of 
approximation. 









\subsection{Our Results}

In this paper we give algorithms for the following:

\smallskip

\begin{enumerate}[(A)]\item \textbf{Computing a small Voronoi separator.} Given a set  of  points in , we show how to
    compute, in expected linear time, a balanced Voronoi separator of
    size . This is described in
    \secref{balanced:separator}. The existence of such a separator was
    not known before, and our proof is relatively simple and elegant.
    
    Such a separator can be used to break a large data-set into a
    small number of chunks, such that each chunk can be handled
    independently -- potentially in parallel on different computers.

    \item \textbf{Exact algorithm for computing the smallest Voronoi
       separator realizing a given partition.} In \secref{exact:separator}, given a partition  of a point set  in , we describe an
    algorithm that computes the minimum size Voronoi separator
    realizing this separation.  The running time of the algorithm is
    , where  is the cardinality of
    the optimal separating sets (the  notation is hiding a constant
    that depends on ).
    
    
    \item \textbf{Constant approximation algorithm for the smallest
       Voronoi separator realizing a given partition.} In \secref{const:factor}, we describe how to compute a constant
    factor approximation to the size of the minimal Voronoi separator
    for a given partition of a set in . This is the natural
    extension of the greedy algorithm for geometric hitting set of
    balls, except that in this case, the set of balls is infinite and
    is encoded implicitly, which somewhat complicates things.
    
    
    \item \textbf{A \PTAS for the smallest Voronoi separator realizing
       a given partition.} In \secref{PTAS}, we present a polynomial time approximation
    scheme to compute a Voronoi separator, realizing a given
    partition, whose size is a -approximation to the size of
    the minimal Voronoi separator for a given partition of a set in
    . The running time is .
    
    Interestingly, the new algorithm provides a \PTAS for the
    geometric hitting set problem (for balls), that unlike previous
    approaches that worked top-down \cite{c-ptasp-03, ejs-ptasg-05},
    works more in a bottom-up approach. Note, that since our set of
    balls that needs to be pierced is infinite, and is defined
    implicitly, it is not obvious a priori how to use the previous
    algorithms in this case. 


        
    \medskip \textbf{Sketch of algorithm.} The new algorithm works by first computing a ``dirty'' constant
    approximation hitting set using a greedy approach (this is
    relatively standard). Somewhat oversimplifying, the algorithm next
    clusters this large hitting set into tight clusters of size  each. It then replaces each such cluster of the weak
    hitting set, by the optimal hitting set that can pierce the same
    set of balls, computed by using the exact algorithm -- which is
    ``fast'' since the number of piercing points is at most
    . In the end of this process the resulting set of
    points is the desired hitting set.  Namely, the new approximation
    algorithm reduces the given geometric hitting set instance, into
     smaller instances where  is the size of the overall
    optimal hitting set and each of the smaller instances has an
    optimal hitting set of size .
    


    For the analysis of this algorithm, we need a strengthened version
    of the separator theorem. See \thmrefpage{ball:separator} for
    details.
    
    \item \textbf{Local search \PTAS for continuous geometric hitting
       set problems.} An interesting consequence of the new bottom-up \PTAS, is that it
    leads to a simple local search algorithm for geometric hitting set
    problems for fat objects. Specifically, in \secref{local:search},
    we show that the algorithm starts with any hitting set (of the
    given objects) and continues to make local improvements via
    exchanges of size at most , until no such
    improvement is possible, yielding a \PTAS.  The analysis of the
    local search algorithm is subtle requiring to cluster
    simultaneously the locally optimal solution, and the optimal
    solution, and matching these clusters to each other.

\end{enumerate}



\paragraph{Significance of Results.}

Our separator result provides a new way to perform geometric divide
and conquer for Voronoi diagrams (or Delaunay triangulations).  The
\PTAS for the Voronoi partition problem makes progress on a geometric
hitting set problem where the ranges to be hit are defined implicitly,
and their number is infinite, thus pushing further the envelope of
what geometric hitting set problems can be solved efficiently. Our
local search algorithm is to our knowledge the first local search
algorithm for geometric hitting set -- it is simple, easy to
implement, and might perform well in practice (this remains to be
verified experimentally, naturally). More importantly, it shows that
local search algorithms are potentially more widely applicable in
geometric settings.


\paragraph{How our results relate to known results?}

Our separator result is similar in spirit (but not in details!) to the
work of Miller \etal \cite{mttv-sspnng-97} on a separator for a
-ply set of balls -- the main difference being that Voronoi cells
behave very differently than balls do. Arguably, our proof is
significantly simpler and more elegant. Our bottom-up \PTAS approach
seems to be new, and should be applicable to other problems. Having
said that, it seems like the top-down approaches \cite{c-ptasp-03,
   ejs-ptasg-05} potentially can be modified to work in this case, but
the low level details seem to be significantly more complicated, and
the difficulty in making them work was the main motivation for
developing the new approach. The analysis of our local search
algorithm seems to be new -- in particular, the idea of incrementally
clustering in sync optimal and local solutions.  Of course, the basic
idea of using separators in analyzing local search algorithms appear
in the work of Mustafa and Ray \cite{mr-pghsp-09} and Chan and
Har-Peled \cite{ch-aamis-12}.













\section{Preliminaries}

For a point set , the \emphi{Voronoi diagram}
of , denoted by  is the partition of space
into convex cells, where the \emphi{Voronoi cell} of  is

where  is the distance of  to the set .
Voronoi diagrams are a staple topic in Computational Geometry, see
\cite{bcko-cgaa-08}, and we include the definitions here for the sake
of completeness. In the plane, the Voronoi diagram has linear
descriptive complexity. For a point set , and points , the geometric loci of all points in  that
have both  and  as nearest neighbor, is the
\emphi{bisector} of  and  -- it is denoted by
.  A point  is the center of a ball whose interior does
not contain any point of  and that has  and  on
its boundary. The set of all such balls induced by
 is the \emphi{pencil} of  and ,
denoted by .


\begin{defn}
    Let  be a set of points in , and  and
     be two disjoint subsets of . The sets
     and  are \emphi{Voronoi separated} in
     if for all  and , we have that their Voronoi cells are disjoint; that
    is, .
\end{defn}


\begin{defn}
    For a set , a \emphi{partition} of  is a pair of
    sets , such that , and .
    A set  is a \emphi{Voronoi separator} for a partition
     of , if
     and  are Voronoi separated in ; that is, the Voronoi cells of  in
     do not intersect the Voronoi cells
    of . We will refer to the points of the separator
     as \emphi{guards}.
\end{defn}

See \figref{v:partition} for an example of the above definitions.



\begin{defn}\deflab{dbl:constant}For a ball , its \emphi{covering number} is the minimum
    number of (closed) balls of half the radius that are needed to
    cover it.  The \emphi{doubling constant} of a metric space is the
    maximum cover number over all possible balls.  Let  be the
    doubling constant for .
\end{defn}



The constant  is exponential in , and  -- indeed, cover a ball (say, of unit radius) by a
grid with sidelength , and observe that each grid cell has
diameter , and as such can be covered by a ball of radius .


\begin{figure}[t]\begin{tabular}{\si{cc}}
        \begin{minipage}{0.4\linewidth}
            \centerline{\includegraphics{figs/pencil}}\end{minipage}
        &
        \begin{minipage}{0.4\linewidth}
            \centerline{\includegraphics[page=2]{figs/pencil}}\end{minipage}
        \\
        (A) & (B)
    \end{tabular}
    \captionof{figure}{(A) The unbounded bisector induced by 
       and . (B) The pencil of  and . }\figlab{hypercube}
\end{figure}




\begin{defn}
    \deflab{projection}For a closed set , and a point , the \emphi{projection} of  into  is the
    closest point on  to . We denote the projected point
    by .
\end{defn}




\section{Computing a small Voronoi separator}
\seclab{balanced:separator}

\subsection{Preliminaries, and how to block a sphere}

Given a set  of  points in , we show how to compute
a balanced Voronoi separator for  of size .

\begin{defn}
    A set  is
    \emphi{-dense} in , if for any point , there exists a point , such that
    .
\end{defn}



\begin{lemma}
    \lemlab{blocker}Consider an arbitrary sphere , and a point . Then one can compute, in constant time,
    a set of points , such that the
    Voronoi cell  does not
    intersect , and . We denote
    the set  by .
\end{lemma}

\begin{proof}
    If  is outside the sphere , then  provides the desired separation.
    
    \parpic[r]{\includegraphics{figs/blocker_set}}
    
    If  is inside , then consider the unit sphere
    centered at , cover it with the minimum number of spherical
    caps having diameter , and let  be the
    resulting set of caps. Every such cap of directions defines a
    natural cone centered at . Formally, for such a cap ,
    consider the set . Compute the closest point of
     inside this cone, and add the point to
    . Repeat this process for all the caps of .
    
    We claim that  is the desired blocker. To this end,
    consider any cap , and observe that
     contains , and this is the
    closest point on  to . In
    particular, since the cone angle is , it is
    straightforward to verify that the bisector of  and 
    separates  from , implying
    that  can not intersect
    the portion of  inside , see figure
    above for an example.
\end{proof}



\subsection{The Algorithm}

The input is a set  of  points in . The algorithms
works as follows:

\noindent
\begin{minipage}{0.68\linewidth}
    \begin{compactenum}[\noindent \;\; (A)]
        \item Let , see \defref{dbl:constant}.  Let
         be the smallest (closed) ball that
        contains  points of  where .
        
        \noindent
        \item Pick a number  uniformly at random from the range
        .
        
        \item Let .
        
        \item Let  and .
        
        \item Let .  Compute an -dense
        set , of size , on the sphere 
        using the algorithm of \lemref{dense:set} described below.
        
        
        \item If a point  is in distance smaller
        than  from , we insert
         into the separating set ,
        see \lemref{blocker}.
        
    \end{compactenum}\end{minipage}\hfill \begin{minipage}{0.3\linewidth}
    \centerline{\includegraphics{figs/separator}}
    \captionof{figure}{A slightly inaccurate depiction of how the
       algorithm works.}
\end{minipage}

\medskip

\noindent We claim that the resulting set  is the desired separator.



\paragraph{Efficient implementation.}

One can find a -approximation (in the radius) to the smallest ball
containing  points in linear time, see \cite{h-gaa-11}. This
would slightly deteriorate the constants used above, but we ignore
this minor technicality for the sake of simplicity of exposition. If
the resulting separator is too large (i.e., larger than  see below for details), we rerun the algorithm.

\subsubsection{Computing a dense set}

The following is well known, and we include it only for the sake of
completeness.
\begin{lemma}
    \lemlab{dense:set}Given a sphere  of radius  in , and given
    a number , one can compute a -dense set  on
     of size . This set can
    be computed in  time.
\end{lemma}
\begin{proof}
    Consider the grid  of sidelength , and let
     be the set of intersection points of the lines of 
    with . Observe that every -face of the bounding
    cube of  intersects 
    lines of the grid, and since there  such faces, the claim on
    the size of  follows.
    
    As for the density property, observe that for any point , let  be the grid cell of  that contains
    it. Observe, that  contains 
    completely, one of the vertices of  must be inside the
    sphere, and at least one of them must be outside the sphere. Since
    the edges of the boundary of  are connected, it follows
    that one of the points of  is on the boundary of ,
    which in turn implies that there is a point of  contained
    in , implying the desired property.
\end{proof}


\subsection{Correctness}

\begin{lemma}
    We have  and .
\end{lemma}
\begin{proof}
    By \defref{dbl:constant}, the ball 
    can be covered by  balls of radius , each one of
    them contains at most  points, as 
    is the smallest ball containing  points of .
    
    As such  contains at most  points of
    . In particular, as , we have that
     has at least  points of , inside it, and
    at least  points outside it.
\end{proof}

\begin{lemma}
    The sets  and  are Voronoi separated in
    .
\end{lemma}

\begin{proof}
    We claim that all the points on  are dominated by
    . Formally, for any , we have that
    , which
    clearly implies the claim.
    
    So, let  be the nearest neighbor to  in .
    If  then since  is
    -dense in , it follows that there exists  such that , as desired.
    
    If  then the addition of
     to , during the
    construction, guarantees that the nearest point in  to
    , is closer to  than  is, see
    \lemref{blocker}.
\end{proof}

\begin{lemma}
    \lemlab{small:separator}Let . We have that , where  is some constant.
\end{lemma}
\begin{proof}
    Let  be the number of points of , whose projections
    were added to . We claim that .  To this end, for a point ,
    let  be the indicator variable that is one if and only if
     is in distance at most  from . The
    algorithm picked the radius  uniformly at random in the
    interval . Furthermore,  if and only
    if . This happens only if  falls into an interval
     that is of length at most  centered at
    .  As such, we have
    
    Now, by linearity of expectation, we have that , where
     is the constant of \lemref{blocker}. This implies the claim,
    as .
\end{proof}



\subsection{The result}



\begin{theorem}
    \thmlab{separator:main}Let  be a set of  points in . One can compute,
    in expected linear time, a sphere , and a set , such that
    \begin{compactenum}[\quad (i)]
        \item ,
        \item  contains  points of 
        inside it,
        \item there are  points of  outside
        , and
        \item  is a Voronoi separator of the points of
         inside  from the points of 
        outside .
    \end{compactenum}
    Here  is a constant that depends only on the dimension .
\end{theorem}

\begin{proof}
    Clearly, each round of the algorithm takes  time. By
    Markov's inequality the resulting separator set  is of
    size at most , with probability at least
    , see \lemref{small:separator}. As such, if the separator is
    larger than this threshold, then we rerun the algorithm. Clearly,
    in expectation, after a constant number of iterations the
    algorithm would succeed, and terminates. (It is not hard to
    derandomize this algorithm and get a linear running time.)
\end{proof}








\section{Exact algorithm for computing the optimal separation for a given partition}
\seclab{exact:separator}

Given a set  of  points in , and a partition
 of , we are interested in
computing the smallest Voronoi separating set realizing this
partition.




\subsection{Preliminaries and problem statement}
\seclab{euclidean:preliminaries}

\begin{defn}\deflab{bad:pairs}For a set  and a pair of disjoint subsets
    , the set of \emphi{bad pairs} is
    
\end{defn}


\remove{\begin{figure}[t]\centerline{\includegraphics{figs/f_induced_halfspace}}\captionof{figure}{ A -feature  and its induced
          -halfflats . }
       \figlab{feature:halfspace}
   \end{figure}}

\parpic[r]{\begin{minipage}{6cm}\centerline{{\includegraphics{figs/f_induced_halfspace}\hspace{-1.5cm}}}\captionof{figure}{ A -feature  and its induced
          -halfflats . }
       \figlab{feature:halfspace} \end{minipage}}

For a Voronoi diagram , we can assume that all its
faces (of various dimensions) are all triangulated (say, using
bottom-vertex triangulation). This does not change the complexity of
the Voronoi diagram. For , such a  dimensional
Voronoi simplex is a \emphi{-feature}. Such a -feature
, is induced by  sites, denoted by
; that is, any point  is in
equal distance to all the points of  and these are
the nearest neighbor of  in . Thus, a vertex  of the
Voronoi diagram is a -feature, and 
(assuming general position, which we do).  The \emphi{span} of a
feature , is the set of points in  that are
equidistant to every site in ; it is denoted by
 and is the  flat that contains .  A
\emphi{-halfflat} is the intersection of a halfspace with a
-flat.

Consider any -feature . The complement set
 can be covered by 
-halfflats of . Specifically, each of these
halfflats is an open -halfflat of , whose
boundary contains a -dimensional face of the boundary of
. This set of halfflats of , is the \emphi{shell}
of , and is denoted by , see
\figref{feature:halfspace}.

Once the Voronoi diagram is computed, it is easy to extract the ``bad
features''. Specifically, the set of \emphi{bad features} is

Clearly, given a Voronoi diagram the set of bad features can be
computed in linear time in the size of the diagram.  \medskip


Given a -feature , it is the convex-hull of  points;
that is, , where . We are interested in finding the closest
point in a feature to an arbitrary point . This is a constant
size problem for a fixed , and can be solved in constant time.  We
denote this closest point by .  For the feature ,
and any point , we denote by  the
ball  (if it is
uniquely defined).  Furthermore, for an arbitrary set  of points,
 denote
. In particular, for any point , consider
 -- it contains the points of
 on its boundary. The set of all such balls is the
\emphi{pencil} of , denoted by

The \emphi{trail} of  is the union of all these balls; that
is, . Finally, let 
denote the smallest ball in the pencil of a feature
. Clearly, the center of  is the point
, where  is some arbitrary point of
. As such,  can be computed in
constant time.

\begin{lemma}\lemlab{halfspace}Let  be any point and let  be any -feature. The
    point  induces a halfflat of  denoted by
    , such that
     is the set of all balls
    in  that contain .
\end{lemma}

\begin{proof}
    Consider any arbitrary site .  The set
    of points whose ball in the pencil contains , is clearly the
    set of points in  that are closer to 
    than to .  This set of points, is a halfspace of 
    that is not parallel to the -flat .  Thus,
     is the desired halfflat of 
    induced by , whose boundary is given by the set of points
    equidistant to .
\end{proof}



We are now ready to restate our problem in a more familiar language.

\begin{lemma}[Restatement of problem]\lemlab{hit:balls}Given a set  of  points in , and a pair of
    disjoint subsets , finding a minimum
    size Voronoi separator realizing separation of
    , is equivalent to finding a minimum
    size hitting set of points , such that  stabs
    (the interior) of all the balls in the set
    
\end{lemma}
\begin{proof}
    Indeed, a Voronoi separating set , must stab all the
    balls of , otherwise, there would be Voronoi feature
    of  that has a generating site in
    both,  and .
    
    As for the other direction, consider a set  that stabs all
    the balls of , and observe that if  and
     are not Voronoi separated in , then there exists a ball , that has no point
    of  in its interior, and points from both
     and  on its boundary. But then, this ball
    must be in the pencil of the Voronoi feature induced by . A contradiction to  stabbing all the balls of
    .
\end{proof}












\subsection{Exact algorithm in }
\seclab{exact}

Given a set  of  points in , a pair of disjoint
subsets  of  and an upper bound
 on the number of guards, we show how one can compute the
minimum size Voronoi separator realizing their separation in
 time. Our approach is to construct a small number
of polynomial inequalities that are necessary and sufficient
conditions for separation, and then use cylindrical algebraic
decomposition to find a feasible solution.

\begin{observation}
    \obslab{feature:cover} For a set of guards , a feature
     is completely removed from ,
    if and only if the induced halfflats of the guards, on
    , cover . This follows directly from
    \lemref{hit:balls} and \lemref{halfspace}.
\end{observation}


\begin{observation}
    \obslab{helly}Given a set  of at least  halfflats in a -flat, if
     covers the -flat, then there exists a subset of
    -halfflats of , that covers the -flat.  This is a
    direct consequence of Helly's theorem.
\end{observation}

\paragraph{Low dimensional example.}
To get a better understanding of the problem at hand, the reader may
imagine the subproblem of removing a bad -feature 
(i.e.  is a triangle) from the Voronoi diagram. We know that
a set  of  guards removes  from the Voronoi
diagram, if and only if the  -halfflats induced by 
cover the triangle . If we add the feature-induced halfflats
induced by  to the above set of halfflats, then the problem
of covering the triangle , reduces to the problem of
covering the entire plane with this new set  of 
halfflats. Then from \obsref{helly}, we have that  is
removed from the Voronoi diagram if and only if there are three
halfplanes of , that covers the entire plane (there are 
such triplets).  \lemref{annihilate:feature} below show how to convert
the condition that any three -halfflats cover the plane, into a
polynomial inequality of degree four in the coordinates of the guards.


\subsubsection{Constructing the Conditions}



\begin{lemma}
    \lemlab{feature:cover}
Let  be a -feature, and  be a set of
    -halfflats on .  Then,  covers
      there exists a subset  of size  that covers
    .
\end{lemma}

\begin{proof}    
    If  covers , then  covers , as
     covers
    . Then, by Helly's theorem (see
    \obsref{helly}), we have that some subset of  of size 
    covers .
    
    For the other direction, we have that some subset of  covers
     (of size ).  Since 
    does not cover any point in , we have that  must cover  completely.
\end{proof}



\begin{observation}
    \obslab{plane:cover}Consider a set  of  -halfflats all contained in some
    -flat . We are interested in checking that  covers
    . Fortunately, this can be done by computing the 
    vertices induced by  on , and verifying that each one
    of them is covered by the other halfflat of . Formally, 
    covers   for every halfflat , we have that
    .
\end{observation}


For a set  of  points in  in general position,
let  be the unique ball having all the points
of  on its boundary.



\begin{lemma}
    \lemlab{incircle}Consider a -feature , let  be a set of halfflats
    on , and let  be the set of guards
    inducing the halfflats of . Assume that .  Let  be a
    -halfflat induced by a guard , and let .  Then   .
\end{lemma}

\begin{proof}
    The boundary of the induced halfflat of a guard , is the set
    of points equidistant to the points of , see \lemref{halfspace}; equivalently, this is the set
    containing every point , such that  contains  on its boundary. Furthermore, for any
     inside this induced halfflat, . Thus   the point . Also,  is the
    point in equal distance to all the points of
    .
\end{proof}

A set  of  guards in  can be interpreted as a
vector in  encoding the locations of the guards. One can
then reduce the requirement that  provides the desired
separation into a logical formula over the coordinates of this vector.



\begin{lemma}
    \lemlab{annihilate:feature}Let  be a bad -feature of , and let  be a parameter. One
    can compute a boolean sentence 
    consisting of  polynomial inequalities (of degree
    ), over  variables, such that
     is true  the set of 
    guards  (induced by the solution of this formula)
    destroys  completely when inserted. Formally, for every
    , we have .
\end{lemma}

\begin{proof}
    Let 
    be the set of halfflats on  induced by the
    guards in . By \obsref{feature:cover}, if  covers
    , then  removes  from the Voronoi
    diagram (see also \lemref{hit:balls}). To this end, let . Further, let  be a
    set of  points that exactly induce the halfflats of  and let . From \lemref{feature:cover}, we know that  covers
      some size  subset of  covers the
    -flat . Then by \obsref{plane:cover}, 
    covers   there exists some size  subset
     of , such that for every , we have
    .
    
    Since  exactly induces the halfflats of ,
    \lemref{incircle} implies that  is completely removed
    from   there exists some size
     subset  of , such that for every
    ,  lies inside the ball containing the
    points of  on
    its boundary. More formally, we define,
    
    where  represents the standard in-circle
    determinant whose sign determines the inclusion of  in the
    ball fixed by the points of . This determinant affords us a
    polynomial of degree at most  involving only the variables of
    , as the points of  are merely
    constants.  Clearly,  contains at
    most  polynomial inequalities, and
    the claim follows.
\end{proof}



\subsubsection{The Result}

\begin{theorem}
    \thmlab{exact}Let  be a set of  points in . Let
     be some disjoint partition of 
    and  be a parameter, such that there exists a Voronoi
    separator for  of at most 
    points. The minimal size Voronoi separator can be computed in
     time, if such a separator exists of size
    at most  (note, that the constant in the  notations
    depends on ).
\end{theorem}

\begin{proof}
    Let  be a parameter to be fixed shortly. Let  be
    a set of  guards in .  By
    \lemref{annihilate:feature}, the condition 
    that every bad feature is removed from the Voronoi diagram of
    , can be written as
    
    Namely,  is a Voronoi separator for
    .
The formula  contains 
    degree- polynomial inequalities comprising of at most  variables. By \cite[Theorem~13.12]{bpr-arag-06}, one can
    compute, in  time, a solution as well as the
    sign of each polynomial in , for every possible sign
    decomposition that  can attain. Now for each attainable sign
    decomposition, we simply check if  is
    true. This can be done in  time. The algorithm
    computes a Voronoi separator for  in
     of size , in  time, if
    such a separator exists.
    
    Now, the algorithms tries  and
    stops as soon as a feasible solution is found.
\end{proof}



\paragraph{Remark.}

Interestingly, both here and in the rest of the paper, one can specify
which pair of points need to be separated from each other (instead of
a partition of the input set), and the algorithm works verbatim for
this case (of course, in the worst case, one might need to specify
 pairs, if one explicitly lists the forbidden pairs).



\section{Approximation algorithms}

\subsection{Constant factor approximation}
\seclab{const:factor}

Given a set  of  points in , and a partition
 of , we show how one can compute in
 time, a Voronoi separator  for , whose size is a constant factor approximation to the size
of the minimal Voronoi separator realizing such a partition.

\subsubsection{The algorithm \GreedySeparator{}}
Since the problem is equivalent to a hitting set problem on balls, see
\lemref{hit:balls}, we can apply the ``standard'' greedy
strategy. Specifically, given , and a pair of
disjoint subsets , start with an empty
set  of stabbing points.

Now, at each iteration, compute the Voronoi diagram , and compute the set of bad features
. Compute the
minimum ball in  (see \Eqref{pencil}) for each of
the bad features .  Let  be the
smallest ball encountered. Let  be a constant size set
of points, such that any ball that intersects  (and is at
least as large), must intersect . Such a set can be
easily constructed by sprinkling a -dense set in the enlarged ball
. Note that  must also stab
.  The resulting set  has constant size (for
example, by using grid points of the appropriate size). Set , and repeat.



\subsubsection{The Result}

\begin{theorem}\thmlab{const:sep}Let  be a set of  points in , and
     be a given pair of disjoint subsets
    of . One can compute a Voronoi separator  that
    realizes this partition. The algorithm runs in 
    time for , and in  time, for .  The algorithm provides a constant factor approximation to the
    smallest Voronoi separator realizing this partition.
\end{theorem}

\begin{proof}
    Observe the optimal solution is finite, as one can place 
    points around each point of , close enough, so that
    they Voronoi separate this point from the rest of . As
    such, the optimal solution is of size at most
    .
    
    As for the quality of approximation, this is a standard exchange
    argument. Indeed, consider the optimal solution, and observe that,
    at each iteration, the minimum ball found  must contain at
    least one point of the optimal solution, and the greedy algorithm
    replaces it in the approximation by the set , such
    that any ball that is stabbed by a point of the optimal solution
    that is contained in , and is at least as big as 
    is also stabbed by some points of . In particular,
    if  is the maximum size set  constructed by the
    algorithm (which is a constant), then the quality of approximation
    of the algorithm is .
    
    The above implies that the algorithms terminates with at most
     points added. Since computing the Voronoi diagram takes
     time in the plane, this implies that the running of
    the algorithm in the plane is .  In higher
    dimensions, computing the Voronoi diagram takes
    , and overall, the algorithm takes
     time.
\end{proof}






\subsection{Polynomial time approximation scheme}
\seclab{PTAS}

Given a set  of  points in , a parameter ,
and a pair of disjoint subsets  of ,
we show here how to -approximate, in 
time, a Voronoi separator  for .

As implied by \lemref{hit:balls}, this problem boils down to a hitting
set problem. That is, the desired partition give rise to a set of
balls , such that our task is to approximate the minimum
size hitting set for . The challenge here is that
 is an infinite set, see \Eqrefpage{hitting:set}.


We need an improved separator theorem, as follows.
\begin{theorem}
    \thmlab{ball:separator}Let  be a set of points in , and  be an integer
    sufficiently smaller than .  One can compute, in
     expected time, a set  of
     points and a sphere  containing
     points of  inside it, such that for any set
     of balls stabbed by , we have that every ball
    of  that intersects  is stabbed by a point of
    .
\end{theorem}

Due to space limitations, we had delegated the proof of
\thmref{ball:separator} to \apndref{sperating:guards} -- it is a
careful extension of the proof of \thmref{separator:main}.




\subsubsection{Preliminaries}

For a set  of balls in , let
 be the size of its minimal hitting set.
Here, our aim is to approximate the value of
.



\begin{observation}
    \obslab{subset}Let  and  be sets of balls such that
    .  Then .
\end{observation}


\begin{observation}
    \obslab{disjoint:union}Let  and  be sets of balls such that no
    ball in  intersects a ball in .  Then
    .
\end{observation}

\subsubsection{The Algorithm \Algorithm{ApproximateSeparator}}

The input is a set  of  points in , and a desired
partition .
\begin{compactenum}[\qquad (A)]
    \item Using the algorithm \GreedySeparator{}, compute a Voronoi
    separator , for  in , and
    let .
    
    \item 
    
    \item , 
    
    \item While :
    
    
    \begin{compactenum}[(a)]
        \item Compute a sphere  and a set 
        using \thmref{ball:separator} for  with the parameter
        .
        
        \item Let  be the corresponding closed ball of
        .
        
        \item , \quad , \quad , \quad .
        
        \item  Compute (exactly) the smallest
        hitting set for  using \thmref{exact}.
        
        \item 
        
        \item 
        
        \item 
    \end{compactenum}
    
    \item Output 
    
\end{compactenum}


\subsubsection{Correctness}

Let  be the number of iterations in the algorithm above.  Let
 be the set of
all balls that need to be hit (see \Eqrefpage{hitting:set}). For , let .


\begin{lemma}
    \lemlab{valid}The set  is a hitting set for .
\end{lemma}

\begin{proof}
    Observe that  form a partition of
    , and consider any ball .  The ball
     is stabbed by at least one point of , and let 
    be the minimal index such that  stabs .
    
    If  intersects the sphere  then,  stabs , by \thmref{ball:separator}.
    Otherwise,  must be inside , as otherwise it
    cannot be stabbed by the points of . But then,  being a ``bad'' ball, must have a
    point of  and a point of  on its
    boundary, implying , and it is thus stabbed by
    , as testified by \thmref{exact}.
\end{proof}


\begin{lemma}
    \lemlab{geometrically:disjoint}
\end{lemma}

\begin{proof}
    Consider any integers  such that .  Consider
    any ball . By construction, 
    stabs . Now , implying that  is stabbed by
    . Thus,  cannot be in the set ,
    and further, .
    
    A stronger property holds -- there is no point that stabs balls
    that are in both  and . Indeed, all the
    balls of  (resp.  ) are contained inside
     (resp. ) by \thmref{ball:separator}. As
    such, such a point  that stabs balls in both sets, must be
    in .  But  stabs all the
    balls of  that intersect . In particular, as
    , it follows that no ball of
     can intersect .
    
    Now \obsref{disjoint:union} implies the claim.
\end{proof}

\begin{lemma}
    \lemlab{approx}Let  be the size of the optimal hitting set.  We have
    .
\end{lemma}

\begin{proof}
    We have , as 
    is a constant approximation to the optimal hitting set. Then, by
    \lemref{geometrically:disjoint} and \obsref{subset}, we have
    
\end{proof}


\subsubsection{The result}

\begin{theorem}
    Given a set  of  points in , a parameter
    , and a corresponding partition ,
    one can compute a Voronoi separator for  in
     time, such that its size is a
    -approximation to the minimal Voronoi separator
    realizing the partition .
\end{theorem}

\begin{proof}
    By \lemref{valid} and \lemref{approx}, setting ,
    where  is a sufficiently large constant implies the desired
    approximation.
    
    As for the running time, observe that the bottleneck in the
    running time, is in the invocation of the exact algorithm of
    \thmref{exact} in the \th iteration, for . However, in the \th iteration, a trivial stabbing set is
    , which has size . That is, the running time of
    algorithm of \thmref{exact} in the \th iteration is ,
    implying the result.
\end{proof}






\section{\PTAS for geometric hitting set via local search}
\seclab{local:search}

Here, we present a simple local search -approximation
algorithm (\PTAS) for hitting set problems of balls (or fat objects)
in . The set of balls is either specified explicitly, or as in
the case of the Voronoi partition, implicitly.

\subsection{The Algorithm \Algorithm{LocalHitBalls}}

\subsubsection{Preliminaries}

Let  be a set of balls (possibly infinite) in  that
is represented (potentially implicitly) by an input of size , and
let  be the size of its minimal hitting set.
We assume that  satisfies the following properties:
\begin{compactenum}[\qquad(P1)]
    \item \pitemlab{p:1}\textbf{Initial solution}: One can compute a hitting set 
    of  in  time, such that the size of
     is a constant factor approximation to the optimal.
    
    \item \pitemlab{p:2}\textbf{Local exchange}: Let  and  be point
    sets, such that
    \begin{compactenum}[\qquad (i)]
        \item  is a hitting set of  (i.e., it is the
        current solution),
        \item  (i.e., it is not
        too large),
        \item  (i.e.,  is the subset to be
        replaced),
        \item , where  is any
        integer.
    \end{compactenum}
    Then one can compute in  time, the smallest
    set , such that  is a
    hitting set of .
\end{compactenum}


\subsubsection{Algorithm}


The input is a set  of balls in  satisfying the
properties above. The algorithm works as follows:
\smallskip \begin{compactenum}[\quad(A)]
    \item Compute an initial hitting set  of  (see
    \pitemref{p:1}), and set .
    
    \item While there is a beneficial exchange of size  in , carry it out using \pitemref{p:2}.
    
    Specifically, verify for every subset  of
    size at most , if it can be replaced by a strictly smaller
    set  such that 
    remains a hitting set of . If so, set , and repeat.

    \item If no such set exists, then return  as the hitting
    set.
\end{compactenum}




\paragraph{Details.}

For the geometric hitting set problem where  is a set of
 balls in , \pitemref{p:1} follows by a simple greedy
algorithm hitting the smallest ball (in the spirit of
\thmrefpage{const:sep}) -- see also \cite{c-ptasp-03}. As for
\pitemref{p:2}, one can check for a smaller hitting set of size at
most  by computing the arrangement , and
directly enumerating all possible hitting sets of size at most
.

The more interesting case is when the set  is defined
implicitly by an instance of the minimal Voronoi separation problem
(i.e., we have a set  of  points in , and a desired
Voronoi partition  of ).  Then
\pitemref{p:1} follows from \thmref{const:sep}. Furthermore,
\pitemref{p:2} follows from the algorithm of \thmrefpage{exact} through
computing the minimal hitting set  of
, in  time, where
.



\begin{figure}[t]
\AlgorithmBox{\algClusterLocal{}(, , ):\+\+\\
   \CodeComment{// : given set of balls need hitting.}\\
   \CodeComment{// : locally optimal hitting
      set of  computed by \Algorithm{LocalHitBalls}.}\\
   \CodeComment{// : optimal hitting set.}\- \\, \quad , \quad , \quad , \quad , \quad and .\\
   \While  \Do \+\+\\
Apply \thmrefpage{ball:separator} to  with
   the parameter . \\, : ball and the separator set returned,
   respectively. \\ be the region of space newly covered by .
   \\ and .\\.\\.\\\-\-\\
.}\caption{Clustering the local optimal solution.}
     \figlab{cluster:local}
\end{figure}




\subsection{Quality of approximation}

The bound on the quality of approximation follows by a clustering
argument similar to the \PTAS algorithm. The clustering is described
in \figref{cluster:local}. This breaks up the local optimal solution
 and the optimal solution  into small sets, and we will
use a local exchange argument to bound their corresponding sizes.  The
following lemma testifies that this clustering algorithm provides a
``smooth'' way to move from  to , through relatively
small steps.


\begin{lemma}
    \lemlab{stabby:stab}Any ball of  is stabbed by , for all ,
    where .
\end{lemma}
\begin{proof}
    The claim holds clearly for , as , where
     is the locally optimal solution. Now, for the sake of
    contradiction, consider the minimum  for which the claim fails,
    and let  be the ball that is not being
    stabbed. We have that  is stabbed by  but not by .

    It can not be that  is stabbed by a point of
    , as such a point is also present in
    .  As such,  must be stabbed by one of the
    points of , and then this stabbing
    point must be inside  -- indeed, the points removed from
     and  as we compute  and
    , respectively, are the ones inside .

    Now, if  intersects , then  stabs  by
    \thmrefpage{ball:separator}, a contradiction.

    

    So it must be that . But then consider
    the region . It must be that . This in
    turn implies that the point of  stabbing  is in
    . A contradiction.
\end{proof}


\begin{lemma}
    \lemlab{opt:chunk:small}Consider any ball that . Let  be the
    minimum index such that  stabs . Then  is
    stabbed by . That is , where
    , , and . Additionally, , for
    all .
\end{lemma}
\begin{proof}
    If  intersects , then it is stabbed by
     by \thmrefpage{ball:separator}. Otherwise, . In particular, this implies that no later point of
     can stab . That is,
    only  stabs .  By \lemref{stabby:stab} both
     and  stab , where . Namely,  is stabbed by a
    point of  that is contained inside . Such a point is
    either in , or in , as
    claimed.

    The second part follows by observing that otherwise  can
    be replaced by  in the optimal solution.

    The third claim follows by observing that by the algorithm design
    , and . As such,
    .
\end{proof}


\begin{lemma}
    \lemlab{local:is:small}Consider any ball  that is stabbed by
     but it is not stabbed by , then
     is stabbed by . Additionally, using the notations of
    \lemref{opt:chunk:small}, we have .
\end{lemma}
\begin{proof}
    If  intersects , then it is stabbed by
     by \thmrefpage{ball:separator}.  So we assume for
    now on that  is not stabbed by .  But then,
    . 


    Now, by \lemref{stabby:stab} both  and  stab
    , where . Namely,
     is stabbed by a point of  that is contained inside
    . Such a point is either in 
    and then we are done, or alternatively, it can be in
    .

    Now, if  then  must stab
    , and we are done. Otherwise, let  be the maximum
    index such that  intersects . Observe
    that as  intersects , it can not be that it
    intersects the balls . In
    particular, \thmrefpage{ball:separator} implies that there is a
    point of  that stabs , as  is being
    stabbed by . This point of 
    is added to , and it is not being removed till
    . Namely, this point is in , and it is
    of course also in , thus implying the claim.

    As for the second part, by \lemref{opt:chunk:small}, . As such, setting  to be sufficiently large, we have that , and the local search algorithm would consider the local
    exchange of  with . As this is an exchange not taken, it
    must be that it is not beneficial, implying the inequality.
\end{proof}

Now we are left with some easy calculations. 

\begin{lemma}
    \lemlab{silly:calcs}We have  that
    \begin{inparaenum}[(i)]
        \item , and 
        \item .
    \end{inparaenum}
\end{lemma}

\begin{proof}
    Observe that  and , where  can be
    made arbitrarily small by making  sufficient large. In
    particular, in every iteration, the algorithm removes 
    points from , and replaces them by 
    points. Starting with a solution of size , where  is some constant, 
    this can happen at
    most . As such, we have , as . The claim now follows by
    setting  to be sufficiently large.

    The second claim follows by observing that  counts the
    numbers of points added to , while  counts the
    number of points removed from it. As  is
    empty, it must be that .
\end{proof}

\begin{lemma}
    \lemlab{local:quality}We have that .
\end{lemma}

\begin{proof}
    We have by \lemref{local:is:small} and \lemref{silly:calcs} that
    
\end{proof}




\subsubsection{The Result}

\begin{theorem}
    Let  be a set of balls in  satisfying properties
    \pitemrefpage{p:1} and \pitemrefpage{p:2}. Then
    \Algorithm{LocalHitBalls} computes, in  time, a
    hitting set of , whose size is a
    -approximation to the minimum size hitting set of
    .
\end{theorem}

\begin{proof}
    \lemref{local:quality} implies the bound on the quality of
    approximation. 

    As for the runtime, observe that the size of local solution
    reduces by at least one after each local improvement, and from
    \pitemrefpage{p:1}, the initial local solution has size
    . Thus there can be at most  local
    improvements. Furthermore, every local solution has at most
     subsets of size  that are checked for local
    improvement. By \pitemrefpage{p:2}, such a local improvement can
    be checked in  time. Thus
    \Algorithm{LocalHitBalls} runs in  time.
\end{proof}



\section{Conclusions}
\seclab{conclusions}

In this paper, we introduced the problem of Voronoi separating a set
of sites into two balanced portions, by introducing separating guards
into the Voronoi diagram. We provided a simple, fast and elegant
algorithm for computing it. We then addressed the problem of how to
compute a Voronoi separating set given a specific partition. This
boils down to a geometric hitting/piercing set problem, which is
quite challenging as the set of balls that needs piercing is
infinite. We showed how to solve this problem exactly using algebraic
techniques, and then we showed how to -approximate it, by
providing a new algorithm for geometric hitting set problem, that
works by reducing the problem into small instances, that can be solved
exactly. We believe this new algorithm to be quite interesting, and it
should be usable for other problems.  Furthermore, the new \PTAS can
be viewed as extending the type of geometric hitting set problems that
can be approximated efficiently. We also introduced a new technique for 
proving local search methods on general geometric hitting set problems, 
based on our strong separator result. 




There are many interesting open problems for further research. In 
particular, the new \PTAS might be more practical for 
the piercing balls problem than previous algorithms, and it might be
worthwhile to further investigate this direction. Additionally, the 
proof technique for the local search algorithm might be applicable 
to other separator based geometric problems whether finite or infinite 
in nature.

\newcommand{\etalchar}[1]{}
 \providecommand{\CNFX}[1]{ {\em{\textrm{(#1)}}}}\providecommand{\CNFSoCG}{\CNFX{SoCG}}\providecommand{\CNFCCCG}{\CNFX{CCCG}}\providecommand{\CNFFOCS}{\CNFX{FOCS}}\providecommand{\CNFSTOC}{\CNFX{STOC}}\providecommand{\CNFSODA}{\CNFX{SODA}}\providecommand{\CNFPODS}{\CNFX{PODS}}\providecommand{\CNFISAAC}{\CNFX{ISAAC}}\providecommand{\CNFFSTTCS}{\CNFX{FSTTCS}}\providecommand{\CNFIJCAI}{\CNFX{IJCAI}}\providecommand{\CNFBROADNETS}{\CNFX{BROADNETS}}\providecommand{\CNFSWAT}{\CNFX{SWAT}} \providecommand{\CNFESA}{\CNFX{ESA}}
  \providecommand{\CNFWADS}{\CNFX{WADS}}\providecommand{\CNFINFOCOM}{\CNFX{INFOCOM}}\providecommand{\Merigot}{M{\'{}e}rigot}\providecommand{\Badoiu}{B\u{a}doiu} \providecommand{\Matousek}{Matou{\v
  s}ek} \providecommand{\Erdos}{Erd{\H o}s}
  \providecommand{\Barany}{B{\'a}r{\'a}ny}
  \providecommand{\Bronimman}{Br{\"o}nnimann}
  \providecommand{\Gartner}{G{\"a}rtner} \providecommand{\Badoiu}{B\u{a}doiu}
  \providecommand{\tildegen}{{\protect\raisebox{-0.1cm}
  {\symbol{'176}\hspace{-0.03cm}}}} \providecommand{\SarielWWWPapersAddr}
  {http://www.uiuc.edu/~sariel/papers} \providecommand{\SarielWWWPapers}
  {http://www.uiuc.edu/\tildegen{}sariel/\hspace{0pt}papers}
  \providecommand{\urlSarielPaper}[1]{ \href{\SarielWWWPapersAddr/#1}
  {\SarielWWWPapers{}/#1}}  \providecommand{\CNFX}[1]{ {\em{\textrm{(#1)}}}}\providecommand{\CNFSTOC}{\CNFX{STOC}}\providecommand{\CNFFOCS}{\CNFX{FOCS}}\begin{thebibliography}{{Har}11b}

\bibitem[AGK{\etalchar{+}}01]{agkmp-lshkm-01}
V.~Arya, N.~Garg, R.~Khandekar, K.~Munagala, and V.~Pandit.
\newblock Local search heuristic for -median and facility location problems.
\newblock In {\em Proc. 33rd Annu. ACM Sympos. Theory Comput.\CNFSTOC}, pages
  21--29, 2001.

\bibitem[AKL13]{akl-vddt-13}
F.~Aurenhammer, R.~Klein, and D.-T. Lee.
\newblock {\em Voronoi Diagrams and Delaunay Triangulations}.
\newblock World Scientific, 2013.

\bibitem[AST90]{ast-stgem-90}
\href{http://www.math.tau.ac.il/~nogaa/}{N.~{Alon}}, P.~D. Seymour, and R.~Thomas.
\newblock A separator theorem for graphs with an excluded minor and its
  applications.
\newblock In {\em STOC}, pages 293--299, 1990.

\bibitem[BCKO08]{bcko-cgaa-08}
{M. de} Berg, \href{http://www.win.tue.nl/~ocheong}{O.~{Cheong}}, {M. van} Kreveld, and \href{http://www.cs.uu.nl/people/markov/}{M.~H. {Overmars}}.
\newblock {\em Computational Geometry: Algorithms and Applications}.
\newblock Springer-Verlag, 3rd edition, 2008.

\bibitem[BPR06]{bpr-arag-06}
S.~Basu, R.~Pollack, and M.~F. Roy.
\newblock {\em Algorithms in Real Algebraic Geometry}.
\newblock Algorithms and Computation in Mathematics. Springer, 2006.

\bibitem[BPTW10]{bptw-betsu-10}
J.~{B{\"o}ttcher}, K.~P. {Pruessmann}, A.~{Taraz}, and A.~{W{\"u}rfl}.
\newblock Bandwidth, expansion, treewidth, separators and universality for
  bounded-degree graphs.
\newblock {\em Eur. J. Comb.}, 31(5):1217--1227, July 2010.

\bibitem[CH12]{ch-aamis-12}
\href{http://www.math.uwaterloo.ca/~tmchan/}{T.~M.~{Chan}} and \href{http://www.uiuc.edu/~sariel}{S.~{{Har-Peled}}}.
\newblock Approximation algorithms for maximum independent set of pseudo-disks.
\newblock {\em \href{http://link.springer-ny.com/link/service/journals/00454/}{Discrete Comput. {}Geom.}}, 48:373--392, 2012.

\bibitem[Cha03]{c-ptasp-03}
\href{http://www.math.uwaterloo.ca/~tmchan/}{T.~M.~{Chan}}.
\newblock Polynomial-time approximation schemes for packing and piercing fat
  objects.
\newblock {\em J. Algorithms}, 46(2):178--189, 2003.

\bibitem[EH06]{eh-ggt-06}
\href{http://www.cs.arizona.edu/~alon/}{A.~{Efrat}} and \href{http://www.uiuc.edu/~sariel}{S.~{{Har-Peled}}}.
\newblock Guarding galleries and terrains.
\newblock {\em Inform. Process. Lett.}, 100(6):238--245, 2006.

\bibitem[EJS05]{ejs-ptasg-05}
T.~Erlebach, K.~Jansen, and E.~Seidel.
\newblock Polynomial-time approximation schemes for geometric intersection
  graphs.
\newblock {\em SIAM J. Comput.}, 34(6):1302--1323, 2005.

\bibitem[EK13]{ek-ltamf-13}
D.~Eisenstat and P.~N. Klein.
\newblock Linear-time algorithms for max flow and multiple-source shortest
  paths in unit-weight planar graphs.
\newblock In {\em Proc. 45th Annu. ACM Sympos. Theory Comput.\CNFSTOC}, pages
  735--744, 2013.

\bibitem[FR06]{fr-pgnwe-06}
J.~Fakcharoenphol and S.~Rao.
\newblock Planar graphs, negative weight edges, shortest paths, and near linear
  time.
\newblock {\em J. Comput. Sys. Sci.}, 72(5):868--889, 2006.

\bibitem[GHT84]{ght-stgbg-84}
J.~R. Gilbert, J.~P. Hutchinson, and R.~E. Tarjan.
\newblock A separator theorem for graphs of bounded genus.
\newblock {\em J. Algorithms}, 5(3):391--407, 1984.

\bibitem[GT08]{gt-salsa-08}
A.~Gupta and K.~Tangwongsan.
\newblock Simpler analyses of local search algorithms for facility location.
\newblock {\em CoRR}, abs/0809.2554, 2008.

\bibitem[{Har}11a]{h-gaa-11}
\href{http://www.uiuc.edu/~sariel}{S.~{{Har-Peled}}}.
\newblock {\em Geometric Approximation Algorithms}, volume 173 of {\em
  Mathematical Surveys and Monographs}.
\newblock Amer. Math. Soc., 2011.

\bibitem[{Har}11b]{h-speps-11}
\href{http://www.uiuc.edu/~sariel}{S.~{{Har-Peled}}}.
\newblock A simple proof of the existence of a planar separator.
\newblock {\em CoRR}, abs/1105.0103, 2011.

\bibitem[HL12]{hl-wgscp-12}
\href{http://www.uiuc.edu/~sariel}{S.~{{Har-Peled}}} and M.~Lee.
\newblock Weighted geometric set cover problems revisited.
\newblock {\em J. Comput. Geom.}, 3(1):65--85, 2012.

\bibitem[HM05]{hm-facsk-05}
\href{http://www.uiuc.edu/~sariel}{S.~{{Har-Peled}}} and S.~{Mazumdar}.
\newblock Fast algorithms for computing the smallest -enclosing disc.
\newblock {\em Algorithmica}, 41(3):147--157, 2005.

\bibitem[Kle08]{k-ltast-08}
P.~N. Klein.
\newblock A linear-time approximation scheme for tsp in undirected planar
  graphs with edge-weights.
\newblock {\em SIAM J. Comput.}, 37(6):1926--1952, 2008.

\bibitem[Koe36]{k-kdka-36}
P.~Koebe.
\newblock Kontaktprobleme der konformen {Abbildung}.
\newblock {\em Ber. Verh. S{\"a}chs. Akademie der Wissenschaften Leipzig,
  Math.-Phys. Klasse}, 88:141--164, 1936.

\bibitem[LT77]{lt-stpg-77}
R.~J. Lipton and R.~E. Tarjan.
\newblock A separator theorem for planar graphs.
\newblock In {\em Proc. GI Conf. Theoret. Comput. Sci.}, 1977.

\bibitem[LT79]{lt-stpg-79}
R.~J. Lipton and R.~E. Tarjan.
\newblock A separator theorem for planar graphs.
\newblock {\em SIAM J. Appl. Math.}, 36:177--189, 1979.

\bibitem[MR09]{mr-pghsp-09}
N.~H. Mustafa and S.~Ray.
\newblock {PTAS} for geometric hitting set problems via local search.
\newblock In {\em Proc. 25th Annu. ACM Sympos. Comput. Geom.\CNFSoCG}, pages
  17--22, 2009.

\bibitem[MTTV97]{mttv-sspnng-97}
G.~L. Miller, S.~H. Teng, W.~P. Thurston, and S.~A. Vavasis.
\newblock Separators for sphere-packings and nearest neighbor graphs.
\newblock {\em \href{http://www.acm.org/jacm/}{J. Assoc. Comput. {Mach.}}}, 44(1):1--29, 1997.

\bibitem[O'R87]{o-agta-87}
\href{http://cs.smith.edu/~orourke/}{J.~{O'Rourke}}.
\newblock {\em Art Gallery Theorems and Algorithms}.
\newblock The International Series of Monographs on Computer Science. Oxford
  University Press, 1987.

\bibitem[PA95]{pa-cg-95}
\href{http://www.math.nyu.edu/~pach}{J.~{Pach}} and \href{http://www.cs.duke.edu/~pankaj}{P.~K.~{Agarwal}}.
\newblock {\em Combinatorial Geometry}.
\newblock John Wiley \& Sons, 1995.

\bibitem[SVY09]{svy-dosg-09}
C.~Sommer, E.~Verbin, and W.~Yu.
\newblock Distance oracles for sparse graphs.
\newblock In {\em Proc. 50th Annu. IEEE Sympos. Found. Comput. Sci.\CNFFOCS},
  pages 703--712, Georgia, USA, 2009.

\bibitem[SW98]{sw-gsta-98}
W.~D. Smith and N.~C. Wormald.
\newblock Geometric separator theorems and applications.
\newblock In {\em Proc. 39th Annu. IEEE Sympos. Found. Comput. Sci.\CNFFOCS},
  pages 232--243, 1998.

\end{thebibliography}



\appendix

\section{Separating the guards}
\apndlab{sperating:guards}

Here, we show that given a set of guards  how one can
(efficiently) separates  into two subsets, one of them of size
, by adding  guards, such that the
underlying ball hitting instance gets separated into two separate
subproblems. To this end, we prove an extension of
\thmrefpage{separator:main}.

\subsection{Preliminaries}

\begin{lemma}
    \lemlab{shield:ball}Given a sphere  in  with center  and radius
    , and given a parameter , one can
    compute in a set  of size , such
    that every ball of radius  that intersects 
    is stabbed by a point of . The time to compute  is
     time.
\end{lemma}

\begin{proof}
    Consider the ring , and pick a -dense set in . To
    this end, consider the grid of sidelength , and
    take the vertices of the grid that are inside . To verify
    the claim on the size, observe that every such grid vertex, must
    be adjacent to a grid cell that is fully contained in the expanded
    ring . The volume
    of such a grid cell is , and the volume of this
    ring is , implying the claim. As for the
    running time claim, observe that the set of vertices of interest
    are grid connected, and a simple \si{BFS} would compute all of
    them.
    
    It is now easy to verify that such a dense set intersects any ball
    of radius  that intersects .
\end{proof}




Let  be a set of balls in  that are stabbed by a set
 of points in . Let  be a parameter. We show how to
compute a set  of  points and a sphere
 such that;
\begin{compactenum}[\quad(A)]
    \item The set  is broken into two sets: (i)  --
    the points of  inside , and (ii)  -- the
    points outside.
    
    \item .
    
    \item Every ball of  that intersects , is
    stabbed by a point of .
\end{compactenum}


\subsection{The Algorithm}

The input is a set of points  in , and a parameter .
\begin{compactenum}[\qquad (A)]
    \item Using the algorithm of \cite{hm-facsk-05}, compute in linear
    time a -approximation to the smallest (closed) ball
     that contains  points of , where
    ..
    
    \item Let .
    
    \item Pick a number  uniformly at random from the range
    .
    
    \item Let  represent the points of  in
    .
    
    \item Let .
    
    
    \item Compute the set  as in \lemref{shield:ball}, of
    size , for
    the sphere  and parameter .
    
    \item If a point  is in distance smaller than
     from , we insert it into .
\end{compactenum}
\bigskip

\noindent
We claim that in expectation,  is the desired sphere, and
 is the corresponding desired set of points.

\subsubsection{Correctness}

\begin{lemma}\lemlab{correctness:1}We have  and
    .
\end{lemma}

\begin{proof}
    Since  contains ,
     by
    construction.  Now by \defref{dbl:constant}, the ball  can
    be covered by  balls of radius . Each
    one of them contains at most  points, as 
    is (up to a factor of two) the smallest ball containing  points
    of . Thus, .
\end{proof}


\begin{lemma}
    \lemlab{sphere:separates}Let  be a set of balls stabbed by .  Every ball
    in  that intersects , is stabbed by a point
    of .
\end{lemma}

\begin{proof}
    By construction, every ball of  that intersects
    , whose size is at least , is stabbed by a
    point of .  For the case of smaller balls, consider that
    every ball in  is stabbed by some point of . Now
    any ball of size less than  intersecting , must
    be centered within a distance of  from
    . Consequently, the point of  that stabs it, must
    be within a distance of  from . But by
    construction,  also contains this point.
\end{proof}


\begin{lemma}
    \lemlab{separator:size}Let . We have that .
\end{lemma}

\begin{proof}
    Let  be the number of points of , that were added to
    . We claim that .  To this
    end, for a point , let  be the indicator
    variable that is one if and only if  is in distance at most
     from . The algorithm picked the radius 
    uniformly at random in the interval . Furthermore,  if and only if
    . This happens only if  falls into an interval
     that is of length at most  centered at
    . As such, we have
    
    Now, by linearity of expectation, we have that . This implies the
    claim, as .
\end{proof}


\subsection{The result}
\begin{theorem}[Restatement of \thmref{ball:separator}.]
    \thmlab{ball:separator:restate}Let  be a set of points in , and  be an integer
    sufficiently smaller than .  One can compute, in
     expected time, a set  of
     points and a sphere  containing
     points of  inside it, such that for any set
     of balls stabbed by , we have that every ball
    of  that intersects  is stabbed by a point of
    .
\end{theorem}








\end{document}
