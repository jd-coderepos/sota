\def\year{2021}\relax
\documentclass[letterpaper]{article} \usepackage{aaai21}  \usepackage{times}  \usepackage{helvet} \usepackage{courier}  \usepackage[hyphens]{url}  \usepackage{graphicx} \urlstyle{rm} \def\UrlFont{\rm}  \usepackage{graphicx}  \usepackage{natbib}  \usepackage{caption} \frenchspacing  \setlength{\pdfpagewidth}{8.5in}  \setlength{\pdfpageheight}{11in}  

\usepackage{amsmath}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{array, boldline, makecell, booktabs}
\usepackage{amssymb}
\usepackage{color}
\newcommand{\tabincell}[2]{\begin{tabular}{@{}#1@{}}#2\end{tabular}}
\usepackage{bbm}
\usepackage[switch]{lineno}
\usepackage{bm}

\newcommand{\sectionref}[1]{Section~\ref{#1}}
\newcommand{\tabref}[1]{Table~\ref{#1}}
\newcommand{\figref}[1]{Figure~\ref{#1}}
\newcommand{\algoref}[1]{Algorithm~\ref{#1}}
\newcommand{\eg}[1]{\textit{e.g.,}}
\newcommand{\ie}[1]{\textit{i.e.,}}

\pdfinfo{
/Title (Group-Wise Semantic Mining for Weakly Supervised Semantic Segmentation)
/Author (Xueyi Li, 
Tianfei Zhou, 
Jianwu Li,
Yi Zhou,
Zhaoxiang Zhang)
/TemplateVersion (2021.1)
} 






\title{Group-Wise Semantic Mining for Weakly Supervised Semantic Segmentation}

\author{Xueyi Li\textsuperscript{\rm 1}, 
		Tianfei Zhou\textsuperscript{\rm 2}\thanks{Corresponding author: \textit{Tianfei Zhou}}, 
		Jianwu Li\textsuperscript{\rm 1},
		Yi Zhou\textsuperscript{\rm 3},
		Zhaoxiang Zhang\textsuperscript{\rm 4} \\
		}
 
\affiliations{
 	\textsuperscript{\rm 1 }{Beijing Key Laboratory of Intelligent Information Technology,} \\ {School of Computer Science and Technology, Beijing Institute of Technology, China} \\
 	\textsuperscript{\rm 2 }{Computer Vision Laboratory, ETH Zurich, Switzerland} \\
 	\textsuperscript{\rm 3 }{School of Computer Science and Engineering, Southeast University, China} \\
 	\textsuperscript{\rm 4 }{Center for Research on Intelligent Perception and Computing, CASIA, China}\\
 	\texttt{\{xueyili,ljw\}@bit.edu.cn~~~ tianfei.zhou@vision.ee.ethz.ch}
 }

\begin{document}


\maketitle

\begin{abstract}
	
	Acquiring sufficient ground-truth supervision to train deep visual models has been a bottleneck over the years due to the data-hungry nature of deep learning. This is exacerbated in some structured prediction tasks, such as semantic segmentation, which requires pixel-level annotations. This work addresses weakly supervised semantic segmentation (WSSS), with the goal of bridging the gap between image-level annotations and pixel-level segmentation. We formulate WSSS as a novel group-wise learning task that explicitly models semantic dependencies in a group of images to estimate more reliable pseudo ground-truths, which can be used for training more accurate segmentation models. In particular, we devise a graph neural network (GNN) for group-wise semantic mining, wherein input images are represented as graph nodes, and the underlying relations between a pair of images are characterized by an efficient co-attention mechanism. Moreover, in order to prevent the model from paying excessive attention to common semantics only, we further propose a graph dropout layer, encouraging the model to learn more accurate and complete object responses. The whole network is end-to-end trainable by iterative message passing, which propagates interaction cues over the images to progressively improve the performance. We conduct experiments on the popular PASCAL VOC 2012 and COCO benchmarks, and our model yields state-of-the-art performance. Our code is available at: \textit{\texttt{https://github.com/Lixy1997/Group-WSSS}}.
\end{abstract}
\section{Introduction}



\begin{figure*}[!t]
	\centering
	\includegraphics[width=\textwidth]{./figures/fig1.pdf}
	\caption{\small\textbf{Architecture comparison of existing frameworks \textit{vs.} Ours.} (a) Single-image models feed each image one by one into the network for training, which bears high similarity with standard classifiers (\eg, VGG). (b) Pair-wise methods extract features from a pair of images using a Siamese network, and make predictions using a pair-wise classifier which has learned the correlation between the two images. (c) We propose a group-wise method that accepts an arbitrary number of images as input. The input images are \textit{iteratively} processed by a GNN to enable substantial information to exchange, and a group-wise classifier is then adopted for prediction.}
	\label{fig:1}
\end{figure*}

Semantic segmentation is a fundamental task in computer vision, aiming to assign a semantic category to each pixel in an image. It can benefit a wide variety of applications including autonomous driving, image editing and medical diagnosis.  With the recent renaissance of deep neural networks, semantic segmentation has achieved tremendous progress. However, most of the leading approaches~\cite{long2015fully,wang2019learning,zhou2020matnet,zhou2020motion} are fully supervised, requiring massive amounts of pixel-level annotated training data, which are extremely expensive and time-consuming to obtain. In contrast, the weak supervision alternatives, \eg, image-level tags~\cite{pathak2015constrained,kolesnikov2016seed,qi2016augmented,wei2016stc,chaudhry2017discovering,ahn2018learning,fan2018associating}, scribbles~\cite{lin2016scribblesup,vernaza2017learning} or bounding-box annotations~\cite{dai2015boxsup,khoreva2017simple,song2019box}, are less costly. Thus, it is of interest to explore the potential of these weak supervision cues in providing a data-efficient solution for semantic segmentation. In this paper, we aim to address weakly supervised semantic segmentation (WSSS) under the supervision of image-level tags, which can be obtained effortlessly.

WSSS based on image tags is extremely challenging because fine-grained pixel-level annotations, which are typically required for semantic segmentation, are difficult to obtain from class labels. The pioneering work,~\cite{zhou2016learning}, proposes an efficient and straightforward way to solve this by recognizing the discriminative regions specific to a given category using class activation maps (CAMs), which are then refined to obtain pseudo ground-truths for supervising a semantic segmentation network. Along this line, a number of approaches have been proposed to improve the estimation of CAMs so that they cover the full extent of objects rather than only the most representative parts. For example, some approaches~\cite{wei2017object,kolesnikov2016seed,choe2019attention} manipulate internal feature maps to guide the network to perceive easily ignored but essential parts, while others~\cite{hou2018self,chang2020weakly,fan2020learning,wang2020self} adopt self-ensembling or self-supervision to improve localization.

However, the mainstream methods above are merely based on \textit{\textbf{single images}} (\figref{fig:1} (a)), ignoring the valuable semantic context existing in a group of images. The very recent studies~\cite{fan2020cian,sun2020mining} utilized Siamese networks to model the relations between a pair of images, leading to a \textit{\textbf{pair-wise}} solution (\figref{fig:1} (b)). These approaches have proven effective in locating more accurate object regions. However, seeking relations between two images at a time is still limited in capturing substantial semantic context. 
Accordingly, we introduce a more promising, and fundamentally different  \textit{\textbf{group-wise}} solution (\figref{fig:1} (c)) which comprehensively mines richer semantics from a group of images. Our main motivation is that the availability of group images containing instances of the \textit{same semantic classes} can make up for the absence of detailed supervisory information. From this perspective, we hypothesize that it is desirable to take advantage of all available information for WSSS, including not only individual image properties, but also group-level synergetic relationships. 


Based on the above analysis, we propose a novel deep learning model for WSSS. Unlike previous pair-wise approaches, our model is targeted at group-wise semantic mining to capture more comprehensive relations among input images. Specifically, we develop an efficient, end-to-end trainable graph neural network (GNN), and conduct recursive reasoning for group-wise semantic understanding. In our graph, the nodes represent a group of input images, and edges describe pair-wise relations between two connected images.  We consider two images as connected only if they share common semantic objects with each other, and their relation is then characterized by an elaborately designed co-attention mechanism. Through iterative message passing, the information from individual elements can be efficiently integrated and broadcasted over the graph structure. In this way, our model is capable of leveraging explicit semantic dependencies among images to obtain better node representations. However, this graph reasoning strategy mainly focuses on co-occurring semantics in a group of images, ignoring isolated objects. To address this, we further introduce a graph dropout layer, which can be seamlessly integrated into the GNN for iterative inference. The graph dropout layer selectively suppresses the most salient objects, forcing the network to be biased toward their counterparts. 

Our method has two appealing characteristics over single-image and pair-wise methods. \textbf{First}, it is capable of learning semantic relations from an arbitrary number of images using a flexible GNN framework. The GNN empowers our model to inherit the complementary strengths of neural networks in learning capability and graphical models in structure representations. \textbf{Second}, our model adopts multi-step, iterative inference to progressively improve image representations. This is more favorable than directly producing representations by one-step inference in previous approaches

In summary, our main contributions are three-fold: \textbf{First}, we demonstrate the advantages of group-wise semantic mining for WSSS, and proffer a graph-aware solution for effective inference. \textbf{Second}, we develop a graph dropout layer to promote the missing categories, leading to more accurate localization. \textbf{Third}, we evaluate the proposed approach on two large-scale benchmarks, \ie, PASCAL VOC 2012~\cite{everingham2010pascal} and COCO~\cite{lin2014microsoft}, and the results demonstrate its superiority. 




\section{Related Work}

\noindent\textbf{Weakly Supervised Semantic Segmentation.}
Recent years have seen	a surge of interest in semantic segmentation under weak supervision (\eg, image-level labels, scribbles, bounding boxes), greatly reducing human efforts in manual labeling. In particular, methods operating with image-level labels have attracted the most attention since they require minimal annotation efforts. Most of these methods follow a popular pipeline that trains an image classifier using image-level labels, and exploits CAMs to highlight the most discriminative object regions for a particular semantic category as its pseudo ground-truth. However, CAMs are weak in revealing complete object regions, resulting in poor segmentation performance. Some pioneering efforts address this difficulty 
by learning pixel affinities~\cite{ahn2018learning}, erasing the most discriminative parts~\cite{wei2017object,choe2019attention,lee2019ficklenet}, optimizing intra-class discrimination~\cite{fan2020learning}, or applying region growing~\cite{kolesnikov2016seed,wei2018revisiting,huang2018weakly} to capture the full extent of objects. However, these methods are confined to using only limited image-level information. More recent approaches thus follow the self-supervised paradigm to acquire additional supervisions~\cite{shimoda2019self,wang2020self}, or rely on Siamese networks to capture semantic relations between a pair of images~\cite{fan2020cian,sun2020mining}. 

In this paper, we take a further step toward discovering higher-order relations among images. A graph model is designed to encode such relationships. Through graph reasoning, our model iteratively refines object representations by accepting informative knowledge from other images.








\begin{figure*}[!t]
	\centering
	\includegraphics[width=\textwidth]{./figures/fig2.pdf}
	\put(-403,17){\tiny }
	\put(-403,40){\tiny }
	\put(-403,91){\tiny }
	\put(-403,111){\tiny }
	\put(-31,106){\tiny }
	\put(-31,79){\tiny }
	\put(-31,53){\tiny }
	\put(-31,28){\tiny }
	\put(-14,106){\tiny }
	\put(-14,79){\tiny }
	\put(-14,53){\tiny }
	\put(-14,28){\tiny }
	\put(-355,12){\tiny }
	
	\caption{\small \textbf{Overview of the proposed group-wise semantic mining network} during the training phase. Given a group of images (\ie, ), our model uses VGG16 to extract convolutional features (\ie, ), which are used as the initial embeddings for graph construction. Next, our model conducts -step graph reasoning to iteratively refine the features by \textit{message passing} (Eq.\!~\eqref{eq:8}), \textit{message aggregation} (Eq.\!~\eqref{eq:2}), and \textit{graph dropout} (Eq.\!~\eqref{eq:10}). The final features (\ie, ) are fed into a readout function (Eq.\!~\eqref{eq:9}) to get the  predictions (\ie, ).}

	\label{fig:2}
\end{figure*}

\noindent\textbf{Graph Neural Networks.}
Graph neural networks were proposed in~\cite{scarselli2008graph}, and have since gained widespread attention due to their superiority in dealing with flexible graph-structured data. GNNs typically model the graph elements (\eg, nodes, edges) and approximation inference as learnable neural networks, and conduct iterative reasoning to explicitly discover the relations among nodes. They have achieved wide success in a variety of fields, including molecular biology~\cite{gilmer2017neural}, computer vision~\cite{qi20173d,lu2020video,marino2016more,wang2019zero,santoro2017simple,wang2020hierarchical}, and machine learning~\cite{velivckovic2017graph,qu2019gmnn}. Inspired by these efforts, we build an image-level graph network to model their semantic relations for the WSSS task. Assisted by a graph dropout layer, our model can generate more accurate pseudo ground-truths for semantic segmentation.


\section{Methodology}

In this section, we elaborate on the proposed model for WSSS. Given training images with only image-level labels, current efforts operate on two sub-tasks to achieve pixel-wise predictions. The first one is \textit{pseudo ground-truth generation}, which relies on an image classification network to localize discriminative regions. The other one is \textit{semantic segmentation}, which conducts dense predictions using a fully convolutional network (FCN) under the supervision of pseudo labels. Our approach also follows this pipeline. However, unlike previous approaches that treat each single image independently, our model aims to mine common semantic patterns from multiple images by graph inference. In this way, our model can alleviate the incomplete-annotation problem in WSSS and produce more accurate pseudo labels.





\subsection{Preliminary: Graph Neural Networks}
We start by revisiting the basic concept of GNNs. We define a graph  by its node set  and edge set . We assume that each node  is associated with a feature embedding vector , and each edge  has an edge representation . During inference, GNNs iteratively improve the feature representations at a node by aggregating its neighborhood features. Specifically, a GNN maps the graph  to the node outputs through two phases: a message passing phase and a readout phase. The message passing phase is defined in terms of a \textit{message function} , whose input is a node's features and output is a message, and an \textit{aggregation function} , whose input is a set of messages and output is the updated features. Suppose we conduct  rounds of message passing; the -th round for a node  can be described as:

where for , the message function firstly summarizes the information (\ie, ) from its neighbors , and then uses it to update the node state. Then, in the readout phase, a task-specific readout function  operates on the final node representation  to produce a node output:


Next, we will present the details of the proposed graph-based semantic mining model for pseudo ground-truth generation in WSSS.

\subsection{Group-Wise Semantic Mining Network}

\noindent\textbf{Problem Definition:} 
Given a collection of training samples, our first goal is to generate corresponding pseudo ground-truths, which will later be used to supervise semantic segmentation networks. To achieve this, we formulate the problem as graph-based semantic co-mining among multiple images. Formally, we denote  as the training data, where  is an image and  is the corresponding image-level ground-truth with  possible semantic categories. During training, we \textit{selectively} sample  images  as a mini-batch, and model their relations as a directed graph , where the image  is denoted as node , and the relation between  and  is represented by edge . To better capture more comprehensive common semantics, we consider two nodes  and  to be linked only if there is at least one semantic category shared between them. Besides, we assume that every node has a \textit{self-edge}, \eg,  for .

Given the above definitions, our network aims to conduct pseudo ground-truth generation in a graph learning scheme, under the full supervision of image-level labels as well as the implicit semantic relations among different images. In this manner, our model can capture richer semantic information and obtain more accurate pseudo labels. Next, we describe the details of each component in our model.

\noindent\textbf{Node Embedding:}
As an initial step, we abstract a high-level feature representation for each input image. Formally, given , we extract features  from the convolutional stages of a standard classification network (\eg, VGG\!~\cite{simonyan2014very}). The embedding of node  is then initialized by , which is a -dimensional tensor preserving full spatial details for more effective pixel-level matching during graph reasoning. 

\noindent\textbf{Edge Embedding:} For each edge  connecting  to , we aim to learn an edge embedding  at each iteration  to find the correct semantic correspondence between the two nodes. This is achieved by dense matching over node embeddings using the following bilinear model:

where  and  are flattened into matrix representations for computational convenience.  is a trainable weight matrix. In Eq.~\eqref{eq:4},  encodes the similarity between  and  for all pairs of spatial locations.
For the edge , its embedding at iteration  is simply calculated as .


It should be noted that Eq.~\eqref{eq:4} introduces a large number of parameters, increasing the computational cost. To alleviate this,  is approximately factorized into two low-rank matrices  and , where  is a reduction ratio. Then, Eq.~\eqref{eq:4} can be rewritten as:

Eq.~\eqref{eq:5} has significant advantages over Eq.~\eqref{eq:4} in both model parameters and computational cost: 1) it reduces the number of parameters by  times; 2) it only requires  multiplication operations, instead of the  in Eq.~\eqref{eq:4}. 

In addition, for each self-edge , its embedding  captures the self-relation over the node representation . We compute  at iteration  by self-attention~\cite{vaswani2017attention,wang2018non}, which can effectively capture long-range semantic dependencies. In particular, the self-attention calculates the response at a position by attending to all the positions within the same node embedding:

where  are  convolutional operators. As seen, we also consider it to be a residual layer in Eq.~\eqref{eq:6}, which can effectively preserve information in the original feature map.

\noindent\textbf{Message Passing:}
Given the node and edge embeddings, our model iteratively updates the hidden states of graph nodes by applying message functions to collect information from their neighboring nodes. More specifically, for a node , it absorbs knowledge along two types of edges: 1) a self-edge  that encodes rich context-aware knowledge in ; and 2) other edges  that connect  to . For the former, our message function directly reads the message from , \ie, ; while for the latter, the messages are summarized as: 

where  denotes the row-wise softmax operation. In Eq.\!~\eqref{eq:7}, we accumulate knowledge from , which is weighted based on the similarity between  and .  is then reshaped to a -dimensional tensor. Then, we can easily summarize the message for  at  the -th iteration as:


Next, the aggregation function  updates the hidden states of nodes, as given in Eq.\!~\eqref{eq:2}. In our method,  is instantiated by a ConvGRU network~\cite{ballas2015delving}, which is an extension of the GRU update function used in~\cite{gilmer2017neural}. In this way, the message passing algorithm runs for  steps before convergence, iteratively collecting messages and updating node embeddings.

\noindent\textbf{Readout Phase:}
Having repeated the above process for  time steps, we obtain the final node embedding  for . Then, the readout function  is applied to the features  for image classification:

where  is a class-aware convolutional layer with kernel size  that obtains a feature map with  channels, and  denotes a \textit{global average pooling} layer which produces the final classification outputs.




\noindent\textbf{Pseudo Ground-Truth Generation by Self-Ensembling:} 
Once the classification results are obtained (Eq.\!~\eqref{eq:9}), we discover the discriminative image regions for a particular category following~\cite{jiang2019integral}. These regions are further thresholded to generate pseudo ground-truths. 

Besides, as shown in~\figref{fig:2}, for each input image, our network produces two outputs based on raw convolutional features  as well as enriched features . This not only introduces additional deeply supervised constraints~\cite{lee2015deeply} which could benefit the performance, but also enables the results to be further improved by ensembling the CAMs of multiple outputs. We found that the pseudo ground-truths from different outputs are well complementary with each other, and self-ensembling them by averaging can further improve the performance (see~\tabref{table:2}).  


\subsection{Graph Dropout Layer}
The above graph reasoning scheme enables our model to discover common semantics present in different images (Eq.\!~\eqref{eq:5}). The features of these semantics can be accordingly enriched by summarizing all the information from other images (Eq.\!~\eqref{eq:8}). However, standalone categories, which may exist only in a single image, are almost ignored in this procedure. To address this, we introduce a graph dropout layer to force the network to pay more attention to these categories. Formally, given the feature map  at the -th iteration, we average it along the channel dimension to obtain . Then, we generate a mask  as follows:

Here, the parameter  is a drop rate threshold, determining whether to carry out the dropout operation or not. The parameter  is a scalar generated from a random generator. If ,  is an importance map which supports the activations in ; otherwise, the layer drops the highly activated semantic regions to emphasize standalone semantics.  is a matrix indicator function which returns  for the true elements in , and  otherwise. The  operation calculates the maximum value for a 2D tensor.  is a threshold controlling the dropout.
Finally, we enhance the feature maps by:

where  denotes spatial-wise multiplication. Note that  is then used to replace original features  in the next iteration.

\begin{table}[t]
	\centering
	\small
	\caption{\small \textbf{Quantitative comparison of different methods} on PASCAL VOC 2012 \textit{val} and \textit{test} in terms of mIoU. : VGG backbone. : ResNet backbone.}
	\begin{tabular}{l|c|cc}
		\hlineB{2.5}
		\textit{Methods} & \textit{Pub.}  &  \textit{Val} & \textit{Test} \\ \hline\hline
		
		
		MEFF{\!~\tiny~\cite{ge2018multi}} & CVPR18 & - & 55.6\% \\ 
		GAIN{\!~\tiny~\cite{li2018tell}} & CVPR18 & 55.3\% & 56.8\% \\ 
MDC{\!~\tiny~\cite{wei2018revisiting}}  & CVPR18  & 60.4\% & 60.8\% \\
		RRM{\!~\tiny~\cite{zhang2020reliability}}  & AAAI20  & 60.7\% & 61.0\% \\	
		MCOF{\!~\tiny~\cite{wang2018weakly}} & CVPR18  & 60.3\% & 61.2\% \\
SeeNet{\!~\tiny~\cite{hou2018self}}  & NIPS18  & 63.1\% & 62.8\% \\
		DSRG{\!~\tiny~\cite{huang2018weakly}} & CVPR18  & 61.4\% & 63.2\% \\
		AffinityNet{\!~\tiny~\cite{ahn2018learning}} & CVPR18  & 61.7\% & 63.7\% \\
		SS-WSSS{\!~\tiny~\cite{araslanov2020single}} & CVPR20  & 62.7\% & 64.3\% \\
		SSNet{\!~\tiny~\cite{zeng2019joint}} & ICCV19  & 63.3\% & 64.3\% \\
		IRNet{\!~\tiny~\cite{ahn2019weakly}} & CVPR19  & 63.5\% & 64.8\% \\ 
		CIAN{\!~\tiny~\cite{fan2020cian}}  & AAAI20  & 64.3\% & 65.3\% \\
		FickleNet{\!~\tiny~\cite{lee2019ficklenet}}  & CVPR19  & 64.9\% & 65.3\% \\
		IAL{\!~\tiny~\cite{wang2020weakly}} & IJCV20 & 64.3\% & 65.4\% \\
		SSDD{\!~\tiny~\cite{shimoda2019self}}  & ICCV19  & 64.9\% & 65.5\% \\
		SEAM{\!~\tiny~\cite{wang2020self}}  & CVPR20  & 64.5\% & 65.7\% \\
		SubCat{\!~\tiny~\cite{chang2020weakly}}  & CVPR20  & 66.1\% & 65.9\% \\
		OAA+{\!~\tiny~\cite{jiang2019integral}}  & ICCV19  & 65.2\% & 66.4\% \\
		RRM{\!~\tiny~\cite{zhang2020reliability}}  & AAAI20  & 66.3\% & 66.5\% \\
		BES{\!~\tiny~\cite{chenweakly}}  & ECCV20  & 65.7\% & 66.6\% \\
		EME{\!~\tiny~\cite{fanemploying}}  & ECCV20  & 67.2\% & 66.7\% \\
		MCIS{\!~\tiny~\cite{sun2020mining}}  & ECCV20  & 66.2\% & 66.9\% \\
		ICD{\!~\tiny~\cite{fan2020learning}} & CVPR20  & 67.8\% & 68.0\% \\ \hline
		Ours (VGG16)  & -- & 63.3\% & 63.6\% \\
		Ours (ResNet101) & -- & \textbf{68.2\%} & \textbf{68.5\%} \\ 
		\hline
	\end{tabular}
	
	\label{table:1}
\end{table}



\subsection{Detailed Network Architecture}

Our model is comprised of two sub-networks: a \textit{classification network} for group-wise pseudo ground-truth generation and a \textit{segmentation network} for semantic segmentation. 

\noindent\textbf{Classification Network.}
We choose VGG16~\cite{simonyan2014very} as the backbone, which is pre-trained on ImageNet~\cite{deng2009imagenet}. We replace the last convolutional layer in VGG16 by dilated convolutions with a rate of 2, and the feature maps from this layer are taken as the initial node representations for the GNN. For each image , our network has two outputs: an intermediate output  which is directly obtained from the backbone (\figref{fig:2}), and a final output  after graph reasoning (\figref{fig:2}). Then, the loss function of the classification network for image  is:
  
where  indicates the standard sigmoid cross entropy loss, and  balances the two losses.

After training, we obtain the CAMs for each training image from the two classification layers mentioned earlier, and combine them to obtain foreground object seeds. Besides, we also follow conventional practices~\cite{jiang2019integral,fan2020learning} to estimate background seeds using an off-the-shelf salient object detection model~\cite{hou2017deeply}. The final pseudo labels are generated by combining the foreground and background seeds.


\noindent\textbf{Segmentation Network.}
Following~\cite{chang2020weakly,fan2020cian}, we choose DeepLab-v2~\cite{chen2017deeplab} as the segmentation network due to its superior performance in fully supervised semantic segmentation tasks. 

\begin{table}[t]
	\centering
	\small
	\caption{\small \textbf{Quantitative comparison of different methods} on COCO \textit{val} in terms of mIoU. All methods use VGG16 as the backbone.}
	\begin{tabular}{l|c|cc}
		\hlineB{2.5}
		\textit{Methods} & \textit{Pub.}  &  \textit{Val}\\ \hline\hline
		BFBP{\!~\tiny~\cite{saleh2016built}} & ECCV16 & 20.4\%  \\ 
		SEC{\!~\tiny~\cite{kolesnikov2016seed}} & ECCV16 & 22.4\% \\ 	
		DSRG{\!~\tiny~\cite{huang2018weakly}}  & CVPR18  & 26.0\% \\
		IAL{\!~\tiny~\cite{wang2020weakly}}  &IJCV20  & 27.7\% \\
		\hline
		Ours & -- & \textbf{28.4\%}\\ \hline
	\end{tabular}
	
	\label{table:3}
\end{table}

\section{Experiments}
\subsection{Experimental Setup}

\noindent\textbf{Datasets:}
We conduct our experiments on two datasets: PASCAL VOC 2012~\cite{everingham2010pascal} and COCO~\cite{lin2014microsoft}. 1) \textbf{PASCAL VOC 2012} is currently the most popular benchmark for WSSS. The dataset contains 20 semantic categories (\eg, person, bicycle, cow) and one background category. Following standard protocol~\cite{huang2018weakly,lee2019ficklenet,wang2020self}, extra data from SBD~\cite{hariharan2011semantic} is also used for training, leading to a total of 10,582 training images. We evaluate our model on the standard validation and test sets, which have 1,449 and 1,456 images, respectively. 
2) \textbf{COCO} is a more challenging benchmark with 80 semantic classes. Since more complex contextual relations exist among these categories, it is interesting to examine the performance of our model in this dataset. Following~\cite{wang2020weakly}, we use the default train/val splits (80k images for training and 40k for validation) in the experiment.

\noindent\textbf{Evaluation Metric:} For fair comparison, we utilize a widely used metric~\cite{wang2018weakly,choe2019attention,sun2020mining}, \textit{mean Intersection-over-Union (mIoU)}, for evaluation. The scores on the test set of PASCAL VOC are obtained from the official evaluation server.


\noindent\textbf{Training Details:} 
1) \textit{Greedy Mini-Batch Sampling.} During training, we design a heuristic, greedy strategy to sample  training images in each mini-batch. Starting from a randomly sampled image , we further find another  images, each of which shares as many common semantic objects with  as possible. These  images are then used to build a -node GNN. This sampling strategy enables our model to better explore rich relationships among groups of images and improve the results.
2) \textit{Training Settings.} 
For the classification network, the number of nodes  and message passing steps  in the GNN are separately set to 4 and 3 by default. The input image size is . The entire network is trained using the SGD optimizer with initial learning rates of 1e-3 for the backbone and 1e-2 for the GNN, which are reduced by 0.1 every five epochs. The total number of epochs, momentum and weight decay are set to 15, 0.9, and 5e-4, respectively. The  in Eq.~\eqref{eq:12} is empirically set to 0.4 and the  in Eq.~\eqref{eq:5} is set to 4. For the segmentation network, we follow the training setting in~\cite{chen2017deeplab}, but use the generated pseudo ground-truths as the supervision.



\noindent\textbf{Reproducibility:} 
Our network is implemented in PyTorch and trained on four NVIDIA RTX 2080Ti GPUs with 11GB memory per card. The testing is conducted on the same machine with one GPU card. 

\subsection{Performance on PASCAL VOC 2012}
We evaluate the proposed approach on PASCAL VOC 2012 against current top-performing WSSS methods that only operate with image-level labels. Following conventions, we evaluate the performance of our model using VGG16~\cite{simonyan2014very} and ResNet101~\cite{he2016identity} as the backbones, respectively. As reported in~\tabref{table:1}, our model with ResNet101 achieves the best performance, scoring  and  on the \textit{val} and \textit{test} sets, respectively. It significantly outperforms the current leading approach, \ie, ICD~\cite{fan2020learning}, by  and  on the two evaluation sets. 

In addition,~\tabref{table:1} also shows that the proposed approach outperforms both pair-wise models (\ie, CIAN~\cite{fan2020cian} and MCIS~\cite{sun2020mining}), and all single-image based models (\eg, RRM~\cite{zhang2020reliability}, OAA+~\cite{jiang2019integral}), by a large margin. The reason lies in that existing methods exploit limited context in image collection, while our approach can learn more effective inter-image representations with GNNs. 






In~\figref{figure:3}, we also provide sample results for representative images in PASCAL VOC 2012 \textit{val}. The images cover various challenging factors in WSSS, such as multiple objects, different semantic categories, small objects, and cluttered background. We see that our model can deal with these difficulties well, resulting in appealing segmentation results.



\subsection{Performance on COCO}
We further examine the performance of our model on COCO. As reported in~\tabref{table:3}, our model achieves the best mIoU score (\ie, \textbf{28.4\%}) on the validation set, outperforming the second-best result, \ie, IAL~\cite{wang2020weakly}, by \textbf{0.7\%}. This further proves the superiority of our model.

\begin{table}[t]
	\centering
	\caption{\small \textbf{Diagnostic experiments of our model} on PASCAL VOC 2012 \textit{val} in terms of mIoU. For all variants, we use ResNet101 as the backbone.}
	\small
	\begin{tabular}{c|c|c|c|c}
		\hlineB{2.5}
		\multicolumn{2}{c|}{\textit{Aspect}} & \multicolumn{2}{c|}{\textit{Variant}} & \textit{mIoU}\\\hline\hline
		
		\multicolumn{2}{c|}{\multirow{2}{*}{\tabincell{c}{\textbf{Full Model}}}} & \multicolumn{2}{c|}{, } & \multirow{2}{*}{\tabincell{c}{\textbf{68.2}\%} }\\
		
		\multicolumn{2}{c|}{}&\multicolumn{2}{c|}{, } & \\ \hline
			
		& \multirow{3}{*}{\tabincell{c}{{Node}\\{Number}} } & \multicolumn{2}{c|}{} & 68.1\% \\
		& & \multicolumn{2}{c|}{} & 67.8\%\\
		& & \multicolumn{2}{c|}{} & 67.6\%\\ \cline{2-5}	
		
		\multirow{3}{*}{\tabincell{c}{{Graph}\\{Reasoning}}} 
		& \multirow{3}{*}{\tabincell{c}{{Message}\\{Passing}} } & \multicolumn{2}{c|}{} & 67.8\% \\
		& & \multicolumn{2}{c|}{} & 68.0\%\\
		& & \multicolumn{2}{c|}{} & 68.0\%\\ \cline{2-5}
		
		
		& \multirow{5}{*}{\tabincell{c}{{Graph}\\{Dropout}}}  & \multirow{2}{*}{\tabincell{c}{} } &
		 & 68.0\% \\
& & &  & 67.7\%\\  \cline{3-5}
		
		& &  & \multirow{2}{*}{\tabincell{c}{} } & 66.8\% \\
& &  &  & 63.6\%\\ \cline{3-5}
		
		& & \multicolumn{2}{c|}{\textit{w/o} dropout} & 67.7\% \\ \hline
		
		\multicolumn{2}{c|}{\multirow{3}{*}{\tabincell{c}{Self-Ensembling}}} & \multicolumn{2}{c|}{intermediate output} & 64.1\%\\ 
		\multicolumn{2}{c|}{}&\multicolumn{2}{c|}{graph output} & 67.8\% \\
		\multicolumn{2}{c|}{}&\multicolumn{2}{c|}{self-ensembling} & 68.2\% \\
		
		\hline
	\end{tabular}
	\label{table:2}
\end{table}

\begin{figure*}[!t]
	\centering
	\includegraphics[width=0.99\textwidth]{./figures/fig3.pdf}
	\caption{\small\textbf{Qualitative results} on PASCAL VOC 2012 \textit{val}. From top to bottom: input images, ground-truths, and our segmentation results.}
	\label{figure:3}
\end{figure*}

\begin{figure}[!t]
	\centering
	\includegraphics[width=0.47\textwidth]{./figures/fig4.pdf}
	\caption{\small\textbf{Visual comparisons of CAMs} generated \textit{w/} or \textit{w/o} the graph dropout layer.}
	\label{fig:4}
\end{figure}

\begin{figure}[!t]
	\centering
	\includegraphics[width=0.47\textwidth]{./figures/fig5.pdf}
	
	\caption{\small \textbf{Visual comparisons of CAMs}. Here we provide the results of two groups of images. For each group, we show the input images, CAMs from the \textit{intermediate readout layer} and CAMs from the \textit{graph readout layer} (from left to right). Our model clearly provides more accurate CAMs after group-wise graph reasoning.}
	
\label{fig:5}
\end{figure}


\subsection{Diagnostic Experiments}
We further conduct diagnostic analysis on PASCAL VOC 2012 \textit{val} set to verify the effectiveness of the essential modules in our approach. We use ResNet101 as the default backbone for all the studies. The performance of our full model with default parameters is given in the first row of~\tabref{table:2}.




\noindent\textbf{Number of Nodes :} We first investigate the effect of the node number  used in the GNN, which indicates the number of images in a group. As shown in~\tabref{table:2}, the model achieves comparably high performance with three or four nodes. However, when more nodes are added, the performance decreases significantly. This can be attributed to the trade-off between meaningful semantic relations and noise brought by group images. When  or , the semantic relations can be fully exploited to improve the integral regions of objects. However, when more images are further considered, meaningful semantic cues reach a bottleneck and noise, introduced by imperfect localization of the classifier, dominates, thus leading to performance degradation.

\noindent\textbf{Number of Message Passing Steps :}
We further evaluate the impact of the message passing steps by comparing the performance with different  ranging from 2 to 5. From~\tabref{table:2}, we observe that the mIoU score is significantly improved when  varies from 2 to 3. The performance decreases slightly when considering more steps. Therefore, we set  as default for message passing.






\noindent\textbf{Graph Dropout Layer:}
To verify the effectiveness of the proposed graph dropout layer, we design multiple experiments to search the optimal configuration of parameters \textit{drop-rate} and \textit{drop-th}. We observe that both parameters have great influences on the performance. As observed in~\tabref{table:2}, our model reaches the best performance at  and . If  is higher (\eg, 0.9), most discriminative regions will be kept, and thus ignored regions will remain unactivated. In contrast, if the  is lower, the regions with high responses  will be excessively dropped, leading to degraded classification accuracy. 

In addition, the parameter  controls whether to drop the responses or not during training. As shown in~\tabref{table:2}, a  of  helps to achieve the best mIoU score. Such a setting not only maintains the classification ability of the network by keeping discriminative regions with a high probability, but also drives the network to mildly attend to other regions. We can also see that by setting  to smaller values (\eg,  or ), the performance encounters a significant decrease.

Moreover, we examine the performance of our model without the graph dropout layer. As seen, without the dropout layer, the performance of our model decreases by  in terms of mIoU, which reveals its importance.


Finally, we illustrate some examples of the final CAMs generated \textit{with} or \textit{without} the graph dropout layer. As shown in~\figref{fig:4}, without the dropout layer, the network only focuses on the most discriminative parts (\eg, heads of the cat and the horse). This is improved with our dropout layer, which helps to highlight non-discriminative object regions.


\noindent\textbf{Self-Ensembling:}
In addition to the supervision on the final outputs, we also introduce deep supervision signals on the intermediate features. Such multi-level supervision has proven effective for improving the performance of various vision tasks. Besides, this enables us to combine the multiple outputs with low cost to further boost the performance. Here, we examine the self-ensembling strategy by building three network variants, \ie, \textit{intermediate output}, \textit{graph output} and \textit{self-ensembling}, in which the final CAMs are separately extracted from the intermediate readout layer, graph-aware readout layer, and their ensemble, respectively. As shown in~\tabref{table:2}, the \textit{intermediate output} only obtains an mIoU score of , greatly lagging behind the  obtained by the \textit{graph output}. This demonstrates that through iterative graph reasoning, our model can improve the image representations by integrating information from group images, leading to huge performance gains. Furthermore, the self-ensembling strategy boosts the performance to .


In~\figref{fig:5}, we illustrate two groups of images with their CAMs from the \textit{intermediate readout layer} and \textit{graph readout layer}. As seen, in both groups, the CAMs are well-refined to cover more complete foreground regions after graph reasoning. Besides, in many cases, the CAMs from two output layers complement with each other well, enabling better results to be obtained by self-ensembling.


\section{Conclusion}

In this paper, we have introduced a group-wise learning framework for weakly supervised semantic segmentation (WSSS). We formulate the task within a graph neural network (GNN), which operates on a group of images and explores their semantic relations for representation learning. By iterative graph reasoning, our model provides better pseudo ground-truths, which further lead to significant performance improvement for the semantic segmentation results. We also devise a graph dropout layer to facilitate the discovery of complete object regions.
We conduct extensive experiments on PASCAL VOC 2012 and COCO benchmarks, and the results demonstrate that the proposed approach performs favorably against the state-of-the-art methods.





\bibliographystyle{aaai}
\small\bibliography{ref}

\end{document}
