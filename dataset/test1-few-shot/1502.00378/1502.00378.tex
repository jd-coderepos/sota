\documentclass{article}

\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{verbatim}
\usepackage{float}
\usepackage{scrextend}
\usepackage{xspace}
\usepackage{fullpage}

\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{specification}{Specification}
\newcommand{\qed}{\hfill  \bigbreak}
\newenvironment{proof}{{\bf Proof. } }{{\hfill }}
\deffootnote[1em]{1em}{0em}{\textsuperscript{\thefootnotemark}\,}
\floatstyle{ruled}
\newfloat{algorithm}{thp}{lop}
\floatname{algorithm}{Algorithm}

\newcommand{\ie}{{\em i.e.,}\xspace}
\newcommand{\eg}{{\em e.g.,}\xspace}

\newcommand{\fixme}[1]{\fbox{\textsl{{\bf #1}}}}
\newcommand{\FIXME}[1]{\fixme{#1} \marginpar[\null\hspace{2cm} FIXME]{FIXME}}

\begin{document}

\title{
Enabling Minimal Dominating Set in\\Highly Dynamic Distributed Systems
}

\renewcommand*{\thefootnote}{\fnsymbol{footnote}}

\author{
Swan Dubois\footnotemark[1]
\and
Mohamed-Hamza Kaaouachi\footnotemark[1]
\and
Franck Petit\footnotemark[1]
}

\footnotetext[1]{Sorbonne Universit\'es, UPMC Universit\'e Paris 6, F-75005, Paris, France\\
CNRS, UMR 7606, LIP6, F-75005, Paris, France\\
Inria, \'Equipe-projet REGAL, F-75005, Paris, France\\
E-mail: {\tt firstname.lastname@lip6.fr}}

\renewcommand*{\thefootnote}{\arabic{footnote}}
\setcounter{footnote}{0}

\date{}

\maketitle

\begin{abstract}
We address the problem of computing a Minimal Dominating Set in highly dynamic distributed systems. We assume weak connectivity, \ie the network may be disconnected at each time instant and topological changes are unpredictable. We make only weak assumptions on the communication: every process is infinitely often able to communicate with other processes (not necessarily directly). 

Our contribution is threefold. First, we propose a new definition of minimal dominating set suitable for the context of time-varying graphs that seems more relevant than existing ones. Next, we provide a necessary and sufficient topological condition for the existence of a deterministic algorithm for minimal dominating set construction in our settings. Finally, we propose a new measure of time complexity in time-varying graph in order to  to allow fair comparison between algorithms. Indeed, this measure takes account of communication delays attributable to dynamicity of the graph and not to the algorithms. 
\end{abstract}

\section{Introduction} 

The availability of wireless communications has drastically increased in recent years and established new applications. Humans, agents, devices, robots, and applications interact together through more and more heterogeneous infrastructures, such as mobile \emph{ad hoc} networks (MANET), vehicular networks (VANET), (mobile) sensor and actuator networks (SAN), body area networks (BAN), as well as always evolving network infrastructures on the Internet. In such networks, items (users, links, equipments, {\em etc.}) may join, leave, or move inside the network at unforeseeable times. A common feature of these networks is their {\em high dynamic}, meaning that their topology keeps continuously changing over time. Dynamic, heterogeneity of devices, usages, and participants, and often the unprecedented scale to consider, make the design of such infrastructures extremely challenging. For a vast majority of them, the dynamics are also unpredictable. Classically, distributed systems are modeled by a static undirected connected graph where vertices are processes (nodes, servers, processors, etc.) and edges represent bidirectional communication links.  Clearly, such modeling is not suitable for high dynamic networks.

Numerous models taking in account topological changes over time have have been proposed since several decades, \eg \cite{AKMUV12,AE84,CCF09,F03,F04,FGM07,SW09}. Some works aim at unifying most of the above approaches. For instance, in~\cite{XFJ03}, the authors introduced the {\em evolving graphs}. They proposed modeling the time as a sequence of discrete time instants and the system dynamic by a sequence of static graphs, one for each time instant. More recently, another graph formalism, called {\em Time-Varying Graphs} (TVG), has been provided in~\cite{CFQS12}. In contrast with evolving graphs, TVGs allow systems evolving within continuous time. Also in~\cite{CFQS12} and in companion papers~\cite{CFMS10,CFMS12}, TVGs are gathered and ordered into classes depending mainly on two main features: the quality of connectivity among the participating nodes and the possibility/impossibility to perform tasks.

In this paper, we focus on the {\em Minimal Dominating Set} (MDS) problem. A dominating set is a subset of vertices of a graph such as each vertex of this graph is either in the dominating set or neighbor of a vertex in the dominating set. A \emph{minimal} dominating set is such that none of its proper subsets is also a dominating set of the graph. Like many distributed covering structure (such as trees, coloring, matching, \emph{etc.}), Minimal Dominating Set is a key building block for numerous network protocols, \eg hierarchical routing and clustering, unicast, multicast, topology control, media access coordination, to name only a few.

Minimal Dominating Set and some of related problems (such as Maximal Independent Set and Connected Dominating Set) receive some attention in the context of dynamic networks, \eg \cite{BDTC05,WDCG12,SW10,CMM11}. The difficulty to define covering structures in dynamic networks (including MDS) is pointed out in~\cite{CF13r}. Indeed, the authors show that the definition of such structures may become ambiguous, incorrect, or even irrelevant when applied in dynamic systems. As an example, if the dynamicity of the graph is modeled as a sequence of static graphs and a new MDS is computed at each topological change as in \cite{WDCG12}, the stability of the MDS fully depends on the dynamic rate of the network (\ie the relative speed of appearance/disappearance of edges). This natural definition may hence lead to an high instability (or even impossibility of use) of the MDS. We discuss more precisely this issue in Section~\ref{sec:MDS}.

This paper aims at proposing a new approach suitable for Minimal Dominating Set construction in time-varying graph with weak connectivity, \ie the graph may be disconnected at each time instant and topological changes are unpredictable. The only assumption on communications is that every process is infinitely often able to communicate with other processes (not necessarily directly). In this context, our contribution is threefold. First, we propose a new definition of MDS for time-varying graphs that increases stability of this structure. More precisely, we require that each dominated node is infinitely often neighbor of at least one dominating node. Next, we provide a necessary and sufficient topological condition for the existence of a deterministic algorithm for MDS construction in our settings. Finally, we propose a new measure of time complexity in time-varying graph. This measure takes account of communication delays attributable to the dynamicity of the graph and not to the algorithm in order to allow fair comparison between algorithms.

The paper is organized as follows. Section \ref{sec:TVG} presents formally the time-varying graph model and our new measure of time complexity. We devote the Section \ref{sec:UG} to some preliminaries necessary to our main results on MDS presented in Section \ref{sec:MDS}. Finally, Section \ref{sec:conclu} concludes the paper.

\section{Time-Varying Graph: Model and Complexity}\label{sec:TVG}

This section aims to present formally the framework of our study of dynamic systems. In a first time, we recall in Section \ref{sub:model} the model of time-varying graphs (TVGs) introduced by \cite{CFQS12}. We present only definitions needed for the comprehension of our work and we refer the reader to \cite{CFQS12} for more details and an interesting taxonomy of TVGs. 

Then, Section \ref{sub:complexity} focuses in complexity measures in this model. We think that a computational model without correct time complexity measure(s) is not complete. We are unable to find in previous works any such measure that is suitable for all TVGs. In consequence, we propose in this paper a new time complexity measure that captures the cost of the algorithm independently of delays introduced by topology changes and asynchronous communications.

\subsection{Model}\label{sub:model}

Let us first borrow the formalism introduced in~\cite{CFQS12} in order to describe the distributed systems prone to high dynamic. We consider {\em distributed systems} made of  computing entities, henceforth indifferently referred to as {\em nodes}, {\em vertices}, or {\em processes}.  A process has a local memory, a local sequential and deterministic algorithm, and input\slash output capabilities. We assume that each entity has a unique identifier. Moreover, given two distinct entities  and  identified respectively by  and , either  or . All these entities are gathered in a set .  Let  be a set of edges (or relations) between pairwise entities, that describes interactions between processes, namely communication exchange. The presence of an edge between two vertices  and  at a given time  means that each vertex among  is able to send a message to the other at .

The interactions between processes are assumed to take place over a time span  called the {\em lifetime} of the system. The temporal domain  is generally assumed to be either  (discrete-time systems) or  (continuous-time systems).

\begin{definition}[Time-varying graph \cite{CFQS12}]
\label{def:TVG}
A time-varying graph (TVG for short)  is a tuple   where  is a (static) set of vertices ,  a (static) set of edges between these vertices ,  (called presence function) that indicates whether a given edge is available (\emph{i.e.} present) at a given time,  (called edge latency function) indicates the time it takes to cross a given edge if starting at a given date, and  (called process latency function) indicates the time an internal action of a process takes at a given date.
\end{definition}

Given a TVG , let  be the subset of  for which a topological event (appearance/disappearance of an edge) occurs in . The evolution of  during its lifetime  can be described as the sequence of graphs , where  corresponds to the static {\em snapshot} of  at time , \emph{i.e.}  if and only if . Note that, by definition,  for any . 

We consider {\em asynchronous} distributed systems, \emph{i.e.} no pair of processes has access to any kind of shared device that could allow to synchronize their execution rate.  Furthermore, at any time, no process has access to the output of , \emph{i.e.} none of them can ({\em a priori}) predict a bound on the message delay. Note that the ability to send a message to another process at a given time does not mean that this message will be delivered. Indeed, the dynamicity of the communication graph implies that the edge between the two processes may disappear before the delivery of this message leading to the lost of messages in transit. 

The presences and absences of an edge are instantly detected by its two adjacent nodes. We assume that our system provides to each process a non-blocking communication primitive named \textbf{Send\_retry} that ensures the following property. When a process  invokes \textbf{Send\_retry} (where  is an arbitrary message and  another process of ) at time , this primitive delivers  to  in a finite time provided that there exists a time  such that the edge  is present at time  during at least  units of time. In other words, the delivery of the message is ensured if there is, after the invocation of the primitive, an availability of the edge that is sufficient to overcome the communication delay of the edge at this time. Note that this primitive may never deliver a message (\emph{e.g.} if the considered edge never appears after invocation). Details of the implementation of this primitive are not considered here but it typically consists in resending  at each apparition of the edge  until its reception by . This primitive allows us to abstract from topology changes and asynchronous communication and to write high-level algorithms.

\paragraph{Configurations and executions} The \emph{state} of a process is defined by the values of its variables. Given a TGV , a \emph{configuration} of  is a vector of  components  such that  is a static snapshot of  (\emph{i.e.} ),  is the set of multi-sets of messages carried over , and  to  represent the state of the  processes in . We say that a process  outputs a value  in a configuration  if one of its variable (called an output variable) has the value  in .

An {\em execution} of the distributed system modeled by  is a sequence of configurations  , such that for each , during an execution step , one of the following event occurs:  , or  at least one process receives a message, sends a message, or executes some internal actions changing its state. The \emph{algorithm} executed by  describes the set of all allowed internal actions of processes (in function of their current state or external events as message receptions or time-out expirations) during an execution of . We assume that during any configuration step  of an execution, if  , then for each edge  such that   and  (\emph{i.e.}  disappears during the step ), none of the messages carried by  belongs to . Also, for each edge  such that   and  (\emph{i.e.}  appears during the step ),  contains no message in configuration . 

\paragraph{Connected over time TVGs} A key concept of time-varying graphs has been identified in~\cite{CFQS12}. The authors shows that the classical notion of path in static graphs in meaningless in TVGs. Indeed, some processes may communicate even if there is no (static) path between them at each time. To perform communication between two processes, the existence of a \emph{temporal path} (\emph{a.k.a.} \emph{journey}) between them is sufficient.  They define such a temporal path as follows: a sequence of ordered pairs  such that   is a path\footnote{A sequence of edges  is a \emph{path} if  .} if for every ,  and . In other words, a journey from process  to process  is a sequence of adjacent edges from  to  such that availability and latency of edges allow the sending of a message from  to  using the \textbf{Send\_retry} primitive at each intermediate process (refer to \cite{CFQS12} for a formal definition). Note that a journey is a non symmetric relation between two processes.

Based on various assumptions made about journeys (\emph{e.g.} recurrence, periodicity, symmetry, and so on), the authors propose in~\cite{CFQS12} proposes a relevant hierarchy of TVG classes. In this paper, we choose to make minimal assumptions on the dynamicity of our system since we restrict ourselves on \emph{connected-over-time} TVGs defined as follows: 

\begin{definition}[Connected-over-time TVG \cite{CFQS12}]\label{def:COT}
A TVG  is connected-over-time if, for any time  and for any pair of processes  and  of , there exists a journey from  to  after time . The class of connected-over-time TVGs is denoted by \footnote{Authors of \cite{CFQS12} refer to this class as C5 in their hierarchy of TVG classes.}.
\end{definition}

Note that the lifetime of a connected-over-time TVG is necessarily infinite by definition. The class 
allows us to capture highly dynamic systems since we only require that any process will be always able to communicate
with any other one without any extra assumption on this communication (such as delay, periodicity, or used route). In particular, note that a connected-over-time TVG may be disconnected at each time and that the presence of an edge at a given time does not preclude that this edge will appear again after this time.  Define an \emph{eventual missing edge} as en edge that appears only a finite number of time during the lifetime of the TVG. The main difficulty encountered in the design of distributed algorithms in  is to deal with such eventual missing edges because no process is able to predict if a given adjacent edge is an eventual missing edge or not. Note that the time of the last presence of such an eventual missing edge cannot be even bounded.

\begin{definition}[(Eventual) Underlying Graph]\label{def:UG}
Given a TVG , the underlying graph of a  is the (static) graph . The eventual underlying graph of  is the (static) subgraph  with , where  is the set of eventual missing edges of . 
\end{definition}

Intuitively, the underlying graph (sometimes referred to as {\em footprint}) of a TVG  gathers all edges that appear at least once during the lifetime of , whereas the eventual underlying graph of  gathers all edges that are infinitely often present during the lifetime of . Note that, for any TVG of , both underlying graph and eventual underlying graph are connected by definition. Let us define the \emph{neighborhood}  of a process  is the set of processes with which  shares an edge in the underlying graph.

\paragraph{Induced subclasses}

In the following, we focus on specific subclasses of the class  to establish our impossibility result. Informally, we focus on subclasses that gather all TVGs whose underlying graph belongs to a given set. The intuition behind this restriction is the following. In practice, some technical reasons may restrict or prevent the communication between some processes, that induces a given underlying graph for the TVG that models our system. In contrast, we cannot predict in general the availabilities and latencies of communication edges, that leads us to consider all TVGs sharing this underlying graph. More formally:

\begin{definition}[Induced subclass]\label{def:inducedsubclass}
Given a set of (static) graphs  and a class of TVGs , the subclass of  induced by  (denoted by ) is the set of all TVGs of  whose underlying graph belongs to .
\end{definition}

\paragraph{Diameter}

For any given (static) graph , we denote by  the diameter of  (that is, the longest distance between two processes of ).

\subsection{Complexity Measures}\label{sub:complexity}

At the best of our knowledge, there exists currently no time complexity measure that is suitable for any class of TVGs. Some previous works interested in complexity measure in the TVG model but restrict themselves to synchronous systems (see \emph{e.g.} \cite{KOM11c,KLO10c}), to message complexity (see \emph{e.g.} \cite{CFMS10c}), or to specific class of TVGs in which an existing notion of complexity naturally makes sense (see \emph{e.g.} \cite{IKW14c,CFMS10c}).

The first contribution of this paper is to propose a definition of a time complexity measure suitable for our model. We need a definition that captures the ``quality'' of an algorithm independently of delays introduced by asynchronous communications but also by topological changes. A typical example of such a delay is the waiting after the next apparition of an incident edge to a disconnected process that may introduce a long delay that is not imputable to the algorithm but only to the dynamicity of the system. To perform our goal, we propose to extend the classical notion of time complexity commonly adopted in asynchronous message passing (static) systems.

The classical way to deal with communication delays in time complexity measure in asynchronous message passing models is to consider as the unit of time of an execution the worst delay between the sending and the reception of a message during this execution (see \cite{AW04} for example). Using this time measure, we can bound the termination time of any execution of an algorithm independently of communication delays in this execution. This leads to a time complexity measure (the worst termination time over all possible executions of the algorithm) that induces a fair comparison between algorithms. Our proposal is to extend this idea to dynamic environments by including delays introduced by the dynamicity in this definition. In other words, we will consider as the unit of time of an execution the worst delay between the invocation of the \textbf{Send\_retry} primitive and the delivery of the message by this primitive during this execution.

This natural extension of the definition of time complexity measure of asynchronous message passing systems is not sufficient. Indeed, the dynamicity of the system may introduce another possibly arbitrarily long delay that we call initial delay. As an example, consider a problem that requires each process to propagate an initial value (think about consensus-like problems). An easy way to delay the termination of any algorithm for this problem is to disconnect one process for an arbitrary long (but bounded) time that leads all other processes to wait after its first apparition. Intuitively, this delay is not due to the algorithm but to the dynamicity of the system. Consequently, our complexity measure have to ignore such initial delay.

To deal with this issue, we propose to define for each problem a starting time as follows. It is the smallest time of an execution where the dynamicity of the system ``shows'' to processes the minimal topological information to solve the problem. Note that this starting time depends only of the problem (\emph{e.g.} first connexion of the last process for consensus-like problems) and that, in a static system, the starting time and the initial time are identical (since the system cannot delay apparition of any topological information).

Then, we propose to measure the complexity of an algorithm by the worst time (expressed in the time unit described above) between the starting time and the termination of the algorithm over all its possible executions. We believe that this time complexity measure allows us to fairly compare algorithms designed in our model based on TVGs since it exhibits their intrinsic communication costs and does not take in account delays introducing by asynchronous communications and topological changes.

We now state our complexity measure more formally. In the following, we first restrict to \emph{fixed point computation problems} on a TVG class , \emph{i.e.} problems that admit a specification of the following form: it is required that the execution on every TVG of  reaches in a finite time a suffix where each process outputs constantly a given value. The required value depends of the considered problem and is not necessarily the same at each process. Using this definition, leader election or spanning structure construction are fixed point computation problems whereas mutual exclusion or broadcast are not.  

We consider now a (deterministic) distributed algorithm  that satisfies the specification of a fixed point computation problem  on a TVG class . Let  be the execution of  on a given TVG of class . For any message  sent during , we call \emph{delay} (of ) the time between the invocation of the \textbf{Send\_retry} primitive by the sender of  and the delivery of  to its destination. Now, we call \emph{communication step} (or simply step) of  the worst delay over the set of messages that are actually delivered during  (note that we do not consider messages that are never delivered in ).

We associate to  a function , called the \emph{necessary presence sets function} of , that returns, for any TVG  of , a set of subsets of . Note that the actual definition of this function depends of the problem itself and not of a TVG nor an execution. Each element of  describes one of the set of edges whose apparition is necessary and sufficient to start the effective solving the problem (independently of the used algorithm). We give some examples in the following. For the underlying graph computation problem , we have  since each edge of  must appear in the output of any process. For a broadcast problem , we have  (where process  is the sender of the message) since the apparition of any edge adjacent to  is necessary and sufficient to begin the broadcast of a message by .

We define the \emph{starting time} of the execution  of  over a TVG  as the smallest time  such that each edges of at least one element of  are present at least once before  in this execution. Note that, in a static distributed system, the initial time and the starting time are always identical since all edges of all elements of  are present in the initial configuration whatever the definition of  is. Finally, the \emph{convergence time} of  on  is the time (expressed in communication steps of ) between the starting time of  and the smallest time in  where the specification of  is satisfied.

\begin{definition}[Time complexity on a TVG class]
The time complexity of a distributed algorithm  that satisfies the specification of a fixed point computation problem  on a TVG class  is the worst convergence time of  on all TVGs of .
\end{definition}

Note that this definition may be naturally extended to so-called \emph{service problems} in the following way. First, we consider as starting time the maximum between the starting time defined above and the time of request of a service (\emph{e.g.} the sending of a message for a broadcast algorithm, the request of critical section for a mutual exclusion algorithm). Second, we substitute the convergence time of the algorithm by the time of achievement of the required service by the algorithm (\emph{e.g.} the delivery of a message to its destinations for a broadcast algorithm, the starting of critical section for a mutual exclusion algorithm).

\section{Underlying Graph Computation}\label{sec:UG}

In this section, we present an underlying graph computation algorithm (see Section \ref{sub:UGalgo}) and proves its time optimality with respect to our new measure (see Section \ref{sub:UGcomplexity}). This algorithm is used as a building block in the next section for our minimal dominating set construction algorithm. Before presenting our algorithm, we need to specify the underlying graph computation problem.

\begin{specification}[Underlying graph]
An algorithm  satisfies the underlying graph specification for a class of TVGs  if the execution  of  on every TVG  of  has a suffix  for a given  such that each process outputs the underlying graph of  in any configuration of .
\end{specification}

\subsection{Algorithm}\label{sub:UGalgo}

Our underlying graph computation algorithm is presented in Algorithm \ref{algo:ug}. The intuition behind this algorithm is simple. Each process stores locally a graph, initially empty, that eventually gathers all edges of the underlying graph. At the first appearance of an edge, the two adjacent processes add this edge to their graph. Then, they try to propagate the last version of their graph to all processes that they have as neighbor at least once since the beginning of the execution. When a process receives such a message (that contains the current underlying graph of another process), it add to its own underlying graph every edge it does not already know. If its underlying graph grows during this operation, then the process propagates again its underlying graph to all processes that it has as neighbor at least once since the beginning of the execution.

\begin{algorithm}\caption{Underlying graph computation for process .}\label{algo:ug}
\begin{description}
\item[Variables:]~\\
: underlying graph built by \\
: neighborhood of 
\item[Initialization:]~\\
\\

\item[Upon appearance of an edge :]~
\begin{tabbing}
xxx \= xxx \= \kill 
\textbf{if}  \textbf{then}\\
\> \\
\> \\
\> \textbf{foreach}  \textbf{do}\\
\>\> \textbf{Send\_retry}
\end{tabbing}
\item[On reception of  from :]~
\begin{tabbing}
xxx \= xxx \= \kill 
\textbf{if}  \textbf{then}\\
\> \\
\> \textbf{foreach}  \textbf{do}\\
\>\> \textbf{Send\_retry}
\end{tabbing}
\end{description}
\end{algorithm}

This algorithm ensures that, upon the first apparition of the last edge of the underlying graph, this edge is added to the output of adjacent processes and then propagated (at least) to their neighbors in the eventual underlying graph in one step, and so on (note that we have no guarantees for neighbors in the underlying graph in general since it may exist some eventual missing edges). Hence, in any execution, after at most  steps, this edge (and all others) appears in the output graph of any process. In other words, we have the following result:

\begin{theorem}
Algorithm \ref{algo:ug} satisfies the underlying graph specification for . Moreover, its convergence time on any TVG  of  is  steps.
\end{theorem}

\subsection{Time Optimality}\label{sub:UGcomplexity}

In this section, we interest in a lower bound result on the time complexity of underlying graph computation. We restrict ourselves to greedy algorithms that are the most natural ones for this problem. We define a {\em greedy algorithm} for the underlying graph computation as an algorithm that satisfies the following property. The initial output of any process is an empty graph and the graph outputted by a process can only grow (in the sense of inclusion) over time. In other words, such an algorithm ensures that, once a process start to output a given edge or process, this latter always appears in the output of this process afterwards. Note that Algorithm~\ref{algo:ug} falls in this category.

In the following, we prove that no greedy algorithm for underlying graph computation on  can exhibit a better time complexity than our algorithm. Indeed, we prove that there exists, for any greedy algorithm, a TVG  in  such that this algorithm needs  steps to compute the underlying graph of . Note that the complexity of the underlying graph computation depends surprisingly of a parameter of the \emph{eventual} underlying graph. 

We need a technical lemma for the proof of this optimality result.

\begin{lemma}\label{lem:optimality}
For any greedy algorithm  that satisfies the underlying computation graph, for any TVG  in , for any edge  that is not a cut-edge of , for any process , for any ,  cannot belong to the graph outputted by  in the execution of  on  at time  if there exists no temporal path from one extremity of  to  that starts after the first appearance of  in  and ends before .
\end{lemma}

\begin{proof}
By contradiction, assume that there exists a greedy algorithm  that satisfies the underlying computation graph, a TVG  in , an edge  that is not a cut-edge of , a process , and a time  such that  appears in the graph outputted by  in the execution of  on  at time  and that there exists no temporal path from one extremity of  to  that starts after the first appearance of  in  and ends before .

Then, consider the TVG  with:


Note that, according to the assumption that  is not a cut-edge of ,  belongs to . Hence, due to the construction of  and the determinism of , the process  receives exactly the same messages before time  in  and  (the assumption on temporal paths after the first appearance of  in  ensures us that the fact to remove  in  is not detectable by  before time ). In other words,  cannot distinguish the executions of  on  and  before . As a consequence,  appears in the graph outputted by  in the execution of  on  at time . As  is a greedy algorithm, this edge never disappear of the output of  in the execution of  on  after time . This is contradictory with the fact that  satisfies the underlying graph specification on  since  does not belongs to  and proves the lemma.
\end{proof}

We are now ready to prove the following result.

\begin{theorem}\label{th:optimality}
For any greedy algorithm  that satisfies the underlying graph specification on , there exists a TVG  of  such that the convergence time of  is at least  steps.
\end{theorem}

\begin{proof}
Let  be a greedy algorithm that satisfies the underlying graph specification on . Then, let us define the following family of TVGs. For any given , let  be the TVG defined by , , and




\begin{figure}
  \centering 
  \includegraphics[scale=0.4]{optimality.pdf}
  \caption{An illustration of the TVGs family in the proof of Theorem \ref{th:optimality}. \label{fig:optimality}}
\end{figure}

Refer to Figure \ref{fig:optimality} for an example of such a . Note that, for any , we have  (and  since ). As this graph is connected,  belongs to . By construction of , the starting time of the execution of  on  is  for any  (recall that ). Note that, due to the choice of the latency function, any communication step of the execution of  on  takes exactly one time unit.

Consider  the execution of  on  for any . From Lemma \ref{lem:optimality}, we know that the edge  cannot appear in the graph outputted by  in  before there exists at least one temporal path from  or  to . Note that the construction of  implies that such a temporal path (after time ) needs at least  steps (the length of the path from  or  to  since  is static after time ). As the edge  must eventually appear in the output of any process in  by assumption on , we obtain that the convergence time of  is at least  steps, that ends the proof.
\end{proof}

\section{Minimal Dominating Set Construction}\label{sec:MDS}

Minimal dominating set construction is a classical problem in the context of distributed computing since this spanning structure have interesting properties for a lot of practical problems as clustering. Recall that, in a static distributed system, a dominating set  is a subset of processes of the system such that each process that does not belong to  have at least one neighbor in . Such a dominating set is minimal when it has is no strict subset that is also a dominating set.

Regarding dynamic distributed systems, two different approaches have been proposed to handle minimal dominating set problem. We survey them quickly here and show that these definitions seem not relevant in our context, that motivates the need of our new definition presented in this section.

The most natural way to extend minimal dominating set definition in the context of dynamic systems is presented in \cite{WDCG12}. In this work, the dynamic graph is seen as a sequence of static graphs and a new minimal dominating set is computed at each topological change. This approach is not suitable in the case of highly dynamic systems since the system may be always in computation phase (the computation of the new dominating set at each topological change is not instantaneous). In this case, the dominating set may be never stable and is then useless for the application that required it.

The second approach, proposed by \cite{CF13r}, consists in computing a stable dominating set on the underlying graph of the TVG. This approach is interesting since the outputted dominating set is stable in spite of the dynamicity of the system but is still not suitable for our purpose. Indeed, as the dominating set is computed on the underlying graph that may contain eventual missing edges, it is possible for a process to be dominated only through such edges. In other words, a dominated process may have eventually only dominated neighbors, that is counter-intuitive for a minimal dominating set and makes sense only in TVGs where there is no eventual missing edges.

To overcome flaws of precedent definitions in our context of highly dynamic distributed systems (captured by the class of TVGs ), we propose a third definition. In this definition,  we require the outputted minimal dominating set to be stable and each dominated process to be infinitely often neighbor of at least one dominating process. In other words, we want to compute a minimal dominating set on the \emph{eventual} underlying graph. Note that this definition is exactly the same as the one of \cite{CF13r} in TVGs where there is no eventual missing edges. 

\begin{definition}[Minimal dominating set over time] 
A set of processes  is a minimal dominating set over time (MDST for short) of a TVG  if  is a minimal dominating set of .
\end{definition}

We now specify the minimal dominating set construction problem over TVGs as follows.

\begin{specification}[Minimal dominating set]
An algorithm  satisfies the minimal dominating set specification for a class of TVGs  if the execution  of  on every TVG  of  has a suffix  for a given  such that each process outputs constantly a boolean value in any configuration of  and that the set of processes outputting true is a minimal dominating set overt time of .
\end{specification}

\subsection{Preliminaries}\label{sub:MDSprelem}

In this section, we present some preliminary results that are needed in the following. First, we introduce the definition of a strong minimal dominating set of a graph as a dominated set of any connected spanning subgraph of this graph. In Section \ref{sub:MDSimp}, we prove that the existence of such a set in the underlying graph of a TVG is necessary to the existence of an algorithm to construct a minimal dominating set over time of this TVG. We claim in Section \ref{sub:MDSalgo} that this condition is also sufficient. To prove this result, we use a characterization of graphs that admit a strong minimal dominating set that we present in the end of this preliminary section.
 
\begin{definition}[Strong minimal dominating set] 
A strong minimal dominating set (SMDS for short) of a (static) graph  is a subset of processes of  that is a minimal dominating set of every connected spanning subgraph of .
\end{definition}

The following lemma follows directly from definitions and legitimates our interest for strong minimal dominating sets.

\begin{lemma}\label{lem:smdsismdst}
If the underlying graph of a TVG  admits a strong minimal dominating set  then  is a minimal dominating set over time of .
\end{lemma}

The next result provides us a characterization of (static) graphs that admits a SMDS. We use this characterization in our minimal dominating set construction algorithm in the next section.

\begin{lemma}\label{lem:characterization}
For any (static) graph  and any minimal dominating set  of ,  is a strong minimal dominating set of  if and only if the set of edges  is a cut-set in  for every process .
\end{lemma}

\begin{proof}
First, we prove that, for any SMDS  of a graph , the set of edges  is a cut-set in  for every process . By contradiction, assume that there exists a SMDS  of a graph  such that the set of edges  is not a cut-set in  for a process . Let  the subgraph of  defined by . By assumption,  is a connected graph. Moreover, in  the process  has no neighbor in , that means that  is not a minimal dominating set of . This contradicts the fact that  is a SMDS of  and proves the necessity of the condition.

Second, we prove that any minimal dominating set  of a graph  such that the set of edges  is a cut-set in  for every process  is a SMDS of . By contradiction again, assume that there exists a minimal dominating set  of a graph  such that the set of edges  is a cut-set in  for every process  is not a SMDS of . By definition of a SMDS, there exists a connected subgraph  of  such that  is not a minimal dominating set of . Let us study the two following cases.

\begin{enumerate}
\item  is not a dominating set of . Then, there exists a process  such that no neighbors of  in  belongs to . As  is connected, that means that the set  is not a cut-set in , that is contradictory with the initial assumption on .
\item  is a dominating set of  but is not minimal. We say that a process of a dominating set properly dominates one of its neighbor if it is the only dominating process in the neighborhood of this dominated process. Then, we know that there exists, in , two neighbors  and  such that  does not dominate properly any of its neighbors. As  is a minimal dominating set in , we deduce that  dominates properly at least one of its neighbors  (recall that  and  are neighbors in  by construction). That means that the set of edges  is not a cut-set of  (since this edge does not belong to  that is connected). This is contradictory with the initial assumption on .
\end{enumerate}

These contradictions show us the sufficiency of the condition and ends the proof.
\end{proof}

\subsection{Impossibility Result}\label{sub:MDSimp}

\begin{figure*}[htb]
  \centering 
  \includegraphics[scale=0.4]{mds_w.pdf}
  \caption{An illustration of the sequence  used in the proof of Theorem \ref{th:MDSimp}. \label{fig:impossibility}}
\end{figure*}

The proof of our impossibility result presented in Theorem \ref{th:MDSimp} makes use of a generic framework we proposed in another work. We recall here the minimal definitions and results to understand our proof. Due to the lack of space, the interested reader is referred to \cite{BDKP14r} for more details. 

\paragraph{Summary of \cite{BDKP14r}} For a given time domain , a given static graph  and a given latency function , let us consider the set  of all TVGs over  that admit  as underlying graph and  as latency function. For the sake of clarity, we will omit the subscript  and simply denote this set by . Remark that two distinct TVGs of  can be distinguished only by their presence function. For any TVG  in , let us denote its presence function by . We define now the following metric  over . If , then . Otherwise,  with .

For a given algorithm  and a given TVG , let us define the -output as the function that associate to any time  the state of  at time  when it executes . We say that  is the supporting TVG of this output. Let us consider the set  of all -outputs over all TVGs  of . For the sake of clarity, we will omit the subscript  and simply denote this set by . Remark that two distinct output of  can be distinguished only by their supporting TVG. For any output  in , let us denote its supporting TVG by . We define now the following metric  over . If , then . Otherwise,  with .

Once we have observed that the metric spaces  and  are complete, we are now able to recall the main result of \cite{BDKP14r}. Intuitively, this theorem ensures us that, if we take a sequence of TVGs with ever-growing common prefixes, then the sequence of corresponding outputs also converges. Moreover, we are able to describe the output to which it converges as the output that corresponds to the TVG that shares all commons prefixes of our TVGs sequence. This result is useful since it allows us to construct counter-example in the context of impossibility results. Indeed, it is sufficient to construct a TVG sequence (with ever-growing common prefixes) and to prove that their corresponding outputs violates the specification of the problem for ever-growing time to exhibit an execution that violates infinitely often the specification of the problem. More formally, we have:

\begin{theorem}\label{th:convergence}
For any deterministic algorithm , if a sequence  of  converges to a given , then the sequence  of the -outputs converges to . Moreover,  is the -output.
\end{theorem}

\paragraph{Application to minimal dominating set}

We are now in measure to prove our impossibility result. This result states that there exists no deterministic algorithm that satisfies the minimal dominating set specification on a TVG of  as soon as the underlying graph of the considered TVG does not admit a strong minimal dominating set. Intuitively, this impossibility comes from the following fact. As no process is able to detect eventual missing edges, the minimal dominated set computed by any algorithm must be a minimal dominated set of any possible eventual underlying graph, that is of any connected subgraph of the underlying graph. In other words, the computed minimal dominated set is a strong minimal dominating set. The existence of such a set is then a necessary condition to the existence of an algorithm to compute a minimal dominating set over time. The main difficulty of the formal proof of this result lies in the construction of the TVGs sequence that allows us to apply Theorem \ref{th:convergence}.

\begin{theorem}\label{th:MDSimp}
For any set of (static) graphs  containing at least one graph that does not admit a strong minimal dominating set, there exists no deterministic algorithm that satisfies the minimal dominating set specification for .
\end{theorem}

\begin{proof}
Let us introduce some notation first. We define, for any TVG ,  the TVG  (with  and for any ,  and ) as the TVG  with:


By contradiction, assume that there exists a set of (static) graphs  containing at least one graph that does not admit a strong minimal dominating set and that there exists a deterministic algorithm  that satisfies the minimal dominating set specification for . In consequence, any process that executes  outputs a boolean value at any time.

Let  be a TVG of  such that  does not admit a strong minimal dominating set and that all edges of  are present during the first communication step of the execution of  on  ( exists by construction of  and by definition of ). Let  be the time of completion of the first communication step of the execution of  on . We construct then a sequence  of TVGs as follows. We set . Assume that we have already  for a given  such that , , and . Then, we define inductively  as follows (refer to Figure \ref{fig:impossibility} for an illustration, gray boxes represent portions of executions where  outputs a stable minimal dominating set):

\begin{enumerate}
\item Consider the execution of  over  and let  be the smallest time strictly greater than  from which the set of processes that output true is constant ( exists by assumption on  since );
\item Let  be the minimal dominating set computed by  on  (\emph{i.e.} the set of processes of  outputting true after ). As , we know by assumption on  that  does not admit a SMDS. In particular,  is not a SMDS of . Hence, there exists a process  of  such that the set of edges   is not a cut-set of ; 
\item Let .
\item Remark that  (by construction of  since ) and that  is connected (since  by construction\footnote{where  denotes the set of edges of .} and  is not a cut-set of ). Hence,  and we can consider the execution of  over . Let  be the smallest time strictly greater than  from which the set of processes that output true is constant. Let  be the minimal dominating set computed by  on  (\emph{i.e.} the set of processes of  outputting true after ). Note that  since  is not a minimal dominating set of  (recall that, in ,  has no neighbor in );
\item Let .
\end{enumerate}

It is straightforward to check that this construction ensures that, if there exists  for a given  such that , , and , then  satisfies the same property. Moreover, as , this property is naturally satisfied for  with any . Hence, the sequence  is well-defined. Note that, for any ,  and  (by construction). 

That allows us to define the following TVG: . Note that  and then that  belongs to . Observe that, for any , we have  by construction of  and . Thus,  converges in  to .

We are now in measure to apply the Theorem \ref{th:convergence} that states that the -output is the limit of the sequence of the -outputs. In other words, the -output shares a prefix of length  with the -output for any  (recall that the sequence of the -outputs is Cauchy since it converges). That means that, for any , the set of processes that output true in  at  is  and the set of processes that output true in  at  is . As we know that  for any , we obtain that the set of processes that output true in  never converges, that contradicts the fact that  satisfies the minimal dominating set specification for  and ends the proof.
\end{proof}

\subsection{Algorithm}\label{sub:MDSalgo}

We are now able to prove the sufficiency of the existence of a strong minimal dominating set on the underlying graph for the construction of a minimal dominating set over time of any TVG of . We prove this result simply by presenting an algorithm based on our underlying graph computation algorithm presented in Section \ref{sec:UG}. 

This algorithm works as follows. Once a process has computed the underlying graph, it is easy to decide if this process belongs to the outputted minimal dominating set: the process enumerates (locally and in a deterministic order based \emph{e.g.} on process identities) all minimal dominating sets of the underlying graph and chooses the first one that satisfies Lemma \ref{lem:characterization}. This latter is then a strong minimal dominating set of the underlying graph and hence a minimal dominating set over time of the TVG by Lemma \ref{lem:smdsismdst}. In order to avoid the use of an algorithm of termination detection (for the underlying graph computation), each process repeats the local computation of its output at each update of its local copy of the underlying graph by the algorithm of Section \ref{sec:UG}. The existence of this simple algorithm allows us to state the following result:

\begin{theorem}
For any set of (static) graphs  containing only graphs that admit a strong minimal dominating set, there exists a deterministic algorithm that satisfies the minimal dominating set specification for .
\end{theorem}

\section{Conclusion}\label{sec:conclu}

This paper addressed the construction of a minimal dominating set over time (MDST) in highly dynamic distributed systems. We considered the weakest connectivity assumption in the hierarchy of time-varying graphs: the graph may be disconnected at each time, topological changes are unpredictable but we know that any process is able to communicate with any other infinitely often using so-called temporal paths. In this context, we proposed a new definition of minimal dominating set increasing the stability of the computed MDST. Next, we provided a necessary and sufficient topological condition for the existence of a deterministic MDST algorithm. We then proposed a new measure of time complexity that takes in account the communication delays due to network dynamic.  

The above results used the construction of an underlying graph. We showed the time optimality of our algorithm with respect to our measure. Note that our result (Theorem~\ref{th:optimality}) is valid for greedy algorithms only. We conjecture that all distributed underlying graph algorithms are greedy. This would lead to generalize our result of optimality. Also, we would like to extend our approach to other related overlay constructions. 

\bibliographystyle{plain}
\bibliography{biblioRR}

\end{document}
