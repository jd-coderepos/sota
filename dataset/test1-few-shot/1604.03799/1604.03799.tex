\documentclass[a4paper,reqno]{amsart}
\pdfoutput=1




\usepackage{ifthen}
\usepackage{xargs}

\newcommand{\prd}[1]{\Pi_{#1}\mkern1mu}
\newcommand{\prdsimple}[1]{\Pi_{#1}}

\newcommand{\sm}[1]{\Sigma \left(#1\right).\,}
\newcommand{\smsimple}[1]{\Sigma_{#1}}
\newcommand{\smonlybig}[1]{\Sigma \big(#1\big).\,}

\newcommand{\prdsymbol}{\Pi}
\newcommand{\smsymbol}{\Sigma}

\newcommand{\lam}[1]{\lambda #1 .}

\newcommand{\fa}[2]{\forall (#1 : #2) . \,}
\newcommand{\fasimple}[1]{\forall #1 . \,}
\newcommand{\fapairs}[3]{\fa {#1 \, #2} #3}
\newcommand{\fapairssimple}[2]{\fasimple {#1 \, #2}}
\newcommand{\fatypes}[1]{\fa #1 \type} 

\newcommand{\jdeq}{\equiv}      \newcommand{\defeq}{\vcentcolon\equiv}  

\newcommand{\eqvsym}{\simeq}
\newcommand{\eqv}[2]{\ensuremath{#1 \eqvsym #2}\xspace}
\newcommand{\eqvauto}[1]{\eqv{#1}{#1}}
\newcommand{\iseqown}[1]{\ensuremath{\mathsf{e}_{#1}}\xspace}
\newcommand{\eqvsymspace}{\enspace \eqvsym \enspace}
\newcommand{\eqvspace}[2]{\ensuremath{#1 \eqvsymspace #2}\xspace}
\newcommand{\eqvautospace}[1]{\eqvspace{#1}{#1}}

\newcommand{\idfunc}[1][]{\ensuremath{\mathsf{id}_{#1}}\xspace}

\newcommand{\idsym}{{=}}
\newcommand{\idsymspace}{\enspace \idsym \enspace}
\newcommand{\id}[3][]{\ensuremath{#2 =_{#1} #3}\xspace}
\newcommand{\nid}[3][]{\ensuremath{#2 \not=_{#1} #3}\xspace}
\newcommand{\idspace}[3][]{\ensuremath{#2 \, =_{#1} \, #3}\xspace}
\newcommand{\idtype}[3][]{\ensuremath{\mathsf{Id}_{#1}(#2,#3)}\xspace}
\newcommand{\idtypevar}[1]{\ensuremath{\mathsf{Id}_{#1}}\xspace}
\newcommand{\idauto}[2][]{\id[#1]{#2}{#2}}


\newcommand{\refl}[1]{\ensuremath{\mathsf{refl}_{#1}}\xspace}
\newcommand{\reflp}[2]{\ensuremath{\mathsf{refl}^{#1}_{#2}}\xspace}

\newcommand{\ct}{\mathchoice{\mathbin{\raisebox{0.5ex}{}}}{\mathbin{\raisebox{0.5ex}{}}}{\mathbin{\raisebox{0.25ex}{}}}{\mathbin{\raisebox{0.1ex}{}}}
}

\newcommand{\opp}[1]{\mathord{{#1}^{-1}}}
\let\rev\opp
\let\sym\opp

\newcommand{\trans}[2]{\ensuremath{{#1}_{*}\mathopen{}\left({#2}\right)\mathclose{}}\xspace}
\let\Trans\trans
\newcommand{\transf}[1]{\ensuremath{{#1}_{*}}\xspace} \newcommand{\transfib}[3]{\ensuremath{\mathsf{transport}^{#1}(#2,#3)\xspace}}
\newcommand{\Transfib}[3]{\ensuremath{\mathsf{transport}^{#1}\Big(#2,\, #3\Big)\xspace}}
\newcommand{\transFib}[3]{\ensuremath{\mathsf{transport}^{#1}\left(#2,\, #3\right)\xspace}}
\newcommand{\transfibf}[1]{\ensuremath{\mathsf{transport}^{#1}\xspace}}


\newcommand{\isequiv}{\ensuremath{\mathsf{isequiv}}}
\newcommand{\idequiv}{\ensuremath{\textsf{id-equiv}}}


\newcommand{\UU}{\ensuremath{\mathcal{U}}\xspace}
\newcommand{\VV}{\ensuremath{\mathcal{V}}\xspace}
\newcommand{\UUp}{{\UU_\bullet}}




\newcommand{\UUtt}[2]{\ensuremath{ \UU_{#1}^{#2}}}
\newcommand{\UUt}[1]{\ensuremath{ \UU^{#1}}}
\newcommand{\UUtprime}[1]{\ensuremath{ \UU'^{#1}}}
\newcommand{\VVt}[1]{\ensuremath{ \VV^{#1}}}


\newcommand{\N}{\ensuremath{\mathbb{N}}\xspace}
\let\nat\N
\newcommand{\suc}{\mathsf{succ}}
\newcommand{\add}{\mathsf{add}}

\newcommand{\Nminus}{\ensuremath{\mathbb{N}_{-2}}\xspace}

\newcommand{\emptyt}{\ensuremath{\mathbf{0}}\xspace}

\newcommand{\unit}{\ensuremath{\mathbf{1}}\xspace}
\newcommand{\ttt}{\ensuremath{\star}\xspace}

\newcommand{\bool}{\ensuremath{\mathbf{2}}\xspace}
\newcommand{\btrue}{{1_{\bool}}}
\newcommand{\bfalse}{{0_{\bool}}}

\newcommand{\boolpower}[1]{\bool^{(#1)}}
\newcommand{\imprboolpower}[1]{\underline{\boolpower {#1}}}
\newcommand{\boolpowerpoint}[1]{\btrue^{(#1)}}
\newcommand{\ispointedbool}{\mathsf{is}\bool^\bullet}

\newcommand{\swap}{\ensuremath{\textsf{swap}}}
\newcommand{\swapequiv}{\ensuremath{\textsf{swap-equiv}}}


\newcommand{\iscontr}{\ensuremath{\mathsf{isContr}}}
\newcommand{\isprop}{\ensuremath{\mathsf{isProp}}}
\newcommand{\isset}{\ensuremath{\mathsf{isSet}}}


\def\compare#1#2#3#4{\if#1#3\if#2#41\else0\fi\else0\fi}

\newcommand{\istype}[1]{
  \edef\a{\compare-2#1\empty\empty}
  \if\a1 \iscontr \else
  \edef\b{\compare-1#1\empty\empty}
  \if\b1 \isprop \else
  \edef\c{#1}
  \if0\c \isset \else
  \mathsf{is}\mbox{-}{#1}\mbox{-}\mathsf{type} \fi\fi\fi
}



\newcommand{\ua}{\ensuremath{\mathsf{ua}}\xspace} \newcommand{\idtoeqv}{\ensuremath{\mathsf{idtoeqv}}\xspace}
\newcommand{\univalence}{\ensuremath{\mathsf{univalence}}\xspace} 


\newcommand{\Sn}{\mathbb{S}}


\newcommand{\north}{\mathrm{north}}
\newcommand{\south}{\mathrm{south}}
\newcommand{\meridian}{\mathrm{meridian}}

\newcommand{\gens}[2]{\mathbb{S}_{#1} \! {#2}}
\newcommand{\gensw}[2]{\mathbb{S}_{#1}^{\mathsf {tame}} \! {#2}}
\newcommand{\base}{\ensuremath{\mathsf{base}}\xspace}
\newcommand{\lloop}{\ensuremath{\mathsf{loop}}\xspace}
\newcommand{\surf}{\ensuremath{\mathsf{surf}}\xspace}

\newcommand{\points}[1]{\mathfrak{p}_{#1}}
\newcommand{\multipoints}[2]{\mathfrak{p}_{#1}^{#2}}
\newcommand{\hub}[1]{\mathfrak{h}_{#1}}
\newcommand{\spokes}[1]{\mathfrak{s}_{#1}}

\newcommand{\indpoints}[1]{\mathrm{p}_{#1}}
\newcommand{\indhub}[1]{\mathrm{h}_{#1}}
\newcommand{\indspokes}[1]{\mathrm{s}_{#1}}

\newcommand{\ind}[2]{\mathsf{ind}^{#1}_{#2}}

\newcommand{\seqp}{\mathfrak{e}} \newcommand{\seqg}{\mathfrak{g}} 

\newcommand{\indseqp}{\mathrm{e}} \newcommand{\indseqg}{\mathrm{g}} 


\newcommand{\bbg}{\mathsf{b}}
\newcommand{\llg}{\mathsf{l}}
\newcommand{\wwg}{\mathsf{w}}


\newcommand{\mapfunc}[1]{\ensuremath{\mathsf{ap}_{#1}}\xspace} \newcommand{\map}[2]{\ensuremath{{#1}\mathopen{}\left({#2}\right)\mathclose{}}\xspace}
\newcommand{\mapdepfunc}[1]{\ensuremath{\mathsf{apd}_{#1}}\xspace} \newcommand{\mapdep}[2]{\ensuremath{\mapdepfunc{#1}\mathopen{}\left(#2\right)\mathclose{}}\xspace}

\newcommand{\happly}{\ensuremath{\mathsf{happly}}}

\newcommand{\uipplain}{\mathsf{UIP}}
\newcommand{\uipext}[1]{\uipplain_{#1}}

\newcommand{\dec}{\mathsf{decidable}}
\newcommand{\deceq}{\mathsf{discrete}}

\newcommand{\UIP}{\textsf{UIP}}
\newcommand{\MLTT}{\textsf{MLTT}}
\newcommand{\HOTT}{\textsf{HoTT}}
\newcommand{\MLTTK}{\ensuremath{\MLTT_K}}


\newcommand{\trunc}[2]{\mathopen{}\left\Vert #2\right\Vert_{#1}\mathclose{}}
\newcommand{\ttrunc}[2]{\bigl\Vert #2\bigr\Vert_{#1}}
\newcommand{\Trunc}[2]{\Bigl\Vert #2\Bigr\Vert_{#1}}
\newcommand{\truncf}[1]{\Vert \blank \Vert_{#1}}
\newcommand{\tproj}[3][]{\mathopen{}\left|#3\right|_{#2}^{#1}\mathclose{}}
\newcommand{\tprojf}[2][]{|\blank|_{#2}^{#1}}

\newcommand{\bbbrck}[1]{\Bigl\Vert #1 \Bigr\Vert}
\newcommand{\brck}[1]{\trunc{}{#1}}
\newcommand{\bbrck}[1]{\ttrunc{}{#1}}
\newcommand{\Brck}[1]{\Trunc{}{#1}}
\newcommand{\bproj}[1]{\tproj{}{#1}}
\newcommand{\bprojf}{\tprojf{}}

\newcommand{\onebrck}[1]{\{#1\}}


\newcommand{\ordinal}[1]{[\mathsf{#1}]} \newcommand{\incrmapplain}{\mathrel{\mathrlap{\hspace{2pt}\raisebox{4pt}{\scalebox{0.7}{}}}\mathord{\rightarrow}}}
\newcommand{\incrmap}[2]{\ordinal{#1} \incrmapplain \ordinal{#2}}
\newcommand{\sincrmap}[2]{\ordinal{#1}\mathrel{\mathrlap{\hspace{1.5pt}\raisebox{3pt}{\scalebox{0.5}{}}}\mathord{\rightarrow}}\ordinal{#2}}
\newcommand{\Sk}[2]{\mathsf{Sk}^{\ordinal {#1}}_{\ordinal {#2}}}
\newcommand{\Fibeq}[1]{\mathsf{F}_{\ordinal {#1}}}
\newcommand{\Skfun}[4]{\mathsf{Sk}^{\ordinal {#1}, \ordinal{#2}}_{\ordinal {#3}, \ordinal {#4}}}







\newcommand{\fst}{\mathsf{fst}}
\newcommand{\snd}{\mathsf{snd}}

\newcommand{\inl}{\mathsf{inl}\xspace}
\newcommand{\inr}{\mathsf{inr}\xspace}
\newcommand{\inone}{\mathsf{in_1}\xspace}
\newcommand{\intwo}{\mathsf{in_2}\xspace}
\newcommand{\inthree}{\mathsf{in_3}\xspace}


\newcommand{\LEM}[1]{\ensuremath{\mathsf{LEM}_{#1}}\xspace}
\newcommand{\choice}[1]{\ensuremath{\mathsf{AC}_{#1}}\xspace}
\newcommand{\infchoice}{\choice \infty}


\newcommand{\dpath}[4]{#3 =^{#1}_{#2} #4}


\newcommand{\const}{\mathsf{const}\xspace}
\newcommand{\coll}{\mathsf{coll}\xspace}
\newcommand{\pathcoll}{\mathsf{pathColl}\xspace}
\newcommand{\stable}{\mathsf{stable}\xspace}
\newcommand{\sep}{\mathsf{separated}\xspace}
\newcommand{\hstable}{\mathsf{splitSup}\xspace}
\newcommand{\istrans}{\mathsf{isTransitive}\xspace}
\newcommand{\hsep}{\mathsf{hSeparated}\xspace}
\newcommand{\fix}{\mathsf{fix}\xspace}

\newcommand{\cohcond}{\mathsf{coh}}

\newcommand{\h}{\operatorname{\mathsf{h_{tr}}}}
\newcommand{\elim}{\operatorname{\mathsf{rec_{tr}}}}
\newcommand{\depelim}{\operatorname{\mathsf{ind_{tr}}}}

\newcommand{\seg}{\mathsf{seg}}
\newcommand{\I}{\mathbb I}
\newcommand{\myst}{\mathsf{myst}}

\newcommand{\UUpointed}{\UU_{\bullet}}

\def\cf{see\xspace}






\newcommand{\pted}[1]{\mathfrak #1}
\newcommand{\loops}{\mathsf{Loop}}

\newcommand{\hasup}[3]{\mathsf{up}^{{#1}:{#2}}_{{#3}}}
\newcommand{\hasdup}[3]{\mathsf{dup}^{{#1}:{#2}}_{{#3}}}

\newcommand{\gettype}{\mathsf{type}}
\newcommand{\getcons}{\mathsf{cons}}



\newcommand{\sigbu}{\Sigma^\bullet}
\newcommand{\pibu}{\Pi^\bullet}
\newcommand{\pibucurried}[2]{\pibu_{#1}{#2}}

\newcommand{\pair}[2]{\left( #1 \; , \; #2 \right)}

\newcommand{\functioncompose}{\ensuremath{\mkern-2mu \circ \mkern-2mu}}

\newcommand{\PointedPred}[1]{\operatorname{Fam_{#1}^{\bullet}}}



\newcommand{\trunctype}[3]{\mathcal{T}^{#3}_{#1,#2}}

\newcommand{\conn}[2]{ \left\lfloor {#1} \right\rfloor^{#2} }

\newcommand{\truncmap}[2]{\tproj {} {#2} {#1}}

\newcommand{\pseudotrunc}[2]{\llparenthesis {#2} \rrparenthesis_{#1}}
\newcommand{\multipseudotrunc}[3]{\llparenthesis {#3} \rrparenthesis_{#1}^{#2}}
\newcommand{\naivepseudotrunc}[2]{\langle \!\! \langle #2 \rangle \!\! \rangle_{#1}}



\newcommand{\theorywithhit}{\ensuremath{\mathsf{MLTT}^{\mathsf{UA}}_{\mathsf{TRUNC}}}\xspace}
\newcommand{\theorywithua}{\ensuremath{\mathsf{MLTT}^{\mathsf{UA}}}\xspace}
\newcommand{\theoryplain}{\ensuremath{\mathsf{MLTT}}\xspace}

\newcommand{\isconnectedhit}[1]{\ensuremath{\mathsf{is}\mbox{-}{#1}\mbox{-}\mathsf{connected}}}
\newcommand{\isconnectedhitprime}[1]{\mathsf{is}\mbox{-}{#1}\mbox{-}\mathsf{connected'}}
\newcommand{\isconnectedplain}[3]{\ensuremath{\mathsf{is}\mbox{-}{#1}\mbox{-}\mathsf{connected}_{{#2},{#3}}^\star}}
\newcommand{\isconnectedplainwo}[1]{\ensuremath{\mathsf{is}\mbox{-}{#1}\mbox{-}\mathsf{connected}^\star}}






\newcommand{\impl}[2]{\ensuremath{(#1) \Rightarrow (#2)}}
\newcommand{\implsimple}{\ensuremath{\Rightarrow}}
\newcommand{\implref}[2]{\ensuremath{(\ref{#1}) \! \Rightarrow \! (\ref{#2})}}

\newcommand{\logiceqv}{\ensuremath{\longleftrightarrow}}




\newcommand{\eqsst}[1]{\mathsf{Eq}_{#1}}
\newcommand{\trivsst}[1]{\mathsf{T}_{#1}}



\newcommand{\deltop}{\ensuremath{\Delta_+^\mathrm{op}}}
\newcommand{\deltplus}{\ensuremath{\Delta_+}}
\newcommand{\C}{\mathcal{C}}




\def\filledsim{\Delta}
\def\boundary{\partial\Delta}
\def\horn{\Lambda}




\renewcommand{\lim}{\mathsf{lim}\xspace}



\newcommand{\ttfc}{\mathfrak C}
\newcommand{\ccat}{\widehat{\Delta}_+}
\newcommand{\opccat}{\widehat{\Delta}_+^\mathrm{op}}
\newcommand{\cob}[2]{c^{#2}_{\ordinal {#1}}}








\newcommand{\fibslice}[2]{\left( {#1} \slash {#2} \right)_{\mathsf f} }

\newcommand{\proj}{\mathsf{proj}}


\newcommand{\apoint}{\mathfrak {a_0}}


\newcommand{\Aa}[1]{\mathcal T\mkern-6mu{#1}}
\renewcommand{\AA}[1]{\widehat{\mathcal T}\mkern-6mu{#1}}
\newcommand{\Ee}[1]{\mathcal E\mkern-4mu{#1}}
\newcommand{\EE}[1]{\widehat{\mathcal E}\mkern-4mu{#1}}

\newcommand{\Nn}{\mathcal N}
\newcommand{\NN}{\widehat\Nn}

\newcommand{\Pp}{\mathcal P}

\newcommand{\coskel}[3]{\mathsf{coskel}^{\ordinal{#1},{#2}}_{#3}}


\newcommand{\oppo}[1]{#1^\mathrm{op}}











\newcommand{\toomega}{\xrightarrow{\raisebox{-1pt}{}}} 
\newcommand{\ton}[1]{\xrightarrow{\raisebox{-1pt}{}}} 




\newcommand{\fib}{\twoheadrightarrow}
\newcommand{\fibre}{\twoheadleftarrow}

\newcommand{\trivfib}{\mathrel{\mathrlap{\hspace{2.5pt}\raisebox{4pt}{}}\mathord{\twoheadrightarrow}}}
\newcommand{\trivfibre}{\mathrel{\mathrlap{\hspace{5pt}\raisebox{4pt}{}}\mathord{\twoheadleftarrow}}}

\newcommand{\cofib}{\rightarrowtail}
\newcommand{\trivcofib}{\mathrel{\mathrlap{\hspace{2.5pt}\raisebox{4pt}{}}\mathord{\rightarrowtail}}}
\newcommand{\arrowsim}{\mathrel{\mathrlap{\hspace{2.5pt}\raisebox{4pt}{}}\mathord{\rightarrow}}}



\newcommand{\idmorph}[1]{\mathsf{id}_{#1}}

\newcommand{\truncCat}[1]{ \llparenthesis {#1} \rrparenthesis } 

\let\proptrunc \brck

\renewcommand{\I}{\mathfrak{I}}





\newcommand{\rref}{\mathrm{r}}
\newcommand{\ssym}{\mathrm{s}}
\newcommand{\ttra}{\mathrm{t}}
\newcommand{\UUU}{\mathbf U}

\newcommand{\Z}{\ensuremath{\mathbb{Z}}\xspace}


\newcommand{\isyongrp}{\mathsf{isYonedaGrp}}
\newcommand{\idom}{\ensuremath{\mathsf{Id}\omega}}


\newcommand{\prop}{\mathbf{Prop}}
\newcommand{\comp}{\textit{comp}}
\newcommand{\compInv}{\textit{compInv}}
\newcommand{\sound}{\textit{sound}}
\newcommand{\exact}{\textit{exact}}
\newcommand{\isweq}[1]{\iseq(#1)}

\newcommand{\nfak}{\mathbf{n!}}
\newcommand{\n}{\mathbf n}

\newcommand{\reflWritten}{\mathsf{refl}}
\newcommand{\symWritten}{\mathsf{sym}}
\newcommand{\transWritten}{\mathsf{trans}}

\newcommand{\reflWrittensim}{{{\mathsf{refl}}^\sim}}
\newcommand{\symWrittensim}{{\mathsf{sym}}^\sim}
\newcommand{\transWrittensim}{{\mathsf{trans}}^\sim}

\newcommand{\isclasses}{\mathsf{isCl}}

\newcommand{\one}{\ensuremath{\mathbf{1}}\xspace}
\newcommand{\zero}{\ensuremath{\mathbf{0}}\xspace}





\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
    \node[shape=circle,draw,inner sep=0.5pt] (char) {#1};}}

\newcommand*\dashcircled[1]{\tikz[baseline=(char.base)]{
    \node[shape=circle,dashed,draw,inner sep=0.5pt] (char) {#1};}}



\newcommand{\forinnerpart}{}
\newcommand{\formalised}{\circled{\forinnerpart}\xspace}
\newcommand{\formalisednospace}{\circled{\forinnerpart}}

\newcommand{\formalisedElsewhere}{\dashcircled{\forinnerpart}\xspace}


\newcommand{\repr}[1]{\mathsf{Rep}(#1)}



\newcommand{\Hom}{\mathsf{Hom}}
\newcommand{\Fin}{\mathsf{Fin}}
\newcommand{\isIncr}{\mathsf{isIncr}}

\newcommand{\cm}{\mathsf{cm}}
\newcommand{\cmr}{\mathsf{cm'}}
\newcommand{\isnconst}[1]{\mathsf{is}\mbox-{#1}\mbox-\mathsf{constant}}
\newcommand{\isnkconst}[2]{\mathsf{is}\mbox-({#1}\mbox,{#2})\mbox-\mathsf{constant}}
\newcommand{\tonk}[2]{\xrightarrow{(#1,#2)}}


\newcommand{\isNull}{\mathsf{isNull}}
\newcommand{\sind}{\mathsf{rind}} \newcommand{\canon}{\mathfrak c} \newcommand{\pinvr}{\mathfrak d} \newcommand{\connn}[1]{\mathsf{conn}_{#1}} 

\newcommand{\strict}[1]{#1^\mathrm{s}}
\newcommand{\fibrant}[1]{#1^\mathrm{f}}
\newcommand{\Ty}{\mathsf{Ty}}
\newcommand{\fTy}{\fibrant{\Ty}}
\newcommand{\Tm}{\mathsf{Tm}}
\newcommand{\fTm}{\fibrant{\Tm}}
\newcommand{\op}[1]{#1^{\mathrm{op}}}
\newcommand{\setcat}{\mathsf{Set}}
\newcommand{\presheaf}[1]{\widehat{#1}}
 
\usepackage{microtype}
\bibliographystyle{plain}

\usepackage{enumitem}
\usepackage{csquotes}
\usepackage{mathalfa}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{mathtools}
\usepackage[llparenthesis,rrparenthesis]{stmaryrd}
\usepackage{xspace}
\usepackage{tabularx}

\usepackage{smalllists}

\usepackage{graphics}
\usepackage{MnSymbol}
\usepackage{braket}
\usepackage{float}
\usepackage{enumitem}
\usepackage{amsthm}
\usepackage{hyperref}
\usepackage[normalem]{ulem}

\usepackage{proof}


\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{mainlemma}[theorem]{Main Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{conjecturetheorem}[theorem]{Conjecture or Theorem}

\theoremstyle{definition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{openproblem}[theorem]{Open Problem}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{principle}[theorem]{Principle}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{notation}[theorem]{Notation}
\newtheorem{example}[theorem]{Example}
\newtheorem{remcor}[theorem]{Remark and Corollary}

\title{Extending Homotopy Type Theory with Strict Equality}
\author{Thorsten Altenkirch \and Paolo Capriotti \and Nicolai Kraus}
\thanks{This work was supported by the Engineering and Physical Sciences Research Council (EPSRC), grant reference EP/M016994/1, and by USAF, Airforce office for scientific research, award FA9550-16-1-0029.}

\newcommand{\Type}{\textbf{Type}}
\newcommand{\SST}{\textrm{SST}}
\newcommand{\SSX}{\textrm{SS}}
\renewcommand{\Sk}{\textrm{Sk}}
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\Func}[2]{{#1}\Rightarrow{#2}}


\begin{document}

\begin{abstract}
In homotopy type theory (HoTT), all constructions are necessarily stable under homotopy equivalence.  This has shortcomings: for example, it is believed that it is impossible to define a type of semi-simplicial types.  More generally, it is difficult and often impossible to handle towers of coherences.  To address this, we propose a 2-level theory which features both strict and weak equality.  This can essentially be represented as \emph{two} type theories: an ``outer'' one, containing a strict equality type former, and an ``inner'' one, which is some version of HoTT.  Our type theory is inspired by Voevodsky's suggestion of a \emph{homotopy type system} (HTS) which currently refers to a range of ideas.  A core insight of our proposal is that we do not need any form of equality reflection in order to achieve what HTS was suggested for.  Instead, having unique identity proofs in the outer type theory is sufficient, and it also has the meta-theoretical advantage of not breaking decidability of type checking.  The inner theory can be an easily justifiable extensions of HoTT, allowing the construction of ``infinite structures'' which are considered impossible in plain HoTT. Alternatively, we can set the inner theory to be exactly the current standard formulation of HoTT, in which case our system can be thought of as a type-theoretic framework for working with ``schematic'' definitions in HoTT.  As demonstrations, we define semi-simplicial types and formalise constructions of Reedy fibrant diagrams.
\end{abstract}
\maketitle


\section{Introduction: Motivations for a 2-Level System}

The identity type is probably the single concept of intensional Martin-L\"of type theory () which has created most questions, stimulated most research, caused most confusion, and enabled the largest number of different views.
Written  for elements  of a type , the identity type expresses that two elements are equal in some sense and can be substituted for each other, and the elements of this type are called equalities.
However, by default, it has a somewhat strange standing.
On the one hand, it is not well-behaved when it comes to describing equality of functions and equality of types.
Given two functions of the same type, we cannot derive the principle of (naive) function extensionality, saying that the functions are equal if they are equal at every point, from the basic axioms.
We also cannot show that equivalent types can be substituted for each other, although they do behave equivalently in any given situation.
On the other hand, we also cannot derive the principle of unique identity proofs (): by a construction of Hofmann and Streicher~\cite{hofmannStreicher_groupoids}, we can not show  for two equalities . A priori, it is unclear what it should mean to have distinguishable equalities and how one can make sense of this behaviour.

As we view it, there are two major ways to remedy the situation.
Both can be seen as extensions of . The principle of function extensionality can be added in any case, but after that, we have two possibilities to extend the theory further.
The first is to add  (or, equivalently, Streicher's ) as an axiom. Let us call the resulting type theory .
The second possibility is to consider univalence, ensuring that type equality is what one would ideally expect.
This approach is taken by Homotopy Type Theory~\cite{HoTTbook}, and we write  for the resulting theory.

One appeal of  is that equalities can be seen as paths in a space, and it is even possibly to develop a lot of homotopy theory synthetically.
An important insight is that, when doing homotopy theory in type theory, every statement that we make is up to homotopy, and every construction respects (homotopical) equivalence. 
This means that whatever we do will be ``non-evil'' in the sense that it can only take the homotopy type of spaces, and homotopy equivalence classes of maps, into account, and not the concrete representations of spaces or maps.
Exactly this is often considered a selling point of : one often defines constructions using representatives of homotopy classes in traditional homotopy theory and is forced to show that the constructions are well-defined, i.e.\ do not depend on the choice of the representative. 
In , everything we do is automatically well-defined as we are simply not able to talk about strict properties internally.

Going back to the homotopical point of view, it is not hard to imagine that the blessing of having only constructions up to homotopy can turn out to be a curse:
we are unable to make any strict statement.
For example, we cannot form a type expressing that a given diagram commutes strictly; all we can do it stating that it commutes up to homotopy.
Unfortunately, depending on the shape of the diagram, this will only be sufficient in the simplest cases.
More often than not, it will be necessary to say that the different ``pieces'' (the equalities expressing commutativity) fit together. 
For example, the fact that a certain sub-diagram commutes can be part of the proof that the diagram commutes, but it may at the same time be derivable as the composition of the fact that other sub-diagrams commute.
In this case, it is natural to require these different ways of getting a certain proof to be equal.
It does not stop here; these new proofs can itself be required to be coherent, and so on.
What happens here is not at all something that can only be observed in type theory.
The first step becomes already apparent in the theory of monoidal categories in the form of ``Mac Lane's Pengaton''.
On higher dimensions, it is exactly the same issue that is discussed as \emph{homotopy commutativity versus homotopy coherence} by Lurie~\cite{Lurie_higherToposTheory}.

In general, homotopy coherence corresponds to infinite towers of coherence data, and it is a major open problem (and commonly believed to be unsolvable) to express such towers internally in .
One way to avoid this problem is to restrict constructions to types of low truncation levels.
As an examples, the category theory developed in~\cite{ahrens_rezk} only considers -truncated types and [what corresponds to] ordinary categories.
This is in many situations not satisfactory: we know that types are -groupoids~\cite{lumsdaine_phd,bg:type-wkom}, and similarly, the universe should be an -category. 
Unfortunately, we seem to have no way of expressing this internally in .

The crucial shortcoming of  is that we are unable to perform some constructions 
which actually \emph{seem} to be harmless as they only require finite amounts of coherences at every step.
An example that has received considerable attention in the -community is the construction of Reedy fibrant -truncated semi-simplicial types (simply referred to as \emph{semi-simplicial types}).
Let us start with , the category of finite non-zero ordinals and strictly monotonous functions.
Let us write  for the ordinal with  elements.
A type-valued diagram over  is a strict functor from  to the category of types.
It would correspond to a type  (for simplicity written ) for every , and face maps  for , as it is well-known that any map can be written as a composition of face maps.
The problem is that we need the semi-simplicial identities (essentially a representation of the functor laws) to be strict, which we cannot express in type theory.
The considered approach to avoid this problem is to only attempt internalising Reedy fibrant diagrams over , essentially ensuring that the face maps are simple projections.
Using the correspondence between fibrations and type families, a (Reedy fibrant) semi-simplicial type then 
corresponds to a type  (the ``points'') on level . 
On level , we need a family , where  is the universe of types. 
We think of  as lines between types.
Next, we need , the type of fillers for triangles. 
Writing down the type of  is already a bit tedious, but nevertheless straightforward:  is a family which gives a type for any collection of four points, six lines and four triangles that form an empty tetrahedron.
The long-standing open problem of homotopy type theory is to write down the type of  in general (up to equivalence).
Perhaps surprisingly, this does not seem to be possible.
What \emph{is} possible is to generate an expression  for every externally fixed numeral , such that the expressions  all ``fit together''.
When one tries to do the construction for a \emph{variable} , it does no longer type-check.
The reason is that some judgmental equalities that hold in the case of a numeral  fail to hold in the case of a variable.
We can try to prove in type theory that the required equalities hold up to homotopy.
However, we quickly have to realize that we then also need that these equalities are coherent, and that the coherence proofs are coherent themselves, and so on; something that no one has managed to do so far.
The problem is that we cannot formulate the tower of coherences that we need to prove. 
Morally, the required equalities \emph{should} hold and be fully coherent just because they are trivially satisfied for each externally fixed natural number.
If we can use a system where we judgmental equalities can be shown by induction, there would thus be no problem at all; however, this would require judgmental equalities to be some sort of type.

In , the internal equality type can be seen as an internalised version of judgmental equality.
For example, a well-known meta-theoretic statement is that any equality that is constructed in the empty context is ; that is, if we can show an equality internally without assumptions, then this equality holds judgmentally.
Not surprisingly, it is possible to construct Reedy fibrant semi-simplicial types in .
However, we can also simply define categories and functors in the naive sense, as all coherences are satisfied automatically.

The idea of a 2-level system is to combine  and  instead of viewing them as two alternative extensions of .
We can describe this in two ways:
\begin{enumerate}
 \item \label{item:firstKthenEmbed}
 Start with a type theory that has axiom  and consider a ``sub-theory'' of types and maps that do not talk about equalities. 
 Inside this sub-system, we can consider a new equality type and univalent universes. 
 If we use the equality type with  of the outer system, we cannot form types that live in the inner system; however, we can reason about the inner system.
 \item We may start with  and try to formulate the meta-theory (in which judgmental equality lives) as a type system.
 It is not necessary to capture every aspect of the meta-theory in this type system; the important part is that this outer type system has an equality type (which we call \emph{strict equality}) satisfying .
 We then have in total three equalities: the equality in ; the strict equality; and the judgmental equality (which we should now refer to as \emph{definitional equality}).
 From the point of view of , the strict equality and definitional equality are identical.
\end{enumerate}

Considering a type theory with two equality types is not new.
Our proposal is motivated by the suggestion of 
a \emph{homotopy type system} (HTS) by Voevodsky~\cite{voe_hts}.
However, as far as we are aware, ``HTS'' mostly refers to a range of ideas so far 
but not to a precise theory, and there is no publication that presents or analyses HTS.
The core idea of HTS is to make some judgmental equalities provable.
In other words, some form of equality reflection, the characteristic concept of extensional type theory, is reintroduced, in a way that is compatible with the ``standard'' intensional identity type.
A concrete theory that could be called ``HTS'' is outlined in the draft~\cite{voe_hts} which, unfortunately, presents rather involved rules that would presumably be non-trivial to justify.
It is sometimes said that \emph{Andromeda}, a project by Bauer et al.~\cite{andromeda}, is an implementation of HTS.
However, this is probably rather misleading as Andromeda goes in a very different direction and does not feature univalence at all.


A key observation of the current paper is that no form of equality reflection is actually required.
Our proposal instead only required unique identity proofs for the strict equality type.
Thus, we can avoid all the problems that are usually connected to equality reflection, such as undecidability of type checking.
In contrast, the theory that we suggest is well-behaved, very close to the standard formulation of , and has straightforward semantics.
One could expect that a downside of our system might be reduced expressibility compared to a theory that features equality reflection. 
However, we show that we can achieve in our system what HTS was suggested for: a definition of semi-simplicial types, and other constructions.
This should actually not be surprising in the light of Hofmann's result~\cite{hofmann_conservativity}, which states that equality reflection is conservative over .

Our 2-level theory can be defined as two separate type theories with a morphism between them. 
This actually gives a recipe for constructing a variety of reasonable 2-level theories, and the choices that can be made affect the exact abilities of the system.
We believe that our 2-level theories can be used in two ways.
First, we can use the outer theory as a powerful formal language to study the inner theory.
For some formulations of the 2-level theory, we get a conservativity result (by an argument of the second-named author; see the forthcoming thesis~\cite{paolo:thesis}).
This means that the inner theory is exactly  as studied in the standard textbook on homotopy type theory~\cite{HoTTbook} and by many authors.
In a proof assistant which supports this theory, we can then implement results that so far can only be stated meta-theoretically.
To give an example, it is shown in~\cite{kraus_generaluniversalproperty} that constant functions from  to  which satisfy  coherence conditions correspond to maps , provided that  is -truncated. 
This can be done in  only if  is an externally fixed natural number.
In the 2-level system, we can formalise it by taking  to be a number in the outer theory, and show that the equivalence holds in the inner theory.

Second, we can use the construction of 2-level theories to derive extensions of  that allow constructions that  does not allow.
For example, we can assume that the natural numbers of the outer theory are \emph{exactly} the natural numbers of the inner theory, something that is satisfied in the simplicial set model.
This gives us a univalent type theory in which various concepts including semi-simplicial types can be defined.

\subparagraph*{Contributions of the paper}
Summarised, the main contributions of the paper are:
\begin{itemize}
 \item We give (for the first time) a clean presentation of a system with two equalities.
 \item Our theory is simple enough to have straightforward semantics. Such semantics have not yet been described for previous proposals~\cite{voe_hts,DBLP:journals/corr/PartL15}.
 \item We demonstrate how our theory allows constructions that are thought to be impossible in standard , such as semi-simplicial types~\cite{herbelin_semisimpl,DBLP:journals/corr/PartL15}. A partial \textsf{Agda} formalisation is available.
 \item Schematic constructions, which could so far only be given on paper, can be formalised in our system. As an example, we perform constructions of Reedy fibrant diagrams. Further work is outlined in the conclusions.
\end{itemize}


\subparagraph*{Related work}
The current paper is the write-up of our presentation~\cite{altenkirch_twolevels} at TYPES'15.
As briefly explained above, the main difference to Voevosky's draft~\cite{voe_hts} is that we do not consider any form of equality reflection, saving us from various difficulties.

Superficially related is the construction by Maietti~\cite{Maietti2009319} of a \emph{two-level foundation for constructive mathematics}. However, their motivation and goals are very different from ours, hence their system cannot be used to reconcile strict equality with univalence.  

Our work is more closely related to a recent proposal by Part and Luo~\cite{DBLP:journals/corr/PartL15} of Logic-enriched . 
In their system, our strict layer of type theory is replaced by a ``logic enrichment''.
Their proposal is limited to the construction of semi-simplicial types (corresponding to the one that we give in Section~\ref{sec:semisimp}). 
It is not explained whether this can be generalised to Reedy fibrant diagrams in the sense we present in Section~\ref{sec:diag-inverse}, as they use specific properties of the  category.

Herbelin has given a construction of semi-simplicial types along the lines of the one in Section~\ref{sec:semisimp} in an unspecified type theory containing a ``connective'' for strict equality~\cite{herbelin_semisimpl}.



\subparagraph*{\textsf{Agda} formalisation}
As a proof assistant based on our 2-level theory does not (yet) exist, we cannot formalise our constructions exactly as they are presented.
However, we have implemented in Agda an approximation of the construction of semi-simplicial types that is given in Section~\ref{sec:semisimp}.
It can be found on GitHub at \href{https://github.com/nicolaikraus/HoTT-Agda/blob/master/nicolai/SemiSimp/SStypes.agda}{\nolinkurl{github.com/nicolaikraus/HoTT-Agda/tree/master/nicolai/SemiSimp}}.
For an explanation of the relationship between the construction given in the paper and this implementation, we refer to the last remark of Section~\ref{sec:semisimp}.

\subparagraph*{Organisation}
The structure of the paper is as follows.
In Section~\ref{sec:specification}, we specify our 2-level theories.
Section~\ref{sec:semisimp} explains the construction of Reedy fibrant -truncated semi-simplicial types in a way that could \emph{nearly} be done in homotopy type theory, and we show how the missing gap is filled by our strict equality.
Then, in Section~\ref{sec:diag-inverse}, we demonstrate how our theory can be used to internalise standard constructions in a fairly straightforward way. 
Finally, in 
Section~\ref{sec:conclusions}, we outline further work and conclude the paper. 


\section{The Specification of a 2-Level System} \label{sec:specification}

In this section, we want to specify our 2-level theory (or, to be precise, our family of 2-level theories). 
We give two presentations: first, the semantical approach, and second, the syntactical approach.
With the first approach, we explain how the theory is constructed.
It also shows which choices can be made, and how models of the 2-level theory can be constructed.
The syntax that we propose afterwards is based on the semantics, but fixes a precise system.

\subsection{Semantical Approach}

Many models of type theory consist of a category , modelling the category of contexts.
Starting from , additional structures are added to model types and terms, together with the structure that is needed to model the components of the considered theory (such as universes or dependent functions).
Then, a model of a 2-level theory in our sense is given by a category of contexts , together with \emph{two} structures on  such that the first structure (taken together with ) models , and the second structure (taken together with ) models .
Finally, we need a morphism between the structures in a suitable sense, describing how any type or term in  can be viewed as a type or term in . 

We make this precise using the notion of \emph{categories with families}~\cite{dybjer1995internal}.  Let us recall the definition:

\begin{definition}[CwF {\cite{dybjer1995internal}}]
A \emph{category with families} (CwF) is given by:
\begin{itemize}
\item a category , equipped with a distinguished terminal object ;
\item a presheaf ;
\item a presheaf ;
\item for all  and , an object  representing the functor  defined by:

\end{itemize}

The objects of  are called \emph{contexts}. Given a context , the
elements of  are called \emph{types}, and given a type , the
elements of  are called \emph{terms}.

The context  is called the \emph{context extension} of  by the
type , and  is the \emph{display map} of .

The action of  and  on morphisms is called \emph{substitution}.
\end{definition}

A CwF can be regarded as a model of  with only
\emph{structural rules}, i.e.\ rules that deal with types, terms and
substitutions, but no type formers (like  or  types).  Type formers
can be postulated separately as additional structures on a CwF.
For details, we refer to \cite{dybjer1995internal} and \cite{hofmann_syntaxSemantics}.

To model a 2-level type theory, we need to add some extra structure to a CwF:
\begin{definition}\label{def:cwf2}
A \emph{2-level category with families} is a CwF , together with:
\begin{itemize}
\item a presheaf ;
\item a natural transformation .
\end{itemize}
\end{definition}

Given a 2-level CwF , we will denote the underlying category with family by
.  There is also a second CwF structure on , where the types
are given by , and terms are defined as:

and context extension is given simply by .  We will
denote this second CwF by .

The map  determines a morphism of CwF ,
which we will also denote by .

The theory employed in this paper will be modelled by a 2-level CwF  where:
\begin{itemize}
\item  is a model of ;
\item  is a model of ;
\item the morphism  preserves ,  and  \emph{strictly}.
\end{itemize}

Note that, crucially, equality types, although present in both CwF structures,
are \emph{not} generally preserved.  This is important, because preservation of
equality would mean that axiom  holds in , which in turn would
imply that  does not admit any univalent universes containing
non-propositional types.

Other type formers besides those mentioned might or might not be preserved.  We
say that a 2-level CwF is \emph{strong} if  preserves coproducts, natural numbers, and the empty type (more generally -types, if part of the theory). 

Interestingly, most of the existing models of  can be naturally extended
to a 2-level CwF.  Most notably, the simplicial model
\cite{kapLumsVoe_ssModelOfUF} can be regarded as a 2-level CwF, where  is
given by arbitrary (well-ordered) morphisms,  is the subfunctor of 
consisting of Kan fibrations, and  is simply the inclusion.  With this
setup,  is (equivalent to) a presheaf CwF, which models type theory
with equality reflection (hence, in particular, ), and  is
the same as the model defined in the paper.

One can also start with an arbitrary model  of , then consider the
presheaf category .  It is perhaps not surprising that one can
equip  with a 2-level CwF structure so that  can be recovered
inside .  This makes it possible to use 2-level type
theory to formulate and prove statements that hold in any model of ,
i.e.\ 2-level type theory can be regarded as a meta-language for .

However, the details of this construction are somewhat involved, mainly due to
the strictness requirement in Definition~\ref{def:cwf2}.  Therefore, we will
not explore that direction further in this paper and refer instead to the
forthcoming thesis of the second-named author~\cite{paolo:thesis}.

\newcommand{\steq}{\stackrel{s}{=}}
\newcommand{\ctx}{\mathrm{ctx}}



\subsection{Syntactical Approach}

In the syntactical approach, the clear separation of a 2-level theory into two theories becomes harder to see.
We do not leave as many choices open as in the semantical approach, but rather fix a concrete theory; and the choices that we make ensure that the conservativity result of the forthcoming thesis~\cite{paolo:thesis} applies to the presented theory.

For a precise specification, we choose a presentation in the style of~\cite[Appendix A.2]{HoTTbook}, which considers three forms of judgments: ; ; and .
Fortunately, we do not need to give \emph{all} the rules, as most of them are identical to those given in~\cite[Appendix A.2]{HoTTbook}. 
Thus, in most cases, it is sufficient to state the difference in order to give both an understandable and a precise specification.

\newcommand{\strictN}{\N^s}

The theory that we consider has the following basic types and type formers: 
, the type former of dependent functions;
, the type former of dependent pairs;
, the coproduct type former;
, the unit type;
, the empty type;
, the fibrant type of natural numbers;
, the equality type (in the sense of );
a hierarchy  of universes.
So far, we can think of these as the types and type formers of .
Further, we have:
, the strict coproduct;
, the strict empty pretype;
, the strict pretype of natural numbers;
, the strict equality;
and hierarchy  of strict universes.

Both the hierarchy  and the hierarchy  are cumulative.
We think of the elements of  as \emph{fibrant types} (or simply \emph{types}), while the elements of  are \emph{pretypes}.

Recall possibility \ref{item:firstKthenEmbed} from the two ways of describing a 2-level system as outlined on page \pageref{item:firstKthenEmbed}: we can start with a type theory with  and embed  later.
Thus, we first consider the type theory with the basic types , , , with universes , and with , , and .
All rules correspond exactly to those of~\cite[Appendix A.2]{HoTTbook}.
For example:
\begin{itemize}
 \item Contexts are formed using elements of , i.e.\ if  is a context and , then  is a context.
 \item If  and , then we have .
 \item If , then we have .
 \item All further rules of , and all rules of , , , , and  are also those given in~\cite[A.2.4--9]{HoTTbook}. 
 The constructors of  are called , , and the constructors of  are called  and .
 We assume all the usual judgmental rules (including the judgmental -rule for ).
\end{itemize}
Further, the theory has a strict identity pretype, written : For any  and , we have , with the introduction rule , the eliminator , and the usual computation rule. 
For pretypes , we can form the pretype of strict isomorphisms, written  (unlike in , it is enough to have maps in both directions such that both compositions are pointwise strictly equal to the identity).
However, we do \emph{not} assume that  is univalent. 
Instead, we add the rule : for , ,  as before, and for , we have a term . 
We also assume that  satisfies the principle of function extensionality.

Note that, so far, we have not considered , , , ,  at all.
We do this now, and their rules are more subtle.
The first important rule is that any type (element of ) is also a pretype (element of ):

This means that informally we can understand  as a subtype of .


Now, let  and  be fibrant types, i.e.\  and .
Then, by~\eqref{eq:type-is-pretype} and by the formation rule of , we have .
However, we add the rule that, under these conditions, this conclusion can be lifted to . 
In other words,  preserves types.
We add the same rule for :

We do \emph{not} add the same rule for , that is, the strict sum of two types is still only a pretype.
Similarly, there is no special rule for : if , it does not matter whether  is a type or only a pretype, the expression  is only an element of , not of .


In contrast, the equality type former  can only be applied to elements of fibrant types; i.e.\ its formation rule is given by

(note that there is no strict universe  involved).
The type  (with the constructor ) is a pretype by rule~\eqref{eq:type-is-pretype}, but (usually) not the same as .
The elimination principle of  only works for families of types (not in general for pretypes).
This means that the usual ``path induction'' principle, which allows us to construct an element of , can only be applied if  is a family of types, i.e.\ .
If we restrict ourselves to types, we can do everything that we can do in . 
In particular, we can say what it means for a function between types to be an equivalences (using ).
We assume that the universes  are univalent, that is, the canonical map from type of equalities  to the type of equivalences  (defined as usual in homotopy type theory) is an equivalence itself.

Similarly, the type former  only allows us to form a type  if  and  are types (elements of some ), and we can only defined a function  with the usual induction principle if  is a family of types.

We have the type of natural numbers  (in any context) with the constructors , , and its induction principle can only be applied to eliminate into families of types.
The same is the case for .
This completes the syntactical characterization of our 2-level system.
We will usually omit the index and simply write  or  instead of  or  in the same style as it is done in~\cite{HoTTbook}.
A strong 2-level theory is now simply one in which  and , and  and , and  and  coincide.

\begin{remark}
 If  is a (``fibrant'') type with elements , then we can form both the type  and the pretype . 
 By ``strict path induction'' (i.e.\ an application of ), we can easily construct a function .
 Consequently, strictly equal elements of a type are also homotopy-equal.
 This corresponds to the fact that judgmental equality in  implies equality (``'').
 We cannot construct a function in the other direction, as the path induction principle  can only be applied to eliminate into types, which  is not. 
 Hence, equal elements are not necessarily strictly equal.
 However, if we have a type which does satisfy this ``equality reflection'' principle, it is easy to see that the type is a set in the sense of homotopy type theory.
\end{remark}

\newcommand{\sst}{\mathsf{SST}}
\newcommand{\ssx}{\mathsf{SS}}
\newcommand{\ssk}{\mathsf{SK}}
\newcommand{\sskmor}{\mathsf{SK}^\to}
\newcommand{\ssfunclaw}{\mathsf{\alpha}}


\section{Semi-Simplicial Types} \label{sec:semisimp}

In a 2-level theory, we can define strict categories in a reasonable sense. 
There are a number of choices that one can make; 
for example, the objects could be a fibrant type or only assumed to be a pretype.
Later (see Definition~\ref{def:strictcat}), we will give one possible concrete definition.
The important thing is that the categorical equations can be required strictly; and, if we have such a strict category , we can easily write down the pretype of strict functors .
Unfortunately, there is no general way to get an actual fibrant type of such functors.

The case where  is  (the category of finite nonempty ordinals and increasing functions) is particularly interesting since ``simplicial structures'' appear frequently in homotopy theory.
Having a type of functors  would have many potential applications; 
maybe most notably, one could try to internalise a constructive version of the model of univalent foundations in simplicial sets~\cite{kapLumsVoe_ssModelOfUF}.
Unfortunately, it seems unreasonable to expect that such a type can be constructed.
It would be a good approximation (and potentially good enough for many constructions) if one could form a type of functors , where  is the category of finite nonempty ordinals and \emph{strictly} increasing functions (a more precise definition will be given below).
Trying to define such a type seems more promising, since  is an \emph{inverse category} and, if we restrict ourselves to \emph{Reedy fibrant} functors, we can describe them by induction (see~\cite{shulman_inversediagrams}).

This gave rise to the challenge of defining Reedy fibrant -truncated semi-simplicial types (in the community often just referred to as \emph{semi-simplicial types}) in type theory.
The challenge was first raised during the special year on Univalent Foundations at the Institute for Advanced Study (Princeton, 2012--13).
As briefly sketched in the introduction, a (Reedy fibrant) -truncated semi-simplicial type is simply a type , a -truncated semi-simplicial type is such an  together with a family , and so on.
Defining -truncated semi-simplicial types as a family  in homotopy type theory is a famous open problem.
Many attempts (see e.g.\ \cite{herbelin_semisimpl,shulman:eating,nicolai:thesis}) have not led to a solution, and at a workshop on HoTT in Warsaw (June 29--30, 2015), a clear majority of the participants expected it to be impossible.

The hard part of the construction is to define the \emph{matching objects} , that is the ``full boundary'' of an -simplex, as the corresponding component of  is then just given as a family .
A popular attempt for defining the matching objects  is to define the \emph{-skeleton}  of  by induction on , that is, the collection of components of  up to level .
As long as  is a fixed numeral, this can be done.
However, if  is a variable, some crucial judgmental equalities do not hold anymore
and the construction is believed to become impossible.
In our -level theory, we can prove strict equalities (i.e.\ the internalisation of judgmental equality) by induction.
This allows us to complete the sketched approach of defining  in a weak sense:
we construct a family . 
If we assume that the strict natural numbers () and the fibrant ones () coincide, this represents a construction of -truncated semi-simplicial types.
Without this assumption and under the conjectured conservativity result~\cite{paolo:thesis},
it internalises the result that -truncated semi-simplicial types can be defined for an externally fixed .

To give the precise construction, let us first note that we have the family  of finite types ( is the type with  elements), together with the families .
Let us write  for the predicate 
 
expressing that a function is strictly monotonously increasing.
Let us further write  for the type .
We then have a composition operator , defined separately on each of the two components.
This is a representation of strictly increasing functions such that  is strictly associative, as observed in~\cite{nicolai:thesis}.
Unsurprisingly, this is enough to make  a \emph{category} in the sense that we will define later (see Definition~\ref{def:strictcat}).\footnote{Note that, for technical reasons, we include the initial object . This explains the shift by : we have defined  instead of .}


In the following, we use variable names ,  instead of ,  to indicate that we have an element of a nested -type, i.e.\ a tuple.
With  at hand, we define truncated semi-simplicial types () simultaneously with skeletons () and the morphism part of skeletons (written ).
These have the following types:

These type families can be explained as follows:
\begin{enumerate}
 \item  is the type of -truncated semi-simplicial types.
 \item Assume we have a -truncated semi-simplicial type , where  is smaller than another given number .\footnote{The definition works for , but  is the case that is important for the intuition.} 
 allows us to form the type .
This is the type of ``partial boundaries'' of an -truncated semi-simplicial type.
Intuitively, it has  points,  lines, \ldots, and  cells on level .
 \item We think of  as a ``functor'' from  to . 
Its morphism component is given by : for any , we get a function  which simply ``removes'' those cells that appear in the partial boundary of an -simplex, but not in the partial boundary of an -simplex.
\end{enumerate}
At the same time as we define ,  and , we prove the following strict functor law for all , , and , :


We define all the components by induction on  as follows.
In the base case, we set
; ; ; and .
In the successor case, we choose

Note that, in the last line, the type of the term  is .
However, what we need at that point is an element of the type .
This is why we transport along the proof , abbreviated to , which shows that the two types are strictly equal.

We omit the term for  as it is not insightful to write it down explicitly.
It is constructed as follows.
First, we note that we need a (strict) equality between pairs; the first components are (strictly) equal by .
When one tries to prove that the second components are (strictly) equal, one quickly realizes that what is needed is coherence for the family of strict equalities :
The composition  can be shown to be (strictly) equal to  in two ways, and we need that both ways are strictly equal.
Of course, this follows from the fact that we have axiom  for our strict equality.
We have verified this construction in Agda (see the remark below). 

\begin{remark}
 We and many others have attempted to formalize semi-simplicial types in homotopy type theory with exactly the outlined strategy, replacing the strict law  by the usual equality type.
 This works in the same way until the point where we need that  is coherent, which is automatic in our case.
 Intuitively,  \emph{is} coherent, and it is easy to get trapped into thinking that this coherence can just be shown simultaneously with the other four components.
 However, if one does this, one notices that one needs an additional coherence level for ,
 and it continues like this.
 Morally, all these coherences should hold, and it is very likely that we would actually be able to prove them inductively if only we were able to write them down.
 Unfortunately, writing them down is a problem that is very similar to defining semi-simplicial types itself.
 From this point of view, what the -level theory gives us is the possibility to prove a certain equality and \emph{all} its higher coherences at the same time. 
\end{remark}
\begin{remark}
 We have now defined the -truncated semi-simplicial types , so we may ask whether we can define a (non-truncated) type of semi-simplicial types .
 If we work in the strong 2-level theory (where  and  coincide), 
 we can consider the homotopy limit , defined as
  
 Then,  is indeed a (fibrant) type that encodes (Reedy fibrant) functors .
\end{remark}
\begin{remark}
 Our Agda formalisation\footnote{\href{https://github.com/nicolaikraus/HoTT-Agda/blob/master/nicolai/SemiSimp/SStypes.agda}{\nolinkurl{github.com/nicolaikraus/HoTT-Agda/tree/master/nicolai/SemiSimp}}} takes place within the fibrant theory. 
 The contribution of the strict equality is completely encapsulated in a single lemma that we postulate without a formal proof.
 Unfortunately, simulating our 2-level system completely in Agda, although possible in principle, would be extremely cumbersome because of the need to keep track of type fibrancy manually. 
\end{remark}


\section{Reedy Fibrant Diagrams Over Inverse Categories} \label{sec:diag-inverse}

In Section~\ref{sec:semisimp}, we have defined Reedy fibrant truncated semi-simplicial types using our 2-level theory.
We have stayed in the fibrant theory () as much as we could, and only used the strict theory to prove a crucially needed coherence. 
In this section we want to demonstrate that the 2-level theory is even more powerful if we give up this strategy of only working in the fibrant fragment whenever possible.
The point is that we can derive results about  without staying inside , 
analogous to how one can get results that respect homotopy equivalence even when certain constructions are performed on concrete spaces that only represent homotopy types.

What we claim is that, in a proof assistant implementing a 2-level type theory, we could formalize many constructions that are presented meta-theoretically in the current literature.
In the current section, we will show that Reedy fibrant diagrams  have limits in  if  is a finite inverse category. This is an internalised version of results discussed by Shulman~\cite{shulman_inversediagrams}.
Of course it generalizes the construction in Section~\ref{sec:semisimp}, although not ``literally'': the truncated semi-simplicial types that we get here will look different from those constructed above.

\subsection{Essentially Fibrant Pretypes and Strict Fibrations}

As a preparation for our ``more abstract'' sample applications of the 2-level theory, we remark that it is often not necessary to know that a pretype  is a fibrant type. 
Instead, it is usually sufficient to have a fibrant type  and a strict isomorphism . 
If this is the case, we say that  is \emph{essentially fibrant}. Clearly, every fibrant type is also an essentially fibrant pretype.

In Section~\ref{sec:semisimp}, we have made heavy use of the fibrant finite types  (for ).
In a strong 2-level theory, this type coincides with the strict pretype  (for ), but this is not in general the case.
We say that some pretype  is \emph{essentially finite} if we have a number  and a strict isomorphism .
\begin{lemma}
 Let  be essentially finite and  be a family of fibrant types. Then,  is essentially fibrant.
\end{lemma}
\begin{proof}
 Essential finiteness gives us a cardinality  on which we do induction. If  is , then  is strictly isomorphic to the unit type. 
 Otherwise, we have an essentially finite  such that , and  is strictly isomorphic to
,
 which is essentially finite by the induction hypothesis.
\end{proof}


Similar to essential fibrancy, we have the following definition:

\begin{definition}[strict fibration]
Let  be a function (with ).  
We say that  is a \emph{strict fibration} if we have a family  such that
the fibre of  over any  is strictly isomorphic to , that is,
. 
\end{definition}

From now on, we will drop the attribute \emph{strict} and simply talk about \emph{fibrations}.
Any fibrant type family  gives rise to a fibration , 
as it is easy to see that the first projection  satisfies the given condition.
Indeed, any strict fibration is isomorphic over  to a strict fibration of this form.
This often allows us to assume that a given fibration has the form of a projection.


\subsection{Strict Categories}

We define categories in much the same way as the precategories are defined in~\cite{HoTTbook}, except that we
use strict equality to express the laws. 
Since strict equality does not suffer from coherence issues, this notion of category is well-behaved. 
It can be applied to structures which do not have fibrant types of objects or morphisms.

\renewcommand{\C}{\mathcal C}
\let\seq\steq 
\newcommand{\obj}[1]{\vert #1 \vert}

\begin{definition}[strict category] \label{def:strictcat}
A \emph{strict category}  is given by: a pretype  of \emph{objects};
for all pairs , a pretype  of \emph{arrows}
or \emph{morphisms};
an \emph{identity} arrow 
 for every object ; and a \emph{composition} function
 for all objects .
The usual categorical laws are required to hold strictly, that is, 
we have strict equalities  and , as well as .

We say that a category is \emph{essentially finite} if the pretype of objects  is essentially finite (no condition is put on the arrows).
\end{definition}

The usual theory of categories can be reproduced in the context of strict
categories.  We leave it to the reader to define appropriate notions of \emph{functor},
\emph{natural transformation}, \emph{limits}, \emph{adjunctions}, and so on.

From now on, we will refer to strict categories simply as \emph{categories}. If
 is a category, we will often abuse notation and use  itself to denote
its type of objects.

Another important notion is the following:
\begin{definition}[reduced coslice]
Given a category  and an object , the \emph{reduced coslice}
 is the full subcategory of non-identity arrows in the coslice
category . 
A concrete definition is the following.
The objects of  are triples 
of an , a morphism , and a proof , for all ,
where  denotes the  function .
Morphisms between  and  are elements  such that  in .

Note that we have a ``forgetful functor'' , given by the first projection on objects as well as on morphisms.
\end{definition}


\subsection{Inverse Categories}


Classically, \emph{inverse categories} are categories which do not contain an infinite sequence of nonidentity arrows (see~\cite{shulman_inversediagrams}).
We restrict ourselves to those which have \emph{height} at most , and where a \emph{rank function} is given explicitly.
First, consider the category  which has  as objects, and  (the function  is defined in the canonical way).
Then, we define:
\begin{definition}[inverse category]
 We say that a category  is an \emph{inverse category}
 if there is a functor  which reflects identities; i.e.\ if we have  and , then we also have  and .
\end{definition}


\subsection{Reedy Fibrant Limits}

Much of what is known about the category of sets in classical category theory
can be extended to the category of pretypes in a given universe. 
For example, the following result translates rather directly:

\begin{lemma} \label{lem:all-strict-limits}
The universe , viewed as a category in the canonical sense, has all small limits.
\end{lemma}
\begin{proof}
Let  be a category with  and  (for all ).
Let  be a
functor. 
We define  to be the pretype of natural transformations , where 
 is the constant functor on .  
Clearly, , and
a routine verification shows that  satisfies the universal property of the
limit of .
\end{proof}

Unfortunately, the category  of fibrant types is not as well behaved.  
Even pullbacks of fibrant types are not fibrant in general (but see Lemma~\ref{prop:fibrant-pullback}). 
If we have a functor , we can always regard it as a functor , where it does have a limit.
If this limit happens to be essentially fibrant, we say that  has a \emph{fibrant limit}.
Clearly, this limit will then be a limit of the original diagram  (note that  is a full subcategory of ).

\begin{lemma}\label{prop:fibrant-pullback}
The pullback of a fibration  along any function  is a fibration.
\end{lemma}
\begin{proof}
We can assume that  is of the form  and  is the first projection.
Clearly, the first projection of 
satisfies the universal property of the pullback.
\end{proof}

Lemma \ref{prop:fibrant-pullback} makes it possible to construct fibrant limits of
certain ``well-behaved'' functors from inverse categories.
The so-called \emph{matching objects} play an important role.
\begin{definition}[matching object; see {\cite[Chp.~11]{shulman_inversediagrams}}]
Let  be an inverse category, and  a functor. 
For any , we define the \emph{matching object}  to be the (not necessarily fibrant) limit of
the composition
.
\end{definition}


\begin{definition}[Reedy fibrant diagram; see {\cite[Def. 11.3]{shulman_inversediagrams}}]
 Let  be an inverse category and  be a functor.
 We say that  is \emph{Reedy fibrant} if, for all , the canonical map  is a fibration.
\end{definition}



Using this definition, we can make precise the claim that we can construct fibrant limits of certain well-behaved diagrams:
\begin{theorem}[see {\cite[Lemma 11.8]{shulman_inversediagrams}}] \label{thm:fibrant-limits}
Let  be an essentially finite inverse category. 
Then, every Reedy fibrant  has a fibrant limit.
\end{theorem}
\begin{proof}
By induction on the cardinality of . In the zero case, the limit is the unit type.

 Otherwise, let us consider the rank functor .
 We choose an object  such that  is maximal; this is possible (constructively) since  is assumed to be essentially finite.
 Let us call  the category that we get if we remove  from ; 
 that is, we set .
 Clearly,  is still essentially finite and inverse.
 
 Let  be Reedy fibrant. 
 We can write down the limit of  
 explicitly as
 
 Using that  has no incoming non-identity arrows, this pretype is strictly isomorphic to
 

 
 Let us write  for the limit of  restricted to ,
 and let us further write  for the canonical map . 
 Further, we write  for the map .
 Then, \eqref{eq:limit-2} is strictly isomorphic to
 
 This is the pullback of the span .
 By Reedy fibrancy of , the map  is a fibration. 
 Thus, by Lemma~\ref{prop:fibrant-pullback}, the map from \eqref{eq:limit-3} to  is a fibration.

 By the induction hypothesis,  is essentially fibrant.
 This implies that \eqref{eq:limit-3} is essentially fibrant, as it is the domain of a fibration whose codomain is essentially fibrant.
\end{proof}

If  is an inverse category, we will denote by  the full subcategory
of  consisting of all those objects of rank less than .  Correspondingly,
for a given diagram  over , we will denote by  the restriction of
 to .

\newcommand{\tdeltop}[1]{\left(\op{\Delta_+}\right)^{<#1}}

\subsection{Fibrant Limits and Semi-Simplicial Types}

If  is a Reedy fibrant diagram over , we can restrict  to , then take the limit of the corresponding functor.  With a slight
abuse of notation, we will denote such limit by , even though  is not
defined at .

Note that a diagram  over  is Reedy fibrant if and only if its
restriction to  is Reedy fibrant and the map  is a
fibration.  Hence, to give a Reedy fibrant diagram over  is the
same as to give a Reedy fibrant diagram  over , together with a
fibration  over .  We will refer to this extended diagram as .
By mutual induction on the natural number , we can define a type ,
and a function  from  to diagrams over .  We start
with with  and  set to the trivial diagram
over .
Then, we set

Above, we write  to mean the type given by Theorem
\ref{thm:fibrant-limits} which is strictly isomorphic to the matching object of
 at  (which would otherwise only be a pretype).

This gives us a succinct alternative to the construction of Section
\ref{sec:semisimp}, where most of the hard work is encapsulated in the use of
Theorem \ref{thm:fibrant-limits}.



\section{Conclusions and Further Work} \label{sec:conclusions}

In the previous two sections, we have demonstrated how our 2-level theories can be used in two ways. 
First, our framework offers reasonable, easily justifiable ways of extending homotopy type theory.
Second, we can internalise results about homotopy type theory that, before, could only be stated meta-theoretically. 
In a suitable proof assistant which implements a 2-level theory, we could formalize many constructions that can at the moment only be done on paper. 
Our current article offers a demonstration of this possibility: we have shown
how some of the constructions about fibrant limits and diagrams can be
internalised.
From here, we could go into several directions.
We could, for example, internalise Shulman's result that diagrams over a model of type theory form again a model, preserving univalence~\cite{shulman_inversediagrams}.
Of course, for such an internalisation, we need to be careful to formulate all definitions and results constructively.

A more modest but (as we believe) worthwhile next goal is the construction of fibrant replacements.
With this, we can internalise the proof that any type carries the structure of an -groupoid (a Kan semi-simplicial type), as it is given in~\cite[Remark and Corollary 16]{kraus_generaluniversalproperty}.
To do this, we would first define an -groupoid to be a Reedy fibrant semi-simplicial type  such that every fibration from  to a horn is an equivalence (in the sense of homotopy type theory).
We can then, for a type , consider the semi-simplicial type , defined to be the Reedy fibrant replacement of the functor that is constantly .
It is shown in~\cite{kraus_generaluniversalproperty} that  is an -groupoid in our sense, and the argument can easily be internalised. 
This construction is in fact not difficult and has in the current paper been omitted solely for reasons of space.

Our next significant project, supported by the 2-level theory, 
is the development of -category theory.
By an -category, which could also be called a \emph{Segal type}, we mean a Reedy fibrant semi-simplicial type  for which the usual ``Segal maps''  are equivalences.
It is likely that it is necessary to add degeneracies, and we expect that this can be done in the way presented by Harpaz~\cite{harpaz2015quasi}.

We believe that it is important to develop a theory of -categories
type-theoretically, because the universe itself should be an
-category; we expect that many infinite coherence problems become
approachable if we can set up some basic infrastructure, so that towers of
coherences could be formulated and handled in a clean way.

The most important application that we currently have in mind is the specification of \emph{higher inductive types} (HITs).
Although HITs are used frequently in the literature on homotopy type theory, we do not have a general syntactical specification yet.
The approach to define a general syntactical framework of HITs that is used in~\cite{gabe_HITs} seems to be promising, 
but suffers from the issue that an unmanageable number of coherences
needs to be handled manually.
We expect and hope that this can be resolved with the framework of -categories that we plan to develop.

\bibliographystyle{alpha}
\bibliography{master}


\end{document}
