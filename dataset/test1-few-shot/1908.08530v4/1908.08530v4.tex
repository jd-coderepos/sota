
\documentclass{article} \usepackage{iclr2020_conference,times}

\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}


\usepackage{comment}
\usepackage[british,UKenglish,USenglish,american]{babel}
\usepackage{multirow}

\usepackage{makecell}
\usepackage{subfigure}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{hyperref}
\usepackage{url}


\allowdisplaybreaks[4]

\title{VL-BERT: Pre-training of Generic Visual-Linguistic Representations}

\iclrfinalcopy

\author{Weijie Su, Xizhou Zhu\thanks{Equal contribution. This work is done when Weijie Su and Xizhou Zhu are interns at Microsoft Research Asia.}~~, Yue Cao, Bin Li, Lewei Lu, Furu Wei, Jifeng Dai  \\
University of Science and Technology of China
\\
Microsoft Research Asia \\
\texttt{\{jackroos,ezra0408\}@mail.ustc.edu.cn}, \texttt{binli@ustc.edu.cn} \\
\texttt{\{yuecao,lewlu,fuwei,jifdai\}@microsoft.com} \\
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}


\begin{document}


\maketitle

\begin{abstract}
We introduce a new pre-trainable generic representation for visual-linguistic tasks, called Visual-Linguistic BERT (VL-BERT for short). VL-BERT adopts the simple yet powerful Transformer model as the backbone, and extends it to take both visual and linguistic embedded features as input. In it, each element of the input is either of a word from the input sentence, or a region-of-interest (RoI) from the input image. It is designed to fit for most of the visual-linguistic downstream tasks. To better exploit the generic representation, we pre-train VL-BERT on the massive-scale Conceptual Captions dataset, together with text-only corpus. Extensive empirical analysis demonstrates that the pre-training procedure can better align the visual-linguistic clues and benefit the downstream tasks, such as visual commonsense reasoning, visual question answering and referring expression comprehension. 
It is worth noting that VL-BERT achieved the first place of single model on the leaderboard of the VCR benchmark. 
Code is released at \url{https://github.com/jackroos/VL-BERT}.
\end{abstract}


\section{Introduction}
Pre-training of generic feature representations applicable to a variety of tasks in a domain is a hallmark of the success of deep networks. Firstly in computer vision, backbone networks
designed for and pre-trained on ImageNet~\citep{deng2009imagenet} classification are found to be effective for improving numerous image recognition tasks. Recently in natural language processing (NLP), Transformer networks~\citep{vaswani2017transformer} pre-trained with ``masked language model" (MLM) objective~\citep{devlin2018bert} on large language corpus excel at a variety of NLP tasks.


Meanwhile, for tasks at the intersection of vision and language, such as image captioning~\citep{young2014image,chen2015microsoft,sharma2018conceptual}, visual question answering (VQA)~\citep{antol2015vqa,johnson2017clevr,goyal2017making,hudson2019gqa}, visual commonsense reasoning (VCR)~\citep{zellers2019vcr,gao2019two}, there lacks such pre-trained generic feature representations. The previous practice is to combine base networks pre-trained for image recognition and NLP respectively in a task-specific way. The task-specific model is directly finetuned for the specific target task, without any generic visual-linguistic pre-training. The task-specific model may well suffer from overfitting when the data for the target task is scarce. Also, due to the task-specific model design, it is difficult to benefit from pre-training, where the pre-training task may well be different from the target. There lacks a common ground for studying the feature design and pre-training of visual-linguistic tasks in general.


In the various network architectures designed for different visual-linguistic tasks, a key goal is to effectively aggregate the multi-modal information in both the visual and linguistic domains. For example, to pick the right answer in the VQA task, the network should empower integrating linguistic information from the question and the answers, and aggregating visual information from the input image, together with aligning the linguistic meanings with the visual clues. Thus, we seek to derive generic representations that can effectively aggregate and align visual and linguistic information.


In the meantime, we see the successful application of Transformer attention~\citep{vaswani2017transformer} in NLP, together with its MLM-based pre-training  technique in BERT~\citep{devlin2018bert}. The attention module is powerful and flexible in aggregating and aligning word embedded features in sentences, while the pre-training in BERT further enhances the capability.


Inspired by that, we developed VL-BERT, a pre-trainable generic representation for visual-linguistic tasks, as shown in Figure~\ref{fig.pretrain_arch}. The backbone of VL-BERT is of (multi-modal) Transformer attention module taking both visual and linguistic embedded features as input. In it, each element is either of a word from the input sentence, or a region-of-interest (RoI) from the input image, together with certain special elements to disambiguate different input formats. Each element can adaptively aggregate information from all the other elements according to the compatibility defined on their contents, positions, categories, and etc. The content features of a word / an RoI are domain specific (WordPiece embeddings~\citep{wu2016google} as word features, Fast R-CNN~\citep{girshick2015fast} features for RoIs). By stacking multiple layers of multi-modal Transformer attention modules, the derived representation is of rich capability in aggregating and aligning visual-linguistic clues. And task-specific branches can be added above for specific visual-linguistic tasks.


To better exploit the generic representation, we pre-train VL-BERT at both large visual-linguistic corpus and text-only datasets\footnote{Here we exploit the Conceptual Captions dataset~\citep{sharma2018conceptual} as the visual-linguistic corpus, and the BooksCorpus~\citep{zhu2015aligning} \& English Wikipedia as the text-only corpus.}. The pre-training loss on the visual-linguistic corpus is incurred via predicting randomly masked words or RoIs. Such pre-training sharpens the capability of VL-BERT in aggregating and aligning visual-linguistic clues. While the loss on the text-only corpus is of the standard MLM loss in BERT, improving the generalization on long and complex sentences. 



Comprehensive empirical evidence demonstrates that the proposed VL-BERT achieves state-of-the-art performance on various downstream visual-linguistic tasks, such as visual commonsense reasoning, visual question answering and referring expression comprehension. In particular, we achieved the first place of single model on the leaderboard of visual commonsense reasoning. 
 \section{Related Work}

\textbf{Pre-training for Computer Vision} Prior to the era of deep networks, it is far from mature to share features among different tasks and to improve the features via pre-training. The models for various computer vision tasks are of too diverse design choices to derive a generic representation. With the success of AlexNet~\citep{krizhevsky2012alexnet} in ImageNet~\citep{deng2009imagenet} classification, we see the renaissance of convolutional neural networks (CNNs) in the vision community. Soon after that, researchers found that ImageNet pre-trained CNNs can serve well as generic feature representation for various downstream tasks \citep{donahue2014decaf}, such as object detection~\citep{girshick2014rich}, semantic segmentation~\citep{long2015fcn}, instance segmentation~\citep{hariharan2014simultaneous}. The improvement in backbone networks for ImageNet classification further improves the downstream tasks. Recently there are research works on directly training CNNs from scratch on massive-scale target datasets, without ImageNet pre-training~\citep{he2018rethinking}. They achieved performance on par with those with ImageNet pre-training. While they also note that pre-training on a proper massive dataset is vital for improving performance on target tasks with scarce data.  



\textbf{Pre-training for Natural Language Processing (NLP)} It is interesting to note that the development of pre-training techniques in NLP lags quite behind computer vision. There are previous research works on improving word embedding~\citep{mikolov2013efficient,pennington2014glove,kiros2015skip}, which is a low-level linguistic feature representation. On top of that, numerous diverse architectures are designed for various NLP tasks. In the milestone work of Transformers~\citep{vaswani2017transformer}, the Transformer attention module is proposed as a generic building block for various NLP tasks. After that, a serious of approaches are proposed for pre-training the generic representation, mainly based on Transformers, such as GPT~\citep{radford2018GPT}, BERT~\citep{devlin2018bert}, GPT-2~\citep{radford2019GPT-2}, XLNet~\citep{yang2019xlnet}, XLM~\citep{lample2019xlm}, and RoBERTa~\citep{liu2019roberta}. Among them, BERT is perhaps the most popular one due to its simplicity and superior performance.





\textbf{Pre-training for Visual-Linguistic Tasks.} The development course of models for visual-linguistic tasks is also quite similar to those in the computer vision and NLP communities. Previously, task-specific models are designed, wherein the features derived from off-the-shelf computer vision and NLP models are combined in an ad-hoc way for specific tasks. Model training is performed on the dataset for the specific task only. 


VideoBERT~\citep{sun2019videobert} is the first work seeking to conduct pre-training for visual-linguistic tasks. In it, video clips are processed by off-the-shelf networks for action recognition, and are assigned to different clusters (visual words) based on the derived features. The pre-training loss is incurred via predicting the cluster ids of masked video clips. Due to the abrupt clustering of the video clips, it losses considerable visual content information and hinders updating visual network parameters. In the following work of CBT~\citep{sun2019contrastive}, such clustering mechanism is removed. Both works are applied on videos, which are of linear structure in the time dimension, same as sentences. It is highly desired to study at the well-established image-based visual-linguistic tasks.



Concurrent to our work, multiple works released on Arxiv very recently also seek to derive a pre-trainable generic representation for visual-linguistic tasks. Table~\ref{table:concurrent_works} in Appendix compares among them. We briefly discuss some of these works here. 


In ViLBERT~\citep{lu2019vilbert} and LXMERT~\citep{tan2019lxmert}, which are under review or just got accepted, the network architectures are of two single-modal networks applied on input sentences and images respectively, followed by a cross-modal Transformer combining information from the two sources. The attention pattern in the cross-modal Transformer is restricted, where the authors believe to improve the performance. The authors of ViLBERT claim that such two-stream design is superior than a single-stream unified model. Meanwhile, in the proposed VL-BERT, it is of a unified architecture based on Transformers without any restriction on the attention patterns. The visual and linguistic contents are fed as input to VL-BERT, wherein they interact early and freely. We found that our unified model of VL-BERT outperforms such two-stream designs. 


VisualBert~\citep{li2019visualbert}, B2T2~\citep{alberti2019fusion}, and Unicoder-VL~\citep{li2019unicodervl}, which are of work in progress or under review, are also of unified single-stream architecture. The differences of these works are compared in Table~\ref{table:concurrent_works}. The concurrent emergency of these research works indicates the importance of deriving a generic pre-trainable representation for visual-linguistic tasks.

In addition, there are three noticeable differences between VL-BERT and other concurrent works in pre-training. Their effects are validated in Section~\ref{sec:ablation}. (1) We found the task of Sentence-Image Relationship Prediction used in all of the other concurrent works (e.g., ViLBERT~\citep{lu2019vilbert} and LXMERT~\citep{tan2019lxmert}) is of no help in pre-training visual-linguistic representations. Thus such a task is not incorporated in VL-BERT. (2) We pre-train VL-BERT on both visual-linguistic and text-only datasets. We found such joint pre-training improves the generalization over long and complex sentences. (3) Improved tuning of the visual representation. In VL-BERT, the parameters of Fast R-CNN, deriving the visual features, are also updated. To avoid visual clue leakage in the pre-training task of Masked RoI Classification with Linguistic Clues, the masking operation is conducted on the input raw pixels, other than the feature maps produced by layers of convolution.

 \section{VL-BERT}
\subsection{Revisit BERT Model}


Let  be the input elements in BERT~\citep{devlin2018bert}, which are of embedded features encoding sentence words. They are processed by a multi-layer bidirectional Transformer~\citep{vaswani2017transformer}, where the embedding features of each element are transformed layer-by-layer in the fashion of aggregating features from the other elements with adaptive attention weights. Let  be the features of the -th layer ( is set as the input ). The features of the -th layer, , is computed by

where  in Eq.~\ref{eq:multi_head}  indexes over the attention heads, and  denotes the attention weights between elements  and  in the -th head, which is normalized by . , ,  and  are learnable weights for  attention head,  and  in Eq.~\ref{eq:feedfoward} are learnable weights and biases, respectively. Note that, the operations in Eq.~\ref{eq:multi_head}~~\ref{eq:ffn} is irrelevant to the order of input sequence, i.e. the final BERT representation of permuted input is same as the final BERT representation of the original input after the same permutation. The position of an element in BERT is encoded in its own embedding features by sequence positional embedding. Thanks to such decoupled representation, the BERT model is flexible enough to be pre-trained and finetuned for a variety of NLP tasks.


In BERT pre-training, the masked language modeling (MLM) task is introduced. The embedded features of a certain input word would be randomly masked out (the token embedding channels capturing the word content is replaced by a special [MASK] token). The BERT model is trained to predict the masked word from linguistic clues of all the other unmasked elements. As explained in \cite{wang2019bertmrf}, the overall MLM-based training of BERT is equivalent to optimizing the following joint probability distribution

where  is the potential function for the -th input element, with parameters , and  is the partition function. Each log-potential term  is defined as

where  denotes the final output feature of BERT corresponding to the -th element for input , where  is defined as . The incurred MLM-based loss is as

where  is a randomly sampled sentence from the training set , and  is a randomly sampled location for masking words. 


The second pre-training task, Next Sentence Prediction, focuses on modeling the relationship between two sentences. Two sentences are sampled from the input document, and the model should predict whether the second sentence is the direct successor of the first. In BERT, the sampled two sentences are concatenated into one input sequence, with special elements [CLS] and [SEP] inserted prior to the first and the second sentences, respectively. 
A Sigmoid classifier is appended on the final output feature corresponding to the [CLS] element to make the prediction. Let  be the input sequence,  indicates the relationship between the two sentences. The loss function is defined as

where  is the final output feature of the [CLS] element (at the -th layer), and  is the classifier output. 


\subsection{Model Architecture}

\begin{figure*}
\begin{center}
        \includegraphics[width=1.0\linewidth]{fig/pretrain.pdf}
\end{center}
\vspace{-0.5em}
\caption{Architecture for pre-training VL-BERT. All the parameters in this architecture including VL-BERT and Fast R-CNN are jointly trained in both pre-training and fine-tuning phases.}
\vspace{-0.5em}
\label{fig.pretrain_arch}
\end{figure*}

Figure~\ref{fig.pretrain_arch} illustrates the architecture of VL-BERT. Basically, it modifies the original BERT~\citep{devlin2018bert} model by adding new elements to accommodate the visual contents, and a new type of visual feature embedding to the input feature embeddings. Similar to BERT, the backbone is of multi-layer bidirectional Transformer encoder~\citep{vaswani2017transformer}, enabling dependency modeling among all the input elements. Different to BERT processing sentence words only, VL-BERT takes both visual and linguistic elements as input, which are of features defined on regions-of-interest (RoIs) in images and sub-words from input sentences, respectively. The RoIs can either be bounding boxes produced by object detectors, or be annotated ones in certain tasks.

It is worth noting that the input formats vary for different visual-linguistic tasks (e.g., Caption, Image for image captioning, and Question, Answer, Image for VQA~\citep{antol2015vqa,johnson2017clevr,goyal2017making,hudson2019gqa} and VCR~\citep{zellers2019vcr,gao2019two}). But thanks to the unordered representation nature of Transformer attention (e.g., the position of a word in sentence is encoded by the positional embedding only, other than the order in the input sequence), a generic representation can be derived as long as the input elements and embedding features are properly designed. Three types of input elements are involved, namely, visual, linguistic, and special elements for disambiguating different input formats. The input sequence always starts with a special classification element ([CLS]), then goes on with linguistic elements, then follows up with visual elements, and ends with a special ending element ([END]). A special separation element ([SEP]) is inserted in between different sentences in the linguistic elements, and between the linguistic and visual elements. For each input element, its embedding feature is the summation of four types of embedding, namely, token embedding, visual feature embedding, segment embedding, and sequence position embedding. Among them, the visual feature embedding is newly introduced for capturing visual clues, while the other three embeddings follow the design in the original BERT paper.



\textbf{Token Embedding} Following the practice in BERT, the linguistic words are embedded with WordPiece embeddings~\citep{wu2016google} with a 30,000 vocabulary. A special token is assigned to each special element. For the visual elements, a special [IMG] token is assigned for each one of them.


\textbf{Visual Feature Embedding} We firstly describe visual appearance feature and visual geometry embedding separately, and then how to combine them to form the visual feature embedding. 

For the visual element corresponding to an RoI, the visual appearance feature is extracted by applying a Fast R-CNN~\citep{girshick2015fast} detector (i.e., the detection branch in Faster R-CNN~\citep{ren2015faster}), where the feature vector prior to the output layer of each RoI is utilized as the visual feature embedding (of 2048-d in paper). For the non-visual elements, the corresponding visual appearance features are of features extracted on the whole input image. They are obtained by applying Faster R-CNN on an RoI covering the whole input image. 

The visual geometry embedding is designed to inform VL-BERT the geometry location of each input visual element in image. Each RoI is characterized by a 4-d vector, as , where  and  denote the coordinate of the top-left and bottom-right corner respectively, and  are of the width and height of the input image. Following the practice in Relation Networks~\citep{hu2018relation}, the 4-d vector is embedded into a high-dimensional representation (of 2048-d in paper) by computing sine and cosine functions of different wavelengths.

The visual feature embedding is attached to each of the input elements, which is the output of a fully connected layer taking the concatenation of visual appearance feature and visual geometry embedding as input.


\textbf{Segment Embedding} Three types of segment, , are defined to separate input elements from different sources, namely,  and  for the words from the first and second input sentence respectively, and  for the RoIs from the input image. For example, for input format of Question, Answer, Image,  denotes Question,  denotes Answer, and  denotes Image. For input format of Caption, Image,  denotes Caption, and  denotes Image. A learned segment embedding is added to every input element for indicating which segment it belongs to.


\textbf{Sequence Position Embedding~} A learnable sequence position embedding is added to every input element indicating its order in the input sequence, same as BERT. Because there is no natural order among input visual elements, any permutation of them in the input sequence should achieve the same result. Thus the sequence position embedding for all visual elements are the same. 


\subsection{Pre-training VL-BERT}
\label{sec:pre_training_tasks}


The generic feature representation of VL-BERT enables us to pre-train it on massive-scale datasets, with properly designed pre-training tasks. We pre-train VL-BERT on both visual-linguistic and text-only datasets. Here we utilize the Conceptual Captions dataset~\citep{sharma2018conceptual} as the visual-linguistic corpus. It contains around 3.3 million images annotated with captions, which are harvested from web data and processed through an automatic pipeline. The issue with the Conceptual Captions dataset is that the captions are mainly simple clauses, which are too short and simple for many down-stream tasks. To avoid overfitting on such short and simple text scenario, we also pre-train VL-BERT on text-only corpus with long and complex sentences. We utilize the BooksCorpus~\citep{zhu2015aligning} and the English Wikipedia datasets, which are also utilized in pre-training BERT.


In SGD training, in each mini-batch, samples are randomly drawn from both Conceptual Captions and BooksCorpus \& English Wikipedia (at a ratio of 1:1). For a sample drawn from Conceptual Captions, the input format to VL-BERT is of Caption, Image, where the RoIs in the image are localized and categorized by a pre-trained Faster R-CNN object detector. Two pre-training tasks are exploited to incur loss, which are as follows.

\emph{Task \#1 Masked Language Modeling with Visual Clues} This task is very similar to the Masked Language Modeling (MLM) task utilized in BERT. The key difference is that visual clues are incorporated in VL-BERT for capturing the dependencies among visual and linguistic contents. During pre-training, each word in the input sentence(s) is randomly masked (at a probability of 15\%). For the masked word, its token is replaced with a special token of [MASK]. The model is trained to predict the masked words, based on the unmasked words and the visual features. The task drives the network to not only model the dependencies in sentence words, but also to align the visual and linguistic contents. For example, in Figure~\ref{fig.pretrain_arch} ``kitten drinking from [MASK]'', without the input image, the masked word could be any containers, such as ``bowl'', ``spoon'' and ``bottle''. The representation should capture the correspondence of the word ``bottle" and the corresponding RoIs in the image to make the right guess. During pre-training, the final output feature corresponding to the masked word is fed into a classifier over the whole vocabulary, driven by Softmax cross-entropy loss.


\emph{Task \#2 Masked RoI Classification with Linguistic Clues} This is a dual task of Task \#1. Each RoI in image is randomly masked out (with 15\% probability), and the pre-training task is to predict the category label of the masked RoI from the other clues. 
To avoid any visual clue leakage from the visual feature embedding of other elements, the pixels laid in the masked RoI are set as zeros before applying Fast R-CNN. During pre-training, the final output feature corresponding to the masked RoI is fed into a classifier with Softmax cross-entropy loss for object category classification. The category label predicted by pre-trained Faster R-CNN is set as the ground-truth. An example is shown in Figure~\ref{fig.pretrain_arch}. The RoI corresponding to cat in image is masked out, and the corresponding category cannot be predicted from any visual clues. But with the input caption of ``kitten drinking from bottle", the model can infer the category by exploiting the linguistic clues.



For a sample drawn from the BooksCorpus \& English Wikipedia datasets, the input format to VL-BERT degenerates to be Text, , where no visual information is involved. The ``visual feature embedding'' term in Figure~\ref{fig.pretrain_arch} is a learnable embedding shared for all words. The training loss is from the standard task of Masked Language Modeling (MLM) as in BERT.



In summary, the pre-training on visual-linguistic corpus improves the detailed alignment between visual and linguistic contents. Such detailed alignment is vital for many downstream tasks (for example, in Visual Grounding~\citep{kazemzadeh2014referitgame}, the model locates the most relevant object or region in an image based on a natural language query). While the pre-training on text-only corpus facilitates downstream tasks involving understanding of long and complex sentences.





\subsection{Fine-tuning VL-BERT}

VL-BERT is designed to be a generic feature representation for various visual-linguistic tasks. It is relatively simple to finetune VL-BERT for various downstream tasks. We simply need to feed VL-BERT with properly formatted input and output, and finetune all the network parameters end-to-end. For the input, the typical formats of Caption, Image and Question, Answer, Image cover the majority visual-linguistic tasks. VL-BERT also supports more sentences and more images as long as appropriate segment embeddings are introduced to identify different input sources. At the output, typically, the final output feature of the [CLS] element is used for sentence-image-relation level prediction. The final output features of words or RoIs are for word-level or RoI-level prediction. In addition to the input and output format, task-specific loss functions and training strategies also need to be tuned. See Section~\ref{sec:exp_finetune} for the detailed design choices and settings.

 \section{Experiment}

\subsection{Pre-training}

As described in Section~\ref{sec:pre_training_tasks}, we pre-train VL-BERT jointly on Conceptual Captions~\citep{sharma2018conceptual} as visual-linguistic corpus, and BooksCorpus~\citep{zhu2015aligning} \& English Wikipedia as text-only corpus. As VL-BERT is developed via adding new inputs capturing visual information to the original BERT model, we initialize the parameters to be the same as the original BERT described in \citep{devlin2018bert}. VL-BERT and VL-BERT denote models developed from the original BERT and BERT models, respectively. The newly added parameters in VL-BERT are randomly initialized from a Gaussian distribution with mean of 0 and standard deviation of 0.02.  Visual content embedding is produced by Faster R-CNN + ResNet-101, initialized from parameters pre-trained on Visual Genome~\citep{krishna2017visual} for object detection (see BUTD~\citep{anderson2018bottom}).


Prior to pre-training on Conceptual Captions, the pre-trained Faster R-CNN is applied to extract RoIs. Specifically, at most 100 RoIs with detection scores higher than 0.5 are selected for each image. At minimum, 10 RoIs are selected from one image, regardless of the detection score threshold. The detailed parameter settings are in Appendix.



\subsection{Fine-tuning on Downstream Tasks}\label{sec:exp_finetune}

\begin{figure*}[ht]
\centering 
\subfigure[Input and output format for Visual Commonsense Reasoning (VCR) dataset]{ 
    \includegraphics[width=0.8\linewidth]{fig/vcr_paradigm.pdf}}
\subfigure[Input and output format for Visual Question Answering (VQA) dataset]{ 
    \includegraphics[width=0.8\linewidth]{fig/vqa_paradigm.pdf}}
\subfigure[Input and output format for Referring Expression task on RefCOCO+ dataset]{ 
    \includegraphics[width=0.8\linewidth]{fig/refcoco_paradigm.pdf}}
\vspace{-0.5em}
\caption{Input and output formats for fine-tuning different visual-linguistic downstream tasks.}
\label{fig:finetune_paradigm}
\end{figure*}

The pre-trained VL-BERT model can be fine-tuned for various downstream visual-linguistic tasks, with simple modifications on the input format, output prediction, loss function and training strategy.

\subsubsection{Visual Commonsense Reasoning (VCR)}

\begin{table}[ht]
\small
    \centering
\begin{tabular}{l|cccccc}
\Xhline{1.0pt}
    \multirow{2}{*}{Model} & \multicolumn{2}{c}{Q  A} & \multicolumn{2}{c}{QA  R} & \multicolumn{2}{c}{Q  AR}\\
     & val & test & val & test & val & test\\
\hline
    R2C~\citep{zellers2019vcr} & 63.8 & 65.1 & 67.2 & 67.3 & 43.1 & 44.0 \\
\hline
    ViLBERT~\citep{lu2019vilbert}  & 72.4 & 73.3 & 74.5 & 74.6 & 54.0 & 54.8 \\
    VisualBERT~\citep{li2019visualbert}   & 70.8 & 71.6 & 73.2 & 73.2 & 52.2 & 52.4\\ 
    B2T2~\citep{alberti2019fusion}   & 71.9 & 72.6 & 76.0 & 75.7 & 54.9 & 55.0 \\
\hline
    VL-BERT w/o pre-training  & 73.1 & - & 73.8  & - & 54.2 & - \\
    VL-BERT  & 73.8 & - & 74.4 & - & 55.2 & - \\
    VL-BERT  & 75.5 & 75.8 & 77.9  & 78.4 & 58.9 & 59.7 \\
\Xhline{1.0pt}
\end{tabular}
\caption{Comparison to the state-of-the-art methods with single model on the VCR dataset. \newline \dag ~indicates concurrent works.}
\label{table:results_VCR}
\end{table}

Visual Commonsense Reasoning (VCR) focuses on higher-order cognitive and commonsense understanding of the given image. In the dataset of \cite{zellers2019vcr}, given an image and a list of categorized RoIs, a question at cognition level is raised. The model should pick the right answer to the question and provide the rationale explanation. For each question, there are 4 candidate answers and 4 candidate rationales. This holistic task (Q  AR) is decomposed into two sub-tasks wherein researchers can train specific individual models: question answering (Q  A) and answer justification (QA  R). The released VCR dataset consists of 265k pairs of questions, answers, and rationales, over 100k unique movie scenes (100k images). They are split into training, validation, and test sets consisting of 213k questions and 80k images, 27k questions and 10k images, and 25k questions and 10k images, respectively.


Our experimental protocol for VCR follows that in R2C~\citep{zellers2019vcr}. The model is trained on the train split, and is evaluated at the val and test sets. In the original work R2C, task-specific ``Grounding'', ``Contextualization'' and ``Reasoning'' modules are designed. Here we simply adopt the generic representation of VL-BERT for the task. Figure~\ref{fig:finetune_paradigm} (a) illustrates the input format, Question, Answer, Image. For the sub-task of Q  A, `Q' and `A' are filled to the Question section and Answer section respectively.  For the sub-task of QA  R , the concatenation of `Q' and `A' is filled to the Question section, and `R' is filled to the Answer section. The input RoIs to VL-BERT are the ground-truth annotations in the dataset. The final output feature of [CLS] element is fed to a Softmax classifier for predicting whether the given Answer is the correct choice. During fine-tuning, we adopt two losses, the classification over the correctness of the answers and the RoI classification with linguistic clues. The detailed parameter settings are in Appendix.




Table~\ref{table:results_VCR} presents the experiment results. Pre-training VL-BERT improves the performance by 1.0\% in the final Q  AR task, which validates the effectiveness of pre-training.
Compared with R2C, we do not use ad-hoc task-specific modules. Instead, we simply adopt the generic representation of VL-BERT and jointly train the whole model end-to-end. Despite the same input, output and experimental protocol as R2C, VL-BERT outperforms R2C by large margins, indicating the power of our simple cross-modal architecture. Compared with other concurrent works, i.e., ViLBERT, VisualBERT and B2T2, our VL-BERT achieves the state-of-the-art performance.  


\subsubsection{Visual Question Answering (VQA)}

\begin{table}[ht]
\small
    \centering
\begin{tabular}{l|cc}
\Xhline{1.0pt}
     Model & test-dev & test-std\\
\hline
    BUTD~\citep{anderson2018bottom} & 65.32 & 65.67 \\
\hline
    ViLBERT~\citep{lu2019vilbert}  & 70.55 & 70.92 \\
    VisualBERT~\citep{li2019visualbert}  & 70.80 & 71.00  \\
    LXMERT~\citep{tan2019lxmert}  & 72.42 & 72.54  \\
\hline
    VL-BERT  w/o pre-training  & 69.58 & - \\
    VL-BERT   & 71.16 & -   \\
    VL-BERT   & 71.79 & 72.22  \\
\Xhline{1.0pt}
\end{tabular}
\caption{Comparison to the state-of-the-art methods with single model on the VQA dataset. \newline \dag ~indicates concurrent works.}
\label{table:results_VQA}
\end{table}

In the VQA task, given a natural image, a question at the perceptual level is asked, and the algorithm should generate / choose the correct answer. Here we conduct experiments on the widely-used VQA v2.0 dataset~\citep{goyal2017making}, which is built based on the COCO~\citep{lin2014microsoft} images. The VQA v2.0 dataset is split into train (83k images and 444k questions), validation (41k images and 214k questions), and test (81k images and 448k questions) sets. Following the experimental protocol in BUTD~\citep{anderson2018bottom}, for each question, the algorithm should pick the corresponding answer from a shared set consisting of 3,129 answers.


Figure~\ref{fig:finetune_paradigm} (b) illustrates the input format for the VQA task, which is of Question, Answer, Image. As the possible answers are from a shared pool independent to the question, we only fill a [MASK] element to the Answer section. As in BUTD~\citep{anderson2018bottom}, the input RoIs in VL-BERT are generated by a Faster R-CNN detector pre-trained on Visual Genome~\citep{krishna2017visual}. The answer prediction is made from a multi-class classifier based upon the output feature of the [MASK] element. During fine-tuning, the network training is driven by the multi-class cross-entropy loss over the possible answers. The detailed parameter settings are in Appendix.



Table~\ref{table:results_VQA} presents our experimental results. Pre-training VL-BERT improves the performance by 1.6\%, which validates the importance of pre-training. VL-BERT shares the same input (i.e., question, image, and RoIs), output and experimental protocol with BUTD, a prevalent model specifically designed for the task. Still, VL-BERT surpasses BUTD by over 5\% in accuracy.  Except for LXMERT, our VL-BERT achieves better performance than the other concurrent works. This is because LXMERT is pre-trained on massive visual question answering data (aggregating almost all the VQA datasets based on COCO and Visual Genome). While our model is only pre-trained on captioning and text-only dataset, where there is still gap with the VQA task.


\subsubsection{Referring Expression Comprehension}

\begin{table}[ht]
\small
    \centering
\begin{tabular}{l|ccc|ccc}
\Xhline{1.0pt}
    \multirow{2}{*}{Model} & \multicolumn{3}{c|}{Ground-truth Regions} & \multicolumn{3}{c}{Detected Regions} \\
    \cline{2-7}
     & val & testA & testB & val & testA & testB\\
\hline
    MAttNet~\citep{yu2018mattnet}  & 71.01 & 75.13 & 66.17 & 65.33 & 71.62 & 56.02 \\
\hline
    ViLBERT~\citep{lu2019vilbert}  & -  & - & - & 72.34 & 78.52 & 62.61 \\
\hline
    VL-BERT w/o pre-training  & 74.41 & 77.28 & 67.52 & 66.03  & 71.87 & 56.13 \\
    VL-BERT  & 79.88 & 82.40 & 75.01 & 71.60 & 77.72 & 60.99 \\
    VL-BERT  & 80.31 & 83.62 & 75.45 & 72.59 & 78.57 & 62.30 \\
\Xhline{1.0pt}
\end{tabular}
\caption{Comparison to the state-of-the-art methods with single model on the RefCOCO+ dataset. \newline \dag ~indicates concurrent work.}
\label{table:results_REF}
\end{table}

A referring expression is a natural language phrase that refers to an object in an image. The referring expression comprehension task is to localize the object in an image with the given referring expression.
We adopt the RefCOCO+~\citep{kazemzadeh2014referitgame} dataset for evaluation, consisting of 141k expressions for 50k referred objects in 20k images in the COCO dataset~\citep{lin2014microsoft}.
The referring expressions in RefCOCO+ are forbidden from using absolute location words, e.g. left dog. Therefore the referring expressions focus on purely appearance-based descriptions. RefCOCO+ are split into four sets, training set (train), validation set (val), and two testing sets (testA and testB). Images containing multiple people are in testA set, while images containing multiple objects of other categories are in testB set. There is no overlap between the training, validation and testing images.


Figure~\ref{fig:finetune_paradigm} (c) illustrates the input format for referring expression comprehension , where the input format is of Query, Image. Model training and evaluation are conducted either on the ground-truth RoIs or on the detected boxes in MAttNet~\citep{yu2018mattnet}. And the results are reported either in the track of ground-truth regions or that of detected regions, respectively. During training, we compute the classification scores for all the input RoIs. For each RoI, a binary classification loss is applied. During inference, we directly choose the RoI with the highest classification score as the referred object of the input referring expression. The detailed parameter settings are in Appendix.


Table~\ref{table:results_REF} presents our experimental results. 
Pre-trained VL-BERT significantly improves the performance. Compared with MAttNet, VL-BERT is much simpler without task-specific architecture designs, yet much better. VL-BERT achieves comparable performance with the concurrent work of ViLBERT.

\subsection{Ablation Study}
\label{sec:ablation}

\setlength{\tabcolsep}{3pt}
\renewcommand{\arraystretch}{1.1}
\begin{table}[ht]
\small
\centering
\resizebox{1.0\linewidth}{!}{
\begin{tabular}{c|ccccc|cc|c|c}
\Xhline{1.0pt}
    \multirow{3}{*}{Settings} & \multirow{3}{*}{\makecell{\footnotesize Masked Language \\\footnotesize Modeling with \\\footnotesize Visual Clues}} & \multirow{3}{*}{\makecell{\footnotesize Masked RoI \\ Classification with \\ \footnotesize Linguistic Clues}} & \multirow{3}{*}{\makecell{\footnotesize Sentence-Image \\ \footnotesize Relationship \\\footnotesize Prediction}} & \multirow{3}{*}{\makecell{\footnotesize with \\ Text-only \\\footnotesize Corpus}} & \multirow{3}{*}{\makecell{\footnotesize Tuning \\ \footnotesize Fast R-CNN}} & \multicolumn{2}{c|}{VCR} & \multicolumn{1}{c|}{\multirow{2}{*}{VQA}} & \multicolumn{1}{c}{\multirow{2}{*}{\makecell{RefCOCO+ \\ \footnotesize Detected Regions}}} \\
         & & & & & & \footnotesize QA & \footnotesize QAR &  &  \\
     & & & & & & val & val & test-dev & val \\
\hline
    \footnotesize w/o pre-training &              &              &              &              &              & 72.9 & 73.0 & 69.5 & 62.7 \\
\hline
        (a) &  &              &              &              &                                 & 72.9 & 73.1 & 71.0 & 69.1\\
        (b) &  &  &              &              &              & 73.0 & 73.1 & 71.1 & 70.7\\
        (c) &  &  &  &              &              & 72.2 & 72.4 & 70.3 & 69.5\\
        (d) &  &  &              &  &              & 73.4 & 73.8 & 71.1 & 70.7 \\
\hline
        VL-BERT &  &  &              &  &  & 73.8 & 73.9 & 71.2 &  71.1\\
\Xhline{1.0pt}
\end{tabular}}
\caption{Ablation study for VL-BERT with 0.5 fine-tuning epochs.}
\label{table:ablation_study}
\end{table}


Table~\ref{table:ablation_study} ablates key design choices in pre-training VL-BERT. For experimental efficiency, the finetuning epoches of VL-BERT are of 0.5 of those in Section~\ref{sec:exp_finetune}, with only VL-BERT model.

Overall, the pre-training of VL-BERT improves the performance over all the three down-stream tasks (by comparing setting ``w/o pre-training" and  VL-BERT). The improvement amplitude varies for different tasks. By comparing setting (a) to that of ``w/o pre-training", we see the benefits of Task \#1, Masked Language Modeling with Visual Clues. By further incorporating Task \#2, Masked RoI Classification with Linguistic Clues, the accuracy further improves on RefCOCO+, but gets stuck at VCR and VQA.  This might be because only RefCOCO+ utilizes the final output feature corresponding to [IMG] tokens for prediction. Thus the pre-training of such features is beneficial. Setting (c) incorporates the task of Sentence-Image Relationship Prediction as in ViLBERT~\citep{lu2019vilbert} and LXMERT~\citep{tan2019lxmert}. It would hurt accuracy on all the three down-stream tasks. We guess the reason is because the task of Sentence-Image Relationship Prediction would introduce unmatched image and caption pairs as negative examples. Such unmatched samples would hamper the training of other tasks. Setting (d) adds text-only corpus during pre-training. Compared with setting (b), it improves the performance over all three down-stream tasks, and is most significant on VCR. This is because the task of VCR involves more complex and longer sentences than those in VQA and RefCOCO+\footnote{ In VCR, there are 16.0 and 33.7 words per sample on average for Q  A and QA  R sub-tasks, respectively. While the words per sample for VQA and RefCOCO+ are of 7.2 and 3.5, respectively.}. By further finetuning the network parameters of Fast R-CNN, which generates the visual features, we get the final setting of VL-BERT. Such end-to-end training of the entire network is helpful for all the downstream tasks.


 \section{Conclusion}

In this paper, we developed VL-BERT, a new pre-trainable generic representation for visual-linguistic tasks. Instead of using ad-hoc task-specific modules, VL-BERT adopts the simple yet powerful Transformer model as the backbone. It is pre-trained on the massive-scale Conceptual Captions dataset, together with text-only corpus. Extensive empirical analysis demonstrates that the pre-training procedure can better align the visual-linguistic clues, and thus benefit the downstream tasks. In the future, we would like to seek better pre-training tasks, which could beneficial more downstream tasks (e.g., Image Caption Generation).
 
\subsubsection*{Acknowledgments}
The work is partially supported by the National Natural Science Foundation of China under grand No.U19B2044 and No.61836011.

\bibliography{VL-BERT-ICLR2020}
\bibliographystyle{iclr2020_conference}

\clearpage

\appendix
\section{Appendix}

\subsection{Comparison among VL-BERT and other works}

Table~\ref{table:concurrent_works} compares among VL-BERT and other concurrent works for pre-training generic visual-linguistic representations.


\begin{table}[h]
\centering
\small
\resizebox{1.0\linewidth}{!}{
        \begin{tabular}{c|c|l|c|l|l|l}
        \Xhline{1.0pt}
            & Method & Architecture & Visual Token & Pre-train Datasets & Pre-train Tasks & Downstream Tasks \\
        \hline
           \multirow{3}{*}{\makecell{Published\\Works}} & \multirow{3}{*}{\makecell{VideoBERT\\\citep{sun2019videobert}}} & \multirow{3}{*}{single cross-modal Transformer} & \multirow{3}{*}{video frame} & \multirow{3}{*}{\makecell{Cooking312K\\\citep{sun2019videobert}}} & 1) sentence-image alignment & 1) zero-shot action classification\\
            &  &  &  &  & 2) masked language modeling & 2) video captioning\\
            &  &  &  &  & 3) masked visual-words prediction \\
            \hline
            \multirow{27}{*}{\makecell{Works\\Under\\Review /\\Just Got\\Accepted}} & \multirow{3}{*}{\makecell{CBT\\\citep{sun2019contrastive}}} & two single-modal Transformer & \multirow{3}{*}{video frame} & \multirow{3}{*}{\makecell{Cooking312K\\\citep{sun2019videobert}}} & 1) sentence-image alignment & 1) action anticipation\\
            &  & (vision \& language respectively) &  &  & 2) masked language modeling & 2) video captioning \\
            &  & + one cross-modal Transformer &  &  & 3) masked visual-feature regression \\
            \cline{2-7}
            & \multirow{5}{*}{\makecell{ViLBERT\\\citep{lu2019vilbert}}} & \multirow{5}{*}{\makecell[l]{one single-modal Transformer\with restricted attention pattern)}} & \multirow{5}{*}{image RoI} & \multirow{5}{*}{\makecell{Conceptual Captions\\\citep{sharma2018conceptual}}} & 1) sentence-image alignment & 1) visual question answering\\
            &  &  &  &  & 2) masked language modeling & 2) visual commonsense reasoning\\
            &  &  &  &  & 3) masked visual-feature classification & 3) grounding referring expressions\\
            &  &  &  &  & & 4) image retrieval\\
            &  &  &  &  &  & 5) zero-shot image retrieval\\
            \cline{2-7}
            & \multirow{2}{*}{\makecell{B2T2\\\citep{alberti2019fusion}}} & \multirow{2}{*}{single cross-modal Transformer} & \multirow{2}{*}{image RoI} & \multirow{2}{*}{\makecell{Conceptual Captions\\\citep{sharma2018conceptual}}} & 1) sentence-image alignment & 1) visual commonsense reasoning\\
            &  &  &  &  & 2) masked language modeling  \\
                \cline{2-7}
            & \multirow{5}{*}{\makecell{LXMERT\\\citep{tan2019lxmert}}} &  & \multirow{5}{*}{image RoI} & \ddag ~COCO Caption & 1) sentence-image alignment & 1) visual question answering \\
            &  & two single-modal Transformer &  & + VG Caption & 2) masked language modeling & 2) natural language visual reasoning  \\
            &  & (vision \& language respectively) &  & + VG QA & 3) masked visual-feature classification \\
            &  & + one cross-modal Transformer &  & + VQA & 4) masked visual-feature regression \\
            &  &  &  & + GQA & 5) visual question answering\\
            \cline{2-7}
            & \multirow{4}{*}{\makecell{VisualBERT\\\citep{li2019visualbert}}} & \multirow{4}{*}{single cross-modal Transformer} & \multirow{4}{*}{image RoI} & \multirow{4}{*}{\makecell{COCO Caption\\\citep{chen2015microsoft}}} & 1) sentence-image alignment & 1) visual question answering\\
            &  &  &  &  & 2) masked language modeling & 2) visual commonsense reasoning\\
            &  &  &  &  &  & 3) natural language visual reasoning  \\
            &  &  &  &  &  & 4) grounding phrases \\
            \cline{2-7}
            & \multirow{3}{*}{\makecell{Unicoder-VL\\\citep{li2019unicodervl}}} & \multirow{3}{*}{single cross-modal Transformer} & \multirow{3}{*}{image RoI} & \multirow{3}{*}{\makecell{Conceptual Captions\\\citep{sharma2018conceptual}}} & 1) sentence-image alignment & 1) image-text retrieval \\
            &  &  &  &  & 2) masked language modeling  & 2) zero-shot image-text retrieval \\
            &  &  &  &  & 3) masked visual-feature classification \\
                \cline{2-7}
            & \multirow{5}{*}{Our VL-BERT} & \multirow{5}{*}{single cross-modal Transformer} & \multirow{5}{*}{image RoI} & \multirow{5}{*}{\makecell[l]{Conceptual Captions\\ \citep{sharma2018conceptual} \\ + BooksCorpus \\ \citep{zhu2015aligning} \\ + English Wikipedia}} & 1) masked language modeling & 1) visual question answering\\
            &  &  &  &  & 2) masked visual-feature classification & 2) visual commonsense reasoning\\
            &  &  &  &  &  & 3) grounding referring expressions\\
            &  &  &  &  &  & \\
            &  &  &  &  &  & \\
        \Xhline{1.0pt}
        \multicolumn{7}{l}{\hspace{-0.5em}\ddag ~LXMERT is pre-trained on COCO Caption~\citep{chen2015microsoft}, VG Caption~\citep{krishna2017visual}, VG QA~\citep{zhu2016visual7w}, VQA~\citep{antol2015vqa} and GQA~\citep{hudson2019gqa}.} \\
        \end{tabular}
}
\caption{Comparison among our VL-BERT and other works seeking to derive pre-trainable generic representations for visual-linguistic tasks.}
\label{table:concurrent_works}
\end{table}

\subsection{Detailed experiment settings}

Pre-training is conducted on 16 Tesla V100 GPUs for 250k iterations by SGD. In each mini-batch, 256 samples are drawn. Among them, 128 samples are of Caption, Image pairs from Conceptual Captions, and the rest 128 samples are sequential tokens (at most 64 tokens for each sequence) from BooksCorpus \& English Wikipedia. In SGD, Adam optimizer~\citep{kingma2014adam} is applied, with base learning rate of , , , weight decay of , learning rate warmed up over the first 8,000 steps, and linear decay of the learning rate. All the parameters in VL-BERT and Fast R-CNN are jointly trained in both pre-training and fine-tuning phase. The visual feature input for textual corpus is a learnable embedding shared for all words. In the task of Masked RoI Classification with Linguistic Clues, the pixels lying in all the masked RoIs are set as zeros in the image. A box covering the whole image is added as a RoI and would not be masked.

For VCR, the fine-tuning is conducted on 16 Tesla V100 GPUs for 20 epochs. In each mini-batch, 256 triplets of Question, Answer, Image are sampled. In SGD, the basic mini-batch gradient descent is conducted, with base learning rate of , momentum of 0.9, and weight decay of . The learning rate is linearly warmed up in the first 1,000 steps from an initial learning rate of 0, and is decayed by 0.1 at the 14-th and the 18-th epochs.

For VQA, the fine-tuning is conducted on 16 Tesla V100 GPUs for 20 epochs. In each mini-batch, 256 triplets of Question, Answer, Image are sampled. In SGD, Adam optimizer is applied, with base learning rate of , , , weight decay of , learning rate warmed up over the first 2,000 steps, and linear decay of the learning rate.

For RefCOCO+, the fine-tuning is conducted on 16 Tesla V100 GPUs for 20 epochs. In each mini-batch, 256 pairs of Query, Image are sampled. In SGD, Adam optimizer is applied, with base learning rate of , , , weight decay of , learning rate warmed up over the first 500 steps, and linear decay of the learning rate.

\subsection{Visualization of attention maps in VL-BERT}

\begin{figure*}

\centering

\subfigure[]{
\begin{minipage}[t]{0.5\linewidth}
\centering
\includegraphics[width=0.71\linewidth]{fig/vis-1.pdf}
\end{minipage}}\subfigure[]{
\begin{minipage}[t]{0.5\linewidth}
\centering
\includegraphics[width=0.7\linewidth]{fig/vis-5.pdf}
\end{minipage}}

\subfigure[]{
\begin{minipage}[t]{0.5\linewidth}
\centering
\includegraphics[width=0.7\linewidth]{fig/vis-2.pdf}
\end{minipage}}\subfigure[]{
\begin{minipage}[t]{0.5\linewidth}
\centering
\includegraphics[width=0.79\linewidth]{fig/vis-3.pdf}
\end{minipage}}

\subfigure[]{
\begin{minipage}[t]{0.5\linewidth}
\centering
\includegraphics[width=0.74\linewidth]{fig/vis-4.pdf}
\end{minipage}}\subfigure[]{
\begin{minipage}[t]{0.5\linewidth}
\centering
\includegraphics[width=0.7\linewidth]{fig/vis-6.pdf}
\end{minipage}}

\caption{Visualization of attention maps in pre-trained VL-BERT. Line intensity indicates the magnitude of attention probability with the text token as query and the image RoI as key. The intensity is affinely rescaled to set the maximum value as 1 and the minimum as 0, across different heads in each layer. The index of network layer and attention head is counted from 0.}

\label{fig.att_viz}
\end{figure*}

To better understand what VL-BERT learns from pre-training, we visualized the attention maps of pre-trained VL-BERT (without fine-tuning on downstream tasks) using BertViz\footnote{\url{https://github.com/jessevig/bertviz}}\citep{vig2019transformervis}. 

Some visualization results on COCO \citep{lin2014microsoft,chen2015microsoft} val2017 set are shown in Figure~\ref{fig.att_viz}. We can see different attention patterns across attention heads. For some attention heads, text tokens attend more on the associated image RoIs. While in some other heads, text tokens attend uniformly to all RoIs. It demonstrates the ability of VL-BERT in aggregating and aligning visual-linguistic contents.

 

\end{document}
