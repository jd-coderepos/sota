\documentclass{article} \usepackage{iclr2019_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{caption}
 \usepackage{hyperref}
 \usepackage{url}
 \usepackage{microtype}
 \usepackage{graphicx}
 \usepackage{subfigure}
 \usepackage{booktabs} \usepackage{multirow}

 \usepackage{amsmath}
 \usepackage{amsthm}
 \usepackage{amsfonts}
 \usepackage{natbib}
 \usepackage{mathtools}
 \usepackage{multirow}
 \usepackage{soul}
 \usepackage{threeparttable}

\title{Generating High Fidelity Images \\ with Subscale Pixel Networks \\ and Multidimensional Upscaling}



\author{Jacob Menick\thanks{Equal contributions.} \\
DeepMind\\
\texttt{jmenick@google.com} \\
\And
Nal Kalchbrenner \\
Google Brain Amsterdam \\
\texttt{nalk@google.com} \\
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}
\newcommand{\jacobtodo}[1]{{\color{red} Jacob TODO: #1}}
\newcommand{\naltodo}[1]{{\color{purple} Nal TODO: #1}}

\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}

The unconditional generation of high fidelity images is a longstanding benchmark
for testing the performance of image decoders. Autoregressive image models
have been able to generate small images unconditionally, but the extension of
these methods to large images where fidelity can be more readily assessed has
remained an open problem. Among the major challenges are the capacity to
encode the vast previous context and the
sheer difficulty of learning a distribution that preserves
both global semantic coherence and exactness of detail. To address the former
challenge, we propose the Subscale Pixel Network (SPN), a conditional decoder
architecture that generates an image as a sequence of sub-images of equal size. The SPN compactly captures
image-wide spatial dependencies and requires a fraction of the memory and the
computation required by other fully autoregressive models. To address the latter challenge, we propose to use Multidimensional Upscaling to grow an image in both size and depth via intermediate stages utilising distinct SPNs. We
evaluate SPNs on the unconditional generation of CelebAHQ of size 256 and of ImageNet
from size 32 to 256. We achieve state-of-the-art likelihood results in multiple
settings, set up new benchmark results in previously unexplored settings and are
able to generate very high fidelity large scale samples on the basis of both datasets.


\end{abstract}

\section{Introduction}

A successful generative model has two core aspects: it produces targets that have high fidelity and it generalizes well on held-out data. Autoregressive (AR) models trained by conventional maximum likelihood estimation (MLE) have produced superior scores on held-out data across a wide range of domains such as text \citep{Vaswani17,gnmt}, audio \citep{Oord16}, images \citep{Parmar18} and videos \citep{vpn}. These scores are a measure of the models' ability to generalize in that setting. From the perspective of sample fidelity, the outputs generated by AR models have also achieved state-of-the-art fidelity in many of the aforementioned domains with one notable exception. In the domain of unconditional large-scale image generation, AR samples have yet to manifest long-range structure and semantic coherence.

One source of difficulties impeding high-fidelity image generation is the multi-faceted relationship between the MLE scores achieved by a model and the model's sample fidelity. On the one hand, MLE is a well-defined measure as improvements in held-out scores generally produce improvements in the visual fidelity of the samples. On the other hand, as opposed to for example adversarial methods \citep{birthday}, MLE forces the model to support the entire empirical distribution. This guarantees the model's ability to generalize at the cost of allotting capacity to parts of the distribution that are irrelevant to fidelity. 
A second source of difficulties arises from the high dimensionality of large images. A  image has a total of 196,608 positions that need to be architecturally connected in order to learn dependencies among them; the representations at each position require sufficient capacity to express their respective surrounding contexts. These requirements translate to large amounts of memory and computation.

 \begin{figure}[h]
  \begin{center}
    \includegraphics[scale=0.2]{graphs/stagewise.pdf}
    \caption{A representation of Multidimensional Upscaling. Left: depth upscaling is applied to a \emph{generated} 3-bit  RGB subimage from CelebAHQ to map it to a full 8-bit  RGB image. Right: size upscaling followed by depth upscaling are applied to a \emph{generated} 3-bit  RGB subimage from ImageNet to map it to the target resolution of the 8-bit  RGB image. We stress that the rightmost column of both figures are true unconditional samples from our model at full 8bit depth.}
    \label{fig:size_depth}
  \end{center}
\end{figure}

These difficulties notwithstanding, we aim to learn the full distribution over 8-bit RGB images of size up to  well enough so that the samples have high fidelity. We aim to guide the model to focus first on visually more salient bits of the distribution and later on the visually less salient bits. We identify two visually salient subsets of the distribution: first, the subset determined by sub-images (``slices'') of smaller size (e.g. ) sub-sampled at all positions from the original image; and secondly, the subset determined by the few (e.g. 3) most significant bits of each RGB channel in the image. 
We use \emph{Multidimensional Upscaling} to map from one subset of the distribution to the other one by upscaling images in size or in depth. For example, the generation of a  8-bit RGB image proceeds by first upscaling it in size from a  3-bit RGB image to a  3-bit RGB image; we then upscale the resulting image in depth to the original resolution of the  8-bit RGB image. We thus train three networks: (a) a decoder on the small size, low depth image slices subsampled at every  pixels from the original image with the desired target resolution; (b) a size-upscaling decoder that generates the large size, low depth image conditioned on the small size, low depth image; and (c) a depth-upscaling decoder that generates the large size, high depth image conditioned on the large size, low depth image.  Figure \ref{fig:size_depth} illustrates this process.

To address the latter difficulties that ensue in the training of decoders (b) and (c), we develop the Subscale Pixel Network (SPN) architecture. The SPN divides an image of size  into sub-images of size  sliced out at interleaving positions (see Figure 2), which implicitly also captures a form of size upscaling. The  image is generated one slice at a time conditioned on previously generated slices in a way that encodes a rich spatial structure. SPN consists of two networks, a conditioning network that embeds previous slices and a decoder proper that predicts a single target slice given the context embedding. The decoding part of the SPN acts over image slices with the same spatial structure and it can share weights for all of them. The SPN is an independent image decoder with an implicit size upscaling mechanism, but it can also be used as an \emph{explicit} size upscaling network by initializing the first slice of the SPN input at sampling time with one generated separately during step (a). 


We extensively evaluate the performance of SPN and the size and depth upscaling methods both quantitatively and from a fidelity perspective on two unconditional image generation benchmarks, CelebAHQ-256 and ImageNet of various sizes up to 256. From a MLE scores perspective, we compare with previous work to obtain state-of-the-art results on CelebAHQ-256, both at full 8-bit resolution and at the reduced 5-bit resolution \citep{Glow}, and on ImageNet-64. We also establish MLE baselines for ImageNet-128 and ImageNet-256. From a sample fidelity perspective, we show the strong benefits of multidimensional upscaling as well as the benefits of the SPN. We produce CelebAHQ-256 samples (at full 8-bit resolution) that are of similar visual fidelity to those produced with methods such as GANs that lack however an intrinsic measure of generalization \citep{Mescheder,ProGAN}. We also produce some of the first successful samples on unconditional ImageNet-128 (also at 8-bit) showing again the striking impact of the SPN and of multidimensional upscaling on sample quality and setting a fidelity baseline for future methods.

\section{Model}

\subsection{Conventional Generation Ordering}

A standard AR image model such as the PixelCNN \citep{PixelRNN} generates an  colour image starting at the top-left position and ending at the bottom-right position, fully generating the three 8-bit channels of each pixel in a given position:


where  corresponds to all previously generated intensity values in the ordering and , , and  are row, column, and colour channel indices. The raster scan ordering (Figure 3(a)) is conventionally used in AR models. Each conditional distribution  is parametrized by a deep neural network \citep{PixelRNN}.

\begin{figure}
 \centering
. \includegraphics[scale=0.09]{graphs/sub_context2.pdf}
 \vspace{-0.5cm}
 \caption{The receptive field in a Subscale Pixel Networks (a) and the four image slices subsampled from the original image (b)}
\end{figure}

\subsection{Subscale Ordering in Images}
\label{Subs}

We define an alternative ordering that divides a large image into a sequence of equally sized slices and has various core properties. First, it makes it easy to compactly encode long-range dependencies across the many pixels in the large images. It also induces a spatial structure over the original image by aligning the subsampled slices; this also has an implicit size upscaling side effect. From the perspective of the neural architecture, it makes it possible for the same decoder within the SPN to be consistently applied to all slices, since they are structurally similar; the smaller slices also allow for self-attention \citep{Vaswani17} in the SPN to be used without local contexts \citep{Parmar18}. We think of the ordering as the two-dimensional analogue of the one-dimensional subscale ordering introduced in \citet{WaveRNN}.

The subscale ordering is defined as follows:

where  corresponds to all previously generated intensity values according to this ordering. Figure \ref{fig:OrderingDiagram}(d) illustrates the subscale ordering. A scaling factor  is selected and each slice of size  is obtained by selecting a pixel every  pixels in both height and width; there are thus  interleaved slices in the original image, with each specified  by its row and column offset . We sometimes refer to this offset as the ``meta-position'' of a slice.

\begin{figure}
 \centering
 \includegraphics[scale=0.14]{graphs/Fact_graphic_2.pdf}
 \caption{Different generation ordering schemes, where the numbers indicate the step-by-step order. Distinct colors correspond to distinct neural networks. (a) and (b) are from \citep{PixelRNN}. (c) is from \citep{ParallelMultiscale}. The Subscale ordering alone, with size-only, depth-only and with multidimensional upscaling are, respectively, in blocks (d), (e), (f) and (g).}
 \label{fig:OrderingDiagram}
 \end{figure}

\subsection{Size Upscaling in Subscale Ordering}

The subscale ordering itself already captures size upscaling implicitly. Analogous to the multi-scale ordering \citep{PixelRNN}, and depicted in \ref{fig:OrderingDiagram}(b), we can perform size upscaling \emph{explicitly}, by training a single slice decoder on subimages and generate the first slice of a subscale ordering from the single slice decoder itself. The rest of the image is then generated according to the subscale ordering by the main network (see \ref{fig:OrderingDiagram}(e)). The single-slice model can be trained on just the first slices of images, or on slices at all positions in all images given the shared spatial structure among the slices. For this reason, the same SPN that captures the subscale ordering can act simultaneously as a full-blown image model as well as a size upscaling model if initialized with the outputs of a single-slice decoder. A separate formulation of size upscaling is the Parallel Multi-Scale \citep{ParallelMultiscale} ordering where the pixels in an image are doubled at every stage by distinct neural networks and are generated in parallel without sequentiality (\ref{fig:OrderingDiagram}(c)).

\subsection{Depth Upscaling}

Multidimensional upscaling applies upscaling not just in the height and width of the image, but also in the remaining dimension that is channel depth. This is performed in stages such that a network first generates the  most significant bits of an image using a conventional or subscale ordering; then a second network generates the next  most significant bits of the image conditioned on \emph{all} the  bits of the image; and so on to further stages. Using the conventional ordering as basis, the first stage of depth upscaling looks as follows:

Next, a second stage of depth upscaling has the following form, conditioned on the first  bits of each channel:

We do not share weights among the networks at different stages of depth upscaling. We note that in depth upscaling bits of lower significance are only generated when the more significants bits at all positions have been generated in a previous stage. Just like for size upscaling from the previous section, the goal of multidimensional upscaling is to let the model focus on visually salient bits of an image unaffected by less salient and less predictable bits of the image. Depth upscaling is related to the method underlying the Grayscale PixelCNN that models 4-bit greyscale images subsampled from colored images \citet{greyscaling}.

\begin{figure}
\centering
\includegraphics[scale=0.12]{graphs/Enc_dec_graphic_.pdf}
\vspace{-0.5cm}
\label{fig:architecture}
\caption{(a) The architecture of a Subscale Pixel Network, with a conditional and a decoding part. (b) Scheme of the parts in the decoder itself.}
\end{figure}
\section{Architecture}
\vspace{-0.3cm}

\subsection{Challenges in Training Conventional Decoders on Large Images}

Using a conventional generation ordering, models such as PixelRNN, PixelCNN \citep{PixelRNN} and Image Transformer \citep{Parmar18} construct a representation of the generated context for each dimension of each pixel. Existing AR approaches inherently require an amount of computation and memory that is superlinear in the number of pixels. In particular, the quadratic memory requirements of self-attention become severely limiting for images larger than  and intractable in practice for the 196,608 distinct positions we consider in a  colour image.

Mitigating the memory requirements and computational requirements of encoding the dependencies amongst so many variables often comes at the expense of global context. Modeling choices such as cropping images within the decoders \citep{vpn} or performing self-attention over local neighborhoods \citep{Parmar18} neglect global dependencies, while model parallelism, though technically feasible with the joint use of a very large number of accelerators, does not overcome the challenges in learning the global structure.

\subsection{Subscale Pixel Network}

To address these challenges, we devise the Subscale Pixel Network (SPN), an architecture that embodies the subscale ordering from Section \ref{Subs}. For an image of size , where  is the number of bits used for the current generation stage, one first chooses a scaling factor  and obtains the  slices of the original image of size . We use  and  as well as  and , for the larger images we process, so that the slices have size . This scheme of choosing  such that slices are always  renders the memory and computation requirements effectively constant as the true image size  changes.

\begin{figure}[ht]
  \begin{center}
    \includegraphics[scale=0.19]{images_final_jpg/both_images_imnet.jpg}
    \caption{Left: 8-bit 128x128 RGB ImageNet samples from SPN with depth upscaling only. Right:  8-bit 128x128 RGB ImageNet samples from SPN with full-blown Multidimensional Upscaling. Temperature is 0.99 for the initial 32x32 sub-image and otherwise 1.0}
    \label{fig:im128_updepthed}
  \end{center}
\end{figure}

The SPN architecture is composed of two parts: an embedding part for slices at preceding meta-positions that conditions the decoder for the current slice that is being generated (Figure 4 (a)). The embedding part is a convolutional neural network with residual blocks that takes as input preceding slices that are concatenated along the \emph{depth} dimension. One detail is the way the slices are ordered along the channel dimension when concatenated. As illustrated in Figure 4 (a), empty padding slices are used to preserve \emph{relative} meta-positions of each preceding slice with respect to the current target slice. For example, the slice above any target slice in the two-dimensional meta-grid is always aligned in the same position along the depth axis in the input. This achieves equivariance in the embedding architecture with respect to the  offset of a slice. The padding slices also ensure that the depth of the input slice tensor remains the same for all target slices. In addition to the slice tensor, the embedding part also receives as input the meta-position of the target slice as an embedding of 8 units tiled spatially across the slice tensor. The pixel intensity values are also embedded as one-hot indices of size 8. The context embedding network passes its input through a series of self-attention layers and then a series of residual blocks, finally emitting a slice-sized feature map  that summarizes the context for the decoder.



The decoder takes as input the encoded slice tensor  in a position-preserving manner: each position in the target slice is given as input the encoded representations of pixels at that same position in the preceding slices. In addition it processes the target slice in the raster-scan order. The decoder that we use is a hybrid architecture combining masked convolution and self-attention \citep{pixelsnail}. We employ an initial 1D self-attention network \cite{Vaswani17} that is used to gather the entire available context in the slice (see Figure 4(b)). The slice is reshaped into a 1D tensor before it is given as input to masked 1D self-attention layers; the masking is performed over the previous pixels only (as opposed to over the current RGB channels) in the self-attention layers. Then the output of the layers is reshaped back into a 2D tensor, concatenated depth-wise with the output of the slice embedding network, and given as conditioning input to a Gated PixelCNN as in Equation 5 in \citet{gatedpix}. The PixelCNN network models the target slice with full masking over pixels and channel dimensions. We can see how memory requirements are significantly lower - up to  lower with  - due to the smaller {\it spatial} size of the slices and their compact concatenation along the channel dimension of the input tensor. Due to this structure, the entire previously generated context is captured at each position of the decoder.
\vspace{-0.2cm}

\subsection{Learning}

The log-likelihood derived from equation 2 decomposes as a sum over slices. An unbiased estimator of the log-loss is obtained by uniformly sampling a choice of target slice and evaluating its log-probability conditioned upon previous slices as depicted in Figure 4 (a). We perform maximum likelihood learning by doing stochastic gradient descent on this Monte Carlo estimate, with all gradients computed by backpropagation. 


\subsection{Multidimensional Upscaling with SPN}

As seen in Section 2.3, the SPN naturally serves as a size-upscaling network when the first slice of the input tensor is initialized with with an externally generated subimage. In our experiments, we ensure that the smaller subimages used for the initialization and those used in the training of the SPN decoder are identical to each other. 

Analogously, the SPN can be used to upscale the depth of the channels of an image. The image to be upscaled in depth is itself divided into slices by the subscale method (secion 2) and the slices are then concatenated along the channel dimension into a slice tensor for the conditioning image . The latter is then added as a fixed additional input to the embedding part of the SPN in order to model . The model of  is a normal SPN, but trained on data with low bit depth.


\begin{table}[t]
\small
\begin{center}
\begin{tabular}{l|l|l}
& ImageNet 32x32 & ImageNet 64x64 \\
\hline
\hline
Gated PixelCNN \citep{gatedpix} & 3.83 & 3.57 \\
Parallel Multiscale \citep{ParallelMultiscale} & 3.95 & 3.70 \\
PixelSNAIL \citep{pixelsnail} & 3.80 & - \\
Image Transformer \citep{Parmar18} & \bf{3.77} & - \\
Glow \citep{Glow} & 4.09 & 3.81 \\
\hline
\hline
Decoder baseline & 3.79 & \bf{3.52} \\
SPN & - & 3.53 \\
SPN + Depth Upscaling & - & 3.53 (0.63, 2.90) \\
SPN + 16x16 slices & 3.85 & - \\
SPN + 8x8 slices & 3.91 & - \\
\end{tabular}
\caption{Negative Log-likelihood (NLL) scores for Downsampled Imagenet \citep{PixelRNN} in bits/dim. The parenthesized numbers in Depth Upscaling rows indicate NLL for  and  respectively.}
\end{center}
\label{tab:dsimagenet}
\end{table}




\section{Experiments}

We demonstrate experimentally that our model is capable of high fidelity samples at high resolution, producing unconditional CelebA-HQ samples of quality better than the Glow model \citep{Glow} and  improving the MLE scores. Furthermore, we show that these results extend to high-resolution ImageNet images, with state-of-the-art log-likelihoods at 128x128 by a large margin and the first benchmark on 256x256 ImageNet. Unconditional samples at these resolutions are characterized by unprecedented global coherence.

Because our networks operate on small images ( slices), we can train large networks both in terms of the number of hidden units and in terms of network depth (see Appendix C for details of sizes).
The context-embedding network contains 5 convolutional layers and 6-8 self-attention layers depending on the dataset. The masked decoder consists of a PixelCNN with 15 layers in all experiments. The 1D Transformer in the decoder (Figure 4(b)) has between 8 and 10 layers depending on the dataset. See Table 4 for all dataset-specific hyperparameter details.

\begin{table}[t]
\small
\begin{center}
\begin{tabular}{l|l|l}
 & ImageNet 128 x 128 & ImageNet 256 x 256 \\
\hline
\hline
Parallel Multiscale \citep{ParallelMultiscale}  & 3.55 &- \\
\hline
\hline
SPN & \bf{3.08} & \bf{2.97} \\
SPN + Depth-Upscaling & \bf{3.08} (0.46, 2.62) & 3.01 (0.40, 2.61) \\
\end{tabular}
\caption{NLL scores for high-resolution Imagenet in bits/dim. The parenthesized numbers in Depth Upscaling rows indicate NLL for  and  respectively.}
\end{center}
\label{tab:imagenet}
\end{table}



\begin{table}[t]
\small
\begin{center}
\begin{tabular}{l|l|l}
& ImageNet 64 x 64 (5bit) & CelebA-HQ 256 x 256 (5bit) \\
\hline
\hline
Glow \citep{Glow}  & 1.76 & 1.03 \\
\hline
\hline
SPN & \bf{1.41} & \bf{0.61} \\
\end{tabular}
\caption{Negative Log-likelihood scores for 5-bit datasets in bits/dim.}
\end{center}
\vspace{-0.3cm}
\label{tab:fivebit}
\end{table}

\subsection{Downsampled ImageNet at  and }

We first benchmark the performance of our hybrid decoder alone (i.e. no subscaling, Figure 4(b)) and show that it compares favorably to state of the art models on  Downsampled ImageNet (see Table 1). We find that SPN hurts in this low-resolution setting with  and even further with . This is likely because the size of the resulting image slices becomes very small and the image \ coarse grained.

On  Downsampled ImageNet, we achieve a state of the art log-likelihood of 3.52 bits/dim. We hypothesize that PixelSNAIL would achieve a similar score, but results at this resolution were not reported in \citet{pixelsnail}. At this resolution, SPN scores similarly with 3.53 bits/dim. 
The improvement over Glow in the 5-bit setting is very significant (Table 3). 

\subsection{ImageNet at }

For these experiments we use the standard ILSVRC Imagenet dataset \citep{imagenet} resized with Tensorflow's  function. Parallel Multiscale PixelCNN \citep{ParallelMultiscale} is the only model in the literature which reports log-likelihood on  ImageNet. SPN improves the log-likelihood over this model from 3.55 bits/dim 
to 3.08 bits/dim (see Table 2). Figure 5 gives  8-bit ImageNet samples for both the setting of depth upscaling only and of complete multidimensional upscaling. These settings do not affect the NLL, but the samples with depth upscaling show significant semantic coherence that is usually lacking in samples without upscaling. In addition, multidimensional upscaling seems to increase the overall rate of success of the samples.
Additional intermediate ImageNet samples can be seen in Figures 10, 11 and 12 in the Appendix.

\subsection{CelebAHQ}

 At  we can produce high-fidelity samples of celebrity faces from the CelebAHQ dataset. The quality compares favorably to the samples of other models such as Glow and GANs \citep{ProGAN}. We show in Table 3 that the achieved MLE scores are a significant improvement over previously reported scores. Figure 6 showcases some samples for 8-bit CelebAHQ-256. Figure 7 in the Appendix includes 5-bit samples,  Figure 8 includes 3-bit samples while Figure 9 includes 3-bit samples with the temperature of the output distribution set to 0.95.

\section{Conclusion}

The problem of whether it is possible to learn the distribution of complex natural images and attain high sample fidelity has been a long-standing one in the tradition of generative models. The SPN and Multidimensional Upscaling model that we introduce accomplishes a large step towards solving this problem, by attaining both state-of-the-art MLE scores on large-scale images from complex domains such as CelebAHQ-256 and ImageNet-128 and by being able to generate high fidelity full 8-bit samples from the resulting learnt distributions without alterations to the sampling process (via e.g. heavy modifications of the temperature of the output distribution). The generated samples show an unprecedented amount of  semantic coherence and exactness of details even at the large scale size of full 8-bit  and  images.

\section{Acknowledgements}

We would like to thank Alex Graves, Karen Simonyan, Aaron van den Oord, Tim Harley, Sander Dieleman, Tim Salimans, Lasse Espeholt, Ali Razavi, Jeffrey De Fauw and Andy Brock for insightful discussions. In particular we wish to thank Andriy Mnih for formative ideas about autoregressivity in the bit-depth of an image.

\bibliography{iclr2019_conference}
\bibliographystyle{iclr2019_conference}

\section*{Appendix A}

In some cases for purposes of analysis the entropy of the softmax output distributions has been artificially reduced via a ``temperature" divisor on the predicted logits. When we say the temperature is 0.95, we mean that the logits of a trained model have been divided by this constant at sampling time.

\begin{figure}[h]
  \begin{center}
    \includegraphics[scale=0.19]{images_final_jpg/cel256_updepthed_block.jpg}
    \caption{8-bit 256x256 RGB CelebA-HQ samples from SPN with Depth-Upscaling. Temperature is 0.99 for the low-bit-depth image and otherwise 1.0}
    \label{fig:cel256_updepthed}
  \end{center}
\end{figure}

\begin{figure}[h]
  \begin{center}
    \includegraphics[scale=0.2]{images_final_jpg/cel256_5bit_block.jpg}
    \caption{256x256 CelebA-HQ 5bit samples from SPN}
    \label{fig:cel256_5bit}
  \end{center}
\end{figure}

\begin{figure}[h]
  \begin{center}
    \includegraphics[scale=0.2]{images_final_jpg/cel256_3bit_block_temp99.jpg}
    \caption{256x256 CelebA-HQ 3bit samples from SPN}
    \label{fig:cel256_3bit}
  \end{center}
\end{figure}

\begin{figure}[h]
  \begin{center}
    \includegraphics[scale=0.2]{images_final_jpg/cel256_3bit_block_temp95.jpg}
    \caption{256x256 CelebA-HQ 3bit samples from SPN with temperature 0.95}
    \label{fig:cel256_3bit_temp95}
  \end{center}
\end{figure}

\begin{figure}[h]
  \begin{center}
    \includegraphics[scale=0.2]{images_final/im128_upscaled_3bit_block.png}
    \caption{128x128 ImageNet 3bit; upscaled 32x32 slices}
    \label{fig:im128_upscaled_3bit}
  \end{center}
\end{figure}

\begin{figure}[h]
  \begin{center}
    \includegraphics[scale=0.2]{images_final/im128_32slice_3bit_block.png}
    \caption{128x128 ImageNet 3bit samples from model trained on 32x32 slices}
    \label{fig:im128_32slice_3bit}
  \end{center}
\end{figure}

\begin{figure}[h]
  \begin{center}
    \includegraphics[scale=0.2]{images_final/im128_3bit_block.png}
    \caption{128x128 ImageNet 3bit samples from SPN}
    \label{fig:im128_3bit}
  \end{center}
\end{figure}

\section*{Appendix B}

Please see Table 4 for all the detailed hyperparameters.

\section*{Appendix C}

Our experiments operate at a fairly large scale in terms of both the amount of compute used and the size of the networks. We proportionately increase the batch size so that the number of pixels in a batch is not affected by the subscaling. These large batch sizes (a maximum of 2048) are achieved by increasing the degree of data parallelism by running on Google Cloud TPU pods \citep{tpu}. For Imagenet 32 we used 64 tensorcores. For ImageNet 64, 128 and 256, we use 128 tensorcores. The fast interconnect between these devices affords much faster synchronous gradient computation than would be possible using the same number of GPUs. When overfitting is a problem, as in small datasets like CelebA-HQ, we rather decrease the batch size and use a lower number of 32 tensorcores. 

Our SPN architectures have between 50M and 250M parameters depending on the dataset. See Table 4 for the number of parameters in the SPN architecture for each dataset. Depth-upscaling doubles the number of parameters due to using two separate networks with untied weights. Size-upscaling adds more parameters still for the separate decoder-only network which models the first slice as seen in Figure 3 (g). Thus the maximal number of parameters used to generate a sample in the paper occurs in the multidimensional upscaling setting for ImageNet 128, where the total parameter count reaches 650M (the decoder-only network used to model the first slice has 150M parameters).

\begin{table}[t]
\label{table:hparam_table}
\begin{center}
\begin{tabular}{ccc}

& ImageNet (32, 64, 128, 256) & CelebA HQ \\
\hline
\hline
\bf{Optimization} & & \\
batch size & (1024, 2048, 2048, 2048) & 256 \\
learning rate & (sched, sched, 1e-5, 1e-5) & 5e-5 \\
rmsprop momentum & 0.9 & 0.9 \\
rmsprop decay & 0.95 & 0.95 \\
rmsprop epsilon & 1e-8 &  1e-8 \\
polyak decay & 0.9999 & 0.9999 \\

\hline
\hline
\bf{Decoder} & & \\
PixelCNN layers & 15 & 15 \\
PixelCNN conv channels & (256, 256, 384, 384) & 128 \\
PixelCNN residual channels & 1280 & 1280 \\
PixelCNN nonlinearity & gated & gated \\
PixelCNN filter size & 3 & 3 \\
masked self-attention layers & 8 & 5 \\
attention heads & 10 & 5 \\
attention channels & 128 & 128 \\
attention ffn layer & ``parameter\_attention'' & ``parameter\_attention'' \\

\hline
\hline
\bf{Slice Embedder} & & \\
conv layers & 5 & 5 \\
conv filter size & 3 & 3 \\
conv channels & 256 & 256 \\
residual channels & 1024 & 1024 \\
nonlinearity & relu & relu \\
self-attention layers & (6, 6, 8, 8) & 6 \\
attention heads & (4, 4, 8, 8) & 4 \\
attention channels & (64, 64, 128, 128) & 64 \\
attention ffn layer & ``parameter\_attention'' & ``parameter\_attention'' \\

\hline
\hline
\bf{Number of parameters} & & \\
 & ( 150M,  150M,  250M,  250M) &  50M \\

\end{tabular}
\caption{SPN Hyperparameters. A learning rate marked ``sched'' utilizes a piecewise-constant schedule starting at 1e-4, and decreasing to 3e-5 and finally 1e-5 at training steps 50k and 100k respectively. The ``attention'' parameters listed are configurable hyperparameters of the open source Transformer implementation in \citet{tensor2tensor}. The parameter ``residual channels`` refers to the number of hidden units in residual convolution layers within the Slice Embedder or PixelCNN networks.}
\end{center}
\label{table:hpn_hparams}
\end{table}
 
\end{document}
