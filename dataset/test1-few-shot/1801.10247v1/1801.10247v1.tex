\documentclass{article} \usepackage{iclr2018_conference,times}
\usepackage{hyperref}
\usepackage{url}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{caption}

\usepackage{amsmath,amssymb,amsthm,bbm,mathtools}
\usepackage{algorithm,algorithmicx,algpseudocode}
\DeclareMathOperator{\cov}{Cov}
\DeclareMathOperator{\var}{Var}
\DeclareMathOperator{\mean}{E}
\DeclareMathOperator{\sgn}{sgn}
\newcommand{\cm}[1]{{\color{red} #1}}
\newcommand{\wpone}{w.p.}

\theoremstyle{plain}\newtheorem{theorem}{Theorem}\theoremstyle{plain}\newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{plain}\newtheorem{corollary}[theorem]{Corollary}
\theoremstyle{plain}\newtheorem{lemma}[theorem]{Lemma}


\title{FastGCN: Fast Learning with Graph Convolutional Networks via Importance Sampling}



\author{Jie Chen\thanks{These two authors contribute equally.}\,\,, \,
  Tengfei Ma\footnotemark[1]\,\,,\,
  Cao Xiao \\
IBM Research\\
\texttt{chenjie@us.ibm.com, Tengfei.Ma1@ibm.com, cxiao@us.ibm.com}
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy 

\begin{document}


\maketitle

\begin{abstract}
The graph convolutional networks (GCN) recently proposed by Kipf and Welling are an effective graph model for semi-supervised learning. This model, however, was originally designed to be learned with the presence of both training and test data. Moreover, the recursive neighborhood expansion across layers poses time and memory challenges for training with large, dense graphs. To relax the requirement of simultaneous availability of test data, we interpret graph convolutions as integral transforms of embedding functions under probability measures. Such an interpretation allows for the use of Monte Carlo approaches to consistently estimate the integrals, which in turn leads to a batched training scheme as we propose in this work---FastGCN. Enhanced with importance sampling, FastGCN not only is efficient for training but also generalizes well for inference. We show a comprehensive set of experiments to demonstrate its effectiveness compared with GCN and related models. In particular, training is orders of magnitude more efficient while predictions remain comparably accurate.
\end{abstract}


\section{Introduction}

Graphs are universal representations of pairwise relationship. Many real world data come naturally in the form of graphs; e.g., social networks, gene expression networks, and knowledge graphs.
To improve the performance of graph-based learning tasks, such as node classification and link prediction, recently much effort is made to extend well-established network architectures, including recurrent neural networks (RNN) and convolutional neural networks (CNN), to graph data; see, e.g., \cite{DBLP:journals/corr/BrunaZSL13,NIPS2015_5954,DBLP:journals/corr/LiTBZ15,DBLP:journals/corr/JainZSS15,DBLP:journals/corr/HenaffBL15,DBLP:journals/corr/NiepertAK16,DBLP:journals/corr/KipfW16,VAE2016}.

Whereas learning feature representations for graphs is an important subject among this effort, here, we focus on the feature representations for graph vertices. In this vein, the closest work that applies a convolution architecture is the graph convolutional network (GCN)~\citep{DBLP:journals/corr/KipfW16,VAE2016}. Borrowing the concept of a convolution filter for image pixels or a linear array of signals, GCN uses the connectivity structure of the graph as the filter to perform neighborhood mixing. The architecture may be elegantly summarized by the following expression:

where  is some normalization of the graph adjacency matrix,  contains the embedding (rowwise) of the graph vertices in the th layer,  is a parameter matrix, and  is nonlinearity.

As with many graph algorithms, the adjacency matrix encodes the pairwise relationship for both training and test data. The learning of the model as well as the embedding is performed for both data simultaneously, at least as the authors proposed. For many applications, however, test data may not be readily available, because the graph may be constantly expanding with new vertices (e.g. new members of a social network, new products to a recommender system, and new drugs for functionality tests). Such scenarios require an inductive scheme that learns a model from only a training set of vertices and that generalizes well to any augmentation of the graph.

A more severe challenge for GCN is that the recursive expansion of neighborhoods across layers incurs expensive computations in batched training. Particularly for dense graphs and powerlaw graphs, the expansion of the neighborhood for a single vertex quickly fills up a large portion of the graph. Then, a usual mini-batch training will involve a large amount of data for every batch, even with a small batch size. Hence, scalability is a pressing issue to resolve for GCN to be applicable to large, dense graphs.



To address both challenges, we propose to view graph convolutions from a different angle and interpret them as integral transforms of embedding functions under probability measures. Such a view provides a principled mechanism for inductive learning, starting from the formulation of the loss to the stochastic version of the gradient. Specifically, we interpret that graph vertices are iid samples of some probability distribution and write the loss and each convolution layer as integrals with respect to vertex embedding functions. Then, the integrals are evaluated through Monte Carlo approximation that defines the sample loss and the sample gradient. One may further alter the sampling distribution (as in importance sampling) to reduce the approximation variance.

The proposed approach, coined FastGCN, not only rids the reliance on the test data but also yields a controllable cost for per-batch computation. At the time of writing, we notice a newly published work GraphSAGE~\citep{DBLP:journals/corr/HamiltonYL17} that proposes also the use of sampling to reduce the computational footprint of GCN. Our sampling scheme is more economic, resulting in a substantial saving in the gradient computation, as will be analyzed in more detail in Section~\ref{sec:graphsage}. Experimental results in Section~\ref{sec:exp} indicate that the per-batch computation of FastGCN is more than an order of magnitude faster than that of GraphSAGE, while classification accuracies are highly comparable.

\section{Related Work}

Over the past few years, several graph-based convolution network models emerged for addressing applications of graph-structured data, such as the representation of molecules~\citep{NIPS2015_5954}. An important stream of work is built on spectral graph theory~\citep{DBLP:journals/corr/BrunaZSL13, DBLP:journals/corr/HenaffBL15, DBLP:journals/corr/DefferrardBV16}. They define parameterized filters in the spectral domain, inspired by graph Fourier transform. These approaches learn a feature representation for the whole graph and may be used for graph classification.

Another line of work learns embeddings for graph vertices, for which \cite{DBLP:journals/corr/GoyalF17} is a recent survey that covers comprehensively several categories of methods. A major category consists of factorization based algorithms that yield the embedding through matrix factorizations; see, e.g., \cite{Roweis2323,Belkin:2001:LES:2980539.2980616,Ahmed:2013:DLN:2488388.2488393,Cao:2015:GLG:2806416.2806512,Ou:2016:ATP:2939672.2939751}. These methods learn the representations of training and test data jointly. Another category is random walk based methods~\citep{Perozzi:2014:DOL:2623330.2623732,Grover:2016:NSF:2939672.2939754} that compute node representations through exploration of neighborhoods. LINE~\citep{Tang:2015:LLI:2736277.2741093} is also such a technique that is motivated by the preservation of the first and second-order proximities. Meanwhile, there appear a few deep neural network architectures, which better capture the nonlinearity within graphs, such as SDNE~\citep{Wang:2016:SDN:2939672.2939753}. As motivated earlier, GCN~\citep{DBLP:journals/corr/KipfW16} is the model on which our work is based.

The most relevant work to our approach is GraphSAGE~\citep{DBLP:journals/corr/HamiltonYL17}, which learns node representations through aggregation of neighborhood information. One of the proposed aggregators employs the GCN architecture. The authors also acknowledge the memory bottleneck of GCN and hence propose an ad hoc sampling scheme to restrict the neighborhood size. Our sampling approach is based on a different and more principled formulation. The major distinction is that we sample vertices rather than neighbors. The resulting computational savings are analyzed in Section~\ref{sec:graphsage}.


\section{Training and Inference through Sampling}\label{sec:sampling}

One striking difference between GCN and many standard neural network architectures is the lack of independence in the sample loss. Training algorithms such as SGD and its batch generalization are designed based on the additive nature of the loss function with respect to independent data samples. For graphs, on the other hand, each vertex is convolved with all its neighbors and hence defining a sample gradient that is efficient to compute is beyond straightforward.

Concretely, consider the standard SGD scenario where the loss is the expectation of some function  with respect to a data distribution :

Here,  denotes the model parameter to be optimized. Of course, the data distribution is generally unknown and one instead minimizes the empirical loss through accessing  iid samples :

In each step of SGD, the gradient is approximated by , an (assumed) unbiased sample of . One may interpret that each gradient step makes progress toward the sample loss . The sample loss and the sample gradient involve only one single sample .

For graphs, one may no longer leverage the independence and compute the sample gradient  by discarding the information of 's neighboring vertices and their neighbors, recursively. We therefore seek an alternative formulation. In order to cast the learning problem under the same sampling framework, let us assume that there is a (possibly infinite) graph  with the vertex set  associated with a probability space , such that for the given graph , it is an induced subgraph of  and its vertices are iid samples of  according to the probability measure . For the probability space,  serves as the sample space and  may be any event space (e.g., the power set ). The probability measure  defines a sampling distribution.

To resolve the problem of lack of independence caused by convolution, we interpret that each layer of the network defines an embedding function of the vertices (random variable) that are tied to the same probability measure but are independent. See Figure~\ref{fig:architecture}. Specifically, recall the architecture of GCN

For the functional generalization, we write

Here,  and  are independent random variables, both of which have the same probability measure . The function  is interpreted as the embedding function from the th layer. The embedding functions from two consecutive layers are related through convolution, expressed as an integral transform, where the kernel  corresponds to the  element of the matrix . The loss is the expectation of  for the final embedding . Note that the integrals are not the usual Riemann--Stieltjes integrals, because the variables  and  are graph vertices but not real numbers; however, this distinction is only a matter of formalism.

\begin{figure}[t]
\centering
\includegraphics[width = .8\linewidth]{GCN_and_sampling_crop.pdf}
\caption{Two views of GCN. On the left (graph convolution view), each circle represents a graph vertex. On two consecutive rows, a circle  is connected (in gray line) with circle  if the two corresponding vertices in the graph are connected. A convolution layer uses the graph connectivity structure to mix the vertex features/embeddings. On the right (integral transform view), the embedding function in the next layer is an integral transform (illustrated by the orange fanout shape) of the one in the previous layer. For the proposed method, all integrals (including the loss function) are evaluated by using Monte Carlo sampling. Correspondingly in the graph view, vertices are subsampled in a bootstrapping manner in each layer to approximate the convolution. The sampled portions are collectively denoted by the solid blue circles and the orange lines.}
\label{fig:architecture}
\end{figure}

Writing GCN in the functional form allows for evaluating the integrals in the Monte Carlo manner, which leads to a batched training algorithm and also to a natural separation of training and test data, as in inductive learning. For each layer , we use  iid samples  to approximately evaluate the integral transform~\eqref{eqn:h1}; that is,

with the convention .
Then, the loss  in~\eqref{eqn:h2} admits an estimator

The follow result establishes that the estimator is consistent. The proof is a recursive application of the law of large numbers and the continuous mapping theorem; it is given in the appendix.

\begin{theorem}\label{thm:L}
If  and  are continuous, then

\end{theorem}

In practical use, we are given a graph whose vertices are already assumed to be samples. Hence, we will need bootstrapping to obtain a consistent estimate. In particular, for the network architecture~\eqref{eqn:GCN}, the output  is split into batches as usual. We will still use  to denote a batch of vertices, which come from the given graph. For each batch, we sample (with replacement) uniformly each layer and obtain samples , , . Such a procedure is equivalent to uniformly sampling the rows of  for each . Then, we obtain the batch loss

where, recursively,

Here, the  inside the activation function  is the number of vertices in the given graph and is used to account for the normalization difference between the matrix form~\eqref{eqn:GCN} and the integral form~\eqref{eqn:h1}. The corresponding batch gradient may be straightforwardly obtained through applying the chain rule on each . See Algorithm~\ref{algo:mini.batch}.

\begin{algorithm}[ht]
  \caption{FastGCN batched training (one epoch)}
  \label{algo:mini.batch}
  \begin{algorithmic}[1]
    \For{each batch}
    \State For each layer , sample uniformly  vertices 
    \For{each layer } \Comment{Compute batch gradient }
    \State If  is sampled in the next layer, 
    \EndFor
    \State 
    \Comment{SGD step}
    \EndFor
  \end{algorithmic}
\end{algorithm}


\subsection{Variance Reduction}
As for any estimator, one is interested in improving its variance. Whereas computing the full variance is highly challenging because of nonlinearity in all the layers, it is possible to consider each single layer and aim at improving the variance of the embedding function before nonlinearity. Specifically, consider for the th layer, the function  as an approximation to the convolution . When taking  samples , the sample average of  admits a variance that captures the deviation from the eventual loss contributed by this layer. Hence, we seek an improvement of this variance. Now that we consider each layer separately, we will do the following change of notation to keep the expressions less cumbersome:
\begin{center}
\renewcommand*{\arraystretch}{1.5}
\begin{tabular}{cccc}
\hline
& Function & Samples & Num.\ samples \\
\hline
Layer ; random variable  &
 &
 &
 \\
Layer ; random variable  &
 &
 &
 \\
\hline
\end{tabular}
\end{center}
Under the joint distribution of  and , the aforementioned sample average is

First, we have the following result.

\begin{proposition}\label{thm:E.Var}
The variance of  admits

where

\end{proposition}

The variance~\eqref{eqn:Var} consists of two parts. The first part  leaves little room for improvement, because the sampling in the  space is not done in this layer. The second part (the double integral), on the other hand, depends on how the 's in this layer are sampled. The current result~\eqref{eqn:Var} is the consequence of sampling 's by using the probability measure . One may perform importance sampling, altering the sampling distribution to reduce variance. Specifically, let  be the new probability measure, where the 's are drawn from.
We hence define the new sample average approximation

and the quantity of interest

Clearly, the expectation of  is the same as that of , regardless of the new measure . The following result gives the optimal .

\begin{theorem}\label{thm:E.Var2}
If

then the variance of  admits

where  is defined in Proposition~\ref{thm:E.Var}. The variance is minimum among all choices of .
\end{theorem}

A drawback of defining the sampling distribution  in this manner is that it involves , which constantly changes during training. It corresponds to the product of the embedding matrix  and the parameter matrix . The parameter matrix is updated in every iteration; and the matrix product is expensive to compute. Hence, the cost of computing the optimal measure  is quite high.

As a compromise, we consider a different choice of , which involves only . The following proposition gives the precise definition. The resulting variance may or may not be smaller than~\eqref{eqn:Var}. In practice, however, we find that it is almost always helpful.

\begin{proposition}\label{thm:E.Var3}
If

where  is defined in~\eqref{eqn:b}, then the variance of  admits

where  is defined in Proposition~\ref{thm:E.Var}.
\end{proposition}

With this choice of the probability measure , the ratio  is proportional to , which is simply the integral of  with respect to . In practical use, for the network architecture~\eqref{eqn:GCN}, we define a probability mass function for all the vertices in the given graph:

and sample  vertices  according to this distribution. From the expression of , we see that it has no dependency on ; that is, the sampling distribution is the same for all layers. To summarize, the batch loss  in~\eqref{eqn:L.mini} now is recursively expanded as

The major difference between~\eqref{eqn:L.mini.expand} and~\eqref{eqn:L.mini.expand2} is that the former obtains samples uniformly whereas the latter according to . Accordingly, the scaling inside the summation changes. The corresponding batch gradient may be straightforwardly obtained through applying the chain rule on each . See Algorithm~\ref{algo:mini.batch2}.

\begin{algorithm}[ht]
  \caption{FastGCN batched training (one epoch), improved version}
  \label{algo:mini.batch2}
  \begin{algorithmic}[1]
    \State For each vertex , compute sampling probability 
    \For{each batch}
    \State For each layer , sample  vertices  according to distribution 
    \For{each layer } \Comment{Compute batch gradient }
    \State If  is sampled in the next layer, 
    \EndFor
    \State 
    \Comment{SGD step}
    \EndFor
  \end{algorithmic}
\end{algorithm}


\subsection{Inference}\label{sec:inference}
The sampling approach described in the preceding subsection clearly separates out test data from training. Such an approach is inductive, as opposed to transductive that is common for many graph algorithms. The essence is to cast the set of graph vertices as iid samples of a probability distribution, so that the learning algorithm may use the gradient of a consistent estimator of the loss to perform parameter update. 
Then, for inference, the embedding of a new vertex may be either computed by using the full GCN architecture~\eqref{eqn:GCN}, or approximated through sampling as is done in parameter learning. Generally, using the full architecture is more straightforward and easier to implement.


\subsection{Comparison with GraphSAGE}\label{sec:graphsage}
GraphSAGE~\citep{DBLP:journals/corr/HamiltonYL17} is a newly proposed architecture for generating vertex embeddings through aggregating neighborhood information. It shares the same memory bottleneck with GCN, caused by recursive neighborhood expansion. To reduce the computational footprint, the authors propose restricting the immediate neighborhood size for each layer. Using our notation for the sample size, if one samples  neighbors for each vertex in the th layer, then the size of the expanded neighborhood is, in the worst case, the product of the 's. On the other hand, FastGCN samples vertices rather than neighbors in each layer. Then, the total number of involved vertices is at most the sum of the 's, rather than the product. See experimental results in Section~\ref{sec:exp} for the order-of-magnitude saving in actual computation time.



\section{Experiments}\label{sec:exp}
We follow the experiment setup in \cite{DBLP:journals/corr/KipfW16} and \cite{DBLP:journals/corr/HamiltonYL17} to demonstrate the effective use of FastGCN, comparing with the original GCN model as well as GraphSAGE, on the following benchmark tasks: (1) classifying research topics using the Cora citation data set \citep{McCallum:2000:ACI:593959.594002}; (2) categorizing academic papers with the Pubmed database; and (3) predicting the community structure of a social network modeled with Reddit posts. These data sets are downloaded from the accompany websites of the aforementioned references. The graphs have increasingly more nodes and higher node degrees, representative of the large and dense setting under which our method is motivated. Statistics are summarized in Table~\ref{tb: dataset_fact}. We adjusted the training/validation/test split of Cora and Pubmed to align with the supervised learning scenario. Specifically, all labels of the training examples are used for training, as opposed to only a small portion in the semi-supervised setting~\citep{DBLP:journals/corr/KipfW16}. Such a split is  coherent with that of the other data set, Reddit, used in the work of GraphSAGE. Additional experiments using the original split of Cora and Pubmed are reported in the appendix.



\begin{table}[ht]
\begin{center}
\caption{Dataset Statistics}
\label{tb: dataset_fact}
\begin{tabular}{cccccc}
\hline
 Dataset &  Nodes &  Edges &  Classes &  Features &  Training/Validation/Test \\
\hline
Cora &  &  &  &  &  \\
Pubmed &  &  &  &  &  \\
Reddit &  &&  & &  \\
\hline
\end{tabular}
\end{center}
\end{table}



Implementation details are as following. All networks (including those under comparison) contain two layers as usual. The codes of GraphSAGE and GCN are downloaded from the accompany websites and the latter is adapted for FastGCN. Inference with FastGCN is done with the full GCN network, as mentioned in Section~\ref{sec:inference}. Further details are contained in the appendix.

We first consider the use of sampling in FastGCN. The left part of Table~\ref{tab:pre_comp} (columns under ``Sampling'') lists the time and classification accuracy as the number of samples increases. For illustration purpose, we equalize the sample size on both layers. Clearly, with more samples, the per-epoch training time increases, but the accuracy (as measured by using micro F1 scores) also improves generally.

\begin{figure}[ht]
\begin{minipage}{0.45\linewidth}
\centering
  \captionof{table}{Benefit of precomputing  for the input layer. Data set: Pubmed. Training time is in seconds, per-epoch (batch size 1024). Accuracy is measured by using micro F1 score.}
  \label{tab:pre_comp}
  \begin{tabular}{lcccc}
  \hline
   & \multicolumn{2}{c}{Sampling}& \multicolumn{2}{c}{Precompute}\\
         & Time & F1 & Time & F1\\\hline
     &  &  &  &  \\
     &  &  &  &  \\
     &  &  &  &  \\
     &  &  &  &  \\
  \hline
  \end{tabular}
\end{minipage}\begin{minipage}{0.55\linewidth}
\centering
\includegraphics[height=4.8cm]{Rplot3new2.pdf}
\captionof{figure}{Prediction accuracy: uniform versus importance sampling. The three data sets from top to bottom are ordered the same as Table~\ref{tb: dataset_fact}.}
\label{fig:uni_inp}
\end{minipage}
\end{figure}

An interesting observation is that given input features , the product  in the bottom layer does not change, which means that the chained expansion of the gradient with respect to  in the last step is a constant throughout training. Hence, one may precompute the product rather than sampling this layer to gain efficiency. The compared results are listed on the right part of Table~\ref{tab:pre_comp} (columns under ``Precompute''). One sees that the training time substantially decreases while the accuracy is  comparable. Hence, all the experiments that follow use precomputation. 

Next, we compare the sampling approaches for FastGCN: uniform and importance sampling. Figure~\ref{fig:uni_inp} summarizes the prediction accuracy under both approaches. It shows that importance sampling consistently yields higher accuracy than does uniform sampling. Since the altered sampling distribution (see Proposition~\ref{thm:E.Var3} and Algorithm~\ref{algo:mini.batch2}) is a compromise alternative of the optimal distribution that is impractical to use, this result suggests that the variance of the used sampling indeed is smaller than that of uniform sampling; i.e., the term~\eqref{eqn:Var3} stays closer to~\eqref{eqn:Var2} than does~\eqref{eqn:Var}. A possible reason is that  correlates with . Hence, later experiments will apply importance sampling.

We now demonstrate that the proposed method is significantly faster than the original GCN as well as GraphSAGE, while maintaining comparable prediction performance. See Figure~\ref{fig:time}. The bar heights indicate the per-batch training time, in the log scale. One sees that GraphSAGE is a substantial improvement of GCN for large and dense graphs (e.g., Reddit), although for smaller ones (Cora and Pubmed), GCN trains faster. FastGCN is the fastest, with at least an order of magnitude improvement compared with the runner up (except for Cora), and approximately two orders of magnitude speed up compared with the slowest. Here, the training time of FastGCN is with respect to the sample size that achieves the best prediction accuracy. As seen from the table on the right, this accuracy is highly comparable with the best of the other two methods.

\begin{figure}[ht]
\begin{minipage}{0.45\linewidth}
\centering
\includegraphics[height=3.8cm]{time_final_new.pdf}
\end{minipage}\begin{minipage}{0.55\linewidth}
\centering
\begin{tabular}{cccc}
\multicolumn{4}{c}{Micro F1 Score}\\
\hline
& Cora & Pubmed & Reddit\\
\hline
FastGCN          &0.850 &0.880 & 0.937\\
GraphSAGE-GCN    &0.829 &0.849 & 0.923\\
GraphSAGE-mean   &0.822 &0.888 & 0.946 \\
GCN (batched)    &0.851 &0.867 & 0.930\\
GCN (original)   &0.865 &0.875 & NA\\
\hline
\end{tabular}
\end{minipage}
\caption{Per-batch training time in seconds (left) and prediction accuracy (right). For timing, GraphSAGE refers to GraphSAGE-GCN in~\cite{DBLP:journals/corr/HamiltonYL17}. The timings of using other aggregators, such as GraphSAGE-mean, are similar. GCN refers to using batched learning, as opposed to the original version that is nonbatched; for more details of the implementation, see the appendix. The nonbatched version of GCN runs out of memory on the large graph Reddit. The sample sizes for FastGCN are 400, 100, and 400, respectively for the three data sets.}
\label{fig:time}
\end{figure}

\if0
\begin{table*}[ht]
\centering
  \caption{Uniform Sampling versus Importance Sampling}
  \label{tab:uni_inp}
  \begin{tabular}{llccccccccc}
  \hline
  &&\multicolumn{9}{c}{Micro-F1 Score}\\\hline
 \multirow{2}{*}{} &  & \multicolumn{3}{c}{Reddit}& \multicolumn{3}{c}{Cora}& \multicolumn{3}{c}{Pubmed} \\
    \multicolumn{2}{c}{\# Samples in Layer } & 25 & 50 & 100 & 25 & 50 & 100& 25 & 50 & 100\\\hline
\multicolumn{2}{c}{ Uniform Sampling} &   0.901&0.913  &0.922  & 0.828&0.834&0.843 &0.863&0.874&0.876\\
\multicolumn{2}{c}{Importance Sampling} & 0.911 &0.925  &0.930 &0.830 & 0.843&0.842& 0.879&0.880&0.880\\
\hline
  \end{tabular}
\end{table*}
\fi

In the discussion period, the authors of GraphSAGE offered an improved implementation of their codes and alerted that GraphSAGE was better suited for massive graphs. The reason is that for small graphs, the sample size (recalling that it is the product across layers) is comparable to the graph size and hence improvement is marginal; moreover, sampling overhead might then adversely affect the timing. For fair comparison, the authors of GraphSAGE kept the sampling strategy but improved the implementation of their original codes by eliminating redundant calculations of the sampled nodes. Now the per-batch training time of GraphSAGE compares more favorably on the smallest graph Cora; see Table~\ref{tab:GraphSAGE.new}. Note that this implementation does not affect large graphs (e.g., Reddit) and our observation of orders of magnitude faster training remains valid.

\begin{table}[ht]
\centering
\caption{Further comparison of per-batch training time (in seconds) with new implementation of GraphSAGE for small graphs. The new implementation is in PyTorch whereas the rest are in TensorFlow.}
\label{tab:GraphSAGE.new}
\begin{tabular}{cccc}
\hline
& Cora & Pubmed & Reddit\\
\hline
FastGCN                  &0.0084 & 0.0047 & 0.0129\\
GraphSAGE-GCN (old impl) &1.1630 & 0.3579 & 0.4260\\
GraphSAGE-GCN (new impl) &0.0380 & 0.3989 & NA \\
GCN (batched)            &0.0166 & 0.0815 & 2.1731\\
\hline
\end{tabular}
\end{table}


\section{Conclusions}
We have presented FastGCN, a fast improvement of the GCN model recently proposed by~\cite{DBLP:journals/corr/KipfW16} for learning graph embeddings. It generalizes transductive training to an inductive manner and also addresses the memory bottleneck issue of GCN caused by recursive expansion of neighborhoods. The crucial ingredient is a sampling scheme in the reformulation of the loss and the gradient, well justified through an alternative view of graph convoluntions in the form of integral transforms of embedding functions. We have compared the proposed method with additionally GraphSAGE~\citep{DBLP:journals/corr/HamiltonYL17}, a newly published work that also proposes using sampling to restrict the neighborhood size, although the two sampling schemes substantially differ in both algorithm and cost. Experimental results indicate that our approach is orders of magnitude faster than GCN and GraphSAGE, while maintaining highly comparable prediction performance with the two.

The simplicity of the GCN architecture allows for a natural interpretation of graph convolutions in terms of integral transforms. Such a view, yet, generalizes to many graph models whose formulations are based on first-order neighborhoods, examples of which include MoNet that applies to (meshed) manifolds~\citep{Monti2017}, as well as many message-passing neural networks (see e.g.,~\citet{Scarselli2009, Gilmer2017}). The proposed work elucidates the basic Monte Carlo ingredients for consistently estimating the integrals. When generalizing to other networks aforementioned, an additional effort is to investigate whether and how variance reduction may improve the estimator, a possibly rewarding avenue of future research.


\bibliography{iclr2018_conference}
\bibliographystyle{iclr2018_conference}


\appendix
\section{Proofs}
\begin{proof}[Proof of Theorem~\ref{thm:L}]
Because the samples  are iid, by the strong law of large numbers,

converges almost surely to . Then, because the activation function  is continuous, the continuous mapping theorem implies that  converges almost surely to . Thus,  converges almost surely to , where note that the probability space is with respect to the th layer and hence has nothing to do with that of the variable  or  in this statement. Similarly,

converges almost surely to  and thus to . A simple induction completes the rest of the proof.
\end{proof}


\begin{proof}[Proof of Proposition~\ref{thm:E.Var}]
Conditioned on , the expectation of  is

and the variance is  times that of , i.e.,

Instantiating~\eqref{eqn:proof.E1} and~\eqref{eqn:proof.Var1} with iid samples  and taking variance and expectation in the front, respectively, we obtain

and

Then, applying the law of total variance

we conclude the proof.
\end{proof}


\begin{proof}[Proof of Theorem~\ref{thm:E.Var2}]
Conditioned on , the variance of  is  times that of

i.e.,

Then, following the proof of Proposition~\ref{thm:E.Var}, the overall variance is

Hence, the optimal  must be proportional to . Because it also must integrate to unity, we have

in which case

\end{proof}


\begin{proof}[Proof of Proposition~\ref{thm:E.Var3}]
Conditioned on , the variance of  is  times that of

i.e.,

The rest of the proof follows that of Proposition~\ref{thm:E.Var}.
\end{proof}



\section{Additional Experiment Details}

\subsection{Baselines}
{\bf GCN}: The original GCN cannot work on very large graphs (e.g., Reddit). So we modified it into a batched version by simply removing the sampling in our FastGCN (i.e., using all the nodes instead of sampling a few in each batch). 
For relatively small graphs (Cora and Pubmed), we also compared the results with the original GCN.

{\bf GraphSAGE}: For training time comparison, we use GraphSAGE-GCN that employs GCN as the aggregator. It is also the fastest version among all choices of the aggregators. For accuracy comparison, we also compared with GraphSAGE-mean. We used the codes from \url{https://github.com/williamleif/GraphSAGE}. Following the setting of~\cite{DBLP:journals/corr/HamiltonYL17}, we use two layers with neighborhood sample sizes  and . For fair comparison with our method, the batch size is set to be the same as FastGCN, and the hidden dimension is 128.

\subsection{Experiment Setup}
{\bf Datasets:}
The Cora and Pubmed data sets are from \url{https://github.com/tkipf/gcn}. As we explained in the paper, we kept the validation index and test index unchanged but changed the training index to use all the remaining nodes in the graph. The Reddit data is from \url{http://snap.stanford.edu/graphsage/}.

{\bf Experiment Setting:}
We preformed hyperparameter selection for the learning rate and model dimension. We swept learning rate in the set \{0.01, 0.001, 0.0001\}. The hidden dimension of FastGCN for Reddit is set as 128, and for the other two data sets, it is 16. The batch size is 256 for Cora and Reddit, and 1024 for Pubmed. Dropout rate is set as 0. We use Adam as the optimization method for training. In the test phase, we use the trained parameters and all the graph nodes instead of sampling. For more details please check our codes in a temporary git repository \url{https://github.com/matenure/FastGCN}.


{\bf Hardware:}
Running time is compared on a single machine with 4-core 2.5 GHz Intel Core i7, and 16G RAM.




\section{Additional Experiments}

\subsection{Training Time Comparison}
Figure~\ref{fig:time} in the main text compares the per-batch training time for different methods. Here, we list the total training time for reference. It is impacted by the convergence of SGD, whose contributing factors include learning rate, batch size, and sample size. See Table~\ref{tab:total.training.time}. Although the orders-of-magnitude speedup of per-batch time is slightly weakened by the convergence speed, one still sees a substantial advantage of the proposed method in the overall training time. Note that even though the original GCN trains faster than the batched version, it does not scale because of memory limitation. Hence, a fair comparison should be gauged with the batched version. We additionally show in Figure~\ref{fig:accuracy.vs.time} the evolution of prediction accuracy as training progresses.

\begin{table}[ht]
\centering
\caption{Total training time (in seconds).}
\label{tab:total.training.time}
\begin{tabular}{crrr}
\hline
& \multicolumn{1}{c}{Cora} & \multicolumn{1}{c}{Pubmed} & \multicolumn{1}{c}{Reddit}\\
\hline
FastGCN          &  2.7 &  15.5 &   638.6\\
GraphSAGE-GCN    & 72.4 & 259.6 &  3318.5\\
GCN (batched)    &  6.9 & 210.8 & 58346.6\\
GCN (original)   &  1.7 &  21.4 & \multicolumn{1}{c}{NA}\\
\hline
\end{tabular}
\end{table}

\begin{figure}[ht]
\centering
\begin{minipage}{0.33\linewidth}
\centering
\includegraphics[width=\linewidth]{train-accuracy-time-cora-new.pdf}
\end{minipage}\begin{minipage}{0.33\linewidth}
\centering
\includegraphics[width=\linewidth]{train-accuracy-time-pubmed-new.pdf}
\end{minipage}\begin{minipage}{0.33\linewidth}
\centering
\includegraphics[width=\linewidth]{train-accuracy-time-reddit-new.pdf}
\end{minipage}\\
\centering
\begin{minipage}{0.33\linewidth}
\centering
\includegraphics[width=\linewidth]{accuracy-time-cora-new.pdf}
\end{minipage}\begin{minipage}{0.33\linewidth}
\centering
\includegraphics[width=\linewidth]{accuracy-time-pubmed-new.pdf}
\end{minipage}\begin{minipage}{0.33\linewidth}
\centering
\includegraphics[width=\linewidth]{accuracy-time-reddit-new.pdf}
\end{minipage}\caption{Training/test accuracy versus training time. From left to right, the data sets are Cora, Pubmed, and Reddit, respectively.}
\label{fig:accuracy.vs.time}
\end{figure}



\subsection{Original Data Split for Cora and Pubmed}

As explained in Section~\ref{sec:exp}, we increased the number of labels used for training in Cora and Pubmed, to align with the supervised learning setting of Reddit. For reference, here we present results by using the original data split with substantially fewer training labels. We also fork a separate version of FastGCN, called FastGCN-transductive, that uses both training and test data for learning. See Table~\ref{tab:original.split}.

The results for GCN are consistent with those reported by~\cite{DBLP:journals/corr/KipfW16}. Because labeled data are scarce, the training of GCN is quite fast. FastGCN beats it only on Pubmed. The accuracy results of FastGCN are inferior to GCN, also because of the limited number of training labels. The transductive version FastGCN-transductive matches the accuracy of that of GCN. The results for GraphSAGE are curious. We suspect that the model significantly overfits the data, because perfect training accuracy (i.e., 1) is attained.

One may note a subtlety that the training of GCN (original) is slower than what is reported in Table~\ref{tab:total.training.time}, even though fewer labels are used here. The reason is that we adopt the same hyperparameters as in~\cite{DBLP:journals/corr/KipfW16} to reproduce the F1 scores of their work, whereas for Table~\ref{tab:total.training.time}, a better learning rate is found that boosts the performance on the new split of the data, in which case GCN (original) converges faster.

\begin{table}[ht]
\centering
\caption{Total training time and test accuracy for Cora and Pubmed, original data split. Time is in seconds.}
\label{tab:original.split}
\begin{tabular}{crcrc}
\hline
& \multicolumn{2}{c}{Cora}& \multicolumn{2}{c}{Pubmed}\\
& \multicolumn{1}{c}{Time} & F1 & \multicolumn{1}{c}{Time} & F1\\\hline
FastGCN              &   2.52 & 0.723 &  0.97 & 0.721\\
FastGCN-transductive &   5.88 & 0.818 &  8.97 & 0.776\\
GraphSAGE-GCN        & 107.95 & 0.334 & 39.34 & 0.386\\
GCN (original)       &   2.18 & 0.814 & 32.65 & 0.795\\
\hline
\end{tabular}
\end{table}

\section{Convergence}

Strictly speaking, the training algorithms proposed in Section~\ref{sec:sampling} do not precisely follow the existing theory of SGD, because the gradient estimator, though consistent, is biased. In this section, we fill the gap by deriving a convergence result. Similar to the case of standard SGD where the convergence rate depends on the properties of the objective function, here we analyze only a simple case; a comprehensive treatment is out of the scope of the present work. For convenience, we will need a separate system of notations and the same notations appearing in the main text may bear a different meaning here. We abbreviate ``with probability one'' to ``\wpone'' for short.

We use  to denote the objective function and assume that it is differentiable. Differentiability is not a restriction because for the nondifferentiable case, the analysis that follows needs simply change the gradient to the subgradient. The key assumption made on  is that it is -strictly convex; that is, there exists a positive real number  such that

for all  and . We use  to denote the gradient estimator. Specifically, denote by , with  being a random variable, a strongly consistent estimator of ; that is,

Moreover, we consider the SGD update rule

where  is an indepedent sample of  for the th update. The following result states that the update converges on the order of .

\begin{theorem}
Let  be the \textup{(}global\textup{)} minimum of  and assume that  is uniformly bounded by some constant . If , then there exists a sequence  with

such that  \wpone.
\end{theorem}

\begin{proof}
Expanding  by using the update rule~\eqref{eqn:update.rule}, we obtain

where . Because for a given ,  converges to  \wpone, we have that conditioned on ,

On the other hand, applying the strict convexity~\eqref{eqn:strictly.convex}, by first taking  and then taking , we obtain

Substituting~\eqref{eqn:le} to~\eqref{eqn:to}, we have that conditioned on ,

for some

Now consider the randomness of  and apply induction. For the base case , the theorem clearly holds with . If the theorem holds for , let . Then, taking the probabilistic limit of  on both sides of~\eqref{eqn:Ck}, we have that  converges \wpone\ to some limit that is less than or equal to . Letting this limit be , we complete the induction proof.
\end{proof}


\end{document}
