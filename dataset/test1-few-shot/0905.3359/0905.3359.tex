

\documentclass[11pt]{article}\usepackage{amsmath}
\usepackage{subfigure}
\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{algorithm}
\usepackage{algorithmic}\setcounter{MaxMatrixCols}{30}
\providecommand{\U}[1]{\protect\rule{.1in}{.1in}}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{acknowledgement}[theorem]{Acknowledgement}
\newtheorem{axiom}[theorem]{Axiom}
\newtheorem{case}[theorem]{Case}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{conclusion}[theorem]{Conclusion}
\newtheorem{condition}[theorem]{Condition}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{criterion}[theorem]{Criterion}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}
\newtheorem{exercise}[theorem]{Exercise}
\newtheorem{lemma}[theorem]{Lemma}
{\theoremstyle{definition}
\newtheorem{notation}[theorem]{Notation}
}
\newtheorem{problem}[theorem]{Problem}
\newtheorem{proposition}[theorem]{Proposition}
{\theoremstyle{definition}
\newtheorem{remark}[theorem]{Remark}
}
\newtheorem{solution}[theorem]{Solution}
\newtheorem{summary}[theorem]{Summary}
\setlength{\textwidth}{6.75in}
\setlength{\textheight}{9.25in}
\setlength{\oddsidemargin}{-.125 in}
\setlength{\topmargin}{-.90 in}
\begin{document}

\title{Searching the Nodes of a Graph: Theory and Algorithms}
\author{Ath. Kehagias, G. Hollinger and A. Gelastopoulos\thanks{emails:
kehagiat@auth.gr, geoff.hollinger@gmail.com, alexgelas@hotmail.com.}}
\date{19 May, 2009}
\maketitle

\begin{abstract}
One or more \emph{searchers} must \emph{capture} an invisible \emph{evader}
hiding in the \emph{nodes} of a graph. We study this version of the
\emph{graph search} problem under additional restrictions, such as
monotonicity and connectedness. We emphasize that we study \emph{node search},
i.e., the capture of a \emph{node-located }evader; this problem has so far
received much less attention than \emph{edge search}, i.e., the capture of an
\emph{edge-located} evader.

We show that in general graphs the problem of node search is easier than that
of edge search, Namely, every edge clearing search is also node clearing, but
the converse does not hold in general (however node search is NP-complete,
just like edge search). Then we concentrate on the \emph{internal monotone
connected }(IMC)\ node search of \emph{trees} and show that it is essentially
equivalent to IMC\ edge search; hence Barriere's tree search algorithm
\cite{Barriere1}, originally designed for edge search, can also be used for
node search.

We return to IMC\ node search on general graphs and present (several variants
of) a new algorithm: \emph{GSST }(Guaranteed Search by Spanning Tree). GSST
clears a graph  by performing all its clearing moves along a
spanning tree  of . Because spanning trees can be
generated and cleared very quickly, GSST\ can test a large number of spanning
trees and find one which clears  with a small (though not
necessarily minimal)\ number of searchers. We prove the existence of
probabilistically complete variants of GSST (i.e., these variants are
guaranteed to find a minimal IMC node clearing schedule if run for
sufficiently long time). Our experiments also indicate that GSST can
efficiently node-clear large graphs given only a small running time. \emph{An
implementation of GSST\ }(running on Windows and Linux computers) \emph{is
also provided and made publicly available}.

\end{abstract}

\section{Introduction}

\label{sec01}

In this paper we study a variant of \emph{graph search}. Our motivation comes
from applied robotics problems. As an introduction, consider the following two
problems, which can both be modeled as graph searches.

\begin{enumerate}
\item An \emph{evader} is hiding in a \emph{building} and a team of one or
more \emph{searchers} are trying to \emph{capture} him. The building is
represented by a graph : nodes are \emph{rooms} and edges are
\emph{doors} between rooms. Both searchers and evader occupy the nodes of the
graph and move from node to node by sliding along the edges. The evader is
captured when he is located in the same node as a searcher. It is assumed that
the evader has the following characteristics:\ (a)\ he wants to avoid capture,
(b)\ he is invisible to the searchers (unless he is located in the same node
as one of them), (c)\ he is always aware of the searchers' locations and
(d)\ he is arbitrarily fast.

\item An evader and a team of searchers are located inside a \emph{cave}. The
cave is again represented by a graph : edges are \emph{tunnels}
and nodes are the \emph{intersections} of tunnels. The searchers move from
node to node, sliding along the edges; capture takes place if a searcher
slides along an edge occupied by the evader, or if the evader moves through a
node occupied by a searcher. The previously mentioned properties of the evader
are assumed to hold in this case as well.
\end{enumerate}

The two problems are very similar but differ in one important respect. In the
first problem the evader is assumed to reside in the \emph{nodes} of the graph
(the rooms); in the second problem he is assumed to reside in the \emph{edges}
(the tunnels). Accordingly, we will call the first problem \emph{node search}
and the second \emph{edge search}. Edge- or node-location of the evader is an
important aspect of the graph search problem and can be used to categorize the
related literature. Historically, research has concentrated on the problem of
\textquotedblleft\emph{edge-located} evader\textquotedblright. To the best of
our knowledge, very little work has been done on the problem of
\textquotedblleft\emph{node-located} evader\textquotedblright. Interestingly,
the term \textquotedblleft node search\textquotedblright\ has been used in the
past to denote a version of the graph search for edge-located evader
\cite{Kiroussis}. Hence, to avoid confusion, let us repeat that \emph{we use
\textquotedblleft node search\textquotedblright\ to denote the search for a
node-located evader}.\emph{ }

Another important aspect of the graph search problem is the \textquotedblleft
visibility\textquotedblright\ of the evader. Namely, we say that the evader is
\emph{visible} if the searchers always know his location; we say that the
evader is \emph{invisible} if the evaders may become aware of his location
only when he is in the same node (or edge) as they.

Additional aspects of the graph search include whether it is \emph{internal}
(the searchers can only move along the edges of the graph) or not (a searcher
can, in one step, move to any node of the graph -- we call this
\textquotedblleft\emph{teleporting}\textquotedblright), \emph{monotone }(the
evader can never return to a searched part of the graph) and \emph{connected}
(the searched parts form a connected subgraph). These terms will be defined
rigorously in Section \ref{sec02}.

We now present a brief overview of the graph search literature. Early papers
include \cite{Breisch} where the problem of cave searching was posed and
\cite{Parsons1} where the first mathematical study of the problem was
presented. The problem was independently rediscovered a little later in
\cite{Petrov}. The edge search problem was placed in the context of graph
theory in \cite{Megiddo}. The already mentioned \textquotedblleft node
search\textquotedblright\ variant \ (actually dealing with edge-located
evader)\ appeared a little earlier in \cite{Kiroussis}. Another variant,
called \textquotedblleft mixed search\textquotedblright\ (and again dealing
with edge-located evader)\ appeared in \cite{Bienstock} and was further
studied in \cite{Takahashi,Yang1}. The study of \emph{connected }edge search
started relatively recently; see \cite{Barriere1, Barriere2, Fomin,
Fraigniaud1, Fraigniaud2, Yang2}. There is very little published on
\textquotedblleft true\textquotedblright\ node search, i.e., the search for a
node-located evader. There is a considerable literature on pursuit of
\emph{visible} node-located evaders, which we will not discuss, since visible
evader search is outside the scope of the current paper; let us simply mention
that an important early paper is \cite{Nowakowski}. Graph search is also
related to several \emph{graph parameters}, most notably \ \emph{pathwidth}
and \emph{vertex separation}. These connections are discussed in many papers,
e.g., in
\cite{BienstockReview,Dendris,Ellis,Kinnersley,Kiroussis,ThilikosParams}.
Finally there are several reviews of the graph search literature:\ an old and
deep one is \cite{BienstockReview}, a more recent one is \cite{Alspach} and a
very recent and very extensive one is \cite{FominThilikos}.

The above mentioned papers adopt a theoretical point of view. While there is
much discussion about graph search algorithms, we have found few actually
implemented algorithms which can tackle relatively large graphs (with the
exception of \emph{tree} search algorithms). A much more applied line of
research appears in the \emph{robotics} literature, for example in
\cite{Gerkey1,Gerkey2,Guibas,Lavalle} and the book \cite{LavalleBook}. These
papers present actual implementations of algorithms, as well as numerical and
even physical experiments, but they provide little (if any)\ theoretical
justification of their methods. In particular, the distinction between edge
and node search often appears to be misunderstood. We attempt to clarify this
distinction and also combine the robotics and graph theoretic points in two
technical reports we have previously published \cite{Hollinger1,Kehagias1}.

In the current paper we study graph search for an invisible, node-located
evader. We also examine connections to the problem of invisible, edge-located
evader. We do \emph{not} deal with the case of visible evader. We are mainly
interested in \emph{internal, monotone, connected }(IMC)\ node search. This
version of the problem is the one most relevant to robotics applications
which, as already stated, provide our main motivation. In general, we try to
provide a balanced combination of theory and implementation.

The main contribution of the paper is the introduction of (several variants
of)\ the node-search algorithm GSST (\emph{Guaranteed Search by Spanning
Tree}). This algorithm is presented in detail, theoretically motivated and
analyzed and also practically evaluated by a number of numerical
experiments\footnote{An implementation of the algorithm (for Windows and Linux
computers)\ is available in the public domain; for details see Appendix
\ref{secD}.}. The \emph{main idea }behind the algorithm is that every
IMC\ node search generates a spanning tree of the graph; conversely, every
spanning tree can be used to perform a node search. Trees can be searched much
more efficiently than general graphs; GSST\ exploits this fact to quickly
compute a large number of searches and then output the one which requires the
least number of searchers\footnote{In fact GSST\ is an \textquotedblleft
anytime\textquotedblright\ algorithm \cite{Zilberstein}. Namely, the longer it
runs the better solutions are provided, but a reasonable solution becomes
available even in the initial stages of the algorithm.}. \ Our experiments
also indicate that GSST can efficiently node-clear large graphs in a small
running time. From the theoretical point of view, we establish several results
about node search and its relation to edge search. These results are used to
motivate the GSST\ algorithm and also to prove that some variants of GSST are
probabilistically complete (i.e., they are guaranteed to find a minimal IMC
node clearing schedule if given sufficient time).

The paper is organized as follows.\ Preliminary concepts and notation are
introduced in Section \ref{sec02}; edge search and node search are compared in
Section \ref{sec03}; IMC\ node and edge search on \emph{trees} is studied in
Section \ref{sec04}; IMC\ node search on general graphs is studied in Section
\ref{sec05} where the GSST\ search algorithm is also introduced; the algorithm
is evaluated by numerical experiments in Section \ref{sec06}; conclusions and
future research directions appear in Section \ref{sec07}. Some edge search
results by Barriere et al. \cite{Barriere1,Barriere2} are presented in
Appendix \ref{secA}; the connection of node search to \emph{mixed} edge search
is discussed in Appendix \ref{secB}; connections to \emph{pathwidth} are
discussed in Appendix \ref{secC}; an implementation of GSST as an actual
executable program (which runs on Windows and Linux computers)\ is discussed
in Appendix \ref{secD}.

\section{Preliminaries}

\label{sec02}

\subsection{Basic concepts and notation}

We denote graphs by boldface letters, e.g. 
where  is the \emph{node set} and  is the \emph{edge set}. We will
always label the nodes of  as 
(hence the graph contains  nodes, i.e. ). Edges
are denoted as  where ; often we will write
 instead, for simplicity, but note that  and  are the same edge
(i.e. we study \emph{undirected} graphs). We only consider connected graphs
without loops or multiple edges. \emph{Also, to avoid some trivial cases, we
will always consider graphs with at least one edge (and at least two nodes).}

Nodes  are said to be \emph{neighbors} iff .

Given a node sequence , where  for 
 we say that  is

\begin{enumerate}
\item a \emph{path} iff  for  and ;

\item a \emph{cycle} iff  for  (and ) except that .
\end{enumerate}

A \emph{tree} is a connected graph without any cycles. Equivalent definitions
are:\ a tree is a graph for which there is a unique path between every pair of
nodes; a tree is a connected graph with  nodes and  edges. The
\emph{leaves }of the tree are the nodes which have exactly one neighbor.

A \emph{rooted tree} is a tree with a distinguished node  called the
\emph{root }of the tree. Given a tree , we
will denote the same tree rooted at  by . Take any node  and let  be the unique path from  to ; then
 is the \emph{parent }of ;  is the \emph{child }of
. Given a node , its children, their children and so on are the
\emph{descendants} of . Given a rooted tree  and a node , consider the node set

and the edge set
note that both  and  are determined
by \emph{both}  and . The graph  is a tree (a \emph{sub-tree }of ). The
\emph{rooted }tree  will be denoted by .

A \emph{search schedule} on the graph  is a
sequence of \emph{ordered }pairs of nodes:

subject to 
for . We call  the -th move (or
step)\ of the search schedule. The -th move can be any one of the following

\begin{enumerate}
\item \emph{placing }a searcher at node  (in which case  and ) or

\item \emph{sliding} a searcher from node  to node
 or

\item \emph{removing }a searcher from node  (in which case  and ).
\end{enumerate}

We will also use the more evocative notation , i.e. a searcher is moved from node  to
node . Moves of the form:  (a new searcher is introduced in
the graph)\ and  (a searcher is removed from the graph) involve
the fictitious \textquotedblleft source\ node\textquotedblright\ 0 (it is not
an element of ), in which searchers are kept whenever they are not actively
involved in the graph search; the evader does not have access to the source node.

Given a search , the number of searchers inside the graph at time
 will be denoted by . The maximum number
of searchers used by  will be denoted by , i.e.

These numbers must not be confused with the search number of a \emph{graph},
which will be defined in Section \ref{sec0202}.

Finally, we say that a node  is \emph{guarded} at time  iff a searcher
is located at  (at time ); otherwise we say  is \emph{unguarded}. \ A
path  is called \emph{n-unguarded }(node unguarded) iff
nodes  () are unguarded (at time ); otherwise it is
called \emph{n-guarded.} The path is called \emph{e-unguarded }(edge
unguarded) iff nodes  () are unguarded (at time ) and
e-guarded otherwise. It is easy to see that
The reason for the two different definitions is that the first pertains to
\emph{node} recontamination and the second to \emph{edge }recontamination, as
will be seen in Section \ref{sec0202}.

\subsection{Node and edge search}

\label{sec0202}

We repeat the assumptions introduced in Section \ref{sec01} regarding the
evader. Namely, the evader wants to avoid capture, he is invisible to the
searchers (unless located in the same node), he is always aware of the
searchers' locations and arbitrarily fast. The net result of all these
assumptions is that (in both node and edge search)\ the evader can (and will)
always avoid capture if an escape route is available. Hence, from the
searchers' point of view, we can think of graph search as a process of
eliminating escape routes. This is expressed as follows:\ 

\begin{enumerate}
\item a node / edge is \emph{dirty} if it can \emph{possibly} contain the
evader and \emph{clear} otherwise (e.g., a node occupied by a searcher is clear);

\item a previously clear node / edge can become dirty (e.g., when a previously
guarded path between a clear and a dirty node becomes unguarded) -- this is
called \emph{recontamination};

\item graph search is the process of gradually decreasing the \emph{dirty set}
(of nodes or edges) until it becomes the empty set (i.e., the evader has no
escape route left).
\end{enumerate}

This is a \emph{worst case approach }which essentially eliminates the evader
from the graph search, introducing in his place the dirty set. We can think of
node (edge) search as a \emph{one-player} \textquotedblleft node
game\textquotedblright\ (\textquotedblleft edge game\textquotedblright). In
both these games the player controls all searchers, much like pieces in a game
of chess. We now present the rules of the two games. For reasons which will be
explained presently, we substitute the terms \textquotedblleft
clear\textquotedblright\ and \textquotedblleft dirty\textquotedblright\ with
the terms \textquotedblleft n-clear\textquotedblright\ and \textquotedblleft
n-dirty\textquotedblright\ (in the node game) and \textquotedblleft
e-clear\textquotedblright\ and \textquotedblleft e-dirty\textquotedblright \ (in the edge game).

\begin{center}
--------------------------------------------------------------------------------------------------

\textbf{Rules of the Node Game}
\end{center}

\begin{enumerate}
\item[\textbf{{N0}}] At time  all nodes are \emph{n-dirty} and no
searcher is located in the graph.

\item[\textbf{N1}] At every time  the player performs \emph{one} of
the following moves:

\begin{enumerate}
\item[\textbf{{N1a}}] place a searcher on a node,

\item[\textbf{{N1b}}] remove a searcher from a node,

\item[\textbf{{N1c}}] slide a searcher along one edge.
\end{enumerate}

\item[\textbf{{N2}}] An n-dirty node becomes \emph{n-clear }when occupied by a searcher.

\item[\textbf{{N3}}] An n-clear node  becomes n-dirty when it is connected
to to an n-dirty node  by an \emph{n-unguarded\ path}.

\item[\textbf{{N4}}] An edge is n-dirty if it is adjacent to an n-dirty node;
otherwise it is clear.

\item[\textbf{{N5}}] The game is concluded when all nodes (and consequently
also all edges) are n-clear.
\end{enumerate}

\begin{center}
--------------------------------------------------------------------------------------------------

\textbf{Rules of the Edge Game}
\end{center}

\begin{enumerate}
\item[\textbf{{E0}}] At time  all edges are \emph{e-dirty} and no
searcher is located in the graph.

\item[\textbf{E1}] At every time  the player performs \emph{one} of
the following moves:

\begin{enumerate}
\item[\textbf{{E1a}}] place a searcher on a node,

\item[\textbf{{E1b}}] remove a searcher from a node,

\item[\textbf{{E1c}}] slide a searcher along one edge.
\end{enumerate}

\item[\textbf{{E2}}] An e-dirty edge becomes e-clear when a searcher slides
along the edge.

\item[\textbf{{E3}}] An e-clear edge  becomes e-dirty when it is connected
to to a e-dirty edge  by an \emph{e-unguarded\ path}.

\item[\textbf{{E4}}] A node is e-dirty if it is unguarded and adjacent to an
e-dirty edge; otherwise it is e-clear.

\item[\textbf{{E5}}] The game is concluded when all edges (and consequently
also all nodes)\ are e-clear.
\end{enumerate}

\begin{center}
--------------------------------------------------------------------------------------------------
\end{center}

\begin{remark}
\label{prp0201}The reason for using \textquotedblleft
n-clear\textquotedblright\ and \textquotedblleft e-clear\textquotedblright \ (instead of simply \textquotedblleft clear\textquotedblright)\ is that an
edge can be clear in the node game and dirty in the edge game. An example will
illustrate this point. Consider the graph of Fig.1 and the search schedule
   
 If this schedule is executed in a node game, after the final
move all nodes are n-clear and so all edges are also n-clear. But in an edge
game, after the final move, edge  has still not been
traversed and hence it is still e-dirty. More generally, while
\textquotedblleft n-clear\textquotedblright\ and \textquotedblleft
e-clear\textquotedblright\ refer to similar physical situations, there is no a
priori reason that their mathematical definitions are equivalent (in Section
\ref{sec04} we will show that they \emph{are }equivalent \emph{provided
certain conditions are satisfied}).
\end{remark}

\begin{figure}[h]
\centering
\includegraphics[width=2.25in]{pix/fig01.pdf}\caption{A graph in which node
clearing and edge clearing are not equivalent. For example, placing a searcher
into node 0 (), then placing a second searcher at 1 and sending
him through 2, 4, 3 (, , ,
) is node clearing but not edge clearing.}\label{fig:graph1}\end{figure}

\begin{remark}
\label{prp0202}Note that in the edge game clear edges are \textquotedblleft
recorded\textquotedblright\ at the completion of each move. This is important
to note in the case that an edge is e-cleared and e-dirtied \emph{during the
same move }(i.e. for a single value of ). To clarify this, suppose that in
the graph of Fig.1 the following moves are executed:\  at
;  at . In this case edge  is
first e-cleared (because traversed)\ and then e-dirtied, \emph{both during
}. After completion of the second move, \emph{edge } \emph{is e-dirty}.
\end{remark}

We now introduce more detailed notation regarding clear/dirty nodes/edges. For
the node game we will use the following notation.


We use exactly analogous notation for the edge game, but with an  (rather
than ) subscript:, , , ,
. Obviously we have



\begin{remark}
\label{prp0203}The n-clear / e-clear graph definitions are consistent, i.e.
 /

\emph{are} graphs. More specifically: \ 
\end{remark}

\begin{enumerate}
\item in the node game  consists of the
n-clear nodes and all edges between such nodes (these are exactly the set
);

\item in the edge game  consists of the
e-clear edges and none of these can be left \textquotedblleft
dangling\textquotedblright, i.e. if  then
, (we will prove this as Lemma
\ref{prp0301} in Section \ref{sec03}); in addition  may contain guarded nodes adjacent to e-dirty edges; such nodes may appear
as disconnected components of .
\end{enumerate}

In the current paper we will concentrate on some \emph{restricted} versions of
the edge and node games. More specifically, the restrictions concern the
allowable search schedules and they are the following.

\begin{enumerate}
\item We call a search schedule \emph{rooted }iff searchers can be placed only
into a single, prespecified node , called the \emph{root} of the search.

\item We call a search schedule \emph{internal }iff searchers once placed into
the graph (a) can only move along the edges and (b)\ are never removed from
the graph. In other words, \textquotedblleft teleporting\textquotedblright \ (the arbitrary movement of a searcher from one node to another, irrespective
of the graph connectivity) is not allowed\footnote{Since no searchers are ever
removed during an internal search , we have  where  is
the length of the search.}.

\item In the node game we call a search schedule  \emph{monotone
}iff the clear node set is never decreasing:  for all  In other words, once a
node is n-cleared it never becomes n-dirty again. The definition is similar
for the edge game; i.e.,  is monotone in the edge game iff
 for all
\footnote{An important detail is worth mentioning at this point. There is
a property, call it \emph{strong monotonicity}, which characterizes schedules
in which a \emph{traversed} edge never becomes e-dirty again. The schedule of
Remark \ref{prp0202}. is monotone (since ) but \emph{not }strongly monotone. We
stress this detail mostly for the sake of completness; in what follows we will
\emph{not} use strong monotonicity.} \ 

\item In the node game (resp. edge game)\ we call a search schedule
\emph{connected }iff the clear graph 
(resp. )\ is connected for .
\end{enumerate}

In Section \ref{sec03} we will study general, unrestricted graph search; in
the remaining sections we will concentrate on internal monotone (\emph{IM}),
internal connected (\emph{IC})\ and, especially, internal monotone connected
(\emph{IMC})\ node / edge search. Our focus originates in our interest in
practical \emph{pursuit / evasion }problems which arise in robotics. The
nature of the problem dictates the restrictions on the search.

\begin{enumerate}
\item The internality constraint arises from the fact that a robot cannot
\textquotedblleft teleport\textquotedblright; it can only move through rooms
and doors connecting these rooms; in the graph model of the physical situation
this is reflected by the use of edge-sliding moves only.

\item Similarly, rootedness reflects the fact that usualy an environment has a
single entrance through which robots must enter.

\item Connectedness and monotonicity are desirable (but not mandatory)
characteristics of robotic search. For example, in a hostile environment it is
preferrable that the cleared area consists of a single connected region, which
is easier to guard and control than multiple regions. Similarly, if a high
cost is associated with clearing an area, it is desirable that this area is
cleared only once, i.e., that the search is monotone.
\end{enumerate}

A given graph  with  nodes can always be node-cleared using 
searchers:\ just place one searcher in every node. Usually  can be
cleared with much fewer searchers; the \emph{node search number} of
, denoted by , is the minimum
number of searchers required to node-clear . Introducing
additional constraints on the search schedule we get additional search numbers:

\begin{center}\begin{tabular}
[c]{lll} : & min. nr. of searchers required to
clear  with & internal\ node search schedule;\\
 & \qquad\qquad\qquad-//- & IM\ node
search schedule;\\
 : & \qquad\qquad\qquad-//- & IC\ node
search schedule;\\
 & \qquad\qquad\qquad-//- & IMC\ node
search schedule.
\end{tabular}



\end{center}

For the edge game we define the corresponding edge search numbers:\ , ,
, , .

In case of a search rooted at node , we will modify the notation as
follows:  is the minimum number of
searchers required to node-clear  by a search rooted at ;
similarly for ,  and so on. If the graph  is a rooted tree
, then we will assume it is always searched by rooted
searches; hence ,  and so on.

A \emph{minimal} node search schedule is one which clears  using
 searchers; a \emph{minimal} IM\ node search
schedule is an IM\ schedule which clears  using  searchers and similarly for all other types of either
node or edge search.

\section{Comparison of node and edge search}

\label{sec03}

In this section we compare \textquotedblleft unrestricted\textquotedblright \ edge and node search. In other words, we compare the outcome of a search
schedule  when it is used first in a node game and then in edge
game, both played on the same graph  and without requiring
rootedness, internality, monotonicity or connectedness.

Our main result is Theorem \ref{prp0303} which, informally, says the
following: every search schedule  gives at least as good results
in the node game as in the edge game. More precisely, at every step  of the
search, the set of e-clear nodes (and edges) is a subset of the set of n-clear
nodes (and edges). An immediate corollary is that an edge clearing search
schedule is also node clearing; The converse does not hold, as we have already
seen by the example of Remark \ref{prp0201}.

To prove Theorem \ref{prp0303} we will need the following lemmas.

\begin{lemma}
\label{prp0301}Given a graph  and a search schedule ,
for  we have
In other words: if a node  is e-dirty, then all edges , adjacent to
, are also e-dirty; and if an edge  is e-clear, then nodes  are e-clear.
\end{lemma}

\begin{proof}
For (\ref{eq0301a}): since  is e-dirty, it must be unguarded. We
distinguish two cases.

\noindent(1.i)\ Suppose  is adjacent to a single edge, call it . If
 is e-clear then  is not adjacent to any e-dirty edges and hence must
be e-clear, which is contrary to the original assumption. Hence  is e-dirty.

\noindent(1.ii)\ On the other hand, if  is adjacent to more than one edges,
they cannot all be e-clear (then  would also be e-clear); so at least one
edge, call it , is e-dirty. Suppose there is also an e-clear edge, call it
. But then the e-unguarded path  connects e-dirty  to e-clear
, which leads to contradiction. Hence all edges adjacent to  are e-dirty.

For (\ref{eq0301b}): suppose . Then  is
unguarded and there exists some  and . But the path  is e-unguarded and so  which is a contradiction.
\end{proof}

\begin{lemma}
\label{prp0302}If a node  is e-cleared exactly at time , then  is
entered by a searcher at .
\end{lemma}

\begin{proof}
Suppose  . This can happen in two ways. (i)\  was unguarded and e-dirty at 
and then entered by a searcher at . This is exactly the case described by
the theorem. (ii)\ The other way for  to be cleared exactly at  is if
 was unguarded and e-dirty at  and in addition a single edge, call it
, was e-dirty at  and e-cleared at  (while all other edges
 were e-clear at  and remained e-clear at ). For this to happen,
the move at time  is either  or .
But  is not possible, because then  would be guarded
and e-clear at . Hence the move at  is  and 
was entered at  (which shows that (ii)\ is a sub-case of (i)).
\end{proof}

Now we are ready to prove the following.

\begin{theorem}
\label{prp0303}Given a graph  and a search schedule ,
we have


\end{theorem}

\begin{proof}
We will actually show the relationships (equivalent \ to (\ref{eq0312}) )

The proof is by induction. At  all nodes are dirty in both the edge game
and the node game, hence . Suppose  for . Now we take  and consider first the
cleared and then the recontaminated nodes.

\begin{enumerate}
\item[\textbf{I.}] \emph{Cleared Nodes.} By Lemma \ref{prp0302}, a node
becomes e-cleared \emph{exactly }at  only if entered at . Hence at
most one such node (call it )\ exists and, since entered at , it
is also n-clear at . In other words: .

\item[\textbf{II.}] \emph{Recontaminated Nodes.} Denote by  the set of
nodes recontaminated (in the node game) \emph{exactly} at ; i.e.,
. By the
definition of n-dirty node, every  must have a path (n-unguarded at
) to a node . Furthermore, at least
one  must have a path (n-unguarded at ) to a node  (if this did not hold for any , then none of
the nodes of  would get recontaminated to begin with) and in fact this
shows \emph{every}  must have a path (n-unguarded at ) to a node
. So take any , then there exists a
path  satisfying:
Now we will show that  must belong to  as well. First, . Second, if  then  was cleared exactly at ,
which (by Lemma \ref{prp0302}) means a searcher entered  at ; but
then  which is contrary to
(\ref{eq0431}). Hence . \ Since  is \emph{e-dirty} at time ,
 is e-dirty at  by Lemma \ref{prp0301}. Also  is e-unguarded at . Hence . Since this is true for every , we conclude

\end{enumerate}

If the move at  was placing or sliding a searcher into node , let
; else let . Since  we have

Since the e-dirty nodes at  include all the e-dirty nodes at  except
the node  (which was e-cleared at ), we have
And so we have

The n-dirty nodes at  are exactly the n-dirty nodes at , excluding
nodes n-cleared at , plus the nodes recontaminated at . In other
words
Combining eqs. (\ref{eq0407}), (\ref{eq0308}) and (\ref{eq0309}) we get
Hence by induction we get  \ (and )\ for  .

Let us now consider the edge sets  and . Take any  and any edge . Without loss of generality we can assume  and hence, by Lemma
\ref{prp0301}, . Hence, for ,
we have

which completes the proof.
\end{proof}

\begin{corollary}
\label{prp0304}Given a graph  and an internal search schedule
, if  is edge clearing it is also node clearing.
\end{corollary}

\begin{proof}
Suppose the final move of  took place at time , then
. Since  we have
 which also means  (if a node  was n-dirty, an
adjacent edge  would also be n-dirty).
\end{proof}

\begin{remark}
\label{prp0305}From Theorem \ref{prp0303} we see that edge search is
\textquotedblleft weaker\textquotedblright\ than node search, i.e., for every
search schedule\textbf{,} and at every time step, the clear set in the edge
game is smaller or equal than the one in the node game. There is a variant of
edge search, the so-called \emph{mixed edge search }which, as we will see in
Appendix \ref{secB}, is \emph{equivalent} to node search, i.e. every search
schedule produces the same clear and dirty sets at every step of both the edge
and node game (this is stated and proved as Theorem \ref{prpA01}). From this
fact follow two consequences. First, \emph{node search is NP-complete} (since
mixed edge search is NP-complete \cite{Bienstock}). Second, Theorem
\ref{prp0303} can be obtained as a corollary of Theorem \ref{prpA01}. A more
detailed discussion of these issues appears in Appendix \ref{secB}.
\end{remark}

\section{Search on Trees}

\label{sec04}

In this section we will focus on \emph{rooted IMC\ (internal, monotone,
connected)\ search on trees} and we will compare node and edge search in this context.

Several authors have studied rooted IMC\ \emph{edge} search \cite{Barriere1,
Barriere2, Fomin, Fraigniaud1, Fraigniaud2, Yang2}. Our main results in this
section are Theorems \ref{prp0401} and \ref{prp0402} which establish the
equivalence of rooted IMC\ node and edge search on trees. Hence several
results already established for edge search also hold for node search (on
trees) as will be seen in the sequel.

\begin{theorem}
\label{prp0401}Given a tree  and an internal \emph{rooted }search
schedule , if  is monotone connected \emph{in the node
game} then

and  is monotone connected in the edge game.
\end{theorem}

\begin{proof}
The proof is inductive. We have  and . Also, since the search is rooted and internal, the move
at  will be the placement of a searcher into the root ; hence
 and . Now suppose that at time  we have

and let us consider the move , performed at , .

We first dispose of the case where the move involves the node 0. Because of
internality,  (no searcher is removed from the graph). If the move is
, by rootedness we must have . Also by rootedness,
 is the first node cleared (at some ). Now, in the node game:
(a)\ by monotonicity, no node is recontaminated at  and (b)\ no node is
n-cleared either (since  \emph{remains }n-clear, the move  implies ); hence  which also means . In the edge game,  (a)\ does not clear any new edges
(so it does not clear any new nodes either) and (b)\ does not remove any
searchers from any node, so neither edge \ nor node recontamination is
possible; hence 
and . In short, if
the -th move involves node 0, from (\ref{eq0401})\ follows



Next we examine the case where the -th move is
, with . We will examine the effects of this move
separately for the node and edge game. \noindent

\noindent\textbf{I.} \emph{Node Game}.  was guarded at time , so . Suppose, first, that at  only one searcher
was located on  so  is unguarded at . However, since 
was supposed monotone in the node game, there is no node    and, especially,
 remains n-clear. Since no node has become n-dirty at , no edge has
become n-dirty either (an edge becomes n-dirty iff incident on an n-dirty
node). As for clearings,  is n-clear at , since entered by a searcher;
and  is also n-clear since . No node other than  was entered at , so no
node other than  was n-cleared. Is there an edge (other than )\ which
was n-cleared exactly at ? This is only possible if (a)\ the edge has the
form  and (b) ( became n-clear \emph{exactly} at ) and (c)\ . Suppose
. Since  is connected,
there is a path  which is \emph{inside } and hence \emph{does not contain }. Then the tree
 contains a cycle  which is a contradiction.
Hence the only edge \emph{possibly} n-cleared at  (if not already n-clear
at ) is . In short
The case that  is still guarded at  (i.e.  contained more than one
searcher at time ) is omitted, since it is similar but easier to treat than
the case of unguarded . \noindent

\noindent\textbf{II. }\emph{Edge Game}. Again, we first examine the case that
only one searcher was located in  at time . So  was guarded (and
e-clear) at  and is unguarded at . We will now show that  remains
e-clear at ; in other words that

Suppose, on the contrary, that we have
There are only two ways for (\ref{eq0443})\ to hold, each of which we examine separately.

\begin{enumerate}
\item[\textbf{II.1}]  such that . Then . Since the move at
 was ,  was guarded at  and . Now, from  and  we get
; from this and  unguarded at 
we conclude that  which contradicts
monotonicity of the node search.

\item[\textbf{II.2}] Alternatively, there exists a path  (with ) such that  and  is e-unguarded at
. First note that, since  is e-unguarded at  and the
-th move is , it follows that
; and since  is a
tree,  too; in short .
Also , since  is a
path. Now
and this together with  implies
. From
 follows that  was not entered at  and so
. From this and 
being n-unguarded at  we conclude that  which contradicts monotonicity of the node search.
\end{enumerate}

In short,  cannot become e-dirty at , i.e., we have proved
(\ref{eq0441}). Using this we now will show that no previously e-clear edge
 can become e-dirty at . Because this would require the existence of
some edge  and a path  which is e-unguarded at  but e-guarded at 
(otherwise  would already be e-dirty at . But any such path would have
to contain  (no searcher was removed from any other node at ) which
would in turn imply , which contradicts
(\ref{eq0441}). Since no edge is recontaminated no node is recontaminated
either (the only node guarded at  and unguarded at  is , for which
we have (\ref{eq0441}) ).

On the other hand, the only edge \emph{possibly }e-cleared at time  (if
not already e-clear at ) is , since no other edge was traversed at
. Hence the only node \emph{possibly }e-cleared at time  (if not
already e-clear at ) \ is .

In short \ we have shown

The treatment of the case that  is still guarded at  (i.e., at  it
contained more than one searcher) is omitted, since it is similar but easier
to the case of  unguarded. \medskip From \noindent(\ref{eq0401}),
(\ref{eq0402}) and (\ref{eq0403}) we obtain

and, proceeding inductively, we obtain the required result:

Monotonicity and connectedness in the edge game follow from the fact that
these hold in the node game and from eq.(\ref{eq0405a}).
\end{proof}

\begin{theorem}
\label{prp0402}Given a tree  and an internal \emph{rooted }search
schedule  with root , if  is monotone connected
\emph{in the edge game} and satisfies either of the following constraints

\begin{enumerate}
\item[\textbf{C1}] , 

\item[\textbf{C2}] , , ,
\end{enumerate}

then
and  is monotone connected in the node game.
\end{theorem}

\begin{remark}
\label{prp0403}Before proving the theorem, let us discuss the significance of
constraints \textbf{C1} and \textbf{C2}. Three remarks must be made

\begin{enumerate}
\item Regarding the kind of searches which will satisfy either of the
constraints:\ \textbf{C1} will be satisfied by searches with ,  (provided  has a single neighbor, namely );
\textbf{C2} will be satisfied by searches with , ,
; in both cases  is,
obviously, the root of the search.

\item The constraints are imposed to exclude situations similar to the one
discussed in Remark \ref{prp0202}, where an edge is e-cleared and e-dirtied
during the \emph{same }time step .

\item Finally, \textbf{C1} and \textbf{C2} are not exceedingly restrictive; as
will be seen later, every \textquotedblleft interesting\textquotedblright \ IMC\ search on a tree either satisfies \textbf{C1} / \textbf{C2} or can
easily be converted to an equivalent search which does.
\end{enumerate}
\end{remark}

\begin{proof}
[Proof of Theorem \ref{prp0402}]The theorem will be proved by induction. It is
easy to check that

with  when \textbf{C1 }holds and  when \textbf{C2} holds.
Now suppose that at time  we have

and consider the move performed at .

We first dispose of the case where the move involves the node 0. Because of
internality,  (no searcher is removed from the graph). If the move is
, by rootedness we must have . By \textbf{C1} and
\textbf{C2},  is the first node cleared (at ). In the edge game,
at , no edge is recontaminated (by monotonicity)\ and no edge is
e-cleared (since no edge is traversed); hence ; since no searcher is removed from a node,
 as well. In the
node game,  is already n-clear at  and no other node is entered
at , so no node is n-cleared; no searcher is removed from the graph, so
no node is recontaminated; hence  which implies  as well. In short, if the -th move
involves node 0, from (\ref{eq0401a})\ and the above arguments follows



Next we examine the case where the -th move is
, with . We will examine the effects of this move
separately for the node and edge game. \noindent

\noindent\textbf{I.} \emph{Edge Game}. By monotonicity of the search, no
previously e-clear edge becomes e-dirty at ; and hence the only node that
can \emph{possibly} become e-dirty is . We will show however that  also
remains e-clear. Since  and , from edge monotonicity follows that
 for all . And, since
 and
 is connected, there exists ; if  becomes e-dirty at , then , which contradicts monotonicity of the edge
search. Hence no previously e-clear node becomes e-dirty at .

Regarding new clearings, edge  and node  \emph{may} become e-clear at
 (if they were not already e-clear at ). No edge other than  was
traversed, hence no edge other than  (and no node other than ) can be
e-cleared at . \ 

In short, in the edge game we have


\noindent\textbf{II.}\ \emph{Node Game}. Again, we first examine the case that
only one searcher was located on  at time . So  was guarded (hence
n-clear) at  and is unguarded at . We will now show that  remains
n-clear at ; in other words that

Suppose on the contrary that we have
(\ref{eq0445})\ can happen in only two ways, each of which we examine separately.

\begin{enumerate}
\item[\textbf{II.1}]  such that  and
. Then
 and hence (since the move at  was
 and ) .

Since  (for all ) and
 and
 is connected, there exists . However, since  and  is unguarded at , we conclude , which contradicts monotonicity of the edge search.

\item[\textbf{II.2}] Alternatively, there exists a path  (with ) such that  and  is n-unguarded at
 (so ). First note that,
since  is a path, .
Now
Since  it
follows that ; since also
 is not traversed at , it follows that . By the same reasoning as in the previous case,
there exists  and, since  and  is unguarded at , we conclude
, which contradicts the edge monotonicity
of .
\end{enumerate}

In short,  cannot become n-dirty at , i.e., we have proved
(\ref{eq0444}). Using this fact and an argument similar to that of Theorem
\ref{prp0401}, we conclude that no previously n-clear node can become n-dirty
at . Since no node is recontaminated, no edge is recontaminated either.

On the other hand, the only node \emph{possibly }n-cleared at time  is
 (no other node was entered) and hence the only edge \emph{possibly
}n-cleared at time  is  (if another edge was cleared, by an analysis
similar to that of Theorem \ref{prp0401}, we conclude that a cycle must exist
in , which is impossible). Hence the only edge possibly n-cleared
at  is .

In short, in the node game we have
The treatment of the case that  is still guarded at  (i.e., it
contained more than one searcher at ) is omitted, since it is similar to
but easier than the case of  unguarded. \medskip From \noindent
(\ref{eq0401a}), (\ref{eq0406}) and (\ref{eq0407a}) we obtain

and, proceeding inductively, we obtain the required result

Monotonicity and connectedness in the node game follow from the fact that
these hold in the edge game and eq.(\ref{eq0447}).
\end{proof}

We will now review some results (obtained by Barriere et al.
\cite{Barriere1,Barriere2}) regarding IMC\ \emph{edge }search on trees and
will show that similar results hold for IMC\ \emph{node }search on trees. In
the following presentation the terminology and notation of
\cite{Barriere1,Barriere2} is somewhat changed, to conform with the one used
in the current paper.

The first basic result of \cite{Barriere1} is the following.

\begin{theorem}
\label{prp0404}\cite{Barriere1} For every tree  there is an IMC
edge clearing search schedule  which uses  searchers. Moreover, in  all searchers are
initially placed at the same node  (i.e., the search schedule is
rooted) and the first step (after placing the searchers) consists in clearing
an edge incident to .
\end{theorem}

\begin{corollary}
\label{prp0405}For every tree  we have . There exists a
\emph{rooted }IMC\ search schedule which achieves this bound.
\end{corollary}

Theorem \ref{prp0404} can be extended to the following sequence of
inequalities\cite{Barriere2}.

\begin{theorem}
\label{prp0406}\cite{Barriere2} For every tree  we have
Furthermore, there are trees  for which the inequality  is strict.
\end{theorem}

Barriere et al. also present the \textbf{Search }algorithm \cite{Barriere1},
which computes a minimal edge-clearing rooted IMC\ schedule  for
every tree . The next Theorem shows that  is also a
minimal \emph{node-}clearing rooted IMC\ schedule.

\begin{theorem}
\label{prp0413}For every tree , the search  produced
by the \textbf{Search} algorithm is

\begin{enumerate}
\item a minimal edge-clearing IMC\ search of , which is also rooted;

\item a minimal node-clearing IMC\ search of , which is also rooted.
\end{enumerate}
\end{theorem}

\begin{proof}
Part 1 of the Theorem is proved as Lemma 9 in \cite{Barriere1}. Let us now
prove part 2. Since  is an edge-clearing strategy it is also
node-clearing. We next show it is minimal.\ 

Let us first consider the case of trees  such that . It is easy to see that such trees are
paths of the form , and \textbf{Search }produces the
\textquotedblleft obvious\textquotedblright\ edge clearing schedule:
, , ... (or the reverse, starting
at ) which is also a rooted minimal node clearing IMC\ schedule.

Suppose now that . By part 1,
\textbf{Search }will produce a rooted minimal edge clearing IMC\ schedule
. Also, by relaxing the requirement that all searchers are placed
into the graph in the first move (in other words, by interspersing searcher
placements with edge slidings) we can obtain from  a new search
schedule  which

\begin{enumerate}
\item uses the same number of searchers as \textbf{ }(i.e.\textbf{, }\textbf{);}

\item is rooted (i.e. all searcher placements are into );

\item satisfies either \textbf{C1} or \textbf{C2 }of Theorem \ref{prp0402};

\item produces the same sequence of clear graphs  as  \ (with a slight time adjustment, to account for
the changes in searcher placement times).
\end{enumerate}

Hence  satisfies the conditions of Theorem \ref{prp0402}
and is IMC\ in the edge game which means that, using , we
have

From this also follows that  is a node clearing rooted
IMC\ search schedule of .

Now take another node clearing IMC\ search of , call it
, which is minimal for the node game (i.e.,
 ). Then, by Theorem \ref{prp0401},  is also edge clearing, hence
On the other hand, since  is node clearing,

Hence

which completes the proof.
\end{proof}

\begin{corollary}
\label{prp0414}For every tree  we have .
\end{corollary}

\begin{remark}
\label{prp0416}Theorem \ref{prp0413} shows that the Barriere \textbf{Search}
algorithm can be used to compute a rooted IMC\ node clearing schedule for
every tree . How good is such a schedule? In other words, can we
node clear a tree  with fewer than  searchers? We can certainly do this with an internal
(non-monotone, non-connected)\ search. For example, let  be the complete binary tree of height ; then , while ; but we do not
know the values of  and . More
generally, we do not have the analog for node search of the inequalities
(\ref{eq0451}). It is easy to see that
for every graph  and, in particular, for every tree 
(and the inequalities in (\ref{eq0452}) can be strict). Refining
(\ref{eq0452}) to something like (\ref{eq0451}) is a subject of our future
research. The question is of special interest to us because, as already
mentioned, the one \emph{absolute} requirement for robotic pursuit / evasion
is internality; monotonicity and connectedness are desirable but not indispensable.
\end{remark}

\begin{remark}
\label{prp0417}A basic component of Barriere's \textbf{Search} algorithm is
the \textquotedblleft labeling\textquotedblright\ of edges, performed
by the auxiliary \textbf{Label} algorithm\cite{Barriere1}. As will be seen in
the next section, the Barriere  labels are also used by our GSST
algorithm to node-clear \emph{general graphs}.
\end{remark}

\section{Search on Graphs}

\label{sec05}

We now turn to the study of rooted IMC node searches of an arbitrary graph
 (which will always be assumed to have 
nodes, i.e., ). In every such search, the -th
move has the form , where  or, perhaps, , the \textquotedblleft source\textquotedblright\ node.

We present several variants of a basic node clearing algorithm. All variants
are guaranteed to find a node clearing search schedule; we prove that two of
the variants will find a minimal schedule with probability 
where  and  is the number of iterations of
the algorithm; even non-minimal search schedules require a reasonably small
number of searchers, as will be seen by the experiments of Section \ref{sec06}.

\subsection{Motivation}

\label{sec0501}

Our basic algorithmic idea is motivated by the following rather simple
observation: \emph{every rooted IMC\ node-clearing search of }\emph{ generates a spanning tree}. This observation can be refined in the
form of the following theorem.

\begin{theorem}
\label{prp0501}Given a graph  and a rooted
IMC node clearing search  of . The clearing moves of
 generate a sequence of trees, , where (for
)\  and the
following hold:\ 

\begin{enumerate}
\item[\textbf{D1}]  is the empty graph (,
);

\item[\textbf{D2}]  is a spanning tree of , );

\item[\textbf{D3}] for : ,  (in other words  is a subtree of
);

\item[\textbf{D4}] for : , and for : , with .
\end{enumerate}
\end{theorem}

\begin{proof}
Inductively. Since  is monotone, it involves  clearing moves.
 is the empty graph.  is formed by the first
move of , which consists in placing a searcher at the root node.
So  is the tree with a single node and trivially has
as a subgraph. Suppose \textbf{D3}\ and \textbf{D4}\ hold up
to  and consider the -th clearing move of
. Since  is connected, we add to \ one
node  and (as explained in the Proof of Theorem \ref{prp0401})
\emph{exactly }one edge  (with ) to
obtain a new tree  (of  nodes and  edges)\ which
also satisfies \ \textbf{D3}\ and \textbf{D4}. Hence \textbf{D3}\ and
\textbf{D4}\ hold for . At ,  contains  nodes,
hence ; since  is a tree, it is a spanning tree of
.
\end{proof}

\begin{remark}
\label{prp0502}An abbreviated statement of Theorem \ref{prp0501} could be:
\textquotedblleft Every rooted IMC node clearing search of 
specifies a spanning tree of \textbf{ }and an order of clearing
the nodes\textquotedblright. But the order must be consistent with the edge
structure of the graph and the spanning tree (e.g., we cannot use an order of
node clearing which requires non-existent edges). This consistence is exactly
what conditions \textbf{D3}\ and \textbf{D4}\ describe.
\end{remark}

Theorem \ref{prp0501} gives the motivation for our algorithm GSST
(\textbf{G}\emph{uaranteed \textbf{S}earch with \textbf{S}panning
\textbf{T}rees}), which is informally described below.

\begin{algorithm}[h]
\caption{ GSST, Informal Description}
\begin{algorithmic}
\STATE \textbf{Input:} Graph 
\STATE Select a spanning tree  of  and a root  of 
\STATE Find a rooted IMC node-clearing search  of 
\STATE Apply  to 
\IF{at some step of  a move  would result in recontamination in }
\STATE send a ``guard'' to 
\STATE execute 
\ENDIF
\STATE \textbf{Output:} The search  obtained by combining  with the guard moves
\end{algorithmic}
\label{alg:random}
\end{algorithm}


Note that, by construction, all clearing moves take place along edges of the
spanning tree .

In the above description we have used the term \textquotedblleft
guard\textquotedblright. Stated informally, the searchers play two
roles:\ \textquotedblleft\emph{tree searchers}\textquotedblright\ perform the
clearing moves, always along the edges of the spanning tree; \textquotedblleft \emph{guards}\textquotedblright\ are stationary and block potential
recontamination paths. However, note that a particular searcher can change
roles during the course of the search.

The main advantage of the GSST\ algorithm is that it is \emph{fast}. A random
spanning tree  can be quickly generated and searched. Since
 and  have the same node set, node-clearing
 in a \emph{node-monotone manner} results in node-clearing
 as well. The main issue is: \emph{how many guards will be
required to block recontamination through non-tree edges of }? The number
usuallly turns out to be quite reasonable, because (a)\ guards can be reused
and (b)\ tree searchers\ can also be used as guards when they do not perform
clearing moves.

Both the labeling and the traversal phase of GSST\ can be executed in either a
centralized or distributed manner; the latter is useful for robotic
applications, where each robot can share some of the computational load. In
the distributed implementation, all searchers share the underlying spanning
tree and labeling. When a searcher reaches a node, he checks to see if he can
move without recontamination. If he can, he determines his next move based on
the traversal strategy, and he shares this move with the team.

Hence GSST has short execution time and can be run repeatedly (in reasonable
time), using many different (randomly selected)\ spanning trees. \ Our
algorithm depends on the quick discovery of a spanning tree corresponding to a
minimal or near-minimal search (Theorem \ref{prp0501}). Our experiments in
Section \ref{sec06} show that GSST discovers near-minimal searches in only a
short time for several families of complex graphs.

An important characteristic of the GSST\ algorithm is its \textquotedblleft
anytime-ness\textquotedblright. Anytime algorithms return a partial answer
before completion and they keep providing improved answers, the improvement
increasing with computation time \cite{Zilberstein}. GSST\ has these
characteristics, as will be understood in Section \ref{sec0502}. Namely,
GSST\ is characterized by monotonicity (the solution only improves over time),
recognizable quality (the quality of the solution, i.e. number of searchers,
can be determined at run time), consistency (the algorithm will not spend too
much time finding a single solution), and interruptibility.

\subsection{The GSST Algorithms}

\label{sec0502}

A detailed description of the GSST algorithm is given by the following
pseudocode on p.\pageref{gsst}. The notation  means that the move 
is appended to the previously determined search schedule  (i.e.,
becomes the next move of ). Several subroutines appearing in the
following listing will be discussed presently.

\begin{algorithm}[h]
\label{gsst}
\caption{GSST}
\begin{algorithmic}
\STATE \textbf{Input:} : a graph; :  no. of spanning trees to use.
\STATE 
\STATE 
\FOR{}
\STATE 
\STATE =\textbf{GenerateTree}()
\STATE Randomly choose root 
\STATE 
\STATE , 
\STATE , 
\STATE 
\STATE =\textbf{R-Label(T)}
\WHILE{}
\STATE =\textbf{SelectEdge}()
\IF{a searcher can traverse  without recontamination}
\STATE Move that searcher to  \emph{staying inside the clear graph}
\STATE 
\STATE , 
\STATE , 
\STATE 
\ELSE
\STATE 
\ENDIF
\ENDWHILE
\IF{}
\STATE 
\STATE 
\ENDIF
\ENDFOR
\STATE \textbf{Output:} Node clearing schedule .
\end{algorithmic}
\label{alg:random}
\end{algorithm}


The following remarks explain the operation of the algorithm.

\begin{enumerate}
\item Generate a random spanning tree  by \textbf{GenerateTree.}
We have used two different methods of random spanning tree generation.

\begin{enumerate}
\item The \emph{uniform} method is an implementation of Wilson's
\cite{Wilson1} \emph{loop erased random walk algorithm}.

\item The \emph{DFS} method selects a root node and randomly moves down the
tree in a depth-first manner. At each node, a random incident edge is chosen
and set as an edge in the spanning tree. A visited list is maintained, and
when a node is visited more than once, the edge used to reach it the second
time is set as a non-tree edge. This eliminates cycles in the graph and thus
generates a tree. When a leaf is reached, the algorithm recurses to ensure
that all nodes are included in the tree (i.e, it is a spanning tree of the
original graph). The motivation for this method is to bias towards spanning
trees that require fewer guards. The intuition is that a DFS traversal will
generate only a few nodes with non-tree edges, thus leading to few required guards.
\end{enumerate}

\item Label the edges of  by the \textbf{R-Label} algorithm (this,
a modification of Barriere's \textbf{Label} algorithm, is listed and discussed
in Appendix \ref{secA}).

\item While n-dirty nodes still exist, select an n-dirty edge  of
 (by \textbf{SelectEdge,} to be discussed presently). Let a
searcher traverse  if this does not cause node
recontamination\footnote{The line \textquotedblleft Move that searcher to 
staying inside the clear graph\textquotedblright\ is actually a
simplification, i.e., in the interest of brevity, we do not indicate how such
a path is obtained; however this is always possible, usually in more than one
ways.}; if no such searcher exists, then use a new searcher (originally placed
at the root)\ to traverse .

\item Repeat the process until all nodes are n-cleared. (Hence the algorithm
does not allow node recontamination and will generate as many searchers as
necessary to prevent it).

\item When all nodes have been n-cleared, a rooted IMC node clearing search
has been generated, which performs all its clearing moves along the edges of
.

\item Go back to step 1 and repeat the process with a new spanning tree.

\item After the maximum number of trees and (corresponding searches) has been
generated, return a search  which attains , the
minimum value of .
\end{enumerate}

The subroutine \textbf{SelectEdge} chooses an n-dirty edge 
\emph{belonging to } and adjacent to the current clear graph
. There are several ways to perform this selection.

\begin{enumerate}
\item \textbf{Labeled Selection (L). }Select the next edge  of
 to be traversed according to the Barriere  labels (as in
algorithm \textbf{R-Search, }presented in Appendix \ref{secA}); however, if
traversing  would cause recontamination then select the next edge in the
Barriere sequence; if, at some stage of the search, traversing \emph{any} edge
of  would cause recontamination (i.e., if all searchers are stuck)
then introduce a new searcher at the root.

\item \textbf{Labeled Selection with Randomized Tie-breaking (LR).} Same as
the previous except that ties of edge labels are broken randomly.

\item \textbf{Randomized Selection (R). }Choose  randomly (without making
\emph{any} use of the Barriere labeling)\ by a uniform probability on all
n-dirty edges \emph{belonging to } and adjacent to :


\item \textbf{Labeled Weighted Selection (LW). }This rule is intermediate
between R and L: edge selection is still random but, instead of a uniform
probability distribution, the probability of an edge  being selected is
inversely proportional to its Barriere  label.

\item \textbf{Label Dominated Selection} \textbf{(LD).} This can be done by
labeling edges that lead to parts of the graph that are trees (subtrees of the
graph). A list of searchers who can move without recontamination can be
maintained during search. If an edge adjacent to 
leads to a subtree of the graph, and enough free searchers are available,
clearing this subtree can only improve the search strategies.
\end{enumerate}

By using each of the above rules in the \textquotedblleft
basic\textquotedblright\ GSST algorithm, we obtain \emph{ten} GSST variants:
uniform GSST-L, uniform GSST-LR, ... , uniform GSST-LD, DFS\ GSST-L, ...,
DFS\ GSST-LD. These variants (except for the two GSST-R's) utilize the
Barriere labeling, \emph{but do not necessarily produce a Barriere traversal
of the spanning tree}\footnote{This is true even of GSST-L, because an edge
which would be next in Barriere's traversal \ order may be temporarily skipped
if its traversal (at the current stage of the search)\ would cause
recontamination.}. In a sense Randomized Selection is the simplest or most
naive rule that can be used to select the next move of the search
schedule:\ every n-dirty edge of  (adjacent to the clear
graph)\ is equally likely to be selected. The remaining three rules can be
understood as ways to bias the probability by which edges are selected in some
meaningful way. The effectiveness of these rules will be judged by the
experiments of Section \ref{sec06}. From the theoretical point of view, we
will show in Section \ref{sec0503}\ that the uniform GSST-R and uniform
GSST-LD will find a minimal node clearing schedule with probability
 where  is the number of iterations and ; we conjecture that this property does not hold for Barriere
selection. As a practical matter, the issue is how large  has to be for
 to be sufficiently close to 1. However, the experiments of
Section \ref{sec06} indicate that the above rules find good search schedules
in very reasonable time.

Variants of GSST can also be produced by replacing the \textbf{GenerateTree}
subroutine with an \emph{exhaustive generation} of all spanning trees of
 (it can be used in conjunction with any of the above variants of
\textbf{SelectEdge}). To do this we have used Char's spanning tree enumeration
algorithm \cite{Jayakumar}. Exhaustive enumeration is feasible only for
relatively small graphs.

Finally note that the search schedules produced by (every variant of)\ GSST
are IMC. This holds for the search of both  and .
Indeed, for the search of  to work, the search of 
\emph{must} be IMC. In other words, no obvious modification of GSST will
produce, for example, an internal, connected, \emph{non-monotone}
node-clearing search of . The question arises:\ how good is a
minimal IMC\ node clearing of  (as compared to, for example, an
internal but not monotone / connected node clearing)? This is the question
already hinted at in Remark \ref{prp0416}.

Let us close this section by repeating that \emph{the basic idea of GSST\ is
to perform all clearing moves along the edges of a spanning tree}. This idea
exploits the facts that (a)\ spanning trees can be both generated and searched
quickly and (b)\ blocking recontamination does not require an excessively
large number of guards (because a searcher can change roles as a guard and a
tree searcher).

\subsection{Completeness}

\label{sec0503}

\begin{definition}
\label{prp0504}Given a graph  and a search  of
, the \emph{frontier }\ at  (under ) is

i.e., the n-clear nodes which are connected to n-dirty nodes.
\end{definition}

\begin{lemma}
\label{prp0505}In a node search, for every , the nodes  are guarded.
\end{lemma}

\begin{proof}
A frontier node  is by definition n-clear and adjacent to an n-dirty node
. This is only possible if  is guarded.
\end{proof}

\begin{definition}
\label{prp0506}Consider a rooted IMC node clearing search  of
. Let  and suppose the clearing moves of 
take place at times ; let also . The -th
\emph{phase} of  (for ) is the time interval , i.e. the interval between the -th and -th clearing move.
\end{definition}

The following remarks are rather obvious. For , a \emph{target edge
} (with ) corresponds to the -th
phase (here we take the root node to be ). While  the algorithm moves a searcher towards .
For ,  is n-dirty, 
is n-clear,  is n-dirty. At  we have  and ,  are n-cleared.

\begin{lemma}
\label{prp0507}Given a graph  and a rooted
IMC node clearing search  of , produced by either
GSST-R or GSST-LW, let , , ... ,  be the times at
which clearing moves take place; let also . Then for 

\begin{enumerate}
\item for : ;

\item for : every  contains exactly one searcher, except one node  which possibly contains two searchers;

\item for : every  contains
exactly one searcher.
\end{enumerate}
\end{lemma}

\begin{proof}
The proof is by induction on . Items 1, 2, 3 of the theorem hold for ,
. Suppose they also
hold up to the -th phase. In the interval  a target edge  (with ) is selected
and an available searcher is sent towards . Because GSST-R /
GSST-LW always selects for clearing an edge adjacent to the clear graph,
 ,  . There are three cases.

\noindent\textbf{I}.\  is neighbor of a single n-dirty node, namely
. In this case  (i.e.,  is n-cleared in one
step) and .
Node ; \ node  may or
may not belong to  but, at any rate, it
contains exactly one searcher; no searchers enter or exit any other nodes,
hence (by the inductive hypothesis)\ all  contain exactly one searcher.

\noindent\textbf{II}.\  is neighbor of more than one n-dirty nodes, one
of which is , and there are free searchers. Since  is a
frontier node, by hypothesis it contains a single searcher who, consequently,
is stuck. However, if free searchers are available inside n-clear,
non-frontier nodes, one of these searchers will be sent to  by a
sequence of moves. At every  during this sequence, the searcher may enter a
frontier node ; for that particular ,  will be the only frontier node
which contains two searchers. At  the searcher will be located at
 (which will now contain two searchers) and at  he will enter
; this leaves at  every  with a single searcher and also places a searcher at . The only
node which may have been added to the frontier is  which contains a
single searcher; every other node  was
previously in the frontier, contained a single searcher and, if a searcher
entered  at some , it exited  at
; hence every such node at  contains a single searcher.

\noindent\textbf{III}.\ The final case is when all frontier-located searchers
are stuck and there are no searchers inside n-clear, non-frontier nodes. In
this case a new searcher is placed at the root node and the rest of the
analysis is identical to that of Case II. Hence items 1, 2, 3 also hold for
 and we can complete the induction for
.
\end{proof}

\begin{lemma}
\label{prp0508}Given a graph  and a tree
sequence 
which satisfies conditions \textbf{D1-D4} of Theorem \ref{prp0501}.
Then\ uniform GSST-R / GSST-LW with  (i.e., using a single spanning tree)
has a nonzero probability of producing a search  which generates
.
\end{lemma}

\begin{proof}
The probability that Algorithm 1 generates the tree sequence  is

Note that the conditioning in the above expression \emph{always} includes
, since this is the first choice made in running GSST-R /
GSST-LW. Now obviously, .
By Wilson's Theorem 1 \cite{Wilson1}, 
for every spanning tree . Also,  is the probability of expanding (at the -th step)\  by
the edge  which, by the
construction of both GSST-R and GSST-LW, is always positive. Finally,
. Hence  for every
sequence .
\end{proof}

\begin{lemma}
\label{prp0509}Given a graph  and a rooted
IMC node clearing search  of ; let  be the tree
sequence generated by . Let  be a search
produced by either GSST-R or GSST-LW\ and \emph{also} generating . Then
.
\end{lemma}

\begin{proof}
The proof is exactly the same for GSST-R and GSST-LW, so we only prove the
first one, by induction. Let  be the clearing times of
 and  be the clearing times of
. Also let 

At we have 

The only times at which  may change
are ,  . Suppose that
Further, suppose that at  a new searcher is introduced in
. This can only happen (in the 
search) if all of the following hold:

\begin{enumerate}
\item at  exactly  searchers exist in ;

\item there are no searchers inside nodes  (i.e., all
searchers are located inside frontier nodes);

\item all searchers are stuck (i.e., moving a searcher out of a frontier node
 exposes  to recontamination).
\end{enumerate}

The sequence  along with the clearing times determines the frontier  for every . Hence  at  has
the same frontier as  at . If conditions 1-3 above hold in
, then every searcher is located in a frontier \ node and
is stuck. It is possible that non-stuck searchers exist in 
(located either in frontier or non-frontier nodes) but this also means that
; hence adding a searcher in 
at  preserves

Since no searchers are added in  for  and no searchers are ever removed
in  (i.e., ) we also get

From the above inequality inductively we get which proves the Lemma.
\end{proof}

\begin{theorem}
\label{prp0510}Given a graph .

\begin{enumerate}
\item Uniform GSST-R will generate a minimal rooted IMC clearing node search
of  with probability greater than or equal to 
where  is the number of iterations and .

\item Uniform GSST-LW will generate a minimal rooted IMC clearing node search
of  with probability greater than or equal to 
where  is the number of iterations and .
\end{enumerate}
\end{theorem}

\begin{proof}
The proof is exactly the same for GSST-R and GSST-LW, so we only prove the
first one.  has at least one minimal rooted IMC node \ clearing
search  of . Let  be the tree sequence generated by
. By Lemma \ref{prp0508}, GSST-R has a nonzero probability, call
it , of generating \emph{in a single iteration} a search
 with the same tree sequence as . Then, by
Lemma \ref{prp0509},

Since  is minimal,  and so  is minimal too. Now, the probability of \emph{not} generating
 in a single iteration is ; and
the probability of \emph{not} generating  in 
iterations is , while the
probability of generating  in  iterations is
.
\end{proof}

Finally, let us mention that the GSST algorithm can be modified to produce an
edge- rather than node-clearing search using the following theorem.

\begin{center}



\end{center}

\begin{theorem}
\label{prp0511}Given a graph  and an IMC node clearing search
 using  searchers, there is an edge clearing search
 using either  or  searchers.
\end{theorem}

\begin{proof}
Suppose that  contains  edges, that the length (i.e.,
number of moves)\ of  is  and that . The new search  will consist of
the  moves (executed at integer times )
combined with the moves of an extra searcher, the \textquotedblleft edge
cleaner\textquotedblright, who will only (if at all)\ move at
\emph{fractional} time steps of the form ,
 (fractional times are introduced to preserve the
\textquotedblleft alignment\textquotedblright\ of  and
, i.e. to ensure  at integer times; of course, once
 has been obtained, the time scale can be renormalized,
so that \emph{all }moves occur at integer times). We will use the notation
.

We will describe the moves of of the edge cleaner on a step-by-step basis, for
 in such a manner that at the same time we will complete an
inductive proof of the fact that
recall that  is the frontier, i.e., the set of n-clear nodes
connected to n-dirty nodes (and similarly for ) and that the
frontier nodes are always guarded in both the node and edge game.

For  we have , , and the edge cleaner is not used, so . Now suppose that

and consider . Let the -th move of 
be . We consider three cases.

\begin{enumerate}
\item \textbf{Case I}. If  is an interior node (i.e., \ a non-frontier
node:\  ), then  is
an edge of  and no new nodes/edges are cleared, either in the node or edge
game. No path becomes unguarded, and so no recontaminaiton is possible either.
Hence

The edge cleaner is not used, hence also



\item \textbf{Case II}. If  is a frontier node ( ) which contains a \emph{single
}searcher at , then  becomes unguarded at . Clearly

It is also easy to see that there is no edge  with  and : if such an edge
existed, then we would have  ( was not
entered at ) and so ; but  (it was guarded at ) and so node monotonicity
of  would be violated.

Take any edge . Edge  cannot be recontaminated in the node game (no node
was recontaminated). Edge  cannot be recontaminated in the edge game
either; for this to happen there must exist an e-unguarded path from  to
some ; but all such paths must go
through  (no other node became unguarded at )\ and hence must include
 (the only edge e-dirty at  and incident on ) but  is guarded
at . Hence no edge is e-dirtied at  and so no node is e-dirtied either.
In other words
which, together with (\ref{eq5903})\ shows that . Also, ; in both the node and edge game,  was removed from
the frontier and  was \emph{possibly} added to it. In short, we have
established (\ref{eq5901})\ \ for Case II as well.

From the previous remarks we know that, in the edge game and at time , no
edge was recontaminated and edge  was e-cleared. I.e.,
In the node game, on the other hand,

where ,  and there \emph{may }exist other nodes  which must (a)\ be neighbors of  and (b)\ belong to
. Hence
 were guarded at  and remain so at . In other words,
at time  the edges  have both endpoints guarded and are
n-clear but e-dirty. Now we invoke the edge cleaner who (at times  ) moves to  and then performs the
moves , , ,
, ... , . This entire sequence can be
performed in no more than  moves, so at 
the edges  have been e-cleared and so

Combining (\ref{eq5905})\ and (\ref{eq5906})\ we get .
In short, we have established (\ref{eq5902})\ \ for Case II as well.
\medskip

\item \textbf{Case III}. The final case to examine is when  is a frontier node
which contains more than one searcher at . We omit a detailed treatment
because the proof combines elements from the previous two cases; namely,
recontamination does not happen (for the same reasons as in Case I) bu the
edge cleaner may possibly be required (as in Case II).
\end{enumerate}

Hence, in all three cases considered, starting from (\ref{eq5900})\ we have
established (\ref{eq5901})\ and (\ref{eq5902}). Hence we can complete the
induction up to time  which means
Eqs.(\ref{eq5907})\ imply that all nodes are e-cleared at  but a few
extra steps may be required to e-clear all edges (by time  at most).
\end{proof}

\begin{center}

\end{center}

\section{Graph Search Experiments}

\label{sec06}

In this section we evaluate the performance of the GSST\ algorithm by
numerical experiments. Some of these experiments involve specific graphs
(Section \ref{sec0601}) and others involve families of graphs (Sections
\ref{sec0602} and \ref{sec0603} -- in which case we present average results).
We use ten \emph{variants }of GSST, obtained by using two different methods of
spanning tree generation (uniform and DFS) and five methods of edge traversal
(GSST-L, GSST-R, GSST-LR, GSST-LW, and GSST-LD).

\subsection{Experiments using Individual Graphs}

\label{sec0601}

\subsubsection{Simple Graph}

The first graph we have used appears in Fig.\ref{fig02}. This is a relatively
simple graph (with IMCnode search number 3)\ which we use to
illustrate the basic principles of GSST\ operation.

\begin{figure}[h]
\centering
\scalebox{0.6}{\includegraphics{pix/fig02.pdf}}\caption{A simple graph.}\label{fig02}\end{figure}

We node-search the graph using the ten GSST variants, each with 
generated spanning trees; to each spanning tree corresponds a search
, . In Table 2 we list for each GSST\ variant:
(a) (i.e.,
the minimum number of searchers achieved by the specific combination),
(b)\ the proportion of minimal searches out of the the  total searches and
(c)\ the time\footnote{All computations were performed by the gsearch.exe
program (see Appendix \ref{secD}), on a PC\ with Intel Dual Core E7500 CPU,
running at 2.93 GHz with 3 GB RAM; computation time is reported in seconds,
unless otherwise indicated.} (in sec)\ required to run the  searches.

\begin{center}\begin{tabular}
[c]{|l|l|l|l|l|l|l|}\hline
& \multicolumn{3}{|c}{\textbf{Uniform ST generation}} &
\multicolumn{3}{|c|}{\textbf{DFS ST generation}}\\\hline
\textbf{Edge Traversal} & Min & Prop. of min & Time & Min & Prop. of min &
Time\\\hline
GSST-L & \multicolumn{1}{|r|}{3} & \multicolumn{1}{|r|}{0.1562} &
\multicolumn{1}{|r|}{0.203125} & \multicolumn{1}{|r|}{3} &
\multicolumn{1}{|r|}{0.1804} & \multicolumn{1}{|r|}{0.203125}\\\hline
GSST-R & \multicolumn{1}{|r|}{3} & \multicolumn{1}{|r|}{0.2031} &
\multicolumn{1}{|r|}{0.171875} & \multicolumn{1}{|r|}{3} &
\multicolumn{1}{|r|}{0.2848} & \multicolumn{1}{|r|}{0.203125}\\\hline
GSST-LR & \multicolumn{1}{|r|}{3} & \multicolumn{1}{|r|}{0.2656} &
\multicolumn{1}{|r|}{0.265625} & \multicolumn{1}{|r|}{3} &
\multicolumn{1}{|r|}{0.2096} & \multicolumn{1}{|r|}{0.265625}\\\hline
GSST-LW & \multicolumn{1}{|r|}{3} & \multicolumn{1}{|r|}{0.2292} &
\multicolumn{1}{|r|}{0.218750} & \multicolumn{1}{|r|}{3} &
\multicolumn{1}{|r|}{0.2854} & \multicolumn{1}{|r|}{0.250000}\\\hline
GSST-LD & \multicolumn{1}{|r|}{3} & \multicolumn{1}{|r|}{0.2031} &
\multicolumn{1}{|r|}{0.218750} & \multicolumn{1}{|r|}{3} &
\multicolumn{1}{|r|}{0.3020} & \multicolumn{1}{|r|}{0.234375}\\\hline
\end{tabular}



\end{center}

\noindent\textbf{Table 2.} Node-clearing the \textquotedblleft simple
graph\textquotedblright\ by the various GSST variants: minimum number of
searchers attained and proportion of minimal solutions; number of spanning
trees generated is 

\bigskip

The true node search number (i.e., 3) has been found by every variant of GSST.
Generally, the DFS\ variants perform better than the uniform ones, as can be
seen by the higher proportion of minimal solutions achieved. A better
understanding of the distribution of the number of searchers required by each
search can be obtained by looking at the \emph{histogram} of the distribution;
one such histogram (for the variant with BH edge traversal and uniform
spanning tree generation) is plotted in Fig.\ref{fig03}. We can see that this
simple graph has a high proportion of spanning trees which yield minimal schedules.

\begin{figure}[h]
\centering\scalebox{0.35}{\includegraphics{pix/fig03.jpg}}\caption{The
histogram of the distribution of minimum number of searchers required to node
clear the \textquotedblleft simple graph\textquotedblright\ by the uniform
GSST-L\ variant.}\label{fig03}\end{figure}

An additional tool to evaluate the anytime performance of GSST is the plot of
 (the minimum node clearing number of searchers achieved by the first 
searches).  is decreasing with . The overall minimum
achieved by GSST is  (having tried  searches). If this
minimum is achieved for a small value of , then the minimal solution has
been obtained quickly. A graph of  (for the variant with
labeled edge traversal and uniform spanning tree generation) appears in
Fig.\ref{fig04}; as can be seen a minimal solution (clearing the graph with
three searchers) is achieved by the seventh computed search, approximately at
time sec.

\begin{figure}[h]
\centering
\scalebox{0.6}{\includegraphics{pix/fig04.pdf}}\caption{Plot of  vs.  for the \textquotedblleft simple graph\textquotedblright \ and the uniform GSST-L\ variant. The  axis is truncated at , since
the rest of the plot shows no change.}\label{fig04}\end{figure}

The \textquotedblleft simple graph\textquotedblright\ is simple enough to have
a relatively small number of spanning trees (namely 272, as computed by
Kirchoff's theorem \cite{HarrisKirchoff} ) and so we can also run GSST on
\emph{all }spanning trees (exhaustive enumeration). The computation takes
0.03125 (for the GSST-L variant) sec and shows that 83 out of the 272 spanning
trees (\emph{rooted at node} 1) yield minimal searches\footnote{Note that all
GSST variants, except GSST-L, use a randomized element in the order of edge
traversal -- hence multiple runs with the same spanning tree can yield
different searches.}.

\subsubsection{Tree/Grid Graph}

The second graph we have used appears in Fig.\ref{fig05}. It consists of a
\textquotedblleft root\textquotedblright\ node and two branches under it; the
left branch is a tree and the right one a grid; hence the name
\textquotedblleft tree/grid". The graph has 4 and we have
deliberately designed it to \textquotedblleft trick\textquotedblright\ the
GSST\ algorithm. For the sake of definiteness consider GSST-L. If the root of
the search is node 6, then GSST-L \ will find a four searcher node clearing
IMC\ schedule. However, if the root is node 1, then GSST-L\ will only find a
five searcher schedule, even after enumerating all spanning trees. A four
searcher IMC\ node clearing schedule is possible from either starting node;
but it requires the use of a non-Barriere edge traversal (for example, one
produced by the GSST-R variant); but GSST-L will always first send the
searchers down the right branch (towards the grid); actually, going first to
the left branch, towards the tree, is better (i.e. yields a four searcher schedule).

\begin{figure}[h]
\centering
\scalebox{0.6}{\includegraphics{pix/fig05.pdf}}\caption{The \textquotedblleft
tree/grid\textquotedblright\ graph.}\label{fig05}\end{figure}

Table 3 summarizes the results of our experiment, using the ten variants of
GSST and  spanning trees per variant. Note that in this table
(as in all others) the starting node is selected randomly. The uniform
variants are able to generate minimal search schedules, but not the DFS\ ones.

\begin{center}\begin{tabular}
[c]{|l|l|l|l|l|l|l|}\hline
& \multicolumn{3}{|c}{\textbf{Uniform ST generation}} &
\multicolumn{3}{|c|}{\textbf{DFS ST generation}}\\\hline
\textbf{Edge Traversal} & Min & Prop. of min & Time & Min & Prop. of min &
Time\\\hline
GSST-L & \multicolumn{1}{|r|}{4} & \multicolumn{1}{|r|}{0.00054} &
\multicolumn{1}{|r|}{5.921875} & \multicolumn{1}{|r|}{5} &
\multicolumn{1}{|r|}{0.06380} & \multicolumn{1}{|r|}{6.687500}\\\hline
GSST-R & \multicolumn{1}{|r|}{4} & \multicolumn{1}{|r|}{0.00328} &
\multicolumn{1}{|r|}{3.734375} & \multicolumn{1}{|r|}{5} &
\multicolumn{1}{|r|}{0.06956} & \multicolumn{1}{|r|}{4.390625}\\\hline
GSST-LR & \multicolumn{1}{|r|}{4} & \multicolumn{1}{|r|}{0.00076} &
\multicolumn{1}{|r|}{8.328125} & \multicolumn{1}{|r|}{5} &
\multicolumn{1}{|r|}{0.06976} & \multicolumn{1}{|r|}{8.765625}\\\hline
GSST-LW & \multicolumn{1}{|r|}{4} & \multicolumn{1}{|r|}{0.00206} &
\multicolumn{1}{|r|}{4.812500} & \multicolumn{1}{|r|}{5} &
\multicolumn{1}{|r|}{0.07252} & \multicolumn{1}{|r|}{5.609375}\\\hline
GSST-LD & \multicolumn{1}{|r|}{4} & \multicolumn{1}{|r|}{0.00232} &
\multicolumn{1}{|r|}{4.968750} & \multicolumn{1}{|r|}{5} &
\multicolumn{1}{|r|}{0.09376} & \multicolumn{1}{|r|}{5.656250}\\\hline
\end{tabular}



\end{center}

\noindent\textbf{Table 3. }Node-clearing the \textquotedblleft
tree/grid\textquotedblright\ by the various GSST variants: minimum number of
searchers attained and proportion of minimal solutions; number of spanning
trees generated is \textbf{ }

\bigskip

In this case the uniform variants find four-searcher clearing schedules and
hence outperform the DFS\ generated ones, which can only clear the graph with
five or more searchers\footnote{We have experimented with larger values of 
(e.g., ) but the DFS\ variants still cannot achieve a four searcher
clearing schedule.}. Note also the lower proportion of minimal solutions, even
for the uniform variants. For example, uniform GSST-L finds  minimal solutions. This in an indication that this
graph\ is indeed harder than the \textquotedblleft simple\textquotedblright \ one, at least for the GSST\ algorithm. Also, the tree/grid graph\ has 31529
spanning trees (and correspondingly many cycles) which is an additional
indication that it is (much) harder to search than the simple graph, which has
272 spanning trees. The small number of minimal solutions can also be
appreciated by looking at the histogram (for uniform GSST-L\ variant it is
plotted in Fig.\ref{fig06}).

\begin{figure}[h]
\centering\scalebox{0.35}{\includegraphics{pix/fig06.jpg}}\caption{The
histogram of the distribution of minimum number of searchers required to node
clear the \textquotedblleft hard graph\textquotedblright\ by the uniform
GSST-L\ variant. There is a small, barely noticeable, bar at ,
corresponding to the four-searcher clearing schedules.}\label{fig06}\end{figure}

However, despite the small proportion of minimal solutions, the first one is
always found after a relatively small number of iterations. For example, the
uniform GSST-L variant finds a four searcher schedule with the 420-th spanning
tree generated (out of a total of  spanning trees),
approximately at time sec.

\subsubsection{NSH Graph}

The next graph we use has been obtained by discretization of an actual
floorplan, namely the first floor of the Newel-Simon building in the Carnegie
Mellon University \ campus. In Fig.\ref{fig08} we present the actual floorplan
and its discretization; in Fig.\ref{fig09} we present the resulting graph (the
node numbers in Fig.\ref{fig09} correspond to the cell numbers in
Fig.\ref{fig08}).

\begin{figure}[h]
\centering
\scalebox{0.6}{\includegraphics{pix/fig07.pdf}}\caption{The NSH floorplan.}\label{fig08}\end{figure}

\begin{figure}[h]
\centering
\scalebox{0.4}{\includegraphics{pix/fig08.jpg}}\caption{The NSH graph.}\label{fig09}\end{figure}

\clearpage


This graph, with 60 nodes and 64\ edges, appears to be more complex than the
previous ones; however it has a relatively small number of spanning trees
(namely 3604, as computed by Kirchoff's theorem). By visual inspection it
appears very unlikely that the graph can be node-cleared with two searchers;
on the other hand, as will be seen presently, GSST can compute three-searcher
clearing schedules. Hence we conjecture that the search number 
is three.

Applying the \textquotedblleft standard\textquotedblright\ variants of
GSST\ and using  spanning trees per variant we obtain the
results of Table 4.

\begin{center}\begin{tabular}
[c]{|l|l|l|l|l|l|l|}\hline
& \multicolumn{3}{|c}{\textbf{Uniform ST generation}} &
\multicolumn{3}{|c|}{\textbf{DFS ST generation}}\\\hline
\textbf{Edge Traversal} & Min & Prop. of min & Time & Min & Prop. of min &
Time\\\hline
GSST-L & \multicolumn{1}{|r|}{3} & \multicolumn{1}{|r|}{0.00224} &
\multicolumn{1}{|r|}{14.265625} & \multicolumn{1}{|r|}{3} &
\multicolumn{1}{|r|}{0.01038} & \multicolumn{1}{|r|}{14.578125}\\\hline
GSST-R & \multicolumn{1}{|r|}{3} & \multicolumn{1}{|r|}{0.00002} &
\multicolumn{1}{|r|}{9.406250} & \multicolumn{1}{|r|}{3} &
\multicolumn{1}{|r|}{0.00006} & \multicolumn{1}{|r|}{10.140625}\\\hline
GSST-LR & \multicolumn{1}{|r|}{3} & \multicolumn{1}{|r|}{0.00478} &
\multicolumn{1}{|r|}{21.937500} & \multicolumn{1}{|r|}{3} &
\multicolumn{1}{|r|}{0.01026} & \multicolumn{1}{|r|}{21.390625}\\\hline
GSST-LW & \multicolumn{1}{|r|}{3} & \multicolumn{1}{|r|}{0.00328} &
\multicolumn{1}{|r|}{11.546875} & \multicolumn{1}{|r|}{3} &
\multicolumn{1}{|r|}{0.00608} & \multicolumn{1}{|r|}{12.593750}\\\hline
GSST-LD & \multicolumn{1}{|r|}{3} & \multicolumn{1}{|r|}{0.00544} &
\multicolumn{1}{|r|}{12.625000} & \multicolumn{1}{|r|}{3} &
\multicolumn{1}{|r|}{0.00880} & \multicolumn{1}{|r|}{13.578125}\\\hline
\end{tabular}



\end{center}

\noindent\textbf{Table 4. }Node-clearing the NSH\ graph\ \ by the various GSST
variants: minimum number of searchers attained and proportion of minimal
solutions; number of spanning trees generated is 

\bigskip

We see that all the GSST\ variants using uniform spanning tree generation
achieve the true search number, namely three. The random edge traversal
variants perform poorest of all: the uniform GSST-R finds only one minimal
search and the DFS GSST-R variant three. Generally, while the time required to
complete  searches is higher for the NSH\ graph than for the
\textquotedblleft tree/grid\textquotedblright\ graph, the proportion of
correct solutions is in some cases higher (at least for the uniform variants).
A histogram of the searchers required appears in Fig.\ref{fig10}, for the
uniform GSST-L\ variant; for this variant the first minimal search schedule is
computed at step 845 (out of 50000), approximately at time sec.

\begin{figure}[h]
\centering\scalebox{0.35}{\includegraphics{pix/fig09.jpg}}\caption{The
histogram of the distribution of minimum number of searchers required to node
clear the NSH\ graph\ by the uniform GSST-L\ variant.}\label{fig10}\end{figure}

\subsubsection{National Art Gallery Graph}

The next graph we use has also been obtained by discretization of an actual
floorplan, namely the first floor of the National Gallery of Art, in
Washington, DC. In Fig.\ref{fig12} we present the actual floorplan and the
discretization we have used; in Fig.\ref{fig13} we plot the corresponding graph.

\begin{figure}[h]
\centering
\scalebox{0.6}{\includegraphics{pix/fig10.pdf}}\caption{The National Gallery
of Art floorplan.}\label{fig12}\end{figure}

\begin{figure}[h]
\centering\scalebox{0.4}{\includegraphics{pix/fig11.jpg}}\caption{The National
Gallery of Art graph.}\label{fig13}\end{figure}

\clearpage


This graph, has 70 nodes and 93\ edges and is more complex than any of the
previously used graphs. In particular, it is more complex than the NSH\ graph.
While the National Art Gallery graph has about 50\% more edges than the
NSH\ graph, it has a \emph{much }larger number of spanning, approximately
5.3, as compared to 3604; this precludes use of the GSST with
exhaustive enumeration of the spanning trees. Also, we have no obvious way to
compute the true node search number. Nevertheless, we proceed to apply the ten
GSST\ variants using  spanning trees per combination. The
results obtained appear in Table 5.

\begin{center}\begin{tabular}
[c]{|l|l|l|l|l|l|l|}\hline
& \multicolumn{3}{|c}{\textbf{Uniform ST generation}} &
\multicolumn{3}{|c|}{\textbf{DFS ST generation}}\\\hline
\textbf{Edge Traversal} & Min & Prop. of min & Time & Min & Prop. of min &
Time\\\hline
GSST-L & \multicolumn{1}{|r|}{5} & \multicolumn{1}{|r|}{0.0000066} &
\multicolumn{1}{|r|}{74.378237} & \multicolumn{1}{|r|}{5} &
\multicolumn{1}{|r|}{0.0004466} & \multicolumn{1}{|r|}{77.214947}\\\hline
GSST-R & \multicolumn{1}{|r|}{6} & \multicolumn{1}{|r|}{0.0013133} &
\multicolumn{1}{|r|}{45.500000} & \multicolumn{1}{|r|}{5} &
\multicolumn{1}{|r|}{0.0004800} & \multicolumn{1}{|r|}{50.984375}\\\hline
GSST-LR & \multicolumn{1}{|r|}{5} & \multicolumn{1}{|r|}{0.0000066} &
\multicolumn{1}{|r|}{78.172631} & \multicolumn{1}{|r|}{5} &
\multicolumn{1}{|r|}{0.0002000} & \multicolumn{1}{|r|}{87.250000}\\\hline
GSST-LW & \multicolumn{1}{|r|}{5} & \multicolumn{1}{|r|}{0.0000200} &
\multicolumn{1}{|r|}{62.859375} & \multicolumn{1}{|r|}{5} &
\multicolumn{1}{|r|}{0.0007600} & \multicolumn{1}{|r|}{77.500000}\\\hline
GSST-LD & \multicolumn{1}{|r|}{5} & \multicolumn{1}{|r|}{0.0000066} &
\multicolumn{1}{|r|}{64.656250} & \multicolumn{1}{|r|}{5} &
\multicolumn{1}{|r|}{0.0009800} & \multicolumn{1}{|r|}{77.546875}\\\hline
\end{tabular}



\end{center}

\noindent\textbf{Table 5. }Node-clearing the National Art Gallery\ graph\ \ by
the various GSST variants: minimum number of searchers attained and proportion
of minimal solutions; number of spanning trees generated is 

\bigskip

We see that all the GSST\ variants\footnote{Except for uniform GSST-R; however
5-searcher clearing schedules can also be found by this variant if it is run
for a sufficiently large .} find node clearing searches with five
searchers. While we cannot be sure that the true node search number of the
National Art Gallery is five, we have been unable to find a lower search
number using any method (including extensive inspection by the authors). In
addition, the middle part of the graph resembles a five-by-six grid, which is
known to have a node search number of five (see Section \ref{sec0603}). A
histogram of the searchers required appears in \ref{fig14}, for the uniform
GSST-L variant; for this variant the first minimal search schedule is found at
step 101823 (out of a total ). Similar results hold for the
other variants.

\begin{figure}[h]
\centering\scalebox{0.35}{\includegraphics{pix/fig12.jpg}}\caption{The
histogram of the distribution of minimum number of searchers required to node
clear the National Gallery of Art \ graph\ by the uniform GSST-L\ variant.}\label{fig14}\end{figure}

The National Art Gallery graph results (as well as the NSH\ ones)\ show the
applicability of GSST on graphs that are derived from representations of real
indoor environments (which has been the main motivation for our research). The
methods that incorporate Barriere labeling improve performance on the NSH map
because it is similar to a tree (it becomes a tree if we remove only a
\emph{few} edges). In this case, Barriere labeling, which is based on trees,
helps to improve the schedules generated by GSST. The National Art Gallery, on
the other hand, is more similar to a grid, which lessens the advantage of
using Barriere labeling to guide traversal (though a significant improvement
is still obtained).

\subsection{Interval Graphs}

\label{sec0602}

The next experiment presented involves, unlike the ones of Section
\ref{sec0601}, a large number of graphs belonging to the same \emph{family}.
Our goal is to evaluate the \emph{average }performance of the GSST\ algorithm.
While, strictly speaking, the results are specific to the family of interval
graphs, they also suggest general properties of the GSST\ algorithm.

To evaluate the performance of GSST\ we must have some estimate of the actual
search number of each graph we use; then we can compare this search number
with the minimum  achieved by GSST.
To satisfy this condition, we will work with \emph{interval graphs}. Briefly,
an interval graph is obtained from a \emph{system of intervals}, i.e. a
collection of intervals of real numbers; each interval corresponds to a graph
node and two nodes are connected by an edge iff the corresponding intervals
intersect. It is known \cite{IntervalFomin,IntervalKaplan} that the
\emph{(non-monotone, non-connected) edge search number} of an interval graph
 (i.e., )\ is equal to its
\emph{interval width}, which is defined to be the size of the largest clique
of the graph. It is also known that the interval width of an interval graph
 of  nodes can be computed in time O
\cite{IntervalFomin,IntervalKaplan}. Of course, while we know the \emph{edge}
search number  exactly, this only provides
an estimate of the IMC\ \emph{node}-search number , in which we are really interested. There is no strict
inequality connecting  and ; we just know that  and . In general,
we expect that the discrepancy between  and
 is not too large and hence
 can be used to evaluate GSST\ performance.

We randomly generate interval systems (and the corresponding interval graphs)
by the following mechanism. First we select two parameters of the family: ,
the number of intervals, and , the average interval length. Then we
generate  intervals, the -th interval having its left endpoint at 
and the right endpoint at , where  follows an exponential
probability law . We form the
interval graph  corresponding to this interval system and compute
its interval width. We repeat the process 100 times to obtain  interval
graphs; these form a family characterized by the parameters 
(specified by us) and also by the average number of edges and the average
interval width. We repeat the process for five different choices of ; this information is summarized in Table 6.

\begin{center}\begin{tabular}
[c]{|l|l|c|c|}\hline
 &  & \textbf{Average num. of Edges} & \textbf{Average Interval
Width}\\\hline
\multicolumn{1}{|r|}{30} & \multicolumn{1}{|r|}{3} &
\multicolumn{1}{|r|}{74.22} & \multicolumn{1}{|r|}{5.49}\\\hline
\multicolumn{1}{|r|}{30} & \multicolumn{1}{|r|}{5} &
\multicolumn{1}{|r|}{113.06} & \multicolumn{1}{|r|}{7.66}\\\hline
\multicolumn{1}{|r|}{25} & \multicolumn{1}{|r|}{7} &
\multicolumn{1}{|r|}{182.01} & \multicolumn{1}{|r|}{9.51}\\\hline
\multicolumn{1}{|r|}{35} & \multicolumn{1}{|r|}{10} &
\multicolumn{1}{|r|}{231.84} & \multicolumn{1}{|r|}{11.68}\\\hline
\multicolumn{1}{|r|}{40} & \multicolumn{1}{|r|}{15} &
\multicolumn{1}{|r|}{366.79} & \multicolumn{1}{|r|}{15.53}\\\hline
\end{tabular}


\textbf{Table 6.} Characteristics of the various families of interval graphs
used for the experiments.
\end{center}

\bigskip

Finally, we apply the ten GSST variants to each of the five familes (using
 spanning trees per variant). The results are summarized in
Tables 7.a (for the uniform variants) and 7.b (for the DFS\ variants). In
these tables every row corresponds to a family, the families being indexed by
their average interval widths (appearing in the first column). Each of the
remaining columns corresponds to one GSST\ variant and lists the average (over
the 100 graphs)\ minimum number of searchers achieved by the respective
variant. Hence, an estimate of the efficiency of the GSST\ variants can be
obtained by comparing the first column of each table to the remaining ones.
For example, in the first row of Table 7.a we see that all uniform
GSST\ variants node clear the graphs of the first family with fewer searchers
(on the average)\ than those \textquotedblleft predicted\textquotedblright\ by
the interval width of the graphs (e.g., ). As we proceed down the
rows of Table 7.a to graphs of higher interval width (and, presumably, of
greater complexity) the average number of searchers required to clear a graph
increases above the average interval width. For example, in the last row the
average interval width is 15.53 and the average minimum number of searchers
required by the uniform GSST-L variant is 19.05; in other words the uniform
GSST-L requires  more searchers
than expected by the interval width estimate. Things get better with the
DFS\ variants; for example, for the  family,
the searcher overhead incurred by the DFS GSST-L\ variant is , which is actually quite good for
graphs of such high complexity.

\begin{center}\begin{tabular}
[c]{|l|l|l|l|l|l|}\hline
\textbf{Av. Int. Width} & \textbf{GSST-L} & \textbf{GSST-R} & \textbf{GSST-LR}
& \textbf{GSST-LW} & \textbf{GSST-LD}\\\hline
\multicolumn{1}{|r|}{5.49} & \multicolumn{1}{|r|}{5.15} &
\multicolumn{1}{|r|}{5.32} & \multicolumn{1}{|r|}{5.36} &
\multicolumn{1}{|r|}{5.14} & \multicolumn{1}{|r|}{5.16}\\\hline
\multicolumn{1}{|r|}{7.66} & \multicolumn{1}{|r|}{7.82} &
\multicolumn{1}{|r|}{8.08} & \multicolumn{1}{|r|}{8.03} &
\multicolumn{1}{|r|}{7.80} & \multicolumn{1}{|r|}{7.87}\\\hline
\multicolumn{1}{|r|}{9.51} & \multicolumn{1}{|r|}{11.01} &
\multicolumn{1}{|r|}{11.42} & \multicolumn{1}{|r|}{11.45} &
\multicolumn{1}{|r|}{11.02} & \multicolumn{1}{|r|}{11.30}\\\hline
\multicolumn{1}{|r|}{11.68} & \multicolumn{1}{|r|}{13.61} &
\multicolumn{1}{|r|}{13.91} & \multicolumn{1}{|r|}{13.91} &
\multicolumn{1}{|r|}{13.60} & \multicolumn{1}{|r|}{13.63}\\\hline
\multicolumn{1}{|r|}{15.53} & \multicolumn{1}{|r|}{19.05} &
\multicolumn{1}{|r|}{19.37} & \multicolumn{1}{|r|}{19.50} &
\multicolumn{1}{|r|}{19.06} & \multicolumn{1}{|r|}{19.25}\\\hline
\end{tabular}



\end{center}

\noindent\textbf{Table 7.a}: Average minimum number of searchers required to
node-clear each family of interval graphs\ by the uniform GSST variants;
number of spanning trees generated is 

\begin{center}
\medskip 

\begin{tabular}
[c]{|l|l|l|l|l|l|}\hline
\textbf{Av. Int. Width} & \textbf{GSST-L} & \textbf{GSST-R} & \textbf{GSST-LR}
& \textbf{GSST-LW} & \textbf{GSST-LD}\\\hline
\multicolumn{1}{|r|}{5.49} & \multicolumn{1}{|r|}{5.04} &
\multicolumn{1}{|r|}{5.13} & \multicolumn{1}{|r|}{5.04} &
\multicolumn{1}{|r|}{5.08} & \multicolumn{1}{|r|}{5.06}\\\hline
\multicolumn{1}{|r|}{7.66} & \multicolumn{1}{|r|}{7.34} &
\multicolumn{1}{|r|}{7.47} & \multicolumn{1}{|r|}{7.39} &
\multicolumn{1}{|r|}{7.44} & \multicolumn{1}{|r|}{7.36}\\\hline
\multicolumn{1}{|r|}{9.51} & \multicolumn{1}{|r|}{10.23} &
\multicolumn{1}{|r|}{10.34} & \multicolumn{1}{|r|}{10.25} &
\multicolumn{1}{|r|}{10.25} & \multicolumn{1}{|r|}{10.24}\\\hline
\multicolumn{1}{|r|}{11.68} & \multicolumn{1}{|r|}{12.70} &
\multicolumn{1}{|r|}{12.80} & \multicolumn{1}{|r|}{12.64} &
\multicolumn{1}{|r|}{12.73} & \multicolumn{1}{|r|}{12.62}\\\hline
\multicolumn{1}{|r|}{15.53} & \multicolumn{1}{|r|}{17.68} &
\multicolumn{1}{|r|}{17.87} & \multicolumn{1}{|r|}{17.75} &
\multicolumn{1}{|r|}{17.72} & \multicolumn{1}{|r|}{17.66}\\\hline
\end{tabular}



\end{center}

\noindent\textbf{Table 7.b}: Average minimum number of searchers required to
node-clear each family of interval graphs\ by the DFS GSST variants; number of
spanning trees generated is 

\bigskip

The results on interval graphs show that GSST can yield near-minimal schedules
on a large class of graphs. They also demonstrate that GSST \ scales well with
increasing complexity both in performance and computation time. This is a
direct result of the linear scalability of the algorithm in the number of
nodes in the environment.

\subsection{Grid Graphs}

\label{sec0603}

\subsubsection{Full Grids}

We now present some experiments involving grid graphs, i.e. graphs with nodes
located at points with integer coordinates (an example appears in Fig.
\ref{fig18}). It is easily seen that a grid graph of dimension  (i.e. containing nodes with coordinates )
can be node cleared using  searchers;
the corresponding search schedule is obvious\footnote{Namely (assuming that
the height  of the grid is less than or equal to the width )
place  searchers on one of the vertical sides of the grid and slide
them horizontally to the other vertical side.}. However, for a \emph{general}
graph search algorithm (such as GSST) which must work without assuming any
special structure of the graph, grid graphs are potentially extremely hard,
because they have many cycles and many spanning trees, only a few of which
correspond to minimal search schedules.

In this experiment we use 6 grid graphs, with dimensions starting at
 and going up to . To each such graph we apply the ten
GSST variants; in Tables 8.a (uniform ST\ generation variants) and 8.b
(DFS\ ST\ generation variants) we list the minimum search number attained by
each variant on each graph (, the number of spanning trees generated per
graph is also listed, in the last column). Let us also note that the total
execution time for this experiment is approximately 25 hours, reflecting (a)
the large number of graphs used, (b) the high complexity of many graphs,
(c)\ the large number of spanning trees used (the \emph{much smaller
}execution time for each individual graph and GSST\ variant is not listed, for
economy of space).

\begin{center}\begin{tabular}
[c]{|l|r|r|r|r|r|r|}\hline
\multicolumn{7}{|c|}{\textbf{Uniform random spanning tree generation}}\\\hline
\textbf{Graph Dim.} & \textbf{GSST-L} & \textbf{GSST-LR} & \textbf{GSST-R} &
\textbf{GSST-LW} & \textbf{GSST-LD} & \textbf{No.Trees}\\\hline
\multicolumn{1}{|r|}{55} & 5 & 5 & 5 & 5 & 5 & 10\\\hline
\multicolumn{1}{|r|}{66} & 7 & 7 & 7 & 7 & 7 & 210\\\hline
\multicolumn{1}{|r|}{77} & 8 & 8 & 8 & 8 & 8 & 310\\\hline
\multicolumn{1}{|r|}{88} & 10 & 9 & 9 & 9 & 9 & 310\\\hline
\multicolumn{1}{|r|}{99} & 11 & 11 & 11 & 10 & 11 & 410\\\hline
\multicolumn{1}{|r|}{1010} & 13 & 13 & 13 & 13 & 13 & 510\\\hline
\end{tabular}



\end{center}

\noindent\textbf{Table 8.a}. Minimum search number attained by the uniform
GSST variants on the full-grid graphs.

\begin{center}
\bigskip 

\begin{tabular}
[c]{|l|r|r|r|r|r|r|}\hline
\multicolumn{7}{|c|}{\textbf{DFS random spanning tree generation}}\\\hline
\textbf{Graph Dim.} & \textbf{GSST-L} & \textbf{GSST-LR} & \textbf{GSST-R} &
\textbf{GSST-LW} & \textbf{GSST-LD} & \textbf{No.Trees}\\\hline
\multicolumn{1}{|r|}{55} & 6 & 6 & 6 & 6 & 6 & 10\\\hline
\multicolumn{1}{|r|}{66} & 7 & 7 & 8 & 7 & 7 & 210\\\hline
\multicolumn{1}{|r|}{77} & 9 & 9 & 9 & 9 & 9 & 310\\\hline
\multicolumn{1}{|r|}{88} & 11 & 11 & 11 & 11 & 11 & 310\\\hline
\multicolumn{1}{|r|}{99} & 12 & 13 & 12 & 13 & 12 & 410\\\hline
\multicolumn{1}{|r|}{1010} & 14 & 14 & 14 & 14 & 15 & 510\\\hline
\end{tabular}



\end{center}

\noindent\textbf{Table 8.b. }Minimum search number attained by the DFS\ GSST
variants on the full-grid graphs.\bigskip

\begin{center}



\end{center}

We see that, on the grids, the uniform variants perform better than the
DFS\ ones; this is exactly the opposite situation from what happens in
interval graphs. With few exceptions, the uniform variants (Table 8.a)\ either
attain the actual minimum search number (for the  graph) or incur a
small overhead of 1 or 2 extra searchers. The situation changes with the
 graph, where the minimum attained search number is 13, with a
30\% overhead over the true . However, the  grid
graph is very complex, with 100 nodes, 180 edges and 5.6943
spanning trees. Judging from the distribution of the attained search numbers
(which, for economy of space, is not displayed here) lower search numbers
\emph{can} be attained but they require a much larger number of spanning
trees. To get an idea of the complexity of the full grid graphs, we list in
Table 8.c. the number of spanning trees for each of the six graphs used. This
provides a measure of the hardness of node-clearing the graph. This actually
quite reasonable: a graph with many cycles (and many spanning trees)\ is
harder to clear because it contains many escape routes for the evader.

\begin{center}\begin{tabular}
[c]{|l|r|}\hline
\textbf{Graph Dim.} & \textbf{No. of spaning trees}\\\hline
\multicolumn{1}{|r|}{55} & 5.57560\\\hline
\multicolumn{1}{|r|}{66} & 3.2566\\\hline
\multicolumn{1}{|r|}{77} & 1.9872\\\hline
\multicolumn{1}{|r|}{88} & 1.2623\\\hline
\multicolumn{1}{|r|}{99} & 8.3266\\\hline
\multicolumn{1}{|r|}{1010} & 5.6943\\\hline
\end{tabular}


\textbf{Table 8.c. }Number of spanning trees for each of the full-grid graphs


\end{center}

On the positive side, we see that node-clearing schedules can be computed for
the full grid graphs using slightly more than the minimum number of searchers
and in reasonable computation time. For example, the uniform GSST-L\ variant
finds the first 8-searcher clearing schedule for the  graph in under
2 mins and an 11-searcher clearing schedule for the  graph in under
10 mins. Considering that (due to the large number of cycles)\ grid graphs are
potentially some of the hardest graphs for GSST\footnote{It is interesting to
note that a somewhat related fact is well known in the probabilistic inference
literature: inference is easier on graphs with low tree-width \cite{Chavira}.}, we find these results to be quite satisfactory.

\subsubsection{Depleted Grids}

Our final experiment involves what we call \textquotedblleft depleted grid
graphs\textquotedblright. These are obtained as follows. First we choose two
parameters,  and , the length and width of the grid. Just like
with the full grid graphs, we place nodes at the positions . We also connect all nearest neighbor nodes along the
following lines

\begin{enumerate}
\item one horizontal line: ,

\item  vertical lines:, for 
\end{enumerate}

\noindent obtaining a tree of the form indicated by the solid edges in
Fig.\ref{fig18}. Finally, we consider all pairs of nearest neighbors ,  which are not already
connected and add to the graph an edge connecting each such pair with
probability .

\begin{figure}[h]
\centering\scalebox{0.7}{\includegraphics{pix/fig13.pdf}}\caption{Generating a
depleted grid graph. The solid lines correspond to edges which are always
present in the graph. Each dotted line becomes and edge with probability }\label{fig18}\end{figure}

The resulting graph  is a subgraph of the full 
grid and has ; in other words, 
yields an upper bound (useful for estimating the performance of GSST) of
. It seems reasonable that, on the
average,  is an increasing function of
 and for  the bound is tight, i.e. ; it will be useful to keep this in
mind when evaluating the results of the experiment. Note also that, as 
approaches 0, the graph becomes more similar to a tree (has fewer cycles).

We generate twelve families of depleted grids; namely we use dimensions
, , ,  and  values 0.4375, 0.7500
and 0.9375, yielding twelve combinations. We generate \emph{fifty }graphs from
each family and apply to each of these the ten GSST\ variants, \emph{using
}\emph{ spanning trees for each graph}. The results appear in
Tables 9.a (uniform variants) and 9.b (DFS\ variants). Namely, for each
combination we present the minimum search number attained, averaged over the
fifty graphs of the corresponding family. It can be seen that the resulting
numbers are quite low, especially for the uniform variants, often going under
the  bound.

\begin{center}\begin{tabular}
[c]{|c|c|c|c|c|c|c|}\hline
\textbf{Graph Dim.} &  & \textbf{GSST-L} & \textbf{GSST-R} &
\textbf{GSST-LR} & \textbf{GSST-LW} & \textbf{GSST-LD}\\\hline
\multicolumn{1}{|r|}{55} & \multicolumn{1}{|r|}{0.4375} &
\multicolumn{1}{|r|}{2.86} & \multicolumn{1}{|r|}{2.86} &
\multicolumn{1}{|r|}{2.86} & \multicolumn{1}{|r|}{2.86} &
\multicolumn{1}{|r|}{2.86}\\\hline
\multicolumn{1}{|r|}{55} & \multicolumn{1}{|r|}{0.7500} &
\multicolumn{1}{|r|}{3.68} & \multicolumn{1}{|r|}{3.68} &
\multicolumn{1}{|r|}{3.50} & \multicolumn{1}{|r|}{3.48} &
\multicolumn{1}{|r|}{3.48}\\\hline
\multicolumn{1}{|r|}{55} & \multicolumn{1}{|r|}{0.9375} &
\multicolumn{1}{|r|}{4.53} & \multicolumn{1}{|r|}{4.53} &
\multicolumn{1}{|r|}{4.12} & \multicolumn{1}{|r|}{4.18} &
\multicolumn{1}{|r|}{4.20}\\\hline
\multicolumn{1}{|r|}{77} & \multicolumn{1}{|r|}{0.4375} &
\multicolumn{1}{|r|}{3.63} & \multicolumn{1}{|r|}{3.56} &
\multicolumn{1}{|r|}{3.64} & \multicolumn{1}{|r|}{3.57} &
\multicolumn{1}{|r|}{3.62}\\\hline
\multicolumn{1}{|r|}{77} & \multicolumn{1}{|r|}{0.7500} &
\multicolumn{1}{|r|}{5.24} & \multicolumn{1}{|r|}{5.14} &
\multicolumn{1}{|r|}{5.32} & \multicolumn{1}{|r|}{5.08} &
\multicolumn{1}{|r|}{5.06}\\\hline
\multicolumn{1}{|r|}{77} & \multicolumn{1}{|r|}{0.9375} &
\multicolumn{1}{|r|}{6.62} & \multicolumn{1}{|r|}{6.40} &
\multicolumn{1}{|r|}{6.56} & \multicolumn{1}{|r|}{6.30} &
\multicolumn{1}{|r|}{6.28}\\\hline
\multicolumn{1}{|r|}{88} & \multicolumn{1}{|r|}{0.4375} &
\multicolumn{1}{|r|}{4.22} & \multicolumn{1}{|r|}{4.14} &
\multicolumn{1}{|r|}{4.08} & \multicolumn{1}{|r|}{4.08} &
\multicolumn{1}{|r|}{4.00}\\\hline
\multicolumn{1}{|r|}{88} & \multicolumn{1}{|r|}{0.7500} &
\multicolumn{1}{|r|}{6.10} & \multicolumn{1}{|r|}{6.14} &
\multicolumn{1}{|r|}{5.90} & \multicolumn{1}{|r|}{5.86} &
\multicolumn{1}{|r|}{5.84}\\\hline
\multicolumn{1}{|r|}{88} & \multicolumn{1}{|r|}{0.9375} &
\multicolumn{1}{|r|}{7.70} & \multicolumn{1}{|r|}{7.76} &
\multicolumn{1}{|r|}{7.52} & \multicolumn{1}{|r|}{7.40} &
\multicolumn{1}{|r|}{7.46}\\\hline
\multicolumn{1}{|r|}{1010} & \multicolumn{1}{|r|}{0.4375} &
\multicolumn{1}{|r|}{5.44} & \multicolumn{1}{|r|}{5.50} &
\multicolumn{1}{|r|}{5.32} & \multicolumn{1}{|r|}{5.30} &
\multicolumn{1}{|r|}{5.28}\\\hline
\multicolumn{1}{|r|}{1010} & \multicolumn{1}{|r|}{0.7500} &
\multicolumn{1}{|r|}{7.94} & \multicolumn{1}{|r|}{8.02} &
\multicolumn{1}{|r|}{7.84} & \multicolumn{1}{|r|}{7.68} &
\multicolumn{1}{|r|}{7.80}\\\hline
\multicolumn{1}{|r|}{1010} & \multicolumn{1}{|r|}{0.9375} &
\multicolumn{1}{|r|}{10.20} & \multicolumn{1}{|r|}{10.40} &
\multicolumn{1}{|r|}{10.24} & \multicolumn{1}{|r|}{10.06} &
\multicolumn{1}{|r|}{10.94}\\\hline
\end{tabular}



\end{center}

\noindent\textbf{Table 9.a.}\emph{ }Average minimum number of searchers
required to node-clear each family of depleted-grid graphs\ by the uniform
GSST variants; number of spanning trees generated is .

\bigskip

\begin{center}\begin{tabular}
[c]{|c|c|c|c|c|c|c|}\hline
\textbf{Graph Dim.} &  & \textbf{GSST-L} & \textbf{GSST-R} &
\textbf{GSST-LR} & \textbf{GSST-LW} & \textbf{GSST-LD}\\\hline
\multicolumn{1}{|r|}{55} & \multicolumn{1}{|r|}{0.4375} &
\multicolumn{1}{|r|}{3.36} & \multicolumn{1}{|r|}{3.36} &
\multicolumn{1}{|r|}{3.36} & \multicolumn{1}{|r|}{3.36} &
\multicolumn{1}{|r|}{3.36}\\\hline
\multicolumn{1}{|r|}{55} & \multicolumn{1}{|r|}{0.7500} &
\multicolumn{1}{|r|}{4.38} & \multicolumn{1}{|r|}{4.36} &
\multicolumn{1}{|r|}{4.36} & \multicolumn{1}{|r|}{4.36} &
\multicolumn{1}{|r|}{4.36}\\\hline
\multicolumn{1}{|r|}{55} & \multicolumn{1}{|r|}{0.9375} &
\multicolumn{1}{|r|}{5.04} & \multicolumn{1}{|r|}{5.04} &
\multicolumn{1}{|r|}{5.02} & \multicolumn{1}{|r|}{5.04} &
\multicolumn{1}{|r|}{4.98}\\\hline
\multicolumn{1}{|r|}{77} & \multicolumn{1}{|r|}{0.4375} &
\multicolumn{1}{|r|}{4.24} & \multicolumn{1}{|r|}{4.24} &
\multicolumn{1}{|r|}{4.24} & \multicolumn{1}{|r|}{4.24} &
\multicolumn{1}{|r|}{4.24}\\\hline
\multicolumn{1}{|r|}{77} & \multicolumn{1}{|r|}{0.7500} &
\multicolumn{1}{|r|}{5.82} & \multicolumn{1}{|r|}{5.78} &
\multicolumn{1}{|r|}{5.84} & \multicolumn{1}{|r|}{5.80} &
\multicolumn{1}{|r|}{5.77}\\\hline
\multicolumn{1}{|r|}{77} & \multicolumn{1}{|r|}{0.9375} &
\multicolumn{1}{|r|}{7.24} & \multicolumn{1}{|r|}{7.30} &
\multicolumn{1}{|r|}{7.28} & \multicolumn{1}{|r|}{7.28} &
\multicolumn{1}{|r|}{7.32}\\\hline
\multicolumn{1}{|r|}{88} & \multicolumn{1}{|r|}{0.4375} &
\multicolumn{1}{|r|}{4.68} & \multicolumn{1}{|r|}{4.66} &
\multicolumn{1}{|r|}{4.66} & \multicolumn{1}{|r|}{4.63} &
\multicolumn{1}{|r|}{4.64}\\\hline
\multicolumn{1}{|r|}{88} & \multicolumn{1}{|r|}{0.7500} &
\multicolumn{1}{|r|}{6.56} & \multicolumn{1}{|r|}{6.62} &
\multicolumn{1}{|r|}{6.62} & \multicolumn{1}{|r|}{6.64} &
\multicolumn{1}{|r|}{6.62}\\\hline
\multicolumn{1}{|r|}{88} & \multicolumn{1}{|r|}{0.9375} &
\multicolumn{1}{|r|}{8.58} & \multicolumn{1}{|r|}{8.52} &
\multicolumn{1}{|r|}{8.62} & \multicolumn{1}{|r|}{8.54} &
\multicolumn{1}{|r|}{8.56}\\\hline
\multicolumn{1}{|r|}{1010} & \multicolumn{1}{|r|}{0.4375} &
\multicolumn{1}{|r|}{5.80} & \multicolumn{1}{|r|}{5.80} &
\multicolumn{1}{|r|}{5.78} & \multicolumn{1}{|r|}{5.78} &
\multicolumn{1}{|r|}{5.80}\\\hline
\multicolumn{1}{|r|}{1010} & \multicolumn{1}{|r|}{0.7500} &
\multicolumn{1}{|r|}{8.62} & \multicolumn{1}{|r|}{8.58} &
\multicolumn{1}{|r|}{8.68} & \multicolumn{1}{|r|}{8.72} &
\multicolumn{1}{|r|}{8.62}\\\hline
\multicolumn{1}{|r|}{1010} & \multicolumn{1}{|r|}{0.9375} &
\multicolumn{1}{|r|}{11.34} & \multicolumn{1}{|r|}{11.38} &
\multicolumn{1}{|r|}{11.54} & \multicolumn{1}{|r|}{11.38} &
\multicolumn{1}{|r|}{11.26}\\\hline
\end{tabular}



\end{center}

\noindent\textbf{Table 9.b}.Average minimum number of searchers required to
node-clear each family of depleted-grid graphs\ by the DFS\ GSST variants;
number of spanning trees generated is .

\bigskip

The depleted grid results show the high performance of GSST on graphs with
large numbers of spanning trees and many cycles. Better results are obtained
for smaller values of , i.e. when the graph becomes more similar to a tree;
this is to be expected, since a basic component of the GSST algorithm is
search along a spanning tree. It is interesting to note that even for a quite
high value of , namely 0.9375, results (at least for uniform
GSST\ variants)\ are quite good; taking into account also the results of the
full grids, it appears that the increase of attained search number over
 happens only when  gets \emph{very}
close to 1. Once again we observe that the uniform variants perform better
than the DFS\ ones.

\subsection{Discussion}

\label{grid0604}

Our experiments demonstrate the performance of GSST on several different
classes of graphs. On many complex graphs, GSST was able to find a minimal
search schedule in reasonable time. On \emph{all} graphs, at least one
near-minimal schedule is computed early in the execution of the algorithm. In
fact, the \textquotedblleft anytime\textquotedblright\ operation of GSST\ (see
also the discussion in Section \ref{sec0501})\ yields reasonably good
solutions in very short time and then keeps improving on these solutions as
long as additional computation time is available. While the minimal schedules
form a small percentage of the computed solutions, many more near-minimal
solutions are available. These properties of GSST\ are highly desirable,
especially given the fact that (as far as we are aware) no other algorithm has
been \emph{implemented} which can tackle graphs of the size and complexity
presented here.

We can highlight some specific conclusions supported by the experiments on the
various graphs considered in Section \ref{sec0601} -- \ref{sec0603}.

\begin{enumerate}
\item The NSH and National Art Gallery graphs show the application of GSST on
graphs that are derived from representations of indoor environments. The
methods that incorporate Barriere labeling improve performance on the NSH map
because it is similar to a tree. The National Art Gallery, on the other hand,
is more similar to a grid, which lessens the advantage of using Barriere
labeling to guide traversal.

\item The results on interval graphs show that GSST can yield near-minimal
schedules on a large class of graphs. They also demonstrate that, with
increasing complexity, GSST \ scales well both in performance and computation time.

\item Finally, the grid results show the high performance of GSST on graphs
with large numbers of spanning trees and many cycles. These are potentially
some of the hardest graphs for GSST. Also, it appears that the the increase of
attained search number over  happens only
when  gets \emph{very} close to 1.
\end{enumerate}

Comparing spanning tree generation methods, we see that DFS\ generation
performs better on all graphs considered except for grid graphs (and the
tree/grid graph) where the uniform ST\ generation is better. At this point we
do not have a good explanation but we intend to further research this fact
because we believe it will give us a better understanding of which are the
\textquotedblleft good\textquotedblright\ spanning trees, i.e. the ones
associated with minimal searches. See Section \ref{sec07} for some additional
remarks on this issue.

Regarding edge traversal methods, there is no single GSST\ variant which
consistently outperforms all others. However, uniform GSST-L never does too
poorly and is fast; GSST-LW has the same advantages and, in addition, is
provably complete. Hence, in case node-clearing schedules must be quickly
produced (i.e. computation time is at premium), one can use a
\textquotedblleft reduced suite\textquotedblright\ of GSST\ variants,
consisting of GSST-L and GSST-LW (with both uniform and DFS\ spanning tree
generation) and expect to obtain nearly as good results (at a fraction of the
computing time)\ as when using the \textquotedblleft full\textquotedblright \ suite of the ten GSST\ variants.

Let us also stress that all variants of GSST\ can attain lower search numbers
than the ones presented here if sufficient running time is available.

\section{Conclusion}

\label{sec07}

Motivated by the problem of robotic pursuit / evasion, in the current paper we
have investigated \emph{node search}, i.e., the capture by a team of searchers
of an invisible evader located in the \emph{nodes} of a graph. This problem
has so far received little attention in the graph theoretic literature, with
most related publications concentrating on the problem of edge-located evader.
The basic contributions of the current paper are of two kinds.

\begin{enumerate}
\item From the theoretical point of view, we have shown that, in general
graphs, the problem of node search is easier than that of edge search, in the
sense that every edge clearing search is also a node clearing one; but the
converse does not hold in general. We have then concentrated on the internal
monotone connected (IMC)\ node search of trees and shown that it is
essentially equivalent to edge search under the same restrictions; hence
Barriere's tree search algorithm, originally designed for edge search, can
also be used for node search.

\item From the algorithmic point of view, we have presented GSST, a new
algorithm which performs IMC\ search on general graphs. This algorithm is
based on the fact that every node clearing search generates a spanning tree;
hence node-clearing a preselected spanning tree (by the use of \emph{tree
searchers}) and simultaneously blocking recontamination (by the use of
\emph{guards}) \ monotonically node-clears the graph. Because spanning tree
generation and search can both be performed very efficiently, a large number
of spanning trees can be tried by GSST\ until the one yielding the minimum
number of searchers is discovered. Experiments have shown that GSST can
quickly node-clear large and complex graphs using a small number of searchers.
\end{enumerate}

Many issues touched upon in the current paper require additional research. We
conclude by listing some future research directions, categorized as follows.

\begin{enumerate}
\item \textbf{Theory}.

\begin{enumerate}
\item \emph{Optimality}. Given a graph  with IMC node search
number . Suppose we have  searchers
with . What is the best we can
do? Of course \textquotedblleft best\textquotedblright\ depends on some
optimality criterion. For example we may want to clear the graph in the
minimum number of steps. Or, we may want a search strategy which minimizes the
cumulative \textquotedblleft area\textquotedblright\ of the dirty set (i.e.,
). We would like to obtain
algorithms which solve such optimization problems.

\item Our experiments show that the uniform GSST\ variants perform better than
DFS\ on grids and grid-like graphs. We want to discover a mathematical
explanation of this fact, e.g., to find necessary and / or sufficient
conditions under which uniform GSST\ outperforms DFS\ GSST. A result of this
type will probably have useful computational implications -- see also item 2.(a)\ below.\ 

\item We want to establish a sequence of inequalities between node search
numbers. In other words, to refine (\ref{eq0452}), either for a general graph
, or for the special case when  is a tree. For the
latter case, we conjecture that we can re-establish the Barriere et al.
inequalities (\ref{eq0451}) so as to hold for \emph{node-}\ rather than
edge-search numbers.

\item Finally, we are interested in questions of \emph{consistency}. Suppose
that we are given a graph along with a \emph{configuration} of each nodes
(i.e., a specification of the clear and dirty nodes). Can this configuration
be obtained by a sequence of moves in the node game? In the edge game? Also,
given a configuration of clear and dirty nodes and another one of clear and
dirty edges, are these configurations compatible in the node game? In the edge game?
\end{enumerate}

\item \textbf{Computation. }The GSST\ algorithm searches the space of spanning
trees in a random manner. Is there a way to bias the search in some useful
way?\ For this we need a characterization of \textquotedblleft
good\textquotedblright\ spanning trees, i.e., trees which yield a low number
of searchers (this includes tree searchers \emph{and} guards). We have no such
characterization at present. Perhaps we can obtain it by understanding why
uniform variants perform better than DFS\ on grid graphs (and conversely on
interval graphs).

\item \textbf{Extensions}. We want to study theoretically and develop
algorithms for the following variants of the search problem.

\begin{enumerate}
\item For less restricted types of node search, e.g., internal monotone (but
not connected), internal connected (but not monotone); or for completely
unrestricted node search.

\item For different types of \ pursuer / evader behavior; e.g., for pursuers
with extended (non-local)\ visibility, evaders with finite speed etc.

\item How does the graph search problem look from the evader's point of view?
Given a graph  and  searchers, what is the best the evader can
do if ? What if ? In the latter case capture is guaranteed, but can the evader, for
example, maximize the number of steps until capture?\ Many other interesting
problems can be posed from the evader's point of view.
\end{enumerate}
\end{enumerate}

\bigskip

\noindent\textbf{Acknowledgement}. We gratefully acknowledge Sanjiv Singh for
many useful discussions and valuable comments on the current paper.

\newpage

\appendix


\section{Appendix: Edge Search on Trees}

\label{secA}

In this Appendix we present the \textbf{R-Label} and \textbf{R-Search}
algorithms, which perform rooted IMC\ search of \emph{trees }and are also used
by the GSST\ algorithm. \textbf{R-Label} and \textbf{R-Search} are simplified
versions of corresponding algorithms presented by Barriere et al.
\cite{Barriere1}; some theoretical results from \cite{Barriere1} are also
reviewed. In our presentation the terminology and notation of \cite{Barriere1}
are somewhat changed, to conform with the current paper.

The next Lemma and Definition play a crucial role in computing the IMC\ search
number of a tree.

\begin{lemma}
\label{prp0407}\cite{Barriere1} Given a rooted tree  and a
node  of , if  has more than one children, enumerate
them as , so that they satisfy  for . Then

\end{lemma}

\begin{definition}
\label{prp0410}\cite{Barriere1} Given a tree 
and a node , consider all the edges  incident on  and label
them as follows.

\begin{enumerate}
\item If  is a leaf, then .

\item If  is not a leaf, let  be the neighbors of
 other than , enumerated so that \ (for ) and define

\end{enumerate}
\end{definition}

Note that the above definition assigns \emph{two} labels to each edge ,
namely  and .
Intuitively,  is the number of searchers that
must cross the \emph{directed } edge in an IMC\ edge-clearing of the tree.
In \cite{Barriere1} Barriere et al. present the \textbf{Label }algorithm which
computes the labels . Furthermore they prove the following.

\begin{lemma}
\label{prp0411}\cite{Barriere1} For every tree  and every edge
 of , we have .
\end{lemma}

\begin{lemma}
\label{prp0411A}\cite{Barriere1} Given a tree , for every  define  as follows
in the second line of the definition,  are the neighbors of
, enumerated so that they satisfy  for . Then


\end{lemma}

The algorithms and results of \cite{Barriere1} are geared towards computing
. The GSST\ algorithm, on the other
hand, requires the computation of 
and rooted searches. Hence we introduce the \textbf{R-Label} and
\textbf{R-Search} algorithms, which are simplified, \textquotedblleft
rooted\textquotedblright\ versions of the corresponding Barriere algorithms.
The pseudocode of these algorithms is listed in the next page.

The \textbf{R-Label} algorithm takes as input a tree  \emph{and} a root node . The algorithm is a
straightforward implementation of Definition \ref{prp0410}. \textbf{R-Label}
does \emph{not} compute all the labels  but only the ones for which  is a child of  in the
rooted tree ; for these edges, \textbf{R-Label} produces
the same  labels as \textbf{Label}. \textbf{R-Label }uses two
subroutines:\ given that  is the root, the subroutine \textbf{Depth} returns a partition  of \ the node set , where  contains all nodes of depth ; the subroutine
\textbf{SortChildren} returns the
children of  sorted in decreasing order of their  labels.

The \textbf{R-Search} algorithm uses the  labels to produce a rooted
IMC (edge and node)\ clearing search of . \textbf{R-Search} is
almost identical to Barriere's \textbf{Search}, the only difference being that
the starting node  is given, rather than chosen by the algorithm (this
implies that \textbf{R-Search} produces a minimal \emph{rooted }IMC search of
). \textbf{R-Search} uses Barriere's subroutine
\textbf{Move}. The notation 
means:\ append  moves of the form  to the search schedule
.

\begin{algorithm}[h]
\label{label}
\caption{\textbf{R-Label}}
\begin{algorithmic}
\STATE \textbf{Input:} Tree , start node 
\STATE  \textbf{Depth}
\FOR{ \textbf{with step}  \textbf{until} 1}
\FOR{}
\FOR{ \textbf{SortChildren}}
\STATE  \textbf{SortChildren}
\IF{\textbf{Length}=0}
\STATE 
\ELSIF{\textbf{Length}}
\STATE 
\ELSE
\STATE 
\ENDIF
\ENDFOR
\ENDFOR
\ENDFOR
\STATE \textbf{Output:} Edge labeling 
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[h]
\caption{\textbf{R-Search}}
\begin{algorithmic}
\STATE \textbf{Input:} Tree , start node , edge labeling 
\STATE 
\STATE  \textbf{SortChildren}
\FOR{ \textbf{with step}  \textbf{until} 1}
\STATE =\textbf{Move}
\ENDFOR
\STATE \textbf{Output:} Search 
\end{algorithmic}
\label{alg:search}
\end{algorithm}


\begin{algorithm}[h]
\caption{\textbf{Move}}
\begin{algorithmic}
\STATE \textbf{Input:} Tree , start node , edge labeling 
\STATE 
\STATE  \textbf{SortChildren}
\FOR{ \textbf{with step}  \textbf{until} 1}
\STATE =\textbf{Move}
\ENDFOR
\STATE 
\STATE \textbf{Output:} Search 
\end{algorithmic}
\label{alg:search}
\end{algorithm}


\clearpage


\newpage

\section{Appendix:\ The relationship between node search and \emph{mixed} edge
search}

\label{secB}

Theorem \ref{prp0303} tells us that edge search is \textquotedblleft
weaker\textquotedblright\ than node search in the sense that, for every graph
and every search schedule, we have  and . We will now consider a variant of edge search,
the so-called \emph{mixed edge search }which, as we will see, is
\emph{equivalent} to node search.

Mixed edge search is obtained by augmenting the clearing rules. In the
\textquotedblleft\emph{Mixed Search Edge Game}\textquotedblright\ an edge can
be cleared not only by sliding, but also by guarding both its endpoints. More
precisely, to obtain the rules of the mixed edge search game, take the rules
of the edge game (presented in Section \ref{sec02}), change the terms
\textquotedblleft e-clear\textquotedblright\ and \textquotedblleft
e-dirty\textquotedblright\ to \textquotedblleft m-clear\textquotedblright\ and
\textquotedblleft m-dirty\textquotedblright\ and add the following rule:

\begin{enumerate}
\item[\textbf{{E2}}] An m-dirty edge  becomes m-clear when both
 and  are occupied by searchers.
\end{enumerate}

In other words, we can clear an edge either by traversing it or by guarding
both its endpoints.

We will use  to denote the set of m-clear nodes
at time , and will analogously use the notations , , ,
 etc.

We emphasize that, in the mixed search edge game, the evader resides in the
edges of the graph and recontamination occurs by the same rules as in the
\textquotedblleft plain\textquotedblright\ edge game.

\begin{theorem}
\label{prpA01}Given a graph  and an internal search schedule
. Then, we have


\end{theorem}

\begin{proof}
The proof is inductive and consists of several steps. \noindent

\noindent\textbf{I.} At  we have
Suppose that we have

and let us next consider time . \noindent

\noindent\textbf{II.} We will now prove that
To this end we will show two things.

\begin{enumerate}
\item[\textbf{II.a}] \emph{If a previously n-dirty edge becomes n-clear at
}\emph{, then it also becomes m-clear}. Suppose that . In other words,
 is n-cleared exactly at ; this means that one of  was already
n-clear by  and the other was n-cleared \emph{exactly} at . Without
loss of generality, assume
Since a node can be n-cleared only by moving into it, the -th move must be . We distinguish the following cases.

\textbf{(i.1)} Suppose . Since  and
,  was guarded at ; since ,
 remains guarded at . Hence, at ,  has both ends guarded and
so . (Note that this analysis holds even
when , i.e., when the move was to place a new searcher).

\textbf{(i.2)} Suppose  and  is still guarded at  (i.e., at 
there was more than one searcher in ). Then at  both  and  are
guarded and .

\textbf{(i.3)} The remaining possibility is that  and  is unguarded at
 (i.e., at  there was exactly one searcher in ). Note that
 at  means that  is guarded at  and hence . If  as well,
then . So we now will show that  is not possible. Indeed  can only happen in one of the following two ways.

\textbf{(i.3.1)} There exists a node  such that . But  implies  (because  is guarded at ) and  implies 
(because  was not entered at ). Finally, from  and  unguarded at , we conclude  which contradicts assumption (\ref{eq0322}).

\textbf{(i.3.2)} Alternatively, there exists a path  (with
), e-unguarded at  and with  (note also that, since
 is a path, ). In this case, we have
and
and finally

But  contradicts assumption (\ref{eq0322}). Hence  \medskip

\qquad In short, by examining cases (i.1)-(i.3)we have shown that
i.e., if at  some  is n-cleared it is also m-cleared.

\item[\textbf{II.b}] \emph{If a previously m-clear edge becomes m-dirty at
}\emph{, then it also becomes n-dirty.} Suppose that . Without loss of
generality, we can assume that there exists a  and a path
 which was e-guarded at  but became e-unguarded at .
Since the path became e-unguarded at , exactly one node in it was guarded
at  (and became unguarded at ). Call this node ,
with  if the node in question is  (i.e., )\ and
 otherwise. The move at 
is , where  (since  is e-unguarded at ).
Since  , either  or . We consider the following cases.

\textbf{(ii.1)} If  then  as well (it was not entered) and the path
 is n-unguarded at . So  and .

\textbf{(ii.2)} If , then  and so  is the guarded node in the path
 (i.e., ). We distinguish two subcases.

\textbf{(ii.2.1)} The move at  is  and . Then  and so  and, by the same argument as in (ii.1), we get
.

\textbf{(ii.2.2)} The move at  is . Since we
have assumed ,  must be adjacent to some \emph{other} edge
 ;
so we can use  in place of ,  in place of
 and conclude by the reasoning of case (ii.2.1) that . \medskip

\qquad In short, we have shown that
i.e., if at  some  is m-dirtied then it is also n-dirtied.
\end{enumerate}

Hence every edge added at  to  is also added
to  and every edge removed at  from
 is also removed from . These facts, combined with , yield
\noindent\textbf{III.} To strengthen (\ref{eq0306}) to set equality, we need
the reverse set inclusion. In fact we can prove

by following the proof of Theorem \ref{prp0303} and replacing
\textquotedblleft e-clear\textquotedblright, \textquotedblleft
e-dirty\textquotedblright, ... with \textquotedblleft
m-clear\textquotedblright, \textquotedblleft m-dirty\textquotedblright, ...
(analogs of Lemmas \ref{prp0301}, \ref{prp0302} can also be proved
easily)\footnote{Basically the proof remains valid because the
\emph{recontamination rules} remain the same.}. From (\ref{eq0306})\ and
(\ref{eq0314})\ we obtain

\noindent\textbf{IV.} Now suppose \ . Then
 is unguarded and adjacent to some . Hence either  or  is n-dirty and so
(since  is unguarded) . On the other
hand, if , then  is unguarded and there
exists a 
and (since  is unguarded) . It follows
that

\noindent\textbf{V.} In short, we have established that
Eq.(\ref{eq0323}) and the fact  and 
complete the proof of the theorem.
\end{proof}

Several facts follow from Theorem \ref{prpA01}. First, it is well known that
mixed edge search is NP-complete \cite{Ellis} hence node search is also NP-complete.

Second, Theorem \ref{prpA01} can be used to obtain a Theorem \ref{prp0303} as
a corollary with a short proof (which, of course, presupposes the lengthy
proof of Theorem \ref{prpA01}). We give a sketch of such a proof. Suppose a
graph  and a search schedule  are given. Then, by
Theorem \ref{prpA01} we have (for every )  and . Now suppose  is applied to 
under the rules of the edge game and, up to time  we have  and . Then, at time , every
e-cleared edge is also m-cleared (since the mixed game has all the clearing
rules of the edge game and an additional one)\ and every m-dirtied edge is
also e-dirtied (since the edge and mixed games have the same recontamination
rules) except if an edge was already e-dirty. Hence , which also shows that
.

Finally, the above Theorem \ref{prpA01} and the monotonicity result proved in
\cite{Bienstock} (\textquotedblleft if there is a mixed edge clearing search
of  using  guards, there is a monotone mixed edge clearing
\ search of  using  guards\textquotedblright) makes the
following conjecture seem almost trivially true.

\begin{conjecture}
\label{prpA02}If there is a node clearing search  of 
using at most  guards, there is a monotone node clearing search
 of  using at most  guards.
\end{conjecture}

However some additional work is required to prove the conjecture, because of
the following detail:\ edge monotonicity does not necessarily imply node
monotonicity. In other words, the implication

is not necessarily true! Consider again the search schedule of Remark
\ref{prp0202}. In this case , but  does not hold. It is true however (and easy to
prove)\ that



Unfortunately, the result proved by Bienstock in \cite{Bienstock} concerns
\textquotedblleft simple\textquotedblright, not strong monotonicity. Hence one
of our future research goals is to extend Bienstock's result to node search
and thus prove that .\newpage

\section{Appendix:\ Vertex separation and pathwidth}

\label{secC}

Vertex separation and pathwidth are strongly (but not obviously) related to
graph search and search number, as discussed in (among other
papers)\ \cite{Megiddo,FominThilikos}, where the author can find a more
detailed discussion; here we just give the basic definitions and the main theorem.

\begin{definition}
\label{def0204}Given a graph , a \emph{path
decomposition} of  is a pair , where
 is a family of subsets of  and  is a
path whose nodes are the subsets  and they satisfy the following properties

\begin{enumerate}
\item .

\item For every edge  in , there is a subset  that contains both
 and .

\item If  then .
\end{enumerate}
\end{definition}

\begin{definition}
\label{def0205}The \emph{width} of a path decomposition  (with
) is denoted by  and
is defined by


\end{definition}

\begin{definition}
\label{def0206}The \emph{pathwidth} of a graph  is denoted by  and defined by


\end{definition}

\begin{definition}
\label{def0207}Given a graph  (with
)\ and a permutation  of . The \emph{vertex separation }of  with
respect to  is denoted by  and defined by
The \emph{vertex separation }of  is denoted by  and defined by

\end{definition}

The following theorem shows the connection between  and  and search number.

\begin{theorem}
For every graph ,  and .
\end{theorem}

\newpage

\section{Appendix: Implementations of the GSearch Algorithm}

\label{secD}

We have implemented the GSST\ algorithm in two forms which are publicly available.

\begin{enumerate}
\item As a command line executable, which runs on Windows and Linux computers.
The program and supporting material are available at the URL\ 

\qquad\qquad\texttt{http://www.frc.ri.cmu.edu/\symbol{126}gholling/home/software.html}.

\item As a graphical user interface (GUI), available at

\qquad\qquad\qquad\texttt{http://users.auth.gr/\symbol{126}kehagiat/KehagiasSoftware.htm}.
\end{enumerate}

We discuss each of these implementations separately.

\subsection{The Command Line program}

This is an executable, \texttt{gsearch.exe,} which has the following usage

\bigskip
\begin{verbatim}
       USAGE: gsearch -m [graph] -n [no.trees] -s [startnode] -g [gen.tree] 
          -y [wr-search] -w [wr-tree] -v [visualize] -t [edge traversal]
          -i [improve tree] -l [low number] -r [redundancy check]
       EXAMPLE: gsearch -m graphs/Edge01.txt -g exhaustive -s 1 -n 500000 -t bh
\end{verbatim}

\bigskip

The various options available are as follows.

\bigskip

\texttt{-m [graph]: string, name of file with edge list of the graph.}

\texttt{-n [no.trees]: int, how many sp.trees to generate (DEFAULT is 1).}

\texttt{-s [start node]: int, which node to start }

\ \ \ \ \ \ \texttt{(DEFAULT is 1, random choice is 0)}

\texttt{-g [gen.tree]: string, method of generating spanning trees}

\texttt{ \ \ (acceptable values: readtree, exhaustive, uniform, dfsrand; }

\ \ \ \ \ \ \ \texttt{DEFAULT is uniform)}

\texttt{-y [wr-search]: string, how many best searches to write}

\texttt{ \ \ (acceptable values: one, all, none; DEFAULT is one)}

\texttt{-w [wr-tree]: string, how many best sp.trees to write}

\texttt{ \ \ (acceptable values: one, all, none; DEFAULT is one)}

\texttt{-t [traversal]: string, how to break edge label ties}

\texttt{ \ \ (acceptable values: bh, random, bhrand, bhweight, bhdom; }

\ \ \ \ \ \ \ \texttt{DEFAULT is bh).}

\texttt{-i [improve tree]: boolean, use tree improve technique or not.}

\texttt{ \ \ (acceptable values are 0 / 1; DEFAULT is 0: do not use it)}

\texttt{-r [redundancy check]: boolean, check for redundant trees}

\texttt{ \ \ (acceptable values are 0 / 1; DEFAULT 1: }

\ \ \ \ \ \ \ \texttt{check for redundancy)}

\texttt{-l [low number]: break if a tree is found with this number of }

\ \ \ \ \ \ \ \texttt{searchers (DEFAULT is 0: do not break)}

\texttt{-v [visualize]: boolean, use visualizer (only supported }

\ \ \ \ \ \ \ \texttt{on linux) (DEFAULT is 0: do not use)}

\texttt{-h [help] }

\bigskip

The \texttt{-m} option indicates the file which contains the graph
description. This must be an ascii (plain text)\ file containing a list of the
edges of the graph, one edge per line, indicated as a pair of nodes. The nodes
must be continuously numbered from 1 to  and these numbers are used as
labels.  is assumed to be the largest number appearing in the edge list
(the graph is assumed to be undirected and connected). Examples of edge lists
can be found in the \texttt{graphs} directory.

The remaining options of \texttt{gsearch} correspond to the description of the
algorithm in Section \ref{sec05}. The \texttt{-n} option corresponds to the
 parameter of GSST (number of spanning trees), \texttt{-s} is the root of
the search, \texttt{-g} describes the uniform and DFS\ methods for generating
spanning trees (there are also options for exhaustive enumeration of all
spanning trees and for reading a specific spanning tree from file) and the
\texttt{-t} options (\texttt{bh, random, bhrand, bhweight, bhdom}) corresponds
to the traversal methods (L, R, LR, LW and LD, respectively). The \texttt{-i,
-r }and \texttt{-l} options are self explanatory. The \ \texttt{-y} option
writes one or more minimal strategies in the file(s)
\texttt{output/strat*.txt}; each row of the file corresponds to one step of
the strategy and shows the nodes in which the searchers are currently located.
The \ \texttt{-w} option writes the rooted tree(s) corresponding to optimal
strategies, in the file(s) \texttt{output/tree*.txt}; each row of the file
shows one parent and her child. The \texttt{-v} visualization option only
works on Linux computers (for a visualization of the search on Windows
computers use the GUI).

The command line \ \texttt{gsearch} was implemented by G. Hollinger in ANSI\ C
using the gcc 4.1 compiler.

\subsection{The Graphical I\textbf{nterface}}

This is an executable, \texttt{gsearchGUI.exe,} which corresponds closely to
the command line program. (In fact the GUI\ is a front end for the command
line program.)\ Launching the program brings up the window of Figure
\ref{fig15}. On the left side we see several input boxes. All of these
correspond to abovementioned options of the command line program with one
exception: in addition to the edge list file (\texttt{graphs/Edge11.txt} in
Figure \ref{fig15}) there is also a file containing the - and
-coordinates of the nodes (\texttt{graphs/Node11.txt} in Figure \ref{fig15}
-- this is required for visualization). The GUI\ starts with the default
selection of \texttt{Edge01.txt} and \texttt{Node01.txt} ; if you want a
different graph, type the corresponding file names in the input boxes.

\begin{figure}[h]
\centering\scalebox{0.5}{\includegraphics{pix/GUIScreen1.png}}\caption{A
screenshot of the gsearch GUI.}\label{fig15}\end{figure}

Having completed the input boxes on the left side of the window, you can now
use the buttons on the right side.

\begin{enumerate}
\item The \textsf{Search} button performs the graph search (it actually
invokes the \texttt{gsearch} executable and stores results in the
\texttt{output} directory). Time to complete the search depends on the size of
the graph and the number of spanning trees used. Do \emph{not} use the
exhaustive spanning tree enumeration option on large graphs because the
program may take too long to terminate.

\item The \textsf{Plot Graph} button plots the graph. An image of the graph is
generated and an image viewer is invoked which can be used to view the image
file (this is always named \texttt{graph.jpg}). A screenshot of the image
viewer appears in Figure \ref{fig16}.

\item The \textsf{Plot Search} button plots the graph search. Actually, first
the search strategy files are used to generate a sequence of image files, one
image corresponding to each step of the search (these files are stored in the
directory \texttt{pix}) and then the image viewer is invoked to view the
files. The user can step through the images using the arrow keys, or use the
\textsf{start} / \textsf{stop }buttons to run a slide show of the search. A
screenshot of the image viewer appears in Figure \ref{fig16}.
\end{enumerate}

\begin{figure}[h]
\centering\scalebox{0.5}{\includegraphics{pix/GUIScreen2.png}}\caption{A
screenshot of the image viewer.}\label{fig16}\end{figure}

\noindent \emph{Nota bene}: do not run \textsf{Plot Search} before running
\textsf{Search}! The \textsf{Plot Search} function uses the latest results of
\textsf{Search}; if these correspond to an earlier graph (from a previous run
of the GUI) the plotted search will produce nonsense reults.

The GUI was implemented by Ath. Kehagias in MS Visual Basic 5.0 (and a little
bit of C, using the dev-cpp 4.9.9.2 environment). The image viewer is a
freeware program called AutoPics and made available by the company
\emph{Mydesktophelp} (at \texttt{http://www.mydesktophelp.com}). The
GD\ graphics library (version gd-2.0.34-win32) has also been used; this
library is available at \texttt{http://www.libgd.org/}.

Finally it must be stressed that the current version , \texttt{gsearchGUI
v.0.9,} is still \emph{beta} and requires further development. However we make
it publicly available in the hope that it will prove useful to the graph
search community.

\newpage

\clearpage


\begin{thebibliography}{99}                                                                                               


\bibitem {Alspach}B. Alspach, \textquotedblleft Searching and sweeping graphs:
a brief survey\textquotedblright, \emph{Le Matematiche}, vol. 59, pp. 5--37, 2006.

\bibitem {Barriere1}L. Barriere, P. Flocchini, P. Fraigniaud, and N. Santoro,
\textquotedblleft Capture of an intruder by mobile agents\textquotedblright,
in \emph{Proc. of the 14th annual ACM symposium on Parallel algorithms and
architectures }(SPAA 2002), pp. 200--209, 2002.

\bibitem {Barriere2}L. Barriere, P. Fraigniaud, N. Santoro, and D. M.
Thilikos, \textquotedblleft Searching is not jumping\textquotedblright, in
\emph{Proc. of the 29th International Workshop on Graph-Theoretic Concepts in
Computer Science }(WG 2003), vol. 2880 of Springer LNCS, pp. 34--45, 2003.

\bibitem {BienstockReview}D. Bienstock, \textquotedblleft Graph searching,
path-width, tree-width and related problems (a survey)\textquotedblright, in
\emph{Reliability of computer and communication networks}, vol. 5 of DIMACS
Ser. Discrete Math. Theoret. Comput. Sci., pp. 33--49, 1991.

\bibitem {Bienstock}D. Bienstock and P. Seymour, \textquotedblleft
Monotonicity in graph searching\textquotedblright, \emph{J. Algorithms},
vol.12, pp. 239--245, 1991.

\bibitem {Breisch}R. Breisch, \textquotedblleft An intuitive approach to
speleotopology\textquotedblright, \emph{Southwestern Cavers}, vol.6, pp.
72--78, 1967.

\bibitem {Chavira}M. Chavira. \emph{Beyond Treewidth in Probabilistic
Inference}. Ph.D. dissertation, UCLA Dept. of Computer Science, 2007.

\bibitem {Dendris}N. D. Dendris, L. M. Kirousis, and D. M. Thilikos,
\textquotedblleft Fugitive-search games on graphs and related
parameters\textquotedblright, \emph{Theoret. Comput. Sci}., vol. 172, pp.
233--254, 1997.

\bibitem {Ellis}J. A. Ellis, I. H. Sudborough, and J. S. Turner,
\textquotedblleft The vertex separation and search number of a
graph\textquotedblright, \emph{Inform. and Comput}., vol. 113, pp. 50--79, 1994.

\bibitem {IntervalFomin}F.V. Fomin, P. Heggernes and R. Mihai.
\textquotedblleft Mixed search number and linear-width of interval and split
graphs\textquotedblright. \emph{Springer LNCS}, vol. 4769, pp.304-315, 2007

\bibitem {Fomin}F. V. Fomin, D. M. Thilikos, and I. Todinca, \textquotedblleft
Connected graph searching in outerplanar graphs\textquotedblright,
\emph{Electronic Notes in Discrete Mathematics}, vol. 22, pp. 213--216, 2005.

\bibitem {FominThilikos}F. V. Fomin, D. M. Thilikos, \textquotedblleft An
annotated bibliography on guaranteed graph searching\textquotedblright.
\emph{Theor. Comp. Sci., }vol.399, pp.236-245, 2008.

\bibitem {Fraigniaud1}P. Fraigniaud, F. V. Fomin, and D. M. Thilikos,
\textquotedblleft Connected branch decomposition and graph
searching\textquotedblright, in \emph{Proc. of SIAM Conference on Discrete
Mathematics}, 2006.

\bibitem {Fraigniaud2}P. Fraigniaud and N. Nisse, \textquotedblleft Connected
treewidth and connected graph searching\textquotedblright, in \emph{Proc. of
the 7th Latin American Symposium on Theoretical Informatics} (LATIN 2006),
vol. 3887 of Springer LNCS., pp. 479--490, 2006.

\bibitem {Gerkey1}B.P. Gerkey, S. Thrun and G. Gordon. \textquotedblleft
Visibility-based pursuit-evasion with limited field of view\textquotedblright .\ \emph{Proc. of the Natl. Conf. on Artificial Intelligence (AAAI 2004)}, pp.
20-27, 2004.

\bibitem {Gerkey2}B.P. Gerkey, S. Thrun and G. Gordon. \textquotedblleft
Parallel stochastic hill-climbing with small teams\textquotedblright. In
\emph{Multi-Robot Systems: From Swarms to Intelligent Automata} \emph{III},
pp. 65-77, 2005.

\bibitem {Guibas}L. J. Guibas, J.-C. Latombe, S. M. Lavalle, D. Lin, and R.
Motwani, \textquotedblleft A visibility-based pursuit-evasion
problem\textquotedblright, \emph{Int. J. Comput. Geom. Appl.,} vol. 9, pp.
471--493, 1999.

\bibitem {HarrisKirchoff}J.M. Harris, J.L. Hirst and M.J. Mossinghoff.
\emph{Combinatorics and Graph Theory}. Springer, 2008.

\bibitem {Hollinger2}G. Hollinger, Ath. Kehagias and S. Singh.
\textquotedblleft Probabilistic strategies for pursuit in cluttered
environments with multiple robots\textquotedblright. In \emph{Proc.
ICRA\ 2007}, 2007.

\bibitem {Hollinger1}G. Hollinger, Ath. Kehagias, S. Singh, D. Ferguson, and
S. Srinivasa. \textquotedblleft Anytime Guaranteed Search using Spanning
Trees\textquotedblright. Tech. Report CMU-RI-TR-08-36, Robotics Institute,
Carnegie Mellon University, 2008.

\bibitem {Jayakumar}R. Jayakumar, K. Thulasiraman and M.N.S. Swamy.
\textquotedblleft MOD-CHAR: an implementation of Char's spanning tree
enumeration algorithm and its complexity analysis\textquotedblright.
\emph{IEEE Trans. on Circuits and Systems}, vol. 36, pp.219-228, 1989.

\bibitem {IntervalKaplan}H Kaplan, R Shamir. \textquotedblleft Pathwidth,
bandwidth, and completion problems to proper interval graphs with small
cliques\textquotedblright. \emph{SIAM Journal on Computing}, vol. 25,
pp.540-561, 1996.

\bibitem {Kehagias1}Ath. Kehagias, G. Hollinger, and S. Singh.
\textquotedblleft A Graph Search Algorithm for Indoor Pursuit /
Evasion\textquotedblright. Tech. Report CMU-RI-TR-08-38, Robotics Institute,
Carnegie Mellon University, 2008.

\bibitem {Kinnersley}N. G. Kinnersley, \textquotedblleft The vertex separation
number of a graph equals its pathwidth\textquotedblright, \emph{Inf. Process.
Lett.}, vol. 42, pp. 345--350, 1992.

\bibitem {Kiroussis}L. M. Kirousis and C. H. Papadimitriou, \textquotedblleft
Searching and pebbling\textquotedblright, \emph{Theoret. Comput. Sci}., vol.
47, pp. 205--218, 1986.

\bibitem {LaPaugh}A. S. LaPaugh, \textquotedblleft Recontamination does not
help to search a graph\textquotedblright, \emph{J. Assoc. Comput. Mach.}, vol.
40, pp. 224--245, 1993.

\bibitem {Lavalle}S. M. Lavalle, B. H. Simov, and G. Slutzki,
\textquotedblleft An algorithm for searching a polygonal region with a
flashlight\textquotedblright, \emph{Int. J. Comput. Geom. Appl.}, vol.12, pp.
87--113, 2002.

\bibitem {LavalleBook}S.M. LaValle. \emph{Planning Algorithms}. Cambridge
University Press, 2008.

\bibitem {Megiddo}N. Megiddo, S. L. Hakimi, M. R. Garey, D. S. Johnson, and C.
H. Papadimitriou, \textquotedblleft The complexity of searching a
graph\textquotedblright, \emph{J. Assoc. Comput. Mach.}, vol. 35, pp. 18--44.
16, 1988.

\bibitem {Nowakowski}R. Nowakowski and P. Winkler, \textquotedblleft
Vertex-to-vertex pursuit in a graph\textquotedblright, \emph{Discrete Math.},
vol. 43, pp. 235--239, 1983.

\bibitem {Parsons1}T. D. Parsons, \textquotedblleft Pursuit-evasion in a
graph\textquotedblright, in \emph{Theory and applications of graphs}, Springer
LNM, vol. 642, pp. 426-- 441, 1978.

\bibitem {Petrov}N. N. Petrov, A problem of pursuit in the absence of
information on the pursued, \emph{Differentsialnye Uravneniya}, vol. 18, pp.
1345--1352, 1982.

\bibitem {Sing87IJRA}S. Singh and M. Wagh. \textquotedblleft Robot path
planning using intersecting convex shapes: Analysis and
simulation\textquotedblright, \emph{IEEE Journal of Robotics and Automation},
vol.?, pp.??-??, 1987.

\bibitem {Smith}J. D. H. Smith, \textquotedblleft Minimal trees of given
search number\textquotedblright, \emph{Discrete Math}., vol. 66, pp. 191--202, 1987.

\bibitem {Takahashi}A. Takahashi, S. Ueno, and Y. Kajitani, Mixed searching
and proper- path-width, \emph{Theoret. Comput. Sci.}, 137 (1995), pp. 253--268.

\bibitem {ThilikosParams}D. M. Thilikos, \textquotedblleft Algorithms and
obstructions for linear-width and related search parameters\textquotedblright,
\emph{Discrete Appl. Math.}, vol. 105, pp. 239--271, 2000.

\bibitem {Wilson1}D.B. Wilson, \textquotedblleft Generating random spanning
trees more quickly than the cover time\textquotedblright, \emph{Proc. of the
28th annual ACM symposium on Theory of Computation}, pp.296-303, 1996.

\bibitem {Yang1}B. Yang, \textquotedblleft Strong-mixed searching and
pathwidth\textquotedblright, \emph{J. Comb. Optim.}, vol. 13, pp. 47--59, 2007.

\bibitem {Yang2}B. Yang, D. Dyer, and B. Alspach, \textquotedblleft Sweeping
graphs with large clique number\textquotedblright, in \emph{Proc. of the 15th
International Symposium on Algorithms and Computation }(ISAAC 2004), Springer
LNCS, vol. 3341, pp. 908--920, 2004.

\bibitem {Zilberstein}S Zilberstein. \textquotedblleft Using anytime
algorithms in intelligent systems\textquotedblright. \emph{AI magazine}, vol.
17, pp. 73-83, 1996.
\end{thebibliography}


\end{document}