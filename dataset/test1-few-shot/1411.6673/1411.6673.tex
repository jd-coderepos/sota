


\documentclass[runningheads,a4paper]{llncs}

\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{paralist}
\usepackage{bm}
\usepackage{algorithmicx,algorithm}
\usepackage{algpseudocode}
\usepackage{url}
\usepackage{hyperref}
\usepackage{boxedminipage}
\usepackage{wrapfig}
\usepackage{ifthen}
\usepackage{color}
\usepackage{xcolor}
\usepackage{varwidth}
\usepackage{framed}

\newcounter{obs}
\spnewtheorem{observation}[obs]{Observation}{\bfseries}{\itshape}

\usepackage{thmtools}
\usepackage{thm-restate}


\newcommand{\comment}[1]{\textit {\em \color{blue} \footnotesize[#1]}\marginpar{\tiny\textsc{\color{blue} To Do!}}}
\newcommand{\mcomment}[1]{\textbf {\em \color{red} \footnotesize[#1]}\marginpar{\tiny\textsc{\color{red} PLEASE CHECK}}}

\newcommand{\ignore}[1]{}


\newcommand{\cA}{{\cal A}}
\newcommand{\cB}{\mathcal{B}}
\newcommand{\cC}{{\cal C}}
\newcommand{\cD}{\mathcal{D}}
\newcommand{\cE}{{\cal E}}
\newcommand{\cF}{\mathcal{F}}
\newcommand{\cG}{\mathcal{G}}
\newcommand{\cH}{{\cal H}}
\newcommand{\cI}{{\cal I}}
\newcommand{\cJ}{{\cal J}}
\newcommand{\cL}{{\cal L}}
\newcommand{\cN}{{\cal N}}
\newcommand{\cM}{{\cal M}}
\newcommand{\cP}{\mathcal{P}}
\newcommand{\cQ}{\mathcal{Q}}
\newcommand{\cR}{{\cal R}}
\newcommand{\cS}{\mathcal{S}}
\newcommand{\cT}{{\cal T}}
\newcommand{\cU}{{\cal U}}
\newcommand{\cV}{{\cal V}}
\newcommand{\cX}{{\cal X}}

\newcommand{\B}{\mathbf{B}}
\newcommand{\be}{{\bf e}}
\newcommand{\bzero}{{\bf 0}}
\newcommand{\inter}[2]{\I^{#2}_{#1}}
\newcommand{\R}{\mathbb R}
\newcommand{\N}{\mathbb N}
\newcommand{\F}{\mathbb F}
\newcommand{\Z}{{\mathbb Z}}
\newcommand{\eps}{\varepsilon}
\newcommand{\lam}{\lambda}
\newcommand{\sgn}{\mathrm{sgn}}
\newcommand{\poly}{\mathrm{poly}}
\newcommand{\polylog}{\mathrm{polylog}}
\newcommand{\littlesum}{\mathop{{\textstyle \sum}}}
\newcommand{\half}{{\textstyle \frac12}}
\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
\newcommand{\wh}{\widehat}
\newcommand{\wt}{\widetilde}
\newcommand{\calE}{{\cal E}}
\newcommand{\calL}{{\cal L}}
\newcommand{\calF}{{\cal F}}
\newcommand{\calW}{{\cal W}}
\newcommand{\calH}{{\cal H}}
\newcommand{\calN}{{\cal N}}
\newcommand{\calO}{{\cal O}}
\newcommand{\calP}{{\cal P}}
\newcommand{\calV}{{\cal V}}
\newcommand{\calS}{{\cal S}}
\newcommand{\calT}{{\cal T}}
\newcommand{\calD}{{\cal D}}
\newcommand{\calC}{{\cal C}}
\newcommand{\calX}{{\cal X}}
\newcommand{\calY}{{\cal Y}}
\newcommand{\calZ}{{\cal Z}}
\newcommand{\calA}{{\cal A}}
\newcommand{\calB}{{\cal B}}
\newcommand{\calG}{{\cal G}}
\newcommand{\calI}{{\cal I}}
\newcommand{\calJ}{{\cal J}}
\newcommand{\calR}{{\cal R}}
\newcommand{\calK}{{\cal K}}
\newcommand{\calU}{{\cal U}}
\newcommand{\barx}{\overline{x}}
\newcommand{\bary}{\overline{y}}
\newcommand{\E}{\hbox{\bf E}}

\newcommand{\ba}{\boldsymbol{a}}
\newcommand{\bb}{\boldsymbol{b}}
\newcommand{\bp}{\boldsymbol{p}}
\newcommand{\bt}{\boldsymbol{t}}
\newcommand{\bv}{\boldsymbol{v}}
\newcommand{\bx}{\boldsymbol{x}}
\newcommand{\by}{\boldsymbol{y}}
\newcommand{\bz}{\boldsymbol{z}}
\newcommand{\br}{\boldsymbol{r}}
\newcommand{\bh}{\boldsymbol{h}}

\newcommand{\bA}{\boldsymbol{A}}
\newcommand{\bD}{\boldsymbol{D}}
\newcommand{\bG}{\boldsymbol{G}}

\newcommand{\bR}{\boldsymbol{R}}
\newcommand{\bS}{\boldsymbol{S}}
\newcommand{\bX}{\boldsymbol{X}}
\newcommand{\bY}{\boldsymbol{Y}}
\newcommand{\bZ}{\boldsymbol{Z}}

\newcommand{\NN}{\mathbb{N}}
\newcommand{\RR}{\mathbb{R}}

\newcommand{\abs}[1]{\left\lvert #1 \right\rvert}
\newcommand{\norm}[1]{\left\lVert #1 \right\rVert}
\newcommand{\ceil}[1]{\lceil#1\rceil}
\newcommand{\Exp}{\EX}
\newcommand{\floor}[1]{\lfloor#1\rfloor}
\newcommand{\Pe}[2]{(#1)_{#2}}
\newcommand{\EX}{\hbox{\bf E}}
\newcommand{\mG}{\mathbb{G}}
\newcommand{\prob}{{\rm Prob}}

\newcommand{\gset}{Y}
\newcommand{\gcol}{{\cal Y}}

\newcommand{\Sec}[1]{\hyperref[sec:#1]{Section\,\ref*{sec:#1}}} \newcommand{\Eqn}[1]{\hyperref[eq:#1]{(\ref*{eq:#1})}} \newcommand{\Fig}[1]{\hyperref[fig:#1]{Fig.\,\ref*{fig:#1}}} \newcommand{\Tab}[1]{\hyperref[tab:#1]{Tab.\,\ref*{tab:#1}}} \newcommand{\Thm}[1]{\hyperref[thm:#1]{Theorem\,\ref*{thm:#1}}} \newcommand{\Fact}[1]{\hyperref[fact:#1]{Fact\,\ref*{fact:#1}}} \newcommand{\Lem}[1]{\hyperref[lem:#1]{Lemma\,\ref*{lem:#1}}} \newcommand{\Prop}[1]{\hyperref[prop:#1]{Prop.~\ref*{prop:#1}}} \newcommand{\Cor}[1]{\hyperref[cor:#1]{Corollary~\ref*{cor:#1}}} \newcommand{\Conj}[1]{\hyperref[conj:#1]{Conjecture~\ref*{conj:#1}}} \newcommand{\Def}[1]{\hyperref[def:#1]{Definition~\ref*{def:#1}}} \newcommand{\Alg}[1]{\hyperref[alg:#1]{Algorithm~\ref*{alg:#1}}} \newcommand{\Ex}[1]{\hyperref[ex:#1]{Ex.~\ref*{ex:#1}}} \newcommand{\Clm}[1]{\hyperref[clm:#1]{Claim~\ref*{clm:#1}}} \newcommand{\Obs}[1]{\hyperref[obs:#1]{Observation~\ref*{clm:#1}}} 

\def\hf{\hat{f}}
\def\hg{\hat{g}}
\def\Inf{{\sf Inf}}
\def\Viol{{\sf Viol}}
\def\Up{{\sf Up}}
\def\I{{\mathsf I}}
\def\V{{\mathsf V}}
\def\U{{\mathbf U}}
\def\mI{\overline{\mathbf I}}
\def\mV{\overline{\mathbf V}}
\def\mU{\overline{\mathbf U}}
\def\MON{{\tt MON}}
\def\dist{{\sf dist}}
\def\YES{{\sf YES}}
\def\NO{{\sf NO}}
\def\depth{{\sf depth}}
\def\fii{{f^{(i)}}}
\def\fext{f_{\textrm{\tt ext}}}
\def\ef{g_{\textrm{\tt ext}}}
\def\efg{g'_{\textrm{\tt ext}}}
\def\fa{f_{|\a}}
\def\fia{f^{(i)}_{|\a}}
\def\a{{\mathbf a}}
\def\b{{\mathbf b}}
\def\mid{{\sf mid}}
\def\max{{\sf max}}
\def\TV{{\sf TV}}
\def\lca{{\sf lca}}
\def\val{{\sf val}}
\def\lleft{{\sf left}}
\def\rright{{\sf right}}
\def\const{120}
\def\pdiext{d_{\textrm{\tt ext}}}
\def\pdiext{\pdi_{\textrm{\tt ext}}}
\def\d{\pdi}
\def\dext{\pdiext}
\def\cross{{\sf cr}}
\def\str{{\sf st}}
\def\pdi{{\mathfrak d}}
\def\cPdd{{\cP}}
\newcommand{\hcd}{{\tt hcd}}
\renewcommand{\lca}{{\tt lca}}


\newcommand{\cPd}[1]{\cP({#1})}
\newcommand{\probab}[2]{p^{(#2)}_{#1}}
\newcommand{\bigP}[1]{P_{#1}}
\newcommand{\lowC}{\mathop{lowC}}
\newcommand{\highC}{\mathop{highC}}
\newcommand{\set}[1]{\{#1\}}
\newcommand{\distmon}[2]{\varepsilon_{#1}(#2)}
\newcommand{\distline}{\varepsilon}
\newcommand{\diff}{\Gamma}
\newcommand{\frest}[2]{{#1}_{|#2}}
\newcommand{\slice}{S}
\newcommand{\mass}{m}
\def\VG{\mathcal{G}_{\mathsf{viol}}}

\newcommand{\edgeb}[1]{E(#1,\overline{#1})}
\newcommand{\as}{{\sf AS}}

\newcommand{\rev}[1]{\hbox{rev}(#1)}
\newcommand{\imb}[1]{\hbox{bal}(#1)}

\newcommand{\noise}{U}
\newcommand{\wS}{\widetilde{S}}
\newcommand{\crr}{\mathrm{Cr}}
\newcommand{\lp}[1]{\log_{\frac{1}{p}} #1}

\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}

\usepackage{url}
\urldef{\mailsa}\path|{alfred.hofmann, ursula.barth, ingrid.haas, frank.holzwarth,|
\urldef{\mailsb}\path|anna.kramer, leonie.kunz, christine.reiss, nicole.sator,|
\urldef{\mailsc}\path|erika.siebert-cole, peter.strasser, lncs}@springer.com|    
\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

\begin{document}

\mainmatter  
\title{On Counting Cliques, Clique-covers and Independent sets in Random Graphs\footnote{ supported in part by NSF Grant CCF-1320814}}

\titlerunning{Counting  in Random Graphs}

\author{Kashyap Dixit\and Martin F{\"u}rer}
\authorrunning{Kashyap Dixit \and Martin F{\"u}rer}

\institute{Pennsylvania State University\\
111 IST Building, University Park 16801, USA\\
kashyap@cse.psu.com\\
furer@cse.psu.edu\\
}


\toctitle{Counting  in Random Graphs}
\tocauthor{K.Dixit  {\em and} M.F{\"u}rer}
\maketitle


\begin{abstract}
We study the problem of counting the number of {\em isomorphic} copies of a given {\em template} graph, say , in the input {\em base} graph, say . In general, it is believed that polynomial time algorithms that solve this problem exactly are unlikely to exist. 
So, a lot of work has gone into designing efficient {\em approximation schemes}, especially, when  is a perfect matching. 
In this work, we present efficient approximation schemes to count -Cliques, -Independent sets and -Clique covers in random graphs. \\

We present {\em fully polynomial time randomized approximation schemes} (fpras) to count -Cliques and -Independent sets in a random graph on  vertices when  is at most , and -Clique covers when  is a constant. 
The problem of counting -cliques and -independent sets was an open problem in [Frieze and McDiarmid, 1997].
In other words, we have a fpras to evaluate the first  terms of the {\it clique polynomial} and the {\it independent set polynomial} of a random graph. 
[Grimmett and McDiarmid, 1975] present a simple greedy algorithm that {\em detects} a clique (independent set) of size  in  with high probability. No algorithm is known to detect a clique or an independent set of larger size with non-vanishing probability. 
Furthermore, [Coja-Oghlan and Efthymiou, 2011] present some evidence that 
one cannot hope to easily improve a similar, almost 40 years old bound for sparse random graphs. Therefore, our results are unlikely to be easily improved. \\

We use a novel approach to obtain a recurrence corresponding to the variance of each estimator. Then we upper bound the variance using the corresponding recurrence. This leads us to obtain a polynomial upper bound on the critical ratio.
As an aside, we also obtain an alternate derivation of the closed form expression for the -th moment of a binomial random variable using our techniques. The previous derivation [Knoblauch (2008)] was based on the moment generating function of a  binomial random variable.
\keywords{Random Sampling, Approximate Counting, Randomized Approximation Schemes for \#P-complete problems.}
\end{abstract}

\section{Introduction}
Given a {\em base graph}  and a {\em template graph} , {\em the subgraph isomorphism} problem is to decide whether an edge preserving injection  between the vertices of  and  exists. 
That is, for every edge  in ,  is an edge in . Subgraph isomorphism is a generalization of several fundamental NP-complete problems, like Hamiltonian Path and Clique. 
The problem has applications in many areas, including cheminformatics~\cite{U76}, pattern discovery in databases~\cite{KK07}, bioinformatics~\cite{PCJ06} and social networks~\cite{SPRH06}. 
Another widely studied related fundamental problem is that of counting the number of copies of  in . In general, this problem is \#P-complete (Valiant~\cite{V79}). The class \#P is defined as  
There exists a non-deterministic polynomial time Turing machine , such that on input , the computation tree of  has exactly  accepting leaves. The problems complete in this class are computationally quite difficult, 
since an oracle access to \#P complete problem would make it possible to solve any problem in the polynomial hierarchy in polynomial time (Toda~\cite{T91}). 

The -Clique problem asks whether there exists a -clique in the input graph . A -Clique is the complete graph on  vertices. The -Clique problem has numerous applications, particularly in bioinformatics and social networks~\cite{PCJ06,SPRH06}. 
Counting -cliques in a web-graph has applications in social network analysis. In particular, this gives an estimate of the number of closed communities in the web-graphs. Therefore, fast algorithms for counting -cliques in web-graphs give an insight to the evolution of Internet. 

The -Clique cover problem asks for the existence of a perfect -clique packing in . More precisely, given base graph  with  vertices and template graph  that is  vertex disjoint and edge disjoint copies of -cliques, does there exist an injective mapping from  to . 
The decision problem -Clique Cover, that is Gk is NP-complete on general graphs with clique number ~\cite{K72}.  The -Clique cover problem has applications in the {\em orgy problem}~\cite{CHW82}:
 Given a group of people with affinities and aversion between them, is it possible to divide them into   members each, such that every person in each group is compatible with every other person in the group. 
Some of the scheduling problems can also be modeled as an orgy problem. 
We are given  jobs of length  seconds and  machines. Also, for each job , we are given a list of {\em conflicting jobs} which can not be scheduled with  on the same machine. The problem is to schedule the jobs on the machines such that the total time to complete all the jobs is minimized. 

The clique-polynomial~\cite{HL94} of a graph  is given by . Here,  denotes the number of -Cliques in ,  denotes the size of largest clique in . The independent-set polynomial~\cite{HL94} of a graph is defined analogously. 
In general, computing the clique-polynomial and the independent set polynomial of a graph  is -complete. 

We consider template graphs which are vertex disjoint union of cliques. More specifically, we will be considering problems of counting cliques and clique covers. We note that our techniques can be extended to counting embeddings of template graphs which are disjoint union of cliques of possibly different sizes.
The counting version of the -Clique problem is \#P-complete in general.  The counting version of the -Clique cover problem is \#P-complete even for  (Valiant~(\cite{V79})), where  is a perfect matching. 

Note that the counting versions of the aforementioned problems are extremely hard even for the simple cases. So, we try to come up with {\em fully polynomial time approximation schemes} (abbreviated as fpras) for these problems that work well for {\em almost all} graphs. More precisely, 
fpras must run in time  and return an answer within a relative error of  with high probability (i.e., probability tending to  as ) for graphs that are uniformly randomly sampled from . Here,    denotes the class of 
graphs in which each edge occurs with probability . Note that when , each graph  is equiprobable. Another commonly studied model is  where each graph with  vertices 
and  edges is assigned the same probability, which is , where . 

The theory of random graphs was initiated by Erd\H{o}s and R\'{e}nyi~\cite{ER60}. We work with the model  where we are given a fixed set of  vertices and each of the  edges is added with probability . 

Our analysis also provides an alternate derivation of the closed form of the  moment of a binomial random variable  sampled from , which has been derived by Knoblauch~\cite{K08a} using {\em moment generating function}. We derive the same results using simple binomial equalities that we obtain using the binomial theorem.
\subsection{Our results}
In this work, we present new results for -Clique and -Clique cover counting problems  in random graphs. Our algorithm is based on the idea of Rasmussen's unbiased estimator for permanents~\cite{R94}. 
It has been widely used in the context of subgraph isomorphism counting problems~\cite{R97,FK05,FK08}. For counting -cliques in the input random graph , we embed a -clique into , doing so one vertex at a time chosen randomly. 
If the procedure succeeds, we compute the probability with which the clique is obtained in  
and output its inverse. As shown in~\cite{FK08}, this is an unbiased estimate of the number of cliques in . We state the results below in \Thm{app-clique}.  
In this work, we generalize Rasmussen's approach~\cite{R94} to efficiently count -cliques and -clique covers in random graphs. As a corollary, we also get a fpras for counting -independent sets in random graphs. 
Note that~\cite{CE11} indicates that our bounds is extremely difficult to be improved. 
\begin{theorem}\label{thm:app-clique}
Let  be a -Clique, where . Then, there exists a fpras for estimating the number of copies of  in  for constant .
\end{theorem}

Note that counting -cliques in  is equivalent to counting -independent sets in . Since  is a constant in our case, we have a fpras for counting -Independent sets of a random graph.

\begin{theorem}\label{cor:app-ind-sets}
Let  be a -independent set, where . Then, there exists a fpras for estimating the number of copies of  in  for constant .
\end{theorem}

For counting -clique cover, we embed one clique at a time, until the whole graph is covered by -cliques. The {\em key} observation here is that after embedding a clique, the residual base graph still remains random with edge probability . We obtain the following theorem for counting -clique covers.
\begin{theorem}\label{thm:app-clique-covers}
Let  be a -clique cover, where .  Then, there exists a fpras for estimating the number of copies of  in  for constant .
\end{theorem}

 Our estimators for counting cliques and clique-covers are given in \Alg{app-clique} and \Alg{app-clique-cover} respectively in \Sec{app-estimators}.  As a side result, we obtain an alternate derivation of   for a binomial random variable , for all . We note that this has already been obtained in~\cite{K08a} 
using the moment generating function for binomial random variable. 


\textbf{Outline of the paper}: In \Sec{app-prev}, we give some of the related work to set perspective for our work. 
To introduce our techniques to the reader, we give a new derivation for the closed form of  -th moment for binomial random variables using these techniques \Sec{app-model-definitions}. 
We move on to describe estimators for counting -cliques and -clique covers in \Sec{app-estimators}. We analyze these estimators for counting -cliques and -clique covers for random graphs in \Sec{app-clique} and \Sec{app-ccover} respectively, which is the main contribution of this paper. 

\section{Related work}\label{sec:app-prev}
A lot of work has been done in finding and counting of cliques and independent sets in graphs. One of the earliest result in the theory of random graphs is about showing that the independence number and clique number of a random graph  is about . 
Grimmett and McDiarmid~\cite{GM75} analyzed simple greedy algorithm constructs an inclusion-maximal independent set. They showed that it yields an independent set of size . Coja-Oghlan and Efthymiou~\cite{CE11} show some evidence for why no better algorithm could be found over many years. 

Luby and Vigoda~\cite{LV97} have shown a fully polynomial time scheme for counting independent sets in the graphs with maximum degree , which was later improved by Weitz~\cite{W06} to . On the other hand,
 Dyer, Freize and Jerrum~\cite{DFJ02} have shown that no fpras exists for counting independent sets in graphs with  unless NP=RP. They also show that 
the Markov Chain Monte Carlo technique is likely to fail if . Chandrasekaran et.al.~\cite{CCGSS11} have obtained fpras for higher degree graphs with large girths. 

A major breakthrough in counting perfect matchings (-clique covers) was a polynomial time algorithm for planar graphs due to Kasteleyn~\cite{K61}.   For a bipartite graph, it corresponds to calculating the permanent of a  matrix. In the seminal  paper of Valiant~\cite{V79}, 
 it has been shown to be \#P-complete, even though the decision version of this problem is in P.
The noted work of Jerrum, Sinclair and Vigoda~\cite{JSV01} presents a fpras for counting perfect matchings in bipartite graphs. The problem of existence and counting of covers in random graphs  was addressed in the seminal work of Johansson, Kahn and Vu~\cite{JKV08}. 
They show that given a subgraph , the number of -covers in a random graph  is  for large enough  with probability at least . 
Here  and .  Various approaches for getting an unbiased estimator with small variance have been explored for counting perfect matchings in other graphs. 
Some of these are determinant based approaches~\cite{GG81,KKLLL93,C04,LP86}, Markov chain Monte Carlo (MCMC) algorithms~\cite{B86,JS89,JSV01,BSVV08} and search based on Rasmussen's techniques ~\cite{R94,R97,FK05,FK08}. 
Chien~\cite{C04}  gives an efficient fpras for counting perfect matchings in random graphs. MCMC algorithms are polynomial time algorithms for all bipartite graphs. 
The estimators based on Rasmussen's approach (from~\cite{R94}) have also been proved to work well in random graphs, where they lead to simple, polynomial time approximation schemes. In this work, we generalize Rasmussen's approach to efficiently count -Cliques and -Clique covers in random graphs. 
As a corollary, we also get a fpras for counting -Independent sets in random graphs.


 Rasmussen~\cite{R97} has given a fpras for counting cliques and independent sets in random graphs. But it is unclear how to extend that algorithm for counting -cliques~\cite{FM97} or -Independent sets in random graphs. We note here that 
F{\"u}rer and Kasivaswanathan~\cite{FK08} have used similar techniques to get fpras for a large class of subgraph isomorphism problems. A fundamental constraint in their analysis was that the template subgraphs triangle-free. Thus,
their analysis could not be extended directly to get fpras for -clique, -independent set and -clique cover problems. 


\section{  moment of a binomial random variable}\label{sec:app-model-definitions}
Consider the binomial random variable . We are interested in finding the  moment of , i.e. we want to find . In this section, we give the closed form expression for . 
We evaluate using new equalities obtained from well known binomial theorem. Note that 


We start with the most fundamental equality known as binomial theorem given below.
 

Suppose we differentiate \Eqn{app-binom} with respect to  and multiply by  subsequently, we get the following equation.


Note that substituting  in \Eqn{app-1st} and multiplying by , we get , which is the first moment of . Suppose we differentiate \Eqn{app-1st} w.r.t. 
 again and multiply by  subsequently, we get


The term  denotes the falling factorial . Again, substituting  in \Eqn{app-2nd} and multiplying , 
we get . 
The above calculations show an emerging pattern for higher moments, which \Lem{app-binom} illustrates. 
\begin{lemma}
\label{lem:app-binom}

Here  are the coefficients that depend on  and  but are independent of . Here  .
\end{lemma}
\begin{proof}
We will prove the above lemma by induction. For , this is true as shown in \Eqn{app-1st}. Suppose the lemma is true for . We prove that it holds for . Differentiating \Eqn{app-binomk} w.r.t.  and subsequently multiplying with  gives


Note that the \Eqn{app-x} shows that  where  follows the recurrence relation 
 
As given in~\cite{K08a}, Stirling numbers of second kind follow this recurrence. 

\end{proof}
To get the  moment, we simply substitute  in \Eqn{app-binomk} and multiply by . Hence we have the following theorem.

\begin{theorem}
\label{thm:app-binomk}

where  are as given in \Eqn{app-coeff}.
\end{theorem}

\section{Estimators for counting -cliques and -clique covers in random graphs}\label{sec:app-estimators}
In this section, we formally describe our estimators. The estimator for counting cliques in given in \Alg{app-clique}. Note that it embeds the clique  and outputs the inverse of probability of embedding it in this way into .
The estimator embeds one vertex at a time until the whole clique is embedded. If the algorithm gets stuck, it outputs . This process can be viewed as decomposing the clique into subgraphs , where each  is
 the subgraph induced by the  numbered vertex  and its lower numbered neighbors. It is denoted by . 

We denote our randomized estimator by  and let  be the output estimate. To get an fpras, we need that , also called the {\em critical ratio}, is polynomially bounded. 
We will bound a related quantity called {\em critical ratio of averages} given by . Here, the outer expectation is over the graphs of   and the inner
 expectation is over the coin tosses of the estimator. Our focus in this work will be to get a bound on critical ratio of averages. As shown in \Prop{app-FK08}, this will also give a polynomial bound on the critical ratio itself.
The proof of \Prop{app-FK08} follows from \Cor{app-asymptotic} of \Thm{app-R00} from~\cite{R00}.

Consider any induced subgraph  of  with  vertices. Let  of edge  For stating the results, we need to define the following ratio for the template graph .


Note that  is closely related to the largest possible average degree of an induced subgraph of . In our case, this is  for the case of counting cliques and  for counting clique covers. Let  
denote the number of copies of  in .

\begin{theorem}[\cite{R00}]\label{thm:app-R00}
Let  be a graph on  vertices and  be as defined above. Let  be a constant. Suppose that the following conditions hold:  and . Then, with high probability, 
a random graph  has a spanning subgraph isomorphic to . In general,
 satisfies 

\end{theorem}
\emph{Remarks.} Note that \Thm{app-R00} holds for the spanning subgraphs of the random graphs. This assumption can easily be incorporated while embedding a single clique at any step. While embedding each clique, 
 is considered to be the  vertex graph which is the disjoint union of a clique and the isolated vertices in both the cases. 
Also, note that  since  and  are both bounded by . Therefore, all conditions of \Thm{app-R00} are satisfied in our case. So we get the following corollary in our case.

\begin{corollary}\label{cor:app-R00}
Let  and  be one of the following graphs 

Then , where  denotes the number of copies of  in .
\end{corollary}

From the asymptotic equivalence between  and  (see e.g.~\cite{JLR00,R94}), we have the following corollary.

\begin{corollary}\label{cor:app-asymptotic}
Let  and  be one of the following graphs 

Then , where   be a real valued function that goes to  as .
\end{corollary}
\Thm{app-R00} along with \Cor{app-R00} and \Cor{app-asymptotic} yield the following proposition. The proof is identical to the one given for a similar proposition in~\cite{FK08}, but we give it make the write-up self contained.

\begin{proposition}\label{prop:app-FK08}
Let  and  be one of the following graphs 
 Let X be the output of Algorithm Embeddings, and let  be a constant. Then, for a random graph  
the critical ratio satisfies , where  such that  as .
\end{proposition}

\begin{proof}
For the unbiasted estimator , we have . Therefore, from \Cor{app-asymptotic}, we have that  with high probability.  Also, from Markov's inequality we have .
Therefore with probability at least , we have . Our result follows from these inequalities.
\end{proof}

In the rest of the paper, we focus on bounding the critical ratio of averages. The estimator for counting -cliques is given in \Alg{app-clique}. It embeds one clique of size  in  and outputs the inverse of probability of embedding. This is done by the procedure \textproc{Embed-Clique}, 
which is called only once in this case.

\begin{algorithm}
\caption{Count-cliques()}\label{alg:app-clique}
\begin{algorithmic}[1]	
\Procedure{Embed-Clique}{}\State  \Comment{ denotes the number of nodes already embedded in }
\State  \Comment{Arbitrarily assign a node from  to }
\While{}\State \If {} 
	\State  \Comment{Embedding algorithm has failed; so terminate}
\EndIf\State 
\State \Comment{uniformly randomly assign a node from  to }
\State 
\State 
\EndWhile\label{euclidendwhile}
\State \textbf{return} \Comment{Estimator outputs unbiased estimate of number of -Cliques}\label{step:1last}
\EndProcedure
\end{algorithmic}
\end{algorithm}

The estimator for counting -clique covers of  is given in \Alg{app-clique-cover}. It uses the procedure \textproc{Embed-Clique} described in \Alg{app-clique} to embed each -clique in the cover. This process is sequentially repeated until all the vertices are covered. 
In the end, it returns the inverse of probability of finding the cover, if successful. Note that this is the product of the probabilities of embedding the individual cliques in the cover. 
\begin{algorithm}
\caption{Count-clique-covers()}\label{alg:app-clique-cover}
\begin{algorithmic}[1]
\State 
\State \Comment{Size of the automorphism group of -clique cover}
\State 
\While{}
\State \textproc{Embed-Clique()}
\If {\textproc{Embed-Clique() }} 
	\State  \Comment{Embedding algorithm has failed; so terminate}
\EndIf
\State \Comment{Remove the currently embedded clique  from  to get }
\EndWhile
\State \textbf{return} 
\end{algorithmic}
\end{algorithm}


\section{Analysis of estimator for counting cliques and clique-covers in random graphs}
In this section, we show a polynomial bound on the critical ratio of averages for the estimators in \Alg{app-clique} and \Alg{app-clique-cover}. Note that from \Prop{app-FK08}, this is sufficient to bound the critical ratio of the estimator and hence get an fpras for 
counting -cliques (for ) and -clique covers (for ) in random graphs.





\subsection{Counting Cliques}\label{sec:app-clique}
In this section, we prove \Thm{app-clique}. In this case, the estimator embeds a single clique onto the base graph and outputs the inverse of probability of embedding the same. Let , the random variable denoting the count,
 be the output of the estimator. The estimator selects first vertex in the graph arbitrarily and embeds 
one edge at a time until the whole clique is embedded. It outputs the inverse of probability of embedding if it goes through, else it outputs . 

Let  corresponds to the number of ways to embed vertex  in the residual graph. Note that . Now consider the term . 

To estimate the critical ratio of averages, we need the definition of -nesting, denoted by , as follows.
\begin{definition}[-nesting]\label{def:app-k-nesting}
A -nesting is a function  that can be evaluated in the following recursive way. 
\begin{enumerate}[(i)]
\item The -nesting is defined as  
\item The -nesting is defined as 
\end{enumerate}
\end{definition}

Note that the embedding of a -clique can be thought of as embedding -vertex to get an -clique from -clique for each . So, we have the following observation.

\begin{observation}\label{obs:app-variance} 

\end{observation}

\Lem{app-num-term} shows the exact structure of ,  which we use in getting the bound on the critical ratio. 
\begin{lemma}
\label{lem:app-num-term}

Here  is a function in  that is independent of  with the following properties. 
\begin{enumerate}[(i)]
\item  for all  and  for all .
\item .
\end{enumerate}
\end{lemma}

\begin{proof}
We prove this by induction on . For the base case, {\em i.e.} for  this is 


Suppose the claim is true for  for . We will show that the claim is true for . From \Def{app-k-nesting} we have


\end{proof}
The following lemma is used in the proof of \Lem{app-num-term}.
\begin{lemma}\label{lem:app-fact-mom}

In particular, if we multiply \Eqn{app-fact-mom} by  and substitute  we get

\end{lemma}
\begin{proof}
We prove the identity in \Eqn{app-fact-mom} using induction.For  (base case) we need to show that
, which holds from \Eqn{app-1st}. For hypothesis, assume that \Eqn{app-fact-mom} holds for . We prove that it also holds for  as follows. 
Differentiating \Eqn{app-fact-mom} w.r.t.  gives 


Hence the identity holds for .
\end{proof}



The following lemma upper bounds  for 
\begin{lemma}\label{lem:app-f-upper-bound}
For   where . 
\end{lemma}

\begin{proof}
We will prove this claim using induction on . Consider  for the base case. From \Def{app-k-nesting}, we have . So, the claim holds. Now assume that the claim holds for all clique sizes up to  
Now, from \Eqn{app-num-poly}, we have the following recurrence relation. 


First we prove for . Using \Eqn{app-recurrence}, we have 


Now we show that . From \Eqn{app-recurrence}, we have  since . 
Applying the recurrence repeatedly, we get the desired relation.
\end{proof}

Now we bound  which is the same as 
We have


\Lem{app-clique} immediately proves \Thm{app-clique}.

\begin{lemma}\label{lem:app-clique}
For ,   is upper bounded by .
\end{lemma}

\begin{proof}
Consider the ratio  for a fixed . Here we have . As we shall see,  changes for the -Clique cover. For , this is  since . Note that 
. Now we consider .

The first inequality above uses \Lem{app-f-upper-bound},  and  for all . Note that . So, we have 
, where  is as defined in \Eqn{app-hi}. Note that for ,  
is polynomially bounded for all . Therefore  is polynomially bounded.
\end{proof}

\begin{lemma}\label{lem:app-poly}
For ,  is polynomially bounded for all .
\end{lemma}
\begin{proof}
First note that 

Let , where . This function is maximized at the point where , which happens at
. At this point, . Note that  is polynomially bounded only when .

\end{proof}


\subsection{Clique cover counting}\label{sec:app-ccover}
As noted earlier in \Prop{app-FK08}, we focus on bounding the  {\em critical ratio of averages} given by  for \Alg{app-clique}. 

The estimator embeds one clique at a time, by selecting a vertex at random at first and then embedding each edge till  vertices of the clique are embedded. A crucial observation is that the residual graph, after embedding a clique still remains random with edge probability . 
Finally, the estimator sequentially embeds  cliques to get the clique cover and outputs the inverse of probability of getting this clique cover, if the embedding procedure goes through, otherwise it outputs . Note that this is the product of the inverse of the probabilities for embedding each clique. 
Let  denote the random variable corresponding to the estimate of the number of embeddings of the  clique in the residual graph, which is a random graph from . Note that  is independent from  for  and .
Therefore we have the following equation.

Note that the equality follows from the fact that after embedding each -clique, the residual graph still remains random with edge probability . Now, we bound the numerator, {\em i.e.}, .  


Let  corresponds to the number of ways to embed vertex  in the residual graph. Note that . 

Now consider the term . 
Note that in this case, we have 

We show in \Lem{app-cri-rat-int-bound} that  is bounded by  for all , where . 
\begin{lemma}\label{lem:app-cri-rat-int-bound}
For large , constant   and constant  we have 
\end{lemma}

\begin{proof}
Consider the ratio  for a fixed . For , this is  since . Note that 
. Now we consider . 
As shown in \Eqn{app-hi}, we have 


To prove the lemma, we handle the cases of  and   separately. First we handle the latter case. For , we prove that . In other words, we prove that  for constant .
 

Let .  Consider the continuous function 
. Therefore we have 


Observe that for large  and for constant , the term  dominates all the other terms, so  for . Therefore  is a decreasing function.  We analyze cases  and  separately.
First we analyze latter case.  We prove that , which implies that  for . This proves that  for  , eventually proving that
 

Consider the function . So we have 



Note that for constant , this is smaller than  for large enough . Therefore , hence the claim.

Now we do the analysis for . We calculate  using the recurrence. 


Going on as shown in the above equation, we get . Therefore we have


Note that 


Note that for constant ,  is a constant.
Therefore, using \Eqn{app-ige2} and \Eqn{app-ie1} we have 

Hence the lemma.
\end{proof}

Note that \Lem{app-cri-rat-int-bound} shows that . Note that \Thm{app-clique-covers} follow from \Lem{app-cri-rat-int-bound} since 
 in this case.

\section{Conclusion and open problems}
In this work, we show the first fpras for counting -cliques, where  and -clique covers (for constant ) in random graphs, using the unbiased estimators that are very simple to describe. Both problems are \#P-complete in general for the respective values of . 
Getting a fpras for these problems over general graphs is a long standing open problem. Here are some specific open problems that we think are worth investigating.
\begin{enumerate}
\item The problem of counting clique is still open for counting cliques of size greater . Solving this will resolve the open problem of Frieze and McDiarmid~(\cite{FM97}) completely, though, this is probably very hard to solve~\cite{CE11}.
\item Another specific problem to resolve here is to count clique covers of superconstant sized cliques. 
\item The determinant based estimators usually have smaller worst case running times in fpras (e.g.~\cite{C04}) for random graphs. It is unclear to us how to obtain any determinant based unbiased estimators for the clique and clique cover counting problems.
\end{enumerate}

\bibliographystyle{plain}
\bibliography{references}

\end{document}
