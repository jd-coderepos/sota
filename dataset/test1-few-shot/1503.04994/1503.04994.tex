\documentclass{llncs}
   \usepackage{times}
   \usepackage{mathptm}
   \usepackage{epsfig}
   \usepackage{color}
   \usepackage{latexsym}
   \usepackage{pslatex}
   \usepackage{cite}
   \usepackage{graphicx}
   \usepackage{algorithm}
   \usepackage{algorithmic}
   \usepackage{listings}
   \usepackage{multirow}
   \usepackage{pslatex}
   \usepackage{tabularx}
   \usepackage{colortbl}
   \usepackage{amsfonts}

\newenvironment{keywords}{
       \list{}{\advance\topsep by0.35cm\relax\small
       \leftmargin=1cm
       \labelwidth=0.35cm
       \listparindent=0.35cm
       \itemindent\listparindent
       \rightmargin\leftmargin}\item[\hskip\labelsep
                                     \bfseries Keywords:]}
     {\endlist}

\newtheorem{defn}{Definition}
\newtheorem{prop}{Property}



\newcommand{\procname}[1]{\textsc{#1} }
\newcommand{\ALGORITHM}{\textbf{algorithm} }
\newcommand{\AND}{\textbf{and} }
\newcommand{\ARRAY}{\textbf{array} }
\newcommand{\BEGIN}{\textbf{begin} }
\newcommand{\BL}{\textbf{begin\_loop} }
\newcommand{\CASE}{\textbf{case} }
\newcommand{\ELSE}{\textbf{else} }
\newcommand{\ESAC}{\textbf{esac} }
\newcommand{\END}{\textbf{end} }
\newcommand{\EL}{\textbf{end\_loop} }
\newcommand{\DO}{\textbf{do} }
\newcommand{\FI}{\textbf{fi} }
\newcommand{\FOR}{\textbf{for} }
\newcommand{\FOREACH}{\textbf{for each} }
\newcommand{\IF}{\textbf{if} }
\newcommand{\IN}{\textbf{in} }
\newcommand{\OD}{\textbf{od} }
\newcommand{\OF}{\textbf{of} }
\newcommand{\OR}{\textbf{or} }
\newcommand{\OUT}{\textbf{out} }
\newcommand{\PRINT}{\textbf{print} }
\newcommand{\QUEUE}{\textbf{queue} }
\newcommand{\RECORD}{\textbf{record} }
\newcommand{\RETURN}{\textbf{return} }
\newcommand{\SET}{\textbf{set} }
\newcommand{\THEN}{\textbf{then} }
\newcommand{\GO}{\textbf{go} }
\newcommand{\TO}{\textbf{to} }
\newcommand{\TYPE}{\textbf{type} }
\newcommand{\UNTIL}{\textbf{until} }
\newcommand{\VAR}{\textbf{var} }
\newcommand{\WHILE}{\textbf{while} }
\newcommand{\CONTINUE}{\textbf{continue} }
\newcommand{\BREAK}{\textbf{break} }
\newcommand{\true}{\mathsf{true}}
\newcommand{\false}{\mathsf{false}}
\newcommand{\implies}{\rightarrow}
\newcommand{\biimplies}{\Leftrightarrow}
\newcommand{\props}{\Pi}
\newcommand{\INPUT}{\textbf{input:} }

\newcommand{\scope}{\mathbin{.}}


\begin{document}
\thispagestyle{plain}
\pagestyle{plain}  

\title{A Linear-Time Algorithm for Finding All Double-Vertex Dominators of a Given Vertex}
\author{Maxim~Teslenko\inst{1} \and Elena Dubrova\inst{2}}
\institute{Ericsson Research, Ericsson, F\"ar\"ogatan 6, 164 80 Stockholm, Sweden\\
\email{maxim.teslenko@ericsson.com}
\and
Royal Institute of Technology, Electrum 229, 164 40 Stockholm, Sweden\\
\email{dubrova@kth.se}
}

\maketitle
 
\begin{abstract}

Dominators provide a general mechanism for identifying reconverging paths in graphs. This is useful for a number of applications in Computer-Aided Design (CAD) including signal probability computation in biased random simulation, switching activity estimation in power and noise analysis, and cut points identification in equivalence checking. However, traditional single-vertex dominators are too rare in circuit graphs. In order to handle reconverging paths more efficiently, we consider the case of double-vertex dominators which occur more frequently. First, we derive a number of specific properties of double-vertex dominators. Then, we describe a data structure for representing all double-vertex dominators of a given vertex in linear space. Finally, we present an algorithm for finding all double-vertex dominators of a given vertex in linear time. Our results provide an efficient systematic way of partitioning large graphs along the reconverging points of the signal flow.
\end{abstract} 

\begin{keywords} 
Graph, dominator, min-cut, logic circuit, reconverging path
\end{keywords} 
\section{Introduction}
\label{ddom_sec:introduction}

This paper considers the problem of finding dominators in circuit graphs. 
A vertex  is said to {\em dominate} another vertex  if every path
from  to the output of the circuit contains ~\cite{LeT79}.  
For example, for the circuit in Figure~\ref{ddom_f2}(a), vertex 
dominates vertex ; vertex  dominates vertex , etc.

Dominators provide a general mechanism for identifying re-converging
paths in graphs. If a vertex  is the origin of a
re-converging path, then the immediate dominator of  is the
earliest point at which such a path converges. 
For example, in
Figure~\ref{ddom_f2}(a), the re-converging path originated at  ends at ;
the re-converging path originated at  ends at .

Knowing the precise starting and ending points of a re-converging path
is useful in a number of applications including computation of signal
probabilities in biased random simulation, estimation of switching activities in power and
noise analysis, and identification of cut points in
equivalence checking.

The {\em signal probability} of a net in a combinational circuit is
the probability that a randomly generated input vector will produce
the value one on this net~\cite{PaM75}. Signal probability
analysis is used, for example, to measure and control the coverage of vector
generation for biased random simulation~\cite{KuLWCH07}.

The average {\em switching activity} in a
combinational circuit is the probability of its net values to change
from 0 to 1 or vice verse~\cite{GhDK92}.  It correlates directly with the average
dynamic power dissipation of the circuit, thus its analysis is
useful for guiding logic optimization methods targeting low power consumption~\cite{CoMD97}.


Computation of signal probabilities and switching activities based on
topologically processing the circuit from inputs to outputs and
evaluating the gate functions generally produces incorrect results due
to higher-order exponents introduced by correlated signals~\cite{PaM75}. For
example, if the functions  and  have variables in common, then
, where  is the signal
probability.  Dominators provide the earliest points during
topological processing at which all signals correlated with signal originated at the dominated vertex
converge. Therefore, the computation of
signal probabilities and switching activities can be 
partitioned along the dominator points.


Cut-points
based equivalence checking partitions the specification and implementation 
circuits along frontiers of functionally equivalent signal pairs, called 
{\em cut-points}~\cite{KhMKH01}.  This is usually done in four steps: (1) cut-points
identification, attempting to discover as many cut-points as possible,
(2) cut-points selection, aiming to choose the cut-points which
simplify the task of verification, (3) equivalence checking of the
resulting sub-circuits, (4) false negative reduction.
Dominators provide a systematic mechanism for identifying and choosing good cut-points
in circuits, since converging points of the signal flow are ideal candidates for cut-points.

In spite of the theoretical advantages of dominators,
previous attempts to apply dominator-based techniques to large circuits
have not been successful. 
Two main reasons for this are: (1) single-vertex dominators,
which can be found in linear time, are too rare in circuits; (2)
multiple-vertex dominators, which are common in circuits, require
exponential time to be computed. 
In other words, no systematic approach
for finding useful dominators in large circuits efficiently has been known so far.
Useful are normally dominators of a
small size because  combinations of values
of a -vertex dominator have to be manipulated to resolve signal correlations~\cite{KrDK03}.

In this paper, we focus on the specific case double-vertex dominators.  
First, we prove a number of fundamental properties of double-vertex dominators.
For example, we show that immediate double-vertex dominators are unique.
This property also holds for single-vertex dominators, but it does not extend
to dominators of size larger than two. Then, we present a data structure for representing
all double-vertex dominators of a given vertex in linear space. 
Finally, we introduce an algorithm for finding
all double-vertex dominators of a given vertex in linear time.
This asymptotically reduces the complexity of the previous quadratic
algorithm for finding double-vertex dominators~\cite{TeD05b}.




The paper is organized as follows. Section~\ref{basic} 
presents basic notation and definitions.
In Section~\ref{ddom_prelim}, we introduce
definitions of dominators which are more
general than the traditional ones from~\cite{LeT79}. 
Section~\ref{ddom_prev} summarizes the
previous work on dominators.  
In Sections~\ref{ddom_mdp} and~\ref{sec_dd}, we describe properties of 
multiple-vertex and double-vertex dominators, respectively.
Section~\ref{ddom_ds} presents the data
structure for representing double-vertex dominators.
Section~\ref{ddom_alg} describes the new algorithm for finding double-vertex dominators. 
The experimental results are shown in
Section~\ref{ddom_exp}. Section~\ref{ddom_con} concludes the paper.

\begin{figure}[t!]
\begin{center}
\includegraphics*[width=4in]{figure1-crop.pdf}
\caption{(a) An example circuit; (b) Its dominator tree.}
\label{ddom_f2}
\end{center}
\end{figure}

\section{Preliminaries} \label{basic}

Unless otherwise specified, throughout the paper, we use capital letters  etc.
to denote vectors and bold letters  etc. to denote sets.

Let  denote a single-output acyclic circuit graph where the set
of vertices  represents the primary inputs and gates.  A particular
vertex  is marked as the circuit output. The set of edges
 represents the nets connecting the gates.

{\em Fanin} and {\em fanout} sets of a vertex  are defined as  and , respectively.

The {\em transitive fanin} of a vertex  is a subset of
 containing all vertices from which  in reachable.
Similarly, the {\em transitive fanout} of a vertex  is a subset of
 containing all vertices reachable from .

A {\em path}  is a vector of vertices of 
such that  for all . The
vertices  and  are called the {\em source} and the {\em
sink} of , respectively. The source and the sink of  are
called the {\em terminal} vertices of . The remaining vertices of 
 are called the {\em non-terminal} vertices. 

Throughout the paper, we call two paths {\em disjoint} if the intersection of
sets of their non-terminal vertices is empty.

Given two paths  and , the {\em concatenation} of  and 
is defined only if . The result of the
concatenation is the path .  We use the notation  to denote that 
is a concatenation of  and .

A {\em prefix} of a vertex , denoted by {\em prefix}, is a sub-vertex of 
 containing  first adjacent vertices of  for some . 
A {\em suffix} of a vertex , denoted by {\em suffix},
is a sub-vertex of  containing  last adjacent vertices of  for some . 

\section{Definition of Dominators} \label{ddom_prelim}

In this section, we introduce definitions of dominators and immediate
dominators which are more general than the traditional ones from~\cite{LeT79}.


\begin{defn} \label{ddom_dom}
A set of vertices  {\em dominates} a set of vertices  with
respect to a set of vertices  if every path which starts at a vertex
in  and ends at a vertex in  contains at least one vertex from
. 
\end{defn}

\begin{defn} \label{ddom_dom2}
A set of vertices  is a {\em dominator} of a set of vertices
 with respect to a set of vertices , if
\begin{itemize}
\item[(a)]  dominates ,
\item[(b)] ,  does not dominate .
\end{itemize}
\end{defn}

The sets  and  are called, the {\em source} set and the {\em sink} set, respectively.
For example, for the circuit in Figure~ \ref{ddom_f2}(a),  is a dominator of the source 
with respect to the sink .

In most applications of dominators, the source set  and the
sink set  are known, while the dominator set  needs to
be computed. The sizes of the sets ,
 are neither important for the choice of data structure for representing dominators,
nor for the algorithm which finds them. Vertices in the set 
can be merged into a single vertex  which feeds all the vertices fed by any vertex in . Similarly, vertices into the set 
can be merged to a single vertex  which is fed by all vertices feeding any vertex in . In this case finding a dominator for  with respect to  is equivalent to finding a dominator for  with respect to . Therefore, an algorithm which
handles the case  can be extended to the sets  and  of an arbitrary size.

Contrary, the size of the dominator set  is crucial for the choice
of data structures and algorithms.  
Therefore, the size of 
is the most important criteria for characterizing the properties of a
dominator. 
We use the term -{\em vertex dominator} to refer to
the case of . If  then we may also call a -vertex dominator {\em multiple-vertex dominator}.
If a dominator dominates more then one vertex, i.e. , it is called
{\em common} -vertex dominator.

Throughout this paper, unless specified otherwise, the vertex 
is assumed to be the sink for any considered dominator relation.
So, if we say that  dominates , we mean that  dominates
 with respect to .

\begin{defn} \label{ddom_sdom}
A set of vertices  is a {\em strict} dominator of a set of vertices ,
if  is a dominator of  and .
\end{defn}

For example, in Figure~ \ref{ddom_f2}(a),  is a dominator of ,
but it is not strict. On the other hand,  is a strict dominator of . Obviously, any
dominator of a single vertex is a strict dominator. All results in this paper are derived for 
dominators of single vertices. Therefore, throughout the paper when we write "dominator" it also means "strict dominator".
Note that 
any algorithm which finds only strict dominators can be 
extended to find all dominators by introducing a
fake vertex which feeds all nodes in . The search is
carried out with the fake vertex constituting the new .


\begin{defn} \label{ddom_idom}
A set  is an {\em immediate} -vertex dominator of a set  if  is
a strict -vertex dominator of  and  does not dominate , where  is
any other strict -vertex dominator of .
\end{defn}

The concept of immediate dominators has a special importance for
single-vertex dominators. It was shown
in~\cite{LoM69,AhU72} that every vertex  in a directed acyclic graph  except  has a
unique immediate single-vertex dominator, .
The edges  form a directed
tree rooted at , which is called the {\em dominator tree} of
. For example, the dominator tree for the circuit  in Figure~\ref{ddom_f2}(a) is shown in Figure~\ref{ddom_f2}(b).

Note that the immediate multiple-vertex dominators are not necessarily unique.
For example, vertex  in Figure~\ref{ddom_f2}(a) has two immediate 3-vertex dominators:  and .
Later in the paper we prove that the immediate dominators 
are always unique for the case of .

It might be worth mentioning that dominators are more general than
{\em min-cut} in circuit partitioning~\cite{KeL70}. A min-cut is
required to dominate all vertices in its transitive fanin. Therefore, every
min-cut is a dominator, but not every dominator is a min-cut.

\section{Previous Work} \label{ddom_prev}

The problem of finding single-vertex dominators was first considered
in global flow analysis and program optimization. Lorry and
Medlock~\cite{LoM69} presented an  algorithm for finding
all immediate single-vertex dominators in
a flowgraph with  vertices.
Successive improvements of this algorithm were done
by Aho and Ullman~\cite{AhU72}, Purdom and Moore~\cite{PuM72}, and
Tarjan~\cite{Ta74}, culminating in Lengauer and Tarjan's~\cite{LeT79}
 algorithm, where  is the number of edges and
 is the standard functional inverse of the Ackermann function
which grows slowly with  and .

The asymptotic time complexity of finding single-vertex dominators was
reduced to linear by Harel~\cite{Ha85}, Alstrup et al.~\cite{AlHLT99}
and Buchsbaum et al.~\cite{BuKRW98}. However, these improvements in
asymptotic complexity did not contribute much to reducing the actual
runtime. For example, the algorithm~\cite{BuKRW98} runs 10\% to 20\%
slower than Lengauer and Tarjan's~\cite{LeT79}. Lengauer and Tarjan
algorithm appears to be the fastest of algorithms for single-vertex
dominators on graphs of large size.


One of the first attempts to develop an algorithm for the
identification of multiple-vertex dominators was done by
Gupta. In~\cite{gupta}, three algorithms addressing this
problem were proposed. The first finds all immediate multiple-vertex dominators of
size up to  in  time. Computing immediate dominators is
easy because an immediate dominator of a vertex  is always
contained in the set of fanout vertices of . Possible redundancies
can be removed by checking whether for every  in the fanout of
 there exists at least one path from  to  which contains
 and does not contain any other  in the fanout of .

The second algorithm in~\cite{gupta} finds all multiple-vertex dominators of
a given vertex. The number of all dominators of a vertex can be
exponential with respect to . Since the algorithm represents each
dominator explicitly as a set of vertices, it has exponential space
and time complexity.

The third algorithm in~\cite{gupta} finds all multiple-vertex dominators of
size up to  for all vertices in the circuit. Due to its specific
nature, this algorithm cannot not be modified to search for all
multiple-vertex dominators of a fixed size for a given vertex.
The complexity of the algorithm is not evaluated in the
paper. Depending on the implementation, the complexity can vary from
exponential to polynomial with a high degree of the polynomial.
For example, for double-vertex dominators, the complexity of the
algorithm is at least .

Successive improvements of the algorithms in~\cite{gupta} were done in~\cite{KrD05a,KrD05b,Du04} and~\cite{DuTM04}.
The algorithm presented in~\cite{DuTM04} finds the set of all
possible -vertex dominators of a circuit by
iteratively restricting the graph with respect to one of its vertices, . The restriction is done by removing from 
the graph all vertices dominated by . Dominators of size  are then computed for the resulting
restricted graph by applying the same
technique recursively.  Once  is reduced to 1, a single-vertex
dominator algorithm is used.  Since single-vertex dominators can be
computed in linear time, the overall complexity of the
algorithm~\cite{DuTM04} is bounded by . 

The first algorithm designed specifically for
double-vertex dominator was presented in~\cite{TeD05b}. This algorithm
uses the max-flow algorithm to find an immediate double-vertex dominator 
for a given set of vertices . The immediate dominator is
considered as a sink and all vertices in  are merged into a single
source vertex.  The obtained min-cut corresponds to the minimal-size 
dominator which dominates all paths from the source to the sink.  
If the size of the min-cut is larger than two, then  does not
have any double-vertex dominators. The complexity of this algorithm 
is .

Interesting results on testing two-connectivity of directed graphs in linear time were presented in~\cite{AbGKM10}, with a focus on finding disjoint paths. Since dominators are contained in disjoint
paths, the results of~\cite{AbGKM10} can potentially facilitate their search. However, with such an approach, the complexity of checking if a pair of vertices is a double-vertex dominator remains
linear. As we show later, in our case it is reduced to a constant.

The {\em cactus tree} data structure for representing all undirected min-cuts was introduced
in~\cite{DiKL76}. The problem of finding a min-cut of a high degree is reduced to finding a two-element
cut in the cactus tree. Such a structure allows for extracting min-cuts of a high degree, which
are a special case of -vertex dominators. In our case, the original degree is two. Therefore,
the cactus tree data structure cannot help reduce is further.

\section{Properties of Multiple-Vertex Dominators} \label{ddom_mdp}

In this section, we derive some general properties of -vertex
dominators. 
The following three Lemmata show antisymmetry, transitivity, and reflexivity
of the dominator relation.

\begin{lemma} \label{ddom_mp01}
Let  and  be two different dominators of a vertex . If 
dominates , then  does not dominate .
\end{lemma}
{\bf Proof:} Set  is not equal to  by the condition of the Lemma. 
is not a proper subset of  either, because otherwise  would
violate the Definition~\ref{ddom_dom2}b. Thus, there is a
vertex  such that .  Since  is a dominator of , by
Definition~\ref{ddom_dom2}b, there exists , such that , and , .  The path  which is suffix of  should contain a vertex  since  dominates . The path  which is
a suffix of  does not contain any vertex of  by
construction. Thus, by Definition~\ref{ddom_dom},  does not dominate
. 
\begin{flushright}
 \\
\end{flushright}

\begin{lemma} \label{ddom_mp02}
If  dominates  and  dominates , then  dominates .
\end{lemma}
{\bf Proof:} Consider an arbitrary path  such that . We proof the Lemma by showing that a vertex from  is in
.  Since  dominates , it holds that  such
that .  The path  is a suffix of .
Since  dominates , it holds that  such that .  Thus  as well. 
\begin{flushright}
 \\
\end{flushright}

\begin{lemma} \label{ddom_mp03}
 dominates .
\end{lemma}
{\bf Proof:}
Follows trivially from the Definition~\ref{ddom_dom}a. 
\begin{flushright}
 \\
\end{flushright}

It follows from the above three Lemmata that any set of dominators of
a vertex  is partially ordered by the dominator relation.



\section{Properties of Double-Vertex Dominators} \label{sec_dd}
\label{ddom_ddp}

In this section, we derive a number of fundamental properties of
double-vertex dominators. 





Let  be the set of all possible double-vertex dominators of a vertex . 
Each element of  is a pair of vertices , , constituting a double-vertex dominator of . 
With some abuse of notation, throughout the paper we write  as a shorthand for
 such that .

The following Lemma shows that if two dominators have a common vertex, 
then one of the dominators dominates the non-common vertex in another dominator.

\begin{lemma} \label{ddom_p01}
If  and ,
then either  dominates , or  dominates .
\end{lemma}
{\bf Proof:} If  dominates , then the Lemma
holds trivially. Suppose that  does not dominate . Since
, by Definition~\ref{ddom_dom2}b, there exists , such that  and . Since
, for all    it holds that . Furthermore,  precedes  in , because, by
assumption,  does not dominate . Thus the prefix  of the path  does not contain  and .

Then, there exists no path  such that , because otherwise the path  would contain neither
 nor . This would contradict . So
for all , it holds that either  or . Thus, by Definition~\ref{ddom_dom},  dominates .

Similarly we can show that if  does not dominate , then
 dominates .
\begin{flushright}

\end{flushright}


The following Lemma considers the case of two double-vertex dominators
which have no vertices in common and which do not dominate each other.

\begin{lemma} \label{ddom_p03}
If , ,
 does not dominate , and  does not
dominate , then  and .

\end{lemma}
{\bf Proof:} Vertices  and  belong to . Thus,
 none of them is a single-vertex dominator of
. Therefore, any deduction showing that any pair of these vertices
dominates  would imply that this pair is a double-vertex
dominator of .

First, we show that . 
Consider the following two cases:
\begin{itemize}
\item[(1)] There exists  such that ,
\item[(2)] There exists no  such that .
\end{itemize}

\noindent {\bf Case 1:} One of the vertices ,  precedes another one in .

\noindent (a)  Assume that  precedes . This implies that
for all , . According to
the conditions of the Lemma,  does not dominate .
This means that there exists  such that
. Then, there exists no  such that , or otherwise a path  would contain neither  nor
, and that would contradict . 
So, for all , . Thus, every path 
containing  contains  as well. Thus,  can be substituted
by  in any dominator of . So  implies
that .

\noindent (b)  If  precedes , then the prove is similar to
(a) case. We can show that all paths  containing
 contain  as well. Thus,  implies
that .

\noindent {\bf Case 2:}
The assumption of the case 2 directly implies that for all
, . The rest of the proof is
similar to the case 1(a).

Next, we show that . Consider
two following two cases:
\begin{itemize}
\item[(1)] There exists  such that ,
\item[(2)] There exists no  such that .
\end{itemize}

\noindent {\bf Case 1:} (a) Assume that  precedes . It
implies that, for all , .  But  implies that for all
, , i.e.   is a single-vertex dominator of
.  Thus,  implies that .

\noindent (b) If  precedes , the prove is similar to (a).
Then,  is a single-vertex dominator of .  Thus,  implies that .

\noindent {\bf Case 2:}
The assumption of the case 2 directly implies that for all , . Thus  is a single-vertex
dominator of . Consequently  implies that
.
\begin{flushright}

\end{flushright}

The following Lemma shows another property of two double-vertex dominators
which have no vertices in common and which do not dominate each other.

\begin{lemma} \label{ddom_p04}
If , ,
 does not dominate , and  does not
dominate , then  dominates  and 
dominates .

\end{lemma}
{\bf Proof:} According to the Lemma~\ref{ddom_p03}, 
and .

First, we prove that  does not dominate  by contradiction.
Assume that  dominates .

Since , by Definition~\ref{ddom_dom2}b, there exists
 such that . Since
 dominates , this implies that . Thus,
 precedes  in any path containing , .

Since  does not dominate , by Definition~\ref{ddom_dom},
there exists  such that  and
.

Since , by Definition~\ref{ddom_dom2}b, there exists
 such that . Since 
precedes , it implies that  either.

The existence of the path  which does not contain neither 
nor  contradicts the fact that . Thus,
the assumption that  dominates  is invalid.

Since  and , according
to the Lemma~\ref{ddom_p01} either  dominates , or
 dominates . But, as we showed before, 
does not dominate , thus  dominates .

The case of  dominating  can be proved similarly.
\begin{flushright}
 \\
\end{flushright}

The following three Lemma consider mutual relations between of several dominators of the same vertex.

\begin{lemma} \label{ddom_p015}
If  and
 dominates , then  dominates .
\end{lemma}
{\bf Proof:} According to the Lemma~\ref{ddom_p01}, either 
dominates , or  dominates . This implies that one of the
two following cases are possible:
\begin{itemize}
\item[(1)]  dominates ,
\item[(2)]  dominates .
\end{itemize}

\noindent {\bf Case 1:}
If  dominates , then from the condition of the Lemma by transitivity of
dominator relation it follows that  dominates .

\noindent {\bf Case 2:}
If  dominates , then by the antisymmetry of
dominator relation it follows that  does not dominate
. The vertex  is dominated by , thus
 is not dominated by .

Since  dominates , it implies that  dominates
, thus  does not dominate . The
vertex  is dominated by , thus  is not
dominated by .

Since  is not dominated by  and  is not
dominated by , according to the Lemma~\ref{ddom_p04} 
dominates .
\begin{flushright}

\end{flushright}




\begin{lemma} \label{ddom_p05}
For all  and for all , there exist  such that 
dominates  and  dominates .
\end{lemma}
{\bf Proof:}
Three cases are possible:
\begin{itemize}
\item[(1)]  and  have two common
vertices, i.e they are the same set.
\item[(2)]  and  have one common
vertex,
\item[(3)]  and  do not have common
vertices.
\end{itemize}

We prove the Lemma by identifying the dominator set 
for all three cases.

\noindent {\bf Case 1:}
The Lemma trivially holds by choosing  to be .

\noindent {\bf Case 2:}
Suppose that  is the common vertex, i.e. the second immediate
dominator is . According to the Lemma~\ref{ddom_p01}, 
dominates  or  dominates . Without any loss of
generality, assume that  dominates . It immediately
follows that  dominates . Thus the Theorem
holds by choosing  to be .

\noindent {\bf Case 3:}
If one dominator dominates the other one, then the Theorem holds by
choosing the dominated dominator to be .

Assume that none of the dominators dominates each other. It means at
least one vertex in both dominators is not dominated by the other
dominator.  Note that with current assumption it is impossible that
two vertices in any of the dominators are not dominated by the other
dominator, since it would contradict Lemma~\ref{ddom_p04}. Thus exactly
one vertex from both dominators is not dominated by the other dominator
and no other cases are possible.

Without any loss of generality, assume that  does not dominate
 and  does not dominate . According to
the Lemma~\ref{ddom_p03}, . According to the Lemma~\ref{ddom_p04},
 dominates , thus  dominates
. Also  dominates , thus 
dominates . The Lemma holds by choosing  to be
.
\begin{flushright}
 \\
\end{flushright}

\begin{lemma} \label{ddom_p06}
For any non-empty subset  of , there exist  such that  dominated by all dominators in .
\end{lemma}

\noindent {\bf Proof:}
We prove the Lemma by induction on the size of the set .

\noindent {\bf Basis:}
If , then the dominator which is dominated by all dominators in
 is the dominator which constitutes , i.e. .

\noindent {\bf Inductive step:}
Assume the Lemma holds for . Next we show that the Lemma holds
for , where .

Let  be a proper subset of  such that . Since  is
a subset of ,  is a subset of  as well. According to
the assumption, there exists  such that 
is dominated by all vertices in .  Let  be the remaining
dominator of  which does not belong to , i.e. .  According to the Lemma~\ref{ddom_p05}, there exists 
such that  dominates  and 
dominates .  All dominators in  dominate 
and  dominate , thus, using transitivity of
dominator relation, all dominators in  dominate
. Since  dominates  as well, we
can conclude that all dominators in  dominate . Thus,
.
\begin{flushright}
 \\
\end{flushright}

Finally, we prove that immediate double-vertex dominators are unique.
As we have shown in Section~\ref{ddom_prelim}, this property does not extend
to the dominators of a larger size.

\begin{theorem} \label{ddom_p08}
For any , if  is non-empty, then there exist a unique immediate double-vertex
dominator of .
\end{theorem}

\noindent {\bf Proof:} It immediately follows from the Lemma~\ref{ddom_p06} that there exists
 such that  is dominated by all
dominators in . Due to the antisymmetry of dominator
relation,  does not dominate any other dominator in
. By Definition~\ref{ddom_idom},  is an immediate
double-vertex dominator of .

To prove the uniqueness of the immediate double-vertex dominator, assume there is another immediate
double-vertex dominator . Since any dominator
in  dominates , it means that  dominates
. This contradicts the Definition~\ref{ddom_idom}.
\begin{flushright}
 \\
\end{flushright}



\section{A Data Structure for Representing Dominators}
\label{ddom_ds}

In this section, we describe a data structure for representing all double-vertex dominators of a given 
vertex in linear space\footnote{A preliminary short version of the paper presenting this data structure appeared in the Proceedings of the Design and Test in Europe Conference (DATE’2005)~\cite{TeD05b}.}.

Given one vertex in a double-vertex dominator ,  say , we call
the other vertex  a {\em matching} vertex of  with respect to .
A vertex may have more than one matching vertices with respect to . 
We represent the set of all matching vertices of a vertex by the
following vector.

\begin{figure}[t!]
\begin{center}
\includegraphics*[width=4in]{figure2-crop.pdf}
\caption{An example circuit.} \label{ddom_f3}
\end{center}
\end{figure}


\begin{defn} \label{ddom_mv}
For any , the {\em matching vector} of  with respect to , denoted by , consists of
all vertices  such that  is a double-vertex dominator of .
The order of vertices in  is defined as follows: 
If  dominates , then  precedes  in .
\end{defn}

\begin{lemma} \label{ddom_tmv1}
For every , there exist  a unique matching vector .
\end{lemma}
\noindent {\bf Proof:} The set of vertices which constitute  for a given  is uniquely
determined by the Definition~\ref{ddom_mv}. It remains to prove that the
order of elements in  is unique. 

By Definition~\ref{ddom_mv}, the vertices of  are 
ordered according to the dominator relation. 
Given any pair of double-vertex dominators of , say  and  , 
by Lemma~\ref{ddom_p01}, either  dominates ,
or  dominates . This implies that either 
dominates , or  dominates . Thus, 
the order imposed by the dominator relation on the elements 
of  is total.
\begin{flushright}
 \\
\end{flushright}

As an example, consider the circuit in Figure~\ref{ddom_f3}.
The set of all double-vertex dominators of 
 is: , , , , ,
, , , , , ,
. 
Therefore, we have the following matching vectors with respect to :


Let  be the set of all matching vectors of all vertices in .
The set  can be partitioned into a set of connected components
which we call {\em clusters}.

\begin{defn} \label{ddom_deps}
A set of matching vectors  is a {\em cluster} if:
\begin{enumerate}
\item[(1)]
 and , 
\item[(2)]
 cannot be partitioned into two clusters satisfying (1).
\end{enumerate}
\end{defn}

In the example above,  can be partitioned into 4 clusters:
, ,
, and .

Finally, we introduce a structure  
which will allow us to represent all clusters of  in linear space.

\begin{defn} \label{ddom_comp}
A vector   is the {\em composition vector} for a set of matching vectors , if: 
\begin{enumerate}
\item It contains each matching vector of  as a subvector,
\item It contains only matching vectors from ,
\item It contains no duplicated vertices.  
\end{enumerate}
\end{defn}

\begin{theorem} \label{ddom_tmv2}
For any two vertices , it holds that either
\begin{enumerate}
\item  {\em suffix} {\em prefix}, or
\item  {\em suffix} {\em prefix}.
\end{enumerate}
\end{theorem}
\noindent {\bf Proof:}  See Appendix A.

An obvious implication of the Theorem~\ref{ddom_tmv2} is that, for any two matching vectors, there exists a composition vector. Furthermore if the two matching vectors
have vertices in common, then the composition vector is unique (see Figure~\ref{comp_vector} for an illustration). It can also be shown that, 
for any set of matching vectors,  there exists a composition vector.

In the example above, ,   , and .
Note that the set of matching vectors of vertices of the first composition vector 
is equivalent to the second cluster, and vice verse. Similarly, the set of matching vectors of vertices of the third composition vector is equivalent to the fourth cluster, and vice verse. We call such clusters  {\em  complimentary}.

\begin{defn} \label{cluster_comp}
The cluster is {\em complimentary} to a cluster ,
denoted by ,
if the set of all matching vectors  of all  constitute a cluster equivalent to .
\end{defn}

It is easy to show that if  is complimentary to , then  is complimentary to  as well. Each double-vertex dominator in  has one of its vertices in some cluster  and another vertex in . The following Lemma follows directly.

\begin{lemma}
The set  can be partitioned into pairs of complimentary clusters.
\end{lemma}

\begin{figure}[t!]
\begin{center}
\includegraphics*[width=2.8in]{figure3-crop.pdf}
\caption{The relation between two overlapping matching vectors and their composition vector.} \label{comp_vector}
\end{center}
\end{figure}


This brings us to the data structure for representing .

\begin{defn} \label{ddom_d1}
The set  of all double-vertex dominators of any 
can be represented by the {\em dominator chain}  
which is a vector of pairs of composition vectors of complimentary clusters of :

where  is the th cluster of , for .
The order of clusters in  is defined as follows: 
If  is the first vertex of  and  is the first vertex of ,
then  dominates every vertex in  and  for all .
Each vertex  which is contained in  is associated
with a pair  representing of the first
and the last vertex of .
\end{defn}

For the circuit in Figure~\ref{ddom_f3}, the dominator chain for  is

 is associated with ,  is associated with , etc.

\section{Operations of Dominator Chains}

One of the tasks for which dominator chains are used in this paper is to
identify whether a given pair of vertices  is a
double-vertex dominator of some vertex  or not. 
Assume that we have the dominator chain  and 
that pairs  consisting of the first
and the last vertex of  are associated with each .
For each vertex ,  we set . 
Then, to determine whether  is a
double-vertex dominator of ,  we first check whether  and  are empty.
If they are,  is not a dominator of . Otherwise,
we take  and search for this vertex in . The position of  in 
 gives us the starting point of . We need to traverse  until its last vertex, ,
to determine whether .  If , then  is a dominator of . Otherwise,  is not a dominator of . 
Such a procedure has a linear time complexity with respect to the size of . 
However, ii can be further improved by indexing vertices of  as follows.



We partition  into two vectors  ("left") and  ("right").
For each pair of composition vectors  in ,
we put all vertices of one composition vector in   and all vertices of another composition vector  in .
It does not matter whether we put all  in  and all  in 
, or vice verse. However, once we make a choice for the first pair of  composition vectors in  ,
this choice should be followed for all  pairs in . It is also possible to make  and 
unique by imposing the topological order on vertices of the circuit graph. In this case,
we put  in   
if the first vertex of  precedes the first vertex of .
Otherwise, we put  in .  

For the circuit in Figure~\ref{ddom_f3}, the dominator chain can be partitioned as follows:


To make possible a constant time look-up for dominators, three
parameters are assigned to vertices:
\begin{itemize}
\item
For all  we assign  {\em left,right} , which distinguishes
whether  belongs to  or .  
\item
For all ,  we assign  which
indicates the position of  in .  
\item
Instead of associating with
each  a pair of vertices , we associating with
each   a pair of indexes , where
, . 
\end{itemize}

In the example above,  {\em left},  {\em right}, 
, , 
, , etc.

Now we can check whether  dominates  as
follows:
\begin{enumerate}
\item
Check if .
If yes, go to step 2. Otherwise, .
\item Check if . If yes,
. Otherwise, .
\end{enumerate}



\section{An Algorithm for Finding Dominators} \label{ddom_alg}

The algorithm presented in this section
takes as its input a circuit graph  and a
vertex .  It returns the dominator chain .
The pseudo-code of the algorithm is shown in Figure~\ref{ddom_code_d}.

In order to construct , the following steps are followed:
\begin{enumerate}
\item Find all single-vertex dominators of .
\item Set  and .
\item Construct the dominator chain   for  assuming that  is the sink
and append it to the end of .
\item Set  and repeat Step 3 until .
\end{enumerate}

To simplify the description of the algorithm, we assume that there are
no single-vertex dominators of  with respect to , i.e.
we focus on the Steps 3 and 4. 





\begin{figure}[t!] 
\begin{center}
\parbox{0cm} 
{
\begin{tabbing}  
m \== m \== m \== m \== m \== m \== m \== \kill
\ALGORITHM  \\
\INPUT  is a set of vertices, .\\
\> Construct a path  from  to ;\\
\> Construct a path  from  to  such that ; \\
\> Construct a path  from  to  such that ; \\
\> \IF  is constructed \THEN \\
\> \> \RETURN ; \\ \> \FOREACH  \DO \\
\> \> Set {\em marked(v)} = 0;\\
\> \END \\
\> ;\\
\> \FOREACH   \DO \\
\> \> Set {\em marked(v)} = 0;\\
\> \END \\
\> ;\\
\> ;\\
\> ;\\
\> ;\\
\> ;\\
\> \RETURN ;\\
\END
\end{tabbing}
}
\caption{Pseudo-code of the presented algorithm for finding double-vertex dominators of a vertex .}\label{ddom_code_d}
\end{center}
\end{figure}


The presented algorithm exploits the following property of disjoint paths.
Recall that we call two paths disjoint if the intersection of
sets of their non-terminal vertices is empty.

\begin{lemma} \label{ddom_al01}
If there are two disjoint paths from  to
,  and , then, for any double-vertex dominator  of , it
holds that  and .
\end{lemma}
{\bf Proof:} By Definition~\ref{ddom_dom2}, 
at least one vertex of the double-vertex dominator 
should be present in any path from  to .
Since  and  are disjoint,
none of their vertices belong to both paths
except  and . Vertices  and  are single vertex
dominators of , thus they do not belong to . Therefore, one
vertex of the pair  should belong to  and another one to .
\begin{flushright}
 \\
\end{flushright}

It directly follows from the Lemma~\ref{ddom_al01} that 
if there exists a third path from  to
 which is disjoint with both  and , then  has 
no double-vertex dominators. We use this property to
bound the search space for double-vertex dominators.

\begin{figure}[t!]
\begin{center}
\parbox{0cm} 
{
\begin{tabbing}
m \== m \== m \== m \== m \== m \== m \== \kill
\ALGORITHM  \\
\INPUT ,\\
~~~~~~~~.\\
\> ; \\
\> ; \\
\> ; \\
\> ; \\
\> ; \\
\> \FOREACH  from 1 to  \DO \\
\> \> \IF  \THEN \\
\> \> \> /*By setting  we remove  from*/ \\
\> \> \> /*the list of potential candidates into dominators*/ \\
\> \> \> ; \\
\> \> \> ;\\
\> \> \ELSE \\
\> \> \> ; \\
\> \> \> ;\\
\> \> \> ;\\
\> \> ; \\
\> \> \IF  \THEN \\
\> \> ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   \\
\> \> \IF  \THEN \BREAK  \\
\> \> \FOREACH  from  to  \DO \\
\> \> \> ; \\
\> \> \END \\
\> \> ; \\
\> \END \\
\> ;\\
\END
\end{tabbing}
}
\caption{Pseudo-code of the procedure .}\label{ddom_code2}
\end{center}
\end{figure}

We search for three disjoint paths from  to
 using a modified version of the max-flow algorithm which 
operates on vertex rather than edge capacities~\cite{TeD04c}. 
The max-flow algorithm attempts to construct three augmenting
paths with  as the source and  as the sink. 
Each vertex is assigned a unit capacity. 
The net flow through each vertex should be either one or zero.
Therefore, the resulting augmenting paths are mutually disjoint by
construction. 

If the algorithm succeeds to find three disjoint  paths,
then by Lemma~\ref{ddom_al01}, .
If only two disjoint  paths are found, then we conclude that vertices on
these paths are potential candidates for . The
Lemma below helps us to distinguish which of them 
can belong to  and which are not.



\begin{lemma} \label{ddom_al03}
Let  and  be two disjoint paths from  to . 
If there exists a path  which starts at some vertex ,
ends at some vertex , ,
and has not other common vertices with
neither  nor , then 
 for all  such that .
\end{lemma}
{\bf Proof:} 
The path  can be seen as concatenation of three paths
 where  is a prefix of  having 
as its last vertex,  is a suffix of  having 
as its first vertex, and  is the middle part of  containing
all vertices from  to .
Denote by  a path .

Consider some vertex . 
Since  and  cannot appear twice in 
,  and . Since
 and  have no common vertices except  and ,
we can conclude that . This implies that , and
also that , because  and 
 are disjoint. 
Since paths  and  are two disjoint paths from  to
 and  does not belong to any of them, by Lemma~\ref{ddom_al01},
.
\begin{flushright}
 \\
\end{flushright}





We call a vertex  {\em prime} if any path from 
an ancestor of  to a descendant of  contains .
By the Lemma~\ref{ddom_al03}, 
any pair of prime vertices  such that  and , 
and  and  are disjoint, can potentially be a double-vertex dominator of . 
The next Lemma put additional restrictions of pairs of vertices that can belong to
.

\begin{lemma} \label{ddom_al04}
Let  and  
be two disjoint paths from  to . 
If there exists a path  which starts at some vertex ,
ends at some vertex , and has not other common vertices with
 and , then all pairs of vertices  such that  
and  are not in .
\end{lemma}
{\bf Proof:} The path  can be seen as a concatenation of two paths
 where  and .  
Similarly, the path  can be seen as a concatenation of two
paths  where  and .
Denote by  a path .

Since  and  have no common vertices except , 
we can conclude that, for any , . Similarly, 
for any ,  
because  and  have no common vertices
except .

Since, for any ,  and  cannot appear twice in  
, . Also, for any ,  because
 is disjoint with .

Similarly,  since for any ,   
and  cannot appear twice in  
, . Also, for any ,  because
 is disjoint with .

It follows from above that, for any  
and , . Since 
is a path from  to , by the Definition~\ref{ddom_dom2}
that .
\begin{flushright}
 \\
\end{flushright}


\begin{figure}[t!]
\begin{center}
\parbox{0cm} 
{
\begin{tabbing}
m \== m \== m \== m \== m \== m \== m \== \kill
\ALGORITHM  \\
\INPUT , ,\\
~~~~~~~~.\\

\> Let ;\\
\> Let ;\\
\> \FOREACH  {\em TransFanout} \DO  \\
\> \> \IF  \THEN \BREAK \\
\> \> ;\\
\> \> \IF  \THEN \RETURN ; \\
\> \> \IF  \THEN \\
\> \> \> \IF  \THEN ; \\
\> \> \> \BREAK \\
\> \> \IF  \THEN \\
\> \> \> \IF  \THEN ; \\
\> \> \> \BREAK \\
\> \END \\
\END
\end{tabbing}
}
\caption{Pseudo-code of the  procedure .}\label{ddom_code3}
\end{center}
\end{figure}

We use fields  and  of vertices of  and 
to keep track of potential double-vertex dominators during the execution of the algorithm\footnote{Note that, because we
re-use the fields  and , their intermediate values during the execution of the algorithm might not be
in accordance with the definition in Section~\ref{ddom_ds}. The final values of  and  fields are set by the procedure  before the termination of  the algorithm.}. 
If the field  of some   is assigned to , that means that we have identified that  for all  such that .
Similarly, if the field  of  is assigned to , then we have identified that 
 for all  such that .

The rules for assigning  and  fields follow from the Lemma~\ref{ddom_al04}. 
If there exist a  path , , , disjoint with  and ,
then  for all  such that 
and  for all  such that .
Note that we write an inequality sign because there might be another path
 disjoint with  and  such that  and .
In this case,  and . 
All paths disjoint with  and  should be considered to determine which indexes should be assigned to 
 and  fields. The following property summarizes the rules for assigning  and  fields.

\begin{prop} \label{ddom_minmax}
Let  and  be two disjoint paths from  to . 
Let , , , be a path
disjoint with  and . Then:
\begin{itemize}
\item[(a)]
,  such that , 
where  is the minimal index of a vertex of  for which 
the path  exists.
\item[(b)]
,  such that , 
where  be the maximal index of a vertex of  for which 
the path  exists.
\end{itemize}
\end{prop}

\begin{figure}[t!]
\begin{center}
\parbox{0cm} 
{
\begin{tabbing}
m \== m \== m \== m \== m \== m \== m \== \kill
\ALGORITHM  \\
\INPUT ,\\
~~~~~~~~.\\
\> ;\\
\> ;\\
\> \FOREACH  from 2  to  \DO \\
\> \> ;\\
\> \> ;\\
\> \> \IF  \THEN \BREAK \\
\> \> \IF  \THEN \\
\> \> \> /*min field is set to the index of the closest*/ \\
\> \> \> /*prime descendant of  in  */ \\
\> \> \>  ;\\
\> \> \IF  \THEN \\
\> \> \> /*max field is set to the index of the closest*/ \\
\> \> \> /*prime ancestor of  in */ \\
\> \> \>  ;\\
\> \> \IF  \THEN \\
\> \> \> Append  to the end of vector ;\\
\> \> \> ;\\
\> \> \> ;\\
\> \END \\
\> \RETURN ;\\
\END
\end{tabbing}
}
\caption{Pseudo-code of the procedure .}\label{ddom_code3a}
\end{center}
\end{figure}

\begin{figure}[t!]
\begin{center}
\parbox{0cm} 
{
\begin{tabbing}
m \== m \== m \== m \== m \== m \== m \== \kill
\ALGORITHM  \\
\INPUT , .\\
\> \FOR all  \DO \\
\> \> ;\\
\> \> ;\\
\> \END \\
\END
\end{tabbing}
}
\caption{Pseudo-code of the procedure .}\label{ddom_code4}
\end{center}
\end{figure}

The procedure , shown in Figure~\ref{ddom_code2},  
allocates  field
for all vertices  and  field for all vertices . This procedure also checks whether vertices of  are
prime or not.  If  is not a prime, then its field  is set
to the index of the closest prime ancestor of  in .
If  is a prime, then its field  is set
to the index of the closest prime descendant of  in .

The main loop of the procedure 
iterates through all vertices  of  from the source to
the sink of . For every , in the beginning of the main loop, the
variable  contains the maximum index of a vertex of
 that can be reached from an ancestor of  in  by
a path disjoint with  and . Similarly, the variable  contains the
maximum index of a vertex of  that can be reached from
an ancestor of  in  by a path disjoint with  and .

In the main loop, first we check whether  is prime or not. 
If , it means that there exists a
path  from an ancestor of  in  to a 
descendant of  in  which is disjoint with  and . Thus by Lemma~\ref{ddom_al03}  is not
prime. If  then no such path
exists and  can be declared prime. According to the
Property~\ref{ddom_minmax}b  is set to .

The procedure
, described later in this section, is used to update a pair
of global variables  and . The
values  represents the maximum index of a vertex of
 that can be reached from  or any ancestor of  in  
by a path disjoint with  and . Since  is an ancestor of
,  represents the value of
 for the next iteration of main loop. Similarly, the value
 represents the maximum index of a vertex of 
that can be reached from  or any of its ancestors in  by a
path with is disjoint with  and . Thus,  represents the value of
 for the next iteration of the main loop.

If , this means that, for every vertex  in
the range ,
 is the minimum index of a vertex in  for which there exists a to a descendant of  in  which is disjoint with  and . According to the Property~\ref{ddom_minmax}a  is set to .

The procedure  sets
 for all vertices  which are reachable by
path which is disjoint with  and  from a given vertex  and updates global variables
 and . The marking 
is performed by a depth-first search. Any
path disjoint with  and  which contains  can be
extended to any of the vertices in the fanout of . Such an extended path 
is disjoint with  and  as well.  So, all vertices in the fanout of  are reachable by  paths disjoint with  and ,
and therefore they are marked.  is called for
all newly marked vertices which do not belong to neither  or .

The maximum index of each marked vertex in a path  () is stored in
the global variable  (). This variable
 represents the maximum index of a vertex of  () that can be reached by 
a disjoint with  and  path from one of the vertices  for which  was
initially called.

The following theorem states that once all  fields  and  are set by
  and
, all remaining potential candidates to
double-vertex dominators are indeed double-vertex dominators.

\begin{theorem} \label{ddom_al02}
Let  and  be two disjoint paths from  to . 
If vertices  and  are prime, ,
and , then  is a double-vertex
dominator of .
\end{theorem}
\noindent {\bf Proof:}  See Appendix B.


\begin{figure}[t!]
\begin{center}
\parbox{0cm} 
{
\begin{tabbing}
m \== m \== m \== m \== m \== m \== m \== \kill
\ALGORITHM  \\
\INPUT , . \\
\> ; ;\\
\> ; ;\\
\> ;\\
\> ;\\
\> \WHILE  \DO \\
\> \> \WHILE 1 \DO\\
\> \> \> ;\\
\> \> \> \IF  \THEN \BREAK \\
\> \> \> ;\\
\> \> \> ;\\
\> \> \> \IF  \THEN \BREAK \\
\> \> \> ;\\
\> \> \END \\
\> \> Set ; /**/\\
\> \> Set ; /**/\\
\> \> Append  to ;\\
\> \> ;\\
\> \> ;\\
\> \> ;\\
\> \END \\
\end{tabbing}
}
\caption{Pseudo-code of the procedure .}\label{ddom_code3b}
\end{center}
\end{figure}


The procedure  returns the vector
, which is either  or . 
The vector  consists
of a subset of vertices of . According to the Theorem~\ref{ddom_al02},
a vertex  belongs to 
 if there exists at least one prime vertex
in  which is in the range between  and
. First, we check whether  and 
contain indexes of prime vertices. If not, then they are updated as follows. The
field  is set to the minimum index of 
prime vertices  in  satisfying .
Similarly, the  is
set to the maximum index of 
prime vertices  in  satisfying .
Finally, if
, then we can conclude that   and
 are double-vertex
dominators of  and  append  at the end of . 
At this point,  the position of 
in  is known. Therefore, we set the index of  to .
However, indexes of vertices  
and  in the complimentary to  
vector of the dominator chain are not known yet. These indexes are assigned later by the
procedure .

Finally, the dominator chain  is constructed by the procedure
 . This procedure is optional, 
since for some applications it
is sufficient to find  and  along with ,
 for all .

The procedures ,
  and
 have linear complexity with
respect to , , and  respectively. The procedure
 is called at most once for every
vertex during the call of
. Each call of
  iterates through all vertices in the fanout of , thus   has
linear time complexity with respect to the number of edges  in
the input graph.

Since all procedures of  
have linear complexity
with respect to , the presented algorithm
has the complexity . Its execution time is dominated by
the execution time of the procedures  and
. Therefore, the actual execution time of the presented algorithm is
proportional to , where  is the set
of edges in the transitive fanout of .

\begin{table*}[t!]\centering
\begin{tabular}{|@{}c@{}|c|c|c||c|c|c||c|c|c|} \hline
            & 	      &     	                &  2-input       & All       & All      & Useful &\multicolumn{3}{c|}{Runtime, sec} \\ \cline{8-10}
Name  &  Inputs     & Outputs 	& AND gates  & 1-doms 	& 2-doms   & 2-doms  &\cite{DuTM04} & \cite{TeD05b} & presented  \\ \hline \hline

clma	&	94	&	115	&	24277	&	948	&	9819	&	2867	&	88.52	&	 0.41	 &	 0.34	\\
clmb	&	415	&	402	&	23906	&	361	&	8638	&	2356	&	98.09	&	 0.53	 &	 0.45	\\
mult32	&	64	&	96	&	10594	&	1150	&	27507	&	16442	&	885.62	 &	 2.98	 &	 1.45	\\
apex2	&	38	&	3	&	8755	&	853	&	1551	&	890	&	162.16	&	 0.23	 &	 0.16	 \\
too\_large	&	38	&	3	&	8746	&	971	&	2238	&	1467	&	136.02	 &	 0.22	 &	 0.14	\\
misex3	&	14	&	14	&	8155	&	59	&	2657	&	1224	&	29.83	&	 0.17	 &	 0.12	\\
seq	&	41	&	35	&	7462	&	1796	&	27631	&	13879	&	9.62	&	 0.25	 &	 0.16	\\
~cordic\_latches~	&	318	&	294	&	6212	&	7313	&	31714	&	12214	&	 4.27	 &	 0.36	&	0.28	 \\
bigkey	&	452	&	421	&	5661	&	2016	&	8822	&	2421	&	4.16	 &	 0.33	 &	 0.23	\\
s15850s	&	553	&	627	&	5389	&	27210	&	170189	&	31245	&	25.23	 &	 0.81	 &	 0.41	\\
alu4	&	14	&	8	&	5285	&	134	&	706	&	449	&	28.06	&	0.08	 &	 0.08	 \\
des	&	256	&	245	&	4733	&	3361	&	9231	&	2349	&	2.56	&	 0.25	 &	 0.17	\\
s15850	&	611	&	684	&	4172	&	34564	&	74941	&	16975	&	18.52	 &	 0.77	 &	 0.45	\\
apex5	&	114	&	88	&	3781	&	800	&	21728	&	8107	&	0.95	&	 0.17	 &	 0.12	\\
key	&	452	&	421	&	3537	&	1348	&	7717	&	2740	&	2.17	&	 0.28	 &	 0.19	\\
i8	&	133	&	81	&	3444	&	2068	&	8121	&	3296	&	0.83	&	 0.12	 &	 0.09	\\
ex1010	&	10	&	10	&	3278	&	0	&	545	&	92	&	11.33	&	0.14	 &	 0.14	 \\
dsip	&	452	&	421	&	2975	&	2245	&	6586	&	2059	&	1.75	 &	 0.23	 &	 0.2	\\
i10	&	257	&	224	&	2935	&	6446	&	81707	&	30608	&	4.95	&	 0.47	 &	 0.2	 \\
apex4	&	9	&	19	&	2905	&	0	&	841	&	165	&	8.7	&	0.12	&	 0.09	 \\
s13207s	&	483	&	574	&	2590	&	3179	&	13365	&	6673	&	2.28	 &	 0.22	 &	 0.16	\\
apex3	&	54	&	50	&	2419	&	1723	&	34386	&	29957	&	6.66	 &	 0.2	 &	 0.11	\\
C6288	&	32	&	32	&	2370	&	480	&	5743	&	3366	&	1.67	&	 0.27	 &	 0.2	 \\
C7552	&	207	&	108	&	2282	&	4604	&	87027	&	14728	&	19.12	 &	 0.31	 &	 0.11	\\
k2	&	45	&	45	&	2236	&	1827	&	16400	&	11693	&	5.42	&	 0.17	 &	 0.08	\\ \hline
{\bf total for 214}	&		&		&		& 177577	& 3777809	&	935309	&	1637.47	 &	 30.77  &  17.27 \\ \hline
\end{tabular}
\vspace*{1mm}
\caption{Benchmark results for IWLS'02 benchmark set.} \label{ddom_t1}
\end{table*}


\section{Experimental Results} \label{ddom_exp}

In this section, we compare the performance of the presented algorithm
to the algorithm for finding double-vertex dominators from~\cite{TeD05b}
and to the algorithm finding multiple-vertex dominators
from~\cite{DuTM04}.  
The algorithm~\cite{DuTM04} can compute
all -vertex dominators of a given vertex for any . In our experiment, 
we set  to 2.

We have applied the three algorithms to 214 combinational benchmarks 
from the IWLS'02 benchmark set.
Table~\ref{ddom_t1} shows the results for 25 largest of these benchmarks. 
Columns 1, 2, 3 and 4 show the name of the benchmark, the number of
primary inputs, the number of primary outputs, and the number of 2-input AND gates in the benchmark,
respectively. 
In the last row of the Table~\ref{ddom_t1}, the  is
computed for all 214 benchmarks.

In our experiments, we treated every primary output of a multiple-output
circuit as a separate function. Circuits for every primary output were extracted
from the original multiple-output circuit. For each resulting
single-output circuit, all dominators were computed for every primary
input with respect to the primary output. The numbers shown in Columns 5, 6
and 7 give the total number of dominators for all single
output circuits of the corresponding benchmark. 
The same dominator of several inputs was counted as one dominator.

In Column 5, we show the total number of single-vertex dominators
(except trivial dominators which are primary inputs and the primary output),
computed using the Lengauer and Tarjan's algorithm~\cite{LeT79}.

Column 6 shows the total number of double-vertex dominators computed by
 the presented algorithm, the algorithm ~\cite{TeD05b} and the algorithm~\cite{DuTM04}.  
All three algorithms found all double
vertex-dominators, therefore they produce the same result.
For most applications, useful dominators are
those which dominate more vertices then the size of the dominator
itself. Thus, in Column 7, we also show the number of all "useful"
double-vertex which dominate at least three primary inputs.

Columns 8, 9, and 10 show the runtime of three algorithms, in seconds. The
time was measured using the Unix command  (user time). The
experiments were performed on a PC with a 1600 MHz AMD Turion64 CPU
and 1024 MByte main memory.

From Table~\ref{ddom_t1} we can see that the presented algorithm and
the algorithm~\cite{TeD05b} substantially outperform the algorithm~\cite{DuTM04}, delivering, on
average, an order of magnitude runtime reduction. This is not surprising since
they are specifically designed for double-vertex dominators.
We can also see that the presented algorithm consistently outperforms
the algorithm~\cite{TeD05b} on all 
benchmarks presented in Table~\ref{ddom_t1}.

In our implementation, the original benchmark circuits were converted to
an And-Inverter graph which consists of 2-input AND gates 
and Inverters~\cite{kuehlmann}. In such a graph, the majority of single vertex dominators have
the corresponding trivial double-vertex dominator (a pair of
vertices feeding the single-vertex dominator). The number of such
trivial double-vertex dominators can be roughly overapproximated to be
equal to the number of single-vertex dominators. Trivial double vertex
dominators  are usually less useful than the corresponding
single-vertex dominator. So, the numbers in Column 7 should be reduced by
the numbers in Column 5 to get a better picture of the number
of useful dominators.

Some rare circuits have less double-vertex dominators than
single-vertex dominators. Recall that our definition of multiple-vertex dominators
excludes redundancies. Therefore, in the extreme case of a tree-like
circuit with  vertices the number of single-vertex dominators is  while the number of double-vertex dominators is 0.


\section{Conclusion}
\label{ddom_con}
This paper presents supporting theory and algorithms for finding double-vertex dominators in directed acyclic graphs. Our results provide an efficient systematic way of partitioning a graph along the reconverging points of its signal flow. They might be useful in a number of CAD applications, including signal probability computation, switching activity estimation and cut
point identification. For example, in the method presented in~\cite{KhMKH01},
cut-points are used to progressively abstract a functional
representation by quantification.  Our dominator-based approach can
complement this method by providing a systematic way of identifying and selecting 
good cut-points for the abstraction.

Our results might also find potential applications beyond CAD borders.  In
general, any technique which use dominators in a directed acyclic graph 
might benefit from this work.

\bibliographystyle{IEEEtran}
\bibliography{dom}

\chapter*{Appendix}
{\bf A. Proof of the Theorem~\ref{ddom_tmv2}:}
Let  denote the number of vertices common for  and . 
If , then the Theorem~\ref{ddom_tmv2} holds trivially with vector
 being empty.

Assume that . We divide the prove into two parts. In the first
part, we prove that all  common vertices should be in a suffix
of one vector, and in a prefix of the other one. In the second part, we
prove that the order of common vertices is the same in both vectors. 

\noindent {\bf Part 1:}
By assumption, there exists a common vertex, say , which
belong to both  and .
This implies that there exist dominators  and
. According to the Lemma~\ref{ddom_p01}, either
 dominates  or  dominates .
This also means that either  dominates , or
 dominates . Without any loss of
generality, assume that  dominates .

First, we prove that a prefix of  whose last element is 
is always a subvector of  and a suffix of  whose first 
element is  is always a subvector of .

Due to the antisymmetry of the dominator relation,  does not
dominate . Since  is dominated by
, thus  is not dominated by .

By the Definition~\ref{ddom_mv},  dominates
 for every vertex  preceding  in .
Due to the antisymmetry of dominator relation,  does not dominate
. Since  is dominated by ,
thus  is not dominated by .

To summarize, we derived that there are dominators  and
 such that  does not dominate  and
 does not dominate . According to the
Lemma~\ref{ddom_p03}, this implies that . Therefore, 
every vertex  that precedes  in 
should also be contained in .

Using similar arguments as above, we can show that, for every vertex  succeeding  in ,
there exist dominators
 and  such that 
does not dominate  and  does not dominate
. Then, according to the Lemma~\ref{ddom_p03}, . 
This implies that every vertex  that succeeds  in 
should also be contained in .

By Lemma~\ref{ddom_p015}, the assumption that  dominates   implies that  dominates ,
where  is any common vertex of  and . None of the common vertices can occupy a position  in the vector
 such that , since otherwise  first vertices of  would be
contained in . This would contradict the fact that there are
only  common vertices in both vectors. So, all  common vertices
should be contained in a suffix of . Similarly, we can show
that all  common vertices should be contained in a prefix of . 

\noindent {\bf Part 2:}
Next, we prove that  dominating  implies that
 dominates . This would imply the same
order of common vertices in vectors  and .

Assume that  dominates .
Then using the same arguments as in the first part of the proof, we
can show that  does not
dominate  and  does not dominate . According to the
Lemma~\ref{ddom_p04},  dominates . This implies that
 dominates .
\begin{flushright}
 \\
\end{flushright}

{\bf B. Proof of the Theorem~\ref{ddom_al02}:} 
Assume that  is not a double-vertex
dominator of . Then there should be a path  from  to  which
does not contain neither  nor . 

Define  to be a vector containing all vertices of
 which appear in either
 or . More formally,  if , and
either  or .  A vertex  precedes a vertex  in
 if  precedes  in .

Let  be a set containing all vertices that either precede  in
 or precede   in .
Similarly, let  be a set of all vertices
that either succeed  in  or succeed  in .


Any vertex in  belongs to either  or . Since
the first vertex of , , is in  and the last vertex of ,
, is in , there exists  such
that  and  and .
Let  be a subvector of  containing all vertices of   from  to . 
By construction,  does
not have any common vertices with neither  nor  except  and .

To summarize, from the assumption that  is not a
double-vertex dominator  we derived the existence of the path
. Next we show that such a path  cannot exist,
and therefore the assumption is not valid.

With respect to the source and the sink of , there are four possible Cases:
\begin{enumerate}
\item  and ,
\item  and ,
\item  and ,
\item  and .
\end{enumerate}

\noindent {\bf Case 1:}
If  exists, then  is not prime. This
contradicts the conditions of the Theorem~\ref{ddom_al02}.\\
{\bf Case 2:}
If  exists, then  is not prime. This contradicts
the conditions of the Theorem~\ref{ddom_al02}.\\
{\bf Case 3:}
If  exists, then , where  is the index of
 in . Since  it
follows that , thus . This contradicts the
conditions of the Theorem~\ref{ddom_al02}.\\
{\bf Case 4:}
If  exists, then , where  is the index of
 in . Since  it follows that , thus . This
contradicts the conditions of the Theorem~\ref{ddom_al02}.
\begin{flushright}
 \\
\end{flushright}

\end{document}
