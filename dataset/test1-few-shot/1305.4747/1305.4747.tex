\documentclass{article}

  

\usepackage{epsfig}  


\usepackage{url}  
\usepackage{latexsym,amssymb}  
\usepackage{boxedminipage}  
\urlstyle{tt}  
\usepackage{xcolor}
\newcommand{\rt}[1]{\textcolor{red}{#1}}

\usepackage[linesnumbered,longend]{algorithm2e}
\usepackage[round]{natbib}



\usepackage[left]{lineno}

\usepackage{etoolbox}


\begin{document}  
  \linenumbers
  


\newcommand{\mC}{\mathcal{C}}  
\newcommand{\mF}{\mathcal{F}}  
\newcommand{\sign}{\mbox{\it sign}}
\newcommand{\PK}{\mathcal{P}}
\newcommand{\n}{[n]}
\newcommand{\Id}{\mbox{\it Id}}
\newcommand{\found}{\it found}
\newcommand{\larg}{\it large}
\newtheorem{remark}{Remark} 

\newtheorem{definition}{Definition}  
\newtheorem{proposition}{Proposition}  
\newtheorem{prop}{Property}  
\newtheorem{lemma}{Lemma}  
\newtheorem{cor}{Corollary}  
\newtheorem{corollary}{Corollary}  
\newtheorem{example}{Example}  
\newtheorem{invariant}{Invariant}  
\newtheorem{property}{Property}  
 
\newtheorem{theo}{Theorem}  
\newtheorem{theorem}{Theorem}  
 
\newenvironment{proof2}{\noindent {\it Proof.}}{\vskip1ex}  
\newenvironment{preuve}{\noindent {\it Proof.}}{\vskip1ex}  
\newenvironment{preuveA1}{\noindent {\it Proof of conservation of   
Property .}}{\vskip1ex}  
\newenvironment{preuveA2}{\noindent {\it Proof of conservation of   
Property .}}{\vskip1ex}  
\newenvironment{preuveB}{\noindent {\it Proof of the invariants.}}  
{\vskip1ex}  
\newenvironment{OJO}{\noindent {\bf OJO:}}{\vskip1ex}  
  


\title{Easy identification of generalized common and conserved nested intervals}    
   

\author{
Fabien de Montgolfier\thanks{\mbox{LIAFA, Univ. Paris Diderot - Paris 7, 75205 Paris Cedex 13, France.} {\tt \{fm,raffinot\}@liafa.univ-paris-diderot.fr}} \and Mathieu Raffinot \and Irena Rusu\thanks{\mbox{LINA, UMR 6241, Universit\'e de Nantes, 44300, Nantes, France.} {\tt Irena.Rusu@univ-nantes.fr}}} 
\maketitle 
  
  
\begin{abstract}

In this paper we explain how to easily compute gene clusters,
formalized by classical or generalized nested common or conserved
intervals, between a set of  genomes represented as 
permutations. A -nested common (resp. conserved) interval  of
size  is either an interval of size 1 or a common
(resp. conserved) interval that contains another -nested common
(resp. conserved) interval of size at least . When , this
corresponds to the classical notion of nested interval. We exhibit two
simple algorithms to output all -nested common or conserved
intervals between  permutations in  time,
where {\em nocc} is the total number of such intervals. We also
explain how to count all -nested intervals in  time. New properties of the family of conserved intervals are proposed to do so.
\end{abstract}  
  




\section{Introduction}  
\label{sec:intro}  





Comparative genomics is nowadays a classical field in computational
biology, and one of its typical problems is to cluster sets of
orthologous genes that have virtually the same function in several
genomes. A very strong paradigm is that groups of genes which remain
``close'' during evolution work together (see for instance \citet{galperin2000s}, \citet{lathe2000gene}, \citet{tamames2001evolution}).
Thus, a widely  used approach
to obtain interesting clusters is to try to cluster genes or other
biological units (for instance unique contigs of protein domains)
according to their common proximity on several genomes.  For this
goal, many different cluster models have been proposed, like common
intervals in \citet{UnoYagura}, conserved intervals in \citet{BergeronBCC04},
-patterns in \citet{Parida06}, gene teams in \citet{BealBCR04}, domain
teams in \citet{Pasek2005}, approximate common intervals in \citet{AmirGS07}
and so on, considering different chromosome models (permutations,
signed permutations, sequences, graphs, etc.) or
different distance models (accepting gaps, distance modeled as
weighted graphs, etc.)

Among all those models, the first proposed, and still
one of the most used in practice, is the concept of \emph{common
  interval} on genomes represented by permutations. A set of genes
form a common interval of  genomes if it appears as a segment on
each of the  unsigned permutations that represent the genomes. The orders
inside the segments might be totally different.  The model of
conserved interval is close to the model of common interval but
considers signed permutations. 


Recently, nested common intervals (easily extensible to nested
conserved intervals) were introduced in \citet{HD05} based on real data
observation by \citet{The10}. A common interval  of size  is nested 
if  or if it contains at least one  nested common interval of size .
\citet{HD05} pointed that
the nestedness assumption can strengthen the significance of detected
clusters since it reduces the probability of observing them randomly.
An  time algorithm to compute all nested common intervals
between two permutations has been presented in \citet{BlinFS10} while
between  permutations a recent  algorithm is
proposed in \citet{IR}, where \emph{nocc} is the number of solutions.


In this paper, we exhibit two simple algorithms to easily compute
nested common and conserved intervals of  permutations from their
natural tree representations. Also, with the same simplicity, we
propose to deal with a generalization of nested common intervals,
called -nested common intervals, and with its variant for conserved
intervals (which are a signed version of common intervals), called
-nested conserved intervals.  These new classes allow - as 
grows - for a less constraint containment between the intervals in the
family. Indeed, a nested interval  must contain a nested interval
of size  or be a unit interval. A -nested common
(resp. conserved) interval must contain a -nested common
(resp. conserved) interval of size at least  or be a unit
interval. Nested intervals are indead -nested. 
From a biological point of view, this is equivalent to modeling
clusters with a larger variability in gene content and gene order,
thus allowing algorithms to deal with annotation errors. However, the
study and validation of this new interval model is deferred to
further applied studies. In this paper we focus on the algorithmic
aspects.

Given a set  of  permutations on  elements representing
genomes with no duplicates, our simple algorithms 
for finding all -nested common or conserved intervals of  run in
-time and need  additional space, where
\emph{nocc} is the number of solutions. In this way, our algorithm for 
common intervals performs as well as the algorithm in \citet{IR} for the case
of  permutations, and proposes an efficient approach for the new classes of 
-nested intervals.
 
Moreover, a slight modification of our approach allows us to count the number
of -nested common or conserved intervals  of  permutations in  time.
Efficiently counting the number of -nested common intervals without enumerating
them is very usefull when one needs to compute similarity functions between genomes that
are expressed in terms of number of intervals.  See for instance \citet{FR}.


The paper is organized as follows. In Section \ref{sect:Generalities}
we present the main definitions for common and conserved intervals, and
precisely state the problem to solve. In Section \ref{sect:PQ} we
focus on -nested common intervals, recalling the data structure called a 
-tree, giving a characterization of -nested common intervals and showing 
how -trees can be used to find all -nested common intervals. 
In Section \ref{sect:conservedtree} we adopt a similar approach for
conserved intervals, with the difference that another tree structure must
be  used in this case. In Section \ref{sect:conclusion} we eventually conclude.



\section{Generalities on common and conserved intervals}\label{sect:Generalities}
A {\em permutation}  on  elements is a complete linear order on the set
of integers . We denote  the identity
permutation . An {\em interval} of a permutation
 is a set of consecutive elements of the
permutation . An interval of a permutation will be denoted 
by  giving its first and last positions, such as . Such
an interval is also said {\it delimited} by  (left) and  (right).
An interval  of the identity permutation 
will be simply denoted by .

\begin{definition}[\citet{UnoYagura}]
  \label{def:common-intervals}
  Let  be a set of  permutations
  on  elements.
  A {\em common interval} of   
  is a set of integers that 
  is an interval in each permutation of  .
\end{definition}

The set  and all singletons (also called unit
intervals) are common intervals of any non-empty set  of
permutations.  Moreover, one can always assume that one of the permutations,
say , is the identity permutation . For this, it is sufficient
to renumber the elements of  so as to obtain , and then 
to renumber all the other permutations accordingly. Then the common
intervals of  are of the form  with .

Define now a {\it signed} permutation as a permutation  whose elements have an associated sign among
  and , making each element to be respectively {\em positive} or {\em negative}.  
Negative elements are denoted  while positive elements are simply denoted , or  for emphasizing positivity. A permutation is then a signed permutation containing only  positive elements. 

\begin{definition}[\citet{BS06}]
Let    be 
a set of signed permutations over , with first element  and last element , 
for each . Assume .
A {\em conserved interval} of  is either a unit interval or a common interval  of 
(ignoring the signs) which is delimited, in each , either by  (left) and  (right),
or by    (left) and  (right).
\label{def:conserved}
\end{definition}

\begin{remark}
In the subsequent, we assume that    with . Moreover,
when we deal with conserved intervals, the permutations are assumed to satisfy the hypothesis in
Definition \ref{def:conserved}. 
\end{remark}

Now, we are ready to introduce the new classes of intervals.

\begin{definition}
  \label{def:bnested-intervals}
  Let  be a set of  permutations
  on  elements and let  be a positive integer. 
  A common  (respectively conserved) interval of   
  is {\em -nested} if either  or  strictly contains a common (resp. conserved)  interval of size at 
  least .
\end{definition}

We are interested in efficient algorithms for finding and counting all 
-nested common  (resp. conserved)
intervals of , without redundancy. 
Obviously,
unit intervals are, by definition, -nested common (resp. conserved) intervals.
As a consequence, from now on and without any subsequent specification, we 
focus on finding -nested common (resp. conserved)  intervals of size at
least 2.
The following notions will be very useful in the subsequent.

\begin{definition}
 Let  be a set of  permutations
  on  elements and let  be a positive integer. 
  A common  (resp. conserved) interval of   
  is {\em -small} if its size does not exceed . Otherwise, the interval is {\em -large}.
\end{definition}


Notice that all -small intervals are -nested, by definition and since unit intervals are -nested.

\section{On  -nested common intervals}\label{sect:PQ}

This section is divided into three parts. The first one recalls a tree structure that we associate
to common intervals of permutations, the -trees. The second one discusses the properties of
-nested common intervals. Finally, we give the algorithms for efficiently computing and counting
the -nested common intervals.
 
\subsection{-trees and common intervals}

\begin{definition} Let  be a family of intervals from  containing the interval . 
A {\em PQ-tree representing the family } is a tree  satisfying:

\begin{itemize}
\item[1.] its nodes are in bijection with a subset  of intervals from , the root corresponding to 
\item[2.] its arcs represent all the direct (not obtained by transitivity) inclusions between intervals in 
\item[3.] each node is labeled  ou , and an order is defined for the children of each -node
\item[4.] an interval  of  belongs to  iff either it corresponds to a node, or there
exists a unique -node  such that   is the union of intervals corresponding to
successive children of , according to the order defined for .
\end{itemize}
\label{def:PQ}
\end{definition}

Note that the size of the tree is in , thus allowing to drastically reduce the memory
space needed to store all the intervals in . When labels  and  are forgotten, the tree  
is called the {\em inclusion tree} of .

Given the -tree representing a family , we denote by  the interval from  corresponding
to a node . We also denote, for each interval  from , by  the {\it domain} of  defined 
as follows. If , then  is the set of its children. If , then by condition
4. in Definition \ref{def:PQ}, let  be the children of the -node  such
that . Then .

Fundamental results on -trees involve {\it closed} families of intervals.

\begin{definition}
A {\em closed} family  of intervals of the permutation  is a family that contains all singletons as well  
as the interval , and that in addition has the following property:  
if  and , with , belong to , then  
, ,   and  belong to .
\end{definition}

The construction of a -tree for a closed family of intervals relies on strong
intervals:

\begin{definition}
Let  be a family of closed intervals from . An interval  is said to \emph{overlap} another interval 
 if they intersect without inclusion,  \emph{i.e.}  or . 
An interval  of  is {\em strong} if it does not overlap any other  interval of , 
and  is {\em weak} otherwise.
\label{def:strong}
\end{definition}

Notice that   and the unit intervals are always strong. Also,  the family 
of strong  intervals of  is \emph{laminar} (that is, 
every two distinct intervals are either disjoint or included in each other) 
and, as  belongs to the family, it is possible to define for them an inclusion tree.
Then it can be shown that:

\begin{theorem}[\citet{landau2005using}]
\label{th1}
Given a closed family  of  intervals of , let  be the set of strong intervals from  and let
 be the inclusion tree of . Then the -tree obtained by the following rules 
represents the family :
\begin{itemize}
\item[1.] label with  each node  of  such that  for all 
  with .
\item[2.] label with  each node  of  not labeled , and define the order 
of its children such that  for all .  
\end{itemize}

\end{theorem}

Common intervals of permutations (including those of size 1) are obviously a closed family of intervals from , thus 
Theorem \ref{th1} applies. 
Moreover, the -tree for common intervals (hereafter simply denoted ) may be computed in linear time:

\begin{theorem}\citet{BCMR05}
The construction of the -tree  of common  intervals of a set  of
 permutations on  elements may be done in  time.
\end{theorem}

It is easy to note here that the leaves of  are the singletons. Also,  the intervals
, , associated to the children of a -node are contiguous, 
i.e. . This is due to condition 4 in the definition of a
-tree and to the assumption, that the reader must keep in mind, that  (thus
all the common intervals are of the form ). An example is given in Fig. \ref{figtotal2b}.



\begin{figure}[t]
 \begin{center}
\begin{tabular}{p{4cm}lp{4cm}} 
\vspace {-.8 cm}\includegraphics[height=3cm]{TotPQ.pdf}&
\phantom{xxxxxxxx} & 
\mbox{  Let ,}\hfill \linebreak \centerline{} \centerline{}
 The -tree for the set of common intervals of  is shown on the left.
\\
\end{tabular}
 \end{center}\vspace{-.3cm}
\caption{Example of PQ-tree}
 \label{figtotal2b}
\end{figure}

\subsection{Properties of -nested common intervals}\label{sect:main}

Let  be a set of permutations on  elements such that , and
let  be the -tree representing the common intervals of .
Say that a common interval  is a {\em -interval} if it is strong and there is a -node  with . 
Otherwise,  is a  {\em -interval}.

With the aim of identifying the particular structure of -nested common  intervals
among all common  intervals, we first prove that:

\begin{lemma}\label{lemma:nonnested}
Let  be a -nested common  interval with , . Then each of the intervals , ,  is either a -small 
or a -nested common interval.
\end{lemma}
\begin{preuve}
Assume a contrario that some  is of size  and is not -nested. 
Let  be a -nested common  interval with the property 
that  and  is minimal with this property. Now,
since  is -nested, we have that  strictly contains  and thus
. Then  must contain some -nested common  interval  with
 . Furthermore,  and  are disjoint since  is strong
 and by the minimality of 
we have that  cannot contain . But then ,
a contradiction.
\end{preuve}

It is easy to see that:

\begin{remark}\label{rem:inclusion}
{\em Let  be common  intervals such that  and
 is -nested with . Then   is -nested, since
.}
\end{remark}

Now, the characterization of -nested intervals corresponding to a -node is obtained as follows.

\begin{lemma}\label{lemma:round}
 Let  be a -interval with . Then  is a -nested common 
 interval if and only if there is some , such that  is
a -nested common  interval of size at least .
\end{lemma}

\begin{preuve}
Since  is a -interval, its maximal common  subintervals are ,
. The '''' part  follows directly from the definition. For the
'''' part, assume by contradiction that the affirmation does not hold. Then none of 
the intervals , , is -nested of size at least , but 
since  is -nested we deduce that some interval  exists
containing a -nested common  interval  of size at least . But
this is impossible according to Remark \ref{rem:inclusion}.
\end{preuve}

The structure of -nested common intervals given by consecutive children of a -node is more
complex. In the next lemmas we show that at most one of the intervals  composing
such an interval may be -large (see also Fig. \ref{bstruct}).
 
\begin{lemma}\label{lemma:firstlast}
 Let  be a -interval with . Then  is a -nested common 
 interval if and only if 
  is  -small and  is a -nested common  interval, or  is
 -small and  is a -nested common  interval.
\end{lemma}

\begin{preuve}
Recall that for a -interval , the order  implies that the equation
 holds
for all  with . 

: Since  is -nested, it contains some -nested interval  such that .
Choose  as large as possible. Now,  cannot be strictly included in some non -nested  by Remark \ref{rem:inclusion}, thus
 with , and  or .
Assume w.l.o.g. that . Then  is -small (since )
and  is -nested by Remark \ref{rem:inclusion} since it contains  or is
equal to .

: Let  or  according to which proposition holds. We have that  since . 
Then  is -nested.
\end{preuve}

\begin{lemma}\label{lemma:not2large}
 Let  be a -interval with  which is a -nested common 
interval. Then at most one of the intervals , , is -large, and in
this case this interval is a -nested common  interval. 
\end{lemma}

\begin{preuve}
By contradiction, assume there exist -nested common -intervals that contain at least two
-large intervals of type , and let  be a smallest  such interval 
w.r.t. inclusion. Let  (resp. ), with , be such that
 (resp. ) is -large and  (resp. ) is minimum (resp. maximum) with this
property. Then  and , otherwise by Lemma \ref{lemma:firstlast} the minimality of
 is contradicted. But now Lemma \ref{lemma:firstlast} is contradicted, since  and
 are both -large. 

Then, at most one of the intervals , , is -large. To finish the proof, 
assume that  (for some fixed ), is the unique -large interval and 
apply Lemma \ref{lemma:nonnested} to  to deduce that  is -nested.
\end{preuve}

\begin{figure}[t]
\vspace{-0.3cm}
  \centering
\includegraphics[width=5cm]{bnested.pdf} 
\caption{Structure of a -nested -interval. }
 \label{bstruct}
\vspace{-0.3cm}
\end{figure}
We are able now to prove the theorem characterizing -nested common  intervals.

\begin{theorem}\label{th:all}
Let  be a common  interval of .   is -nested if and only if:
\begin{enumerate}
\item[(a)] either  is a -interval and there exists  such that  is a -nested 
common  interval of size at least .
\item[(b)] or  is a -interval with the property that all intervals  with  are
 -small, with one possible exception which is a -large -nested interval. 

\end{enumerate}
\end{theorem}

\begin{preuve}
Lemma \ref{lemma:round} proves the theorem in the case where  is a -interval. When
 is a -interval, Lemma \ref{lemma:not2large} proves affirmation .\end{preuve}


\subsection{Computing and counting all -nested common intervals}\label{sect:algo}

Consider Algorithm \ref{algo:bnested1}, which computes all -nested common intervals. 
For a node , the  notations  and  respectively indicate the minimum and the maximum 
value in .
Figure \ref{fig:algo} illustrates our algorithm.

\begin{algorithm}[h]
\label{algo:bnested1}
\dontprintsemicolon
\caption{The -NestedCommonSearch algorithm}
\KwIn{The PQ-tree  of  for common  intervals, a positive integer }
\KwOut{All -nested common  intervals of }
Perform a post-order traversal of  \;
\For{each node  of  encountered during this traversal}{
  \eIf{ is a leaf}{output  as -nested\;}{
     let  be the children of  \;
     \eIf{ is a -node}{
      \If{  such that  is -nested and }{output  as -nested}
      }{
      \For{ to }{
            \hfill{//  number of -large intervals already included}\;
            \hfill{// considers all children starting with }\; 
           \While{ and ( or  is -nested) and }{
             \lIf{}{\;}
             \If{ and }{
                output  as -nested\;
                }
             \;
            }
         }
     }
}
}

\end{algorithm}

\begin{theorem}

Algorithm \ref{algo:bnested1} correctly computes all the -nested common  intervals,
assuming the -tree is already built, in  time, where  is the
number of -nested common intervals in .
\end{theorem}

\begin{preuve} To show the algorithm correctness, note first that 
all the leaves are output in step 4, and they are -nested common
intervals. Moreover, all -nested common intervals corresponding to
-nodes are correctly output in step 9 according to Theorem
\ref{th:all}. Next, -intervals corresponding to a -node 
are generated in steps 12-22 by starting with each child  of ,
and successively adding right children  as long as condition
 in Theorem \ref{th:all} is satisfied (step 15).


Let us analyze now the running time. The -tree has size , and the traversal considers
every node  exactly once. Working once on the children of each node
takes . The test in line 8 considers every child of a -node
one more time, so that the  time is ensured when the -interval
generation is left apart. Now, during the generation of the
-intervals, a node  that belongs to no -nested common
interval is uselessly included in some interval candidate at most once
by left initial positions for the scan (beginning line 12), which is
in total bounded by  since there exists a linear number of initial
positions in the -tree. At each iteration of
the loop line 15, a unique distinct -nested interval is output, or
 (that happens once for each node since  is incremented at
each iteration), or  (that also happens once for each node
since it ends the loop). The total number of iterations is thus
, each iteration taking . The overall running 
time is thus in  where {\em nocc} is the
total number of -nested common intervals.
\end{preuve}

\begin{figure}[t]
\vspace{-0.3cm}
  \centering
\includegraphics[width=9cm]{bqnode.pdf} 
\caption{Computing all -nested intervals of a -interval, where
   (resp. ) means -small (resp. -large). The algorithm
  considers all positions from left to right and expands the -nested
  interval while it is possible.}
 \label{fig:algo}
\vspace{-0.3cm}
\end{figure}



The previous approach can be modified to count the -nested common 
intervals instead of enumerating them, by simply analyzing more
precisely the structure of the -nodes. The goal is to count the -nested
common intervals in a time proportional to the number of children instead of the
number of -nested common intervals. To perform the count, we assume that the traversal is post-order, that it marks each
vertex as -nested or not, and that it computes the cardinality of each . 

{\bf -nodes.} Obviously, a -node (including the leaves) counts for 1 if the associated interval is -nested, and for 0 otherwise.

{\bf -nodes.} To make the computation for a -node with children  , the algorithm looks for 
the -large -nested intervals   and counts\\
1)~the -nested common intervals containing each ,
and\\
2)~the -nested common intervals generated by maximal sets of consecutive -small common intervals 
.  To this end, the vertices  are considered from left to right in order to identify 
both the -large -nested common intervals ,
and the maximal sets of consecutive -small common intervals 
. Then: 

To solve 1), each encountered -large -nested interval  has the following treatment. We 
count the number of consecutive -small nodes  on its right (resp. left), denoted by
 (resp. ).  Then we compute the number of -nested common intervals
which contain child  as   

To solve 2),  for each maximal set of consecutive -small common intervals 
, assuming it has size , we count  

One may easily decide whether the interval corresponding
to the -node itself is -nested or not, and compute its size. 

All these operations may be performed in  time, where  is the number of sons of the -node.
\bigskip

{\bf Example.} On the
example in Fig. \ref{fig:algo}, we count (from left to right): (a)
for the first -large strong child to the left:  -nested common
intervals; (b) for the -large second strong child:  -nested common
intervals; (c) for the last -large strong child:  -nested common
intervals. We sum up to obtain  -nested common intervals containing one -large -nested
interval . Now we add the nested intervals generated between the -large intervals: 
. Altogether, the -node of Figure \ref{fig:algo} generates  -nested intervals.

\paragraph{Complexity} The time complexity of the counting procedure is obviously  the size of the underlying -tree. The time needed to get the PQ-tree itself given  permutations is however , as indicated before.








\section{On -nested conserved intervals}
\label{sect:conservedtree}

As stated before, we assume the set  of permutations has the properties required in
Definition \ref{def:conserved}. As conserved
intervals are common intervals, one may be tempted to follow the same approach using -trees.
Unfortunately, the inclusion tree of strong conserved intervals does not define a -tree representing
the family of conserved intervals, due to the fact that a  conserved interval  cannot be
written as a disjoint union of strong conserved intervals. The resulting 
{\em ordered tree} has been used in the literature \citet{BergeronBCC04}, but its underlying
properties have not been clearly stated. We do it here, before using these properties.

\subsection{Structure of conserved intervals}

We start by an easy property about intersection of conserved intervals:

\begin{lemma}\label{lemstru2}
Let  and  be two conserved intervals of   with . Then the intervals , ,  and
 are conserved intervals.
\end{lemma}

\begin{preuve}
As an element  from  fulfills  and an element 
from  fulfills  then an element  from  fulfills . These elements are exactly those between 
and  and  is thus a conserved interval. Similarly, 
.The elements from  are all the elements 
not lower than  and not larger than ,  so  is a conserved interval.  
Finally, the elements from  are 
all elements greater than   and smaller than , so  is a conserved
interval. 
\end{preuve}

The notions of strong/weak intervals and of a frontier are essential in our study.


\begin{definition}
A conserved interval  of  is {\rm strong} if it has cardinality at least two, and does not overlap
other conserved intervals. Otherwise, it is {\em weak}.
\end{definition}

Notice that unit conserved intervals are not strong.

\begin{definition}
Let  be a  conserved interval.  A set
 of elements satisfying  is a
\emph{set of frontiers} of  if  is a conserved
interval, for all  with . An element of  is
a \emph{frontier} of  if it occurs in at least one set of frontiers
of .
\end{definition}

The two following properties are easy ones:

\begin{lemma}\label{lemstru1}
Let  be a conserved interval and  be a set of frontiers of .
 The elements of   are either all positive or all negative.
\end{lemma}
\begin{preuve}
 By the definition of a conserved interval, its two endpoints have the
 same sign. By the definition of a set on frontiers, any two frontiers 
 are the extremities of some conserved interval.
\end{preuve}


\begin{lemma}
\label{unionfrontier}
Let  be a conserved interval, and  let  and
 be two sets of frontiers of . Then  is
also a set of frontiers of .
\end{lemma}
\begin{preuve}
We show that any interval between two elements of  
is conserved. Let
 and , and suppose that . If , then we have
 and we are done.  If , then
 and we are also done. If  and , 
then Lemma \ref{lemstru2} allows to conclude.
The same proof holds if .
\end{preuve}

Let now  be the inclusion tree of strong intervals from , in which
every node  corresponds to a strong interval denoted , and 
node  is the parent of node  iff  is the  smallest strong
conserved interval strictly containing . Then 
contains two types of nodes: those corresponding to strong conserved 
intervals with no internal frontier, and those corresponding to strong 
conserved intervals with at least one internal frontier. We will show that 
weak conserved  intervals are the conserved strict subintervals of the latter ones, defined by two frontiers.
Overall, we have a structure working pretty much as a -tree, but which 
cannot be mapped to a -tree. This is proved in the next theorem.

Given a conserved interval, denote by  
the smallest strong conserved interval such that .  


\begin{theorem}
\label{theostruc2}
Each conserved interval  of  admits a unique maximal
(w.r.t. inclusion) set of frontiers denoted .
Moreover, each conserved
interval  of  satisfies one of the following
properties:
\begin{itemize}
\item[1.]  is strong
\item[2.]  is weak and there exists a unique strong conserved interval  of
  , and two frontiers  with , such that
  . Moreover   and 
\end{itemize}
\end{theorem}

\begin{preuve}
Let us first prove the uniqueness of the maximal set of frontiers. By contradiction, assume
two distinct maximal sets of frontiers  and  exist
for a conserved interval  . Using Lemma \ref{unionfrontier}, we deduce that 
 is a larger set of frontiers of , a contradiction.

Let us now prove that if  is not strong, then  there exists a unique strong conserved interval
, and two frontiers  with , such that .

{\em Existence of .} Let  be a weak conserved interval of .
Then there is another interval  overlapping it, either on its left
(i.e.  with )
or on its right (i.e.  with ). According to Lemma~\ref{lemstru2},  is a
conserved interval, and  is a set of frontiers
for  (not necessarily all distinct). If  is not strong then it is overlapped by
another interval .  We build an increasing sequence of intervals
, with  overlapped by , and
, until we find a strong conserved
interval  (the process ends since  is strong). Each time
Lemma~\ref{lemstru2} ensures that  is a conserved interval,
and  is a set of frontiers for 
(where  are the 
endpoins of  ). But then  is a subset of the maximal set of
frontiers  of  and the two frontiers of   defining
 are , since . 




{\em Uniqueness of .} Assume a contrario that two strong intervals  and  exist with
,  and
such that  with  and
.  Then, clearly,  and this is the left
endpoint of , whereas  and this is the right endpoint of
.  Since  and  are both strong, they cannot
overlap. Assume then w.l.o.g. that  is strictly included in
, and more precisely that  (then  due to
inclusion). Now,  overlaps  (which is forbidden) unless , in which
case we have  and this is the left endpoint of . Now,
since  is strictly included in , we deduce  and
 overlaps . This contradiction proves the
uniqueness of the strong interval  satisfying condition~2.

Let us prove that . Suppose by contradiction that 
contains a frontier  not in . Recall that  and 
,  belong to . Now, for each  with , we have that
 is a conserved interval either by Lemma~\ref{lemstru2} applied
to  and  (when ) or since it is the union
of the two conserved intervals  and  (when ). 
Symmetrically,  is also a conserved interval when , . 
But then  is a set of frontiers of  larger than , 
which contradicts the maximality of 

Eventually, let us prove that  Assume that
 , that  and that, by contradiction, there 
is a smallest strong conserved interval  which contains
. Then  since otherwise  and  would
overlap. W.l.o.g. assume that . Then 
overlaps , and this contradicts the assumption that  is strong.
\end{preuve}


We only need three more results before dealing with -nested conserved
intervals.

\begin{lemma}\label{memecontainer}
Let  and  be two conserved intervals. If there exists a frontier , 
then   
\end{lemma}

\begin{preuve}
Since both  and  are strong,
and since they share a common element, one contains the other. Now, suppose
w.l.o.g. that .  By contradiction,
assume that  and let
. Since  and that by Theorem
\ref{theostruc2} we have , we deduce that  and thus
 and  are conserved intervals. Now, one of them necessarily
overlaps , since at least one of  is not an endpoint of
. But this is impossible. Therefore  

\end{preuve}

\begin{lemma}
\label{coro1}
Let  be a (weak or strong) conserved interval with frontier set
 and let  be a conserved interval. Then
exactly one of the following cases occurs for the interval :
\begin{enumerate}
\item either there exists  such that , and then 
there exist  and  such that . 
\item or  contains no frontier of , and then there exists  such that
.
\end{enumerate}
\end{lemma}

\begin{preuve} Obviously, the two cases cannot hold simultaneously. Moreover,
in case 2., the deduction is obvious.

Let us focus now on the case 1. Let  contain some frontier .
Consider now the two intervals  and  Then
either {\em (i)} , or {\em (ii)}
, or {\em (iii)}  or , or {(iv)}  overlaps
 or . The two first cases are trivial, let us
consider the two last cases.

In case {\em (iii)} assume w.l.o.g. that  (the case  is
symmetric). Then  since .  Since 
contains the elements of  that are smaller or equal to , then
 is a conserved
interval. Thus  is a frontier set of . If  then according to Lemma~\ref{unionfrontier} we have that  is a frontier-set of  contradicting the maximality of
. We deduce that there exists  such that . 
Now we are done, since .

In case {\em (iv)},  is necessarily weak since it overlaps another
conserved interval. W.l.o.g. we assume that  overlaps  
Let us first prove that  is also a frontier of .  Indeed, 
assume {\em a contrario} that , and denote 
. With ,
we have either  and by Lemma \ref{lemstru2} for  and
 we deduce that  is conserved, or  and then
Lemma \ref{lemstru2} for  and  we deduce that 
is conserved. Then 
 is a set of frontiers of , which
contradicts the maximality of .
Now, by Lemma \ref{memecontainer} for  (whose
frontier set contains  by Theorem \ref{theostruc2}) and  
we deduce that . Thus using
Theorem \ref{theostruc2}, we conclude that  for
some . But since 
and , we are done.
\end{preuve}

The following theorem ensures that in the inclusion tree  of the strong conserved intervals 
of , weak intervals are exactly the intervals extending between two frontiers 
of a strong interval. Moreover, each weak interval is uniquely represented in
such a way. In addition, the computation of the tree and of all the frontier sets
is linear.


\begin{theorem}
Let  be the inclusion tree  of strong conserved intervals of a set  of permutations.
Then:
\begin{enumerate}
\item  a conserved interval  of  is weak if and only if there exists
a strong interval  of  and two frontiers  such 
that . Moreover, in this case  is unique.
\item for each strong conserved interval  of  with parent  in , there is a unique conserved
interval  defined by  
successive frontiers  in  such that . 
\item the tree , the maximal set of frontiers  of each strong conserved interval 
and the interval  of each strong conserved interval  may be computed 
in global  time and  space.
\end{enumerate}
\label{th:arbreT}
\end{theorem}

\begin{preuve}
Concerning affirmation 1, the '''' part is deduced directly from Theorem~\ref{theostruc2},
whereas the '''' part is ensured by the definition of a set of frontiers.
Again by Theorem \ref{theostruc2}, we deduce the uniqueness of .

Affirmation 2 results from Lemma \ref{coro1}. According to affirmation 1 in this lemma,  cannot contain
a frontier of , since otherwise  would be of the form , with , 
and thus would not be strong. Thus, by affirmation 2 in Lemma \ref{coro1}, we deduce the existence of ,
which is necessarily unique by the definition of the frontiers.

We focus now on affirmation 3. In \citet{BS06}, a conserved interval is called {\it irreducible} if it cannot 
be written as the union
of smaller conserved intervals. It is easy to notice that the set of irreducible intervals of
size at least two is exactly composed of the intervals , where 
 are two consecutive frontiers of a strong conserved interval of .
Indeed, affirmation 1 shows that the only irreducible weak conserved intervals  
are those for which , and obviously the only irreducible strong intervals  are those
with , which are of the form , with . 

To show affirmation 3, we notice that the number of irreducible intervals is in  [\citet{BS06}],
and that they may be computed in  time and space for an arbitrary number  of permutations using 
generators from \citet{IRconserved}.  Knowing irreducible conserved intervals, the computation of
strong intervals, of their set of frontiers, as well as that of the tree is quite easy. First, one
must plot on the identity permutation the  irreducible intervals of size at least two, by marking the left and
right endpoint of each such irreducible interval. Notice that each element  of the permutation 
has at most two marks, the equality occurring only when  is an internal (that is, different from
an endpoint) frontier of a strong interval. We assume the right mark of  (when it exists) 
always precedes the element  whereas the left mark (when it exists) always follows the element , 
so that a left-to-right traversal of  allows to close the interval with right endpoint
 before opening the interval with left endpoint . 

Replacing left and right marks with respectively (square) left and right brackets indexed by their corresponding 
element  on , we obtain an expression  which has correctly nested brackets, 
since irreducible intervals may only overlap on one element. Moreover,  if  and  are strong 
intervals such that  is the parent of , then  and thus these
intervals are closed exactly in this order during a left-to-right traversal of the expression .
The expression  then allows, during a left-to-right traversal, to discover the strong intervals 
according to a post-order traversal of , which is built on the fly. A strong conserved interval 
is obtained by chaining as long as possible neighboring irreducible intervals, i.e. such that the
right bracket of an interval is followed by the endpoint   of the interval and by the left bracket 
of the next interval. Its frontiers  are given by the endpoints of the chained irreducible intervals. 
Also, since  for all strong intervals , it is easy to identify  since it is 
the interval which closes immediately after  during the traversal. 
\end{preuve}

{\bf Example.} Let , where . The strong intervals
are  (with frontier set ),  (with frontier set ) and
 (with frontier set ). To build , we first plot the irreducible intervals, i.e.
 and   on , and we obtain the expression:


\noindent A left-to-right traversal of  allows to find first the interval  which is included in ,
and thus the node  of  is built, and a node  starting with  is created and defined as the parent
of . Next, the interval  in  is continued with  (just change the interval inside
the already existing node), and continued with another interval , where  is not yet known.
Still,   is discovered as a subinterval of , and it may be continued with ,
thus creating together the interval  which is another child of . Once this is done, we read
 which indicates that . Thus  has three nodes, the root  (with frontier set 
discovered during the traversal), and its two children  (with frontier set ) and 
 (with frontier set  discovered during the traversal).

\subsection{Properties of -nested conserved intervals}
\label{sect:conservedproperties}

Recall that by definition all -small conserved
intervals are -nested conserved intervals. The
characterization below of -nested conserved intervals has some
similarities with that of -nested common intervals represented in
the -tree as -intervals (see affirmation  in Theorem
\ref{th:all}).


 Let  be a conserved interval and let  be its maximal set of frontiers. We say that  {\em contains a
 -\emph{gap} at position } if  is -large.
 Furthermore, we say that a conserved interval  {\em falls in the
 gap} between  and  of  if  and
  has the parent . In other
 words,  is represented in  by the node 
 and  is  represented by the node ,
 in such a way that the former node is the parent of the latter one.
 

A -gap at position  is said \emph{good} if it contains at least one
-nested strong conserved interval  with ,
or equivalently . Then a good -gap is
a -nested conserved interval.


\begin{theorem}\label{thgap}
A conserved interval  of  is -nested if and only if it contains no
-gap, or if it contains exactly one good -gap .
\end{theorem}



\begin{preuve}

We first prove the '''' part.  Let  be a conserved
interval with maximal set of frontiers . If  contains exactly one -gap, let it be at position
. Otherwise, let us fix arbitrarily .  In both cases,  is a
conserved -nested interval: either because it is -small, or because
it is a good -gap. Now, for all  in increasing order, we deduce by
induction that   is a conserved interval (by definition of the set of
  frontiers) containing , and thus it is
  -nested. Thus  is a conserved -nested interval.
  Similarly, we deduce by induction that  is a conserved
  -nested interval, for all decreasing values of . Thus  is -nested.


Now let us prove the '''' part, by proving (a) that an
conserved interval with two -gaps or more is not -nested, and (b) that if
a -nested conserved interval contains one -gap then this -gap is good.


{\sf Proof of (a). } Assume by contradiction that  with  is
conserved -nested and contains two -gaps at initial positions  and 
(). The -nestedness of  implies the existence of a -nested
conserved interval  such that . Now,
, otherwise  misses at least 
elements from  (which is -large) and thus 
, a contradiction. Similarly, .
We deduce that  contains both  and , as well as at least one
additionnal element on the left of  and one additionnal element on the right of 
. By Lemma \ref{coro1} with  and  we have that 
with  and . Thus the existence of the -nested interval
 containing the two -gaps implies the existence of a smaller -nested
interval  still containing the two -gaps.

Now assume a maximal size series  of -nested conserved 
intervals has been built similarly, each interval being strictly included in the previous one, all containing
the two -gaps. Such a series ends with , since
otherwise (if the last interval is larger)  it is possible to construct a smaller -nested interval
included in the last interval and containing  Thus
 is -nested. But this is not possible, as it cannot 
strictly contain another -nested common interval of size at least 
. As before, such an interval needs to contain the two gaps, and
it is therefore not strictly included in 
 
{\sf Proof of (b).}  Assume now that  with  is
conserved -nested and has a unique -gap situated at position . As before,
 must contain a -nested conserved interval  with  and then
 implying by Lemma \ref{coro1} that  must contain
. The smallest interval obtained following the same reasoning is then
 itself, which must be -nested. As this interval has no internal frontiers
(otherwise  would not be maximal), any -nested common interval  of size at
least  it contains satisfies . If  is strong 
then we are done, otherwise  is strong and has all the required
properties. 
\end{preuve}

\subsection{Computing and counting all -nested conserved intervals}
\label{sect:computingconserved}

Theorem \ref{th:arbreT} allows to count and to enumerate efficiently all
-nested conserved intervals. The computation may be performed, as was
the case for common intervals, in a single post-order traversal of the inclusion tree , 
focusing on each strong conserved interval  of . First compute the -gaps of . 
Mark  as -nested if it contains no -gap or one -gap , with , 
that is a good one. The latter verification assumes that during the treatment of each child  of
, if  is detected as -nested, then  (which is an interval  with  
) is marked as good if and only if  is a -gap and 
(otherwise,  is not marked at all). Now, if  is -nested and , 
the same type of mark is performed on  if the conditions are fulfilled.
 
Then, applying Algorithm~\ref{alg2} on each strong conserved interval
 allows to enumerate all the -nested conserved intervals generated by the
frontiers of  , according to Theorem \ref{th:arbreT}. Affirmation 1 in Theorem \ref{th:arbreT}
ensures that each interval is output exactly once.
The running time of Algorithm~\ref{alg2} is clearly linear in the number of intervals output plus
the numbers of children of , yielding a global  time.

\begin{algorithm}[h!]
\dontprintsemicolon
\caption{Conserved -nested intervals \label{alg2}}
\KwIn{A strong conserved interval , its frontier set , the children of  in  marked as nested or not}
\KwOut{The conserved -nested intervals generated by the frontiers of  and strictly included in }
\For{ from  to }{
\;
goodgaps  0 \hfill{// counts the good -gaps between  and }\; 
stop \;
\Repeat{{\rm stop} and ( or ( and ))}{
  \If{}{
 // Found a  -gap at \;
    \eIf{ is a good gap and {\rm goodgaps} }
        {goodgaps  1\;}
        {stop \;}
   }
   \lIf{not {\rm stop}}{output  {\bf end if}}  \hfill{// notice  is not output}\;
   \;
}
}

\end{algorithm}

To simply count the number of -nested conserved intervals in , we must follow the same
approach as for common intervals. Good and not good -gaps are identified during a search
among the intervals , where  . Then, for
each good -gap we compute the number  (respectively ) of successive
-small intervals  on its left (respectively right). We count
the number of -nested conserved intervals containing the good -gap as  
 Next, for each maximal set of successive -small intervals 
 we add

-nested common intervals, where  is the number of -small intervals in the set.

All these operations  obvisously take  time and space.

\section{Conclusion}\label{sect:conclusion}
In this paper we introduced the family of -nested common intervals
of  permutations, and showed that it may be computed in time
proportional to its cardinality. This approach extends to any
closed family of intervals that is represented by a -tree. We also
show that our approach can be applied to conserved intervals, whose
structure and properties are close but still different from those of common
intervals. The interest of our generalization of common/conserved intervals 
for finding conserved clusters of genes should be attested by further experiments.
Also, other applications may be devised, such as helping the identification of
orthologs/paralogs or defining distances between genomes in an
evolutionary approach. These are the close perspectives of our work.


\bibliographystyle{plainnat}
\begin{thebibliography}{18}
\providecommand{\natexlab}[1]{#1}
\providecommand{\url}[1]{\texttt{#1}}
\expandafter\ifx\csname urlstyle\endcsname\relax
  \providecommand{\doi}[1]{doi: #1}\else
  \providecommand{\doi}{doi: \begingroup \urlstyle{rm}\Url}\fi

\bibitem[Amir et~al.(2007)Amir, Gasieniec, and Shalom]{AmirGS07}
A.~Amir, L.~Gasieniec, and B.~Riva Shalom.
\newblock Improved approximate common interval.
\newblock \emph{Information Processing Letters}, 103\penalty0 (4):\penalty0
  142--149, 2007.

\bibitem[B{\'e}al et~al.(2004)B{\'e}al, Bergeron, Corteel, and
  Raffinot]{BealBCR04}
M.-P. B{\'e}al, A.~Bergeron, S.~Corteel, and M.~Raffinot.
\newblock An algorithmic view of gene teams.
\newblock \emph{Theoretical Computer Science}, 320\penalty0 (2-3):\penalty0
  395--418, 2004.

\bibitem[Bergeron and Stoye(2006)]{BS06}
A.~Bergeron and J.~Stoye.
\newblock On the similarity of sets of permutations and its applications to
  genome comparison.
\newblock \emph{Journal of Computational Biology}, 13\penalty0 (7):\penalty0
  1340--1354, 2006.

\bibitem[Bergeron et~al.(2004)Bergeron, Blanchette, Chateau, and
  Chauve]{BergeronBCC04}
A.~Bergeron, M.~Blanchette, A.~Chateau, and C.~Chauve.
\newblock Reconstructing ancestral gene orders using conserved intervals.
\newblock In \emph{Proceedings of WABI}, volume 3240 of \emph{Lecture Notes in
  Computer Science}, pages 14--25, 2004.

\bibitem[Bergeron et~al.(2008)Bergeron, Chauve, de~Montgolfier, and
  Raffinot]{BCMR05}
A.~Bergeron, C.~Chauve, F.~de~Montgolfier, and M.~Raffinot.
\newblock Computing common intervals of {K} permutations, with applications to
  modular decomposition of graphs.
\newblock \emph{SIAM Journal of Discrete Mathematics}, 22\penalty0
  (3):\penalty0 1022--1039, 2008.

\bibitem[Blin et~al.(2010)Blin, Faye, and Stoye]{BlinFS10}
G.~Blin, D.~Faye, and J.~Stoye.
\newblock Finding nested common intervals efficiently.
\newblock \emph{Journal of Computational Biology}, 17\penalty0 (9):\penalty0
  1183--1194, 2010.

\bibitem[Fertin and Rusu(2011)]{FR}
G.~Fertin and I.~Rusu.
\newblock Computing genomic distances: An algorithmic viewpoint.
\newblock In \emph{Algorithms in Computational Molecular Biology: Techniques,
  Approaches and Applications, {\rm M. Elloumi, A. Y. Zomaya} {\it eds.}},
  pages 773--797. Wiley Series in Bioinformatics, 2011.

\bibitem[Galperin and Koonin(2000)]{galperin2000s}
M.~Y Galperin and E.~V Koonin.
\newblock Who's your neighbor? new computational approaches for functional
  genomics.
\newblock \emph{Nature Biotechnology}, 18\penalty0 (6):\penalty0 609--613,
  2000.

\bibitem[Hoberman and Durand(2005)]{HD05}
R.~Hoberman and D.~Durand.
\newblock The incompatible desiderata of gene cluster properties.
\newblock In \emph{Proceedings of RECOMB-CG}, volume 3678 of \emph{Lecture
  Notes in Computer Science}, pages 73--87, 2005.

\bibitem[Kurzik-Dumke and Zengerle(1996)]{The10}
U.~Kurzik-Dumke and A.~Zengerle.
\newblock Identification of a novel drosophila melanogaster gene, angel, a
  member of a nested gene cluster at locus 59f4,5.
\newblock \emph{Biochim Biophys Acta}, 1308\penalty0 (3):\penalty0 177--81,
  1996.

\bibitem[Landau et~al.(2005)Landau, Parida, and Weimann]{landau2005using}
G.~M. Landau, L.~Parida, and O.~Weimann.
\newblock Using {}-trees for comparative genomics.
\newblock In \emph{Proceedings of CPM}, volume 3537 of \emph{Lecture Notes in
  Computer Science}, pages 128--143, 2005.

\bibitem[Lathe et~al.(2000)Lathe, Snel, and Bork]{lathe2000gene}
W.~C Lathe, B.~Snel, and P.~Bork.
\newblock Gene context conservation of a higher order than operons.
\newblock \emph{Trends in Biochemical Sciences}, 25\penalty0 (10):\penalty0
  474--479, 2000.

\bibitem[Parida(2006)]{Parida06}
L.~Parida.
\newblock Gapped permutation patterns for comparative genomics.
\newblock In \emph{Proceedings of WABI}, volume 4175 of \emph{Lecture Notes in
  Computer Science}, pages 376--387, 2006.

\bibitem[Pasek et~al.(2005)Pasek, Bergeron, Risler, Louis, Ollivier, and
  Raffinot]{Pasek2005}
S.~Pasek, A.~Bergeron, J.~L. Risler, A.~Louis, E.~Ollivier, and M.~Raffinot.
\newblock {I}dentification of genomic features using microsyntenies of domains:
  domain teams.
\newblock \emph{Genome Research}, 15\penalty0 (6):\penalty0 867--874, June
  2005.

\bibitem[Rusu(2012)]{IRconserved}
I.~Rusu.
\newblock New applications of interval generators to genome comparison.
\newblock \emph{Journal of Discrete Algorithms}, 10:\penalty0 123--139, 2012.

\bibitem[Rusu(2013)]{IR}
I.~Rusu.
\newblock Min{M}ax-{P}rofiles: A unifying view of common intervals, nested
  common intervals and conserved intervals of {} permutations.
\newblock arXiv:1304.5140, submitted, 2013.

\bibitem[Tamames(2001)]{tamames2001evolution}
J.~Tamames.
\newblock Evolution of gene order conservation in prokaryotes.
\newblock \emph{Genome Biology}, 2\penalty0 (6):\penalty0 R0020, 2001.

\bibitem[Uno and Yagiura(2000)]{UnoYagura}
T.~Uno and M.~Yagiura.
\newblock Fast algorithms to enumerate all common intervals of two
  permutations.
\newblock \emph{Algorithmica}, 26:\penalty0 290--309, 2000.

\end{thebibliography}




\end{document}
