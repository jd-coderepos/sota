

\documentclass[11pt,a4paper]{article}


\usepackage{amsmath,amsfonts,bm}

\DeclareMathOperator{\LN}{LN}
\DeclareMathOperator{\MHA}{MHA}
\DeclareMathOperator{\TPMHA}{TPMHA}
\DeclareMathOperator{\EMHA}{EMHA}
\DeclareMathOperator{\FF}{FF}
\DeclareMathOperator{\ReLU}{ReLU}
\DeclareMathOperator{\embedding}{embedding}
\DeclareMathOperator{\cell}{cell}

\newcommand{\cBlue}[1]{{\color{blue}\small{#1}}}{}
\newcommand{\cBrown}[1]{{\color{brown}\small{#1}}}{}
\newcommand{\cOrange}[1]{{\color{green}\small{#1}}}{}
\newcommand{\cGreen}[1]{{\color{magenta}\small{#1}}}{}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage[hyperref]{emnlp2020}
\usepackage{times}
\usepackage{latexsym}
\usepackage{microtype}
\usepackage{graphicx}
\usepackage{subfigure}
\renewcommand{\UrlFont}{\ttfamily\small}

\usepackage{microtype}

\aclfinalcopy 



\usepackage{textcomp}
\usepackage{ifthen}
\mathchardef\mhyphen="2D
\newboolean{showcomments}
\setboolean{showcomments}{true}   \newcommand{\ps}[1]{\ifthenelse{\boolean{showcomments}}{{\color{blue}\small{[ps: #1]}}}{}}  \newcommand{\is}[1]{\ifthenelse{\boolean{showcomments}}{{\color{red}\small{[is: #1]}}}{}}  \newcommand{\jg}[1]{\ifthenelse{\boolean{showcomments}}{{\color{green}\small{[jg: #1]}}}{}}  \newcommand{\RF}[1]{\ifthenelse{\boolean{showcomments}}{{\color{orange}\small{[rf: #1]}}}{}}  \newcommand{\nj}[1]{\ifthenelse{\boolean{showcomments}}{{\color{purple}\small{[nj: #1]}}}{}}  

\newcommand{\psmo}[1]{{\color{teal}{#1}}}  
\newcommand{\ischl}[1]{{#1}}


\renewcommand{\t}[1]{{\mathtt{#1}}}
\renewcommand{\r}[1]{{\mathrm{#1}}}
\renewcommand{\b}[1]{{\mathbf{#1}}}
\renewcommand{\c}[1]{{\mathcal{#1}}}
\newcommand{\rR}{\r{R}}
\newcommand{\rF}{\r{F}}
\newcommand{\bW}{{\mathbb{W}}}
\newcommand{\bU}{{\mathbb{U}}}

\graphicspath{{images/}}

\newcommand\BibTeX{B\textsc{ib}\TeX}

\title{Enhancing the Transformer With Explicit Relational \\ Encoding for Math Problem Solving}

\author{
Imanol Schlag\thanks{\ \ Work partially done while at Microsoft Research.},
Paul Smolensky,
Roland Fernandez,
Nebojsa Jojic,\\
\textbf{
J\"urgen Schmidhuber,
Jianfeng Gao
}
\\
 The Swiss AI Lab IDSIA / USI / SUPSI,\\
 Microsoft Research, Redmond,\\
 Johns Hopkins University
\\
\{imanol,juergen\}@idsia.ch \\
\{psmo,rfernand,jojic,jfgao\}@microsoft.com
}



\date{}

\begin{document}

\maketitle
\begin{abstract}
We incorporate Tensor-Product Representations within the Transformer in order to better support the explicit representation of relation structure. 
Our Tensor-Product Transformer (TP-Transformer) sets a new state of the art on the recently-introduced Mathematics Dataset containing 56 categories of free-form math word-problems. 
The essential component of the model is a novel attention mechanism, called TP-Attention, which explicitly encodes the relations between each Transformer cell and the other cells from which values have been retrieved by attention. 
TP-Attention goes beyond linear combination of retrieved values, strengthening representation-building and resolving ambiguities introduced by multiple layers of standard attention. 
The TP-Transformer's attention maps give better insights into how it is capable of solving the Mathematics Dataset's challenging problems. 
Pretrained models and code are available online\footnote{\texttt{github.com/ischlag/TP-Transformer}}.\looseness=-1
\end{abstract}

\section{Introduction} \label{sec:Intro}
In this paper we propose a variation of the Transformer \citep{vaswani2017attention} that is designed to allow it to better incorporate structure into its representations. 
We test the proposal on a task where structured representations are expected to be particularly helpful: math word-problem solving, where, among other things, correctly parsing expressions and compositionally evaluating them is crucial.
Given as input a free-form math question in the form of a character sequence like \texttt{Let r(g) be the second derivative of 2*g**3/3 - 21*g**2/2 + 10*g. Let z be r(7). Factor -z*s + 6 - 9*s**2 + 0*s + 6*s**2.}, the model must produce an answer matching the specified target character-sequence \texttt{-(s + 3)*(3*s - 2)} exactly.
Our proposed model is trained end-to-end and infers the correct answer for novel examples without any task-specific structural biases. 

We begin by viewing the Transformer as a kind of Graph Neural Network \citep[e.g.,][]{gori2005new, GK95a, battaglia2018relational}. 
For concreteness, consider the encoder component of a Transformer with  heads. 
When the  head of a cell  of layer  issues a query and as a result concentrates its self-attention distribution on another cell  in layer , we can view these two cells as joined by an edge in an information-flow graph: the information content at  in effect passes via this edge to affect the state of . 
The strength of this attention can be viewed as a weight on this edge, and the index  of the head can be viewed as a label. 
Thus, each layer of the Transformer can be viewed as a complete, directed, weighted, labeled graph.
Prior NLP work has interpreted certain edges of these graphs in terms of linguistic relations (Sec.~\ref{sec:Related}), and we wish to enrich the relation structure of these graphs to better support the explicit representation of relations within the Transformer. 

Here we propose to replace each of the discrete edge labels , with a \newterm{relation vector}: we create a bona fide representational space for the relations being learned by the Transformer.
This makes it possible for the hidden representation at each cell to approximate the vector embedding of a symbolic structure built from the relations generated by that cell.
This embedding is a \newterm{Tensor-Product Representation} \citep[\newterm{TPR};][]{Smolensky:1990:TPV:102418.102425} in an end-to-end-differentiable TPR system \citep{schlag2018nips, Schmidhuber:93ratioicann} that learns ``internal spotlights of attention'' \citep{Schmidhuber:93ratioicann}.
TPRs provide a general method for embedding symbol structures in vector spaces.
TPRs support compositional processing by directly encoding constituent structure: the representation of a structure is the sum of the representation of its constituents.
The representation of each constituent is built compositionally from two vectors: one vector that embeds the content of the constituent, the \newterm{`filler'} --- here, the vector returned by attention --- and a second vector that embeds the structural \newterm{role} it fills --- here, a relation conceptually labeling an edge of the attention graph.
The vector that embeds a filler and the vector that embeds the role it fills are \newterm{bound} together by the tensor product to form the tensor that embeds the constituent that they together define.\footnote{
The tensor product operation (when the role-embedding vectors are linearly independent) enables the sum of constituents representing the structure as a whole to be uniquely decomposable back into individual pairs of roles and their fillers, if necessary.}
The relations here, and the structures they define, are learned unsupervised by the Transformer in service of a task; post-hoc analysis is then required to interpret those roles.

In the new model, the \newterm{TP-Transformer}, each head of each cell generates a key-, value- and query-vector, as in the Transformer, but additionally generates a \newterm{role-vector} (which we refer to in some contexts as a `relation vector').
The query is interpreted as seeking the appropriate filler for that role (or equivalently, the appropriate string-location for fulfilling that relation).
Each head binds that filler to its role via the tensor product (or some contraction of it), and these filler/role bindings are summed to form the TPR of a structure with  constituents (details in Sec.~\ref{sec:TPT}). 

An interpretation of an actual learned relation illustrates this (see Fig.~\ref{fig:attn-maps} in Sec.~\ref{sec:InterpAttn}).
One head of our trained model can be interpreted as partially encoding the relation \textit{second-argument-of}.
The top-layer cell dominating an input digit seeks the operator of which the digit is in the second-argument role.
That cell generates a vector  signifying this relation, and retrieves a value vector  describing the operator from position  that stands in this relation.
The result of this head's attention is then the binding of filler  to role ; this binding is added to the bindings resulting from the cell's other attention heads. 

On the Mathematics Dataset (Sec.~\ref{sec:Data}), the new model sets a new state of the art for the overall accuracy (Sec.~\ref{sec:Results}).
Initial results of interpreting the learned roles for the arithmetic-problem module show that they include a good approximation to the second-argument role of the division operator and that they distinguish between numbers in the numerator and denominator roles (Sec.~\ref{sec:Interp}). 

More generally, it is shown that Multi-Head Attention layers not only capture a subspace of the attended cell but capture nearly the full information content (Sec.~\ref{sec:information}).
An argument is provided that multiple layers of standard attention suffer from the binding problem, and it is shown theoretically how the proposed TP-Attention avoids such ambiguity (Sec.~\ref{sec:Binding}).
The paper closes with a discussion of related work (Sec.~\ref{sec:Related}) and a conclusion (Sec.~\ref{sec:Conclusion}).


\section{The TP-Transformer}  \label{sec:TPT}
The TP-Transformer's encoder network, like the Transformer's encoder \citep{vaswani2017attention}, can be described as a 2-dimensional lattice of cells  where  are the sequence elements of the input and  are the layer indices with  as the embedding layer.
All cells share the same topology and the cells of the same layer share the same weights. 
More specifically, each cell consists of an initial layer normalization (LN) followed by a \newterm{TP-Multi-Head Attention (TPMHA)} sub-layer followed by a fully-connected feed-forward (FF) sub-layer. Each sub-layer is followed by layer normalization (LN) and by a residual connection (as in the original Transformer). Our cell structure follows directly from the official TensorFlow source code by \cite{vaswani2017attention} but with regular Multi-Head Attention replaced by our TPMHA layer.

\subsection{TP-Multi-Head Attention} \label{sec:TPMA}
The TPMHA layer of the encoder consists of  heads that can be applied in parallel. 
Every head  applies separate affine transformations ,  to produce key, value, query, and relation vectors from the hidden state , where :


The filler of the attention head  is 

i.e., a weighted sum of all  values of the same layer and attention head (see Fig. \ref{fig:TP-Attention}).
Here  is a continuous \textit{degree of match} given by the softmax of the dot product between the query vector at position  and the key vector at position :


The scale factor  can be motivated as a variance-reducing factor under the assumption that the elements of  and  are uncorrelated variables with mean 0 and variance 1, in order to initially keep the values of the softmax in a region with better gradients \cite{vaswani2017attention}.

Finally, we bind the filler  with our relation vector , followed by an affine transformation  before it is summed up with the other heads' bindings to form the TPR of a structure with  constituents: this is the output of the TPMHA layer.


Note that, in this binding, to control dimensionality, we use a contraction of the tensor product, pointwise multiplication : this is the diagonal of the tensor product. For discussion, see the Appendix. 

\begin{figure}[ht]
    \begin{center}
    \includegraphics[scale=1.0]{tp-attention.png}
    \end{center}
    \caption{A simplified illustration of our TP-Attention mechanism for one head at position  in layer . The main difference from standard Attention is the additional role representation that is element-wise multiplied with the filler/value representation.}
    \label{fig:TP-Attention}
\end{figure}

It is worth noting that the  TPMHA layer returns a vector that is quadratic in the inputs  to the layer: the vectors  that are linearly combined to form  (Eq.~\ref{eq:v-bar}), and , are both linear in the  (Eq.~\ref{eq:kvqr}), and they are multiplied together to form the output of TPMHA (Eq.~\ref{eq:TPMHA}). 
This means that, unlike regular attention, TPMHA can increase, over successive layers, the polynomial degree of its representations as a function of the original input to the Transformer.
Although it is true that the feed-forward layer following attention (Sec.~\ref{sec:FF}) introduces its own non-linearity even in the standard Transformer, in the TP-Transformer the attention mechanism itself goes beyond mere linear re-combination of vectors from the previous layer. This provides further potential for the construction of increasingly abstract representations in higher layers. 

\subsection{Feed-Forward Layer} \label{sec:FF}
The feed-forward layer of a cell consists of an affine transformation followed by a ReLU activation and a second affine transformation:

Here,  and  is the function's argument.
As in previous work, we set . 

\subsection{The Decoder Network}
The decoder network is a separate network with a similar structure to the encoder that takes the hidden states of the encoder and auto-regressively generates the output sequence. 
In contrast to the encoder network, the cells of the decoder contain two TPMHA layers and one feed-forward layer.
We designed our decoder network analogously to \cite{vaswani2017attention} where the first attention layer attends over the masked decoder states while the second attention layer attends over the final encoder states.
During training, the decoder network receives the shifted targets (teacher-forcing) while during inference we use the previous symbol with highest probability (greedy-decoding). 
The final symbol probability distribution is given by

where  is the hidden state of the last layer of the decoder at decoding step  of the output sequence and  is the shared symbol embedding of the encoder and decoder.

\section{The Mathematics Dataset}  \label{sec:Data}
The Mathematics Dataset \citep{saxton2018analysing} is a large collection of math problems of various types, including algebra, arithmetic, calculus, numerical comparison, measurement, numerical factorization, and probability.
Its main goal is to investigate the capability of neural networks to reason formally. 
Each problem is structured as a character-level sequence-to-sequence problem. 
The input sequence is a free-form math question or command like \texttt{What is the first derivative of 13*a**2 - 627434*a + 11914106?} from which our model correctly predicts the target sequence \texttt{26*a - 627434}.
Another example from a different module is \texttt{Calculate 66.6*12.14.} which has \texttt{808.524} as its target sequence.

The dataset is structured into 56 modules which cover a broad spectrum of mathematics up to university level.
It is procedurally generated and comes with 2 million pre-generated training samples per module.
The authors provide an interpolation dataset for every module, as well as a few extrapolation datasets as an additional measure of algebraic generalization.

We merge the different training splits \textit{train-easy}, \textit{train-medium}, and \textit{train-hard} from all modules into one big training dataset of 120 million unique samples.
From this dataset we extract a character-level vocabulary of 72 symbols, including \textit{start-of-sentence},  \textit{end-of-sentence}, and \textit{padding} symbols\footnote{Note that \cite{saxton2018analysing} report a vocabulary size of 95, but this figure encompasses characters that never appear in the pre-generated training and test data.}.

\newcommand{\NameLSTM}{LSTM with thinking steps (Saxton et al.)}
\newcommand{\NameTFSaxton}{Transformer (Saxton et al.)}
\newcommand{\NameTF}{Transformer (ours)}
\newcommand{\NameTPTlarge}{TP-Transformer (ours)}
\newcommand{\NameTPTsmallA}{TP-Transformer B (ours)}
\newcommand{\NameTPTsmallB}{TP-Transformer C (ours)}

\begin{table*}[t]
\centering
\setlength{\tabcolsep}{0.12cm}
\begin{tabular}{lccccccc}
\hline
\multicolumn{1}{c}{} 
& \multicolumn{1}{c}{\textbf{Weights}} 
& \multicolumn{1}{c}{\textbf{Steps}} 
& \multicolumn{1}{c}{\textbf{Train}} 
& \multicolumn{2}{c}{\textbf{Interpolation}} 
& \multicolumn{2}{c}{\textbf{Extrapolation}} \\
\multicolumn{1}{c}{} 
& 
& 
& 
& \multicolumn{1}{c}{acc} & \multicolumn{1}{c}{\textgreater 95\%}
& \multicolumn{1}{c}{acc} & \multicolumn{1}{c}{\textgreater 95\%} \\
\hline

\NameLSTM       & 18M   & 500k  & -         & 57.00\%       & 6     & 41.00\%       & 1 \\
\NameTFSaxton   & 30M   & 500k  & -         & 76.00\%       & 13    & 50.00\%       & 1 \\
\NameTF         & 44.2M & 1000k & 86.60\%   & 79.54\%       & 16    & 53.28\%       & 2 \\
\NameTPTlarge   & 49.1M & 1000k & 89.01\%   & 81.92\%       & 18    & 54.67\%       & 3 \\
\NameTPTsmallA  & 43.0M & 1000k & 87.53\%   & 80.52\%       & 16    & 52.04\%       & 1 \\
\NameTPTsmallB  & 30.0M & 1000k & 86.33\%   & 79.02\%       & 14    & 54.71\%       & 1 \\
\hline
\end{tabular}
\label{table:accuracy}
\caption{Model accuracy averaged over all modules. A sample is correct if all characters of the target sequence have been predicted correctly. The column ``\textgreater 95\%'' counts how many of the 56 modules achieve over 95\% accuracy. TP-Transformer B and C differ from the standard hyper-parameters in order to reduce the total number of weights. See section \ref{sec:ImplsDetails} for more details.}
\end{table*}

\section{Experimental Results}  \label{sec:Results}
We evaluate our trained model on the concatenated interpolation and extrapolation datasets of the pre-generated files, achieving a new state of the art (see Table 1). \ischl{A more detailed comparison of the interpolation and extrapolation performance for every module separately can be found in the supplementary material.}
\ischl{Throughout 1.0 million training steps, the interpolation error on the held-out data was strictly decreasing.
We trained on one machine with 8 P100 Nvidia GPUs for 10 days. Preliminary experiments of 2.0 million training steps indicates that the interpolation accuracy of the TP-Transformer can be further improved to at least 84.24\%.} \looseness=-1

\subsection{Implementation Details}
\label{sec:ImplsDetails}
\ischl{The TP-Transformer uses the same hyper-parameters as the regular Transformer (). 
Due to the use of the TP-Attention this results in a larger number of trainable weights. 
For this reason we also include two hyper-parameter settings with fewer trainable weights.
\textit{TP-Transformer B} shrinks the hidden-state size and filter size from a multiple of 64 to a multiple of 60 () which results in 1.2 million fewer trainable weights than the baseline and the \textit{TP-Transformer C} shrinks the filter size more aggressively down to a total of 14.2 million trainable weights (\texttildelow 32\% fewer weights) by massively reducing the filter size while keeping the hidden state size the same ().}

We initialize the symbol embedding matrix  from ,  from , and all other matrices  using the Xavier uniform initialization as introduced by \cite{glorot2010understanding}.
We were not able to train the TP-Transformer, nor the regular Transformer, using the learning rate and gradient clipping scheme described by \cite{saxton2018analysing}.
Instead we proceed as follows:
The gradients are computed using PyTorch's Autograd engine and their gradient norm is clipped at 0.1.
The optimizer we use is also Adam, but with a smaller .
We train with a batch size of 1024.

\section{Interpreting the Learned Structure}  \label{sec:Interp}
We report initial results of analyzing the learned structure of the encoder network's last layer after training the TP-Transformer for 700k steps.

\subsection{Interpreting the Learned Roles}
To this end, we sample 128 problems from the interpolation dataset of the \textit{arithmetic\_\_mixed} module and collect the role vectors from a randomly chosen head. 
We use -means with  to cluster the role vectors from different samples and different time steps of the final layer of the encoder. 
Interestingly, we find separate clusters for digits in the numerator and denominator of fractions. 
When there is a fraction of fractions we can observe that these assignments are placed such that the second fraction reverses, arguably simplifying the division of fractions into a multiplication of fractions (see Fig.~\ref{fig:interpret}). 

\begin{figure*}[h!]
\centering
    \includegraphics[width=0.9\textwidth]{fraction_example.png}
  \vspace{-8pt}
  \caption{Samples of correctly processed problems from the \textit{arithmetic\_\_mixed} module. 
  `\textsf{\#}' and `\textsf{\%}' are the start- and end-of-sentence symbols. The colored squares indicate the -means cluster of the role-vector assigned by one head in the final layer in that position.  Blue and gold rectangles respectively highlight numerator and denominator roles. They were discovered manually. Note how their placement is correctly swapped in rows 2, 3, and 4, where a number in the denominator of a denominator is treated as if in a numerator. Role-cluster 9 corresponds to the role \textit{ones-digit-of-a-numerator-factor}, and 6 to  \textit{ones-digit-of-a-denominator-factor}; other such roles are also evident.}
\label{fig:interpret}
\end{figure*}
\begin{figure*}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{Attention-GIVE436boxed.png}
    \includegraphics[width=0.9\textwidth]{Attention-GIVE403boxed.png}
    \includegraphics[width=0.9\textwidth]{Attention-GIVE138boxed.png}
    \vspace{-8pt}
    \caption{TP-Transformer attention maps for three examples as described in section \ref{sec:InterpAttn}.}
    \label{fig:attn-maps}
\end{figure*}

\subsection{Interpreting the Attention Maps}  \label{sec:InterpAttn}
In Fig.~\ref{fig:attn-maps} we display three separate attention weight vectors of one head of the last TP-Transformer layer of the encoder.
Gold boxes are overlaid to highlight most-relevant portions.
The row above the attention mask indicates the symbols that take information to the symbol in the bottom row.
In each case, they take from `\texttt{/}'.
Seen most simply in the first example, this attention can be interpreted as encoding a relation \textit{second-argument-to} holding between the querying digits and the `\texttt{/}' operator.
The second and third examples show that several numerals in the denominator can participate in this relation.
The third display shows how a numerator-numeral (\texttt{-297}) intervening between two denominator-numerals is skipped for this relation. \looseness=-1


\section{\ischl{Deficits of Multi-Head Attention Layers}}
\subsection{Multi-Head Attention Subspaces Capture Virtually All Information}
\label{sec:information}
It was claimed by \cite{vaswani2017attention} that \textit{Multi-head attention allows the model to jointly attend to information from different representation subspaces at different positions.} In this section, we show that in our trained models, an individual attention head does not access merely a subset of the information in the attended cell but instead captures nearly the full information content.

Let us consider a toy example where the attention layer of  only attends to . In this setting, the post-attention representation simplifies and becomes 

where  and  are the respective affine maps (see Sec.~\ref{sec:TPMA}).
Note that even though  is a projection into an 8 times smaller vector space, it remains 
to be seen whether the hidden state loses information about .
We empirically test to what extent the trained Transformer and TP-Transformer lose information. 
To this end, we randomly select  samples and extract the hidden state of the last layer of the encoder , as well as the value representation  for every head. 
We then train an affine model to reconstruct  from , the value vector of the single head :

For both trained models, the TP-Transformer and the regular Transformer, the mean squared error  averaged across all heads is only \texttildelow 0.017 and \texttildelow 0.009 respectively.
Note that, because of layer normalization, the relevant quantities are scaled to .
This indicates that the attention mechanism incorporates not just a subspace of the states it attends to, but affine transformations of those states that preserve nearly the full information content. 
\ischl{In such a case, the attention mechanism can be interpreted as the routing of multiple local information source into one global tree structure of local representations. }

\subsection{The Binding Problem of Stacked Attention Layers} \label{sec:Binding}
The \textit{binding problem} refers to the problem of binding features together into objects while keeping them separated from other objects.
It has been studied in the context of theoretical neuroscience \citep{von1981correlation, von1994correlation} but also with regards to connectionist machine learning models \citep{hinton1984distributed}. 
The purpose of a binding mechanism is to enable the fully distributed representation of symbolic structure (like a hierarchy of features) which has recently resurfaced as an important direction for neural network research \citep{lake2017generalization, bahdanau2018systematic, van2019perspective, palangi2017deep, tang2018learning}. 

In this section, we describe how the standard attention mechanism is ill suited to capture complex nested representations, and we provide an intuitive understanding of the benefit of our TP-Attention. 
We understand the attention layer of a cell as the means by which the \textit{subject} (the cell state) queries all other cells for an \textit{object}. 
We then show how a hierarchical representation of multiple queries becomes ambiguous in multiple standard attention layers. 

Consider the string \texttt{(a/b)/(c/d)}. 
A good neural representation captures the hierarchical structure of the string such that it will not be confused with the similar-looking but structurally different string \texttt{(a/d)/(c/b)}. 
Our TP-Attention makes use of a binding mechanism in order to explicitly support complex structural relations by binding together the object representations receiving high attention with a subject-specific role representation. 
Let us continue with a more technical example.
Consider a simplified Transformer network where every cell consists only of a single-head attention layer with a residual connection: no feed-forward layer or layer normalization, and let us assume no bias terms in the maps  and  introduced in the previous section (Eq.~\ref{singlehead}). 
In this setting, assume that  only attends to , and  only attends to  where  are distinct positions of the input sequence. 
In this case


Suppose now that, for hierarchical grouping, the next layer  attends to both  and  (equally, each with attention weight ). 
This results in the representation


Note that the final representation is ambiguous in the sense that it is unclear by looking only at Eq. \ref{eq:ambiguous} whether  has picked  or .
Either scenario would have led to the same outcome, which means that the network would not be able to distinguish between these two different structures (as in confusing \texttt{(a/b)/(c/d)} with \texttt{(a/d)/(c/b)}).
In order to resolve this ambiguity, the standard Transformer must recruit other attention heads or find suitable non-linear maps in between attention layers, but it remains uncertain how the network might achieve a clean separation.

Our TP-Attention mechanism, on the other hand, specifically removes this ambiguity.
Now Eqs.~\ref{eq:zac} and \ref{eq:ambiguous} become:

Note that the final representation is not ambiguous anymore.
Binding the filler symbols  (our objects) with a subject-specific role representation  as described in Eq. \ref{eq:TPMHA} breaks the structural symmetry we had with regular attention.
It is now simple for the network to specifically distinguish the two different structures.

\ischl{
\section{Hadamard-Product Attention as an Optimal Approximation of Tensor-Product Attention}
In Eq.~\ref{eq:TPMHA} for TPMHA, we have a sum over all  heads of an affine-transformed product of a value vector  and a role vector .
(Throughout this discussion, we leave the subscripts  implicit, as well as the over-bar on  in Eq.~\ref{eq:TPMHA}.)
In a hypothetical, full-TPR formulation, this product would be the tensor product , although in our actual proposed TP-Transformer, the Hadamard (elementwise) product  (the diagonal of ) is used.
The appropriateness of the compression from tensor product to Hadamard product can be seen as follows.

In the hypothetical full-TPR version of TPMHA, attention would return the sum of  tensor products.
This tensor  would have rank at most , potentially enabling a substantial degree of compression across all tensors the model will compute over the data of interest.
Given the translation-invariance built into the Transformer via position-invariant parameters, 
the same compression must be applied in all positions within a given layer , although the compression may vary across heads.
For the compression of  we will need more than  components, as this decomposition needs to be optimal over all \emph{all} tensors in that layer for \emph{all} data points.


In detail, for each head , the compression of the tensor 
 (or matrix )
is to dimension , which will ultimately be mapped to dimension  (to enable addition with  via the residual connection) by the affine transformation of Eq.~\ref{eq:TPMHA} .
The optimal -dimensional compression for head  at layer  would preserve the  dominant dimensions of variance of the attention-generated states for that head and layer, across all positions and inputs: a kind of singular-value decomposition retaining those dimensions with the principal singular values.
Denote these principal directions by , and let  and  respectively be the  matrices with the orthonormal vectors  and  as columns.
(Note that orthonormality implies that  and , with  the  identity matrix.)
 
The compression of , , will lie within the space spanned by these  tensor products , i.e., ; in matrix form, , where  is the  diagonal matrix with elements .
Thus the  dimensions  of the compressed matrix  that approximates  are given by:



where , .
Now from Eq.~\ref{eq:kvqr}, , so .
Thus by changing the parameters  to , and analogously for the role parameters , we convert our original hypothetical TPR attention tensor  to its optimal -dimensional approximation, in which the tensor product of the original vectors  is replaced by the Hadamard product of the linearly-transformed vectors .
Therefore, in the proposed model, which deploys the Hadamard product, learning simply needs to converge to the parameters  rather than the parameters .
}

\section{Related Work}  \label{sec:Related}
Several recent studies have shown that the Transformer-based language model BERT \citep{devlin2018bert} captures linguistic relations such as those expressed in dependency-parse trees. 
This was shown for BERT's hidden activation states \citep{hewitt2019structural, tenney2019bert} and, most directly related to the present work, for the graph implicit in BERT's attention weights \citep{coenen2019visualizing, lin2019open}.
Future work applying the TP-Transformer to language tasks (like those on which BERT is trained) will enable us to study the connection between the \textit{explicit} relations  the TP-Transformer learns and the \textit{implicit} relations that have been extracted from BERT.

\ischl{
Multiplicative states have been used in neural networks before \cite{ivakhnenko1965, ivakhnenko1971}.
The Hadamard-Product Attention bears similarity to neural network gates which have been shown to be effective mechanism to represent complex states in recurrent models \cite{Hochreiter:97lstm} and feed-forward models \cite{greff2015nips}. 
Recent work presents the \textit{Gated Transformer-XL} model which incorporates a gating layer after the Multi-Head Attention layer of the regular Transformer \cite{parisotto2019stabilizing}. 
Unlike the regular Transformer, the Gated Transformer-XL is shown to be stable in a reinforcement learning domain while matching or outperforming recurrent baselines.
The main difference is that the TP-Attention binds the values of different heads before summation whereas the \textit{Gated Transformer-XL} gates simply the output of the attention-layer.

Very recent work proposes a Transformer variation which merges the self-attention layer and the fully-connected layer into a new \textit{all-attention} layer \cite{sukhbaatar2019augmenting}. 
To achieve this, the self-attention layer is extended with keys and values which are learned by gradient descent instead of using neural network activations. 
The feed-forward layers are then removed. 
Our binding-problem argument (Sec. \ref{sec:Binding}) applies to this architecture even more so than to the regular Transformer since there are no non-linear maps in-between attention layers that could possibly learn to resolve ambiguous cases.

Previous work used Multi-Head Attention also in recurrent neural networks in order to perform complex relational reasoning \cite{santoro2018relational}. In their work, Multi-Head Attention is used to allow memories to interact with each other. They demonstrate benefits on program evaluation and memorization tasks. Technically, the TP-Attention is not limited to the Transformer architecture and as such the benefits could possibly carry over to any connectionist model that makes use of Multi-Head Attention. 
}

\section{Conclusion}  \label{sec:Conclusion}
We have introduced the TP-Transformer, which enables the powerful Transformer architecture to learn to explicitly encode structural relations using Tensor-Product Representations. 
On the novel and challenging Mathematics Dataset, \ischl{TP-Transformer beats the previously published state of the art and our initial analysis} of this model's final layer suggests that the TP-Transformer naturally learns to cluster symbol representations based on their structural position and relation to other symbols.

\section{Acknowledgments}
We thank the anonymous reviewers for their valuable comments.
This research was supported by an European
Research Council Advanced Grant (no:~742870).

\bibliographystyle{acl_natbib}
\bibliography{references}

\appendix
\section{General Considerations}

In the version of the TP-Transformer studied in this paper, binding of relations  to their values  is not done by the tensor product, , as in full TPRs.
Rather, a contraction of the full TPR is used: the diagonal, which is the elementwise or Hadamard product .\footnote{This is a vector, and should not be confused with the inner product  which is a scalar: the inner product is the sum of all the elements of the Hadamard product.}
To what extent does Hadamard-product binding share relevant properties with tensor-product binding?

A crucial property of the tensor product for its use in vector representations of structure is that a structure like  is not confusable with , unlike the frequently-used bag-of-words encoding: in the BOW encoding of , the pair of arguments to the operator are encoded simply as , where  and  are respectively the vector encodings of  and . 
Obviously, this cannot be distinguished from the BOW encoding of the argument pair in , . (Hence the name, symbol ``bag'', as opposed to symbol ``structure''.)

In a tensor-product representation of the argument pair in , we have , where  and  are respectively distinct vector embeddings of the numerator (or first-argument) and denominator (or second-argument) roles, and  is the tensor product. 
This is distinct from , the embedding of the argument-pair in . 
(In Sec.~\ref{sec:Binding} of the paper, an aspect of this general property, in the context of attention models, is discussed. 
In Sec.~\ref{sec:Interp}, visualization of the roles and the per-role-attention show that this particular distinction, between the numerator and denominator roles, is learned and used by the trained TP-Transformer model.)

This crucial property of the tensor product, that , is shared by the Hadamard product:  if we now take  to represent the Hadamard product, the inequality remains true. 
To achieve this important property, the full tensor product is not required: the Hadamard product is the diagonal of the tensor product, which retains much of the product structure of the tensor product. 
In any application, it is an empirical question how much of the full tensor product is required to successfully encode distinctions between bindings of symbols to roles; in the TP-Transformer, it turns out that the diagonal of the tensor product is sufficient to get improvement in performance over having no symbol-role-product structure at all. 
Unfortunately, the compute requirements of training on the Mathematics Dataset currently makes using the full tensor product infeasible, unless the vector representations of symbols and roles are reduced to dimensions that proved to be too small for the task. 
When future compute makes it possible, we expect that expanding from the diagonal to the full tensor product will provide further improvement in performance and interpretability.

\section{Detailed Test Accuracy}
\begin{figure*}[h]
  \vspace{-10pt}
  \centering
    \includegraphics[scale=0.39]{interpolation.png}
  \caption{Test accuracy on the interpolation test-set of the Mathematics dataset. TPT refers to the TP-Transformer variations as introduced in section \ref{sec:ImplsDetails}. TF refers to our implementation of the Transformer \cite{vaswani2017attention}.}
\end{figure*}

\begin{figure*}[t]
  \vspace{-10pt}
  \centering
    \includegraphics[width=\textwidth]{extrapolation.png}
  \caption{Test accuracy on the extrapolation test-set of the Mathematics dataset. TPT refers to the TP-Transformer variations as introduced in section \ref{sec:ImplsDetails}. TF refers to our implementation of the Transformer \cite{vaswani2017attention}.}
\end{figure*}

\end{document}
