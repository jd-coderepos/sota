
\documentclass{tlp}


\usepackage{graphicx}
\usepackage{ulem}
\usepackage{color}
\usepackage{latexsym}
\usepackage{amsmath}
\usepackage{amsfonts}

\normalem

\long\def\comment#1{}

\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
\newcommand{\rrarrow}{\longrightarrow}

\newtheorem{definition}{Definition} \newtheorem{proposition}{Proposition} \newtheorem{example}{Example} \newtheorem{corollary}{Corollary} \newtheorem{theorem}{Theorem} \newtheorem{lemma}{Lemma}

\title[Unfolding for CHR programs]
      {Unfolding for CHR programs}




\author[M. Gabbrielli, M.C. Meo, P. Tacchella and H. Wiklicky]{
	Maurizio Gabbrielli\\
		Department of Computer Science/Focus \\
		Universit\`a di Bologna/INRIA\\
		Mura Anteo Zamboni 7,\\
		40127 Bologna, Italy\\
		\email{gabbri@cs.unibo.it}
\and
        Maria Chiara Meo\\
		Dipartimento di Economia\\
		Universit\`a di Chieti-Pescara\\
		Viale Pindaro 42,\\
		65127 Pescara, Italy\\
		\email{cmeo@unich.it}
\and
        Paolo Tacchella\\
		Universit\`a di Bologna\\
		Mura Anteo Zamboni 7,\\
		40127 Bologna, Italy\\
		\email{Paolo.Tacchella@cs.unibo.it}
		\and
        	Herbert Wiklicky\\
		Imperial College London\\
		180 Queen's Gate\\
		London SW7 2BZ, UK\\
		\email{herbert@doc.ic.ac.uk}
}



\submitted{25 October 2010}
\revised{12 September 2012}
\accepted{28 June 2013}

\label{firstpage}

\begin{document}

\bibliographystyle{acmtrans}

\maketitle


\begin{abstract}
Program transformation is an appealing technique which allows to
improve  run-time efficiency, space-consumption, and more generally
to optimize a given program. Essentially, it consists of a sequence
of syntactic program manipulations which preserves some kind of
semantic equivalence. Unfolding is one of the basic operations which is used
by most program transformation systems and which
consists in the replacement of a procedure call by its definition.
While there is a large body of literature on transformation and
unfolding of sequential programs, very few papers have addressed
this issue for concurrent languages.

This paper defines an unfolding system
for CHR programs. We define an unfolding rule, show its
correctness and discuss some conditions which can be used to
delete an unfolded rule while preserving the program meaning.
We also prove that, under some suitable conditions, confluence and termination are preserved by the above transformation.

{\em To appear
in Theory and Practice of Logic Programming (TPLP).}

\end{abstract}

\begin{keywords}
CHR (Constraint Handling Rules), Program Transformation, Unfolding, Confluence, Termination.
\end{keywords}
\section{Introduction}

Constraint  Handling Rules (CHR) \cite{Fru98,FA03,Fru08} is a
concurrent, committed-choice language which was initially designed for writing
constraint solvers and which is nowadays a general purpose language. A CHR program is a (finite) set of guarded rules, which
allow to transform multisets of atomic formulas (constraints) into simpler ones.


There exists a very  large body of literature on
CHR, ranging from theoretical aspects to implementations and
applications. However,
only few papers, notably  \cite{FH03,Fru04,SSD05b,TMG07,Tac08,SS09}, consider  source to source transformation of CHR programs. This is not surprising,
since program transformation is in general very difficult for
(logic) concurrent languages and in case of CHR it is even more
complicated, as we discuss later.  Nevertheless, the study of this technique
for concurrent languages and for CHR in particular, is important
as it could lead to significant improvements in the run-time efficiency and space-consumption of programs.

Essentially, a source to source transformation consists of a sequence
of syntactic program manipulations which preserves some kind of semantics. A basic manipulation is {\em unfolding}, which consists in the replacement
of a procedure call by its definition. While this operation can be
performed rather easily for sequential languages, and indeed  in
the field of logic programming it was first investigated by Tamaki
and Sato more than twenty years ago \cite{TS84}, when considering
logic concurrent languages it becomes quite difficult to define
reasonable conditions which ensure its correctness.
\comment{In the case of CHR this is mainly
due to three problems. The first one is the presence of guards in the rules.
Intuitively, when
unfolding a rule  by using a rule  (i.e. when replacing in
the body of  a ``call'' of a procedure by its definition )
it could happen that some guard in  is not satisfied
``statically'' (i.e. when performing the unfold), even though it
could become satisfied later when the unfolded rule is actually
used. If we move the guard of  in the unfolded version of 
we can then loose some computations (because the guard is
anticipated). This means that if we want to preserve the meaning
of a program in general we cannot replace the rule  by its unfolded
version. Suitable conditions can be defined in order to allow such a replacement, as we do later.
The second source of difficulties consists in the pattern matching
mechanism which is used by the CHR computation. According to this mechanism, when rewriting a goal  by a rule  only the variables in the head of  can be instantiated (to become equal to the terms in ).  Hence, it could happen that statically the body of a rule  is not instantiated enough to perform the pattern matching involved in the unfolding,  while it could become instantiated later in the computations. Also in this case replacing  by its unfolded version in general is not correct. Finally, we have the problem of the multiple heads.
In fact, let  be the body of a rule  and let  be the (multiple)
head of a rule , which can be used to unfold : we cannot be sure
that at run-time all the atoms in  will be used to rewrite ,
since in general  could be in a conjunction with other atoms even
though the guards are satisfied. This technical point, that one can legitimately find
obscure now, will be further clarified in Section~\ref{sec:safty-rule-deletion}.}



In this paper, we first define an unfolding rule for CHR programs
and show that it preserves the semantics of the program in terms
of qualified answers \comment{, a notion already defined in the literature}
\cite{Fru98}.
Next, we provide a syntactic condition which allows one to replace in a
program a rule by its unfolded version while preserving
qualified answers.  This condition preserves also termination, provided that one considers normal derivations.
We also show that a more restricted condition ensures
that confluence is preserved.
Finally, we give a weaker condition for replacing a rule by its unfolded version:
This condition allows to preserve the qualified answers for a specific class of programs (those which are normally terminating and confluent).

Even though the idea of the unfolding is
straightforward, its technical development is complicated by the
presence of guards, multiple heads, and matching substitution,
as previously mentioned. In
particular, it is not obvious to identify conditions which
allow to replace the original rule by its unfolded version.
Moreover, a further reason of complication comes from the fact
that we consider as reference semantics the one
defined in \cite{DSGH04} and called , which avoids trivial non-termination by
using a  ``token store'' (or history). The token store
idea was originally introduced by \cite{Abd97} but the shape of these
tokens is different from that of those used  in \cite{DSGH04}. Due
to the presence of this token store,  in order to define correctly
the unfolding we have to slightly modify the syntax of CHR programs
by adding to each rule  a local token store. The resulting programs
are called annotated and we define their semantics by providing a
(slightly) modified version of the semantics , which is
proven to preserve the qualified answers.

The remainder of this paper is organized as follows. Section~\ref{sec:notation}
introduces the CHR syntax while the operational semantics 
\cite{DSGH04} and the modified one   are given in
Section~\ref{sec:semantics}. Section~\ref{sec:unfolding} defines
the unfolding rule (without replacement) and proves its correctness.
Section~\ref{sec:safty-rule-deletion}  discuss the problems
related to the replacement of a rule by its unfolded version and provides a correctness condition for such a replacement.
In this section, we also prove that (normal) termination and
confluence are preserved by the replacement which satisfies this condition. A further, weaker, condition ensuring the correctness of replacement for (normally) terminating and confluent programs is given in Section~\ref{sec:normally -rep}. Finally, Section~\ref{sec:conclusion_and_future} concludes
by discussing some related works. Some of the proofs are deferred to the Appendix in order to improve the readability of the paper.


A preliminary version of this paper appeared in \cite{TMG07}, some results were contained in the thesis  \cite{Tac08}.



\section{Preliminaries}\label{sec:notation}

In this section, we introduce the syntax of CHR and some notations
and definitions we will need in the paper. For our purpose, a {\em constraint} is simply defined as an atom
, where  is some predicate symbol of arity  and
 is an -tuple of terms.
A {\em term} is (inductively) defined as a variable , or as , where  is a function symbol of arity  and
 are terms.  is the set of all terms.

We use the following notation: let  be any syntactic object and let  be a set of variables.
 denotes the
existential closure of  w.r.t. the variables in , while  denotes the existential closure of  with the exception of the variables in  which remain unquantified.  denotes the free variables appearing in .


We use ``,'' rather than  to denote conjunction
and we will often consider a conjunction of atomic constraints as
a multiset of atomic constraints.
We use  for sequence concatenation,  for empty sequence,  for set difference operator and  for multiset union. We shall sometimes treat multisets as sequences (or vice versa), in which case we nondeterministically choose an order for the objects in the multiset. We use the notation
 as a shorthand for the (conjunction of) constraints
. Similarly if  and  are sequences of equal length then  is a shorthand for .

A substitution is a mapping  such that the set  (domain of ) is finite;
 is the empty substitution: .
\comment{If  is a substitution and  is a syntactic expression we denote by
 the restriction of 
to the variables in .}

The composition  of the substitutions 
and  is defined as the functional composition. A substitution
 is idempotent if
.
A renaming is a (nonidempotent) substitution  for which there exists the inverse 
such that  =  =.
\comment{The preordering  (more general than) on substitutions is
such that  iff there exists a 
such that  = .
The result of the
application of the substitution  to an expression  is an
{\em instance} of  denoted by . We define  ( is more general than ) iff there exists a 
such that  = .}
\comment{A substitution  is a
grounding for  if  is ground and  denotes the set of ground instances of .}


We restrict our attention to idempotent substitutions, unless explicitly stated otherwise.



Constraints can be divided into either {\em user-defined} (or CHR) constraints or {\em built-in} constraints on some constraint domain . The built-in constraints are handled by an existing solver and we assume
given a (first order) theory  which describes their meaning.
We assume also that the built-in constraints contain the predicate  which is described,
as usual, by the Clark Equality Theory \cite{Llo84} and the values
\texttt{true} and \texttt{false} with their obvious meaning.



We use  to denote built-in constraints,  to denote CHR
constraints, and  to denote both built-in and user-defined
constraints (we will call these generically constraints). The capital
versions will be used to denote multisets
(or sequences) of constraints.



\subsection{CHR syntax}\label{sec:syntax}
As shown by the following definition \cite{Fru98}, a  \emph{CHR program}
consists of a set of rules which can be divided into three types:
\emph{simplification}, \emph{propagation}, and \emph{simpagation}
rules. The first kind of rules is used to rewrite
CHR constraints into simpler ones, while second kind allows to add new redundant
constraints which may cause further simplification. Simpagation rules allow to represent both simplification and propagation rules.

\begin{definition}[{\sc CHR Syntax}]
A CHR program is a finite set of CHR rules.
There are three kinds of CHR rules:

\noindent{A \textbf{simplification} rule has the form: }\\
\noindent{A \textbf{propagation} rule has the form:
}\\
\noindent{A \textbf{simpagation} rule has the form:
}
\noindent where  is a unique identifier of a rule, ,
 and  are sequences of user-defined constraints, with   and
 different from the empty sequence,  is a possibly empty conjunction of built-in constraints,
and  is a possibly empty sequence of (built-in and
user-defined) constraints.  (or ) is called
\emph{head},  is called \emph{guard} and  is called \emph{body} of the rule.
\end{definition}

A  \emph{simpagation} rule can simulate both simplification and
propagation rule by considering, respectively, either  or
 empty. In the following, we
will consider in the formal treatment only simpagation rules.

\subsection{CHR Annotated syntax}\label{sec:annsyntax}

When considering unfolding we need to consider a slightly
different syntax,  where rule identifiers are not necessarily
unique, each atom in the body is associated with an identifier,
that is unique in the rule, and
where each rule is associated  with a local token store .
More precisely, we define an identified CHR constraint  (or
identified atom)  as a CHR constraint  associated with
an integer  which allows to distinguish different copies of the
same constraint.

Moreover, let us define a token as an object of the form , where 
is the name of a rule and  is a sequence of distinct identifiers.
\comment{(namely, the sequence of identifiers associated with the constraints to which the
head of the rule  is applied).}
A token store (or history) is a set of tokens.



\begin{definition}[{\sc CHR Annotated syntax}]
An {\em annotated} rule has then the form:
 where 
is an identifier,  and  are
sequences of user-defined constraints with
 different from the empty sequence,  is a possibly empty conjunction of built-in constraints,
 is a possibly empty sequence of built-in and identified CHR constraints
such that different (occurrences of) CHR constraints have different identifiers,
and  is a token store.
 is called
\emph{head},  is called \emph{guard},  is called \emph{body} and
 is called \emph{local token store} of the annotated rule.
An annotated CHR program is a finite set of annotated CHR rules.

\end{definition}



We will also use the following two functions: {\em chr(hi)= h} and the overloaded
function {\em id(hi)= i}, (and ),
extended to sets and sequences of identified CHR constraints (or tokens) in
the obvious way. An (identified) CHR {\em goal} is a multi-set of
both (identified) user-defined and built-in constraints.
 is the set of all (possibly
identified) goals.


Intuitively, identifiers are used to distinguish different
occurrences of the same atom in a rule or in a goal. The identified atoms can
be obtained by using a suitable function which associates a
(unique) integer to each atom. More precisely, let  be a goal
which contains  CHR-constraints. We assume that the function
 identifies each CHR constraint in  by
associating to it a unique integer in  according to the
lexicographic order.

The token store allows one to memorize  some tokens,
where each token describes which propagation rule has been used
for reducing which identified atoms.
As we discuss
in the next section, the use of this information was originally proposed
in \cite{Abd97} and then further elaborated in the semantics defined
in \cite{DSGH04} in order to avoid trivial  non-termination
arising from the repeated application of the same propagation rule
to the same constraints. Here, we simply incorporate this
information in the syntax, since we will need to manipulate it in
our unfolding rule.

Given a CHR program , by using the function  and
an initially empty local token store we can construct its annotated
version as the next definition explains.


\begin{definition}
Let  be a CHR program. Then its annotated version is defined as follows:

\end{definition}


\noindent {\bf Notation} \\
In the following examples, given a
(possibly annotated) rule
   we write it as
 if  is empty and
we write it as
 if  is empty.
That is, we maintain also the notation previously introduced for
simplification and propagation rules. Moreover, if , then  is omitted
and if in an annotated rule the token store is empty we
simply  omit it.
Sometimes, in order to simplify the notation, if in an annotated program  there are no annotated propagation rules, then we write  by using the standard syntax.\\


Finally, we will use  to denote (possibly annotated) rules
and
 to denote (possibly annotated) rules with identifier .


\begin{example}\label{chiara}
The following CHR program, given a forest of finite trees
(defined in terms of the predicates  and , with the obvious meaning), is
able to recognize if two nodes belong to the same tree and if so returns the root.

The program  consists of the following five rules



Then its annotated version  is defined as follows:


\comment{

Then its annotated version  is defined as follows:
}
\end{example}







\section{CHR operational semantics}\label{sec:semantics}

This section first introduces the reference semantics  \cite{DSGH04}. For the sake of simplicity, we omit indexing the relation with the name of the program.

Next, we define a slightly different operational  semantics,
called , which considers annotated programs and which
will be used to prove the correctness of our unfolding rules (via some form of
equivalence between   and ).

In the following, given a (possibly annotated) rule

we denote by  the existential quantification
. By an abuse of notation, when it is clear from the context, we will write
 instead of .

\subsection{The semantics }

\begin{table*}[tbp]
\caption{The transition system  for the  semantics}
\centering
\label{omega-t}

\begin{tabular}{lll}
\hline\noalign{\smallskip}
&\mbox{   }&\mbox{   }
\\
\mbox{\bf Solve} &  



&\mbox{ }
\\
&\mbox{   }&\mbox{   }
\\

\mbox{\bf Introduce}&  &\mbox{ }
\\
&\mbox{   }&\mbox{   }
\\

\mbox{\bf Apply}& &\mbox{ }
\\
&\mbox{   }&\mbox{   }
\\
&\mbox{where }
  
\mbox{ and } &\mbox{
}
\\
&\mbox{   }&\mbox{   }
\\
\noalign{\smallskip}\hline
\end{tabular}
\end{table*}


We describe the operational semantics , introduced in {\cite{DSGH04}, by using a transition system
 Configurations in  are
tuples of the form  where , the {\em goal store} is a multiset of constraints. The \emph{CHR constraint store}  is a set of
identified CHR constraints. The \emph{built-in constraint store}  is a
conjunction of built-in constraints. The {\em propagation history}
 is a token store and  is an integer.
Throughout this paper, we use the symbols  to represent configurations in .

The \emph{goal store} () contains all constraints to
be executed. The \emph{CHR constraint store} () is the set\footnote{Note that sometimes we treat  as a multiset. This is the case, for example, of the transition rules, where considering  as a multiset simplifies the notation.} of
identified CHR constraints that can be matched with the head of the
rules in the program . The \emph{built-in constraint store} () contains any built-in  constraint that has been passed to the built-in constraint solver. Since we will usually have no information about the
internal representation of , we treat it as a conjunction of constraints. The {\em propagation history}
() describes which rule has been used
for reducing which identified atoms. Finally, the \emph{counter}  represents the next
free integer which can be used to number a CHR constraint.


\comment{We describe the operational semantics , introduced in \cite{DSGH04}, by using a transition system
 Configurations in  are
tuples of the form  with the
following meaning. The \emph{goal store}  is a multiset (repeats are allowed) of constraints to
be evaluated. The \emph{CHR constraint store}  is the set of
identified CHR constraints that can be matched with the head of the
rules in the program . The \emph{built-in constraint store}  is a
conjunction of built-in constraints. The {\em propagation history}
 is a token store. Finally, the \emph{counter}  represents the next
free integer which can be used to number a CHR constraint.}


Given a goal , the  {\em initial configuration} has the form

A {\em final configuration} has either the form , when it is {\em failed}, or it
has the form  (with ) when it
represents a successful termination (since there are no more
applicable rules).


The relation  (of the transition system
) is defined  by the rules
in Table~\ref{omega-t}: the \textbf{Solve} rule moves a
built-in constraint from the goal store to the built-in constraint
store; the \textbf{Introduce} rule identifies and moves a CHR (or user-defined) constraint from the goal store to the CHR constraint
store;  the \textbf{Apply} rule chooses a program rule  and fires it, provided that the following conditions are satisfied: there exists a matching between the constraints in the CHR store and the ones in
the head of ; the guard of  is
entailed by the built-in constraint store (taking into account also the
matching mentioned before); the token that would be added by \textbf{Apply}}
to the token store is not already
present. After the application of ,
the constraints which match with the right hand side of the head
of  are deleted from the CHR constraint store, the body of  is added to
the goal store and the guard of , together with the equality representing the matching, is added to the built-in constraint store.
The \textbf{Apply} rule assumes that all
the variables appearing in a program clause are renamed with fresh ones in order to
avoid variable names clashes.

From the rules, it is clear that when not considering
tokens (as in the original semantics of \cite{Fru98}) if a propagation rule can be
applied once  then it can be applied infinitely many times, thus
producing an infinite computation (no fairness assumptions are
made here). Such a trivial non-termination is avoided by tokens, since they ensure that
if a propagation rule is used to reduce a sequence of constraints
then the same rule has not been used before on the same
sequence of constraints.


\subsection{The modified semantics }
We now define the semantics  which considers annotated rules.
This semantics differs from  in two aspects.

First, in 
the goal store and the CHR store are fused in a unique generic \emph{store}, where
CHR constraints are immediately labeled. As a consequence, we do not
need  the {\bf Introduce} rule anymore and every CHR
constraint in the body of an applied rule is immediately
utilizable for rewriting.

The second difference concerns the shape of the rules. In fact,
each annotated rule  has  a local token store (which can be
empty) that is associated with it and which is used to keep track of
the propagation rules that are used to unfold the body of .
Note also that here, differently from the case of the propagation
history in , the token store associated with a computation can be updated
by adding multiple tokens at once (because an unfolded rule with many
tokens in its local token store has been used).

In order to define   formally,
we need a function   which updates
the formal identifiers of a rule to the actual computation ones. Such a function 
is defined as follows.

\begin{definition}\label{definst}
 Let  be the set of all possible token
sets and let  be the set of natural numbers. We denote
by  the function such that
), where
\begin{itemize}
    \item  is an identified CHR goal,
    \item  is obtained from  by
    incrementing each identifier in  with  and
    \item  is the greatest identifier in .
\end{itemize}
\end{definition}

We describe now the operational semantics   for annotated CHR
programs by using, as usual, a transition system
 Configurations in
 are tuples of the form  with the following meaning.   is the set\footnote{Also in this case, sometimes we treat  as a multiset. See the previous footnote.} of
identified CHR constraints that can be matched with rules in the
program  and built-in constraints. The built-in constraint
store  is a conjunction of built-in constraints and  is a
set of tokens, while the counter  represents the last integer
which was used to number the CHR constraints in .


Given a goal , the  {\em initial configuration} has the form

where  is the number of CHR constraints in  and  is the function which associates the identifiers with the CHR constraints in .
A {\em failed
configuration} has the form .


A {\em final
configuration} either is failed or it has the form  (with ) when it represents a successful
termination, since there are no more applicable rules.

The relation  (of the transition system ) is defined  by the rules in
Table~\ref{tab:operational-semantics} which have the following explanation:
\begin{description}
\item[\textbf{Solve'}]{moves a built-in constraint from the store to the
built-in constraint store;}

\item[\textbf{Apply'}] {fires  a rule  of the form  provided that the following conditions are satisfied: there exists a matching between the constraints in the store and the ones in
the head of ; the guard of  is
entailed by the built-in constraint store (taking into account also the
matching mentioned before); . These conditions are equal to those already seen for {\bf Apply}. Moreover, analogously to the {\bf Apply} transition step,
 together with  are added to the built-in constraint
store.
However, in this case, when the rule  is fired,  is replaced by  and the local store  is added to  (with ), where each identifier
is suitably incremented by the  function.  Finally, the subscript  is replaced by , that is
the greatest number used during the computation step.

As for the \textbf{Apply} rule, the  \textbf{Apply'} rule assumes that all
the variables appearing in a program clause are renamed with fresh ones in order to
avoid variable names clashes.

}
\end{description}

\begin{table*}[t]
\caption{The transition system  for the  semantics}
\centering
\label{tab:operational-semantics}

\end{table*}

The following example shows a derivation obtained by the new transition
system.

\begin{example}\label{chiara1}
Given the goal  in the following program ,
\begin{small}

\end{small}
\vspace*{0.2cm}
we obtain the following derivation \comment{, where we simplify the built-in store,}\\
\begin{small}

\vspace*{0.2cm}\\

\vspace*{0.2cm}\\

\vspace*{0.2cm}\\

\vspace*{0.2cm}\\

\vspace*{0.2cm}\\

\vspace*{0.2cm}\\

\vspace*{0.2cm}\\

\vspace*{0.2cm}\\

\end{small}
\end{example}

From the previous transition systems we can obtain a notion
of observable property of CHR computations that will be used in order
to prove the correctness of our unfolding rule.
The notion of "observable property" usually identifies the relevant property that one is interested in
observing as the result of a computation. In our case, we use the notion of qualified answer,
originally introduced in \cite{Fru98}: Intuitively this is the constraint obtained as the result of a non-failed computation,
including both built-in constraints and CHR constraints which have not been "solved" (i.e. transformed
by rule applications into built-in constraints).
Formally qualified answer are defined as follows.


\begin{definition}[{\sc Qualified answers}]  Let  be a CHR program and let
 be a goal. The set  of
qualified answers for the query  in the program  is defined
as follows:

\end{definition}

Analogously, we can define the qualified answer of an annotated
program.

\begin{definition}[{\sc Qualified answers for annotated programs}]
Let  be an annotated CHR program and let  be a goal. The set  of qualified answers
for the query  in the annotated program  is defined as follows:

\end{definition}


The previous two notions of qualified answers are equivalent,
as shown by the proof (in the Appendix) of the following proposition.
This fact will be used to prove the correctness of the unfolding.

\begin{proposition}\label{prop:nequality}
Let  and  be respectively a CHR program and its annotated version.
Then, for every goal ,

holds.
\end{proposition}

\section{The unfolding rule}\label{sec:unfolding}


In this section, we define the \emph{unfold operation} for CHR
simpagation rules. As a particular case, we obtain also
unfolding for  simplification and propagation rules, as these can
be seen as particular cases of the former.

The unfolding allows to replace  a  conjunction  of constraints
(which can be seen as a procedure call) in the body of a rule 
by the body of a rule  ,  provided that the head of  matches
with  (when considering also the instantiations provided by the built-in constraints in
the guard and in the body of the rule ). More precisely, assume that
the built-in constraints in the guard and in the body
of the rule  imply that the head  of ,
instantiated by a substitution , matches with the
conjunction  in the body of  . Then, the unfolded rule is
obtained from  by performing the following steps:  1) the new
guard in the unfolded rule is the conjunction of the guard of 
with the guard of , the latter instantiated by  and
without  those constraints that are entailed by the built-in
constraints which are in
; 2) the body of  and the equality
 are added to the body of ; 3) the conjunction of constraints  can
be removed, partially removed or left in the body of  the unfolded
rule, depending on the fact that  is a simplification, a
simpagation or a propagation rule, respectively; 4) as for the
local token store   associated with every rule , this is
updated consistently during the unfolding operations in order to
avoid that a propagation rule is used twice to unfold the same
sequence of constraints.

Before giving the formal definition of the unfolding rule, we illustrate the above steps by means of the following example.


\begin{example}\label{ex:banca}
Consider the following program , similar to that one given in \cite{SS08}, which describes the rules for updating a bank account and for performing the money transfer. We write the program by using  the standard syntax, namely without using the local token store and the identifiers in the body of rules, since there are no annotated propagation rules. The program  consists of the following three rules
\begin{small}
\end{small}
where the three rules identified by , and  are called , and , respectively. The predicate names are abbreviations:  for balance,  for deposit,  for withdraw and  for
transfer.

Now, we unfold the rule  by using the  rule  and we  obtain the new clause :
\begin{small}
\end{small}
Next, we unfold the rule  by using the  rule  and we can obtain the new clause 
\begin{small}
\end{small}
\end{example}


Before formally defining the unfolding, we need to define a
function which removes the useless tokens from the token store.

\begin{definition}\label{def:clean}
Let  be an identified goal and let  be a token set,
 is defined as
follows:  deletes from  all the tokens for
which at least one identifier is not present in the identified
goal . More formally

\end{definition}

\begin{definition}[{\sc Unfold}]\label{def:unf}
Let  be an annotated CHR program  and let  be the two
following annotated rules

respectively, where  is the conjunction of all the built-in constraints in the body
of . Let   be a substitution such that  and
. Furthermore let
 be the greatest identifier which appears in the
rule  and let .
Then, the \emph{unfolded} rule is:
 where , ,
, , the
constraint  is satisfiable and
\begin{itemize}
    \item if  then 
    \item if  then .
    \end{itemize}
\end{definition}

Note that   is the greatest set of built-in constraints such that  for each . Moreover,  as shown in the following, all the results in the paper are independent from the choice of the substitution  which satisfies the conditions of Definition~\ref{def:unf}. Finally, we use  the function   (Definition~\ref{definst})
in order to increment the value of the
identifiers associated with atoms in the unfolded rule. This allows
us to distinguish the new identifiers introduced in the unfolded
rule from the old ones. Note also that the condition on the token
store is needed to obtain a correct rule.  Consider for example a ground annotated
program

where
the three rules identified by , and  are called , and , respectively\footnote{Here and in the following examples, we use an identifier and also a name for a rule. The reason for this is that after having performed an unfolding we could have different rules labeled by the same identifier. Moreover, we omit the token stores if they are empty.}. Let
 be  the start goal. In this case, the unfolding could change
the semantics if the token store was not used. In fact, according
to the semantics proposed in Table~\ref{omega-t} or
~\ref{tab:operational-semantics}, we have that the goal  has only the qualified answer
.
\comment{following
computation: .} On the other hand,  considering an
unfolding without the update of  the token store, one would have
cl_{r_2}cl_{r_2}cl_{r_3}.
So, starting from the constraint  we could obtain the qualified answer , that
is not possible in the original program (the rule obtained after
the wrongly applied unfolding rule is underlined).



As previously mentioned, the unfolding rules for simplification
and propagation can be obtained as particular cases of
Definition~\ref{def:unf}, by setting  and  , respectively, and by considering accordingly the
resulting unfolded rule.
\comment{In the following examples we will use
 to denote both   and .}



\begin{example}\label{ex:gen_adam}
Consider the program  consisting of the following four rules

that we call , , , and , respectively. This program
deduces information  about genealogy. Predicate  is considered as
father,  as grandfather,  as grandson and  as
great-grandfather. The following rules are such that we can unfold
some constraints in the body of  using the rule ,  , and .

Now, we  unfold the body of rule  by using the simplification rule
. We use the  function
.
So the new unfolded rule is:



Now, we unfold the body of  by using the propagation rule .
As in the previous case, we have that  and then
the new unfolded rule is:


Finally, we unfold the body of rule  by using the simpagation
rule . As before, the function
 is computed.
The new unfolded rule is:




\end{example}

The following example considers more specialized rules  with guards which are not .

\begin{example}\label{ex:gen_adam_refined}
Consider the program consisting of the following rules

that, as usual, we call , and , respectively, and which specialize the rules introduced in Example~\ref{ex:gen_adam}
to the genealogy of Adam. That is,  here we remember that Adam was father of Seth; Seth was father
of Enosh; Enosh was father of Kenan. As before, we consider the predicate  as father,
 as grandfather,  as grandson and  as great-grandfather.


\comment{If we unfold  by using ,
where we assume , we obtain:
}
If we unfold  by using  we have

Moreover, when   is considered to unfold , we obtain


Note that  , which is the guard of the rule
, is not
added to the guard of the unfolded rule  because  is
entailed by the guard of  and  is entailed
by the built-in constraints in the body of , by considering also the binding provided by the parameter passing (analogously for ).
\end{example}

\begin{example}\label{ex:chiara2}
The program  of the Example~\ref{chiara1} is obtained from the program  of Example~\ref{chiara} by adding to 
 the clauses resulting from the unfolding of the clause  with  and  and from the unfolding of the clause  with . It is worth noticing  that the use of the unfolded clauses allows to decrease the number of Apply tansition steps in the successful derivation.
\end{example}


The following result states the correctness of our unfolding rule. The proof is in the Appendix.

\begin{proposition}\label{prop:equality}
Let  be an annotated CHR program with
. Let   be the result
of the unfolding of  with respect to  and let  be the program
obtained from  by adding rule . Then, for every goal ,
 holds.
\end{proposition}

Since the previous result is independent from the choice of the particular substitution
 which satisfies the conditions of Definition~\ref{def:unf}, we can choose any such a substitution in order to define the unfolding.



Using the semantic equivalence of a CHR program and its annotated
version, we obtain  also the following corollary which shows the equivalence between a CHR program
and its annotated and unfolded version.

\begin{corollary}\label{prop:QAunf}
Let  and  be respectively a CHR program and its annotated version.
Moreover let  be CHR annotated rules such that
  is the result
of the unfolding of  with respect to  and .
Then, for every goal ,
.
\end{corollary}
\begin{proof}
The proof follows from
Proposition~\ref{prop:nequality}
and Proposition~\ref{prop:equality}.
\end{proof}




\section{Safe rule replacement}\label{sec:safty-rule-deletion}

The previous result shows that we can safely add to
a program  a rule resulting from the unfolding, while preserving the
semantics of  in terms of qualified answers.
However, when a rule  has been unfolded producing
the new rule , in some cases we would also like to replace  by  in ,
since this could improve the efficiency of the resulting program.
Performing such a replacement while preserving the semantics
is in general a very difficult task.

In the case of CHR this is mainly
due to three problems. The first one is the presence of guards in the rules.
Intuitively, when
unfolding a rule  by using a rule  (i.e. when replacing in
the body of  a ``call'' of a procedure by its definition )
it could happen that some guard in  is not satisfied
``statically'' (i.e. when performing the unfold), even though it
could become satisfied at run-time when the  rule  is actually
used. If we move the guard of  in the unfolded version of 
we can then loose some computations, because the guard 
in  is moved before the atoms in the body of  (and those atoms could 
instantiate and satisfy the guard). In other words, the overall guard in the unfolded rule has been strengthened, which 
means that the rule applies in fewer cases. This implies that if we want to preserve the meaning
of a program in general we cannot replace the rule  by its unfolded
version. Suitable conditions can be defined in order to allows such a replacement, as we do later.
The second source of difficulties consists in the pattern matching
mechanism which is used by the CHR computation. According to this mechanism, when rewriting a goal  by a rule  only the variables in the head of  can be instantiated (to become equal to the terms in ).  Hence, it could happen that statically the body of a rule  is not instantiated enough to perform the pattern matching involved in the unfolding,  while it could become instantiated at run-time in the computations. Also in this case replacing  by its unfolded version in general is not correct. 
Note that this is not a special case of the first issue, indeed if we cannot (statically) perform the pattern matching we do not unfold the rule  
while if we move the pattern matching to the guard we could still unfold the rule (under suitable conditions).

Finally, we have the problem of the multiple heads.
In fact, let  be the body of a rule  and let  be the (multiple)
head of a rule , which can be used to unfold : we cannot be sure
that at run-time all the atoms in  will be used to rewrite ,
since in general  could be in a conjunction with other atoms even
though the guards are satisfied. 	\comment{This technical point, that one can legitimately find
obscure now, will be further clarified in Section~\ref{sec:safty-rule-deletion}.}
Note that the last point does not mean that the answers of the transformed program are a subset of those of the original one, since by deleting some computations we could introduce in the transformed program new qualified answers which were not in the original program. 
This is a peculiarity of CHR and it is different from what happens in Prolog.


The next
subsection clarifies these three points by using some examples.

\subsection{Replacement problems}

As previously mentioned, the first problem in replacing a rule by its unfolded version concerns the anticipation of
the guard of the rule  (used to unfold the rule ) in the guard of 
(as we do in the unfold operation). In fact, as shown by the following example, this could lead to the loss of some
computations,  when the unfolded rule   is used rather than the
original rule .

\begin{example}\label{esempio:mau}
Let us consider the program

where we do not consider the identifiers (and the local token store) in
the body of rules, because we do not have propagation rules in
.

The unfolding  of   by using the rule  returns the new
rule . Now the
program

is not semantically equivalent to  in terms of qualified
answers. In fact, given the goal  we have , while 
\end{example}


The second problem is related to the pattern matching used in CHR computations. In fact,
following Definition~\ref{def:unf}, there are some matchings that could become
possible only at run-time, and not at compile time, because a stronger (as a first order formula)
built-in constraint store is needed. Also in this case, a rule elimination could lead to lose
possible answers as illustrated in the following example.

\begin{example}\label{ex:matching}
Let us consider the program

where, as before, we do not consider the identifiers and the token store in the
body of rules, because we do not have propagation rules in .
Let  be the program where the unfolded rule
, obtained by using  in ,
substitutes the original one (note that other unfoldings are not possible, in
particular the rule  can  not be used to unfold )

Let  be a goal. We can see that
 and   because,
with the considered goal (and consequently
the considered built-in constraint store)  can fire in  but can not fire in
.





The third problem is related to multiple heads. In fact, the
unfolding that we have defined  assumes that the head of a rule
matches completely with the body of another one, while in general,
during a CHR computation, a rule can match with constraints
produced by more than one rule and/or  introduced by the initial
goal. The following example illustrates this point.

\begin{example}\label{ex:unicatesta}
Let us consider the program

where we do not consider the identifiers and the token store in
the body of rules, as usual.

The unfolding  of  by using   returns the new
rule
 Now the program

where we substitute the original rule by its  unfolded version is
not semantically equivalent to . In fact, given the goal , we have that  , while 
\end{example}



\end{example}

\subsection{A condition for safe rule replacement}

We have identified some conditions which ensure that we can safely replace the
original rule  by its unfolded version while maintaining the
qualified answers semantics. Intuitively, this holds when: 1)  the
constraints of the body of   can
 be rewritten only by CHR rules such that all the atoms in the head contain the same set of variables;
2) there exists no rule  which can be fired by using
a part of constraints introduced in the body of  plus some
other constraints; 3) all the rules that can be applied at run-time to the body of the original rule , can also be applied at
transformation time.
Before defining formally these conditions, we need some further
notations. First of all, given a rule  we define
two sets.

The first one contains a set of pairs: for each pair the first
component is a rule that can be used to unfold , while the second one is the
sequence of the identifiers of the atoms in the body of  which
are used in the unfolding.

The second set contains all the rules that can be used for the
{\em partial unfolding} of ; in other words, it is the set of rules that can fire by
using at least an atom in the body of  and necessarily
some other CHR and built-in constraints. Moreover, such a set contains
also the rules that can fire, when an opportune built-in constraint
store is provided by the computation, but that cannot be unfolded.



\begin{definition}\label{def:Pposeneg}

Let  be an annotated CHR program and let  be the following two annotated rules

such that  and   is renamed
apart with respect to . We define  and  as follows:
\begin{enumerate}
    \item\label{uno}  
 if and only if
 can be
unfolded with  (by Definition~\ref{def:unf}) by using the sequence
of the identified atoms in  with identifiers .
    \item\label{due}  if and only if at least one of the
following conditions holds: \\
\begin{enumerate}
\item\label{ai} there exists  and
     a built-in constraint  such that
    , the constraint
     is satisfiable,
    , , and   \\
\item\label{bi} or there exist ,
     and
     a built-in constraint  such that
, the constraint
     is satisfiable,
    , and there exists no  such that
 and
.
\\
\end{enumerate}
\end{enumerate}
\end{definition}
Some explanations are in order here.

The set  contains all the couples composed by those rules that can be used to unfold a
fixed rule , and the identifiers of the constraints considered in the unfolding,
introduced in Definition~\ref{def:unf}.

Let us consider now the set .
The conjunction of built-in constraints 
represents a generic set of built-in constraints
(such a set naturally can be equal to every possible built-in constraint store that can
be generated by a real computation before the application of rule ); the
condition 
is required to avoid free variable capture,
it represents the renaming (with fresh variables) of a rule  with respect to the computation
before the use of the  itself in an \textbf{Apply'} transition;
the condition  avoids trivial non-termination due the propagation rules;
the conditions  and
 secure that a strong enough built-in constraint
is provided by the computation, before the application of rule ;
finally, the condition
 is required
to avoid to consider the rules that can be correctly unfolded in the body of .
There are two kinds of rules that are added to .
The first one, due to Condition~\ref{ai} in Definition~\ref{def:Pposeneg},
indicates a matching substitution problem similar to that one described  in Example~\ref{ex:matching}. The second kind, due to Condition~\ref{bi} in Definition~\ref{def:Pposeneg}, indicates a multiple
heads problem similar to that one in Example~\ref{ex:unicatesta}.
Hence, as we will see in Definition~\ref{def:nsafedel}, in
order to be able to correctly perform the unfolding, the set  must be empty.

Note also that if  contains a pair, whose first component is
a rule with a multiple head and such that the atoms in the head contain different sets of variables, then by definition,
 (Condition~\ref{bi} of Definition~\ref{def:Pposeneg}).


The following definition introduces a notation for the set obtained by unfolding a rule with (the rules in) a program.

\begin{definition}
Let  be an annotated CHR program and assume that
,
 is the set of all annotated rules obtained by unfolding
the rule  with a rule in , by using Definition~\ref{def:unf}.
\end{definition}

We can now give the central definition of this section.

\begin{definition}[{\sc Safe rule replacement}]\label{def:nsafedel}
Let  be an annotated CHR program and let  be the annotated rule , such that the following
holds
\begin{enumerate}
\item[i)] ,
\item[ii)]   and
\item[iii)] for each

we have that
.
\end{enumerate}
Then, we say that the rule 
can be safely replaced (by its unfolded version) in .
\end{definition}


Condition  of the previous definition implies that
 can be
safely replaced in  only if:
\begin{itemize}
\item  contains only pairs, whose 
first component is a rule such that each atom in the head contains the same set of variables;

\item  a sequence of identified atoms of
body of the rule  can be used to fire a rule 
only if  can be unfolded with   by using the same sequence
of the identified atoms.
\end{itemize}

Condition {\bf ii)} states that there exists at least one rule for unfolding
the rule .

Condition {\bf iii)}  states that each annotated rule obtained by the
unfolding of  in  must have a guard equivalent to that one of : in fact
the condition   in {\bf iii)} avoids the
problems discussed in Example~\ref{esempio:mau}, thus allows the moving (i.e. strengthening)
of the guard in the unfolded rule.

Note that Definition~\ref{def:nsafedel} is independent from the particular substitution  chosen in Definition~\ref{def:unf} in order to define the unfolding of the rule

In fact, let us assume that there exist two substitution  and  which satisfy the conditions of Definition~\ref{def:unf}.
Then  for each .
Therefore, if  and
, we have that  and then
.
Now, it is easy to check that Condition {\bf iii)} follows if and only if .


The following is an example of a safe replacement.
\begin{example}\label{ex:safe1}
Consider the program  consisting of the following four rules

where the four rules identified by , and  are called , and , respectively.
By Definition \ref{def:Pposeneg}, we have that


Moreover


Then   can be safely replaced in  according to Definition~\ref{def:nsafedel} and then we obtain

where  is the program

\end{example}


We can now provide the result which shows the correctness of our safe replacement rule. The proof is in the Appendix.

\begin{theorem}\label{theo:n1completeness}
Let  be an annotated program,   be a rule in  such that
 can be safely replaced
in  according to Definition~\ref{def:nsafedel}. Assume also that


Then  for any arbitrary
goal .
\end{theorem}


Of course, the previous result can be applied to a sequence of program transformations.
Let us define such a sequence as follows.

\begin{definition}[{\sc U-sequence}]\label{def:uno}
Let  be an annotated CHR program. An \emph{U-sequence} of programs
starting from  is a sequence of annotated CHR programs , such that

 where ,  and can be safely replaced in .
\end{definition}

\begin{example}\label{ex:safe2}
Let us to consider the program  of Example~\ref{ex:safe1}. The clause  can be safely replaced in  according to Definition~\ref{def:nsafedel} and then we obtain

where  is the program


\end{example}

Then, from  Theorem~\ref{theo:n1completeness} and
Proposition~\ref{prop:nequality}, we have the
following.

\begin{corollary}\label{lemma:ncompleteness}
Let  be a program and let  be an U-sequence starting from . Then
 for any arbitrary goal
.
\end{corollary}

\subsection{Confluence and Termination}\label{sec:confluence&termination}

In this section, we prove that our unfolding preserves termination
provided that one considers normal derivations. These
are the derivations in which the  \textbf{Solve} (\textbf{Solve'})
transitions are applied as soon as possible, as specified by Definition~\ref{def:ND}.
Moreover, we prove that our unfolding preserves also confluence, provided that one considers only non-recursive unfoldings.

We first need to introduce the concept of built-in
free configuration: This is a configuration which has no built-in constraints in the first component. \comment{or has an unsatisfiable built-in store.}

\begin{definition}[{\sc Built-in free configuration}]\label{def:BFS}
Let   ().
The configuration  is built-in free  if
 is a multiset of (identified) CHR-constraints.
\end{definition}

Now, we can introduce the concept of normal derivation.

\begin{definition}[{\sc Normal derivation}]\label{def:ND}
Let   be a (possibly annotated) CHR program  and let
 be a derivation in .
We say that  is normal if, for each configuration   in , a transition
\textbf{Apply} (\textbf{Apply'})
is used on  only if  is built-in free.
\end{definition}


Note that, by definition, given a CHR program ,  can be calculated by considering only normal derivations and analogously for an annotated CHR program .

\begin{definition}[{\sc Normal Termination}]
A CHR program  is called \emph{terminating}, if there are no infinite derivations.
A (possibly annotated) CHR program  is called  \emph{normally terminating}, if there are no infinite normal derivations.
\end{definition}

The following result shows that normal termination is preserved by unfolding with the safe replacement condition. The proof is in the Appendix.


\begin{proposition}[{\sc Normal Termination}]\label{prop:termination} Let  be a CHR program and
let  be an U-sequence starting from .  satisfies
normal termination if and only if   satisfies normal termination.
\end{proposition}

When standard termination is considered  rather than  normal termination,
the previous result does not hold, due to  the guard elimination in the unfolding. This is shown by the following example.

\begin{example}\label{ex:termination-problem}
Let us consider the following program:

where we do not consider the identifiers and the token store in the
body of rules (because we do not have propagation rules in ).
Then, by using  to unfold  (with replacement) we obtain the following program :

It is easy to check that the program  satisfies the (standard) termination.
On the other hand, considering the program  and the start goal , the following state can be reached

where rules  and  can be applied infinitely many times if the built-in constraint  is not moved by the \textbf{Solve'} rule into the built-in store. Hence, we have non-termination.\end{example}

The  next property we consider is confluence. This property guarantees that any computation for a goal
results in the same final state, no matter which of the applicable
rules are applied \cite{AF04,Fru04}.



We first give the following definition which introduces some specific notation for renamings of indexes.


\begin{definition}\label{def:renaming}
Let  be distinct identification values.
\begin{itemize}
  \item A renaming of identifiers is a
substitution of the form , where   is a permutation of .
  \item Given an expression  and a renaming of identifiers , 
  is defined as the expression obtained from  by
substituting each occurrence of the identification value 
with the corresponding , for 
  \item If  and  are renamings of identifiers, then  denotes the renaming of identifiers such that for each expression , .
\end{itemize}
 We will use  to denote renamings.
\end{definition}

Now, we need the
following definition introducing a form of equivalence between configurations, which is a slight modification of that one in \cite{RBF09},
since considers a different form of configuration  and, in particular, also the presence of the token store.
Two configurations are equivalent if they have the same logical reading and the same rules are applicable to these configurations with the same results. By an abuse of notation, when it is clear from the context, we will write  to denote two equivalence relations in
 and in  with the same meaning.


\begin{definition}\label{def:naltraeq}
Let  be a set of variables
The equivalence  between configurations in   is the smallest equivalence relation  that satisfies the following conditions.

\begin{itemize}
\item ,

\item ,

\item Let  be variables such that  and  does not occur in  or .
,

\item If , , and
 then
,

\item ,

\item 
for each renaming of identifiers  such that for each  we have that ,


\item
.
 \end{itemize}

\end{definition}


We can define the equivalence  between configurations in  in an analogous way.
\begin{definition}\label{def:n1altraeq}
Let  be a set of variables
The equivalence  between configurations in  is the smallest equivalence relation  that satisfies the following conditions.

\begin{itemize}
\item ,

\item ,

\item Let  be variables such that  and  does not occur in  or .
,

\item If , , and
 then
,

\item ,

\item 
for each renaming of identifiers  such that for each 
we have that ,

\item
.
 \end{itemize}
\end{definition}

By definition of , it is straightforward to check that
if ,  is a set of variables, and  then the following holds
\begin{itemize}
\item if  then  and
\item if  then .
\end{itemize}
\comment{\begin{definition}\label{def:vecchiaaltraeq}
Let
\langle G,   S,c, T\rangle_{n} and let  be a set of variables.  if at least one of the following holds:
\begin{itemize}
  \item  and  are both failed configurations;
  \item  and  are identical up to renaming of variables not in  and of identifiers, up to logical equivalence of built-in constraints and up to cleaning of the token store (that is, up to deleting from the token store all the tokens for
which at least one identifier is not present in the set of
identified CHR constraints, see Definition~\ref{def:clean}). \end{itemize}
\end{definition}
}
We now introduce the concept of confluence which is a slight modification of that one in \cite{RBF09}, since it considers also the cleaning of the token store.

In the following  means either  or .


\begin{definition}[{\sc Confluence}]\label{def:Conf}
A CHR [annotated] program is \emph{confluent} if for any state  the following holds:
if  and  then there exist states 
and  such that  and , where .
\end{definition}

Now, we prove that our unfolding preserves confluence, provided that one considers only non-recursive unfolding. These
are the unfoldings such that a clause  cannot be used in order to unfold    itself.

When safe rule replacement is considered  rather than  non-recursive safe rule replacement (see Definition~\ref{def:nrsafedel}),
the confluence is not preserved. This is shown by the following example.

\begin{example}\label{ex:cofluence-problem}
Let us consider the following program:

where we do not consider the identifiers and the token store in the
body of rules (because we do not have propagation rules in ).
Then, by using  to unfold  itself (with safe rule replacement) we obtain the following program :

It is easy to check that the program  is confluent.
On the other hand, considering the program  and the start goal , the following  two states can be reached

and
there exist no states 
and  such that  and  in , where .\end{example}

Note that the program in previous example is not terminating. 
We cannot consider a terminating program here, since for such a program (weak) safe rule replacement would allow to preserve confluence.
Now, we give the definition of non-recursive safe rule replacement.

\begin{definition}[{\sc Non-recursive safe rule replacement}]\label{def:nrsafedel}
Let  be an annotated CHR program and let  be an annotated rule such that

can be safely replaced (by its unfolded version) in .
We say that 
can be non-recursively safely replaced (by its unfolded version) in  if
for each  , we have that
.
\end{definition}

The following is the analogous of Definition~\ref{def:uno}, where non-recursive safe rule replacement is considered.


\begin{definition}[{\sc NRU-sequence}]\label{def:nruno}
Let  be an annotated CHR program. An \emph{NRU-sequence} of programs
starting from  is a sequence of annotated CHR programs , such that

 where ,  and can be non-recursively safely replaced in .
\end{definition}

\begin{theorem} Let  be a CHR program and let 
be an NRU-sequence starting from .  satisfies confluence if and only if 
satisfies confluence too.
\end{theorem}


\section{Weak safe rule replacement}\label{sec:normally -rep}
In this subsection, we consider only programs which are normally terminating and confluent.
For this class of programs we give a condition for rule replacement which is much weaker than that one used in the previous section and which still allows one to preserve the qualified answers semantics. Intuitively this new condition requires that there exists a rule obtained by the unfolding of  in  whose guard is equivalent to that one in .

\begin{definition}[{\sc Weak safe rule replacement}]\label{def:wsafedel}
Let  be an annotated CHR program and let  be a rule such that there exists

with .

Then, we say that the rule 
can be weakly safely replaced (by its unfolded version) in .
\end{definition}



\begin{example}\label{ex:ncofluence}
Let us consider the following program :

where we do not consider the identifiers and the token store in the
body of rules (because we do not have propagation rules in ).
By Definition \ref{def:wsafedel},  can be weakly safely replaced (by its unfolded version) in  and then we can obtain the program

   where  is the program

Finally, observe that  cannot be safely replaced (by its unfolded version) in .
\end{example}




The following proposition shows that normal termination and confluence
are preserved by weak safe rule replacement. The proof is in the Appendix.


\begin{proposition}\label{prop:wterm}
Let  be an annotated CHR program and let  such that 
can be weakly safely replaced in . Moreover let

If  is normally terminating then  is normally terminating. If  is normally terminating and confluent then  is confluent too.
\end{proposition}

The converse of the previous theorem does not hold, as shown by the following example.
\begin{example}\label{ex:wconfluence-problem}
Let us consider the following program:

where we do not consider the identifiers and the token store in the
body of rules (because we do not have propagation rules in ).
Then, by using  to unfold  itself (with weak safe rule replacement) we obtain the following program :

It is easy to check that the program  satisfies the (normal) termination.
On the other hand, considering the program  and the start goal , the following state can be reached

where rules  and  in  can be applied infinitely many times.
Hence, we have non-(normally)termination.\end{example}


Next, we show that weak safe rule replacement transformation preserves qualified answers.

\begin{theorem}\label{prop:wqualified}
Let  be a normally terminating and confluent annotated program and let  be a rule in  such that
 can be weakly safely replaced
in  according to Definition~\ref{def:wsafedel}. Assume also that

Then  for any arbitrary
goal .
\end{theorem}

\begin{proof}
Analogously to Theorem~\ref{theo:n1completeness}, by using Proposition~\ref{prop:nequality}  we can prove that
 where
 
for any arbitrary goal .

Then, to prove the thesis, we have only to prove that

We prove the two inclusions separately.
\begin{description}
  \item[{\bf () }]
  The proof is the same of the case  of Theorem~\ref{theo:n1completeness} and hence it is omitted.


  \item[{\bf () }]
  The proof is by contradiction. Assume that there exists . Since, from the proof of Proposition~\ref{prop:wterm}, we can conclude that  is normally terminating and confluent, we have that  is a singleton. Moreover, since by the previous point
  , we have that .
  This means that each normal derivation in  either is not terminating or terminates with a failed configuration. Then, by using Proposition~\ref{prop:wterm}, we have that each normal derivation in  terminates with a failed configuration. Since , we have that there exist normal derivations in  which terminate with a failed configuration. Then, by Lemma~\ref{conflnormterm} and since , we have a contradiction and then the thesis holds.
\end{description}
\end{proof}

Let  be the rule .
Note that Proposition~\ref{prop:wterm} and Theorem~\ref{prop:wqualified} hold also if 
 where   and there exists
  such that  .

\comment{Analogously if  is the rule  then the following Corollary~\ref{lemma:wcompleteness} holds also if

where   and there exists
 such that .\\}


If in Definition~\ref{def:uno} we consider weak safe rule replacement rather than safe rule replacement, then we can obtain a definition
of  WU-sequence (rather than U-sequence).
From the previous theorem and by Proposition~\ref{prop:wterm}, by using an obvious inductive argument, we can derive that the semantics (in terms of qualified
answers) is preserved in WU-sequences starting from a normally terminating and confluent annotated program,
where weak safe replacement is applied repeatedly.






\section{Conclusions}\label{sec:conclusion_and_future}

In this paper, we have defined an unfold operation for CHR which preserves the qualified answers of a program.

This was obtained by transforming a CHR program into an
annotated one which is then unfolded. The equivalence of the unfolded
program and the original (unannotated) one is proven by using  a slightly modified operational semantics for annotated programs.
We have then provided a condition that can be used to replace a
rule by its unfolded version, while preserving the qualified answers. We have also shown that this condition ensures that confluence and termination are preserved, provided that one considers normal derivations. Finally,
we have defined a further, weaker, condition which allows one to safely replace a rule by its unfolded version (while preserving qualified answers) for programs which are normally terminating and confluent.

There are only few other papers that consider source to source transformation
of CHR programs. \cite{Fru04}, rather than considering a generic transformation
system focuses on the specialization of rules w.r.t. a specific goal, analogously
to what happens in partial evaluation. In \cite{FH03} CHR rules are transformed
in a relational normal form, over which a source to source transformation is performed. Some form of
transformation for probabilistic CHR is considered in \cite{WFLP02}, while
guard optimization was studied in \cite{SSD05b}. Another paper which involves program transformation
for CHR is \cite{SS09}.

Both the general and the goal specific approaches are important in order
to define practical transformation systems for CHR. In fact, on the
one hand of course one needs some general unfold rule, on the other
hand, given the difficulties in removing rules from the transformed
program, some goal specific techniques can help to improve the
efficiency of the transformed program for specific classes of
goals. A method for deleting redundant CHR rules is considered
in \cite{AF04}. However, it is based on a semantic check and it
is not clear whether it can be transformed into a specific syntactic
program transformation rule.

When considering more generally the field of concurrent logic
languages, we find few papers which address the issue of program
transformation. Notable examples include  \cite{EGM01} that deals with
the transformation of  Concurrent Constraint Programming (CCP) and
\cite{UF88} that considers Guarded Horn Clauses (GHC).  The
results in these papers are not directly applicable to CHR  because
neither CCP nor GHC allow rules with multiple heads.

As mentioned in the introduction, some of the results presented here appeared in
\cite{TMG07} and in the thesis  \cite{Tac08}. However, it is worth noticing that
the conditions for safe rule replacement that we have presented in Section 5
and the content of Section 6 are original contributions of this paper.
In particular, differently from the conditions given in \cite{TMG07} and \cite{Tac08},
the conditions defined in Section 5 allow us to perform rule replacement also when rules with multiple heads
are used for unfolding a
given rule. This is a major improvement, since CHR rules have naturally multiple heads.


The results obtained in the current article can
be considered as a first step
in the direction of defining a transformation system for CHR programs,
based on unfolding. This step could be extended in several directions:
First of all, the unfolding operation could be extended to take
into account also the constraints in the propagation part of the head
of a rule.
Also, we could extend to CHR some of the other transformations,
notably folding \cite{TS84} which has already been applied to CCP in \cite{EGM01}.
Finally, we would like to investigate from a practical perspective
to what extent program transformation can improve the
performance of the CHR solver. Clearly, the application of an
unfolded rule avoids some computational steps (assuming  that
unfolding is done at the time of compilation, of course). However, the
increase in the number of program rules produced by unfolding could eliminate this improvement.

Here, it would probably be important to consider some unfolding
strategy, in order to decide which rules have to be unfolded.



An efficient unfolding strategy could also incorporate in particular
probabilistic or statistical information. The idea would be to only unfold 
CHR rules which are used often and leave those which are used only 
occasionally unchanged in order to avoid an unnecessary increase in the
number of program rules. This approach could be facilitated by probabilistic 
CHR extensions such as the ones as presented for example
in \cite{WFLP02}\ and \cite{CHRPrism}.  Extending the results of this paper
to probabilistic CHR will basically follow the lines and ideas presented here.
The necessary information
which one would need to decide whether and in which sequence to 
unfold CHR rules could obtain experimentally, e.g. by profiling, or formally 
via probabilistic program analysis. One could see this as a kind
of {\em speculative} unfolding.


\bibliographystyle{acmtrans}
\bibliography{thesis}















































\newpage

\appendix

 \section{Proofs}


In this appendix, we give the proofs of some of the results contained in the paper.

\subsection{Equivalence of the two operational semantics}

Here, we provide the proof of  Proposition~\ref{prop:nequality}.
To this aim we first introduce some preliminary notions and lemmas.


Then, we define two configurations (in the two different transition systems)
equivalent when they are essentially the same up to renaming of identifiers.


\begin{definition}[{\sc Configuration equivalence}]\label{def:PLQA}
 Let
  be a configuration in the transition system  and let   be a configuration in the transition system .

 and  are \emph{equivalent} (and we write
) if:
\begin{enumerate}
\item\label{uno-e}  there exist  and , such that ,  and ,
\item\label{due-e} for each ,  does not occur in ,
\item\label{tre-e} there exists a renaming of identifier  s.t.  and
.
\end{enumerate}
\end{definition}
Condition~\ref{uno-e} grants that  and  have equal
CHR constraints, while Condition~\ref{due-e} ensures that no propagation rule is applied to constraints in  corresponding to constrains in  that are not previously
introduced in the CHR store. Finally, condition~\ref{tre-e} requires that there exists a renaming of identifiers such that
the identified CHR constraints  and the tokens of 
and the ones associated with them in  are equal, after the renaming.

The following result shows the equivalence of the two introduced
semantics proving the equivalence of intermediate configurations.


\begin{lemma}\label{lemma:intermequiv}
Let  and  be respectively a CHR program and its annotated version.
Moreover, let
 and let   such that
.
Then, the following holds
\begin{itemize}
  \item there exists a derivation  in  if and only if
there exists a derivation  in  such  
  \item the number of \textbf{Solve} (\textbf{Apply}) transition steps in  and the number of \textbf{Solve'} (\textbf{Apply'}) transition steps in  are equal.
\end{itemize}
\end{lemma}
\begin{proof}
We show that any transition step from any configuration in one system can be imitated from a (possibly empty) sequence of  transition steps from an equivalent configuration in the other system to achieve an equivalent configuration.
 Moreover there exists a \textbf{Solve} (\textbf{Apply}) transition step in  if and only if there exists a  \textbf{Solve'} (\textbf{Apply'}) transition step in .

 Then, the proof follows by a straightforward inductive argument.

Let 
and let   such that
.
By definition of ,  there exist  and  and a renaming  such that


\begin{description}
\item[Solve and Solve':] they move a built-in constraint from the Goal store or the Store
respectively to the built-in constraint store. In this case, let . By definition of the two transition systems

By definition of , it is easy to check that .
\\

\item[Introduce:] this kind of transition there exists only in  semantics and its
application labels a CHR constraint in the goal store and moves it in the CHR store.
In this case, let  and



Let . By (\ref{7giu3}) and since ,
there exists an identified atom .
Let  (where  if  is not in the domain of ).

Now, let  and . By (\ref{7giu3}), we have that ,  and .

Moreover, by definition of , for each ,  does not occur in . Therefore, since by construction , we have that for each ,  does not occur in .

Now, to prove that , we have only to prove that there exists a renaming , such that
 and .
We can consider the new renaming .
By definition  is a renaming of identifiers.

Let us start proving that
.


We recall that
 by hypothesis.
Since by construction, , we have that

Moreover, since by definition  and , we have that
.
By the previous observations, we have that

Finally, we prove that . Since by definition of configurations in ,
 does not occur in  and , we have that , where the last equality follows by hypothesis. Moreover  since , we have that  does  not occur in .
Therefore,  and then the thesis.
\\

\item[Apply and Apply':] Let   and let 
be its annotated version, where .
 The latter can
be applied to the considered configuration . In particular  match respectively with  and  such that
. Without loss of generality, by using a suitable number of {\bf Introduce} steps, we can assume that
 can be applied to . In particular, considering the hypothesis , we can assume for , there exists  such that ,  and  match respectively with  and .

Then, by (\ref{7giu3}), there exist  and  such that
,  and
.

By construction, since  and  (and then
), we have that

\begin{itemize}
\item  if and only if
 and
\item  if and only if
.
\end{itemize}


Therefore, by definition of {\bf Apply} and of {\bf Apply'}

if and only if

where
\begin{itemize}
  \item ,
  \item  and
  \item .
\end{itemize}

Let  and
. \\

Now, to prove the thesis, we have to prove that
.

The following holds.

\begin{enumerate}
\item  There exist  and , such that ,
     and .
\item Since for each ,  does not occur in ,
  and by definition of \textbf{Apply'} transition, we have that for each ,  does not occur in ,
\item By construction and since , we have that .
Moreover, by construction  .
\end{enumerate}
By definition, we have that  and then the thesis.
\end{description}
\end{proof}

\noindent Then, we easily obtain the following \\

\setcounter{proposition}{0}
\begin{proposition}
Let  and  be respectively a CHR program and its annotated version.
Then, for every goal ,

holds.
\end{proposition}
\setcounter{proposition}{4}
\begin{proof}
By definition of  and of ,
the initial configurations of the two transition systems are equivalent. Then, the proof follows by Lemma~\ref{lemma:intermequiv}.
\end{proof}


\subsection{Correctness of the unfolding}
We prove now the correctness of our unfolding definition.

Next proposition states that qualified answers can be obtained  by considering normal derivations only for both the semantics  considered. Its proof is straightforward and hence it is omitted.

\begin{proposition}\label{prop:solonorm}
Let  be CHR program  and let  an annotated CHR program.
Then

and

\end{proposition}


The next proposition essentially shows the correctness of unfolding w.r.t. a derivation step.
We first define an equivalence between configurations in .

\begin{definition}[{\sc Configuration Equivalence}]\label{def:SE}
Let   and   be configurations  in .
 and  are equivalent and we write  if one of the following facts hold:
\begin{itemize}
  \item  and  are both failed configurations
  \item or ,  and .
\end{itemize}

\end{definition}


\begin{proposition}\label{prop:servequality}
Let  be annotated CHR rules and   be the result
of the unfolding of  with respect to . Let  be a generic built-in free configuration such that we can use the transition \textbf{Apply'} with the rule  obtaining the configuration  and then the built-in free configuration . Then, we can construct a derivation which uses at most the rules  and  and obtain a built-in free configuration  such that .
\end{proposition}
\begin{proof}
Assume that


The labeled arrow  means that only {\bf Solve} transition steps are applied.
Moreover:
\begin{itemize}
           \item if  has the form
 then the derivation between the parenthesis is not present and .
           \item the derivation between the parenthesis is present and , otherwise.
         \end{itemize}
Let   be a built-in free configuration
and let  and  be the rules
 and
 respectively,
where  is the conjunction of all the built-in constraints in the body
of ,  is a substitution such that  and

Furthermore assume that  is the greatest identifier which appears in the
rule  and that .
Then, the \emph{unfolded} rule  is:

where ,
, 
, , the
constraint  is satisfiable and
\begin{itemize}
    \item if  then 
    \item if  then .
    \end{itemize}

By the previous observations, we have that
    
and therefore . Then, without loss of generality, we can assume that
    
Analogously, by (\ref{13marzo1}) and since , we can assume that
 



Moreover, since by definition  and , we have that
    
Let us consider the application of the rule  to . By definition of the transition \textbf{Apply'}, we have that

and

 \noindent
 where
 \begin{itemize}
   \item ,
   \item ,
   \item   and
     .
 \end{itemize}

    Therefore, by definition
    
    where
    

Let us consider now the application of
 to  and then of  to the  obtained from the previous application.
Since by construction  and by (\ref{10dic1}), we have that

Therefore, by definition of the transition \textbf{Apply'}, we have that

\noindent where
\begin{itemize}
  \item ,
  \item  and
.
\end{itemize}



Therefore, by definition 
  where


Now, we have two possibilities
\begin{description}
  \item[().] In this case, by construction, we have that . Therefore  and then the thesis.
  \item[().]
\comment{By (\ref{10dic1}) and (\ref{13marzo2})
  
Then, by} By (\ref{13marzo2}) and (\ref{10dic2})
(\ref{13marzo1}), we have that


Moreover, by (\ref{13marzo2}), (\ref{10dic1}) and (\ref{7giu1})

and then .
Therefore, by (\ref{3giu101}), (\ref{7giu5}) and since the rules are renamed apart,

Then, by definition of  and since , we have that
.

Therefore, since  ,


Then,  is such that we can use the transition \textbf{Apply'} with the rule  obtaining the new configuration

where \begin{itemize}
        \item 
        \item ),
        \item  and .
      \end{itemize}

Finally, by definition, we have that

  where
  
  By definition of  and , we have that .

  If  then the proof is analogous to the previous case and hence it is omitted.
  Otherwise, observe that by construction,
, where
 is obtained from  by adding the natural  to each identifier in
 and by adding the natural  to each identifier in
.
Analogously, by construction,
, where
  are obtained from  by adding the natural  to each identifier in
 and  is obtained from  by adding the natural   to each identifier in .

Therefore  and then, to prove the thesis, we have only to prove that 

Let us introduce the function  as
the restriction of the function  to token sets and natural numbers, namely
, where  is obtained from  by
incrementing each identifier in  with . So, since
,
 and
, we have that




Analogously, since ,
 and , we have that

Now, since by construction  is obtained from  by adding the natural  to each identifier, we have that .
Moreover, by definition of annotated rule 
and , where
 is obtained from  by adding the natural  to each identifier in
 and by adding the natural  to each identifier in
. Then  and then the thesis holds.
\end{description}
\end{proof}

\noindent Hence we obtain the correctness result. \\

\setcounter{proposition}{1}
\begin{proposition}
Let  be an annotated CHR program with
. Let   be the result
of the unfolding of  with respect to  and let  be the program
obtained from  by adding rule . Then, for every goal ,
 holds.
\end{proposition}
\setcounter{proposition}{6}

\begin{proof}
We prove the two inclusions separately.
\begin{description}
  \item[{\bf ()}] The proof follows from Propositions~\ref{prop:solonorm} and~\ref{prop:servequality} and by a straightforward inductive argument.
  \item[{\bf ()}]
  The proof is by contradiction. Assume that there exists . By definition there exists a derivation
   in , such that . Since , we have that there exists the derivation
 in . Moreover, since  and by hypothesis , we have that there exists a derivation step  by using the rule .
Then, by definition of unfolding there exists a derivation step  in , by using the rule  and then we have a contradiction.
\end{description}
\end{proof}





\subsection{Safe replacement}

We can now provide the result which shows the correctness of the safe rule replacement condition.
This is done by using  the following proposition.

\begin{proposition}\label{lemma:servcomplete}
Let  be two annotated CHR rules such that the following holds
\begin{itemize}
\item  is of the form ,
\item  is of the form , with
   and it is obtained by unfolding the identified atoms .
\end{itemize}
Moreover, let  be a generic built-in free configuration such that we can
construct a derivation  from  where
\begin{itemize}
  \item  uses at the most the rules  and  in the order,
  \item a built-in free configuration   can be obtained and
  \item if  is used, then  rewrites the atoms  such that . \comment{corresponding (in the obvious sense) to the considered  in the body of .}
\end{itemize}
Then, we can use the transition \textbf{Apply'} with the rule  obtaining the configuration  and then the built-in free configuration  such that .
\end{proposition}
\begin{proof}
Assume that


The labeled arrow  means that only {\bf Solve} transition steps are applied.
Moreover
\begin{itemize}
           \item if  has the form
 then the derivation between the parenthesis is not present and .
           \item the derivation between the parenthesis is present and , otherwise.
         \end{itemize}

We first need some notation.  Let   be a built-in free configuration
and let  and  be of the form
 and
 respectively,
,  is the conjunction of all the built-in constraints in the body
of  and  is a substitution such that  and

Furthermore let  be the greatest identifier which appears in the
rule  and let .

Then, the \emph{unfolded} rule  is:

where ,
,
, , the
constraint  is satisfiable and
\begin{itemize}
    \item if  then 
    \item if  then .
    \end{itemize}

Since by hypothesis, , we have that


Let us now consider the application of the rule
 to . By definition of the \textbf{Apply'} transition step, we have that

and

where ,
 and
.

Therefore, by definition

  where

Let us now apply the rule  to
. By (\ref{110dic1}), (\ref{110dic2}) and
by definition of the  \textbf{Apply'} transition step, we have that

where
\begin{itemize}
  \item ,
  \item ,
  \item  and
.
\end{itemize}

Therefore, by definition

where


Now, we consider the two previously obtained configurations  and
. Since by hypothesis  is a non-failed configuration, we have that 


Now, let  such that . Note that such atoms there exist, since by construction  are atoms in the body of .

  By definition, since
 are atoms in the body of , , by (\ref{13marzo21}), (\ref{113marzo1}) and (\ref{110dic2}), \comment{and (\ref{110dic1}),} we have that

 and therefore, since , we have that

Then, since by hypothesis  rewrites the atom  such that , we have that

     where
     \begin{itemize}
       \item ,
       \item  ,
       \item  and
       .
     \end{itemize}
Finally, by definition, we have that
 where
  

  If  then the proof is analogous to the previous case and hence it is omitted.

  Otherwise, the proof is analogous to that given for Proposition~\ref{prop:servequality} and hence it is omitted.
\end{proof}


\begin{proposition}\label{propcambioequality}
Let  be a built-in configuration and let  be an annotated CHR rule such that the following holds.\begin{description}
        \item[a)] . where
        ,
        \item[b)]
        there exists  such that
         and ,
        \item[c)] there exist  and  such that
        ,
         and ,
        \item[d)]  is an  transition step which uses the clause , rewrites the atoms  and such that
            , where  is the constraint
            .
      \end{description}
      Then, there exists an   transition step    which uses the clause , rewrites the atoms  and such that
      , where  is the constraint
             and
            \begin{enumerate}
              \item \label{28sett1} ,
              \item \label{28sett2} .
            \end{enumerate}
      \end{proposition}
\begin{proof}
First of all, by definition of   transition step and since, by hypothesis , , we have to prove that

         By hypothesis  and since , we have that
         . Hence the thesis follows by hypothesis .

        Now, we have to prove~\ref{28sett1}. By hypothesis ,  we have that
        .
        Therefore, there exists a substitution  such that  and

        By hypothesis  and since , we have that
        
         and by (\ref{7sett111}),
        .\\
        Then   and then the thesis.
        \\
        The proof of~\ref{28sett2} is obvious by definition of   transition step.
\end{proof}




\begin{proposition}\label{propavanza}
Let  be a built-in configuration such that there exists a normal terminating derivation  starting from  which ends in a configuration . Assume that  uses an annotated CHR rule  such that the following holds.
\begin{description}
        \item[a)] 
        \item[b)]
        there exists  such that  rewrites the atoms  in  and 

      \end{description}
Then, there exists a normal terminating derivation  starting from  such that
\begin{itemize}
  \item  uses at most the same clauses of  and uses the rule  in the first  transition step, in order to rewrite the atoms ,
  \item  ends in a configuration  such that .
\end{itemize}
\end{proposition}
\begin{proof}
The proof is obvious by definition of derivation.
\end{proof}


\noindent Hence we have the following result.\\
\setcounter{theorem}{0}
\begin{theorem}
Let  be an annotated program,   be a rule in  such that
 can be safely replaced
in  according to Definition~\ref{def:nsafedel}. Assume also that


Then  for any arbitrary
goal .
\end{theorem}
\setcounter{theorem}{3}


\begin{proof}
By using a straightforward inductive argument and by
Proposition~\ref{prop:equality}, we have that
 where
 
for any arbitrary goal .

Then, to prove the thesis, we have only to prove that

In the following, we assume that  is of the form .
We prove the two inclusions separately.
\begin{description}
  \item[{\bf () }]
  The proof is by contradiction. Assume that there exists . By definition there exists a derivation
  
in , such that . Since , we have that there exists the derivation
 in . Moreover, since  and , we have that there exists a derivation step  by using the rule . \\
Since  can be safely replaced
in , we have that there exists an unfolded rule  such that  is of the form 
 and by construction . \\
Then, there exists a derivation step  in  (by using the rule ) and then we have a contradiction.


  \item[{\bf () }]
  First of all, observe that by Proposition~\ref{prop:solonorm},
   can be calculated by
considering only non-failed normal terminating derivations. \\
Then, for each non-failed normal terminating derivation  in , which uses the rule  after the application of , we obtain the configuration  and then a non-failed built-in free configuration . Now, let  be the built-in constraint store of .

Since by hypothesis
 can be safely replaced
in , following Definition~\ref{def:nsafedel}, we have there exists at least an atom
, such that there exists a corresponding atom (in the obvious sense)  which is rewritten in  by using a rule  in . Therefore, without loss of generality, we can assume that


 where the transition step  is the first {\bf Apply'} transition step which uses the clause  and  is the first {\bf Apply'} transition step which rewrites an atom , corresponding to an atom  in the body of  introduced by .
 Since by hypothesis
 can be safely replaced
in  and by Proposition~\ref{propcambioequality} we can assume that  rewrites in  only atoms corresponding (in the obvious sense) to atoms in . Moreover, since by hypothesis
 can be safely replaced
in  and by Proposition~\ref{propavanza}, we can assume that  is the first {\bf Apply'} transition step after .
Then, the thesis follows since by hypothesis
 can be safely replaced
in , by Proposition~\ref{lemma:servcomplete} and by a straightforward inductive argument.

 \comment{ Moreover we can assume that , , , , the transition step  uses the clause  and let us to assume that the clause  rewrites the atoms .\\
By definition of {\bf Apply'} transition step, there exists  such that

Let . Then, since  can be safely replaced
in , we have that  and therefore, by condition~\ref{bi} of Definition~\ref{def:Pposeneg}, there exist the atoms
 in the body of the clause  such that

By (\ref{6giugno0}) and since 
 we have that
 and therefore,
by (\ref{6giugno1}), since , we have that
. Moreover
Therefore, we can use the clause  in order to rewrite the atoms in , corresponding to  in  the body of .

Now, observe that
 and that
 and therefore





Moreover, since  can be safely replaced
in  (and therefore , a new rule  of the form  can be obtained by unfolding the atom  in the body of the rule  with the rule , where  .
Without loss of generality we can assume that in the derivation , the rule  is applied to the considered configuration  (in order to rewrite the atom  corresponding to ).


In both the cases the proof is straightforward, by using the previous observations and  Proposition~\ref{lemma:servcomplete}. Hence the thesis holds.}
\end{description}
\end{proof}


\subsection{Termination and confluence}

We first prove the  correctness of unfolding w.r.t. termination.\\

\setcounter{proposition}{2}
\begin{proposition}[{\sc Normal Termination}]

Let  be a CHR program and
let  be an U-sequence starting from .  satisfies
normal termination if and only if   satisfies normal termination.
\end{proposition}
\setcounter{proposition}{7}

\begin{proof}
By Lemma~\ref{lemma:intermequiv}, we have that  is normally terminating if and only if  is normally terminating.
Moreover from Proposition~\ref{prop:servequality} and Proposition~\ref{lemma:servcomplete} and by using a straightforward inductive argument, we have that
for each ,  satisfies normal termination if and only if  satisfies the normal termination too and then the thesis.
\end{proof}


The following lemma relates the , 
and  equivalences.


\begin{lemma}\label{lem:relrel}
Let  be final configurations in ,  and let  be a set of variables.
\begin{itemize}
  \item If ,  then   if and only if .
  \item If ,  and   then .
\end{itemize}
\end{lemma}
\begin{proof}
The proof of the first statement follows by definition of  and by observing that if  is a final configuration in , then 
has the form   or it
has the form .

The proof of the second statement is straightforward, by observing that if , then
 for each set of variables .
\end{proof}




\setcounter{theorem}{1}
\begin{theorem}[{\sc Confluence}] Let  be a CHR program and let 
be an NRU-sequence starting from .  satisfies confluence if and only if 
satisfies confluence too.
\end{theorem}\setcounter{theorem}{3}
\begin{proof}
\comment{We prove only that if  is normally terminating and confluent, then  is confluent too.
The proof of the converse is similar and hence it is omitted.}
By Lemma~\ref{lemma:intermequiv}, we have that  is confluent if and only if  is confluent.
Moreover, by Proposition~\ref{prop:servequality}
Now, we prove that
for each ,  is confluent if and only if  is confluent too.
Then, the proof follows by a straightforward inductive argument.
\begin{itemize}


  \item Assume that  is confluent and let us assume by contrary that  does not satisfies confluence.
  By definition,  there exists a state  and two derivations  and  in  such that
there are no two derivations  and  in   where
. Without loss of generality, we can assume that  and  are built-in free states.  Therefore, by Proposition~\ref{prop:servequality}, there exist
two derivations  and  in , such that  and . Moreover, since  is confluent, there exist two derivations  and  in  such that . Moreover, without loss of generality, we can assume that  and  are built-in free.
Analogously to Theorem~\ref{theo:n1completeness}, since by hypothesis
 can be safely replaced
in  and by using Proposition~\ref{lemma:servcomplete}, we can counstruct two new derivations
 and 
in  such that
 and  are built-in free,
,  and such that if  and  use the clause , then no atoms introduced (in the obvious sense) by  is rewritten by using (at least) one rule in .
Moreover, by hypothesis and by Lemma~\ref{lem:relrel}, .



Let  the number of the {\bf Apply'} transition steps in  and ,
which use the rule  and whose body is not rewritten by using (at least) one rule in .
The proof is by induction on .
\begin{description}
  \item[()] In this case,  and  are derivations in . By hypothesis  and by Lemma~\ref{lem:relrel}, we have that   and then we have a contradiction.

\item[()] Let us consider the last {\bf Apply'} transition step in  and , which use (a renamed version of) the rule , whose body is not rewritten by using (at least) one rule in  and where  is the conjunction of all the built-in constraints in the body of . Without loss of generality, we can assume that such an {\bf Apply'} transition step is in .
    Now, we have two possibilities

    \begin{itemize}
      \item  is a failed configuration. By definition of , we have that  is also a failed configuration. In this case, it is easy to check that, by using Lemma~\ref{lemma:servcomplete}, we can substitute each {\bf Apply'} transition steps in  and , which use the rule  and whose body is not rewritten by using (at least) one rule , with an {\bf Apply'} transition step which uses a rule in . Then, analogously to the case {\bf ()}, it is easy to check that there exist the derivations  and  in  such that  and  are both failed configurations and then we have a contradiction.

\item   is not a failed configuration. Then  is of the form , where .
    Moreover, since  can be non-recursively safely replaced in , there exists a clause  in   such that
     can be unfolded by using . Therefore, by definition of non-recursive safe unfolding,
    there exists a new derivation , where  is obtained from   first by an
     {\bf Apply'} transition step, which uses the rule  and rewrites atoms in the body of  and then some {\bf Solve'} transition steps.
     By definition of  and since , we have that there exists also a new derivation
     , where  is obtained from   first by an
     {\bf Apply'} transition step, which uses the rule  and rewrites atoms in the body of  and then some {\bf Solve'} transition steps.

 Since by hypothesis , we have that . Moreover the number of the {\bf Apply'} transition steps in  and , which use the rule  whose body is not rewritten by using (at least) one rule in 
     is strictly less than  and then the thesis.
     \end{itemize}
   \end{description}
    \item Assume that  is confluent and let us assume by contrary that   does not satisfies confluence. The proof is analogous to the previous case and hence it is omitted.
\end{itemize}
\end{proof}



\subsection{Weak safe rule replacement}


Finally, we provide the proof of Proposition~\ref{prop:wterm}. We first need of the following lemma, which provides an alternative characterization of confluence for normally terminating programs.

\begin{lemma}\label{conflnormterm}
Let  be a CHR [annotated] normally terminating program.  is confluent if and only if for each pair of normal derivations  and , we have that
.
\end{lemma}
\begin{proof}
\begin{description}
  \item[(Only if)] The proof is straightforward by definition of confluence.
  \item[(If)] The proof is by contradiction. Assume that  is not confluent. Then, there exists a state  such that  and  and for each pair of states 
and  such that  and , we have that . In particular, since  is normally terminating, we have that there exists  and  such that
,  and .
Then, it is easy to check that there exist two normal derivation
 and  such that
 and . Since , by definition of , we have that  and then we have a contradiction.
\end{description}
\end{proof}


Then, we have the desired result.


\setcounter{proposition}{3}
\begin{proposition}
Let  be an annotated CHR program and let  such that 
can be weakly safely replaced (by its unfolded version) in . Moreover let

If  is normally terminating then  is normally terminating. Moreover, if  is normally terminating and confluent then  is confluent too.
\end{proposition}
\setcounter{proposition}{7}


\begin{proof}
First, we prove that if  is normally terminating then   is normally terminating too, where

   Then, we prove that if  is normally terminating then  is normally terminating.
    Analogously if  is normally terminating and confluent and then the thesis.
\begin{itemize}
   \item Assume that  is normally terminating.
  The proof of the normal termination of  follows by Proposition~\ref{prop:servequality}.

   \item Now, assume that  is normally terminating and confluent and by the contrary that  does not satisfy confluence.


       By Lemma~\ref{conflnormterm} and since by the previous result  is normally terminating, there exist a state
 and two normal derivations
 in 
such that
.


Then, by using arguments similar to that given in Proposition~\ref{prop:servequality} and since , we have that there exist two normal derivations

in , where
  and . Since by hypothesis  is confluent, we have that .
  Therefore, by Lemma~\ref{lem:relrel} we have a contradiction to the assumption that there exist two states  and  as previously defined.
 \end{itemize}


 \noindent Now, we prove that if  is normally terminating then  is normally terminating. Moreover we prove  that if  is normally terminating and confluent then  is confluent too and then the thesis.
 \begin{itemize}
   \item If  is normally terminating then, since , we have that
   is normally terminating too.
     \item Now, assume that  is normally terminating and confluent and  by the contrary that  does not satisfy confluence. Moreover, assume that  is of the form . By Lemma~\ref{conflnormterm} and since by the previous result  is normally terminating, there exist a state
 and two normal derivations

 in  such that
.


Since , we have that there exist two normal derivations

in . Then, since  is confluent and  there exists  such that
 in  by using the rule . In this case, by definition of weak safe replacement, there exists an unfolded rule   such that  is of the form

with  and by construction . Therefore  in , by using the rule , and then we have a contradiction.
 \end{itemize}
\end{proof}



\end{document}
