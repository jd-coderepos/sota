\documentclass[sigconf]{acmart}

\usepackage{booktabs} 

\usepackage{pifont}\newcommand{\cmark}{\ding{51}}\newcommand{\xmark}{\ding{55}}

\usepackage{tikz}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{mathtools}
\usepackage{makecell}
\usepackage[linesnumbered,lined,boxed,commentsnumbered]{algorithm2e}
\usepackage{amssymb}
\usepackage{bbm}

\usepackage[american]{babel}





\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 



\newcommand{\ours}{\textsc{DDGK}}
\newcommand{\todo}[1]{{\footnotesize\color{red}{\textbf{#1}}}}
\newcommand{\corpus}[1]{\begin{quote}{\small \emph{#1}}\end{quote}}

\definecolor{ramiblue}{HTML}{007bd5}
\definecolor{ramigray}{HTML}{a9a9a9}
\definecolor{ramired}{HTML}{c11b24}
\def\layersep{2.5cm}

\DeclarePairedDelimiterX{\infdivx}[2]{(}{)}{#1\;\delimsize\|\;#2}



\setcopyright{rightsretained}



\copyrightyear{2019}
\acmYear{2019} 
\setcopyright{iw3c2w3}
\acmConference[WWW '19]{Proceedings of the 2019 World Wide Web Conference}{May 13--17, 2019}{San Francisco, CA, USA}
\acmBooktitle{ Proceedings of the 2019 World Wide Web Conference (WWW'19), May 13--17, 2019, San Francisco, CA, USA}
\acmPrice{}
\acmDOI{10.1145/3308558.3313668}
\acmISBN{978-1-4503-6674-8/19/05}

\begin{document}
\title{DDGK: Learning Graph Representations for Deep Divergence Graph Kernels}



\author{Rami Al-Rfou}
\affiliation{\institution{Google AI}
  \streetaddress{1600 Amphitheatre Parkway}
  \city{Mountain View}
  \state{CA}
  \postcode{94043}
}
\email{rmyeid@google.com}

\author{Dustin Zelle}
\affiliation{\institution{Google AI}
  \streetaddress{111 8th Ave}
  \city{New York}
  \state{NY}
  \postcode{10011}
}
\email{dzelle@google.com}

\author{Bryan Perozzi}
\affiliation{\institution{Google AI}
  \streetaddress{111 8th Ave}
  \city{New York}
  \state{NY}
  \postcode{10011}
  }
\email{bperozzi@acm.org}


\renewcommand{\shortauthors}{R. Al-Rfou et al.}


\begin{abstract}

Can neural networks learn to compare graphs without feature engineering?
In this paper, we show that it is possible to learn representations for graph similarity with neither domain knowledge nor supervision (i.e.\ feature engineering or labeled graphs).
We propose Deep Divergence Graph Kernels, an unsupervised method for learning representations over graphs that encodes a relaxed notion of graph isomorphism. 
Our method consists of three parts.  
First, we learn an encoder for each anchor graph to capture its structure.
Second, for each pair of graphs, we train a cross-graph attention network which uses the node representations of an anchor graph to reconstruct another graph.
This approach, which we call \emph{isomorphism attention}, captures how well the representations of one graph can encode another.
We use the attention-augmented encoder's predictions to define a divergence score for each pair of graphs.
Finally, we construct an embedding space for all graphs using these pair-wise divergence scores. 

Unlike previous work, much of which relies on 1) supervision, 2) domain specific knowledge (e.g. a reliance on Weisfeiler-Lehman kernels), and 3) known node alignment, our unsupervised method jointly learns node representations, graph representations, and an attention-based alignment between graphs.

Our experimental results show that Deep Divergence Graph Kernels can learn an unsupervised alignment between graphs, and that the learned representations achieve competitive results when used as features on a number of challenging graph classification tasks.
Furthermore, we illustrate how the learned attention allows insight into the the alignment of sub-structures across graphs.
\end{abstract}



\keywords{Graph Kernels; Graph Neural Networks; Representation Learning; Similarity and Search}

\maketitle

\section{Introduction}

Deep learning methods have achieved tremendous success in domains where the structure of the data is known a priori.
For example domains like speech and language have intrinsic sequential structure to exploit, while computer vision applications have spatial structure (images) and perhaps temporal structure (videos).
In all these cases, our intuition guides us to build models and learning algorithms based on the structure of the data.
For example, translation invariant convolution networks might search for shapes regardless of their physical position in an image, or recurrent neural networks might share a common latent representation of a concept across distant time steps or diverse domains such as languages.
In contrast, graph learning represents a more general class of problems because the structure of the data is free from any constraints.
A neural network model must learn to solve both the desired task at hand (e.g.\ node classification) and to represent the structure of the problem itself -- that of the graph's nodes, edges, attributes, and communities.

\begin{figure}[t]
\includegraphics[width=\columnwidth]{figures/DDK-Method.pdf}
\caption{Our method of learning graph representations by measuring the divergence of a target graph across a population of source graph encoders.
First, we train a graph encoder for each graph in our source graph population \{, , ..., \}.
Second, for each of these encoders we measure the divergence of the target graph from the associated source graph.
Finally, these divergence scores are used to compose the vector representation of the target graph.}
\label{fig:method}
\end{figure}

Despite the challenges, there has been a recent surge of interest in applying neural network models to such graph-structured data \cite{deepwalk, kipf-gcn,hamilton2017inductive,velickovic2017graph,zhu2018deep}.
While initial approaches like DeepWalk \cite{deepwalk} focused on generic representations of graph primitives (e.g.\ a graph's nodes \cite{deepwalk} or edges \cite{asymmetric}), present approaches ignore learning general graph and node representations in favor of maximizing accuracy on a set of narrow classification tasks.
These approaches, broadly referred to as Graph Neural Networks (GNNs), seek to leverage the structure between data items as a scaffolding to perform computation (e.g. message passing, gradient updates, etc).
The parameters and the activations, use the structure during training, but are tuned primarily to classify the graph's nodes, edges, and/or attributes.

While much effort has focused on unsupervised learning of node representations \cite{deepwalk,node2vec,dngr,tsitsulin2017verse}, edge representations \cite{asymmetric}, or latent community structure \cite{cavallari2017learning,wang2017community,zheng2016node}, relatively little work has focused on the unsupervised learning of representations for entire graphs -- a problem of practical interest in domains such as information retrieval, biology, and natural language processing \cite{gilmer2017neural,battaglia2018relational}.
In cases where GNNs have been applied to the task of learning similarity between graphs, the approaches considered generally come in two flavors: an end-to-end \textit{supervised graph classification} or \textit{graph representation learning}.

In supervised graph classification, the task is to solve an end-to-end whole-graph classification problem (i.e.\ the problem of assigning a label to the entire graph).
These supervised approaches \cite{patchysan,zhang2018end,tixier2018graph,morris2018weisfeiler} learn an intermediate representation of an entire graph as a precondition in order to solve the classification task.
This learned representation can be used to compare similarity between graphs, but is heavily biased towards maximizing performance on the classification task of interest.  

The second class of approaches focuses on the more general problem of learning graph representations \cite{taheri2018RNN}.
While much exciting progress has been made in this area, the existing approaches suffer from one or more of the following limitations.
First, many existing methods rely on feature engineering, such as the graph's clustering coefficient, its motif distribution, or its spectral decomposition, to represent graphs \cite{berlingerio2012netsimile,yanardag2015deep,tsitsulin2018netlsd}.
By limiting the features that they consider, these methods are limited to composing only known graph signals.
Second, many of these approaches \cite{patchysan,zhang2018end} have sought to encode algorithmic heuristics from the graph isomorphism literature (especially the intuition encoded in the Weisfeiler Lehman algorithm \cite{shervashidze2011weisfeiler}).
Relying heavily on existing heuristics to solve a hard problem raises an important question: how well can a learning-only approach solve a classic algorithmic problem?
Finally, other work in this area of graph similarity assumes that identical nodes in both graphs share the same id (i.e.\ the alignment is already given).
While this can be useful for calculating a similarity score, we find the general problem more compelling.



In this work, we propose a method of learning graph representations driven by the similarity between a pair of graphs as measured by the divergence in their structures.
We show the representations learned through our method, Deep Divergence Graph Kernels (\ours{}), capture the attributes of graphs by using them as features for several classification problems.
In addition, we show that our representations capture the local similarity of graph pairs and the global similarity across families of graphs.

\ours{} has three key differentiators.
First, it makes no assumptions about the structure of the matching problem. 
In order to solve the matching problem, we propose an attention mechanism: \emph{isomorphism attention} to align the nodes across graph pairs.
Second, \ours{} does not rely on any existing heuristics for graph similarity.
Instead, we learn the kernel method jointly with the node representation and alignment networks.
This allows the model the freedom to learn representations that best preserve the graph, and does not impose artificial oversights.
Finally, as an unsupervised method, the representations it learns emphasize structural similarity, and does not correlate with a downstream labeling tasks.
This is especially useful for ranking tasks where labeling may not be available.

\noindent To summarize, our main contributions are:
\begin{itemize}
\item \textbf{Deep Divergence Graph Kernels}: A novel method for learning unsupervised representations of graphs and their nodes.
Our kernel is learnable and does not depend on feature engineering or domain knowledge. 
\item \textbf{Isomorphism Attention}:  A cross-graph attention mechanism to probabilisticly align representations of nodes between graph pairs.
These attention networks allow for great interpretablity of graph structure and discoverablilty of similar substructures.
\item \textbf{Experimental results}: We show that \ours{} both encodes graph structure to distinguish families of graphs, and when used as features, the learned representations achieve competitive results on challenging graph classification problems like predicting the functional roles of proteins.
\end{itemize}

\section{Learning Graph Representations}
In this section, we lay out the problem definition of representing graphs and the connection between our representations and the kernel framework.

\subsection{Problem Definition}

A graph is defined to be a tuple , where  is the set of vertices and  is the set of edges, .
A graph  can have an attribute vector  for each of its nodes or edges.
We denote the attributes of node  as , and denote the attributes of an edge (, ) as .

Given a family of graphs {, , , } we aim to learn a continuous representation for each graph  that encodes its attributes and its structure.
For this representation to be useful, it has to be comparable to other graph representations.
However, it is likely that our method of graph encoding will produce one of many equally good representations each time we run it.
For example we can get two different, but equal, representations by permuting the dimensions of the first one.
Those representations are not comparable given they exist in two different spaces.

To avoid this problem, we seek to develop an equivalence class across all possible encodings of a graph.
Essentially, two encodings of a graph are equivalent if they lead to the same pair-wise similarity scores when used to compare the graph to all other graphs in the set.
We note that this issue arises when working with embedding based representations across domains, and several equivalence methods have been proposed \cite{D16-1250,NIPS2018_7368}.

\subsection{Embedding Based Kernels}
In this work, we study the development of graph kernels, which are functions to compute the pairwise similarity between graphs.
Specifically, given two graphs , , a classic example of a kernel defined over graph pairs is the geometric random walk kernel \cite{borgwardt2005protein} as shown in Eq.\ \ref{eq:rwk}:

where  is the adjacency matrix of the product graph of  and , and  is a hyper-parameter which encodes the importance of each step in the random walk.
We aim to learn an embedding based kernel function  as a similarity metric for graph pairs, defined as the following:

For a dataset of  \emph{source}\footnote{In this paper, we use source and anchor interchangeably when referring to the encoded graph.} graphs  and  \emph{target} graphs (, for any member of the target graph set we define the  dimension of the representation  to be:

where  and  is a predictor of some structural property of the graph  but parameterized by the graph .
We note that the source and target graphs sets () could be disjoint, overlapping, or equal.

\begin{comment}
\subsection{Representation Properties}
We seek to learn graph representations through a process which has the following desirable
characteristics:

\begin{itemize}
    \item Unsupervised - the distance between graphs should be computable without side information
    \item Unaware (General)
    \item Self-aligning
    \item Can account for attribute information (both node and edge) attributes.
\end{itemize}

We detail the method that we design for this below.
\end{comment}

\section{Learning to Align Graph Representations}
\label{sec:aligngraphs}
We propose to learn a graph representation by comparing it to a population of graphs.
To compare the similarity of a pair of graphs (\emph{source}, \emph{target}), we rely on deep neural networks to measure the divergence between their structure and attributes.
First, we learn the structure of the source graph by passing it through a graph encoder.
Second, to measure how much the target graph diverges from the source graph,
we use the source graph encoder to predict the structure of the target graph.
If the pair is similar, we expect the source graph encoder to correctly predict the target graph's structure.
In this section, we develop the three key components necessary to learn the similarity between a pair of graphs.

First, in Section \ref{sec:encoding}, we discuss encoding graphs. 
The quality of the graph representation depends on the extent to which the encoder of each source graph is able to discover its structure.

Second, in Section \ref{sec:attention}, we propose a cross-graph attention mechanism to learn a soft alignment between graphs.
This is necessary because a target graph may not share its vertex ids with any of the source graphs -- indeed, they could even have differing number of nodes!
Therefore, we need to learn an alignment between the nodes of the target graph and each source graph.
This leads to an alignment that is not necessarily a one-to-one correspondence.


Third, in Section \ref{sec:attributes} we introduce additional constraints on the cross-graph attention learning.
For example, let us assume that  is assigned to .
While both  and  may be structurally similar, they may belong to different node classes as indicated by their attributes.
These attributes may be of significant importance to the nature of the graph.  For instance, swapping one element for another in a graph representing a molecule could drastically change its chemical structure.

We will see how these pairwise alignments can produce divergence scores suitable for Graph Kernels in Section \ref{sec:graph_kernels}.

\begin{figure}[t]
\centering
\includegraphics[width=\columnwidth]{figures/DDK-AE}
\caption{A Node-To-Edges Encoder.
Here the input graph contains 4 vertices, and the encoder has to predict the neighbors of vertex .
First,  is represented by a one-hot encoding .
Second,  is multiplied by a linear embedding layer.
Third, this embedding  is passed to a DNN which produces scores for each vertex in .
Finally, these scores are normalized using the \emph{sigmoid} function to produce the final predictions, in this case, \{, \}.}
\label{fig:ae}
\end{figure}




\subsection{Graph Encoding}
\label{sec:encoding}
To learn the structure of a graph, we train an encoder capable of reconstructing such structure given partial or distorted information.
In this paper, we choose a \emph{Node-To-Edges} encoder (Figure \ref{fig:ae}) for its simplicity, but we note that additional choices are certainly possible (see Section \ref{sec:extensions} for more discussion).
\paragraph{Node-To-Edges Encoder} -
In this setup, an encoder is given a single vertex and it is expected to predict its neighbors.
This can be modeled as a multilabel classification task since the predictions are not mutually exclusive.
Specifically, we are maximizing the following objective function ,

Each vertex  in the graph is represented by one-hot encoding vector .
Then to embed the vertex we multiply its encoding vector with a linear layer  resulting in an embedded vertex , where  is the number of vertices in the graph, and  is the size of the embedding space.

For graphs with a large number of nodes, we can replace this multiplication with a table lookup, extracting one row from the embedding matrix.
This embedding vector represents the feature set given to the encoder tasked with predicting all adjacent vertices.
Our encoder , is implemented as a fully connected deep neural network (DNN) with an output layer of size  and trained as a multilabel classifier.


\begin{figure}[t]
\includegraphics[width=\columnwidth]{figures/DDK-ATT}
\caption{Attention layers mapping the target graph nodes onto the source graph.
The augmented encoder has to predict the neighbors of node  in the target graph.
First, node  is passed to the attention layer which assigns it mainly to node  of the source graph.
Second, the source graph encoder learned earlier (in Figure \ref{fig:ae}) that the neighbors of node  are \{, \}.
Finally, the reverse attention network maps nodes \{, \} of the source graph to nodes \{, , \} of the target graph which are the neighbors of node .
}
\label{fig:attention}
\end{figure}



\subsection{Cross-Graph Attention}
\label{sec:attention}
So far, we have developed a utility to encode individual graphs. 
However, we seek to develop a method which can compare pairs of graphs, which may  differ in size (differing node sets) and structure (differing edge sets). 
For this to happen we need a method of learning an alignment between the graphs. Ideally this method will operate in the absence of a direct mapping between nodes.



In other areas, attention models have been proposed to align structured data.
For example, attention models have been proposed to align pairs of images and text \cite{xu2015show}, pairs of sentences for translation \cite{vaswani2017attention}, and pairs of speech and transcription \cite{NIPS2015_5847}.
Inspired by these efforts, we formalize the problem of aligning two graphs as that of attention.
We propose an attention mechanism, \emph{isomorphism attention}, that aligns the nodes of a target graph against those of a source graph.


\subsubsection{Isomorphism Attention}
Given two graphs  (\emph{source graph}) and  (\emph{target graph}), we propose a model that allows bi-directional mapping across the pair's nodes.
This requires two separate attention networks.
The first network allows nodes in the target graph to \emph{attend} to the nodes in the source graph.
The second network, allows neighborhood representations in the source graph to \emph{attend} to neighborhoods in the target graph.

We denote the first attention network as (), which assigns every node in the target graph  a probability distribution over the nodes of the source graph .
This attention network will allow us to pass the nodes of the target graph as an input to the source graph encoder.
We implement this attention network using a multiclass classifier,

The second network is a \emph{reverse attention} network () which aims to learn how to map a neighborhood's representation in the source graph to a neighborhood in the target graph.
By adding both attention networks to the source graph encoder, we will be able to construct a target graph encoder that is able to predict the neighbors of each node -- but utilizing the structure of the source graph.
We implement the reverse attention as a multilabel classifier,

Figure \ref{fig:attention} shows the attention network () receiving a one-hot encoding vector representing a node () in the target graph and mapping it onto the most structurally similar node () from the source graph.
The source graph encoder, then, predicts the neighbors of , .
The \emph{reverse attention} network (), takes  and maps them to the neighbors of , .


Both attention networks may be implemented as linear transformations .
In the case that either  or  are prohibitively large, the attention network parameters can be decreased by substituting a DNN with hidden layers of fixed size.
This will reduce the attention network size from  to .

\subsection{Attributes Consistency}
\label{sec:attributes}
Labeled graphs are not defined only by their structures, but also by the attributes of their nodes and edges.
The attention network assigns each node in the target graph a probability distribution over the nodes of the source graph.
There might be several, equally good, nodes in the source graph with similar structural features.
However, these nodes may differ in their attributes.
To learn an alignment that preserves nodes and edges attributes, we add regularizing losses to the attention and reverse-attention networks.

More specifically, we refer to the nodes as  and  for the source and target graphs, respectively.
We refer to the set of attributes as  and the distribution of attributes over the graph nodes as .
Given that the attention network  learns the distribution ,
we can calculate a probability distribution over the attributes as inferred by the attention process as the following:


\noindent We define, the attention regularizing loss over the nodes attributes to be the average cross entropy loss between the observed distribution of attributes and the inferred one (See Eq. \ref{eq:lattnodes}).

where  is the number of nodes in the target graph.

For preserving edge attributes over nodes, we define  to be the normalized attributes count over all edges connected to the node .
For instance, if a node  has 5 edges with 2 of them colored red and the other three colored yellow, 
By replacing  with  in Equations \ref{eq:attrdistnodes} and \ref{eq:lattnodes}, we create a regularization loss for edge attributes.

We also introduce these regularization losses for \emph{reverse attention} networks.
Reverse attention networks maps a neighborhood in the source graph to a neighborhood in the target graph.
The distribution of attributes over a node's neighborhood will be the frequency of each attribute occurrence in the neighborhood normalized by the number of attributes appearing in the neighborhood.
For edges, the node's neighborhood edges are the edges appearing at 2-hops distance from the node.
Similarly, we can define the probability of the edges attributes by normalizing their frequencies over the total number of attributes of edges connected to the neighborhood.


\section{Deep Divergence Graph Kernels}
\label{sec:graph_kernels}

So far, we have proposed a method for learning representations of graphs, and an attention mechanism for aligning graphs based on a set of encoded graph representations. 
Here we discuss our proposed method for using the alignment to construct a graph kernel based on divergence scores.
First, in Section \ref{sec:div}, we show how we can utilize the divergence scores to construct a full graph representation.
Divergence is driven by the target graph structure and attribute prediction error as calculated using a source graph encoder.
Next  we introduce DDGK, our method for learning graph representations for Deep Divergence Graph Kernels in Section \ref{sec:alg_ddgk}.
Then in Section \ref{sec:training} we discuss how we train these representations.
Finally we discuss the scalability of this approach in Section \ref{sec:scalability}.


\subsection{Graph Divergence}
\label{sec:div}
In Section \ref{sec:aligngraphs} we presented a method to align two graphs by using a source graph encoder, augmented with attention layers, to encode a target graph.
Here, we propose to use the ability of the augmented encoder at predicting the structure of the target graph as a measure of those graphs similarity.
To explain, let us assume the trivial case where both the source and target graphs are identical.
First, we train the source graph encoder.
Second, we augment it with attention networks and train it to predict the structure of the target graph.
The attention networks will (ideally) learn the identity function.
Therefore, the source graph encoder is able to encode the target graph as accurately as encoding itself.
We would reasonably conclude that these graphs are similar.

We aim to learn a metric that measures the divergence score between a pair of graphs .
If two graphs are similar, we expect their divergence to be correspondingly low.
We refer to the encoder trained on a graph  as  and the divergence score given to the target graph  to be  



\noindent Given that  is not a perfect predictor of the graph  structure, we can safely assume that .
To rectify this problem we define

which sets  to zero.

We note that this definition is not symmetric (as  might not necessarily equal to ).
If symmetry is required, we can define .

\subsection{Graph Embedding}
Given a set of source graphs, we can establish a vector space where each dimension corresponds to one graph in the source set.
Target graphs are represented as points in this vector space where the value of the  dimension for a given target graph  is .

More formally, for a set of  source graphs we can define our target graph representation to be:


\noindent To create a kernel out of our graph embeddings, we use the Euclidean distance measure as outlined in Eq \ref{eq:our_kernel}.
This distance measure will guarantee a positive definite kernel \cite{haasdonk2004learning,wu2018d2ke}.

\subsection{Algorithm : \textsc{DDGK}}
\label{sec:alg_ddgk}

\IncMargin{1em}
\begin{algorithm}[t!]
\SetKwArray{Encodings}{encodings}
\SetKwArray{Embedding}{}
\SetKwFunction{GraphDivergence}{GraphDivergence}
\SetKwFunction{GraphEncode}{GraphEncode}
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\Input{
Set of  source graphs  \\ 
Set of  target graphs  \\ 
Learning rate  \\
Encoding epochs  \\
Scoring epochs 
}
\Output{All graph representations
}

\emph{// learn graph encodings}

\ForEach{}{
\\

\For{ \KwTo }{
 \label{encoding:loss} \\
 \label{encoding:update} \\
}
\Encodings{i}\\
}

\ForEach{}{
 \\
\ForEach{}{

\emph{// learn cross-graph attention  and } \\

\For{ \KwTo }{
 \label{divergence:loss} \\
 \label{divergence:update1} \\
 \label{divergence:update2} \\
}

\emph{// calculate graph divergences} \\

\Embedding{i, j}\\
}
}

\KwRet{\Embedding}
\caption{
DDGK: An unsupervised algorithm for learning graph representations.}
\label{algorithm:ddgk}
\end{algorithm}\DecMargin{1em}

We present pseudo-code for \ours{} in Algorithm \ref{algorithm:ddgk}. 
The algorithm has two parts. First, a \emph{Node-To-Edges} encoder is trained for all source graphs (Algorithm \ref{algorithm:ddgk} line~\ref{encoding:loss} and line~\ref{encoding:update}). 
Second, cross-graph attentions are learned for all target-source graph pairs (Algorithm \ref{algorithm:ddgk} line~\ref{divergence:loss}, line~\ref{divergence:update1} and line~\ref{divergence:update2}). 
We implement \ours{} using a deep neural network for its \emph{Node-To-Edges} encoder and linear transformations for its isomorphism attention. 

\begin{figure*}[t]
    \begin{subfigure}[b]{0.33\textwidth}
        \includegraphics[scale=0.25]{figures/no_reg.pdf} \includegraphics[scale=0.25]{figures/attention_no_reg.pdf}
        \caption{No attributes.}
        \label{fig:graph_no_reg}         
    \end{subfigure}
    \begin{subfigure}[b]{0.33\textwidth}
        \includegraphics[scale=0.25]{figures/node_reg.pdf}
        \includegraphics[scale=0.25]{figures/attention_node_reg.pdf}
        \caption{Labeled nodes.}
        \label{fig:graph_node_reg}        
    \end{subfigure}
    \begin{subfigure}[b]{0.33\textwidth}
        \includegraphics[scale=0.25]{figures/node_edge_reg.pdf}  \includegraphics[scale=0.25]{figures/attention_node_edge_reg.pdf}
        \caption{Labeled nodes and edges.}
        \label{fig:graph_edge_node_reg}        
    \end{subfigure}
    \caption{The effect of attributes preserving losses on the attention networks.
    Our method is given a pair of identical graphs, the upper graph represents the target and the other represents the source graph.
    Each graph consists of two rings of size  connected with one edge ((, ) and (, ) respectively).
    We visualize the strongest attention weights as cross-graph edges.
    On the right of each figure we visualize the rest of the attention weights as a heatmap.
    When the graph attends to itself without attribute preserving losses, there are several solutions that are equally good because of several symmetries available.
    Once we add the nodes attributes, we can see an immediate effect where the nodes from the same label class attend only to each other. This behavior further intensifies after also adding the edge attributes.
    }
    \label{fig:attention_viz}     
\end{figure*}

\subsection{Training}
\label{sec:training}
We implement our models using TensorFlow \cite{tensorflow},
calculate our gradients using backpropagation, and update our parameters using Adam \cite{kingma2014adam}.
We train each source graph on its adjacency matrix for a constant number of iterations.

\subsubsection{Target Graph Encoding}
Here, the augmented encoder has to predict the neighboring vertices for each vertex in the target graph with the help of the attention and reverse-attention layers.
To learn the augmented target graph encoder (which consists of the source graph encoder with the additional attention layers), we use the following procedure:
\begin{enumerate}
    \item First, freeze the parameters of the source graph encoder.
    \item Second, add two additional networks, one for attention and another for reverse attention mapping between the target graph nodes to the source graph nodes and vice versa.
    \item Third, add the regularizing losses to preserve the nodes or edges attributes if they are available.
    \item Fourth, train the augmented encoder on the input, which is the adjacency matrix of the target graph, and a node attribute and/or edge attribute matrix (if available).
\end{enumerate}
\noindent Finally, once the training of the attention layers is done, we use the augmented encoder to compute the divergence between the graph pair as discussed in \ref{sec:div}.

\subsection{Scalability}
\label{sec:scalability}
We start by defining the following quantities:
 the number of source graphs in the dataset,
 the number of target graphs in the dataset,
 the average number of nodes,
 the number of epochs to encode source graphs,
 the number of epochs to encode target graphs,
 the number of encoder hidden layers,
 the number of attention hidden layers, and
 the embedding and hidden layer size

Our method relies on pairwise similarity, therefore, we will have  computations that each involves scoring a target graph against one source graph.
Training a source graph encoder requires  steps that each involves  computations.
In addition to running the source graph encoder, the target graph alignment learns the attention networks which represents .
If we define , , and 
then the total computation cost is 
.
Because  is likely much larger than , we interpret the computational complexity as .

In Section \ref{sec:sampling}, we explore the effect of sampling to hasten \ours{}'s runtime on large datasets.  
We show that not all  comparisons are necessary to achieve high performance: empirically, it seems that less than  of source graphs are required, significantly speeding our approach.


\section{Experiments}
In this section, we demonstrate our method through a series of qualitative and quantitative experiments.
First, we show how our attention based alignment works under different conditions.
Then, we show how our representations are capable of capturing the structure of the space of graphs by applying hierarchical clustering on the kernel space.
Finally, we show that the learned graph embeddings represent a sufficient feature set to predict the graph label on several challenging classification problems in real-world biological datasets.

\subsection{Cross-Graph Attention}

In this qualitative experiment, we seek to understand how two graphs are related to each other.
Comparing different patterns between different graphs is an important application in domains such as biology.

Figure \ref{fig:graph_no_reg} shows two identical unlabeled barbell graphs.
Each graph consists of two rings of size  connected with the edge (, ) and (, ).
The upper graph represents the target graph while the lower one represents the source graph.
The edges connecting the source and target graphs represent the strongest attention weights for each node in the target graph.
The heatmap shows the full attention matrix for more thorough analysis.
Aligning these identical graphs is an easy task for the naked eye.
However, our method can find many possible symmetries to exploit while still achieving perfect predictions.
For example, nodes in the left ring can attend to the right ring of the source graph and vice versa.

Figure \ref{fig:graph_node_reg} shows the previous setup with labeled graph nodes.
This introduces a regularizing loss to preserve the node attributes.
The attention heat map shows significant weights for the upper left and lower rights quadrants.
The right ring does not attend to nodes in the left ring anymore, and vice versa.
Still we can see the method exploiting symmetries within the same ring.

Finally, by also adding edge labels, the alignment problem is constrained enough that the attention heatmap is concentrated along the diagonal (See Figure \ref{fig:graph_edge_node_reg}).
We can observe that the attention edges correspond in a one-to-one relationship between the target and source graphs.
This synthetic experiment shows the effect of attribute preserving losses on learning the alignment between graphs.


\subsection{Hierarchical Clustering}
To understand the global structure of the graph embedding space, we explore it qualitatively using hierarchical clustering.
First, we create a dataset which is a composition of 6 different families of graphs.
Three graph families are mutated graphs and three families are subset of a larger set of realistic graphs.
From each family we sample 5 graphs, creating a universe of 30 graphs.
Then, we embed the graphs using our method constructing a graph embedding space.
Finally, we cluster the embeddings according to their pairwise euclidean distances.

\subsubsection{Mutated Graphs}
For these datasets we start with a known graph and generate a sequence of mutations to produce a family of graphs.
In particular, we consider the following graphs.

\begin{itemize}
     \item C. Elegans \cite{watts1998collective}: represents the neural network of the C. Elegans worm.
     \item Karate Club \cite{ZacharyKarate}: social network of friendships between 34 members of a karate club.
     \item Word Network \cite{NewmanWordNetwork}: adjacency network of common adjectives and nouns in the novel David Copperfield by Charles Dickens.
 \end{itemize}

In order to generate a family  for each original graph , we employ the following mutation procedure.
At each of the  time steps, there is a  chance of performing an edge deletion or addition.
For additions, we select the two nodes to connect from any unlinked nodes according to the preferential attachment model characterized by  \cite{chung2006complex}.
For deletions, we select an edge at random and remove it.
We run this procedure for 4 times with  time steps, creating a family of 5 related graphs.
The initial seed for any of these mutations is denoted by the suffix ``-0".

\subsubsection{Realistic Graphs}
We randomly pick 5 graphs from three of the real-world families of graphs we consider (\textbf{D\&D}, \textbf{PTC}, and \textbf{NCI1}).
See Section \ref{sec:datasets} for more information about these graphs.

Figure \ref{fig:clusters30} shows the result of clustering the pairwise distances between our graph embeddings.
We are able to retrieve perfect clusters of \{\texttt{c-elegans}, \texttt{words}\} where there are clusters of size of 5 that consist only of graphs of the same type.
For \{\textbf{NCI1}, \textbf{D\&D\}}, we can cluster 4 graphs out of 5 before adding a graph which is out of the family.

\begin{figure}
    \centering
    \includegraphics[width=\columnwidth]{figures/clustering.pdf}
    \vspace{3mm}
    \caption{A hierarchical clustering of the graph kernel space for several different graph families.  It shows 30 graphs that belong to 6 different families.
    The values of the matrix are the pairwise Euclidean distances between the graph embeddings.
    }
    \label{fig:clusters30}
\end{figure}



\subsection{Graph Classification}



Our learned graph representations respect both attributes and structure.
They can be used for graph classification tasks where the graph structure, node attributes, and/or edge attributes convey meaning or function.
To demonstrate this, we use \ours{} representations of several chemo- and bio- informatics datasets as features for classification tasks.
We report our results against both unsupervised and supervised methods.




\subsubsection{Hyper-parameters Search}
To choose \ours{} hyperparameters (See Table \ref{table:ddgkparams}), we perform grid searches for each dataset.
We create splits of each dataset to avoid over-fitting, they are: \{\texttt{train}, \texttt{dev}, \texttt{test}\}.
We use the scikit-learn SVM \cite{pedregosa2011scikit} as our classifier, and we vary the kernel choices between \{\texttt{linear}, \texttt{rbf}, \texttt{poly}, \texttt{sigmoid}\} and the regularization coefficient  between  and .
We choose the hyper-parameters of both \ours{} and the classifier that maximize the accuracy on the \texttt{dev} dataset.

\begin{table}[tb]
\begin{tabular}{l|l}
\textbf{Hyper-Parameter}& \textbf{Values}\\\hline
Node embedding &  \\ 
Encoder layers &  \\
Learning rate & , , , ,  \\
Encoding epochs &  \\
Scoring epochs &  \\
Node preserving loss coefficient &  \\ 
Edge preserving loss coefficient &  \\ 
\end{tabular}
\vspace{3mm}
\caption{Values used during our grid search for  \ours{} graph representations learning hyper-parameters.}
\label{table:ddgkparams}
\end{table}


\begin{table}[tb]
\begin{tabular}{l|rrccrc}
&\thead{\bf \#\\\bf Graphs}
&\thead{\bf Average\\\bf Nodes}
&\thead{\bf Average\\\bf Edges}
&\thead{\bf \#\\\bf Labels}
&\thead{\bf \# Node\\\bf Labels}
&\thead{\bf \# Edge\\\bf Labels}
\\\hline
D\&D &  &   &   &  &  &  \\
NCI1 &  &  &  &  &  &  \\
PTC &  &  &  &  &  &  \\
MUTAG &  &  &  &  &  &  \\
\end{tabular}
\vspace{3mm}
\caption{Statistics of the chemo- and bio-informatics datasets.}
\label{table:datasetprop}
\end{table}

\begin{table*}[ht]
\begin{tabular}{ll|lll|llll}
\textbf{Method} & &\rotatebox[origin=l]{90}{\tiny \bf Unsupervised}&\rotatebox[origin=l]{90}{\tiny \bf No Weisfeiler-Lehman}&\rotatebox[origin=l]{90}{\tiny \bf No Feature Engineering} &\textbf{D\&D}&\textbf{NCI1}&\textbf{PTC}&\textbf{MUTAG}\\\hline


PSCN & \cite{patchysan} &&&  &  &  &   &   \\
DGCNN & \cite{zhang2018end} &&&  &  &  &   &   \\







\hline

SP Kernel & \cite{borgwardt2005shortest} &\cmark&&  &   &  &   &  \\  
WL Kernel & \cite{kriege2016valid} & \cmark &&  &   &  &   &   \\
WL-OA & \cite{kriege2016valid} & \cmark && &  &  &   &   \\

DGK & \cite{yanardag2015deep} & \cmark &&  &  &  &   &   \\

graph2vec & \cite{graph2vec} & \cmark &&  &  &  &   &   \\

S2S-N2N-PP & \cite{taheri2018RNN} & \cmark && &  &  &  &   \\
\hline
node2vec & \cite{node2vec} & \cmark  & \cmark &  &   &  &   &   \\

\hline
\ours{} & (this paper)  & \cmark & \cmark & \cmark&   &   &  &  \\
\end{tabular}
\vspace{3mm}
\caption{Average accuracy in ten-fold cross validation on our graph classification task. 
Methods are grouped by their level of supervision during the similarity metric learning, whether they use algorithm insights the Weisfeiler-Lehman algorithm, and  whether they use feature engineering (e.g. graph motifs, random walks, etc.).
Baseline results taken from \cite{patchysan,kriege2016valid,taheri2018RNN} (missing results are missing from these works).
We note that \ours{} performs surprisingly competitively for an unsupervised method with no hard-coded insights.
}
\label{table:results}
\end{table*}
 
\subsubsection{Datasets}

\label{sec:datasets}
Four benchmark graph classification datasets from chemo- and bio-informatics domains are used. The datasets include \textbf{D\&D}, \textbf{NCI1}, \textbf{PTC} and \textbf{MUTAG}.
All datasets include node labels.
The \textbf{PTC} and \textbf{MUTAG} datasets also include edge labels.
Table \ref{table:datasetprop} shows network statistics for each dataset.
The datasets:
\begin{itemize}
\item \textbf{D\&D} \citep{dobson2003distinguishing}:   contains 1178 proteins labeled as enzymes or non-enzymes.
\item \textbf{NCI1} \citep{45b3e5c6d2ee4938b77995a88ee0b928}: contains 4110 chemical compounds labeled as active or inactive against non-small cell lung cancer.
\item \textbf{PTC} \citep{toivonen2003statistical}: contains 344 chemical compounds labeled according to their carcinogenicity in male rats.
\item \textbf{MUTAG} \citep{doi:10.1021/jm00106a046}:  contains 188 mutagenic aromatic and heteroaromatic compounds labeled according to their mutagenic effect on a specific gram negative bacterium.
\end{itemize}

\subsubsection{Results}

The results of these experiments are presented in Table \ref{table:results}.
We see that \ours{} is quite competitive, with higher average performance on both the \textbf{D\&D} and \textbf{MUTAG} datasets than any of the baselines.  
This is especially surprising given that the supervised methods have additional information available to them.
We note that \ours{} achieves its strong results without engineered features, or access to information from Weisfeiler-Lehman kernels.
For \textbf{PTC}, we also see that \ours{} attains competitive performance against all other methods, only being outperformed by 2 of the 9 baselines.
Finally, on \textbf{NCI1}, we see that \ours{} performs better than the method using the most similar kind of information (\texttt{node2vec}), but find that baselines using the WL kernel perform best on this dataset (indeed, the WL kernel itself takes the top two spots).
We find this dependence quite interesting, and will seek to characterize it better in future work.

\subsection{Dimension Sampling}
\label{sec:sampling}
So far, we have been setting the source graphs set to be equal to the target graphs set.
This pairwise computation is quite expensive for large datasets.
To reduce the computational complexity of our method, we study the effect of sub-sampling the dimensions of our graph embedding space on the quality of graph classification.

To do that, we  construct a source graph set that is a subset of the original graph set.
We learn divergence scores for all target graphs against this subset.
We use the reduced embeddings as features to predict graph categories.
Figure \ref{fig:sampling} shows that we are able to achieve stable and competitive results with less than 20\% of the graphs being used as source graphs.

\begin{figure}
    \centering
    \includegraphics[width=\columnwidth]{figures/sampling.pdf}
    \caption{Effect of sub-sampling source graphs on graph classification tasks.  Here we vary the number of source graphs available to each method, and observe that very few dimensions are needed to achieve our final classification performance (less than  of the dimensions for the datasets considered).}
    \label{fig:sampling}
\end{figure}

\section{Related Work}

The main differences between our proposed method and
previous work can be summarized as follows:
\begin{enumerate}
\item We are an unsupervised method, taking only a graph as input.
\item We use no domain-specific information about what primitives are important in a graph, using only the edges.
\item We use no algorithmic insights from the literature in graph isomorphism (e.g.\ the Weisfeiler-Lehman kernel).
\item We assume nothing about the mapping of node ids between graphs, instead learning the alignment.
\end{enumerate}

\noindent While many approaches exist that contain at least one of these differentiators, we are, to the best of our knowledge, the only proposed method that meets all four of these conditions. 
In this section we will briefly cover related work in graph similarity and other applications of neural networks to graph representation.

\subsection{Unsupervised Graph Similarity}

We divide our brief survey of the literature into three kinds of unsupervised methods for graph similarity.
The first seeks to explicitly define a kernel over graph features, or use the intuition from such a kernel as part of the representation learning process.
The second focuses on the representation of individual elements of the graph, learning primitives that maximize some kind of reconstruction of the graph.  
The third group of work constructs a similarity function between graphs by an explicit vector of statistical features constructed by the graph.



\noindent \textbf{Traditional Graph Kernels}:
There has been considerable work done on unsupervised methods for graph kernel learning.
Initial efforts in the area focused on theoretical views of the problem, defining graph similarity via the Graph Edit Distance \cite{gao2010survey} or the size of the Maximum Common Subgraph \cite{bunke2002comparison} between graphs.  Unfortunately these problems are both NP-Complete in the general case, require a known correspondence between the nodes of the two graphs of interest.

Many approaches are built around the graph similarity measure computed by the Weisfeiler-Lehman (WL) subtree graph kernel \citep{shervashidze2011weisfeiler,kriege2016valid}.  
At its core, the WL algorithm collapses the labels of a node's neighbors into a ordered sequence, and then hashes that sequence into a new label for the node.
This process repeats iteratively to average information over the neighborhood together.
Other functions that use different types of predefined features for graph similarity, such as shortest-paths kernels \cite{borgwardt2005shortest}, and random walk kernels \cite{kashima2003marginalized} have also been proposed, but their naive implementations suffer from high asymptotic complexity ( and , respectively).
Faster implementations of these kernels have been proposed \cite{borgwardt2007fast,kang2012fast}.
Some unsupervised methods also focus on extending the algorithm intuition of these classic approaches to the problem.
For instance \cite{taheri2018RNN} learns a representation for each position in a WL ordering jointly while learning a graph representation.

Unlike all of these approaches, our method deliberately avoids algorithmic insights.  
Our proposed isomorphism attention mechanism allows capturing higher-order structure between graphs (beyond immediate neighborhoods).


\noindent \textbf{Node embedding methods}: Since DeepWalk \cite{deepwalk} proposed embedding the nodes via a sequence of random walks, the problem of node representation learning has received considerable attention \cite{perozzi2017don,node2vec,chen2017harp,tsitsulin2017verse,bojchevski2017deep,abu2018watch,aepasto2019}.  In general, all of these methods utilize insights about similarity functions which are important to the graph.
While these methods seek the best way to represent nodes, the representations are learned independently between graphs, which makes them generally unsuitable for graph similarity computations.
For more information on this area, we recommend recent surveys in the area \cite{chen2018tutorial,cui2018survey}.
Unlike these methods, our goal is to learn representations of graphs, not of nodes.

\noindent \textbf{Graph statistics}:
Finally, another family of unsupervised graph similarity measures define a hand-engineered feature vector to compute graph similarity.  
The NetSmilie method \cite{berlingerio2012netsimile} operates by constructing a fixed size feature value of graph statistics and uses this as a similarity embedding over graphs.  
Similarly, DetlaCon \cite {koutra2013deltacon} defines the similarity over two graphs with known node-to-node mapping via the similarity in their propagation of belief, and \cite{papadimitriou2010web} proposes a number of similarity measures over directed web graphs.

Unlike these methods, \ours{} does not explicitly engineer its features for the problem.  Instead, the similarity is learned function directly from the edges present in the adjacency matrix, with no assumptions about which features are important for the application task.



\subsection{Supervised Graph Similarity}
The first class of supervised methods uses some supervision to inform a similarity function constructed over different hand-engineered graph features.

A number of supervised approaches also utilize intuitions from the Weisfeiler-Lehman graph kernel.
\texttt{Patchy-SAN} \citep{niepert2016learning} proposes an approach for convolutional operations on graph structured data.  The core of their method uses the ordering from the WL kernel to order the nodes of a rooted subgraph into a sequence, and then apply standard 1-dimensional convolutional filters.
This approach is further generalized by \citep{zhang2018end}, who use the WL ordering to sort a graph sample in a pooling layer.
Another branch of work has focused on extending the Graph Convolutional Networks (GCNs) proposed by \cite{kipf-gcn} to perform supervised classification of graphs.
Proposed extensions include a pooling architecture that learns a soft clustering of the graph \citep{ying2018hierarchical}, or a two-tower model which frames graph similarity as link prediction between GCN representations \cite{bai2018graph}.
Interestingly, it has been shown that many of these methods are not necessarily more expressive than the original Weisfeiler-Lehman subtree kernel itself \cite{morris2018weisfeiler}.

Unlike all of these approaches, our method learns representations of graphs without supervision --- we use no labels about the class label of a graph, and no external information about which pairs of graphs are related.
Our proposed isomorphism attention mechanism allows capturing higher-order structure between graphs (beyond immediate neighborhoods).




\section{Extensions \& Future Work}
\label{sec:extensions}
Here we briefly discuss a number of areas of future investigation for our method.

\subsection{Graph Encoders}
Given the choice of input and reconstructed output, several additional graph encoders are possible, in addition to the Nodes-To-Edges encoder which we used in this work.  To mention a few options:

\paragraph{Edge-To-Nodes Encoder} -
This encoder is trained to predict the source and destination vertices given a specific edge.
Similar to the \emph{Node-To-Edges} encoder, this could be expressed as a multilabel classification task with the following objective function,

Note that the number of edges in a graph could grow quadratically, therefore, iterating over the edges is more expensive than the nodes.

\paragraph{Neighborhood Encoder} -
In this case, the encoder is trained to predict a set of vertices or edges that are beyond the immediate neighbors.
Random walks could serve as a mechanism to calculate a neighborhood around a specific node or edge.
Given a partial random walk, the encoder has to predict the vertices that could have been visited within a specific number of hops.



\subsection{Attention Mechanism}
We proposed a simple attention mechanism which uses node-to-node alignment.
As we discussed in Section \ref{sec:scalability}, we could replace the linear layer with a deep neural network to reduce the size of the model if scability is an issue.
While node-to-node alignment enhances the interpretability of our models, subgraph alignment could lead to better and easier understanding of how two graphs are similar.
Hierarchical attention models \cite{yang2016hierarchical} could lead to higher levels of abstractions which could learn community structure and which communities are similar across a pair of graphs.
Hierarchy has already been used within the context of learning better node embeddings, for example \citep{ying2018hierarchical} showed that a better understanding of the graph substructure can lead to better graph classification.
Therefore, we believe extending the work beyond node-to-node alignment will significantly improve our results.


\subsection{Regularization}
We proposed attribute based losses to regularize our isomorphism attention mechanism.
The graph encoder capacity was adjusted according to the source graph size.
However, the source graph encoder could still suffer from overfitting which would reduce its utility in recognizing similar target graphs.
Therefore, further research is necessary to understand the relation between the encoder training characteristics and the quality of the generated divergence scores

\subsection{Feature Engineering}
In this work we have focused on developing an approach for representing graphs that operated without any feature engineering or algorithmic insights.
While this willful ignorance has allowed us to design a new paradigm for graph similarity, we suspect that there are many fruitful combinations of this idea with other approaches for graph classification.
For example, the graph embeddings we learn could be used as additional features for approaches based on learning supervised classifiers over graphs.


\section{Conclusion}
In this work, we have shown that neural networks can learn powerful representations of graphs without explicit feature engineering.
Our proposed method, Deep Divergence Graph Kernels, learns an encoder for each graph to capture its structure, and uses a novel \textit{isomorphism preserving attention mechanism} to align node representations across graphs without the use of supervision.
We show that representing graphs by their divergence from different source graphs provides a powerful embedding space over families of graphs.
Our proposed model is both flexible and amenable to extensions.
We illustrate this by proposing extensions to handle many commonly occurring varieties of graphs, including graphs with attributed nodes, and graphs with attributed edges.



Our experimental analysis shows that despite being trained with only the graph's edges (and no feature engineering) the learned representations encode a variety of local and global information.
When the representations produced by \ours{} are used as features for  graph classification methods, we find them to be competitive with challenging baselines which use at least one of graph labels, engineered features, or the Weisfeiler-Lehman framework.
In addition to being powerful, \ours{} models are incredibly informative.
The learned isomorphism attention weights allow a level of insight into the alignment between a pair of graphs, which is not possible with other deep learning methods developed for graph similarity.


Unsupervised representation learning for graphs is an important problem, and we believe that the method of Deep Divergence Graph Kernels we have introduced here is an exciting step forward in this area.
As future work, we will investigate 1) enhanced method for choosing informative source from the space of all graphs, 2) improving the architecture of our encoders and attention models, 3.) making it easier to reproduce research results in the area of graph similarity, and 4) making graph similarity models even easier to understand.



\newpage
\bibliographystyle{ACM-Reference-Format}
\bibliography{references}

\end{document}
