
\documentclass{article} \usepackage{iclr2019_conference,times}
\usepackage{pgfplots,capt-of}
\usepackage{graphicx} 
\usepackage{booktabs}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{hyperref}
\usepackage{url}

\usepackage{pgfplots,capt-of}
\pgfplotsset{tick pos = left}
\usepgfplotslibrary{colorbrewer}
\usepackage{subfigure}
\usepackage{xcolor}

\newenvironment{tight_enumerate}{
\begin{enumerate}
  \setlength{\itemsep}{1pt}
  \setlength{\parskip}{0pt}
}{\end{enumerate}}

\title{Improved Language Modeling by Decoding the Past}


\author{Siddhartha Brahma\\
IBM Research, Almaden, USA\\
\texttt{brahma@us.ibm.com} 
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}



\maketitle

\begin{abstract}
Highly regularized LSTMs achieve impressive results on several benchmark datasets in language modeling. 
We propose a new regularization method based on decoding the last token in the context using the predicted
distribution of the next token. This biases the model towards retaining more contextual information, in turn improving its ability to predict the next token. With negligible overhead in the number of parameters and training time, our Past Decode Regularization (PDR) method achieves a word level perplexity of 55.6 on the Penn Treebank and  63.5 on the WikiText-2 datasets using a single softmax. We also show gains by using PDR in combination with a mixture-of-softmaxes, achieving a word level perplexity of 53.8 and 60.5 on these datasets. In addition, our method achieves 1.169 bits-per-character on the Penn Treebank Character dataset for character level language modeling. These results constitute a new state-of-the-art in their respective settings.



\end{abstract}


\section{Introduction}
Language modeling is a fundamental task in natural language processing. Given a sequence of tokens, its joint probability distribution can be modeled using the auto-regressive conditional factorization. This leads to a convenient formulation where a language model has to predict the next token given a sequence of tokens as context. Recurrent neural networks are an effective way to compute distributed representations of the context by sequentially operating on the embeddings of the tokens. These representations can then be used to predict the next token as a probability distribution over a fixed vocabulary using a linear decoder followed by Softmax. 

Starting from the work of \cite{Mikolov2010RecurrentNN}, there has been a long list of works that seek to improve language modeling performance using more sophisticated recurrent neural networks (RNNs) (\cite{Zaremba2014RecurrentNN, Zilly2017RecurrentHN, Zoph2016NeuralAS, Mujika2017FastSlowRN}). 
However, in more recent work vanilla LSTMs (\cite{Hochreiter1997}) with relatively large number of parameters   have been shown to achieve state-of-the-art performance on several standard benchmark datasets both in word-level and character-level perplexity (\cite{Merity2018,Merity2018AnAO,Melis2018,Yang2017BreakingTS}). A key component in these models is the use of several forms of regularization e.g. variational dropout on the token embeddings (\cite{Gal2016ATG}), dropout on the hidden-to-hidden weights in the LSTM (\cite{Wan2013RegularizationON}), norm regularization on the outputs of the LSTM and classical dropout (\cite{Srivastava2014DropoutAS}). By carefully tuning the hyperparameters associated with these regularizers combined with optimization algorithms like NT-ASGD (a variant of the Averaged SGD), it is possible to achieve very good performance. Each of these regularizations address different parts of the LSTM model and are general techniques that could be applied to any other sequence modeling problem. 

In this paper, we propose a regularization technique that is specific to  language modeling. One unique aspect of language modeling using LSTMs (or any RNN) is that at each time step , the model takes as input a particular token  from a vocabulary  and using the hidden state of the LSTM (which encodes the context till ) predicts a probability distribution  on the next token  over the same vocabulary as output. Since   can be mapped to a trivial probability distribution over , this operation can be interpreted as transforming distributions over  (\cite{Inan2016TyingWV}). Clearly, the output distribution is dependent on and is a function of  and the context further in the past and encodes information about it. We ask the following question -- How much information is it possible to decode about the input distribution (and hence )  from the output distribution ? In general, it is impossible to decode   unambiguously. Even if the language model is perfect and correctly predicts  with probability 1, there could be many tokens preceding it. However, in this case the number of possibilities for  will be limited, as dictated by the bigram statistics of the corpus and the language in general. We argue that biasing the language model such that it is possible to decode more information about the past tokens from the predicted next token distribution is beneficial. We incorporate this intuition into a regularization term in the loss function of the language model. 

The symmetry in the inputs and outputs of the language model at each step lends itself to a simple decoding operation. It can be cast as a (pseudo) language modeling problem in ``reverse", where  the future prediction  acts as the input and the last token  acts as the target of prediction. The token embedding matrix and weights of the linear decoder of the main language model can be reused in the past decoding operation. We only need a few extra parameters to model the nonlinear transformation performed by the LSTM, which we do by using a simple stateless layer. We compute the cross-entropy loss between the decoded distribution for the past token and  and add it to the main loss function after suitable weighting. The extra parameters used in the past decoding are discarded during inference time. We call our method \emph{Past Decode Regularization} or \textbf{PDR} for short. 

We conduct extensive experiments on four benchmark datasets for word level and character level language modeling by combining PDR with existing LSTM based language models and achieve new state-of-the-art performance on three of them.  
\section{Past Decode Regularization (PDR)}
Let  be a sequence of tokens. In this paper, we will experiment with both word level and character level language modeling. Therefore, tokens can be either words or characters. The joint probability  factorizes into 

Let  denote the context available to the language model for . Let  denote the vocabulary of tokens, each of which is embedded into a vector of dimension . Let  denote the token embedding matrix of dimension  and  denote the embedding of . 
An LSTM computes a distributed representation of   in the form of its hidden state , which we assume has dimension  as well. 
The probability that the next token is  can then be calculated using a linear decoder followed by a Softmax layer as 
 
where  is the entry corresponding to  in a bias vector   of dimension  and   represents projection onto . Here we assume that the weights of the decoder are tied with the token embedding matrix  (\cite{Inan2016TyingWV,Press2017UsingTO}). To optimize the parameters of the language model , the loss function to be minimized during training  is set as the cross-entropy between the predicted distribution  and the actual token .
 


 
Note that Eq.(\ref{eqn:softmax}), when applied to all  produces a   vector , encapsulating the prediction the language model has about the next token . 
Since this is dependent on and conditioned on ,  clearly encodes information about it; in particular about the last token  in . 
In turn, it should be possible to  infer or decode some limited information about  from . 
We argue that by biasing the model to be more accurate in recalling information about past tokens, we can help it in predicting  the next token better. 

To this end,  we define the following decoding operation to compute a probability distribution over  as the last token in the context.

Here  is a non-linear function that maps vectors in  to vectors in  and  is a bias vector of dimension , together with parameters . In effect, we are \emph{decoding the past} -- the last token in the context .  
This produces a vector    of dimension . The cross-entropy loss with respect to the actual last token  can then be computed as 

Here  stands for \emph{Past Decode Regularization}.  captures the extent to which the decoded distribution of tokens differs from the actual tokens  in the context. Note the symmetry between Eqs.(\ref{eqn:softmax}) and (\ref{eq:lpd}).  The ``input" in the latter case is  and the ``context" is provided by a nonlinear transformation of . Different from the former, the context in Eq.(\ref{eq:lpd}) does not preserve any state information across time steps as we want to decode only using . 
The term  can be interpreted as a ``soft" token embedding lookup, where the token vector  is a probability distribution instead of a unit vector. 


We add  to the loss function in Eq.(\ref{eq:ce}) as a regularization term, where  is a positive weighting coefficient, to construct the following new loss function for the language model.

Thus equivalently PDR can also be viewed as a method of defining an augmented loss function for language modeling. The choice of  dictates the degree to which we want the language model to incorporate our inductive bias i.e. decodability of the last token in the context. If it is too large, the model will fail to predict the next token, which is its primary task. If it is zero or too small, the model will retain less information about the last token which hampers its predictive performance. In practice, we choose  by a search based on validation set performance. 

Note that the trainable parameters  associated with PDR are used only during training to bias the language model and are not used at inference time. This also means that it is important to control the complexity of the nonlinear function  so as not to overly bias the training. As a simple choice, we use a single fully connected layer of size  followed by a Tanh nonlinearity as . This introduces few extra parameters and a small increase in training time as compared to a model not using PDR. 



\section{Experiments}
\begin{table}
\setlength{\tabcolsep}{4pt}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{l|lll|lll|lll|lll}
\toprule
 & \multicolumn{3}{c|}{\textbf{PTB}} &  \multicolumn{3}{c|}{\textbf{WT2}}  &  \multicolumn{3}{c|}{\textbf{PTBC}} &  \multicolumn{3}{c}{\textbf{enwik8}} \\
& Train & Valid & Test & Train & Valid & Test & Train & Valid & Test & Train & Valid & Test\\
\midrule
Tokens & 888K & 70.4K & 78.7K & 2.05M & 213K & 241K & 5.01M & 393k &  442k &  90M &  5M & 5M   \\
Vocab & \multicolumn{3}{|c|}{10K} & \multicolumn{3}{|c|}{33.3K} & \multicolumn{3}{|c|}{51} & \multicolumn{3}{|c}{205}\\
\bottomrule
\end{tabular}
\caption{Statistics of the language modeling benchmark datasets.}
\label{tab:stats}
\end{table}

We present extensive experimental results to show the efficacy of using PDR for language modeling on four  standard benchmark datasets -- two each for word level and character level language modeling. For the former, we evaluate our method on the Penn Treebank (PTB)  (\cite{Mikolov2010RecurrentNN}) and the WikiText-2 (WT2) (\cite{Merity2016PointerSM}) datasets.  For the latter, we use the Penn Treebank Character (PTBC) (\cite{Mikolov2010RecurrentNN})  and the Hutter Prize Wikipedia Prize (\cite{HutterPrize}) (also known as Enwik8) datasets. Key statistics for these datasets is presented in Table \ref{tab:stats}. 


As mentioned in the introduction, some of the best existing results on these datasets are obtained by using extensive regularization techniques on  relatively large LSTMs (\cite{Merity2018,Merity2018AnAO,Yang2017BreakingTS}). We apply our regularization technique to these models, the so called AWD-LSTM. We consider two versions of the model -- one with a single softmax (AWD-LSTM) and one with a mixture-of-softmaxes (AWD-LSTM-MoS). The PDR regularization term is computed according to Eq.(\ref{eq:PDR}) and Eq.(\ref{eq:lpd}). We call our model AWD-LSTM+PDR when using a single softmax and AWD-LSTM-MoS+PDR when using a mixture-of-softmaxes. We largely follow the experimental procedure of the original models and incorporate their dropouts and regularizations in our experiments. The relative contribution of these existing regularizations and PDR will be analyzed in Section \ref{sec:analysis}. 

There are 7 hyperparameters associated with the regularizations used in AWD-LSTM (and one extra with MoS). PDR also has an associated weighting coefficient .  For our experiments, we set   which was determined by a coarse search on the PTB and WT2 validation sets.  For the remaining ones, we perform light hyperparameter search in the vicinity of those reported for AWD-LSTM in \cite{Merity2018,Merity2018AnAO} and for AWD-LSTM-MoS in \cite{Yang2017BreakingTS}. 








\subsection{Model and training for PTB and WikiText-2}
For the single softmax model (AWD-LSTM+PDR), for both PTB and WT2, we use a 3-layered LSTM with 1150, 1150 and 400 hidden dimensions. The word embedding dimension is set to .  For the mixture-of-softmax model,  we use a 3-layer LSTM with dimensions 960, 960 and 620, embedding dimension of 280 and 15 experts for PTB and a 3-layer LSTM with dimensions 1150, 1150 and 650, embedding dimension of  and 15 experts for WT2.  Weight tying is used in all the models. For training the models, we follow the same procedure as AWD-LSTM i.e. a combination of SGD and NT-ASGD, followed by finetuning. We adopt the learning rate schedules and batch sizes of  \cite{Merity2018} and  \cite{Yang2017BreakingTS} in our experiments.


\subsection{Model and training for PTBC and Enwik8}
For  PTBC, we use a 3-layer LSTM with 1000, 1000 and 200 hidden dimensions and a character embedding dimension of . For  Enwik8, we use a LSTM with 1850, 1850 and 400 hidden dimensions and the characters are embedded in  dimensions. 
For training, we largely follow the procedure laid out in \cite{Merity2018AnAO}.
For each of the datasets, AWD-LSTM+PDR has less than 1\% more parameters than the corresponding AWD-LSTM model (during training only). The maximum observed time overhead due to the additional computation is less than 3\%. 




\section{Results on Word Level Language Modeling} 

The results for PTB are shown in Table \ref{tab:ptb_res}. 
With a single softmax, our method (AWD-LSTM+PDR) achieves a perplexity of 55.6 on the PTB test set, which improves on the current state-of-the-art with a single softmax by an absolute 1.7 points. The advantages of better information retention due to PDR are maintained when combined with a continuous cache pointer (\cite{Grave2016ImprovingNL}), where our method yields an absolute improvement of 1.2 over AWD-LSTM. Notably, when coupled with dynamic evaluation (\cite{Krause2018DynamicEO}), the perplexity is decreased further to 49.3. To the best of our knowledge, ours is the first method to achieve a sub 50 perplexity on the PTB test set with a single softmax. Note that, for both cache pointer and dynamic evaluation, we coarsely tune the associated hyperparameters on the validation set.  

Using a mixture-of-softmaxes, our method (AWD-LSTM-MoS+PDR) achieves a test perplexity of 53.8, an improvement of 0.6 points over the current state-of-the-art. The use of dynamic evaluation pushes the perplexity further down to 47.3. 
PTB is a restrictive dataset with a  vocabulary of 10K words. Achieving good perplexity requires considerable regularization. The fact that PDR can improve upon  existing heavily regularized models is empirical evidence of its distinctive nature and its effectiveness in improving language models.  

Table \ref{tab:wt2_res} shows the perplexities achieved by  our model on  WT2. This dataset is considerably more complex than PTB with a vocabulary of more than 33K words. AWD-LSTM+PDR improves over the current state-of-the-art with a single softmax by a significant 2.3 points, achieving a perplexity of 63.5. The gains are maintained with the use of cache pointer (2.4 points) and with the use of  dynamic evaluation (1.7 points). Using a mixture-of-softmaxes,  AWD-LSTM-MoS+PDR achieves perplexities of 60.5 and 40.3 (with dynamic evaluation) on the WT2 test set, improving upon the current state-of-the-art by 1.0 and 0.4 points respectively. 





\subsection{Performance on Larger Datasets}
We consider the Gigaword dataset \cite{Chelba2014OneBW} with a  truncated vocabulary of about 100K tokens with the highest frequency and apply PDR to a baseline 2-layer LSTM language model with embedding and hidden dimensions set to 1024. We use all the shards from the training set for training and a few shards  from the heldout set for validation (heldout-0,10) and test (heldout-20,30,40). We tuned the PDR coefficient coarsely in the vicinity of 0.001. While the baseline model achieved a validation (test) perplexity of 44.3 (43.1), on applying PDR, the model achieved a perplexity of 44.0 (42.5).  Thus, PDR is relatively less effective on larger datasets, a fact also observed for other regularization techniques on such datasets (\cite{Yang2017BreakingTS}).



\begin{table}[t]
\begin{tabular}{llll}
\toprule
\textbf{Model} & \textbf{\#Params} & \textbf{Valid} & \textbf{Test} \\
\midrule
Sate-of-the-art Methods (Single Softmax)\\
\midrule
\cite{Merity2018} -- AWD-LSTM  & 24.2M &  60.0  & 57.3 \\
\cite{Merity2018} -- AWD-LSTM + continuous cache pointer & 24.2M &  53.9 & 52.8\\
\cite{Krause2018DynamicEO} -- AWD-LSTM + dynamic evaluation & 24.2M & 51.6 & 51.1 \\
\midrule
Our Method (Single Softmax)\\
\midrule
AWD-LSTM+PDR  & 24.2M & \textbf{57.9} & \textbf{55.6}  (\textcolor{red}{\textbf{-1.7}})\\
AWD-LSTM+PDR + continuous cache pointer & 24.2M & 52.4 & 51.6  (\textcolor{red}{\textbf{-1.2}}) \\
AWD-LSTM+PDR + dynamic evaluation & 24.2M & \textbf{50.1} & \textbf{49.3}  (\textcolor{red}{\textbf{-1.8}})\\
\midrule
Sate-of-the-art Methods (Mixture-of-Softmax)\\
\midrule
\cite{Yang2017BreakingTS} -- AWD-LSTM-MoS  & 22M &  56.5  & 54.4 \\
\cite{Yang2017BreakingTS} -- AWD-LSTM-MoS + dynamic evaluation & 22M &  48.3 & 47.7\\
\midrule
Our Method (Mixture-of-Softmax)\\
\midrule
AWD-LSTM-MoS+PDR  & 22M & \textbf{56.2} & \textbf{53.8}  (\textcolor{red}{\textbf{-0.6}})\\
AWD-LSTM-MoS+PDR + dynamic evaluation & 22M & \textbf{48.0} & \textbf{47.3}  (\textcolor{red}{\textbf{-0.4}})\\
\toprule
\end{tabular}
\caption{Perplexities on Penn Treebank (PTB) test set for single softmax and mixture-of-softmaxes models. Values in parentheses show improvement over respective  state-of-the-art perplexities. }
\label{tab:ptb_res}
\end{table}

\begin{table}[t]
\begin{tabular}{llll}
\toprule
\textbf{Model} & \textbf{\#Params} & \textbf{Valid} & \textbf{Test} \\
\midrule
Sate-of-the-art Methods (Single Softmax) \\
\midrule
\cite{Merity2018} -- AWD-LSTM  & 33.6M &  68.6  & 65.8 \\
\cite{Merity2018} -- AWD-LSTM + continuous cache pointer & 33.6M &  53.8 & 52.0\\
\cite{Krause2018DynamicEO} -- AWD-LSTM + dynamic evaluation & 33.6M & 46.4 & 44.3 \\
\midrule
Our Method (Single Softmax) \\
\midrule
AWD-LSTM+PDR & 33.6M & \textbf{66.5} & \textbf{63.5}  (\textcolor{red}{\textbf{-2.3}}) \\
AWD-LSTM+PDR + continuous cache pointer & 33.6M & {51.5} & {49.6}  (\textcolor{red}{\textbf{-2.4}})\\
AWD-LSTM+PDR + dynamic evaluation & 33.6M &  \textbf{44.6} & \textbf{42.6}  (\textcolor{red}{\textbf{-1.7}})\\
\midrule
Sate-of-the-art Methods (Mixture-of-Softmax)\\
\midrule
\cite{Yang2017BreakingTS} -- AWD-LSTM-MoS  & 35M &  63.9  & 61.5 \\
\cite{Yang2017BreakingTS} -- AWD-LSTM-MoS + dynamic evaluation & 35M &  42.4 & 40.7\\
\midrule
Our Method (Mixture-of-Softmax)\\
\midrule
AWD-LSTM-MoS+PDR  & 35M & \textbf{63.0} & \textbf{60.5}  (\textcolor{red}{\textbf{-1.0}})\\
AWD-LSTM-MoS+PDR + dynamic evaluation & 35M & \textbf{42.0} & \textbf{40.3}  (\textcolor{red}{\textbf{-0.4}})\\
\toprule
\end{tabular}
\caption{Perplexities on WikiText-2 (WT2) test set for single softmax and mixture-of-softmaxes models. Values in parentheses show improvement over respective state-of-the-art perplexities.}
\label{tab:wt2_res}
\vspace{-1em}
\end{table}



\section{Results on Character Level Language Modeling}
\begin{table}[t]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Model} & \textbf{\#Params} &  \textbf{Test} \\
\midrule
\cite{Krueger2016ZoneoutRR} -- Zoneout LSTM & - & 1.27 \\
\cite{Chung2016HierarchicalMR} -- HM-LSTM & - & 1.24 \\
\cite{Ha2016HyperNetworks} -- HyperLSTM & 14.4M &  1.219 \\
\cite{Zoph2016NeuralAS} -- NAS Cell & 16.3M & 1.214 \\
\cite{Mujika2017FastSlowRN}  -- FS-LSTM-4 &   6.5M & 1.193 \\
 \cite{Merity2018AnAO}  -- AWD-LSTM & 13.8M &  1.175 \\
\midrule
Our Method\\
\midrule
AWD-LSTM+PDR  & 13.8M & 1.169 (\textcolor{red}{\textbf{-0.006}}) \\
\toprule
\end{tabular}
\caption{Bits-per-character on the PTBC test set.} \label{tab:pennchar_res}
\end{table}
\begin{table}[t]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Model} & \textbf{\#Params} &  \textbf{Test} \\
\midrule
\cite{Ha2016HyperNetworks} --  HyperLSTM & 27M & 1.340 \\
\cite{Chung2016HierarchicalMR} -- HM-LSTM & 35M & 1.32 \\
\cite{Rocki2016SurprisalDrivenZ} -- SD Zoneout & 64M & 1.31 \\
\cite{Zilly2017RecurrentHN} -- RHN (depth 10) & 21M & 1.30 \\
\cite{Zilly2017RecurrentHN} -- Large RHN  & 46M & 1.270 \\
\cite{Mujika2017FastSlowRN}  -- FS-LSTM-4 & 27M & 1.277 \\
\cite{Mujika2017FastSlowRN} -- Large FS-LSTM-4 &   47M & 1.245\\
 \cite{Merity2018AnAO}  -- AWD-LSTM & 47M &  1.232 \\
\midrule
Our Method\\
\midrule
AWD-LSTM (Ours) & 47M & 1.257 \\
 AWD-LSTM+PDR  & 47M & 1.245 (-0.012)\\
\toprule
\end{tabular}
\caption{Bits-per-character on Enwik8 test set.}\label{tab:enwik8_res}
\end{table}
The results on PTBC are shown in Table \ref{tab:pennchar_res}. Our method achieves a bits-per-character (BPC) performance of 1.169 on the PTBC test set, improving on the current state-of-the-art by 0.006 or 0.5\%. It is notable that even with this highly processed dataset and a small vocabulary of only 51 tokens, our method  improves on already highly regularized models. 
Finally, we present  results on Enwik8 in Table \ref{tab:enwik8_res}. AWD-LSTM+PDR achieves 1.245 BPC. This is 0.012 or about 1\% less than the 1.257 BPC achieved by AWD-LSTM  in our experiments (with hyperparameters from \cite{Merity2018AnAO}).



\section{Analysis of PDR}
\label{sec:analysis}

In this section, we analyze PDR by probing its performance in several ways and comparing it with current state-of-the-art models that do not use PDR. 

\subsection{A Valid Regularization}


\begin{table}[h!]
		\centering
		\begin{tabular}{lll}
			\toprule
			          & PTB Valid & WT2 Valid \\
			\midrule
			AWD-LSTM (NoReg)    & 108.6     & 142.7 \\
			AWD-LSTM (NoReg) + PDR  & 106.2      & 137.6 \\
			\bottomrule
		\end{tabular}
		\caption{Validation perplexities for AWD-LSTM without any regularization and with only PDR. }
		\label{lab:tab_noreg}
		\end{table}

To verify that indeed PDR can act as a form of regularization, we perform the following experiment. We take the models for PTB and WT2 and turn off all dropouts and regularization and compare its performance with only PDR turned on. The results, as shown in Table \ref{lab:tab_noreg}, validate the premise of PDR. The model with only PDR turned on achieves 2.4 and 5.1 better validation perplexity on PTB and WT2 as compared to the model without any regularization. Thus, biasing the LSTM by decoding the distribution of past tokens from the predicted next-token distribution can indeed act as a regularizer leading to better generalization performance.  

Next, we plot histograms of the negative log-likelihoods of the correct context tokens  in the past decoded vector  computed using our best models on the PTB and WT2 validation sets in Fig. \ref{fig:nll}(a). The NLL values are significantly peaked near 0, which means that the past decoding operation is able to decode significant amount of information about the last token in the context. 

To investigate the effect of hyperparameters on PDR, we pick 60 sets of random hyperparameters in the vicinity of  those reported by \cite{Merity2018} and compute the validation set perplexity after training (without finetuning) on PTB, for both AWD-LSTM+PDR and AWD-LSTM. Their histograms are plotted in Fig.\ref{fig:nll}(b). The perplexities for models with PDR are distributed slightly to the left of those without PDR. There appears to be more instances of perplexities in the higher range for models without PDR. 
Note that there are certainly hyperparameter settings where adding PDR leads to lower validation complexity, as is generally the case for any regularization method. 


\begin{figure}
\subfigure[Histogram of the NLL of  in the past decoded vector .]{
\begin{tikzpicture}[scale=0.80]
\usetikzlibrary{patterns}
\begin{axis}[ybar, ymin=0, bar width=2,
x tick label style={rotate=0},
xlabel={Negative log-likelihood},
ylabel={Normalized frequency},
y label style={at={(0.05,0.5)}},
every axis plot/.append style={fill},
legend pos= north east,
legend entries={PTB-Valid, WT2-Valid},
]
\addplot[magenta]
coordinates
{(0.33,0.316464626105)(1.0,0.0851737740793)(1.67,0.0652768579573)(2.33,0.057819113709)(3.0,0.0520170462726)(3.67,0.0518154856172)(4.33,0.050044631288)(5.0,0.0517866912379)(5.67,0.0515851305825)(6.33,0.0497854818739)(7.0,0.0443865357482)(7.67,0.0388580149155)(8.33,0.0341789282732)(9.0,0.0278297676294)(9.67,0.022977914711)};
\addplot[black]
coordinates
{(0.33,0.30860908651)(1.0,0.0787424358073)(1.67,0.0643498909958)(2.33,0.059959790672)(3.0,0.0559238916244)(3.67,0.0553451965817)(4.33,0.0522072726003)(5.0,0.0524417438676)(5.67,0.0500670986924)(6.33,0.0488797761049)(7.0,0.0446293607914)(7.67,0.0396455991739)(8.33,0.0349711400791)(9.0,0.0289646846361)(9.67,0.0252630318631)};
\end{axis}
\end{tikzpicture}
}
\subfigure[Histogram of validation perplexities on PTB for a set of different hyperparameters.]{
\begin{tikzpicture}[scale=0.80]
\usetikzlibrary{patterns}
\begin{axis}[ybar, ymin=0, bar width=2,ymax=0.3,
x tick label style={rotate=0},
xlabel={Perplexity},
ylabel={Normalized frequency},
y label style={at={(0.02,0.5)}},
legend cell align={left},
every axis plot/.append style={fill},
y tick label style={
    /pgf/number format/.cd,
    fixed,
    fixed zerofill,
    precision=2
  },
  legend pos= north west,
legend entries={AWD-LSTM+PDR,AWD-LSTM},
]
\addplot[red]
coordinates {(60.17,0.016393442623)(60.32,0.0)(60.47,0.016393442623)(60.61,0.0655737704918)(60.76,0.114754098361)(60.91,0.131147540984)(61.05,0.114754098361)(61.2,0.147540983607)(61.35,0.229508196721)(61.49,0.0655737704918)(61.64,0.0655737704918)(61.79,0.0)(61.93,0.016393442623)(62.08,0.0)(62.23,0.016393442623)};
\addplot[black!60!green]
coordinates {(60.17,0.0)(60.32,0.0)(60.47,0.0)(60.61,0.0655737704918)(60.76,0.0819672131148)(60.91,0.16393442623)(61.05,0.180327868852)(61.2,0.131147540984)(61.35,0.0983606557377)(61.49,0.114754098361)(61.64,0.131147540984)(61.79,0.0327868852459)(61.93,0.0)(62.08,0.0)(62.23,0.0)};
\end{axis}
\end{tikzpicture}
}
\caption{Context token NLL for AWD-LSTM+PDR and comparison with AWD-LSTM.}
\label{fig:nll}
\vspace{-1em}
\end{figure}


\subsection{Comparison with AWD-LSTM}
\setcounter{subfigure}{0}
\pgfplotsset{cycle list/Set1-4}
\begin{figure}[t]
\subfigure[Histogram of entropies of  for PTB valid.]{
\begin{tikzpicture}[scale=0.80]
\usetikzlibrary{patterns}
\begin{axis}[ybar, ymin=0, bar width=2,
x tick label style={rotate=0},
xlabel={Predicted token entropy},
ylabel={Normalized frequency},
y label style={at={(0.02,0.5)}},
y tick label style={
    /pgf/number format/.cd,
    fixed,
    fixed zerofill,
    precision=2
  },
legend cell align={left},
every axis plot/.append style={fill},
legend pos= north west,
legend entries={AWD-LSTM+PDR, AWD-LSTM},
]
\addplot[red]
coordinates
{(0.33,0.0668799739693)(1.0,0.031575807698)(1.67,0.0282406214835)(2.33,0.0319960953917)(3.0,0.037310701067)(3.67,0.045865589284)(4.33,0.064331132472)(5.0,0.0876367629713)(5.67,0.108068167952)(6.33,0.133922639949)(7.0,0.145975406391)(7.67,0.117490746892)(8.33,0.0765737062596)(9.0,0.0230073618135)(9.67,0.00112528640573)};
\addplot[black!60!green]
coordinates
{(0.33,0.0684582220475)(1.0,0.0332840738079)(1.67,0.031372442685)(2.33,0.0344093602137)(3.0,0.0409305982999)(3.67,0.0500684662211)(4.33,0.0660529562494)(5.0,0.084057538741)(5.67,0.103553464662)(6.33,0.123117178921)(7.0,0.133583698261)(7.67,0.11149825784)(8.33,0.083824279071)(9.0,0.0334982171667)(9.67,0.00229124581407)};
\end{axis}
\end{tikzpicture}
}
\subfigure[Training curves on PTB showing perplexity. The kink in the middle represents the start of finetuning.]{
\begin{tikzpicture}[scale=0.80]
\begin{axis}[xmax=1200,xmin=50,ymax=85, 
x tick label style={rotate=0},
xlabel={No. of epochs},
ylabel={Perplexity},
y label style={at={(0.05,0.5)}},
legend cell align={left},
legend entries={AWD-LSTM+PDR (Train),AWD-LSTM (Train),AWD-LSTM+PDR (Valid),AWD-LSTM (Valid)}
]
\addplot[red,thick,dashed]
coordinates
{(10,155.13)(20,107.08)(30,88.67)(40,78.86)(50,72.14)(60,68.24)(70,66.26)(80,62.77)(90,61.43)(100,59.24)(110,57.73)(120,56.89)(130,55.47)(140,54.97)(150,53.56)(160,53.39)(170,51.40)(180,50.83)(190,51.02)(200,50.42)(210,49.81)(220,49.46)(230,49.05)(240,48.19)(250,48.29)(260,48.05)(270,47.82)(280,47.44)(290,47.52)(300,46.70)(310,46.44)(320,46.24)(330,46.49)(340,45.73)(350,45.62)(360,45.44)(370,44.94)(380,45.05)(390,44.54)(400,44.91)(410,44.52)(420,44.00)(430,43.94)(440,43.95)(450,44.13)(460,43.84)(470,43.88)(480,43.63)(490,43.73)(500,43.57)(510,42.99)(520,42.78)(530,42.89)(540,43.10)(550,43.06)(560,42.55)(570,42.55)(580,42.27)(590,41.90)(600,42.71)(610,42.08)(620,42.40)(630,42.15)(640,42.14)(650,42.57)(660,41.67)(670,41.60)(680,41.43)(690,41.55)(700,41.68)(710,41.68)(720,41.44)(730,41.21)(740,41.70)(750,41.69)(760,39.79)(770,41.44)(780,41.96)(790,42.13)(800,41.67)(810,41.85)(820,42.46)(830,41.82)(840,41.82)(850,41.76)(860,41.43)(870,41.65)(880,41.61)(890,41.94)(900,41.35)(910,41.76)(920,41.30)(930,41.34)(940,41.24)(950,41.09)(960,41.11)(970,40.72)(980,41.14)(990,40.53)(1000,41.03)(1010,41.11)(1020,41.06)(1030,40.65)(1040,41.14)(1050,40.73)(1060,40.62)(1070,40.48)(1080,40.83)(1090,41.12)(1100,40.41)(1110,40.65)(1120,40.17)(1130,40.44)(1140,40.28)(1150,40.05)(1160,40.44)(1170,39.93)(1180,39.90)(1190,39.59)(1200,40.16)(1210,40.28)(1220,39.82)(1230,40.00)(1240,40.08)(1250,39.93)(1260,39.62)(1270,39.45)(1280,39.85)(1290,39.82)(1300,40.09)(1310,39.63)(1320,39.64)(1330,39.34)(1340,39.05)(1350,39.43)(1360,39.12)(1370,39.32)(1380,39.37)(1390,39.63)(1400,39.71)};
\addplot[black!60!green,thick,dashed]
coordinates
{(10,140.66)(20,95.19)(30,79.04)(40,69.99)(50,64.20)(60,60.38)(70,58.07)(80,55.14)(90,53.71)(100,51.55)(110,50.41)(120,49.34)(130,48.23)(140,47.76)(150,46.76)(160,46.68)(170,44.84)(180,44.30)(190,44.08)(200,43.60)(210,43.48)(220,43.03)(230,42.56)(240,41.78)(250,41.93)(260,41.61)(270,41.81)(280,41.40)(290,41.20)(300,40.69)(310,40.43)(320,40.17)(330,40.40)(340,39.86)(350,39.66)(360,39.46)(370,39.03)(380,38.83)(390,38.53)(400,38.91)(410,38.74)(420,38.21)(430,37.93)(440,38.15)(450,38.09)(460,37.83)(470,37.85)(480,37.75)(490,37.72)(500,37.27)(510,37.09)(520,37.19)(530,36.76)(540,37.15)(550,37.02)(560,36.77)(570,36.77)(580,36.53)(590,36.16)(600,36.76)(610,36.43)(620,36.24)(630,36.26)(640,36.12)(650,36.44)(660,35.96)(670,35.79)(680,35.75)(690,35.62)(700,35.79)(710,35.62)(720,35.97)(730,35.30)(740,35.43)(750,35.72)(760,36.88)(770,36.87)(780,37.12)(790,36.91)(800,36.36)(810,36.07)(820,36.33)(830,35.65)(840,35.58)(850,35.48)(860,35.18)(870,35.29)(880,34.86)(890,35.3)(900,34.87)(910,35.37)(920,34.76)(930,34.68)(940,34.69)(950,34.31)(960,34.56)(970,34.15)(980,34.4)(990,33.95)(1000,34.02)(1010,34.12)(1020,34.24)(1030,33.9)(1040,34.11)(1050,33.79)(1060,33.91)(1070,33.84)(1080,34.06)(1090,34.3)(1100,33.75)(1110,33.54)(1120,33.57)(1130,33.55)(1140,33.42)(1150,33.17)(1160,33.78)(1170,33.1)(1180,33.01)(1190,32.9)(1200,33.38)(1210,33.12)(1220,32.83)(1230,32.94)(1240,32.95)(1250,33.04)(1260,32.57)(1270,32.57)(1280,32.63)(1290,32.93)(1300,32.83)(1310,32.68)(1320,32.54)(1330,32.72)(1340,32.24)(1350,32.65)(1360,32.42)(1370,32.24)(1380,32.53)(1390,32.42)(1400,32.45)};
\addplot[red,thick]
coordinates
{(10,121.40)(20,89.75)(30,81.34)(40,75.91)(50,73.53)(60,68.18)(70,66.82)(80,66.04)(90,65.49)(100,65.03)(110,64.64)(120,64.29)(130,63.97)(140,63.70)(150,63.46)(160,63.25)(170,63.04)(180,62.85)(190,62.69)(200,62.54)(210,62.40)(220,62.27)(230,62.15)(240,62.04)(250,61.93)(260,61.84)(270,61.76)(280,61.68)(290,61.60)(300,61.53)(310,61.46)(320,61.40)(330,61.35)(340,61.30)(350,61.25)(360,61.20)(370,61.15)(380,61.11)(390,61.06)(400,61.03)(410,60.99)(420,60.95)(430,60.92)(440,60.88)(450,60.85)(460,60.82)(470,60.80)(480,60.77)(490,60.75)(500,60.73)(510,60.71)(520,60.68)(530,60.66)(540,60.65)(550,60.63)(560,60.61)(570,60.59)(580,60.58)(590,60.56)(600,60.54)(610,60.53)(620,60.51)(630,60.50)(640,60.49)(650,60.48)(660,60.47)(670,60.46)(680,60.44)(690,60.43)(700,60.42)(710,60.41)(720,60.40)(730,60.40)(740,60.39)(750,60.39)(760,59.97)(770,59.78)(780,59.64)(790,59.51)(800,59.41)(810,59.32)(820,59.25)(830,59.18)(840,59.13)(850,59.08)(860,59.03)(870,59.00)(880,58.96)(890,58.93)(900,58.90)(910,58.88)(920,58.85)(930,58.83)(940,58.80)(950,58.78)(960,58.75)(970,58.73)(980,58.71)(990,58.69)(1000,58.67)(1010,58.65)(1020,58.63)(1030,58.61)(1040,58.59)(1050,58.57)(1060,58.56)(1070,58.54)(1080,58.52)(1090,58.50)(1100,58.48)(1110,58.47)(1120,58.45)(1130,58.44)(1140,58.42)(1150,58.41)(1160,58.39)(1170,58.38)(1180,58.37)(1190,58.35)(1200,58.34)(1210,58.33)(1220,58.31)(1230,58.30)(1240,58.29)(1250,58.28)(1260,58.27)(1270,58.26)(1280,58.25)(1290,58.24)(1300,58.23)(1310,58.22)(1320,58.21)(1330,58.21)(1340,58.20)(1350,58.19)(1360,58.18)(1370,58.18)(1380,58.17)(1390,58.16)(1400,58.15)};
\addplot[black!60!green,thick]
coordinates
{(10,115.36)(20,87.02)(30,79.04)(40,74.46)(50,72.82)(60,67.61)(70,66.66)(80,65.95)(90,65.42)(100,64.98)(110,64.60)(120,64.27)(130,63.96)(140,63.70)(150,63.48)(160,63.29)(170,63.12)(180,62.96)(190,62.81)(200,62.68)(210,62.56)(220,62.45)(230,62.35)(240,62.26)(250,62.17)(260,62.09)(270,62.02)(280,61.95)(290,61.89)(300,61.83)(310,61.77)(320,61.72)(330,61.66)(340,61.62)(350,61.57)(360,61.53)(370,61.48)(380,61.45)(390,61.41)(400,61.38)(410,61.35)(420,61.32)(430,61.29)(440,61.26)(450,61.23)(460,61.21)(470,61.18)(480,61.16)(490,61.14)(500,61.13)(510,61.11)(520,61.09)(530,61.07)(540,61.06)(550,61.04)(560,61.02)(570,61.01)(580,61.00)(590,60.98)(600,60.97)(610,60.96)(620,60.94)(630,60.93)(640,60.92)(650,60.91)(660,60.90)(670,60.89)(680,60.88)(690,60.87)(700,60.86)(710,60.85)(720,60.84)(730,60.83)(740,60.83)(750,60.82)(760,60.37)(770,60.30)(780,60.25)(790,60.18)(800,60.13)(810,60.07)(820,60.01)(830,59.97)(840,59.93)(850,59.91)(860,59.89)(870,59.86)(880,59.83)(890,59.81)(900,59.78)(910,59.76)(920,59.75)(930,59.73)(940,59.72)(950,59.70)(960,59.69)(970,59.68)(980,59.67)(990,59.66)(1000,59.65)(1010,59.63)(1020,59.62)(1030,59.61)(1040,59.60)(1050,59.58)(1060,59.57)(1070,59.56)(1080,59.55)(1090,59.54)(1100,59.52)(1110,59.51)(1120,59.49)(1130,59.48)(1140,59.47)(1150,59.46)(1160,59.45)(1170,59.44)(1180,59.43)(1190,59.43)(1200,59.42)(1210,59.41)(1220,59.40)(1230,59.39)(1240,59.39)(1250,59.38)(1260,59.37)(1270,59.37)(1280,59.36)(1290,59.36)(1300,59.35)(1310,59.35)(1320,59.34)(1330,59.34)(1340,59.34)(1350,59.33)(1360,59.33)(1370,59.33)(1380,59.32)(1390,59.32)(1400,59.31)};
\end{axis}
\end{tikzpicture}
}
\caption{Comparison between AWD-LSTM+PDR and AWD-LSTM.}
\label{fig:entropy_hist}
\vspace{-1em}
\end{figure}





To show the qualitative difference between AWD-LSTM+PDR and AWD-LSTM,  in Fig.\ref{fig:entropy_hist}(a), we plot a histogram of the entropy of the predicted next token distribution  for all the tokens in the validation set of PTB achieved by their respective best models. The distributions for the two models is slightly different, with some identifiable patterns. The use of PDR has the effect of reducing the entropy of the predicted distribution when it is in the higher range of 8 and above, pushing it into the range of 5-8. This shows that one way PDR biases the language model is by reducing the entropy of the predicted next token distribution. Indeed, one way to reduce the cross-entropy between  and  is by making  less spread out in Eq.(\ref{eq:lpd}). This tends to benefits the language model when the predictions are correct. 





We also compare the training curves for the two models in Fig.\ref{fig:entropy_hist}(b) on PTB.  Although the two models use slightly different hyperparameters, the regularization effect of PDR is apparent with a lower validation perplexity but higher training perplexity. The corresponding trends shown in Fig.\ref{fig:entropy_hist}(a,b) for WT2 have similar characteristics.

\subsection{Ablation Studies}
\begin{table}
\centering
\begin{tabular}{l|ll|ll}
\toprule
& \multicolumn{2}{|c|}{\textbf{PTB}} &  \multicolumn{2}{|c}{\textbf{WT2}} \\
\textbf{Model} & {Valid} &  { Test} &  { Valid} &  { Test}  \\
\midrule
AWD-LSTM+PDR & 57.9 & 55.6 & 66.5 & 63.5 \\
-- finetune & 60.4 & 58.0 & 68.5 & 65.6 \\
\midrule
-- LSTM output dropout & 67.6 & 65.4 & 75.4 & 72.1 \\
-- LSTM layer dropout & 68.1 & 65.8 & 73.7 & 70.4 \\ 
-- embedding dropout & 63.9 & 61.4 & 77.1 & 73.6  \\
-- word dropout & 62.9 & 60.5 & 70.4 & 67.4\\
-- LSTM weight dropout & 68.4 & 65.8 & 79.0 & 75.5 \\
-- alpha/beta regularization & 63.0 & 60.4 & 74.0 & 70.7 \\
-- weight decay & 64.7 & 61.4 & 72.5 & 68.9 \\
-- past decoding regularization (PDR) & 60.5 & 57.7 & 69.5 & 66.4 \\
\bottomrule
\end{tabular}
\caption{Ablation experiments on the PTB and WT2 validation sets.}
\label{tab:ablation}
\vspace{-1em}
\end{table}
We perform a set of ablation experiments on the best AWD-LSTM+PDR models for PTB and WT2 to understand the relative contribution of PDR and the other regularizations used in the model. The results are shown in Table \ref{tab:ablation}. In both cases, PDR has a significant effect in decreasing the validation set performance, albeit lesser than the other forms of regularization. This is not surprising as PDR does not influence the LSTM directly. 


\section{Related Work}
Our method builds on the work of using sophisticated regularization techniques to train LSTMs for language modeling. In particular, the AWD-LSTM model achieves state-of-the-art performance with a single softmax on the four datasets considered in this paper (\cite{Merity2018,Merity2018AnAO}). \cite{Melis2018} also achieve similar results with highly regularized LSTMs. By addressing the so-called softmax bottleneck in single softmax models, \cite{Yang2017BreakingTS} use a mixture-of-softmaxes to achieve significantly lower  perplexities. 
PDR utilizes the symmetry between the inputs and outputs of a language model, a fact that is also exploited in weight tying (\cite{Inan2016TyingWV,Press2017UsingTO}). Our method can be used with  untied weights as well. Although motivated by language modeling, PDR can also be applied to seq2seq models with shared input-output vocabularies, such as those used for text summarization and neural machine translation (with byte pair encoding of words) (\cite{Press2017UsingTO}). 
Regularizing the training of an LSTM by combining the main objective function with auxiliary tasks has been successfully applied to several tasks in NLP (\cite{Radford2018, Rei2017SemisupervisedML}). In fact, a popular choice for the auxiliary task is language modeling itself. This in turn is related to multi-task learning (\cite{Collobert2008AUA}). 

Specialized architectures like Recurrent Highway Networks (\cite{Zilly2017RecurrentHN}) and NAS (\cite{Zoph2016NeuralAS}) have been successfully used to achieve competitive performance in language modeling. The former one makes the hidden-to-hidden transition function more complex allowing for more refined information flow. Such architectures are especially important for character level language modeling where strong results have been shown using  Fast-Slow RNNs (\cite{Mujika2017FastSlowRN}), a two level architecture where the slowly changing recurrent network tries to capture more long range dependencies. The use of historical information can greatly help language models deal with long range dependencies as shown by \cite{Merity2016PointerSM,Krause2018DynamicEO,Rae2018FastPL}.  Finally, in a recent paper, \cite{Gong2018FRAGEFW} achieve improved performance for language modeling by using frequency agnostic word embeddings, a technique orthogonal to and combinable with PDR. 











\bibliography{bibtex}
\bibliographystyle{iclr2019_conference}

\end{document}
