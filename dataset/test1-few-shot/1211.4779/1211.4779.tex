\documentclass[submission,
copyright,
creativecommons
]{eptcs}
\providecommand{\event}{G.Ciobanu (Ed.):\\
MeCBIC 2012\\
EPTCS Proceedings.  2012.
}
\usepackage{graphicx, amssymb}
\usepackage{wrapfig,subfig}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{mathpartir}
\usepackage{verbatim}
\usepackage{color}
\usepackage{timestamp}
\usepackage{fancyvrb}
\usepackage[normalem]{ulem} \newcommand{\SALTA} [1] {}





\newcommand{\mycomment}[2]{\textbf{[#1 -- #2]}}
\newcommand{\todo}[1]{\mycomment{#1}{TODO}}

\renewcommand\theenumi{\roman{enumi}}
\renewcommand\labelenumi{(\theenumi)}

\newcommand{\eg}{\emph{e.g.} }
\newcommand{\ie}{\emph{i.e.} }
\newcommand{\apriori}{{\it a priori}}
\newcommand{\picalc}{-calculus}



\newcommand{\syntaxdef}{\mathrel{::=}}
\newcommand{\ou}{\;\;  \mid \;\; }

\let\vec\widetilde
\newtheorem{theorem}{Theorem}
 \newtheorem{remark}{Remark}
 \newtheorem{example}{Example}
 \newtheorem{fact}{Fact}[section]
 \newtheorem{lemma}[fact]{Lemma}
 \newtheorem{proposition}[fact]{Proposition}
 \newtheorem{definition}[fact]{Definition}


\newcommand{\hname}[1]{\textit{{\sc #1}}}

\newcommand{\these}{\vdash}
\newcommand{\eqdef}{\mathrel{\stackrel{\rm\mbox{\tiny }}{=}}}
\newcommand{\size}[1]{|#1|} \newcommand{\indexvec}[1]{1..\size{\vec{#1}}}
\newcommand{\powersetfm}{\mathcal{P}_m^f}  \newcommand{\powersetf}{\mathcal{P}^f}  \newcommand{\powerset}{\mathcal{P}}  
\newcommand{\functions}{\mathcal{F}}
\newcommand{\relations}{\mathcal{R}} 
\newcommand{\seqn}[1]{#1_{1},\ldots,#1_{n}}
\newcommand{\dom}{\texttt{dom}}
\newcommand{\ran}{\texttt{ran}}






\newcommand{\FV}{\texttt{FV}}
\newcommand{\chole}{\,\cdot\,}
\newcommand{\fns}{\texttt{fn}}
\newcommand{\bns}{\texttt{bn}}
\newcommand{\econtap}[1]{\econt\set{#1}}   \newcommand{\econtapp}[1]{\econt'\set{#1}}   \newcommand{\econt}{\mathbf{C}} \newcommand{\econtapl}[1]{\econtl\set{#1}}   \newcommand{\econtappl}[1]{\econtl'\set{#1}}   \newcommand{\econtl}{\overline{\mathbf{E}}} \newcommand{\ccont}{\mathbf{C}}  \newcommand{\ccontap}[1]{\ccont\set{#1}}   

\newcommand{\names}{\mathsf{N}}    
\newcommand{\labels}{\mathsf{L}}

\newcommand{\red}{\rightarrow}
\newcommand{\sreds}{\sred^*\reds}
\newcommand{\barb}{\downarrow}
\newcommand{\trans}{\xrightarrow}
\newcommand{\parop}{\mid}
\newcommand{\nil}{\boldsymbol {0}}
\def\new#1{\scop{#1}}

\newcommand{\loc}[2]{ \{ #1 \}_{#2} }
\newcommand{\unfp} [2]{[{#1}]^{#2}}



\newcommand{\doubleopensqbr}{\mbox{\rm [\hspace{-1.67pt}[}}
\newcommand{\doubleclosesqbr}{\mbox{\rm ]\hspace{-1.67pt}]}}
\newcommand{\tr}[1]{\doubleopensqbr #1 \doubleclosesqbr}
\newcommand{\tri}[1]{\doubleopensqbr #1 \doubleclosesqbr^{-1}}
\newcommand{\trr}[1]{\doubleopensqbr #1 \doubleclosesqbr^r}

\def\pep#1{#1.}
\def\scop#1{\pep{(\nu #1)}}

\newcommand{\N}{\mathcal{N}} \newcommand{\La}{\mathcal{L}} 



\newcommand{\processes}{\mathsf{P}} 
\newcommand{\labprocesses}{\mathsf{LP}}   
\newcommand{\wflabprocesses}{\mathsf{WFP}}   

\newcommand{\D}{D} \newcommand{\C}{C} \newcommand{\Pl}{\overline{P}} \newcommand{\Ql}{\overline{Q}} \newcommand{\Rl}{\overline{R}} 

\newcommand{\rad}{\mathrm{rad}}
\newcommand{\labf}{\mathrm{lab}}
\newcommand{\unl}{\mathrm{unl}}
\newcommand{\wf}{\mathrm{wf}}






\newcommand{\pictproc}{\mathsf{M}} 
\newcommand{\labpictproc}{\mathsf{LM}}   
\newcommand{\wflabpictproc}{\mathsf{WFM}}   

\newcommand{\eval}{\Downarrow}    \newcommand{\reds}{\mapsto}
\newcommand{\cor}{\preceq} 

\newcommand{\M}{\mathcal{M}} \newcommand{\Hp}{\mathcal{H}} \newcommand{\Pq}{\mathcal{P}} \newcommand{\Qq}{\mathcal{Q}} \newcommand{\Hpl}{\overline{\mathcal{H}}} \newcommand{\Pql}{\overline{\mathcal{P}}} \newcommand{\Qql}{\overline{\mathcal{Q}}} \newcommand{\Ml}{\overline{\mathcal{M}}} 

\newcommand{\fresh}{\mathrm{fresh}}
\newcommand{\freshn}{\mathrm{freshn}}
\newcommand{\psize}{\mathrm{size}}

\newcommand{\mstate}[2]{\langle#1,#2\rangle} 
\newcommand{\mstatelab}[3]{\langle#1,#2,#3\rangle} 
\newcommand{\mstatefull}[3]{\langle#1,#2,#3\rangle} 
\newcommand{\mstatefulllab}[4]{\langle#1,#2,#3,#4\rangle} 
\newcommand{\empl}{\mathrel{[]}}  \newcommand{\cons}{\mathrel{::}}  \newcommand{\assoc}{\rightarrow}


\newcommand{\enuml}[3]{#1 \ldots #2 \ldots #3}







\newcommand{\inc}{\parop}
\newcommand{\lab}[1]{\langle#1\rangle} 
 
\newtheorem{mydef}{Definition}


\newcommand{\rulename} [1] {{\sc #1}}
\newcommand{\transP}[1]{\stackrel{#1}{\rightarrowtail}}
\newcommand{\transPwithRate}[1]{\stackrel{#1}{\rightarrowtail}}
\newcommand{\transC}[1]{\stackrel{#1}{\rightarrow}}
\newcommand{\transCwithRate}[1]{\stackrel{#1}{\rightarrow}}
\newcommand{\extrudeLoc}[3]{{#1}_{#2}(#3)}
\newcommand{\unfold}[3]{{#1}_{#2}(#3)}
\newcommand{\eqDef}{\stackrel{def}{=}}
\newcommand{\subst}[2]{[{#2}/{#1}]}
\newcommand{\pair}[2]{\langle {#1}, {#2} \rangle}
\newcommand{\rot}{\texttt{rot}}
\newcommand{\mov}{\texttt{mov}}
\newcommand{\movAction}{\ensuremath{\tau}}
\newcommand{\reshape}{\texttt{reshape}}
\newcommand{\shape}[1]{\texttt{space}(#1)} \newcommand{\sha}[1]{\texttt{shape}(#1)}
\newcommand{\dis}[2]{\texttt{dis}(#1,#2)}
\newcommand{\rnd}{\texttt{rnd}}
\newcommand{\delay}{\texttt{delay}}
\newcommand{\tconf}[2] {(#1,#2)} 


\newcommand{\maxSpace}{\texttt{maxSpace}}
\newcommand{\maxShape}{\texttt{maxShape}}
\newcommand{\sh}[2]{#1\mathrel{:}#2}


\newcommand{\ts}[2]{  \{ \!\!\{ #1 \}\!\!\}^{#2} }
\newcommand{\stoc}{{\it st}}
\newcommand{\timed}{{\it t}}
\newcommand{\nstoc}{{\it mv}}
\newcommand{\Redex}[1]{\Re_{#1}}
\newcommand{\Ctx}[1]{C_{#1}}
\newcommand{\hole}{[\;]}

\newcommand{\OK}{{\rm OK}}

\newcommand{\CtxInt}{C}
\newcommand{\redDet}[1]{\rightarrowtail}
\newcommand{\redStoc}[1]{\dashrightarrow}
\newcommand{\redTime}[1]{\stackrel{#1}{\rightsquigarrow}}
\newcommand{\redT}[1]{\labRed{#1}}
\newcommand{\labRed}[1]{{\xrightarrow{#1}}}
\newcommand{\stTime}{\tau}
\newcommand{\tauL}{t}
\newcommand{\g}{\xi,\omega, \sigma}
\newcommand{\gP}{\xi',\omega', \sigma'}
\newcommand{\gU}[1]{\xi_{#1},\omega_{#1}, \sigma_{#1}}
\newcommand{\SPI}{SPi}
\newcommand{\PI}{Pi}
\newcommand{\locP}[3]{\{#1\}_{#3}}


\definecolor{brown}{rgb}{0.85,.66,0}



\newif\ifsubmit
\submitfalse
\ifsubmit
\newcommand{\AC}[1]{#1}
\newcommand{\ACComm}[1]{}
\newcommand{\MD}[1]{#1}
\newcommand{\MDComm}[1]{}
\newcommand{\PG}[1]{#1}
\newcommand{\PGG}[1]{#1}
\newcommand{\PGComm}[1]{}
\newcommand{\AT}[1]{#1}
\newcommand{\ATComm}[1]{}
\newcommand{\md}[1]{#1}
\newcommand{\mdc}[1]{}
\newcommand{\ac}[1]{#1}
\newcommand{\acc}[1]{}
\newcommand{\at}[1]{#1}
\newcommand{\atc}[1]{}
\else
\newcommand{\AC}[1]{\textcolor{blue}{#1}}
\newcommand{\ACComm}[1]{{\scriptsize \textcolor{blue}{[Adriana{:} #1]}}}
\newcommand{\MD}[1]{\textcolor{red}{#1}}
\newcommand{\MDComm}[1]{{\scriptsize \textcolor{red}{[Mariangiola{:} #1]}}}
\newcommand{\PG}[1]{\textcolor{magenta}{#1}}
\newcommand{\PGG}[1]{\textcolor{green}{#1}}
\newcommand{\PGComm}[1]{{\scriptsize \textcolor{magenta}{[Paola{:} #1 ]}}}
\newcommand{\AT}[1]{\textcolor{brown}{#1}}
\newcommand{\ATComm}[1]{{\scriptsize \textcolor{brown}{[Angelo{:} #1 ]}}}
\newcommand{\md}[1]{\textcolor{red}{#1}}
\newcommand{\mdc}[1]{\textcolor{red}{[Mariangiola{:} #1]}}
\newcommand{\ac}[1]{\textcolor{blue}{#1}}
\newcommand{\acc}[1]{\textcolor{blue}{[Adriana{:} #1]}}
\newcommand{\at}[1]{\textcolor{brown}{#1}}
\newcommand{\atc}[1]{\textcolor{brown}{[Angelo{:} #1]}}
\fi



\makeatletter
 \let\@copyrightspace\relax
 \makeatother

\hyphenation{di-men-sion-al delay BioScape}




\title{Parallel BioScape: A Stochastic and Parallel Language for Mobile and Spatial Interactions \thanks{Extended Abstract. This research is funded by the BioBITs Project (\emph{Converging
Technologies} 2007, area: Biotechnology--ICT), Regione Piemonte.}}
\author{Adriana Compagnoni
\institute{Department of Computer Science\\Stevens Institute of Technology}
\and Mariangiola Dezani--Ciancaglini
\institute{Dipartimento di Informatica\\Universit\`a di Torino}
\and Paola Giannini
\institute{Dipartimento di Informatica\\Universit\`a del Piemonte Orientale}
\and Karin Sauer
\institute{Department of Biological Sciences\\Binghamton University}
\and Vishakha Sharma
\institute{Department of Computer Science\\Stevens Institute of Technology}
\and Angelo Troina
\institute{Dipartimento di Informatica\\Universit\`a di Torino}
}

\def\copyrightholders{A.\ Compagnoni, M.\ Dezani--Ciancaglini, P.\ Giannini,\\
  K.\ Sauer, V.\ Sharma, A.\ Troina}

\def\titlerunning{Parallel BioScape: A Stochastic and Parallel Language for Mobile and Spatial Interactions}

\def\authorrunning{A.\ Compagnoni, M.\ Dezani--Ciancaglini, P.\ Giannini,
  K.\ Sauer, V.\ Sharma, A.\ Troina}
\begin{document}
\maketitle


\begin{abstract}BioScape is a concurrent language motivated by the biological
landscapes found at the interface of biology and biomaterials
\cite{BioScape:CS2Bio}. It has been motivated by the need to model
antibacterial surfaces, biofilm formation, and the effect of DNAse in
treating and preventing biofilm infections.
As its predecessor, SPiM
\cite{Phillips07}, BioScape has a sequential semantics based on Gillespie's
algorithm \cite{Gillespie_1977}, and its
implementation does not scale beyond 1000 agents. However, in order to
model larger and more realistic systems, a semantics that may take advantage
of the new multi-core and GPU architectures is needed. This motivates the
introduction of parallel semantics, which is the contribution of this paper: Parallel
BioScape, an extension with fully parallel semantics.
\end{abstract}


Process algebras have been successfully used in the modeling of
biological systems, see \cite{Priami01, CardelliGTP09, Baoetal2010},
where they are
particularly attractive, because of their ability to accommodate new
objects and new behavioral attributes as the complex biological system
becomes better understood.
However, most of the modeling languages lack adequate support for the design of
systems in which to study complex interactions involving both spatial
properties, movements in three-dimensional space, and stochastic interactions.
Recently, new spatial modeling languages
allowing explicit description of temporal spatial dynamics of
biochemical processes have been proposed (SpacePi \cite{spacePi},
DCA \cite{DCA}, \textit{L} \cite{lpi}, Stochsim
\cite{LeNovereEtAl:2001}).
Other agent-based platforms \cite{ABMS}
include
C-Immsim \cite{ISSO, CImmSim} and PathSim visualizer
\cite{PathSim}.
However, few of them support
individual based, continuous motion, and continuous space stochastic
simulation \cite{Bittig10}, which are important features
for modeling temporal spatial dynamics of biochemical processes
accurately.  To address this problem in previous work we introduced
BioScape \cite{BioScape:CS2Bio},
a  language incorporating both stochasticity and 3D spatial attributes.



Gillespie's algorithm produces two outputs in each iteration: 1) the
next reaction \textit R to be executed and 2) a slice of time \textit
t to advance the simulation clock. Since many reactions, including
many instances of the same reaction, may be available, the slice of
time \textit t does not correspond to the time that \textit R would
take, but an amount of time proportional to the time it would take to
execute all available reactions. In contrast, the parallel semantics
will execute all available reactions, not just one instance of one
reaction \textit R, and the first challenge is then how to calculate simulated
time.
Reaction times can vary substantially, for example, some
prokaryotic cell mitosis takes ten minutes, some plant cell mitosis
takes about half an hour, while some animal cell mitosis takes about
three hours.
If we trigger all reactions together, how do we advance the
simulation clock?  The solution we propose here consists of annotating
each product of a reaction with a timer indicating how long that
reaction will take.

For example, if  means that a
 takes 30 minutes to split, through mitosis, into two daughter cells, then we will
annotate the two daughter cells as  and
.
As time lapses, the timer will be reduced, and when reaching ,
both cells will be available for new reactions.


In Fig.~\ref{fig.syntax} we define the syntax of the calculus, which
slightly simplifies the syntax of \cite{BioScape:CS2Bio} in order to
avoid  decorating semantic  processes with shapes, as defined at page \pageref{shape}.


\begin{figure}[t]
\vspace*{-0.8cm}
 {\small  }
\vspace*{-0.6cm}
\caption{Syntax}
 \label{fig.syntax}
\vspace*{-0.5cm}
\end{figure}

We assume a set of channel names, denoted by
, , and a set of variables, denoted by ,
, with subscripts or superscripts, if needed. As usual,
 is , and similar for
.
The empty process is .
By  we denote an instance of the entity defined by .
The actual parameters of the instance may be either channel names or variables,
in case the instance occurs in a definition.
The process  is the parallel composition
of processes  and  .
 By
 we
define the channel name  with two parameters \texttt{r} and
\texttt{rad} within process ; the parameter \texttt{r} is the stochastic
rate for communications through channel  and  is the
communication radius. The radius is the maximum distance between
processes in order to communicate through channel , and the
reaction rate determines how long it takes for two processes to react given that they are close enough
to communicate.

The \textit{heterogeneous} choice is denoted by ,   where  means .    Choices may
  have reaction branches and movement branches.  The reaction branches
  are probabilistic (stochastic), since reactions are subject
  to kinetic reaction rates, while the movement branches are
  non-deterministic, since the movement of instances of entities is always
  enabled, provided there is enough space. The prefix  denotes the action that the process
   can perform. The prefix  is a
  spontaneous and unilateral reaction of a single process, where
  \texttt{r} is the stochastic rate. The prefix  denotes output,
  and the prefix  denotes input.  The prefix  moves
    processes in space according to their diffusion rate () (see below).
We use standard syntactic
abbreviations such as  for
.

We denote by  a global list of definitions. The equality 
defines entity  with formal parameters , to be the choice  with geometry
, specifying a movement space , a step
, and a shape . The choice  describes the behavior of 
  with a choice of prefixed processes. The selection of one of the
  choices depends not only on the available interactions with other
  processes, but also on the available space.
The movement space  is a set of
point coordinates in the global coordinate system defining a
volume. Intuitively,  can move within .  The step , is the distance that  can stir in a movement,
and it corresponds to the diffusion rate of ;
 is the three-dimensional shape (sphere, cube, etc.) of .
The movement space for the empty process 
is everywhere, the global space, and its movement step is 0 by
default.  The entity variable  can be defined at most once  in , and the free variables of
, denoted by , must be a subset of the variables
.
We also write  as short for  and .

We use  to range over environments of channel name
declarations. By  we declare channel name 
with reaction rate \texttt{r} and reaction radius \texttt{rad}. A
channel name  appears at most once in .

Consider the following simple example of a bacterium \texttt{Bac},
that can either move or divide into two daughter cells. \texttt{Bac}
is defined with movement space \texttt{movB}, movement step
\texttt{stepB}, and shape \texttt{shapeB}. Intuitively, bacteria can
move within \texttt{movB}, with non-deterministic steps of length \texttt{stepB},
and the shape \texttt{shapeB} is at all times contained within
\texttt{movB}.  The prefix \texttt{ mov } represents a non-deterministic movement
of length \texttt{stepB}, whereas \texttt {delay@1.0.(Bac() | Bac())}
represents mitosis, the division of a bacterium into two daughter
cells: \texttt{Bac() | Bac()}, and the \texttt{delay@1.0} prefix is
used to model the fact that division is not an instantaneous reaction.\\
\centerline{

}
\begin{figure}[tbp]
\footnotesize{
    \begin{mathpar}
      \inferrule[S.Loc]
      { P \equiv Q}
      { \locP{P}{\sigma}{\mu} \equiv \locP{Q}{\sigma}{\mu} }
      \and
     \inferrule[S.Loc.Nu]
       { }
       { (\nu a@\texttt{r}, \texttt{rad}).\locP{P}{\sigma}{\mu}\equiv \locP{(\nu a@\texttt{r}, \texttt{rad}).P}{\sigma}{\mu}}
        \and
      \inferrule[S.Loc.Par]
      { \mu_1(\sha{P})\cup\mu_2(\sha{Q})=\mu(\sha{P\parop Q})}
      { \locP{P}{\sigma}{\mu_1} \parop \locP{Q}{\sigma}{\mu_2} \equiv \locP{P\parop Q}{\sigma}{\mu} }
     \and
     \inferrule[S.Nu.Com]
       { }
       { (\nu a@\texttt{r}, \texttt{rad}).(\nu b@\texttt{r}', \texttt{rad}').A\equiv (\nu b@\texttt{r}', \texttt{rad}').(\nu a@\texttt{r}, \texttt{rad}).A}
  \and
    \inferrule[S.Nu.Par]
       { a\not\in\fns(B)}
       { ((\nu a@\texttt{r}, \texttt{rad}).A)\parop B\equiv (\nu a@\texttt{r}, \texttt{rad}).(A\parop B)}
    \end{mathpar}}
\vspace*{-0.6cm}
  \caption{Structural Equivalence of Spatial Configurations}
\vspace*{-0.5cm}
  \label{fig.pi.struct}
\end{figure}
A run-time system is represented by a parallel composition of entity instances (without free variables) each
  with its shape, and located in some positions of a global frame.
We define the {\texttt shape} of processes inductively as follows:\\
  \\
where  gives a shape obtained by composing two shapes trough juxtaposition. For different applications we can choose suitable functions to realise , we only require  to be a commutative and associative operator, i.e.  and .



We use  to denote a map which applied to a shape locates it in the global space, by putting its
barycentre at a fixed point, orienting the shape, and possibly modifying it.
So  computes the space occupied by a
  process  in the global coordinate system.\label{shape}
  Processes may also share channels
  for communication. {\em Spatial configurations}, denoted by ,
  ,  are defined as follows:\\
\centerline{
}
Structural equivalence on configurations is defined in Fig.~\ref{fig.pi.struct}, omitting the rules for associativity and commutativity of  and
. Parallel composition  has
neutral element  for any .
Rule \rulename{S.Loc} uses
the standard structural equivalence of \PI-calculus processes.
The premise
  of rule \rulename{S.Loc.Par} assures that the two equivalent
  processes occupy exactly the same space.
In rule
\rulename{S.Nu.Par},  is a function that returns the set of free channel names of a configuration.
\begin{figure}[bp]
\vspace*{-0.4cm}
\footnotesize{
    \begin{mathpar}
     \inferrule[SR.Delay]
        {X(\overline{x})= (delay@\texttt{r}.P\;[+\;M])^{\xi,\omega,\sigma}\in D }
        {E\these \locP{X(\overline{a})}{\sigma}{\mu}\labRed{\texttt{r}} \locP{P[\overline{a}/\overline{x}]}{\sigma}{\mu}}\and
        \inferrule[SR.Str]
        { A \equiv A'\\ E\these A' \labRed{\texttt{r}} B'\\ B' \equiv B }
        { E\these A \labRed{\texttt{r}} B }\and
  \inferrule[SR.Com]
        {X(\overline{x})= (!a(b).P\;[+\;M])^{\xi,\omega,\sigma}\in D\quad
        Y(\overline{y})= (?a(z).Q\;[+\;N])^{\xi',\omega',\sigma'}\in D\quad \dis{\mu} {\mu'} \leq\texttt{rad}}
        {E,   a@\texttt{r}, \texttt{rad}\these  \locP{X(\overline{c})}{\sigma}{\mu} \parop
          \locP{Y(\overline{d})}{\sigma'}{\mu'}
          \labRed{\texttt{r}}\locP{P[\overline{c}/\overline{x}]}{\sigma}{\mu} \parop
          \locP{Q[\overline{d}/\overline{y}][b/z]}{\sigma'}{\mu'} }
\end{mathpar}}
\vspace*{-0.6cm}
  \caption{Stochastic Reduction Relation}
\vspace*{-0.5cm}
  \label{fig:stoc.reduction}
\end{figure}

\begin{figure}[tbp]
\footnotesize{
    \begin{mathpar}
  \inferrule[NR.Move]
      { \mu'=\texttt{translate}(\omega,\mu)  \quad
         \mu'(\sigma) \subseteq         \xi \quad
        X(\overline{x})= (\mov.P \;[+\;M])^{\xi,\omega,\sigma}\in D}
      { \locP{X(\overline{a})}{\sigma'}{\mu} \labRed{}
        \locP{P[\overline{a}/\overline{x}]}{\sigma'}{\mu'}}
\and
        \inferrule[NR.Str]
        { A \equiv A'\\  A' \labRed{} B'\\ B' \equiv B }
        {  A \labRed{} B }
    \end{mathpar}}
  \vspace*{-0.6cm}
  \caption{Non-stochastic Reduction Relation}
\vspace*{-0.5cm}
  \label{fig.rednorate}
\end{figure}

The (parallel) operational semantics of BioScape is based on two {\em
  auxiliary} reduction
relations: a stochastic
relation, , for reactions such as
synchronisation and delay, defined in Fig.~\ref{fig:stoc.reduction}, and
a non-deterministic (non-stochastic) relation, , for
geometric transformations, in our case movement, defined in
Fig.~\ref{fig.rednorate}. Notice that reduction axioms (\rulename{SR.Delay, SR.Com, NR.Move}) only involve entities (), and entities evolve according to one of the choices  in their
definitions. In rules \rulename{SR.Delay, SR.Com} and
\rulename{NR.Move},  there is no  check of whether the entities of the
resulting process have enough space, since this check is done in the
parallel reductionrules \rulename{PR.Stoc}, and \rulename{PR.Move} of
Fig.~\ref{fig:par.reduction}. In particular, a stochastic
(non-stochastic) redex is stuck, if there is not enough space for its
reduct in the configuration. Therefore, the {\em evolution of systems in parallel BioScape  produces configurations in which space is consistent}.


Fig.~\ref{fig:stoc.reduction} defines the stochastic reduction
relation of BioScape, , where
 is the rate of the channel used for synchronization or delay.
 We write 
for the distance between the origin of
 and the origin of . In rule
\rulename{SR.Com} the condition 
ensures that located processes
 and  are close enough to communicate through
channel .
The non-stochastic reduction relation  of BioScape,
 , is defined in Fig.~\ref{fig.rednorate}.
By  \texttt{translate}(,) we denote the function that randomly generates a new
map , using the movement step  and the old
map . The condition  of rule \rulename{NR.Move}
ensures the new located process
 is within the movement space  of  (see previous remark about not checking if the entity moves to an empty space).

For stochastic reductions we compute the duration of the reduction, based on the exponential distribution associated with the propensity of the reduction. Since reductions may have different durations, we introduce {\em timed configurations}, , meaning that, after a time , this configuration will be . We extend structural equivalence to timed configurations by adding that , and  implies . With the metavariables , and  we denote either spatial configurations or timed configurations ({\em extended configurations}), i.e.,\\
\centerline{
 
}


We define a reduction strategy that given the whole configuration,
first moves all the processes that can be moved, and then executes all
the stochastic reductions that can be executed, omitting only
reductions which would lead to overlaps,
i.e. configurations where some entities occupy the same space. Both
non-stochastic and stochastic reductions are applied in parallel. For
this purpose, we define multi-hole contexts  by the following
grammar:\\
\centerline{

}
Congruence on multi-hole contexts is naturally induced by the congruence on configuration, associativity and commutativity of the parallel operator, and standard rules for  restrictions similar to \rulename{S.Nu.Com} and \rulename{S.Nu.Par}. Given this congruence any multi-hole context, , may be written in a {\it canonical form}. That is, there is ,  such that ,
where , , is an abbreviation for , and for all , ,  for some , and , or  for some , and . We say that  is .
In the following we assume that multi-hole contexts are always in canonical form.

As already mentioned, our reduction strategy avoids spatial
overlaps. In particular for moving reductions we have to ensure
that moves and reshaping are compatible with the available space, that
is after moving no entity overlaps with another entity. For stochastic reductions we have to assure that the created entities have their space.
To this aim we define the space of a configuration, and a predicate that says whether a configuration does not have any overlapping entities.

Let  be a function on configuration  that returns the
space occupied by its processes located in the global frame defined as follows.\\
\centerline{}
We say that a configuration  is  if the various entities in  do not overlap, that is:\\
\centerline{
}
With the notion of  configuration we define  two notions of
{\it well-formedness of configurations}.
The first notion is to be used for parallel
move reductions and the second for parallel stochastic reductions.
Theses notions are to be used to enforce  the fact that only
reductions that have enough space for their reduct are allowed, and
 that we want {\em maximal parallelism}, that is any ``extra''
movement or transformation would produce an overlap.  In order to formalise this
we first need to single out the sets  and  of movement and stochastic redexes, i.e. we define:\vspace{-1mm}
\begin{itemize}
\item ,
\item \\
\\

 where  is the declaration of channel .
\end{itemize}\vspace{-1mm}
We extend the syntax of configurations by allowing {\em underlined  extended configurations}, defined by: an underlined  extended configurations is a configuration in which some spatial sub-configurations may be underlined. Underlined configurations
are the tool we use to define maximal parallelism. We can then define:\vspace{-1mm}
\begin{mydef}
\begin{enumerate}
\item An extended configuration  is  if  is  and  with  not underlined and  and   imply  not .\vspace{-1mm}
\item An extended configuration  is  if  is  and  with  not underlined and  and   imply  not .
\end{enumerate}
\end{mydef}\vspace{-1mm}
As a last notion, we say that a context  is {\em untimed} if it does not contain timed configurations.

\begin{figure}[tbp]
\vspace*{-0.2cm}
\footnotesize{
    \begin{mathpar}
      \inferrule[PR.Move]
        { F_i\labRed{}G_i \quad (1\leq i\leq p)
\\
       \Ctx{}[\underline{G_1}]\cdots[\underline{G_p}]\ \OK_\nstoc \\
        }
        {\Ctx{}[F_1]\cdots[F_p]\redDet{}\Ctx{}[G_1]\cdots[G_p]}

    \inferrule[PR.Timed] {n=min\{n_i\;|\;1\leq i\leq p\}\quad \Ctx{}\text{ is untimed}}
      {\Ctx{}[\ts{A_1}{n_1}]\cdots[\ts{A_p}{n_p}]\redTime{}\Ctx{}[\ts{A_1}{n_1-n}]\cdots[\ts{A_p}{n_p-n}]
      }


      \inferrule[PR.Stoc]
      {{\tt restr}(\Ctx{})\these A_i\labRed{\texttt{r}_i} B_i\quad
\quad n_i=\stTime(\texttt{r}_i,\CtxInt_i[A_i])
        \quad
(1\leq i\leq p)\\
         \Ctx{}[\CtxInt_{1}[\underline{B_1}]]\cdots[\CtxInt_{p}[\underline{B_p}]]\ \OK_\stoc
      }
      {\Ctx{}[\CtxInt_1[A_1]]\cdots[\CtxInt_{p}[A_p]]\redStoc{}\Ctx{}[\CtxInt_1[\ts{B_1}{n_1}]]\cdots[\CtxInt_{p}[\ts{B_p}{n_p}]] }

\inferrule[PR.Conf]
{F\redDet{} F_1\redStoc{} F_2\redTime{}F'}
{F\redT{} F'}
    \end{mathpar}}
\vspace*{-0.6cm}
  \caption{Parallel Reduction Relation}
\vspace*{-0.5cm}
  \label{fig:par.reduction}
\end{figure}
We are now able to explain our  parallel reduction strategy, whose rules are given in Fig.~\ref{fig:par.reduction}. The first three rules deal respectively with parallel movements, timed reductions, and stochastic reductions, while the fourth rule maps extended configurations into extended configurations by applying first the parallel movements, then the stochastic interactions, and finally by advancing the time of the minimum required to complete one or more interactions. In this way at the next iteration there would be new entities to be moved and/or stochastically reduced.

The condition of obtaining an  extended configuration in
rule  \rulename{PR.Move} assures that all possible moves in
 which do not cause overlaps have been done in
the reduction.  Similar effect is produced by the conditions that the
extended configuration is  and that the context is timed in
the following two rules, respectively. Rule \rulename{PR.Stoc}
prescribes that the time of a stochastic reaction depends (through the
function ) on the  rate of the reduction and on the number of
available reactants. The outer context  is a multi-hole context, while the context  of the redex  is a
single hole context capturing the surrounding environment that influences the speed of the reduction.
We could incorporate a counting function keeping track of the available reactants in the communication range (in a way similar to what is done, e.g., in~\cite{BDGT12,CWCTCS}).

Examples, results of
simulations, comparisons with related papers and discussions  can be found in the full version of this papers available at \url{http://www.di.unito.it/~dezani/papers/cdgsst.pdf}.
\vspace{-7mm}
\bibliographystyle{eptcs}
\bibliography{TPrefs}
\end{document}
