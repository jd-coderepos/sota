
\documentclass{article} \usepackage{iclr2020_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{booktabs}
\usepackage{amsmath}
\usepackage{bbm}
\usepackage{multirow}
\usepackage{array}
\usepackage{wrapfig}
\usepackage{enumitem}

\usepackage{hyperref}
\usepackage{url}
\usepackage{varwidth}


\title{Generalization through Memorization: \\ Nearest Neighbor Language Models}



\author{
Urvashi Khandelwal\thanks{Work done while the first author was interning at Facebook AI Research.}, Omer Levy, Dan Jurafsky, Luke Zettlemoyer \& Mike Lewis\\
Stanford University\\
Facebook AI Research\\
 {\tt \{urvashik,jurafsky\}@stanford.edu}\\
  {\tt \{omerlevy,lsz,mikelewis\}@fb.com}
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}


\newif\ifcomment
\commenttrue


\ifcomment
\newcommand{\uk}[1]{\textcolor{red}{UK: #1}}
\newcommand{\omer}[1]{\textcolor{blue}{OL: #1}}
\newcommand{\luke}[1]{\textcolor{orange}{LZ: #1}}
\newcommand{\mike}[1]{\textcolor{cyan}{ML: #1}}
\newcommand{\dan}[1]{\textcolor{magenta}{DJ: #1}}
\else
\newcommand{\uk}[1]{}
\newcommand{\omer}[1]{}
\newcommand{\mike}[1]{}
\newcommand{\dan}[1]{}
\newcommand{\luke}[1]{}
\fi

\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}
We introduce NN-LMs, which extend a pre-trained neural language model (LM) by linearly interpolating it with a -nearest neighbors (NN) model. 
The nearest neighbors are computed according to distance in the pre-trained LM embedding space, and can be drawn from any text collection, including the original LM training data. 
Applying this augmentation to a strong \textsc{Wikitext-103} LM, with neighbors drawn from the original training set, our NN-LM achieves a new state-of-the-art perplexity of 15.79 -- a 2.9 point improvement with no additional training. 
We also show that this approach has implications for efficiently scaling up to larger training sets and allows for effective domain adaptation, by simply varying the nearest neighbor datastore, again without further training. 
Qualitatively, the model is particularly helpful in predicting rare patterns, such as factual knowledge.
Together, these results strongly suggest that learning similarity between sequences of text
is easier than predicting the next word, and that nearest neighbor search is an effective approach for language modeling in the long tail.

 \end{abstract}



\section{Introduction}
\label{sec:intro}

Neural language models (LMs) typically solve two subproblems: (1) mapping sentence prefixes to fixed-sized representations, and (2) using these representations to predict the next word in the text \citep{bengio2003neural,mikolov2010recurrent}. 
We present a new language modeling approach that is based on the hypothesis that the representation learning problem may be easier than the prediction problem.
For example, any English speaker knows that \emph{Dickens is the author of} and \emph{Dickens wrote} will have essentially the same distribution over the next word, even if they do not know what that distribution is.
We provide strong evidence that existing language models, similarly, are much better at the first problem, by using their prefix embeddings in a simple nearest neighbor scheme that significantly improves overall  performance. 

We introduce NN-LM, an approach that extends a pre-trained LM by linearly interpolating its next word distribution with a -nearest neighbors (NN) model. The nearest neighbors are computed according to distance in the pre-trained embedding space and can be drawn from any text collection,  including the original LM training data.
This approach allows rare patterns to be memorized explicitly, rather than implicitly in model parameters.  It also improves performance when the same training data is used for learning the prefix representations and the NN model, strongly suggesting that the prediction problem is more challenging than previously appreciated.

To better measure these effects, we conduct an extensive empirical evaluation. Applying our NN augmentation to a strong  \textsc{Wikitext-103} LM using only the original dataset achieves a new state-of-the-art perplexity of 15.79 -- a 2.86 point improvement over the base model~\citep{baevski2019adaptive} -- with no additional training.
We also show that the approach has implications for efficiently scaling up to larger training sets and allows for effective domain adaptation, by simply varying the nearest neighbor datastore. 
Training a model on 100-million tokens and using NN search over a 3-billion token dataset can outperform training the same model on all 3-billion tokens, opening a new path for efficiently using large datasets in language models.
Similarly, adding out-of-domain data to the datastore makes a single LM useful across multiple domains, again without further training.
Qualitatively, we find the model is particularly helpful for long-tail patterns, such as factual knowledge, 
which might be easier to access via explicit memory.
 

\begin{figure*}
    \centering
	\includegraphics[width=0.98\textwidth]{fig/knn_lm_diagram.pdf}
    \caption{An illustration of NN-LM. A datastore is constructed with an entry for each training set token, and an encoding of its leftward context. For inference, a test context is encoded, and the  most similar training contexts are retrieved from the datastore, along with the corresponding targets. A distribution over targets is computed based on the distance of the corresponding context from the test context. This distribution is then interpolated with the original model's output distribution.}
    \label{fig:illustration}
\end{figure*}



\section{Nearest Neighbor Language Modeling}
\label{sec:model}

Language models (LMs) assign probabilities to sequences. Given a \emph{context}  sequence of tokens , autoregressive LMs estimate , the distribution over the \emph{target} token .

The NN-LM involves augmenting such a pre-trained LM with a nearest neighbors retrieval mechanism, without any additional training (the representations learned by the LM remain unchanged).
This can be done with a single forward pass over a text collection (potentially including the original LM training set), where the resulting context-target pairs are stored in a key-value datastore that is queried during inference, as illustrated in Figure~\ref{fig:illustration}.

\paragraph{Datastore}
Let  be the function that maps a context  to a fixed-length vector representation computed by the pre-trained LM.
For instance, in a Transformer LM,  could map  to an intermediate representation that is output by an arbitrary self-attention layer. 
Then, given the -th training example , we define the key-value pair , where the key  is the vector representation of the context  and the value  is the target word .
The datastore  is thus the set of all key-value pairs constructed from all the training examples in :


\paragraph{Inference}
At test time, given the input context 
the model generates the output distribution over next words  and the context representation .
The model queries the datastore with  to retrieve its -nearest neighbors  according to a distance function  (squared  distance in our experiments, making the similarity function an RBF kernel).Then, it computes a distribution over neighbors based on a softmax of their negative distances, while aggregating probability mass for each vocabulary item across all its occurrences in the retrieved targets (items that do not appear in the retrieved targets have zero probability): 



Finally, we follow \citet{grave2017unbounded} and interpolate the nearest neighbor distribution  with the model distribution  using a tuned parameter  to produce the final NN-LM distribution:


\paragraph{Implementation}
The datastore contains an entry for each target in the training set, which for LMs can be up to billions of examples.
To search over this large datastore, we use FAISS \citep{johnson2017billion}, an open source library for fast nearest neighbor retrieval in high dimensional spaces.
FAISS speeds up search by clustering the keys and looking up neighbors based on the cluster centroids, while reducing memory usage by storing compressed versions of the vectors. We found in preliminary experiments that using  distance for FAISS retrieval results in better performance for NN-LM,  compared to inner product distance.


\paragraph{Related Cache Models}
Prior work \citep{grave2017improving,merity2017pointer} used a similar approach to compute similarity to the previous hidden states of \emph{test} documents, making it easier to copy rare vocabulary items from the recent past. 
Such techniques have been less popular since the development of Transformers \citep{vaswani2017attention}, which can learn to copy recent words using self-attention; in Section~\ref{sec:wikiresults}, we observe relatively small gains from caching recent items in the same test document \`{a} la \citet{grave2017improving}.
Most relatedly, \citet{grave2017unbounded} describe an \emph{online} language model using nearest neighbor search over all previous hidden states, to improve domain adaptation.
In our work, we only save training data, with the goal of explicitly memorizing training examples to better generalize to similar cases at test time. 


\section{Experimental Setup}
\label{sec:setup}

\paragraph{Data} 
Experiments in this paper use the following English corpora:


\textsc{Wikitext-103} is a standard benchmark by \cite{merity2017pointer} for autoregressive language modeling with a 250K word-level vocabulary.
It consists of 103M tokens of Wikipedia in the training set and 250K tokens in each of the development and test sets. 

\textsc{Books} is the Toronto Books Corpus \citep{zhu2015aligning}, containing 0.7B. Complete books are held out for validation/test.

\textsc{Wiki-3B} is English Wikipedia, containing about 2.87B tokens. Whole articles are held out for validation/test.

\textsc{Wiki-100M} is a random 100M token subset of \textsc{Wiki-3B}, consisting of complete articles.






Except for \textsc{Wikitext-103}, text is tokenized using the byte-pair encoding \citep{sennrich2015neural} with the 29K subword vocabulary from BERT \citep{devlin2018bert}.



\paragraph{Model Architecture} NN-LM is compatible with any model that produces fixed size context representations. We use decoder-only Transformers \citep{vaswani2017attention} for language modeling, which are the current state of the art.
Since the NN-LM makes no changes to the underlying LM, we take the exact architecture and optimization described by \citet{baevski2019adaptive} and use it to create a NN-LM for inference.
This model consists of 16 layers, each with 16 self-attention heads, 1024 dimensional hidden states, and 4096 dimensional feedforward layers, amounting to 247M trainable parameters.
It processes 3072 tokens of context per example for \textsc{Wikitext-103} and 1024 tokens for the rest of the corpora.
Following \citet{baevski2019adaptive}, we use adaptive inputs and an adaptive softmax \citep{grave2017efficient} with tied weights \citep{press2016using} for the \textsc{Wikitext-103} experiments. On other datasets we do not use adaptive inputs or an adaptive softmax.


\paragraph{Evaluation}
LMs are trained to minimize the negative log-likelihood of the training corpus,
and evaluated by perplexity (exponentiated negative log-likelihood) on held out data.
Following \citet{baevski2019adaptive}, 512 tokens are scored per test example, but up to 2560 tokens of extra prior context is provided for \textsc{Wikitext-103} and up to 512 tokens of extra prior context is provided for the rest of the corpora.

\paragraph{NN-LM}
The keys used for NN-LM are the 1024-dimensional representations fed to the feedforward network in the final layer of the Transformer LM (after self-attention and layernorm; see Section~\ref{sec:hpstudy} for further explanation).
We perform a single forward pass over the training set with the trained model, in order to save the keys and values.
During this forward pass, each target token is provided a minimum of 1536 tokens of prior context for \textsc{Wikitext-103} and a minimum of 512 tokens for the rest of the corpora.
A FAISS index is then created using 1M randomly sampled keys to learn 4096 cluster centroids. For efficiency, keys are quantized to 64-bytes.
During inference, we retrieve  neighbors, and the index looks up 32 cluster centroids while searching for the nearest neighbors.
For \textsc{Wikitext-103} experiments, we compute squared  distances with full precision keys, but for the other datasets we use the FAISS  distances (not squared) between quantized keys directly, for faster evaluation.
We tune the interpolation parameter  on the validation set.\footnote{Code is available at: \url{https://github.com/urvashik/knnlm}} 


\paragraph{Computational Cost}
Although the NN-LM requires no training given an existing LM, it does add some other computational overheads.
Storing the keys and values requires a single forward pass over the training set, which amounts to a fraction of the cost of training for one epoch on the same examples.
Once the keys are saved, for \textsc{Wikitext-103} building the cache with 103M entries takes roughly two hours on a single CPU.
Finally, running on the validation set took approximately 25 minutes when retrieving 1024 keys. 
While the cost of building a large cache grows linearly in the number of entries, it is trivial to parallelize and requires no GPU-based training.






\section{Experiments}

\subsection{Using the Training Data as the Datastore}
\label{sec:wikiresults}

\begin{table*}[t]
    \centering
    \begin{tabular}{l>{\centering\arraybackslash}m{1.5cm}>{\centering\arraybackslash}m{1.5cm}c}
        \toprule[1.5pt]
\textbf{Model} & \multicolumn{2}{c}{\textbf{Perplexity ()}} & \textbf{\# Trainable Params}\\
        & Dev & Test\\
        \midrule[0.5pt]
        \citet{baevski2019adaptive} & 17.96 & 18.65 & 247M\\
        \hspace{0.5em} +Transformer-XL \citep{dai2019transformer} & - & 18.30 & 257M\\
        \hspace{0.5em} +Phrase Induction \citep{luo2019improving} & - & 17.40 & 257M\\
\midrule[0.5pt]
        \midrule[0.5pt]
Base LM \citep{baevski2019adaptive}& 17.96 & 18.65 & 247M\\
        \hspace{0.5em} +NN-LM& \textbf{16.06} & \textbf{16.12} & 247M\\
        \addlinespace[0.15em]
        \midrule[0.5pt]
\hspace{0.3em} +Continuous Cache \citep{grave2017improving} & 17.67 & 18.27 & 247M\\
        \hspace{0.3em} +NN-LM + Continuous Cache & \textbf{15.81} & \textbf{15.79} & 247M\\
        \addlinespace[0.15em]
        \bottomrule[1.5pt]
    \end{tabular}
    \caption{Performance on \textsc{Wikitext-103}. The NN-LM substantially outperforms existing work. Gains are additive with the related but orthogonal continuous cache, allowing us to improve the base model by almost 3 perplexity points with no additional training. We report the median of three random seeds.}
    \label{tab:wikiresults}
\end{table*}



\begin{table*}
    \centering
    \begin{tabular}{l>{\centering\arraybackslash}m{1.5cm}>{\centering\arraybackslash}m{1.5cm}c}
        \toprule[1.5pt]
\textbf{Model} & \multicolumn{2}{c}{\textbf{Perplexity ()}} & \textbf{\# Trainable Params}\\
        & Dev & Test\\
        \midrule[0.5pt]
        Base LM \citep{baevski2019adaptive} & 14.75 & 11.89 & 247M\\
        \hspace{0.3em} +NN-LM & \textbf{14.20} & \textbf{10.89} & 247M\\
        \addlinespace[0.15em]
        \bottomrule[1.5pt]
    \end{tabular}
    \caption{Performance on \textsc{Books}, showing that NN-LM works well in multiple domains.}
    \label{tab:books}
\end{table*}

We first experiment with creating a datastore from the same data used to train the LM.
Table~\ref{tab:wikiresults} shows that NN-LM improves perplexity on \textsc{Wikitext-103} from 18.65 \citep{baevski2019adaptive} to a new state-of-the-art of 16.12.
We also provide reported perplexities from two other recent models that also build upon Baevski and Auli's, suggesting that further improvements may be possible by augmenting the NN-LM with these techniques.
We compare with models trained only on the standard training set, but recent work has shown performance can be improved by training on additional data, from either the test set \citep{krause2019dynamic} or large amounts of web text \citep{shoeybi2019megatron}.


We also experiment with a continuous cache model, a related but orthogonal technique from \citet{grave2017improving}, in which the model saves and retrieves neighbors from earlier in the test document, rather than the training set.
Gains from interpolating with the continuous cache are smaller than reported in the original setting that used LSTMs, perhaps because self-attentive language models can learn to perform such queries.
Improvements from the continous cache are additive with the NN-LM, pushing our state-of-the-art result to 15.79, a gain of 2.86 over the base model.

Finally, we repeat the experiment using text from a different domain, \textsc{Books}, to control for the possibility that encyclopedic Wikipedia text is somehow uniquely good for caching. 
Table~\ref{tab:books} shows an improvement in test set perplexity from 11.89 to 10.89, suggesting that this is not the case. 



\subsection{More Data without Training}
\label{sec:large}

Section~\ref{sec:wikiresults} has shown that retrieving neighbors from the training data can significantly improve language modeling performance.
This raises the question: can retrieving nearest neighbors from data be a substitute for training on it?
To test this, we train a LM on \textsc{Wiki-100M} and use it to build a datastore from \textsc{Wiki-3B}, a corpus 30 times larger than the training set.
We then compare this NN-LM to a vanilla LM trained on the entire \textsc{Wiki-3B} corpus.\footnote{The original LM \citep{baevski2019adaptive} was trained for 286K steps on a corpus of similar size to \textsc{Wiki-100M}. When scaling up to \textsc{Wiki-3B}, we tuned only the number of updates on the validation set and found that training for 572K steps (double) produces a slightly stronger baseline.}





\begin{table*}[t]
    \centering
\begin{tabular}{lc>{\centering\arraybackslash}m{1.5cm}c}
        \toprule[1.5pt]
        \textbf{Training Data} &\textbf{Datastore} & \multicolumn{2}{c}{\textbf{Perplexity ()}} \\
        && Dev & Test \\
        \midrule[0.5pt]
\textsc{Wiki-3B} & \centering{-} & 16.11 & 15.17 \\
        \textsc{Wiki-100M} & - & 20.99 & 19.59 \\
        \midrule[0.5pt]
\textsc{Wiki-100M} & \textsc{Wiki-3B}  & 14.61 & 13.73 \\
        \addlinespace[0.15em]
        \bottomrule[1.5pt]
    \end{tabular}
    \caption{Experimental results on \textsc{Wiki-3B}. The model trained on 100M tokens is augmented with a datastore that contains about 3B training examples, outperforming the vanilla LM trained on the entire \textsc{Wiki-3B} training set.}
    \label{tab:bwresults}
\end{table*}
\begin{figure*}[t]
		\centering
		\begin{subfigure}{0.49\textwidth}
            \centering
            \includegraphics[width=\linewidth]{fig/size_wiki.pdf}
            \caption{Effect of datastore size on perplexities.}
            \label{fig:size_ppls}
        \end{subfigure}\begin{subfigure}{0.49\textwidth}
            \centering
            \includegraphics[width=\linewidth]{fig/lambda_wiki.pdf}
            \caption{Tuned values of  for different datastore sizes.}
            \label{fig:size_lambda}
        \end{subfigure}\caption{Varying the size of the datastore. (a) Increasing the datastore size monotonically improves performance, and has not saturated even at about 3B tokens. A NN-LM trained on 100M tokens with a datastore of 1.6B tokens already outperforms the LM trained on all 3B tokens. (b) The optimal value of  increases with the size of the datastore.}
		\label{fig:size}
\end{figure*}

Table \ref{tab:bwresults} shows that, as expected, the model trained on 3B tokens dramatically outperforms the model trained on 100M tokens, improving perplexity from 19.59 to 15.17.
However, adding nearest neighbors retrieval over those 3B examples to the model trained on 100M tokens improves perplexity from 19.59 to 13.73; i.e. \emph{retrieving nearest neighbors from the corpus outperforms training on it}.
This result suggests that rather than training language models on ever larger datasets, we can use smaller datasets to learn representations and augment them with NN-LM over a large corpus.

To understand how the amount of data used for NN retrieval affects performance, we use the \textsc{Wiki-100M} model to create datastores using different amounts of randomly sampled data from \textsc{Wiki-3B}.
Figure~\ref{fig:size_ppls} shows that using only 1.6B examples for the datastore already surpasses the performance of the model trained on all of \textsc{Wiki-3B}.
In addition, performance does not saturate at 3B examples in the datastore, suggesting that growing the datastore more could lead to further gains.
Figure~\ref{fig:size_lambda} shows the model relies more on the NN component as the size of the datastore increases.














\subsection{Domain Adaptation}
\label{sec:domadapt}

We also experiment with domain adaptation by creating a datastore on the target domain training set.
Table~\ref{tab:domadapt} shows that an in-domain LM on \textsc{Books} has a relatively low perplexity (11.89), while a model trained on \textsc{Wiki-3B} performs poorly on the \textsc{Books} domain (34.84 perplexity).
Adding NN search over \textsc{Books} to the \textsc{Wiki-3B} model reduces perplexity by 14 points (to 20.47), demonstrating that 
NN-LM allows a single model to be useful in multiple domains, by simply adding a datastore per domain.




\begin{table*}[t]
    \centering
    \begin{tabular}{lc>{\centering\arraybackslash}m{1.5cm}>{\centering\arraybackslash}m{1.5cm}c}
        \toprule[1.5pt]
        \textbf{Training Data} &\textbf{Datastore} & \multicolumn{2}{c}{\textbf{Perplexity ()}}\\&& Dev & Test \\
        \midrule[0.5pt]
        \textsc{Wiki-3B} &-& 37.13 & 34.84\\\textsc{Books} &-& 14.75 & 11.89\\\midrule[0.5pt]
\textsc{Wiki-3B} & \textsc{Books} & 24.85 & 20.47\\\addlinespace[0.15em]
        \bottomrule[1.5pt]
    \end{tabular}
    \caption{Domain adaptation experiments, with results on \textsc{Books}. Adding an in-domain datastore to a Wikipedia-trained model improves results by 23 points, approaching in-domain training.}
    \label{tab:domadapt}
\end{table*}
 

\section{Tuning Nearest Neighbor Search}
\label{sec:hpstudy}

While the NN-LM is conceptually straightforward, and requires no additional training, a number of hyperparameters are introduced for nearest neighbor search. 
We experiment with different choices here. 


\paragraph{Key Function} 
For similarity search, we extract a representation of context  using an intermediate state of the LM . 
Transformers compute a number of different intermediate states, and we compare several choices depicted in Figure~\ref{fig:tlm_layer}, with results shown in Table~\ref{tab:keytypes}. 
While all the instantiations of  we tried are helpful, we achieved the largest improvement by using the input to the final layer's feedforward network.
We also observe that normalized representations (i.e. taken immediately after the layer norm) perform better.
Repeating the experiment on the second-last transformer layer showed similar trends with slightly worse results (not shown), suggesting that the feedforward layer might be focusing more on the prediction problem, while the onus of representing the input falls more on the self-attention layer.
\begin{table*}[t]
\begin{minipage}[b]{0.4\linewidth}
    \centering
    \includegraphics[height=45mm]{fig/transformer.pdf}
    \captionof{figure}{Transformer LM layer.}
    \label{fig:tlm_layer}
  \end{minipage}
  \hfill
\begin{varwidth}[b]{0.55\linewidth}
    \centering
    \small
    \begin{tabular}{lccc}
        \toprule[1.5pt]
        \textbf{Key Type} & \textbf{Dev ppl. ()}\\
        \midrule[0.5pt]
        No datastore & 17.96\\
        Model output & 17.07\\
        Model output layer normalized & 17.01\\
        FFN input after layer norm & \textbf{16.06}\\
        FFN input before layer norm & 17.06\\
        MHSA input after layer norm & 16.76\\
        MHSA input before layer norm & 17.14\\
        \addlinespace[0.15em]
        \bottomrule[1.5pt]
    \end{tabular}
    \caption{\textsc{Wikitext-103} validation results using different states from the final layer of the LM as the representation function  for keys and queries. We retrieve =1024 neighbors and  is tuned for each.}
\label{tab:keytypes}
    \end{varwidth}
\end{table*}



\begin{figure*}[t]
	\centering
	\begin{varwidth}[t]{0.49\linewidth}
		\centering
		\includegraphics[width=0.9\textwidth]{fig/diff_knns.pdf}
		\caption{Effect of the number of nearest neighbors returned per word on \textsc{Wikitext-103} (validation set). Returning more entries from the datastore monotonically improves performance.}
 		\label{fig:knn}
	\end{varwidth}
	\hfill
	\begin{varwidth}[t]{0.49\linewidth}
		\centering
		\includegraphics[width=0.9\textwidth]{fig/diff_lambs.pdf}
		\caption{Effect of interpolation parameter  on in-domain (left y-axis) and out-of-domain (right y-axis) validation set performances. More weight on  improves domain adaptation.}
		\label{fig:lambda}
	\end{varwidth}
\end{figure*}

\paragraph{Number of Neighbors per Query} Each query returns the top- neighbors. 
Figure \ref{fig:knn} shows that performance monotonically improves as more neighbors are returned, and suggests that even larger improvements may be possible with a higher value of . Nonetheless, even a small number of neighbors () is enough to achieve a new state of the art.

\paragraph{Interpolation Parameter} We use a parameter  to interpolate between the base model distribution and the distribution from NN search over the dataset. Figure \ref{fig:lambda} shows that  is optimal on \textsc{Wikitext-103}. However,  works best for domain adaptation results (Figure \ref{fig:lambda}).

\paragraph{Precision of Similarity Function} In FAISS, the nearest neighbor search computes  distances against quantized keys. We found results were improved from 16.5 perplexity on \textsc{Wikitext-103} to 16.06 by computing squared  distances with full precision keys for Equation \ref{equation:p_knn}. 


 

\section{Analysis}

\paragraph{Qualitative Analysis}
To understand why NN-LM improves performance, we manually examine cases in which  was significantly better than .
Table \ref{figure:output} shows one such example, along with several others in Appendix~\ref{sec:appendix}. The example shows an interesting case where the model matches the trigram \emph{impact on the} in several retrieved neighbors, but puts almost all weight on the most relevant neighbor, thus adding more value than an -gram LM.

In general, we find that examples where NN-LM is most helpful typically contain rare patterns.
Examples include factual knowledge, names, and near-duplicate sentences from the training set.
In these cases, assigning train and test instances similar representations (via ) appears to be an easier problem than implicitly memorizing the next word in model parameters.

\begin{figure}[t]
\centering
\small
\begin{tabular}{p{9.5cm}>{\centering\arraybackslash}m{1.6cm}>{\centering\arraybackslash}m{1.6cm}}
        \toprule[1.5pt]
\textbf{Test Context} ~~~ (, )         & \textbf{Test Target}        &                     \\ \midrule[0.75pt]
\emph{it was organised by New Zealand international player Joseph Warbrick, promoted by civil servant Thomas Eyton, and managed by James Scott, a publican. The Natives were the first New Zealand team to perform a haka, and also the first to wear all black. They played 107 rugby matches during the tour, as well as a small number of Victorian Rules football and association football matches in Australia. Having made a significant impact on the...}                    & development                    \\\addlinespace[0.15em]
                     \midrule[0.75pt]
\textbf{Training Set Context} & \textbf{Training Set Target} & \textbf{Context Probability} \\ 
                     \midrule[0.75pt]
\emph{As the captain and instigator of the 1888-89 Natives -- the first New Zealand team to tour the British Isles -- Warbrick had a lasting impact on the...}  &  development        &  0.998                   \\\addlinespace[0.5em]\emph{promoted to a new first grade competition which started in 1900. Glebe immediately made a big impact on the...}  &  district        &  0.00012                   \\\addlinespace[0.5em]\emph{centuries, few were as large as other players managed. However, others contend that his impact on the...}  &  game        &  0.000034                   \\\addlinespace[0.5em]\emph{Nearly every game in the main series has either an anime or manga adaptation, or both. The series has had a significant impact on the...}  &  development        &  0.00000092                   \\
\bottomrule[1.5pt]
\end{tabular}
    \caption{Example where the NN model has much higher confidence in the correct target than the LM. Although there are other training set examples with similar local -gram matches, the nearest neighbour search is highly confident of specific and very relevant context. }
    \label{figure:output}
\end{figure}

\paragraph{Simple vs Neural Representation}
We observe that many long-tail phenomena manifest as rare -grams (e.g. names).
Is it therefore possible to interpolate an -gram model with a Transformer LM, as an alternative to our NN approach?
Figure~\ref{fig:ngram} shows little improvement from using -gram LMs -- 0.2 perplexity points (similarly to \citet{bakhtin2018lightweight}).
This result highlights the need to use the learned representation function  to measure similarity between more varied contexts.

\begin{figure*}
	\centering
	\begin{varwidth}[t]{0.49\textwidth}
	    \centering
        \includegraphics[width=\textwidth]{fig/ngram.pdf}
        \caption{Interpolating the Transformer LM with -gram LMs on \textsc{Wikitext-103} (validation set). Using NN-LM gives a much lower perplexity, suggesting that the representations are learning more than just matching local context.}
        \label{fig:ngram}
	\end{varwidth}
	\hfill
	\begin{varwidth}[t]{0.49\textwidth}
		\centering
		\includegraphics[width=\textwidth]{fig/drop_nodrop.pdf}
		\caption{Training curves for the Transformer LM with and without dropout. Turning off dropout allows the training loss to go to 0, indicating that the model has sufficient capacity to memorize the training data.}
		\label{fig:memnewdrop}
	\end{varwidth}
\end{figure*}

\paragraph{Implicit vs Explicit Memory}
If a neural representation function is crucial for NN-LM, could implicitly memorizing the training dataset in the neural network parameters replace the explicit memory in the datastore?
To test this, we train a Transformer LM with no dropout.
Figure~\ref{fig:memnewdrop} shows that this model eventually reaches zero training loss, indicating that it can make perfect predictions for all examples in the training set; the model has memorized the dataset.
Naturally, the memorizing LM overfits, i.e. the training loss drops to 0 while the best validation perplexity is much higher at 28.59.
For comparison, the vanilla Transformer LM (with dropout) has a much higher training loss (shown in Figure~\ref{fig:memnewdrop}), but also generalizes better with a validation perplexity of 17.96. This result shows that the Transformer has sufficient capacity to memorize the training set.

We consider whether the memorizing LM can be an effective substitute for nearest neighbor search. 
Interpolating the memorizing LM with the original LM improves validation perplexity by just 0.1 -- compared to  1.9 from NN-LM. 
This result suggests that although the Transformer is expressive enough to memorize all training examples, learning to do so does not result in context representations that generalize. 
In contrast, NN-LM memorizes training data while improving generalization.

From these experiments, we conjecture that NN-LM improves performance because (1) the Transformer LM is very good at learning a representation function for contexts with an implicit notion of similarity, and (2) while the Transformer has capacity to memorize all training examples, doing so causes its representation to generalize less effectively, but (3) the NN-LM allows the model to memorize the training data while retaining an effective similarity function. 
























































%
 

\section{Related Work}
\label{sec:relwork}

We discuss related uses of caches for language modeling in Section \ref{sec:model}.

Similar NN models to ours have been proposed for computer vision tasks \citep{papernot2018deep,orhan2018simple,zhao2018retrieval}, primarily motivated by improving interpretability and robustness to adversarial attacks. 
We hypothesize that our method may be particularly effective for language modeling, because plentiful unlabeled data allows datastores of billions of tokens, and language modeling often requires world knowledge to be learnt from few examples.

Nearest neighbor models have been applied to a number of NLP problems in the past, such as part of speech tagging \citep{daelemans1996mbt} and morphological analysis \citep{bosch2007efficient}, but the use of learned representations makes the similarity function much more effective in the case of neural models. More recently, \citet{kaiser2017learning} have used a similarly differentiable memory that is learned and updated during training, and is applied to one-shot learning tasks.





Several models have also improved language generation by using training examples directly at test time.
\citet{guu2018generating} propose a model that samples training sentences at random and edits them with a sequence-to-sequence model, but does not use a retrieval mechanism such as NN.
\citet{gu2018search} introduce a translation model that attends over retrieved training set examples.
\citet{weston2018retrieve} improve a dialogue response generation model by refining similar instances from the training set.
NN-LM differs from these approaches by working at the level of individual tokens instead of whole training sentences, as well as not incorporating the retrieval mechanism into the training pipeline.




A general trend in machine learning, and in language modeling in particular, is that adding more data consistently improves performance \citep{devlin2018bert,radford2019language,yang2019xlnet,liu2019roberta,zellers2019defending,shoeybi2019megatron}.
Our work offers an alternative method for scaling language models, in which relatively small models learn context representations, and a nearest neighbour search acts as a highly expressive classifier.
 

\section{Conclusion and Future Work}
We have introduced NN-LMs, which can significantly outperform standard language models by directly querying training examples at test time.
The approach can be applied to any neural language model.
The success of this method suggests that learning similarity functions between contexts may be an easier problem than predicting the next word from some given context.
Future work should explore explicitly training similarity functions, and reducing the size of the datastore. %
 
\subsubsection*{Acknowledgments}
The authors thank the anonymous reviewers as well as Sida Wang, Kartikay Khandelwal, Kevin Clark and members of the FAIR Seattle team for helpful discussions and comments.



\bibliography{iclr2020_conference}
\bibliographystyle{iclr2020_conference}

\appendix
\clearpage
\section{Appendix}
\label{sec:appendix}



This section provides several examples where  places higher probability mass on the true target, compared to .



\begin{table}[h]
\centering
\small
\begin{tabular}{p{9.5cm}>{\centering\arraybackslash}m{1.6cm}>{\centering\arraybackslash}m{1.6cm}}
        \toprule[1.5pt]
\textbf{Test Context} ~~~ (, )         & \textbf{Test Target}        &                     \\ \midrule[0.75pt]
\emph{For Australians and New Zealanders the Gallipoli campaign came to symbolise an important milestone in the emergence of both nations as independent actors on the world stage and the development of a sense of national identity. Today, the date of the initial landings, 25 April, is known as Anzac Day in Australia and New Zealand and every year thousands of people gather at memorials in both nations, as well as Turkey, to...}                    & honour                    \\\addlinespace[0.15em]
                     \midrule[0.75pt]
\textbf{Training Set Context} & \textbf{Training Set Target} & \textbf{Context Probability} \\ 
                     \midrule[0.75pt]
\emph{Despite this, for Australians and New Zealanders the Gallipoli campaign has come to symbolise an important milestone in the emergence of both nations as independent actors on the world stage and the development of a sense of national identity. Today, the date of the initial landings, 25 April, is a public holiday known as Anzac Day in Australia and New Zealand and every year thousands of people gather at memorials in both nations, and indeed in Turkey, to ...}  &  honour        &  0.995                   \\\addlinespace[0.5em]\emph{On the anniversary date of his death, every year since 1997, thousands of people gather at his home in Memphis to...}  &  celebrate        &  0.0086                   \\\addlinespace[0.5em]\emph{Twenty-five years after Marseille's death, fighter pilot veterans of World War II gathered to...}  &  honour        &  0.0000041                   \\\addlinespace[0.5em]\bottomrule[1.5pt]
\end{tabular}
    \caption{Another example where the NN model places much higher probability mass on the correct target, compared to the LM. The nearest neighbors search has retrieved a training set context that is extremely similar to the test context, while very rare and in the long-tail of patterns.}
    \label{table:app_output}
\end{table}

\begin{table}[h]
\centering
\small
\begin{tabular}{p{9.5cm}>{\centering\arraybackslash}m{1.6cm}>{\centering\arraybackslash}m{1.6cm}}
        \toprule[1.5pt]
\textbf{Test Context} ~~~ (, )         & \textbf{Test Target}        &                     \\ \midrule[0.75pt]
\emph{U2 do what they're best at, slipping into epic rock mode, playing music made for the arena". In two other local newspaper reviews, critics praised the song's inclusion in a sequence of greatest hits. For the PopMart Tour of 1997--...}                    & 1998                    \\\addlinespace[0.15em]
                     \midrule[0.75pt]
\textbf{Training Set Context} & \textbf{Training Set Target} & \textbf{Context Probability} \\ 
                     \midrule[0.75pt]
\emph{Following their original intent, "Sunday Bloody Sunday" was not played during any of the forty-seven shows on the Lovetown Tour in 1989. The song reappeared for a brief period during the Zoo TV Tour, and late during the second half of PopMart Tour (1997--...}  &  1998        &  0.936                   \\\addlinespace[0.5em]\emph{They are 6 times Champions and they won the Challenge Cup in 1938, and have experienced two previous stretches in the Super League, 1997--...}  &  2002        &  0.0071                   \\\addlinespace[0.5em]\emph{About \61.4 million in 2018 dollars) was spent on the property acquisition. After weather-related construction delays due to the El Nino season of the winter of 1997--...}  &  1998        &  0.0015                   \\\addlinespace[0.5em]\emph{This made it the highest-rated season of The X-Files to air as well as the highest rated Fox program for the 1997--...}  &  98        &  0.00000048                   \\
\bottomrule[1.5pt]
\end{tabular}
    \caption{In this example, the desired date pattern appears in many examples. Yet, the nearest neighbors search is able to identify the only training set context which is relevant to the test context and assigns it the highest probability mass.}
    \label{table:app_output}
\end{table}


\begin{table}[h]
\centering
\small
\begin{tabular}{p{9.5cm}>{\centering\arraybackslash}m{1.6cm}>{\centering\arraybackslash}m{1.6cm}}
        \toprule[1.5pt]
\textbf{Test Context} ~~~ (, )         & \textbf{Test Target}        &                     \\ \midrule[0.75pt]
\emph{Lord Strathcona awarded Gauthier a scholarship in 1906 that allowed her to return to Europe and continue her vocal studies. She returned there and continued both to study and give performances. Her first operatic performance came in 1909 in Pavia, Italy as Micaela in Bizet's...}                    & Carmen                    \\\addlinespace[0.15em]
                     \midrule[0.75pt]
\textbf{Training Set Context} & \textbf{Training Set Target} & \textbf{Context Probability} \\ 
                     \midrule[0.75pt]
\emph{Despite poor relations with the orchestra, Mahler brought five new operas to the theatre, including Bizet's...}  &  Carmen        &  0.356                   \\\addlinespace[0.5em]\emph{The fourth movement of An die Jugend (1909), for instance, uses two of Niccolo Paganini's Caprices for solo violin (numbers 11 and 15), while the 1920 piece Piano Sonatina No. 6 (Fantasia da camera super Carmen) is based on themes from Georges Bizet's...}  &  opera        &  0.0937                   \\\addlinespace[0.5em]\emph{It also hosted the Ballet of her Majesty's Theatre in the mid-19th century, before returning to hosting the London premieres of such operas as Bizet's...}  &  Carmen        &  0.0686                   \\\addlinespace[0.5em]\bottomrule[1.5pt]
\end{tabular}
    \caption{In this case, the model is able to memorize the fact that \emph{Georges Bizet} wrote \emph{Carmen}.}
    \label{table:app_output}
\end{table}



\begin{table}[t]
\centering
\small
\begin{tabular}{p{9.5cm}>{\centering\arraybackslash}m{1.6cm}>{\centering\arraybackslash}m{1.6cm}}
        \toprule[1.5pt]
\textbf{Test Context} ~~~ (, )         & \textbf{Test Target}        &                     \\ \midrule[0.75pt]
\emph{Mycena maculata bears some resemblance to M. unk, but is only associated with decaying hardwood logs and stumps, and is found in eastern North America, and sometimes on oak on the West Coast. In age, it...}                    & develops                    \\\addlinespace[0.15em]
                     \midrule[0.75pt]
\textbf{Training Set Context} & \textbf{Training Set Target} & \textbf{Context Probability} \\ 
                     \midrule[0.75pt]
\emph{Morchella tridentina (=Morchella frustrata) is also rufescent and very similar to M. rufobrunnea. It is found in mountainous forests and maquis and forms a marked sinus at the attachment of the cap with the stem, which is pure white. At maturity, it...}  &  develops        &  0.031                   \\\addlinespace[0.5em]\emph{The winter bonnet (M. tintinnabulum) is a northern European species that is much smaller (cap diameter up to 2.6 cm (1.0 in) across) and has a brown cap, and has ragged hairs at the base. It...}  &  generally        &  0.029                   \\\addlinespace[0.5em]\emph{The "bleeding" will distinguish Mycena atkinsoniana from most other Mycena species commonly encountered. The common and widely distributed M. sanguinolenta is another "bleeder", but it is smaller than M. atkinsonia, with a cap diameter ranging from 3 to 15 mm (0.1 to 0.6 in). Additionally, it...}  &  has        &  0.028                   \\\addlinespace[0.5em]\emph{Mycena flavoalba bears resemblance to some members of the genus Hemimycena, such as H. lactea and H. unk. It...}  &  can        &  0.018                  \\
\bottomrule[1.5pt]
\end{tabular}
    \caption{This is an example where the  distribution is relatively flat, as several words are plausible continuations. However, the nearest neighbors search assigns the highest probability to the correct target and a corresponding context that is particularly relevant. In contrast, the LM probability on the correct target is lower.}
    \label{table:app_output}
\end{table}

%
 
\end{document}
