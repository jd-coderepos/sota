

\documentclass[letter]{ieice}
\usepackage[dvips]{graphicx}
\setcounter{page}{1}



\field{}
\title{ Bounded-Choice Statements for  User Interaction  in
 Imperative  Programming}
\authorlist{\authorentry{Keehang KWON}{m}{labelA}
\authorentry{Jeongyoon SEO}{n}{labelA}
\authorentry{Daeseong Kang}{n}{labelB}
}
\affiliate[labelA]{The authors are with Computer Eng., DongA University. email:khkwon@dau.ac.kr}
\affiliate[labelB]{The author is with Electronics Eng., DongA University.}
\received{2003}{1}{1}
\revised{2003}{1}{1}
\finalreceived{2003}{1}{1}

\makeatletter
\long\def\@makemyfntext#1{ #1}

\long\def\@myfootnotetext#1{\insert\footins{\footnotesize
    \interlinepenalty\interfootnotelinepenalty 
    \splittopskip\footnotesep
    \splitmaxdepth \dp\strutbox \floatingpenalty \@MM
    \hsize\columnwidth \@parboxrestore
   \edef\@currentlabel{\csname p@footnote\endcsname\@thefnmark}\@makemyfntext
    {\rule{\z@}{\footnotesep}\ignorespaces
      #1\strut}}}

\def\myfootnotetext{\@ifnextchar
     [{\@xfootnotenext}{\xdef\@thefnmark{\thempfn}\@myfootnotetext}}
\makeatother



\newenvironment{describe}{\begin{list}{}{\setlength\leftmargin{80pt}}\setlength\labelsep{10pt}\setlength\labelwidth{70pt}}{\end{list}}

\newenvironment{flag}{\begin{list}{\makebox[20pt]{\hss\enspace}}
                                  {\labelwidth 20pt}}{\end{list}}





\newenvironment{numberedlist}
{\begin{list}{\makebox[20pt]{\hss(\arabic{itemno})\enspace}}
             {\usecounter{itemno}\labelwidth 20pt}}{\end{list}}

\newenvironment{alphabetlist}
{\begin{list}{\makebox[20pt]{\hss(\alph{itemno1})\enspace}}
             {\usecounter{itemno1}\labelwidth 20pt}}{\end{list}}

\newenvironment{romanlist}
{\begin{list}{\makebox[20pt]{\hss(\roman{itemno2})\enspace}}
             {\usecounter{itemno2}\labelwidth 20pt}}{\end{list}}

\newcounter{itemno}

\newcounter{itemno1}

\newcounter{itemno2}
\newcounter{lemma}
\newcounter{exno}

\newcounter{defno}













\newenvironment{defn}{\refstepcounter{defno}\medskip \noindent {\bf
Definition \thedefno.\ }}{\medskip}

\newenvironment{ex}{\refstepcounter{exno}\medskip \noindent {\bf
Example \theexno.\ }}{\medskip} 













\newenvironment{millerexample}{
 \begingroup \begin{tabbing} \hspace{2em}\= \hspace{5em}\= \hspace{5em}\=
\hspace{5em}\= \kill}{
 \end{tabbing}\endgroup}

\newenvironment{wideexample}{
 \begingroup \begin{tabbing} \hspace{2em}\= \hspace{10em}\= \hspace{10em}\=
\hspace{10em}\= \kill}{
 \end{tabbing}\endgroup}

\newcommand{\sep}{\;\vert\;}

\newcommand{\ra}{\rightarrow}
\newcommand{\app}{\ }
\newcommand{\appt}{\ }
\newcommand{\tup}[1]{\langle\nobreak#1\nobreak\rangle}

\newcommand{\hu}{{\cal H}^+}
\newcommand{\Free}{{\cal F}}
\newcommand{\oprove}{\vdash\kern-.6em\lower.7ex\hbox{}\,}
\newcommand{\true}{\top}

\newcommand{\Dscr}{{\cal D}}
\newcommand{\Pscr}{{\cal P}}
\newcommand{\Gscr}{{\cal G}}
\newcommand{\Fscr}{{\cal F}}
\newcommand{\Vscr}{{\cal V}}
\newcommand{\Uscr}{{\cal U}}
\newcommand{\pderivation}{{\cal P}\kern -.1em\hbox{\rm -derivation}}
\newcommand{\pderivationl}{{\cal P}\kern -.1em\hbox{\em -derivation}}
\newcommand{\pderivable}{{\cal P}\kern -.1em\hbox{\rm -derivable}}
\newcommand{\pderivablel}{{\cal P}\kern -.1em\hbox{\em -derivable}}
\newcommand{\pderivations}{{\cal P}\kern -.1em\hbox{\rm -derivations}}
\newcommand{\pderivability}{{\cal P}\kern -.1em\hbox{\rm -derivability}}
\newcommand{\eqm}[1]{=_{\scriptscriptstyle #1}}
\newcommand\subsl{\preceq}
\newcommand{\fnrestr}{\uparrow}

\newcommand{\match}{{\rm MATCH}}
\newcommand{\triv}{{\rm TRIV}}
\newcommand{\imit}{{\rm IMIT}}
\newcommand{\proj}{{\rm PROJ}}
\newcommand{\simpl}{{\rm SIMPL}}
\newcommand{\failed}{{\bf F}}

\newcommand{\Dsiginst}[1]{{[#1]_\Sigma}}
\newcommand{\Psiginst}[1]{{[#1]_\Sigma}}
\newcommand{\lnorm}{{\lambda}norm}
\newcommand{\seq}[2]{#1 \supset #2}
\newcommand{\dseq}[2]{#1_1,\ldots,#1_{#2}}

\newcommand{\all}{\forall}
\newcommand{\some}{\exists}
\newcommand{\lambdax}[1]{\lambda #1\,}
\newcommand{\somex}[1]{\some#1\,}
\newcommand\allx[1]{\all#1\,}

\newcommand{\subs}[3]{[#1/#2]#3}
\newcommand{\rep}[3]{S^{#2}_{#1}{#3}}
\newcommand{\ie}{{\em i.e.}}
\newcommand{\eg}{{\em e.g.}}

\newcommand{\lbotr}{-R}
\newcommand{\ldbotr}{\bot\mbox{\rm -R}}
\newcommand{\landl}{-L}
\newcommand{\ldandl}{\land\mbox{\rm -L}}
\newcommand{\landr}{-R}
\newcommand{\ldandr}{\land\mbox{\rm -R}}
\newcommand{\lorl}{-L}
\newcommand{\ldorl}{\lor\mbox{\rm -L}}
\newcommand{\lorr}{-R}
\newcommand{\ldorr}{\lor\mbox{\rm -R}}
\newcommand{\limpl}{-L}
\newcommand{\ldimpl}{\supset\mbox{\rm -L}}
\newcommand{\limpr}{-R}
\newcommand{\ldimpr}{\supset\mbox{\rm -R}}
\newcommand{\lnegl}{-L}
\newcommand{\ldnegl}{\neg\mbox{\rm -L}}
\newcommand{\ldnegr}{\neg\mbox{\rm -R}}
\newcommand{\lalll}{-L}
\newcommand{\ldalll}{\forall\mbox{\rm -L}}
\newcommand{\lallr}{-R}
\newcommand{\ldallr}{\forall\mbox{\rm -R}}
\newcommand{\lsomel}{-L}
\newcommand{\ldsomel}{\exists\mbox{\rm -L}}
\newcommand{\lsomer}{-R}
\newcommand{\ldsomer}{\exists\mbox{\rm -R}}
\newcommand{\ldlamlr}{\lambda}
\newcommand{\sequent}[2]{\hbox{{}}}
\newcommand{\prog}[2]{\hbox{{}}}
\newcommand{\run}{\Gamma}


\newcommand{\Ibf}{{\bf I}}
\newcommand{\Cbf}{{\bf C}} 
\newcommand{\Cbfpr}{{\bf C'}}

\newcommand{\cprove}{\vdash_C}
\newcommand{\iprove}{\vdash_I}

\newsavebox{\lpartfig}
\newsavebox{\rpartfig}




\newenvironment{exmple}{
 \begingroup \begin{tabbing} \hspace{2em}\= \hspace{3em}\= \hspace{3em}\=
\hspace{3em}\= \hspace{3em}\= \hspace{3em}\= \kill}{
 \end{tabbing}\endgroup}
\newenvironment{example2}{
 \begingroup \begin{tabbing} \hspace{8em}\= \hspace{2em}\= \hspace{2em}\=
\hspace{10em}\= \hspace{2em}\= \hspace{2em}\= \hspace{2em}\= \kill}{
 \end{tabbing}\endgroup}

\newenvironment{example}{
\begingroup  \begin{tabbing} \hspace{2em}\= \hspace{3em}\= \hspace{3em}\=
\hspace{3em}\= \hspace{3em}\= \hspace{3em}\= \hspace{3em}\= \hspace{3em}\= 
\hspace{3em}\= \hspace{3em}\= \hspace{3em}\= \hspace{3em}\= \kill}{
 \end{tabbing} \endgroup }


\newcommand{\sand}{sand} \newcommand{\pand}{pand} \newcommand{\cor}{cor} 

\newcommand{\lb}{\langle}
\newcommand{\rb}{\rangle}
\newcommand{\pr}{prov}
\newcommand{\prG}{intp}
\newcommand{\prSG}{intp_E}
\newcommand{\intp}{intp_o}
\newcommand{\prove}{exec} \newcommand{\np}{invalid} \newcommand{\Ra}{\supset}  
\newcommand{\add}{\oplus} \newcommand{\adc}{\sqcap} \newcommand{\Cscr}{{\cal C}}
\newcommand{\seqweb}{SProlog}
\newcommand{\sprog}{{SProlog}}

\newtheorem{theorem}[lemma]{Theorem}

\newtheorem{proposition}[lemma]{Proposition}

\newtheorem{corollary}[lemma]{Corollary}
\newenvironment{proof}
     {\begin{trivlist}\item[]{\it Proof. }}{\\* \hspace*{\fill} \end{trivlist}}

\newcommand{\seqand}{\prec}
\newcommand{\seqor}{\cup}
\newcommand{\seqandq}[2]{\prec_{#1}^{#2}}
\newcommand{\parandq}[2]{\land_{#1}^{#2}}
\newcommand{\exq}[2]{\exists_{#1}^{#2}}
\newcommand{\ext}{intp_G} 
\newcommand{\muprolog}{{C}}
\newcommand{\uch}{kchoose}
\newcommand{\kch}{kchoose}
\renewcommand{\pr}{ex}
\renewcommand{\prove}{ex} 



\begin{document}
\maketitle
\begin{summary}
Adding versatile interactions to imperative  programming -- C, Java and
Android -- is an essential
task. 
Unfortunately, existing  languages provide only limited constructs for user interaction.
These constructs are usually in the form of  quantification. For example,
  existing  languages can take the keyboard input from the user only
via the   statement. Note that the value of   is  unbounded
in the sense that  can have any value. This statement is thus not useful for 
applications with bounded
inputs.
  To support bounded choices, we propose new bounded-choice statements for user interation.
Each input device (keyboard,  mouse, touchpad, ) 
naturally requires a new  bounded-choice statement.
To make things simple, however, we focus on a  bounded-choice statement  for keyboard --  --
 to allow for more controlled and more 
guided participation from the user. We illustrate our idea
via \muprolog, an extension of the core C  with a new 
bounded-choice statement for the keyboard.
\end{summary}
\begin{keywords}
interactions,  bounded choices, read.
\end{keywords}








\section{Introduction}\label{sec:intro}

 Adding versatile interactions to imperative  programming -- C, Java,
Android, etc. -- has become an essential
task. 
Unfortunately, existing  languages provide only limited constructs for user interaction.
These constructs are usually in the form of  quantification. For instance, 
the keyboard input statement  that has been used
in Java-like languages  is restricted to the  statement. 
The  statement is  of the form , where  is a statement and 
 can have any value. Hence, it is a form of an  quantified 
statement.  However, in many situations,
the system requires a  form of  
{\it bounded-choice} interactions; the user is expected to choose  one among many alternatives.  Examples include most interactive systems such as airline ticketing systems.


The use of bounded-choice interactions is thus essential  in 
representing most interactive
systems. For this purpose, this paper proposes  a bounded-choice approach to user 
 interaction. Each input device naturally requires a new
bounded-choice statement.   To make things simple,  however, 
we focus only on the keyboard device. It is straightforward
to adjust our idea to other input devices such as  mouse and  touchpad.

Toward this end, we propose a new bounded keyboard input statement 
, 
where each   is a statement. This has the following execution semantics:


 

\noindent , where  is  chosen (\ie, a keyboard input) by the user and  is a 
set of procedure definitions.  The notation  denotes the reverse implication, \ie, 
.
In the above definition, the system  requests the user to choose  via the keyboard 
and then proceeds
with executing .  If  is not among , then we assume that the system does 
nothing.
It can be easily seen that our new statement has many applications
 in representing most interactive systems.

The following C-like code example reads a variable named  from the keyboard,
 whose value represents an employee's name. 

\begin{exmple}
        read(emp); \\
        switch (emp) \{ \\
 \>           case tom:  age = 31;   break; \\
  \>          case kim: age = 40;   break;\\
 \>           case sue: age = 22;    break;\\
 \>           default: age = 0;          \\
        \}\\
\end{exmple}

\noindent 
In the above, the system 
 requests the user to type in a particular employee. 
 Note that the above code is based on unbounded quantification
 and is thus very awkward. It is also  error-prone 
 because the user may type in  an invalid value.

The above application obviously
 requires a bounded-choice interaction rather than  one based on
unbounded quantification.
Our  statement provides such a  bounded-choice interaction for  keyboard   
 and is useful to avoid this kind of human error.
Hence, instead of the above code, consider the statement 


\begin{exmple}
print(``Enter 1 for tom, 2 for kim and 3 for sue:''); \\
        \kch( \\
 \>           emp = tom;  age = 31, \\
  \>          emp = kim; age = 40, \\
 \>           emp = sue; age = 22 );
\end{exmple}

\noindent This program expresses the task of the user choosing one among
three employees.
 Note that this program is much easier and safer to use.
 The system now requests the user to select one (by typing 1,2,3)  
among three
employees. After it is selected, 
the system sets his age as well.

Generally speaking, the  statement is designed to directly encode most interactive objects
which require  the user to choose one among several possible tasks.
Hence, there is a rich realm of applications for this statement.
For example, as we will see later in Section 3, the ATM machine requires the user
to select one among 1) balance checking, 2) cash withdrawal, and 3) cash deposit.
Hence, it can be directly encoded via the  statement.


 It is easy to observe that   statement  can be built from the
 - combination. For example, the above example can be rewritten in the following way.

\begin{exmple}
print(``Enter 1 for tom, 2 for kim and 3 for sue:''); \\
        read(n); \\
        switch (n) \{ \\
 \>           case 1:  emp = tom; age = 31;   break; \\
  \>          case 2:  emp = kim; age = 40;   break;\\
 \>           case 3:  emp = sue; age = 22;    break;\\
 \>           default:           \\
        \}\\
\end{exmple}



   

 It is then tempting to conclude that the  construct is not needed because it can be built from the
 -
combination. However, this view is quite misleading. Without it, the resulting codes would be 
low-level for the following reasons: 

\begin{itemize}

\item The programmer must manually allocate a variable for the
 construct.

\item The programmer must specify the numbering sequence in the  statement.

\item The programmer must specify the default part.

\end{itemize}
\noindent
As a consequence, these codes are cumbersome, error-prone, difficult to read,  and reason about.


 The   construct should rather be seen as a well-designed, 
high-level abstraction for bounded-choice interaction and the  
- combination should  be seen as  its low-level implementation. 
 The advantage of the use of this construct becomes evident when an application has a long
sequence of  interactions with the user. Therefore, the need for this construct is clear.
 To our knowledge, this kind of construct  has never been proposed before in imperative languages.
This is quite surprising, given the ubiquity of
  bounded-choice interaction in interactive applications.

The   construct can be implemented in many ways. One way to implement the   construct is via preprocessing, \ie, via transformation to plain C-like code.
That is,   is transformed to the following: 

\begin{exmple}
         int k; \\
        read(k); \\
        switch (k) \{ \\
 \>           case 1:  ;   break; \\
  \>          case 2:  ;   break;\\
\> \vdots \\
 \>           case n:  ;    break;\\
 \>           default:           \\
        \}\\
\end{exmple}
\noindent Here, k is a new, local storage, and  are obtained from
  via the same transformation.

This paper focuses on the minimum 
core of C. This is to present the idea as concisely as possible.
The remainder of this paper is structured as follows. We describe 
 \muprolog, an extension of  core C  with a new 
bounded-choice statement for the keyboard
 in Section 2. In Section \ref{sec:modules}, we
present an example of  \muprolog.
Section~\ref{sec:conc} concludes the paper.

\section{The Language}\label{sec:logic}

The language is   core C 
 with  procedure definitions. It is described
by - and -formulas given by the syntax rules below:
\begin{exmple}
\> \>    \\  
\>\>   \\
\> \>  \\
\end{exmple}
\noindent
 In the above, 
 in  represents a head of an atomic procedure definition of the form  
where  are parameters.  in  represents a procedure call
 of the form  
where  are actual arguments.
A -formula  is called a  procedure definition.
In the transition system to be considered, -formulas will function as the
main  statement, and a set of -formulas  enhanced with the
machine state (a set of variable-value bindings) will constitute  a program.
Thus, a program is a union of two disjoint sets, \ie, 
where each  is a -formula and  represents the machine state.
Note that  is initially set to an empty set and will be updated dynamically during execution
via the assignment statements. 

 We will  present an interpreter via a proof theory \cite{Khan87,MNPS91,HM94,MN12}.
Note that this interpreter  alternates between 
 the execution phase 
and the backchaining phase.  
In  the execution phase (denoted by ) it tries to execute a main statement  with respect to
a program  and
produce a new program 
by reducing  
to simpler forms until  becomes an assignment statement or a procedure call. The rules
 (6), (7),(8) and (9) deal with this phase.
If  becomes a procedure call, the interpreter switches to the backchaining mode. This is encoded in the rule (3). 
In the backchaining mode (denoted by ), the interpreter tries 
to solve a procedure call   and produce a new  program 
by first reducing a procedure definition  in a program  to  its instance
 (via rule (2)) and then backchaining on the resulting 
definition (via rule (1)).
 To be specific, the rule (2) basically deals with argument passing: it eliminates the universal quantifier  in 
by picking a value  for
 so that the resulting instantiation, written as , matches the procedure call .
The notation \ seqand\  denotes the  sequential execution of two tasks. To be precise, it denotes
the following: execute  and execute
 sequentially. It is considered a success if both executions succeed.
Similarly, the notation \ parand\  denotes the  parallel execution of two tasks. To be precise, it denotes
the following: execute  and execute
  in any order.  Thus, the execution order is not important here. 
It is considered a success if both executions succeed.
 The notation \ choose\  denotes the  selection between two tasks. To be precise, it denotes
the following: the machine selects and executes  one between   and\ .
 It is considered a success if the selected one succeeds.


As mentioned in Section 1, the notation  denotes  reverse implication, \ie, .

\begin{defn}\label{def:semantics}
Let  be a main statement and let  be a program.
Then the notion of   executing  successfully and producing a new
program --  --
 is defined as follows:
\begin{numberedlist}




\item     
 . \% A matching procedure for  is found.

\item        . \% argument passing



\item         parand . \% a procedure call

\item  . \% True is always a success.

\item    .
\% the assignment statement. Here, 
 denotes a set union but  in  will be replaced by .



\item       seqand 
  . \% sequential composition



\item    
  .   where
 is the keyboard input and  
 denotes a set union but  in  will be replaced by .




\item    ((read the keyboard input i)  seqand \\
  seqand  choose
 seqand 

\end{numberedlist}
\end{defn}

\noindent
If  has no derivation, then the machine returns  the failure.

 The rule (8) deals with bounded-choice interaction.    To execute  successfully, 
the machine does the following:

\begin{numberedlist}

\item It reads and saves the keyboard input value  in some
temporary storage.

\item Then it tries the first branch  of the form  seqand .
 That is, it first
checks whether  is legal, \ie, among .  
   The machine then executes .

\item If the first branch fails, the machine tries the second branch of the form
 seqand .
That is, it first checks whether  is illegal, \ie, not among . 
If it is illegal,  then it means that it is the user, not the machine, who
 failed to do his job. Therefore, the machine sets  to  and returns the success.

\end{numberedlist}
\noindent  As an example of our language, the following -formula 

\begin{exmple}
\kch( \\
 \>           emp = tom;  age = 31, \\
  \>          emp = kim; age = 40, \\
 \>           emp = sue; age = 22 );
\end{exmple}
\noindent expresses the task of the user choosing one among
three employees. More examples are shown in Section 3.



As mentioned earlier, the   construct is a well-designed, 
high-level abstraction for bounded-choice interaction which is quite common to
user interaction. As for its implementation,
it can be bolted into the language as a basic statement or it can be supported via preprocessing.
C macro code for some initial implementation of   is available under \\
{\tt http://www.researchgate.net/publication/} \\ 
{\tt 282331184}\footnote{
Unfortunately, C has little support for variadic macros such as . 
For this reason, the current implementation supports only a limited number of arguments (up to 5, to be precise).
 We plan to improve this implementaton in the future.
}.

\section{Examples }\label{sec:modules}



As an  example, consider the following
statement that performs ATM transaction. The types of ATM transaction are
1) balance checking, 2) cash withdrawal, and 3) cash deposition.
An example of this class is provided by the
following code where the program  is of the form:

\begin{exmple}
deposit() =  \\
 print(``type 1 for \5:''); \\
\kch(amount = \5);   \\

withdraw() = \\
 print(``type 1 for \5:''); \\
 \kch(amount = \5);  \\

balance() =    \\
\end{exmple}

\noindent and the goal  is of the form:

\begin{exmple}
 print(``type 1 for balance,2 for withdraw,3 for deposit'');\\
\kch(balance(),    withdraw(), deposit());
\end{exmple}
\noindent In the above, the execution
 basically proceeds as follows: the machine asks the user to choose one among three procedures.
If the user choose the withdrawal  by typing 2, then  the machine will ask the user
again to choose the amount of the withdrawal. Then the execution will go on.
Note that our code is very concise compared to the traditional one.


As a second example, our language  makes it possible to customize the amount for tuition via
interaction with the user.

The following C-like code displays the amount of the tuition, based on the user's
field of study.

\begin{exmple}
        read(major); \\
        switch (major) \{ \\
 \>           case english:  tuition = \4,000;   break;\\
 \>           case liberal:  tuition = \2,000, \\
  \>           major= medical;    tuition = \2,200);\\
print(tuition); \\
\end{exmple}

\noindent This program expresses the task of the user choosing one among
three majors.
 Note that this program is definitely better than the above: it is concise, much easier to read/write/use,
 and less error-prone.
 The system now requests the user to select one (by typing 1,2 or 3)
among three majors. After it is selected, 
the system displays the amount of the tuition.



\section{Empirical Study}

This section provides some empirical study 
 comparing two languages, namely C and \muprolog. 

 It has    
the following features:   

\begin{itemize}
                                  
\item The same program  is considered for each language.   
 A typical ATM machine in Korea 
   has  a sequence of 3 interactions  for
cash deposit, 4 for cash withdrawal, and 2 for checking balance.
The program we require is an implementation of this ATM machine using seven
major procedures (deposit, withdrawal, balance, password processing, etc).
Overall, there are five occurrences of bounded-choice interactions in the program.


 \item
 For each language, we analyze five best implementations  of the 
program by 
Computer Science undergraduate students
in our Software Engineering classes.
                                                            

\item Two different aspects are investigated, namely program length and programming effort.

\end{itemize}


{\bf Program length} \\

The following table  shows the numbers of lines of five programs containing 
 a statement, a declaration, or  a delimiter such as a closing brace.

\begin{exmple}
 \>\>          program lines   \>\>\>\>  average line   \\ \\
C   \>\>        (127,130,135,142,154)    \>\>\>\>     137.6 \\
\muprolog   \>\>        (113,115,123,129,132)    \>\>\>\>     122.4 \\
\end{exmple}

    We see that C codes are typically 10\% longer   
than  \muprolog. \\


{\bf Work time and productivity} \\

                                                                       
The following table shows the total work time  for designing, writing, 
and testing the program as  measured by us in the classes.

\begin{exmple}
 \>\>          programming hours  \>\>\>\>  average hour   \\ \\
C   \>\>        (1.6,1.8,2.4,2.5,2.8)    \>\>\>\>     2.2 \\
\muprolog   \>\>        (1.2,1.4,1.5,1.6,2.1)    \>\>\>\>     1.5 \\
\end{exmple}

As we see, \muprolog  
takes less than 70\% as long as C.


\section{Conclusion}\label{sec:conc}

In this paper, we have  extended  core C  by adding a bounded-choice statement.
 This extension allows   ,  where each  is a statement.
This statement makes it possible for the core C
to model decision steps from the user. 

 The  construct allows only a simple form of user input, \ie,   natural numbers.
A more flexible form of user input can be obtained using a parameterized  statement
of the form , where  are (pairwise disjoint) strings.
The semantics is that if some string  is typed, then  will be executed.
Thus, the latter allows   the user to type  more symbolic names rather than  just  numbers.
We plan to investigate this possibility in the future.

Although we focused on the keyboard input, it is straightforward to extend our idea
to the mouse input, which plays a central role in smartphone applications.
For example, the statement  where
each button is a graphic component located at some area can be adopted. The idea is that if  is clicked,
then  will be executed. It can be easily seen 
 that this statement will greatly
 simplify  smartphone
programming.





We plan to compare our construct to another popular approach: the monad construct 
in functional languages. We also plan to
connect our execution model to Japaridze's elegant 
Computability Logic \cite{Jap03,Jap08},
which has many interesting applications (for example, see \cite{KHP13})
 in information technology. 

\section{Acknowledgements}

We thank the anonymous reviewer for several helpful comments including the parameterized  statement.
This work  was supported by Dong-A University Research Fund.

\bibliographystyle{ieicetr}
\begin{thebibliography}{1}

\bibitem{Khan87}
G.~Kahn,  ``Natural Semantics'', In the 4th Annual Symposium on Theoretical Aspects of Computer Science, 
LNCS vol. 247,  1987.



\bibitem{Jap03}
G.~Japaridze, ``Introduction to computability logic'', Annals  of Pure and
 Applied  Logic, vol.123, pp.1--99, 2003.

\bibitem{Jap08}
G.~Japaridze,   ``Sequential operators in computability logic'',
 Information and Computation, vol.206, No.12, pp.1443-1475, 2008.  

\bibitem{KHP13}
K.~Kwon, S.~Hur and M.~Park,  ``Improving Robustness via Disjunctive Statements in Imperative  Programming'', IEICE Transations on Information and Systems, vol.E96-D,No.9, pp.2036-2038, September, 2013.  

\bibitem{HM94}
J.~Hodas and D.~Miller,   ``Logic Programming in a Fragment of Intuitionistic Linear Logic'', 
 Information and Computation, vol.110, No.2, pp.327-365, 1994. 



\bibitem{MNPS91}
D.~Miller, G.~Nadathur, F.~Pfenning, and A.~Scedrov, ``Uniform proofs as a
  foundation for logic programming'', Annals of Pure and Applied Logic, vol.51,
  pp.125--157, 1991.

\bibitem{MN12}
D.~Miller, G.~Nadathur, Programming with higher-order logic, Cambridge University Press,   2012.
\end{thebibliography}

 






\end{document}
