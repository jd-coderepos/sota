\documentclass{article} \usepackage{nips14submit_e,times}
\usepackage{hyperref}
\usepackage{url}


\usepackage{algorithm,algorithmic,color}
\usepackage{float}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{subfig}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{color}
\usepackage{stmaryrd}
\usepackage{wrapfig}


\definecolor{darkblue}{rgb}{0,0.05,0.35}
\definecolor{darkgreen}{rgb}{0,0.6,0}
\newcommand{\rcom}[1]{\textcolor{red}{[#1]}}
\newcommand{\gcom}[1]{\textcolor{darkgreen}{[#1]}}
\newcommand{\bcom}[1]{\textcolor{blue}{[#1]}}
\newcommand{\eqn}[1]{Eqn.~\ref{eqn:#1}}
\newcommand{\fig}[1]{Fig.~\ref{fig:#1}}
\newcommand{\tab}[1]{Table~\ref{tab:#1}}
\newcommand{\secc}[1]{Section~\ref{sec:#1}}
\newcommand{\cha}[1]{Chapter~\ref{cha:#1}}
\usepackage{bm,array}

\newlength{\cifarwidth}
\setlength{\cifarwidth}{.1\textwidth}

\usepackage[compact]{titlesec}
\titlespacing{\section}{0pt}{2ex}{1ex}
\titlespacing{\subsection}{0pt}{1ex}{0ex}
\titlespacing{\subsubsection}{0pt}{0.5ex}{0ex}


\newcolumntype{C}{>{\centering\arraybackslash}p{6em}}


\newcommand{\rev}[1]{\overset{{}_{\shortleftarrow}}{#1}}

\newtheorem*{mydef}{Definition}

\usepackage{bm}
\newif\ifMIT
\MITfalse
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}




\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}
\ifMIT
\def\vlambda{{\boldmath{\lambda}}}
\def\vmu{{\boldmath{\mu}}}
\def\valpha{{\boldmath{\alpha}}}
\def\vbeta{{\boldmath{\beta}}}
\def\gamma{{\boldmath{\vgamma}}}
\def\vtheta{{\boldmath{\theta}}}
\def\vepsilon{{\boldmath{\epsilon}}}
\def\vomega{{\boldmath{\omega}}}
\def\vpsi{{\boldmath{\psi}}}
\def\vsigma{{\boldmath{\sigma}}}
\def\vSigma{{\boldmath{\Sigma}}}
\def\veta{{\boldmath{\eta}}}
\def\vrho{{\boldmath{\rho}}}
\def\vRho{{\boldmath{\Rho}}}
\def\vphi{{\boldmath{\phi}}}
\def\vPhi{{\boldmath{\Phi}}}
\def\vDelta{{\boldmath{\Delta}}}
\def\vdelta{{\boldmath{\delta}}}
\else
\def\vlambda{{\bm{\lambda}}}
\def\vmu{{\bm{\mu}}}
\def\valpha{{\bm{\alpha}}}
\def\vbeta{{\bm{\beta}}}
\def\vgamma{{\bm{\gamma}}}
\def\vtheta{{\bm{\theta}}}
\def\vepsilon{{\bm{\epsilon}}}
\def\vomega{{\bm{\omega}}}
\def\vpsi{{\bm{\psi}}}
\def\vphi{{\bm{\phi}}}
\def\vsigma{{\bm{\sigma}}}
\def\vSigma{{\bm{\Sigma}}}
\def\veta{{\bm{\eta}}}
\def\vrho{{\bm{\rho}}}
\def\vRho{{\bm{\Rho}}}
\def\vphi{{\bm{\phi}}}
\def\vPhi{{\bm{\Phi}}}
\def\vDelta{{\bm{\Delta}}}
\def\vdelta{{\bm{\delta}}}
\fi

\def\KeyIdea{}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\ifMIT
\def\mLambda{{\boldmath{\Lambda}}}
\def\mBeta{{\boldmath{\beta}}}
\def\mPhi{{\boldmath{\Phi}}}
\def\mSigma{{\boldmath{\Sigma}}}
\else
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}
\fi

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\def\empirical{\ptrain} \newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma} \newcommand{\sigm}{\sigmoid} \newcommand{\softplus}{\zeta} \newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\ifMIT
\else
\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\fi
\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\title{Improved Techniques for Training GANs}

\author{Tim Salimans \\
\texttt{tim@openai.com} \\
\And
Ian Goodfellow\\
\texttt{ian@openai.com} \\
\And
Wojciech Zaremba\\
\texttt{woj@openai.com} \\
\And
Vicki  Cheung\\
\texttt{vicki@openai.com}
\And
Alec  Radford\\
\texttt{alec.radford@gmail.com}
\And
Xi Chen\\
\texttt{peter@openai.com}
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}


\newcommand{\qT}{q_{\theta}}
\newcommand{\rT}{r_{\theta}}

\newcommand{\bx}{\mathbf{x}}
\newcommand{\bz}{\mathbf{z}}
\newcommand{\f}{\mathbf{f}}
\newcommand{\F}{\mathbf{F}}
\newcommand{\X}{\mathbf{X}}
\newcommand{\bw}{\mathbf{w}}

\newcommand{\ts}[1]{\textbf{\textcolor{blue}{#1}}}
\newcommand{\il}[1]{\textbf{\textcolor{green}{#1}}}
\newcommand{\wz}[1]{\textbf{\textcolor{orange}{#1}}}



\DeclareMathOperator{\maximum}{maximum}

\nipsfinalcopy 

\relpenalty=10000
\binoppenalty=10000

\begin{document}
\setlength{\lineskiplimit}{0pt}
\setlength{\lineskip}{0pt}
\setlength{\abovedisplayskip}{2pt}
\setlength{\belowdisplayskip}{0pt}

\maketitle

\begin{abstract}
We present a variety of new architectural features and training procedures that we apply
to the generative adversarial networks (GANs) framework.
We focus on two applications of GANs: semi-supervised learning, and the generation of
images that humans find visually realistic.
Unlike most work on generative models, our primary goal is not to train a model that assigns
high likelihood to test data, nor do we require the model to be able to learn well without using any
labels. Using our new techniques, we achieve state-of-the-art results in semi-supervised classification
on MNIST, CIFAR-10 and SVHN.
The generated images are of high quality as confirmed by a visual Turing test: 
our model generates MNIST samples that humans cannot distinguish from real data,
and CIFAR-10 samples that yield a human error rate of .
We also present ImageNet samples with unprecedented resolution and show that
our methods enable the model to learn recognizable features of ImageNet classes.
\end{abstract}



\section{Introduction}
Generative adversarial networks~\cite{goodfellow2014generative} (GANs) are a class of methods for learning generative models
based on game theory. The goal of GANs is to train a generator network  that produces samples from the
data distribution, , by transforming vectors of noise  as . The training signal for  is provided by a discriminator network  that is trained to distinguish samples from the generator distribution  from real data. The generator network  in turn is then trained to fool the discriminator into accepting its outputs as being real.

Recent applications of GANs have shown that they can produce excellent samples \cite{denton2015deep, radford2015unsupervised}.
However, training GANs requires finding a Nash equilibrium of a non-convex game
with continuous, high-dimensional parameters.
GANs are typically trained using gradient descent techniques that are designed to
find a low value of a cost function, rather than to find the Nash equilibrium of
a game.
When used to seek for a Nash equilibrium, these algorithms 
may fail to converge \cite{goodfellow2014distinguishability}.

In this work, we introduce several techniques intended to encourage convergence of
the GANs game.
These techniques are motivated by a heuristic understanding of the non-convergence
problem.
They lead to improved semi-supervised learning peformance and improved sample generation.
We hope that some of them may form the basis for future work, providing formal guarantees
of convergence.

All code and hyperparameters may be found at:
\url{https://github.com/openai/improved_gan}

\section{Related work}
\label{subsec:previous}
Several recent papers focus on improving the stability of training and the
resulting perceptual quality of GAN
samples~\cite{denton2015deep, radford2015unsupervised, im2016generating, yoo2016pixel}.
We build on some of these techniques in this work.
For instance, we use some of the ``DCGAN'' architectural innovations proposed
in Radford et al.~\cite{radford2015unsupervised}, as discussed below.


One of our proposed techniques, {\em feature matching}, discussed in Sec. \ref{sec:feature},
is similar in spirit to approaches that use maximum mean discrepancy \cite{gretton2005measuring, fukumizu2007kernel, smola2007hilbert}
to train generator networks \cite{Li-et-al-2015,dziugaite2015training}.
Another of our proposed techniques, {\em minibatch features}, is based in part on ideas used
for batch normalization~\cite{ioffe2015batch}, while our proposed 
 {\em virtual batch normalization} is a direct extension of batch normalization.



One of the primary goals of this work is to improve the effectiveness of generative
adversarial networks for semi-supervised learning (improving the performance of
a supervised task, in this case, classification, by learning on additional
unlabeled examples).
Like many deep generative models, GANs have previously been applied to
semi-supervised learning \cite{sutskever2015towards,springenberg2015unsupervised}, and our
work can be seen as a continuation and refinement of this effort.













\section{Toward Convergent GAN Training}
Training GANs consists in finding a Nash equilibrium to a two-player non-cooperative game.
Each player wishes to minimize its own cost function, 
for the discriminator
and  for the generator.
A Nash equilibirum is a point  such that  is
at a minimum with respect to  and  is at a minimum with respect to .
Unfortunately, finding Nash equilibria is a very difficult problem. Algorithms exist for specialized cases, but we are not aware of any that are feasible
to apply to the GAN game, where the cost functions are non-convex, the parameters are
continuous, and the parameter space is extremely high-dimensional.

The idea that a Nash equilibrium occurs when each player has minimal cost seems
to intuitively motivate the idea of using traditional gradient-based minimization
techniques to minimize each player's cost simultaneously.
Unfortunately, a modification to  that reduces  can increase
, and a modification to  that reduces  can increase
.
Gradient descent thus fails to converge for many games.
For example, when one player minimizes  with respect to  and another player
minimizes  with respect to , gradient descent enters a stable orbit,
rather than converging to , the desired equilibrium point \cite{Goodfellow-et-al-2016-Book}.
Previous approaches to GAN training have thus applied gradient descent on each player's
cost simultaneously, despite the lack of guarantee that this procedure will converge.
We introduce the following techniques that are heuristically motivated to encourage
convergence:


























\subsection{Feature matching}
\label{sec:feature}
Feature matching addresses the instability of GANs
by specifying a new objective for the generator that prevents it from overtraining on the current discriminator. Instead of directly maximizing the output of the discriminator, the new objective requires the generator to generate data that matches the statistics of the real data, where we use the discriminator only to specify the statistics that we think are worth matching. Specifically, we train the generator to match the expected value of the features on an intermediate layer of the discriminator. This is a natural choice of statistics for the generator to match, since by training the discriminator we ask it to find those features that are most discriminative of real data versus data generated by the current model. 

Letting  denote activations on an intermediate layer of the discriminator,
our new objective for the generator is defined as:
.
The discriminator, and hence , are trained in the usual way.
As with regular GAN training, the objective has a fixed point where 
exactly matches the distribution of training data.
We have no guarantee of reaching this fixed point in practice, but our empirical
results indicate that feature matching is indeed effective in situations where
regular GAN becomes unstable.

\subsection{Minibatch discrimination}
\label{sec:minibatch}
One of the main failure modes for GAN is for the generator to collapse to a parameter setting where it
always emits the same point.
When collapse to a single mode is imminent, the gradient of the
discriminator may point in similar directions for many similar points.
Because the discriminator processes each example independently, there is
no coordination between its gradients, and thus no mechanism to tell the
outputs of the generator to become more dissimilar to each other.
Instead, all outputs race toward a single point that the discriminator
currently believes is highly realistic.
After collapse has occurred, the discriminator learns that this single
point comes from the generator, but gradient descent is unable to separate
the identical outputs. The gradients of the discriminator then push the
single point produced by the generator around space forever, and the
algorithm cannot converge to a distribution with the correct amount of entropy.
An obvious strategy to avoid this type of failure is to allow the discriminator to look at multiple data examples in combination, and perform what we call \emph{minibatch discrimination}.

The concept of minibatch discrimination is quite general: any discriminator model that looks at multiple examples in combination, rather than in isolation, could potentially help avoid collapse of the generator. In fact, the successful application of batch normalization in the discriminator by Radford et al.~\cite{radford2015unsupervised} is well explained from this perspective. So far, however,  we have restricted our experiments to models that explicitly aim to identify generator samples that are particularly close together. One successful specification for modelling the \emph{closeness} between examples in a minibatch is as follows: Let  denote a vector of features for input , produced by some intermediate layer in the discriminator. We then multiply the vector  by a tensor , which results in a matrix . We then compute the -distance between the rows of the resulting matrix  across samples  and apply a negative exponential (\fig{dist}): .
\begin{wrapfigure}[13]{r}{0.4\textwidth}
	\centering
	\includegraphics[width=0.38\textwidth]{imgs/dist.png}
	\caption{Figure sketches how minibatch discrimination works. Features  from sample  are multiplied
    through a tensor , and cross-sample distance is computed.}
\label{fig:dist}
\end{wrapfigure}
The output  for this \emph{minibatch layer} for a sample  is then defined as the sum of the 's to all other samples:


Next, we concatenate the output  of the minibatch layer with the intermediate features  that were its input, and we feed the result into the next layer of the discriminator. We compute these minibatch features separately for samples from the generator and from the training data. As before, the discriminator is still required to output a single number for each example indicating how likely it is to come from the training data: The task of the discriminator is thus effectively still to classify single examples as real data or generated data, but it is now able to use the other examples in the minibatch as \emph{side information}. Minibatch discrimination allows us to generate visually appealing samples very quickly, and in this regard it is superior to feature matching (\secc{expr}). Interestingly, however, feature matching was found to work much better if the goal is to obtain a strong classifier using the approach to semi-supervised learning described in \secc{feat_match_experiments}.







\subsection{Historical averaging}
When applying this technique, we modify each player's cost to include
a term ,
where  is the value of the parameters at past time .
The historical average of the parameters can be updated in an online fashion
so this learning rule scales well to long time series.
This approach is loosely inspired by the fictitious play \cite{brown1951iterative}
algorithm that can find equilibria in other kinds of games.
We found that our approach was able to find equilibria of low-dimensional,
continuous non-convex games, such as the minimax game with one player controlling 
, the other player controlling , and value function ,
where  for  and  otherwise.
For these same toy games, gradient descent fails by going into extended orbits
that do not approach the equilibrium point.


\subsection{One-sided label smoothing}
Label smoothing, a technique from the 1980s
recently independently re-discovered by Szegedy et. al \cite{Szegedy-et-al-2015},
replaces the  and  targets for a classifier with smoothed values, like 
or , and was recently shown to reduce the vulnerability of neural networks
to adversarial examples \cite{wardefarley2016}.

Replacing positive classification targets with  and negative targets with , the optimal discriminator becomes
.
The presence of  in the numerator is problematic because, in areas where
 is approximately zero and  is large, erroneous samples from
 have no incentive to move nearer to the data.
We therefore smooth {\em only} the positive labels to , leaving negative
labels set to 0.


\subsection{Virtual batch normalization}
Batch normalization greatly improves
optimization of neural networks, and was shown to be highly effective for
DCGANs \cite{radford2015unsupervised}.
However, it causes the output of a neural network for an input example  to be
highly dependent on several other inputs  in the same minibatch.
To avoid this problem we introduce {\em virtual batch normalization} (VBN),
in which each example  is normalized based on the statistics collected
on a {\em reference batch} of examples that are chosen once and fixed at the
start of training, and on  itself.
The reference batch is normalized using only its own statistics.
VBN is computationally expensive because it requires running forward propagation on two minibatches
of data, so we use it only in the generator network. 


\section{Assessment of image quality}
\label{sec:qual}
Generative adversarial networks lack an objective function, which makes it difficult to compare performance of different models. One intuitive metric of performance can be obtained by having human annotators judge the visual quality of samples~\cite{denton2015deep}.
We automate this process using Amazon Mechanical Turk (MTurk),
using the web interface in figure~\fig{turing} (live at \url{http://infinite-chamber-35121.herokuapp.com/cifar-minibatch/}), which we use to ask annotators to distinguish between generated data and real data. The resulting quality assessments of our models are described in \secc{expr}.
\begin{wrapfigure}[11]{l}{0.4\textwidth}
    \fbox{
    \begin{minipage}[b][1.6cm][t]{0.41\linewidth}
	    \includegraphics[width=\textwidth]{imgs/question_cifar.png}
    \end{minipage}
    }
    \hfill
    \fbox{
    \begin{minipage}[b][1.6cm][t]{0.41\linewidth}
	    \includegraphics[width=\textwidth]{imgs/res_cifar.png}
    \end{minipage}
    }
	\caption{Web interface given to annotators. Annotators are asked to distinguish computer generated images from real ones.}
\label{fig:turing}
\end{wrapfigure}

A downside of using human annotators is that the metric varies depending on the setup of the task and the motivation of the annotators. We also find that results change drastically when we give annotators feedback about their mistakes: By learning from such feedback, annotators are better able to point out the flaws in generated images, giving a more pessimistic quality assessment. The left column of \fig{turing} presents a screen from the annotation process, while the right column shows how we inform annotators about their mistakes.

As an alternative to human annotators, we propose an automatic method to evaluate samples, which we find to correlate well with human evaluation: We apply the Inception model\footnote{We use the pretrained Inception model from \url{http://download.tensorflow.org/models/image/imagenet/inception-2015-12-05.tgz}. Code to compute the Inception score with this model will be made available by the time of publication.} \cite{szegedy2015rethinking} to every generated image to get the conditional label distribution . Images that contain meaningful objects should have a conditional label distribution  with low entropy. Moreover, we expect the model to generate varied images, so the marginal  should have high entropy. Combining these two requirements, the metric that we propose is: , where we exponentiate results so the values are easier to compare.
Our {\em Inception score} is closely related to the objective used for training generative models in CatGAN \cite{springenberg2015unsupervised}: Although we had less success using such an objective for training, we find it is a good metric for evaluation that correlates very well with human judgment. We find that it's important to evaluate the metric on a large enough number of samples (i.e. ) as part of this metric measures diversity. 


\section{Semi-supervised learning}
\label{sec:feat_match_experiments}
Consider a standard classifier for classifying a data point  into one of  possible classes. Such a model takes in  as input and outputs a -dimensional vector of logits , that can be turned into class probabilities by applying the softmax: .
In supervised learning, such a model is then trained by minimizing the cross-entropy between the observed labels and the model predictive distribution .

We can do semi-supervised learning with any standard classifier by simply adding
samples from the GAN generator  to our data set, labeling them with a new
``generated'' class , and correspondingly increasing the dimension of
our classifier output from  to .
We may then use  to supply the probability that 
is fake, corresponding to  in the original GAN framework.
We can now also learn from unlabeled data, as long as we know that it corresponds to one of the  classes of real data by maximizing .
Assuming half of our data set consists of real data and half of it is generated (this is arbitrary), our loss function for training the classifier then becomes

where we have decomposed the total cross-entropy loss into our standard supervised loss function  (the negative log probability of the label, given that the data is real) and an unsupervised loss  which is in fact the standard GAN game-value as becomes evident when we substitute  into the expression:
 
The optimal solution for minimizing both  and  is to have  and  for some undetermined scaling function . The unsupervised loss is thus consistent with the supervised loss in the sense of Sutskever et al.~\cite{sutskever2015towards}, and we can hope to better estimate this optimal solution from the data by minimizing these two loss functions jointly. In practice,  will only help if it is not trivial to minimize for our classifier and we thus need to train  to approximate the data distribution. One way to do this is by training  to minimize the GAN game-value, using the discriminator  defined by our classifier. This approach introduces an interaction between  and our classifier that we do not fully understand yet, but empirically we find that optimizing  using feature matching GAN works very well for semi-supervised learning, while training  using GAN with minibatch discrimination does not work at all. Here we present our empirical results using this approach; developing a full theoretical understanding of the interaction between  and  using this approach is left for future work.

Finally, note that our classifier with  outputs is over-parameterized: subtracting a general function  from each output logit, i.e.\ setting , does not change the output of the softmax. This means we may equivalently fix , in which case  becomes the standard supervised loss function of our original classifier with K classes, and our discriminator  is given by .

\subsection{Importance of labels for image quality}
Besides achieving state-of-the-art results in semi-supervised learning, the approach described above also has the surprising effect of improving the quality of generated images as judged by human annotators. The reason appears to be that the human visual system is strongly attuned to image statistics that can help infer what class of object an image represents, while it is presumably less sensitive to local statistics that are less important for interpretation of the image. This is supported by the high correlation we find between the quality reported by human annotators and the \emph{Inception score} we developed in \secc{qual}, which is explicitly constructed to measure the ``objectness'' of a generated image. By having the discriminator  classify the object shown in the image, we bias it to develop an internal representation that puts emphasis on the same features humans emphasize. This effect can be understood as a method for transfer learning, and could potentially be applied much more broadly. We leave further exploration of this possibility for future work.

\section{Experiments}
\label{sec:expr}

We performed semi-supervised experiments on MNIST, CIFAR-10 and SVHN, and sample generation experiments on
MNIST, CIFAR-10, SVHN and ImageNet.
We provide code to reproduce the majority of our experiments.

\subsection{MNIST}
\label{sec:mnist}


\begin{wrapfigure}[17]{r}{0.5\textwidth}
	\centering
	\includegraphics[width=0.23\textwidth]{imgs/mnist_sample_20_5_5_300.png}
  \hfill
	\includegraphics[width=0.23\textwidth]{imgs/mnist_minibatch_sample.png}
	\caption{{\em (Left)} samples generated by model during semi-supervised training. Samples can be clearly
    distinguished from images coming from MNIST dataset. {\em (Right)} Samples generated with minibatch discrimination.
    Samples are completely indistinguishable from dataset images.}
\label{fig:mnist}
\end{wrapfigure}


The MNIST dataset contains  labeled images of digits. We perform semi-supervised training
with a small randomly picked fraction of these, considering setups with , , , and  labeled examples.
Results are averaged over  random subsets of labeled data, each chosen to have a balanced number of examples from each class. The remaining training images are provided without labels. Our networks have 5 hidden layers each.
We use weight normalization \cite{salimans2016weight} and add Gaussian noise to the output of each layer of the discriminator. \tab{mnist} summarizes our results.





Samples generated by the generator during semi-supervised learning using
feature matching (\secc{feature}) do not look visually appealing
(left \fig{mnist}). By using minibatch discrimination instead (\secc{minibatch})
we can improve their visual quality. On MTurk,
annotators were able to distinguish samples in  of cases ( votes total),
where  would be obtained by random guessing. Similarly, researchers in our
institution were not able to find any artifacts that would allow them to
distinguish samples. However, semi-supervised learning with minibatch
discrimination does not produce as good a classifier as does feature matching.

\begin{table}[ht]
  \tiny
  \centering
  \renewcommand{\arraystretch}{1.15}
  \begin{tabular}{cCCCC}
    \hline
     Model & \multicolumn{4}{c}{Number of incorrectly predicted test examples}\\
           & \multicolumn{4}{c}{for a given number of labeled samples}\\
           & 20 & 50 & 100 & 200 \\
    \hline
    \hline
     DGN~\cite{kingma2014semi} & & &  & \\
     Virtual Adversarial~\cite{miyato2015distributional} & & & 212 & \\
     CatGAN~\cite{springenberg2015unsupervised} & & &  & \\
		 Skip Deep Generative Model \cite{maaloe2016auxiliary} & & &  & \\
     Ladder network~\cite{rasmus2015semi} & & &  & \\
		 Auxiliary Deep Generative Model \cite{maaloe2016auxiliary} & & &  & \\
    \hline
     Our model &  &  &  &  \\
     Ensemble of 10 of our models &  &     &  & \\
    \hline
  \end{tabular}
  \caption{Number of incorrectly classified test examples for the semi-supervised setting on permutation invariant MNIST. Results are averaged over  seeds.}
  \label{tab:mnist}
\end{table}

\subsection{CIFAR-10}
\label{sec:cifar}


\begin{table}[h]
  \tiny
  \centering
  \renewcommand{\arraystretch}{1.15}
  \begin{tabular}{cCCCC}
    \hline
     Model & \multicolumn{4}{c}{Test error rate for}\\
           & \multicolumn{4}{c}{a given number of labeled samples}\\
           & 1000 & 2000 & 4000 & 8000 \\
    \hline
    \hline
     Ladder network~\cite{rasmus2015semi} & & &  & \\
     CatGAN~\cite{springenberg2015unsupervised} & & &  & \\
    \hline
     Our model&  &   &  & \\
     Ensemble of 10 of our models &  &  &  &  \\
    \hline
  \end{tabular}
  \caption{Test error on semi-supervised CIFAR-10. Results are averaged over  splits of data.}
  \label{tab:cifar}
\end{table}

CIFAR-10 is a small, well studied dataset of  natural images. We use this data set to study semi-supervised learning, as well as to examine the visual quality of samples that can be achieved. For the discriminator in our GAN we use a  layer deep convolutional network with dropout and weight normalization. The generator is a 4 layer deep CNN with batch normalization. \tab{cifar} summarizes our results on the semi-supervised learning task.



\begin{figure}
	\centering
	\includegraphics[width=0.45\textwidth]{imgs/cifar10_feat_match.png}
  \hfill
	\includegraphics[width=0.45\textwidth]{imgs/cifar10_with_labels.png}
	\caption{Samples generated during semi-supervised training on CIFAR-10 with feature matching (\secc{feature}, {\em left}) and minibatch discrimination (\secc{minibatch}, {\em right}).}
\label{fig:cifar10}
\end{figure}


When presented with  real and  fake data generated by our
best CIFAR-10 model, MTurk users correctly
categorized  of images correctly.
However, MTurk users may not be sufficiently familiar with CIFAR-10 images
or sufficiently motivated; we ourselves were able to categorize images
with  accuracy.
We validated the Inception score described above by observing that MTurk
accuracy drops to  when the data is filtered by using only the
top  of samples according to the Inception score.
We performed a series of ablation experiments to demonstrate that our proposed
techniques improve the Inception score, presented in \tab{measure}.
We also present images for these ablation experiments---in our opinion, the
Inception score correlates well with our subjective judgment of image quality.
Samples from the dataset achieve the
highest value.
All
the models that even partially collapse have relatively low scores.
We caution that the Inception score should be used as a rough guide to
evaluate models that were trained via some independent criterion; directly
optimizing Inception score will lead to the generation of
adversarial examples~\cite{szegedy2013intriguing}.

\begin{table}[h]
  \tiny
  \centering
  \renewcommand{\arraystretch}{1.15}
  \begin{tabular}{p{1.5cm}CCCCCCC}
    \hline
     Samples & \includegraphics[width=\cifarwidth]{imgs/samples_real.png} & \includegraphics[width=\cifarwidth]{imgs/samples_calorie.png} & \includegraphics[width=\cifarwidth]{imgs/samples_circle.png}  &  \includegraphics[width=\cifarwidth]{imgs/samples_green.png} & \includegraphics[width=\cifarwidth]{imgs/samples_citizen.png} & \includegraphics[width=\cifarwidth]{imgs/samples_crunch.png} & \includegraphics[width=\cifarwidth]{imgs/samples_card.png}  \\
    \hline
     Model & Real data & Our methods & -VBN+BN & -L+HA & -LS & -L & -MBF \\
    \hline
     Score  std. &  &   &  &  &  &  &   \\ 
    \hline
  \end{tabular}
  \caption{Table of Inception scores for samples generated by various models for  images.
  Score highly correlates with human judgment, and the 
  best score is achieved for natural images.
  Models that generate collapsed samples have relatively low score. This metric allows us to avoid relying on human evaluations.
  ``Our methods'' includes all the techniques described in this work, except for feature matching and historical averaging.
  The remaining experiments are ablation experiments showing that our techniques are effective.
  ``-VBN+BN'' replaces the VBN in the generator with BN, as in DCGANs. This causes a small decrease
  in sample quality on CIFAR. VBN is more important for ImageNet.
``-L+HA'' removes the labels from the training process, and adds historical averaging to compensate.
HA makes it possible to still generate some recognizable objects. Without HA, sample quality is
considerably reduced (see "-L").
``-LS" removes label smoothing and incurs a noticeable drop in performance relative to ``our methods.''
``-MBF'' removes the minibatch features and incurs a very large drop in performance, greater even than
the drop resulting from removing the labels. Adding HA cannot prevent this problem.
}
  \label{tab:measure}
\end{table}




\subsection{SVHN}
\label{sec:svhn}
For the SVHN data set, we used the same architecture and experimental setup as for CIFAR-10. \begin{figure}[!htb]
    \begin{minipage}[t]{.58\textwidth}
				\vspace{2pt}
		\tiny
  \centering
  \renewcommand{\arraystretch}{1.15}
  \begin{tabular}{cCCC}
    \hline
     Model & \multicolumn{3}{c}{Percentage of incorrectly predicted test examples}\\
           & \multicolumn{3}{c}{for a given number of labeled samples}\\
           & 500 & 1000 & 2000\\
    \hline
    \hline
     DGN~\cite{kingma2014semi} & &   & \\
     Virtual Adversarial~\cite{miyato2015distributional} & &  & \\
     Auxiliary Deep Generative Model \cite{maaloe2016auxiliary} & &  & \\
     Skip Deep Generative Model \cite{maaloe2016auxiliary} & &  & \\	 
    \hline
     Our model &  &  &  \\
     Ensemble of 10 of our models & &  & \\
    \hline
  \end{tabular}
		\end{minipage}\hspace{0.1cm}
    \begin{minipage}[t]{0.4\textwidth}
		\vspace{0pt}
		\centering
		\centerline{\includegraphics[width=0.5\textwidth]{imgs/svhn_small.png}}
    \end{minipage}
		\caption{{\em (Left)} Error rate on SVHN. {\em (Right)} Samples from the generator for SVHN.}
\label{fig:svhn}
\end{figure}

\subsection{ImageNet}
\label{sec:imagenet}

We tested our techniques on a dataset of unprecedented scale:  images from the ILSVRC2012
dataset with 1,000 categories.
To our knowledge, no previous publication has applied a generative model to a dataset with both this
large of a resolution and this large a number of object classes.
The large number of object classes is particularly challenging for GANs due to their tendency to underestimate
the entropy in the distribution.
We extensively modified a publicly available implementation of DCGANs\footnote{https://github.com/carpedm20/DCGAN-tensorflow}
using TensorFlow \cite{tensorflow} to achieve high performance, using a multi-GPU implementation.
DCGANs without modification learn some basic image statistics and generate contiguous shapes
with somewhat natural color and texture but do not learn any objects.
Using the techniques described in this paper, GANs learn to generate objects
that resemble animals, but with incorrect anatomy.
Results are shown in \fig{imagenet}.

\begin{figure}[htb]
	\centering
	\includegraphics[width=0.4\textwidth]{dcgan_imagenet.png}
  \hfill
	\includegraphics[width=0.4\textwidth]{imagenet_animals.png}
	\caption{Samples generated from the ImageNet dataset.
  {\em (Left)} Samples generated by a DCGAN.
  {\em (Right)} Samples generated using the techniques proposed in this work.
The new techniques enable GANs to learn recognizable features of animals,
such as fur, eyes, and noses, but these features are not correctly combined
to form an animal with realistic anatomical structure.
  }
\label{fig:imagenet}
\end{figure}

\section{Conclusion}
Generative adversarial networks are a promising class of generative models that has so far been held back by unstable training and by the lack of a proper evaluation metric. This work presents partial solutions to both of these problems. We propose several techniques to stabilize training that allow us to train models that were previously untrainable. Moreover, our proposed evaluation metric (the Inception score) gives us a basis for comparing the quality of these models. We apply our techniques to the problem of semi-supervised learning, achieving state-of-the-art results on a number of different data sets in computer vision. The contributions made in this work are of a practical nature; we hope to develop a more rigorous theoretical understanding in future work.

\small
\bibliography{bibliography}
\bibliographystyle{unsrt}




\end{document}
