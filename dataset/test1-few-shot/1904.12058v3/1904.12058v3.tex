\documentclass{article} \usepackage{iclr2020_conference,times}
\iclrfinalcopy


\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{hyperref}
\usepackage{url}
\usepackage{graphicx}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{wrapfig}
\usepackage{bm}
\newcommand{\mat}[1]{\bm{\mathrm{#1}}}
\renewcommand{\vec}[1]{\bm{\mathrm{#1}}}
\newcommand{\trans}{^{\top}}

\usepackage[skip=3pt]{caption}


\title{Inductive Matrix Completion Based on Graph Neural Networks}






\author{Muhan Zhang*\\
Washington University in St. Louis\\
\texttt{muhan@wustl.edu}\\
\footnotesize{*Now at Facebook}
\And Yixin Chen\\
Washington University in St. Louis\\
\texttt{chen@cse.wustl.edu} \\
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\begin{document}


\maketitle

\begin{abstract}
We propose an inductive matrix completion model without using side information. By factorizing the (rating) matrix into the product of low-dimensional latent embeddings of rows (users) and columns (items), a majority of existing matrix completion methods are \textit{transductive}, since the learned embeddings cannot generalize to unseen rows/columns or to new matrices. To make matrix completion \textit{inductive}, most previous works use content (side information), such as user's age or movie's genre, to make predictions. However, high-quality content is not always available, and can be hard to extract. Under the extreme setting where not any side information is available other than the matrix to complete, can we still learn an inductive matrix completion model? In this paper, we propose an Inductive Graph-based Matrix Completion (IGMC) model to address this problem. IGMC trains a graph neural network (GNN) based purely on 1-hop subgraphs around (user, item) pairs generated from the rating matrix and maps these subgraphs to their corresponding ratings. It achieves highly competitive performance with state-of-the-art transductive baselines. In addition, IGMC is inductive -- it can generalize to users/items unseen during the training (given that their interactions exist), and can even transfer to new tasks. Our transfer learning experiments show that a model trained out of the MovieLens dataset can be directly used to predict Douban movie ratings with surprisingly good performance. Our work demonstrates that: 1) it is possible to train inductive matrix completion models without using side information while achieving similar or better performances than state-of-the-art transductive methods; 2) local graph patterns around a (user, item) pair are effective predictors of the rating this user gives to the item; and 3) Long-range dependencies might not be necessary for modeling recommender systems.



\end{abstract}

\section{Introduction}
Matrix completion \citep{candes2009exact} is one common formulation of recommender systems, where rows and columns of a matrix represent users and items, respectively, and predicting users' interest in items corresponds to filling in the missing entries of the rating matrix.
By assuming a low-rank rating matrix, many of the most popular matrix completion algorithms use factorization techniques that decompose a rating  into , the inner product of user 's and item 's latent feature vectors  and , respectively, which have achieved great successes \citep{adomavicius2005toward,schafer2007collaborative,koren2009matrix,bobadilla2013recommender} 



However, matrix factorization is intrinsically transductive, meaning that the learned latent features (embeddings) for users/items are not generalizable to users/items unseen during the training. When the rating matrix has changed values or has new rows/columns added, it often requires a complete retraining to get the new embeddings. To make matrix completion inductive, Inductive Matrix Completion (IMC) has been proposed, which leverages content (side information) of users and items \citep{jain2013provable,xu2013speedup}. In IMC, a rating is decomposed by , where  and  are content feature vectors of user  and item , respectively, and  is a learnable matrix modeling the feature interactions. To accurately predict missing entries, IMC methods have strong constraints on the content quality, which often leads to inferior performance when high-quality content is not available. Other content-based recommender systems \citep{lops2011content} face similar problems. In some extreme settings, there is not any content available for user, such as a website where users are completely anonymous. In these cases, inductive matrix completion seems impossible. 



Recently, \citet{hartford2018deep} propose exchangeable matrix layers, which apply permutation equivariant operations on the rating matrix to reconstruct missing entries. The resulting models are inductive and do not rely on side information. However, these models take the whole rating matrix  as input and output another reconstructed matrix, which poses scalability challenges for practical datasets with millions of users/items.
In this paper, we propose a novel inductive matrix completion method that does not use any content. Further, our method does not need to take the whole rating matrix as input, and can infer ratings for individual user-item pairs. The key that frees us from using content or whole rating matrix is \textbf{local graph pattern}.
If for each observed rating we add an edge between the corresponding user and item, we can build a \textit{bipartite graph} from the rating matrix. Subsequently, predicting unknown ratings converts equivalently to predicting labeled links in this bipartite graph. This transforms matrix completion into a link prediction problem \citep{liben2007link}, where graph patterns play a major role in determining link existences.

A major class of link prediction methods are heuristic methods, which predict links based on some heuristic scores. For example, the common neighbors heuristic count the common neighbors between two nodes to predict links, while the Katz index \citep{katz1953new} uses a weighted sum of all the walks between two nodes. See \citep{liben2007link} for an overview. These heuristics can be seen as some predefined graph structure features calculated based on the local or global graph patterns around links, which have achieved great successes due to their simplicity and effectiveness. 

However, these traditional link prediction heuristics only work for simple graphs where nodes and edges both only have a single type. Can we find some heuristics for labeled link prediction in bipartite graph?
Intuitively, such heuristics should exist. For example, if a user  likes an item , we may expect to see very often that  is also liked by some other user  who shares a similar taste to . By similar taste, we mean  and  have together both liked some other item . In the bipartite graph, such a pattern is realized as a ``like'' path . If there are many such paths between  and , we may infer that  is highly likely to like . Thus, we may count the number of such paths as an indicator of how likely  likes . In fact, many neighborhood-based recommender systems \citep{desrosiers2011comprehensive} rely on similar heuristics. 



Of course we can try to manually define many such intuitive heuristics and test their effectiveness. In this work, however, we take a different approach that \textbf{automatically learns suitable heuristics} from the given bipartite graph. To do so, we first extract an \textit{-hop enclosing subgraph} for each training user-item pair , which is defined to be the subgraph induced from the bipartite graph by nodes  and their neighbors within  hops. Such local subgraphs contain rich graph pattern information about the rating that  may give to . For example, all the  paths are included in the 1-hop enclosing subgraph around . By feeding these enclosing subgraphs to a graph neural network (GNN), we train a graph regression model that maps each subgraph to the rating that its center user gives to its center item. Figure~\ref{overall} illustrates the overall framework. 


\begin{figure}
\centering
  \includegraphics[width=0.99\textwidth]{materials/overall2.pdf}
  \caption{We extract a local enclosing subgraph around each rating (dark green), and train a GNN to map subgraphs to ratings. Each enclosing subgraph is induced by the user and item associated with the target rating as well as their -hop neighbors (here ).
From the subgraphs, a GNN can learn mixed graph patterns (such as average ratings, paths, etc.) useful for rating prediction. We illustrate some possible patterns in the GNN box.
We use the trained GNN to complete the missing entries.}
  \label{overall}
\end{figure}

Due to the superior graph learning ability, a GNN can learn highly expressive graph structure features useful for inferring the ratings without restricting the features to predefined heuristics. Given a trained GNN, we can also apply it to unseen users/items without retraining. Our resulting algorithm is inductive, and is named Inductive Graph-based Matrix Completion (IGMC). Note that IGMC \textbf{does not} address the extreme cold-start problem, as it still requires an unseen user-item pair's enclosing subgraph (i.e., the user and item should at least have some interactions with neighbors so that the enclosing subgraph is not empty). This scenario is very common in practice. For example, a newly registered YouTube user may quickly watch some videos without completing their personal information. In this case, if we cannot retrain user embeddings frequently, IGMC can be of great value by still making recommendations based purely on this user's interaction history with videos.

We compare IGMC with state-of-the-art matrix completion algorithms on five benchmark datasets. Without using any content, IGMC achieves the smallest RMSEs on four of them, even beating many transductive baselines augmented by side information. 
Our model is also equipped with excellent transfer learning ability. We show that an IGMC model trained on the MovieLens-100K dataset can be directly used to predict Douban movie ratings and even outperforms some baselines trained specifically on Douban. We also analyze IGMC's behavior on sparse rating matrices. We show that IGMC is more robust than transductive methods on sparse matrices. Under an extremely sparse case (only 0.1\% of MovieLens-1M training ratings are kept), IGMC can still achieve less than 0.95 RMSE, beating a state-of-the-art transductive method GC-MC by more than 0.1 RMSE. Finally, our visualization confirms that local enclosing subgraphs are indeed strong predictors of ratings.










\section{Related Work}\label{appendix:related}

\noindent\textbf{Graph neural networks~~} 
Graph neural networks (GNNs) are a new type of neural networks for learning over graphs \citep{scarselli2009graph,bruna2013spectral,duvenaud2015convolutional,li2015gated,kipf2016semi,niepert2016learning,dai2016discriminative}. There are two types of GNNs: \textbf{Node-level GNNs} use message passing layers to iteratively pass messages between each node and its neighbors in order to extract a feature vector for each node encoding its local substructure. \textbf{Graph-level GNNs} additionally use a pooling layer such as summing which aggregates node feature vectors into a graph representation to enable graph-level tasks such as graph classification/regression. Due to the superior graph representation learning ability, GNNs have achieved state-of-the-art performance on semi-supervised node classification \citep{kipf2016semi}, network embedding \citep{hamilton2017inductive}, graph classification \citep{zhang2018end}, and link prediction \citep{zhang2018link}, etc.


\noindent \textbf{GNNs for matrix completion~~}
The matrix completion problem has been studied using GNNs. \citet{monti2017geometric} develop a multi-graph CNN (MGCNN) model to extract user and item latent features from their respective nearest-neighbor networks. \citet{berg2017graph} propose graph convolutional matrix completion (GC-MC) which directly applies a GNN to the user-item bipartite graph to extract user and item latent features using a GNN. The SpectralCF model of \citep{zheng2018spectral} uses a spectral-GNN on the bipartite graph to learn node embeddings. Although using GNNs for matrix completion, all these models are still \textbf{transductive} -- MGCNN and SpectralCF require graph Laplacians which do not generalize to new graphs, while GC-MC uses one-hot encoding of node IDs as initial node features, thus cannot generalize to unseen users/items. A recent inductive graph-based recommender system, PinSage \citep{ying2018graph}, uses node content as initial node features (instead of the one-hot encoding in GC-MC), and is successfully used in recommending related pins in Pinterest. Although being inductive, PinSage relies heavily on the rich visual and text content associated with the pins which is not often accessible in other recommendation tasks. In comparison, our IGMC model is inductive and does not rely on any content. All previous approaches use node-level GNNs to learn embeddings for \textbf{nodes}, while our IGMC uses a \textbf{graph-level} GNN to learn representations for \textbf{subgraphs}. We will discuss this crucial difference in more details in Section \ref{subgraphVSsubtree}.

Another related previous work is \citep{hartford2018deep}, which defines exchangeable matrix layers to perform permutation-equivariant operations on matrices to achieve inductive matrix completion without using content. In particular, the operation updates each matrix entry by a weighted sum of itself, entries of its row, entries of its column, and all other entries of the matrix, where parameters for each of the four components are shared across all entries. It can also be regarded as a GNN with the exceptions that 1) the message passing is performed on edges (final edge features are pooled into node features), and 2) all edges (including those not connected to the center edge) pass messages to the center edge in each round. One limitation of \citep{hartford2018deep} is that it takes the entire rating matrix as input, which might raise concerns for large matrices. In comparison, our IGMC takes only local subgraphs as input which avoids the issue and enables predicting individual ratings. 

\noindent\textbf{Link prediction based on graph patterns~~} 
Learning supervised heuristics (graph patterns) has been studied for link prediction in simple graphs. \citet{zhang2017weisfeiler} propose Weisfeiler-Lehman Neural Machine (WLNM), which learns graph structure features using a fully-connected neural network on the subgraphs' adjacency matrices. Later, they improve this work by replacing the fully-connected neural network with a GNN and achieves state-of-the-art link prediction results \citep{zhang2018link}. Our work generalizes this line of research from predicting link existence in simple graphs to predicting values of links in bipartite graphs (i.e., matrix completion). In \citep{chen2005link,zhou2007bipartite}, traditional link prediction heuristics are adapted to bipartite graphs which show promising performance for recommender systems. Our work differs in that we do not use any predefined heuristics, but learn general graph structure features using a GNN. Another similar work to ours is \citep{li2013recommendation}, where graph kernels are used to learn graph structure features. However, graph kernels require quadratic time and space complexity to compute and store the kernel matrices thus are unsuitable for modern recommender systems.



\section{Inductive Graph-based Matrix Completion (IGMC)}
We now present our Inductive Graph-based Matrix Completion (IGMC) framework. We use  to denote the undirected bipartite graph constructed from the given rating matrix . In , a node is either a user (denoted by , corresponding to a row in ) or an item (denoted by , corresponding to a column in ). Edges can exist between user and item, but cannot exist between two users or two items. Each edge  has a value , corresponding to the rating that  gives to . We use  to denote the set of all possible ratings (e.g.,  in MovieLens), and use  to denote the set of 's neighbors that connect to  with edge type .

\subsection{Enclosing subgraph extraction}
The first part of IGMC is enclosing subgraph extraction. For each observed rating , we extract an -hop enclosing subgraph around  from . Algorithm~\ref{ese} describes the BFS procedure for extracting -hop enclosing subgraphs. We will feed these enclosing subgraphs to a GNN and regress on their ratings. Then, for each testing  pair, we again extract its -hop enclosing subgraph from , and use the trained GNN model to predict its rating. Note that after extracting a training enclosing subgraph for , we should remove the edge  because it is the target to predict. 

\begin{algorithm}[tp]
\begin{algorithmic}[1]
\STATE \textbf{input:} , target user-item pair , the bipartite graph  \\
\STATE \textbf{output:} the -hop enclosing subgraph  for \\
\STATE{}
\FOR{}
\STATE{}
\STATE{}
\STATE{}
\STATE{}
\STATE{Let  be the vertex-induced subgraph from  using vertices }
\STATE{Remove edge  from .}
\ENDFOR
\RETURN{}
\end{algorithmic}
\caption{\textsc{Enclosing Subgraph Extraction}}\label{ese}
\footnotesize Note:  is the set of nodes that are adjacent to at least one node in  with any edge type.
\end{algorithm}

\subsection{Node labeling}
The second part of IGMC is node labeling. Before we feed an enclosing subgraph to the GNN, we first apply a \textit{node labeling} to it, which gives an integer label to every node in the subgraph. The purpose is to use different labels to mark nodes' different roles in a subgraph. Ideally, our node labeling should be able to: 1) distinguish the target user and target item between which the target rating is located, and 2) differentiate user-type nodes from item-type nodes. Otherwise, the GNN cannot tell between which user and item to predict the rating, and might lose node-type information. To satisfy these conditions, we propose a node labeling as follows: We first give label 0 and 1 to the target user and target item, respectively. Then, we determine other nodes' labels according to at which hop they are included in the subgraph in Algorithm~\ref{ese}. If a user-type node is included at the  hop, we will give it a label . If an item-type node is included at the  hop, we will give it . Such a node labeling can sufficiently discriminate: 1) target nodes from ``context'' nodes, 2) users from items (users always have even labels), and 3) nodes of different distances to the target rating. 

Note that this is not the only possible way of node labeling, but we empirically verified its excellent performance. The one-hot encoding of these node labels will be treated as the initial node features  of the subgraph when fed to the GNN. Note that our node labels are determined completely \textbf{inside each enclosing subgraph}, thus are independent of the global bipartite graph. Given a new enclosing subgraph, we can as well predict its rating even if all of its nodes are from a different bipartite graph, because IGMC purely relies on graph patterns within local enclosing subgraphs without leveraging any global information specific to the bipartite graph.
Our node labeling is also \textbf{different} from using the \textbf{global node IDs} as in GC-MC \citep{berg2017graph}. Using one-hot encoding of global IDs is essentially transforming the first message passing layer's parameters into latent node embedding associated with each particular ID (equivalent to an embedding lookup table). Such a model cannot generalize to nodes whose IDs are out of range, thus is transductive. 



\subsection{Graph neural network architecture}
The third part of IGMC is to train a graph neural network (GNN) model predicting ratings from the enclosing subgraphs. In previous node-based approaches such as GC-MC, a node-level GNN is applied to the entire bipartite graph to extract node embeddings. Then, the node embeddings of  and  are input to an inner-product or bilinear operator to reconstruct the rating on . In contrast, IGMC applies a graph-level GNN to the enclosing subgraph around  and maps the subgraph to the rating.
There are thus two components in our GNN: 1) message passing layers that extract a feature vector for each node in the subgraph, and 2) a pooling layer to summarize a subgraph representation from node features. 

To learn the rich graph patterns introduced by the different edge types, we adopt the relational graph convolutional operator (R-GCN) \citep{schlichtkrull2018modeling} as our GNN's message passing layers, which has the following form:

where  denotes node 's feature vector at layer ,  and  are learnable parameter matrices. Since neighbors  connected to  with different edge types  are processed by different parameter matrices , we are able to learn a large amount of enriched graph patterns inside the edge types, such as the average rating the target user gives to items, the average rating the target item receives, and by which paths the two target nodes are connected, etc. We stack  message passing layers with \textit{tanh} activations between two layers. Following \citep{zhang2018end,xu2018powerful}, node 's feature vectors from different layers are concatenated as its final representation :


Next, we pool the node representations into a graph-level feature vector. There are many choices such as summing, averaging, SortPooling \citep{zhang2018end}, DiffPooling \citep{ying2018hierarchical}, etc. In this work, however, we use a different pooling layer which concatenates the final representations of only the target user and item as the graph representation:

where we use  and  to denote the final representations of the target user and target item, respectively. Our particular choice is due to the extra importance that these two target nodes carry compared to other context nodes. Although being very simple, we empirically verified its better performance than summing and other advanced pooling layers for our matrix completion tasks.

After getting the final graph representation, we use an MLP to output the predicted rating:

where  and  are parameters of the MLP which map the graph representation  to a scalar rating , and  is an activation function (we take ReLU in this paper).



\subsection{Model training}
\noindent \textbf{Loss function}~~We minimize the mean squared error (MSE) between the predictions and the ground truth ratings:

where we use  and  to denote the true rating and predicted rating of , repsectively, and  is a 0/1 mask matrix indicating the observed entries of the rating matrix .

\noindent \textbf{Adjacent rating regularization}~~The R-GCN layer (\ref{rgcn}) used in our GNN has different parameters  for different rating types. One drawback here is that it fails to take the magnitude of ratings into consideration. For instance, a rating of 4 and a rating of 5 in MovieLens both indicate that the user likes the movie, while a rating of 1 indicates that the user does not like the movie. Ideally, we expect our model to be aware of the fact that a rating of 4 is more similar to 5 than 1 is. In R-GCN, however, ratings 1, 4 and 5 are only treated as three independent edge types -- the magnitude and order information of the ratings is completely lost. To fix that, we propose an adjacent rating regularization (ARR) technique, which encourages ratings adjacent to each other to have similar parameter matrices. Assume the ratings in  exhibit an ordering  which indicates increasingly higher preference that users have for items. Then, the ARR regularizer is:

where  denotes the Frobenius norm of a matrix. The above regularizer restrains the parameter matrices of adjacent ratings from having too much differences, which not only takes into consideration of the ratings' order, but also helps the optimization of those infrequent ratings by transferring knowledge from their adjacent ratings. The final loss function is given by:

where  trades-off the importance of the MSE loss and the ARR regularizer. There are many other ways to model rating magnitude and order, which are left for future work.


\begin{wrapfigure}[11]{L}{0.45\textwidth}
\centering
\vspace{-12pt}
  \includegraphics[width=0.45\textwidth]{materials/subtree2.pdf}
\label{subtree}
\end{wrapfigure}

\section{Graph-level GNN vs. node-level GNN}
\label{subgraphVSsubtree}



Compared to previous graph matrix completion approaches such as PinSage and GC-MC, one important difference of IGMC is that it uses a graph-level GNN to map the enclosing subgraph around the target user and item to their rating (left figure (a)), instead of using a node-level GNN on the bipartite graph  to learn target user's and item's embeddings and use the node embeddings to predict the rating (left figure (b)). 
One drawback of the latter node-based approach is that the learned node embeddings are essentially encoding the two rooted subtrees around the two nodes \textbf{independently}, which fails to model the \textbf{interactions} and \textbf{correspondences} between the nodes of the two trees. For example, from the two subtrees of the left figure (b) we do not really know whether the two target nodes are just isolated from each other like in (b) or actually densely connected like in (a); these two cases look \textbf{identical} to a node-based approach. 

In comparison, a graph-level GNN can discriminate the two cases through a sufficient number of message passing rounds. Since the learning is confined to the subgraph, stacking multiple graph convolution layers will learn more and more refined local structural features which can adequately discriminate up to all subgraphs that the Weisfeiler-Lehman algorithm can discriminate \citep{xu2018powerful}. However, for node-based approaches, since there is no subgraph boundary, stacking multiple graph convolutions will only extend the convolution range to unrelated distant nodes and over-smooth the node embeddings \citep{li2018deeper}. This is reflected in that previous node-based approaches mainly use only one or two message passing layers \citep{berg2017graph,ying2018graph}.

Nevertheless, using a graph-level GNN on every target rating's enclosing subgraph has higher complexity than using a node-level GNN on the entire bipartite graph. Suppose the bipartite graph has  edges. Then performing one round of message passing using a node-level GNN has  complexity. Assume the maximum number of edges in all enclosing subgraphs is . Performing one round of message passing for all enclosing subgraphs then has  complexity. In practice, we can use subsampling to restrict  to a small number to reduce IGMC's complexity.


















\section{Experiments}
We conduct experiments on five common matrix completion datasets: Flixster \citep{jamali2010matrix}, Douban \citep{ma2011recommender}, YahooMusic \citep{dror2011yahoo}, MovieLens-100K and MovieLens-1M \citep{miller2003movielens}. For ML-100K, we train and evaluate on the canonical u1.base/u1.test train/test split. For ML-1M, we randomly split it into 90\% and 10\% train/test sets. For Flixster, Douban and YahooMusic we use the preprocessed subsets and splits provided by \citep{monti2017geometric}. Dataset statistics are summarized in Table \ref{stat}. We implemented IGMC using pytorch\_geometric \citep{Fey/Lenssen/2019}. We tuned model hyperparameters based on cross validation results on ML-100K, and used them across all datasets. The final architecture uses 4 R-GCN layers with 32, 32, 32, 32 hidden dimensions. Basis decomposition with 4 bases is used to reduce the number of parameters in  \citep{schlichtkrull2018modeling}. The final MLP has 128 hidden units and a dropout rate of 0.5. We use \textbf{1-hop} enclosing subgraphs for all datasets, and find them sufficiently good. We find using 2 or more hops can slightly increase the performance but take much longer training time. For each enclosing subgraph, we randomly drop out its adjacency matrix entries with a probability of 0.2 during the training. We set the  in (\ref{reg}) to 0.001. We train our model using the Adam optimizer \citep{kingma2014adam} with a batch size of 50 and an initial learning rate of 0.001, and multiply the learning rate by 0.1 every 20 epochs for ML-1M, and every 50 epochs for all other datasets. Our code is publicly available at \url{https://github.com/muhanzhang/IGMC}.

\begin{table}[t]
\caption{Statistics of each dataset.}
\label{stat}
\begin{center}
\begin{tabular}{lrrrrr}
    \toprule
    \textbf{Dataset}&\textbf{Users}&\textbf{Items}&\textbf{Ratings}&\textbf{Density}&\textbf{Rating types}\\
    \midrule
    Flixster & 3,000 & 3,000 & 26,173 & 0.0029 & 0.5, 1, 1.5, ..., 5\\
    Douban & 3,000 & 3,000 & 136,891 & 0.0152 & 1, 2, 3, 4, 5\\
    YahooMusic & 3,000 & 3,000 & 5,335 & 0.0006 & 1, 2, 3, ..., 100\\
    ML-100K & 943 & 1,682 & 100,000 & 0.0630 & 1, 2, 3, 4, 5\\
    ML-1M & 6,040 & 3,706 & 1,000,209 & 0.0447 & 1, 2, 3, 4, 5\\
  \bottomrule
\end{tabular}\end{center}
\end{table}


\begin{table}[t]
   \caption{RMSE test results on Flixster, Douban and YahooMusic.}
     \label{res1}
\begin{center}
\begin{tabular}{lcclll}
    \toprule
    \textbf{Model}&\textbf{Inductive}&\textbf{Content}&\textbf{Flixster}&\textbf{Douban}&\textbf{YahooMusic}\\
    \midrule
    GRALS & no & yes & 1.245 & 0.833 & 38.0 \\
    sRGCNN & no & yes & 0.926 & 0.801 & 22.4 \\
    GC-MC & no & yes & 0.917 & 0.734 & 20.5 \\
	  \midrule
	IGC-MC & yes & yes & 0.9990.062 & 0.9900.082 & 21.30.989 \\
	  F-EAE  & yes & no & 0.908 & 0.738 & 20.0 \\ 
	  PinSage  & yes & yes & 0.9540.005 & 0.7390.002 & 22.90.629\\
    IGMC (ours) & yes & no & \textbf{0.872}0.001 & \textbf{0.721}0.001 & \textbf{19.1}0.138 \\
  \bottomrule
\end{tabular}\end{center}
\end{table}

\subsection{Flixster, Douban and YahooMusic}
For these three datasets, we compare our IGMC with GRALS \citep{rao2015collaborative}, sRGCNN \citep{monti2017geometric}, GC-MC \citep{berg2017graph}, F-EAE \citep{hartford2018deep}, and PinSage \citep{ying2018graph}. Among them, GRALS is a graph regularized matrix completion algorithm. GC-MC and sRGCNN are transductive node-level-GNN-based matrix completion methods. F-EAE uses exchangeable matrix layers to perform inductive matrix completion without using content. PinSage is an inductive node-level-GNN-based model using content, which is originally used to predict related pins and is adapted to predicting ratings here. We further implemented an inductive GC-MC model (IGC-MC) which replaces the one-hot encoding of node IDs with the content features to make it inductive. The content in these datasets are presented in the form of user and item graphs. We summarize whether each algorithm is inductive and whether it uses content in Table~\ref{res1}.

We train our model for 40 epochs, and save the model parameters every 10 epochs. The final predictions are given by averaging the predictions from epochs 10, 20, 30 and 40. We repeat the experiment five times and report the average RMSEs. The baseline results are taken from \citep{hartford2018deep}. Table \ref{res1} shows the results. Our model achieves the smallest RMSEs on all three datasets without using any content, significantly outperforming all the compared baselines, regardless of whether they are transductive or inductive. Further, except F-EAE, all the baselines have used content information to assist the matrix completion. 
This further highlights IGMC's great performance advantages without relying on content.



\newcolumntype{F}{>{\centering\arraybackslash}p{3.6em}}
\newcolumntype{G}{>{\raggedright\arraybackslash}p{3.8em}}
\newcolumntype{H}{>{\raggedright\arraybackslash}p{4.5em}}
\begin{table}[t]
\centering
   \caption{RMSE test results on MovieLens-100K (left) and MovieLens-1M (right).}
     \label{res2}
\begin{center}
\begin{tabular}{GFFr|}
    \toprule
    \textbf{Model}& \textbf{Inductive} & \textbf{Content} & \textbf{ML-100K}\\
    \midrule
    MC  & no & no & 0.973\\
    IMC  & no & yes & 1.653 \\
    GMC  & no & yes & 0.996 \\
    GRALS  & no & yes & 0.945 \\
    sRGCNN  & no & yes & 0.929 \\
    GC-MC  & no & yes & \textbf{0.905} \\
	\midrule
	  IGC-MC & yes & yes &  1.142 \\
	F-EAE  & yes & no & 0.920 \\
	  PinSage   &  yes & yes & 0.951 \\ 
    IGMC & yes & no & \textbf{0.905} \\
  \bottomrule
\end{tabular}\medskip
  \begin{tabular}{HFFr}
    \toprule
    \textbf{Model}&\textbf{Inductive} & \textbf{Content} & \textbf{ML-1M}\\
    \midrule
    PMF  & no & no & 0.883\\
    I-RBM & no & no & 0.854 \\
NNMF & no & no & 0.843 \\
I-AutoRec  & no & no & 0.831 \\
	CF-NADE & no & no & \textbf{0.829} \\
    GC-MC &  no & no & 0.832\\
	\midrule
	  IGC-MC & yes & yes & 1.259 \\
F-EAE & yes & no & 0.860 \\
	  PinSage  &  yes & yes & 0.906 \\ 
    IGMC & yes & no & 0.857 \\
  \bottomrule
\end{tabular}\end{center}
\end{table}


\subsection{ML-100K and ML-1M}
We further conduct experiments on MovieLens datasets. Side information is present for both users (age, gender, occupation, etc.) and movies (genres). For ML-100K, we compare against matrix completion (MC) \citep{candes2009exact}, inductive matrix completion (IMC) \citep{jain2013provable}, geometric matrix completion (GMC) \citep{kalofolias2014matrix}, as well as GRALS, sRGCNN, GC-MC, F-EAE and PinSage. We train IGMC for 80 epochs and report the ensemble performance of epochs 50, 60, 70 and 80. For ML-1M, besides the baselines GC-MC, F-EAE and PinSage, we further include state-of-the-art algorithms including PMF \citep{mnih2008probabilistic},  I-RBM \citep{salakhutdinov2007restricted}, NNMF \citep{dziugaite2015neural}, I-AutoRec \citep{sedhain2015autorec} and CF-NADE \citep{zheng2016neural}. We train IGMC for 40 epochs and report the ensemble performance of epochs 25, 30, 35 and 40. The experiments are repeated five times and the average results are reported in Table \ref{res2} (standard deviations are less than 0.001). As we can see, IGMC achieves the best performance on ML-100K, in parallel with GC-MC despite that IGMC is an inductive model, while GC-MC is transductive and additionally uses content information. For ML-1M, IGMC cannot catch up with state-of-the-art transductive models such as CF-NADE and GC-MC, but outperforms other inductive models. We will analyze this dataset further in Section \ref{sparserating}.


\begin{wrapfigure}[15]{L}{0.46\textwidth}
\centering
\vspace{-10pt}
  \includegraphics[width=0.45\textwidth]{materials/Sparsity_exp.pdf}
  \caption{ML-1M results under different sparsity ratios.}
  \label{res3}
\end{wrapfigure}

\subsection{Sparse rating matrix analysis}\label{sparserating}
To gain insight into when inductive graph-based matrix completion is more suitable than transductive methods, we compare IGMC with GC-MC on ML-1M under different sparsity levels of the rating matrix. We sequentially increase the sparsity level by randomly keeping only 0.2, 0.1, 0.05, 0.01, and 0.001 of the original training ratings. Then, we train both models on the sparsified rating matrices, and evaluate on the original test set. Figure \ref{res3} shows the results. As we can see, although IGMC falls behind GC-MC initially with full ratings, it starts to perform better after the sparsity ratio is less than 20\%. The advantage becomes even greater under extremely sparse cases. This seems to indicate that IGMC is a better choice than transductive methods when there is not a large amount of training data, which is particularly suitable for the initial rating collection phase of a recommender system. It also suggests that transductive matrix completion relies more on the dense user-item interactions than inductive graph-based matrix completion does. 



\begin{table}[t]
   \caption{RMSE of transferring the model trained on ML-100K to Flixster, Douban and YahooMusic.}
     \label{transferRes}
\begin{center}
\begin{tabular}{lccrrr}
    \toprule
    \textbf{Model}&\textbf{Inductive}&\textbf{Content}&\textbf{Flixster}&\textbf{Douban}&\textbf{YahooMusic}\\
    \midrule
		IGC-MC & yes & no & 1.290 & 1.144 & 25.7 \\
	  F-EAE & yes & no & 0.987 & 0.766 & 23.3 \\ 
    IGMC (ours) & yes & no & \textbf{0.906} & \textbf{0.759} & \textbf{20.1}\\
  \bottomrule
\end{tabular}\end{center}
\end{table}

\subsection{Transfer learning}
A great advantage of an inductive model is its potential for transferring to other tasks. We conduct a transfer learning experiment by applying the IGMC model trained on ML-100K to Flixster, Douban and YahooMusic. Among the three datasets, only Douban has exactly the same rating types as ML-100K (1,2,3,4,5). Thus for Flixster and YahooMusic, we bin their edge types into groups 1 to 5 before feeding into the ML-100K model, and multiply the YahooMusic predictions by 20 to account for the different scales. Despite all the compromises, the transferred IGMC model achieves excellent performance (Table \ref{transferRes}). We also show the transfer learning results of other two inductive models, IGC-MC and F-EAE. Note that an inductive model using content features (such as PinSage) is not transferrable, due to the different feature spaces between MovieLens and the target datasets. Thus for IGC-MC, we replace its content features with node degrees. As we can see, IGMC outperforms the other two models by large margins in terms of transfer learning ability. Furthermore, the transferred IGMC even outperforms a wide range of baselines trained especially on each dataset (Table \ref{res1}). 





\subsection{Ablation studies}
To understand the individual contributions of some components in IGMC, we conduct several ablation studies. In particular, we are interested in: 1) whether the proposed pooling layer in Equation (\ref{pooling}) helps; 2) whether the proposed adjacent rating regularization (ARR) helps; and 3) whether incorporating content can further improve IGMC's performance. We present the results in the appendix.


\subsection{Visualization}
Finally, we visualize 10 testing enclosing subgraphs with the highest and lowest predicted ratings for Flixster, Douban, YahooMusic, and ML-100K, respectively, in Figure \ref{vis1}. As we can see, there are substantially different patterns between high-score and low-score subgraphs, which is why IGMC can predict ratings merely from these subgraphs. For example, high-score subgraphs typically show both high user average rating and high item average rating, while low-score subgraphs often have mixed ratings from non-target users and have low user average rating.




\begin{figure}[htbp]
\centering
\begin{minipage}{0.495\textwidth}
  \includegraphics[width=1\textwidth]{materials/visualization_flixster_prediction.pdf}
  \vspace{-17pt}
  {\footnotesize\center Flixster\par}
  \end{minipage}
  \smallskip
\begin{minipage}{0.495\textwidth}
  \includegraphics[width=1\textwidth]{materials/visualization_douban_prediction.pdf}
  \vspace{-17pt}
  {\footnotesize\center Douban\par}
  \end{minipage}
\begin{minipage}{0.495\textwidth}
  \includegraphics[width=1\textwidth]{materials/visualization_yahoo_music_prediction.pdf}
  \vspace{-17pt}
  {\footnotesize\center YahooMusic\par}
  \end{minipage}
    \smallskip
\begin{minipage}{0.495\textwidth}
  \includegraphics[width=1\textwidth]{materials/visualization_ml_100k_prediction.pdf}
  \vspace{-17pt}
  {\footnotesize\center ML-100K\par}
  \end{minipage}
  \caption{Testing enclosing subgraphs for Flixster, Douban, YahooMusic, and ML-100K. Top 5 and bottom 5 are subgraphs with the highest and lowest predicted ratings, respectively. In each subgraph, red nodes in the left are users, blue nodes in the right are items; the bottom red and blue nodes are the target user and item; the predicted rating and true rating (in parenthesis) are shown underneath. We visualize edge ratings using the color map shown in the right. Higher ratings are redder.}
  \label{vis1}
\end{figure}


















\section{Conclusion}
In this paper, we have proposed Inductive Graph-based Matrix Completion (IGMC). Instead of learning transductive latent features, IGMC learns local graph patterns related to ratings inductively based on graph neural networks. Compared to previous inductive matrix completion methods, IGMC does not rely on content (side information) of users/items. We show that IGMC has highly competitive performance compared to state-of-the-art baselines. In addition, IGMC is transferrable to new tasks without any retraining, a property much desired in those recommendation tasks having few training data. We hope IGMC can provide a new idea to matrix completion and recommender systems.

\subsubsection*{Acknowledgments}
The work is supported in part by the National Science Foundation under award numbers III-1526012 and SCH-1622678, and by the National Institute of Health under award number 1R21HS024581.





\bibliography{rs}
\bibliographystyle{iclr2020_conference}


\appendix
\section{Ablation studies}
In this section, we conduct ablation experiments to study the individual contributions of some components in IGMC. In particular, we are interested in: 1) whether the proposed pooling layer in Equation (\ref{pooling}) helps; 2) whether the proposed adjacent rating regularization (ARR) in Equation (\ref{arr}) helps; and 3) whether incorporating content can further improve IGMC's performance. Therefore, we compare the original IGMC with: 1) IGMC with SumPooling replacing the proposed pooling layer, 2) IGMC without ARR by setting  in (\ref{reg}) to 0, and 3) IGMC with content by concatenating target user and item's content feature vectors to the graph representation  before feeding into the MLP (\ref{mlp}), which is similar to \citep{berg2017graph}. The results are shown in Table~\ref{ablation}.



\begin{table}[h]
   \caption{RMSE test results of ablation experiments.}
     \label{ablation}
\begin{center}
\begin{tabular}{lllll}
    \toprule
    \textbf{Model}&\textbf{Flixster}&\textbf{Douban}&\textbf{YahooMusic}&\textbf{ML-100K}\\
    \midrule
    IGMC (original) & \textbf{0.872}0.001 & \textbf{0.721}0.001 & \textbf{19.1}0.138 & \textbf{0.905}0.001\\
    IGMC (SumPooling) & 0.8790.002 & 0.7290.003 & 22.91.102 & 0.9330.001\\
    IGMC (no\_ARR) & \textbf{0.872}0.001 & \textbf{0.721}0.001
 & 19.20.140 & 0.9080.001\\
    IGMC (content) & 0.8860.002
 & 0.7260.001  & \textbf{19.1}0.069 & 0.9060.001\\
  \bottomrule
\end{tabular}\end{center}
\end{table}

From Table~\ref{ablation}, we have the following observations. Firstly, using the proposed pooling layer shows a huge improvement over a standard SumPooling. This might be because SumPooling assigns equal importance to all nodes in a subgraph, which fails to distinguish the target user and item from the context nodes. This indicates that a pooling layer able to highlight the target user and item is important for IGMC.

Secondly, we can see that disabling ARR results in a 0.003 performance drop on ML-100K, while seeming to have no influence on the other three datasets. One possible explanation is that ARR is more useful for modeling large and dense enclosing subgraphs, since ARR enhances the modeling power by modeling the extra relationships between edge types in terms of their magnitude differences. Another possible reason is that we only tuned ARR's  on ML-100K and used  uniformly on all datasets. This is partly verified by that when increasing  to 0.1 for YahooMusic, we can further decrease IGMC's RMSE to 18.980.140. We did not fully verify this, and leave better ways of modeling rating magnitude for future study. 

Thirdly, we observe that incorporating content does not improve IGMC's performance on ML-100K, and often hurts the performance on the other datasets. For Flixster, Douban and YahooMusic, this phenomenon can be explained by that the content of these three datasets are user/item's respective graphs, which has little to no gains to a model that has already exploited graph structure information between users and items very well. In addition, the content feature vectors are presented in 3000-dimensional adjacency vectors, which might pose new problems due to their size and sparsity. For ML-100K, the lost of some performance when adding content actually contradicts with our initial experiments. In our initial experiments when the RMSE on ML-100K without content was around 0.910, we observed that adding content was indeed helpful and reduced the RMSE to 0.907. However, after we introduced ARR and redid the hyperparameter tuning, the RMSE of ML-100K without content became 0.905, and adding content no longer helped. We hypothesize that the benefits of content reduce with the better modeling of graph structure features.

The way we incorporate content might be another reason for why content is not useful in IGMC. In our experiments we only concatenate the target user and item's content vectors with the final graph representation output by the GNN, similar to \citep{berg2017graph}. However, this method fails to model the interactions between content and graph structures in the early graph convolution stage. On the other hand, as \citet{berg2017graph} and \citet{zhang2018link} found, directly concatenating content with initial node features (the one-hot encoding vectors) as the input to GNN often led to worse performance due to information flow bottlenecks. We leave exploring better ways to combine content and graph structures for future work.










\end{document}
