\documentclass[11pt]{article}
\usepackage[latin1]{inputenc}
\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{color}
\usepackage{vmargin}
\usepackage{multirow}
\usepackage{lscape}
\usepackage{verbatim}
\usepackage{amsthm, amssymb}
\usepackage{amsmath}
\newtheorem{Lem}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{Cor}{Corollary}
\newtheorem{Def}{Definition}
\def\polylog{\operatorname{polylog}}
\def\poly{\operatorname{poly}}
\def\dist{\operatorname{dist}}
\def\bdist{\operatorname{bdist}}
\def\refine{\operatorname{refine\_dist}}
\def\refinefurther{\operatorname{refine\_further}}
\def\even{\operatorname{even}}
\def\odd{\operatorname{odd}}
\def\comb{\operatorname{comb}}
\renewcommand\arraystretch{1.5}


\title{Approximate Distance Oracles with Improved Query Time}
\author{Christian Wulff-Nilsen
        \footnote{Department of Mathematics and Computer Science,
                  University of Southern Denmark,
                  \texttt{koolooz@diku.dk},
                  \texttt{http://www.imada.sdu.dk/cwn/}.}}

\date{}
\begin{document}


\maketitle
\begin{abstract}
Given an undirected graph  with  edges,  vertices, and non-negative edge weights, and given an integer , we show
that a -approximate distance oracle for  of size  and with  query time can be constructed in
 time for some constant .
This improves the  query time of Thorup and Zwick.
Furthermore, for any , we give an oracle of size  that
answers -approximate distance queries in  time.
At the cost of a -factor in size, this improves the  approximation achieved by the constant query time oracle of
Mendel and Naor and approaches the best possible tradeoff between size and stretch, implied by a widely believed girth conjecture
of Erd\H{o}s. We can match the  size bound of Mendel and Naor for any constant  and
.
\end{abstract}
\newpage

\section{Introduction}\label{sec:Intro}
The practical need for efficient algorithms to answer shortest path (distance) queries in graphs has increased significantly over
the years, in large part due to emerging GPS navigation technology and other route planning software.
Classical algorithms like Dijkstra do not scale well as they may need to explore the entire
graph just to answer a single query. As road maps are typically of considerable size, developing more efficient algorithms and data
structures has received a great deal of attention from the research community.

A distance oracle is a data structure that answers shortest path distance queries between vertex pairs in time independent of the size of the graph. A naive way
of achieving this is to precompute and store all-pairs shortest path distances in a look-up table, allowing subsequent
queries to be answered in
constant time. The obvious drawback is of course the huge space requirement which is quadratic in the number of vertices of the graph,
as well as the long time for precomputing all-pairs shortest path distances.

It is not difficult to see that quadratic space is necessary for constant
query time. It is therefore natural to consider \emph{approximate} distance
oracles where some error in the reported distances is allowed. We say that
an approximate distance  between two vertices  and 
in a graph  is of \emph{stretch}  if , where  denotes the
shortest path distance in  between  and . Awerbuch et
al.~\cite{Awerbuch98} gave for any integer  and a graph with  edges and  vertices
a data structure with stretch , space
, and preprocessing . Its query
time is  and therefore not independent of the size of
the graph. Stretch was improved to  by Cohen~\cite{Cohen98} and further to  by Matou\v{s}ek~\cite{Matousek96}.

In the seminal paper of Thorup and Zwick~\cite{ThorupZwick}, it was shown
that a data structure of size  can be constructed in
 time which reports shortest path distances stretched by a factor of at most  in  time. Since its query time is independent of
the size of the graph (when  is), we refer to it as an approximate distance
oracle. The tradeoff between size and stretch is optimal up to a factor of  in space, assuming a widely believed
and partially proved girth conjecture of Erd\H{o}s~\cite{Erdos}.

Time and space in~\cite{ThorupZwick} are expected bounds; Roditty Thorup, and Zwick~\cite{DetOracleSpanner} gave a deterministic
oracle with only a small increase in preprocessing.

Baswana and Kavitha~\cite{APASP} showed how to obtain  preprocessing for , an improvement for dense graphs.
Subquadratic time was recently obtained for  and ~\cite{SubquadraticOracleCWN}. P\u{a}tra\c{s}cu and
Roditty~\cite{Patrascu} gave an oracle of size  and stretch  for a graph with  edges.
Furthermore, they showed that a size  oracle with multiplicative stretch  and additive stretch  exists for unweighted
graphs. Baswana, Gaur, Sen, and Upadhyay~\cite{SubquadraticOracle} also gave oracles with both multiplicative and additive stretch.

Although the oracles above answer queries in time independent of the graph size, query time still depends on
stretch. Mendel and Naor~\cite{MendelNaor} asked the question of whether good approximate distance oracles exist with query time
bounded by a universal constant. They answered this in the affirmative by giving an oracle of size , stretch at
most , query time  and preprocessing time . Combining results of Naor and Tao~\cite{NaorTao} with Mendel and 
Naor~\cite{MendelNaor}
improves stretch to roughly ; according to Naor and Tao, with a more
careful analysis of the arguments in~\cite{MendelNaor}, it should be possible
to further improve stretch to roughly  but not by much more.
The  preprocessing time was later improved by Mendel and Schwob~\cite{CKR} to ; for an
-point metric space, they obtain a bound of .\footnote{I thank an anonymous referee for mentioning this improvement.}

We refer the reader to the survey by Sen~\cite{DistOracleSpannerSurvey} on distance oracles as well as the related area of spanners.

\paragraph{Our contributions:}
Our first contribution is an improvement of the query time of the Thorup-Zwick oracle from  to  without
increasing space, stretch, or preprocessing time. We achieve this by showing how to apply binary search on the bunch-structures,
introduced by Thorup and Zwick. Our improved query algorithm is very simple to describe and straightforward to implement.
It can easily be incorporated into our recent distance oracle~\cite{SubquadraticOracleCWN}, giving improved
preprocessing.

Our second contribution is an approximate distance oracle with universally constant query time whose size is 
and whose stretch can be made arbitrarily close to the optimal  (when ): for any positive
, we give an oracle of size , stretch ,
and query time . For  and constant , space can be improved to
, matching that of Mendel and Naor\footnote{This covers almost all values of  that are of interest
as the Mendel-Naor oracle has  space requirement for .}.
To achieve this result, the main idea is to first query the Mendel-Naor oracle to get an -approximate distance
and then refine this estimate in  iterations using the
bunch-structures of Thorup and Zwick. Our results are summarized in Table~\ref{tab:Oracles}.

Note that we are interested in non-constant  only; if , the Thorup-Zwick oracle is optimal up to constants
(assuming the girth conjecture) since it has size , stretch , and query time .

\begin{table*}
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
Stretch        & Query time & Space      & Preprocessing time      & Reference\\
\hline
 &  &  &  & \cite{ThorupZwick, SubquadraticOracleCWN}\\
\hline
 &  &  &  & This paper\\
\hline
 &  &  &  & ~\cite{MendelNaor,CKR}\\
\hline
 &  &  &
 & This paper\\
\hline
\end{tabular}
\end{center}
\caption{Performance of distance oracles in weighted undirected graphs.}\label{tab:Oracles}
\end{table*}

\paragraph{Organization of the paper:}
In Section~\ref{sec:Prelim}, we introduce notation and give some basic definitions and results.
Our oracle with  query time is presented in Section~\ref{sec:FasterQuery}. This is followed by
our constant time oracle in Section~\ref{sec:ConstQuery}; first we present a generic algorithm in
Section~\ref{subsec:Generic} that takes as input a large-stretch distance estimate and outputs a refined
estimate. Some technical results are presented in Section~\ref{subsec:MendelNaor} that will allow us to combine
this generic algorithm with the Mendel-Naor oracle to form our own oracle. We describe preprocessing and query in detail
in Sections~\ref{subsec:Preproc} and~\ref{subsec:Query} and we bound time and space requirements in
Section~\ref{subsec:TimeSpace}. In Section~\ref{subsec:FasterPreproc}, we show how to improve preprocessing compared
to that in~\cite{CKR}.
Finally, we conclude in Section~\ref{sec:ConclRem}.


\section{Preliminaries}\label{sec:Prelim}
Throughout the paper,  is an undirected connected graph with non-negative edge weights and with  edges and 
vertices. For , we denote by  the shortest path distance between  and .

Sometimes we consider list representations of sets. We denote by  the th entry of some chosen
list representation of a set , . For ,  is the base  logarithm of .

The following definitions are taken from~\cite{ThorupZwick} and we shall use them throughout the paper.
Let  be an integer and form sets  with
. For , set  is formed by
picking each element of  independently with probability . Set  has expected size  for
. For each vertex  and each ,
 denotes the vertex of  closest to  (breaking ties arbitrarily). Define a \emph{bunch}  as

where we let ; see Figure~\ref{fig:Bunch}.
\begin{figure}\centerline{\scalebox{1.2}{\begin{picture}(0,0)\includegraphics{Bunch.pstex}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(2524,2316)(5716,-14684)
\put(7917,-13721){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6354,-13035){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(7056,-13502){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} }}
\caption{A bunch  in a complete Euclidean graph with . Black vertices belong to
, grey vertices to , and white vertices to . Line segments connect  to
vertices of .}
\label{fig:Bunch}
\end{figure}

Thorup and Zwick showed how to compute all bunches in  time and showed that each of them has expected size
 for a total of . The following lemma states some simple but important results about bunches.
\begin{Lem}\label{Lem:SimpleProperties}
Let  be distinct vertices and let . If  then .
Furthermore, . In particular, .
\end{Lem}
Algorithm  in Figure~\ref{fig:Distk} is identical to the query algorithm of Thorup and Zwick except that we do not
initialize  but allow any start value. We shall use this generalized algorithm in our analysis in the following.
\begin{figure}
\begin{tabbing}
d\=dd\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\kill
\>\texttt{Algorithm} \\\\
\>1. \>; \\
\>2. \>while \\
\>3. \>\>\\
\>4. \>\>\\
\>5. \>\>\\
\>6. \>return 
\end{tabbing}
\caption{Answering a distance query, starting at sample level .}\label{fig:Distk}
\end{figure}



\section{Oracle with  Query Time}\label{sec:FasterQuery}
In this section, we show how to improve the  query time of the Thorup-Zwick oracle to . Let  be the
index sequence . The idea is to identify  subsequences
 of  in that order, where for
,
. Each subsequence  has the property that  applied to the
beginning of it outputs a desired -approximate distance in  time.
We apply binary search to identify the subsequences, with each step taking constant time. The final
subsequence  has  length and  is applied to it to compute a -distance estimate in 
additional time.

In the following, we define a class of such subsequences.
For vertices  and , an index  is \emph{-terminal} if
\begin{enumerate}
\item  (in which case ) or
\item  is even and either  or .
\end{enumerate}
Note that if an index  is -terminal,  terminates if it reaches  or .
We say that a subsequence  of  is \emph{-feasible} if
\begin{enumerate}
\item  is even,
\item , and
\item  is -terminal.
\end{enumerate}
The following lemma implies that  answers a -approximate distance query for  and 
when applied to a -feasible sequence.
\begin{Lem}\label{Lem:FeasibleApprox}
Let  be a -feasible subsequence. Then  gives a -approximate -distance
in  time.
\end{Lem}
\begin{proof}
The time bound follows since  is -terminal
and since each iteration can be implemented to run in constant time using
hash tables to represent bunches as in~\cite{ThorupZwick}.
The stretch bound follows from the analysis of Thorup and Zwick for their query algorithm: when , we have
 by
Lemma~\ref{Lem:SimpleProperties} and the triangle inequality. Hence,
each iteration of  increases  by at most . Since , we have at termination
that .
\end{proof}
\begin{Lem}\label{Lem:IFeasible}
 is -feasible for all vertices  and .
\end{Lem}
For each vertex  and , define .
The following lemma allows us to binary search for a -approximate distance estimate of .
\begin{Lem}\label{Lem:FeasibleRec}
Let  be a -feasible sequence and let  be even, .
Let  be an even index in subsequence
 that maximizes . If  and  then  is
-feasible. Otherwise,  is -feasible.
\end{Lem}
\begin{proof}
If  or  then  is -terminal. Since  is -feasible, so is
.

Now assume that  and . Then  and
 by Lemma~\ref{Lem:SimpleProperties}.
Applying the triangle inequality twice yields

so .

Let  be the set of even indices .
Since  is -feasible, . By the choice of ,

Hence, since  is -feasible, so is .
\end{proof}
We can now show our first main result.
\begin{figure}
\begin{tabbing}
d\=dd\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\kill
\>\texttt{Algorithm} \\\\
\>1. \>if  then return \\
\>2. \>let  be the middle even index in \\
\>3. \>let  be the (precomputed) even index in
        maximizing \\
\>4. \>if  and  then
       return \\
\>5. \>else return 
\end{tabbing}
\caption{Answering a distance query using binary search. The initial call
is . For correctness of the pseudocode, we assume here that . The call in line  is to  in Figure~\ref{fig:Distk}.}\label{fig:BDistk}
\end{figure}
\begin{theorem}\label{Thm:LogkQuery}
For an integer , a -approximate
distance oracle of  of size  and  query time can be constructed in
 time for some constant .
\end{theorem}
\begin{proof}
In order for -values to be defined, we assume that
; the result of the theorem is already known for  (in fact
for any constant ).
We obtain bunch  for each vertex  in a total of  time using the Thorup-Zwick construction.
The following additional preprocessing is done for  to determine the -subsequences of  that are needed. Let
 be the current sequence considered; initially, . Pick an even index
, , such that  and  have (roughly) the same size and
find an even index  in  which maximizes . Then recurse on subsequences
 and . The recursion stops when a sequence of length at most   is reached.
Below we show that these indices  can be identified in  time which is  over all .

Now, to answer a distance query for vertices  and , we do binary search on sequences
 generated; see Figure~\ref{fig:BDistk}. We start the search with  and check if
both  and . If so, we continue the search on subsequence .
Otherwise, we continue the search on . We stop when reaching a sequence of length at most .
By Lemmas~\ref{Lem:IFeasible} and~\ref{Lem:FeasibleRec}, this subsequence is -feasible.
Applying  to it outputs a -approximate distance estimate of  by
Lemma~\ref{Lem:FeasibleApprox}.

Binary search takes  time. Since we end up with a -feasible sequence of length at most , 
applied to it takes  time. Hence, query time is .

The oracle in~\cite{SubquadraticOracleCWN} with  preprocessing time
also constructs bunches and applies linear search in these to answer distance
queries in  time. Our binary search algorithm can immediately be plugged in instead.

It remains to bound, for each vertex , the time to identify the indices . Since sequence lengths are reduced by a factor of at least two in each
recursive step, simple linear searches will give all the indices in a total of  time. In the following, we improve this to .

Let us call a subsequence of  \emph{canonical} if it is obtained during the following procedure: start with the subsequence
 of  consisting of the even indices. Then find an index  that partitions  into two
(roughly) equal-size subsequences (both containing ), and recurse on each of
them; the recursion stops when a subsequence consisting of two indices is obtained. We keep a binary tree  reflecting the recursion,
where each node of  is associated with the canonical subsequence generated at that step in the recursion.
From this procedure, we identify (the endpoints of) all canonical subsequences in  time.
A bottom-up  time algorithm in  can then identify, for each canonical subsequence , an
index  in  that maximizes .

Now consider a (not necessarily canonical) subsequence  of  with indices  even. We can
find  canonical subsequences whose union is  as follows: let  and  be the leaves
of  associated with canonical subsequences  and , respectively. Let  be the path in  from the
parent of  to the parent of  and let  be the set of nodes in  having a parent in . Then it is
easy to see that the  canonical subsequences associated with nodes in  have  as their union.
It follows that finding the desired index  for  takes  time as it can be found among the -indices for canonical
subsequences associated with nodes in .

In our preprocessing for vertex , we only need to find -indices for  subsequences since
the recursion stops when a subsequence of length at most  is found.
Total preprocessing for  is thus , as desired.
\end{proof}

\section{Oracle with Constant Query Time}\label{sec:ConstQuery}
Let  be given. In this section, we show how to achieve stretch , query time
\footnote{Let .
Since  is concave, , which implies
.},
and space . Initially, we aim for a preprocessing bound of , matching that
in~\cite{MendelNaor}. In Section~\ref{subsec:FasterPreproc}, we improve this to the bound stated in
Table~\ref{tab:Oracles}.

We start with a generic algorithm, , to refine a distance
estimate. Later we will show how to combine this with the Mendel-Naor oracle.
We shall assume that  since otherwise, the oracle of the previous section can be applied.

\subsection{A generic algorithm}\label{subsec:Generic}
For a vertex  and a non-negative value , we define  as the largest even index
 such that .

Pseudocode of  can be found in Figure~\ref{fig:refine}.
\begin{figure}
\begin{tabbing}
d\=ddd\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\kill
\>\texttt{Algorithm} \\\\
\>1. \>\\
\>2. \>\\
\>3. \>if not  then return \\
\>4. \>\\
\>5. \>while  and
       \\
\>6. \>\>\\
\>7. \>\>\\
\>8. \>\>\\
\>9. \>\\
\>10.\>if  then\\
\>11.\>\>let  be an even index in 
         maximizing \\
\>12.\>\>if  then
         return \\
\>13.\>\>if  then
         return \\
\>14.\>if  then
       return \\
\>15.\>else return \\
\end{tabbing}
\begin{tabbing}
d\=ddd\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\kill
\>\texttt{Algorithm} \\\\
\>1. \>if  then\\
\>2. \>\>let  be an even index in 
         maximizing \\
\>3. \>\>if  or  then
         return \texttt{true}\\
\>4. \>if  or  then
       return \texttt{true}\\
\>5. \>else return \texttt{false}\\
\end{tabbing}
\caption{Algorithm  takes as input an -approximate -distance  and outputs
         a -approximate -distance.}\label{fig:refine}
\end{figure}
It takes as input an -approximate -distance  and outputs
a -approximate -distance. In line , it calls
subroutine  which checks a condition similar to that in Lemma~\ref{Lem:FeasibleRec}
to determine whether the initial estimate  is already a good enough approximation.
If so,  outputs this distance in line . Otherwise, it repeatedly refines the initial
estimate in the while loop in lines --. In each iteration, the estimate is reduced by a
factor of  and  is called to determine whether we can refine the
estimate further. If not, the while-loop ends and the refined estimate is output in lines
--. The while-loop also terminates after roughly  iterations since
then the refined estimate is small enough as the initial estimate is an -approximate
-distance. With the Mendel-Naor oracle, we can pick , giving only 
iterations. We will implement  so that each iteration takes  time, giving the
desired  query time.

The following lemma shows that  outputs the stretch we are aiming for.
\begin{Lem}\label{Lem:Generic}
For , , and , algorithm  outputs a
-approximate -distance if  is an -approximate -distance.
\end{Lem}
\begin{proof}
Initially, . If the test in line  of
 succeeds, i.e., if algorithm  returns \texttt{false}, then
since the test in line  of that algorithm fails, a telescoping
sums argument similar to that in the proof of
Lemma~\ref{Lem:FeasibleRec} implies
. Since also line
 fails, we have
.
Hence 
(note that  since  which implies  by
Lemma~\ref{Lem:SimpleProperties}). In the following, we can thus assume
that the test in line  of  fails.

We know that  returns \texttt{true} since  is the value of  in the iteration before the last.
Hence, if a distance is returned in line , . In particular, all distances returned are at least
.

Assume first that the while-loop ended because  returned \texttt{false}. Observing the following string
of inequalities in lines  to  will help us in the following:

We have . If lines  to  are executed then
. Thus,
if , a value of at most

is returned in line . If  and , Lemma~\ref{Lem:SimpleProperties} gives 
and

Furthermore, since  and , we have

Hence, a value of less than

is returned in line . The same argument as for line 
with  instead of  shows that the desired distance estimate is output
in line . If we reach line ,  and (as already observed) .
Then  and

so a value of at most

is returned in line .

Now assume that the while-loop ended with  returning \texttt{true}.
Then  iterations have been executed so
the final value of  is at most
. If the algorithm returns a value in line  then
this value is at most
.
If  and  then
 so a value of at most
 is returned in line
. Since , this gives the desired estimate. A similar argument gives the same estimate for lines  and .
This completes the proof.
\end{proof}

\subsection{Combining with the Mendel-Naor oracle}\label{subsec:MendelNaor}
Our oracle will query that of Mendel and Naor for a distance estimate and then give it as input to an efficient implementation of
. It is worth pointing out that any oracle with universally constant
query time and  stretch can be used as a black box and not just that
in~\cite{MendelNaor}; the only requirement
is that the number of distinct distances it can output is not too big; see
details below.

We will keep a sorted list of values such that for any distance query, the list contains
the  -values found in  as consecutive entries. We linearly traverse the list to
identify these entries some of which point to -indices needed by . These pointers together with some
additional preprocessing allow us to execute each iteration of the while-loop in  time.

We will ensure the property that the elements of the list are spaced by a factor of at least . For this we need a new definition.
Let  be a non-empty set of real numbers and let  be given. Define the \emph{-comb} of 
to be the set  of real numbers obtained by the iterative algorithm  in Figure~\ref{fig:comb}.
Lemmas~\ref{Lem:Comb} and~\ref{Lem:EpsilonComb} below show that the -comb of a certain superset of the set of
all distances that can be output by the Mendel-Naor oracle has the above property while not containing too many elements.
\begin{figure}
\begin{tabbing}
d\=dd\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\kill
\>\texttt{Algorithm} \\\\
\>1. \>let  be the largest element of \\
\>2. \>; \\
\>3. \>while \\
\>4. \>\>let  be the largest element of  and let  be
         the smallest element of \\
\>5. \>\>\\
\>6. \>\>\\
\>7. \>\>remove all the elements from  that have value
         at least \\
\>8. \>return 
\end{tabbing}
\caption{Algorithm that outputs the -comb  of a non-empty set  of real values.}\label{fig:comb}
\end{figure}
\begin{Lem}\label{Lem:Comb}
Let  be the -comb of a set . Then
\begin{enumerate}
\item for any , there is a unique  such that ,
\item any two elements of  differ by a factor of at least , and
\item .
\end{enumerate}
\end{Lem}
\begin{proof}
To show the first part,
define  to be the element  found in the th iteration of the while-loop. Define  and 
similarly. Now, let  be given. Since , there is an element of  which is at least .
Let  be the smallest such element and suppose for the sake of contradiction that .
Let  be the iteration in which  is added to . Since ,  for some 
so . After line  has been executed, every element of
 is strictly smaller than . Thus, . Since also
, it follows that
. But , contradicting the choice of .

We have shown that . To show uniqueness, let  be the first element added to 
for which . Assume for the sake of contradiction that . Then  was added
in a later iteration than  so ,
a contradiction. Thus, , showing uniqueness.

The second part of the lemma holds since in line ,  is the smallest element of  and the
next element  to be added to this set satisfies .

The third part of the lemma follows since in line ,
 and  and since at least one element (namely ) is removed from  in line  after
an element has been added to .
\end{proof}

For any vertices  and , denote by  the -distance estimate output by the Mendel-Naor oracle and let
 be the stretch achieved by the oracle, i.e., .
Let  be the set of all distances that the oracle can output.
\begin{Lem}\label{Lem:DMNBound}
.
\end{Lem}
\begin{proof}
The Mendel-Naor oracle stores trees representing certain ultrametrics. Each tree node is labelled with a distance and each
approximate distance output
by the Mendel-Naor oracle is one such label. Hence, since the oracle has size , so has .
\end{proof}
\begin{Lem}\label{Lem:EpsilonComb}
For each , let
 and let
 be the -comb of . Then for each ,
there exists a unique  such that  and
 for .
Also, .
\end{Lem}
\begin{proof}
The existence and uniqueness of  follows from  and from part
 of Lemma~\ref{Lem:Comb}. Define  and .
We use induction on  to show that . The base case  has
been shown since  so assume 
and that . Consider the iteration of
 following that in which  was added to . Here,
 since  and so ,
giving  which
is added to  in line . Hence, , completing the induction step.

For the last part of the lemma, since ,
Lemma~\ref{Lem:DMNBound} and part  of Lemma~\ref{Lem:Comb} give

\end{proof}

As mentioned earlier, certain elements of the -comb in Lemma~\ref{Lem:EpsilonComb} contain pointers to -indices.
These pointers are defined by the following type of map. For a set  of real values with smallest element , define
 by .
\begin{Lem}\label{Lem:tau}
Let  be a set of real values with smallest element  and let  .
If  are consecutive elements in  then  iff .
\end{Lem}

\subsection{Preprocessing}\label{subsec:Preproc}
We are now ready to give an efficient implementation of algorithm . We construct the Mendel-Naor oracle
and obtain the set . For each vertex , we construct bunch  and the set  of
values  for each . We represent  as a list sorted by increasing value. Furthermore,
we find a set  of real values as follows. For each index  of , subdivide interval
 into four even-length subintervals. We denote by  the set
of these subintervals over all  and form the set  of all their endpoints.
We obtain the -comb  as defined in Lemma~\ref{Lem:EpsilonComb} and
represent it as a sorted list. Then we form a set  of those 
for which  is either the smallest or the largest element that  maps to ; see Figure~\ref{fig:Pointers}.
\begin{figure}\centerline{\scalebox{1.0}{\begin{picture}(0,0)\includegraphics{Pointers.pstex}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFontNFSS\undefined \gdef\SetFigFontNFSS#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(6796,1583)(1786,-2425)
\put(2476,-2356){\makebox(0,0)[lb]{\smash{{\SetFigFontNFSS{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2476,-1906){\makebox(0,0)[lb]{\smash{{\SetFigFontNFSS{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1801,-1681){\makebox(0,0)[lb]{\smash{{\SetFigFontNFSS{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1834,-1013){\makebox(0,0)[lb]{\smash{{\SetFigFontNFSS{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2476,-1456){\makebox(0,0)[lb]{\smash{{\SetFigFontNFSS{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} }}
\caption{Sets , , , and  (ordered by increasing value from left
         to right) as well as the map  restricted to the subset  (white points) of
         . Elements of  represented by long line segments are those
         belonging to . For clarity, elements of each set  from Lemma~\ref{Lem:EpsilonComb}
         are evenly spaced in the figure.}
\label{fig:Pointers}
\end{figure}
With each , we associate the largest even index  such that
. For all , we leave
 undefined.

\subsection{Query}\label{subsec:Query}
To answer an approximate -distance query, we first obtain the Mendel-Naor estimate  and
identify the smallest element  of  which is at least .
This element is the input to  where .
By Lemma~\ref{Lem:EpsilonComb},  is an -approximate distance so the
output will be a -approximate distance.

It follows from Lemma~\ref{Lem:EpsilonComb} and part  of Lemma~\ref{Lem:Comb}
that all values of  in  are consecutive and start
from  in . Linearly traversing the list from  thus
corresponds to updating  in the while-loop.

We also need to maintain even index . Assume for now that for the initial , index
 is defined. Then the initial  is . As  is updated in the while-loop,
at some point it may happen that  is undefined. Let  be the last value encountered in the linear traversal
such that  is defined. Then  is the largest element in  that  maps to
 and  is larger than the smallest such element. Hence,
 and it follows from Lemma~\ref{Lem:tau} that  need
not be updated from the
value it had when  was encountered. Thus, maintaining  is easy, assuming its initial value can be identified.

What if  is undefined for the initial ? Then we move down the list 
until we find an index  that is defined. By Lemma~\ref{Lem:tau}, this index is the initial
value of  and we are done. The problem with this approach is that we may need to traverse a large part
of the list before the index can be found. We can only afford to traverse 
entries of . The following lemma shows that if the search has
not identified an index  after a small number of steps then our oracle can output twice the distance value
in the final entry considered.
\begin{Lem}\label{Lem:NoPointer}
For vertices  and , let  be the index of  such that
.
Assume that  is an index of  such that
 and  are undefined for all .
Then .
\end{Lem}
\begin{proof}
We have .
For each index  of ,  by
Lemma~\ref{Lem:EpsilonComb} and part  of Lemma~\ref{Lem:Comb}. Thus,

showing the second inequality of the lemma.

To show the first inequality, let  be the interval containing . Then it follows from
Lemma~\ref{Lem:tau} that  for every  satisfying the condition in the lemma.
Recalling our assumption , we get
 so

and since ,
 must have length . Let  be the index of  such that
interval  contains
. Since  is one of four consecutive subintervals of  of even length,  has length .
Also, .

Similarly, there is an index  of  such that
 has length
 and .



Let  be the final index of  (corresponding to a -query to the Thorup-Zwick oracle). Assume it is even
(the odd case is handled in a similar manner). Then
 for all even  (using an observation similar to that in
the proof of Lemma~\ref{Lem:FeasibleRec}). By the above,
. We also have
 for all odd  so again by the above,
. Finally, since ,

Thus,  and since  we have . Also,
 so since , we get .
We can now conclude the proof with the first inequality of the lemma:

\end{proof}

\subsection{Running time and space}\label{subsec:TimeSpace}
We now bound the time and space of our oracle.

\paragraph{Preprocessing:} Constructing the Mendel-Naor oracle takes
 time and requires  space. Traversing the nodes of the trees kept by
the oracle identifies all distances in time proportional to their number which by Lemma~\ref{Lem:DMNBound} is .
Sorting them to get the list representation of  then takes  time.

Forming a sorted list of the values from  in Lemma~\ref{Lem:EpsilonComb} can be done in
 time and requires
 space.
Clearly, when the input to  is given as a sorted list, the algorithm can be implemented to run in time linear in
the length of the list. Thus, computing a sorted list of the values of  can be done in
 time.

By the analysis of Thorup and Zwick, forming bunches  takes  time.
Since these bunches have total size
, sorted lists  can be found in  time. Sets  can be found within the
same time bound.

Forming -sets can be done by two linear traversals of the sorted list  of values from
. The first traversal visits elements in decreasing order. Whenever we encounter
a  from a set , let  be the previous visited element of  ( if no such element exists)
and let  be the latest visited element of . If ,
 is the smallest element of  that  maps to
 so we add  to . Otherwise we do nothing as  maps no element of
 to . The second traversal visits elements in
increasing order. When we encounter a , let  be the predecessor of  in  ( is no such element
exists) and let  be the latest visited
element of . Then, assuming ,  is the largest element that  maps
to  and so we add  to . Together, these two traversals form
all -sets in time .

Since each element of each set  is associated with at most two elements of , we get a
space bound of  for sets . In the two traversals, we can easily identify ,
, without an asymptotic increase in time. We represent each of
these index maps as hash functions in the same way as bunches  are represented in the Thorup-Zwick oracle. These hash functions
do not increase space.

\paragraph{Query:} To answer a -query, we need an efficient implementation of algorithm . The while-loop consists of
 iterations. Sub-routine  can be implemented to run in constant time assuming we have
precomputed, for each  and each even index , the even index  in  that maximizes .
This preprocessing can easily be done in  time. It then follows that  runs in  time
and we can conclude with our second main result.
\begin{theorem}\label{Thm:ConstQuery}
For any integer  and any , a -approximate distance oracle of  of size
 and query time 
can be constructed in  time. For  and constant , space can be
improved to .
\end{theorem}
\begin{proof}
We may assume that  since otherwise we can apply the Thorup-Zwick oracle or our  query time oracle.
Apply Lemma~\ref{Lem:Generic} and Lemma~\ref{Lem:NoPointer} with  instead of .
Then we get stretch , size , and query time .
This shows the first part of the theorem.

To show the second part, apply the first part with  instead of  and 
instead of , where  (we assume here for simplicity that  is an integer).
Then  so we get the desired stretch. Size is .
Letting , we have  so we get size  if
, i.e., if . The latter holds when .
\end{proof}

\subsection{Faster preprocessing}\label{subsec:FasterPreproc}
In this subsection, we show how to improve the  preprocessing bound in
Theorem~\ref{Thm:ConstQuery}. First, we can replace the Mendel-Naor oracle with that of Mendel and Schwob~\cite{CKR}.
This follows since the latter also uses ultrametric representations of approximate shortest path distances so the proof of
Lemma~\ref{Lem:DMNBound} still holds. This modification alone gives a preprocessing bound of .

Next, observe that our result holds for any -approximate distance  output
and not just for . More
precisely, let  be an integer. If  has stretch  then it follows from our analysis that
this estimate can be refined to  in  iterations and we get preprocessing
time  and query time .
In addition to this, we need to construct bunches and form sorted lists . As shown earlier, this can be done in
 time. Combining this with the above gives the following improvement in
preprocessing over that in Theorem~\ref{Thm:ConstQuery}.
\begin{theorem}
For any integers  and  and any , a -approximate
distance oracle of  of size  and query time 
can be constructed in 
time. For  and constant , space can be improved to .
\end{theorem}

\section{Concluding Remarks}\label{sec:ConclRem}
We gave a size  oracle with  query time for stretch -distances, improving the  query time
of Thorup and Zwick. Furthermore, for any positive , we gave an oracle with stretch  which answers
distance queries in  time. This improves the result of Mendel and Naor which answers stretch
-distances in  time.

For the first oracle, can we go beyond the  query bound? And can space be improved to ?
For the second oracle, can stretch be improved to  while
keeping  query time? To our knowledge, the oracle of Mendel and Naor cannot be used to produce approximate shortest
paths, only distances. Our second oracle then has the same drawback (due to Lemma~\ref{Lem:NoPointer}). What can be done to deal
with this?

\section*{Acknowledgments}
I thank anonymous referees for their comments and remarks that helped improve
the presentation of the paper.

\begin{thebibliography}{99}
\bibitem{Awerbuch98}
  B.~Awerbuch, B.~Berger, L.~Cowen, and D.~Peleg.
  Near-linear time construction of sparse neighborhood covers.
  SIAM J.~Comput., Vol. , No. , pp. --, .
\bibitem{SubquadraticOracle}
  S.~Baswana, A.~Gaur, S.~Sen, and J.~Upadhyay.
  Distance oracles for unweighted graphs: Breaking the quadratic barrier with constant additive error.
  In Proc.~th International Colloquium on Automata, Languages and Programming (ICALP), pp.~--, .
\bibitem{APASP}
  S.~Baswana and T.~Kavitha.
  Faster Algorithms for All-Pairs Approximate Shortest Paths in Undirected Graphs.
  SIAM J.~Comput., Vol.~, No.~, pp.~--, .
\bibitem{Spanner}
  S.~Baswana and S.~Sen.
  A Simple and Linear Time Randomized Algorithm for Computing Sparse Spanners in Weighted Graphs.
  Random Structures \& Algorithms,  (), pp.~--.
\bibitem{Cohen98}
  E.~Cohen.
  Fast algorithms for constructing -spanners and paths with stretch .
  SIAM J.~Comput., Vol.~, No.~, pp.~--, .
\bibitem{Erdos}
  P.~Erd\H{o}s.
  Extremal problems in graph theory.
  In Theory of Graphs and its Applications (Proc.~Sympos.~Smolenice, ),
  Czechoslovak Acad.~Sci., Prague, , pp.~--.
\bibitem{Matousek96}
  J.~Matou\v{s}ek.
  On the distortion required for embedding finite metric spaces into normed
  spaces.
  Isr.~J.~Math.~, pp.~--, .
\bibitem{MendelNaor}
  M.~Mendel and A.~Naor.
  Ramsey partitions and proximity data structures.
  Journal of the European Mathematical Society, (): --, . See also FOCS'.
\bibitem{CKR}
  M.~Mendel and C.~Schwob.
  Fast C-K-R Partitions of Sparse Graphs.
  Chicago J.~Theoretical Comp.~Sci., 2009 (2), pp.~--.
\bibitem{NaorTao}
  A.~Naor and T.~Tao.
  Scale-Oblivious Metric Fragmentation and the Nonlinear Dvoretzky Theorem.
  arXiv: .v [math.MG], .
\bibitem{Patrascu}
  M.~P\u{a}tra\c{s}cu and L.~Roditty.
  Distance Oracles Beyond the Thorup-Zwick Bound.
  In Proc.~st Annual IEEE Symposium on Foundations of Computer Science (FOCS), pp.~--, .
\bibitem{DetOracleSpanner}
  L.~Roditty, M.~Thorup, and U.~Zwick.
  Deterministic constructions of approximate distance oracles and spanners.
  L.~Caires et al.~(Eds.): ICALP , LNCS , pp.~--, .
\bibitem{DistOracleSpannerSurvey}
  S.~Sen.
  Approximating Shortest Paths in Graphs.
  S.~Das and R.~Uehara (Eds.): WALCOM , LNCS , pp.~--, .
\bibitem{ThorupZwick}
  M.~Thorup and U.~Zwick.
  Approximate Distance Oracles.
  J.~Assoc.~Comput.~Mach.,  (), pp.~--.
\bibitem{ThorupZwickSpanner}
  M.~Thorup and U.~Zwick.
  Spanners and emulators with sublinear distance errors.
  In Proc.~th ACM-SIAM Symposium on Discrete Algorithms (SODA), pp.~--, .
\bibitem{SubquadraticOracleCWN}
  C.~Wulff-Nilsen.
  Approximate Distance Oracles with Improved Preprocessing Time.
  In Proc.~rd ACM-SIAM Symposium on Discrete Algorithms (SODA), pp.~--, .
\bibitem{Zwick}
  U.~Zwick.
  All-pairs shortest paths using bridging sets and rectangular matrix multiplication.
  J.~Assoc.~Comput.~Mach.,  (), pp.~--.
\end{thebibliography}
\end{document}
