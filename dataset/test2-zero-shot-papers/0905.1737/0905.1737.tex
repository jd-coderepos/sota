\documentclass[11pt,envcountsame,oribibl]{llncs}

\long\def\commentWeizmann #1\commentWeizmannend{}


\usepackage[T1]{fontenc} 

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[dvips]{epsfig}
\usepackage{algorithmic}



\newcommand{\quod}{\hfill  \bigbreak}
\newcommand{\reals}{I\!\!R}
\newcommand{\np}{\mbox{{\sc NP}}}
\newcommand{\sing}{\mbox{{\sc Sing}}}
\newcommand{\con}{\mbox{{\sc Con}}}
\newcommand{\prob}{\mbox{Prob}}
\newcommand{\atm}{\mbox{{\sc ATM}}}
\newcommand{\hopn}{\hop_{\cN}}
\newcommand{\atmn}{\atm_{\cN}}
\newcommand{\cA}{{\cal A}}
\newcommand{\cO}{{\cal O}}
\newcommand{\cP}{{\cal P}}
\newcommand{\cR}{{\cal R}}
\newcommand{\cB}{{\cal B}}
\newcommand{\cL}{{\cal L}}
\newcommand{\cN}{{\cal N}}
\newcommand{\cU}{{\cal U}}
\newcommand{\cH}{{\cal H}}

\newcommand{\eps}{{\epsilon}}
\newcommand{\la}{{\lambda}}
\newcommand{\al}{{\alpha}}
\renewcommand{\mod}{\mbox{ mod }}



\newcommand{\cC}{{\cal \vec{C}}}
\newcommand{\suc}{\mbox{\em succ}}
\newcommand{\pred}{\mbox{\em pred}}

\newcommand{\epsFigi}[4]{\begin{figure}[#4] \begin{center} \input{#2}
    \caption{\label{#1}#3} \end{center} \end{figure}}
\newcommand{\epsFigii}[5]{\begin{figure}[#5] \begin{center} \epsfig{figure=#2,width={#4}}
    \caption{\label{#1}#3}  \end{center} \end{figure}}

\newcommand{\tenrm}{\rm}
\newcommand{\elvrm}{\rm}
\newcommand{\ninrm}{\rm}
\newcommand{\twlrm}{\rm}




\newtheorem{observation}[theorem]{Observation}

\newcommand{\hide}[1]{}   



\begin{document}




\title{{More efficient periodic traversal in anonymous undirected graphs}}
\author{
J.~Czyzowicz\thanks{\tiny D\'epartement d'Informatique,
                          Universit\'e du Qu\'ebec en Outaouais,
                          Gatineau, Qu\'ebec J8X 3X7, Canada.
                          E-mail: {\tt jurek@uqo.ca}.}
\and
S.~Dobrev\thanks{\tiny Institute of Mathematics,
                       Slovak Academy of Sciences,
                       Dubravska 9, P.O.Box 56, 840 00,
                       Bratislava, Slovak Republic.
                       E-mail: {\tt stefan@ifi.savba.sk}.}
\and
L.~G\k{a}sieniec\thanks{\tiny Department of Computer Science,
                              University of Liverpool,
                              Ashton Street, Liverpool, L69 3BX, United Kingdom.
                              E-mail: {\tt \{L.A.Gasieniec,Russell.Martin\}@liverpool.ac.uk}.
                              L.~G\k{a}sieniec partially funded by the
                              Royal Society International Joint Project, IJP - 2007/R1.
                              R.~Martin partially funded by the Nuffield Foundation
                              grant NAL/32566, ``The structure and efficient
                              utilization of the Internet and other distributed systems''.}
\and
D.~Ilcinkas\thanks{\tiny CNRS, LABRI, Universit\'e Bordeaux I,
                         33 400 Talence, France.
                         E-mail: {\tt \{david.ilcinkas,ralf.klasing\}@labri.fr.}
                         Supported in part by the ANR projects ALADDIN and ALPAGE,
                         the INRIA project CEPAGE,
                         and the European projects GRAAL and DYNAMO.}
\and
J.~Jansson\thanks{\tiny Ochanomizu University, 2-1-1 Otsuka,
                        Bunkyo-ku, Tokyo 112-8610, Japan.
                        E-mail: \texttt{Jesper.Jansson@ocha.ac.jp}.
                        Funded by the Special Coordination Funds for
                        Promoting Science and Technology.}
\and
R.~Klasing
\and
I.~Lignos\thanks{\tiny Department of Computer Science,
                       Durham University, South Road, Durham, DH1 3LE, UK.
                       E-mail: {\tt yannis.lignos@durham.ac.uk}.}
\and
R.~Martin\and
K.~Sadakane\thanks{\tiny Principles of Informatics Research Division,
                         National Institute of Informatics.
                         2-1-2 Hitotsubashi, Chiyoda-ku, Tokyo 101-8430, Japan.
                         E-mail: {\tt sada@nii.ac.jp}.}
\and
W.-K.~Sung\thanks{\tiny Department of Computer Science,
                        National University of Singapore,
                        3 Science Drive 2, 117543 Singapore.
                        E-mail: {\tt ksung@comp.nus.edu.sg}.}
}

\institute{}

\date{}
\maketitle
\def\thefootnote{\fnsymbol{footnote}}


\begin{abstract}
  We consider the problem of {\em periodic graph exploration} in which
  a mobile entity with constant memory, {\sl an agent}, has to visit
  all  nodes of an arbitrary undirected graph  in a periodic
  manner. Graphs are supposed to be anonymous, that is, nodes are
  unlabeled. However, while visiting a node, the robot has to
  distinguish between edges incident to it. For each node  the
  endpoints of the edges incident to  are uniquely identified by
  different integer labels called {\sl port numbers}. We are interested in
  minimisation of the length of the exploration period.

  This problem is unsolvable if the local port numbers are set
  arbitrarily, see~\cite{Bu78}. However, surprisingly small periods
  can be achieved when assigning carefully the local port
  numbers. Dobrev et al.~\cite{DJSS05} described an algorithm for
  assigning port numbers, and an oblivious agent (i.e. agent with no
  memory) using it, such that the agent explores all graphs of size
   within period . Providing the agent with a constant number
  of memory bits, the optimal length of the period was proved
  in~\cite{GKMNZ08} to be no more than  (using a different
  assignment of the port numbers). In this paper, we improve both
  these bounds. More precisely, we show a period of length at most
   for oblivious agents, and a period of length at most
   for agents with constant memory. Moreover, we give the first
  non-trivial lower bound, , on the period length for the
  oblivious case.
\end{abstract}








\section{Introduction}

Efficient search in unknown or unmapped environments is one of the
fundamental problems in algorithmics. Its applications range from
robot navigation in hazardous environments to rigorous exploration
(and, e.g., indexing) of data available on the Internet. Due to a
strong need to design simple and cost effective agents as well as to
design exploration algorithms that are suitable for rigorous
mathematical analysis, it is of practical importance to limit the
local memory of agents.

We consider the task of graph exploration by a mobile entity
equipped with small (constant number of bits) memory. The mobile
entity may be, e.g., an autonomous piece of software navigating
through an underlying graph of connections of a computer network.
The mobile entity is expected to visit all nodes in the graph in a
periodic manner. For the sake of simplicity, we call the mobile
entity an {\em agent} and model it as a finite state automaton. The
task of periodic traversal of all nodes of a network is particularly
useful in network maintenance, where the status of every node has to
be checked regularly.

We consider here undirected graphs that are anonymous, i.e., the nodes
in the graph are neither labelled nor colored. To enable the agent to
distinguish the different edges incident to a node, edges at a node
 are assigned {\em port numbers} in  in a
one-to-one manner, where  is the degree of node .

We model agents as {\em Mealy
  automata}. The Mealy automaton has a finite number of states and a
transition function  governing the actions of the agent.
If the automaton enters a node  of degree  through
port  in state , it switches to state  and exits the node
through port , where . The memory size of an
agent is related to its number of states, more precisely it equals the
number of bits needed to encode these states. For example an oblivious
agent has a single state, or equivalently zero memory bits. Note that
the size of the agent memory represents in this model the amount of
information that the agent can remember while moving. This does not
restrict computations made on a node and thus the transition function
can be any deterministic function. Additional memory needed for
computations can be seen as provided temporarily by the hosting
node. Nevertheless, our agent algorithms perform very simple tests and
operations on the non-constant inputs  and , namely equality
tests and incrementations.

Periodic graph exploration requires that the agent has to visit
every node infinitely many times in a periodic manner. In this
paper, we are interested in minimising the length of the
exploration period. In other words, we want to minimise the maximum
number of edge traversals performed by the agent between two
consecutive visits of a generic node, while the agent enters this
node in the same state through the same port.

However, Rollik~\cite{Rol80} proved that this problem is
unsolvable as an agent needs  memory bits to explore
all graphs of size , even restricted to cubic planar graphs. This
lower bound has been proved recently to be actually optimal by
Reingold in his breakthrough paper~\cite{Rein}. Providing the agent
with a pebble to mark nodes does not help much as the asymptotic size
of memory needed remains 
bits~\cite{FraIlcRajTix06}. In fact, even a highly-coordinated
multi-agent team capable of (restricted) teleportation cannot explore
all graphs with constant memory~\cite{CooRac80}.

Nevertheless, putting some information in the graph does help a
lot. Cohen et al.~\cite{CohFraIlcKorPel05} showed that putting two
bits of advice at each node allows to explore all graphs by an agent
with constant memory, by a periodic traversal of length , where  is the
number of edges. In fact, the impossibility results presented above
all use the ability of the adversary to assign the local port numbers
in a misleading order. On the other hand, even if nodes are not marked
in any way but if port numbers are carefully assigned (still
satisfying the condition that at each node , port numbers from 
to  are used), then a simple agent, even oblivious, can perform
periodic graph exploration within period of length . Using
appropriate assignment of the local port numbers, the best known
period achieved by an oblivious agent is ~\cite{DJSS05} whereas
the best known period achieved by an agent with constant memory is
~\cite{GKMNZ08}.


\subsection{Our results}

In this paper, we improve both
these bounds. More precisely, we present an efficient deterministic
algorithm assigning port numbers in the graph, such that, an oblivious
agent is able to accomplish each period of the traversal route in at
most .
Our algorithm uses a new three-layer partition of graphs permitting an
optimal time construction of the port labeling.
As a complement, we present a class of graphs in which an oblivious agent
performs a tour of at most .
In addition, we present another
algorithm assigning port numbers in the graph,
also using the three-layer partitioning approach,
such that, an agent with
constant memory is able to accomplish periodic graph exploration within period
at most .
Moreover, we give the first
non-trivial lower bound, , on the period length for the
oblivious case.


\subsection{Related Work}\label{Sec-Rel}
Graph exploration by robots has recently attracted growing
attention. The unknown environment in which the robots operate is
often modelled as a graph, assuming that the robots may only move
along its edges. The graph setting is available in two different
forms.

In~\cite{AlbHe00,BenFRSV98,BenSl94,DePa99,FT}, the robot explores
strongly connected directed graphs and it can move only in one
pre-specified direction along each edge.
In~\cite{AwBS99,BRS2,CohFraIlcKorPel05,DunKK01,FraIPPP04,FraIlcRajTix06,PanPe99}, the
explored graph is undirected and the agent can traverse edges in
both directions.
Also, two alternative efficiency measures are adopted in most papers
devoted to graph exploration, namely, the {\em time} of completing
the task~\cite{AlbHe00,AwBS99,BenFRSV98,BenSl94,BRS2,DePa99,DunKK01},
or the number of {\em
memory bits} (states in the automaton) available to the agent
\cite{CohFraIlcKorPel05,DiFKP02,FraIl04,FraIPPP04,FraIlcRajTix06,GPRZ07}.

Graph exploration scenarios considered in the literature differ in
an important way: it is either assumed that nodes of the graph have
unique labels which the agent can recognise, or it is assumed that
nodes are anonymous. Exploration of directed graphs assuming the
existence of labels was investigated in~\cite{AlbHe00,DePa99,FT}. In this
case, no restrictions on the agent moves were imposed, other than by
directions of edges, and fast exploration algorithms were sought.
Exploration of undirected labelled graphs was considered
in~\cite{AwBS99,AK,BRS2,DunKK01,PaPe}. Since in this case a simple
exploration based on depth-first search can be completed in time
, where  is the number of edges, investigations concentrated
either on further reducing the time for an unrestricted agent, or on
studying efficient exploration when moves of the agent are
restricted in some way.  The first approach was adopted in
\cite{PaPe}, where an exploration algorithm working in time
, with  being the number of nodes, was proposed.
Restricted agents were investigated in~\cite{AwBS99,AK,BRS2,DunKK01}. It
was assumed that the agent is a robot with either a restricted fuel
tank~\cite{AwBS99,BRS2}, forcing it to periodically return to the base
for refuelling, or that it is a tethered robot, i.e., attached to
the base by a ``rope'' or ``cable'' (a path from the original node)
of restricted length~\cite{DunKK01}. For example, in~\cite{DunKK01} it was
proved  that exploration can be done in time  under both
scenarios.

Exploration of anonymous graphs presents different types of challenges.
In this case, it is impossible to explore arbitrary graphs
and to stop after completing exploration if no marking of nodes is
allowed~\cite{Bu78}. Hence, the scenario adopted in~\cite{BenFRSV98,BenSl94}
was to allow {\em pebbles} which the agent can drop on nodes to
recognise already visited ones, and then remove them and drop in
other places. The authors concentrated attention on the minimum
number of pebbles allowing efficient exploration of arbitrary
directed -node graphs. (In the case of undirected graphs, one
pebble suffices for efficient exploration.) In~\cite{BenSl94}, the
authors compared the exploration power of one agent with pebbles to
that of two cooperating agents without pebbles. In~\cite{BenFRSV98}, it
was shown that one pebble is enough, if the agent knows an upper
bound on the size of the graph, and  pebbles
are necessary and sufficient otherwise.

In~\cite{CohFraIlcKorPel05,DiFKP02,FraIl04,FraIPPP04,FraIlcRajTix06},
the adopted measure of
efficiency was the memory size of the agent exploring anonymous
graphs. In~\cite{FraIl04,FraIlcRajTix06}, the agent was allowed to mark nodes by
pebbles, or even by writing messages on whiteboards with which nodes
are equipped. In~\cite{CohFraIlcKorPel05}, the authors studied special schemes
of labelling nodes, which facilitate exploration with small memory.
Another aspect of distributed graph exploration by robots with
bounded memory was studied in~\cite{DiFKP02,GPRZ07}, where the topology
of graphs is restricted to trees. In~\cite{DiFKP02} Diks {\em et al.}
proposed a robot requiring  memory bits to explore any
tree with at most  nodes. They also provided the lower bound
 if the robot is expected to return to its original
position in the tree. Very recently the gap between the upper bound
and the lower bound was closed in~\cite{GPRZ07} by G\k asieniec {\em
et al.} who showed that  bits of memory suffice in tree
exploration with return. However it is known, see~\cite{FraIPPP04}, that in
arbitrary graphs the number of memory bits required by any robot
expected to return to the original position is 
where  is the diameter and  is the maximum degree in the
graph. In comparison, Reingold~\cite{Rein} proved recently that , i.e., any decision problem which can be solved by a
deterministic Turing machine using logarithmic memory (space) is
log-space reducible to the USTCON (st-connectivity in undirected
graphs) problem. This proves the existence of a robot equipped with
asymptotically optimal number of  bits being able to
explore any -node graph in the perpetual exploration model, where
the return to the original position is not required. The respective
lower bound  is provided in~\cite{Rol80}.

In this paper, we are interested in robots characterised by very low
memory utilisation. In fact, the robots are allowed to use only a
constant number of memory bits. This restriction permits modelling
robots as finite state automata. Budach~\cite{Bu78} proved that no
finite automaton can explore all graphs. Rollik~\cite{Rol80} showed
later that even a finite team of finite automata cannot explore all
planar cubic graphs. This result is improved in~\cite{CooRac80}, where
Cook and Rackoff introduce a powerful tool, called the {\em JAG},
for Jumping Automaton for Graphs. A JAG is a finite team of finite
automata that permanently cooperate and that can use {\em
teleportation} to move from their current location to the location
of any other automaton. However, even JAGs cannot explore all
graphs~\cite{CooRac80}.


\section{Preliminaries}

\subsection{Notation and basic definitions}


Let  be a simple, connected, undirected graph.
We denote by  the symmetric directed graph obtained
from  by replacing each undirected edge  by two directed edges
in opposite directions -- the directed edge from  to  denoted by 
and the directed edge from  to  denoted by . For each directed
edge   or  we say that undirected edge  is
its {\em underlying} edge.
For any node  of a directed graph the {\em out-degree} of  is the number
of directed edges leaving , the {\em in-degree} of  is
the number of directed edges incoming to , and {\em cumulative degree}
of  is the sum of its out-degree and its in-degree.



Directed cycles constructed by our algorithm traverse some edges in 
once and some other edges twice in opposite directions.
However, at early stages, our algorithm for oblivious agents is solely
interested whether the edge is unidirectional or bidirectional,
indifferently of the direction. To alleviate the presentation (despite some
abuse of notation), in this context, an edge that is traversed once when
deprived of its direction we call a {\sl single edge}.
Similarly, an edge that is traversed twice is called a {\sl two-way edge},
and it is understood to be composed of two single edges (in opposite directions).
Hence we extend the notion of single and two-way edges to general directed graphs
in which the direction of edges is removed. In particular,
we say that two remote nodes  and  are connected by
a {\sl two-way path}, if there is
a finite sequence of vertices 
where each pair  and  is connected by a two-way edge, and
 and 
We call a directed graph  {\em two-way connected} if for
any pair of nodes there is a two-way path connecting them.
Note that two-way connectivity implies strong connectivity but not the opposite.



\subsection{Three-layer partition\label{s:3l-partition}}



The three-layer partition is a new graph decomposition method that we
use in to efficiently construct periodic tours in both the oblivious and
the bounded-memory cases.


For any set of nodes  we call the {\em neighborhood} of  the set
of their neighbors in graph  (excluding nodes in ) and we
denote it by .
One of the main components of the constructions of our technique
are {\em backbone trees} of , that is connected cycle-free subgraphs of .
We say that a node  is {\em saturated} in a backbone tree  of  if all
edges incident to  in  are also present in .

A {\em three-layer partition} of a graph  is a
4-tuple  such that
(1) the three sets ,  and  form a partition of ,
(2)  and ,
(3)  is a tree of node-set  where all nodes in  are saturated.
We call  the {\sl top layer},  the {\sl middle layer},
and  the {\sl bottom layer} of the partition. Any edge of 
between two nodes in  will be called {\sl horizontal}.

During execution of procedure {\sc 3L-Partition} the nodes in  are dynamically
partitioned into sets  and  with temporary contents, where  is the set of
saturated nodes,  contains nodes at distance 1 from ,
 contains
nodes at distance 2 from ,  contains nodes
at distance 3
from  and  contains all the remaining nodes in~.
\vspace*{-0.2cm}
\begin{tabbing}
xxx\=xxx\=xxx\=xxx\=xxx\=xxx\kill\\
{\bf Procedure} {\sc 3L-Partition}\\
(1) \>   \\
(2) \> select an arbitrary node \\
(3) \> {\bf loop}\\
\> (a)  (insert into  newly selected node);\\
\> (b) update contents of sets  and  (on the basis of new );\\
\> (c) saturate the newly inserted node  to  (i.e., insert
           all new edges to );\\
\> (d) {\bf if} the new node  in  was selected from  {\bf then}
           insert to  an arbitrary horizontal edge\\
\>\>\> (on middle level) to connect the newly formed star rooted
           in  with the rest of \\
\> (e) {\bf if} any new node  can be saturated {\bf then}
           select  for saturation;\\
\>\>\> {\bf else-if} any new node  can be saturated {\bf then}
           select  for saturation;\\
\>\>\>\> {\bf else-if}  is non-empty {\bf then} select a new 
           from  for saturation arbitrarily;\\
\>\>\>\>\> {\bf else} exit-loop;\\
\> {\bf end-loop}\\
(4) \> {\bf output} 
\end{tabbing}

\vspace*{-0.3cm}
\begin{figure}[htbp] \centering
   \includegraphics[width=4in]{3l-partition.eps}
   \caption{Three-layer partition. Solid lines and black nodes belong
   to the backbone tree .
   Dashed lines represent horizontal edges outside . Dotted lines
   are incident to nodes from }
   \label{fig:3l-partition}
\end{figure}




\begin{lemma}\label{lem:algo}
Procedure {\sc 3L-Partition} computes a three-layer
partition for any connected graph 
\end{lemma}

\begin{lemma}\label{lm:3-conditions}
The three-layer partition has the following properties:
\begin{description}
\vspace{-0.2cm}
\item[(1)] each node in  has an incident {\sl horizontal} edge outside of ;
\vspace{-0.2cm}
\item[(2)] each node in  has at least two neighbors in .
\end{description}
\end{lemma}
\begin{proof}
To prove property (1) assume, by contradiction, that there exists
a node  that has no horizontal edges outside of  Observe that
in this case  can be saturated , i.e.,  may be moved to 
inserting into  all remaining
edges incident to  Indeed, since before  was saturated all such edges lead only
to nodes in  their insertion does not form cycles. Thus property (1) holds.
Finally, assume there is a node  in  with no more than one incident edge leading
to level  Also in this case we can saturate  since all edges incident to 
form a star that shares at most one node with  Thus, no cycle is
created, which in turn proves property (2). \qed
\end{proof}







\begin{lemma}\label{lm:3layer-complexity}
For any graph  a three-layer partition may be computed in  time.
\end{lemma}


\subsection{RH-traversability and witness cycles}
In this section we discuss the conditions for the oblivious periodic
traversals. Given a port number assignment algorithm and an agent
algorithm, it is possible, for a given degree , to permute all port
numbers incident to each degree- node of a graph  according to
some fixed permutation , and to modify the transition function
 of the agent accordingly, so that the agent behaves exactly the
same as before in . The new transition function  is in this
case given by the formula  and
the two agent algorithms are said to be equivalent.

More precisely, two agent algorithms described by their respective
transition functions  and  are {\em equivalent} if for any
 there exists a permutation  on  such that
.

The most common algorithm used for oblivious agents is the
Right-Hand-on-the-Wall algorithm. This algorithm is specified by the
transition function . Differently
speaking, if the agent enters a degree- node  by port number
, it will exit  through port number .

The following lemma states that any couple consisting of a port number
assignment algorithm and an oblivious agent algorithm, and solving the
periodic graph exploration problem, can be expressed by using the
Right-Hand-on-the-Wall algorithm as the agent algorithm. We will thus
focus on this algorithm in all subsequent parts referring to oblivious
agents.

\begin{lemma}\label{lem:only-RH}
  Any agent algorithm enabling an oblivious agent to explore all
  graphs (even all stars) is equivalent to the Right-Hand-on-the-Wall
  algorithm.
\end{lemma}



Graph traversal according to the Right-Hand-on-the-Wall
  algorithm has been called {\em right-hand traversals} or shortly {\em RH-traversals},
see~\cite{DJSS05}. Similarly, cyclic paths formed in the graph according
to the right-hand rule are called {\em RH-cycles}.
The aim of our first oblivious-case algorithm is to find a short RH-traversal of the graph, i.e., to find a cycle  in
 containing all nodes of  and satisfying the
right-hand rule: If  and  are two
successive edges of  then  is the successor
of  in the port numbering of . We call such a
cycle a {\em witness cycle} for , and the corresponding port
numbering a {\em witness port numbering}.

Given graph  we first design , a
spanning subgraph of  that contains all edges of
a short witness cycle  of .
Then we look for port numbering of each node in
 to obtain . The
characterisation of such a graph  is not trivial,
however it is easy to characterise
graphs which are unions of RH-cycles.

\begin{definition} A node  is {\em RH-traversable}
in  if there exists a port numbering 
such that, for
each edge  incoming to  via an underlying
edge  there exists an outgoing edge  leaving~ via
the underlying edge , such that  is the successor of  in
the port numbering of~.

We call such ordering a {\em witness ordering} for .
\end{definition}


Let  be a spanning subgraph of . For each node ,
denote by ,  and  the number of two-way edges incident
to  used in  only incoming and only outgoing edges,
respectively.
The following lemma characterises the nodes of a graph being an union of RH-cycles.

\begin{lemma} \label{lm:RHchar}
A node  is RH-traversable if and only if  or .
\end{lemma}

\begin{proof}
 The definition of RH-traversability implies .

\noindent
 If  i.e., all edges incident to
 are used in two directions, any ordering of the edges is acceptable.
Otherwise (), choose a port numbering in which outgoing edges that contribute
to two-way edges are arranged in one block followed by an outgoing edge.
All remaining directed edges are placed in a separate block, in which
edges alternate directions and the last (incoming) edge precedes the block
of all two-way edges. \qed
\end{proof}

\vspace*{-0.15cm}
We easily obtain the following

\begin{corollary} \label{cor:RHchar}
A spanning subgraph  of  is a union of RH-cycles
if and only if each node  has an even number of single edges
incident to  in , and, in case no single
edge is incident to  in , all two-way edges
incident to  in  must be also present in .
\end{corollary}

In the rest of this section we introduce several operations on cycles,
and the conditions under which these operations will result in a witness cycle.



Consider a subgraph  of  that has only RH-traversable nodes.
Observe that any
port numbering implies a partitioning of  into a set of RH-cycles.
Take any ordering  of this set of cycles. We define two rules
which transform one set of cycles to another. The first rule, {\em Merge3},
takes as an input three cycles
incident to a node and merge them to form a single one. The
second rule, {\em EatSmall}, breaks a non-simple cycle into two
sub-cycles and transfers one of them to another cycle.



\begin{figure}
\begin{center}
\includegraphics[scale=0.76]{m3.eps}
\end{center}
\caption{(a) Applying rule {\em Merge3}; (b) applying rule {\em EatSmall}.\label{Fig:merge3}\label{Fig:eatSmall}}
\end{figure}

\begin{enumerate}


\item
{\bf Rule Merge3:} Let  be a node incident to
at least three different cycles ,  and . Let ,
 and  be the underlying edges at  containing incoming edges
for cycles ,  and , respectively ( and 
can be a single edge or a two-way edge in ). Suppose w.l.o.g.,
that  is between  and  in cyclic port numbering of . The port numbering
which makes the successor of  becomes the successor of
, the successor of  becomes the successor of  and the
successor of  becomes the successor of  and keeps the relative
order of the remaining edges the same (see Figure \ref{Fig:merge3}(a))
connects the cycles ,  and  into a single cycle , while
remaining a witness port numbering for  (due to the original port numbering).

\item
{\bf Rule EatSmall:} Let  be the smallest cycle in ordering  such that
\begin{itemize}
\item there is a node  that appears in  at least twice
\item there is also another cycle  incident to 
\item 
\end{itemize}
Let  and  be underlying edges at 
containing incoming edges for  and  respectively;
let  be the underlying edge containing the incoming edge by which
 returns to  after leaving via the successor of . If 
is the successor of , choose a different . Modify the ordering of
the edges in  as follows: (1) the successor of  becomes the
new successor of , (2) the old successor of  becomes the new
successor of , (3) the old successor of  becomes the new
successor of  and (4) the order of the other edges remains
unchanged -- see Figure \ref{Fig:eatSmall}(b).


\end{enumerate}




\begin{lemma}\label{lm:main}
Let  be a two-way connected spanning subgraph of  
with all nodes RH-traversable in  . Consider the set
of RH-cycles generated by some witness port numbering of its nodes,
with  being the largest cycle according to some ordering .
If neither {\em Merge3} nor {\em EatSmall} can be applied to
the nodes of  then  is a witness cycle.
\end{lemma}

\begin{proof}
Suppose, by contradiction, that  does not span all the nodes in .
Let  be the set of nodes of  not traversed by .
Since  is two-way connected there exist two nodes ,
such that  belongs to  and , and the directed edges 
and  belong to . Edges  and  cannot belong
to different cycles of  because {\em Merge3} would be applicable.
Hence   and  must both belong to the same cycle . However 
and  cannot be consecutive edges of  because this would imply 
which is not the case, since  also belongs to . Hence  must visit 
at least twice.
However, since  is the largest cycle we have 
and the conditions of applicability of rule {\em EatSmall} are satisfied with
 and . This is the contradiction proving the claim
of the lemma. \hfill \qed
\end{proof}






\section{Oblivious periodic traversal}

\noindent
In this section we describe the algorithm that constructs a short witness
cycle for graph . According to lemma~\ref{lm:main} it is
sufficient to construct a spanning subgraph  of 
which is two-way connected, such that,
each node of  is RH-traversable in . We will
present first a restricted case of a {\em terse set of RH-cycles}, when
it is possible to construct a spanning tree of  with no saturated
node. In this case we can construct a witness cycle of size .
In the case of arbitrary graphs, we need a more involved argument,
which will lead to a witness cycle of size . We
conclude this section with the presentation of
a lower bound of .

\subsection{Terse set of RH-cycles}

\noindent
Suppose that we have a graph , which has a spanning tree  with no saturated node.
This happens for large and non-trivial classes of graphs, including two-connected graphs,
graphs admitting two disjoint spanning trees, and many others. For those graphs we present
an algorithm that finds a shorter witness cycle than one that we can find for arbitrary
graphs. The idea of the algorithm is to first construct a spanning subgraph of 
 of size ,
which contains only RH-traversable
nodes (cf.\ algorithm \textsc{TerseCycles}). Then we apply a port numbering
which partitions  into a set of RH-cycles that can then
be merged into a single witness cycle (cf. Corollary~\ref{cor:TerseCycles}).

\smallskip\smallskip\smallskip
\noindent
{\bf Algorithm} \textsc{TerseCycles}:
\begin{algorithmic}[1]
\STATE Find  -- a spanning subgraph of  with no saturated nodes;
\STATE  \{each edge in  is a two-way edge
in \}
\STATE For each node  add to  a
single edge from  \{the single edges form a collection of stars \}
\STATE {\sc Restore-Parity}
\end{algorithmic}

\vspace*{0.2cm}
Procedure {\sc Restore-Parity}  has to assure that the number of single edges incident
to each node is even. The procedure visits each node  of the tree  in the bottom-up
manner and counts all single edges incident to  If this number is odd, the two-way edge
leading to the parent is reduced to a single edge (with the direction to be specified
later). The procedure terminates when the parity of all children of the root
in the spanning tree is restored. Note also that the cumulative degree of the
root must be even since
the cumulative degree of all nodes in  is even. Note also that no decision about
the direction of single edges is made yet.


\bigskip\noindent{\bf Procedure}
\textsc{RestoreParity}(directed graph  tree  node ): integer;
\begin{algorithmic}[1]
\STATE  (number of single edges in ;
\IF { is not a leaf in }
\FOR {each node  being a child of }
\STATE ;
\ENDFOR
\ENDIF
\IF {}
\STATE  reduce the two-way edge  to single;
\ENDIF
\STATE {\bf return} ;
\end{algorithmic}


\begin{lemma}
After the completion of procedure \textsc{TerseCycles}
every node of  is RH-traversable.
\end{lemma}
\begin{proof}
Every node is either saturated or it has at least
two single edges
incident to it. \qed
\end{proof}

\begin{corollary}\label{cor:TerseCycles}
For any graph  admitting a spanning tree , such that none of the nodes
is saturated (i.e.,  spans all nodes of ) it is
possible to construct a witness cycle of length at most 
\end{corollary}


Corollary~\ref{cor:TerseCycles} gives small witness cycles for a large class of graphs.
It should be noted for -regular graphs, finding a spanning tree having no
saturated nodes corresponds to finding a Hamiltonian path, a problem known to be
NP-hard even in this restricted setting~\cite{Garey}.

\subsection{Construction of witness cycles in arbitrary graphs}
\noindent
The construction of witness
cycle is based on the following approach. First select a spanning tree  of graph 
composed of two-way edges. Let , for  be the connected components
of , having, respectively,  nodes. For each such component we apply
procedure \textsc{3L-Partition}, obtaining three sets  and  and
a backbone tree . We then add single edges incident to the
nodes of sets  and , and we apply the procedure \textsc{RestoreParity}
to each component . We do this in such a way that the total number of edges in
 is smaller than . For the union of graphs
 we take a port numbering
that generates a set of cycles.
The port numbering and orientation of edges in the union of graphs is obtained as follows.
First we remove temporarily all two-way edges from the union.
The remaining set of single edges is partitioned into a collection of simple cycles,
where edges in each cycle have a consistent orientation. Further we reinstate all two-way
edges in the union, s.t., each two-way edge is now represented as two
arcs with the opposite direction. Finally we provide port numbers at each
node of the union, s.t., it is consistent
with the RH-traversability condition, see lemma~\ref{lm:RHchar}.
We apply rules {\em Merge3} and {\em EatSmall} to this set of cycles until neither rule
can be applied. The set of cycles obtained will contain
a witness cycle, using lemma~\ref{lm:main}.

\bigskip\noindent{\bf Algorithm} \textsc{FindWitnessCycle};
\begin{algorithmic}[1]
\STATE Find a spanning tree  of graph  \{two-way edges\}
\FOR {each connected component  of }
\STATE {\sc 3L-Partition};
\STATE Form set  by selecting for each node in  two edges
           leading to ; \{single edges\};
\STATE Form a set of independent stars  spanning all nodes in 
that are not incident to ; \{single edges\};
\STATE {\sc RestoreParity};
\ENDFOR
\STATE ; \label{witness-K}
\STATE Take any port numbering and produce a set
 of RH-cycles induced by it;
\STATE  Apply repeatedly {\em Merge3} or, if not possible, {\em EatSmall} to  until neither rule can be applied;
\STATE {\bf return} the witness cycle of ;
\end{algorithmic}

\begin{theorem}\label{th:4.3}
For any -node graph algorithm \textsc{FindWitnessCycle} returns a
witness cycle of size at most .
\end{theorem}


\begin{theorem} \label{th:complexity}
The algorithm \textsc{FindWitnessCycle} terminates in  time.
\end{theorem}

\subsection{Lower Bound}
We have shown in the previous section that for any -node graph we can construct
a witness cycle of length at most .
In this section we complement this result with the lower bound :

\begin{theorem} \label{th:lb}
For any non-negative integers ,  and  such that,  and 
there exists an -node graph for which any witness cycle
is of length .
\end{theorem}




\section{Periodic traversal with constant memory}

In this section we focus on the construction of a tour in arbitrary
undirected graphs to be traversed by an agent equipped with
a constant memory.
The main idea of the periodic graph traversal mechanism
proposed in \cite{Ilc06}, and further developed in \cite{GKMNZ08},
is to visit all nodes in the graph while traversing along an
{\sl Euler tour} of a (particularly chosen) spanning tree.
In \cite{Ilc06} the agent after entering a node  in the tree via port 
which always leads to the parent in the spanning tree,
visits recursively all subtrees accessible from  via ports
 where  is the number of children of 
When the agent returns from the last (th) child it either:
(1) returns to its parent via port 1, when  is also the degree of
 (i.e.,  is saturated in ); or
(2) it attempts to visit another child of  adopting the edge 
associated with port 
In case (2) the agent learns at the other end of  that the port number is
different from , i.e.,
the agent is not visiting a legal child of .
The agent first returns to  and
then immediately to
the parent of  where it continues the tree traversal process.
In these circumstances, the edge  is called a {\sl penalty edge}
since  does not belong to the spanning
tree and an extra cost has to be charged for accessing it.
Since the spanning tree
has  edges, and at each node the agent can be forced to examine a
penalty
edge, the number of steps
performed by the agent (equal to the length of the periodic tour)
may be as large as  ( edges of the spanning tree and 
penalty edges, where each edge is traversed in both directions).
The main result of \cite{GKMNZ08} is the efficient construction of a specific
spanning tree
supported by a more advanced visiting mechanism stored in the agent's memory.
They showed that the agent is able to avoid penalties
at a fraction of at least  nodes. This in turn gave the
length of
the periodic tour not larger than .

In what follows we show a new construction of the spanning tree, based
on the earlier three-layer partition. This, supported by a new labeling
mechanism together with slightly
increased memory of the agent, allows to avoid penalties at
 nodes resulting in a periodic tour of length

In the new scheme some leaves in the spanning tree are connected with
their parents
via port 2 (in \cite{GKMNZ08} this port is always assumed to be 1). The
rationale behind
this modification is to treat edges towards certain leaves as penalty
edges (rather than
the regular tree edges) and in turn to avoid visits beyond these leaves,
i.e., to avoid
unnecessary examination of certain penalty edges.

Recall that the nodes of the input graph can be partitioned into three sets
 and  where
all nodes in  and  are spanned by a backbone tree, see
section~\ref{s:3l-partition}.
The spanning tree  is obtained from the backbone tree by connecting
every node in 
to one of its neighbors in  Recall also that every node  is
{\sl saturated}, i.e.,
all edges incident to  in  belong also to the spanning tree.
Every node in  that lies on a path in  between two nodes in 
is called a {\sl bonding node}. The remaining nodes in 
are called {\sl local}.


\noindent
{\bf Initial port labeling}
When the spanning tree  is formed, we pick one of its leaves as the
root  where the two ports located on the tree edge
incident to 
are set to 1. Initially, for any node  the port leading to the parent
is set to 1 and ports
leading to the  children of  are set to  s.t., the subtree
of  rooted in child 
is at least as large as the subtree rooted in child  for all 
All other ports are set arbitrarily using distinct values from the range
 where  is the degree of 
Later, we modify allocation of ports at certain leaves of the spanning
tree located in 
In particular we change labels at all children having no other
leaf-siblings in  of bonding nodes
(see, e.g., node  in Figure~\ref{f:w1w2}), as well as in single
children of local nodes,
but only if the local node is the last child of a node in  that has
children on its own (see, e.g., node  in Figure~\ref{f:w1w2}).

\begin{figure}
\begin{center}
\includegraphics[width=5in]{3l-partition-tree.eps}
\end{center}
\caption{Fragment of the spanning tree with the root
located to the right of  and \label{f:w1w2}}
\end{figure}

\noindent
{\bf Port swap operation} Recall that every leaf  located at the
level  has also an incident edge  outside of  that leads to
some node  in 
(property 2 of the three-layer partition).
When we swap port numbers at , we set to 2 the port on the tree edge
leading to
the parent of  We call such edge a {\sl sham penalty edge} since it
now pretends
to be a penalty edge while, in fact, it connects  to its parent in
the spanning tree .
We also set to 1 the port number on the lower end of  All other port
numbers at 
(if there are more incident edges to ) are set arbitrarily.
After the port swap operation at  is accomplished we also have to ensure
that the edge
 will never be examined by the agent, otherwise it would be wrongly
interpreted as
a legal tree edge, where  would be recognised as the parent of 
In order to avoid this problem we also set ports at  with greater
care. Note that 
has also an incident horizontal edge  outside of 
(property 1 of
the three-layer partition). Assume that the node  has  children in
 Thus if we
set to  the port on  (recall that port 1 leads to the parent of  and
ports  lead
to its children) the port on  will have value larger than  and
 will never be accessed by the agent.
Finally note that the agent may wake up in the node with a sham penalty edge
incident to it.
For this reason we introduce an extra state to the finite state
automaton 
governing moves of the agent in~\cite{GKMNZ08} to form a new
automaton~.
While being in the wake up state the agent moves across the edge
accessible via port 1 in
order to start regular performance (specified in~\cite{GKMNZ08}) in a node
that is
not incident to the lower end of a sham penalty edge.


\begin{lemma}\label{l:newlabel}
The new port labeling provides a mechanism to visit all nodes in the graph
in a periodic manner
by the agent equipped with a finite state automaton .
\end{lemma}



\begin{theorem}\label{th:3.5n}
For any undirected graph  with  nodes, it is possible to compute
a port labeling such that
an agent equipped with a finite state automaton  can visit
all nodes in  in a periodic manner with a tour length that is no
longer than 
\end{theorem}


Note that in the model with implicit labels, one port at each node has
to be distinguished in order to break symmetry in a periodic order of ports. This is
to take advantage of the extra memory provided to the agent.

\section{Further discussion}
\label{s:conclusion}
Further studies on trade-offs between the length of the periodic tour and
the memory of a mobile entity are needed.
The only known lower bound  holds independently of the size of the
available memory, and it refers to trees.
This still leaves a substantial gap in view of our new  upper bound.
Another alternative would be to look for as good as possible tour
for a given graph, for example, in a form of an approximate solution. Indeed,
for an arbitrary graph, finding the shortest tour may correspond to
discovering a Hamiltonian
cycle in the graph, which is NP-hard.

\paragraph{Acknowledgements.}
Many thanks go to Adrian Kosowski, Rastislav Kralovic, and Alfredo Navarra
for a number of valuable discussions on the main themes of this work.




\nocite{}
\bibliographystyle{splncs}
\bibliography{biblio-periodic-explo}





\section{Appendix}

\subsection{An example of the 3L-Partition}
The example from Figure~\ref{fig:3par-ex} illustrates the procedure
{\sc 3L-Partition} for a graph in Fig.~\ref{fig:3par-ex}(-). The graphs
from Fig.~\ref{fig:3par-ex}(a) through Fig.~\ref{fig:3par-ex}(e) present
the configuration after
each iteration of the loop, when a new node is chosen for saturation,
and the sets  as well as the backbone tree  are
modified accordingly. The saturated
nodes are  and , chosen from different sets  and .
In all configurations except (-) the content of each set  is
represented at a different horizontal level.

\begin{figure}[htb] \centering
   \includegraphics[scale=.90]{3par-ex.eps}
   \caption{Example of functioning of procedure {\sc 3L-Partition}.
   Solid lines and black nodes belong to the backbone tree .}
   \label{fig:3par-ex}
\end{figure}
\subsection{An example of local port ordering}
\begin{figure}[htb] \centering
   \includegraphics[scale=0.80]{first.eps}
   \caption{Ordering two bidirectional, two incoming and two outgoing underlying edges.}
   \label{Fig:first}
\end{figure}



\subsection{An example of a port numbering which induces a union of RH-cycles}
One can verify, that
if we exchange any two labels of one of the degree-three
nodes of this graph, the three cycles would merge to a single witness cycle.

\begin{figure}[h]
\includegraphics{multiCycl.eps}
\centering
\caption{Each node is RH-traversable, but the witness
ordering of nodes define several cycles, i.e., no cycle spans the whole graph.}
\label{Fig:2cycl}
\end{figure}


\subsection{Proof of Lemma~\ref{lem:algo}}
We show that the procedure creates a three-layer partition with a
distinguished backbone tree .
Recall that the contents of sets  and  strictly depend on the content of 
New nodes are inserted to  gradually, one per {\sl round}, where each round
corresponds to a single execution of the main loop. We use the following
invariant. At the start of each round nodes in sets  and  are spanned by a partial
backbone tree  and a newly selected node for saturation is provided as . At the end
of the first round the invariant is satisfied since  contains only one node whose
neighbors in  form  (step 3b) and all edges incident to it belong to  (step 3c).
Assume now that
the invariant is satisfied at the beginning of some further round  When the newly
selected node  is inserted to  (step 3a) the content of other sets is recomputed
(step 3b). Note that  is always selected, s.t., adding all edges incident to  will
not form a cycle with edges in .
If  was chosen from  (this happens only
when  has no horizontal incident edges),  is already connected to  so all
incident edges to  (added in step 3c) will be connected to the rest of  too.
Alternatively, if  comes from  (this happens when all nodes in  have
horizontal edges outside of ) and  has exactly one neighbor 
as soon as all edges incident to  are inserted,
the new part of  gets connected to the old one via the node 
Finally, if  was selected in  (this happens when all nodes in  have
horizontal edges outside of  and all nodes in  have at
least two neighbors in ) then all edges incident to  are inserted to 
Note that when  was moved to  all its neighbors in  were
moved to  forming at least one new horizontal edge in  (formerly this edge
laid across sets  and ). We use this new horizontal edge to connect a newly
formed star with the remaining part of 
The procedure stops when it attempts to select a new node for saturation from an empty
set  meaning that all nodes from  are already distributed among  for which,
according to our invariant, the backbone tree  is already completed. \qed



\subsection{Proof of Theorem~\ref{lm:3layer-complexity}}
Each edge  is taken into consideration twice by the procedure, once
as the directed edge  and the other time as the directed edge . We prove
that for each directed edge the procedure performs a constant time task.

We suppose that each node of the graph is colored {\em red} when it has been already
tested for saturation (whether or not it was eventually included in set ) or
{\em green} otherwise. All nodes are initially colored green and put in set .
During the execution of step (e) of \textsc{3L-Partition} procedure a green node
 is selected for saturation from a set  or  (in that order). Depending
on the set to which belongs  and the sets to which belong all its neighbors 
passes or fails the saturation tests. In particular:
\begin{enumerate}
 \item If  then  becomes saturated (and promoted to ) if none of
 its neighbors belongs to .
 \item If  then  becomes saturated if only one of its neighbors
 belongs to .
 \item If  then  always becomes saturated.
\end{enumerate}
Moreover, each neighbor of , whether it is green or red, may be promoted to a
higher ranking set among  and  depending on the result of the saturation
of . This needs a second scan of the list of neighbours,
once the set into which  is put has been determined. Hence  is turned from
green to red as a result of a -time step. The \textsc{3L-Partition} procedure
terminates when all nodes are red so its overall complexity is . \hfill\qed

\subsection{Proof of Lemma~\ref{lem:only-RH}}

  Consider an arbitrary algorithm  enabling an oblivious agent to
  periodically explore all trees. Let  be its transition
  function. Fix an arbitrary  and let  be the function
   from  to , where
   is the single state of the oblivious agent. Consider the
  -node star of degree . For , let  be
  the leaf reachable from the central node  by the edge with port
  number .

  For the purpose of contradiction, assume first that  is not
  surjective. Let  be a port number without pre-image. If the agent
  is started by the adversary in node , with , then the
  node  is never explored. Therefore  is surjective, and
  thus a permutation of the set . Again for the purpose
  of contradiction, assume that  can be decomposed into more than
  one cycle. Let  be a port number outside 's orbit (i.e. 
  and  are not in the same cycle of the permutation). If the agent
  is started by the adversary in node , then the node  is
  never explored. Hence  is a cyclic permutation, i.e., it is
  constructed with a single cycle. Since the equivalence classes of
  permutations (usually called conjugacy classes) correspond exactly
  to the cycle structures of permutations, the agent algorithm 
  is equivalent to the Right-Hand-on-the-Wall algorithm.

\subsection{Proof of Corollary~\ref{cor:TerseCycles}}
Note that after the execution of procedure \textsc{TerseCycles}   each node
of  has an even number (different from zero)
of single edges incident to it. One can provide direction to all single
edges and port numbering at each node , s.t., all the edges
outgoing from and incoming to  belong to the same cycle. This is
done in two steps. First, the initial port numbering and
the direction of single edges are obtained via greedy selection of single
edges to form cycles. Later, if there is a node  that belongs to two cycles
(based on single edges), the cycles are merged at  via direct port number
manipulation. When this stage is accomplished, the set of nodes in 
is partitioned into components, with all nodes in the same component belonging
to the same cycle based on single edges.
Note also that each component is at distance one from some other component,
where the components are connected by at least one two-way edge (this is a
consequence of the fact that each node has at least two single edges
incident to it). The two-way edge is used to connect the components.
Connecting successively pairs of components at distance one we end up
with a single component, i.e., a witness cycle spanning all the nodes.
Note that for each single edge introduced to  a two-way edge
from the spanning tree is reduced to single during the restore parity process.
This happens because single edges form a collection of stars and
at least one endpoint of each single edge (in a star) is free.
Thus the number of all edges in the witness cycle is bounded by 
\hfill\qed


\subsection{Proof of Theorem~\ref{th:4.3}}
Since  from line~8 contains , it is a connected
spanning subgraph of .
For each such component we apply procedure \textsc{3L-Partition},
obtaining three sets  and , and a backbone tree
structure . By lemma~\ref{lm:3-conditions} we can add single edges
incident to the nodes in  and pairs of single edges incident
to the nodes in  and then apply procedure \textsc{RestoreParity}
to each component . Note that,
when each star  is constructed, we may do it in such a way that no
path of length three or more is created. Indeed, otherwise we could remove
a middle edge of any path of length three and the set of spanned
nodes would remain the same. Hence  is a forest of stars. Moreover we
can assume that only centers of such stars can be incident to edges forming 
otherwise any edge leading to a leaf node incident to  can be removed.
Consequently, after termination of the ``for'' loop, each
node of  is RH-traversable in . Moreover,
since ,  is two-way
connected, so the conditions of lemma~\ref{lm:main} are satisfied.
Hence, at the end of the algorithm  contains a witness cycle.
\noindent

In order to bound the size of the witness cycle we will bound the number
of edges in . Note first that  edges are used in 
(i.e.  two-way edges). Suppose first that for each component , containing 
nodes of , no single edges were added in lines 4 and 5,
that is  and .
Hence, the call of procedure {\sc RestoreParity}  from line 6 did not
modify . In consequence,  edges were added for 
or  in total. This value is maximized
for  giving  edges added in the ``for'' loop, and  total
edges in . The count remains the same if some ,
since exactly two edges were added for each node of  in line 4.
\noindent

Suppose now that , in line 5, for some components .
For each endpoint   of a star belonging to  and a single edge 
added for  in  in line 5, we check whether there is some other edge
that was reduced (from two-way to single) during the call of
procedure {\sc RestoreParity} in line 6. This happens when  is not
incident to a horizontal edge of the backbone tree , since one of
the edges incident to  will then become single. Thus the addition
of  is done at no extra cost, i.e., the total number of edges remains the same.
However, when
two endpoints of a horizontal edge are incident to two edges of , only
one such edge will be amortised. Consider then a collection of single horizontal edges,
belonging to the backbone tree  with edges of  incident to both of
their end-points.
The collection forms a forest. In each tree pick a root arbitrarily and
repeat the following
process until there is only one edge left in it. Take an arbitrary leaf and amortise
the edge of  incident to it with the tree edge leading to the parent of the leaf.
Remove the leaf and the edge that leads to its parent from further consideration.
Note that in this case amortisation is one to one. When this process is accomplished
each tree is reduced to one edge. In other words we have a collection of independent
single horizontal edges belonging to the backbone tree. Note that each such edge
is associated with two independent edges of . Clearly the worst case
happens when the forest was formed by independent single edges. This implies that the
number of such horizontal edges is not larger than .

Taking into consideration the maximal penalty that we have to pay for edges
added in line 5 of the algorithm, the number of edges forming  is
bounded by . \hfill\qed


\subsection{A lower bound example for the {\sc FindWitnessCycle} algorithm}
The example from Figure~\ref{fig:parachute} shows that the bound from
Theorem \ref{th:4.3} is tight (up to an additive constant) for our algorithm.
More precisely, the image shows that there exist graphs on which our algorithm
may produce a witness cycle of size .
\begin{figure}[!htb]
  \begin{center}
\includegraphics[width=11cm]{parachute}
\end{center}
  \caption{Example of a graph for which our algorithm
           gives a witness cycle of size not smaller than
           }
  \label{fig:parachute}
\end{figure}
The main part of the graph containing  nodes consists of  copies
of four nodes
, for , where the last node of
each but the last copy is identified with the first node of the next copy
(cf. Fig.~\ref{fig:parachute}). Moreover, an extra node  is
adjacent to each of the nodes ,
and a node  is adjacent to all other nodes in the graph.
Suppose that the star at node  is chosen by the algorithm
as the spanning tree , represented by the dotted edges in the
picture. The procedure {\sc 3L-Partition}  locates nodes
 in set  and
the nodes 
in set  (set  is empty). Suppose that the spanning tree is the
path  - represented by the solid edges in
Fig.~\ref{fig:parachute}. Since the algorithm adds one horizontal
edge for each node from class , all edges incident to 
are added to the structures. It is easy to see, that the parity
restoring procedure will chose the edges  as the single
edges of the structure. In consequence, only  dashed edges and  thin
solid edges in Fig.~\ref{fig:parachute} are chosen as single
edges --- all other edges (i.e.  dotted edges and
 bold solid edges) are taken as two-way edges. This results in
a witness cycle of size , i.e.\ containing
 edges.


\begin{figure}[htbp] \centering
   \includegraphics{lb.eps}
   \caption{The lower bound based on diamond graphs.}
   \label{fig:lb}
\end{figure}


\subsection{Proof of Theorem~\ref{th:complexity}}
In  time we can find a spanning tree  of  and the connected
components of . By lemma \ref{lm:3layer-complexity}, for each
connected component  having  nodes and  edges, the call of
the procedure {\sc 3L-Partition}  terminates in  time. The construction
of sets  in line 4 and set  in line 5 as well as the call of procedure
{\sc RestoreParity} in line 6 are completed in  time.
Altogether, the ``for'' loop terminates in  time. The construction
of  in line 8 and  in line 9 are done
in time proportional to their sizes, i.e., .

We show now that line 10, where the rules {\em Merge3} and {\em EatSmall} are
repeatedly applied, may be performed within  time. We chose any ordering
 of cycles and we attach to each edge a label corresponding to the cycle
to which the edge belongs. Let  be the largest cycle according to 
and  be any vertex of . We perform repeatedly rules {\em Merge3}
(resulting cycle obtaining rank of ) and  {\em EatSmall} to
vertex  until no longer possible. Each time we traverse the edges of
the cycle (or a part of the cycle) added to  and change their labels to .
When neither {\em Merge3} nor {\em EatSmall} is applicable to  we proceed to vertex 
- the actual successor of  in  - and repeat the procedure of applying rules
{\em Merge3} or {\em EatSmall} to . Although  changes dynamically and
some vertices may be traversed many times we end up by traversing all vertices
eventually in . By lemma~\ref{lm:main} at the end of this process
 becomes a witness cycle.
Note that the complexity of each {\em Merge3} and {\em EatSmall} operation is
proportional to the number of edges added to .
By theorem~\ref{th:4.3} the overall complexity of line 10 is . \hfill\qed



\subsection{Proof of Theorem~\ref{th:lb}}
Consider first a single {\sl diamond graph}  see left part of
Figure~\ref{fig:lb}. W.l.o.g., we can assume that we start the traversal
through . Consider the successor of . Also, w.l.o.g., we
can take  as the successor. Now there is only one feasible
successor of  and that is  All other edges violate
either RH-traversability () or leave  unvisited.
Similarly, the only possible successor of  is 
( has already been traversed with a different predecessor,
and  violates RH-traversability), of  is  and
of  is . Therefore, each edge of  must be used in
both directions.

Consider now a chain of diamond graphs from the right side
of Figure \ref{fig:lb}, starting the graph traversal at node .
From the fact that each edge in the witness cycle is traversed at
most twice (one time in each direction) it follows that when returning
from  to , all nodes in  (as well as in all 
for ) must have been visited.
Note that from RH-traversability it follows that the successor of
 cannot be the same (in reverse direction) as the
predecessor of , and similarly the successor of
 cannot be the same as the predecessor of .
In turn this means that the analogous arguments (as used in )
apply also to each , therefore all edges of  must be
traversed in both directions.

The theorem now follows directly for . If  is not a multiple of
, an extra path of  nodes can be added to  to satisfy the
claim of the theorem. \hfill\qed


\subsection{Proof of Theorem~\ref{l:newlabel}}
Note that it is enough to prove that no difficulty arises at nodes with
numbers affected by the modified labeling scheme.

\noindent
{\bf Case C1:}
Consider first the case when the port numbers are swapped at some node
 which is
a single child of a bonding node  (see Fig~\ref{f:w1w2}).
When during traversal the agent returns from the subtree rooted in a
child of  accessible
via port  it enters via port  the edge leading to  This edge
is interpreted as
a penalty edge and the agent after visiting  returns immediately to
 and then it goes
with no further action to the parent of  Note that if the labeling
was not changed the agent
would act similarly, however it would examine additionally a penalty
edge located at 
Thus thanks to the new labeling scheme we save one penalty at the node 


\noindent
{\bf Case C2:}
Consider now the second case when the port numbers are swapped at a
single child 
of a local node , s.t.,  has no siblings different from leaves
to its right (accessible via larger ports), see Fig~\ref{f:w1w2}.
Assume that  is the (saturated) parent of  and port
 at  leads to 
When during traversal the agent returns from the subtree
rooted in a child of  accessible via port  it enters via port
 the edge leading
to 
When it learns that
the port label at  is different from  it interprets the sham
penalty edge linking
 and  as the penalty edge. The agent returns immediately to 
while switching to the leaf recognition state ( would be interpreted as
the first leaf of ).
This means that all remaining leaves accessible from  (if any) will
be visited at no extra charge, i.e., without paying penalty at them.
Thus the agent does not miss the node  and it also saves penalty
at  and possibly at all leaves that are siblings of  \hfill\qed




\subsection{\bf Proof of Theorem~\ref{th:3.5n}}
The main line of the proof explores the fact that the fraction of nodes
at which the agent
manages to save on penalties is at least  The proof is
split into global
and local amortisation arguments.

\vspace*{0.2cm}
\noindent
{\bf Global amortisation} [saturated nodes amortise all bonding nodes
and single children
of saturated nodes]


Note that in a three-layer partition with  saturated nodes there are
at most  bonding nodes, since introduction of a new saturated node
implies creation of at most two bonding nodes.
Note also that there are at most  single leaves (with no siblings)
that are children of
saturated nodes. In the global amortisation argument we assume that at
these nodes, i.e., all bonding nodes and all single leaves of
saturated nodes, in the worst case the agent always pays
penalty (examines the penalty edge).
Fortunately, all of these  nodes ( bonding nodes and 
single leaves
of saturated nodes) can be amortised by  saturated nodes. Thus, as
required,
the fraction of nodes where the agent does not pay penalty is

For all other nodes in  we use the local amortisation argument.

\begin{figure}
\begin{center}
\includegraphics[scale=0.60]{3l-abcd.eps}
\end{center}
\caption{Local amortisation argument -- cases (a), (b), (c) and (d).\label{f:abcd}}
\end{figure}


\vspace*{0.2cm}
\noindent
{\bf Local amortisation} [direct amortisation of nodes within small
subtrees]


\noindent
The local amortisation argument is used solely on two-layer subtrees
accessible
from saturated nodes, i.e., formed of local nodes and (possibly) their
children,
cases (a), (b), (c), and (d), see Figure~\ref{f:abcd},
as well as on leaves accessible from bonding nodes, cases (e) and (f).



The local amortisation argument involving local nodes is split into cases
(a), (b), (c), and (d) in relation to the size of subtrees rooted in
local nodes.
We start the analysis with the largest subtrees in case (a) and gradually
move towards smaller structures in cases (b) and (c), finishing with single
local nodes in case (d).

\noindent
{\bf (a)} Consider any subtree  with at least two children rooted in
a local node. In this case the initial labeling remains unchanged.
During traversal of  the agent pays penalties at the local node and
at its
first child where it switches to the leaf recognition state. In this state
no further penalties at the leaves of  are paid.
Since the number of children  the fraction of nodes in the subtree
without penalties is at least 


\noindent
{\bf (b)} Consider now the case where a saturated node  has
at least two children (local nodes) with single children (two {\sl extended
leaves} according to the notation from~\cite{GKMNZ08})
accessible from . In this case the number of penalties
paid during
traversal of all extended leaves is limited to two since the penalties
are paid at
both nodes of the first extended leaf where the agent switches to
extended leaves
recognition state. The remaining nodes of the extended leaves are visited
at no extra cost.
In this case the fraction of nodes without penalties is at least



\noindent
{\bf (c)} Consider now the case where a saturated node has only one
extended
leaf (a local node  and its single child ) possibly followed by
some regular
leaves formed of local nodes. In this case the initial labeling is
changed and
the sham penalty edge  is introduced (case C1 in the proof of
lemma~\ref{l:newlabel}).
When the agent visits the extended leaf it enters the
sham penalty edge
interpreting it as the penalty edge. Thus the penalty is paid only at
the local
node  Moreover if  has sibling leaves all of them are visited at
no extra
cost since after visiting a sham penalty edge the agent is in the leaf search
state (\cite{GKMNZ08}).
Thus also in this case the fraction of nodes where the penalty is not paid
is at least 


\noindent
{\bf (d)} It may happen that a saturated node has several
children that
are leaves in  not preceded by an extended leaf. In this case the
penalty is paid
only at the first leaf and all other leaves are visited (in leaf search
mode)
at no extra cost.
(Recall that the case when a saturated node has only one child that is a
leaf in 
was already considered as a part of the global amortisation argument.)

The remaining cases of the local amortisation argument refers to the leaves
accessible via bonding nodes.

\noindent
{\bf (e)} When a bonding node has at least two children (all children
are leaves)
during traversal the agent pays penalty only at the first child while
all other children
are visited at no extra cost (thanks to the leaf search state).
Thus the fraction of nodes (leaves) where the penalty is avoided is at
least 


\noindent
{\bf (f)} Finally consider the case where a bonding node  has exactly
one child 
(case C2 from the proof of lemma~\ref{l:newlabel}).
In this case thanks to the sham penalty edge  no penalty is paid at 
i.e., the fraction of nodes without penalties is 

In conclusion, the fraction of nodes at which the penalty is avoided is
bounded
from below by  in all considered cases. Thus the number of
visited penalty
edges is bounded by  Since the number of edges in the
spanning tree is
 the agent visits at most  edges where each edge is
visited in
both directions. This concludes the proof that the length of the tour is
bounded by  \hfill\qed



\end{document}
