\documentclass{llncs}

\usepackage{amssymb}
\usepackage{graphicx}

\usepackage{amsmath}
\usepackage{amsfonts}

\usepackage{stmaryrd}

\usepackage{enumerate}

\usepackage{url}
 
\urldef{\mailpj}\path|petr.jancar@vsb.cz|
\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

\usepackage{dpda-macros}

\sloppy

\hyphenation{ana-lo-gous-ly ge-ne-ral re-gu-la-ri-ty bounded-ly
spe-ci-fied na-tu-ral-ly con-si-de-red stra-te-gy equi-va-len-ce
bi-si-mi-la-ri-ty re-pla-cing si-mi-lar-ly}

\begin{document}

\mainmatter  

\thispagestyle{plain}
\pagestyle{plain}

\title{Bisimulation Equivalence of
		First-Order Grammars\thanks{This paper extends the version
	contained in Proc. of ICALP'14.}}

	\author{Petr Jan\v{c}ar}


\institute{Dept Comp. Sci., FEI, Techn. Univ. of Ostrava
	(V\v{S}B-TUO),\\
	17. listopadu 15, 70833 Ostrava, Czech Rep.\\
\mailpj
}


\maketitle

\begin{abstract}
A decidability proof for bisimulation equivalence 
of first-order grammars
(finite sets
of labelled rules for rewriting roots of first-order terms) is
presented. The equivalence generalizes the  
DPDA
(deterministic pushdown automata) equivalence, and the result corresponds
to the result achieved by  S\'enizergues (1998, 2005) in the framework of
equational graphs, or of 
PDA with
restricted -steps. The framework
of classical first-order terms seems particularly useful for 
providing a 
proof that should be understandable for a wider audience.
We also discuss an extension to branching bisimilarity,
announced by Fu and Yin (2014).
\end{abstract}

\section{Introduction}\label{sec:intro}


Decision problems for  semantic equivalences 
have been a frequent topic in computer science. 
E.g.,
for pushdown automata (PDA) 
\emph{language equivalence} was quickly shown undecidable,
while 
the decidability in the case of deterministic PDA (DPDA) 
is 
a famous result 
by S\'enizergues~\cite{Senizergues:TCS2001}.
A finer equivalence, called \emph{bisimulation equivalence} or
\emph{bisimilarity}, has emerged as another fundamental behavioural
equivalence\,; for deterministic systems it essentially coincides with
language equivalence.
We name~\cite{BBK2} to exemplify the 
first decidability results for infinite-state systems,
and 
refer to~\cite{Srba:Roadmap:04} for a survey of a specific area.

One of the most involved results in the area~\cite{Seni05}
shows the decidability of bisimilarity
of equational graphs with finite out-degree
(or of PDA with deterministic popping
-steps); this generalizes the result for DPDA.
The recent nonelementary lower bound~\cite{BGKM12} for the problem
is, in fact, TOWER-hardness in the terminology
of~\cite{Schmitz2013}, and it holds
even for real-time PDA, i.e. PDA with no -steps. 
For the full above mentioned PDA 
the 
problem is even not primitive recursive, 
since it is Ackermann-hard~\cite{DBLP:conf/fossacs/Jancar14}.
In the deterministic case, the equivalence problem is known to be
PTIME-hard, and
has a primitive recursive upper bound shown 
by Stirling~\cite{Stir:DPDA:prim}; a finer analysis places
the problem in TOWER~\cite{DBLP:conf/fossacs/Jancar14}.
This complexity gap is just one indication that the respective
fundamental equivalence problems are far from being fully understood.
Another such indication might be the length and 
the technical nature of the so
far published proofs (including the unpublished~\cite{stirling-pda-00}).

This paper is an attempt to make a further step 
in clarifying the main decidability proof in the mentioned area.
It provides
a self-contained
decidability proof for bisimulation equivalence 
in labelled transition systems generated by \emph{first-order
grammars} (FO-grammars), which seems to be a particularly convenient
formalism. The states 
are here first-order terms over a
specified finite set of function symbols (or ``nonterminals''); the
transitions are induced by 
a finite set
of labelled rules that allow to rewrite the roots of terms.
This framework 
is equivalent
to the framework of~\cite{Seni05}; cf., e.g.,~\cite{CourcelleHandbook}
for the early references, or~\cite{JancarLICS12}
for a concrete transformation of PDA 
to FO-grammars (which is also given 
in Appendix here). 
The proof in this paper
is in principle based on the same high-level ideas as the proof
in~\cite{Seni05} but it is 
shorter and simpler; 
we do not provide a detailed comparison here.
This paper is also a (self-contained) continuation of~\cite{JancarLICS12}
where the first-order
term framework was used to give
a decidability proof in the deterministic case.


Related work is also discussed in
Section~\ref{sec:addrem}, where we address the extension of 
decidability to
branching bisimilarity, studied recently  
by Y. Fu and Q. Yin~\cite{yuxi-pdadecid-14}.

\begin{quote}
	{\small
		\emph{Remark.} Some parts are formatted as this
		remark; they contain additional details and comments.
		The aim of this paper
		is to make
		the proof easily understandable, not technically
		shortest.
	}
\end{quote}

\section{Preliminaries and Result}\label{sec:prelim}



In this section we define the basic notions and 
state the result.
Some standard definitions are restricted 
when we do not need the full generality.

By  we denote the 
set  of nonnegative integers; we use 
 to denote the set .
For a set , by  we denote the set of finite
sequences of elements of , which are also called \emph{words}
(over ).
By  we denote the
\emph{length} of 
. 
By  we denote the \emph{empty sequence}
(hence ).


\textbf{LTSs.}
A \emph{labelled transition system} (an LTS) 
is a tuple 
\begin{center}

\end{center}
where  is a \emph{finite or countable}
set of \emph{states},
 is a finite 
set of \emph{actions} (or \emph{letters}),
and  is a set of
\emph{-transitions} (for each ). 
In fact, we only deal with  
image-finite LTSs, where 
 is \emph{image-finite}
if the set  is finite for each 
pair , .  We say that  is 
a \emph{deterministic LTS} if for each pair 
,  there is 
 at most one  such that .

By , where 
,
we denote 
that there is a \emph{path}
;
if , then  
 is \emph{reachable from} , within  steps.
By  we denote that  is
\emph{enabled by} , i.e.,  for some .
A \emph{state}  is \emph{dead} if 
there is no  such that .

If  is deterministic, 
then by  or  we also denote the respective
unique path.
 
\textbf{(Stratified) bisimilarity.}
Let   be a given
LTS.
We say that a \emph{set}   
\emph{covers} 
 if 
\begin{itemize}
	\item		
for any  and  such that 
 there is 
such that
 and 
, and
\item
for any  and  such that 
 there is 
such that
 and 
.
\end{itemize}
We note that if  are dead states, 
then  is covered by any , 
in particular by .
If there is an action  that is enabled by precisely one
of , then   is not covered by
any .

For 
we say that  \emph{covers}  if 
covers each .
A set 
is a \emph{bisimulation} if  covers .
States  are \emph{bisimilar},
written 
,
if there is a bisimulation
 containing . 
We note the standard 
fact that 

is the maximal
bisimulation, the union of all bisimulations.


We put . For ,
 is the set of all pairs 
covered by . 
We easily verify that  and  are equivalence relations, and
that 
.
For the (first infinite) ordinal  we put 
 if  for all ; hence 
.
It is a standard fact
that
  is a bisimulation in any 
 image-finite LTS, where we thus have
.

\textbf{Eq-levels.} 
Given an image-finite LTS,
we attach 
the \emph{equivalence
level} (eq-level) to each pair of states:
\begin{center}
.
\end{center}




\textbf{First-order-term LTSs informally.}
We focus on certain (image-finite) LTSs in which states are
first-order terms\,; we mean standard finite terms primarily
but 
it will turn out convenient to consider also infinite regular terms
(i.e. infinite terms with only finitely many pairwise different subterms).
The terms are built from \emph{variables}
from a fixed countable set
\begin{center}

\end{center}
and from 
\emph{function symbols}, also called \emph{(ranked) nonterminals},
from some specified finite set ; each  has 
. We use   for
nonterminals, while  (possibly with subscripts etc.)
are reserved for terms.
\begin{figure}[t]
\centering
\includegraphics[scale=0.4]{basicterm.eps}
\caption{Syntactic tree of , and 
a graph presenting }
\label{fig:basicterm}
\end{figure}
An example of a (standard finite) term is  

where the arities of  are , respectively.
The left-hand side of Fig.~\ref{fig:basicterm} depicts the syntactic
tree of . (The right-hand side  will be referred to later.)


Transitions are determined by a finite set of 
\emph{root-rewriting} rules. 
An example of a ``non-popping'' rule 
is , an
example of a ``popping'' rule is .
Each rule induces the transitions arising by applying the same
substitution  to both the left-hand side (lhs) and the
right-hand side (rhs) of the rule. E.g., 
the rule  
\begin{center}
 and the substitution
 for which
,
,
 
\end{center}
(where
 after applying  becomes 
) induce the transition 
 depicted
in Fig.~\ref{fig:basictransition}.
\begin{figure}[t]
\centering
\includegraphics[scale=0.4]{basictransition.eps}
\caption{Transition generated by 
	 and  (in the
text)}
\label{fig:basictransition}
\end{figure}
Fig.~\ref{fig:basictransition} depicts an -transition between two states, where 
the states in our LTSs are terms.
The small symbols  are superfluous here, they just 
  depict the original variables in the lhs and in the rhs
of the respective rule; these variables have been replaced by applying
the substitution .
Hence  and  in the target-term have been replaced by the third root-successor and by the second
root-successor of the source-term, respectively. In this concrete case
the first root-successor of the source-term ``disappears'' since 
 does not occur in the rhs of the rule.

Another example can be given by the rule 
 and the above , which induces 
the transition, or the one-step path,
 where  and 
.
In this case our one-step path 
exposes a root-successor
 in the
source term 
(the first root-successor in our case);
the path has thus ``sinked'' to a subterm in depth .

\textbf{The result informally.}
We will show that there is an algorithm that computes
 when given a finite set of root-rewriting rules
and two terms .
In the rest of this section we formalize this statement,
 making also
some conventions about our use of (finite and infinite) 
terms and substitutions.

\textbf{Regular terms, presentation size.}
We identify terms with their syntactic trees, and denote them by
. Thus a \emph{term  over}
 (where  is a set of ranked nonterminals) 
is a rooted, ordered, finite or infinite tree where each node
has a label from ; if the label of a node is , 
then the node has no successors, and if the label is , then 
it has  (immediate) successor-nodes where .
More precisely, a term corresponds to a set of isomorphic trees, since
two isomorphic trees represent the same term.
Each node is also the root of a \emph{subterm} of , i.e., of the
subtree rooted in this node; more precisely, each concrete node 
is the root of a \emph{subterm-occurrence}, 
since a subterm corresponds to a set of isomorphic subtrees.
A subterm can thus have more (maybe infinitely
many) occurrences in . Each \emph{subterm-occurrence} has
its (nesting) \emph{depth in} , which is its (naturally defined) 
distance from the root of ; the term  itself is a
subterm-occurrence with depth .
E.g., in  
(in Fig.~\ref{fig:basicterm})
there 
is one occurrence of the
term , with depth , and two occurrences of , with
depths  and .

We also use the standard notation: a term is either  or
; if , then 
, , and
 are the \emph{root-successors}, i.e.,
the ordered subterm-occurrences with depth .

A \emph{term}  is \emph{finite} if the respective tree is finite; by
 we then mean the largest depth of a subterm-occurrence in . 
For 
in Fig.~\ref{fig:basicterm}
we thus have .

A (possibly infinite) \emph{term} is \emph{regular}
if it has only finitely many subterms (though the subterms may be infinite and
can have infinitely many occurrences). 
Any regular term has a natural \emph{finite-graph
presentation} (with possible cycles).
E.g., the right-hand side of Fig.~\ref{fig:basicterm} presents a
regular term ; here the term  itself is a subterm 
with infinitely many
occurrences (with depths ).
By  (the presentation 
size of
) we mean the size
of the smallest graph presentation of .

\begin{quote}
{\small
We can be more precise, though the respective notions are standard.
A \emph{finite-graph
presentation} of a (regular) term over  is a finite directed
(multi)graph, 
with a designated root,
where each node has a
label from ; if the label of a node is ,
then the node has no outgoing arcs, and if the label is  ,
then the node has  ordered outgoing arcs. 
The standard ``tree-unfolding'' of the graph is the respective term, 
which is infinite if there are cycles in the graph.
We can obviously effectively
compare if two graph presentations
represent the same term.
Given a presentation of a regular term , we can thus 
compute the \emph{syntactic graph of} , i.e., 
the graph whose nodes
(one-to-one) correspond to the (roots of) subterms occurring in .
(E.g., the syntactic graph of  in Fig.~\ref{fig:basicterm} arises from
the given graph presentation by merging the nodes with label 
and merging those with label ; but we note that if we replaced  with , we
\emph{could not} merge the nodes with label .)
We can take the number of nodes
of the syntactic graph of  as .
}
\end{quote}
In what follows, by a ``term'' we mean a ``regular term''
if we do not say explicitly that the term is finite.
(We do not consider non-regular terms.)
We reserve symbols , and also , for denoting
(regular) terms. 

\textbf{Substitutions, associative composition.}
By  we denote the set of all (regular) terms over
a set  of (ranked) nonterminals.
A \emph{substitution}  is a mapping
\begin{center}
 whose 
\emph{support}

\end{center}
is \emph{finite};
we reserve the symbol  for substitutions.
By  we mean the set .
By \emph{applying a substitution}  {to 
a term}  we get the term  
that arises from  by replacing each occurrence of  with
.
Hence  implies
; we \emph{prefer the
notation}
 to .

The 
\emph{composition of substitutions}, where
 satisfies
, 
can be easily verified to be
associative. We thus write simply  when meaning 
 or  . 

\textbf{First-order grammars.}
A \emph{first-order grammar}, an \emph{FO-grammar} or
just a \emph{grammar} for short, is a tuple
 where 

is a finite set of 
ranked \emph{nonterminals}, viewed as function symbols with
arities, 
is a finite set of \emph{actions} (or letters), 
and 
is
a finite set of 
\emph{rules} of the form
\begin{center}

\end{center}
where , , 
,
and  is a
\emph{finite}  
term over  
\emph{in which each occurring variable 
is
from the set} .






\textbf{Rule-based and action-based LTSs generated by grammars.}
Given , 
by 
we denote the (\emph{rule based}) LTS
where each rule  of the form
 
induces
	
for any substitution .
\\
(Hence also , due to 
with .)

\begin{quote}
{\small
Speaking in an informal 
``operational'' manner,
we can apply a rule  of the form  
to (a graph-presentation of)
 iff 
.
If so, and , then the
target of the -th outgoing arc of the root of 
(which might be the root itself in the case of a loop) is the root of 
 where .
If , we get  (for which )
by adding (a fresh copy of) 
to  where the root of  becomes the root of the arising ; 
to finish the construction of , 
each
arc in
 leading to a node labelled with  is redirected to 
the -th root-successor in . 
Hence the variables  in the rules serve just as
``place-holders'' for root-successors (in the source term of a
transition); recall again Fig.~\ref{fig:basictransition}.
}
\end{quote}
The LTS  is deterministic, since for each 
and  there is at most one  such that .
Hence , for , refers to a unique path in
 (which is later technically convenient).

\begin{quote}
{\small
We stress explicitly that \emph{transitions cannot add variables},
i.e.,  implies that
each variable occurring in  also occurs in  (though not vice
versa in general; recall that the first root-successor 
``disappeared'' by the transition in Fig.~\ref{fig:basictransition},
which also caused that the subterm  ``disappeared'').
We also note that   implies  for any
substitution ; this follows from the fact that  are dead,
 not enabling any action.
\\
Finally we observe that our stipulation that the 
right-hand sides (rhs)  in the grammar-rules

are finite implies
that
\emph{all terms reachable from a finite term} are \emph{finite}.
(It turns out technically convenient to have the rhs finite 
while including regular terms into our LTSs.)
}
\end{quote}
By the \emph{action-based} LTS, related to a grammar
,  
we mean the LTS  
where each rule 
induces  
\begin{center}
 
\end{center}
for any 
substitution 
.

Hence  in  implies 
  in , where
  is the naturally defined \emph{action-image} of :
the homomorphism  is defined by putting
 for any rule  of the form .

We note that  is image-finite,  
and nondeterministic in general.
In fact, we still \emph{complete the definition of} 
 \emph{by stipulating that}
\begin{center}
\emph{no  covers  or  
when
.}
\end{center}
We thus have that
\begin{center}
 implies , i.e., 
.
\end{center}
In particular we have
 for .
Technically we think of each used variable  
as being equipped with its unique action  and with the
transition  in ;
this entails that 
for 
without any special stipulation. 

\smallskip

\emph{Convention.}
Whenever we consider  in 
, we tacitly assume that no 
special transitions  are involved.
Hence  implies  for any substitution
. We also stipulate that 
covers , thus avoiding superfluous technicalities.


\begin{quote}
{\small
The stipulation  for 
reflects the fact that  implies that
 for
some , unless the underlying grammar 
is trivial.
The special transitions  are just one technical possibility 
how to reflect this fact in  smoothly.
}
\end{quote}
In what follows we refer to the action-based LTSs
, 
if we do not say explicitly that we have  in
mind. 

\begin{theorem}\label{th:bisdecid}
There is an algorithm that, given an FO-grammar
 and
,
computes  in  .
\end{theorem}	


\section{Proof of Theorem~\ref{th:bisdecid}}

We note that deciding  is trivial, since 
 holds for all .  
When having a procedure deciding , we can 
easily construct a procedure deciding ;
this follows from the facts that 
 iff  is covered by
, and that
for any  we can
construct all (finitely many) pairs  such that .
We thus get a part of 
Theorem~\ref{th:bisdecid}:

\begin{proposition}\label{prop:negatcase}
There is an algorithm that, given  and ,
outputs  if , and does not halt if
.
\end{proposition}
We need to modify the algorithm so that it recognizes the case 
 in
finite time.
As a convenient  tool
we introduce a round-based game between
Prover(she) and Refuter(he); 
the game is more involved than the standard
bisimulation game. 
We start with a simple first version of the game, and then we
 enhance it stepwise.
Refuter will be always able to force his win in finite time 
if the terms in the initial pair  are non-equivalent.
Prover will be always able to avoid losing if ,
but only in the
last game-version she will be able to force her win in finite
time. Since Prover's winning strategy for 
in the last game-version
will be finitely presentable and
effectively verifiable, a proof of  Theorem~\ref{th:bisdecid} will be
finished.
Before the first game-version we 
observe some simple standard facts related to
(stratified) bisimulation equivalence.


\textbf{Expansions.}
Assume an LTS .
By
\begin{center}
, where ,
\end{center}
we denote that  is a \emph{minimal expansion for },
i.e.,  
covers 
 and no proper subset of  covers ;
this also implies
that for each  there is 
such that  and  for some .
We note that , and
if  are dead (not enabling any action), then
.

For any  we have
 and we stipulate  .
We also 
stipulate , and define
.

\begin{proposition}\label{prop:simplecovering}\hfill\\
(1) If   then there is no  
such that  .
\\
(2) If  and  , then 
.
\\
(3) If  then there is  such that 
 and . 
(In particular, if  then  for
some .)
\\
(4) For  we have  iff there is a sequence
.
\end{proposition}
\textbf{Prover-Refuter game (first version).}
A play starts with a grammar
 and an \emph{initial pair}
 of terms.
For , the \emph{-th round} of the play
starts with some specified pair  and proceeds
as follows:

\begin{enumerate}
\item
Prover chooses  and some 
 for 
and shows that 
  
where .
\\
If this is impossible 
(i.e., if ), then Refuter
wins.
\item
Refuter chooses a pair  in 
. 
If this is impossible, i.e. 
if  (which includes the
case ),
then  Prover wins.
(In this case  , 
since   implies that 
,
by Prop.~\ref{prop:simplecovering}(2).)
\item
The pair  is taken for starting 
the -th round.
\end{enumerate}
\begin{figure}\centering
\includegraphics[scale=0.52]{roundsketch.eps}
\caption{Illustration of a game-round (where Prover has chosen )}
\label{fig:roundsketch}
\end{figure}
Fig.~\ref{fig:roundsketch} illustrates an -th round (with
).
Note that 
our requirement 
entails that there are  such that , , and , 
 (in ), as sketched in the
figure.
\begin{quote}
	{\small	
The reversals of  can be found by the ``bottom-up
approach'', starting from
  and going up to .
This follows from recalling that  implies that 
for each  there is  such that 
 and  for some .
}
\end{quote}
We also note that, e.g., 
for each  such that  in 
where  there is  and  such that 
, , ,
and .
\begin{quote}
	{\small	
This is also depicted in Fig.~\ref{fig:roundsketch}. When looking for
, we now use the
``top-down approach'' driven by .
}
\end{quote}
We say that \emph{Refuter} uses the \emph{least-eqlevel strategy}, if
he always chooses  so that 
; in this case 
,
and thus ,
unless  for all 
.
We easily observe the following facts.

\begin{proposition}\label{prop:firstgameanal}
	Let .
\\
1. If , then Refuter  wins within  rounds by 
the least-eqlevel strategy. 
\\
2. Prover can guarantee that she will not lose within  rounds.
\end{proposition}	




\smallskip

\textbf{Prover's additional tool.}
A challenge is to add sound possibilities for Prover to enable her to
force her win in finite time if .
We allow
Prover to claim a win 
when she can (soundly) demonstrate, in some -th round, 
that either Refuter has not used the least-eqlevel strategy 
or .
This new abstract rule does not
change Prop.~\ref{prop:firstgameanal}.
A simple instance 
is a \emph{repeat}: if 
 for some ,
then Prover can claim her win. 
(Equality  is another trivial example.)

We thus further assume that Prover wins when a repeat appears,
and we look at more involved options
enabling her to ``balance'', i.e., to replace
 (in the point  of a game-round)
with   that are 
``closer'' to each other, while 
keeping  
when Refuter
uses the least eq-level strategy.
Before formulating the second version of the game,
we clarify the crucial underlying facts. First a trivial one:

\begin{proposition}\label{prop:basicreplace}
Assume an LTS .
	If  and ,
then 
(since  and ). 
\end{proposition}


\textbf{Congruence, the crux of balancing.}
We assume a given grammar .
For substitutions
 and  we put
\begin{center}
 
if 
 for
each .
\end{center}
We also put
; hence
.
We now note that  and  are congruences:

\begin{proposition}\label{prop:congruence}\hfill\\
(1) If , then ;
hence .
\\
(2) If , 
then ; 
hence .
\\
Moreover, if  and
 (i.e., ),
then .
\end{proposition}	

\begin{proof}
(1) Suppose ; note that any pair , or ,
in 
must satisfy  (since otherwise it cannot be covered by our
definition of ).
For each  we put . We almost get
; just for the cases 
, , where 
  is not
 covered by , we complete  
 
 with some pairs of identical
 terms, using the fact that 
  for some ).

(2) Suppose , and take 
  where . 
Let .
For the cases , and thus 
, we complete 
  accordingly, using the fact that 
. If , then this procedure
is valid even when we 
start with
.
\qed
\end{proof}


\begin{quote}
{\small
\emph{Remark.}	
The compositionality induced by the congruence properties leads
naturally to considering the following modification of our game, based
on decompositions.
Prover is always allowed to 
``decompose'' , 
i.e., to present
some finite set

of pairs of terms that are in some sense smaller
than , if it is guaranteed that
; 
Refuter then chooses a pair from  for continuing.
If our measure of size satisfies 
that there are only finitely many pairs with the size 
that is smaller than or equal to the size of any given , then 
Refuter's least-eqlevel strategy still wins if the initial terms are
non-equivalent. On the other hand, if there is a bound such that each
pair  that is bigger than the bound is decomposable via a set
, then we have a required algorithm: 
if Prover keeps decomposing large pairs via subsets of , then we
get a repeat eventually. 

This is a basis of decision algorithms for so called BPA processes,
which can be viewed as being generated by FO-grammars where all
nonterminals have arity  (or ).
We can refer, e.g., to the
papers~\cite{DBLP:journals/iandc/ChristensenHS95,DBLP:conf/mfcs/BurkartCS95,Jan12b}
for details. 
However, in our more general case such a straightforward approach
does not seem clear. We follow a more involved way, based on a balancing
strategy that makes the component-terms in  
``close to each other''. 
We note that 
balancing strategies, in different frameworks, 
were used by 
S\'enizergues~\cite{Senizergues:TCS2001,Senizergues:TCS2002simple,Seni05}
and then Stirling~\cite{Stirling:TCS2001,Stir:DPDA:prim,stirling-pda-00}.
In fact, we will also discuss 
a bit of decomposition later, in Section~\ref{sec:addrem}.
}
\end{quote}
We now illustrate how Prover can use already the simple fact captured by
Prop.~\ref{prop:basicreplace}.
Suppose the -th round 
starts with  and Refuter chooses 
 in  (we refer to the notation in the game
definition, and to Fig.~\ref{fig:roundsketch}).
We thus have ,  in ,
for some , where   (and ).

Suppose that  is \emph{not a shortest path} from 
 to  (in );
then we have  for some  
where . As we already observed,  we then must also have 
 for some  and some  such that 
 
and .
(In Fig.~\ref{fig:roundsketch} we would have a respective pair
.)
We thus have   when  and Refuter uses the least-eqlevel strategy.

Therefore Refuter ``cannot protest'' when Prover puts
 instead of 
, since
 if Refuter uses the
least-eqlevel strategy.
We note that  are close to each other in the
sense that they are both reachable within  steps from one
``pivot term'', namely . 
We have , where generally we define 

In the second game-version below
we use the congruence properties
to enable
Prover to replace  with ``closer''
 even in some cases where  is
a shortest path from  to  and 
 is a shortest path from  to .


\smallskip

\textbf{Prover-Refuter game (second version).}
The only change w.r.t. the first game-version is in the
 point :
\begin{enumerate}[3.]
\item
	Prover creates  for the start of the 
	-th round:

	Either she puts ,
	thus making \emph{no change}, 
	or she can use one of the following options if available:
	\begin{enumerate}[i/]
		\item \emph{Left-balancing}:
Prover presents  as  for some \emph{finite
term}  and some substitution ,
where for each
 she finds  such that 
.
She defines  with 

as follows: if , then
, where  is an above found pair.
Finally she  puts 
.
\item
\emph{Right-balancing}:	
Symmetrically, Prover presents  as , 
finds all appropriate pairs
 in , 
and puts . 
\end{enumerate}
\end{enumerate}
Our previous illustration, where  
was not a shortest path from  to ,
was a special case:
we had  where ,  and 
, and we replaced  with 
 where  (and thus 

for all ).

Informally speaking, in the second game-version
Prover might replace the whole  with some  that
is ``shortly reachable from the pivot'' (if possible),
but she can also replace just
``small-depth'' subterms  of  with (sub)terms  that are
``shortly reachable from the pivot''; in the latter case some
``\emph{special finite head}''  of  remains. (The case of
right-balancings is symmetric.)

A left-balancing (with the pivot  and the bal-result 
)
is also depicted in the upper part of
Fig.~\ref{fig:tworounds}. (The lower part will be discussed later.)


\begin{figure}\centering
\includegraphics[scale=0.52]{tworounds.eps}
\caption{Two consecutive rounds, with a left-balancing in the first
one}
\label{fig:tworounds}
\end{figure}



\smallskip
We can easily verify that Prop.~\ref{prop:firstgameanal}
holds also for the second game-version. The crucial point is that
 when Refuter uses the
least-eqlevel strategy 
(this is based on Prop.~\ref{prop:congruence}(2) and 
Prop.~\ref{prop:basicreplace}).

\textbf{Bal-results are close to pivots.}
When doing a left-balancing, 
replacing 
 with 
the \emph{bal-result}
,
we might not have 
for the \emph{pivot} ,
 but we surely 
have
, for ,
where we generally extend the notation from~(\ref{eq:relclose})
as follows: 

the symbol \textsc{L} signals that we allow a special head
in the \emph{left}-hand component (here with the height at most ).
Symmetrically 
we define , 
where \textsc{R} refers to the right-hand component.

\smallskip

\textbf{Two remaining steps 
in the proof of Theorem~\ref{th:bisdecid}.}
 We first give an informal sketch, which is then formalized.
 We recall that a play of the Prover-Refuter game gives
rise to a sequence 

of pairs of terms that are the starting pairs for 
the rounds , respectively.

In the first of the remaining proof steps
(captured by Lemma~\ref{lem:forcingngseq})
we show that in the case  Prover can force a certain
potentially 
infinite -subsequence of , by a
simple balancing strategy.

In the second step
(Lemma~\ref{lem:realboundng}) we bound
the lengths of \emph{eqlevel-decreasing} -sequences.
It turns out that Prover can compute a respective bound
 on condition that she guesses correctly the pairs
of equivalent terms up to a certain (large) presentation size.

In the final game-version Prover wins if the length of a created
-sequence exceeds , but
Refuter's least-eqlevel strategy will be
still winning if Prover does not guess correctly when computing 
.



\textbf{Eqlevel-decreasing sequences, and -sequences.}
A \emph{sequence}  

of pairs of (regular) terms is \emph{eqlevel-decreasing} if 
. 
In this case the sequence must be finite, and our requirement
 implies that its length is
bounded by . 

Given a pair  where  and
 is a nondecreasing function
(where ), 
a (finite or infinite) sequence of pairs of terms
is an \emph{-sequence} if it can be presented as
\begin{center}

\end{center}
for a substitution 
with , where 
 for . 
(We put , say.)
Thus the growth of the (regular) ``head-terms''  is bounded by
the function , while at most  fixed 
``tail-subterms'' (of unrestricted
size)
suffice for this presentation.


\textbf{Prover can force an -subsequence by a balancing
strategy.}
We aim to prove Lemma~\ref{lem:forcingngseq}; the proof is the most
technical part of the paper, and we thus first 
explain the idea informally. 
Prover will use a simple balancing strategy, when starting with
:
\begin{itemize}
	\item		
In each round Prover chooses  (in the point  of
the game), where  is a sufficiently large constant computed from
the grammar ; she also uses only , thus
keeping  for all .
\item
Prover balances (in the point  of the second game-version),
e.g. by replacing  with  
 in the case of left-balancing,
\emph{only when} the respective \emph{special head  
has a bounded height}, bounded by some sufficiently large ;
the above
 was chosen sufficiently larger than .
\item
Obeying the above ``bounded-head'' condition, 
Prover balances in any round in which she has an opportunity,
but she has still another
constraint: \emph{Prover does not ``switch'' balancing sides
	in two consecutive
rounds}, i.e.,
if she does a left-balancing
in the -th round, then she cannot do a right-balancing 
in the -th round, and vice versa.
\end{itemize}
To sketch the idea why this strategy enables to present 
an infinite subsequence of  as
an -sequence, we first explore the case 
where Prover does a left-balancing in the -th round.
Hence we have 
\begin{center}

\end{center}
(using the notation in~(\ref{eq:closelh})), where  is the
respective pivot and  the respective bal-result;
this is also illustrated in Fig.~\ref{fig:tworounds}.


We have two possibilities for the following -th round:
\begin{enumerate}
	\item		
There is a left-balancing in the  -th round.
\\
The pivot of this balancing 
is , and we have 
 where
; hence  is ``boundedly reachable'' from  in this case. 

\item
Left-balancing (with a bounded head) is not possible
in the  -th round.
\\
Here we have ``no change'', i.e., 
, and we will derive that 
 
(using the notation in~(\ref{eq:relclose})).
Now the pivot  of the first next balancing in future
will be again reachable from ; maybe not boundedly reachable from  but
boundedly
reachable from a subterm of .
\end{enumerate}
The claims in the case  
are based on the fact that the impossibility to do a
left-balancing in the  -th round
entails that 
 the respective path 
 
is a shortest path from  to  and
is steadily ``sinking'' (or
``popping''), exposing deeper and deeper subterms of ; 
our choice of  and  will guarantee that
 
can be then written , 
thus ``erasing''  
and exposing some
 that is reachable from  within  steps;
this is depicted in Fig.~\ref{fig:tworounds}, where
.

A simple analysis now shows that
if there is no repeat in the sequence 
, then
there must be infinitely many balancing rounds, with the respective 
pivots denoted 
, 
while each concrete pivot can 
repeat only boundedly many times.
In the special ``pivot path''  which we
touched on (recall 
that  is boundedly reachable from a subterm of )
we then must have a deepest subterm  of ,
visited in some segment 
, written as 
,
such that the path 

does not visit any subterm of .
Then the sequence of
bal-results related to  
can be presented as an -sequence,
where  are determined by .

The proof of the next lemma just makes clear all relevant 
technical details.

\begin{lemma}\label{lem:forcingngseq}
There are  (, )
determined by (in fact, computable from) grammar
 such that Prover can force for any initial  that
she either wins or the sequence  has an
infinite -subsequence.
\end{lemma}	

\begin{proof}
We first introduce some technical notions related
to a given grammar ; 
in our notation we
assume that  for all .

If  in , then we call
 an  \emph{-sink word}.
We assume that for each pair  
,  there is a fixed 
shortest -sink word , and we put 
\begin{center}
.
\end{center}
The words  can be found and 

can be computed by a standard dynamic programming
approach.

\begin{quote}
{\small
We note that   if there is a rule
; otherwise
  where  is a shortest word such that 
  for a rule ; moreover, the path
  ``sinks'' along a branch in  till a leaf , and
 can be composed from the relevant shorter words
. Though  can be exponential (as demonstrated by the rules
), it can be
computed in polynomial time.

If we find that there are no -sink words for some , then 
the -th root-successor of any  plays no role
(i.e., its replacing does not change the equivalence class);  we
can then simply omit the -th root-successors when the root is .
We can thus 
decrease
, and modify the grammar rules accordingly
so that the LTSs   and  
do not change, up
to isomorphism. We can thus indeed safely assume that 
there are  for all ,
.
}
\end{quote}
A \emph{path}  in 
is \emph{root-performable},
if  where 
 
(in which case   is enabled by any term with the root ).
A \emph{path}  in 
is a \emph{non-sink segment}, a \emph{non-sink} for short,
if  and  is
root-performable.
(For each root-successor  in  we thus have
 for some  shorter than .)

A \emph{path}   in 
is \emph{sinking} if it contains no non-sink,
i.e., for any partition  with  we have 
 () where
 and  is a
root-successor in .
Hence if  is sinking, then 
 it can be written  where  and
  is a
subterm of  in depth at least .
(By  we denote integer division.)

Finally we consider a \emph{shortest path}
 \emph{from  to  that is not sinking}.
It can be written 
 where 
 is the last non-sink. 
We can easily check that then  where 
, for some  determined by ,
and  consists of the root-successors in .

\begin{quote}
	{\small	
To verify the claim, we first note 
that we cannot have 
where  is a root-successor in , since there would be a shorter
path  from  to  (for 
being
the relevant sink-word , satisfying ).
Hence   is root-performable, and we have
 where
 and
 consists of the root-successors in .
Since we took the last non-sink in ,
the path , and thus also 
,
is sinking after its first
step. Therefore  is reachable within less than  steps from a
subterm of the rhs  of a rule  in the set 
 of rules in the grammar . We can thus (generously) put
 where 
 there is a rule
 in .
}
\end{quote}
We now take  such that ,
and show Prover's strategy in the -th round, when starting 
with 
:
		\begin{enumerate}[i/]
	\item
		Prover chooses  
		and
		
		where		
		 (for all ).
		Refuter chooses  and 
		we can fix some paths 
, 
in ,
where ,  (recall again
Fig.~\ref{fig:roundsketch}).
	\item 
If  is not a shortest path from  to  or contains a non-sink,
and \emph{Prover did not do a right-balancing in the (previous) 
-th round}, then she makes 
a left-balancing, 
replacing  with 
, for some head  with the
		smallest possible height. 
		(We know that .)
	\item
If ii/ did not apply, and 
 is not shortest or contains a non-sink,
and Prover did not do a left-balancing in the 
		-th round, then she 
		makes 
a right-balancing, symmetrically to ii/. 
	\item
If none of ii/, iii/ applied, 
Prover 
puts .
\end{enumerate}
Before analysing the outcome of the strategy, 
we recall that each
bal-result  has its pivot , where
 
or 
(recall the definition in~(\ref{eq:closelh})),
and we explore the case when Prover  does a left-balancing 
in the -th round, with the pivot
,
but she cannot do a left-balancing (and thus any balancing) in the 
-th round, as depicted in Fig.~\ref{fig:tworounds}. (We omit the case with a right-balancing, since it
is symmetric.)

In the mentioned case we have
, 
where  and each  is reachable
from  within  steps.
Now 
the respective path  (created in the 
-th round) is sinking (and
shortest). But then   
 
as can be easily verified.
\begin{quote}
	{\small	
Indeed, 
we have chosen  large enough 
() so that the sinking path 
 can be written

(where ); informally, the path 
sinks along a branch of  until a leaf 
of  (where  hangs). Since 

is reachable from  within  steps, we have
 where .
On the other hand, our definitions yield 
that  for some words
 where each has the length . 
}
\end{quote}
We now
explore an infinite play from  where Prover uses the
above strategy. We first note that
there are \emph{infinitely many balancings};
otherwise from some round on we would have constant 
sinking on both sides, which necessarily leads to a repeat since our
terms are regular.
\begin{quote}
	{\small	
Suppose we have 

where all paths  (each of length )
are sinking. Then  is reachable from a subterm of  
in less than 
steps, and we can thus write   where 
and all  are subterms of .
Then the path  first sinks along a
branch of  until exposing a subterm of ; hence 
 is also reachable from a subterm of  
in less than  steps. Inductively we thus derive 
that each
 is reachable from a subterm of  in less than 
steps, hence all  range over a finite
set. (Similarly  
would range over a finite
set when there were only finitely many balancings.)
}
\end{quote}
We denote the pivots of our infinitely many balancings by
, and we easily verify
that for each  we have a path  
 (in )
of the form  

where  are bounded (surely by ) and 
 is a subterm of ; though  can be sometimes long (and
sometimes empty), we can
assume the path  to be sinking.

\begin{quote}
	{\small	
In the case of balancings in two consecutive rounds
(which are then both left-balancings, or both right-balancings), 
with pivots 
and , we have  where .
Suppose now two consecutive balancings, with pivots
 and 
that did not happen in two consecutive rounds, hence .
By our above analysis we have 
, and the strategy implies 
that we have either

or  where each (sub)path 
, or
,
has length  and is sinking.
Similarly as previously, we derive that  is reachable in
less than  steps from a subterm of either  or
.
		}
	\end{quote}
Suppose now that the ``pivot path''
\begin{center}

\end{center} 
visits
subterms of  infinitely often.
Then the pivots  are
infinitely often boundedly reachable from a subterm of ,
as follows
from the form~(\ref{eq:consecpivots})
of paths . In this case one
pivot reappears infinitely often;
but there
are boundedly many bal-results for one pivot, and we would thus have a repeat.
\begin{quote}
	{\small	
Recall that the bal-result  related to pivot  satisfies
 or 
(as defined in~(\ref{eq:closelh})); hence we have boundedly many
possible  for one .
		}
	\end{quote}
Some segment  thus visits a subterm
of , denoted by , for the last time. 
Hence ,
and 
the infinite path  is
root-performable; for  we have

Hence  and 
() for
 whose range consists of the root-successors in . 
We also note that
 can only boundedly grow (with
growing ).
\begin{quote}
	{\small	
		By the form of the paths~(\ref{eq:consecpivots}),
		we know that 
		 is boundedly reachable from a
subterm of ; to be more precise, 
is reachable within  steps from a subterm of a term that is
reachable within  steps from . Hence we surely have
 where 
 there is a rule
 in .
Since , we have 
\\
.
}
\end{quote}
We are interested in the bal-results related to 
, i.e.,
to , 
, , . 
Since the bal-result

related to  satisfies 

or ,  
it is built from some finite bounded ``head-terms'', and some
``tail-terms'' that are subterms of  in depth at most
. 
\begin{quote}
	{\small	
A path  obviously cannot ``expose'', i.e.  ``sink to'',
a subterm of  that is deeper than .
}
\end{quote}
It is useful to rather write  

for a finite term  in which each branch has length 
if it is not a complete branch of , and where  consists
of the subterms of  with depth . 
\begin{quote}
	{\small	
To get  and , for each particular 
occurrence of a subterm  of  that has depth
 in  we do the following:
we replace this occurrence of  with a fresh variable  and
we put . The resulting term  is a finite term with
, and
 consists of at most  variables,
where  is the maximum arity of noterminals of the grammar .
Putting 
\begin{center}
,
\end{center}
we get 
.
}
	\end{quote}
Recalling~(\ref{eq:Arootperform}) and~(\ref{eq:VAF}), we have
	\begin{center}
		
\end{center}
where 
,
,
and 
each
occurrence of  in  has depth at least
 (for ).
The bal-result  related to  (satisfying

or ) can be thus written
\begin{center}
 
\end{center}
for finite terms  whose
height, and thus also size,
can only boundedly grow with growing 
(since  can only boundedly grow with growing ).

\begin{quote}
{\small	
	If  (in ) 
	where ,
	then  where , since 
	the subterm-occurrences with depth at least  in 
	 need at least  steps for being exposed.
Moreover,  (where  bounds the 
height-increase in one step).
	
Recall that  entails 
, and 
 where  and 
 for each
.
Hence each term from the set  
can be written in the form
 for some  with 
.
Therefore we can write  and 
where the height of  and of each 
is bounded by .
Finally we put . Hence
, and we surely have

where  is the maximal arity of nonterminals and
.
Since  and
, we get
\begin{center}
a function , determined by the grammar , 
\end{center}
for which 
, for .
}
\end{quote}
Hence  the bal-results related to the pivots
, i.e.,
to , 
, , , can be presented as   an -sequence
\begin{center}
, 
\end{center}
where  that are determined by the
grammar . 
\qed
\end{proof}




\textbf{The lengths of eqlevel-decreasing -sequences are
bounded.}
Before proving Lemma~\ref{lem:realboundng}
we show
some useful facts and convenient notions, assuming a grammar
.
We first recall that ,
and note: 

\begin{proposition}\label{prop:bisimgetequation}
If 
(where )
then 
there are , ,
and , where , such that
,  or , , and
.
\end{proposition}

\begin{proof}
We take 
,
so that  for all .
(Recall Prop.~\ref{prop:simplecovering}.)
When trying to mimic this sequence by replacing 
 with the empty-support substitution and aiming to create
,
we must get  or  with 
in some  for 
(instead of the original pair  or
), 
since 
otherwise we would prove .
Since  for the respective , we surely have
.
\qed
\end{proof}

By  we denote the substitution that (only) replaces  with
 (i.e.,  and 
  for .
 Hence  

is the substitution  satisfying  and
 for all .
We note that the (``limit'' regular) term

is well defined and satisfies :
a graph presentation of  arises from
a graph presentation of  by redirecting each arc leading to  (if
there is any) towards the root. (We have  if  does not
occur in , or if .) Hence also
.
E.g., for the terms in Fig.~\ref{fig:basicterm} we have
.




By  we denote the substitution arising
from  by removing  from the
support (if it is there), i.e., 
\begin{center}

\end{center}
	If , then  does not occur in 
	defined by~(\ref{eq:Hprime}); we then have
, and this enables an inductive argument 
in the proof of Lemma~\ref{lem:realboundng}, based on stepwise
decreasing the substitution support (i.e., the number  in
eqlevel-decreasing -sequences).

Recalling that  iff 
for all , and referring
to  in~(\ref{eq:Hprime}), we also note the following fact
(which follows from the congruence properties,
by a  repeated use of Prop.~\ref{prop:congruence}(2)):

\begin{proposition}\label{prop:congrlimit}
If  
and ,
then . 	
\end{proposition}	

\begin{proof}
Assume ; hence  does not occur in
, and we also recall that , and .

For  we obviously have 
.
Hence we will be done if we show that 
,
i.e., if we show that

Let
; this can be also written 
.

If , 
then~(\ref{eq:ELHHprime}) is clear.
If , then 
\begin{center}

\end{center}
(where the inequality ``'' follows from
Prop.~\ref{prop:congruence}(2)).
Thus ,
and~(\ref{eq:ELHHprime}) follows
by Prop.~\ref{prop:basicreplace}.
\qed
\end{proof}

\begin{quote}
	{\small
		\emph{Remark.}
We discussed a possible decomposition approach after noting the
congruence properties (Prop.~\ref{prop:congruence}). Now
		Propositions~\ref{prop:bisimgetequation}
		and~\ref{prop:congrlimit} also suggest a certain
decomposition approach, as we now sketch. 

Suppose we have . We can present  as
 in many ways. 

E.g., if  and
 then we can put , 
 (assuming ), and
for  we define  to be the -th
root-successor in 
and  to be the -th
root-successor in .

For  where  there
are
two possibilities:
\begin{enumerate}
	\item		
either , in which case  for any
,
	\item
or .
\end{enumerate}
In the case  we must have   and , where  or  , 
such that 
\begin{center}

\end{center}
(by Prop.~\ref{prop:bisimgetequation} and~\ref{prop:congrlimit}), and
thus  where
\begin{center}
 and .
\end{center}

We can even bound the size of , and thus of , as follows:
,
where  is defined in~(\ref{eq:defsizeinc}). 

We also note that for any  where 
(and maybe ), we have 
\begin{center}
,
\end{center}
which can lead to a decomposition if the pairs
,  are somehow
``smaller'' than .

Moreover, in the case   we can
continue in the same way as above:
\begin{enumerate}
	\item		
either , in which case  for any
,
	\item
or .
\end{enumerate}
In the latter case we get some  and some
 such that  or  , and 
 where
 and , for
.

Continuing this reasoning, we must come to the case  after at most
 iterations where , maybe with the
empty-support substitution in the end.

A problem is to define an adequate size of the pairs, to transform the above
observations into a sound algorithm based on the respective
decompositions. In the algorithm based on our Prover-Refuter game we
circumvent this problem; we use the above observations
for a (conditional, nondeterministic)
computation of a bound on eqlevel-decreasing -sequences.
	}		
\end{quote}	
We still add a few technical notions, useful for proving
Lemma~\ref{lem:realboundng}. For our assumed grammar
 we put 
	
We note that  implies .

For any set  we put 
\begin{center}
,
\end{center}
stipulating .
( has been already defined.)

For any , we put
\begin{quote}
, and
\\
.
\end{quote}
We note that  is always a \emph{finite} number.

For any  and
 we define 
by the following recursive definition:
\begin{quote}
, and
\\
 where 
\end{quote}


\begin{lemma}\label{lem:realboundng}
Any eqlevel-decreasing -sequence has length at most 
.
\end{lemma}
\begin{proof}
By induction on .
Assume an eqlevel-decreasing -sequence 
\begin{center}
,
\end{center}
which also entails 
 by our definition.
Since ,
we have ; 
moreover,  since
.

If , then , and thus
\begin{center}
;
\end{center}
we also
have  if
.

If , then 
\begin{center}
 
\end{center}
for some  and some  with 
; this can be easily
derived from Prop.~\ref{prop:bisimgetequation} 
and~\ref{prop:congrlimit}.



We now put (\emph{shift}) ;
hence , and thus
\begin{center}
.
\end{center}
For 
we define
\begin{center}
.
\end{center}
Since , and similarly 
,
by using Prop.~\ref{prop:basicreplace} we get
\begin{center}
.
\end{center}
Since ,
we get 
\begin{center}
.
\end{center}
Finally we note that
\begin{center}
\\
,
\end{center}
for  defined by~(\ref{eq:gprime}).
Hence 
\begin{center}

\end{center}
is an eqlevel-decreasing -sequence.
By the induction hypothesis we have  
, and thus
.
\qed\end{proof}

If , then
Prover can force a potentially infinite 
-sequence for certain  determined by 
(by Lemma~\ref{lem:forcingngseq}). 
She could claim a win
after creating an -sequence longer than ,
if she could demonstrate the value .
(By Lemma~\ref{lem:realboundng} it would be then clear that Refuter does not use the least-eqlevel
strategy or .)
Inspecting the above, we can verify that for computing  
 for concrete  it suffices to know 
 for a sufficiently large ,
and the values  for  from a 
sufficiently large initial segment  of .
We can capture this by the following inductive definition:
\begin{itemize}
	\item		
We say that  is
a \emph{sufficient size-bound for}  and
 (i.e., for computing )
if  and in the case  we also have that 
 is a sufficient size-bound for  where
 is defined by~(\ref{eq:gprime}).
\item
We say that  is
a \emph{sufficient segment-bound} for  and
 (i.e., for computing )
if

and in the case  we have that
 where 
 
is a sufficient segment-bound for  where
 is defined by~(\ref{eq:gprime}).
\end{itemize}
Finally we note that Prover can, when given a grammar ,
present some  and  
(or just the values  for some
) and perform
 the above recursive computation for , while 
 guessing a set 
  for some 
 that is sufficient for this computation. We note that Prover can
 demonstrate that , and also compute the
 eq-level for each pair in  (recall
 Prop.~\ref{prop:negatcase}). 
 For  
 Prover just claims that 
it is a subset of , in which case her computation of
 would be indeed correct; in reality she computes
a value  that is dependent on her choice of
.
We let Refuter to challenge 
the assumption , 
by choosing a pair from ,
so that his least-eqlevel
strategy will still be winning if Prover does not guess  
correctly.
This idea will be
now formalized and embodied in the final game-version.

For  and  we put
\begin{center}
.
\end{center}
For triples  where
, , 
we define 
 by the following recursive definition:
\begin{quote}
	, and
\\
 where 
\end{quote}


\begin{itemize}
	\item		
We say that 
		 is
a \emph{sufficient size-bound for}  a triple  as above
if , ,
and in the case  
 we also have that
 is a sufficient size-bound for  where
 is defined by~(\ref{eq:gprimerelC}).
\item
We say that  is
a \emph{sufficient segment-bound} for 

if
, and in the case  we have that
 where 
 
is a sufficient segment-bound for  where
 is defined by~(\ref{eq:gprimerelC}).
\end{itemize}


We now derive an analogy of Lemma~\ref{lem:realboundng}:


\begin{lemma}\label{lem:boundng}
Let  be a sufficient size-bound for , 
where , ,
,
and let 
.
Then any
eqlevel-decreasing -sequence 
starting with a pair whose eq-level is less than 
 has length at most .
\end{lemma}

\begin{proof}
Let the assumption hold, and 
let us have an -sequence 
\begin{center}
 
where
.
\end{center}
Since , 
and 
(and thus  and
, which entails
),
we must have
; therefore
.

If , or more generally 
if , 
then 
\begin{center}
.
\end{center}
If ( and) , then 
\begin{center}
 
\end{center}
for some  and some  with 

(by Prop.~\ref{prop:bisimgetequation} and~\ref{prop:congrlimit}).

We now put (\emph{shift}) ;
hence , and thus
\begin{center}
.
\end{center}
For 
we define
;
we thus have   for
  defined by~(\ref{eq:gprimerelC}).
We have 
, and
by using Prop.~\ref{prop:basicreplace} we also derive
\begin{center}
.
\end{center}
Hence the sequence
\begin{center}

\end{center}
is an eqlevel-decreasing -sequence,
and  is sufficient for  (since  is assumed 
sufficient for ).
The induction hypothesis thus implies that
,
and thus .
\qed
\end{proof}

\textbf{Prover-Refuter game (third version).}
We separate
 from the initial pair, now denoted ,
to stress that the initial phase depends on  only.

\begin{enumerate}[i)]
	\item
		A grammar  is given.
	\item 
Prover 
provides  
some finite set ,
some , a sequence of increasing values denoted  
for some , and some  such that 
.
For each pair  Prover provides  and 
demonstrates that  (recall Prop.~\ref{prop:negatcase});
thus .
Prover now computes , using the recursive
definition given before~(\ref{eq:gprimerelC});
this fails when  or  are not sufficiently large.



\item 
An initial pair  is given.
\item
For ,
	Refuter chooses 
 
from  
(with the least eq-level when using
the least-eqlevel strategy).
\item 
Now a play of the second game-version starts with  . 
A new feature is that Prover can claim her win when she shows that 
 contains an -subsequence that is
longer than .
\end{enumerate}
The least-eqlevel strategy still guarantees
Refuter's win for ; Prover can never win by the new
game-rule (i.e., by exceeding ), due to
Lemma~\ref{lem:boundng}. On the other hand, Prover
can correctly guess 

for  that is sufficient for computing (the real)  
(related to  that are guaranteed for  by 
Lemma~\ref{lem:forcingngseq}), and she can force her win
when .


Since a winning strategy of Prover (for any  where
)
is finitely presentable and
effectively verifiable
(which easily follows from the fact that Refuter always has only
finitely many options when it is his turn),
a proof of Theorem~\ref{th:bisdecid} is now
clear.

\section{Additional Remarks}\label{sec:addrem}

Theorem~\ref{th:bisdecid} just states the existence of an algorithm
deciding \emph{bisimulation equivalence}
of first-order grammars, or, in more detail,
computing the respective eq-levels.
But the proof can be surely adapted to more general statements.
It would be a technical
exercise to phrase the proof in some more general terms, not referring
to bisimilarity. E.g., we could speak about some more general
(stratified) equivalence with a related 
notion of covering  
with some properties like those captured in 
Prop.~\ref{prop:simplecovering}, etc. 
As usual, a question in such cases is to what extent it makes good
sense. E.g., do we get new worthwhile decidability results in such a
way?

If we look at a (straightforward) transformation from pushdown
automata (PDA) to
FO-grammars (given here in Appendix for completeness), we note how
FO-grammars ``swallow'' deterministic popping -steps in PDA.
(If there is no other rule
for  than , then any (sub)term 
 can be immediately replaced with .)
A question posed by Stirling was if bisimilarity
of PDA with just popping 
-steps (where some nondeterminism is allowed) is still
decidable. 
This was answered negatively in~\cite{DBLP:journals/jacm/JancarS08}.

In our term-framework we extend the action set in
 with a \emph{silent action}, 
denoted , and we also allow 
\emph{-rules} 
 .
 The associated LTS is then
  that naturally extends the
LTS  defined for the case with no
-rules.
The \emph{collapsed LTS} 
  arises from
  by ``swallowing'' the
 -transitions, i.e., we have no -transitions
 in , and
  in  if 
 in   
 there is a path of the form
 
A construction in~\cite{DBLP:journals/jacm/JancarS08} shows that 
bisimilarity in 
 is undecidable, even
when all -rules are popping, i.e. of the form
.
As also noted in~\cite{DBLP:journals/jacm/JancarS08}, 
the same proof construction 
also shows that 
\emph{weak bisimilarity} (for PDA or for 
of FO-grammars where silent
popping moves are allowed) is undecidable.

\begin{quote}
	{\small
In fact, the construction for undecidability 
in~\cite{DBLP:journals/jacm/JancarS08} works also when we
do not include the silent ``post-transitions'', i.e., if we require
 
in~(\ref{eq:epsswallow}); thus the undecidability 
also holds for the respective equivalence
that is finer than
weak bisimilarity.
	}		
\end{quote}	
The undecidability results have been  recently refined, using
 branching bisimilarity~\cite{DBLP:journals/corr/YinFHHT14}.

 
\begin{quote}
{\small
In branching bisimilarity we also exclude the silent
``post-transitions'' (as mentioned above) but there is also a
``semantical'' constraint: the silent ``pre-transitions'' are supposed
to be not changing the equivalence-class.
Formally, given , where rules 
 are allowed,
we can define a \emph{branching bisimulation} 
in the (non-collapsed) LTS 
as a symmetric relation 

where for each 
move  in a pair , for
, 
there is a sequence, a \emph{response},
 such that
 for all
, and ; if , then 
it suffices that  (i.e., the response might be empty). 
}
\end{quote}
For ``pushing'' -rules the construction for
undecidability from~\cite{DBLP:journals/jacm/JancarS08} can be again
easily adapted to branching bisimilarity. But if we only allow 
popping  -rules, of the form 
, then the construction from
~\cite{DBLP:journals/jacm/JancarS08} cannot be used for branching
bisimilarity; there the silent
``pre-transitions'' do not keep the same equivalence class. 
This was noted by
 Y. Fu and Q. Yin~\cite{yuxi-pdadecid-14} who 
announced a result that
would translate in our setting as
the \emph{decidability of branching bisimilarity
of FO-grammars with popping -rules}.
\begin{quote}
{\small
In fact, ~\cite{yuxi-pdadecid-14} also announces the decidability for 
pushing -rules in the context of so called normed PDA
processes. The crucial idea is that the above ``responses''
 to the moves  can be bounded
in this context;
i.e., Prover gets again only boundedly many possibilities how to cover
a given finite set  (in the adapted version of ), which allows us to proceed essentially 
in the way that we used in this paper.
}
\end{quote}
Hence Y. Fu and Q. Yin have noticed that it indeed makes good 
sense to try to
adapt the decidability proof for bisimilarity to get further 
results. An adaptation of an existing proof seems necessary,
since the branching bisimilarity problem that
they study, in particular for PDA with popping -steps,
does not seem to be easily reducible 
to the known decidable (bisimilarity) problem; one has thus to 
delve into the existing proofs, looking for their possible adaptations.

Y. Fu and Q. Yin have chosen to build 
on Stirling's paper~\cite{stirling-pda-00}. They adapt Stirling's
tableau approach to a new model that they invented. In fact, 
when one looks at 
their
technical model, it seems clear that it could be smoothly replaced 
with the first-order-term framework used here 
(and already in~\cite{JancarLICS12}, i.e.,
in the paper of which the authors of~\cite{yuxi-pdadecid-14}
became aware only afterwards, as they say in their conclusions).
Analysing their procedure and its relation to our Prover-Refuter game
would require a nontrivial technical work; here 
we thus suggest 
a direct adaptation of the game that captures the announced result.

\subsubsection*{Adaptation of Prover-Refuter game.}
If we want to use our framework of the Prover-Refuter game
directly to branching bisimilarity
of FO-grammars with popping -rules, 
thus modifying the relation  accordingly,
we encounter a
technical problem. Though in a pair  each move 
 () still
has 
only finitely many possible responses 
,
their number is not bounded (by a quantity determined by the
underlying grammar ), since the responses might
be sinking to subterms of  in unbounded depths. 
This causes, e.g., that the bal-result related to a pivot might not be
``boundedly close'' to the pivot. But we can require that Prover
avoids such unbounded responses; she can always tell,
whenever she presents a new (sub)term , 
if  is equivalent with a root-successor  in ,
and she must then behave consistently with her claims;
we can imagine that she colours the respective arcs (form the root of
 to the root of ) as ``\emph{blue}''.
\begin{quote}
	{\small
	Recall that any response
 should not change the equivalence class
when ``sinking'' from  to ; this sinking can be done only along such
blue arcs if Prover colours the arcs correctly.
}
\end{quote}
Such a blue arc, i.e. a claim that  where  is a root-successor in ,
can be also challenged by Refuter, 
 but it can be used (later)
for replacing  with  when this should not affect
the current eq-level,
if Refuter uses the least-eqlevel strategy.
In this way the respective possible transitions
 (where ) are
also ``swallowed'', similarly as deterministic popping
-steps, which are swallowed ``automatically''. 
\begin{quote}
	{\small
Recall that if there is no other rule
for  than , then any (sub)term 
 can be immediately replaced with .
}
\end{quote}
We thus recover the ``bounded-closeness'' properties, and we can
accordingly adapt the proof that was used in the case with no
-steps. 

Below we suggest a possible way how to formalize the above idea
 of ``blue arcs''.
We stay in the framework of bisimilarity of FO-grammars (with
no -rules),
but the decidability for branching bisimilarity
(of FO-grammars with popping -steps)
follows routinely  after this adaptation.
We thus consider a grammar  and the
Prover-Refuter game as they were defined previously.


\textbf{Quotient graph-presentations, and related decompositions}.
\\
We now stress more explicitly that
we deal with finite objects in the Prover-Refuter game, i.e., with 
graph-presentations (of terms),
called just \emph{graphs} in what follows, rather than 
with the terms themselves. We
use  symbols   to range over graphs
(while  range over terms).
\begin{quote}
	{\small
 In fact, we can take graphs as the states in
the LTSs ,
;
we made clear how the transitions look like in this case.
Nevertheless, our aim is to convey the main idea, not 
to delve into unnecessary technicalities.
}
\end{quote}
Each graph  has finitely many nodes,
and 
each node  corresponds to the term  rooted in
. 

We write shortly 
instead of ; 
similarly
we write  
instead of .

By  for a node  of  we mean the
restriction of  to the nodes occurring on (directed) paths in
 that start in . 
\begin{quote}
	{\small
We thus have a correspondence (not necessarily one-to-one)
between 
the nodes in  and the subterms of .
}
\end{quote}
Let us now consider a graph  with a partition  of
its nodes. By  we denote a (chosen)
\emph{quotient of}  \emph{w.r.t.
} arising as follows: In each partition-class of  
we choose a
representant-node; the nodes
of  are the representant-nodes of all partition
classes, and if an arc from a representant leads to a
non-representant , then we redirect it to the
representant  of the partition-class containing
.
We thus also get a mapping , ``\emph{reducing}'' each node
 of  to , which is the node in
 representing the partition-class of .


For a node  of , by 
(``depth--reducing of '') we mean (a copy of)
the node  in the
graph arising as follows: we take a disjoint union of  and
, where  
each outgoing arc of  in , leading to 
some , is redirected to the node  in 
. Thus the nodes in  are taken
from , with the exception of the root. 

We now define the \emph{decomposition of  by }:
\begin{center}
 is a
node in .
\end{center}
Hence  is a set of pairs of nodes in a graph; the graph
arises from
 by adding copies of the nodes from  whose outgoing
arcs are directed into .

\begin{proposition}\label{prop:declowerEL}
Let  be a graph and  a partition of its nodes.
If  are in the same
partition-class of , then
.
\end{proposition}	

\begin{proof}
Suppose some , ; let  .
By the congruence properties 
we derive for each node  in  that 
\begin{center}

and .
\end{center} 
\begin{quote}
	{\small	
We can show this as follows.
Let  is a
 node in . 
 Then , 
 by Prop.~\ref{prop:congruence}(2). We thus 
have
,
which implies .
}
\end{quote}
For  where  
we thus have 
\begin{center}
.
\end{center}
\qed
\end{proof}
We will particularly use the decompositions of
graphs  that are induced by sets of arcs in  
(later called ``blue arcs'' or ``red arcs'').
Suppose  and a set of its arcs; we call the arcs in the set
``blue''. This defines the least partition 
where the source-node and the target-node of any blue arc are in the
same partition-class.
\begin{quote}
	{\small	
A partition  of the nodes of 
determines the set  are
in the same partition-class of . Hence partitions can be
naturally ordered by inclusion; we refer to this order when saying ``the
least partition such that ...''.
In the above case, two nodes are in the same partition-class iff there
is a ``blue-path'' between them in the \emph{undirected} graph version.
	}
\end{quote}	

\textbf{Modified Prover-Refuter game.}
Let us recall the second version of the game. We modify
it as follows.
\begin{enumerate}
	\item
We denote the initial pair , and assume
that it is given 
by a graph  with two designated nodes , 
where 
 and .

Prover now suggests a partition  
of the set of nodes of  (generally, not necessarily by ``blue
arcs'') where
 must be in the same partition-class.
Now  is created, where each non-loop arc
is coloured \emph{black};
in this way Prover claims that  for the
source-node  and the target-node .

\begin{quote}
	{\small
Any loop-arc from  to  trivially satisfies that its
source-node and its target-node are equivalent; 
we further ignore such
arcs in our discussion.
We also note that Prover could even demonstrate that 
but this is not
necessary here.
	}		
\end{quote}	
Prover claims 
that the above partition  
is induced by the bisimulation
equivalence; she thus also claims that .

Refuter now chooses a pair 

from  , corresponding to a pair
 of terms.
\begin{quote}
	{\small
If Refuter uses the least-eqlevel strategy, we have 

(by Prop.~\ref{prop:declowerEL}).
	}		
\end{quote}
The pair  is thus, in fact, given by a pair
 of nodes of a graph  where 
only the outgoing arcs of   might be not
black (when ignoring the loop-arcs). Prover is supposed to colour each
outgoing arc of 
as ``\emph{blue}'' iff its source-node and its target-node
are bisimilar.

\item
Prover will use a strategy (corresponding to the strategy
in the proof of Lemma~\ref{lem:forcingngseq}) that also guarantees  
that the -th round starts with
a pair  given by two nodes 
in some graph  where 
the arcs are coloured black or blue (ignoring the loop-arcs), 
and where a cycle in  never contains a blue arc, and each blue arc is 
in a bounded distance (depth) from  or .
\begin{quote}
	{\small
As previously, by a ``bounded'' depth we mean that the respective
bound is determined by the underlying grammar .
	}		
\end{quote}
\item
Whenever Prover presents a new graph (in the sets ), she is
supposed to colour each arc, from  to , \emph{blue} 
if ; by black arcs she claims non-equivalence.
She must be consistent with her previous choices.

Now the sets  contain graphs with two designated nodes, and
with coloured arcs.
Refuter thus chooses  by choosing a graph 
with two designated nodes .

\item
If Prover does not make a balancing step, 
in the -th round after Refuter has chosen 
with  , then 
we define the partition
 of the nodes in  as the least partition containing 
 and the source-target pairs of all blue
arcs.
Refuter chooses a pair 
from 
, which presents the pair .

\item 
Suppose that Prover makes a balancing step, say a left one, 
corresponding to replacing  with 
; this is naturally implemented 
in the graph, and we get a graph  instead of . 
In   we recolour the blue arcs in 
(in the -area) to \emph{red}; we perform such a 
blue-to-red recolouring
also in the ``-area'', i.e., in 
for  each
 that corresponds to the root of some .

Now we define the partition
 of the nodes in  as the least partition containing 
 and the source-target pairs of all
\emph{red} arcs.
Refuter chooses a pair 
from 
, which presents the pair .
\begin{quote}
	{\small
		In the respective graph  we have no red
		arcs but there can be the blue arcs inherited 
		from the special
		head , which has a bounded height. 
	}		
\end{quote}

\end{enumerate}
When Prover uses the strategy described 
in the proof of Lemma~\ref{lem:forcingngseq}, while also guessing the
blue arcs correctly, she cannot lose when
.  
It is a routine to verify that any bal-result 
is still ``boundedly-close'' to its respective pivot.
Now the pivots  of two consecutive balancings
(not necessarily in two consecutive rounds) might not satisfy that
 is boundedly reachable from a subterm of , but  arises
from a term  boundedly reachable from a subterm of  by some
replacings of bounded-depth subterms with other bounded-depth
subterms. This fact enables to derive Lemma~\ref{lem:forcingngseq}
as previously.

In the case with no -rules, the ``machinery'' of blue
arcs is not needed. But it makes sense when we consider branching
bisimilarity in the case of popping -rules. 
There the relation  is modified appropriately, and
we allow Prover to use only responses 

where the ``pre-transitions'' 
can only sink 
along blue arcs, and thus always into bounded depths.
The decidability proof can be then finished  analogously to the 
case with no -rules.


\iffalse

often use the relation ``\, is a root-successor in 
and \,'', and
we thus use   to denote this relation shortly.
(Recall that in infinite regular terms we can have  for a
root-successor  in .)



We say that a (regular) \emph{term}  is 
\begin{itemize}
	\item
		\emph{root-reducible}, if there is  such that
		 and  (in );
\item
	\emph{reduced} if none of the subterms of   is
root-reducible; 
\item
	\emph{depth- reduced} (for )
if each subterm of  with depth  is reduced.
\end{itemize}
We will adapt the game so that Prover can guarantee that all pairs
 occurring in a play are 	\emph{depth- reduced} for a
bounded  (except of the initial pair that can be general).

We first define the natural notion 
the \emph{quotient-presentation} related to a finite-graph presentation 
(of the set of terms rooted in the graph-nodes)
and a partition  of the graph-nodes:

it arises by choosing a representant-node in each partition class,
and restricting the graph to the representant nodes; if the -th
outgoing arc from a representant lead to a node , we
redirect it to the representant of the partition-class of
. By  for a subterm  with the root
 

(POZOR:  muze byt stejny subterm jako pro jiny )

we mean the term rooted  in .

By  
 we denote the term arising from  
by the \emph{complete reduction of the root-successors} (i.e., of the
subterms in depth ):
\begin{itemize}
	\item
		 (for ), and 
	\item
		 where .
\end{itemize}

By  we mean 

 is a subterm of 

By  we mean the set .

\begin{proposition}\label{prop:declowerEL}
For any pair  and any  
we have .
\end{proposition}	

\begin{proof}
(by Prop.~\ref{prop:congruence}), ...
	\qed
\end{proof}




By a \emph{reduction-candidate set} 
or a \emph{candidate} for short, we mean a structure  
described as follows. First informally: Imagine the syntactic graph
of a finite 
set of terms (each considered term being rooted in a node of the graph), 
where some arcs are ``coloured
red'' (``red'' as ``reducible''); they will be denoted by 
below (note the subscript ).
In the graph \emph{restricted to red arcs},
we first fix a representant-node in each 
 \emph{final} strongly connected
component (SCC), i.e. an SCC with no outgoing (red) arc; a final SCC 
might be a singleton, which is always the case when the terms are
finite.
For each node we now
fix an outgoing path finishing in the representant of
a final SCC;
the term rooted 
in the end-node of the fixed path starting from
the root of  is denoted  (the ``reduced'' ). 
(Thus .)

We define the partition:  in the same class if
.




The \emph{correct decomposition}
of , denoted , is  for 
\begin{center}
, and  is a subterm of  or .
\end{center}

\textbf{Prover uses correct decompositions carefully.}
We recall the second game-version, but denote the initial pair as
. 
We adapt the game so that
Prover first chooses  is a subterm of  or  and , and
makes 
a decomposition ,
claiming that this id the correct decomposition.
Refuter
chooses a pair  from ;
by Prop.~\ref{prop:declowerEL}
 when Refuter uses the least-eqlevel strategy.
(Prover's claim implies that  are depth- reduced.)


We also modify the end of the point  in the game. If Prover wants
to make no-change, putting , she first 
makes , for some  consistent with the previous
choices, claiming to do the correct decomposition;
Refuter who chooses  from 
.

If Prover made a left-balancing, replacing  
 with , 
she makes a decomposition

by some  consistent with previous
choices but using only subterms of  and .
(She can thus use only bounded-depth subterms.)
Refuter chooses  from .
(In the case of right-balancings the situation is symmetrical.)

We note that the bal-result is again boundedly close to the
pivot. Regarding the pivots  of two consecutive balancings 
(not necessarily in two consecutive rounds), we might not habe that
 is boundedly reachable from a subterm of  but  is boundedly
close to a subterm of : arising from a boundedly reachable term by
a reduction in small depths. This again leads to an -sequence.

In the case of branching bisimilarity with popping
-moves, the  is modified accordingly,
and Prover must respect her claims about reductions. Hence everything
again works.

As expected, if , then 
Prover uses the correct decomposition ,
and we have  and each  is depth- reduced. 


If Prover is about to do  
(after a left-balancing), the she decomposes only by the respective 
pairs in  and in ; this guarantees that 
 is depth- reduced for bounded , while  is
depth- reduced. The bal-result is again boundedly close to the
pivot. 

Adapting  that Prover can use accordingly, we can
proceed in the same way as before.

\fi

\smallskip

\noindent
\textbf{Further remarks on related research.}
Further work is needed to fully understand the discussed problems.
E.g., even the case 
of BPA processes, generated by real-time PDA with
a single control-state, is not quite clear.
Here the bisimilarity
problem is EXPTIME-hard~\cite{Kiefer13} and in 2-EXPTIME~\cite{DBLP:conf/mfcs/BurkartCS95} 
(proven explicitly in~\cite{Jan12b}); for the subclass of normed BPA
the problem is polynomial~\cite{HiJeMo96}
(see~\cite{CzLa10} for the best published upper bound).













\bibliographystyle{splncs03}
\bibliography{root}


\subsection*{Appendix}

\textbf{A transformation of PDA  to first-order grammars.}
\\
By a \emph{pushdown automaton} (PDA) we mean a structure
 where  are finite sets of \emph{control
states}, of \emph{stack symbols}, and of \emph{actions} (or
\emph{input letters}), respectively;  is a finite set
of \emph{pushdown-rules} of the form  where , , , and
.
By a \emph{configuration} we mean any string  where ,
, and  is a special \emph{bottom-of-the-stack
symbol} (where ). 

A PDA  has the associated LTS
\begin{center}

\end{center}
where  is the set of configurations, and the transitions are
induced by the pushdown-rules as follows:
\begin{center}
if  is in , then 
 for any .
\end{center}

Suppose . Then 
a configuration  
can be naturally viewed as the term  defined
inductively by the points  and  below. 
Hence we view each pair  of a control state and a stack symbol as 
a nonterminal  with arity ; a special case is  with arity .
A pushdown rule  is rewritten to 
  for a special formal symbol , and
\begin{center}
  
 is transformed to  , 
\end{center}
where we also use the point  below:
\begin{enumerate}
	\item
		,
	\item
		.
	\item
		.
\end{enumerate}
Hence
.
In fact, we can modify the operator  
for \emph{deterministic popping -rules}: 
If there is no other pushdown-rule for  than 
, then instead of creating 
the grammar rule
 
we might modify the transformation  by putting
; we have thus
``\emph{swallowed}'' the respective -step.
(The branches of the syntactic tree of 
  can have varying lengths in this case.)

We thus do not need -rules in FO-grammars for expressing
PDA where only deterministic popping -moves are allowed.

\end{document}
