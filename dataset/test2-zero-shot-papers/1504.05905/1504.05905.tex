	\documentclass[11pt]{article}
\usepackage{fullpage,amsthm,amssymb,amsmath, amsfonts}
\usepackage[normalem]{ulem}
\usepackage{authblk}
\usepackage{enumerate}
\usepackage{hyperref}
\usepackage{mathabx}
\usepackage{blkarray}
\usepackage{tikz} 
\usetikzlibrary{backgrounds}
\usetikzlibrary{shapes}
\usetikzlibrary{decorations.markings}
\usepackage{subfig}
\captionsetup[subfigure]{labelformat=empty,margin=0pt, parskip=0pt,
  hangindent=0pt, indention=0pt}
\usetikzlibrary{snakes}
\usepackage{algorithmicx,algorithm}
\usepackage{algpseudocode}
\hypersetup{
    pdftitle=   {An FPT algorithm and a polynomial kernel for Linear Rankwidth- Vertex Deletion},
   pdfauthor=  {Mamadou Moustapha Kant\'e, Eun Jung Kim, O-joung Kwon, and Christophe Paul}
}



\usepackage{amsmath}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{definition}{Definition}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem*{THMMAIN}{Theorem \ref{thm:main}}
\newtheorem*{THMMAIN2}{Theorem \ref{thm:rootedpackingmodel1}}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{CLAIM}{Claim}
\newtheorem{RULE}{Reduction Rule}
\newtheorem{QUE}{Question}
\theoremstyle{remark}
\newtheorem*{REM}{Remark}


\usepackage[utf8]{inputenc}
\usepackage{enumerate}
\usepackage{hyperref}
\usepackage{amssymb}
\usepackage{blkarray}
\usepackage{subfig}
\captionsetup[subfigure]{labelformat=empty,margin=0pt, parskip=0pt,
  hangindent=0pt, indention=0pt}

\usepackage{epsfig}



\newcommand\abs[1]{\lvert #1\rvert}

\newcommand\dbarrow{\mathbin{\upuparrows}}
\newcommand\trarrow{\mathbin{\uparrow\!\uparrow\!\uparrow}}
\usepackage{amsmath}

\newcommand\obn{\Omega_N}
\newcommand\obt{\Omega_T}
\newcommand\obu{\Omega_U}
\newcommand\rank{\operatorname{rank}}
\newcommand\cw{\operatorname{cw}}
\newcommand\gr{\mathcal{G}}
\newcommand\Z{\mathbb Z}
\newcommand\cF{\mathcal{F}}
\newcommand\cB{\mathcal{B}}
\newcommand\cR{\mathcal{R}}

\newcommand\house{}
\newcommand\gem{}
\newcommand\domino{}

\newcommand{\LRWD}{\textsc{LRW1-Vertex Deletion} }
\newcommand{\DEL}{LRW1-deletion set}
\newcommand{\dhdel}{\textsc{DH deletion}}
\newcommand{\YES}{\textsc{Yes}}
\newcommand{\NO}{\textsc{No}}

\newcommand{\xtof}[1]{{\color[rgb]{0.8,0,1}\noindent[Xtof: #1]}}
\newcommand{\xtofc}[1]{{\color[rgb]{0.3,0,1}#1}}
\newcommand{\ojk}[1]{{\color[rgb]{0.8,0,0.3}#1}}

\newcommand{\ejk}[1]{{\color[rgb]{0,0.5,0}[Eunjung: #1]}}


\begin{document}
\title{An FPT algorithm and a polynomial kernel for Linear Rankwidth- Vertex Deletion}

\author[1]{Mamadou Moustapha Kant\'e  \thanks{ E-mail address: \texttt{mamadou.kante@isima.fr}}}
\affil[1]{LIMOS, CNRS - Clermont Universit\'e, Universit\'e Blaise Pascal, France.}

\author[2]{Eun Jung Kim  \thanks{ E-mail address: \texttt{eunjungkim78@gmail.com}}}
\affil[2]{LAMSADE, CNRS - Universit\'e Paris Dauphine, France.}


\author[3]{O-joung Kwon\thanks{Supported by ERC Starting Grant PARAMTIGHT (No. 280152). The work was partially done while at Department of Mathematical Sciences, KAIST, and supported by 
 Basic Science Research
  Program through the National Research Foundation of Korea (NRF)
  funded by  the Ministry of Science, ICT \& Future Planning
  (2011-0011653).}\thanks{E-mail address: \texttt{ojoungkwon@gmail.com}}}
\affil[3]{Institute for Computer Science and Control, Hungarian Academy of Sciences, Budapest, Hungary.}

\author[4]{Christophe Paul  
\thanks{Supported by the ``Chercheur d'avenir -- Languedoc-Roussillon'' project KERNEL}
\thanks{E-mail address: \texttt{christophe.paul@lirmm.fr} \\
 An extended abstract appeared in 
  Proc. 10th International Symposium on Parameterized and Exact Computations, 2015~\cite{KanteKKP2015}.}}
\affil[4]{LIRMM, CNRS  - Universit\'e Montpellier, France.}


\date{\today}




\maketitle

\begin{abstract}
\emph{Linear rankwidth} is a linearized variant of rankwidth, introduced by Oum and Seymour [Approximating clique-width and branch-width. \newblock {\em J. Combin. Theory Ser. B}, 96(4):514--528, 2006]. Motivated from recent development on graph modification problems regarding classes of graphs of bounded treewidth or pathwidth, we study the {\sc Linear Rankwidth- Vertex Deletion} problem (shortly, {\sc LRW1-Vertex Deletion}). In the {\sc LRW1-Vertex Deletion} problem, given an -vertex graph  and a positive integer , we want to decide whether there is a set of at most  vertices whose removal turns  into a graph of linear rankwidth at most  and find such a vertex set if one exists. While the meta-theorem of Courcelle, Makowsky, and Rotics implies that \LRWD  can be solved in time  for some function ,  it is not clear whether this problem allows a running time with a modest exponential function. 

We first establish that \LRWD  can be solved in time . The major obstacle to this end is how to handle a long induced cycle as an obstruction. To fix this issue, we define \emph{necklace graphs} and investigate their structural properties. Later, we reduce the polynomial factor by refining the trivial branching step based on a cliquewidth expression of a graph, and obtain an algorithm that runs in time . We also prove that the running time cannot be improved to  under the Exponential Time Hypothesis assumption. Lastly, we show that the \LRWD problem admits  a polynomial kernel.
\end{abstract}

\section{Introduction}


In a parameterized problem, we are given an instance , where  is a secondary measurement, called as the \emph{parameter}. 
The central question in parameterized complexity is whether a parameterized problem admits an algorithm with running time , called a \emph{fixed parameter tractable algorithm} (shortly, an \emph{FPT algorithm}),
where  is a function depending on the parameter  alone and  is the input size.
A parameterized problem admitting such an algorithm is said to be \emph{fixed-parameter tractable}, or {\em FPT} in short. 
As we study a parameterized problem when its unparameterized decision version is NP-hard, the function  is super-polynomial in general. 
For many natural parameterized problems, the function  is overwhelming~\cite{FG04} or even non-explicit~\cite{RS2004}, especially when the algorithm is indicated by a meta-theorem. Therefore, a lot of research effort focus  on designing an FPT algorithm with affordable super-exponential part in the running time. We are especially interested in solving a parameterized problem in {\em single-exponential} FPT time, that is, in time  for some constant .


One of techniques to handle parameterized problems is the \emph{kernelization algorithm}.
A kernelization algorithm takes an instance  and outputs an instance  in time polynomial in  satisfying that
(1)  is a \textsc{Yes}-instance if and only if  is a \textsc{Yes}-instance,
(2) , and  for some function .
The reduced instance is called a \emph{kernel} and the function  is called the \emph{size} of the kernel.
A parameterized problem is said to admit a \emph{polynomial kernel} if there is a kernelization algorithm that reduces
the input instance into an instance with size bounded by a polynomial function  in .

Graph modification problems are typically formulated as follows: given an input graph  and a fixed set  of elementary operations and a graph property , the objective is to transform  into a graph  by applying at most  operations from . Vertex deletion, edge deletion/addition or contraction are examples of such elementary operations. 

The graph property  having treewidth or pathwidth at most  has received in-depth attention as many problems become tractable on graphs of small treewidth. The celebrated Courcelle's theorem~\cite{Cou90} implies that every graph property expressible in monadic second order logic of the second type () can be verified in time , when the input -vertex graph has treewidth at most . Furthermore, having small treewidth frequently facilitates the design of a dynamic programming algorithm whose running time is much faster than that of the all-round algorithm from the Courcelle's meta-theorem. Therefore, it is reasonable to measure how close an instance is from ``an island of tractability within an ocean of intractable problems''~\cite{GaspersS12}.



In the context of treewidth, the vertex deletion problems for the special cases of  and  correspond to the well-known {\sc Vertex Cover} and {\sc Feedback Vertex Set} problems respectively.
Generally, for fixed , the  {\sc Treewidth- Vertex Deletion} can be solved in time  implied by Courcelle's meta-theorem~\cite{Cou90}. As the function  subsumed in the meta theorem is gigantic, it is natural to ask whether the exponential function in the running time can be rendered realistic. Recent endeavor pursuing this question culminated in establishing that for fixed , the {\sc Treewidth- Vertex Deletion} can be solved in single-exponential FPT time~\cite{FominLMS12,KLPRRSS13}. 

As for pathwidth, \textsc{Pathwidth- Vertex Deletion} was first studied  by Philip, Raman, Villanger~\cite{PhilipRV2010}, and later Cygan, Pilipczuk, Pilipczuk, Wojtaszczyk~\cite{CyganPPW2012} showed that \textsc{Pathwidth-1 Vertex Deletion} can be solved in time  and it admits a quadratic kernel. Using the general method developed for \textsc{Treewidth- Vertex Deletion}~\cite{FominLMS12,KLPRRSS13}, the \textsc{Pathwidth- Vertex Deletion} problem also admits a single-exponential FPT algorithm.

\subparagraph{Linear rankwidth.} 
\emph{Rankwidth} was introduced by Oum and Seymour~\cite{OS2004} for efficiently approximating \emph{cliquewidth}. 
Compared to cliquewidth, there are some containment relations, called \emph{vertex-minors} and \emph{pivot-minors}~\cite{Oum05}, 
where the rankwidth of a graph does not increase when taking those relations.
With these relations, 
rankwidth has been intensively studied to extend  results for treewidth and graph minors~\cite{AKK2014, CourcelleK09,GanianH10,JKO2014, Kante2012, Oum05, Oum2006, OS2004}.

\emph{Linear rankwidth} is a linearized variation of rankwidth as pathwidth is the linearized variant of treewidth. While treewidth and pathwidth are small only on sparse graphs, dense graphs may have small rankwidth or linear rankwidth. For instance, complete graphs, complete bipartite graphs, and threshold graphs~\cite{ChvatalH1977} have linear rankwidth at most  even though they  have unbounded treewidth. 

Linear rankwidth is deeply related to \emph{matroid pathwidth}, also known as \emph{trellis-width}, introduced by Kashyap~\cite{Kashyap08}.
Matroid pathwidth has been studied in some matroid theory literature~\cite{GeelenGW2006, HallOS2007, KoutsonasTY2014}. 
Kashyap~\cite{Kashyap08} showed that it is NP-hard to compute the matroid pathwidth of a binary matroid given with its matrix representation.
From the relation between a binary matroid and its fundamental graph due to Oum~\cite{Oum05},  
one can also deduce that it is NP-hard to compute the linear rankwidth of a graph.
Recently, 
Jeong, Kim, and Oum~\cite{JeongKO2016} showed that for fixed , there is a cubic-time algorithm to test whether an input graph has linear rankwidth at most  or not, and 
output such an ordering if one exists.




Ganian~\cite{Ganian10} pointed out that some NP-hard problems, such as computing pathwidth, can be solved in polynomial time on graphs of linear rankwidth at most .
Generally, the meta-theorem by Courcelle, Makowsky, and Rotics~\cite{CourcelleMR00} states that for every graph property  expressible in monadic second order logic of the first type () and fixed , there is a cubic-time algorithm for testing whether a graph of rankwidth at most  has property .
As rankwidth is always less than or equal to linear rankwidth, 
those problems are tractable on graphs of bounded linear rankwidth as well.




In the same context, it is natural to ask whether there is an FPT algorithm for the \textsc{(Linear) Rankwidth- Vertex Deletion} problem, that is a problem asking whether for a given graph  and a positive integer ,  contains a vertex subset of size at most  whose deletion makes  a graph of (linear) rankwidth at most . 
It is only known that for fixed , both problems are FPT from the meta-theorem on graphs of bounded rankwidth~\cite{CourcelleMR00}. 
We discuss it in more detail in Section~\ref{sec:remark}.
However, as the function of  obtained from the meta-theorem is enormous, it is interesting to know whether there is a single-exponential FPT algorithm for both problems, like \textsc{Treewidth- Vertex Deletion}. 
Also, to the best of our knowledge, there was no known previous result whether the  \textsc{(Linear) Rankwidth- Vertex Deletion} problem admits a polynomial kernel for fixed integer .


\subparagraph{Our contributions.}  In this paper, we show that the \textsc{Linear Rankwidth- Vertex Deletion} problem admits a single-exponential FPT algorithm and a polynomial kernel. This is a first step towards a goal of investigating whether the \textsc{(Linear) Rankwidth- Vertex Deletion} problem admits a single-exponential FPT algorithm or has a polynomial kernel. 

\smallskip
\noindent
\fbox{\parbox{0.97\textwidth}{
{\sc Linear Rankwidth- Vertex Deletion} ({\sc LRW1-Vertex Deletion}) \\
\textbf{Input :} A graph , a positive integer  \\
\textbf{Parameter :}  \\
\textbf{Question :} Does  have a vertex subset  of size at most  whose removal makes  a graph of linear rankwidth at most one?} }


\begin{theorem}\label{thm:main1}
The \LRWD problem can be solved in time , and also can be solved in time .
\end{theorem}

\begin{theorem}\label{thm:main2}
The \LRWD problem has a kernel with  vertices.
\end{theorem}

We note that 
several graph classes with a certain path-like structure have been
studied for parameterized vertex deletion 
problems. Such classes include graphs of pathwidth-~\cite{PhilipRV2010, CyganPPW2012},
proper interval graphs~\cite{FSV2012, VV2013}, unit interval graphs~\cite{BevernKM2010,Cao2015}, and interval graphs~\cite{CaoM2015}. A common approach in the previous work was to use the characterization of the structures obtained after removing small obstructions. We also characterize graphs excluding small obstructions for graphs of linear rankwidth at most .




We investigate a new class of graphs, called \emph{necklace graphs}, which are close to graphs of linear rankwidth at most . 
Briefly speaking, necklace graphs, when viewed locally, are graphs of linear rankwidth at most , but they may have long induced cycles.
In Section~\ref{sec:necklacegraph}, we show that every connected graph having no obstructions of size at most  for graphs of linear rankwidth at most  is either a graph of linear rankwidth at most  or a necklace graph (Theorem~\ref{thm:mainlrw}).
Combining a simple branching algorithm and a polynomial-time algorithm to find a minimum deleting set on necklace graphs, we obtain an FPT algorithm for \LRWD with running time 
in the beginning of Section~\ref{sec:fptthreaddel}. 

One might ask whether the polynomial factor  can be reduced.
This running time appears as we start with finding obstructions of size at most .
Indeed, we can improve it using a dynamic programming algorithm to find an induced subgraph of fixed size in a graph of bounded cliquewidth.
If the rankwidth of a given graph is more than , then the instance is trivially a \NO-instance because rankwidth can be decreased by at most  when removing a vertex.
Using the approximation algorithm due to Oum~\cite{Oum2006}, 
we can decide whether a given graph has rankwidth at most  and if so, outputs a rank-decomposition of width at most  and
also a -cliquewidth expression, in time .
Then we develop a branching algorithm using the cliquewidth expression, and
finally achieve an FPT algorithm with running time .
In Section~\ref{sec:lowerbound}, we prove that the running time of our algorithms cannot be reduced to  under a reasonable assumption.
\begin{theorem}
There is no -time algorithm for \textsc{LRW1 Vertex Deletion}, unless Exponential Time Hypothesis (ETH) fails.
\end{theorem}






In Section~\ref{sec:polykerthreaddel}, we obtain a polynomial kernel for the \LRWD problem. We start with hitting obstructions of size at most  using the Sunflower lemma, and taking a minimum deleting set on the remaining necklace graph. The union of two sets will have size bounded by a polynomial function in , and its removal makes an input graph into a graph of linear rankwidth at most . 
Graphs of linear rankwidth at most  can be seen as graphs obtained by connecting certain blocks, called \emph{thread blocks}, like a path (Theorem~\ref{thm:structurethread}).
The main difficulty for reducing the remaining part is to shrink a large thread block, and 
we can resolve this issue using the set obtained by the Sunflower lemma.
We remark that a similar idea was used by Fomin, Saurabh, and Villanger~\cite{FSV2012} to obtain a polynomial kernel for the {\sc Proper Interval Vertex Deletion} problem.
We conclude the paper with further discussions in Section~\ref{sec:remark}.




\section{Preliminaries}\label{sec:preliminaries}




In this paper, all graphs are finite and undirected, if not mentioned. 
For a graph , we denote by  and  the vertex set and the edge set of a graph , respectively.  
Let  be a graph.
For , let  denote the neighborhood of . 
Let  be a subset of . We denote by  the subgraph of  induced on  and we define .
For short we write  instead of  for .  A vertex  of  is called a \emph{pendant vertex} if
. 
The subset of vertices  is the set of all vertices of  that have a neighbor in . 


A graph  is an \emph{induced subgraph} of a graph  if  for some .
For a set  of graphs, a graph  is \emph{-free} if  has no induced subgraph isomorphic to a graph in . 

 A vertex  of  is called a {\em cut vertex} if the removal of  from  strictly increases the number of connected components. 
A maximal connected subgraph of a graph without a cut vertex is called a {\em block}.
 Note than an edge can be a block.

The path on the vertex set  and the edge set  will be denoted by , and 
the cycle on the vertex set  and the edge set  
will be denoted by .
The length of a path is defined as the number of edges in the path. For , we denote by  the chordless cycle of length . 
A graph  is \emph{distance-hereditary} if for every connected induced subgraph  of  and , 
the distance between  and  in  is the same as the distance between  and  in .
For instance the cycle  of length  is not distance-hereditary, as  and  have distance  in the graph, 
but they have distance  in .
A \emph{star}
is a tree with a distinguished vertex adjacent to all other vertices.  A \emph{complete graph} is a graph with all possible edges.



An ordering on a finite set  is a bijective mapping , and we write  if , and  as the inverse
bijective mapping. 
For an -matrix  and , let  be the submatrix of  whose rows and columns are indexed by  and , respectively.

When we analyze the running time of an algorithm, we agree that  and  if  is an input graph.


\subsection*{Linear rankwidth and thread graphs}
The \emph{adjacency matrix} of a graph , which is a -matrix over the binary field, will be denoted by .
The \emph{width} of an ordering  of the vertex set of a graph  is 
 
where the rank of a matrix is computed over the binary field. The \emph{linear rankwidth} of a graph  is defined as the minimum width over all orderings of .

Ganian~\cite{Ganian10} first characterized graphs of linear rankwidth at most , and he called them \emph{thread graphs}. 
Later, Adler, Farley, and Proskurowski~\cite{AFP2013} gave an easier way to define a thread graph, using a notion of \emph{thread blocks}.
We follow the definition of thread blocks given by Adler, Farley, and Proskurowski, and provide a unified way to define classes of graphs including thread graphs.


A graph  with at least  vertices is called a \emph{thread block}
if there is an ordering  of  and a function  satisfying that
\begin{enumerate}[(1)]
\item  and ,
\item for  with ,  if and only if  and .
\end{enumerate}
A thread block is a \emph{canonical thread block} if it satisfies on the top of the previous two conditions and the following third condition:
\begin{enumerate}[(3)]
\item  if .
\end{enumerate}
The third condition implies that every canonical thread block has no pendant vertex adjacent to its first vertex .
It will guarantee a unique decomposition of a thread graph into thread blocks. 
We say that  and  are the \emph{ordering} and \emph{labeling} of  respectively, and 
say that  and  are the \emph{first and last} vertices of , respectively.
See Figure~\ref{fig:threadblock} for an example.


\begin{figure}
\centerline{\includegraphics[trim={4cm 11.5cm 6cm 12cm},clip,scale=0.50]{threadblock.pdf}}
\caption{An example of a thread block whose first and last vertices are  and , respectively.} \label{fig:threadblock}
\end{figure}
\begin{figure}
\centerline{\includegraphics[clip,scale=0.7]{thread-graph.pdf}}
\caption{An example of a connected thread graph and its canonical thread decomposition.} \label{fig:threadgraph}
\end{figure}

Let  be a digraph.
A  set  of thread blocks is said to be 
\emph{mergeable with } if
\begin{enumerate}[(1)]
\item for every arc  of ,  is a thread block whose first and last vertices are  and , respectively, and
\item  for two distinct arcs  of , .
\end{enumerate}
For a digraph  and a set of thread blocks  mergeable with , we define  as the graph  with the vertex set   and the edge set .
We say that  is the \emph{underlying digraph} of  and that  is a \emph{thread decomposition} of .
We say that   is a \emph{canonical thread decomposition} of 
if every thread block of  is a canonical thread block.

\begin{definition}[Thread graph]
A connected graph  is a \emph{thread graph}
if  is either an one vertex graph or  for some directed path  and some set of thread blocks  mergeable with . A graph is a \emph{thread graph} if each of its connected components is a thread graph. 
\end{definition}

See Figure~\ref{fig:threadgraph} for an example of a connected thread graph, and its canonical thread decomposition.
It is not hard to observe that every connected thread graph admits a canonical thread decomposition; one can obtain a canonical thread decomposition from any thread decomposition by rearranging pendant vertices adjacent to a vertex in the underlying digraph.
In Lemma~\ref{lem:splittreetothreadblock}, we will give a polynomial-time algorithm that given a connected thread graph, outputs its canonical thread decomposition.


The following structural properties of thread graphs will be used in later sections.

\begin{lemma}\label{lem:structure}
Let  be an integer, and let  be a connected thread graph such that
 admits a canonical thread decomposition  where 
 and
.
Then the following are satisfied.
\begin{enumerate}[(1)]
\item For every ,  has a neighbor in . 
\item Vertices  are cut vertices of .
Moreover, every cut vertex of  is contained in .
\item For each ,  is exactly the union of the set of all pendant vertices adjacent to  and the vertex set of the block of  containing .
\end{enumerate}
\end{lemma}
\begin{proof}
(1) Let  be the thread block containing . Depending on the label of  in , 
 is adjacent to at least one of .

\medskip
\noindent
(2) The first statement came from the definition of a connected thread graph that 
for  with , . 
That is, for each , all paths from  to  must pass through , and it implies that  is a cut vertex of .


If , 
then by the statement (1), every vertex of  has a neighbor in  and thus  is connected.
It implies that every cut vertex of  is contained in .

\medskip
\noindent
(3) Let us fix  and let  and  be the ordering and labeling of , respectively.
Let  be the vertex set containing all pendant vertices adjacent to  and the vertex set of the block of  containing  and .
We need to prove that .

To prove that , let . 
Observe that by construction of  and the fact that , if  is not a pendant vertex and satisfies , then . 
So, let us assume that  is not a pendant vertex and has a neighbor in  other than  and .
If  is adjacent to some vertex  of  with , then  it contradicts the fact that  separates  and  in  by (2).
Similarly, if  is adjacent to some vertex  of  with , then it contradicts the fact that  separates  and  in  by (2).
Thus, we have  and .
Finally by construction, as  is a canonical thread decomposition, the pendant vertices adjacent to  belong to . We conclude that .





We verify that . Let .
If , then  is contained in .
If , then by definition of a canonical thread block, there exists  with .
So,  is contained in a cycle of length  together with , and thus, .
If  and there exists  with , 
then similarly we have , 
and if there are no such a vertex , then  is a pendant vertex adjacent to , that is also contained in .
\end{proof}


\begin{figure}
\centerline{\includegraphics[scale=0.8]{figure11.pdf} \quad
\includegraphics[scale=0.8]{figure12.pdf} \quad
\includegraphics[scale=0.8]{figure13.pdf} \quad
\includegraphics[scale=0.8]{figure14.pdf}}
\caption{The induced subgraph obstructions for distance-hereditary graphs.}
\label{fig:obsdh}
\end{figure}


\begin{figure}
\centerline{\includegraphics[scale=0.7]{figure2.pdf}}
\vspace{-0.5cm}
\caption{The induced subgraph obstructions for graphs of linear rankwidth  that are distance-hereditary.}
\label{fig:obslrw1}
\end{figure}


Let  be the house, gem, domino graphs respectively, which are depicted in Figure~\ref{fig:obsdh}.
The induced subgraph obstructions for graphs of linear rankwidth at most  consist of the set of induced subgraph obstructions for distance-hereditary graphs~\cite{BM1986}, that are \house, \gem, \domino, and induced cycles of length at least , and the set of 14 induced subgraph obstructions for graphs of linear rankwidth at most  that are distance-hereditary, depicted in Figure~\ref{fig:obslrw1}~\cite{AFP2013}.
We define that
\begin{itemize}
\item  is the union of  and the set of  graphs in Figure~\ref{fig:obslrw1}.
\end{itemize}




\begin{theorem}[Ganian~\cite{Ganian10}; Adler, Farley, and Proskurowski~\cite{AFP2013}]\label{thm:structurethread}
For a graph , the following are equivalent.
\begin{itemize}
\item  has linear rankwidth at most .
\item  is a thread graph.
\item  has no induced subgraph isomorphic to a graph in .
\end{itemize}
\end{theorem}



We often use the term `thread graphs' for graphs of linear rankwidth at most .
For a graph  and ,  is called a \emph{\DEL} if  is a graph of linear rankwidth at most .


\subsection*{Obtaining a canonical thread decomposition}



It is known that one can recognize graphs of linear rankwidth at most  in time  using split decompositions~\cite{Bui-XuanKL13, AdlerKK20152}.
Furthermore, we can easily obtain a canonical thread decomposition of a graph of linear rankwidth at most  from its split decomposition, 
but for our knowledge, it was not stated anywhere.
In this subsection, we clarify a procedure to obtain a thread decomposition.
This will be especially used in the kernelization algorithm in Section~\ref{sec:polykerthreaddel}.








We use graph-labelled trees introduced by Gioan and Paul~\cite{GP2012}, which are convenient forms of split decompositions.  
A triple  of a tree  and a set of graphs  and a set of functions  is called a \emph{graph-labelled tree} if 
\begin{itemize}
\item for every node  of degree  in ,  is a connected graph on  vertices, called \emph{marker vertices},
\item  is a bijection from the edges of  incident with  to the marker vertices of . 
\end{itemize}
Let  be a leaf of .
A node or a leaf  different from  is called \emph{-accessible} if for every edges  and  on the path from  to  in ,
 is adjacent to  in . 
The \emph{accessibility graph} of a graph-labelled tree  is the graph  whose vertex set is the set of all leaves of , 
and  if and only if  is -accessible. We say that  is a graph-labelled tree of .


We give two operations on a graph-labelled tree to define a \emph{reduced graph-labelled tree}.
A \emph{split} of a graph  is a vertex partition  of  such that
, and there exist  where the set of edges incident with both  and  is exactly .
 A connected graph is \emph{degenerate} if every vertex partition  with  is a split.
It is known that every degenerate graph is either a complete graph or a star graph.
 A node in a graph-labelled tree is called a \emph{clique node} (or a \emph{star node}) if a complete graph (or a star graph, respectively) is assigned to the node.
 A graph without splits is called a \emph{prime graph}.
 
Let  be a graph-labelled tree of a graph .
Let  be a node of  such that  admits a split .
For each , 
let  be the graph obtained from  by adding a new vertex  that is adjacent to all vertices in .
Then the \emph{node-split} operation on the node  with respect to 
consists of substituting  by two adjacent nodes , respectively labelled by , such that for each , 

The \emph{node-join} operation is the reverse operation of the node-split operation; 
if  is an edge of , then the \emph{node-join} operation on  
consists of contracting  into a new node  labelled by the graph  
where  is the graph obtained from the disjoint union of  and  
by deleting  and  and adding all edges between  and .

We say that a star node  is \emph{oriented towards a node } of  if the edge  such that  is the center
of  is on the path in  between  and . 


A graph-labelled tree is \emph{reduced} if  
\begin{enumerate}[(1)]
\item every node is either prime or degenerate, and 
\item it contains no edge that connects two degenerate nodes where the node-join operation on this edge results in another degenerate node.
 \end{enumerate}
Cunningham showed the uniqueness of a reduced graph-laballed tree of a connected graph.
Moreover, it can be computed in time .



\begin{theorem}[Cunningham~\cite{Cunningham1982}; Dahlhaus \cite{Dahlhaus00}]\label{thm:cunningham}
Every connected graph  admits a unique reduced graph-labelled tree, and it can be computed in time .
\end{theorem} 
 
For a connected graph , we denote by  the unique reduced graph-labelled tree obtained from Theorem~\ref{thm:cunningham}.
We call it the \emph{split tree} of .
The following characterization of graphs of linear rankwidth  is crucial.
We give an example of the split tree of a connected thread graph in Figure~\ref{fig:splittree}.

\begin{figure}[t]\centering
\tikzstyle{v}=[circle, draw, solid, fill=black, inner sep=0pt, minimum width=3pt]
 \tikzset{
    photon/.style={decorate,  draw=gray, very thick, , densely dashed},
}

\begin{tikzpicture}[scale=0.045]


\draw (30-40,40) ellipse (14 and 15);
\node(a1) [v] at (30-40,50) {};
\node(a3) [v] at (20-40,40) {};
\node(a4) [v] at (40-40,40) {};
\draw(a1)--(a3)--(a4)--(a1);

\node(a5) [v] at (20-50,40) {};
\node(a6) [v] at (30-40,60) {};
\draw[photon] (a5)--(a3);
\draw[photon](a6)--(a1);

\draw[red] (30-40, 67) node{};


\draw (30,40) ellipse (14 and 15);

\node(b1) [v] at (30,50) {};
\node(b3) [v] at (20,40) {};
\node(b4) [v] at (40,40) {};
\draw(b1)--(b3)--(b4);

\node(b6) [v] at (30,60) {};
\draw[photon](b6)--(b1);

\draw[red] (30, 67) node{};




\draw (30+40,40) ellipse (14 and 15);


\node(c1) [v] at (30+40,50) {};
\node(c3) [v] at (20+40,40) {};
\node(c4) [v] at (40+40,40) {};
\draw(c1)--(c3)--(c4)--(c1);

\node(c6) [v] at (30+40,60) {};
\draw[photon](c6)--(c1);

\draw[red] (30+40, 67) node{};

\draw (30+80,40) ellipse (14 and 15);


\node(d1) [v] at (30+80,50) {};
\node(d3) [v] at (20+80,40) {};
\node(d4) [v] at (40+80,40) {};
\draw(d3)--(d1)--(d4);
\node(d6) [v] at (30+80,60) {};
\draw[photon](d6)--(d1);

\draw (30+120,40) ellipse (14 and 15);


\node(e1) [v] at (30+120,50) {};
\node(e3) [v] at (20+120,40) {};
\node(e4) [v] at (40+120,40) {};
\draw(e1)--(e4)--(e3);
\node(e6) [v] at (30+120,60) {};
\draw[photon](e6)--(e1);

\draw[red] (30+120, 67) node{};

\draw (30+160,40) ellipse (14 and 15);


\node(f1) [v] at (30+160,50) {};
\node(f3) [v] at (20+160,40) {};
\node(f4) [v] at (40+160,40) {};
\draw(f1)--(f3)--(f4)--(f1);
\node(f6) [v] at (30+160,60) {};
\draw[photon](f6)--(f1);

\draw[red] (30+160, 67) node{};

\draw (30+200,40) ellipse (14 and 15);


\node(g1) [v] at (30+200,50) {};
\node(g3) [v] at (20+200,40) {};
\node(g4) [v] at (40+200,40) {};
\draw(g1)--(g3)--(g4);
\node(g6) [v] at (30+200,60) {};
\draw[photon](g6)--(g1);

\draw[red] (30+200, 67) node{};



\draw (30+240,40) ellipse (14 and 15);


\node(h1) [v] at (30+240,50) {};
\node(h2) [v] at (30+240,30) {};
\node(h3) [v] at (20+240,40) {};
\node(h4) [v] at (40+240,40) {};
\draw(h3)--(h1)--(h4);
\draw(h1)--(h2);
\node(h6) [v] at (30+240,60) {};
\node(h7) [v] at (30+240,20) {};
\draw[photon](h6)--(h1);
\draw[photon](h7)--(h2);

\draw[red] (30+240, 10) node{};



\draw[photon] (a4)--(b3);
\draw[photon] (b4)--(c3);
\draw[photon] (c4)--(d3);
\draw[photon] (d4)--(e3);
\draw[photon] (e4)--(f3);
\draw[photon] (f4)--(g3);
\draw[photon] (g4)--(h3);

\draw (30+265, 40) node{};


\end{tikzpicture}
\caption{The canonical split tree of the first two thread blocks of the thread graph in Figure~\ref{fig:threadgraph}.}\label{fig:splittree}
\end{figure} 





\begin{theorem}[Bui-Xuan, Kant\'e, and Limouzy~\cite{Bui-XuanKL13}; Adler, Kant\'e, and Kwon~\cite{AdlerKK20152}]\label{thm:charlrw1split}
A connected graph  with the split tree  is a graph of linear rankwidth at most   if and only if
every graph in  is degenerate and 
the tree obtained from  by removing all its leaves is a path.
Thus, one can recognize graphs of linear rankwidth at most  in time .
\end{theorem}



\begin{lemma}\label{lem:splittreetothreadblock}
Given a connected graph  of linear rankwidth at most , 
we can output a canonical thread decomposition  in time . 
\end{lemma}
\begin{proof}
Using the algorithm in Theorem~\ref{thm:cunningham}, we compute a split tree of  in time .
Let  be the obtained split tree of a connected thread graph .
By Theorem~\ref{thm:charlrw1split}, the tree obtained from  by removing all its leaves is a path and each  is degenerate, that is, either a star node or a clique node.
Let  be the path  obtained from  by removing all its leaves, and we give a direction on edges so that it is the directed path from  to .
Note that for each leaf  in  with the neighbor , there exists a unique marker vertex  in  such that
.
We denote by .



We choose the sequence  of all star nodes such that  
\begin{itemize}
\item , 
\item for each , there is a leaf  of  such that  is the center of .
\end{itemize}
We choose a leaf  of  that is adjacent to , 
and choose a leaf  of  that is adjacent to .
It is not hard to check that .
Also, from the accessibility among nodes of , one can observe that  are cut vertices of , and thus  is an induced path of .
Let , and we regard it as a directed path from  to .


Now, we construct a set of thread blocks  where 
  is a canonical thread decomposition of .
For each node , let  be the set of all leaves in  that are adjacent to .
For convenience, let  and .
For each , we define the following:
\begin{enumerate}
\item Let .
\item We take an ordering  of  such that  and  are the first and last vertices, and 
 if there is a directed path from the neighbor of  to the neighbor of  in . We take an arbitrary ordering for the leaves that have the same neighbor in ,  except . 
This can be done in time .
\item 
From the definition of , 
it is not hard to check that for  with ,  if and only if 
\begin{itemize}
\item , or the neighbor of  is either a clique node or a star node oriented towards , and 
\item , or the neighbor of  is either a clique node or a star node oriented towards . 
\end{itemize}
Note that the vertices in  are pendant vertices adjacent to  in . 
Following the above observations, we give a labeling  on  such that
for  with the neighbor  in ,
 
It takes  time.
It is not hard to verify that  and  are proper ordering and labeling of  using accessibility among nodes of . Moreover,  as  does not contain a vertex  in , which is a pendant vertex adjacent to  if exists, 
 is a canonical thread block whose first and last vertices are  and , respectively, with the ordering  and the labeling .

We return .
\end{enumerate}


Note that  are cut vertices of . Thus, it is straightforward to check that
\begin{enumerate}[(1)]
\item  for every pair  with , 
\item   and .
\end{enumerate} 
We conclude that  is the canonical thread decomposition of , and it can be computed in time .
\end{proof}








\section{Necklace graphs}\label{sec:necklacegraph}
We generalize the construction of thread graphs from directed paths to directed cycles.

\begin{figure}
\centerline{\includegraphics[trim={0 4cm 0 0}, scale=0.3]{necklace-graph2.pdf}}

\caption{An example of a necklace graph and its canonical thread decomposition.}
\label{fig:necklace}
\end{figure}



\begin{definition}
A connected graph  is called a \emph{necklace graph} if  for some directed cycle  and 
some set of thread blocks  mergeable with . 
\end{definition}

See Figure~\ref{fig:necklace} for an example of a necklace graph.
Let  The main result of this section is the following.

\begin{theorem}\label{thm:mainlrw}
Every connected -free graph is either a connected thread graph or a necklace graph whose underlying cycle has length at least .
\end{theorem}

Assuming that  is not a  thread graph, to prove Theorem~\ref{thm:mainlrw}, we recursively find an underlying cycle  of length  and a set of thread blocks  such that . At each recursion step, we assume that  and prove that 
\begin{enumerate}[(1)]
\item if  contains two vertices of distance at least  in , 
then  contains a graph in  or an induced cycle of length  with , 
\item if every pair of vertices of  are at distance at most , 
then  is contained in the union of two consecutive thread blocks of , 
and then either  contains a graph in  or it is a necklace graph with  as the underlying cycle.
\end{enumerate} 



We need some preliminary lemmas.

\begin{lemma}\label{lem:excludecycle8}
Let  be a necklace graph whose underlying cycle  has length . The distance in  between any pair of vertices is at most .
\end{lemma}
\begin{proof}
Observe that when merging the (directed) cycle  with a set of thread blocks  to obtain , the distance between any two vertices of  in  is the same as the distance in  (viewed as an undirected cycle). As the distance between any pair of vertices in an induced cycle of length  is at most , the statement follows from the fact that  every vertex in  either belongs to  or has a neighbor in . 
\end{proof}

\begin{lemma}\label{lem:pathtoobs}
Let  be an integer.
Let  be a graph and let  such that  is an induced path , and  is adjacent to both  and  in .
Then  contains an induced subgraph isomorphic to \house, \gem, \domino, or an induced cycle of length at least .
\end{lemma}
\begin{proof}
Let  be the sequence of integers such that  are all neighbors of  on .
If  for some , then  is an induced cycle of length at least .
We may assume that  for all . If  for some , then 
 is isomorphic to \domino. If one of  and  is  and the other value is  for some , then   is isomorphic to \house. So we may assume that  for all .
Since ,  has an induced subgraph isomorphic to \gem.
\end{proof}




\begin{lemma}\label{lem:extendthread}
Let  be a connected thread graph and  such that
 admits a canonical thread decomposition  where 
 and
.
If , then there exists a set  of thread blocks mergeable with 
such that
 is a canonical thread decomposition of .
\end{lemma}
\begin{proof}
Since  is a connected thread graph,
 admits a canonical thread decomposition  with a directed path  and a mergeable set of thread blocks . We first show that  should be contained in .
By Lemma~\ref{lem:structure}, it is enough to show that they are cut vertices of .

Note that  and  are still cut vertices of  as .
We claim that  is also a cut vertex of .
Suppose that  is not a cut vertex of . This implies that there is a path from  to  in .
We take a shortest path  among such paths.
If it has length , then  induces a subgraph isomorphic to  or  depending on the adjacency between  and the middle vertex of .
If it has length at least , then by Lemma~\ref{lem:pathtoobs},  contains an induced subgraph in , which contradicts to our assumption.
Thus,  is also a cut vertex of .

Since  are cut vertices of , by (2) of Lemma~\ref{lem:structure}, we have . 
If  is a directed path in , then 
for each , we take the subgraph  of  induced on the union of the set of all pendant vertices adjacent to  and the vertex set of the block of  containing .
By (3) of Lemma~\ref{lem:structure},  and  are the canonical thread blocks listed in . 
Now, we assume that  is a directed path in .
In this case, for each , 
the subgraph  of  induced on the union of the set of all pendant vertices adjacent to   and the vertex set of the block of  containing 
is a canonical thread block listed in .
Then we obtain  from  by removing all pendant vertices adjacent to  and adding all pendant vertices adjacent to .
It is not hard to observe that  is a canonical thread block whose first and last vertices are , respectively; we can take a reverse ordering for vertices in the block containing , and replace each label  with  and each label  with .



Now, we set . We claim that . 
As each thread block  or  in  satisfies that  or , 
we have that 
\begin{itemize}
\item , and
\item .
\end{itemize}
As  is a canonical thread decomposition of  and , by (3) of Lemma~\ref{lem:structure}, 
every vertex of  is either a pendant vertex adjacent to one of , 
or
contained in a block containing two consecutive vertices .
It implies that , and we have
\begin{itemize}
\item  and .
\end{itemize}
Therefore, we conclude that .
\end{proof}





\begin{proof}[Proof of Theorem~\ref{thm:mainlrw}]
Let  be a connected -free graph and suppose that  is not a thread graph. By Theorem~\ref{thm:structurethread},  contains an induced cycle of length at least . Let  be a shortest cycle among induced cycles of length at least  in . For convenience, let . We regard  as a directed cycle on vertex set  (with ), where for each ,  is an arc. 

We prove by induction on  that  is a necklace graph whose underlying cycle is . We may assume that . 
Clearly,  is again -free graph and
 is a shortest cycle among induced cycles of length at least  in .  By the induction hypothesis, 
 is a necklace graph whose underlying cycle is  and thereby has a canonical thread decomposition  where .


We claim that all vertices of  have pairwise distance at most  in .
Suppose that there are two vertices  that have distance at least  in . 
By Lemma~\ref{lem:excludecycle8}, the distance in  between  and  is at most . 
We take a shortest path  from  to  in .
Then by Lemma~\ref{lem:pathtoobs}, 
 contains an induced subgraph isomorphic to either \house, \gem, \domino, or an induced cycle  of length  with .
As  was selected as a smallest induced cycle of length , if there is an induced cycle , then it has length at most . This contradicts the assumption that  is -free.






Thus, all vertices of  have pairwise distance at most  in . It implies that  for some .  Let us consider . Observe that  is a thread graph. The facts that  is -free and that  does not belong to a cycle of  of length  or more (see paragraph above), imply that  is -free and thereby a thread graph (Theorem~\ref{thm:structurethread}). By construction  is a thread graph with a canonical thread decomposition  where  and  is the directed path . So we apply Lemma~\ref{lem:extendthread} on  and . Let  be the resulting canonical thread decomposition of . Then  is a canonical thread decomposition of .
\end{proof}






\section{FPT algorithms for \LRWD}\label{sec:fptthreaddel}

In this section, we give two single-exponential FPT algorithms for the \LRWD problem.
Both FPT algorithms are based on branching algorithms that reduce an input graph to a -free graph.
We first show that one can easily find a minimum \DEL\ in a -free graph.
It implies that there is an FPT algorithm with running time  with a simple branching algorithm.
Next, we provide a way to reduce the polynomial factor  into  using an algorithm to find a fixed subgraph on graphs of bounded cliquewidth.
  


We prove the following.
\begin{proposition}\label{prop:nltothread2}
Given a -free graph , we can compute a minimum LRW1-deletion set of  in time .
\end{proposition}

We observe that every necklace graph can be turned into a thread graph by removing a vertex on the underlying cycle.



\begin{lemma} \label{lem:nltothread}
Let  be a connected necklace graph with the underlying directed cycle . For each ,  is a thread graph.
\end{lemma}
\begin{proof}
Let  be the directed cycle  on vertex set , where for each ,  is an arc. 
and let  be the set of thread blocks mergeable with  such that
.
Because of the symmetry, it is sufficient to show that  is a thread graph. 
As the pendent vertices of  that are adjacent to  become isolated vertices after removing , 
we may assume that  has no pendent vertices adjacent to . 
For each , let  and  be the ordering and labeling of , respectively.


Suppose that . 
Since  has no pendant vertices adjacent to , 
the vertex  is labelled either  or .
Let  be the restriction of  on , and
for each , let 

It is easy to check that  
is a thread block with the ordering  and labeling .
If , 
then we can regard  as the last thread block of .



Similarly, 
if , 
then we can regard  as the first thread block of .
Otherwise, we regard  as the first thread block.

Let  and .
We conclude that
 is a thread graph with the underlying directed path  
where

\end{proof}

\begin{proof}[Proof of Proposition~\ref{prop:nltothread2}]
Let  be a -free graph and let  be the minimum size of a LRW1-deletion set of .
By Theorem~\ref{thm:mainlrw},  each connected component of  is either a thread graph or a necklace graph.
For each component  of , we can test whether  is a thread graph or not in time  using Theorem~\ref{thm:charlrw1split}. 
By Lemma~\ref{lem:nltothread}, it is enough to remove exactly one vertex to make  each necklace component a thread graph.
Thus,  is equal to the number of its necklace components. 
Moreover, in each necklace component , we can identify a vertex  on the underlying cycle by testing whether  is a thread graph for every vertex  in .  
It takes a  time.
Therefore, we can find a minimum LRW1-deletion set of  in time .
\end{proof}


We give an FPT algorithm using a simple branching algorithm.

\begin{theorem}\label{thm:algorithm1}
The \LRWD problem can be solved in time .
\end{theorem}

\begin{proof}
Let  be an instance of the \LRWD problem where  is a graph on  vertices. 
First recursively find an induced subgraph of  isomorphic to a graph in  and branch by removing one of the vertices in the subgraph.
Because the maximum size of graphs in  is ,
we can find such a vertex subset in time  if exists.
In the end,
we transform the instance  into at most  sub-instances  such that each sub-instance consists of a -free graph  and a remaining budget . 
Thus, this branching step takes a time . 
Clearly,  is a \textsc{Yes}-instance if and only if one of sub-instances  is a \textsc{Yes}-instance.



Let  be a sub-instance obtained from the branching algorithm.
Since  is -free, 
using the algorithm in Proposition~\ref{prop:nltothread2}, 
we can compute a minimum LRW1-deletion set of  and decide whether  is a \textsc{Yes}-instance in time .
By checking all sub-instances, we can decide whether  is a \textsc{Yes}-instance in time . 
\end{proof}
Theorem~\ref{thm:algorithm1} already gives a single-exponential FPT algorithm for the \LRWD problem, but the polynomial factor  makes it impractical.
In the next subsection, we give an algorithm with better polynomial factor, using the branching algorithm based on a cliquewidth expression.

\subsection{Improving the polynomial factor}


The \emph{cliquewidth} of a graph  is the minimum number of labels needed to construct  using the following four operations:
\begin{enumerate}[(1)]
\item Creation of a new vertex  with label  (denoted by ).
\item Disjoint union of two labeled graphs  and  (denoted by ).
\item Joining by an edge each vertex with label  to each vertex with label  (, denoted by ). 
\item Renaming label  to  (denoted by ).
\end{enumerate}
Every graph can be defined by an algebraic expression using these four operations. 
Such an expression is called a \emph{-expression} if it uses at most  different labels. Thus, the cliquewidth of  is the minimum  for which there exists a -expression defining .


\begin{figure}\center
\begin{tikzpicture}[level distance=10mm]
\tikzstyle{level 1}=[sibling distance=30mm] 
\tikzstyle{level 6}=[sibling distance=15mm] 
\node {}
   child {node {} 
    child {node {}
      child {node {}
      child {node {}
	child {node {}
		child {node {}
		 	child {node {}}
			child {node {}}}}
        child {node {}
			child {node {}
		 	child {node {}}
			child {node {}}}	
			}}
		}}
    child {node {}}};
\end{tikzpicture}
\caption{-expression of .} 	\label{fig:c5expression}
\end{figure}

For instance, the cycle  of length  admits the following -expression:

We can represent this expression as a tree-structure, depicted in Figure~\ref{fig:c5expression}.
We call this tree the \emph{labelled tree induced by the -expression of }.

As we need the relation between rankwidth and linear rankwidth, we define rankwidth.
A tree is \emph{subcubic} if it has at least two vertices and every inner vertex has degree~. A pair  is called a \emph{rank-decomposition} of a graph  if  is a subcubic tree and  is a bijection from the vertices of  to the leaves of . For each edge  in ,  induces a partition  of the leaves of . The \emph{width} of an edge  is defined as . The \emph{width} of a rank-decomposition  is the maximum width over all edges of . The \emph{rankwidth} of  is the minimum width over all rank-decompositions of . If , then  admits no rank-decomposition and it has rankwidth .

The following approximation algorithm was given by Oum~\cite{Oum2006, OS2004}. 

\begin{theorem}[Oum~\cite{Oum2006, OS2004}]\label{thm:approxcw}
Given a graph  and positive integer , 
one can output a rank-decomposition of width at most  of  or confirm that the rankwidth of  is larger than  in time .
Moreover, given a rank-decomposition of a graph  of width , 
one can output a -expression of  in time .
\end{theorem}
Remark that the rankwidth of a graph can be decreased by at most  when removing a vertex, 
and the rankwidth of a graph is at most its linear rankwidth.
Thus, if a given graph has rankwidth larger than , then we cannot make it a graph of linear rankwidth at most  by removing at most  vertices.
Therefore, using the algorithm in Theorem~\ref{thm:approxcw}, we can assume that the instance is given with a -expression, and we can use it to find an induced subgraph of constant size. 

\begin{proposition}\label{prop:inducedoncw}
Let  be a graph on  vertices.
Given a graph  with its -expression, 
one can test whether  contains an induced subgraph isomorphic to  in time , 
and output a vertex set inducing  if exists, in the same time complexity.
\end{proposition}
\begin{proof}
Let  be the vertices of  and  be the edges of .
Let  be the given -expression defining , and  
let  be the labelled rooted tree induced by .
For every node  of , let  be the graph defined at node , and for each , let  be the subgraph of  induced on the vertices with label .






For every node  and every vector , 
we define the following value:






\begin{itemize}
\item 
   if there exists an injective mapping  from  to  such that      
   \begin{itemize}
      \item  for each , ,
	\item for each  with , we have , , and ,
	\item for each  with ,  and , we have ,
	\end{itemize}
\item , otherwise.
\end{itemize}
The values  will capture all possible inequivalent subgraphs of  at , where two subgraphs are equivalent if their corresponding vertices are in the same labels.
A vector  is \emph{complete} if for each  and , 
 and  are non-zero. 
One can observe that  contains an induced subgraph isomorphic to  if and only if 
there is a complete vector  such that .
A vector  is called a \emph{sub-vector} of  
if for each  and ,  and .


Now, we present how the values of  are computed.
At each node , we compute the value  as follows.

\begin{enumerate}
\item (Creation of a new vertex  with label )
Each vertex of  can be mapped to . 
Thus, for each vector  where exactly one of  is  and  for all , 
we assign  and for all other vectors, assign .
\item (Disjoint union node with two children ) 
	We take all possible two sub-vectors  and  of  
	such that 
	\begin{itemize}
	\item for each , 
	if  is non-zero, then exactly one of  and  is equal to , and 
	the same thing holds for  , , and . 
	\end{itemize}	
We assign  if there exist such  where , 
and  otherwise.
	This formula holds because 
	 contains a subgraph  if and only if there is a vertex partition  and  of  with no edges between  and  such that
	 is a subgraph of  and  is a subgraph of  ( or  may be an empty set). 
	This also implies that for a vector  with  and , it suffices to consider a pair  which satisfies either of the following: 
	, or . 
	

	Note that there are at most  possible pair of vectors.
	Thus, we need  iterations to compute  for fixed .
	In total, we need  iterations to compute  for all . 
\item (Join node with the child  such that each vertex with label  is joined to each vertex with label )
      If there are  and  where  with ,  and 
      , then we assign . This correctly assigns the value as two vertices with labels  and  should be adjacent at this join node.
      We can check it in time .
      Now, we assume that the given vector  satisfies that for all  and  with  with  and ,
      we have  .
      
      We take all sub-vectors  of  
	such that for ,   
	\begin{itemize}
	\item  if  with ,  , and , and 
	\item  otherwise.
	\end{itemize} 
Then we assign  if there exists such  where , 
and  otherwise.
This formula holds because 
	 contains a subgraph  if and only if  contains a subgraph 
	where
	 is obtained from  by adding edges between  and .
		
   Note that there are at most  possible sub-vectors.
Thus, we need  iterations to compute  for all . 
      
\item  (Renaming label  to )
	If there is  with , then we assign . This correctly assigns the value as there is no vertex with label  at this node.
	 We can check it in time .
    We assume that the given vector  satisfies that 
    for all , .

For each vector , 
     we take all sub-vectors  of  
	such that for , 
	\begin{itemize}
	\item  if , and 
	\item  otherwise.
	\end{itemize}
We assign  if there exists such  where , 
and  otherwise.
This formula trivially holds as we just change the labels on vertices.

   Note that there are  possible vectors.
Thus, we need  iterations to compute  for all . 
\end{enumerate}







Finally, we can test whether  contains an induced subgraph isomorphic to  by checking 
whether there is a complete vector  such that .
Thus, we can find an induced subgraph of  isomorphic to  in time , if exists.
Also, if we find such a vector , then we can track which vertices are contributed to make the vector , 
and thus, we can compute a vertex set inducing  in the same time complexity.
\end{proof}

 Now, we give a second FPT algorithm for the \LRWD problem.
\begin{theorem}\label{thm:algorithm2}
The \LRWD problem can be solved in  time.
\end{theorem}

\begin{proof}
All procedures in the algorithm will be same as in Theorem~\ref{thm:algorithm1} except the refined branching algorithm. 
Let  be an instance where  is a graph on  vertices.
Using the algorithm in Theorem~\ref{thm:approxcw}, we can decide whether the rankwidth of  is at most  in time .
If the rankwidth of the input graph is more than , then we cannot make it a graph of linear rankwidth at most  by removing at most  vertices.
Thus, we say that it is a \NO-instance in this case.
Otherwise, the algorithm outputs a -expression  of .
Let  be the labelled rooted tree induced by .
For convenience let . 


Let us fix a graph  in .
Note that .
Using the algorithm in Proposition~\ref{prop:inducedoncw}, 
we can test whether  contains an induced subgraph isomorphic to  and outputs a vertex set inducing  if exists, in time .
If there is such a vertex set , then 
branch by removing one of the vertices  in  and decrease  by .
Note that we can obtain the cliquewidth expression for  from  just by removing the node introducing .
We recurse this branching algorithm until there are no such vertex sets .


Combining the remaining steps described in the proof of Theorem~\ref{thm:algorithm1}, 
it is easy to verify that the \LRWD problem can be solved in time .
\end{proof}






\section{A lower bound for \LRWD}\label{sec:lowerbound}
In this section, we show that the algorithm in Theorem~\ref{thm:main1} is best possible in some sense. 
Our lower bound is based on a well-known complexity hypothesis formulated by Impagliazzo, Paturi, and Zane~\cite{ImpagliazzoRF2001}.

\medskip
\medskip
	\textbf{Exponential Time Hypothesis (ETH).} There is a constant  such that \textsc{3-CNF-SAT} with  variables and  clauses cannot be solved in time .

\medskip
\medskip



We use the known lower bound for the \textsc{Vertex Cover} problem.


\smallskip
\noindent
\fbox{\parbox{0.97\textwidth}{
{\sc Vertex Cover} \\
\textbf{Input :} A graph , a positive integer  \\
\textbf{Parameter :}  \\
\textbf{Question :} Does  have a vertex subset  of size at most  such that  has no edges?} }

\begin{theorem}[Cai and Juedes~\cite{Cai2003}]\label{thm:vclow}
There is no -time algorithm for \textsc{Vertex Cover}, unless ETH fails.
\end{theorem}

We show the following.

\begin{theorem}
There is no -time algorithm for \textsc{LRW1 Vertex Deletion}, unless ETH fails.
\end{theorem}
\begin{proof}
For contradiction, suppose there exists an algorithm for solving the \LRWD problem in time .
Let  be an instance of the \textsc{Vertex Cover} problem.
We construct a graph  from  as follows:
\begin{enumerate}[(1)]
\item for every vertex , add a pendant vertex  adjacent to , and
\item  for every edge  in , we replace it with two vertex disjoint paths of length 2 from  to .
\end{enumerate}
Let  be the resulting graph. 
Note that for each edge  in , 
 and two disjoint paths of length  from  to  in  form an induced subgraph isomorphic to .
We have .


We claim that  has a vertex set  of size at most  such that  has no edges  if and only if  has a \DEL\ of size at most .
Suppose that  has a vertex set  of size at most  such that  has no edges.
It is easy to confirm that  is a disjoint union of stars, which has linear rankwidth at most .

For the converse direction, suppose that  has a \DEL\  of size at most . 
If  contains a vertex of degree , then we can replace it with its neighbor.
We may assume that  has no pendant vertices of .
Let  be an edge of  and  be the vertices of degree  that are adjacent to  and  in .
As  does not contain pendant vertices of , we have , otherwise,  contains an induced subgraph isomorphic to .
For each edge , if  contains one of , then we replace it with one of  and . Let  be the resulting set.
Then  and  contains at least one of  and  for each edge  of .
We conclude that  has a vertex set  of size at most  such that  has no edges.







Therefore, using the algorithm for the \LRWD problem, we can decide whether  is a \YES-instance of the \textsc{Vertex Cover} problem, in time , 
which is not possible unless ETH fails by Theorem~\ref{thm:vclow}.
\end{proof}


\section{A polynomial kernel for \textsc{LRW1-Vertex Deletion}}\label{sec:polykerthreaddel}

In this section, we show the following.
\begin{theorem}\label{thm:main22}
The \LRWD problem has a kernel with  vertices.
\end{theorem}


We use the Sunflower lemma to find a hitting set for obstructions of small size with a special property. It consists in finding a subset  with size bounded by  for some function  whose removal turns  into a graphs of linear rankwidth at most  with the property that  for every set  of size at most , the following are equivalent (Lemma~\ref{lem:shrink}):
\begin{itemize}
\item  is a minimal vertex set such that  has no obstructions in . 
\item  is a minimal vertex set such that  has no obstructions in .
\end{itemize} 
This property implies that if there is a minimal LRW1-deletion set , then each vertex of  should be used to remove at least one long induced cycle.
It will be used to find an irrelevant vertex in a large thread block in .
Moreover, we can preprocess the instance so that 
there is no small obstruction containing exactly one vertex of . 
This will be used to bound the length of the sequence of thread blocks in each connected component.

Let  be an instance of {\sc LRW-Vertex Deletion}. 
We start with an easy reduction rule.

\begin{RULE}\label{rule:threadcomponent}
If  has a connected component that has linear rankwidth at most , 
then we remove it from .
\end{RULE}
\subsection{Hitting small obstructions}



Let  be a family of subsets over a set .  A subset  is called \emph{a hitting set} of  if for every set , . 
For a graph  and a family of
graphs , a set  is also called \emph{a hitting set} for  if for every induced subgraph  of  that is isomorphic to a graph in , . 
The following lemma can be obtained from the Sunflower lemma.
	 
\begin{lemma}[Fomin, Saurabh, and Villanger~\cite{FSV2012}]\label{lem:fomin}
Let  be a family of sets of size at most  over a set , and let  be a positive integer. Then in time , we can find a nonempty set  such that
\begin{enumerate}
\item  for every  of size at most ,  is a minimal hitting set of  if and only if  is a minimal hitting set of , and
\item .
\end{enumerate}
\end{lemma}

Using Proposition~\ref{prop:nltothread2} and Lemma~\ref{lem:fomin}, we identify a vertex set  of  with size polynomial in  that allows us to forget about small obstructions. 

\begin{lemma}\label{lem:shrink}
Let  be an instance of {\sc LRW-Vertex Deletion}. There is a polynomial time algorithm that either concludes that  is a \NO-instance or finds a non-empty set  such that
\begin{enumerate}
\item  has linear rankwidth at most ,
\item for every set  of size at most ,  is a minimal hitting set for  in  if and only if it is a minimal hitting set for  contained in , and
\item .
\end{enumerate}
\end{lemma}

\begin{proof}
Let  be the set of vertex sets  of  such that  is isomorphic to a graph in . 
Since the maximum size of a set in  is , 
using Lemma~\ref{lem:fomin}, we can find a subset  of  such that
\begin{enumerate}
\item   for every vertex subset  of size at most , 
	 is a minimal hitting set of  if and only if  is a minimal hitting set of , and
\item  .
\end{enumerate}

Let . 
From the condition 1,
 has no induced subgraph isomorphic to a graph in  and by Theorem~\ref{thm:mainlrw},  is a necklace graph.
Using the algorithm in Proposition~\ref{prop:nltothread2}, we can find a minimum LRW1-deletion set  of  in polynomial time.
If , then we conclude that  is a \NO-instance.
Otherwise, we add  to , increasing its size by at most .
We conclude that  is a required set.
\end{proof}

Let us fix a subset  of  obtained by Lemma~\ref{lem:shrink}.  
We preprocess using the following reduction rule.

\begin{RULE}\label{rule:onevertex}
Let  such that for every , there exists an induced subgraph  of  isomorphic to a graph in  with .
If , then  is a \NO-instance; otherwise, remove  from  and reduce  by , and use  instead of .
\end{RULE}
It can be done in polynomial time because we only need to look at obstructions of  in . 

\begin{lemma}\label{lem:oneintersect}
 Reduction Rule~\ref{rule:onevertex} is safe.
\end{lemma}
\begin{proof}
We claim that every minimal LRW1-deletion set in  contains .
Let  be a minimal LRW1-deletion set in . Then there exists a vertex subset  such that  is a minimal hitting set for graphs of  in . 
From the property of ,  is also a minimal hitting set for graphs of  in , and we must have  as  hits the sets  for each .
It implies that if , then  is a \NO-instance.
Otherwise, since  is always contained in any minimal LRW1-deletion set of , we have that   is a \textsc{Yes}-instance if and only if  is a \textsc{Yes}-instance.
\end{proof}

From now on, we assume that  is reduced under Reduction Rules~\ref{rule:threadcomponent} and \ref{rule:onevertex}.
A  vertex  of  is called \emph{irrelevant} if  is a \YES-instance if and only if  is a \YES-instance. 
For convenience, let .



\subsection{Bound on the size of connected components of }\label{subsec:boundcomp}


We first show that if a thread block in
 is large, then we can always find an irrelevant vertex in there.

\begin{proposition}\label{prop:irrelevant} If  contains a thread block of size at least , then we can find an irrelevant vertex
  in polynomial time.
\end{proposition}

We use the following lemma.

\begin{lemma}\label{lem:diamond}
Let  be a graph and let  be an induced path of length  in .
If two distinct vertices  in  are adjacent to  and ,
then  contains an induced subgraph isomorphic to a graph in . 
\end{lemma}
\begin{proof}
See Figure~\ref{fig:lemma65} for the following cases.
If  is adjacent to  but not adjacent to , then  is an induced path of length  and  is adjacent to its end vertices.
By Lemma~\ref{lem:pathtoobs},  has an induced subgraph isomorphic to a graph in .
Considering all symmetric cases, we may assume that 
for each , 
 is adjacent to both  or neither of them.
Depending on the adjacency between  and , and the adjacency between  and , we have one of the  graphs in , which are .
\end{proof}


\begin{figure}
\centerline{\includegraphics[scale=0.8]{figure7.pdf}}
\caption{Two cases in Lemma~\ref{lem:diamond}.  }\label{fig:lemma65}
\end{figure}



\begin{proof}[Proof of Proposition~\ref{prop:irrelevant}]
Suppose that  contains a thread block of size at least .
We can find such a thread block  and compute its ordering  and labeling  in polynomial time using the algorithm in Lemma~\ref{lem:splittreetothreadblock}.
Let  be the first and last vertices of  and let  be the ordering obtained from  by removing  and .

We mark some vertices of  as follows. We set . 
\begin{enumerate}[(1)]
\item For each vertex  of , choose the first  vertices  of  that are neighbors of  with , and choose the last  vertices  of  that are neighbors of  with , and add them to . 
\item For each pair of two vertices ,  in , choose  common neighbors of  and  in , and add them to . 
\item  Choose the first  vertices  of  with , and choose the last  vertices  of  with , and add them to .
\end{enumerate}
In each case, if there are at most  such vertices, then we add all of them to .
Then

Since , 
there exists a vertex  in .


We claim that  is an irrelevant vertex. 
 If  is a \YES-instance, then  is clearly a \YES-instance.

Suppose that there is a vertex set  with  such that  is a thread graph.
We may assume that  is not a thread graph.
So,  has an induced subgraph containing  that is isomorphic to a graph in . 
Let  be a minimal hitting set for  in .
From the property of the set ,  is a minimal hitting set for  in , which implies that .
Thus  must have an induced cycle of length at least  that contains .
Let  be an induced cycle of length at least  containing  in .

We will find an induced subgraph of  that is isomorphic to a graph in , which leads to a contradiction.
Let  be the consecutive vertices on .
To apply Lemma~\ref{lem:diamond}, we find two vertices that are adjacent to  and .
These cases are depicted in Figure~\ref{fig:irrelevant}.



\begin{figure}
\centering{\includegraphics[scale=0.8]{figure8.pdf}
\,\,\quad \includegraphics[scale=0.8]{figure9.pdf}}
\caption{Cases 1-3 in Proposition~\ref{prop:irrelevant}.} \label{fig:irrelevant}
\end{figure}




\begin{enumerate}
\item (Case 1. .) Since  and  have a common neighbor  in , 
 contains at least  common neighbors of  and .
Since , there exist two vertices  
that are common neighbors of  and .
\item (Case 2. One of  and  is contained in .) From the symmetry, we may assume that  and .
Since ,
 is contained in . If  and , then  contains the first  vertices 
of  that are neighbors of  with . We choose two vertices of them that are not in .
In case when  and , we use the last  vertices  of  that are neighbors of  with  to identify two vertices similarly.
\item (Case 3. Neither  nor  is contained in .)
Since ,  and  are contained in .
If , 
then ,  and it implies that , which is a contradiction.
Also,  cannot happen.
Thus, both of  and  appear either before  in  or after  in .
By the symmetry, we may assume that  and  appear before  in .
So, , , and .
Since  contains the last  vertices  of  with , there exist two vertices  from those  vertices that are not in  and .\end{enumerate}





In all cases,  has an induced subgraph isomorphic to a graph in  by Lemma~\ref{lem:diamond}. It contradicts to the assumption that  is a LRW1-deletion set of .
Therefore,  is a thread graph, and
we conclude that  is a \YES-instance.
\end{proof}

In the next lemma, we show that if a vertex  in  has neighbors on  distinct blocks in a connected component of , 
then we can find a subgraph  isomorphic to one of  such that , which is not possible by Reduction Rule~\ref{rule:onevertex}. 
Using it,  whenever a connected component of  has a long sequence of thread blocks, we can identify a sequence of consecutive thread blocks not touched by any
obstruction in . 
This allows us to contract one of these thread blocks to a vertex.


\begin{lemma}\label{lem:reducelength}
If  has a connected component with at least  thread blocks,
then we can in polynomial time transform  into a graph  with  such that  is a \textsc{Yes}-instance if and only if  is a \textsc{Yes}-instance.
\end{lemma}

\begin{proof}
Suppose that  has a connected component  such that  consists of at least  thread blocks.
We can find such a connected component in polynomial time  using the algorithm in Lemma~\ref{lem:splittreetothreadblock}, if exists. 
Let  be the sequence of thread blocks of .

We claim that every vertex  of  has neighbors in at most  thread blocks of . 
For contradiction, suppose that there is a vertex  in  having neighbors in at least  thread blocks.
Then there are three thread blocks  having a neighbor of  in  such that  
 and .
For each , let  be a neighbor of  in .
Since each thread block consists of at least two vertices, 
we can choose a neighbor  of  in  for each .
Depending on the adjacency between  and the vertices , 
we have an induced subgraph  isomorphic to a graph in  such that it has exactly one vertex of .
This contradicts to the assumption that 
 is an instance reduced by Reduction Rule~\ref{rule:onevertex}.

Now, for each vertex  of , we mark the thread blocks  of  containing a neighbor of .
Since the number of thread blocks in  is at least  and
,
there exist  and  such that
 are non-marked thread blocks.






Let  be the two end vertices of .
We transform the graph  into a graph  by removing the thread block  and adding a new vertex  that are adjacent to . 
Let  be the connected component of  that is modified from the connected component  of .
Since we remove at least two vertices from  and add one vertex, we have .



We show that  is a \textsc{Yes}-instance if and only if  is a \textsc{Yes}-instance.
Suppose that  has a minimal thread vertex set .
We first assume that  contains a vertex  in .  
Since  is a minimal LRW1-deletion set and all small obstructions of  are contained in ,  hits an induced cycle of length at least  in , and 
the cycle must pass through the vertices  and .
Thus,  is a LRW1-deletion set of  with size at most .

Assume that . 
We may assume that  is not a thread graph. 
Then  must have an induced cycle  of length at least  intersecting the new vertex .
The cycle obtained from  by replacing  with the edge  is also an induced cycle of length at least  in . It contradicts to the assumption that 
 is a thread graph.

Now suppose that  has a minimal LRW1-deletion set .
If , then  hits an induced cycle of length at least  in  because of the minimality of  and the distance from  to the end vertices of  and .
Because  hits all induced cycles of length at least  in  having a vertex of ,  is again a LRW1-deletion set of . 

Assume that . 
We may assume that  is not a thread graph.
So,  has an induced cycle  of length at least  passing through  and .
Let  be the cycle obtained from  by replacing the edge  with the vertex .
This cycle  clearly exists in  and it has length at least  because it should contain at least one vertex from the thread blocks  with .
This contradicts to the assumption that  is a thread graph.
We conclude that  is a \textsc{Yes}-instance if and only if  is a \textsc{Yes}-instance.
\end{proof}

\subsection{Kernel size}\label{subsec:kernelsize}


We bound the number of connected components using the following lemma.


\begin{lemma}\label{lem:reducecomponent1}
\begin{enumerate}[(1)]
\item The graph  has at most  connected components containing at least two vertices.
\item If  has at least  isolated vertices,
then we can find an irrelevant vertex in polynomial time.
\end{enumerate}
\end{lemma}

\begin{proof}
(1) By Reduction Rule~\ref{rule:threadcomponent}, 
each connected component  of  contains a vertex that has a neighbor in .
Let  be the set of connected components of  which consist of at least two vertices, and suppose that .
Since every connected component of  has a vertex having a neighbor in , 
there exists a vertex  such that  has neighbors in three distinct connected components of .
Since each connected component of  has at least two vertices, 
 has a vertex set  where  is isomorphic to a graph in  and . It contradicts to the assumption that  is reduced
by Reduction Rule~\ref{rule:onevertex}.

\medskip
(2) Suppose that  has at least  isolated vertices.
Let  be the union of isolated vertices in . 
We may assume that every vertex in  has a neighbor in . 
 
We define a set  to identify an irrelevant vertex.
For each pair of two vertices in , choose  common neighbors in , and add them to . If there are at most  common neighbors, then we add all of them into .
Since , there is a vertex  in .

 We claim that  is an irrelevant vertex of the problem. 
 If  is a \textsc{Yes}-instance,
 then there exists a vertex subset  of size at most  in  such that  is a thread graph.
 Since  is also a thread graph,  is a \textsc{Yes}-instance.
 
 Suppose that  is a \textsc{Yes}-instance.
 We choose a minimal vertex set  in  such that  and  is a thread graph.
 We may assume that  is not a thread graph.
 Let  be a hitting set for  in .
 Then by the property of ,  also hits all induced subgraphs in  that are isomorphic to a graph of .
 Since  already hits all small obstructions in ,
 there exists an induced cycle  of length at least  in  containing .


 
 Let  be the neighbors of  on the cycle .
 Since  have  common neighbors in , 
 we may choose two vertices  that are common neighbors of  and .
 By Lemma~\ref{lem:diamond}, we have that  has an induced subgraph isomorphic to a graph in ,
 which implies that  is not a thread graph. 
 It is a contradiction, and we conclude that  is a \textsc{Yes}-instance.
\end{proof}


Let us now piece everything together and analyze the kernel size.


\begin{proof}[Proof of Theorem~\ref{thm:main22}]
  Let  be an instance of {\sc LRW1-Vertex Deletion}. 
  By Reduction Rule~\ref{rule:threadcomponent}, we may safely assume that  has no connected components that are thread graphs. 
  Then using the algorithm in Lemma~\ref{lem:shrink}, in polynomial time, either we conclude that  is a \NO-instance or find a non-empty set  stated in Lemma~\ref{lem:shrink}.
  We apply Reduction Rule~\ref{rule:onevertex}.
Lemma~\ref{lem:oneintersect} guarantees that for every vertex set  such that  is isomorphic to a graph in , . 

Combining Proposition~\ref{prop:irrelevant} and  Lemma~\ref{lem:reducelength}, we can assume that every connected component of  has size at most   (otherwise the instance can be reduced in polynomial time). 
Note that for each connected component  of , there exists a vertex in  that has a neighbor in . Therefore, by Lemma~\ref{lem:reducecomponent1}, the number of non-trivial components of  is at most  and
the number of isolated vertices in  is at most .
It follows that

\end{proof}
\section{Concluding remarks}\label{sec:remark}

 

We consider the problem {\sc Linear rankwidth- Vertex Deletion} when . A next step is to investigate the problem for bigger , or for any fixed . A closely related problem is {\sc Rankwidth- Vertex Deletion}, which asks whether  has a vertex subset of size at most  such that  has rankwidth at most . {\sc (Linear) Rankwidth- Vertex Deletion} is fixed-parameter tractable for the following reason. Note that any \textsc{Yes}-instance has rankwidth at most . Having bounded (linear) rankwith can be characterized by a finite list of forbidden vertex-minors~\cite{Oum05}. From~\cite{CO2007}, having a vertex-minor can be expressed in , i.e., monadic second order logic without edge set quantification where we can express the parity of  for a vertex set . Fixed-parameter tractability follows as a consequence of Courcelle, Makowsky, Rotics~\cite{CourcelleMR00}. 

As for rankwidth, this result can be turned into a constructive algorithm as~\cite{Oum05} provides an explicit upper bound on the size of vertex-minor obstructions for rankwidth at most  for fixed . 
However, the exponential blow-up in the running time is huge with respect to both  and . It is a challenging question whether a reasonable dependency on  can be achieved. A single-exponential time would be ideal, which was achievable for its treewidth counterpart. A first realistic goal is to consider the case when , that is, the {\sc Distance-Hereditary Vertex Deletion}. We leave it as an open question whether this problem can be solved in time   time for some constant . For linear rankwidth, there is no known upper bound on the size of vertex-minor obstructions for linear rankwidth at most , and thus, obtaining such an upper bound is an interesting open question. 

\section*{Acknowledgment}
The third author would like to thank Sang-il Oum for suggesting the refined branching algorithm using cliquewidth.

\begin{thebibliography}{10}

\bibitem{AFP2013}
I.~Adler, A.~M. Farley, and A.~Proskurowski.
\newblock Obstructions for linear rank-width at most 1.
\newblock {\em Discrete Applied Mathematics}, 168:3--13, 2014.

\bibitem{AKK2014}
I.~Adler, M.~M. Kant{\'{e}}, and O.~Kwon.
\newblock Linear rank-width of distance-hereditary graphs.
\newblock In {\em Graph-Theoretic Concepts in Computer Science - 40th
  International Workshop, {WG} 2014, Nouan-le-Fuzelier, France, June 25-27,
  2014. Revised Selected Papers}, pages 42--55, 2014.

\bibitem{AdlerKK20152}
I.~Adler, M.~M. Kant\'e, and O.~Kwon.
\newblock Linear rank-width of distance-hereditary graphs {II}. vertex-minor
  obstructions.
\newblock {\em preprint}, arxiv.org/abs/1508.04718, 2015.

\bibitem{BM1986}
H.-J. Bandelt and H.~M. Mulder.
\newblock Distance-hereditary graphs.
\newblock {\em J. Combin. Theory Ser. B}, 41(2):182--208, 1986.

\bibitem{Bui-XuanKL13}
B.~Bui{-}Xuan, M.~M. Kant{\'{e}}, and V.~Limouzy.
\newblock A note on graphs of linear rank-width 1.
\newblock {\em preprint}, arxiv.org/abs/1306.1345, 2013.

\bibitem{Cai2003}
L.~Cai and D.~Juedes.
\newblock On the existence of subexponential parameterized algorithms.
\newblock {\em Journal of Computer and System Sciences}, 67(4):789 -- 807,
  2003.
\newblock Parameterized Computation and Complexity 2003.

\bibitem{Cao2015}
Y.~Cao.
\newblock Unit interval editing is fixed-parameter tractable.
\newblock In M.~M. Halldrsson, K.~Iwama, N.~Kobayashi, and B.~Speckmann,
  editors, {\em Automata, Languages, and Programming}, volume 9134 of {\em
  Lecture Notes in Computer Science}, pages 306--317. Springer Berlin
  Heidelberg, 2015.

\bibitem{CaoM2015}
Y.~Cao and D.~Marx.
\newblock Interval deletion is fixed-parameter tractable.
\newblock {\em ACM Trans. Algorithms}, 11(3):Art. 21, 35, 2015.

\bibitem{ChvatalH1977}
V.~Chv{\'a}tal and P.~L. Hammer.
\newblock Aggregation of inequalities in integer programming.
\newblock In {\em Studies in integer programming ({P}roc. {W}orkshop, {B}onn,
  1975)}, pages 145--162. Ann. of Discrete Math., Vol. 1. North-Holland,
  Amsterdam, 1977.

\bibitem{Cou90}
B.~Courcelle.
\newblock {The Monadic Second-Order Theory of Graphs. {I}. {R}ecognizable Sets
  of Finite graphs}.
\newblock {\em Information and Computation}, 85:12--75, 1990.

\bibitem{CourcelleK09}
B.~Courcelle and M.~M. Kant{\'{e}}.
\newblock Graph operations characterizing rank-width.
\newblock {\em Discrete Applied Mathematics}, 157(4):627--640, 2009.

\bibitem{CourcelleMR00}
B.~Courcelle, J.~A. Makowsky, and U.~Rotics.
\newblock Linear time solvable optimization problems on graphs of bounded
  clique-width.
\newblock {\em Theory Comput. Syst.}, 33(2):125--150, 2000.

\bibitem{CO2007}
B.~Courcelle and S.~Oum.
\newblock Vertex-minors, monadic second-order logic, and a conjecture by
  {S}eese.
\newblock {\em J. Combin. Theory Ser. B}, 97(1):91--126, 2007.

\bibitem{Cunningham1982}
W.~H. Cunningham.
\newblock Decomposition of directed graphs.
\newblock {\em SIAM J. Algebraic Discrete Methods}, 3(2):214--228, 1982.

\bibitem{CyganPPW2012}
M.~Cygan, M.~Pilipczuk, M.~Pilipczuk, and J.~Wojtaszczyk.
\newblock An improved fpt algorithm and a quadratic kernel for pathwidth one
  vertex deletion.
\newblock {\em Algorithmica}, 64(1):170--188, 2012.

\bibitem{Dahlhaus00}
E.~Dahlhaus.
\newblock Parallel algorithms for hierarchical clustering, and applications to
  split decomposition and parity graph recognition.
\newblock {\em Journal of Algorithms}, 36(2):205--240, 2000.

\bibitem{FominLMS12}
F.~V. Fomin, D.~Lokshtanov, N.~Misra, and S.~Saurabh.
\newblock Planar f-deletion: Approximation, kernelization and optimal {FPT}
  algorithms.
\newblock In {\em 53rd Annual {IEEE} Symposium on Foundations of Computer
  Science, {FOCS} 2012, New Brunswick, NJ, USA, October 20-23, 2012}, pages
  470--479, 2012.

\bibitem{FSV2012}
F.~V. Fomin, S.~Saurabh, and Y.~Villanger.
\newblock A polynomial kernel for proper interval vertex deletion.
\newblock {\em SIAM Journal on Discrete Mathematics}, 27(4):1964--1976, 2013.

\bibitem{FG04}
M.~Frick and M.~Grohe.
\newblock The complexity of first-order and monadic second-order logic
  revisited.
\newblock {\em Ann. Pure Appl. Logic}, 130(1-3):3--31, 2004.

\bibitem{Ganian10}
R.~Ganian.
\newblock Thread graphs, linear rank-width and their algorithmic applications.
\newblock In {\em Combinatorial algorithms}, volume 6460 of {\em Lecture Notes
  in Comput. Sci.}, pages 38--42. Springer, Heidelberg, 2011.

\bibitem{GanianH10}
R.~Ganian and P.~Hlinen{\'{y}}.
\newblock On parse trees and myhill-nerode-type tools for handling graphs of
  bounded rank-width.
\newblock {\em Discrete Applied Mathematics}, 158(7):851--867, 2010.

\bibitem{GaspersS12}
S.~Gaspers and S.~Szeider.
\newblock Backdoors to satisfaction.
\newblock In {\em The Multivariate Algorithmic Revolution and Beyond - Essays
  Dedicated to Michael R. Fellows on the Occasion of His 60th Birthday}, pages
  287--317, 2012.

\bibitem{GeelenGW2006}
J.~Geelen, B.~Gerards, and G.~Whittle.
\newblock On {R}ota's conjecture and excluded minors containing large
  projective geometries.
\newblock {\em J. Combin. Theory Ser. B}, 96(3):405--425, 2006.

\bibitem{GP2012}
E.~Gioan and C.~Paul.
\newblock Split decomposition and graph-labelled trees: characterizations and
  fully dynamic algorithms for totally decomposable graphs.
\newblock {\em Discrete Appl. Math.}, 160(6):708--733, 2012.

\bibitem{HallOS2007}
R.~Hall, J.~Oxley, and C.~Semple.
\newblock The structure of 3-connected matroids of path width three.
\newblock {\em European J. Combin.}, 28(3):964--989, 2007.

\bibitem{ImpagliazzoRF2001}
R.~Impagliazzo, R.~Paturi, and F.~Zane.
\newblock Which problems have strongly exponential complexity?
\newblock {\em Journal of Computer and System Sciences}, 63(4):512 -- 530,
  2001.

\bibitem{JeongKO2016}
J.~Jeong, E.~J. Kim, and S.~Oum.
\newblock Constructive algorithm for path-width of matroids.
\newblock In R.~Krauthgamer, editor, {\em Proceedings of the Twenty-Seventh
  Annual {ACM-SIAM} Symposium on Discrete Algorithms, {SODA} 2016, Arlington,
  VA, USA, January 10-12, 2016}, pages 1695--1704. {SIAM}, 2016.

\bibitem{JKO2014}
J.~Jeong, O.~Kwon, and S.~Oum.
\newblock Excluded vertex-minors for graphs of linear rank-width at most {}.
\newblock {\em European J. Combin.}, 41:242--257, 2014.

\bibitem{Kante2012}
M.~M. Kant{\'e}.
\newblock Well-quasi-ordering of matrices under {S}chur complement and
  applications to directed graphs.
\newblock {\em European J. Combin.}, 33(8):1820--1841, 2012.

\bibitem{KanteKKP2015}
M.~M. Kant{\'e}, E.~J. Kim, O.~Kwon, and C.~Paul.
\newblock {An FPT Algorithm and a Polynomial Kernel for Linear Rankwidth-1
  Vertex Deletion}.
\newblock In T.~Husfeldt and I.~Kanj, editors, {\em 10th International
  Symposium on Parameterized and Exact Computation (IPEC 2015)}, volume~43 of
  {\em Leibniz International Proceedings in Informatics (LIPIcs)}, pages
  138--150, Dagstuhl, Germany, 2015. Schloss Dagstuhl--Leibniz-Zentrum fuer
  Informatik.

\bibitem{Kashyap08}
N.~Kashyap.
\newblock Matroid pathwidth and code trellis complexity.
\newblock {\em SIAM J. Discrete Math.}, 22(1):256--272, 2008.

\bibitem{KLPRRSS13}
E.~J. Kim, A.~Langer, C.~Paul, F.~Reidl, P.~Rossmanith, I.~Sau, and S.~Sikdar.
\newblock Linear kernels and single-exponential algorithms via protrusion
  decompositions.
\newblock In {\em Automata, Languages, and Programming - 40th International
  Colloquium, {ICALP} 2013, Riga, Latvia, July 8-12, 2013, Proceedings, Part
  {I}}, pages 613--624, 2013.

\bibitem{KoutsonasTY2014}
A.~Koutsonas, D.~M. Thilikos, and K.~Yamazaki.
\newblock Outerplanar obstructions for matroid pathwidth.
\newblock {\em Discrete Math.}, 315:95--101, 2014.

\bibitem{Oum05}
S.~Oum.
\newblock Rank-width and vertex-minors.
\newblock {\em J. Comb. Theory, Ser. {B}}, 95(1):79--100, 2005.

\bibitem{Oum2006}
S.~Oum.
\newblock Approximating rank-width and clique-width quickly.
\newblock {\em ACM Trans. Algorithms}, 5(1):Art. 10, 20, 2008.

\bibitem{OS2004}
S.~Oum and P.~Seymour.
\newblock Approximating clique-width and branch-width.
\newblock {\em J. Combin. Theory Ser. B}, 96(4):514--528, 2006.

\bibitem{PhilipRV2010}
G.~Philip, V.~Raman, and Y.~Villanger.
\newblock A quartic kernel for pathwidth-one vertex deletion.
\newblock In D.~Thilikos, editor, {\em Graph Theoretic Concepts in Computer
  Science}, volume 6410 of {\em Lecture Notes in Computer Science}, pages
  196--207. Springer Berlin Heidelberg, 2010.

\bibitem{RS2004}
N.~Robertson and P.~D. Seymour.
\newblock Graph minors. {XX}. {W}agner's conjecture.
\newblock {\em J. Combin. Theory Ser. B}, 92(2):325--357, 2004.

\bibitem{BevernKM2010}
R.~van Bevern, C.~Komusiewicz, H.~Moser, and R.~Niedermeier.
\newblock Measuring indifference: unit interval vertex deletion.
\newblock In {\em Graph-theoretic concepts in computer science}, volume 6410 of
  {\em Lecture Notes in Comput. Sci.}, pages 232--243. Springer, Berlin, 2010.

\bibitem{VV2013}
P.~van't Hof and Y.~Villanger.
\newblock Proper interval vertex deletion.
\newblock {\em Algorithmica}, 65(4):845--867, 2013.

\end{thebibliography}

\end{document}
