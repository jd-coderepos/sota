In the following we prove that in presence of mobile Byzantine agents the MSR family of algorithms verifies the Byzantine Approximate Agreement specification. We first characterize configurations produced by a MSR algorithm in presence of static Byzantine faulty nodes. Then, we prove that each configuration produced in  presence of mobile Byzantine agents has the same characterization. Hence, the mobility of Byzantine agents does not affect the correctness of MSR family. 
Moreover, we prove that the necessary condition over the number of replicas in \cite{KA94} still holds in the Mobile Byzantine failures model with the mapping defined in the previous section. 




\subsection{Preliminaries}\label{ss:preliminaries} In the following we recall some definitions from \cite{DLPS86, KA94} :
\begin{itemize}
	\item{min(V):} min(; the minimum value of the elements in ;
	\item{max(V):} max(; the maximum value of the elements in ;
	\item{:} ; the real interval spanned by V.  is called the range of V;
	\item{:} ; the difference between the maximum and the minimum values of .  is called the diameter of V;
	\item{:} the multiset of values received in a given round  by non-faulty process . Let  {:} be the subset of  , the values generated by non-faulty processes \footnote{Since the communication graph is fully connected then this set is equal for any correct process}.
\end{itemize}

Now we can recall the important properties of  as proved in \cite{KA94}.
If   then the following two properties hold:
	\begin{itemize}
		\item[P1] For each non faulty process , the computed value is in the range of non faulty values, i.e., .
		\item[P2] For each pair of non faulty processes,  and , the difference between their computed values is strictly less than the diameter of the submultiset of non faulty values received, i.e., .
	\end{itemize}
In the following  denotes the value obtained at the end of round  (computation phase) by process , applying the MSR function vector .

\begin{definition}[correct value]
	Given a value ,  is said to be correct if it respects the two   function properties  and .
\end{definition}


\begin{lemma}\label{l:curedOnRound}
	Let  be the set of cured processes at the beginning of round  in the models {\bf M1-M4}. If   and every  executes computation-phase of a MSR-algorithm then at the end of  we have .
\end{lemma}

\begin{proofL}
	The proof is done by induction. 
During the first round  no Byzantine agent moved yet. Thus, at the end of  trivially . 
	In the next round  Byzantine agents move thus affecting up to  processes. Therefore, at the beginning of  there are up to  cured processes, . If we substitute, for each model {\bf M1-M4} (cf. Table \ref{tab:mapping}), values in  if follows that despite agents movement,  still holds. Thus, for the definition of  the value that each process computes at \emph{computation-phase} is correct. Hence, at the end of round  we have .
	For each further  the reasoning is similar.
	\renewcommand{\toto}{l:curedOnRound}
\end{proofL}

From Lemma \ref{l:curedOnRound} it follows that during each round there are not cured processes related to the previous round but only the ones due to the last Byzantine agents movement, hence the corollary below. 

\begin{corollary}\label{c:numberOfCured}
	Let  be the set of cured processes at the beginning of round . , .
\end{corollary}






\begin{definition}[configuration ]
Let configuration  be a set of  tuples failure state, proposing value representing the state of each process  at round . Note that processes, depending on the failure model, may or may not be aware of their failure state.
\end{definition}



\begin{definition}[]
Let   be a generic instance of the MSR family  and let  be the  execution of the protocol  at round , such that . It takes as input  and returns .
\end{definition}

\begin{definition}[static computation]
A sequence of   executions, such that   is said a static computation if in every configuration , there exists a subset of at least  correct processes that are correct during the whole computation. 
\end{definition}

Note that  with fixed , and , the relation  always holds in a static computation of a MSR algorithm (\cite{KA94}). 

\begin{definition}[mobile computation]
A sequence of   executions, such that   is said to be a mobile computation if for any two subsequent configurations , , any process may change the failure state but the relation  holds at each round. 
\end{definition}

\begin{definition}[configurations equivalence]
A configuration  is said to be equivalent to a configuration  if:
\begin{itemize}
\item  and 
produce the same ;
\item ,  has at least the same number of tuples  correct, correct value  as .
\end{itemize}
Note that in a static computation a correct process is correct for the whole computation, while in a mobile one is correct with respect to the observed round. 
\end{definition}

\begin{definition}[correct computation]
A computation  is a correct computation if it is possible to build a static computation  such that, ,  is equivalent to . 
\end{definition}

\begin{observation}\label{o:correctConf}\cite{KA94}
Given a static computation  of an algorithm in the MSR class, if , then 
each configuration , is characterized as follows:
\begin{itemize}
\item up to  asymmetric Byzantine processes;
\item up to  symmetric Byzantine processes;
\item up to  benign faults;
\item at least  correct processes such that  each  of them computes a correct value .
\end{itemize}
\end{observation}

The first three points are due to the failures static nature. The last one is given by the failures static nature plus the correctness of the algorithm in the static case (as proven in \cite{KA94}).


\subsection{MSR correctness under Mobile Byzantine fault model}
In the following we prove that despite Byzantines mobility, the MSR family of algorithms verifies the Approximate Agreement specification. In the presence of mobile Byzantine agents, each round is characterized by correct, cured and faulty processes. As we showed previously, depending on the failure model considered, cured processes behave accordingly to a different kind of fault (asymmetric, symmetric or benign). 



The following theorem proves the mapping between the Mobile Byzantine faults model and the Mixed-mode fault model. Let us start proving that if  then a mobile computation is also a correct computation, as defined in subsection \ref{ss:preliminaries}.
\begin{theorem}\label{l:mapping}
Let us consider a mobile computation  of an algorithm   in the class MSR. If in each round  (cf. Table \ref{tab:mapping2}) then the sequence  is a correct computation.
\end{theorem}

\begin{proofT}
We have to show that for each iteration of  we can build a static computation equivalent to the dynamic one. The proof is done by induction. Let us denote by ,  and  the set of correct, cured and Byzantine processes respectively and let  denote the cardinality of . Let us denote, in the static case, by , , and  the set of correct, non correct (which may be asymmetric, symmetric, or benign), and asymmetric faulty processes, respectively, and let  denote the cardinality of .

\begin{itemize}
\item{Rounds :} At the begining of round 0, Byzantine agents never move. Thus, the configuration is as follows: 
\begin{itemize} 
\item{}: , ;
\item{}:  \footnote{We use  to indicate that it can be any value} , .
\end{itemize}
The protocol executes its first iteration. 
Processes exchange their value and each non Byzantine process  updates its state: failure state, proposing value  . 
At this point the situation is as follow:
\begin{itemize}
\item{}: , ;
\item{}: , .
\end{itemize}
Up to now, the same happens in a static computation. 
At the begining of round 1, at most  Byzantine agents move affecting other processes. Thus there are up to  cured processes storing a non correct value (e.g., ). 
\begin{itemize}
\item{}: , ;
\item{}: , ;
\item{}: , .
\end{itemize}
At the begining of round 1, there are at least  correct processes. If we map it to the Mixed-mode failures model (cf. Table \ref{tab:mapping}), this is equivalent to a static configuration where there are  asymmetric processes and  non correct that may be asymmetric, symmetric or benign:
\begin{itemize}
\item{}: , ;
\item{}: , ;
\item{}: , .
\end{itemize}
The mobile and static configurations are equivalent (cf. Observation \ref{o:correctConf}). Thus the current mobile configuration (and the mobile computation up to now) is correct.


\item{Rounds :} From the previous point, the configuration at the beginning of round 1 is correct. The second iteration of the protocol takes place. Processes exchange their value and each non Byzantine process  updates its state: failure state, proposing value . At this point, for Lemma \ref{l:curedOnRound}, each process in  becomes correct. In other words, there are up to  Byzantine processes and at least  correct processes. We are in the same situation as at the end of previous round .\\
At the beginning of next round, at most  Byzantine agents can move to other processes, leaving up to  cured processes with non correct value. 
Thus there are at least  correct processes at the begining of round 2. The mobile and static configurations are equivalent (cf. Observation \ref{o:correctConf}). Thus the current mobile configuration (and the mobile computation up to now) is correct.
\item{Rounds :} generalizing, for each round starting with a correct configuration we can apply the previous reasoning ending in a subsequent round characterized by a correct configuration.
\end{itemize}
\renewcommand{\toto}{l:mapping}
\end{proofT}


In the following we prove the correctness of any algorithm in the class MSR under Mobile Byzantine failure model.
\begin{lemma}[Termination]\label{l:termination}
	Let  be an algorithm in the class MSR.   If ,  under Mobile Byzantine fault model verifies the \emph{Termination} property of the Byzantine Approximation Agreement.
\end{lemma}

\begin{proofL}
From Theorem \ref{l:mapping}, if  then algorithm  generates a sequence of correct configurations, i.e., a sequence of converging values exactly as in \cite{DLPS86,KA94}, thus the Termination property is satisfied in the same way this is satisfied by the \cite{DLPS86,KA94} solutions.	
	\renewcommand{\toto}{l:termination}
\end{proofL}

\begin{lemma}[-Agreement]\label{l:agreement}
Let  be an algorithm in the class MSR.   If ,  under Mobile Byzantine fault model verifies the \emph{-Agreement} property of the Byzantine Approximation Agreement.
\end{lemma}

\begin{proofL}
From Theorem \ref{l:mapping}, if  then algorithm  generates a sequence of correct configurations, i.e., a sequence of converging values exactly as in \cite{DLPS86,KA94}. Thus, the -Agreement property is satisfied in the same way this is satisfied by the \cite{DLPS86,KA94} solutions. 

In the following we prove that once -Agreement is achieved among the currently non faulty processors, it is preserved among the (possible different) uninfected processors.
	Let us consider an arbitrarily long mobile computation . If -Agreement is achieved then there exists a round  where all non faulty processes agree on values that are  close to each other. Considering that  then from Theorem \ref{l:mapping} the whole mobile computation  is correct. Thus from round to round the two properties  and  hold and correct processes values can not diverge from each other.

\renewcommand{\toto}{l:agreement}
\end{proofL}

\begin{lemma}[Validity]\label{l:validity}
Let  be an algorithm in the class MSR.   If ,  under Mobile Byzantine fault model verifies the \emph{Validity} property of the Byzantine Approximation Agreement.
\end{lemma}

\begin{proofL}
	From Theorem \ref{l:mapping}, if  then algorithm  generates a sequence of correct configurations, i.e., a sequence of converging values exactly as in the validity proof in \cite{DLPS86,KA94}. 
\renewcommand{\toto}{l:validity}
\end{proofL}









The three above lemmas provide the proof of the theorem below.
\begin{theorem}\label{t:mapping}
If  then the class  MSR verifies the Byzantine Approximate Agreement specification.
\end{theorem}
%
