\documentclass[10pt]{article}

\usepackage{latexsym}
\usepackage{theorem}
\usepackage{color,graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[OT4]{fontenc}

\newenvironment{proof}[1][Proof]
{\par\noindent{\bf #1:} }{\hspace*{\fill}\nolinebreak{}\bigskip\par}

\newcommand{\qed}{\hspace*{\fill}\nolinebreak\ensuremath{\Box}}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\theorembodyfont{\upshape}
\newtheorem{definition}{Definition}


\newcommand{\Alg}{{\tt CST}}
\newcommand{\FindMinimal}{{\tt MCPS}}

\newcommand{\w}{\widetilde}
\newcommand{\jobs}{\mathcal{J}}
\newcommand{\ms}{\textup{ms}}
\newcommand{\nat}{\mathbb{N}}

\newcommand{\tds}{\textup{TDS}}
\newcommand{\csp}{\textup{CS}}
\newcommand{\csfp}{\textup{CS}_{\textup{F}}}

\newcommand{\strategyR}{\mathcal{R}}
\newcommand{\strategy}{\mathcal{S}}
\newcommand{\collection}{\mathcal{C}}
\newcommand{\border}{\delta}
\newcommand{\clearE}{C_{\textup{E}}}

\newcommand{\sn}{\textup{\texttt{s}}}
\newcommand{\msn}{\texttt{ms}}
\newcommand{\isn}{\textup{\texttt{is}}}
\newcommand{\misn}{\textup{\texttt{mis}}}
\newcommand{\csn}{\textup{\texttt{cs}}}
\newcommand{\mcsn}{\textup{\texttt{mcs}}}

\begin{document}


\title{Connected searching of weighted trees}

\author{Dariusz Dereniowski\thanks{Partially supported by the Foundation for Polish Science (FNP) and by the Polish Ministry of Science and Higher Education (MNiSW) grant N~N206~379337.}\\
       Department of Algorithms and System Modeling,\\
       Gda\'{n}sk University of Technology, Poland\\
       \small{deren@eti.pg.gda.pl}}

\maketitle


\begin{center}
\parbox[c]{10 cm}{
\textbf{Abstract:} In this paper we consider the problem of connected edge searching of weighted trees. It is shown that there exists a polynomial-time algorithm for finding optimal connected search strategy for bounded degree trees with arbitrary weights on the edges and vertices of the tree. The problem is NP-complete for general node-weighted trees (the weight of each edge is ).
}
\end{center}

\vspace{5 pt}


\textbf{Keywords:} connected searching, graph searching, search strategy

\section{Introduction}
\label{sec:intro}

Given a simple undirected graph , a fugitive is located on an edge of . The task is to design a sequence of moves of a team of searchers that results in capturing the fugitive. The fugitive is invisible for the searchers -- they can deduce the location of the fugitive only from the history of their moves; the fugitive is fast, i.e. whenever he moves, he can traverse a path of arbitrary length in the graph, as long as the path is free of searchers. Finally, the fugitive has a complete knowledge about the graph and about the strategy of the searchers, which means that he will avoid the capture as long as it is possible. The allowable moves for the searchers are, in general, placing a searcher on a vertex, removing a searcher from a vertex and sliding a searcher along an edge of . An edge is \emph{clear} if it cannot contain the fugitive. Capturing the fugitive is then equivalent to clearing all the edges of . The minimum number of searchers sufficient to clear the graph is the \emph{search number} of , denoted by . The edge searching problem has been introduced by Parsons in~\cite{Parsons76}. The corresponding node searching problem was first studied by Kirousis and Papadimitriou in~\cite{searching_and_pebbling}. For surveys on graph searching problems see~\cite{guaranteed_graph_searching} or~\cite{searchng_and_sweeping}.

A key property of a search strategy is the monotonicity. A search is \emph{monotone} if the strategy ensures that the fugitive cannot reach an edge that has been already cleared. For most graph searching models it has been proven that there exists an optimal search strategy that is monotone. The minimum number of searchers needed to construct a monotone search strategy for  is denoted by .
We have that recontamination does help for connected~\cite{sweeping_large_cliques} and connected visible search \cite{monotony_properties_connected_visible}. Moreover, the difference between  and  can be arbitrarily large for some graphs ~\cite{sweeping_large_cliques}. However, if  is a tree then ~\cite{connected_weighted_trees}.

We say that a search is \emph{internal} if removing the searchers from the graph is not allowed, while for the search to be \emph{connected} we require that after each move of the searchers, the subgraph of  that is clear is connected. The minimum number of searchers required for each connected search strategy of  is called the \emph{connected search number} of , denoted by . The corresponding monotone connected search number is denoted by .

Clearly  for each graph , since each connected search strategy is also a search strategy. Some upper bounds for the connected search number are known, in particular , where  is a tree~\cite{searching_not_jumping}. Connected search number is at most , where  equals the branchwidth of  \cite{price_of_connectedness}. The latter implies that , where  is a fixed number, which is also a consequence of the results in \cite{connected_treewidth}. For the search with visible fugitive both search numbers are equal~\cite{connected_treewidth}.

Several algorithmic results for connected searching of special classes of graphs are know, including chordal graphs~\cite{connected_searching_chordal_graphs}, hypercubes~\cite{hypercubes,contiguous_hypercube}, a pyramid~\cite{pyramid}, chordal rings and tori~\cite{chordal_rings_tori}, or outerplanar graphs~\cite{connected_outerplanar}.
For results on searching planar graphs with small number of searchers and small number of connected components of the cleared subgraph see~\cite{Nowakowski_flooding}.

Authors in~\cite{connected_weighted_trees} provided an efficient algorithm for searching weighted trees. However, their algorithm does not always produce an optimal solution (the tree in Figure~\ref{pic:extensions} in Section~\ref{sec:searching_trees} may serve as an example), which results in an approximation algorithm. The complexity status of searching weighted trees turns out to be NP-complete, which we prove in this work.

This paper is organized as follows. In the next section we give the necessary definitions. In Section~\ref{sec:searching_trees} we analyze the basic properties of connected searching of weighted trees.\footnote{A different model of edge searching of weighted graphs, than the one considered here and in~\cite{connected_weighted_trees}, has been recently introduced in~\cite{edge_searching_weighted_graphs}.} Then, in Section~\ref{sec:bounded_degrees}, we give an algorithm for computing optimal search strategies for weighted trees. The algorithm is exponential in the maximum degree of a tree. Thus, it is designed for trees of bounded degree. Section~\ref{sec:hard} deals with the complexity of searching trees. In Subsection~\ref{subsec:reduction} we prove that finding an optimal connected search of a weighted tree is strongly NP-hard, i.e. it is NP-hard for trees with integer weight functions with polynomially (in the size of the tree) bounded values on the vertices and edges. This justifies the exponential, in general, running time of the algorithm. In order to present the proof we need a preliminary result that a special instance of scheduling time-dependent tasks is NP-complete, which is proven in Subsection~\ref{subsec:time-dependent}.


\section{Preliminaries}
\label{sec:preliminaries}

In the following we assume that all the graphs  are connected, i.e. there exists a path between each pair of vertices of . The sets  and  are, respectively, the vertices and the edges of , while  is a weight function. ( is the set of positive integers.) We start with a formal definition of the Connected Searching problem ().

\begin{definition}
Let  be an integer. Initially all the edges of a weighted graph  are \emph{contaminated}. A \emph{connected -search strategy}  starts by placing  searchers on an arbitrary \emph{starting vertex}  of . Each move of  consists of sliding  searchers along an edge . If  is contaminated, then we require , and  becomes \emph{clear}. An edge  becomes \emph{contaminated} if there exists a contaminated edge  and less than  searchers occupy . The subgraph that is clear has to be connected after each step of . After the last move of  all the edges of  are clear.
\end{definition}

Given any strategy ,  is the number of searchers used by ,  is the number of moves in  and  is its th move, . For each ,  is the set of vertices , occupied by searchers at the end of move , such that there exists a contaminated edge incident to . We say that the vertices in  are \emph{guarded} in step . In other words, if at the end of move  there exists a vertex  and less than  searchers occupy , then a recontamination occurs.

The smallest number  for which a connected -search strategy  exists is called the \emph{connected search number} of , denoted by . The minimum number of  searchers such that there exists a monotone connected -search for  is called the \emph{monotone connected search number} of , and is denoted by . If a (monotone) connected search strategy  uses ()  searchers, i.e. (respectively ) , then  is called an \emph{optimal} (monotone) connected search strategy for .

Forcing a connected search strategy to have different starting vertices results in different number of searchers required to clear a graph . The problem where the starting vertex is a part of the input is denoted by  (Connected Searching problem with Fixed starting vertex).

The number of searchers used for guarding at the end of step  is denoted by . Note that

The searchers which are not used for guarding in a given step , called \emph{free} searchers in step . In particular, if more than  searchers occupy , then  of them are guarding , while the remaining ones are considered to be free. Free searchers can move arbitrarily along the clear edges until the next move , , which clears an edge , where . The move  can be performed only if the required number of  searchers (with  free searchers among them), which will slide along  in , is at . So, each move among  which is not necessary for gathering the  searchers for clearing  in  can be performed after . Moreover, each set of  searchers, which are free at the end of move , can be used to clear  in . For this reason, we do not list the moves of sliding searchers along clear edges. Thus, due to this simplifying assumption, .

We say that a strategy is \emph{partial} if it clears a subset of edges of . Given a search strategy  for , the symbol  is used to denote the partial search strategy containing the moves . Clearly, if  is connected, then  is also connected. Given a partial search strategy , we extend our notation so that  is the set of guarded vertices after the last move of , . The symbol  denotes the set of edges cleared by a partial strategy . In particular, if  clears , then  and .


\section{Searching trees -- basic properties}
\label{sec:searching_trees}

We are able to make several simplifying assumptions on connected search strategies once we consider the  problem for weighted trees .

In Sections~\ref{sec:bounded_degrees} and~\ref{sec:hard} we provide the algorithm for  problem on bounded degree trees and a polynomial-time reduction from a NP-complete problem to the  problem for general trees. In both cases we conclude that the corresponding result (an efficient algorithm or a polynomial-time reduction) holds for the  problem on trees as well. We will use the symbol  to denote the minimum number of searchers needed to clear  when  is the starting vertex. Then,

To simplify the notation, all trees  are rooted at . In the remaining part of this paper we consider the  problem with the starting vertex .

Given a tree  rooted at ,  is the set of edges between  and its descendants, , and  is the subtree of  rooted at .

For each tree  it holds ~\cite{connected_weighted_trees}. Thus, in what follows each connected search strategy is monotone. As mentioned in Section~\ref{sec:preliminaries}, we only list the clearing moves of a search strategy , which implies .

Consider a connected search strategy  for . Let  be a move of clearing an edge . If  is a leaf, then the number of searchers that need to slide along  to clear it in step  is . When  gets clear at the end of move , there is no need to guard , which means that the searchers that reach  in  are free at the end of the move . This holds regardless of the weight of , . Similarly, if  is a leaf, then  and  and it is easy to see that  searchers suffice to clear , and  does not have to be guarded at the end of move . So, we may w.l.o.g. assume that

The number of searchers that slide along ,  is a son of , is  for all edges . This follows from~(\ref{eq:leaf}) when  or  is a leaf, while in the remaining cases  searchers are needed to clear , and there have to be at least  searchers at  at the end of  to avoid recontamination. Thus, if the search is required to be connected and  then  searchers which are not necessary for clearing  follow along  together with the  searchers that clear the edge.

Our next simplifying assumption is considering only node-weighted trees, and we argue that it does not lead to losing generality. Given a connected search strategy  for  with starting vertex , consider a move  of clearing an edge , where  is a son of . At the beginning of  the vertex  is unoccupied and  is guarded by  searchers. To clear  we need to slide  searchers along . If , then by~(\ref{eq:leaf})  is not a leaf of , which means that at the end of move  at least  searchers have to occupy . This means that we have to slide  searchers along  regardless of . Thus, we may assume that if , then . As a result, for each edge , where  is the father of  we have


Consider now a new tree  obtained from  by replacing each edge  by two edges  and , where  is a new vertex of  corresponding to the edge  of . Let  and  for each  and let  for each . Clearly, .

For an example of all the transformations given above see Figure~\ref{pic:simplify}.
\begin{figure}[htb]
\begin{center}
\includegraphics[scale=1]{simplify.eps}
\caption{(a) a rooted tree with node and edge weights;
         (b) the weight of each leaf is ;
         (c) the corresponding tree satisfying~(\ref{eq:edge-weights});
         (d) the node-weighted tree  obtained from }
\label{pic:simplify}
\end{center}
\end{figure}

\begin{lemma} \label{lem:edges_unweighted}
For each  and its corresponding tree ,  for each .
\end{lemma}
\begin{proof}
Given a connected search strategy  for , we create a connected search strategy  for  as follows. Each move , , clearing an edge , where  is the father of , is replaced by two moves  and  of clearing the edges  and , respectively. A simple induction on the number of moves in  allows us to prove that . Indeed, by~(\ref{eq:edge-weights}), clearing  in  requires  searchers excluding the searchers used for guarding, and by the definition of ,  searchers are sufficient to clear  and  resulting in the same set of guarded vertices in  and  after moves  and , respectively. This proves that .

Let  be a connected search strategy for . We may w.l.o.g. assume that if  clears an edge , where  is a son of  then, a move of clearing  follows, because  by~(\ref{eq:edge-weights}). Two consecutive moves of clearing  and  in  can be translated into clearing  in a connected search strategy which requires  searchers. Thus, , and consequently . This proves that .
\end{proof}

In the remaining part of this paper we assume that the weight of each edge  is .

\begin{definition}
Let  and  be partial search strategies for , where . We define a search strategy  as follows:
\begin{list}{}{}
\item[1.]  for each ,
\item[2.] , , clears the edge cleared in the move , while the set of guarded vertices at the end of the move  is , where  is the set of vertices initially occupied by .
\end{list}
\end{definition}
In other words,  clears all the edges cleared by  and  in the order corresponding to the moves .
Note that in particular we have that  for each , and  for each .
Furthermore, for  to be a partial connected search starting at ,  has to be a partial connected search with starting vertex , however,  does not have to be connected, but the requirement is that after each step of , each subgraph cleared by  has to have a common vertex with .

\begin{definition}
Given a tree  rooted at , a vertex , and an integer . We say that a partial connected -search  for , , is -\emph{minimal} if  and  for each partial connected -search  for .
\end{definition}
A strategy  is \emph{not minimal} if there exists no  such that  is -minimal.
We say that a partial connected search strategy  for  can be \emph{extended} to a connected -minimal search for  if there exists a search strategy  such that  is a connected -minimal search for . This in particular implies that . Given a  and ,  is a set of maximal rooted subtrees induced by the edges in .

\begin{lemma} \label{lem:minimal_S_v}
A partial (not minimal) connected search strategy  for  can be extended to a -minimal search for  if and only if there exist  (rooted at ) in  and a partial -minimal connected search  for , such that  can be extended to a partial -minimal search for .
\end{lemma}
\begin{proof}
The ``only if'' part is obvious. To prove the ``if'' part let  be a -minimal partial connected search for . For each  there exists a contaminated edge in , which gives that there exists in  a nonempty subtree  rooted at . (If all edges in  are contaminated, then .) First we argue that there exist  and a partial -minimal connected search  for . For each  and for each move  define . Find minimum  such that  for some . Such an integer  does exist, because otherwise  which contradicts the minimality of . Let  be  restricted to the edges in . By the minimality of ,  uses at most  searchers (which gives that ), and . So, the set of partial -search strategies  for  satisfying  is nonempty and, by the definition, a strategy  with the minimal  is -minimal.

We will use  to extend  to a partial -minimal connected search  for . To obtain  we simply remove from  all the operations of clearing the edges in , preserving the order of clearing the remaining edges in . One can prove that  is connected.

Since , it remains to prove that . By the definition, , so let us consider a move  of clearing an edge , . Select  so that  is the move of clearing . Now we prove that . Let

In other words,  is the set of vertices guarded in step  of  but unguarded in step  of . Clearly, . For each  there exists a vertex  on the path connecting  and  in . Let  be the set of all such vertices , . We have that

To prove~(\ref{eq:X_U}) assume for a contradiction that it does not hold. Find a set , with minimum , such that each path connecting  and , , contains a vertex in  (possibly ). We have , because . Let us create  which clears the edges in

in the same order as they are cleared in . We have  and . Thus,  is not -minimal --- a contradiction, which proves~(\ref{eq:X_U}). Hence, . Since  has been chosen arbitrarily, we have proven the thesis.
\end{proof}

As an example consider a tree in Figure~\ref{pic:extensions}(a). Assume that we start by clearing three edges , ,  (in this order) and let  by such a partial search strategy. We have that  and . Let us look at search strategies for selected subtrees. Denote by , ,  and  search strategies for , ,  and , respectively, such that the branches of the corresponding subtrees are cleared starting with the one on the left hand side, while the right branch is cleared last in all cases. They are \mbox{-,} \mbox{-,} \mbox{-} and -minimal, respectively. Also, there exist a partial -minimal search  for  with  (this strategy clears the two edges on the path connecting  and ) and a partial -minimal search strategy  for , where  ( clear the three edges on the paths connecting  and ). Suppose that we want to find a connected -search strategy for . In order to do it we extend . We have to find a -minimal search, where . For  () we need a -minimal (respectively -minimal) search strategy, so  (, resp.) does not suffice. However,  is -minimal and , so the moves of  as a part of  use  searchers and . Now we can extend  by using , ,  or , but only one extension, namely  uses no more than  searchers. We have . The final extension (the only one possible) is . Note that not all minimal strategies have been listed --- there exist a -minimal strategy (namely ) for  and a -minimal one () for , but it is easy to check that none of those can be used to extend .
\begin{figure}[htb]
\begin{center}
\includegraphics[scale=1]{extensions.eps}
\caption{(a) node weighted tree ; (b) }
\label{pic:extensions}
\end{center}
\end{figure}
Figure~\ref{pic:extensions}(b) depicts a partial strategy , where the dashed arrows represent the moves of the strategy. Their labels  indicate the number  of the corresponding clearing move, while  and  are, respectively, the number of searchers used for clearing and guarding in the move.


\section{Efficient algorithm for bounded-degree trees}
\label{sec:bounded_degrees}

In this section we provide a polynomial-time optimal algorithm for bounded degree trees. In an informal way, it may be described as follows. We start with placing  searchers at the root  of . Assume that the algorithm calculated a partial search strategy . If  then  clears  and the computation stops. Otherwise we select a vertex  and we find a partial connected search  for . We continue with . Note that  requires  to perform  and then the moves of  follow, where  searchers are used to guard the vertices that are not in  and, in addition,  searchers work on the subtree . So, if  can be extended to a connected -search for  and we are able to find a -minimal strategy , then, by Lemma~\ref{lem:minimal_S_v}, we have that  can be extended to a connected -search for . The fact that any such vertex  is sufficient reduces the size of the search space for the algorithm. However, it follows immediately from the NP-completeness proof in Section~\ref{sec:hard} that finding a strategy  is intractable, unless P=NP. We point out here that Lemma~\ref{lem:minimal_S_v} will not be needed in its most general form, because we will apply it for , i.e. when we select a vertex  and the corresponding search strategy , then all the edges in  are contaminated at the end of .

For each  a set  is a global variable and will contain partial -minimal connected search strategies for a subtree , for selected values of .

We start by describing a procedure, called  (\emph{Minimal Connected Partial Strategy}), which for given integer , a rooted tree , and an ordering  of the edges incident to , finds a -minimal partial connected search strategy , which clears the edges in  according to the given order, whenever such a strategy exists. Our final algorithm will process  in a bottom-up fashion, so when  is called, then for each  some -minimal search strategies for  belong to  for some integers . Moreover,  searchers already occupy  when  starts. The procedure is as follows:
\begin{list}{}{}
\item[Step 1.] For each  repeat the following: (i) if  searchers are sufficient to clear , then clear  as the next step of  and find -minimal search  with maximum , . If  exists, then let , otherwise proceed to ; (ii) if more than  searchers are needed to clear , then return `failure'.
\item[Step 2.] Clear . (If  searchers are not sufficient to do it, then return `failure'.) While there exist  and  such that  is -minimal, , then .
\item[Step 3.] Return .
\end{list}

\begin{lemma} \label{lem:FindMinimal_works}
If  can be extended to a -minimal search strategy that clears the edges in  according to the order , then  returns such a strategy.
\end{lemma}
\begin{proof}
Assume that there exists a partial -minimal search strategy  clearing the edges in  according to the order . Let, for brevity,  denote the partial connected search strategy calculated in Steps~1-2 of , where clearing  is the last move of , .

Now we use induction on  to prove that  can be extended to -minimal search for . The claim follows immediately for , since by assumption,  starts by clearing . (For a connected search starting at  an edge in  has to be cleared first.) Assume that  has been cleared by , . The procedure  proceeds in Step~1 by finding a -minimal partial connected search  for . By Lemma~\ref{lem:minimal_S_v},  can be extended to a -minimal connected search for . By the definition, there is no  for which there exists a -minimal partial connected search for . Thus, the next edge  cleared by  must be in . Hence,  which results in strategy .

Thus, we obtain that  can be extended to a -minimal connected search for . Then,  finds in Step~2 a sequence of vertices  and search strategies  such that  is -minimal and . By Lemma~\ref{lem:minimal_S_v}, each strategy , , can be extended to a -minimal search for .

Let . We have that  is -minimal, because otherwise, as proved above, it can be extended to a -minimal search for , and consequently, by Lemma~\ref{lem:minimal_S_v}, there exists  and a -minimal search  such that  can be extended to a -minimal search for , which gives a contradiction with the fact that no such vertex has been found following  by .
\end{proof}


Now we are ready to give a listing of the algorithm  (\emph{Connected Searching of a Tree}) for finding an optimal connected search strategy for a rooted tree . This algorithm is exponential in the maximum degree of , .

\begin{list}{}{}
\item[Step 1.] For each son  of  call . This step guarantees that for each  the collection  of all minimal search strategies for  is calculated (which is necessary also for subsequent calls of ).
\item[Step 2.] Fix a permutation  of the edges in . Set . If Step~3 has been executed for all the  permutations , then Exit.
\item[Step 3.] Call . If the `failure' has been returned, then increase  and repeat Step~3. If a search strategy  has been returned and there is no  such that  and  then add  to  and remove from  all search strategies  such that  and . If  then go to Step~2 to fix the next permutation . Otherwise increase  and repeat Step~3.
\end{list}

\begin{lemma} \label{lem:finds_minimal}
Let  be an integer. The set  contains a partial -minimal connected partial search strategy for  whenever such a strategy exists.
\end{lemma}
\begin{proof}
We prove the lemma by induction on the number of the vertices of a tree. For a tree with one vertex the claim follows.

Let  be a tree with  vertices. By the induction hypothesis, after Step~1 of , the set  contains a -minimal connected search strategy for each  and for each  whenever such a strategy exists.

Then,  iterates over all permutations  of the edges in  and for each permutation all integers  are used (we stop when a strategy clearing  has been found). Lemma~\ref{lem:FindMinimal_works} gives the thesis.
\end{proof}
Lemma~\ref{lem:finds_minimal} in particular implies, that  finds an optimal solution to the  problem, because an optimal connected search strategy  is -minimal and . Now we finish this section with some complexity remarks.



\begin{lemma} \label{lem:running_time}
Given a bounded degree tree , the running time of the algorithm  is , where .
\end{lemma}
\begin{proof}
Denote by  the connected search strategy  calculated by  for , and for fixed  and . For a given permutation  there are at most  different search strategies that can be returned by , because if , , then . This means that . We maintain  as a balanced binary search tree which gives that inserting, removing and finding search strategies takes  time. This implies  running time of .

As to the complexity of , we have that it is called  times, once for each vertex. For a fixed permutation , Step~3 of  is executed for at most  different values of . (The latter follows from the observation, that the instruction `increment ' in  jumps to the next  for which the next strategy found for the same  is different, which means that at least one additional edge of  will be cleared. The next value of , for which the outcome of  will be different, can be recorded while executing the current execution of .) In one repetition of this step it takes  time to execute , and  time to iterate over  to remove unnecessary strategies from the collection. So, the running time of Step~3 of  is , and the overall execution time of  is .
\end{proof}

Since the algorithm solves the  problem, where the starting vertex is given, in order to solve the  problem, a straightforward approach is to call  for each vertex of  as the root and the solution is the best strategy found. However, we can reduce the running time. Let . For different roots  for each  there are at most  different subtrees  for which  calculates search strategies, namely each neighbor of  can be its father and  may be the root itself. This gives that there are in total at most  different subtrees  to consider.
\begin{theorem} \label{thm:polynomial_for_trees}
Given a bounded degree weighted tree , an optimal connected search strategy for  can be computed in  time, where .
\qed
\end{theorem}






\section{Connected searching of weighted trees is hard}
\label{sec:hard}

\subsection{Scheduling time-dependent tasks}
\label{subsec:time-dependent}

In this section we recall a problem of scheduling time-dependent (deteriorating) tasks. The execution time of a task depends on its starting time. The set of tasks is denoted by . Each task  is characterized by two parameters, deadline  and running time , which depends on , the point of time when the execution of  starts. The completion time of  is . We are interested in the single machine scheduling. A schedule  is \emph{feasible} if  the completion time   of each task  is not greater than its deadline, , and the execution times of two different tasks do not overlap. The \emph{makespan} of a schedule  is . Since the execution time depends on the starting point, we will write  to refer to the execution time of  when it starts at . Observe that a schedule  can be described by a permutation , because the idle times between the execution of two consecutive tasks are not necessary for non-decreasing (in time) execution times. In the Time-Dependent Scheduling () problem we ask whether there exists a feasible schedule for . A good survey and a more detailed description of this problem can be found in~\cite{deteriorating_survey}. For a survey on scheduling problems and terminology see~\cite{Blazewicz96,Brucker_SchedulingAlgorithms}.

There are several NP-completeness results for very restricted (linear) functions for execution time of a task \cite{ChengDing03,Kubiak_deteriorating}. However, we need for the reduction described in the next subsection the  problem instances, such that each task starts and ends at integers, which are bounded by a polynomial in the number of tasks. This property does not follow directly from the reductions in~\cite{ChengDing03,Kubiak_deteriorating}. For this reason we will prove NP-hardness of the  problem instances having the properties we need.

We will reduce the -partition problem~\cite{GareyJohnson79} to . The former one can be stated as follows. Given a positive integer , a set of integers  such that  and  for each , find subsets  of  such that ,  for , and  for each .

Now, using  and , we define the instance of the  problem. Let . To simplify the statements we partition the interval  into intervals  as follows:

We use the symbols ,  to denote the endpoints of an interval , i.e. , .
Clearly,  and  for each . Note that the length of  is  for each .

Now we define the tasks in the  problem. For each  we introduce a task  with parameters

In addition, for each  we define a task  with the deadline  and execution time , where

. Let . Observe that in each schedule all tasks are executed within .

For a given schedule  for ,  and  denote, respectively, the start and completion time of . Similarly,  and  are start and completion times of . We say that a task  \emph{precedes}  in a given schedule if  starts earlier than .

In the next three lemmas we prove several properties of every schedule for . Then, in Lemma~\ref{lem:reduction} we prove that there exists a schedule for  if and only if there exists a -partition for  and .

\begin{lemma} \label{lem:preceeding}
In each schedule  for  we have that  precedes  for each .
\end{lemma}
\begin{proof}
Suppose, for a contradiction, that the claim does not hold for . Let  be the permutation of tasks in  such that for each pair of tasks  we have  if and only if . In other words, to obtain  we simply restrict  to tasks in . Then, find the smallest index  such that . Clearly, , . We have

Since  is executed in  later than , we have that

because  for . This gives the desired contradiction.
\end{proof}


Given a schedule  for , define  for  and let . By Lemma~\ref{lem:preceeding}, this definition is valid and all the tasks in  have to be scheduled within .

\begin{lemma} \label{lem:time_windows}
If  is a schedule for , then  for each .
\end{lemma}
\begin{proof}
By the definition, , and, by Lemma~\ref{lem:preceeding},

For the right endpoint of , , we have 

Since , by~(\ref{eq:left_endpoint}) and~(\ref{eq:right_endpoint}) we have that  and , which implies  for each .
\end{proof}


\begin{lemma} \label{lem:time_windows_len}
If  is a schedule for , then  for each .
\end{lemma}
\begin{proof}
We assume, for a contradiction, that the thesis does not hold for .
We create a new set of tasks corresponding to , namely  are  tasks corresponding to . The set of all tasks  is denoted by . Note that . For each  we define the deadline to be the same as for , while the execution time is , where , . Consider a schedule  for  obtained from  in such a way that each task  is replaces by the sequence . We have that a task  executes within  for some , and by Lemma~\ref{lem:time_windows} , which means that its execution time is . Also by Lemma~\ref{lem:time_windows} we have that the sum of execution times of  is . This in particular means that  and all tasks in  are executed in the same time intervals in both schedules.

Now we will perform a sequence of modifications of the schedule , obtaining a sequence of schedules  for the set of tasks . We describe the first modification leading us from  to  and the migration from  to  is analogous for each , . In the remaining part of this proof we use symbols , , ,  to distinguish the parameters of tasks which depend on a schedule , . Consequently we write  since the endpoints depend on the execution time of 's. For a task  its start and completion time in a schedule  is  and , respectively. Find in  the interval  such that  and  for each . Such  does exist since we assumed for a contradiction that the thesis does not hold. Moreover, .

If  then we have that  starts at

This, however, means that  does not finish before its deadline, . So, .

To obtain , let initially  and we apply the following modifications to . Find in  the task  which executes first in the interval . Then, let . Note that only tasks in  are executed in the interval . To make the schedule  feasible, shift  units to the right all tasks in  which are executed in . In the new schedule  no two tasks overlap, because by the definition and by Lemma~\ref{lem:time_windows} the execution time of  in  is at least , while its execution time in  is . To prove that the schedule is feasible after shifting the tasks it is enough to argue that the task  succeeding  in  finishes before its deadline. To prove it observe that for each ,  which implies that

which means that , and

because . If more tasks in  have been shifted while computing , then they also finish before their deadlines, because they are executed consecutively, following . Note that there is now an idle time in , because  and , which by Lemma~\ref{lem:time_windows} means that the execution time of  is strictly bigger in  than in . (Assume that the difference in execution times is .) So, each task which succeeds  in  is executed in  at least  time units earlier, because the execution time of each task does not increase when the execution starts earlier. Consequently, . Similarly, we obtain that  for each .

The schedule  has the property that each interval , , is of length . So, the makespan of  is . Thus,

In particular we obtain that the makespan of  exceeds , while the deadline of each task in  is at most  -- a contradiction.
\end{proof}


\begin{lemma} \label{lem:reduction}
There exists a schedule for  if and only if there exists a -partition for  and .
\end{lemma}
\begin{proof}
Let  be a -partition of . For brevity let . Create a schedule  in such a way that 
We use induction on  to prove that the tasks in  are executed in time interval . The case when  and  are analogous, so assume that all the tasks in  are executed within  for some . For  we have that  is scheduled first and its execution time is . Then, the tasks in  follow in any order. Moreover, for each  we obtain , because  is a part of the solution to the -partition problem. Thus, by~(\ref{eq:intervals}), the tasks in  can be executed within .

Let  be a schedule for . By Lemma~\ref{lem:time_windows_len},  for each . Let . Since, by the definition of 's the tasks executed within  belong to  and, by Lemma~\ref{lem:time_windows}, executing  in  takes  time. Thus, for the jobs  executed within  we have that their total running time is , i.e. . So, , , is a solution to the -partition problem.
\end{proof}

\begin{theorem} \label{thm:tds_hard}
Given a set of tasks  with integer deadlines and integer nondecreasing (in time) execution times, the problem of deciding if there exists a feasible schedule for  is strongly \textup{NP}-complete.
\qed
\end{theorem}





\subsection{Reducing  to }
\label{subsec:reduction}

In this subsection we prove NP-hardness of  problem. We start by reducing  to , then we conclude that  is NP-complete as well.

The instance of  consists of a set of tasks , where each task  has its integer deadline  and a nondecreasing function  describing the execution time. As argumented in the previous section, the integer valued functions  imply that in each schedule  and  are integers, , which also justifies that we may consider the values of  only at integer points. For each  let  be the latest possible integer starting point for , i.e. . The integer  is selected to be an upper bound for the length of each feasible schedule,


Given , we create a node-weighted tree  rooted at .
For each  create a path  with



The tree , in addition to the vertices in , contains the vertices  and , .
The root  is adjacent to  and to the endpoint  of each path , . The other endpoint of , namely the vertex , is adjacent to  for each . Finally, for each  the vertex  is the father of .

The weight function  is as follows



for each , . Finally, let  be the number of available searchers.
Note that for each  and , , it holds

because  for each . Other simple facts that will be useful in the following are



We start by describing a search strategy  for , assuming that a schedule  for  is given:
\begin{list}{}{}
\item[Step 1:] Initially  searchers occupy .
\item[Step 2:] For each  do the following: let ; clear the path  containing vertices , , . (After this step, by~(\ref{eq:weght_def2}),  searchers occupy  to guard it.)
\item[Step 3:] Clear the vertices  and .
\item[Step 4:] For each  clear the path , , , ,  (after this step the subtree rooted at  is clear).
\end{list}

\begin{lemma} \label{lem:C_is_a_search}
 is a connected search for . Moreover, .
\end{lemma}
\begin{proof}
It is easy to see that after each step the subtree that is clear is connected. Now we prove that the number of searchers used is at most . Initially  searchers guard . We prove by induction on  that  searchers suffice to clear the path  in Step~2 and the number of searchers used in  for guarding when the vertex  becomes clear is


The cases when  and  are analogous (), so we prove it for , assuming that it is true for , .

By~(\ref{eq:blocking}) and~(\ref{eq:u_increases}) we obtain

So, by~(\ref{eq:induction_s}),  searchers are needed to clear . We have

because, by the definition of a schedule for time-dependent tasks the execution of a task  starts immediately after the execution of the preceding task ends, which can be stated as

This proves that  searchers are used in the first two steps of the algorithm. When the execution of the second step is completed,  searchers are used for guarding , while for guarding the vertices ,  we need

searchers. The last inequality follows from Equation~(\ref{eq:L_def}) and from the fact that in a valid schedule  each task is completed within interval . Thus, we can use  searchers to clear ,  and then the remaining subpaths , , , , .
\end{proof}


\begin{corollary} \label{cor:scheduling_to_search}
If there exists a valid schedule for , then there exists a connected -search strategy for the weighted tree  rooted at .
\end{corollary}

Now we prove the reverse implication, i.e. that the existence of a search strategy for  gives a valid schedule for . We start with a technical lemma.
\begin{lemma} \label{lem:ry_0_cleared_last}
In each -search strategy  for ,  is the edge that is cleared last among the edges in .
\end{lemma}
\begin{proof}
Let  be the move of clearing . If at least one edge in  is contaminated during clearing , the vertex  has to be guarded while clearing . That would imply  --- a contradiction.
\end{proof}

\begin{lemma} \label{lem:search_to_scheduling}
If there exists a connected -search strategy  for the weighted tree , then there exists a valid schedule for .
\end{lemma}
\begin{proof}
Given , define a schedule , where  if and only if  is the th cleared edge among the edges in . In other words, the order of clearing the edges in  determines the order of task execution in .

Let  be clearing of , , and let the move  clear .
By Lemma~\ref{lem:ry_0_cleared_last},  is cleared last among the edges in .

In order to prove that  is valid we show two facts, namely:
\begin{list}{}{}
\item[Fact 1:]  for each .
\item[Fact 2:] The move  clears the vertex , .
\end{list}

We use induction on  to prove that the above facts hold.

Let . Clearly  starts at  in , which implies Fact~1 for . We have that  searchers guard  while clearing a subpath of . Since  for each , the searchers clear the whole path , ending at . Then,  cannot be cleared, because , and  searchers occupy  to guard it. So, the next move is  which proves Fact~2 for .

Assume now that Fact~1 and Fact~2 hold for some .

For  we have . By the induction hypothesis (Fact~2) we have that the number of searchers used to guard vertices in subtrees rooted at  is . By~(\ref{eq:weght_def2}), , which implies that  is the number of searchers used while clearing . In particular, the number of searchers used to clear  is . Since  uses  searchers,  which proves Fact~1.

In the move  we clear  and then the searchers clear partially the subtree rooted at , ending by clearing a vertex ,  and then the move  follows. ( cannot be cleared when  is guarded, because . Moreover, the search does not stop at a vertex , because by~(\ref{eq:blocking}) it is possible to continue by clearing  for each .)

If  then, in particular, the vertex  has been cleared, while  searchers are used to guard  and , . By~(\ref{eq:weght_def2}), . So, the total number of searchers used while clearing  is  --- a contradiction.

If , then we can clear , because as before  searchers are used for guarding and  additional searchers clear , which means that the number of searchers in use is . Then, by~(\ref{eq:blocking}), we can clear .

By Fact~1, , for each task , which means that . This proves that  is valid.
\end{proof}

The  is clearly in NP, and the reduction is polynomial in , which gives us the theorem.
\begin{theorem} \label{thm:csf_hard}
Given a weighted tree  rooted at  and an integer , deciding whether  is \textup{NP}-complete.
\qed
\end{theorem}
Let  and  be an input to the  problem. There exists a connected -search strategy for  if and only if there exists a connected -search strategy for  (we double the weights of the vertices in ). Take three copies of , add a vertex , which will be the root of , and let the roots of the trees  be the sons of . We have that . Moreover, if  is a connected -search strategy for  then regardless of the starting vertex of , the strategy is forced to clear one of the subtrees  in  by starting at  and using  searchers. This leads to the following
\begin{corollary} \label{cor:cs_hard}
The problem of connected searching of weighted trees is strongly \textup{NP}-hard.
\qed
\end{corollary}




\section{Conclusions}
\label{sec:conclusions}

This paper presents a polynomial-time algorithm for finding optimal connected search strategies of a bounded degree trees with any weights on the edges and vertices of the tree. On the other hand, the corresponding decision problem is NP-complete for arbitrary trees with restricted weight functions , where  for each edge  and  is bounded by a polynomial in , where  is the number of vertices of the input tree.

One of the interesting open problems is the existence of `good' approximations for finding connected search strategies for trees. Note that the bound  \cite{connected_weighted_trees} does not yield an approximation algorithm since no algorithms for searching weighted trees are known.



\bibliographystyle{plain}
\bibliography{search}
\end{document}
