\documentclass[a4paper,11pt]{article}

\usepackage{fullpage}

\usepackage{caption}
\usepackage{cite}
\usepackage{tikz}
\usepackage{tikz-qtree}
\usepackage{boxedminipage}
\usepackage{standalone}
\usepackage{fix2col}

\usepackage[vlined, ruled, commentsnumbered, linesnumbered]{algorithm2e}


\usepackage{url}
\usepackage{color}
\usepackage{listings}


\usepackage{amsmath}
\usepackage{amssymb}

\DontPrintSemicolon

\SetKwProg{Fn}{Function}{}{}

\SetKwFunction{FnFlatten}{Flatten}
\SetKwFunction{FnMinCost}{Min}
\SetKwFunction{FnRepeated}{Repeated}
\SetKwFunction{FnRepetition}{Repetition}
\SetKwFunction{FnStrc}{Strc}
\SetKwFunction{FnStrided}{Strided}
\SetKwFunction{FnTypetree}{Typetree}

\SetKwRepeat{Do}{do}{while}

\SetKwRepeat{Struct}{struct \{}{\}}

\newcommand{\Int}{\KwSty{int}}
\newcommand{\Typenode}{\KwSty{Typenode}}
\newcommand{\Enum}{\KwSty{enum}}
\newcommand{\Edge}{\KwSty{Edge}}
\newcommand{\Node}{\KwSty{Node}}


\newtheorem{problem}{Problem}
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}

\newenvironment{proof}{\par\noindent{\textsc{Proof:}}\space}{\protect\\ \par}

\newcommand{\leaf}{\mathsf{con}}
\newcommand{\vct}{\mathsf{vec}}
\newcommand{\idx}{\mathsf{idx}}
\newcommand{\hetvec}{\mathsf{hetvec}}
\newcommand{\strc}{\mathsf{strc}}
\newcommand{\idxbuc}{\mathsf{idxbuc}}
\newcommand{\vctbuc}{\mathsf{vecbuc}}

\newcommand{\lookup}{\mathrm{lookup}}

\newcommand{\sequ}[1]{\langle #1 \rangle}
\newcommand{\cost}{\mathrm{cost}}

\newcommand{\ceiling}[1]{\lceil #1\rceil}
\newcommand{\floor}[1]{\lfloor #1\rfloor}

\newcommand{\remind}[1]{\textcolor{red}{[\bf #1]}}

\SetAlgorithmName{Listing}{listing}{List of Listings}

\title{Polynomial-time Construction of Optimal Tree-structured
  Communication Data Layout Descriptions\thanks{This work was
    co-funded by the European Commission through the EPiGRAM project
    (grant agreement no.\ 610598).}}

\author{Robert Ganian\\
       Algorithms and Complexity Group\\
       Vienna University of Technology\\
       Austria\\
       \texttt{rganian@gmail.com}
\and Martin Kalany\\
       Parallel Computing Group\\
       Vienna University of Technology\\
       Austria\\
       \texttt{kalany@par.tuwien.ac.at}
\and Stefan Szeider\\
       Algorithms and Complexity Group\\
       Vienna University of Technology\\
       Austria\\
       \texttt{stefan@szeider.net}
\and Jesper Larsson Tr\"aff\\
       Parallel Computing Group\\
       Vienna University of Technology\\
       Austria\\
       \texttt{traff@par.tuwien.ac.at}
}

\clubpenalty=10000
\widowpenalty=10000

\begin{document}
\maketitle

\begin{abstract}
We show that the problem of constructing \emph{tree-structured
  descriptions of data layouts} that are optimal with respect to space
or other criteria, from given sequences of displacements, can be
solved in \emph{polynomial time}. The problem is relevant for
efficient compiler and library support for communication of
non-con\-ti\-gu\-ous data, where tree-structured descriptions with
low-degree nodes and small index arrays are beneficial for the
communication soft- and hardware. An important example is the
Message-Passing Interface (MPI) which has a mechanism for describing
arbitrary data layouts as trees using a set of increasingly general
constructors. Our algorithm shows that the so-called MPI
\emph{datatype reconstruction problem by trees} with the full set of
MPI constructors can be solved optimally in polynomial time, refuting
previous conjectures that the problem is NP-hard. Our algorithm can
handle further, natural constructors, currently not found in MPI.

Our algorithm is based on dynamic programming, and requires the
solution of a series of shortest path problems on an incrementally
built, directed, acyclic graph. The algorithm runs in  time
steps and requires  space for input displacement sequences of
length .
\end{abstract}

\section{Introduction}
\label{sec:introduction}
It is a common situation for instance in parallel, numerical libraries
that substructures of large, static data structures have to be
communicated among
processors~\cite{ChoiDongarraOstrouchovPetitetWalkerWhaley96,PoulsonMarkerHammondRomerovandeGeijn13},
e.g., row- or column vectors or sub-matrices of multi-dimensional
matrices, or irregular substructures corresponding to the non-zeros or
other special elements of larger structures. This requires efficient
access to the typically non-contiguously stored substructure elements
in some predefined order, either for the application which
``(un)packs'' the elements (from) to some structured communication
buffer, or for the communication soft- or hardware to handle the
non-consecutive communication in a way that is transparent to the
application. For the latter approach, concise and efficient
descriptions of such substructures are needed. For instance, lists of
element addresses or displacements are neither concise (space
proportional to the number of elements is required) nor efficient
(processing time is at least doubled, since also the list has to be
traversed). For substructures with some regularities, much better
representations are obviously possible. Often, tree representations
are used with leaves describing base-types and interior constructor
nodes how subtrees are repeated. For example, complex data types in
C-like languages can be built recursively using a small number of
constructors (like arrays and \texttt{struct}s) from given primitive
types (\texttt{int}s, \texttt{char}s, \texttt{double}s, etc.), and the
resulting type trees describe to the compiler how data are laid out in
memory. The same kind of mechanism could be used to describe
substructures of such data types (but is not a part of C). The
Message-Passing Interface (MPI)~\cite{MPI-3.0} is an important example
of a parallel communication interface, indeed often used to implement
parallel numerical
libraries~\cite{ChoiDongarraOstrouchovPetitetWalkerWhaley96,PoulsonMarkerHammondRomerovandeGeijn13},
which provides a generic, explicit mechanism for describing
non-consecutive application data to allow the library implementation
to perform non-consecutive communication in an efficient way, possibly
by directly exploiting hardware features for, e.g., strided,
non-consecutive communication. Given such a tree-structured
description of an application data layout, it is a natural question to
ask whether this description is optimal under some given cost model
reflecting the cost of storing or processing the
description. Likewise, given a trivial description of a data layout in
the form of a long list of addresses (or offsets, or displacements),
it is natural to ask for an algorithm for constructing an efficient,
that is, cost-optimal representation as a tree with some given set of
constructors. In the MPI community, the former problem is referred to
as \emph{type normalization}, and the latter as \emph{type
  reconstruction}~\cite{Traff11:typeguide}. Both problems are
eventually important for the implementation of very high-quality MPI
libraries. The problems would be similarly important in other parallel
interfaces or languages supporting communication of arbitrarily
structured, non-consecutive data. Ideally, a compiler would be able to
perform the normalization (optimization) of data layout descriptions
given more or less explicitly by the application programmer in the
code with the constructs available in the parallel
language~\cite{SchneiderKjolstadHoefler13}.

In this paper, we investigate primarily the type reconstruction
problem for a given set of constructors, that is, the problem of
finding the most concise tree representation of a given substructure
specified by an explicit list of displacements. As the set of
constructors, we use a convenient abstraction of the type constructors
found in MPI~\cite[Chapter 4]{MPI-3.0}. This is both a natural and
powerful set that includes constructors for the case where a single
substructure is repeated in a regular or irregular pattern as well as
the case where different substructures are concatenated with given
displacements. Our main result is to show that an optimally concise
tree representation can be found in polynomial time for the whole set
of constructors, and thus as a corollary that both type reconstruction
and type normalization for the whole set of MPI derived data type
constructors can be solved in polynomial time.  This is an interesting
result since the computational hardness of the problem was not known
before.  Indeed, the problem was believed not to be in  by parts of
the MPI community. Specifically, we give an algorithm that finds an
optimal type tree description for a sequence of displacements of
length  in  operations. The algorithm is based on a
non-trivial use of dynamic programming requiring the solution of a
single-source shortest path problem for each new subproblem
solution. Using standard dynamic programming techniques, the space
requirement is .

MPI libraries typically employ simple forms of type normalization to
derived data types set up by the application programmer (this is
folklore, but
see~\cite{KjolstadHoeflerSnir11,KjolstadHoeflerSnir12,RossMillerGropp03}
for explicit descriptions). In recent
papers~\cite{Traff14:normalization,Traff15:mpilinear}, the problem was
more systematically analyzed, and it was shown that when restricted to
certain homogeneous constructors (those having a single child) the
reconstruction and normalization problems can be solved quite
efficiently in low, polynomial time. It was explicitly conjectured 
that the problems with the full set of MPI derived data type 
constructors would be NP-hard~\cite{Traff15:mpilinear, Traff11:typeguide}. 
We stress that when it is allowed to fold the constructed
trees into even more concise, directed acyclic graphs (DAGs), the
optimality of our construction is no longer guaranteed. We discuss
this problem at the end of the paper.

The notion of an optimal tree-like representation of a data layout is
of course relative to the way the tree will be used and processed by
the parallel programming language or library
implementation. Processing typically includes the ability to pack and
unpack parts of the layout independently using hardware support for
blocked, strided memory access and similar features of the
communication subsystem. We do not deal with the problem of efficient
datatype-tree processing here, but abstract storage and processing
costs with a simple, parameterized cost model, which must be adapted
to the concrete situation. The literature on optimization of the
processing of tree representations of data layouts in MPI is large;
some pointers are given in~\cite{Traff14:normalization}.

The paper is structured as follows. We define the set of considered
constructors and precisely formulate the type reconstruction problem
in Section~\ref{sec:problem}.  Our main result is given in
Section~\ref{sec:treereconstruc}, which describes our dynamic
programming algorithm, proves correctness and establishes the
complexity bound. In Section~\ref{sec:generalizations} we discuss how
our approach can be extended to include other convenient and in
specific situations more concise constructors, and how the problem
changes when trees can be folded into DAGs. Concluding remarks,
including a discussion of relevant future work in this area are given
in Section~\ref{sec:conclusion}.

\section{The type reconstruction problem}
\label{sec:problem}

A \emph{data layout} is an ordered sequence of relative (integer)
displacements, each indexing a certain base data type (integer, char,
floating point number) relative to some base address. Since the
semantics of base-types will not be important for the following, we
abstract the problem to consider from here onward \emph{displacement
  sequences} which we write as  with
the displacements  being indexed from  to . We point
out that the complexity of the problems that we investigate does not
change by considering full \emph{type maps} consisting of sequences of
displacements with their associated basetype (and number of bytes
occupied), as would have to be done in a concrete implementation of
our algorithms for real libraries, although of course the structure of
the reconstructed types may look different.  A \emph{segment} of an
-element displacement sequence from index  to index  is
denoted by , .  A \emph{prefix} of length  is the segment . The
displacements of the sequence are arbitrary (non-negative, negative)
integers, and the same displacement can appear more than once
(although this will normally not be the case, and is often disallowed,
e.g., for some uses of derived data types in MPI). Thinking of
displacements as (Byte) addresses, it is clear that any application
data layout can be described by a displacement sequence. The ordering
constraint (displacement sequence, \emph{not} displacement set)
implies that data are accessed in a specific order.  This is often
important for data layouts used in communication operations.

Displacement sequences typically contain regularities and some form of
structure, since they can be thought of as arising from a specific
application, and this can be exploited to obtain more concise
descriptions.  We do this by type trees, where interior
\emph{constructor nodes} describe some ordered catenation of the
layout(s) described by the child(ren) node(s).  It is natural to ask
for an efficient, polynomial time algorithm for computing the most
concise and efficient representation for a given set of constructors
and cost model.

We consider the following set of constructors that subsume
constructors found in C-like programming languages, as well as the
derived data type constructors found in MPI:

\noindent
\begin{definition}[Basic type constructors]
\label{def:baseconstructors}
A \emph{basic tree} may be constructed from the following four 
\emph{basic constructors}:
\begin{enumerate}
\item
A \emph{leaf}  with \emph{count}  describes a
sequence of  adjacent relative displacements .
\item
A \emph{(homogeneous) vector}  with \emph{count} 
and \emph{stride}  describes the catenation of  sequences  at
relative displacements .
\item
A \emph{(homogeneous) index}
 with \emph{count}  and
\emph{indices}  describes the
catenation of  sequences  at relative displacements
.
\item
A \emph{heterogeneous index}, or \emph{struct},
,
with \emph{count}  and \emph{indices}
 describes the catenation of 
sequences  at relative displacements
.
\end{enumerate}
\end{definition}

For example, the displacement sequence  can be
described by .  A more involved example is shown in
Figure~\ref{fig:typetreeExample}.  Note that any displacement sequence
 of length  can trivially be represented as .

\begin{figure}[t]
\centering
\tikzset{level distance=30pt, sibling distance=40pt}
\Tree 
    [. 
	[. ] 
	[.
	    [. 
		[. ]
	    ]
	]
    ]
\caption{Type tree representing the displacement sequence , , , , , , , , , , , , , , , , , , , .
Note that if the  constructor is not allowed, the only way to represent this displacement sequence is the trivial representation .}
\label{fig:typetreeExample}
\end{figure}
We refer to vertices of type trees as \emph{nodes}, where each node is
one of the constructors.

It can easily be shown that each of the MPI derived data type
constructors (for contiguous, vector, index, and structured
subtrees)~\cite[Chapter 4]{MPI-3.0} is expressible by the basic
constructors of Definition~\ref{def:baseconstructors}, and that the
mapping is almost one-to-one. For instance, the
\texttt{MPI\_Type\_vector} constructor denotes a layout consisting of
a strided sequence of blocks, each being a strided sequence of some
type . This is expressed as  where  is
the number of blocks,  their stride,  the number of elements in
each block, and  the stride used within each block. We treat base
types as sequences of bytes which can be expressed by leaf nodes,
e.g., a 32-bit entity like \texttt{int} would be expressed by
.  The  constructor makes it possible to express the
repetition of the same layout  each at some arbitrary displacement;
for this only the sequence of start indices (and the size of this
sequence) needs to be represented. The most expressive, arbitrary
\emph{branching constructor}  can express the catenation of a
sequence of possibly different, smaller layouts each starting at an
arbitrary displacement. This is the only constructor node with arity
greater than one. In contrast to the similar MPI constructor
\texttt{MPI\_\-Type\_\-create\_\-struct}, which also takes a
repetition count (blocklength) for each substructure, the 
constructor saves this extra sequence. If a substructure is indeed a
repetition of some even smaller substructure, this information is part
of the substructure and not of the  node itself. The basic
constructors increase in generality and storage cost: an  node
is a  node where all substructures are similar, and therefore
does not need to store a sequence of subtypes; a  node is an
 node with regularly strided displacements, which can be
computed from a single scalar instead of storing an explicit index
sequence. As the example in Figure~\ref{fig:typetreeExample} shows,
the  constructor makes unbounded compression possible over the
 constructor.

To make it possible to express further common patterns without
redundancy, we also consider a few auxiliary constructors. The
patterns that these constructors capture can all be expressed by
two-level nestings of basic constructors, but possibly at a higher
cost. For practical purposes and depending on the application usage
patters that are intended to be supported, it might therefore make
sense to have a richer set of constructors. For instance, MPI has both
an \texttt{MPI\_\-Type\_\-create\_\-indexed\_\-block} (which is
captured by the  basic constructor node) and an
\texttt{MPI\_\-Type\_\-indexed} constructor which stores also a
repetition count for each index. In cases where all substructures are
repeated the same number of times, this is strictly redundant, and
there are therefore use cases for both constructors. We include the
auxiliary constructors to argue informally that our algorithm can
handle a large set of reasonable constructors.

\noindent
\begin{definition}[Auxiliary type constructors]
\label{def:auxconstructors}
An \emph{extended tree} may contain also the following two 
\emph{auxiliary constructors}:
\begin{enumerate}
\item
A \emph{strided bucket},  with \emph{count}  and
\emph{strides}  describes the catenation of  sequences at
relative displacements . The -th sequence is
the catenation of  sequences  at relative displacements
.
\item
An \emph{indexed bucket}, 
, with \emph{count} 
and \emph{substride}  describes the catenation of  sequences
at relative indices . The -th sequence
is the catenation of  sequences  at relative displacements
.
\end{enumerate}
\end{definition}

As can be seen from the discussion above, the indexed bucket
constructor corresponds to the \texttt{MPI\_\-Type\_\-indexed}
constructor. There is no MPI counterpart of the other, arguably
natural constructor. We discuss these constructors in more detail in
Section~\ref{sec:auxiliary}.

Each basic or extended tree represents one displacement sequence,
obtained by an ordered traversal of the nodes of the type tree. This
process is called \emph{flattening} and is captured by the algorithm
in Listing~\ref{alg:flattening} for the basic constructors; the
auxiliary constructors can be handled similarly. The converse is not
true: a displacement sequence will almost always have several possible
type tree representations.

\begin{algorithm}[t]
\Fn{\FnFlatten{T, base}}{
    \Switch{T.nodetype}{
        \Case(\tcc*[f]{leaf of consecutive indices}){}{ 
            \For{; ; }{
                print 
            }
        }
        \Case(\tcc*[f]{strided layout}){}{
             \For{; ; }{
                \FnFlatten{, }
             }
        }
        \Case(\tcc*[f]{indexed layout}){}{
             \For{; ; }{
                \FnFlatten{, }
             }
        }
        \Case(\tcc*[f]{indexed layout with subtypes}){}{
            \For{; ; }{
                 \FnFlatten(, )
            }
        }
    }
}
\caption{Flattening procedure defining the displacement sequence
  represented by a given basic tree . The procedure is called
  with a base offset, which will normally be 0. The procedure can
  trivially be extended to also cover extended trees.}
\label{alg:flattening}
\end{algorithm}

We make no claim that Listing~\ref{alg:flattening} depicts a
particularly good way of implementing
flattening~\cite{Traff99:flattening}. Note that the size of the
displacement sequence described by a type tree  could be much
larger than the number of nodes in . Within this paper, we assume
that all numbers can be represented by a constant number of bits;
otherwise, our main result still holds, but the upper bound on space
requirements increases by a logarithmic factor.

By the \emph{conciseness} of a type tree we mean the space taken by
the representation. This is constant for vector and leaf nodes and
proportional to the size of the index and type sequences for the other
constructors. Processing costs are related to conciseness: the concise
vector constructor that describes a strided repetition of a
sub-pattern can often be handled by strided memory-copy or strided
communication operations, whereas constructors with sequences of
displacements or types need at least a traversal of the corresponding
sequences and typically entails a more irregular and expensive access
to memory. We will therefore first focus on a simple cost model for
optimizing conciseness.

The \emph{cost} of a type node shall be proportional to the number of
words that must be stored to process the node.  This includes the node
type (), count, displacement or pointer to
index or type array, pointer to child node(s), and a lookup cost for
the elements in lists of indices or types:

The constants can be adjusted to reflect other overheads related to
representing and processing a node.  We define the \emph{cost} of a
type tree  to be the \emph{additive cost} of its nodes :
.

\begin{algorithm}
\Struct{\Typenode}{
    \Enum{}  = \{, , , \}\;
    \Int{}  \tcc*{count}
    \Int{}  \tcc*{stride}
    \Int{}  \tcc*{displacement of subtypes}
    \Typenode{}  \tcc*{subtype}
    \Typenode{} [ ] \tcc*{array of subtypes}
}
\caption{A possible \Typenode{} structure for representing nodes in
  type trees or DAGs.}
\label{lst:typenode}
\end{algorithm}

For the examples given in this paper, we take , and .  For instance, with a
C-style structure as shown in Listing~\ref{lst:typenode} to represent
any of the type constructors, all constructors indeed have the same
constant in the cost (which we could take as 6 units). We remark that
our algorithm is not dependent on the specific choice of the cost
function, and that our results also hold for other reasonable cost
functions where the cost of a node is a function of the node itself
and the costs of its children.

We can now formally define the problem that we will solve in the next
section. Recall that a type tree  \emph{represents} a displacement
sequence  if .
\begin{center}
  \begin{boxedminipage}[t]{\textwidth}
  \begin{quote}
  \textsc{Basic Type Reconstruction Problem}\\ \nopagebreak
  \emph{Instance}: A displacement sequence  of length .\\ \nopagebreak
  \emph{Task}: Find a least-cost (or optimal) basic tree  representing~; that is,  for any basic tree  representing .
\end{quote}
\end{boxedminipage}
\end{center}
\medskip

\section{Basic tree reconstruction in polynomial time}
\label{sec:treereconstruc}

We now present our main result, namely that the \textsc{Basic Type
  Reconstruction Problem} can be solved in polynomial time. subsequently show that extending the set of the auxiliary constructors
of Definition~\ref{def:auxconstructors}.

\begin{theorem}
\label{thm:polytree}
For any input displacement sequence  of length , the
\textsc{Basic Type Reconstruction Problem} can be solved in 
time and  space.
\end{theorem}

\textsc{Proof outline:} We first give a characterization of the
structure of optimal basic trees (Lemma~\ref{lemma:niceTypeTree})
which allows for a simple and elegant procedure to solve the special
case of displacement sequences in \emph{normal form}
(Definition~\ref{def:normalForm}).

The fundamental observation for the proof is that any (non-trivial)
displacement sequence can be described by either a catenation of the
same kind of shorter displacement sequences (and thus by either a
vector or an index constructor) or by a catenation of different, but
shorter displacement sequences (and thus by a struct constructor). In
both cases, for an optimal description, the description of the shorter
sequences must likewise be optimal, and the principle of optimality
applies. This intuition is formalized in Lemma~\ref{lemma:repetition}
and Lemma~\ref{lemma:strc}. Lemma~\ref{lemma:optimalForNF} proves the
claim for the special case of displacement sequences in normal form,
with a detailed procedure given in Listing~\ref{alg:typetree}.

Finally, Lemma~\ref{lemma:optimalForAny} shows how to construct an
optimal basic tree for any displacement sequence out of an optimal
basic tree representation of its normal form.

\begin{definition}[Repetition, Strided Repetition]
A \emph{repetition} in a displacement sequence  of length  is a
prefix  of length  s.t.\  is a divisor of  and
for all ,, ,  we have that .  A \emph{strided repetition} of length 
additionally fulfills  for all ,
, where  is the \emph{stride} of
the repetition.
\end{definition}

\begin{algorithm}[t]
\Fn{\FnRepeated{D, n, q}}{
    \For{; ; }{
        \For{; ; }{
            \If{}{
                \Return false
            }
        }
    }
    \Return true
}

\Fn{\FnStrided{D, n}}{
    \;
    \For{; ; } {
        \lIf{} {\Return false}
    }
    \Return true
}
\caption{Trivial checks for repetitions and strided repetitions.}
\label{lst:subroutines}
\end{algorithm}

The intention of the functions \FnRepeated and \FnStrided (see
Listing~\ref{lst:subroutines}) is to find (strided) repetitions  of
a displacement sequence  that can be exploited to represent  via
an  or  constructor with subsequence .  It is easy to
see that \FnRepeated and \FnStrided as outlined both take linear time.

As mentioned above, any displacement sequence  can be described by
either a catenation of the same kind of shorter displacement sequences
or by a catenation of different, but shorter displacement sequences.
Additionally, a representation via a  node is possible if 
is a trivial displacement sequence .
In terms of type trees, this means that an optimal basic tree  for
a displacement sequence  is either
\begin{enumerate}
\item , a single  node with count ; or
\item , where the prefix  of length  is a strided repetition in  with stride  and  is an
  optimal basic tree for the prefix ; or
\item , where the prefix
   of length  is a repetition in ,  is an
  optimal basic tree for the sequence  and the indices  are such that
  ; or
\item , where the  for  are optimal basic
  trees for some sequences  which together with the indices
   are such that .
\end{enumerate}
While the first case can be handled with a single scan of , the
others are more involved.  In the following, we give a more detailed
characterization of (optimal) basic trees to tackle the problem.

\begin{definition}[Shifted node]
We call an index node  or a struct node  with  a
\emph{shifted node};  is called the node's \emph{shift}.
\end{definition}
Note that adding some value  to all indices of an  or 
node  shifts the sequence represented by the basic tree rooted at
 by .

\begin{definition}[Nice basic tree]
\label{def:nicetree}
A \emph{nice basic tree} contains at most one shifted node, which is the first  or  node on every root to leaf path.
\end{definition}

\begin{lemma}
\label{lemma:niceTypeTree}
For any basic tree  representing a displacement sequence , a
nice basic tree representation  of  of equal cost
exists.
\end{lemma}
\begin{proof}
A node is \emph{bad} if it is a shifted node and it is not the first
 or  node on every root to leaf path.  Let  be a fixed
displacement sequence and let  be a basic tree representing 
with a minimum number of bad nodes. We will show that  is, in fact,
nice.

Assume that a bad index node (the proof is analogous for a bad struct
node)  is present in the -th subtree of a struct node
 s.t.\ there is no other
shifted node on the path from  to .  We can change  to
a non-shifted index node by subtracting its shift  from all
indices , for  and adding  to the -th index
 of , i.e.,  and . Notice that the basic tree obtained in
this way still represents the same displacement sequence  but
contains one less bad node, and hence the existence of such a node
 would contradict our choice of .
    
Hence there is no  node on the path from a bad node  to
the root node .  If this path contains an index node , proceed analogously to the previous case: 
and . Again, the obtained basic tree also represents
 but contains one less bad node, contradicting our original choice
of . Consequently,  does not contain any bad nodes and thus must
be a nice basic tree.
\end{proof}

\begin{corollary}
\label{corollary:atMostOneIndexWithCount1}
Any optimal basic tree  contains at most one index node with count
1, i.e., at most one node of the form . Additionally, there is no other  or
 node on the path from  to the root.
\end{corollary}
\begin{proof}
Assume that  contains two index nodes with count 1.  Since  is a
tree, there is an index node  with count 1 s.t.\ the path from 
to the root node of  contains another  or  node.  In a
cost-equivalent nice basic tree representation  (obtained
by applying the procedure from the proof of
Lemma~\ref{lemma:niceTypeTree}), the corresponding index node is
.  Note that the type tree rooted at
 represents exactly the same displacement sequence as its
subtype . Thus a representation  of less cost exists, which
contradicts the assumption that  is optimal.
\end{proof}

The following proposition, although not directly required for the
analysis, provides some additional insight into the structure of
optimal basic trees.

\begin{proposition}
\label{proposition:heightOfOptimalTypeTree}
The height of an optimal basic tree is .
\end{proposition}
\begin{proof}
It is easy to see that an optimal basic tree does not contain two
consecutive  nodes, as they can always be merged into one while
reducing the cost.  For any basic tree  that represents a sequence
of length , a basic tree  or
 with  represents a sequence of length at
least . Let  be a maximum-length path from a leaf to the root
of an arbitrary optimal basic tree.  Since any optimal basic tree
contains at most one  node with count 
(Corollary~\ref{corollary:atMostOneIndexWithCount1}) and no 
node with , the length of the represented sequence at least
doubles with at least every other node on .
\end{proof}

\begin{definition}
\label{def:normalForm}
The \emph{normal form}  of a displacement sequence  of
length  is defined as , for all ,
.
\end{definition}
In other words, the normal form  of a displacement sequence
 is obtained by shifting  so that its first element is .

\begin{corollary}
\label{corollary:structureOfNFSolutions}
An optimal basic tree  for a displacement sequence  in
normal form does not contain any shifted nodes or any , 
or  node with count 1.
\end{corollary}
\begin{proof}
It follows directly from Lemma~\ref{lemma:niceTypeTree} and
Corollary~\ref{corollary:atMostOneIndexWithCount1} that there exists
an optimal basic tree  for  which does not contain any
shifted nodes.  Note that a non-shifted ,  or  node
with count 1 does not change the represented sequence.  Thus, removing
such nodes from a basic tree reduces the cost while not changing the
represented displacement sequence.  It follows that no such node can
be part of an optimal basic tree.
\end{proof}

Observe that since there are no shifted nodes in an optimal basic tree
 for , any subtree of  represents a segment of
 in normal form.  In the following, we will use  to
denote an optimal basic tree representation for the normalized segment
 of .

For convenience, we define the function  which,
given two basic trees  and , returns the one with least cost (if
either is \verb|null|, the other is returned).  Note that the cost of
a basic tree can trivially be computed by a simple traversal.
However, when constructing basic trees from the bottom up (as we will
do in this section), we keep for each node the cost of the subtree
rooted at that node. This allows for the cost of a basic tree to be
queried in constant time and thus for a constant-time implementation
of .

\begin{algorithm}
\Fn{\FnRepetition{, }}{
     null\;
    \ForEach{\text{divisor}  of , }{
        \;
        \If{\FnRepeated{, , }}{
            \For{; ; }{ 
                \;
            }
            \;
             = \FnMinCost{, }\;
            \If{\FnStrided{, }} {
                \;
                \;
                 \FnMinCost{, }\;
            } 
        }
    }
    \Return 
}
\caption{Algorithm to find a least-cost representation for a
  displacement sequence in normal form with an  or  node
  as root node.}
\label{alg:checkForRepetitions}
\end{algorithm}

\begin{lemma}
\label{lemma:repetition}
Let  be any displacement sequence of length  in normal
form and assume that optimal basic tree representations for all normal
form prefixes of length less than or equal to  are
known.  A representation , where the root node of  is
either an  or a  node and  is of least cost
w.r.t.\ all possible representations of that form, can be computed in
 time.
\end{lemma}
\begin{proof}
Listing~\ref{alg:checkForRepetitions} enumerates all possible
representations of the desired form and chooses the one with least
cost among them.  Note that for the divisor , the trivial
representation  (which exists for any
displacement sequence ), is generated and thus a valid
representation for  is guaranteed to be found.  For the same
reasons as given in Corollary~\ref{corollary:structureOfNFSolutions},
 nodes with count 1 cannot be part of a least-cost
representation of the desired form and thus need not be considered.

The number of divisors of  is upper-bounded by
 and, by assumption, optimal representations
for all prefixes of  of length less than or equal to  are known, i.e.,  is known for all , .  This implies the claimed runtime bound.
\end{proof}

\begin{lemma}
\label{lemma:strc}
Let  be any displacement sequence of length  in normal
form and assume that optimal basic tree representations are known for
all normal form segments of length strictly less than .  A
representation , where the root node of  is a 
node and  is of least cost w.r.t.\ to all possible
representations of that form, can be computed in  time.
\end{lemma}
\begin{proof}
Construct a weighted, directed acyclic graph  with ,  and the weight function  which is defined for all edges
 in  as .
The intended meaning of this construction is as follows.  A node 
corresponds to the -th element of  ( is a special
vertex that corresponds to the hypothetical first element after the
end of ) and an edge  with  corresponds to
the segment  in normal form.  The weight of an edge
 is equal to the cost of the optimal representation
 of the segment  (which exists by the
assumption) plus a cost of  for including this
representation as a subtype in a  node.  The edge ,
which is not part of the constructed graph, can be thought of as
corresponding to the type tree , i.e., the optimal type
tree representation of  we want to compute.

Let  be a shortest path in
 from  to  with  for .  Then
the basic tree  is a valid
representation of .  Note that by construction, for any valid
representation of  of the desired form, a corresponding path
from  to  exists in  and thus a shortest path represents
the desired solution of least cost.  Given , this representation
can be constructed in linear time, since optimal representations for
all required segments are known by the assumption.  The resulting
graph has  edges and the runtime is dominated by the cost
of  time for finding a shortest path in a DAG.
\end{proof}

We can now give the complete dynamic programming algorithm for
constructing optimal basic trees for displacement sequences in normal
form, which proves Lemma~\ref{lemma:optimalForNF}.  Due to
Lemma~\ref{lemma:niceTypeTree}, it suffices to construct an optimal
nice basic tree which according to
Corollary~\ref{corollary:structureOfNFSolutions} cannot contain any
shifted nodes nor any ,  or  nodes with count 1.
The algorithm is shown in Listing~\ref{alg:typetree}.

\begin{lemma}
\label{lemma:optimalForNF}
For any input displacement sequence  of length  in normal
form, the \textsc{Basic Type Reconstruction Problem} can be solved in
 time and  space.
\end{lemma}

\begin{algorithm}[ht!]
\Fn{\FnTypetree{, }}{
    \tcc{Initialization}
    \;
    \tcc{Preprocessing: find leaf nodes}
    \For{}{
        \;
        \Do{ and }{
            \;
             \;
            Add edge  with basic tree  and weight  to \;
            \;
        }
    }
    \tcc{Find solutions for all segments}
    \For{}{
        \For{}{
            \tcc{Compute optimal basic tree for normalized segment }
            \;
            \tcc{Find best representation with  or  node as root}
            Let  be the normalized segment \;
             \FnRepetition{, , }\; 
             \FnMinCost{, }\;
            \tcc{Find best representation with  node as root}
            Find shortest path  from  to  in \;
            Assume \;
            \;
            
            \;
             \FnMinCost{, }\;
            Add edge  with representation  and weight  to \;
        }
    }
    \Return{} \tcc*{Stored with edge }
}
\caption{Algorithm to find a least-cost basic tree representation.}
\label{alg:typetree}
\end{algorithm}

\begin{proof}
The input to the algorithm is an -element displacement sequence
 in normal form.  The algorithm computes an optimal basic
tree  for each normalized segment , , which is stored with edge  in the constructed graph
.  Note that the solution for the whole input sequence 
can be read off of the edge .

The algorithm starts with a preprocessing step to find all segments
whose normal form is representable with a single  node.  Note
that the normal form of any segment of length 1 can trivially be
represented as  and since no other valid representations
exist for this particular kind of displacement sequence, this
representation is optimal.  A straight forward implementation of this
preprocessing step as in Listing~\ref{alg:typetree} is clearly
feasible in time .

The algorithm computes optimal basic tree representations for all
normalized segments of , via a bottom up dynamic programming
approach.  The dynamic programming table to be filled in is implicit
in the graph , where each segment  is associated with
an edge ).  Note that after the preprocessing step,
solutions for all segments of length 1 are known.  By incrementally
computing optimal representations for all segments of length
, it is ensured that Lemmas~\ref{lemma:repetition}
and~\ref{lemma:strc} can be applied to compute an optimal
representation for each segment as follows.  A basic tree , whose
root node is either an  or a  node, and a basic tree
, whose root node is a  node, are computed.  Both are of
least cost w.r.t.\ all basic tree representations of the desired form.
The optimal basic tree for a normalized segment  is
necessarily one of ,  or a representation via a  node
(if such a representation is possible), which was already computed in
the preprocessing step.

To compute , a small, technical extension of procedure
 (Listing~\ref{alg:checkForRepetitions}) for finding
representations via  or  nodes is necessary.  The
procedure requires access to optimal representations of the prefixes
of the argument displacement sequence . However, in the general
case,  is a segment of , that is, , and
its prefixes therefore start with .  To account for this
(and avoid copying ), we pass an additional argument 
representing the offset of the segment within the input displacement
sequence  (i.e., for a segment , we have
), and in lines 10 and 12 replace the argument  with
.

To compute  in Listing~\ref{alg:typetree}, contrary to
Lemma~\ref{lemma:strc}, we do not construct a new graph for each
segment when computing its representation .  Instead a single
dynamic, incrementally built graph  suffices to solve the problem
for all segments of .  By construction, when computing the
desired representation of a segment ,  contains
edges representing optimal representations for all segments of length
less than  (and possibly some edges representing solutions of
length ).  A shortest path from node  to  in 
therefore leads to the same representation as the one constructed by
Lemma~\ref{lemma:strc}.

To find such a shortest path, for each segment  of
length , one single-source shortest path (SSSP) problem on a
weighted DAG with  nodes and  edges has to be solved.
Since  is a topologically sorted DAG by construction, SSSP is
solvable in  time, where  denotes the number of
vertices and  denotes the number of edges in
~\cite{CormenLeisersonRivestStein09}.  To compute the desired
representations for all segments of length , a shortest path has to
be computed for each of the  node pairs , for
.  The total runtime is thus upper bounded by
, which is .

The algorithm constructs a graph with  edges, where a basic
tree , representing the solution for the normalized segment
, is associated with each edge .  Note that
for each edge  it suffices to store the root node of the
associated basic tree  plus pointers to its child nodes,
which are already stored with the respective edges.  To meet the
desired space bound, only a constant amount of space may be used by
each edge and associated basic tree.  This is trivially true for
 nodes (apart from one word indicating the node's kind and the
cost of the type tree rooted at the node, only the count  needs to
be stored) as well as  nodes (two integer values and one pointer
to the child node are required in addition to the node's kind and the
cost of the type tree rooted at this node).  However,  and
 nodes may require  space in the worst case (e.g.,
if  is the optimal representation of
).  We employ a standard trick often used in dynamic
programming algorithms and store for each node only the information
required to reconstruct the full solution once the algorithm in
Listing~\ref{alg:typetree} has terminated.  If for an  node the
count  is known, the full  node is easily derived as  with
.  The parameters of a  node associated with an edge
 can be reconstructed by again computing the shortest path
from node  to  and mapping it to a  node as done in
Lemma~\ref{lemma:strc}.  Note that this reconstruction step does not
change the asymptotic runtime bound and that the required space for
each node is , from which the claimed upper bound of 
space follows directly.
\end{proof}

The following Corollary~\ref{corollary:idxWithCount1IsRoot} and
Lemma~\ref{lemma:optimalForAny} show how the algorithm of
Lemma~\ref{lemma:optimalForNF} can be applied to general displacement
sequences.
\begin{corollary}
\label{corollary:idxWithCount1IsRoot}
For any optimal basic tree with an index node  with count 1, i.e.,
a node , a representation  of equal
cost s.t.\  is the root node of , exists.
\end{corollary}
\begin{proof}
Due to Corollary~\ref{corollary:atMostOneIndexWithCount1}, there is no
 or  node on the path from  to the root and thus 
shifts the whole sequence by .  This shift can be represented
equivalently by removing  from the basic tree and adding a new root
node to represent the shift, i.e., by letting .
\end{proof}

\begin{lemma}
\label{lemma:optimalForAny}
Given optimal basic trees  for all normalized segments
 of a displacement sequence , an optimal basic tree
 representing  can be computed in  time and 
space.
\end{lemma}
\begin{proof}
By Lemma~\ref{lemma:niceTypeTree}, for any optimal basic tree  a
cost-equivalent nice basic tree  representing the same
displacement sequence  exists and it therefore suffices to find an
optimal nice basic tree representation  for .  By
assumption, an optimal nice basic tree representation  for the normalized sequence  exists.  To
construct , find the first node  on any root to leaf
path in  that is either an  or a  node and add
the displacement sequence's shift  to the indices of this
node, i.e., if  in
, set  in  and analogously for the case of  being a
 node.  Note that  has the same cost as 
and thus is an optimal basic tree representation for .

If such a node does not exist, it follows from
Lemma~\ref{lemma:niceTypeTree} and
Corollary~\ref{corollary:idxWithCount1IsRoot} that the optimal
solution is either
\begin{itemize}
 \item , for some divisor  of , or
 \item , for some , .
\end{itemize}
Note that for  nodes, both the trivial representation  as well as the representation  which only adds a shifted node to  need to be
checked.  Since solutions for all normalized segments are already
known, this construction is feasible in  time and 
space.
\end{proof}

\begin{proof}[of Theorem~\ref{thm:polytree}]
The \textsc{Basic Type Reconstruction Problem} for a displacement
sequence  of length  can be solved by computing an optimal basic
tree representation for the normalized displacement sequence 
(Lemma~\ref{lemma:optimalForNF}) and the post-processing step given in
Lemma~\ref{lemma:optimalForAny}.  The claimed space and time bounds
follow directly from the given Lemmas.
\end{proof}

\section{Computing more concise representations}
\label{sec:generalizations}

In this section we discuss possibly more space efficient tree
representations by allowing a richer set of constructors, exemplified
by the auxiliary constructors introduced in
Definition~\ref{def:auxconstructors}. We then explain why computing
representations by DAGs is an apparently harder problem. Finally, we
discuss the applicability of our algorithms to the type normalization
problem.

\subsection{Handling the auxiliary constructors}
\label{sec:auxiliary}

The auxiliary constructors of Definition~\ref{def:auxconstructors} can
be handled by slight extensions to our algorithm in a way that
polynomial-time type reconstruction is still possible. Basically, only
the part that checks for vector or index patterns shown in
Listing~\ref{alg:checkForRepetitions} needs to be extended. Assume
that a repeated prefix  of length  has been found in the given
displacement sequence , and that  is the displacement sequence
consisting of every th element of , i.e.,
.

The \emph{strided bucket},  constructor can concisely describe
application data layouts consisting of buckets each with some maximum
number of elements (the stride ) where each bucket contains some
(possibly different) number of elements  with bucket stride
. This description is likely to be less costly than describing such
a layout by a  constructor with each subtype describing one
bucket.  To incorporate the strided bucket it simply has to be checked
in Listing~\ref{alg:checkForRepetitions} whether  follows the
strided bucket pattern, and this can easily be done in linear
time. There are two cases to consider. If the first bucket has more
than one element, take as bucket stride  and scan the
index list for repetitions at stride . The first violation at some
position  forces the maximum bucket size to be . Now
continue to scan till the end of , checking that the  strided
pattern repeats and counting the number of elements  in each
bucket of -strided displacements.  Otherwise, the first bucket has
only one element. Take instead as maximum bucket size ,
and scan for repetitions with stride . The first violation at some
position  forces the bucket stride to be . As in
the other case, the bucket sizes  are counted by scanning 
till the end. If an index  is found where  and
 where  is the start of the current bucket in
, then  is not a displacement sequence of a strided bucket
layout.

The strided bucket constructor is in a sense the opposite of the index
constructor. Instead of an index sequence it takes a sequence of
bucket sizes, and has (roughly) the same cost. Interestingly, there is
no such constructor in the MPI standard.

The \emph{indexed bucket}, , on the other hand corresponds closely to
the \texttt{MPI\_\-Type\_\-indexed} constructor. For each index, a
repetition count  gives the number of repeats of  in the
bucket starting at that index; all repetitions use the same stride 
(the constructor could trivially be extended to the case where each
index has its own stride). For each possible bucket stride, the number
of buckets that this stride will give rise to has to be counted. The
stride  leading to a smallest number of buckets is a candidate for
the representation of  and  as an  node. We observe
that each  with  joins two -strided segments
 and  into one bucket starting at index
. Therefore, the stride that occurs most often in the stride
sequence , , will lead to the
smallest number of buckets. To count the number of occurrences of each
stride, we either sort  or count by hashing during the scan of
. Let  be a stride with the most occurrences. A final scan of
 suffices to compute the start indices and sizes of the buckets
with stride .

\subsection{Type reconstruction into DAGs}
\label{sec:dagreconstruc}

A type tree describing some given displacement sequence may have
multiple instances of the same subtree. Our algorithm in particular
constructs nice type trees (Definition~\ref{def:nicetree}) in which
all displacement sequences in index and struct nodes except perhaps
one start at index , and it can well happen that the same index or
struct node occurs many times. A more concise representation results
if such trees are folded into directed acyclic graphs with only one
node for each substructure.

Type DAGs represent displacement sequences by the same flattening
procedure as shown in Listing~\ref{alg:flattening} for trees. Each
path from the root node in the type DAG to a leaf is traversed in
order to generate the corresponding displacement sequence. Thus the
processing cost of a type DAG would arguably be similar to the
processing costs of a tree. By a similar traversal of a DAG an
equivalent tree can be constructed, simply by making a new copy each
time a node is visited.

The space required for the DAG can be much smaller than the space
required for the corresponding tree. One can therefore define also for
DAGs our cost model for optimizing conciseness as the additive cost of
the nodes in the DAG; and \emph{not} as the sum of the costs of all
paths traversed. The type reconstruction problem into DAGs is now to
find the least-cost DAG representing the given displacement sequence.

One crucial difficulty which arises when dealing with such type DAGs
is that the best representation for a subsequence no longer needs to
be locally optimal, since costs savings can be achieved by reusing
other nodes of the DAG. This is illustrated in
Figure~\ref{fig:DAGExample}.

\begin{figure}[h]
\centering
\tikzset{level distance=30pt, sibling distance=0pt}
\Tree 
    [. 
	[.
	    [. ]
	    [. 
		[. ]
	    ]
	]
	[. ] 
	[. 
		[. ]
	]
    ]
\caption{An unfolding of an optimal type DAG representing a
  displacement sequence ;  is an arbitrary subsequence of length
   over . The subtrees rooted at  only
  contribute to the cost function once. Notice that the subtree rooted
  at  is not a least-cost type tree
  representation of the represented subsequence.  }
\label{fig:DAGExample}
\end{figure}

In particular, this implies that the type tree constructed by
unfolding a cost-optimal DAG is not necessarily a cost-optimal tree,
and conversely, that the DAG obtained by folding a given, cost-optimal
type tree is not necessarily a cost-optimal DAG.  This constitutes a
fundamental problem for our general approach for handling type trees,
and new ideas are needed to solve the type reconstruction problem into
DAGs.

\subsection{The type normalization problem}

The type normalization problem subsumes the type reconstruction
problem that we have considered so far. Type normalization asks to
improve the cost of an already given tree description of the data
layout. Since any data layout can be represented as a single 
node with the whole displacement sequence as index sequence, type
normalization includes type reconstruction as a special case. Type
normalization is the problem that compiler or library implementors are
typically faced with: application data structures described as trees
are given by the programmer as part of the code, and an internal,
optimal representation is to be constructed by the programming system.
 
The trivial solution is to flatten the given type tree and apply the
type reconstruction algorithm on the resulting displacement
sequence. Since the size of the resulting displacement sequence is not
bounded by the size or conciseness of the tree, this is highly
undesirable. We would like a procedure where the complexity can be
bounded by the conciseness of the type trees, specifically the total
size of the index sequences in the tree.

As shown in~\cite{Traff14:normalization}, if the set of basic
constructors is restricted to exclude the  constructor, it is
possible to perform type normalization by only rechecking optimality
of the  nodes.  In this case, type normalization can be done in
time proportional to the conciseness of the given tree. When the
 constructor is allowed, arbitrarily more concise
representations can be possible as shown in
Figure~\ref{fig:typetreeExample}. Optimality of a subtree that does
not use the  constructor does therefore not imply optimality
when  is allowed. It is therefore necessary to flatten the
whole tree and apply the tree reconstruction algorithm on the
resulting displacement sequence.

\section{Conclusion}
\label{sec:conclusion}

The main result of this paper is that the type reconstruction problem
into trees is actually solvable in polynomial time. However, an
 algorithm is not useful for larger values of  as might be
the case in parallel applications where  could be proportional to
the number of processors which in itself could be in the range of tens
to hundreds of thousands. We note that our bottom-up dynamic
programming algorithm performs a considerable amount of almost
redundant checking for (strided) repetitions in displacement sequence
segments. An asymptotically more efficient algorithm, perhaps based on
a top-down approach, is likely to exist. Whether an exact, practically
efficient algorithm for the full problem is possible, we do not know
at the point of writing.

Restricting the power of the constructors can permit more efficient
algorithms.  As shown in~\cite{Traff14:normalization}, if only
 and  nodes are allowed, then the type
reconstruction problem for a displacement sequence of length  can
be solved in  time. However, the resulting restricted
trees can and often will be much more costly, as shown in
Figure~\ref{fig:typetreeExample}. The high complexity of our algorithm
is caused by the unbounded branching constructor  node. A
slightly better,  time algorithm would result from allowing
only bounded branching, for instance a binary struct constructor that
catenates only two subtrees. For such a constructor, the shortest path
computation of Lemma~\ref{lemma:strc} could be done in linear time. In
some contexts, bounded branching might be sufficiently expressive.

An alternative approach would be to look for low-complexity
approximation algorithms with provable approximation guarantees. Or,
even weaker, for heuristics that perhaps work well for the intended
application cases. This reflects the state in current MPI libraries.

As discussed, type trees can be represented more concisely as directed
acyclic graphs (DAGs). To the best of our knowledge, it is still open
whether a cost-optimal DAG representation for an arbitrary
displacement sequence can likewise be constructed in polynomial time.

A related problem to consider is the following. Given two displacement
sequences of the same length, construct a least-cost tree (or DAG)
representing a mapping between the two sequences. Such a tree (DAG)
has uses when copying between different data layouts; this arises,
e.g., in matrix transposition. In the MPI context this operation has
been called
\emph{transpacking}~\cite{Traff08:iotypes,RossLathamGroppLuskThakur09}. Our
dynamic programming algorithm may extend to this case as well.

Our work was specifically inspired by the derived data type mechanism
of MPI. We believe that this idea is applicable in a much wider
context of (parallel) programming interfaces and languages, and that
the type normalization and reconstruction problems as defined here, as
well as the associated processing of data layouts represented by
trees, have relevance extending beyond the motivating context.

\bibliographystyle{plain}
\bibliography{traff,parallel}

\end{document}
