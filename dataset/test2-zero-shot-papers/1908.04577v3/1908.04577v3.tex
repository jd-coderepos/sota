\documentclass{article}


\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{arxiv}
\usepackage[T1]{fontenc}
\usepackage{hyperref}       
\usepackage{url}
\usepackage{booktabs}
\usepackage{amsfonts}
\usepackage{nicefrac}
\usepackage{microtype}
\usepackage{lipsum}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{color}
\usepackage{latexsym}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{colortbl,booktabs}
\usepackage{tabu}
\usepackage{float}
\usepackage{amsmath}
\usepackage{subcaption}
\captionsetup{compatibility=false}

\title{StructBERT: Incorporating Language Structures into Pre-training for Deep Language Understanding}

\author{
Wei Wang, 
Bin Bi, 
Ming Yan, 
Chen Wu,
Zuyi Bao,
Jiangnan Xia,
Liwei Peng, 
Luo Si
 \\
Alibaba Group Inc. \\
 \{\texttt{hebian.ww,b.bi,ym119608,wuchen.wc,zuyi.bzy,jiangnan.xjn,liwei.peng,luo.si}\}\texttt{@alibaba-inc.com} \\
}

\begin{document}
\maketitle

\begin{abstract}
Recently, the pre-trained language model, BERT (and its robustly optimized version RoBERTa), has attracted a lot of attention in natural language understanding (NLU), and achieved state-of-the-art accuracy in various NLU tasks, such as sentiment classification, natural language inference, semantic textual similarity and question answering. Inspired by the linearization exploration work of Elman~\cite{elman1990finding}, we extend BERT to a new model, StructBERT, by incorporating language structures into pre-training. Specifically, we pre-train StructBERT with two auxiliary tasks to make the most of the sequential order of words and sentences, which leverage language structures at the word and sentence levels, respectively. As a result, the new model is adapted to different levels of language understanding required by downstream tasks.

The StructBERT with structural pre-training gives surprisingly good empirical results on a variety of downstream tasks, including pushing the state-of-the-art on the GLUE benchmark to 89.0 (outperforming all published models), the F1 score on SQuAD v1.1 question answering to 93.0, the accuracy on SNLI to 91.7.
\end{abstract}

\section{Introduction}
A pre-trained language model (LM) is a key component in many natural language understanding (NLU) tasks such as semantic textual similarity ~\cite{cer2017semeval}, question answering~\cite{rajpurkar2016squad} and sentiment classification~\cite{socher2013recursive}.
In order to obtain reliable language representations, neural language models are designed to define the joint probability function of sequences of words in text with self-supervised learning. Different from traditional word-specific embedding in which each token is assigned a global representation, recent work, such as Cove~\cite{mccann2017learned}, ELMo~\cite{peters2018deep}, GPT~\cite{radford2018improving} and BERT~\cite{devlin2018bert}, derives contextualized word vectors from a language model trained on a large text corpus. These models have been shown effective for many downstream NLU tasks.

Among the context-sensitive language models, BERT (and its robustly optimized version RoBERTa~\cite{liu2019roberta}) has taken the NLP world by storm. It is designed to pre-train bidirectional representations by jointly conditioning on both left and right context in all layers and model the representations by predicting masked words only through the contexts. However, it does not make the most of underlying language structures.

According to Elman~\cite{elman1990finding}'s study, the recurrent neural networks was shown to be sensitive to regularities in word order in simple sentences.
Since language fluency is determined by the ordering of words and sentences, finding the best permutation of a set of words and sentences is an essential problem in many NLP tasks, such as machine translation and NLU~\cite{hasler2017comparison}. Recently, word ordering was treated as LM-based linearization solely based on language models~\cite{schmaltz2016word}. Schmaltz showed that recurrent neural network language models~\cite{mikolov2010recurrent} with long short-term memory~\cite{hochreiter1997long} cells work effectively for word ordering even without any explicit syntactic information.

In this paper, we introduce a new type of contextual representation, StructBERT, which incorporates language structures into BERT pre-training by proposing two novel linearization strategies. Specifically, in addition to the existing masking strategy, StructBERT extends BERT by leveraging the structural information: word-level ordering and sentence-level ordering. We augment model pre-training with two new structural objectives on the inner-sentence and inter-sentence structures, respectively.
In this way, the linguistic aspects~\cite{elman1990finding} are explicitly captured during the pre-training procedure. With structural pre-training, StructBERT encodes dependency between words as well as sentences in the contextualized representation, which provides the model with better generalizability and adaptability.

StructBERT significantly advances the state-of-the-art results on a variety of NLU tasks, including the GLUE benchmark~\cite{wang2018glue}, the SNLI dataset~\cite{bowman2015large} and the SQuAD v1.1 question answering task~\cite{rajpurkar2016squad}. All of these experimental results clearly demonstrate StructBERT's exceptional effectiveness and generalization capability in language understanding.

We make the following major contributions:
\begin{itemize}
\item We propose novel structural pre-training that extends BERT by incorporating the word structural objective and the sentence structural objective to leverage language structures in contextualized representation. This enables the StructBERT to explicitly model language structures by forcing it to reconstruct the right order of words and sentences for correct prediction.
\item StructBERT significantly outperforms all published state-of-the-art models on a wide range of NLU tasks. This model extends the superiority of BERT, and boosts the performance in many language understanding applications such as semantic textual similarity, sentiment analysis, textual entailment, and question answering.
\end{itemize}

\section{StructBERT Model Pre-training}
StructBERT builds upon the BERT architecture, which uses a multi-layer bidirectional Transformer network~\cite{vaswani2017attention}. Given a single text sentence or a pair of text sentences, BERT packs them in one token sequence and learns a contextualized vector representation for each token. Every input token is represented based on the word, the position, and the text segment it belongs to. Next, the input vectors are fed into a stack of multi-layer bidirectional Transformer blocks, which uses self-attention to compute the text representations by considering the entire input sequence.

The original BERT introduces two unsupervised prediction tasks to pre-train the model: i.e., a masked LM task and a next sentence prediction task. Different from original BERT, our StructBERT amplifies the ability of the masked LM task by shuffling certain number of tokens after word masking and predicting the right order. Moreover, to better understand the relationship between sentences, StructBERT randomly swaps the sentence order and predicts the next sentence and the previous sentence as a new sentence prediction task. In this way, the new model not only explicitly captures the fine-grained word structure in every sentence, but also properly models the inter-sentence structure in a bidirectional manner. Once the StructBERT language model is pre-trained with these two auxiliary tasks, we can fine-tune it on task-specific data for a wide range of downstream tasks.

\subsection{Input Representation}
Every input  is a sequence of word tokens, which can be either a single sentence or a pair of sentences packed together. The input representation follows that used in BERT~\cite{devlin2018bert}. For each input token , its vector representation  is computed by summing the corresponding token embedding, positional embedding, and segment embedding. We always add a special classification embedding ([CLS]) as the first token of every sequence, and a special end-of-sequence ([SEP]) token to the end of each segment. Texts are tokenized to subword units by WordPiece~\cite{wu2016google} and absolute positional embeddings are learned with supported sequence lengths up to 512 tokens. In addition, the segment embeddings are used to differentiate a pair of sentences as in BERT.

\subsection{Transformer Encoder}
We use a multi-layer bidirectional Transformer encoder~\cite{vaswani2017attention} to encode contextual information for input representation. Given the input vectors , an -layer Transformer is used to encode the input as:

where ,  and . We use the hidden vector  as the contextualized representation of the input token .

\subsection{Pre-training Objectives}
To make full use of the rich inner-sentence and inter-sentence structures in language, we extend the pre-training objectives of original BERT in two ways: \textcircled{1} word structural objective (mainly for the single-sentence task), and \textcircled{2} sentence structural objective (mainly for the sentence-pair task). We pre-train these two auxiliary objectives together with the original masked LM objective in a unified model to exploit inherent language structures.

\subsubsection{Word Structural Objective}
Despite its success in various NLU tasks, original BERT is unable to explicitly model the sequential order and high-order dependency of words in natural language. Given a set of words in random order from a sentence, ideally a good language model should be able to recover this sentence by reconstructing the correct order of these words. To implement this idea in StructBERT, we supplement BERT's training objectives with a new word structural objective which endows the model with the ability to reconstruct the right order of certain number of intentionally shuffled word tokens. This new word objective is jointly trained together with the original masked LM objective from BERT.

\begin{figure}
     \centering
     \begin{subfigure}[b]{0.45\textwidth}
         \centering
         \includegraphics[width=\textwidth]{figs/word_obj.pdf}
         \caption{Word Structural Objective}
         \label{fig:word_obj}
     \end{subfigure}
     \qquad
     \begin{subfigure}[b]{0.45\textwidth}
         \centering
         \includegraphics[width=\textwidth]{figs/sent_obj.pdf}
         \caption{Sentence Structural Objective}
         \label{fig:sent_obj}
     \end{subfigure}
     \caption{Illustrations of the two new pre-training objectives}
     \label{fig:objectives}
\end{figure}

Figure~\ref{fig:word_obj} illustrates the procedure of jointly training the new word objective and the masked LM objective. In every input sequence, we first mask 15\% of all tokens at random, as done in BERT~\cite{devlin2018bert}. The corresponding output vectors  of the masked tokens computed by the bidirectional Transformer encoder are fed into a softmax classifier to predict the original tokens.

Next, the new word objective comes into play to take word order into consideration. Given the randomicity of token shuffling, the word objective is equivalent to maximizing the likelihood of placing every shuffled token in its correct position. More formally, this objective can be formulated as:

where  represents the set of trainable parameters of StructBERT, and  indicates the length of every shuffled subsequence. Technically, a larger  would force the model to be able to reconstruct longer sequences while injecting more disturbed input. On the contrary, when  is smaller, the model gets more undisturbed sequences while less capable of recovering long sequences. We decide to use trigrams (i.e., ) for subsequence shuffling to balance language reconstructability and robustness of the model.

Specifically, as shown in Figure~\ref{fig:word_obj}, we randomly choose some percentage of trigrams from unmasked tokens, and shuffle the three words (e.g., , , and  in the figure) within each of the trigrams. The output vectors of the shuffled tokens computed by the bidirectional Transformer encoder are then fed into a softmax classifier to predict the original tokens. The new word objective is jointly learned together with the masked LM objective in a unified pre-trained model with equal weights.

\subsubsection{Sentence Structural Objective}
The next sentence prediction task is considered easy for the original BERT model (the prediction accuracy of BERT can easily achieve 97\%-98\% in this task~\cite{devlin2018bert}). We, therefore, extend the sentence prediction task by predicting both the next sentence and the previous sentence, to make the pre-trained language model aware of the sequential order of the sentences in a bidirectional manner.

As illustrated in Figure~\ref{fig:sent_obj}, given a pair of sentences (, ) as input, we predict whether  is the next sentence that follows , or the previous sentence that precedes , or a random sentence from a different document. Specifically, for the sentence ,  of the time we choose the text span that follows  as the second sentence ,  of the time the previous sentence ahead of  is selected, and  of the time a sentence randomly sampled from the other documents is used as . The two sentences are concatenated together into an input sequence with the separator token [SEP] in between, as done in BERT. We pool the model output by taking the hidden state corresponding to the first token [CLS], and feed the encoding vector of [CLS] into a softmax classifier to make a three-class prediction.

\subsection{Pre-training Setup}
The training objective function is a linear combination of the word structural objective and the sentence structural objective. For the masked LM objective, we followed the same masking rate and settings as in BERT~\cite{devlin2018bert}. 5\% of trigrams are selected for random shuffling.

We used documents from English Wikipedia (2,500M words) and BookCorpus~\cite{zhu2015aligning} as pre-training data, following the preprocessing and the WordPiece tokenization from ~\cite{devlin2018bert}. The maximum length of input sequence was set to 512.

We ran Adam with learning rate of 1e-4, , , L2 weight decay of 0.01, learning rate warm-up over the first 10\% of the total steps, and linear decay of the learning rate. We set a dropout probability of 0.1 for every layer. The gelu activation~\cite{hendrycks2016gaussian} was used as done in GPT~\cite{radford2018improving}.

We denote the number of Transformer block layers as , the size of hidden vectors as , and the number of self-attention heads as . Following the practice of BERT, We primarily report experimental results on the two model sizes:

{\bf StructBERT{\small Base}}: , , , Number of parametersM

{\bf StructBERT{\small Large}}: , , , Number of parametersM

Pre-training of StructBERT was performed on a distributed computing cluster consisting of 64 Telsa V100 GPU cards. For the StructBERT{\small Base}, we ran the pre-training procedure for 40 epochs, which took about 38 hours, and the training of StructBERT{\small Large} took about 7 days to complete.





















\section{Experiments}
In this section, we report results of StructBERT on a variety of downstream tasks including General Language Understanding Evaluation (GLUE benchmark), Standford Natural Language inference (SNLI corpus) and extractive question answering (SQuAD v1.1).

Following BERT's practice, during fine-tuning on downstream tasks, we performed a grid search or an exhaustive search (depending on the data size) on the following sets of parameters and chose the model that performed the best on the dev set. All the other parameters remain the same as those in pre-training:

{\small \emph{Batch size}: 16, 24, 32; 
\emph{Learning rate}: 2e-5, 3e-5, 5e-5; 
\emph{Number of epochs}: 2, 3; 
\emph{Dropout rate}: 0.05, 0.1}



\begin{table*}[ht]
\scriptsize\center
\begin{tabular}{l|l|l|l|l|l|l|l|l|l|l|l}
 \hline
\bf System & \bf CoLA & \bf SST-2 & \bf MRPC & \bf STS-B & \bf QQP & \bf MNLI & \bf QNLI & \bf RTE & \bf WNLI & \bf AX & \bf Average\\
 & 8.5k & 67k & 3.5k & 5.7k & 363k & 392k & 108k & 2.5k & 634 & \\
 \hline
 Human Baseline&	66.4&	97.8&	86.3/80.8&	92.7/92.6&	59.5/80.4&	92.0/92.8&	91.2&	93.6&	95.9&	-\\
 \hline
 BERT{\tiny Large}~\cite{devlin2018bert} &60.5 &	94.9 &	89.3/85.4 &	87.6/86.5 &	72.1/89.3 &	86.7/85.9 &	92.7 &	70.1 &	65.1 &	39.6  & 80.5\\
 BERT on STILTs~\cite{phang2018sentence}&	62.1&	94.3&	90.2/86.6&	88.7/88.3&	71.9/89.4&	86.4/85.6&	92.7&	80.1&	65.1&	28.3& 82.0\\
SpanBERT~\cite{joshi2019spanbert}& 64.3 & 94.8 & 90.9/87.9 & 89.9/89.1 & 71.9/89.5 & 88.1/87.7 & 
94.3 & 79.0 & 65.1 & 45.1 & 82.8 \\
 Snorkel MeTaL~\cite{ratner2017snorkel}&	63.8&	96.2&	91.5/88.5&	90.1/89.7&	73.1/89.9&	87.6/87.2&	93.9&	80.9&	65.1&	39.9& 83.2\\
 MT-DNN++~\cite{liu2019multi}&	65.4&	95.6&	91.1/88.2&	89.6/89.0&	72.7/89.6&	87.9/87.4&	95.8&	85.1&	65.1&	41.9& 83.8\\
 MT-DNN ensemble~\cite{liu2019multi}&	65.4&	96.5&	92.2/89.5&	89.6/89.0&	73.7/89.9&	87.9/87.4&	96.0&	85.7&	65.1&	42.8& 84.2\\
 \hline 
 StructBERT{\tiny Base}	&	57.2&	94.7&	89.9/86.1&	88.5/87.6&	72.0/89.6&	85.5/84.6	&92.6&	76.9&	65.1&	39.0&80.9 \\
 StructBERT{\tiny Large}&	65.3&	95.2&	92.0/89.3&	90.3/89.4&	74.1/90.5&	88.0/87.7	&95.7&	83.1&	65.1&	43.6& 83.9 \\
 StructBERT{\tiny Large} ensemble& 68.6&95.2& 92.5/90.1 &91.1/90.6 & 74.4/90.7 & 88.2/87.9 &95.7 &83.1
 & 65.1 &  43.9 &  84.5\\
 \hline
 XLNet ensemble~\cite{yang2019xlnet} & 67.8 & 96.8 & 93.0/90.7 & 91.6/91.1 & 74.2/90.3 & 90.2/89.8 & 98.6 & 86.3 & 90.4 & 47.5 & 88.4\\
 RoBERTa ensemble~\cite{liu2019roberta} & 67.8 & 96.7 & 92.3/89.8 & 92.2/91.9 & 74.3/90.2 &  90.8/90.2 & 98.9 &  88.2 & 89.0 &  48.7 & 88.5\\
 Adv-RoBERTa ensemble & 68.0 & 96.8 & 93.1/90.8 & 92.4/92.2 & {\bf 74.8/90.3} &
 {\bf 91.1/90.7} & 98.8 & {\bf 88.7} & 89.0 & {\bf 50.1} & 88.8 \\
 StructBERT{\tiny RoBERTa} ensemble & {\bf 69.2} & {\bf 97.1} & {\bf 93.6/91.5} & {\bf 92.8/92.4} & {\bf 74.4/90.7} &  90.7/90.3 & {\bf 99.2} & 87.3 & {\bf 89.7} & 47.8 & {\bf 89.0} \\
 \hline 
 
\end{tabular}
\caption{Results of published models on the GLUE test set, which are scored by the GLUE evaluation server. The number below each task
denotes the number of training examples. The state-of-the-art results are in bold. All the results are obtained from \url{https://gluebenchmark.com/leaderboard} (StructBERT submitted under a different model name ALICE).}
\label{table:glue}
\end{table*}

\subsection{General Language Understanding}
\subsubsection{GLUE benchmark}
The General Language Understanding Evaluation (GLUE) benchmark~\cite{wang2018glue} is a collection of nine NLU tasks, covering textual entailment (RTE~\cite{bentivogli2009fifth} and MNLI~\cite{williams2017broad}), question-answer entailment (QNLI~\cite{wang2018glue}), paraphrase (MRPC~\cite{dolan2005automatically}), question paraphrase (QQP~\footnote{\small{\url{https://data.quora.com/First-Quora-Dataset-Release-Question-Pairs}}}), textual similarity (STS-B~\cite{cer2017semeval}), sentiment (SST-2~\cite{socher2013recursive}), linguistic acceptability (CoLA~\cite{warstadt2018neural}), and Winograd Schema (WNLI~\cite{levesque2012winograd}). 

On the GLUE benchmark, given the similarity of MRPC/RTE/STS-B to MNLI, we fine-tuned StructBERT on MNLI before training on MRPC/RTE/STS-B data for the respective tasks. This follows the two-stage transfer learning STILTs introduced in~\cite{phang2018sentence}. For all the other tasks (i.e., RTE, QNLI, QQP, SST-2, CoLA and MNLI), we fine-tuned StructBERT for each single task only on its in-domain data.

Table~\ref{table:glue} presents the results of published models on the GLUE test set obtained from the official benchmark evaluation server. Our StructBERT{\small Large} ensemble suppressed all published models (excluding RoBERTa ensemble and XLNet ensemble) on the average score, and performed the best among these models in six of the nine tasks. In the most popular MNLI task, our StructBERT{\small Large} single model improved the best result by 0.3\%/0.5\%, since we fine-tuned MNLI only on its in-domain data, this improvement is entirely attributed to our new training objectives. The most significant improvement over BERT was observed on CoLA (4.8\%), which may be due to the strong correlation between the word order task and the grammatical error correction task. In the SST-2 task, our model improved over BERT while performed worse than MT-DNN did, which indicates that sentiment analysis based on single sentences benefits less from the word structural objective and sentence structural objective.

\begin{table}[b]
\begin{center}
\begin{tabular}{l|c|c|c|c|c}
\hline \bf Model & \bf GPT & \bf BERT & \bf MT-DNN & \bf SJRC & \bf StructBERT{\small Large}\\
\hline
Dev & - & 90.1 & 91.4 & - & {\bf 92.2} \\
Test & 89.9 & 90.8 & 91.1 & 91.3 & {\bf 91.7} \\
\hline
\end{tabular}
\end{center}
\caption{Accuracy (\%) on the SNLI dataset. }
\label{table:snli}
\end{table}

With pre-training on large corpus, XLNet ensemble and RoBERTa ensemble outperformed all published models including our StructBERT{\small Large} ensemble. To take advantage of the large data which RoBERTa is trained on, we continued pre-training with our two new objectives from the released RoBERTa model, named StructBERT{\small RoBERTa}. At the time of paper submission, our StructBERT{\small RoBERTa} ensemble, which was submitted under a different name ALICE, achieved the best performance among all published models including RoBERTa on the leaderboard, creating a new state-of-the-art result of 89.0\% on the average GLUE score. It demonstrates that the proposed objectives are able to improve language models in addition to BERT.

\subsubsection{SNLI}
Natural Language Inference (NLI) is one of the important tasks in natural language understanding. The goal of this task is to test the ability of the model to reason the semantic relationship between two sentences. In order to perform well on an NLI task, a model needs to capture the semantics of sentences, and thus to infer the relationship between a pair of sentences: entailment, contradiction or neutral.

\begin{table*}[t]
\begin{center}
\begin{tabular}{lllll}
\hline
\bf System & \bf Dev set && \bf Test set & \\
 & \bf EM & \bf F1 & \bf EM & \bf F1 \\
\hline
Human & - & - & 82.3 & 91.2 \\
XLNet(single+DA) ~\cite{yang2019xlnet} & 88.9 & 94.5 & 89.9 & 85.0 \\
BERT(ensemble+DA) ~\cite{devlin2018bert}& 86.2 & 92.2 & 87.4 & 93.2 \\
KT-NET(single) ~\cite{yang2019enhancing}& 85.1 & 81.7 & 85.9 & 92.4 \\
BERT(single+DA) ~\cite{devlin2018bert}& 84.2 & 91.1 & 85.1 & 91.8 \\
QANet(ensemble+DA)~\cite{yu2018qanet} &- & - & 84.5 & 90.5\\
\hline
StructBERT{\small Large} (single) & 85.2& 92.0& - & - \\
StructBERT{\small Large} (ensemble) &  87.0 & 93.0 & - & - \\
\hline
\end{tabular}
\end{center}
\caption{SQuAD results. The StructBERT{\small Large} ensemble is 10x systems which use different pre-training checkpoints and fine-tuning seeds.}
\label{table:squad}
\end{table*}

We evaluated our model on the most widely used NLI dataset: The Stanford Natural Language Inference (SNLI) Corpus~\cite{bowman2015large}, which consists of 549,367/9,842/9,824 premise-hypothesis pairs in train/dev/test sets and target labels indicating their relations. 
We performed a grid search on the sets of parameters, and chose the model that performed best on the dev set.

Table~\ref{table:snli} shows the results on the SNLI dataset of our model with other published models. StructBERT outperformed all existing systems on SNLI, creating new state-of-the-art results 91.7\%, which amounts to 0.4\% absolute improvement over the previous state-of-the-art model SJRC and 0.9\% absolute improvement over BERT. Since the network architecture of our model is identical to that of BERT, this improvement is entirely attributed to the new pre-training objectives, which justifies the effectiveness of the proposed tasks of word prediction and sentence prediction.

\subsection{Extractive Question Answering}
SQuAD v1.1 is a popular machine reading comprehension dataset consisting of 100,000+ questions created by crowd workers on 536 Wikipedia articles~\cite{rajpurkar2016squad}. The goal of the task is to extract the right answer span from the corresponding paragraph given a question.

We fine-tuned our StructBERT language model on the SQuAD dataset for 3 epochs, and compared the result against the state-of-the-art methods on the official leaderboard~\footnote{\small{\url{https://rajpurkar.github.io/SQuAD-explorer/}}}, as shown in Table~\ref{table:squad}. We can see that even without any additional data augmentation (DA) techniques, the proposed StructBERT model was superior to all published models except XLNet+DA on the dev set.~\footnote{\small{We have submitted the model under the name of ALICE to the SQuAD v1.1 CodaLab for evaluation on the test set. However, due to crash of the Codalab evaluation server, we have not got our test result back yet at the time of paper submission. We will update the result once it is announced.}}. With data augmentation and large corpus used during pre-training, XLNet+DA outperformed our StructBERT which did not use data augmentation or large pre-training corpus. It demonstrates the effectiveness of the proposed pre-trained StructBERT in modeling the question-paragraph relationship for extractive question answering. Incorporating the word and sentence structures significantly improves the understanding ability in this fine-grained answer extraction task.

\begin{table*}[t]
\centering
\begin{tabular}{l|l|l|l|l|l|l}
\hline
\bf Task & \bf CoLA & \bf SST-2 & \bf MNLI & \bf SNLI & \bf QQP & \bf SQuAD \\
 & (Acc) & (Acc) & (Acc) & (Acc) & (Acc) & (F1) \\
 \hline
 StructBERT{\small Base} & {\bf 85.8} &  {\bf 92.9} &	{\bf 85.4} &	91.5 &	{\bf 91.1} &	{\bf 90.6} \\
 -word structure &	81.7 &	92.7  &	85.2 &	{\bf 91.6} &	90.7 &	90.3 \\
 -sentence structure &	84.9 & {\bf 92.9} &	84.1 &	91.1 &	90.5 &	89.1 \\
 BERT{\small Base} &	80.9 & 92.7 &	84.1 &	91.3 &	90.4 &	88.5 \\
 \hline 

\end{tabular}
\caption{Ablation over the pre-training objectives using StructBERT{\small Base} architecture. Every result is the average score of 8 runs with different random seeds (the MNLI accuracy is the average score of the matched and mis-matched settings).
  }
\label{table:ablation}
\end{table*}

\begin{figure*}[b!]
    \centering
    \begin{subfigure}[b]{0.3\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figs/lm_loss.png}
    \end{subfigure}
    \quad\quad
    \begin{subfigure}[b]{0.3\textwidth}  
        \centering 
        \includegraphics[width=\textwidth]{figs/lm_acc.png}
    \end{subfigure}\\
\begin{subfigure}[b]{0.3\textwidth}   
        \centering 
        \includegraphics[width=\textwidth]{figs/sp_loss.png}
    \end{subfigure}
    \quad\quad
    \begin{subfigure}[b]{0.3\textwidth}   
        \centering 
        \includegraphics[width=\textwidth]{figs/sp_acc.png}
    \end{subfigure}
    \caption[]
    {Loss and accuracy of word and sentence prediction over the number of pre-training steps} 
    \label{fig:loss_acc}
\end{figure*}

\subsection{Effect of Different Structural Objectives}
We have demonstrated the strong empirical results of the proposed model on a variety of downstream tasks. In the StructBERT pre-training, the two new structural prediction tasks are the most important components. Therefore, we conducted an ablation study by removing one structural objective from pre-training at a time to examine how the two structural objectives influence the performance on various downstream tasks. 

Results are presented in Table~\ref{table:ablation}. From the table, we can see that: (1) the two structural objectives were both critical to most of the downstream tasks, except for the word structural objective in the SNLI task. Removing any word or sentence objective from pre-training always led to degraded performance in the downstream tasks. The StructBERT model with structural pre-training consistently outperformed the original BERT model, which shows the effectiveness of the proposed structural objectives. (2) For the sentence-pair tasks such as MNLI, SNLI, QQP and SQuAD, incorporating the sentence structural objective significantly improved the performance. It demonstrates the effect of inter-sentence structures learned by pre-training in understanding the relationship between sentences for downstream tasks. (3) For the single-sentence tasks such as CoLA and SST-2, the word structural objective played the most important role. Especially in the CoLA task, which is related to the grammatical error correction, the improvement was over 5\%. The ability of reconstructing the order of words in pre-training helped the model better judge the acceptability of a single sentence.

We also studied the effect of both structural objectives during self-supervised pre-training. Figure~\ref{fig:loss_acc} illustrates the loss and accuracy of word and sentence prediction over the number of pre-training steps for StructBERT{\small Base} and BERT{\small Base}. From the two sub-figures on top, it is observed that compared with BERT, the augmented shuffled token prediction in StructBERT's word structural objective had little effect on the loss and accuracy of masked token prediction. On the other hand, the integration of the simpler task of shuffled token prediction (lower loss and higher accuracy) provides StructBERT with the capability of word reordering. In contrast, the new sentence structural objective in StructBERT leads to a more challenging prediction task than that in BERT, as shown in the two figures at the bottom. This new pre-training objective enables StructBERT to exploit inter-sentence structures, which benefits sentence-pair downstream tasks.

\section{Related Work}
\subsection{Contextualized Language Representation}
A word can have different semantics depending on the its context. Contextualized word representation is considered to be an important part of modern NLP research, with various pre-trained language models~\cite{mccann2017learned,peters2018deep,radford2018improving,devlin2018bert} emerging recently. ELMo~\cite{peters2018deep} learns two unidirectional LMs based on long short-term memory networks (LSTMs). A forward LM reads the text from left to right, and a backward LM encodes the text from right to left. Following the similar idea of ELMo, OpenAI GPT~\cite{radford2018improving} expands the unsupervised language model to a much larger scale by training on a giant collection of free text corpora. Different from ELMo, it builds upon a multi-layer Transformer~\cite{vaswani2017attention} decoder, and uses a left-to-right Transformer to predict a text sequence word-by-word.



In contrast, BERT~\cite{devlin2018bert} (as well as its robustly optimized version RoBERTa~\cite{liu2019roberta}) employs a bidirectional Transformer encoder to fuse both the left and the right context, and introduces two novel pre-training tasks for better language understanding. We base our LM on the architecture of BERT, and further extend it by introducing word and sentence structures into pre-training tasks for deep language understanding.





\subsection{Word \& Sentence Ordering}
The task of linearization aims to recover the original order of a shuffled sentence~\cite{schmaltz2016word}. Part of larger discussion as to whether LSTMs are capturing syntactic phenomena linearization, is standardized in a recent line of research as a method useful for isolating the performance of text-to-text generation~\cite{zhang2015discriminative} models.
Recently, Transformers have emerged as a powerful architecture for learning the latent structure of language. For example, Bidirectional Transformers (BERT) has reduced the perplexity for language modeling task. We revisit Elman's question by applying BERT to the word-ordering task, without any explicit syntactic approaches, and find that pre-trained language models are effective for various downstream tasks with linearization.

Many important downstream tasks such as STS and NLI ~\cite{wang2018glue} are based on understanding the relationship between two text sentences, which is not directly captured by language modeling. While BERT~\cite{devlin2018bert} pre-trains a binarized next sentence prediction task to understand sentence relationships, we take one step further and treat it as a sentence ordering task.
The goal of sentence ordering is to arrange a set of sentences into a coherent text in a clear and consistent manner, which can be viewed as a ranking problem~\cite{chen2016neural}. The task is general and yet challenging, and once is especially important for natural language generation~\cite{reiter1997building}. 
Text should be organized according to the following properties: rhetorical coherence, topical relevancy, chronological sequence, and cause-effect. In this work, we focus on what is arguably the most basic characteristics of a sequence: their order. Most of prior work on sentence ordering was part of the study of downstream tasks, such as multi-document summarization~\cite{bollegala2010bottom}. We revisit this problem in the context of language modeling as a new sentence prediction task.

\section{Conclusion}
In this paper, we propose novel structural pre-training which incorporates word and sentence structures into BERT pre-training. A word structural objective and a sentence structural objective are introduced as two new pre-training tasks for deep understanding of natural language in different granularities. Experimental results demonstrate that the new StructBERT model can obtain new state-of-the-art results in a variety of downstream tasks, including the popular GLUE benchmark, the SNLI Corpus and the SQuAD v1.1 question answering.

\bibliography{references}
\bibliographystyle{plain}

\end{document}
