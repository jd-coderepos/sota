

\documentclass{scrartcl}
\def\arXiv{}




\usepackage{basicstuff}

\usepackage{caption} \usepackage{subcaption} \usepackage[absolute,overlay]{textpos} \usepackage{tikz} \usepackage{textcomp} \usepackage{refcount} \usepackage{array}



\usepackage{booktabs}

\renewcommand{\todo}[1]{}

\newcommand*\circled[1]{ \protect\tikz[baseline=(char.base)]{ \protect\node[shape=circle,draw,inner sep=0.2pt] (char) {#1};}} 



\newcommand{\1}[1]{{\normalfont \ensuremath{#1^{\tiny\circled{1}}}}} \newcommand{\2}[1]{{\normalfont \ensuremath{#1^{\tiny\circled{2}}}}} \renewcommand{\k}[1]{{\normalfont \ensuremath{#1^{\tiny\circled{k}}}}} \newcommand{\proj}[2]{\ensuremath{\left.#1\right|_{#2}}} \newcommand{\eps}{\varepsilon}
\DeclareMathOperator{\skel}{skel} \DeclareMathOperator{\expan}{exp} \DeclareMathOperator{\pert}{pert} \DeclareMathOperator{\pos}{pos} \DeclareMathOperator{\bel}{bel} \DeclareMathOperator{\roo}{root} \DeclareMathOperator{\cyc}{cyc} \DeclareMathOperator{\high}{high} \DeclareMathOperator{\lca}{LCA} \DeclareMathOperator{\contr}{contr} \DeclareMathOperator{\side}{side} \DeclareMathOperator{\en}{end} \DeclareMathOperator{\curr}{curr} \DeclareMathOperator{\prev}{prev} \DeclareMathOperator{\nex}{next} \DeclareMathOperator{\temp}{temp} \DeclareMathOperator{\detcyc}{detcyc} 


\ifdefined\elsevier

\usepackage{lmodern} \usepackage{amsthm} 

\theoremstyle{plain} \newtheorem{theorem}{Theorem} \newcounter{lemmacounter} \setcounter{lemmacounter}{0} \newtheorem{lemma}[lemmacounter]{Lemma} \newtheorem{fact}{Fact}  \newtheorem{corollary}{Corollary} \theoremstyle{definition} \newtheorem{definition}{Definition} 

\fi

\ifdefined\arXiv

\usepackage{arXiv} 

\title{\Large Disconnectivity and Relative Positions\\in Simultaneous
  Embeddings\thanks{Part of this work was done within GRADR --
    EUROGIGA project no. 10-EuroGIGA-OP-003.}}

\author{Thomas Bläsius \myand Ignaz Rutter}

\date{Karlsruhe Institute of Technology (KIT), Germany\\\medskip \texttt{\{blaesius,rutter\}@kit.edu}}

\fi


\begin{document}

\ifdefined\elsevier

\begin{frontmatter}
  
  \title{Disconnectivity and Relative Positions in Simultaneous
    Embeddings\tnoteref{eurogigia,confversion}}

  \tnotetext[eurogiga]{Part of this work was done within GRADR --
    EUROGIGA project no. 10-EuroGIGA-OP-003.} 

  \tnotetext[confversion]{A preliminary version of this work has been
    published as T. Bläsius and I. Rutter: Disconnectivity and Relative
    Positions in Simultaneous Embeddings, \emph{Proceedings of the 20th
      International Symposium on Graph Drawing (GD'12)}, pages 31--42,
    LNCS, Springer, 2012}


  \author{Thomas Bläsius} \ead{blaesius@kit.edu}
  \author{Ignaz Rutter}
  \ead{rutter@kit.edu}
  \address{Karlsruhe Institute of Technology (KIT), Germany}
\fi

\ifdefined\arXiv
\maketitle
\fi

  \begin{abstract}
    For two planar graphs  and 
    sharing a common subgraph  the problem {\sc
      Simultaneous Embedding with Fixed Edges (SEFE)} asks whether
    they admit planar drawings such that the common graph is drawn the
    same.  Previous algorithms only work for cases where~ is
    connected, and hence do not need to handle relative positions of
    connected components.  We consider the problem where~, 
    and~ are not necessarily connected.



    First, we show that a general instance of {\sc SEFE} can be
    reduced in linear time to an equivalent instance where 
    and  and  are connected.  Second, for the case where~
    consists of disjoint cycles, we introduce the \emph{CC-tree} which
    represents all embeddings of~ that extend to planar embeddings
    of~.  We show that CC-trees can be computed in linear time,
    and that their intersection is again a CC-tree.  This yields a
    linear-time algorithm for {\sc SEFE} if all  input graphs
    (possibly ) pairwise share the same set of disjoint cycles.
    These results, including the CC-tree, extend to the case where 
    consists of arbitrary connected components, each with a fixed
    planar embedding on the sphere.  Then the running time
    is~.
  \end{abstract}

\ifdefined\elsevier
\end{frontmatter}
\fi

\section{Introduction}
\label{sec:introduction}

To enable a human reader to compare different relational datasets on a
common set of objects it is important to visualize the corresponding
graphs in such a way that the common parts of the different datasets
are drawn as similarly as possible.  An example is a dynamic graph
that changes over time.  Then the change between two points in time
can be easily grasped with the help of a visualization showing the
parts that did not change in the same way for both graphs.  This leads
to the fundamental theoretical problem {\sc Simultaneous Embedding
  with Fixed Edges} (or {\sc SEFE} for short), asking for two graphs
 and  with the common graph , whether there are planar
drawings of  and  such that the common graph  is drawn
the same in both.

The problem {\sc SEFE} and its variants, such as {\sc Simultaneous
  Geometric Embedding}, where one insists on a simultaneous
straight-line drawing, have been studied intensively in the past
years; see the recent survey~\cite{bkr-sepg-13} for an overview.  Some
of the results show, for certain graph classes, that they always admit
simultaneous embeddings or that there exist negative instances of SEFE
whose input graphs belong to these classes.  As there are planar
graphs that cannot be embedded simultaneously, the question of
deciding whether given graphs admit a {\sc SEFE} is of high interest.
Gassner et al.~\cite{SimultaneousGraphEmbeddings-Gassner.etal(06)}
show that it is -complete to decide {\sc SEFE} for
three or more graphs.  For two graphs the complexity status is still
open.  However, there are several approaches yielding efficient
algorithms for special cases.  Fowler at al. show how to solve {\sc
  SEFE} efficiently, if~ and~ have at most two and one cycles,
respectively~\cite{SPQR-TreeApproachto-Fowler.etal(09)}.  Fowler et
al. characterize the class of common graphs that always admit a {\sc
  SEFE}~\cite{Characterizationsofrestricted-Fowler.etal(11)}.
Angelini et al.~\cite{adf-tppeg-10} show that if one of the input
graphs has a fixed planar embedding, then {\sc SEFE} can be solved in
linear time.  Haeupler et al. solve {\sc SEFE} in linear time for the
case that the common graph is
biconnected~\cite{TestingSimultaneousPlanarity-Haeupler.etal(10)}.
Angelini et al. obtain the same result with a completely different
approach~\cite{adfpr-tsegi-12}.  They additionally solve the case
where the common graph is a star and, moreover, show the equivalence
of the case where the common graph is connected to the case where the
common graph is a tree and relate it to a constrained book embedding
problem.  The currently least restrictive result (in terms of
connectivity) by Bläsius and Rutter~\cite{br-spqoacep-13} shows that
{\sc SEFE} can be solved in polynomial time for the case that both
graphs are biconnected and the common graph is connected.

The algorithms testing {\sc SEFE} have in common that they use the
result by Jünger and
Schulz~\cite{IntersectionGraphsin-Juenger.Schulz(09)} stating that the
question of finding a simultaneous embedding for two graphs is
equivalent to the problem of finding planar embeddings of  and
 such that they induce the same embedding on~.  Moreover, they
have in common that they all assume that the common graph is
connected, implying that it is sufficient to enforce the common edges
incident to each vertex to have the same circular ordering in both
embeddings.  Especially in the result by Bläsius and
Rutter~\cite{br-spqoacep-13} this is heavily used, as they explicitly
consider only orders of edges around vertices using PQ-trees.
However, if the common graph is not required to be connected, we
additionally have to care about the relative positions of connected
components to one another, which introduces an additional difficulty.
Note that the case where the common graph is disconnected cannot be
reduced to the case where it is connected by inserting additional
edges.  Figure~\ref{fig:cannot-connect-common-graph} shows an instance
that admits a simultaneous embedding, which is no longer true if the
isolated vertex  is connected to the remaining graph.  Other
approaches to solve the SEFE problem have only appeared recently.
Schaefer~\cite{s-ttp-13} characterizes, for certain classes of SEFE
instances, the pairs of graphs that admit a SEFE via the independent
odd crossing number.  Among others, this gives a polynomial-time
algorithm for SEFE when the common graph has maximum degree~3 and is
not necessarily connected.

\begin{figure}
  \centering
  \includegraphics{fig/cannot-connect-common-graph}
  \caption{The bold edges belong to both graphs, the dashed and thin
    edges are exclusive edges.}
  \label{fig:cannot-connect-common-graph}
\end{figure}

In this work we tackle the {\sc SEFE} problem from the opposite
direction \todo{Pag 3, line -6}than the so far known results, by
assuming that the circular order of edges around vertices in  is
already fixed and we only have to ensure that the embeddings chosen
for the input graphs are \emph{compatible} in the sense that they
induce the same relative positions on~.  Initially, we assume that
the graph  consists of a set of disjoint cycles, each of them
having a unique planar embedding.  We present a novel data structure,
the \emph{CC-tree}, which represents all embeddings of a set of
disjoint cycles that can be induced by an embedding of a graph
containing them as a subgraph.  We moreover show that two such
CC-trees can be intersected, again yielding a CC-tree.  Thus, for the
case that  and  have the common graph  consisting of a
set of disjoint cycles, the intersection of the CC-trees corresponding
to  and  represents all simultaneous embeddings.  We show
that CC-trees can be computed and intersected in linear time, yielding
a linear-time algorithm to solve {\sc SEFE} for the case that the
common graph consists of disjoint cycles.  Note that this obviously
also yields a linear-time algorithm to solve {\sc SEFE} for more than
two graphs if they all share the same common graph consisting of a set
of disjoint cycles.  We show that these results can be further
extended to the case where the common graph may contain arbitrary
connected components, each of them with a prescribed planar embedding.
However, in this case the corresponding data structure, called
CC-tree, may have quadratic size.  These results show that
the choice of relative positions of several connected components does
not solely make the problem {\sc SEFE} hard to solve.

\todo{Pag 3, line 14-15:}Note that these results have an interesting
application concerning the problem {\sc Partially Embedded Planarity}.
The input of \textsc{Partially Embedded Planarity} is a planar graph
 together with a fixed embedding for a subgraph  (including
fixed relative positions).  It asks whether  admits a planar
embedding extending the embedding of .  Angelini et
al.~\cite{adf-tppeg-10} introduced this problem and solve it in linear
time.  The CC-tree can be used to solve {\sc Partially
  Embedded Planarity} in quadratic time as it represents all possible
relative positions of the connected components in  to one another
that can be induced by an embedding of .  It is \todo{Pag 3, line
  18:}then easy to test whether the prespecified relative positions
can be achieved.  In fact, this solves the slightly more general case
of {\sc Partially Embedded Planarity} where not all relative positions
have to be fixed.

The above described results have one restriction that was not
mentioned so far.  The graphs~ and  are assumed to be
connected, otherwise the approach we present does not work.
Fortunately, we can show that both graphs of an instance of {\sc SEFE}
can always be assumed to be connected, even if all vertices are
assumed to be common vertices (forming isolated vertices when not
connected via a common edge).  This shows that {\sc SEFE} can be solved
efficiently if the common graph consists of disjoint cycles without
further restrictions on the connectivity.  Moreover, it is an
interesting result on its own as it applies to arbitrary instances of
{\sc SEFE}, not only to the special case we primarily consider here.

As connectivity plays an important role in this work we fix some basic
definitions in the following.  A graph is \emph{connected} if there
exists a path between any pair of vertices.  A \emph{separating
  -set} is a set of  vertices whose removal disconnects the
graph.  Separating 1-sets and 2-sets are \emph{cutvertices} and
\emph{separation pairs}, respectively.  A connected graph is
\emph{biconnected} if it does not have a cut vertex and
\emph{triconnected} if it does not have a separation pair.  The
maximal biconnected components of a graph are called \emph{blocks}.
The \emph{cut components} with respect to a separating -set  are
the maximal subgraphs that are not disconnected by removing .

\paragraph{Outline.}

In Section~\ref{sec:disconnected-graphs} we show that, for any given
instance of {\sc SEFE}, there exists an equivalent instance such that
both input graphs are connected, even if each vertex is assumed to be
a common vertex.  With this result instances of {\sc SEFE} can always
be assumed to have this property.  In Section~\ref{sec:disj-cycl} we
show how to solve {\sc SEFE} in linear time if the common graph
consists of disjoint cycles, including a compact representation of all
simultaneous embeddings.  In Section~\ref{sec:extension} we show how
to extend these results to solve {\sc SEFE} in quadratic time for the
case that the common graph consists of arbitrary connected components,
each with a fixed planar embedding.  We conclude in
Section~\ref{sec:conclusion}.

\section{Connecting Disconnected Graphs}
\label{sec:disconnected-graphs}

Let  and  be two planar graphs with
common graph  with .  We show that the
problem {\sc SEFE} can be reduced to the case where  and 
are required to be connected.  First note that the connected
components of the union of  and  can be handled
independently.  Thus we can assume that  is connected.
We first ensure that  is connected without increasing the number
of connected components in .  Afterwards we can apply the same
steps to  to make it connected, maintaining the connectivity of
.

Assume  and  consist of  and  connected
components, respectively.  Since the union of  and  is
connected, we can always find an edge  such
that the vertices  and  belong to different connected
components  and  in .  We construct the
\emph{augmented instance}  of {\sc SEFE} with
respect to the edge  by introducing a new vertex  and new
edges  and .
Note that  has  connected components since 
and  are now connected via the two edges  and .
Moreover, the number  of connected components in  does not
change, since the edge  connects the new vertex  to one of
its connected components.  It remains to show that the original
instance and the augmented instance are equivalent.

\begin{figure}
  \centering
  \includegraphics[page=1]{fig/connecting-graphs}
  \caption{Illustration of Lemma~\ref{lem:connecting-graphs}, the
    common graph is depicted black.  The graph  with the edge
     lying in the common face , which is the
    outer face of  (left).  The graph  with the faces
     incident to  and
    , respectively, partitioned into 
    and~~(middle). The resulting graph  after choosing
     as outer face of  (for ) and inserting
    the vertex  and the edges  and  (right).}
  \label{fig:connecting-graphs}
\end{figure}

\begin{lemma}
\label{lem:connecting-graphs}
  Let  be an instance of {\sc SEFE} and let  be the augmented instance with respect to the edge .  Then  and  are
  equivalent.
\end{lemma}
\begin{proof}
  If the augmented instance admits a {\sc SEFE}, then obviously the
  original instance does.  To show the other direction assume the
  original instance  has a {\sc SEFE}  inducing the embedding  for the common
  graph.  We show how to construct an embedding  such
  that \todo{Pag 4, proof of Lemma 1, lines 2-3:}(i)  is a {\sc SEFE}, and (ii) the vertices 
  and  lie on the border of a common face in~.
  Then we can easily add the vertex  together with the two
  edges  and~, yielding a {\sc SEFE} of the augmented instance
  .  Note that the first property, namely that
   is a {\sc SEFE}, is satisfied if
  and only if the embeddings  and 
  induce the same embedding  on the common graph.
  Figure~\ref{fig:connecting-graphs} illustrates the proof.

  Consider a face  of the embedding  of the common
  graph.  The embedding  of the graph~ splits
  this face  into a set of faces .  We say that a face 
  is \emph{contained} in .  Note that every face of  is contained in exactly one face of .  The same
  definition can be made for the second graph.

  The edge  borders two faces  and
   of .  Since  belongs exclusively
  to~ (otherwise  and  would not have been in different
  connected components in ) both faces~ and 
  are contained in the same face  of the embedding  of
  the common graph .  We assume without loss of generality that 
  is the outer face.  The face  may be subdivided by edges
  belonging exclusively to the graph .  However, we can find
  faces  and  of , both contained
  in~, such that  and  are contained in the boundary of
  these faces.  If  we are done since  and
   lie on the boundary of the same face in .
  Otherwise, we split  into two subgraphs~ and~
  with the embeddings  and 
  induced by  as follows.  The connected
  component~ (for~) containing  belongs to
   and all connected components that are completely contained
  in an internal face of  also belong to .  All
  remaining connected components belong either to  or to
  .  Note that this partition ensures that there is a simple
  closed curve in the outer face of  separating
   and .  Thus, we can change the embeddings
  of~ and~ independently.  In
  particular, we choose the faces  and  to be the
  new outer faces, yielding the changed embeddings 
  and , respectively.  When combining these to
  embeddings by putting  into the outer face of  and
  vice versa, we obtain a new embedding  of 
  with the following two properties.  First, the embedding induced for
  the common graph does not change since both faces  and
   belong to the outer face  of the embedding 
  of the common graph .  Second, the vertices  and  both
  lie on the outer face of the embedding .  Hence,
   is still a {\sc SEFE} of the
  instance  and the vertex  together with the two
  edges  and~ can be added easily, which concludes the proof.
\end{proof}

With this construction we can reduce the number of connected
components of  and  and thus finally obtain an equivalent
instance of {\sc SEFE} in which both graphs are connected.  We obtain
the following Theorem.

\begin{theorem}
  \label{thm:connecting-graphs}
  For every instance  of {\sc SEFE} there exits an
  equivalent instance  such that
   and  are connected.  Such an instance can
  be computed in linear time.
\end{theorem}
\begin{proof}
  Lemma~\ref{lem:connecting-graphs} directly implies that an
  equivalent instance  in which both graphs
  are connected exists.  It remains to show that it can be computed in
  linear time.  To connect all the connected components of , we
  contract each of them to a single vertex in the graph .  Then
  an arbitrary spanning tree yields a set of edges , such that augmenting the instance with
  respect to these edges yields a connected graph .  This
  works symmetrically for  and can obviously be done in linear
  time.
\end{proof}

\section{Disjoint Cycles}
\label{sec:disj-cycl}

In this section, we consider the problem {\sc SEFE} for the case that
the common graph consists of a set of disjoint cycles.  Due to
Theorem~\ref{thm:connecting-graphs}, we can assume without loss of
generality that both graphs are connected.  In
Section~\ref{sec:disj-cycl-poly-time} we show how to solve this
special case of {\sc SEFE} in polynomial time.  In
Section~\ref{sec:compact-rep} we introduce a tree-like data structure,
the \emph{CC-tree}, representing all planar embeddings of a set of
cycles contained in a single graph that can be induced by an embedding
of the whole graph.  We additionally show that the intersection of the
set of embeddings represented by two CC-trees can again be represented
by a CC-tree, yielding a solution for {\sc SEFE} even for the case of
more than two graphs if all graphs have the same common graph, which
consists of a set of disjoint cycles.  In
Section~\ref{sec:line-time-algor} we show how to compute the CC-tree
and the intersection of two CC-trees in linear time.  Before we start,
we fix some definitions.

\paragraph{Embeddings of Disjoint Cycles.}
\label{sec:embedd-disj-cycl}

Let  be a set of disjoint simple
cycles.  We consider embeddings of these cycles on the sphere.  Since
a single cycle has a unique embedding on the sphere only their
relative positions to one another are of interest.  To be able to use
the terms ``left'' and ``right'' we consider the cycles to be
directed.  We denote the relative position of a cycle  with
respect to a cycle  by .  More precisely, we
have  and , if  lies on the left and right side of ,
respectively.  We call an assignment of a value ``left'' or ``right''
to each of these relative positions a \emph{semi-embedding} of the
cycles .  Note that not every
semi-embedding yields an embedding of the cycles.  For example if
 and
, then  also
needs to have the value ``left''; see Figure~\ref{fig:semi-embedding}.
However, two embeddings yielding the same semi-embedding are the same.

Sometimes we do not only consider the relative position of cycles but
also of some other disjoint subgraph.  We extend our notation to this
case.  For example the relative position of a single vertex  with
respect to a cycle  is denoted by .

\begin{figure}
  \centering
  \includegraphics{fig/semi-embedding}
  \caption{Three nested cycles.}
  \label{fig:semi-embedding}
\end{figure}

\paragraph{SPQR- and BC-Trees.}
\label{sec:spqr-trees}

The \emph{block-cutvertex tree (BC-tree)}  of a connected
graph is a tree whose nodes are the blocks and cutvertices of the
graph, called \emph{B-nodes} and \emph{C-nodes}, respectively.  In the
BC-tree a block  and a cutvertex  are joined by an edge if 
belongs to .  If an embedding is chosen for each block, these
embeddings can be combined to an embedding of the whole graph if and
only if  can be rooted at a B-node such that the parent of
every other block  in , which is a cutvertex, lies on
the outer face of .

We use the \emph{SPQR-tree} introduced by Di Battista and
Tamassia~\cite{dt-omtc-96,dt-opt-96} to represent all planar
embeddings of a biconnected planar graph .  The SPQR-tree  of  is a decomposition of  into triconnected components along
its \emph{split pairs}, where a split pair is either a separation pair
or an edge.  We define the SPQR-tree to be unrooted, representing
embeddings on the sphere, that is planar embeddings without a
designated outer face.  Let  be a split pair and let 
and~ be two subgraphs of  such that  and
.  Consider the tree containing the two nodes
 and  associated with the graphs  and
, respectively.  These graphs are called
\emph{skeletons} of the nodes , denoted by  and
the special edge  is said to be a \emph{virtual edge}.  The
two nodes  and  are connected by an edge or, more
precisely, the occurrence of the virtual edges  in both
skeletons are linked by this edge.  The \emph{expansion graph}
 of a virtual edge  is the subgraph of 
it represents, that is in  and  the
expansion graphs of  are  and , respectively.  Now
a combinatorial embedding of  uniquely induces a combinatorial
embedding of  and .  Furthermore,
arbitrary and independently chosen embeddings for the two skeletons
determine an embedding of , thus the resulting tree can be used to
represent all embeddings of  by the combination of all embeddings
of two smaller planar graphs.  This replacement can of course be
applied iteratively to the skeletons yielding a tree with more nodes
but smaller skeletons associated with the nodes.

Applying this kind of decomposition in a systematic way yields the
SPQR-tree as introduced by Di Battista and
Tamassia~\cite{dt-omtc-96,dt-opt-96}.  The SPQR-tree  of a
biconnected planar graph  contains four types of nodes.  \todo{Pag
  7, line 1-2:}First, the skeleton of a P-node consists of a bundle of
at least three parallel edges.  Embedding the skeleton of a P-node
corresponds to choosing an order for the parallel edges.  Second, the
skeleton of an R-node is triconnected, thus having exactly two
embeddings~\cite{w-cgcg-32}, and third, S-nodes have a simple cycle as
skeleton without any choice for the embedding.  Finally, every edge in
a skeleton representing only a single edge in the original graph 
is formally also considered to be a virtual edge linked to a Q-node in
 representing this single edge.  Note that all leaves of
the SPQR-tree~ are Q-nodes.  Besides from being a nice way
to represent all embeddings of a biconnected planar graph, the
SPQR-tree has size only linear in the size of  and Gutwenger and
Mutzel~\cite{gm-lti-00} show that it can be computed in linear time.
Figure~\ref{fig:spqr-tree} shows a biconnected planar graph together
with its SPQR-tree.

\begin{figure}
  \centering
  \includegraphics[page=1]{fig/SPQR-tree}
  \caption{The unrooted SPQR-tree of a biconnected planar graph.  The
    nodes ,  and  are P-nodes,  is an
    R-node and  is an S-node.  The Q-nodes are not shown
    explicitely.}
  \label{fig:spqr-tree}
\end{figure}

\subsection{A Polynomial-Time Algorithm}
\label{sec:disj-cycl-poly-time}

Let  be an instance of {\sc SEFE} with common graph 
consisting of pairwise disjoint simple cycles .  We first assume that  and  are biconnected
and show later how to remove this restriction.  Our approach is to
formulate constraints on the relative positions of the cycles to one
another ensuring that  and  induce the same semi-embedding
on the common graph .  We show implicitly that the resulting
semi-embedding is really an embedding by showing that the graphs 
and  have planar embeddings inducing this semi-embedding.  Note
that this only works for the case that  and  are connected.
Thus, our approach crucially relies on the result provided in
Section~\ref{sec:disconnected-graphs}.

\subsubsection*{Biconnected Graphs}
\label{sec:biconnected-graphs}

Before considering two graphs, we determine for a single graph the
possible embeddings it may induce on a set of disjoint cycles
contained in it.  Let  be a biconnected graph with
SPQR-tree , let  be a simple directed cycle in  and
let  be a node in .  Obviously,  is either
completely contained in the expansion graph of a single virtual edge
of  or  induces a simple directed cycle of virtual edges in
.  We say that  is \emph{contracted} in  in
the first case and that  is \emph{a cycle} in  in the
second case.
If~
is a cycle in~, we also say that~
\emph{contains}~ as a cycle.  Consider the case where  is a
cycle in  and let~ denote this cycle.  By fixing
the embedding of  the virtual edges in  not
contained in  split into two groups, some lie to the left and
some to the right of .  Obviously, a vertex~ in the expansion graph of a virtual edge that lies to the left
(to the right) of~ lies to the left (to the right) of  in
, no matter which embedding is chosen for the skeletons of other
nodes.  In other words, the value of  is completely
determined by this single node~.  We show that for every vertex
 there is a node  in~ containing  as a
cycle such that the virtual edge in  containing  in its
expansion graph is not contained in the cycle  induced by .
Hence such a node~ determining 
always exists.  Extending this to a pair of cycles yields the
following lemma.

\begin{lemma}
  \label{lem:determining-pos-by-ex-one}
  Let  be a biconnected planar graph with SPQR-tree 
  and let  and  be two disjoint simple cycles in .  There
  is exactly one node  in  determining
  .  Moreover,  contains  as cycle
   and  either as a cycle or contracted in an edge not
  contained in .
\end{lemma}
\begin{proof}
  We choose some vertex  as representative for the whole
  cycle.  Consider a Q-node~ in the SPQR-tree 
  corresponding to an edge contained in .  Moreover, let 
  be a Q-node corresponding to an edge incident to .  We claim that
  the desired node  lies somewhere on the path  in the SPQR-tree .

  Obviously  is a cycle in  and the vertex  belongs to
  the virtual edge in .  In  the vertex  is a
  pole and  is contracted in the virtual edge of 
  since .  Assume we are navigating from  to
   and let  be the current node.  If  does
  not contain the vertex , it belongs to a single virtual edge in
  .  In this case  is obviously the node
  corresponding to this virtual edge.  If  is a vertex of
  , then  corresponds to one of the virtual
  edges incident to  in .  As long as  is a
  cycle in the current node and  belongs to a virtual edge in this
  cycle, the next node in the path corresponds to this virtual edge
  and thus~ remains a cycle.  Since  is contracted in
  , we somewhere need to follow a virtual edge not contained in
  the cycle induced by ; let  be this node.  By definition
   contains  as cycle~ and the next node on the path
  belongs to a virtual edge that is not contained in  but
  contains~ in its expansion graph.  Thus  is
  determined by this node .  Since  is a node of the second
  cycle  also  is completely determined by this
  node.  Moreover,  contains  as cycle~ and 
  either as a cycle or contracted in a virtual edge not belonging to
  .
\end{proof}

Now consider a set of pairwise disjoint cycles  in .  Let  be an arbitrary node in the SPQR-tree
.  If  is an S- or a Q-node it clearly does not
determine any of the relative positions since either every cycle is
contracted in  or a single cycle is a cycle in
 containing all the virtual edges.  In the following, we
consider the two interesting cases namely that  is an R- or a
P-node containing at least one cycle as a cycle.

Let  be a {\bf P-node} in  with 
consisting of two vertices  and  with parallel virtual
edges~ between them.  If 
is contained as a cycle in , it induces a cycle 
in  consisting of two of the parallel virtual edges.  Let
without loss of generality  and  be these virtual
edges.  Obviously, no other cycle  is a cycle in
 since such a cycle would need to contain  and ,
which is a contradiction to the assumption that  and  are
disjoint.  Thus, every other cycle  is contracted in ,
belonging to one of the virtual edges .  If
it belongs to  or , which are contained in ,
then  is not determined by~.  If  belongs to
one of the virtual edges , the relative
position  is determined by the relative position of this
virtual edge with respect to the cycle .  This relative
position can be chosen for every virtual edge  arbitrarily and independently.  Hence, if there are two
cycles  and~ belonging to different virtual edges in , the
positions  and  can be chosen
independently.  Furthermore, if the two cycles  and  belong
to the same virtual edge ,
their relative position with respect to  is the same, that is
, for every embedding of .

Let  be an {\bf R-node} in .  For the moment, we
consider that the embedding of  is fixed by choosing one
of the two orientations.  Let  be a cycle inducing the cycle
 in .  Then the relative position 
of a cycle  is determined by  if and only if  is a
cycle in  or if it is contracted belonging to a virtual
edge not contained in .  Since we consider only one of the two
embeddings of  at the moment,  is fixed to
one of the two values ``left'' or ``right'' in this case.  The same
can be done for all other cycles that are cycles in 
yielding a fixed value for all relative positions that are determined
by .  Finally, we have a partition of all positions determined by
 into the set of positions  all
having the value ``left'' and the set of positions 
having the value ``right''.  Now if the embedding of  is
not fixed anymore, we have only the possibility to flip it.  By
flipping, all the positions in  change to ``right'' and
all positions in  change to ``left''.  Hence, we obtain
that the equation  is satisfied for every embedding of the
cycles  induced by an embedding of
.

To sum up, we obtain a set of (in)equalities relating the relative
positions of cycles to one another.  We call these constraints the
\emph{PR-node constraints} with respect to the biconnected graph~.
Obviously the PR-node constraints are necessary in the sense that
every embedding of  induces an embedding of the cycles  satisfying these constraints.  The following
lemma additionally states the sufficiency of the PR-node constraints.

\begin{lemma}
  \label{lem:PR-node-constraints}
  Let  be a biconnected planar graph containing the disjoint cycles
  .  Let further  be a semi-embedding of these cycles.  There is an
  embedding  of  inducing  if
  and only if  satisfies the PR-node
  constraints.
\end{lemma}
\begin{proof}
  The ``only if''-part of the proof is obvious, as mentioned above.
  It remains to show the ``if''-part.  Let 
  be a semi-embedding of  satisfying
  the PR-node constraints given by~.  We show how to construct an
  embedding  of  inducing the embedding  on the cycles~.
  We simply process the nodes of the SPQR-tree one by one and choose
  an embedding for the skeleton of every node.  Let  be a node in
  .  If  is an S- or a Q-node, there is nothing to
  do, since there is no choice for the embedding of .  If
   is a P-node several relative positions may be determined by
  the embedding of .  However, these positions satisfy the
  PR-node constraints stemming from , hence we can choose an
  embedding for  determining these positions as given
  by~.  Obviously, the same holds for the
  case where  is an R-node.  Hence, we finally obtain an
  embedding~ of  determining the positions that are
  determined by a node in  as required by .  Due to Lemma~\ref{lem:determining-pos-by-ex-one}
  every pair of relative positions is determined by exactly one node
  in , yielding that the resulting embedding 
  induces  on the cycles.  Note that this
  shows implicitly that  is not only a
  semi-embedding but also an embedding.
\end{proof}

Now let  and  be two biconnected planar graphs with the
common graph  consisting of pairwise disjoint simple cycles
.  If we find a semi-embedding
 of the cycles that satisfies the PR-node constraints with
respect to  and  simultaneously, we can use
Lemma~\ref{lem:PR-node-constraints} to find embeddings  and  for  and  both inducing the
embedding  on the common graph~.  Thus, satisfying the
PR-node constraints with respect to both  and , is
sufficient to find a {\sc SEFE}.  Conversely, given a pair of
embeddings  and  inducing the same
embedding  on~, this embedding  needs to
satisfy the PR-node constraints with respect to both,  and ,
which is again due to Lemma~\ref{lem:PR-node-constraints}.  Since the
PR-node constraints form a set of boolean (in)equalities we can
express them as an instance of {\sc 2-Sat}.  As this instance has
polynomial size and can easily be computed in polynomial time, we
obtain the following theorem.

\begin{theorem} 
  \label{thm:sefe-biconnected-quadratic}
  {\sc Simultaneous Embedding with Fixed Edges} can be solved in
  quadratic time for biconnected graphs whose common graph is a set of
  disjoint cycles.
\end{theorem}
\begin{proof}
  It remains to show that the PR-node constraints can be computed in
  quadratic time, yielding an instance of {\sc 2-Sat} with quadratic
  size.  As this {\sc 2-Sat} instance can be solved consuming time
  linear in its size~\cite{ComplexityofTimetable-Even.etal(76),
    linear-timealgorithmtesting-Aspvall.etal(79)}, we obtain a
  quadratic-time algorithm.

  We show how to process each node  of the SPQR-tree in  time, computing the PR-node constraints
  stemming from .  For each virtual edge  we compute a list
  of cycles in  that contain edges in the expansion graph
   by traversing all leaves in the corresponding
  subtree, consuming  time for each virtual edge.  Then
  the list of cycles that occur as cycles in  can be
  computed in linear time.  For each of these cycles  all
  constraints on relative positions with respect to  determined by
   can be easily computed in  time.  As only
   cycles can be contained as cycles in
  , this yields the claimed  time for each skeleton.  Since the total size of the
  skeletons is linear in the size of the graph, this yields an overall
  -time algorithm.
\end{proof}

\subsubsection*{Allowing Cutvertices}
\label{sec:cutvertices}

In this section we consider the case where the graphs may contain
cutvertices.  As before, we consider a single graph  containing a
set of disjoint cycles  first.  Let
 be one of the cycles and let  be a cutvertex
contained in the same block  that contains~.  The cutvertex 
splits  into  cut components .  Assume
without loss of generality that  (and with it also ) is
contained in .  We distinguish between the cases that  is
contained in  and that it is not.

If {\bf  is not contained in }, then
the relative position  is determined by the embedding of
the block  and it follows that all the subgraphs  lie on the same side of  as  does.  It follows from the
biconnected case (Lemma~\ref{lem:determining-pos-by-ex-one}) that
 is determined by the embedding of the skeleton of
exactly one node  in the SPQR-tree of .  Obviously, the
conditions that all cycles in  are on the same
side of  as  can be easily added to the PR-node constraints
stemming from the node ; call the resulting constraints the
\emph{extended PR-node constraints}.  These constraints are clearly
necessary.  On the other hand, if  is a
semi-embedding of the cycles satisfying the extended PR-node
constraints, we can find an embedding  of the block 
such that all relative positions of cycles that are determined by
single nodes in the SPQR-tree of  are compatible with~.

If {\bf  is contained in }, the
relative position  does not exist.  Assume the embedding
of each block is already chosen.  Then for each subgraph , the positions  can be chosen
arbitrarily and independently.  In this case we say for a cycle 
in  that its relative position  is \emph{determined
  by the embedding chosen for the cutvertex }.  Obviously, in every
embedding of , a pair of cycles  and  both belonging to
the same subgraph  lie on the same side
of  yielding the equation .  This
equation can be set up for every pair of cycles in each of the
subgraphs, yielding the \emph{cutvertex constraints} with respect
to~.  Again we have that, given a semi-embedding  of the cycles satisfying the cutvertex constraints
with respect to , we can simply choose an embedding of the graph
such that the relative positions determined by the embedding around
the cutvertex are compatible with~.

To sum up, a semi-embedding  on the cycles
 that is induced by an
embedding~ of the whole graph always satisfies the
extended PR-node and cutvertex constraints.  Moreover, given a
semi-embedding  satisfying these constraints,
we can find an embedding  of  inducing compatible
relative positions for each relative position that is determined by a
single node in the SPQR-tree of a block or by a cutvertex.  Obviously,
the relative position of every pair of cycles is determined by such a
node or a cutvertex.  Thus the extended PR-node and cutvertex
constraints together are sufficient, that is, given a semi-embedding
of the cycles satisfying these constraints, we can find an embedding
of  inducing this semi-embedding.  This shows implicitly that the
given semi-embedding is an embedding.  This result is stated again in
the following lemma.

\begin{lemma}
  \label{lem:ext-PR-node-cutvert-constraints}
  Let  be a connected planar graph containing the disjoint cycles
  .  Let further~ be a semi-embedding of these cycles.  There is an embedding
   of  inducing~ if and only
  if  satisfies the extended PR-node and
  cutvertex constraints with respect to~.
\end{lemma}

This result again directly yields a polynomial-time algorithm to solve
{\sc SEFE} for the case that both graphs  and  are connected
and their common graph  consists of a set of disjoint cycles.
Moreover, requiring both graphs to be connected is not really a
restriction due to Theorem~\ref{thm:connecting-graphs}.  The extended
PR-node and cutvertex constraints can be computed similarly as in the
proof of Theorem~\ref{thm:sefe-biconnected-quadratic}, yielding the
following theorem.

\begin{theorem}
  {\sc Simultaneous Embedding with Fixed Edges} can be solved in
  quadratic time if the common graph consists of disjoint cycles.
\end{theorem}

Note that we really need to use Theorem~\ref{thm:connecting-graphs} to
ensure that the graphs are connected since our approach does not
extend to the case where the graphs are allowed to be disconnected.
In this case it would still be easy to formulate necessary conditions
in terms of boolean equations.  However, these conditions would only
be sufficient if it is additionally ensured that the given
semi-embedding actually is an embedding.  The reason why this is not
directly ensured by the embedding of the graph (as it is in the
connected case) is that the relative position of cycles to one another
is not determined by exactly one choice that can be made independently
from the other choices; see Figure~\ref{fig:disonnected-graphs}.

\begin{figure}
  \centering
  \includegraphics{fig/disconnected-graphs}
  \caption{One component containing  (bold) and another consisting
    only of the vertex .  Changing the face in which  lies may
    change the relative position .  Moreover, changing the
    embedding of the component containing  (in this case flipping
    it) also changes .}
  \label{fig:disonnected-graphs}
\end{figure}

\subsection{A Compact Representation of all Simultaneous Embeddings}
\label{sec:compact-rep}

In the previous section we showed that {\sc SEFE} can be solved in
polynomial time for the case that the common graph consists of
disjoint cycles.  In this section we describe a data structure, the
\emph{CC-tree}, representing all embeddings of a set of disjoint cycles that
can be induced by an embedding of a connected graph containing them.
Afterwards, we show that the intersection of the sets of embeddings
represented by two CC-trees can again be represented by a CC-tree.  In
Section~\ref{sec:line-time-algor} we then show that the CC-tree and
the intersection of two CC-trees can be computed in linear time,
yielding an optimal linear-time algorithm for {\sc SEFE} for the case
that the common graph consists of disjoint cycles.  Note that this
algorithm obviously extends to the case where  graphs  are given such that they all intersect in the same common graph
 consisting of a set of disjoint cycles.

\subsubsection*{C-Trees and CC-Trees}
\label{sec:cc-trees}

Let  be a set of disjoint cycles.  A
\emph{cycle-tree (C-tree)}  on these cycles
is a minimal connected graph containing ; see
Figure~\ref{fig:cc-tree}.  Obviously, every embedding of  induces an embedding of the cycles.  We say that two
embeddings of  are equivalent if they induce
the same embedding of  and we are only interested in the
equivalence classes with respect to this equivalence relation.  An
embedding  of the cycles in  is
\emph{represented} by  if it admits an
embedding inducing .  Note that contracting each of the
cycles  in a C-tree to a single
vertex yields a spanning tree on these vertices.  In most cases we
implicitly assume the cycles to be contracted such that  can be treated like a tree.

\begin{figure}
  \centering
  \includegraphics[page=1]{fig/cc-tree}
  \caption{Two embeddings of the same CC-tree.  The only difference
    between the embeddings is that different values are chosen for the
    crucial relative position .  Note that the tree
    structure enforces the (non-crucial) relative position
     to be equal to .}
  \label{fig:cc-tree}
\end{figure}

The embedding choices that can be made for 
are of the following kind.  For every edge  in
, we can decide to put all cycles in the
subtree attached to  via~ either to the left or to the right of
.  In particular, we can assign a value ``left'' or ``right'' to
the relative position .  Moreover, by fixing the relative
positions  and  for every pair of cycles 
and  that are adjacent in , the embedding
represented by  is completely determined.
Thus, given a C-tree , we call the relative
positions  and  with 
\emph{crucial} if  and~ are adjacent in ; see Figure~\ref{fig:cc-tree}.  We note that, when determining
an embedding of~, the crucial relative
positions can be chosen independently from one another.

Since the crucial relative positions with respect to a C-tree
 are binary variables, we can use
(in)equalities between them to further constrain the embeddings
represented by .  We call a C-tree with such
additional constraints on its crucial relative positions a
\emph{constrained cycle-tree (CC-tree)} on the set of cycles .  In this way, there is a bijection between the embeddings
of~ represented by a CC-tree and the solutions of an
instance of {\sc 2-Sat} given by the constraints on the crucial
relative positions of~.  We essentially prove
two things.  First, for every connected graph  containing the
cycles , there exists a CC-tree representing exactly the
embeddings of  that can be induced by embeddings of .
Essentially, we have to restrict the extended PR-node and cutvertex
constraints to the crucial relative positions of a C-tree compatible
with .  Second, for a pair of CC-trees~ and  on the same set~ of cycles, there exists a CC-tree 
representing exactly the embeddings of  that are
represented by  and .

Let~ be a connected planar graph containing a set~ of
disjoint cycles.  We say that a C-tree  is
\emph{compatible} with  if it is a minor of , that is if it can
be obtained by contracting edges in a subgraph of .  The
corresponding \emph{compatible CC-tree} is obtained from~ by adding the subset of the extended PR-node and
cutvertex constraints that only involve crucial relative positions
of~.  Note that there may be many compatible
CC-trees for a single graph .  However, in the following we
arbitrarily fix one of them and speak about \emph{the} CC-tree of~.

\begin{theorem}
  \label{thm:cycle-tree-is-rep}
  Let  be a connected planar graph containing the disjoint cycles
  .  The CC-tree  of 
  represents exactly the embeddings of  that can be
  induced by an embedding of .
\end{theorem}
\begin{proof}
  Let  be an embedding of  and let  be the embedding induced on the cycles .  Obviously, the CC-tree  can be obtained from  by contracting the cycles  to single vertices, choosing a spanning tree, expanding the
  cycles and contracting edges incident to non-cycle vertices.  Since
  we essentially only pick a subgraph of  containing all cycles
   and contract edges, the embedding
   is preserved.  Moreover, by
  Lemma~\ref{lem:ext-PR-node-cutvert-constraints}, it satisfies the
  extended PR-node and cutvertex constraints since it is induced by
  the embedding  of .  Hence, 
  is represented by the CC-tree~.

  Conversely, let  be an embedding on the
  cycles represented by the CC-tree .  By
  definition, the extended PR-node and cutvertex constraints are
  satisfied for the crucial relative positions.  We show that the
  tree-like structure of  ensures that they
  are also satisfied for the remaining relative positions, yielding
  that an embedding  of  inducing  exists due to Lemma~\ref{lem:ext-PR-node-cutvert-constraints}.
  We start with the PR-node constraints.  Let  be a block of 
  with SPQR-tree .  In a P-node  containing a
  cycle  as cycle  every other cycle in  is contracted,
  belonging to a single virtual edge.  Let~ and  be two
  cycles in  belonging to the same virtual edge  not
  contained in .  In this case the PR-node constraints
  stemming from  require , and we show
  that this equation is implied if the extended PR-node constraints
  are satisfied for the crucial relative positions.  Let~ and
   be the first cycles on the paths from  to  and 
  in , respectively.  Note that~
  and~ are not necessarily contained in the block .  However,
  we first consider the case where both are contained in .  Then
   and  are both contracted in the same virtual
  edge~ as  and  since a path from a cycle belonging
  to  to a cycle belonging to a different virtual edge would
  necessarily contain a pole of  and thus a vertex in .
  Thus, the PR-node constraints restricted to the crucial relative
  positions enforce .  Furthermore,
  the tree structure of  enforces
   and .  Hence, in this case the PR-node constraints
  stemming from  are implied by their restriction to the crucial
  relative positions.  For the case that  or  are contained
  in a different block, they are connected to  via
  cutvertices~ or , which must belong to  by the
  same argument as above, namely that every path from  or  to a
  vertex that is contained in the expansion graph of another virtual
  edge needs to contain one of the poles.  Thus, the extended PR-node
  constraints enforce  yielding the
  same situation as above.  In total, the extended PR-node constraints
  stemming from a P-node  restricted to the crucial relative
  positions enforce that the PR-node constraints stemming from 
  are satisfied for all relative positions.

  For the case that  is an R-node a similar argument holds.  If
   is a cycle  in  and two cycles  and
   lie contracted or as cycles on the same side (on different
  sides) of , then the first cycles  and  on the
  path from  to  and  in the CC-tree  lie on the same side (on different sides) of
   or the cutvertices connecting  and  to the
  block  lie on the same side (on different sides) of .
  Thus, the extended PR-node constraints restricted to the crucial
  relative positions enforce 
  () and the tree structure of
   yields  and
  .  Obviously, these arguments extend to
  the case of extended PR-node constraints since a cutvertex not
  contained in  can be treated like a disjoint cycle.

  It remains to deal with the cutvertex constraints stemming from the
  case where  is a cycle containing a cutvertex  splitting 
  into the cut components .  Let without loss of
  generality  be the subgraph containing .  The cutvertex
  constraints ensure that a pair of cycles  and  belonging
  to the same subgraph  are located on
  the same side of .  Let  and~ be the first cycles on
  the path from  to  and~ in the CC-tree , respectively.  Obviously~ and~ belong
  to the same subgraph  and hence the cutvertex constraints
  restricted to the crucial relative positions enforce .  Moreover, the tree structure of  again ensures that the equations  and  hold, which concludes
  the proof.
\end{proof}

\subsubsection*{Intersecting CC-Trees}
\label{sec:inters-cc-trees}

In this section we consider two CC-trees 
and  on the same set of cycles .  We show that the set of embeddings that are represented by both
 and  can
again be represented by a single CC-tree.  We will show this by
constructing a new CC-tree, which we call the \emph{intersection}
of~ and ,
showing afterwards that this CC-tree has the desired property.  The
intersection  is a copy of  with some additional constraints given by the
second CC-tree .  We essentially have to
formulate two types of constraints.  First, constraints stemming from
the structure of the underlying C-tree of .  Second, the constraints given by the (in)equalities on the
relative positions that are crucial with respect to .  We show that both kinds of constraints can be
formulated as (in)equalities on the relative positions that are
crucial with respect to .

Let  and  be two cycles joined by an edge in .  Obviously,  and  are contained in the
boundary of a common face in every embedding 
represented by .  It is easy to formulate
constraints on the relative positions that are crucial with respect to
 such that~ and~ are contained
in the boundary of a common face for every embedding represented by
.  Consider the path  from  to
 in .  For every three cycles ,
 and  appearing consecutively on  it is necessary that
 holds.  Otherwise  and  would
be separated by .  Conversely, if this equation holds for every
triple of consecutive cycles on , then  and  always lie
on a common face.  We call the resulting equations the
\emph{common-face constraints}.  Note that all relative positions
involved in such constraints are crucial with respect to .

To formulate the constraints given on the crucial relative positions
of , we essentially find, for each of
these crucial relative positions , a relative
position  that is crucial with respect to
 such that  is
determined by fixing  in .  More precisely, for every relative position
 that is crucial with respect to  we define its \emph{representative} in  to be the crucial relative position
, where  is the first cycle in  on the path from  to .  We obtain the
\emph{crucial-position constraints} on the crucial relative positions
of  by replacing every relative position
in the constraints given for  by its
representative.  The resulting set of (in)equalities on the crucial
relative positions of  is obviously
necessary.

We can now formally define the \emph{intersection}  of two CC-trees  and
 to be  with
the common-face and crucial-position constraints additionally
restricting its crucial relative positions.  We obtain the following
theorem, justifying the name ``intersection''.

\begin{theorem}
  \label{thm:intersection-is-intersection}
  The intersection of two CC-trees represents exactly the embeddings
  that are represented by both CC-trees.
\end{theorem}
\begin{proof}
  Let  and 
  be two CC-trees and let  be their
  intersection.  Let further  be an embedding represented
  by  and .
  Then  also represents  since
  the common-face and crucial-position constraints are obviously
  necessary.  Now let  be an embedding represented
  by~.  It is clearly also represented by
   since  is the
  same tree with some additional constraints.  It remains to show that
   is represented by .  The
  embedding  induces a value for every relative position.
  In particular, it induces a value for every relative position that
  is crucial with respect to~.  The
  crucial-position constraints ensure that these values satisfy the
  constraints given for the crucial relative positions in the CC-tree
  .  Thus we can simply take these
  positions, apply them to  and obtain an
  embedding  that is represented by .  It remains to show that~.  To this end, we consider an arbitrary pair of
  cycles  and  and show the following equation, where
   and  denote the relative
  positions of  with respect to  in the embeddings~ and , respectively.



  Consider the paths  and  from  to  in
   and ,
  respectively.  We use induction on the length of ,
  illustrated in Figure~\ref{fig:intersection-CC-trees}, with
  Equation~\eqref{eq:1} as induction hypothesis.  If ,
  then  is crucial with respect to  and thus equal in both embeddings 
  and  by construction of .  For the
  case  let  and  be the neighbors of
   in  and , respectively.  Since  and
   lie on the path between  and  in  and , the following two
  equations hold.

Thus, it suffices to show that  holds to obtain Equation~\eqref{eq:1}.  Let
   be the neighbor of  on the path .  Since the
  path from  to  is shorter than  the equation
   follows from the
  induction hypothesis stated in Equation~\eqref{eq:1}.  There are two
  possibilities.  The path from  to  in  has either  or  for
  some other cycle  as first edge.  In the former case the
  equation

obviously follows.  Together with Equations~\eqref{eq:2}
  and~\eqref{eq:3}, this yields the induction hypothesis
  (Equation~\eqref{eq:1}).  In the latter case we have the following
  equation.

Moreover, the common-face constraints stemming from the edge
   in  enforce 

again yielding the induction hypothesis stated in
  Equation~\eqref{eq:1}.  This concludes the proof.
\end{proof}

\begin{figure}
  \centering
  \includegraphics[page=1]{fig/intersection-CC-trees}
  \caption{The two cases arising in the proof of
    Theorem~\ref{thm:intersection-is-intersection}.  If the path from
     to  starts with the edge  (left) the
    equation  follows by
    induction.  Otherwise (right)  follows by induction and the equation
     holds due to the
    common-face constraint stemming from .}
  \label{fig:intersection-CC-trees}
\end{figure}

\subsection{Linear-Time Algorithm}
\label{sec:line-time-algor}

In this section we first show how to compute the CC-tree of a given
graph containing a set of disjoint cycles in linear time.  Afterwards,
we show that the intersection of two CC-trees can be computed in
linear time.  Together, this yields a linear-time algorithm for the
variant of {\sc SEFE} we consider.

\subsubsection*{Computing the CC-Tree in Linear Time}
\label{sec:computing-cc-tree}

\todo{Pag 15, line 1 of ``Computing...time'':}The first step of
computing the CC-tree  of a graph  is to
compute the underlying C-tree.  Obviously, this can be easily done in
linear time.  Thus, the focus of this section lies on computing the
extended PR-node and cutvertex constraints restricted to the crucial
relative positions.  To simplify notation we first consider the case
where  is biconnected.  Before we start computing the PR-node
constraints we need one more definition.  For each cycle  there is
a set of inner nodes in the SPQR-tree  containing  as a
cycle.  We denote the subgraph of  induced by these nodes
by~ and call it the \emph{induced subtree} with
respect to .  To justify the term ``subtree'' we prove the
following lemma.

\begin{lemma}
  Let  be a biconnected planar graph with SPQR-tree 
  containing the disjoint cycles .
  The induced subtrees  with respect to  are pairwise
  edge-disjoint trees.
\end{lemma}
\begin{proof}
  We first show that the induced tree with respect to a single cycle
  is really a tree.  Afterwards, we show that two disjoint cycles
  induce edge-disjoint trees, yielding that they have linear size in
  total.

  Let  be a cycle in  and let  be its
  induced tree.  A Q-node in  contains  as a cycle if
  and only if the corresponding edge is contained in .  For each
  pair of these Q-nodes all nodes on the path between them are
  contained in , thus the Q-nodes are in the
  same connected component in the induced subtree.  Moreover, an
  internal node in  cannot be a leaf in , implying that it contains only one connected component.

  Assume there are two cycles  and  inducing trees
   and  that are not
  edge-disjoint.  Let  be an edge in 
  belonging to both.  Let further  and  be the
  cycles in  induced by  and , respectively.
  Since the neighbor  of  also contains  as a cycle,
  it corresponds to a virtual edge  in  that is contained
  in .  Similarly,  is also contained in ,
  which is a contradiction since  and  are disjoint.
\end{proof}

Our algorithm computing the PR-node constraints consists of four
phases, each of them consuming linear time.  In each phase we compute
data we then use in the next phase.  Table~\ref{tab:data} gives an
overview about the data we compute.  During all phases we assume the
SPQR-tree  to be rooted at a Q-node corresponding to an
edge in  that is not contained in any cycle in .  In
the first phase we essentially compute the induced trees
.  More precisely, for every node  in the
SPQR-tree we compute a list  containing a cycle  if and
only if  is a cycle in \todo{Pag 16, line 19:}, that is
if and only if  is contained in .
Moreover, we say a virtual edge  in  \emph{belongs}
to a cycle  if  induces a cycle in  containing
.  Note that  belongs to at most one cycle.  If 
belongs to , we set ; if  does not belong to
any cycle, we set .  Finally, the root of an
induced tree  with respect to the root chosen
for  is denoted by .  To sum
up, in the first phase we compute  for every node ,
 for every virtual edge  and  for every induced subtree .  In the
second phase, we compute  as the highest edge in the
SPQR-tree  on the path from  to the root whose
endpoints are both reachable from~ without using edges contained
in any of the induced subtrees .  Note that
 is the edge in~ incident to the root if no
edge on the path from  to the root is contained in one of the
induced subtrees.  For the special case that the edge from  to
its parent itself is already contained in one of the induced trees,
the edge  is not defined and we set .
In the third phase we compute for every crucial relative position
 the node in the SPQR-tree determining it, denoted by
.  Moreover, for every virtual edge  in
 we compute a list  of relative positions.
A relative position  is contained in  if and
only if it is crucial, determined by  and  is contracted in
.  Similarly, the list  for an R-node~
contains the crucial relative position  if and only if 
and  are both cycles in , implying that 
is determined by .  Finally, in the fourth pase, we compute the
PR-node constraints restricted to the crucial relative positions.  The
next lemma states that the first phase can be implemented in linear
time.

\begin{table}
  \heavyrulewidth=1pt
  \centering
  \begin{tabular}{lp{0.8\linewidth}}
    \toprule
    {\bf Data} & {\bf Description}  \\
    \midrule
     & For a node  in the SPQR-tree the list of cycles
    in  that are cycles in .  \\
    \midrule
     & For a virtual edge  in  either a
    cycle  if  induces a cycle in 
    containing  or  denoting that  is not contained
    in such a cycle.  \\
    \midrule
     & The root for the induced tree
     with respect to a chosen root for the
    SPQR-tree .  \\
    \midrule
      &  For a node  in the SPQR-tree 
    the highest edge in  on the path from  to the
    root that is reachable without using an edge in any of the induced
    subtrees~.  \\
    \midrule
     & The node in the SPQR-tree determining the
    relative position  of the cycle  with respect to
    another cycle .  \\
    \midrule
     & For a virtual edge  in  a list
    of relative positions containing  if and only if it is
    crucial, determined by  and  is contracted in .  \\
    \midrule
     & For every R-node  a list of crucial relative
    positions containing  if and only if  and  are
    cycles in . \\
    \bottomrule
\end{tabular}
\caption{Data that is computed to compute the PR-node constraints
  restricted to the crucial relative positions.}
\label{tab:data}
\end{table}



\begin{lemma}
  \label{lem:induced-trees-comp-data}
  Let  be a biconnected planar graph with SPQR-tree~
  containing the disjoint cycles~.  The data 
  for every node ,  for every virtual edge ,
  and  for every cycle~ can be
  computed in overall linear time.
\end{lemma}
\begin{proof}
  We process the SPQR-tree  bottom-up, starting with the
  Q-nodes.  If a Q-node  corresponds to an edge belonging to a
  cycle , then  contains only  and 
  for the virtual edge in .  If the edge corresponding to 
  is not contained in a cycle, then  is empty and
  .  Furthermore, a Q-node cannot be the root of
  any induced subtree  as we chose as the root
  of  a Q-node corresponding to an edge not contained in
  any of the cycles.  Now consider an inner node .  We first
  process the virtual edges in  not belonging to the
  parent of .  Let  be such a virtual edge corresponding to
  the child  of  and let  be the virtual edge in
   corresponding to its parent .  Then 
  belongs to a cycle induced by  if and only if~ does, thus
  we set .  Moreover, if  we need to add the cycle  to  if it was
  not already added.  Whether  is already contained in
   can be tested in constant time as follows.  We define a
  timestamp , increase  every time we go to the next node in
   and we store the current value of  for a cycle added
  to .  Then a cycle  was already added to 
  if and only if the timestamp stored for  is equal to the current
  timestamp .  Thus, processing all virtual edges in 
  not corresponding to the parent of  takes time linear in the
  size of .  Let now  be the virtual edge
  corresponding to the parent of .  If  for
  all virtual edges  incident to , then  cannot be
  contained in a cycle induced by any of the cycles in .
  Otherwise, there are two possibilities.  There is a cycle  such that  for exactly one virtual
  edge  incident to  or there are two such edges 
  and  with .  In the former
  case the edges belonging to  in  form a path from 
  to , thus the edge  corresponding to the parent also
  belongs to  and we set .  In the latter case 
  is contained in the cycle  but the virtual edge does not belong
  to  and we set .  This takes time linear in
  the degree of  in  and hence lies in .  It remains to set  for every cycle  inducing the subtree 
  having  as root.  The tree  has  as
  root if and only if  is contained as cycle  in  but
  the virtual edge  in  corresponding to the parent
  of  is not contained in .  Thus we have to set
   for all cycles  in 
  except for .  Note that this again consumes time linear
  in the size of  since the number of cycles that are
  cycles in  is in .  Due to the fact
  that the SPQR-tree  has linear size this yields an
  overall linear running time.
\end{proof}

In the second phase we want to compute  for each of the
nodes in .  We obtain the following lemma.

\begin{lemma}
  \label{lem:computing-high}
  Let  be a biconnected planar graph with SPQR-tree~
  containing the disjoint cycles~.  For every node 
  in  the edge  can be computed in linear
  time.
\end{lemma}
\begin{proof}
  We make use of the fact that  is already computed for
  every virtual edge  in each of the skeletons, which can be
  done in linear time due to Lemma~\ref{lem:induced-trees-comp-data}.
  Note that an edge  in the SPQR-tree 
  (where  is the parent of ) belongs to the induced subtree
   with respect to the cycle 
  if and only if  for the virtual edge  in
   corresponding to the child .  In this case we
  also have  where  is the
  virtual edge in  corresponding to the parent.  Hence,
  we can compute  for every node  in~ by
  processing~ top-down remembering the latest processed
  edge not belonging to any of the induced subtrees.  This can easily
  be done in linear time.
\end{proof}

In the third phase we compute  for every crucial
relative position in linear time.  Moreover, we compute 
for every virtual edge  and  for every R-node
.  We show the following lemma.

\begin{lemma}
  \label{lem:compute-det-and-contr}
  Let  be a biconnected planar graph with SPQR-tree 
  containing the disjoint cycles .  The node
   for each crucial relative position ,
  the list  for each virtual edges  and the list
   for each R-nodes  can be computed in overall
  linear time.
\end{lemma}
\begin{proof}
  Let  and  be two cycles such that  is a crucial
  relative position.  We show how to compute the node
   determining this relative position in constant
  time.  Moreover, if  is contracted in a virtual edge  in
  , we append the relative position  to
  .  Otherwise,  is an R-node
  containing  and  as cycles and we add  to
  .  Since there are only linearly many
  crucial relative positions this takes only linear time.  Let  and 
  be the roots of the induced trees with respect to  and~,
  respectively, which are already computed due to
  Lemma~\ref{lem:induced-trees-comp-data}.  We use that the lowest
  common ancestor of a pair of nodes can be computed in constant time
  after a linear-time preprocessing~\cite{ht-fafnca-84, bf-lcapr-00}.
  In particular, let  be the lowest common ancestor
  of the two roots.  There are three possibilities.  First,  is above  (Figure~\ref{fig:compute-det-cases}(a)).
  Second, 
  (Figure~\ref{fig:compute-det-cases}(b)).  And third,  lies above 
  (Figure~\ref{fig:compute-det-cases}(c--f)).  Note that the first
  case includes the situation where  lies
  above .

  In the first case the cycle  is contracted in  in the
  virtual edge  corresponding to the parent of , while
   contains  as cycle  not containing the virtual edge
   corresponding to the parent.  Hence,  determines
  .  We set  and insert
   into .  In the second case  and 
  are both cycles in , hence  determines
  .  We set  and insert
   into  since  contains  and
   as cycles.

  \begin{figure}
    \centering
    \includegraphics{fig/compute-det-const-time}
    \caption{The cases that occur in the proof of
      Lemma~\ref{lem:compute-det-and-contr}.}
    \label{fig:compute-det-cases}
  \end{figure}

  In the third case the node determining  lies somewhere
  on the path from  down to~.  In this situation
   comes into play and we distinguish several cases.  We
  first assume that .  Let  be the highest edge in  on the path from
   to the root that is reachable without using an edge in any of
  the induced trees, as computed by Lemma~\ref{lem:computing-high}.
  Let  be the parent of .  We claim that either  or
   determines the crucial relative position
  . 

  More precisely, if  lies above or is equal to 
  (Figure~\ref{fig:compute-det-cases}(c)), then the child  of
   on the path from  to  does not contain  as a
  cycle.  Otherwise the edge  would have been
  contained in , which is a contradiction to the
  definition of .  Thus,  is contracted in the
  virtual edge  in  corresponding to the child
   that is not contained in the cycle induced by , implying
  that  determines .  In this case we set
  .  Moreover, we want to insert the crucial
  relative position  into .  Unfortunately,
  we cannot determine the virtual edge  belonging to the child
   in constant time.  We handle that problem by storing a
  temporary list  for the node  and insert
   into this list.  After we have processed all crucial
  relative positions, we process  bottom-up, building a
  union-find data structure by taking the union of  with all its
  children after processing .  Thus, when processing~, we
  can simply traverse the list  once, find for every
  crucial relative position  the virtual edge 
  containing  by finding  in the
  union-find data structure and then add  to
  .  Note that this takes overall linear time, because
  the union-find data structure consumes amortized constant time per
  operation since the union-operations we apply are known in
  advance~\cite{gt-ltascdsu-85}.

  In the second case~ lies below , where .  We claim that  contains~ as a cycle and
   contracted in the virtual edge  in 
  corresponding to the child~, as depicted in
  Figure~\ref{fig:compute-det-cases}(d).  By definition of
   there is a cycle  that is contained as a cycle
  in~ and in the parent of~ but not in .  We show
  that  or  is not a crucial relative position.
  Assume ; see Figure~\ref{fig:compute-det-cases}(e).  In
   the cycle  is contracted in the virtual
  edge~ corresponding to the child~, whereas  is
  contracted in the virtual edge  corresponding to the parent of
  .  Since~ is a cycle in  and in its parent, it
  induces a cycle in  containing~.  Consider a
  path~ from~ to  in the graph .  Then  contains
  one of the poles of  and hence contains a vertex
  in~.  Thus the relative position  is not crucial,
  which is a contradiction.  Hence we can simply set  and append  to the list .

  Finally,  may be not defined, that is  since the edge connecting  to its parent is already
  contained in one of the induced cycle trees.  With a similar
  argument as before, this induced tree is ,
  belonging to the cycle , as depicted in
  Figure~\ref{fig:compute-det-cases}(f).  Thus  contains  and
   as cycles and we set  and add
   to the list . This concludes the proof.
\end{proof}

In the fourth and last phase we process the SPQR-tree 
once more to finally compute the PR-node constraints restricted to the
crucial relative positions.  We obtain the following lemma.

\begin{lemma}
  \label{lem:computing-pr-node-constr}
  Let  be a biconnected planar graph.  The PR-node constraints
  restricted to the crucial relative positions can be computed in
  linear time.
\end{lemma}
\begin{proof}
  We process each node in the SPQR-tree  of  once,
  consuming time linear in the size of its skeleton plus some
  additional costs that sum up to the number of crucial relative
  positions in total.  Let  be a node in .  If 
  is not contained in any induced tree , it does
  not determine any relative position at all.  Thus assume there is at
  least one cycle that is a cycle in .  If  is a P-node,
   consists of  parallel virtual edges  and we can assume without loss of generality that
  the cycle  induces in  the cycle  consisting
  of the two virtual edges  and~.  For every crucial
  relative position  that is determined by  there
  is a virtual edge  containing
   in the list , which is already computed due to
  Lemma~\ref{lem:compute-det-and-contr}.  Hence, the PR-node
  constraints stemming from  can be computed by processing each
  of these lists , setting  for any two cycles  and  appearing
  consecutively in .  The time-consumption is linear in
  the size of  plus the number of crucial relative
  positions determined by .

  If  is an R-node, it may contain several cycles as a cycle, all
  of them stored in the list  due to
  Lemma~\ref{lem:induced-trees-comp-data}.  Every crucial relative
  position  determined by  is either contained in the
  lists  for a virtual edge  in  or in
   if  and  are both cycles in 
  (Lemma~\ref{lem:compute-det-and-contr}).  We first carry the
  relative positions in  over to the corresponding
  cycles.  More precisely, we define a list  for every
  cycle~ in  and insert a crucial relative position
   into it, if it is contained in .  This
  can obviously be done consuming time linear in the size of
  .  Afterwards, we start by fixing the embedding of
   and pick an arbitrary vertex  in .
  For each cycle  contained as cycle  in  we
  define a variable  and initialize it with the value
  ``left'' or ``right'', depending on which side  lies \todo{Pag
    20, line 18:}with respect to  in the chosen embedding of
  , or with the value ``on'' if  is contained in~.
  Due to Lemma~\ref{lem:induced-trees-comp-data} we know for every
  edge  to which cycle it belongs (or that it does not belong to
  a cycle at all).  Thus  can be easily computed for every
  cycle  that is a cycle in  consuming time linear in
   by traversing  once, starting at .

  To sum up, each crucial relative position  determined by
   is either contained in  if  is contracted in
   or in  if  is a cycle in .
  Moreover, for each cycle~ the value of  describes on
  which side of  the chosen start-vertex  lies with respect to
  a chosen orientation of .  We now want to divide the
  crucial relative positions determined by~ into two lists {\sc
    Left} and {\sc Right} depending on which value they have with
  respect to the chosen embedding.  If this is done, the PR-node
  constraints stemming from  restricted to the crucial relative
  positions can be computed by simply processing these two lists once.
  To construct the lists {\sc Left} and {\sc Right}, we make a
  DFS-traversal in  such that each virtual edge is
  processed once.  More precisely, when we visit an edge 
  (starting at ), then  is either an unvisited vertex and we
  continue the traversal from  or  was already visited, then we
  go back to .  If all virtual edges incident to the current vertex
   were already visited, we do a back-tracking step, i.e., we go
  back to the vertex from which we moved to .  Essentially, a
  normal step consists of three phases, leaving the current vertex
  , traveling along the virtual edge , and finally
  arriving at  or back at .  In a back-tracking step we have
  only two phases, namely leaving the current vertex~ and arriving
  at its predecessor.  During the whole traversal we keep track of the
  sides .  More precisely, when leaving a vertex 
  that was contained in a cycle  we may have to update 
  if the target-vertex  is not also contained in .  On the other
  hand, when arriving at a vertex  contained in a cycle  we have
  to set .  Since such an update has to be
  done for at most one cycle we can keep track of the sides in
  constant time per operation and thus in overall linear time.  Now it
  is easy to compute the values of the crucial relative positions
  determined by  with respect to the currently chosen embedding.
  While traveling along a virtual edge  we process
  .  For a crucial relative position 
  contained in  we know that  is contracted in
  .  Thus, in the chosen embedding the value of  is
  the current value of  and we can insert  into
  the list {\sc Left} or {\sc Right} depending on the value of
  .  This takes linear time in the number of crucial
  relative positions contained in .  We deal with the
  crucial relative positions contained in one of the lists
   in a similar way.  Every time we reach a vertex 
  contained in a cycle  we check whether this is the first time we
  visit the cycle .  If it is the first time, we insert every
  crucial relative positions  contained in 
  into one of the lists {\sc Left} or {\sc Right}, depending on the
  current value of .  Clearly the whole traversal takes
  linear time in the size of  plus linear time in the
  number of crucial relative positions determined by .  Moreover,
  we obviously obtain the PR-node constraints restricted to the
  crucial relative positions stemming form  by processing each of
  the lists {\sc Left} and {\sc Right} once, obtaining an equality
  constraint for positions that are adjacent in the lists and
  additionally a single inequality for a pair of positions, one
  contained in {\sc Left} and the other in {\sc Right}, unless one of
  them is empty.
\end{proof}

\begin{corollary}
  The CC-tree  of a biconnected planar graph  can be
  computed in linear time.
\end{corollary}

It remains to extend the described algorithm to the case where  is
not necessarily biconnected.  More precisely, we need to show how to
compute the extended PR-node constraints and the cutvertex constraints
in linear time.  This is done in the proof of the following theorem.

\begin{theorem}
  \label{thm:compute-cc-trees-lin-time}
  The CC-tree  of a connected planar graph  can be
  computed in linear time.
\end{theorem}
\begin{proof}
  As before, the underlying C-tree can be easily computed in linear
  time.  For a fixed block  we have the SPQR-tree  and
  for a cycle  in  the induced tree  can
  be defined as before.  Obviously,
  Lemma~\ref{lem:induced-trees-comp-data} can be used as before to
  compute  for every node ,  for every
  virtual edge and  for every induced
  subtree in linear time.  Moreover, the edge  in
   can be computed for every node  as in
  Lemma~\ref{lem:computing-high}.  For the computation of
   for every crucial relative position 
  and  for every virtual edge , we cannot directly
  apply Lemma~\ref{lem:compute-det-and-contr} since the cycles  and
   may be contained in different blocks.  Thus, before we can
  compute , we need to find out whether  and 
  are in the same block, which can be done by simply storing for every
  cycle a pointer to the block containing it.  For the case that~
  and  are contained in the same block  can be
  computed as before and  can be inserted into the list
   for some  if necessary.  For the case that 
  and~ are contained in different blocks  and , we need to
  find the unique cutvertex  in  that separates  and .
  This can be done in overall linear time by computing the BC-tree and
  using an approach combining the lowest common ancestor and
  union-find data structure similar as in the proof of
  Lemma~\ref{lem:compute-det-and-contr}.  

  If the resulting cutvertex  is not contained in , we can treat
  the cutvertex~ as if it was the cycle  and use the same
  algorithm as in Lemma~\ref{lem:compute-det-and-contr} to compute
   and append  to  for
  some  if necessary.  If  is contained in , then the
  crucial relative position  is not determined by any node
  in any SPQR-tree at all, but by the embedding of the blocks around
  the cutvertex .  Thus there are no extended PR-node constraints
  restricting .  Finally,  can be
  computed in overall linear time for every crucial relative position
   that is determined by a node in the SPQR-tree of the
  block containing~.  Moreover, for a node  in the SPQR-tree
  of the block  containing  every virtual edge  has a list
   containing all crucial relative positions
   that are determined by~ and for which either 
  is contracted in  or belongs to a different block  and is
  connected to~ via a cutvertex contained in the expansion graph
  .  With these information the extended PR-node
  constraints can be computed exactly the same as the PR-node
  constraints are computed in
  Lemma~\ref{lem:computing-pr-node-constr}.

  It remains to compute the cutvertex constraints restricted to the
  crucial relative positions.  As mentioned above, we can compute a
  list of crucial relative positions  determined by the embedding of the blocks around a
  cutvertex  contained in  in linear time.  We then process this
  list once, starting with .  We store  as
  reference position for the block~ containing .  Now, when
  processing , we check whether the block~
  containing~ already has a reference position 
  assigned to it.  In this case we set ,
  otherwise we set  to be the reference position.  This
  obviously consumes overall linear time and computes the cutvertex
  constraints restricted to the crucial relative positions.
\end{proof}



\subsubsection*{Intersecting CC-Trees in Linear Time}
\label{sec:inters-cc-trees-lin-time}

Due to Theorem~\ref{thm:intersection-is-intersection} we can test
whether two graphs  and  with common graph  consisting of
a set of disjoint cycles have a {\sc SEFE} by computing the
CC-trees  and  of  and ,
respectively, which can be done in linear time due to
Theorem~\ref{thm:compute-cc-trees-lin-time}.  Then the intersection
 of  and  represents
exactly the possible embeddings of the common graph  in a {\sc
  SEFE}.  It remains to show that the intersection can be computed in
linear time.

\begin{theorem}
  \label{thm:intersection-in-lin-time}
  The intersection of two CC-trees can be computed in linear time.
\end{theorem}
\begin{proof}
  Let  and 
  be two CC-trees on a set~ of cycles.  We start with
   and show how
  to compute the common-face and crucial-position constraints in
  overall linear time.  For the crucial-position constraints we
  essentially only show how to find for each crucial relative position
  in  a crucial relative position in
   corresponding to it.  Computing the
  crucial-position constraints is then easy.  We root  at an arbitrary vertex and again use that the lowest
  common ancestor of two vertices in~ can be
  computed in constant time~\cite{ht-fafnca-84, bf-lcapr-00}.  For
  every edge  in  we
  obtain a path in  from  to the lowest
  common ancestor of  and  and further to .  We
  essentially process these two parts of the path separately with some
  additional computation for the lowest common ancestor.  We say that
  the parts of the paths \emph{belong} to the \emph{half-edges}
   and , respectively.  We use the following
  data structure.  For every cycle  there is a list 
  containing all edges in~ whose
  endpoints have  in  as lowest common
  ancestor.  This list can be computed for every cycle in overall
  linear time.  We then process  bottom up,
  saving for the cycle  we currently process a second list
   containing all the half-edges in  whose paths contain .  This can be done in overall
  linear time by ensuring that every half-edge  ()
  is contained in at most one list  at the same time.  Then
   can be removed from this list in constant time by storing
  for~ pointers to the previous and to the next element in
  that list, denoted by  and .
  Additionally, we build up the following union-find data structure.
  Every time we have processed a cycle , we union  with all its
  children in .  Thus, when processing~,
  this data structure can be used to find for every cycle in the
  subtree below  the child of  it belongs to.  Note that again
  this version of the union-find data structure consumes amortized
  constant time per operation since the sequence of union operations
  is known in advance~\cite{gt-ltascdsu-85}.  Before starting to
  process , we process~ once and for every edge~ we
  insert the half-edges~ and~ to the lists
   and , respectively.  While
  processing~ bottom up the following
  invariants hold at the moment we start to process .
  \begin{compactenum}
  \item The list  contains all half-edges starting at .
  \item For every child  of  the list  contains the
    half-edge  if and only if the path belonging to it
    contains  and .
  \item Every half-edge  is contained in at most one list
    , and  and  contain the
    previous and next element in that list, respectively.
  \end{compactenum}
  When we start processing a leaf  the invariants are obviously
  true.  To satisfy invariant~2. for the parent of  we have to
  ensure that all half-edges ending at  are removed form the list
  .  Since there are no half-edges ending in a leaf, we
  simply do nothing.  Invariants~1. and~3. obviously also hold for the
  parent of .

  Let  be an arbitrary cycle and assume that the invariants are
  satisfied.  To ensure that invariant~2. holds for the parent of
  , we need to build a list of all half-edges whose paths
  contain~ and do not end at .  Since invariants~1. and~2. hold
  for  this are exactly the half-edges contained in  plus
  the half-edges contained in  for each of the children
   of  that are not ending at .  Note that a half-edge may
  also start at  and end at .  This is the case if the
  corresponding edge connects  with another cycle  such that
  the lowest common ancestor of~ and  is .  We first
  process the list  containing the edges ending at ; let
   be an edge in .  The two half-edges  and
   belonging to  are contained in the lists 
  and , where  and  are different cycles and
  each of them is either  or a child of .  We remove 
  form  for~.  This can be done by setting the
  pointers  and
  , taking constant time per
  edge since each half-edge is contained in at most one list due to
  invariant~3.  Afterwards, for every child  of , we append
   to  and empty the list  afterwards,
  to ensure that invariant~3 remains satisfied.  This takes constant
  time per child and thus overall time linear in the degree of .
  Obviously this satisfies all invariants for the parent of .
  Furthermore, we consume time linear in the degree of~ plus time
  linear in the number of half-edges ending at .  However, every
  half-edge ends exactly once yielding overall linear time.

  Now it is easy to compute the common-face and crucial-position
  constraints while processing~ as described
  above.  Essentially, when processing , we compute all the
  constraints concerning the relative position of other cycles with
  respect to .  In particular, we need to add common-face
  constraints if two half-edges end at  and if the path belonging
  to a half-edge contains  in its interior.  Furthermore, we find a
  corresponding crucial relative position for every half-edge starting
  at .  \todo{Pag 23, lines 21-24:}Let  be an
  edge whose half-edges end at .  There are two different cases.
  First, one of the cycles  (for ) is  (its half
  edge starts and ends at ).  Then the other cycle (whose half-edge
  only ends at ) is contained in a subtree with root , where
   is a child of .  Second,  and  are contained in
  the subtrees with roots  and , respectively, where
   and  are different children of .  In this case, both
  half-edges end at .  We consider the second case first.  Then
   and  can be found in amortized constant time by finding
   and  in the union-find data structure.  The equation
   is exactly the common-face constraint
  at the cycle  stemming from the edge .  In the second case
  we can again find the child  in constant time.  Assume without
  loss of generality that  and  is contained in the
  subtree having  as root.  Then  is the crucial
  relative position in  corresponding to the
  crucial relative position  in .  The half-edges containing  in its interior
  are exactly the half-edges contained in one of the lists 
  for a child  of  whose path does not end at .  Thus, for
  the parent  of  we have to add the common-face constraint
   if and only if the list  is
  not empty after deleting all half-edges in .  These
  additional computations obviously do not increase the running time
  and hence the common-face and crucial-position constraints can be
  computed in overall linear running time.
\end{proof}

Theorems~\ref{thm:cycle-tree-is-rep},~\ref{thm:intersection-is-intersection},~\ref{thm:compute-cc-trees-lin-time}
and~\ref{thm:intersection-in-lin-time} directly yield the following results.

\begin{theorem}
  {\sc Simultaneous Embedding with Fixed Edges} can be solved in
  linear time if the common graph consists of disjoint cycles.
\end{theorem}

\begin{theorem}
  {\sc SEFE} can be solved in linear time for the case of  graphs
   all intersecting in the same common graph 
  consisting of disjoint cycles.
\end{theorem}

\section{Connected Components with Fixed Embedding}
\label{sec:extension}

In this section we show how the previous results can be extended to
the case that the common graph has several connected components, each
of them with a fixed planar embedding.  Again, we first consider the
case of a single graph  containing  as a subgraph,
where in this case  is a set of connected components
instead of a set of disjoint cycles.  First note that the relative
position  of a component  with respect to another
component  can be an arbitrary face of .  Thus, the choice of
the relative positions is no longer binary and a set of inequalities
on the relative positions would lead to a coloring problem in the
conflict graph, which is -hard in general.  However,
most of the constraints between relative positions are equations, in
fact, all inequalities stem from R-nodes in the SPQR-tree of  (or
of the SPQR-tree of one of the blocks in~).  Fortunately, if a
relative position is determined by an R-node, there are only two
possibilities to embed this R-node.  Thus, the possible values for
the relative position is restricted to two faces, yielding a binary
decision.  Note that in general the possible values for 
are not all faces of~, even if  is not determined by an
R-node but by a P-node or by the embedding around a cutvertex.

Thus, we obtain for each relative position a set of possible faces as
values and additionally several equations and inequalities, where
inequalities only occur between relative positions with a binary
choice.  These conditions can be modeled as a conflict graph where
each node represents a relative position with some allowed colors
(faces) and edges in this conflict graph enforce both endvertices to
be either colored the same or differently.  In the case of the problem
{\sc SEFE} each of the graphs yields such a conflict graph.  These
conflict graphs can be easily merged by intersecting for each relative
position the sets of allowed colors (faces).  Then a simultaneous
embedding can be constructed by first iteratively contracting edges
requiring equality, intersecting the possible colors of the involved
nodes.  If the resulting graph contains a node with the empty set as
choice for the color, then no simultaneous embedding exists.
Otherwise, we have to test whether each connected component in the
remaining graph can be colored such that adjacent nodes have different
colors, which can be done efficiently since such a component either
consists of a single node or there are only up to two possible colors
for each connected component left due to the considerations above.

Moreover, the CC-tree can be adapted to work for the case of connected
components with fixed embeddings instead of disjoint cycles, as the
extended PR-node and cutvertex constraints on the crucial relative
positions are still sufficient to imply them on all relative
positions.  We call this tree on connected components the
CC-tree, standing for \emph{constrained component-tree}.  In
the following we quickly go through the steps we did before in the
case of disjoint cycles and describe the changes when considering
connected components instead.

\paragraph{PR-Node Constraints.}
\label{sec:pr-node-constraints}

Let  be a biconnected planar graph and let  be a
subgraph of  consisting of several connected components, each with
a fixed planar embedding.  Let further  be one of
the connected components and let  be a node in the SPQR-tree
 of .  The virtual edges in  whose
expansion graphs contain parts of the component  induce a connected
subgraph in .  In the previous case, where the subgraph
consisted of disjoint cycles, this induced subgraph was either a
single edge or a cycle.  In the case that  is an arbitrary
component the induced graph can be an arbitrary connected subgraph of
.  If it is a single edge, we say that  is
\emph{contracted} in , otherwise  is a \emph{component} in
.

We obviously obtain that the relative position  of another
component  with respect to  is determined by the embedding of
 if and only if  is a component in  and  is
not contracted in one of the virtual edges belonging to the subgraph
induced by .  Moreover, the embedding of  is partially
(or completely) fixed by the embedding of  if the induced graph in
 contains a vertex with degree greater than~2.  More
precisely, consider  to be a P-node containing  as a
component.  Then the virtual edges belonging to  have a fixed
planar embedding and each face in this induced graph represents a face
in .  These faces are the possible values for the relative
positions with respect to  that are determined by .  The
remaining virtual edges not belonging to  can be added arbitrarily
and thus components contracted in these edges can be put into one of
the possible faces with the restriction that two components contracted
in the same virtual edge have to lie in the same face, that is they
have the same relative position with respect to .  To sum up, we
obtain a set of possible faces of  with respect to  and a set
of equations between relative positions of components with respect to
.

For the case that  is an R-node, either the embedding of
 is fixed due to the fact that there exists a component
whose induced graph in  contains a vertex with degree
greater than~2.  Otherwise, each component is either contracted in
 or the induced subgraph is a cycle or a path.  No matter which
case arises, the relative positions determined by  are either
completely fixed or there are only two possibilities.  If the
embedding is fixed, the relative positions determined by  are
fixed and thus there is no need for additional constraints.
Otherwise, a crucial relative position with respect to  is fixed if
 induces a path in  and it changes by flipping
 if  induces a cycle.  For two components  and 
both inducing a cycle in  this yields a bijection between
the two possible values for relative positions with respect to 
determined by  and the two possible values for positions with
respect to .  Thus we can add the equations and inequalities as in
the case of disjoint cycles.

The resulting constraints are again called PR-node constraints.  As
for disjoint cycles we obtain that an embedding of the components
 respecting the fixed embeddings for each component can be
induced by an embedding chosen for  if and only if the PR-node
constraints are satisfied.  This directly yields a polynomial-time
algorithm to solve {\sc SEFE} for the case that both graphs are
biconnected and the common graph consists of several connected
components, each having a fixed planar embedding.

\paragraph{Extended PR-Node and Cutvertex Constraints.}
\label{sec:extended-pr-node}

As for cycles the considerations above can be easily extended to the
case that the graph  containing the components  is
allowed to contain cutvertices.  For a cutvertex  not contained in
a component , the relative position of  with respect to 
determines the relative positions of components attached via ,
which again yields the extended PR-node constraints.  If  is
contained in , then the relative position of another component 
with respect to  is determined by the embedding around  if and
only if  splits  from .  In this case  can obviously lie
in one of the faces of  incident to .  Fortunately, the
cutvertex constraints do not contain inequalities as they only ensure
that components attached to  via the same block lie in the same
face of .  With these considerations all results form
Section~\ref{sec:disj-cycl-poly-time} can be extended to the case of
components with fixed embedding instead of cycles.  In particular,
{\sc SEFE} can be solved in polynomial time if the common graph
consists of connected components, each with a fixed planar embedding.

\paragraph{CC-Trees.}
\label{sec:cc-trees-ext}

As mentioned before, the CC-tree can be adapted to represent all
embeddings that can be induced on the set of components 
by an embedding of the graph , yielding the CC-tree.  To
this end, each node in the tree represents a component  and the incidence to  of an edge  in the
CC-tree represents the choice for the crucial relative
position .  The possible values are restricted to a subset
of faces of  as described before and there may be some equations
between crucial relative positions with respect to .  Moreover,
there may be inequalities between crucial relative positions even with
respect to different components.  However, if this is the case, then
there are at most two possible choices and we have a bijection between
the possible faces of different components.  As in the proof of
Theorem~\ref{thm:cycle-tree-is-rep}, it follows from the structure of
the underlying C-tree, that relative positions that are not crucial
are determined by a crucial relative position that is determined by
the same P- or R-node or by the same embedding choice around a
cutvertex.  The proof can be easily adapted to the case of components
instead of cycles yielding that satisfying the constraints and
restrictions to a subset of faces for the crucial relative positions
automatically satisfies these conditions for all relative positions.

To be able to solve {\sc SEFE} with the help of CC-trees, we need to
intersect two CC-trees such that the result is again a CC-tree.
Assume as in the case of cycles that we have the two
CC-trees~ and~.  As before we
start with  and add the restrictions given by
.  More precisely, for every pair  of
adjacent nodes in  we have to add the common-face
constraints to , that is equations between crucial
relative positions on the path between  and  in  enforcing~ and~ to share a face.  Moreover, for every
relative position  that is crucial with respect to
 we have to add the equations and inequalities it is
involved in to the CC-tree .  As for cycles
 is in  determined by the crucial
relative position , where  is the first node on the
path from  to .  We have to do two things.  First, we have to
restrict the possible choices for  to those that are
possible for , which can easily be done by intersecting
the two sets.  Second, the equations and inequalities  is
involved in have to be carried over to .  This can be
done as before by choosing for each crucial relative position in
 the representative in .  For the
resulting intersection  it remains to show that every
embedding represented by it is also represented by 
and .  The former is clear, the latter can be shown
as in the proof of Theorem~\ref{thm:intersection-is-intersection}.

\paragraph{Efficient Implementation.}

Unfortunately, the constrained component-tree may have quadratic size
in contrast to the constrained cycle-tree, which has linear size.
This comes from the fact that a node  in the CC-tree may
have linearly many neighbors.  Moreover, each relative position
 of a neighbor  of  may have linearly many possible
values, as  may have that many faces.  As these possible values
need to be stored for the edge  in the CC-tree it has
quadratic size.  On the other hand, it is easy to see that the CC-tree
can be computed in quadratic time.  Moreover, the proof of
Theorem~\ref{thm:intersection-in-lin-time} providing a linear-time
algorithm to intersect CC-trees can be adapted almost
literally.  The only thing that changes is that additionally the
possible values for  and  need to be
intersected, where  is a relative position that is crucial
with respect to  and  is the
representative in .  Thus, two
CC-trees can be intersected consuming time linear in the size
of the CC-trees, that is quadratic time in the size of the
input graphs.  We finally obtain the following theorem.

\begin{theorem}
  {\sc Simultaneous Embedding with Fixed Edges} can be solved in
  quadratic time, if the embedding of each connected component of the
  common graph is fixed.
\end{theorem}

Let  be the CC-tree representing all
embeddings of the components  that can be induced by the
graph .  It is worth noting that, although the explicit
representation of  may have quadratic size,
it also admits a compact representation of linear size.  The key idea
is the following.  In case there are more than two possible values for
a crucial relative position , this position is determined
by a P-node or a cutvertex.  Then we can encode the possible values
for  by pointing to a list that is stored at that P-node
or cutvertex, respectively.  Since this set of values is independent
of  it is sufficient to store one list for each P-node or
cutvertex.  It is not hard to see that the total size of these lists
is linear.  Moreover, the fast algorithm for computing CC-trees can be
applied with obvious modifications to compute this compact
representation in linear time.  It is, however, unclear whether the
intersection of two or more CC-trees still admits a compact
representation and whether it can be computed in linear time from the
given compact representations.
 

\section{Conclusion}
\label{sec:conclusion}

Contrary to the previous results on simultaneous embeddings we focused
on the case where the embedding choice does not consist of ordering
edges around vertices but of placing connected components in relative
positions to one another.  We first showed that generally both input
graphs of an instance of {\sc Simultaneous Embedding with Fixed Edges}
can be always assumed to be connected.  We then showed how to solve
{\sc Simultaneous Embedding with Fixed Edges} in linear time for the
case that the common graph consists of simple disjoint cycles (or more
generally has maximum degree~2).  We further extended the result to a
quadratic-time algorithm solving the more general case where the
embedding of each connected component of the common graph is fixed.
These solutions include a compact and easy to handle data structure,
the CC-tree and CC-tree, representing all possible
simultaneous embeddings.  Thus, there is hope that the CC-tree and the
CC-tree are also useful when relaxing the restriction of a
fixed embedding for each component.

\ifdefined\elsevier
\bibliographystyle{elsarticle-num}
\fi
\ifdefined\arXiv
\bibliographystyle{plain}
\fi
\bibliography{DisjCycles}

\end{document}
