\documentclass[runningheads,a4paper]{llncs}

\def\todoFlag{OFF} \def\longFlag{OFF} \def\nuevoFlag{OFF} \def\borradoFlag{OFF} 




\usepackage{amsmath}







\usepackage{proof}
\usepackage{amsfonts}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{alltt}
\usepackage{stmaryrd}


\usepackage{color}


\newtheorem{counterexample}{Counterexample}


\usepackage{ifthen} 


\newcommand{\nc}{\newcommand}
\nc{\coment}[1]{}

\nc{\bcen}{\begin{center}}
\nc{\ecen}{\end{center}}

\nc{\tp}[1]{\overline{#1}}
\def\hh#1{\hspace*{0.#1cm}}
\def\v#1{\vspace*{#1cm}}
\def\vv#1{\vspace*{0.#1cm}}


\nc{\ra}{\rightarrow}
\nc{\crwlto}{\rightarrowtriangle}  \nc{\f}{\rightarrow_{\tiny l}}    \nc{\fcrwl}{\rightarrow_{\it CRWL}}    \nc{\fc}{\rightarrow_{\it CRWL}}
\nc{\nlet}{\leadsto}        \nc{\cont}{\hat}
\newcommand{\egcl}{e}

\nc{\gl}{\vdash_{\it CRWL_{\it let}}}
\nc{\bl}{{\cal P} \vdash_{\it BRC_{\it let}}}
\nc{\cl}{{\cal P} \vdash_{\it CRWL}}
\nc{\cld}{{\cal P} \vdash_{\it CRWL'}}
\nc{\fnt}{\rightarrow_{\it let_{nt}}}    \nc{\fnr}{\leadsto^l}  \nc{\fnre}{\leadsto^{l^*}}  \nc{\fnrc}[1]{\leadsto^{l^{#1}}}  \nc{\jn}{\Join} \nc{\tr}{\underline{\mbox{\textbf{t}}}}
\nc{\h}{\rightarrow_{\tiny h}}    \nc{\dgl}[1]{\den{#1}_{\it GORC_{let}}}
\nc{\ddgl}[1]{\denn{#1}_{\it GORC_{let}}}
\nc{\dg}[1]{\den{#1}_{\it CRWL}}
\nc{\dcl}[1]{\den{#1}_{\it CRWL_{\it let}}}
\nc{\ddcl}[1]{\denn{#1}_{\it CRWL_{\it let}}}
\nc{\tlr}[1]{\widehat{#1}} \nc{\rw}{\to} \nc{\trw}{\to^r} \nc{\tor}{\to} \nc{\clto}{\crwlto}                \nc{\dend}[1]{\den{#1}^d} \nc{\cldt}{{\cal P} \vdash_{\it CRWL^{d}}} \nc{\con}{{\cal C}}
\nc{\slt}{=} \nc{\shlt}{=} \nc{\crw}{{\rw^{ct}}}    \nc{\crwpr}{{\rw_{\cal P}^{{ct}^*}}}    \nc{\rrw}{{\,\rw^{rt}\,}} \nc{\rrwp}{{\,\rw^{rt'}\,}} \nc{\rrwpr}{{\rw_{\cal P}^{{rt}^*}}}    \nc{\Rrw}{{\rw^{Rt}}} \nc{\prog}{{\cal P}}
\nc{\crwllet}{{\it CRWL\ }}
\nc{\raux}{\rw} \nc{\ordap}{\sqsubseteq} 




\newcommand{\kk}{}
\newcommand{\ekk}{}

\newenvironment{dem}{\noindent {\bf Demostraci√≥n:}}{} 



\newcommand{\nat}{\mathrm{I\! N}}
\newcommand{\var}{\mathcal{V}}
\newcommand{\toye}{}
\newcommand{\toy}{}


\newcommand{\rec}{\triangleleft}
\newcommand{\fail}{\textsf{\scriptsize F}}
\newcommand{\cb}{\mathcal{C}}

\newcommand{\toto}{\twoheadrightarrow}
\newcommand{\den}[1]{[\![#1]\!]}
\newcommand{\denn}[1]{[\![\![#1]\!]\!]}
\newcommand{\s}{\mathcal{S}}

\newcommand{\conscrwl}{\vdash_{\textit{CRWL}}}
\newcommand{\conscrwllet}{\vdash_{\textit{CRWL}}}

\newcommand{\mifrac}[3]{
  \mbox{\tiny{#1}}
  \frac{\mbox{}}
      {\mbox{}}}



\newcommand{\de}[1]{\;
  \begin{array}{c}
    \-0.3cm]
    \textrm{\scriptsize{}}
  \end{array}\;}

\newcommand{\des}[1]{\;
  \begin{array}{c}
     _{*}\-0.3cm]
    \textrm{\scriptsize{}}
  \end{array}\;}
\newcommand{\dec}[1]{\;
  \begin{array}{c}
    \-0.3cm]
    \textrm{\scriptsize{}}
  \end{array}\;}


\newcommand{\decs}[1]{\;
  \begin{array}{c}
    _{*}\-0.3cm]
    \textrm{\scriptsize{}}
  \end{array}\;}
\newcommand{\decl}[1]{\;
  \begin{array}{c}
    _{l}\-0.3cm]
    \textrm{\scriptsize{}}
  \end{array}\;}

\newcommand{\dedem}[2]{\;
  \begin{array}{c}
    \-0.1cm]
    \textrm{\huge }\-0.2cm]
    \textrm{\huge }\-0.2cm]
    \textrm{\huge }\f(t_1,\ldots,t_n) \rw e
\begin{array}{lcll}
desugar(rt(X)) & = & X & \mbox{ if } X \in \var\\
desugar(rt(c(e_1, \ldots, e_n))) & = & c(desugar(rt(e_1)), \ldots, desugar(rt(e_n))) & \mbox{ if } c \in CS \\
desugar(rt(f(e_1, \ldots, e_n))) & = & f^{\rtm}(desugar(rt(e_1)), \ldots, desugar(rt(e_n))) & \mbox{ if } f \in FS \\
desugar(rt(rt(e))) & = & desugar(rt(e)) \\
\end{array}
0.15cm]
     \textbf{(OR)} &  & for any context , , and \end{tabular}
\end{center}
\end{minipage}
}
\caption{A one-step reduction relation for non-strict call-time choice with  annotations}\label{br}
\label{popeye}
\end{figure*}

The first characterization is shown in Fig. \ref{popeye}. Its drawback is that the rule \textbf{(B)} involves a `magical' guessing in advance of the fact
that the reduction of a (sub)-expression is not going to be
needed, and replaces this `no need of reduction in the future' by an artificial anticipated
reduction to the undefined value .
However, because of its simplicity, the relation is helpful to understand what are the possible results of a reduction.

The second characterization is the
rewrite relation of Fig. \ref{letrcalc}. It expresses in a more realistic manner (specially, if a reduction strategy would be added, which is not
our focus here) the way in which computations are to be performed. To express sharing (when needed), local bindings are created
via a \emph{let} construct.

\begin{figure*}[thb]
\framebox{
\begin{minipage}{0.98\textwidth}
\begin{center}
  \begin{description}
     \item[(Fapp)] , ~~~ if , \0.15cm]
     \item[(Bind)] , ~~~ if \0.15cm]
     \item [(Flat)] \\
 if  \
\begin{array}{ll}
coin \tor 0 ~~~~~& f(X) \tor g(X, coin)\\
coin \tor 1 ~~~~~& g(X,Y) \tor (X,X,Y,Y)
\end{array}

\begin{array}{l}
f^\rtm(coin^\rtm) \pop g(coin^\rtm, coin) \pop g(coin^\rtm, 0) \pop (coin^\rtm, coin^\rtm, 0, 0) \\
\pop (0, coin^\rtm, 0, 0) \pop (0, 1, 0, 0)
\end{array}

\begin{array}{l}
f^\rtm(coin^\rtm) \f g(coin^\rtm, coin) \f let~X=coin~in~g(coin^\rtm, X) \\
\f let~X=coin~in~(coin^\rtm, coin^\rtm, X, X) \f let~X=coin~in~(0, coin^\rtm, X, X) \\
\f let~X=coin~in~(0, 1, X, X) \f let~X=0~in~(0, 1, X, X) \\
\f (0, 1, 0, 0)
\end{array}

\infer[~~\mathbf{(\rrt)}]{\prog \vdash_{CRWL} \rrt(e) \clto t}
           {
            e \rw^*_{\cal P'} e'~
          \ ~t \ordap |e'|
           }

\begin{array}{lcll}
\rrtT{X} & = & X & \mbox{ if } X \in \var \\
\rrtT{c(e_1, \ldots, e_n)} & = & c(\rrtT{e_1}, \ldots, \rrtT{e_n}) & \mbox{ if } c \in CS \\
\rrtT{f(e_1, \ldots, e_n)} & = & {\rrtHat f}^{\rtm}(\rrtT{e_1}, \ldots, \rrtT{e_n}) & \mbox{ if } f \in FS \\
\rrtT{\rrtT{e}} & = & \rrtT{e}
\end{array}

\begin{array}{c}
\{coin \tor 0, coin \tor 1, f(X) \tor g(X, coin), g(X,Y) \tor (X,X,Y,Y)\}
\\
\uplus
\\
\{\rrtHat coin \tor 0, \rrtHat coin \tor 1, \rrtHat f(X) \tor {\rrtHat g}^{\rtm}(X, coin), \rrtHat g(X,Y) \tor (X,X,Y,Y)\}
\end{array}

\begin{array}{l}
\rrt(f(coin)) \equiv {\rrtHat f}^{\rtm}(\rrtHat coin^{\rtm}) \pop \rrtHat g^{\rtm}(\rrtHat coin^{\rtm}, \rrtHat coin^{\rtm}) \\
\pop (\rrtHat coin^{\rtm}, \rrtHat coin^{\rtm}, \rrtHat coin^{\rtm}, \rrtHat coin^{\rtm}) \pop^* (0,1,0,1)
\end{array}

\end{example}


\section{Implementation issues}\label{implementation}
In order to study the practicability of the proposal we have implemented it as an
extension of the functional logic system \emph{Toy} (\cite{toyreport}). This system, as well
as
other modern systems like \emph{Curry} (\cite{Han06curry}), operates under call-time
  choice. We
introduce the new syntactic construct {\it rt e} into the syntax of \emph{Toy} to instruct
the system to evaluate the expression {\it e} under a run-time choice
regime. The system will use run-time choice for evaluating the expressions annotated with
{\it rt}, and call-time choice as usual for the rest of computations, i.e., we
have within the same language both regimes of evaluation.

The extension is well supported by the system and requires only some light\-weight
modifications. In fact, the traditional problem is how to achieve sharing
in a non-deterministic language like this, and our goal now is to inhibit
this sharing mechanism at the points required by the programmer with {\it rt}.

\emph{Toy} is implemented in Prolog and uses Prolog as target code (see \cite{LLR93,toyreport} for
details). Sharing is implemented by means of {\it suspensions}, that are Prolog
terms of the form:
\begin{center}
  {\it susp(FunctionName,Arguments,Result,Evaluated)}
\end{center}
The {\it FunctionName} and its {\it Arguments} represent the expression  to
be evaluated, while {\it Result} is the resulting value (if evaluated, variable in
other case) and {\it Evaluated} is a flag that indicates if the expression has
been evaluated (flag {\it on}) or not (flag variable). Every function call is
translated into a suspension in
order to share its value when the expression is passed as argument and copied.
As an example of the use of this representation consider the following program:
\begin{alltt}
  coin = 0
  coin = 1

  double X = X + X

  test1 = double coin
  test2 = rt (double coin)
\end{alltt}
Consider the evaluation of {\it test1}. As all the function calls are translated
into suspended forms, in particular {\it coin} will
have the form {\it susp(coin,[],R,E)}. The evaluation of {\it double} does not
demand the evaluation of its argument {\it coin}, so it will produce
\begin{center}
  {\it susp(coin,[],R,E) + susp(coin,[],R,E)}
\end{center}
Later, when one of the calls to {\it coin} is evaluated, for example to 0, the other
one automatically gets the same value:
\begin{center}
  {\it susp(coin,[],0,on) + susp(coin,[],0,on)}
\end{center}
The result of the addition is 0, that is a value obtained for {\it test1}. If we
evaluate {\it coin} to 1 we have
\begin{center}
  {\it susp(coin,[],1,on) + susp(coin,[],1,on)}
\end{center}
and then result 2, that is the other value obtained for {\it test1}. With this
sharing mechanism we can not
obtain the value 1 for {\it double coin} as it would require to evaluate both calls
to {\it coin} to two different values.

For the function function {\it test2} we would want to obtain the values 0 and 2
as before, but also the value 1 (evaluating separately both calls to {\it
  coin}). In this case {\it rt} will deactivate the sharing
mechanism. This can be easily achieved by translating the call {\it coin} into
the suspended form {\it susp(coin,[],R,rt)}. The flag {\it rt} will indicate to
the system that the
value of this expression must not be shared (and neither kept in the variable
{\it R}). For {\it test2} we evaluate
\begin{center}
  {\it susp(coin,[],R,rt) + susp(coin,[],R,rt)}
\end{center}
The first suspension can be reduced to 0 (without annotating the result in {\it
  R}), and the second one to 1, obtaining 1 for {\it test2} as expected.

The extension implemented in \emph{Toy} provides this behaviour with {\it test1} and
{\it test2}. In fact, for {\it test2} it obtains 0, 2 and 1 twice (evaluating
the first {\it coin} to 0 and the second to 1 and viceversa). As another
example, consider the problem of generating numbers as combinations of the
digits 0, 1 and 2. Using {\it take}, {\it repeat} and the alternative
operator `' (introduced in Sec. \ref{intro}) we could define:
\begin{alltt}
  number N = take N (repeat (0 | 1 | 2))
\end{alltt}
but then the expression {\it number 3} will produce only the answers [0,0,0],
[1,1,1] and [2,2,2], because the expression {\it 0  1  2} is evaluated only once
and then its value is shared when evaluating {\it repeat}. For achieving the
expected behaviour we have to instruct the system for choosing the digits under
run-time choice (to avoid sharing):
\begin{alltt}
  number N = take N (repeat (rt (0 | 1 | 2)))
\end{alltt}
Now we obtain the 27 possible combinations that include  or 
as instance.
The example of palindromes of Sect. \ref{intro} also works as expected.

The prototype and some examples can be found at\\
\texttt{https://gpd.sip.ucm.es/trac/gpd/wiki/GpdSystems}.

\section{Conclusions}\label{conclu}
We have proposed a simple way of combining in the same program run-time choice and
call-time choice, two semantics commonly adopted for non-determinism in
rewriting-based declarative languages, but that cannot coexist within the same
program in current systems.

The approach presented here starts from a call-time choice ambient
(as given by most popular functional logic systems like \emph{Curry} \cite{Han06curry} or \emph{Toy} \cite{LS99})
and adds to it the possibility of annotating the evaluation of (sub)-expressions as following
a run-time choice regime. We have proposed two variants of this idea, the first being more 'local'
in the effect of an annotation , while the second is more global. In both cases
we have proposed a formal definition of the intended semantics.

For the first variant we have given formal operational descriptions, by adapting to the
new setting two one-step reduction relations proposed in \cite{ppdp2007} as a simple
notion of rewriting adequate for call-time choice. As for implementation, this variant
has been  achieved by modifying of the system \emph{Toy}. Essentially, we have needed to
change the management of \emph{suspensions}, that are the technical key to implement
sharing for call-time choice. The resulting prototype can be found at
\texttt{https://gpd.sip.ucm.es/trac/gpd/wiki/GpdSystems}.


For the second variant we give a logical
semantics that extends, to cope with \emph{rt} annotations, the proof calculus
of the \emph{CRWL} framework \cite{GHLR99}. We have seen how to transform
annotations of this variant into the first one. This mapping can be used to implement
the second variant.

Recently, we have tried a different alternative to the combination
of call-time and run-time choice \cite{LRStchrRTCT08long}, following
a way complementary to the one in this paper: there we start from ordinary rewriting
and enhance it with local bindings through a \emph{let} construct to express sharing
and call-time choice. The resulting framework seems to be more amenable to formal
treatments, as shown by the good number of technical results obtained in
\cite{LRStchrRTCT08long}. On the other hand, the approach here seems to be more
easily implementable, at least if one wants to reuse existing call-time-choice
based implementations.

\begin{thebibliography}{10}

\bibitem{Antoy97ALP}
S.~Antoy.
\newblock Optimal non-deterministic functional logic computations.
\newblock In {\em Proc. International Conference on Algebraic and Logic
  Programming (ALP'97)}, pages 16--30. Springer LNCS 1298, 1997.

\bibitem{BaaderNipkow-98}
F.~Baader and T.~{}Nipkow.
\newblock {\em Term Rewriting and All That}.
\newblock Cambridge University Press, United Kingdom, 1998.

\bibitem{toyreport}
R.~Caballero and J.~S\'anchez~(eds.).
\newblock {TOY}: A multiparadigm declarative language, version 2.2.3.
\newblock Technical report, UCM, Madrid, July 2006.

\bibitem{GHLR99}
J.~C. G{onz\'alez-Moreno}, T.~H{ortal\'a-Gonz\'alez}, F.~L{\'opez-Fraguas}, and
  M.~R{odr\'{\i}guez-Artalejo}.
\newblock An approach to declarative programming based on a rewriting logic.
\newblock {\em Journal of Logic Programming}, 40(1):47--87, 1999.

\bibitem{Hanus07ICLP}
M.~Hanus.
\newblock Multi-paradigm declarative languages.
\newblock In {\em Proceedings of the International Conference on Logic
  Programming (ICLP 2007)}, pages 45--75. Springer LNCS 4670, 2007.

\bibitem{Han06curry}
M.~H{anus (ed.)}.
\newblock {C}urry: An integrated functional logic language (version 0.8.2).
\newblock Available at {\it http://www.informatik.uni-kiel.de/\verb+~+}{\it
  curry/}{\it report.html}, March 2006.

\bibitem{hussmann93}
H.~Hussmann.
\newblock {\em Non-Determinism in Algebraic Specifications and Algebraic
  Programs}.
\newblock Birkh\"auser Verlag, 1993.

\bibitem{LLR93}
R.~Loogen, F.~L{\'opez-Fraguas}, and M.~R{odr\'{\i}guez-Artalejo}.
\newblock A demand driven computation strategy for lazy narrowing.
\newblock In {\em Proc. International Symposium on Programming Language
  Implementation and Logic Programming (PLILP'93)}, pages 184--200. Springer
  LNCS 714, 1993.

\bibitem{ppdp2007}
F.~L{\'opez-Fraguas}, J.~R{odr\'{\i}guez-Hortal\'a}, and
  J.~S{\'anchez-Hern\'andez}.
\newblock A simple rewrite notion for call-time choice semantics.
\newblock In {\em Proc. Principles and Practice of Declarative Programming},
  pages 197--208. ACM Press, 2007.

\bibitem{LRStchrRTCT08long}
F.~L{\'opez-Fraguas}, J.~R{odr\'iguez-Hortal\'a}, and
  J.~S{\'anchez-Hern\'andez}.
\newblock A flexible framework for programming with non-deterministic functions
  (extended version).
\newblock Technical report, 2008.
\newblock \url{http://gpd.sip.ucm.es/juanrh/pubs/tchrRTCT08.pdf}.

\bibitem{LS99}
F.~L{\'opez-Fraguas} and J.~S{\'anchez-Hern\'andez}.
\newblock : A multiparadigm declarative system.
\newblock In {\em Proc. Rewriting Techniques and Applications (RTA'99)}, pages
  244--247. Springer LNCS 1631, 1999.

\bibitem{Sondergaard95}
H.~S{\o}ndergaard and P.~Sestoft.
\newblock Non-determinism in functional languages.
\newblock {\em The Computer Journal}, 35(5):514--523, 1992.

\end{thebibliography}
\end{document}
