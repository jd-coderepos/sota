\documentclass[11pt]{article}
\usepackage{pifont,fullpage,xspace,epsfig, wrapfig,paralist}
\usepackage{amsmath, amsthm, amssymb,times}
\usepackage{latexsym}
\usepackage{graphicx}
\usepackage{amsfonts}
\newenvironment{CompactItemize}{\begin{itemize}}{\end{itemize}}
\newenvironment{CompactEnumerate}{ 
\begin{list}{\arabic{enumi}.}{\usecounter{enumi}
\setlength{\leftmargin}{12pt}
\setlength{\itemindent}{3pt}
\setlength{\topsep}{3pt}
\setlength{\itemsep}{1pt}
}}
{\end{list}}
\newenvironment{remark}{\noindent {\em Remark:}}{\smallskip}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{definition}[theorem]{Definition}

\newtheorem{prop}[theorem]{Proposition}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{corollary}[theorem]{Corollary}

\newcommand{\FI}[1]{Fig.\ \ref{#1}}
\newcommand{\ind}{\hspace*{5mm}}
\newenvironment{algorithm}[1]{{\vspace{1ex} \noindent \bf #1:
\sffamily}}{\rmfamily \vspace{1ex} }
\newcommand{\bec}{\leftarrow}
\newcommand{\alg}[2]{\begin{center}\fbox{\begin{minipage}{0.99\columnwidth}{\begin{center}\underline{\textsc{#1}}\end{center}{#2}}\end{minipage}}\end{center}}

\newcommand{\rbec}{\rightarrow}
\DeclareMathSymbol{\R}{\mathbin}{AMSb}{"52}

\title{Approximately Counting Embeddings into Random Graphs\thanks{A preliminary version of this paper appeared in 12th International Workshop on Randomization and Computation (RANDOM 2008).}}
\author{Martin F\"urer\thanks{Pennsylvania State University, {\tt furer@cse.psu.edu}. Research supported in part by NSF Grant CCF-0964655.} \ \ \ \ \ \ Shiva Kasiviswanathan\thanks{General Electric Research, {\tt kasivisw@gmail.com}. }}
\renewcommand{\today}{}
\begin{document}
\maketitle

\begin{abstract}
Let  be a graph, and let  be the number of (subgraph isomorphic) copies of  contained in a graph . We investigate the fundamental problem of estimating . Previous results cover only a few specific instances of this general problem, for example, the case when  has degree at most one (monomer-dimer problem). In this paper, we present the first general  subcase of the subgraph isomorphism counting problem which is almost always efficiently approximable. The results rely on a new graph decomposition technique.  Informally, the decomposition is a labeling of the vertices such that every edge is between vertices with different labels and for every vertex all neighbors with a higher label have identical labels. The labeling implicitly generates a sequence of bipartite graphs which permits us to break the problem of counting embeddings of large subgraphs into that of counting embeddings of small subgraphs. Using this method, we present a simple randomized algorithm for the counting problem.  For all decomposable graphs  and all graphs , the algorithm is an unbiased estimator. Furthermore, for all graphs  having a decomposition where each of the bipartite graphs generated is small and almost all graphs , the algorithm is a fully polynomial randomized approximation scheme. 

We show that the graph classes of  for which we obtain a fully polynomial randomized approximation scheme for almost all  includes graphs of degree at most two, bounded-degree forests, bounded-length grid  graphs, subdivision of bounded-degree graphs,  and major subclasses of outerplanar graphs, series-parallel graphs and planar graphs, whereas unbounded-length grid graphs are excluded.  Additionally, our general technique can easily be applied to proving many more similar results. 
\end{abstract}
\section{Introduction}
Given a {\em template} graph  and a {\em base} graph , we call an injection  between vertices of  and vertices of  an {\em embedding} of  into  if  maps every edge of  into an edge of . In other words,  is an isomorphism between  and a subgraph (not necessarily induced) of . Deciding whether such an injection exists is known as the subgraph isomorphism problem. Subgraph isomorphism is an important and general form of pattern matching. It generalizes many interesting graph problems, including Clique, Hamiltonian Path, Maximum Matching, and Shortest Path. This problem arises in application areas ranging from text processing to physics and chemistry~\cite{app1,app2,app3,app4}. The general subgraph isomorphism problem is NP-complete, but there are various special cases which are known to be fixed-parameter tractable in the size of  \cite{zwick}.

In this work, we consider the related fundamental problem of counting the number of copies of a template graph in another graph. By a {\em copy} of  in  we mean any, not necessarily induced subgraph of , isomorphic to . In general the problem is \#P-complete (introduced by Valiant \cite{val}). The class \#P is defined as   such that on input , the computation tree of  has exactly  . Problems co\-mplete for this class are presumably very difficult, especially since Toda's result \cite{toda} implies that a call to a \#P-oracle suffices to solve any problem in the polynomial hierarchy in polynomial time. 

Fixed-parameter tractability of this counting problem has been well-studied with negative results for exact counting \cite{grohe} and positive results for some special cases of approximate counting \cite{arvind}. In this paper, we are interested in the more general problem of counting copies of large subgraphs. Exact counting is possible for very few classes of non-trivial large subgraphs. A key example is perfect matchings in a planar graph~\cite{kat}. A slightly different problem that is also solvable in polynomial time is counting the number of spanning trees in a graph. A few more problems such as counting perfect matchings in a bipartite graph (a.k.a.\ - permanent) \cite{jsv},  counting all matchings in a graph \cite{ising}, counting labeled subgraphs of a given degree sequence in a bipartite graph \cite{ivana}, counting combinatorial quantities encoded by the Tutte polynomial in a dense graph  \cite{noga1},  and counting Hamilton cycles in dense graphs \cite{fd}, can be done approximately. But problems like counting perfect matchings in general graphs are still open.

Since most of the other interesting counting problems are hopelessly hard to solve (in many cases even approximately) \cite{jer}, we investigate whether there exists a {\em fully polynomial randomized approximation scheme} (henceforth, abbreviated as fpras) that works well for {\em almost all graphs}. The statement can be made precise as: Let  be a graph chosen uniformly at random from the set of all -vertex graphs. We say that a predicate  holds for almost all graphs if  as  (probability over the choice of a random graph). By fpras we mean a randomized algorithm  that produces a result that is correct to within a relative error of  with high probability (i.e., probability tending to 1). The algorithm must run in time , where  is the input size. We call a problem {\em almost always efficiently approximable} if there is a randomized polynomial time algorithm producing a result within a relative error of  with high probability for almost all instances.

Previous attempts at solving these kinds of problems have not been very fruitful. For example, even seemingly simple problems like counting cycles in a random graph have remained open for a long time (also stated as an open problem in the survey by Frieze and McDiarmid \cite{fmc}).  In this paper we present new techniques that can not only handle simple graphs like cycles, but also major subclasses of more complicated graph classes like outerplanar, series-parallel, planar etc.

The theory of random graphs was initiated by Erd{\H{o}}s and R{\'e}nyi \cite{erdos}. The most commonly used models of random graphs are  and . Both models specify a distribution on -vertex graphs with a fixed set of vertices. In  each of the  edges is added to the graph independently with probability  and  assigns equal probability to all graphs with exactly  edges.  Unless explicitly stated otherwise, the default model addressed in this paper is . 

There has been a lot of interest in using random graph models for analyzing typical cases (beating the pessimism of worst-case analysis). Here, we mention some of these results relevant to our counting problem (see the survey of Frieze and McDiarmid \cite{fmc} for more). One of the most well-studied  problems is that of counting perfect matchings in graphs. For this problem, Jerrum and Sinclair \cite{jerrum1} have presented a simulation of a Markov chain that almost always is an fpras (extended to all bipartite graphs in \cite{jsv}). Similar results using other approaches were obtained later in~\cite{frieze,ras,chien,shiva1}. Another well-studied problem is that of counting Hamiltonian cycles in random digraphs. For this problem, Frieze and Suen \cite{suen} have obtained an fpras, and later Rasmussen \cite{ras} has presented a simpler fpras. Afterwards, Frieze \emph{et al.}\ \cite{fm} have obtained similar results in random regular graphs. Randomized approximation schemes are also available for counting the number of cliques in a random graph \cite{ras1}. However, there are no general results for counting copies of an arbitrary given~graph in a random graph. 

\subsection{Our Results and Techniques}
In this paper, we remedy this situation by presenting the first general subcase of the subgraph isomorphism counting problem that is almost always efficiently approximable. For achieving this result we introduce a new graph decomposition that we call an {\em ordered bipartite decomposition}. Informally, an ordered bipartite decomposition is a labeling of vertices such that every edge is between vertices with different labels and for every vertex all neighbors with a higher label have identical labels. The labeling implicitly generates a sequence of bipartite graphs and the crucial part is to ensure that each of the bipartite graphs is of small size. The size of the largest bipartite graph defines the {\em width} of the decomposition. The decomposition allows us to obtain general results for the counting problem which could not be achieved using the previous methods. It also leads to a relatively simple and elegant analysis. We will show that many graph classes have such a decomposition, while at the same time many simple small graphs (like a triangle) may not possess a decomposition.

The actual algorithm itself is based on the following simple sampling idea (known as importance sampling in statistics): let  be a large set whose cardinality we want to estimate.  Assume that we have a randomized algorithm () that picks each element  with non-zero known probability . Then,  the Algorithm Count (\FI{count}) produces an estimate for the cardinality of . The following proposition shows that the estimate is unbiased, i.e., . 

\begin{figure}[btp]
\alg{Algorithm Count(,)}{
 (let Algorithm  return  with probability  for all  with )\\
If  for , then  \\
Else  \\
Output 
}
\caption{Estimator for the cardinality of .}
\label{count}
\end{figure}


\begin{proposition} \label{bias}
The Algorithm Count (\FI{count}) is an unbiased estimator for the cardinality of .
\end{proposition} 
\begin{proof}
It suffices to show that each element  has an expected contribution of  towards . This holds because on picking  (an event that happens with probability ), we set  to the inverse probability of this event happening. Therefore, .
\end{proof}

Similar schemes of counting have  previously been used by Hammersley \cite{hammer} and Knuth \cite{knuth} in other settings. Recently, this scheme has been used by Rasmussen for approximating the permanent of a - matrix \cite{ras}, and later for approximately counting cliques in a graph \cite{ras1}. A variant of this scheme has also been used by the authors to provide a near linear-time algorithm for counting perfect matchings in random graphs \cite{shiva,shiva1}. This is however the first generalization of this simple idea to the general problem of counting graph embeddings. Another nice feature  of such schemes is that they also seem to work well in practice~\cite{piotr}.

Our randomized algorithm will try to embed  into . If the algorithm succeeds in finding an embedding of  in , it outputs the inverse probability of finding this embedding. The challenging task here is not only to ensure that each embedding of  in  has a positive probability of being found but also to pick each embedding with approximately equal probability to obtain a low variance. For this purpose, the algorithm considers an increasing sequence of subgraphs  of . The algorithm starts by randomly picking an embedding of  into , then randomly an embedding of  into  containing the embedding of  and so on. It is for defining the increasing sequence of subgraphs that our decomposition is useful. 

The algorithm is always an unbiased estimator for .  The decomposition provides a natural sufficient condition for the class of algorithms based on the principle of the Algorithm Count to be an unbiased estimator. Additionally, if the base graph is a random graph from  with constant  and if the template graph has an ordered bipartite decomposition of bounded width, we show that the algorithm is an fpras.  The interesting case of the result is when . Since the  model assigns a uniform distribution over all graphs of  given vertices, an fpras (when the base graph is from ) can be interpreted as an fpras for almost all base graphs. This result is quite powerful because now to prove that the number of copies of a template graph can be well-approximated for most graphs , one just needs to show that the template graph has an ordered bipartite decomposition of bounded width.

The later half of the paper is devoted to showing that a lot of interesting graph classes naturally have an ordered bipartite decomposition of bounded width.  Let  denote a cycle of length .  If a graph  does not have a subgraph isomorphic to , then we say  is -free.\!\footnote{This is a weaker definition that the notion of minor-free graphs used commonly in the graph theory literature~\cite{diestel}.} In this paper, we show that graphs of degree at most two, bounded-degree forests, bounded-length grid (lattice) graphs,\!\footnote{The {\em length} of an  grid graph is .} subdivision of bounded-degree graphs, bounded-degree outerplanar graphs which are -free, bounded-degree series-parallel graphs which are both - and -free\footnote{Denoted henceforth as -free.}, and planar graphs of girth at least 16 have an ordered bipartite decomposition of bounded width. Using this we obtain the following result (proved in Theorems~\ref{mainproof} and~\ref{thm:probg}). 

\begin{theorem} [Main Result\footnote{The proof of this theorem follows by combining Theorems~\ref{thm:fpras} and~\ref{thm:probg}.}] \label{first}
Let  be a connected graph from one of the following graph classes: graphs of degree at most two, bounded-degree trees, bounded-length grid graphs, subdivision of bounded-degree graphs, bounded-degree -free outerplanar graphs,  bounded-degree -free series-parallel graphs, or  bounded-degree planar graphs of girth at least 16. Then,  there exists an fpras for estimating the number of copies of H in  for constant .
\end{theorem} 

Even when restricted to graphs of degree at most two, this theorem recovers most of the older results. It also provides simpler, unified proofs for (some of) the results in \cite{frieze,ras,chien,suen}. For example, to count matchings of cardinality  one could use a template consisting of  disjoint edges. Similarly, to count all cycles of length   the template is a cycle of that length. By varying  and boosting the success probability, the algorithm can easily be extended to count all matchings or all cycles. This provides the first fpras for counting all cycles in a random graph (solving an open problem of Frieze and McDiarmid~\cite{fmc}). 


For template graphs coming from the other classes, our result supplies the first efficient randomized approximation scheme for counting copies of them in almost all base graphs. For example, it was not known earlier how to even obtain an fpras for counting the number of copies of a given bounded-degree tree in a random graph. For the simpler graph classes the decomposition follows quite straightforwardly, but for graph classes such as subdivision, outerplanar, series-parallel, and planar, constructing the decomposition requires several new combinatorial/algorithmic ideas. Even though our techniques can be extended to other interesting graph classes, we conclude by showing that our techniques can't be used to count the copies of an unbounded-length grid graph in a random graph.

\paragraph{Organization.} In Section~\ref{sec:def}, we review some useful definitions. In Section~\ref{algo}, we define the ordered bipartite decomposition, and use that to obtain an  fpras for counting copies of a graph in a random graph. Section~\ref{exam} shows that many graph classes have an ordered bipartite decomposition of bounded width, whereas in Section~\ref{neg}, we show that an unbounded-length grid graph does not have this property.  We conclude in Section~\ref{sec:concl}.

\section{Definitions and Notation} \label{sec:def}
\begin{definition} [Fully Polynomial Randomized Approximation Scheme (fpras)]
Let  be some function from the set of input strings  to natural numbers. A fully polynomial randomized approximation scheme for  is a randomized algorithm that takes input  and an accuracy parameter  and outputs a number  (a random variable depending on the coin tosses of the algorithm) such that, 
 
and runs in time polynomial in , . The success probability can be boosted to  by running the algorithm  times and taking the median \cite{vazirani}. 
\end{definition}

\paragraph{Graph Notation.}
Throughout this paper, we use  to denote a base random graph on  vertices.  The graph  is the template whose copies we want to count in . We can assume without loss of generality that the graph  also contains  vertices, otherwise we just add isolated vertices to . The number of isomorphic images remains unaffected. Let  denote the maximum degree of .

For a graph , we use  to denote its vertex set and  to denote its edge set. Furthermore, we use  and  for the number of vertices and edges. For a subset  of vertices of ,  denotes the neighborhood of  in .  denotes the subgraph of  induced by . 

Automorphisms are edge respecting permutations on the set of vertices, and the set of automorphisms form a group under composition. For a graph , we use  to denote the size of its automorphism group. For a bounded-degree graph ,  can be evaluated in polynomial time \cite{luks}.

We use  to denote the number of copies of  in . Let  denote the number of embeddings (or labeled copies) of  in . For a random graph , we will be interested in quantities  and . 

 Most of the other graph-theoretic concepts that we use (such as planarity) are covered in standard text books (see, e.g., \cite{diestel}), and we describe them as needed. 

\paragraph{Randomization.} Our algorithm is randomized. The output of the algorithm is denoted by , which is an unbiased estimator of , i.e.,  (expectation over the coin tosses of the algorithm). As the output of our algorithm depends on both the input graph, and the coin tosses of the algorithm, we use expressions such as . Here, the inner expectation is over the coin-tosses of the algorithm, and the outer expectation is over the graphs of . Note that  is a random variable defined on the set of graphs. 

\section{Approximation Scheme for Counting Copies} \label{algo}
We define a new graph decomposition technique which is used for embedding the template graph into the base graph.  As stated earlier our algorithm for embedding works in stages and our notion of decomposition captures this idea.   
\begin{definition} [Ordered Bipartite Decomposition]  \label{def:obd}
An ordered bipartite decomposition of a graph  is a sequence  of subsets of  such that: 
\begin{dingautolist}{172}   \newcommand{\titem}{\item}
\titem  form a partition of .
\titem Each of the  (for ) is an independent set in .   
\titem  such that  implies . 
\end{dingautolist}  
\end{definition}
Property \ding{174} just states that if a neighbor of a vertex  is in some  (), then all other neighbors of  which are not in , are in .  Property \ding{174} will be used in the analysis for random graphs to guarantee that in every stage, the base graph used for embedding is still random with the original edge probability.  

Let . Define 
 

\begin{wrapfigure}[8]{r}{100pt}
\begin{picture}(150,5)(0,80)
\put(0,-10){\epsfig{file=fig10.eps,width=100pt}}
\put(44,-2){\footnotesize }
\put(36,20){\footnotesize }
\put(72,45){\footnotesize }
\put(71,83){\footnotesize }
 \end{picture}
\end{wrapfigure} 
 is the set of neighbors of  in . Define  to be the subgraph of  induced by .  Let  denote the edge set of graph .  
\begin{definition} [Width of Ordered Bipartite Decomposition] 
Let  be the ordered bipartite decomposition of a graph . Let  be the set of neighbors of  in . Define  to be the subgraph of  induced by .  The {\em width} of an ordered bipartite decomposition of  is the number of edges (size) in the largest . 
\end{definition}


The 's will play an important role in our analysis. Note that given a , its corresponding  has the property that . Hereafter, when the context is clear, we just use {\em decomposition} to denote an ordered bipartite decomposition. In general, the decomposition of a graph needn't be unique. The following lemma describes some important consequences of the decomposition. 
\begin{lemma} \label{com}
Let  be a decomposition of a graph . Then,  the following assertions are true. 
\begin{enumerate}
\item \label{item:1} Each of the  is an independent set in   is a bipartite graph. 
\item \label{item:2} The edge set  is partitioned into .
\end{enumerate}
\end{lemma}
\begin{proof}
For Part~\ref{item:1}, assume otherwise. Let  be an edge in  with both . Let  appear in some  () and  appear in some  (). Property \ding{173} implies that . Assume without loss of generality that . Property \ding{174}  implies there exists no vertex  such that . Therefore, . Contradiction. Additionally, since each of the  and  is an independent set, each of the graph  is bipartite.\\
For Part~\ref{item:2}, first note that due to Properties \ding{172} and \ding{174}, the 's are pairwise disjoint (but they do not necessarily form a partition). Therefore, the 's are also pairwise disjoint. Now since for every edge  there exist a  such that   and  and without loss of generality . Then,  and . Thus,  form a partition of .  
\end{proof}


Every graph has a trivial decomposition satisfying Properties \ding{172} and \ding{173}, but the situation changes if we add Property \ding{174} ( is the simplest graph which has no decomposition). Every bipartite graph though has a simple decomposition, but not necessarily of bounded width. Note that the bipartiteness of  is a sufficient condition for it to have an ordered bipartite decomposition, but not a necessary one.

We will primarily be interested in cases where the decomposition is of bounded width. This can only happen if  is a constant. In general, if  grows as a function of , no decomposition could possibly have a bounded width ( is always a trivial lower-bound for the width). The size of the parameter  is not important in our analysis. 
\begin{figure*}
\alg{Algorithm Embeddings(G,H)}{
Initialize , ,  \\
Let  denote an ordered bipartite decomposition of  \\
For  to  do\\
\ind Let  ( is the subgraph of  used for embedding ) \\
\ind Compute , the number of embeddings of  in  with  fixed  mapping given by~ \\
\ind Pick an embedding uniformly at random (if one exists) and use it to update \\
\ind If no embedding exists, then set  to  and terminate\\
\ind \\
\ind  \\
 \\
Output }
\caption{Algorithms for counting copies of graph  in .}
\label{fig:embed}
\end{figure*}

\paragraph{Algorithm for Counting Embeddings.} The input to the Algorithm Embeddings (\FI{fig:embed}) is the template graph  together with its decomposition and the base graph .  The algorithm tries to construct a bijection  between the vertices of  and .  represents the set of vertices of  which get embedded into  during the th stage, and the already constructed mapping of  is used to achieve this. For a subset of vertices ,  denotes the image of  under . If  ( is defined in the Algorithm Embeddings), then the function  represents an embedding of  in  (consequence of Properties \ding{172} and \ding{173}), and the output  represents the inverse probability of this event happening. Since every embedding has a positive probability of being found,  is an unbiased estimator for the number of embeddings of  in  (Proposition \ref{bias}), and  is an unbiased estimator for the number of copies of  in . 

The actual procedure for computing the 's is not very relevant for our results, but note that the 's can be computed in polynomial time if  has a decomposition of bounded width.  In this case the Algorithm Embeddings runs in polynomial time.

Since the Algorithm Embeddings is an unbiased estimator, use of Chebychev's inequality implies that repeating the algorithm  times and taking the mean of the outputs results in a randomized approximation scheme for estimating .  The ratio  is commonly referred to as the {\em critical ratio}.  


\subsection{FPRAS for Counting in Random Graphs}
We now concentrate on showing that for random graphs the algorithm is an fpras. From here on, we abbreviate  as . A few of the technical details in our proof are somewhat similar to previous applications of this sampling idea, such as that for counting perfect matchings \cite{ras,shiva1}. The simpler techniques in these previous results, however, are limited to handling one edge per stage (therefore, they work only when  is a matching).  Algorithm Embeddings embeds a small sized subgraph at every stage. The key for obtaining an fpras is to guarantee that the factor contributed to the critical ratio at every stage is very small (which is now involved because it is no longer a simple ratio of binomial moments as in \cite{ras,shiva1}). We then do a stage-by-stage analysis of the critical ratio 
to show that the Algorithm Embedding is an fpras.

The analysis will be done for a worst-case graph  under the assumption that the width of the decomposition of  is bounded by a universal constant . Here, instead of investigating the critical ratio, we investigate the much simpler ratio , which we call the {\em critical ratio of averages}. We use the second moment method to show that these two ratios (critical ratio and critical ratio of averages) are closely related. To establish this fact, we take a detour through the  model. The ratio  plays an important role here and for bounding it we use a recent result of Riordan \cite{riordan}. The result (stated below) studies the related question of when a random graph  is likely to have a spanning subgraph isomorphic to .  Let  denote the maximum degree of . The idea behind the following theorem is to use Markov's inequality to bound  in terms of  and . The main thrust lies in proving that .\!\footnote{
Since  is fairly tightly concentrated around its mean, a rudimentary approximation for  is just  (as ). However, this naive approach doesn't produce for {\em any} , an -approximation for  (see, e.g.,~\cite{frieze,suen,ras,ras1,chien}).}

In the following,  is used to denote . We say an event holds with high probability (w.h.p.), if it holds with probability tending to  as .
\begin{theorem}[Riordan \cite{riordan}, Restated] \label{rior}
Let  be a graph on  vertices. Let , and let  with  an integer. Suppose that the following conditions hold: , and  , where  

Then,  w.h.p.\ a random graph  has a spanning subgraph isomorphic to .  In particular,  satisfies

\end{theorem}
The quantity  is closely related to twice the maximum average degree of a subgraph of . 



The templates graph that we will be interested are bounded-degree connected graphs. For a bounded-degree graph , both  and  are constants. Also, since the graph is connected . Additionally, for us  is a constant (as we work with dense random graphs ). Therefore, the conditions of Theorem~\ref{rior} are all satisfied.

\begin{corollary} \label{cor:gnm}
Let  be a bounded-degree connected graph on  vertices. Then,  w.h.p.\ a random graph  satisfies .
\end{corollary} 

Corollary~\ref{cor:gnm} with Chebychev's inequality gives,  tends to  as  tends to . Using this and standard results on asymptotic equivalence between  and  models of random graphs (e.g., see Proposition 1.12 of \cite{jansonr}) yields the following corollary. Similar analysis has been used in the previous works of~\cite{frieze,suen,ras,ras1,chien}.
\begin{corollary} \label{cor:l1}
Let  be a bounded-degree connected graph on  vertices. Let  be any function tending to  as , and let  be a constant. Then,  w.h.p.\ a random graph  satisfies .
\end{corollary}

Using the above result we investigate the performance of Algorithm Embeddings when  is a random graph.
The proof idea is to break the critical ratio analysis of the large subgraph into a more manageable critical ratio analysis of small subgraphs.

\begin{proposition} \label{critical} \label{mainproof}
Let  be an -vertex connected graph with a decomposition of width  (a constant). Let  be the output of Algorithm Embeddings, and let  be a constant. Then,  w.h.p.\ for a random graph  the critical ratio  is polynomially bounded in .
\end{proposition}
\begin{proof}
We first relate the critical ratio to the critical ratio of averages. As the estimator is unbiased . Therefore, from Corollary~\ref{cor:l1},

Squaring both sides, 
Note that  refers to the expected output for fixed graph , and the inequalities hold for almost all such graphs , while  is the expected output for a random graph .

The numerator of critical ratio of averages, . Using Markov's inequality 

Using the above inequalities yields 


Now, we just concentrate on bounding the critical ratio of averages.  Let  denote a decomposition of  of width . In the bipartite graph  between the vertices of  and  with edge set , let , , and . Let . We will rely on the fact that all the 's are of bounded (size) width. 

Let . Let  be a random graph from  with  distinguished vertices. Let  denote the number of embeddings of  in  where the mapping of the vertices in  to the distinguished vertices in  is fixed (given). The results do not depend on the mapping used for . We abbreviate  by . 


First we investigate the numerator of the critical ratio of averages. Here we use the fact that

The previous equality arises, because at the th stage the graph used for embedding  is from  irrespective of the choices made over the first  stages. This is guaranteed by Property~\ding{174} of the decomposition and in turn it allows us to perform a stage-by-stage analysis of the critical ratio.  

Furthermore,  (as the graph is random, it doesn't matter which vertices  gets mapped to). Next we investigate the  denominator of the critical ratio of averages. Here we use the fact that



Therefore, the ratio  To bound this expression we investigate the parameter . 

Now consider a complete bipartite graph  with one side being the  distinguished vertices of  and the other side being the remaining (non-distinguished) vertices of . Let  be the set of embeddings of  in  where the mapping of the vertices in  to the distinguished vertices in  is fixed as in  (note that one side of  contains these distinguished vertices) . For each embedding  from  define the indicator random variable . For each , let  be the number of edges in , and let  be the number of vertices in  which belong to . Now there are  pairs  of embeddings of  in  with  isomorphic () to . In the following, we use  for .  


The second equality (above) used the fact that random variables  and  are independent if  . The implicit constants in the above equivalences depend on the width of  (a constant), but are independent of . The quantity  
 
Therefore, , implying . If , then , and . Putting everything together, we obtain

for constant  depending only on  and . Since ,  can be polynomially bounded (to ) by a telescoping argument.
Putting everything together,  we get that the critical ratio  is polynomially bounded in . This completes the proof.
\end{proof} 


Summarizing, we have the following result: if  has a decomposition of bounded width , then for almost all graphs , running the Algorithm Embeddings  times  and taking the mean of the outputs it generates results in an -approximation for . Here,  is a polynomial in  depending on  and . Since each run of the Algorithm Embeddings also takes polynomial time (as  has bounded width decomposition), this is, an fpras. 

\begin{theorem} \label{thm:fpras}
Let  be an -vertex connected graph with a decomposition of width  (a constant). Then,   there exists an fpras for estimating the number of copies of H in  for constant .
\end{theorem}


\section{Graphs with Ordered Bipartite Decomposition}\label{exam}
We divide this section into subsections based on the increasing complexity of the graph classes. We will prove the following result in the remainder of this section. 

\begin{theorem}\!\footnote{The proof of this theorem follows by combining Propositions~\ref{prop:1},~\ref{prop:2},~\ref{prop:3},~\ref{prop:4}, and ~\ref{prop:5}.}  \label{thm:probg}
Let  be a graph from one of the following graph classes: graphs of degree at most two, forests, bounded-length grid graphs, subdivision graphs, -free outerplanar graphs, -free series-parallel graphs, or planar graphs of girth at least 16. Then,  there exists an ordered bipartite decomposition of . Furthermore, if  has bounded degree, then the decomposition has bounded width. 
\end{theorem}  

We concentrate on connected graphs .\!\footnote{If  is disconnected then a decomposition is obtained by combining the decomposition of all the connected components (in any order).} Let  be the maximum degree of any vertex in . For constructing the decomposition, the following definitions are useful, 
 
All our decomposition algorithms proceeds in steps with step  creating the  pair. 

\subsection{Some Easy Graph Classes} \label{simp}
We start off by considering easy graph classes such as graphs of degree at most two (paths and cycles), trees, and grid graphs. \FI{tri} illustrates some examples. 
\begin{itemize}
\item \noindent{\textbf {Paths:}} Let  represent a path  of length . Then, the decomposition is,  for . 
\begin{figure}[btp]
\centering
\hfill
\begin{minipage}[t]{.3\textwidth}
\begin{center}  
\vspace*{-.4in}
\includegraphics[width=5cm]{fig8a_redraw.pdf}
\end{center}
\end{minipage}
\hfill
\begin{minipage}[t]{.3\textwidth}
\begin{center}  
\vspace*{-.4in}
\includegraphics[width=5cm]{fig9a_redraw.pdf}
\end{center}
\end{minipage}
\hfill
\begin{minipage}[t]{.3\textwidth}
\begin{center}  
\vspace*{-.4in}
\includegraphics[width=5cm]{fig7a_redraw.pdf}
\end{center}
\end{minipage}
\hfill
\caption{Decomposition of a cycle, tree, and grid.  Vertices with label  constitute . Neighbors of  with lower labels constitute .}
\label{tri}
\end{figure}

\item \noindent{\textbf {Cycles:}} First consider the cycles of length four or greater.  Let  be the vertices of a cycle~ of length  enumerated in cyclic order. In the decomposition, , , and  for . Cycles of length three (triangles) don't have a decomposition, but counting copies of triangles is easy (we describe an algorithm to do so in Appendix~\ref{app:app2}). This also completes the claim for graphs of degree at most two in Theorem~\ref{thm:probg}.

\item \noindent{\textbf{Trees:}} For a tree , , where  is any vertex in . For , let  be any vertex from , then  is the set of neighbors of this vertex which are not in . Intuitively,  is the set of children of the vertex in , if one thinks of  as a tree rooted at . The width of this decomposition is at most .

\item \noindent{\textbf{Grid Graphs:}} Let   be the length of the grid graph  (for an  grid graph the length is ). Set , where  is any corner vertex in . Later on,  is the set of all vertices which are at a lattice (Manhattan) distance  from . Since for each , there are at most  vertices at distance  from , the sizes of the 's are bounded if  is bounded. Consequently, the width of this decomposition is bounded if  is bounded. This construction also extends to higher dimensional grid graphs.
\end{itemize}

\begin{proposition} \label{prop:1}
Let  be a graph from one of the following graph classes: graphs of degree at most two, bounded-degree forests, or bounded-length grid graphs. Then,  there exists an ordered bipartite decomposition of  with bounded width.
\end{proposition}

\subsection{Decomposition of Subdivision Graphs}\label{app6}
A -subdivision graph of a graph is obtained by inserting  new vertices in every edge, that is by replacing each original edge by a path of length . We relax this definition and say that a -subdivision graph is the graph obtained by inserting at least one and at most  vertices in every edge. Let  be a -subdivision graph of a graph . We now show that  has a decomposition of width at most .

The main idea behind the decomposition is that as soon as a vertex  of  appears in some , all vertices in  not in  are selected in , i.e., . The decomposition of  can be formally defined as, 

We now argue correctness of the decomposition for which the following lemma is useful.  
\begin{lemma} \label{sub}
There exists at most one vertex in  for all  in the decomposition.
\end{lemma}
\begin{proof}
Proof by induction over . True by construction for . Assume by the inductive hypothesis,  has at most one vertex. If there exists a vertex in , then let  be this vertex. In this case,  doesn't contain any vertex from  (this follows as subdivision of  creates ). Otherwise, , therefore, there is at most one vertex of  in  (again this follows because of subdivision of  creates ). Therefore, in both cases, .  
\end{proof}

Notice that the decomposition described above selects all vertices in , and the vertices selected in any  are not selected in , therefore, 's form a partition of  (Property~\ding{172}). For Property~\ding{173} notice that if   is constructed using  (or ) then (by the subdivision graph construction) it is always the case that  is an independent set, and if it constructed using , then it has at most two neighbors who do not have an edge between them (again due to the subdivision graph construction). Property~\ding{174} is satisfied as for the vertex  or  (or ), we select all its neighbors which are not in  together. 

The width of this decomposition is at most   as  the maximum degree of  is . 

\begin{proposition} \label{prop:2}
Let  be a subdivision of a bounded-degree graph. Then,  there exists an ordered bipartite decomposition of  with bounded width.
\end{proposition}

\subsection{Decomposition of Outerplanar Graphs}
In this section, we prove the decomposition property on outer planar graphs.
A graph is outerplanar if it has a planar embedding such that all vertices are on the same face. Let  be a -free outerplanar graph. The idea behind the decomposition is that vertices in  partitions the outer face into smaller intervals, each of which can then be handled separately. 

Before we formally describe the decomposition, we need some terminology. Let  be the vertices around the outer face with  (ordering defined by the outerplanar embedding). For symmetry, we add two dummy vertices  without neighbors and define , and  (the dummy vertices play no role and can be removed before running the Algorithm Embeddings).  

The algorithm proceeds in steps with step  creating the  pair. For , two vertices  with , define an {\em interval} at step  if , but for . If the interval is defined it is the sequence of vertices between  (including the endpoints).\!\footnote{If no interval exists, then all vertices are already part of the decomposition and we are done. Also, there could be more than one interval at each , in which case, we can pick any one.}  Let  be a median vertex of the vertices in  (median based on the outerplanar vertex ordering), where  is a step  interval.  Define  as the smallest subset of  containing  and also . In other words,  is the smallest set of vertices in  including  such that the set of neighbors of  excluding the vertices from  (call this set ) have the property that the vertices in  have no neighbors outside of  in . Note that setting  as  satisfies the above condition, but it may not be the smallest. 

Define . We now  argue that this is indeed a decomposition. Consider the interval  at the th step, with  as the defining endpoints, and  as the median of .  
\begin{figure}[h]
\centering
\begin{center}  
\epsfig{file=fig5a.eps, scale=0.25}
\put(-67,-7){\footnotesize 1}
\put(-27,43){\footnotesize 2}
\put(-38,80){\footnotesize 2}
\put(-62,103){\footnotesize 2}
\put(-100,80){\footnotesize 2}
\put(-120,60){\footnotesize 6}
\put(-108,40){\footnotesize 2}
\put(-4,34){\footnotesize 3}
\put(-5,78){\footnotesize 4}
\put(0,50){\footnotesize 4}                     
\put(-7,60){\footnotesize 3}
\put(-18,93){\footnotesize 3}
\put(-35,110){\footnotesize 3}
\put(-40,125){\footnotesize 5} 
\put(-60,127){\footnotesize 3}
\put(-71,123){\footnotesize 3}
\put(-112,103){\footnotesize 6} 
\put(-122,93){\footnotesize 6} 
\put(-132,83){\footnotesize 7}
\put(-137,51){\footnotesize 7}
\put(-133,32){\footnotesize 6}
\end{center}
\caption{Decomposition of an outer planar graph. Vertices with label  constitute . Neighbors of  with lower labels constitute .}
\label{fig:outerplanar}
\end{figure}


\begin{lemma} \label{fo} 
Let  be the interval at the th step. Then, . 
\end{lemma}
\begin{proof}
 can only contain vertices that have a path to  but not containing any vertex from  in the path. Since the graph is outerplanar, any path from  to any vertex  passes through either of the endpoints (), both of which are in .  In other words, since the vertices not in  do not have a path to  which does not pass through a vertex in , we have . 
\end{proof}

\begin{lemma} \label{uo} 
Let  be the interval at the th step. Then, . 
\end{lemma}
\begin{proof}
The first inequality follows as  (by construction) and  (Lemma \ref{fo}).

For the second one we use induction over . The hypothesis, is true by construction for . Assume the hypothesis holds for . Let  be the interval used by the algorithm at the th step. By inductive hypothesis, . The interval  is split into several new intervals (at least two as ) by the vertices of , which define the step  intervals. The newly created interval are of two types: (a) both its endpoints are from , (b) one endpoint is from  and other is from . In the intervals of the first type there are at most  vertices from  (at most  vertices from each of the two endpoints) and no vertex from . In the intervals of the second type, there are at most  vertices from  adjacent to the endpoint in  and at most  vertices from  (from the inductive hypothesis and the fact that  is the median of  ). Therefore, each of the newly created step  intervals (which includes ) have at most  vertices from . 
\end{proof}

The Properties \ding{172} and \ding{174} are guaranteed  by construction. Let us concentrate on Property~\ding{173}. For contradiction assume that there exists two vertices  and  in some  with the edge  in . Since no triangles exist in , both  and  should be connected to two different vertices (say,  and ) in . However, since the graph is outerplanar there exists no path from  to  going through any vertices of  other than  and . This would mean that we could remove at least one of  or  from  without disturbing the condition that it needs to satisfy. This would lead to a contradiction to   being the smallest set in  satisfying the condition.


Lemma \ref{uo} implies that the width of this decomposition is most  (as ). See \FI{fig:outerplanar} for an illustration.

\begin{proposition} \label{prop:3}
Let  be a bounded-degree -free outerplanar graph. Then, there exists an ordered bipartite decomposition of  with bounded width.
\end{proposition}

\subsection{Decomposition of Series-Parallel Graphs}
In this section, we prove the decomposition property on series-parallel graphs. A series-parallel graph (also called a two-terminal series-parallel graph)  is a graph with two distinguished vertices  and  that is obtained as follows. A single edge  is a  series-parallel graph (base case).  Let  and  be two series-parallel graphs with terminals   and  respectively. The graph formed by identifying  with  is a series-parallel graph with terminals  (series operation is denoted by ). The graph formed by identifying  with  and  with  is a series-parallel graph with terminals  and  (parallel operation is denoted by ). 

The algorithm again proceeds in steps with step  creating the  pair. In the following, the process of adding a vertex to some  is referred by the term {\em selecting}. We say a vertex is {\em finished} once it is added to some , i.e., all its neighbors are selected. The construction is technical, but the basic idea is to first finish the terminals, so that the parallel components separate (for the decomposition purposes). Then, the algorithm finishes some vertex joining two serial components. In both these steps the algorithm might be forced to finish some other vertices too. 

To define the decomposition we need some more terminology. Let  be a -free series-parallel graph with (distinguished) terminals  and .  Let  denote a decomposition of . Let . For a set of vertices  in  define 
  represents the set of neighbors of  in  selected in the first  steps of the algorithm. The algorithm starts by finishing  and  as follows.  
  
In words, the first four steps of the algorithm achieves: (i) select , (ii) finish , (iii) select  unless already selected, (iv) finish . Define  
 where  is defined recursively as:

\begin{enumerate}
\item \textbf{Base case:} If all the vertices in  are selected, . 
\item \textbf{Parallel case:} If , find recursively  and . Define 
  
\item \textbf{Serial case:} If , with  as the vertex joining  and . Let   and~.
\begin{enumerate}
\item If  is finished, define . \item If  ( has already been selected) and  not finished, then finish . This produces the set . Define . \item Otherwise, first select  which produces the set . Then,  finish . This produces the set . Define . 
\end{enumerate}
 \end{enumerate}

The following lemma provides  bounds on the sizes of 's.  The proof looks at two possible situations, conditioning on the presence or absence of paths of length  or  between  and .  Since both  and  are forbidden, it follows that there can either be a path of length  or  between any two vertices, but not both. This fact will be crucial for implying Property \ding{173}. See \FI{fig:seriesparallel} for an example.

\begin{figure}[h]
\centering
\begin{minipage}[t]{.25\textwidth}
\begin{center}  
\epsfig{file=fig5b.eps, scale=0.25}
\put(-148,60){\footnotesize }
\put(0,60){\footnotesize }
\put(-74,-8){\footnotesize 9}
\put(-63,-8){\footnotesize 10}
\put(-74,129){\footnotesize 4}
\put(-61,129){\footnotesize 5}
\put(-106,8){\footnotesize 10}
\put(-36,8){\footnotesize 12}
\put(-44,33){\footnotesize 13}
\put(-80,26){\footnotesize 10}
\put(-60,26){\footnotesize 12}
\put(-100,33){\footnotesize 11}
\put(-130,37){\footnotesize 2}
\put(-106,52){\footnotesize 2}
\put(-31,52){\footnotesize 3}
\put(-106,67){\footnotesize 2}
\put(-31,67){\footnotesize 3}
\put(-7,37){\footnotesize 3}
\put(-8,86){\footnotesize 3}
\put(-130,86){\footnotesize 2}
\put(-100,87){\footnotesize 6}
\put(-37,87){\footnotesize 8}
\put(-60,92){\footnotesize 7}
\put(-35,113){\footnotesize 7}
\put(-80,92){\footnotesize 5}
\put(-101,113){\footnotesize 5}
\put(-138,118){\footnotesize 2}
\put(0,118){\footnotesize 3}
\put(-138,2){\footnotesize 2}
\put(0,2){\footnotesize 3}
\end{center}
\end{minipage}
\caption{Decomposition of a series-parallel graph. Vertices with label  constitute . Neighbors of  with lower labels constitute .}
\label{fig:seriesparallel}
\end{figure}

\begin{lemma}  \label{spg}
Let  be a -free series-parallel graph with terminals  and . Then, the above algorithm finishes  vertices in every step (size of all the 's is ).
\end{lemma}
\begin{proof}
The proof is via induction on the size of series-parallel graph. The inductive hypothesis is that if  and possibly some vertices in  are the only vertices finished, then the above algorithm finds a decomposition of  by finishing  vertices in every step.

The algorithm always first finishes  and then , and once  and  are finished the parallel components can be handled independently for constructing the decomposition. In the process of finishing , the algorithm could possibly finish some vertices in . Hence, in each of the parallel components , terminals  and possibly some vertices in  are finished. Therefore, inductively a decomposition can be obtained. So the challenging case is when  has just one parallel component. Let  with  as the vertex joining  and . There are three different cases. In each of them the interesting event occurs after , and  are finished, which splits  into  and . Afterwards, decomposition on  and  could be constructed independently.

In the following, we describe the cases under the assumption that there exists no edge between  and . If there exists such an edge, then the description would remain the same except that the step where  is selected would no longer exist ( is now selected when  is finished). Also if there is an edge between  and , then there exists no path of length  between  and , as, otherwise there would be a triangle. \\

\noindent{\textbf{Case 1: No path of length  or  between  and .}} Note that at the step when  is finished no other vertex in  is finished. Later, when  is selected the only vertices in  that finish at that step are those which are neighbors of . This set is  as, otherwise, there would be a path of length  between . Similarly, at the step when  is finished the only vertices in  that finish are those which share a common neighbor with . This set is also  as, otherwise, there would be a path of length  between . Now at the step when  is selected some vertices in  and   could possibly be finished, and at the step when  is finished some vertices in  could possibly be finished (this supplies the  bound). However, as soon as  is finished, the graphs  and  can be handled independently. Now  is a smaller series-parallel graph with terminals , where  and possibly some vertices in  are finished. Therefore, inductively a decomposition of  can be completed. Similarly,  can be viewed as a series-parallel graph with terminals . In , terminals  and possibly some vertices in  are finished. Therefore, inductively a decomposition of  can also be completed. 
\newline


\noindent{\textbf{Case 2: Paths of length  between  and :}} So there is no path of length  between  and . If  has been selected before  is finished, then  is finished together with  (at which step  is also selected). Note that  and  can be finished in the same step because there is no path of length 3. At the step when  is finished some vertices in  could possibly be finished. Afterwards,  we can invoke induction on both  and . If  is finished before selecting , then  is finished while selecting . At the step when  is finished some vertices in  could possibly be finished. Later, at the step when  is finished some vertices in  could possibly be finished. But again after  is finished, we can invoke induction on both  and .  See \FI{fig:serpar1}.


\begin{figure}[h]
\begin{center}
\includegraphics[width=5cm]{fig2a_redraw.pdf}
\vspace*{-.1in}
\caption{Illustration for Case 2. The dotted edges may not be present in the graph.}
\label{fig:serpar1}
\end{center}
\end{figure} 


\noindent{\textbf{Case 3: Paths of length  between  and :}}  So there is no path of length  between  and . There are two sub-cases based on the distance from  to . 

\noindent\textbf{First Sub-case:} First assume that the distance between  to  is one. At the step when  is finished  is selected. At the step when  is selected no vertex in  is finished (absence of path of length ). At the step when  is finished,  is  finished and also some other vertices in  could possibly be finished. Hereafter, induction can be invoked over  and .  See \FI{fig:serpar2}.

\begin{figure}[h]
\begin{center}
\includegraphics[width=5cm]{fig3a_redraw.pdf}
\vspace*{-.1in}
\caption{Illustration for the first sub-case of Case 3.}
\label{fig:serpar2}
\end{center}
\end{figure} 



\begin{figure}[h]
\begin{center}
\includegraphics[width=5cm]{fig4a_redraw.pdf}
\vspace*{-.1in}
\caption{Illustration for the second sub-case of Case 3.}
\label{fig:serpar3}
\end{center}
\end{figure} 




\noindent \textbf{Second Sub-case:} Now if the distance between  and  is two. Then,  the distance between  and  is one. At the step when  is finished no other vertex in  is finished. At the step when  is selected no vertex in  is finished. At the step when  is finished,  gets selected and  some vertices in  would be finished. Finally, at the step when  is finished some vertices in  could possibly be finished. Hereafter, induction can be invoked over  and .  See \FI{fig:serpar3}.



Therefore, a decomposition of  can be obtained with no more than  finishing at each step. A more precise upper bound of  can be obtained by a more careful analysis. 
\end{proof}

The Properties \ding{172} and \ding{174} are guaranteed by construction.  Property~\ding{173} follows from the fact that  during any step of the above algorithm the set of vertices selected (appearing in the same ) is at most distance two (i.e, two neighborhood away) from some fixed vertex (see the proof of Lemma~\ref{spg}). Since  has no  or , the vertices selected together can't have any edge between themselves (i.e., 's are independent sets).  

The width of this decomposition is  as  vertices are finished in each step by the above algorithm (Lemma~\ref{spg}).


\begin{proposition} \label{prop:4}
Let  be a bounded-degree -free series-parallel graph. Then, there exists an ordered bipartite decomposition of  with bounded width.
\end{proposition}

\subsection{Decomposition of Planar Graphs}
In this section, we prove the decomposition property on planar graphs. Define a \emph{thread} as an induced path in  whose vertices are all of degree  in . A -thread is a thread with  vertices. Let  be a planar graph of girth at least 16. We first prove a structural result on planar graphs. 
\begin{lemma} \label{planare}
Let  be a planar graph of minimum degree  and girth at least , then  always contains a -thread. 
\end{lemma}
\begin{proof}
Assume without loss of generality that the graph  is connected, otherwise it is sufficient to prove the statement for each of the components. Let  be the graph obtained from  by contracting all degree  vertices. Then,  is a planar graph of minimum degree . 

We first show that  contains a face of degree  or less. For contradiction, suppose that all the faces have degree at least . Let  be the number of vertices,  be the number of edges, and  be the number of faces of . Moreover, let  be the set of faces and  the set of vertices of . Since the degree of each face is at least  (where the degree of a face  is the number of edges going around ), . Moreover,  since the minimum degree in  is at least .
By Euler's formula\footnote{It states that in a planar graph with  vertices,   edges, and   faces, .}  and the previous inequalities: . A contradiction.

Let  be a face of  that corresponds to a face of the degree  or less in . Since the degree of  is at least  (the girth is ), it is easy to see that  contains a -thread in .
\end{proof}

In order to define a decomposition, we define a -thread partition  of a planar graph  as a partition of  such that each  satisfies 

By Lemma~\ref{planare} every planar graph with girth at least  has a -thread partition. As earlier, we say, a vertex is selected if we add it to some . Using the -thread partition (which can be constructed using Lemma~\ref{planare}), a decomposition of a planar graph of girth at least  can be constructed by repeating this following simple procedure,
\renewcommand{\labelenumi}{\roman{enumi}.}

\begin{enumerate}
\item Find the largest index  such that  contains a vertex  which has not yet been selected, but is adjacent to an already selected vertex. 
\item Define  and . 
\item Increment . 
\end{enumerate} 


\begin{lemma} \label{planarf}
Let  be a planar graph of girth at least 16. Then, each of the  pair created by the above algorithm satisfies that  and .
\end{lemma}
\begin{proof}

Let  be a -thread partition of .   Let  be the graph induced by   on . The first observation is that a vertex in any  () has at most one edge connecting it to the vertices in . Consider some step  of the decomposition (step  is when the  pair is created). Let  be the largest index with an unselected vertex .  From the previous observation it follows that vertices in  that are in  are not selected, in steps  to . Assume otherwise. Let  be a vertex belonging to  that is  selected in the first  steps. Then,  needs to have a neighbor in , a contradiction since it would imply that  (which is in ) has two neighbors in . Therefore, till step  none of the neighbors of  in  have been selected.  By definition of threads  could have at most two neighbors in . The cases where it has two neighbors are one of the following: (a)  has one neighbor from  and another from , or (b)  has both its neighbors from . This implies that , and .
\end{proof}
The Properties \ding{172} and \ding{174} of the decomposition are again guaranteed by construction. The Property \ding{173} is satisfied because  and the vertices in  are neighbors of , therefore, the vertices in  can not have edges between themselves, otherwise it will result in a cycle of length . Since this holds for every , the 's are independent sets. 

The width of this decomposition is at most  (as  from Lemma~\ref{planarf}).

\begin{proposition} \label{prop:5}
Let  be a bounded-degree planar graph of girth at least . Then, there exists an ordered bipartite decomposition of  with bounded width.
\end{proposition}

\section{Negative Result for Ordered Bipartite Decomposition} \label{neg}
As mentioned earlier only graphs of bounded degree have a chance of having a decomposition of bounded width. So a natural question to ask is whether all bounded-degree graphs with a decomposition have one of bounded width. In this section, we answer this question negatively by showing that every unbounded-length grid graph fails to satisfy this condition.  For simplicity, we will only consider  grid graphs, but our proof techniques extend to other cases as well. 

Let  be a  grid graph with  and . We now show that any decomposition of  has a width of at least .  Let  be any decomposition of .  Consider any  square of  defined by vertices  (in clockwise order).  Assume without loss of generality that the vertex  has the smallest label (given by the decomposition) among vertices , and , and let the label on  be .  The two neighbors  of the vertex  always have the same label . The fourth vertex  has any label  with  and . We define a new graph  on the same set of vertices by putting the edge  into .  Note that all vertices in a connected component  in  have the same label thus need to be chosen together in the decomposition (i.e., all vertices in a connected component  in   appear in the same  in the decomposition). 

Let  be a class of graphs on vertex set  with exactly one diagonal in every  square (and no other edges). That is any graph  from  has for every  with  exactly one of the edges  in  and no other edges are in . Note that . The following theorem shows that any graph  has the property that there is a connected component touching top and bottom or left and right (and therefore  also has this property). Note that (as mentioned before) every connected component in  would have to be chosen together in the decomposition implying that the width of the decomposition is .


\begin{theorem}\label{dis}
Consider any graph .  There exists a connected component of  that contains at least one vertex from every row or at least one vertex from every column in the grid graph.
\end{theorem}
\begin{proof}
Assume  does not have a connected component that contains a vertex of every row. Let  be the subgraph of  generated by all the vertices connected to the top row, i.e.,  is a collection of those connected components in  that have at least one vertex from the top row. By assumption,  does not contain any vertices from the bottom row. 

For every  sub-grid with vertices  and edge , we call  a {\em boundary edge} if exactly one of  is in  and neither of  or  are in . Let  be the subgraph of  where  is the set of boundary edges. We assign the color red to all the vertices in  and color black to all the vertices in . Over the following two claims we make some observations about the structure of . For a vertex , let  indicate whether the vertex is colored red () or black ().

\begin{figure}[t]
\begin{center}  
\epsfig{file=figrp4.eps, scale=.3}
\end{center}
\caption{The figure illustrates the negative result. The dotted diagonal lines are the edges in , and the solid diagonal lines are the edges in . There exists a component in  than spans from the left to right boundary. } 
\label{all}
\end{figure}

\begin{claim}
There are no degree 3 vertices in , i.e., all vertices in  have degree  or .
\end{claim}
\begin{proof}
Assume to the contrary. Let  be a degree 3 black vertex. Let  be the only edges incident on  in . 


By choice, . For the other vertices, there are only two possibilities: (i)  and (ii) .  As all the edges in  are all either between two red vertices or two black vertices and every  sub-grid has exactly one edge,  is black and there exists an edge between  in .  Therefore, every vertex in  has degree either . See \FI{fig:cla1}.
\end{proof}
\begin{figure}[h]
\begin{center}
\includegraphics[width=5cm]{figrp6_redraw.pdf}
\caption{The solid lines are the edges in , whereas the dotted lines at the edges in the grid. If , then the two possibilities of color assignments to other vertices are: (i)  and (ii) .}
\label{fig:cla1}
\end{center}
\end{figure}


As in the previous claim, by considering all possibilities for the neighbors of  being in  or not, one can conclude immediately that all vertices of degree 1 are on the left or right border and there are odd numbers of degree  vertices on each border. 
\begin{claim} \label{cl2}
All the degree 1 vertices of  are either on the left or the right border of the grid graph . Additionally, there is an odd number of degree 1 vertices of  on the left and on the right border. 
\end{claim}

Every connected component in  has an even number of degree  vertices. From Claim~\ref{cl2}, we know that degree  vertices only occur at the left and right boundary of  and there are odd number of them on both boundaries. Putting these two statements together implies that there exists a component in  (therefore, in ) that connects the left and the right border. This finishes the proof of the Theorem~\ref{dis}. See \FI{all} for an illustration.
\end{proof}



\begin{corollary} [Negative Result]
Every decomposition of a  grid graph  has a width of  .
\end{corollary}


\section{Conclusions and Open Problems} \label{sec:concl}
The natural question arising from this work is what other classes of graphs have an ordered bipartite decomposition and more importantly which of them have one of bounded width. Other than the graph classes mentioned above, the bounded-degree -free Halin graphs~\cite{hali} where degree two vertices are allowed and hexagonal grid graphs are some other interesting graph classes which have bounded width decompositions.  Most of the graph classes we considered appear to have small treewidth. So a natural question would be to relate these two decomposition schemes. However, we show in Appendix~\ref{app:treewidth} that the treewidth and the width of an ordered bipartite decomposition are incomparable.

Another interesting problem would be to investigate the general complexity of the ordered bipartite decomposition and possibly characterize its relation to other existing graph decomposition schemas. The notion of bounded width decomposition is a natural sufficient condition for the class of algorithms based on the principle of the Algorithm Count to give almost always an fpras. But the necessary condition for the general approach to work is still unclear.  Finally, a challenging open problem is to obtain any such general result for counting in arbitrary dense graphs. 

\subsection*{Acknowledgments}
We thank Andrzej Ruci\'nski for pointing us to \cite{riordan} and Piotr Berman for simplifying the proofs in Section~\ref{neg}. The authors would also like to thank Sofya Raskhodnikova, Adam Smith, and Martin Tancer for helpful comments and discussions. 

We also thank anonymous referees for pointing out an error in Definition~\ref{def:obd} in an earlier version of this paper.


\begin{thebibliography}{10}

\bibitem{noga1}
{\sc Alon, N., Frieze, A.~M., and Welsh, D.}
\newblock Polynomial time randomized approximation schemes for
  {T}utte-{G}r{\"o}thendieck invariants: The dense case.
\newblock {\em Random Structures \& Algorithms 6}, 4 (1995), 459--478.

\bibitem{zwick}
{\sc Alon, N., R.Yuster, and Zwick, U.}
\newblock Color-coding.
\newblock {\em Journal of the ACM 42}, 4 (1995), 844--856.

\bibitem{app2}
{\sc Artymiuk, P.~J., Bath, P.~A., Grindley, H.~M., Pepperrell, C.~A.,
  Poirrette, A.~R., Rice, D.~W., Thorner, D.~A., Wild, D.~J., Willett, P.,
  Allen, F.~H., and Taylor, R.}
\newblock Similarity searching in databases of three-dimensional molecules and
  macromolecules.
\newblock {\em Journal of Chemical Information and Computer Sciences 32\/}
  (1992), 617--630.

\bibitem{arvind}
{\sc Arvind, V., and Raman, V.}
\newblock Approximation algorithms for some parameterized counting problems.
\newblock In {\em ISAAC\/} (2002), vol.~2518, Springer, pp.~453--464.

\bibitem{ivana}
{\sc Bez{\'a}kov{\'a}, I., Bhatnagar, N., and Vigoda, E.}
\newblock Sampling binary contingency tables with a greedy start.
\newblock In {\em SODA\/} (2006), SIAM, pp.~414--423.

\bibitem{chein}
{\sc Chien, S.}
\newblock A determinant-based algorithm for counting perfect matchings in a
  general graph.
\newblock In {\em SODA\/} (2004), SIAM, pp.~728--735.

\bibitem{diestel}
{\sc Diestel, R.}
\newblock {\em Graph theory}, 2~ed.
\newblock Springer-Verlag, 2000.

\bibitem{app1}
{\sc Dong, H., Wu, Y., and Ding, X.}
\newblock An {ARG} representation for chinese characters and a radical
  extraction based on the representation.
\newblock In {\em International Conference on Pattern Recognition\/} (1988),
  pp.~920--922.

\bibitem{fd}
{\sc Dyer, M., Frieze, A.~M., and Jerrum, M.}
\newblock Approximately counting {Hamilton} paths and cycles in dense graphs.
\newblock {\em SIAM Journal on Computing 27}, 5 (1998), 1262--1272.

\bibitem{erdos}
{\sc Erd{\H{o}}s, P., and R{\'e}nyi, A.}
\newblock On the evolution of random graphs.
\newblock {\em Publ.\ Math.\ Inst.\ Hung.\ Acad.\ Sci.\ 5\/} (1960), 17--61.

\bibitem{grohe}
{\sc Flum, J., and Grohe, M.}
\newblock The parameterized complexity of counting problems.
\newblock {\em SIAM Journal of Computing 33}, 4 (2004), 892--922.

\bibitem{frieze}
{\sc Frieze, A.~M., and Jerrum, M.}
\newblock An analysis of a {M}onte {C}arlo algorithm for estimating the
  permanent.
\newblock {\em Combinatorica 15}, 1 (1995), 67--83.

\bibitem{fm}
{\sc Frieze, A.~M., Jerrum, M., Molloy, M.~K., Robinson, R., and Wormald,
  N.~C.}
\newblock Generating and counting {H}amilton cycles in random regular graphs.
\newblock {\em Journal of Algorithms 21}, 1 (1996), 176--198.

\bibitem{fmc}
{\sc Frieze, A.~M., and McDiarmid, C.}
\newblock Algorithmic theory of random graphs.
\newblock {\em Random Structures \& Algorithms 10}, 1-2 (1997), 5--42.

\bibitem{suen}
{\sc Frieze, A.~M., and Suen, S.}
\newblock Counting the number of {H}amilton cycles in random digraphs.
\newblock {\em Random Structures \& Algorithms 3}, 3 (1992), 235--242.

\bibitem{shiva}
{\sc F{\"u}rer, M., and Kasiviswanathan, S.~P.}
\newblock An almost linear time approximation algorithm for the permanent of a
  random (0-1) matrix.
\newblock In {\em FSTTCS\/} (2004), vol.~3328, Springer, pp.~263--274.

\bibitem{shiva1}
{\sc F{\"u}rer, M., and Kasiviswanathan, S.~P.}
\newblock Approximately counting perfect matchings in general graphs.
\newblock In {\em ALENEX/ANALCO\/} (2005), SIAM, pp.~263--272.

\bibitem{hali}
{\sc Halin, R.}
\newblock Studies on minimally n-connected graph.
\newblock {\em Combinatorial Mathematics and its Applications (Proc. Conf.,
  Oxford, 1969)\/} (1971), 129--136.

\bibitem{hammer}
{\sc Hammersley, J.~M.}
\newblock Existence theorems and {M}onte {C}arlo methods for the monomer-dimer
  problem.
\newblock {\em Research Papers in Statistics\/} (1966), 125--146.

\bibitem{band}
{\sc Heun, V., and Mayr, E.~W.}
\newblock Embedding graphs with bounded treewidth into optimal hypercubes.
\newblock {\em Journal of Algorithms 43}, 1 (2002), 17--50.

\bibitem{jansonr}
{\sc Janson, S., {\L}uczak, T., and Ruci{\'n}ski, A.}
\newblock {\em Random graphs}.
\newblock Wiley-Interscience, 2000.

\bibitem{jer}
{\sc Jerrum, M.}
\newblock {\em Counting, sampling and integrating: algorithms and complexity}.
\newblock Birkh{\"a}user, 2003.

\bibitem{jerrum1}
{\sc Jerrum, M., and Sinclair, A.}
\newblock Approximating the permanent.
\newblock {\em SIAM Journal on Computing 18}, 6 (Dec. 1989), 1149--1178.

\bibitem{ising}
{\sc Jerrum, M., and Sinclair, A.}
\newblock Polynomial-time approximation algorithms for the {Ising} model.
\newblock {\em SIAM Journal on Computing 22}, 5 (1993), 1087--1116.

\bibitem{jsv}
{\sc Jerrum, M., Sinclair, A., and Vigoda, E.}
\newblock A polynomial-time approximation algorithm for the permanent of a
  matrix with nonnegative entries.
\newblock {\em Journal of ACM 51}, 4 (2004), 671--697.

\bibitem{vazirani}
{\sc Jerrum, M., Valiant, L., and Vazirani, V.}
\newblock Random generation of combinatorial structures from a uniform
  distribution.
\newblock {\em Theoretical Computer Science 43\/} (1986), 169--188.

\bibitem{kat}
{\sc Kasteleyn, P.~W.}
\newblock {\em Graph theory and crystal physics ({F}. {H}arary, ed.)}.
\newblock Academic Press, 1967.

\bibitem{knuth}
{\sc Knuth, D.~E.}
\newblock Estimating the efficiency of backtrack programs.
\newblock {\em Mathematics of Computation 29}, 129 (Jan. 1975), 121--136.

\bibitem{app4}
{\sc Levinson, R.}
\newblock Pattern associativity and the retrieval of semantic networks.
\newblock {\em Computers \& Mathematics with Applications 23}, 6--9 (1992),
  573--600.

\bibitem{luks}
{\sc Luks, E.~M.}
\newblock Isomorphism of graphs of bounded valence can be tested in polynomial
  time.
\newblock {\em Journal of Computer and System Sciences 25\/} (1982), 42--65.

\bibitem{ras}
{\sc Rasmussen, L.~E.}
\newblock Approximating the permanent: {A} simple approach.
\newblock {\em Random Structures \& Algorithms 5}, 2 (1994), 349--362.

\bibitem{ras1}
{\sc Rasmussen, L.~E.}
\newblock Approximately counting cliques.
\newblock {\em Random Structures \& Algorithms 11}, 4 (1997), 395--411.

\bibitem{riordan}
{\sc Riordan, O.}
\newblock Spanning subgraphs of random graphs.
\newblock {\em Combinatorics, Probability \& Computing 9}, 2 (2000), 125--148.

\bibitem{piotr}
{\sc Sankowski, P.}
\newblock Alternative algorithms for counting all matchings in graphs.
\newblock In {\em STACS\/} (2003), Springer, pp.~427--438.

\bibitem{app3}
{\sc Stahs, T., and Wahl, F.~M.}
\newblock Recognition of polyhedral objects under perspective views.
\newblock {\em Computers and Artificial Intelligence 11\/} (1992), 155--172.

\bibitem{toda}
{\sc Toda, S.}
\newblock On the computational power of {PP} and {}.
\newblock In {\em FOCS\/} (1989), IEEE, pp.~514--519.

\bibitem{val}
{\sc Valiant, L.~G.}
\newblock The complexity of computing the permanent.
\newblock {\em Theoretical Computer Science 8\/} (1979), 189--201.

\end{thebibliography}


\appendix
\section{Extension to the Disjoint Triangle Case} \label{app:app2}
For simplicity, we will discuss only the case where  is a union of  vertex disjoint triangles (other cases where  is a union of fewer vertex disjoint triangles can be handled similarly). Even though  doesn't have a decomposition, there is a simple fpras for counting copies of  in random graphs. Let  be the vertices in , with every triplet  forming a triangle in  (for ). 

Let  be the output of the Algorithm Embeddings for inputs  and , but where each  and  (even though  is not an ordered bipartite decomposition). As in Proposition~\ref{mainproof}, we will again investigate the ratio  which equals the critical ratio of averages. 

The numerator, 

The last equality follows because after embedding each triangle the subgraph of  into which nothing has been embedded yet is random with the original edge probability . Consider a representative term from this product,  

Here, as earlier, we relied on the fact the graph into which we embed the vertex  is random. Let  and .  Therefore,  denotes the number of ways of embedding the vertex  and  denotes the number of ways of embedding the vertex . Since the number of edges incident on the vertices in  is binomially distributed,  equals 


Let  denote the number of embeddings of a triangle in a random graph from . Then,  the denominator  

Note that . Using the above equalities, the critical ratio of averages can be bounded to 

for a constant . Again, we obtain a polynomial bound on the critical ratio of averages, which translates to an fpras for counting copies of  in .

\section{Ordered Bipartite Decomposition vs.\ Treewidth} \label{app:treewidth}
In this section, we show that the treewidth and the width of an ordered bipartite decomposition are incomparable. In one direction, consider a star graph. Treewidth is 1, but no ordered bipartite decomposition of width less than  exists. For the other direction, we consider the -subdivision graph of a constant-degree expander as explained below. 

Let  be a constant-degree expander graph. Consider the -subdivision graph
 of  . From Proposition~\ref{prop:2},  has an ordered bipartite decomposition of bounded width. So the only fact that remains to be verified is that vertex expansion ratio of  is a constant.

\begin{lemma} \label{expand}
A -subdivision graph of a constant-degree expander is an expander. 
\end{lemma}
\begin{proof}
Let  be a set of vertices in . Let  (= constant) denote the vertex expansion ratio of  and  denote the maximum degree in . Let  denote the -subdivision graph of .  Let  be a subset of vertices from . We consider the vertex expansion ratios for two different scenarios of .  
\begin{itemize}
\item \textbf{Case }. In this case, . 
\item \textbf{Case }. First assume that, . Under this assumption, . Say . Now even if ,  is at least . Therefore,  

\end{itemize} 
The final case to consider involves a set of vertices  in , which are not in . In this case, .

From the above case analysis it is clear that the vertex expansion ratio of  is a constant, and the proof follows.
\end{proof}
 has constant expansion which implies a treewidth ~\cite{band}, whereas  has an ordered bipartite decomposition of bounded width. Therefore, treewidth and the width of an ordered bipartite decomposition are incomparable.
\end{document}
