\documentclass[11pt]{article}
\def\FULL{full}

\usepackage{dsfont}
\usepackage{pstricks,pst-text,pst-node}
\usepackage{amsmath,amssymb}
\usepackage{algorithm,algorithmic}
\usepackage{graphicx}
\usepackage{boxedminipage}
\usepackage{picins}
\usepackage{enumitem}
\usepackage{calc}
\usepackage{ifthen}

\newcommand{\iffull}[1]{\ifthenelse{\equal {\FULL}{full}}{#1}{}}
\newcommand{\ifconf}[1]{\ifthenelse{\equal {\FULL}{full}}{}{#1}}

\newlength{\parcor}

\newlength{\halftw}
\setlength{\halftw}{\textwidth*\real{.55}}

\iffull{
  \usepackage{amsthm}
  \usepackage[letterpaper,margin=2.8cm,centering]{geometry}

  \newtheorem{theorem}{Theorem}
  \newtheorem{lemma}{Lemma}
  \newtheorem{claim}{Claim}
  \newtheorem{corollary}{Corollary}
  \newtheorem{definition}{Definition}
  \newtheorem{proposition}{Proposition}
  \newtheorem{fact}{Fact}
  \newtheorem{example}{Example}

  \setlength{\parcor}{-4ex}
}

\newtheorem{assumption}{Assumption}
\newtheorem{observation}{Observation}

\newcommand{\comment}[1]{\textsl{\small[#1]}\marginpar{\tiny\textsc{To Do!}}}
\newcommand{\ignore}[1]{}
\newcommand{\todo}[1]{\textbf{TO DO:} #1 \bigskip}

\newcommand{\ess}{\ensuremath{\mathcal{S}}}
\newcommand{\su}{\ensuremath{\mathrm{s}}}
\newcommand{\de}{\ensuremath{\mathrm{\pi}}}
\newcommand{\cee}{\ensuremath{\mathcal{C}}}
\newcommand{\fC}{\ensuremath{\mathcal{K}}}
\newcommand{\R}{\ensuremath{\mathcal{R}}}
\newcommand{\calF}{\ensuremath{\mathcal{F}}}
\newcommand{\Sm}{\ensuremath{\mathcal{S}}}
\newcommand{\La}{\ensuremath{\mathcal{L}}}
\newcommand{\C}{\ensuremath{\mathcal{C}}}
\newcommand{\M}{\ensuremath{\mathcal{M}}}
\newcommand{\PP}{\ensuremath{\mathcal{P}}}
\newcommand{\opt}{\ensuremath{\mathtt{opt}}}
\newcommand{\OPT}{\ensuremath{\mathtt{OPT}}}
\newcommand{\NP}{\ensuremath{\text{NP}}}
\newcommand{\IP}{\ensuremath{\text{P}}}
\newcommand{\IR}{\mathbb{R}}
\newcommand{\IN}{\mathbb{N}}
\newcommand{\IZ}{\mathbb{Z}}
\newcommand{\cov}[1]{\ensuremath{\mathtt{Cov}(#1)}}
\newcommand{\bb}{\ensuremath{\bar{b}}}
\newcommand{\bA}{\ensuremath{\bar{A}}}
\newcommand{\bs}{\ensuremath{\bar{s}}}
\newcommand{\bx}{\ensuremath{\bar{x}}}
\newcommand{\hx}{\ensuremath{\hat{x}}}
\newcommand{\val}{\ensuremath{\mathrm{val}}}
\newcommand{\1}{\mathbb{1}}
\newcommand{\Sup}[1]{\ensuremath{#1|_{01}}}
\def\ni{\noindent}
\def\xint{x^{\tt int}}




\begin{document}

\title{On Column-restricted and Priority Covering Integer Programs \thanks{
    Supported by NSERC grant no. 288340 and by an Early Research
    Award. Emails: {\tt deeparnab@gmail.com, elyot@uwaterloo.ca, jochen@uwaterloo.ca}}}


\author{
  Deeparnab Chakrabarty
  \and
  Elyot Grant 
  \and
 Jochen K{\"o}nemann 
}

\ifconf{
  \institute{Department of Combinatorics and Optimization \\
    University of Waterloo, Waterloo, ON, Canada N2L 3G1}}
\iffull{
  \date{University of Waterloo, Waterloo, ON, Canada N2L 3G1}
}

\maketitle

\begin{abstract}
  In a column-restricted covering integer program (CCIP), all the
  non-zero entries of any column of the constraint matrix are
  equal. Such programs capture capacitated versions of covering
  problems. In this paper, we study the approximability of CCIPs, in
  particular, their relation to the integrality gaps of the underlying
  0,1-CIP.

  \hspace{5mm} If the underlying 0,1-CIP has an integrality gap
  , and assuming that the integrality gap of the {\em
    priority version} of the 0,1-CIP is , we give a factor
   approximation algorithm for the CCIP. Priority
  versions of 0,1-CIPs (PCIPs) naturally capture {\em quality of
    service} type constraints in a covering problem.

  \hspace{5mm} We investigate priority versions of the line (PLC) and
  the (rooted) tree cover (PTC) problems.  Apart from being natural
  objects to study, these problems fall in a class of fundamental
  geometric covering problems. We bound the integrality of certain
  classes of this PCIP by a constant.  Algorithmically, we give a
  polytime exact algorithm for PLC, show that the PTC problem is
  APX-hard, and give a factor -approximation algorithm for it.



\iffalse
In a 0,1-covering integer program (CIP), the goal is to pick a minimum cost
subset of columns of a 0,1-matrix such that for every row,
the total number of 's in the row among the picked columns is at least
a specified {\em demand} of the row. In the {\em capacitated} version of the problem,
each column has an associated {\em supply}, and in a feasible solution, for 
every row the total supply in the row among the picked columns is at least
the specified demand. The corresponding covering integer program is called
the {\em column-restricted covering integer program} (CCIP) since
its constraint matrix has the special property that all non-zeros in 
any given column are equal to the column's supply.

\hspace{5mm} From an approximation algorithms point of view, CCIPs are not as well
understood as their 0,1 counterparts. 
Our main result connects the approximability of a CCIP with two natural
related 0,1-CIPs. The first is the underlying original 0,1-CIP obtained by setting all 
supplies of columns to . The second is a priority version of the 0,1-CIP 
in which every column and row are assigned priorities. A column now covers a row
iff it covers the row in the original 0,1-CIP, and
the column's priority exceeds that of the row's.
We show that a strengthening of the natural 
LP relaxation for the CCIP has integrality gap at most 
if the two 0,1-CIPs have gap  and , 
respectively.

\hspace{5mm} Priority versions of CIPs naturally capture {\em quality of service}
type constraints in a covering problem. We study the priority versions
of the line (PLC) and the (rooted) tree cover (PTC) problems. Apart
from being natural objects to study, these problems fall in a class
of fundamental geometric covering problems. We make progress in
understanding the integrality gaps of the corresponding
PCIPs. Algorithmically, we give a polytime exact algorithm for PLC,
show that the PTC problem is APX-hard, and give a factor
-approximation algorithm for it.
\fi
\end{abstract}




\section{Introduction}
In a {\em 0,1-covering integer program} (0,1-CIP, in short), we are
given a constraint matrix , demands , non-negative costs , and upper bounds , and the goal is to solve the following integer linear
program (which we denote by \cov{A,b,c,d}).



Problems that can be expressed as 0,1-CIPs are essentially equivalent
to set multi-cover problems, where sets correspond to columns and
elements correspond to rows.  This directly implies that 0,1-CIPs are
rather well understood in terms of approximability: the class admits
efficient  approximation algorithms and this is best
possible unless .  Nevertheless, in many cases one can get
better approximations by exploiting the structure of matrix .  For
example, it is well known that whenever  is {\em totally
  unimodular} (TU)(e.g., see \cite{Sc03}), the canonical LP relaxation
of a 0,1-CIP is integral; hence, the existence of efficient algorithms
for solving linear programs immediately yields fast exact algorithms
for such 0,1-CIPs as well.

While a number of general techniques have been developed for obtaining
improved approximation algorithms for structured -CIPs, not much is known
for structured non- CIP instances. In this paper, we attempt to
mitigate this problem, by studying the class of {\em column-restricted
  covering integer programs} (CCIPs), where all the non-zero entries 
  of any column of the constraint matrix are equal. Such CIPs arise
  naturally out of -CIPs, and the main focus of this paper 
  is to understand how the structure of the underlying 0,1-CIP can be used 
  to derive improved approximation algorithms for CCIPs.
  \\

\noindent
 {\bf Column-Restricted Covering IPs (CCIPs):}  
Given a 0,1-covering problem \cov{A,b,c,d} and a supply vector
, the corresponding CCIP is obtained as follows. Let
 be the matrix obtained by replacing all the 's in the th
column by ; that is,  for all . The column-restricted covering problem is given 
by the following integer program.


\noindent
CCIPs naturally capture {\em capacitated} versions of 0,1-covering 
problems. To illustrate this we use the following 0,1-covering problem
called the tree covering problem.
The input is a tree
  rooted at a vertex , a set of {\em segments} ,
  non-negative costs  for all , and demands  for all . An edge  is contained in a segment
   if  lies on the unique -path in .  The goal is
  to find a minimum-cost subset  of segments such that each edge  is contained in at least  segments of .  When 
  is just a line, we call the above problem, the {\em line cover} (LC)
  problem.  In this example, the constraint matrix  has a row for
  each edge of the tree and a column for each segment in . 
  It is not too hard to show that this matrix is TU and thus these can be solved exactly
  in polynomial time.
  

In the above tree cover problem, suppose each segment
 also has a capacity supply  associated with it, and
call an edge  covered by a collection of segments  iff the total
supply of the segments containing  exceeds the demand of . 
The problem of finding the minimum cost subset of segments covering 
every edge is precisely the column-restricted tree cover problem. The column-restricted 
line cover problem encodes the minimum knapsack problem and is thus 
NP-hard. \\
 
\noindent
For general CIPs, the best known approximation algorithm, due to
Kolliopoulos and Young~\cite{KY05}, has a performance guarantee of
, where , called the {\em dilation} of the instance,
denotes the maximum number of non-zero entries in any column of
the constraint matrix. Nothing better is known for the special case of CCIPs
unless one aims for {\em bicriteria} results where solutions 
violate the upper bound constraints  (see Section \ref{sec:rel-work} for more details). 

In this paper, our main aim is to understand how the approximability
of a given CCIP instance is determined by the structure of the
underlying -CIP. In particular, if a -CIP has a constant
integrality gap, under what circumstances can one get constant factor
approximation for the corresponding CCIP?  We make
some steps toward finding an answer to this question.



In our main result, we show that there is a constant factor
approximation algorithm for CCIP if {\em two} induced -CIPs have
constant integrality gap.  The first is the underlying original
0,1-CIP.  The second is a {\em priority} version of the 0,1-CIP (PCIP, in
short), whose constraint matrix is derived from that of the 0,1-CIP
as follows. \\

\noindent
{\bf Priority versions of Covering IPs (PCIPs):}
Given a 0,1-covering problem \cov{A,b,c,d}, a priority supply
vector , and a priority demand vector ,
the corresponding PCIP is as follows. Define  to be the
following 0,1 matrix

Thus, a column  covers row , only if its priority supply is
higher than the priority demand of row .  The priority covering
problem is now as follows.


We believe that priority covering problems are interesting in their
own right, and they arise quite naturally in covering applications
where one wants to model {\em quality of service} (QoS) or priority
restrictions. For instance,  in the tree cover problem
defined above,
suppose each segment  has a {\em quality of
  service} (QoS) or priority supply  associated with it and suppose each edge
 has a QoS or priority demand  associated with it. We say that a segment
 covers  iff  contains  {\em and} the priority supply of 
exceeds the priority demand of . The goal is to find a minimum cost
subset of segments that covers every edge. This is the priority tree cover problem.







Besides being a natural covering problem to study, we show that the
priority tree cover problem is a special case of a classical geometric
covering problem: that of finding a minimum cost cover of points by
axis-parallel rectangles in  dimensions.  Finding a constant factor
approximation algorithm for this problem, even when the rectangles
have uniform cost, is a long standing open problem. 


We show that although the tree cover is polynomial time solvable, the priority
tree cover problem is APX-hard. 
We complement this with a factor  approximation for
the problem. Furthermore, we present constant upper bounds for
the integrality gap of this PCIP in a number of special cases, implying
constant upper bounds on the corresponding CCIPs in these special cases.
We refer the reader to Section \ref{sec:tech} for a formal statement of our results,
which we give after summarizing works related to our paper.

\iffalse
\vspace{-2mm}
\subsection{Preliminaries}
Given a 0,1-CIP \cov{A,b,c,d}, we obtain its {\em canonical LP
  relaxation} by removing the integrality constraint.  The {\em
  integrality gap} of the CIP is defined as the supremum of the ratio
of optimal IP value to optimal LP value, taken over all non-negative 
integral vectors , and . The integrality gap of an IP
captures how much the integrality constraint affects the optimum, and
is an indicator of the {\em strength} of a linear programming
formulation. We now define CCIPs and PCIPs formally. 

\vspace{-3mm}
\paragraph{Column-Restricted Covering IPs (CCIPs)}  
In the tree cover problem, suppose each segment
 also has a capacity supply  associated with it, and
call an edge  covered by a collection of segments  iff the total
supply of the segments containing  exceeds the demand of . This
is the column-restricted tree cover problem. Observe that if one
considers the constraint matrix of this capacitated problem, then in
any column corresponding to a segment  each entry is either
 or . 

Given a 0,1-covering problem \cov{A,b,c,d} and a supply vector
, the corresponding CCIP is obtained as follows. Let
 be the matrix obtained by replacing all the 's in the th
column by ; that is,  for all . The column-restricted covering problem is given 
by the following integer program.



\vspace{-3mm}
\paragraph{Priority versions of Covering IPs (PCIPs)}
In the tree cover problem, suppose each segment  has a {\em quality of
  service} (QoS) or priority supply  associated with it and suppose each edge
 has a QoS or priority demand  associated with it. We say that a segment
 covers  iff  contains  {\em and} the priority supply of 
exceeds the priority demand of . The goal is to find a minimum cost
subset of segments that covers every edge. This is the priority tree cover problem.
We remark that the
demand vector for the priority problem is the all 's vector; one
could modify the definition with a more general demand vector, but
this definition suffices for our purposes.

In general, the PCIP of a covering problem is obtained as follows.
Given a 0,1-covering problem \cov{A,b,c,d}, a priority supply
vector , and a priority demand vector ,
the corresponding PCIP is as follows. Define  to be the
following 0,1 matrix

Thus, a column  covers row , only if its priority supply is
higher than the priority demand of row .  The priority covering
problem is now as follows.

Note that we do not need the upper bounds here since no  will be
greater than  in any minimal solution.  We define the integrality
gap of PCIP as the supremum, taken over all integral choices of  and
, of the ratio of the optimum value of
 to its canonical LP relaxation.
\fi

\subsection{Related work}\label{sec:rel-work}

There is a rich and long line of work
(\cite{Do82,Ho82,RV93,Sr99,Sr06}) on approximation algorithms for
CIPs, of which we state the most relevant to our work.  Assuming no
upper bounds on the variables, Srinivasan \cite{Sr99} gave a -approximation to the problem (where  is the
dilation as before).  Later on, Kolliopoulos and Young \cite{KY05}
obtained the same approximation factor, respecting the upper
bounds. However, these algorithms didn't give any better results when
special structure of the constraint matrix was known.  On the hardness
side, Trevisan~\cite{Tr01} showed that it is NP-hard to obtain a
-approximation algorithm even for
0,1-CIPs.

The most relevant work to this paper is that of Kolliopoulos
\cite{Ko03}. The author studies CCIPs which satisfy a 
rather strong assumption, called the {\em no bottleneck
  assumption}, that the supply of any column is smaller than the
demand of any row. Kolliopoulos \cite{Ko03} shows that 
 if one is allowed to
violate the upper bounds by a multiplicative constant, then the
integrality gap of the CCIP is within a constant factor of that of the
original 0,1-CIP\footnote{Such a result is implicit in the paper;
  the author only states a  integrality gap.}. As the
author notes such a violation is necessary; otherwise the CCIP has
unbounded integrality gap. If one is not allowed to violated upper
bounds, nothing better than the result of \cite{KY05} is known for
the special case of CCIPs. 

 Our work on CCIPs parallels a large body of work on column-restricted
 {\em packing} integer programs (CPIPs). Assuming the {\em
   no-bottleneck assumption}, Kolliopoulos and Stein \cite{KS04} show
 that CPIPs can be approximated asymptotically as well as the
 corresponding 0,1-PIPs. Chekuri et al.~\cite{CMS07} subsequently
 improve the constants in the result from \cite{KS04}. These results
 imply constant factor approximations for the column-restricted tree
 {\em packing} problem under the no-bottleneck assumption. Without the
 no-bottleneck assumption, however, only polylogarithmic approximation
 is known for the problem \cite{CEK09}.

The only work on priority versions of covering problems that we are
aware of is due to Charikar, Naor and Schieber~\cite{CNS04} who
studied the priority Steiner tree and forest problems in the context of QoS
management in a network multicasting application.  Charikar et
al. present a -approximation algorithm for the problem, and
Chuzhoy et al.~\cite{CG+08} later show that no efficient  approximation algorithm can exist unless  ( is the number of vertices).

To the best of our knowledge, the column-restricted or priority
versions of the line and tree cover problem have not been studied. The
best known approximation algorithm known for both is the 
factor implied by the results of \cite{KY05} stated above. However,
upon completion of our work, Nitish Korula \cite{Ko09} pointed out to
us that a -approximation for column-restricted line cover is
implicit in a result of Bar-Noy et al. \cite{BarNoy}.  We remark that
their algorithm is not LP-based, although our general result on CCIPs
is.

\subsection{Technical Contributions and Formal Statement of Results}\label{sec:tech}
\noindent
Given a 0,1-CIP \cov{A,b,c,d}, we obtain its {\em canonical LP
  relaxation} by removing the integrality constraint.  The {\em
  integrality gap} of the CIP is defined as the supremum of the ratio
of optimal IP value to optimal LP value, taken over all non-negative 
integral vectors , and . The integrality gap of an IP
captures how much the integrality constraint affects the optimum, and
is an indicator of the {\em strength} of a linear programming
formulation.  \\

\noindent
{\bf CCIPs: }
Suppose the CCIP is \cov{A[s],b,c,d}.
We make the following two assumptions about the integrality gaps 
of the 0,1 covering programs, both the original 0,1-CIP and the 
priority version of the 0,1-CIP.

\begin{assumption}\label{as:1}
  The integrality gap of the original 0,1-CIP is . Specifically, for any non-negative integral vectors
  , and , if the canonical LP
  relaxation to the CIP has a fractional solution , then one can
  find in polynomial time an integral feasible solution to the CIP of
  cost at most . We stress here that the entries
  of  could be  as well as .
\end{assumption}

\begin{assumption}\label{as:2}
  The integrality gap of the PCIP is .  Specifically,
  for any non-negative integral vectors , if the canonical LP
  relaxation to the PCIP has a fractional solution , then one can
  find in polynomial time, an integral feasible solution to the PCIP
  of cost at most .
\end{assumption}

We give an LP-based approximation algorithm for solving CCIPs.  Since
the canonical LP relaxation of a CCIP can have unbounded integrality
gap, we strengthen it by adding a set of valid constraints called the
{\em knapsack cover constraints}.  We show that the integrality gap of
this strengthened LP is , and can be used to give
a polynomial time approximation algorithm.

\begin{theorem}\label{thm:1}
  Under Assumptions \ref{as:1} and \ref{as:2}, there is a
  -approximation algorithm for column-restricted
  CIPs. 
\end{theorem}

Knapsack cover constraints to strengthen LP relaxations were
introduced in \cite{B75,HJP75,Wo75}; Carr et al. \cite{CF+00} were the
first to employ them in the design approximation algorithms. The paper
of Kolliopoulos and Young \cite{KY05} also use these to get their
result on general CIPs.

The main technique in the design of algorithms for column-restricted
problems is {\em grouping-and-scaling} developed by Kolliopoulos and
Stein \cite{KS01,KS04} for packing problems, and later used by
Kolliopoulos \cite{Ko03} in the covering context.  In this technique,
the {\em columns} of the matrix are divided into groups of `close-by'
supply values; in a single group, the supply values are then scaled to
be the same; for a single group, the integrality gap of the original
0,1-CIP is invoked to get an integral solution for that group; the
final solution is a `union' of the solutions over all groups.

There are two issues in applying the technique to the new strengthened
LP relaxation of our problem.  Firstly, although the original
constraint matrix is column-restricted, the new constraint matrix with
the knapsack cover constraints is not.  Secondly, unless additional
assumptions are made, the current grouping-and-scaling analysis
doesn't give a handle on the degree of violation of the upper bound
constraints. This is the reason why Kolliopoulos \cite{Ko03} needs the
strong no-bottleneck assumption.

We get around the first difficulty by grouping the {\em rows} as well,
into those that get most of their coverage from columns not affected
by the knapsack constraints, and the remainder. On the first group of
rows, we apply a subtle modification to the vanilla
grouping-and-scaling analysis and obtain a 
approximate feasible solution satisfying these rows; we then show that
one can treat the remainder of the rows as a PCIP and get a
 approximate feasible solution satisfying them, using
Assumption 2. Combining the two gives the  factor.
The full details are given in Section 2.

We stress here that apart from the integrality gap
assumptions on the 0,1-CIPs, we do not make any other assumption
(like the no-bottleneck assumption). In fact, we can use the modified
analysis of the grouping-and-scaling technique to get a similar result
as \cite{Ko03} for approximating CCIPs violating the upper-bound
constraints, under a {\em weaker} assumption than the no-bottleneck
assumption. The no-bottleneck assumption states that the
supply of {\em any} column is less than the demand of {\em any} row.
In particular, even though a column has entry  on a certain row,
its supply needs to be less than the demand of that row. We show that
if we weaken the no-bottleneck assumption to assuming that the supply
of a column  is less than the demand of any row  only if
 is positive, a similar result can be obtained via our modified analysis.


\begin{theorem}\label{thm:2}
  Under assumption \ref{as:1} and assuming , for
  all , given a fractional solution  to the canonical LP
  relaxation of \cov{A[s],b,c,d}, one can find an integral solution
   whose cost  and .
\end{theorem}

\paragraph{Priority Covering Problems.}
In the following, we use PLC and PTC to refer to the priority versions
of the line cover and tree cover problems, respectively. 
Recall that the constraint matrices for line and tree cover problems
are totally unimodular, and the integrality of the corresponding 
0,1-covering problems is therefore  in both case. It is
interesting to note that the 0,1-coefficient matrices for PLC and 
PTC are not totally unimodular in general. 
The following integrality gap bound is obtained via a primal-dual
algorithm.

\begin{theorem}\label{thm:plc-gap}
  The canonical LP for priority line cover has an integrality gap of at least  and 
  at most .
\end{theorem}

In the case of tree cover, we obtain constant upper bounds on
the integrality gap for the case , that is, for the
minimum cardinality version of the problem.  We believe that the PCIP
for the tree cover problem with general costs also has a constant
integrality gap.  On the negative side, we can show an integrality gap
of at least .

\begin{theorem}\label{thm:ptc-gap}
  The canonical LP for {\em unweighted} PTC has an integrality gap of
  at most .
\end{theorem}

We obtain the upper bound by taking a given PTC instance and a
fractional solution to its canonical LP, and decomposing it into a
collection of PLC instances with corresponding fractional solutions,
with the following two properties. First, the total cost of the
fractional solutions of the PLC instances is within a constant of the
cost of the fractional solution of the PTC instance. Second, union of
integral solutions to the PLC instances gives an integral solution to
the PTC instance. The upper bound follows from Theorem
\ref{thm:plc-gap}.  Using Theorem \ref{thm:1}, we get the following as
an immediate corollary.

\begin{corollary}
  There are -approximation algorithms for column-restricted line
  cover and the cardinality version of the column-restricted tree
  cover.
\end{corollary}

We also obtain the following combinatorial results.

\begin{theorem}\label{thm:plc-exact}
  There is a polynomial-time exact algorithm for PLC.
\end{theorem}

\begin{theorem}\label{thm:ptc-hard}
  PTC is APX-hard, even when all the costs are unit.
\end{theorem}

\begin{theorem}\label{thm:ptc-apx}
  There is an efficient -approximation algorithm for 
  PTC. 
\end{theorem}

The algorithm for PLC is a non-trivial dynamic programming approach
that makes use of various structural observations about the optimal
solution.  The approximation algorithm for PTC is obtained via a
similar decomposition used to prove Theorem \ref{thm:ptc-gap}.

We end by noting some interesting connections between the priority
tree covering problem and set covering problems in computational
geometry. The {\em rectangle cover} problem in -dimensions is the
following: given a collection of points  in , 
and a collection  of axis-parallel rectangles with
costs, find a minimum cost collection of rectangles that covers every
point. We believe studying the PTC problem
could give new insights into the rectangle cover problem.

\begin{theorem}\label{thm:ptc-geom}
The priority tree covering problem is a special case of the rectangle cover problem in -dimensions.
\end{theorem}

\ifconf{Due to space restrictions, we omit many proofs. A full version of the paper 
is available \cite{CGK-full}.}


\section{General Framework for Column Restricted CIPs}
\label{sec:ccip}

In this section we prove Theorem \ref{thm:1}.
Our goal is to round a solution to a LP relaxation of 
\cov{A[s],b,c,d} into an approximate integral solution.  We strengthen the following
canonical LP relaxation of the CCIP

by adding valid {\em knapsack cover} constraints. 
In the following we use \C\ for the set of columns and \R\
for the set of rows of .

\subsection{Strengthening the canonical LP Relaxation}

Let  be a subset of the columns in the column restricted
CIP \cov{A[s],b,c,d}.  For all rows , define

to be the residual demand of row  w.r.t. . Define matrix  by letting

for all  and for all . 
The following {\em Knapsack-Cover} (KC) inequality 

is valid for the set of all integer solutions  for
.  Adding the set of all KC inequalities yields the
following stronger LP formulation CIP. We note that the LP is not column-restricted, in
that, different values appear on the same column of the new constraint matrix.


\ni It is not known whether \eqref{lp} can be solved in polynomial
time.  For , call a vector  -relaxed if
its cost is at most , and if it satisfies \eqref{kc} for . An -relaxed solution
to \eqref{lp} can be computed efficiently for any . To see
this note that one can check whether a candidate solution satisfies
\eqref{kc} for a set ; we are done if it does, and otherwise we
have found an inequality of \eqref{lp} that is violated, and we can
make progress via the ellipsoid method. Details can be found in
\cite{CF+00} and \cite{KY05}.

We fix an , specifying its precise value later.
Compute an -relaxed
solution,  , for \eqref{lp}, and let . Define  as,
 if , and , otherwise.
Since  is an -relaxed solution, we get that  is
a feasible fractional solution to the {\em residual} CIP,
\cov{A^F[s],b^F,c,\alpha d}. In the next subsection, our goal will be
to obtain an {\em integral} feasible solution to the covering problem
\cov{A^F[s],b^F,c,d} using . The next lemma shows how this
implies an approximation to our original CIP.

\def\xint{x^{\tt int}}
\begin{lemma} \label{lem:res}
 	If there exists an integral feasible solution, , to \cov{A^F[s],b^F,c,d}  with , then there
	exists a -factor approximation to \cov{A[s],b,c,d}.
\end{lemma}
\iffull{
\begin{proof}
Define 

Observe that . 
 is a feasible integral solution to  \cov{A[s],b,c,d} since for any ,

where the first inequality follows from the definition of  and since , the second inequality follows since 
 is a feasible solution to  \cov{A^F[s],b^F,c,d}. 

\ni
Furthermore, 
 
where the first inequality follows from the definition of  and the second from the assumption in the theorem statement.
\end{proof}
}
\subsection{Solving the Residual Problem}
In this section we use a feasible fractional solution  of \cov{A^F[s],b^F,c,\alpha d}, to obtain an {\em integral} feasible solution  to  the covering problem \cov{A^F[s],b^F,c,d}, with  for . Fix . \\

\noindent
{\bf \em Converting to Powers of . } 
For ease of exposition, we first modify the input to the residual problem \cov{A^F[s],b^F,c,d} so that all entries of are powers of . For every , let  denote the smallest power of  larger than .
For every column , let  denote the largest power of  smaller than .

\begin{lemma} \label{lem:yfeas}
   is feasible for \cov{A^F[\bs],\bb,c,4\alpha d}.
\end{lemma}
\iffull{
\begin{proof}
  Focus on row . We have
  
  where the first inequality uses the fact that  for
  all , the second inequality uses the fact that \bx\ is
  feasible for
  \cov{A^F[s],b^F,c,\alpha d}, and the third follows from the definition of . 
\end{proof}
}
\noindent
{\bf \em Partitioning the rows. } 
We call  the residual demand of row . For a row , a column  is {\em -large} if the supply of 
is at least the residual demand of row ; it is {\em -small} otherwise. Formally,

Recall the definition from \eqref{eq:defAf}, .
Therefore,  for all  since ; 
and  for all , since being powers of , 
 implies, . 

We now partition the rows into large and small depending on which columns
most of their coverage comes from. Formally, call a row  {\em large} if

and small otherwise. Note that Lemma \ref{lem:yfeas} together with the
fact that each column in row 's support is either small or large implies,

Let  and  be the set of large and small rows. 

\def\xints{x^{{\tt int},\Sm}}
\def\xintl{x^{{\tt int},\La}}
In the following, we address small and large rows separately. We
compute a pair of integral solutions  and  that are
feasible for the small and large rows, respectively. We then obtain
 by letting

for all . 

\subsubsection{Small rows.} 
For these rows we use the grouping-and-scaling technique a la
\cite{CMS07,Ko03,KS01,KS04}.  However, as mentioned in the
introduction, we use a modified analysis that bypasses the
no-bottleneck assumptions made by earlier works.

\begin{lemma}\label{lem:small-rows}
We can find an integral solution  such that \\
\indent
a)  for all , \\ \indent
b) , and \\ \indent
c) for every  small row , .
\end{lemma}
\begin{proof} 
\iffull{
The complete proof is slightly technical and hence we start with a sketch.}
\ifconf{(Sketch)} 
Since the rows are small, for any row , we can zero out the entries 
that are larger than , and still  will be a feasible solution. 
Note that, now in each row, the entries are , and thus are at most
 (everything being powers of ). We stress that it could be that  
of some row is less than the entry in some other row, that is, we don't have the 
no-bottleneck assumption. However, when a particular row  is fixed,  is 
at least any entry of the matrix in the th row. 
Our modified analysis of grouping and scaling then makes the proof go through.

We {\em group} the columns into classes that have  as the same power of ,
and for each row  we let  be the contribution of the class  columns 
towards the demand of row . The columns of class , the small rows, and the 
demands  form a CIP where all non-zero entries of the matrix are the same
power of . We scale both the constraint matrix and   down by that 
power of  to get a 0,1-CIP, and using assumption 1, we get an integral solution
to this 0,1-CIP. Our final integral solution is obtained by concatenating all these integral 
solutions over all classes. 

Till now the algorithm is the standard grouping-and-scaling algorithm.
The difference  lies in our analysis  in proving that this integral solution is feasible for the original 
CCIP. Originally the no-bottleneck assumption was used to prove this. However, we
show since the column values in different classes 
are geometrically decreasing, the weaker assumption of  being
at least any entry in the th row is enough to make the analysis 
go through. \ifconf{This completes the sketch of the proof.} \iffull{We now get into the full proof.\\

\vspace*{\parcor}
\paragraph{Step 1: Grouping the columns.}

Let  and  be the smallest and largest supply among 
the columns in . Since all  are powers of , we introduce the shorthand,  for the supply .
We say that a column  is in {\em class} ,
if , and we let 

be the set of class  supplies.  \\

\vspace*{\parcor}
\paragraph{Step 2: Disregarding -large columns of a small row .}

Fix a small row . We now identify the columns  that are -small.
To do so, define . Observe that any column  in class  
for  are -small. This is because .
Define 

as the contribution of the class , -small columns to the demand of row , multiplied by .
Note that by definition of small rows, these columns contribute to more than  of the demand, and so

Henceforth, we will consider only the contributions of the small -columns of a small row .\\

\vspace*{\parcor}
\paragraph{Step 3: Scaling and getting the integral solution.}

Fix a class  of columns and scale down by  to get a -constraint matrix.
(Recall entries of the columns in a class  are all .)
This will enable us to apply assumption  and get a integral solution corresponding to these columns.
The final integral solution will be the concatenation of the integral solutions over the various classes.

The constants in the next claim are carefully chosen for the calculations to work out later.

\begin{claim} \label{claim:s1}
  For any  and for all , . 
\end{claim}
\begin{proof}
  The claim is trivially true for rows  with  as  in this
  case. Consider a row  with .
  Since any column  is -small, we get . 
  Using the definition of , we
  obtain
  
  Dividing both sides by  and taking the floor on the right-hand side yields the claim.
\end{proof}

Since  and  is a feasible solution to 
\cov{A^F[s],b^F,c,d/24}, we get that  for all . Thus, the above
claim shows that  is a feasible fractional solution for
\cov{A^{(t)},\lfloor 3\bb^{(t)}/\bs^{(t)}\rfloor,c^{(t)},d^{(t)}}, where 
 is the submatrix of  defined by the columns in , and 
 and  are the sub-vectors of  and , respectively, that are induced by
. Using Assumption \ref{as:1}, we therefore conclude that there is an integral vector 
such that 


We obtain integral solution  by letting  if .
Thus  for all , and we get, 


\ni
Thus we have established parts (a) and (b) of the lemma.
It remains to show that  is feasible for the set of small rows. \\

\vspace*{\parcor}
\paragraph{Step 4: Putting them all together: scaling back.}

Once again, fix a small row . The following inequality takes only contribution of the -small columns.
We later show this suffices.

The first inequality follows since  for
-small columns, the equality follows from the definition
of , and the final inequality uses the fact that  for . The following claim along with
\eqref{eq:feas} proves feasibility of row .  This is the part where
our analysis slightly differs from the standard grouping-and-scaling
analysis.

\begin{claim}
For any small row , 

\end{claim}
\begin{proof}
In this proof, the choice of the constant  on the right-hand side
of the inequality in Claim \ref {claim:s1} will become clear. Let 

be the set of -small classes  whose fractional supply
 is small compared to its integral supply . 
We now show that for any small row , the columns in the classes not in  
suffice to satisfy its demand. 
Note that

which follows from the definition of . Furthermore, from \eqref{eq:bbisum} we know that for a small row,
. Also, since  form a geometric series, we get that 
. Putting this in \eqref{eq:1} we get

where the final equality follows from the definition of  which implies that . 

Moreover, for , we know that  since
 if .  Therefore, using inequality
\eqref{hx-feas} in \eqref{eq:feas}, we get

where the second-last inequality uses \eqref{eq:si}, and the last uses the definition of . This completes the proof of the lemma.
\end{proof} }
\end{proof}


\subsubsection{Large rows.}
The large rows can be showed to be a PCIP problem and thus Assumption 2 can be invoked to get
an analogous lemma to Lemma \ref{lem:small-rows}.
\begin{lemma}\label{lem:large-rows}
We can find an integral solution  such that \\
\indent
a)  for all , \\ \indent
b) , and \\ \indent
c) for every  large row , .
\end{lemma}
\iffull{
\begin{proof}
Let  be a large row, and recall that  is the set of -large columns in \C. We have

and hence 


Let  be the minor of  induced by the large rows. Consider the
priority cover problem \cov{A^\R[\bs,\bb],\mathds{1},c}. From the
definition of , it follows  is a feasible fractional
solution to the priority cover problem.

Using Assumption \ref{as:2}, we conclude that there is an 
integral solution  such that ,
and  , for all large rows .

Fix a large row .  Since   for all -large columns , we get

This completes the proof of the lemma.
\end{proof}

\ni
{\bf Proof of Theorem \ref{thm:1}}
Let  and  be as satisfying the conditions of Lemma \ref{lem:small-rows} and \ref{lem:large-rows}, respectively. Define  as
. We have\\

\noindent
a)  since both  and . \\

\noindent
b) For any row ,  since the inequality is true with  replaced by  for small rows, and 
 by  for large rows. \\

\noindent
c) . \\

\ni
Thus,  is a feasible integral solution to  with cost bounded as . Noting that , the proof of the theorem follows from Lemma \ref{lem:res}. .
}
\ifconf{
Define   as  for all ; using the previous two lemmas and Lemma \ref{lem:res}, this integral solution proves Theorem \ref{thm:1}.
}

\iffull{
\subsection{CCIPs with violation of upper-bounds: Proof of Theorem \ref{thm:2}}
In this section we prove Theorem \ref{thm:2} that we restate here. In the proof, we will indicate how
we modify the analysis of grouping-and-scaling that allows us to replace the no-bottleneck assumption
with a weaker one.
\begin{theorem}(Theorem \ref{thm:2})
Under assumption \ref{as:1} and assuming , for all , given a fractional solution  to 
the canonical LP relaxation of \cov{A[s],b,c,d}, one can find an integral solution  whose cost 
 and .
\end{theorem}
\begin{proof}
\def\xint{x^{\tt int}}
\def\tplus{2^{-(t+1)}s_{max}}
\def\t{2^{-t}s_{max}}
\def\Aij{A_{ij}}
Let  be a feasible solution to . We construct an integral solution  such that  and .
Let  and  be the largest and smallest 's.\\

\noindent
{\bf \em Grouping:}
Let  for 
where .  Let . Note that . Let , that
is,  is the smallest non-zero entry of the th row of  in
the columns of .  Note that . Let  be
the largest entry of row . The assumption 
implies
. \\

\ni
\def\s{\hat{s}}
{\bf \em Scaling:}
Let  be a vector with  for ,  elsewhere. Note that 
and  for any .
Let  be a vector with  for ,  otherwise. Since for all , , for all rows  we have 

\ni
Therefore since , we get

\ni If we define an integral vector  to be , we see that .
Using assumption \ref{as:1},  there exists an integral solution  such that , and , and . \\

\ni
{\bf \em Scaling back:}  Now fix a row , and look at 

where the first inequality follows 
since  is the minimum entry in the th row in the columns of . This is where our analysis slightly differs
from the previous analyses of grouping and scaling, where instead of multiplying the RHS by , the RHS was multiplied
by . This subtle observation leads us to make a weaker assumption than the no-bottleneck assumption. \\


\def\zint{z^{\bf int}}
\ni
{\bf \em Getting the final integral solution:} \\
Define . Note that 
and . \\

\ni
Fix a row  and look at the th entry of .

\ni
Let . Note that 

the second inequality following from Claim \ref{claim:m} below. This gives us


For , we have the floor in the inequality \eqref{eq:app1} at least 1. So we can use the relation  for . Thus, using ,
we have



\begin{claim}\label{claim:m}
. 
\end{claim}
\begin{proof}
Note that the non-zero  decreases as  goes from  to . Also, for any , we have  and . Thus, . Since the largest  can be at most , 
. 
\end{proof}\end{proof}
}
\section{Priority line cover}
\label{sec:plc}

\ifconf{ In this extended abstract, we show that the integrality gap
  of the canonical linear programming relaxation of PLC is at most
  .  Subsequently, we sketch an exact combinatorial algorithm for
  the problem.  } 

\iffull{ We first show that the integrality gap of
  the canonical linear programming relaxation of PLC is at least 
  and at most . Subsequently, we present an exact combinatorial
  algorithm for the problem.  }

\subsection{Canonical LP relaxation: Integrality gap}
We start with the canonical LP relaxation for PLC and its dual in Figure \ref{fig:PD}.
\begin{figure}[h]
  \begin{minipage}{\halftw}  \end{minipage}
  \hfill \vline \hfill
  \begin{minipage}{\halftw} \end{minipage}
  \caption{\small The PLC canonical LP relaxation and its
dual.}\label{fig:PD} \end{figure}

\iffull{
The following example shows that the integrality gap of
\eqref{lp:primal} is at least .

\begin{example}
  {\em Figure \ref{fig:1} shows a line of odd length ; odd numbered
  edges have demand , and even numbered edges have a demand of
  . Paths are shown as lines above the line graph, and are also
  numbered. Odd numbered paths have a supply of , and even numbered
  ones have a supply of . Dashed lines indicate edges spanned but
  not covered.  All paths have cost . Note that a fractional
  solution is obtained by letting  for paths  and , and
   otherwise.  The cost of this solution is , while
  the best integral solutions takes all odd-numbered paths, and has
  cost . As  tends to , the ratio between the
  integral and fractional optimum tends to . As an aside, we
  found the above integrality gap instance by translating a known
  integrality-gap instance of the tree-augmentation problem in
  caterpillar graphs; see \cite{CK+08}.}

 \begin{figure}[h]
    \begin{center}
      \includegraphics[scale=0.8]{gap-tlc}
      \label{fig:1}  \caption{Integrality Gap for PLC}
    \end{center}
  \end{figure}
\end{example}

\noindent
We now show that the integrality gap of the canonical LP for PLC is bounded by . 
We describe a simple primal-dual algorithm that constructs a
feasible line cover solution and a feasible dual solution, and the
cost of the former is at most twice the value of the dual solution. 

The algorithm maintains a set of segments .  Call an edge  {\em
  unsatisfied} if no segment in  covers . Let  be the set of
unsatisfied edges.  Initially  is the empty set and .  We
grow duals  on certain edges, as specified below. We let 
denote the edges with positive ; we call such edges, {\em
  positive} edges. Initially  is empty.  Call a segment  {\em
  tight} if .
We use the terminology an edge  is larger than , if . \\

\vspace{2mm}
\hspace{-6mm}
\begin{boxedminipage}{\textwidth}
{\bf Primal-Dual Algorithm} 
\begin{enumerate}
\item While  is not empty do
\begin{itemize}
	\item Breaking ties arbitrarily, pick the largest edge  in .
	\item Increase  till some segment becomes tight. Note
          that each such segment must contain . Let  and
           be the tight segments that have the smallest
          left-end-point and the largest right-end-point,
          respectively. Since  is chosen to be the largest
          uncovered edge, any unsatisfied edge contained in 
          the two segments 
          or  is also covered.  We say 
          is responsible for  and .
	
	Add  to . Add  to .
	Remove all the unsatisfied edges contained in either  or  from .
\end{itemize}

\item {\bf Reverse Delete:} Scan the segments  in  in the
  reverse order in which they were added, and delete  if its
  deletion doesn't lead to uncovered edges.
\end{enumerate}
\end{boxedminipage}

\vspace{4mm}
\noindent
It is clear that the final set  is feasible. It is also clear that
 forms a feasible dual.  The factor -approximation follows from
the following lemma by a standard relaxed complementary slackness
argument, and this finishes the proof of Theorem \ref{thm:plc-gap}.
\begin{lemma}\label{lem:atmost2}
  Any edge  is covered by at most two segments in .
\end{lemma}

\begin{proof}
  Suppose there is an edge  covered by three segments
   and .  Observe that one of the segments, say ,
  must be completely contained in .  Since  is not
  deleted from , there must be an edge  such that 
  is the only segment in  covering . Since  and  don't
  cover , but one of them, say  contains it, this implies
  . That is,  is larger than .

  If  is the edge responsible for , then since  contains
  ,  wouldn't be in . Since  is larger than , there
  must be a segment  in  added before  that covers . In
  the reverse delete order,  is processed before .  This
  contradicts that  is the only segment in  covering .
\end{proof}

\begin{lemma}
  .
\end{lemma}
\begin{proof}
  Since each  satisfies , we get
  
\end{proof}
}
\ifconf{
We use the terminology an edge  is larger than , if . 
The algorithm maintains a set of segments  initially empty.  Call an edge  {\em
  unsatisfied} if no segment in  covers  and let  be the set of
unsatisfied edges. The algorithm picks the largest edge in  and raises the dual 
value  till some segments becomes tight. The segments with the farthest left-end point
and the farthest right-end point are picked in , and all edges contained in any of them 
are removed from . Note that since we choose the largest in , all such edges are covered.
The algorithm repeats this process till  becomes , that is,
all edges are covered. The final set of segments is obtained by a reverse delete step, where a segment
is deleted if its deletion doesn't make any edge uncovered.

The algorithm is a factor  approximation algorithm. To show this it suffices 
by a standard argument for analysing primal-dual algorithms, that any edge 
with a positive dual  is contained in at most two segments in . 
These two segments correspond to the left-most and the right-most segments 
that cover ; it is not too hard to show if something else covers , then either
 has zero dual, or the third segment is removed in the reverse delete step.
}
\subsection{An Exact Algorithm for PLC}
\iffull{
We first describe the sketch of the algorithm; the full proof starts
from Section \ref{sec:vms}.}
\ifconf{We sketch the exact algorithm for PLC.}
 A segment  covers only a subset of
edges it contains. We call a contiguous interval of edges covered by
, a {\em valley} of . The uncovered edges form {\em
  mountains}. Thus a segment can be thought of as forming a series of
valleys and mountains.

Given a solution  to the PLC (or even a PTC)
instance, we say that segment  is {\em needed} for edge  if
 is the unique segment in  that covers . We let 
be the set of edges that need segment . 
We say a solution is {\em
  valley-minimal} if it satisfies the following two properties: (a) If
a segment  is needed for edge  that lies in the valley  of
, then no higher supply segment of  intersects this valley ,
and (b) every segment  is needed for its last and first edges.  We
show that an optimum solution can be assumed to be valley-minimal, and
thus it suffices to find the minimum cost valley-minimal solution.

The crucial observation follows from properties (a) and (b) above.
The valley-minimality of solution  implies that there is a unique
segment  that covers the first edge of the line. At a very
high level, we may now use  to decompose the given instance into a
set of {\em smaller} instances.  For this we first observe that each
of the remaining segments in  is either fully
contained in the strict interior of segment , or it is disjoint
from , and lies to the right of it.  The set of all segments that
are disjoint from  form a feasible solution for the smaller PLC
instance induced by the portion of the original line instance to the
right of . On the other hand, we show how to reduce the problem of
finding an optimal solution for the part of the line contained in 
to a single shortest-path computation in an auxiliary digraph.  Each
of the arcs in this digraph once again corresponds to a smaller
sub-instance of the original PLC instance, and its cost is that of its
optimal solution. The algorithm follows by dynamic programming.
\iffull{
\subsubsection{Valley-Minimal Solutions}\label{sec:vms}
As mentioned above, it helps to think of supplies and demands as {\em
  heights}. In the case of PLC, the demands of the edges in  form a
terrain, and each segment  corresponds to a straight line
at height . Segment  then covers edge  if  lies in the
segment's {\em shadow}, that is, the height of  is smaller than the
height of the segment.

\begin{figure}[h]
\begin{center}
 \includegraphics[scale=0.8]{terrain}
\end{center}
\caption{\label{fig:terr} The figure shows a segment , and the terrain
  induced by the edges of  that it contains. The terrain partitions
   into valleys and mountains. Valleys are indicated by solid parts of
  , and mountains are shown as dashed lines.}
\end{figure}

Figure \ref{fig:terr} illustrates this with path  and its edges. The light
gray terrain indicates the demands of the edges. The segment  shown
in the picture covers the edges in  that lie in its shadow;
e.g.,  covers edge  but not . The terrain partitions
 naturally into {\em valleys} -- contiguous sub-intervals of
 that are in the shadow of , and {\em mountains} -- those
sub-intervals that are contained in  and consist entirely of
edges that are not covered by . The parts of  that correspond to
mountains are indicated by dashed lines, and valleys are depicted by
solid lines. In the following, we let  be the interval
corresponding to the th valley of .

In the following, we will assume that the set of segments \ess\ in the
given PLC/PTC instance is {\em segment-complete}; i.e., if \ess\
contains the segment  then it also contains all proper
sub-segments. For example, if a PLC instance contains segment 
corresponding to interval , then it also contains segments
corresponding to intervals  for all . This assumption is w.l.o.g. as we can always add a {\em dummy}
sub-segment  for any such interval  with the same supply
and cost as . Any minimal solution clearly uses at most one of 
and , and if  is used, then replacing it with  does not
affect feasibility.

Let  be an inclusion-wise minimal solution for the given 
instance, and let  be any one of its segments. We say that  is
{\em needed} for edge  if  covers , and if there is no
other segment in  that covers ; let  be the set of edges that 
need , and hence  for all . Thus, if
 is needed for , then  is in one of 's valleys; we let 
be that valley. 

A solution  is {\em
  valley-minimal} if 
\begin{itemize}
\item[ {[M1]} ] for all  and for all , no
  segment of higher supply in  covers any of the edges in
  , and
  \item[ {[M2]} ]  each segment is needed for its first and 
    last edge.
\end{itemize}


We obtain the following observation.

\begin{lemma}
  Given a feasible instance of PLC/PTC, there exists an optimum feasible
  solution that is valley-minimal.
\end{lemma}
\begin{proof}
  First, it is not too hard to see that we can always obtain an optimal 
  solution that satisfies [M2]. If  is an optimum solution with a 
  segment , and  is not needed for its first or last edge ,
  then we may clearly replace  by the sub-segment . This 
  does not increase the solutions cost, using the segment-completeness.
  
  Assume, for the sake of contradiction that  violates [M1]. 
For a solution , say that 
 is a {\em violating triple} if ,  has higher supply than  ,  is
needed for , and  covers some edge in . 
  Choose a solution  with the smallest number of violating triples and
  let  be one such triple. Since  is needed for , edge
   is not contained in , and hence  is either fully
  contained in the interval  or fully contained in the interval
  .  Using the segment-completeness assumption, we may replace
   by the sub-segment  obtained by removing the prefix
  consisting of edges in ; remove  if it is empty. The
  resulting set of segments has cost at most that of , and the
  number of violating triples is smaller; a contradiction.
\end{proof}

In the next subsection, we show how we can compute the minimum cost
valley-minimal solution for PLC instances in polynomial time using
dynamic programming.

\subsubsection{Computing valley-minimal solutions}

Given , we obtain the sub-instance {\em
  induced} by interval  by restricting the line  to this
interval, and by keeping only segments that are fully contained in
.  Observe that the valley-completeness assumption implies that
any such sub-instance is feasible.  We begin by making a crucial
observation that will allow us to decompose a given PLC instance into
{\em smaller} instances.  Let  be a valley-minimal solution for the
sub-instance induced by , and note that [M2] implies that 
contains a unique segment  that covers the first edge .
Suppose that  is the set of edges
within  that need segment . Abusing notation slightly, we
let  be the valley of  around edge ;
thus we clearly have

Note that segment  may have valleys that entirely consist of 
edges that do not need ; accordingly, such valleys are not 
part of the list on the right-hand side of \eqref{eq:vdec}. 
Using property [M2], however, we may assume that
  and  are the first and last valley, 
respectively, of segment .
We obtain the following observation,  where we let . 

\begin{observation}\label{obs:part}
  We may assume,
  for all , if  contains ,
  then  is fully contained in . 
\end{observation}
\begin{proof}
  Consider first a segment  with supply bigger than .
  In this case [M1] implies that  must have an empty intersection with
  the valleys , and the observation
  follows.

  On the other hand if segment  has supply at most , then
  since  must be needed for some edge ,  must not contain
   implying  must have its right end-point in
  . Replacing  by its intersection with 
  completes the observation.
\end{proof}

We now let  be a minimum cost valley-minimal feasible
solution for the sub-instance induced by interval , and we let
 be its cost. Clearly,  consists of the
minimum cost segment in \ess\ that covers edge , and 
is the optimum solution we want to obtain. Suppose that we know
 for all . The high level idea is the
following. The algorithm guesses the first segment  in
. Suppose that  is the rightmost edge covered
by .  Observation \ref{obs:part} allows us to partition the
remaining segments in  into two parts:
\begin{description}
  \item[Part 1] Segments that contain edges in . None of these 
    segments can contain any of the edges in  by the observation.
  \item[Part 2] Segments that contain edges in . Once again,
    the observation implies that such segments must be fully
    contained in .
\end{description}
The first part's solution is obtained since it
is a smaller subproblem, the second part is obtained via a
shortest-path computation.  We now elaborate and give the complete
algorithm.


\begin{figure}[t]
\begin{center}
  \includegraphics[scale=0.8]{gi}
\end{center}
\caption{\label{fig:gi} The part of digraph  corresponding to segment
  .}
\end{figure}

Let  be the segments in \ess\ with leftmost endpoint .  We
construct a digraph  as follows.  Consider a segment , and let

be the set of its valleys. We add a node  for each valley  of  to . We also add an arc
 for all .
A shortest path corresponding to the solution  will use arc
 if 
\begin{itemize}
\item[(i)]  is the leftmost segment in , and
\item[(ii)]  and  are two consecutive valleys 
  of  that contain edges that need . 
\end{itemize}
Observation \ref{obs:part} then states that  uses segments 
that are entirely contained in  to cover .
An optimum set of such segments is given by ,
and we therefore give arc  cost .
Figure \ref{fig:gi} shows the part of  for the segment  from 
Figure \ref{fig:terr}.

We add a source node  and arcs  of cost
 for each of the segments . A shortest path uses
such an arc if  is the unique segment starting at  in the
corresponding optimum solution. 
We also add a sink node  and add an arc  for all 
of cost  indicating the optimum PLC for the sub-interval .
Note that if , then this arc is a loop of cost  and can be discarded.

It follows from the above construction that  is equal to
the cost of a shortest -path in .  Each of the
shortest-path computations can clearly be done in polynomial time, and
hence  can be obtained via dynamic programming, in
polynomial time.  This yields the following restatement of 
Theorem \ref{thm:plc-exact}.

\begin{theorem}
  The cost  of an optimum solution for a given PLC instance
  can be computed in polynomial time.
\end{theorem}
}
\section{Priority tree cover}
\label{sec:ptc}
\ifconf{
In this extended abstract, we sketch a factor  approximation for the PTC problem, and show how the PTC problem is a special case of the  dimensional 
rectangle cover problem. For the APX hardness and the integrality gap of the unweighted PTC LP, we refer the reader to the full version.
}
\iffull{
We first give a proof of Theorem \ref{thm:ptc-hard}, and show
that rooted PTC is APX-hard, even if all segments have unit
cost. Subsequently, we present a -approximation algorithm for the
problem, by reducing it to an auxiliary instance of the tree
augmentation problem. Then, we prove Theorem \ref{thm:ptc-gap},
and show that the integrality gap of the canonical LP formulation 
of unweighted PTC is bounded by . Finally, we prove the connection
between PTC and the rectangle cover problem.

\subsection{APX-hardness}
We prove APX-hardness of PTC via a reduction from the minimum vertex cover problem in bounded degree graphs. The latter problem is known to be APX-hard \cite{BK98}.
Given a bounded degree graph ,
with  vertices and  edges, let the edges be arbitrarily numbered . 

The tree in our instance has a broom structure: it has a {\em handle} which is a path of  edges  given by vertices 
, and it has  {\em bristles} where each bristle corresponds to a particular vertex  and is a path of length . The edge  in the handle for , corresponds to the edge numbered  in the graph .
The bristle corresponding to vertex  is a path  given by the vertices .  
The root of the tree is , the end point of the handle.
Thus the tree has  edges.

We now describe the priority demands of these tree edges.
The demand of edge  is .
Consider the edges in  incident on  in the decreasing order of their numbers. Suppose they are . 
The demands of the edge  is . Thus, for a particular bristle corresponding to a vertex , the demands decrease as we go from  to , and these demands correspond to the numbers of edges incident on .

Now we describe the segments. All segments have unit cost.
We have two kinds of segments: edge segments and vertex segments. For every edge  in , there are two edge segments  and . Segments  
contains all edges  to  and edges  to , 
where edge  is the th edge in the descending order of neighbors of  in . The supply of segment  is , and thus by construction, we see that  only spans edge  and . That completes the description of edge segments.
For every vertex , there is a vertex segment  that covers all the edges in the bristle corresponding to vertex . 
That completes the description of the PTC instance. 
Look at figure \ref{fig:red} for an illustration of the reduction.

\begin{figure}
  \begin{center}
    \includegraphics[scale=.8]{apx.eps}
  \end{center}
  \caption{\label{fig:red} (i) shows an instance of
    the vertex cover problem, and (ii) is the
    corresponding PTC instance. The numbers on the edges are the
    priority demands corresponding to the edge numbers in the
    graph. Figure (ii) also shows two 
    segments:  and , having supplies  and 
    respectively.  Dashed line means that these segments do not have
    enough supply to cover the edges.}
\end{figure}

The following lemma along with the APX-hardness of the vertex cover
problem in bounded degree graphs, and the fact that in the latter any
vertex cover is of size , leads to the APX-hardness of the
PTC problem.

\begin{lemma}
The optimum PTC of the above instance is , where  is the size of the optimum vertex cover of .
\end{lemma}
\begin{proof}
  Firstly note that we may assume that in any optimal PTC, for any
  edge , we will have exactly one of  or  in
  the solution. We need to have one since these are the only two
  segments that cover edge  in the tree. Instead of picking
  both, we can remove one, say , from the solution and pick the
  corresponding vertex segment  instead, at no increase of
  cost. Therefore, there are exactly  edge segments picked in any
  optimal PTC solution.

  Now note that these  edge segments uniquely correspond to an
  orientation of the edges in ; if for edge ,  is
  chosen in the solution, the edge  is oriented from  to
  .  In this orientation, if there is a {\em sink} (a vertex with
  all edges incident to it) , then note that all the edges in the
  bristle corresponding to  have also been covered. Thus, the
  number of vertex segments required to cover the remaining edges of
  the tree, is precisely the number of {\em non-sinks} in this
  orientation. In particular, the optimal PTC corresponds to the
  orientation that minimizes the number of non-sinks.

  The proof is complete by noting that non-sinks form a vertex cover;
  this is because each edge is oriented away from some non-sink, and
  is thus incident to it. Furthermore, given a vertex cover, there
  exists an orientation with precisely these vertices as
  non-sinks. Orient the edges towards the complement of the vertex
  cover (the independent set) - the complement is precisely the set of
  sinks, and thus the vertex cover is precisely the set of non-sinks.
\end{proof}

\begin{proof}[Proof of Theorem \ref{thm:ptc-hard}]
  Suppose the degrees of  are all , a constant.  Note that the
  vertex cover of this graph is at least .  The
  APX-hardness implies that it is NP-hard to distinguish between the
  case when the vertex cover is  or  where  are certain constants.

  The above lemma therefore implies it is NP-hard to distinguish
  between the cases when the optimum of a PTC is  and when the optimum is . Since
   are constants, we get the APX-hardness.

  (For the interested reader: the APX-hardness of vertex cover of
  bounded degree graphs by Berman and Karpinski \cite{BK98} gives
  ,  and , showing it is NP-hard to
  approximate to a factor better than .)
\end{proof}
}

\subsection{An approximation algorithm for PTC}
\ifconf{
We use the exact algorithm for PLC to get the factor  algorithm for PTC.
The crucial idea is the following.  Given an optimum
solution , we can partition the edge-set  of 
into disjoint sets  , and partition two copies of  into ,
such that  is a  path in  for each ,
and  is a priority line cover for the path . 
Using this, we describe the -approximation algorithm which proves Theorem~\ref{thm:ptc-apx}. \\

\ni
{\em Proof of Theorem \ref{thm:ptc-apx}:}
For any two vertices  (top) and  (bottom) of the tree , such that  is an ancestor of , let  be the unique path from  to . Note that , together with the restrictions of the segments in \ess  to , defines an instance of PLC. Therefore, for each pair  and , we can compute the optimal solution to the corresponding PLC instance using the exact algorithm; let the cost of this solution be . Create an instance of the 0,1-tree cover problem with  and segments 
 with costs .
Solve the 0,1-tree cover instance exactly (recall we are in the rooted version) and for the segments  in  returned, return the solution of the corresponding PLC instance of cost .

One now uses the decomposition above to obtain a solution to the 0,1-tree cover problem  of cost at most  times the cost of . This proves the theorem. The segments in  picked are precisely the segments 
corresponding to paths ,  and each  is a solution to the PLC instance. Since we find the optimum PLC, there is a solution to  with costs  of cost less than total cost of segments in . But that cost is at most twice the cost of  since each segment of  is in at most two 's.
}
\iffull{
The crucial idea is the following.  Given an optimum solution
, we can partition the edge-set  of  into
disjoint sets , and partition two copies of 
into , such that  is a path in  for each ,
and  is a priority line cover for the path . Once again, we assume
without loss of generality that the instance is segment-complete.

In particular, we prove the following lemma. Let  be
the set of edges  such that  is the segment with the highest
supply, among all segments in  that cover .  Note that the
union of all , over all , partitions
. Also note that for each edge , there is a unique segment 
such that . 
If there were two, we could replace one of the segments by a sub-segment and still stay feasible.
We call the segment  {\em
  responsible} for .

\begin{lemma}\label{lem:ptc-apx}
  Given an optimal solution  to a PTC
  instance with tree , there is a partition
  
  where each  is the edge set of a path in  such that for all ,
  
  for at most two .
\end{lemma}

Using this, we describe the -approximation algorithm which proves Theorem~\ref{thm:ptc-apx}. \\

\begin{proof}[Proof of Theorem \ref{thm:ptc-apx}]
  For any two vertices  (top) and  (bottom) of the tree ,
  such that  is an ancestor of , let  be the unique path
  from  to . Note that , together with the restrictions
  of the segments in \ess to , defines an instance of
  PLC. Therefore, for each pair  and , we can compute the
  optimal solution to the corresponding PLC instance; let the cost of
  this solution be . Create an instance of the 0,1-tree cover
  problem with  and segments  with costs .  Solve the 0,1-tree cover
  instance exactly (recall we are in the rooted version) and for the
  segments  in  returned, return the solution of the
  corresponding PLC instance of cost .
  We now use Lemma \ref{lem:ptc-apx} to obtain a solution to the
  0,1-tree cover problem  of cost at most  times the
  cost of . This will prove the theorem. 

For each , let  and  be the end points of  with 
 being the ancestor of . Since 's partition the edges,
the segments  is a feasible 0,1-tree cover for .
Define  to be
  the set of segments responsible for the edges in . By
  definition,  is a PLC for . Thus, the cost of the segments in 
 is at least . Furthermore, Lemma \ref{lem:ptc-apx}
implies that the total cost of the segments in  is at most twice
the cost of segments in . Therefore, the cost of the feasible
solution to the cover problem in  is at most twice the cost 
of segments in .

\end{proof}

\begin{proof}[Proof of Lemma \ref{lem:ptc-apx}]
  We give an algorithm to compute the decomposition. Let  be 
  any of the edges incident to the root of , and let 
  be the highest-supply segment covering . We then let 
  be the edges of the path in  corresponding to . Removing
   from  yields sub-trees . For each
  tree  we repeat the above steps, and let 
  
  be the final partition; let  be the segment 
  corresponding to edge-set . Note that for ,
   is empty. This is because 
is a subset of edges which are not in .

  Consider a segment , and let  be 
  smallest such that , and
  assume that  for some
  ; choose  smallest with this property. We
  claim that , 
 and hence for all
   we have .
Thus,  has non-empty intersection only with 
 and .


  Let , and let  be
  two edges in different parts of the partition such that  is responsible for both. 
  As both  and  are edges on , and since 
  , it follows that  is a descendant of  in tree .
  Let  be the topmost edge of ; clearly,  is on the
  -path in . By the decomposition algorithm, segment  is
  the highest-supply
  segment covering edge . As  contains , this means 
  that the supply of  is at least that of . Finally, since  is 
  on ,  covers  as well. But this means that 
   as  is responsible for .
\end{proof}

\subsection{Canonical LP relaxation of PTC: Integrality Gap}

In this section, we prove Theorem \ref{thm:ptc-gap}, by showing that 
the canonical LP relaxation of unweighted PTC is at most . 
Recall the PTC LP.


\begin{proof}[Proof of Theorem \ref{thm:ptc-gap}]
  The idea of the proof is the following: as in the factor
  -approximation for PTC, we decompose the edge set of the tree
  into disjoint sets , such that each  induces a
  path.  We will abuse notation and refer to the 's as paths.
  Furthermore, we take any feasible solution  of
  \eqref{lp:primal-ptc} and obtain  fractional solutions
   such that  is 
  a feasible
  fractional solution to \eqref{lp:primal} for the PLC instance on the
  path . We will guarantee that
  
  The theorem then follows from Theorem \ref{thm:plc-gap}.
  
  \piccaptioninside
  \piccaption{\label{fig:frag} The figure shows a fragment , its
   parent , and two children  and . The segments
    , and  are local for , and segment  is
    global. In particular,  is an -global segment.}


  \parpic(7cm,8cm)[fr]{
   \includegraphics[scale=.85]{frag}}

  Unlike in the argument used in the previous section where the
  decomposition into paths depended on , the decomposition into
  disjoint paths that we use here is universal.  Each path  will
  end at a unique leaf, and  in \eqref{eq:part} will now be the
  number of leaves of . Let  be {\em any} path from the root
  to a leaf. Delete  from the tree to get a series of sub-trees.
  Recursively, obtain  to . We call a path  a {\em
    child} of , if the starting point of  lies on .

  Let  be any feasible fractional solution of \eqref{lp:primal-ptc}
  and let  be the support of , that is, .  Fix a path  and say that a segment  {\em
    intersects}  if  covers an edge in  
A segment  that intersects  is called {\em local} for 
  if either the first or the last edge covered by  lies in .
  A segment  that intersects  is called {\em global} for
  , otherwise. Figure \ref{fig:frag} illustrates this.

  Let  be a global segment for , and let  be the
  first edge contained in  {\em after} .  If , we
  call  an {\em -global} segment. Observe that  is a child
  of .  Thus an -global segment {\em enters}  and {\em
    exits} via .  Note that -global segments, over all  such that  is a child of ,
  partition all global segments for . Also note that an
  -global segment could also be a -global segment for some
  other .

  Now we are ready to define the fractional solution  that
  will be feasible for \eqref{lp:primal} for the PLC instance on
  .  Firstly for all segments  that are local for , let
  . Next, we take care of segments that are global
  for .  For each child  of , order all the -global
  segments in non-increasing order of supply: .
  Let  be such that
  
  If no such  exists, then .  Define 
  for . If , then let .

\begin{claim}
   is feasible for \eqref{lp:primal} for the PLC instance on .
\end{claim}
\begin{proof}
  Pick any edge . Look at all segments  that
  cover . These segments are either local for  or global for
  . If  is local, there is a corresponding segment in the
  support  of the same value. Furthermore for any ,
  
  In any case,  is covered by  at least to the extent it
  is covered by , which implies  is feasible.
\end{proof}

\begin{lemma}
  
\end{lemma}

\begin{proof}
  Each segment  is local for at most two paths  and
  . Thus the contribution to the LHS by local segments for some
  path  is exactly .

  Furthermore, for every parent-child pair  and  that
  induces an -global segment for , we increase the LHS by at
  most . The number of such pairs is at most the number of leaves
  in . 
   The proof is complete by noting that  is at least the number of leaves in .
\end{proof}

To complete the proof of the theorem, note that from Theorem
\ref{thm:plc-gap} we know there exists for each , a set of segments
 such that . The union of
all such  forms a valid PTC of cardinality at most .
\end{proof}
}
\subsection{Priority Tree Cover and Geometric Covering Problems}
\ifconf{
We sketch  how the PTC problem can be encoded as a rectangle cover problem.
To do so, an auxiliary problem is defined, which we call -PLC. \\

\vspace{-2mm}
\ni
{\bf -Priority Line Cover (2-PLC)} The input is similar to PLC, except each segment and edge has now 
an ordered pair of priorities, and a segment covers an edge it contains iff each of the priorities of the segment
exceeds the corresponding priority of the edge. The goal, as in PLC, is to find a minimum cost cover.

It is not too hard to show 2-PLC is a special case of rectangle cover. The edges correspond to points
in 3 dimension and segments correspond to rectangles in -dimension;
dimensions encoded by the linear coordinates on the line, and the two priority values.
In general, -PLC can be shown to be a special case of -dimensional rectangle cover. 

What is more involved is to show PTC is a special case of 2-PLC. To do so, we run two DFS orderings on the 
tree, where the order in which children of a node are visited is completely opposite in the two DFS orderings.
The first ordering gives the order in which these edges must be placed on a line. The second gives one of the 
priorities for the edges. The second priority of the edges comes from the original priority in PTC. It can be shown
that the segments priorities can be so set that the feasible solutions are precisely the same in both the instances
proving Theorem \ref{thm:ptc-geom}.
}
\iffull{
In this section, we show that the PTC problem is a special case of covering a set 
of points in -dimension by axis-parallel rectangles (cuboids). In particular we prove 
Theorem \ref{thm:ptc-geom}. We go in two steps. We first define a problem, that we 
call -Priority Line Cover and show that the PTC problem is a special case of -PLC. Subsequently,
we show -PLC is a special case of -dimensional rectangle cover.
We start with a definition of -PLC. \\

\noindent
{\bf -Priority Line Cover (2-PLC).} The input is  a line , and a collection of segments 
 with costs  for each . Furthermore, each segment 
has a priority supply vector in {\em two} dimensions, denoted as , and each edge  
has a priority demand vector in two dimensions, denoted as . A segment  
covers  iff  contains  and  for both . The goal is to find the minimum
cost collection of segments that cover every edge. \\

\noindent
It is easy to see that PLC is a special case of -PLC. Somewhat surprisingly, PTC is a special case 
of -PLC as well.

\begin{lemma}
Any instance of PTC can be encoded as an instance of 2-PLC with the same solution set.
\end{lemma}
\begin{proof}
Given a rooted tree , we perform two different depth first traversals
to get two different orderings on the edges . One such ordering will define the line
of the 2-PLC instance, the other will define the first coordinates of the priority demand vectors 
of the edges.

In a depth first traversal of a tree, at every step we move from a vertex to one of its children, if any.
Our two different traversals will be defined by two different choices of moving to a child-vertex.
For every vertex  of the tree, consider a total order  on its children. One such order that is convenient
to keep in mind is the following; given a drawing of the tree, the total order of the children is from left to right.
Let  be the {\em opposite} total order. The two depth first traversals are obtained by running 
with 's and 's, respectively. Figure \ref{fig:illus-dfs} illustrates the two orders 
with the ordering  at every vertex  being from left-to-right, and  being from
right-to-left.

\begin{figure}[h]
    \begin{center}
      \includegraphics[scale=0.55]{illus-dfs}
      \caption{The left most tree is the original tree, the second and third are the two depth first traversals. The line below
      shows the line in the 2-PLC instance.}
      \label{fig:illus-dfs}
    \end{center}
\end{figure}

  Let the two traversals return orderings  and  on the
  edges of the tree. The crucial observation is the following: for any
  vertex , let  be the children in the 
  order; then , and
  thus, .

  Now we are ready to describe the 2-PLC instance. The line is defined
  by the edges of the tree ordered w.r.t. .  That is, the order
  of the edges is  such that .  The priority demand vector of an edge  of
  the tree is . Consider a segment  such
  that  is a descendant of  in the PTC instance. We identify two
  specific tree edges contained in : the parent-edge
   of , and the edge  between node  and its 
  unique child  that is on the -path in .
  By the depth-first property, we get .
  The corresponding segment in the 2-PLC instance, also denoted as
  , contains all the edges from  to . The
  priority supply vector of  is .

\begin{claim}
  For any segment , the set of edges covered by  in the 2-PLC
  instance is precisely the set of edges covered in the PTC instance.
\end{claim}
\begin{proof}
  Let  be an edge covered by  in the PTC instance. Since  is
  contained in the path from  to  in the tree, by property of
  depth first traversals we get,  and .  The first pair of
  inequalities implies  lies in the segment  in the 2-PLC
  instance, the second implies that . Since  is
  covered by  in the PTC, we also get . Thus,  is covered by  in the 2-PLC instance.

  Let  be an edge covered by  in the 2-PLC instance. Since 
  lies in , we conclude . This
  implies either (a)  lies on the path from  to  in the tree,
  or, (b) there is a node  on the -path in the tree, and a
  child  of  that is not on this path such that  is contained
  in the subtree defined by edge . 
  
  Note, that in case (b) the depth-first traversal for order 
  visits edge  {\em before} edge . This implies that 
  the second dfs traversal for order 
  visits  {\em after} . Since  is visited before
   in both traversals, we must therefore have
  , and this implies  which is impossible since  covers . Thus, case (b)
  is not possible, and  lies on the path fro  to  on the
  tree.  Furthermore, we have , and so
   covers  in the PTC instance as well. 
\end{proof}  
\end{proof}

Now we show that -PLC is a special case of -dimensional
rectangle cover. This is not to hard to see.  We assume the edges of
the line are numbered . For edge  numbered ,
we associate a point in  dimensions with coordinates
. For each segment , we have a
rectangle associated.  In fact, these rectangles have are unbounded in
the negative  and  coordinates. The other  bounding
half-spaces are , ,  and . It is not too hard to see a rectangle corresponding to a
segment  contains a point corresponding to an edge  iff 
covers  in the 2-PLC instance. This completes the proof of Theorem \ref{thm:ptc-geom}.
}
\section{Concluding Remarks}

In this paper we studied column restricted covering integer
programs. In particular, we studied the relationship between CCIPs and
the underlying 0,1-CIPs. We conjecture that the approximability of a
CCIP should be asymptotically within a constant factor of the
integrality gap of the original 0,1-CIP. We couldn't show this;
however, if the integrality gap of a PCIP is shown to be within a
constant of the integrality gap of the 0,1-CIP, then we will be
done. At this point, we don't even know how to prove that PCIPs of
special 0,1-CIPS, those whose constraint matrices are totally
unimodular, have constant integrality gap. Resolving the case of PTC
is an important step in this direction, and hopefully in resolving our
conjecture regarding CCIPs.

\bibliography{cover}
\bibliographystyle{plain}

\end{document}