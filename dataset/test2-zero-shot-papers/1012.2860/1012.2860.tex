\documentclass{easychair}

\usepackage{makeidx}
\makeindex

\usepackage{array}
\usepackage{multirow}



\newcommand{\xf}[1]{Figure~\ref{#1}}
\newcommand{\xp}[1]{page~\pageref{#1}}
\newcommand{\xs}[1]{Section~\ref{#1}}
\newcommand{\xa}[1]{Appendix~\ref{#1}}
\newcommand{\xc}[1]{Chapter~\ref{#1}}
\newcommand{\xt}[1]{Table~\ref{#1}}
\newcommand{\xl}[1]{Listing~\ref{#1}}



\newcommand{\rpc}{{RPC\index{RPC}}}
\newcommand{\rmi}{{RMI\index{RMI}}}
\newcommand{\clp}{{CLP\index{CLP}}}
\newcommand{\tlp}{{TLP\index{TLP}}}
\newcommand{\slp}{{SLP\index{SLP}}}
\newcommand{\complus}{{DCOM+\index{DCOM+}}}
\newcommand{\corba}{{CORBA\index{CORBA}}}
\newcommand{\jini}{{Jini\index{Jini}}}
\newcommand{\dotnet}{{.NET Remoting\index{.NET Remoting}}}
\newcommand{\gnu}{{GNU\index{GNU}}}
\newcommand{\tcpip}{{TCP/IP\index{TCP/IP}}}
\newcommand{\AST}{{AST\index{AST}}}




\newcommand{\gipc}{{GIPC\index{GIPC}\index{Frameworks!GIPC}}}
\newcommand{\gicf}{{GICF\index{GICF}\index{Frameworks!GICF}}}
\newcommand{\iplcf}{{IPLCF\index{IPLCF}\index{Frameworks!IPLCF}}}
\newcommand{\gee}{{GEE\index{GEE}\index{Frameworks!GEE}}}
\newcommand{\geer}{{GEER\index{GEER}}}
\newcommand{\gipsy}{{GIPSY\index{GIPSY}}}
\newcommand{\ripe}{{RIPE\index{RIPE}\index{Frameworks!RIPE}}}
\newcommand{\dpr}{{DPR\index{DPR}}}
\newcommand{\dms}{{DMS\index{DMS}}}
\newcommand{\jms}{{JMS\index{JMS}}}
\newcommand{\dmf}{{DMF\index{DMF}\index{Frameworks!DMF}}}
\newcommand{\dfg}{{DFG\index{DFG}}}




\newcommand{\glu}{{GLU\index{GLU}}}
\newcommand{\glusharp}{{GLU\#\index{GLU\#}}}
\newcommand{\gipl}{{GIPL\index{GIPL}}}
\newcommand{\sipl}{{SIPL\index{SIPL}}}
\newcommand{\ipl}{{IPL\index{IPL}}}
\newcommand{\lucid}{{Lucid\index{Lucid}}}
\newcommand{\ilucid}{{Indexical Lucid\index{Indexical Lucid}}}
\newcommand{\jlucid}{{JLucid\index{JLucid}}}
\newcommand{\olucid}{{Objective Lucid\index{Tensor Lucid}}}
\newcommand{\tlucid}{{Tensor Lucid\index{Tensor Lucid}}}
\newcommand{\plucid}{{Partial Lucid\index{Partial Lucid}}}
\newcommand{\flucid}{{Forensic Lucid\index{Forensic Lucid}}}
\newcommand{\onyx}{{Onyx\index{Onyx}}}
\newcommand{\lucx}{{Lucx\index{Lucx}}}
\newcommand{\ooip}{{OOIP\index{OOIP}}}
\newcommand{\ioop}{{IOOP\index{IOOP}}}
\newcommand{\jooip}{{JOOIP\index{JOOIP}}}




\newcommand{\C}{{C\index{C}}}
\newcommand{\cpp}{{C++\index{C++}}}
\newcommand{\perl}{{Perl\index{Perl}}}
\newcommand{\java}{{Java\index{Java}}}
\newcommand{\python}{{Python\index{Python}}}
\newcommand{\fortran}{{Fortran\index{Fortran}}}
\newcommand{\aspectj}{{AspectJ\index{AspectJ}}}
\newcommand{\php}{{PHP\index{PHP}}}



\newcommand{\lisp}{{LISP\index{LISP}}}
\newcommand{\scheme}{{Scheme\index{Scheme}}}
\newcommand{\haskell}{{Haskell\index{Haskell}}}
\newcommand{\mllessequal}{{ML\index{ML}}}
\newcommand{\fcpp}{{FC++\index{FC++}}}



\newcommand{\olucidop}[1]{{\bf \texttt{\textmd{\textsc{#1}}}}}
\newcommand{\lucidop}[1]{{\bf \texttt{#1}}}




\newcommand{\trans}{}
\newcommand{\transeq}[2]{}
\newcommand{\invtrans}{}
\newcommand{\invtranseq}[2]{}




\newcommand{\tab}[1]{\hspace{#1pt}}

\newcommand{\shrule}[0]{\vspace{3pt}\hrule\vspace{6pt}}
\newcommand{\ehrule}[0]{\vspace{6pt}\hrule\vspace{3pt}}

\newcommand{\nonterminal}[1]{}

\newcommand{\source}[1]
{
	{\shrule}
	\scriptsize
	#1
	\normalsize
	\hrule
}

\newcommand{\sourcefloat}[3]
{
	\begin{figure}[!hp]
	\begin{centering}
	\begin{minipage}{0.5\textwidth}
	\source{#1}
	\end{minipage}
	\caption{\small{#3}}
	\label{#2}
	\end{centering}
	\end{figure}
}

\newcommand{\todo}[0]
{
	{\Large }
}

\newcommand{\file}[1]{\url{#1}\index{Files!#1}}
\newcommand{\tool}[1]{\texttt{#1}\index{Tools!#1}}
\newcommand{\option}[1]{\texttt{#1}\index{Options!#1}}
\newcommand{\api}[1]{\texttt{#1}\index{API!#1}}
\newcommand{\apipackage}[1]{\url{#1}\index{API!Packages!#1}\index{Packages!#1}}
\newcommand{\datatype}[1]{\texttt{#1}\index{Type!#1}}
\newcommand{\codesegment}[1]{\texttt{\##1}\index{Segments!\##1}}



\newcommand{\javacc}[0]{JavaCC\index{Tools!JavaCC}}
\newcommand{\junit}[0]{JUnit\index{Tools!JUnit}}



\newcommand{\marf}[0]{MARF\index{MARF}\index{Frameworks!MARF}\index{Libraries!MARF}}
\newcommand{\dmarf}[0]{DMARF\index{MARF!Distributed}\index{Frameworks!Distributed MARF}\index{Libraries!Distributed MARF}}
\newcommand{\jdsf}[0]{JDSF\index{Frameworks!JDSF}\index{Libraries!JDSF}}
\newcommand{\sqlrand}[0]{SQLrand\index{SQLrand}}
\newcommand{\hsqldb}[0]{HSQLDB\index{HSQLDB}\index{Tools!HSQLDB}\index{Databases!HSQLDB}}
\newcommand{\cryptolysis}[0]{Cryptolysis\index{Frameworks!Cryptolysis}}




\newcommand{\statement}[2]
{
	\vspace{7pt}
	\shrule
	{\bf #1}

	#2
	\ehrule
	\vspace{7pt}
}

\newcommand{\sproposition}[2]
{
	\statement{Proposition #1}{#2}
}

\newcommand{\sdefinition}[2]
{
	\statement{Definition #1}{#2}
}

\newcommand{\saxiom}[2]
{
	\statement{Axiom #1}{#2}
}

\newcommand{\stheorem}[2]
{
	\statement{Theorem #1}{#2}
}



\newcommand{\unix}{\index{Unix@{\sc{Unix}}}{\sc{Unix}}}
\newcommand{\macos}[1]{\index{Mac OS #1@{\sc{Mac OS #1}}}{\sc{Mac OS #1}}}
\newcommand{\linux}{\index{Linux@{\sc{Linux}}}{\sc{Linux}}}
\newcommand{\rhl}[1]{\index{Red Hat Linux #1@{\sc{Red Hat Linux #1}}}{\sc{Red Hat Linux #1}}}
\newcommand{\fcore}[1]{\index{Fedora Core #1@{\sc{Fedora Core #1}}}{\sc{Fedora Core #1}}}
\newcommand{\ubuntu}[1]{\index{Ubuntu #1@{\sc{Ubuntu #1}}}{\sc{Ubuntu #1}}}
\newcommand{\debian}[1]{\index{Debian #1@{\sc{Debian #1}}}{\sc{Debian #1}}}
\newcommand{\solaris}[1]{\index{Solaris #1@{\sc{Solaris #1}}}{\sc{Solaris #1}}}
\newcommand{\win}[1]{\index{Windows #1@{\sc{Windows #1}}}{\sc{Windows #1}}}



\newtheorem{defn}{Definition}
\newtheorem{axioms}{Axiom}
\newtheorem{lemmas}{Lemma}
\newcommand{\wwweb}{{WWW}}
\newcommand{\bic}{{\index{BIC}BIC}}
\newcommand{\mni}{{\index{MNI}MNI}}
\newcommand{\nfs}{{\index{NFS}NFS}}
\newcommand{\crim}{{\index{CRIM}CRIM}}
\newcommand{\animal}{\index{Animal@{\sc{Animal}}}{\sc{Animal}}}
\newcommand{\paranimal}{\index{Paranimal@{\sc{ParAnimal}}}{\sc{ParAnimal}}}
\newcommand{\minc}{{\sc{MINC}}}
\newcommand{\netcdf}{{\sc{NetCDF}}}
\newcommand{\sgi}{{\index{SGI}}SGI}
\newcommand{\vv}{{\tt{*var}}}
\newcommand{\vd}{{\tt{?var}}}
\newcommand{\tv}{{\tt{*term}}}
\newcommand{\td}{{\tt{?term}}}
\newcommand{\fv}{{\tt{*fn}}}
\newcommand{\fd}{{\tt{?fn}}}
\newcommand{\home}{{\tt{home}}}
\newcommand{\light}{{\tt{light}}}
\newcommand{\heavy}{{\tt{heavy}}}
\newcommand{\lucidA}[1]{}
\newcommand{\lucidL}[1]{{}() }
\newcommand{\tristan}{\index{Tristan}Tristan}
\newcommand{\commercial}[1]{#1}
\newcommand{\al}{\mbox{}}
\newcommand{\be}{\mbox{}}
\newcommand{\ga}{\mbox{}}
\newcommand{\vx}[1]{\mbox{}}
\newcommand{\lvx}[1]{\mbox{}}
\newcommand{\svx}[1]{{\small \mbox{}}}
\newcommand{\curl}[1]{\nabla\times\;\mathbf{#1}}
\newcommand{\components}[3]{{_{#3}}{#2}_{#1}}
\newcommand{\componentsp}[3]{{_{#3}}{#2}'_{#1}}
\newcommand{\mypageheader}[1]{\vspace*{22mm}{\Huge \bf #1}\vspace*{5mm}}
\newcommand{\myfig}[1]{\center{\makebox[\textwidth]{\hbox{\vbox{\epsfbox{#1}}}}}}
\newcommand{\ctxt}{{\mathcal L},{\mathcal D},{\mathcal P},{\mathcal W}}
\newcommand{\noWctxt}{{\mathcal L},{\mathcal D},{\mathcal P}}
\newcommand{\myvdash}{\:\vdash\:}
\newcommand{\mysemi}{\::\:}
\newcommand{\Spc}          {{\mathcal{S}}}
\newcommand{\corner}[1]    {\ulcorner #1\urcorner}
\newcommand{\db}[1]        {\{#1\}}
\newcommand{\mtt}[1]       {{\mathtt{#1}}}
\newcommand{\mrm}[1]       {{\mathrm{#1}}}
\newcommand{\mem}[1]       {{\mathit{#1}}}

\newcommand{\mathfbyd}     {{\mathtt{fby.d}}}
\newcommand{\mathfirstd}   {{\mathtt{first.d}}}
\newcommand{\mathnextd}    {{\mathtt{next.d}}}
\newcommand{\mathprevd}    {{\mathtt{prev.d}}}
\newcommand{\mathwvrd}     {{\mathtt{wvr.d}}}
\newcommand{\mathasad}     {{\mathtt{asa.d}}}
\newcommand{\mathupond}    {{\mathtt{upon.d}}}
\newcommand{\mathfby}      {{\mathtt{fby}}}
\newcommand{\mathbefore}   {{\mathtt{before}}}
\newcommand{\mathfirst}    {{\mathtt{first}}}
\newcommand{\mathnext}     {{\mathtt{next}}}
\newcommand{\mathprev}     {{\mathtt{prev}}}
\newcommand{\mathwvr}      {{\mathtt{wvr}}}
\newcommand{\mathasa}      {{\mathtt{asa}}}
\newcommand{\mathupon}     {{\mathtt{upon}}}
\newcommand{\mathif}       {{\mathtt{if}}}
\newcommand{\maththen}     {{\mathtt{then}}}
\newcommand{\mathelse}     {{\mathtt{else}}}
\newcommand{\mathfi}       {{\mathtt{fi}}}
\newcommand{\mathatd}      {{\mathtt{@.d}}}
\newcommand{\mathat}       {{\mathtt{@.}}}
\newcommand{\mathtagd}     {{\mathtt{\#.d}}}
\newcommand{\mathtag}      {{\mathtt{\#.}}}
\newcommand{\mathwhere}    {{\mathtt{where}}}
\newcommand{\mathdimension}{{\mathtt{dimension}}}
\newcommand{\mathhome}	   {{\mathtt{home}}}
\newcommand{\mathheavy}	   {{\mathtt{heavy}}}
\newcommand{\mathlight}	   {{\mathtt{light}}}
\newcommand{\mathiseod}    {{\mathtt{iseod}}}
\newcommand{\mathiserror}  {{\mathtt{iserror}}}
\newcommand{\mathend}      {{\mathtt{end}}}
\newcommand{\matheod}      {{\mathtt{eod}}}
\newcommand{\matherror}    {{\mathtt{error}}}
\newcommand{\mathtrue}     {{\mathtt{true}}}
\newcommand{\mathfalse}    {{\mathtt{false}}}
\newcommand{\Ek}           {}
\newcommand{\Eop}           {}
\newcommand{\Eid}           {}
\newcommand{\Efid}          {}
\newcommand{\Econdt}        {}
\newcommand{\Econdf}        {}
\newcommand{\Ewhere}        {}
\newcommand{\Eat}           {}
\newcommand{\Etag}          {}
\newcommand{\Qid}           {}
\newcommand{\Qfid}          {}
\newcommand{\QQ}            {}
\newcommand{\const}        {{\mathit{k}}}
\newcommand{\varid}        {{\mathit{id}}}
\newcommand{\dimid}        {{\mathit{did}}}
\newcommand{\letter}       {{\mathit{letter}}}
\newcommand{\digit}        {{\mathit{digit}}}
\newcommand{\character}    {{\mathit{char}}}
\newcommand{\mystring}     {{\mathit{string}}}
\newcommand{\boolean}      {{\mathit{boolean}}}
\newcommand{\real}         {{\mathit{real}}}
\newcommand{\ASCIIchar}    {{\mathit{ASCIIchar}}}
\newcommand{\alphanum}     {{\mathit{alphanum}}}
\newcommand{\integer}      {{\mathit{integer}}}
\newcommand{\E}            {{\mathit{E}}}
\newcommand{\userfct}      {{\mathit{userfct}}}
\newcommand{\llop}         {{\textit{intensional-op}}}
\newcommand{\luop}         {{\textit{i-unary-op}}}
\newcommand{\lbop}         {{\textit{i-binary-op}}}
\newcommand{\op}           {{\textit{data-op}}}
\newcommand{\uop}          {{\textit{unary-op}}}
\newcommand{\bop}          {{\textit{binary-op}}}
\newcommand{\ifexpr}       {{\mathit{ifexpr}}}
\newcommand{\deflist}      {{\mathit{deflist}}}
\newcommand{\dimdef}       {{\mathit{dimdef}}}
\newcommand{\fctid  }      {{\mathit{fid}}}
\newcommand{\tensorid}[2]  {{\mathit{tid_{#1}#2}}}
\newcommand{\usc}          {\mathit{\raisebox{0mm}{\_}}}
\newcommand{\dimlist}      {{\mathit{dimlist}}}
\newcommand{\Elist}        {{\mathit{Elist}}}
\newcommand{\simpleuop}    {{\mathit{mathuop}}}
\newcommand{\complexuop}   {{\mathit{intuop}}}
\newcommand{\defmy}        {{\mathit{Q}}}
\newcommand{\paramlist}    {{\mathit{parlist}}}
\newcommand{\id}           {{\mathit{identifier}}}
\newcommand{\Luciduop}     {{\mathit{Luciduop}}}
\newcommand{\Lucidbop}     {{\mathit{Lucidbop}}}
\newcommand{\simplebop}    {{\mathit{mathbop}}}
\newcommand{\complexbop}   {{\mathit{intbop}}}
\newcommand{\arithbop}     {{\textit{arith-op}}}
\newcommand{\relbop}       {{\textit{rel-op}}}
\newcommand{\logbop}       {{\textit{log-op}}}
\newcommand{\bitbop}       {{\textit{bit-op}}}
\newcommand{\seqbop}       {{\textit{seq-op}}}
\newcommand{\B}{\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!}
\newcommand{\Bs}{\!\!\!}
\newcommand{\Bt}{\!}
\newcommand{\Dim}{{\mathcal{D}}}
\newcommand{\Point}{{\mathcal{P}}}
\newcommand{\PointP}{{\mathcal{P}}\!\dagger\!}
\newcommand{\Tag}{{\mathcal{T}}}
\newcommand{\Lang}{{\mathcal{L}}}
\newcommand{\Def}{{\mathcal{D}}}
\newcommand{\Ware}{{\mathcal{W}}}
\newcommand{\WareD}[2]{{\mathcal{W}}?\!\left\{[#1]#2\right\}}
\newcommand{\WareP}[3]{{\mathcal{W}}\!\dagger\!\left\{[#1]#2:#3\right\}}
\newcommand{\Id}{{\mathcal{I}}}
\newcommand{\Val}{{\mathcal{V}}}
\newcommand{\Stream}{{\mathcal{I}}}
\newcommand{\Expr}{{\mathcal{E}}}
\newcommand{\allExpr}{\Expr^\infty}
\newcommand{\allDim}{\Delta^\infty}
\newcommand{\allPoint}{\Pi^\infty}
\newcommand{\allStream}{\Stream^\infty}
\newcommand{\allVal}{\Val^\infty}
\newcommand{\allTag}{\Tag^\infty}
\newcommand{\extdef}{\stackrel{ext}{\equiv}}
\newcommand{\Sb}{\mathbf{Sb}}
\newcommand{\Sw}{\mathbf{Sw}}

\newenvironment{program}
		{\begin{quote}}
		{\end{quote}}
\newtheorem{mydef}
		{{\bf Definition:}}
		{}
\newcommand{\paracite}[2]
		{\vspace{0.5cm}
		{\it{#1

		}}
		{\begin{flushright}---#2\end{flushright}}
}
\newcommand{\cutecite}[2]
		{\vspace{0.5cm}
		{\begin{flushright}
		{\it{#1}}\\
		---#2
		\end{flushright}}
}
\newcommand{\sembox}[3]
		{\TR{   \begin{small}
			\begin{tabular}{|p{4mm}|c|}\hline
			#1 & {\tt{#2}}\\\cline{2-2}
		   	   & [#3]\\\hline
			\end{tabular}
			\end{small}

		}}









\def\mymid{\vrule depth 4pt height 10pt width 0.2mm}
\def\myspace{\hspace*{3mm}}
\def\mymidspace{\mymid\myspace}
\def\myvert{\raise 2.27pt \hbox{\vrule depth 0pt height 8pt width 0.2mm}}
\def\myarrow{\hspace*{0.43mm}\raise 2.29pt\hbox{\vrule depth 0pt height 8pt width 0.16mm}\hspace*{-0.32mm}
             \ }
\def\mmyarrow{\ }



\newcommand{\johndef}{\mathcal{D}}
\newcommand{\johnjvmdef}{\mathcal{D}_{jvm}}
\newcommand{\johntdef}{\mathcal{T}}
\newcommand{\myid}{\textit{id}}
\newcommand{\mytid}{\textit{tid}}
\newcommand{\mydagger}{\!\dagger\!}
\newcommand{\context}[2]{\mathcal{D},\mathcal{P} \vdash #1 : #2}
\newcommand{\jvmcontext}[2]{\mathcal{D}_{jvm} \vdash #1 : #2}
\newcommand{\pcontext}[2]{\mathcal{D},\mathcal{P},\mathcal{N} \vdash #1 : #2}
\newcommand{\contextW}[2]{\mathcal{D},\mathcal{P},\mathcal{W} \vdash #1 : #2}
\newcommand{\contextWp}[2]{\mathcal{D},\mathcal{P},\mathcal{W}' \vdash #1 : #2}
\newcommand{\qcontext}[2]{\mathcal{D},\mathcal{P} \vdash #1 \::\: #2}
\newcommand{\qjvmcontext}[2]{\mathcal{D}_{jvm} \vdash #1 \::\: #2}
\newcommand{\pqcontext}[2]{\mathcal{D},\mathcal{P},\mathcal{N} \vdash #1 \::\: #2}
\newcommand{\qcontextW}[2]{\mathcal{D},\mathcal{P,\mathcal{W}} \vdash #1 \::\: #2}
\newcommand{\myifthenelse}{\mathtt{if}\;E\;\mathtt{then}\;E'\;\mathtt{else}\;E''}

\def\Lfirst{\index{first@{\texttt{first}}}\texttt{first}\;}
\def\Lnext{\index{next@{\texttt{next}}}\texttt{next}\;}
\def\Lfby{\index{fby@{\texttt{fby}}}\;\texttt{fby}\;}
\def\Lat{\index{a@{\texttt{\char64}}}\;\texttt{\char64}\;}
\def\LSat{\index{a@{\texttt{\char64}}}\texttt{\char64}}
\def\Lhash{\index{a@{\texttt{\char35}}}\texttt{\char35}}
\def\Lwvr{\index{wvr@{\texttt{wvr}}}\;\texttt{wvr}\;}
\def\Lupon{\index{upon@{\texttt{upon}}}\;\texttt{upon}\;}
\def\LSupon{\index{upon@{\texttt{upon}}}\;\texttt{upon}}
\def\Lasa{\index{asa@{\texttt{asa}}}\;\texttt{asa}\;}
\def\Leod{\index{eod@{\texttt{eod}}}\texttt{eod}}
\def\Liseod{\index{iseod@{\texttt{iseod}}}\texttt{iseod}}
\def\Lif{\index{ifthenelse@{\texttt{if then else}}}\texttt{if}\;}
\def\Lthen{\;\texttt{then}\;}
\def\Lelse{\;\texttt{else}\;}
\def\Lsif{\index{ifthenelse@{\texttt{if then else}}}\texttt{\scriptsize if}\;}
\def\Lsthen{\;\texttt{\scriptsize then}\;}
\def\Lselse{\;\texttt{\scriptsize else}\;}

\def\mufirst{\index{first@{\texttt{first}}}\mathrm{\underline{\mathtt{first}}}\;}
\def\munext{\index{next@{\texttt{next}}}\mathrm{\underline{\mathtt{next}}}\;}
\def\mufby{\index{fby@{\texttt{fby}}}\;\mathrm{\underline{\mathtt{fby}}}\;}
\def\muwvr{\index{wvr@{\texttt{wvr}}}\;\mathrm{\underline{\mathtt{wvr}}}\;}
\def\muupon{\index{upon@{\texttt{upon}}}\;\mathrm{\underline{\mathtt{upon}}}\;}
\def\muasa{\index{asa@{\texttt{asa}}}\;\mathrm{\underline{\mathtt{asa}}}\;}

\def\mfirst{\index{first@{\texttt{first}}}\mathrm{{\mathtt{first}}}\;}
\def\mprev{\index{prev@{\texttt{prev}}}\mathrm{{\mathtt{prev}}}\;}
\def\mnext{\index{next@{\texttt{next}}}\mathrm{{\mathtt{next}}}\;}
\def\mfby{\index{fby@{\texttt{fby}}}\;\mathrm{{\mathtt{fby}}}\;}
\def\mwvr{\index{wvr@{\texttt{wvr}}}\;\mathrm{{\mathtt{wvr}}}\;}
\def\mupon{\index{upon@{\texttt{upon}}}\;\mathrm{{\mathtt{upon}}}\;}
\def\masa{\index{asa@{\texttt{asa}}}\;\mathrm{{\mathtt{asa}}}\;}

\def\Tfirst{\index{first@{\texttt{first}}}\texttt{first}}
\def\Tnext{\index{next@{\texttt{next}}}\texttt{next}}
\def\Tfby{\index{fby@{\texttt{fby}}}\texttt{fby}}
\def\Twvr{\index{wvr@{\texttt{wvr}}}\texttt{wvr}}
\def\Tupon{\index{upon@{\texttt{upon}}}\texttt{upon}}
\def\Tasa{\index{asa@{\texttt{asa}}}\texttt{asa}}

\newcommand{\eqdef}{\stackrel{{\mathrm{def}}}{=}}
\newcommand{\mylinebefore}{\noindent\rule{.1mm}{3mm}\rule[3mm]{.995\textwidth}{.1mm}\rule{.1mm}{3mm}\vspace*{-5mm}}
\newcommand{\mylineafter}{\vspace*{-5mm}\noindent\rule{.1mm}{3mm}\rule{.995\textwidth}{.1mm}\rule{.1mm}{3mm}}
\newcommand{\myprop}[1]{
\mylinebefore
\begin{proposition}
#1
\end{proposition}
\mylineafter
}
 

\begin{document}


\title{Towards Refactoring the DMF to Support {\jini} and JMS {\dms} in {\gipsy}}
\titlerunning{Uniform Invocation of Jini and JMS DMSs in GIPSY}

\author
{
	Yi Ji, Serguei A. Mokhov, and Joey Paquet\\
	Computer Science and Software Engineering\\
	Concordia University, Montreal, QC, Canada\\
	\url{{ji_yi,mokhov,paquet}@cse.concordia.ca}
}
\authorrunning{Ji, Mokhov, Paquet}


\maketitle


\begin{abstract}
In this paper we report on our re-engineering effort to refactor and unify
two somewhat disjoint Java distributed middleware technologies -- {\jini} and {\jms} --
used in the implementation of the Demand Migration System (DMS).
In doing so, we refactor their parent Demand Migration Framework (DMF), within
the General Intensional Programming System ({\gipsy}).
The complex Java-based {\gipsy} project is used to investigate on the
intensional and hybrid programming paradigms.
\end{abstract}

\hyphenation{In-te-r-o-pe-ra-bi-li-ty}




\section{Introduction}
\label{sect:introduction}

The {\gipsy} research prototype system \cite{gipsy} (see \xs{sect:background})
is a collection of replaceable Java components arranged primarily
into three main packages -- the collection of compilers for the programming
languages of interest (GIPC -- core -- Lucid-based intensional dialects \cite{lucid95}, and
hybrid dialects, primarily mixing Lucid code and Java code to various degrees),
runtime programming environment (RIPE) (currently a loose set of user interaction
components), and the run-time systems -- the general eduction engine (GEE).
We focus on some aspects of the latter in this paper, specifically its distributed
subcomponents that implement two instances of the demand-migration system (DMS)
using two distributed Java middleware technologies, namely Jini and JMS for
comparative studies of evaluation of hybrid programs to gain insight on the
technologies and various their parameters from programmability to scalability
metrics among others. Here we report some of our findings through development
and experiments.

\paragraph{Problem Statement}

One of the main reasons necessitating this study is the
hybrid intensional programming aspect the the GIPSY platform is there
to investigate among other things.
Lucid programs are naturally parallel and expressive \cite{lucid95,lucid85}
as well as context-oriented with contexts as first class
values \cite{wanphd06,tongxinmcthesis08}. Yet, in itself {\lucid} is rather
simple functional language for computation, and does not have rich I/O and
other support, so it should rely on the existing libraries and frameworks
when such needs arise leading the way to hybrid programming paradigms involving
a Lucid dialect and Java in our case.
Earlier (while still very valuable to the community, but relatively non-scalable and umaintainable)
solutions, were proposed and their enhancement with hybridification of Lucid and C \cite{glu1,glu2}
or later {\cpp} \cite{glu3}. Since GIPSY's architecture was first proposed and evolved in the
past 10 years to be extendable and component-based, hybrid prototype dialects emerged combinding
Java and Lucid -- {\jlucid} (Lucid program primarily calls only Java methods),
{\olucid} (Lucid to access to object properties of Java objects) \cite{mokhovmcthesis05} and later
{\jooip} (Java-based OO Intensional Programming) language \cite{aihuawu09} that enabled bidrectional
Lucid being able to access Java members and, at the same time, Java classes could contain fragments
written in Lucid in them. (Further work in programs involves extension of these in the form of
{\flucid} \cite{flucid-imf08} and MARFL \cite{marfl-context-secasa08}).
To support the evaluation of programs written in these hybrid dialects, the runtime (GEE)
of GIPSY has to scale to be able not only to locally compute light-weight Lucid fragments
locally, but also compute the hybrid ``heavy'' Java fragments -- given the latter can take
a lot of computation and I/O resources, and natural parallelization of Lucid, the hybrid
components are proposed to be evaluated distributively. Then the problem becomes which
distributed middleware technologies to pick.
As a proof of concept, the DMF was defined in Java and was implemented using two different
Java middleware technologies, {\jini} (by Vassev et al. \cite{dmf-plc05})
and {\jms} (Pourteymour \cite{dmf-pdpta07}). But those two were development in the
simulated prototype environment, relatively isolated from the core GIPSY project
and from each other.

\paragraph{Proposed Solution}

To enable consistent comparative studies of Jini and JMS in the GIPSY multi-tier
environment and hybrid language paradigms 
\cite{gipsy-multi-tier-sac09,gipsy-type-system-c3s2e09,bin-han-10} for points
of scalability \cite{ji-yi-mcthesis-2011}, usability, programmability, deployment,
and other aspects, we unify the two Java implementations of Jini and JMS DMS
under GEE and its multi-tier architecture and redefine the practical meaning
of certain of its components and do extensive testing of both. Hereafter, we
report on our experience in this regard.

\paragraph{Organization}

We proved the necessary background of the Java-based {\gipsy} project and its
distributed middleware technologies used in \xs{sect:background}.
We then describe the objectives of this work in \xs{sect:objectives}
and present the methodology and the approach in \xs{sect:methodology},
and finally we conclude in \xs{sect:conclusion}.


\section{Background}
\label{sect:background}

The General Intensional Programming System ({\gipsy}) provides a platform to
investigate the possibilities of the intensional programming~\cite{gipsy-multi-tier-secasa09}.
The intensional programming model, in the sense of Lucid, is a declarative and functional programming
language paradigm where the identifiers are evaluated in multidimensional context spaces.
The {\gipsy} compiler translates any flavor of intensional program into a source-language
independent GIPL program, and the {\gipsy} runtime system executes the GIPL program using
an evaluation model called eduction. In the demand-driven eduction model, an initial demand
requesting the value of a certain identifier is generated, and to consume this demand,
new demands are generated to request the values of the identifiers constituting the expression
defining the initial identifier, and similarly these demands further generate new demands
until eventually some of the demands are evaluated and propagated back in the chain of demands,
so that the identifiers whose value depend on them can be evaluated in turn,
and eventually the initial identifier is evaluated~\cite{gipsy-multi-tier-secasa09}.
This demand-driven eduction model naturally supports distributed
execution of intensional programs~\cite{glu2,glu3}.

The Demand Migration Framework ({\dmf}) for the {\gipsy} runtime system was proposed
for the distributed and demand-driven execution of intensional programs
by Vassev et al.~\cite{gipsy,vassev-mscthesis-05,dmf-plc05,dmf-cnsr05,dmf-pdpta07,mokhovmcthesis05}, and two principle Demand Migration Systems (DMS) as of this writing -- based
on {\jini} and {\jms} Java middleware technologies were provided to implement the DMF~\cite{dms-pdpta08,pourteymourmcthesis08}. The basic idea of the DMF is to provide a generic framework defining interface to
migrate/propagate demands among distributed demand generators and demand workers,
where the generators generate demands and the workers compute the demands.

A follow up work by Ji et al. \cite{ji-yi-mcthesis-2011} further streamlined
the code for unification while performing scalability studies for the the
Jini and JMS implementations of DMS in {\gipsy} (see \xs{sect:results}).

We briefly introduce the {\jini} DMS
and the {\jms} DMS architectures in the sections that follow.





\subsection{{\jini} DMS}
\label{sect:jini}

{\jini} is a Java-based and service-oriented middleware technology for building 
distributed systems consisting of {\jini} services and clients~\cite
{jini,jiniupnp,eermi}. 
Now officially known as {\em Apache River}~\cite{apache-river}, 
{\jini} defines a set of specifications and provides implementation
of several basic services such as lookup discovery, leasing and transaction services.
It also provides a Java implementation of the Tuple Space called the JavaSpace service
that enables distributed {\jini} clients to read, write and remove serialized 
Java objects stored in the shared object repository. JavaSpace supports
object persistence so that when restarted, the objects stored in the JavaSpace
can be recovered.

The {\jini} DMS of the {\gipsy} runtime system was implemented by Vassev
with his proposal of the first Demand Migration Framework (DMF)~\cite
{dmf-plc05,dmf-cnsr05}. As shown in \xf{fig:jini-architecture}, the {\jini} DMS consists of Demand Generators 
Demand Workers, {\jini} Transport Agent ({\jini} TA) and JavaSpace. 
The Demand Generators and Workers communicate among each other by sending and reading 
 into and from the JavaSpace with the aid of the {\jini} TA.
A  is a serialized Java object containing information 
for the evaluation of Lucid identifiers that require functional computation. 
A typical demand-migration process is as follows: 
\begin{enumerate}
	\item when parsing the abstract syntax tree of a hybrid Lucid program, 
				the Demand Generators encounter identifiers whose values depend on
				certain functional computations, so the Generators generate 
				demands to request these computation and use the TA to send those
				 demands into the JavaSpace;
	\item the Demand Workers then use the TA to pick up the  demands from 
	      the JavaSpace and carry out the functional computations requested, 
	      and send the  demands back to the JavaSpace;
  \item the Demand Generators then use the TA to pick up the  demands 
        from the JavaSpace and retrieve the values of the identifiers.
\end{enumerate}

The {\jini} TA in \xf{fig:jini-architecture} consists of {\jini} TA proxies and
a {\jini} TA backend. Each Demand Generator or Worker can obtain a {\jini} 
TA proxy object using the {\jini} lookup discovery service, and uses this TA proxy to 
communicate with the remote {\jini} TA backend via remote method invocation.
To write a demand into the JavaSpace, once invoked remotely by the Demand Generator
or Worker, the {\jini} TA backend uses a local Demand Dispatcher object
to wrap the demands as JavaSpace entries and send the entries into the remote JavaSpace. 
The reference to the remote JavaSpace service held by the Demand Dispatcher 
is also looked up via the {\jini} lookup discovery service.
Similarly, once invoked remotely to read a demand from the JavaSpace, 
the {\jini} TA backend uses the Demand Dispatcher object to retrieve
the corresponding JavaSpace entry and unwrap it, and returns the
demand to the remote Demand Generator or Worker.

The separation of the {\jini} TA into proxies and the remote backend
it allows diverse {\jini} TA implementations to be 
integrated into the system without affecting existing components, and may increase
system availability by allowing the Demand Generators and Workers to connect
to any TA registered in the {\jini} lookup discovery service.
However, its disadvantages are that the additional remote method invocation 
is redundant that it increases communication cost and undermines performance.



\begin{figure}[htpb!]
	\centering
\includegraphics[width=\columnwidth]{images/jini-architecture}
	\caption{Jini DMS architecture}
	\label{fig:jini-architecture}
\end{figure}




\subsection{{\jms} DMS}
\label{sect:jms}

{\jms} is short for Java Message Service that is a Java-based and message-oriented 
middleware technology \cite{qosJMS,comparisonddsjms,jmstutorial}. 
It defines a set of API specifications and has several implementations
such Open Message Queue and JBoss Messaging. Basically a {\jms} implementation is a
{\jms} broker providing messaging services to its clients. The {\jms} clients fall into
two domains: message producer and consumer, and message publisher and subscriber.
The producer/consumer domain is for end-to-end messaging, meaning that each message
is sent by one producer, stored in the message queue in the broker, and received
by only one consumer; whereas the publisher/subscriber is for broadcast messaging,
in which each message is sent by one publisher, but can be received by multiple
subscribers. Compared to {\jini} JavaSpace, {\jms} broker provides additional
services to ensure availability and reliability such as delicate memory management, 
flow control, various acknowledgment models and better polished transactions. 
{\jms} also supports message persistence.

The {\jms} DMS was first implemented by Pourteymour~\cite
{dmf-pdpta07,dms-pdpta08,pourteymourmcthesis08} based on the message producer/consumer model. The alternative publisher/subscriber
model was not adopted because it does not allow newly registered subscribers to receive 
messages that were published before their registration, whereas the {\gipsy} must allow
workers to pick up  demands in the form of messages sent at anytime.
As shown in \xf{fig:jms-architecture}, the {\jms} DMS consists of Demand
Generators, Demand Workers, {\jms} TAs and the {\jms} broker service. Similar to the 
{\jini} DMS, the Demand Generators generate demands and the Workers compute 
the demands, and the demands are migrated among them via the TAs and the {\jms}
broker service. However, in this {\jms} DMS, to send a demand passed by the Demand
Generator or Worker, the {\jms} TAs wrap the demands into object messages and 
send them directly into the message queues managed by the broker; 
to read a demand, the {\jms} TAs directly read object messages
from the message queues, unwrap and return the demands
to the Demand Generator or Worker. Compared to the {\jini} DMS, the {\jms} DMS
has a simpler TA architecture without unnecessary communication cost, 
and it does not have a concrete Demand Dispatcher to wrap around the message queue
since the {\jms} API and broker was reckoned as the role of the Demand Dispatcher.
However, since the {\jms} TA in the {\jms} DMS is directly instantiated by the
Demand Generator or Worker, once the TA implementation is changed, the Java source
code of the existing components will be affected, which is inconvenient to add 
new TA implementations that are based on different middleware technologies.



\begin{figure}[htpb!]
	\centering
\includegraphics[width=\columnwidth]{images/jms-architecture}
	\caption{{\jms} DMS architecture}
	\label{fig:jms-architecture}
\end{figure}



\section{Methodology}
\label{sect:methodology}

We studies the original implementations of Jini and JMS DMS to be able
to run both consistently or even concurrently within one GIPSY computing network
instance. With this preliminary study we defined a number of required objectives
related to the actual refactoring, as well as identifying which technology is
more appropriate than the other and under which condition in the consistent
uniform setup; including common interfaces, glue, data structures and the like.

\subsection{Objectives}
\label{sect:objectives}


\begin{itemize}
	\item 
	Make {\jms}~\cite{jms} and {\jini}~\cite{jini} look similar, i.e. be a part of
	the same interchangeable framework's implementation.
	
	\item 
	Redefine the roles of Demand Dispatcher and the Transport Agent (see \xf{fig:generator-dispatcher})
	for the dispatcher to be more of decision maker and a scheduler for the generators, etc. rather than
	being attached to the demand store.
	
\item
	Compare Jini and JMS vs JVM performance and scalability of computation.
	
	\item
	Compare programmability of the two APIs.
	
	\item
	Compare ease of deployment and startup of JMS and Jini from the same common point.
\end{itemize}

\begin{figure}[htpb!]
	\centering
	\includegraphics[width=\columnwidth]{images/generator-dispatcher}
	\caption{Demand Generator and Demand Dispatcher relationship}
	\label{fig:generator-dispatcher}
\end{figure}

\subsection{Making {\jini} and {\jms} similar}

Before the refactoring process, the class diagram of the Jini and JMS DMSs
	is shown in \xf{fig:old-dms-class-diagram}. In this class diagram, the Jini 
	Demand Dispatcher communicates directly with the JavaSpace, and is used by
	the JTABackend that is remotely invoked by the JINITransportAgentProxy. 
	The JMSTA communicates with Message Queue directly and had no DemandDispatcher. 
	The JINITransportAgentProxy and the JMSTA inherit different interfaces as they
	expose too much middleware-dependent features, such as the UUid in {\jini} and the
	connection setup phase in {\jms}, and therefore each DMS has their own Demand 
	Generator and Worker since the Generator and Worker instantiate their TAs
	directly and use them in a middleware-dependent way.
	
	\begin{figure}[htpb!]
	\centering
\includegraphics[width=\columnwidth]{images/old-dms-class-diagram}
	\caption{DMS class diagram before refactoring}
	\label{fig:old-dms-class-diagram}
	\end{figure}
	
The refactoring began with creating a new class called JiniTA, moving the 
	original business logic of the DemandDispatcher into this JiniTA, and updating
	all the references to the original DemandDispatcher by pointing them to the
	new JiniTA. Then we encapsulated all the middleware-dependent logic, such
	as {\jms} connection setup and teardown, inside each TA implementation, and
	made them directly inherit the ITransportAgent interface. Having done so,
	we removed all the TA-implementation-dependent logic, such as TA instantiation,
	from the Demand Generators or Workers, so that they only reference ITransportAgent
	only. Then we used DemandDispatcher to delegate ITransportAgent, and replaced
	the usage of ITransportAgent with IDemandDispatcher inside the Demand Generator
	and Worker, so that the Demand Generators or Workers now talks to 
	IDemandDispatcher only and in the future we could easily add scheduling logic 
	into the DemandDispatcher to decide when, where and using what TA to send or receive
	demands. The class diagram of the DMS after our refactoring is shown in
	\xf{fig:new-dms-class-diagram}. We also unified the demand classes we use and
	separate them into subclasses due to their different purposes, such as
	procedural identifier evaluation, intensional identifier evaluation, runtime-resource
	acquisition and system management, as shown in \xf{fig:demand-tree}.
	
	\begin{figure}[htpb!]
	\centering
\includegraphics[width=\columnwidth]{images/new-dms-class-diagram}
	\caption{DMS class diagram after refactoring}
	\label{fig:new-dms-class-diagram}
	\end{figure}
	
	\begin{figure}[htpb!]
	\centering
\includegraphics[width=\columnwidth]{images/demand-tree}
	\caption{class diagram of demands}
	\label{fig:demand-tree}
	\end{figure}
	
To ease the addition and switching of TA or Demand Dispatcher implementations,
	we use Java Reflection to instantiate each TA or Demand Dispatcher
	implementation by the name, where the name of the implementation is
	a character string passed via network or stored in files. In this way
	the two DMSs are interchangeable without changing the Java source code
	of the Demand Generator and the Demand Worker, so that we can use the 
	same set of Demand Generators and Demand Workers to a comparative
	study of the two DMSs. With proper testing and upon approval from all group members, 
	we committed the changes and cleaned up the affected code remained.
	

\section{Results}
\label{sect:results}

We compared the following three aspects of the Jini and JMS DMSs based on
our refactoring work.

\subsection{Ease of programming}
	In our experience, the programming of {\jini} application requires the knowledge 
	of several separate but also correlated {\jini} concepts and services, 
	such as service lookup discovery, leasing, JavaSpace and transaction. 
	Such knowledge requires time and effort to collect, study and put into practice,
	especially if additional quality of service (QoS) is required. For example, {\jini} does
	not provide additional memory management besides the memory tuning available to the
	Java Virtual Machine (JVM), therefore if stronger memory management mechanism is required, 
	programmers will have to code their own {\jini} extension to enhance memory management.
	In contrast, {\jms} is a mainstream middleware technology and has relatively integrated
	services, more QoS choices, well managed documentation and easily understandable tutorials, 
	which is easier for programmers to learn and put into practice.
		
\subsection{Ease of deployment}
	{\jini} requires only a set of .jar and configuration files to start its services, therefore
	has a light weight (the size of all .jar files is less than 4 MB) and can be easily
	deployed across different platforms, as long as Java is installed in the machines. In contrast,
	{\jms} requires platform-dependent executable binary files, such as .exe files in Windows,
	to start and manage the broker service, therefore it has a larger size (in the case of 32-bit Windows
	version, the size of all executable files and .jar files is around 20 MB), and requires those
	plat-form dependent executable files to be deployed across different platform.
	
\subsection{Runtime issues}
	We tested that when the {\jini} DMSs was storing increasing amount of demands, 
	the {\jini} DMS would run out of memory and crash in the end, even if the data persistence feature
	was turned on. This shows the storage capacity of the {\jini} JavaSpace is constrained by its
	memory, and it provides no mechanism to prevent JVM crash. In contrast, the {\jms} DMS
	with message persistence turned on can swap persistent messages into its persistent storage, such
	as files, to reduce its memory usage once the memory usage exceeds certain threshold.
	Therefore when the {\gipsy} runtime system is facing increasing amount of demands, the {\jms} DMS
	with message persistence is a better choice when the system availability is the dominant concern.
	
	However, when comparing system performance in the sense of throughput of concurrent Pi
	calculation demands when the demands were generated by a multi-threaded Generator and computed
	by multiple Demand Workers distributed in different computers with maximumly two Workers
	per computer, we found that as the number Workers increases, the {\jini} DMS provided a higher throughput than
	the {\jms} DMS, and the {\jms} DMS reached its throughput saturation when there were 10 Workers deployed.
	The test result is shown in \xf{fig:scalability-load-test-2}, and the test was perform in a lab
	with computers with the same hardware and operating system environment shown in \xf{tab:test-environment}.
	These computers and their corresponding switch ports have 100 Mbps maximum speeds, 
	with each machine connected to one switch port and all of them on the same subnet and VLAN.
	This test shows that in the sense of throughput, the {\jini} DMS is a better choice than the {\jms} DMS.
	We also found that for each Demand Generator or Worker connection, the {\jini} DMS uses one thread
	to handle each connection, whereas the {\jms} DMS uses two threads. 
	
	All the above differences show that when deployed in managed network, {\jini} is more suitable for DMS 
	requiring high throughput but low memory storage and low reliability, whereas {\jms} is suitable for DMS 
	requiring high reliability and availability.
	
	\begin{figure}[htpb!]
	\centering
\includegraphics[width=\columnwidth]{images/scalability-load-test-2}
	\caption{throughput of Pi calculations of the two DMSs}
	\label{fig:scalability-load-test-2}
	\end{figure}
	
	\begin{table*}[htbp]
		\centering
		\caption{Hardware and operating system environment}
		\label{tab:test-environment}
		\begin{tabular}{ | l | p{8cm} | }
\hline
		OS Name                    & Microsoft Windows 7 Enterprise \\ \hline
		Version                    & Version	6.1.7600 Build 7600 \\ \hline
		System Type                & X86-based PC \\ \hline
		\multirow{2}{*}{Processor} & Intel(R) Core(TM)2 CPU 6300 @ 1.86GHz, 1862 MHz, 2 Core(s), 2 Logical Processor(s) \\ \hline
		Installed RAM	             & 2.00 GB \\ \hline
		Total RAM	                 & 2.00 GB \\ \hline
		Available RAM	             & 1.06 GB \\ \hline
		Total Virtual Memory       & 4.00 GB \\ \hline
		Available Virtual Memory   & 2.58 GB \\ \hline
		Page File Space	           & 2.00 GB \\ \hline
  	\end{tabular}
	\end{table*}
	


\section{Conclusion}
\label{sect:conclusion}

We have successfully did the POC integration of the
two middleware technologies implementations based
on {\jini} and {\jms} available to the GIPSY run-time
system. In the future work we plan to continue
refactoring and cleaning up the other technologies
within GIPSY to work together in unison.
It is evident, that Jini appears to be easier to work with for
development and deployment, but its memory-bound scalability is
more problematic than that of JMS, so JMS-based implementation is
general more reliable, but Jini DMS offers higher throughput
over JMS.
For in-depth results of the initial study on various
scalability metrics pleas refer to \cite{ji-yi-mcthesis-2011}.
Some significant redesign was also necessary to make the two
implementations work together consistently, with a potential
payoff any new, better or worse, implementations for comparative
studies like we did, will be much more manageable.

\subsection{Future work}

There is a lot of work to be done; our immediate future attention will be
the item (1) below to expand our distributed testing environment followed
by other proposed items:

\begin{enumerate}
	\item Various JVMs in Linux and MacOS X distributed testing environments and clusters
	\item Comparative study for Web Services-based implementation
	\item Long-running distributed computation processes (e.g. MARF pattern recognition pipeline with very large data set over GIPSY)
	\item Expand the architecture to mobile Java platforms
\end{enumerate}


\subsection{Acknowledgment}

This work in part is supported by NSERC and the Faculty of Engineering and
Computer Science, Concordia University, Montreal, QC, Canada.
We thank reviewers for their constructive reviews and feedback.

\bibliographystyle{plain}
\bibliography{unifying-refactoring-jini-jms-dms}

\appendix

\section{How to run the {\jini} DMS and the {\jms} DMS in the {\gipsy} project}
This documents introduces the steps to deploy and start the {\gipsy} runtime system
in 32-bit Windows.

\begin{enumerate}
	\item check out the GIPSY project \cite{mokhovcvs}. The project is an Eclipse
	project so you can simply imported into Eclipse IDE for Java Developers \cite{eclipse}.
	However, before you import it into Eclipse, remember to stop Eclipse from
	cleaning the bin folder as all the DMS executables are there. For example, in the case of 
	Eclipse Helios, once the IDE is open, go to Windows->Preferences->Java->Compiler->Building, 
	and uncheck the option ``Scrub output folders when cleaning projects'', and go back
	to the menu bar, click Project, and uncheck the option ``Build Automatically''
	so that you will need to build the project manually. Then you can import the {\gipsy}
	project and build it manually.
	
	\item Once the {\gipsy} project is built, you can go to the project's home folder,
	then go to the directory \\bin\\multitier\\.
	
	\item If you want to start {\jini} DMS, open StartGMTNode.config, and set the value of
	the property gipsy.GEE.multitier.Node.DSTConfigs as ../jini/DST.config
	
	\item If you want to start {\jms} DMS, open StartGMTNode.config, and set the value of
	the property gipsy.GEE.multitier.Node.DSTConfigs as ../jms/DST.config
	
	\item Double click startGMTNode.bat.
	
\end{enumerate}


\section{How to run the {\jini} DMS in the {\gipsy} project}
\label{sect:howto}

This document introduces the steps to compile and run the {\jini} code in the GIPSY project in
Windows XP. To use this guide, readers are required to have basic Java and Eclipse experience,
basic Jini knowledge (for example, service, lookup, JavaSpace, etc), and the basic understanding
of the GIPSY project structure.

\begin{enumerate}
	\item 
Get and install the appropriate software, and import the GIPSY project \cite{mokhovcvs}.
NOTE: If the software below cannot be found online, please check the GIPSY tools repository
	\begin{enumerate}
		\item 
		JDK 6 update 14 or later (\url{http://java.sun.com/javase/downloads/index.jsp}). It is better to set
		the \api{JAVA\_HOME} environment variable.
		\item 
		Eclipse IDE for Java Developers~\cite{eclipse}. Unpack the IDE, open
		it and import the GIPSY project from the GIPSY CVS into the Eclipse.
		\item 
		Jini Technology Starter Kit v2.1~\cite{jini}. The
		installation should require no administrator accounts. The term \api{JINI\_HOME} would be used in
		this manual to refer the installation directory.
	\end{enumerate}

	\item 
Compile the Jini code of the GIPSY project
NOTE: Point 1 and 2 should be done already in the GIPSY project when you get it.
	\begin{enumerate}
		\item 
		Copy the \file{jini-core.jar} and \file{jini-ext.jar} from \file{JINI\_HOME/lib} into the \file{gipsy/lib}
		\item 
		Configure the project Build Path by adding the above jars inside lib through ``Add JARs''
		\item 
		Build the project automatically or manually.
	\end{enumerate}

	\item 
Start the Jini service
	\begin{enumerate}
		\item 
Go to \file{JINI\_HOME/installverify}, and double-click the Launch All shortcut. The shortcut should
launch a service window and a Service Browser window.
		\item 
In the Service Browser window, click the ``Registrar'', and select the registrar representing
your computer. Then there would be 6 services appear in the ``Matching Services'' area,
including JavaSpace05, LookupDiscoveryService, ServiceRegistrar and TransactionManager.
		\item 
Leave the two windows open and do not touch them unless you want to shut down all the
services.
	\end{enumerate}

	\item 
Run the code requiring only JavaSpace.
NOTE: Currently there are two groups of Jini scenarios. The first one consists of
\api{DemandDispatcher}, \api{DemandDispatcherClient} and the \api{DemandDispatcherAgent} under the
\api{gipsy.GEE.IDP} package. The second scenario consists of the \api{gipsy.GEE.IDP.DemandDispatcher}, and
the DGT class in the \api{gipsy.GEE.IDP.DemandGenerator.simulator} package, and the \api{Worker} class in
the \api{gipsy.GEE.IDP.DemandGenerator.simulator.jini} package.

	\begin{enumerate}
		\item 
		Open Eclipse and run the classes within the same groups mentioned above with the \api{main()} method.
	\end{enumerate}

\item
Run the code requiring both JavaSpace and RMI
	\begin{enumerate}
		\item 
		Use command window to go to the \file{gipsy/bin} directory.
		\item 
		Open the \file{startJiniHTTPServer.bat} in edit mode, and check if all the paths are correct.
		\item 
		Double-click the \file{startJiniHTTPServer.bat}.
		\item 
		Double-click the \file{startJiniRMID.bat}.
		\item 
		Open Eclipse and run the\\\api{gipsy.GEE.IDP.DemandGenerator.jini.rmi.JINITransportAgent}.
		and the \api{gipsy.GEE.IDP.DemandGenerator.simulator.jini.WorkerJTA}, and the \api{DGT} in
		the \api{gipsy.GEE.IDP.DemandGenerator.simulator} package.
		
		Note:
		
		Please make sure that the \file{startJiniHTTPServer.bat} and the \file{startJiniRMID.bat} are in the \file{gipsy/bin}
		folder. If they are missing, please refer to the following content. Please make sure the settings in
		the content are consistent with your own JRE directories as shown in \xf{fig:startHTTPServer}
		and \xf{fig:startJiniRMID}.

\begin{figure*}[htpb]\hrule
\scriptsize
\begin{verbatim}

set RUNTIME_JAR="D:\Program Files\Java\jre6\lib\rt.jar"
set JINIHOME_BACKSLASH="D:\Program Files\jini2_1"
set JINI_CLASSPATH=.;KSLASHl\reggie-dl.jar;-dl.jar;ar;
java -jar -classpath -verbose
\end{verbatim}
\normalsize
\hrule
\caption{\texttt{startHTTPServer.bat}}\label{fig:startHTTPServer}\end{figure*}


\begin{figure*}[htpb!]\hrule
\begin{verbatim}

rmid -J-Djava.security.policy=gipsy/GEE/IDP/config/jini.policy
\end{verbatim}
\hrule
\caption{\texttt{startJiniRMID.bat}}\label{fig:startJiniRMID}\end{figure*}

	\end{enumerate}
\end{enumerate}


\printindex

\end{document}
