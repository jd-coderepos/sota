\documentclass[11pt]{article}
\newtheorem{theorem}{Theorem}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\usepackage{style}
\usepackage{geometry}      
\usepackage{amsmath}
\usepackage[pstricks1-10]{vaucanson-g}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage{algorithm}
\usepackage{ALgo}

\title{\Large\bf Algorithms for Glushkov -graphs}

\author{
Pascal {\sc
Caron}\thanks{Pascal.Caron@univ-rouen.fr}, Marianne
{\sc Flouret} \thanks{Marianne.Flouret@univ-lehavre.fr}
\\ LITIS,
Universit\'e de Rouen, 76801
Saint \'Etienne du Rouvray, France \\ LITIS, Universit\'e du Havre, 76058  Le
Havre Cedex, France
}
\begin{document}
\maketitle
\begin{abstract}
The automata arising from the well known conversion of regular expression to non deterministic automata have rather 
particular transition graphs. We refer to them as the Glushkov graphs, to honour his nice expression-to-automaton 
algorithmic short cut \cite{Glu61}. The Glushkov graphs have been characterized \cite{CZ97} in terms of simple graph 
theoretical properties and certain reduction rules. We show how to carry, under certain restrictions, this 
characterization over to the weighted Glushkov graphs. With the weights in a semiring , they are defined as the transition 
Glushkov -graphs of the Weighted Finite Automata (WFA) obtained by the generalized Glushkov construction \cite{CF03}  from the -expressions. It works provided that the semiring  is factorial and the -expressions are in the
 so called star normal form (SNF) of Br\"uggeman-Klein \cite{Bru93}. The restriction to the factorial semiring ensures to obtain algorithms. The restriction to the SNF would not be necessary 
if every -expressions were equivalent to some with the same litteral length, as it is the case for the 
boolean semiring  but remains an open question for a general .  
\end{abstract}
{\scriptsize {\bf Keywords: } Formal languages, weighted automata, -expressions.}


\section{Introduction}
The extension of boolean algorithms (over languages) to multiplicities
(over series)
has always been a central point in theoretical research. First,
Sch\"utzenberger \cite{Sch61.1} has given an equivalence between rational
and
recognizable series extending the classical result of Kleene \cite{Kle56}.
Recent contributions have been done in this area, an overview of knowledge of these domains is presented by Sakarovitch 
in \cite{Sak03}.
 Many research works have focused on producing a small WFA. For example, Caron and Flouret have extended the Glushkov construction to WFAs \cite{CF03}.
Champarnaud {\it et al} have designed a quadratic algorithm \cite{COZ09} for computing the equation WFA of a -expression. This equation WFA has been introduced by Lombardy and Sakarovitch as an extension of Antimirov's algorithm  \cite{LS01} based on partial derivatives.

Moreover, the Glushkov WFA of a -expression with  occurrences of symbol
(we say that its alphabetic width is equal to ) 
has only  states;
the equation -automaton
(that is a quotient of the Glushkov automaton)
has at most  states.

On the opposite, classical algorithms compute -expressions
the size of which is exponential with respect to the number of states of the WFA. For example, let us cite the block decomposition algorithm  proven in \cite{BR88}.




 In this paper, we also address the problem of computing short -expressions,
and we focus on a specific kind of conversion based on Glushkov automata.
Actually the particularity of Glushkov automata is the fol\-lo\-wing:
any regular expression of width  can be turned into its Glushkov -state automaton;
if a -state automaton is a Glushkov one, then it can be turned into an expression of width .
The latter property is based on the characterization of the family of Glushkov automata in terms of graph properties presented in~\cite{CZ97}. These properties are stability, transversality and reducibility.
 Br\"uggemann-Klein defines regular expressions in {\it Star Normal Form} (SNF) \cite{Bru93}. These expressions are characterized by underlying Glushkov  automata where each edge is generated exactly one time. This definition is extended to multiplicities. The study  of the SNF case would not be necessary 
if all -expressions were equivalent to some in SNF with the same litteral length, as it is the case for the boolean semiring .
 
 The aim of this paper is to extend the characterization of Glushkov automata to the multiplicity case in order to compute a -expression of width  from a -state WFA. This extension requires to restrict the work to factorial semirings as well as Star Normal Form -expressions. 
 
We exhibit a procedure that, given a WFA  on  a factorial semiring, outputs the following: 
either  is obtained by the Glushkov algorithm from a proper -expression  in Star Normal Form and the 
procedure computes a -expression  equivalent to , or  is not obtained in that way and the procedure 
says no.

The following section recalls fundamental notions concerning automata, expressions and Glushkov conversion for both boolean and multiplicity cases. An error in the paper by Caron and Ziadi \cite{CZ97} is pointed out and corrected. The section 3 is devoted to the reduction rules for acyclic -graphs. Their efficiency is provided by the confluence of -rules. The next section gives orbit properties for Glushkov -graphs. The section 5 presents the algorithms computing a -expression from a Glushkov -graph and details an example. 







\section{Definitions}
\subsection{Classical notions}
Let  be a finite set of letters (alphabet),  the empty word
and  the empty set.
Let (, , ) be a  zero-divisor free semiring where
 is the neutral element of
 and  the one of .  The semiring 
is said to be zero-divisor free \cite{HW96} if  and if , .

A {\it formal series} \cite{BR88} is a mapping 
from  into  usually denoted by  where  is the
coefficient of  in . The {\it support} of  is the language .


In \cite{LS01}, Lombardy and Sakarovitch explain in details the computation of
- expressions. We have followed their model of grammar. Our constant symbols
are  the empty word and . Binary rational operations are still  and
, the unary ones are Kleene closure , positive closure  and for
every , the multiplication to the left or to the right of an
expression . For an easier reading, we will write  (respectively ) for  (respectively 
). Notice that our definition of -expressions, which set is denoted
, introduces the operator of positive closure. This operator preserves
rationality with the same conditions (see below) that the Kleene closure's one.

-expressions are then given by the following grammar:


Notice that parenthesis will be omitted when not necessary. The expressions  and  are called {\it closure expressions}.
If a series  is represented by a -expression , then we denote by  (or ) the coefficient of the empty word of .
A -expression  is {\it valid} \cite{Sak03} if for each closure subexpression  and  of , .
 
 A -expression  is {\it proper} if for each closure subexpression  and  of , .


We denote by  the set of proper -expressions. Rational series
can then be defined as formal series expressed by {\it proper -expressions}.
For  in ,  is the support of the rational series
defined by .

The length of a -expression , denoted by , is the number of occurences of letters and of  
appearing in . By opposition, the litteral length, denoted by  is the number of occurences of letters in .
 For example, the expression   as a length of  and a litteral length of .

 A {\it weighted finite automaton} ({\it WFA}) on a zero-divisor free semiring
  over an alphabet  \cite{Eil74} is a
-tuple   where  is a finite set of states and the
sets ,
 and  are mappings  (input weights),
 (output weights), and  (transition weights).
The set of WFAs on  is denoted by .
A WFA is {\it homogeneous} if all vertices reaching a same state are labeled by the same letter. 

A {\it -graph} is a graph  labeled with coefficients in  where  is the set of vertices and  is the 
function that associates each edge with its label in . When there is no edge from  to , we have .
In case , the boolean semiring,   is the set of {\it regular
expressions} and, as the only element of  is , we omit
the use of coefficient and of the external product ().
For a rational series  represented by  ,  is usually called the
language of , denoted by  and .
A boolean automaton (automaton in the sequel)  over
an alphabet  is usually defined
\cite{Eil74,HU79} as a -tuple  where  is a
finite set of states,  the set of initial states,  the set of final states, and  the set of edges. We denote by   the language
recognized by the automaton . A graph  is a -graph for which labels of edges are not written.

\subsection{Extended Glushkov construction}

An algorithm given by Glushkov \cite{Glu61} for computing an automaton with  states from a regular expression of litteral length   has been extended to semirings  by the authors \cite{CF03}. Informally, the principle is to associate exactly one state in the computed automaton to each occurrence of letters in the expression. Then, we link by a transition two states of the automaton if the two  occurences of the corresponding letters in the expression can be read successively.

In order to recall  the extended Glushkov construction, we have to first define the ordered pairs and the supported operations.
An ordered pair  consists of a coefficient  and a position .
We also define the functions  such that  is equal to  
if  and  otherwise.
We define  the function that extracts positions from a set of ordered pairs  as follows: for  a set of ordered pairs, . 




The function   extracts the coefficient associated to a position  as follows:  for .

Let   be two sets of ordered pairs.
We define the product of  and  by   and 
, . 
 We define the operation  by  for some . 

As in the original Glushkov construction \cite{Glu60,MY60}, and in order to specify their position in the expression, 
letters are subscripted following the order of reading. The resulting expression is denoted  , defined over the 
alphabet of indexed symbols , each one appearing at most once in . The set of indices thus obtained is 
called positions and denoted by . For example, starting from 
, one obtains the indexed expression , 
 and  .
Four functions are defined in order to
compute a WFA which needs not be deterministic. 
represents the set of initial positions of words of  associated with their input weight,
 represents the set of final positions of words of  associated to their output weight and
 is the set of positions of words of  which immediately follows
position  in the expression , associated to their transition weight.  In the boolean case, these sets are subsets of . The  set represents 
the coefficient of the empty word. The way to compute these sets is completely formalized in table \ref{tableset}. 

\begin{table}[H]
{\small
\begin{tabular}{|c||c|c|c|c|}
\hline
\bf{E}&\bf{Null(E)}&\bf{First(E)}&\bf{Last(E)}&\bf{Follow}(E,i)\\
\hline
\hline
\bf{} &&&&\\
\hline
\bf{}&&&&\\
\hline
\bf{}&&&&\\
\hline
\bf{}&&&&\\
\hline
\bf{}&&&&\\
\hline
\bf{}&\begin{minipage}{1.8cm}\begin{center}\\\\\end{center}\end{minipage}&\begin{minipage}
{2.7cm}\begin{center}\\\\\end{center}\end{minipage}&\begin{minipage}{2.5cm}\begin{center}\\\\\end{center}\end{minipage}&\begin{minipage}{3.7cm}\begin{center}\\\\\end{center}\end{minipage}\\
\hline
\bf{}&\begin{minipage}{1.8cm}\begin{center}\\\\\end{center}\end{minipage}
&\begin{minipage}{2.7cm}\begin{center} \\ \\ \end{center}\end{minipage}&\begin{minipage}
{2.5cm}\begin{center}\\  \\ \end{center}\end{minipage}&\begin{minipage}{3.7cm}
\begin{center}\\  \\ \\ \\ \end{center}\end{minipage}\\
\hline
\bf{}&&&&\begin{minipage}{3.7cm}\begin{center}\\\\\end{center}\end{minipage}\\
\hline
\bf{}&&&&\begin{minipage}{3.7cm}\begin{center}\\\\\end{center}\end{minipage}\\
\hline
\end{tabular}
}
\caption{Extended Glushkov functions}\label{tableset}
\end{table}

These functions allow us to define the WFA
 where
\begin{enumerate}
\item  is the indexed alphabet,
\item  is the single initial state with no incoming edge with  as input weight,
\item 
\item  such that

\item  such that   for every , whereas\\

\end{enumerate}

The Glushkov WFA  of  is computed from  by
replacing the indexed letters on edges by the corresponding letters in
the expression . We will denote  the application such that  is the Glushkov WFA obtained from  by this algorithm proved in \cite{CF03}. 





In order to compute a -graph from an homogeneous WFA , we have to add a new vertex . Then , the set of edges, is obtained from transitions of  by removing labels and adding directed edges from every final state to . We label  edges to  with output weights of final states. The labels of the edges   for , ,  are -multiplied by the input value of the initial state  of .

In case  is a Glushkov WFA of a -expression , the -graph obtained from  is called  Glushkov -graph of  and is denoted by .


\subsection{Normal forms and casting operation}
\subsubsection*{Star normal form and epsilon normal form}
For the boolean case, Br\"uggemann-Klein defines regular expressions in {\it Star Normal Form} (SNF) \cite{Bru93} as expressions  for which, for each
 position  of , when computing the  function, the unions of sets are disjoint. This definition is given only for usual 
operators ,, , . We can extend this definition to the positive closure,  as follows:
\begin{definition}
A -expression  is in SNF if, for each closure -subexpression  or , the SNF conditions 
(1)  and (2)  hold.
\end{definition} 
Then, the properties of the star normal form (defined with the positive closure) are preserved.

In the same paper, Br\"uggemann-Klein defines also the {\it epsilon normal form} for the boolean case. We extend this epsilon normal form to the 
positive closure operator.
\begin{definition}
The epsilon normal form for a -expression  is defined by induction in the following way:
\begin{itemize}
\item{ or }  is in epsilon normal form.
\item{}  is in epsilon normal form if  and  are in epsilon normal form and if 
.
\item{}  is in epsilon normal form if  and  are in epsilon normal form.
\item{ or }  is in epsilon normal form if  is in epsilon normal form and .
\end{itemize}
\end{definition}

\begin{theorem}[\cite{Bru93}]
 For each regular expression , there exists a regular expression  such that 
 \begin{enumerate}
 \item ,
\item  is in SNF
\item  can be computed from  in linear time.
\end{enumerate}
\end{theorem}
Br\"uggemann-Klein has given every step for the computation of . This computation remains. We just have to add 
for  the same rules as for . Main steps of the proof are similar.\\


We extend the star normal form to multiplicities in this way. Let  be a -expression. 
For every subexpression  or  in , for each  in , 

We do not have to consider the case of the empty word because  and  are proper -expressions if .
  
As an example, let  and . We can see that the 
expression  is not in SNF, because
,  {\it P(Follow(H,2))}. 

\subsubsection*{The casting operation }
We have to define the casting : .  This is similar to the way in which  Buchsbaum et al. \cite{BGW00} define the topology of a graph.
 A WFA  is casted into an automaton  in the following way:
, ,  and .
 The casting operation can be extended to -expressions .
The regular expression  is obtained from  by replacing each  by .
The  operation on  is an embedding of -expressions 
into regular ones. Nevertheless, the Glushkov -graph computed from a -expression  may be different whether the Glushkov construction is applied first or the casting operation . This is due to properties of -expressions. For example, let ,  ( is not in epsilon normal form). We then have . We can notice that  ( does not recognize  but   does).\\





\begin{lemma}\label{rat1} 
Let  be a -expression.
 If  is in SNF and in epsilon normal form, then 
\end{lemma}

\noindent
{\bf Proof }We have to show that the automaton obtained by the Glushkov construction for an expression 
 in  has the same edges as the Glushkov automaton for .
First, we have , as  is obtained from  only by deleting coefficients.
Let us show that  (states reached from the initial state)
by induction on the length of . If , 
, . 
If ,  then , , . 
Let  satisfy the hypothesis, and ,. In this case, , 
.
 If , , , 
 .
 
 If , and if  and  satisfy the induction hypothesis, and as the coefficient of the empty word is  for one of the two subexpression  or  (epsilon normal form), we have 
 , 
 which is equal to   by induction. We obtain the same result concerning ,  and .

\noindent 
The equality  is obtained similarly.
 
The last function used to compute the Glushkov automaton is the {\it Follow} function. 
Let  be a -expression and  . If , , 
. 
If , , .  
Let  satisfy  for all .  
If  is  or , ,  by hypothesis. If  and  satisfy the induction  hypothesis, and if , (and  without loss of generality), , then . We obtain similar results for  as there is no intersection between positions of  and .
Concerning the star operation, let , with  for all . Then, .   But by definition, as  is in SNF, we know that , so . In fact, it means that if there exists a couple , there cannot exist . Otherwise, the expression would not be in SNF, and it would be possible that , which would make  and imply a deletion of an edge. A same reasonning can be done for the positive closure operator.

Hence, the casting operation  and the Glushkov construction commute for the composition operation if we do not consider the empty word.
\cqfd

 


\subsection{Characterization of Glushkov automata in the boolean case}\label{Glushkov-Charac}
The aim of the paper by Caron and Ziadi  \cite{CZ97} is to know how boolean Glushkov graphs can be characterized. We recall here the definitions which allow us to give the main theorem of their paper. These notions will be necessary to extend this characterization to Glushkov -graphs.

A {\it hammock} is a graph   without a loop if , otherwise  it has two distinct  vertices   and  such that, for any vertex   of ,
(1) there exists a path from   to   going through ,
(2) there is no non-trivial path from   to  nor from   to . Notice that every hammock with at least two vertices has a unique root (the vertex ) and anti-root (the vertex ). 


Let  be a hammock.
 We define  as an {\it orbit} of  if and only if  for all  and  in  there exists a non-trivial path from  to .
The orbit  is {\it maximal}  if, for each vertex  and for each vertex , there do not exist both a path from  to  and a path from  to . Equivalently,  is a maximal orbit of  if and only if it is a strongly connected component with at least one edge.

Informally, in a Glushkov graph obtained from a regular expression , the set of vertices of a maximal orbit corresponds exactly to the set of positions of a closure subexpression of .

The set of direct successors (respectively direct predecessors) of  is denoted by   (respectively ). Let  and . 
For an orbit  ,  denotes  and  denotes the set .
In other words,  is the set of vertices which are directly reached from  and which are not in . By extension,  and  .
The sets   and 
denote  the {\it input} and the {\it output} of the orbit . As  is a hammock,  and  
. 
An orbit  is  {\it stable} if .
An orbit  is  {\it transverse} if, for all ,  
and, for all ,  . 

An orbit  is {\it strongly stable} (respectively {\it strongly transverse}) if it is stable (respectively transverse)  and if after deleting the edges  in  (1) there does not exist any suborbit  or (2) every maximal suborbit of   is strongly  stable (respectively strongly transverse).
The hammock  is stronly stable (respectively strongly transverse) if (1) it has no orbit or (2) every maximal orbit  is strongly stable (respectively strongly transverse).

If   is  strongly  stable, then we call {\it the graph without orbit} of , denoted by , the acyclic directed graph obtained by recursively deleting, for every maximal orbit   of , the edges in . The graph  is then reducible if it can be reduced to one vertex by iterated applications of the three following rules:
\begin{itemize}
\item {\bf Rule {\bf }}: If  and  are vertices such that  and , then delete  and define .
\item{\bf Rule  {\bf }}: If  and  are vertices such that  and , then delete  and any edge connected to .	
\item{\bf Rule {\bf }}: If  is a vertex such that for all , then delete edges in .  
\end{itemize}
 
\begin{theorem}[\cite{CZ97}]\label{th}
 is a Glushkov graph if and only if the three following conditions are satisfied: 
\begin{itemize}
\item  is a  hammock.
\item Each maximal orbit in G is  {\it strongly  stable} and {\it strongly transverse}.
\item The graph without orbit  is {\it reducible}.
\end{itemize}
\end{theorem}

\subsection{The problem of reduction rules}
\subsubsection*{An erroneous statement in the paper by Caron and Ziadi}
In \cite{CZ97}, the definition of the  rules is wrong in some cases. Indeed, if we consider the regular expression , the graph obtained from the Glushkov algorithm is as follows

\VCDraw[.85]{
\begin{VCPicture}{(-6,-3)(12,3)}
\State[1]{(3,-1.5)}{1}
\State[2]{(6,-1.5)}{2}
\State[3]{(3,1.5)}{3}
\State[4]{(6,1.5)}{4}
\State[s_I]{(0,0)}{si}
\State[\Phi]{(9,0)}{phi}

\EdgeR{si}{1}{}
\EdgeR{si}{2}{}
\EdgeR{si}{3}{}
\EdgeR{si}{4}{}
\EdgeR{si}{phi}{}
\EdgeR{1}{2}{}
\EdgeR{1}{phi}{}
\EdgeR{2}{phi}{}
\EdgeR{3}{4}{}
\EdgeR{3}{phi}{}
\EdgeR{4}{phi}{}
\end{VCPicture}
}

Let us now try to reduce this graph with the reduction rules as they are defined in \cite{CZ97}. We can see that the sequel of applicable rules is ,  and . We can notice that there is a multiple choice for the application of the first  rule, but after having chosen the vertex on which we will apply this first rule, the sequel of rules leads to a single graph (exept with the numerotation of vertices).
\begin{figure}[H]
\VCDraw[.60]{
\begin{VCPicture}{(0,-3)(12,3)}
\SmallState
\tiny
\State[1]{(3,-1.5)}{1}
\State[2]{(6,-1.5)}{2}
\State[3]{(3,1.5)}{3}
\State[4]{(6,1.5)}{4}
\State[s_I]{(0,0)}{si}
\State[\Phi]{(9,0)}{phi}

\EdgeR{si}{1}{}
\EdgeR{si}{3}{}
\EdgeR{si}{4}{}
\EdgeR{1}{2}{}
\EdgeR{1}{phi}{}
\EdgeR{2}{phi}{}
\EdgeR{3}{4}{}
\EdgeR{3}{phi}{}
\EdgeR{4}{phi}{}

\State[1]{(17,-1.5)}{11}
\State[2]{(20,-1.5)}{12}
\State[3]{(17,1.5)}{13}
\State[4]{(20,1.5)}{14}
\State[s_I]{(14,0)}{1si}
\State[\Phi]{(23,0)}{1phi}

\EdgeR{1si}{11}{}
\EdgeR{1si}{13}{}
\EdgeR{1si}{14}{}
\EdgeR{11}{12}{}
\EdgeR{12}{1phi}{}
\EdgeR{13}{14}{}
\EdgeR{13}{1phi}{}
\EdgeR{14}{1phi}{}

\State[1]{(32.5,-1.5)}{21}

\State[3]{(31,1.5)}{23}
\State[4]{(34,1.5)}{24}
\State[s_I]{(28,0)}{2si}
\State[\Phi]{(37,0)}{2phi}

\EdgeR{2si}{21}{}
\EdgeR{2si}{23}{}
\EdgeR{2si}{24}{}
\EdgeR{21}{2phi}{}
\EdgeR{23}{24}{}
\EdgeR{23}{2phi}{}
\EdgeR{24}{2phi}{}
\end{VCPicture}
}
\caption{Application of  on ,  on  and  on  and .}
\end{figure}

We can see that the graph obtained is no more reducible. This problem is a consequence of the multiple computation of the edge . In fact, this problem is solved when each edge of the acyclic Glushkov graph is computed only once. It is the case when  is in epsilon normal form.

\subsubsection*{A new  rule for the boolean case}
Let  be an acyclic graph. The rule   is as follows:\\
\begin{itemize}
\item If  is a vertex such that for all , then delete the edge  if there does not exist a vertex  such that the following conditions are true:
\begin{itemize}
\item there is neither a path from  to  nor a path  from    to ,
\item  and ,
\item .
\end{itemize}
\end{itemize}
The new rule  check whether conditions of the old  rules are verified and moreover deletes an edge only if it does not correspond to the  of more than one subexpression.
The validity of this rule is shown in Proposition \ref{K-red}.


 
\section{Acyclic Glushkov WFA properties}
The definitions of section \ref{Glushkov-Charac} related to graphs are extended to -graphs by considering that edges labeled  do not exist.

Let us consider  a WFA without orbit.
Our aim here is to give conditions on weights in order to check whether  is a Glushkov WFA. 
Relying on the boolean characterization, we can deduce that  is homogeneous and that the Glushkov graph of  is reducible.


\subsection{-rules}
  
    
-rules can be seen as an extension of reduction rules. Each rule is divided into two parts: a graphic condition on edges, and a numerical condition (exept for the -rule) on coefficients.
The following definitions allow us to give numerical constraints for the application of -rules.

Let  be a -graph and let . Let us now define the set of beginnings of the set  as . A vertex   is in  if  for all  in  there is not a non trivial path from  to . In the same way, we define the set of terminations of  as  .  A vertex   is in  if for all  in  there is not a non trivial path from  to .

We say that  and  are {\it backward equivalent} if  and there exist  such that for every , there exists  such that  and . Similarly, we say that  and  are {\it forward equivalent} if  and there exist  such that for every , there exists  such that  and . Moreover, if  and  are both backward and forward equivalent, then we say that  and  are {\it bidirectionally equivalent}.

 In the same way, we say that  is {\it -equivalent}  if for all  the edge  exists and if there exist  such that for every  there exists  and for every  there exist ,  such that ,  and  .
 
Similarly,  is {\it quasi--equivalent} if 
\begin{itemize}
\item   or , and
\item for all , the edge  exists, and 
\item  there exist  such that for every  there exist  and for every , there exist  such that  , , and
\item  if  or  
\begin{itemize}
\item   then  
\item else  there exists  such that  (Notice that if the edge from  to  does not exist in the automaton, then  and it is possible to have ).
\end{itemize}
\end{itemize}
In order to clarify our purpose, we have distinguished the case where  are superpositions of edges (quasi--equivalence  of ) to the case where they are not (-equivalence  of ).\\

\noindent
{\bf Rule} : If  and  are vertices such that  and , then delete  and define .\\


\begin{figure}[H]
\centerline{\includegraphics[width=90mm]{KR1.eps}}
\caption{ reduction rule}\label{KR1-rule}
\end{figure}
\noindent
{\bf Rule}  : If   and  are bidirectionally equivalent, with  are the constants satisfying such a definition,
then 
\begin{itemize}
\item delete   and any edge connected to  
\item for every  and  set  and   where  and  are defined as in the bidirectional equivalence. 
\end{itemize}

\begin{figure}[H]
\includegraphics[width=140mm]{KR2.eps}
\caption{ reduction rule}\label{KR2-rule}
\end{figure}

\noindent
{\bf Rule} : If  is -equivalent or  is quasi--equivalent with   the constants satisfying such a definition,
then
\begin{itemize}
\item if  is -equivalent 
\begin{itemize}
\item then delete every ,
\item else delete every .
\end{itemize}
\item for every  and  set  and   where  and  are defined as in the -equivalence or quasi--equivalence. 
\item If  is quasi--equivalent then compute the new edges from   labeled .
\end{itemize}


\begin{figure}[H]
\includegraphics[width=140mm]{KR3_1.eps}
\caption{ reduction when  is -equivalent}\label{KR3a-rule}

\end{figure}

\begin{figure}[H]
\includegraphics[width=140mm]{KR3_2.eps}
\caption{ reduction when  is quasi--equivalent}\label{KR3b-rule}

\end{figure}

\subsection{Confluence for -rules}
In order to have an algorithm checking whether a -graph is a Glushkov -graph, we have to know (1) if it is decidable to apply a -rule on some vertices and (2) if the application of -rules ends. In order to ensure these characteristics, we will specify some sufficient properties on the semiring . Let us define  as a field or as a factorial semiring. A factorial semiring  is a zero-divisor free semiring for which every non-zero, non-unit element  of  can be written as a product of irreducible elements of  , and this representation is unique apart from the order of the irreducible elements. This notion is a slight adaptation of the factorial ring notion.

 It is clear that, if  is a field, the application of -rules is decidable. Conditions of application of -rules are sufficient to define an algorithm. In the case of a factorial semiring, as the decomposition is unique, a  is defined\footnote{In case  is not commutative, left  and right  are defined.} and it gives us a procedure  allowing us to apply one rule ( or ) on a -graph if it is possible. It ensures the decidability of -rules application for factorial semirings.  For both cases (field and factorial semiring), we prove that -rules are confluent. It ensures the ending of the algorithm allowing us to know whether a -graph is a Glushkov one. \\



We explicit algorithms in order to apply the  and  rules. Algorithm \ref{algoR2} tests whether the -rule graphical and numerical conditions for two states are verified. If so, it returns the partially reduced -graph. 
 Algorithm \ref{algoR3} is divided into three functions. The first one check whether the -graphical conditions are checked on a state  ({\sc GraphicalEquivalenceConditionsChecking}) and returns the  or quasi--equivalence type of . Then, depending on the type of , the numerical conditions for  or quasi--equivalence are verified (function {\sc EquivalenceChecking}). Finally a partially reduced -graph is obtained using {\sc GraphComputing} function.
 
{\small


\begin{algorithm}[H]
 \begin{algo}{-Application}{x,G}
\IN { One state  of a -graph }
\OUT {The newly computed graph }
\IF{\CALL{GraphicalEquivalenceConditionsChecking}{x,G, type}=False}
\RETURN{False}
\FI
\COM{If type is equal to  (resp. quasi-) lines labeled \{{\bf quasi-} \} (resp. \{ {\bf } \})\CUT of the functions below are deleted}
\IF{\CALL{EquivalenceChecking}{x,G,[\alpha],[\beta],k,[\gamma]}=False}
\RETURN{False}
\FI
\CALL{GraphComputing}{x,G,[\alpha],[\beta],k,[\gamma]}
\RETURN{True}
\end{algo}
\caption{Application of the  rule for a state}\label{algoR3}
\end{algorithm}
\begin{algorithm}[H]
 \begin{algo}{-Application}{x,y,G}
\IN { Two states  and  of a -graph }
\OUT {The newly computed graph }
\IF{Q^-(x)\neq Q^-(y)\mbox{ or }Q^+(x)\neq Q^+(y)}
\RETURN{False}
\FI
\SET{q^-_1}{\mbox{a vertex of }Q^-(x)}
\SET{\mbox{gcd}_r(x)}{U(q_1^-,x)}
\SET{\mbox{gcd}_r(y)}{U(q_1^-,y)}
\DOFOREACH {q^-\in Q^-(x)}
\SET{\mbox{gcd}_r(x)}{\CALL{right gcd}{U(q^-,x),\mbox{gcd}_r(x)}}
\SET{\mbox{gcd}_r(y)}{\CALL{right gcd}{U(q^-,y),\mbox{gcd}_r(y)}}
\OD
\DOFOREACH {q^-\in Q^-(x)}
\STATE{compute  such that }
\IF {\alpha_{q^-}\otimes \mbox{gcd}_r(y) \neq U(q^-,y)}
\RETURN{False}
\FI
\OD

\SET{q^+_1}{\mbox{a vertex of }Q^+(x)}
\SET{\mbox{gcd}_l(x)}{U(x,q_1^+)}
\SET{\mbox{gcd}_l(y)}{U(y,q_1^+)}
\DOFOREACH {q^+\in Q^+(x)}
\SET{\mbox{gcd}_l(x)}{\CALL{left gcd}{U(x,q^+),\mbox{gcd}_l(x)}}
\SET{\mbox{gcd}_l(y)}{\CALL{left gcd}{U(y,q^+),\mbox{gcd}_l(y)}}
\OD
\DOFOREACH {q^+\in Q^+(x)}
\STATE{compute  such that }
\IF {\mbox{gcd}_l(y)\otimes \beta _{q^+}\neq U(y,q^+)}
\RETURN{False}
\FI
\OD

\STATE{delete  and any edge connected to }
\DOFOREACH {q^-\in Q^-(x)}
\SET{U(q^-,x)}{\alpha_{q^-}}
\OD
\DOFOREACH {q^+\in Q^+(x)}
\SET{U(q^+,x)}{\beta_{q^+}}
\OD
\RETURN{True}
\end{algo}
\caption{Application of the  rule for two states}\label{algoR2}
\end{algorithm}

\begin{algo}{GraphComputing}{x,G,[\alpha],[\beta],k,[\gamma]}
\IN { One state  of a -graph  \CUT 
, ,}
\RCOM{{\bf quasi-}}
\IN { and }
\OUT {The newly computed graph }

\DOFOREACH{q^-\in Q^-(x)}
\SET {U(q^-,x)}{\alpha_{q^-}}
\OD
\DOFOREACH {q^+\in Q^+(x)}
\SET {U(x,q^+)}{\beta_{q^+}}
\OD
\RCOM{{\bf }}
\STATE {delete any edge }
\RCOM{{\bf quasi-}}
\STATE {delete any edge }
\RCOM{{\bf quasi-}}
\DOFOREACH{(q^-,q^+)\in B(Q^-(x))\times T(Q^+(x))}
\RCOM{{\bf quasi-}}
\SET {U(q^-,q^+)}{\gamma (q^-,q^+)}
\OD
\end{algo} 

\begin{algo}[noends]{GraphicalEquivalenceConditionsChecking}{x,G, type}
\IN{ One state  of a -graph }
\OUT{type  -equivalence, quasi--equivalence\}}
\STATE{compute  and }
\IF{ B(Q^-(x))=Q^-(x) \mbox{ and }T(Q^+(x))=Q^+(x)}
\DOFOREACH {q^-\in Q^-(x)}
\DOFOREACH {q^+\in Q^+(x)}
\IF{U(q^-,q^+)= \b{0}}
\RETURN{False}
\FI
\OD
\OD
\SET{\mbox{type}}{\epsilon}
\RETURN{True}
\ELSE
\DOFOREACH {q^-\in Q^-(x)}
\DOFOREACH {q^+\in Q^+(x)}
\IF{(q^-,q^+) \in Q^-(x) \times Q^+(x) \setminus B(Q^-(x))\times T(Q^+(x))
\CUT \mbox{and }U(q^-,q^+))= \b{0}}
\RETURN{False}
\FI
\OD
\OD
\SET{\mbox{type}}{\mbox{quasi-}\epsilon}
\RETURN{True}
\FI
\end{algo} 

\begin{algo}{EquivalenceChecking}{x,G,[\alpha],[\beta],k,[\gamma]}
\IN { One state  of a -graph }
\OUT{, ,}
\RCOM{{\bf quasi-}}
\OUT{ and }
\SET{q^-_1}{\mbox{a vertex of }Q^-(x)}
\SET {\mbox{gcd}_r}{U(q_1^-,x)}
\DOFOREACH {q^-\in Q^-(x)}
\SET{\mbox{gcd}_r}{\CALL{right gcd}{U(q^-,x),\mbox{gcd}_r}}
\OD
\DOFOREACH {q^-\in Q^-(x)}
\STATE{compute  such that
}
\OD
\SET{q^+_1}{\mbox{a vertex of }Q^+(x)}
\SET {\mbox{gcd}_l}{U(x,q_1^+)}
\DOFOREACH {q^+\in Q^+(x)}
\SET{\mbox{gcd}_l}{\CALL{left gcd}{\mbox{gcd}_l,U(x,q^+)}}
\OD
\DOFOREACH {q^+\in Q^+(x)}
\STATE{compute  such that
}
\OD
\RCOM{{\bf }}
\SET{(q_1^-,q_1^+)}{\mbox{ a couple of vertices of }Q^-(x)\times Q^+(x)}
\RCOM{{\bf quasi-}}
\SET{(q_1^-,q_1^+)}{\mbox{ a couple of vertices of }\CUT Q^-(x)\times Q^+(x)\setminus B(Q^-(x))\times T(Q^+(x))}
\STATE{Find  such that\CUT }
\IF{k_1 \mbox{ does not exist}}
\RETURN{False}
\FI
\DOFOREACH{(q^-,q^+)\in Q^-(x)\times Q^+(x)}
\RCOM{{\bf quasi-}}
\IF {(q^-,q^+) \not\in B(Q^-(x))\times T(Q^+(x))}
\STATE{Find  such that\CUT }
\IF{k \mbox{ does not exist}}
\RETURN{False}
\ELIF{k\neq k_1}
\RETURN{False}
\FI
\FI
\OD
\RCOM{{\bf quasi-}}
\DOFOREACH{(q^-,q^+)\in B(Q^-(x))\times T(Q^+(x))}
\RCOM{{\bf quasi-}}
\STATE{Find  such that\CUT }
\RCOM{{\bf quasi-}}
\IF{\gamma (q^-,q^+) \mbox{ does not exist}}
\RCOM{{\bf quasi-}}
\RETURN{False}
\FI
\OD
 \RETURN{True}
\end{algo}
}

\begin{definition}[confluence]
Let  be a -graph and  the acyclic graph having only one vertex. Let  be a sequence of -rules such that 


-rules are confluent if for all -graph
  such that there exists   a sequence of -rules with   then there exists  a sequence of -rules such that  
\end{definition}
For the following,  is a field or a factorial semiring.
\begin{proposition}\label{confluent}
The -rules are confluent.
\end{proposition}
{\bf Proof } In order to prove this result, we will show that if there exist two applicable -rules reducing a Glushkov -graph, then the order of application does not modify the resulting -graph. 

Let us denote by  the application of a ,  or  rule on the vertices  and  with  for a  rule.

Let  be a Glushkov -graph and let  and  be two applicable -rules on  such that   and no edge can be deleted by both rules. Necessarily we have  .

Suppose now that  or one edge is deleted by both rules. We have to consider several cases depending on the rule .
\begin{itemize}
\item[ is a  rule] In this case  can not delete the edge from  to  and  is necessarily a -rule with . If , as the coefficient does not act on the reduction rule, 

\item[ is a  rule] Consider that  is a  rule with . Using the notations of the  rule, there exist , ,  such that , ,  and   with , , and ,  (, ). By hypothesis, a  rule can also be applied on the vertices  and . There also exists , ,  such that , , ,   ( and ). By construction (Algorithm \ref{algoR2}) 
of , the left gcd of all  is . Then, whatever  the order of application of  rules,  the same decomposition of edges values is obtained. Symetrically a same reasoning is applied for the right part. 


Consider now that  is a  rule. Neither edges from  or  nor edges to  or  can be deleted by . Then  or . Let . If we successively apply  and   or  and  on , we obtain the same -graph following the same method (function {\sc EquivalenceChecking})
 as the previous case. If we choose , we have also the same -graph (commutativity property of the sum operator). 
\item[ is a  rule] The only case to consider now is  a  rule. Suppose that  deletes an edge also deleted by  (with ). Let  be this edge.


Using the notations of the  rule, there exist , ,  such that , ,  with ,  and , .
 There also exists , ,  such that , ,  with , . By construction, (function {\sc EquivalenceChecking}),
  the computation of   and  ( and ) are independant.  A same reasoning is applied for the right part. Then we can choose  such that  and . So 
. It is easy to see that .
\end{itemize}
\cqfd


\subsection{-reducibility}
\begin{definition}
A -graph  is  said to be {\it -reducible} if it has no orbit and if it can be  reduced to one vertex by  iterated applications of any of the three rules , ,  described below.
\end{definition}




Proposition \ref{K-red}  shows the existence of a sequel of -rules leading to the complete reduction of Glushkov -graphs. However, the existence of an algorithm allowing us to obtain this sequel of -rules depends on the semiring .

In order to show the -reducibility property of a Glushkov -graph , we check (Lemma \ref{2R1}) that every sequence  of -rules leading to the -reduction of  contains necessarily two  rules which will be denoted by  and .
\begin{lemma}\label{2R1}
Let  be a -reducible Glushkov -graph without orbit with , and let  be the sequence of -rules which can be applied on  and reduce it. Necessarily,  can be written  with  and   two -rules merging respectively  and .
\end{lemma}
{\bf Proof }We show this lemma by induction on the number of vertices of the graph. It is obvious that if  then, the only possible graphs are the following ones:

\VCDraw[.35]{
\begin{VCPicture}{(-15,-2)(15,8)}
\State[s_I]{(0,0)}{0}
\State[\Phi]{(12,0)}{fi}
\State[x]{(6,6)}{x}

\EdgeL{0}{x}{}\LabelL[.5]{\lambda}
\EdgeR{x}{fi}{}\LabelL[.5]{\lambda '}

\State[s_I]{(18,0)}{0}
\State[\Phi]{(30,0)}{fi}
\State[x]{(24,6)}{x}

\EdgeL{0}{x}{}\LabelL[.5]{\lambda}
\EdgeR{x}{fi}{}\LabelL[.5]{\lambda '}
\EdgeR{0}{fi}{}\LabelR[.5]{\lambda ''}


\end{VCPicture}
}

\noindent
and then, for the first one  with  in  and  in . For the second one  is -equivalent and  with  a -rule such that  ,  , ,  and . Then,   and  are  rules such that   for  and . Suppose now that  has  vertices. As it is -reducible, there exists a sequence of -rules which leads to one of the two previous basic cases.\cqfd 
 
 For the reduction process, we associate each vertex of  to a
subexpression. We define  to be the expression of the vertex .
At the beginning of the process,  is , the only letter
labelling edges reaching the vertex  (homogeneity of Glushkov
automata). For the vertices  and , we define
. When applying -rules, we associate a new
expression to each new vertex.  
With notations of figure \ref{KR1-rule}, the -rule induces
 with .
With notations of figure \ref{KR2-rule}, the -rule induces
.
And with notations of figures \ref{KR3a-rule} and \ref{KR3b-rule}, the
-rule induces .

\begin{proposition}\label{K-red}
Let  be a -graph without orbit. The graph  is a Glushkov -graph if and only if it is -reducible.
\end{proposition}
\noindent
{\bf (  )} This proposition will be proved by recurrence on the length of the expression. First for , we have only two proper -expressions which are  and , for . When , the Glushkov -graph has only two vertices which are  and  and the edge  is labeled with . Then the  rule can be applied. Suppose now that , then the Glushkov -graph of  has three vertices and is -reducible. Indeed, the -rule can be applied twice.

Suppose now that for each proper -expression  of length , its Glushkov -graph is -reducible. We then have to show that the Glushkov -graph of -expressions , ,  and  of length  are -reducible. Let us denote by  (respectively ) the sequence of rules which can be applied on  (respectively ). In case ,  (respectively ).

\begin{itemize}
\item[case ] We have , , ,  and , . Every rule which can be applied on  and which does not modify the edge  can also be applied on . 

If  has only two states, then  a -rule, and then  a - rule where  is such that . Elsewhere, the  edge can only be reduced by a  rule. 

Suppose now that  there is no  rule modifying  which can be applied on . Then there is a  rule  which can be applied on  with  and then   can be reduced by .

Let us now suppose that  is the subsequence of -rules of  which modify the  edge. Necessarily,  acts on a state  which is -equivalent. If  or  then  where  in  is modified  as follows:  is quasi--equivalent with  and the rule  is a  rule on a state  which is -equivalent and . Elsewhere, there is two cases to distinguish. If  then the  rule is no more applicable on  (no edge between  and ) and the  rule in  now acts on an  -equivalent  vertex in . If  then  can be applied on  with .
\item[case ] If , we have, , , ,  and ,  and . In this case,  where  is a  rule with  and ,  and so  is -reducible.
\item[case ]  If , we have, , , ,  and ,  and , .
Let  be the subsequel of -rules modifying edges reaching . Necessarily,  and  (Lemma \ref{2R1}).
Indeed, let us suppose that  and that there exists  such that  is a , , or -rule. Necessarily  , which contradicts our hypothesis. Then we have  where  the -rule from a vertex  to   of the sequence  and labeled with  is modified in  as follows: . We have also  for the rule .


\end{itemize}
The case  is proved similarily as the previous one considering the rules modifying edges from  (with  instead of ). \\

\noindent
{\bf (  )} By induction on the number of states of the reducible -graph .
If ,  and the only -expression  is
 with . Let  be the Glushkov
-graph obtained from . By construction
 and , necessarily .

We consider the property true for ranks bellow  and  a
-graph partially reduced.
Three cases can occur according to the graphic form of the partially
reduced graph.
Either we will have to apply twice the -rule or once the -rule and twice the -rule if , or we will
have to apply once the -rule and twice the -rule if
. For each case, we compute successively the new
expressions of vertices, and we check that the Glushkov
construction applied on the final -expression is .
\cqfd


\subsection{Several examples of use for -rules}
For the  rule, the first example is for transducers in () where ``'' denotes the concatenation operator. In this case, we can express the  rule conditions as follows. For all  in ,   is the  common prefix of  and . Likewise, for all  in ,  is the  common suffix of  and  .

\medskip
\VCDraw[.85]{
\begin{VCPicture}{(-3,-2)(20,2)}
\State[p_2]{(0,-1.5)}{p2}
\State[p_1]{(0,1.5)}{p1}
\State[y]{(4,-1.5)}{y}
\State[x]{(4,1.5)}{x}
\State[q_2]{(8,-1.5)}{q2}
\State[q_1]{(8,1.5)}{q1}
\EdgeL{p1}{x}{}\LabelL[.5]{aa}
\EdgeR{p1}{y}{}\LabelL[.3]{ab}
\EdgeR{p2}{y}{}\LabelR[.6]{b}
\EdgeL{p2}{x}{}\LabelL[.2]{a}
\EdgeL{x}{q1}{}\LabelL[.5]{aba}
\EdgeL{x}{q2}{}\LabelL[.3]{aa}
\Edge{y}{q1}{}\LabelL[.2]{bba}
\Edge{y}{q2}{}\LabelR[.5]{ba}
\State[p_2]{(12,-1.5)}{p2a}
\State[p_1]{(12,1.5)}{p1a}
\StateVar[a E(x) a + b E(y) b]{(17,0)}{xy}
\State[q_2]{(22,-1.5)}{q2a}
\State[q_1]{(22,1.5)}{q1a}
\EdgeL{p1a}{xy}{}\LabelL[.3]{a}
\EdgeL{p2a}{xy}{}\LabelL[.3]{\varepsilon}
\EdgeL{xy}{q1a}{}\LabelL[.7]{ba}
\EdgeL{xy}{q2a}{}\LabelL[.7]{a}

\end{VCPicture}
}
\medskip

The second one is in (), where  are elements of the quaternions and  is the sum and  the product.  In this case,  is a field. Every factorization leads to the result.

\medskip
\VCDraw[.85]{
\begin{VCPicture}{(-3,-2)(20,2)}
\State[p_2]{(0,-1.5)}{p2}
\State[p_1]{(0,1.5)}{p1}
\State[y]{(4,-1.5)}{y}
\State[x]{(4,1.5)}{x}
\State[q_2]{(8,-1.5)}{q2}
\State[q_1]{(8,1.5)}{q1}
\EdgeL{p1}{x}{}\LabelL[.5]{2i}
\EdgeR{p1}{y}{}\LabelL[.3]{j}
\EdgeR{p2}{y}{}\LabelR[.6]{-k}
\EdgeL{p2}{x}{}\LabelL[.2]{2}
\EdgeL{x}{q1}{}\LabelL[.5]{3j}
\EdgeL{x}{q2}{}\LabelL[.3]{j}
\Edge{y}{q1}{}\LabelL[.2]{2k}
\Edge{y}{q2}{}\LabelR[.5]{2k}
\State[p_2]{(12,-1.5)}{p2a}
\State[p_1]{(12,1.5)}{p1a}
\StateVar[2i E(x) 1 + j E(y) 2i]{(17,0)}{xy}
\State[q_2]{(22,-1.5)}{q2a}
\State[q_1]{(22,1.5)}{q1a}
\EdgeL{p1a}{xy}{}\LabelL[.3]{1}
\EdgeL{p2a}{xy}{}\LabelL[.3]{-i}
\EdgeL{xy}{q1a}{}\LabelL[.7]{3j}
\EdgeL{xy}{q2a}{}\LabelL[.7]{j}

\end{VCPicture}
}
\medskip


We now give a complete example using the three rules on the () semiring. This example enlightens the reader on the problem of the quasi-epsilon equivalence. For this example, we will identify the vertex with its label.


\medskip
\VCDraw[.50]{
\begin{VCPicture}{(0,-6)(40,5)}
\State[s_I]{(0,0)}{0}
\State[y]{(8,0)}{y}
\State[x]{(8,4)}{x}
\State[z]{(8,-3)}{z}
\State[\Phi]{(18,0)}{fi}
\EdgeL{0}{x}{}\LabelL[.5]{2}
\EdgeR{0}{y}{}\LabelL[.6]{6}
\EdgeR{0}{z}{}\LabelL[.6]{2}
\VArcR{arcangle=-50,ncurv=.8}{0}{fi}{3}
\EdgeR{x}{y}{}\LabelR[.6]{5}
\EdgeL{x}{fi}{}\LabelL[.6]{6}

\Edge{y}{fi}{}\LabelL[.35]{2}
\Edge{z}{fi}{}\LabelR[.5]{0}

\State[s_I]{(24,0)}{0a}
\State[y]{(32,0)}{ya}
\State[x]{(32,4)}{xa}
\State[z]{(32,-3)}{za}
\State[\Phi]{(42,0)}{fia}
\EdgeL{0a}{xa}{}\LabelL[.5]{0\otimes 2}
\EdgeR{0a}{ya}{}\LabelL[.6]{0\otimes 6\otimes 0}
\EdgeR{0a}{za}{}\LabelL[.6]{2}
\VArcR{arcangle=-50,ncurv=.8}{0a}{fia}{0\otimes 6\otimes 1\oplus 3}
\EdgeR{xa}{ya}{}\LabelL[.6]{5\otimes 0}
\EdgeL{xa}{fia}{}\LabelL[.6]{5\otimes 1}

\Edge{ya}{fia}{}\LabelL[.35]{2}
\Edge{za}{fia}{}\LabelR[.5]{0}

\rput[lt](23,-7.2){\Large  rule can be applied on  with ,  and }
\end{VCPicture}
}

\VCDraw[.50]{
\begin{VCPicture}{(0,-8)(40,9)}
\State[s_I]{(0,0)}{0}
\State[y]{(8,0)}{y}
\StateVar[2 x 5 + 6]{(8,4)}{x}
\State[z]{(8,-3)}{z}
\State[\Phi]{(18,0)}{fi}
\EdgeL{0}{x}{}\LabelL[.5]{0}
\EdgeL{x}{fi}{}\LabelL[.5]{0\otimes 1\otimes 0}
\EdgeR{0}{z}{}\LabelR[.6]{2}
\VArcR{arcangle=-50,ncurv=.8}{0}{fi}{3}
\EdgeR{x}{y}{}\LabelR[.6]{0\otimes 0}

\Edge{y}{fi}{}\LabelL[.35]{2\otimes 0}
\Edge{z}{fi}{}\LabelR[.5]{0}

\State[s_I]{(24,0)}{0a}
\StateVar[0 y 2 + 1]{(32,0)}{ya}
\StateVar[2 x 5 + 6]{(32,4)}{xa}
\State[z]{(32,-3)}{za}
\State[\Phi]{(42,0)}{fia}
\EdgeL{0a}{xa}{}\LabelL[.5]{0}
\EdgeR{0a}{za}{}\LabelR[.6]{2}
\VArcR{arcangle=-50,ncurv=.8}{0a}{fia}{3}
\EdgeR{xa}{ya}{}\LabelR[.6]{0}

\Edge{ya}{fia}{}\LabelL[.35]{0}
\Edge{za}{fia}{}\LabelR[.5]{0}

\rput[lt](0,-7.2){\Large  rule can be applied on }
\rput[lt](0,-8.2){\Large with ,  and }
\rput[lt](24,-7.2){\Large  rule can be applied on  and on }

\end{VCPicture}
}


\VCDraw[.75]{
\begin{VCPicture}{(0,-6)(20,5)}
\State[s_I]{(0,-1)}{0a}
\State[z]{(6,-1)}{za}
\State[\Phi]{(12,-1)}{fia}
\LargeState \StateVar[(2 x 5 + 6)(0 y 2 + 1)]{(6,2)}{xa}
\EdgeL{0a}{xa}{}\LabelL[.3]{0}
\EdgeR{0a}{za}{}\LabelR[.5]{2}
\VArcR{arcangle=-30,ncurv=.8}{0a}{fia}{3}
\EdgeL{xa}{fia}{}\LabelL[.8]{0}
\Edge{za}{fia}{}\LabelR[.5]{0}
\MediumState
\State[s_I]{(15,-1)}{0}
\State[\Phi]{(31,-1)}{fi}
\LargeState \StateVar[(2 x 5 + 6)(0 y 2 + 1) + 2 z]{(23,2)}{x}
\EdgeL{0}{x}{}\LabelL[.5]{0}
\EdgeL{0}{fi}{3}

\EdgeL{x}{fi}{}\LabelL[.5]{0}

\rput[lt](0,-4.2){\Large  rule can be applied on}
\rput[lt](0,-5.2){\Large  and on }
\rput[lt](15,-3.2){\Large A  rule can be applied to end the process}

\end{VCPicture}
}


\bigskip

\noindent
This example leads to a possible -expression such as 



\section{Glushkov -graph with orbits}

We will now consider a graph which has at least one maximal orbit . We extend the notions of strong stability and strong transversality to the -graphs obtained from -expressions in SNF.
We have to give a characterization on coefficients only. 
The stability and transversality notions are rather linked. Indeed, if we consider the states of  as those of  then both notions amount to the transversality. Moreover, the extension of these notions to WFAs (-stability - definition \ref{Kstable} - and -transversality - definition \ref{Ktransverse}), implies the manipulation of output and input vectors of  whose product is exactly the orbit matrix of  (Proposition \ref{Kbal}). 

\begin{lemma}\label{orbit=star}
Let  be a -expression and  its Glushkov -graph. Let  be a maximal orbit of . Then  contains a closure subexpression  such that .
\end{lemma}  
This lemma is a direct consequence of Lemma 4.5 in \cite{CZ97} and of Lemma \ref{rat1}.
\begin{definition}[-stability]\label{Kstable}
A maximal orbit  of a -graph  is -stable if 
\begin{itemize} 
\item  is stable and
\item the matrix  such that
, for each  of ,  can be written
as a product  of two vectors such that  and .
\end{itemize}
The graph  is -stable if each of its maximal orbits is -stable.
\end{definition}

If a maximal orbit  is -stable,  is a matrix of rank  called the {\it orbit matrix}. Then, for a decomposition of  in the product  of two vectors,  will be called the {\it tail-orbit vector} of  and  will be called the {\it head-orbit vector} of . 
\begin{lemma}\label{lmKstable}
A Glushkov -graph obtained from a -expression  in SNF is -stable.
\end{lemma}
{\bf Proof }
Let  be the Glushkov -graph of a -expression  in SNF,  its Glushkov WFA  and  be a maximal orbit of G. 
Following Lemma \ref{rat1} and Theorem \ref{th},  is strongly stable which implies that every orbit of  is stable. 
Let ,  and , . Following the extended Glushkov construction and as for all , , we have . As  corresponds to a closure subexpression  or  (Lemma \ref{orbit=star}) and as  is an edge of , we have . As  is in SNF, so are  and ,  and then . The lemma is proved  choosing  such that   and  with .
\cqfd

\begin{definition}[-transversality]\label{Ktransverse}
A maximal orbit  of  is -transverse if 
\begin{itemize} 
\item   is transverse,
\item the matrix  such that   for each  of , can be written
as a product  of two vectors such that  and
,
\item the matrix  such that
 for each  of , can be written
as a product  of two vectors such that  and .
\end{itemize}
The graph  is -transverse if each of its maximal orbits is -transverse.
\end{definition}

If a maximal orbit  is -transverse,  (respectively ) is a matrix of rank  called the {\it input matrix} of  (respectively {\it output matrix} of ). For a decomposition of  (respectively ) in the product  (respectively ) of two vectors,  will be called the {\it input vector} (respectively  will be called the {\it output vector}) of . 

\begin{lemma}\label{lmKtransverse}
The Glushkov -graph  of a -expression  in SNF is -transverse.
\end{lemma}
{\bf Proof }
Let  be a maximal orbit of G.  Following Lemma \ref{rat1} and Theorem \ref{th},  is strongly transverse implies that  is transverse. By Lemma  \ref{orbit=star}, there exists a maximal closure subexpression  such that  or . As  is in SNF, so is . By the definition of the function {\it Follow}, we have in this case: for all , for all , . We now have to distinguish three cases. 
\begin{enumerate}
\item If , then the result holds immediatly. Indeed the output matrix of  is a vector.
\item If  and , , necessarily, we have  with  some subexpressions of . Then we have  if . Then as  is a first position of only one subexpression,   where  which concludes this case.
\item Now if  then  where  is the  value of some subexpression following  not depending on .
\end{enumerate}
 A same reasoning can be used for the left part of the transversality. \cqfd 
 
 \begin{definition}[-balanced]
The orbit  of a graph  is -balanced if   is -stable and  -transverse and if there exists  an input vector  of  and  an output vector  of  such that the orbit matrix . The graph  is -balanced if every maximal orbit of  is -balanced.
\end{definition}

\begin{proposition}\label{Kbal}
A Glushkov -graph obtained from a -expression  in SNF is -balanced. 
\end{proposition}
{\bf Proof }
 Lemma  \ref{lmKstable} enlightens on the fact that , the tail orbit vector of , is  such that  for all , which is, from Lemma  \ref{lmKtransverse}, the output vector of .
The details of the proofs for these lemmas show in the same way that there exists an  head-orbit vector and an  input vector for    which are equal.
\cqfd

We can now define the recursive version of WFA -balanced property.

\begin{definition}
A -graph is strongly -balanced  if (1) it has no orbit or (2) it is -balanced and if after deleting all edges  of each maximal orbit , it is strongly -balanced.
\end{definition}


\begin{proposition}\label{K-prop}
A Glushkov -graph obtained from a -expression  in SNF is strongly -balanced.
\end{proposition}
{\bf Proof }
Let  be the Glushkov of a -expression  and  be a maximal orbit of G. The Glushkov -graph  is strongly stable and strongly transverse. As  is in , edges of  that are deleted are backward edges of a unique closure subexpression  or . Consequently, the recursive process of edges removal deduced from the definition of strong -stability produces only maximal orbits which are -balanced. The orbit  is therefore strongly -balanced.
\cqfd

\begin{theorem}
Let .  is a Glushkov -graph of a -expression  in SNF if and only if
\begin{itemize}
\item  is strongly -balanced.
\item The graph without orbit of  is -reducible.
\end{itemize}
\end{theorem}
{\bf Proof } Let  be a Glushkov -graph. From Proposition \ref{K-prop},  is strongly -balanced. The graph without orbit of  is -reducible (Proposition \ref{K-red})
For the converse part of the theorem, if  has no orbit and  is -reducible, by Proposition  \ref{K-red} the result holds immediatly. Let  be a maximal orbit of . As it is strongly -balanced, we can write  the orbit matrix of , there exists an output vector  equal to the tail-orbit vector  and an input vector  equal to the head-orbit vector . If the graph without orbit of  corresponds to a -expression  then  corresponds to the -expression  where ,  . We have also ,  and . Hence the Glushkov functions are well defined. 

We now have to show that the graph without orbit of  can be reduced to a single vertex. By the successive applications of the -rules, the vertices of the graph without orbit of  can be reduced to a single state (giving a -rational expression for ). Indeed, as  is transverse, no -rule concerning one vertex of  and one vertex out of  can be applied. 

\cqfd

\section{Algorithm for orbit reduction}
In this section, we present a recursive algorithm that computes a -expression from a Glushkov -graph. We then give an example which illustrate this method.
\subsection*{Algorithms}
{\small 
\begin{algorithm}[H]
\begin{algo}{OrbitReduction}{G}
\IN { A -graph }
\OUT {A newly computed graph without orbit}

\DOFOREACH{\mbox{maximal orbit }\O=(X_\O,U_\O)\mbox{ of }G}
\IF{\CALL{BackEdgesRemoval}{\O,T,T',Z,Z'}}
\IF{\CALL{OrbitReduction}{\O}}
\IF{\CALL{Expression}{E_{\O},\O,T,T'}}
\CALL{ReplaceStates}{G,\O,E_{\O},Z,Z'}
\ELSE
\RETURN{False}
\FI
\ELSE
\RETURN{False}
\FI
\ELSE
\RETURN{False}
\FI
\OD
\RETURN{True}
\end{algo} 
\end{algorithm}
}

The {\sc BackEdgesRemoval} function on  deletes edges from  to , returns true if vectors  (as defined in definition \ref{Ktransverse}) can be computed, false otherwise.

The {\sc Expression} function returns true, computes the -expression  of  where  and  ouputs  if  is -reducible. It returns false otherwise.

The {\sc ReplaceStates} function replaces  by one state  labeled  and connected to  and  with the sets of coefficients of  and . Formally  with .\\

{\small
\begin{algorithm}[H]
\begin{algo}{BackEdgesRemoval}{\O,M_e, M_s,T,T',Z,Z'}
\IN { a -graph , }
\IN{ }
\OUT{, ,,} 

\DOFOREACH {\mbox{line }l\mbox{ of }M_e}
\SET{\mbox{gcd}_l(l)}{\mbox{{\sc left gcd} of all values of the line } l}
\OD
\COM{ is the vector of  values} 
\STATE{Find a vector  such that }
\IF {\b{\mbox{gcd}_l}\mbox{ does not exist}}
\RETURN{False}
\FI

\DOFOREACH {\mbox{column }c\mbox{ of }M_s}
\SET{\mbox{gcd}_r(c)}{\mbox{{\sc right gcd} of all values of the column } c}
\OD
\COM{ is the vector of  values} 
\STATE{Find a vector  such that }
\IF {\b{\mbox{gcd}_r}\mbox{ does not exist}}
\RETURN{False}
\FI

\STATE{Find  such that }
\COM{ is the orbit matrix of }
\IF{k \mbox{ does not exist}}
\RETURN{False}
\FI

\SET{A}{\mbox{{\sc right gcd} of all values of the }\mbox{gcd}_l\mbox{ vector}}
\SET{B}{\mbox{{\sc left gcd} of all values of the }\mbox{gcd}_r\mbox{ vector}}

\SET{k_1}{\CALL{left gcd}{B,k}}
\STATE{Find  such that } 
\IF{\CALL{right gcd}{k_2,A}\neq k_2}
\RETURN{False}
\FI
\SET{T}{k_2\otimes \b{\mbox{gcd}_l}}
\SET{T'}{\b{\mbox{gcd}_r}\otimes k_1}
\STATE{Find  such that }
\STATE{Find  such that }

\STATE {delete any edge from  to }

\RETURN{True}
\end{algo}
\end{algorithm}
}

\subsection*{Illustrated example}

We illustrate Glushkov WFAs characteristics developped in this paper  with a reduction example in the  semiring. This example deals with the reduction of an orbit and its connection to the outside. We first reduce the orbit to one state and replace the orbit by this state in the original graph. This new state is then linked to the predecessors (respectively successors) of the orbit with vector  (respectively ) as label of edges.

Let  be the -subgraph of Figure \ref{fig-example} and let  be the only maximal orbit of  such that .




\begin{figure}[H]
\VCDraw[0.8]{
\begin{VCPicture}{(-8,-4.5)(16,5)}
\State[p_1]{(-2,1)}{p1}
\State[p_2]{(-2,-1)}{p2}

\State[q_1]{(16,2)}{q1}
\State[q_2]{(16,0)}{q2}
\State[q_3]{(16,-2)}{q3}

\State[a_1]{(3,2)}{e1}
\State[b_2]{(3,0)}{e2}
\State[c_3]{(3,-2)}{e3}

\State[b_5]{(8,0)}{y}
\State[a_4]{(6,0)}{x}

\State[b_6]{(11,-1.5)}{s2}
\State[c_7]{(11,1.5)}{s1}




\EdgeL{p1}{e1}{}\LabelL[.6]{4}
\EdgeL{p1}{e2}{}\LabelL[.8]{2}
\EdgeL{p1}{e3}{}\LabelL[.8]{2}
\EdgeL{p2}{e1}{}\LabelL[.1]{5}
\EdgeL{p2}{e2}{}\LabelR[.4]{3}
\EdgeL{p2}{e3}{}\LabelR[.6]{3}



\EdgeL{e1}{x}{}\LabelL[.5]{0}
\EdgeL{e2}{x}{}\LabelL[.5]{3}
\EdgeL{e3}{x}{}\LabelL[.5]{2}

\EdgeL{x}{y}{}\LabelL[.5]{0}

\EdgeL{y}{s1}{}\LabelL[.5]{4}
\EdgeL{y}{s2}{}\LabelL[.5]{5}

\EdgeL{s1}{q1}{}\LabelL[.5]{1}
\EdgeL{s2}{q1}{}\LabelR[.9]{3}
\EdgeL{s1}{q2}{}\LabelL[.4]{2}
\EdgeL{s2}{q2}{}\LabelR[.4]{4}
\EdgeL{s1}{q3}{}\LabelR[.3]{3}
\EdgeL{s2}{q3}{}\LabelR[.4]{5}



\ArcR{s1}{e1}{}\LabelR[.5]{2}
\VArcR{arcangle=-45,ncurv=1.5}{s1}{e2}{}\LabelR[.5]{0}
\VArcR{arcangle=50,ncurv=1.5}{s1}{e3}{}\LabelL[.5]{0}


\VArcL{arcangle=-50,ncurv=1.5}{s2}{e1}{}\LabelR[.5]{4}
\VArcL{arcangle=45,ncurv=1.5}{s2}{e2}{}\LabelL[.5]{2}
\ArcL{s2}{e3}{}\LabelL[.5]{2}
\end{VCPicture}
}
\caption{An example for orbit reduction}\label{fig-example}
\end{figure}

\medskip



We have ,
. We can check that  is -transverse.  and .\\ 

We then verify that the orbit  is -stable.
.
 We easily check that the orbit is -balanced. There is an input vector  which is equal to  and an output vector  which is equal to .\\
 
Then, we delete back edges and add  and  vertices for the orbit . The  vertex is connected to . Labels of edges are values of the   vector.
Every vertex of  is connected to . Labels of edges are values of the  vector. The following graph is then reduced to one state by iterated applications of -rules. 

\VCDraw[1]{
\begin{VCPicture}{(-4,-2.5)(16,2.5)}
\State[s_I]{(-1,0)}{pi}
\State[\Phi]{(15,0)}{qj}
\State[a]{(3,2)}{e1}
\State[b]{(3,0)}{e2}
\State[c]{(3,-2)}{e3}

\State[b]{(8,0)}{y}
\State[a]{(6,0)}{x}

\State[c]{(11,-1.5)}{s2}
\State[b]{(11,1.5)}{s1}

\EdgeL{pi}{e1}{}\LabelL[.6]{2}
\EdgeL{pi}{e3}{}\LabelR[.6]{0}
\EdgeL{s2}{qj}{}\LabelR[.4]{2}
\EdgeL{pi}{e2}{}\LabelL[.6]{0}
\EdgeL{s1}{qj}{}\LabelL[.4]{0}





\EdgeL{e1}{x}{}\LabelL[.5]{0}
\EdgeL{e2}{x}{}\LabelL[.5]{3}
\EdgeL{e3}{x}{}\LabelL[.5]{2}

\EdgeL{x}{y}{}\LabelL[.5]{0}

\EdgeL{y}{s1}{}\LabelL[.5]{4}
\EdgeL{y}{s2}{}\LabelL[.5]{5}

\end{VCPicture}
}


 The expression  associated to this graph is replaced by  and states of  (respectively ) are connected to the newly computed state choosing  as vector of coefficients (respectively ).


\VCDraw[1]{
\begin{VCPicture}{(-4,-2)(16,2)}
\State[p_1]{(0,1)}{p1}
\State[p_2]{(0,-1)}{p2}


\State[q_1]{(15,1)}{q1}
\State[q_2]{(15,0)}{q2}
\State[q_3]{(15,-1)}{q3}

\FixStateDiameter{2cm}
\StateVar[\big( (2a+b3+c2)\cdotp a\cdotp  b\cdotp (4b+5c2)\big) ^{\small +}]{(7.5,0)}{e1}
\MediumState


\EdgeL{p1}{e1}{}\LabelL[.5]{2}
\EdgeL{p2}{e1}{}\LabelL[.5]{3}
\EdgeL{e1}{q1}{}\LabelL[.5]{1}
\EdgeL{e1}{q2}{}\LabelL[.5]{2}
\EdgeL{e1}{q3}{}\LabelL[.5]{3}

\end{VCPicture}
}
\medskip

\section{Conclusion}
While trying to characterize Glushkov -graph, we have pointed out an error in the paper by Caron and Ziadi \cite{CZ97} that we have corrected. This patching allowed us to extend characterization to -graph restricting  to  factorial semirings or fields. For fields, conditions of applications of -rules are sufficient to have an algorithm.\\

For the case of strict semirings,
this limitation allowed us to work with {\sc gcd} and then to give algorithms of computation of -expressions from Glushkov -graphs. 

This characterization is divided into two main parts. The first one is the reduction of an acyclic Glushkov -graph into one single vertex labeled with the whole -expression. We can be sure that this algorithm ends without doing a depth first search according to confluence of -rules. The second one is lying on orbit properties. These criterions allow us to give an algorithm computing a single vertex from each orbit.

In case the expression is not in SNF or the semiring is not zero-divisor free, some edges are computed in  several times (coefficients are -added) which implies that some edges may be deleted. Then this characterization does not hold. A question then arises: the factorial condition is a sufficient condition to have an algorithm. Is it also a necessary condition ? 



{\small
\bibliographystyle{plain}
\bibliography{/Users/pacot/TEX/BIBLIO/biblio,/Users/pacot/TEX/BIBLIO/mar-bib}
}
\end{document}
