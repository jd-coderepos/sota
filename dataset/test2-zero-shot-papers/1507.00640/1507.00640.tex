\documentclass[a4paper,UKenglish]{lipics}


\usepackage{microtype}\usepackage[utf8]{inputenc}
\usepackage{algorithm2e}
\usepackage{tikz}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{xspace}							

\usetikzlibrary{arrows,positioning}



\bibliographystyle{plain}

\title{Fixed parameter complexity of distance constrained labeling and uniform channel assignment problems
\footnote{Paper supported by project Kontakt LH12095 and by GAUK project 1784214.}\footnote{Second, third and fourth author are supported by the project SVV--2015--260223. First, third and fifth author is supported by project CE-ITI P202/12/G061 of GA ČR.}}
\titlerunning{Distance constrained labeling} 

\author[1]{Jiří Fiala}
\author[1]{Tomáš Gavenčiak}
\author[1]{Dušan Knop}
\author[1]{Martin Koutecký}
\author[1]{Jan Kratochvíl}
\affil[1]{Department of Applied Mathematics, Charles University\\
  Malostranské nám. 25, Prague
  \texttt{\{fiala,gavento,knop,koutecky,honza\}@kam.mff.cuni.cz}
}
\authorrunning{J. Fiala, T. Gavenčiak, D. Knop, M. Koutecký and J. Kratochvíl} 

\Copyright{Jiří Fiala, Tomáš Gavenčiak, Dušan Knop, Martin Koutecký and Jan Kratochvíl}

\subjclass{G.2.2 Graph Theory}\keywords{distance labeling, channel assignment, bounded cliquewidth, bounded vertex cover, fixed parameter tractability}

\DeclareMathOperator{\dist}{{\rm dist}}
\DeclareMathOperator{\nd}{{\rm nd}}
\DeclareMathOperator{\nlc}{{\rm nlc}}
\DeclareMathOperator{\vc}{{\rm vc}}
\DeclareMathOperator{\len}{{\rm len}}

\newcommand{\cC}{{\mathcal C}}
\newcommand{\cT}{{\mathcal T}}
\newcommand{\cW}{{\mathcal W}}
\renewcommand{\P}{{\sf P}\xspace}
\newcommand{\NP}{{\sf{NP}}\xspace}
\newcommand{\FPT}{{\sf{FPT}}\xspace}
\newcommand{\N}{{\mathbb{N}}}

\newcommand{\bw}{{\mathbf w}}

\def\romanitems{
\renewcommand{\theenumi}{\roman{enumi}}
\renewcommand{\labelenumi}{(\theenumi)}
}

\theoremstyle{plain}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
\newtheorem{prob}[theorem]{Problem}



\serieslogo{}\volumeinfo {Billy Editor and Bill Editors}{2}{Conference title on which this volume is based on}{1}{1}{1}\EventShortName{}
\DOI{10.4230/LIPIcs.xxx.yyy.p}

\begin{document}

\maketitle

\begin{abstract}
  We study computational complexity of the class of distance-constrained graph labeling problems
from the fixed parameter tractability point of view. The parameters studied are 
neighborhood diversity and clique width. 



We rephrase the distance constrained graph labeling problem as
a specific uniform variant of the {\sc Channel Assignment} problem and show that this problem is fixed parameter tractable when 
parameterized by the neighborhood diversity together with the largest weight.
Consequently, every {\sc -labeling} problem is \FPT{} when parameterized by
the neighborhood diversity, the maximum  and .

Our results yield also \FPT{} algorithms for all {\sc -labeling} 
problems when parameterized by the size of a minimum vertex cover, answering an open question of
Fiala et al.: \emph{Parameterized complexity of coloring problems: Treewidth versus
vertex cover}. The same consequence applies on {\sc Channel Assignment} when the maximum weight is additionally
included among the parameters.



Finally, we show that the uniform variant of the {\sc Channel Assignment} problem becomes \NP-complete when 
generalized to graphs of bounded clique width. \end{abstract}

\section{Introduction}\label{s:intro}

The frequency assignment problem in wireless networks 
yields an abundance of various mathematical models and related problems.
We study a group of such discrete optimization problems in terms of parameterized
computational complexity, which is one of the central paradigms of
contemporary theoretical computer science. We study parameterization of the problems by
\emph{clique width} and particularly by \emph{neighborhood diversity} (), 
a graph parameter lying between clique width and the size of a minimum vertex cover.

All these problems are \NP-hard even for constant clique width,
including the uniform variant, as we show in this paper. 
On the other hand, we prove that they are in \FPT{} w.r.t. . 
Such fixed parameter tractability has been so far known only for the special case of 
labeling when parameterized by vertex cover~\cite{l:FGK09}.

\subsection{Distance constrained labelings}

Given a -tuple of positive integers , called \emph{distance constraints}, an -labeling of a graph is an assignment  of integer labels to the vertices of the graph satisfying the following condition: 
Whenever vertices  and  are at distance , the assigned labels differ by at least . 
Formally,  for all . 
Often only non-increasing sequences of distance constraints are considered.

Any -labeling is a graph coloring and vice-versa. Analogously, any coloring of the -th distance power of a graph is an -labeling. 
The concept of -labeling is attributed to Roberts by Griggs and Yeh~\cite{l:GY92}. 
It is not difficult to show that whenever  is an optimal -labeling within a range , 
then the so called \emph{span}  is a linear combination of ~\cite{l:GY92,l:Kral06}. 
In particular, a graph  allows an -labeling of span  if and only it has an -labeling of span  for any positive integer .

For the computational complexity purposes, we define the following class of decision problems:

\begin{prob}[\sc -labeling]~
\begin{center}
\begin{tabular} {|ll|}
      \hline
      {\bf Parameters:\enspace} & {\parbox[t]{27em}{Positive integers }}\\
      {\bf Input:\enspace} & {\parbox[t]{27em}{Graph , positive integer }}\\
      {\bf Question:\enspace}&\parbox[t]{27em}{Is there an  labeling of  using labels from the interval ?}\\
      \hline
\end{tabular}
\end{center}
\end{prob}

The {\sc -labeling} problem has been shown to be \NP-complete by Griggs and Yeh~\cite{l:GY92} 
by a reduction from {\sc Hamiltonian cycle} (with ). 
Fiala, Kratochvíl and Kloks~\cite{l:FKK01} showed that {\sc -labeling} 
remains \NP-complete also for all fixed ,
while for  it is solvable in linear time. 

Despite a conjecture that {\sc -labeling} remains \NP-complete on trees~\cite{l:GY92}, 
Chang and Kuo~\cite{l:ChK96} showed a dynamic programming algorithm for this problem, 
as well as for all {-labelings where  divides . 
All the remaining cases have been shown to be \NP-complete by Fiala, Golovach and Kratochvíl~\cite{l:FGK08}. 
For graphs of tree width 2, the same authors show that {\sc -labeling} is \NP complete already on series-parallel graphs~\cite{l:FGK05}. 
Note that these results imply \NP-hardness 
of {\sc -labeling} on graphs of clique width at most 3 and of {\sc -labeling} for clique width at most 9.

On the other hand, when  is fixed, then the existence of an -labeling of  can be expressed in MSO hence it allows a linear time algorithm on any graph of bounded clique width~\cite{t:KR01}.

Fiala et al.~\cite{l:FGK09} showed that the problem of {\sc -labeling} is \FPT{} when
parameterized by  together with the size of the vertex cover. 
They also ask for the complexity characterization of the related {\sc Channel Assignment} problem.
We extend their work to the broader class of graphs and, consequently, in our Theorem~\ref{thm:chaVC} we provide a solution for their open problem.


\subsection{Channel assignment}

Channel assignment is a concept closely related to distance constrained graph labeling. 
Here, every edge has a prescribed weight  and it is required
that the labels of adjacent vertices differ at least by the weight of the corresponding edge. 
The associated decision problem is defined as follows:

\begin{prob}[\sc Channel Assignment]~
\begin{center}
\begin{tabular} {|ll|}
      \hline
      {\bf Input:\enspace} & {\parbox[t]{27em}{Graph , a positive integer , edge weights }}\\
      {\bf Question:\enspace}&\parbox[t]{27em}{Is there a labeling  of the vertices of  by integers from 
                                                such that  for all ?}\\
      \hline
\end{tabular}
\end{center}
\end{prob}

The maximal edge weight is an obvious necessary lower bound for the span of any labeling. 
Observe that for any bipartite graph, in particular also for all trees, it is also an upper bound 
--- a labeling that assigns  to one class of the bipartition and  to the other class
satisfies all edge constraints. 
McDiarmid and Reed \cite{c:DR03} showed that it is \NP-complete to decide whether a graph of tree width  
allows a channel assignment of given span .
This \NP-hardness hence applies on graphs of clique width at most .
It is worth to note that for graphs of tree width , i.e. for subgraphs of series-parallel graphs,
the complexity characterization of the {\sc Channel Assignment} is still open. Only few partial results are known~\cite{c:Skvarek10},
among others that the {\sc Channel Assignment} is polynomially solvable on graphs of bounded tree width if the span  is bounded by a constant.

Any instance ,  of the {\sc -labeling} problem can straightforwardly be reduced to an instance  of the {\sc Channel Assignment} problem.
Here,  arises from  by connecting all pairs of vertices that are in  at distance at most , and for the edges of 
we let  whenever .

The resulting instances of {\sc Channel Assignment} have by the construction some special properties. We explore and generalize these to obtain a uniform variant of the {\sc Channel Assignment} problem.

\subsection{Neighborhood diversity}


Lampis significantly reduced (from the tower function to double exponential) the hidden constants of the generic polynomial algorithms for MSO model checking on graphs with bounded vertex cover~\cite{t:Lampis12}.
To extend this approach to a broader class of graphs he introduced a new graph parameter called the neighborhood diversity of a graph as follows:

\begin{definition}[Neighborhood diversity]
A partition  is called a \emph{neighborhood diversity decomposition} if it satisfies
\begin{itemize}
\item each  induces either an empty subgraph or a complete subgraph of , and
\item for each distinct  and  there are either no edges between  and , or every vertex of  is adjacent to all vertices of .
\end{itemize}
We write  to indicate that  and  belong to the same class of the decomposition.

The \emph{neighborhood diversity} of a graph , denoted by , is the minimum number of classes of a neighborhood diversity decomposition.
\end{definition}

Observe that for the optimal neighborhood diversity decomposition it holds that  is equivalent with 
. 
Therefore, the optimal neighborhood diversity decomposition can be computed in  time~\cite{t:Lampis12}.

Classes of graphs of bounded neighborhood diversity reside between classes of bounded vertex cover and graphs of bounded clique width. Several non-MSO problems, e.g. {\sc Hamiltonian cycle} not be solved in polynomial time on graphs of bounded clique width~\cite{t:Wanke94}. On the other hand, Fomin et al. stated more precisely that the {\sc Hamiltonian cycle} problem is -hard, when parameterized by clique width~\cite{t:FGLS10}.
In sequel, Lampis showed that some of these problems, including {\sc Hamiltonian cycle}, are indeed fixed parameter tractable on graphs of bounded neighborhood diversity~\cite{t:Lampis12}.

Ganian and Obdržálek~\cite{t:GO13} further deepened Lampis' results and showed that also  problems expressible in MSO
with cardinality constraints (cardMSO) are fixed parameter tractable when parameterized by  and/or .

It is easy to see that for a graph  it holds that 
where  is the size of minimal vertex cover of the graph . This is also used in more detail in the proof of 
Theorem~\ref{thm:chaVC}.

Observe that a sufficiently large -vertex graph of bounded neighborhood diversity can be described in significantly more effective way, namely by using only  space:

\begin{definition}[Type graph]
The \emph{type graph}  for a neighborhood diversity decomposition 
of a graph  is a vertex weighted graph on vertices , 
where each  is assigned weight , i.e. the size of the corresponding class of the decomposition. 
Distinct vertices  and  are adjacent in  if and only if the edges between the two corresponding classes  and  form a complete bipartite graph. Moreover,  contains a loop incident with vertex  if and only if the corresponding class  induces a clique. 
\end{definition}

\begin{figure}[ht!]
  \begin{tikzpicture}
  \tikzstyle{vrchol}=[circle, draw, inner sep=1pt, minimum width=3pt]
  \tikzstyle{node}=[fill=yellow!50, yellow!50]
  \tikzstyle{headder}=[font=\normalfont]
  
  \begin{scope}[shift={(0,4)},node distance=0.7cm]
    \node[headder] at (1.5,4) { and its -labelling};

    \draw[node] (0,0) circle (1cm);
    \node[vrchol](v1) at (0, 0.35) {7};
    \node[vrchol, below of=v1](v2) {5};

    \draw[node] (3,0) circle (1cm);
    \node[vrchol](v3) at (3,0) {3};

    \draw[node] (6,0) circle (1cm);
    \node[vrchol](v4) at (6,0) {8};

    \draw[node] (9,0) circle (1cm);
    \node[vrchol](v5) at (9, 0.35) {1};
    \node[vrchol, below of=v5](v6) {0};

    \draw[node] (12,0) circle (1cm);
    \node[vrchol](v7) at (12, 0.7) {7};
    \node[vrchol, below of=v7](v8) {9};
    \node[vrchol, below of=v8](v9) {5};

    \draw[node] (4.5,3) circle (1cm);
    \node[vrchol](v10) at (3.8, 3) {2};
    \node[vrchol, right of=v10](v11) {4};
    \node[vrchol, right of=v11](v12) {6};

    \draw (v1) edge (v2);
    \draw (v1) edge (v3);
    \draw (v2) edge (v3);
    \draw (v3) edge (v4);
    \draw (v4) edge (v5);
    \draw (v4) edge (v6);
    \draw (v5) edge (v7);
    \draw (v5) edge (v8);
    \draw (v5) edge (v9);
    \draw (v6) edge (v7);
    \draw (v6) edge (v8);
    \draw (v6) edge (v9);

    \draw (v7) edge (v8);
    \draw (v8) edge (v9);
    \draw (v7) edge[bend left] (v9);
    
    \draw (v3) edge (v10);
    \draw (v3) edge (v11);
    \draw (v3) edge (v12);
    \draw (v4) edge (v10);
    \draw (v4) edge (v11);
    \draw (v4) edge (v12);
    \draw (v10) edge (v11);
    \draw (v11) edge (v12);
    \draw (v10) edge[bend left] (v12);
  \end{scope}

  \begin{scope}[shift={(0,-0.5)},node distance=1cm]
    \node[headder] at (0,2.5) {};

    \node[vrchol](n1) at (0,0) {2};
    \node[vrchol, right of=n1](n2) {1};
    \node[vrchol, right of=n2](n3) {1};
    \node[vrchol, right of=n3](n4) {2};
    \node[vrchol, right of=n4](n5) {3};
    \node[vrchol](n6) at (1.5,1.5) {3};

    \path (n1) edge [out=230, in=310, distance=1cm] node[above] {} (n1);
    \path (n2) edge [out=230, in=310, distance=1cm] node[above] {} (n2);
    \path (n3) edge [out=230, in=310, distance=1cm] node[above] {} (n3);
    \path (n5) edge [out=230, in=310, distance=1cm] node[above] {} (n5);
    \path (n6) edge [out=50, in=130, distance=1cm] node[below] {} (n6);

    \path (n1) edge (n2);
    \path (n2) edge (n3);
    \path (n3) edge (n4);
    \path (n4) edge (n5);
    \path (n2) edge (n6);
    \path (n3) edge (n6);
    
  \end{scope}

  \begin{scope}[node distance=1.5cm,shift={(5.5,-0.5)}]
    \node[headder] at (0.5,2.5) { and };

    \node[vrchol](u1) at (0,0) {2};
    \node[vrchol, right of=u1](u2) {1};
    \node[vrchol, right of=u2](u3) {1};
    \node[vrchol, right of=u3](u4) {2};
    \node[vrchol, right of=u4](u5) {3};
    \node[vrchol](u6) at (2.25,1.5) {3};

    \path (u1) edge [out=230, in=310, distance=1cm] node[above] {2} (u1);
    \path (u2) edge [out=230, in=310, distance=1cm] node[above] {2} (u2);
    \path (u3) edge [out=230, in=310, distance=1cm] node[above] {2} (u3);
    \path (u4) edge [out=230, in=310, distance=1cm] node[above] {1} (u4);
    \path (u5) edge [out=230, in=310, distance=1cm] node[above] {2} (u5);
    \path (u6) edge [out=50, in=130, distance=1cm] node[below] {2} (u6);

    \path (u1) edge node[above] {2} (u2);
    \path (u2) edge node[above] {2} (u3);
    \path (u3) edge node[above] {2} (u4);
    \path (u4) edge node[above] {2} (u5);

    \path (u1) edge node[left] {1} (u6);
    \path (u2) edge node[left] {2} (u6);
    \path (u3) edge node[left] {2} (u6);
    \path (u4) edge node[left] {1} (u6);
    \path (u5) edge node[left] {1} (u6);

    \path (u1) edge[out=340, in=220, distance=1.5cm] node[below right] {1} (u3);
    \path (u1) edge[out=320, in=220, distance=3cm] node[below] {1} (u4);

    \path (u5) edge[out=190, in=320, distance=1.5cm] node[below left] {1} (u3);
    \path (u5) edge[out=220, in=340, distance=3cm] node[below] {1} (u2);
  \end{scope}
\end{tikzpicture}

   \caption{An example of a graph with its neighborhood diversity decomposition. 
	Vertex labels indicate one of its optimal -labelings. 
  The corresponding type graph. 
	The weighted type graph corresponding to the resulting instance of the {\sc Channel Assignment} problem.}
	\label{fig:labelExample}
\end{figure}

For our purposes, i.e. to decide existence of a suitable labeling of a graph , 
it suffices to consider only its type graph, as  can be uniquely reconstructed from  
(upto an isomorphism) and vice-versa.

Moreover, the reduction of {\sc -labeling} to {\sc Channel Assignment} preserves the property of bounded neighborhood diversity:

\begin{observation}
For any graph  and any positive integer  it holds that .
\end{observation}

\begin{proof}
The optimal neighborhood diversity decomposition of  is a neighborhood diversity decomposition of . 
\end{proof}

\subsection{Our contribution}\label{ss:our}

Our goal is an extension of the FPT algorithm for {\sc -labeling} on graphs of bounded vertex cover
to broader graph class and for rich collections of distance constraints.
In particular, we aim at {\sc -labeling} on graphs of bounded neighborhood diversity.

For this purpose we utilize the aforementioned reduction to the {\sc Channel Assignment}, taking into account that the
neighborhood diversity remains bounded, even though the underlying graph changes.

It is worth to note that we must adopt additional assumptions for the {\sc Channel Assignment} since otherwise 
it is \NP-complete already on complete graphs, i.e. on graphs with .
To see this, we recall the construction of Griggs and Yeh~\cite{l:GY92}. They show that a graph 
 on  vertices has a Hamiltonian path if and only if the complement  extended by a single universal vertex allows 
an -labeling of span . As the existence of a universal vertex yields diameter two, the underlying graph for the resulting instance of {\sc Channel Assignment} is .

On the other hand, the additional assumptions on the instances of {\sc Channel Assignment} still shall allow to reduce 
any instance of the {\sc -labeling} problem.
By the reduction, all edges between classes of the neighborhood diversity decomposition are assigned the same weight.
We formally adopt this as our additional constraint as follows:

\begin{definition}
The edge weights  on a graph  are \emph{-uniform} if  whenever  and 
w.r.t. the optimal neighborhood diversity decomposition. 
In a similar way we define uniform weights w.r.t. a particular decomposition.
\end{definition}

Our main contribution is an algorithm for the following scenario:

\begin{theorem}\label{thm:cha}
The {\sc Channel Assignment} problem on -uniform instances is \FPT{} when parameterized by  and , where .
\end{theorem}

Immediately, we get the following consequence:

\begin{theorem}\label{thm:Lp}
The  the {\sc -labeling} problem is \FPT{} when parameterized by ,  and maximum  (or equivalently by  and the -tuple ).
\end{theorem}

Furthermore, our \FPT{} result for {\sc Channel Assignment} extends to vertex cover even without the uniformity requirement.

\begin{theorem}\label{thm:chaVC}
The {\sc Channel Assignment} problem is \FPT{} when parameterized by  and the size of vertex cover.
\end{theorem}

One may ask whether the uniform version of {\sc Channel Assignment} allows an \FPT{} algorithm also for a broader class of graph.
Finally, we show that a natural generalization of this concept on graphs of bounded clique width yields an \NP-complete 
problem on graphs of clique width at most 5.
 \section{Representing labelings as sequences and walks}

We now focus on the -uniform instances of the {\sc Channel Assignment} problem.
It has been already mentioned that the optimal neighborhood diversity decomposition can be computed in cubic time. 
The test, whether it is -uniform, could be computed in extra quadratic time. 
On the other hand, on -uniform instances it suffices to consider only the type graph, whose edges take weights from the edges of the underlying graph (see Fig.~\ref{fig:labelExample}), since such weighted type graph corresponds 
uniquely to the original weighted graph, upto an isomorphism.

Hence without loss of generalization 
assume that our algorithms are given the type graph whose edges are weighted by separation constraints ,
however we express the time complexity bounds in terms of the size of the original graph.

Without loss of generality we may assume that the given graph  and its type graph  are connected, since connected components can be treated independently. 

If the type graph  contains a type  not incident with a loop, we may reduce the channel assignment 
problem to the graph , obtained from  by deleting all but one vertices of the type . 
Any channel assignment of  yields a valid channel assignment of  by using the same label on all vertices of type  in  as was given to the single vertex of type  in . Observe that adding a loop to a 
type, which represents only a single vertex, does not affect the resulting graph . Hence we assume without loss of generality that all types are incident with a loop. We call such type graph \emph{reflexive}. 

\begin{observation}\label{obs:refl}
If the type graph  is reflexive, then vertices of  of the same type have distinct labels in every channel assignment.
\end{observation}

Up to an isomorphism of the graph , any channel assignment  is uniquely characterized by a sequence of type sets as follows:

\begin{lemma}\label{lem:seq}
Any weighted graph  corresponding to a reflexive weighted type graph  
allows a channel assignment of span ,
if and only if there exists a sequence of sets 
 of the following properties:
\begin{enumerate}\romanitems
 \item  for each , 
 \item for each , 
 \item for all 
\end{enumerate}
\end{lemma}

\begin{proof}
Given a channel assignment , we define the desired sequence , such that the -th element is the set of types that contain a vertex labeled by . Formally .
Now
\begin{enumerate}\romanitems
\item each element of the sequence is a set of types, possibly empty,
\item as all vertices of  are labeled by distinct labels by Observation~\ref{obs:refl}, any type  occurs in  many elements of the sequence
\item if  of type  is labeled by , and it is adjacent to  of type  labeled by , then
, i.e. adjacent types  and  may appear in sets 
that are in the sequence at least  apart.
\end{enumerate}

In the opposite direction assume that the sequence  exists. Then for each set  and type  we choose a
distinct vertex  and label it by , i.e. .

Now the condition (ii) guarantees that all vertices are labeled, while condition (iii) guarantees that all distance constraints are fulfilled.
\end{proof}

Observe that Lemma~\ref{lem:seq} poses no constrains on sets  that are at distance at least . Hence, we build an auxiliary directed graph  on all possible sequences of sets of length at most .

The edges of  connect those sequences, that overlap on a fragment of length , i.e. when they could be consecutive in .
This construction is well known from the so called shift register graph.

\begin{definition}
For a general graph  and weights  we define a directed graph  such that 
\begin{itemize}
\item the vertices of  are all -tuples  of subsets of  such that for all 
\item  for all .
\end{itemize}
\end{definition}

As the first condition of the above definition mimics (iii) of Lemma~\ref{lem:seq} with , 
any sequence  that justifies a solution for , 
can be transformed into a walk of length  in . 

In the opposite direction, namely in order to construct a walk in , that corresponds to a valid channel assignment, we need to guarantee also an analogue of the condition (ii) of Lemma~\ref{lem:seq}. 
In other words, each type should occur sufficiently many times in the resulting walk.
Indeed, the construction of  is independent on the function , 
which specifies how many vertices of each type are present in .

In this concern we consider only special walks that allow us to count the occurrences of sets within -tuples.
Observe that  contains also the -tuple . In addition, any 
walk of length  can be converted into a closed walk from  of length , 
since the corresponding sequence  can be padded with additional  empty sets at the front, and another  at the end. From our reasoning, the following claim is immediate:

\begin{lemma}\label{lem:walk}
A closed walk  on  where ,
yields a solution of the {\sc Channel Assignment} problem 
on a -uniform instance  with reflexive , 
if and only if for each  holds that  .
\end{lemma}

We found interesting that our representation of the solution resembles the \NP-hardness reduction found by Griggs and Yeh~\cite{l:GY92} (it was briefly outlined in Section~\ref{ss:our}) and later generalized by Bodlaender et al.~\cite{l:BKTL00}. 
The key difference is that in their reduction, a Hamilton path is represented by a sequence of vertices of the constructed graph. 
In contrast, we consider walks in the type graph, which is assumed to be of limited size.

 \section{The algorithm}

In this section we prove the following statement, which directly implies our main result, Theorem~\ref{thm:cha}:

\begin{proposition}\label{prop:cha}
Let  be a weighted graph, whose weights are uniform with respect to a 
neighborhood diversity partition with  classes. 

Then the {\sc Channel Assignment} problem can be decided on  and any  in time ,
where  is the number of vertices of , provided that  are described by the weighted type graph  on  nodes.

A suitable labeling of  can be found in additional  time.
\end{proposition}

\begin{proof}
According to Lemma~\ref{lem:walk}, 
it suffices to find a closed walk  (if it exists) corresponding to the desired labeling . 
From the well know Euler's theorem follows that any directed closed walk  yields a multiset of edges in  
that induces a connected subgraph and that satisfies Kirchhoff's law.
In addition, any such suitable multiset of edges can be converted into a 
closed walk, though the result need not to be unique.



For this purpose we introduce an integer variable  for every directed edge .
The value of the variable  is the number of occurrences of  in the multiset of edges.

Kirchhoff's law is straightforwardly expressed as:



In order to guarantee the connectivity, observe first that an edge  and  would be 
in distinct components of a subgraph of ,
if the subgraph is formed by removing edges that include a cut  between  and .
Now, the chosen multiset of edges is disconnected from , if for some  and  holds that 
has a positive value, while all variables corresponding to elements of  are zeros.
As all variable values are upperbounded by , we express that  is not a cutset for the chosen multiset of 
edges by the following condition:



To guarantee the overall connectivity, we apply the above condition for every edge , 
where , and for each set of edges  
that separates  from . 

The necessary condition expressed in Lemma~\ref{lem:walk} can be stated in terms of variables  as



Finally, the size of the multiset is the length of the walk, i.e.



Observe that these conditions for all  and all suitable  indeed imply that the  
belongs to the subgraph induced by edges with positively evaluated variables .

Algorithm~\ref{alg:cha} summarizes our deductions.

\begin{algorithm}[h]
\KwIn{A reflexive type graph  whose edges are labeled by  and span .}
\KwOut{A channel assignment  respecting constraints , if it exists.}
\Begin{
\nl Compute \;
\nl Construct the directed graph \;
\nl Solve the following ILP in variables :\\
\Indp\Indp
\nl for each :\\
\Indp\Indp
 \\
\Indm\Indm
\nl for each :\\
\Indp\Indp
\\
\Indm\Indm
\nl for each  and each cutset  between  and  in :\\
\Indp\Indp
 \\
\Indm\Indm
\nl for each :\\
\Indp\Indp
 \\
\Indm\Indm
\nl \;
\Indm\Indm
\nl \eIf {the ILP has a solution}{
\nl find a walk  that traverses each edge  exactly  times\;
\nl convert the walk  into a labeling  and \Return {}\;
}{\nl \Return {"No channel assignment  of span  exists."}}
}
\caption{Solving the {\sc Channel Assignment} problem.}\label{alg:cha}
\end{algorithm}

To complete the proof, we argue about the time complexity as follows:
\begin{itemize}
\item Line 1 needs  time.
\item As  has  nodes and  edges, line 2 needs  time.
\item Similarly, conditions at lines 4 and 5
require  time and space to be composed. Analogously, conditions at lines 7 and 8 involve coefficients that are proportional to the size of the original graph  (namely  and ), hence  time and space is needed here.
\item For line 6, we examine each subset of , whether it is a suitable cutset .
There are at most  choices for , so the overall time and space complexity 
for the composition of conditions at line 6 is .
\item Frank and Tardos~\cite{m:FrankTardos87} (improving the former result due to Lenstra~\cite{m:Lenstra83}) showed that the time needed to solve the system of inequalities with  integer variables is , where  is the number of bits needed to encode the input. As we have  variables and the conditions are encoded in space , the time needed to resolve the system of inequalities is .
\item A solution of the ILP can be converted into the walk in time , and the same bound applies to the conversion of a walk to the labeling at lines 10 and 11.
\end{itemize}

Observe that if only the existence of the labeling should be decided, the lines 10 and 11 need not to be executed, only an affirmative answer needs to be returned instead.
\end{proof}

We are aware the the double exponential dependency on  and  makes our algorithm interesting 
mostly from the theoretical perspective. Naturally, one may ask, whether the exponential tower height might be reduced
or whether some nontrivial lower bounds on the computational complexity could be established 
(under usual assumptions on classes in the complexity hierarchy). 

\iffalse


Theorem~\ref{thm:Lp} follows from Theorem~\ref{thm:cha} straightforwardly. Given a graph  and distance constraints ,
we form an instance of {\sc Channel Assignment} as follows: We join vertices  that are originally at distance at most . We then assign  to any edge  of the resulting type graph, where  and  were originally at distance . In addition, each loop has assigned weight .

The equivalence of the two parameterizations follows from the fact that for a fixed  and maximum  there are only
 -tuples to consider, and we can join the \FPT{} algorithms for all these into one program always running the appropriate one.

It is worth noting that the neighborhood diversity and the type graph can be computed in  time~\cite{t:Lampis12}.

\fi
 \section{Bounded vertex-cover}\label{s:metaalg}

We utilize the results of the previous sections to derive an \FPT\ algorithm proposed as Theorem~\ref{thm:chaVC}. 

\begin{proof}[Proof of Theorem~\ref{thm:chaVC}]
Given a graph  and its optimal vertex cover , we construct a partition of the vertices of  as follows. 
Next let  be the independent set of . 
We form a partition of  as follows: For every subset  we define:


Observe that for any  it holds that , and hence also . 
In particular, the optimal neighborhood diversity decomposition of  consists of all nonempty sets  together with a suitable partition of . Consequently, .

\begin{figure}[ht!]
  \begin{tikzpicture}
  [align=center, node distance=0.7cm]
  \tikzstyle{vrchol}=[circle, draw, fill=black, inner sep=0pt, minimum width=4pt]
  \tikzstyle{vc}=[circle, draw, inner sep=1pt, minimum width=4pt]
  \tikzstyle{legenda}=[rectangle, minimum width=5pt]
  
\node[fill=yellow!40,thick,draw,yellow!30,
      minimum height=0.7cm,
      minimum width=3cm,
      label=west:Vertex cover ] at (6,2.5) {};
  \begin{scope}
    \node[vc](100) at (5, 2.5) {1};
    \node[vc, right of=100](101) {2};
    \node[vc, right of=101](102) {3};
    \node[vc, right of=102](103) {4};
  \end{scope}

\draw[fill=blue!20,blue!20] (-0.2,-0.6) -- (-0.2,0.2) -- (0.2,0.2) -- (0.2,-0.2) -- (4,-0.2) -- (4, 0.2) -- (4.4,0.2) -- (4.4,-0.6) -- cycle;
\draw[fill=blue!80, blue!80] (2.6,-0.2) -- (2.6,0.2) -- (3.7,0.2) -- (3.7,-0.2) --  cycle;
\draw[fill=green!20, green!20] (1-0.5,-0.2) -- (1-0.5,0.2) -- (.9,0.2) -- (.9,-0.2) --  cycle;
\draw[fill=green!40, green!40] (1.2,-0.2) -- (1.2,0.2) -- (2.3,0.2) -- (2.3,-0.2) --  cycle;
\draw[fill=green!80, green!80] (6.1,-0.6) -- (6.1,0.2) -- (6.5,0.2) -- (6.5,-0.2) -- (7.5,-0.2) -- (7.5,0.2) -- (7.9,0.2) -- (7.9,-0.6) -- cycle;
\draw[fill=blue!40, blue!40] (4.7,-0.2) -- (4.7,0.2) -- (5.1,0.2) -- (5.1,-0.2) --  cycle;
\draw[fill=blue!60, blue!60] (5.4,-0.2) -- (5.4,0.2) -- (5.8,0.2) -- (5.8,-0.2) --  cycle;
\draw[fill=orange!60, orange!60] (6.8,-0.2) -- (6.8,0.2) -- (7.2,0.2) -- (7.2,-0.2) --  cycle;
\draw[fill=brown!60, brown!60] (8.2,-0.2) -- (8.2,0.2) -- (8.6,0.2) -- (8.6,-0.2) --  cycle;
  
  \node[vrchol](1) at (0,0) {};
  \foreach \i [count=\q] in {2,...,13}
    \node[vrchol, right of=\q](\i){};

  \draw  (100) edge (1);
  \draw  (100) edge (2);
  \draw  (100) edge (5);
  \draw  (100) edge (6);
  \draw  (100) edge (7);

  \draw  (101) edge (1);
  \draw  (101) edge (3);
  \draw  (101) edge (4);
  \draw  (101) edge (7);
  \draw  (101) edge (8);
  \draw  (101) edge (11);
  \draw  (101) edge (1);
  
  \draw  (102) edge (5);
  \draw  (102) edge (6);
  \draw  (102) edge (8);
  \draw  (102) edge (9);
  \draw  (102) edge (11);
  
  \draw  (103) edge (9);
  \draw  (103) edge (10);
  \draw  (103) edge (11);
  \draw  (103) edge (12);

\draw[draw=black] (8.9,-.5) rectangle (12.2,2.7);
  \node at (10.5,2.4) {Colors of the sets};
  \node[legenda,fill=brown!60,label=east:] at (9.2,1.8) {};
  \node[legenda,fill=green!20,label=east:] at (9.2,1.3) {};
  \node[legenda,fill=green!60,label=east:] at (9.2,.8) {};
  \node[legenda,fill=green!80,label=east:] at (9.2,.3) {};
  
  \node[legenda,fill=blue!20,label=east:] at (11,1.8) {};
  \node[legenda,fill=blue!80,label=east:] at (11,1.3) {};
  \node[legenda,fill=blue!40,label=east:] at (11,.8) {};
  \node[legenda,fill=blue!60,label=east:] at (11,.3) {};
  \node[legenda,fill=orange!60,label=east:] at (10.1,-.2) {};
\end{tikzpicture}

   \caption{An example of a neighborhood diversity decomposition based on vertex cover---sets  in the bottom.}
\end{figure}

We further refine sets , so that the edge-weights became uniform. 
For a set  and each -tuple of positive integers  with  for every  we define the set  as


Observe that any refinement of a neighborhood diversity decomposition is again a decomposition. We now estimate the number of types of the refined decomposition. The number of types of the refined decomposition can be upper-bounded by  To finish the proof we apply Proposition~\ref{prop:cha} on the refined decomposition.
\end{proof}

\iffalse



This proof might be interesting on its own as it yields a general method for finding an \FPT{} algorithm for an edge-constrained problem parameterized by the size of vertex cover via its {\em uniform version} parameterized by the neighborhood diversity. 

If a problem {\sc P} with edge-constraints allows the existence of an
equivalence relation  on the set of edges, a bound  and a function
 such that the number of equivalence
classes of an independent set is at most , and
furthermore, if a problem {\sc Uniform P} admits an \FPT algorithm
when parameterized by neighborhood diversity, then the original problem {\sc P}
admits an \FPT algorithm when parameterized by  and .

Moreover, if there exists a function  such that  then problem {\sc P} becomes \FPT when parameterized by the size of vertex cover only.

\fi
 \section{NLC-uniform channel assignment}

One may ask whether the concept of -uniform weights could be extended to broader graph classes.
We show, that already its direct extension to graphs of bounded clique width makes the 
{\sc Channel Assignment} problem \NP-complete. Instead of clique width we express our 
results in terms of NLC-width~\cite{t:Wanke94} (NLC stands for node label controlled). 
The parameter NLC-width is linearly dependent on clique width, but it is technically simpler.

We now briefly review the related terminology. 
A NLC-decomposition of a graph  is a rooted tree whose leaves are in one-to-one correspondence 
with the vertices of . For the purpose of inserting edges, each vertex is given a label 
(the labels for channel assignment are now irrelevant), which may change during the construction of the graph .
Internal nodes of the tree are of two kinds: \emph{relabel} nodes and \emph{join} nodes.

Each relabel node has a single child and as a parameter takes a mapping  on the set of labels.
The graph corresponding to a relabel node is isomorphic to the graph corresponding to its child,
only  is applied on each vertex label.

Each join node has a two children and as a parameter takes a symmetric binary relation  on the set of labels.
The graph corresponding to a relabel node is isomorphic to the disjoint union of the two graphs  and 
corresponding to its children, where further edges are inserted as follows: 
 labeled by  is made adjacent to  labeled by  if and only if .

The minimum number of labels needed to construct at least one labeling of  
in this way is the NLC width of , denoted by .

Observe that  as the vertex types could be used as labels for the corresponding vertices
and the adjacency relation in the type graph could be used for  in all join nodes. 
In particular, in this construction the order of performing joins is irrelevant and no relabel nodes are needed.

\begin{definition}
The edge weights  on a graph  are \emph{-uniform} w.r.t. a particular 
NLC-decomposition, if  
whenever edges  and  are inserted during the same join operation
and at he moment of insertion  have the same label in  and  have the same label in .
\end{definition}

Observe that our comment before the last definition justifies 
that weights that are uniform w.r.t. a neighborhood diversity decomposition 
are uniform also w.r.t. the corresponding NLC-decomposition.

Gurski and Wanke showed that NLC-width remains bounded when taking powers~\cite{t:GW09}.
It is well known that NLC-width of a tree is at most three. Fiala et al. proved
that {\sc -labeling} is \NP-complete on trees~\cite{l:FGK08}. To combine these facts together 
we show that the weights on the graph arising from a reduction of the -labeling 
on a tree to {\sc Channel Assignment} are -uniform.

\begin{theorem}
The {\sc Channel Assignment} problem is \NP-complete on graphs with edge 
weights that are -uniform w.r.t. a NLC-decomposition of width at most four.
\end{theorem}

\begin{proof}
Let a tree  be an instance of the {\sc -labeling} problem.

By induction on the size of  we show that  allows an NLC-decomposition  
such that the weights  prescribed by the reduction of {\sc -labeling}
to {\sc Channel Assignment} are -uniform.

Assume for the induction hypothesis that such NLC-decomposition 
exists for every tree  on less than  vertices, 
where the labels of  are distributed as follows:
assume that  is rooted in a vertex , then  is labeled by , its direct neighbors by  and all other vertices by .

Such decomposition clearly exists for a tree on a single vertex.

Now consider a tree  on  nodes. Choose and edge  arbitrarily and define two trees  and  as the components of , where  contains  and vice versa.

\begin{figure}[ht!]
  \includegraphics{src/nlc.pdf}
  \caption{Recursive step in the construction of NLC-decomposition. The original edges of  and  are in black, 
	         only the added weighted edges of  are in color.}
	\label{fig:nlc}
\end{figure}

By induction hypothesis  and  allow NLC-decompositions of the desired properties.
Before we join trees  and  together, we change labels in  as .
At the join will insert the following weighted edges: of weight 3 between vertices labeled 1 in  and 2 in , 
and of weight 2 between vertices of labels 2 and 2, and between 1 and 4, respectively.
Finally, we relabel  and promote  to be the root  of . 
All steps are depicted in Fig.~\ref{fig:nlc}.  Observe that the result of this construction is 
with appropriate -uniform weights, and that its labeling satisfies all conditions of the induction hypothesis.
\end{proof}





 

 \section{Conclusion}\label{s:con}

We have shown an algorithm for the {\sc Channel Assignment} problem on -uniform instances 
and several complexity consequences for
{\sc -labeling} problem. In particular, Theorem~\ref{thm:Lp} extends known results
for -labelings problem to labelings with arbitrarily many distance constraints, answering
an open question of~\cite{l:FGK09}. Simultaneously, we broaden the considered graph classes by restricting
neighborhood diversity instead of vertex cover.

\begin{figure}[!ht]
  \begin{minipage}[c]{0.3\textwidth}
    \begin{tikzpicture}
  [align=center, node distance=1.5cm]
  \tikzstyle{parameter}=[inner sep=5pt]

  \node[parameter](cw) {cw};
  \node[parameter, below left of=cw](tw) {tw};
  \node[parameter, below right of=cw](mw) {mw};
  \node[parameter, below of=mw](nd) {nd};
  \node[parameter, below left of=nd](vc) {vc};

  \draw[->,line width=5mm,thick,dashed,>=stealth'] (tw) -- (cw);
  \draw[->,thick,dashed,>=stealth'] (vc) -- (nd);
  \draw[->,thick,>=stealth'] (mw) -- (cw);
  \draw[->,thick,>=stealth'] (nd) -- (mw);
  \draw[->,thick,>=stealth'] (vc) -- (tw);
  
\end{tikzpicture}
   \end{minipage}\hfill
  \begin{minipage}[c]{0.65\textwidth}
    \caption{A map of assumed parameters. Full arrow stands for linear upper bounds, while dashed arrow stands for exponential upper bounds.}
    \label{fig:parameterMap}
  \end{minipage}
\end{figure}

While the main technical tools of our alogorithms are bounded-dimension ILP programs, ubiquitous in the \FPT{} area,
the paper shows an interesting insight on the nature of the labelings over the type graph and the necessary
patterns of such labelings of very high span. Note that the span of a graph is generally not bounded by any of the
considered parameters and may be even proportional to the order of the graph.

Solving a generalized problem on graphs of bounded neighborhood diversity is a viable method
for designing \FPT{} algorithms for a given problem on graphs of bounded vertex cover, as demostrated by this and previous papers.
This promotes neighborhood diversity as a parameter that naturally generalizes the widely studied parameter vertex cover.

We would like to point out that the parameter {\em modular width}, proposed by Gajarský, Lampis and Ordyniak~\cite{t:GLO13}, offers further generalization of neighborhood diversity towards the clique width~\cite{t:CO00} (dependencies between these graph parameters are depicted in Fig.~\ref{fig:parameterMap}).

As an interesting open problem we ask whether it is possible to strengthen our results to graphs of bounded modular width
or whether the problem might be already \NP-complete for fixed modular width, as is the case with clique width.
For example, the {\sc Graph Coloring} problem ILP based algorithm for bounded neighborhood diversity translates
naturally to an algorithm for bounded modular width. On the other hand, there is no apparent way how our labeling
results could be adapted to modular width in a similar way.


 


\bibliography{main}

\end{document}
