\documentclass[sigconf]{acmart}

\usepackage{caption}
\usepackage{subcaption}
\usepackage{epstopdf}
\usepackage{enumitem}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{multirow}

\fancyhead{}
\captionsetup[table]{skip=1pt}
\captionsetup[figure]{skip=1pt}
\newtheorem{definition}{Definition}
\renewcommand{\algorithmicrequire}{\textbf{Input:}} 
\renewcommand{\algorithmicensure}{\textbf{Output:}}

\settopmatter{printacmref=false, printfolios=false}
\setcopyright{rightsretained}
\acmDOI{10.1145/3269206.3271739}
\acmISBN{978-1-4503-6014-2/18/10}
\acmConference[CIKM '18]{The 27th ACM International Conference on Information and Knowledge Management}{October 22--26, 2018}{Torino, Italy}
\acmBooktitle{The 27th ACM International Conference on Information and Knowledge Management (CIKM '18), October 22--26, 2018, Torino, Italy}
\acmYear{2018}
\copyrightyear{2018}
\acmPrice{15.00}


\begin{document}
\title[RippleNet for Recommender Systems]{RippleNet: Propagating User Preferences on the Knowledge Graph for Recommender Systems}


\author[H. Wang et al.]{Hongwei Wang, Fuzheng Zhang, Jialin Wang, Miao Zhao, Wenjie Li, Xing Xie, Minyi Guo}
\authornote{M. Guo is the corresponding author. This work was partially sponsored by the National Basic Research 973 Program of China under Grant 2015CB352403.}
\affiliation{Shanghai Jiao Tong University, wanghongwei55@gmail.com, guo-my@cs.sjtu.edu.cn}
\affiliation{Microsoft Research Asia, xingx@microsoft.com, Meituan AI Lab, zhangfuzheng@meituan.com}
\affiliation{The Hong Kong Polytechnic University, \{csjlwang, csmiaozhao, cswjli\}@comp.polyu.edu.hk}



\begin{abstract}
	To address the sparsity and cold start problem of collaborative filtering, researchers usually make use of side information, such as social networks or item attributes, to improve recommendation performance.
	This paper considers the knowledge graph as the source of side information.
 	To address the limitations of existing embedding-based and path-based methods for knowledge-graph-aware recommendation, we propose \textit{RippleNet}, an end-to-end framework that naturally incorporates the knowledge graph into recommender systems.
 	Similar to actual ripples propagating on the water, RippleNet stimulates the propagation of user preferences over the set of knowledge entities by automatically and iteratively extending a user's potential interests along links in the knowledge graph.
 	The multiple "ripples" activated by a user's historically clicked items are thus superposed to form the preference distribution of the user with respect to a candidate item, which could be used for predicting the final clicking probability.
 	Through extensive experiments on real-world datasets, we demonstrate that RippleNet achieves substantial gains in a variety of scenarios, including movie, book and news recommendation, over several state-of-the-art baselines.
\end{abstract}

\keywords{Recommender systems; knowledge graph; preference propagation}

\maketitle


\subsection*{\small{ACM Reference Format:}}
\vspace{-0.05in}
	{\small
		Hongwei Wang, Fuzheng Zhang, Jialin Wang, Miao Zhao, Wenjie Li, Xing Xie, and Minyi Guo.
		2018.
		RippleNet: Propagating User Preferences on the Knowledge Graph for Recommender Systems.
In \textit{The 27th ACM International Conference on Information and Knowledge Management (CIKM '18), October 22--26, 2018, Torino, Italy}.
		ACM, New York, NY, USA, 10 pages.
		https://doi.\\org/10.1145/3269206.3271739
	}


\section{Introduction}
	The explosive growth of online content and services has provided overwhelming choices for users, such as news, movies, music, restaurants, and books.
	Recommender systems (RS) intend to address the information explosion by finding a small set of items for users to meet their personalized interests.
	Among recommendation strategies, \textit{collaborative filtering} (CF), which considers users' historical interactions and makes recommendations based on their potential common preferences, has achieved great success \cite{koren2009matrix}.
	However, CF-based methods usually suffer from the sparsity of user-item interactions and the cold start problem.
	To address these limitations, researchers have proposed incorporating \textit{side information} into CF, such as social networks \cite{jamali2010matrix}, user/item attributes \cite{wang2018shine}, images \cite{zhang2016collaborative} and contexts \cite{sun2017collaborative}.
	
	Among various types of side information, \textit{knowledge graph} (KG) usually contains much more fruitful facts and connections about items.
	A KG is a type of directed heterogeneous graph in which nodes correspond to \textit{entities} and edges correspond to \textit{relations}.
	Recently, researchers have proposed several academic KGs, such as NELL\footnote{\url{http://rtw.ml.cmu.edu/rtw/}}, DBpedia\footnote{\url{http://wiki.dbpedia.org/}}, and commercial KGs, such as Google Knowledge Graph\footnote{\url{https://www.google.com/intl/bn/insidesearch/features/search/knowledge.html}} and Microsoft Satori\footnote{\url{https://searchengineland.com/library/bing/bing-satori}}.
	These knowledge graphs are successfully applied in many applications such as KG completion \cite{lin2015learning}, question answering \cite{dong2015question}, word embedding \cite{xu2014rc}, and text classification \cite{wang2017combining}.
	
	\begin{figure}[t]
		\centering
  		\includegraphics[width=.48\textwidth]{figures/kg.pdf}
  		\caption{Illustration of knowledge graph enhanced movie recommender systems. The knowledge graph provides fruitful facts and connections among items, which are useful for improving precision, diversity, and explainability of recommended results.}
  		\label{fig:kg}
	\end{figure}
	
	Inspired by the success of applying KG in a wide variety of tasks, researchers also tried to utilize KG to improve the performance of recommender systems.
	As shown in Figure \ref{fig:kg}, KG can benefit the recommendation from three aspects:
	(1) KG introduces semantic relatedness among items, which can help find their latent connections and improve the \textit{precision} of recommended items;
	(2) KG consists of relations with various types, which is helpful for extending a user's interests reasonably and increasing the \textit{diversity} of recommended items;
	(3) KG connects a user's historical records and the recommended ones, thereby bringing \textit{explainability} to recommender systems.
	In general, existing KG-aware recommendation can be classified into two categories:
	
	The first category is \textit{embedding-based methods} \cite{wang2018dkn,zhang2016collaborative,wang2018shine}, which pre-process a KG with \textit{knowledge graph embedding} (KGE) \cite{wang2017knowledge} algorithms and incorporates the learned entity embeddings into a recommendation framework.
	For example, Deep Knowledge-aware Network (DKN) \cite{wang2018dkn} treats entity embeddings and word embeddings as different channels, then designs a CNN framework to combine them together for news recommendation.
	Collaborative Knowledge base Embedding (CKE) \cite{zhang2016collaborative} combines a CF module with knowledge embedding, text embedding, and image embedding of items in a unified Bayesian framework.
	Signed Heterogeneous Information Network Embedding (SHINE) \cite{wang2018shine} designs deep autoencoders to embed sentiment networks, social networks and profile (knowledge) networks for celebrity recommendations.
	Embedding-based methods show high flexibility in utilizing KG to assist recommender systems, but the adopted KGE algorithms in these methods are usually more suitable for in-graph applications such as link prediction than for recommendation \cite{wang2017knowledge}, thus the learned entity embeddings are less intuitive and effective to characterize inter-item relations.
	
	The second category is \textit{path-based methods} \cite{yu2014personalized,zhao2017meta}, which explore the various patterns of connections among items in KG to provide additional guidance for recommendations.	
	For example, Personalized Entity Recommendation (PER) \cite{yu2014personalized} and Meta-Graph Based Recommendation \cite{zhao2017meta} treat KG as a heterogeneous information network (HIN), and extract meta-path/meta-graph based latent features to represent the connectivity between users and items along different types of relation paths/graphs.
	Path-based methods make use of KG in a more natural and intuitive way, but they rely heavily on manually designed meta-paths, which is hard to optimize in practice.
	Another concern is that it is impossible to design hand-crafted meta-paths in certain scenarios (e.g., news recommendation) where entities and relations are not within one domain.
	
	To address the limitations of existing methods, we propose \textit{RippleNet}, an end-to-end framework for knowledge-graph-aware recommendation.
	RippleNet is designed for click-through rate (CTR) prediction, which takes a user-item pair as input and outputs the probability of the user engaging (e.g., clicking, browsing) the item.
	The key idea behind RippleNet is \textit{preference propagation}:
	For each user, RippleNet treats his historical interests as a seed set in the KG, then extends the user's interests iteratively along KG links to discover his hierarchical potential interests with respect to a candidate item.
	We analogize preference propagation with actual ripples created by raindrops propagating on the water, in which multiple "ripples" superpose to form a resultant preference distribution of the user over the knowledge graph.
	The major difference between RippleNet and existing literature is that RippleNet combines the advantages of the above mentioned two types of methods:
	(1) RippleNet incorporates the KGE methods into recommendation naturally by preference propagation;
	(2) RippleNet can automatically discover possible paths from an item in a user's history to a candidate item, without any sort of hand-crafted design.
	
	Empirically, we apply RippleNet to three real-world scenarios of movie, book, and news recommendations.
	The experiment results show that RippleNet achieves AUC gains of  to ,  to , and  to  in movie, book, and news recommendations, respectively, compared with state-of-the-art baselines for recommendation.
	We also find that RippleNet provides a new perspective of explainability for the recommended results in terms of the knowledge graph.
	
	In summary, our contributions in this paper are as follows:
	\begin{itemize}
		\item
			To the best of our knowledge, this is the first work to combine embedding-based and path-based methods in KG-aware recommendation.
		\item
			We propose RippleNet, an end-to-end framework utilizing KG to assist recommender systems.
			RippleNet automatically discovers users' hierarchical potential interests by iteratively propagating users' preferences in the KG.
		\item
			We conduct experiments on three real-world recommendation scenarios, and the results prove the efficacy of RippleNet over several state-of-the-art baselines.
	\end{itemize}
	
	

\section{Problem Formulation}\label{sec:problem_formulation}
	The knowledge-graph-aware recommendation problem is formulated as follows.
	In a typical recommender system, let  and  denote the sets of users and items, respectively.
	The user-item interaction matrix  is defined according to users' implicit feedback, where
	
	A value of 1 for  indicates there is an implicit interaction between user  and item , such as behaviors of clicking, watching, browsing, etc.
	In addition to the interaction matrix , we also have a knowledge graph  available, which consists of massive entity-relation-entity triples .
	Here , , and  denote the head, relation, and tail of a knowledge triple, respectively,  and  denote the set of entities and relations in the KG.
	For example, the triple (\textit{Jurassic Park}, \textit{film.film.director}, \textit{Steven Spielberg}) states the fact that Steven Spielberg is the director of the film "Jurassic Park".
	In many recommendation scenarios, an item  may associate with one or more entities in .
	For example, the movie "Jurassic Park" is linked with its namesake in KG, while news with title "France's Baby Panda Makes Public Debut" is linked with entities "France" and "panda".
	
	Given interaction matrix  as well as knowledge graph , we aim to predict whether user  has potential interest in item  with which he has had no interaction before.
	Our goal is to learn a prediction function , where  denotes the probability that user  will click item , and  denotes the model parameters of function .
	
	
	

\section{RippleNet}\label{sec:ripple_networks}
	In this section, we discuss the proposed RippleNet in detail.
	We also give some discussions on the model and introduce the related work.
	
	\subsection{Framework}
		\begin{figure*}[t]
			\centering
  			\includegraphics[width=0.95\textwidth]{figures/framework.pdf}
  			\caption{The overall framework of the RippleNet. It takes one user and one item as input, and outputs the predicted probability that the user will click the item. The KGs in the upper part illustrate the corresponding ripple sets activated by the user's click history.}
  			\label{fig:framework}
		\end{figure*}	
		
		The framework of RippleNet is illustrated in Figure \ref{fig:framework}.
		RippleNet takes a user  and an item  as input, and outputs the predicted probability that user  will click item .
		For the input user , his historical set of interests  is treated as seeds in the KG, then extended along links to form multiple ripple sets  ().
		A ripple set  is the set of knowledge triples that are -hop(s) away from the seed set .
		These ripple sets are used to interact with the item embedding (the yellow block) iteratively for obtaining the responses of user  with respect to item  (the green blocks), which are then combined to form the final user embedding (the grey block).
		Lastly, we use the embeddings of user  and item  together to compute the predicted probability .		
		
		
	\subsection{Ripple Set}
	\label{sec:ripple_set}		
		A knowledge graph usually contains fruitful facts and connections among entities.
		For example, as illustrated in Figure \ref{fig:ripple_set}, the film "Forrest Gump" is linked with "Robert Zemeckis" (director), "Tom Hanks" (star), "U.S." (country) and "Drama" (genre), while "Tom Hanks" is further linked with films "The Terminal" and "Cast Away" which he starred in.
		These complicated connections in KG provide us a deep and latent perspective to explore user preferences.
		For example, if a user has ever watched "Forrest Gump", he may possibly become a fan of Tom Hanks and be interested in "The Terminal" or "Cast Away".
		To characterize users' hierarchically extended preferences in terms of KG, in RippleNet, we recursively define the set of -hop relevant entities for user  as follows:
		
		\begin{definition}[relevant entity]
			Given interaction matrix  and knowledge graph , the set of -hop relevant entities for user  is defined as
			
		where  is the set of user's clicked items in the past, which can be seen as the seed set of user  in KG.
		\end{definition}
		
		Relevant entities can be regarded as natural extensions of a user's historical interests with respect to the KG.
		Given the definition of relevant entities, we then define the -hop ripple set of user  as follows:
		
		\begin{definition}[ripple set]
			The -hop ripple set of user  is defined as the set of knowledge triples starting from :
		
		\end{definition}
		
		The word "ripple" has two meanings:
		(1) Analogous to real ripples created by multiple raindrops, a user's potential interest in entities is activated by his historical preferences, then propagates along the links in KG layer by layer, from near to distant.
		We visualize the analogy by the concentric circles illustrated in Figure \ref{fig:ripple_set}.
		(2) The strength of a user's potential preferences in ripple sets weakens with the increase of the hop number , which is similar to the gradually attenuated amplitude of real ripples.
		The fading blue in Figure \ref{fig:ripple_set} shows the decreasing relatedness between the center and surrounding entities.
		
		One concern about ripple sets is their sizes may get too large with the increase of hop number .
		To address the concern, note that:
		(1) A large number of entities in a real KG are \textit{sink entities}, meaning they only have incoming links but no outgoing links, such as "2004" and "PG-13" in Figure \ref{fig:ripple_set}.
		(2) In specific recommendation scenarios such as movie or book recommendations, relations can be limited to scenario-related categories to reduce the size of ripple sets and improve relevance among entities.
		For example, in Figure \ref{fig:ripple_set}, all relations are movie-related and contain the word "film" in their names.
		(3) The number of maximal hop  is usually not too large in practice, since entities that are too distant from a user's history may bring more noise than positive signals.
		We will discuss the choice of  in the experiments part.
		(4) In RippleNet, we can sample a fixed-size set of neighbors instead of using a full ripple set to further reduce the computation overhead.
		Designing such samplers is an important direction of future work, especially the non-uniform samplers for better capturing user's hierarchical potential interests.
		
		\begin{figure}[t]
			\centering
  			\includegraphics[width=.45\textwidth]{figures/ripple_set.pdf}
  			\caption{Illustration of ripple sets of "Forrest Gump" in KG of movies. The concentric circles denotes the ripple sets with different hops. The fading blue indicates decreasing relatedness between the center and surrounding entities.Note that the ripple sets of different hops are not necessarily disjoint in practice.}
  			\label{fig:ripple_set}
		\end{figure}
		
		
	\subsection{Preference Propagation}
Traditional CF-based methods and their variants \cite{koren2008factorization,wang2017joint} learn latent representations of users and items, then predict unknown ratings by directly applying a specific function to their representations such as inner product.
		In RippleNet, to model the interactions between users and items in a more fine-grained way, we propose a preference propagation technique to explore users' potential interests in his ripple sets.
		
		As shown in Figure \ref{fig:framework}, each item  is associated with an item embedding , where  is the dimension of embeddings.
		Item embedding can incorporate one-hot ID \cite{koren2008factorization}, attributes \cite{wang2018shine}, bag-of-words \cite{wang2018dkn} or context information \cite{sun2017collaborative} of an item, based on the application scenario.
		Given the item embedding  and the 1-hop ripple set  of user , each triple  in  is assigned a relevance probability by comparing item  to the head  and the relation  in this triple:
		
		where  and  are the embeddings of relation  and head , respectively.
		The relevance probability  can be regarded as the similarity of item  and the entity  measured in the space of relation .
		Note that it is necessary to take the embedding matrix  into consideration when calculating the relevance of item  and entity , since an item-entity pair may have different similarities when measured by different relations.
		For example, "Forrest Gump" and "Cast Away" are highly similar when considering their directors or stars, but have less in common if measured by genre or writer.
		
		After obtaining the relevance probabilities, we take the sum of tails in  weighted by the corresponding relevance probabilities, and the vector  is returned:
		
		where  is the embedding of tail .
		Vector  can be seen as the 1-order response of user 's click history  with respect to item .
		This is similar to item-based CF methods \cite{koren2008factorization,wang2018dkn}, in which a user is represented by his related items rather than a independent feature vector to reduce the size of parameters.
		Through the operations in Eq. (\ref{eq:key_addressing}) and Eq. (\ref{eq:value_reading}), a user's interests are transferred from his history set  to  the set of his 1-hop relevant entities  along the links in , which is called \textit{preference propagation} in RippleNet.
		
		Note that by replacing  with  in Eq. (\ref{eq:key_addressing}), we can repeat the procedure of preference propagation to obtain user 's 2-order response , and the procedure can be performed iteratively on user 's ripple sets  for .
		Therefore, a user's preference is propagated up to  hops away from his click history, and we observe multiple responses of user  with different orders: .
		The embedding of user  with respect to item  is calculated by combining the responses of all orders:
		
Note that though the user response of last hop  contains all the information from previous hops theoretically, it is still necessary to incorporate  of small hops  in calculating user embedding since they may be diluted in .
		Finally, the user embedding and item embedding are combined to output the predicted clicking probability:
		
		where  is the sigmoid function.
		
		
	
	\subsection{Learning Algorithm}
		In RippleNet, we intend to maximize the following posterior probability of model parameters  after observing the knowledge graph  and the matrix of implicit feedback :
		
		where  includes the embeddings of all entities, relations and items.
		This is equivalent to maximizing
		
		according to Bayes' theorem.
		In Eq. (\ref{eq:pp}), the first term  measures the priori probability of model parameters .
		Following \cite{zhang2016collaborative}, we set  as Gaussian distribution with zero mean and a diagonal covariance matrix:
		
		The second item in Eq. (\ref{eq:pp}) is the likelihood function of the observed knowledge graph  given .
		Recently, researchers have proposed a great many knowledge graph embedding methods, including translational distance models \cite{bordes2013translating,lin2015learning} and semantic matching models \cite{nickel2016holographic,liu2017analogical} (We will continue the discussion on KGE methods in Section \ref{sec:kge}).
		In RippleNet, we use a three-way tensor factorization method to define the likelihood function for KGE:
		
		where the indicator  equals  if  and is  otherwise.
		Based on the definition in Eq. (\ref{eq:kge}), the scoring functions of entity-entity pairs in KGE and item-entity pairs in preference propagation can thus be unified under the same calculation model.
		The last term in Eq. (\ref{eq:pp}) is the likelihood function of the observed implicit feedback given  and the KG, which is defined as the product of Bernouli distributions:
		
		based on Eq. (\ref{eq:re})--(\ref{eq:inner}).
		
		Taking the negative logarithm of Eq. (\ref{eq:pp}), we have the following loss function for RippleNet:
		
		where  and  are the embedding matrices for all items and entities, respectively,  is the slice of the indicator tensor  in KG for relation , and  is the embedding matrix of relation .
		In Eq. (\ref{eq:loss}), The first term measures the cross-entropy loss between ground truth of interactions  and predicted value by RippleNet, the second term measures the squared error between the ground truth of the KG  and the reconstructed indicator matrix , and the third term is the regularizer for preventing over-fitting.
		
		\begin{algorithm}[t]
			\caption{Learning algorithm for RippleNet}
			\label{alg:rn}
			\begin{algorithmic}[1]
				\REQUIRE{Interaction matrix , knowledge graph }
				\ENSURE{Prediction function }
				\STATE Initialize all parameters
				\STATE Calculate ripple sets  for each user ;
				\FOR{number of training iteration}
				\STATE Sample minibatch of positive and negative interactions from ;
				\STATE Sample minibatch of true and false triples from ;
				\STATE Calculate gradients , , , and  on the minibatch by back-propagation according to Eq. (4)-(13);
				\STATE Update , , , and  by gradient descent with learning rate ;
				\ENDFOR
				\RETURN 
			\end{algorithmic}
		\end{algorithm}
		
		It is intractable to solve the above objection directly, therefore, we employ a stochastic gradient descent (SGD) algorithm to iteratively optimize the loss function.
		The learning algorithm of RippleNet is presented in Algorithm \ref{alg:rn}.
		In each training iteration, to make the computation more efficient, we randomly sample a minibatch of positive/negative interactions from  and true/false triples from  following the negative sampling strategy in \cite{mikolov2013distributed}.
		Then we calculate the gradients of the loss  with respect to model parameters , and update all parameters by back-propagation based on the sampled minibatch.
		We will discuss the choice of hyper-parameters in the experiments section.
		
		
	\subsection{Discussion}
		\subsubsection{Explainability}
		\label{sec:explainability}
			Explainable recommender systems \cite{tintarev2007survey} aim to reveal why a user might like a particular item, which helps improve their acceptance or satisfaction of recommendations and increase trust in RS.
			The explanations are usually based on community tags \cite{vig2009tagsplanations}, social networks \cite{sharma2013social}, aspect \cite{bauman2017aspect}, and phrase sentiment \cite{zhang2014explicit}
			Since RippleNet explores users' interests based on the KG, it provides a new point of view of explainability by tracking the paths from a user's history to an item with high relevance probability (Eq. (\ref{eq:key_addressing})) in the KG.
			For example, a user's interest in film "Back to the Future" might be explained by the path " \textit{Future}", if the item "Back to the Future" is of high relevance probability with "Forrest Gump" and "Robert Zemeckis" in the user's -hop and -hop ripple set, respectively.
			Note that different from path-based methods \cite{yu2014personalized,zhao2017meta} where the patterns of path are manually designed, RippleNet automatically discovers the possible explanation paths according to relevance probability.
			We will further present a visualized example in the experiments section to intuitively demonstrate the explainability of RippleNet.
		
		
		\subsubsection{Ripple Superposition}
		\label{sec:ripple_superposition}
			A common phenomenon in RippleNet is that a user's ripple sets may be large in size, which dilutes his potential interests inevitably in preference propagation.
			However, we observe that relevant entities of different items in a user's click history often highly overlap.
			In other words, an entity could be reached by multiple paths in the KG starting from a user's click history.
			For example, "Saving Private Ryan" is connected to a user who has watched "The Terminal", "Jurassic Park" and "Braveheart" through actor "Tom Hanks", director "Steven Spielberg" and genre "War", respectively.
			These parallel paths greatly increase a user's interests in overlapped entities.
			We refer to the case as \textit{ripple superposition}, as it is analogous to the interference phenomenon in physics in which two waves superpose to form a resultant wave of greater amplitude in particular areas.
			The phenomenon of ripple superposition is illustrated in the second KG in Figure \ref{fig:framework}, where the darker red around the two lower middle entities indicates higher strength of the user's possible interests.
			We will also discuss ripple superposition in the experiments section.
		

	\subsection{Links to Existing Work}
		Here we continue our discussion on related work and make comparisons with existing techniques in a greater scope.
		
		\subsubsection{Attention Mechanism}
			The attention mechanism was originally proposed in image classification \cite{mnih2014recurrent} and machine translation \cite{bahdanau2014neural}, which aims to learn where to find the most relevant part of the input automatically as it is performing the task.
			The idea was soon transplanted to recommender systems \citep{wang2017dynamic,chen2017attentive,seo2017interpretable,zhou2017deep,wang2018dkn}.
			For example, DADM \cite{chen2017attentive} considers factors of specialty and date when assigning attention values to articles for recommendation;
			D-Attn \cite{seo2017interpretable} proposes an interpretable and dual attention-based CNN model that combines review text and ratings for product rating prediction;
			DKN \cite{wang2018dkn} uses an attention network to calculate the weight between a user's clicked item and a candidate item to dynamically aggregate the user's historical interests.
			RippleNet can be viewed as a special case of attention where tails are averaged weighted by similarities between their associated heads, tails, and certain item.
			The difference between our work and literature is that RippleNet designs a multi-level attention module based on knowledge triples for preference propagation.
		
		\subsubsection{Memory Networks}
			Memory networks \cite{weston2014memory,sukhbaatar2015end,miller2016key} is a recurrent attention model that utilizes an external memory module for question answering and language modeling.
			The iterative reading operations on the external memory enable memory networks to extract long-distance dependency in texts.
			Researchers have also proposed using memory networks in other tasks such as sentiment classification \cite{tai2015improved,li2017end} and recommendation \cite{huang2017mention,chen2018sequential}.
			Note that these works usually focus on entry-level or sentence-level memories, while our work addresses entity-level connections in the KG, which is more fine-grained and intuitive when performing multi-hop iterations.
			In addition, our work also incorporates a KGE term as a regularizer for more stable and effective learning.
			
		\subsubsection{Knowledge Graph Embedding}
		\label{sec:kge}
			RippleNet also connects to a large body of work in KGE methods\cite{bordes2013translating,wang2014knowledge,ji2015knowledge,lin2015learning,wang2018graphgan,nickel2016holographic,trouillon2016complex,yang2015embedding}.
			KGE intends to embed entities and relations in a KG into continuous vector spaces while preserving its inherent structure.
			Readers can refer to \cite{wang2017knowledge} for a more comprehensive survey.
			KGE methods are mainly classified into two categories:
			(1) Translational distance models, such as TransE \cite{bordes2013translating}, TransH \cite{wang2014knowledge}, TransD \cite{ji2015knowledge}, and TransR \cite{lin2015learning}, exploit distance-based scoring functions when learning representations of entities and relations.
			For example, TransE \cite{bordes2013translating} wants  when  holds, where ,  and  are the corresponding representation vector of ,  and .
			Therefore, TransE assumes the score function  is low if  holds, and high otherwise.
			(2) Semantic matching models, such as ANALOGY \cite{nickel2016holographic}, ComplEx \cite{trouillon2016complex}, and DisMult \cite{yang2015embedding}, measure plausibility of knowledge triples by matching latent semantics of entities and relations.
			For example, DisMult \cite{yang2015embedding} introduces a vector embedding  and requires .
			The scoring function is hence defined as .
			Researchers also propose incorporating auxiliary information, such as entity types \cite{xie2016representation}, logic rules \cite{rocktaschel2015injecting}, and textual descriptions \cite{zhong2015aligning} to assist KGE.
			However, these methods are more suitable for in-graph applications such as link prediction or triple classification, according to their learning objectives.
			From this point of view, RippleNet can be seen as a specially designed KGE method that serves recommendation directly.


\section{Experiments}\label{section_experiments}
	In this section, we evaluate RippleNet on three real-world scenarios: movie, book, and news recommendations
\footnote{Experiment code is provided at \url{https://github.com/hwwang55/RippleNet}.}.
	We first introduce the datasets, baselines, and experiment setup, then present the experiment results.
	We will also give a case study of visualization and discuss the choice of hyper-parameters in this section.
	
	
	\subsection{Datasets}
		We utilize the following three datasets in our experiments for movie, book, and news recommendation:
		\begin{itemize}
			\item
				MovieLens-1M\footnote{\url{https://grouplens.org/datasets/movielens/1m/}} is a widely used benchmark dataset in movie recommendations, which consists of approximately 1 million explicit ratings (ranging from 1 to 5) on the MovieLens website.
\item
				Book-Crossing dataset\footnote{\url{http://www2.informatik.uni-freiburg.de/~cziegler/BX/}} contains 1,149,780 explicit ratings (ranging from 0 to 10) of books in the Book-Crossing community.
\item
				Bing-News dataset contains 1,025,192 pieces of implicit feedback collected from the server logs of Bing News\footnote{\url{https://www.bing.com/news}} from October 16, 2016 to August 11, 2017.
				Each piece of news has a title and a snippet.
		\end{itemize}
		
		Since MovieLens-1M and Book-Crossing are explicit feedback data, we transform them into implicit feedback where each entry is marked with 1 indicating that the user has rated the item (the threshold of rating is 4 for MovieLens-1M, while no threshold is set for Book-Crossing due to its sparsity), and sample an unwatched set marked as 0 for each user, which is of equal size with the rated ones.
For MovieLens-1M and Book-Crossing, we use the ID embeddings of users and items as raw input, while for Bing-News, we concatenate the ID embedding of a piece of news and the averaged word embedding of its title as raw input for the item, since news titles are typically much longer than names of movies or books, hence providing more useful information for recommendation.
		
		
		We use Microsoft Satori to construct the knowledge graph for each dataset.
		For MovieLens-1M and Book-Crossing, we first select a subset of triples from the whole KG whose relation name contains "movie" or "book" and the confidence level is greater than 0.9.
		Given the sub-KG, we collect IDs of all valid movies/books by matching their names with tail of triples (\textit{head, film.film.name, tail}) or \textit{(head, book.book.title, tail)}.
		For simplicity, items with no matched or multiple matched entities are excluded.
		We then match the IDs with the head and tail of all KG triples, select all well-matched triples from the sub-KG, and extend the set of entities iteratively up to four hops.
		The constructing process is similar for Bing-News except that: (1) we use entity linking tools to extract entities in news titles; (2) we do not impose restrictions on the names of relations since the entities in news titles are not within one particular domain.
		The basic statistics of the three datasets are presented in Table \ref{table:statistics}.
		
		
		\begin{table}[t]
			\centering
			\caption{Basic statistics of the three datasets.}
			\begin{tabular}{c|ccc}
				\hline
				& MovieLens-1M & Book-Crossing & Bing-News\\
				\hline
				\# users & 6,036 & 17,860 & 141,487\\
				\# items & 2,445 & 14,967 & 535,145\\
				\# interactions & 753,772 & 139,746 & 1,025,192\\
				\# 1-hop triples & 20,782 & 19,876 & 503,112\\
				\# 2-hop triples & 178,049 & 65,360 & 1,748,562\\
				\# 3-hop triples & 318,266 & 84,299 & 3,997,736\\
				\# 4-hop triples & 923,718 & 71,628 & 6,322,548\\
				\hline
			\end{tabular}
			\vspace{-0.07in}
			\label{table:statistics}
		\end{table}	
		
		\begin{table}[t]
			\centering
			\caption{Hyper-parameter settings for the three datasets.}
			\begin{tabular}{c|c}
				\hline
				MovieLens-1M & , , , , \\
				Book-Crossing & , , , , \\
				Bing-News & , , , , \\
				\hline
			\end{tabular}
			\vspace{-0.07in}
			\label{table:hps}
		\end{table}	
		
	\subsection{Baselines}
		We compare the proposed RippleNet with the following state-of-the-art baselines:
		\begin{itemize}
			\item
				\textbf{CKE} \cite{zhang2016collaborative} combines CF with structural knowledge, textual knowledge, and visual knowledge in a unified framework for recommendation.
				We implement CKE as CF plus structural knowledge module in this paper.
			\item
				\textbf{SHINE} \cite{wang2018shine} designs deep autoencoders to embed a sentiment network, social network, and profile (knowledge) network for celebrity recommendation.
				Here we use autoencoders for user-item interaction and item profile to predict click probability.
			\item
				\textbf{DKN} \cite{wang2018dkn}	treats entity embedding and word embedding as multiple channels and combines them together in CNN for CTR prediction.
				In this paper, we use movie/book names and news titles as textual input for DKN.
			\item
				\textbf{PER} \cite{yu2014personalized} treats the KG as HIN and extracts meta-path based features to represent the connectivity between users and items.
				In this paper, we use all item-attribute-item features for PER (e.g., ``movie-director-movie").
			\item
				\textbf{LibFM} \cite{rendle2012factorization} is a widely used feature-based factorization model in CTR scenarios.
				We concatenate user ID, item ID, and the corresponding averaged entity embeddings learned from TransR \cite{lin2015learning} as input for LibFM.
			\item
				\textbf{WideDeep} \cite{cheng2016wide} is a general deep model for recommendation combining a (wide) linear channel with a (deep) non-linear channel.
				Similar to LibFM, we use the embeddings of users, items, and entities to feed WideDeep.
		\end{itemize}
		
	\begin{figure}[t]
			\centering
            \begin{subfigure}[b]{0.23\textwidth}
                \includegraphics[width=\textwidth]{charts/es_1.eps}
                \caption{MovieLens-1M}
                \label{fig:es_1}
            \end{subfigure}
            \hfill
            \begin{subfigure}[b]{0.23\textwidth}
                \includegraphics[width=\textwidth]{charts/es_2.eps}
                \caption{Book-Crossing}
                \label{fig:es_2}
            \end{subfigure}
            \hfill
            \begin{subfigure}[b]{0.23\textwidth}
                \includegraphics[width=\textwidth]{charts/es_3.eps}
                \caption{Bing-News}
                \label{fig:es_3}
            \end{subfigure}
            \hfill
            \begin{subfigure}[b]{0.23\textwidth}
                \includegraphics[width=\textwidth]{charts/es_4.eps}
                \caption{Ratio of two average numbers}
                \label{fig:es_4}
            \end{subfigure}
            \caption{The average number of -hop neighbors that two items share in the KG w.r.t. whether they have common raters in (a) MovieLens-1M, (b) Book-Crossing, and (c) Bing-News datasets. (d) The ratio of the two average numbers with different hops.}
            \label{fig:case_study}
        \end{figure}
		
		
	\subsection{Experiment Setup}	
		In RippleNet, we set the hop number  for MovieLens-1M/Book-Crossing and  for Bing-News.
		A larger number of hops hardly improves performance but does incur heavier computational overhead according to experiment results. 
		The complete hyper-parameter settings are given in Table \ref{table:hps}, where  denotes the dimension of embedding for items and the knowledge graph, and  denotes the learning rate.
		The hyper-parameters are determined by optimizing  on a validation set.
		For fair consideration, the latent dimensions of all compared baselines are set the same as in Table \ref{table:hps}, while other hyper-parameters of baselines are set based on grid search.
		
		For each dataset, the ratio of training, evaluation, and test set is .
		Each experiment is repeated  times, and the average performance is reported.
		We evaluate our method in two experiment scenarios:
		(1) In click-through rate (CTR) prediction, we apply the trained model to each piece of interactions in the test set and output the predicted click probability.
		We use  and  to evaluate the performance of CTR prediction.
		(2) In top- recommendation, we use the trained model to select  items with highest predicted click probability for each user in the test set, and choose , ,  to evaluate the recommended sets.
	
		
	\subsection{Empirical Study}
	\label{sec:es}        
        We conduct an empirical study to investigate the correlation between the average number of common neighbors of an item pair in the KG and whether they have common rater(s) in RS.
		For each dataset, we first randomly sample one million item pairs, then count the average number of -hop neighbors that the two items share in the KG under the following two circumstances: (1) the two items have at least one common rater in RS; (2) the two items have no common rater in RS.
		The results are presented in Figures \ref{fig:es_1}, \ref{fig:es_2}, \ref{fig:es_3}, respectively, which clearly show that if two items have common rater(s) in RS, they likely share more common -hop neighbors in the KG for fixed .
		The above findings empirically demonstrate that \textit{the similarity of proximity structures of two items in the KG could assist in measuring their relatedness in RS}.
		In addition, we plot the ratio of the two average numbers with different hops (i.e., dividing the higher bar by its immediate lower bar for each hop number) in Figure \ref{fig:es_4}, from which we observe that the proximity structures of two items under the two circumstances become more similar with the increase of the hop number.
		This is because any two items are probable to share a large amount of -hop neighbors in the KG for a large , even if there is no direct similarity between them in reality.
		The result motivates us to find a moderate hop number in RippleNet to explore users' potential interests as far as possible while avoiding introducing too much noise.
		
		
	\subsection{Results}
		\begin{table}[t]
			\setlength{\abovecaptionskip}{3pt}
            \centering
            \caption{The results of  and  in CTR prediction.}
                \begin{tabular}{c|cccccc}
                    \hline
                    \multirow{2}{*}{Model} & \multicolumn{2}{c}{MovieLens-1M} & \multicolumn{2}{c}{Book-Crossing} & \multicolumn{2}{c}{Bing-News} \\
                    \cline{2-7}
                    & \textit{AUC} & \textit{ACC} & \textit{AUC} & \textit{ACC} & \textit{AUC} & \textit{ACC} \\
                    \hline
                    RippleNet* & \textbf{0.921} & \textbf{0.844} & \textbf{0.729} & \textbf{0.662} & \textbf{0.678} & \textbf{0.632} \\
                    CKE & 0.796 & 0.739 & 0.674 & 0.635 & 0.560 & 0.517 \\
                    SHINE & 0.778 & 0.732 & 0.668 & 0.631 & 0.554 & 0.537 \\
                    DKN & 0.655 & 0.589 & 0.621 & 0.598 & 0.661 & 0.604 \\
                    PER & 0.712 & 0.667 & 0.623 & 0.588 & - & - \\
                    LibFM & 0.892 & 0.812 & 0.685 & 0.639 & 0.644 & 0.588 \\
                    WideDeep & 0.903 & 0.822 & 0.711 & 0.623 & 0.654 & 0.595 \\
                    \hline
				\end{tabular}
			\label{table:ctr}
			\footnotesize \flushleft{* Statistically significant improvements by unpaired two-sample -test with .}
		\end{table}
		
		\begin{figure*}[t]
			\centering
			\begin{subfigure}[b]{0.9\textwidth}
				\vspace{-0.1in}
                \includegraphics[width=\textwidth]{charts/legend.eps}
                \vspace{-0.3in}
            \end{subfigure}
            \hfill
            \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth]{charts/p_1.eps}
                \caption{}
            \end{subfigure}
            \hfill
            \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth]{charts/r_1.eps}
                \caption{}
            \end{subfigure}
            \hfill
            \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth]{charts/f_1.eps}
                \caption{}
            \end{subfigure}
            \caption{, , and  in top- recommendation for MovieLens-1M.}
            \label{fig:topk_movie}
        \end{figure*}
        
        \begin{figure*}[t]
			\centering
            \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth]{charts/p_2.eps}
                \caption{}
            \end{subfigure}
            \hfill
            \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth]{charts/r_2.eps}
                \caption{}
            \end{subfigure}
            \hfill
            \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth]{charts/f_2.eps}
                \caption{}
            \end{subfigure}
            \caption{, , and  in top- recommendation for Book-Crossing.}
            \label{fig:topk_book}
        \end{figure*}
        
        \begin{figure*}[t]
			\centering
            \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth]{charts/p_3.eps}
                \caption{}
            \end{subfigure}
            \hfill
            \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth]{charts/r_3.eps}
                \caption{}
            \end{subfigure}
            \hfill
            \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth]{charts/f_3.eps}
                \caption{}
            \end{subfigure}
            \caption{, , and  in top- recommendation for Bing-News.}
            \label{fig:topk_news}
        \end{figure*}
        
        The results of all methods in CTR prediction and top- recommendation are presented in Table \ref{table:ctr} and Figures \ref{fig:topk_movie}, \ref{fig:topk_book}, \ref{fig:topk_news}, respectively.
        Several observations stand out:
        \begin{itemize}
        	\item
        		CKE performs comparably poorly than other baselines, which is probably because we only have structural knowledge available, without visual and textual input.
        	\item
        		SHINE performs better in movie and book recommendation than news.
        		This is because the 1-hop triples for news are too complicated when taken as profile input.
        	\item
        		DKN performs best in news recommendation compared with other baselines, but performs worst in movie and book recommendation.
        		This is because movie and book names are too short and ambiguous to provide useful information.
        	\item
        		PER performs unsatisfactorily on movie and book recommendation because the user-defined meta-paths can hardly be optimal.
        		In addition, it cannot be applied in news recommendation since the types of entities and relations involved in news are too complicated to pre-define meta-paths.
        	\item
        		As two generic recommendation tools, LibFM and WideDeep achieve satisfactory performance, demonstrating that they can make well use of knowledge from KG into their algorithms.
        	\item
        		RippleNet performs best among all methods in the three datasets.
        		Specifically, RippleNet outperforms baselines by  to ,  to , and  to  on  in movie, book, and news recommendation, respectively.
        		RippleNet also achieves outstanding performance in top- recommendation as shown in Figures \ref{fig:topk_movie}, \ref{fig:topk_book}, and \ref{fig:topk_news}.
        		Note that the performance of top- recommendation is much lower for Bing-News because the number of news is significantly larger than movies and books.
        \end{itemize}
        
        \noindent \textbf{Size of ripple set in each hop}.
        We vary the size of a user's ripple set in each hop to further investigate the robustness of RippleNet.
        The results of  on the three datasets are presented in Table \ref{table:kg_ratio}, from which we observe that with the increase of the size of ripple set, the performance of RippleNet is improved at first because a larger ripple set can encode more knowledge from the KG.
        But notice that the performance drops when the size is too large.
        In general, a size of  or  is enough for most datasets according to the experiment results.
        
        
        \begin{table}[t]
			\setlength{\abovecaptionskip}{3pt}
            \centering
            \caption{The results of  w.r.t. different sizes of a user's ripple set.}
                \begin{tabular}{c|cccccc}
                    \hline
                    Size of ripple set & 2 & 4 & 8 & 16 & 32 & 64\\
                    \hline
                    MovieLens-1M & 0.903 & 0.908 & 0.911 & 0.918 & \textbf{0.920} & 0.919 \\
                    Book-Crossing & 0.694 & 0.696 & 0.708 & \textbf{0.726} & 0.706 & 0.711 \\
                    Bing-News & 0.659 & 0.672 & 0.670 & 0.673 & \textbf{0.678} & 0.671 \\
                    \hline
				\end{tabular}
			\label{table:kg_ratio}
		\end{table}
        
        \noindent \textbf{Hop number}.
        We also vary the maximal hop number  to see how performance changes in RippleNet.
        The results are shown in Table \ref{table:hop_number}, which shows that the best performance is achieved when  is  or .
        We attribute the phenomenon to the trade-off between the positive signals from long-distance dependency and negative signals from noises: too small of an  can hardly explore inter-entity relatedness and dependency of long distance, while too large of an  brings much more noises than useful signals, as stated in Section \ref{sec:es}.
        
        	\begin{table}[t]
				\setlength{\abovecaptionskip}{3pt}
            	\centering
            	\caption{The results of  w.r.t. different hop numbers.}
                	\begin{tabular}{c|cccc}
                    	\hline
                    	Hop number  & 1 & 2 & 3 & 4 \\
                    	\hline
                    	MovieLens-1M & 0.916 & \textbf{0.919} & 0.915 & 0.918 \\
                    	Book-Crossing & 0.727 & 0.722 & \textbf{0.730} & 0.702 \\
                    	Bing-News & 0.662 & 0.676 & \textbf{0.679} & 0.674 \\
                    	\hline
					\end{tabular}
					\vspace{-0.05in}
				\label{table:hop_number}
			\end{table}
		
		
	\subsection{Case Study}
		\begin{figure}[t]
			\centering
  			\includegraphics[width=0.45\textwidth]{figures/case_study.pdf}
  			\caption{Visualization of relevance probabilities for a randomly sampled user w.r.t. a piece of candidate news with label . Links with value lower than  are omitted.}
  			\label{fig:cs}
		\end{figure}
		
		To intuitively demonstrate the preference propagation in RippleNet, we randomly sample a user with  clicked pieces of news, and select one candidate news from his test set with label .
		For each of the user's -hop relevant entities, we calculate the (unnormalized) relevance probability between the entity and the candidate news or its -order responses.
		The results are presented in Figure \ref{fig:cs}, in which the darker shade of blue indicates larger values, and we omit names of relations for clearer presentation.
		From Figure \ref{fig:cs} we observe that RippleNet associates the candidate news with the user's relevant entities with different strengths.
		The candidate news can be reached via several paths in the KG with high weights from the user's click history, such as "Navy SEAL"--"Special Forces"--"Gun"--"Police".
		These highlighted paths automatically discovered by preference propagation can thus be used to explain the recommendation result, as discussed in Section \ref{sec:explainability}.
		Additionally, it is also worth noticing that several entities in the KG receive more intensive attention from the user's history, such as "U.S.", "World War II" and "Donald Trump".
		These central entities result from the ripple superposition discussed in Section \ref{sec:ripple_superposition}, and can serve as the user's potential interests for future recommendation.

		
	\subsection{Parameter Sensitivity}
		\begin{figure}[t]
			\centering
            \begin{subfigure}[b]{0.23\textwidth}
                \includegraphics[width=\textwidth]{charts/ps_1.eps}
                \caption{Dimension of embedding}
                \label{fig:ps_1}
            \end{subfigure}
            \hfill
            \begin{subfigure}[b]{0.23\textwidth}
                \includegraphics[width=\textwidth]{charts/ps_2.eps}
                \caption{Training weight of KGE term}
                \label{fig:ps_2}
            \end{subfigure}
            \caption{Parameter sensitivity of RippleNet.}
            \label{fig:ps}
        \end{figure}
        
        In this section, we investigate the influence of parameters  and  in RippleNet.
        We vary  from  to  and  from  to , respectively, while keeping other parameters fixed.
        The results of  on MovieLens-1M are presented in Figure \ref{fig:ps}.
        We observe from Figure \ref{fig:ps_1} that, with the increase of , the performance is boosted at first since embeddings with a larger dimension can encode more useful information, but drops after  due to possible overfitting.
        From Figure \ref{fig:ps_2}, we can see that RippleNet achieves the best performance when .
        This is because the KGE term with a small weight cannot provide enough regularization constraints, while a large weight will mislead the objective function.		


\section{Conclusion and Future Work}
\label{section_conclusions}
	In this paper, we propose RippleNet, an end-to-end framework that naturally incorporates the knowledge graph into recommender systems.
	RippleNet overcomes the limitations of existing embedding-based and path-based KG-aware recommendation methods by introducing preference propagation, which automatically propagates users' potential preferences and explores their hierarchical interests in the KG.
	RippleNet unifies the preference propagation with regularization of KGE in a Bayesian framework for click-through rate prediction.
	We conduct extensive experiments in three recommendation scenarios.
	The results demonstrate the significant superiority of RippleNet over strong baselines.
	
	For future work, we plan to (1) further investigate the methods of characterizing entity-relation interactions; (2) design non-uniform samplers during preference propagation to better explore users' potential interests and improve the performance.
	




\bibliographystyle{ACM-Reference-Format}
\bibliography{sigproc} 

\end{document}
