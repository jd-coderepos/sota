\documentclass{LMCS}

\overfullrule=2 pt

\def\doi{8 (2:05) 2012}
\lmcsheading {\doi}
{1--30}
{}
{}
{Sep.~17, 2011}
{May.~31, 2012}
{}

\pdfoutput=1
\usepackage{textcomp}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[leqno]{amsmath}
\usepackage{stmaryrd}
\usepackage[dvipsnames,usenames]{color}
\usepackage{paralist}
\usepackage{xspace}
\usepackage{mismacros}
\usepackage{graphicx}
\usepackage{url}
\usepackage{proof, mathpartir}
\usepackage{syntax}
\setlength{\grammarindent}{30pt}
\usepackage{fixltx2e}
\usepackage{bussproofs}
\usepackage{subfig}
\usepackage{version}
    \includeversion{TR}
    \excludeversion{CA}
\usepackage{hyperref,enumerate}





\usepackage{listings}
\lstset{language=Java,
  commentstyle=\rm\color{blue},
  basicstyle=\ttfamily\small\color{black},
  keywordstyle=\bfseries\color{black}}
\lstset{escapeinside={(*@}{@*)}}
\lstset{literate=
{default}{{{\texttt{default}}}}7
{@Copy}{{\textcolor{blue}{\texttt{\,@Copy}}}}5
{@Deep}{{\textcolor{blue}{\texttt{\,@Deep}}}}5
{@Shallow}{{\textcolor{blue}{\texttt{\,@Shallow}}}}8}
\renewcommand{\ttdefault}{pcr}
\newcommand{\ttt}[1]{}

\newcommand{\tobeupdated}[1]{{\color{red}#1}\marginpar{\tiny\textsc{To Be Updated}}}
\newcommand{\upforinclusion}[1]{{\color{blue}#1}\marginpar{\tiny\textsc{Up For Inclusion}}}
\newcommand{\seclone}{\xspace}
\newcommand{\dpnote}[1]{\marginpar{\color{magenta}David: #1}}
\newcommand{\ftk}[1]{\marginpar{\textcolor{Green}{#1}}}



\begin{document}

\title{Secure the Clones}

\author [T.~Jensen]{Thomas Jensen}
\author [F.~Kirchner]{Florent Kirchner}
\author [D.~Pichardie]{David Pichardie}
\address{INRIA Rennes -- Bretagne Atlantique, France}
\email  {firstname.lastname@inria.fr}
\thanks {This work was supported in part by the ANSSI, the ANR, and the
         \emph{R\'egion Bretagne}, respectively under the Javasec, Parsec, and
         Certlogs projects.}

\keywords{Static analysis, Shape analysis, Type system, Java bytecode, Secure
data copying.}
\subjclass{I.1.2, F.3.1, F.3.3, D.3.3}



\begin{abstract}
  Exchanging mutable data objects with untrusted code is a delicate
  matter because of the risk of creating a data space that is
  accessible by an attacker. Consequently, secure programming guidelines for
  Java stress the importance of using defensive copying before accepting or
  handing out references to an internal mutable object.
However, implementation of a copy method (like clone()) is entirely
  left to the programmer. It may not provide a sufficiently deep copy of
  an object and is subject to overriding by a malicious sub-class. Currently 
  no language-based mechanism supports secure object cloning. 
This paper proposes a type-based annotation system for defining modular
  copy policies for class-based object-oriented programs. 
  A copy policy specifies the maximally allowed sharing between an
  object and its clone. We present a static
  enforcement mechanism that will guarantee that all classes fulfil their
  copy policy, even in the presence of overriding of copy methods, and  
  establish the semantic correctness of the overall approach in Coq.
The mechanism has been implemented and experimentally evaluated on
  clone methods from several Java libraries.
\end{abstract}

\iffalse
  La Guerre des Clones n'aura pas lieu.
  Spécification et validation de politiques de copie d'objet.
Dans les langages orientés objets, l'échange de données mutables avec du code
  inconnu est un sujet délicat, en raison du risque de création d'un espace de
  données accessible à un attaquant. Pour parer à cette éventualité, plusieurs
  normes de programmation recommandent d'effectuer des copies défensives avant
  d'accepter ou de renvoyer des références à un objet mutable interne.
En revanche, l'implémentation de méthodes de copie telles que clone() est
  laissé à la charge du développeur. Celle-ci risque alors de ne pas fournir de
  copie assez profonde, et est sujette à redéfinition par une sous-classe
  malveillante. Actuellement aucun mécanisme ne permet de sécuriser la copie
  d'objet. 
Notre travail propose un système d'annotation de types permettant la
  définition modulaire de politiques de copie pour des programmes orientés
  objet. Ces politiques définissent le niveau maximal de partage autorisé entre
  un objet et son clone. Nous présentons un mécanisme de vérification statique
  qui garantit que toutes les classes respectent leur politique de copie, y
  compris dans le cas où des méthodes de copie sont redéfinies, et dont nous
  établissons la correction sémantique en Coq. Ce mécanisme est implémenté et
  validé expérimentalement sur les méthodes de clone de plusieurs librairies
  Java.
\fi


\maketitle


\section{Introduction}


Exchanging data objects with untrusted code is a delicate matter because
of the risk of creating a data space that is accessible by an attacker.
Consequently, secure programming guidelines for Java such as those proposed by
Sun \cite{SunGuidelines:2010} and CERT \cite{CertGuidelines:2010} stress the
importance of using defensive \emph{copying} or \emph{cloning} before
accepting or handing out references to an internal mutable object. There are
two aspects of the problem:
\begin{enumerate}[(1)]
\item If the result of a method is a reference to an internal mutable object,
  then the receiving code may modify the internal state. Therefore, it is
  recommended to make copies of mutable objects that are returned as
  results, unless the intention is to share state. 
\item If an argument to a method is a reference to an object coming
  from hostile code, a local copy of the object should be
  created. Otherwise, the hostile code may be able to modify the internal
  state of the object.
\end{enumerate}

\noindent A common way for a class to provide facilities for copying objects is
to implement a \ttt{clone()} method that overrides the cloning
method provided by \ttt{java.lang.Object}. 
The following code snippet, taken from Sun's Secure Coding
Guidelines for Java, demonstrates how a \ttt{date} object is cloned
before being returned to a caller:
\begin{lstlisting}
public class CopyOutput {
    private final java.util.Date date;
    ...
    public java.util.Date getDate() {
        return (java.util.Date)date.clone(); }
}
\end{lstlisting}

\noindent However, relying on calling a polymorphic \ttt{clone} method
to ensure secure copying of objects may prove insufficient, for two
reasons. First, the implementation of the \ttt{clone()} method is
entirely left to the programmer and there is no way to enforce that an
untrusted implementation provides a sufficiently \emph{deep} copy of
the object. It is free to leave references to parts of the original
object being copied in the new object. Second,
even if the current \ttt{clone()} method works properly, sub-classes may
override the \ttt{clone()} method and replace it with a method that does not
create a sufficiently deep clone.  For the above example to behave correctly,
an additional class invariant is required, ensuring that the \ttt{date} field
always contains an object that is of class \ttt{Date} and not one of its 
sub-classes. To quote from the CERT guidelines for secure Java programming:
\emph{``Do not carry out defensive copying using the clone() method in
constructors, when the (non-system) class can be subclassed by untrusted code.
This will limit the malicious code from returning a crafted object when the
object's clone() method is invoked.''} Clearly, we are faced with a situation
where basic object-oriented software engineering principles (sub-classing and
overriding) are at odds with security concerns.
To reconcile these two aspects in a manner that provides semantically
well-founded guarantees of the resulting code, this paper proposes a formalism
for defining \emph{cloning policies} by annotating classes and specific copy
methods, and a static enforcement mechanism that will guarantee that all
classes of an application adhere to the copy policy. Intuitively,
policies impose non-sharing constraints between the structure 
referenced by a field of an object and the structure returned by the
cloning method.  Notice, that we do not enforce that
a copy method will always return a target object that is functionally
equivalent to its source. Nor does our method prevent a sub-class from
making a copy of a structure using new fields that are not governed by
the declared policy. For a more detailed example of these limitations,
see Section~\ref{sec:pol:limitations}. 



\subsection{Cloning of Objects}
\label{sec:intro:cloning}

For objects in Java to be cloneable, their class must implement the
empty interface \ttt{Cloneable}. A default \ttt{clone} method is
provided by the class \ttt{Object}: when invoked on an object of a
class, \ttt{Object.clone} will create a new object of that class and
copy the content of each field of the original object into the new
object. The object and its clone share all sub-structures of the
object; such a copy is called \textit{shallow}. 

It is common for cloneable classes to override the default clone
method and provide their own implementation. For a generic
\ttt{List} class, this could be done as follows:

\begin{lstlisting}
public class List<V> implements Cloneable
{
    public V value;
    public List<V> next;

    public List(V val, List<V> next) {
	this.value = val;
	this.next = next; }

    public List<V> clone() {
        return new List(value,(next==null)?null:next.clone()); }
}  
\end{lstlisting}
Notice that this cloning method performs a shallow copy of the list,
duplicating the spine but sharing all the elements between the list and its
clone. Because this amount of sharing may not be desirable (for the reasons
mentioned above), the programmer is free to implement other versions of
\ttt{clone()}. For example, another way of cloning a list is by copying both
the list spine and its elements\footnote{To be type-checked by the Java
compiler it is necessary to add a cast before calling \ttt{clone()} on
\ttt{value}. A cast to a sub interface of \ttt{Cloneable} that declares a
\ttt{clone()} method is necessary.}, creating what is known as a \textit{deep}
copy. 
\begin{lstlisting}
public List<V> deepClone() {
  return new List((V) value.clone(),
                  (next==null ? null : next.deepClone())); }  
\end{lstlisting}

\noindent A general programming pattern for methods that clone objects works by first
creating a shallow copy of the object by calling the \ttt{super.clone()}
method, and then modifying certain fields to reference new copies of the original
content. This is illustrated in the following snippet, taken from the class
\ttt{LinkedList} in Fig.~\ref{fig:linkedlist}:

\begin{lstlisting}
public Object clone() {  ...
  clone = super.clone();  ...
  clone.header = new Entry<E>(null, null, null); ...
  return clone;}
\end{lstlisting}

\noindent
There are two observations to be made about the analysis of such methods.
First, an analysis that tracks the depth of the clone being returned will have
to be flow-sensitive, as the method starts out with a shallow copy that is
gradually being made deeper. This makes the analysis more costly. Second,
there is no need to track precisely modifications made to parts of the memory
that are not local to the clone method, as clone methods are primarily
concerned with manipulating memory that they allocate themselves. This
will have a strong impact on the design choices of our analysis.



\subsection{Copy Policies}
\label{sec:intro:pol}

The first contribution of the paper is a proposal for a set of semantically
well-defined program annotations, whose purpose is to enable the expression of
policies for secure copying of objects. Introducing a copy policy language
enables class developers to state explicitly the intended behaviour of copy
methods. 
In the basic form of the copy policy formalism, fields of classes are
annotated with \ttt{@Shallow} and \ttt{@Deep}. Intuitively, the annotation
\ttt{@Shallow} indicates that the field is referencing an object, parts of which
may be referenced from elsewhere. The annotation \ttt{@Deep}(\ttt{X}) on a
field \ttt{f} means
that 
\begin{inparaenum}[\itshape a\upshape)]
\item upon return from \ttt{clone()}, the object referenced by this field \ttt{f} is not referenced
  from elsewhere, and
\item the field \ttt{f} is copied according to the copy policy identified by \ttt{X}. 
\end{inparaenum} 
Here, \ttt{X} is either the name of a specific policy or if omitted,
it designates the default policy of the class of the field. 
For example, the following annotations:
\begin{lstlisting}
  class List  { @Shallow V value;  @Deep List next;  ...}
\end{lstlisting}
specifies a default policy for the class \ttt{List} where the \ttt{next} field
points to a list object that also respects the default copy policy for
lists. Any method in the \ttt{List} class, labelled with the \ttt{@Copy}
annotation, is meant to respect this default policy.

In addition it is possible to define other copy policies and annotate specific
\emph{copy methods} (identified by the annotation \ttt{@Copy(...)}) with the name
of these policies.
For example, the annotation\footnote{Our implementation uses a sightly
different policy declaration syntax because of the limitations imposed by the
Java annotation language.}
\begin{lstlisting}
DL: { @Deep V value; @Deep(DL) List next;};
@Copy(DL) List<V> deepClone() {
  return new List((V) value.clone(),
                  (next==null ? null : next.deepClone())); }  
\end{lstlisting}
can be used to specify a list-copying method that also ensures that
the \ttt{value} fields of a list of objects are copied according to
the copy policy of their class (which  is a stronger policy than
that imposed by the annotations of the class \ttt{List}). We give a
formal definition of the policy annotation language in
Section~\ref{section-annotations}. 

The annotations are meant to ensure a certain degree of non-sharing between
the original object being copied and its clone. We want to state
explicitly that the parts of the clone that can be accessed via fields marked \ttt{@Deep}
are unreachable from any part of the heap that was accessible before the call
to \ttt{clone()}. To make this intention precise, we provide a formal
semantics of a simple programming language extended with policy annotations
and define what it means for a program to respect a policy
(Section~\ref{sec:policysemantics}). 

\subsection{Enforcement} 
\label{sec:intro:typ}

The second major contribution of this work is to make the developer's intent,
expressed by copy policies, statically enforceable using a type system.  We
formalize this enforcement mechanism by giving an interpretation of the policy
language in which annotations are translated into graph-shaped type
structures. For example, the default annotations of the \ttt{List} class defined above
will be translated into the graph that is depicted to the right in 
Fig.~\ref{fig:listab}  (\ttt{res} is the name given to
the result of the copy method). The left part shows the concrete heap structure.

Unlike general purpose shape analysis, we take into account the programming
methodologies and practice for copy methods, and design a type system
specifically tailored to the enforcement of copy policies.  This means that
the underlying analysis must be able to track precisely all modifications to
objects that the copy method allocates itself (directly or indirectly) in a
flow-sensitive manner.  Conversely, as copy methods should not modify
non-local objects, the analysis will be designed to be more approximate when
tracking objects external to the method under analysis, and the type system
will accordingly refuse methods that attempt such non-local modifications. As
a further design choice, the annotations are required to be verifiable
modularly on a class-by-class basis without having to perform an analysis of
the entire code base, and at a reasonable cost.

\begin{figure}
  \centering
  \includegraphics[width=.8\linewidth]{listalpha}
  \caption{A linked structure (left part) and its abstraction (right part).}
  \label{fig:listab}
\end{figure}

As depicted in Fig.~\ref{fig:listab}, concrete memory cells
are either abstracted as
\begin{inparaenum}[\itshape a\upshape)]
\item  when they are not allocated in the copy method itself (or its callee);
\item  when they are just marked as \emph{maybe-shared}; and
\item circle nodes of a deterministic graph when they are locally allocated and not shared. A single 
circle furthermore expresses a singleton concretization.
\end{inparaenum} 
In this example, the abstract heap representation matches the graph
interpretation of annotations, which means that the instruction set that
produced this heap state satisfies the specified copy policy.

Technically, the intra-procedural component of our analysis corresponds to
heap shape analysis with the particular type of graphs that we have defined.
Operations involving non-local parts of the heap are rapidly discarded.
Inter-procedural analysis uses the signatures of copy methods provided by the
programmer. Inheritance is dealt with by stipulating that inherited fields
retain their ``shallow/deep'' annotations.  Redefinition of a method must
respect the same copy policy and other copy methods can be added to a
sub-class. 
The detailed definition of the analysis, presented as a set of type inference
rules, is given in Section~\ref{sec:type-system}. 

This article is an extended version of a paper presented at ESOP'11~\cite{JensenKP:Esop11}.
We have taken advantage of the extra space to provide improved and more detailed
explanations, in particular of the inference mechanism and of what is
exactly is being enforced by our copy policies. We have also added
details of the proof of correctness of the enforcement
mechanism. The formalism of copy policies and the correctness theorem
for the core language defined in Section~\ref{section-annotations} have been
implemented and verified mechanically in Coq~\cite{clone-webpage}.
The added details about the proofs should especially facilitate the 
understanding of this Coq development
















\section{Language and Copy Policies}\label{section-annotations}


\begin{figure}
  \centering
  \begin{small}
\begin{frameit}


\
\begin{small} \begin{array}{rrlcl} l &\in& \Loc \\ v &\in& \Val &=& \Loc \cup
\{ \vnull \} \\ \rho &\in& \Env &=& \Var \to \Val \\ o &\in& \Object &=&
\Field \to \Val \\ h &\in& \Heap &=& \Loc \ptofin \left( \ClassName \times
\Object\right) \\ \st{\rho,h,A}&\in& \State &=&
\Env\times\Heap\times\Power(\Loc) \end{array} \end{small} 
\begin{array}{c}
\inferrule
 {~~}
 {\left(\HAssign{x}{y},\stb{\rho,h,A}\right) \leadsto \str{\rho[x\mapsto\rho(y)],h,A}}
\qquad
\inferrule
 {~~}
 {\left(\HAssign{x}{\snull},\stb{\rho,h,A}\right) \leadsto \str{\rho[x\mapsto\vnull],h,A}}
\3ex]
\inferrule
 {l \not\in \dom(h)}
 {\left(\HNew{x}{\var{cn}},\stb{\rho,h,A}\right) \leadsto \str{\rho[x\mapsto l],h[l \mapsto (\var{cn},o_{\vnull})],A\cup\{l\}}}
\3ex]
\inferrule
{\begin{array}{c}
  h(\rho(y))=(\var{cn}_y,\underscore) \quad \lookup(\var{cn}_y,m) = \left(\Copy(X')~\HAssign{m(a)}c\right) 
  \quad \var{cn}_y \preceq \var{cn} \cr
  (c,\stb{\rho_{\vnull}[a\mapsto\rho(y)],h,\emptyset}) \leadsto \str{\rho',h',A'} \cr
\end{array}}
 {\left(\HCall{x}{\var{cn}:X}{y},\stb{\rho,h,A}\right) \leadsto \str{\rho[x\mapsto \rho'(\ret)],h',A\cup A'}}
\3ex]
\inferrule
{{\left(c_1,\stb{\rho,h,A}\right) \leadsto \str{\rho_1,h_1,A_1}}\quad
 {\left(c_2,\stb{\rho_1,h_1,A_1}\right) \leadsto \str{\rho_2,h_2,A_2}}}
{\left(c_1; c_2,\stb{\rho,h,A}\right) \leadsto \str{\rho_2,h_2,A_2}}\3ex]
\inferrule{~~}
{\left(\HWhile{c},\stb{\rho,h,A}\right) \leadsto \str{\rho,h,A}}\qquad
\inferrule
{\left(c; \HWhile{c},\stb{\rho,h,A}\right) \leadsto \str{\rho',h',A'}}
{\left(\HWhile{c},\stb{\rho,h,A}\right) \leadsto \str{\rho',h',A'}}
\end{array}
\Pi_p(X) \subseteq \Pi_p(X').
(\HCall{x}{\var{cn}:X}{y}, \st{\rho_1,h_1,A_1}) \leadsto \st{\rho_2,h_2,A_2}
  ~~\text{implies}~~\rho_2,h_2,x \models \tau
\tau_1\subseteq\tau_2 ~\text{implies}~ 
\forall h,\rho,x,~~ \rho,h,x \models \tau_2 ~\Rightarrow \rho,h,x \models \tau_1

n           &\in\Node
  &t        &\in\BaseType = \Node + \{ \bot,  \topout, \top \} \\
\Gamma      &\in \Var \to \BaseType 
  &\Delta   &\in \LSG = \Node \ptofin \Field \to \BaseType \\
\Theta      &\in \Power(\Node) 
  &T        &\in  \Type = (\Var \to \BaseType)\times\LSG\times\Power(\Node) 

  \Gamma &= [\mathtt{res}\mapsto n_1, \mathtt{this}\mapsto \topout] \\
  \Delta &= 
  [ (n_1,\mathtt{next})\mapsto n_2,(n_2,\mathtt{next})\mapsto n_2,(n_1,\mathtt{value})\mapsto \top,(n_2,\mathtt{value})\mapsto \top ] \\
  \Theta &=  \{n_1\}.

\inferrule{~}{\tevalexpr{\Gamma}{\Delta}{x}{\Gamma(x)}}
\quad
\inferrule{\tevalexpr{\Gamma}{\Delta}{\pi}{n}}
          {\tevalexpr{\Gamma}{\Delta}{\pi.f}{\Delta[n,f]}}
\quad
\inferrule{\tevalexpr{\Gamma}{\Delta}{\pi}{\top}}
          {\tevalexpr{\Gamma}{\Delta}{\pi.f}{\top}}
\quad
\inferrule{\tevalexpr{\Gamma}{\Delta}{\pi}{\topout}}
          {\tevalexpr{\Gamma}{\Delta}{\pi.f}{\topout}}

\Delta_p = \displaystyle\bigcup_{X:\{ (X_1,f_1);\ldots ;(X_k,f_k)\} \in \Pi_p} 
  \left[ (n'_X,f_1) \mapsto n'_{X_1}, \cdots, (n'_X,f_k) \mapsto n'_{X_k} \right]

\Phi(\tau)=\left(n_\tau,
                 \Delta_p\cup\left[ (n_\tau,f_1) \mapsto n'_{X_1}, \cdots, (n_\tau,f_k) \mapsto n'_{X_k} \right],
                 \{n_\tau\}\right)
{\InterpM{\rho}{h}{A}{\Gamma}{\Delta}{\Theta}}
\begin{array}{c}
\inferrule{~~}
{\Interpret{\rho}{h}{A}{\Gamma}{\Delta}{\vnull}{t}}
~~~~
\inferrule{~~}
{\Interpret{\rho}{h}{A}{\Gamma}{\Delta}{v}{\top}}
~~~~
\inferrule{
\Reach{h}{l}\cap A = \emptyset
}
{\Interpret{\rho}{h}{A}{\Gamma}{\Delta}{l}{\topout}}
\}
\begin{minipage}[t]{.9965\linewidth}
\bf Main type interpretation
\end{minipage}
{\scriptsize}
\caption{Type Interpretation}\label{fig:type:interpret}
\end{figure}























We now establish a semantic link between policy semantics and type
interpretation. We show that if the final state of a copy method can be given a type 
of the form  then this is a secure method wrt. the policy .

\begin{thm}
\label{th:policy-type}
Let , , and . Assume that, for all  such that  is
distinct from ,  is not reachable from  in a
given heap , \emph{i.e.} .  If there
exists a state of the form , a return variable  and a
local variable type  such that ,
 and
, then  holds.
\end{thm}
\begin{proof}

[See Coq proof \texttt{InterpAnnot.sound_annotation_to_type}~\cite{clone-webpage}]

We consider two paths  and  such that
, , ,
 and look for a contradiction. 
Since  and , there exists a
node  such that 
. Furthermore
 so we can deduce that .  Thus we
obtain a contradiction with  because any
path that starts from a variable other than  cannot reach the
elements in .
\end{proof}




\subsection{Sub-typing}

\begin{figure}
\centering\scriptsize
\begin{minipage}[t]{.9965\linewidth}
\bf Value sub-typing judgment
\end{minipage}\\

\begin{minipage}[t]{.9965\linewidth}
\bf Main sub-typing judgment
\end{minipage}\
      &\sigma\in\dom (\Delta_1) \rightarrow \dom (\Delta_2) + \{\top\}
        \label{eq:st1}\\
      \begin{split}
        &\forall t_1\in\BaseType, \forall \pi\in\AccessPath, \tevalexpr{\Gamma_1}{\Delta_1}{\pi}{t_1} 
         \Rightarrow \exists t_2\in \BaseType, t_1 \leq_\sigma t_2 \wedge \tevalexpr{\Gamma_2}{\Delta_2}{\pi}{t_2} 
      \end{split}
        \label{eq:st2} \\
      &\forall n_2\in\Theta_2, ~ \exists n_1\in\Theta_1,~ \sigma^{-1}(n_2) = \{n_1\} \label{eq:st3}
    
\exists t_1 \leq_\sigma t_2,\quad
\tevalexpr{\Gamma_1}{\Delta_1}{\pi}{t_1}. 

{\InterpretS{\rho}{h}{A}{(\Gamma_1,\Delta_1)}{v}{t_1}}
~~
\text{and}
~~t_1 \sqsubseteq_\sigma t_2~~
\text{implies}
~~
{\InterpretS{\rho}{h}{A}{(\Gamma_2,\Delta_2)}{v}{t_2}}.

\Gamma,\Delta,\Theta \vdash c : \Gamma',\Delta',\Theta'.
3ex]
\inferrule{\Gamma(\var{y})=t\qquad t\in\{\topout,\top\}}
  {\tst{\Gamma,\Delta,\Theta} \vdash \HAssign{x}{y.f} : \tstr{\Gamma[\var{x}\mapsto t],\Delta,\Theta}}
\quad
\inferrule{\Gamma(\var{y})=n}
  {\tstb{\Gamma,\Delta,\Theta} \vdash \HAssign{x}{y.f} : \tstr{\Gamma[\var{x}\mapsto \Delta[n,f]],\Delta,\Theta}}
\3ex]
\inferrule{\Gamma(\var{x})=n\quad n\not\in\Theta
 \quad (\Gamma,\Delta[n,f \mapsto \Gamma(y)],\Theta) \sqsubseteq (\Gamma',\Delta',\Theta')
 \quad (\Gamma,\Delta,\Theta) \sqsubseteq (\Gamma',\Delta',\Theta')
}
  {\tstb{\Gamma,\Delta,\Theta} \vdash \HAssign{x.f}{y} : \tstr{\Gamma',\Delta',\Theta'}}
\3ex]
\inferrule{\tstb{\Gamma',\Delta',\Theta'} \vdash c : \tstr{\Gamma_0,\Delta_0,\Theta_0} \quad (\Gamma,\Delta,\Theta)\sqsubseteq (\Gamma',\Delta',\Theta') \quad (\Gamma_0,\Delta_0,\Theta_0)\sqsubseteq (\Gamma',\Delta',\Theta')}
  {\tstb{\Gamma,\Delta,\Theta} \vdash \HWhile{c} : \tstr{\Gamma',\Delta',\Theta'}}
\4ex]
\inferrule{
\Pi_p(X) = \tau \quad \Phi(\tau) = (n_\tau,\Delta_\tau) \quad
\nodes(\Delta)\cap \nodes(\Delta_\tau) = \emptyset \quad
(\Gamma(y) = \bot) \vee (\Gamma(y)=\topout)}
  {\tstb{\Gamma,\Delta,\Theta} \vdash \HCall{x}{\var{cn}:X}{y} : \tstr{\Gamma[x\mapsto n_\tau],\Delta\cup\Delta_\tau,\Theta\cup\{n_\tau\}}}
\4ex]
\inferrule{(\Gamma(y) = \bot) \vee (\Gamma(y)=\topout)}
  {\tstb{\Gamma,\Delta,\Theta} \vdash \UnkownCall{x}{y} : \tstr{\Gamma[x\mapsto \topout],\Delta,\Theta}}
\quad
\inferrule{
\mathit{KillSucc}_{n}(\Gamma,\Delta,\Theta) = (\Gamma',\Delta',\Theta')\quad
\Gamma(y) = n}
  {\tstb{\Gamma,\Delta,\Theta} \vdash \UnkownCall{x}{y} : \tstr{\Gamma'[x\mapsto \topout],\Delta',\Theta'}}
\\\inferrule{~~}
  {\tstb{\Gamma,\Delta,\Theta} \vdash \HReturn{x} : \tstr{\Gamma[\var{ret}\mapsto\Gamma(x)],\Delta,\Theta}}
\end{array}

  \inferrule{
    \begin{array}[c]{c}
 [~\cdot\mapsto\bot][x\mapsto \topout], \emptyset, \emptyset \vdash c : \Gamma,\Delta,\Theta \cr
   \Pi_p(X) = \tau \quad \Phi(\tau) = (n_\tau,\Delta_\tau) \quad
     (\Gamma, \Delta, \Theta) \sqsubseteq (\Gamma',\Delta_\tau,\{n_\tau\})
\quad \Gamma'(\var{ret}) =  n_\tau 
   \end{array}}
  {  \vdash \Copy(X)~\HAssign{m(x)}{}c}

  \inferrule{\forall \var{cl}\in p, ~ \forall\md\in\var{cl},~~  \vdash  \md }
  {\vdash p}
\Delta[(n,\_)\mapsto\bot]\Deltan\bot\mathit{KillSucc}_{n}n\top\HIf{}{}\HWhile{}\HNew{x}{}n\Delta\Gamma(x)\HAssign{x.f}{y}xn\Gamma(x) = n\Deltanf\Gamma(y)n\in\Thetanx.fnm(\var{y})m\var{y}\tau(n_\tau,\Delta_\tau)\HCall{x}{\var{cn}:X}{y}(\Gamma,\Delta,\Theta)\Gammaxn_\tau\Delta\Delta_\taun_\tau\var{y}\var{y}nnn\top \UnkownCall{x}{y}\var{y}\var{x}\var{y}nm\Phi(\tau)\HAssign{x.f}{y}\Gamma(\var{x})=\top\topout\var{x}\var{f}\var{f}\topT_ii\topoutT_{13}T_{14}T_{16}T_{17}T_{16}e\mapsto\topoutT_{24}T_{19}T_{23}T=(\Gamma,\Delta,\Theta),
T_1=(\Gamma_1,\Delta_1,\Theta_1),T_2=(\Gamma_2,\Delta_2,\Theta_2)\in\Typec\in\prog\st{\rho,h,A},
\st{\rho_1,h_1,A_1}, \st{\rho_2,h_2,A_2}\in\Statel_f\pi'l_f\pifl,l'\evalexpr{\rho}{h}{\pi}{l'}\pi'l_f\evalexpr{\rho}{h[l,f\mapsto l']}{\pi'}{l_f}\exists \pi_z, \pi_1, \ldots, \pi_n, \pi_f\pi\st{\rho,h}\st{\rho,h[l,f\mapsto l']}\InterpMMM{\rho}{h}{A}{\Gamma,\Delta,\Theta}\rho(x)=l_x\in A\Gamma(x)=n_x\in \Theta\rho(y)=l_y\Gamma(y)=t_y\pivtt \neq
\topv \neq \vnull\evalexpr{\rho}{h}{\pi}{v}\InterpMMM{\rho}{h}{A}{\Gamma,\Delta,\Theta}\tevalexpr{\Gamma}{\Delta}{\pi}{t}\evalexpr{\rho}{h}{y}{l_y}\exists \pi_f,
\evalexpr{\rho}{h}{y.\pi_f}{v}\tevalexpr{\Gamma}{\Delta}{y.\pi_f}{t}{T_1 \vdash c: T_2}\InterpMM{\rho_1}{h_1}{A_1}{T_1}(c,\st{\rho_1,h_1,A_1}) \leadsto \st{\rho_2,h_2,A_2}\InterpMM{\rho_2}{h_2}{A_2}{T_2}ccT_2\top\bot\topoutc\equiv \HAssign{x}{y}\st{\rho_2,h_2,A_2} = \st{\rho_1[x\mapsto\rho_1(y)],h_1,A_1}(\rho_2,h_2,\Gamma_2,\Delta_2)x.\pi\rho_2(x)=\rho_1(y)\Gamma_2(x)=\Gamma_1(y)y.\pi(\rho_1,h_1,\Gamma_1,\Delta_1)\InterpMMM{\rho_1}{h_1}{A_1}{\Gamma_1,\Delta_1,\Theta_1}y.\piv\evalexpr{\rho_1}{h_1}{y.\pi}{v}n\tevalexpr{\Gamma_1}{\Delta_1}{y.\pi}{n}{\Interpret{\rho_1}{h_1}{A_1}{\Gamma_1}{\Delta_1}{v}{n}}x.\pi{\Interpret{\rho_1[x\mapsto\rho_1(y)]}{h_1}{A_1}{\Gamma_1[x\mapsto\Gamma_1(y)]}{\Delta_1}{v}{n}}\evalexpr{\rho_1[x\mapsto\rho_1(y)]}{h_1}{x.\pi}{v}\tevalexpr{\Gamma_1[x\mapsto\Gamma_1(y)]}{\Delta_1}{x.\pi}{n}xn \in \Theta_2n\pi\pi'\Delta_2xh_2=h_1\pix\pi'zll'\Gamma_2(x)=\Gamma_1(y)\Delta_2=\Delta_1\pi''(\rho_1,h_1,\Delta_1,\Gamma_1)y\evalexpr{\rho_1}{h_1}{\pi''}{l}z\evalexpr{\rho_1}{h_1}{\pi'}{l'}n \in
  \Theta_1\InterpMMM{\rho_1}{h_1}{A_1}{\Gamma_1,\Delta_1,\Theta_1}l = l'\InterpMMM{\rho_1[x\mapsto\rho_1(y)]}{h_1}{A_1}{\Gamma_1[\var{x}\mapsto\Gamma_1(\var{y})],\Delta_1,\Theta_1}c\equiv \HAssign{x.f}{y}\st{\rho_2,h_2,A_2} = \st{\rho_1,h_1[(\rho_1(x),f)\mapsto \rho_1(y)],A_1}n = \Gamma(x)c\equiv \HAssign{x.f}{y}n=\Gamma(x)\in\Thetanh\pinl\tevalexpr{\Gamma_2}{\Delta_2}{\pi}{n}\evalexpr{\rho_2}{h_2}{\pi}{l}\pif\evalexpr{\rho_1}{h_1}{\pi}{l} \wedge
    \tevalexpr{\Gamma_1}{\Delta_1}{\pi}{n}\Interpret{\rho_1}{h_1}{A_1}{\Gamma_1}{\Delta_1}{l}{n}\pi_0\evalexpr{\rho_2}{h_2}{\pi_0}{l}n_0\tevalexpr{\rho_2}{h_2}{\pi_0}{n_0}\Interpret{\rho_1}{h_1}{A_1}{\Gamma_1}{\Delta_1}{l}{n_0}n_0=n\Delta_1\Delta_2\pif\pi'(\rho_1,h_1,\Gamma_1,\Delta_1)y.\pi'ln\evalexpr{\rho_1}{h_1}{y.\pi'}{l} \wedge
    \tevalexpr{\Gamma_1}{\Delta_1}{y.\pi'}{n}\pi_0\evalexpr{\rho_2}{h_2}{\pi_0}{l}\tevalexpr{\rho_2}{h_2}{\pi_0}{n_0}\Interpret{\rho_1}{h_1}{A_1}{\Gamma_1}{\Delta_1}{l}{n_0}n=n_0\pi_0\pin \in \Theta_2n\pi\pi'\Delta_2f\evalexpr{\rho_1}{h_1}{\pi}{l} \wedge \tevalexpr{\Gamma_1}{\Delta_1}{\pi}{n} \wedge
      \evalexpr{\rho_1}{h_1}{\pi'}{l'} \wedge \tevalexpr{\Gamma_1}{\Delta_1}{\pi'}{n}l=l'f\evalexpr{\rho_1}{h_1}{\pi'}{l'} \wedge
      \tevalexpr{\Gamma_1}{\Delta_1}{\pi}{n}\pi_\star(\rho_1,h_1,\Gamma_1,\Delta_1)y.\pi_\starln\evalexpr{\rho_1}{h_1}{y.\pi_\star}{l} \wedge
      \tevalexpr{\Gamma_1}{\Delta_1}{y.\pi_\star}{n}l=l'f\pi_\star\pi'_\stary.\pi_\starlny.\pi'_\starl'n\evalexpr{\rho_1}{h_1}{y.\pi_\star}{l} \wedge
      \tevalexpr{\Gamma_1}{\Delta_1}{y.\pi_\star}{n} \wedge
      \evalexpr{\rho_1}{h_1}{y.\pi'_\star}{l'} \wedge
      \tevalexpr{\Gamma_1}{\Delta_1}{y.\pi'_\star}{n}l=l'l=l'h_1l=l'h_2\InterpMMM{\rho_1}{h_1[(\rho_1(x),f)\mapsto
    \rho_1(y)]}{A_1}{\Gamma_1,\Delta_1[n,f \mapsto \Gamma(y)],\Theta_1}n\in\Thetac\equiv \HAssign{x.f}{y}n=\Gamma(x)\notin\Thetanh\sigma_1\sigma_2(\Gamma_1,\Delta_1,\Theta_1)\sqsubseteq(\Gamma_2,\Delta_2,\Theta_2)(\Gamma_1,\Delta_1[n,f\mapsto
    \Gamma_1(y)],\Theta_1)\sqsubseteq(\Gamma_2,\Delta_2,\Theta_2)\pi(\rho_2,h_2,\Gamma_2,\Delta_2)l_0n_0'l\rho_1(x)l'\rho_1(y)l_fl_0\piy\pi'\pi\pif\evalexpr{\rho_1}{h_1}{\pi}{l_0}n_0\pi(\rho_1,h_1,\Gamma_1,\Delta_1)\tevalexpr{\Gamma_1}{\Delta_1}{\pi}{n_0}n'_0=\sigma_1(n_0)n_0l_0\Interpret{\rho_1}{h_1}{A_1}{\Gamma_1}{\Delta_1}{l_0}{n_0}l_0n'_0\pi_0\evalexpr{\rho_2}{h_2}{\pi_0}{l_0}\tevalexpr{\Gamma_2}{\Delta_2}{\pi_0}{n'_0}\pi_0l\rho_1(x)l'\rho_1(y)l_fl_0\piy\pi'\pi_0\pi_0f\pi_0 = \pi_z.f.\pi_1.f.\ldots.f.\pi_n.f.\pi_fn'_0(\Gamma_2,\Delta_2)n_x'n_y'\sigma_1(\Gamma_1(x)) = n_x'\sigma_1(\Gamma_1(y)) = n_y'\bullet\evalexpr{\rho_1}{h_1}{\pi_z}{\rho_1(x)}\tevalexpr{\Gamma_1}{\Delta_1}{\pi_z}{\Gamma_1(x)}\tevalexpr{\Gamma_2}{\Delta_2}{\pi_z}{n_x'}i\in [1,n]\evalexpr{\rho_1}{h_1}{y.\pi_i}{\rho_1(x)}\tevalexpr{\Gamma_1}{\Delta_1}{y.\pi_i}{\Gamma_1(x)}\tevalexpr{\Gamma_2}{\Delta_2}{y.\pi_i}{n_x'}\evalexpr{\rho_1}{h_1}{y.\pi_f}{l_0}\tevalexpr{\Gamma_1}{\Delta_1}{y.\pi_f}{n_0}\tevalexpr{\Gamma_2}{\Delta_2}{y.\pi_f}{n'_0}n'_0 = \sigma_1(n_0)\Delta_1[n,f \mapsto \Gamma_1(y)]n = \Gamma_1(x)\Gamma_1(y)f\Gamma_1,\Delta_1,\Theta_1\Gamma_1,\Delta_1[n,f\mapsto
    \Gamma_1(y)],\Theta_1\Gamma_1\sigma_2(\Gamma_1(x)) = \sigma_1(\Gamma_1(x)) = n_x'\sigma_2(\Gamma_1(y)) = \sigma_1(\Gamma_1(y)) = n_y'\Delta_2n_x'n_y'f\sigma_2\tevalexpr{\Gamma_2}{\Delta_2}{\pi_0}{n'_0}n_x'n_y'\pif\pi\pi_z.f.\pi_1.f.\ldots.f.\pi_n.f.\pi_f\Delta_1l_0(\rho_1,h_1,\Gamma_2,\Delta_2)l_0n'_0\pil_0\st{\rho_1,h_1}\evalexpr{\rho_1}{h_1}{y.\pi_f}{l_0}y.\pi_fn'_0\Delta_2n_x'n_y'\Delta_2n_x' = \sigma_1(\Gamma_1(x)) =
    \sigma_2(\Gamma_1(x))n_y' = \sigma_1(\Gamma_1(y)) =
    \sigma_2(\Gamma_1(y))\Gamma_2(x)=\topn'_0=\top\sigma_1\sigma_24\pi\pi_z\Gamma_1(x)\Delta_1n_x'\Delta_2\evalexpr{\rho_1}{h_1}{\pi_z}{\rho_1(x)}\tevalexpr{\Gamma_1}{\Delta_1}{\pi_z}{\Gamma_1(x)}\tevalexpr{\Gamma_2}{\Delta_2}{\pi_z}{n_x'}i\in[1,n]\tevalexpr{\Gamma_1}{\Delta_1}{y.\pi_i}{\Gamma_1(x)}\Delta_2n_x'n_y'fi\in[1,n]\tevalexpr{\Gamma_2}{\Delta_2}{y.\pi_i}{n_x'}\Delta_2\tevalexpr{\Gamma_2}{\Delta_2}{\pi_z.f.\pi_1.f.\ldots.f.\pi_n}{n_x'}\tevalexpr{\Gamma_2}{\Delta_2}{y.\pi_f}{n_0'}n_0\rho_1,h_1,\Delta_1,\Gamma_1y.\pi_f\tevalexpr{\Gamma_1}{\Delta_1}{y.\pi_f}{n_0}n_0' =
    \sigma_1(n_0)n_0l_0\Interpret{\rho_1}{h_1}{A_1}{\Gamma_1}{\Delta_1}{l_0}{n_0}l_0n'_0\pi_0\evalexpr{\rho_2}{h_2}{\pi_0}{l_0}\tevalexpr{\Gamma_2}{\Delta_2}{\pi_0}{n'_0}\pi_0l\rho_1(x)l'\rho_1(y)l_fl_0\piy\pi'\pi_0\pi_0f\pi_0 = \pi'_z.f.\pi'_1.f.\ldots.f.\pi'_n.f.\pi'_fn'_0(\Gamma_2,\Delta_2)\bullet\evalexpr{\rho_1}{h_1}{\pi'_z}{\rho_1(x)}\tevalexpr{\Gamma_1}{\Delta_1}{\pi'_z}{\Gamma_1(x)}\tevalexpr{\Gamma_2}{\Delta_2}{\pi'_z}{n_x'}i\in [1,n]\evalexpr{\rho_1}{h_1}{y.\pi'_i}{\rho_1(x)}\tevalexpr{\Gamma_1}{\Delta_1}{y.\pi'_i}{\Gamma_1(x)}\tevalexpr{\Gamma_2}{\Delta_2}{y.\pi'_i}{n_x'}\evalexpr{\rho_1}{h_1}{y.\pi_f}{l_0}l_0n_0\tevalexpr{\Gamma_1}{\Delta_1}{y.\pi_f}{n_0}\tevalexpr{\Gamma_2}{\Delta_2}{y.\pi_f}{n'_0}n'_0 =
    \sigma_1(n_0)\tevalexpr{\Gamma_2}{\Delta_2}{\pi_0}{n'_0}n\in\Theta_2\pi\pi'\rho_2,h_2,\Gamma_2,\Delta_2f\evalexpr{\rho_1}{h_1}{\pi}{l} \wedge
      \evalexpr{\rho_1}{h_1}{\pi'}{l'}n'n = \sigma_1(n')\tevalexpr{\Gamma_1}{\Delta_1}{\pi}{n'} \wedge
      \tevalexpr{\Gamma_1}{\Delta_1}{\pi'}{n'}l=l'f\evalexpr{\rho_1}{h_1}{\pi}{l}\pi'=\pi_0.f.\pi_1.f.\ldots.f.\pi_n.f.\pi_f\evalexpr{\rho_1}{h_1}{y.\pi_f}{l'}n'n=\sigma_1(n')\tevalexpr{\Gamma_1}{\Delta_1}{\pi}{n'}n''\Delta_1y.\pi_fn\sigma_1n=\sigma_1(n'')\tevalexpr{\Gamma_1}{\Delta_1}{y.\pi_f}{n''}n'=n''l=l'f\pi_f\pi'_fy.\pi_fly.\pi'_fl'\evalexpr{\rho_1}{h_1}{y.\pi_\star}{l} \wedge
      \evalexpr{\rho_1}{h_1}{y.\pi'_\star}{l'}n'\Delta_1l=l'c\equiv \HAssign{x.f}{y}{ \vdash p}mpm\Copy(X)\{\tau\}h_1,h_2\in\Heap\rho_1,\rho_2\in\EnvA_1,A_2\in\Power(\Loc) x,y\in\Varm\Copy(X')~\HAssign{m(a)}c\tau'X'\tau \subseteq \tau'\rho_2,h_2,x \models \tau'\Copy(X')~\HAssign{m(a)}c\Gamma',\Gamma,\Delta,\Theta\Gamma'(\var{ret}) =  n_\tau(\Gamma, \Delta, \Theta) \sqsubseteq (\Gamma',\Delta_\tau,\{n_\tau\})[~\cdot\mapsto\bot][x\mapsto \topout], \emptyset, \emptyset \vdash c : \Gamma,\Delta,\Theta\InterpMMM{\rho'}{h_2}{A'}{\Gamma,\Delta,\Theta}(\Gamma, \Delta, \Theta)(\Gamma',\Delta_\tau,\{n_\tau\})\InterpMMM{\rho'}{h_2}{A'}{\Gamma',\Delta_\tau,\{n_\tau\}}\rho_2,h_2,x \models \tau(\Type,\sqsubseteq)\sqsubseteq\TypeT\in\TypeT\sqsubseteq_\textit{id} TT_1, T_2, T_3\in\TypeT_1\sqsubseteq_{\sigma_1}T_2T_2\sqsubseteq_{\sigma_2}T_3\sigma_1\sigma_2T_1\sqsubseteq_{\sigma_3}T_3\sigma_3\sigma_3(n) = \sigma_2(\sigma_1(n))\sigma_1(n)\in\Node\top\equivT_1\equiv
T_2T_1\sqsubseteq T_2T_2\sqsubseteq
T_1\sqsubseteq(\Type,\equiv)\Type\equiv\sqsubseteqn_ix_if_ii(\Gamma,\Delta,\Theta)\Delta\Gamma\Delta\gc\gc\sqsubseteq\gc\equivT_1,T_2\in\TypeT_1\equiv T_2~~\text{iff}~~ T_1=T_2\sqcup\alpha\BaseType\alpha\alpha\Gamma_1\Gamma_2\Delta_1 \cup \Delta_2\alpha\{(x,t);(x,t')\} \subseteq (\Gamma_1\times\Gamma_2)\{t,t'\}\alpha\exists u\in\alpha,\exists f\in\Field, |succ(u,f)| > 1uf\alpha(\Gamma,\Delta,\Theta)\Gamma_1\Gamma_2\alphaSt\in\BaseType\llparenthesis S\rrparenthesisSS\alpha\llparenthesis S\rrparenthesis\alpha \gets \alpha + nt \in Sf \in \Field\exists u, \alpha(t,f)=u\alpha \gets \alpha(n,f) \mapsto u\exists n', \alpha(n',f)=t\alpha \gets \alpha(n',f) \mapsto n\alpha \gets \alpha - tT_1=(\Gamma_1,\Delta_1,\Theta_1)T_2=(\Gamma_2,\Delta_2,\Theta_2)\Delta_1\Delta_2\alpha\BaseType\alpha\Gamma_i\Gamma_i\alpha\Gamma_i\Delta\alpha\leq_\sigma\Gamma\Gamma_i\alpha\Delta\sigma\Delta_1\cup\Delta_2\Delta\Gamma_1\Gamma_2\Delta\alphax \in \text{Var}\alpha \gets \alpha + \llparenthesis\{\Gamma_1(x)\}\rrparenthesis + \llparenthesis\{\Gamma_2(x)\}\rrparenthesisn \in \Delta\exists f\in\text{Fields}, \exists b\in\text{BaseType}, \Delta[n,f]=b\alpha \gets \alpha + \llparenthesis\{n\}\rrparenthesis + \llparenthesis\{b\}\rrparenthesis\alpha \gets \alpha(\llparenthesis \{n\}\rrparenthesis,f) \mapsto \llparenthesis \{b\}\rrparenthesis\alpha\Type\Gamma_1\Gamma_2\alpha\Var\to\BaseType\Gamma\lambda x.\bot\LSG\DeltaN\in \alphax\in \Var, \Gamma_1(x)\in N \vee \Gamma_2(x)\in N\Gamma \gets \Gammax \mapsto \nmlz{N}N,N' \in \alpha\alpha(N,f)=N'\Delta \gets \Delta(\nmlz{N},f) \mapsto \nmlz{N'}(\Gamma,\Delta)\leq_\sigma\downarrow\top\in N\top\forall c\in N, c=\bot\bot\sqcup\sigma_1\sigma_2\sigma(T,\sigma)= T_1\sqcup T_2T_1 \sqsubseteq TT_2
  \sqsubseteq Tt_1t_2(T,\sigma)= T_1 \sqcup T_2T'T_1 \sqsubseteq T'T_2 \sqsubseteq T'T \sqsubseteq T'TT\sqsubseteq T'\sigma\leq_\tau\sqsubseteq_\sigma\alt\sqsubseteq_\sigma\leq_\sigmaT'\alpha'T_1T_2T'\beta\beta \alt \alpha'\beta\gamma\gamma \alt \alpha'\BaseType\gammaTT'\nabla\in\Type\times\Type\to\Type\sqcupnn2NN\{\}$ (the same signature as
\ttt{java.lang.Object.clone()}). In some cases, for instance in the
\ttt{DomAttr} class, this will happen when the copy method returns the result
of another, unannotated method call, and can be mitigated with additional copy
annotations. In other cases, merges between abstract values result in
precision losses: this is, for instance, the case for the \ttt{clone} method
of the TreeMap class, as explained above.

Our prototype confirms the efficiency of the enforcement technique:
these verifications took about 25s to run on stock hardware.
The prototype, the Coq formalization and proofs, as well as examples of annotated
classes can be found at \url{http://www.irisa.fr/celtique/ext/clones}.










\section{Related Work}
\label{sec:relatedwork}

Several proposals for programmer-oriented annotations of Java programs
have been published following Bloch's initial proposal of an annotation
framework for the Java language \cite{Bloch04}. 
These proposals define the syntax of the annotations but often leave
their exact semantics unspecified. A notable exception is the set of
annotations concerning non-null annotations \cite{Fahndrich03} for which a precise
semantic characterization has emerged~\cite{hubert08}. 
Concerning security, the GlassFish environment in Java offers program annotations of
members of a class (such
as \ttt{@DenyAll} or \ttt{@RolesAllowed}) for implementing role-based access control to
methods. 

To the best of our knowledge, the current paper is the first to
propose a formal, semantically founded framework for secure cloning through program
annotation and static enforcement. The closest work in
this area is that of Anderson \emph{et al.}~\cite{AndersonGayNaik:PLDI09}
who have designed an annotation system for C data structures in order
to control sharing between threads. Annotation policies are enforced by
a mix of static and run-time verification. On the run-time verification
side, their approach requires an operator that can dynamically
``cast'' a cell to an unshared structure. 
In contrast, our approach offers a completely static mechanism with
statically guaranteed alias properties.

Aiken \emph{et al.} proposes an analysis for checking and inferring
local non-aliasing of data~\cite{Aiken:03}. They propose to annotate C function parameters with
the keyword \ttt{restrict} to ensure that no other aliases to the data
referenced by the parameter are used during the execution of the
method. A type and effect system is defined for enforcing this
discipline statically. This analysis differs from ours in that it
allows aliases to exist as long as they are not used whereas we aim at
providing guarantees that certain parts of memory are without
aliases. 
The properties tracked by our type system are close to 
escape analysis~\cite{Blanchet99,ChoiGSSM99} but the analyses differ
in their purpose. While escape
analysis tracks locally allocated objects and tries to detect those
that do not escape after the end of a method execution, we are
specifically interested in tracking 
locally allocated objects that escape from the result of a method, as
well as analyse their dependencies with respect to parameters.





Our static enforcement technique falls within the large area of static
verification of heap properties. A substantial amount of research has been
conducted here, the most prominent being region calculus~\cite{TofteTalpin97},
separation logic~\cite{OHearnYR04} and shape analysis~\cite{SagivRW02}. Of
these three approaches, shape analysis comes closest in its use of shape
graphs.  Shape analysis is a large framework that allows to infer complex
properties on heap allocated data-structures like absence of dangling pointers
in C or non-cyclicity invariants. In this approach, heap cells are abstracted
by shape graphs with flexible object abstractions. Graph nodes can either
represent a single cell, hence allowing strong updates, or several cells
(summary nodes). \emph{Materialization} allows to split a summary node during
cell access in order to obtain a node pointing to a single cell.
The shape graphs that we use are not intended to do full shape analysis but
are rather specialized for tracking sharing in locally allocated objects. We
use a different naming strategy for graph nodes and discard all information
concerning non-locally allocated references. This leads to an analysis which
is more scalable than full shape analysis, yet still powerful enough
for verifying complex copy policies as demonstrated in the concrete case study
\ttt{java.util.LinkedList}.

Noble \emph{et al.}~\cite{Noble:98:Flexible} propose a prescriptive
technique for characterizing the aliasing, and more generally, the
topology of the object heap in object-oriented programs. This
technique is based on alias modes which have evolved into the notion
of ownership types \cite{Clarke:98:Ownership}. In this setting, the
annotation \ttt{@Repr} is used to specify that an object is
\emph{owned} by a specific object. It is called a
\emph{representation} of its owner. After such a declaration, the
programmer must manipulate the representation in order to ensure that
any access path to this object should pass trough its owner. Such a
property ensures that a \ttt{@Repr} field must be a \ttt{@Deep}
field in any copying method. Still, a \ttt{@Deep} field is not
necessarily a \ttt{@Repr} field since a copying method may want to
deeply clone this field without further interest in the global alias
around it.  Cloning seems not to have been studied further in the
ownership community and ownership type checking is generally not
adapted to flow-sensitive verification, as required by the programming
pattern exhibited in existing code. In this example, if we annotate
the field \ttt{next} and \ttt{previous} with \ttt{@Repr}, the
\ttt{clone} local variable will not be able to keep the same
ownership type at line 12 and at line 26. Such a an example would
require ownership type systems to track the update of a reference in
order to catch that any path to a representation has been erased in
the final result of the method.

We have aimed at annotations that together with static
analysis allows to verify existing cloning methods. 
Complementary to our approach, 
Drossopoulou and Noble~\cite{pubsdoc:clonesPre} propose a system
that generate cloning methods from annotation inpired by ownership types.


\section{Conclusions and Perspectives}

Cloning of objects is an important aspect of exchanging data with
untrusted code. Current language technology for cloning does not
provide adequate means for defining and enforcing a secure copy policy
statically; a task which is made more difficult by important
object-oriented features such as inheritance and re-definition of
cloning methods. We have presented a flow-sensitive type system for
statically enforcing copy policies defined by the software developer
through simple program annotations. The annotation formalism deals
with dynamic method dispatch and addresses some of the problems posed
by redefinition of cloning methods in inheritance-based object
oriented programming language (but see
Section~\ref{sec:pol:limitations} for a discussion of current
limitations). The verification technique is designed to enable modular
verification of individual classes. By specifically targeting the
verification of copy methods, we consider a problem for which it is
possible to deploy a localized version of shape analysis that avoids
the complexity of a full shape analysis framework. This means that our
method can form part of an extended, security-enhancing Java byte code
verifier which of course would have to address, in addition to secure cloning, a wealth of other
security policies and security guidelines as \emph{e.g.}, listed on
the CERT web site for secure Java
programming~\cite{CertGuidelines:2010}.

The present paper constitutes the formal foundations for a secure
cloning framework. All theorems except those of
Section~\ref{sec:inference} have been mechanized in the Coq proof
assistant. Mechanization was particularly challenging because
of the storeless nature of our type interpretation but in the end
proved to be  of great help to get the
soundness arguments right. 

 Several issues merit further investigations in order
to develop a full-fledged software security verification tool. 
The extension of the policy language to be able to impose policies on
fields defined in sub-classes should be developed
(\emph{cf.}~discussion in Section~\ref{sec:pol:limitations}). We
believe that the 
analysis defined in this article can be used to enforce such policies
but their precise semantics remains to be defined. 
In the current approach, virtual methods without copy
policy annotations are considered as black boxes that may modify any object reachable
from its arguments. An extension of our copy annotations to virtual
calls should be worked out if we want to enhance our enforcement
technique and accept more secure copying methods. More advanced verifications
will be possible if we
develop a richer form of type signatures for methods where the formal
parameters may occur in copy policies, in order to express a relation
between copy properties of returning objects and parameter fields.
The challenge here is to provide sufficiently expressive signatures
which at the same time remain humanly readable software contracts. 
The current formalisation has been developed for a sequential model of
Java. We conjecture that the extension to interleaving multi-threading
semantics is feasible and that it can be done without making major changes to the type system
because we only manipulate thread-local pointers. 


An other line of work could be to consider the correctness of
\ttt{equals()} methods with respect to copying methods, since we
generally expect \ttt{x.clone().equals(x)} to be \ttt{true}.  The
annotation system is already in good shape for such a work but a
static enforcement may require a major improvement of our specifically
tailored shape analysis.

\section{Acknowledgement}
We wish to thank the ESOP’11 and LMCS anonymous reviewers for their
helpful comments on this article. We specially thank the anonymous reviewer who suggested the 
\ttt{EvilList} example presented in Section~\ref{sec:pol:limitations}.
 
\bibliographystyle{plain}
\bibliography{bibli}


\end{document}
