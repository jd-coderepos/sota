\documentclass[10pt,journal]{IEEEtran}
\usepackage{setspace,amsmath,latexsym,cite,amssymb,epsfig,amsfonts,psfig}
\usepackage{url,cite}
\usepackage{balance}
\usepackage{graphicx}
\usepackage{enumerate}
\usepackage{stmaryrd}
\usepackage{colortbl}
\usepackage{url,cite}
\usepackage{balance}
\usepackage{graphicx}
\usepackage{enumerate}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{slashbox}
\usepackage{booktabs}
\usepackage[table]{xcolor}
\definecolor{lightgray}{gray}{0.9}
\definecolor{lightgrayd}{gray}{1}


\usepackage{makeidx}  \def\bfalpha{{\boldsymbol{\alpha}}}



\renewcommand{\theenumi}{\arabic{enumi}}
\renewcommand{\labelenumi}{\theenumi}
\renewcommand{\thefootnote}{\alph{footnote}}
\renewcommand{\theenumii}{\arabic{enumii}}
\renewcommand{\labelenumii}{\theenumii}

\renewcommand{\theenumii}{\arabic{enumiii}}
\renewcommand{\labelenumii}{\theenumiii}

\newcommand{\define}{\stackrel{\bigtriangleup}{=}}
\newcommand{\bs}{\boldsymbol}
\newtheorem{lemma}{Lemma}
\newtheorem{remark}{Remark}
\def\bmu{{\boldsymbol{\mu}}}
\def\bGamma{{\boldsymbol{\Gamma}}}
\def\bfeta{{\boldsymbol{\eta}}}
\def\bfPsi{{\boldsymbol{\Psi}}}
\def\bftheta{{\boldsymbol{\theta}}}
\def\bflamda{{\boldsymbol{\lambda}}}
\def\bfsigma{{\boldsymbol{\sigma}}}
\def\bfphi{{\boldsymbol{\phi}}}
\def\bfOmega{{\boldsymbol{\Omega}}}
\def\bfPhi{{\boldsymbol{\Phi}}}
\newcommand{\argmax}{\operatornamewithlimits{\textit{argmax}}}
\usepackage{amsthm}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{definition}[theorem]{Definition}
\newtheorem*{note}{Note}
        \makeatletter
        \def\fps@eqnfloat{!t}
        \def\ftype@eqnfloat{4}
        \newenvironment{eqnfloat}
               {\@float{eqnfloat}}
               {\end@float}
        \newenvironment{eqnfloat*}
               {\@dblfloat{eqnfloat}}
               {\end@dblfloat}
        \makeatother
















\ifCLASSOPTIONcompsoc
\else
\fi






\ifCLASSINFOpdf
\else
\fi




\hyphenation{op-tical net-works semi-conduc-tor}

\begin{document}
\title{User Collusion Avoidance Scheme for Privacy-Preserving Decentralized Key-Policy Attribute-Based Encryption -- Full Version }
\author{ Yogachandran Rahulamathavan,~\textit{Member, IEEE}\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem Y. Rahulamathavan is with the School of Engineering and Mathematical Science, City University London, London, U.K. (e-mail: Yogachandran.Rahulamathavan.1@city.ac.uk).\protect
\IEEEcompsocthanksitem Shorter version of this paper got accepted in IEEE TC \cite{Rahul9}. \protect
}
}
\IEEEcompsoctitleabstractindextext{
\begin{abstract}
Recent trend towards cloud computing paradigm,  smart devices and 4G wireless technologies has enabled seamless data sharing among users. Cloud computing environment is distributed and untrusted, hence data owners have to encrypt their data to enforce data confidentiality. The data confidentiality in a distributed environment can be achieved by using attribute-based encryption  technique. Decentralized attribute-based encryption technique is a variant of multiple authority based attribute-based encryption whereby any attribute authority  can independently join and leave the system without collaborating with the existing attribute authorities.  In this paper, we propose a privacy-preserving decentralized key-policy attribute-based encryption scheme. The scheme preserves the user privacy when users interact with multiple authorities to obtain decryption keys while mitigating the well-known user collusion security vulnerability. We showed that our scheme relies on decisional bilinear Diffie-Hellman standard complexity assumption in contrast to the previous nonstandard complexity assumptions such as decisional Diffie-Hellman inversion.
\end{abstract}
\begin{keywords}
Cloud computing, attribute-based encryption, multi-authority, user collusion, anonymous key issuing protocol.
\end{keywords}
}
\maketitle


\IEEEdisplaynotcompsoctitleabstractindextext
\IEEEpeerreviewmaketitle



\section{Introduction}

Recent trend towards cloud computing, outsourcing, smart devices, and high bandwidth mobile broadband has enabled users to share information anywhere and anytime. Data could be shared using public data storages such as cloud computing infrastructure which can provide flexible computing capabilities at reduced costs. Although this brings many benefits, there are many unavoidable security problems since those facilities are maintained by third party service providers \cite{SRuj}.

Traditionally,  data owners, users, and  storage server are in the same  domain and  the storage server is fully trusted \cite{RBAC, CWDRBAC, ERBAC, TRBAC, SRBAC, ESRBAC, LRBAC, LAAC, ESTAC}. However, in cloud computing and outsourcing  environments, data confidentiality is not guaranteed since the data is stored and processed within the third party environment \cite{Rahul5,Rahul6,Rahul7,Rahul8}. Personnel information of the data owners and  commercial secrets of service providers can be leaked to third party if the data owners  store decrypted data in public servers. To overcome this challenge, the data confidentiality in a distributed environment can be achieved by applying attribute-based encryption (ABE) technique \cite{FIBE, kpabe,cpabe}. ABE  is considered as a promising cryptographic technique for organizations who host their services in the cloud \cite{FIBE, kpabe,cpabe,Rahul1}. In fact, using ABE, the data owners can enforce fine-grained access policies based on the nature of data. In ABE, at least four different parties are involved namely data owner, users, attribute authority and storage server (i.e., cloud). 

The attribute authority is responsible for a set of attributes and will be issuing encryption and decryption credentials to the data owner and users, respectively. In order to get the decryption credentials for a set of attributes, the user needs to prove to the attribute authority that he is a legitimate user for those attributes. Data owner will choose a set of attributes for a particular data and will use the corresponding encryption credential for those attributes to encrypt the data. Then the encrypted data will be uploaded onto the cloud by the data owner. If the user wants to access the encrypted data, then he will first download the encrypted data from the cloud and will compare whether he satisfies the set of attributes defined by the data owner during the encryption. For instance, let us assume, an employer uploads an  encrypted file to the cloud using ABE, where the access policy of that file is defined using the following attributes and functions AND and OR: ``Manager" OR ``Finance Office" AND ``Company A". Hence, an employee who is a ``Manager"  employed at ``Company A" can  decrypt the file.

\begin{table*}[!ht]\caption{Comparisons of attribute based encryption schemes related to the proposed scheme.}
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
Ref.                        & Year & KP/CP-ABE & \begin{tabular}[c]{@{}c@{}}Access\\ Structure\end{tabular} & Security Model     & \begin{tabular}[c]{@{}c@{}}Decentralized\\ Attribute Authorities\end{tabular} & \begin{tabular}[c]{@{}c@{}}User\\ Privacy\end{tabular} \\ \hline
Sahai et al. {[}17{]}       & 2005 & KP-ABE    & Threshold                                                  & Selective Security & No                                                                            & No                                                     \\ \hline
Goyal et al. {[}18{]}       & 2006 & KP-ABE    & Tree                                                       & Selective Security & No                                                                            & No                                                     \\ \hline
Chase {[}20{]}              & 2007 & KP-ABE    & Threshold                                                  & Selective Security & No                                                                            & No                                                     \\ \hline
Bethencourt et. al {[}19{]} & 2007 & CP-ABE    & Tree                                                       & Selective Security & No                                                                            & No                                                     \\ \hline
Chase et al. {[}21{]}       & 2009 & KP-ABE    & Threshold                                                  & Selective Security & No                                                                            & Yes                                                    \\ \hline
Lewko et al. {[}23{]}       & 2011 & CP-ABE    & LSSS                                                       & Selective Security & Yes                                                                           & No                                                     \\ \hline
Liu et al. {[}28{]}         & 2011 & CP-ABE    & LSSS                                                       & Full Security      & Yes                                                                           & No                                                     \\ \hline
Han et al. {[}15{]}         & 2012 & KP-ABE    & Tree                                                       & Selective Security & Yes                                                                           & Yes                                                    \\ \hline
Our Scheme                  & 2015 & KP-ABE    & Tree                                                       & Selective Security & Yes                                                                           & Yes                                                    \\ \hline
\end{tabular}
\end{table*}

There are two main types of ABE namely ciphertext-policy ABE (CP-ABE) and key-policy ABE (KP-ABE) \cite{kpabe,cpabe}. In CP-ABE scheme, the access structure is assigned to the ciphertext and each private key is associated with a set of attributes. It must be noted that in CP-ABE, the data owner must enforce the access structure together with encryption. The user must have the private key to satisfy the policy in order to decrypt the ciphertext \cite{cpabe}. In the KP-ABE scheme, the private keys are associated with an access structure and the ciphertext is labeled with a set of attributes. When the access structure defined in the private key matches the attributes labeled with the ciphertext, then it decrypts the ciphertext \cite{kpabe}. Both the schemes have different applications in secure data sharing. However, we consider only KP-ABE scheme in this paper.


Each ABE scheme can be further divided into  two types: single authority based ABE \cite{kpabe} and multiple authorities based ABE (MA-ABE)  \cite{imaabe} schemes. In a single authority based ABE scheme, only one attribute authority is responsible for monitoring all the attributes. In the MA-ABE scheme, in contrast to the single authority ABE scheme, there are multiple attribute authorities responsible for a disjoint sets of attributes. The management of attributes is a crucial part in the ABE systems.  In reality, it is more convenient and secure to monitor and maintain different sets of attributes  by different attribute authorities, e.g., in healthcare one authority can monitor attributes of nurse and doctors while another authority monitors attributes of  administrators and human resources \cite{Rahul2} or in vehicular adhoc network (VANET), different identities can be monitored by different authorities \cite{Rahul3, Rahul4}. The focus of this paper is on multi-authority KP-ABE scheme. Let us review some of the relevant works in multi-authority ABE schemes followed by the decentralized schemes.

\textbf{Related Works:} Chase et. al. \cite{maabe} presented a MA-ABE scheme, which allows any polynomial number of independent authorities to monitor attributes and distribute decryption keys. In \cite{maabe}, the data owner chooses a number, i.e.,  for {th} attribute authority, and a set of attributes from each attribute authority, and encrypts a message. This encrypted message can be decrypted  only by the users who satisfy   number of attributes from the  attribute authority, . However,  a trusted central authority  is needed for distributing all the keys  \cite{maabe}.



An improved MA-ABE scheme without central authority has been presented by Chase and Chow in \cite{imaabe} where, each pair of attribute authorities securely exchange a shared secret among them during the set up process. In \cite{maabe}, users must submit their global identity (GIDs) to each authority to obtain the decryption credentials. This will breach the user privacy since a set of corrupted authorities can pool together all the attributes belong to the particular GID. In order to mitigate this privacy vulnerability, Chase and Chow proposed an anonymous key issuing protocol in \cite{imaabe}, whereby a user can obtain the decryption keys from attribute authorities without revealing her GIDs. Even though the scheme proposed by Chase and Chow eliminates the central authority, all the attribute authorities must be online and collaborate with each other to set up the ABE system. Hence, if one attribute authority joins and/or leaves the system then the entire system must be rebooted. Let us review the decentralized MA-ABE schemes in literature.



In literature, various protocols  have been proposed to decentralize  the ABE scheme, however, each scheme has its own merits and demerits. In a decentralized ABE scheme, any attribute authority  can independently join and/or leave the system or  issue keys to users without collaborating with existing attribute authorities. Hence, this kind of scheme eliminates the need that all the attribute authorities must be online and interact with each other in order to setup the system.

Decentralized schemes for CP-ABE was proposed in \cite{Dabe,Muller1, Muller2, ZLiu, OT13}.  In particular, \cite{Dabe} constructs the first decentralized multi-authority ABE scheme whereby any party can become an authority and there is no requirement for any global coordination
other than the creation of an initial set of common reference parameters. However, the schemes in \cite{Dabe,BWaters,Muller1, Muller2, ZLiu, OT13} do not preserve the user privacy i.e., attributes of users can be collected by tracing users' GIDs. For the first time, Han et al. proposed a privacy-preserving decentralized scheme for KP-ABE \cite{main1}. In contrast to the existing decentralized ABE schemes,  the scheme in \cite{main1} preserves the user privacy and relies only on decisional bilinear Diffie-Hellman (DBDH) standard complexity assumption.
In \cite{main1}, the GID of the user is used to tie all the decryption keys together, where blind key generation protocol has been used to issue the decryption keys. Hence, corrupted attribute authorities cannot pool the users' attributes by tracing the GIDs' of the users from the decryption keys. Unfortunately, the scheme in \cite{main1} cannot prevent  user collusion, hence, two users can pool their decryption keys  to generate decryption keys for an unauthorized user \cite{main2}. This is due to weak bind between users' GID and the decryption keys.

In this paper, contrasting to all the works in literature, we propose a strong privacy-preserving decentralized KP-ABE scheme in order to mitigate the known user collusion security vulnerability \cite{main2}. We exploit  the anonymous key issuing protocol in \cite{imaabe} to strengthen the bind between decryption keys and GID as well as to preserve the user privacy. In order to incorporate the anonymous key issuing protocol, we  modify the privacy-preserving decentralized KP-ABE scheme in \cite{main1}. We prove this by contradiction that the proposed scheme is secure i.e., we reduce the DBDH standard complexity assumption to show that an adversary who can break the proposed scheme  can be exploited to break the DBDH assumption. We also proved that the anonymous key issuing protocol is free from leak and selective-failure.

The reminder  of this paper is organized as follows: we provide notations and cryptographic building blocks required for the new algorithm in Section II. We propose the decentralized KP-ABE algorithm and it's security proof in Section III. In Section IV, we describe anonymous key issuing protocol and it's security proof. Complexities of similar algorithms are compared in Section V followed by Conclusions  in Section VI.

\section{Preliminaries}
The following notations will be used throughout this paper. We use  to denote that  is randomly selected from . Suppose  is a finite field with prime order , by , we denote the polynomial ring on . Let us explain the building blocks used in this paper in the following subsections.

\subsection{Lagrange Interpolation}
Shamir's secret share uses Lagrange interpolation technique to obtain the secret from shared-secrets. Suppose that  is a  degree polynomial and secret . Let us denote  and the Lagrange coefficient for  in  as

For a given  different number of values , , , , the polynomial  can be reconstructed as follows,

hence the secret  can be obtained as:



\subsection{Bilinear Groups}
Let ,  be two multiplicative groups of prime order , generated by  ,  respectively.
A bilinear map is denoted as  :    , where it has the following three properties.
\begin{enumerate}
  \item Bilinearity: , and , there is .
  \item Non-degeneracy:   where  is the identity of .
  \item Computability:  is an efficient computation.
\end{enumerate}


\subsection{Decisional Bilinear Diffie-Hellman Complexity Assumption}
The DBDH  is one of the standard cryptographic complexity assumption in contrast to other nonstandard complexity assumptions such as decisional Diffie-Hellman Inversion. Let ,  as bilinear parameters, and  as a generator of . The DBDH assumption says that in , there is no probabilistic polynomial-time adversary can distinguish []  from [] with non-negligible advantage. We will use this property to prove by contradiction  that our proposed algorithm is secure against well-known attacks. Later in this paper, we will show that if there is an adversary who can break the proposed algorithm then we can use the adversary indirectly to break the DBDH assumption (i.e., this is a contradiction to the DBDH assumption, hence our proposed algorithm is secure).

\subsection{Commitment}
A commitment scheme consists of three sub-algorithms: \textit{Setup}, \textit{Commit}, and \textit{Decommit}. The \textit{Setup} outputs parameters (i.e., \textit{params}) for a particular security input. The \textit{Commit} outputs commitment (e.g., \textit{com}) and decommitment (e.g., \textit{decom}) parameters for a particular message  and \textit{params}. The \textit{Decommit} algorithm outputs  if the \textit{com} matches the \textit{decom} for the message and \textit{params}, otherwise it outputs .

\subsection{Proof of Knowledge}
We use the notation introduced in \cite{PoK} to prove statements about discrete logarithm. By

we denote a zero knowledge proof of knowledge of integers  and . Conventionally, the values in the parenthesis
denote the knowledge that is being proven, while the rest of the other values are known to the verifier. There exists a knowledge extractor which can be used to rewind these quantities from a successful prover.


\subsection{Access Structure}
Let  be a set of attributes. A collection  is monotone if  if  and  then . An access structure (respectively, monotone access structure) is a collection (respectively, monotone collection)  of non-empty subsets of , i.e., . The sets in  are called the authorized sets, and the sets not in  are called the unauthorized sets \cite{Beimel}. In our context, we restrict our attention to monotone access structures. However, it is also possible to (inefficiently) realize general access structures using the techniques given in \cite{kpabe}.

We follow the same strategy used in \cite{kpabe} to build monotone access structure using access tree. Let  be a tree representing an access structure. Each non-leaf node of the tree represents a threshold gate, described by its children and a threshold value. If 
is the number of children of a node  and  is its threshold value, then . When , the threshold gate is an OR gate and when , it is an AND gate.

Each leaf node  of the tree is described by an attribute and a threshold value .
To facilitate working with the access trees, we define a few functions. We denote the
parent of the node  in the tree by . The function  is defined only if  is a
leaf node and denotes the attribute associated with the leaf node  in the tree. The access
tree  also defines an ordering between the children of every node, that is, the children
of a node are numbered from  to . The function  returns such a number
associated with the node . Where the index values are uniquely assigned to nodes in the
access structure for a given key in an arbitrary manner.

Let  be an access tree with root . Denote by  the subtree
of  rooted at the node . Hence  is the same as . If a set of attributes  satisfies the
access tree , we denote it as . We compute  recursively as follows. If  is a
non-leaf node, evaluate  for all children 
of node .  returns 1 if and only if at
least  children return 1. If  is a leaf node, then  returns  if and only if .





\section{Decentralized Key-Policy Attribute-based Encryption}
In this section, we present our decentralized KP-ABE scheme.   In a decentralized scheme, it is not necessary to maintain a fixed number of attribute authorities. Any attribute authority can join and/or leave the system at any time without rebooting the system. First of all, we will explain  sub-algorithms and security game followed by the privacy-preserving decentralized KP-ABE. In Section IV, we incorporate the anonymous key issuing protocol to strengthen the bind between user GID and decryption keys, hence, our scheme mitigates the user collusion vulnerability found in  \cite{main1}.
\begin{figure*}\small
\setlength{\unitlength}{0.2in} \centering \framebox{
\parbox[t][12cm]{17cm}{
\textbf{Global Setup} 
\begin{itemize}
  \item For a given security parameter ,  generates the bilinear groups  and  with prime order  as follows:
      
  \item Let  be a bilinear map and ,  and  be the generators of  such that  and , 
  \item There are  number of authorities :  monitors  attributes i.e. 
\end{itemize}

\textbf{Authorities Setup} 
\begin{itemize}
  \item  Security parameters of :
   
  \item Public parameters of :  = \{, , and ,  
  \item  specify  as  minimum number of attributes required to satisfy the access structure ( )
\end{itemize}

\textbf{Key Generation} 
\begin{itemize}
    \item Collision-Resistant Hash Function  to generate   from the user global identity
    \item Attribute set of user is : 
    \item  generates  and  polynomial  for each node  (including the leaves) 
    \item For each node , the degree  of the polynomial  is   where  --  threshold value of that node
    \item Now, for the root node , set 
    \item For any other node , set 
    \item Now decryption keys for the user  is generated as follows:\\
    \ \\
    
\end{itemize}


\textbf{Encryption} 
\begin{itemize}
\item Attribute set for the message  is : , i.e. 
\item Data owner of message  randomly chooses , and output the ciphertext as follows:

 where  denotes the index set of the authorities.
\end{itemize}


\textbf{Decryption} 
\begin{itemize}
  \item In order to decrypt , the user , computes  and  as follows:
\item[--]   
\item User then decrypts the message  as follows: 
\end{itemize}
}}
\caption{The proposed decentralized key-policy attribute-based encryption scheme.}
\label{main algorithm}
\end{figure*}  
\subsection{Sub-algorithms}
Our algorithm contains five sub-algorithms namely global setup, authority setup, key issuing, encryption and decryption. Let us briefly explain the functionalities of each sub-algorithm.

\noindent\textbf{Global Setup:} This algorithm takes a security parameter as input and output system parameters. These system parameters can be used by authorities who join the system.

\noindent\textbf{Authority Setup:} Each attribute authority uses the system parameters obtained from the global setup to generate public and private keys for the attributes it maintains.

\noindent\textbf{Key Issuing:}  User and  attribute authority interact via anonymous key issuing protocol (see Section IV) in order to determine a set of attributes belongs to the user. Then attribute authority  generates decryption credentials for  those attributes and send them to the user.

\noindent\textbf{Encryption:} The encryption algorithm takes a set of attributes maintained by attribute authority and the data as input. Then it outputs the ciphertext of the data.

\noindent\textbf{Decryption:} The decryption algorithm takes  the decryption credentials received from attribute authorities and the ciphertext as input. The decryption will be successful if and only if the user attributes satisfy the access structure.



\subsection{Security Game}
In order to avoid the security vulnerabilities, ABE schemes should be proven to be secure against the selective identity (ID) model \cite{FIBE}. In the selective ID model, the adversary should provide the identities of the attribute authorities (challenge identities) he wishes to challenge the challenger with. Then challenger (i.e., the system) will generate necessary parameters corresponding to the challenge identities  and send them to the adversary. Then the adversary is allowed to make secret queries about the challenge identities. If the adversary cannot decrypt the encrypted message at the end with non-negligible advantage then the proposed scheme is secure against the selective ID model. Formally, this is represented by the following game between the adversary and the challenger:\\

\noindent\textbf{Setup}
\begin{itemize}
  \item Adversary sends a list of attribute sets and attribute authorities including corrupted authorities to the challenger.
  \item Now the challenger generates public and private keys corresponding to the attributes and authorities provided by the adversary.
  \item Challenger provides public and private keys corresponding to the corrupted authorities to the adversary while only public keys corresponding to the remaining authorities to the adversary.
\end{itemize}
\noindent\textbf{Secret Key Queries}
\begin{itemize}
  \item The adversary is allowed to make any number of secret key queries as he wants against the attribute authorities.
  \item However, the only requirement is that for each user, there must be at least one non corrupted attribute  authority from which the adversary can get insufficient number of secret keys.
\end{itemize}
\noindent\textbf{Challenge}
\begin{itemize}
  \item The adversary sends two messages  and  to the challenger in plain domain.
  \item Now the challenger randomly chooses one of the messages and encrypt it and send the ciphertext to the adversary.
\end{itemize}
\noindent\textbf{More Secret Key Queries}
\begin{itemize}
  \item The adversary is allowed to make more secret key queries as long as he satisfies the requirement  given earlier.
\end{itemize}
\noindent\textbf{Guess}
\begin{itemize}
  \item Now the adversary guesses which message was encrypted by the challenger.
  \item The adversary is said to be successful if he guesses the correct message with probability  whereby  is a non-negligible function.
\end{itemize}













\subsection{Construction of our new algorithm}
Let us consider a system which contains  number of attribute authorities (i.e., we denote them as ). The attribute set managed by the authority  is denoted as   . Each attribute authority also assigned a value  i.e., user must have at least  number of attributes of this authority in order to retrieve the secret key associated with this attribute authority. The complete algorithm is given in Fig.~\ref{main algorithm}. Let us explain the important steps involved in Fig.~\ref{main algorithm}.

Initially, for a given security parameter , global setup algorithm () generates the bilinear groups  and  with prime order  i.e., . The authority setup algorithm () is executed by each attribute authority to randomly generate public keys () and the corresponding secret keys ().  The public-secret key pairs for  is given as .

Let us denote the attribute set belongs to user  as  and the common attribute set between user  and authority   as  i.e., . Key generation () algorithm will be used to issue decryption keys to the user  with a set of attributes . The algorithm outputs a key that enables the user to decrypt a message encrypted under a set of attributes  if and only if .  The algorithm proceeds as follows. First choose a polynomial  for each node  (including the leaves)
in the tree . These polynomials are chosen in the following way in a top-down manner,
starting from the root node . For each node  in the tree, set the degree  of the polynomial  to be one less than
the threshold value  of that node, that is, . Now, for the root node , set
 and  other points of the polynomial  randomly to define it completely. For
any other node , set  and choose  other points randomly to
completely define . Once the polynomials have been decided, for each leaf node , we give the
secret value  ,  and ,  as shown in Fig.~\ref{main algorithm} to the user.
Note that, users' unique identifier  is tied non-linearly with each decryption key to strengthen the bind, hence the vulnerability found in \cite{main1} can be mitigated with the proposed approach. 



Let us denote the set of attributes used to encrypt  message  as  and the common attribute set between message  and the authority  as  i.e., . Let us also denote the index set of authorities involved in the ciphertext of message  as . The encryption algorithm ()  encrypts the message  using an attribute set . In order to encrypt the message, the message owner randomly generates  and computes ciphertext . If user has decryption keys for the attributes of message  then he can obtain the message  from the ciphertext using the following four steps by executing the decryption algorithm (). First, user can use decryption key  and  to compute  as

then user uses decryption key  and  to compute  as

and uses , ,  and polynomial interpolation to get  as


where . Hence,

Now user can get the message  using  and pre-computed values  as follows:







\subsection{Security Analysis}

\noindent \textbf{Theorem 1.} \emph{The proposed scheme is  semantically secure against chosen plain text attack (CPA) in the selective ID model, if there exist negligible function  such that,  any adversary will succeed the security game explained earlier with probability at most .}\\

\noindent \textbf{Proof.} Suppose if there is a probabilistic polynomial time adversary who can break our algorithm then  there will be a challenger who  can break the DBDH assumption by exploiting the adversary. Lets assume that the challenger is provided with  [] and if  the challenger wants to break the DBDH assumption then he needs to determine whether   or not with at least  probability.

Let us assume that there is an adversary who can break the proposed algorithm. In this section, we will show that the challenger can use such an adversary to break the DBDH assumption. In order to exploit such an adversary, the challenger needs to incorporate the given [] within the proposed algorithm (i.e., Fig.~\ref{main algorithm}). First of all, let us explain how the challenger incorporates [] within the global setup, authority setup, and key generation sub-algorithms. We stress here that this incorporation is indistinguishable from the steps provided in Fig.~\ref{main algorithm}.

Initially, as explained in the security game, the adversary must submit a set of attributes and a set of attribute authorities he wants to challenge. Let us denote the set of attributes provided by the adversary as  where  and a list of corrupted authorities as . One of the conditions as given in security game is that at least there will be one honest authority for each user whereby the adversary can get insufficient number of decryption credentials \cite{maabe}. Let us denote GID of a particular user as  and the corresponding honest authority as , and it's access structure  hence . Hence, we can divide the authorities who maintain attributes  into three: corrupted authorities, authorities who are not corrupted and not , and .
Firstly, challenger generates two random values  and sets  and . For the corrupted authorities :

 \begin{itemize}
   \item The challenger generates  and sets ,  and .
   \item Hence, the public-secret key pairs for  is given as .
   \item Challenger provides the secret-public key pairs of the corrupted authorities to the adversary.
   \item Hence, the adversary can compute  and  himself for user  without interacting with the challenger.
 \end{itemize}
 For the authorities who are not corrupted and not  (i.e., ):

  \begin{itemize}
    \item Challenger generates  and sets , and .
    \item For the attributes , the challenger sets .
    \item Other attributes i.e., , the challenger sets .
    \item Hence, the public-secret key pairs for  is given as\\ .
    \item Challenger sends public keys  to the adversary.
    \item Now authority  assigns a polynomial   with degree  for every node in it's access tree . It first sets up a polynomial  of degree  for the root node . It sets  and then sets rest of the points randomly to completely fix . Now it sets polynomials for each child node   of  as follows: .
    \item Then computes  and  or 
  \end{itemize}
 If :
  \begin{itemize}
    \item Challenger generates .
     \item Challenger sets , .
     \item For the attributes , the challenger sets .
    \item Other attributes i.e., , the challenger sets .
    \item Hence, the public-secret key pairs for  is given as .
    \item Challenger sends public keys  to the adversary.

    \item Since , it should be stressed that maximum  number of  children of node  could be satisfied. It first defines a polynomial  of degree  for the root node  such that .  For each satisfied child   of , the procedure chooses a random point  and sets . We will show later in this section that it is possible to implicitly define remaining children nodes using polynomial interpolation.  Now it recursively defines polynomials for the rest of the nodes in the tree as follows. For each child node  of , .
    \item Computes  and  or
         where .
  \end{itemize}
The following lemma proves  and  are correct and the challenger can generate these without knowing  from .\\



\noindent \textbf{Lemma 1.} \emph{ and  are correct and they can be generated by challenger without knowing  from .}

\noindent \textbf{Proof.}
In the beginning of the access structure we chosen , , ,  random values for children nodes of root node and we set . Hence, using the polynomial interpolation technique, we can implicitly assign values to other children nodes of root using the following valid polynomial function:

During the key extraction, for the correctness, the challenger hides  in attribute . Since, , the    is given as

which is valid and identical to that in the original scheme. Now we will prove that the challenger can generate  and  for  without knowing  and .

and

Once adversary received all the credential from the challenger, he will send two messages,  and  to the challenger. Now the challenger randomly chooses one of the messages  and encrypts it and sends the encrypted message back to the adversary. Let us denote the message chosen by the challenger as  where  or  and the encrypted message as . We stress here that  is a valid encryption of the message  if . Hence, the adversary should have his usual non-negligible advantage  of correctly identifying the message . However, when , then  is just random value, hence, the adversary can have no more than  probability of guessing correctly. Hence, if the adversary guesses correctly then challenger guesses that   and if adversary is wrong then challenger guesses that , hence, the challenger has an advantage of  in distinguishing whether . Hence, an adversary who breaks our scheme with advantage  implies an algorithm for breaking DBDH assumption with non-negligible advantage . We can conclude that the proposed scheme is selective ID secure.\\


\begin{figure*}
\setlength{\unitlength}{0.14in} \framebox{
\parbox[t][8.0cm]{17cm}{
\centering \makebox[9cm][l]{\ ~~~~~~\underline{User }}\makebox[8cm][l]{\ ~~~~~\underline{Authority }}\vspace{0.5cm}\\
\makebox[9cm][l]{1. Randomly chooses  }\makebox[10cm][l]{, }\\
\makebox[9cm][l]{   ~~}\makebox[8cm][l]{}\\
\makebox[9cm][l]{}\makebox[8cm][l]{}\\
\makebox[9cm][l]{2. Computes }\makebox[8cm][l]{}\\
\makebox[9cm][l]{3. }\makebox[8cm][l]{}\\
\makebox[9cm][l]{ }\makebox[8cm][l]{}\\
\makebox[9cm][l]{ }\makebox[8cm][l]{Let  denotes the proof:}\\
\makebox[9cm][l]{ }\makebox[8cm][l]{} \\
\makebox[9cm][l]{ }\makebox[8cm][l]{}\\
\makebox[9cm][l]{4. }\makebox[8cm][l]{}\\
\makebox[9cm][l]{ }\makebox[8cm][l]{}\\
\makebox[9cm][l]{ }\makebox[8cm][l]{}\\
}}
\caption{Anonymous key issuing protocol for decentralized KP-ABE}
\label{Anonymous key issuing protocol}
\end{figure*}



\noindent \textbf{Theorem 2.} \emph{Let  be a -selective identity secure IBE system (IND-sID-CPA). Suppose 
admits  distinct identities. Then  is also a -fully secure IBE (IND-ID-CPA).}\\

\noindent \textbf{Proof.} It has been shown by Boneh et. al in [34; see Theorem 7.1.] that, if any selective identity model is secure under DBDH assumption then it is also fully secure (i.e., adaptive identity). Consequently, if the system has sufficiently high selective-identity security (which requires using a bilinear group of sufficiently large size p) then the system is also a fully secure with adequate security [34]. This means that the selective-ID secure system proposed in this paper is fully secure system in its own right, assuming we use a large enough group so that the DBDH problem is sufficiently difficult.

\section{Anonymous Key Issuing Protocol}
As described by Chase et. al., the ABE system comprises of several types of authorities where some authorities require public identities such as name or social security number of the users to issue credentials \cite{imaabe}. In these cases the users will need to identify themselves in any case in order to obtain the decryption keys for a specific set of attributes. However, there are many attributes, which do not belong to this category e.g., ability to drive a car. However, one should be able to prove the ability to do something in an examination and then get the corresponding credential, without presenting any identifying information.

In an anonymous credential system [30,31,32], the users can obtain and prove the possession of credentials while remaining anonymous. In such work it is assumed that each user has a unique secret key. We can assume that this secret key could be the user’s GID. Then the user can interact with each authority under a different pseudonym (generated using GID) in such a manner that it is impossible to link multiple pseudonyms belonging to the same user. There are two efficient secure protocols in literature to prove that a given secret key is valid and to prevent users from loaning out their keys [30,31,32]: public-key infrastructure (PKI)-assured non-transferability and all-or-nothing non-transferability. In PKI-assured non-transferability, sharing a key implies also sharing a particular, valuable secret key from outside the system (e.g., the secret key that gives access to the user's bank account). In all-or-nothing non-transferability, sharing just one pseudonym or credential implies sharing all of the user's other credentials and pseudonyms in the system, i.e., sharing all of the user's secret keys inside the system.

In the proposed work, we exploited anonymous credentials to allow the users to obtain decryption keys from the authorities without revealing their GID’s. The basic idea is to let the GID play the role of the anonymous credential secret key. The user obtains anonymous credentials as explained earlier. When the user wants to obtain decryption keys corresponding to a set of attributes, he proves (via the anonymous credential system) that he is the owner of a credential for these attributes. Then he uses the ABE system to obtain decryption keys.

In particular, in the proposed key issuing protocol, we coupled the properties of anonymous credential system with ABE. Hence, the user can obtain a set of decryption keys for his secret GID without revealing any information about that GID to the authority (preserve the privacy). At the same time, the authority is guaranteed that the agreed upon decryption-keys are the only information that the user learns from the transaction (i.e., provide security by mitigating user collusion).



The anonymous key issuing protocol preserves the user's identities from the authorities. Hence, the authorities do not know the user's GID nor can cause failures for certain GID's. This concept is from blind IBE schemes  \cite{IBE1}. We define this algorithm as  .
In this algorithms, the user runs \textit{Commit} and sends the \textit{com} to authority and keeps the \textit{decom}. Then the user and authority interact with each other to generate decryption keys. The decryption keys for the user will be  generated only if the output of \textit{Decommit} is .


From \cite{IBE1}, the anonymous key extraction protocol should satisfy the following two properties: leak-freeness and selective-failure blindness. Leak-freeness requires that by executing the anonymous key issuing algorithm with honest authorities, the malicious user cannot find out anything which it is supposed to know by executing the algorithm without privacy preservation with the authorities. Selective-failure blindness requires that malicious authorities cannot discover anything about the user�s identifier and his attributes, and cause the algorithm to selectively fail depending on the user�s identifier and his attributes. These two properties can be formalized by using the following games.

\subsection{Security Games}

\textit{Leak-Freeness.} This game is defined by a real experiment and an ideal experiment. In real experiment, the user (adversarial user) and authority interact with each other using the proposed anonymous key issuing protocol. Hence, the user will obtain randomized decryption keys. However the user will be able remove the randomness to get decryption keys. In an ideal experiment, there will be a simulator that will interact (on behalf of user) with trusted authority to obtain decryption keys (without randomization). The proposed algorithm is free from leak only if no efficient distinguisher can distinguish whether the user is executing real or ideal experiments.

\textit{Selective-failure Blindness.} In this game, the authority (adversarial) outputs pair of GIDs (i.e.,  and ). Then the adversary given with commitments  and  where  and black box access to  and . The algorithm  interact with the authority and output decryption keys i.e., . The proposed algorithm is blind to selective-failure if no probabilistic polynomial-time adversary has non-negligible advantage over identifying .

\subsection{Construction of anonymous key issuing protocol}


Fig.~ \ref{Anonymous key issuing protocol} shows the anonymous key issuing protocol where user with private value  and an authority  with private values ,  and   jointly computing decryption keys for user. The decryption keys for user  are  and  . In order to obtain these keys, first user and  interact with each other using two-party protocol (2PC). The 2PC protocol can be done via a general 2PC protocol for a simple arithmetic computation. Alternatively, we can do this more efficiently using the construction in \cite{2PC1}. The 2PC protocol takes  from user and  from  and returns  and  to . Since,  and  were randomly generated by user, the authority  cannot extract the user identity  from  and . After executing the 2PC protocol, the user now computes  and  and send those values to . Now  computes ,  and  (i.e., randomized decryption credentials) using  and  and send them back to the user. Now the user exponentiates the obtained values by  to get the decryption keys. Note that, since   coupled non-linearly within the decryption keys,  user collusion is not possible \cite{imaabe}.


\subsection{Security Analysis}
To obtain the decryption credential blindly from the authority  , the user needs to prove that he holds the identifier  in zero knowledge. As shown in Fig.~ \ref{Anonymous key issuing protocol}, the user randomly generates  and computes  and  as commitments. At the end of the 2PC protocol, the authority obtains , . Then authority verifies  and . If they are correctly verified then the authority continues otherwise it aborts.

Now authority needs to proof that he knows  in zero knowledge to the user. This will be done using the following steps:
\begin{enumerate}
  \item[1.]  randomly generates , computes  and sends , and  to the user
  \item[2.] User generates  and sends it to the authority
  \item[3.] Authority computes  and sends  to the user
  \item[4.] User verifies , otherwise aborts
\end{enumerate}
We ignored the zero-knowledge proofs for   and  for brevity since they are similar to the above proof.\\

\noindent \textbf{Theorem 3.} \emph{The proposed anonymous key issuing protocol is both leak-free and selective-failure blind.}\\

\noindent \textbf{Proof.} \textbf{Leak freeness.}  Suppose there exists an adversary  in the real experiment (where  is interacting with an honest authority  running the anonymous key issuing protocol) and a simulator  in the
ideal experiment (where  can access the trusted authority running the key issuing protocol without privacy preservation) such that no efficient distinguisher  can distinguish the real experiment from the ideal experiment. The simulator  simulates the communication between the distinguisher  and the adversary  by passing the input of  to  and the output of  to .  The simulator  works as follows:
\begin{enumerate}
  \item[1.]  sends the adversary  the public-key  of 
  \item[2.] The adversary  must proof the possession of  in zero-knowledge to . If proof is successful then  obtains  using rewind technique
  \item[3.]  sends  to the trusted party. The trusted party runs KeyGen to generates (, , )  and responds to 
  \item[4.] Now   computes  and sends them to 
\end{enumerate}
If (, , ) are correct keys from the trusted authority in the ideal experiment, then  are the correct keys from  in the real experiment. Hence, (, , ) and  are correctly distributed and no efficient distinguisher can distinguish the real experiment with the ideal experiment.\\

\noindent \textbf{Proof.} \textbf{Selective-failure blindness.} The adversarial authority  submits the public key , and two GIDs  and . Then, a bit  is randomly selected.  can have a black box access to 's and 's parameters i.e.,  and . Then,  executes the anonymous key issuing protocol with  and outputs secret keys for  and  i.e.,  and .
\begin{itemize}
  \item[1.] If  and  then  is given (, )
  \item[2.] If  and  then  is given (, )
  \item[3.] If  and  then  is given (, )
  \item[4.] If  and  then  is given (, )
\end{itemize}
At the end  submits his prediction on .

In the anonymous key issuing protocol,  sends four random parameters  and  to the adversarial authority  and proves . Now it is 's turn to respond. So far, �s view on the two black boxes is computationally undistinguishable. Otherwise, the hiding property of the commitment scheme and the witness undistinguishable property of the zero-knowledge proof will be broken. Suppose that  uses any computing strategy to output secret keys \{\} for the first black box. In the following, we will show that  can predict  of  without interacting with the two black boxes:

\begin{itemize}
  \item[1.]   checks
  \item[] 
  \item[] 
  \item[] If proof fails,  sets 
  \item[2.]  generates different secret keys \{\} for the second black box and a proof of knowledge:
      \item[] 
  \item[] 
  \item[] If proof fails,  sets 
  \item[3.] Finally  outputs his prediction on (, ) with (, ) if  and ; (, ) if  and ; (, ) if  and ; (, ) if  and .
\end{itemize}





\begin{table*}[!ht]\caption{Comparison of Computational Cost and Ciphertext length}
  \centering
\begin{tabular}{|c|c|c|c|c||c|}
  \hline
&\!\!\!\! Authority Set.\!\!\!\!   & Key Generation& Encryption    & Decryption            & Ciphertext \\ \hline
   \multirow{2}{*}{\!\!\!\!\!\!\!\!\!\!Our Scheme\!\!\!\!\!\!\!\!\!\!}    & \multirow{2}{*}{}      & &   &\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!   &  \\
                                &                   &   & &          &  \\ \hline
  {Han et. al. }      & \multirow{2}{*}{}      &  &   &  &  \\
   \cite{main1}                 &                   &   & &          &  \\ \hline
 {Chase  }           & \multirow{2}{*}{}       & \multirow{2}{*}{} &\multirow{2}{*}{}&           &  \\
       \cite{maabe}                         &                   &               &               &      &  \\ \hline
  {\!\!\!\!Chase et. al. \!\!\!\!\!\!}   &  & &  &      &  \\
     \cite{imaabe}                &       & &                 &        &  \\
  \hline
\end{tabular}
\label{Table: Comparision}
\end{table*}

The predication on (, ) is correct, and has the identical distribution with the black box. Because  performs the same check as the honest , it outputs the valid keys as  obtains from anonymous key issuing protocol. Hence, if  can predict the final outputs of
the two black boxes, the advantage of  in distinguishing the two black boxes is the same without the final outputs. Therefore, the advantage
of  should come from the received  and . From the hiding property of the commitment scheme and witness undistinguishable property of the zero-knowledge proof,  cannot distinguish one from the other with nonnegligible advantage. Hence our anonymous key issuing protocol is secure against selective-failure.

\section{Complexity Comparison}
In this section, we compare the computational complexity of our scheme against the following KP-ABE  schemes: Han et. al decentralized KP-ABE scheme \cite{main1}, Chase MA-ABE KP-ABE scheme with central authority \cite{maabe}, and Chase et.al MA-ABE KP-ABE scheme without central authority \cite{imaabe}. Let us assume there are  number of attribute authorities and each authority monitors  number of attributes. In order to compare the complexity at worst case scenario, let us assume that the ciphertext encrypted using all the attributes in the system (i.e., ) and user has decryption credentials for all the attributes.  Let us denote the computational time (in ms) for one multiplication, one exponentiation,  and  one pairing as  , , and , respectively.



 The Table \ref{Table: Comparision} compares the complexities in all four sub-algorithms and length of ciphertext. From the Table \ref{Table: Comparision}, it is obvious that the centralized algorithms in  \cite{maabe,imaabe} have lower computational complexity than the decentralized schemes proposed in this paper and in  \cite{main1}. However, since the algorithms in \cite{maabe,imaabe} need a central authority and/or interaction among authorities, they are vulnerable for single point of failure. Since the number of pairing operations (i.e., ) equal in both the proposed and  \cite{main1}, they share same order of computational complexity. However, the proposed algorithm mitigates the user collusion vulnerability  compared to \cite{main1}. Finally, the size of the ciphertext in all four algorithms are almost equal.





\section{Conclusions}
In this paper, we proposed a privacy-preserving key-policy attribute-based encryption scheme for a distributed data sharing environment. The proposed scheme enables users to download and decrypt the data from online such as cloud without revealing their attributes to the third-parties. The novelty of the work is to mitigate the user collusion attack in the existing scheme. We used anonymous key issuing protocol to strengthen the bind between user identity and decryption keys, hence,  two or more users cannot pool their keys to generate decryption keys for an unauthorized user. We validated the security of the proposed scheme using the decisional bilinear Diffie-Hellman standard complexity assumption.
\balance
\begin{thebibliography}{5}
\bibitem{SRuj}
S. Ruj, M. Stojmenovic, and A. Nayak. Decentralized Access Control with Anonymous Authentication of Data Stored in Clouds. IEEE Trans. Parallel and Distributed Systems, Vol. 25, No. 2 pp. 384--394, 2014.

\bibitem{RBAC}
R. S. Sandhu, E. J. Coyne, H. L. Feinstein, and C. E. Youman. Role-based access control models. Computer, vol. 29, no. 2, pp. 38--47, 1996.




\bibitem{CWDRBAC}
G. Zhang, M. Parashar. Context-aware dynamic access control for pervasive applications. In Proc. Commun. Networks and Distributed Systems Modeling and Simulation Conf., pp. 21-30, 2004.

\bibitem{ERBAC}
P. Bonatti, C. Galdi, D. Torres. ERBAC: event-driven RBAC. In Proc. 18th ACM Symp. Access control models and technologies. ACM, pp. 125-136,  2013.

\bibitem{TRBAC}
E. Bertino, P. A. Bonatti, E. Ferrari. TRBAC: A temporal role-based access control model. ACM Trans. Information and System Security (TISSEC), vol. 4, no. 3, pp. 191-233, 2001.

\bibitem{SRBAC}
F. Hansen, V. Oleshchuk. SRBAC: A spatial role-based access control model for mobile systems. In Proc. 7th Nordic Workshop on Secure IT Systems (NORDSEC’03), pp. 129-141, 2003.

\bibitem{ESRBAC}
M. S. Kirkpatrick, E. Bertino. Enforcing spatial constraints for mobile RBAC systems. In Proc. 15th ACM Symp. Access Control Models and Technologies, pp. 99-108, 2010.

\bibitem{LRBAC}
I. Ray, M. Kumar, L. Yu. LRBAC: A location-aware role-based access control model. Information Systems Security. Springer Berlin Heidelberg,  pp. 147-161, 2006.

\bibitem{LAAC}
Y. S. Cho, L. Bao, M. T. Goodrich. LAAC: A location-aware access control protocol. IEEE 3rd Annual Int'l Conf. Mobile and Ubiquitous Systems: Networking and Services, pp. 1-7, 2006.

\bibitem{ESTAC}
M. Toahchoodee,  et al. Ensuring spatio-temporal access control for real-world applications. In Proc. 14th ACM Symp. Access Control Models and Technologies, pp. 13-22, 2009.

\bibitem{Rahul1}
F. Li, Y. Rahulamathavan, M. Rajarajan, R. C.-W Phan. Low complexity multi-authority attribute based encryption scheme for mobile cloud computing. In Proc. IEEE 7th Int'l Symp. Service Oriented System Engineering (SOSE), San Francisco, USA, pp. 573--577, Mar. 2013.

\bibitem{Rahul2}
C. Burnett, P. Edwards, T. J Norman, L. Chen, Y. Rahulamathavan, M. Jaffray, E. Pignotti. TRUMP: A Trusted mobile platform for self-management of chronic illness in rural areas. In Trust and Trustworthy Computing, pp. 142--150. Springer Berlin Heidelberg, 2013.

\bibitem{Rahul3}
K. Zaidi, Y. Rahulamathavan, and M. Rajarajan. DIVA - Digital identity in VANETs: A multi-authority framework for VANETs. In Proc.  19th IEEE Int'l Conf. Netw. (ICON'13), Singapore, Dec. 2013.

\bibitem{Rahul4}
F. Li, Y. Rahulamathavan, M. Rajarajan, R. C.-W Phan. LSD-ABAC: Lightweight Static and Dynamic Attributes Based Access Control Scheme for Secure Data Access in Mobile Environment. In Proc. IEEE Local Computer Networks (LCN), Edmonton, Canada, Sept. 2014.




\bibitem{main1}
J. Han, W. Susilo, Y. Mu, and J. Yan: Privacy-Preserving Decentralized Key-Policy Attribute-Based Encryption. In IEEE Trans. Parallel and Distributed Systems, vol. 23, no. 11, pp. 2150--2162, Nov. 2012.

\bibitem{main2}
A. Ge, J. Zhang, R. Zhang, C. Ma, and Z. Zhang: Security Analysis of a Privacy-Preserving Decentralized Key-Policy Attribute-Based Encryption Scheme. In IEEE Trans. Parallel and Distributed Systems, vol. 24, no. 11, pp. 2319--2321, 2013.



\bibitem{FIBE}
A. Sahai, and B. Waters, Fuzzy Identity-Based Encryption. Advances in Cryptology EUROCRYPT,  vol.3494, pp. 557, 2005.

\bibitem{kpabe}
V. Goyal, O. Pandey, A. Sahai, and B. Waters. Attribute-based Encryption for Fine-Grained Access Control of Encrypted Data. In Proc. 13th ACM conf. Comp. and Commun. security (CCS '06), New York, USA, pp. 89-98 2006.

\bibitem{cpabe}
J. Bethencourt, A. Sahai, B. Waters. Ciphertext-Policy Attribute-Based Encryption. In IEEE Symposium on Security and Privacy, SP 07, pp. 321--334, May 2007.

\bibitem{maabe}
M. Chase, Multi-authority Attribute Based Encryption, In LNCS, Berlin Heidelberg,  pp. 515--534, vol. 4392, 2007.






\bibitem{imaabe}
M. Chase and Sherman S.M. Chow. Improving privacy and security in multi-authority attribute-based encryption. In Proc. 16th ACM conf. Comp. and Commun. Security (CCS '09), New York, USA, pp. 121-130, 2009.
\bibitem{2PC1}
 M. Belenkiy, J. Camenisch, M. Chase, M. Kohlweiss, A. Lysyanskaya, and H.Shacham. Randomizable Proofs and Delegatable
Anonymous Credentials. In Advances in Cryptology-CRYPTO 2009, pp. 108--125. Springer Berlin Heidelberg, 2009.





\bibitem{Dabe}
A. B. Lewko and B. Waters. Decentralizing attribute-based encryption. In EUROCRYPT, ser. Lecture Notes in Computer Science, K. G. Paterson, Ed., vol. 6632. Springer, 2011, pp. 568-588.
\bibitem{OT13}
T. Okamoto, and K. Takashima: Decentralized attribute-based signatures. In Public-Key Cryptography�PKC 2013. Springer Berlin Heidelberg, pp. 125--142, 2013.
\bibitem{BWaters}
B. Waters. Ciphertext-Policy Attribute-Based Encryption: An Expressive, Efficient, and Provably Secure Realization. In Proc. 14th
Int�l Conf. Practice and Theory in Public Key Cryptography Conf. Public Key Cryptography (PKC �11), D. Catalano, N. Fazio,
R. Gennaro, and A. Nicolosi, eds., pp. 53-70, Mar. 6-9 2011.

\bibitem{Muller1}
S. M\"{u}ller, S. Katzenbeisser, and C. Eckert. Distributed Attribute-Based Encryption. In Proc. 11th Int�l Conf. Information Security and
Cryptology (ICISC �08), P.J. Lee and J.H. Cheon, eds., pp. 20-36, Dec. 2008.

\bibitem{Muller2}
S. M\"{u}ller, S. Katzenbeisser, and C. Eckert. On Multi-Authority Ciphertext-Policy Attribute-Based Encryption. Bull. of the Korean
Math. Soc., vol. 46, no. 4, pp. 803-819, 2009.

\bibitem{ZLiu}
Z. Liu, Z. Cao, Q. Huang, D.S. Wong, and T.H. Yuen. Fully Secure Multi-Authority Ciphertext-Policy Attribute-Based Encryption
without Random Oracles. In Proc. 16th European Symp. Research in Computer Security (ESORICS �11), V. Atluri and C. Diaz, eds., pp. 278-297, Sept. 2011.

\bibitem{ACS1}
Stefan Brands. Rethinking Public Key Infrastructure and Digital Certificates � Building in Privacy. PhD thesis, Eindhoven Inst. of Tech. 1999.

\bibitem{ACS2}
J. Camenisch and A. Lysyanskaya. Efficient Non-transferable Anonymous Multi-show Credential System with Optional Anonymity Revocation. In
EUROCRYPT 2001, vol. 2045 of LNCS, pp. 93--118. Springer Verlag, 2001.

\bibitem{PoK}
J. Camenisch and M. Stadler. Efficient Group Signature Schemes for Large Groups, In Proc. Advances in Cryptology-CRYPTO�97 (B. S. K. Jr., ed.), vol. 1294 of Lecture Notes in Computer Science, (Santa Barbara, California, USA), pp. 410�424, Springer,
August 17--21 1997.

\bibitem{IBE1}
 J. Camenisch, M. Kohlweiss, A. Rial, and C. Sheedy. Blind and anonymous identity-based encryption and authorised private searches on public key encrypted data. In Proc: PKC�09, volume 5443 of LNCS, pp. 196--214. Springer, 2009.

\bibitem{Rahul5}
 Y. Rahulamathavan, and M. Rajarajan, Efficient Privacy-Preserving Facial Expression Classification, IEEE Transactions on Dependable and Secure Computing, to appear

\bibitem{Rahul6}
 F. Li, Y. Rahulamathavan, M. Conti, M. Rajarajan. Robust Access Control Framework for Mobile Cloud Computing Network. In (Elsevier) Computer Communications, Vol. 68, pp. 61-72, Sep. 2015.

\bibitem{Rahul7}
Y. Rahulamathavan, M. Rajarajan, O. F. Rana, M. S. Awan, P. Burnap and S. K. Das. Assessing Data Breach Risk in Cloud Systems, In 7th Int'l Conf. Cloud Computing Technology and Science (IEEE CloudCom 2015), Vancouver, Canada, Nov. 30 - Dec. 3, 2015

\bibitem{Rahul8}
Y. Rahulamathavan, V. Moonsamy, L. Batten, S. Shunliang and M. Rajarajan. An Analysis of Tracking Service Settings in Blackberry 10 and Windows Phone 8 Smartphones, in 19th Australasian Conference on Information Security and Privacy (ACISP), 2014.

 \bibitem{Beimel}
 A. Beimel. Secure Schemes for Secret Sharing and Key Distribution. PhD thesis, Israel
Institute of Technology, Technion, Haifa, Israel, 1996.

 \bibitem{BonehSID}
Boneh, D., and Boyen, X. Efficient selective identity-based encryption without random oracles. Journal of Cryptology, vol. 24, no. 4, pp. 659--693, 2011.

\bibitem{Rahul9}
Y. Rahulamathavan, S. Veluru, J. Han, R. Lu, F. Li, and M. Rajarajan. User Collusion Avoidance Scheme for Privacy-Preserving Decentralized Key-Policy Attribute-Based Encryption
IEEE Transactions on Computers, 2016 to appear.











\end{thebibliography}

\end{document}
