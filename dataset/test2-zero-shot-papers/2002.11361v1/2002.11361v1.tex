
\def\usearxivstyle{1}

\documentclass[11pt]{article}
\usepackage{fullpage}
\makeatletter
\long\def\@makecaption#1#2{
  \vskip 0.8ex
  \setbox\@tempboxa\hbox{\small {\bf #1:} #2}
  \parindent 1.5em  \dimen0=\hsize
  \advance\dimen0 by -3em
  \ifdim \wd\@tempboxa >\dimen0
  \hbox to \hsize{
    \parindent 0em
    \hfil 
    \parbox{\dimen0}{\def\baselinestretch{0.96}\small
      {\bf #1.} #2
} 
    \hfil}
  \else \hbox to \hsize{\hfil \box\@tempboxa \hfil}
  \fi
}
\makeatother

\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{caption}
\usepackage{microtype}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{booktabs} \usepackage[numbers]{natbib}
\usepackage{fancyhdr}
\usepackage{color}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{forloop}

\setlength{\parindent}{0em}
\setlength{\parskip}{1em}

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argsup}{arg\,sup}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}

\newcommand{\tengyu}[1]{}
\newcommand{\tnote}[1]{}
\newcommand{\pl}[1]{}
\newcommand{\ak}[1]{}




\usepackage{hyperref}




\begin{document}

\abovedisplayskip=8pt plus0pt minus3pt
\belowdisplayskip=8pt plus0pt minus3pt

\begin{center}
  {\LARGE Understanding Self-Training for Gradual Domain Adaptation} \\
  \vspace{.5cm}
  {\Large Ananya Kumar ~~~~ Tengyu Ma ~~~~ Percy Liang} \\
  \vspace{.2cm}
  {\large Stanford University} \\
Department of Computer Science \\
  \vspace{.2cm}
  \texttt{\{ananya,tengyuma,pliang\}@cs.stanford.edu}
\end{center}

\begin{abstract}
\noindent Machine learning systems must adapt to data distributions that evolve over time, in applications ranging from sensor networks and self-driving car perception modules to brain-machine interfaces. We consider gradual domain adaptation, where the goal is to adapt an initial classifier trained on a source domain given only unlabeled data that shifts gradually in distribution towards a target domain. We prove the first non-vacuous upper bound on the error of self-training with gradual shifts, under settings where directly adapting to the target domain can result in unbounded error. The theoretical analysis leads to algorithmic insights, highlighting that regularization and label sharpening are essential even when we have infinite data, and suggesting that self-training works particularly well for shifts with small Wasserstein-infinity distance. Leveraging the gradual shift structure leads to higher accuracies on a rotating MNIST dataset and a realistic Portraits dataset.
\end{abstract} 
\section{Introduction}
\label{introduction}

Machine learning models are typically trained and tested on the same data distribution.
However, when a model is deployed in the real world, the data distribution typically evolves over time, leading to a drop in performance.
This problem is widespread: sensor measurements drift over time due to sensor aging~\cite{vergara2012Chemical}, self-driving car vision modules have to deal with evolving road conditions~\cite{bobu2018adapting}, and neural signals received by brain-machine interfaces change within the span of a day~\cite{farshchian2019adversarial}.
Repeatedly gathering large sets of labeled examples to retrain the model can be impractical, so we would like to leverage unlabeled examples to adapt the model to maintain high accuracy~\cite{farshchian2019adversarial, sethi2017reliable}.

In these examples the domain shift doesn't happen at one time, but happens gradually, although this gradual structure is ignored by most domain adaptation methods.
Intuitively, it is easier to handle smaller shifts, but for each shift we can incur some error so the more steps, the more degradation---making it unclear whether leveraging the gradual shift structure is better than directly adapting to the target.

In this paper, \emph{we provide the first theoretical analysis showing that gradual domain adaptation provides improvements over the traditional approach of direct domain adaptation}. We analyze self-training (also known as pseudolabeling), a method in the semi-supervised learning literature~\cite{chapelle2006semisupervised} that has led to state-of-the-art results on ImageNet~\cite{xie2020selftraining} and adversarial robustness on CIFAR-10~\cite{uesato2019are, carmon2019unlabeled, najafi2019robustness}. 

\begin{figure}[t]
\begin{center}
\ifdefined\usearxivstyle
\centerline{\includegraphics[width=0.6\columnwidth]{images/portraits_example.png}}
\else
\centerline{\includegraphics[width=\columnwidth]{images/portraits_example.png}}
\fi
\caption{In gradual domain adaptation we are given labeled data from a source domain, and unlabeled data from intermediate domains that shift gradually in distribution towards a target domain. Here, blue = female, red = male, and gray = unlabeled data.}
\label{fig:portraits_example}
\end{center}
\vskip -0.3in
\end{figure}

As a concrete example of our setting, the Portraits dataset~\cite{ginosar2017portraits} contains photos of high school seniors taken across many years, labeled by gender (Figure~\ref{fig:portraits_example}).
We use the first 2000 images (1905 - 1935) as the source, next 14000 (1935 - 1969) as intermediate domains, and next 2000 images as the target (1969 - 1973). A model trained on labeled examples from the source gets 98\% accuracy on held out examples in the same years, but only 75\% accuracy on the target domain. Assuming access to \emph{unlabeled} images from intermediate domains, our goal is to adapt the model to do well on the target domain. Direct adaptation to the target with self-training only improves the accuracy a little, from 75\% to 77\%.

\pl{make it clearer that we're proposing this or it has been studied (in which case we need a cite)}
The gradual self-training algorithm begins with a classifier  trained on labeled examples from the source domain (Figure~\ref{fig:intro_timestep0}). For each successive domain , the algorithm generates pseudolabels for unlabeled examples from that domain, and then trains a regularized supervised classifier on the pseudolabeled examples. The intuition, visualized in Figure~\ref{fig:grad_st_intuition}, is that after a single gradual shift, most examples are pseudolabeled correctly so self-training learns a good classifier on the shifted data, but the shift from the source to the target can be too large for self-training to correct. \emph{We find that gradual self-training on the Portraits dataset improves upon direct target adaptation (77\% to 84\% accuracy)}.

\begin{figure}

     \begin{center}
     \hfill
     \ifdefined\usearxivstyle
     \begin{subfigure}[b]{0.14\columnwidth}
     \else
     \begin{subfigure}[b]{0.24\columnwidth}
     \fi
         \centering
         \includegraphics[width=\textwidth]{images/intro_timestep_1_of_4.png}
         \caption{t = 0}
         \label{fig:intro_timestep0}
     \end{subfigure}
     \hfill
     \ifdefined\usearxivstyle
     \begin{subfigure}[b]{0.14\columnwidth}
     \else
     \begin{subfigure}[b]{0.24\columnwidth}
     \fi
         \centering
         \includegraphics[width=\textwidth]{images/intro_timestep_2_of_4.png}
         \caption{t = 1}
         \label{fig:intro_timestep1}
     \end{subfigure}
     \hfill
     \ifdefined\usearxivstyle
     \begin{subfigure}[b]{0.14\columnwidth}
     \else
     \begin{subfigure}[b]{0.24\columnwidth}
     \fi
         \centering
         \includegraphics[width=\textwidth]{images/intro_timestep_3_of_4.png}
         \caption{t = 2}
         \label{fig:intro_timestep2}
     \end{subfigure}
     \hfill
     \ifdefined\usearxivstyle
     \begin{subfigure}[b]{0.14\columnwidth}
     \else
     \begin{subfigure}[b]{0.24\columnwidth}
     \fi
         \centering
         \includegraphics[width=\textwidth]{images/intro_timestep_4_of_4.png}
         \caption{t = 3}
         \label{fig:intro_timestep3}
     \end{subfigure}
     \hfill
     \hfill
     \caption{
The source classifier  gets 100\% accuracy on the source domain (Figure~\ref{fig:intro_timestep0}), where we have labeled data.
     But after 3 time steps (Figure~\ref{fig:intro_timestep3}) the source classifier is stale, classifying most examples incorrectly.
     Now, we cannot correct the classifier using unlabeled data from the target domain, which corresponds to traditional domain adaptation directly to the target.
     Given \emph{unlabeled} data in an intermediate domain (Figure~\ref{fig:intro_timestep1}) where the shift is gradual, the source classifier pseudolabels most points correctly, and self-training learns an accurate classifier (show in green) that separates the classes.
     Successively applying self-training learns a good classifier on the target domain (green classifier in Figure~\ref{fig:intro_timestep3}).
     }
	\label{fig:grad_st_intuition}
	\end{center}
	\vskip -0.2in
\end{figure}

\textbf{Our results}: We analyze gradual domain adaptation in two settings.
The key challenge for domain adaptation theory is dealing with source and target domains whose support do not overlap~\cite{zhao2019zhao, shu2018dirtt}, which are typical in the modern high-dimensional regime.
The gradual shift structure inherent in many applications provides us with leverage to handle adapting to target distributions with non-overlapping support.

Our first setting, the margin setting, is distribution-free---we only assume that at every point in time there exists some linear classifier that can classify most of the data correctly with a margin, where the linear classifier may be different at each time step (so this is more general than covariate shift), and that the shifts are small in Wasserstein-infinity distance.
A simple example (as in Figure~\ref{fig:grad_st_intuition}) shows that a classifier that gets 100\% accuracy can get 0\% accuracy after a constant number of time steps.
Directly adapting to the final target domain also gets 0\% accuracy.
Gradual self-training does better, letting us bound the error after  steps: , where  is the error of the classifier on the source domain, and  is the number of unlabeled examples in each intermediate domain.
While this bound is exponential in , this bound is non-vacuous for small , and we show that this bound is tight for gradual self-training.

In the second setting, stronger distributional assumptions allow us to do better---we assume that  is a -dimensional isotropic Gaussian for each . Here, we show that if we begin with a classifier  that is nearly Bayes optimal for the initial distribution, we can recover a classifier  that is Bayes optimal for the target distribution with infinite unlabeled data.
This is an idealized setting to understand what properties of the data might allow self-training to do better than the exponential bound.

\emph{Our theory leads to practical insights, showing that regularization---even in the context of infinite data---and label sharpening are essential} for gradual self-training. Without regularization, the accuracy of gradual self-training drops from 84\% to 77\% on Portraits and 88\% to 46\% on rotating MNIST. Even when we self-train with more examples, the performance gap between regularized and unregularized models stays the same---unlike in supervised learning where the benefit of regularization diminishes as we get more examples.
\pl{I was expecting some results for label sharpening; people might not even know what label sharpening is...}
\ak{Ah I see, it seems like a slightly less major point, and hard to define---what do you think?}
\pl{just thinking about it, label sharpening is a bit of a misnomer - we're sharpening the distribution over labels, not the labels,
but I don't have any other better ideas}

Finally, our theory suggests that the gradual shift structure helps when the shift is small in Wasserstein-infinity distance as opposed to other distance metrics like the KL-divergence.
For example, one way to interpolate between the source and target domains is to gradually introduce more images from the target, but this shift is large in Wasserstein-infinity distance---we see experimentally that gradual self-training does not help in this setting.
We hope this gives practitioners some insight into when gradual self-training can work.
 
\section{Setup}
\label{setup}

\newcommand{\dist}{\ensuremath{\rho}}
\newcommand{\wasser}{\ensuremath{W_{\infty}}}
\newcommand{\xspace}{\ensuremath{\mathbb{R}^d}}
\newcommand{\yspace}{\ensuremath{\{-1, 1\}}}
\newcommand{\error}{\ensuremath{\mbox{Err}}}
\newcommand{\E}[0]{\ensuremath{\mathop{\mathbb{E}}}}
\newcommand{\prob}[0]{\ensuremath{\mathbb{P}}}
\newcommand{\sign}{\ensuremath{\mbox{sign}}}
\newcommand{\selftrain}{\ensuremath{\textup{ST}}}
\newcommand{\linearmodels}{\ensuremath{\Theta}}

\newcommand{\marginphi}{\ensuremath{\phi}}
\newcommand{\ramp}{\ensuremath{r}}
\newcommand{\hinge}{\ensuremath{h}}
\newcommand{\rampl}{\ensuremath{\ell_r}}
\newcommand{\hingel}{\ensuremath{\ell_h}}
\newcommand{\phil}{\ensuremath{\ell_{\phi}}}
\newcommand{\rampL}{\ensuremath{L_r}}
\newcommand{\hingeL}{\ensuremath{L_h}}
\newcommand{\phiL}{\ensuremath{L_{\phi}}}
\newcommand{\reg}{\ensuremath{R}}
\newcommand{\normal}{\ensuremath{\mathcal{N}}}


\textbf{Gradually shifting distributions:} Consider a binary classification task of predicting labels  from input features . 
We have joint distributions over the inputs and labels, : , where  is the source domain,  is the target domain, and  are intermediate domains.
We assume the shift is gradual: for some ,  for all , where  is some distance function between distributions  and .
We have  labeled examples  sampled independently from the source  and  unlabeled examples  sampled independently from  for each .

\textbf{Models and objectives:}
We have a model family , where a model  outputs a score representing its confidence that the label  is 1 for the given example.
The model's prediction for an input  is , where  if  and  if .
We evaluate models on the fraction of times they make a wrong prediction, also known as the - loss:

The goal is to find a classifier  that gets high accuracy on the target domain ---that is, low .
In an online setting we may care about the accuracy at the current  for every time , and our analysis works in this setting as well.

\textbf{Baseline methods:}
We select a loss function  which takes a prediction and label, and outputs a non-negative loss value,
and we begin by training a source model  that minimizes the loss on labeled data in the source domain:


The \emph{non-adaptive baseline} is to use  on the target domain, which incurs error .
\emph{Self-training} uses unlabeled data to adapt a model.
Given a model  and unlabeled data ,  denotes the output of self-training.
Self-training pseudolabels each example in  using , and then selects a new model  that minimizes the loss on this pseudolabeled dataset.
Formally,


Here, self-training uses ``hard" labels: we pseudolabel examples as either  or , based on the output of the classifier, instead of a probabilistic label based on the model's confidence---we refer to this as \emph{label sharpening}.
In our theoretical analysis, we sometimes want to describe the behavior of self-training when run on infinite unlabeled data from a probability distribution :


The \emph{direct adaptation to target} baseline takes the source model  and self-trains on the target data , and is denoted by . Prior work often chooses to repeat this process of self-training on the target  times, which we denote by .

\textbf{Gradual self-training:} In gradual self-training, we self-train on the finite unlabeled examples from each domain successively. That is, for , we set:

 is the output of gradual self-training, which we evaluate on the target distribution .

\pl{should we admit that GST actually uses more data, but that we can adjust? I'm on the fence about not complicating things but also pre-empting readers' worries}
\ak{Would prefer not complicating things here!}
 
\section{Theory for the margin setting}
\label{sec:margin_theory}

We show that gradual self-training does better than directly adapting to the target, where we assume that at each time step there exists some linear classifier---which can be different at each step---that can classify most of the data correctly with a margin (a standard assumption in learning theory), and that the shifts are small. Our main result (Theorem~\ref{thm:gradualSelfTrain}) bounds the error of gradual self-training.
We show that our analysis is tight for gradual self-training (Example~\ref{ex:selfTrainingExponential}), and explain why regularization, label sharpening, and the ramp loss, are key to our bounds.
Proofs are in Appendix~\ref{sec:appendix_margin_theory}.


\subsection{Assumptions}

\textbf{Models and losses:} We consider regularized linear models that have weights with bounded  norm:  for some fixed . Given , the model's output is .

We consider margin loss functions such as the hinge and ramp losses. Intuitively, a margin loss encourages a model to classify points correctly and confidently---by keeping correctly classified points far from the decision boundary. We consider the hinge function  and ramp function :

The ramp loss is , where  is a model's prediction, and  is the true label.
The hinge loss is the standard way to enforce margin, but the ramp loss is more robust towards outliers because it is bounded above---no single point contributes too much to the loss.
We will see that the ramp loss is key to the theoretical guarantees for gradual self-training because of its robustness.
We denote the population ramp loss as:

\tengyu{would it be easier if we just write }
\ak{Ah I think this will be inconsistent with the self-training algorithm definition though, in the setup}
Given a finite sample , the empirical loss is:



\textbf{Distributional distance:} Our notion of distance is , the Wasserstein-infinity distance.
Intuitively,  moves points from distribution  to  by distance at most  to match the distributions.
For ease of exposition we consider the Monge form of , although the results can be extended to the Kantarovich formulation as well.
Formally, given probability measures  on :


As usual,  denotes the push-forward of a measure, that is, for every set , .

In our case, we require that the conditional distributions do not shift too much. Given joint probability measures  on the inputs and labels , the distance is:


\newcommand{\sepAssump}{-separation}
\newcommand{\noLabShiftAssump}{no label shift}
\newcommand{\NoLabShiftAssump}{No label shift}
\newcommand{\gradShiftAssump}{gradual shift}
\newcommand{\GradShiftAssump}{Gradual shift}
\newcommand{\boundedAssump}{bounded data}
\newcommand{\BoundedAssump}{Bounded data}

\textbf{\sepAssump{} assumption}: Assume every domain admits a classifier with low loss , that is there exists  and for every domain , there exists some  with .

\textbf{\GradShiftAssump{} assumption}: For some , assume  for every consecutive domain, where  is the regularization strength of the model class .  can be interpreted as the geometric margin (distance from decision boundary to data) the model is trying to enforce.

\textbf{\BoundedAssump{} assumption}: When dealing with finite samples we need a standard regularity condition: we say that  satisfies the \emph{bounded data assumption} if the data is not too large on average:  where .

\textbf{\NoLabShiftAssump{} assumption}: Assume that the fraction of  labels does not change:  is the same for all . 

\subsection{Domain shift: baselines fail}

While the distribution shift from  to  is small, the distribution shift from the source  to the target  can be large, as visualized in Figure~\ref{fig:grad_st_intuition}.
A classifier that gets 100\% accuracy on , might classify every example wrong on , even if .
In this case, directly adaptating to  would not help.
The following example formalizes this:

\newcommand{\baselinesFailText}{
  Even under the \sepAssump, \noLabShiftAssump, \gradShiftAssump, and \boundedAssump{} assumptions, there exists distributions  and a source model  that gets  loss on the source (), but high loss on the target: . Self-training directly on the target does not help: . This holds true even if every domain is separable, so .
}

\begin{example}
\label{ex:baselinesFail}
\baselinesFailText{}
\end{example}

\textbf{Other methods}: Our analysis focuses on self-training, but other bounds do not apply in this setting because they either assume that the density ratio between the target and source exists and is not too small~\cite{huang2006correcting}, or that the source and target are similar enough that we cannot discriminate between them~\cite{ben2010theory}.





\subsection{Gradual self-training improves error}

We show that gradual self-training helps over direct adaptation.
For intuition, consider a simple example where  and  classifies every example in  correctly with geometric margin .
If each point shifts by distance ,  gets every example in the new domain  correct.
If we had infinite unlabeled data from , we can learn a model  that classifies every example in the new domain  correctly with margin  since .
Repeating the process for , we get every example in  correct.

But what happens when we start with a model that has some error, for example because the data cannot be perfectly separated, and have only finite unlabeled samples?
We show that self-training still does better than adapting to the target domain directly, or using the non-adaptive source classifier.

The first main result of the paper says that if we have a model  that gets low loss and the distribution shifts slightly, self-training gives us a model  that does not do too badly on the new distribution.

\newcommand{\gradualSelfTrainTheoremText}{
Given  with  and marginals on  are the same so . Suppose  satisfy the \boundedAssump{} assumption, and we have initial model , and  unlabeled samples  from , and we set . Then with probability at least  over the sampling of , letting :

}

\begin{theorem}
\label{thm:gradualSelfTrain}
\gradualSelfTrainTheoremText{}
\end{theorem}

The proof of this result is in Appendix~\ref{sec:appendix_margin_theory}, but we give a high level sketch here. There exists some classifier that gets accuracy  on , so if we had access to  \emph{labeled} examples from  then empirical risk minimization gives us a classifier that is accurate on the population---from a Rademacher complexity argument we get a classifier  with loss at most , the second and third term in the RHS of the bound.

Since we only have \emph{unlabeled} examples from , self-training uses  to pseudolabel these  examples and then trains on this generated dataset. Now, if the distribution shift  is small relative to the geometric margin , then we can show that the original model  labels most examples in the new distribution  correctly---that is,  is small if  is small. Finally, if most examples are labeled correctly we show that because there exists some classifier  with low margin loss, self-training will also learn a classifier  with low margin loss , which completes the proof.

We apply this argument inductively to show that after  time steps, the error of gradual self-training is  for some constant , if the original error is .

\newcommand{\gradualSelfTrainCorollaryText}{
  Under the \sepAssump, \noLabShiftAssump, \gradShiftAssump, and \boundedAssump{} assumptions, if the source model  has low loss  on  (i.e. ) and  is the result of gradual self-training: , letting :

}

\begin{corollary}
\label{cor:gradualSelfTrain}
\gradualSelfTrainCorollaryText{}
\end{corollary}

Corrollary~\ref{cor:gradualSelfTrain} says that the gradual structure allows some control of the error unlike direct adaptation where the accuracy on the target domain can be 0\% if . Note that if the classes are separable and we have infinite data, then gradual self-training maintains 0 error.


Our next example shows that our analysis for gradual self-training in this setting is tight---if we start with a model with loss , then the error can in fact increase exponentially even with infinite unlabeled examples.
Intuitively, at each step of self-training the loss can increase by a constant factor, which leads to an exponential growth in the error.

\newcommand{\selfTrainingExponentialText}{
  Even under the \sepAssump, \noLabShiftAssump, \gradShiftAssump, and \boundedAssump{} assumptions,
  given , for every  there exists distributions , and  with , but if  then . Note that  is always in .
}

\begin{example}
\label{ex:selfTrainingExponential}
\selfTrainingExponentialText{}
\end{example}

This suggests that if we want sub-exponential bounds we either need to make additional assumptions on the data distributions, or devise alternative algorithms to achieve better bounds (which we believe is unlikely).

\subsection{Essential ingredients for gradual self-training}
\label{subsec:essential_ingredients_theory}

In this section, we explain why regularization, label sharpening, and the ramp loss are essential to bounding the error of gradual self-training (Theorem~\ref{thm:gradualSelfTrain}).

\textbf{Regularization}:
Without regularization there is no incentive for the model to change when self-training---if we self-train without regularization an optimal thing to do is to output the original model. The intuition is that since the model  is used to pseudolabel examples,  gets every pseudolabeled example correct. The scaled classifier  for large  then gets optimal loss, but  and  make the same predictions for every example. We use  to denote the \emph{set} of possible  that minimize the loss on the pseudolabeled distribution (Equation~\eqref{eqn:selfTrainSample}):

\newcommand{\noRegularizationNoGainText}{
  Given a model\pl{if you use  notation, then you can just say , which is easier to parse anyway}  and unlabeled examples  where for all , , there exists  such that for all , .
}

\begin{example}
\label{ex:noRegularizationNoGain}
\noRegularizationNoGainText{}
\end{example}
\pl{should this really be called an example? I feel like these are more results (propositions?) rather than simple illustrative examples}
\ak{I think they are fairly straightforward? It seems too simple to be a proposition.}

More specific to our setting, our bounds require regularized models because regularized models classify the data correctly with \emph{a margin}, so even after a mild distribution shift we get most new examples correct.
Note that in traditional supervised learning, regularization is usually required when we have few examples for better generalization to the population, whereas in our setting regularization is important for maintaining a margin even with infinite data.

\textbf{Label sharpening}: When self-training, we pseudolabel examples as  or , based on the output of the classifier.
Prior work sometimes uses ``soft" labels~\cite{najafi2019robustness}, where for each example they assign a probability of the label being  or , and train using a logistic loss.
The loss on the soft-pseudolabeled distribution is defined as:
\newcommand{\logL}{\ensuremath{L_{\sigma, \theta}}}
\newcommand{\logl}{\ensuremath{ll}}
,
where  is the sigmoid function, and  is the log loss:

Self-training then picks  minimizing .
A simple example shows that this form of self-training may never update the parameters because  minimizes :

\newcommand{\softLabelsBadText}{
For all ,  is a minimizer of , that is, for all , .

}

\begin{example}
\label{ex:softLabelsBad}
\softLabelsBadText{}
\end{example}

This suggests that we ``sharpen" the soft labels to encourage the model to update its parameters.
Note that this is true even on finite data: set  to be the empirical distribution.

\textbf{Ramp versus hinge loss}:
We use the ramp loss, but does the more popular hinge loss  work?
Unfortunately, the next example shows that we cannot control the error of gradual self-training with the hinge loss even if we had infinite examples, so the ramp loss is important for Theorem~\ref{thm:gradualSelfTrain}.

\newcommand{\HingeLossBadText}{
  Even under the \sepAssump, \noLabShiftAssump, and \gradShiftAssump{} assumptions,
  given , there exists distributions  and  with , but if  then  ( gets every example in  wrong), where we use the hinge loss in self-training.
}

\begin{example}
\label{ex:hingeLossBad}
\HingeLossBadText{}
\end{example}

We only analyzed the statistical effects here---the hinge loss tends to work better in practice because it is much easier to \emph{optimize} and is convex for linear models.


\subsection{Self-training without domain shift}

Example~\ref{ex:selfTrainingExponential} showed that when the distribution shifts, the loss of gradual self-training can grow exponentially (though the non-adaptive baseline has unbounded error).
Here we show that if we have no distribution shift, the error can only grow linearly: if , given a classifier with loss , if we do gradual self-training the loss is at most .

\newcommand{\selfTrainingNoShiftBoundText}{
  Given , distributions , and model  with ,  where 
}

\begin{proposition}
\label{prop:selfTrainingNoShiftBound}
\selfTrainingNoShiftBoundText{}
\end{proposition}

In Appendix~\ref{sec:appendix_margin_theory}, we show that self-training can indeed hurt without domain shift: given a classifier with loss  on , self-training on  can increase the classifier's loss on  to , but here the non-adaptive baseline has error .





\pl{nice results, but it's a bit too bad that you don't give any details of
the actual examples; space is a concern but are they complex? is there anything you can do?}
 
\section{Theory for the Gaussian setting}
\label{sec:gaussian_theory}



In this section we study an idealized Gaussian setting to understand conditions under which self-training can have better than exponential error bounds: we show that if we begin with a good classifier, the distribution shifts are not too large, and we have infinite \emph{unlabeled} data, then gradual self-training maintains a good classifier.

\subsection{Setting}

We assume  is an isotropic Gaussian in -dimensions for each .
We can shift the data to have mean , so we suppose:

Where  and  for each .
\pl{uh, you can do that for one time step, but doesn't make sense across time steps? doesn't seem fully general}
\ak{If you have infinite unlabeled data, and itâ€™s isotropic, you can just shift the data in the current domain its mean. If the original shifts between domain 1 and 2 is small, then the shifts in the mean-centered data from 1 and 2 will be small as well.}
As usual, we assume the shifts are gradual: for some , .
We assume that the means of the two classes do not get closer than the shift, or else it would be impossible to distinguish between no shift, and the distributions of the two classes swapping: so  for all .
We assume infinite unlabeled data (access to ) in our analysis.

Given labeled data in the source, we use the objective:

For unlabeled data, self-training performs descent steps on an underlying objective function~\cite{amini2003semisupervised}, which we focus on:

We assume  is a continuous, non-increasing function which is strictly decreasing on : these are regularity conditions which the hinge, ramp, and logistic losses satisfy. If  then ~\cite{amini2003semisupervised}.
\pl{why not just use  instead of  to make the notation consistent with previous section?}
\ak{there's no bias term here, and I use  for the weights before (and in the appendices), is that fine?}

The algorithm we analyze begins by choosing  from labeled data in , and then updates the parameters with unlabeled data from  for :


Note that we do not show that self-training actually converges to the constrained minimum of  in Equation~\eqref{eqn:constrained_min} and prior work only shows that self-training descends on ---we leave this optimization analysis to future work.

\subsection{Analysis}

Let  where .
Note that  minimizes the 0-1 error on .
Our main theorem says that if we start with a regularized classifier  that is near , which we can learn from labeled data, and the distribution shifts  are not too large, then we recover the optimal .
The key challenge is that the unlabeled loss  in  dimensions is non-convex, with multiple local minima, so directly minimizing  does not guarantee a solution that minimizes the labeled loss .

\newcommand{\gaussianTheoremText}{
Assuming the Gaussian setting, if , then we recover .
}

\begin{theorem}
\label{thm:gaussian}
\gaussianTheoremText{}
\end{theorem}

Proving this reduces to proving the \emph{single-step} case. At each step , if we have a classifier  that was close to , then we will recover . We give intuition here and the formal proof in Appendix~\ref{sec:appendix_gaussian_theory}.

We first show that if  changes by a small amount, the optimal parameters (for the labeled loss) does not change too much.
Then since  is close to ,  is not too far away from .
The key step in our argument is showing that the unique minimum of the unlabeled loss  in the neighborhood of , is ---looking for a minimum \emph{nearby} is important because if we deviate too far we might select other ``bad" minima.
We consider arbitrary  near  and construct a pairing of points  in , using a convexity argument to show that  contributes more to the loss of  than .


 
\section{Experiments}
\label{sec:experiments}

Our theory leads to practical insights---we show that regularization and label sharpening are important for gradual self-training, that leveraging the gradual shift structure improves target accuracy, and give intuition for when the gradual shift assumption may not help.
We run experiments on three datasets (see Appendix~\ref{sec:appendix_experiments} for more details):


\textbf{Gaussian}: Synthetic dataset where the distribution  for each of two classes is a -dimensional Gaussian, where . The means and covariances of each class vary over time. The model gets  labeled samples from the source domain, and  unlabeled samples from each of  intermediate domains. This dataset resembles our Gaussian setting but the covariance matrices are not isotropic, and the number of labeled and unlabeled samples is finite and on the order of the dimension .

\textbf{Rotating MNIST}: Rotating MNIST is a semi-synthetic dataset where we rotate each MNIST image by an angle between 0 and 60 degrees. We split the 50,000 MNIST training set images into a source domain (images rotated between 0 and 5 degrees), intermediate domain (rotations between 5 and 60 degrees), and a target domain (rotations between 55 degrees and 60 degrees). Note that each image is seen at exactly one angle, so the training procedure cannot track a single image across different angles.


\textbf{Portraits}: A real dataset comprising photos of high school seniors across years~\cite{ginosar2017portraits}. The model's goal is to classify gender. We split the data into a source domain (first 2000 images), intermediate domain (next 14000 images), and target domain (next 2000 images).

\subsection{Does the gradual shift assumption help?}
\label{sec:doesGradualShiftHelpExperiments}

Our goal is to see if adapting to the gradual shift sequentially helps compared to directly adapting to the target. We evaluate four methods: \emph{Source}: simply train a classifier on the labeled source examples. \emph{Target self-train}: repeatedly self-train on the unlabeled target examples ignoring the intermediate examples. \emph{All self-train}: pool all the unlabeled examples from the intermediate and target domains, and repeatedly self-train on this pooled dataset to adapt the initial source classifier. \emph{Gradual self-train}: sequentially use self-training on unlabeled data in each successive intermediate domain, and finally self-train on unlabeled data on the target domain, to adapt the initial source classifier.

For the Gaussian and MNIST datasets, we ensured that the target self-train method sees as many unlabeled target examples as gradual self-train sees across all the intermediate examples.
Since portraits is a real dataset we cannot synthesize more examples from the target, so target self-train uses fewer unlabeled examples here. 

For rotating MNIST and Portraits we used a 3-layer convolutional network with dropout and batchnorm on the last layer, that was able to achieve  accuracy on held out examples in the source domain.
For the Gaussian dataset we used a logistic regression classifier with  regularization.
For each step of self-training, we filter out the 10\% of images where the model's prediction was least confident---Appendix~\ref{sec:appendix_experiments} shows similar findings without this filtering\pl{then why bother with this filtering since it's more complicated?}\ak{all methods do better with this filtering, but the relative difference is similar, see appendix C}.
To account for variance in initialization and optimization, we ran each method 5 times and give  confidence intervals.
More experimental details are in Appendix~\ref{sec:appendix_experiments}.

\begin{table}[t]
\caption{
Classification accuracies for gradual self-train (ST) and baselines on 3 datasets, with  confidence intervals for the mean over 5 runs.
Gradual ST does better than self-training directly on the target or self-training on all the unlabeled data pooled together.
}
\label{tab:gradHelps}
\vskip 0.15in
\begin{center}
\begin{small}
\begin{sc}
\begin{tabular}{lcccr}
\toprule
 & Gaussian & Rot MNIST & Portraits \\
\midrule
Source              & 47.70.3  & 31.91.7 & 75.31.6 \\
Target ST   & 49.60.0  & 33.02.2 & 76.92.1 \\
All ST     & 92.50.1  & 38.01.6 & 78.93.0 \\
Gradual ST & \textbf{98.80.0} & \textbf{87.91.2} & \textbf{83.80.8} \\
\bottomrule
\end{tabular}
\end{sc}
\end{small}
\end{center}
\vskip -0.1in
\end{table}

Table~\ref{tab:gradHelps} shows that leveraging the gradual structure leads to improvements over the baselines on all three datasets.


\subsection{Important ingredients for gradual self-training}

Our theory suggests that regularization and label sharpening are important for gradual self-training, because without regularization and label sharpening there is no incentive for the model to change (Section~\ref{subsec:essential_ingredients_theory}).
However, prior work suggests that overparameterized neural networks trained with stochastic gradient methods have strong implicit regularization~\cite{zhang2017understanding, hardt2016train}---in the supervised setting they perform well without explicit regularization even though the number of parameters is much larger than the number of data points---is this implicit regularization enough for gradual self-training?

In our experiments, we see that even without explicit regularization, or with `soft' probabilistic labels, gradual self-training does slightly better than the non-adaptive source classifier, suggesting that this implicit regularization may have some effect.
However, explicit regularization and `hard' labeling gives a much larger accuracy boost.

\textbf{Regularization is important}: We repeat the same experiment as Section~\ref{sec:doesGradualShiftHelpExperiments}, comparing gradual self-training with or without regularization---that is, disabling dropout and batchnorm~\cite{ioffe2015batch} in the neural network experiments.
In both cases, we first train an \emph{unregularized} model on labeled examples in the source domain.
Then, we either turn on regularization during self-training, or keep the model unregularized.
We control the original model to be the same in both cases to see if regularization helps in the self-training process, as opposed to in learning a better supervised classifier.
Table~\ref{tab:regHardLabelImportant} shows that accuracies are significantly better with regularization, even though unregularized performance is still better than the non-adaptive source classifier. \tnote{cite some paper that proposes that batchnorm may have regularization effect? Fixup discuss it a bit but very little, which other paper shows it?} \ak{Cited the original batch norm paper which claims this}

\textbf{Soft labeling hurts}: We ran the same experiment as Section~\ref{sec:doesGradualShiftHelpExperiments}, comparing gradual self-training with hard labeling versus using probabilistic labels output by the model. Table~\ref{tab:regHardLabelImportant} shows that accuracies are better with hard labels.

\begin{table}[t]
\caption{
Classification accuracies for gradual self-train with explicit regularization and hard labels (Gradual ST), without regularization but with hard labels (No Reg), and with regularization but with soft labels (Soft Labels).
Gradual self-train does best with explicit regularization and hard labels, as our theory suggests, even for neural networks with implicit regularization.
}
\label{tab:regHardLabelImportant}
\vskip 0.15in
\begin{center}
\begin{small}
\begin{sc}
\begin{tabular}{lcccr}
\toprule
 & Gaussian & Rot MNIST & Portraits \\
\midrule
Soft Labels         & 90.51.9  & 44.12.3 & 80.11.8 \\
No Reg   & 84.61.1  & 45.82.5 & 76.51.0 \\
Gradual ST           & \textbf{99.30.0}  & \textbf{83.82.5} & \textbf{82.60.8} \\
\bottomrule
\end{tabular}
\end{sc}
\end{small}
\end{center}
\vskip -0.1in
\end{table}

\textbf{Regularization is still important with more data}:
In supervised learning, the importance of regularization diminishes as we have more training examples---if we had access to infinite data (the population), we don't need regularization.
On the other hand, for gradual domain adaptation, the theory says regularization is needed to adapt to the dataset shift even with infinite data, and predicts that regularization remains important even if we increase the sample size.

To test this hypothesis, we construct a rotating MNIST dataset where we increase the sample sizes.
The source domain  consists of  images on MNIST.
 then consists of these \emph{same}  images, rotated by angle , for .
The goal is to get high accuracy on : these images rotated by 60 degrees---the model doesn't have to generalize to unseen images, but to seen images at different angles.
We compare using regularization versus not using regularization during gradual self-training.
\begin{table}[t]
\caption{
Classification accuracies for gradual self-train on rotating MNIST as we vary the number of samples.
Unlike in previous experiments, here the same  samples are rotated, so the models do not have to generalize to unseen images, but seen images at different angles.
The gap between regularized and unregularized gradual self-training does not shrink much with more data.
}
\label{tab:moreDataDoesntHelp}
\vskip 0.15in
\begin{center}
\begin{small}
\begin{sc}
\begin{tabular}{lcccr}
\toprule
 & N=2000 & N=5000 & N=20,000 \\
\midrule
Source         & 28.31.4  & 29.92.5 & 33.92.6\\
No Reg   & 55.73.9  & 53.64.0 & 55.13.9\\
Reg           & \textbf{93.10.8}  & \textbf{91.72.4} & \textbf{87.43.1}\\
\bottomrule
\end{tabular}
\end{sc}
\end{small}
\end{center}
\vskip -0.1in
\end{table}
Table~\ref{tab:moreDataDoesntHelp} shows that regularization is still important here, and the gap between regularized and unregularized gradual self-training does not shrink much with more data.

\pl{one could just say maybe your  is too small, and if you had a million points, then it wouldn't matter...}
\ak{True, I added an experiment with 20K points.}

\subsection{When does gradual shift help? \tnote{can we have a statement instead of a question?}}

Our theory in Section~\ref{sec:margin_theory} says that gradual self-training works well if the shift between domains is small in Wasserstein-infinity distance, but it may not be enough for the total variation or KL-divergence between  and  to be small.


To test this, we run an experiment on a modified version of the rotating MNIST dataset.
We keep the source and target domains the same as before, but change the intermediate domains.
In Table~\ref{tab:gradHelps} we saw that gradual self-training works well if we have intermediate images rotated by gradually increasing rotation angles.
Another type of gradual transformation is to gradually introduce more examples rotated by  to  degrees.
That is, in the -th domain,  fraction of the examples are MNIST images rotated by  to  degrees, and  of the examples are MNIST images rotated by  to  degrees, where .
Here the total-variation distance between successive domains is small, but intuitively the Wasserstein distance is large because each image undergoes a large ( degrees) rotation.

As the theory suggests, here gradual self-training does not outperform directly self-training on the target---gradual self-training gets  accuracy on the target, while direct adaptation to the target gets  over 5 runs.
We hope this gives practitioners some insight into not just the strengths of gradual self-training, but also its limitations.
 
\section{Related work}
\label{sec:related_work}

\textbf{Self-training} is a popular method in semi-supervised learning~\cite{lee2013pseudo, sohn2020fixmatch} and domain adaptation~\cite{long2013transfer, zou2019confidence, inoue2018cross}, and is related to entropy minimization~\cite{grandvalet05entropy}. Theory in semi-supervised learning~\cite{rigollet2007generalization, singh2008unlabeled, shai2008unlabeled} analyzes when unlabeled data can help, but does not show bounds for particular algorithms. Recent work shows that a robust variant of self-training can mitigate the tradeoff between standard and adversarial accuracy~\cite{raghunathan2020understanding}. Related to self-training is co-training~\cite{blum98cotraining}, which assumes that the input features can be split into two or more views that are conditionally independent on the label.

Unsupervised \textbf{domain adaptation}, where the goal is to directly adapt from a labeled source domain to an unlabeled target domain, is widely studied~\cite{quinonero2009dataset}.
The key challenge for domain adaptation theory is when the source and target supports do not overlap~\cite{zhao2019zhao, shu2018dirtt}, which are typical in the modern high-dimensional regime.
\emph{Importance weighting} based methods~\cite{shimodaira2000improving, sugiyama2007covariate, huang2006correcting} assume the domains overlap, with bounds depending on the expected density ratios between the source and target.
Even if the domains overlap, the density ratio often scales exponentially in the dimension.
These methods also assume that  is the same for the source and target.
\emph{The theory of -divergence}~\cite{ben2010theory, mansour2009domain} gives conditions for when a model trained on the source does well on the target \emph{without any adaptation}.
Empirical methods aim to learn domain invariant representations~\cite{tzeng2014domain, ganin2015domain, tzeng2017domain} but there are no theoretical guarantees for these methods~\cite{zhao2019zhao}.
These methods require additional heuristics~\cite{hoffman2018cycada}, and work well on some tasks but not others~\cite{bobu2018adapting, peng2019moment}.
Our work suggests that the structure from gradual shifts, which appears often in applications, can be a way to build theory and algorithms for regimes where the source and target are very different.



\citet{hoffman2014continuous, gadermayr2018gradual, wulfmeier2018incremental, bobu2018adapting} among others propose approaches for \textbf{gradual domain adaptation}.
This setting differs from online learning~\cite{shalev07online}, lifelong learning~\cite{silver2013lifelong}, and concept drift~\cite{kramer1988learning, bartlett1992learning, bartlett1996learning}, since we only have unlabeled data from shifted distributions. To the best of our knowledge, we are the first to develop a theory for gradual domain adaptation, and investigate when and why the gradual structure helps. 


\paragraph{Acknowledgements.}

The authors would like to thank the Open Philantropy Project and the Stanford Graduate Fellowship program for funding. This work is also partially supported by the Stanford Data Science Initiative and the Stanford Artificial Intelligence Laboratory.

We are grateful to Stephen Mussman, Robin Jia, Csaba Szepesvari, Shai Ben-David, Lin Yang, Rui Shu, Michael Xie, Aditi Raghunathan, Yining Chen, Colin Wei, Pang Wei Koh, Fereshte Khani, Shengjia Zhao, and Albert Gu for insightful discussions.


\paragraph{Reproducibility.}

Our code is at \url{https://github.com/p-lambda/gradual_domain_adaptation}. Code, data, and experiments will be available on CodaLab soon.

 
\bibliographystyle{unsrtnat}
\bibliography{local,refdb/all}

\appendix

\newpage
\section{Proofs for Section~\ref{sec:margin_theory}}
\label{sec:appendix_margin_theory}

\newtheorem*{baselinesFailExample}{Restatement of Example~\ref{ex:baselinesFail}}

\begin{baselinesFailExample}
\baselinesFailText{}
\end{baselinesFailExample}

\begin{proof}
We construct an example in 2-D, where we consider the set of regularized linear models , where . Such a classifier is parametrized by  where  with , and . The output of the model is , and the predicted label is .

We first define the source distribution :


Consider the source classifier .
The classifier classifies all examples correctly, in particular , and .
In addition, the ramp loss is , that is:

We now construct distributions  and :




Basically, the second-coordinate starts at 1 and decreases over time when the label is , and starts at  and increases over time when the label is .
We note that .

Now,  classifies everything incorrectly in .
, and  but the corresponding labels in  are  and  respectively.
Accordingly, the ramp loss .

Self-traning on  cannot fix the problem.
 gets every example incorrect, so all the pseudolabels are incorrect.
In particular, let  be the pseudolabels produced using ---we have,  and .
Self-training on this is now a convex optimization problem, which attains 0 loss, for example using the classifier , , but any such classifier also gets all the examples incorrect.
Note that the max-margin classifier on the source also exhibits the same issue (that is, it can get all the examples wrong after the dataset shift), from a simple extension of this example.

Finally, the classifier , , gets every label correct in \emph{all distributions}, .


\end{proof}


\newtheorem*{gradualSelfTrainTheorem}{Restatement of Theorem~\ref{thm:gradualSelfTrain}}

\begin{gradualSelfTrainTheorem}
\gradualSelfTrainTheoremText{}
\end{gradualSelfTrainTheorem}

We begin by stating and proving some lemmas that formalize the proof outline in the main paper.
We begin with a standard lemma that says if we learn a regularized linear classifier from  labeled examples from a distribution , then the classifier is almost as good as the optimal regularized linear classifier on , and the classifier gets closer to optimal as  increases. We bound the error of the classifier using the Rademacher complexity of regularized linear models .

\begin{lemma}
\label{lem:finiteSampleBound}
Given  samples  from a joint distribution  over inputs  and labels , and suppose . Let  and  be the empirical and population minimizers of the ramp loss respectively:


Then with probability at least ,

\end{lemma}

\begin{proof}
We begin with a standard bound (see e.g. Theorem 9, page 70 in~\cite{liang2016statistical}), where the generalization error on the left is bounded by the Rademacher complexity:

Here,  is the composition of the loss with the set of regularized linear models, and  is the Rademacher complexity.
It now suffices to bound .

We first use Talagrand's lemma, which says that if  is an -Lipschitz function (that is,  for all ), then:

In our case, we let , in which case  where  is the ramp loss.
The Lipschitz constant of the ramp loss  is 1, so .

Finally, we need to bound , the Rademacher complexity of -regularized linear models. This is a standard argument (e.g. see Theorem 11, page 82 in~\cite{liang2016statistical}) and we get:

\end{proof}


The next lemma shows that the error (0-1 loss) of  is low on , even though the margin loss may be high. Intuitively,  classifies most points in  correctly with geoemtric margin , so after a small distribution shift , these points are still correctly classified since the margin acts as a `buffer' protecting us from misclassification.

\begin{lemma}
\label{lem:boundErrorFromMargin}
If , , and the marginals on  are the same so , then  
\end{lemma}

\begin{proof}
Let  be the weights and bias of the regularized linear model, with .

Intuitively, if the ramp loss for a regularized linear model is low, then most points are classified correctly with high geometric margin (distance to decision boundary). Formally, we first show (using basically Markov's inequality) that , where we recall that  is the ramp loss which is bounded between  and :

Here, the inequality on the third line follows because if  where , then , from the definition of the ramp loss.

This gives us:


The high level intuition of the next step is that since the shift is small, only points  with  can be misclassified after the distribution shift, and from the previous step since there aren't too many of these the error of  on  is small.

Formally, fix  with , and let  be a mapping such that for all measurable , , with  for \footnote{We need the  here because a mapping with exactly the  distance may not exist, although if they  and  have densities then such a mapping does exist.}, then we have:


Where the inequality follows from Cauchy-Schwarz:


Combining this with Equation~\eqref{eqn:marginErrorBound}, this gives us:

Since  was arbitrary, by taking the infimum over all , we get:

Which was what we wanted to show.

\end{proof}

From the previous lemma,  has low error on , or in other words only occasionally mislabels examples from . The next lemma says that if we minimize the ramp loss on a distribution where the points are only occasionally mislabeled, then we learn a classifier with low (good) ramp loss as well.

\begin{lemma}
\label{lem:boundMarginFromError}
Given random variables  (defined on the same measure space) with joint distribution , where  denotes the distribution over inputs, and  denote distinct distributions over labels. If  then for any , . Here  denotes the distribution where the input  is sampled from  and then the label is sampled from .
\end{lemma}

\begin{proof}
Let . The proof is by algebra, where we recall that  is the ramp loss which is bounded between  and :

\end{proof}


\begin{proof}[Proof of Theorem~\ref{thm:gradualSelfTrain}]
We begin by noting that there is some  that gets low loss  on :


In self-training, we do not have access to labels from  so we use  to pseudolabel examples  from , so let  and let  be the pseudolabel distribution .

However, our pseudolabels are mostly correct.
That is, let .
Since the conditions of Lemma~\ref{lem:boundErrorFromMargin} are satisfied, .
This means that the pseudolabels from  and the true labels on  mostly agree: .
So by Lemma~\ref{lem:boundMarginFromError}, , which attained low loss  on , also does fairly well on the pseudolabeled distribution , which denotes the distribution where the input  is sampled from  and then the label is sampled from :


Since we have  examples from , from Lemma~\ref{lem:finiteSampleBound} the empirical risk minimizer  on the  examples satisfies:


But minimizing the loss on  explicitly gives us a lower loss than  gets on  (recall that  is the minimizer of the loss on  which is different):


Combining Equations~\eqref{eqn:ermOnPseudolabel} and~\eqref{eqn:eplicitlyMinPseudolabel}, we get:

This bounds the ramp loss of  on the pseudolabeled distribution ---to convert this back to  we apply Lemma~\ref{lem:boundMarginFromError} again which we can since , which gives us:

This completes the proof.

\end{proof}



\newtheorem*{gradualSelfTrainCorollary}{Restatement of Corollary~\ref{cor:gradualSelfTrain}}

\begin{gradualSelfTrainCorollary}
\gradualSelfTrainCorollaryText{}
\end{gradualSelfTrainCorollary}

\begin{proof}
We begin with a classifier with loss .
Applying Theorem~\ref{thm:gradualSelfTrain} for each subsequent step of self-training, letting , we get:

Expanding, this becomes the sum of a geometric series. Noting that , by using the formula for the sum of geometric series, we get:

\end{proof}



\newtheorem*{selfTrainingExponentialExample}{Restatement of Example~\ref{ex:selfTrainingExponential}}

\begin{selfTrainingExponentialExample}
\selfTrainingExponentialText{}
\end{selfTrainingExponentialExample}

\begin{proof}
The construction works even in 1-D. We will consider regularized linear models  with , so . Such a model in 1D can be parametrized by 2 parameters,  with , where the output of the linear model for an input  is , and the label is .

First we give intuition, and then we dive into the formal details of the construction.

We start with a classifier .
We will construct the distributions so that the classifier  for all , that is, gradual self-training will not update the classifier.
In the initial distribution , all the negative examples will be located at , so the classifier gets them correct and incurs 0 loss on them.
 fraction of the positive examples will be at , these examples are misclassified so the classifier incurs loss .
The rest of the positive examples will be at , and the classifier incurs  loss on them.

In distribution ,  fraction of the positive examples will move from  to , but everything else stays the same as in .
After pseudolabeling and self-training, the classifier still stays the same, that is .
This is because the  fraction of examples at  will be pseudolabeled negative, the  fraction of examples at  pseudolabeled positive, and the remaining positive examples at  will be pseudolabeled positive. 
Training on this pseudolabeled distribution gives us  as the optimal parameters.

In , the  fracton of points at  moves to .
After pseudolabeling and self-training, we still get .
At this point the classifier incurs loss .
We repeat this process, except for ,  fraction of the positive examples move from  to , and then the next time in ,  fraction of the positive examples move from  to , etc.
So in this way the loss grows exponentially.

We now give the formal construction, which works even in just 1 dimension.
First, we choose  to be the maximum integer such that .
We have , because .

We now define a sequence of weights, which represents the fraction of points we move in each step as in the sketch above.
For , let , and let .
From the sum of geometric series, we can verify that each of these weights are positive, and the weights sum up to .

We now define the distributions at each step, we case on whether the step is odd or even since as in the above high level sketch, it takes 2 steps to move a point from  across to the other side of the decision boundary.
One subtlety is that unlike the sketch above, since we use the Monge form of the Wasserstein distance, we cannot have all the points exactly at  but keep them separated by a small distance .
This is a technical detail, so on a first reading the reader may just pretend  to work through the structure of the proof.

(Odd case) For ,  is given by:


(Even case) For ,  is given by:


If , then for , we set  (by this step the classifier will have reached ramp loss and error 0.5).

We can check that if , then the classifier obtained from gradual self-training is  (the classifier does not change after self-training).
When , , and finally if  then .
The edge case is because at the end all positive points are to the left of the classifier, so the classifier moves to the right.

Next we examine the loss values.
If , the fraction of examples the classifier  gets wrong on  is:

If , the fraction of examples the classifier  gets wrong on  is .
The ramp loss is bounded below by the error rate, which means:

As desired.

We can verify that for every , , so these distributions satisfy the \gradShiftAssump{} assumption.
 for all , so the distributions satisfy the \noLabShiftAssump{} assumption.
The classifier  gets  loss on all , so the distributions satisfy the \sepAssump{} assumption with .
Finally, the data is all bounded in a constant region, between  and , so the distributions satisfy the \boundedAssump{} assumption.
\end{proof}



\newtheorem*{noRegularizationNoGainExample}{Restatement of Example~\ref{ex:noRegularizationNoGain}}

\begin{noRegularizationNoGainExample}
\noRegularizationNoGainText{}
\end{noRegularizationNoGainExample}

\begin{proof}
The proof is straightforward: scaling up the parameters of the original model  gives us a  that gets  loss (ramp or hinge) on the pseudolabeled distribution, but does not change the model predictions.
For simplicity, we focus on the ramp loss but the proof applies to the hinge loss as well.
Suppose , where  and .

We choose our new parameters to be , where  is a scaling factor we will choose.
Then we can write , the loss of  on the pseudolabeled examples  as:

Now, we can choose large enough  so that the term inside the  in the last line above is always :

So now,  for all .
This gives us that , since  for .
Note that this is true for the hinge loss as well,  for .
Since  is bounded below by ,  is a minimizer of the loss on the pseudolabeled distribution (which is what self-training minimizes, see Equation~\eqref{eqn:selfTrainSample}).

Since  is just a scaled up version of , it does not change the predictions:


\end{proof}



\newtheorem*{softLabelsBadExample}{Restatement of Example~\ref{ex:softLabelsBad}}

\begin{softLabelsBadExample}
\softLabelsBadText{}
\end{softLabelsBadExample}

\begin{proof}
The reason for this is that the logistic loss is a proper scoring loss---if we fix , the loss of  is minimized when . That is, if :

So we have:

\end{proof}


\newtheorem*{hingeLossBadExample}{Restatement of Example~\ref{ex:hingeLossBad}}

\begin{hingeLossBadExample}
\HingeLossBadText{}
\end{hingeLossBadExample}

\begin{proof}

We construct an example in 2D.
We consider the set of regularized linear models , where .
Such a classifier is parametrized by  where  with , and .
The output of the model is , and the predicted label is .

Set .
We will construct an example where the initial hinge error is , but it increases to over  and gets every example wrong, in 2 distribution shifts, even though there exists a single classifier with  hinge loss across all the distributions.
Let  and .
Consider a distribution , for , defined as follows:

We will set , , and .
First, we note that the Wasserstein-infinity distance between any consecutive one of these is at most .

Next, we can verify that .
In particular,  gets points 2 and 4 incorrect, and points 1 and 3 correct with margin 1.
Computing the expectation of the loss, we get .

Now the algorithm self-trains on :  pseudolabels points 1 and 4 positive (), and pseudolabels points 2 and 3 negative (), again getting points 2 and 4 incorrect.
From the KKT conditions, we can verify that the minimizer of the hinge loss on these pseudolabeled points is , and .

Finally, the algorithm self-trains on : here  pseudolabels points 3 and 4 positive, and 1 and 2 negative.
That is, it gets all the examples wrong.
Self-training on these pseudolabels, the model still gets every example wrong (one solution is  and ).
So , and the hinge loss is lower bounded by the error with .

On the other hand, the classifier  and , gets hinge loss  on .

\end{proof}


\newtheorem*{selfTrainingNoShiftBoundProp}{Restatement of Proposition~\ref{prop:selfTrainingNoShiftBound}}

\begin{selfTrainingNoShiftBoundProp}
\selfTrainingNoShiftBoundText{}
\end{selfTrainingNoShiftBoundProp}

\newcommand{\unlabeledL}{\ensuremath{U_r}}
We give intuition for our argument, and then dive into the formal proof.
Suppose we start out with a model that has ramp loss  on .
After a single step of self-training, the loss can increase to  on .
So a naive argument leads to an exponential bound (since the loss is now , it can increase to  after another round of self-training, etc, so after  steps the loss on  is bounded by ).
Showing a linear upper bound requires a more subtle argument that tracks some other invariants, and not just the loss value.

Roughly speaking, if the initial loss is below , there cannot be more than  fraction of points near the decision boundary.
We show that this invariant is maintained by self-training: the `number' of points near the decision boundary decreases, so it always stays below the initial value .
Finally, we show that if there are  points near the decision boundary, then self-training cannot increase the loss by more than  \emph{no matter what the current loss is}.
This shows that at each step the loss can only increase by .
Compare this with Example~\ref{ex:selfTrainingExponential}, where we do have distribution shift---in this case the `number' of points near the decision boundary can keep increasing which can lead to an exponential growth in the loss.

We now dive into the formal proof---we begin by making some definitions and stating and proving lemmas that formalize the above intuition.

In self-training, we pseudolabel an example  with label .
We define the corresponding distribution on the pseudolabels  by .

Recall that the loss of  on labeled data is (where  is the ramp loss):


We define a loss on unlabeled data which corresponds to the loss of  if every example was labeled by .
This roughly corresponds to the `number' of points near the decision boundary, since points far from the decision boundary incur 0 loss, but points near the decision boundary incur a loss between 0 and 1.
Note that the unlabeled loss does not use the labels .
Letting  denote the marginal distribution of  on , and  denote the distribution where  is sampled from  and  is sampled from , the unlabeled loss  is:



The unlabeled loss  and labeled loss  are always defined since the ramp loss is bounded below by .
A straightforward lemma shows that the unlabeled loss lower bounds the labeled loss.

\begin{lemma}[Lower bounds labeled loss]
\label{lem:unlabeled_lower_bounds_labeled}
The unlabeled loss lower bounds the labeled loss: .
\end{lemma}

\begin{proof}
Since , 

Now, since  is a non-increasing function, we have:

Taking expectations on both sides:

\end{proof}

The next lemma shows that each step of self-training decreases the unlabeled loss.

\begin{lemma}[Unlabeled loss decreases]
\label{lem:unlabeled_loss_decreases}
If  and , then .
\end{lemma}

\begin{proof}
Since the unlabeled loss does not depend on the labels, we have:

From Lemma~\ref{lem:unlabeled_lower_bounds_labeled}, the unlabeled loss lower bounds the labeled loss:

But  is the distribution of pseudolabels produced by model , which is exactly what self-training () minimizes (recall the definition of self-training in Equation~\eqref{eqn:selfTrainPop}), so  has lower loss than  on the pseudolabeled distribution:

Which means that:

\end{proof}

We now show a type of triangle inequality for the loss, which says that the loss of  on  is upper bounded by the loss of  on pseudolabels from  plus the loss of  on .

\begin{lemma}[Triangle Inequality]
\label{lem:unlabeled_triangle_inequality}

\end{lemma}

\begin{proof}

We will first show that for any , , , :

We can prove this by casing. If  and  have different signs, or  and  have different signs, then the RHS is 1.
But the ramp loss is bounded above by 1, so the LHS has loss at most 1, which makes this statement true.
Otherwise, suppose , , and  all have the same signs---but then , so .

With this in hand, the result follows with some algebra:

\end{proof}

Next, we show that if the unlabeled loss of  is less than , then self-training cannot increase the loss by more than .

\begin{lemma}[Upper bounding loss growth]
\label{lem:loss_growth_upper_bound}
Suppose  and let . Then:

\end{lemma}

\begin{proof}
From Lemma~\ref{lem:unlabeled_triangle_inequality}, it suffices to show that . But as in Equation~\eqref{eqn:st_loss_bounds_unlabeled}, this is simply because  minimizes the pseudolabeled loss so we have:

\end{proof}

The proof of Proposition~\ref{prop:selfTrainingNoShiftBound} now simply inductively applies Lemma~\ref{lem:unlabeled_loss_decreases} and Lemma~\ref{lem:loss_growth_upper_bound}.

\begin{proof}[Proof of Proposition~\ref{prop:selfTrainingNoShiftBound}]
Let  for .
The unlabeled loss lower bounds the labeled loss: that is, since , from Lemma~\ref{lem:unlabeled_lower_bounds_labeled}, .
The unlabeled loss can only decrease with self-training: that is, inductively applying Lemma~\ref{lem:unlabeled_loss_decreases}, we get that for all , .
Then from Lemma~\ref{lem:loss_growth_upper_bound}, the loss can only increase by  at each step of self-training, so .
\end{proof}

The next Example shows that even without distribution shift, self-training can increase the loss of a model from  to nearly .

\begin{example}
Even under the \sepAssump{} and \boundedAssump{} assumptions, for every , there exists a model  and distribution  with  but . 
\end{example}

\begin{proof}
We give an example in 1D, where a linear model can be parametrized by 2 parameters,  with , where the output of the linear model for an input  is , and the label is .

Let  and .
Let the data distribution  be given by:




Note that the probabilities are all non-negative and add up to  and the data is bounded between  and .

Let the initial model be  and .
The initial loss is .
We can check that after self-training, the updated parameters are  and .
The final loss is .

\end{proof}
 
\newpage

\section{Proofs for Section~\ref{sec:gaussian_theory}}
\label{sec:appendix_gaussian_theory}

We prove Theorem~\ref{thm:gaussian} in Section~\ref{sec:margin_theory}, following the sketch described in the paper.
Our first lemma shows that if  does not change too much, then the optimal parameters  do not change too much either.

\begin{lemma}
\label{lem:lipschitzGaussian}
 is -Lipschitz, that is if , then:

\end{lemma}

\begin{proof}
Recall that , which is well defined since .
We will first prove that if , then the claim holds, that is:

Expanding both sides, this is equivalent to showing:

Subtracting both sides by , it suffices to show:

But since , we can bound the LHS above if we multiply by :

So Equation~\eqref{eqn:lipschitzCase1} is true.

Now we prove the main claim.
Without loss of generality, suppose , otherwise we can swap  and .
Then we can scale  and reduce to the previous case:

Where in the inequality on the 4th line we applied Equation~\eqref{eqn:lipschitzCase1}. This completes the proof.

\end{proof}

We now state a standard lemma in measure theory, which says that if  for all , and the inequality is \emph{strict} on a set of non-zero measure (volume), then the integral of  is strictly greater than the integral of .

\begin{lemma}
\label{lem:basicExpectationBound}
Let  be a measure on , and  be measurable with .
Suppose  if , and  for all , where  and  are measurable functions with finite integrals.
Then:

\end{lemma}

Our next lemma is the key step of the proof.
We show that  is a strict local minimizer of , that is it has lower loss than any other  nearby.

\begin{lemma}
\label{lem:localMinGaussian}
For all  with  and , with , we have:

\end{lemma}

\begin{proof}
Denote  as .
By Cauchy-Schwarz, since  and , we have , and .
This is because .
Since the dot product is non-zero, neither vector can be .

We begin by noting that  is well-defined and finite: because  is between  and  so the expectation is well-defined with finite, non-negative value.

\textbf{Step 1 (Scaling Parameters)}: First, we show that scaling up the parameters decreases the loss: for any  and , .

Since  is non-increasing, .
Now, let .
Since  is strictly decreasing on , for , .
 (the Gaussian mixture distribution assigns positive probability to any set with non-zero volume / Lebesgue measure).
Then from Lemma~\ref{lem:basicExpectationBound}:

Which is precisely saying .

This lets us assume, without loss of generality, that  since scaling up  strictly decreases the loss, and the theorem statement assumes .

\textbf{Step 2 (Rotating parameters)}: Note that rotating the entire space does not change the loss values, formally if  is a rotation matrix then:

So without loss of generality, we rotate the setup so that  and  lie on the  plane (except for the first two coordinates, all coordinates are ).
Let  be the unit bisector of  and , given by .
Without loss of generality, rotate the setup so that  is along the positive  axis (the second coordinate is , and all other coordinates are ), and the first two coordinates of  are positive. 
Let  where , we then have that  since  and  are in the same direction.

\textbf{Step 3 (Symmetry argument)}: Now consider any point  with , with .
Consider its reflection point around , .
Let  denote the increase in loss on  from using classifier  instead of .
Now, from the way we constructed , , and .
So .
That is, as per our sketch, the loss for  decreases when using  instead of , but increases for  when using  instead of , but the magnitudes of these two quantities are equal.

Next, we will show that the probability density is higher for  than .
Let  denote the density of .
 is the mixture of two Gaussians, so for normalizing constant , we have:



We now use strict convexity of  to show that .
Let , , . Since, , we have  and . Letting  we can rewrite the above probabilities as:


Finally, we use strict convexity of  to show the desired result. Since , for some , we can write:


Then, from strict convexity, we have:


Adding both of these, we get:

That is, we have shown .

The case when , where  and  is symmetric.
We ignore points  since this has measure 0.

\textbf{Step 4 (Expectation)}:
We give intuition and then dive into the math.
For every pair of points in our pairing in Step 3, the contribution to the loss of  is at most as high as the contribution to the loss of .
So this trivially gives us , but we want a strict inequality.
However, we can find a set of points with non-zero volume (Lebesgue measure) where the contribution to the loss for  is strictly less than for , which completes the proof.

Formally, letting , we can write (where we defined  in Step 3):

Where the  comes from the fact that the case when  is symmetric and gives the same integral.
Now, let  be a quarter cylinder.
The volume of  is , and .
Further, for all , we have:

So applying Lemma~\ref{lem:basicExpectationBound} again, we get:

Which completes the proof.
\end{proof}

With these key lemmas, the proof of Theorem~\ref{thm:gaussian} is straightforward.

\newtheorem*{gaussianTheorem}{Restatement of Theorem~\ref{thm:gaussian}}

\begin{gaussianTheorem}
\gaussianTheoremText{}
\end{gaussianTheorem}

\begin{proof}
The proof reduces to showing the one-step case: for , if  then , where the  is selected according to Equation~\eqref{eqn:constrained_min}. Applying this one-step result inductively gives us the desired result, that .

For the one-step case, from Lemma~\ref{lem:lipschitzGaussian}, since , .
Then by triangle inequality, since , we have .
Further, , and by Lemma~\ref{lem:localMinGaussian}, any other  satisfying , , and  satisfies .
So  is the unique minimizer in the constrained set, which means .
\end{proof}
 
\newpage
\newpage
\section{Experimental details for Section~\ref{sec:experiments}}
\label{sec:appendix_experiments}

In this section, we provide additional experimental details, and give results for ablations for the experiments in Section~\ref{sec:doesGradualShiftHelpExperiments}.
An advantage of gradual self-training is that it has a very small number of hyperparameters and we show that our findings are robust to different choices of these parameters---even if we do not do confidence thresholding, train every method for more iterations, and use a smaller window size, gradual self-training does better than self-training directly to the target and the other baselines.
For reproducibility, we provide all code but we also describe our datasets and models here.

\subsection{Datasets}

We ran experiments on 3 datasets:
\begin{enumerate}
\item \emph{Gaussian in  dimensions}: We randomly select an initial mean and covariance for each of the two classes, and a final mean and covariance for each class, all in  dimensions. Note that unlike in the theory in Section~\ref{sec:gaussian_theory}, each class can have a different (non diagonal) covariance matrix. The initial and final covariance matrices can also be different. The marginal probability of each class is the same, 0.5. We get labeled data sampled from a gaussian with the initial mean and covariance. For the intermediate domains, we linearly interpolate the means and covariances for each class between the initial and final, and sample points from a gaussian with the corresponding mean and covariance matrices. The number of labeled and unlabeled samples is on the order of d (as opposed to exponential in d, which importance weighting approaches would need). We provide more details next.

Details: We sample  independently from  in  dimensions. Since  is high, these are all nearly orthogonal to each other. We then sample covariance matrices  independently by sampling a diagonal matrix and rotation matrix (since the covariance matrices are PSD they decompose into  for rotation matrix  and diagonal matrix ). We first sample a diagonal matrix  in  dimensions where each entry is uniformly random and independently sampled between min\_var and max\_var. Then, we sample a rotation matrix  from the Haar distribution (which is a standard way to sample random orthogonal matrices), and then compose these to get .

At all times, we keep . We now sample  labeled examples from the source domain, where  and .
We sample  unlabeled intermediate examples. For , let  and . We then sample , and ---the model only gets to see  but not . The unseen target images are sampled from the final means and covariances for each class, and we measure accuracy on these held out examples.

We use  = 500 (500 labeled examples from the source),  = 5000 (so 5000 unlabeled examples in total), and use min\_var=0.05, max\_var=0.1 (the standard-deviation is the square root of these).  We sample 1000 target examples to check accuracy.

\item \emph{Rotating MNIST}: We split the training data, consisting of 50,000 images, using the first  images as the source training set, next  images as source validation set, next  images as unlabeled intermediate examples, and the final  images as unseen target examples. We rotate each source image by an angle uniformly selected between 0 and 5 degrees. The -th intermediate example is rotated by angle  degrees. Each target image is rotated by an angle uniformly selected between 55 degrees and 60 degrees.

\item \emph{Portraits}: A more realistic dataset where we do not control the structure of the shift, consisting of photos of high school seniors taken across many years. Additionally, there is label shift, that is the proportions of males and females, , changes over time (see Figure~\ref{fig:portraits_gender_ratios}), unlike our theory which assumes that the probability of each label stays constant. We use the first 2000 images as source images. We shuffle these, and use 1000 for training, and 1000 for validation. We use the next 14000 images as unlabeled intermediate examples. Finally, we use the next 2000 images as unseen target examples. We downsample the images to 32x32 but do no other preprocessing. We reserve images at the end of the dataset as held-out examples for future work, and so that we can test how the method extrapolates past the point we validate on.
\end{enumerate}


\begin{figure}[t]
\begin{center}
\ifdefined\usearxivstyle
\centerline{\includegraphics[width=0.5\columnwidth]{images/portraits_gender_ratios.png}}
\else
\centerline{\includegraphics[width=\columnwidth]{images/portraits_gender_ratios.png}}
\fi
\caption{The plot shows a rolling average of the fraction of images that are female, over a window size of 1000, with 90\% confidence intervals. The plot suggests that the proportion of males and females changes over time, and is not constant---this label shift might make the task more challenging for self-training methods.}
\label{fig:portraits_gender_ratios}
\end{center}
\vskip -0.3in
\end{figure}

\subsection{Algorithm and baselines}

Next, we describe the gradual self-training algorithm and parameters in more detail.
Algorithm~\ref{alg:grad_self_training} shows pseudocode for gradual self-training.
filter\_low\_confidence filters out the  fraction of examples where the model is least confident, where confidence is measured as the maximum of the softmax output of the classifier.
This filtering is standard in many instances of self-training~\cite{xie2020selftraining}.

\begin{algorithm}[tb]
   \caption{Gradual Self-Training}
   \label{alg:grad_self_training}
\begin{algorithmic}
   \STATE {\bfseries Input:} Labeled source examples , Intermediate unlabeled examples , Window size , Confidence threshold , Number of Epochs , Regularized model 
   \STATE {\bfseries Assume:}  divides 
   \STATE Train  on  for  epochs
   \FOR{ {\bfseries to} }
   \STATE cur\_xs
   \STATE pseudolabeled\_ys.predict\_labelscur\_xs
   \STATE confident\_idxsfilter\_low\_confidence, cur\_xs, 
   \STATE filtered\_xs = cur\_xs[confident\_idxs]
   \STATE filtered\_ys = pseudolabeled\_ys[confident\_idxs]
   \STATE Train  on filtered\_xs, filtered\_ys for  epochs
   \ENDFOR
\end{algorithmic}
\end{algorithm}

For the baselines---for target self-train, we self-train multiple times (iteratively) on the target. Each round of self-training uses the current model  to pseudolabel examples in the target, and then trains on these pseudolabeled examples. Specifically, to make comparisons fair we self-train  times on the target, so that the total number of self-training steps performed by the target self-train baseline and gradual self-training are the same. Similarly, when we self-train to all examples, we self-train multiple times on all unlabeled data, self-training  times. Here  is the window size in Algorithm~\ref{alg:grad_self_training} which is the number of examples in each intermediate domain.

Note that in the synthetic datasets (rotating MNIST and Gaussian) we ensure that target self-train gets access to the same number of unlabeled examples as gradual self-training does in total, to ensure that the improvements are not simply because gradual self-training consumes more unlabeled data (accumulated over all of the intermediate domains). For the real dataset (Portraits), we cannot generate additional examples for target self-train. However, this is why we also compare against self-training directly to all the unlabeled data, which gets access to exactly the same data that gradual self-training does but does not leverage the gradual structure.

\subsection{Models and parameter settings}

Next, we describe the models and parameter settings we used:
\begin{enumerate}

	\item \emph{Models}: For the Gaussian dataset we use a logistic regression classifier, with l2 regularization 0.02. For the MNIST and Portraits dataset, we use a 3 layer convolutional network. For each conv layer we use a filter size of 5x5, stride of 2x2, 32 output channels, and relu activation. We added dropout(0.5) after the final conv layer, and batchnorm after dropout. We flatten the final layer, and then apply a single linear layer to output logits (the number of logits is the number of classes in the dataset which is 10 for rotating MNIST and 2 for Portraits). We then take the softmax of the logits, and optimize the cross-entropy loss. We did not tune the model architecture for our experiments, however we checked that adding an extra layer, changing the number of output channels, and using a different architecture with an extra fully connected layer on top, have little impact on the results. 

	\item \emph{Parameters}: For the window size, we use  for the Gaussian dataset, and  for the rotating MNIST and Portraits dataset. We use a smaller window for the Gaussian dataset because the data is lower dimensional and we have less unlabeled data. We train the model for 10 epochs, 20 epochs, and 100 epochs in each round for the rotating MNIST, Portraits, and Gaussian dataset respectively. These numbers were chosen on validation data on the source without examining the intermediate or target data, and we show an ablation which suggests that the results are not sensitive to these choices.

	\item \emph{Confidence thresholding}: We chose  to filter out the 10\% least confident examples, since these are examples the model is not confident on, so the predicted label is less likely to be correct. We run an ablation without this filtering and see that all methods perform slightly worse, but the relative ordering is similar---gradual self-training is still significantly better than all the other methods.

\end{enumerate}

\subsection{Ablations}

We run ablations which suggest that the results in Section~\ref{sec:doesGradualShiftHelpExperiments} are robust to the choice of algorithm hyperparameters.

\textbf{Confidence thresholding}: Table~\ref{tab:confAblation} shows the results for rotating MNIST and Portraits without confidence thresholding. All methods do worse without confidence thresholding but gradual self-training does significantly better than the other methods.

\begin{table}[t]
\caption{
Classification accuracies for gradual self-train (ST) and baselines without confidence thresholding/filtering, with  confidence intervals for the mean over 5 runs. All methods do worse without confidence thresholding but gradual self-training does significantly better than the other methods.
}
\label{tab:confAblation}
\vskip 0.15in
\begin{center}
\begin{small}
\begin{sc}
\begin{tabular}{lcccr}
\toprule
 & Rot MNIST & Portraits \\
\midrule
Source      & 30.51.0 & 76.20.5 \\
Target ST   & 31.11.4 & 76.91.3 \\
All ST      & 32.61.3 & 77.10.5 \\
Gradual ST  & \textbf{80.31.4} & \textbf{81.71.3} \\
\bottomrule
\end{tabular}
\end{sc}
\end{small}
\end{center}
\vskip -0.1in
\end{table}

\textbf{Window sizes}: Table~\ref{tab:smallerWindowAblation} shows the results for rotating MNIST and Portraits if we use smaller window sizes (from 2000 to 1000). Gradual self-training still does significantly better than the other methods.

\begin{table}[t]
\caption{
Classification accuracies for gradual self-train (ST) and baselines with smaller window sizes, with  confidence intervals for the mean over 5 runs. Gradual self-training still does significantly better than the other methods.
}
\label{tab:smallerWindowAblation}
\vskip 0.15in
\begin{center}
\begin{small}
\begin{sc}
\begin{tabular}{lcccr}
\toprule
 & Rot MNIST & Portraits \\
\midrule
Source      & 35.61.7 & 74.11.4 \\
Target ST   & 36.01.5 & 77.91.4 \\
All ST      & 38.52.6 & 76.32.2 \\
Gradual ST  & \textbf{90.42.0} & \textbf{83.80.5} \\
\bottomrule
\end{tabular}
\end{sc}
\end{small}
\end{center}
\vskip -0.1in
\end{table}

\textbf{Additional ablations for Portraits}: We ran two additional ablations, focusing on Portraits. In the first ablation, we trained every method of self-training for 50\% more epochs. Over 5 trials, gradual self-training got an accuracy of , target self-train got an accuracy of , and self-training to all unlabeled examples got an accuracy of . The non-adaptive baseline got an accuracy of .

We also ran an experiment on Portraits where we extrapolate further in time. Here we use the first 2000 images as source, next 20,000 images as unlabeled intermediate examples, and next 2000 images as the target. Here the accuracy of gradual self-training is , self-training on the target directly is , and self-training on all unlabeled data is . Gradual self-training still does better, but all methods do quite poorly---developing and analyzing new techniques for gradual domain adaptation is an exciting avenue for future work.


 
\end{document}