
\documentclass[copyright,creativecommons]{eptcs}
\providecommand{\event}{SAIRP 2013}
\usepackage{amssymb}
\usepackage{amsthm}
\newcommand{\ol}{\overline}
\renewcommand{\ni}{\noindent}
\newcommand{\eqdef}{\stackrel{{\rm def}}{=}}
\newcommand{\bc}{\begin{center}}
\newcommand{\ec}{\end{center}}
\newcommand{\be}{\begin{enumerate}}
\newcommand{\ee}{\end{enumerate}}
\newcommand{\bi}{\begin{itemize}}
\newcommand{\ei}{\end{itemize}}
\newcommand{\ba}{\begin{array}}
\newcommand{\ea}{\end{array}}
\newcommand{\fa}{\forall}
\newcommand{\facps}{\forall}
\newcommand{\ex}{\exists}
\newcommand{\bnfbar}{\mid}
\newcommand{\se}{\sim}
\newcommand{\we}{\approx}
\newcommand{\lt}{<}
\newcommand{\longleadsto}{\longmapsto}

\def\nset{\mathbb{N}}


\newcommand{\ac}[1]{{\tt #1}}
\newcommand{\act}[1]{{\tt #1}}
\newcommand{\nac}[1]{ \ol{{\tt #1}}}
\newcommand{\olact}[1]{ \ol{{\tt #1}}}
\newcommand{\prc}[1]{ {\tt #1}}
\newcommand{\Nil}{{\tt 0}}
\renewcommand{\t}{\tau}
\newcommand{\e}{\varepsilon}
\newcommand{\hid}{\backslash\!\backslash}
\newcommand{\by}[1]{\stackrel{ #1 }{\longrightarrow}}
\newcommand{\By}[1]{\stackrel{ #1 }{\Longrightarrow}}
\newcommand{\byre}[1]{\stackrel{ #1 }{\longleftarrow}}
\newcommand{\Byre}[1]{\stackrel{ #1 }{\Longleftarrow}}
\renewcommand{\P}{\mathsf{P}}
\newcommand{\A}{\mathsf{A}}
\newcommand{\Ob}{\mathsf{O}}
\newcommand{\ts}{\mathsf{P}}
\newcommand{\tran}{(\mathit{Pr},\mathit{Act}, \arr{ \ })}
\newcommand{\sqsup}{\sqsupset}
\newcommand{\sqsub}{\sqsubset}
\newcommand{\f}{\mathsf{F}}
\newcommand{\ce}{\mathsf{E}}
\newcommand{\G}{\mathsf{G}}

\newcommand{\pmean}[1]{\mid\!\mid\! #1 \!\mid\!\mid^{\Gamma}}
\newcommand{\eset}[1]{ \{ #1 \}}
\newcommand{\dia}[1]{\langle #1 \rangle}
\newcommand{\Dia}[1]{\langle\!\langle  #1 \rangle\!\rangle}
\newcommand{\nec}[1]{\left[ \!\left[  #1 \right] \!\right] }
\renewcommand{\max}[2]{\nu #1 .\, #2 }
\renewcommand{\min}[2]{\mu #1 .\, #2 }
\newcommand{\mean}[2]{\Vert \, #1 \,\Vert_{#2}}
\newcommand{\Mean}[1]{\Vert \, #1 \,\Vert}
\newcommand{\meant}[1]{\Vert\, #1 \,\Vert^{\P}}
\newcommand{\meane}[1]{\Vert\, #1 \,\Vert^{\ce}}
\newcommand{\meanp}[1]{\Vert\, #1 \,\Vert^{\P}}
\newcommand{\meanpt}[2]{\Vert\, #1 \,\Vert^{\P}_{#2}}
\newcommand{\meanet}[2]{\Vert\, #1 \,\Vert^{\P(E)}_{#2}}
\newcommand{\meantt}[2]{\Vert\, #1 \,\Vert_{#2}}
\newcommand{\meanv}[1]{\Vert\, #1 \,\Vert_{\V}}
\newcommand{\meaneev}[1]{\Vert\, #1 \,\Vert_{\V}^{\ce}}
\newcommand{\seq}{  \vdash}
\newcommand{\seqt}[2]{{#1}\vdash{#2}}
\newcommand{\seqxx}[2]{{#1}\vdash_{\V}{#2}}
\newcommand{\seqd}{ \vdash}
\newcommand{\V}{\mathsf{V}}
\newcommand{\pff}{{\tt ff}}
\newcommand{\por}{\vee}
\newcommand{\pand}{\wedge}
\newcommand{\pnu}{\nu}
\newcommand{\pmu}{\mu}
\newcommand{\prtt}{{\tt tt}}
\newcommand{\pnot}{\neg}
\newcommand{\pr}[1]{{\tt #1 }}
\newcommand{\mathsrm}[1]{\mathrm{ #1 }}
\newcommand{\den}[1]{\|#1\|}
\newcommand{\dentv}[1]{\den{#1}_{\V}^{\T}}
\newcommand{\midd}{\; \; \mbox{\Large{}}\;\;}
\newtheorem{prop}{Proposition}
\newtheorem{defin}{Definition}
\newtheorem{theorem}[prop]{Theorem}
\newtheorem{lemma}[prop]{Lemma}
\newtheorem{cor}[prop]{Corollary}
\newtheorem{claim}[prop]{Claim}
\newtheorem{conv}[prop]{Convention}
\newtheorem{fact}[prop]{Fact}
\newtheorem{observ}[prop]{Observation}
\newtheorem{example}{Example}

\def\Var{\mathrm{Var}}
\def\Prop{\mathrm{Prop}} 
\def\w{\emph}
\def\Act{\mathrm{Act}}
\def\T{\mathsf{T}}
\def\S{\mathsf{S}}
\def\rstrut{\vrule height 2ex depth .75ex width 0pt}
\def\proofrule#1#2{{\rstrut #1 \over \rstrut #2}} 
\makeatletter
\def\@eqnnum{}
\def\@yeqncr{\@testopt\@xeqncr\@eqnskip}
\def\@eqnskip{1\jot}
\makeatother
\makeatletter
\def\newspacing #1{\def\baselinestretch{#1}\ifx\@currsize\normalsize
                   \@normalsize \else \@currsize\fi}
\makeatother


 

\newcount\ProofTreebias \ProofTreebias=50
\newdimen\ProofTreeovershoot \ProofTreeovershoot=0.1em \newdimen\ProofTreeannotspace \ProofTreeannotspace=0pt
\def\ProofTreestrut{\vrule depth 5.5pt height 12.5pt width 0pt }
\def\ProofTreerulestrut{\vrule depth 0pt height 0pt width 0pt }
\newbox\ProofTree\newskip\ProofTreespace\ProofTreespace=1em
\newdimen\ProofTreea\newdimen\ProofTreeb\newdimen\ProofTreec
\def\ProofTreedopremise#1{#1}
\def\PTirule{\aPTirule{\hskip-\ProofTreeannotspace}}
\def\PTiirule{\aPTiirule{\hskip-\ProofTreeannotspace}}
\def\PTiiirule{\aPTiiirule{\hskip-\ProofTreeannotspace}}
\def\gobblebrace#1{\def\gobblearg{#1}\afterassignment\agobblebrace\let\gobblething= }

\def\agobblebrace{\ifx\gobblething\ProofTreespace \let\next=\setskip
\else
\ifcat\bgroup\noexpand\gobblething
\let\next=\gobblearg
\else
\ifcat\space\noexpand\gobblething
\let\next=\bgobblebrace
\else
\def\next{\errmessage
{I was expecting optional spaces followed by a left
brace!}}\fi\fi\fi\next}
\def\bgobblebrace{\afterassignment\agobblebrace\let\gobblething=}
\def\setskip{\afterassignment\bgobblebrace\skip255}



\def\doannot#1{\setbox0=\vbox to 0pt{\vss\hbox{#1}\vss}}
\def\aPTiirule#1#2{\begingroup
\doannot{#1}
\setbox7=\hbox{\ProofTreestrut\ProofTreedopremise{#2}}\setbox8=\copy7
\gobblebrace{\bgroup\aftergroup\aPTiirulepartb}}

\def\aPTiirulepartb{\setbox1=\box\ProofTree
\dimen1=\ProofTreea \dimen2=\ProofTreeb \dimen3=\ProofTreec
\skip255=\ProofTreespace \gobblebrace{\bgroup\aftergroup\aPTiirulepartc}}

\def\aPTiirulepartc{\ProofTreespace=\skip255
\setbox2=\box\ProofTree
\dimen4=\ProofTreea \dimen5=\ProofTreeb \dimen6=\ProofTreec
\dimen0=\wd1
\advance\dimen0 -\dimen1
\advance\dimen0 -\dimen2
\advance\dimen0 \ProofTreespace
\advance\dimen0 \dimen4
\advance\dimen0 \dimen5
\advance\dimen0 \dimen6
\ifnum\wd7 <\dimen0
\dimen9=\dimen1
\advance\dimen9 \dimen2
\global\ProofTreea=\dimen9
\ProofTreeb=\dimen0
\advance\ProofTreeb -\wd7
\divide\ProofTreeb 100
\multiply\ProofTreeb \ProofTreebias
\global\ProofTreeb=\ProofTreeb
\setbox7=\hbox to\dimen0{\hskip\ProofTreeb\box7\hfil}
\else \advance\dimen0 -\wd7
\divide\dimen0 100 \multiply\dimen0 \ProofTreebias
\dimen9=\dimen1
\advance\dimen9 \dimen2
\advance\dimen9 \dimen0
\global\ProofTreea=\dimen9
\dimen0=\wd7
\global\ProofTreeb=0pt
\fi
\ifnum\dimen9 <0
\dimen8=-\dimen9
\global\ProofTreea=0pt
\else
\dimen8=0pt
\fi
\global\ProofTreec=\wd8
\global\setbox\ProofTree=\vtop{\offinterlineskip\halign
{\hskip\dimen8 ##\cr
\hskip\dimen9\box7\hfil\cr
\ProofTreerulestrut\hskip\dimen9\hskip-\ProofTreeovershoot\advance\dimen0 2\ProofTreeovershoot
\vrule width\dimen0 depth0pt height 0.4pt\hskip\ProofTreeannotspace\box0\hskip-\ProofTreeovershoot
\hfil\cr
\box1\hskip\ProofTreespace\box2\hfil\cr}}\endgroup}

\def\PTaxiom#1{\global\setbox\ProofTree=\vtop{\hbox{\ProofTreestrut\ProofTreedopremise{#1}}}\global\ProofTreea=0pt\global\ProofTreeb=0pt\global\ProofTreec=\wd\ProofTree
}

\def\aPTirule#1#2{
\begingroup
\doannot{#1}
\setbox7=\hbox{\ProofTreestrut\ProofTreedopremise{#2}}\setbox8=\copy7
\gobblebrace{\bgroup\aftergroup\aPTirulepartb}}
\def\aPTirulepartb{\setbox1=\box\ProofTree
\dimen1=\ProofTreea \dimen2=\ProofTreeb \dimen3=\ProofTreec
\dimen0=\dimen3 \ifnum\wd7 <\dimen0
\dimen9=\dimen1
\advance\dimen9 \dimen2
\global\ProofTreea=\dimen9
\ProofTreeb=\dimen0
\advance\ProofTreeb -\wd7
\divide\ProofTreeb 100
\multiply\ProofTreeb \ProofTreebias
\global\ProofTreeb=\ProofTreeb
\setbox7=\hbox to\dimen0{\hskip\ProofTreeb\box7\hfil}
\else
\advance\dimen0 -\wd7
\divide\dimen0 100 \multiply\dimen0 \ProofTreebias
\dimen9=\dimen1
\advance\dimen9 \dimen2
\advance\dimen9 \dimen0
\global\ProofTreea=\dimen9
\dimen0=\wd7
\global\ProofTreeb=0pt
\fi
\ifnum\dimen9 <0
\dimen8=-\dimen9
\global\ProofTreea=0pt
\else
\dimen8=0pt
\fi
\global\ProofTreec=\wd8 \global\setbox\ProofTree=\vtop{\offinterlineskip\halign
{\hskip\dimen8 ##\cr
\hskip\dimen9\box7\hfil\cr
\ProofTreerulestrut\hskip\dimen9\hskip-\ProofTreeovershoot\advance\dimen0 2\ProofTreeovershoot
\vrule width\dimen0 depth0pt height 0.4pt \hskip\ProofTreeannotspace\box0\hskip-\ProofTreeovershoot
\hfil\cr\box1\hfil\cr}}\endgroup}

\def\aPTiiirule#1#2{\begingroup
\doannot{#1}
\setbox7=\hbox{\ProofTreestrut\ProofTreedopremise{#2}}\setbox8=\copy7
\gobblebrace{\bgroup\aftergroup\aPTiiirulepartb}}

\def\aPTiiirulepartb{\setbox1=\box\ProofTree
\dimen1=\ProofTreea \dimen2=\ProofTreeb \dimen3=\ProofTreec
\gobblebrace{\bgroup\aftergroup\aPTiiirulepartc}}

\def\aPTiiirulepartc{\setbox3=\box\ProofTree
\gobblebrace{\bgroup\aftergroup\aPTiiirulepartd}}

\def\aPTiiirulepartd{\setbox2=\box\ProofTree
\dimen4=\ProofTreea \dimen5=\ProofTreeb \dimen6=\ProofTreec
\dimen0=\wd1
\advance\dimen0 -\dimen1
\advance\dimen0 -\dimen2
\advance\dimen0 \ProofTreespace
\advance\dimen0 \wd3
\advance\dimen0 \ProofTreespace
\advance\dimen0 \dimen4
\advance\dimen0 \dimen5
\advance\dimen0 \dimen6
\ifnum\wd7 <\dimen0
\dimen9=\dimen1
\advance\dimen9 \dimen2
\global\ProofTreea=\dimen9
\ProofTreeb=\dimen0
\advance\ProofTreeb -\wd7
\divide\ProofTreeb 100
\multiply\ProofTreeb \ProofTreebias
\global\ProofTreeb=\ProofTreeb
\setbox7=\hbox to\dimen0{\hskip\ProofTreeb\box7\hfil}\else \advance\dimen0 -\wd7
\divide\dimen0 100 \multiply\dimen0 \ProofTreebias
\dimen9=\dimen1
\advance\dimen9 \dimen2
\advance\dimen9 \dimen0
\global\ProofTreea=\dimen9
\dimen0=\wd7
\global\ProofTreeb=0pt
\fi
\ifnum\dimen9 <0
\dimen8=-\dimen9
\global\ProofTreea=0pt
\else
\dimen8=0pt
\fi
\global\ProofTreec=\wd8
\global\setbox\ProofTree=\vtop{\offinterlineskip\halign
{\hskip\dimen8 ##\cr
\hskip\dimen9\copy7\hfil\cr
\ProofTreerulestrut\hskip\dimen9\hskip-\ProofTreeovershoot\advance\dimen0 2\ProofTreeovershoot
\vrule width\dimen0 depth0pt height 0.4pt \hskip\ProofTreeannotspace\box0\hskip-\ProofTreeovershoot
\hfil\cr
\box1\hskip\ProofTreespace\box3\hskip\ProofTreespace\box2\hfil\cr}}\endgroup}




\def\tree{\gobblebrace{\bgroup\aftergroup\treepartb}}
\def\treepartb{\box\ProofTree
}

 \title{A  Proof System with Names for Modal Mu-calculus\footnote{To Dave who 
I first met in 1982 when we shared 
an office in Edinburgh where I learnt about denotational
semantics, least fixpoints and Edinburgh pubs.}}
\author{
    Colin Stirling
    \institute{School of Informatics\\ University of Edinburgh}\\
    \email{cps@inf.ed.ac.uk}}
\def\titlerunning{A proof system with names for modal mu-calculus}
\def\authorrunning{Colin Stirling}
\begin{document}

\maketitle





\begin{abstract}
Fixpoints are an important ingredient in semantics, abstract interpretation
and program logics. Their addition to a logic
can add considerable expressive power.
One general  issue is how to define 
proof systems for such logics. Here we examine proof systems for
modal logic with fixpoints \cite{Koz83}. We  present a  tableau proof system
for checking validity of formulas 
which uses names to keep track of unfoldings of fixpoint variables 
as devised in  \cite{Ju09}.
\end{abstract}

\section{Introduction}
Fixpoints are an important ingredient in semantics, abstract interpretation
and program logics. Their addition to a logic
can add considerable expressive power.
One general  issue is how to define 
proof systems for such logics. 
In this paper we consider modal mu-calculus, modal logic with fipoints,
see \cite{BS07} for a survey. 
Dave Schmidt  has used this logic to understand data flow analyis
\cite{Sch}.
Here our interest is more with developing \w{proof systems} for the logic. 

In this paper we describe a tableau proof system which checks when
a modal mu-calculus formula is valid. The system 
uses names to keep track of unfoldings of fixpoint variables. 
This idea originated in \cite{StW9} in the context of  model checking. 
For satisfiability
checking it  was used in \cite{LS01} for LTL and CTL and then for
modal mu-calculus  in \cite{Ju09}. 

In Section~\ref{secmodal} we describe the syntax and semantics of 
modal mu-calculus and in Section~\ref{secproof} we briefly examine 
approaches to  devising proof systems for this logic. The tableau proof
system based on names for checking  valid formulas is then presented in
Section~\ref{secnames} and shown to be both sound and complete. 


\section{Modal Mu-calculus}
\label{secmodal}
Let  be an (infinite) set of \w{variable names}, typically
indicated by ; let  be a set of \w{atomic
propositions}, typically indicated by ; and let  be a set
of \w{actions}, typically indicated by . The set of modal
mu-calculus formulas  (with respect to ) is as 
follows.


In  
every free occurrence of  in  occurs positively, that is  within
the scope of an even number of negations. 
If a formula is written as , it is to be understood that the
subsequent writing of  means  with  substituted for all
free occurrences of . 

The positivity requirement on the fixpoint operator is a syntactic
means of ensuring that  denotes a functional monotonic in ,
and so has unique minimal and maximal fixed points. It is usually  
more convenient to
introduce derived dual operators, and work in
positive form:  means ,   means 
and  means . 
A formula is in \w{positive form} if it is
written with the derived operators so that  only occurs applied to
atomic propositions. It is in \w{positive normal form} if in addition
all bound variables are distinct. Any closed formula can be put into positive 
normal form. It is also useful to have derived propositional constants
 (for ) and  (for ). 

A modal mu-calculus \w{structure}  (over ) is a labelled
transition system, namely a set  of states and a family of transition
relations  for  ,  
together with an interpretation  for
the atomic propositions.  As usual we write  for 
. 

Given a structure  and an interpretation  
of the variables, the set  of states satisfying a formula
 is defined as follows:

where  is the valuation which maps  to  and otherwise
agrees with . If we are working in positive normal form, we may
add definitions for the derived operators by duality (and for the propositional
constants). 


If we take the usual lattice structure on , given by set inclusion, and 
if  is a monotonic function then by the Knaster-Tarski theorem  has fixed 
points, and indeed has a unique maximal and a unique minimal fixed point.
The maximal fixed point is the union of
\w{post-fixed points}, , and the minimal fixed point 
is the intersection of \w{pre-fixed points}, . These determine the meanings of  and  in .
 
Moreover, the standard theory of fixpoints tells 
that if  is a monotone function on a
lattice, we can construct its minimal fixed point  by applying
 repeatedly on the least element  of the lattice
to form an increasing
chain,  whose limit is the least fixed point.
Similarly,  the maximal fixed point is constructed
by applying  repeatedly on the largest element
to form a decreasing chain, whose limit is the maximal  fixed point.
The stages of these iterations  can be introduced syntactically as 
 and  for ordinals 
whose meanings are  as follows when   is a limit ordinal.

 

\begin{defin} The formula  of  is \w{valid} if for all
structures  and interpretations , .
The formula  is \w{satisfiable} if there is a structure
 and an interpretation  such that .
\end{defin}

\ni
As is standard  indicates that  is valid and 
 is written as  , dropping the
index  wherever possible. 

The relationship between stages of iteration and
the fixpoints is formally described.

\begin{fact}
\label{fact1}   
\begin{enumerate}
\item  iff   for all 
ordinals .
\item  iff  for some
ordinal .  
\end{enumerate}
\end{fact}
So for a minimal fixpoint formula 
, if  satisfies the 
fixpoint, it satisfies some iterate, say the
th so that
. 
Now if we \w{unfold} this formula once, we get
. Therefore, 
the fact that  satisfies the fixpoint
depends, via , on the fact that other states in 
satisfy the fixpoint
\emph{at smaller iterates than  does}. So if one follows a chain
of dependencies, the chain terminates. 
Therefore,  means
`finite looping'.
On the other hand, for a maximal fixpoint , there is no such
decreasing chain:  iff 
 for every iterate
 iff  for every iterate

iff , and so we may loop
for ever. 

We impose a further syntactic constraint on formulas. In the following we write
 for  or  when we are indifferent to 
which  fixpoint.  


\begin{defin}
The formula  of  is \w{guarded} if for any subformula
 of , every occurrence of  in  is within 
the scope of a modal operator. 
\end{defin}

\ni
The following is standard; see \cite{Koz83,NiWa96,Wal00}.

\begin{fact} 
\label{guarded} Every formula of   is equivalent to a guarded
formula.
\end{fact}


\section{Proof Systems}
\label{secproof}

There has been a variety of proof systems for . Kozen presented
an equational deductive system which is equivalent to the  
Henkin  axiom system  of Figure~\ref{axiom} that extends 
the standard modal logic  \cite{Koz83}: here 
means . 
\begin{figure}



\caption{Kozen's axiomatisation of }
\label{axiom}
\end{figure}
There is an extra axiom for a  least fixed point that its ``unfolding''
implies it; and  Park's fixed point induction rule 
which says that  is indeed the least pre-fixed point.
The duals of this axiom and rule for greatest fixed points are;
 and if
 then . Despite the naturalness of this axiomatisation, Kozen was
unable to show that it was complete in \cite{Koz83}. 
Instead, he proved it 
complete for a subset of , the 
aconjunctive fragment. Subsequently, he provided a complete infinitary
deductive system for the whole of   by adding the following 
infinitary rule \cite{Koz86}.


Soundness of this rule depends on the \w{finite model property} which is
that  a formula
is satisfiable if, and only if,  it is satisfiable in a finite model. 
It is possible to devise an infinite structure (with infinite branching)
with  state
 such that, for instance,  and 
 for all .  
 
Later Walukiewicz established that indeed  Kozen's axiomatisation 
in Figure~\ref{axiom} is 
complete for the whole language. The proof appeals to 
a normal form, \w{disjunctive normal form}, 
inspired by automata and semantic tableaux 
and also uses  (a slightly weakened version of)
aconjunctivity \cite{Wal00}. First, it is shown that 
every formula is \w{provably} equivalent to a guarded formula
(thereby strengthening Fact~\ref{guarded}).
For any  unsatisfiable weakly aconjunctive or disjunctive normal 
form formula  there is a proof of . 
Then the central  argument 
proceeds by induction on formulas  showing that every guarded
formula provably implies a semantically equivalent disjunctive normal form
formula. 
This unusual proof method for showing completeness
can be contrasted with the more  standard technique of building a model
out of consistent sets of formulas (which has remained elusive
for ). 

Given a valid formula such as 
it is not so easy to provide a proof of it within Kozen's  axiom  system. 
This suggests that one may also seek natural deduction,  sequent or
tableau  style
proof  systems.  A  \w{goal directed} 
proof system is presented in Figure~\ref{fig2}.
\begin{figure}




\caption{Goal directed proof rules} 
\label{fig2}
\end{figure}
A sequent of this proof system is a set of formulas understood
disjunctively; we assume  indicate a \w{set}
of formulas and   is the set
; clearly,  and  are then valid. The rules remove  between formulas and branch
at an . Some notation in the modal rule: 
is the set of formulas .
In its application the set  can be empty.
Fixpoint formulas are unfolded. The idea is to build
a proof for a starting guarded formula  in positive normal form.
Such systems have been presented before. For instance,
in \cite{NiWa96} there is a dual system
for showing that a formula is unsatisfiable.
There are also systems, such as in \cite{DHL06,JKS08,Stu08},  
where the rules are
inverted. 

The main problem with the rules in Figure~\ref{fig2} is
that they lead to  infinite depth proof trees  as in
Figure~\ref{fig3}.  It is unclear when such a tree is in
fact a proof; for instance, there are such trees
for invalid formulas such as 
.  
\begin{figure}

\caption{A never ending proof tree} 
\label{fig3}
\end{figure}
One solution is to replace  infinite depth  proofs with proofs of infinite
width by adopting a variant
of  Kozen's infinitary rule. 
In \cite{JKS08, Stu08} the authors add 
an infinitary rule as follows (again whose soundness
depends on the finite model property).  


 

Every branch in a successful  proof tree thereby is  finite and finishes
at a sequent  or . For
instance, Figure~\ref{fig30} illustrates part of the proof tree
for .
\begin{figure}


\caption{An infinitely wide proof tree} 
\label{fig30}
\end{figure}

Alternatively, one can accept infinite depth proofs but find a finite 
way of generating or recognising  them. 
Extra criteria for deciding when an infinite tree labelled with sets
of formulas is indeed a proof are necessary. In particular, we need to guarantee
(see comments after Fact~\ref{fact1}) that in any infinite branch
a greatest    fixpoint 
formula is  unfolded infinitely often. 
In \cite{NiWa96} the authors  add the  extra 
mechanism of an   infinite  game that plays
over an  infinite tree. 
In \cite{DHL06} 
for linear time mu-calculus the extra mechanism is a nondeterministic parity
automaton that runs over the tree. 

What we shall do is to show that indeed there is a means for obtaining a 
finite proof using names. This mechanism was introduced in \cite{Ju09}
as a  tableau decision procedure for showing
satisfiability of  formulas. Here we reformulate it as a proof system
for showing when a formula is valid.

\section{Proof System with Names}
\label{secnames}
Our aim is now to build a proof system such that a formula  
has a finite proof tree
if, and only if, it is valid. The proof system  includes 
some auxiliary naming notation.
Assume a starting guarded closed formula  in positive
normal form. 

\begin{defin}
If in  the subformula  is
a proper subformula of  then  is \w{more outermost} 
than 
(in ).  Variable  is a 
\w{variable} in  if  
is a subformula of  and it is a \w{-variable} if 
is .
\end{defin} 

We assume a fixed linear ordering  
on all the distinct  variables in  such that if 
is more outermost than  then . 
For instance, in a linear ordering for variables in  
 
the  -variable  must occur before  whereas  can 
occur before or after it. 
For each -variable  in  we assume a finite set 

of \w{names} for  where  is the length of .

The proof system has sequents of the form  where
 is a sequence of distinct names for -variables and
each element of  has the form   
where  is a formula (belonging to the closure of )  
and  is a  subsequence of . The initial sequent is
 with the empty sequence of names.
If  is a sequence of names then ,
, is the element . 

\begin{defin}
Assume   is the fixed  linear ordering  of
variables  in   and  are sequences of names
of these variables where   are subsequences of .
\begin{enumerate}
\item We write  if for some , 
(1)  and  are names of the same variable
and  occurs before  in , and (2) 
for all .
\item  The sequence  is the subsequence of
 that omits all names of the variables .
\item We write   if  or there is a -variable
 such that  is a proper prefix of .
\end{enumerate}
\end{defin}


The proof rules in Figure~\ref{fig4} 
are an elaboration of those in Figure~\ref{fig2}.
Again, sets of formulas are to be understood disjunctively; now formulas also
carry  sequences of names reflecting the history of 
unfoldings of greatest fixpoints.
\begin{figure}




\caption{Goal directed proof rules with names} 
\label{fig4}
\end{figure}
The  and   rules are similar to before; the names index
is passed to the components. In the modal rule
we assume that 
is the set of formulas ;
in an  application  can be empty. Some further notation:
 in the conclusion of the modal rule (and in other rules)
is the subsequence of names in   that still occur in  and ;
names that occurred only in formulas in the premises  are removed from
. Fixpoint formulas are unfolded; names in  that belong to variables that
are more innermost than  are removed from  (and from  if they do not
occur in ). In the case of a greatest  fixpoint a new name for  is
also added to the name sequence (both in  and ). 
Importantly, there are also two key structural rules in Figure~\ref{fig5}.
\begin{figure}






\caption{Structural  proof rules} 
\label{fig5}
\end{figure}
If  and  both occur in  a sequent  then
either  or .  In the case of the 
rule Reset the names 
are names for the same variable   and  could be the same as .
When applying the proof rules of Figures~\ref{fig4} and \ref{fig5} we assume
that the structural rules have  priority over the logical rules.
 

\begin{defin}
\label{leaf}
A node  of a tree labelled with the sequent
 is a \emph{leaf} if
there is a node  above it, its \emph{companion}, 
labelled with the same sequent
; this leaf is \emph{successful} if between nodes
 and  there is an application  of the rule Reset for some 
such that for any node  labelled with  between
and including  and  the name  occurs in .
\end{defin}


\begin{defin}
A \emph{proof
tree} for  is a tree where
\begin{enumerate}
\item the root is labelled ,
\item any  other node is labelled with a  sequent that is the result of an 
application of a rule in  Figure~\ref{fig4} or \ref{fig5} to the sequent
at its parent node, 
\item each leaf is labelled with a sequent
that is  an instance of an  axiom in Figure~\ref{fig4}
or is successful according to  the repeat condition. 
\end{enumerate}
\end{defin}

\ni
A tree is not a proof if it has a leaf labelled with a
sequent of the form 

where  for all  or has a leaf  that is a repeat
because of its companion    and for every application of a rule 
Reset between  and  there is a node  between (and including) 
 and  labelled  such that  does not occur in . 
Given a formula  there are at most  different subsets
of subformulas of  where  is the size of .
The number of greatest fixpoints in  is also bounded by .
The number of different possible sequents derivable from 
is bounded by , see \cite{Ju09}, which is therefore
also a bound on the depth of a tree.  Moreover, the width of  a tree
is bounded by .  The only rule that allows choice is the modal rule;
the number of choices is again bounded by . 
Therefore, the  number of possible trees with root  is 
bounded in terms of . 

\begin{fact}
\label{finitefact}
For any closed guarded  there are only boundedly  many 
trees
for  and each such tree has boundedly many nodes (where the bounds
are functions  of ).
\end{fact}
 
\begin{figure}



\caption{A proof tree} 
\label{fig6}
\end{figure}
In Figure~\ref{fig6} there is a proof tree for the valid formula
 where we employ the abbreviations
that  is this formula and  is it's subformula 
.
It is a  proof tree because of the repeat sequent 
 with an application of Repeat inbetween
where  is a name that occurs in each sequent throughout. 
The proof tree for a  more complex  valid formula  is 
illustrated in 
\begin{figure}







\caption{A proof tree} 
\label{fig7}
\end{figure}
Figure~\ref{fig7}. We encourage the reader to check that indeed
it is a  proof tree.

At the  cost of increasing the size of trees, 
we can add further  conditions on  when a node  counts
as a leaf in   Definition~\ref{leaf}: for instance, an extra
requirement is that  its sequent
is  the result of an 
application of the modal rule. 

\begin{theorem}
For any closed guarded ,  iff there is a proof tree
for  . 
\end{theorem}
\begin{proof}
Assume  but there is not a proof tree for .
We show that we can build a countermodel to ; a structure
 and  a state  of  such that
. 
Given a sequent  it is valid if 
.
The initial sequent  is valid.
We now build a tree using the proof rules where each node
is labelled with a valid sequent (or, as we shall see, a countermodel)
and except for the root node
is the result of an application of a  proof rule.
Assume we have built part of the tree and consider a current leaf
labelled with a valid sequent; if it is not an axiom or a repeat
then the tree can be extended with further valid sequents. This is clear
if we can apply a structural rule of Figure~\ref{fig5} which has priority
and it is also clear for ,  and the fixpoint
rules of Figure~\ref{fig4};
in all these cases if the premise sequent is valid 
then so are the conclusion sequents. 
We next come to the modal rule. We assume it is only applied if no other 
rule applies. Then a leaf of the current tree is labelled with a valid
sequent of the form

where each  is nonempty,  when 
and we assume it is not an axiom, 
so  for all . A  possible conclusion 
of an application of  the modal rule has the  form  when   or 
when  is different from each . 
With our tree we allow \w{all} such possible applications.
For each such application if the sequent is not valid we let the node be 
a leaf and we associate a countermodel to it: that is, a structure
 and a state  such that
 or a structure  and  a state 
such that . If all
possible applications of the rule are invalid, including the case
when  in , then we obtain a contradiction
by  constructing  a countermodel to the valid premise
 as follows. For  we take the disjoint
union of each   and of each  together with a new state .
For each  such that  assume there
is not  a transition of the form . Otherwise,
we let  of  and 
of . 
Finally, we assume  and 
for each .  Clearly, by construction,  fails to satisfy each  formula
in . Any node of the tree
labelled with a sequent of the form   is called a \emph{modal}
node. Therefore, there is at least one child node labelled with a valid
sequent of a modal node. For each such child we continue to extend the tree.
The tree building  eventually stops when nodes are leaves either because
they are children of a modal node labelled with an invalid sequent or
nodes 
labelled with an axiom or a repeat node.  In the last case we assume that we
restrict  repeat nodes to be children  of modal nodes.  
All nodes of the tree except for some successors of modal
nodes are labelled with valid sequents. 
However, by assumption there is not a proof tree for .
We now prune the tree. Starting top down, at any node where  is applied
we choose one of the successor nodes which fails to produce a
proof tree; we discard the subtree
of  the other successor.
The result is a finite tree
where the  only branching is at modal nodes.
All leaves are either unsuccessful repeats or children of modal nodes
labelled with invalid sequents (and with associated countermodels). 
From this tree we build a countermodel
to . We identify as states any region of the tree starting at the
root or at a child of a modal node labelled with a valid sequent down to,
and including, the next modal node. In the case of a leaf that is  a 
repeat we assume that there is a backward edge to its companion node
above. If a state  finishes at
the modal node labelled with the sequent  then 
for each  such that  assume there
is not  a transition of the form . Otherwise, for each
child that is labelled with an invalid sequent 
we let  of the countermodel
 or  
of the countermodel . For any child labelled 
with valid sequent  when   whose associated state is
 we assume a transition 
or any child  whose associated state is 
we assume a transition : the associated state of a repeating
leaf is that of its companion (the target of the backedge).  
Finally, we assume  and 
for each . We say that  if  belongs to 
some sequent in the region associated with . The proof is completed by
showing that if  then  in the countermodel . 
Assume to the contrary that for some  and ,  and
.
Clearly, then  is not a literal, an atomic formula or the negation of an 
atomic formula. For a formula  we can follow it through the tree,
passing between states and jumping from a leaf to its companion. If  then by construction  or . If  then we can choose
between   and . If 
then we look at the modal node associated with : if there is not
a  such tht  or only countermodels under -transitions
to  then . Otherwise, we can choose a
 such that  and . Similarly, for .
If  then . 
Therefore, if we follow  for 
we obtain a finite or infinite
sequence 
where , , there is a state transition
when  is a modal formula and for all , .
Clearly, the sequence cannot be finite  ending at a literal or a modal formula.
So, the sequence must be infinite. We show that the outermost fixpoint unfolded
infinitely often is  a least fixpoint which is a contradiction by
Fact~\ref{fact1}. For suppose it is a greatest fixpoint :
then the sequence of formulas  must have a subsequence
of the form 
where Reset is applied and  is defined throughout: that is, 
the sequence  must pass through  a successful
repeat. 



For soundness, assume that there is a proof tree
for  but . Therefore, there is
a proof tree with root labelled  all of whose leaves
are either labelled with axioms or are successful repeats. 
A sequent  is \emph{not}  valid if . 
First, if the premise of an application of a rule is not valid then
so is a conclusion.  This is clear for the structural rules,  for the
 rule and the fixpoint rules. In the case of , 
if the premise sequent is not valid then one of the successor
sequents is not valid. In the case of the modal rule, if
 then by standard modal reasoning
; so, if the premise sequent
is not valid then neither is the conclusion in an application of the modal rule.
Next we refine the argument by adding ordinal information. If  then using Fact~\ref{fact1} there is a least ordinal ,
a countermodel  and  a state  of  such that
. To do this, we slightly change the rules
(as in fact used in Figures~\ref{fig6} and \ref{fig7}) by letting variables 
abbreviate the fixpoint subformulas of .


So, formulas can contain variables. 
We  associate ordinals
with sequents by adding ordinals to names. Assume an invalid
sequent  where .
We extend  to pairs 
where each  is an ordinal: if 
and  contains a name for  then the meaning of 
in  is  when  is 
and  where  is the 
last name for  in . We assume that the invalid sequent
 remains invalid when greatest
fixpoint subformulas are so interpreted.
We maintain the following invariant in an ordinal sequence:
if ,  and 
 name the same variable  such that there is a formula
 such that  both occur in  then 
. Moreover, we assume lexicographic ordering on 
ordinal sequences: if 
and  then
 if for some ,  and for 
all , .  We are interested
in a least ordinal interpretation which makes   
invalid. Moreover, if a proof rule is applied to such a sequent
then a conclusion is invalid under the ordinal interpretation;
we minimise the ordinal sequence which makes the conclusion invalid with 
respect to the lexicographical ordering.  
This is clear for the , Thin, , modal, 
and least fixpoint variable  
(where we lose ordinals for any inner  such that ) rules.  
In the case of the maximal fixpoint variable  rule with premise 
 if there is no name for  in  then we know that
there is a least  such that 

is invalid where  is a new name for . Otherwise,  there is a name
for  in ; suppose the last one is  with ordinal .
Since the fixpoint is unfolded we know that we can decrease the meaning
of  by at least one; so for the invalid   conclusion 

.  Finally, we turn to the Reset rule with
premise  where  does not occur in 
and  name the same variable.
In   we have  and later  (in any order). By the invariant property
it follows that  for each  and that 
 of  has meaning  for 

(as  may contain further names for ). Let . Clearly, we can
replace  in  with , remove all the names
 such that 
is invalid.  Given a proof tree for  we now follow a branch
of invalid sequents down the tree minimising their ordinal
interpretations of variables. Clearly, we cannot reach a leaf  or  as these sequents are valid.
Moreover, we cannot reach a successful repeat  with
an application of Reset in between when   is in each sequent 
throughout.
Consider the companion node with ordinal interpretation 

and the leaf node with interpretation : it follows that  as at least the entry for 
was reduced by the Reset rule which is a contradiction. 
\end{proof}

\section{Conclusion}

We have presented a sound and complete proof system  for checking validity
of modal mu-calculus formulas. However, it relies on auxiliary notation for
names that keep track of  unfoldings of greatest fixpoints. 

We  tried,  but failed,  to
see if this  method is able to underpin a different proof of completeness
of Kozen's axiomatisation  than  Walukiewicz's 
proof by induction.  

An alternative framework for deciding satisfiability and validity for
 is automata-theoretic  \cite{StE89}. Using two way automata
there is also a decision procedure for  satisfiability and validity
of formulas when past  
modal operators are  included
\cite{V98}. 
Neither a sound and complete 
axiom system nor a sound and complete tableau  proof system
have been developed for this extended fixpoint  logic (which fails 
the finite model property). 
 
\bibliographystyle{eptcs}


\begin{thebibliography}{99}
\providecommand{\urlalt}[2]{\href{#1}{#2}} 
\providecommand{\doi}[1]{doi:\urlalt{http://dx.doi.org/#1}{#1}}

\bibitem{BS07} J. Bradfield and C. Stirling, Modal mu-calculi. In
\emph{Handbook of Modal Logic} ed. P. Blackburn, J. van Benthem and
F. Wolter, 721--756, Elsevier (2007). 
\doi{10.1016/S1570-2464(07)80015-2}
\bibitem{DHL06} C. Dax, M. Hofmann and M. Lange, A proof system for
the linear time -calculus. In Procs FSTTCS 2006 LNCS {\bf 4337}
274--285 (2006). 
\doi{10.1007/11944836\_26}
\bibitem{JKS08} G. J\"{a}ger, M. Kretz and T. Studer,
Canonical completeness of infinitary . \emph{The Journal of
Logic and Algebraic Programming} {\bf 76} 270--292 (2008).
\doi{10.1016/j.jlap.2008.02.0005}
\bibitem{Koz83} D. Kozen, Results on the propositional -calculus.
 \emph{Theor.~Comput.~Sci.} {\bf 27} 333--354 (1983). 
\doi{10.1016/0304-3975(82)90125-6}
\bibitem{Koz86} D. Kozen, A finite model theorem for the propositional
-calculus. \emph{Studia Logica} {\bf 47} 233--241 (1986).
\doi{10.1007/BF00370554}
\bibitem{LS01} M. Lange and C. Stirling, Focus games for satisfiability
and completeness of temporal logic. In Procs LICS 2001, 357--365 (2001).
\doi{10.1109/LICS.2001.932511}
\bibitem{Ju09} N. Jungteerapanich, A tableau system for the modal 
-calculus. In Procs TABLEAUX 2009, LNAI {\bf 5607} 220--234 (2009).
\doi{10.1007/978-3-642-02716-1\_17}
\bibitem{NiWa96} D. Niwinski and I. Walukiewicz, Games for the -calculus.
 \emph{Theor.~Comput.~Sci.} {\bf 163} 99--116 (1996).
\doi{10.1016/0304-3975(95)00136-0}
\bibitem{Sch} D. Schmidt, Data flow analysis is model checking of abstract 
interpretations. In Procs. POPL 1998 38--48 (1998). 
\doi{10.1145/268946.268950}
\bibitem{StW9} C. Stirling and D. Walker, Local model checking in the modal
mu-calculus. \emph{Theor.~Comput.~Sci.} {\bf 89} 161--177 (1991).
\doi{10.1016/0304-3975(90)90110-4}
\bibitem{StE89} R. Streett and E. Emerson, An automata theoretic 
decision procedure for the propositional mu-calculus. \emph{Information
 and Computation}
{\bf 81} 249--264 (1989).  
\doi{10.1016/0890-5401(89)90031-X}
\bibitem{Stu08} T. Studer, On the proof theory of the modal mu-calculus.
\emph{Studia Logica} {\bf 89} 343--363 (2008). 
\doi{10.1007/s11225-008-9133-6}
\bibitem{V98} M. Vardi, Reasoning about the past with two-way automata.
 In Procs ICALP 98, LNCS {\bf 1443} 628--641 (1998).
\doi{10.1007/BFb0055090}
\bibitem{Wal00} I. Walukiewicz, Completeness of Kozen's axiomatisation of 
the propositional -calculus. \emph{Information and Computation} 
{\bf 157} 142--182 (2000).
\doi{10.1006/inco.1999.2836}
\end{thebibliography}
\end{document}
