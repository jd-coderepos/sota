\documentclass{CSML}

\def\dOi{11(3:20)2015}
\lmcsheading {\dOi}
{1--24}
{}
{}
{Jul.~\phantom01, 2014}
{Sep.~22, 2015}
{}

\ACMCCS{[{\bf Theory of computation}]: Models of Computation; Formal
  languages and automata theory---Automata over infinite objects} 



\usepackage{hyperref}
\usepackage{gastex}
\usepackage{color}
\usepackage[c]{esvect} 

\theoremstyle{plain}\newtheorem{theorem}[thm]{Theorem}
\theoremstyle{plain}\newtheorem{corollary}[thm]{Corollary}
\theoremstyle{plain}\newtheorem{example}[thm]{Example}
\theoremstyle{plain}\newtheorem{lemma}[thm]{Lemma}
\theoremstyle{plain}\newtheorem{remark}[thm]{Remark}
\def\eg{{\em e.g.}}
\def\cf{{\em cf.}}




\newcommand{\problemx}[3]{
\vspace{3mm}
\par\noindent{\bf#1}\par\nobreak\vskip.2\baselineskip
\begingroup\clubpenalty10000\widowpenalty10000
\setbox0\hbox{\bf INPUT: }\setbox1\hbox{\bf QUESTION: }
\dimen0=\wd0\ifnum\wd1>\dimen0\dimen0=\wd1\fi
\vskip-\parskip\noindent
\hbox to\dimen0{\box0\hfil}\hangindent\dimen0\hangafter1\ignorespaces#2\par
\vskip-\parskip\noindent
\hbox to\dimen0{\box1\hfil}\hangindent\dimen0\hangafter1\ignorespaces#3\par
\endgroup\vspace{3mm}
}



\newcommand{\Z}{\mathbb{Z}}
\newcommand{\ZZ}{\ensuremath{\mathbb{Z}}\xspace}
\newcommand{\NN}{\ensuremath{\mathbb{N}}\xspace}
\newcommand{\N}{\mathbb{N}}
\newcommand{\RP}{\mathbb{R}_{\geq 0}}
\newcommand{\R}{\mathbb{R}}

\newcommand{\net}{\mathcal{N}}
\newcommand{\B}{\mathcal{B}}
\newcommand{\mtl}{MTL }

\newcommand{\finally}{\mathsf{F}}

\newcommand{\Aa}{\ensuremath{\mathcal{A}}\xspace}

\newcommand{\reg}{\mathsf{reg}}
\newcommand{\locs}{\mathcal{L}}
\newcommand{\edges}{E}
\newcommand{\edge}{e}
\newcommand{\wt}{\mathsf{wt}}
\newcommand{\lab}{\mathsf{label}}
\newcommand{\clocks}{\mathcal{X}}
\newcommand{\clock}{x}
\newcommand{\inc}{\mathsf{in}}
\newcommand{\out}{\mathsf{out}}
\newcommand{\edgecost}{\mathsf{ewt}}
\newcommand{\loccost}{\mathsf{lwt}}
\newcommand{\const}{\mathsf{CONST}}

\newcommand{\loc}{\mathit{l}}
\newcommand{\cmax}{\mathsf{cmax}}
\newcommand{\abs}{\mathsf{abs}}
\newcommand{\TW}{T\Sigma^+}
\newcommand{\supp}{\mathsf{supp}}
\usepackage{todonotes}
\newcommand{\true}{\mathtt{true}}
\newcommand{\false}{\mathtt{false}}

\newcommand{\U}{\mathsf{U}}
\newcommand{\X}{\mathsf{X}}
\newcommand{\cfg}{\gamma}
\newcommand{\sep}{\text{ }|\text{ }} 

\renewcommand{\succ}{\mathsf{Succ}}
\newcommand{\minv}{\mathsf{minval}}
\newcommand{\mins}{\mathsf{minstep}}
\newcommand{\tsucc}{\mathsf{TSucc}}
\newcommand{\reach}{\mathsf{Reach}}
\newcommand{\AB}{\mathcal{A}\text{-}\mathcal{B}}
\renewcommand{\next}{\mathsf{next}}
\renewcommand{\frac}{\mathsf{frac}}
\renewcommand{\int}{\mathsf{int}}
\newcommand{\uc}[1]{\uparrow\hspace{-1.1mm}{#1}}
\newcommand{\ucr}[2]{\uparrow^{#1}\hspace{-1.1mm}{#2}}
\newcommand{\val}{\mathsf{Val}}
\newcommand{\lin}{\mathsf{Lin}}
\newcommand*\ie{\textit{i.e.}}


\newcommand{\enc}{\mathsf{enc}} 



\newcommand{\glob}{\mathsf{G}}


\newcommand{\A}{\mathcal{A}}
\newcommand{\tcm}{\mathcal{M}}
\newcommand{\inst}{\mathcal{I}}
\newcommand{\vmax}{\mathsf{vmax}}
\newcommand{\cm}{\mathcal{C}}
\newcommand{\state}{\mathsf{state}}
\newcommand{\Op}{\mathsf{Op}}
\newcommand{\op}{\mathsf{op}}
\newcommand{\last}{\mathsf{last}}

\newcommand{\gs}{\mathcal{G}} \newcommand{\hs}{\mathcal{H}} 


\makeatletter
\newcommand*{\defeq}{\mathrel{\rlap{\raisebox{0.3ex}{}}\raisebox{-0.3ex}{}}=}
\makeatother

\makeatletter
\newcommand*{\ndefeq}{\mathrel{\rlap{\raisebox{0.3ex}{}}\raisebox{-0.3ex}{}\rlap{\raisebox{0.3ex}{}}
                     \raisebox{-0.3ex}{}}
                     =}
\makeatother


\newcommand{\intransA}{\hspace{-1.7mm}\in\transA}
\newcommand{\transA}{\Rightarrow_{\hspace{-.8mm}\A}}
\newcommand{\transAB}{\Rightarrow_{\hspace{-.8mm}\A\B}}



\begin{document}

	\title[Timed Automata with Unbounded Discrete Data Structures]{Verification for Timed Automata extended with Unbounded Discrete Data Structures}

\author[K.~Quaas]{Karin Quaas}	\address{Universit\"at Leipzig, Germany}	\email{quaas@informatik.uni-leipzig.de}
\thanks{The author is supported by DFG, project QU 316/1-1.}	









\keywords{Timed automata, real-time systems, counter systems, pushdown automata, Metric Temporal Logic}

\titlecomment{{\lsuper*}An extended abstract was published in \emph{CONCUR 2014}.}




\begin{abstract}
  \noindent We study decidability of verification problems for timed automata extended with unbounded discrete data structures. 
	More detailed, we extend timed automata with a pushdown stack. 
	In this way, we obtain a strong model that may for instance be used to model real-time programs with procedure calls. 
	It is long known that the reachability problem for this model is decidable. 
	The goal of this paper is to identify subclasses of timed pushdown automata for which the language inclusion problem and related problems are decidable.
\end{abstract}

\maketitle

\section{Introduction}
\emph{Timed automata} were introduced by Alur and Dill~\cite{AD94}, and have since then become a popular standard formalism to model real-time systems. 
An undeniable reason for the success of timed automata is the  decidability of the \emph{language emptiness problem}~\cite{AD94}.
A major drawback of timed automata is the undecidability~\cite{AD94} of the \emph{language inclusion problem}: given two timed automata  and , does  hold?
The undecidability of this problem prohibits the usage of automated verification algorithms for analysing timed automata, where  can be seen as the specification that is supposed to be satisfied by the system modelled by . 
However, if  is restricted to have at most one clock, then the language inclusion problem over finite timed words is decidable (albeit with non-primitive recursive complexity)~\cite{DBLP:conf/lics/OuaknineW04}.
As other important milestones in the success story of timed automata we would like to mention the decidability of bisimulation~\cite{DBLP:conf/cav/Cerans92}, 
the decidability of the \emph{model checking problem} for timed automata and a timed extension of CTL~\cite{DBLP:conf/lics/HenzingerNSY92}, and, more recently,  the decidability of the model checking problem for timed automata and Metric Temporal Logic (MTL, for short) over finite timed words~\cite{DBLP:conf/lics/OuaknineW05}.

Timed automata can express many interesting time-related properties, and even with the restriction to a single clock, they  allow one to model a large class of systems, including, for example, the internet protocol TCP~\cite{TCP}.  
If we want to reason about real-time programs with procedure calls, or about the number of events occurring in computations of real-time systems, we have to extend the model of timed automata with unbounded discrete data structures. In 1994, Bouajjani et al.~\cite{DBLP:conf/hybrid/BouajjaniER94} extended timed automata with discrete counters and a pushdown stack, and proved that the satisfiability of reachability properties for several subclasses of this model is decidable. 
Nine years later, it was shown that the binary reachability relation for \emph{timed pushdown systems} is decidable~\cite{DBLP:journals/tcs/Dang03}.  Decidability of the reachability problem was also proved for several classes of \emph{timed counter systems}~\cite{DBLP:journals/entcs/BouchyFS09}, mainly by simple extensions of the classical region-graph construction~\cite{AD94}. 
The language inclusion problem, however, is to the best of our knowledge only considered in~\cite{EmmiM06} for the class of timed pushdown systems. 
In~\cite{EmmiM06} it is stated that the language inclusion problem is decidable if  is a timed pushdown automaton, and  is a one-clock timed automaton. 
The proof is based on an extension of the proof for the decidability of the language inclusion problem for the case that  is a timed automaton without pushdown stack~\cite{DBLP:conf/lics/OuaknineW04}. 
Unfortunately, and as is well known, the proof in~\cite{EmmiM06} is not correct. 

In this paper, 
we prove that different to what is claimed in~\cite{EmmiM06}, the language inclusion problem for the case that  is a  pushdown timed automaton and  is a one-clock timed automaton is undecidable. This is even the case if  is a deterministic instance of a very restricted subclass of timed pushdown automata called \emph{timed visibly one-counter nets}.
On the other hand,
we prove that the language inclusion problem is decidable if  is a timed automaton and  is a timed automaton extended with a finite set of counters that can be incremented and decremented, and which we call \emph{timed counter nets}. As a special case, we obtain the decidability of the \emph{universality problem} for timed counter nets: given a timed automaton  with input alphabet , does  accept the set of all timed words over ?
Finally, we give the precise decidability border for the universality problem by proving that the universality problem is undecidable for the class of \emph{timed visibly one-counter automata}. 
We remark that all results apply to extensions of timed automata over \emph{finite} timed words. 



\section{Extensions of Timed Automata with Discrete Data Structure}
We use ,  and   to denote the integers, the non-negative integers and  the non-negative reals, respectively.



We use  to denote a finite alphabet. A {\em timed word} over  is a non-empty finite sequence  such that the sequence  of timestamps is non-decreasing.
We say that a timed word is \emph{strictly monotonic} if  for every . 
We use  to denote the set of finite timed words over .
A set  is called a {\em timed language}.


 
Let  be a finite set of {\em clock variables} ranging over .
We define {\em  clock constraints}  over  to be conjunctions of formulas of the form , where , , and . 
We may use  as abbreviation for . 
We use  to denote the set of all clock constraints over .
For the case that  is the empty set, we set . 
A \emph{clock valuation} is a mapping from  to . 
A clock valuation  satisfies a clock constraint , written , if  evaluates to true according to the values given by .
For  and , we define  to be  for each , and we define  by  if , and  otherwise. 


Let  be 
a finite stack alphabet. We use  to denote the set of finite words over , including the empty word denoted by . 
We define a finite set  of \emph{stack operations} by . 




A \emph{timed pushdown automaton} is a tuple
, where
\begin{itemize}
\item  is a finite set of \emph{locations},
\item  is the set of initial locations,
\item  is the set of accepting locations,
\item  is a finite set of edges. 
\end{itemize}	
A \emph{state} of  is a triple , where  is the current location, the clock valuation  represents the current values of the clocks, and  represents the current stack content, where the top-most symbol of the stack is the left-most 
symbol in the word , and the empty word  represents the empty stack. 
We use  to denote the set of all states of .
A timed pushdown automaton  induces a  transition relation  on  as follows:
, if, and only if, there exists some edge  
such that 
,
, 
and
(i) if  for some , 
then ;
(ii) if  for some ,
then  ;
(iii) if , then ;
(iv) if , then . 
A \emph{run} of  is a finite sequence 
 such that
 
for every . 
A run is called \emph{successful} if ,  for every , , and .
With a run we associate the timed word . 
The language accepted by the timed pushdown automaton , denoted by , is defined to be the set of timed words  for which there exists a successful run of  that  is associated with.




Next we define some subclasses of timed pushdown automata; see Figure 1 for a graphical overview.
We start with timed extensions of \emph{one-counter automata}~\cite{DLS-tcs10,DBLP:journals/iandc/JancarKMS04} and \emph{one-counter nets}~\cite{DBLP:conf/fsttcs/HofmanLMT13,DBLP:conf/concur/AbdullaC98}. 
A \emph{timed one-counter automaton} is a timed pushdown automaton where the stack alphabet is a singleton. 
By writing  and  we mean that we increment and decrement the counter, respectively, whereas  corresponds to a zero test.  
A \emph{timed one-counter net} is a timed one-counter automaton without zero tests, \ie, the  operation is not allowed.
We remark that for both classes, the execution of an edge of the form  is \emph{blocked} if the stack is empty. 


Next, we consider the timed extension of an interesting subclass of pushdown automata called \emph{visibly pushdown automata}~\cite{DBLP:conf/stoc/AlurM04}. 
A \emph{timed visibly pushdown automaton}
is a timed pushdown automaton for which the input alphabet  can be partitioned into three pairwise disjoint sets  of \emph{internal}, \emph{call}, and \emph{return} input symbols, respectively, and such that
for every edge 
the following conditions are satisfied:
\begin{itemize}
\item  if, and only if,  ,
\item , if, and only if,   for some ,
\item  if, and only if,   or  for some . 	
\end{itemize}
A \emph{timed visibly one-counter automaton} (timed visibly one-counter net, respectively) is a timed one-counter automaton (timed one-counter net, respectively) that is also a timed visibly pushdown automaton.
We say that a timed visibly one-counter net with no clocks is \emph{deterministic} if 
for all ,   with  we  have either  and , or
 and . 

Finally, we define the class of \emph{timed counter nets}, which generalizes timed one-counter nets, but is not a subclass of timed pushdown automata. 
A timed counter net of dimension  is a tuple 
, where 
 are the sets of locations, initial locations and accepting locations, respectively, and 
 is a finite set of edges. 
A state of a timed counter net is a triple , where ,  is a clock valuation, and  is a vector representing the current values of the counters. We define  if, and only if, there exists some edge  such that , , and , where  vector addition is defined pointwise.  Note that, similar to pop operations on an empty stack, transitions which result in the negative value of one of the counters are \emph{blocked}. 
The notions of \emph{runs}, \emph{successful runs}, \emph{associated timed words} and \emph{the language accepted by }, are defined analogously to the corresponding definitions for timed pushdown automata. 


\begin{figure}
\begin{center}
\begin{picture}(123,52)(0,-52)





\node[Nw=37.0,Nh=8.5,Nmr=0.0](n0)(68.0,-9.0){}
\put(52,-8){One-clock timed }
\put(51,-12){pushdown automata}

\node[Nw=41.0,Nh=8.5,Nmr=0.0](n1)(18.0,-9){}

\put(-2,-8){One-clock timed visibly}
\put(1,-12){pushdown automata}

\node[Nw=41.0,Nh=8.5,Nmr=0.0,linewidth=0.5](n2)(18.0,-26.0){}
\put(-2,-25){One-clock timed visibly}
\put(-.5,-29){one-counter automata}


\node[Nw=37.0,Nh=8.5,Nmr=0.0](n3)(68.0,-26.0){}
\put(53,-25){One-clock timed}
\put(49.5,-29){one-counter automata}

\node[Nw=41.0,Nh=8.5,Nmr=0.0,linewidth=0.5](n4)(18.0,-43.0){}
\put(-2,-42){One-clock timed visibly}
\put(3,-46){one-counter nets}


\node[Nw=37.0,Nh=8.5,Nmr=0.0,linewidth=0.5](n5)(68.0,-43.0){}
\put(53,-42){One-clock timed}
\put(53,-46){one-counter nets}


\node[Nw=31.0,Nh=8.5,Nmr=0.0,linewidth=0.5](n6)(113.0,-43.0){}
\put(100,-42){One-clock timed}
\put(103,-46){counter nets}


\node[linecolor=green,Nw=140,Nh=12,Nmr=0.0,linewidth=0.4](nets)(61,-43){}
\node[linecolor=yellow,Nw=96,Nh=32,Nmr=0.0,linewidth=0.4](onecounter)(41,-35){}
\node[linecolor=red,Nw=46,Nh=51,Nmr=0.0,linewidth=0.4](visibly)(18,-28){}










\drawedge(n4,n2){ }

\drawedge(n2,n1){ }

\drawedge(n1,n0){ }

\drawedge(n3,n0){ }

\drawedge(n5,n3){ }

\drawedge(n4,n5){ }

\drawedge(n2,n3){ }

\drawedge(n5,n6){ }

\node[Nw=3.5,Nh=4.0,Nmr=0.0](o)(4,-63.5){A}
\node[Nw=3.5,Nh=4.0,Nmr=0.0](p)(11,-63.5){B}
\drawedge(o,p){ }
\end{picture}

\caption{Extensions of one-clock timed automata with discrete data structures.
	Here, 
	\protect\phantom{} means that  is a subclass of .	The classes surrounded by the red frame are visibly pushdown automata, in which the input determines the stack operations. The yellow framed classes only allow one counter, and the green framed classes do not allow zero tests. 
The language emptiness problem is decidable for all classes,
but only the green framed classes have a decidable universality problem. The corresponding results for classes in boxes with bold line are new and presented in this paper.}
\label{figure_A}
\end{center}
\end{figure}


\section{Main Results}
In this section,
we present the main results of the paper.
We are interested in the language inclusion problem , where
 and  are extensions of timed automata with discrete data structures.
Recall that according to standard notation in the field of verification, in this problem formulation 
 is seen as the \emph{specification}, and  is the system that should satisfy this specification, \ie,  should be a \emph{model} of .  
	As a special case of this problem, we consider the universality problem, \ie, the question whether  for a given automaton .	
	In general, the two problems are undecidable  for timed pushdown automata. 
	This follows on the one hand  from the undecidability of the universality problem for timed automata~\cite{AD94}, 
	and on the other hand from the undecidability of the universality problem for pushdown automata. In fact, it is long known that the universality problem is  undecidable already for non-deterministic one-counter automata~\cite{DBLP:journals/jacm/Greibach69,DBLP:journals/mst/Ibarra79}.
	
		
	However, there are interesting decidability results for subclasses of timed pushdown automata:
	The language inclusion problem is decidable if  is a timed automaton, and  is a timed automaton with at most one clock~\cite{DBLP:conf/lics/OuaknineW04}. As a special case, the universality problem for timed automata is decidable if only one clock is used. 
	The language inclusion problem is also decidable if
	 is a one-counter net and  is a finite automaton, 
	and if  is a finite automaton and  is a one-counter net~\cite{DBLP:journals/jcss/JanarEM99}.
	The universality problem for non-deterministic one-counter nets has recently been proved to have non-primitive recursive complexity~\cite{DBLP:conf/rp/HofmanT14}.
Further we know that the universality and language inclusion problems are decidable if  and  are visibly pushdown automata~\cite{DBLP:conf/stoc/AlurM04}.
	

	Hence it is interesting to consider the two problems for the corresponding subclasses of timed pushdown automata.
	It turns out that the decidability status changes depending on whether the \emph{model} uses a stack (or, more detailed: a counter) or not.
	As a first main result we present:
	\begin{theorem}
		\label{theorem_main_lang_inc}
		The language inclusion problem is undecidable if  is a timed visibly one-counter net and  is a timed automaton, even if  is deterministic and has no clocks, and  uses at most one clock. 
	\end{theorem}
	We remark that this result corrects Theorem 2 in~\cite{EmmiM06}, in which it is claimed that the language inclusion problem for the case that  is a timed pushdown automaton and  is a one-clock timed automaton is decidable.
	The incorrectness of the proof of Theorem 2 in~\cite{EmmiM06}, respectively that of Theorem 1, which the proof for Theorem 2 builds upon,  was already asserted in~\cite{DBLP:conf/concur/ChadhaV07}. Since then the problem of whether language inclusion is decidable or not has been open. 
	
	In contrast to Theorem \ref{theorem_main_lang_inc}, 
	we have decidability for the following classes: 
\begin{theorem}
		\label{theorem_main_dec}
		The language inclusion problem is decidable with non-primitive recursive complexity if  is a timed automaton and  is a one-clock timed counter net.
	\end{theorem}
	As a special case of this result (and with the lower bound implied by the corresponding result for one-clock timed automata~\cite{DBLP:journals/fuin/AbdullaDOQW08}), we obtain:
	\begin{corollary}
		\label{corollary_univ_dec}
		The universality problem for one-clock timed counter nets is decidable with non-primitive recursive complexity.
	\end{corollary}
	The next two sections are devoted to the proofs of Theorems \ref{theorem_main_lang_inc} and \ref{theorem_main_dec}. 
	We will also give some interesting consequences of these results and their proofs. 
	Amongst others, we prove the undecidability of the model checking problem for timed visibly one-counter nets and MTL over finite timed words, \cf \ the decidability of the same problem for timed automata~\cite{DBLP:conf/lics/OuaknineW05}. 
	After this, in Sect. 5, we will prove the following theorem:
	\begin{theorem}
		\label{theorem_univ_undec}
		The universality problem for one-clock timed visibly one-counter automata is undecidable.
	\end{theorem}
	This is in contrast to the decidability of the universality problem for the two underlying models of one-clock timed automata~\cite{DBLP:conf/lics/OuaknineW04} and visibly one-counter automata, which form a subclass of visibly pushdown automata~\cite{DBLP:conf/stoc/AlurM04}.  
	We also want to point out that this result 
	is stronger than a previous result on the undecidability of the universality problem for one-clock timed visibly pushdown automata (Theorem 3 in~\cite{EmmiM06}), and our proof closes a gap in the proof of Theorem 3 in~\cite{EmmiM06}. 
	Further, we can infer from Corollary \ref{corollary_univ_dec} and Theorem \ref{theorem_univ_undec} the exact decidability border for the universality problem of timed pushdown automata, which lies between timed visibly one-counter nets and timed visibly one-counter automata. 
	
	
	
	\section{Undecidability Results}
	In this section, we prove Theorem \ref{theorem_main_lang_inc}. 
	The proof is a reduction of an undecidable  problem for \emph{channel machines}. 
	
	\subsection{Channel Machines}
Let  be a finite alphabet. 
We define the order  over the set of finite words over  by 
 if there exists a strictly increasing function  such that  for every . 

A \emph{channel machine} consists of a finite-state automaton acting on an  unbounded fifo channel. Formally, 
a channel machine is a tuple , where
\begin{itemize}
\item  is a finite set of \emph{control states},
	\item  is the initial control state,
	\item  is a finite set of \emph{messages},
	\item  is the transition relation over the label set .
\end{itemize}
Here,  corresponds to a  operation,  corresponds to a  operation, and  is a test which returns  if and only if the channel is empty.
Without loss of generality, we assume that  does not have any incoming transitions, \ie,  implies .
Further, we assume that  implies . 
A \emph{configuration} of  is a pair , where  is the control state and  represents the contents of the channel.
We use  to denote the set of all configurations of . 
The rules in  induce a transition relation  on  as follows:
\begin{itemize}
\item  if, and only if, there exists some transition  and , \ie,  is added to the tail of the channel.
\item  if, and only if, there exists some transition  and , \ie,  is removed from the head of the channel. 
\item  if, and only if, there exists some transition  and , \ie, the channel is empty, and . 
\end{itemize}
We may write  whenever .
Next, we define a second transition relation   on . The relation  is a superset of . It contains some additional transitions which result from \emph{insertion errors}. We define , if, and only if, there exist  such that , , and .
We may also write  whenever . 
A \emph{computation} of  is a finite sequence  such that  for every . 
We say that a computation is \emph{error-free} if for all  we have .
Otherwise, we say that the computation is \emph{faulty}.

The proof of Theorem \ref{theorem_main_lang_inc}  is a reduction from the following undecidable~\cite{Brand:1983:CFM:322374.322380} control state reachability problem: given a channel machine  with control states  and , does there exist an error-free computation of  from  to  for some ?



We remark that the analogous problem for faulty computations is decidable with non-primitive recursive complexity~\cite{DBLP:journals/fuin/AbdullaDOQW08}: both the lower and upper bound can be proved using corresponding results for \emph{lossy channel machines}~\cite{DBLP:journals/tcs/AbdullaJ03,DBLP:journals/ipl/Schnoebelen02}.

\begin{example}
	\label{example_encoding}
	Define a channel machine  by , , and . 
	The computation	
	 
	is faulty due to the last but one transition, where the symbol  is an insertion error. 	
	It is easy to see that there exists no error-free computation from  to  for some . 
\end{example}

The idea of our reduction is as follows: 
Given a channel machine , we define a timed language  consisting of all timed words that encode potentially faulty computations of  that start in  and end in  for some . 
Then we define a timed visibly one-counter net  such that  contains exactly \emph{error-free} encodings of such computations. In other words, we use  to exclude the encodings of faulty computations from , 
obtaining undecidability of the non-emptiness problem for . 
Finally, we define a one-clock timed automaton  that accepts the complement of ; hence the problem of deciding whether  is undecidable. 


\subsection{Encoding Faulty Computations}
For the remainder of Section 4, consider a channel machine 
 and let . 
Define 
,
,
and ,
where  and  are fresh symbols that do not occur in . The symbols  are called \emph{wildcard symbols}. 
We define a timed language  over  that consists of all timed words that encode computations of  from  to  for some . 
The definition of  follows the ideas presented in~\cite{DBLP:conf/lics/OuaknineW05}, in which (a dual variant of) the 
control state reachability problem for channel machines is reduced to the satisfiability problem for MTL over timed words.


In general, the idea is to encode a configuration of  of the form  by a timed word of duration one. 
This timed word starts with the symbol  at some time .
If the content of the channel  is of the form , 
then  is followed by the symbols  in this order. The timestamps of these symbols must be strictly monotonic and in the interval . 
Due to the denseness of the time domain, one can indeed store the channel content in one time unit without any upper bound on .


\begin{example}
	The initial configuration  is encoded by a
        single-letter timed word, for instance by . 
The configuration  may be encoded by the timed word . 
The choice of the timestamps is arbitrary as long as the timestamps of the message symbols are in the unit interval determined by the timestamp of the preceding control state. 
\end{example}

To encode a computation of a channel machine, we concatenate the encodings of each of the participating configurations in the following way. 
Encodings of consecutive configuration have a time distance of exactly two time units. 
One time unit before the encoding of the next configuration we store the label of the transition. 
Further, each message symbol in the encoding of the current configuration has a matching copy in the encoding of the next configuration,  after exactly two time units, and in accordance with the following rules: If the next transition is sending a new message symbol  to the tail of the channel, we add  to the tail of the encoding of the next configuration. 
If the next transition is reading  from the head of the channel, we test whether the first symbol after the control state in the encoding of the current configuration equals , and if so, we remove it from the encoding of the next configuration.  
\begin{example}
	The transition  
 may be encoded by  
 The symbol  at time   has a matching copy exactly two time units later; the symbol  at  does not, because it is removed from the channel by the transition. 
\end{example}
This idea of encoding computations of channel machines was used for proving lower complexity bounds for the satisfiability problem of MTL~\cite{DBLP:conf/lics/OuaknineW05} and the universality problem for one-clock timed automata~\cite{DBLP:journals/fuin/AbdullaDOQW08}. 
These problems, however, are decidable~\cite{DBLP:conf/lics/OuaknineW05,DBLP:journals/fuin/AbdullaDOQW08}, whereas here we want to use the encoding to show undecidability of a problem. The crucial point is that the encoding explained above does not exclude timed words that are encoding \emph{faulty} computations of a channel machine: for excluding encodings of faulty computations, we need to require that every message symbol has not only a matching copy \emph{after} two time units, but also a matching copy two time units \emph{before}. In other words, it should not be possible that message symbols appear ``all of a sudden'', \ie, without a corresponding error-free transition.
\begin{example}
	The faulty transition  
	may be encoded by  
	As in the previous example, the symbol  at time   has a matching copy exactly two time units later; the symbol  at  does not, because it is removed from the channel by the encoded transition. 
	However, the symbol  at time  appears all of a sudden, \ie, without any matching copy two time units before.
 This corresponds to an insertion error in the computation, see Example \ref{example_encoding}. 
\end{example}
The above described \emph{backward-looking conditions}, however, cannot be expressed by neither MTL formulas, nor by one-clock timed automata.\footnote{Backward-looking conditions (or, to be more exact with respect to the reduction: the violation of such backward-looking conditions), can be expressed by MTL with past operators, and by timed automata with two clocks, leading to the undecidability of the corresponding satisfiability and universality problem, respectively~\cite{AD94}.} Due to this failure, it is only the control state reachability problem \emph{for faulty computations} that can be reduced to the satisfiability problem for MTL respectively the universality problem for one-clock timed automata. As mentioned before, the control state reachability problem for faulty computations is \emph{decidable}~\cite{DBLP:journals/fuin/AbdullaDOQW08}.

For our undecidability proof to work,
we have to exclude encodings of faulty computations. 
In other words, we have to exclude timed words in which message symbols occur without any matching copy two time units before. 
This will be carried out by the counter of the visibly timed one-counter net . 
For this to work, we have to change the encoding in some details, as explained in the following. 







Assume we want to encode a given error-free computation of . 
Let  be the maximum length of the channel content during this computation. 
Let us assume for a moment that  does not start its computation with the empty channel, but the channel contains the word , \ie,  occurrences of the wildcard symbol . The semantics of  is changed in the following way: If a message  is sent, then, instead of adding  to the tail of the channel, the first  occurring in the channel is \emph{replaced} by . 
If a message  is read, then, it is tested whether the first symbol in the channel is . If this the case, it is removed from the channel and additionally a new wildcard symbol   is added to the tail of the channel. 
A test for emptiness of the channel is replaced by testing whether the channel only contains the wildcard symbol . 
\begin{example}
	Let  be a computation of , and let . 
	With the new wildcard semantics this computation is of the form
	
\end{example}
Observe that the length of the channel content is constantly . 
We will later exploit this fact. 


The encoding of computations of channel machines is now changed with this wildcard semantics in mind. 
The initial configuration is encoded by a timed word that starts with the symbol  at some time , and then is followed by  occurrences of , all of which have monotonically increasing timestamps in the interval . 
The rules for the transitions change accordingly:
If the next transition is sending a message  to the channel, we \emph{replace} in the encoding of the next configuration the first occurrence of  by . 
If the next transition is reading a message  from the head of the channel, we test whether the first symbol after the control state is , and if so, we remove it from the encoding of the next configuration. We further add a new  to the end of the encoding of the next configuration.\begin{example}
	The encoding of the computation of the previous example may be of the form
	
	
\end{example}
Observe that the length of the encoding of every configuration is constantly . This is due to the fact that none of the encoding rules changes the number of symbols in a configuration. 
However, due to the lack of backward-looking conditions, 
it may still happen that some symbols appear ``all of a sudden'', \ie, without a matching copy two time units before. 
In this case, the length of the encoding of the configuration increases. By the encoding conditions above, the increasing effect will be carried over to the encodings of the following configurations. 
Hence, in order to find out whether insertion errors occurred, 
it suffices to compare the length of the encoding of the initial configuration (which is equal to ) to the length of the encoding of the last configuration: If it is still , then we know that no insertion error has occurred; otherwise, some insertion error has occurred. 
The test will be done by the counter of the timed visibly one-counter net . 
During a run of  on the encoding of a computation, 
the counter is incremented while the symbols of the encoding of the first configuration are read, and it is decremented while the symbols of the encoding of the last configuration are read. In between, the counter is not touched. By the fact that a one-counter net cannot decrement the counter more often than it was incremented ( is blocked as soon as the counter would become negative), we can exclude timed words which are encoding potential insertion errors. 

By definition of timed \emph{visibly} one-counter nets,  is restricted to use  and the wildcard symbol  whenever the counter should be incremented, and it can only use the wildcard symbol  and  whenever the counter should be decremented.  
This requires some extra effort in the encoding, namely that the encoding of the first configuration only uses the wildcard symbol , and the encoding of the last configuration only uses the wildcard symbol . 
Before we give the formal definition of the language , 
we show a complete encoding of the faulty computation of Example \ref{example_encoding} for .
\begin{example}
	\label{example_thewholeenc}
	
	
	
\end{example}
For every , we define a timed language   as follows: 
The timed language  consists of all timed words  over  that satisfy the following conditions:
\begin{enumerate}
\item  must be strictly monotonic. 
	
\item The untiming of  must be of the form given by the following regular expression: 
	
\item For every , if  is followed by  after one time unit, and  is followed by  after two time units, then . 
	
	
\item For every  with , there exists  after exactly one time unit. 
	
\item For every  with , there exists  after exactly two time units.
	
\item After   the symbol  occurs after two time units.
	
	
\end{enumerate}
Further,
for every infix of  of the form

with ,
,
,
,
there exists a strictly increasing function  such that the following conditions are satisfied:
\begin{enumerate}
	\addtocounter{enumi}{6} 
\item If ,
	then 
	\begin{enumerate}
	\item  and  for all  (the channel is empty), and
	\item  for every  (there are matching copies after two time units).
	\end{enumerate}	
\item If  for some , then
	\begin{enumerate}
	\item there exists  such that  (there is some wildcard symbol in the encoding of the current configuration),  
	\item  and  for  (the first wildcard symbol is replaced by  two time units later), 
	\item  and   for all  (there are matching copies for the remaining symbols).
	\end{enumerate}
\item If  for some , then 
	\begin{enumerate}
	\item  (the first symbol is equal to ),
	\item , , and 
		 (a new wildcard symbol is added at the end of the encoding), and
	\item  and   for all  (there are matching copies for all other symbols except for the first one, which is removed from the encoding). 
\end{enumerate}		
\end{enumerate}\smallskip

\noindent For an infix like above but with  and , we add conditions (7'), (8') and (9') that   differ from 7, 8, and 9, respectively, in that all message or wildcard symbols to be copied or added to the encoding of the next configuration are replaced by the wildcard symbol .

A simple observation that we will later use is that by these conditions the length of the encodings of two consecutive configurations cannot decrease. 
Indeed, the conditions for representing transitions between two configurations of the channel machine do not change the number of symbols in the encoding of the respective configurations. 
By the lack of backward-looking conditions it may however happen that some symbols appear all of a sudden, \ie, without a matching copy two time units before. We point out that such insertion errors \emph{may} occur, but they are not required by any of the conditions. 


\subsection{Excluding Faulty Computations}
We define a timed visibly one-counter net  over  such that for every  the intersection  consists of all timed words that encode \emph{error-free} computations of  from  to  for some . 
The timed visibly one-counter net  is shown in Figure \ref{figure_A}.
After incrementing the counter while reading the initial letter , it non-deterministically guesses a number  of symbols  and increments the counter each time it reads the symbol .
When  leaves , the value of the counter is . After that, the counter value is not changed until the state symbol  is read.
Then, while reading symbols in , the counter value is decremented. Note that  can reach the final location  only if the number of the occurrences of symbol  between  and  is \emph{at most} : otherwise the counter value would become negative, and thus the edges going out from  would be blocked. 
Note that  does not use any clock, and it is deterministic. 
	\begin{figure}
\begin{center}
		\begin{picture}(107,14)(0,-14)
\node[NLangle=0.0,Nmarks=i,ilength=3,Nw=4.0,Nh=4.0,Nmr=2.0](n0)(5.0,-11.0){}
\node[NLangle=0.0,Nw=4.0,Nh=4.0,Nmr=2.0](n1)(27.0,-11){}
\node[NLangle=0.0,Nw=4.0,Nh=4.0,Nmr=2.0](n2)(50.0,-11){}
\drawedge[curvedepth=4.0](n0,n1){\footnotesize{}}
\drawloop[loopdiam=6](n1){\footnotesize{}}
\drawedge[curvedepth=4.0](n1,n2){\footnotesize{}}
\drawloop[loopdiam=6](n2){\footnotesize{}}
\node[NLangle=0.0,Nw=4.0,Nh=4.0,Nmr=2.0](n3)(76.0,-11){}
\node[NLangle=0.0,Nmarks=f,flength=3,Nw=4.0,Nh=4.0,Nmr=2.0](n4)(100.0,-11){}
\drawedge[curvedepth=4.0](n2,n3){\footnotesize{}}
\drawloop[loopdiam=6](n3){\footnotesize{}}
\drawedge[curvedepth=4.0](n3,n4){\footnotesize{}}
\end{picture}
\caption{The deterministic timed visibly one-counter net  for excluding insertion errors. }
\label{figure_B}
\end{center}
\end{figure}
\begin{example}
	The timed word presented in Example \ref{example_thewholeenc} cannot be accepted by the timed visibly one-counter net  in Figure \ref{figure_B}: 
	The run of  on the prefix is of the form 
	
	Here, in ,  stands for the current location, and  stands for the current value of the counter. 
	The counter value stays constant until we finally read the first :  
	
	Now  is blocked:
	all outgoing edges of  require the counter to be decremented, which is not possible if the counter has value zero. 
	This is indeed what we want: the timed word in Example \ref{example_encoding} is encoding a faulty computation, and should be excluded.  
\end{example}


\begin{lemma}
	\label{lemma_intersection}
	 has an error-free computation from  
	to  for some , if, and only if, 
	there exists   such that  .
\end{lemma}
\begin{proof}
	For the direction from left to right,
	let  be an error-free computation of  from  to  for some . 
	Let  be the maximum length of the channel content during . 
	Let  be a timed word in  in which no message or wildcard symbols occur ``all of a sudden'', \ie, without a matching copy two time units before. 
	Note that such a timed word exists, because  is error-free, and hence there is no need to encode insertion errors into . 
	This implies that the length of the encodings of all, and in particular, the first and the last configuration in  is . 
	This implies .
	Hence . 
	
	
	
	
	For the direction from right to left, 
	let  for some . 
By definition of , 
	the length of the encoding of the initial configuration is . 
	By the observation above, the length of the  encoding of the last configuration  is thus at least , too. 	
	However, by definition of , 
	the length of the encoding of the last configuration cannot be greater than , because otherwise the edge to  cannot be taken due to the decrement operation. 
	By the observation above, the length of encodings of consecutive configurations do not decrease, and thus the length of the encodings of all configurations is . Hence we can conclude that there are no insertion errors necessary to encode the execution of a transition. This implies that 
	there exists some error-free computation  of  from  to  for some . 	
\end{proof}
We finally define .
	\begin{corollary}
		\label{corollary_cap}
		There exists some error-free computation of  from  to  for some  if, and only if, . 
	\end{corollary}
	
	
	\subsection{The Reduction}
	Finally, 
	we define a one-clock timed automaton  such that . 
	The construction of  follows the same ideas as, \eg, in~\cite{DBLP:conf/formats/AdamsOW07}: 
	 is the union of several one-clock timed automata, each of them violating some condition of the definition of , as described in the following. 
	
	
	The timed automaton in Figure A accepts timed words that are not strictly monotonic,  thus violating condition (1). 
	For accepting timed words violating condition (2), we can construct a finite automaton that recognizes the complement of the given regular expression. 
	Define 
	for every  the sets  and , and  and . 
	Then for every  the corresponding timed automaton in Figure B accepts timed words that contain the encoding of a transition , thus violating condition (3).
	Violations of the forward-looking conditions in (4), (5), and (6) can be 
	accepted by the timed automaton in Figure C with, respectively, 
	(4) , , and , (5) , , and , and (6) , , and .  		
	
	
	\begin{center}
		\begin{tabular}{p{5cm}p{1cm}p{5cm}}
			\\
\mbox{\begin{picture}(48,22)(0,-22)
\node[NLangle=0.0,Nmarks=i,ilength=3,Nw=4.0,Nh=4.0,Nmr=2.0](n0)(5.0,-13.0){}
\node[NLangle=0.0,Nw=4.0,Nh=4.0,Nmr=2.0](n1)(25.0,-13){}
\node[NLangle=0.0,Nmarks=f,flength=3,Nw=4.0,Nh=4.0,Nmr=2.0](n2)(43.0,-13){}
\drawloop[loopdiam=4](n0){\footnotesize{}}
\drawloop[loopdiam=4](n2){\footnotesize{}}
\drawedge[curvedepth=4.0](n0,n1){\footnotesize{}}
\drawedge[curvedepth=4.0](n1,n2){\footnotesize{}}
\end{picture}} & & 
\begin{picture}(50,22)(0,-22)
\node[NLangle=0.0,Nmarks=i,ilength=3,Nw=4.0,Nh=4.0,Nmr=2.0](n0)(5.0,-13.0){}
\node[NLangle=0.0,Nw=4.0,Nh=4.0,Nmr=2.0](n1)(21.0,-13){}
\node[NLangle=0.0,Nmarks=f,flength=3,Nw=4.0,Nh=4.0,Nmr=2.0](n2)(45.0,-13){}

\drawedge[curvedepth=4.0](n0,n1){\footnotesize{}}
\drawloop[loopdiam=4](n0){\footnotesize{}}

\drawloop[loopdiam=4](n2){\footnotesize{}}
\drawedge[curvedepth=4.0](n1,n2){\footnotesize{}}
\drawedge[curvedepth=-4.0,ELside=r](n1,n2){\footnotesize{}}

\end{picture}
 \\
 Figure A: Condition (1) & &Figure B: Condition (3)
\end{tabular}\end{center}



\begin{center}
		\begin{tabular}{p{8cm}}
		\\
		\mbox{
 \begin{picture}(75,20)(0,-20)
\node[NLangle=0.0,Nmarks=i,ilength=3,Nw=4.0,Nh=4.0,Nmr=2.0](n0)(5.0,-13.0){}
\node[NLangle=0.0,Nw=4.0,Nh=4.0,Nmr=2.0](n1)(30.0,-13){}
\node[NLangle=0.0,Nmarks=f,flength=3,Nw=4.0,Nh=4.0,Nmr=2.0](n2)(70.0,-13){}
\drawloop[loopdiam=6](n0){\footnotesize{}}
\drawloop[loopdiam=6](n2){\footnotesize{}}
\drawedge[curvedepth=4.0](n0,n1){\footnotesize{}}
\drawloop[loopdiam=6](n1){\footnotesize{}}

\drawedge[curvedepth=6.0](n1,n2){\footnotesize{}}
\drawedge[curvedepth=0.0](n1,n2){\footnotesize{}}
\drawedge[curvedepth=-6.0](n1,n2){\footnotesize{}}
\end{picture}}
 \\
 Figure C: Conditions (4), (5), and (6)
 \\
 \\
\end{tabular}\end{center}
Timed words violating condition (7a) can be accepted by the timed automaton in Figure D. 
In Figure E we show a timed automaton that accepts timed words violating condition (7b).

	 \begin{tabular}{p{4.1cm}p{10cm}}
\mbox{
	\begin{picture}(41,20)(0,-20)
\node[NLangle=0.0,Nmarks=i,ilength=3,Nw=4.0,Nh=4.0,Nmr=2.0](n0)(0.0,-13.0){}
\node[NLangle=0.0,Nw=4.0,Nh=4.0,Nmr=2.0](n1)(14.0,-13){}
\node[NLangle=0.0,Nmarks=f,flength=3,Nw=4.0,Nh=4.0,Nmr=2.0](n2)(31.0,-13){}
\drawloop[loopdiam=4](n0){\footnotesize{}}
\drawloop[loopdiam=4](n2){\footnotesize{}}
\drawedge[curvedepth=4.0](n0,n1){\footnotesize{}}
\drawloop[loopdiam=4](n1){\footnotesize{}}
\drawedge[curvedepth=4.0](n1,n2){\footnotesize{}}
\end{picture}}
&\begin{picture}(95,20)(0,-20)
\node[NLangle=0.0,Nmarks=i,ilength=3,Nw=4.0,Nh=4.0,Nmr=2.0](n0)(5.0,-13.0){}
\node[NLangle=0.0,Nw=4.0,Nh=4.0,Nmr=2.0](n1)(30.0,-13){}
\node[NLangle=0.0,Nw=4.0,Nh=4.0,Nmr=2.0](n3)(55.0,-13){}
\node[NLangle=0.0,Nmarks=f,flength=3,Nw=4.0,Nh=4.0,Nmr=2.0](n2)(90.0,-13){}
\drawloop[loopdiam=4](n0){\footnotesize{}}
\drawloop[loopdiam=4](n2){\footnotesize{}}
\drawloop[loopdiam=4](n1){\footnotesize{}}
\drawedge[curvedepth=4.0](n0,n1){\footnotesize{}}
\drawedge[curvedepth=4.0](n1,n3){\footnotesize{}}


\drawloop[loopdiam=4](n3){\footnotesize{}}

\drawedge[curvedepth=3.0](n3,n2){\footnotesize{}}
\drawedge[curvedepth=-3.0](n3,n2){\footnotesize{}}
\end{picture}
\\
\hspace{-5mm}Figure D: Condition (7a) & Figure E: Condition (7b) 
\\
\\
\end{tabular}
The timed automaton in Figure F accepts all timed words for which the last symbol before  is different from . This, together with the structure of  ensured by condition (2), implies that condition (8a) is violated. 
The timed automaton in Figure G accepts timed words violating condition (8b). 
For condition (8c), we can use a timed automaton similar to that in Figure E.
By constructing for every  the corresponding automata, we can thus accept all timed words violating the conditions stated in (8). 
	\begin{center}
		\begin{tabular}{p{2.9cm}p{5mm}p{8.5cm}}
\mbox{\begin{picture}(30,20)(0,-19)
\node[NLangle=0.0,Nmarks=i,ilength=3,Nw=4.0,Nh=4.0,Nmr=2.0](n0)(5.0,-13.0){}
\node[NLangle=0.0,Nw=4.0,Nh=4.0,Nmr=2.0](n1)(16.0,-13){}
\node[NLangle=0.0,Nmarks=f,flength=3,Nw=4.0,Nh=4.0,Nmr=2.0](n2)(25.0,-13){}
\drawloop[loopdiam=4](n0){\footnotesize{}}
\drawloop[loopdiam=4](n2){\footnotesize{}}
\drawedge[curvedepth=4.0](n0,n1){\footnotesize{}}
\drawedge[curvedepth=4.0](n1,n2){\footnotesize{}}
\end{picture}}& &\begin{picture}(83,19)(0,-19)



\node[NLangle=0.0,Nmarks=i,ilength=3,Nw=4.0,Nh=4.0,Nmr=2.0](n0)(5.0,-13.0){}
\node[NLangle=0.0,Nw=4.0,Nh=4.0,Nmr=2.0](n1)(18.0,-13){}
\node[NLangle=0.0,Nw=4.0,Nh=4.0,Nmr=2.0](n2)(34.0,-13){}
\node[NLangle=0.0,Nw=4.0,Nh=4.0,Nmr=2.0](n3)(45.0,-13){}
\node[NLangle=0.0,Nw=4.0,Nh=4.0,Nmr=2.0](n4)(54.0,-13){}
\node[NLangle=0.0,Nmarks=f,flength=3,Nw=4.0,Nh=4.0,Nmr=2.0](n5)(78.0,-13){}


\drawloop[loopdiam=4](n0){\footnotesize{}}
\drawedge[curvedepth=3.0](n0,n1){\footnotesize{}}
\drawedge[curvedepth=3.0](n1,n2){\footnotesize{}}
\drawloop[loopdiam=4](n2){\footnotesize{}}
\drawedge[curvedepth=3.0](n2,n3){\footnotesize{}}
\drawedge[curvedepth=3.0](n3,n4){\footnotesize{}}

\drawedge[curvedepth=-4.0](n4,n5){\footnotesize{}}
\drawedge[curvedepth=4.0](n4,n5){\footnotesize{}}
\drawloop[loopdiam=4](n5){\footnotesize{}}
\end{picture} \\
Figure F: Condition (8a)& &Figure G: Condition (8b) \\
\\ 
\end{tabular}	
\end{center}
Last but not least we present timed automata that accept timed words violating condition (9). 
For all , we define  
timed automata shown in Figure H  und I, respectively, that accept timed words violating condition (9a) and (9b), respectively.
For (9c) we construct a timed automaton very similar to that in Figure E. 
	 \begin{center}
\begin{tabular}{p{5cm}p{8cm}}
	\\
\mbox{\begin{picture}(46,19)(0,-19)



\node[NLangle=0.0,Nmarks=i,ilength=3,Nw=4.0,Nh=4.0,Nmr=2.0](n0)(5.0,-13.0){}
\node[NLangle=0.0,Nw=4.0,Nh=4.0,Nmr=2.0](n1)(16.0,-13){}
\node[NLangle=0.0,Nw=4.0,Nh=4.0,Nmr=2.0](n2)(30.0,-13){}
\node[Nmarks=f,flength=3,NLangle=0.0,Nw=4.0,Nh=4.0,Nmr=2.0](n3)(41.0,-13){}


\drawloop[loopdiam=4](n0){\footnotesize{}}


\drawedge[curvedepth=3.0](n0,n1){\footnotesize{}}
\drawedge[curvedepth=3.0](n1,n2){\footnotesize{}}
\drawloop[loopdiam=4](n2){\footnotesize{}}
\drawloop[loopdiam=4](n3){\footnotesize{}}
\drawedge[curvedepth=3.0](n2,n3){\footnotesize{}}
\end{picture}}&\begin{picture}(80,19)(0,-19)
\node[NLangle=0.0,Nmarks=i,ilength=3,Nw=4.0,Nh=4.0,Nmr=2.0](n0)(5.0,-13.0){}
\node[NLangle=0.0,Nw=4.0,Nh=4.0,Nmr=2.0](n1)(28.0,-13){}
\node[NLangle=0.0,Nw=4.0,Nh=4.0,Nmr=2.0](n2)(40.0,-13){}
\node[NLangle=0.0,Nw=4.0,Nh=4.0,Nmr=2.0](n3)(60.0,-13){}
\node[NLangle=0.0,Nmarks=f,flength=3,Nw=4.0,Nh=4.0,Nmr=2.0](n4)(75.0,-13){}

\drawloop[loopdiam=4](n0){\footnotesize{}}


\drawedge[curvedepth=4.0](n0,n1){\footnotesize{}}

\drawedge[curvedepth=4.0](n1,n2){\footnotesize{}}
\drawloop[loopdiam=6](n2){\footnotesize{}}

\drawedge[curvedepth=4.0](n2,n3){\footnotesize{}}
\drawedge[curvedepth=-4.0](n2,n4){\footnotesize{}}

\drawloop[loopdiam=4](n3){\footnotesize{}}
\drawedge[curvedepth=4.0](n3,n4){\footnotesize{}}
\drawloop[loopdiam=4](n4){\footnotesize{}}
\end{picture} \\
Figure H: Condition (9a)& Figure I: Condition (9b) \\
\\
\end{tabular}\end{center}
So let  the union of all these timed automata. 
One can easily see that for every timed word  we have  if, and only if, .
By Corollary \ref{corollary_cap},
	there exists some error-free computation of  from  to  for some  if, and only if, . 
	The latter is equivalent to . 
	Hence, the language inclusion problem is undecidable.
		
	\subsection{Undecidability of the Model Checking Problem for \mtl}	
	The proof idea of Theorem \ref{theorem_main_lang_inc} can be used to show the undecidability of the following model checking problem: given a timed visibly one-counter net , and an \mtl formula , does every  satisfy  ?
Recall that this problem is decidable for the class of timed automata~\cite{DBLP:conf/lics/OuaknineW05}.
We prove that adding a visibly counter without zero test already makes the problem undecidable. 
But first, let us recall the syntax and semantics of MTL. 

Let  be a  finite alphabet.
	The set of \mtl formulae is built up from  
        by Boolean connectives and a time constraining version of the {\em until}
modality:

        where  and  is an open, closed, or half-open interval with endpoints in .


We interpret \mtl formulae in the \emph{pointwise semantics}, \ie, over finite timed words over . 
Let  be a timed word, and let  . 
We define the {\em satisfaction relation for \mtl}\hspace{-1.4mm}, denoted by ,
inductively as follows:

We say that a timed word  satisfies an \mtl formula , written , if .



Note that \mtl only allows to express restrictions on time, and it does not allow for any restrictions on the values of the counters. 
In fact, it is proved that as soon as we add to \mtl the capability for expressing restrictions on the values of a counter that can be incremented and decremented, model checking is undecidable~\cite{DBLP:conf/lata/Quaas13}.
The proof of the following theorem is based on the fact that MTL can encode computations of channel machines with insertion errors~\cite{DBLP:conf/lics/OuaknineW05}.
\begin{theorem}
	\label{theorem_model_checking}
	The model checking problem for timed visibly one-counter nets and \mtl is undecidable, even if the timed visibly one-counter net does not use any clocks and is deterministic. 
\end{theorem}
\begin{proof}
	The definition of an \mtl formula  such that  is straightforward, see, \eg, ~\cite{DBLP:conf/lics/OuaknineW05}.
	By Corollary \ref{corollary_cap}, 
	there exists some error-free computation of  from  to  for some  if, and only if, . 
	The latter, however, is equivalent to saying that there exists some timed word  such that . 
	Hence the model checking problem is undecidable. 
\end{proof}

We would like to remark that the proof of Theorem \ref{theorem_model_checking} shares some similarities with the proof of the undecidability of model checking one-counter machines (\ie, one-counter automata without input alphabet) and Freeze LTL with one register (LTL, for short)~\cite{DLS-tcs10}. 
In~\cite{DBLP:journals/tocl/DemriL09},
it is proved that 
LTL can encode computations of \emph{counter automata with incrementing errors}. 
Similar to the situation for \mtl and channel machines,  can however not encode \emph{error-free} computations of counter automata. 
In~\cite{DLS-tcs10}, a one-counter machine is used to repair this incapability, resulting in the undecidability of the model checking problem. 
The one-counter machine in~\cite{DLS-tcs10} does not use zero tests; however, we point out that in contrast to our visibly timed one-counter net the one-counter machine in~\cite{DLS-tcs10} is \emph{non-deterministic}. Indeed, model checking \emph{deterministic} one-counter machines and LTL is decidable~\cite{DLS-tcs10}.

We further remark that using a similar proof, we can show that the model checking problem for \emph{parametric timed automata} and MTL is undecidable, even if the automaton only uses one parametric clock, one parameter and is deterministic~\cite{DBLP:journals/corr/Quaas14a}.


\subsection{Energy Problems on Timed Automata with Discrete Weights}
Next  we will consider an interesting extension of \emph{lower-bound energy problems on weighted timed automata}, introduced in~\cite{DBLP:conf/formats/BouyerFLMS08}, which gained  attention in the last years, see, \eg,~\cite{DBLP:journals/pe/BouyerLM14,DBLP:conf/lata/Quaas11,DBLP:conf/hybrid/BouyerFLM10}.
In lower-bound energy problems, 
one is interested whether in a given automaton with some weight variable whose value can be increased and decreased, there exists a successful run in which all accumulated weight values are never below zero.  
Similar problems have also been considered for untimed settings, \eg,~\cite{DBLP:conf/birthday/JuhlLR13,DBLP:conf/atva/EsikFLQ13,DBLP:conf/ictac/FahrenbergJLS11,DBLP:conf/icalp/BrazdilJK10}.  


A \emph{timed automaton with discrete weights} (dWTA, for short)
is syntactically the same as a timed one-counter net.
	In the semantical graph induced by a dWTA, however, we allow the value of the counter (or, the \emph{weight variable}) to become negative.
	Hence the value of the weight variable does not influence the behaviour of the dWTA, 
	because, different to timed one-counter nets, transitions that result in negative values are not blocked. 
	We remark that for the  simple reasons that (1) the value of the weight variable does not influence the behaviour of dWTA, and (2) MTL does not restrict the values of the weight variable, the model checking problem for dWTA and MTL is decidable, using the same algorithm as for timed automata~\cite{DBLP:conf/lics/OuaknineW05}. 
	We define the \emph{model checking energy problem} for dWTA and \mtl as follows: given a dWTA  and an \mtl formula , does there exist some accepting run  of  such that the value of the weight variable is always non-negative, and the timed word  associated with  satisfies ?	
	For the special case , 
	the problem is decidable in polynomial time for one-clock dWTA~\cite{DBLP:conf/formats/BouyerFLMS08}.
	\begin{theorem}
		\label{theorem_energy}
		The model checking energy problem for dWTA and \mtl is undecidable, even if the dWTA uses no clocks. 
	\end{theorem}
	\begin{proof}		
		For the proof, we reduce the  model checking problem for timed one-counter nets and \mtl to the energy problem. 
		Note that timed one-counter nets are a generalization of timed visibly one-counter nets, and thus by Theorem \ref{theorem_model_checking} the model checking problem is undecidable. 
		Let  be a timed one-counter net, and let  be an \mtl formula. 
		Define  to be the dWTA that is syntactically equal to .
		One can easily prove that  is a negative instance of the model checking problem if, and only if,  is a positive instance of the energy problem. 
	\end{proof}
	


	\section{Decidability Result}
	In the preceding section, we showed that one cannot automatically verify  timed automata extended with unbounded discrete data structures against real-time specifications expressed by timed automata or MTL-formulas. 
	In this section, 
	we prove that in contrast to this, we can use one-clock timed counter nets as specification for model checking timed automata: the language inclusion problem  is decidable with non-primitive recursive complexity if  is a timed automaton and  is a one-clock timed counter net (Theorem \ref{theorem_main_dec}).
	We will first give the formal proof of Theorem \ref{theorem_main_dec}. 
	After that, we will argue that this result extends known facilities for the verification of timed automata. 
	
	\subsection{Proof of Theorem \ref{theorem_main_dec}}
	\begin{proof}
		For the case that  is a timed automaton and  is a one-clock timed automaton,
		the language inclusion problem  is decidable~\cite{DBLP:conf/lics/OuaknineW04} with non-primitive recursive complexity~\cite{DBLP:journals/fuin/AbdullaDOQW08}. 
		The lower bound hence follows, and the decidability proof is an adaptation of the decidability proof in~\cite{DBLP:conf/lics/OuaknineW04}.


		
		The proof is based on the theory of well-quasi-orders, and we start with defining some useful notions.
	
	Let  be two sets, and let  be a binary relation on .
	Then  is a \emph{quasi-order} on  if  is reflexive and transitive. 
	 is a \emph{well-quasi-order} on  if it is a quasi-order and for every infinite sequence  in  there exist indices  such that . 
	A standard example for a well-quasi-order is the pointwise order  on the set  of vectors of  natural numbers (Dickson's Lemma, \cite{Dickson1913}). 
	
	Let  be a quasi-order on , 
	and let  be a quasi-order on . 
	We define the \emph{product} of  and  on  by , if and only if,  and . 	
	We define the \emph{monotone domination order}  on  by  if and only if there exists a strictly increasing function  such that for all  we have . 
	We define the \emph{subset order}  on the set  of finite subsets of  by
	 if and only if there is an injective mapping  such that for all  we have . 
	


	\begin{lemma}[Higman's Lemma~\cite{Higman1952}]
		\label{lemma_higman}
		\begin{enumerate}
		\item If  and  are well-quasi-orders on  and , respectively, 
			then the product of  and  is a well-quasi-order on . 
	\item  If  is a well-quasi-order on ,
		then the monotone domination order  is a well-quasi-order on . 
	\item  If  is a well-quasi-order on ,
		then the subset order  is a well-quasi-order on . 
	\end{enumerate}
	\end{lemma}
		
		
		
		Let  be a timed automaton with clock variables , 
		and let  be a timed counter net of dimension  with a single clock variable .
		Without loss of generality, we may assume that . 


		Note that a state  of  is an element in , 
		and a state  of  is an element in .		
		A \emph{joint configuration of  and } is a
		pair , where  is a state of , and  is a set of states of .
		We use  to denote the set of all joint configurations of  and . 		
		We say that a joint configuration  is \emph{initial} if  and  (with 
		 we denote the vector of dimension  containing only ).
		We say that a joint configuration  is \emph{bad} if  for some , and for all states  we have . 
		The \emph{joint behaviour of  and } is defined as follows: 
		For a state  of ,  and , 
		we define .
For a set  of states of , we define 
		. Note that  is a set of states of , and it may be empty. 
		Finally, we define the transition relation  on  by   if there exists some  such that  and  . 
		
		
		Next, we encode joint configurations of  and  by  finite untimed words over the set  of finite subsets of .
		Here, 	
		, where  is an integer greater than the maximal constant occurring in clock constraints in both  and , and  is a symbol representing all values greater than . 
		Let 
		be a joint configuration.		
		To simplify the definition, we write  as a set 
		
		Partition  into a sequence of subsets 
		,
		such that , and
		if ,
		then for all , , 
		we have  if, and only if, , and 
		 if, and only if, . Here,  denotes the fractional part of a real number . 		
		In this way,    and  are in the same subset  if, and only if,  and  are both smaller than or equal to  and have the same fractional part. 
		In addition, we require that 
		 if, and only if, the fractional part of  is zero, and
		 for all . 
		We define the encoding  of  to be  the finite word 
		, 
		where  with  if , and  otherwise ( denotes the integer part of a real number ). 
		
		
		We define a transition relation  on the set of encodings of joint configurations and  as follows:  if there exists  and  such that . 
		We further define the equivalence relation  by  if, and only if, .
		\begin{example}
			Let  be a timed automaton with a single clock , and let  be a timed one-counter net of dimension  and with a single clock . Assume . 
			Let  be a joint configuration of  and . 
			The encoding of  equals 
			
			The joint configuration 
			
			has the same encoding, and thus . Note that for  to hold, the configurations must agree on the counter values. 
		\end{example}
		In the next lemma, we prove that  is a time-abstract bisimulation over joint configurations. 
		The proof can be done like the proof of Prop. 11 in~\cite{DBLP:conf/lics/OuaknineW04}. 
		\begin{lemma}
			\label{lemma_bisim}
			For all joint configurations , and , if , then
			\begin{itemize}
			\item for all  such that , there exists  such that  and ,
			\item for all  such that , there exists  such that  and .
			\end{itemize}
		\end{lemma}
\noindent Next, we define a quasi-order  on the set of encodings of joint configurations and prove that  is a well-quasi-order. 
		First, define  on 
		 
		by  if, and only if, , , , and . 
		By Lemma \ref{lemma_higman}.1 and the fact that  on the finite set  and  on  are well-quasi-orders, 
		 is a well-quasi-order, too.
		By Lemma \ref{lemma_higman}.3, the subset order  is a well-quasi-order. 
		Finally, we define  to be the monotone domination order on , and then by Lemma \ref{lemma_higman}.2, 
		 is a well-quasi-order. 
		\begin{example}
Let .
			Then , where  from the previous example. Note that the counter values in  may be smaller than the associated counter values in , as it is here the case with the counter values for . 
		\end{example}		
		The next lemma states that  is downward-compatible with respect to . 
		\begin{lemma}
			\label{lemma_dc}
			If  and , then there exists  such that  and .
		\end{lemma}
		\begin{proof}
			The proof is similar to the proof of Lemma 15 in~\cite{DBLP:conf/lics/OuaknineW04}.
			
			Let  be such that  and .
			Further let 
			, 
			, 
			and  be such that \newline. 
			This implies that 
			there exists  with
			 and
			. 
			
			


			Since , 
			we know that there exists a set  of states in    such that
			 ():  is obtained from choosing a suitable set 
			such that the encoding of  differs from the encoding of  only in that the vectors representing the counter values occurring in  may be greater (with respect to ) than the corresponding vectors in .  
			  is then the result from subtracting suitable values from the vectors in  so that the encoding is equal. 


			


			
			Now let . 
			Then  (). 
			Note that we can add suitable values to the vectors in  to obtain  (). 
			
			


			
			From  and  it follows by Lemma \ref{lemma_bisim} that there exists
			 such that 
			 and 
			. 
			From the former it follows that
			, where . 
			From the second and  it follows that  .
		\end{proof}
		Intuitively, 
		comparing the situation for timed counter nets with the situation for pure timed automata like in Lemma 15 in~\cite{DBLP:conf/lics/OuaknineW04}, 
		there may now be transitions that can be executed from configurations encoded by , but that are blocked from configurations encoded by  due to the fact that counter values are too small. This, however, does not cause any trouble, because it results in smaller sets of successor configurations, and thus leading to . 
		\begin{remark}
		Note that Lemma  \ref{lemma_dc} does not hold if the counters in  can be tested for zero. 
		For instance, consider  and  from the previous example. Assume that in  there are no edges with source location  and , and the only suitable -labelled edge with source location  
		does a zero test on the second counter and leaves all other components unchanged. 
		This yields  
		 and , 
		where  is the set of states of  in some configuration  with  for .
		Assume there is an -labelled edge in  with source location  and leaving all components unchanged. 
		Then we have
		 with  , 
		 with 
		. 
		Note that  does \emph{not} hold. 		
		Indeed, the universality problem of (even untimed) one-counter automata is undecidable~\cite{DBLP:journals/jacm/Greibach69,DBLP:journals/mst/Ibarra79}. 
		In Section 6, we prove that this is also the case for timed visibly pushdown one-counter automata. 
		This gives us the precise decidability border for the universality problem. 
	\end{remark}
Finally, we describe the algorithm to decide . 
		Like in~\cite{DBLP:conf/lics/OuaknineW04}, 
		we solve the language inclusion problem by solving the following reachability problem: in the implicit graph of the encoding of joint configurations and the transition relation ,
		is there a path from the encoding of one of the finitely many  initial joint configuration to the encoding of a bad joint configuration?
		Note that we have  if, and only if, there is no such path. 
		For solving the reachability problem, we compute the unfolding of the graph, 
		starting the computation with the encoding of an initial joint configuration.
		If for the current node labelled by , there is along the branch already a node labelled with  and , 
		then by Lemma \ref{lemma_dc} we can prune the tree after the current node: 
		Assume that from  we can reach a word  that represents a bad configuration,
		then by Lemma \ref{lemma_dc} we can reach a word  from  such that , and hence,  is representing a bad configuration, too. 		
		By the facts that the unfolding is finitely branching,  is a well-quasi-order and by K\"onig's Lemma, we know that the computation will finally terminate. 
	\end{proof}
	
	
	\subsection{On the Expressiveness of Timed Counter Nets}
	Theorem \ref{theorem_main_dec} generalizes a result by Ouaknine and Worrell on the decidability of the language inclusion problem  for  being a one-clock timed automaton without counters~\cite{DBLP:conf/lics/OuaknineW04}.
	Clearly, timed counter nets are more expressive than timed automata; for instance, the timed language accepted by the timed one-counter net on the left hand side of Figure \ref{tocn_L_2} cannot be accepted by any timed automaton, because its projection on  equals , \ie, a non-regular language. 
		
		\begin{figure}
\begin{center}
		\begin{picture}(100,25)(0,-25)
\node[NLangle=0.0,Nmarks=i,flength=3,ilength=3,Nw=4.0,Nh=4.0,Nmr=2.0](n0)(5.0,-16.0){}
\node[NLangle=0.0,Nmarks=f,flength=3,Nw=4.0,Nh=4.0,Nmr=2.0](n1)(27.0,-16){}
\drawedge[curvedepth=4.0](n0,n1){\footnotesize{}}
\drawloop[loopdiam=6](n0){\footnotesize{}}
\drawloop[loopdiam=6](n1){\footnotesize{}}


\node[NLangle=0.0,Nmarks=i,ilength=3,Nw=4.0,Nh=4.0,Nmr=2.0](m0)(50.0,-16.0){}
\node[NLangle=0.0,Nw=4.0,Nh=4.0,Nmr=2.0](m1)(67.0,-16){}
\node[NLangle=0.0,Nw=4.0,Nh=4.0,Nmr=2.0](m3)(84,-6){}
\node[NLangle=0.0,Nmarks=f,flength=3,Nw=4.0,Nh=4.0,Nmr=2.0](m2)(101,-16){}

\drawedge[curvedepth=2.0](m1,m3){\footnotesize{}}
\drawloop[loopdiam=6](m3){\footnotesize{}}
\drawedge[curvedepth=2.0](m3,m2){\footnotesize{}}

\drawedge(m1,m2){\footnotesize{}}
\drawedge[curvedepth=-8.0](m0,m2){\footnotesize{}}
\drawloop[loopdiam=6,loopangle=70](m2){\footnotesize{}}


\drawloop[loopdiam=6,loopCW=n](m0){}


\put(50,-7){\footnotesize{}}
\put(54,-12){\footnotesize{}}
\put(52,-18){
    \unitlength=4mm
   
    \drawcurve[AHnb=0,AHnb=1](0,1)(0.4,2)(2,2.5)(3,2)(3.5,1)
  }
\end{picture}
\caption{From left to right: A timed one-counter net and an alternating one-clock timed automaton}
\label{tocn_L_2}
\end{center}
\end{figure}
However, the result in~\cite{DBLP:conf/lics/OuaknineW04} 
was also generalized to another extension of timed automata called \emph{alternating} one-clock timed automata~\cite{DBLP:conf/lics/OuaknineW05,DBLP:journals/tocl/LasotaW08}.
An alternating one-clock timed automaton allows for two modes of branching, namely existential branching and universal branching, represented by disjunction and conjunction, respectively. 
For example, the alternating one-clock timed automaton on the right hand side of Figure \ref{tocn_L_2} has a universal branching transition in  for the input letter , formally expressed by ; and it has an existential branching transition in  for the input letter , formally   (see~\cite{DBLP:conf/lics/OuaknineW05} for more details). 
This alternating one-clock timed automaton accepts the timed language consisting of a sequence of 's followed by a sequence of 's such that the time sequence belonging to the -sequence is strictly monotonic, and every  is followed by some  after exactly one time unit. Note that the projection on  thus equals .  

We prove that timed one-counter nets with one clock and alternating one-clock timed automata are incomparable in expressive power. 
\begin{theorem}
	Timed one-counter one-clock nets and alternating one-clock timed automata are incomparable in expressiveness.
\end{theorem}
\begin{proof}
	On the hand, due to the lack of zero tests, 
	the timed language accepted by the alternating one-clock timed automaton on the right hand side of Figure \ref{tocn_L_2} cannot be accepted by any timed one-counter net. 
	On the other hand, 
	we prove that the timed language  accepted by the timed counter net on the left side of Figure \ref{tocn_L_2} cannot be accepted by any alternating one-clock timed automaton, as we will prove in the following. 
	
	
	We start with some simple facts about deterministic finite automata. 	
	Let  be a deterministic finite automaton over the singleton alphabet  and with a set of states denoted by . 
	For every , 
	we define a function  such that  means that if  starts in state  to read the word , then  ends in . 
	Clearly, there exist natural numbers  such that . 
	By determinism of  we further have  for every . 
	
	Now let  be a finite set of deterministic finite automata. 
	For every , let  and  be such that . 
	Set , and let  be the least common multiple of . 
	One can easily prove that for every  we have , and, again by determinism, 
	 for every . 
	
	
	
	
	
	
	
	
	
	
	Assume by contradiction that  is accepted by an alternating  one-clock timed automaton .
	Assume  has  locations.
	Let  be the set of all deterministic finite automata over  with at most  states. Note that  is finite up to equivalent behaviour. 
	Now choose  as explained above and such that 
	 for every  and . 
	
	
	
	
	
	
	



	
	Define . 
	Define 
	and define , 	
	where  with  for every , 
	and, similarly,  with  for every .
	Note that  and .
	Further note that  and  for all . 
	
	
	
	We prove that  if, and only if, , \ie,  cannot distinguish between  and .
	
	First assume that .	
	Let  be the configuration that  is in after reading . 
	Clearly, all states  in  satisfy . 
	Let  be the run of   that starts from  on the suffix of  that contains the  many 's. 
	All clock constraints occurring in transitions of  are of the form  for some , and by the choice of , 
the only  clock constraints that are relevant for the acceptance of  are those with  equal to . The satisfaction of constraints of the form  may depend on preceding resets of the clock ; however, even with clock resets occurring in , the clock constraint  cannot be satisfied anywhere in  because the time delays between the 's are always greater than .
	In other words,  behaves on the (untimed) word  like an alternating automaton without a clock, but with an additional flag telling whether there was a reset on the clock or not. This, however, is equivalent to the behaviour of a  deterministic finite automaton with  states on the (untimed) word . 
	But then, by the choice of  and , 
	we know that starting from ,  also accepts , and thus . 	
	The proof for the other direction is analogous. 
\end{proof}
	
	
	
	
	
	
	
	
			
		
		
		\section{The Universality Problem for Visibly One-Counter Automata}
		We prove that allowing zero tests in a one-clock timed visibly one-counter net results in the undecidability of the universality problem.
		The undecidability of the universality problem for the more general class of one-clock visibly pushdown automata was already stated in Theorem 3 in~\cite{EmmiM06}.
		The proof in~\cite{EmmiM06} is a reduction of the halting problem for two-counter machines. 
		Given a two-counter machine , 
		one can define a timed language  that consists of all timed words encoding a halting computation of . 
		Then a timed visibly pushdown automaton  is defined that accepts the complement of . 
		Altogether,  if, and only if,  does not have a halting computation. 
		The definition of  is similar to the definition of  in the proof of Theorem \ref{theorem_main_lang_inc}. 
		Recall that in the definition of  we did not include a condition that requires every symbol to have a matching symbol two time units \emph{before}, and, as we mentioned, 
		this is the reason for  to contain timed words encoding \emph{faulty} computations of . 
		However, in the definition of  in~\cite{EmmiM06}, such a ``backward-looking'' condition is used. In the proof in~\cite{EmmiM06}, it is unfortunately not clear how the  one-clock timed visibly pushdown automaton  can detect violations of this condition\footnote{More detailed, it is not clear how to construct one-clock timed automata  and  mentioned on p. 10 in~\cite{EmmiM06}. Recall that in the proof for undecidability of the universality problem for timed automata with two or more clocks, it is exactly this backward-looking condition that requires \emph{two} clocks~\cite{DBLP:conf/formats/AdamsOW07}.}. 
		
		Here, we give a complete proof for the subclass of timed visibly one-counter automata. 
		Like the proof of Theorem \ref{theorem_main_lang_inc}, the proof is a reduction of the control state reachability problem for channel machines. 
		We however remark that one can similarly use a reduction of the halting problem for two-counter machines.  		
		
		\
	
		\noindent
		{\bf Proof of Theorem \ref{theorem_univ_undec}} 
		Let  be a channel machine, and let . 
		Define  in the same way as in the proof of Theorem \ref{theorem_main_lang_inc}.
		For every , we define a timed language 
		that 
		consists of all timed words over  that encode computations of  from  to  for some . But in contrast to the proof of Theorem \ref{theorem_main_lang_inc}, 
		 will only contain encodings of \emph{error-free} computations of . 
		
		
		Formally,  is defined using the same conditions as the ones for  in the proof of Theorem \ref{theorem_main_lang_inc} plus an additional condition that requires the number of wildcard symbols in the enoding of the last configuration to be equal to :		
		\begin{enumerate}
		\addtocounter{enumi}{9} 
	\item Between  and , the wildcard symbol  occurs exactly  times. 
		\end{enumerate}	
		Recall that the conditions (1) to (9) guaranteed that the length of consecutive encodings cannot decrease, \ie, the length of every encoding is at least . However, insertion errors may occur, leading to an increase of the length of the encoding and all consecutive encodings.  
		But by the new condition (10), we can exclude the occurrence of such insertion errors. 	We thus have for :
		\begin{lemma}
			\label{lemma_univ_automata}
			There exists some error-free computation of  from  to  for some , if, and only if, . 
		\end{lemma}


Next, we define a timed visibly one-counter automaton with a single clock such that . 
		Hence, by the preceding lemma,  if, and only if, there exists some error-free computation of  from  to  for some .
		
		 is the union of  defined in the proof of Theorem \ref{theorem_main_lang_inc} and the visibly one-counter automaton shown in Figure \ref{figure_visibly_one_counter_automaton}. The latter accepts timed words violating the new condition (10): 
		The automaton non-deterministically guesses the maximum number  of occurrences of the symbol . 
		When leaving , 
		the value of the counter is . 
		The final location , however, 
		can only be reached while reading  or  if the value of the counter is zero. This means that the encoding of the last configuration contains at least one symbol more than the encoding of the initial configuration. 
	\begin{figure}
\begin{center}
		\begin{picture}(107,14)(0,-14)
\node[NLangle=0.0,Nmarks=i,ilength=3,Nw=4.0,Nh=4.0,Nmr=2.0](n0)(5.0,-11.0){}
\node[NLangle=0.0,Nw=4.0,Nh=4.0,Nmr=2.0](n1)(27.0,-11){}
\node[NLangle=0.0,Nw=4.0,Nh=4.0,Nmr=2.0](n2)(50.0,-11){}
\drawedge[curvedepth=4.0](n0,n1){\footnotesize{}}
\drawloop[loopdiam=6](n1){\footnotesize{}}
\drawedge[curvedepth=4.0](n1,n2){\footnotesize{}}
\drawloop[loopdiam=6](n2){\footnotesize{}}
\node[NLangle=0.0,Nw=4.0,Nh=4.0,Nmr=2.0](n3)(76.0,-11){}
\node[NLangle=0.0,Nmarks=f,flength=3,Nw=4.0,Nh=4.0,Nmr=2.0](n4)(100.0,-11){}
\drawedge[curvedepth=4.0](n2,n3){\footnotesize{}}
\drawloop[loopdiam=6](n3){\footnotesize{}}
\drawedge[curvedepth=4.0](n3,n4){\footnotesize{}}
\drawloop[loopdiam=6](n4){\footnotesize{}}
\end{picture}
\caption{The  timed visibly one-counter automaton  for recognizing timed words violating the additional ``backwards-looking'' condition of . }
\label{figure_visibly_one_counter_automaton}
\end{center}
\end{figure}

\section{Conclusion and Open Problems}
The main conclusion of this paper is that even for very weak extensions of timed automata with counters it is impossible to automatically verify whether a given specification is satisfied. 
On the other hand, we may use one-clock timed counter nets as specifications to verify timed automata.
The results on the expressive power of timed counter nets in Sect. 5.2 show that this increases so far known possibilities for the verification of timed automata. 

An interesting problem is to figure out a (decidable) extension of LTL that is capable of expressing properties referring to both time and discrete data structures. 

We remark that all our results hold for automata defined over \emph{finite} timed words. 
We cannot expect the decidability of, \eg, the universality problem for one-clock timed counter nets over infinite timed words, as the same problem is already undecidable for the subclass of one-clock timed automata~\cite{DBLP:journals/fuin/AbdullaDOQW08}. 



\subsection*{Acknowledgements}
I would like to thank Michael Emmi and Rupak Majumdar for helpful discussions on their work on timed pushdown automata. 
I further would like to thank James Worrell  very much for pointing me to MTL's capability of encoding faulty computations of channel machines.



\begin{thebibliography}{Kos97}

\bibitem{DBLP:conf/concur/AbdullaC98}
Parosh~Aziz Abdulla and K\={a}rlis \v{C}er\={a}ns.
\newblock Simulation is decidable for one-counter nets (extended abstract).
\newblock In Davide Sangiorgi and Robert de~Simone, editors, {\em CONCUR},
  volume 1466 of {\em LNCS}, pages 253--268. Springer, 1998.

\bibitem{DBLP:journals/fuin/AbdullaDOQW08}
Parosh~Aziz Abdulla, Johann Deneux, Jo{\"e}l Ouaknine, Karin Quaas, and James
  Worrell.
\newblock Universality analysis for one-clock timed automata.
\newblock {\em Fundam. Inform.}, 89(4):419--450, 2008.



\bibitem{DBLP:journals/tcs/AbdullaJ03}
Parosh~Aziz Abdulla and Bengt Jonsson.
\newblock Model checking of systems with many identical timed processes.
\newblock {\em Theor. Comput. Sci.}, 290(1):241--264, 2003.




\bibitem{DBLP:conf/formats/AdamsOW07}
Sara Adams, Jo{\"e}l Ouaknine, and James Worrell.
\newblock Undecidability of universality for timed automata with minimal
  resources.
\newblock In Jean-Fran\c{c}ois Raskin and P.~S. Thiagarajan, editors, {\em
  FORMATS}, volume 4763 of {\em LNCS}, pages 25--37. Springer, 2007.

\bibitem{AD94}
Rajeev Alur and David~L. Dill.
\newblock A theory of timed automata.
\newblock {\em Theoretical Computer Science}, 126(2):183--235, 1994.

\bibitem{DBLP:conf/sfm/AlurM04}
Rajeev Alur and P.~Madhusudan.
\newblock Decision problems for timed automata: A survey.
\newblock In Marco Bernardo and Flavio Corradini, editors, {\em SFM}, volume
  3185 of {\em LNCS}, pages 1--24. Springer, 2004.

\bibitem{DBLP:conf/stoc/AlurM04}
Rajeev Alur and P.~Madhusudan.
\newblock Visibly pushdown languages.
\newblock In L{\'a}szl{\'o} Babai, editor, {\em STOC}, pages 202--211. ACM,
  2004.

\bibitem{DBLP:conf/hybrid/BouajjaniER94}
Ahmed Bouajjani, Rachid Echahed, and Riadh Robbana.
\newblock On the automatic verification of systems with continuous variables
  and unbounded discrete data structures.
\newblock In Panos~J. Antsaklis, Wolf Kohn, Anil Nerode, and Shankar Sastry,
  editors, {\em Hybrid Systems}, volume 999 of {\em LNCS}, pages 64--85.
  Springer, 1994.

\bibitem{DBLP:journals/entcs/BouchyFS09}
Florent Bouchy, Alain Finkel, and Arnaud Sangnier.
\newblock Reachability in timed counter systems.
\newblock {\em Electr. Notes Theor. Comput. Sci.}, 239:167--178, 2009.

\bibitem{DBLP:conf/hybrid/BouyerFLM10}
Patricia Bouyer, Uli Fahrenberg, Kim~G. Larsen, and Nicolas Markey.
\newblock Timed automata with observers under energy constraints.
\newblock In Karl~Henrik Johansson and Wang Yi, editors, {\em HSCC}, pages
  61--70. ACM, 2010.

\bibitem{DBLP:conf/formats/BouyerFLMS08}
Patricia Bouyer, Ulrich Fahrenberg, Kim~Guldstrand Larsen, Nicolas Markey, and
  Jir\'{\i} Srba.
\newblock Infinite runs in weighted timed automata with energy constraints.
\newblock In Franck Cassez and Claude Jard, editors, {\em FORMATS}, volume 5215
  of {\em LNCS}, pages 33--47. Springer, 2008.

\bibitem{DBLP:journals/pe/BouyerLM14}
Patricia Bouyer, Kim~G. Larsen, and Nicolas Markey.
\newblock Lower-bound-constrained runs in weighted timed automata.
\newblock {\em Perform. Eval.}, 73:91--109, 2014.

\bibitem{Brand:1983:CFM:322374.322380}
Daniel Brand and Pitro Zafiropulo.
\newblock On communicating finite-state machines.
\newblock {\em J. ACM}, 30(2):323--342, April 1983.

\bibitem{DBLP:conf/icalp/BrazdilJK10}
Tom{\'a}s Br{\'a}zdil, Petr Jan\v{c}ar, and Anton\'{\i}n Kucera.
\newblock Reachability games on extended vector addition systems with states.
\newblock In Samson Abramsky, Cyril Gavoille, Claude Kirchner, Friedhelm {Meyer
  auf der Heide}, and Paul~G. Spirakis, editors, {\em ICALP (2)}, volume 6199
  of {\em LNCS}, pages 478--489. Springer, 2010.
  
  
  
  \bibitem{DBLP:conf/concur/ChadhaV07}
  Rohit Chadha and Mahesh Viswanathan.
  \newblock Decidability Results for Well-Structured Transition Systems with Auxiliary Storage.
  \newblock In Lu{\'{\i}}s Caires and Vasco Thudichum Vasconcelos, editors, {\em CONCUR}, volume 4703 of {\em LNCS}, pages 136--150, Springer, 2007.

\bibitem{DBLP:journals/tcs/Dang03}
Zhe Dang.
\newblock Pushdown timed automata: a binary reachability characterization and
  safety verification.
\newblock {\em Theor. Comput. Sci.}, 302(1-3):93--121, 2003.

\bibitem{DBLP:journals/tocl/DemriL09}
St{\'e}phane Demri and Ranko Lazi\'{c}.
\newblock {LTL} with the freeze quantifier and register automata.
\newblock {\em ACM Trans. Comput. Log.}, 10(3), 2009.



\bibitem{DLS-tcs10}
St{\'e}phane Demri, Ranko Lazi{\'c}, and Arnaud Sangnier.
\newblock Model checking memoryful linear-time logics over one-counter
  automata.
\newblock {\em Theor.~Comput.~Sci.}, 411(22-24):2298--2316, 2010.  
  
  
\bibitem{Dickson1913}
Leonard~Eugene Dickson.
\newblock Finiteness of the odd perfect and primitive abundant numbers with n
  distinct prime factors.
\newblock {\em Amer. J. Math.}, 35:413--422, 1913.

\bibitem{EmmiM06}
Michael Emmi and Rupak Majumdar.
\newblock Decision problems for the verification of real-time software.
\newblock In J.~P. Hespanha and A.~Tiwari, editors, {\em HSCC}, volume 3927 of
  {\em LNCS}, pages 200--211. Springer, 2006.

\bibitem{DBLP:conf/atva/EsikFLQ13}
Zolt{\'a}n {\'E}sik, Uli Fahrenberg, Axel Legay, and Karin Quaas.
\newblock Kleene algebras and semimodules for energy problems.
\newblock In Dang~Van Hung and Mizuhito Ogawa, editors, {\em ATVA}, volume 8172
  of {\em LNCS}, pages 102--117. Springer, 2013.

\bibitem{DBLP:conf/ictac/FahrenbergJLS11}
Uli Fahrenberg, Line Juhl, Kim~G. Larsen, and Jir\'{\i} Srba.
\newblock Energy games in multiweighted automata.
\newblock In Antonio Cerone and Pekka Pihlajasaari, editors, {\em ICTAC},
  volume 6916 of {\em LNCS}, pages 95--115. Springer, 2011.

\bibitem{DBLP:journals/jacm/Greibach69}
Sheila~A. Greibach.
\newblock An infinite hierarchy of context-free languages.
\newblock {\em J. ACM}, 16(1):91--106, 1969.

\bibitem{DBLP:conf/lics/HenzingerNSY92}
Thomas~A. Henzinger, Xavier Nicollin, Joseph Sifakis, and Sergio Yovine.
\newblock Symbolic model checking for real-time systems.
\newblock In {\em LICS}, pages 394--406. IEEE Computer Society, 1992.

\bibitem{Higman1952}
Graham Higman.
\newblock Ordering by divisibility in abstract algebras.
\newblock {\em Proceedings of the London Mathematical Society}, 2:236--366,
  1952.

\bibitem{DBLP:conf/fsttcs/HofmanLMT13}
Piotr Hofman, Slawomir Lasota, Richard Mayr, and Patrick Totzke.
\newblock Simulation over one-counter nets is {PSPACE}-complete.
\newblock In Anil Seth and Nisheeth~K. Vishnoi, editors, {\em FSTTCS},
  volume~24 of {\em LIPIcs}, pages 515--526. Schloss Dagstuhl - Leibniz-Zentrum
  fuer Informatik, 2013.

\bibitem{DBLP:conf/rp/HofmanT14}
Piotr Hofman and Patrick Totzke.
\newblock Trace inclusion for one-counter nets revisited.
\newblock In Jo{\"{e}}l Ouaknine and Igor Potapov and James Worrell, editors, {\em {RP}}, volume 8762 of {\em LNCS}, pages 151--162. Springer, 2014. 

\bibitem{DBLP:journals/mst/Ibarra79}
Oscar~H. Ibarra.
\newblock Restricted one-counter machines with undecidable universe problems.
\newblock {\em Mathematical Systems Theory}, 13:181--186, 1979.

\bibitem{DBLP:journals/jcss/JanarEM99}
Petr Jan\v{c}ar, Javier Esparza, and Faron Moller.
\newblock Petri nets and regular processes.
\newblock {\em J. Comput. Syst. Sci.}, 59(3):476--503, 1999.

\bibitem{DBLP:journals/iandc/JancarKMS04}
Petr Jan\v{c}ar, Anton\'{\i}n Kucera, Faron Moller, and Zdenek Sawa.
\newblock {DP} lower bounds for equivalence-checking and model-checking of
  one-counter automata.
\newblock {\em Inf. Comput.}, 188(1):1--19, 2004.

\bibitem{DBLP:conf/birthday/JuhlLR13}
Line Juhl, Kim~Guldstrand Larsen, and Jean-Fran\c{c}ois Raskin.
\newblock Optimal bounds for multiweighted and parametrised energy games.
\newblock In Zhiming Liu, Jim Woodcock, and Huibiao Zhu, editors, {\em Theories
  of Programming and Formal Methods}, volume 8051 of {\em LNCS}, pages
  244--255. Springer, 2013.

\bibitem{DBLP:journals/tocl/LasotaW08}
Slawomir Lasota and Igor Walukiewicz.
\newblock Alternating timed automata.
\newblock {\em ACM Trans. Comput. Log.}, 9(2), 2008.

\bibitem{TCP}
Information Sciences~Institute of~the University~of Southern~California.
\newblock \emph{Transmission Control Protocoll} ({DARPA} {I}nternet {P}rogram
  {P}rotocol {S}pecification), 1981.
\newblock http://www.faqs.org/rfcs/rfc793.html.

\bibitem{DBLP:conf/lics/OuaknineW04}
Jo{\"e}l Ouaknine and James Worrell.
\newblock On the language inclusion problem for timed automata: Closing a
  decidability gap.
\newblock In {\em LICS}, pages 54--63. IEEE Computer Society, 2004.

\bibitem{DBLP:conf/lics/OuaknineW05}
Jo{\"e}l Ouaknine and James Worrell.
\newblock On the decidability of metric temporal logic.
\newblock In {\em LICS}, pages 188--197. IEEE Computer Society, 2005.

\bibitem{DBLP:conf/fossacs/OuaknineW06}
Jo{\"e}l Ouaknine and James Worrell.
\newblock On metric temporal logic and faulty turing machines.
\newblock In Luca Aceto and Anna Ing{\'o}lfsd{\'o}ttir, editors, {\em FoSSaCS},
  volume 3921 of {\em LNCS}, pages 217--230. Springer, 2006.

\bibitem{DBLP:conf/lata/Quaas11}
Karin Quaas.
\newblock On the interval-bound problem for weighted timed automata.
\newblock In Adrian~Horia Dediu, Shunsuke Inenaga, and Carlos Mart\'{\i}n-Vide,
  editors, {\em LATA}, volume 6638 of {\em LNCS}, pages 452--464. Springer,
  2011.

\bibitem{DBLP:conf/lata/Quaas13}
Karin Quaas.
\newblock Model checking metric temporal logic over automata with one counter.
\newblock In Adrian~Horia Dediu, Carlos Mart\'{\i}n-Vide, and Bianca Truthe,
  editors, {\em LATA}, volume 7810 of {\em LNCS}, pages 468--479. Springer,
  2013.

\bibitem{DBLP:journals/corr/Quaas14a}
Karin Quaas.
\newblock {MTL}-model checking of one-clock parametric timed automata is
  undecidable.
\newblock In {\'E}tienne Andr{\'e} and Goran Frehse, editors, {\em SynCoP},
  volume 145 of {\em EPTCS}, pages 5--17, 2014.
  
  \bibitem{DBLP:journals/ipl/Schnoebelen02}
  Philippe Schnoebelen.
\newblock Verifying lossy channel systems has nonprimitive recursive complexity.
\newblock In {Inf. Process. Lett.},
  83(5), pages 251--261, 2002.
  
  
  

\bibitem{DBLP:conf/cav/Cerans92}
K\={a}rlis \v{C}er\={a}ns.
\newblock Decidability of bisimulation equivalences for parallel timer
  processes.
\newblock In Gregor von Bochmann and David~K. Probst, editors, {\em CAV},
  volume 663 of {\em LNCS}, pages 302--315. Springer, 1992.


\end{thebibliography}


\end{document}
