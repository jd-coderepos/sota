\documentclass{eptcs}

\usepackage{amsmath,amssymb}
\usepackage[all]{xy}

\def\shuf{\mathbin{\mathchoice
{\rule{.3pt}{1ex}\rule{.3em}{.3pt}\rule{.3pt}{1ex}
\rule{.3em}{.3pt}\rule{.3pt}{1ex}}{\rule{.3pt}{1ex}\rule{.3em}{.3pt}\rule{.3pt}{1ex}
\rule{.3em}{.3pt}\rule{.3pt}{1ex}}{\rule{.2pt}{.7ex}\rule{.2em}{.2pt}\rule{.2pt}{.7ex}
\rule{.2em}{.2pt}\rule{.2pt}{.7ex}}{\rule{.3pt}{1ex}\rule{.3em}{.3pt}\rule{.3pt}{1ex}
\rule{.3em}{.3pt}\rule{.3pt}{1ex}}}}

\def\raa{\longrightarrow}
\newcommand{\Nat}{\mathbb{N}}
\def\ra{\rightarrow}
\def\Ra{\Rightarrow}
\def\ss{\subseteq}
\def\sss{\sqsubseteq}
\def\raa{\longrightarrow}
\newcommand{\ew}{\lambda}


\begin{document}

\title{On the Existence of Universal Finite or Pushdown Automata
}
\def\titlerunning{On the Existence of Universal Finite and Pushdown Automata}
\author{Manfred Kudlek\footnote{
Sadly, Manfred Kudlek passed away June 18, 2012, before the publication of these proceedings}
\institute{Fachbereich Informatik, MIN-Fakult\"at,
 Universit\"at Hamburg, DE}
}
\def\authorrunning{Kudlek}
\date{}
\maketitle



\begin{abstract}
We investigate the (non)-existence of universal automata for some classes
of automata, such as finite automata and pushdown automata, and
 in particular the influence of the reï¿½presentation and encoding function.
An alternative approach, using transition systems, is presented too.
\end{abstract}

\section{Introduction}

It is well known that there exist universal Turing machines (UTM).
Such a UTM simulates any special Turing machine (TM)  in a certain
way. There are several ways of simulation. One is that a UTM  
simulating a TM  with input  halts if and only if  halts
on input . Another possibility is that any computation step of 
is simulated by  using some number of steps which are be restricted
by some complexity function. In very small UTM's this can be
exponential.

Almost all UTM's constructed so far are deterministic, simulating
deterministic TM's. In \cite{KM} it has been shown that there exist UTM's simulating
all special TM's with complexity constraints. These complexity constraints,
for space or time, are from a subclass of all primitive recursive functions
over one variable. The UTM's have the same complexity constraints.

In both cases, general TM's and those with complexity constraint,
the specific TM  and its input , where  is
the alphabet of , have to be encoded. Such an encoding, and also the
decoding, can be achieved by deterministic finite state transducers (DFST),
which means that encoding and decoding is bijective. The input for a
UTM , to simulate  with input , can then have the form
 where ,  are the encoding functions for , ,
respectively.

If one intends to construct universal machines for weaker automata classes it
should be kept in mind that encoding and decoding for such automata should not
exceed the power of deterministic versions of those machines. Otherwise too
much power and information could be hidden in the encoding.

In \cite{Kud} it has been shown, under this condition, that there don't exist universal
1-way finite automata (FA),  neither deterministic (DFA) nor nondeterministic (NFA) ones. The proof uses arguments on the
number of states of such automata.

So the question arises whether there exist universal universal pushdown automata (UPDA), and if so if
encoding and decoding can be achieved by DFST's, or if deterministic pushdown
transducers (DPDT) are necessary. For general TM's DFST's suffice for encoding
and decoding (e.g. \cite{Min}).

\section{Transducers}

 Pushdown transducers (see e.g. \cite{Gin,Gur}) are just the analogon
to finite state transducers, i.e. pushdown automata with output.

\bigskip\noindent
Formally:

A {\it (non-deterministic) pushdown transducer (PDT)} is a construct
},q_0,Q_f,\rho)Q\Sigma_i\Sigma_o\Delta{\ & stack bottom symbol \\
 & initial state \\
 & set of final states \\
 &
the transition relation\ . \\
\end{tabular}
\end{center}

\bigskip

A {\it deterministic pushdown transducer (DPDT)} is the deterministic version
of PDT. That is,  is a function
.

In the sequel a normal form of PDT's will be considered, being quasi lettering
in input and pushdown, i.e.
.

\bigskip

Contrary to regular languages ({\bf REG}) which are closed under finite state
transductions the context-free languages ({\bf CF})
are not closed under pushdown transductions, neither non-deterministic nor
deterministic. Even linear context-free languages give sets outside {\bf CF}
if a deterministic pushdown transduction is applied. This is shown by the
following examples of DPDT's where  denotes the function
defined by a deterministic transducer.

\medskip

\noindent
Let  and


with

},0{\},{\

\hspace{1cm}},{\.

Then .

\medskip

\noindent
Let  and


with

},0{\

\hspace{1cm}

\hspace{1cm}},{\.

Then .

\medskip

\noindent
Let  and


with

},0{\},1{\

\hspace{1cm}

\hspace{1cm}},0{\

\hspace{1cm}},1{\

\hspace{1cm}

\hspace{1cm}

\hspace{1cm}},{\.

Then .

\bigskip

One also might consider 2-way FST's (2FST). However, {\bf REG} is not closed
under 2-way finite state transductions, as can be seen from the following
example of a 2DFST ( denote move to left, right, or not,
respectively).

\noindent
Let  and


with



\hspace{1cm}

\hspace{1cm}.

Then .

\bigskip


\section{Representations}

A representation of FA, PDA, TM's etc. has to contain information on the
set of states, initial and final states, alphabets, and the set of transitions:

 with e.g. 
 for a PDA.

\noindent
Usually  is represented by an ordered list of elements from , together with
lists for  and . For non-deterministic machines one might also allow
repetitions of list elements. This can give a regular set of representations if
, , and  are fixed.

FA and PDA usually are represented by the list  of their transitions,
putting together the tuples  or  for FA or PDA
respectively, where , and
.

For FA one has a representation , and for PDA

where  stands for .
Together with the input  this gives a representation .
But one might think also of a representation  or even
 where  is the shuffle operation,
and  a separation symbol.

If the first version of representation is encoded by a DFST  the result is a word
 where  is the function associated to . 
This follows from the fact that  is working 1-way.
The same conditions hold for the `inverse', namely for a DPDT  with
associated function . Furthermore,
 has to hold.

\medskip

Considering representations of FA with arbitrary sets of states  and arbitrary
alphabets , states  can be represented by  () and symbols  by
 () over the finite alphabet . Then the set of all
representations of finite automata is given by

.

Clearly, . But note that this holds only for non-deterministic FA.
In the case of DFA there is the condition that a pair 
of state and symbol, represented by  and ,
can appear only once as first components in the list of transitions. 

An analogous property also holds for PDA.

\medskip

Since {\bf REG} and {\bf CF} are closed under FST mappings, encoding (and
decoding) will not lead out from these classes. However, the examples
above show that this does not hold for PDT mappings. Therefore, not to gain too
much power it might be reasonable to have a condition that those PDT mappings
used for encoding and decoding are not leading out from the class {\bf CF}.

\section{Universality?}

In the sequel we shall consider PDA  accepting languages .
Assume that there exists a universal PDA  simulating all specific PDA  over
. Denote this class by .
Let  be the alphabet of . Then, with the first version of
representation,

.

Consider now the special regular (context-free) languages .
A representation of a DFA , being also a PDA or 2DFA, accepting exactly
the language ,
e.g. looks like
\mbox{}.
Together with an input  the representation has the form
.
A DFST maps this into .
Clearly,



\hspace{.5cm}.

Now 



\hspace{1cm}

since {\bf CF} is closed under intersection with regular sets.

Applying the `inverse' DFST mapping  yields

.

Another DFST mapping  with , ,
 gives

,

a contradiction.

\bigskip

These considerations can be summarized as

\medskip

\noindent
{\bf Theorem 1:} If encoding and decoding of specific finite or pushdown automata
have to be
achieved by DFST then there doesn't exist a universal finite automaton,
or
2-way finite automaton or pushdown automaton, simulating all specific
finite automata.
\hfill

\bigskip

It should be remarked, however, that the proof of this theorem cannot be used to
show that the statement also holds for all quasi lettering finite automata.
The reason is that the DFST for encoding has to know the length of  for the
representation  where  and all 
are different.

Therefore we give another proof that this theorem also holds for quasi-lettering
automata. For non-deterministic (quasi-lettering) FA it can be assumed that there
is exactly one initial and exactly one final state, and that the first element
in the list has the form  where  is the initial state and
, and that the last element has the form  where
 is the final state.

\medskip

Let

 a FA, illustrated in Figure 1, where
 
\noindent 
   and

\noindent
  
are fixed and















\hspace{1.2cm}.

	\begin{figure}[htbp]
		\centerline{
		
		}
		\caption{FA}
		\label{fig:upda2}
	\end{figure}


 implies , , ,
.
Note that  is also a PDA.

An encoding of  is given e.g. by



\hspace{1.5cm}



 is a DFST mapping.
Note that  actually depends on .

\medskip

Now assume that



\hspace{.8cm}

is context-free, where QLFA denotes the class of quasi-lettering FA with
set of states , initial state , final state , and alphabet .

Define


\hspace{2cm}.


Obviously,  is regular, implying that  is context-free. But



\hspace{1.2cm}

is not context-free, a contradiction.

\bigskip

If 2-way pushdown transducers are allowed however, and the encoding is not required to
have the form ,
e.g. in a more general form ,
 it is possible to construct a universal PDA,
following an idea by Gh. P\u{a}un et. al.. To be more precise, there exists a
quasi-lettering universal PDA simulating all lettering PDA
in this way.


\medskip
Let  with 
be a lettering PDA, and 

be its representation.
Suppose we allow  to be transduced by a 2-way PDT
 (2PDT).
Then one can choose the coding

where , and  is a coding of  in a fixed alphabet.
Note that  depends on . 
For simplicity let  at first where  is the
identity function. Then  can be 
calculated by a 2PDT that works as follows:
\begin{enumerate}

	\item First go right until the place after \# and print the first symbol of .

	\item Go left and push  to the stack until reading \#.

	\item Go left to the beginning of the input. 

	\item Print  until reading \#.
	
	\item Go further right and simultaniously pop  from the stack.
On empty stack check if the end of the input has been reached.
	
	\begin{enumerate}
		\item If so, print `\%', go to the beginning of the input and copy  one last time and halt.
		\item Otherwise print the current input symbol and repeat from step 2.
	\end{enumerate}
\end{enumerate}

Consider the following PDA  (Figure 2) with 
		   and
		 \mbox{ } for all possible .
		  The  are not finite, but when chosen an appropiate
		  encoding  for the representation of simulated automata,
		  the following idea for an UPDA works with finite alphabets 
		  . For now, assume any transition 
		  in the simulated automaton to be an atomic symbol of our UPDA.
		  
		  At any time 's stack consists of
		  a word  where
 is the stack content
                  and  the current state
		  of  during a simulation. In state ,  first reads a symbol
		   from the input (word ) and afterwards checks whether the 
		  simulated PDA could have read  by travelling through the input
		   and looking for a transition  with
		   being the state  is currently in, and storing the new state
		  and changed stack content of  in its own stack.


	\begin{figure}[htbp]
		\centerline{
		
		}
		\caption{Universal PDA}
		\label{fig:upda}
	\end{figure}

In the construction we have used  etc. as one symbol,
but it works also if an encoding  over a finite alphabet  is used.
E.g., 
with  gives such an encoding.
 Then, point 4\ in the transduction  would contain 
additional steps to encode a transition. E.g. to read symbol 
and print  and so on.
Also, the UPDA  must have additional components for decoding
in all states that have outgoing transitions reading a tuple 
from the input.

This can be achieved as follows. Let  where
 are markers.  is the deliminator of
 encoding ,
and  the deliminator of a block .

In a step , after reading , goes into different states according to .
The stack of  contains \ in the stack is
replaced by UUM\Delta(S,\Sigma,\delta,S_0,S_F)S\Sigma\delta \subseteq S\times (\Sigma\cup\{\ew\}) \times QS_0\ss SS_F\ss Ss\stackrel{t}{\raa}s'(s,t,s')\in \deltaS\cup Ts \stackrel{\ew}{\raa} ss\ews \stackrel{wt}{\raa} s's''s \stackrel{w}{\raa} s'' \land 
		 					s'' \stackrel{t}{\raa} s'\stackrel{*}{\raa}\raaAA=(Q,\Sigma,\delta,q_0,Q_F)QQ_FA=(Q,\Sigma,\Delta,\delta,q_0,Q_F)c\in Q\times\Delta^*(q,wx)\stackrel{a}{\raa}(q',wy) \iff (q,a,x,y,q')\in \delta{\bf X}\subseteq {\bf RE}A=(S,\Sigma,\delta,S_0,S_F)L\in \Sigma^*{\bf X}s_L\in SL((S,\Sigma,\delta,s_L,S_F))=Ln\in \Nat,a\in \SigmaL_n=\{a^n\} \in {\bf REG}Us_{L_n}nUn>|S|U\Box$	

\section{Outlook}

We have shown that there doesn't exist
universal 1-way or 2-way finite automata nor pushdown
automata if encoding and decoding have to be done by
deterministic finite state transducers. However, if
2-way deterministic pushdown transducers are allowed and
for encoding
of a repetition of the specific pushdown automaton to
be simulated, depending on the length of input,
a universal pushdown automaton can be constructed.
Further research has to be done on encoding and decoding
device. Our conjecture is that 1-way deterministic are
not sufficient for the existence of a universal
pushdown automaton.

\section{Acknowledgement}
The author thanks Georg Zetzsche for many fruitful
discussions and contributions to this article.

\begin{thebibliography}{99}

\bibitem{Gin}Ginsburg, S.: {\it The Mathematical Theory of Context-free Languages.}
McGraw-Hill, 1966.

\bibitem{Gur}Gurari, E. M.: {\it An Introduction to the Theory of Computation.}
Computer Science Press, Rockville, 1989.

\bibitem{Kud}Kudlek, M.: {\it On Universal Finite Automata and a-Transducers.}
(In: {\it Grammars and Automata for String Processing: from Mathematics and Computer
Science to Biology and back.} Eds. C. Mart\'{\i}n Vide, V. Mitrana. {\it Topics
in Computer Mathematics}, pp. 163-170, Taylor and Francis, London, 2003.)

\bibitem{KM}Kudlek M., Margenstern, M.: {\it Universal Turing Machines with
Complexity Constraints.} Proc. Intern. Conf. {\it Automata and Formal Languages
VIII}, Publ. Math. Debrecen {\bf 53}, pp. 895-904, 1999.

\bibitem{Min}Minsky M.: {\it Computation: Finite and Infinite Machines.}
Prentice Hall, 1968.

\end{thebibliography}

\end{document}