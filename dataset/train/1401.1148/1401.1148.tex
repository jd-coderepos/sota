\documentclass[10pt]{article}

\usepackage[margin=1.5in]{geometry}

\usepackage{amsmath}
\usepackage{stmaryrd}
\usepackage{MnSymbol}
\usepackage{bussproofs}
\EnableBpAbbreviations

\DeclareFontFamily{OT1}{pzc}{}
\DeclareFontShape{OT1}{pzc}{m}{it}{<-> s * [1.10] pzcmi7t}{}
\DeclareMathAlphabet{\mathpzc}{OT1}{pzc}{m}{it}
\newcommand{\types}{\mathbb{T}}
\newcommand{\tvars}{\mathbb{V}}
\newcommand{\terms}{\Lambda}
\newcommand{\trms}[1]{\mathpzc{Terms}({#1})}
\newcommand{\termsof}[1]{\mathpzc{Terms}({#1})}

\newcommand{\leeq}{\lambda {\eeq}}
\newcommand{\leeqr}{\lambda {\eeq} \mathsf{r}}
\newcommand{\lext}{\lambda\mathpzc{e}}

\newcommand{\vars}{\mathsf{Var}}
\newcommand{\then}{\;\Longrightarrow\;}
\newcommand{\comment}[1]{}
\newcommand{\RA}{\Rightarrow}
\newcommand{\LRA}{\Leftrightarrow}
\newcommand{\lra}{\leftrightarrow}
\newcommand{\lRa}{\longrightarrow}
\newcommand{\lmt}{\longmapsto}
\newcommand{\ora}{\overrightarrow}
\newcommand{\stt}{\lambda_{\to\times}}
\newcommand{\bool}{\mathbb{B}}
\newcommand{\nat}{\mathbb{N}}



\newcommand{\hired}[1]{\textcolor{red}{#1}}
\newcommand{\hiblue}[1]{\textcolor{blue}{#1}}
\newcommand{\higreen}[1]{\textcolor{darkgreen}{#1}}
\newcommand{\greyout}[1]{\textcolor{gray}{#1}}
\newcommand{\whiteout}[1]{\textcolor{white}{#1}}

\newcommand{\sta}{*}
\newcommand{\lstar}{{\lambda\!\!\:\sta}}
\newcommand{\lstars}{\lstar}
\newcommand{\lstarss}{{\lambda\!\sta}}

\newcommand{\qomikron}{\ocirc}
\newcommand{\qfun}{\mathbin{{\ooalign{\cr\raise.29ex
\hbox{}\cr}}}}
\newcommand{\qprod}{\otimes}
\newcommand{\absof}[1]{{|{#1}|}}
\newcommand{\qlam}{\mathsf{Lam}}
\newcommand{\qapp}{\mathsf{App}}
\newcommand{\qpair}{\mathsf{Pair}}
\newcommand{\qproj}{\mathsf{Proj}}
\newcommand{\sttcontext}{\Gamma(\lambda_{\to\times})}
\newcommand{\mora}{|M|\ora{[\hat{x}^*/ x]}}
\newcommand{\tprime}{t'\ora{[\hat x^*/x]}}
\newcommand{\qbeta}{\beta\!\!\!\beta}
\newcommand{\ee}[1]{\simeq_{#1}}
\newcommand{\eqv}{\ee{}}
\newcommand{\env}{\mathsf{Env}}
\newcommand{\btype}{\mathbf{Type}}
\newcommand{\lsimple}{\lambda_{\to}}
\newcommand{\setof}[1]{\{{#1}\}}
\newcommand{\seqof}[1]{\langle{#1}\rangle}
\newcommand{\semof}[1]{\llbracket{#1}\rrbracket}
\newcommand{\sse}{\subseteq}

\newcommand{\lift}{\mathsf{Lift}}
\newcommand{\cons}{\mathsf{Cons}}
\newcommand{\refl}[1]{{\mathsf{r}({#1})}}

\newcommand{\fv}{\mathsf{FV}}
\newcommand{\fvof}[1]{\fv({#1})}
\newcommand{\dom}{\mathsf{dom}}
\newcommand{\ol}[1]{\overline{#1}}

\newcommand{\qFun}{\mathbin{{\ooalign{\cr\raise.037ex
\hbox{}\cr}}}}
\newcommand{\qSum}{\mathbin{{\ooalign{\cr\raise.036ex
\hbox{}\cr}}}}
\newcommand{\ext}{\mathsf{sub}}
\newcommand{\qsta}{\mathord{\oast}}
\newcommand{\qU}{\mathbin{{\ooalign{\cr\raise.037ex
\hbox{}\cr}}}}
\newcommand{\qT}{\mathbin{{\ooalign{\cr\raise.037ex
\hbox{}\cr}}}}
\newcommand{\qEq}{\mathbin{{\ooalign{\cr\raise.15ex
\hbox{}\cr}}}}
\newcommand{\qRel}{\mathbin{{\ooalign{\cr\raise.2ex
\hbox{}\cr}}}}
\newcommand{\lstau}{{\lstar U}}
\newcommand{\uelim}{\mathsf{U{-}elim}}
\newcommand{\tspace}{\hskip 3cm\ \ \phantom{U}\ \ }


\newcommand{\eqsta}{\refl{\qsta}}
\newcommand{\eqfun}{{\qFun}\!{}^*}
\newcommand{\eqsum}{{\qSum}\!{}^*}
\newcommand{\eqtype}{\mathpzc{Eq}} 
\newcommand{\reltype}{\mathpzc{Rel}} 
\newcommand{\idtype}{\mathpzc{Id}} 
\newcommand{\lstaue}{\lstau\!{\ee{}}}
\newcommand{\eps}{\epsilon}
\newcommand{\eqEq}{{{\qEq}\!{}^*}}
\newcommand{\eqRel}{{{\qRel}\!{}^*}}


\newcommand{\thra}{\twoheadrightarrow}


\newcommand{\eq}{\quad=\quad}
\newcommand{\of}{\quad : \quad}
\newcommand{\de}{\quad := \quad}


\comment{
\newcommand{\pzA}{\mathpzc{A}}
\newcommand{\pzB}{\mathpzc{B}}
\newcommand{\pzC}{\mathpzc{C}}
\newcommand{\pzE}{\mathpzc{E}}
}

\newcommand{\pzA}{A_*}
\newcommand{\pzB}{B_*}
 
\newcommand{\phan}{\phantom{\eq}\;}
\newcommand{\phanq}{\phantom{\eq\qquad}}

\newcommand{\hista}{\!\raisebox{1mm}{}}
\newcommand{\bsim}{\raisebox{-1mm}{\scalebox{1.5}{}}}
\newcommand{\blam}{\raisebox{-2mm}{\scalebox{2.1}{}}}
\newcommand{\bseq}{\raisebox{-1mm}{\scalebox{1.8}{}}}
\newcommand{\ic}{\mathtt{I}}
\newcommand{\kc}{\mathtt{K}}
\newcommand{\yc}{\mathtt{Y}}
\newcommand{\indc}{\mathsf{Ind}}
\newcommand{\cnc}{\mathsf{c}}

\newcommand{\annoy}{{\sc \ul{Question:}}}
\newcommand{\annoyok}{{\sc \ul{Question:}\ }}
\newcommand{\istype}{\mathtt{\ type}}

\newcommand{\scomb}{\mathtt{S}}
\newcommand{\inl}{\mathsf{in}_1}
\newcommand{\inr}{\mathsf{in}_2}
\newcommand{\case}{\mathsf{case}}

\newcommand{\emptytype}{\mathbf{0}}
\newcommand{\unittype}{\mathbf{1}}
\newcommand{\ttt}{\mathtt{t}\!\!\mathtt{t}}
\newcommand{\exfalso}{\mathtt{ef}}
\newcommand{\point}{\mathtt{pt}}
\newcommand{\limp}{\supset}

\newcommand{\pdot}{\phantom{.}}

\newcommand{\rrule}{\hspace{1em}\lRa\hspace{1em}}
\newcommand{\eeq}{\simeq}
\newcommand{\seq}{{\eeq}^*}
\newcommand{\srel}{{\sim}^*}

\newcommand{\ssim}{{\sim}}
\newcommand{\too}{\quad\longrightarrow\quad}

\newcommand{\optarg}[1]{{\textcolor{Periwinkle}{\setof{#1}}}}

\renewcommand{\refl}[1]{\mathsf{r}({#1})}
\newcommand{\sym}[1]{\ol {#1}}
\newcommand{\tr}[2]{{#1} \circ {#2}}
\newcommand{\Sub}[3]{\mathpzc{Sub}_{#1}({#2},{#3})}
\newcommand{\sub}[4]{\mathpzc{sub}_{#1}\optarg{#2}({#3},{#4})}

\newcommand{\trip}[3]{
{\scriptsize \left[
  \begin{array}{l}
    {#1}\\
    {#2}\\
    {#3}
  \end{array}
\right]}}

\newcommand{\tripar}[3]{
{\scriptsize \left(
  \begin{array}{l}
    {#1}\\
    {#2}\\
    {#3}
  \end{array}
\right)}}

\newcommand{\trisub}[6]{
{\scriptsize \left(
  \begin{array}{r p{-2mm} l}
    {#1}&/&{#2}\\
    {#3}&/&{#4}\\
    {#5}&/&{#6}
  \end{array}
\right)}}

\newcommand{\err}{}
\newcommand{\ups}{\upsilon}
\newcommand{\envt}{\Gamma_0}
\newcommand{\rsa}{\rightsquigarrow}


\newcommand{\turn}[1]{{#1}{\rotatebox[origin=c]{180}{}\!}}
\newcommand{\flip}[1]{\mathbin{\rotatebox[origin=c]{-90}{}\!{}_{#1}}}
\newcommand{\sflip}[1]{\mathbin{\scalebox{0.7}{\rotatebox[origin=c]{-90}{}}\!{}_{#1}\!}}


\newcommand{\rec}{\mathpzc{Rec}}
\newcommand{\llra}{\longleftrightarrow}
\newcommand{\df}{\quad:=\quad}

\newcommand{\bset}{\mathsf{Set}}

\newcommand{\lstarn}{\lstar\!{}_n}
\newcommand{\lrra}{\longrightarrow}
\newcommand{\llla}{\longleftarrow}
\newcommand{\lth}{\mathcal H}

\newcommand{\ul}[1]{\underline{#1}} 
\usepackage{url}
\usepackage{relsize}
\usepackage{graphicx}
\usepackage[dvipsnames]{xcolor}
\usepackage{rotating}
\usepackage{amsthm}

\renewcommand{\bsim}{{\raisebox{-1mm}{\scalebox{1.5}{}}}}


\newenvironment{lemma}{{\sc Lemma.}}{}
\newenvironment{definition}{{\sc Definition.}}{}
\newenvironment{theorem}{{\sc Theorem.}}{}

\title{Internalization of extensional equality}
\author{Andrew Polonsky}

\bibliographystyle{eb}

\usepackage{ebharvard}

\usepackage{titlesec}
\titlelabel{\thetitle.\quad}


\renewcommand{\lext}{\leeq}
\renewcommand{\optarg}[1]{\greyout{#1}}

\newcommand{\iso}{\stackrel{\eeq}{\to}}
  \newcommand{\phabra}{\phantom{\{}}

\newcommand{\objof}[1]{\mathsf{Ob}({#1})}
\newcommand{\homsym}{\mathsf{Hom}}
\begin{document}
\maketitle

\begin{abstract}
We give a type system in which the universe of types is closed by
reflection into it of the logical relation defined
externally by induction on the
structure of types.
This contribution is placed in the context of the search for a
natural, syntactic construction of the extensional equality type
(\cite{tait}, \cite{thorsten1999}, \cite{coquand}, \cite{harper}, \cite{perML}).
The system is presented as an extension of , the terminal pure
type system in which the universe of all types is a type.
The universe inconsistency is then removed by the usual method of
stratification into levels.
We give a set-theoretic model for the stratified
system.  We conjecture that Strong Normalization holds as well.
\end{abstract}

\section{Background: the problem of extensionality}

In recent years, the problem of extensionality in type theory has
received increasing attention.  In part, this is due to
type theory emerging as the language of choice for
computer formalisation of mathematics.
(\cite{Gonthier},  \cite{thehomotopybook}.)

The fundamental notion of this language, that of a \emph{type},
is a notion of collection which bases membership on the
syntactic form of the objects.  Accordingly, the notion of
equality between objects of a given type is likewise based
on their syntactic form:
two expressions are judged as denoting equal objects
if one can be transformed into another by a finite
sequence of syntactic manipulations.

Since a general number-theoretic function can in principle be
implemented in any number of ways, there will be
different expressions defining the same function which cannot
be transformed from one to another using syntactic manipulations only.
For example, the function which maps a vector of numbers
to a rearrangement of it listing the numbers in non-decreasing order,
can be implemented using bubble-sort or quick-sort processes,
and these cannot be transformed into one another by local
simplifications.

Therefore, basing equality on syntactic form alone leads to the
failure of \emph{function extensionality}, the principle stating that
two functions are equal if they are pointwise equal:

At the same time, this principle is deeply embedded into the
language and culture of mathematics.  After set theory
became the standard language of 
communicating mathematical ideas, the intuitive notion of ``function''
came to be understood through its encoding into
set theory ---  as a set of ordered pairs.
Since sets are extensional almost by definition, so must be functions in
the set-theoretic foundations.

In the usual mathematics, the above ``principle'' is therefore a
matter of linguistics.
\footnote{At the time of
writing these words, the definition of the word ``function'' given by
Google is that it is an ``expression with one or more variables''.
This corresponds to the type-theoretic notion of a function ---  a lambda term ---
and not the set-theoretic notion (a set of pairs having certain
properties).

The middle-school definition of a function as a ``black box''
which \emph{transforms} its input into output is
likewise more faithfully captured by the lambda calculus standpoint.
}

But not so in type theory. Elementary mathematical arguments often become
clumsy when translated to type theory, because the principle (FE) is
not available.

In order to develop set-theoretic mathematics in type theory,
it would be convenient to have a notion of equality that
justified the above principle.  Such a notion may then be called
\emph{extensional equality}.  Unfortunately, the known constructions
of this notion result in violation of key design principles of type theory.

\section{Approaches to extensionality}

The classical approach originally pursued by \cite{itt} is
to extend the definitional (syntactic) equality between expressions,
by allowing expressions to be declared syntactically equal whenever
the statement of their equality is proved in the system's logic.
(That is, mathematical equality is reflected back into the syntax.)

This fixed the problem with (FE), but the cost was too great:
syntactic equality, being now dependent on propositions, became
undecidable, and so did type-checking.  But type theory, following
Curry--Howard paradigm, identifies proving propositions with
inhabiting types.  Thus undecidability of type-checking means it is
not possible to decide whether a purported proof is indeed a proof,
making type theory useless as a foundational system. \footnote{
After all, the point of a formal system is not to abstractly talk
about the set

but rather to offer \emph{convenient} tools whereby membership (of some elements)
in this set can be established with finite effort.}

A more recent idea is due to \cite{hlc},
who discovered a single sentence in the language of type theory
which, when assumed as an axiom, makes the intensional identity type
behave like the extensional one.  The axiom is a strong form of \emph{universe
extensionality} (\cite{groupoid}) --- stating that isomorphic types
are equal --- and has many deep consequences for type theory,
including (FE).

However, assuming an axiom in type theory without specifying
its combinatory behavior with respect to other symbols
results in the loss of another crucial property of \emph{canonicity}.
This property guarantees that every type-theoretic construction
is conceptually computable, in the sense that every definition can
be computed by trivial simplification steps to a value.

A computational interpretation for Voevodsky's axiom has been recently
given by Coquand and collaborators (\cite{cubes}).  Their solution is
\emph{semantic}:
all relevant computations are performed in
a constructive model of homotopy types.
The notion of extensional equality is given meaning only implicitly,
via its interpretation in the homotopy model of type theory.

It would appear worthwhile to have a native, type-theoretic construction
of extensional equality which did not assume the univalence axiom or
the homotopy interpretation.  

\section{Extensional equality by induction on type structure}

Yet another approach is to define
extensional equality by induction on type structure.
Here one defines the equality relation
\emph{externally} to the type system, by relating
certain elements of the (free) term model of the system.

This is actually the oldest approach to the problem,
having led \cite{Gandy} to derive the
\emph{logical relations principle}, a basic tool in metatheoretic
studies of type systems.

In 1995, in a paper titled ``Extensional Equality in the Classical
Theory of Types'', William Tait assumed the denotation of the notion of
extensional equality to be the canonical equivalence relation
defined by the logical relations principle.  While this idea is
certainly familiar to many researchers,
it appears to have missed a general announcement.

Let it thus be made explicit. \vspace{0.3cm}

{\centering \framebox{
\begin{minipage}{11cm}
{\sc \ul{Extensionality Thesis}.} \emph{The extensional equality type
  is the canonical equivalence 
  relation defined between elements of the term
  model of type theory  by induction on type structure.} 
\end{minipage}
} \par}

\vspace{0.3cm}

The challenge in realizing Tait's program is that the equality relation,
being defined externally, is a priori valued in the types of the meta-level.
In order to talk about equality \emph{within} the system, we must
reflect this relation from the meta-level back into the syntax.  This
step is somewhat delicate, and indeed has restricted much work along
these lines to ``truncated'' systems, in which the equality type
\emph{cannot} be iterated to yield an infinite tower


At the same time, we certainly do want to iterate the equality type,
in order for it to generalize Martin-L\"of
intensional identity type .

Herein lies our main contribution.  We describe a type system 
in which
the logical relation is reflected into the type structure via a new
type constructor, the type  of \emph{type equalities}
(between types ).  The (unique) elimination rule for this type associates to
every  a heterogeneous \emph{dependent equality}
.  The introduction rules for this type
assert that every type constructor preserves type equality, including
type equality itself.  The computation rules capture the logical
conditions associated to the corresponding type constructor.

We give a
complete proof of the
\emph{preservation theorem} for , which states that every
expression preserves the (reflected) logical relation.  In
particular, every closed term  is related to itself, and the
type  lives in the same universe as .

For detailed development, from the simply typed lambda
calculus to the system presented here, we refer the reader to
our earlier report (\cite{ett1}).

The system  gives a satisfactory definion of extensional
equality for \emph{closed} types.  In order for equality to really
behave like a``type constructor'', much work remains to be done.

In the future, we would like to internalize the preservation operator, so that
extensionality of terms could be witnessed internally (cf.\ \cite{intpar}).
We also want equality to satisfy the higher-dimensional analogues
of symmetry and transitivity: the \emph{Kan filling conditions}.
An ultimate benchmark of success would be to validate all
of the axioms for equality isolated by \cite[p.34]{coquand}.

From now on, we use the words ``extensional equality''
in the sense of the thesis above.

\section{Related work}

To place our paper in context, we review some recent developments in
extensional equality.
\begin{itemize}
\item 
\emph{Observational Equality Now!}, \cite{ott}

The authors give a complete treatment of the 1-dimensional theory of equality (setoid level), including symmetry, transitivity, and the relevant computation
rules.  The constructions are performed in a metatheory having
the uniqueness of identity proofs (UIP) principle.
\item 

\emph{Equality and dependent type theory}, \cite{coquand}

These slides, which had a great influence on our own investigations,
contain early ideas for computing with univalence, taking the
syntactic rather than semantic route.
\item 
\emph{Canonicity for 2-dimensional type theory}, \cite{harper}

As stated in the title, this theory is truncated at level 2.
Nevertheless, it gives a complete computational treatment
of the groupoid operations.  The authors assume propositional reflection in the metatheory.
\item 
\emph{Computational interpretation of parametricity},
\cite{intpar}

Parametricity theory is intimately connected to extensional equality.

One key difference obtains in the
treatment of universes.  In the context of parametricity, the relation on the
universe associates to each pair of types the type of binary relations
between them.  In our notation, this would appear as the rewrite rule



When defining extensional equality, we want the relation on the
universe to be type equality.  This may still allow interpretation by weaker notions of
equality --- such as isomorphism or homotopy equivalence --- but should
certainly prohibit general relations between types.

Instead, the relation on the universe in  associates to types
 the type of equalities between  and :

The type  is thought of as the type of codes for relations with
certain properties; those properties are validated by various
notions of ``equivalence of types''.

Another difference is that the preservation theorem in parametricity results
is not iterable: even when carried out in a ``reflective'' PTS, the
witnesses of parametricity are typed in a higher universe than the
original terms.

In contrast, when we stratify , the ``parametricity witnesses''
will actually be typed in a \emph{lower} universe than the given
terms. (This choice will be forced upon us by semantic considerations.)

On the other hand, \cite{intpar} go much further in internalization,
reflecting the preservation operator into the syntax as well.
In our case, the preservation
map is only a meta-level operation on pseudoterms.

\item 
P. Martin-L\"of, lectures given at CMU, \cite{perML}

This talk series gives a systematic treatment of the (1-dimensional) relation model.
\item
\emph{Internalization of the groupoid model}, \cite{matthiu}

A complete formalization of the 2-dimensional theory in the Coq proof assistant.
\end{itemize}

As compared to the previous results,
our contribution internalizes the
external logical relation
in a way that neither limits the resulting theory to a low
dimension, nor requires any axioms in the metatheory.


In the next section we present the system .
Section \ref{ext-thm} gives the proof of
Tait's extensionality theorem for .
We use this theorem to derive extensional equality for closed types
in Section \ref{s:exte}.
Afterwards, we stratify the system to make it consistent,
and give a natural set-theoretic model.

\section{}
In this section, we describe a type theory in which
extensionality of terms is witnessed by terms in the same system.
Denoted by , the system is an extension of , the ``naive''
dependent type theory, by a new type, called
\emph{type equality}.
The typing rules for this type ensure that extensionality of every term is witnessed
within the system.
\footnote{
There is some reason to believe that 
is a minimal dependent type theory with this property,
since it is obtained from the ``canonical'' PTS 
by closing the type structure under reflection of the standard
logical relation.  (See (\cite{ett1}) for additional commentary.)
}

The choice of  as the base system is
motivated by the fact that, although inconsistent, this system is by
far and away the simplest formulation of dependent type theory.
We found that postponing proper universe management
until the rules for the new type are clearly set out
simplifies the presentation considerably.

Afterwards, the standard recipe for turning an inconsistent type
theory into a consistent one by stratifying the universes may be
applied, and the proofs given earlier remain valid.
Stratification of  will be given in Section \ref{strat}.
 
The system admits a meta-level operation

which raises by one the dimension of a given term.
Using this operation, we prove a new, fully internal form of the \emph{extensionality
  theorem} from \cite{tait}.

The dependent version of the theorem requires one to
consider a certain relation on the universe of types, and for every pair of
types related by it, a new ``heterogeneous'' relation between terms of
these types.  We shall now define these concepts.

\subsubsection*{Intuitive description}
We set out by stipulating that there be a binary relation
 on the universe of types.
It is a new type constructor, and we call it \emph{type equality}.
For types , the type of equalities between  and  is
denoted .

Every equality  between  and  induces a binary
relation  between  and .  The
-operator is the elimination rule for the type .

For  and , we think of the type  as
representing equalities between  and  which are
``lying over'' .  To articulate this
intuition, we introduce the notation


We add term constructors which assert that every type constructor
preserves type equality, including type equality itself.  These terms
are the constructors for the type .

For instance, the constructor
corresponding to  asserts that  preserves type
equality.  The corresponding introduction rule becomes


Finally, for every combination of an introduction rule and elimination
rule, there must be a reduction rule specifying how the two
interact.  In , there are four type constructors: ,
, , and .  Thus, there are 
reduction rules for .

The reduction rules capture the logical conditions corresponding
to the four
type constructors.  They will insure that the extensional equality on
every type is \emph{definitionally} equal to a type expressible with
basic constructors.
\footnote{
This is also the reason why the type  does not require axioms stating that
it preserves equality:\\ it is not a proper type constructor, but 
reduces to more basic types according to the structure of .}

For instance, extensional equality on the  and  types
is


Leaving the full treatment of extensional equality to Section \ref{s:exte},
suffice it to say that the reduction rules for type equality are wholly
motivated by generalizing these ``logical conditions'' to the dependent
case.
Conversely, our definition of extensional equality will indeed
arise as the specialization of the heterogeneous
relation  to the case when 
and when  is the ``degenerate path'' .

We are ready to present the system .

\subsubsection*{Formal description}

\begin{description}
\item[Syntax]:
\vspace{-0.5cm}

\item[Typing] \optarg{\text{(greyed out font demarcates implicit arguments)}}:
\begin{prooftree}
  \AXC{ \fbox{} }
\UIC{}
\end{prooftree}
\begin{prooftree}
\AXC{}
\AXC{}
\BIC{}
\noLine
\UIC{}
\end{prooftree}
\begin{prooftree}
\AXC{}
\AXC{}
\BIC{}
\end{prooftree}
\item[Reduction]:

\end{description}
In what follows, we will often see a pattern where three operations
of the same type appear in a row,
like the triple-product sequences in the last reduction rule.
To reduce clutter in such expressions, we introduce the following notations.



With these conventions, the reduction rules for the type  may
be rendered as


\section{The -operator} \label{ext-thm}
We now define the map  which will satisfy

The intuition is that  gives the transport of 
over a ``formal path'' in the context.
\newpage

\begin{definition}
  Let  be the operation of apostrophizing every variable,
bound or otherwise.
\end{definition}

\begin{lemma}
    \begin{itemize}
    \item 
    \item 
    \item 
    \end{itemize}
  \end{lemma}
  \begin{proof}
   Typography.  \end{proof}

  \begin{definition}
The operation  is defined by induction on term structure.

In the equations that follow, the symbols , , , etc.\ are free
variables: the appearence of  in a {\bf sub}script is merely a suggestive choice of
naming the variables.

f a)^* &\eq f^* a a' a^* \

\end{definition}


\begin{lemma} \label{subst}

\end{lemma}

\begin{proof}
  By induction on the structure of .
\end{proof}

\begin{lemma} \label{conv}

\end{lemma}

\begin{proof}
By induction on the length of the reduction--expansion sequence in
  , it suffices to show
  

First we argue that it is enough to consider contractions at the root
of the term.

Indeed, suppose that , , and  by
contraction
at the root.

Let , where  is fresh.

Using Lemma \ref{subst}, we write

Since -reduction is itself a congruence, it suffices to verify
that the instances of each variable are reducible.  That  and 
is clear; that  remains to be proved.

There is thus no loss of generality in assuming that the
redex is contracted at the root.

We now treat each reduction rule in order.

\newcommand{\st}{.\hspace{0.5em}}
\begin{description}
\item[\underline{}] Given , we are to show that

Indeed,

by Lemma \ref{subst}.  Thus .
\item[\underline{}] We have
  
\item[\underline{}] Consider 
We have 

\item[\ul{}]  Consider

Let  be the reduct on the right.  We have

By inspection, this is exactly .  Let's check the innermost
quantifier:

(Here we used that .)
Indeed,

as required.
\end{description}
Other cases are treated similarly.
\end{proof}

\begin{definition}
  Let 
be a context.  Put

\end{definition}

\newpage
\begin{theorem}
\qquad\qquad
\end{theorem}

\begin{proof}
  We proceed by induction on .
  \begin{description}
  \item[Axiom] For the axiom rule , we have

By conversion rule, .
\item[Variable] Given the derivation
\begin{prooftree}
  \AXC{}
  \UIC{}
  \end{prooftree}
we have, by induction hypothesis, that

and hence .

Clearly, .

Then  is a valid context, and

\item[Weakening] Given the derivation
  \begin{prooftree}
  \AXC{}
  \AXC{}
  \BIC{}
\end{prooftree}
the induction hypothesis gives that

Then  is a valid context, and

(by applying weakening thrice).

\item[Formation of ,] 
Suppose we are given
\begin{prooftree}
  \AXC{}
  \AXC{}
  \BIC{}
\end{prooftree}
Induction gives

By lemmata, we also have apostrophized versions of these:

Together, the given data, the primed version, and the inductive
version,
provide the hypotheses necessary for the application of the -rule:
\begin{prooftree}
  \AXC{}
\AXC{}
\BIC{}
\end{prooftree}
Since , the above
judgement has the desired form.

The case of -formation is treated congruently.

\item[-Formation]  This is like the previous case, but easier; given
\begin{prooftree}
  \AXC{}
  \AXC{}
  \BIC{}
\end{prooftree}
we have that , and also, by induction, that

These data allow us to apply the -rule, yielding

which type converts to , as required.
\item[-Formation]
Suppose we are given
\begin{prooftree}
  \AXC{}
  \AXC{}
  \AXC{}
  \TIC{}
\end{prooftree}
Then we have , and by
induction


We work in .  Reducing the type of , we get

When written in explicit form, this looks like


By definition of , 


Thus, for any , , we
find that


In particular, the type of  is exactly 


Since , we conclude that

\item[Abstraction] Given
  \begin{prooftree}
    \AXC{}
    \AXC{}
    \AXC{}
    \TIC{}
  \end{prooftree}
We have, by IH, that

Observe that our target type converts as

The first two induction hypotheses give us that this is a
well-formed type.  The third, after three applications of
the abstraction rule, gives

The subject of this judgement is equal to .\\
The type predicate converts to .
\item[Application] Suppose we are given
  \begin{prooftree}
    \AXC{}
    \AXC{}
    \AXC{}
    \TIC{}
  \end{prooftree}
The induction hypotheses are

Working in , we need to show that

Equivalently, we need to show that

(where we used the substitution lemma to rewrite ).

Applying the converison rule to \eqref{app3} gives

Then, by a triple use of the application rule, we have

which is typographically consistent with \eqref{appGoal}.
\item[Pairing] Let us be given
\begin{prooftree}
  \AXC{}
  \AXC{}
  \AXC{}
  \TIC{}
\end{prooftree}
We work in .  By induction, we have

We may rewrite the latter as


Using these data, the following sequence of judgements may be verified:

\item[Projections] Next, we consider the inference rules
  \begin{prooftree}
    \AXC{}
    \AXC{}
    \AXC{}
    \TIC{}
    \noLine
    \UIC{}
  \end{prooftree}
We have

The judgements (p1) and (p2) are of the required form.
\item[Conversion] Next, suppose we are given the inference
\begin{prooftree}
  \AXC{}
  \AXC{}
  \AXC{}
  \TIC{}
\end{prooftree}
We are to show that .

From the given data, we know that

Thus 

By Lemma \ref{conv}, we have


By IH, we also have .
Using \eqref{M-conv} and \eqref{B-conv},
we may apply the conversion rule to this judgment
to obtain

\item[-Congruence]  Let us be given
\begin{prooftree}
\AXC{
  (\sta^*)^* \quad:\quad &\sta^* \sim_{(\sta \eeq \sta)^*} \sta^*\\
  (\sta^*)^* \quad:\quad &\sta^* \sim_{\seq \sta^* \sta^*} \sta^*\\
 (\sta^*)^* \quad : \quad &\prod \tripar{A :\sta}{A':\sta}{A^* : A {\sim_{\sta^*}} A'}
\prod \tripar{ B:\sta}{ B':\sta}{ B^* : B  {\sim_{\sta^*}} B'}.\ (A \sim_{\sta^*} B)
\eeq (A' \sim_{\sta^*} B')
(\sta^*)^* = \blam \tripar{A:\sta}{A':\sta}{A^* : A{\eeq}A'}\;
\blam \tripar{B:\sta}{B':\sta}{B^* : B {\eeq} B'}.\; \seq A^* B^*
& (\Pi^* [x,x_1,x_*] : A_*.\ B_*)^* \label{picongterm}\\ &\eq
\blam \tripar { f : \Pi x{:}A.B}{ f':\Pi x'{:}A'.B'}{ f^*
 : f \sim_{\Pi^* A^* B^*} f'}\notag
\blam \tripar {f_1 : \Pi x_1{:}A_1.B_1} {f'_1:\Pi x_1' {:}A_1'.B_1'} {f^*_1
 : f_1 \sim_{\Pi^* A^*_1 B^*_1} f'_1}.\\
&\phantom{\eq\;}\,
\prod\hista \trip{a}{a'}{a^*} : A^*\;
\prod\hista \trip{a_1}{a_1'}{a_1^*} : A_1^*\;\notag
\prod\hista \trip{a_* }{a_*'}{a_*^*} : A_*^*  \tripar{a}{a'}{a^*} \tripar{a_1}{a'_1}{a^*_1}.\\
&\phanq
B^*_* \trip{a/x}{a'/x'}{a^*/x^*}
\trip{a_1/x_1}{a_1'/x_1'}{a_1^*/x_1^*}
\trip{a_*/x_*}{a_*'/x_*'}{a_*^*/x_*^*}
\tripar{f a}{f' a'}{f^* a a' a^*}
\tripar{f_1 a_1}{f'_1 a'_1}{f^*_1 a_1 a'_1 a^*_1} \notag

\label{pi-cong}
\Pi^* A_* B_* \sim_{\seq (\Pi x{:}A.B)^* (\Pi x_1{:}A_1.B_1)^*}
\Pi^* A'_* B'_*
(\Pi x{:}A.B \eeq \Pi x{:}A_1.B_1) \eeq (\Pi x{:}A'.B' \eeq
\Pi x{:}A_1'.B_1')
&\qquad \quad \ssim(\seq (\Pi x{:}A.B)^* (\Pi x_1{:}A_1.B_1)^*)\\
&\eq \lambda e : (\Pi x{:}A.B \eeq \Pi x_1{:}A_1.B_1)\,
  \lambda e' : (\Pi x'{:}A'.B' \eeq \Pi x_1' {:} A_1'. B_1').\\
&\phanq  \prod \tripar { f : \Pi x{:}A.B} { f' : \Pi x'{:}A'.B' }
{ f^* : f
\sim_{(\Pi x{:}A.B)^*} f'}  \prod \tripar { f_1 : \Pi x_1{:}A_1.B_1} { f_1' : \Pi
  x_1'{:}A_1'.B_1' }  { f_1^* : f_1 \sim_{(\Pi x_1{:}A_1.B_1)^*} f_1'}\\
&\phanq \qquad \qquad (f \sim_e f_1) \eeq (f' \sim_{e'} f'_1)

(f \sim_{\Pi^* A_* B_*} f_1) \eeq (f' \sim_{\Pi^* A_*' B_*'} f'_1) =
\hspace{-4cm}
\label{toprovepicong}\\
& \Pi a{:}A \Pi a_1{:}A_1 \Pi a_* : a \sim_{A_*} a_1. (f a
\sim_{B_*[a,a_1,a_*/x,x_1,x_*]} f_1 a_1)\notag\\
&   \eeq  \Pi a'{:}A' \Pi a'_1{:}A'_1 \Pi a'_* : a' \sim_{A'_*} a'_1. (f' a'
\sim_{B'_*[a',a'_1,a'_*/x',x'_1,x'_*]} f'_1 a'_1)\notag
A^*_* \tripar{a} {a'} {a^*} \tripar{a_1} {a_1'} {a_1^*} : (a \sim_{A_*} a_1) \eeq (a'
\sim_{A'_*} a'_1) (\Gamma, x : A, x_1:A_1,x_*: x \sim_{A_*} x_1)^*
\vdash B_*^* : B_* \sim_{\seq B^* B_1^*} B_*'(\Gamma, x : A, x_1:A_1,x_*: x \sim_{A_*} x_1)^*
\vdash B_*^* : {(\seq B^* B_1^*)^\sim}B_*  B_*'
\Gamma^* &\vdash  B_*^*\trip{a/x}{a'/x'}{a^*/x^*}
\trip{a_1/x_1}{a'_1/x'_1}{a^*_1/x^*_1}  \label{bstartype} 
\trip{a_*/x_*}{a'_*/x'_*}{a_*^*/x_*^*} \\
&\of \notag
{\left(\seq B^*\trip{a/x}{a'/x'}{a^*/x^*}
B_1^*\trip{a_1/x_1}{a'_1/x'_1}{a^*_1/x^*_1}\right)}^{\bsim}
\!\!\!B_*[\vec a/ \vec x] \;
B'_*[\vec a'/\vec x']\\
&\eq \notag
\prod \tripar {y : B[a]} {y' : B'[a']} {y^*:y{\sim_{B^*[a,a',a^*]}}y'}
\prod \tripar {y_1 :B_1[a_1]} { y_1':B_1'[a_1']}
{y_1^* : y_1 \sim_{B_1^*[a_1,a_1',a_1^*]} y_1'}.
\\&\phanq\qquad  (y \sim_{B_*[\vec a]} y_1) \eeq (y' \sim_{B'_*[\vec
  a']} y_1') \notag

f^* &: \prod \tripar {x:A}  {x':A'} { x^* : x {\sim_{A^*}} x'}\quad f x \sim_{B^*}
f' x'\\
f^*_1 &: \prod \tripar {x_1 : A_1} {x'_1 :A_1'} {x^*: x_1 {\sim_{A^*_1}}
x'_1} \quad f_1 x_1 \sim_{B_1^*} f'_1 x'_1

  f^* a a' a^* &: {B^* \trip{a/x}{a'/x'}{a^*/x^*}}^\bsim (f a) (f' a')\\
  f_1^* a_1 a_1' a_1^* &: {B_1^* \trip{a_1/x_1}{a_1'/x_1'}{a_1^*/x_1^*}}^\bsim (f_1 a_1) (f_1' a_1')
B^*_*
\trip{a}{a'}{a^*}\trip{a_1}{a'_1}{a^*_1}\trip{a_*}{a_*'}{a_*^*}
\tripar{fa} {f'a'}{f^* a a' a^*} \tripar {f_1 a_1} {f_1' a_1'} {f_1^* a_1 a_1'
a_1^*} \of (f a \sim_{B_*[\vec a]} f_1 a_1) \eeq (f' a' \sim_{B_*'[\vec
  a']} f_1' a_1')
&(\Sigma^*\, [x,x_1,x_*] : A_*.\, B_*) \sim_{(\Sigma x{:}A.B \ee{}
  \Sigma x_1{:}A_1.B_1)^*}
(\Sigma^*\, [x,x_1,x_*] : A_*.\, B_*)'\\
&=(\Sigma^*\, [x,x_1,x_*] : A_*.\, B_*) \sim_{\seq (\Sigma x{:}A.B)^* 
  (\Sigma x_1{:}A_1.B_1)^*}
(\Sigma^*\, [x',x'_1,x'_*] : A'_*.\, B'_*)\\
&= \prod \tripar{p : \Sigma x{:}A.B} {p' : \Sigma
  x'{:}A'.B'} {p^* : p \sim_{(\Sigma x{:}A.B)^*} p'}
\prod \tripar {p_1 : \Sigma x_1{:}A_1.B_1} {p_1' : \Sigma x_1'{:}A_1'.B_1'}
{p_1^* : p_1 \sim_{(\Sigma x_1{:}A_1.B_1)^*} p_1'}.\\
&\qquad\qquad (p \sim_{\Sigma^*\, [x,x_1,x_*] : A_*.\, B_*} p_1) \eeq
    (p' \sim_{\Sigma^*\, [x',x'_1,x'_*] : A'_*.\, B'_*} p'_1)

  &(\Sigma^* [x,x_1,x_*] : A_*.\ B_*)^*\\
&\eq \blam \tripar{p : \Sigma x{:}A.B}{p':\Sigma x'{:}A'.B'}
{p^* : p \sim_{\Sigma^* A^* B^*} p'}
\blam \tripar {p_1 : \Sigma x_1{:}A_1.B_1} {p_1' : \Sigma x_1'{:}A_1'.B_1'} {p_1^* : p_1 \sim_{\Sigma^* A_1^* B_1^*} p_1'}.\\
&\phan
\sum\hista\trip{a_* : \pi_1 p \sim_{A_*} \pi_1 p_1}
{a'_* : \pi_1 p' \sim_{A'_*}  \pi_1 p'_1}
{a^*_* : a_* \sim_{(A_*^\sim\, \pi\!{}_1\! p\; \pi\!{}_1\! p\!{}_1)^*} a'_*} :
A^*_* \tripar{\pi_1 p}{\pi_1 p'}{\pi_1 p^*}
\tripar{\pi_1 p_1} {\pi_1 p_1'} {\pi_1 p_1^*}.\\
&\phanq B^*_* \trip{\pi_1 p/x}{\pi_1 p'/x'}{\pi_1 p^*/x^*}
\trip{\pi_1 p_1/x_1}{\pi_1 p_1'/x_1'}{\pi_1 p_1^*/x_1^*}
\trip{a_*/x_*}{a_*'/x_*'}{a_*^*/x_*^*}
\tripar{\pi_2 p}{\pi_2 p'}{\pi_2 p^*}
\tripar{\pi_2 p_1}{\pi_2 p_1'}{\pi_2 p_1^*}

&\sum\hista\trip{a_* : \pi_1 p \sim_{A_*} \pi_1 p_1}
{a'_* : \pi_1 p' \sim_{A'_*}  \pi_1 p'_1}
{a^*_* : a_* \sim_{(A_*^\sim \, \pi\!{}_1\! p\; \pi\!{}_1\! p\!{}_1)^*} a'_*} :
A^*_* \tripar{\pi_1 p}{\pi_1 p'}{\pi_1 p^*}
\tripar{\pi_1 p_1} {\pi_1 p_1'} {\pi_1 p_1^*}.\\
&\phanq B^*_* \trip{\pi_1 p/x}{\pi_1 p'/x'}{\pi_1 p^*/x^*}
\trip{\pi_1 p_1/x_1}{\pi_1 p_1'/x_1'}{\pi_1 p_1^*/x_1^*}
\trip{a_*/x_*}{a_*'/x_*'}{a_*^*/x_*^*}
\tripar{\pi_2 p}{\pi_2 p'}{\pi_2 p^*}
\tripar{\pi_2 p_1}{\pi_2 p_1'}{\pi_2 p_1^*}

&(p \sim_{\Sigma^*\, [x,x_1,x_*] : A_*.\, B_*} p_1) \eeq
    (p' \sim_{\Sigma^*\, [x',x'_1,x'_*] : A'_*.\, B'_*} p'_1)\\
&\eq \left(\sum \hista \trip{x}{x_1}{x_*} : A_*.B_*\right)^\sim \!\!p\; p_1
\ \ \eeq \  \
\left(\sum \hista \trip{x'}{x'_1}{x'_*} : A'_*. B'_*\right)^\sim \!p'\;
p_1'\\
&\eq \hspace{-0.6cm}\sum_{a_* : \pi_1 p \sim_{A_*} \pi_1 p_1} \hspace{-0.3cm} B_*\trip{\pi_1
    p/x}{\pi_1 p_1/x_1}{a_*/x_*}^\sim \!\pi_2 p\;\pi_2 p_1
\quad \eeq \hspace{-0.3cm}
\sum_{a'_* : \pi_1 p' \sim_{A_*'} \pi_1 p'_1} \hspace{-0.3cm} B'_*\trip{\pi_1
  p'/x'}{\pi_1 p'_1/x'_1}{a'_*/x'_*}^\sim \!\pi_2 p'\;\pi_2 p'_1

  A^*_* \tripar{\pi_1 p}{\pi_1 p'}{\pi_1 p^*}
\tripar{\pi_1 p_1} {\pi_1 p_1'} {\pi_1 p_1^*}
&\of (A_*^\sim \ \pi_1 p \ \pi_1 p_1) \eeq ({A'_*}^\sim\ \pi_1 p'
\ \pi_1 p_1')

& B^*_* \trip{\pi_1 p/x}{\pi_1 p'/x'}{\pi_1 p^*/x^*}
\trip{\pi_1 p_1/x_1}{\pi_1 p_1'/x_1'}{\pi_1 p_1^*/x_1^*}
\trip{a_*/x_*}{a_*'/x_*'}{a_*^*/x_*^*}
\tripar{\pi_2 p}{\pi_2 p'}{\pi_2 p^*}
\tripar{\pi_2 p_1}{\pi_2 p_1'}{\pi_2 p_1^*}\\
&\of 
\sim B_*\trip{\pi_1
    p/x}{\pi_1 p_1/x_1}{a_*/x_*} \;\pi_2 p\;\pi_2 p_1
\quad \eeq \quad
\sim  B'_*\trip{\pi_1
  p'/x'}{\pi_1 p'_1/x'_1}{a'_*/x'_*} \;\pi_2 p'\;\pi_2 p'_1

 (\seq A_* B_*)^* &\eq \blam \tripar{e : A \eeq B}
{e':A' \eeq B'} {e^* : e \sim_{\seq A^* B^*} e'}
\quad\blam\tripar{e_1 : A_1 \eeq B_1}{e_1' : A_1' \eeq B_1'}
{e_1^* : e_1 \sim_{\seq A_1^* B_1^*} e_1'}.\\
&\phanq
\prod\hista \trip{a}{a'}{a^*} : A^*\;
\prod\hista \trip{a_1}{a_1'}{a_1^*} : A_1^*\;
\prod\hista \trip{a_*}{a_*'}{a_*^*} : A_*^* \tripar{a}{a'}{a^*} \tripar{a_1}{a_1'}{a_1^*}\\
&\phanq
\prod\hista \trip{b}{b'}{b^*} : B^*\;
\prod\hista \trip{b_1}{b_1'}{b_1^*} : B_1^*\;
\prod\hista \trip{b_*}{b_*'}{b_*^*} : B_*^* \tripar{b}{b'}{b^*} \tripar{b_1}{b_1'}{b_1^*}.\\
&\phanq\qquad \bseq \left(e^* \tripar{a}{a'}{a^*}
  \tripar{b}{b'}{b^*}\right)
\left(e_1^* \tripar{a_1}{a_1'}{a_1^*} \tripar{b_1}{b_1'}{b_1^*}\right)\\

&\phan \seq A_* B_* \sim_{((A \eeq B) \eeq (A_1 \eeq B_1))^*} \seq A_*' B_*'\\
&\eq \seq A_* B_* \sim_{\seq (A \eeq B)^* \eeq (A_1 \eeq B_1)^*} \seq A_*' B_*'\\
&\eq \prod \tripar {e : A \eeq B}{e':A' \eeq B'}{e^* : e \sim_{(A
  \eeq B)^*} e'} \prod \tripar {e_1 : A_1 \eeq B_1}{e_1':A_1' \eeq B_1'}{e_1^*: e_1 \sim_{(A_1
  \eeq B_1)^*} e_1'}.\\
&\phanq\quad (e \sim_{\seq A_* B_*} e_1) \eeq (e' \sim_{\seq A_*' B_*'} e_1')

&(e \sim_{\seq A_* B_*} e_1) \eeq (e' \sim_{\seq A_*' B_*'} e_1')
\eq \label{yeaaay}\\
&\phanq \qquad \left(\begin{aligned}
&\Pi a{:}A \Pi a_1{:}A_1 \Pi a_* : a \sim_{A_*} a_1\\
&\Pi b{:}B \Pi b_1{:}B_1 \Pi b_* : b \sim_{B_*} b_1. \quad
 a \sim_e b \ \eeq\ a_1 \sim_{e_1} b_1
\end{aligned}\right) \notag\\
&\phanq \quad\beq \left(\begin{aligned}
&\Pi a'{:}A' \Pi a'_1{:}A'_1 \Pi a'_* : a' \sim_{A'_*} a'_1\\
&\Pi b'{:}B' \Pi b'_1{:}B'_1 \Pi b'_* : b' \sim_{B'_*} b'_1. \quad
 a' {\sim_{e'}} b' \ \eeq\ a'_1 {\sim_{e'_1}} b'_1
\end{aligned}\right) \notag
A_*^* : \prod \tripar{x : A}{x': A'}{x^*: x \sim_{A^*} x'}
\prod \tripar{x_1:A_1}{x_1':A'_1}{x_1^* : x_1 \sim_{A_1^*} x_1'}.\ 
x \sim_{A_*} x_1 \; \eeq \; x' \sim_{A'_*} x'_1 A_*^* \tripar{a}{a'}{a^*} \tripar{a_1}{a_1'}{a_1^*}  \of
a \sim_{A_*} a_1 \ \ \eeq\ \  a' \sim_{A'_*} a'_1
&\bseq \left(e^* \tripar{a}{a'}{a^*}
  \tripar{b}{b'}{b^*}\right)
\left(e_1^* \tripar{a_1}{a_1'}{a_1^*}
  \tripar{b_1}{b_1'}{b_1^*}\right)\\
&\of 
(a \sim_e b \ \eeq\ a_1 \sim_{e_1} b_1) \ \eeq \
(a' \sim_{e'} b' \ \eeq\ a'_1 \sim_{e'_1} b'_1)

  e^* a a' a^* b b' b^* &\of (a \sim_e b) \eeq (a' \sim_{e'} b')\\
  e_1^* a_1 a_1' a_1^* b_1 b_1' b_1^* &\of
(a_1 \sim_{e_1} b_1) \eeq (a_1' \sim_{e_1'} b_1')
 \vdash \sta : \sta  \vdash \sta^* : \sta \sim_{\sta^*} \sta  \sta \sim_{\sta^*} \sta \rrule \sta \eeq \sta  \vdash \sta^* : \sta \eeq \sta  \vdash A : \sta  \vdash A^* : A \sim_{\sta^*} A' \sim_{A^*} \of A \to A \to \sta    \fbox{  } \vdash a :A \vdash a^* : a \sim_{A^*} a'  \vdash a^* : a \ee A a' a^* \of a \ee A a \fbox{} a \ee A a' \eq a \sim_{\refl{A}} a' 
\fbox{ \vdash a : A  \vdash \refl{a} : a \sim_{\refl{A}} a}
 A \ee \sta B \eq A \sim_{\refl{\sta}} B \eq A \eeq B  \fbox{} \vdash a : A  \vdash \refl{a} : a \ee A a 
&\vdash \refl{\refl{a}} \quad\; \of \refl{a} \ee {a \ee A a}
\refl{a}\\
&\vdash \refl{\refl{\refl{a}}} \of \refl{\refl{a}} \ee {\refl{a} \ee {a \ee A a}
\refl{a}}
\refl{\refl{a}}\\
&\qquad \vdots

    x : A &\vdash b(x) : B(x)\\
    &\vdash a^* : a \ee A a'
  
 x:A, x':A, x^* : x \sim_{\refl{A}} x' &\vdash B^*(x,x',x^*) : B(x)
 \eeq B(x')\\
 x:A, x':A, x^* : x \sim_{\refl{A}} x' &\vdash b^*(x,x',x^*) : b(x) \sim_{B^*(x,x',x^*)}
b(x')

 &\vdash B^*(a,a',a^*) : B(a) \eeq B(a')\\
 &\vdash b^*(a,a',a^*) : b(a) \sim_{B^*(a,a',a^*)} b(a')
 x:A, y:B(x) \vdash c(x,y) : C(x,y) 
 &\vdash C^*(a,a',a^*,b(a),b(a'),b^*(a,a',a^*)) : C(a,b(a)) \eeq C(a',b(a'))\\
 &\vdash c^*(\vec a, \ora{b(a)}) : c(a,b(a)) \sim_{C^*(\vec a,
   \ora{b(a)})} c(a',b(a'))
 (\vec a, \vec a', \vec a^*) \eq (a_1,a_1',a_1^*,\dots,a_n,a_n',a_n^*) 
  &\vdash a_i : A_i(a_1,\dots,a_{i-1})\\
  &\vdash a_i' : A_i(a_1',\dots,a_{i-1}')\\
  &\vdash a_i^* : a_i
  \sim_{A_i^*(a_1,a_1',a_1^*,\dots,a_{i-1},a_{i-1}',a_{i-1}^*)} a_i'
 \vec a^* \of \vec a \ee \Gamma \vec a'  \vdash B(\vec a^*) : B(\vec a) \eeq B(\vec a')  \vdash b(\vec a^*) : b(\vec a) \sim_{B(\vec a^*)} b(\vec a') \setof{\sta_n \mid n \in \omega}\AXC{
\item A new rule is introduced:
  \begin{prooftree}
    \AXC{}
    \UIC{}
  \end{prooftree}
\item In all other rules,
the  symbol is replaced by .
\end{enumerate}
\end{definition}
 
{\sc Remark.}\ \ When we describe the intended model, it will turn out that the above
definition is not quite correct: the elimination rule for  does
not have the right universe indexing.  We shall address this issue when
it arises in the course of our construction.

\subsection{The strict model}

First, we describe a particularly simple model in which  is interpreted by
strict, set-theoretic equality.  This model even validates the rule
derivable in the \cite{itt} system with propositional reflection:


Let  be a sequence
of strongly inaccessible cardinals.

\begin{enumerate}
\item Each universe  is interpreted by , the cumulative hierarchy up to stage~:

\item The - and -types are interpreted,
  respectively, by cartesian product and disjoint union of families of sets:

\item The -type is interpreted by equality:

\end{enumerate}

Since, for  strongly inaccessible,
 is closed under cartesian products and disjoint union,
the above definition manifestly
validates the four formation rules of , as well as the
subsumption rule.

The interpretation of term formers related to the - and
-types is completely standard:


The interpreation of  is
self-evident.  When , put


The interpretation of contexts  is the set of all tuples
 such that


It is straightforward to verify that the interpretation preserves
substitution, conversion, and typing rules.  So we have

\begin{theorem} (Soundness)
Let  be as defined above.  Then

\end{theorem}

The above model is \emph{proof-irrelevant}, since proofs of equality
have no computational content.  It is in keeping with our goal of
generality, that extensional equality should admit such an
interpretation.

However, the -type also contains all the necessary machinery
for transporting computational information over proofs of equality.
We shall now describe a model which makes use of this feature.

Due to lack of space, we do not go into details, but give a general outline.
\subsection{The proof-relevant model}

\subsubsection{Isomorphism as equality}

In this model, type equality is interpreted as isomorphism of sets:


Let ,  be
families of sets.
Given an isomorphism ,
and a family , we obtain isomorphisms



Given isomorphisms , , we get an
isomorphism (conjugation):


Every isomorphism  induces a binary relation
:


Every set  has the identity isomorphism:


In particular, there exist canonical isomorphisms


This fixes the interpretation of everything related to type equality.
Keeping the interpretation of other types the same, we now try to
validate the reduction rules.

\subsubsection{A bug?}

Thankfully, all of the reduction rules are perfectly valid in our model.

Except one.


The right side is interpreted by the set of isomorphisms .

The left side is interpreted by the relation :


The rule \eqref{srule}
is thus saying that there is at most one isomorphism between
any pair of sets, a claim which many members of  will find offensive.

How are we to reconcile this reduction rule with our model?

\subsubsection{The truth-table universe}

In the first instance, we notice that the
offending claim \emph{does} make sense
for sets that are either empty or singletons, i.e., 
\emph{propositions}.

Indeed, the universe  of classical propositions is closed under
isomorphism, in the sense that there is indeed at most one isomorphism
between any two propositions --- its existence being equivalent to the
existence of a pair of maps between them.
 \comment{ (The relation 
induced by such an isomorphism  
relates all pairs of elements, and is equivalent to the
existence of functions from one set to the other and back.
(In particular, the identity relation on an empty or singleton set relates
all elements of that set.)}

Furthermore, all other type constructors can be given the standard
``truth-table semantics'' in this universe,
validating their introduction and elimination rules.

This motivates us to let propositions actualize the
interpretation of , the lowest universe in .
Constructions carried out in this universe fall in the scope
of the \emph{propositions as types} embedding (\cite{Howard80}).

\subsubsection{Homotopy hierarchy}

We are thus led to reconsider our interpretation


In order for \eqref{srule} to remain valid while preserving
``type equality is isomorphism'' idea, we \emph{must} observe


This means that the equality on  --- which we defined as the
``relation'' induced by identity equality of  with itself ---
must actually be a \emph{set family} (giving, for any two sets,
the set of isomorphisms between then), rather than a simple relation.

In contrast, for  elements of ,
the relation  induced by 
an isomorphism  , is always two-valued: it's a proposition.
In particular, the equality relation induced by the identity isomorphism on
 is a proposition.

For propositions, an ``isomorphism'' is just a pair of maps, and the
relation associated to this pair is the total (``1-valued'') relation between the two propositions.

Going higher, we find that, for groupoids ,
the collection of groupoid equivalences
between  and  forms again a groupoid\footnote{
Given , 
the isomorphisms between ,  may be given equivalently either as

These collections, being products of sets, are again sets.},
 and every groupoid equivalence   induces a
-valued predicate on :


We observe the following pattern:\\

{\centering \fbox{\begin{minipage}{10cm}
{The relation  induced by a type equality
 between types in the universe ,
is valued in the universe .}
\end{minipage} }\\ \par} \vspace{0.3cm}

This pattern leads us to revoke the interpretation of universes in the
cumulative hierarchy of set theory in favor of the (still cumulative)
hierarchy of homotopy -types:


\subsubsection{Fixing the bug}
 
The pattern announced above forces us to reconsider the
-elimination rule in the
stratified system.  It shall now be read as follows.

\begin{prooftree}
  \AXC{}
  \AXC{}
  \AXC{}
  \TIC{}
\end{prooftree}

Postponing for the moment the question of what we are to make of the
conclusion in the case when , we point out that this change
resolves the problem in , allowing us to complete
the model.  Thus, for , we have

These collections may be naturally identified.  In particular:\\
- Two propositions are equivalent if their truth-table semantics yield
isomorphic sets;\\
- Two sets  are isomorphic if the identity groupoid equivalence

relates them as objects: .\\
- etc.

We remark that the formation rule of the equality type needs
no amendments:

This rule already gives the intended meaning:\\
- Propositions are closed under logical equivalence;\\
- Sets are closed under isomorphism;\\
- Groupoids are closed under equivalence of groupoids;\\
- etc.

Although we have discussed only the first few levels of the homotopy
hierarchy, it is clear that the given pattern has a clear inductive
structure, and extends to all finite -types.

We may also consider adding a ``limit universe''

for which the -operator would stay valued in .  The
natural interpretation of  would be by a model of weak
-groupoids.

But in order for such a universe to be of any interest, our language
should already provide the computational interpretation of the
higher groupoid laws (the Kan filling conditions).
This of course is a major topic for future work.

\newcommand{\unitt}{\boldsymbol{1}}
\newcommand{\unitc}{t\!t}
\newcommand{\unitelim}{\mathsf{Const}}
To complete our model, we discuss the rule of -elimination for
the case when .

The symbol  is treated as notation for , the unit
type.

We add new formation, introduction, elimination, and computation
rules for this type.


\vspace{0.1 cm}

\vspace{0.3 cm}


We add the rules for interaction between  and
.
\begin{prooftree}
  \AXC{}
  \UIC{}
\end{prooftree}

Finally, we extend the -operation to these new terms:\footnote{
We do not include the lifting of the  eliminator; in future
versions of our system  is expected to be derivable from the
\emph{transport operator}:
\begin{prooftree}
  \AXC{}
  \AXC{}
  \BIC{}
  \UIC{}
  \AXC{}
  \BIC{}
\end{prooftree}
}

 
This completes our model construction.

\section{Conclusion}

In this paper, we have enunciated Tait's suggestion for the
type-theoretic meaning of the notion of extensional equality.

We have shown how the external definition of extensional equality may
be reflected into the syntax.  Our construction yields an internal
definition of extensional equality for closed types.

We have not yet witnessed all of the desired properties of this
equality.  Future work includes generalization to open terms and
computational treatment of Kan filling conditions (to be defined via
transport maps over type equality).

In the model outlined in the last section, we see the syntactic
approach to extensional equality starting to come together
with the threads of ideas motivated by homotopy theory.

An original feature of this interpretation is that the logical
relation defined by induction on type structure is reflected in the
\emph{lower} universe than the types being related by it.

\bibliography{ett2.5}
\setlength{\voffset}{0cm}

\end{document}
