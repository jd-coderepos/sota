\documentclass[10pt, conference, compsocconf]{IEEEtran}
\pdfoutput=1
\usepackage{amsfonts,amssymb,amsmath,alltt,stmaryrd}
\usepackage {mathpartir,amssymb}
\usepackage{graphicx,url}
\usepackage[latin1]{inputenc}
\usepackage{flushend}
\renewcommand{\ttdefault}{cmtt}
\newenvironment{ttbox}{\begin{alltt}\ttbraces\small\tt}{\end{alltt}}
\def\ttbraces{\let\.=\nobreak\chardef\{=`\{\chardef\}=`\}\chardef\|=`\\}
\newcommand\aspfun{ASP\ }
\newcommand\aspfunp{ASP}
\newcommand{\symb}[1]{\makebox{\it #1}} 
\newcommand\dom{{\rm dom}}
\newcommand\ran{{\rm ran}\ }
\newcommand\imp\Longrightarrow
\newcommand\gamact{{\Gamma_{\symb{act}}}}
\newcommand\gamfut{{\Gamma_{\symb{fut}}}}
\newcommand\loweq{=_{\nabla}}
\newcommand\ind{\sim_{\sigma, \tau}}
\newcommand\inda{\sim_{\alpha}}
\newcommand\indp{\sim_{\sigma',\tau'}}
\newcommand\indpp{\sim_{\sigma',\tau}}
\newcommand\indR{{=}_{R}\,}
\newcommand{\coloncolon}{\mathrel{::}}
\newcommand\loc{\ensuremath{\to_\varsigma}}
\newcommand\dist{\ensuremath{\to_\|}}
\newcommand\distone{\ensuremath{\to_\|}^{01}}
\newcommand\diststar{\ensuremath{\to_\|^*}}
\newcommand{\setN}{{\mathord{\mathbb N}}}
\newcommand\ie{i.e.\!\,, }
\newcommand\all{\forall\,}

\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}[section]
\newtheorem{proposition}[definition]{Proposition}
\newtheorem{corollary}[definition]{Corollary}
\newtheorem{fact}[definition]{Law}
\newtheorem{lemma}[definition]{Lemma}
\newtheorem{example}[definition]{Example}
\newtheorem{property}[definition]{Property}
\newcommand{\tto}{\!\!\shortrightarrow\!\!}
\newcommand{\dc}{\delta_{\text{client}}}
\newcommand{\da}{\delta_{\alpha}}



\begin{document}

\title{Confinement for Active Objects}
\author{\IEEEauthorblockN{Florian Kamm\"uller\\}
\IEEEauthorblockA{
Middlesex University, London UK and\\
Technische Universit\"at Berlin, Germany\\
Email: f.kammueller@mdx.ac.uk}
}
\maketitle
\thispagestyle{empty}

\begin{abstract}
In this paper, we provide a formal framework for the security of distributed active objects.
Active objects communicate asynchronously implementing method calls via futures.
We base the formal framework on a security model that uses a semi-lattice to enable
multi-lateral security crucial for distributed architectures.
We further provide a security type system for the programming model ASPfun of 
functional active objects.
Type safety and a confinement property are presented. ASPfun thus realizes secure down calls.
\end{abstract}
\begin{keywords} 
Distributed active objects, formalization, security type systems
\end{keywords} 
\section{Introduction}
\label{sec:intro}
Formal models for actor systems become increasingly important  for the security
analysis of distributed applications.
For example, models of organisational structures together with actors provide a basis
for the analysis of insider threats, \cite{Probst:2008:EAS:1480242.1480308,Probst.311.1}.

Active objects define a programming model similar to actors \cite{Agha:92}
but closely related to object-orientation.  An object is an {\it active object} if 
it serves as an access point to its own methods and associated (passive) objects and their 
threads.  Consequently, every call
to those methods will be from outside. These remote calls are collected in a list of requests.
The unit comprising the object's methods and attributes and its current requests is 
called {\it activity}.
The activity serves as a unit of distribution since it has a data space separate from its environment 
and can process requests independently.
To enable asynchronous communication between distributed active objects, the concept of 
{\it futures} -- promises for method call values -- is used.
Active objects are practically implemented in the Java API ProActive \cite{CDD:CMST06}
developed by Inria and commercialized by its spin-off ActiveEON.
Active objects are also a tangible abstraction for distributed information systems beyond just
one specific language.
ASP \cite{CHSPOPL04} is a calculus for active objects. 
ASP has been simplified into \aspfun --
a calculus of {\it functional} active objects. \aspfun is formalized
in Isabelle/HOL \cite{hkl:11} thus providing a general automated framework for 
the exploration of properties of active objects.

In this paper, we use this framework to support security specification and analysis of
active objects.
The contributions of this paper are 
(a) the formalization of a novel security model for distributed active objects 
    that supports multi-lateral security,
(b) a type system for the static security analysis for \aspfun configurations,
(c) preservation and the simple security property of confinement for well-typed configurations,
(d) and an argument that secure down calls are possible for \aspfunp.

The novel security model \cite{kam:12} is tailored to active objects as it supports
decentralized privacy specification of data in distributed entities.
This is commonly known as multi-lateral security. To achieve it we break away from 
the classical dogma of lattices of security classes and use instead semi-lattices. 
In our model, we implement {\it confinement}.
Every object can remotely access only public () methods of other activities. 
Methods can be specified as private () in an activity forbidding direct access.
All other methods of objects are assumed to be , partitioning methods 
locally into  and . 
The security policy further forbids local information flow from  to .
To access an -method remotely,
the containing activity must also be visible to the calling activity in a configuration.
In \aspfunp, this visibility relation is implemented by activity references.
In other active object programming languages, visibility could be given
alternatively by an import relation or a registry. 


In this paper, we provide an implementation of this security model in the \aspfun framework to 
illustrate its feasibility and the applicability of the \aspfun framework.

We design a security type system for \aspfun that implements a type check for a
security specification of active objects and visibility.
We prove the preservation property for type safety of the type system guaranteeing that
types are not changed by the evaluation of an \aspfun configuration.
The specification of parts of an active object as confined, or private (or ), 
is possible at the discretion of the user. This specification is entered as a security 
assignment into the type system;
by showing a general theorem that confinement is entailed in well-typedness, 
we thus know that a well-typed program provides confinement of private methods.
Although the confinement property intuitively suffices for security, at this point, a 
formal security proof is still missing. Moreover, implicit flows may occur.
We thus provide a definition of noninterference for active objects. Based on that, we prove 
that a well-typed configuration does not leak information to active objects below 
in the hierarchy of the security model, \ie multi-lateral security holds for well-typed 
configurations.

Remote method calls in \aspfun have no side-effects. Hence, secure down calls can be made.
Confinement provides that no private information is accessed remotely and side-effect freedom
guarantees that through the call no information from the caller side is leaked.
Side effects are excluded in our formal model \aspfun because it is functional 
but this can be implemented into the run-time system of other active object languages.

\subsection*{Overview}
We first review the semi-lattice for multi-lateral security 
(Section \ref{sec:sml4mls}) and \aspfun (Section \ref{sec:aspfun}) introducing
a running example of private sorting (Section \ref{sec:ex}).
Next, we describe how the semi-lattice model can be applied to active
objects by instantiating it for \aspfunp (Section \ref{sec:smlasp}). We 
discuss secure down calls, a distinctive feature of \aspfun enabled by 
its functional nature and that moreover does not restrict common bi-directional
communication patterns. To show the latter point, we present
how to implement the Needham-Schroeder Public Key protocol in \aspfunp.
We describe what we mean by security, i.e., the attacker model and the information 
flows between active objects through method calls (Section \ref{sec:sec}) and illustrate
their enforcement on the running example.
Following that, we present a type system for the static analysis of a configuration of 
active objects in \aspfun (Section \ref{sec:types}). Properties of this type system are 
presented  (Section \ref{sec:props}): 
(a) preservation as a standard result of type safety and (b) confinement.
We then define noninterference and multi-lateral security formally to present a soundness
theorem, i.e., well-typed configurations are multi-lateral secure.
We finish the paper with a related work section and also give some conclusions 
(Section \ref{sec:concl}).
An Appendix contains sections A \dots E with formal details, more examples, and (full) proofs.

\section{Prerequisites}
\label{sec:prereq}
\subsection{Semi-Lattice Model for Privacy}
\label{sec:sml4mls}
We abstract the confinement property known from object oriented languages, e.g., 
private/public in Java,
and use it as a blueprint for a model of privacy in distributed objects. 
Consider Figure \ref{fig:mls}: multi-{\it level} security models support strict hierarchies 
like military  organization (left); multi-{\it lateral} security \cite[Ch. 8]{and:01} 
is intended to support a decentralized security world where 
parties A to E share resources without a strict hierarchy (right) thereby granting 
privacy at the discretion of each party. But lattice-based security models usually
achieve the middle schema: since a lattice 
has joins, there is a security class A  B  C  D  E 
that has unrestricted access to all 
classes A to E. For a truely decentralized multi-lateral security model 
this top element is considered harmful. 
To realize confinement, we exclude the top element by excluding joins from the lattice. 
We thereby arrive at an algebraic structure called a semi-lattice in which meets always 
exist but not joins.
\begin{figure}
\vspace{-3ex}
\begin{center}
\includegraphics[scale=.1]{MLS.png}\includegraphics[scale=.1]{mls_top2.png}\includegraphics[scale=.1]{multilateral.png}
\vspace{-2ex}
\caption{Joins enable Top control in MLS models}
\label{fig:mls}
\end{center}
\vspace{-3ex}
\end{figure}

\subsubsection*{Semi-Lattice}
The semi-lattice of security classes for active objects is a combination of
global and local security lattices. The two lattices are used to classify
the methods into groups and objects into hierarchies.

\subsubsection{Local Classification}
The local classification is used to control the information flow inside an
object, where methods are called and executed. For every active object there is the public () and a private
() level partitioning the set of this active object's methods. 
The order relation of the lattice for local classification is the relation  
defined on  as .

\subsubsection{Global Classification}
The purpose of the global classification is to control the course of information flows 
between methods of globally distributed objects and lead their information together in a common dominating activity.
To remotely access active objects, the key is their identity 
(we use ,  to denote identities). 
As classes for the global lattice we use subsets of the set of all 
activity identities . These subsets of compartments
build the lattice of global classes, the powerset lattice  over activity identities .

In a concrete configuration, the global class label of an activity is the set of
activity identities to which access is granted. For example, with 
respect to the Hasse diagram in Figure \ref{fig:slmmls}, an object at global level 
 can access any
part (method) of an object labeled as  or  or  
but only if this part is additionally labeled as .
Vice versa an object at level  can neither access  nor  parts of objects at level
 nor any parts at level  but only  parts at level . Thus the
classification of parts of an active object needs to combine labels.

\subsubsection{Combination of Lattices}
\label{sec:comblatt}
The security model of the semi-lattice needs to combine the local and global classification scheme.
As result, a {\it security class} is a pair of local and global class .
We want to impose confinement of methods in order to realize multi-lateral security with 
our model. Thus, we have to define the combination of the two constituting lattices such that its
order relation corresponds to a multi-lateral information flow relation. I.e., private methods 
of an object are not accessible by any other than the object itself.

Consequently, the new order for security classes is defined as follows.
The combined security class ordering for active objects is defined 
such that a method class  dominates  and also  for all 
 
but no other  dominates  . 
The combination of local and global types into pairs gives a partial order 

with 

where  the vertical notation  abbreviates  and
 denotes the strict ordering on the local security classes.
Consequently, meets exist but no joins. The
partial order {\it CL} is thus just a semi-lattice as illustrated by an example 
in Figure \ref{fig:slmmls} (right).
\begin{figure}
\vspace{-3ex}
\begin{center}
\includegraphics[scale=.2]{SMLforMLSnew.png}
\end{center}
\vspace{-3ex}
\caption{Taking the top off MLS lattice (left) leads to semi-lattice (right).
\label{fig:slmmls}}
\vspace{-3ex}
\end{figure}


\subsection{Functional Active Objects: \aspfun}
\label{sec:aspfun}
\aspfun uses a slightly extended form of the simplest -calculus 
from the Theory of Objects \cite{AC96a} by distributing 
-calculus objects into activities. 
The calculus \aspfun is functional because method update is realized on a copy of the active
object: there are no side-effects.


\subsubsection{-calculus}
Objects consist of a set of labeled methods . Attributes 
are considered as methods not using the parameters. 
The calculus features method call  and method update  on objects where
 is the binder for the method parameter . Every method may also contain a ``{\it this}'' element 
representing the surrounding object. Note, that the ``this'' is usually \cite{AC96a} expressed as an additional
parameter  to each method's  scope but we use for this exposition literally 
{\it this} to facilitate the understanding. It is, however, important to bear in mind that 
formally {\it this} is a variable representing a copy of the current object and that this 
variable is scoped as a local variable for each object.
The {-calculus is Turing complete, e.g. it can simulate the -calculus. 
We illustrate the -calculus by our example below.

\subsubsection{Syntax of \aspfunp}
\aspfun is a minimal extension of the -calculus by one single 
additional primitive, the {\it Active}, for creating an activity.
In the syntax (see Table \ref{tab:syntax}) we distinguish between underlined constructs 
representing the static syntax that may be used by a programmer, while futures and active 
object references are created at runtime.
\begin{table}[!ht]

\vspace{-3ex}
\caption{\aspfun syntax}
\label{tab:syntax}
\vspace{-3ex}
\end{table}
We use the naming convention  for -terms, ,
 for active objects,  for futures,  for request queues.


\subsubsection{Futures}
A {\it future} can intuitively be described as a promise for the result of a method call.
The concept of futures has been introduced in Multilisp \cite{Halstead85} and 
enables asynchronous processing of method calls in distributed applications:
on calling a method a future is immediately returned to the caller enabling the
continuation of the computation at the caller side. Only if the method call's value
is needed, a so-called wait-by-necessity may occur.
Futures identify the results of asynchronous method invocations to an
activity. Technically, we can see a future as a pair consisting of a future {\it reference} and a future {\it value}.
The future reference points to the future value which is the instance
of a method call in the request queue of a remote activity. 
In the following, we will use future and future {\it reference} synonymously for simplicity.
Futures can be transmitted between activities. Thus different activities 
can use the same future. 


\subsubsection{Configuration}
A {\it configuration} is a set of activities

where  are disjoint subsets of  . 
The unordered list  represents the request queue, 
the active object, and  the activity reference.
A configuration represents the ``state''of a distributed system by the current parallel activities. 
Computation is now the state change induced by the evaluation of method calls in the request queues
of the activities.
Since \aspfun is functional, the {\it local} active object does not change -- it is immutable -- but the configuration is changed {\it globally}
by the stepwise computation of requests and the creation of new activities.

The constructor  activates the object  by creating a new activity 
in which the object  becomes active object. Although the active object of an activity is immutable, an update operation on
activities is provided. It performs an update on a freshly created copy
of the active object placing it into a new activity with empty request queue; 
the invoking context receives the new activity reference
in return. If we want to model operations that change active objects, we can do so using the
update. Although the changes are not literally performed on the original objects, a state change
can thus be implemented at the level of configurations (for examples see \cite{hkl:11}). 
Efficiency is not the goal of \aspfun rather 
minimality of representation with respect to the main decisive language features of 
active objects while being fully formal.




\subsubsection{Results, Programs and Initial Configuration}
A term is a result, \ie a totally evaluated term, if it is either an
object (like in \cite{AC96a}) or an activity reference. 
We consider results as values.

In a usual programming
language, a programmer does not write configurations but usual programs
invoking some distribution or concurrency primitives (in \aspfun
\emph{Active} is the only such primitive). This is reflected by the \aspfun syntax given 
above. A ``program'' is a term  given by this static
syntax (it has no future or active object reference and no free variable). In order to be
evaluated, this program must be placed in an initial
configuration. The initial configuration has a single activity with a single request consisting of the user program:

Sets of data that can be used as {\it values} are indispensable if we want to 
reason about information flows. In \aspfunp, such values can be represented as 
results (see above) to any configuration either by explicit use of some corresponding
object terms or by appropriate extension of the initial configuration that leads to
the set-up of a data base of basic datatypes, like integers or strings. 

\subsubsection{Informal Semantics of \aspfunp}
Syntactically, \aspfun merely extends the -calculus by a second parameter for methods
(the first being {\it this})
and the \emph{Active} primitive but the latter gives rise to a completely new semantic layer for
the evaluation of distributed activities in a configuration.

{\it Local} semantics (the relation ) and the 
{\it parallel} (configuration) semantics (the relation )
are given by the set of reduction rules informally described as follows (see Appendix C for the formal semantics). \begin{itemize}
\item {\sc call, update, local}: the local reduction relation {} is based on the -calculus.
\item {\sc active}: {} creates a new activity {}, 
  with {} as its active object, global new name {}, and initially no futures; in \aspfun notation this is {}.
\item {\sc request, self-request}: a {\it method call} {} creates a new future
  {} for the method  of active object {} placing the resulting future value
  onto 's request queue; the future  can be used to refer to the future value 
   at any time.
\item {\sc reply}: {\it returns result}, \ie replaces future {} by the
      referenced result term, \ie the future value resulting from some .
\item {\sc update-ao}: {\it active object update} creates a copy of the active object
      and updates the active object of the copy -- the original remains the same (functional active objects are {\it immutable}).
\end{itemize}
\subsection{Running Example: Private Sorting} 
\label{sec:ex}
As an example for a standard program consider the implementation of 
quicksort as an active object  illustrated in Figure \ref{fig:qsort}. 
The operations we use are  for list cons,
 for list append,  for list length,  for the list head, and a let construct 
(see \cite{hkl:11} for details on their implementation). 

\noindent \begin{small}

\end{small}

The quick sort algorithm in  is parametric over a method ``ord'', a numerical value, that is used in method ``part''. This method ord  is assumed to 
be available uniformly in the target objects  contained in the list that shall be sorted. We 
omit the parameter to calls of ord because it is unused, i.e., the empty object .

\begin{figure}
\vspace{-5ex}
\begin{center}
\includegraphics[scale=.35]{quicksort.png}
\end{center}
\vspace{-3ex}
\caption{Three active objects  in controller 's list.}
\label{fig:qsort}
\vspace{-5ex}
\end{figure}


The following controller object  holds a list of active objects (for example
 in Figure \ref{fig:qsort} but generally arbitrary thus represented
as \dots below). Controller  uses the quick sort algorithm provided by  to sort this list on execution
of the manage method.

\begin{small}

\end{small}

The target objects contained in  list (omitted) are active objects of the
kind of  below. Here, the  in the body of method ord is an integer specific to 
and the field income shall represent some private confidential data in . 

\begin{small}

\end{small}

If active objects of the kind of  represent principals in the system,
it becomes clear what is the privacy challenge: the controller object  should be able to
sort his list of -principals without learning anything about their
private data, here income. 


\section{Semi-Lattice Model for \aspfun}
\label{sec:smlasp}
As a proof of concept, we show that the calculus of functional active objects
\aspfun gives rise to a fairly straightforward implementation of the security semi-lattice
by mapping the concepts of the security model onto language concepts as follows.
\begin{itemize}
\item The global class ordering on sets of activity identities corresponds to the
      sets of activity references that are accessible from within an activity. We name this
      accessibility relation visibility (see Definition \ref{def:vis}). It is a consequence
      of the structure of a configuration thereby at the discretion of the configuration programmer.
\item The local classification of methods into public  and private  methods is specified
      as an additional security assignment mapping method names to  at the discretion of the
      user.
\item Based on these two devices for specifying and implementing a security policy with active objects
      we devise as a practical verification tool a security type system for \aspfunp. The types of this
      type system correspond quite closely to the security classes of the semi-lattice defined in Section
      \ref{sec:sml4mls}: object types are pairs of security assignment maps and global levels.
\end{itemize}


\subsection{Assigning Security Classes to Active Objects}

\subsubsection*{Visibility}
We define visibility as the ``distributed part'' of the accessibility 
within a configuration. It derives from the activity references and
thus represents the global security specification as programmed into 
a configuration.

\begin{definition}[Visibility]
\label{def:vis}
Let  be a configuration with a security specification
{\it sec} partitioning the methods of each of 's active objects locally into  and 
methods.
Then, the relation  is inductively defined on activity references by the following two cases.

We use the vertical notation  to abbreviate ; 
for context variable  see Appendix C.
We then define the relation called {\em visibility}  
as the {\it reflexive transitive closure} over  for any , {\it sec}. \hfill
\end{definition}
We denote the {\it visibility range} using Definition \ref{def:vis} as
.
The visibility relation
extends naturally to a relation  on global levels: every activity 
may be assigned the global level corresponding to the union of all its visible activities
.
This relation is a subrelation of the subset relation on the powerset of activity identities
introduced before and thus also a partial order. 
We use it as the semantics of the subtype relation in Section \ref{sec:types}.

\subsubsection*{Assigning Security Classes to Example}
To illustrate how activities are labeled in the semi-lattice model using visibility, 
consider the running example above where we assume the list in controller  to contain
various active object references .
We assign to each activity the global class containing its own identity and those of all 
its visible activities. 
For our example, the {\it global} class of controller  would 
be the following. 

The global classes  of the  objects and  in turn
contain all their visible objects' classes.
Thus, the global classes are ordered  for all  and 
. The security classification of methods assigns
pairs of global classes and local levels to method names, for example,
 and .

\subsubsection*{Practical Classification of Objects}
The pairs  in the partial order {\it CL} (see Section \ref{sec:comblatt})
are the security classes for methods of active objects. 
The semi-lattice is actually defined as a partial order on object methods rather than objects.
To classify objects we consider only the global part of the classification, i.e., the second
 component because all methods of an active object have this  in common.
Intuitively, this factorization corresponds to drawing objects as borders into the
semi-lattice structure (see Figure \ref{fig:slmmlsobj}). These borders represent the confinement zone
of an active object.  
\begin{figure}
\vspace{-3ex}
\begin{center}
\includegraphics[scale=.2]{SMLforMLSwithObjectCircles.png}
\end{center}
\vspace{-3ex}
\caption{
Tentatively drawing in object classes as confinement zones.
\label{fig:slmmlsobj}}
\vspace{-3ex}
\end{figure}

Formally, we consider an object class to be the factorization 
: a pair of a security assignment
to  for each method  of an object and the object's global class  common for all parts.
An activity contains one active object but may contain various passive
objects. 
The security assignment of an active object must be defined for all contained objects
(see rule {\sc SecAss Subsumption} in Section \ref{sec:types}).









\subsection{Secure Down Calls}
In a distributed system with a nontrivial security classification of communicating objects,
secure down calls are not possible because they would violate the security
policy of ``no-down-flows'' of information.
In general, a method call represents an information flow to the remote object
in the form of the request itself and the parameters passed; 
its response flows information back in the form of a reply.
Therefore, secure method communication is trivially restricted to objects of one class --
otherwise one direction would contradict the policy ``no-down-flows''.
This catch-22 situation can be overcome if we exclude side-effects: the requests do not leave traces in the remote object. 
In \aspfun this is given implicitly by the semantics because requests created by method 
calls in the remote object are not accessible by the remote object itself.
However, the reply may flow information up. Thus, information does flow back, i.e. up. 


As an overall result of the properties presented in this paper we can infer
that secure down calls are possible. The reasoning is as follows.
We assume as given a configuration together with a security specification {\it sec}
partitioning a portion of the methods into public () and private ().
If this configuration can be type checked according to our type system, it is secure,
\ie we know it  has confinement and is noninterfering as we are going to see in Section
\ref{sec:props}. Therefore, futures can be securely used in higher
security classes, \ie method results may flow up but, since no implicit flows exist, 
information is not leaked in the process.

Side-effect freedom does permit to securely call down because the call leaves no visible trace.
But does this not also exclude any mutual information exchange on the same level? It might 
seem so, but fortunately,
if we have two activities that are in the same class, methods 
calls between them are possible permitting bidirectional information flow. As an example, an
implementation of the Needham-Schroeder public key protocol is given next.

\subsection*{Needham Schroeder Public Key Protocol (NSPK) in \aspfun}
This example illustrates that inside one security class mutual information
exchange is possible between different activities. The easiest way to illustrate this 
is to use a protocol.
We use the corrected short form of the Needham Schroeder Public Key Protocol (NSPK) 
originally published by \cite{Needham78usingencryption}.
The originally published protocol missed out the  inside the encrypted message to  
in step two thereby giving rise to the well-known attack of \cite{Lowe95anattack}.

The protocol is usually written as follows using public keys
 known globally and their secret counterparts  establishing 
nonces  in the process of authentication.

In \aspfunp, the protocol is implemented as a set of methods between two activities  and . 
We omit details about decoding and keys because it is clear that they can be implemented and we want to highlight the communication process.

\begin{small}

\end{small}
The protocol can be executed by invoking method step which in turn invokes
the step step and step.
\begin{small}

\end{small}
 In each of the steps the nonces are created,
encrypted and tested between the method calls. If the communicated messages adhere to
the protocol, \ie the nonces and ids correspond to what has been sent in earlier steps,
the own nonces are updated into the methods NA and NB and the other's
nonces in the respective method ``knows''. Otherwise, the 
protocol failure is recorded as ``error'' in method knows. This protocol implementation 
illustrates that mutual information flows are possible locally within one security class. 
The type system that we present in the following Section \ref{sec:types}
accepts this configuration since the calls are of the same global level .

\subsection{Security Analysis}
\label{sec:sec}
In language based security, we may use the means provided by a language to enforce security.
That is, we make use of certain security guarantees that correspond to implicit assumptions 
concerning the execution of programs. The language introduces a security perimeter because we
assume that the language compilation and run-time system are respected (below the perimeter) while
the language is responsible for the security above the perimeter by virtue of its semantics
and other language tools, e.g. static analysis by type checking.
We now describe the security goal of confidentiality addressed in this paper and elaborate
on the attacker model for active objects.

\subsubsection*{Security Goal Confidentiality}
A computation of active objects is an evaluation of a distributed set of mutually referencing
activities. Principals that use the system can observe the system only by using the system's
devices. We make the simplifying assumption that principals can be identified as activities.
Principals, objects, programs and values are thus all contained in this configuration.
There are no external inputs to this system -- it is a closed system of communicating actors.
We concentrate in this paper on confidentiality, i.e. activities should not learn anything
about private parts of other activities neither directly nor indirectly.
Integrity is the dual to this notion and we believe that it can simply be derived from our present
work by inverting the order relation.

\subsubsection*{Attacker Model}
As a further consequence to the language based approach to security, we restrict the attacker to only have
the means of the language to make his observations.
Consequently, we also consider the attacker -- as any other principal -- as being represented 
by an activity. The attacker's knowledge is determined by all active objects he sees, 
more precisely their public parts. If any of the internal computations in inaccessible parts of other objects leak information,
the attacker can learn about them by noticing differences in different runs of the same
configuration. 
Inaccessible parts of other objects must be their private methods
or other objects 
that are referenced in these private 
parts.
The language semantics and the additional static analysis must guarantee that under the
assumption of the security perimeter an attacker cannot learn anything about private parts.


\subsection{Information Flow Control}
\label{sec:ifcao}
Information flow control \cite{dd:77} technically uses an {\it information flow policy} 
which is given by the specification of a set of {\it security classes} to classify 
information and a {\it flow relation} on these classes that defines 
allowed information flows. System entities that contain information, for example variables , ,
are bound to security classes. Any operation that uses the value of  to calculate that of , creates a flow of information from  to .
This operation is only admissible if the class of  dominates the class of  in the flow relation,
formally written  where  denotes the class of entity .
The concept of information flow classically stipulates that the security classes together with 
the flow relation as an order relation on the classes are a lattice \cite{de:76,dp:02}. We differ here
since we only require a semi-lattice.

\subsubsection*{Information Flow Control for Active Objects}
Information is contained in data values which are here either objects or activity references
(see Section \ref{sec:aspfun}).
To apply the concept of information flow control to configurations of active objects, we need to
interpret the above notions of security classes, their flow relation, and the entities that
are assigned to the security classes: we identify the classes of our security model 
as the security classes of methods and the flow relation as the semi-lattice ordering 
on these classes (see Section \ref{sec:sml4mls}). 
Flows of information local to objects are generated by local method calls between
neighboring methods of the same object. These are regulated by the local -classification of an 
object's methods ( may call  {\it and}  -- but  only ). 
Global flows result from remote method calls between objects' methods.
The combined admissible flows have to be in accordance with a concrete 
configuration and its  specification. 



\subsection{Enforcing Legal Information Flows}
To illustrate the task of controlling information flows, 
we first extend the intuition about information flow to configurations of active objects. 
An active object sees only other active objects that are directly referenced in its methods
or those active objects that are indirectly visible via public methods of visible objects.
From the viewpoint of one active object, 
information may flow into the object and out of the object.
For each direction, there are two ways how information may flow: implicit or explicit (direct) flows.
Information flows {\it explicitly into} an object by parameters passed to remote calls directed to 
the object's methods; it may also flow {\it implicitly into} the object simply if the choice
of which method is called depends on the control flow of the calling object. Similarly,
information flows {\it explicitly out} of an active object by parameters passed to remote method
calls and {\it implicitly out} of it, if the choice depends on the object's own control flow.
Some of these flows are illustrated on our running example next.

\subsubsection*{Running Example: Implicit Information Flow}
\label{sec:ifex}
We will now finally illustrate the security model on the running example showing
implicit information flows of active objects introduced above in Section \ref{sec:ex}. 
Let us assume that the implementation of the -objects featuring in the controller's list
had the following implementation.

\begin{small}

\end{small}

Let us further assume that ord is again a public method and income again the private field of
.
We have here a case of an implicit information flow. Since the guard of the if-command in ord 
depends on the private field income, effectively the order number of a -object is 1 if the 
income of  is more than 1000 else 0. In our security model this control flow represents
an illicit flow of information from a high level value in  to its public parts and is thus 
visible to the remote controller. This should not be the case since  L. 
It should thus be detectable by an information flow control analysis. We will show next how to
 detect it statically by a security type system.





\section{Security Type System}
\label{sec:types}
Before formalizing security of active objects and defining a type system that implements
rules for a static analysis, we summarize the security considerations so far and motivate the 
upcoming type system and proofs.
\subsection{Intermediate Summary, Motivation, and Outlook}
\label{sec:typesmotiv}
In a configuration of active objects we may have direct (explicit) and implicit information flows
through method calls which are controlled differently.
\begin{itemize}
\item To guarantee only legal information flows on direct calls we rely on the labeling of
   methods by  and  and on the global hierarchy. This corresponds to the simple security
   property of {\it confinement}: remote method calls can refer only to low methods of visible objects. 
   Confinement can be locally checked. It is decidable since it corresponds to merely looking up 
   method labels in a security assignment. 
\item We will use a program counter  that records the current security level of a method evaluation. 
    Locally, within the confinement zone of an activity, 
accessing -methods in -methods may create implicit flows -- as seen in the example.
    To detect such flows and protect the confidential information from flowing out of the 
    confinement zone of the activity, the program counter records these dependencies by 
    increasing to . In combination with the method labels, the  thereby allows 
    associating the calling context with the called method. Implemented into type rules,
    this enables static checking and thus controlling of information flows in evaluations 
    of configurations. 
\end{itemize}
As a security enforcement mechanism of our multilateral security model for active objects, 
we propose a security type system, \ie a rule set for static analysis of a configuration with respect
to its methods' security assignment. The idea of a security type system is as follows.
Not all possible programs in \aspfun are secure. In general, for example, any method can be accessed
in an active object. The purpose of a type system for security is to supply a set of simple rules defining
types of configurations enabling a static check (before run-time) whether those contain only allowed 
information flows.

The above described cases of information flows need to be implemented in the type rules such that the 
rules allow to infer a type just for secure configurations and otherwise reject them.
The first direct case of information flow is intuitively simple, as it boils down to locally looking-up 
the security level of a method before deciding whether a remote call from up in the hierarchy can be 
granted.
The ``up in the hierarchy'' is encoded in a subtype relation  encoding the global hierarchy
described by the visibility relation. After the presentation of the type system in this section, we 
prove in the following Section \ref{sec:props} that confinement is a security property implied by it.

How to avoid and detect implicit flows, is more subtle: the combination of a program counter 
with the called method's security label grants us to combine the provenance of one call with the
security level of the call context. However, this combination needs to adhere to the security specification 
for all runs of a program and thus all possible calls in a context. The appropriate notion of security
for this is noninterference: in all runs the observable (low) parts of configurations need to look
``the same''.  Therefore,  we first introduce a notion of noninterference for active objects 
based on which we will then 
be able to express the absence of implicit flows and prove multilateral security.
The definition of noninterference and proofs of properties are contained in Section 
\ref{sec:props}. We first introduce the type system.

\subsection{Type System}
\label{sec:typesformal}
\subsubsection*{Type Formation}
We need to provide types for objects and for configurations of active objects;
the latter by mapping names of futures and activities to object types.
The two-dimensional classification of local and global security described above
translates directly into the object types of the security type system.
A type is a pair   where .
The first part  provides the partition of methods into 
public () and private () methods for the object. 
The other element  of an object type represents the global
classification of an object. This global level corresponds to the
classification of the object's surrounding activity  derived from its visibility.
We adopt the following naming conventions for variables.
 stands for the global part of a type.
We use  to denote security assignments, e.g. .
, or simply , stands for levels  or .
In general, we use indexed variables to designate result values of a function, 
e.g.,  for the level value of method  -- also expressed as .
We use  for object types .
To map an object type  to its security assignment or its global part,
respectively, we use the projections  and .
We formally use a parameter  as the parameter for the overall 
methods' security assignment of an entire configuration . 
A triplet of maps is a configuration type 
 
assigning types to all activities and futures of a configuration in addition containing 
the security assignment .

\subsubsection*{Typing Relations}
A typing judgement  reads: 
given type assumptions in , term  has type 
in the context of a program counter . 
A program counter () is a common technique in information flow control 
originating in Fenton's Data Mark Machine \cite{fen:73}. The  encodes the highest security level that has been reached in all possible control flows leading 
to the current control state. In a functional language, like \aspfunp, this highest security level of all execution paths simply is the level of the evaluation context 
for the term .
Thus, the  is some  denoting the security label of the local context. 
The type environment  contains types  for the parameter variables
 and types for the parameter {\it this} both paired with the local security 
level  representing their local .


\subsubsection*{Subsumption Rules}
Subsumption means that an element of a type also has the type of its super-type. 
It is responsible for making the partial order relation on global levels a subtype relation. 
Intuitively, {\sc Glob Subsumption} says that if a term can be typed in a low context
it may as well be ``lifted'', \ie considered as of higher global level thereby enforcing 
(together with {\sc Type Call} below) that only -methods can be accessed remotely.
This corresponds to the confinement property as formally shown in Section \ref{sec:conf}.
The local security class ordering is  and features implicitly in the type 
system in the form of a second -- the local -- subsumption rule.
Finally, the rule {\sc SecAss Subsumption} allows the security assignment type of an object
to be extended. This rule is necessary to consider an object also as a local object
inside another (active) object adopting its security assignment.
\begin{table}[!h]
\vspace{-3ex}
\begin{mathpar}
 \inferrule [Loc Subsumption]
  {T; L \vdash x : (A, \delta)}{T; H \vdash x : (A, \delta)}   

 \inferrule [SecAss Subsumption]
  {T; S \vdash x : (A, \delta) \\ A \subseteq A'}{T; S \vdash x : (A', \delta)}

 \inferrule [Glob Subsumption]
  {T; L \vdash x : (A, \delta) \\ \delta \sqsubseteq \delta'}{T; L \vdash x : (A, \delta')}
  \end{mathpar}\centering
\vspace{-3ex}
  \caption{Subsumption rules, , }
  \label{tab:sectypeord}
\vspace{-3ex}
\end{table}

\subsubsection*{Object Typing} 
\begin{table}[!h]
\vspace{-3ex}
\begin{mathpar}
  \inferrule [Val Self]  
      {}{\symb{this}\!:\! \Sigma \coloncolon T; \sqcup_{i \in 1..n} S_i \vdash \symb{this}\!:\! \Sigma}

  \inferrule [Val Local]
      {}{x: \Sigma :: T; S \vdash x: \Sigma}

  \inferrule [Type Object] 
    { \forall i \in 1..n.\ \\\\ \symb{this}\!:\! \Sigma \coloncolon y\!:\! \Sigma \coloncolon T; S_i \vdash t_i : \Sigma}
    {T; \sqcup_{i \in 1..n} S_i \vdash [l_i  = \varsigma(y) t_i]^{i \in 1..n}: \Sigma }

 \inferrule [Type Call] 
    {  T; S \vdash o : \Sigma \\\\ 
       j \in 1..n \\ T; S_j  \vdash t: \Sigma}
    {T; S_j \vdash o.l_j(t) : \Sigma}

 \inferrule [Type Update]
    {T; S \vdash o: \Sigma \\\\
    j \in 1..n\\ \symb{this}\!:\! \Sigma\coloncolon y\!:\! \Sigma\coloncolon T; S_j \vdash t : \Sigma}
    {T; S \vdash o.l_j := \varsigma(y) t: \Sigma }
  \end{mathpar}\centering
\vspace{-2ex}
  \caption{Type rules for objects; }
  \label{tab:sectype}
\vspace{-3ex}
\end{table}
The object typing rules in Table \ref{tab:sectype} 
describe how object types are derived for all possible terms of \aspfunp.
The {\sc Val}-rules state that type assumptions stacked on the type environment  
left of the turnstile  can be used in type judgments.
These rules apply to the two kinds of environment entries for {\it this} and for the -parameter.
Since the {\it this} represents the entire object value itself, its  is
derived as the supremum of all security levels assigned to methods in it. We 
express this supremum as the join over all levels .
The other rules are explained as follows.
{\sc Type Object}: if every method  of an object is typeable with some local type 
 assigned to it by the assignment component  of , then
the object comprising these methods is typeable with their maximal local type.
Thus, objects that contain  methods cannot themselves be contained in other -methods.
Otherwise, local objects containing confidential parts could be typed with {\sc Glob Subsumption}
at higher levels (see the Appendix for a ``borderline example'' illustrating this point). 
Only objects that are purely made from -methods can be accessed
remotely in their entirety. Albeit this strong restriction, the {\sc Call} rule permits
selectively accessing  methods of such objects (see below).
The {\it PC} guarantees that all method 
bodies  are typeable on their given privacy level .
The rule {\sc Type Call} is the central rule 
enforcing that only  methods can be called in any object -- locally or remotely.
Initially, a call  can only be typed as 
 for the  of the surrounding object .
Although the  in the typing of  is (by {\sc Type Object}) the maximal level of all methods,
we may still call -methods on objects that are typed with  as . 
The  in the typing of the resulting call  is coerced to , \ie the
security level assigned to the called method. This prevents  methods from being 
callable remotely while admitting to call methods on objects that are themselves typed 
in a -{\it PC}.
Because of the rule {\sc Glob Subsumption} any method call  can 
also be interpreted as  for  
but this is restricted to  contexts: a method call typeable in an  context 
cannot be ``lifted'', 
\ie it cannot be interpreted as well-typed  with ; to prevent this,
the {\it PC} in {\sc Glob Subsumption} is  thus excluding {\sc Call} instantiations
for methods  with .
{\sc Update}: an update of an object's method is possible but conservatively, \ie the types must remain the same.

\subsubsection*{Configuration Typing}
The rules for configurations (see Table \ref{tab:typeconf}) use the union of all futures of a configuration.
\begin{definition}[Future Domain]
Let  be a configuration. We define the domain of all futures of .
 
\end{definition}

The rules for configurations anticipate two semantic properties of futures in well formed \aspfun 
configurations. We use well-formedness of \aspfun configurations as defined in \cite{hkl:11}; 
in brief: there are no dangling references. 

\begin{property}[Unique Future Home Activity]
\label{prop:futact}
Every future is defined in the request queue of one unique activity.

We denote this unique activity  as . \hfill
\end{property}

Next, every future  in a well formed configuration  is created by a call to a unique label in its home activity. 
\begin{property}[Unique Future Label]
\label{prop:futlab}
Let  be the unique . Then,

We denote this unique method label as . \hfill
\end{property}
We omit the configuration  for the previous two operators if it is clear from context.

The configuration type rules
link up types for activities and futures with the local types of terms
in active objects and request lists (see Table \ref{tab:typeconf}).

\begin{table*}[ht]
\vspace{-3ex}
\centering
\begin{mathpar}
  \inferrule [Type Active]
   {\langle \Gamma_{\symb{act}}, \Gamma_{\symb{fut}}, \symb{sec} \rangle, T; S \vdash a: \Sigma}
   {\langle \Gamma_{\symb{act}}, \Gamma_{\symb{fut}}, \symb{sec} \rangle, T; S \vdash \symb{Active}(a): \Sigma}

  \inferrule [Type Active Object Reference]
   {\beta\in\dom(\Gamma_{\symb{act}})}
   {\langle \Gamma_{\symb{act}}, \Gamma_{\symb{fut}}, \symb{sec} \rangle, T, M_\beta \vdash \beta: \Gamma_{\symb{act}} (\beta) }

  \inferrule [Type Future Reference]
   {f_k \in \dom(\Gamma_{\symb{fut}})}
   {\langle \Gamma_{\symb{act}}, \Gamma_{\symb{fut}}, \symb{sec} \rangle, T; \symb{ass}(\Gamma_{\symb{fut}}(f_k))(\symb{futlab}(f_k)) \vdash f_k: \Gamma_{\symb{fut}} (f_k)}

  \inferrule [Type Configuration]
   {\dom (\Gamma_{\symb{act}}) = \dom (C) \\ \dom(\Gamma_{\symb{fut}}) = \dom_{\symb{fut}}(C) \\
   \bigcup_{\alpha \in \dom(C)} \symb{ass}(\Gamma_{\symb{act}}(\alpha)) \subseteq \symb{sec} \\\\
      {\forall\,\alpha[Q,a]\in C.~ 
\left\{ \begin{array}[c]{@{}l@{}}
          \langle \Gamma_{\symb{act}}, \Gamma_{\symb{fut}}, \symb{sec}\rangle, 
             \varnothing; M_\alpha \vdash  a: \Gamma_{\symb{act}}(\alpha)\land\\
      \forall\, f_k \!\in\! \dom(Q).\,
               \left\{ {\begin{array}[c]{@{}l@{}}
\Gamma_{\symb{act}}(\alpha) = \Gamma_{\symb{fut}}(f_k)\land\\
                 \langle \Gamma_{\symb{act}}, \Gamma_{\symb{fut}}, \symb{sec}\rangle, 
                          \varnothing; \symb{ass}(\Gamma_{\symb{act}}(\alpha))(\symb{futlab}(f_k))
                                                    \vdash  Q(f_k): \Gamma_{\symb{fut}}(f_k)\\
                \end{array}}  \right.
        \end{array} \right. }}
{\vdash C: \langle\Gamma_{\symb{act}}, \Gamma_{\symb{fut}}, \symb{sec} \rangle }

\end{mathpar}
\vspace{-2ex}
 \caption{Typing configurations; }
  \label{tab:typeconf}
\vspace{-3ex}
\end{table*}

{\sc Type Active} allows to transfer the type of an object term to its activation which
coerces the types of activities and activity references to coincide with the types
of their defining objects. This is achieved together with {\sc Type Active Object Reference} and the clause 

of {\sc Type Configuration}.

{\sc Type Future Reference} similarly assigns the types for the future references in .
For a given activity ,
this rule further coerces the  for the typing of  to coincide with , 
i.e., 's security assignment applied to the label that leads to the instance of .

The rule {\sc Type Configuration} ensures consistency between the type maps ,
, and the overall security assignment {\it sec}.
It looks rather complex but it essentially only scoops up what has been prepared by
the other rules. The first two clauses ensure that the domains of activities coincide 
with the configuration domain and similarly for futures that the future type map 
 is defined over precisely all futures
in all activities.  The third clause integrates the security specification 
 to be respected by the individual security assignments of activities. 
The last large clause of {\sc Type Configuration} specifies first that the activity types assigned 
to activity references by  coincide with their active object types.
The second part of that clause addresses the future types in . 
Note, that in the context of this clause we may assume 
 by Property \ref{prop:futact}.
The clause ensures that the types assigned by  coincide with the
ones assigned by  to their home activity.
Additionally, this final clause ensures that the request  must have the type
assigned by the future map  for this future  with the  that
corresponds to the  assigned by the security assignment in the home activity.

\subsection{Running Example: Type System Checks Example}
\label{sec:extest}
For the sake of argument, we illustrate the application of the type system
with an inconsistent constraint on the assignment {\it sec} for the example in Section \ref{sec:ex}. 
The extended implementation as discussed in Section \ref{sec:ifex} contains the following changed ord function (we repeat the code here for convenience).

\begin{small}

\end{small}

If we specify income as private, this extended version of the running example may contain an implicit 
illegal information flow.
Any security assignment  that fulfills the constraint must be fallacious
since the call .ord in the manager object  reveals information 
about the confidential () value of income. 
The type system rejects any such  since no consistent type can be inferred for the 
configuration in this case as we illustrate next. 
The failed type checking thus proves that for the extended configuration all specifications
would have to specify income  because the assumption income  was inconsistent.

The global classification is derived according to the visibility relation (Definition \ref{def:vis})
from the example's configuration as  for all . 
To be able to type the call to  in manager object 
this method must be an -method according to {\sc Type Call}. Hence, we need
to have the following extended constraint on {\it sec}.

The third clause of {\sc Type Configuration}, \ie 
,
gives us the constraint 

since {\it sec} and  are both functions.

We show now that  (for an arbitrary  in the configuration) cannot be typed with this
type constraint.
The final step in a type inference to arrive at a type 
for  can only be an instance of {\sc Type Object} which looks as follows.
\begin{mathpar}
  \inferrule [Instance Type Object] 
    { \symb{this}\!:\! \Sigma_{\beta_i} \coloncolon []\!:\! \Sigma_{\beta_i}
      \coloncolon \varnothing; A(\text{ord}) \vdash  t_{\text{ord}}: \Sigma_{\beta_i} \\\\
      \symb{this}\!:\! \Sigma_{\beta_i} \coloncolon []\!:\! \Sigma_{\beta_i}
      \coloncolon \varnothing; A(\text{income}) \vdash  t_{\text{income}}: \Sigma_{\beta_i}}
    {\varnothing; \sqcup \{A(\text{ord}), A(\text{income})\} \vdash\\\\
      [\text{ord}  = \varsigma(y)\ t_{\text{ord}}, \text{income} = \varsigma(y)\ t_{\text{income}}]: \Sigma_{\beta_i}}
\end{mathpar}
We write  for ,
, and 
. 
In fact, a more technical definition of  is

where {\it true} is a boolean object containing methods if, then, and else.
The details of this boolean object and its typing as well as the details of the following
abridged reasoning are contained in Appendices  and .
The main point that we can see from this implementation is that the 
type  is coerced by the type , \ie 
it must hold that  in .
This is the case, because  is a call to the method if. 
According to the rule {\sc Type Call}, the  must thus be  
which corresponds here to  and coincides with the  
 in the above instance of {\sc Type Object}, \ie .
Now, the remaining argument just shows that  must be .
In short form, the reasoning for the latter goes as follows. 
By assumption,  must be . Thus
according to {\sc Type Call} and {\sc Val Self}, {\it this}.income is typeable 
only with  as . We must apply {\sc Type Call} twice, to type
.
The  for typing this is  each time because it must be the 
same as the  (named ) in typing the parameter (named  in the 
rule {\sc Type Call}) and the previous typing of the parameter 
{\it this}.income has a -.
The  in the application of the rule {\sc Type Update} is then also coerced
to  in the typing of the newly inserted body method , here ``if''. 
Hence, this update coerces the   to be , \ie 
 to be . 
The two following updates do not change the security type of the method if.
We are finished since as we have seen above 
. Thus,  must be  and cannot be
typed  as would be necessary to call this method remotely in .
The typing fails. We have a contradiction to the initially required specification 
that income be private. Since this was the only assumption, if follows by contraposition
that income must be  to make the configuration typeable.

This illustrates the correctness of the type system by example: the configuration  of 
our running example cannot be typed with the constraint income  since any 
attempt to infer a type  
for it fails.
The type inference reveals the dependency between ord and income: a security
leak because it would enable implicit information flows from 's private part to
.

In the following, we provide general proofs showing that the type system is sound, i.e., it
generally implies security not just for the example.


\section{Properties}
\label{sec:props}

\subsection{Preservation}
Type safety includes always a preservation theorem: if a program can be typed,
the type has to be preserved by the evaluation of the program -- otherwise the guarantees
encoded in the types would be lost. In our case, since configurations dynamically change during the
evaluation with the reduction relation , the preservation has a slightly unusual form as the 
configuration type actually changes. But this change is conservative, \ie dynamically
created new elements are assigned new types but old types persist, as represented below 
by .
Alongside the configuration types, also the security class lattice is extended likewise
in a conservative way by extension of the visibility relation.

\begin{theorem}[Preservation]
\label{thm:subred}
\begin{small}

where  and .
\end{small}
\end{theorem}

The proof of this theorem has two parts. The first part shows a local preservation property
for the part of the type system that describes secure method calls at the level of objects, i.e.,
the rules depicted in Tables \ref{tab:sectypeord} and \ref{tab:sectype}. The second part of the proof
addresses the typing rules at the global level, i.e., the configuration typing rules depicted in 
Table \ref{tab:typeconf}. Both proofs are straightforward using the induction schemes corresponding to
the inductive rule definitions of the type rule definitions. Albeit the relatively small size of the 
computation model \aspfunp, these rules are fairly complex. Hence to avoid mistakes in these proofs we have 
formalized them in Isabelle/HOL. 
The Isabelle/HOL sources can be found at \url{https://sites.google.com/site/floriankammueller/home/resources}.

\subsection{Confinement}
\label{sec:conf}
Confinement is the property of our type system encoding the principal idea of
the security model: if a method of an object can be called remotely, it must be a
public  method.
As a preparation to proving confinement, we present next a chain of lemmas that lead up to it.
Let  be an object and  be an arbitrary type environment throughout the following formal
statements.



The type rules for subsumption allow that 
types of objects can be ``lifted'', \ie
objects can have more than one type. We lose uniqueness of type judgments. To overcome this, we use a well-known trick (already
been used in the Hindley-Milner type system for ML to accommodate polymorphic types) 
to regain some kind of uniqueness: minimal types. 
\begin{definition}[Minimal Type]
Define the minimal type in the  context of  as follows.

\end{definition}
This provides at least that minimal types of local typings are unique.
\begin{lemma}[Minimal Type Uniqueness]
Let .
If  and , 
then .
\end{lemma}

A slightly stronger form of that previous lemma exists for  s.
\begin{lemma}[High PC Uniqueness]
If  and , then .
\end{lemma}

Using slight generalization and contraposition, the previous lemma can be strengthened to the following key
lemma for confinement.
\begin{lemma}[Abstract Confinement]
\label{lem:absconf}
If  and  and , 
then .
\end{lemma}
The following key fact, about the minimal type for futures provides the anchor to apply 
Abstract Confinement and arrive at Confinement.
\begin{proposition}[Minimal Future Type]
\label{prop:minfut}
Let ,
, and  the home activity of . Then 

\end{proposition}


\begin{theorem}[Confinement]
\label{thm:conf}
If a future  is typeable with an arbitrary   as of type  strictly larger than
the global level of 's home activity , then  has been initially generated from a call
to an  method of .
Formally, 
let , , 
and  with
 
Then 

\end{theorem}

The proof of confinement is basically just a combination of Lemma \ref{lem:absconf}
and Proposition \ref{prop:minfut}. The chain of lemmas and confinement have been proved in Isabelle/HOL
as well.

\subsection{Noninterference}
Confinement can be considered as a simple security property because it 
is similar to a safety property:
confinement is preserved on every trace of execution of a configuration. Intuitively it seems to imply confidentiality of private parts but this is only true 
for direct information flows.
Confidentiality necessitates that no information is leaked to an outsider even considering implicit information flows as 
described in Section \ref{sec:sec}. Based on those observations, we define the general property 
of confidentiality as {\it noninterference}, informally meaning that an attacker cannot learn anything despite
his ability to observe configurations on all runs while comparing values that he can see: a difference
in the value of the same call allows deductions about a change in hidden parts. The formal 
definition of noninterference for active objects in general \cite{kam:12}
is a bisimulation over the indistinguishability 
relation  on configurations. We omit the rather technical definition of indistinguishability 
referring to Appendix D. Essentially, indistinguishability says that  and  appear equal to the 
attacker 's viewpoint  
even if they differ in secret parts; noninterference means that this appearance is preserved by the evaluation of configurations. 
\begin{definition}[-Noninterference]
\label{def:ni}
If configuration  is indistinguishable to any  for  with respect to {\it sec} 
and remains so under the evaluation of configurations , 
then  is -noninterfering.
Formally, we define -noninterference  {\it sec} as follows.

\end{definition}
A main result for our security type system is {\it soundness}: a well-typed configuration is secure; 
-noninterference holds for the configuration, i.e., it does not leak information.
\begin{theorem}[Soundness]
\label{thm:ni}
For any well-typed configuration , 
we have noninterference with respect to , \ie



\end{theorem}
The proof of this theorem is a case analysis distinguishing the 
cases where a reduction step of the configuration has happened 
in the -visible part or outside it. 
In the latter case, a difference in the visible part would mean a breach of confinement.
Within the visible part, a straightforward case analysis shows that what is possible
in one configuration must also be possible in the other, indistinguishable, one, since 
those parts are isomorphic; hence the same reduction rules apply.
We have formalized the definitions of indistinguishability, noninterference, and 
multilateral security, as well as the statements of the theorems in Isabelle/HOL
-- only the soundness proof is not yet formalized but a detailed paper proof is
contained in Appendix E.

The parameterization of the attacker as an active object  grants the 
possibility to adapt the noninterference predicate.
If we universally quantify  in our definition of noninterference, we 
obtain a predicate where each object could be the attacker corresponding to multi-lateral security.
\begin{definition}[Multi-Lateral Security]
If a configuration  is -noninterfering for all
 then multi-lateral security holds for .
\end{definition}
Since no  is fixed in the type statement, the soundness theorem holds
for any  if the configuration is well-typed. Hence, well-typing implies
immediately multi-lateral security.




\section{Related Work and Conclusions}
\label{sec:concl}
The main difference of our approach is that we specifically address functional active 
objects. We also use a non-standard security model \cite{kam:12} for 
multi-lateral security tailored to distributed active objects.
Other work on actor security, e.g. \cite{hmss:07}, is based on message passing
models different to our high level language model. The paper \cite{achl:07}
addresses only direct information flows in active objects.
The priority program Reliably Secure Software Systems (RS3) of the 
German Research Foundation (DFG) \cite{rs3:10} addresses in its part project MoVeSPAcI 
\cite{pf:11} security of actor systems using an event based approach without futures.

The Distributed Information Flow Control (DIFC) approach \cite{ml:97} provides
support for Java programs (Jif) to annotate programs with labels ``Alice'' 
and ``Bob'' for information flow control. In this approach objects are not first class
citizen. The formal model \cite{zm:07} uses a lambda calculus  to 
accommodate the rich hierarchy of labels but (Java) objects are not in the calculus.
They use an elegant approach to prove noninterference of a type system for labels
pioneered by \cite{ps:03} Pottier and Simonet. This approach does not apply to parallel 
languages since the evaluation order of parallel processes is not deterministic.

Reactive Noninterference, e.g. \cite{DBLP:journals/jlp/MatosBC07}, \cite{bpswz:09},
adopts a reactive system view. Some of these works, 
e.g. \cite{occ:06}, use a while language in their formal models and bisimulation
based noninterference notions but the semantics is message passing by events.

The language based approach has its beginnings in \cite{vsi:96,vs:97}.
\cite{sv:98} offer the first model of language based 
information flow control  for concurrency, later refined by Boudol and Castellani
addressing scheduling problems and related timing leaks.
Many works have followed this methodology (see \cite{sm:03} for an overview).
However, most works consider imperative while languages with various extensions 
like multi threading. 
Barthe and Serpette  \cite{bs:00} have considered security type systems for -objects
but no distribution. Later, Barthe and others 
\cite{bpr:07,kam:08} provide information flow control for Java-like languages. 
Sabelfeld and Mantel consider message passing in distributed programs \cite{sm:02,ms:03}.
These works use the secure channel abstraction, i.e. connecting remote processes of
the same security class via secure channels integrating security primitives.

Distributed security has also been considered in many works in the setting of process algebras
most prominently using pi calculus by \cite{Mil:89}
(see \cite{fg:95} and \cite{rsglr:00} providing overviews). 
Commonalities of process algebra based security to our work are the bisimulation notion of 
noninterference and asynchronous communication. 
The spi calculus by \cite{ag:97} extends the pi calculus with constructs for encryption and
decryption. It is thus a forerunner for current work that integrates encryption primitives
into languages, most prominently homomorphic encryption \cite{fpr:11}.
The applied pi calculus \cite{af:01} in contrast is a generalisation of Milner's original
pi calculus with equational theories, i.e. functions and equations.
Thereby, extensions by cryptographic primitives are possible.
The applied pi calculus is used for security protocol verification. An 
implementation is the model checker ProVerif by \cite{cb:13}. 
There is a line of research on mobile calculi that use purely functional concurrent
calculi. A few representative papers are by \cite{hvy:00} on the pi calculus and
\cite{hr:02} for the security pi calculus. 
An impressive approach on information flows for distributed languages with mobility and states 
\cite{mc:11} first introduces declassification. Similar work is by \cite{bcc:01} also studying 
noninterference for distribution and mobility for Boxed Ambients.
\cite{bf:08} deviates from the applied pi calculus generality focusing on core abstractions
for security in distributed systems, like secure channels \cite{bf:10}.
In common with these works are modeling distributed system by a calculus but 
none of the pi calculus related work focuses on active objects while we do not
consider cryptographic primitives.
An interesting perspective would be to investigate the relationship between confinement
and effects of cryptographic primitives.
We also use a bisimulation-based equivalence relation to express noninterference.
In the applied pi calculus, for example, the notion of a static equivalence, similar
to our indistinguishability is used in addition to observational equivalence
that corresponds to our notion of noninterference (see e.g. \cite{dkr:10}). 

This work presented a formal framework for the security of active objects based on 
the semi-lattice security model that propagates confinement.  
We presented a safe security type system, that verifies the confinement property  and
is sound, i.e., checks security, with respect to a dedicated formal notion of noninterference, 
or more generally, multi-lateral security. 
\aspfun makes secure down-calls possible and is still applicable bi-directionally as 
illustrated by implementing the NSPK protocol. 
The proofs have been in large parts formalized in Isabelle/HOL.
An implementation of functional active objects is given by Erlang Active Objects in \cite{fk:10}
also providing a simple extension by a run-time monitor for confinement \cite{fk:11}.



\bibliographystyle{IEEEtranS}
\bibliography{biblio}

\section*{Appendix}
\subsection*{A: Booleans and conditional in the -calculus and their security types}
To prepare for the type inference, we need the implementation
of the boolean datatype and the {\it if-then-else} in the -calculus, i.e. in the local calculus of \aspfunp. 



In the third line above, ;  denotes the empty
object. The definition shows how -- similar to -calculus -- the functionality of
the constructor is encoded in the elements of the datatype: when  is true 
its method if delegates to the method then, filled with
term , when false, if delegates to else, executing term .

Typing of the {\it if-then-else} construct is a base test for an information flow
type system as this construct is the basic example that gives rise to implicit
information flows. We will thus here illustrate how the security type rules presented
in this paper establish that the guard of the {\it if-then-else} construct, the if, must
be typed with the same  as the branches, \ie then and else. Then it immediately follows
that if the method if has - then the branches must have - as well.
The reasoning instantiates type rules showing the constraints that follow for the
security assignment in the security type .

A condition  in the method if of an {\it if-then-else} object evaluates 
to either  or . We consider those two possibilities and infer
their types and the resulting constraints. 

To type {\it true}, we initially type {\it this} which can be done only by rule {\sc Val Self}
leading to the following typing where  
is the security type for the {\it if-then-else} object and 
.
We use the arbitrary set of additional type assumptions  provided by the rule to integrate
the type assumption for  already here. It is needed further down for typing the object but only
formally.

\begin{small}
\begin{mathpar}
\inferrule[Instance Val Self]
{this\!:\! \Sigma_{\text{ifte}} \coloncolon(y\!:\! \Sigma_{\text{ifte}}) \coloncolon T; M_{\text{ifte}} \vdash \symb{this}\!:\! \Sigma_{\text{ifte}}}
{}
\end{mathpar}
\end{small}

We then apply the rule {\sc Type Call} to infer a type for {\it this}.then.
The following instance of that rule sets the parameters such that it can be applied to the
previous {\sc Instance Val Self}.

\begin{small}
\begin{mathpar}
\inferrule [Instance Type Call]
{\symb{this}\!:\! \Sigma_{\text{ifte}}\coloncolon y\!:\! \Sigma_{\text{ifte}} \coloncolon T; M_{\text{ifte}} \vdash \symb{this}\!:\! \Sigma_{\text{ifte}}\\\\
\symb{this}\!:\! \Sigma_{\text{ifte}} \coloncolon y\!:\! \Sigma_{\text{ifte}} \coloncolon T; A_{\text{ifte}}(\text{then})\vdash []\!:\! \Sigma_{\text{ifte}}
}{\symb{this}\!:\! \Sigma_{\text{ifte}} \coloncolon y\!:\! \Sigma_{\text{ifte}} \coloncolon T; A_{\text{ifte}}(\text{then}) \vdash \symb{this}.\text{then}([])\!:\! \Sigma_{\text{ifte}}}
\end{mathpar}
\end{small}

Now, to type the {\it true} object including its fields then and else
we next need an instance of {\sc Type Object}.

\begin{small}
\begin{mathpar}
  \inferrule [Instance Type Object] 
  { \symb{this}\!:\! \Sigma_{\text{ifte}} \coloncolon y\!:\! \Sigma_{\text{ifte}} \coloncolon T; 
                  A_{\text{ifte}}(\text{if})\vdash \symb{this}.\text{then}([]) :\Sigma_{\text{ifte}}\\
     \symb{this}\!:\! \Sigma_{\text{ifte}} \coloncolon y\!:\! \Sigma_{\text{ifte}} \coloncolon T; 
                  A_{\text{ifte}}(\text{then})\vdash [] :\Sigma_{\text{ifte}}\\
      \symb{this}\!:\! \Sigma_{\text{ifte}} \coloncolon y\!:\! \Sigma_{\text{ifte}} \coloncolon T;
                  A_{\text{ifte}}(\text{else})\vdash [] :\Sigma_{\text{ifte}}\\
     }
    {T; M_{\text{ifte}} \vdash \text{true} = \left[\,\text{if} = \varsigma(y) \symb{this}.\text{then}(y),
                  \text{then} = \varsigma(y) [], \text{else} = \varsigma(y) []\,\right] : \Sigma }
\end{mathpar}
\end{small}

The main observation is that the following constraint must hold for 

because this is necessary for the first proviso of the 
above instance to be matched with the previous type derivation for 
 by {\sc Instance Type Call}.

With a very similar argument for typing {\it false}, \ie , 
we arrive at a similar constraint.


Since for an arbitrary {\it if-then-else} guard  we have to allow both values
{\it true} and {\it false} as possible outcome we have to combine the constraints and
conclude for  the following overall constraint.

The update of the methods then and else does not change the  and thus
preserves the security assignment and the constraints.
This constraint is what we expect for information flow security. If the guard of an
{\it if-then-else} can only be typed in a - then its branches must also be
``lifted'' to . Only if the guard can be typed in a -, can the branches also 
be typed in -.

\subsection*{Note on typing constants}
In the above type rule instances we have used typings for constants, for example,
the empty object  as granted and did not refine them any further.

A word is in order to explain how these are constructed and their types are derived. 
A simple way to integrate the empty object into an activity is to add a method empty and then 
replace all  by {\it this}.empty. The security assignment should be . 
Then, we can use {\sc Type Call} to have  
and from there derive the above 
.
However,  (and other commonly used plain objects) can more practically be considered as
{\it activities without any  methods} that are included as a ``data base''
in a configuration. Then, an occurrence of  is literally the activity named ``empty object'',
\ie  is an activity reference. 
For the typing, the natural type of the empty object is given as the empty security assignment 
, \ie the partial function that is undefined for all inputs, and the
bottom element  of the visibility semi-lattice which corresponds to the empty set of
activity names.

By definition this typing with - as  for the empty object enables
typing  ``into'' any other activity type  because  and
. Thus -- by {\sc SecAss Subsumption}  and {\sc Glob Subsumption} -- 
. 

A similar type and subtyping argumentation goes for other constants, for example  or , used in
the running example. Similar to Church numerals simple term representation can be given to them
in \aspfunp. Such constant activities  must have their methods all assigned to , i.e.,
their security assignment  maps all method names of  to . Then the
 of the activity  is also  because it is given as  according to 
the rule {\sc Type Configuration}. The global level of a constant activity like  
is defined as the set . If the constant  is used by referencing
it in other activities of the configuration, the name  becomes part of the
other activities' global levels.


\subsection*{B: Running Example -- Details on Typing}
The following shows why the example configuration presented as running example cannot be typed
with income . 

\subsection*{Implementation}
The quicksort function  is described in Section \ref{sec:ex}.
The manager activity that controls the ordering of a list and the sorting object  that
calls the ord method in -objects are repeated here for convenience of the reader.

\noindent \begin{small}

\end{small}

\noindent \begin{small}

\end{small}


The extended method ord that bears a dependency between ord and income,
\begin{small}

\end{small}
is not typeable for any security assignment  that imposes the constraint that
method income . 
The following type inference elaborates that the type system rejects any
security assignment that contains the constraint income . 
It illustrates how the security assignment  is inferred.

\subsection*{Typing remote call implies ord }
Since the method ord is called remotely in  via  we need that ord ,
which cannot be possible because of the dependency in the above implementation.
To be able to type the call to  in the object   
this method must be an -method according to {\sc Type Call} and {\sc Glob Subsumption}.
More precisely, let .
We have that 
 because of {\sc Type Active Object Reference} and .
The  is  where  needs to be inferred 
in the process. We can use next {\sc Type Call} to type 
.
However, to type .ord in the context of the object  it needs to be typed as
 with global type component . This upgrading of the
call can only be achieved by application of rule {\sc Glob Subsumption} which requires
that  which is true but also requires that the 
of the typing , \ie , is .

\subsection*{Typing  at global level  only with -}
The next part of the argument states that the only type that can be inferred for a call 
is , \ie with -.
This is because types for calls can only be inferred by rule {\sc Call} and  
which coerces the  according to rule {\sc Call} to . 
For clarity of the exposition, we omit in the following 
 in front of the typings.
Since we want to arrive at ,
by the inversion principle of inductive type definitions,
all provisos of {\sc Type Configuration} have to be true.
Since

the fourth proviso, first clause, of {\sc Type Configuration} yields



The coercion of  to 
is a consequence of the typing of the object  with an instance of rule {\sc Type Object}.

\begin{small}
\begin{mathpar}
  \inferrule [Instance Type Object] 
    { \symb{this}\!:\! \Sigma_{\beta_i} \coloncolon []\!:\! \Sigma_{\beta_i}
      \coloncolon \varnothing; A_{\beta_i}(\text{ord}) \vdash  t_{\text{ord}}: \Sigma_{\beta_i} \\\\
      \symb{this}\!:\! \Sigma_{\beta_i} \coloncolon []\!:\! \Sigma_{\beta_i}
      \coloncolon \varnothing; A_{\beta_i}(\text{income}) \vdash  t_{\text{income}}: \Sigma_{\beta_i}}
    {\varnothing; M_{\beta_i}
     \vdash [\text{ord}  = \varsigma(y)\ t_{\text{ord}}, \text{income} = \varsigma(y)\ t_{\text{income}}]: \Sigma_{\beta_i}}
\end{mathpar}
\end{small}

This instance enforces  to be the same as the  in the typing of
 
The only way to arrive at a type for  is by an application of {\sc Type Call}
as in the following instance.

\begin{small}
\begin{mathpar}
 \inferrule [Instance Type Call] 
    {  T; S \vdash  (((\symb{true}.\text{if} := (\symb{this}.>0(\symb{this}.\text{div}_{10^3}(\symb{this}.\text{income}))))\\\\
  .\text{then} := 1).\text{else:= 0}): \Sigma \\\\ 
       T; A_{\beta_i}(\text{if})  \vdash []: \Sigma}
    {T; A_{\beta_i}(\text{if}) \vdash t_{\text{ord}} : \Sigma}
\end{mathpar}
\end{small}

In order to match the conclusion of the above with the first proviso of the earlier
{\sc Instance Type Object}, the security assignment of ord is coerced to that of if

We only need to show that  and we are finished.

\subsection*{Typing implies that }
The following chain of steps shows how a type for the body of ord and thus 
must be inferred detailing how the security assignment parameter  needs to 
be instantiated to .
The chain of reasoning starts from the one specified security assignment 
income  in  and shows that then also ord 
which contradicts the above ord . Hence, no type can exist with
the constraint income  for this configuration.

 is  by constraint on  and thus .
According to {\sc Val Self} with 

we get the following typing for {\it this}.



According to {\sc Type Call}, {\it this}.income is typeable  
only with  as  since .



The previous typing feeds into rule {\sc Type Call} again but this time
for the parameter . Since the   matches with  we get again
a - coercing the method  also to be assigned to 
in .



In the same fashion, the previous considered as a parameter typing
{\sc Type Call} consequently coerces  also to :



We instantiate {\sc Update} as follows.

\begin{small}
\begin{mathpar}
 \inferrule [Instance Type Update]
    {\varnothing; S \vdash \text{true}: (A_{\beta_i}, \delta_{\beta_i}) \\\\
    \symb{this}\!:\! \Sigma_{\beta_i}\coloncolon []\!:\! \Sigma_{\beta_i} \coloncolon \varnothing; A_{\beta_i}(\text{if}) \vdash \\\\
     \symb{this}.>0(\symb{this}.\text{div}_{10^3}(\symb{this}.\text{income})): (A_{\beta_i}, \delta_{\beta_i})  }
    {\varnothing; \sqcup \{A_{\beta_i}(\text{if}), \dots \} ) \vdash \\\\
\text{true}.\text{if}[] := \symb{this}.>0(\symb{this}.\text{div}_{10^3}(\symb{this}.\text{income})): (A_{\beta_i}, \delta_{\beta_i}) }
\end{mathpar}
\end{small}

The first proviso, the typing for {\it true} can be inferred as shown in the previous section,
using rule {\sc Sec Ass Subsumption} in addition to embed it into .
We spell out some portion of  above to
emphasize that   is part of the . 
The dots stand for 
and  etc. To match the previous derivation above of
 to the second proviso in the above instance it is necessary to coerce

We are finished here already because we have already shown above that  which thus is  contradicting the earlier requirement to be .

For completeness, we continue the derivation of the body of . 
From the previous step above, we get the conclusion 

\begin{small}

\end{small}

We can again instantiate the update rule.

\begin{small}
\begin{mathpar}
 \inferrule [Instance Type Update]
    {\varnothing; H \vdash \text{true}.\text{if}[] := \symb{this}.>0(\symb{this}.\text{div}_{10^3}(\symb{this}.\text{income})): (A_{\beta_i}, \delta_{\beta_i}) \\\\
    \symb{this}\!:\! (A_{\beta_i}, \delta_{\beta_i})\coloncolon y\!:\! (A_{\beta_i}, \delta_{\beta_i})\coloncolon \varnothing; H \vdash 1 : (A_{\beta_i}, \delta_{\beta_i})}
    {\varnothing; H \vdash \symb{this}.>0(\symb{this}.\text{div}_{10^3}(\symb{this}.\text{income})).\text{then}:= 1: (A_{\beta_i}, \delta_{\beta_i})}
\end{mathpar}
\end{small}

And a second time we instantiate {\sc Type Update} for  to finally obtain

\begin{small}

\end{small}

\subsection*{Running Example: Typing Summary}
The coercions revealed in the above steps determine the parameter  in summary as follows.

I.e., the only possible instantiation for  is . We cannot meet the required 
constraint  necessary to call it from the outside in  as 
explained initially. Therefore, the example configuration cannot be typed with the
constraint income .


\subsection*{Borderline Example for Confinement}
The confinement property states that remote calls can only be addressed to  methods.
But does this simple security property guarantee that no hidden  methods can be returned
with the reply to such a call? Consider the following example

where  is an integer representing a secret key. Let the security assignment for  be
.
One may think that an activity  could contain a call  
since the method leak is  enabling the remote call to . Once the
call result is returned into , it would evaluate to the active object of  
inside  (since {\it this} represents this active object of ). Since
we are now already in , it might seem possible to apply the method key to extract the key.

How does the security type system prevent this? 
Since the typing for {\it this} inside  is only possible with the 
as  (since ), 
the typing for {\it this} yields

\begin{small}

\end{small}

Typing the object  must use the following instance of {\sc Type Object}.

\begin{small}
\begin{mathpar}
  \inferrule [Instance Type Object] 
    { \symb{this}\!:\! \Sigma_{\alpha} \coloncolon y\!:\! \Sigma_{\alpha}
      \coloncolon \varnothing; A_\alpha(\text{leak}) \vdash  \symb{this}: \Sigma_{\alpha} \\\\
      \symb{this}\!:\! \Sigma_{\alpha} \coloncolon y\!:\! \Sigma_{\alpha}
      \coloncolon \varnothing; A_\alpha(\text{key}) \vdash  n: \Sigma_{\alpha}}
    {\varnothing; \sqcup \{A_\alpha(\text{leak}), A_\alpha(\text{key})\}
     \vdash [\text{leak} = \varsigma (y) \symb{this}, \text{key} = \varsigma (y) n]: \Sigma_{\alpha}}
\end{mathpar}
\end{small}

Now, matching the instance of {\sc Val Self} for {\it this} with the first proviso of the
instance of {\sc Type Object} coerces  to  contradicting the
initial specification. I.e., the method leak is forced to be  and cannot be called remotely.


\subsection*{C: Formal Semantics of \aspfun}
For a concise representation of the operational semantics, we define contexts as expressions 
with a single  hole ().  A context  denotes the term
obtained by replacing the single hole by .

This notion of context is used in the formal semantics of \aspfun in Table \ref{tab:asp_sem}
and also in the definition of visibility (see Definition \ref{def:vis}).
\begin{table*}[!ht]
\begin{mathpar}
    \inferrule [call] {l_i \in\{l_j\}^{j\in1..n}} {E\left[[l_j =
        \varsigma(y_j)s_j]^{j\in1..n}.l_i(t)\right] \loc E\left[s_i\{\symb{this}\gets[l_j
        = \varsigma(y_j)s_j]^{j\in1..n} ,y_i\gets t\}\right]}

    \inferrule [update] {l_i \in\{l_j\}^{j\in1..n}} {E\left[[l_j =
        \varsigma(y_j)s_j]^{j\in1..n}.l_i:=\varsigma(y)t\right]\loc
       E\left[[l_i=\varsigma(y)t,
        l_j=\varsigma(y_j)s_j^{j\in(1..n)-\{i\}}]\right]}

\inferrule[local]
  {s\loc s'}
  {\alpha[f_i\mapsto s \!\coloncolon\! Q,t]\coloncolon C \dist \alpha[f_i\mapsto s'\!\coloncolon\! Q,t]\coloncolon C }

\inferrule[active]
  {\gamma\notin (\dom(C)\cup\{\alpha\})\\\symb{noFV}(s) }
  {\alpha[f_i\mapsto E[\symb{Active}(s)]\!\coloncolon\! Q,t]\coloncolon C \dist \alpha[f_i\mapsto E[\gamma] \!\coloncolon\! Q,t]\coloncolon\gamma[\varnothing,s]\coloncolon C }

\inferrule[request]
  {f_k \text{ fresh}\\\symb{noFV}(s) \\ \alpha\neq\beta}
  {\alpha\left[f_i\mapsto E[\beta.l(s)]\!\coloncolon\! Q,t\right]\coloncolon\beta[R,t']\coloncolon C \dist \alpha\left[f_i\mapsto E[f_k] \!\coloncolon\! Q,t\right]\coloncolon\beta\left[f_k\mapsto t'.l(s)\!\coloncolon\! R,t'\right]\coloncolon C }

\inferrule[self-request]
  {f_k \text{ fresh}\\\symb{noFV}(s)}
  {\alpha\left[f_i\mapsto E[\alpha.l(s)]\!\coloncolon\! Q,t\right]\coloncolon C \dist \alpha\left[f_k\mapsto t.l(s)\coloncolon f_i\mapsto E[f_k]\!\coloncolon\! Q,t\right]\coloncolon C }

\inferrule[reply]
  {\beta[f_k\mapsto s\!\coloncolon\! R,t']\in\alpha[f_i\mapsto E[f_k]\!\coloncolon\! Q,t]\coloncolon C}
  {\alpha[f_i\mapsto E[f_k]\!\coloncolon\! Q,t]\coloncolon C \dist \alpha[f_i\mapsto E[s]\!\coloncolon\! Q,t]\coloncolon C }
  

\inferrule[update-AO]
  {\gamma \!\notin\! \dom(C)\!\cup\!\{\alpha\}\\\symb{noFV}(\varsigma(x,y)s)\\
  \beta[R,t']\!\in\!\alpha[f_i\mapsto E[\beta.l\!\!:=\!\!\varsigma(x,y)s]\!\coloncolon\! Q,t]\!\coloncolon\! C}
  {\alpha[f_i\mapsto E[\beta.l:=\varsigma(x,y)s]\coloncolon Q,t]\coloncolon C \dist \alpha[f_i\mapsto E[\gamma] \coloncolon Q,t]\coloncolon\gamma[\varnothing,t'.l:=\varsigma(x,y)s]\coloncolon C }
  \end{mathpar}  
\caption{\aspfun semantics}
  \label{tab:asp_sem}
\end{table*}


\subsection*{D: Indistinguishability}
In \aspfun active objects are created by activation, futures by method calls. Names
of active objects and futures may differ in evaluations of the same configuration but this does not
convey any information to the attacker. In order to express the resulting structural
equivalence, we use typed bijections like \cite{bn:03} that enable the definition of an isomorphism
of configurations necessary to define indistinguishability. This technique of using the existence
of ``partial bijections'' to define an isomorphism between configurations only serves to express
equality of visible parts but is rather technical as it needs to provide differently
typed bijections for the involved structure, e.g. futures, objects, and request lists. 


\begin{definition}[Typed Bijection]
A typed bijection is a finite partial function  on activities 
(or futures  respectively) such that for a type 

\end{definition}
By  we denote the equality of terms up to replacing all occurrences
of activity names  or futures  by their counterparts 
or , respectively, restricted to the label names in {\it sec}, i.e.,
in the object terms  and  we exempt those parts of the objects that are
private.
The local reduction with  of a term  to a value
 (again up to future and activity references) is written as .



\begin{definition}[Equality up to Name Isomorphism]
\label{def:ind}
An equality up to name isomorphism is a family of equivalence relations on \aspfun terms indexed by two typed bijections  and security assignment {\it sec}
consisting of the following differently typed sub-relations; 
the sub-relation's types are indicated by the naming convention:  for -terms, ,
 for active objects,  for futures,  for request queues.
1ex]
\alpha \indR \beta & \equiv & \sigma(\alpha) = \beta \1ex]
Q_{\alpha} \indR Q_{\beta}\  & \equiv\ &
      \left(\begin{array}{l}
            \dom(\tau) \supseteq \dom(Q_{\alpha}) \\
            \ran(\tau) \supseteq \dom(Q_{\beta}) \\
\all f_k \in \dom(Q_\alpha).\\
            Q_{\alpha}(f_k) \indR Q_{\beta}(\tau(f_k))
      \end{array}\right) \\ [1ex]

\alpha[Q_{\alpha}, t_{\beta}] \indR \beta[Q_{\beta}, t_{\alpha}] & \equiv & \alpha \indR \beta \wedge Q_{\alpha} \indR Q_{\beta} \wedge t_{\alpha} \indR t_{\beta} \
\end{definition}
Such an equivalence relation defined by two typed bijections  and  may exist
between given sets  of active object names in . If  correspond to the viewpoints
of attacker  in  and its counterpart in  we call this equivalence relation 
indistinguishability.


In the following, we use the {\it visibility range} based on Definition \ref{def:vis} as
.
\begin{definition}[Indistinguishability]
Let  be arbitrary configurations, well-typed with respect to a security specification \symb{sec}, 
active object  and  (we exempt  from renaming 
for simplicity).
Configurations  and  are called indistinguishable with respect to  and {\it sec}, 
if 's visibility ranges are the same in both up to name isomorphism.

\end{definition}

As an example for -indistinguishable configurations consider the running example.
In the original (non-fallacious) form, .income could be  in configuration 
and it could be  in configuration . Since income is specified as  those two configurations
can be considered as -indistinguishable (with respect to ). 
Attacker  sees no difference between the two. In the fallacious example, however, he'd notice a difference
when calling the quicksort algorithm that implicitly drafts information from income through ord:
here,  and  would be distinguishable since .ord is 0 in  and 1 in .



\subsection*{E: Noninterference Proof}
\it Theorem 2 (Soundness)}
For any well-typed configuration, 
we have noninterference with respect to , \ie

{\it Proof:}\\
Let  be another arbitrary but fixed configuration such that .
This means that for any , if  visibility range of  -- 
we have that  and  for some  and . 
That is, aside differently named  futures (and active object references) these two activities are structurally 
the same and contain the same values.
For the sake of clarity of the proof exposition, we leave the naming isomorphism
implicit, i.e. use the same names, e.g., , , for both sides, i.e., 
for  and .
Note, that
the type of the configurations  and  is in some cases an extension to the types of  and , 
as described in the Preservation Theorem \ref{thm:subred}.


The proof is an induction over the reduction relation combined with a case analysis whether an arbitrary 
 is in the visibility range of  or not.

If, for the first case,  by some reduction according to the semantics rules in the part of the configuration
that is {\it not visible} to , then for most cases trivially no change becomes visible by the transition to :
for any local reduction, this is the case since the visibility relation is unchanged. Hence, ``invisible'' objects remain invisible. 
If  and , then also  whereby we trivially have the conclusion since
 (in zero steps).
This observation is less trivial for the rules {\sc request} and {\sc active} where 
new elements, futures and activities, respectively, are created. In the case of {\sc request}, 
let  and  
with  in the -invisible part and  visible to .
The fact that there are no side effects provides that request  
created in the request step in , i.e.  in , 
is not -visible.

Similarly, if a new activity  is created from a method in  according to {\sc active}, 
then  will not be in the visibility range of  since  was not visible to  by Definition \ref{def:vis} of the visibility relation. 
Thus, for  not visible to , if  and , then also  
and the conclusion holds again because . This closes the case of 
{\it non--visible} reductions.

If  by some reduction in the {\it -visible} part, we need to consider all cases
individually as given by the induction according to the semantics rules. 

If  by semantics rule {\sc request} then   must have contained
 and  for some
, , and . Hence,  and
 in  for some new future .
Since  is -visible, so is  by definition of visibility
(since  was created from ,  must have an -method containing
). By confinement,  has global level  and  is .
Since , and  visible to , we 
have (up to isomorphism of names) that  and  
in . Therefore, we can equally apply the rule {\sc request} to  to obtain
that  contains  and 
. In , 
is also -invisible and  is typed  as well.
Now, the -visible parts of  are equal to the ones of  apart from the new
future . However, based on the future bijection  that exists due to indistinguishability
between  and  we can extend this for  to a bijection . In addition, by preservation,
 as well as  are well-typed whereby finally  and this finishes the {\sc request}-case.


Another, also less obvious case for new elements in the -visible part, is the one for {\sc active}. 
However, here we have a very similar situation as in the {\sc request} case. If, in , there is some 
, we also have  alike in ,
whereby we get in the next step -- according to rule {\sc active} --  in  replacing 
the previous . We can also apply {\sc active} in  so 
that  in  and  as well instead of just the old .
Indistinguishability is preserved since a bijection  exists as extension to  to
the new activity  and by preservation again  and  remain well-typed.
We are finished with the case for {\sc active} since .

The other cases, corresponding to the remaining semantics rules, are of very a similar nature. 
Thus, the second part of -visible parts of the configurations  and  is also finished and completes
the proof of the theorem.
\hfill {}




\end{document}
