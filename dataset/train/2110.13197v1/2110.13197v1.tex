\documentclass{article}




\PassOptionsToPackage{numbers,compress}{natbib}
\usepackage[final]{neurips_2021}







\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{xcolor,colortbl}         \usepackage{subcaption}
\usepackage{graphicx}
\usepackage{amssymb,amsmath,amsthm}
\usepackage{wrapfig}
\usepackage{multirow}
\usepackage{enumitem}
\usepackage{caption}
\captionsetup[table]{font=Large}
\captionsetup[figure]{font=small}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 \newcommand{\inv}{^{-1}}
\newcommand{\trans}{^{\top}}
\newcommand{\mat}[1]{\bm{\mathrm{#1}}}
\renewcommand{\vec}[1]{\bm{\mathrm{#1}}}


\newcommand{\pan}[1]{{\textcolor{red}{P: #1}}}
\newcommand{\muhan}[1]{{\textcolor{blue}{M: #1}}}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}
\newtheorem{corollary}{Corollary}


\title{Nested Graph Neural Networks}






\author{Muhan Zhang\thanks{Corresponding author: Muhan Zhang (\texttt{muhan@pku.edu.cn}).}~~~~Pan Li\thanks{Pan Li contributes Sec. 3.3 that proves the Theorem~\ref{thm:power} and some implementation ideas.}\\
  Institute for Artificial Intelligence, Peking University\\ 
  Beijing Institute for General Artificial Intelligence\\ 
  Department of Computer Science, Purdue University\\ 
}

\begin{document}

\maketitle

\begin{abstract}
Graph neural network (GNN)'s success in graph classification is closely related to the Weisfeiler-Lehman (1-WL) algorithm. By iteratively aggregating neighboring node features to a center node, both 1-WL and GNN obtain a node representation that encodes a \textit{rooted subtree} around the center node. These rooted subtree representations are then pooled into a single representation to represent the whole graph. However, rooted subtrees are of limited expressiveness to represent a non-tree graph. To address it, we propose Nested Graph Neural Networks (NGNNs). NGNN represents a graph with \textit{rooted subgraphs} instead of rooted subtrees, so that two graphs sharing many identical subgraphs (rather than subtrees) tend to have similar representations. The key is to make each node representation encode a subgraph around it more than a subtree. To achieve this, NGNN extracts a local subgraph around each node and applies a \textit{base GNN} to each subgraph to learn a subgraph representation. The whole-graph representation is then obtained by pooling these subgraph representations. We provide a rigorous theoretical analysis showing that NGNN is strictly more powerful than 1-WL. In particular, we proved that NGNN can discriminate almost all -regular graphs, where 1-WL always fails. Moreover, unlike other more powerful GNNs, NGNN only introduces a constant-factor higher time complexity than standard GNNs. NGNN is a plug-and-play framework that can be combined with various base GNNs. We test NGNN with different base GNNs on several benchmark datasets. NGNN uniformly improves their performance and shows highly competitive performance on all datasets.
\end{abstract}

\section{Introduction}
Graph is an important tool to model relational data in the real world. Representation learning over graphs has become a popular topic of machine learning in recent years. While network embedding methods, such as DeepWalk~\citep{perozzi2014deepwalk}, can learn node representations well, they fail to generalize to whole-graph representations, which are crucial for applications such as graph classification, molecule modeling, and drug discovery. On the contrary, although traditional graph kernels~\citep{haussler1999convolution,shervashidze2009efficient,kondor2009graphlet,borgwardt2005shortest,neumann2016propagation,shervashidze2011weisfeiler} can be used for graph classification, they define graph similarity often in a heuristic way, which is not parameterized and lacks some flexibility to deal with features. 

In this context, graph neural networks (GNNs) have regained people's attention and become the state-of-the-art graph representation learning tool~\citep{scarselli2009graph,bruna2013spectral,duvenaud2015convolutional,li2015gated,kipf2016semi,defferrard2016convolutional,dai2016discriminative,velivckovic2017graph,zhang2018end,ying2018hierarchical}. GNNs use message passing to propagate features between connected nodes. By iteratively aggregating neighboring node features to the center node, GNNs learn node representations encoding their local structure and feature information. These node representations can be further pooled into a graph representation, enabling graph-level tasks such as graph classification. In this paper, we will use \textit{message passing GNNs} to denote this class of GNNs based on repeated neighbor aggregation~\citep{gilmer2017neural}, in order to distinguish them from some high-order GNN variants~\citep{morris2019weisfeiler,maron2019provably,chen2019equivalence} where the effective message passing happens between high-order node tuples instead of nodes.

GNNs' message passing scheme mimics the 1-dimensional Weisfeiler-Lehman (1-WL) algorithm~\citep{weisfeiler1968reduction}, which iteratively refines a node's color according to its current color and the multiset of its neighbors' colors. This procedure essentially encodes a rooted subtree around each node into its final color, where the rooted subtree is constructed by recursively expanding the neighbors of the root node. One critical reason for GNN's success in graph classification is because two graphs sharing many identical or similar rooted subtrees are more likely classified into the same class, which actually aligns with the inductive bias that two graphs are similar if they have many common substructures~\citep{vishwanathan2010graph}.

Despite this, rooted subtrees are still limited in terms of expressing \textbf{all possible substructures} that can appear in a graph. It is likely that two graphs, despite sharing a lot of identical rooted subtrees, are not similar at all because their other substructure patterns are not similar. Take the two graphs  and  in Figure~\ref{fig:3regular} as an example. If we apply 1-WL or a message passing GNN to them, the two graphs will always have the same representation no matter how many iterations/layers we use. This is because \textbf{all} nodes in the two graphs have identical rooted subtrees across \textbf{all} tree heights. However, the two graphs are quite different from a holistic perspective.  is composed of two triangles, while  is a hexagon. The intrinsic reason for such a failure is that rooted subtrees have limited expressiveness for representing general graphs, especially those with cycles.



\begin{figure*}[t]
\centering
\includegraphics[width=0.95\textwidth]{materials/3regular9.pdf}
\caption{The two original graphs  and  are non-isomorphic.  is composed of two triangles, while  is a hexagon. However, both 1-WL and message passing GNNs cannot differentiate them, since all nodes in the two graphs share identical rooted subtrees at any height (see the rooted subtrees around  and  in the middle block for example). In comparison, we can discriminate the two graphs by comparing their height-1 rooted subgraphs around any nodes. For example, the height-1 rooted subgraph around  is a closed triangle, but the height-1 rooted subgraph around  is an open triangle (see the red boxes in the right block).}
\label{fig:3regular}
\end{figure*}


To address this issue, we propose Nested Graph Neural Networks (NGNNs). The core idea is, instead of encoding a rooted subtree, we want the final representation of a node to encode a \textbf{rooted subgraph} (local -hop subgraph) around it. The subgraph is not restricted to be of any particular graph type such as tree, but serves as a general description of the local neighborhood around a node. Rooted subgraphs offer much better representation power than rooted subtrees, e.g., we can easily discriminate the two graphs in Figure~\ref{fig:3regular} by only comparing their height-1 rooted subgraphs.

To represent a graph with rooted subgraphs, NGNN uses \textbf{two} levels of GNNs: base (inner) GNNs and an outer GNN. By extracting a local rooted subgraph around each node, NGNN first applies a base GNN to each node's subgraph independently. Then, a subgraph pooling layer is applied to each subgraph to aggregate the intermediate node representations into a subgraph representation. This subgraph representation is used as the final representation of the root node. Rather than encoding a rooted subtree, this final node representation encodes the local subgraph around it, which contains more information than a subtree. Finally, all the final node representations are further fed into an outer GNN to learn a representation for the entire graph. Figure~\ref{fig:overall} shows one NGNN implementation using message passing GNNs as the base GNNs and a simple graph pooling layer as the outer GNN.

One may wonder that the base GNN seems to still learn only rooted subtrees if it is message-passing-based. Then why is NGNN more powerful than GNN? One key reason lies in the subgraph pooling layer. Take the height-1 rooted subgraphs (marked with red boxes) around  and  in Figure~\ref{fig:3regular} as an example. 
Although  and 's height-1 rooted subtrees are still the same, their neighbors (labeled by 1 and 2) have different height-1 rooted subtrees. Thus, applying a one-layer message passing GNN plus a subgraph pooling as the base GNN is sufficient to discriminate  and .









\begin{figure*}[t]
\centering
\includegraphics[width=0.99\textwidth]{materials/overall7.pdf}
\caption{A particular implementation of the NGNN framework. It first extracts (copies) a rooted subgraph (height=1) around each node from the original graph, and then applies a base GNN with a subgraph pooling layer to each rooted subgraph independently to learn a subgraph representation. The subgraph representation is used as the root node's final representation in the original graph. Then, a graph pooling layer is used to summarize the final node representations into a graph representation.}
\label{fig:overall}
\end{figure*}



The NGNN framework has multiple exclusive advantages. Firstly, it allows freely choosing the base GNN, and can enhance the base GNN's representation power in a plug-and-play fashion. Theoretically, we proved that NGNN is more powerful than message passing GNNs and 1-WL by being able to discriminate almost all -regular graphs (where 1-WL always fails). Secondly, by extracting rooted subgraphs, NGNN allows augmenting the initial features of a node with subgraph-specific structural features such as distance encoding~\citep{li2020distance} to improve the quality of the learned node representations. Thirdly, unlike other more powerful graph neural networks, especially those based on higher-order WL tests~\citep{morris2019weisfeiler,maron2019provably,chen2019equivalence,morris2020weisfeiler}, NGNN still has linear time and space complexity w.r.t. graph size like standard message passing GNNs, thus maintaining good scalability. We demonstrate the effectiveness of the NGNN framework in various synthetic/real-world graph classification/regression datasets. On synthetic datasets, NGNN demonstrates higher-than-1-WL expressive power, matching very well with our theorem. On real-world datasets, NGNN consistently enhances a wide range of base GNNs' performance, achieving highly competitive results on all datasets. 







 



\section{Preliminaries}

\subsection{Notation and problem definition}
We consider the graph classification/regression problem. Given a graph  where  is the node set and  is the edge set, we aim to learn a function mapping  to its class or target value . The nodes and edges in  can have feature vectors associated with them, denoted by  (for node ) and  (for edge ), respectively.


\subsection{Weisfeiler-Lehman test}
The Wesfeiler-Lehman (1-WL) test~\citep{weisfeiler1968reduction} is a popular algorithm for graph isomorphism checking. The classical 1-WL works as follows. At first, all nodes receive a color 1. Each node collects its neighbors' colors into a multiset. Then, 1-WL will update each node's color so that two nodes get the same new color if and only if their current colors are the same and they have identical multisets of neighbor colors. Repeat this process until the number of colors does not increase between two iterations. Then, 1-WL will return that two graphs are non-isomorphic if their node colors are different at some iteration, or fail to determine whether they are non-isomorphic. See \citep{shervashidze2011weisfeiler,zhang2017weisfeiler} for more details.

1-WL essentially encodes the rooted subtrees around each node at different heights into its color representations. Figure~\ref{fig:3regular} middle shows the rooted subtrees around  and . Two nodes will have the same color at iteration  if and only if their height- rooted subtrees are the same.



\section{Nested Graph Neural Network}
In this section, we introduce our Nested Graph Neural Network (NGNN) framework and theoretically demonstrate its higher representation power than message passing GNNs. 



\subsection{Limitations of the message passing GNNs}
Most existing GNNs follow the message passing framework~\citep{gilmer2017neural}: given a graph , each node's hidden state  is updated based on its previous state  and the messages  from its neighbors

Here  are the message and update functions at time stamp ,  is the feature of edge , and  is the set of 's neighbors in graph . The initial hidden states  are given by the raw node features . After  time stamps (iterations), the final node representations  are summarized into a whole-graph representation with a readout (pooling) function  (e.g., mean or sum):




Such a message passing (or neighbor aggregation) scheme iteratively aggregates neighbor information into a center node's hidden state, making it encode a local rooted subtree around the node. The final node representations will contain both the local structure and feature information around nodes, enabling node-level tasks such as node classification. After a pooling layer, these node representations can be further summarized into a graph representation, enabling graph-level tasks. When there is no edge feature and the node features are from a countable space, it is shown that message passing GNNs are at most as powerful as the 1-WL test for discriminating non-isomorphic graphs~\citep{xu2018powerful,morris2019weisfeiler}.

For an -layer message passing GNN, it will give two nodes the same final representation if they have identical \textbf{height- rooted subtrees} (i.e., both the structures and the features on the corresponding nodes/edges are the same). If two graphs have a lot of identical (or similar) rooted subtrees, they will also have similar graph representations after pooling. This insight is crucial for the success of modern GNNs in graph classification, because it aligns with the inductive bias that two graphs are similar if they have many common substructures. Such insight has also been used in designing the WL subtree kernel~\citep{shervashidze2011weisfeiler}, a state-of-the-art graph classification method before GNNs.

However, message passing GNNs have several limitations. Firstly, rooted subtree is only one specific substructure. It is not general enough to represent arbitrary subgraphs, especially those with cycles due to the natural restriction of tree structure. Secondly, using rooted subtree as the elementary substructure results in a discriminating power bounded by the 1-WL test. For example, all -node -regular graphs cannot be discriminated by message passing GNNs. Thirdly, standard message passing GNNs do not allow using root-node-specific structural features (such as the distance between a node and the root node) to improve the quality of the learned root node's representation. We might need to break through such limitations in order to design more powerful GNNs. 



\subsection{The NGNN framework}\label{section:ngnn}
To address the above limitations, we propose the Nested Graph Neural Network (NGNN) framework. NGNN no longer aims to encode a rooted subtree around each node. Instead, in NGNN, each node's final representation encodes the general local \emph{subgraph} information around it more than a subtree, so that two graphs sharing a lot of identical or similar \textit{rooted subgraphs} will have similar representations. 

\begin{definition}\label{def:rooted_subgraph}
\textbf{(Rooted subgraph)} Given a graph  and a node , the height- rooted subgraph  of  is the subgraph induced from  by the nodes within  hops of  (including -hop nodes).\end{definition}





To make a node's final representation encode a rooted subgraph, we need to compute a subgraph representation. To achieve this, we resort to an arbitrary GNN, which we call the \textit{base GNN} of NGNN. For example, the base GNN can be simply a message passing GNN, which performs message passing \textbf{within} each rooted subgraph to learn an intermediate representation for \textbf{every} node of the subgraph, and then uses a pooling layer to summarize a subgraph representation from the intermediate node representations. This subgraph representation is used as the final representation of the root node in the original graph. 
Take root node  as an example. We first perform  rounds of message passing within node 's rooted subgraph . Let  be any node appearing in . We have

Here  are the message and update functions of the base GNN at time stamp ,  denotes the set of 's neighbors within 's rooted subgraph , and  and  denote node 's hidden state and message \textbf{specific to} rooted subgraph  at time stamp . Note that when node  attends different nodes' rooted subgraphs, its hidden states and messages will also be \textbf{different}. This is in contrast to standard GNNs where a node's hidden state and message at time  is the same regardless of which root node it contributes to. For example,  and  in Eq.~\ref{eq:mpnn} do not depend on any particular rooted subgraph.



After  rounds of message passing, we apply a \textit{subgraph pooling layer} to summarize a subgraph representation  from the intermediate node representations .

where  is the subgraph pooling layer. This subgraph representation  will be used as root node 's final representation  in the original graph. Note that
the base GNNs are simultaneously applied to all nodes' rooted subgraphs to return a final node representation for every node in the original graph, and all the base GNNs share the same parameters. With such node representations, NGNN uses an \textit{outer GNN} to further process and aggregate them into a graph representation of the whole graph. For simplicity, we let the outer GNN be simply a \textit{graph pooling layer} denoted by :


The Nested GNN framework can be understood as a two-level GNN, or a \textbf{GNN of GNNs}---the inner subgraph-level GNNs (base GNNs) are used to learn node representations from their rooted subgraphs, while the outer graph-level GNN is used to return a whole-graph representation from the inner GNNs' outputs. The inner GNNs all share the same parameters which are trained end-to-end with the outer GNN. Figure~\ref{fig:overall} depicts the implementation of the NGNN framework described above.




Compared to message passing GNNs, NGNN changes the ``receptive field'' of each node from a rooted subtree to a rooted subgraph, in order to capture better local substructure information. The rooted subgraph is read by a base GNN to learn a subgraph representation. Finally, the outer GNN reads the subgraph representations output by the base GNNs to return a graph representation.

Note that, when we apply the base GNN to a rooted subgraph, this rooted subgraph is extracted (copied) out of the original graph and treated as a completely independent graph from the other rooted subgraphs and the original graph.
This allows the same node to have \textbf{different} representations within different rooted subgraphs. For example, in Figure~\ref{fig:overall}, the same node  appears in four different rooted subgraphs. Sometimes it is the root node, while other times it is a 1-hop neighbor of the root node. NGNN enables learning different representations for the same node when it appears in different rooted subgraphs, in contrast to standard GNNs where a node only has one single representation at one time stamp (Eq.~\ref{eq:mpnn}). Similarly, NGNN also enables using different initial features for the same node when it appears in different rooted subgraphs. This allows us to customize a node's initial features based on its structural role within a rooted subgraph, as opposed to using the same initial features for a node across all rooted subgraphs. For example, we can optionally augment node 's initial features with the distance between node  and the root---when node  is the root node, we give it an additional feature ; and when  is a -hop neighbor of the root, we give it an additional feature . Such feature augmentation may help better capture a node's structural role within a rooted subgraph. It is an exclusive advantage of NGNN and is \textbf{not} possible in standard GNNs.







\subsection{The representation power of NGNN}
We theoretically characterize the additional expressive power of NGNN (using message passing GNNs as base GNNs) as opposed to standard message passing GNNs. We focus on the ability to discriminate regular graphs because they form an important category of graphs which standard GNNs cannot represent well. Using 1-WL or message passing GNNs, any two -sized -regular graphs will have the same representation, unless discriminative node features are available. In contrast, we prove that NGNN can distinguish almost all pairs of -sized -regular graphs regardless of node features. 





\begin{definition}
If the message passing (Eq.~\ref{eq:mp-1}) and the two-level graph pooling (Eqs.~\ref{eq:sg-pool},\ref{eq:g-pool}) are all injective given input from a countable space, then the NGNN is called \textbf{proper}.
\end{definition}



A proper NGNN always exists due to the representation power of fully-connected neural networks used for message passing and Deep Set for graph pooling~\citep{zaheer2017deep}. For all pairs of graphs that 1-WL can discriminate, there always exists a proper NGNN that can also discriminate them, because two graphs discriminated by 1-WL means they must have different multisets of rooted subtrees at some height , while a rooted subtree is always included in a rooted subgraph with the same height.

Now we present our main theorem.
\begin{theorem}\label{thm:power}
Consider all pairs of -sized -regular graphs, where . For any small constant , there exists a proper NGNN using at most -height rooted subgraphs and -layer message passing, which distinguishes almost all () such pairs of graphs. 
\end{theorem}

We include the proof in Appendix~\ref{proof:power}. Theorem~\ref{thm:power} has three implications. Firstly, since NGNN can discriminate almost all -regular graphs where 1-WL always fails, it is \textbf{strictly more powerful} than 1-WL and message passing GNNs. Secondly, it implies that NGNN does not need to extract subgraphs with a too large height (about ) to be more powerful. Moreover, NGNN is already powerful with very few layers, i.e., an arbitrarily small constant  times  (as few as 1 layer). This benefit comes from the subgraph pooling (Eq.~\ref{eq:sg-pool}), freeing us from using deep base GNNs. We further conduct a simulation experiment in Appendix~\ref{appendix:simu} to verify Theorem~\ref{thm:power} by testing how well NGNN discriminates -regular graphs in practice. The results match almost perfectly with our theory.

Although NGNN is strictly more powerful than 1-WL and 2-WL (1-WL and 2-WL have the same discriminating power~\citep{maron2019provably}), it is unclear whether NGNN is more powerful than 3-WL. Our early-stage analysis shows both NGNN and 3-WL cannot discriminate strongly regular graphs with the same parameters~\cite{brouwer2012strongly}. We leave the exact comparison between NGNN and 3-WL to future work.



\subsection{Discussion}\label{sec:discussion}



\textbf{Base GNN.} NGNN is a general plug-and-play framework to increase the power of a base GNN. For the base GNN, we are not restricted to message passing GNNs as described in Section~\ref{section:ngnn}.
For example, we can also use GNNs approximating the power of higher-dimensional WL tests, such as 1-2-3-GNN~\cite{morris2019weisfeiler} and PPGN/Ring-GNN~\citep{maron2019provably,chen2019equivalence}, as the base GNN. In fact, one limitation of these high-order GNNs is their  complexity. Using the NGNN framework we can greatly alleviate this by applying the higher-order GNN to multiple small rooted subgraphs instead of the whole graph.
Suppose a rooted subgraph has at most  nodes, then by applying a high-order GNN to all  rooted subgraphs, we can reduce the time complexity from  to . 

\textbf{Complexity.} We compare the time complexity of NGNN (using message passing GNNs as base GNNs) with a standard message passing GNN. Suppose the graph has  nodes with a maximum degree , and the maximum number of nodes in a rooted subgraph is . Each message passing iteration in a standard message passing GNN takes  operations. In NGNN, we need to perform message passing over all  nodes' rooted subgraphs, which takes . We will keep  small (which can be achieved by using a small ) to improve NGNN's scalability. Additionally, a small  enables the base GNN to focus on learning local subgraph patterns. 



In Appendix~\ref{appendix:design_choices}, we discuss some other design choices of NGNN.






















\section{Related work}


Understanding GNN's representation power is a fundamental problem in GNN research. \citet{xu2018powerful} and \citet{morris2019weisfeiler} first proved that the discriminating power of message passing GNNs is bounded by the 1-WL test, namely they cannot discriminate two non-isomorphic graphs that 1-WL fails to discriminate (such as -regular graphs). Since then, there is increasing effort in enhancing GNN's discriminating power beyond 1-WL~\citep{morris2019weisfeiler,chen2019equivalence,maron2019provably,murphy2019relational,li2020distance,bouritsas2020improving,you2021identity,beaini2020directional,morris2020weisfeiler}. Many GNNs have been proposed to mimic higher-dimensional WL tests, such as 1-2-3-GNN~\citep{morris2019weisfeiler}, Ring-GNN~\citep{chen2019equivalence} and PPGN~\citep{maron2019provably}. However, these models generally require learning the representations of all node tuples of certain cardinality (e.g., node pairs, node triples and so on), thus cannot leverage the sparsity of graph structure and are difficult to scale to large graphs. Some works study the universality of GNNs for approximating any invariant or equivariant functions over graphs~\citep{maron2018invariant,chen2019equivalence,maron2019universality,keriven2019universal,azizian2020characterizing}. However, reaching universality would require polynomial()-order tensors, which hold more theoretical value than practical applicability. \citet{dasoulas2019coloring} propose to augment nodes of identical attributes with different colors, which requires exhausting all the coloring choices to reach universality. Similarly, Relational Pooling (RP)~\citep{murphy2019relational} uses the ensemble of permutation-aware functions over graphs to reach universality, which requires exhausting all  permutations to achieve its theoretical power. Its local version Local Relational Pooling (LRP)~\citep{chen2020can} applies RP over subgraphs around nodes, which is similar to our work yet still requires exhausting node permutations in local subgraphs and even more loses RP's theoretical power. In contrast, NGNN maintains a controllable cost by only applying a message passing GNN to local subgraphs, and is guaranteed to be more powerful than 1-WL. 






Because of the high cost of mimicking high-dimensional WL tests, several works have been proposed to increase GNN's representation power within the message passing framework. Observing that different neighbors are indistinguishable during neighbor aggregation, some works propose to add one-hot node index features or random features to GNNs~\citep{loukas2019graph,sato2020random}. These methods work well when nodes naturally have distinct identities irrespective of the graph structure. However, although making GNNs more discriminative, they also lose some of GNNs' generalization ability by not being able to guarantee nodes with identical neighborhoods to have the same embedding; the resulting models are also no longer permutation invariant. Repeating random initialization helps with avoiding such an issue but gets much slower convergence~\cite{abboud2020surprising}. An exception is structural message-passing (SMP)~\citep{vignac2020building}, which propagates one-hot node index features to learn a global  feature matrix for each node. The feature matrix is further pooled to learn a permutation-invariant node representation. 


On the contrary, some works propose to use structural features to augment GNNs without hurting the generalization ability of GNNs. SEAL~\citep{zhang2018link,zhang2020revisiting}, IGMC~\citep{Zhang2020Inductive} and DE~\citep{li2020distance} use distance-based features, where a distance vector w.r.t. the target node set to predict is calculated for each node as its additional features. Our NGNN framework is naturally compatible with such distance-based features due to its independent rooted subgraph processing. GSN~\citep{bouritsas2020improving} uses the count of certain substructures to augment node/edge features, which also surpasses 1-WL theoretically. However, GSN needs a properly defined substructure set to incorporate domain-specific inductive biases, while NGNN aims to learn arbitrary substructures around nodes without the need to predefine a substructure set.


Concurrent to our work, \citet{you2021identity} propose Identity-aware GNN (ID-GNN). ID-GNN uses different weight parameters between each root node and its context nodes during message passing. It also extracts a rooted subgraph around each node, and thus can be viewed as a special case of NGNN with: 1) the number of message passing layers equivalent to the subgraph height, 2) directly using the root node's intermediate representation as its final representation without subgraph pooling, and 3) augmenting initial node features with 0/1 ``identity''. However, the extra power of ID-GNN only comes from the ``identity'' feature, while the power of NGNN comes from the subgraph pooling---without using any node features, NGNN is still provably more discriminative than 1-WL. Another similar work to ours is natural graph network (NGN)~\citep{de2020natural}. NGN argues that graph convolution weights need not be shared among all nodes but only (locally) isomorphic nodes. If we view our distance-based node features as refining the graph convolution weights so that nodes within a center node's neighborhood are no longer treated symmetrically, then our NGNN reduces to an NGN.

The idea of independently performing message passing within -hop neighborhood is also explored in -hop GNN~\citep{nikolentzos2020k} and MixHop~\citep{abu2019mixhop}. However, MixHop directly concatenates the aggregation results of neighbors at different hops as the root representation, which ignores the connections between other nodes in the rooted subgraph. -hop GNN sequentially performs message passing for -hop, -hop, ..., and 0-hop node (the update of -hop nodes depend on the updated states of -hop nodes), while NGNN simultaneously performs message passing for all nodes in the subgraph thus is more parallelizable. Both MixHop and -hop GNN directly use the root node's representation as its final node representation. In contrast, NGNN uses a subgraph pooling to summarize all node representations within the subgraph as the final root representation, which distinguishes NGNN from other -hop models. As Theorem~\ref{thm:power} shows, the subgraph pooling enables using a much smaller number of message passing layers  (as small as 1) than the depth  of the subgraph, while MixHop and -hop GNN always require . 
MixHop and -hop GNN also do not have the strong theoretical power of NGNN to discriminate -regular graphs. Like SEAL and -hop GNN, G-Meta~\citep{huang2020graph} is another work extracting subgraphs around nodes/links. It focuses specifically on a meta-learning setting.




\section{Experiments}
In this section, we study the effectiveness of the NGNN framework for graph classification and regression tasks. In particular, we want to answer the following questions:

\textbf{Q1}~Can NGNN reach its theoretical power to discriminate 1-WL-indistinguishable graphs?\\
\textbf{Q2}~How often and how much does NGNN improve the performance of a base GNN?\\
\textbf{Q3}~How does NGNN perform in comparison to state-of-the-art GNN methods in open benchmarks?\\
\textbf{Q4}~How much extra computation time does NGNN incur?

We implement the NGNN framework based on the PyTorch Geometric library~\citep{fey2019fast}. Our code is available at \url{https://github.com/muhanzhang/NestedGNN}.



\subsection{Datasets}
To answer \textbf{Q1}, we use a simulation dataset of -regular graphs and the EXP dataset~\citep{abboud2020surprising} containing 600 pairs of 1-WL-indistinguishable but non-isomorphic graphs. To answer \textbf{Q2}, we use the QM9 dataset~\citep{ramakrishnan2014quantum,wu2018moleculenet} and the TU datasets~\citep{KKMMN2016}. QM9 contains 130K small molecules. The task here is to perform regression
on twelve targets representing energetic, electronic, geometric, and thermodynamic properties, based on the graph structure and node/edge features. TU contains five graph classification datasets including D\&D~\citep{dobson2003distinguishing}, MUTAG~\citep{debnath1991structure}, PROTEINS~\citep{dobson2003distinguishing}, PTC\_MR~\citep{toivonen2003statistical}, and ENZYMES~\citep{schomburg2004brenda}. We used the datasets provided by PyTorch Geometric~\citep{fey2019fast}, where for QM9 we performed unit conversions to match the units used by \citep{morris2019weisfeiler}. The evaluation metric is Mean Absolute Error (MAE) for QM9 and Accuracy (\%) for TU.
To answer \textbf{Q3}, we use two Open Graph Benchmark (OGB) datasets~\citep{hu2020open}, \texttt{ogbg-molhiv} and \texttt{ogbg-molpcba}. The \texttt{ogbg-molhiv} dataset contains 41K small molecules, the task of which is to classify whether a molecule inhibits HIV virus or not. ROC-AUC is used for evaluation. The \texttt{ogbg-molpcba} dataset contains 438K molecules with 128 classification tasks. The evaluation metric is Average Precision (AP) averaged over all the tasks. We include the statistics for QM9 and OGB datasets in Table~\ref{table:stat}.





\captionsetup[table]{font=large}
\begin{table*}[t]
\begin{center}
  \resizebox{0.9\textwidth}{!}{
  \begin{minipage}[t]{1.2\textwidth}
  \caption{Statistics and evaluation metrics of the QM9 and OGB datasets.}
  \label{table:stat}
  \begin{tabular}{lcccccccc}
    \toprule
    \textbf{Dataset}&\textbf{\#Graphs}&\textbf{Avg. \#nodes}&\textbf{Avg. \#edges}&\textbf{Split ratio}&\textbf{\#Tasks}&\textbf{Task type}&\textbf{Metric} \\
    \midrule
    \texttt{QM9} & 129,433 & 18.0  & 18.6 & 80/10/10 & 12 & Regression & MAE\\
\texttt{ogbl-molhiv} & 41,127 &  25.5 & 27.5 & 80/10/10 & 1 & Classification & ROC-AUC\\
    \texttt{ogbl-molpcba} & 437,929 & 26.0 & 28.1 & 80/10/10 & 128 & Classification & AP\\
  \bottomrule
\end{tabular}
\end{minipage}
}
\end{center}
\vspace{-10pt}
\end{table*}
\captionsetup[table]{font=Large}

\subsection{Models}
\textbf{QM9.}~We use 1-GNN, 1-2-GNN, 1-3-GNN, and 1-2-3-GNN from \citep{morris2019weisfeiler} as both the baselines and the base GNNs of NGNN. Among them, 1-GNN is a standard message passing GNN with 1-WL power. 1-2-GNN is a GNN mimicking 2-WL, where message passing happens among 2-tuples of nodes. 1-3-GNN and 1-2-3-GNN mimic 3-WL, where message passing happens among 3-tuples of nodes. 1-2-GNN and 1-3-GNN use features computed by 1-GNN as initial node features, and 1-2-3-GNN uses the concatenated features from 1-2-GNN and 1-3-GNN. We additionally include numbers provided by \citep{wu2018moleculenet} and Deep LRP~\citep{chen2020can} as baselines. Note that we omit more recent methods~\citep{anderson2019cormorant,klicpera2020directional,qiao2020orbnet} using advanced physical representations calculated from angles, atom coordinates, and quantum mechanics, which may obscure the comparison of models' pure graph representation power. For NGNN, we uniformly use height-3 rooted subgraphs. For a fair comparison, the base GNNs in NGNN use exactly the same hyperparameters as when they are used alone, except for 1-GNN where we increase the number of message passing layers from 3 to 5 to make the number of layers larger than the subgraph height, similar to \citep{zeng2020deep}. For subgraph pooling and graph pooling layers, we uniformly use mean pooling. All other settings follow \citep{morris2019weisfeiler}.








\textbf{TU.}~We use four widely adopted GNNs as the baselines and the base GNNs of NGNN: GCN~\citep{kipf2016semi}, GraphSAGE~\citep{hamilton2017inductive}, GIN~\citep{xu2018powerful}, and GAT~\citep{velivckovic2017graph}. Since TU datasets suffer from inconsistent evaluation standards~\citep{errica2019fair}, we uniformly use the 10-fold cross validation framework provided by PyTorch Geomtric~\citep{Fey/Lenssen/2019} for all the models to ensure a fair comparison. For GNNs, we search the number of message passing layers in . For NGNNs, we similarly search the subgraph height  in , so that both NGNNs and GNNs can have equal-depth local receptive fields. For NGNNs, we always use  message passing layers instead of searching it together with , because that will make NGNNs have more hyperparameters to tune. All models have 32 hidden dimensions, and are trained for 100 epochs with a batch size of 128. For each fold, we record the test accuracy with the hyperparameters chosen based on the best validation performance of this fold. Finally, we report the average test accuracy across all the 10 folds.



\textbf{OGB.}~We use GNNs achieving top places on the OGB graph classification leaderboard\footnote{\url{https://ogb.stanford.edu/docs/leader_graphprop/}} (at the time of submission) as the baselines, including GCN~\citep{kipf2016semi}, GIN~\citep{xu2018powerful}, DeeperGCN~\citep{li2020deepergcn}, Deep LRP~\citep{chen2020can}, PNA~\citep{corso2020principal}, DGN~\citep{beaini2020directional}, GINE~\citep{brossard2020graph}, and PHC-GNN~\citep{le2021parameterized}. Note that those high-order GNNs~\citep{morris2019weisfeiler,maron2019provably,chen2019equivalence,morris2020weisfeiler} are not included here, because despite being theoretically more discriminative, these GNNs are \textbf{not} among the GNNs with the best empirical performance on modern large-scale graph benchmarks, and their  complexity also raises a scalability issue.
For NGNN, we use GIN as the base GNN (although GIN is not among the strongest baselines here). Some baselines additionally use the virtual node technique~\citep{gilmer2017neural,li2015gated,ishiguro2019graph}, which are marked by ``*''. For NGNN, we search the subgraph height  in , and the number of layers in . We train the NGNN models for 100 and 150 epochs for \texttt{ogbg-molhiv} and \texttt{ogbg-molpcba}, respectively, and report the validation and test scores at the best validation epoch. We also find that our models are subject to high performance variance across epochs, likely due to the increased expressiveness. Thus, we save a model checkpoint every 10 epochs, and additionally report the ensemble performance by averaging the predictions from all checkpoints. The final hyperparameter choices and more details about the experimental settings are included in Appendix~\ref{appendix:hyper}.
All results are averaged over 10 independent runs. 

In the following, we uniformly use ``Nested GNN'' to denote an NGNN model using ``GNN'' as the base GNN. For example, Nested GIN denotes an NGNN model using GIN~\citep{xu2018powerful} as the base GNN.
For the NGNN models in QM9, TU and OGB datasets, we augment the initial features of a node with Distance Encoding (DE)~\citep{li2020distance}, which uses the (generalized) distance between a node and the root as its additional feature, due to DE's successful applications in link-level tasks~\citep{zhang2018link,Zhang2020Inductive}. Note that such feature augmentation is not applicable to the baseline models as discussed in Section~\ref{section:ngnn}. An ablation study on the effects of the DE features is included in Appendix~\ref{appendix:de}. 








\subsection{Results and discussion}

To answer \textbf{Q1}, we first run a simulation to test NGNN's power for discriminating -regular graphs. The results are presented in Appendix~\ref{appendix:simu}. They match almost perfectly with Theorem~\ref{thm:power}, demonstrating that a practical NGNN can fulfil its theoretical power for discriminating -regular graphs. 


\begin{wraptable}[8]{L}{0.3\textwidth}
\large
\setlength{\tabcolsep}{13pt}
\vspace{-10pt}
\resizebox{0.29\textwidth}{!}{
\begin{minipage}[t]{0.47\textwidth}
\caption{Results (\%) on EXP.}
  \begin{tabular}{lc}
    \toprule
    \textbf{Method} & \textbf{Test Accuracy} \\
    \midrule
\textbf{GCN-RNI}~\citep{abboud2020surprising} & 98.01.85\\
    \textbf{PPGN}~\citep{maron2019provably} & 50.00.00\\
    \textbf{1-2-3-GNN}~\citep{morris2019weisfeiler} & 50.00.00\\
    \textbf{3-GCN}~\citep{abboud2020surprising} & 99.70.004\\
    \midrule
    \textbf{Nested GIN} & \textbf{99.9}0.26 \\
  \bottomrule
\end{tabular}
\label{table:exp}
\end{minipage}
}
\end{wraptable}

We also test NGNN's expressive power using the EXP dataset provided by \citep{abboud2020surprising}, which contains 600 carefully constructed 1-WL indistinguishable but non-isomorphic graph pairs. Each pair of graphs have different labels, thus a standard message passing GNN cannot predict them both correctly, resulting in an expected classification accuracy of only 50\%. We exactly follow the experimental settings and copy the baseline results in \citep{abboud2020surprising}. In Table~\ref{table:exp}, our Nested GIN model achieves a 99.9\% classification accuracy, which outperforms all the baselines and distinguishes almost all the 1-WL indistinguishable graph pairs. 
These results verified that NGNN's expressive power is indeed beyond 1-WL and message passing GNNs.




To answer \textbf{Q2}, we adopt the QM9 and TU datasets. We show the QM9 results in Table~\ref{table:qm9}. If the Nested version of a base GNN achieves a better result than the base GNN itself, we color that cell with light green. As we can see, NGNN brings performance gains to all base GNNs on most targets, sometimes by large margins. We also show the results on TU in Table~\ref{table:tu}. NGNNs also show improvement over their base GNNs in most cases. These results indicate that NGNN is a general framework for improving a GNN's power. We further compute the maximum reduction of MAE for QM9 and maximum improvement of accuracy for TU before and after applying NGNN. NGNN reduces the MAE by up to 7.9 times for QM9, and increases the accuracy by up to 14.3\% for TU. These results answer \textbf{Q2}, indicating that NGNN can bring steady and significant improvement to base GNNs.   










\begin{table*}[t]
\setlength{\tabcolsep}{3.7pt}
\vspace{-10pt}
\begin{center}
  \resizebox{1\textwidth}{!}{
  \begin{minipage}[t]{1.72\textwidth}
   \caption{MAE results on QM9 (smaller the better). A colored cell means NGNN is better than the base GNN.}
   \vspace{-5pt}
   \label{table:qm9}
  \begin{tabular}{lccc|cccc|cccc|c}
    \toprule
    \multirow{2}{*}{\textbf{Target}}&\multicolumn{11}{c}{\textbf{Method} (Ne. for Nested)}\\
    \cmidrule{2-13}
    &\textbf{DTNN}&\textbf{MPNN}&\textbf{Deep LRP}&\textbf{1-GNN}&\textbf{1-2-GNN}&\textbf{1-3-GNN}&\textbf{1-2-3-GNN}&\textbf{Ne. 1-GNN}&\textbf{Ne. 1-2-GNN}&\textbf{Ne. 1-3-GNN}&\textbf{Ne. 1-2-3-GNN}&\textbf{Max. reduction}\\
    \midrule
     & \textbf{0.244} &  0.358 & 0.364 & 0.493 & 0.493 & 0.473 & 0.476 & \cellcolor[HTML]{E7FFE2}0.428 & \cellcolor[HTML]{E7FFE2}0.437 & \cellcolor[HTML]{E7FFE2}0.436 &\cellcolor[HTML]{E7FFE2} 0.433 & 1.2\\
     & 0.95 &  0.89 & 0.298 & 0.78 & 0.27 & 0.46 & 0.27 & \cellcolor[HTML]{E7FFE2}0.29 & 0.278 & \cellcolor[HTML]{E7FFE2}\textbf{0.261} & \cellcolor[HTML]{E7FFE2}0.265 & 2.7\\
     & 0.00388 &  0.00541 & \textbf{0.00254} & 0.00321 & 0.00331 & 0.00328 & 0.00337 & \cellcolor[HTML]{E7FFE2}0.00265 & \cellcolor[HTML]{E7FFE2}0.00275 & \cellcolor[HTML]{E7FFE2}0.00265 & \cellcolor[HTML]{E7FFE2}0.00279 & 1.2\\
     & 0.00512 &  0.00623 & 0.00277 & 0.00355 & 0.00350 & 0.00354 & 0.00351 & \cellcolor[HTML]{E7FFE2}0.00297 &\cellcolor[HTML]{E7FFE2} 0.00271 &\cellcolor[HTML]{E7FFE2} \textbf{0.00269} & \cellcolor[HTML]{E7FFE2}0.00276 & 1.3\\
     & 0.0112 &  0.0066 & \textbf{0.00353} & 0.0049 & 0.0047 & 0.0046 & 0.0048 & \cellcolor[HTML]{E7FFE2}0.0038 &\cellcolor[HTML]{E7FFE2} 0.0039 &\cellcolor[HTML]{E7FFE2} 0.0039 &\cellcolor[HTML]{E7FFE2} 0.0039 & 1.8\\
     & \textbf{17.0} &  28.5 & 19.3 & 34.1 & 21.5 & 25.8 & 22.9 & \cellcolor[HTML]{E7FFE2}20.5 & \cellcolor[HTML]{E7FFE2}20.4 & \cellcolor[HTML]{E7FFE2}20.2 & \cellcolor[HTML]{E7FFE2}20.1 & 1.7\\
    ZPVE & 0.00172 &  0.00216 & 0.00055 & 0.00124 & 0.00018 & 0.00064 & 0.00019 & \cellcolor[HTML]{E7FFE2}0.00020 &\cellcolor[HTML]{E7FFE2} 0.00017 & \cellcolor[HTML]{E7FFE2}0.00017 &\cellcolor[HTML]{E7FFE2} \textbf{0.00015} & 6.2\\
     & 2.43 &  2.05 & 0.413 & 2.32 & \textbf{0.0357} & 0.6855 & 0.0427 & \cellcolor[HTML]{E7FFE2}0.295 & 0.252 & \cellcolor[HTML]{E7FFE2}0.291 & 0.205 & 7.9\\
     & 2.43 &  2.00 & 0.413 & 2.08 & \textbf{0.107} & 0.686 & 0.111 &\cellcolor[HTML]{E7FFE2} 0.361 & 0.265 & \cellcolor[HTML]{E7FFE2}0.278 & 0.200 & 5.8\\
     & 2.43 & 2.02 & 0.413 & 2.23 & 0.070 & 0.794 & \textbf{0.0419} & \cellcolor[HTML]{E7FFE2}0.305 & 0.241 & \cellcolor[HTML]{E7FFE2}0.267 & 0.249 & 7.3\\
     & 2.43 & 2.02 & 0.413 & 1.94 & 0.140 & 0.587 & \textbf{0.0469} & \cellcolor[HTML]{E7FFE2}0.489 & 0.272 & \cellcolor[HTML]{E7FFE2}0.287 & 0.253 & 4.0\\
     & 0.27 &  0.42 & 0.129 & 0.27 & 0.0989 & 0.158 & 0.0944 & \cellcolor[HTML]{E7FFE2}0.174 & \cellcolor[HTML]{E7FFE2}0.0891 & \cellcolor[HTML]{E7FFE2}0.0879 & \cellcolor[HTML]{E7FFE2}\textbf{0.0811} & 1.8\\ 
  \bottomrule
\end{tabular}
\end{minipage}
}
\end{center}
\end{table*}





\begin{table}[t]
\vspace{-10pt}
\hspace{-5pt}
\resizebox{0.53\textwidth}{!}{
\begin{minipage}[t]{0.9\linewidth}
\caption{Accuracy results (\%) on TU datasets.}
\label{table:tu}
  \begin{tabular}{lcccccc}
    \toprule
    & D\&D  & MUTAG & PROTEINS & PTC\_MR & ENZYMES \\
\#Graphs & 1178 & 188 & 1113 & 344 & 600\\
    Avg. \#nodes & 284.32 & 17.93 & 39.06 &  14.29 & 32.63\\
    \midrule
    \textbf{GCN} & 71.6{\small2.8} &  73.4{\small10.8} & 71.7{\small4.7} & 56.4{\small7.1} & 27.3{\small5.5} \\
    \textbf{GraphSAGE} & 71.6{\small3.0} &  74.0{\small8.8} & 71.2{\small5.2} & 57.0{\small5.5} & 30.7{\small6.3} \\
    \textbf{GIN} & 70.5{\small3.9} &  84.5{\small8.9} & 70.6{\small4.3} & 51.2{\small9.2} & \textbf{38.3}{\small6.4} \\ 
    \textbf{GAT} & 71.0{\small4.4} &  73.9{\small10.7} & 72.0{\small3.3} & 57.0{\small7.3} & 30.2{\small4.2} \\
    \midrule
    \textbf{Nested GCN} & \cellcolor[HTML]{E7FFE2}76.3{\small3.8} &  \cellcolor[HTML]{E7FFE2}82.9{\small11.1} & \cellcolor[HTML]{E7FFE2}73.3{\small4.0} & \cellcolor[HTML]{E7FFE2}\textbf{57.3}{\small7.7} & \cellcolor[HTML]{E7FFE2}31.2{\small6.7} \\
    \textbf{Nested GraphSAGE} & \cellcolor[HTML]{E7FFE2}77.4{\small4.2} &  \cellcolor[HTML]{E7FFE2}83.9{\small10.7} & \cellcolor[HTML]{E7FFE2}\textbf{74.2}{\small3.7} & \cellcolor[HTML]{E7FFE2}57.0{\small5.9} & \cellcolor[HTML]{E7FFE2}30.7{\small6.3} \\
    \textbf{Nested GIN} & \cellcolor[HTML]{E7FFE2}\textbf{77.8}{\small3.9} &  \cellcolor[HTML]{E7FFE2}\textbf{87.9}{\small8.2} & \cellcolor[HTML]{E7FFE2}73.9{\small5.1} & \cellcolor[HTML]{E7FFE2}54.1{\small7.7} & 29.0{\small8.0} \\
    \textbf{Nested GAT} & \cellcolor[HTML]{E7FFE2}76.0{\small4.4} &  \cellcolor[HTML]{E7FFE2}81.9{\small10.2} & \cellcolor[HTML]{E7FFE2}73.7{\small4.8} & 56.7{\small8.1} & 29.5{\small5.7} \\
    \midrule
\textbf{Max. improvement} & 10.4\% & 13.4\% & 4.7\% & 5.7\% & 14.3\%\\
  \bottomrule
\end{tabular}
\end{minipage}
}
\hspace{5pt}
\resizebox{0.47\textwidth}{!}{
\begin{minipage}[t]{0.845\linewidth}
\caption{Results (\%) on OGB datasets (* virtual node).}
\label{table:ogb}
  \begin{tabular}{lcccc}
    \toprule
    &\multicolumn{2}{c}{\texttt{ogbg-molhiv} (AUC)} & \multicolumn{2}{c}{\texttt{ogbg-molpcba} (AP)} \\
\cmidrule(r{0.5em}){2-3} \cmidrule(l{0.5em}){4-5}
    \textbf{Method}&Validation&\textbf{Test}&Validation&\textbf{Test}\\
    \midrule
\textbf{CCN*} & 83.84{\small0.91} &  75.99{\small1.19} & 24.95{\small0.42} & 24.24{\small0.34} \\
\textbf{GIN*} & 84.79{\small0.68} &  77.07{\small1.49} & 27.98{\small0.25} & 27.03{\small0.23} \\
    \textbf{Deep LRP} & 82.09{\small1.16} &  77.19{\small1.40} &  -- & --\\
    \textbf{DeeperGCN*} & -- &  -- & 29.20{\small0.25} & 27.81{\small0.38} \\
    \textbf{HIMP} & -- &  78.80{\small0.82} & -- & -- \\
    \textbf{PNA} & 85.19{\small0.99} &  79.05{\small1.32} & -- & -- \\
    \textbf{DGN} &  84.70{\small0.47} & 79.70{\small0.97} -- &  -- & \\
\textbf{GINE*} & -- &  -- & 30.65{\small0.30} & 29.17{\small0.15} \\
    \textbf{PHC-GNN} & 82.17{\small0.89} &  79.34{\small1.16} & 30.68{\small0.25} & 29.47{\small0.26} \\
    \midrule
    \textbf{Nested GIN*} & 83.17{\small1.99} &  \cellcolor[HTML]{E7FFE2}78.34{\small1.86} & 29.15{\small0.35} &  \cellcolor[HTML]{E7FFE2}28.32{\small0.41}\\
    \textbf{Nested GIN* (ens)} & 80.80{\small2.78} & \cellcolor[HTML]{E7FFE2}\textbf{79.86}{\small1.05} & 30.59{\small0.56} & \cellcolor[HTML]{E7FFE2}\textbf{30.07}{\small0.37}  \\
  \bottomrule
\end{tabular}
\end{minipage}
}
\end{table}








To answer \textbf{Q3}, we compare Nested GIN with leading methods on the OGB leaderboard. The results are shown in Table~\ref{table:ogb}. Nested GIN achieves highly competitive performance with these leading GNN models, albeit using a relatively weak base GNN (GIN). Compared to GIN alone, Nested GIN shows clear performance gains. It achieves test scores up to 79.86 and 30.07 on \texttt{ogbg-molhiv} and \texttt{ogbg-molpcba}, respectively, which outperform all the baselines. In particular, for the challenging \texttt{ogbg-molpcba}, our Nested GIN can achieve 30.07 and 28.32 test AP with and without ensemble, respectively, outperforming the plain GIN model (with 27.03 test AP) significantly. These results demonstrate the great empirical performance and potential of NGNN even compared to heavily tuned open leaderboard models, despite using only GIN as the base GNN. 

To answer \textbf{Q4}, we report the training time per epoch for GIN and Nested GIN on OGB datasets. On \texttt{ogbg-molhiv}, GIN takes 54s per epoch, while Nested GIN takes 183s. On \texttt{ogbg-molpcba}, GIN takes 10min per epoch, while Nested GIN takes 20min. This verifies that NGNN has comparable time complexity with message passing GNNs. The extra complexity comes from independently learning better node representations from rooted subgraphs, which is a trade-off for the higher expressivity.

In summary, our experiments have firmly shown that NGNN is a theoretically sound method which brings consistent gains to its base GNNs in a plug-and-play way. Furthermore, NGNN still maintains a controllable time complexity compared to other more powerful GNNs. 

Finally, we point out one memory limitation of the current NGNN implementation. Currently, NGNN does not scale to graph datasets with a large average node number (such as REDDIT-BINARY) or datasets with a large average node degree (such as \texttt{ogbg-ppa}) due to copying a rooted subgraph for each node to the GPU memory. Reducing batch size or subgraph height helps, but at the same time leads to performance degradation. One may wonder why materializing all the subgraphs into GPU memory is necessary. The reason is that we want to batch-process all the subgraphs simultaneously. Otherwise, we have to sequentially extract subgraphs on the fly, which results in a much higher latency. We leave the exploration of memory efficient NGNN to the future work. 

\section{Conclusions}
We have proposed Nested Graph Neural Network (NGNN), a general framework for improving GNN's representation power. NGNN learns node representations encoding rooted subgraphs instead of rooted subtrees. Theoretically, we prove NGNN can discriminate almost all -regular graphs where 1-WL always fails. Empirically, NGNN consistently improves the performance of various base GNNs across different datasets without incurring the  complexity like other more powerful GNNs.

\section*{Acknowledge}
The authors greatly thank the actionable suggestions from the reviewers to improve the manuscript. Li is partly supported by the 2021 JP Morgan Faculty Award and the National Science Foundation (NSF) award HDR-2117997.



\bibliography{paper}
\bibliographystyle{unsrtnat}







\appendix

\section{Proof of Theorem~\ref{thm:power}}\label{proof:power}
The proof is inspired by the previous theoretical characterization on the power of distance features~\cite{li2020distance}. Basically, performing height- subgraph extraction around a center node is essentially equivalent to injecting distance features that indicate whether the distance between a node and the center node is less than . In the following part, we will explicitly show how these distance features make NGNN more powerful than the 1-WL test. Let us first introduce the outline of the proof. Consider two -node -regular graphs  and  and we pick two nodes, each from one graph, denoted by  and . By performing certain-height (at most -height) rooted subgraph extraction around these two nodes, due to the implicit distance features, we may prove that the nodes on the boundary of the obtained two subgraphs will obtain special node representations. These special node representations will be propagated within the subgraphs. After some steps of propagation, we can prove that NGNN by leveraging the subgraph pooling (Eq. \ref{eq:sg-pool}) can distinguish these two subgraphs. This tells that NGNN may generate different node representations for  and  respectively. Then, a union bound can be used to transform such difference in node representations into the difference in the representations of  and . Note that the proof will assume that there are no node/edge attributes that can be leveraged. Additional node/edge attributes may only improve the possibility to distinguish these two graphs.

The first lemma is to analyze the difference between the structures of the rooted subgraphs around two nodes over two -node -regular graphs. Before introducing that, we need to define a notion termed edge configuration. For a node  in graph , let  denote the set of nodes in  that are exactly -hop neighbors of , i.e., the shortest path distance between  and any node   is . Then, we know the height- rooted subgraph over  around the center node  is the subgraph induced by the node set . 
\begin{definition}
The edge configuration between  and  is a list  where  denotes the number of nodes in  of which each has exactly  edges from .
\end{definition}
When we say two edge configurations  (between  and ),  (between  and ) are equal, we mean that these two lists are component-wise equal to each other. Obviously, we should also have  if . Now, we are ready to propose the first lemma.
\begin{lemma}\label{lemma:1}
For two graphs  and  that are uniformly independently sampled from all -node -regular graphs, where , we pick any two nodes, each from one graph, denoted by  and  respectively. Then, there is at least one  with probability  such that  . Moreover, with at least the same probability, for all , the number of edges between  and    are at least  for . 
\end{lemma}
\begin{proof}
This lemma can be obtained by following the steps 1-3 in the proof of Theorem 3.3 in \cite{li2020distance}.
\end{proof}


Now, we set . We focus on the two extracted subgraphs  and . We first prove a lemma that shows with a certain number of layers, a proper NGNN will generate different representations for  and , i.e.,  and  in Eq. \ref{eq:sg-pool}.

\begin{lemma}\label{lemma:2}
For two graphs  and  that are uniformly independently sampled from all -node -regular graphs, where , we pick any two nodes, each from one graph, denoted by  and  respectively, and do -height rooted subgraph extraction around  and . With at most  many layers, a proper message passing GNN (with injective  and subgraph pooling) will generate different representations for the extracted two subgraphs with probability at least .
\end{lemma}

\begin{proof}
According to Lemma~\ref{lemma:1}, we know that with probability , there exists at least one  such that . So there exists at least one  that make  (thus the difference in edge configurations appears in  and ) and we pick the largest .  

Now let us consider running a message passing GNN over the two subgraphs , . All nodes are initialized with the same node features. The nodes of these two subgraphs can be categorized into  (), for  respectively. Next, let us consider the node representations in these categories during the message passing procedure. We have the following observations.
\begin{enumerate}
    \item Note that all the nodes other than those in  have degree  in both subgraphs. Therefore, in the -th iteration, the nodes in  for  will share the same node representation. We call this node representation as \emph{default representation}. Note that if we do not perform rooted subgraph extraction, then all nodes in all -regular graph hold default representation.
    
    \item Node representations that are different from default representations will first appear among the nodes in  after the first iteration. This is because there are at least  edges between  and  before performing subgraph extraction (due to Lemma~\ref{lemma:1}) and all these edges will not appear in the extracted subgraphs. Then, almost all nodes in  hold only degree one (and thus do not have degree  to keep default representations) within the corresponding extracted subgraphs. We uniformly call the node representations that are different from the default ones as \emph{new representations}. New representations may be mutually different. 

    \item Those new different node representations will propagate to nodes in ,  and so on and so forth via iterative message passing. Moreover, during such propagation procedure, after  iterations, new representations will at least make almost all nodes in  hold representations different form almost all nodes in  for , which can be easily obtained by doing induction from  to . 
\end{enumerate}
Observing the above three points, We may compare the above propagating procedure between  and . Suppose in the first  steps of message passing, the set of node representations (both the default ones and the new ones) can keep the same between the two extracted subgraphs. If this is not true, we have already proven the results. As they hold different edge configurations in , when the new node representations propagate from  to , it will definitely induce different sets of new node representations between  and . Currently,  node representations are kept the same between   and  for  as they are all default node representations. Though   also hold new node representations, they are different from those in    for . At this point, if an injective subgraph pooling operation is adopted, then the obtained representations of  and , i.e.,  and , are different. 
\end{proof}

Based on Lemma~\ref{lemma:2}, using a union bound by comparing a node representation of  with all node representaitons of , we may achieve the final conclusion. Specifically, we consider a node of , say , and another arbitrary node of , say . Using Lemma~\ref{lemma:2}, we know with probability ,  is different from . Then, using the union bound, with probability , we have . Therefore, if the final graph pooling (Eq. \ref{eq:g-pool}) is injective, we may guarantee that NGNN can generate different representations for  and .


\section{Design choices of NGNN}\label{appendix:design_choices}

In this section, we discuss some other design choices of NGNN.

\textbf{High-order NGNN.} 
NGNN is a two-level GNN (a GNN of GNNs), where a base GNN is used to learn a final node representation from a rooted subgraph and an outer GNN (graph pooling) is used to learn a graph representation from the base GNNs' outputs. This design thus involves one level of nesting, which we call first-order NGNN. To extend the framework, we propose \textit{high-order NGNN}, where we make the base GNN itself an NGNN. That is, we perform the subgraph representation learning tasks each using a first-order NGNN, where we treat each subgraph the same as the graph in the original NGNN. This way, we arrive at a second-order NGNN with two levels of nesting (a GNN of NGNNs, or a GNN of GNNs of GNNs). Repeating this construction, we can in principle construct an arbitrary-order NGNN. It is interesting to investigate whether high-order NGNNs can further enhance the representation power and the practical performance of a base GNN. We leave the exploration of such architectures to future work.

\textbf{Pooling functions  and .} 
To summarize node representations into a subgraph/graph representation, we need a readout (pooling) function. Popular choices include sum, mean, max, as well as more complex ones such as selecting top- nodes~\citep{zhang2018end,gao2019graph} and hierarchical approaches~\citep{ying2018hierarchical}. In this paper, we find mean pooling works very well, which directly takes the mean of node representations as the subgraph/graph representation. We also find another pooling function to be sometimes useful for subgraph pooling, called center pooling (CP). CP directly uses the root node's representation to represent the entire subgraph. The success of CP relies on using more layers of message passing than the height of the rooted subgraph, so that even the intermediate representation of the center root node alone can have sufficient information about the entire subgraph. This is feasible for rooted subgraphs with a small height. Note that when using a number of message passing layers smaller than the subgraph height, NGNN with CP will reduce to a standard message passing GNN.

\textbf{Subgraph height  and base GNN layers .}
NGNN is flexible in terms of choosing the subgraph height  and the number of message passing layers  in the base GNN. Theorem~\ref{thm:power} provides a guide for choosing  and  when discriminating -regular graphs. In practice, we find using  and  generally performs well across various tasks. Using a small  will restrict the receptive field, causing NGNN to learn too local features. Using a too large  might cause each rooted subgraph to include the entire graph. For the number of message passing layers , we find that using  performs better. This can be explained by that using a large  makes each node in a rooted subgraph to more sufficiently absorb the whole-subgraph information thus learning a better intermediate node representation reflecting its structural position within the subgraph. Please refer to \citep{zeng2020deep} for more motivations for using deeper message passing layers than the subgraph height.

















\section{More details about the experimental settings}\label{appendix:hyper}
The experiments were run on a Linux server with 64GB memory, two NVIDIA RTX 2080S (8GB) GPUs and an INTEL i9-9900 8-core CPU. For \texttt{ogbg-molhiv}, the final NGNN architecture used a rooted subgraph height  and number of GIN layers . Mean pooling is used in both the subgraph and graph pooling. The final NGNN architecture for \texttt{ogbg-molpcba} used a rooted subgraph height  and the number of GIN layers . Center pooling (CP) is used in the subgraph pooling and mean pooling is used in the graph pooling. Although we searched  and , we found the final performance is not very sensitive to these hyperparameters as long as  is between 3 and 5 and . For the DE features, we use shortest path distance and resistance distance~\citep{klein1993resistance}. 


\section{Simulation experiments to verify Theorem~\ref{thm:power}}\label{appendix:simu}
We conduct a simulation over random regular graphs to validate Lemma~\ref{lemma:2} (how well NGNN distinguishes nodes of regular graphs) and Theorem~\ref{thm:power} (how well NGNN distinguishes regular graphs). The results are shown in Figure~\ref{fig:simulation}, which match our theory almost perfectly. Basically, we sample 100 -node 3-regular graphs uniformly at random, and then apply an untrained NGNN to these graphs to see how often NGNN can distinguish the nodes and graphs at different rooted subgraph height  and node number . The required  at different  matches almost perfectly with the lower bound in Lemma~\ref{lemma:2}. More details are contained in the caption of Figure~\ref{fig:simulation}.



\begin{figure*}[h]
\centering
\includegraphics[width=0.45\textwidth]{materials/simu_node1.pdf}
\includegraphics[width=0.45\textwidth]{materials/simu_graph1.pdf}
\caption{Simulation to verify Theorem~\ref{thm:power}. The left graph shows the node-level (with only subgraph pooling) simulation results. The right graph shows the graph-level (with both subgraph and graph pooling) simulation results. We uniformly sample 100 -node 3-regular graphs with  ranging from 10 to 1280. We let the rooted subgraph height  range from 1 to 10. We apply an untrained Nested GIN with one message passing layer to these graphs (with a uniform 1 as node features). In the left figure, we compare the final node representations (after subgraph pooling) from all graphs output by the Nested GIN. If the difference between two node representations  is greater than machine accuracy, they are regarded as indistinguishable. The shade of each scatter point's color reflects the portion of indistinguishable node pairs at certain . The darker, the more indistinguishable node pairs. In the right graph, we compare the final graph representations (after graph pooling) output by the Nested GIN. The blue and red dashed lines show the theoretical upper and lower bounds for  to discriminate almost all nodes in -node 3-regular graphs, respectively. As we can see, the node-level simulation results perfectly match the theory (Lemma~\ref{lemma:2})---when  is larger than , almost all nodes from -regular graphs are distinguishable by NGNN. 
When  is even larger than , the nodes can hardly be distinguished because each subgraph contains the entire regular graph. The graph-level simulation results show that even using a very small  NGNN can still discriminate almost all -regular graphs--- in practice even does not need to be always chosen beyond . This is because although most nodes from two -regular graphs cannot be distinguished when , the graph pooling can still distinguish the two graphs as long as there exists one single node from one graph holding a representation different from any node representation from the other graph.}
\label{fig:simulation}
\end{figure*}






\section{Ablation study on DE}\label{appendix:de}

In this paper, we choose Distance Encoding (DE)~\citep{li2020distance} to augment the initial node features of NGNN, due to its good theoretical properties for improving the expressive power of message passing GNNs as well as its superb empirical performance on link prediction tasks~\citep{zhang2018link,Zhang2020Inductive}. DE encodes the distance between a node and the root node into a vector through an embedding layer. The distance embedding is concatenated with the raw features of a node as its new features (in this rooted subgraph) input to the base GNN. Note that when this node appears in another rooted subgraph, it may have a different distance to that root node, thus resulting in different DE features in different subgraphs. Only the NGNN framework can leverage such a subgraph-specific feature augmentation---a standard GNN treats a node always the same no matter which node's rooted subgraph/subtree it is in. 








\captionsetup[table]{font=small}
\begin{table*}[h!]
\caption{\small Ablation study on QM9 comparing Nested GNNs with and without DE features.}
\vspace{-10pt}
\label{table:ablation1}
\begin{center}
  \resizebox{1\textwidth}{!}{
  \begin{tabular}{lcccccccccccc}
    \toprule
    \textbf{Method}&&&&&&&ZPVE&&&&&\\
\midrule
    \textbf{1-GNN} & 0.493 &  0.78 & 0.00321 & 0.00355 & 0.0049 & 34.1 & 0.00124 & 2.32 & 2.08 & 2.23 & 1.94 & 0.27\\
    \textbf{Nested 1-GNN} (no DE) & \cellcolor[HTML]{E7FFE2}0.466 &  \cellcolor[HTML]{E7FFE2}0.38 & \cellcolor[HTML]{E7FFE2}0.00292 & \cellcolor[HTML]{E7FFE2}\textbf{0.00294} & \cellcolor[HTML]{E7FFE2}0.0042 & \cellcolor[HTML]{E7FFE2}24.0 & \cellcolor[HTML]{E7FFE2}0.00040 & \cellcolor[HTML]{E7FFE2}1.09 & \cellcolor[HTML]{E7FFE2}1.76 & \cellcolor[HTML]{E7FFE2}1.04 & \cellcolor[HTML]{E7FFE2}1.19 & \cellcolor[HTML]{E7FFE2}\textbf{0.111}\\
    \textbf{Nested 1-GNN} (with DE) & \cellcolor[HTML]{C3FFB5}\textbf{0.428} &  \cellcolor[HTML]{C3FFB5}\textbf{0.29} & \cellcolor[HTML]{C3FFB5}\textbf{0.00265} & 0.00297 & \cellcolor[HTML]{C3FFB5}\textbf{0.0038} & \cellcolor[HTML]{C3FFB5}\textbf{20.5} & \cellcolor[HTML]{C3FFB5}\textbf{0.00020} & \cellcolor[HTML]{C3FFB5}\textbf{0.295} & \cellcolor[HTML]{C3FFB5}\textbf{0.361} & \cellcolor[HTML]{C3FFB5}\textbf{0.305} & \cellcolor[HTML]{C3FFB5}\textbf{0.489} & 0.174\\
    \midrule
    \textbf{1-2-GNN} & 0.493 &  \textbf{0.27} & 0.00331 & 0.00350 & 0.0047 & 21.5 & 0.00018 & \textbf{0.0357} & \textbf{0.107} & \textbf{0.070} & \textbf{0.140} & 0.0989\\
    \textbf{Nested 1-2-GNN} (no DE) & \cellcolor[HTML]{E7FFE2}0.454 &  0.308 & \cellcolor[HTML]{E7FFE2}0.00280 & \cellcolor[HTML]{E7FFE2}0.00278 & \cellcolor[HTML]{E7FFE2}0.0041 & 23.3 & 0.00029 & 0.349 & 0.281 & 0.395 & 0.307 & \cellcolor[HTML]{E7FFE2}0.0945\\
    \textbf{Nested 1-2-GNN} (with DE) & \cellcolor[HTML]{C3FFB5}\textbf{0.437} &  0.278 & \cellcolor[HTML]{C3FFB5}\textbf{0.00275} & \cellcolor[HTML]{C3FFB5}\textbf{0.00271} & \cellcolor[HTML]{C3FFB5}\textbf{0.0039} & \textbf{20.4} & \textbf{0.00017} & 0.252 & 0.265 & 0.241 & 0.272 & \cellcolor[HTML]{C3FFB5}\textbf{0.0891}\\
    \midrule
    \textbf{1-3-GNN} & 0.473 &  0.46 & 0.00328 & 0.00354 & 0.0046 & 25.8 & 0.00064 & 0.6855 & 0.686 & 0.794 & 0.587 & 0.158\\
    \textbf{Nested 1-3-GNN} (no DE) & \cellcolor[HTML]{E7FFE2}0.448 &  \cellcolor[HTML]{E7FFE2}0.298 & \cellcolor[HTML]{E7FFE2}0.00276 & \cellcolor[HTML]{E7FFE2}0.00276 & \cellcolor[HTML]{E7FFE2}0.0040 & \cellcolor[HTML]{E7FFE2}22.0 & \cellcolor[HTML]{E7FFE2}0.00025 & \cellcolor[HTML]{E7FFE2}0.410 & \cellcolor[HTML]{E7FFE2}0.396 & \cellcolor[HTML]{E7FFE2}0.370 &\cellcolor[HTML]{E7FFE2} 0.422 & \cellcolor[HTML]{E7FFE2}0.0936\\
    \textbf{Nested 1-3-GNN} (with DE) & \cellcolor[HTML]{C3FFB5}\textbf{0.436} &  \cellcolor[HTML]{C3FFB5}\textbf{0.261} & \cellcolor[HTML]{C3FFB5}\textbf{0.00265} & \cellcolor[HTML]{C3FFB5}\textbf{0.00269} & \cellcolor[HTML]{C3FFB5}\textbf{0.0039} & \cellcolor[HTML]{C3FFB5}\textbf{20.2} & \cellcolor[HTML]{C3FFB5}\textbf{0.00017} & \cellcolor[HTML]{C3FFB5}\textbf{0.291} & \cellcolor[HTML]{C3FFB5}\textbf{0.278} & \cellcolor[HTML]{C3FFB5} \textbf{0.267} & \cellcolor[HTML]{C3FFB5}\textbf{0.287} & \cellcolor[HTML]{C3FFB5}\textbf{0.0879}\\
    \midrule
    \textbf{1-2-3-GNN} & 0.476 &  0.27 & 0.00337 & 0.00351 & 0.0048 & 22.9 & 0.00019 & \textbf{0.0427} & \textbf{0.111} & \textbf{0.0419} & \textbf{0.0469} & 0.0944\\
    \textbf{Nested 1-2-3-GNN} (no DE) & \cellcolor[HTML]{E7FFE2}0.449 &  0.306 & \cellcolor[HTML]{E7FFE2}0.00282 & \cellcolor[HTML]{E7FFE2}0.00286 & \cellcolor[HTML]{E7FFE2}0.0041 & \cellcolor[HTML]{E7FFE2}22.0 & 0.00023 & 0.220 & 0.218 & 0.268 & 0.205 & 0.0975\\
    \textbf{Nested 1-2-3-GNN} (with DE) & \cellcolor[HTML]{C3FFB5}\textbf{0.433} &  \textbf{0.265} & \cellcolor[HTML]{C3FFB5}\textbf{0.00279} & \cellcolor[HTML]{C3FFB5}\textbf{0.00276} & \cellcolor[HTML]{C3FFB5}\textbf{0.0039} & \cellcolor[HTML]{C3FFB5}\textbf{20.1} & \textbf{0.00015} & 0.205 & 0.200 & 0.249 & 0.253 & \textbf{0.0811}\\
  \bottomrule
\end{tabular}
}
\end{center}
\vspace{-5pt}
\end{table*}

In this section, we do ablation experiments to study the effect of the DE features. We choose QM9 as the testbed. The base GNNs are the same as in Table~\ref{table:qm9}. For each base GNN, we compare it with its Nested GNN version without DE features (no DE) and its Nested GNN version with DE features (with DE). The results are shown in Table~\ref{table:ablation1}.


In Table~\ref{table:ablation1}, we color the cell with light green if the NGNN (no DE) is better than the base GNN, and mark the cell with green if the NGNN (with DE) is additionally better than the NGNN (no DE). From the results, we can first observe that NGNNs (no DE) generally outperform the base GNNs, validating that even without any feature augmentation the NGNN framework still enhances the performance of base GNNs. Furthermore, we can observe that if NGNN improves over the base GNN, adding DE features could further enlarge the performance improvement by achieving the smallest MAEs among the three (i.e., base GNN, NGNN (no DE) and NGNN (with DE)). This demonstrates the usefulness of augmenting NGNN with DE features. Note that adding such DE features can be done simultaneously with the rooted subgraph extraction process, which only adds a negligible amount of time. Thus, augmenting NGNN with DE features is almost a free yet powerful operation to further enhance NGNN's power, which motivates us to make it a default choice of NGNN.



\end{document}