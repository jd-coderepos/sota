\pdfoutput=1

\documentclass{article}







\usepackage[final,nonatbib]{neurips_2019}



\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      

\usepackage{graphicx}
\usepackage{comment}
\usepackage{multirow}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{subcaption}
\captionsetup{compatibility=false}
\newcommand*{\q}[1]{\textcolor{red}{#1}}
\newcommand*{\A}[1]{\textcolor{blue}{#1}} 
\usepackage{wrapfig}
\usepackage{array}
\usepackage{ragged2e}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\title{DFNets: Spectral CNNs for Graphs with Feedback-Looped Filters}



\author{Asiri ~Wijesinghe\\ Research School of Computer Science\\
  The Australian National University\\
  \texttt{asiri.wijesinghe@anu.edu.au} \\
  \And
  Qing ~Wang \\
  Research School of Computer Science\\
  The Australian National University\\
  \texttt{qing.wang@anu.edu.au} \\
}



\begin{document}


\maketitle

\begin{abstract}
We propose a novel spectral convolutional neural network (CNN) model on graph structured data, namely \emph{Distributed Feedback-Looped Networks} (DFNets). This model is incorporated with a robust class of spectral graph filters, called \emph{feedback-looped filters}, to provide better localization on vertices, while still attaining fast convergence and linear memory requirements. Theoretically, feedback-looped filters can guarantee convergence w.r.t. a specified error bound, and be applied universally to any graph without knowing its structure. Furthermore, the propagation rule of this model can diversify features from the preceding layers to produce strong gradient flows. We have evaluated our model using two benchmark tasks: semi-supervised document classification on citation networks and semi-supervised entity classification on a knowledge graph. The experimental results show that our model considerably outperforms the state-of-the-art methods in both benchmark tasks over all datasets.
\end{abstract}



\section{Introduction}
\vspace{-0.2cm}
Convolutional neural networks (CNNs) \cite{krizhevsky2012imagenet} are a powerful deep learning approach which has been widely applied in various fields, e.g., object recognition \cite{sharif2014cnn}, image classification \cite{hu2015deep}, and semantic segmentation \cite{li2017fully}. Traditionally, CNNs only deal with data that has a regular Euclidean structure, such as images, videos and text. In recent years, due to the rising trends in network analysis and prediction, generalizing CNNs to graphs has attracted considerable interest \cite{bruna2013spectral,defferrard2016convolutional,hamilton2017inductive,perozzi2014deepwalk}. However, since graphs are in irregular non-Euclidean domains, this brings
up the challenge of how to enhance CNNs for effectively extracting useful features (e.g. topological structure) from arbitrary graphs.

To address this challenge, a number of studies have been devoted to enhancing CNNs by developing filters over graphs. In general, there are two categories of graph filters: (a) spatial graph filters, and (b) spectral graph filters. Spatial graph filters are defined as convolutions directly on graphs, which consider neighbors that are spatially close to a current vertex \cite{atwood2016diffusion, duvenaud2015convolutional, hamilton2017inductive}. In contrast, spectral graph filters are convolutions indirectly defined on graphs, through their spectral representations \cite{bruna2013spectral,chung1997spectral,defferrard2016convolutional}. In this paper, we follow the line of previous studies in developing spectral graph filters and tackle the problem of designing an effective, yet efficient CNNs with spectral graph filters.

Previously, Bruna et al. \cite{bruna2013spectral} proposed convolution operations on graphs via a spectral decomposition of the graph Laplacian. To reduce learning complexity in the setting where the graph structure is not known a priori, Henaff et al. \cite{henaff2015deep} developed a spectral filter with smooth coefficients. Then, Defferrard et al. \cite{defferrard2016convolutional} introduced Chebyshev filters to stabilize convolution operations under coefficient perturbation and these filters can be exactly localized in k-hop neighborhood. Later, Kipf et al. \cite{kipf2016semi} proposed a simple layer-wise propagation model using Chebyshev filters on 1-hop neighborhood. Very recently, some works attempted to develop rational polynomial filters, such as Cayley filters \cite{levie2017cayleynets} and ARMA \cite{bianchi2019graph}. From a different perspective, Petar et al. \cite{velivckovic2017graph} proposed a self-attention based CNN architecture for  graph filters, which extracts features by considering the importance of neighbors. 










\begin{figure}[t!]
    \centering
    \includegraphics[width=0.85\textwidth]{images/Architecture_Diagram2.pdf}
    \caption{A simplified example of illustrating feedback-looped filters, where  is the current vertex and the similarity of the colours indicates the correlation between vertices, e.g.,  and  are highly correlated, but  and  are less correlated with : (a) an input graph, where  is the original frequency to vertex ; (b) the feedforward filtering, which attenuates some low order frequencies, e.g. , and amplify other frequencies, e.g.  and ; (c) the feedback filtering, which reduces the error in the frequencies generated by (b), e.g. . \label{fig:firstModel}}\vspace{-0.2cm}
\end{figure}
One key idea behind existing works on designing spectral graph filters is to approximate the frequency responses of graph filters using a polynomial function (e.g. Chebyshev filters \cite{defferrard2016convolutional}) or a rational polynomial function (e.g. Cayley filters \cite{levie2017cayleynets} and ARMA \cite{bianchi2019graph}). Polynomial filters are sensitive to changes in the underlying graph structure. They are also very smooth and can hardly model sharp changes, as illustrated in Figure \ref{fig:firstModel}. Rational polynomial filters are more powerful to model localization, but they often have to trade off computational efficiency, resulting in higher learning and computational complexities, as well as instability. 
 
\smallskip
\noindent\textbf{Contributions. }In this work, we aim to develop a new class of spectral graph filters that can overcome the above limitations. We also propose a spectral CNN architecture (i.e. DFNet) to incorporate these graph filters. In summary, our contributions are as follows: \begin{itemize}
\item \textbf{Improved localization. }A new class of spectral graph filters, called \emph{feedback-looped filters}, is proposed to enable better localization, due to its rational polynomial form. Basically, feedback-looped filters consist of two parts: \emph{feedforward} and \emph{feedback}. The feedforward filtering is k-localized as polynomial filters, while the feedback filtering is unique which refines k-localized features captured by the feedforward filtering to improve approximation accuracy. We also propose two techniques: \emph{scaled-normalization} and \emph{cut-off frequency} to avoid the issues of gradient vanishing/exploding and instabilities. 

\item \textbf{Efficient computation. }For feedback-looped filters, we avoid the matrix inversion implied by the denominator through approximating the matrix inversion with a recursion. Thus, benefited from this approximation, feedback-looped filters attain linear convergence time and linear memory requirements w.r.t. the number of edges in a graph.

\item \textbf{Theoretical properties. }Feedback-looped filters enjoy several nice theoretical properties. Unlike other rational polynomial filters for graphs, they have theoretically guaranteed convergence w.r.t. a specified error bound. On the other hand, they still have the universal property as other spectral graph filters \cite{isufi2017autoregressive1}, i.e., can be applied without knowing the underlying structure of a graph. The optimal coefficients of feedback-looped filters are learnable via an optimization condition for any given graph.

\item \textbf{Dense architecture. }We propose a layer-wise propagation rule for our spectral CNN model with feedback-looped filters, which densely connects layers as in DenseNet \cite{huang2017densely}. This design enables our model to diversify features from all preceding layers, leading to a strong gradient flow. We also introduce a layer-wise regularization term to alleviate the overfitting issue. In doing so, we can prevent the generation of spurious features and thus improve accuracy of the prediction.
\end{itemize}
To empirically verify the effectiveness of our work, we have evaluated feedback-looped filters within three different CNN architectures over four benchmark datasets to compare against the state-of-the-art methods. The experimental results show that our models significantly outperform the state-of-the-art methods. We further demonstrate the effectiveness of our model DFNet through the node embeddings in a 2-D space of vertices from two datasets.
 \section{Spectral Convolution on Graphs}
\label{sec:sepectral-filters}\vspace{-0.2cm}
Let  be an undirected and weighted graph, where  is a set of vertices,  is  a set of edges, and  is an adjacency matrix which encodes the weights of edges. We let  and . A \emph{graph signal} is a function  and can be represented as a vector  whose  component  is the value of  at the  vertex in .  The graph Laplacian is defined as , where  is a diagonal matrix with  and  is an identity matrix.  has a set of orthogonal eigenvectors , known as the \emph{graph Fourier basis}, and non-negative eigenvalues , known as the \emph{graph frequencies} \cite{chung1997spectral}. 
 is diagonalizable by the eigendecomposition such that , where  and  is a hermitian transpose of . We use  and  to denote the smallest and largest eigenvalues of , respectively.


Given a graph signal , the \emph{graph Fourier transform} of  is  and its inverse is  \cite{sandryhaila2013discrete,shuman2013emerging}. The graph Fourier transform enables us to apply graph filters in the vertex domain. A \emph{graph filter}  can filter  by altering (amplifying or attenuating) the graph frequencies as 

Here, , which controls how the frequency of each component in a graph signal  is modified. However, applying graph filtering as in Eq. \ref{equ:graph-filter} requires the eigendecomposition of , which is computationally expensive. To address this issue, several works \cite{bianchi2019graph, defferrard2016convolutional,hammond2011wavelets,kipf2016semi,levie2017cayleynets,liao2019lanczosnet} have studied the approximation of  by a polynomial or rational polynomial function. 



\smallskip
\textbf{Chebyshev filters.   } Hammond et al. \cite{hammond2011wavelets} first proposed to approximate  by  a polynomial function with -order polynomials and Chebyshev coefficients. Later, Defferrard et al. \cite{defferrard2016convolutional} developed Chebyshev filters for spectral CNNs on graphs. A Chebyshev filter is defined as

where  is a vector of learnable Chebyshev coefficients,  is rescaled from , the Chebyshev polynomials  are recursively defined with  and , and  controls the size of filters, i.e., localized in k-hop neighborhood of a vertex \cite{hammond2011wavelets}. Kipf and Welling \cite{kipf2016semi} simplified Chebyshev filters by restricting to 1-hop neighborhood.




\smallskip
\textbf{Lanczos filters. } Recently, Liao et al. \cite{liao2019lanczosnet} used the Lanczos algorithm to generate a low-rank matrix approximation  for the graph Laplacian. They used the affinity matrix . Since  holds,  and  share the same eigenvectors but have different eigenvalues. As a result,  and  correspond to the same . To approximate the eigenvectors and eigenvalues of , they diagonalize the tri-diagonal matrix  to compute Ritz-vectors  and Ritz-values , and thus . Accordingly, a k-hop Lanczos filter operation is,


where  is a vector of learnable Lanczos filter coefficients. Thus, spectral convolutional operation is defined as . Such Lanczos filter operations can significantly reduce computation overhead when approximating large powers of , i.e. . Thus, they can efficiently compute the spectral graph convolution with a very large localization range to easily capture the multi-scale information of the graph.














\smallskip
\textbf{Cayley filters.  } Observing that Chebyshev filters have difficulty in detecting narrow frequency bands due to , Levie et al. \cite{levie2017cayleynets} proposed Cayley filters, based on Cayley polynomials:
 
where  is a real coefficient and  is a vector of complex coefficients.  denotes the real part of a complex number , and  is a parameter called \emph{spectral zoom}, which controls the degree of ``zooming'' into eigenvalues in . Both  and  are learnable during training. To improve efficiency, the Jacobi method is used to approximately compute Cayley polynomials. 

\smallskip
\textbf{ARMA filters. } Bianchi et al. \cite{bianchi2019graph} sought to address similar issues as identified in \cite{levie2017cayleynets}. However, different from Cayley filters, they developed a first-order ARMA filter, which is approximated by a first-order recursion:

where  and  are the filter coefficients, , and . Accordingly, the frequency response is defined as:

where , , and  \cite{isufi2017autoregressive1}. Multiple ARMA filters can be applied in parallel to obtain a ARMA filter. However, the memory complexity of  parallel ARMA filters is  times higher than ARMA graph filters. \begin{comment}

where  denotes the spectral decomposition of .
\end{comment}






\smallskip


We make some remarks on how these existing spectral filters are related to each other. (i) As discussed in \cite{bianchi2019graph,levie2017cayleynets, liao2019lanczosnet}, polynomial filters (e.g. Chebyshev and Lanczos filters) can be approximately treated as a special kind of rational polynomial filters. (ii) Further, Chebyshev filters can be regarded as a special case of Lanczos filters. (iii) Although both Cayley and ARMA filters are rational polynomial filters, they differ in how they approximate the matrix inverse implied by the denominator of a rational function. Cayley filters use a fixed number of Jacobi iterations, while ARMA filters use a first-order recursion plus a parallel bank of  ARMA.
 (iv) ARMA by Bianchi et al. \cite{bianchi2019graph} is similar to GCN by Kipf et al. \cite{kipf2016semi} because they both consider localization within 1-hop neighborhood. 



 
\section{Proposed Method}
\label{sec:others}\vspace{-0.2cm}
We introduce a new class of spectral graph filters, called \emph{feedback-looped filters}, and propose a spectral CNN for graphs with feedback-looped filters, namely \emph{Distributed Feedback-Looped Networks} (DFNets). We also discuss optimization techniques and analyze theoretical properties. 


\subsection{Feedback-Looped Filters}\label{subsec:filters}
Feedback-looped filters belong to a class of Auto Regressive Moving Average (ARMA) filters \cite{isufi2017autoregressive2,isufi2017autoregressive1}.
Formally, an ARMA filter is defined as:

\begin{comment}

\end{comment}
The parameters   and  refer to the \emph{feedback} and \emph{feedforward} degrees, respectively.  and  are two vectors of complex coefficients. 
Computing the denominator of Eq. \ref{equ:arma-filter-L} however requires a matrix inversion, which is computationally inefficient for large graphs. To circumvent this issue, \emph{feedback-looped filters} use the following approximation: 
where , , ,  and  is the largest eigenvalue of . Accordingly, the frequency response of feedback-looped filters is defined as:

To alleviate the issues of gradient vanishing/exploding and numerical instabilities, we further introduce two techniques in the design of feedback-looped filters: \emph{scaled-normalization} and \emph{cut-off frequency}. 

\noindent\textbf{Scaled-normalization technique. } To assure the stability of feedback-looped filters, we apply the scaled-normalization technique to increasing the stability region, i.e., using the scaled-normalized Laplacian , rather than just . This accordingly helps centralize the eigenvalues of the Laplacian  and reduce its spectral radius bound. The scaled-normalized Laplacian  consists of graph frequencies within , in which eigenvalues are ordered in an increasing order. 









\smallskip
\noindent\textbf{Cut-off frequency technique. } To map graph frequencies within  to a uniform discrete distribution, we define a \emph{cut-off frequency} , where  and  refers to the largest eigenvalue of . The cut-off frequency is used as a threshold to control the amount of attenuation on graph frequencies. The eigenvalues  are converted to binary values  such that  if  and  otherwise. This trick allows the generation of ideal high-pass filters so as to sharpen a signal by amplifying its graph Fourier coefficients. This technique also solves the issue of narrow frequency bands existing in previous spectral filters, including both polynomial and rational polynomial filters \cite{defferrard2016convolutional, levie2017cayleynets}. This is because these previous spectral filters only accept a small band of frequencies. In contrast, our proposed feedback-looped filters resolve this issue using a cut-off frequency technique, i.e., amplifying frequencies higher than a certain low cut-off value while attenuating frequencies lower than that cut-off value. Thus, our proposed filters can accept a wider range of frequencies and capture better characteristic properties of a graph.

 



\subsection{Coefficient Optimisation}
Given a feedback-looped filter with a desired frequency response: , we aim to find the optimal coefficients  and  that make the frequency response as close as possible to the desired frequency response, i.e. to minimize the following error:

However, the above equation is not linear w.r.t. the coefficients  and . Thus, we redefine the error as follows:

Let , ,  with  and  with  are two Vandermonde-like matrices. Then, we have .
 Thus, the stable coefficients   and  can be learned by minimizing  as a convex constrained least-squares optimization problem:


Here, the parameter  controls the tradeoff between convergence efficiency and approximation accuracy. A higher value of  can lead to slower convergence but better accuracy. It is not recommended to have very low  values due to potentially unacceptable accuracy.  is the stability condition, which will be further discussed in detail in Section \ref{subsec:theoretical-properties}.





\subsection{Spectral Convolutional Layer} 


We propose a CNN-based architecture, called DFNets, which can stack multiple spectral convolutional layers with feedback-looped filters to extract features of increasing abstraction. Let  and . The propagation rule of a spectral convolutional layer is defined as:



\noindent where  refers to a non-linear activation function such as .  is a graph signal matrix where  refers to the number of features.  is a matrix of activations in the  layer.  and  are two trainable weight matrices in the  layer. To compute , a vertex needs access to its -hop neighbors with the output signal of the previous layer , and its -hop neighbors with the input signal from . To attenuate the overfitting issue, we add , namely \emph{kernel regularization} \cite{cortes20092}, and a bias term . We use the xavier normal initialization method \cite{glorot2010understanding} to initialise the kernel and bias weights, the unit-norm constraint technique \cite{douglas2000gradient} to normalise the kernel and bias weights by restricting parameters of all layers in a small range, and the kernel regularization technique to penalize the parameters in each layer during the training.  In doing so, we can prevent the generation of spurious features and thus improve the accuracy of prediction 
\footnote{DFNets implementation can be found at: \href{https://github.com/wokas36/DFNets} {https://github.com/wokas36/DFNets}}.

In this model, each layer is directly connected to all subsequent layers in a feed-forward manner, as in DenseNet \cite{huang2017densely}. Consequently, the  layer receives all preceding feature maps  as input. We concatenate multiple preceding feature maps column-wise into a single tensor to obtain more diversified features for boosting the accuracy. This densely connected CNN architecture has several compelling benefits: (a) reduce the vanishing-gradient issue, (b) increase feature propagation and reuse, and (c) refine information flow between layers  \cite{huang2017densely}. 

\begin{comment}
\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{images/first_model_v5.png}
    \caption{Densely connected spectral ARMA convnets architecture with 3 ARMA layers (8, 16, 32 nodes respectively) followed by a softmax layer.}
    \label{fig:firstModel}
\end{figure}
\end{comment}

\subsection{Theoretical Analysis}\label{subsec:theoretical-properties}
Feedback-looped filters have several nice properties, e.g., guaranteed convergence, linear convergence time, and universal design. We discuss these properties and analyze computational complexities.  

\noindent\textbf{Convergence. } Theoretically, a feedback-looped filter can achieve a desired frequency response only when  \cite{isufi2017autoregressive1}. However, due to the property of linear convergence preserved by feedback-looped filters, stability can be guaranteed after a number of iterations w.r.t. a specified small error \cite{isufi2017autoregressive2}. More specifically, since the pole of rational polynomial filters should be in the unit circle of the z-plane to guarantee the stability, we can derive the stability condition  by  Eq.~\ref{equ:arma-filter-L} in the vertex domain and correspondingly obtain the stability condition  in the frequency domain as stipulated in Eq.~\ref{equ:arma-filter-optimizer} \cite{isufi2017autoregressive2}.








\noindent\textbf{Universal design. } 
The universal design is beneficial when the underlying structure of a graph is unknown or the topology of a graph changes over time. The corresponding filter coefficients can be learned independently of the underlying graph and are universally applicable. When designing feedback-looped filters, we define the desired frequency response function  over graph frequencies  in a binary format in the uniform discrete distribution as discussed in Section \ref{subsec:filters}. Then, we solve Eq.~\ref{equ:arma-filter-optimizer} in the least-squares sense for this finite set of graph frequencies to find optimal filter coefficients.






\begin{table}[h!]
\centering\vspace{-0cm}
\scalebox{1}{\begin{tabular}{| l|m{1.8cm}| c|c| c|}  \hline
   \multirow{2}{*}{Spectral Graph Filter} & \multirow{2}{*}{Type} & Learning & Time & Memory \\
    & &Complexity& Complexity& Complexity\\
   \hline
Chebyshev filters \cite{defferrard2016convolutional} & \multirow{2}{*}{Polynomial} &  &  & {} \\\cline{1-1}\cline{3-5}
    {Lanczos filters} \cite{liao2019lanczosnet} & &  &  &  \\\hline
    Cayley filters \cite{levie2017cayleynets} &\multirow{4}{\hsize}{Rational polynomial} & {} &{} &{} \\\cline{1-1}\cline{3-5}
   ARMA filters \cite{bianchi2019graph} & &{} & {} & {}\\\cline{1-1}\cline{3-5}
       parallel ARMA filters \cite{bianchi2019graph} & &{} & {} & {}\\\cline{1-1}\cline{3-5}
   Feedback-looped filters (ours) & &{} &{}  & {}\\
   \hline
 \end{tabular}}
 \caption{Learning, time and space complexities of spectral graph filters. \label{Tab:complexity}}\vspace{-0.3cm}
\end{table}
\noindent\textbf{Complexity. } When computing  as in Eq. \ref{equ:feedback-looped}, we need to calculate  for  and  for . Nevertheless,  is computed only once because . Thus, we need  multiplications for each  in the first term in Eq. \ref{equ:feedback-looped}, and  multiplications for the second term in Eq. \ref{equ:feedback-looped}. Table \ref{Tab:complexity} summarizes the complexity results of existing spectral graph filters and ours, where  refers to the number of Jacobi iterations in \cite{levie2017cayleynets}. Note that, when  (i.e., one spectral convolutional layer), feedback-looped filters have the same learning, time and memory complexities as Chebyshev filters, where .
 
\section{Numerical Experiments}
\label{sec:experiments}
We evaluate our models on two benchmark tasks: (1) semi-supervised document classification in citation networks, and (2) semi-supervised entity classification in a knowledge graph.   




\subsection{Experimental Set-Up}
\textbf{Datasets.} We use three citation network datasets Cora, Citeseer, and Pubmed \cite{sen2008collective} for semi-supervised document classification, and one dataset NELL \cite{carlson2010toward} for semi-supervised entity classification. NELL is a bipartite graph extracted from a knowledge graph \cite{carlson2010toward}. Table \ref{Tab:datasets} contains dataset statistics \cite{yang2016revisiting}. 
\begin{table}[ht]
\centering \begin{tabular}{l l r r r r r} \specialrule{.1em}{.05em}{.05em} Dataset & Type & \#Nodes & \#Edges & \#Classes & \#Features & {\%Labeled Nodes} \\ [0.5ex] \hline Cora & Citation network & 2,708 & 5,429 & 7 & 1,433 & 0.052 \\
Citeseer & Citation network & 3,327 & 4,732 & 6 & 3,703 & 0.036 \\
Pubmed & Citation network & 19,717 & 44,338 & 3 & 500 & 0.003 \\
NELL & Knowledge graph & 65,755 & 266,144 & 210 & 5,414 & 0.001 \\
\specialrule{.1em}{.05em}{.05em}
\end{tabular}
\caption{Dataset statistics. \label{Tab:datasets}}
\end{table}\vspace*{-0.5cm}

\textbf{Baseline methods.} We compare against twelve baseline methods, including five methods using spatial graph filters, i.e., Semi-supervised Embedding (SemiEmb) \cite{weston2012deep}, Label Propagation (LP) \cite{zhu2003semi}, skip-gram graph embedding model (DeepWalk) \cite{perozzi2014deepwalk}, Iterative Classification Algorithm (ICA) \cite{lu2003link}, and semi-supervised learning with graph embedding (Planetoid*) \cite{yang2016revisiting}, and seven methods using spectral graph filters: Chebyshev \cite{defferrard2016convolutional}, Graph Convolutional Networks (GCN) \cite{kipf2016semi}, Lanczos Networks (LNet) and Adaptive Lanczos Networks (AdaLNet) \cite{liao2019lanczosnet}, CayleyNet \cite{levie2017cayleynets}, Graph Attention Networks (GAT) \cite{velivckovic2017graph}, and ARMA Convolutional Networks (ARMA) \cite{bianchi2019graph}.



We evaluate our feedback-looped filters using three different spectral CNN models: (i) DFNet: a densely connected spectral CNN with feedback-looped filters, (ii) DFNet-ATT: a self-attention based densely connected spectral CNN with feedback-looped filters, and (iii) DF-ATT: a self-attention based spectral CNN model with feedback-looped filters. 


\begin{table}[ht]
\centering \scalebox{0.97}{\begin{tabular}{l c c l c c l } \specialrule{.1em}{.05em}{.05em} Model & L2 reg. & \#Layers & \#Units  &Dropout &[p, q]&\\ [0.5ex] 
\hline DFNet & 9e-2 & 5 & [8, 16, 32, 64, 128]& 0.9 &[5, 3]&0.5\\ 
DFNet-ATT & 9e-4 & 4 & [8, 16, 32, 64] &0.9 &[5, 3]& 0.5\\ 
DF-ATT & 9e-3 & 2 & [32, 64] & [0.1, 0.9] &[5, 3]& 0.5 \\ 
\hline 
\end{tabular}}
\caption{Hyperparameter settings for citation network datasets.\label{Tab:hyperparameters}}
\end{table}\vspace{-0.3cm}


\textbf{Hyperparameter settings.} We use the same data splitting for each dataset as in Yang et al. \cite{yang2016revisiting}. The hyperparameters of our models are initially selected by applying the orthogonalization technique (a randomized search strategy). We also use a layerwise regularization (L2 regularization) and bias terms to attenuate the overfitting issue. All models are trained 200 epochs using the Adam optimizer \cite{kingma2014adam} with a learning rate of 0.002. Table \ref{Tab:hyperparameters} summarizes the hyperparameter settings for citation network datasets.  The same hyperparameters are applied to the NELL dataset except for L2 regularization (i.e., 9e-2 for DFNet and DFnet-ATT, and 9e-4 for DF-ATT). For , we choose the best setting for each model. For self-attention, we use 8 multi-attention heads and 0.5 attention dropout for DFNet-ATT, and 6 multi-attention heads and 0.3 attention dropout for DF-ATT. The parameters ,  and  are applied to all three models over all datasets.



\begin{comment}
\begin{table}[ht]
\caption{Hyperparameter settings for each model.\label{Tab:hyperparameters}} \centering \begin{tabular}{l l c c l c} \specialrule{.1em}{.05em}{.05em} Dataset & Model & L2 reg. & \#Layers & \#Nodes & [P, Q, \gamma] \\ [0.5ex] \hline \multirow{3}{4em}{Cora} & FirstModel & 9e-2 & 5 & [8, 16, 32, 64, 128] & [5, 3, 0.9]\\ 
& SecondModel & 9e-4 & 4 & [8, 16, 32, 64] & [3, 2, 0.7]\\ 
& ThirdModel & 9e-3 & 2 & [32, 64] & [5, 3, 0.9] \\ 
\hline \multirow{3}{4em}{Citeseer} & FirstModel & 9e-2 & 5 & [8, 16, 32, 64, 128] & [5, 3, 0.9]\\ 
& SecondModel & 9e-4 & 4 & [8, 16, 32, 64] & [5, 3, 0.5]\\ 
& ThirdModel & 9e-3 & 2 & [32, 64] & [5, 3, 0.5] \\ 
\hline \multirow{3}{4em}{Pubmed} & FirstModel & 9e-2 & 5 & [8, 16, 32, 64, 128] & [3, 2, 0.7]\\ 
& SecondModel & 9e-2 & 4 & [8, 16, 32, 64] & [5, 3, 0.9]\\ 
& ThirdModel & 9e-3 & 2 & [32, 64] & [5, 3, 0.9] \\ 
\hline \multirow{3}{4em}{NELL} & FirstModel & 9e-2 & 5 & [8, 16, 32, 64, 128] & [5, 3, 0.5]\\ 
& SecondModel & 9e-2 & 4 & [8, 16, 32, 64] & [5, 3, 0.9]\\ 
& ThirdModel & 9e-4 & 2 & [32, 64] & [5, 3, 0.9] \\ 
\specialrule{.1em}{.05em}{.05em} \end{tabular}
\end{table}




\end{comment}

\subsection{Comparison with Baseline Methods}
Table \ref{Tab:baselines} summarizes the results of classification in terms of accuracy. The results of the baseline methods are taken from the previous works  \cite{kipf2016semi, liao2019lanczosnet, velivckovic2017graph, yang2016revisiting}. Our models DFNet and DFNet-ATT outperform all the baseline methods over four datasets. Particularly, we can see that: (1) Compared with polynomial filters, DFNet improves upon GCN (which performs best among the models using polynomial filters) by a margin of 3.7\%, 3.9\%, 5.3\% and 2.3\% on the datasets Cora, Citeseer, Pubmed and NELL, respectively. (2) Compared with rational polynomial filters, DFNet improves upon CayleyNet and ARMA by 3.3\% and 1.8\% on the Cora dataset, respectively. For the other datasets, CayleyNet does not have results available in \cite{levie2017cayleynets}. (3) DFNet-ATT further improves the results of DFNet due to the addition of a self-attention layer. (4) Compared with GAT (Chebyshev filters with self-attention), DF-ATT also improves the results and achieves 0.4\%, 0.6\% and 3.3\% higher accuracy on the datasets Cora, Citeseer and Pubmed, respectively.

Additionally, we compare DFNet (our feedback-looped filters + DenseBlock) with GCN + DenseBlock and GAT + DenseBlock. The results are also presented in Table \ref{Tab:baselines}. We can see that our feedback-looped filters perform best, no matter whether or not the dense architecture is used. 

\begin{table}[ht]
\centering 
\begin{tabular}{ l c c c c}
\specialrule{.1em}{.05em}{.05em} 
Model & Cora & Citeseer & Pubmed & NELL \\ [0.5ex] 
\hline
SemiEmb \cite{weston2012deep} & 59.0 & 59.6 &71.1 & 26.7\\
LP \cite{zhu2003semi} & 68.0 & 45.3 & 63.0 & 26.5 \\
DeepWalk \cite{perozzi2014deepwalk} & 67.2 & 43.2 & 65.3 & 58.1 \\
ICA \cite{lu2003link} & 75.1 & 69.1 & 73.9 & 23.1 \\
Planetoid* \cite{yang2016revisiting} & 64.7 & 75.7 & 77.2 & 61.9 \0.5ex]
\hline
GCN + DenseBlock & 82.7  0.5 & 71.3  0.3 & 81.5  0.5 & 66.4  0.3 \\ 
GAT + Dense Block & 83.8  0.3 & 73.1  0.3 & 81.8  0.3 & - \\ [0.5ex]
\hline DFNet (ours) & \textbf{85.2}  \textbf{0.5} & \textbf{74.2}  \textbf{0.3} & \textbf{84.3}  \textbf{0.4} & \textbf{68.3}  \textbf{0.4} \\
DFNet-ATT (ours) & \textbf{86.0}  \textbf{0.4} & \textbf{74.7}  \textbf{0.4} & \textbf{85.2}  \textbf{0.3} & \textbf{68.8}  \textbf{0.3} \\
DF-ATT (ours) & 83.4  0.5 & 73.1  0.4 & \textbf{82.3}  \textbf{0.3} & \textbf{67.6}  \textbf{0.3} \\
\specialrule{.1em}{.05em}{.05em}
\end{tabular}\caption{Accuracy (\%) averaged over 10 runs (* was obtained using a different data splitting in \cite{levie2017cayleynets})}. 
\label{Tab:baselines} \vspace{-0.7cm}
\end{table}









\begin{comment}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.45\textwidth]{images/polynomial_orders_plot/poly_P.eps}
    \includegraphics[width=0.45\textwidth]{images/polynomial_orders_plot/poly_Q.eps}
    \caption{Accuracy (\%) of DFNet under different polynomial orders, where Q=3 in (a) and P=5 in (b).}
    \label{fig:polynomialPlots}
\end{figure}\vspace{-0.1cm}
\end{comment}

\begin{comment}
\begin{table}[ht]
\caption{Evaluation with different polynomial orders. \label{Tab:polynomial}} \centering \begin{tabular}{c l c c c} \specialrule{.1em}{.05em}{.05em} Order[P, Q, ] & Model & Cora & Citeseer & Pubmed \\ [0.5ex] \hline \multirow{3}{4em}{[3, 2, 0.7]} & FirstModel & 61.8 & 71.9 & \textbf{84.6} \\ 
& SecondModel & \textbf{86.3} & 71.6 & 83.7 \\ 
& ThirdModel & 79.8 & 68.2 & 81.4 \\ 
\hline \multirow{3}{4em}{[3, 2, 0.9]} & FirstModel & 71.5 & 72.8 & 83.5 \\ 
& SecondModel & 85.9 & 74.5 & 83.9 \\ 
& ThirdModel & 80.0 & 69.5 & 81.7 \\ 
\hline \multirow{3}{4em}{[5, 3, 0.5]} & FirstModel & 83.8 & \textbf{74.2} & 82.7 \\ 
& SecondModel & 84.9 & \textbf{74.7} & 83.1 \\ 
& ThirdModel & 82.0 & 70.6 & 82.4 \\ 
\hline \multirow{3}{4em}{[5, 3, 0.9]} & FirstModel & \textbf{85.2} & 73.9 & 83.4 \\ 
& SecondModel & 85.7 & 72.4 & \textbf{85.1} \\ 
& ThirdModel & \textbf{83.4} & \textbf{73.1} & \textbf{82.3} \\ 
\hline \multirow{3}{4em}{[9, 4, 0.5]} & FirstModel & 82.8 & 29.5 & 83.0 \\ 
& SecondModel & 65.7 & 26.7 & 83.3 \\ 
& ThirdModel & 81.9 & 71.3 & 81.9 \\ 
\hline \multirow{3}{4em}{[9, 4, 0.9]} & FirstModel & 75.4 & 30.1 & 82.3 \\ 
& SecondModel & 42.9 & 26.3 & 82.7 \\ 
& ThirdModel & 80.3 & 70.7 & 81.3 \\ 
\specialrule{.1em}{.05em}{.05em} \end{tabular}
\label{table:nonlin} \end{table}
\end{comment}



\begin{comment}
\begin{figure}[h]
    \centering
    \fbox{\includegraphics[width=0.45\textwidth]{images/cut-off_plots/ARMA-Dense.png}}
    \fbox{\includegraphics[width=0.45\textwidth]{images/cut-off_plots/ARMA-DenseATT.png}}
    \fbox{\includegraphics[width=0.45\textwidth]{images/cut-off_plots/ARMA-ATT.png}}
    \caption{Accuracy fluctuation for each cut-off values on Cora, Citeseer, and Pubmed datasets for ARMA-Dense, ARMA-DenseATT, and ARMA-ATT models.}
    \label{fig:coraEmbeddings}
\end{figure}
\end{comment}

\subsection{Comparison under Different Polynomial Orders} \label{subsec:other-hyperparameters}

\begin{comment}
\begin{wrapfigure}[12]{r}{0.5\textwidth}
\vspace{-0.3cm}
\centering\vspace{-0.2cm}
\includegraphics[width=0.5\textwidth]{images/polynomial_orders_plot/poly_v1.png}
\caption{Accuracy (\%) of DFNet under different polynomial orders  and .
    \label{fig:polynomialPlots}}
\end{wrapfigure}
\end{comment}

In order to test how the polynomial orders  and  influence the performance of our model DFNet, we conduct experiments to evaluate DFNet on three citation network datasets using different polynomial orders  and .
    Figure \ref{fig:polynomialPlots} presents the experimental results. In our experiments,  and  turn out to be the best parameters for DFNet over these datasets. In other words, this means that feedback-looped filters are more stable on  and  than other values of  and . This is because, when  and , Eq.~\ref{equ:arma-filter-optimizer} can obtain better convergence for finding optimal coefficients than in the other cases. Furthermore, we observe that: (1) Setting  to be too low or too high can both lead to poor performance, as shown in Figure \ref{fig:polynomialPlots}.(a), and (2) when  is larger than , the accuracy decreases rapidly as shown in Figure \ref{fig:polynomialPlots}.(b). Thus, when choosing  and , we require that  holds.

\begin{figure}[!h]
\vspace{-0.3cm}
\centering
\includegraphics[width=0.7\textwidth]{images/polynomial_orders_plot/poly_v1.png}
\caption{Accuracy (\%) of DFNet under different polynomial orders  and .}
    \label{fig:polynomialPlots}
\end{figure}

\subsection{Evaluation of Scaled-Normalization and Cut-off Frequency}
\begin{comment}
\begin{wraptable}{r}{0.45\textwidth}
\resizebox{0.45\columnwidth}{!}{\begin{tabular}{|c| l| c c c|} 
\specialrule{.1em}{.05em}{.05em} 
Case & Model & Cora & Citeseer & Pubmed \\ [0.5ex] 
\hline 
\multirow{3}{*}{1} & DFNet & \textbf{85.2} & \textbf{74.2} & \textbf{84.3} \\ 
& DFNet-ATT & \textbf{86.0} & \textbf{74.7} & \textbf{85.2} \\ 
& DF-ATT & \textbf{83.4} & \textbf{73.1} & \textbf{82.3} \\ 
\hline 
\multirow{3}{*}{2} & DFNet & 46.6 & 33.2 & 82.8 \\ 
& DFNet-ATT & 45.1 & 47.2 & 81.1 \\ 
& DF-ATT & 73.9 & 58.5 & 71.8 \\ 
\hline 
\multirow{3}{*}{3} & DFNet & 35.6 & 28.7 & 70.2 \\ 
& DFNet-ATT & 30.9 & 25.3 & 82.4 \\ 
& DF-ATT & 76.3 & 66.5 & 81.3 \\ 
\specialrule{.1em}{.05em}{.05em}
\end{tabular}}\caption{Accuracy (\%) of our models in three cases: (1) using both scaled-normalization and cutoff frequency, (2) not using scaled-normalization, and (3) not using cutoff frequency.  \label{Tab:normalization-cutoff}}
\end{wraptable}
\end{comment}
To understand how effectively the scaled-normalisation and cut-off frequency techniques can help learn graph representations, we compare our methods that implement these techniques with the variants of our methods that only implement one of these techniques. The results are presented in Figure \ref{fig:evalParams}. We can see that, the models using these two techniques outperform the models that only use one of these techniques over all citation network datasets. Particularly, the improvement is significant on the Cora and Citeseer datasets.


\begin{comment}
\begin{table}[ht]
\centering \begin{tabular}{l l c c c} \specialrule{.1em}{.05em}{.05em} Description & Model & Cora & Citeseer & Pubmed \\ [0.5ex] \hline \multirow{3}{12em}{Scaled-normalization} & DFNet & \textbf{85.2} & \textbf{74.2} & \textbf{84.3} \\ 
& DFNet-ATT & \textbf{86.0} & \textbf{74.7} & \textbf{85.2} \\ 
& DF-ATT & \textbf{83.4} & \textbf{73.1} & \textbf{82.3} \\ 
\hline \multirow{3}{12em}{Laplacian without scaled-normalize technique} & DFNet & 46.6 & 33.2 & 82.8 \\ 
& DFNet-ATT & 45.1 & 47.2 & 81.1 \\ 
& DF-ATT & 73.9 & 58.5 & 71.8 \\ 
\hline \multirow{3}{12em}{Without \smallskip
\noindent\textbf{Laplacian without cut-off frequency technique}} & DFNet & 53.7 & 35.1 & 70.2 \\ 
& DFNet-ATT & 50.9 & 40.2 & 82.4 \\ 
& DF-ATT & 75.4 & 66.5 & 81.3 \\ 
\specialrule{.1em}{.05em}{.05em} \end{tabular}
\label{table:nonlin} \end{table}
\end{comment}

\begin{figure}[t!]
    \vspace{-0.5cm}\centering
    \includegraphics[width=1\textwidth]{images/evaluation_all_parameters.png}
    \caption{Accuracy (\%) of our models in three cases: (1) using both scaled-normalization and cut-off frequency, (2) using only cut-off frequency, and (3) using only scaled-normalization.  
    \label{fig:evalParams}}\vspace{-0.3cm}
\end{figure}

\subsection{Node Embeddings}
We analyze the node embeddings by DFNets over two datasets: Cora and Pubmed in a 2-D space. Figures \ref{fig:pubmedEmbeddings} and \ref{fig:coraEmbeddings} display the visualization of the learned 2-D embeddings of GCN, GAT, and DFNet (ours) on Pubmed and Cora citation networks by applying t-SNE \cite{maaten2008visualizing} respectively.
Colors denote different classes in these datasets. It reveals the clustering quality of theses models. These figures clearly show that our model DFNet has better separated 3 and 7 clusters respectively in the embedding spaces of Pubmed and Cora datasets. This is because features extracted by DFNet yield better node representations than GCN and GAT models.

\begin{comment}
\begin{figure}[h]
    \centering
    \fbox{\includegraphics[width=0.30\textwidth]{images/embeddings/pubmed/GCN_hidden_embeddings.png}}
    \fbox{\includegraphics[width=0.30\textwidth]{images/embeddings/pubmed/GAT_hidden_embeddings.png}}
    \fbox{\includegraphics[width=0.30\textwidth]{images/embeddings/pubmed/ARMA_hidden_embeddings.png}}
    \caption{The t-SNE visualization of the 2-D node embedding space for the Pubmed dataset in GCN, GAT, and Our method.}
    \label{fig:pubmedEmbeddings}
\end{figure}
\end{comment}

\begin{figure}[h]
  \centering\vspace{-0.2cm}
  \begin{subfigure}[b]{0.32\linewidth}
    \fbox{\includegraphics[width=0.95\textwidth]{images/embeddings/pubmed/GCN_hidden_embeddings.png}}
    \caption{GCN}
  \end{subfigure} 
  \begin{subfigure}[b]{0.32\linewidth}
   \fbox{\includegraphics[width=0.95\textwidth]{images/embeddings/pubmed/GAT_hidden_embeddings.png}}
    \caption{GAT}
  \end{subfigure}
  \begin{subfigure}[b]{0.32\linewidth}
   \fbox{\includegraphics[width=0.95\textwidth]{images/embeddings/pubmed/ARMA_hidden_embeddings.png}}
    \caption{DFNet (ours)}
  \end{subfigure}
  \caption{The t-SNE visualization of the 2-D node embedding space for the Pubmed dataset.}
  \label{fig:pubmedEmbeddings}
  \centering
  \begin{subfigure}[b]{0.32\linewidth}
    \fbox{\includegraphics[width=0.95\textwidth]{images/embeddings/cora/GCN_hidden_embeddings.png}} 
    \caption{GCN}
  \end{subfigure} 
  \begin{subfigure}[b]{0.32\linewidth}
   \fbox{\includegraphics[width=0.95\textwidth]{images/embeddings/cora/GAT_hidden_embeddings.png}}
    \caption{GAT}
  \end{subfigure}
  \begin{subfigure}[b]{0.32\linewidth}
   \fbox{\includegraphics[width=0.95\textwidth]{images/embeddings/cora/ARMA_hidden_embeddings.png}} 
    \caption{DFNet (ours)}
  \end{subfigure}
  \caption{The t-SNE visualization of the 2-D node embedding space for the Cora dataset.}
  \label{fig:coraEmbeddings}
\end{figure}

\begin{comment}
\begin{figure}[h]
    \centering
    \fbox{\includegraphics[width=0.30\textwidth]{images/embeddings/cora/GCN_hidden_embeddings.png}} 
    \fbox{\includegraphics[width=0.30\textwidth]{images/embeddings/cora/GAT_hidden_embeddings.png}}
    \fbox{\includegraphics[width=0.30\textwidth]{images/embeddings/cora/ARMA_hidden_embeddings.png}} 
    \caption{The t-SNE visualization of the 2-D node embedding space for the Cora dataset in GCN, GAT, and Our method.}
    \label{fig:coraEmbeddings}
\end{figure}
\end{comment}









 \vspace{-0.3cm}
\section{Conclusions}\vspace{-0.3cm}\label{sec:conclusions}
In this paper, we have introduced a spectral CNN architecture (DFNets) with feedback-looped filters on graphs. To improve approximation accuracy, we have developed two techniques: scaled normalization and cut-off frequency. In addition to these, we have discussed some nice properties of feedback-looped filters, such as guaranteed convergence, linear convergence time, and universal design. Our proposed model outperforms the state-of-the-art approaches significantly in two benchmark tasks. In future, we plan to extend the current work to time-varying graph structures. As discussed in \cite{isufi2017autoregressive1}, feedback-looped graph filters are practically appealing for time-varying settings, and similar to static graphs, some nice properties would likely hold for graphs that are a function of time.







 

\newpage
\bibliographystyle{abbrv}
\bibliography{references}

\newpage
\section*{Appendices}

In the following, we provide further experiments on comparing our work with the others. 

\medskip
\noindent\textbf{Comparison with different spectral graph filters. }We have conducted an ablation study of our proposed graph filters. Specifically, we compare our feedback-looped filters, i.e., the newly proposed spectral filters in this paper, against other spectral filters such as Chebyshev filters and Cayley filters. To conduct this ablation study, we remove the dense connections from our model DFNet. The experimental results are presented in table \ref{table:table2}. It shows that feedback-looped filters improve localization upon Chebyshev filters by a margin of 1.4\%, 1.7\% and 7.3\% on the datasets Cora, Citeseer and Pubmed, respectively. It also improves upon Cayley filters by a margin of 0.7\% on the Cora dataset.

\begin{table}[!h]
\centering
\begin{tabular}{l c c c } \specialrule{.1em}{.05em}{.05em} Model & Cora & Citeseer & Pubmed \\ [0.5ex] \hline {Chebyshev filters} \cite{defferrard2016convolutional} & 81.2 & 69.8 & 74.4  \\ 
{Cayley filters} \cite{levie2017cayleynets}& 81.9 & - & -  \\ 
Feedback-looped filters (ours) & \textbf{82.6}  \textbf{0.3} & \textbf{71.5}  \textbf{0.4} & \textbf{81.7}  \textbf{0.6} \\
\specialrule{.1em}{.05em}{.05em} \end{tabular}\caption{Accuracy (\%) averaged over 10 runs.}
\label{table:table2} \end{table}\vspace{-0.2cm}

\noindent\textbf{Comparison with LNet and AdaLNet using different data splittings. }
We have benchmarked the performance of our DFNet model against the models LNet and AdaLNet proposed in \cite{liao2019lanczosnet}, as well as Chebyshev, GCN and GAT, over three citation network datasets Cora, Citeseer and Pubmed. We use the same data splittings as used in \cite{liao2019lanczosnet}. All the experiments are repeated 10 times. For our model DFNet, we use the same hyperparameter settings as discussed in Section 4.2. 




\begin{table}[!h]
\centering
\begin{tabular}{l c c c c c c}
\specialrule{.1em}{.05em}{.05em} Training Split & Chebyshev & GCN & GAT & LNet & AdaLNet & DFNet\\ [0.5ex] \hline 5.2\% (standard) & 78.0  1.2 & 80.5  0.8 & 82.6  0.7 & 79.5  1.8 & 80.4  1.1 & \textbf{85.2}  \textbf{0.5}\\ 
3\%  & 62.1  6.7 & 74.0  2.8 & 56.8  7.9 & 76.3  2.3 & 77.7  2.4 & \textbf{80.5}  \textbf{0.4}\\ 
1\%  & 44.2  5.6 & 61.0  7.2 & 48.6  8.0 & 66.1  8.2 & 67.5  8.7 & \textbf{69.5}  \textbf{2.3}\\ 
0.5\%  & 33.9  5.0 & 52.9  7.4 & 41.4  6.9 & 58.1  8.2 & 60.8  9.0 & \textbf{61.3}  \textbf{4.3}\\ 
\specialrule{.1em}{.05em}{.05em} \end{tabular}\caption{Accuracy (\%) averaged over 10 runs on the Cora dataset.}
\label{lanczos-cora}
\end{table}
\vspace*{-0.3cm}
\begin{table}[!h]
\centering
\begin{tabular}{l c c c c c c}
\specialrule{.1em}{.05em}{.05em} Training Split & Chebyshev & GCN & GAT & LNet & AdaLNet & DFNet\\ [0.5ex] \hline 3.6\% (standard) & 70.1  0.8 & 68.1  1.3 & 72.2  0.9 & 66.2  1.9 & 68.7  1.0 & \textbf{74.2}  \textbf{0.3}\\ 1\%  & 59.4  5.4 & 58.3  4.0 & 46.5  9.3 & 61.3  3.9 & 63.3  1.8 & \textbf{67.4}  \textbf{2.3}\\ 
0.5\%  & 45.3  6.6 & 47.7  4.4 & 38.2  7.1 & 53.2  4.0 & 53.8  4.7 & \textbf{55.1}  \textbf{3.2}\\ 
0.3\%  & 39.3  4.9 & 39.2  6.3 & 30.9  6.9 & 44.4  4.5 & 46.7  5.6 & \textbf{48.3}  \textbf{3.5}\\ 
\specialrule{.1em}{.05em}{.05em} \end{tabular}
\caption{Accuracy (\%) averaged over 10 runs on the Citeseer dataset.}\label{lanczos-citeseer}
\end{table}
\vspace*{-0.35cm}
\begin{table}[!h]
\centering
\begin{tabular}{l c c c c c c}
\specialrule{.1em}{.05em}{.05em} Training Split & Chebyshev & GCN & GAT & LNet & AdaLNet & DFNet\\ [0.5ex] \hline 0.3\% (standard) & 69.8  1.1 & 77.8  0.7 & 76.7  0.5 & 78.3  0.3 & 78.1  0.4 & \textbf{84.3}  \textbf{0.4}\\ 0.1\% & 55.2  6.8 & 73.0  5.5 & 59.6  9.5 & 73.4  5.1 & 72.8  4.6 & \textbf{75.2}  \textbf{3.6}\\ 
0.05\%  & 48.2  7.4 & 64.6  7.5 & 50.4  9.7 & 68.8  5.6 & 66.0  4.5 & \textbf{67.2}  \textbf{7.3}\\ 
0.03\% & 45.3  4.5 & 57.9  8.1 & 50.9  8.8 & 60.4  8.6 & \textbf{61.0}  \textbf{8.7} & 59.3  6.6\\ 
\specialrule{.1em}{.05em}{.05em} \end{tabular}
\caption{Accuracy (\%) averaged over 10 runs on the Pubmed dataset.}\label{lanczos-pubmed}\vspace{-0.3cm}
\end{table}

Tables \ref{lanczos-cora}-\ref{lanczos-pubmed} present the experimental results. Table \ref{lanczos-cora} shows that DFNet performs significantly better than all the other models over the Cora dataset, including LNet and AdaLNet proposed in \cite{liao2019lanczosnet}. Similarly, Table \ref{lanczos-citeseer} shows that DFNet performs significantly better than all the other models over the Citeseer dataset. For the Pubmed dataset, as shown in Table \ref{lanczos-pubmed}, DFNet performs significantly better than almost all the other models, except for only one case in which DFNet performs slightly worse than AdaLNet using the splitting 0.03\%. These results demonstrate the robustness of our model DFNet.


 
\end{document}
