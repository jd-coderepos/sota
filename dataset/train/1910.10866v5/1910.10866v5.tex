\pdfoutput=1

\documentclass{article}







\usepackage[final,nonatbib]{neurips_2019}



\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      

\usepackage{graphicx}
\usepackage{comment}
\usepackage{multirow}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{subcaption}
\captionsetup{compatibility=false}
\newcommand*{\q}[1]{\textcolor{red}{#1}}
\newcommand*{\A}[1]{\textcolor{blue}{#1}} 
\usepackage{wrapfig}
\usepackage{array}
\usepackage{ragged2e}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\title{DFNets: Spectral CNNs for Graphs with Feedback-Looped Filters}



\author{Asiri ~Wijesinghe\\ Research School of Computer Science\\
  The Australian National University\\
  \texttt{asiri.wijesinghe@anu.edu.au} \\
  \And
  Qing ~Wang \\
  Research School of Computer Science\\
  The Australian National University\\
  \texttt{qing.wang@anu.edu.au} \\
}



\begin{document}


\maketitle

\begin{abstract}
We propose a novel spectral convolutional neural network (CNN) model on graph structured data, namely \emph{Distributed Feedback-Looped Networks} (DFNets). This model is incorporated with a robust class of spectral graph filters, called \emph{feedback-looped filters}, to provide better localization on vertices, while still attaining fast convergence and linear memory requirements. Theoretically, feedback-looped filters can guarantee convergence w.r.t. a specified error bound, and be applied universally to any graph without knowing its structure. Furthermore, the propagation rule of this model can diversify features from the preceding layers to produce strong gradient flows. We have evaluated our model using two benchmark tasks: semi-supervised document classification on citation networks and semi-supervised entity classification on a knowledge graph. The experimental results show that our model considerably outperforms the state-of-the-art methods in both benchmark tasks over all datasets.
\end{abstract}



\section{Introduction}
\vspace{-0.2cm}
Convolutional neural networks (CNNs) \cite{krizhevsky2012imagenet} are a powerful deep learning approach which has been widely applied in various fields, e.g., object recognition \cite{sharif2014cnn}, image classification \cite{hu2015deep}, and semantic segmentation \cite{li2017fully}. Traditionally, CNNs only deal with data that has a regular Euclidean structure, such as images, videos and text. In recent years, due to the rising trends in network analysis and prediction, generalizing CNNs to graphs has attracted considerable interest \cite{bruna2013spectral,defferrard2016convolutional,hamilton2017inductive,perozzi2014deepwalk}. However, since graphs are in irregular non-Euclidean domains, this brings
up the challenge of how to enhance CNNs for effectively extracting useful features (e.g. topological structure) from arbitrary graphs.

To address this challenge, a number of studies have been devoted to enhancing CNNs by developing filters over graphs. In general, there are two categories of graph filters: (a) spatial graph filters, and (b) spectral graph filters. Spatial graph filters are defined as convolutions directly on graphs, which consider neighbors that are spatially close to a current vertex \cite{atwood2016diffusion, duvenaud2015convolutional, hamilton2017inductive}. In contrast, spectral graph filters are convolutions indirectly defined on graphs, through their spectral representations \cite{bruna2013spectral,chung1997spectral,defferrard2016convolutional}. In this paper, we follow the line of previous studies in developing spectral graph filters and tackle the problem of designing an effective, yet efficient CNNs with spectral graph filters.

Previously, Bruna et al. \cite{bruna2013spectral} proposed convolution operations on graphs via a spectral decomposition of the graph Laplacian. To reduce learning complexity in the setting where the graph structure is not known a priori, Henaff et al. \cite{henaff2015deep} developed a spectral filter with smooth coefficients. Then, Defferrard et al. \cite{defferrard2016convolutional} introduced Chebyshev filters to stabilize convolution operations under coefficient perturbation and these filters can be exactly localized in k-hop neighborhood. Later, Kipf et al. \cite{kipf2016semi} proposed a simple layer-wise propagation model using Chebyshev filters on 1-hop neighborhood. Very recently, some works attempted to develop rational polynomial filters, such as Cayley filters \cite{levie2017cayleynets} and ARMA$_1$ \cite{bianchi2019graph}. From a different perspective, Petar et al. \cite{velivckovic2017graph} proposed a self-attention based CNN architecture for  graph filters, which extracts features by considering the importance of neighbors. 










\begin{figure}[t!]
    \centering
    \includegraphics[width=0.85\textwidth]{images/Architecture_Diagram2.pdf}
    \caption{A simplified example of illustrating feedback-looped filters, where $v_1$ is the current vertex and the similarity of the colours indicates the correlation between vertices, e.g., $v_1$ and $v_5$ are highly correlated, but $v_2$ and $v_6$ are less correlated with $v_1$: (a) an input graph, where $\lambda_i$ is the original frequency to vertex $v_i$; (b) the feedforward filtering, which attenuates some low order frequencies, e.g. $\lambda_2$, and amplify other frequencies, e.g. $\lambda_{5}$ and $\lambda_{6}$; (c) the feedback filtering, which reduces the error in the frequencies generated by (b), e.g. $\lambda_{6}$. \label{fig:firstModel}}\vspace{-0.2cm}
\end{figure}
One key idea behind existing works on designing spectral graph filters is to approximate the frequency responses of graph filters using a polynomial function (e.g. Chebyshev filters \cite{defferrard2016convolutional}) or a rational polynomial function (e.g. Cayley filters \cite{levie2017cayleynets} and ARMA$_1$ \cite{bianchi2019graph}). Polynomial filters are sensitive to changes in the underlying graph structure. They are also very smooth and can hardly model sharp changes, as illustrated in Figure \ref{fig:firstModel}. Rational polynomial filters are more powerful to model localization, but they often have to trade off computational efficiency, resulting in higher learning and computational complexities, as well as instability. 
 
\smallskip
\noindent\textbf{Contributions. }In this work, we aim to develop a new class of spectral graph filters that can overcome the above limitations. We also propose a spectral CNN architecture (i.e. DFNet) to incorporate these graph filters. In summary, our contributions are as follows: \begin{itemize}
\item \textbf{Improved localization. }A new class of spectral graph filters, called \emph{feedback-looped filters}, is proposed to enable better localization, due to its rational polynomial form. Basically, feedback-looped filters consist of two parts: \emph{feedforward} and \emph{feedback}. The feedforward filtering is k-localized as polynomial filters, while the feedback filtering is unique which refines k-localized features captured by the feedforward filtering to improve approximation accuracy. We also propose two techniques: \emph{scaled-normalization} and \emph{cut-off frequency} to avoid the issues of gradient vanishing/exploding and instabilities. 

\item \textbf{Efficient computation. }For feedback-looped filters, we avoid the matrix inversion implied by the denominator through approximating the matrix inversion with a recursion. Thus, benefited from this approximation, feedback-looped filters attain linear convergence time and linear memory requirements w.r.t. the number of edges in a graph.

\item \textbf{Theoretical properties. }Feedback-looped filters enjoy several nice theoretical properties. Unlike other rational polynomial filters for graphs, they have theoretically guaranteed convergence w.r.t. a specified error bound. On the other hand, they still have the universal property as other spectral graph filters \cite{isufi2017autoregressive1}, i.e., can be applied without knowing the underlying structure of a graph. The optimal coefficients of feedback-looped filters are learnable via an optimization condition for any given graph.

\item \textbf{Dense architecture. }We propose a layer-wise propagation rule for our spectral CNN model with feedback-looped filters, which densely connects layers as in DenseNet \cite{huang2017densely}. This design enables our model to diversify features from all preceding layers, leading to a strong gradient flow. We also introduce a layer-wise regularization term to alleviate the overfitting issue. In doing so, we can prevent the generation of spurious features and thus improve accuracy of the prediction.
\end{itemize}
To empirically verify the effectiveness of our work, we have evaluated feedback-looped filters within three different CNN architectures over four benchmark datasets to compare against the state-of-the-art methods. The experimental results show that our models significantly outperform the state-of-the-art methods. We further demonstrate the effectiveness of our model DFNet through the node embeddings in a 2-D space of vertices from two datasets.
 \section{Spectral Convolution on Graphs}
\label{sec:sepectral-filters}\vspace{-0.2cm}
Let $G = (V, E, A)$ be an undirected and weighted graph, where $V$ is a set of vertices, $E\subseteq V\times V$ is  a set of edges, and $A \in \mathbb{R}^{n\times n}$ is an adjacency matrix which encodes the weights of edges. We let $n=|V| $ and $m=|E|$. A \emph{graph signal} is a function $x: V\rightarrow \mathbb{R}$ and can be represented as a vector $x \in \mathbb{R}^{n}$ whose $i^{th}$ component $x_i$ is the value of $x$ at the $i^{th}$ vertex in $V$.  The graph Laplacian is defined as $L=I-D^{-1/2} AD^{-1/2}$, where $D \in \mathbb{R}^{n\times n}$ is a diagonal matrix with $D_{ii}=\sum_{j}A_{ij}$ and $I$ is an identity matrix. $L$ has a set of orthogonal eigenvectors $\left\{{u_i}\right\}_{i=0}^{n-1} \in \mathbb{R}^{n}$, known as the \emph{graph Fourier basis}, and non-negative eigenvalues $\left\{{\lambda_i}\right\}_{i=0}^{n-1}$, known as the \emph{graph frequencies} \cite{chung1997spectral}. 
$L$ is diagonalizable by the eigendecomposition such that $L=U\Lambda U^{H}$, where $\Lambda=diag\left(\left[\lambda_0,\dots,\lambda_{n-1}\right]\right) \in \mathbb{R}^{n\times n}$ and $U^H$ is a hermitian transpose of $U$. We use $\lambda_{min}$ and $\lambda_{max}$ to denote the smallest and largest eigenvalues of $L$, respectively.


Given a graph signal $x$, the \emph{graph Fourier transform} of $x$ is $\hat{x}=U^Hx \in \mathbb{R}^{n}$ and its inverse is $x=U\hat{x}$ \cite{sandryhaila2013discrete,shuman2013emerging}. The graph Fourier transform enables us to apply graph filters in the vertex domain. A \emph{graph filter} $h$ can filter $x$ by altering (amplifying or attenuating) the graph frequencies as 
\begin{equation} \label{equ:graph-filter}
h (L)x = h (U\Lambda U^H) x = U h (\Lambda) U^H x = U h (\Lambda) \hat{x}.
\end{equation}
Here, $h (\Lambda)=diag([h(\lambda_0), \dots, h (\lambda_{n-1})])$, which controls how the frequency of each component in a graph signal $x$ is modified. However, applying graph filtering as in Eq. \ref{equ:graph-filter} requires the eigendecomposition of $L$, which is computationally expensive. To address this issue, several works \cite{bianchi2019graph, defferrard2016convolutional,hammond2011wavelets,kipf2016semi,levie2017cayleynets,liao2019lanczosnet} have studied the approximation of $h(\Lambda)$ by a polynomial or rational polynomial function. 



\smallskip
\textbf{Chebyshev filters.   } Hammond et al. \cite{hammond2011wavelets} first proposed to approximate $h (\lambda)$ by  a polynomial function with $k^{th}$-order polynomials and Chebyshev coefficients. Later, Defferrard et al. \cite{defferrard2016convolutional} developed Chebyshev filters for spectral CNNs on graphs. A Chebyshev filter is defined as
\begin{equation}
h_\theta (\tilde{\lambda})=\sum_{j=0}^{k-1} \theta_j T_j(\tilde{\lambda}),
\end{equation}
where $\theta\in\mathbb{R}^{k}$ is a vector of learnable Chebyshev coefficients, $\tilde{\lambda}\in [-1,1]$ is rescaled from $\lambda$, the Chebyshev polynomials $T_j(\lambda)=2\lambda T_{j-1}(\lambda)-T_{j-2}(\lambda)$ are recursively defined with $T_0(\lambda)=1$ and $T_1(\lambda)=\lambda$, and $k$ controls the size of filters, i.e., localized in k-hop neighborhood of a vertex \cite{hammond2011wavelets}. Kipf and Welling \cite{kipf2016semi} simplified Chebyshev filters by restricting to 1-hop neighborhood.




\smallskip
\textbf{Lanczos filters. } Recently, Liao et al. \cite{liao2019lanczosnet} used the Lanczos algorithm to generate a low-rank matrix approximation $T$ for the graph Laplacian. They used the affinity matrix $S=D^{-1/2}AD^{-1/2}$. Since $L=I-S$ holds, $L$ and $S$ share the same eigenvectors but have different eigenvalues. As a result, $L$ and $S$ correspond to the same $\hat{x}$. To approximate the eigenvectors and eigenvalues of $S$, they diagonalize the tri-diagonal matrix $T \in \mathbb{R}^{m\times m}$ to compute Ritz-vectors $V \in \mathbb{R}^{n\times m}$ and Ritz-values $R \in \mathbb{R}^{m\times m}$, and thus $S \approx VRV^T$. Accordingly, a k-hop Lanczos filter operation is,
\begin{equation}
h_{\theta}(R) = \sum_{j=0}^{k-1}\theta_jR^j,
\end{equation}

where $\theta \in \mathbb{R}^{k}$ is a vector of learnable Lanczos filter coefficients. Thus, spectral convolutional operation is defined as $h_{\theta}(S)x \approx Vh_{\theta}(R)V^Tx$. Such Lanczos filter operations can significantly reduce computation overhead when approximating large powers of $S$, i.e. $S^k \approx VR^kV^T$. Thus, they can efficiently compute the spectral graph convolution with a very large localization range to easily capture the multi-scale information of the graph.














\smallskip
\textbf{Cayley filters.  } Observing that Chebyshev filters have difficulty in detecting narrow frequency bands due to $\tilde{\lambda}\in [-1,1]$, Levie et al. \cite{levie2017cayleynets} proposed Cayley filters, based on Cayley polynomials:
\begin{equation} 
h_{\theta,s}(\lambda)=\theta_0+2Re(\sum_{j=1}^{k-1} \theta_j(s\lambda -i)^j(s\lambda+i)^{-j}),
\end{equation} 
where $\theta_0\in\mathbb{R}$ is a real coefficient and $(\theta_1,\dots, \theta_{k-1})\in\mathbb{C}^{k-1}$ is a vector of complex coefficients. $Re(x)$ denotes the real part of a complex number $x$, and $s>0$ is a parameter called \emph{spectral zoom}, which controls the degree of ``zooming'' into eigenvalues in $\Lambda$. Both $\theta$ and $s$ are learnable during training. To improve efficiency, the Jacobi method is used to approximately compute Cayley polynomials. 

\smallskip
\textbf{ARMA$_1$ filters. } Bianchi et al. \cite{bianchi2019graph} sought to address similar issues as identified in \cite{levie2017cayleynets}. However, different from Cayley filters, they developed a first-order ARMA filter, which is approximated by a first-order recursion:
\begin{equation}
\bar{x}^{(t+1)} = a \tilde{L} \bar{x}^{(t)} + b x,
\end{equation}
where $a$ and $b$ are the filter coefficients, $\bar{x}^{(0)} = x$, and $\tilde{L}= (\lambda_{max} - \lambda_{min}) / 2I - L$. Accordingly, the frequency response is defined as:
\begin{equation}
h(\tilde{\lambda}) = \frac{r}{\tilde{\lambda} - p},
\end{equation}
where $\tilde{\lambda} = (\lambda_{max} - \lambda_{min}) / 2 \lambda$, $r = -b/a$, and $p = 1/a$ \cite{isufi2017autoregressive1}. Multiple ARMA$_1$ filters can be applied in parallel to obtain a ARMA$_k$ filter. However, the memory complexity of $k$ parallel ARMA$_1$ filters is $k$ times higher than ARMA$_1$ graph filters. \begin{comment}
\begin{equation}
\bar{X} = \sum_{k=1}^{K} \bar{X}^{k} = \sum_{k=1}^{K} \sum_{m=1}^{M} \frac{r_{k}}{\mu_{m} + p_{k}} u_{m} u_{m}^{T} x_{m},
\end{equation}
where $\sum_{m=1}^{M} h(\mu_{m}) u_{m} u_{m}^{T}$ denotes the spectral decomposition of $L$.
\end{comment}






\smallskip


We make some remarks on how these existing spectral filters are related to each other. (i) As discussed in \cite{bianchi2019graph,levie2017cayleynets, liao2019lanczosnet}, polynomial filters (e.g. Chebyshev and Lanczos filters) can be approximately treated as a special kind of rational polynomial filters. (ii) Further, Chebyshev filters can be regarded as a special case of Lanczos filters. (iii) Although both Cayley and ARMA$_k$ filters are rational polynomial filters, they differ in how they approximate the matrix inverse implied by the denominator of a rational function. Cayley filters use a fixed number of Jacobi iterations, while ARMA$_k$ filters use a first-order recursion plus a parallel bank of $k$ ARMA$_1$.
 (iv) ARMA$_1$ by Bianchi et al. \cite{bianchi2019graph} is similar to GCN by Kipf et al. \cite{kipf2016semi} because they both consider localization within 1-hop neighborhood. 



 
\section{Proposed Method}
\label{sec:others}\vspace{-0.2cm}
We introduce a new class of spectral graph filters, called \emph{feedback-looped filters}, and propose a spectral CNN for graphs with feedback-looped filters, namely \emph{Distributed Feedback-Looped Networks} (DFNets). We also discuss optimization techniques and analyze theoretical properties. 


\subsection{Feedback-Looped Filters}\label{subsec:filters}
Feedback-looped filters belong to a class of Auto Regressive Moving Average (ARMA) filters \cite{isufi2017autoregressive2,isufi2017autoregressive1}.
Formally, an ARMA filter is defined as:
\begin{equation}\label{equ:arma-filter-L}
h_{\psi,\phi}(L)x=\Big(I+\sum_{j=1}^{p} \psi_j L^j \Big)^{-1} \Big(\sum_{j=0}^q \phi_j L^j\Big)x.
\end{equation}
\begin{comment}
\begin{equation}\label{equ:arma-filter-lambda}
h_{\psi, \phi}(\lambda)=\frac{h_{\phi}(\lambda)}{h_{\psi}(\lambda)}=\frac{\sum_{j=0}^{q} \phi_j  \lambda^j}{1+\sum_{j=1}^{p} \psi_j \lambda^j}.
\end{equation}
\end{comment}
The parameters $p$  and $q$ refer to the \emph{feedback} and \emph{feedforward} degrees, respectively. $\psi\in \mathbb{C}^p$ and $\phi\in \mathbb{C}^{q+1}$ are two vectors of complex coefficients. 
Computing the denominator of Eq. \ref{equ:arma-filter-L} however requires a matrix inversion, which is computationally inefficient for large graphs. To circumvent this issue, \emph{feedback-looped filters} use the following approximation: \begin{equation}\label{equ:feedback-looped}
\bar{x}^{(0)}=x \text{  and  }\bar{x}^{(t)}=-\sum_{j=1}^{p}\psi_j\tilde{L}^j \bar{x}^{(t-1)} + \sum_{j=0}^{q} \phi_j \tilde{L}^j x, 
\end{equation}
where $\tilde{L}=\hat{L} - (\frac{\hat{\lambda}_{max}}{2})I$, $\hat{L}=I - \hat{D}^{-1/2} \hat{A} \hat{D}^{-1/2}$, $\hat{A}=A+I$, $\hat{D}_{ii}=\sum_{j} \hat{A}_{ij}$ and $\hat{\lambda}_{max}$ is the largest eigenvalue of $\hat{L}$. Accordingly, the frequency response of feedback-looped filters is defined as:
\begin{equation}\label{equ:arma-filter-lambda2}
h(\lambda_i)=\frac{\sum_{j=0}^{q} \phi_j  \lambda_i^j}{1+\sum_{j=1}^{p} \psi_j \lambda_i^j}.
\end{equation}
To alleviate the issues of gradient vanishing/exploding and numerical instabilities, we further introduce two techniques in the design of feedback-looped filters: \emph{scaled-normalization} and \emph{cut-off frequency}. 

\noindent\textbf{Scaled-normalization technique. } To assure the stability of feedback-looped filters, we apply the scaled-normalization technique to increasing the stability region, i.e., using the scaled-normalized Laplacian $\tilde{L}=\hat{L} - (\frac{\hat{\lambda}_{max}}{2})I$, rather than just $\hat{L}$. This accordingly helps centralize the eigenvalues of the Laplacian $\hat{L}$ and reduce its spectral radius bound. The scaled-normalized Laplacian $\tilde{L}$ consists of graph frequencies within $[0, 2]$, in which eigenvalues are ordered in an increasing order. 









\smallskip
\noindent\textbf{Cut-off frequency technique. } To map graph frequencies within $[0, 2]$ to a uniform discrete distribution, we define a \emph{cut-off frequency} $\lambda_{cut}=(\frac{\lambda_{max}}{2} - \eta)$, where $\eta\in[0,1]$ and $\lambda_{max}$ refers to the largest eigenvalue of $\tilde{L}$. The cut-off frequency is used as a threshold to control the amount of attenuation on graph frequencies. The eigenvalues $\{\lambda_i\}^{n-1}_{i=0}$ are converted to binary values $\{\tilde{\lambda}_i\}^{n-1}_{i=0}$ such that $\tilde{\lambda}_i=1$ if $\lambda_i \geq\lambda_{cut}$ and $\tilde{\lambda}_i=0$ otherwise. This trick allows the generation of ideal high-pass filters so as to sharpen a signal by amplifying its graph Fourier coefficients. This technique also solves the issue of narrow frequency bands existing in previous spectral filters, including both polynomial and rational polynomial filters \cite{defferrard2016convolutional, levie2017cayleynets}. This is because these previous spectral filters only accept a small band of frequencies. In contrast, our proposed feedback-looped filters resolve this issue using a cut-off frequency technique, i.e., amplifying frequencies higher than a certain low cut-off value while attenuating frequencies lower than that cut-off value. Thus, our proposed filters can accept a wider range of frequencies and capture better characteristic properties of a graph.

 



\subsection{Coefficient Optimisation}
Given a feedback-looped filter with a desired frequency response: $\hat{h}:\{\tilde{\lambda}_i\}^{n-1}_{i=0}\rightarrow \mathbb{R}$, we aim to find the optimal coefficients $\psi$ and $\phi$ that make the frequency response as close as possible to the desired frequency response, i.e. to minimize the following error:
\begin{equation}
\acute{e}(\tilde{\lambda}_i) = \hat{h}(\tilde{\lambda}_i) - \frac{\sum_{j=0}^{q} \phi_j  \tilde{\lambda}_i^j}{1+\sum_{j=1}^{p} \psi_j  \tilde{\lambda}_i^j}
\end{equation}
However, the above equation is not linear w.r.t. the coefficients $\psi$ and $\phi$. Thus, we redefine the error as follows:
\begin{equation}
e(\tilde{\lambda}_i) = \hat{h}(\tilde{\lambda}_i) + \hat{h}(\tilde{\lambda}_i) \sum_{j=1}^{p} \psi_j  \tilde{\lambda}_i^j - \sum_{j=0}^{q} \phi_j  \tilde{\lambda}_i^j.
\end{equation}
Let $e=[e(\tilde{\lambda}_0),\dots,e(\tilde{\lambda}_{n-1})]^T$, $\hat{h}=[\hat{h}(\tilde{\lambda}_0),\dots,\hat{h}(\tilde{\lambda}_{n-1})]^T$, $\alpha\in \mathbb{R}^{n\times p}$ with $\alpha_{ij}=\tilde{\lambda}_i^j$ and $\beta\in \mathbb{R}^{n\times (q+1)}$ with $\beta_{ij}=\tilde{\lambda}_i^{j-1}$ are two Vandermonde-like matrices. Then, we have $e=\hat{h}+diag(\hat{h})\alpha\psi - \beta \phi$.
 Thus, the stable coefficients $\psi$  and $\phi$ can be learned by minimizing $e$ as a convex constrained least-squares optimization problem:
\begin{equation}\label{equ:arma-filter-optimizer}
{\text{\textbf{minimize}}}_{\psi,\phi}\;||\hat{h}+diag(\hat{h})\alpha\psi - \beta \phi||_2
\end{equation}
\[
	\text{\textbf{subject to}}\;\;||\alpha\psi||_\infty \le \gamma \text{ and }\gamma \textless 1
\]
Here, the parameter $\gamma$ controls the tradeoff between convergence efficiency and approximation accuracy. A higher value of $\gamma$ can lead to slower convergence but better accuracy. It is not recommended to have very low $\gamma$ values due to potentially unacceptable accuracy. $||\alpha\psi||_\infty \le \gamma \textless 1$ is the stability condition, which will be further discussed in detail in Section \ref{subsec:theoretical-properties}.





\subsection{Spectral Convolutional Layer} 


We propose a CNN-based architecture, called DFNets, which can stack multiple spectral convolutional layers with feedback-looped filters to extract features of increasing abstraction. Let $\mathbf{P}=-\sum_{j=1}^{p}\psi_j\tilde{L}^j$ and $\mathbf{Q}=\sum_{j=0}^{q} \phi_j \tilde{L}^j$. The propagation rule of a spectral convolutional layer is defined as:

\begin{equation}\label{equ:spectral-layer}
\bar{X}^{(t+1)}= \sigma(\bold{P}\bar{X}^{(t)}\theta_1^{(t)} + \bold{Q}X\theta_2^{(t)} + \mu (\theta_1^{(t)};\theta_2^{(t)}) + b),
\end{equation}

\noindent where $\sigma$ refers to a non-linear activation function such as $ReLU$. $\bar{X} ^{(0)}=X \in \mathbb{R}^{n\times f}$ is a graph signal matrix where $f$ refers to the number of features. $\bar{X}^{(t)}$ is a matrix of activations in the $t^{th}$ layer. $\theta_1^{(t)} \in \mathbb{R}^{c\times h}$ and $\theta_2^{(t)} \in \mathbb{R}^{f\times h}$ are two trainable weight matrices in the $t^{th}$ layer. To compute $\bar{X}^{(t+1)}$, a vertex needs access to its $p$-hop neighbors with the output signal of the previous layer $\bar{X}^{(t)}$, and its $q$-hop neighbors with the input signal from $X$. To attenuate the overfitting issue, we add $\mu (\theta_1^{(t)};\theta_2^{(t)})$, namely \emph{kernel regularization} \cite{cortes20092}, and a bias term $b$. We use the xavier normal initialization method \cite{glorot2010understanding} to initialise the kernel and bias weights, the unit-norm constraint technique \cite{douglas2000gradient} to normalise the kernel and bias weights by restricting parameters of all layers in a small range, and the kernel regularization technique to penalize the parameters in each layer during the training.  In doing so, we can prevent the generation of spurious features and thus improve the accuracy of prediction 
\footnote{DFNets implementation can be found at: \href{https://github.com/wokas36/DFNets} {https://github.com/wokas36/DFNets}}.

In this model, each layer is directly connected to all subsequent layers in a feed-forward manner, as in DenseNet \cite{huang2017densely}. Consequently, the $t^{th}$ layer receives all preceding feature maps $F_0, \dots, F_{t-1}$ as input. We concatenate multiple preceding feature maps column-wise into a single tensor to obtain more diversified features for boosting the accuracy. This densely connected CNN architecture has several compelling benefits: (a) reduce the vanishing-gradient issue, (b) increase feature propagation and reuse, and (c) refine information flow between layers  \cite{huang2017densely}. 

\begin{comment}
\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{images/first_model_v5.png}
    \caption{Densely connected spectral ARMA convnets architecture with 3 ARMA layers (8, 16, 32 nodes respectively) followed by a softmax layer.}
    \label{fig:firstModel}
\end{figure}
\end{comment}

\subsection{Theoretical Analysis}\label{subsec:theoretical-properties}
Feedback-looped filters have several nice properties, e.g., guaranteed convergence, linear convergence time, and universal design. We discuss these properties and analyze computational complexities.  

\noindent\textbf{Convergence. } Theoretically, a feedback-looped filter can achieve a desired frequency response only when $t\rightarrow \infty$ \cite{isufi2017autoregressive1}. However, due to the property of linear convergence preserved by feedback-looped filters, stability can be guaranteed after a number of iterations w.r.t. a specified small error \cite{isufi2017autoregressive2}. More specifically, since the pole of rational polynomial filters should be in the unit circle of the z-plane to guarantee the stability, we can derive the stability condition $||-\sum_{j=1}^{p} \psi_j L^j|| \textless 1$ by  Eq.~\ref{equ:arma-filter-L} in the vertex domain and correspondingly obtain the stability condition $||\alpha\psi||_\infty \le \gamma \in (0, 1)$ in the frequency domain as stipulated in Eq.~\ref{equ:arma-filter-optimizer} \cite{isufi2017autoregressive2}.








\noindent\textbf{Universal design. } 
The universal design is beneficial when the underlying structure of a graph is unknown or the topology of a graph changes over time. The corresponding filter coefficients can be learned independently of the underlying graph and are universally applicable. When designing feedback-looped filters, we define the desired frequency response function $\hat{h}$ over graph frequencies $\tilde{\lambda_i}$ in a binary format in the uniform discrete distribution as discussed in Section \ref{subsec:filters}. Then, we solve Eq.~\ref{equ:arma-filter-optimizer} in the least-squares sense for this finite set of graph frequencies to find optimal filter coefficients.






\begin{table}[h!]
\centering\vspace{-0cm}
\scalebox{1}{\begin{tabular}{| l|m{1.8cm}| c|c| c|}  \hline
   \multirow{2}{*}{Spectral Graph Filter} & \multirow{2}{*}{Type} & Learning & Time & Memory \\
    & &Complexity& Complexity& Complexity\\
   \hline
Chebyshev filters \cite{defferrard2016convolutional} & \multirow{2}{*}{Polynomial} & $O(k)$ & $O(km)$ & {$O (m)$} \\\cline{1-1}\cline{3-5}
    {Lanczos filters} \cite{liao2019lanczosnet} & & $O(k)$ & $O(km^2)$ & $O(m^2)$ \\\hline
    Cayley filters \cite{levie2017cayleynets} &\multirow{4}{\hsize}{Rational polynomial} & {$O((r+1)k)$} &{$O((r+1)km)$} &{$O (m)$} \\\cline{1-1}\cline{3-5}
   ARMA$_1$ filters \cite{bianchi2019graph} & &{$O (t)$} & {$O (tm)$} & {$O (m)$}\\\cline{1-1}\cline{3-5}
      $d$ parallel ARMA$_1$ filters \cite{bianchi2019graph} & &{$O (t)$} & {$O (tm)$} & {$O (dm)$}\\\cline{1-1}\cline{3-5}
   Feedback-looped filters (ours) & &{$O (tp + q)$} &{$O ((tp + q)m)$}  & {$O (m)$}\\
   \hline
 \end{tabular}}
 \caption{Learning, time and space complexities of spectral graph filters. \label{Tab:complexity}}\vspace{-0.3cm}
\end{table}
\noindent\textbf{Complexity. } When computing $\bar{x}^{(t)}$ as in Eq. \ref{equ:feedback-looped}, we need to calculate $\tilde{L}^j \bar{x}^{(t-1)}$ for $j=1, \dots, p$ and $\tilde{L}^j x$ for $j=1, \dots, q$. Nevertheless, $\tilde{L}^j x$ is computed only once because $\tilde{L}^j x = \tilde{L}(\tilde{L}^{j-1} x)$. Thus, we need $p$ multiplications for each $t$ in the first term in Eq. \ref{equ:feedback-looped}, and $q$ multiplications for the second term in Eq. \ref{equ:feedback-looped}. Table \ref{Tab:complexity} summarizes the complexity results of existing spectral graph filters and ours, where $r$ refers to the number of Jacobi iterations in \cite{levie2017cayleynets}. Note that, when $t=1$ (i.e., one spectral convolutional layer), feedback-looped filters have the same learning, time and memory complexities as Chebyshev filters, where $p+q=k$.
 
\section{Numerical Experiments}
\label{sec:experiments}
We evaluate our models on two benchmark tasks: (1) semi-supervised document classification in citation networks, and (2) semi-supervised entity classification in a knowledge graph.   




\subsection{Experimental Set-Up}
\textbf{Datasets.} We use three citation network datasets Cora, Citeseer, and Pubmed \cite{sen2008collective} for semi-supervised document classification, and one dataset NELL \cite{carlson2010toward} for semi-supervised entity classification. NELL is a bipartite graph extracted from a knowledge graph \cite{carlson2010toward}. Table \ref{Tab:datasets} contains dataset statistics \cite{yang2016revisiting}. 
\begin{table}[ht]
\centering \begin{tabular}{l l r r r r r} \specialrule{.1em}{.05em}{.05em} Dataset & Type & \#Nodes & \#Edges & \#Classes & \#Features & {\%Labeled Nodes} \\ [0.5ex] \hline Cora & Citation network & 2,708 & 5,429 & 7 & 1,433 & 0.052 \\
Citeseer & Citation network & 3,327 & 4,732 & 6 & 3,703 & 0.036 \\
Pubmed & Citation network & 19,717 & 44,338 & 3 & 500 & 0.003 \\
NELL & Knowledge graph & 65,755 & 266,144 & 210 & 5,414 & 0.001 \\
\specialrule{.1em}{.05em}{.05em}
\end{tabular}
\caption{Dataset statistics. \label{Tab:datasets}}
\end{table}\vspace*{-0.5cm}

\textbf{Baseline methods.} We compare against twelve baseline methods, including five methods using spatial graph filters, i.e., Semi-supervised Embedding (SemiEmb) \cite{weston2012deep}, Label Propagation (LP) \cite{zhu2003semi}, skip-gram graph embedding model (DeepWalk) \cite{perozzi2014deepwalk}, Iterative Classification Algorithm (ICA) \cite{lu2003link}, and semi-supervised learning with graph embedding (Planetoid*) \cite{yang2016revisiting}, and seven methods using spectral graph filters: Chebyshev \cite{defferrard2016convolutional}, Graph Convolutional Networks (GCN) \cite{kipf2016semi}, Lanczos Networks (LNet) and Adaptive Lanczos Networks (AdaLNet) \cite{liao2019lanczosnet}, CayleyNet \cite{levie2017cayleynets}, Graph Attention Networks (GAT) \cite{velivckovic2017graph}, and ARMA Convolutional Networks (ARMA$_1$) \cite{bianchi2019graph}.



We evaluate our feedback-looped filters using three different spectral CNN models: (i) DFNet: a densely connected spectral CNN with feedback-looped filters, (ii) DFNet-ATT: a self-attention based densely connected spectral CNN with feedback-looped filters, and (iii) DF-ATT: a self-attention based spectral CNN model with feedback-looped filters. 


\begin{table}[ht]
\centering \scalebox{0.97}{\begin{tabular}{l c c l c c l } \specialrule{.1em}{.05em}{.05em} Model & L2 reg. & \#Layers & \#Units  &Dropout &[p, q]&$\lambda_{cut}$\\ [0.5ex] 
\hline DFNet & 9e-2 & 5 & [8, 16, 32, 64, 128]& 0.9 &[5, 3]&0.5\\ 
DFNet-ATT & 9e-4 & 4 & [8, 16, 32, 64] &0.9 &[5, 3]& 0.5\\ 
DF-ATT & 9e-3 & 2 & [32, 64] & [0.1, 0.9] &[5, 3]& 0.5 \\ 
\hline 
\end{tabular}}
\caption{Hyperparameter settings for citation network datasets.\label{Tab:hyperparameters}}
\end{table}\vspace{-0.3cm}


\textbf{Hyperparameter settings.} We use the same data splitting for each dataset as in Yang et al. \cite{yang2016revisiting}. The hyperparameters of our models are initially selected by applying the orthogonalization technique (a randomized search strategy). We also use a layerwise regularization (L2 regularization) and bias terms to attenuate the overfitting issue. All models are trained 200 epochs using the Adam optimizer \cite{kingma2014adam} with a learning rate of 0.002. Table \ref{Tab:hyperparameters} summarizes the hyperparameter settings for citation network datasets.  The same hyperparameters are applied to the NELL dataset except for L2 regularization (i.e., 9e-2 for DFNet and DFnet-ATT, and 9e-4 for DF-ATT). For $\gamma$, we choose the best setting for each model. For self-attention, we use 8 multi-attention heads and 0.5 attention dropout for DFNet-ATT, and 6 multi-attention heads and 0.3 attention dropout for DF-ATT. The parameters $p=5$, $q=3$ and $\lambda_{cut}=0.5$ are applied to all three models over all datasets.



\begin{comment}
\begin{table}[ht]
\caption{Hyperparameter settings for each model.\label{Tab:hyperparameters}} \centering \begin{tabular}{l l c c l c} \specialrule{.1em}{.05em}{.05em} Dataset & Model & L2 reg. & \#Layers & \#Nodes & [P, Q, \gamma] \\ [0.5ex] \hline \multirow{3}{4em}{Cora} & FirstModel & 9e-2 & 5 & [8, 16, 32, 64, 128] & [5, 3, 0.9]\\ 
& SecondModel & 9e-4 & 4 & [8, 16, 32, 64] & [3, 2, 0.7]\\ 
& ThirdModel & 9e-3 & 2 & [32, 64] & [5, 3, 0.9] \\ 
\hline \multirow{3}{4em}{Citeseer} & FirstModel & 9e-2 & 5 & [8, 16, 32, 64, 128] & [5, 3, 0.9]\\ 
& SecondModel & 9e-4 & 4 & [8, 16, 32, 64] & [5, 3, 0.5]\\ 
& ThirdModel & 9e-3 & 2 & [32, 64] & [5, 3, 0.5] \\ 
\hline \multirow{3}{4em}{Pubmed} & FirstModel & 9e-2 & 5 & [8, 16, 32, 64, 128] & [3, 2, 0.7]\\ 
& SecondModel & 9e-2 & 4 & [8, 16, 32, 64] & [5, 3, 0.9]\\ 
& ThirdModel & 9e-3 & 2 & [32, 64] & [5, 3, 0.9] \\ 
\hline \multirow{3}{4em}{NELL} & FirstModel & 9e-2 & 5 & [8, 16, 32, 64, 128] & [5, 3, 0.5]\\ 
& SecondModel & 9e-2 & 4 & [8, 16, 32, 64] & [5, 3, 0.9]\\ 
& ThirdModel & 9e-4 & 2 & [32, 64] & [5, 3, 0.9] \\ 
\specialrule{.1em}{.05em}{.05em} \end{tabular}
\end{table}




\end{comment}

\subsection{Comparison with Baseline Methods}
Table \ref{Tab:baselines} summarizes the results of classification in terms of accuracy. The results of the baseline methods are taken from the previous works  \cite{kipf2016semi, liao2019lanczosnet, velivckovic2017graph, yang2016revisiting}. Our models DFNet and DFNet-ATT outperform all the baseline methods over four datasets. Particularly, we can see that: (1) Compared with polynomial filters, DFNet improves upon GCN (which performs best among the models using polynomial filters) by a margin of 3.7\%, 3.9\%, 5.3\% and 2.3\% on the datasets Cora, Citeseer, Pubmed and NELL, respectively. (2) Compared with rational polynomial filters, DFNet improves upon CayleyNet and ARMA$_1$ by 3.3\% and 1.8\% on the Cora dataset, respectively. For the other datasets, CayleyNet does not have results available in \cite{levie2017cayleynets}. (3) DFNet-ATT further improves the results of DFNet due to the addition of a self-attention layer. (4) Compared with GAT (Chebyshev filters with self-attention), DF-ATT also improves the results and achieves 0.4\%, 0.6\% and 3.3\% higher accuracy on the datasets Cora, Citeseer and Pubmed, respectively.

Additionally, we compare DFNet (our feedback-looped filters + DenseBlock) with GCN + DenseBlock and GAT + DenseBlock. The results are also presented in Table \ref{Tab:baselines}. We can see that our feedback-looped filters perform best, no matter whether or not the dense architecture is used. 

\begin{table}[ht]
\centering 
\begin{tabular}{ l c c c c}
\specialrule{.1em}{.05em}{.05em} 
Model & Cora & Citeseer & Pubmed & NELL \\ [0.5ex] 
\hline
SemiEmb \cite{weston2012deep} & 59.0 & 59.6 &71.1 & 26.7\\
LP \cite{zhu2003semi} & 68.0 & 45.3 & 63.0 & 26.5 \\
DeepWalk \cite{perozzi2014deepwalk} & 67.2 & 43.2 & 65.3 & 58.1 \\
ICA \cite{lu2003link} & 75.1 & 69.1 & 73.9 & 23.1 \\
Planetoid* \cite{yang2016revisiting} & 64.7 & 75.7 & 77.2 & 61.9 \\[0.5ex]\hline
Chebyshev \cite{defferrard2016convolutional} & 81.2 & 69.8 & 74.4 & - \\ GCN \cite{kipf2016semi} & 81.5 & 70.3 & 79.0 & 66.0 \\
{LNet} \cite{liao2019lanczosnet} & 79.5 & 66.2 & 78.3 & -\\
{AdaLNet} \cite{liao2019lanczosnet} & 80.4 & 68.7 & 78.1 & -\\
{CayleyNet} \cite{levie2017cayleynets} & \hspace*{0.15cm}81.9$^*$ & - & - & - \\
{ARMA$_1$} \cite{bianchi2019graph} & 83.4 & 72.5 & 78.9 & - \\  

GAT  \cite{velivckovic2017graph} & 83.0 & 72.5 & 79.0 & - \\[0.5ex]
\hline
GCN + DenseBlock & 82.7 $\pm$ 0.5 & 71.3 $\pm$ 0.3 & 81.5 $\pm$ 0.5 & 66.4 $\pm$ 0.3 \\ 
GAT + Dense Block & 83.8 $\pm$ 0.3 & 73.1 $\pm$ 0.3 & 81.8 $\pm$ 0.3 & - \\ [0.5ex]
\hline DFNet (ours) & \textbf{85.2} $\pm$ \textbf{0.5} & \textbf{74.2} $\pm$ \textbf{0.3} & \textbf{84.3} $\pm$ \textbf{0.4} & \textbf{68.3} $\pm$ \textbf{0.4} \\
DFNet-ATT (ours) & \textbf{86.0} $\pm$ \textbf{0.4} & \textbf{74.7} $\pm$ \textbf{0.4} & \textbf{85.2} $\pm$ \textbf{0.3} & \textbf{68.8} $\pm$ \textbf{0.3} \\
DF-ATT (ours) & 83.4 $\pm$ 0.5 & 73.1 $\pm$ 0.4 & \textbf{82.3} $\pm$ \textbf{0.3} & \textbf{67.6} $\pm$ \textbf{0.3} \\
\specialrule{.1em}{.05em}{.05em}
\end{tabular}\caption{Accuracy (\%) averaged over 10 runs (* was obtained using a different data splitting in \cite{levie2017cayleynets})}. 
\label{Tab:baselines} \vspace{-0.7cm}
\end{table}









\begin{comment}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.45\textwidth]{images/polynomial_orders_plot/poly_P.eps}
    \includegraphics[width=0.45\textwidth]{images/polynomial_orders_plot/poly_Q.eps}
    \caption{Accuracy (\%) of DFNet under different polynomial orders, where Q=3 in (a) and P=5 in (b).}
    \label{fig:polynomialPlots}
\end{figure}\vspace{-0.1cm}
\end{comment}

\begin{comment}
\begin{table}[ht]
\caption{Evaluation with different polynomial orders. \label{Tab:polynomial}} \centering \begin{tabular}{c l c c c} \specialrule{.1em}{.05em}{.05em} Order[P, Q, $\gamma$] & Model & Cora & Citeseer & Pubmed \\ [0.5ex] \hline \multirow{3}{4em}{[3, 2, 0.7]} & FirstModel & 61.8 & 71.9 & \textbf{84.6} \\ 
& SecondModel & \textbf{86.3} & 71.6 & 83.7 \\ 
& ThirdModel & 79.8 & 68.2 & 81.4 \\ 
\hline \multirow{3}{4em}{[3, 2, 0.9]} & FirstModel & 71.5 & 72.8 & 83.5 \\ 
& SecondModel & 85.9 & 74.5 & 83.9 \\ 
& ThirdModel & 80.0 & 69.5 & 81.7 \\ 
\hline \multirow{3}{4em}{[5, 3, 0.5]} & FirstModel & 83.8 & \textbf{74.2} & 82.7 \\ 
& SecondModel & 84.9 & \textbf{74.7} & 83.1 \\ 
& ThirdModel & 82.0 & 70.6 & 82.4 \\ 
\hline \multirow{3}{4em}{[5, 3, 0.9]} & FirstModel & \textbf{85.2} & 73.9 & 83.4 \\ 
& SecondModel & 85.7 & 72.4 & \textbf{85.1} \\ 
& ThirdModel & \textbf{83.4} & \textbf{73.1} & \textbf{82.3} \\ 
\hline \multirow{3}{4em}{[9, 4, 0.5]} & FirstModel & 82.8 & 29.5 & 83.0 \\ 
& SecondModel & 65.7 & 26.7 & 83.3 \\ 
& ThirdModel & 81.9 & 71.3 & 81.9 \\ 
\hline \multirow{3}{4em}{[9, 4, 0.9]} & FirstModel & 75.4 & 30.1 & 82.3 \\ 
& SecondModel & 42.9 & 26.3 & 82.7 \\ 
& ThirdModel & 80.3 & 70.7 & 81.3 \\ 
\specialrule{.1em}{.05em}{.05em} \end{tabular}
\label{table:nonlin} \end{table}
\end{comment}



\begin{comment}
\begin{figure}[h]
    \centering
    \fbox{\includegraphics[width=0.45\textwidth]{images/cut-off_plots/ARMA-Dense.png}}
    \fbox{\includegraphics[width=0.45\textwidth]{images/cut-off_plots/ARMA-DenseATT.png}}
    \fbox{\includegraphics[width=0.45\textwidth]{images/cut-off_plots/ARMA-ATT.png}}
    \caption{Accuracy fluctuation for each cut-off values on Cora, Citeseer, and Pubmed datasets for ARMA-Dense, ARMA-DenseATT, and ARMA-ATT models.}
    \label{fig:coraEmbeddings}
\end{figure}
\end{comment}

\subsection{Comparison under Different Polynomial Orders} \label{subsec:other-hyperparameters}

\begin{comment}
\begin{wrapfigure}[12]{r}{0.5\textwidth}
\vspace{-0.3cm}
\centering\vspace{-0.2cm}
\includegraphics[width=0.5\textwidth]{images/polynomial_orders_plot/poly_v1.png}
\caption{Accuracy (\%) of DFNet under different polynomial orders $p$ and $q$.
    \label{fig:polynomialPlots}}
\end{wrapfigure}
\end{comment}

In order to test how the polynomial orders $p$ and $q$ influence the performance of our model DFNet, we conduct experiments to evaluate DFNet on three citation network datasets using different polynomial orders $p=[1,3,5,7,9]$ and $q=[1,3,5,7,9]$.
    Figure \ref{fig:polynomialPlots} presents the experimental results. In our experiments, $p=5$ and $q=3$ turn out to be the best parameters for DFNet over these datasets. In other words, this means that feedback-looped filters are more stable on $p=5$ and $q=3$ than other values of $p$ and $q$. This is because, when $p=5$ and $q=3$, Eq.~\ref{equ:arma-filter-optimizer} can obtain better convergence for finding optimal coefficients than in the other cases. Furthermore, we observe that: (1) Setting $p$ to be too low or too high can both lead to poor performance, as shown in Figure \ref{fig:polynomialPlots}.(a), and (2) when $q$ is larger than $p$, the accuracy decreases rapidly as shown in Figure \ref{fig:polynomialPlots}.(b). Thus, when choosing $p$ and $q$, we require that $p>q$ holds.

\begin{figure}[!h]
\vspace{-0.3cm}
\centering
\includegraphics[width=0.7\textwidth]{images/polynomial_orders_plot/poly_v1.png}
\caption{Accuracy (\%) of DFNet under different polynomial orders $p$ and $q$.}
    \label{fig:polynomialPlots}
\end{figure}

\subsection{Evaluation of Scaled-Normalization and Cut-off Frequency}
\begin{comment}
\begin{wraptable}{r}{0.45\textwidth}
\resizebox{0.45\columnwidth}{!}{\begin{tabular}{|c| l| c c c|} 
\specialrule{.1em}{.05em}{.05em} 
Case & Model & Cora & Citeseer & Pubmed \\ [0.5ex] 
\hline 
\multirow{3}{*}{1} & DFNet & \textbf{85.2} & \textbf{74.2} & \textbf{84.3} \\ 
& DFNet-ATT & \textbf{86.0} & \textbf{74.7} & \textbf{85.2} \\ 
& DF-ATT & \textbf{83.4} & \textbf{73.1} & \textbf{82.3} \\ 
\hline 
\multirow{3}{*}{2} & DFNet & 46.6 & 33.2 & 82.8 \\ 
& DFNet-ATT & 45.1 & 47.2 & 81.1 \\ 
& DF-ATT & 73.9 & 58.5 & 71.8 \\ 
\hline 
\multirow{3}{*}{3} & DFNet & 35.6 & 28.7 & 70.2 \\ 
& DFNet-ATT & 30.9 & 25.3 & 82.4 \\ 
& DF-ATT & 76.3 & 66.5 & 81.3 \\ 
\specialrule{.1em}{.05em}{.05em}
\end{tabular}}\caption{Accuracy (\%) of our models in three cases: (1) using both scaled-normalization and cutoff frequency, (2) not using scaled-normalization, and (3) not using cutoff frequency.  \label{Tab:normalization-cutoff}}
\end{wraptable}
\end{comment}
To understand how effectively the scaled-normalisation and cut-off frequency techniques can help learn graph representations, we compare our methods that implement these techniques with the variants of our methods that only implement one of these techniques. The results are presented in Figure \ref{fig:evalParams}. We can see that, the models using these two techniques outperform the models that only use one of these techniques over all citation network datasets. Particularly, the improvement is significant on the Cora and Citeseer datasets.


\begin{comment}
\begin{table}[ht]
\centering \begin{tabular}{l l c c c} \specialrule{.1em}{.05em}{.05em} Description & Model & Cora & Citeseer & Pubmed \\ [0.5ex] \hline \multirow{3}{12em}{Scaled-normalization} & DFNet & \textbf{85.2} & \textbf{74.2} & \textbf{84.3} \\ 
& DFNet-ATT & \textbf{86.0} & \textbf{74.7} & \textbf{85.2} \\ 
& DF-ATT & \textbf{83.4} & \textbf{73.1} & \textbf{82.3} \\ 
\hline \multirow{3}{12em}{Laplacian without scaled-normalize technique} & DFNet & 46.6 & 33.2 & 82.8 \\ 
& DFNet-ATT & 45.1 & 47.2 & 81.1 \\ 
& DF-ATT & 73.9 & 58.5 & 71.8 \\ 
\hline \multirow{3}{12em}{Without \smallskip
\noindent\textbf{Laplacian without cut-off frequency technique}} & DFNet & 53.7 & 35.1 & 70.2 \\ 
& DFNet-ATT & 50.9 & 40.2 & 82.4 \\ 
& DF-ATT & 75.4 & 66.5 & 81.3 \\ 
\specialrule{.1em}{.05em}{.05em} \end{tabular}
\label{table:nonlin} \end{table}
\end{comment}

\begin{figure}[t!]
    \vspace{-0.5cm}\centering
    \includegraphics[width=1\textwidth]{images/evaluation_all_parameters.png}
    \caption{Accuracy (\%) of our models in three cases: (1) using both scaled-normalization and cut-off frequency, (2) using only cut-off frequency, and (3) using only scaled-normalization.  
    \label{fig:evalParams}}\vspace{-0.3cm}
\end{figure}

\subsection{Node Embeddings}
We analyze the node embeddings by DFNets over two datasets: Cora and Pubmed in a 2-D space. Figures \ref{fig:pubmedEmbeddings} and \ref{fig:coraEmbeddings} display the visualization of the learned 2-D embeddings of GCN, GAT, and DFNet (ours) on Pubmed and Cora citation networks by applying t-SNE \cite{maaten2008visualizing} respectively.
Colors denote different classes in these datasets. It reveals the clustering quality of theses models. These figures clearly show that our model DFNet has better separated 3 and 7 clusters respectively in the embedding spaces of Pubmed and Cora datasets. This is because features extracted by DFNet yield better node representations than GCN and GAT models.

\begin{comment}
\begin{figure}[h]
    \centering
    \fbox{\includegraphics[width=0.30\textwidth]{images/embeddings/pubmed/GCN_hidden_embeddings.png}}
    \fbox{\includegraphics[width=0.30\textwidth]{images/embeddings/pubmed/GAT_hidden_embeddings.png}}
    \fbox{\includegraphics[width=0.30\textwidth]{images/embeddings/pubmed/ARMA_hidden_embeddings.png}}
    \caption{The t-SNE visualization of the 2-D node embedding space for the Pubmed dataset in GCN, GAT, and Our method.}
    \label{fig:pubmedEmbeddings}
\end{figure}
\end{comment}

\begin{figure}[h]
  \centering\vspace{-0.2cm}
  \begin{subfigure}[b]{0.32\linewidth}
    \fbox{\includegraphics[width=0.95\textwidth]{images/embeddings/pubmed/GCN_hidden_embeddings.png}}
    \caption{GCN}
  \end{subfigure} 
  \begin{subfigure}[b]{0.32\linewidth}
   \fbox{\includegraphics[width=0.95\textwidth]{images/embeddings/pubmed/GAT_hidden_embeddings.png}}
    \caption{GAT}
  \end{subfigure}
  \begin{subfigure}[b]{0.32\linewidth}
   \fbox{\includegraphics[width=0.95\textwidth]{images/embeddings/pubmed/ARMA_hidden_embeddings.png}}
    \caption{DFNet (ours)}
  \end{subfigure}
  \caption{The t-SNE visualization of the 2-D node embedding space for the Pubmed dataset.}
  \label{fig:pubmedEmbeddings}
  \centering
  \begin{subfigure}[b]{0.32\linewidth}
    \fbox{\includegraphics[width=0.95\textwidth]{images/embeddings/cora/GCN_hidden_embeddings.png}} 
    \caption{GCN}
  \end{subfigure} 
  \begin{subfigure}[b]{0.32\linewidth}
   \fbox{\includegraphics[width=0.95\textwidth]{images/embeddings/cora/GAT_hidden_embeddings.png}}
    \caption{GAT}
  \end{subfigure}
  \begin{subfigure}[b]{0.32\linewidth}
   \fbox{\includegraphics[width=0.95\textwidth]{images/embeddings/cora/ARMA_hidden_embeddings.png}} 
    \caption{DFNet (ours)}
  \end{subfigure}
  \caption{The t-SNE visualization of the 2-D node embedding space for the Cora dataset.}
  \label{fig:coraEmbeddings}
\end{figure}

\begin{comment}
\begin{figure}[h]
    \centering
    \fbox{\includegraphics[width=0.30\textwidth]{images/embeddings/cora/GCN_hidden_embeddings.png}} 
    \fbox{\includegraphics[width=0.30\textwidth]{images/embeddings/cora/GAT_hidden_embeddings.png}}
    \fbox{\includegraphics[width=0.30\textwidth]{images/embeddings/cora/ARMA_hidden_embeddings.png}} 
    \caption{The t-SNE visualization of the 2-D node embedding space for the Cora dataset in GCN, GAT, and Our method.}
    \label{fig:coraEmbeddings}
\end{figure}
\end{comment}









 \vspace{-0.3cm}
\section{Conclusions}\vspace{-0.3cm}\label{sec:conclusions}
In this paper, we have introduced a spectral CNN architecture (DFNets) with feedback-looped filters on graphs. To improve approximation accuracy, we have developed two techniques: scaled normalization and cut-off frequency. In addition to these, we have discussed some nice properties of feedback-looped filters, such as guaranteed convergence, linear convergence time, and universal design. Our proposed model outperforms the state-of-the-art approaches significantly in two benchmark tasks. In future, we plan to extend the current work to time-varying graph structures. As discussed in \cite{isufi2017autoregressive1}, feedback-looped graph filters are practically appealing for time-varying settings, and similar to static graphs, some nice properties would likely hold for graphs that are a function of time.







 

\newpage
\bibliographystyle{abbrv}
\bibliography{references}

\newpage
\section*{Appendices}

In the following, we provide further experiments on comparing our work with the others. 

\medskip
\noindent\textbf{Comparison with different spectral graph filters. }We have conducted an ablation study of our proposed graph filters. Specifically, we compare our feedback-looped filters, i.e., the newly proposed spectral filters in this paper, against other spectral filters such as Chebyshev filters and Cayley filters. To conduct this ablation study, we remove the dense connections from our model DFNet. The experimental results are presented in table \ref{table:table2}. It shows that feedback-looped filters improve localization upon Chebyshev filters by a margin of 1.4\%, 1.7\% and 7.3\% on the datasets Cora, Citeseer and Pubmed, respectively. It also improves upon Cayley filters by a margin of 0.7\% on the Cora dataset.

\begin{table}[!h]
\centering
\begin{tabular}{l c c c } \specialrule{.1em}{.05em}{.05em} Model & Cora & Citeseer & Pubmed \\ [0.5ex] \hline {Chebyshev filters} \cite{defferrard2016convolutional} & 81.2 & 69.8 & 74.4  \\ 
{Cayley filters} \cite{levie2017cayleynets}& 81.9 & - & -  \\ 
Feedback-looped filters (ours) & \textbf{82.6} $\pm$ \textbf{0.3} & \textbf{71.5} $\pm$ \textbf{0.4} & \textbf{81.7} $\pm$ \textbf{0.6} \\
\specialrule{.1em}{.05em}{.05em} \end{tabular}\caption{Accuracy (\%) averaged over 10 runs.}
\label{table:table2} \end{table}\vspace{-0.2cm}

\noindent\textbf{Comparison with LNet and AdaLNet using different data splittings. }
We have benchmarked the performance of our DFNet model against the models LNet and AdaLNet proposed in \cite{liao2019lanczosnet}, as well as Chebyshev, GCN and GAT, over three citation network datasets Cora, Citeseer and Pubmed. We use the same data splittings as used in \cite{liao2019lanczosnet}. All the experiments are repeated 10 times. For our model DFNet, we use the same hyperparameter settings as discussed in Section 4.2. 




\begin{table}[!h]
\centering
\begin{tabular}{l c c c c c c}
\specialrule{.1em}{.05em}{.05em} Training Split & Chebyshev & GCN & GAT & LNet & AdaLNet & DFNet\\ [0.5ex] \hline 5.2\% (standard) & 78.0 $\pm$ 1.2 & 80.5 $\pm$ 0.8 & 82.6 $\pm$ 0.7 & 79.5 $\pm$ 1.8 & 80.4 $\pm$ 1.1 & \textbf{85.2} $\pm$ \textbf{0.5}\\ 
3\%  & 62.1 $\pm$ 6.7 & 74.0 $\pm$ 2.8 & 56.8 $\pm$ 7.9 & 76.3 $\pm$ 2.3 & 77.7 $\pm$ 2.4 & \textbf{80.5} $\pm$ \textbf{0.4}\\ 
1\%  & 44.2 $\pm$ 5.6 & 61.0 $\pm$ 7.2 & 48.6 $\pm$ 8.0 & 66.1 $\pm$ 8.2 & 67.5 $\pm$ 8.7 & \textbf{69.5} $\pm$ \textbf{2.3}\\ 
0.5\%  & 33.9 $\pm$ 5.0 & 52.9 $\pm$ 7.4 & 41.4 $\pm$ 6.9 & 58.1 $\pm$ 8.2 & 60.8 $\pm$ 9.0 & \textbf{61.3} $\pm$ \textbf{4.3}\\ 
\specialrule{.1em}{.05em}{.05em} \end{tabular}\caption{Accuracy (\%) averaged over 10 runs on the Cora dataset.}
\label{lanczos-cora}
\end{table}
\vspace*{-0.3cm}
\begin{table}[!h]
\centering
\begin{tabular}{l c c c c c c}
\specialrule{.1em}{.05em}{.05em} Training Split & Chebyshev & GCN & GAT & LNet & AdaLNet & DFNet\\ [0.5ex] \hline 3.6\% (standard) & 70.1 $\pm$ 0.8 & 68.1 $\pm$ 1.3 & 72.2 $\pm$ 0.9 & 66.2 $\pm$ 1.9 & 68.7 $\pm$ 1.0 & \textbf{74.2} $\pm$ \textbf{0.3}\\ 1\%  & 59.4 $\pm$ 5.4 & 58.3 $\pm$ 4.0 & 46.5 $\pm$ 9.3 & 61.3 $\pm$ 3.9 & 63.3 $\pm$ 1.8 & \textbf{67.4} $\pm$ \textbf{2.3}\\ 
0.5\%  & 45.3 $\pm$ 6.6 & 47.7 $\pm$ 4.4 & 38.2 $\pm$ 7.1 & 53.2 $\pm$ 4.0 & 53.8 $\pm$ 4.7 & \textbf{55.1} $\pm$ \textbf{3.2}\\ 
0.3\%  & 39.3 $\pm$ 4.9 & 39.2 $\pm$ 6.3 & 30.9 $\pm$ 6.9 & 44.4 $\pm$ 4.5 & 46.7 $\pm$ 5.6 & \textbf{48.3} $\pm$ \textbf{3.5}\\ 
\specialrule{.1em}{.05em}{.05em} \end{tabular}
\caption{Accuracy (\%) averaged over 10 runs on the Citeseer dataset.}\label{lanczos-citeseer}
\end{table}
\vspace*{-0.35cm}
\begin{table}[!h]
\centering
\begin{tabular}{l c c c c c c}
\specialrule{.1em}{.05em}{.05em} Training Split & Chebyshev & GCN & GAT & LNet & AdaLNet & DFNet\\ [0.5ex] \hline 0.3\% (standard) & 69.8 $\pm$ 1.1 & 77.8 $\pm$ 0.7 & 76.7 $\pm$ 0.5 & 78.3 $\pm$ 0.3 & 78.1 $\pm$ 0.4 & \textbf{84.3} $\pm$ \textbf{0.4}\\ 0.1\% & 55.2 $\pm$ 6.8 & 73.0 $\pm$ 5.5 & 59.6 $\pm$ 9.5 & 73.4 $\pm$ 5.1 & 72.8 $\pm$ 4.6 & \textbf{75.2} $\pm$ \textbf{3.6}\\ 
0.05\%  & 48.2 $\pm$ 7.4 & 64.6 $\pm$ 7.5 & 50.4 $\pm$ 9.7 & 68.8 $\pm$ 5.6 & 66.0 $\pm$ 4.5 & \textbf{67.2} $\pm$ \textbf{7.3}\\ 
0.03\% & 45.3 $\pm$ 4.5 & 57.9 $\pm$ 8.1 & 50.9 $\pm$ 8.8 & 60.4 $\pm$ 8.6 & \textbf{61.0} $\pm$ \textbf{8.7} & 59.3 $\pm$ 6.6\\ 
\specialrule{.1em}{.05em}{.05em} \end{tabular}
\caption{Accuracy (\%) averaged over 10 runs on the Pubmed dataset.}\label{lanczos-pubmed}\vspace{-0.3cm}
\end{table}

Tables \ref{lanczos-cora}-\ref{lanczos-pubmed} present the experimental results. Table \ref{lanczos-cora} shows that DFNet performs significantly better than all the other models over the Cora dataset, including LNet and AdaLNet proposed in \cite{liao2019lanczosnet}. Similarly, Table \ref{lanczos-citeseer} shows that DFNet performs significantly better than all the other models over the Citeseer dataset. For the Pubmed dataset, as shown in Table \ref{lanczos-pubmed}, DFNet performs significantly better than almost all the other models, except for only one case in which DFNet performs slightly worse than AdaLNet using the splitting 0.03\%. These results demonstrate the robustness of our model DFNet.


 
\end{document}
