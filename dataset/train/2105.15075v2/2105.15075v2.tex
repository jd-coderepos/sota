\documentclass{article}







\usepackage[final, nonatbib]{neurips_2021}



\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{xcolor}         


\usepackage{bm}
\usepackage{amsmath}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{wrapfig}
\usepackage{amsthm}
\usepackage{caption}


\usepackage{booktabs}


\usepackage{pifont}
\newcommand{\cmark}{\ding{51}}\newcommand{\xmark}{\ding{55}}

\title{Not All Images are Worth 16x16 Words: Dynamic Transformers for Efficient Image Recognition}



\author{Yulin Wang\thanks{Equal contribution.}\ \ \ \ 
  Rui Huang\ \ \ 
  Shiji Song\ \ \ 
  Zeyi Huang\ \ \ 
  Gao Huang\thanks{Corresponding author.}\\
    Department of Automation, BNRist, Tsinghua University, Beijing, China\\
Huawei Technologies Ltd., China\\
    Beijing Academy of Artificial Intelligence, Beijing, China\\
  \texttt{\{wang-yl19, hr20\}@mails.tsinghua.edu.cn, huangzeyi2@huawei.com.} \\
  \texttt{\{shijis, gaohuang\}@tsinghua.edu.cn}
}

\begin{document}

\maketitle

\begin{abstract}

Vision Transformers (ViT) have achieved remarkable success in large-scale image recognition. They split every 2D image into a fixed number of patches, each of which is treated as a token. Generally, representing an image with more tokens would lead to higher prediction accuracy, while it also results in drastically increased computational cost. To achieve a decent trade-off between accuracy and speed, the number of tokens is empirically set to 16x16 or 14x14. In this paper, we argue that every image has its own characteristics, and ideally the token number should be conditioned on each individual input. In fact, we have observed that there exist a considerable number of ``easy'' images which can be accurately predicted with a mere number of 4x4 tokens, while only a small fraction of ``hard'' ones need a finer representation. Inspired by this phenomenon, we propose a Dynamic Transformer to automatically configure a proper number of tokens for each input image. This is achieved by cascading multiple Transformers with increasing numbers of tokens, which are sequentially activated in an adaptive fashion at test time, i.e., the inference is terminated once a sufficiently confident prediction is produced. We further design efficient feature reuse and relationship reuse mechanisms across different components of the Dynamic Transformer to reduce redundant computations. Extensive empirical results on ImageNet, CIFAR-10, and CIFAR-100 demonstrate that our method significantly outperforms the competitive baselines in terms of both theoretical computational efficiency and practical inference speed. Code and pre-trained models (based on PyTorch and MindSpore) are available at \url{https://github.com/blackfeather-wang/Dynamic-Vision-Transformer} and \url{https://github.com/blackfeather-wang/Dynamic-Vision-Transformer-MindSpore}.



\end{abstract}






















































































































































\vspace{-1ex}
\section{Introduction}
\vspace{-1ex}
\label{sec:intro}

Transformers, the dominant self-attention-based models in natural language processing (NLP) \cite{devlin-etal-2019-bert, NIPS2017_3f5ee243, NEURIPS2020_1457c0d6}, have been successfully adapted to image recognition problems \cite{dosovitskiy2021an, yuan2021tokens, touvron2020training, han2021transformer} recently. In particular, vision Transformers achieve state-of-the-art performance on the large scale ImageNet benchmark \cite{5206848}, while exhibit excellent scalability with the further growing dataset size (e.g., on JFT-300M \cite{dosovitskiy2021an}). These models split each image into a fixed number of patches and embed them into 1D tokens as inputs. Typically, representing the data using more tokens contributes to higher prediction accuracy, but leads to intensive computational cost, which grows quadratically with respect to the token number in self-attention blocks. For a proper trade-off between efficiency and effectiveness, existing works empirically adopt 14x14 or 16x16 tokens \cite{dosovitskiy2021an, yuan2021tokens}.


\begin{wraptable}{r}{4.85cm}
    \centering
    \vskip -0.175in
    \caption{Accuracy and computational cost of T2T-ViT-12 with different token numbers on ImageNet.\label{tab:table1}} 
    \vskip -0.08in
    \setlength{\tabcolsep}{2mm}{
\renewcommand\arraystretch{1}
    \hspace{-2ex}
    \resizebox{1\linewidth}{!}{
    \begin{tabular}{c|ccc}
    \toprule
     \# of Tokens&14x14&7x7&4x4 \\
     \midrule
     Accuracy &76.7\% & 70.3\% & 60.8\% \\
     FLOPs & 1.78G &0.47G&0.21G \\
     \bottomrule
    \end{tabular}}}
    \vskip -0.2in
\end{wraptable}

In this paper, we argue that it may not be optimal to treat all samples with the same number of tokens. In fact, there exist considerable variations among different images (e.g., contents, scales of objects, backgrounds, etc.). Therefore, the number of representative tokens should ideally be configured specifically for each input. This issue is critical for the computational efficiency of the models. For example, we train a T2T-ViT-12 \cite{yuan2021tokens} with varying token numbers, and report the corresponding accuracy and FLOPs in Table \ref{tab:table1}. One can observe that adopting the officially recommended 14x14 tokens only correctly recognizes 15.9\% (76.7\% v.s. 60.8\%) more test samples compared to that of using 4x4 tokens, while increases the computational cost by 8.5x (1.78G v.s. 0.21G). In other words, computational resources are wasted on applying the unnecessary 14x14 tokens to many ``easy'' images for which 4x4 tokens are sufficient.


\begin{wrapfigure}{r}{5.525cm}
    \vskip -0.25in
    \begin{minipage}[t]{\linewidth}
    \centering
    \hspace{-2.5ex}
    \includegraphics[width=1.05\textwidth]{figs/fig1.pdf}	
    \vskip -0.125in
    \caption{Examples for DVT.
    \label{fig:examples}}  
    \end{minipage}
    \vskip -0.2in
\end{wrapfigure}
Motivated by this observation, we propose a novel \emph{Dynamic Vision Transformer} (DVT) framework, aiming to automatically configure a decent token number conditioned on each image for high computational efficiency. In specific, a cascade of Transformers are trained using increasing number of tokens. At test time, these models are sequentially activated starting with less tokens. Once a prediction with sufficient confidence has been produced, the inference procedure will be terminated immediately. As a consequence, the computation is unevenly allocated among ``easy'' and ``hard'' samples by adjusting the token number, yielding a considerable improvement in efficiency. Importantly, we further develop \emph{feature-wise} and \emph{relationship-wise} reuse mechanisms to reduce redundant computations. The former allows the downstream models to be trained on the basis of previously extracted deep features, while the later enables leveraging existing upstream self-attention relationships to learn more accurate attention maps. Illustrative examples of our method are given in Figure \ref{fig:examples}.

Notably, DVT is designed as a general framework. Most of the state-of-the-art image recognition Transformers, such as ViT \cite{dosovitskiy2021an}, DeiT \cite{touvron2020training}, and T2T-ViT \cite{yuan2021tokens}, can be straightforwardly deployed as its backbones for higher efficiency. Our method is also appealing in its flexibility. The computational cost of DVT is able to be adjusted online by simply adapting the early-termination criterion. This characteristic makes DVT suitable for the cases where the available computational resources fluctuate dynamically or a minimal power consumption is required to achieve a given performance. Both situations are ubiquitous in real-world applications (e.g., searching engines and mobile apps).

The performance of DVT is evaluated on ImageNet \cite{5206848} and CIFAR \cite{krizhevsky2009learning} with T2T-ViT \cite{yuan2021tokens} and DeiT \cite{touvron2020training}. Experimental results show that DVT significantly improves the efficiency of the backbones. For examples, DVT reduces the computational cost of T2T-ViT by 1.6-3.6x without sacrificing accuracy. The real inference speed on a NVIDIA 2080Ti GPU is consistent with our theoretical results.


 




\vspace{-1.5ex}
\section{Related Work}
\vspace{-1.5ex}

\textbf{Vision Transformers.}
Inspired by the success of Transformers on NLP tasks \cite{devlin-etal-2019-bert, NIPS2017_3f5ee243, NEURIPS2020_1457c0d6, wang2018glue}, vision Transformers (ViT) have recently been developed for image recognition \cite{dosovitskiy2021an}. Although ViT by itself is not comparable with state-of-the-art convolutional networks (CNN) on the standard ImageNet benchmark, it attains excellent results when pre-trained on the larger JFT-300M dataset. DeiT \cite{touvron2020training} studies the training strategy of ViT and proposes a knowledge distilling-based approach, surpassing the performance of ResNet \cite{He_2016_CVPR}. Some following works such as T2T-ViT \cite{yuan2021tokens}, TNT \cite{han2021transformer}, CaiT \cite{touvron2021going}, DeepViT \cite{zhou2021deepvit}, CPVT \cite{chu2021conditional}, LocalViT \cite{li2021localvit} and CrossViT \cite{chen2021crossvit} focus on improving the architecture design of ViT. Another line of research proposes to integrate the inductive bias of CNN into Transformers \cite{wu2021cvt, d2021convit, yuan2021incorporating, graham2021levit}. There are also attempts to adapt ViT for other vision tasks (e.g., object detection, semantic segmentation, etc.) \cite{liu2021swin, wang2021pyramid, el2021training, he2021transreid, zeng2021motr, zhao2021trtr, fan2021multiscale}. The most majority of these concurrent works represent each image with a fix number of tokens. To the best of our knowledge, we are the first to consider configuring token numbers conditioned on the inputs.

\textbf{Efficient deep networks.}
Computational efficiency plays a critical role in real-world scenarios, where the executed computation translates into power consumption, carbon emission or latency. A number of works have been done on reducing the computational cost of CNNs \cite{howard2017mobilenets, sandler2018mobilenetv2, howard2019searching, yang2021condensenetv2, zhang2018shufflenet, ma2018shufflenet, DBLP:conf/icml/TanL19}. However, designing efficient vision Transformers is still an under-explored topic. T2T-ViT \cite{yuan2021tokens} proposes a light-weighted tokens-to-token module and obtains a competitive accuracy-parameter trade-off compared to MobileNetV2 \cite{sandler2018mobilenetv2}. LeViT \cite{graham2021levit} accelerates the inference of Transformer models by involving convolutional layers. Swin Transformer \cite{liu2021swin} introduces an efficient shifted window-based approach in multi-stage vision Transformers. Compared to these models with fixed computational graphs, the proposed DVT framework improves the efficiency by adaptively changing the architecture of the network on a per-sample basis.


\textbf{Dynamic models.}
Designing dynamic architectures is an effective approach for efficient deep learning \cite{han2021dynamic}. In the context of recognition tasks, MSDNet and its variants \cite{huang2017multi, yang2020resolution, li2019improved} develop a multi-classifier CNN architecture to perform early exiting for easy samples. Another type of dynamic CNNs skips redundant layers \cite{veit2018convolutional, wang2018skipnet, wu2018blockdrop} or channels \cite{lin2017runtime} conditioned on the inputs. Besides, the spatial adaptive paradigm \cite{figurnov2017spatially, cao2019seernet, NeurIPS2020_7866, verelst2020dynamic, wang2021adaptive} has been proposed for efficient image and video recognition. Although these works are related to DVT on the spirit of adaptive computation, they are developed based on CNN, while DVT is tailored for vision Transformers.

Notably, our work may seem similar to the multi-exit networks \cite{huang2017multi, yang2020resolution, li2019improved, NeurIPS2020_7866} from the lens of early-exiting. However, DVT differentiates itself from these existing works in several important aspects. For example, a major efficiency gain in both MSDNet \cite{huang2017multi} and RANet \cite{yang2020resolution} comes from the adaptive depth, namely processing ``easier'' samples using fewer layers within a single network. In comparison, DVT cascades multiple Transformers to infer several entire networks at test time. Besides, DVT does not leverage the multi-scale architecture or dense connection in MSDNet \cite{huang2017multi}. Compared with RANet \cite{yang2020resolution}, DVT introduces the adaptive token number and the relationship reuse mechanism tailored for ViT. In addition, IMTA \cite{li2019improved} studies the training techniques of multi-exit models, which are actually complementary to DVT. Another difference is that all these networks \cite{huang2017multi, yang2020resolution, li2019improved, NeurIPS2020_7866} adopt pure convolutional models.
 




\vspace{-1ex}
\section{Dynamic Vision Transformer}
\vspace{-1ex}

Vision Transformers \cite{dosovitskiy2021an, han2021transformer, touvron2020training, yuan2021tokens} split each 2D image into 1D tokens, while model their long range interaction with the self-attention mechanism \cite{NIPS2017_3f5ee243}. As aforementioned, to correctly recognize some ``hard'' images and achieve high accuracy, the number of tokens usually needs to be large, leading to the quadratically grown computational cost. However, ``easier'' images that make up the bulk of the datasets typically require far fewer tokens and much less costs (as shown in Table \ref{tab:table1}). Inspired by this observation, we propose a \emph{Dynamic Vision Transformers} (DVT), aiming to improve the computational efficiency of Transformers via adaptively reducing the number of representative tokens for each input.

In specific, we propose to deploy multiple Transformers trained with increasing number of tokens, such that one can sequentially activate them for each test image until obtaining a convincing prediction (e.g., with sufficient confidence). The computation is allocated unevenly across different samples for improving the overall efficiency. It is worth noting that, if all the Transformers are learned separately, the computation performed by upstream models will simply be abandoned once a downstream Transformer is activated, resulting in considerable inefficiency. To alleviate this problem, we introduce the efficient feature and relationship reuse mechanisms.






\begin{figure*}[t]
\begin{center}
    \centerline{\includegraphics[width=1\columnwidth]{figs/overview.pdf}}
\caption{
        An overview of \emph{Dynamic Vision Transformers} (DVT). Under the objective of configuring proper token numbers conditioned on the inputs, we cascade multiple Transformers with increasing number of tokens. At test time, they are sequentially activated until a convincing prediction (e.g. sufficiently confident) has been obtained or the final model has been inferred. The feature and relationship reuse mechanisms allow reusing computation across different Transformers. 
    }
    \label{fig:overview}
    \end{center}
    \vspace{-2.5ex}
\end{figure*}

\vspace{-1ex}
\subsection{Overview}
\vspace{-1ex}
\textbf{Inference.}
We start by describing the inference procedure of DVT, which is shown in Figure \ref{fig:overview}. For each test sample, we first coarsely represent it using a small number of 1D token embeddings. This can be achieved by either straightforwardly flattening the split image patches \cite{dosovitskiy2021an, han2021transformer} or leveraging techniques like the tokens-to-token module \cite{yuan2021tokens}. We infer a vision Transformer with these few tokens to obtain a quick prediction. This process enjoys high efficiency since the computational cost of Transformers grows quadratically with respect to token number. Then the prediction will be evaluated with certain criterion to determine whether it is reliable enough to be retrieved immediately. In this paper, early-termination is performed when the model is sufficiently confident (details in Section \ref{sec:adaptive_inference}).

Once the prediction fails to meet the termination criterion, the original input image will be split into more tokens for more accurate but computationally more expensive inference. Note that, here the dimension of each token embedding remains unchanged, while the number of tokens increases, enabling more fine-grained representation. An additional Transformer with the same architecture as the previous one but different parameters will be activated. By design, this stage trades off computation for higher accuracy on some ``difficult'' test samples. To improve the efficiency, the new model can reuse the previously learned features and relationships, which will be introduced in Section \ref{sec:reuse}. Similarly, after obtaining a new prediction, the termination criterion will be applied, and the above procedure will proceed until the sample exits or the final Transformer has been inferred.



\textbf{Training.}
For training, we simply train DVT to produce correct predictions at all exits (i.e., each with the corresponding number of tokens). Formally, the optimization objective is

where  denote a sample in the training set  and its corresponding label. We adopt the standard cross-entropy loss function , while  denotes the softmax prediction probability output by the  exit. We find that such a simple training objective works well in practice.

\textbf{Transformer backbone.}
DVT is proposed as a general and flexible framework. It can be built on top of most existing vision Transformers like ViT \cite{dosovitskiy2021an}, DeiT \cite{touvron2020training} and T2T-ViT \cite{yuan2021tokens} to improve their efficiency. The architecture of Transformers simply follows the implementation of these backbones.

\subsection{Feature and Relationship Reuse}
\label{sec:reuse}

An important challenge to develop our DVT approach is how to facilitate the \emph{reuse} of computation. That is, once a downstream Transformer with more tokens is inferred, it is obviously inefficient if the computation performed in previous models is abandoned. The upstream models, although being based on smaller number of input tokens, are trained with the same objective, and have extracted valuable information for fulfilling the task. Therefore, we propose two mechanisms to reuse the learned deep features and self-attention relationships. Both of them are able to improve the test accuracy significantly by involving minimal extra computational cost.


\textbf{Background.}
For the ease of introduction, we first revisit the basic formulation of vision Transformers. The Transformer encoders consist of alternatively stacked multi-head self-attention (MSA) and multi-layer perceptron (MLP) blocks \cite{NIPS2017_3f5ee243, dosovitskiy2021an}. The layer normalization (LN) \cite{ba2016layer} and residual connection \cite{He_2016_CVPR} are applied before and after each block, respectively. Let  denote the output of the  Transformer layer, where  is the number of tokens for each sample, and  is the dimension of each token. Note that , which corresponds to  patches of the original image and a single learnable classification token. Formally, we have

where  is the total number of layers in the Transformer. The classification token in  will be fed into a LN layer followed by a fully-connected layer for the final prediction. For simplicity, here we omit the details on the position embedding, which is unrelated to our main idea. No modification is performed on it in addition to the configurations of backbones.




\begin{figure*}[t]
\begin{center}
    \centerline{\includegraphics[width=1\columnwidth]{figs/feature_reuse.pdf}}
\caption{
        Illustration of the feature reuse mechanism. A layer-wise context embedding is learned based on the final representations output by the upstream model, i.e., , and integrated into the MLP block of each downstream Transformer layer.
    }
    \label{fig:feature_reuse}
    \end{center}
    \vspace{-2.5ex}
\end{figure*}


\textbf{Feature reuse.}
All the Transformers in DVT share the same goal of extracting discriminative representations for accurate recognition. Therefore, it is straightforward that downstream models should be learned on the basis of previously obtained deep features, rather than extracting features from scratch. The former is more efficient since the computation performed in an upstream model contributes to both itself and the successive models. To implement this idea, we propose a feature reuse mechanism (see: Figure \ref{fig:feature_reuse}). In specific, we leverage the image tokens output by the final layer of the upstream Transformer, i.e., , to learn a layer-wise embedding  for the downstream model: 

Herein,  consists of a sequence of operations starting with a LN-MLP (), which introduces nonlinearity and allows more flexible transformations. Then the image tokens are reshaped to the corresponding locations in the original image, upsampled and flattened to match the token number of the downstream model. Typically, we use a small  for an efficient . 

Consequently, the embedding  is injected into the downstream model, providing prior knowledge on recognizing the input image. Formally, we replace Eq. (\ref{eq:background_2}) by:

where  is concatenated with the intermediate tokens . We simply increase the dimension of LN and the first layer of MLP from  to . Since  is based on the upstream outputs  that have less tokens than , it actually concludes the context information of the input image for each token in . Therefore, we name  as the \emph{context embedding}. Besides, we do not reuse the classification token and pad zero for it in Eq. (\ref{eq:feature_reuse_2}), which we empirically find beneficial for the performance. Intuitively, Eqs. (\ref{eq:feature_reuse_1}) and (\ref{eq:feature_reuse_2}) allow training the downstream model to flexibly exploit the information within  on a per-layer basis, under the objective of minimizing the final recognition loss (Eq. (\ref{eq:objective})). This feature reuse formulation can also be interpreted as implicitly enlarging the depth of the model.



\begin{wrapfigure}{r}{9cm}
\begin{minipage}[t]{\linewidth}
    \centering
    \includegraphics[width=\textwidth]{figs/relationship_reuse.pdf}	
    \vskip -0.05in
    \caption{
        Illustration of the relationship reuse mechanism. We leverage the learned self-attention relationships from all upstream layers and attention heads, i.e., , to refine the downstream attention maps. The addition operation of logits is adopted. Note that  denotes the head number for multi-head self-attention.
    \label{fig:relationship_reuse}}  
    \end{minipage}
    \vskip -0.25in
\end{wrapfigure}
\textbf{Relationship reuse.}
A prominent advantage of vision Transformers is that their self-attention blocks enable integrating information across the entire image, which effectively models the long-range dependencies in the data. Typically, the models need to learn a group of attention maps at each layer to describe the relationships among tokens. Apart from the deep features mentioned above, the downstream models also have access to the self-attention maps produced in previous models. We argue that these learned relationships are also capable of being reused to facilitate the learning of downstream Transformers.



Given the input representation , the self-attention is performed as follows. First, the query, key and value matrices ,  and  are computed via linear projections:

where ,  and  are weight matrices. Then the attention map is calculated by a scaled dot-product operation with softmax to aggregate the values of all tokens, namely

Here  is the hidden dimension of  or , and  denotes the logits of the attention map. Note that we omit the details on the multi-head attention mechanism for clarity, where  may include multiple attention maps. Such a simplification does not affect the description of our method.



For relationship reuse, we first concatenate the attention logits produced by all layers of the upstream model (i.e., ):

where  and  denote the number of tokens and all attention maps in the upstream model, respectively. Typically, we have , where  is the number of heads for the multi-head attention and  is the number of layers. Then the downstream Transformer learns attention maps by leveraging both its own tokens and  simultaneously. Formally, we replace Eq. (\ref{eq:self_att_2}) by

where  is a transformation network that integrates the information provided by  to refine the downstream attention logits . The architecture of  is presented in Figure \ref{fig:relationship_reuse}, which includes a MLP for nonlinearity followed by an upsample operation to match the size of attention maps. For multi-head attention, the output dimension of the MLP will be set to the number of heads.


\begin{wrapfigure}{r}{5cm}
    \vskip -0.15in
    \begin{minipage}[t]{\linewidth}
    \centering
    \includegraphics[width=\textwidth]{figs/upsample.pdf}	
    \vskip -0.08in
    \caption{An example for the upsample operation in . \label{fig:upsample}}  
    \end{minipage}
    \vskip -0.15in
\end{wrapfigure}
Notably, Eq. (\ref{eq:relationship_reuse}) is a simple but flexible formulation. For one thing, each self-attention block in the downstream model has access to all the upstream attention heads in both shallow and deep layers, and hence can be trained to leverage multi-level relationship information on its own basis. For another, as the newly generated attention maps and the reused relationships are combined in logits, their relative importance can be automatically learned by adjusting the magnitude of logits. It is also worth noting that the regular upsample operation cannot be directly applied in . To illustrate this issue, we take upsampling a  () attention map to  () for example in Figure \ref{fig:upsample}. Since each of its rows and columns corresponds to  image tokens, we reshape the rows or columns back to , scale them to , and then flatten them to  vectors.

\subsection{Adaptive Inference}
\vspace{-1ex}
\label{sec:adaptive_inference}

As aforementioned, the proposed DVT framework progressively increases the number of tokens for each test sample and performs early-termination, such that ``easy'' and ``hard'' images can be processed using varying tokens with uneven computational cost, improving the overall efficiency. Specifically, at the  exit that produces the softmax prediction , the largest entry of , i.e.,  (defined as confidence \cite{huang2017multi, yang2020resolution, NeurIPS2020_7866}), is compared with a threshold . If , the inference will stop by adopting  as the output. Otherwise, the image will be represented using more tokens to activate the downstream Transformer. We always adopt a zero-threshold for the final Transformer.

The values of  are solved on the validation set. We assume a \emph{budgeted batch classification} \cite{huang2017multi} setting, where DVT needs to recognize a set of samples  within a given computational budget . Let  and  denote the accuracy and computational cost on  when using the thresholds . The optimal thresholds can be obtained by solving the following optimization problem:

Due to the non-differentiability, we solve this problem with the genetic algorithm \cite{whitley1994genetic} in this paper.




















%
 




\vspace{-1.5ex}
\section{Experiments}
\vspace{-1.5ex}
\label{sec:experiment}

In this section, we empirically validate the proposed DVT on ImageNet \cite{5206848} and CIFAR-10/100 \cite{krizhevsky2009learning}. Ablation studies and visualization are presented on ImageNet to give a deeper understanding of our method. Code and pre-trained models based on PyTorch are available at \url{https://github.com/blackfeather-wang/Dynamic-Vision-Transformer}. We also provide the implementation using the MindSpore framework and the models trained on a cluster of Ascend AI processors at \url{https://github.com/blackfeather-wang/Dynamic-Vision-Transformer-MindSpore}.




\textbf{Datasets.}
(1) ImageNet is a 1,000-class dataset from ILSVRC2012 \cite{5206848}, containing 1.2 million images for training and 50,000 images for validation. 
(2) CIFAR-10/100 datasets \cite{krizhevsky2009learning} contain 32x32 colored images in 10/100 classes. Both of them consist of 50,000 images for training and 10,000 images for testing. For all the three datasets, we adopt the same data pre-processing and data augmentation policy as \cite{He_2016_CVPR, 2016arXiv160806993H, huang2017multi}. In addition, we solve the confidence thresholds stated in Section~\ref{sec:adaptive_inference} on the training set, which we find achieves similar performance to adopting cross-validation. 

\textbf{Backbones.}
Our experiments are based on several state-of-the-art vision Transformers, namely T2T-ViT-12 \cite{yuan2021tokens}, T2T-ViT-14 \cite{yuan2021tokens}, and DeiT-small (w/o distillation) \cite{touvron2020training}. Unless otherwise specified, we deploy DVT with three exits, corresponding to representing the images as 7x7, 10x10 and 14x14 tokens\footnote{Although 4x4 tokens are also used as an example in Section \ref{sec:intro}, we find starting with 7x7 is more efficient.}. For fair comparisons, our implementation exploits the official code of the backbones, and adopts exactly the same training hyper-parameters. More training details can be found in Appendix A. The number of FLOPs is calculated using the \emph{fvcore}  toolkit provided by Facebook AI Research, which is also used in Detectron2 \cite{wu2019detectron2}, PySlowFast \cite{fan2020pyslowfast}, and ClassyVision \cite{adcock2019classy}. 



\textbf{Implementation details.}
For feature reuse, the hidden size and output size of the MLP in  are set to 128 and 48. In relationship reuse, for implementation efficiency, we share the same hidden state across the MLPs of all , such that  can be obtained at one time in concatenation by implementing a single large MLP, whose hidden size and output size are  and . Note that  is the head number of multi-head attention and  is the layer number.

\begin{figure*}[t]
\begin{center}
    \centerline{\includegraphics[width=\columnwidth]{results/t2t.pdf}}
    \vspace{-1ex}
    \caption{
        Top-1 accuracy v.s. GFLOPs on ImageNet. DVT is implemented on top of T2T-ViT-12/14.
    }
    \label{fig:t2t}
    \end{center}
    \vspace{-4ex}
\end{figure*}

\begin{figure}[t]
    \begin{center}
        \begin{minipage}{0.445\columnwidth}
            \centering
        \begin{footnotesize}
        \captionof{table}{The practical speed of DVT.}
        \vskip -0.075in 
        \label{tab:ImageNet_speed}
        \setlength{\tabcolsep}{2mm}{
\renewcommand\arraystretch{1.1}
        \resizebox{0.975\columnwidth}{!}{
        \begin{tabular}{c|cc}
        \toprule
        \multirow{2}{*}{Models} & \multicolumn{2}{c}{ImageNet (NVIDIA 2080Ti, bs=128)}  \\
        & Top-1 Acc. & Throughput   \\
        \midrule
        T2T-ViT-7 & 71.68\% & 1574 img/s \\
        DVT & \textbf{78.48\%} (\textcolor{blue}{6.80\%}) & 1574 img/s \\
        \midrule
        T2T-ViT-10 & 75.15\% & 1286 img/s \\
        DVT &\textbf{79.74\%} (\textcolor{blue}{4.59\%})& 1286 img/s \\
        \midrule
        T2T-ViT-12 & 76.74\% & 1121 img/s \\
        DVT &\textbf{80.43\%} (\textcolor{blue}{3.69\%})& 1128 img/s \\
        \midrule
        T2T-ViT-14 & 81.50\% & 619 img/s \\
        DVT & 81.50\% & \textbf{877 img/s} (\textcolor{blue}{1.42x})  \\
        \midrule
        T2T-ViT-19 & 81.93\% & 382 img/s \\
        DVT & 81.93\% & \textbf{666 img/s} (\textcolor{blue}{1.74x})  \\
        \bottomrule
        \end{tabular}}}
        \end{footnotesize}
        \end{minipage}
    \hspace{-0.065in}
    \begin{minipage}{0.555\columnwidth}
        \centering
    \begin{footnotesize}
    \captionof{table}{Performance of DVT on CIFAR-10/100.}
    \vskip -0.075in 
    \label{tab:cifar}
    \setlength{\tabcolsep}{2mm}{
\renewcommand\arraystretch{1.1}
    \resizebox{0.975\columnwidth}{!}{
    \begin{tabular}{c|cc|cc}
    \toprule

    \multirow{2}{*}{Models} & \multicolumn{2}{c}{CIFAR-10} & \multicolumn{2}{|c}{CIFAR-100} \\
    & Top-1 Acc. & GFLOPs  & Top-1 Acc. & GFLOPs \\
    \midrule
    T2T-ViT-10 & 97.21\% & {1.53} & 85.44\% & 1.53 \\
    DVT & 97.21\% & \textbf{0.50} (\textcolor{blue}{3.1x}) & 85.45\% & \textbf{0.54} (\textcolor{blue}{2.8x}) \\
    \midrule
    T2T-ViT-12 & 97.45\% & {1.78} & 86.23\% & 1.78 \\
    DVT & 97.46\% & \textbf{0.52} (\textcolor{blue}{3.4x}) & 86.26\% & \textbf{0.61} (\textcolor{blue}{2.9x}) \\
    \midrule
    T2T-ViT-14 & 98.19\% & {4.80} & 89.10\% & 4.80 \\
    DVT & 98.19\% & \textbf{0.77} (\textcolor{blue}{6.2x}) & 89.11\% & \textbf{1.62} (\textcolor{blue}{3.0x}) \\
    \midrule
    T2T-ViT-19 & 98.43\% & {8.50} & 89.37\% & 8.50 \\
    DVT & 98.43\% & \textbf{1.44} (\textcolor{blue}{5.9x}) & 89.38\% & \textbf{1.74} (\textcolor{blue}{4.9x}) \\
    \midrule
    T2T-ViT-24 & 98.53\% & {13.69} & 89.62\% & 13.69 \\
    DVT & 98.53\% & \textbf{1.49} (\textcolor{blue}{9.2x}) & 89.63\% & \textbf{1.86} (\textcolor{blue}{7.4x}) \\
    \bottomrule
    \end{tabular}}}
    \end{footnotesize}
    \end{minipage}
    \end{center}
    \vskip -0.3in
 \end{figure}






\begin{figure*}[t]
    \begin{center}
        \begin{minipage}{0.49\columnwidth}
            \hspace{-0.075in}
            \includegraphics[width=1.01\columnwidth]{results/deit.pdf}
            \vskip -0.12in
            \caption{Performance of DeiT-based DVT on ImageNet. DeiT-small is used as the backbone.
        }\label{fig:deit}
    \end{minipage}
    \hspace{0.01in}
    \begin{minipage}{0.49\columnwidth}
        \hspace{-0.075in}
\includegraphics[width=1.01\columnwidth]{results/abl_reuse.pdf}
        \vskip -0.12in
        \caption{Performance of the DVT based on T2T-ViT-12 with and without the reuse mechanisms. 
    }\label{fig:abl_reuse}
    \end{minipage}
    \end{center}
    \vskip -0.245in
 \end{figure*}



\vspace{-1.5ex}
\subsection{Main Results}
\vspace{-1.5ex}

\textbf{Results on ImageNet}
are shown in Figures \ref{fig:t2t} and \ref{fig:deit}, where T2T-ViT \cite{yuan2021tokens} and DeiT \cite{touvron2020training} are implemented as backbones respectively. As stated in Section \ref{sec:adaptive_inference}, we vary the average computational budget, solve the confidence thresholds, and evaluate the corresponding validation accuracy. The performance of DVT is plotted in gray curves, with the best accuracy under each budget plotted in black curves. We also compare our method with several highly competitive baselines, i.e., TNT \cite{han2021transformer}, LocalViT \cite{li2021localvit}, CrossViT \cite{chen2021crossvit}, PVT \cite{wang2021pyramid}, ViT \cite{dosovitskiy2021an} and ResNet \cite{He_2016_CVPR}. It can be observed that DVT consistently reduces the computational cost of the backbones. For example, DVT achieves the 82.3\% accuracy with 3.6x less FLOPs compared with the vanilla T2T-ViT. When the budget ranges among 0.5-2 GFLOPs, DVT has 1.7-1.9x less computation than T2T-ViT with the same performance. Notably, our method can flexibly attain all the points on each curve by simply adjusting the values of confidence thresholds with a single DVT.


\textbf{Practical efficiency of DVT}.
We test the actual speed of DVT on a NVIDIA 2080Ti GPU under a batch inference setting, where a mini-batch of data is fed into the model at a time. After inferring each Transformer, the samples that meet the early-termination criterion will exit, with the remaining images fed into the downstream Transformer. The results are presented in Table \ref{tab:ImageNet_speed}. Here we adopt a two-exit DVT based on T2T-ViT-12 using 7x7 and 14x14 tokens, which we find more efficient in practice. All other implementation details remain unchanged. One can observe that DVT improves the accuracy of small models (T2T-ViT-7/10/12) by 3.7-6.8\% with the same inference speed, while accelerates the inference of the large T2T-ViT-14/19 models by 1.4-1.7x without sacrificing performance.


\textbf{Results on CIFAR}
are presented in Table \ref{tab:cifar}. Following the common practice \cite{dosovitskiy2021an, yuan2021tokens, han2021transformer, touvron2020training}, we resize the CIFAR images to 224x224, and fine-tune the T2T-ViT and DVT models in Figure \ref{fig:t2t}. The official code and training configurations provided by \cite{yuan2021tokens} are utilized. We report the computational cost of DVT when it achieves the competitive performance with baselines. Our proposed method is shown to consume 3-9x less computation compared with T2T-ViT.


\begin{table*}[!h]
    \centering
    \vskip -0.075in
    \begin{footnotesize}
    \captionof{table}{Comparisons between DVT and three state-of-the-art methods for improving the computational efficiency of vision Transformers, i.e., Data distillation \cite{touvron2020training}, DynamicViT \cite{rao2021dynamicvit} and Patch slimming \cite{tang2021patch}. Both DVT and the baselines are implemented on top of DeiT-small. Since the computational cost of DVT can be adjusted online, we match the FLOPs or the accuracy of DVT with the baselines, respectively, to see the difference.}
    \vskip -0.08in 
    \label{tab:vsSOTA}
    \setlength{\tabcolsep}{1mm}{
\renewcommand\arraystretch{1.1}
    \resizebox{\columnwidth}{!}{
    \begin{tabular}{c|c|ccc|ccc|ccc}
    \toprule
    & DeiT-small & Data distillation & \multicolumn{2}{c|}{DVT} & DynamicViT & \multicolumn{2}{c|}{DVT} & Patch slimming & \multicolumn{2}{c}{DVT}\\
    \midrule
    Top-1 Acc. & 79.80\% & 81.20\% & 81.20\% & \textbf{81.67\%} & 79.30\% & 79.30\% & \textbf{80.40\%} & 79.40\% & 79.40\% & \textbf{79.81\%} \\
    GFLOPs/image & 4.61 & 4.63 & \textbf{3.61} & 4.63 & 2.90 & \textbf{2.37} & 2.90 & 2.60 & \textbf{2.41} & 2.60 \\
    
    \bottomrule
    \end{tabular}}}
    \end{footnotesize}
    \vskip -0.15in
\end{table*}

\textbf{Comparisons with SOTA baselines.}
In Table \ref{tab:vsSOTA}, we compare DVT with several recently proposed approaches for facilitating efficient vision Transformers on ImageNet. Both knowledge distillation (KD) \cite{touvron2020training} and patch pruning based methods \cite{rao2021dynamicvit, tang2021patch} are considered. One can observe that DVT outperforms the baselines with similar FLOPs, or has significantly lower computational cost with the same accuracy. Besides, one can expect that DVT is compatible with these techniques, i.e., DVT can also be trained with KD to further boost the accuracy or leverage patch pruning to reduce the FLOPs. 


\begin{wraptable}{r}{0.66\columnwidth}
    \centering
    \vskip -0.025in
    \begin{footnotesize}
    \captionof{table}{DVT v.s. existing multi-exit models with the same adaptive inference strategy. The accuracy under each budget is reported.}
    \vskip -0.08in 
    \label{tab:vsCNN}
    \setlength{\tabcolsep}{1mm}{
\renewcommand\arraystretch{1.05}
    \resizebox{0.66\columnwidth}{!}{
    \begin{tabular}{c|cccccc}
    \toprule
    \multirow{2}{*}{Networks}& \multicolumn{6}{c}{Top-1 Acc.} \\
     & 0.75G & 1.00G & 1.25G & 1.50G & 1.75G & 2.00G \\
    \midrule
    MSDNet \cite{huang2017multi} & 69.82\% & 71.24\% & 72.73\% & 73.66\% & 73.99\% & 74.20\% \\
    IMTA-MSDNet \cite{li2019improved} & 70.84\% & 71.92\% & 73.41\% & 74.31\% & 74.64\% & 74.94\% \\
    RANet \cite{yang2020resolution} & 70.48\% & 72.24\% & 73.57\% & 74.56\% & 75.02\% & 75.10\%  \\
    DVT (T2T-ViT-12) & \ \textbf{73.70\%} & \ \textbf{76.22\%} & \ \textbf{77.89\%} & \ \textbf{78.89\%}  &\ \textbf{79.47\%} & \ \textbf{79.75\%} \\
    \bottomrule
    \end{tabular}}}
    \end{footnotesize}
    \vskip -0.2in
\end{wraptable}
\textbf{Comparisons with existing early-exiting networks}
are presented in Table \ref{tab:vsCNN}. We adopt the same adaptive strategy (see: Section \ref{sec:adaptive_inference}) for all the baselines. The Top-1 accuracy on ImageNet under different computational budgets is reported. One can observe that DVT significantly outperforms these baselines.






\vspace{-2.3ex}
\subsection{Ablation Study}
\vspace{-1.7ex}

\begin{wraptable}{r}{0.63\columnwidth}
    \centering
    \vskip -0.23in
    \begin{footnotesize}
    \captionof{table}{Effects of feature (F) and relationship (R) reuse. The percentages in brackets denote the additional computation compared to baselines involved by the reuse mechanisms.}
    \vskip -0.075in 
    \label{tab:effect_reuse}
    \setlength{\tabcolsep}{1mm}{
\renewcommand\arraystretch{1.05}
    \resizebox{0.63\columnwidth}{!}{
    \begin{tabular}{cc|cccccc}
    \toprule
    \multicolumn{2}{c|}{Reuse} & \multicolumn{2}{c}{1 Exit (7x7)} & \multicolumn{2}{c}{2 Exit (10x10)} & \multicolumn{2}{c}{3 Exit (14x14)}\\
    F&R & Top-1 Acc. & GFLOPs & Top-1 Acc. & GFLOPs & Top-1 Acc. & GFLOPs \\
    \midrule
    & & \textbf{70.33\%} & 0.47 & 73.54\% & 1.37 & 76.74\% & 3.15 \\
    \cmark& & 69.42\% & 0.47 & 75.31\% & 1.43 & 79.21\% & 3.31 \\
    &\cmark & 69.03\% & 0.47 & 75.34\% & 1.41 & 78.86\% & 3.34 \\
    \cmark&\cmark & 69.04\% & 0.47 & \textbf{75.65\%} & 1.46 & \textbf{80.00\%} & 3.50 \\
    \bottomrule
    \end{tabular}}}
    \end{footnotesize}
    \vskip -0.15in
\end{wraptable}
\textbf{Effectiveness of feature and relationship reuse.}
We conduct experiments by ablating one or both of the reuse mechanisms. For a clear comparison, we first deactivate the early-termination, and report the accuracy and GFLOPs corresponding to each exit in Table \ref{tab:effect_reuse}. The three-exit DVT based on T2T-ViT-12 is considered. One can observe that both the two reuse mechanisms are able to significantly boost the accuracy of DVT at the 2 and 3 exits with at most 6\% additional computation, while they are compatible with each other to further improve the performance. We also find that involving computation reusing slightly hurts the accuracy at the 1 exit, which may be attributed to the compromise made by the first Transformer for downstream models. However, once the early-termination is adopted, this difference only results in trivial disadvantage when the computational budget is very small, as shown in Figure \ref{fig:abl_reuse}. DVT outperforms the baseline significantly in most cases.


\textbf{Design choices for the reuse mechanisms.}
Here we study the design of the feature and relationship reuse mechanisms. For experimental efficiency, we consider a two-exit DVT based on T2T-ViT-12 using 7x7 and 10x10 tokens, while enlarge the batch size and the initial learning rate by 4 times. Such a training setting slightly degrades the accuracy of DVT, but it is still reliable to reflect the difference between different design variants. We deactivate early-termination, and report the performance of each exit. Notably, as the FLOPs of 1 exit remain unchanged (i.e., 0.47G), we do not present it.

We consider four variants of feature reuse in Table \ref{tab:abl_feat_reuse}: 
(1) reusing features from the corresponding upstream layer instead of the final layer; 
(2) reusing classification token; 
(3) only performing feature reuse in the first layer of the downstream model; 
(4) removing the LN in . 
One can see that taking final tokens of the upstream model and reusing them in each downstream layer are both important.


{Ablation results for relationship reuse}
are presented in Table \ref{tab:abl_rela_reuse}. We consider four variants as well: 
(1) only reusing the attention logits from the corresponding upstream layer; 
(2) only reusing the attention logits from the final upstream layer; 
(3) replacing the MLP by a linear layer in ; 
(4) adopting naive upsample operation instead of what is shown in Figure \ref{fig:upsample}; 
The results indicate that it is beneficial to enable each downstream layer to flexibly reuse all upstream attention logits. Besides, naive upsampling significantly hurts the performance.



\begin{figure}[t]
    \begin{center}
        \begin{minipage}{0.485\columnwidth}
            \centering
        \begin{footnotesize}
        \captionof{table}{Ablation studies for feature reuse.}
        \vskip -0.075in 
        \label{tab:abl_feat_reuse}
        \setlength{\tabcolsep}{1mm}{
\renewcommand\arraystretch{1.025}
        \resizebox{0.975\columnwidth}{!}{
            \begin{tabular}{c|ccc}
            \toprule
        
            \multirow{2}{*}{Ablation} & 1 Exit (7x7) & \multicolumn{2}{c}{2 Exit (10x10)} \\
            & Top-1 Acc.  & Top-1 Acc. & GFLOPs \\
            \midrule
            w/o reuse & \textbf{70.08\%} & 73.61\% & 1.37 \\
Layer-wise feature reuse & 69.84\% & 74.31\% & 1.43  \\
            Reuse classification token & 69.79\% & 74.70\% & 1.43 \\
            Remove & 69.33\% & 74.73\% & 1.38  \\
            Remove LN in  & 69.63\% & 75.05\% & 1.42 \\
            \midrule
            Ours & 69.44\%   & \textbf{75.23\%} & {1.43} \\
            \bottomrule
        \end{tabular}}}
        \end{footnotesize}
        \end{minipage}
    \hspace{-0.065in}
    \begin{minipage}{0.515\columnwidth}
        \centering
    \begin{footnotesize}
    \captionof{table}{Ablation studies for relationship reuse.}
    \vskip -0.075in 
    \label{tab:abl_rela_reuse}
    \setlength{\tabcolsep}{1mm}{
\renewcommand\arraystretch{1.025}
        \resizebox{0.975\columnwidth}{!}{
            \begin{tabular}{c|ccc}
            \toprule
            \multirow{2}{*}{Ablation} & 1 Exit (7x7) & \multicolumn{2}{c}{2 Exit (10x10)} \\
            & Top-1 Acc.  & Top-1 Acc. & GFLOPs \\
            \midrule
            w/o reuse & \textbf{70.08\%} & 73.61\% & 1.37 \\
Layer-wise relationship reuse& 69.63\% & 73.89\% & 1.38  \\
            Reuse final-layer relationships& 69.25\% & 74.31\% & 1.39  \\
            MLPLinear& 69.20\% & 73.84\% & 1.38  \\
            Naive upsample & 69.60\% & 73.34\% & 1.41  \\
\midrule
            Ours & 69.50\%   & \textbf{74.91\%} & {1.41} \\
            \bottomrule
        \end{tabular}}}
        \end{footnotesize}
        \end{minipage}
    \end{center}
    \vskip -0.2in
 \end{figure}


\begin{wraptable}{r}{0.5\columnwidth}
    \centering
\begin{footnotesize}
    \captionof{table}{Comparisons of early-termination criterions. The accuracy under each budget is reported.}
    \vskip -0.075in 
    \label{tab:early_termi}
    \setlength{\tabcolsep}{1mm}{
\renewcommand\arraystretch{1.1}
    \resizebox{0.5\columnwidth}{!}{
    \begin{tabular}{c|cccc}
    \toprule
    \multirow{2}{*}{Ablation}& \multicolumn{4}{c}{Top-1 Acc.} \\
     & 0.75G & 1.00G & 1.25G & 1.50G \\
    \midrule
    Randomly Exit & 70.19\% & 71.66\% & 72.61\% & 73.59\%  \\
    Entropy-based & 73.41\% & 75.21\% & 77.08\% & 78.40\%   \\
    Confidence-based (ours) & \ \textbf{73.70\%} & \ \textbf{76.22\%} & \ \textbf{77.89\%} & \ \textbf{78.89\%}   \\
    \bottomrule
    \end{tabular}}}
    \end{footnotesize}
    \vskip -0.15in
\end{wraptable}
\textbf{Early-termination criterion.} 
We vary the criterion for adaptive inference based on DVT (T2T-ViT-12) and report the accuracy under several computational budgets in Table \ref{tab:early_termi}. Two variants are considered:
(1) adopting the entropy of softmax prediction to determine whether to exit \cite{teerapittayanon2016branchynet};
(2) performing random exiting with the same exit proportion as DVT.
The simple but effective confidence-based criterion achieves better performance than both of them.




\begin{wraptable}{r}{0.64\columnwidth}
    \centering
    \vskip -0.15in
    \begin{footnotesize}
    \captionof{table}{Effects of applying the adaptive depth mechanism to vision Transformers. The accuracy under each budget is reported.}
    \vskip -0.075in 
    \label{tab:adaptive_depth}
    \setlength{\tabcolsep}{1mm}{
\renewcommand\arraystretch{1.1}
    \resizebox{0.64\columnwidth}{!}{
    \begin{tabular}{c|ccccc}
    \toprule
    \multirow{2}{*}{Ablation}& \multicolumn{5}{c}{Top-1 Acc.} \\
     & 2.00G & 2.50G & 3.00G & 3.50G & 4.00G \\
    \midrule
    T2T-ViT-14 with adaptive depth & 76.09\% & 78.88\% & 79.46\% & 79.54\% & 79.55\%  \\
    DVT (T2T-ViT-14) & \ \textbf{79.24\%} & \ \textbf{80.61\%} & \ \textbf{81.47\%} & \ \textbf{82.10\%}  & \ \textbf{82.42\%}  \\
    \bottomrule
    \end{tabular}}}
    \end{footnotesize}
    \vskip -0.2in
\end{wraptable}
\textbf{Vision Transformers with adaptive depth.} 
We test applying the adaptive depth paradigm \cite{huang2017multi, yang2020resolution} to ViT in Table \ref{tab:adaptive_depth}. Two classifiers are uniformly added to the intermediate layers of T2T-ViT-14, and the early-exiting is performed with the three exits in the same way as DVT. One can observe that the layer-adaptive T2T-ViT achieves significantly lower accuracy than DVT using identical computational budgets. This inferior performance may be alleviated by improving the network architecture, as shown in \cite{huang2017multi}. 





\begin{figure*}[t]
    \begin{center}
    \begin{minipage}{0.64\columnwidth}
\includegraphics[width=1\columnwidth]{results/visualization.pdf}	
        \vskip -0.075in
        \caption{Visualization of the ``easy'' and ``hard'' samples in DVT.
    }\label{fig:vis_sample}
\end{minipage}
    \hspace{0.01in}
    \begin{minipage}{0.345\columnwidth}
\hspace{-0.05in}
        \includegraphics[width=1\columnwidth]{results/visual_num.pdf}
        \vskip -0.125in
\caption{Numbers of images exiting at different exits with varying computational budgets.
    }\label{fig:vis_num}
    \end{minipage}
    \end{center}
    \vskip -0.25in
 \end{figure*}



\vspace{-1.5ex}
\subsection{Visualization}
\vspace{-1.5ex}
Figure \ref{fig:vis_sample} shows the images that are first correctly classified at the 1 and 3 exits of the DVT (T2T-ViT-12). The former are recognized as ``easy'' samples, while the later are considered to be ``hard''. One can observe that ``easy'' samples usually depict the recognition objectives in clear and canonical poses and sufficiently large resolution. On the contrary, ``hard'' samples may contain complex scenes and non-typical poses or only include a small part of the objects, and require a finer representation using more tokens. Figure \ref{fig:vis_num} presents the numbers of images that exit at different exits when the computational budget increases. The plot shows that the accuracy of DVT is significantly improved with more images exiting later, which is achieved by changing the confidence thresholds online.


 



\vspace{-2ex}
\section{Conclusion}
\vspace{-2ex}

In this paper, we sought to optimally configure a proper number of tokens for each individual image in vision Transformers, and hence proposed the \emph{Dynamic Vision Transformer} (DVT) framework. DVT processes each test input by sequentially activating a cascade of Transformers using increasing numbers of tokens, until an appropriate token number is reached (measured by the prediction confidence). We further introduce the feature and relationship reuse mechanisms to facilitate efficient computation reuse. Extensive experiments indicate that DVT significantly improves the computational efficiency on top of state-of-the-art vision Transformers, both theoretically and empirically. 






















%
 
\vspace{-1.5ex}
\section*{Acknowledgements}
\vspace{-1.5ex}
This work is supported in part by the National Science and Technology Major Project of the Ministry of Science and Technology of China under Grants 2018AAA0100701, the National Natural Science Foundation of China under Grants 61906106 and 62022048, and Huawei Technologies Ltd. In particular, we appreciate the valuable discussions with Chenghao Yang.

\bibliographystyle{plain}
\bibliography{IEEEabrv,IEEEtran}






\newpage
\appendix
\section*{Appendix}

\section{Training Details}

The proposed DVT framework is implemented based on the official code of T2T-ViT\footnote{\url{https://github.com/yitu-opensource/T2T-ViT}} \cite{yuan2021tokens} and DeiT\footnote{\url{https://github.com/facebookresearch/deit}} \cite{touvron2020training} when these two models are used as backbones, respectively. The training of DVT follows exactly the same configurations as the backbones, which are also recommended by their official implementations. The details on optimizer, learning rate schedule, batch size and other hyper-parameters can be easily found in their papers or code. Note that a number of regularization and data augmentation techniques are exploited, including RandAugment \cite{cubuk2020randaugment}, Random Erasing \cite{zhong2020random}, Label Smoothing \cite{szegedy2016rethinking}, Mixup \cite{zhang2018mixup}, Cutmix \cite{yun2019cutmix}, and stochastic depth \cite{huang2016deep}. We train all the models with 8 NVIDIA V100 GPUs.




\begin{figure}[h]
  \begin{center}
      \begin{minipage}{0.72\columnwidth}
          \centering
      \begin{footnotesize}
      \captionof{table}{Effects when the location for performing feature reuse varies.}
      \vskip -0.075in 
      \label{tab:appendix_1}
      \setlength{\tabcolsep}{1mm}{
\renewcommand\arraystretch{1.025}
      \resizebox{0.975\columnwidth}{!}{
          \begin{tabular}{c|ccc}
          \toprule
      
          \multirow{2}{*}{Ablation} & 1 Exit (7x7) & \multicolumn{2}{c}{2 Exit (10x10)} \\
          & Top-1 Acc.  & Top-1 Acc. & GFLOPs \\
          \midrule
          w/o reuse & \textbf{70.08\%} & 73.61\% & 1.37 \\
Reuse on shallow half of downstream layers & 69.67\%  &  75.02\% &  1.40  \\
          Reuse on deep half of downstream layers &  69.94\% & 74.57\%  &  1.40 \\
          \midrule
          Reuse on all downstream layers & 69.44\%  & \textbf{75.23\%} & {1.43} \\
          \bottomrule
      \end{tabular}}}
      \end{footnotesize}
      \end{minipage}
      \vskip 0.15in
\begin{minipage}{0.72\columnwidth}
      \centering
  \begin{footnotesize}
  \captionof{table}{Effects when the location for performing relationship reuse varies.}
  \vskip -0.075in 
  \label{tab:appendix_2}
  \setlength{\tabcolsep}{1mm}{
\renewcommand\arraystretch{1.025}
      \resizebox{0.975\columnwidth}{!}{
          \begin{tabular}{c|ccc}
          \toprule
          \multirow{2}{*}{Ablation} & 1 Exit (7x7) & \multicolumn{2}{c}{2 Exit (10x10)} \\
          & Top-1 Acc.  & Top-1 Acc. & GFLOPs \\
          \midrule
          w/o reuse & \textbf{70.08\%} & 73.61\% & 1.37 \\
Reuse on shallow half of downstream layers & 69.72\%  & 74.89\%  &  1.40  \\
          Reuse on deep half of downstream layers & 70.00\%  &  73.68\% &  1.40 \\
          \midrule
          Reuse on all downstream layers & 69.50\%   & \textbf{74.91\%} & {1.41} \\
          \bottomrule
      \end{tabular}}}
      \end{footnotesize}
      \end{minipage}
      \vskip 0.15in
      \begin{minipage}{0.8\columnwidth}
        \centering
    \begin{footnotesize}
    \captionof{table}{Effects of taking attention logits from varying upstream layers.}
    \vskip -0.075in 
    \label{tab:appendix_3}
    \setlength{\tabcolsep}{1mm}{
\renewcommand\arraystretch{1.025}
    \resizebox{0.975\columnwidth}{!}{
        \begin{tabular}{c|ccc}
        \toprule
    
        \multirow{2}{*}{Ablation} & 1 Exit (7x7) & \multicolumn{2}{c}{2 Exit (10x10)} \\
        & Top-1 Acc.  & Top-1 Acc. & GFLOPs \\
        \midrule
        w/o reuse & \textbf{70.08\%} & 73.61\% & 1.37 \\
Reuse relationships from shallow half of upstream layers & 69.93\% & 74.67\%  & 1.40 \\
        Reuse relationships from deep half of upstream layers & 69.55\%  & 74.58\%  & 1.40 \\
        \midrule
        Reuse relationships from all upstream layers & 69.50\%  & \textbf{74.91\%} & {1.41} \\
        \bottomrule
    \end{tabular}}}
    \end{footnotesize}
    \end{minipage}
  \end{center}
  \vskip -0.1in
\end{figure}

\section{Additional Results}
\textbf{Which downstream layers benefit more from reuse?} 
To shed light on the layer-wise reuse paradigm in the downstream model, we test performing feature or relationship reuse only in the shallow/deep half of downstream layers. The same experimental protocol as ablating the design of reuse mechanisms is adopted. The results are shown in Tables \ref{tab:appendix_1} and \ref{tab:appendix_2}. Obviously, it is more important to reuse upstream features/relationships at the shallow layers. This phenomenon indicates that the main effects of the proposed reuse mechanisms lie in helping the first several transformer layers to rapidly extract discriminative representations or to learn accurate attention maps. The successive layers focus more on further improving the shallow features, while less on leveraging upstream information, which may have been effectively integrated into the shallow layers.


\textbf{Which upstream layers contribute more to relationship reuse?} 
In Table \ref{tab:appendix_3}, we further test only taking the attention logits from the shallow/deep half of upstream layers in relationship reuse. One can observe that both shallow and deep relationships are important for boosting the accuracy of the downstream model. In addition, it is interesting that reusing more relationships only slightly improves the performance. We attribute this to the redundancy within the learned attention logits from different layers of the upstream model.


\begin{figure*}[t]
  \hskip -0.1in
  \begin{center}
  \centerline{\includegraphics[width=\columnwidth]{results/c10.pdf}}
  \vspace{-1ex}
  \caption{
      Top-1 accuracy v.s. GFLOPs on CIFAR-10. DVT is implemented on top of T2T-ViT-12/14.
  }
  \label{fig:appendix_1}
  \end{center}
  \vspace{-4ex}
\end{figure*}




\begin{figure*}[t]
  \hskip -0.1in
  \begin{center}
  \centerline{\includegraphics[width=\columnwidth]{results/c100.pdf}}
  \vspace{-1ex}
  \caption{
      Top-1 accuracy v.s. GFLOPs on CIFAR-100. DVT is implemented on top of T2T-ViT-12/14.
  }
  \label{fig:appendix_2}
  \end{center}
  \vspace{-4ex}
\end{figure*}




\begin{figure*}[!t]
  \hskip -0.1in
  \begin{center}
  \centerline{\includegraphics[width=0.5\columnwidth]{results/speed.pdf}}
  \vspace{-1ex}
  \caption{
      Top-1 accuracy v.s. throughput on ImageNet. The results are obtained on NVIDIA 2080Ti GPU with a batch size of 128.
  }
  \label{fig:appendix_3}
  \end{center}
  \vspace{-4ex}
\end{figure*}


\textbf{Top-1 accuracy v.s. GFLOPs curves on CIFAR-10/100} 
are presented in Figures \ref{fig:appendix_1} and \ref{fig:appendix_2}, respectively, corresponding to the results reported in Table 3 of the paper.


\textbf{Top-1 accuracy v.s. throughput curves on ImageNet} 
are presented in Figures \ref{fig:appendix_3} corresponding to the results reported in Table 2 of the paper.




\end{document}