\documentclass{article}









\usepackage[nonatbib,preprint]{neurips_2018}


\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{microtype}      \usepackage{xcolor}
\usepackage{url}
\usepackage{verbatim} \usepackage{graphicx}
\usepackage{caption} 
\usepackage{multirow}
\usepackage[linesnumbered,ruled]{algorithm2e}
\usepackage{xspace}
\usepackage{epsfig}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{times}
\usepackage{xr}
\usepackage{bbm}
\usepackage{bm}
\usepackage{subcaption}
\usepackage{enumitem}
\usepackage{hyperref}       

\usepackage{enumitem}
\setlist[enumerate]{noitemsep, topsep=0.5\topsep}
\setlist[description]{noitemsep, topsep=0.5\topsep}
\setlist[itemize]{noitemsep, topsep=0.5\topsep}

\newcommand{\note}[1]{{{\textcolor{blue}{[note: #1]}}}}
\newcommand{\jure}[1]{{{\textcolor{red}{[Jure: #1]}}}}
\newcommand{\rex}[1]{{{\textcolor{magenta}{[Rex: #1]}}}}
\newcommand{\chris}[1]{{{\textcolor{orange}{[Christopher: #1]}}}}
\newcommand{\jiaxuan}[1]{{{\textcolor{green}{[Jiaxuan: #1]}}}}
\newcommand{\xiang}[1]{{{\textcolor{cyan}{[Xiang: #1]}}}}
\newcommand{\will}[1]{{{\textcolor{purple}{[Will: #1]}}}}

\newcommand{\xhdr}[1]{{\noindent\bfseries #1}.}
\newcommand{\red}[1]{{\textcolor{red}{#1}}}
\newcommand{\CITE}{{\textcolor{red}{[CITE]}}}
\newcommand{\name}{\textsc{DiffPool}\xspace}
\newcommand{\gnn}{\textrm{GNN}}

\newcommand{\V}{\mathcal{V}}
\newcommand{\E}{\mathcal{E}}
\newcommand{\R}{\mathbb{R}}



\newcommand{\nedge}{k}
\newcommand{\mb}{\mathbf}
\newcommand{\cut}[1]{}
\newcommand{\casc}{{\mathbf{t}}}
\newcommand{\alphs}{{\mathbf{A}}}
\newtheorem{proposition}{Proposition}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\newtheorem{lemma}{Lemma}
\newtheorem{observation}{\textbf{Observation}}
\newcommand{\xsketch}{\noindent {\it Proof Sketch.}}
\newcommand{\netinf}{{\textsc{Net\-Inf}}\xspace}
\newcommand{\multitree}{{\textsc{Multi\-Tree}}\xspace}
\newcommand{\netrate}{{\textsc{Net\-Rate}}\xspace}
\newcommand{\connie}{{\textsc{Co\-nNIe}}\xspace}
\newcommand{\maxinf}{{\textsc{Max\-Inf}}\xspace}
\newcommand{\expo}{{\textsc{Exp}}\xspace}
\newcommand{\pow}{{\textsc{Pow}}\xspace}
\newcommand{\ray}{{\textsc{Ray}}\xspace}
\newcommand{\eg}{\emph{e.g.}}
\newcommand{\ie}{\emph{i.e.}}
\newcommand{\unobs}{{\infty}}
\newcommand\T{\rule{0pt}{2.6ex}}
\newcommand\B{\rule[-1.2ex]{0pt}{0pt}}
\DeclareMathOperator*{\argmax}{argmax}


\usepackage{pifont}
\newcommand{\cmark}{\ding{51}}\newcommand{\xmark}{\ding{55}}

\newcommand{\etal}{\textit{et al}.~}


\newcommand{\ba}{Barab\'asi-Albert }
\newcommand{\er}{Erd\H{o}s-R\'enyi}
\newcommand{\angstrom}{\textup{\AA}}
\newcommand{\mmd}{\mathrm{MMD}}
\newcommand{\graphrnnmlp}{GraphRNN-S}
\newcommand{\graphrnnrnn}{GraphRNN}
 \usepackage{todonotes}
\usepackage{enumitem}

\title{Hierarchical Graph Representation Learning with Differentiable Pooling}




\author{
Rex Ying\\
\texttt{rexying@stanford.edu} \\
Stanford University
\And 
Jiaxuan You\\
\texttt{jiaxuan@stanford.edu} \\
Stanford University
\And 
Christopher Morris \\
\texttt{christopher.morris@udo.edu} \\
TU Dortmund University
\And 
Xiang Ren\\
\texttt{xiangren@usc.edu} \\
University of Southern California
\And 
William L. Hamilton\\
\texttt{wleif@stanford.edu} \\
Stanford University
\And
Jure Leskovec\\
\texttt{jure@cs.stanford.edu} \\
Stanford University
}

\begin{document}


\maketitle


\begin{abstract}
Recently, graph neural networks (GNNs) have revolutionized the field of graph representation learning through effectively learned node embeddings, and achieved state-of-the-art results in tasks such as node classification and link prediction. However, current GNN methods are inherently {\em flat} and do not learn {\em hierarchical} representations of graphs---a limitation that is especially problematic for the task of graph classification, where the goal is to predict the label associated with an entire graph.
Here we propose \name, a differentiable graph pooling module that can generate hierarchical representations of graphs and can be combined with various graph neural network architectures in an end-to-end fashion. 
\name learns a differentiable soft cluster assignment for nodes at each layer of a deep GNN, mapping nodes to a set of clusters, which then form the coarsened input for the next GNN layer.
Our experimental results show that combining existing GNN methods with \name\ yields an average improvement of -- accuracy on graph classification benchmarks, compared to all existing pooling approaches, achieving a new state-of-the-art on four out of five benchmark data sets.   
\end{abstract}
%
 \section{Introduction}
\label{sec:intro}
In recent years there has been a surge of interest in developing graph neural networks (GNNs)---general deep learning architectures that can operate over graph structured data, such as social network data \cite{hamilton2017inductive,kipf2017semi,Vel+2018} or graph-based representations of molecules \cite{dai2016discriminative,Duv+2015,Gil+2017}.
The general approach with GNNs is to view the underlying graph as a computation graph and learn neural network primitives that generate individual node embeddings by passing, transforming, and aggregating node feature information across the graph~\cite{Gil+2017,hamilton2017inductive}.
The generated node embeddings can then be used as input to any differentiable prediction layer, e.g., for node classification \cite{hamilton2017inductive} or link prediction \cite{Sch+2017}, and the whole model can be trained in an end-to-end fashion. 




However, a major limitation of current GNN architectures is that they are inherently {\em flat} as they only propagate information across the edges of the graph and are unable to infer and aggregate the information in a \textit{hierarchical} way. 
For example, in order to successfully encode the graph structure of organic molecules, one would ideally want to encode the local molecular structure (e.g., individual atoms and their direct bonds) as well as the coarse-grained structure of the molecular graph (e.g., groups of atoms and bonds representing functional units in a molecule).
This lack of hierarchical structure is especially problematic for the task of graph classification, where the goal is to predict the label associated with an \textit{entire graph}. When applying GNNs to graph classification, the standard approach is to generate embeddings for all the nodes in the graph and then to {\em globally pool} all these node embeddings together, e.g., using a simple summation or neural network that operates over sets \cite{dai2016discriminative,Duv+2015,Gil+2017,Li+2016}. This global pooling approach ignores any hierarchical structure that might be present in the graph, and it prevents researchers from building effective GNN models for predictive tasks over entire graphs.







Here we propose \name, a differentiable graph pooling module that can be adapted to various graph neural network architectures in an hierarchical and end-to-end fashion (Figure~\ref{fig:illustration}). 
\name allows for developing deeper GNN models that can learn to operate on hierarchical representations of a graph. We develop a graph analogue of the spatial pooling operation in CNNs \cite{krizhevsky2012imagenet}, which allows for deep CNN architectures to iteratively operate on coarser and coarser representations of an image. The challenge in the GNN setting---compared to standard CNNs---is that graphs contain no natural notion of spatial locality, i.e., one cannot simply pool together all nodes in a `` patch'' on a graph, because the complex topological structure of graphs precludes any straightforward, deterministic definition of a ``patch''. Moreover, unlike image data, graph data sets often contain graphs with varying numbers of nodes and edges, which makes defining a general graph pooling operator even more challenging.

In order to solve the above challenges, we require a model that learns how to cluster together nodes to build a hierarchical multi-layer scaffold on top of the underlying graph. 
Our approach \name learns a differentiable soft assignment at each layer of a deep GNN, mapping nodes to a set of clusters based on their learned embeddings. 
In this framework, we generate deep GNNs by ``stacking'' GNN layers in a hierarchical fashion (Figure~\ref{fig:illustration}): the input nodes at the layer  GNN module correspond to the clusters learned at the layer  GNN module. 
Thus, each layer of \name coarsens the input graph more and more, and \name is able to generate a hierarchical representation of any input graph after training.
We show that \name\ can be combined with various GNN approaches, resulting in an average 7\% gain in accuracy and a new state of the art on four out of five benchmark graph classification tasks. 
Finally,  we show that \name\ can learn interpretable hierarchical clusters that correspond to well-defined communities in the input graphs.
\cut{
\jure{Say much much more about our method, how it works and why it is cool.}

\chris{Maybe add highlevel visualization of the idea.}

\jure{ I strongly agree, we need a Figure 1 with an illustration of the method.
For example, a graph and then a hierarchical multi-layer scaffold on top of it.
Will, you are great at creating good figures. Do you want to give it a try?}
\will{Yes, I will brainstorm with Rex today about a figure and put something together :)}

\chris{Quickly sketched this. I think it somehow explains the high-level idea. Guess the equations are too much.}
}

\begin{figure}[t]\begin{center}
    \includegraphics[scale=0.95]{figs/differentiable-pooling-V2.pdf}
    \caption{High-level illustration of our proposed method \name. At each hierarchical layer, we run a GNN model to obtain embeddings of nodes. We then use these learned embeddings to cluster nodes together  and run another GNN layer on this coarsened graph. This whole process is repeated for  layers and we use the final output representation to classify the graph. }
    \label{fig:illustration}
    \end{center}
\end{figure}



 \section{Related Work}

Our work builds upon a rich line of recent research on graph neural networks and graph classification. 

\xhdr{General graph neural networks}
A wide variety of graph neural network (GNN) models have been proposed in recent years, including methods inspired by convolutional neural networks \cite{Bru+2014,Def+2015,Duv+2015,hamilton2017inductive,kipf2017semi,Lei+2017,niepert2016learning, Vel+2018}, recurrent neural networks \cite{Li+2016}, recursive neural networks~\cite{bianchini2001,Sca+2009} and loopy belief propagation \cite{dai2016discriminative}. 
Most of these approaches fit within the framework of ``neural message passing'' proposed by Gilmer \etal~\cite{Gil+2017}. 
In the message passing framework, a GNN is viewed as a message passing algorithm where node representations are iteratively computed from the features of their neighbor nodes using a differentiable aggregation function.
Hamilton \etal~\cite{Ham+2017a} provides a conceptual review of recent advancements in this area, and Bronstein \etal \cite{bronstein2017geometric} outlines connections to spectral graph convolutions. 

\xhdr{Graph classification with graph neural networks}
GNNs have been applied to a wide variety of tasks, including node classification \cite{hamilton2017inductive,kipf2017semi}, link prediction \cite{kipf2018}, graph classification \cite{dai2016discriminative,Duv+2015,zhang2018end}, and chemoinformatics~\cite{Mer+2005,Lus+2013,Fou+2017,Jin+2018,Sch+2017}. 
In the context of graph classification---the task that we study here---a major challenge in applying GNNs is going from node embeddings, which are the output of GNNs, to a representation of the entire graph. 
Common approaches to this problem include simply summing up or averaging all the node embeddings in a final layer \cite{Duv+2015}, introducing a ``virtual node'' that is connected to all the nodes in the graph \cite{Li+2016}, or aggregating the node embeddings using a deep learning architecture that operates over sets \cite{Gil+2017}.
However, all of these methods have the limitation that they do not learn hierarchical representations (i.e., all the node embeddings are globally pooled together in a single layer), and thus are unable to capture the natural structures of many real-world graphs.
Some recent approaches have also proposed applying CNN architectures to the concatenation of all the node embeddings \cite{niepert2016learning,zhang2018end}, but this requires a specifying (or learning) a canonical ordering over nodes, which is in general very difficult and equivalent to solving graph isomorphism. 

Lastly, there are some recent works that learn hierarchical graph representations by combining GNNs with deterministic graph clustering algorithms \cite{Def+2015,simonovsky2017dynamic,Fey+2018}, following a two-stage approach. However, unlike these previous approaches, we seek to {\em learn} the hierarchical structure in an end-to-end fashion, rather than relying on a deterministic graph clustering subroutine.



\cut{
\rex{need to be removed probably. there are some points i think are important which is not illustrated in related work}
To achieve this task. recent works have made several attempts.
Recent attempts include the use of linearization of graphs. A graph can be linearized to a vector representation using ``canonical ordering'' \cite{niepert2016learning}. Pooling or striding is easy to carry out on the 1D representation. However, it is non-trivial to specify a canonical ordering that also preserves graph structure. For example, nodes that are distant in graph might be adjacent to each other in the linearized representation.

Another intuitive pooling strategy is to pool using a graph clustering or coarsening strategy \cite{safro2015advanced}, which can be applied hierarchically and produce coarser and coarser graphs.
However, a variety of clustering and coarsening strategies have been designed, and significant hand-engineering is required to find the best strategy for a specific classification task at hand.
}



\cut{
\xhdr{Graph kernels}

In recent years, various graph kernels have been proposed, which
implicitly or explicitly map graphs to a Hilbert space. Gärtner \etal\cite{Gae+2003}
and Kashima \etal~\cite{Kas+2003} simultaneously proposed
graph kernels based on random walks, which count the number of walks
two graphs have in common. Since then, random walk kernels have been
studied intensively, e.g., see~\cite{Sug+2015}.
Kernels based on shortest paths were first proposed in~\cite{Borgwardt2005}.

A different line in the development of graph kernels focused
particularly on scalable graph kernels. These kernels are typically
computed efficiently by explicit feature maps, which allow to bypass
the computation of a gram matrix, and allow applying scalable linear
classification algorithms. Prominent examples are kernels based on
subgraphs up to a fixed size, so called
{graphlets}~\cite{She+2009}. Other approaches of this category encode
the neighborhood of every node by different techniques, e.g.,
see~\cite{Hid+2009, Neu+2016}, and most notably the
Weisfeiler-Lehman subtree kernel~\cite{She+2011} and its higher-order
variants~\cite{Mor+2017}. Subgraph and Weisfeiler-Lehman kernels have
been successfully employed within frameworks for smoothed and deep
graph kernels~\cite{Yan+2015,Yan+2015a}. Recent developments include
assignment-based approaches~\cite{kriege2016valid,Nik+2017,Joh+2015} and
spectral approaches~\cite{Kon+2016}. Although graph kernels have shown good performance in the past, they lack the ability to adapt to they give data distribution at hand, since they mostly rely on precomputed features. Moreover, they may not scale to large data sets due to the quadratic overhead to compute the gram matrix. 

Niepert \etal~\cite{niepert2016learning} extracted canonical vector representations of neighborhoods of nodes,  based on heuristics such as the Weisfeiler-Lehman algorithm~\cite{She+2011}, to compute a graph embeddings and then used neural networks for the classification task. Moreover, recently graph neural networks (GNN) for node and graph classification became popular. Most of these
approaches fit into the framework proposed by~\cite{Gil+2017}. Here a GNN is viewed as a message passing approach where node
features are iteratively computed from the features of the
node's neighbors by using a differentialable neighborhood aggregation function. The parameters of this function are 
learned together with the parameters of the neural network used for the
classification task in an end-to-end fashion. Up to now, naïve global mean pooling or precomputed clustering methods were applied to compute graph embeddings from the features of each single node.

Notable instances of this model include Neural
Fingerprints~\cite{Duv+2015}, Gated Graph Neural
Networks~\cite{Li+2016}, and spectral approaches proposed
in~\cite{Bru+2014,Def+2015,kipf2017semi}. Dai \etal\cite{dai2016discriminative}
proposed an approach inspired by mean-field inference
and Lei \etal\cite{Lei+2017} showed that the generated
feature maps lie in the same Hilbert space as some popular graph
kernels and successfully applied them in the domain of
chemoinformatics~\cite{Jin+2018}. In~\cite{simonovsky2017dynamic} GNN were extended to include edge features and various precomputed pooling heuristics based on clustering methods were applied. Attention-based extensions were explored in~\cite{Vel+2018}. In order to make GNNs scale to large graphs Hamilton \etal\cite{hamilton2017inductive} and Chen \etal\cite{Che+2018} devised stochastic versions of GNNs. Recently, a differentiable pooling mechanism to compute graph embeddings based on node features using differentiable sorting was proposed~\cite{zhang2018end}.

Moreover, GNNs were applied for protein-protein
interaction prediction~\cite{Fou+2017} and quantum interactions in
molecules~\cite{Sch+2017}. An approach for unsupervised learning based
on GNNs was presented in~\cite{Gar+2017}. Early
approaches were published in~\cite{Mer+2005} and~\cite{Sca+2009,
Sca+2009a}. A survey can be found in~\cite{Ham+2017a}.

}




 \section{Proposed Method}
\label{sec:proposed}

The key idea of \name is that it enables the construction of deep, multi-layer GNN models by providing a differentiable module to hierarchically pool graph nodes. 
In this section, we outline the \name module and show how it is applied in a deep GNN architecture.



\subsection{Preliminaries}
\label{sec:setting}

We represent a graph  as , where  is the adjacency matrix, and  is the node feature matrix assuming each node has  features.\footnote{We do not consider edge features, although one can easily extend the algorithm to support edge features using techniques introduced in \cite{simonovsky2017dynamic}.}
Given a set of labeled graphs  where  is the label corresponding to graph , the goal of graph classification is to learn a mapping  that maps graphs to the set of labels. 
The challenge---compared to standard supervised machine learning setup---is that we need a way to extract useful feature vectors from these input graphs.
That is, in order to apply standard machine learning methods for classification, e.g., neural networks, we need a procedure to convert each graph to an finite dimensional vector in .



\xhdr{Graph neural networks}
In this work, we build upon graph neural networks in order to learn useful representations for graph classification in an end-to-end fashion. 
In particular, we consider GNNs that employ the following general ``message-passing'' architecture:

where  are the node embeddings (i.e., ``messages'') computed after  steps of the GNN and  is the message propagation function, which depends on the adjacency matrix, trainable parameters , and the node embeddings  generated from the previous message-passing step.\footnote{For notational convenience, we assume that the embedding dimension is  for all ; however, in general this restriction is not necessary.}
The input node embeddings  at the initial message-passing iteration , are initialized using
the node features on the graph, . 

There are many possible implementations of the propagation function  \cite{Gil+2017,hamilton2017inductive}.
For example, one popular variant of GNNs---Kipf's \etal \cite{kipf2017semi} Graph Convolutional Networks (GCNs)---implements  using a combination of linear transformations and ReLU non-linearities:

where ,  and  is a trainable weight matrix.
The differentiable pooling model we propose can be applied to any GNN model implementing Equation \eqref{eq:gnn}, and is agnostic with regards to the specifics of how  is implemented. 

A full GNN module will run  iterations of Equation \eqref{eq:gnn} to generate the final output node embeddings , where  is usually in the range 2-6.
For simplicity, in the following sections we will abstract away the internal structure of the GNNs and use  to denote an arbitrary GNN module implementing  iterations of message passing according to some adjacency matrix  and initial input node features . 

\xhdr{Stacking GNNs and pooling layers}
GNNs implementing Equation \eqref{eq:gnn} are inherently flat, as they only propagate information across edges of a graph.
The goal of this work is to define a general, end-to-end differentiable strategy that allows one to {\em stack} multiple GNN modules in a hierarchical fashion. 
Formally, given , the output of a GNN module, and a graph adjacency matrix , we seek to define a strategy to output a new coarsened graph containing  nodes, with weighted adjacency matrix  and node embeddings .
This new coarsened graph can then be used as input to another GNN layer, and this whole process can be repeated  times, generating a model with  GNN layers that operate on a series of coarser and coarser versions of the input graph (Figure~\ref{fig:illustration}).
Thus, our goal is to learn how to cluster or pool together nodes using the output of a GNN, so that we can use this coarsened graph as input to another GNN layer.
What makes designing such a pooling layer for GNNs especially challenging---compared to the usual graph coarsening task---is that our goal is not to simply cluster the nodes in one graph, but to provide a general recipe to hierarchically pool nodes across a broad set of input graphs. 
That is, we need our model to learn a pooling strategy that will generalize across graphs with different nodes, edges, and that can adapt to the various graph structures during inference. 

\cut{
\chris{I think the paragraph below repeats some of the points of the prev. paragraph}
The key challenge for graph pooling with GNNs is designing a pooling layer that respects the hierarchical structure of the input graph.
Similar to how CNNs on images stack filters with increasingly large receptive fields, the pooling layers in a GNN should be stacked hierarchically, extracting coarser and coarser subgraph structures to allow the GNN to obtain a more global view of the graph at the final layers. 
Moreover, what makes designing a pooling layer for GNNs especially challenging---compared to the usual graph coarsening task---is that our goal is not to simply cluster the nodes in one graph, but to provide a general recipe to hierarchically pool nodes across a broad set of input graphs. 
That is, we need our model to encode a pooling strategy that will generalize across graphs with different nodes, edges, and that can adapt to the various graph structures during inference. 
Finally, a key desideratum of a pooling module is that we want it to be able to {\em learn} a good strategy from the training data, rather than relying on deterministic graph coarsening functions. 
For instance, one could simply use edge contractions or non-negative matrix factorization to assign nodes to clusters, but these approaches are incapable of adapting their pooling strategy based on training data. 
}



\subsection{Differentiable Pooling via Learned Assignments}
\cut{
\jure{This is our main contribution. We need to discuss why our approach is sound and what is the intuition behind it.
It would be good to talk about possible strategies to learn this (factorization, etc.) but why our approach of learning to assign nodes to clusters is appropriate one.
We need a model that can for any network structure learn what is the right hierarchical pooling structure in order to aggregate information. 
I think such discussion is important as it let's reader to think and appreciate the problem. If we simply introduce the solution too quickly people won't appreciate it.}
\will{I tried to add more motivation in the paragraph above, and Rex and I are trying to add in more intuition behind the method in the paragraphs below.}
}

Our proposed approach, \name, addresses the above challenges by learning a cluster assignment matrix over the nodes using the output of a GNN model.
The key intuition is that we stack  GNN modules and learn to assign nodes to clusters at layer  in an end-to-end fashion, using embeddings generated from a GNN at layer .
Thus, we are using GNNs to both extract node embeddings that are useful for graph classification, as well to extract node embeddings that are useful for hierarchical pooling.
Using this construction, the GNNs in \name learn to encode a general pooling strategy that is useful for a large set of training graphs. 
We first describe how the \name\ module pools nodes at each layer given an assignment matrix; following this, we discuss how we generate the assignment matrix using a GNN architecture. 

\xhdr{Pooling with an assignment matrix}
We denote the learned cluster assignment matrix at layer  as . 
Each row of  corresponds to one of the  nodes (or clusters) at layer , and each column of  corresponds to one of the  clusters at the next layer . 
Intuitively,  provides a soft assignment of each node at layer  to a cluster in the next coarsened layer .

Suppose that  has already been computed, i.e., that we have computed the assignment matrix at the -th layer of our model.
We denote the input adjacency matrix at this layer as  and denote the input node embedding matrix at this layer as .
Given these inputs, the \name layer  coarsens the input graph, generating a new coarsened adjacency matrix  and a new matrix of embeddings  for each of the nodes/clusters in this coarsened graph.
In particular, we apply the two following equations:

Equation \eqref{eq:4} takes the node embeddings  and aggregates these embeddings according to the cluster assignments , generating embeddings for each of the  clusters.
Similarly, Equation \eqref{eq:5} takes the adjacency matrix  and generates a coarsened adjacency matrix denoting the connectivity strength between each pair of clusters. 

Through Equations \eqref{eq:4} and \eqref{eq:5}, the \name layer coarsens the graph: the next layer adjacency matrix  represents a coarsened graph with  nodes or {\em cluster nodes}, where each individual cluster node in the new coarsened graph corresponds to a cluster of nodes in the graph at layer .
Note that  is a real matrix and represents a fully connected edge-weighted  graph; each entry  can be viewed as the connectivity strength between cluster  and cluster . 
Similarly, the -th row of  corresponds to the embedding of cluster . 
Together, the coarsened adjacency matrix  and cluster embeddings  can be used as input to another GNN layer, a process which we describe in detail below.  


\xhdr{Learning the assignment matrix}
In the following we describe the architecture of \name, i.e., how \name\ generates the assignment matrix  and embedding matrices  that are used in Equations \eqref{eq:4} and \eqref{eq:5}.
We generate these two matrices using two separate GNNs that are both applied to the input cluster node features  and coarsened adjacency matrix .
The {\em embedding GNN} at layer  is a standard GNN module applied to these inputs:

i.e., we take the adjacency matrix between the cluster nodes at layer  (from Equation \ref{eq:5}) and the pooled features for the clusters (from Equation \ref{eq:4}) and pass these matrices through a standard GNN to get new embeddings  for the cluster nodes. 
In contrast, the {\em pooling GNN} at layer , uses the input cluster features  and cluster adjacency matrix  to generate an assignment matrix:

where the softmax function is applied in a row-wise fashion.
The output dimension of  corresponds to a pre-defined maximum number of clusters in layer , and is a hyperparameter of the model.

Note that these two GNNs consume the same input data but have distinct parameterizations and play separate roles:
The embedding GNN generates new embeddings for the input nodes at this layer, while the pooling GNN generates a probabilistic assignment of the input nodes to  clusters.

In the base case, the inputs to Equations \eqref{eq:embedgnn} and Equations \eqref{eq:poolgnn} at layer  are simply the input adjacency matrix  and the node features  for the original graph.
At the penultimate layer  of a deep GNN model using \name, we set the assignment matrix  be a vector of 's, i.e., all nodes at the final layer  are assigned to a single cluster, generating a final embedding vector corresponding to the entire graph.
This final output embedding can then be used as feature input to a differentiable classifier (e.g., a softmax layer), and the entire system can be trained end-to-end using stochastic gradient descent. 




\xhdr{Permutation invariance}
Note that in order to be useful for graph classification, the pooling layer should be invariant under node permutations. For \name we get the following positive result, which shows that any deep GNN model based on \name\ is permutation invariant, as long as the component GNNs are permutation invariant. 
\begin{proposition}
\label{prop:permute}
Let  be any permutation matrix, then  as long as  (i.e., as long as the GNN method used is permutation invariant).
\end{proposition}
\begin{proof}
Equations \eqref{eq:embedgnn} and \eqref{eq:poolgnn} are permutation invariant by the assumption that the GNN module is permutation invariant. 
And since any permutation matrix is orthogonal, applying  to Equation (\ref{eq:4}) and (\ref{eq:5}) finishes the proof.
\end{proof}


\subsection{Auxiliary Link Prediction Objective and Entropy Regularization}

In practice, it can be difficult to train the pooling GNN (Equation \ref{eq:5}) using only gradient signal from the graph classification task.
Intuitively, we have a non-convex optimization problem and it can be difficult to push the pooling GNN away from spurious local minima early in training.
To alleviate this issue, we train the pooling GNN with an auxiliary link prediction objective, which encodes the intuition that nearby nodes should be pooled together. 
\cut{
Controlling input features and representation dimension is still insufficient for  to learn and extract meaningful cluster information from a graph. We additionally supply side objectives as regularizations for . 
Intuitively,  should learn to assign nodes that are close together in terms of connectivity into the same clusters. 
Hence, we use a link prediction objective to further encourage similarity of cluster assignments.}
In particular, at each layer , we minimize
, where  denotes the Frobenius norm. 
Note that the adjacency matrix  at deeper layers is a function of lower level assignment matrices, and changes during training. 

Another important characteristic of the pooling GNN (Equation \ref{eq:5})  is that the output cluster assignment for each node should generally be close to a one-hot vector, so that the membership for each cluster or subgraph is clearly defined. We therefore regularize the entropy of the cluster assignment by minimizing , where  denotes the entropy function, and  is the -th row of .

During training,  and  from each layer are added to the classification loss.
In practice we observe that training with the side objective takes longer to converge, but nevertheless achieves better performance and more interpretable cluster assignments.

\cut{
\subsection{Behavior on sparse and dense graphs}
\label{sec:sparse_dense}
The sparsity of (sub)graphs has a large impact on the behavior of the assignment layer  .
In particular, we find that \name\ is most effective in sparse graphs that exhibit hierarchical partitions, whereas in very dense (sub)graphs \name\ simply learns to map all nodes to a single cluster.
Moreover, within a particular layer of a deep GNN model, \name\ will tend to collapse densely-connected connected subgraphs into a single hyper-node. 
This trend is supported by our empirical studies (Section \ref{sec:ex})---e.g., where \name\ leads to state-of-the-art results on all data sets except \textsc{Collab}, which involves exceptionally dense graphs---and this trend can be understood based on the following theoretical intuitions. 

First, note that if a subgraph of the input graph is dense, then the entries of the corresponding subgraph adjacency matrix will be mostly ones. 
And since   is a matrix of all ones, an assignment matrix for the subgraph, where one column is a vector of ones and the others are zero vectors, will be close to a minimum of the link prediction auxiliary objective.
Thus, the objective will tend to group all nodes of a dense subgraph into one cluster.

\rex{formalizing: for a graph with n cliques, the network with linkpred objective will almost deterministically assign all nodes in each clique to a distinct cluster}

Moreover, in terms of GNN computation, collapsing dense subgraphs in this way is intuitively an optimal pooling (or partitioning) strategy.
In particular, it is known that GNNs can efficiently perform message-passing on dense, clique-like subgraphs (due to their small diameter) \cite{liao2018graph}, and hence \name\ can pool together nodes in such a dense subgraph without losing any significant structural information.
In contrast, sparse subgraphs may contain many interesting structures, including path-, cycle- and tree-like structures, and given the high-diameter induced by sparsity, GNN message-passing may fail to capture these structures. 
Thus, by separately pooling distinct parts of a sparse subgraph, \name can learn to capture the meaningful structures present 
in sparse graph regions. 
}

\cut{
This interpretation matches our pooling objective well. Intuitively, a clique-like subgraph contains very little interesting structure, and message passing is efficient due to small graph diameter, and hence it could be directly pooled together without losing much structural information in the pooled embedding matrix . However, a sparse subgraph may contain many interesting structures, including path-, cycle- and tree-like ones. Therefore, message passing may miss these fine-grained structures. Subsequently, each part of the subgraph should be assigned and pooled differently, to capture these meaningful structures. }

\cut{
Hence the objective will tend to group all nodes into one cluster. \chris{We could also formalize it and prove it.}This  implies that all nodes in the dense subgraph are clustered into a single hyper-node. In contrast, when a subgraph is sparse, the resulting assignment tends to have higher entropy, and nodes could be assigned to different clusters, so that the elements of  are small.}
\cut{
\subsection{Learning to Pool with Side Information}
\label{sec:pooling}

Although the assignment matrix  and the embedding matrix  are both computed using the GCN architecture, they have distinct interpretations. In particular, the embedding matrix at each layer is used as an intermediate representations of nodes and subgraphs at different coarsening scales. In comparison, the assignment matrix at each layer is used to determine the clustering assignment, and determines which nodes and subgraphs should be pooled together. Therefore it is important to create asymmetry in the computation of both  and , in order to differentiate their purposes. We achieve this in three ways.

\xhdr{Input Features}
\note{note to rex himself: more experim - identity feat input?}
The goal of  is to learn node and subgraph representations such that when pooled together, subsequent classifier can easily map the representations to labels. 
Since the labels might be a complex function of all node features, e.g., homophily and structural properties of the input graph, we use a variety of features as inputs to  to compute , including structural features such as degree and clustering coefficient features, or node features.
In comparison, the assignment network should learn to predict cluster indices mainly based on homophily property. Therefore structural features such as degree and clustering coefficients are removed from the input features, which is essential in obtaining meaningful clusters that also benefit the classification task.

\xhdr{Representation dimension}
At deeper layers, the embedding matrix  provides representations for hyper-nodes corresponding to larger subgraphs. Therefore, more dimensions should be used when encoding larger subgraphs. This is analogous to CNNs for images~\cite{?}, where the number of channels increases after each convolutional layer.  In contrast, the assignment matrix  aims to map hyper-nodes into a fewer number of clusters, allowing hyper-nodes to gain a more global \rex{what is better wording?} \chris{higher-order?} view of connectivities between subgraphs. Therefore, at deeper layers, the output dimension of  decreases exponentially. Here the dimension reduction ratio  is a hyper-parameter. In practice, we discover that performance is insensitive for . The network outputs a sparse  if the number of intuitive clusters are much less than the output dimension.

\xhdr{Auxiliary objectives}
Controlling input features and representation dimension is still insufficient for  to learn and extract meaningful cluster information from a graph. We additionally supply side objectives as regularizations for . 
Intuitively,  should learn to assign nodes that are close together in terms of connectivity into the same clusters. 
Hence, we use a link prediction objective to further encourage similarity of cluster assignments.
Particularly, at each layer , we minimize
, where  denotes the Frobinus norm. 
Note that the (soft) adjacency matrix  at deeper layers is a function of lower level assignment matrices, and changes during training. 

Another important characteristic of  is that the output cluster assignment for each node should generally be close to a one-hot vector, so that the membership for each cluster or subgraph is clearly defined, except in rare cases where a node serves as a bridge between multiple clusters. We therefore regularize the entropy of the cluster assignment by minimizing , where  denotes the entropy function, and  is the -th row of .

During training,  and  from each layer are added to the classification loss, in order to obtain meaningful assignment matrices at all layers. In practice we observe that training with the side objective takes longer to converge, but nevertheless achieves better performance and more interpretable cluster assignment.

\note{Note to Rex himself: try curriculum training}
\chris{Where is  and  defined}

\xhdr{Relation to low rank matrix factorization}
We note that by approximating  with , the link prediction auxiliary objective bears close resemblance to a low rank matrix factorization of , and well-separated pair decomposition (WSPD). 
Similar to matrix factorization, we require that at each layer,  is able to capture most of the distance information between nodes, while using less dimensions than that of . However, low rank matrix factorization is non-convex and has many local minimums. When trained end-to-end in the graph classification task, \name tends to find local minimum that is better suited for the task. This explains our observation that DiffPool consistently out-performs a two-step procedure of graph clustering followed by GCN that pools over these clusters.
 computes small number of pairs of clusters, such that for any pair of points , we can find a pair of clusters  such that , and . In the case of \name, the goal of the auxiliary objective is to let the connectivity strength between any node pair  to be reflected by the connectivity strength between their corresponding clusters. However, unlike WSPD, the assignment in \name is soft to allow differentiability, which enables end-to-end training and avoids the high computation cost of WSPD in high dimensions.


\xhdr{Behavior on sparse and dense networks}
The sparsity of graphs also affects the behavior of the assignment network .
Suppose a subgraph of the input graph is dense, therefore the entries of the corresponding subgraph adjacency matrix are mostly ones. Since   is a matrix of all ones, an assignment matrix for the subgraph, where one column is a vector of ones and the others are zero vectors, will be close to a minimum of the link prediction auxiliary objective. Hence the objective will tend to group all nodes into one cluster. \chris{We could also formalize it and prove it.}This  implies that all nodes in the dense subgraph are clustered into a single hyper-node. In contrast, when a subgraph is sparse, the resulting assignment tends to have higher entropy, and nodes could be assigned to different clusters, so that the elements of  are small.

This interpretation matches our pooling objective well. Intuitively, a clique-like subgraph contains very little interesting structure, and message passing is efficient due to small graph diameter, and hence it could be directly pooled together without losing much structural information in the pooled embedding matrix. However, a sparse subgraph may contain many interesting structures, including path-, cycle- and tree-like ones. Therefore, message passing may miss these fine-grained structures. Subsequently, each part of the subgraph should be assigned and pooled differently, to capture these meaningful structures. 

}
 \section{Experiments}
\label{sec:ex}

We evaluate the benefits of \name\ against a number of state-of-the-art graph classification approaches, with the goal of answering the following questions:
\begin{enumerate}[leftmargin=20pt]
\item[{\bf Q1}] How does  \name\ compare to other pooling methods proposed for GNNs (e.g., using sort pooling~\cite{zhang2018end} or the \textsc{Set2Set} method \cite{Gil+2017})?
\item[{\bf Q2}] How does  \name\ combined with GNNs compare to the state-of-the-art for graph classification task, including both GNNs and kernel-based methods?
\item[{\bf Q3}] Does  \name  compute meaningful and interpretable clusters on the input graphs?
\end{enumerate}


\xhdr{Data sets}
To probe the ability of \name to learn complex hierarchical structures from graphs in different domains, we evaluate on a variety of relatively large graph data sets chosen from benchmarks commonly used in graph classification \cite{KKMMN2016}. We use protein data sets including \textsc{Enzymes}, \textsc{Proteins}~\cite{Borgwardt2005a, Fer+2013}, \textsc{D\&D}~\cite{Dob+2003}, the social network data set \textsc{Reddit-Multi-12k}~\cite{Yan+2015a}, and the scientific collaboration data set \textsc{Collab}~\cite{Yan+2015a}. See Appendix A for statistics and properties.
For all these data sets, we perform 10-fold cross-validation to evaluate model performance, and report the accuracy averaged over 10 folds. 



\xhdr{Model configurations}
In our experiments, the GNN model used for \name\ is built on top of the \textsc{GraphSage} architecture, as we found this architecture to have superior performance compared to the standard GCN approach as introduced in \cite{kipf2017semi}. 
We use the ``mean'' variant of \textsc{GraphSage}~\cite{hamilton2017inductive} and apply a \name layer after every two \textsc{GraphSage} layers in our architecture.
A total of 2 \name layers are used for the datasets. For small datasets such as \textsc{Enzymes} and \textsc{Collab}, 1 \name layer can achieve similar performance.
After each \name layer, 3 layers of graph convolutions are performed, before the next \name layer, or the readout layer.
The embedding matrix and the assignment matrix are computed by two separate \textsc{GraphSage} models respectively.
In the 2 \name layer architecture, the number of clusters is set as  of the number of nodes before applying \name,
while in the 1 \name layer architecture, the number of clusters is set as .
Batch normalization \cite{ioffe2015batch} is applied after every layer of \textsc{GraphSage}. 
We also found that adding an  normalization to the node embeddings at each layer made the training more stable. 
In Section \ref{sec:s2v}, we also test an analogous variant of \name on the \textsc{Structure2Vec} \cite{dai2016discriminative} architecture, in order to demonstrate how \name\ can be applied on top of other GNN models. 
All models are trained for 3\,000 epochs with early stopping applied when the validation loss starts to drop.
We also evaluate two simplified versions of \name:
\begin{itemize}[leftmargin=15pt, topsep=-5pt, parsep=0pt]
 \item \textsc{\name-Det}, is a \name\ model where assignment matrices are generated using a deterministic graph clustering algorithm~\cite{dhillon2007weighted}.\item
    \textsc{DiffPool-NoLP} is a variant of \textsc{\name} where the link prediction side objective is turned off.
\end{itemize}

\subsection{Baseline Methods}
In the performance comparison on graph classification, we consider baselines based upon GNNs (combined with different pooling methods) as well as state-of-the-art kernel-based approaches. 

\xhdr{GNN-based methods} 
\begin{itemize}[leftmargin=15pt, topsep=-5pt, parsep=0pt]
    \item \textsc{GraphSage} with global mean-pooling \cite{hamilton2017inductive}. Other GNN variants such as those proposed in \cite{kipf2017semi} are omitted as empirically GraphSAGE obtained higher performance in the task.
    \item \textsc{Structure2Vec} (\textsc{S2V})~\cite{dai2016discriminative} is a state-of-the-art graph representation learning algorithm that combines a latent variable model with GNNs. It uses global mean pooling.
    \item Edge-conditioned filters in CNN for graphs (\textsc{ECC})~\cite{simonovsky2017dynamic} incorporates edge information into the GCN model and performs pooling using a graph coarsening algorithm. \item \textsc{PatchySan}~\cite{niepert2016learning} defines a receptive field (neighborhood) for each node, and using a canonical node ordering, applies convolutions on linear sequences of node embeddings. 
    \item \textsc{Set2Set} replaces the global mean-pooling in the traditional GNN architectures by the aggregation used in \textsc{Set2Set}~\cite{vinyals2015order}. Set2Set aggregation has been shown to perform better than mean pooling in previous work \cite{Gil+2017}. We use \textsc{GraphSage} as the base GNN model. 
    \item  \textsc{SortPool}~\cite{zhang2018end} applies a GNN architecture and then performs a single layer of soft pooling followed by 1D convolution on sorted node embeddings. 
\end{itemize}

\medskip
For all the GNN baselines, we use 10-fold cross validation numbers reported by the original authors when possible. 
For the \textsc{GraphSage} and \textsc{Set2Set} baselines, we use the base implementation and hyperparameter sweeps as in our \name\ approach.
When baseline approaches did not have the necessary published numbers, we contacted the original authors and used \textbf{}their code (if available) to run the model, performing a hyperparameter search based on the original author's guidelines. 

\xhdr{Kernel-based algorithms}
We use the \textsc{Graphlet}~\cite{She+2009}, the \textsc{Shortest-Path}~\cite{Borgwardt2005}, \textsc{Weisfeiler-Lehman} kernel (\textsc{WL})~\cite{She+2011}, and \textsc{Weisfeiler-Lehman Optimal Assignment kernel} (\textsc{WL-OA})~\cite{kriege2016valid} as kernel baselines. For each kernel, we computed the normalized gram matrix. We computed the classification accuracies using the -SVM implementation of \textsc{LibSvm}~\cite{Cha+11}, using 10-fold cross validation. The  parameter was selected from   by 10-fold cross validation on the training folds. Moreover, for \textsc{WL} and \textsc{WL-OA} we additionally selected the number of iteration from .

\subsection{Results for Graph Classification}\label{sec:classification}
Table \ref{tab:results} compares the performance of \name\ to these state-of-the-art graph classification baselines.
These results provide positive answers to our motivating questions {\bf Q1} and {\bf Q2}:
We observe that our \name approach obtains the highest average performance among all pooling approaches for GNNs, improves upon the base \textsc{GraphSage} architecture by an average of , and achieves state-of-the-art results on 4 out of 5 benchmarks. Interestingly, our simplified model variant, \textsc{\name-Det}, achieves state-of-the-art performance on the \textsc{Collab} benchmark. This is because many collaboration graphs in \textsc{Collab} show only single-layer community structures, which can be captured well with pre-computed graph clustering algorithm~\cite{dhillon2007weighted}.
One observation is that despite significant performance improvement, \name could be unstable to train, and there is significant variation in accuracy across different runs, even with the same hyperparameter setting. It is observed that adding the link predictioin objective makes training more stable, and reduces the standard deviation of accuracy across different runs.
\cut{
Among the baseline methods, the kernel-based \textsc{WL-OA} also performs quite well, achieving the second-best accuracy on the \textsc{Collab} benchmark, which contains exceptionally dense graphs. 
applied on top of \textsc{GraphSage} with GNNs using other pooling methods, as well as kernel-based methods. In the last column we report the percentage gain of each GNN pooling baseline over \textsc{GraphSage} with naive mean pooling.
\textsc{Set2Set} aggregation has shown to give significant gains in many data sets, achieving an average of  improvement compared to the naive baseline of \textsc{GraphSage} with global pooling. However, \textsc{Set2Set} aggregation has longer running time: it runs  times slower than \name on average.
In comparison, \textsc{PatchySan}, \textsc{SortPool} and \textsc{ClusterPool}  all achieve better results, due to their ability to pool according to structures of the graphs. 
}


\begin{table}[t]\	
\caption{Classification accuracies in percent. The far-right column gives the relative increase in accuracy compared to the baseline \textsc{GraphSage} approach.}
\label{tab:results}
\resizebox{0.93\textwidth}{!}{ \renewcommand{\arraystretch}{1.0}
\centering
\begin{tabular}{@{}clcccccc@{}}\cmidrule[\heavyrulewidth]{2-8}
& \multirow{3}{*}{\vspace*{8pt}\textbf{Method}}&\multicolumn{5}{c}{\textbf{Data Set}}\\\cmidrule{3-8}
& & {\textsc{Enzymes}} & {\textsc{D\&D}} & {\textsc{Reddit-Multi-12k}} & {\textsc{Collab}} & {\textsc{Proteins}} & {\text{Gain}}
\\ \cmidrule{2-8}
\multirow{4}{*}{\rotatebox{90}{\hspace*{-6pt}Kernel}} 
& \textsc{Graphlet}  & 41.03 & 74.85 &  21.73 & 64.66 & 72.91 &  \\ 
& \textsc{Shortest-path} & 42.32 & 78.86 & 36.93 & 59.10  & 76.43 &   \\     
& \text{1-WL} &  53.43 & 74.02 &  39.03 &  78.61 & 73.76 &  \\     
& \text{WL-OA} & 60.13  & 79.04	 & 44.38  & 80.74  & 75.26  &   \\       \cmidrule{2-8}
& \textsc{PatchySan} & -- & 76.27	 & 41.32   & 72.60 &  75.00  & 4.17 \\ 
\multirow{7}{*}{\rotatebox{90}{GNN}} 
& \textsc{GraphSage} &  54.25 & 75.42 	 & 42.24  & 68.25  & 70.48 &  --\\ 
& \textsc{ECC}  & 53.50  & 74.10 & 41.73  & 67.79 &   72.65  & 0.11 \\	
& \textsc{Set2set} &  60.15 & 78.12  & 43.49 & 71.75 & 74.29 & 3.32 \\ 
& \textsc{SortPool} & 57.12 & 79.37  & 41.82 & 73.76  & 75.54  & 3.39 \\     
& \textsc{\name-Det} & 58.33 & 75.47 & 46.18 & \textbf{82.13} & 75.62 & 5.42 \\ 
& \textsc{\name-NoLP} & 61.95  & 79.98	 & 46.65  & 75.58   &  76.22  &  5.95 \\ 
& \textsc{\name} & \textbf{62.53}  & \textbf{80.64}	 & \textbf{47.08}  & 75.48   &  \textbf{76.25}  & \textbf{6.27}\\     
\cmidrule[\heavyrulewidth]{2-8}
\end{tabular}}
\end{table}

\cut{
One notable data set that demonstrates the expressivity of \name is \textsc{Reddit-Multi-12k}, in which each graph represents an online discussion thread between users/nodes (an edge is formed when a user replies to another user). It contains rich hierarchical structures due to the tree-structured nature of Reddit discussions: there are small clusters of discussion among small numbers of users occurring at the leaves of the discussion threads, and the small clusters themselves are grouped into larger clusters based on higher-level threads/topics. 
\name significantly outperforms other methods on this data set, as it can automatically extract meaningful clusters (in a hierarchical fashion) from these natural thread-based graphs. 
}

\cut{
Graphs in the \textsc{Collab} data set, in contrast, are very dense and do not have a hierarchical structure. As illustrated in Section \ref{sec:sparse_dense}, \name tends to assign nodes in densely connected subgraphs into a single cluster. In practice, we observe that hierarchies deeper than two do not result in performance improvement in this data set, which again stresses that it does not contain any hierarchical structure.}


\xhdr{Differentiable Pooling on \textsc{Structure2Vec}}\label{sec:s2v}
\name can be applied to other GNN architectures besides \textsc{GraphSage} to capture hierarchical structure in the graph data.
To further support answering {\bf Q1}, we also applied \name on Structure2Vec (\textsc{S2V}). 
We ran experiments using \textsc{S2V} with three layer architecture, as reported in \cite{dai2016discriminative}.
In the first variant, one \name layer is applied after the first layer of \textsc{S2V}, and two more \textsc{S2V} layers are stacked on top of the output of \name. The second variant applies one \name layer after the first and second layer of \textsc{S2V} respectively. 
In both variants, \textsc{S2V} model is used to compute the embedding matrix, while \textsc{GraphSage} model is used to compute the assignment matrix.


\begin{table}[htbp]\centering		
\caption{Accuracy results of applying \name to \textsc{S2V}.}
\label{tab:results2}
\resizebox{.6\textwidth}{!}{ \renewcommand{\arraystretch}{1.1}
\begin{tabular}{@{}clccc@{}}\cmidrule[\heavyrulewidth]{2-5}
& \multirow{3}{*}{\vspace*{8pt}\textbf{Data Set}}&\multicolumn{3}{c}{\textbf{Method}}\\\cmidrule{3-5}
& & {\textsc{S2V}} & {\textsc{S2V with 1 DiffPool}} & {\textsc{S2V with 2 DiffPool}}
\\ \cmidrule{2-5}
& \textsc{Enzymes}  & 	61.10 & 62.86   & \textbf{63.33}  \\ 
& \textsc{D\&D} & 78.92 & 80.75 &   \textbf{82.07}  \\     
\cmidrule[\heavyrulewidth]{2-5}
\end{tabular}}
\end{table}

The results in terms of classification accuracy are summarized in Table \ref{tab:results2}.
We observe that \name significantly improves the performance of S2V on both \textsc{Enzymes} and \textsc{D\&D} data sets. Similar performance trends are also observed on other data sets.
The results demonstrate that \name is a general strategy to pool over hierarchical structure that can benefit different GNN architectures.

\xhdr{Running time} Although applying \name requires additional computation of an assignment matrix, we observed that \name did not incur substantial additional running time in practice.
This is because each \name layer reduces the size of graphs by extracting a coarser representation of the graph, which speeds up the graph convolution operation in the next layer.
Concretely, we found that \textsc{GraphSage} with \name\ was 12 faster than the  model with  pooling, while still achieving significantly higher accuracy on all benchmarks. 


\subsection{Analysis of Cluster Assignment in \name}
\label{sec:assignment_vis}

\xhdr{Hierarchical cluster structure}
To address {\bf Q3}, we investigated the extent to which \name learns meaningful node clusters by visualizing the cluster assignments in different layers. Figure \ref{fig:assignment_vis} shows such a visualization of node assignments in the first and second layers on a graph from \textsc{Collab} data set, where node color indicates its cluster membership. Node cluster membership is determined by taking the  of its cluster assignment probabilities. We observe that even when learning cluster assignment based solely on the graph classification objective, \name can still capture the hierarchical community structure. We also observe significant improvement in membership assignment quality with link prediction auxiliary objectives.

\xhdr{Dense vs. sparse subgraph structure}
In addition, we observe that \name learns to collapse nodes into soft clusters in a non-uniform way, with a tendency to collapse densely-connected subgraphs into clusters. 
Since GNNs can efficiently perform message-passing on dense, clique-like subgraphs (due to their small diameters) \cite{liao2018graph}, pooling together nodes in such a dense subgraph is not likely to lead to any loss of structural information. 
This intuitively explains why collapsing dense subgraphs is a useful pooling strategy for \name. 
In contrast, sparse subgraphs may contain many interesting structures, including path-, cycle- and tree-like structures, and given the high-diameter induced by sparsity, GNN message-passing may fail to capture these structures. 
Thus, by separately pooling distinct parts of a sparse subgraph, \name can learn to capture the meaningful structures present in sparse graph regions (e.g., as in Figure~\ref{fig:assignment_vis}). 

\xhdr{Assignment for nodes with similar representations}
Since the assignment network computes the soft cluster assignment based on features of input nodes and their neighbors, nodes with both similar input features and neighborhood structure will have similar cluster assignment.
In fact, one can construct synthetic cases where 2 nodes, although far away, have exactly the same neighborhood structure and features for self and all neighbors. In this case the pooling network is forced to assign them into the same cluster, which is different from the concept of pooling in other architectures such as image ConvNets. In some cases we do observe that disconnected nodes are pooled together.

In practice we rely on the identifiability assumption similar to Theorem 1 in GraphSAGE \cite{hamilton2017inductive}, where nodes are identifiable via their features. This holds in many real datasets \footnote{However, some chemistry molecular graph datasets contain many nodes that are structurally similar, and assignment network is observed to pool together nodes that are far away.}. 
The auxiliary link prediction objective is observed to also help discouraging nodes that are far away to be pooled together. Furthermore, it is possible to use more sophisticated GNN aggregation function such as high-order moments \cite{verma2018graph} to distinguish nodes that are similar in structure and feature space. The overall framework remains unchanged.

\xhdr{Sensitivity of the Pre-defined Maximum Number of Clusters}
We found that the assignment varies according to the depth of the network and , the maximum number of clusters. With larger , the pooling GNN can model more complex hierarchical structure. The trade-off is that very large  results in more noise and less efficiency. 
Although the value of  is a pre-defined parameter, the pooling net learns to use the appropriate number of clusters by end-to-end training. 
In particular, some clusters might not be used by the assignment matrix. Column corresponding to unused cluster has low values for all nodes. This is observed in Figure \ref{fig:assignment_vis}(c), where nodes are assigned predominantly into 3 clusters.


\cut{
\xhdr{Number of clusters} \jure{why is this in experiments? We can cut this or make it into an experimental result.}
In addithttps://v2.overleaf.com/projection, although we globally set the number of clusters to be  of the nodes, the assignment network automatically learns the appropriate number of meaningful clusters to assign for different graphs in the dataset, in order to optimize the classification objective.
\cut{
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.8\textwidth]{figs/diffpool_vis.pdf}
    \caption{Visualization of hierarchical cluster assignment over two \name\ layers, using an example graph from \textsc{Collab}.
      Nodes in the right-hand side plot correspond to cluster in the original graph (left-hand side). Colors are used to connect the nodes/clusters across the graphs, and dotted lines are used to indicate clusters.}
    \label{fig:assignment_vis}
\end{figure}
}
}

\begin{figure}[t!]
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{figs/diffpool_vis.pdf}
        \caption{}
    \end{subfigure}
    ~
    \begin{subfigure}[b]{0.25\textwidth}
        \centering
        \includegraphics[height=1in]{figs/vis_1_ell.png}
                \caption{}
    \end{subfigure}~ 
    \begin{subfigure}[b]{0.25\textwidth}
        \centering
        \includegraphics[height=1in]{figs/vis_2_ell.png}
        \caption{}
    \end{subfigure}
    \caption{Visualization of hierarchical cluster assignment in \name, using example graphs from \textsc{Collab}.
      The left figure (a) shows hierarchical clustering over two layers, where nodes in the second layer correspond to clusters in the first layer. (Colors are used to connect the nodes/clusters across the layers, and dotted lines are used to indicate clusters.)
      The right two plots (b and c) show two more examples first-layer clusters in different graphs. 
      Note that although we globally set the number of clusters to be  of the nodes, the assignment GNN automatically learns the appropriate number of meaningful clusters to assign for these different graphs.}
        \label{fig:assignment_vis}
\end{figure}


 \section{Conclusion}

We introduced a differentiable pooling method for GNNs that is able to extract the complex hierarchical structure of real-world graphs. By using the proposed pooling layer in conjunction with existing GNN models, we achieved new state-of-the-art results on several graph classification benchmarks. 
Interesting future directions include learning hard cluster assignments to further reduce computational cost in higher layers while also ensuring differentiability, and applying the hierarchical pooling method to other downstream tasks that require modeling of the entire graph structure.


\section*{Acknowledgement}
This research has been supported in part by DARPA SIMPLEX, Stanford Data
Science Initiative, Huawei, JD and Chan Zuckerberg Biohub.
Christopher Morris is funded by the German Science Foundation (DFG) within the Collaborative Research Center SFB 876 “Providing Information by Resource-Constrained Data Analysis”, project A6 “Resource-efficient Graph Mining”. 
The authors also thank Marinka Zitnik for help in visualizing the high-level illustration of the proposed methods.




 

\bibliography{refs}
\bibliographystyle{abbrv}



\end{document}
