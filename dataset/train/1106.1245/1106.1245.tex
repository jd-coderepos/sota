\documentclass[copyright,creativecommons]{packages/eptcs}
\providecommand{\event}{GandALF 2011} 
\usepackage{breakurl}
\usepackage{alltt}
\usepackage{url}
\usepackage{xspace}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{pstricks,pst-node,pst-text}
\usepackage{tikz}
\usepackage{packages/algorithm, packages/algorithmic, packages/algorithmic-fix}
\usepackage{csquotes}
\usepackage{multirow}

\usepackage{color}

\newcommand{\tr}{\tau}
\newcommand{ \lin}{\mbox{L}}
\newcommand{\ml}{\mbox{ML}}
\newcommand{\m}{{\mbox{d}}}
\newcommand{\bd}{{\mbox{Bd}}}
\newcommand{\clo}{{\mbox{Cl}}}
\newcommand{\p}{{\mbox{P}}}
\newcommand{\br}{{\mbox{Bd}}}
\newcommand{\traj}{\tau}
\newcommand{\pl}{{\mbox{pl}}}
\newcommand{\x}{{\mbox{x}}}
\newcommand{\oo}{{\mbox{O}}}
\newcommand{\interval}{\chi}
\newcommand{\cycle}{\zeta}
\newcommand{\Cycle}{\mbox{C}}
\newcommand{\hc}{\theta}
\newcommand{\depth}{{\mbox{depth}}}
\newcommand{\mc}{{\mbox{MF}}}
\newcommand{\suf}{{\small{suf}}}
\newcommand{\pref}{{\small{pref}}}
\newcommand{\reach}{{\mbox{Reach}}}
\newcommand{\dist}{{\mbox{Dist}}}
\newcommand{\sign}{{\mbox{Sign}}}
\newcommand{\D}{{\mbox{d}}}  
\newcommand{\ST}{{\mbox{ST}}} 
\newcommand{\seq}{\overline{\star}}  
\newcommand{\sgn}{\Sigma} 
\newcommand{\ssgn}{\overline{\sgn}}  
\newcommand{\hsgn}{\Sigma^h}  
\newcommand{\Trj}{\mbox{Tr}}
\newcommand{\STrj}{\overline{\Trj}} 
\newcommand{\Hc}{\Cycle^h} 
\newcommand{\signat}{\sigma} 
\newcommand{\ssignat}{\sgn^s}
\newcommand{\be}{\mbox{e}}

\newcommand{\hsignat}{\sigma^h} 

\newcommand{\conc}{\bigsqcup} 


\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}

\newenvironment{proof}[1][Proof]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}


\newenvironment{newalgo}[2]{\begin{algorithm}
\caption{\textsc{#1}}\label{#2}
\begin{algorithmic}[1]
\vspace{0.0in}} {\end{algorithmic}\end{algorithm}}


\begin{document}

\title{Deciding Reachability 
 for 3-Dimensional\\ Multi-Linear Systems \thanks{This work
      was supported in part by the ``Concept for the Future'' of  
Karlsruhe Institute of
      Technology within the framework of the German Excellence  
Initiative.}}

\author{Olga Tveretina
\institute{Karlsruhe Institute of Technology\\ Karlsruhe, Germany}
\email{olga.tveretina@kit.edu}
\and
\qquad Daniel Funke
\institute{Karlsruhe Institute of Technology\\ Karlsruhe, Germany}
\email{\quad daniel.funke@student.kit.edu}
}
\def\titlerunning{Deciding Reachability  for 3-Dimensional Multi-Linear Systems}
\def\authorrunning{O. Tveretina, D. Funke}

\maketitle




\begin{abstract}
This paper deals with the problem of point-to-point reachability in multi-linear systems. 
These systems consist of a partition of the  Euclidean space into a finite number of regions  and a constant derivative assigned to each region in the partition, 
which governs the dynamical behavior of the system within it. The reachability problem for multi-linear systems has been proven to be decidable for the two-dimensional case  and  undecidable for  the dimension three and higher.
Multi-linear systems however exhibit certain properties that make  them very suitable for topological analysis. 
We prove that reachability can be decided exactly in the 3-dimensional case when  systems satisfy certain conditions. 
We show with experiments that our approach can be orders of magnitude more efficient  than simulation.
\end{abstract}


\section{Introduction}

During the last decades a lot of devices have been developed  that consist of computers  interacting with a physical environment. Computers perform discrete operations, while a physical environment has continuous dynamics. Such systems are called hybrid systems.
Many of the  applications of hybrid systems, such as
intelligent highway systems, air traffic management systems and others  are \emph{safety critical} and require
the guarantee of a safe operation. 


Formally verifying safety properties of hybrid
systems consists of building a set of reachable states and checking if this
set intersects with a set of unsafe states. Therefore one of the
most fundamental problems in the analysis of hybrid systems is the
\emph{reachability} problem.

The reachability problem is known as being difficult. It has been shown to be
decidable for special kinds of hybrid automata \cite{AD94,HKPV95,LPS00,LPY99,LPY99-2} including timed automata \cite{AD94}, 
some classes of rectangular hybrid automata \cite{HKPV95} and o-minimal hybrid automata \cite{LPS00}. 


Since only  certain kinds of hybrid systems allow  for the exact computation of the reachable set,    approaches for safety verification include  the approximation of reachability analysis and  abstraction techniques. 
But these  techniques are easy to fail when applied to large systems since the complexity rises up very quickly with an increase in system size.

One of the drawbacks of approximation and propagation techniques is that too little attention is paid to the geometric properties of the systems under analysis \cite{ASY07}.  There are two main approaches in this direction: 1) methods that use topological properties of the plane \cite{MP93}, and 2) techniques based on the existence of integrals and the ability to compute them \cite{B99}. 

In this paper we consider {\it multi-linear systems} (\ml) also often called  {\it piecewise constant derivative systems} (PCDs) in the literature.  
They  are a special kind of  hybrid system, where the number of dimensions  refers to the number of continuous 
variables. Such systems satisfy the following restrictions: A discrete state
is defined by a set of linear constraints and 
 discrete transitions do not change continuous variables. 
\ml~systems have been proven to be decidable for the two-dimensional case \cite{MP93}, 
whereas the results presented in \cite{AMP95}
state that such systems are  undecidable for  the dimension three and higher.

The decidability results for the -dimensional case rely on the existence of a periodic trajectory after a finite number of steps. This property does not hold for higher dimensions.
Nevertheless, -dimensional systems also feature some sort of regularity. And, as in the -dimensional case, -dimensional multi-linear systems  exhibit  certain properties that make  them very suitable for topological analysis.  





{\it Contribution}. 
We  consider  a subclass of multi-linear systems,  that we call multi-linear -systems. These systems 
 satisfy the following property: If there is a cyclic trajectory, then  the the points of each cycle iteration intersecting the same boundary element of a polyhedron lie on a straight line. A straightforward consequence of this assumption is that the distances between the corresponding boundary points of different rounds are proportional (-property). 
We  introduce the notion of a hypercycle, a generalization of a cycle. The infinity criterion for -dimensional case, refer to \cite{MP93}, has an analog in  dimensions. We show  that the -property holds also for hypercycles, and the reachability can be decided exactly if the derived infinity criterion for  dimensions holds for a hypercycle. 

We have implemented our approach and compared it with simulation.
As soon as our algorithm detects a cycle (or a hypercycle) for which the given infinity criterion holds, the algorithm requires constant number of steps. While the number steps for simulation grows exponentially with the distance between points. 
Algorithms for  computing  reachable states  are often based on floating point computations  that involve rounding errors and the correctness of such algorithms can be violated. Since our algorithm takes significantly less steps, it leads to more exact computations.  
 

A complete version of the paper containing all proofs and the details of the benchmarks is available at 
\cite{TF11-2}.

\section{Multi-Linear  Systems}\label{sec:basics}

Multi-linear systems consist of a partition of the  Euclidean space into a finite number of regions  and a constant derivative
assigned to each region in the partition. 
In this section we define these systems in a way similar to \cite{MP93}.


We consider an -dimensional Euclidean space   with a metric  and points in it denoted by  and . In the following, we  specify the position of any point in -dimensional space by three Cartesian coordinates. 
A {\em linear half space} is a set of all point in  satisfying , where ,  is a rational vector and  is a rational number.
A polyhedron is a  subset  of  obtained by  intersecting a finite number of linear half spaces. 
Since we have  a finite number of linear half spaces that divide the complete -dimensional Euclidean space, there are polyhedra that are not bounded from all sides. 





\begin{definition}[Polyhedral partition] Given a finite set of linear half spaces 
, we say that  is a polyhedral partition of    by  if:  
 , and     for distinct .
\end{definition}
When it is convenient we will use  instead of  to denote a polyhedral partition. 
Given a polyhedral partition ,  we define  the  set of its  boundary points  as  
 


For each polyhedron , we define the set of the boundary points as 
Note that, depending on the partition,   the set of boundary points of  some polyhedra can be empty. 

\begin{definition}[Boundary element]
 Given a polyhedral partition  and a polyhedron , we say that  is a boundary element of  if the following holds.
\begin{enumerate}
 \item[(1)] , and  
 \item[(2)] There is   such that if   then .
\end{enumerate}

\end{definition}



An -dimensional  multi-linear system consists of a partitioning  of the space 
 into a finite set of polyhedral regions  and a constant derivative   assigned to each region . 
We define such systems and a trajectory similar to \cite{MP93}.


\begin{definition}[Multi-linear system] We define a  multi-linear system   on  as
a pair , where  
is a polyhedral partition of  and   is a function that assigns a vector  to each .  
\end{definition}

 


\begin{figure}
\begin{center}

 \psset{xunit=0.45,yunit=0.40}
\begin{pspicture}(0,0)(22,10)



\rput(-2,9.5){\large }

\rput(13,9.5){\large }


\psline[linestyle=dotted,arrows=c->](1,3)(11,3)
\psline[linestyle=dotted,arrows=c->](1,3)(1,9)
\psline[linestyle=dotted,arrows=c->](1,3)(-1.5,0.5)

\psline[arrows=c-c](0,0)(0,7.5)
\psline[arrows=c-c](3,0)(3,7.5)
\psline[arrows=c-c](6,0)(6,7.5)
\psline[arrows=c-c](9,0)(9,7.5)

\psline[arrows=c-c](-1.5,1)(10,1)
\psline[arrows=c-c](-1.5,4)(10,4)
\psline[arrows=c-c](-1.5,7)(10,7)

\psline[linestyle=dashed,arrows=c-c](0,1)(1.5,2.5)
\psline[linestyle=dashed,arrows=c-c](3,1)(4.5,2.5)
\psline[linestyle=dashed,arrows=c-c](6,1)(7.5,2.5)
\psline[linestyle=dashed,arrows=c-c](9,1)(10.5,2.5)

\psline[linestyle=dashed,arrows=c-c](0,4)(1.5,5.5)
\psline[linestyle=dashed,arrows=c-c](3,4)(4.5,5.5)
\psline[linestyle=dashed,arrows=c-c](6,4)(7.5,5.5)
\psline[linestyle=dashed,arrows=c-c](9,4)(10.5,5.5)

\psline[linestyle=dashed,arrows=c-c](0,7)(1.5,8.5)
\psline[linestyle=dashed,arrows=c-c](3,7)(4.5,8.5)
\psline[linestyle=dashed,arrows=c-c](6,7)(7.5,8.5)
\psline[linestyle=dashed,arrows=c-c](9,7)(10.5,8.5)

\psline[linestyle=dashed,arrows=c-c](-0.5,2.5)(11,2.5)
\psline[linestyle=dashed,arrows=c-c](-0.5,5.5)(11,5.5)
\psline[linestyle=dashed,arrows=c-c](-0.5,8.5)(11,8.5)

\psline[linestyle=dashed,arrows=c-c](1.5,0.8)(1.5,9)
\psline[linestyle=dashed,arrows=c-c](4.5,0.8)(4.5,9)
\psline[linestyle=dashed,arrows=c-c](7.5,0.8)(7.5,9)
\psline[linestyle=dashed,arrows=c-c](10.5,0.8)(10.5,9)



\psline[linewidth=0.035,arrows=c->](5.2,4.9)(4.7,6.4)
\psline[linewidth=0.035,arrows=c->](3.3,6)(1.4,4.5)
\psline[linewidth=0.035,arrows=c->](0.7,3.8)(2.6,2)

\psline[linewidth=0.035,arrows=c->](3.5,2.7)(5.8,2.9)
\psline[linewidth=0.035,arrows=c->](6.5,2.4)(9,3.5)
\psline[linewidth=0.035,arrows=c->](8.7,4.5)(7.2,6)




\psline[linewidth=0.035,arrows=c-c](19,4.5)(18.5,6)


\psline[linewidth=0.035,arrows=c-c](18.5,6)(16.6,4.5)

\psline[linewidth=0.035,arrows=c-c](16.6,4.5)(18.5,2.7)
\psline[linewidth=0.035,arrows=c-c](16.6,4.5)(18.5,2.7)

\psline[linewidth=0.035,arrows=c-c](18.5,2.7)(21,3)


\psline[linestyle=dotted,arrows=c->](16,3)(26,3)
\psline[linestyle=dotted,arrows=c->](16,3)(16,9)


\psline[linestyle=dotted,arrows=c->](16,3)(13.5,0.5)

\psline[arrows=c-c](15,0)(15,7.5)
\psline[arrows=c-c](18,0)(18,7.5)
\psline[arrows=c-c](21,0)(21,7.5)
\psline[arrows=c-c](24,0)(24,7.5)

\psline[arrows=c-c](13.5,1)(25,1)
\psline[arrows=c-c](13.5,4)(25,4)
\psline[arrows=c-c](13.5,7)(25,7)

\psline[linestyle=dashed,arrows=c-c](15,1)(16.5,2.5)
\psline[linestyle=dashed,arrows=c-c](18,1)(19.5,2.5)
\psline[linestyle=dashed,arrows=c-c](21,1)(22.5,2.5)
\psline[linestyle=dashed,arrows=c-c](24,1)(25.5,2.5)

\psline[linestyle=dashed,arrows=c-c](15,4)(16.5,5.5)
\psline[linestyle=dashed,arrows=c-c](18,4)(19.5,5.5)
\psline[linestyle=dashed,arrows=c-c](21,4)(22.5,5.5)
\psline[linestyle=dashed,arrows=c-c](24,4)(25.5,5.5)

\psline[linestyle=dashed,arrows=c-c](15,7)(16.5,8.5)
\psline[linestyle=dashed,arrows=c-c](18,7)(19.5,8.5)
\psline[linestyle=dashed,arrows=c-c](21,7)(22.5,8.5)
\psline[linestyle=dashed,arrows=c-c](24,7)(25.5,8.5)

\psline[linestyle=dashed,arrows=c-c](14.5,2.5)(26,2.5)
\psline[linestyle=dashed,arrows=c-c](14.5,5.5)(26,5.5)
\psline[linestyle=dashed,arrows=c-c](14.5,8.5)(26,8.5)

\psline[linestyle=dashed,arrows=c-c](16.5,0.8)(16.5,9)
\psline[linestyle=dashed,arrows=c-c](19.5,0.8)(19.5,9)
\psline[linestyle=dashed,arrows=c-c](22.5,0.8)(22.5,9)
\psline[linestyle=dashed,arrows=c-c](25.5,0.8)(25.5,9)




\psline[linewidth=0.035,arrows=c-c](18.5,2.7)(21,3)
\psline[linewidth=0.035,arrows=c-c](21,3)(23.5,4.5)
\psline[linewidth=0.035,arrows=c->](23.5,4.5)(22,6)



\end{pspicture}\caption{\label{Ex_trajectory}  
a) A simple 3-\ml~and b) a possible trajectory}
\end{center}
\end{figure}


In the following we concentrate on -dimensional multi-linear  systems. A simple -dimensional multi-linear system  is depicted in Figure \ref{Ex_trajectory}. 
 The trajectories of such systems are sequences of line segments, where the break points belong to the boundaries of  polyhedra. 
Multi-linear systems are deterministic in a sense that for  each initial point there is exactly one corresponding trajectory. 

We assume that the assigned derivative vectors of two neighboring polyhedra may not be directed towards the same boundary,
since this would lead to Zeno behavior when   a system performs infinitely many transitions in a finite period of time.



In the rest of the paper we use the following notations. By  we denote the empty sequence. 
We use  to denote the concatenation of sequences  and ,    is a shortcut for the sequence . Given a sequence , we denote by   a (possibly infinite) sequence  if   is repeated at least two times. By  we mean that  for some sequences  and at most one of  and  is not the empty sequence. 

In the following definitions  for simplicity and without loss of generality we can assume that a trajectory always starts at a boundary element. 

\begin{definition}[Trajectory ] Let   be a \ml, and  be a point.
\begin{enumerate} 
\item A trajectory starting at   is a  sequence  
where for   there is   such that    and for   there is no  such that   . We denote by  the set of all trajectories of . 

\item  A sub-trajectory of , written as ,  is a finite (possibly empty) sequence 
.  We denote by  the set of all sub-trajectories of . 

\end{enumerate}
\end{definition}


\begin{definition}[Signature of a trajectory]
Let   be a \ml, and  be a point. We assume a trajectory   .  We say that a sequence of boundary elements  is  a signature of  if   for .  We denote by  the set of signatures of all trajectories of  and by  the set of signatures of all sub-trajectories of .
 \end{definition}


\begin{figure}
\begin{center}
\begin{tikzpicture}[scale=0.40]

   
\draw[thick, dotted] (0,0) -- (6,0);

\draw[->,thick, color=black!100] (0,0) -- (0.5,0.7) -- (0.7,-0.4) -- (1,0);
\draw[->,thick, color=black!80] (1,0) -- (1.5,0.7) -- (1.7,-0.4) -- (2,0);
\draw[->,thick, color=black!60] (2,0) -- (2.5,0.7) -- (2.7,-0.4) -- (3,0);


\draw[->,thick, color=black!100] (5,0) -- (5.5,0.7) -- (5.7,-0.4) -- (7,1);

\draw[thick, dotted] (7,1) -- (3,5) ;

\draw[->,thick,color=black!100] (7,1) -- (8,0.8) -- (7.7,1.5) -- (6.5,1.5);
\draw[->,thick,color=black!80] (6.5,1.5) -- (7.5,1.3) -- (7.2,2) -- (6,2);
\draw[->,thick,color=black!60] (6,2) -- (7,1.8) -- (6.7,2.5) -- (5.5,2.5);


\draw[->,thick,color=black!100] (3.5,4.5) -- (4.5,4.3) -- (4.2,5) -- (2,5);

\draw[thick, dotted] (2,5) -- (-4,-1) ;

\draw[->,thick,color=black!100] (2,5) -- (2.1,4.2) -- (1.4,4.8) -- (0.8,4.8)  -- (1,4);
\draw[->,thick,color=black!80] (1,4) -- (1.1,3.2) -- (0.4,3.8) -- (-0.2, 3.8)  -- (0,3);
\draw[->,thick,color=black!60] (0,3) -- (0.1,2.2) -- (-0.6,2.8) -- (-1.2, 2.8)  -- (-1,2);

\draw[->,thick,color=black!100] (-3,0) -- (-3.1,-0.7) -- (-3.6,-0.2) -- (-4.2, -0.2)  -- (-4,-1);


\draw[thick, dotted] (-4,-1) -- (9,-1);

\draw[->,thick, color=black!100] (-4,-1) -- (-3.5,-0.3) -- (-3.3,-1.4) -- (-3,-1);
\draw[->,thick, color=black!80] (-3,-1) -- (-2.5,-0.3) -- (-2.3,-1.4) -- (-2,-1);
\draw[->,thick, color=black!60] (-2,-1) -- (-1.5,-0.3) -- (-1.3,-1.4) -- (-1,-1);

\draw[->,thick, color=black!100] (8,-1) -- (8.5,-0.3) -- (8.7,-1.4) -- (10,0);

\draw[thick, dotted] (10,0) -- (3,7);

\draw[->,thick,color=black!100] (10,0) -- (11,-0.2) -- (10.7,0.5) -- (9.5,0.5);
\draw[->,thick,color=black!100] (3.5,6.5) -- (4.4,6.3) -- (4.2,7) -- (2,7);


\draw[thick, dotted] (2,7) -- (-5,0);
\draw[->,thick,color=black!100] (2,7) -- (1.9,6.3) -- (1.4,6.8) -- (0.8,6.8)  -- (1,6);


\end{tikzpicture}\label{HC}
\caption{A schematic representation  of a  hypercycle}
\end{center}
\end{figure}

\begin{definition}[Simple trajectory] Let   be a .   We say that  is a simple  trajectory if  
 for each  such that  and .  We denote by  the set of all simple trajectries and by 
 the set of signatures of all simple  trajectories of .  
\end{definition}

For each multi-linear system,  the number of polyhedra in the corresponding  polyhedral partition is finite. Hence, we conclude that the number of signatures corresponding to the simple trajectories is also finite. 

\begin{lemma}\label{lemma:finite_simple_signature}  For each   ,   is a finite set.  
\end{lemma}

The  notion of a cycle plays an important role in the next  section. Due to the finiteness of the  number of polyhedra in the polyhedral partition of each multi-linear system, each trajectory either reaches a region it never leaves or its subtrajectories  form cycles of boundary elements. 

\begin{definition}[Cycle]  Let   be a . We say that  , a (sub)trajectory of  ,  is a cycle if  for . We denote by  the set of all cycles of .
 
\end{definition}


Multi-linear systems for the dimension two have a nice property that makes the analysis  simpler: 
Each trajectory has an ultimately periodic structure, i.e. after finite number of steps
it forms a cycle in terms of visited boundary elements. This property does not hold for higher dimensions.  Therefore, we introduce a   notion of a hypercycle. This  is a generalization of a cycle in the following sense: a hypercycle contains (several) cycles adjoined by simple trajectories. In each iteration of the hypercycle the number of passes through each  cycle may vary but the sequence of visited boundary elements is preserved. 

\begin{definition}[Hypercycle] Let  be a multi-linear system.
We say that a trajectory   is a hypecycle  if  for ,   and  and at least one of the following holds.
\begin{itemize}
 \item There is  such that ,
\item .
\end{itemize}

We denote by  the set of all hypercycles of .
\end{definition}

In fact, the notion of a hypercycle can be generalized further by considering cycles of hypercycles. But in this paper we restrict the class of systems under consideration to the systems such that each trajectory is either a cycle or a hypercycle after finite number of steps. 




\section{Deciding Reachability for a Special Class of Multi-Linear Systems }\label{sec:reachability}

In this section we analyze topological properties of a subclass of multi-linear systems. This subclass is defined by a generalization of properties of -dimensional \ml~systems. 

 Namely, we assume  that if there is a cyclic trajectory, then  the points of each cycle iteration intersecting the same boundary element of a polyhedron lie on a straight line, called the -property. A straightforward consequence of this assumption is that the distances between the corresponding boundary points of different rounds are proportional. 

If there is a cyclic trajectory, then  the points of each cycle iteration intersecting the same boundary element of a polyhedron not necessarily lie on a straight line. In general case, even the angle  between the corresponding line segments is not preserved. Nevertheless, we tend to think that for sufficiently many systems, especially for systems having some symmetry in their description,   the trajectories obey the -property. 

 
\subsection{The Reachability Problem}

In the following to be able to perform exact computations, we assume that all coefficients in a system are rationals.

Since a  solution of a differential equation is unique for a given initial point in combination with rationality of coefficients, we obtain the following property. Given a multi-linear system and a rational  initial  point , it is possible to compute  the point  
reachable  from  after time interval  exactly.  

\begin{definition}[Reachability problem]
 Given a multi-linear system  and two points  and , the problem of point-to-point reachability   is stated as follows: Given two points , is there a trajectory  such that   .
\end{definition}



\subsection{Reachability for Multi-Linear -Systems}

Now we define formally a subclass of multi-linear systems we consider. 



\begin{figure}
\begin{center}

 \psset{xunit=0.7,yunit=0.7}
\begin{pspicture}(0,0)(16,4.5)



\rput(0,3.6){\large }

\rput(9,3.6){\large }

\psline[linewidth=0.015,arrows=c-c](0,0.4)(2,3.45)
\psline[linewidth=0.015,arrows=c-c](7,0.4)(7,3.45)
\psline[linewidth=0.015,arrows=c-c](0,0.4)(7,0.4)
\psline[linewidth=0.015,arrows=c-c](2,3.45)(7,3.45)



\psline[linestyle=dotted,arrows=c-c](3.5,0.5)(5.8,3.45)

\psline[arrows=<->](4.54,1.35)(5.13,2.129)
\psline[arrows=<->](5.2,2.18)(5.55,2.62)
\psline[arrows=<->](5.6,2.65)(5.9,3.07)

\rput(6.2,2.8){}
\rput(5.9,2.2){}
\rput(5.4,1.6){}



\psellipse*(4.25,1.5)(0.08,0.08)
\psellipse*(4.9,2.3)(0.08,0.08)
\psellipse*(5.25,2.8)(0.08,0.08)
\psellipse*(5.5,3.1)(0.08,0.08)

\psellipse*(5.65,3.3)(0.08,0.08)

\psline[linewidth=0.02,arrows=c->](3.4,2.3)(4.245,1.55)
\psline[linewidth=0.02,arrows=c->](4.05,3.1)(4.85,2.35)

\psline[linewidth=0.02,arrows=c->](4.4,3.6)(5.245,2.85)
\psline[linewidth=0.02,arrows=c->](4.65,3.9)(5.45,3.15)
\psline[linewidth=0.02,arrows=c->](4.8,4.1)(5.645,3.35)


\psline[linewidth=0.015,arrows=c-c](9,0.4)(11,3.45)
\psline[linewidth=0.015,arrows=c-c](16,0.4)(16,3.45)
\psline[linewidth=0.015,arrows=c-c](9,0.4)(16,0.4)
\psline[linewidth=0.015,arrows=c-c](11,3.45)(16,3.45)


\psline[linestyle=dotted,arrows=c-c](9.9,0.5)(12.2,3.45)
\psline[linestyle=dotted,arrows=c-c](10.5,0.5)(12.8,3.45)
\psline[linestyle=dotted,arrows=c-c](12.5,0.5)(14.8,3.45)




\psellipse*(10.65,1.5)(0.08,0.08)
\psellipse*(11.3,2.3)(0.08,0.08)
\psellipse*(11.7,2.8)(0.08,0.08)
\psellipse*(11.9,3.1)(0.08,0.08)
\psellipse*(12.05,3.3)(0.08,0.08)

\psellipse*(11.25,1.5)(0.08,0.08)
\psellipse*(11.9,2.3)(0.08,0.08)
\psellipse*(12.3,2.8)(0.08,0.08)
\psellipse*(12.5,3.1)(0.08,0.08)
\psellipse*(12.65,3.3)(0.08,0.08)




\psellipse*(13.25,1.5)(0.08,0.08)
\psellipse*(13.9,2.3)(0.08,0.08)
\psellipse*(14.25,2.8)(0.08,0.08)
\psellipse*(14.5,3.1)(0.08,0.08)

\psellipse*(14.65,3.3)(0.08,0.08)


\psline[arrows=<->](13.54,1.35)(14.13,2.129)
\psline[arrows=<->](14.2,2.18)(14.55,2.62)

\rput(14.9,2.2){}
\rput(14.4,1.6){}



\psline[arrows=<->](11.54,1.35)(12.13,2.129)
\psline[arrows=<->](12.2,2.18)(12.55,2.62)

\rput(12.9,2.2){}
\rput(12.4,1.6){}



\end{pspicture}\caption{\label{prop}  
 -cycle:  a) , and  b) }
\end{center}
\end{figure}


\begin{definition}[-cycle and -line]\label{def:lambda-property} Let  be a \ml. Suppose for   the following holds.
\begin{itemize} 
\item   where for   ,  there are
 and    such that  .
\item  for  ,  , .

\end{itemize} 
Then we say that    is a -cycle.  We say that  a line  is a -line of  with respect to  if  , , . 
\end{definition}

The notion of -cycle  can be extended to a hypercycle.  In the following, given two parallel lines  and , we denote by  the distance between  and , i.e. the length of a line segment  such that ,   and .


\begin{figure}
\begin{center}

 \psset{xunit=0.7,yunit=0.70}
\begin{pspicture}(0,0)(36,4.5)



\psline[linewidth=0.015,arrows=c-c](7,0.4)(11,3.45)
\psline[linewidth=0.015,arrows=c-c](16,0.4)(16,3.45)
\psline[linewidth=0.015,arrows=c-c](7,0.4)(16,0.4)
\psline[linewidth=0.015,arrows=c-c](11,3.45)(16,3.45)

\rput(12.45,3.9){\small }
\rput(13.25,3.9){\small }
\rput(14.55,3.9){\small }

\psline[linewidth=0.02,arrows=<->](12,3.6)(12.5,3.6)
\psline[linewidth=0.02,arrows=<->](12.6,3.6)(13.5,3.6)
\psline[linewidth=0.02,arrows=<->](13.6,3.6)(15.5,3.6)

\psline[linewidth=0.05,linestyle=dotted,arrows=c-c](9.5,0.5)(12,3.43)
\psline[linewidth=0.05,linestyle=dotted,arrows=c-c](10,0.5)(12.5,3.43)
\psline[linewidth=0.05,linestyle=dotted,arrows=c-c](11,0.5)(13.5,3.43)
\psline[linewidth=0.05,linestyle=dotted,arrows=c-c](13,0.5)(15.5,3.43)

\end{pspicture}\caption{\label{fig:lambda_hypercycle}  
 -hypercycle:  The ratio of the distances between -lines of consequitive rounds of a hypercycle is preserved: }
\end{center}
\end{figure}


\begin{definition}[-hypercycle] Let  be a \ml.
 Suppose a trajectory  is a hypercycle, i.e.   for . Let for ,   ,  and , ,  and   are -lines for  of the corresponding consecutive rounds , ,  and  of .  We say that  is a -hypercycle if 
 where , .
\end{definition}


\begin{definition}[-system]  Let  be a \ml. We say that  is a -system if for each  the following holds: 
1)  If  is a cycle then  is a -cycle.
2)  If  is a hypercycle then  is a -hypercycle.
\end{definition}


As the next step, we  define computable properties that would allow us to check whether a system is a -system.
Lemma \ref{prop:traj} defines conditions sufficient for a cycle to be a  -cycle:  As soon as three points of consecutive  cycle iterations  lie on a straight line, the ratio of the distances between  consecutive points of different rounds is preserved. 

\begin{lemma}\label{prop:traj} Let  be a  \ml. Suppose  for  and  . Assume that ,  ,  are consecutive points of intersection of  and . If  for some line  then   is a -cycle. 
\end{lemma}



As we see in Lemma \ref{lem:lambda-prop}, it is sufficient  for the -property to hold for two distinct trajectories going through the same  cycle of boundary elements.  Then it holds for each cycling trajectory
going through the same cycle. Note that it is sufficient to compute for each trajectory whether three points of the consecutive rounds are in one line.


\begin{lemma}\label{lem:lambda-prop} Let  be a \ml. Suppose  for a trajectory , .
Assume that   and  are -cycles. Then the following holds.
\begin{itemize}
 \item  is a -cycle. 
\item , where  is a  -line of  with respect to  for each . 
\end{itemize} 
\end{lemma}

\begin{lemma}\label{lemma:lambda_hypercycle} Let  be a \ml.  Suppose  each   is a -cycle. Then each   is a -hypercycle. 
\end{lemma}

\begin{theorem}\label{theorem:criterion} Let  be a multi-linear system. Then  it is decidable whether  is a -system.
\end{theorem}

\begin{proof}
 By Lemma  \ref{lemma:finite_simple_signature}, the set  is finite.  By  Lemmas \ref{prop:traj}, \ref{lem:lambda-prop} and \ref{lemma:lambda_hypercycle} it is sufficient to perform the following steps:
1) For each  to choose two distinct  and  such that  and  .  2) To compute  three consecutive points of intersection of  and  with . 3) To check whether these points are  in one line.    
\end{proof}

We have shown that if each  cycle is a -cycle then the given system is a -system. The algorithm to check whether a (hyper)cycle is infinite is presented in the next section and it  is an extension of the -dimensional case  from \cite{MP93}.


\section{Algorithm for Point-to-Point Reachability}\label{sec:algorithm}




\begin{newalgo}{Point-to-Point Reachability}{alg:ptp_reachability}
  \INPUT points , \ml~system , maximal simulation steps 
  \OUTPUT 
  
  \medskip
  
  \STATE  \COMMENT{ and  for some partition }
  \STATE 
  
  \WHILE {}
    \STATE 
    \IF {cycle  detected}
      \IF [boundary element of  is in cycle] {}
	\IF  { for }
	  \RETURN \TRUE
	\ENDIF 
      \ENDIF \COMMENT{ is not reached by cycle }
      
      \IF{}
	\RETURN \FALSE
      \ELSE
	\STATE 
      \ENDIF
    \ENDIF \COMMENT{cycle detected}
  \ENDWHILE
  
  \RETURN 
\end{newalgo}


\begin{newalgo}{Infinity test}{alg:infinity}
  \INPUT cycle 
  \OUTPUT  is infinite cycle
  
  \medskip
  
  \FORALL{}
    \FORALL{}
	\IF [trace intersects \ensuremath{e}] {}
	  \IF{}
	    \RETURN \FALSE
	  \ELSE
	    \IF{}
	      \RETURN \FALSE
	    \ENDIF
	  \ENDIF
	\ENDIF
    \ENDFOR
  \ENDFOR
  
  \RETURN \TRUE
\end{newalgo}
\begin{newalgo}{Exit point}{alg:exit_point}
  \INPUT cycle 
  \OUTPUT point  where cycle  is abandoned
  
 \medskip
  
  \STATE 
  \FORALL{}
    \IF{}
      \STATE \textbf{skip}
    \ENDIF
    
    \FORALL{}
	\STATE 
    \ENDFOR
    
    \STATE 
    \IF{}
      \STATE  \STATE 
    \ELSE
      \STATE 
    \ENDIF
    
    \STATE  \STATE 
  \ENDFOR
  
  \RETURN 
\end{newalgo}


First  we need to introduce some further notations. Let  denote the border element  such that  for some partition  and . An edge  is given in the form of  Furthermore, given a cycle , let  denote the point reached by the cycle in the th iteration on border element . Then  for  is the line through the trajectory points on  (-line), called a trace in the following.


Algorithm \ref{alg:ptp_reachability} decides for a \ml~system  and a starting point  whether a point  can be reached by a trajectory  through . The algorithm is allowed to perform  simulations of , note that  can be much larger than  as our experiments will show.

While the maximum number of evaluations is not reached,  is simulated stepwise until either  is reached or a cycle is detected. In our implementation we use the cycle detection algorithm due to Brent \cite{B80} which requires  system evaluations.\footnote{ denoting the first occurrence of the cycle,  indicating the cycle length.} 

If a cycle  is detected, several cases have to be distinguished: 

\begin{enumerate}

\item[a)]  is \emph{not} part of the cycle.\footnote{ is the border element reached from  by simulating , see algorithm \ref{alg:ptp_reachability} step 1.} If  is infinite according to Algorithm \ref{alg:infinity},  will never be reached. 

\item[b)]   for some  and hence is element of the cycle. In this case it needs to be checked whether  such that . If so then  should be in  for some . For all ,  therefore  is in  iff  is reached by a cycle iteration. If  is not reached by  and the cycle is infinite,  is never reached by  from .

\item[c)]   is not reached by  and the cycle is \emph{finite}. We calculate the point  where  is abandoned according to algorithm \ref{alg:exit_point} and continue simulation and cycle detection there.

\end{enumerate}


The infinity test (Algorithm \ref{alg:infinity}) checks for every partition  in cycle  whether the trace line  intersects with some . If a intersection point  exists and  then  must abandon  after some number of iterations and therefore can not be infinite. If no intersection occurs or  and the convergence point  lies before  on the trace line,  is never abandoned. If no partition within the cycle is ever abandoned then  is infinite.


For a finite cycle , Algorithm \ref{alg:exit_point} determines the exit point  from . Recall that an edge can be represented as . For every  the intersection point  with the trace line is determined. 

The intersection point with the smallest distance  to  is the exit point to . The number of cycle iterations fully contained in  is given by  with point  Special consideration is given to , refer to Algorithm \ref{alg:exit_point}. The overall exit point to cycle  can therefore be determined by  with .





\section{Experiments}\label{sec:experiments}

\begin{figure}[tb]
  \centering
  \subfloat[]{\includegraphics[width=.38\textwidth]{img/system1_3D}}
  \subfloat[]{\includegraphics[width=.38\textwidth]{img/system2_3D}}
  \caption{Example \ml~systems with trajectories. The convergence line of  is highlighted in red.}
  \label{fig:example_systems}
\end{figure}

\begin{figure}[tb]
  \centering
  \subfloat[ plane]{\includegraphics[width=.3\textwidth]{img/system1_xy}}
  \subfloat[ plane]{\includegraphics[width=.3\textwidth]{img/system1_xz}}
  \subfloat[ plane]{\includegraphics[width=.3\textwidth]{img/system1_yz}}
  \caption{Projections of trajectory in . In c), the dashed black line indicates the trajectory if the points were to be on one line.}
  \label{fig:projections1}
\end{figure}

\begin{figure}[tb]
  \centering
  \includegraphics[width=.28\textwidth]{img/system2_xz}
  \caption{Projection on  plane of trajectory in . With each iteration of the hyper cycle, more iterations of the simple cycle through the four 3 dimensional polyhedra are required to reach . Therefore no infinite simple cycle exits in .}
  \label{fig:projections2}
\end{figure}



The  experiments were performed on a server with two dual-core 2.8 GHz CPUs and 3 GB main memory under RedHat Linux. We implemented the algorithms in Java using the JAMA library for linear algebra operations \cite{HetAl00}. 
The source code of our implementation is available at \cite{TF11}.



Two sample \ml~systems were used in our experiments and are depicted in Figure \ref{fig:example_systems} alongside a sample trajectory for each.  The  details of the examples can be found in \cite{TF11-2}.






All partitions in  are unbounded in the  dimension. The  plane is divided into four inner partitions and 8 outer ones. In the inner partitions the trajectory \enquote{rotates} around the center with increasing radius, whereas the radius decreases in the outer partitions. 
Not all choices of  result in a -system. Note that in figure \ref{fig:projections1} the points of a trace through one border element (depicted in red) lie on one line for 2 projections ( and ), but violate the line criterion for the  projection.



System  consists of 5 two dimensional polygons and 4 unbounded three dimensional polyhedra. In the unbounded regions the system \enquote{rotates} around the  axis in ever shrinking circles until it reaches .  then traverses all two dimensional polygons until it reaches  where it is ejected into to the unbounded space again. With each iteration more and more rotations are required in the unbounded space to reach  and the trajectory through  converges towards the  axis. Therefore the system never reaches an infinite simple cycle as illustrated in figure \ref{fig:projections2}.

In  placing the initial point  at any distance  from the inner four partitions results in  simulation steps until the inner portion is reached. Our algorithm reduces the complexity to  in general, considering  even to . Only three cycle iterations are required to calculate  for each  and determine the exit point of the cycle. Experimental data is shown in table \ref{tab:experiment} and figure \ref{fig:experiment:a}. We attribute the decrease in running time of our algorithm in the first two iterations to the Java just in time compiler, optimizing code dynamically as it is executed \cite{CetAl97}. Thereafter the algorithm exhibits constant execution time as anticipated.

Modifying  to  so that the rotation radius decreases in the outer partitions as well as in the inner partitions,\footnote{Specifically setting  to .} produces a convergence line for all partitions at . Simulation alone may \emph{never} determine whether  is reached, whereas our algorithm requires again three cycle iterations of length at most 12 to determine the reachability of .

\ml~system  exhibits a similar behavior. With each pass through the two dimensional partitions the number of required rotations to reach the  axis again increases to infinity. Therefore the reachability of  on or close to the convergence line of the system is not feasibly determined by simulation alone. If  is reached after  hyper cycle iterations, at least  simulation steps were required. Our algorithm reduces the complexity to . With improved hyper cycle handling the complexity ought to be further reduced to , since three passes of the simple cycle to reach the  axis suffice to determine the convergence line of the hyper cycle. Again, experimental data is shown in table \ref{tab:experiment} and figure \ref{fig:experiment:b}. The data exhibits the same behavior as for  regarding the Java just in time compilation. Due to its position  reaches  before  and therefore requires fewer simulation steps than .

\begin{table}[tb]
  \centering
  \begin{footnotesize}
  \subfloat[:  is first point to be reached in the inner four partitions.]{
  \begin{tabular}{|l|r|r|r|}
  \hline
   & \multirow{2}{*}{\textbf{Steps}} & \multirow{2}{*}{\textbf{Simulation}} & \multirow{2}{*}{\textbf{PTPR}} \\
  \cline{1-1}
   & & & \\
  \hline  
   & 10 & 10 & 24 \\ 
   & 154 & 98 & 18 \\ 
   & 1594 & 1421 & 6 \\ 
   & 15994 & 2082 & 6 \\ 
   & 159994 & 22609 & 5 \\ 
   & 1599994 & 188276 & 5 \\ 
   & 15999994 & 1952252 & 5 \\ 
   & 159999994 & 19700805 & 7 \\
  \hline
  \end{tabular}}
  \subfloat[: .]{
  \begin{tabular}{|l|r|r|r|}
  \hline
   & \multirow{2}{*}{\textbf{Steps}} & \multirow{2}{*}{\textbf{Simulation}} & \multirow{2}{*}{\textbf{PTPR}} \\
  \cline{1-1}
   & & & \\
  \hline  
   & 10 & 10 & 12 \\
   & 59 & 20 & 13 \\
   & 83 & 17 & 3 \\
   & 111 & 23 & 4 \\
   & 135 & 26 & 4 \\
   & 149 & 30 & 3 \\
   & 161 & 33 & 3 \\
   & 143 & 29 & 3 \\
  \hline
  \end{tabular}}
  \end{footnotesize}
\caption{Comparison of our algorithm to pure simulation to decide reachability of  given . Column \emph{steps} lists the number of simulation steps required to reach . Columns \emph{simulation} and \emph{PTPR} give the time in [ms] required to decide reachability by simulation and our algorithm, respectively.}
\label{tab:experiment}
\end{table}

\begin{figure}[tb]
  \centering
  \subfloat[]{\includegraphics[width=.42\textwidth]{img/chart_h1}\label{fig:experiment:a}}
  \subfloat[]{\includegraphics[width=.42\textwidth]{img/chart_h2}\label{fig:experiment:b}}
  \caption{Comparison of our algorithm (\emph{PTPR}) to pure simulation to decide reachability of  given .}
  \label{fig:experiment}
\end{figure}



\section{Conclusions}\label{sec:conclusions}

The complexity of safety critical systems has increased dramatically over last decades. 
The safety properties of such systems  can often not be checked exactly  either due to theoretical boundaries or due to too large
computational efforts required. One of the drawbacks of recent techniques is that too little attention is paid to the geometric properties of the systems under analysis.

A hybrid system (a hybrid automaton) is a formalism that can be used  for modeling safety critical systems. \ml~systems constitute a rather simple class of hybrid systems but yet they are on the boundary of decidable and undecidable systems.  

\ml~systems have certain properties that make them very suitable for a topological analysis. 
 We have shown that on the one hand there are systems with acyclic behavior, and on the other hand if
some properties of -dimensional systems hold in three dimensions then it is possible to answer  exactly  whether a point  is reachable from a point .   
We have presented a prototype implementation of our approach for solving the reachability problem for a subclass of multi-linear systems which we have called -systems.
We compared our approach  with simulation. The results  suggest, that using geometrical properties of the systems can lead  to  orders of magnitude more efficient techniques than simulation.
As soon as our algorithm detects a cycle (or a hypercycle) for which the infinity criterion holds, the algorithm requires constant number of steps. While the number steps for simulation grows exponentially with the distance between points. 
Also  our algorithm can lead to more exact computations because of  less rounding errors during the computation. 





\bibliographystyle{packages/eptcs}

\bibliography{HybridSystems}



\end{document} 