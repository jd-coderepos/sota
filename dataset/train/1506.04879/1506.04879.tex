\documentclass{LMCS}

\def\dOi{11(3:15)2015}
\lmcsheading {\dOi}
{1--27}
{}
{}
{Jan.~13, 2014}
{Sep.~17, 2015}
{}

\ACMCCS{[{\bf Software and its engineering}]: Software organization
  and properties---Software functional properties---Formal
  methods---Software verification; [{\bf Theory of computation}]:
  Semantics and reasoning---Program reasoning---Program verification}

\usepackage{hyperref}

\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}

\usepackage{tikz}
\usetikzlibrary{arrows,calc,automata,petri,shapes,positioning,shadows,decorations.markings,decorations.pathreplacing,fit,matrix}

\tikzset{
>=stealth',
help lines/.style={dashed, thick},
axis/.style={<->},
important line/.style={thick},
connection/.style={thick, dotted},
}

\usepackage{amsfonts, stmaryrd, amssymb, amsthm, amsmath}

\usepackage[inference]{semantic}

\usepackage{bm,xspace,multirow}

\newcommand{\myif}{\mathit{if}}

\newcommand{\mycomment}[1]{}

\newcommand{\new}[1]{#1}
\newcommand{\neww}[1]{#1}
\newcommand{\ctau}{\tau}

\newcommand{\malert}[1]{\textcolor{red}{#1}}

\newcommand{\delete}[1]{\textcolor{OliveGreen}{MAYBE Delete?: #1}}
\newcommand{\newww}[1]{\textcolor{WildStrawberry}{NEW: #1}}
\newcommand{\todo}[1]{\textcolor{OrangeRed}{TODO: #1}}
\newcommand{\rephrase}[1]{\textcolor{Cerulean}{REPHRASE: #1}}
\newcommand{\chg}[1]{\textcolor{OrangeRed}{CHANGED: #1}}
\newcommand{\q}[1]{\textcolor{Fuchsia}{Q: #1}}
\newcommand{\plan}[1]{\textcolor{WildStrawberry}{PLAN: #1}}

\newcommand{\mand}[1]{\displaystyle{\bigwedge_{#1}}}
\newcommand{\mor}[1]{\displaystyle{\bigvee_{#1}}}

\newcommand{\titlefont}{\fontsize{15pt}{13pt}\fontfamily{phv}\fontseries{bx}\selectfont}
\newcommand{\sectionfont}{\fontsize{9pt}{7pt}\fontfamily{phv}\fontseries{bx}\selectfont}

\newcommand{\ta}{\mathit{TA}}
\newcommand{\iotau}{\textup{I/O Timed Automaton with urgencies}}
\newcommand{\tah}{\textup{TA}^h_i\xspace}
\newcommand{\hta}{H}

\newcommand{\hp}{\mathcal{H}_A}
\newcommand{\ha}{\mathcal{H}_{\gamma}}
\newcommand{\actions}{\mathit{Act}}
\newcommand{\hist}{\mathcal{H}}

\newcommand{\eqs}{\mathcal{E}}
\newcommand{\eqsc}{\mathcal{E}^*}

\newcommand{\X}{\mathcal{X}}
\newcommand{\post}{\mathit{post}}
\newcommand{\en}{\mathit{enabled}}
\newcommand{\dis}{\textit{DIS}}
\newcommand{\disf}{\textit{DIS}}
\newcommand{\disg}{\textit{DIS}}
\newcommand{\live}{\textit{Live}}
\newcommand{\msucc}{\mathsf{succ}}
\newcommand{\dsucc}{\mathsf{disc}\_\mathsf{succ}}
\newcommand{\tsucc}{\mathsf{time}\_\mathsf{succ}}
\newcommand{\sink}{\mathsf{sink}}
\newcommand{\source}{\mathsf{source}}
\newcommand{\inv}{\mathsf{tpc}}
\newcommand{\close}{\mathsf{norm}}
\newcommand{\bv}{\bold{v}}
\newcommand{\bl}{\vec{l}}
\newcommand{\transit}[1]{\stackrel{#1}{\rightarrow}}
\newcommand{\reach}{\mathit{Reach}}
\newcommand{\sigmae}{\Sigma^{\epsilon}}

\newcommand{\invs}{\mathit{Inv}}

\newcommand{\cn}{\mathit{B}\xspace}

\newcommand{\ctn}{\mathit{Controller}}
\newcommand{\cwk}{\mathit{Worker}}
\newcommand{\cwki}{\mathit{Worker}_i}
\newcommand{\cwkO}{\mathit{Worker}_1}

\newcommand{\true}{\mathit{true}\xspace}
\newcommand{\false}{\mathit{false}\xspace}
\newcommand{\ic}{\mathit{CI}}
\newcommand{\iim}{\mathit{II}}

\newcommand{\bip}{\textup{BIP}\xspace}
\newcommand{\rtbip}{\textup{RT-BIP}\xspace}
\newcommand{\fbip}{\mathcal F(\bip)}


\newcommand{\frtbip}{\mathcal F(\textup{TA})}

\newcommand{\gf}{\textup{GF}}

\newcommand{\sep}{\mathcal{S}}

\newcommand{\gi}{\mathit{GI}}
\newcommand{\gih}{\mathit{GI}^h}
\newcommand{\gic}{\mathit{GI}^*}

\newcommand{\var}{\mathit{Var}}

\newcommand{\vr}{(VR)}
\newcommand{\vrh}{(VR)}
\newcommand{\vrc}{(VR)}

\newcommand{\tdfinder}{CoVerTS}

\newcommand{\safe}{\mathit{Safe}}

\newcommand{\te}{h_0}
\newcommand{\lstp}{l_{stop}}
\newcommand{\systcw}{C\|^N_{\gamma} W}

\newcommand{\systcp}{C\|^n_{\gamma} P_i}

\newcommand{\systp}{\|^n_{\gamma} P_i}

\newcommand{\compgamma}{B^*}
\newcommand{\sysgammah}{\compgamma \|_{\gamma^h} B_i^h}

\newcommand{\ctrl}{C}
\newcommand{\proc}{P}

\newcommand{\tdw}{\mathit{tdw}}
\newcommand{\tdc}{\mathit{tdc}}
\newcommand{\cw}{\mathit{Copy}}
\newcommand{\cf}{\mathit{Conflicts}}
\newcommand{\dummy}{\Gamma^*}
\newcommand{\fillin}{\textcolor{red}{\dots}}
\newcommand{\dl}{l^*}
\newcommand{\gp}{\gamma_{\mid a}}

\newcommand{\gs}{\mathbf{s}}
\newcommand{\exo}{Exec^{\leq}}
\newcommand{\exg}{Exec}
\newcommand{\exl}{Exec^w}
\newcommand{\exc}{Exec^{c}}

\newcommand{\sepm}{\sep^{min}}
\newcommand{\sepc}{\sep^{c}}
\newcommand{\occ}{occ}
\newcommand{\mpos}{\mathit{lpos}}
\newcommand{\actc}{A^c}

\newcommand{\mpre}{\widetilde{pre}}

\newcommand{\iterm}{\texttt{ITerm}}
\newcommand{\dterm}{\texttt{DTerm}}
\newcommand{\rterm}{\texttt{RTerm}}
\newcommand{\atom}{\texttt{Atom}}
\newcommand{\formula}{\texttt{Formula}}

\newcommand{\vtrue}{\mathit{true}\xspace}
\newcommand{\vfalse}{\mathit{false}\xspace}

\graphicspath{{Figs/}}
 \newcommand{\compS}[3]{\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4.cm,semithick,font=\small,scale = .4, transform canvas={scale=.4}]\tikzstyle{every state}=[fill=white,text=black]\node[state, accepting] (c0#1) at(#2,#3) {\small };\node[state]         (c1#1) [below of=c0#1] {\small };\path (c0#1) edge[bend left] node[right] {\parbox{1.3cm}{\small \\:=0}} (c1#1)(c1#1) edge[bend left] node[left] {\parbox{1.cm}{\small \\:=0}} (c0#1);\end{tikzpicture}}

\newcommand{\comp}[3]{\node[state, accepting] (c0#1) at(#2,#3) {\small };\node[state]         (c1#1) [below of=c0#1] {\small };\path (c0#1) edge[bend left] node[right] {\parbox{1.3cm}{\small \\:=0}} (c1#1)(c1#1) edge[bend left] node[left] {\parbox{1.cm}{\small \\:=0}} (c0#1);\node[draw,left=1.4cm of c0#1.north] (l0#1) {};\node[draw,right=1.7cm of c1#1.south] (l1#1) {};\node[draw, rectangle, inner sep=0, fit=(l0#1) (l1#1)] {};\node[left=3.cm of l1#1.west] (C#1) {};}

\newcommand{\rodeSlides}[3]{\node[state, accepting] (r0#1) at(#2,#3) {\small };\node[state]         (r1#1) [below=.7cm of r0#1] {\small };\node[state]         (r2#1) [below of=r1#1] {\small };\path (r0#1) edge node[right]{\parbox{.7cm}{\small ini\\t:=\beta}} (r1#1)(r1#1) edge[bend left]  node[right]{\parbox{2cm}{\small cool\\ t  \beta}} (r2#1)(r2#1) edge[bend left]  node[left]{\parbox{.8cm}{\small rest\\ t:= 0}} (r1#1);\node[draw,left=1cm of r0#1.north] (ar#1) {rest};\node[draw,right=1cm of r2#1.south] (ac#1) {cool};\node[draw, rectangle, inner sep=0, fit=(ar#1) (ac#1)] {};\node[below=.5cm of ac#1.west] (R#1) {Rod};}

\newcommand{\rodeHSlides}[2]{\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4.cm,semithick,font=\small,scale = .4, transform canvas={scale=.4}]\tikzstyle{every state}=[fill=white,text=black]\node[state, accepting] (r0) at(#1,#2) {\small };\node[state]         (r1) [below=.7cm of r0] {\small };\node[state]         (r2) [below of=r1] {\small };\path (r0) edge  node[right]{\parbox{.7cm}{\small ini\\t:=\beta}} (r1)(r1) edge[bend left]  node[right]{\parbox{2cm}{\small cool\\ t  \beta\\ hc:=0}} (r2)(r2) edge[bend left]  node[left]{\parbox{.8cm}{\small rest\\ t:= 0\\ hr:=0}} (r1);\end{tikzpicture}}

\newcommand{\controllerSlides}[2]{\node[state, accepting] (AC) at(#1,#2) {};\node[state] (BC) [right of=AC] {};\node[above=.5cm of BC.west] {\small };\node[state] (CC) [right of=BC] {};\node[above=.5cm of CC.east] (invC2) {\small };\node[below=2.7cm of CC.west] {Controller};\path (AC) edge node[above]{\small ini} node[below=.5cm]{\small t := 0} (BC)(BC) edge[bend left] node[above]{\parbox{4.cm}{\centering{\small cool\\ t = , t := 0}}} (CC)(CC) edge[bend left] node[below]{\parbox{3.5cm}{\centering{\small heat\\t = \lambda, t := 0}}} (BC);drawing ports
\node[draw,above=1.5cm of AC.north west] (ch) {heat};\node[draw,below=2.5cm of invC2.south east] (cc) {cool};bounding box for controller
\node[draw, rectangle, inner sep=0, fit=(ch) (cc)] {};}

\newcommand{\controllerH}[2]{\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4.cm,semithick,font=\small,scale = .4, transform canvas={scale=.4}]\tikzstyle{every state}=[fill=white,text=black]\node[state, accepting] (AC) at(#1,#2) {};\node[state] (BC) [right of=AC] {};\node[above=.5cm of BC.west] {\small };\node[state] (CC) [right of=BC] {};\node[above=.5cm of CC.east] (invC2) {\small };\node[below=2.7cm of CC.west] {Controller};\path (AC) edge node[above]{\small ini} node[below=.5cm]{\small t := 0} (BC)(BC) edge[bend left] node[above]{\parbox{4.cm}{\centering{\small cool\\ t = \\t:=0, hc:=0}}} (CC)(CC) edge[bend left] node[below]{\parbox{3.5cm}{\centering{\small heat\\ t=\lambda, t := 0, hh:=0}}} (BC);\end{tikzpicture}}

\newcommand{\controllerHNC}[2]{\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4.cm,semithick,font=\small,scale = .4, transform canvas={scale=.4}]\tikzstyle{every state}=[fill=white,text=black]\node[state, accepting] (AC) at(#1,#2) {};\node[state] (BC) [right of=AC] {};\node[above=.5cm of BC.west] {\small };\node[state] (CC) [right of=BC] {};\node[above=.5cm of CC.east] (invC2) {\small };\node[below=1.2cm of AC.east] {Controller};\path (AC) edge node[above]{\small ini} node[below=.5cm]{\small t := 0} (BC)(BC) edge node[above]{\small cool,t = } node[below=.6cm]{\small t:=0, hc:=0} (CC)(CC) edge[bend left=45] node[below]{\parbox{3.5cm}{\centering{\small heat, t=\lambda\\ t := 0, hh:=0}}} (BC);\path (CC) edge[bend right=45] node[above=1cm]{\parbox{3.5cm}{\centering{\small heat, t=\lambda\\ t := 0, hh:=0}}} (BC);\end{tikzpicture}}

\newcommand{\rode}[3]{\node[state, accepting] (r0#1) at(#2,#3) {\small };\node[state] (r1#1) [below=.6cm of r0#1] {\small };\node[state] (r2#1) [below=.8cm of r1#1] {\small };\path (r0#1) edge node[right]{\parbox{2cm}{\small }}
  (r1#1)(r1#1) edge[bend left] node[right]{\parbox{2.3cm}{\small   }} (r2#1)(r2#1) edge[bend left] node[left]{\parbox{1.9cm}{\small := 0}} (r1#1);\node[draw,left=1.5cm of r0#1.north] (ar#1) {};\node[draw,right=1.5cm of r2#1.south] (ac#1) {};\node[draw, rectangle, inner sep=0, fit=(ar#1) (ac#1)] {};\node[below=.6cm of r2#1.south] (R#1) {Rod};}

\newcommand{\malpha}{900}
\newcommand{\mlambda}{450}

\newcommand{\controller}[2]{\node[state, accepting] (AC) at(#1,#2) {};\node[state] (BC) [below=.6cm of AC] {};\node[left=.0cm of BC.west] {\small };\node[state] (CC) [below=.8cm of BC] {};\node[left=.0cm of CC.west] (invC2) {\small };\node[below=.6cm of CC.south] {Controller};\path (AC) edge node[right]{\parbox{1.cm}{\small}} (BC)(BC) edge[bend left] node[right]{\parbox{1.9cm}{\small =\\:=0}} (CC)(CC) edge[bend left] node[left]{\parbox{1.7cm}{\small = \\  := 0}} (BC);drawing ports
\node[draw,left=1.5cm of AC.north] (ch) {};\node[draw,right=1.5cm of CC.south] (cc) {};bounding box for controller
\node[draw, rectangle, inner sep=0, fit=(ch) (cc)] {};}

\newcommand{\cTikz}[2]{\node[state, accepting] at (#1,#2) (l0) {\small };\node[state]         (l1) [below=.7cm of l0] {\small };\node [left=.05cm of l1] {\small };\node[state]         (l2) [below=.8 of l1] {\small };\path (l0) edge node [right] {\small \parbox{1.3cm}{\\ }} (l1)(l1) edge[bend left] node[right] (gb) {\parbox{1.3cm}{\small \\:=0}} (l2)(l2) edge[bend left] node[left] (gd) {\parbox{.95cm}{\small \\}} (l1);\node[draw,right=1.1cm of l0.north east] (a) {};\node[draw,right=1.15cm of l2.south east] (c) {};bounding box for controller
\node[draw, rectangle, inner sep=0, fit= (gd) (a) (c)] (boxc) {};\node[left=.3cm of boxc.north,xshift=.2cm,yshift=.3cm] (ctrl) {};
}

\newcommand{\wTikz}[3]{\node[state, accepting] (l3#1) at (#2,#3) {\small };\node[state]         (l4#1) [below=.7cm of l3#1] {\small };\path (l3#1) edge[bend left] node[right] (gb#1) {\parbox{1.35cm}{\small }} (l4#1)(l4#1) edge[bend left] node[left] (gd#1) {\parbox{1.46cm}{\small }} (l3#1);\node[draw,left=1.2cm of l3#1.north west] (b#1) {};\node[draw,left=1.2cm of l4#1.south west] (d#1) {};\node[draw, rectangle, inner sep=0, fit=(b#1) (d#1) (gb#1) (gd#1)] (boxw#1) {};\node[below=.2cm of boxw#1.south] (w#1) {};}

\newcommand{\wTikzR}[3]{\node[state, accepting] (l3#1) at (#2,#3) {\small };\node[state]         (l4#1) [below=.7cm of l3#1] {\small };\path (l3#1) edge[bend left] node[right] (gb#1) {\parbox{1.35cm}{\small }} (l4#1)(l4#1) edge[bend left] node[left] (gd#1) {\parbox{1.46cm}{\small }} (l3#1);\node[draw,right=1.1cm of l3#1.north east] (b#1) {};\node[draw,right=1.1cm of l4#1.south east] (d#1) {};\node[draw, rectangle, inner sep=0, fit=(b#1) (d#1) (gd#1) (gb#1)] (boxw#1) {};\node[below=.2cm of boxw#1.south] (w#1) {};}

\newcommand{\wTikzO}[4]{\tikzset{draw opacity=#4}
\node[state, accepting,opacity=#4*#4] (l3#1) at (#2,#3) {\small };\node[state,opacity=#4*#4]         (l4#1) [below=.8cm of l3#1] {\small };\path (l3#1) edge[bend left,opacity=#4*#4] node[right] (gb#1) {\parbox{1.2cm}{\small }} (l4#1)(l4#1) edge[bend left,opacity=#4*#4] node[left] (gd#1) {\parbox{1.1cm}{\small }} (l3#1);\node[draw,left=.8cm of l3#1.north west,opacity=#4] (b#1) {};\node[draw,left=.8cm of l4#1.south west,opacity=#4] (d#1) {};\node[draw, rectangle, inner sep=0, fit=(b#1) (d#1) (gb#1) (gd#1), opacity=1*#4] (boxw#1) {};\node[right=.3cm of boxw#1.north, xshift=.2cm, yshift=.2cm, opacity=#4] (w#1) {};}

\newcommand{\chTikz}[2]{\node[state, accepting] at (#1,#2) (l0) {\small };\node[state]         (l1) [below=.7cm of l0] {\small };\node [left=.05cm of l1] {\small };\node[state]         (l2) [below of=l1] {\small };\path (l0) edge node [right] {\small  \\ } (l1)(l1) edge[bend left] node[right] (gb) {\parbox{1.3cm}{\small \\:=0\\}} (l2)(l2) edge[bend left] node[left] (gd) {\parbox{1.3cm}{\small \\\\}} (l1);\node[draw,right=1.cm of l0.north east] (a) {};\node[draw,right=1.cm of l2.south east] (c) {};bounding box for controller
\node[draw, rectangle, inner sep=0, fit= (gd) (a) (c)] (boxc) {};\node[below=.3cm of boxc.south] (ctrl) {};
}

\newcommand{\whTikz}[3]{\node[state, accepting] (l3#1) at (#2,#3) {\small };\node[state]         (l4#1) [below of=l3#1] {\small };\path (l3#1) edge[bend left] node[right] (gb#1) {\parbox{1.35cm}{\small \\}} (l4#1)(l4#1) edge[bend left] node[left] (gd#1) {\parbox{1.2cm}{\small \\\\}} (l3#1);\node[draw,left=1.1cm of l3#1.north west] (b#1) {};\node[draw,left=1.1cm of l4#1.south west] (d#1) {};\node[draw, rectangle, inner sep=0, fit=(b#1) (d#1) (gd#1) (gb#1)] (boxw#1) {};\node[below=.5cm of boxw#1.south] (w#1) {};}

\newcommand{\whTikzR}[3]{\node[state, accepting] (l3#1) at (#2,#3) {\small };\node[state]         (l4#1) [below of=l3#1] {\small };\path (l3#1) edge[bend left] node[right] (gb#1) {\parbox{1.35cm}{\small \\}} (l4#1)(l4#1) edge[bend left] node[left] (gd#1) {\parbox{1.2cm}{\small \\\\}} (l3#1);\node[draw,right=1.2cm of l3#1.north east] (b#1) {};\node[draw,right=1.2cm of l4#1.south east] (d#1) {};\node[draw, rectangle, inner sep=0, fit=(b#1) (d#1) (gd#1) (gb#1)] (boxw#1) {};\node[below=.5cm of boxw#1.south] (w#1) {};}

\newcommand{\chTikzSym}[2]{\node[state, accepting] at (#1,#2) (l0) {\small };\node[state]         (l1) [below=.7cm of l0] {\small };\node [left=.05cm of l1] {\small };\node[state]         (l2) [below of=l1] {\small };\path (l0) edge node [right] {\small \parbox{1.3cm}{\\}} (l1)(l1) edge[bend left] node[right] (gb) {\parbox{1.3cm}{\small \\:=0\\}} (l2)(l2) edge[bend left] node[left] (gd) {\parbox{1.3cm}{\small \\\\}} (l1);\node[draw,right=1.cm of l0.north east] (ar) {};\node[draw,right=1.cm of l2.south east] (cr) {};\node[draw,left=1.2cm of l0.north west] (al) {};\node[draw,left=1.2cm of l2.south west] (cl) {};bounding box for controller
\node[draw, rectangle, inner sep=0, fit= (gd) (al) (cl) (ar) (cr)] (boxc) {};\node[below=.3cm of boxc.south] (ctrl) {};
}

\newcommand{\trainH}[2]{\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4.cm,semithick]\tikzstyle{every state}=[fill=white,text=black]\node[state, accepting] (AT) {\small far};\node[above=.4cm of AT] (Train) {Train};\node[above=.03cm of AT] (auxt) {};\node[state]         (BT) [right of=AT] {\small near};\node[right=.1cm of BT] {\small x  5};\node[state]         (CT) [below of=BT] {\small in};\node[right=.1cm of CT] {\small x  5};\path (AT) edge              node[above]{approach} node[below=.5cm]{x:= 0, hat:=0} (BT)(BT) edge              node{()?} (CT)(CT) edge              node{\parbox{1cm}{exit\\het:=0}} (AT);\end{tikzpicture}}

\newcommand{\aapproach}{\mathit{approach}}
\newcommand{\aexit}{\mathit{exit}}

\newcommand{\trainp}[2]{\node[state, accepting] (AT) at (#1, #2) {\small };
  \node[left=.1cm of AT] (auxt) {};
  \node[state]         (BT) [right=1.45cm of AT] {\small };
  \node[right=.8cm of AT] (x) {}; 
\node[above=1.2cm of BT.south] {\small };  
  \node[state]         (CT) [below=1.45cm of x.west] {\small };
  \node[below=.06cm of CT] (inv) {\small };
  \node[below=.1cm of inv] (Train) {Train};
\node[draw, rotate=90, right=1.25cm of BT.south,xshift=.08cm] (atp) {};
  \node[draw, rotate=90, right=2.46cm of inv.south, xshift=-.1cm,yshift=-.03cm] (etp) {}; 
  \node[above=1.2cm of BT.east] (auxt1) {};
  \path 
(AT) edge              node[above]{} node[below]{\small } (BT)
(BT) edge              node{} (CT)
        (CT) edge              node{} (AT);
\node[draw, rectangle, inner sep=0, fit=(atp) (etp) (auxt) (BT) (CT) (AT) (inv)] {};
}

\newcommand{\train}[2]{\node[state, accepting] (AT) at (#1, #2) {\small };
  \node[left=.1cm of AT] (auxt) {};
  \node[state]         (BT) [right=1.45cm of AT] {\small };
  \node[right=.8cm of AT] (x) {}; 
\node[above=1.2cm of BT.south] {\small };
  \node[state]         (CT) [below=1.45cm of x.west] {\small };
  \node[below=.06cm of CT] (inv) {\small };
  \node[below=.13cm of inv] (Train) {Train};
  \path 
(AT) edge              node[above]{} node[below]{\small } (BT)
(BT) edge              node{} (CT)
        (CT) edge              node{} (AT);
\node[draw, rotate=90, right=1.2cm of BT.south,xshift=.04cm] (at) {};
  \node[draw, rotate=90, right=2.46cm of inv.south, xshift=-.2cm,yshift=-.03cm] (et) {}; 
\node[draw, rectangle, inner sep=0, fit=(at) (et) (auxt) (BT) (CT) (AT) (inv)] {};
}

\newcommand{\araise}{\mathit{raise}}
\newcommand{\alower}{\mathit{lower}}

\newcommand{\gate}[2]{\node[state, accepting] (AG)  at (#1, #2) {\small };
\node[state]         (BG) [right=1.3cm of AG] {\small };
  \node[right=.1cm of BG] (auxg) {};
  \node[above=.05cm of BG] (inv1) {\small y  1};
\node[state]         (CG) [below=1.1cm of BG] {\small  };
  \node[state]         (DG) [below=1.1cm of AG] {\small  };
  \node[below=.05cm of DG] (inv2) {\small y  2};
\node[right=.7cm of DG] (xg) {}; 
\node[below=.9cm of xg] (Gate) {Gate};
\node[draw, left=.7cm of AG,rotate=-90,xshift=-.05cm] (lg) {};
  \node[draw, left=1.2cm of inv2.south,rotate=-90] (rg) {};
  \path 
(AG) edge              node[above]{} node[below]{\small } (BG)
        (BG) edge              (CG)
(CG) edge              node[below]{} node[above]{\small } (DG)
        (DG) edge              node[left]{\small  } (AG);
\node[draw, rectangle, inner sep=0, fit=(lg) (rg) (auxg) (BG)] {};
}

\newcommand{\controllerTrain}[2]{\node[state, accepting] (AC) at (#1,#2) {};
  \node[state] (BC) [right=1.3cm of AC] {};
\node[above=.1cm of BC] {\small };
\node[state] (CC) [below=1.1cm of BC] {};
  \node[state] (DC) [below=1.1cm of AC] {};
  \node[right=.8cm of DC] (xc) {}; 
\node[below=.95cm of xc] {Controller};
\node[below=.1cm of DC] (inv3) {\small };
\node[draw, left=.95cm of inv3.south,rotate=-90] (ec) {};
\node[draw, right=.63cm of BC,rotate=90,xshift=.05cm,yshift=-.1cm] (lc) {};
  \node[draw, left=.92cm of AC.south,rotate=-90,xshift=-.02cm] (ac) {};
  \node[draw, right=3.5cm of inv3.south,rotate=90] (rc) {};
  \path 
(AC) edge node[above]{} node[below]{\small } (BC)
(BC) edge node[right]{\parbox{2cm}{\small \\ }} (CC)
(CC) edge node[above]{\small } node[below]{} (DC)
  (DC) edge node[left]{} (AC);
\node[draw, rectangle, inner sep=0, fit=(ec) (ac) (rc) (lc)] {};
}

\newcommand{\aset}{\mathit{set}}
\newcommand{\aeq}{\mathit{eq}}

\newcommand{\fischerV}[2]{\node[state] (AV) at (#1, #2) {\small };
  \node[below=.03cm of AV] (auxv) {};
  \node[state]         (BV) [right=1.45cm of AV] {\small };
  \node[right=.8cm of AV] (x) {}; 
  \node[state, accepting]  (CV) [above=1.45cm of x.west] {\small };
  \node[below=.6cm of x] (IdV) {Id Variable};
  \path 
        (AV) edge[loop left]              node[below=.3cm, xshift=.4cm]{\parbox{1cm}{}} (AV)
        (BV) edge[loop right]              node[below=.3cm, xshift=-.4cm]{{}} (BV)
        (CV) edge[loop left]              node[above=.2cm, xshift=.1cm]{{}} (CV)
(CV) edge              node[left,yshift=.25cm]{} (AV)
        (CV) edge              node{{}} (BV)
(AV) edge[in=0,out=10,bend left]  node[above]{{}} (BV)
(BV) edge[in=0,out=10,bend left]  node[above]{{}} (AV);
\node[draw, above=.25cm of CV.north] (eq0) {};
  \node[draw, right=1.2cm of eq0] (eq2) {};
  \node[draw, below=1.5cm of eq2, anchor=north, xshift=-.11cm,rotate=90] (set2) {};
  \node[draw, left=1.2cm of eq0] (eq1) {};
  \node[draw, left=4.3cm of set2, anchor=west, rotate=90] (set1) {}; 
\node[draw, rectangle, inner sep=0, fit=(set1) (set2) (eq0) (eq1) (eq2) (auxv) (AV) (CV) (BV)] {};
}

\newcommand{\aenter}{\mathit{enter}}
\newcommand{\atry}{\mathit{try}}

\newcommand{\fischerP}[3]{\node[state, accepting] (AP)  at (#1, #2) {\small };
  \node[state]         (BP) [right=(#3*3-5)*1.9cm of AP] {\small };
  \node[right=.1cm of BP] (auxp) {};
  \node[above=-.cm of BP] (inv#3) {\small };
  \node[state]         (CP#3) [below=1.1cm of BP] {\small  };
  \node[state]         (DP) [below=1.1cm of AP] {\small  };
  \node[right=(#3*3-5)*.7cm of DP] (xp) {}; 
  \node[below=.6cm of xp] (Process) {Process};
\path 
(AP) edge              node[below=(#3*.02-.02)]{} (BP)
(BP) edge              node[left=(#3*1.1-2.55)]{\parbox{1.3cm}{\small \\}} (CP#3)
(CP#3) edge              node[above=(#3*.02-.02)]{}(DP);
}

\def\testMirrror{
\fill[blue] (-0.1, -0.1) rectangle +(1.6, 3.2); 
    \fill[red] (0.8, 0) arc(180:90:0.1cm)  -- (1, 0.1) arc(-90:0:0.1cm) -- (1.1, 0.45) arc(-90:90:0.015cm and 0.03cm) -- (1.1, 0.51) arc(-90:90:0.015cm and 0.03cm)-- (1.1, 1) arc(180:90:0.05cm) -- (1.3, 1.05) arc(-90:0:0.05cm) -- (1, 1.8)  arc(210:120:0.05cm) .. controls (1.05cm, 2.2cm) and  (0.9cm, 2.3cm) ..  (0.7, 2.5).. controls (0.5, 2.7) .. (0.3, 2.7) arc(270:180:0.3cm) -- (0, 3) -- (1.5, 3) --(1.5, 0) -- cycle;  
}

\newcommand{\fischerL}[2]{
\fischerP{#1}{#2}{1}
  \node[draw, left=.55cm of eq1, anchor=east] (enter1) {};
  \node[draw, left=.8cm of enter1] (try1) {};
  \node[draw, left=1.cm of set1, anchor=west, rotate=90] (set11) {};
  \node[below=.2cm of CP1.south west, xshift=-.4cm] (auxpl) {};
  \node[draw, rectangle, inner sep=0, fit=(enter1) (set11) (inv1) (auxpl)] {};
}

\newcommand{\fischerR}[2]{
\fischerP{#1}{#2}{2}
  \node[draw, right=1.9cm of eq2, anchor=east] (enter2) {};
  \node[draw, right=.8cm of enter2] (try2) {};
  \node[draw, right=1.1cm of set2, anchor=east, rotate=90] (set22) {};
  \node[below=.2cm of CP2.south east, xshift=.4cm] (auxpr) {};
  \node[draw, rectangle, inner sep=0, fit=(enter2) (set22) (inv2) (auxpr)] {};
}




\newcommand{\colora}{blue}
\newcommand{\colore}{green}

\newcommand{\mEx}[2]{
\node[state, initial left] (l1) at(#1,#2) {\small };\node[state] (l2) [below of=l1] {\small };\node[left=0.8cm of l1.north] (c1) {};
\path (l1) edge[bend left, onslide=<2->{highlight}] node[right] {\parbox{1.3cm}{\small \\:=0}} (l2)(l2) edge[bend left] node[left]  {\small } (l1);\node[state, initial left] (l3) [right=4cm of l1] {\small };\node[state] (l4) [below of=l3] {\small };\node[right=1.2cm of l3.north] (c2) {};
\path (l3) edge[bend left, onslide=<2->{highlight}] node[right] (lhb) {\parbox{1.3cm}{\small }} (l4)(l4) edge[bend left] node[left] {\parbox{0.75cm}{\small \\:=0}} (l3);\node[draw,right=1.5cm of l2.south, minimum width=.5cm, minimum height=.5cm] (pa) {};\node[draw,left=1cm of l4.south] (pb) {};

\node[draw,right=1.5cm of l1.north, minimum width=.5cm, minimum height=.5cm] (pc) {};\node[draw,left=1cm of l3.north, minimum width=.5cm, minimum height=.5cm] (pd) {};


\node[draw, rectangle, inner sep=0, fit=(pa) (c1.north west)] {};\node[draw, rectangle, inner sep=0, fit=(pb) (c2.north east)] {};

\draw[*-*, onslide=<2->{highlight}] (pa.east) -- (pb.west);
\draw[*-*, onslide=<2->] (pc.east) -- (pd.west);

}

\newcommand{\mExH}[2]{
\node[state, accepting] (l1) at(#1,#2) {\small };\node[state]         (l2) [below of=l1] {\small };\node[left=.4cm of l1.north] (c1) {};
\path (l1) edge[bend left] node[right] {\parbox{1.3cm}{\small \\:=0\\:=0}} (l2)(l2) edge[bend left] (l1);\node[state, accepting] (l3) [right=4cm of l1] {\small };\node[state]         (l4) [below of=l3] {\small };\node[right=1.2cm of l3.north] (c2) {};
\path (l3) edge[bend left] node[right] (lhb) {\parbox{1.3cm}{\small \\:=0}} (l4)(l4) edge[bend left] node[right] {\small :=0} (l3);\node[draw,right=1.5cm of l2.south] (pa) {};\node[draw,left=1cm of l4.south] (pb) {};\node[draw, rectangle, inner sep=0, fit=(pa) (c1.north west)] {};\node[draw, rectangle, inner sep=0, fit=(pb) (c2.north east)] {};\draw[*-*] (pa.east) -- (pb.west);
\node[right=3cm of lhb] {\huge };
}

\newcommand{\exTA}[2]{
\node[state with output, initial left, inner sep=2.pt] (l1) at(#1,#2) {\tiny  \nodepart{lower} \tiny };\node[state] (l2) [below of=l1] {\tiny };\path (l1) edge[bend left] node[right, text width=1.cm, text centered] {\small \\} (l2)(l2) edge[bend left] node[left, text width=1.cm, text centered] {\small \\ } (l1);\node[draw,right=1.3cm of l1.north] (pd) {};\node[draw,left=1.3cm of l2.south] (pb) {};\node[draw, rectangle, inner sep=0, fit=(pd) (pb)] {};}

\newcommand{\exW}[2]{
\node[state, initial left] (l1#2) [left=#1 of lc0] {};\node[state] (l2#2) [below of=l1#2] {};\node[below=.7cm of l2#2] {\textit{Worker}};\path (l1#2) edge[bend left, \colora] node[right, text width=1.2cm, text centered] (txtw#2) {\small \\} (l2#2)(l2#2) edge[bend left, \colore] node[left, text width=1.2cm, text centered] (txtw2#2) {\small \\ } (l1#2);\node[draw, above=1.cm of txtw#2, xshift=.3cm, text=\colore] (actd#2) {};
\node[draw, below=1.cm of txtw#2, xshift=.3cm, text=\colora] (actb#2) {};

\node[draw, rectangle, inner sep=0, fit=(txtw2#2) (actd#2) (actb#2)] () {};
}

\newcommand{\exWHistRed}[2]{
\node[state, initial left] (l1#2) [left=#1 of lc0] {};\node[state] (l2#2) [below of=l1#2] {};\node[below=.9cm of l2#2] {\textit{Worker}};\path (l1#2) edge[bend left, \colora] node[right, text width=1.2cm, text centered] (txtw#2) {\small \\\\\alert{}} (l2#2)(l2#2) edge[bend left, \colore] node[left, text width=1.2cm, text centered] (txtw2#2) {\small \\ \\\alert{}} (l1#2);\node[draw, above=1.cm of txtw#2, xshift=.3cm, text=\colore] (actd#2) {};
\node[draw, below=1.cm of txtw#2, xshift=.3cm, text=\colora] (actb#2) {};

\node[draw, rectangle, inner sep=0, fit=(txtw2#2) (actd#2) (actb#2)] () {};
}

\newcommand{\exWH}[2]{
\node[state, initial left, onslide=<2>{highlightN}, onslide=<4>{highlightN}] (l1#2) [left=#1 of lc0] {};\node[state, onslide=<3>{highlightN}] (l2#2) [below of=l1#2] {};\node[below=.7cm of l2#2] {\textit{Worker}};\path (l1#2) edge[bend left, onslide=<3>{highlight}] node[right, text width=1.2cm, text centered] (txtw#2) {\small \\} (l2#2)(l2#2) edge[bend left, onslide=<4>{highlight}] node[left, text width=1.2cm, text centered] (txtw2#2) {\small \\ } (l1#2);\node[draw, above=1.cm of txtw#2, xshift=.3cm, onslide=<4>{highlightN}] (actd#2) {};
\node[draw, below=1.cm of txtw#2, xshift=.3cm, onslide=<3>{highlightN}] (actb#2) {};

\node[draw, rectangle, inner sep=0, fit=(txtw2#2) (actd#2) (actb#2)] () {};
}

\newcommand{\exWL}[1]{
\node[state, initial left, onslide=<3>{highlightN}] (l1) [left=#1 of lc0] {};\node[state] (l2) [below of=l1, onslide=<2>{highlightN}] {};\node[below=.7cm of l2] {\textit{Worker}};\path (l1) edge[bend left] node[right, text width=1.2cm, text centered] (txtwl) {\small \\} (l2)(l2) edge[bend left, onslide=<3>{highlight}] node[left, text width=1.2cm, text centered] (txtwl2) {\small \\ } (l1);

\node[draw, above=.9cm of txtwl, xshift=.3cm, onslide=<3>{highlight}] (actld1) {};
\node[draw, below=.9cm of txtwl, xshift=.3cm] (actlb1) {};

\node[draw, rectangle, inner sep=0, fit=(txtwl2) (actld1) (actlb1)] () {};
}

\newcommand{\exWR}[1]{
\node[state, initial left, onslide=<2-4>{highlightN}] (l1) [left=#1 of lc0] {};\node[state] (l2) [below of=l1] {};\node[below=.7cm of l2] {\textit{Worker}};\path (l1) edge[bend left, onslide=<4>{highlight}] node[right, text width=1.2cm, text centered] (txtwr) {\small \\} (l2)(l2) edge[bend left] node[left, text width=1.2cm, text centered] (txtwr2) {\small \\ } (l1);

\node[draw, above=.9cm of txtwr2, xshift=-.5cm] (actrd2) {};
\node[draw, below=.9cm of txtwr2, xshift=-.5cm, onslide=<4>{highlight}] (actrb2) {};

\node[draw, rectangle, inner sep=0, fit= (txtwr) (actrd2) (actrb2)] () {};
}

\newcommand{\exCHigh}[2]{
\node[state, initial below] (lc0) at(#1,#2) {};\node (dummyc) [left=.05cm of lc0] {};\node[state with output, inner sep=2.pt, onslide=<3-4>{highlightN}] (l1) [right of=lc0] {\small  \nodepart{lower}\tiny };\node[state, onslide=<2>{highlightN}] (l2) [below of=l1] {};\path (lc0) edge node[above] (txt1) {\small } node [below=.5cm of txt1] {} (l1)(l1) edge[bend left, onslide=<4>{highlight}] node[right, text width=1.cm, text centered] (txt2) {\small \\\\} (l2)(l2) edge[bend left, onslide=<3>{highlight}] node[left, text width=1.cm, text centered] (txt3) {\small \\ } (l1);\node[below=2cm of txt3] {\textit{Controller}};\node[draw, above=.75cm of txt2, xshift=.3cm, minimum height=.58cm, minimum width=.58cm, onslide=<3>{highlight}] (acte) {};\node[draw, below=.75cm of txt2, xshift=.3cm, minimum height=.58cm, minimum width=.58cm, onslide=<4>{highlight}] (acta) {};\node[draw, rectangle, inner sep=0, fit=(dummyc) (acta) (acte)] () {};
}


\newcommand{\exC}[2]{
\node[state, initial below] (lc0) at(#1,#2) {};\node (dummyc) [left=.05cm of lc0] {};\node[state with output, inner sep=2.pt] (l1) [right of=lc0] {\small  \nodepart{lower}\tiny };\node[state] (l2) [below of=l1] {};\path (lc0) edge node[above] (txt1) {\small } node [below=.5cm of txt1] {} (l1)(l1) edge[bend left, \colora] node[right, text width=1.cm, text centered] (txt2) {\small \\\\} (l2)(l2) edge[bend left, \colore] node[left, text width=1.cm, text centered] (txt3) {\small \\ } (l1);\node[below=2cm of txt3] {\textit{Controller}};\node[draw, above=.85cm of txt2, xshift=.3cm, minimum height=.58cm, minimum width=.58cm, text=\colore] (acte) {};\node[draw, below=.85cm of txt2, xshift=.3cm, minimum height=.58cm, minimum width=.58cm, text=\colora] (acta) {};\node[draw, rectangle, inner sep=0, fit=(dummyc) (acta) (acte)] () {};
}

\newcommand{\exCS}[2]{
\node[state, initial below, onslide=<2>{highlightN}] (lc0) at(#1,#2) {};\node (dummyc) [left=.05cm of lc0] {};\node[state with output, inner sep=2.pt, onslide=<3>{highlightN}, onslide=<5>{highlightN}] (l1) [right of=lc0] {\small  \nodepart{lower}\tiny };\node[state, onslide=<4>{highlightN}] (l2) [below of=l1] {};\path (lc0) edge[onslide=<3>{highlight}] node[above] (txt1) {\small } node [below=.5cm of txt1] {} (l1)(l1) edge[bend left, onslide=<4>{highlight}] node[right, text width=1.cm, text centered] (txt2) {\small \\\\} (l2)(l2) edge[bend left, onslide=<5>{highlight}] node[left, text width=1.cm, text centered] (txt3) {\small \\ } (l1);\node[below=2cm of txt3] {\textit{Controller}};\node[draw, above=.75cm of txt2, xshift=.3cm, minimum height=.58cm, minimum width=.58cm] (acte) {};\node[draw, below=.75cm of txt2, xshift=.3cm, minimum height=.58cm, minimum width=.58cm] (acta) {};\node[draw, rectangle, inner sep=0, fit=(dummyc) (acta) (acte)] () {};
}

\newcommand{\exCWW}[2]{
\exCHigh{#1}{#2}
\exWL{2}{1}
\exWR{-8}{2}
\draw[*-*] (actlb1.south) |- ++(0,-.3) -| (acta.south west) -- ++(0,0.1);
\draw[*-*, onslide=<4>{highlight}] (acta.south east) |- ++(0,-.3) -| (actrb2.south) -- ++(0,.05);
\draw[*-*, onslide=<3>{highlight}] (actld1.north) |- ++(0,.3) -| (acte.north west) -- ++(0,-0.1);
\draw[*-*] (acte.north east) |- ++(0,.3) -| (actrd2.north) -- ++(0,-.05);
}

\newcommand{\exCH}[2]{
\node[state, initial below] (lc0) at(#1,#2) {};\node (dummyc) [left=.05cm of lc0] {};\node[state with output, inner sep=2.pt, onslide=<2>{highlightN},onslide=<4>{highlightN}] (l1) [right of=lc0] {\small  \nodepart{lower}\tiny };\node[state,onslide=<3>{highlightN}] (l2) [below of=l1] {};\path (lc0) edge node[above] (txt1) {\small } node [below=.5cm of txt1] {} (l1)(l1) edge[bend left,onslide=<3>{highlight}] node[right, text width=1.cm, text centered] (txt2) {\small \\\\} (l2)(l2) edge[bend left,onslide=<4>{highlight}] node[left, text width=1.cm, text centered] (txt3) {\small \\ } (l1);\node[below=2cm of txt3] {\textit{Controller}};\node[draw, above=.85cm of txt2, xshift=.3cm, minimum height=.58cm, minimum width=.58cm,onslide=<4>{highlightN}] (acte) {};\node[draw, below=.85cm of txt2, xshift=.3cm, minimum height=.58cm, minimum width=.58cm,onslide=<3>{highlightN}] (acta) {};\node[draw, rectangle, inner sep=0, fit=(dummyc) (acta) (acte)] () {};
}

\newcommand{\exCHistR}[2]{
\node[state, initial below] (lc0) at(#1,#2) {};\node (dummyc) [left=.05cm of lc0] {};\node[state with output, inner sep=2.pt] (l1) [right of=lc0] {\small  \nodepart{lower}\tiny };\node[state] (l2) [below of=l1] {};\path (lc0) edge node[above] (txt1) {\small } node [below=.5cm of txt1] {} (l1)(l1) edge[bend left, \colora] node[right, text width=1.1cm, text centered] (txt2) {\small \\\\\\ \alert{}} (l2)(l2) edge[bend left, \colore] node[left, text width=1.1cm, text centered] (txt3) {\small \\ \\ \alert{}} (l1);\node[below=2cm of txt3] {\textit{Controller}};\node[draw, above=.85cm of txt2, xshift=.3cm, minimum height=.58cm, minimum width=.58cm, text=\colore] (acte) {};\node[draw, below=.85cm of txt2, xshift=.3cm, minimum height=.58cm, minimum width=.58cm, text=\colora] (acta) {};\node[draw, rectangle, inner sep=0, fit=(dummyc) (acta) (acte)] () {};
}

\newcommand{\exCHistRMirror}[2]{
\node[state, initial below] (lc0) at(#1,#2) {};\node (dummyc) [left=.05cm of lc0] {};\node[state with output, inner sep=2.pt] (l1) [right of=lc0] {\small  \nodepart{lower}\tiny };\node[state] (l2) [below of=l1] {};\path (lc0) edge node[above] (txt1) {\small } node [below=.5cm of txt1] {} (l1)(l1) edge[bend left, \colora] node[right, text width=1.1cm, text centered] (txt2) {\small \\\\\\ \alert{}} (l2)(l2) edge[bend left, \colore] node[left, text width=1.1cm, text centered] (txt3) {\small \\ \\ \alert{}} (l1);\node[below=2cm of txt3] {\textit{Controller}};\node[draw, above=.85cm of txt2, xshift=.3cm, minimum height=.58cm, minimum width=.58cm, text=\colore] (acte) {};\node[draw, below=.85cm of txt2, xshift=.3cm, minimum height=.58cm, minimum width=.58cm, text=\colora] (acta) {};\node[draw, rectangle, inner sep=0, fit=(dummyc) (acta) (acte)] () {};
}

\newcommand{\exCHistMirror}[2]{
\node[state, initial below] (lc0) at(#1,#2) {};\node (dummyc) [left=.05cm of lc0] {};\node[state with output, inner sep=1.5pt] (l1) [right of=lc0] {\tiny  \nodepart{lower}\tiny };\node[state] (l2) [below of=l1] {};\path (lc0) edge node[above] (txt1) {\small } node [below=.5cm of txt1] {} (l1)(l1) edge[bend left, \colora] node[right, text width=1.1cm, text centered] (txt2) {\small \\\\\\ \alert{}} (l2)(l2) edge[bend left, \colore] node[left, text width=1.1cm, text centered] (txt3) {\small \\ \\ \alert{}} (l1);\node[below=2cm of txt3] {\textit{Controller}};\node[draw, above=.8cm of txt2, xshift=.3cm, minimum height=.58cm, minimum width=.58cm, text=\colore] (acte) {};\node[draw, below=.8cm of txt2, xshift=.3cm, minimum height=.58cm, minimum width=.58cm, text=\colora] (acta) {};\node[draw, rectangle, inner sep=0, fit=(dummyc) (acta) (acte)] () {};
}

\newcommand{\exCWH}[2]{
\exCH{#1}{#2}
\exWH{2}{1}
\draw[*-*, onslide=<3>{highlight}] (actb1.south) |- ++(0,-.3) -| (acta.south) -- ++(0,0.1);
\draw[*-*, onslide=<4>{highlight}] (actd1.north) |- ++(0,.3) -| (acte.north) -- ++(0,-0.1);
}

\newcommand{\exCW}[2]{
\exC{#1}{#2}
\exW{2}{1}
\draw[*-*,\colora] (actb1.south) |- ++(0,-.3) -| (acta.south) -- ++(0,0.1);
\draw[*-*,\colore] (actd1.north) |- ++(0,.3) -| (acte.north) -- ++(0,-0.1);
}

\newcommand{\exCWHistR}[2]{
\exCHistR{#1}{#2}
\exWHistRed{2}{1}
\draw[*-*,\colora] (actb1.south) |- ++(0,-.3) -| (acta.south) -- ++(0,0.1);
\draw[*-*,\colore] (actd1.north) |- ++(0,.3) -| (acte.north) -- ++(0,-0.1);
}

\newcommand{\exCWHistRMirror}[2]{
\exCHistRMirror{#1}{#2}
\exWHistRed{2}{1}
\exWHistRed{-8}{2}
\draw[*-*,\colora, onslide=<2>{highlight}] (actb1.south) |- ++(0,-.3) -| (acta.south west) -- ++(0,0.1);
\draw[*-*,\colore, onslide=<3>{highlight}] (actd1.north) |- ++(0,.3) -| (acte.north west) -- ++(0,-0.1);
\draw[*-*,\colore, onslide=<3>{highlight}] (acte.north east) |- ++(0,.3) -| (actd2.north) -- ++(0,-.05);
}

\newcommand{\exCWHistMirror}[2]{
\exCHistMirror{#1}{#2}
\exWHistRed{2}{1}
\exWHistRed{-8}{2}
\draw[*-*,\colora] (actb1.south) |- ++(0,-.3) -| (acta.south) -- ++(0,0.1);
\draw[*-*,\colore] (actd1.north) |- ++(0,.3) -| (acte.north west) -- ++(0,-0.1);
\draw[*-*,\colore] (acte.north east) |- ++(0,.3) -| (actd2.north) -- ++(0,-.05);
}

\newcommand{\exCWHistMirrorC}[2]{
\exCHistMirror{#1}{#2}
\exWHistRed{2}{1}
\exWHistRed{-8}{2}
\draw[*-*,blue] (actb1.south) |- ++(0,-.3) -| (acta.south west) -- ++(0,0.1);
\draw[*-*,blue] (acta.south east) |- ++(0,-.3) -| (actb2.south) -- ++(0,.05);
\draw[*-*,green] (actd1.north) |- ++(0,.3) -| (acte.north west) -- ++(0,-0.1);
\draw[*-*,green] (acte.north east) |- ++(0,.3) -| (actd2.north) -- ++(0,-.05);
}

\newcommand{\picTask}{
\begin{tikzpicture}[scale=.9]


       \draw[->] (0,0) -- (8.,0) node [right] {};

    \foreach \pos/\label in {0,2/,4/,6/}
        \draw (\pos,0.1) -- (\pos,-0.1) (\pos cm,-3ex) node
            [anchor=base,fill=white,inner sep=1pt]  {\label};

\foreach \pos/\dist/\height in {1/3/0.,2.7/2/0,4.8/3.5/0,6.9/2/0}
    {
      \node[rectangle, draw, pattern=north east lines, pattern color=blue,anchor=base, xshift=.05cm, minimum size=1cm,minimum height=.3cm, label={below=-2.cm:\parbox{1cm}{\\}}] at (\pos,\height) {};
}
\end{tikzpicture}
}

\newcommand{\cag}[2]{
\node[state, accepting, initial text={}] (lp0) at(#1,#2) {};\node[state, right of=lp0] (lp1) {};\path[->](lp0) edge node[above] (txt1) {\small } node [below=.1cm of txt1] (txt2) {} (lp1);\node[draw,right=.5cm of lp1.north] (la) {};\node[left=3cm of la] (dla) {};\node[draw, rectangle, inner sep=0, fit=(lp0.west) (lp1) (la) (txt2.south) (dla)] {};}

\newcommand{\caiv}[2]{
\node[state, accepting, initial text={}] (lp0) at(#1,#2) {};\node[state, right of=lp0] (lp1) {};\path[->](lp0) edge node[above] (txt1cai) {\small } node [below=.1cm of txt1cai] (txt2) {} (lp1);\node[draw,right=.5cm of lp1.north] (lai) {};\node[left=3cm of lai] (dlai) {};\node[draw, rectangle, inner sep=0, fit=(lp0.west) (lp1) (lai) (txt2.south) (dlai)] {};}

\newcommand{\cai}[2]{
\node[state, accepting, initial text={}] (lp0) at(#1,#2) {};\node[state, right of=lp0] (lp1) {};\path[->](lp0) edge node[above] (txt1cai) {\small } node [below=.1cm of txt1cai] (txt2) {} (lp1);\node[draw,right=.5cm of lp1.north] (lai) {};\node[left=3cm of lai] (dlai) {};\node[draw, rectangle, inner sep=0, fit=(lp0.west) (lp1) (lai) (txt2.south) (dlai)] {};}

\newcommand{\cao}[4]{
\tikzset{draw opacity=#4*#4}
\node[state, accepting, initial text={},opacity=#4*#4] (lp0#1) at(#2,#3) {};\node[left=1.cm of lp0#1.west] (dummy#1) {};
\node[state, right of=lp0#1, opacity=#4*#4] (lp1#1) {};\path[->](lp0#1) edge[opacity=#4*#4] node[above] (txt1#1) {\small } node [below=.1cm of txt1#1] (txt2#1) {} (lp1#1);\node[draw,right=.5cm of lp1#1.north,opacity=#4*#4] (la#1) {};\node[left=3cm of la#1,opacity=#4*#4] (dla#1) {};\node[draw, rectangle, opacity=#4*#4, inner sep=0, fit=(dummy#1.west) (lp1#1) (la#1) (txt2#1.south) (dla#1)] {};\node[left=.5cm of dummy#1] (caon#1) {};}

\newcommand{\caov}[4]{
\tikzset{draw opacity=#4*#4}
\node[state, accepting, initial text={},opacity=#4*#4] (lp0#1) at(#2,#3) {};\node[state, right of=lp0#1, opacity=#4*#4] (lp1#1) {};\path[->](lp0#1) edge[opacity=#4*#4] node[above] (txt1#1) {\small } node [below=.1cm of txt1#1] (txt2#1) {} (lp1#1);\node[draw,right=.5cm of lp1#1.north,opacity=#4*#4] (la#1) {};\node[left=3cm of la#1,opacity=#4*#4] (dla#1) {};\node[draw, rectangle, ,opacity=#4*#4, inner sep=0, fit=(lp0#1.west) (lp1#1) (la#1) (txt2#1.south) (dla#1)] {};\node[left=.5cm of lp0#1] (caon#1) {};}

\newcommand{\caohv}[4]{
\tikzset{draw opacity=#4*#4}
\node[state, accepting, initial text={},opacity=#4*#4] (lp0#1) at(#2,#3) {};\node[state, right of=lp0#1, opacity=#4*#4] (lp1#1) {};\path[->](lp0#1) edge[opacity=#4*#4] node[above] (txt1#1) {\small } node [below=.1cm of txt1#1] (txt2#1) {} (lp1#1);\node[draw,right=.5cm of lp1#1.north,opacity=#4*#4] (la#1) {};\node[left=3cm of la#1,opacity=#4*#4] (dla#1) {};\node[draw, rectangle, ,opacity=#4*#4, inner sep=0, fit=(lp0#1.west) (lp1#1) (la#1) (txt2#1.south) (dla#1)] {};\node[left=.5cm of lp0#1] (caon#1) {};}

\newcommand{\caoh}[4]{
\tikzset{draw opacity=#4*#4}
\node[state, accepting, initial text={},opacity=#4*#4] (lp0#1) at(#2,#3) {};\node[left=.15cm of lp0#1.north west] (lp00#1) {};
\node[state, right of=lp0#1, opacity=#4*#4] (lp1#1) {};\path[->](lp0#1) edge[opacity=#4*#4] node[above] (txt1#1) {\small } node [below=.1cm of txt1#1] (txt2#1) {} (lp1#1);\node[draw,right=.5cm of lp1#1.north,opacity=#4*#4] (la#1) {};\node[left=3cm of la#1,opacity=#4*#4] (dla#1) {};\node[draw, rectangle, ,opacity=#4*#4, inner sep=0, fit=(lp00#1.west) (lp1#1) (la#1) (txt2#1.south) (dla#1)] {};\node[left=.5cm of lp0#1] (caon#1) {};}

\newcommand{\ccx}[2]{
\node[state, accepting, initial text={}] at(#1,#2) (lc0) {};\node[state, right of=lc0] (lc1) {};\path[->](lc0) edge node[above] (txt1) {\small } node [below=.1cm of txt1] (txt2) {} (lc1);\node[draw,left=.5cm of lc0.south] (lac) {};\node[right=3cm of lac] (dlac) {};\node[draw, rectangle, inner sep=0, fit=(lc0) (lc1.east) (lac) (txt2.south) (dlac)] {};\node[below=.6cm of txt1] (ccn) {};}

\newcommand{\ccxh}[2]{
\node[state, accepting, initial text={}] at(#1,#2) (lc0) {};\node[state, right of=lc0] (lc1) {};\node[above=.15cm of lc1.north east,xshift=.1cm] (lc11) {};
\path[->](lc0) edge node[above] (txt1) {\small } node [below=.1cm of txt1] (txt2) {} (lc1);\node[draw,left=.5cm of lc0.south] (lac) {};\node[right=3cm of lac] (dlac) {};\node[draw, rectangle, inner sep=0, fit=(lc0) (lc11.east) (lac) (txt2.south) (dlac)] {};\node[below=.8cm of txt1] (ccn) {};}

\newcommand{\ccca}[2]{
\ca{#1}{#2}
\ccx
}

\newcommand{\fischerVGen}[2]{\node[state, accepting]  (CV) at (#1,#2) {\small };
  \node[below of= CV] (aux) {};
  \node[state, below=2.5cm of CV] (AVI) {\small };
  \node[state, left=2.4cm of aux] (AV) {\small };
  \node[state, right=2.4cm of aux] (BV) {\small };
  \node[right=.3cm of AV] (x) {}; 
  \node[below=1.8cm of x] (IdV) {Id Variable};
  \path 
        (AV) edge[loop left]              node[below=.3cm, xshift=.4cm]{\parbox{1cm}{}} (AV)
        (BV) edge[loop right]              node[below=.3cm, xshift=-.4cm]{{}} (BV)
        (CV) edge[loop left]              node[above=.2cm, xshift=.1cm]{{}} (CV)
(CV) edge              node[left,yshift=.25cm]{} (AV)
        (CV) edge              node{{}} (BV)
        (CV) edge              node{{}} (AVI)
(AV) edge[in=0,out=3,bend left]  node[above]{{}} (AVI)
        (AVI) edge[in=0,out=3,bend left]  node[above]{{}} (AV)
(BV) edge[in=0,out=3,bend left]  node[above]{{}} (AVI)
        (AVI) edge[in=0,out=3,bend left]  node[above]{{}} (BV);
\node[draw, above=.25cm of CV.north] (eqi) {};
  \node[draw, right=3.1cm of eqi] (eq0) {};
  \node[left=1.cm of eqi] (dots1) {};
  \node[right=3.cm of dots1] (dots2) {};
  \node[draw, left=3.1cm of eqi] (eqn) {};
  \node[draw, below=4.8cm of eqi] (set1) {}; 
  \node[right=1.cm of set1] (dots3) {};
  \node[draw, right=2.9cm of set1] (setn) {};
\node[draw, rectangle, inner sep=0, fit=(set1) (setn) (eq0) (eqi) (eqn) (AV) (CV) (BV)] {};
}

\newcommand{\figregexp}[2]{\node[state, accepting] (l0) at (#1,#2) {\small };
\node[state, right of=l0] (l1) {\small };
\path 
     (l0) edge[loop above] node[above] (a) {} (l0)
     (l0) edge[bend left] node[above]{} (l1)
     (l1) edge[bend left] node[above] (b) {} (l0)
     (l1) edge[loop above] node[above] (c) {} (l1);
\node[draw, below=.65cm of l0.south west] (la) {};
\node[draw, below=.5cm of b] (lb) {};
\node[draw, right=2.45cm of la] (lc) {};
\node[draw, rectangle, inner sep=0, fit=(l0) (la) (a) (c) (l1) (lc)] {};
}

\newcommand{\figregexph}[2]{\node[state, accepting] (l0) at (#1,#2) {\small };
\node[state, right of=l0] (l1) {\small };
\path 
     (l0) edge[loop above] node[above] (a) {} (l0)
     (l0) edge[bend left] node[above]{} (l1)
(l1) edge[bend left] node[below] (b) {} (l0)
     (l1) edge[loop above] node[above] (c) {} (l1);
\node[draw, below=.65cm of l0.south west, xshift=-.3cm] (la) {};
\node[draw, below=-.09cm of b] (lb) {};
\node[draw, right=3.05cm of la] (lc) {};
\node[draw, rectangle, inner sep=0, fit=(l0) (la) (a) (c) (l1) (lc)] {};
}

\newcommand{\expts}{
  \ccx{9.8}{0};
  \node at(7.5,.3) {\reflectbox{}};
  \foreach \o [count=\oi from 1] in {4.5, 3, 1.5} {\cao{\oi}{1.5+\o}{1.0-\o}{\o/3};
    \draw[*-*,opacity=\o*4] (la\oi.east) -- (lac.west);
  }
}

\newcommand{\exptsslides}{
  \ccx{11}{0};
  \node at(8.,.8) {\reflectbox{}};
  \foreach \o [count=\oi from 1] in {4.5, 3, 1.5} {\cao{\oi}{.8+\o}{1.9-\o}{\o/3};
    \draw[*-*,opacity=\o*4] (la\oi.east) -- (lac.west);
  }
}

\newcommand{\exptsHslides}{
  \ccxh{14}{0};
  \node at(10.,.9) {\reflectbox{}};
  \foreach \o [count=\oi from 1] in {4.5, 3, 1.5} {\caoh{\oi}{.8+\o}{1.9-\o}{\o/3};
    \draw[*-*,opacity=\o*4] (la\oi.east) -- node[midway,red,fill=white,draw=white,rectangle]{} (lac.west);
  }
}

\newcommand{\expg}{
\cag{4}{0};
\cai{4}{-1.5};
}

\newcommand{\expgslides}{
\cag{4}{0};
\cai{10}{0};
}



\newcommand{\tokenringISv}[3]{\node[state] (l1#3) at (#1, #2) {\small };
  \node[left=.1cm of l1#3] (auxt) {}; 
  \node[state, accepting] (l2#3) [right=1.45cm of l1#3] {\small }; 
  \node[right=.8cm of l1#3] (x) {};
  \node[state] (l3#3) [below=1.45cm of x.west] {\small };
  \node[below=.1cm of l3#3] (P#3) {};
  \path 
  (l1#3) edge node[above]{} node[below=0cm of x.south]{\parbox{1.5cm}{{\centering \small ,\\ }}} (l2#3)
  (l2#3) edge                         (l3#3)
  (l3#3) edge              node{} (l1#3);
\node[draw, left=.5cm of l1#3.north] (lr#3) {};
  \node[draw,right=.5cm of l2#3.north] (ls#3) {}; 
\node[draw, rectangle, inner sep=0, fit=(lr#3) (ls#3) (l1#3) (l2#3) (l3#3)] {};
}

\newcommand{\tokenringIS}[3]{\node[state] (l1#3) at (#1, #2) {\small };
  \node[left=.1cm of l1#3] (auxt) {}; 
  \node[state, accepting] (l2#3) [right=1.45cm of l1#3] {\small }; 
  \node[right=.8cm of l1#3] (x) {};
  \node[state] (l3#3) [below=1.45cm of x.west] {\small };
  \node[below=.05cm of l3#3] (l3s#3) {};
  \node[below=.3cm of l3#3] (P#3) {};
  \path 
  (l1#3) edge node[above]{} node[below=0cm of x.south]{\parbox{1.5cm}{{\centering \small ,\\ }}} (l2#3)
  (l2#3) edge                     node{}  (l3#3)
  (l3#3) edge              node{} (l1#3);
\node[draw, left=.5cm of l1#3.north] (lr#3) {};
  \node[draw,right=.5cm of l2#3.north] (ls#3) {}; 
\node[draw, rectangle, inner sep=0, fit=(lr#3) (ls#3) (l1#3) (l2#3) (l3s#3)] {};
}



\newcommand{\tokenringIRv}[3]{\node[state, accepting] (l1#3) at (#1, #2) {\small };
  \node[left=.1cm of l1#3] (auxt) {}; 
  \node[state] (l2#3) [right=1.45cm of l1#3] {\small }; 
  \node[right=.8cm of l1#3] (x) {};
  \node[state] (l3#3) [below=1.45cm of x.west] {\small };
  \node[below=.1cm of l3#3] (P#3) {};
  \path 
  (l1#3) edge node[above]{} node[below=0cm of x.south]{\parbox{1.5cm}{{\centering \small ,\\ }}} (l2#3)
  (l2#3) edge                       node{} (l3#3)
  (l3#3) edge              node{} (l1#3);
\node[draw, left=.5cm of l1#3.north] (lr#3) {};
  \node[draw,right=.5cm of l2#3.north] (ls#3) {}; 
\node[draw, rectangle, inner sep=0, fit=(lr#3) (ls#3) (l1#3) (l2#3) (l3#3)] {};
}

\newcommand{\tokenringIR}[3]{\node[state, accepting] (l1#3) at (#1, #2) {\small };
  \node[left=.1cm of l1#3] (auxt) {}; 
  \node[state] (l2#3) [right=1.45cm of l1#3] {\small }; 
  \node[right=.8cm of l1#3] (x) {};
  \node[state] (l3#3) [below=1.45cm of x.west] {\small };
  \node[below=.05cm of l3#3] (l3r#3) {};
  \node[below=.4cm of l3#3] (P#3) {};
  \path 
  (l1#3) edge node[above]{} node[below=0cm of x.south]{\parbox{1.5cm}{{\centering \small ,\\ }}} (l2#3)
  (l2#3) edge                     node{}  (l3#3)
  (l3#3) edge              node{} (l1#3);
\node[draw, left=.5cm of l1#3.north] (lr#3) {};
  \node[draw,right=.5cm of l2#3.north] (ls#3) {}; 
\node[draw, rectangle, inner sep=0, fit=(lr#3) (ls#3) (l1#3) (l2#3) (l3r#3)] {};
}

\newcommand{\toycexW}[2]{
\node[state, accepting, initial text={}] (lp0) at(#1,#2) {};\node[state, below of=lp0] (lp1) {};\path[->](lp0) edge[bend left] node[right] (txt1) {\small } node [below=.1cm of txt1] (txt2) {} (lp1)(lp0) edge[bend right] node[left] {\small } (lp1);\node[draw,right=.7cm of lp0.north] (la1) {};\node[draw,right=.7cm of lp1.south] (la2) {};\node[left=.7cm of lp0] (dla) {};\node[draw, rectangle, inner sep=0, fit=(lp0.west) (lp1) (la1) (la2) (txt2) (dla)] {};}

\newcommand{\toycexC}[2]{
\node[state, accepting, initial text={}] (lc0) at(#1,#2) {};\node[state, below of=lc0] (lc1) {};\path[->](lc0) edge[bend left] node[right] (txtc1) {\small } node [below=.1cm of txtc1] (txtc2) {} (lc1)(lc0) edge[bend right] node[left] {\small } (lc1);\node[draw,left=.7cm of lc0.north] (lac1) {};\node[draw,left=.7cm of lc1.south] (lac2) {};\node[right=.7cm of lc0] (dlac) {};\node[draw, rectangle, inner sep=0, fit=(lc0.west) (lc1) (lac1) (lac2) (txtc2.south) (dlac)] {};}


\newcommand{\toycex}{
\toycexW{0}{0}
\toycexC{4}{0}
\draw[*-*] (la1.east) -- (lac1.west);
\draw[*-*] (la2.east) -- (lac2.west);
}

 
\theoremstyle{plain}\newtheorem{remark}[thm]{Remark}
\theoremstyle{plain}\newtheorem{example}[thm]{Example}


\begin{document}

\title[Compositional Verification for Timed Systems]
{Compositional Verification for Timed Systems\\ based on Automatic Invariant Generation\rsuper*}

\author[S.~Ben Rayana]{Souha Ben Rayana\rsuper a}
\address{{\lsuper{a--d}}Univ. Grenoble Alpes, VERIMAG, F-38000 Grenoble}
\email{\{Souha.BenRayana,lastefan,Saddek.Bensalem\}@imag.fr}

\author[L.~A\c stef\u anoaei]{L\u acr\u amioara ~A\c stef\u
  anoaei\rsuper b}
\address{\vspace{-18 pt}}


\author[S.~Bensalem]{Saddek Bensalem\rsuper c}
\address{\vspace{-18 pt}}


\author[M.~Bozga]{Marius Bozga\rsuper d}
\address{{\lsuper{c,d}}CNRS, VERIMAG, F-38000 Grenoble, France}
\email{\{Marius.Bozga,Jacques.Combaz\}@imag.fr}

\author[J.~Combaz]{Jacques Combaz}
\address{\vspace{-18 pt}}


\keywords{compositional verification, timed automata, invariants, component
  invariants, interaction invariants, interactions}

\titlecomment{{\lsuper*}Research supported by the European Integrated Project 257414
  ASCENS and ICT Collaborative Project 288175 CERTAINTY}

\begin{abstract}
  We propose a method for compositional verification to address the
  state space explosion problem inherent to model-checking timed
  systems with a large number of components. The main challenge is to
  obtain pertinent global timing constraints from the timings in the
  components alone. To this end, we make use of auxiliary clocks to
  automatically generate new invariants which capture the constraints
  induced by the synchronisations between components. The method has
  been implemented in the RTD-Finder tool and  successfully experimented on several benchmarks.
\end{abstract}

\maketitle

\section{Introduction}
\label{sec:intro}

Compositional methods in verification have been developed to cope with
state space explosion. Generally based on divide et impera principles,
these methods attempt to break monolithic verification problems into
smaller sub-problems by exploiting either the structure of the system
or the property or both. Compositional reasoning can be used in
different manners e.g., for deductive verification, assume-guarantee,
contract-based verification, compositional generation, etc.

The development of compositional verification for timed systems
remains however challenging. State-of-the-art tools
\cite{uppaal,kronos,red06,Romeo2005} for the verification of such
systems are mostly based on symbolic state space exploration, using
efficient data structures and particularly involved exploration
techniques.  In the timed context, the use of compositional reasoning
is inherently difficult due to the synchronous model of time. Time
progress is an action that synchronises continuously all the
components of the system. Getting rid of the time synchronisation is
necessary for analysing independently different parts of the system
(or of the property) but becomes problematic when attempting to
re-compose the partial verification results.  Nonetheless,
compositional verification is actively investigated and several
approaches have been recently developed and employed in timed
interfaces \cite{Alfaro02} and contract-based assume-guarantee
reasoning \cite{Ecdar,AutomaticCompERAs}.

In this paper, we propose a different approach for exploiting
compositionality for analysis of timed systems. The driving principle
is to use invariants as approximations to exact reachability analysis,
the default technique in model-checking.  We show that rather
precise invariants can be computed compositionally, from the separate
analysis of the components in the system and from their composition
glue. This method is proved to be sound for the verification of safety
state properties. However, it is not complete.

The starting point is the verification method of~\cite{dfinder},
summarised in Figure~\ref{fig:VR}. The method exploits
compositionality as explained next. Consider a system consisting of
components  interacting by means of a set  of
multi-party interactions, and let  be a system property of
interest. Assume that all  as well as the composition through
 can be independently characterised by means of component
invariants , respectively interaction invariant
. The connection between the invariants and the system
property  can be intuitively understood as follows: if 
can be proved to be a logical consequence of the conjunction of
components and interaction invariants, then  holds for the
system.

\begin{figure}[htp]
\begin{center}
\begin{tabular}{c}
  \inference{\vdash \big(\bigwedge_i \ic(\cn_i)\big) \wedge \iim(\gamma) \rightarrow \varphi}{ \|_{\gamma}\cn_i \models \Box\, \varphi } [\vr]
\end{tabular}
\caption{Compositional verification}\label{fig:VR}
\end{center}
\end{figure}

In the rule \; the symbol ``  '' is used to underline
that the logical implication can be effectively proved (for instance
with an SMT solver) and the notation ``'' is to
be read as `` holds in every reachable state of ''.

The verification rule (VR) in \cite{dfinder} has been developed for untimed
systems.  Its direct application to timed systems may be weak as
interaction invariants do not capture global timings of interactions
between components. The key contribution of this paper is to improve the
invariant generation method so to better track such global timings by means
of auxiliary \textit{history clocks} for actions and interactions.  At
component level, history clocks expose the local timing constraints
relevant to the interactions of the participating components. At
composition level, extra constraints on history clocks are enforced due to
the simultaneity of interactions and to the synchrony of time progress.

As an illustration, let us consider as running example the timed
system in Figure~\ref{fig:ncw} which depicts a ``controller''
component serving  ``worker'' components, one at a time. The
interactions between the controller and the workers are defined by the
set of synchronisations .  Periodically, after every 4 units of time, the controller
synchronises its action  with the action  of any worker 
whose clock shows at least  units of time.  Initially, such a
worker exists because the controller waits for  units of time
before interacting with workers.  The cycle repeats forever because
there is always a worker ``willing'' to do , that is, the system is
deadlock-free.  Proving deadlock-freedom of the system requires to
establish that when the controller is at location  there is at
least one worker such that .  Unfortunately, this
property cannot be shown if we use (VR) as it is in~\cite{dfinder}.
Intuitively, this is because the proposed invariants are too weak to
infer cross constraints relating the clocks of the controller and
those of the workers: interaction invariants  relates
only locations of components and thus at most eliminates unreachable
configurations like , while the component
invariants can only state local conditions on clocks such as  at .  Using history clocks allows to recover additional
constraints. For example, after the controller returns from  to
 for the first time, whenever it reaches  again, there
exists a worker  whose clock has an equal value as that of the
controller. Similarly, history clocks allow to infer that different
 interactions are separated by at least 4 time units.
These constraints altogether are sufficient to prove the deadlock
freedom property.

\begin{figure}[htp]
\begin{center}
\resizebox{9.cm}{!}{
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.cm,semithick,font=\small]
\tikzstyle{every state}=[fill=white,text=black, inner sep=0]\cTikz{0}{0}
\foreach \o [count=\oi from 1] in {1, 0.35, 0.1} {\wTikzO{\oi}{4.5+\o}{.06-\o}{\o};
  \draw[*-*,opacity=\o] (a.east) -- (b\oi.west);
  \draw[*-*,opacity=\o] (c.east) -- (d\oi.west);
}
\end{tikzpicture}
}



 \end{center}
\caption{A timed system}
\label{fig:ncw}
\end{figure}

\subsection*{Organisation of the paper}  
This paper is essentially an extended version of the conference paper
\cite{abbbc14}. The extension is threefold with respect to (1)
incorporating proofs, (2) detailing technicalities about handling
initial states, and (3) formalising three heuristics to speed up and
simplify invariant generation. Section~\ref{sec:frtbip} recalls the
needed definitions for modelling timed systems and their
properties. Section~\ref{s:bm} presents our method for compositional
generation of invariants. Section~\ref{sec:heuristics} describes the
heuristics while Section~\ref{sec:impl} shows their use in the case
studies we experimented with in our
implementation. Section~\ref{sec:conc} concludes.



\section{Timed Systems and Properties}
\label{sec:frtbip}
In the framework of the present paper, components are timed automata and
systems are compositions of timed automata with respect to multi-party
interactions. The timed automata we use are essentially the ones from
\cite{alur94}, however, slightly adapted to embrace a uniform notation
throughout the paper.

\begin{defi}[Syntax]
  A component is a timed automaton  where
   is a finite set of locations,  a finite set of actions, 
  is a finite set of local\footnote{Locality is essential for avoiding
    side effects which would break compositionality and local
    analysis.}  clocks,  is a set of edges labelled with an action, a guard,
  and a set of clocks to be reset, 
  assigns a time progress condition\footnote{To avoid confusion with
    invariant properties, we prefer to adopt the terminology of ``time
    progress condition'' from \cite{bornot98} instead of ``location
    invariants''.} to each location.   is the set of clock
  constraints and  provides the initial
  configuration. A clock constraint is defined by the grammar:
   with ,  and
  .  Time progress conditions are restricted to
  conjunctions of constraints as .
\end{defi}

Before recalling the semantics of a component, we first fix some notation.
Let  be the set of all clock valuation functions .  For a clock constraint , 
denotes the evaluation of  in . The notation 
represents a new  defined as  while  represents a new  which assigns any 
in  to 0 and otherwise preserves the values from .

\begin{defi}[Semantics]The semantics of a component  is given by
  the labelled transition system  where  denotes the states of ,
   denotes the transitions according to the rules:
    \begin{itemize}
    \item  if  (time progress);
    \item  if ,  (action step).
    \end{itemize}
    and  denotes the initial states. 
\end{defi}

Because the semantics defined above is in general infinite, we work with
the so called zone graph \cite{henzinger94} as a finite symbolic
representation. The symbolic states in a zone graph are pairs 
where  is a location of  and  is a \textit{zone}, a set of
clock valuations defined by clock constraints.  The initial configuration
 corresponds trivially to a symbolic state .
Given a symbolic state , its successor with respect to a
transition  of  is denoted as  and defined by
means of its timed and its discrete successor:
\begin{itemize}
\item 
\item  if 
\item 
\end{itemize}
where  are usual operations on zones:  is the forward diagonal projection of , i.e., it
contains any valuation  for which there exists a real
 such that  is in ;  is
the set of all valuations in  after applying the resets in ;
 corresponds to normalising  such that all
bounds on clocks and clock differences are either bounded by some
finite value or infinite. Since our use of invariants is only as
over-approximations of the reachable states, a more thorough
discussion on normalisation is not relevant for the present paper. The
interested reader may refer to \cite{bengtssonY03,bouyer04} for more
precise definitions.

A symbolic execution of  is a sequence of
symbolic states \footnote{We tacitly assume that
   is such that .  If this is not the case, one can
  always consider  instead of  for the definition of symbolic
  executions and reachable states.} such that for any , there exists
a transition  for which  is . The set of
reachable symbolic states of  is 
where  is defined recursively as:

for an arbitrary  and  the set of transitions in .  We remind
that the set  can be shown finite knowing that the number
of normalised zones is finite.  In general, the symbolic zone graph
provides an over-approximation of the set of reachable states.  This
over-approximation is exact only for timed automata without diagonal
constraints \cite{bengtssonY03, bouyer04}.

In our framework, components communicate by means of
\emph{interactions}, which are synchronisations between actions.
Given  components , with disjoint sets of actions
, an interaction is a subset 
containing at most one action per component.  We denote interactions
 as sets , with  for all . For readability, in examples, we
use the alternative notation 
instead. Given a set of interactions , we denote by
 the set of actions involved in , that is,
.

\begin{defi}[Timed System] 
For a given  and  let  = ,
, , , ,  be  components with
disjoint sets of actions and initial states .  Let  be a set of interactions constructed from
.  The \emph{timed system}  is defined as
the component  where , , ,
 and
  
\end{defi}

In the timed system , a component  can execute
an action  only as part of an interaction , , that is, along with the execution of all other actions \footnote{To simplify the notation, we omit unary interactions and the
  actions for transitions involved in them. For example, in
  Figure~\ref{fig:ncw}, the initial transition in  does not have
  an explicit action associated.}. This corresponds to the usual notion of multi-party
interaction. We note that interactions can only restrict the behaviour
of components, i.e., the states reached by  in  belong to . This is a property which is
exploited in the verification rule (VR) in Figure~\ref{fig:VR}. 

To give a logical characterisation of components and their properties, we
use invariants. An invariant  is a state predicate which holds in
every reachable state of , in symbols, .  We use
 and , to denote \textbf{component}, respectively
\textbf{interaction invariants}.  For component invariants, our choice is
to work with their reachable symbolic set. More precisely, for component
, its associated component invariant  is the disjunction
of  for all symbolic states  in
.  To ease the reading, we abuse of notation and use
 as a place holder for a state predicate ``'' which
holds in any symbolic state with location , that is, the semantics of
 is given by .  As an
example, the component invariants for the example in Figure~\ref{fig:ncw}
with one worker are:

The interaction invariants are computed by the method explained in
\cite{dfinder}. Interaction invariants are over-approximations of the
global state space allowing us to disregard certain tuples of local
states as unreachable. As an illustration, consider the interactions
invariant for the running example when the controller is interacting
with one worker:

The invariant is given in conjunctive normal form to stick to the
formalism in \cite{dfinder, dfinderJ}. Every disjunction corresponds
to the so called notion of ``initially marked traps'' in an underlying
Petri net associated to our model. Intuitively, a trap in Petri nets
is a set of places which always contains tokens if they have tokens
initially.

We note that the proposed\footnote{The rule \vr\; is generic enough to
  work with other types of invariants. For example, one could use any
  over-approximation of the reachable set in the case of component
  invariants, however, this comes at the price of losing precision.}
component and interaction invariants are inductive invariants.  A
state predicate is called {\em inductive} for a component or system
 if, whenever it holds for a state  of  it equally holds for
any of its successors .  That is, the validity of an inductive
predicate is preserved by executing any transition, timed or discrete.
An inductive predicate which moreover holds at initial states is an
(inductive) invariant.  Trivially, such a predicate holds in all
reachable states.

As for \textbf{component properties}, we are interested in arbitrary
invariant state properties that can be expressed as boolean
combinations of ``'' predicates and clock constraints.
Invariant properties include generic properties such as mutual
exclusion, absence of deadlock, unreachability of ``bad'' states, etc.
As a simple illustration consider the property , discussed for our running example
introduced in Section~\ref{sec:intro}.  As a more sophisticated
example, consider \textit{absence of deadlock}.  Intuitively, a timed
system with a set of interactions  is \textit{deadlocked} when
no interaction in  is enabled.  Absence of deadlock is
therefore expressed as the disjunction . As for the enabledness predicate, we borrow it from
\cite{tripakis99:progress} where it is essentially constructed from
the syntactic definition of the timed system. More precisely, for an
interaction ,  is , with  being
a transition triggered by .  In turn, for ,  is defined using elementary
operations on zones as , where  is the
backward diagonal projection of ,  is the set of
valuations  such that  is in .






\section{Timed Invariant Generation}
\label{s:bm}

As explained in the introduction, a direct application of the
compositional verification rule (VR) may not be useful in itself in
the sense that the component and the interaction invariants alone are
usually not enough to prove global properties, especially when such
properties involve relations between clocks in different
components. More precisely, though component invariants encode timings
of local clocks, there is no direct way -- the interaction invariant
is orthogonal to timing aspects -- to constrain the bounds on the
differences between clocks in different components. To give a concrete
illustration, consider the property  that holds in the running
example with one worker. We note that if this property is satisfied,
it is guaranteed that the global system is not deadlocked when the
controller is at location  and the worker is at location
.  It is not difficult to see that 
cannot be deduced from  as no relation can be
established between  and .

\subsection{History Clocks for Actions}

In this section, we show how we can, by means of some auxiliary
constructions, apply (VR) more successfully. To this end, we ``equip''
components (and later, interactions) with \textit{history clocks}, a
clock per action; then, at interaction time, the clocks corresponding
to the actions participating in the interaction are reset. This basic
transformation allows us to automatically compute a new invariant of
the system with history clocks. This new invariant, together with the
component and interaction invariants, is shown to be, after projection
of history clocks, an invariant of the initial system.

\begin{defi}[Components with History Clocks] Given component , , , , its extension with history clocks is the component  where
\begin{itemize}
\item  is the set of history
  clocks,
\item ,
\item , where , given .
\end{itemize}
\label{def:cha}
\end{defi}

The clock  measures the time from the initialisation.  This clock
equals 0 in  and is never tested or reset.  Due to this very
restricted use, the same clock  can be consistently used (shared) by
all components  and consequently, allows to capture clock constraints
derived from the common system initialisation time.

Every history clock  measures the time passed from the last
occurrence of action .  These history clocks are initially strictly
greater than  and are reset when the corresponding action is
executed. As a side effect, whenever  is strictly bigger than
, we can infer that the action  has not been (yet) executed.
This initialisation scheme allows a more refined analysis precisely
because we can distinguish between actions which were executed and
those which were not.

\mycomment{ In fact,
  if the history clocks were initialised to be equal to  at the
  start time, the global invariant would allow to reflect that all the
  actions have occurred at instant , which is generally
  spurious. In addition, in the following subsections, the method
  proposes an invariant expressing some \textit{separations} between
  the history clocks in some cases. This would induce inaccuracy if
  the history clocks are supposed all equal initially.  Following this
  reasoning, we initialised the history clocks to be strictly positive
  at start time, without giving them concrete values.  }

Since there is no timing constraint involving history clocks, these have no
influence on the behaviour. The extended model is, in fact, bisimilar to
the original model. Moreover, any invariant of the extended model of
 corresponds to an invariant of original component.  By abuse of
notation, given set of actions  use  to
stand for .

\begin{prop} \label{p:tah} \hfill
  \begin{enumerate}
  \item If  is an invariant of  then  is an invariant of .
  \item If  is an invariant of  and  an inductive
    assertion of  expressed on history clocks  then  is an invariant of .
  \end{enumerate}
\end{prop}

\proof (1) It suffices to notice that any symbolic state  in the reachable set  corresponds to
a symbolic state  in the reachable set 
such that  is the projection of  to clocks in ,
that is .  Henceforth, .  Moreover, for
any invariant  of  it holds .  By
combining the two facts, we obtain that  is an invariant of
. \\
\hspace*{1cm} (2) Consider the modified component with history clocks
 defined as  but with initial configuration .  This initial configuration is valid, as
 constrain exclusively clocks in  whereas  leaves
all of them unconstrained.  Now, it can be easily shown that  is an invariant of .  Then, following the
same reasoning as for point (1) we obtain that  is an invariant of .  \qed

The only operation acting on history clocks is reset. Its effect is
that immediately after an interaction takes place, all history clocks
involved in the interaction are equal to zero. All the remaining ones
preserve their previous values, thus they are greater than or equal to
those being reset. This basic observation is exploited in the
following definition, which builds, recursively, all the inequalities
that could hold given an interaction set .

\begin{defi}[Interaction Inequalities for History Clocks]
\label{def:eqs}
Given an interaction set , we define the following
interaction inequalities :

where  and .
\end{defi}

The mechanism of history clocks is as follows. When an interaction
 takes place, the history clocks  associated to any
action  are reset. Thus they are all equal and smaller
than any other clocks and measure the time passed from the last
occurrence of .

The operation  eliminates in any interaction
 the actions from . As an illustration, for , , , . 



We can use the interpreted function ``'' as syntactic sugar to have a
slightly more compact expression for  as follows:
 
As an example, for  corresponding to
the interactions between the controller and one worker in
Figure~\ref{fig:ncw}, the compact form is:


\noindent  characterises the relations between history clocks during
any possible execution. It can be shown that this characterisation is, in
fact, an inductive predicate of the extended system with history clocks.

\begin{prop}
\label{p:eqsI}
 is an inductive predicate of .
\end{prop}
\proof Assume  holds in some arbitrary state  of
. We have two categories of successor states for
, namely time successors and discrete successors. Obviously
 holds for all time successors , as all clocks
progress uniformly and henceforth all the relations between them are
preserved.  Let now  be a discrete successor of  by an
arbitrary interaction .  As all the history clocks for actions
in  have just been reset,  satisfies
 To conclude the proof, we need to show that moreover, for
the remaining clocks of actions in ,
they satisfy  in .  Actually, we can
show the additional fact that for any set of interactions  and
for any interaction  the implication  is valid in any reachable state. This
fact can be simply proven by induction on the size of the set
interactions  following the definition of
. Consequently, assuming that  holds at , it
follows that  holds at . Then
 also holds at  because  does
not modify any clock involved in  and this
concludes the proof.  \qed

By using Proposition~\ref{p:eqsI} and Proposition~\ref{p:tah}, we can
safely combine the component and interaction invariants of the system with
history clocks with the interaction inequalities.  We can eliminate the
history clocks from  and obtain an invariant of the original system. This
invariant is usually stronger than  and yields more successful applications of the rule (VR).

\begin{cor}
   is an invariant of .
\end{cor}

\begin{exa} 
\label{eg:hc}
We reconsider the model of a controller and a worker from
Figure~\ref{fig:ncw}. We show how the generated invariants are enough
to prove the safety property  from Section~\ref{sec:intro}. The
invariants for the components with history clocks are computed
precisely as illustrated in Section~\ref{sec:intro}, that is, they
represent zone graphs:


By using the interaction invariant described in Section~\ref{sec:frtbip}
 and the inequality constraints ,
 after the elimination of the existential quantifiers in 

we obtain the following invariant \,:


We used bold fonts in  to highlight relations between  and
 which are not in . It can be easily checked now that  holds and consequently, this proves that
 holds for the system.
\end{exa}
\noindent To sum up, the basic steps of our invariant generation method described so far are: 
\begin{enumerate}
\item compute the interaction invariant ;
\item extend the components  to components with history clocks
  ;
\item compute component invariants ;
\item compute inequality constraints  for interactions
  ;
\item finally, eliminate the history clocks in .
\end{enumerate}
We note that, due to the combination of recursion and disjunction,
 can be large. Much more compact formulae can be
obtained by exploiting non-conflicting interactions, i.e.,
interactions that do not share actions.
\begin{prop}
 \label{p:eqsDisj}
 If  such that  then .
\end{prop}
\proof By induction on the number of interactions in . In the
base case,  has a single interaction and the property trivially
holds.  For the induction step, for the ease of reading, we introduce
 and  to denote respectively
 and
.  can be rewritten as follows:

\vspace*{-.7cm}
\qed
The following corollary is an immediate consequence of Proposition \ref{p:eqsDisj}.
\begin{cor}
 \label{cor:eqsDisj}
If the interaction model  has only
  disjoint interactions, i.e., for any , , then
  .
\end{cor}
The two interactions in  are
disjoint. Thus, we can simplify the expression of  to .




\subsection{History Clocks for Interactions}
\label{sec:methodEx}

The equality constraints on history clocks allow to relate the local
constraints obtained individually on components.  In the case of
non-conflicting interactions, the relation is rather ``tight'', that is,
expressed as conjunction of equalities on history clocks.  In
contrast, the presence of conflicts lead to a significantly weaker
form.  Intuitively, every action in conflict can be potentially used
in different interactions.  The uncertainty on its exact use leads to
a disjunctive expression as well as to more restricted equalities and
inequalities amongst history clocks.

Nonetheless, the presence of conflicts themselves can be additionally
exploited for the generation of new invariants.  That is, in contrast
to equality constraints obtained from interactions, the presence of
conflicting actions enforce disequalities (or separation) constraints
between all interactions using them. In what follows, we show a
generic way of automatically computing such invariants enforcing
differences between the timings of the interactions themselves. To
effectively implement this, we proceed in a similar manner as in the
previous section: we again make use of history clocks and
corresponding resets but this time we associate them to interactions,
at the system level. 
\begin{defi}[System with Interaction History Clocks]
\label{def:sc}
Given a timed system , its extension with
history clocks for interactions is the timed system  where:
\begin{itemize}
\item  is an auxiliary component  where:
\begin{itemize}
\item the set of actions 
\item the set of interaction history clocks 
\item the set of transitions 
\end{itemize}
\item  with  denoting .
\end{itemize}
\end{defi}

As before, it can be shown that any invariant of  corresponds
to an invariant of .  The history clocks for interactions
do not impact the behaviour and henceforth the two systems are bisimilar.

\begin{prop} \label{p:dtah} \hfill
  \begin{enumerate}
  \item If  is an invariant of , then  is an invariant of .
  \item If  is an invariant of  and  an inductive predicate of 
 expressed on history clocks for actions and interactions  then  is an invariant of .
 \end{enumerate}
\end{prop}
\proof Similar to Proposition~\ref{p:tah}.
\qed

We use history clocks for interactions to express additional constraints on
their timing. The starting point is the observation that when two
conflicting interactions compete for the same action , no matter which
one is first, the latter must wait until the component which owns  is
again able to execute . This is referred to as a ``separation
constraint'' for conflicting interactions.

\begin{defi}[Separation Constraints for Interaction Clocks]
\label{def:sep}
Given an interaction set , the induced separation constraints,
, are defined as follows:
 
where  denotes the absolute value of  and  is a
constant computed locally on the component executing , and representing
the minimum elapsed time between two consecutive executions of .
\end{defi}

In our running example the only conflicting actions are  and  within
the controller, and both  and  are equal to 4. The
expression of the separation constraints reduces to:


\begin{prop} \label{p:cI} 
 Let 
We have that:
\begin{enumerate}\item  is an inductive predicate of .
\item The equivalence  is a valid formula.
\end{enumerate}
\end{prop}
\proof (1) Let us fix an arbitrary term  defined as 
 Assume
 holds in an arbitrary state  of .
Then, it obviously holds for any time successors as well as for any
discrete successors by interactions not containing the action .
For an interaction involving , but different than  and
,  is reset to zero whereas  and  are
unchanged.  Henceforth,  remains valid as only
 changes to 0.  Let consider the situation  is executed
(the case of  is perfectly dual).  In this case, both  and
 are reset to 0, whereas  is unchanged.  Two
situations can happen:
\begin{enumerate}[label=
\sep^*(\gamma) 
& \equiv \displaystyle{\bigwedge_{a \in
     Act(\gamma)}}\;\displaystyle{\bigwedge_{\substack{\alpha\neq\beta \in
       \gamma\\a \in \alpha \cap \beta}}} (h_a \le h_{\alpha} \wedge h_a \le h_\beta \wedge \mid h_\alpha - h_\beta \mid \le k_a) 

& \equiv \sep(\gamma) \wedge \displaystyle{\bigwedge_{a \in
     Act(\gamma)}}\;\displaystyle{\bigwedge_{\substack{\alpha\neq\beta \in
       \gamma\\a \in \alpha \cap \beta}}} (h_a \le h_{\alpha} \wedge h_a \le h_{\beta}) 

\eqsc(\gamma) = \displaystyle{\bigwedge_{a \in Act(\gamma)}} h_a = \min\limits_{{\alpha \in \gamma, a \in \alpha}} h_\alpha.

\exists \ha. \eqsc(\gamma) 
& \equiv \exists \ha. \bigvee\limits_{\alpha_{k_1} \prec \alpha_{k_2} \prec ... \prec \alpha_{k_m}} 
\big( h_{\alpha_{k_1}} \le h_{\alpha_{k_2}} \le ... \le h_{\alpha_{k_m}} \wedge \eqsc(\gamma) \big) \\
& \qquad \textup{ (by choosing an arbitrary ordering  on interactions) } \\
& \equiv  \exists \ha. \bigvee\limits_{\alpha_{k_1} \prec \alpha_{k_2} \prec ... \prec \alpha_{k_m}} 
\big( h_{\alpha_{k_1}} \le h_{\alpha_{k_2}} \le ... \le h_{\alpha_{k_m}} \wedge \\
& \qquad \bigwedge_{a \in \alpha_{k_1}} (h_a = h_{\alpha_{k_1}}) \wedge 
 \bigwedge_{a \in \alpha_{k_2} \setminus \alpha_{k_1}} (h_a = h_{\alpha_{k_2}}) \wedge ... 
 \bigwedge_{a \in \alpha_{k_m} \setminus \alpha_{k_1} ... \alpha_{k_{m-1}}} (h_a = h_{\alpha_{k_m}}) \big) \\
& \qquad \textup{ (by expanding the definition of  along the chosen order) }

& \equiv \exists \ha. \bigvee\limits_{\alpha_{k_1} \prec \alpha_{k_2} \prec ... \prec \alpha_{k_m}} 
\big( h_{\alpha_{k_1}} \le h_{\alpha_{k_2}} \le ... \le h_{\alpha_{k_m}} \wedge 
\bigwedge_{\ell = 1}^m \bigwedge_{a \in \alpha_{k_\ell}\setminus \alpha_{k_1} ... \alpha_{k_{\ell-1}}} (h_a = h_{\alpha_{k_\ell}}) \big) \\
& \qquad \textup{ (by rewriting to a more compact form) } \\
& \equiv \bigvee\limits_{\alpha_{k_1} \prec \alpha_{k_2} \prec ... \prec \alpha_{k_m}} \exists \ha. 
\big( h_{\alpha_{k_1}} \le h_{\alpha_{k_2}} \le ... \le h_{\alpha_{k_m}} \wedge 
\bigwedge_{\ell = 1}^m \bigwedge_{a \in \alpha_{k_\ell}\setminus \alpha_{k_1} ... \alpha_{k_{\ell-1}}} (h_a = h_{\alpha_{k_\ell}}) \big) \\
& \qquad \textup{ (by distributing the existential quantifiers over the disjunction) } 

&  \equiv \bigvee\limits_{\alpha_{k_1} \prec \alpha_{k_2} \prec ... \prec \alpha_{k_m}} 
\bigwedge_{\ell = 1}^m \bigwedge_{\substack{a_i,a_j \in \alpha_{k_\ell} \setminus \alpha_{k_1} ... \alpha_{k_{\ell-1}} \\ 
  a_k \not\in \alpha_{k_1} ... \alpha_{k_\ell}}} (h_{a_i} = h_{a_j} \le h_{a_k}) \equiv \eqs(\gamma) 

\iim(\gamma) = 
& (l_{11}\vee lc_{1}\vee lc_{2}) \wedge (l_{12}\vee lc_{1}\vee lc_{2})  \wedge 
 (lc_{2}\vee l_{11}\vee l_{12})\wedge(lc_{0}\vee lc_{1}\vee l_{21}\vee l_{22})

\ic(\ctn^{h}) = 
& (lc_0 \wedge x = \te \wedge \te < h_a \wedge \te < h_c )\; {\vee}  \\
& (lc_1 \wedge x \leq \te - 8 \wedge  x \leq 4 \wedge \te < h_a  \wedge \te < h_c ) \; {\vee} \\
& (lc_1 \wedge x \leq 4 \wedge  x = h_c \leq h_a \leq \te - 12)\; {\vee} \\
& (lc_2 \wedge x \leq \te - 12 \wedge h_a=x \wedge \te < h_c ))\; {\vee} \\
& (lc_2 \wedge x=h_{a} \wedge  h_{c}=h_{a} + 4 \leq \te - 12)\\

 \ic(\cwk_i^{h}) = 
& (l_{1i} \wedge y_i =\te  \wedge \te < h_{d_i} \wedge \te < h_{b_i}    ) \; {\vee}  \\
& (l_{1i} \wedge  y_i = h_{d_i}  \leq h_{b_i} \leq \te - 8) \; {\vee} \\
& (l_{2i} \wedge y_i \geq h_{b_i}+8 \leq \te < h_{d_i}  )) \; {\vee} \\
& (l_{2i} \wedge y_i =h_{d_i}  \leq \te - 8 \wedge h_{b_i} \leq h_{d_i} - 8 ) \\

\eqsc(\gamma) =
& (h_{b_1}=h_{a|b_{1}}) \wedge (h_{b_2}=h_{a|b_{2}}) \wedge\,\, (h_{a}=\min_{i=1,2}(h_{a|b_{i}})) \wedge \\
& (h_{d_1}=h_{c|d_{1}}) \wedge (h_{d_2}=h_{c|d_{2}}) \wedge\,\, (h_{c}=\min_{i=1,2}(h_{c|d_{i}})) 

& \exists\mathcal{H}_{\gamma}.\mathcal{E}^{*}\left(\gamma\right)\wedge\mathcal{S}(\gamma)\,\, = (|h_{b_{2}}-h_{b_{1}}|\geq 4\,\wedge|h_{d_{2}}-h_{d_{1}}|\geq 4)

\exists \hp \exists \hist_{\gamma}.(\ic(\ctn^{h}) \wedge \bigwedge_i \ic(\cwk_i^{h}) \wedge \iim(\gamma) \wedge \eqsc(\gamma) \wedge \sep(\gamma))

\Phi = 
& \big(l_{11}\wedge l_{12}\wedge lc_{0} \wedge\, {x=y_1=y_2}\big) \vee \\
& \big(l_{11}\wedge l_{12}\wedge lc_{1} \wedge {x \leq 4 \wedge( y_1=y_2 \geq x+8 \vee\, }  \\
& \qquad \qquad \qquad \qquad \qquad \quad {(y_1=x\, \bm{\wedge y_2-y_1 \geq 4}) } \vee \\
& \qquad \qquad \qquad \qquad \qquad \quad {(y_1 \geq x+8 \wedge y_1-y_2 \geq 8)} \vee\\
& \qquad \qquad \qquad \qquad \qquad \quad {(y_2=x\, \wedge \bm{y_1-y_2 \geq 4})} \vee\\
& \qquad \qquad \qquad \qquad \qquad \quad {(y_2 \geq x+8 \wedge y_2-y_1 \geq 8)  }) \big) \vee\\
& \big(l_{21}\wedge l_{12}\wedge lc_{2} \wedge {y_1\geq x+8 \wedge ( (y_2 \geq x+4 \wedge \bm{|y_1-y_2| \geq \,4 } )}\vee\\
& \qquad \qquad \qquad \qquad  \qquad  \qquad         {  y_2 \geq x+12 \, }) \big) \vee\\
& \big(l_{11}\wedge l_{22}\wedge lc_{2} \wedge {y_2\geq x+8 \wedge ( (y_1 \geq x+4 \wedge \bm{|y_1-y_2| \geq \,4 } )}\vee\\
& \qquad \qquad \qquad \qquad  \qquad  \qquad         {  y_1 \geq x+12 \, }) \big)
 h_{\alpha_1} \leq \te \wedge h_{\alpha_2} \leq \te \Rightarrow
\bigvee\limits_{a'\in Prec(a)} h_{a'} \leq \te h_a \leq \te \Rightarrow \bigvee\limits_{a'\in Prec(a)} h_{a'} \leq
\te.
& \textbf{Rule 1 } \textup{[Last Occurrence Retention]:} & E\cdot a \longrightarrow  (E \smallsetminus a) \cdot a \\
& \textbf{Rule 2 } \textup{[Back-unfolding]:} & E^{*} \longrightarrow  (E^{*}\cdot E)+\varepsilon

 \epsilon \smallsetminus a &= & \epsilon \\
 x \smallsetminus a &= &\begin{cases}
                      \epsilon \textrm{ if }  x= a \\
                       x \textrm{ if }  x \neq a  \\
                        \end{cases} \\
 ( E_1+E_2 ) \smallsetminus a &= &( E_1 \smallsetminus a)+ (E_2 \smallsetminus a) \\ 
 ( E_1.E_2 ) \smallsetminus a  &=& ( E_1 \smallsetminus a). (E_2 \smallsetminus a) \\
  E^* \smallsetminus a &= & ( E \smallsetminus a)^* \\

    (a+bc^*b)^*bc^* & \leadsto (a+c^*)^*bc^*  \qquad & \textup{ (by Rule 1) } \\
    & \equiv (a+c^*)^*b(c^*c+\epsilon) \qquad & \textup{ (by Rule 2) } \\
    & \equiv (a+c^*)^*bc^*c + (a+c^*)^*b \qquad & \textup{ (by splitting the last +) } \\
    & \leadsto (a+\epsilon)^*bc + (a+c^*)^*b & \qquad \textup{ (by Rule 1) } \\
    & \equiv a^*bc + (a+c)^*b \qquad & \textup{ (by standard transformation) }
  \phi(e^{\sharp}) \equiv \bigvee\limits_{\substack{a_1...a_n \in L(e^{\sharp})\\\textup{distinct }a_1,\dots,a_n}} \big(\te \geq h_{a_1} \geq ... \geq
h_{a_n} \wedge \bigwedge_{c\not=a_1,...,a_n} h_c > \te\big)
& (h_0 \geq h_a \geq h_b \geq h_c)\, \vee\, (h_a > h_0 \geq h_b \geq h_c)\, \vee & (\textup{corr. to }abc, \textup{resp. }bc)\\ 
& (h_0 \geq h_a \geq h_c \geq h_b)\, \vee\, (h_0 \geq h_c \geq h_a \geq h_b)\, \vee & (\textup{corr. to } acb, \textup{resp. }cab)\\
& (h_a > h_0 \geq h_c \geq h_b)\, \vee\, (h_c > h_0 \geq h_a \geq h_b)\, \vee & (\textup{corr. to }cb, \textup{resp. }ab)\\
& (h_0 \geq h_b \wedge h_c, h_a > h_0) & (\textup{corr. to }b)
\te \geq h_{a_1} \geq ... \geq h_{a_n} \wedge h_{b_1} \ge h_{a_1} \wedge ... \wedge h_{b_m} \ge h_{a_1} 
\wedge \bigwedge\limits_{c\not=a_i,b_j} h_c > \te.  (h_0 \geq h_b \geq h_c \wedge h_a \geq h_b) \vee (h_0 \geq h_b
  \wedge h_a \geq h_b \wedge h_c \geq h_b ) 
\pi(\varphi) = 
\begin{cases}
   x_{\pi(i)} \textit{ rop } x_{\pi(j)} & \textup{ if } \varphi = x_i \textit{ rop } x_j \textup{ and } \textit{rop} \in \{<,\leq,=,>, \geq\}\\
  l_{\pi(i)} & \textup{ if } \varphi = l_i \\
  \neg \pi(\varphi_1) & \textup{ if } \varphi = \neg \varphi_1 \\
  \pi(\varphi_1) \textit{ op } \pi(\varphi_2) & \textup{ if } \varphi = \varphi_1 \textit{ op } \varphi_2 \textup{ and } \mathit{op} \in \{\wedge, \vee\}
\end{cases}

  \sepc(\gamma) = \bigwedge_{\substack{i < j\\a_c \in \alpha_i \cap
      \alpha_j}} h_{\alpha_i} - h_{\alpha_j} \geq k_{a_c} \wedge
  \displaystyle{\bigwedge_{\substack{b \neq a_c\\ b \in \beta_i \cap \beta_j}}} \mid
  h_{\beta_i} - h_{\beta_j} \mid \geq k_b

\displaystyle{\bigwedge_{a\in
    Act(C)}}\displaystyle{\bigwedge_{\substack{i < j\\a \in
      \alpha_i \cap \alpha_j}}} h_{\alpha_i} - h_{\alpha_j} \geq k_{a_c}

 \bigwedge_{i \neq j} \big( (h_{approach_i} \leq \te \wedge h_{approach_j} \leq \te) \rightarrow  h_{raise} \leq h_0\big) 
 \mathbf{R_i}=(e_0+s_0)^*e_i. s_i+(e_0 +  s_0)^*s_i. e_i+(e_0 + e_i)^*s_0 s_i+(e_i + s_0)^*e_0 s_i+s_i 
 \phi(\mathbf{R_i}) = & (h_{e_0} \geq h_{e_i} \wedge  h_{s_0} \geq h_{e_i}  \wedge h_{e_i} \geq h_{s_i} \wedge h_{e_i} \leq \te) \; {\vee}  \\
 & (h_{e_0} \geq h_{s_i} \wedge  h_{s_0} \geq h_{s_i}  \wedge h_{e_i} \leq h_{s_i} \wedge h_{s_i} \leq \te) \; {\vee}   \\
 & (h_{e_0} \geq h_{s_0}  \wedge  h_{e_i}  \geq h_{s_0}  \wedge  h_{s_0} \geq h_{s_i} \wedge h_{s_0} \leq \te) \; {\vee} \\
 & (h_{s_0} \geq h_{e_0}  \wedge  h_{e_i}  \geq h_{e_0}  \wedge  h_{e_0} \geq h_{s_i} \wedge h_{e_0} \leq \te) \;  {\vee} \\
 & ( h_{s_i} \leq \te \wedge h_{s_0}, h_{e_0}, h_{e_i} > \te)
(h_{VP} \leq h_{VS}  \wedge h_{VS} \leq h_0) \rightarrow  h_{VS} - h_{VP} \geq \textit{TURI}

\mycomment{ \q{ Should I put the following?}  Contrariwise, the method
  cannot verify that the time elapse between two consecutive
  \textit{VP venticular events} is bigger than .  This is due to
  the fact that the history clocks record the last occurrence of each
  action. It results that in some way, the global invariant confounds
  consecutive occurrences of the same action. This is one of the cases
  where the method, being based on an over-approximation of the
  reachable states set, shows a false positive. A counter-example
  analysis module based on a guided backward analysis algorithm is
  under development and is meant to remedy this incompleteness.  }

\subsection{Results}
We ran our experiments on a Linux machine with Intel Core  GHz
 and  GiB memory. The results, synthesised in
Table~\ref{tab:res}, show the potential of our method in terms of
accuracy and scalability.  In Table~\ref{tab:res},  is the number
of components,  is the total number of control locations, 
(resp. ) is the number of system clocks (resp. history clocks), 
is the number of interactions, while  shows the total verification
time and  is the timed taken by Yices for satisfiability
checking of . 



\mycomment{ As a side remark, we note
  that for each conflicting action , the corresponding 
  constant, serving to express separation constraints, is computed
  while building the reachability graph of the containing
  component. The interaction inequalities for history clocks are
  necessary to catch the synchronization between the different
  components. However, the separation constraints are necessary only
  for verifying the temperature controller example.}
 \mycomment{Furthermore, the interaction invariant was not useful
  for any of the benchmarks described in this paper.  In fact, for
  most of the examples that we verified, history clocks constraints
  dispense RTD-Finder with their computation, since the safety
  properties could be verified without it. \\} \mycomment{ The
  heuristic based on symmetry exploitation (section 4.3 ) has not been
  implemented yet and is expected to reduce verification time for the
  temperature controller example, whereas the heuristic using regular
  expressions (section 4.2) is expected to compute efficiently the
  local invariant of the Id-Variable of Fischer protocol
\footnote{The heuristic for the
  automatic computation of the untimed Id-variable invariant for
  Fischer has not been implemented yet. For Fischer exclusively, 
  is the time required for the computation of all the other invariants
  and  is the total number of locations of the other components.}. \\
}\begin{table}[htp]
\centering{
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline 
Model &  &   & &  &  &  & \tabularnewline
\hline 
\hline 
Train gate controller (50 trains) & 52 & 158 &  52 & 102 & 106 & 0.5s & 0.3s\tabularnewline
\hline 
Train gate controller (100 trains) & 102 & 308  & 102 & 202 & 206 & 5.3s & 0.6s\tabularnewline
\hline 
Train gate controller (200 trains) & 202 & 608  & 202 & 402 & 406 & 1m33s & 5s\tabularnewline
\hline 
Train gate controller (300 trains) & 302 & 908  & 302 & 602 & 606 & 9m8s & 20s \tabularnewline
\hline 
Train gate controller (500 trains) & 502 & 1508  & 502 & 1002 & 1006 & 1h13m20s & 2m52s \tabularnewline
\hline \hline 
Temperature controller (20 rods) & 21 & 42  & 21 & 40 & 42 & 0.07s & 0.01s \tabularnewline
\hline 
Temperature controller (50 rods) & 51 & 102  & 51 & 100 & 102 & 0.35s & 0.04s \tabularnewline
\hline 
Temperature controller (100 rods) & 101 & 204 &  102 & 200 & 204 & 3.7s & 0.08s\tabularnewline
\hline 
Temperature controller (300 rods) & 301 & 602 &  302 & 600 & 602 & 5m47s & 0.9s\tabularnewline
\hline \hline 
Fischer protocol (100 processes) & 101 & 400 & 101  & 300 & 501 & 2.7s & 0.06s \tabularnewline
\hline 
Fischer protocol (200 processes) & 201 & 800 & 201  & 600 & 1001 & 0m47s & 0.22s\tabularnewline
\hline 
Fischer protocol (300 processes) & 301 & 1200 &  301 & 900 & 1501 & 4m27s & 0.5s \tabularnewline
\hline \hline
Gear controller & 5 & 65 & 4 & 17 & 32 & 15.1s & 0.14s \tabularnewline
\hline \hline 
Pacemaker (with monitor) & 7 & 19 &  11 & 6 & 21 & 15.23s & 0.044s\tabularnewline
\hline 
Pacemaker (without monitor) & 6 & 16 &  9 & 6 & 19 & 15s & 0.032s\tabularnewline
\hline 
\end{tabular}
\caption{ Results from experiments} \label{tab:res}
}
\end{table}

To the best of our knowledge, there are no tools to compositionally
verify safety properties of timed systems. Consequently, there are no
relevant tools to compare RTD-Finder with. Netherveless, we did a
small comparison with Uppaal \cite{uppaal}. Uppaal is a well-known model-checking
tool which is highly optimised. For instance, thanks to some reduction
techniques, it has better scores on the first example (the TGC system)
in particular and on smaller systems in general.  Nonetheless,
generally, state space exploration is costly. This can be
illustrated by means of the temperature controller example: for
 rods, Uppaal generated no results after five hours and 
explored states. On the other hand, RTD-Finder checked the property for
 rods in few minutes, as shown in Table~\ref{tab:res}.  The
timings for the RTD-Finder tool are obtained by the java command
\texttt{getCpuTime} called to compute the total verification time,
while the results for Uppaal come from the command \texttt{verifyta}
which comes with the Uppaal 4.1.14 distribution.




\section*{Related Work} 
Automatic generation of invariants for concurrent systems is a
long-time studied topic.  Yet, to our knowledge, specific extensions
or applications for timed systems are rather limited. As an exception,
the papers \cite{badban10:inv-ta,fietzke12:inv-ta} propose a
monolithic, non-compositional method for finding invariants in the
case of systems represented as a single timed automaton.

Compositional verification for timed systems has been mainly
considered in the context of timed interface theories \cite{Alfaro02}
and contract-based assume guarantee reasoning
\cite{Ecdar,AutomaticCompERAs,mocha}. These methods usually rely upon
choosing a ``good'' decomposition structure and require individual
abstractions for components to be deterministic timed I/O
automata. Finding the abstractions is in general difficult, however,
their construction can be automated by using learning techniques
\cite{AutomaticCompERAs} in some cases. In contrast to the above, we
are proposing a fully automated method generating, in a compositional
manner, an invariant approximating the reachable states of a timed
system.  

Abstractions serve also for compositional minimisation, for instance
\cite{berendsen08} minimises by constructing timed automata quotients
with respect to simulation; these quotients are in turn composed for
model-checking. Our approach is orthogonal in that we do not compose
at all. Compositional deductive verification as in \cite{boer97} is
also orthogonal on our work in that, by choosing a particular class of
local invariants to work with, we need not focus on elaborate proof
systems but reason at a level closer to intuition.

The use of additional clocks has been considered, for instance, in
\cite{Bengtsson98, pettersson07:partial}. There, extra reference
clocks are added to components to faithfully implement a partial order
reduction strategy for symbolic state space exploration. Time is
allowed to progress desynchronised for individual components and
re-synchronised only when needed, i.e., for direct interaction within
components. Clearly, the history clocks in our work behave in a
similar way, however, our use of clocks is as a helper construction in
the generation of invariants and we totally avoid global state space
exploration. Finally, another successful application of extra clocks
has been provided in \cite{SalahBM09} for timing analysis of
asynchronous circuits. There, specific history clocks are reset on
input signals and used to provide a new time basis for the
construction of an abstract model of output signals of the circuit.

\mycomment{
\todo{abstraction + 3 refs from the last reviewer }

Finally, we note that there is notable work on abstraction \cite{...}.
This work is orthogonal on our approach: the abstractions are with
respect to global states, consequently, their applicability to systems
with a great number of components is problematic.

For \cite{tiwari11:hybrid} underline that they do k-induction or
bounded model-checking, that is, the goal is to invalidate safety
properties \obs{not quite sure because they analyse why k-ind doesn't
  return safe for some workbenches}, while in our case, the goal is to
validate: if no solution, then we can conclude that the system is
safe. In addition, the approach in \cite{tiwari11:hybrid} relies on
quantifier elimination which does only works for a small number of
quantifiers (while for large systems this condition cannot be
satisfied/enforced/guaranteed).

\cite{tiwari05:inv-hybrid}

\cite{pettersson07:partial}
}


\section{Conclusions}
\label{sec:conc}
We presented a fully automated compositional method to generate global
invariants for timed systems described as parallel compositions of
timed automata components using multi-party interactions. The
soundness of the method proposed has been proven. In addition, it has
been successfully tested on several benchmarks.
This method has been implemented in the RTD-Finder tool. The results
show that it may outperform the existing exhaustive
exploration-based techniques for large systems, thanks to the use of
compositionality and over-approximations.
Nonetheless, the generated invariant is an over-approximation of the 
reachable states set and false-positives may raise. To remedy this, 
we are working on a guided backward analysis module to decide upon 
their validity. \\
 In order to achieve a better integration, we are working on handling 
 richer classes of systems, including systems with data variables 
 and {\it urgencies} \cite{BozgaSifakis06} on transitions.
 Actually, urgencies provide an alternative way to constrain time progress, which is more intuitive to
use by programmers but very difficult to handle in a compositional
way. A second direction of research which is potentially interesting
for systems containing identical, replicated components and closely
related to the symmetry-based reduction is the application of our
method to the verification of parameterised timed systems. Finally, we
are considering specific extensions to particular classes of timed
systems and properties, in particular, for schedulability analysis of
systems with mixed-critical tasks.


\mycomment{
We presented a fully automated compositional method to generate global
invariants for timed systems described as parallel compositions of
timed automata components using multi-party interactions. The
soundness of the method proposed has been proven. In addition, it has
been implemented and successfully tested on several benchmarks.  The
results show that our method may outperform existing exhaustive
exploration-based techniques for large systems, thanks to the use of
compositionality and over-approximations.

 
This work is currently being extended in several directions.  First,
we work on integrating it within D-Finder tool \cite{dfinder} and the
Real-Time BIP framework \cite{rtbip11}.  In order to achieve a better
integration, we are working on handling {\it urgencies}
\cite{BozgaSifakis06} on transitions.  Actually, urgencies provide an
alternative way to constrain time progress, which is more intuitive to
use by programmers but very difficult to handle in a compositional
way. A second direction of research which is potentially interesting
for systems containing identical, replicated components and closely
related to the symmetry-based reduction is the application of our
method to the verification of parameterised timed systems. Finally, we
are considering specific extensions to particular classes of timed
systems and properties, in particular, for schedulability analysis of
systems with mixed-critical tasks.}




\subsection*{Acknowledgement.} We are grateful to the anonymous
referees for their constructive input and for their thorough feedback.
We would also like to thank our colleague Mahieddine Dellabani for his
help with two benchmarks.


\bibliographystyle{abbrv} 
\bibliography{main}

\end{document}
