\pdfoutput=1  \documentclass{article}
\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{url}

\topmargin 0in              \headheight 0pt                 \headsep 0in                    \textheight 9in              \textwidth 6.5in
\oddsidemargin 0in              


\def\C{{\cal C}}
\def\H{{\cal H}}
\def\L{{\cal L}}
\def\M{{\cal M}}
\def\e{{\varepsilon}}
\def\G{{\Gamma}}
\def\s{{\sigma}}
\def\hull{\mathop{\rm hull}\nolimits}
\def\sp{\mathop{\rm sp}\nolimits}
\def\lline{\mathop{\rm line}\nolimits}


\def\st{{\sc Stretch}}
\def\hp{{\sc Hop}}
\def\sw{{\sc Swap}}
\def\tw{{\sc Twang}}
\def\twc{{\sc TwangCascade}}
\def\stc{{\sc StretchCascade}}
\def\fm{{\sc ForwardMove}}


\newcommand{\hide}[1]{}
\newcommand\R{\mathbb{R}}
\newcommand\Pw{\mathcal{P}}
\newcommand{\squeezelist}{\setlength{\itemsep}{0pt}}


\newtheorem{theorem}{{\bf Theorem}}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{definition}[theorem]{Definition}

\newcommand{\lemlab}[1]{\label{lemma:#1}}
\newcommand{\thmlab}[1]{\label{thm:#1}}
\newcommand{\eqlab}[1]{\label{eq:#1}}
\newcommand{\corlab}[1]{\label{cor:#1}}
\newcommand{\deflab}[1]{\label{def:#1}}
\newcommand{\tablab}[1]{\label{tab:#1}}
\newcommand{\figlab}[1]{\label{fig:#1}}
\newcommand{\seclab}[1]{\label{sec:#1}}
\newcommand{\chaplab}[1]{\label{chap:#1}}

\newcommand{\lemref}[1]{\ref{lemma:#1}}
\newcommand{\thmref}[1]{\ref{thm:#1}}
\newcommand{\corref}[1]{\ref{cor:#1}}
\newcommand{\defref}[1]{\ref{def:#1}}
\newcommand{\chapref}[1]{\ref{chap:#1}}
\newcommand{\secref}[1]{\ref{sec:#1}}
\newcommand{\figref}[1]{\ref{fig:#1}}
\newcommand{\tabref}[1]{\ref{tab:#1}}
\newcommand{\ABox}{
\raisebox{3pt}{\framebox[6pt]{\rule{6pt}{0pt}}}
}
\newenvironment{pf}{{\bf Proof:}}{\hfill\ABox}

{\makeatletter
 \gdef\xxxmark{\expandafter\ifx\csname @mpargs\endcsname\relax \expandafter\ifx\csname @captype\endcsname\relax \marginpar{xxx}\else
       xxx \fi
   \else
     xxx \fi}
 \gdef\xxx{\@ifnextchar[\xxx@lab\xxx@nolab}
 \long\gdef\xxx@lab[#1]#2{{\bf [\xxxmark #2 ---{\sc #1}]}}
 \long\gdef\xxx@nolab#1{{\bf [\xxxmark #1]}}
\gdef\turnoffxxx{\long\gdef\xxx@lab[##1]##2{}\long\gdef\xxx@nolab##1{}}}


\title{Connecting Polygonizations via Stretches and Twangs}
\author{Mirela Damian\thanks{Dept. of Computer Science, Villanova Univ., Villanova,
    PA 19085, USA.
   \protect\url{mirela.damian@villanova.edu}.}
\and
Robin Flatland\thanks{Dept. of Computer Science, Siena College, Loudonville, NY 12211, USA.
    \protect\url{flatland@siena.edu}.}
\and
Joseph O'Rourke\thanks{Dept. of Computer Science, Smith College, Northampton, MA
      01063, USA.
      \protect\url{orourke@cs.smith.edu}.
}
\and
Suneeta Ramaswami\thanks{Dept. of Computer Science, Rutgers University,
       Camden, NJ 08102, USA.
   \protect\url{rsuneeta@camden.rutgers.edu}.}
}
\date{}

\begin{document}
\maketitle

\begin{abstract}
\noindent We show that the space of polygonizations of a fixed
planar point set  of  points is connected by
 ``moves'' between simple polygons.
Each move is composed of a sequence of
atomic moves called ``stretches'' and ``twangs''.
These atomic moves walk between weakly simple
``polygonal wraps'' of .
These moves show promise to serve as a basis for generating random polygons.
\end{abstract}

\maketitle

\section{Introduction}
\seclab{Introduction} This paper studies polygonizations of a fixed
planar point set  of  points. Let the  points be labeled
, . A \emph{polygonization} of  is a
permutation  of  that determines a polygon:
 is a simple
(non-self-intersecting) polygon. We will abbreviate ``simple
polygon'' to \emph{polygon} throughout.
As long as  does not lie in one line, which we will henceforth assume,
there is at least one
polygon whose vertex set is . A point set  may have as few as
 polygonization, if  is in convex position,\footnote{
  is in convex position if every point in  is on the hull of .
}
and as many as
 polygonizations. For the latter, see
Fig.~\figref{one.pocket.polygonization}a.

Our goal in this work is to develop a computationally natural and
efficient method to explore all polygonizations of a fixed set .
One motivation is the generation of ``random polygons'' by first
generating a random  and then selecting a random polygonization
of . Generating random polygons efficiently is a long unsolved
problem; only heuristics~\cite{ah-hgrp-96} or algorithms for special
cases~\cite{zssm-grpgv-96} are known. Our work can be viewed as
following a suggestion in the latter paper:
\begin{quotation}
\noindent ``start with a ... simple polygon and apply some
simplicity-preserving, reversible operations ... with the property
that any simple polygon is reachable by a sequence of operations''
\end{quotation}

\noindent Our two operations are called \emph{stretch} and
\emph{twang} (defined in Section~\secref{Stretches.Twangs}). Neither
is simplicity preserving, but they are nearly so in that they
produce polygonal wraps defined as follows.

\begin{definition}
\emph{A} polygonal wrap \emph{ is determined by
a sequence  of point indices drawn from 
with the following properties:
\begin{enumerate}
\squeezelist
\item Every index in  occurs in .
\item Indices may be repeated.  If index  appears
at least twice in , we call  a \emph{point of double contact}.
\item For sufficiently small , there exists a perturbation
within an -disk of the points in double contact, separating each
such point into two or more points, so that there is a simple closed curve
 that passes through the perturbed points in  order.
Sometimes such a  is called ``weakly simple'' because its
violations of simplicity (i.e., its self-touchings) avoid proper
crossings.\footnote{
   Two segments properly cross if they share a point  in the relative interior of
   both, and cross transversely at .}
\end{enumerate}
}
\label{def:polygonal.wrap}
\end{definition}

\vspace{-0.5em} 
\noindent Fig.~\figref{one.pocket.polygonization}b
shows a polygonal wrap 
with five double-contacts
( and ). Note that a polygon is a polygonal
wrap without double-contact
points. 

Stretches and twangs take one polygonal wrap to another. A stretch
followed by a natural sequence of twangs, which we call a
\emph{cascade}, constitutes a \emph{forward move}. Forward moves
(described in further detail in Section~\secref{Twang.Cascades})  
take a polygon to a polygon, i.e., they are simplicity preserving.
Reverse moves will be introduced in Section~\secref{Reverse}. A
\emph{move} is either a forward or a reverse move. We call a stretch
or twang an \emph{atomic move} to distinguish it from the more
complex forward and reverse moves.

Our main result is that the configuration space of polygonizations for
a fixed  is connected by forward/reverse moves, each of which is
composed of a number of stretches and twangs, and that the diameter of
the space is  moves.
We can bound the worst-case number of atomic moves constituting a
particular forward/reverse move
by the geometry of the point set.
Experimental results on random point sets show that,
in the practical situation that is one of our motivations, the bound
is small, perhaps even constant.
We have also established loose bounds on the worst-case number of atomic
operations as a function of :
an exponential upper bound and a quadratic lower bound. 
Tightening these bounds has so far proven elusive
and is an open problem.

One can view our work as in the
tradition of connecting discrete structures (e.g., triangulations,
matchings) via local moves (e.g., edge flips, edge swaps).  Our result
is comparable to that in~\cite{ls-utstp-82}, which shows connectivity
of polygonizations in  edge-edge swap moves through
intermediate self-crossing polygons. The main novelty of our work is
that the moves, and even the stretches and twangs, never lead to
proper crossings, for polygonal wraps have no such crossings. We explore
the possible application to random polygons briefly in
Section~\secref{Random.Polygons}. For the majority of this paper, we
concentrate on defining the moves and establishing connectivity.

\begin{figure}[htbp]
\centering
\includegraphics[width=0.9\linewidth]{PDFigures/figure1}
\vspace{-0.5em}\caption{Examples. (a) A set of  points that
admits  polygonizations. (b) Polygonal wrap  with
 (c) A polygonization with
one pocket with lid .} \figlab{one.pocket.polygonization}
\end{figure}


We begin by defining pockets, which play a central role in our
algorithms for polygonal transformations. Then in
Section~\secref{Swaps.Hops} we describe two natural operations that
transform one polygon into another but fail to achieve connectivity of
the configuration space of polygonizations, which motivates our
definitions of stretches and twangs in
Section~\secref{Stretches.Twangs}. Following these preliminaries, we
establish connectivity and compute the diameter in
Sections~\secref{single.pocket.reduction}--\secref{Connectivity}.
We conclude with open problems in Section~\secref{Open.Problems}.

\subsection{Pockets and Canonical Polygonization}
\seclab{Pockets} Let  be a polygonization of . A hull edge
 that is not on  is called a \emph{pocket lid}. The
polygon external to  bounded by  and  is a \emph{pocket}
of .


\begin{lemma}
Any point set  not in convex position has a polygonization with
one pocket only~\emph{\cite{chuz-peps-92}}. \lemlab{one.pocket}
\end{lemma}
For a fixed hull edge , we define the canonical polygonization
of  to be a polygon with a single pocket with lid  (cf.
Lemma~\lemref{one.pocket}) in which the pocket vertices are ordered
by angle about vertex , and from closest to farthest from  if
along the same line through . We call this ordering the
\emph{canonical order} of the pocket vertices; see
Fig.~\figref{one.pocket.polygonization}c.

\vspace{-1em}
\section{Polygonal Transformations}

Let  be a polygon defined by a circular index sequence .
We examine operations that permute this sequence, transforming 
into a new polygon with the same set of vertices
linked in a different order. 
Throughout the paper we use  to denote the
closed triangle with corners
,  and .


\subsection{Swaps and Hops}
\seclab{Swaps.Hops} We begin by defining two natural transformation
operations, a \emph{swap} and a \emph{hop}. A swap operation
is a transposition of
two consecutive vertices of  that results in a new
(non-self-intersecting) polygon. Fig.~\figref{swaps}a illustrates
the swap operation. It is well known that transpositions connect all
permutations, but this is not the case for swaps. Because
we require that the resulting polygon be simple, a vertex pair
cannot be swapped if the operation results in a self-intersecting
polygon. Fig.~\figref{swaps}b shows an example of a polygon for
which no vertex pair can be swapped without creating an edge
crossing. Thus, swaps do not suffice to connect all polygonizations,
which motivates our definition of a more powerful move,
which we call a \emph{hop}.

\begin{figure}[htbp]
\centering
\begin{tabular}{cc@{\hspace{0.05\linewidth}}cc}
\raisebox{0.2in}{(a)} &
\raisebox{0.1in}{\includegraphics[width=0.5\linewidth]{PDFigures/swaps}}
& \raisebox{0.2in}{(b)} &
\includegraphics[width=0.3\linewidth]{PDFigures/noswaps}
\end{tabular}
\vspace{-0.5em} \caption{(a) \sw illustrated (b) Polygon
admitting no swaps.} \figlab{swaps}
\end{figure}


The hop operation generalizes the swap by allowing a vertex to hop
to any position in the permutation, as long as the resulting polygon
is simple. Fig.~\figref{hops}a shows the stretching of the edge  down to
vertex , effectively ``hopping''  between
 and  in the permutation. We denote this operation
by \hp, where  (note the first argument
is \emph{from} and the second \emph{to}).


To specify the conditions under which a hop operation is valid, we
introduce some definitions, which will be used subsequently as well.
A polygon  has two sides, the interior of  and the
exterior of . Let  be three vertices consecutive in
the polygonization . For noncollinear vertices, we distinguish
between the \emph{convex side} of , that side of 
with angle  smaller than , and the \emph{reflex
side} of , the side of  with angle 
larger than .
Note that this definition ignores which side is the interior and
which side is the exterior of , and so is unrelated to whether
 is a convex or a reflex vertex in . Every true vertex has a
convex and a reflex side (collinear vertices will be discussed in
Section~\secref{Stretches.Twangs}).
To ensure that the resulting polygon is simple, \hp is
valid iff the following two conditions hold: (1) the triangle
induced by the two edges incident to  is empty of other polygon
vertices and (2) the triangle induced by  and  lies on the
reflex side of  and is empty of other polygon vertices.


Although more powerful than a swap, there also exist polygons that do
not admit any hops. Fig.~\figref{hops}b shows an example (the
smallest we could find) in which each edge-vertex pair violates one
or both of the two conditions above. This example shows that hops do
not suffice to connect all polygonizations. 

\vspace{-0.5em}
\begin{figure}[htbp]
\centering
\begin{tabular}{cc@{\hspace{0.1\linewidth}}cc}
\raisebox{0.2in}{(a)} &
\raisebox{0.1in}{\includegraphics[width=0.52\linewidth]{PDFigures/hops}}
& \raisebox{0.2in}{(b)} &
\includegraphics[width=0.25\linewidth]{PDFigures/nohops}
\end{tabular}
\vspace{-0.5em}\caption{(a) \hp illustrated (b) Polygon
admitting no \hp.} \figlab{hops}
\end{figure}



The limited transformation capabilities of the swap and hop
operations motivate our introduction of two new operations,
\emph{stretch} and \emph{twang}. The former operation relaxes the two hop
conditions and allows the creation of a polygonal wrap.
The latter operation restores the polygonal wrap to a polygon. We show
that together they are capable of transforming any polygon into a
canonical form
(Sections~\secref{single.pocket.reduction}-\secref{canonical}), and
from there to any other polygon
(Sections~\secref{Reverse}-\secref{Connectivity}).

\subsection{Stretches and Twangs}
\seclab{Stretches.Twangs}

Unlike the \hp operation, which requires  to fully see
the edge  into which it is hopping, the \st operation
only requires that  see a point  in the interior\footnote{
   By ``interior'' we mean ``relative interior,''
   i.e., not an endpoint.} of .
The stretch is accomplished in two stages: (i)~temporarily
introduce two new ``pseudovertices'' on  in a small neighborhood
of  (this is what we call \st below), and (ii)~remove the
pseudovertices immediately using twangs.

\paragraph{\st.}
Let  see a point  in the interior of an edge  of . By
\emph{see} we mean ``clear visibility'', i.e., the segment 
shares no points with  other than  and  (see
Fig.~\ref{fig:stretch.twang}a). Note that every vertex  of 
sees such an  (in fact, infinitely many ) on some .
Let  and  be two points to either side of  on ,
both in the interior of ,
such that  can clearly see both  and .
Two such points always exist in a
neighborhood of . We call these points \emph{pseudovertices}. Let
, with  closer to the endpoint  of . Then
\st alters the polygon to replace  with , effectively ``stretching''  out to reach  by
inserting a narrow triangle  that
sits on  (see Fig.~\figref{stretch.twang}b).

\begin{figure}[htbp]
\centering
\includegraphics[width=0.9\linewidth]{PDFigures/stretchtwang}
\caption{\st illustrated (a)  sees  (b)
\st (c) \st. } \figlab{stretch.twang}
\end{figure}
To complete the definition of \st, which
removes the pseudovertices  and , we first define the twang operation.

\vspace{-0.5em}
\paragraph{\tw.}
Informally, if one views the polygon boundary as an elastic band, a
twang operation detaches the boundary from a vertex  and snaps it
to 's convex side. 



\begin{definition}
\emph{The operation \tw is defined for any three consecutive
vertices  such that
\begin{enumerate}
\squeezelist
\item  are not collinear.  
\item  is either a pseudovertex, or a vertex in double
contact. If  is a vertex in double contact,  
then 
does not contain a \emph{nested} double contact at . 
By
this we mean the following: Slightly perturb the vertices of  to
separate each double-contact into two or more points, so that  becomes
simple. Then  does not contain any other occurrence of  in
. (E.g., in Fig.~\figref{twangs}a,  contains a second occurrence
of .)
\end{enumerate}
}

\emph{
Under these conditions, the operation \tw replaces the
sequence  in  by , where  indicates
the shortest path from  to  that stays inside 
and does not cross . We call  the 
\emph{twang vertex}. Whenever  and  are irrelevant to the discussion, we
denote the twang operation by \tw.}  \label{def:twang}
\end{definition}






\begin{figure}[htbp]
\centering
\includegraphics[width=\linewidth]{PDFigures/twangs}
\caption{\tw() illustrated (a) \tw replaces  by
 (b) \tw creates the hairpin vertex  and three
doubled edges ,  and .} \figlab{twangs}
\end{figure}


Informally, \tw ``snaps'' the boundary to wrap around the hull
of the points in , excluding  (see
Fig.~\figref{twangs}a). A twang operation can be viewed as taking
a step toward simplicity by removing either a pseudovertex or a point
of double contact.  We should note that  includes every
vertex along this path, even collinear vertices. If there are no
points inside , then , and \tw can
be viewed as the reverse of \hp.
If  (i.e.,  and  overlap in ), we call  a \emph{hairpin}
vertex of ; in this case, \tw replaces  in  by
. Hairpin vertices and ``doubled edges'' 
arise naturally from twangs.
In Fig.~\figref{twangs}b for instance, \tw produces a
hairpin vertex at  and doubled edges , , .
So we must countenance such degeneracies.
In general, there are points interior to the triangle, and the twang
creates new points of double contact.  Below, we will apply twangs
repeatedly to remove all double contacts.

\paragraph{\st.}
We can now complete the definition of \st, with .  
First execute
\st, which
picks the two pseudovertices  and .
Then execute \tw and
\tw, which detach the boundary from
 and  and return to a polygonal wrap 
of 
 (see Fig.~\figref{stretch.twang}c). We refer to 
() as the \emph{stretch edge} (\emph{vertex}).


\vspace{-0.2em}
\subsection{Twang Cascades}
\seclab{Twang.Cascades}
A twang in general removes one double contact and creates perhaps
several others.  A \emph{\twc} applied on a polygonal wrap
 removes all points of double contact from :

\vspace{-1em}
\begin{center}
\vspace{1mm} \fbox{
\begin{minipage}[h]{0.98\linewidth}
\centerline{\twc()}
\vspace{1mm}{\hrule width\linewidth}\vspace{2mm} \small{\begin{tabbing}
...\=..........\=...........................................................\kill
Loop for as long as  has a point of double contact :\\
\\
\> 1. Find a vertex sequence  in  that satisfies the twang conditions (cf. Def.~\ref{def:twang}).\\
\> 2. \tw.
\end{tabbing}}
\end{minipage}
}\vspace{1mm}
\end{center}



Note that for any point of double-contact , there always exists a vertex
sequence  that satisfies the twang conditions and therefore the twang
cascade loop never gets stuck.
That a twang cascade eventually terminates is not immediate.
The lemma below, whose proof we omit, shows that \tw shortens
the perimeter of the polygonal wrap 
(because it replaces  by )
by at least a constant depending
on the geometry of the point set.  
Therefore, any twang cascade must terminate in a finite number of steps.

\begin{lemma}
A single twang \tw() decreases the perimeter of the polygonal wrap by at least
, where  is the
smallest pairwise point distance and  is the maximum convex
angle formed by any triple of non-collinear points.
\lemlab{delta}
\end{lemma}

Supplementing this geometric bound,
Corollary~\corref{odometer} in Appendix~3 establishes 
a combinatorial upper bound of  on the number of twangs
in any twang cascade.
An impediment to establishing a better bound is that a point can
twang more than once in a cascade.
Indeed we present in Appendix~2 an example in which
 points each
twang  times in one cascade, providing an
 lower bound.

\subsubsection{Forward Move}
We define a \emph{forward move} on a polygonization  of a set 
as a stretch (with the additional requirement that the
pseudovertices on the stretch edge lie on the reflex side of the
stretch vertex), followed by a twang and then a twang cascade, as
described below:

\begin{center}
\vspace{1mm} \fbox{
\begin{minipage}[h]{0.95\linewidth}
\centerline{\fm()}
\vspace{1mm}{\hrule width\linewidth}\vspace{2mm} \small{\begin{tabbing}
..\=.....\=...........................................................\kill
\> Preconditions: (i)  is a simple polygon, (ii)  and 
satisfy the conditions of \st, and \\ 
\> (iii)  is a noncollinear
vertex such that pseudovertices  and  on  lie on the reflex
side of .\\ 
\> \{Let  be the vertex sequence containing  in 
(necessarily unique, since  is simple).\}\\ 
\\
\> 1. \>  \st. \\
\> 2. \>  \tw. \\
\> 3. \>  \twc.
\end{tabbing}}
\end{minipage}
}\vspace{1mm}
\end{center}



A \fm\ takes one polygonization  to another  (see
Fig.~\figref{twang.cascade}), as follows from
Lemma~\lemref{delta}.
Next we discuss two important phenomena that can occur
during a forward move.


\vspace{-0.5em}
\paragraph{Stretch Vertex Placement.} We note that the initial
stretch that starts a move might be ``undone''
by cycling of the cascade. This phenomenon is illustrated in
Fig.~\figref{twang.cascade}, where the initial \st inserts
 between  and  in the polygonal wrap
(Fig.~\figref{twang.cascade}b), but  ends up between  and 
in the final polygonization (Fig.~\figref{twang.cascade}f). Thus any
attempt to specifically place  in the polygonization sequence
between two particular vertices might be canceled by the subsequent
cascade. This phenomenon presents a challenge to reducing a polygon
to canonical form (discussed in Section~\secref{canonical}).

\vspace{-1.5em}
\begin{figure}[htbp]
\centering
\includegraphics[width=\linewidth]{PDFigures/twangcascade}
\vspace{-1.7em} \caption{Forward move illustrated. (a) Initial
polygon  (b) After \st (c) After \tw (d)
After \tw (e) After \tw (f) After
\tw.\vspace{-0.7em}} \figlab{twang.cascade}
\end{figure}


\hide{
\paragraph{Multiple Vertex Twangs.}
A point can twang more than once during the twang cascade, as
illustrated in Fig.~\figref{double.twang}. 
This possibility blocks one route toward
establishing a combinatorial upper bound on the number
of twangs in a cascade.
Note that in the example in Fig.~\figref{double.twang}g, there
is a choice about which vertex sequence to twang (either 
or ) and that only \tw() leads to  twanging twice.
We conjecture that 
a judicious choice of twang sequence
will lead to a linear bound on the number of
twangs in a cascade.


\vspace{-0.5em}
\begin{figure}[htbp]
\centering
\includegraphics[width=\linewidth]{PDFigures/doubletwang}
\vspace{-1.7em}\caption{Point  twangs twice: (a) Initial  (b)
After  \st (c--i) After \tw, 
(i)  in double contact a second time. } \figlab{double.twang}
\end{figure}
}

\vspace{-1.5em}
\section{Single Pocket Reduction Algorithm}
\seclab{single.pocket.reduction} Now that the basic properties of
the moves are established, we aim to show that our moves suffice to
connect any two polygonizations of a point set . The plan is to
reduce an arbitrary polygonization to the canonical polygonization.
En~route to explaining this reduction algorithm, we show how to
remove any particular pocket by redistributing its vertices to other
pockets. This method will be applied repeatedly in
Section~\secref{multiple.pocket.reduction} to move all pockets to
one particular pocket.

In this section we assume that  has two or more
pockets. 
We use  to refer to the closed region defined by
the convex hull of . For a fixed hull edge  that is the lid of a
pocket , the goal is to reduce  to  by redistributing the
vertices of  among the other pockets, using forward moves
only. This is accomplished by the
{\sc Single Pocket Reduction}~algorithm (described below), which
repeatedly picks a hull vertex  of  and attaches  to a pocket
other than ; see Fig.~\figref{single.pocket.reduction} for an
example run. 
Call a vertex  of  a \emph{true} corner if the two polygon edges
incident to  are
non-collinear. 


\begin{center}
\vspace{1mm} \fbox{
\begin{minipage}[h]{0.95\linewidth}
\centerline{{\sc Single Pocket Reduction}() Algorithm}
\vspace{1mm}{\hrule width\linewidth}\vspace{2mm} \small{\begin{tabbing}
.....\=..........\=...........................................................\kill
Loop for as long as the pocket  of  with lid  contains three or more vertices:\\
\> 1. Pick an edge-vertex pair  such that \\
\> \>  is an edge of  on  for some pocket \\
\> \>  is a non-lid true corner vertex on  that sees \\
\> 2.  \fm.
\end{tabbing}}
\end{minipage}
}\vspace{1mm}
\end{center}


We now establish that the {\sc Single Pocket
Reduction} algorithm terminates in a finite number of iterations. First we 
prove a
more general lemma
showing that a twang operation can potentially reduce, but never
expand, the hull of a pocket.

\begin{lemma}[Hull Nesting under Twangs]
Let  be a pocket of a polygonal wrap  and let vertex  satisfy the twang conditions.
Let  be the pocket with the
same lid as  after
\tw. Then .
\lemlab{twang.hull}
\end{lemma}


\begin{pf}
Let  be the vertex sequence involved in the twang operation.
Then \tw replaces the path  by .
If  does not belong to ,
then \tw does not affect  and therefore . So assume that
 belongs to . This implies that  is a vertex of .
Note that  is a non-lid vertex, since
. Then , and
the claim follows from the fact that .
\end{pf}

\vspace{-1.0em}
\begin{figure}[htbp]
\centering
\includegraphics[width=\linewidth]{PDFigures/singlepocketreduction}
\vspace{-2em}\caption{\small{{\sc Single Pocket Reduction}() 
illustrated: (a) Initial ; (b) After \st;
(c) After \tw; (d) After \tw; (e) After
\st; (f) After \tw; (g) After
\st+\tw.}}
\figlab{single.pocket.reduction}
\end{figure}




\vspace{-0.8em}
\begin{lemma}
The {\sc Single Pocket Reduction} algorithm terminates in  forward moves.
\lemlab{single.pocket.reduction}
\end{lemma}
\begin{pf}
Let  denote the set of vertices of  in . Thus . We show that  decreases by at least  in each loop
iteration, thus establishing the claim of the lemma.

First observe that the existence of an edge-vertex pair 
  selected in Step 1 is guaranteed by the fact that  has two or
  more pockets.
Step 2 of the {\sc Single Pocket Reduction} algorithm, which performs
a forward move to a different polygonization,
attempts to reduce  by vertex , thus decrementing . We now show
that this step is successful in that it
does not reattach  back to . Furthermore, we show that
 acquires no new vertices during this step. These together
show that  decreases by at least 1 in each loop iteration.

The first step of the forward move, \st, does not affect .
The second step, \tw, replaces
the path  by , thus eliminating  from
. Since  is a true corner vertex of , 
does not contain  at the end of this step. Let  be the pocket of 
with the same lid as  at the end of \twc. Since a hull vertex never twangs,
Lemma~\lemref{twang.hull} implies that
 is a subset of  and therefore  does
not increase during the twang cascade. Furthermore, since
 does not contain  after the first twang operation,
 must lie outside of  at the end of the twang
cascade. \end{pf}



\vspace{-0.4em}
\section{Multiple Pocket Reduction Algorithm}
\seclab{multiple.pocket.reduction} For a given hull edge , the
goal is to transform  to a polygon with a single pocket with lid
, using forward moves only. If  is an edge of the polygon, for
the purpose of the algorithm discussed here we treat  as a
(degenerate) target pocket . We assume that, in addition to
,~ has one or more other pockets, otherwise there is nothing to do.
Then we can use the {\sc Single Pocket Reduction} algorithm to
eliminate all pockets of  but , as described in the {\sc
Pocket Reduction} algorithm below.

\vspace{-0.2em}
\begin{center}
\vspace{1mm} \fbox{
\begin{minipage}[h]{0.95\linewidth}\centerline{{\sc Pocket Reduction} () Algorithm}
\vspace{1mm}{\hrule width\linewidth}\vspace{2mm} \small{\begin{tabbing}
.....\=.....\=...........................................................\kill
If  is an edge of , set , otherwise set  the pocket with lid  \\ \>(in either case, we treat  as a pocket). \\
For each pocket lid  \\
\> Call {\sc Single Pocket Reduction}()
\end{tabbing}}
\end{minipage}
}\vspace{1mm}
\end{center}




\vspace{-0.2em} Observe that the {\sc Pocket Reduction} algorithm
terminates in  forward moves: there are  pockets 
each of which gets reduced to its lid edge in  forward moves
(cf. Lemma~\lemref{single.pocket.reduction}).

Fig.~\figref{manytoone.example} illustrates the {\sc Pocket
Reduction} algorithm on a 17-vertex polygon with three pockets ,
 and , 
each of which has 3 non-lid vertices,
and target pocket  with lid edge . 
The algorithm first
calls {\sc Single Pocket Reduction}(), which transfers to
 all non-lid vertices of , so  ends up with 6 non-lid
vertices (this reduction is illustrated in detail in
Fig.~\figref{single.pocket.reduction}). Similarly, {\sc Single
Pocket Reduction}() transfers to  all non-lid vertices
of , so  ends up with 9 non-lid vertices, and finally {\sc
Single Pocket Reduction}() transfers all these vertices
to .

\begin{figure}[htbp]
\centering
\includegraphics[width=\linewidth]{PDFigures/multiplepocketreduction}
\vspace{-2em}\caption{(a-e) \small{{\sc Pocket Reduction}(): (a) Initial ; (b) After {\sc Single Pocket
Reduction}(); (c) After {\sc Single Pocket Reduction}(); (d) After {\sc Single Pocket Reduction}();
(e) After {\sc Canonical Polygonization}().}}
\figlab{manytoone.example}
\end{figure}



This example shows that the  bound on the number of forward
moves is tight: an -vertex polygon with a structure similar to
the one in Fig.~\figref{manytoone.example}a has 
pockets.
The number of forward moves performed
by the {\sc Pocket Reduction} algorithm is therefore , so we have the following lemma:
\begin{lemma}
The {\sc Pocket Reduction} algorithm employs  forward
moves. \lemlab{multiple.pocket.bound}
\end{lemma}

\vspace{-1.2em}
\section{Single Pocket to Canonical Polygonization}
\seclab{canonical} Let  denote an arbitrary one-pocket
polygonization of  with pocket lid .  Here we give an
algorithm to transform  into the canonical polygonization
. This, along with the algorithms discussed in
Sections~\secref{single.pocket.reduction}
and~\secref{multiple.pocket.reduction}, gives us a method to
transform any polygonization of  into the canonical form
. Our canonical polygonization algorithm incrementally arranges pocket
vertices in canonical order (cf. Section~\secref{Pockets}) along the
pocket boundary
by applying a series of forward moves to .

\begin{center}
\vspace{1mm} \fbox{
\begin{minipage}[h]{0.95\linewidth}
\centerline{\sc Canonical Polygonization() Algorithm}
\vspace{1mm}{\hrule width\linewidth}\vspace{2mm} {\small
\begin{tabbing}
.....\=.....\=..........................................................\kill
Let .
Let  be the canonical order of
the vertices of pocket .\\
For each \\
\> 1. Set  line passing through  and  \\
\> 2. Set  pocket edge , with  \\
\> 3. If  is not identical to , apply \fm().\end{tabbing}}
\end{minipage}
}\vspace{1mm}
\end{center}



We now show that the one-pocket polygonization resulting after the
-th iteration of the loop above has the points 
in canonical order along the pocket boundary. This, in turn, is
established by showing that the \fm\ in the -th iteration
involves only points in the set .
These observations are formalized in the following lemma, whose
proof appears in Appendix~1:

\begin{lemma}
The -th iteration of the {\sc Canonical Polygonization} loop
produces a polygonization of  with one pocket with lid  and
with vertices  consecutive along the pocket
boundary. \lemlab{canonical.first}
\end{lemma}

\begin{lemma}
The {\sc Canonical Polygonization} algorithm constructs  in
 forward moves. \lemlab{canonical.final}
\end{lemma}


\vspace{-1.5em}
\section{Reverse Moves}
\seclab{Reverse}
Connectivity of the space of polygonizations will follow by reducing
two given polygonizations  and  to a common canonical form
, and then reversing the moves from  to .
Although we could just define a reverse move as a
time-reversal of a forward move, it must be admitted that such
reverse moves are less natural than their forward counterparts.  So
we concentrate on establishing that reverse moves can be achieved by
a sequence of atomic stretches and twangs.

\vspace{-0.5em}
\paragraph{Reverse Stretch.} The reverse of \st may be achieved by a
sequence of one or more twangs, as illustrated in
Fig.~\figref{unstretchtwang}a. This result follows from the fact
that the ``funnel'' created by the stretch is empty, and so the
twangs reversing the stretch do not cascade.


\begin{figure}[htbp]
\centering
\includegraphics[width=\linewidth]{PDFigures/unstretchtwang}
\caption{Reverse atomic moves: (a) \st is reversed by
\tw, \tw, \tw, \tw. (b) \tw is
reversed by \st, \tw, \tw and \tw.}
\figlab{unstretchtwang}
\end{figure}





\vspace{-1.5em}
\paragraph{Reverse Twang.} An ``untwang'' can be accomplished by one stretch followed by a series
of twangs. Fig.~\figref{unstretchtwang}b illustrates how \tw
may be reversed by one \st, for any edge  of ,
followed by zero or more twangs. Observe that the initial stretch
in the reverse twang operation is not restricted to the reflex side of
the stretch vertex, as it is in a \fm. If  is
a hairpin vertex (i.e.,  and  coincide), we view  as an edge
of length zero and the reverse of \tw is simply \st.



\vspace{-0.5em}
\paragraph{Consequence.}
We have shown that the total effect of any forward move, consisting
of one stretch and a twang cascade, can be reversed by a sequence of
stretches and twangs. We call this sequence a \emph{reverse
move}. One way to view the consequence of the above two results can
be expressed via regular expressions. Let the symbols  and 
represent a \st\ and \tw\ respectively. Then a forward move can be
represented by the expression : a stretch followed by
one or more twangs. A reverse stretch,  can be achieved by one or more twangs:
. And
a reverse twang  can be achieved by . Thus the
reverse of the forward move  is  a sequence of stretches and twangs, at least one of each.


\vspace{-0.5em}
\section{Connectivity and Diameter of Polygonization Space}
\seclab{Connectivity}
We begin with a summary the algorithm which, given two polygonizations 
and  of a fixed point set, transforms  into  using
stretches and twangs only.

\vspace{-0.2em}
\begin{center}
\vspace{1mm} \fbox{ \small{
\begin{minipage}[h]{0.95\linewidth}
\centerline{{\sc Polygon Transformation}() Algorithm}
\vspace{1mm}{\hrule width\linewidth}\vspace{2mm} {\small
\begin{tabbing}
.....\=.....\=..........................................................\kill
1. Select an arbitrary edge  of . \\
2.  {\sc Pocket Reduction}();  atomic moves of [ {\sc Pocket Reduction}()].\\
3.  {\sc Canonical Polygonization}();  atomic moves of [{\sc Canonical Polygonization}().]\\
4. Reverse the order of the moves in  ( represents concatenation). \\
5. For each stretch  (twang ) in  in order,
execute reverse stretch (reverse twang  on .
\end{tabbing}}
\end{minipage}
}}\vspace{1mm}
\end{center}


\vspace{-0.2em} \noindent This algorithm, along with
Lemmas~\lemref{multiple.pocket.bound} and \lemref{canonical.final},
establishes our main theorem:

\vspace{-0.2em}
\begin{theorem}
The space of polygonizations of a fixed set of  points is connected via a
sequence of forward and reverse moves.
The diameter of the polygonization space is  moves.
\end{theorem}


\vspace{-1.2em}
\paragraph{Computational Complexity.} With appropriate preprocessing, each twang
operation can be carried out in  time (since  might hit  vertices).
So the running time of a single forward/reverse move is , where  is an
upper bound on the number of twangs in a move. 


\section{Random Polygons}
\seclab{Random.Polygons}
Let  be the graph whose nodes are polygonizations and whose
arcs are the moves defined in this paper.
We know that  can have an exponential number  of vertices.
We have established that it is connected,
and that it has diameter .
One way to generate ``random polygons,'' as mentioned in
Section~\secref{Introduction}, is to start with some polygonization
 of a random set of  points ,
and repeatedly select moves randomly.
An immediate question here is: How
many moves are needed to achieve adequate mixing, i.e.,
ergodicity? If we view the random moves as a random walk in ,
and ask for the 
expected time for a random walk to visit all 
vertices (the \emph{expected cover time})
of a connected graph ,
the answer is known: ~\cite{f-tupct-95}.
Unfortunately, 
the maximum number of polygonizations of a set of  points
has been shown to be ~\cite{gnt-lbncf-00},
and it seems likely that the expected number of polygonizations of a
random set of points is also exponential
(although
we have not found this established in the literature).
Thus, exponentially many moves
are needed to cover the polygonization graph in the worst case, and perhaps
in the expected case as well.
Although disappointing, this is inevitable given the size of ,
and mitigated somewhat by the relatively small diameter of .




We have implemented a version of random polygon generation. After
creating an initial polygonization, we move from polygonization to
polygonization via a sequence of forward moves, where additional
stretches are permitted in the cascade to simulate reverse moves.
Trials on random polygons suggest that the average length of a
cascade for polygons of up to  vertices is about , with
 the maximum cascade length observed in
trials of thousands of forward moves. 
Cascade length seems to be independent of .
Thus, even though 
we only have loose bounds on the length of a twang cascade,
for random point sets the mean length appears to be a constant less than .


\vspace{-0.8em}
\section{Open Problems}
\vspace{-0.2em} 
\seclab{Open.Problems} Our work leaves many interesting problems
open. 
The main unresolved question is establishing a tighter combinatorial
bound on the number of twangs  in a twang cascade and thereby
resolving the computational complexity of the polygon transformation
algorithm.  We have shown (in Appendices)
that  is  and ,
leaving a large gap to be closed.
Another related question asks to improve the efficiency of
the polygon transformation algorithm in terms of forward moves (the
lower bound in Lemma~\lemref{multiple.pocket.bound} is for our
particular algorithm, not all algorithms).

In Section~\secref{Connectivity} we established connectivity with
forward moves and their reverse, and although both moves are
composed of atomic stretches and twangs, the forward moves seem more
naturally determined. 
This suggests the question of
whether forward moves
suffice to ensure
connectivity.
It remains to be seen if the polygonization moves explored in this
paper will be effective tools for generating random polygons.
One possibility is to start from a doubled random noncrossing spanning
tree, which is a polygonal wrap.
Finally, we are extending our work to 3D 
polyhedralizations of a fixed 3D point set.




\begin{thebibliography}{CHUZ92}

\bibitem[AH96]{ah-hgrp-96}
T.~Auer and M.~Held.
\newblock Heuristics for the generation of random polygons.
\newblock In {\em Proc. 8th Canad. Conf. Comput. Geom.}, pages 38--43, 1996.

\bibitem[CHUZ92]{chuz-peps-92}
J.~Czyzowicz, F.~Hurtado, J.~Urrutia, and N.~Zaguia.
\newblock On polygons enclosing point sets.
\newblock In {\em Proc. 4th Canad. Conf. Comput. Geom.}, pages 132--136, 1992.

\bibitem[Fei95]{f-tupct-95}
U.~Feige.
\newblock A tight upper bound on the cover time for random walks on graphs.
\newblock {\em RSA: Random Structures \& Algorithms}, 6, 1995.

\bibitem[GNT00]{gnt-lbncf-00}
A.~Garc{\'i}a, M.~Noy, and J.~Tejel.
\newblock Lower bounds on the number of crossing-free subgraphs of .
\newblock {\em Comput. Geom. Theory Appl.}, 16(4):211--221, 2000.

\bibitem[vLS82]{ls-utstp-82}
J.~van Leeuwen and A.~A. Schoone.
\newblock Untangling a travelling salesman tour in the plane.
\newblock In J.~R. M{\"u}hlbacher, editor, {\em Proc. 7th Internat. Workshop
  Graph-Theoret. Concepts Comput. Sci.}, pages 87--98, M{\"u}nchen, 1982.
  Hanser.

\bibitem[ZSSM96]{zssm-grpgv-96}
C.~Zhu, G.~Sundaram, J.~Snoeyink, and J.~S.~B. Mitchell.
\newblock Generating random polygons with given vertices.
\newblock {\em Comput. Geom. Theory Appl.}, 6:277--290, 1996.

\end{thebibliography}

\normalsize

\newpage
\section*{Appendix~1: {\sc Canonical Polygonization}}
\begin{lemma}
The -th iteration of the {\sc Canonical Polygonization} loop
produces a polygonization of  with one pocket with lid  and
with vertices  consecutive along the pocket
boundary.
\end{lemma}
\begin{pf}
The proof is by induction.
The base case corresponds to  and is trivially true for the
case when . Otherwise,  sees  (since no edge
can block visibility from  to ) and therefore \st is possible. See
Fig.~\figref{canonical.proof.firstfig}a. Furthermore,  may not
twang a second time during the twang cascade of the forward move. This is because a second \tw may only be
triggered by the twang of a hull vertex, which can never occur (hull
vertices never twang). This implies that the \fm\ in Step 3 of the
first iteration creates a one-pocket polygonization in which 
and  are consecutive along the pocket boundary (see
Fig.~\figref{canonical.proof.firstfig}a,b). This completes the base
case.

\begin{figure}[htbp]
\centering
\begin{tabular}{c@{\hspace{0.01\linewidth}}c@{\hspace{0.01\linewidth}}c}
\includegraphics[width=0.32\linewidth]{PDFigures/canonicalproof1} &
\includegraphics[width=0.32\linewidth]{PDFigures/canonicalproof2} &
\includegraphics[width=0.32\linewidth]{PDFigures/canonicalproof3}
\\
(a) & (b) & (c)
\end{tabular}
\caption{{\sc Canonical Polygonization}: \st is always
possible. (a) Base case ():  sees  (b) After
iteration 1,  and  are consecutive along the pocket
boundary (c)  sees .} \figlab{canonical.proof.firstfig}
\end{figure}


To prove the inductive step, suppose that the lemma holds for
iterations .  Note that the existence of the edge
 selected in Step 2 of the algorithm follows immediately
from the fact that  are consecutive along
the pocket boundary (cf. inductive hypothesis).
If  is identical to , there is nothing to
prove. So assume that  and  are distinct. We
now show that  sees , so that \st is
possible.

First observe that the wedge bounded by  and  is
either degenerate (if  are collinear), or is
empty of any pocket points (since  follows  in the cw
sorted order). In the former case,  sees  and
. In the latter case,  must intersect 
(cf. Fig.~\figref{canonical.proof.firstfig}c). In either case, 
sees  and hence \st is possible. This
along with the induction hypothesis implies that at the end of
stretch operation, vertices  are consecutive
along the pocket boundary.

Next we show by contradiction that the twang cascade of the forward
move involves only vertices , so that
 remain consecutive along the pocket boundary.
Suppose the claim is false. For ease of presentation, define
rank() = . Let  be the first vertex with rank()  to get into double contact. Clearly  cannot coincide with ,
since  is a hull vertex and cannot get into double contact. Let
\tw be the twang that created the double contact at . Note
that at the time of \tw, vertices  are
consecutive along the pocket boundary, since none of these vertices
was in double contact prior to  (by choice of ) and therefore
could not have twanged. Since \tw creates the double contact
at ,  and lies on . We also have
that rank() , by our choice of .



Two cases are possible: (i)  lies strictly to the left of
, and (ii)  lies on  In either case, since
 and  lies on or to the right of , it
must be that rank(), rank() rank(). Suppose
w.l.o.g that rank()  rank(). Thus we have that rank()
 rank()  rank()  rank(). In other words
rank()  rank() , but since  and  is an edge of the pocket, it must be that
rank()  rank()  (since  are
consecutive along the pocket boundary). Thus we have reached a
contradiction. This completes the induction step.
\end{pf}

\section*{Appendix~2: Twang Cascade Lower Bound}
Fig.~\figref{double.twang} shows an example in which one point 
twangs twice in a cascade,
which gives a hint at the complex changes that can occur during
a cascade.
We will return to this example in Appendix~3 below.

\begin{figure}[htbp]
\centering
\includegraphics[width=\linewidth]{PDFigures/doubletwang}
\vspace{-1.7em}\caption{Point  twangs twice: (a) Initial  (b)
After  \st (c--i) After \tw, 
(i)  in double contact a second time, and can
twang a second time. } \figlab{double.twang}
\end{figure}


Figure~\figref{quadratic} displays an example in which 
 points each
twang  times in one cascade, providing an
 lower bound on the length of a cascade.
The cascade is initiated by \st followed by \tw.
From then on \tw twangs in a cycle.
Each such twang alters the path to ,
which wraps around .  In the next pass through the cycle,
\tw occurs.
This continues just twice in this figure,
but in general the number of cycles is the number of
 vertices inside each .
\begin{figure}[htbp]
\begin{minipage}[b]{0.47\linewidth}
\centering
\includegraphics[width=0.95\linewidth]{PDFigures/quadratic}
\caption{\st followed by \tw initiates a 
quadratic-length twang cascade.}
\figlab{quadratic}
\end{minipage}\hspace{0.06\linewidth}\begin{minipage}[b]{0.47\linewidth}
\centering
\includegraphics[width=0.95\linewidth]{PDFigures/pinwheel_quadratic}
\caption{It is possible for each triangle 
to enclose  vertices .
}
\figlab{pinwheel_quadratic}
\end{minipage}
\end{figure}
Figure~\figref{pinwheel_quadratic} shows that this number can be .
Here the  vertices are evenly spaced on a circle,
and .
As the length  grows longer, the fraction of points
inside  approaches .


\section*{Appendix~3: Twang Cascade Upper Bound}
Figs.~\figref{twang.cascade},~\figref{double.twang}, and~\figref{quadratic}
support an
intuition that a twang cascade simplifies pocket entanglements in
some sense.
We capture this notion combinatorially in the \emph{pocket hierarchy tree} 
 for a polygonization ,
a unique representation of the nesting of
pockets and subpockets of  in a tree.
Each pocket has a \emph{level} , with  itself level 0,
the pockets
described in Section~\secref{Pockets} as level- pockets,
and its subpockets at level~, and so on.
We will call all of these \emph{pockets}, and use
a superscript to distinguish the level  and subscripts
to distinguish among the pockets at the same level:
.

Each node of 
is the list of vertices in .
If  is convex, it has no children.
Otherwise, each edge  of 
which is not an edge of the polygonization  is
a pocket lid for the vertices of  from  to .
Fig.~\figref{subpockets} illustrates the hierarchy.
Note that every vertex  is on the hull of one
or more pockets of .
\begin{figure}[htbp]
\centering
\includegraphics[height=0.96\textheight]{PDFigures/subpockets}
\caption{Pocket hierarchy for cascade illustrated
in Fig.~\protect\figref{double.twang}.
Middle column displays the pocket tree
(each node showing:
points on hull, points interior,  pocket count), 
right column the pocket vector transposed.}
\figlab{subpockets}
\end{figure}


For each pocket 
,
we define a \emph{pocket count} 
to be the number of points on or in
.
For example, in 
Fig.~\figref{subpockets}c,
the pocket with lid  contains points
 and so has pocket count .
Note that we count points  and  only once even though
they are in double contact.
Finally, we define the \emph{pocket vector}  for
 to list the sum of all pocket counts for
all pockets at each level:
,
.
The pocket vectors in Fig.~\figref{subpockets} are:

\begin{center}
\begin{tabular}{|c|l|}
\hline
(c)  &    \\
(d)  &    \\
(e)  &    \\
(f)  &    \\
(g)  &    \\
(h)  &    \\
(i)  &    \\
\hline
\end{tabular}
\end{center}

Let  and  be two pocket vectors.
We define a lexicographic ordering relation on them:

iff
.
The steady odometer-like decrementing of the pocket vector
evident in the above example
is the sense in which a twang cascade simplifies pocket structure:

\begin{theorem}
A twang \tw always strictly reduces the pocket vector.
\end{theorem}
\begin{pf}
Assume  is the highest pocket in the hierarchy for which 
vertex  is on . 
We know at least one such pocket exists.   

\begin{description}
\item[Case 1:]
 is a lid vertex of pocket .

We show by contradiction that this case is impossible: Since  is a lid 
vertex of pocket , it must be a vertex on the hull of the parent of 
. But this contradicts our assumption that  is the highest 
pocket having  on its hull. (If  has no parent because it is a level-1 
pocket, then it must be on the hull of the entire polygon, which is a 
contradiction since such vertices are never twanged.)

For example, in Fig.~\figref{subpockets}c,
let . Then 
is a lid vertex of pocket  at level 3, 
but it is also a non-lid hull vertex of pocket  at level 2.

\item[Case 2:]
 is not a lid vertex of pocket .

This case implies that , , and  are all part of pocket 's 
boundary, as are edges  and . Because a twang is performed at , we 
know  is a corner point of hull(). Thus after the twang, ) 
loses this corner point and  goes down by one.

Now we show that the pocket counts for pockets at levels  do not change 
as a result of \tw, and in addition no other pocket besides  
at level  changes. First, observe that in addition to , the only 
pockets that may include edges  and  are 's ancestors and 
descendents in the hierarchy. Therefore, \tw affects only these 
pockets and no others.  Of these pockets, only changes in 's 
ancestors could increase the pocket vector. We show now that the counts for the 
ancestors do not changed. First observe that only the lid vertices of a 
pocket are hull vertices of its parent. Since  is not a lid vertex, 
\tw cannot change the hull of its parent, and similarly cannot 
change the hull of any of its ancestors. If the hulls do not change, then 
the point counts for the pockets do not change.
\end{description}
\end{pf}

\begin{corollary}
A twang cascade can have at most  steps.
\corlab{odometer}
\end{corollary}
\begin{pf}
Let  be the maximum length of a pocket vector:
.
In the worst case, a decrement of  by 1 is followed
by  each being (somehow) reset to  and counting down
through their full range.
If this happens for every decrement, then
the ``odometer'' counts through all  distinct possible pocket vectors.
\end{pf}

Note particularly the change in the pocket vector from 
Fig.~\figref{subpockets}c to~d: although  decrements
from  to ,  increases from  to 
(and, in addition,  grows in depth).
It is this phenomenon that makes establishing a better bound
via the pocket hierarchy problematical.


\end{document}
