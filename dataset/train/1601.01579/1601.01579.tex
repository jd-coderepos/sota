\documentclass{CSML}

\def\dOi{12(2:3)2016}
\lmcsheading {\dOi}
{1--28}
{}
{}
{Jan.~\phantom05, 2015}
{Apr.~25, 2016}
{}

\ACMCCS{[{\bf Theory of computation}]: Formal languages and automata
  theory---Automata over infinite objects; Logic---Logic and verification}
\keywords{data automata, counter automata, two-variable logic}

\usepackage[utf8]{inputenc}

\usepackage{amssymb} \usepackage{amsmath} \usepackage{amsthm}
\usepackage{mathbbol} \usepackage{stmaryrd}  

\usepackage{hyperref}
\usepackage{xspace}


\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{trees}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{matrix}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{myexample}{Example}
\newtheorem{remark}{Remark}



\newcommand{\remarque}[1]{\marginpar{\scriptsize #1}}
\newcommand\remove[1]{}
\newcommand\luc[1]{\marginpar{\tiny{\bf Luc}: #1}}
\newcommand\florent[1]{\marginpar{\tiny{\bf Fl}: #1}}
\newcommand\todo[1]{\medskip\noindent\framebox{\framebox{\parbox{\textwidth}{{\bf TODO}: #1}}}\medskip}



\usepackage{ifthen}

\newcommand{\cqfd}{\hfill}
\newcommand{\findef}{\hfill }
\newcommand{\finex}{\hfill}

\newcommand\ra{\ensuremath{\rightarrow}}

\newcommand\vass{\textup{VASS}\xspace}
\newcommand\bvass{\textup{BVASS}\xspace}
\newcommand\ebvass{\textup{EBVASS}\xspace}

\newcommand\dataeq{\ensuremath{\sim}}
\newcommand\neighbor{\ensuremath{\mathord{+}1}}
\newcommand\descendant{\ensuremath{\mathord{<}}}
\newcommand\fo{\mathsf{FO}\xspace}   \newcommand\mso{\mathsf{MSO}\xspace} \newcommand\emso{\mathsf{E}\mso}     \newcommand\fotwo{\ensuremath{\fo^2(\descendant,\neighbor,\mathord{\sim})}\xspace}
\newcommand\fotwoplus{\ensuremath{\fo^2(\neighbor,\mathord{\sim})}\xspace}
\newcommand\msotwo{\ensuremath{\mso^2(\descendant,\neighbor,\mathord{\sim})}\xspace}
\newcommand\emsotwo{\ensuremath{\emso^2(\descendant,\neighbor,\mathord{\sim})}\xspace}
\newcommand\xpath{\textup{XPath}\xspace}

\newcommand\dad{\textup{DTA}\xspace}
\newcommand\wdad{\textup{DTA}\xspace}
\newcommand\fda{\textup{FDA}\xspace}

\newcommand\A{\ensuremath{\mathbb{A}}\xspace}
\newcommand\B{\mathbb{B}}
\newcommand\D{\mathbb{D}}
\newcommand\E{\mathbb{E}}
\newcommand\F{\mathbb{F}}
\newcommand\N{\ensuremath{\mathbb{N}}\xspace}


\newcommand\Aa{\mathcal{A}}
\newcommand\Ba{\mathcal{B}}
\newcommand\Ca{\mathcal{C}}
\newcommand\Da{\mathcal{D}}
\newcommand\Ea{\mathcal{E}}

\newcommand\Co{\mathsf{C}}
\newcommand\merc[3]{\mathsf{C}_{#1}\mathpunct{\circleddash}\mathsf{C}_{#2}\to\mathsf{C}_{#3}}
\newcommand\meru[3]{\ifthenelse{\equal{#1}{}}{}{\mathsf{C}_{#1}}\mathpunct{\circleddash}\ifthenelse{\equal{#2}{}}{}{\mathsf{C}_{#2}}\to_1\mathsf{C}_{#3}}


\newcommand\Trees{\mathsf{Trees}}
\newcommand\Forests{\mathsf{Forests}}
\newcommand\pos{\textup{POS}}
\newcommand\tpos{\textup{pos}}
\newcommand\talph{\textup{alph}}

\newcommand\tree{\boldsymbol{t}}
\newcommand\atree{\boldsymbol{a}}
\newcommand\btree{\boldsymbol{b}}
\newcommand\dtree{\boldsymbol{d}}
\newcommand\etree{\boldsymbol{e}}
\newcommand\set[1]{\ensuremath{\{#1\}}}
\newcommand{\proj}{\mathpunct{\restriction}}
\newcommand{\nf}[1][\#]{\mathord{\downarrow_{#1}}}
\newcommand\stree{\boldsymbol{s}}
\newcommand\wtree{\boldsymbol{w}}





\newcommand\rootpos{\mathsf{root}}
\newcommand\leaf{\mathsf{leaf}}
\newcommand\first{\mathsf{first}}
\newcommand\last{\mathsf{last}}
\newcommand\close{\mathsf{close}}
\newcommand\far{\mathsf{far}}
\newcommand\fcns{\ensuremath{\mathit{fcns}}\xspace}
\newcommand\fcnsd{\mathit{fcnsd}}
\newcommand\rootstate{-state\xspace}


\newcommand\EE{\mathsf{E}}
\newcommand\NS{\EE_{\rightarrow}}
\newcommand\FS{\EE_{\Rightarrow}}
\newcommand\PC{\EE_{\downarrow}}
\newcommand\AD{\EE_{\Downarrow}}
\newcommand\SAD{\EE_{\downdownarrows}}
\newcommand\SFS{\EE_{\rightrightarrows}}


\renewcommand\parallel{\mathbin{\!<\mkern-12mu>\!}}




\def\frew#1#2#3#4#5#6#7#8{
\setbox0=\hbox{}\setbox1=\hbox{}\ifdim \wd0>\wd1 \rlap{\rlap{\hbox to \wd0{#5}}{\hbox to\wd0{\hfil\lower #3\box1\relax\hfil}}}{\raise #4\box0}\else \rlap{\rlap{\hbox to \wd1{#5}}{\hbox to\wd1{\hfil\raise #4\box0\relax\hfil}}}{\lower #3\box1}\fi
}

\def\fstep#1#2#3#4#5{\mathchoice{\frew{#1}{#2}{1.10ex}{1.20ex}{#5}{\scriptstyle}{#3}{#4}}{\frew{#1}{#2}{1.02ex}{1.20ex}{#5}{\scriptstyle}{#3}{#4}}{\frew{#1}{#2}{0.51ex}{0.82ex}{#5}{\scriptscriptstyle}{#3}{#4}}{\frew{#1}{#2}{0.51ex}{0.69ex}{#5}{\scriptscriptstyle}{#3}{#4}}}

\newcommand{\lrstep}[2]{\mathrel{\fstep{#1}{#2}{\;\>}{\>\>\;}{\rightarrowfill}}}
\newcommand{\rlstep}[2]{\mathrel{\fstep{#1}{#2}{\;\>\>}{\;\>}{\leftarrowfill}}}
\newcommand{\eqstep}[2]{\mathrel{\fstep{#1}{#2}{\;\>}{\>\;}{\rlap{\leftarrowfill}{\rightarrowfill}}}}




 \newcommand{\toto}{\longleftrightarrow}







\title[\fotwo on data trees]{\fotwo on data trees, data tree automata and branching vector addition systems}
\author[F.~Jacquemard]{Florent Jacquemard}
\author[L.~Segoufin]{Luc Segoufin}
\author{J\'er\'emie Dimino}
\address{INRIA and ENS Cachan}
\email{\{florent.jacquemard, luc.segoufin\}@inria.fr}




\begin{document}

\begin{abstract}
  A data tree is an unranked ordered tree where each node carries a label from
  a finite alphabet and a datum from some infinite domain.  We consider the two
  variable first order logic \fotwo over data trees.  Here  refers to the
  child and the next sibling relations while  refers to the descendant and
  following sibling relations.  Moreover,~ is a binary predicate testing
  data equality.  We exhibit an automata model, denoted \dad, that is more
  expressive than \fotwo but such that emptiness of \dad and satisfiability of
  \fotwo are inter-reducible.  This is proved via a model of counter tree
  automata, denoted \ebvass, that extends Branching Vector Addition Systems
  with States (\bvass) with extra features for merging counters. We show that,
  as decision problems, reachability for \ebvass, satisfiability of \fotwo and
  emptiness of \dad are equivalent.
\end{abstract}

\maketitle

\section*{Introduction}

A data tree is an unranked ordered tree where each node carries a label from a
finite alphabet and a datum from some infinite domain. Together with the
special case of data words, they have been considered in the realm of program
verification, as they are suitable to model the behavior of concurrent,
communicating or timed systems, where data can represent \textit{e.g.}, process
identifiers or time stamps~\cite{Alur12AAA,BCGK12fossacs,Bouyer02ipl}.  Data
trees are also a convenient model for XML documents~\cite{BojanczykMSS09jacm},
where data represent attribute values or text contents.  Therefore finding
decidable logics for this model is a central problem as it has applications in
most reasoning tasks in databases and in verification.

Several logical formalisms and models of automata over data trees have been
proposed. Many of them were introduced in relation to \xpath, the standard
formalism to express properties of XML documents. Although satisfiability of
\xpath in the presence of data values is undecidable, automata models were
introduced for showing decidability of several 
data-aware fragments~\cite{FS11,BojanczykMSS09jacm,Fig10,F09,JL08}.

As advocated in~\cite{BojanczykMSS09jacm}, the logic 
\fotwo can be seen as a relevant fragment of \xpath. 
Here \fotwo refers to the two-variable fragment of first
order logic over unranked ordered data trees, with predicates for the child and the next
sibling relations (), predicates for the descendant and following sibling
relations () and a predicate for testing data equality between two nodes ().
Over data words, \fotwo was shown to be decidable by a reduction to Petri Nets or,
equivalently, Vector Addition Systems with States (\vass)~\cite{BDMSS11}.  
It is also shown in~\cite{BojanczykMSS09jacm} that reachability for
Branching Vector Addition Systems with States, \bvass, 
reduces to satisfiability of \fotwo over data trees.  
The model of \bvass,  extends \vass with a natural branching feature for running
on trees, see~\cite{acl10} for a survey of the various formalisms equivalent to
\bvass.  As the reachability of \bvass is a long standing open problem, showing
decidability of finite satisfiability for \fotwo seems unlikely in the near future.

This paper is a continuation of the work of~\cite{BDMSS11,BojanczykMSS09jacm}.
We introduce a model of counter automata, denoted \ebvass, and show that
satisfiability of \fotwo is inter-reducible to reachability in \ebvass. 
This model extends \bvass by allowing new features for merging counters.  
In a \bvass the value of a counter at a node  in a binary tree
is the sum of the values of that counter at the children of , 
plus or minus some constant specified by the transition relation. 
In \ebvass constraints can be added modifying this behavior. In particular
(see Section \ref{sec-dad-counter} for a more precise definition) it can enforce the
following at node : 
one of the counters of its left child and one
of the counters of its right child are decreased by the same arbitrary number , 
then the sum is performed as for \bvass, and finally, 
one of the resulting counters is increased by .

The reduction from \fotwo to \ebvass goes via a new
model of data tree automata, denoted \dad. 
Our first result (Section~\ref{sec-fotwo-dad}) shows that languages of data trees 
definable in \fotwo are also recognizable by \dad.  
Moreover the construction of the automaton from the formula is effective. 
Our automata model is a non-trivial extension
from data words to data trees of the Data Automata (DA) model
of~\cite{BDMSS11}, chosen with care in order to be powerful enough to capture the logic 
but also not too powerful in order to match its computational power. 
The obvious extensions of DA to data trees are either too weak to capture \fotwo 
or too expressive and undecidable (see Proposition~\ref{prop-undecid}).
Here we consider the strongest of these extensions, called , 
which is undecidable,
and restrict it into a model called \dad
with an associated emptiness problem is equivalent to satisfiability of \fotwo.

Our second result (Section~\ref{sec-dad-counter}) shows that the emptiness
problem for \dad reduces to the reachability problem for \ebvass.  Finally we
show in Section~\ref{sec-counter-fotwo} that the latter problem can be reduced
to the satisfiability of \fotwo, closing the loop.  Altogether, this implies
that showing (un)decidability of any of these problems would show
(un)decidability of the three of them.
Although this question of (un)decidability remains open,
the equivalence shown in this paper between the decidability of these three problems,
the definition of the intermediate model \dad and the techniques used for proving
the interreductions provides
a better understanding of the three problems, 
and in particular of the emptiness of the branching vector addition systems with states.

{\bf Related work.}
There are many other works introducing automata or logical formalism for data
words or data trees. Some of them are shown to be decidable using counter automata,
see for instance~\cite{DL-tocl08,JL08}. The link between counter automata and
data automata is not surprising as the latter
only compare data values via equality. 
Hence they are invariant under permutation of the data domain and therefore, 
often, it is enough
to count the number of data values satisfying some properties instead of
knowing their precise values.



\section{Preliminaries}\label{sec:prelim}

In this paper  or  denote finite alphabets while  denotes an infinite
data domain. We use  or  when we do not care whether the alphabet is
finite or not. We denote by  the extension of an alphabet  with a new symbol 
that does not occur in .


\paragraph{Unranked ordered data forests.}
We work with finite unranked ordered trees and forests over an alphabet~,
defined inductively as follows: for any ,  is a tree. If
 is a finite non-empty sequence of trees then 
 is a forest. If  is a forest and , then
 is a tree. The set of trees and forests over  are respectively
denoted  and .  A tree is called unary
(resp. binary) when every node has at most one (resp. two) children.
We use standard terminology for trees and forests defining nodes, roots,
leaves, parents, children, ancestors, descendants, following 
and preceding siblings.

Given a forest , and a node  of , we denote
by  the label of  in .

We say that two forests  
and  
\emph{have the same domain} if there is a bijection from the
nodes of  to the nodes of  
that respects the parent and the next-sibling relations. 
In this case we identify the nodes of  with
the nodes of  and the difference between  and  lies
only in the label associated to each node. 
Given two forests , 
 having the same domain, 
we define  
as the forest over the same domain 
and such that for all nodes , 
.

The set of \emph{data forests} over a finite alphabet  
and an infinite data domain   is defined as . 
Note that every  
can be decomposed into  
and  such that .


\paragraph{Logics on data forests.}
A data forest of  can be seen as a relational model for
first order logic.  The domain of the model is the set of nodes in the
forest.  There is a unary relation  for all  containing
the nodes of label . There is a binary relation  containing all
pairs of nodes carrying the same data value of , 
and binary relations  ( is the sibling immediately next to ),
 ( is the parent of ), and ,  which are the non
reflexive transitive closures respectively of  and , minus
respectively  and  (\textit{i.e.}, they define two or more navigation steps).
The reason for this non-standard definition of  and  is that it
will be convenient that equality, , ,  and  are disjoint
binary relations. We will often make use of the macro, , and say
that  and  are \emph{incomparable}, when none of , ,
,  and  holds.


Let \fotwo be the set of first order sentences with two variables built on top
of the above predicates. Typical examples of properties definable in \fotwo are
key constraints (all nodes of label  have different data values), , and downward inclusion
constraints (every node  of label  has a node  of label  in its
subtree with the same data value), 
.

We also consider the extension \emsotwo of \fotwo with existentially quantified
monadic second order variables.  Every formula of \emsotwo has the form
 where  is a \fotwo formula called
the \emph{core}, involving the variables  as unary
predicates.  The extension to full monadic second order logic is denoted
.

We write  for the set of formulas not using the  predicates.
These formulas are ignoring the data values, \textit{i.e.}, 
they are classical monadic second-order formulas over forests.



\paragraph{Automata models for forests.} 
We will informally refer to automata and transducers 
for forests and unranked trees over a finite alphabet. 
The particular choice of a model of automata is not relevant here 
and we refer to~\cite[Chapters~1,6,8]{tata} for a detailed description. 
A set of forests accepted by an automaton is called a \emph{regular language} 
and regular languages are exactly those definable in .  


\paragraph{Automata models for data forests.}  
Given a data forest  
and a data value , the \emph{class forest}\label{def:class-forest} 
 of  associated to the datum  
is the forest of  having the same domain as 
and such that  if  and  otherwise.

\begin{figure}[h!]
\hspace{-8.7 cm}\begin{tikzpicture}
  [level distance=7mm,
   level 1/.style={sibling distance=28mm},
   level 2/.style={sibling distance=9mm}]
\node {}
 child { node {}
         child { node {} }
         child { node {} }
         child { node {} }
       }
 child { node {}
         child { node {} }
         child { node {} }
         child { node {} }
       };
\hspace{6cm}
\node {}  [level distance=7mm,
   level 1/.style={sibling distance=15mm},
   level 2/.style={sibling distance=5mm}]
 child { node {}
         child { node {} }
         child { node {} }
         child { node {} }
       }
 child { node {}
         child { node {} }
         child { node {} }
         child { node {} }
       };
\hspace{4cm}
\node {}[level distance=7mm,
   level 1/.style={sibling distance=15mm},
   level 2/.style={sibling distance=5mm}]
 child { node {}
         child { node {} }
         child { node {} }
         child { node {} }
       }
 child { node {}
         child { node {} }
         child { node {} }
         child { node {} }
       };
\end{tikzpicture}
  \caption{A forest  followed by its class forests
     and }
  \label{fig-class-forest}
\end{figure}

\noindent We now define two models of automata over data trees. The first and most general
one is a straightforward generalization to forests of the automata model over
data words of~\cite{BDMSS11}. The second one adds a restriction in order to
avoid undecidability.

\paragraph{General Data Forest Automata model: \wdad.}  
A \wdad is a pair  where  is a non-deterministic
letter-to-letter transducer taking as input a forest in  and
returning a forest in  with the same domain, while  is a
forest automaton taking as input a forest in . Intuitively a
\wdad works as follows on a forest : first the
transducer  relabels the nodes of  into  and the forest
automaton  has to accept all class forests of~. 

More formally a data forest  
is accepted by  iff
\begin{enumerate}
\item there exists  such that
 is a possible output of  on  and,
\item for all , 
      the class forest  is accepted by .
\end{enumerate}

\noindent
Over data words this model was shown to be decidable~\cite{BDMSS11}. 
Unfortunately it is undecidable over data trees.
\begin{proposition}\label{prop-undecid}
Emptiness of \wdad is undecidable.
\end{proposition}
\begin{proof}
We show that \wdad can simulate the Class Automata
of~\cite{BojanczykLasota10lics}.  This latter model has an undecidable
emptiness problem, already when restricted to data words, 
\textit{i.e.}, forests of the form .  
It captures indeed the class of languages of words - without data - recognized by counter automata.
Like Data Automata, Class Automata are defined as pairs made of one transducer~ and one word automaton~.
However, 
the  part in the Class Automata model has access to the label of the nodes that are not in the
class, while it sees only  in the Data Automata case. 
This extra power implies undecidability.


\newcommand\classproj{\llbracket d \rrbracket}
\newcommand\classtreeprime{\tree'\classproj}
\newcommand\classword{\wtree\classproj}

We assume two finite alphabets  and , writing the latter
\textit{in extenso} as .  
A \emph{class automaton} over
 is a pair  where  is a non-deterministic
letter-to-letter word transducer from  into  and  is a word
automaton taking as input words over the alphabet .
In order to define the acceptance of data words by class automata, 
we shall use a notion of class word associated to a data word 
and a value , denoted , defined as 
the word having the same domain as 
and such that, for every node  of , 
 if 
and 
 otherwise.
A data word  is accepted by  iff
\begin{enumerate} 
\item there exists a word  over  such that
 is a possible output of  on  and,
\item for all , the class word  
is accepted by .
\end{enumerate}

Given a class automaton  over , we construct a \wdad  such that 
accepts a data word iff  accepts a data tree.
The idea of the reduction is that we replace each letter  by a tree of
depth . Hence, even if  is replaced by  during the run of  (conversion to class word),
this label can still be recovered.

Let  be a new alphabet containing the two symbols  and . 
For any symbol  and , let  be the unary data tree of depth 
defined recursively by:  and .
We associate to a data word  a data forest 
 defined by 
.

From the word automaton  we can construct a forest automaton  accepting exactly the set of
class forests  such that  is accepted by
, for all . 

The best way to see this is to use  logic. The language recognized
by  can be defined by a formula  of . The formula
corresponding to  is constructed by replacing in  each atom of
the form  by  and each atom of the form  by a formula testing that  has label  and that the
subtree rooted at  has depth .

\medskip

From there it is now easy to construct an  such that the \wdad 
accepts a data forest iff the class automaton  accepts a data word.
\end{proof}

\paragraph{Restricted Data Forest Automata model: \dad.}  
The second data tree automata model we consider is defined as \wdad with a
restriction on . The restriction makes sure that  ignores repeated
and contiguous occurrences of  symbols.  This ensures that for each class
forest , not only the automata cannot see the label of a node whose
data value is not , but also can not see the shape of subtrees of nodes
whose data value differs from . In particular it can no longer count the number
of  symbols in a subtree and the undecidability proof of
Proposition~\ref{prop-undecid} no longer works.





A set  is called -\emph{stuttering} 
iff it is closed  
under the rules depicted in Figure~\ref{fig-rules}. 
Intuitively these rules should be understood as follows: 
if a subforest is matched by a left-hand side of a rule
(when the variables  and  are replaced by (possibly empty) forests), 
then replacing this subforest by the corresponding right-hand side 
(with the same variable replacement)  
yields a forest also in ,
and the other way round. 

\begin{figure}[h!]
\footnotesize

\caption{Closure rules for -stuttering sets.  represents an arbitrary forest.}
\label{fig-rules}
\end{figure}

For instance if  is -stuttering and contains the trees  and
 of Figure~\ref{fig-class-forest}, then it should also contain the
trees in Figure~\ref{fig-class-closure}.

\begin{figure}

\caption{Closure of  of Figure~\ref{fig-class-forest}.}
\label{fig-class-closure}
\end{figure}


\medskip Typical examples of -stuttering languages are those testing that
no two nodes of label  occur in  (key constraint) or that each
node of label  has a descendant of label  in  (inclusion
constraint).  Other typical -stuttering languages are those defined by
formulas of the form . Indeed the  -stuttering rules do not affect the
relationship between pairs of nodes not labeled by~.

Typical examples of languages that are not -stuttering are
those counting the number of nodes of label~.  
Note that -stuttering
languages are closed under union and intersection. 




\medskip


We define \dad as those \wdad  such that the language recognized by  is -stuttering.
\medskip

We conclude this section with the following simple lemma whose proof is a
straightforward Cartesian product construction. We use the term \emph{letter
  projection} for a relabeling function defined as , where 
and  are alphabets.


\begin{lemma} \label{lem:conjunction-disjunction}
The class of \dad languages is closed 
under union, intersection and letter projection.
\end{lemma}

\section{From \texorpdfstring{\fotwo}{FO2} to \texorpdfstring{\dad}{DTA}}
\label{sec-fotwo-dad}

In this section we show the following result.
\begin{theorem}\label{th-fotwodad}
Given a formula  in \fotwo, there exists a \dad,
effectively computable from ,
accepting exactly the set of data forests satisfying~.
\end{theorem}

The proof works in two steps. 
In the first step we provide a normal form for sentences of \fotwo 
that is essentially an \emsotwo formula 
whose core is a conjunction of simple formula of \fotwo. 
In a second step, 
we show that each of the conjunct can be translated into a \dad, 
and we conclude using
composition of these automata by intersection, 
see Lemma~\ref{lem:conjunction-disjunction}.

\subsection{Intermediate Normal Form} \label{app:normal-form}
We show first that every \fotwo formula  can be transformed into an equivalent \emsotwo formula
in \emph{intermediate normal form}:

where each  has one of the following forms:

where each of  and  is a \emph{type}, 
that is, a conjunction of unary predicates or their negation 
(these unary predicates are either from \A or from , 
\textit{i.e.}, introduced by the existentially quantified variables),
 is either  or ,
 is one of 
      ,  
      or ,
and
 is one of
, 
, 
, 
,
,
, 
, 
,
,
 or .

This normal form is obtained by simple syntactical manipulation 
similar to the one given in~\cite{BDMSS11} for the data words case, and detailed below. 

\paragraph{\bf Scott normal form.}
We first transform the formula  into Scott Normal Form
obtaining an \emsotwo formula of the form:

where  and every  are quantifier free, 
and  are new unary predicates (called monadic).
This transformation is standard: 
a new unary predicate  is introduced
for each subformula  with one free variable for marking the
nodes where the subformula holds. The subformula  is then
replaced by  and a conjunct 
 is added. 
This yields a formula in the desired normal form.

\paragraph{\bf From Scott to intermediate normal form.}
We show next that every conjunct of the core of the formula  in Scott Normal Form
can be replaced by an equivalent conjunction of formulas of the
form~\eqref{eq:inf-fafa} or~\eqref{eq:inf-faex}, possibly by adding 
new quantifications with unary predicates upfront.


\paragraph{\bf Case .}
Recall that with our definition, the binary relations , ,
, ,  and  are pairwise disjoint.
Hence we can rewrite  into an equivalent \fotwo formula 
in the following form,

where every subformula  is quantifier free and only involves the predicate
 together with unary predicates. 
They can be obtained from  via conjunctive normal form and De Morgan's law.
The resulting formula is equivalent to the conjunction

where  is a new predicate denoting the leaves of the forest and
 is also a new predicate denoting nodes having no right sibling.  The
predicate  is specified by the following formulas, that have the desired form. 

Similar formulas specify the predicate .

\noindent
The first three conjuncts, with quantifier prefix , will be
treated later when dealing with the second case.

\noindent
For the next three conjuncts, putting , , 
 in disjunctive normal form 
(with an exponential blowup), 
we rewrite , ,
 as a conjunction of formulas of the form , 
where 
, , and  are as in (\ref{eq:inf-fafa}).
By distribution of conjunction over implication, and by contraposition, 
we obtain for the 3 cases an equivalent conjunction of formulas of the
following form (matching the desired form~\eqref{eq:inf-fafa}) 



\paragraph{\bf Case .}
We first transform  (with an exponential blowup) 
into an equivalent disjunction of the form

where , ,  and 
are as in (\ref{eq:inf-faex}).
Next, in order to eliminate the disjunctions, we add a new
monadic second-order variables , that we existentially quantify
upfront of the global formula, and transform  into the conjunction

The first conjuncts express that 
if  holds, then there exists a node  
such that the corresponding conjunct of  holds, 
and the last conjunct expresses that 
for all node , at least one of the  must hold and can be
rewritten as . Now all the conjuncts are as in \eqref{eq:inf-faex} and
we are done.













\subsection{Case analysis for constructing \texorpdfstring{\dad}{DTA} from intermediate normal forms} We now show how to transform a formula in intermediate normal form into a \dad. 
Let \A be the initial alphabet and let  be the new alphabet formed
by combining letters of \A with the newly quantified unary predicates .  
By closure of \dad under intersection and letter projection (Lemma~\ref{lem:conjunction-disjunction}), 
it is enough to construct a \dad automaton for each simple formula of the form~\eqref{eq:inf-fafa}
or~\eqref{eq:inf-faex}, accepting the data forests in  satisfying the formula.

We do a case analysis depending on the atoms involved in the formula of the
form~\eqref{eq:inf-fafa} or~\eqref{eq:inf-faex}. 
For each case we construct a \dad  
recognizing the set of data forests satisfying the formula.  
The construction borrows several ideas from the data word case~\cite{BDMSS11}, but
some extra work is needed as the tree structure is more complicated.
In the discussion below, a node whose label satisfies the type  will
be called an \emph{-node}.
Many of the cases build on generic constructions that we described 
in the following remark.
\begin{remark}\label{remark-color-class}
  A \dad  can be used to distinguish one specific data value, by recoloring, with , all the nodes carrying the
  data value, and checking, with , the correctness of the recoloring.  We
  will then say that  \emph{marks a data value using the new color
    }.  This can be done as follows.  The transducer  marks
  (i.e. relabel the node by adding to its current label an extra color) a node  with
  this data value with a specific new color .  At the same time it guesses
  all the nodes sharing the same data value as  and marks each of them with
  a new color .  Then, the forest automaton  checks, for every data
  value, that either none of the nodes are marked with  or , or that all
  nodes not labeled with  are marked with  or  and that  occurs
  exactly once in the same class forest.  Note that this defines a
  -stuttering language.  It is now clear that for the run to be accepting,
   must color exactly one data value and that all the nodes carrying this
  data value must be marked with  or .  The transducer  can then
  build on this fact for checking other properties.
\end{remark}

\noindent
A generic example of the usefulness of this remark is given below.
Once an arbitrary data value is marked with a color , 
then a property of the form 
 
is a conjunction of 
 
with 
. 
 The first part, 
 
is now a regular property and can therefore be tested by . 
Hence it is enough to consider the case where  does not carry the marked data value. 
The same reasoning holds if two data values are marked or if the formula starts with a 
 quantification. 
We will use this fact implicitly in the case analysis below.

Given a data forest, a \emph{vertical path} is a set of nodes containing exactly
one leaf and all its ancestors and nothing else.  A \emph{horizontal path} is a
set of nodes containing one node together with all its siblings and nothing else.



\medskip\noindent
We start with formulas of the form~\eqref{eq:inf-fafa}. 

\paragraph{\bf Case 1:}
,
where  is as in (\ref{eq:inf-fafa}).
These formulas express a property of pairs of nodes with the same data value.
We have seen that those are -stuttering languages that can be tested
by the forest automaton  solely (\textit{i.e.}, by a \dad with  doing
nothing).


\paragraph{\bf Case 2:}
.
This formula expresses that a data forest cannot contain 
an -node having a -node with a different data value
as a sibling to its right, except if it is the next-sibling.
Let  be an horizontal path in a data forest  containing at least one
-node, and let  be the leftmost -node in . 
Let  be the data value of . 
Consider an -node  and a -node  that make the formula
false within , in particular we have . Then, if  has a data
value different from  we already have  and the formula is
also false for the pair .
Hence the validity of the formula within  can be tested over pairs  such that
either  or  has data value .

\noindent
With this discussion in mind we construct  as follows. In every horizontal path 
containing one -node, the transducer  identify the leftmost
occurrence  of an -node in , and marks it with a new color , 
and marks all the nodes of  with the same data value as  with a color .  
As in Remark~\ref{remark-color-class}, the forest automaton  checks that the
guesses are correct, \textit{i.e.} it accepts only forests in which every horizontal
path  satisfy one of the following conditions: 
 contains one occurrence of the color  
and all other nodes of  not labeled with  are marked with , 
or  contains none of the colors  and  at all. 
All these properties define regular and -stuttering languages, 
and hence can be checked by a forest automaton .

Assuming this, the transducer  rejects if there are some unmarked
-nodes occurring as a right sibling (except for the next-sibling) of a
marked -node or there is an unmarked -node as
left sibling, except for the previous sibling, of a marked -node.  
As explained in Remark~\ref{remark-color-class}, this is a regular property.


\paragraph{\bf Case 3:}
.
The property expressed by this formula is similar to the previous case,
replacing the right sibling relationship with the descendant relationship.

Let  be a vertical path in a data forest  containing at least one
-node, and let  be the -node in  the closest to
the root. Let  be the data value of .
Consider an -node  and a -node  that make the formula
false within , in particular we have . Then, if  has a data
value different from  we already have  and the formula is
also false for the pair .
Hence the validity of the formula within  can be tested over pairs  such that
either  or  has data value .

\noindent
The construction of  is similar to the previous case, except that different
vertical paths may share some nodes.
The transducer  marks all the -nodes 
that have no -node as ancestor, with a new color . 
Then, for every node  marked ,  guesses all the
nodes inside the subtree rooted at  having the same data value as
 and mark them with a new color .
As in Remark~\ref{remark-color-class}, the forest automaton  checks that the guesses of
colors are correct for each vertical path (see also the previous case).

Assuming this, the transducer  rejects if there are an unmarked
-node that is a descendant, but not a child, of a
marked -node or there is an unmarked -node as
an ancestor, except for the parent, of a marked -node.  
This is a regular property that can be checked by  in conjunction with the marking,
following the principles of Remark~\ref{remark-color-class}. 

\paragraph{\bf Case 4:}
.
The formula expresses that every two nodes of type respectively  and
 and with different data values cannot be incomparable.
Recall that two nodes are incomparable if they are not ancestors and not siblings.

\paragraph{\bf Subcase 4.1:} There exist two -nodes that are incomparable. 

Let  and  be two incomparable -nodes and let  
be their least common ancestor
(see Figure~\ref{fig:case41a}).
\begin{figure}

\caption{Subcase 4.1 in the proof of Theorem~\ref{th-fotwodad}.}
\label{fig:case41a}
\end{figure}
 We can choose  and  such that none of the
-nodes are incomparable with  or sibling of~, because if this was not
the case then there is an -node  incomparable with  or sibling of~, 
and therefore  is incomparable with , and we can replace  with
, continuing with their least common ancestor, 
a node which is strictly higher than . 
Let  and  be the children of  
that are respectively ancestors of  and . 
Note that by construction, . 
If  and there is an -node  in the subtree of , 
different from  and incomparable with , 
then we replace  by  and proceed. 
In other words we ensure that if  
then there is no -node incomparable with  in the subtree of . 
We proceed similarly
to enforce that if  then there is no
-node incomparable with  in the subtree of . 
Notice that we cannot have at the same time  and 
because we assumed  and  to be incomparable. 
All these properties can be specified in  and therefore can be tested 
by a forest automaton.  
Let  and  be the respective data values of  and  (possibly ).

Consider now a -node  whose data value is neither  nor .
If  is incomparable with  or sibling of , then the formula cannot be true as
it is contradicted by .  If  is an ancestor of  then, as no
-node is incomparable with , none is incomparable with . 
Hence the formula can only be true with such .
Assume now that  is inside the subtree of~. 
If  and , then the formula is contradicted by .
If  and , then, by hypothesis, 
there is no -node incomparable with  in the subtree of , 
and there is no -node incomparable with  outside the subtree of ,
hence altogether, the formula holds for .
If  and  is a descendant of , 
then the formula is contradicted by .
The cases where  is descendant of  are symmetric:
in this case, the formula can only be true if  and .
In the remaining cases  is in the subtree of  and not in the subtrees of
 and , making the formula false. Indeed, in each of these cases, either
 or  contradicts the formula.
To summarize, the only cases making the formula true
are when  is an ancestor of , 
or ,
or .
 

With this discussion in mind, this case can be solved as follows:
The transducer  guesses the nodes of , , ,  and 
and checks that they satisfy the appropriate properties. 
Moreover,  guesses whether  
and marks the data values of  and  accordingly
with one or two new colors. 
The forest automaton  will then check that the data values are marked
appropriately as in Remark~\ref{remark-color-class}.

Moreover  checks that for all marked -nodes there is no
-node incomparable with it and with a different data value, a regular
property as explained in Remark~\ref{remark-color-class}.
It now remains for  to check that every unmarked -node~ behaves
according to the discussion above: 
 is an ancestor of  or  and  or  and .
This is a regular property testable by .

\paragraph{\bf Subcase 4.2:} There are no two incomparable -nodes. 

Let  be an -node such that no -node is a descendant of . 
By hypothesis, all -nodes are either ancestors or siblings of . 
Let  be the data value of .
We distinguish between several subcases depending on whether 
there are other -nodes that are siblings of  or not.

If there is an -node  that is a sibling of , then let 
be its data value (possibly ).  Consider
now a -node  whose data value is neither  nor .  
Then, in order to make the formula true,  must be an ancestor or a sibling of .

In this case, the transducer  guesses the nodes  and  and marks the
corresponding data values with one or two new colors (according to whether 
or not).  The forest automaton  will then check that the data values are marked
correctly as explained in Remark~\ref{remark-color-class}.
For the marked -nodes, the property expressed by the formula
is regular and can also be checked by .
It remains for  to check that every unmarked -nodes is 
either an ancestor of  or a sibling of .

Now, if there are no -nodes that are sibling of ,
and  is a -node whose data value is not , 
then in order to make the formal true,  cannot be incomparable with , 
and therefore,  can be an ancestor, a descendant or a sibling of .

In this second case, the transducer  guesses the node , 
marks its data value using a new color. 
The forest automaton  will then check that the data values were marked
correctly as explained in Remark~\ref{remark-color-class}.
The transducer  checks that all marked -nodes make the formula true
(a regular property),
and that all unmarked -nodes are not incomparable with .

\medskip

We now turn to formulas of the form \eqref{eq:inf-faex}.

\paragraph{\bf Case 5:} , where  is as in \eqref{eq:inf-faex}.
These formulas express properties of nodes with the same data value. 
Moreover they express a regular property over all . 
Therefore can be treated by the forest automaton  as for the case 1.



\paragraph{\bf Case 6:}
.
This formula expresses that every -node has a next sibling of type 
with a different data value.
The transducer  marks every -node ,
with a new color  and checks that the next-sibling of  is a -node.
The forest automaton  accepts only the forests such that
for every node marked with , its right sibling is labeled with~.

\paragraph{\bf Cases 7, 8, 9:}
The formulae of form 

where  is one of , ,  
are treated similarly.

\paragraph{\bf Case 10:}
.
This formula expresses that every -node 
must have a -node as a right sibling, but not as its next-sibling,
and with a different data value.

Let  be an horizontal path. Let  be the rightmost -node of  
and  be its data value. 
Consider now an -node  of  with a data value different from . 
Then either  is at the left of the previous-sibling of , 
and  can serve as the desired witness, 
or  has no witness and the formula is false.

The transducer , for each horizontal path  containing an
-node, marks its rightmost -node  with a new color ,
guesses all the nodes of  with the same data value as  and marks them
with a new color . 
Then it checks that every unmarked -node of 
occurs at the left of the previous-sibling of . 
The forest automaton  checks that the guesses are correct 
as in Remark~\ref{remark-color-class}: 
for each horizontal paths, either all elements are marked with  or , or none.

\paragraph{\bf Cases 11, 12, 13:}
The constructions for the formulae

where  is one of , , and  
are similar.

\paragraph{\bf Case 14:}
.
This formula expresses that every -node 
must have a incomparable -node with a different data value.

\paragraph{\bf Subcase 14.1:} 
There exist two -nodes that are incomparable.

Let  and  be two incomparable -nodes and let  be their least
common ancestor. Using the same reasoning as in subcase 4.1, we can choose
 and  such that none of the -nodes is incomparable with  or a
sibling of .  Let  and  be the children of  that are the
ancestors of  and  respectively.  By construction, .
Using the same trick as in subcase 4.1,
we can ensure that if  then there is no -node
incomparable with , and
if  then there is no -node incomparable with . 
Moreover, we cannot have at the same time  and . 
Recall that all these properties can be tested by a forest automaton. 
Let  and  be the respective data values of  and  (possibly ). 

Consider now an -node  whose data value is neither  nor . 
If  is incomparable with  or a sibling of , then  is a witness for . 
If  is an ancestor of  then by hypothesis there is no -node incomparable 
with  and hence the formula is false. 
Assume now that  is in the subtree rooted at . 
If  and , then  is a -node
incomparable with  with a different data value, hence a witness for  in the formula.
If  and , 
then by hypothesis, there is no -node incomparable with 
in the subtree of , and since there are neither -nodes incomparable with 
outside the subtree of , the formula must be false.
If  and  is a descendant of , 
then  is a witness for .
The cases where  is a descendant of  are symmetric.
In the remaining cases,  is in the subtree of  
and not a descendant of  or .
In each of these cases, either  or  is a witness for .

With this discussion in mind, this case can be solved as follows:
The transducer  guesses the nodes of , , ,  and  
and checks that they satisfy the appropriate properties. 
Moreover,  guesses whether  and marks accordingly the data values 
of  and  with one or two new colors. 
The forest automaton  will then check that the data values are marked appropriately, 
as in Remark~\ref{remark-color-class}.
Moreover  checks that for every marked -node, 
there exists a -node making the formula true. 
It remains for  to check the three following properties: 
no unmarked -node occurs above ,
if  then  is not an unmarked -node,
and if  then  is not an unmarked -node.

\paragraph{\bf Subcase 14.2:} There are no two -nodes that are incomparable. 

Let  be an -node such that no -node is
a descendant of . By hypothesis, all -nodes are either ancestors
or siblings of . Let  be the data value of .
We distinguish between several subcases depending on whether there are -nodes
that are siblings of  or not.

If there exists a -node  that is a sibling of , 
let  be its data value (possibly ).
Consider an -node  whose data value is neither  nor .
If  is incomparable with , then  is a witness for . 
If  is an ancestor or a sibling of , 
then the formula cannot be true, because by hypothesis
every -node cannot be incomparable with .
If  is a descendant of , then  makes the formula true for that .

Consider now the case where there are no -node that are sibling of .
Note that  can have -nodes among its ancestors.
Let  be a -node that has data value different from . 
If  is not incomparable with  then the formula must be false. 
Otherwise,  is a witness for .

The transducer  guesses the -node  and marks its data value using a new color. 
Then it checks whether there is an -node  that is a sibling of .
If yes, it guesses whether the value at  is the same as the value at  or not,
and marks the data value of  using a new color.
The forest automaton  will then check that the data values are marked appropriately.
For marked -nodes,  checks the regular property making the formula true.
It now remains for  to check, in both cases, 
that every unmarked -node 
satisfy the appropriate condition described above,
\textit{i.e.},
 that  is incomparable with  or a descendant of  
 if there exists a sibling  
 and that  is incomparable with  otherwise.

\paragraph{\bf Case 15:}
. 
It is sufficient to test with  that no -node is present in the forest.


\section{From \texorpdfstring{\dad}{DTA} to \texorpdfstring{\ebvass}{EBVASS}}\label{sec-dad-counter}

In this section we show that the emptiness problem of \dad can be reduced to
the reachability of a counter tree automata model that extends \bvass, denoted~\ebvass. 
An \ebvass is a tree automaton equipped with counters.  It runs on
binary trees over a finite alphabet.  It can increase or decrease its
counters but cannot perform a zero test.  For \bvass, when going up in the
tree, the new value of each counter is the sum of its values at the left and
right child. An \ebvass can change this behavior using simple arithmetical
constraints.


The general idea of the reduction is as follows. 
\label{sketch:sec-dad-counter}
Let  be a \dad. 
We want to construct
an automaton that recognizes exactly the projections of the data forests
accepted by . Because this automaton does not have access to the data
values, the main difficulty is to simulate the runs of  on all class
forests. We will use counters for this purpose. The automaton will maintain the
following invariant: At any node~ of the forest, for each state~ of
, we have a counter that stores the number of data values~ such that
 is in state  at  when running on the class forest associated to
. In order to maintain this invariant we make sure that the  automata
model has the appropriate features for manipulating the counters. In
particular, moving up in the tree, in order to simulate , 
the automaton has to decide which data value occurring 
in the left subtree also appears in the right subtree.  
At the current node, each data value is associated to a state of  
and, by the invariant property, a counter. In order to maintain the invariant for data
values occurring in both subtrees, for each pair  of states of , the
automaton guesses a number~ (the number of data values being at the same
time in state  in the left subtree and in state  in the right subtree),
removes  from both associated counters and adds  to the counter
corresponding to the state resulting from the application of the transition function of
 on . This preserves the invariant property and a BVASS cannot do it, so we explicitly add this feature to our model. Once we
have done this, the counters from both sides are added like a BVASS would do. 
The -stuttering property of the language of  will ensure that this last operation
is consistent with the behavior of .
This is essentially what we do. But of course there are some nasty details. In
particular \dad run over unranked forests while \ebvass run over binary trees.


We start by defining the counter tree automata model and then we present
the reduction.

\subsection{Definition of \ebvass} 


An \ebvass is a tuple  
where \A is a finite alphabet,  is a finite set of states,  is the initial
state,  is the number of counters,  is a finite set of constraints of
the form with , and  is the set of transitions which are
of two kinds: -transitions (subset denoted ) and
up-transitions (subset denoted ).

An -transition is an element of 
where  is the set of possible counter
updates:  stands for \emph{decrement counter } and  stands for
\emph{increment counter }. We view each element of  as a vector over
 with only one non-zero position.
An up-transition is an element of .


Informally, an -transition may change the current state and increment
or decrement one of the counters. An up-transition depends on the label of the
current node and, when the current node is an inner node, on the states reached
at its left and right child.  It defines a new state and the new value of each
counter is the sum of the values of the corresponding counters of the children.
Moreover, the behavior of up-transitions can be modified by the constraints
. Informally a constraint of the form  modifies this
process as follows: before performing the addition of the counters, 
two positive numbers
 and  are guessed 
(possibly of value ), the counter  of the left child and the counter
 of the right child are decreased by , the counter~ of the left
child and the counter  of the right child are decreased by~ and, once
the addition of the counters has been executed, the counter~ is increased by
. Note that  and  must be so that all intermediate values
remain positive.  This is essentially what is explained in the sketch above
except that we cannot distinguish the left child from the right child. This
will be a property resulting from -stuttering languages when coding them into binary
trees.
We now make this more precise.

A \emph{configuration} of an \ebvass is a pair  where  
and  is a valuation of the counters, seen as a vector of . 
The initial configuration is  where  is the function setting all counters to~.
There is an -\emph{transition} of label  from  to  if
 and  
(in particular this implies that ). 
We write , if  can be reached from
 via a finite sequence of -transitions of label .
 
Given a binary tree , a \emph{run}  of a \ebvass is a
function from nodes of  to configurations verifying for all leaf ,
 and for all nodes  of  with  and
 the left and right child of , and  there exist 
such that:

\begin{enumerate}
\item , 
,
\item ,
\item for each constraint  of the form  
there are two numbers  and  (they may be )
and vectors , having
 and  at positions  for , having
 and  at positions  for ,
 at position  for 
and all other positions set to zero,
\item \label{item:ebvass-decrement}
      , and 
      , and
. 
\end{enumerate}
\noindent
We stress that it will be important for coding the automata into the logic
(Section~\ref{sec-counter-fotwo}) that  is independent of the current state of the automaton.

Without the constraints of  we have the usual notion of
\bvass~\cite{acl10}. 
It does not seem possible in general to simulate directly a constraint
 with BVASS transitions.  One could imagine using an
arbitrary number of -transitions decreasing the counters  and
 while increasing counter , after the merging operation summing up the
counters.  However, it is not clear how to do this while preserving the
positiveness of the corresponding decrements before the merge
(Step~\ref{item:ebvass-decrement} above).


\medskip

\noindent
The \emph{reachability} problem for an \ebvass, on input , 
asks whether there is a tree and a run on that tree reaching 
the configuration  at its root.


\subsection{Reduction from \texorpdfstring{\dad}{DTA} to \texorpdfstring{\ebvass}{EBVASS}}

\begin{theorem}\label{prop-reduct}
  The emptiness problem for \dad reduces to the reachability problem for
  \ebvass.
\end{theorem}
\begin{proof}
We first take care of the binary trees versus unranked forest issue.
It is well known that forests of 
can be transformed into binary trees in  
using the first-child/right-sibling encoding, denoted by ,
and formally defined as follows (for  and ):



This transformation effectively preserves regularity: 
for each automaton  computing on  
there exists an automaton  on binary trees of ,
effectively computable from , 
recognizing exactly the  encoding of the forests recognized by .  
This automaton  is called the  \emph{view} of~.  
Note that we use the same  symbol in the \fcns construction and 
for class forests. This simplifies the technical details of the proof. In
particular we can assume that our tree automata start with a single initial
state at the leaves of the tree.


\medskip

  We show that given a \dad , one can construct an \ebvass  with a
  distinguished state  such that for all , there is
  a run of  on  reaching  at its root iff
   is accepted by  for some~.

\medskip

Before explaining the construction of  we first show the consequences of
the fact that the second component of  recognizes a -stuttering language on its \fcns view .
The \fcns view of the rules of Figure~\ref{fig-rules} are depicted in
Figure~\ref{fig-rules-fcns}: One obtains the same result by application of \fcns and then of a rule of Figure~\ref{fig-rules-fcns} 
than by application of the corresponding rule of Figure~\ref{fig-rules} and then of \fcns. 
This can be enforced using the following syntactic restrictions on the \fcns view  that will be useful in our proofs.
In the definition of these restrictions, 
we use the notation  
for a transition of  from the states ,  
in the left and right child of a node of label , moving up with state .


We assume without loss of generality that the states of  permit to
distinguish the last symbol read by .  More precisely, we assume that the
set of states of  is split into two kinds: the -states and the
non--states.  The states of the first kind are reached by  on nodes
labeled with symbol , while the states of the second kind are reached by
 on nodes with label in .  We say that  is
\emph{-stuttering} if  is deterministic and has a specific -state
 that it must reach on all leaves of label , and verifies the
following properties:
\begin{enumerate} 
\item if a transition rule of the form  
is applied at a -node that is the left-child of another -node, then 
\item if a transition rule of the form  is applied at a -node that is the right-child of another -node, then 
\item all transition rules of the form  with  a -state
  verify .
\item \label{it-commutativity}
 all transition rules of the form  are ``commutative'',
  \textit{i.e.},  must then also be a rule.
\end{enumerate}


\begin{figure}
\small

\caption{\fcns view of the -stuttering closure rules.  and  are
  arbitrary binary trees.}
\label{fig-rules-fcns}
\end{figure}

\noindent From these definitions, it is straightforward to see that 
for a set , the following properties are equivalent
\begin{itemize}
\item  is an -stuttering language,
\item  is closed under the rules in Figure~\ref{fig-rules-fcns},
\item there exists an -stuttering automaton recognizing .
\end{itemize}

\medskip

We now turn to the construction of .
Let  
and 
be the  views of the two components of .
The automaton  is -stuttering (\textit{i.e.} there is a distinction in its
states between -states and non--states, and the existence of a
-state  on which  evaluates the tree with a single
node labeled with ) and we also assume without loss of generality that it
is deterministic and complete, \textit{i.e.}, for every ,  evaluates into exactly one state of .

Here  and  (resp. , ) are the respective state sets
(resp. final state sets) of  and , 
 is the input alphabet of , 
 is the output alphabet of  and input alphabet of 
(with the symbol~),
and ,  are the sets of transitions.
We will use the notation  
,
for a transition of  from the states ,  in the left and right child 
of a node of label , renaming this node with  and moving up with state .
In the following, we write explicitly the set of states of  
as .

For any data tree , and any data value  occurring in , 
the state of  corresponding to the evaluation of  on the class forest 
is called \emph{the -state associated to  in }. 
When  is the data value at the root of ,
this state is called the \emph{\rootstate{}} of .
Note that for all  the \rootstate{} of  exists and is unique,
since  is assumed to be deterministic and complete, 
and that it is always a non--state.

We now construct the expected \ebvass  
with .
We set , 
where  is a finite set of auxiliary control states.
The initial state  is the tuple formed with , the initial state of ,
, the initial state of , and a specific state of .
The first and second components of a state 
are respectively called the -state and the 
\rootstate of .
The transitions of the \ebvass  are constructed in order to ensure
the following invariant:

\medskip
\noindent
\hspace{-1mm}\hspace{2mm}\parbox[t]{128mm}{ reaches the configuration  at the
  root of a tree  
  iff there exists a data tree 
  and a possible output  of  on  
  witnessed by a run of  whose state at the root of  is the -state of~,   
  and moreover for all , ,
   is the number of data values having  as associated -state 
  in .}  
\medskip

\noindent Note that the counters ignore the number of data values having  as associated -state 
(which will always be infinite).
A consequence of  is that:
 there is only one non--state  such that , and actually .
We will refer to this state  as the \emph{\rootstate} of ,
and the construction of  will ensure that  is also the \rootstate of .


If we can achieve the invariant  then we are done.
Indeed, we can add to  some -transitions which, 
when reaching a state  containing a final -state,
decrement the counters corresponding to final states of  (and only those).
Then,  reaches a configuration  with the -state of  being
a final state of  iff there exists a data tree accepted by~.


Notice that the property  is invariant under permutations of .
Hence if a tree  witnesses the property , then any tree
 constructed from  by permuting the data values is also a
witness for .  This observation will be useful for showing the
correctness of the construction of .

 
Before defining the transition relation of  we sketch with more details its
construction.

The automaton  needs to maintain the invariant .  One direction
will be immediate: if  has an accepting run on  then
 is constructed so that it has an accepting run on  satisfying
 as witnessed by . For the converse direction, we need to
construct from a run of  on  a tree  such that
 has a run on  as in .

The simulation of  is straightforward as  can simulate any regular
tree automaton. The simulation of  is done using the -state of the
states of : for every -transition  of , the
-states of  and  must coincide, and for every up-transition
 of , there exists a transition of  of the form
, for some  such that  and  are
the respective -states of ,  and . In other words, the
-state of  always is the state of  at the current node.

Let's now turn to the simulation of  and the invariant .
This invariant will be shown by induction in the depth of the tree.
Let us assume that  reached the configuration  
at the root  of a tree .

If  is a leaf node, then by definition of \ebvass, 
 is the initial state  of  
and ,
hence  holds.

If  is an inner node, then  for some letter
.  By induction on the depth, we have trees 
and  such that there is a run of  on  and  satisfying . 
From the remark above on the invariance of  under permutations of , 
we can assume that  and 
do not share any data value.
We need to set the transitions of  such that from , ,
we can construct a tree  such that  also has 
a run on  as in (). The tree  will
be of the form  for some , where 
and  are constructed from  and  by permuting
the data values. The permutation will identify some data values of 
with some data values of . The number of data values we identify is
given by the  in the constraints of  as explained in the initial
sketch on page~\pageref{sketch:sec-dad-counter}. 
This  is therefore given by the run of  and we will see that it does not
matter which data values we actually choose, it is only important that we pick
 of them. The constraints make sure that this is consistent with the runs of .

For this purpose we define  as the set of constraints of the form
 such that there exists a transition  of  where , , and  are -states in
.  Note that the commutativity rule in the
definition of -stuttering languages implies that whenever we have a
constraint  then both  and
 are transitions of .

This does maintain  assuming that , the data value expected at ,
is not among the data values we identify (in the transitions used to construct
 the root symbol is ). This data value  has to be treated
separately and we have several cases depending on whether  is completely new
(does not occur in~ and~), or occurs in~ but
not in~, or the other way round, or it occurs in both subtrees. Actually it
will also be necessary to consider separately the cases where~ occurs at the
root of~ or~.

This last choice is guessed by  and can therefore be read from the run
of . We can then choose  consistently with the guess of . Again
the precise value of  is not important. It is only important that its
equality type with the other data values is consistent with the choice made by
. This makes finitely many cases and we define the transition function of
 as the union of corresponding family of transitions. Each of them
involving disjoint intermediate states they don't interfere between each
other. We therefore define them separately and immediately after prove that they
do maintain  for their case.

\medskip


\paragraph{\bf 1.}
\emph{ guessed that the data value of the current node 
 is equal to the data value of both its children}.

\noindent
To handle this case, for each transition  of , 
where none of  are -states,  has the following transitions:
\begin{description}
\item[\rm -transitions:] \quad\\
from a state  of -state  
it decreases counter  
and moves to a state \\ from a state  of -state 
it decreases counter  
and moves to state \\
from a state  
it increases counter  
and moves to a state  of -state 

\item[\rm up-transition:]
.
\end{description}
The state  (resp. , ) 
differs from   (resp. , )
only by its third component (in ), that contains .
We shall use the same convention for the states introduced in the 
following construction cases.

\paragraph{\bf Correctness.} 
Let us show that if  makes an up-transition   
at the root of  we can construct  such that 
has a run on  satisfying~.
This up-transition can only occur if we had -transitions from  to
 in the left subtree and from  to
 in the right subtree where  and  are the
-states of  and .
Let  be the root of the tree  where this transition
occurred. We have . 
By induction hypothesis we have trees
 and  
and possible outputs  of  
on respectively  and  
such that there is a run of  on 
 and  satisfying~.

We first apply a bijection on the labels of  in order for the data
value of its root to match the one of the root of . Let  be this
data value.

For each constraint  
we let  and  be the numbers used by the run of  when using
the above up-transition.  By induction hypothesis , and semantics of the
constraints (making sure the counters are big enough) there are at least
 (resp. ) distinct data values different from 
(because the up-transition is applied \emph{after} we decreased the counter  by ) 
in  having  (resp. ) as associated
-state in , 
and similarly for .  
We pick such data values in each subtree 
and call them the data values associated to .  
We do this for all constraints  
and we choose the associated data values such that they are all distinct.  
We now apply to  a permutation on the data values 
such that for all  the data values associated to  in  
are identified with the ones for  and such that all other
data values are distinct.  In order to simplify the notations we call the
resulting tree also .  We then set  as 
and  where  
is an output of  on  compatible with the transition.

Let  be an arbitrary data value occurring in .

If , the root symbol of the class forest  
is  and the counter  is increased by 1 by the last -transition.
By induction hypothesis and its consequence , 
 and for all other non--states 
the corresponding value via  will be 0. 
Hence  is the new \rootstate of . 
It is also the \rootstate of  by construction.

If  we consider 3 subcases. 
If  occurs in both  and  
then the class forest  has the form  
for some forests  and 
containing each at least one symbol other than  (not at the root node).
Let  and  be the states reached by  when evaluating  and .
They are the -states associated to  in  and ,
(resp. the left- and right subtrees of ),
and both are -states in .
By construction of , there are at least
 such data values , 
where  
and  is the unique state of  such that 
 is a transition of  (and
therefore also  is also a transition). 
These  data values will contribute to an increase of  by  as expected.

Assume now that  occurs in  but not in  (the remaining
case being symmetrical). Then  has the form  
where  contains at least one symbol other than  (not at root node),
and all nodes of  are labeled~.
By the hypothesis that  is -stuttering, 
the -state associated to  in  is the same as the one
associated to  in ,
and the -state associated to  in  is .
This is consistent with the behavior of 
that propagates upward the value of the counter corresponding to this state, 
after applying the constraints.
Altogether this shows that  verifies .

\tikzset{
itria/.style={
  draw,shape border uses incircle,
  isosceles triangle,shape border rotate=90,yshift=-0.7cm},
rtria/.style={
  draw,dashed,shape border uses incircle,
  isosceles triangle,isosceles triangle apex angle=90,
  shape border rotate=-45,yshift=0.2cm,xshift=0.5cm},
ritria/.style={
  draw,dashed,shape border uses incircle,
  isosceles triangle,isosceles triangle apex angle=110,
  shape border rotate=-55,yshift=0.1cm},
letria/.style={
  draw,dashed,shape border uses incircle,
  isosceles triangle,isosceles triangle apex angle=110,
  shape border rotate=235,yshift=0.1cm}
}

\begin{figure}
\small

\caption{Proof of Theorem~\ref{prop-reduct}, Case 1.
The -states are displayed in parentheses in the class tree .}
\label{fig-reduct1}
\end{figure}







\paragraph{\bf 2.}  \emph{ guessed that the data value  of
  the current node is equal to the data value of its left child but different
  from the data value  of its right child. 
  Moreover  guessed that the -state associated to  in the right
  subtree is , and that the data value  of the right child also appears in the left subtree, with  as -state associated to  in this left subtree.
  Note that both  and  must be -states in .}

\noindent
To handle this case for all transitions 
and  of
, where none of  are -states but
 (like  and ) are -states, 
 has the following transitions:
\begin{description}
\item[\rm -transitions:] \quad\\
from a state  of -state 
it decreases the counters  and  
and moves to state \\
from a state  of -state  
it decreases the counters  and  
and moves to state \\
from a state  
it increases counters  and  
and moves to a state  of -state 

\item[\rm up-transition:]
.
\end{description}

\paragraph{\bf Correctness.}  We argue as in the previous case with the following modifications.
From  and  we first apply a bijection making sure that the
data values  and  of their roots are different and that  has
-state  in  
and  has -state  in ,
where  and 
 are possible outputs of  
on respectively  and  from the induction hypothesis.

For each  we select the associated data values making sure
they are neither  nor . The decrement in the -transitions make sure
that this is always possible. We then perform the same identification as in the
previous case. 
The same argument as above shows that the resulting tree  has the desired properties.

\begin{figure}
\small

\caption{Proof of Theorem~\ref{prop-reduct}, Case 2.}
\label{fig-reduct2}
\end{figure}







 
\paragraph{\bf 3.}  
\emph{ guessed that the data value  of the
  current node is equal to the data value of its left child but different
  from the data value of its right child.
  Moreover  guessed that  also appear in
  the right subtree of the current node, with  as associated -state in this right subtree, 
  and that the data value of the right child of the current node does not appear in the left subtree. 
  Note that  must be a -state in .}

\noindent
To handle this case for all transitions 
and  of
, where none of  are -states but
 and   are -states, 
 has the following transitions:
\begin{description}
\item[\rm -transitions:] \quad\\
from a state  of -state 
it decreases the counter  
and moves to state \\
from a state  of -state  
it decreases the counter  
and  and moves to state \\
from a state  
it increases the counters  and  
and moves to a state  of -state 

\item[\rm up-transition:]
.
\end{description}

\paragraph{\bf Correctness.}  
We argue as in the previous cases with the following modifications.
From  and  we first apply a bijection making sure that the
data values  and  of their roots are different and that  has
-state  in  
and  does not appear in  ( is as in previous cases).

For each  we select the associated data values making sure
they are neither  nor . The decrement in the -transitions make sure
that this is always possible. We then perform the same identification as in the
previous case. 
As before we show that the resulting tree  has the desired properties.

\begin{figure}
\small

\caption{Proof of Theorem~\ref{prop-reduct}, Case 3. The node without subtree in the class tree  is a leaf.}
\label{fig-reduct3}
\end{figure}








\paragraph{\bf 4.} 
\emph{ guessed that the data value  of the
  current node is different from the ones of its children but appear in both
  subtrees, with  and  as associated -states repectively in left and right subtrees. 
  Moreover  guessed that the data values of both children of the current node 
  are equal. Note that  and  must be \#-states in .}

\noindent
To handle this case for all transitions 
and  of
, where none of  are -states but
 and   are -states,  has the following transitions:
\begin{description}
\item[\rm -transitions:]\quad\\
from a state  of -state  
it decreases the counters  and  
and moves to state \\
from a state  of -state  it
decreases the counters  and  
and moves to state \\
from a state  
it increases the counters  and  
and moves to a state  of -state 

\item[\rm up-transition:]
.
\end{description}

\paragraph{\bf Correctness.}  
We argue as in the previous cases with the following modifications.

From  and  we first apply a bijection making sure that the
data value  of their roots are equal and that  and  share a common
data value  of -state  in  
and -state  in .

For each  we select the associated data values making sure
they are neither  nor . The decrement in the -transitions make sure
that this is always possible. We then perform the same identification as in the
previous case. 
The rest of the argument is similar after setting .

\begin{figure}
\small

\caption{Proof of Theorem~\ref{prop-reduct}, Case 4.}
\label{fig-reduct4}
\end{figure}






\medskip\noindent\textbf{5.}  \emph{ guessed that the data value  of the
  current node is different from the ones of its children but appear in
  both subtrees, with  and  as associated -states in respectively the left and right subtree.
  Moreover  guessed that the data values of both children of the current node are
  distinct but appear in the other subtree with respective associated -state  and .
  Note that , , ,  must be \#-states.}

To handle this case for all transitions
,
 and 
 of , 
where none of  are -states but
 are -states,  has the following
transitions:
\begin{description}
\item[\rm -transitions:]\quad\\
from a state  of -state 
it decreases the counters ,  and  
and moves to state \\
from a state  of -state  
it decreases the counters ,  and  
and moves to state \\
from a state  
it increases the counters ,  and  
and moves to a state  of -state 

\item[\rm up-transition:]
.
\end{description}

\paragraph{\bf Correctness.}  
We argue as in the previous cases with the following modifications.

From  and  we first apply a bijection making sure that the
data values  and  of their roots are distinct and that  has
-state  in  and  has -state  in
. Moreover  and  share a common data value 
distinct from  and  of -state  in  and
-state  in .

For each  we select the associated data values making sure
that they are neither ,  nor . The decrement in the -transitions make sure
that this is always possible. We then perform the same identification as in the
previous case. 
The rest of the argument is similar after setting .

\begin{figure}
\small

\caption{Proof of Theorem~\ref{prop-reduct}, Case 5.}
\label{fig-reduct5}
\end{figure}







\paragraph{\bf 6.}
  \emph{ guessed that the data value  of the
  current node is different from the ones of its children but appear in both
  subtrees, with  and  as associated -states in respectively the left and right subtree. 
  Moreover  guessed that the data value of the right child of the current node appear in its
  left subtree, with  as associated -state in this left subtree, 
  and that the data value of the left child does not appear in the right subtree. 
  Note that ,  and  must be \#-states in .}

\noindent
To handle this case for all transitions 
,
 and 
 of , 
where none of  are -states but
 are -states,  has the following transitions:
\begin{description}
\item[\rm -transitions:]\quad\\
from a state  of -state 
it decreases the counters ,  and  
and moves to state \\
from a state  of -state  
it decreases the counters ,  
and moves to state \\
from a state 
it increases the counters ,  and  
and moves to a state  of -state 

\item[\rm up-transition:]
.
\end{description}

\paragraph{\bf Correctness.}  
We argue as in the previous cases with the following modifications.

From  and  we first apply a bijection making sure that the
data values  and  of their roots are distinct and that  does not
appear in  and  has -state  in
. Moreover  and  share a common data value 
distinct from  and  of -state  in  and
-state  in .

For each  we select the associated data values making sure
that they are neither ,  nor . The decrement in the -transitions make sure
that this is always possible. We then perform the same identification as in the
previous case. 
The rest of the argument is similar after setting .

\begin{figure}
\small

\caption{Proof of Theorem~\ref{prop-reduct}, Case 6.}
\label{fig-reduct6}
\end{figure}









 
\paragraph{\bf 7.}  
\emph{ guessed that the data value  of the
  current node is different from the ones of its children but appears in both
  subtrees with  and  as associated -states. 
  Moreover it guessed that the data values of both children of the current node do not appear elsewhere.
  Note that ,  must be \#-states in .}

\noindent
To handle this case for all transitions 
,
 and 
 of , 
where none of  are -states but
 are -states,  has the following
transitions:
\begin{description}
\item[\rm -transitions:]\quad\\
from a state  of -state 
it decreases the counters ,  
and moves to state \\
from a state  of -state  
it decreases the counters ,  
and moves to state \\ 
from a state  
it increases the counters ,  and  
and moves to a state  of -state 

\item[\rm up-transition:]
.
\end{description}

\paragraph{\bf Correctness.}  
We argue as in the previous cases with the following modifications.

From  and  we first apply a bijection making sure that the
data values  and  of their roots are distinct and that  does not
appear in  and  does not appear in
. Moreover  and  share a common data value 
distinct from  and  of -state  in  and
-state  in .

For each  we select the associated data values making sure
that they are neither ,  nor . The decrement in the -transitions make sure
that this is always possible. We then perform the same identification as in the
previous case. 
The rest of the argument is similar after setting .

\begin{figure}
\small

\caption{Proof of Theorem~\ref{prop-reduct}, Case 7.}
\label{fig-reduct7}
\end{figure}










\paragraph{\bf 8.} 
\emph{ guessed that the data value  of the
  current node is different from the ones of its children and does not appear
  in the subtrees.  Moreover  guessed that the data values of both
  children of the current node are equal.}

\noindent
To handle this case for all transitions 
,
 of , 
where none of  are -states,  has the following transitions:
\begin{description}
\item[\rm -transitions:]\quad\\
from a state  of -state 
it decreases the counters  
and moves to state \\
from a state  of -state  
it decreases the counter  
and moves to state \\
from a state  
it increases the counters , and  
and moves to a state  of -state 

\item[\rm up-transition:] .
\end{description}

\paragraph{\bf Correctness.}  
We argue as in the previous cases with the following modifications.

From  and  we first apply a bijection making sure that the
data values of their roots are equal (let us call it ). 

For each  we select the associated data values making sure
it is not . The decrement in the -transitions make sure
that this is always possible. We then perform the same identification as in the
previous case. 
The rest of the argument is similar after setting
, where  is a fresh new value.

\begin{figure}
\small

\caption{Proof of Theorem~\ref{prop-reduct}, Case 8.}
\label{fig-reduct8}
\end{figure}









\paragraph{\bf 9.} 
\emph{ guessed that the data value  of the
  current node is different from the ones of its children and does not appear in both subtrees. 
  Moreover  guessed that the data values of both children of the current node (say  and ) 
  are distinct but appear in the other subtree with respective associated -state  
  and .
  Note that ,  must be -states in .}

\noindent 
This case is treated as before with the expected transitions.

\begin{figure}
\small

\caption{Proof of Theorem~\ref{prop-reduct}, Case 9.}
\label{fig-reduct9}
\end{figure}




\paragraph{\bf 10.} 
\emph{ guessed that the data value  of the
  current node is different from the ones of its children and does not appear in both subtrees. 
  Moreover  guessed that the data value  of the right child in its left subtree with  as associated -state in this left subtree
  and that the data value  of
  the left child does not appear in the right subtree. 
  Note that  must be a -states in .}

\noindent 
This case is treated as before with the expected transitions.

\begin{figure}
\small

\caption{Proof of Theorem~\ref{prop-reduct}, Case 10.}
\label{fig-reduct10}
\end{figure}




\paragraph{\bf 11.} 
\emph{We omit the symmetric cases.}
\end{proof}


\section{From \texorpdfstring{\ebvass}{EBVASS} to \texorpdfstring{\fotwo}{FO2}}\label{sec-counter-fotwo}

We show in this section that reachability of \ebvass 
can be expressed as a sentence of \fotwo. 
This concludes the loop of reductions, showing that 
reachability for \ebvass, satisfiability of \fotwo and emptiness of \dad 
are equivalent as decision problems. 
The proof essentially mimics the reduction from \bvass to \fotwo described 
in~\cite{BojanczykMSS09jacm} with
extra material in order to handle the extra features.

\begin{theorem}\label{thm-bvass-fodeux}
 The reachability problem for \ebvass reduces to the satisfiability problem for \fotwo.
\end{theorem}

\begin{proof}
Given an \ebvass  and a state , 
we compute a sentence  such that  has a model 
iff the configuration  is reachable in some tree
(where  is the function setting all counters to ).

\noindent
We associate to  the following finite alphabet
. 
Intuitively  says that the counter
 has been decreased,  says that the counter  has been increased,
 encodes the transition relation, and the letters ,  and  will be used to enforce 
the constraint . 
The formula  we construct accept all binary data trees 
of  encoding runs of . It turns out that 
accepts more trees but any accepted trees of  can be transformed into an accepting
run of  with simple transformations.

\noindent
We start with the encoding of a single transition .

\noindent
If  is an -transition then we encode it with two nodes
 where  is the unique child of  and the label of  is  while
the label of  is  (resp. ) 
if  was decreasing (resp. increasing) counter .

\noindent
If  is an up-transition, then we encode
it as a subtree of the following form:
\begin{itemize}
\item The root has label ,
\item below the root there is a (vertical) sequence of nodes of arity one whose 
  labels form a word of
  , 
  where  denotes concatenation,
\item the last node of that sequence has arity two and two branches starts from that node,
\item the sequence of labels of the left branch forms a word of
,
\item the sequence of labels of the right branch forms a word of
,
\item for all  the number of occurrences of  and
   are the same.
\end{itemize}
A tree satisfying all these items, except maybe the last one, is said to be a \emph{pseudo-encoding} of the up-transition . 
Notice that pseudo-encodings of up-transitions form a regular tree language.

\noindent
From there, the encoding of a run is obtained in the obvious way by concatenating
encodings of transitions.

The formula  essentially describes this construction. It first enforces
that the tree has the desired shape: 
\begin{itemize}
\item The tree is a repetition of a sequence of the form: a pseudo-encoding 
of one up-transition followed by the encodings of several -transitions,
\item the sequencing is valid: if  and  are consecutive transitions
  in the tree then the starting state of one is the ending state of the other,
\item the initial state  can be found at the leaves 
and the state  is reached at the root.
\end{itemize}
Note that the above three conditions can be checked by a standard tree
automaton over , and therefore can be expressed in .
Therefore, by setting  for a
suitable  matching the existential part of the  formula, 
the property above can be expressed in .

The formula  now needs to make sure that no counter ever gets negative and that
pseudo-encodings of up-transitions are actually real encodings. 
This is where
data values are needed:
The formula  enforces that 
\begin{enumerate}[label=\enspace(\arabic*)]
\item \label{it:Di} no two nodes with label 
      can have the same data value, for ,
\item \label{it:Ii} no two nodes with label 
      can have the same data value, for ,
\item \label{it:DiIi} for all , every node with label  has a descendant 
      with label  and with the same data value,
\item \label{it:IiDi} for all , every node with label  has an ancestor 
      with label  and with the same data value.
\end{enumerate}
These four conditions enforce that the counters never get negative and that
they are all set to  at the root.  It remains to enforce that all
pseudo-encodings can be transformed into real encodings.  
This is done with the following conditions.
\enlargethispage{\baselineskip}

\begin{enumerate}[label=\enspace(\arabic*)]
\setcounter{enumi}{4}
\item \label{it:Ttheta} no two nodes with label , for ,
      can have the same data value,
\item \label{it:Ltheta} no two nodes with label , for , 
       can have the same data value,
\item \label{it:Rtheta} no two nodes with label , for , 
       can have the same data value,
\item \label{it:TthetaLRtheta} every node with label  has a descendant with label  
      and a descendant with label 
      both with the same data value,
\item \label{it:LRthetaTtheta} every node with label  or  has an ancestor with label  
      and with the same data value,
\item \label{it:LRtheta} two nodes of label  and  with the same data value
  are not comparable with the ancestor relationship.
\end{enumerate}
It now remains to show that  has the desired property.
\begin{lemma}\label{lemma-ebvass-fo}
 has a model iff  is reachable by .
\end{lemma}
\begin{proof}
{\bf From reachability to models of .}
Assume that  is reachable and let  be a run of  witnessing this fact.
Let  be the tree constructed from  by concatenating the sequences
of encodings of transitions of  as explained above. 
The binary tree  certainly satisfies the ``regular'' part of . 
We now assign the data values so that
the remaining part of  is satisfied. This is done in the obvious way:
each time a counter  is decremented, as the resulting value is positive,
this means that a matching increment was performed before. Similarly, each time
a constraint  is used in a transition , we assign one distinct
data value per triple  
occurring in the encoding of
. The formula was constructed to make the resulting tree a model of .

{\bf From models of  to reachability.}
Assume now that . 
Unfortunately, it may happen that  does not encode a run of  because some section corresponds to a pseudo-encoding of an up-transition, 
instead of an expected real encoding. 
However, we show that from  we can construct another tree
 such that  
and  encodes a real run of .

To see this, let us consider a node  of  
with label , 
where , and let . 
Let  and  be two descendants of  
with respective labels  and 
and such that . 
Let  be the least common ancestor of  and .
The existence of  and  is guaranteed by  
(conditions \ref{it:Ttheta}--\ref{it:TthetaLRtheta}). The sentence  also ensures
that  is an ancestor of  
(conditions \ref{it:LRthetaTtheta}--\ref{it:LRtheta}).  By construction the subtree at  must correspond to
a pseudo-encoding of an up-transition .

We now move (down)  and its parent 
(that must have label ) 
right above  within the coding of .
Similarly we move (up)  and its parent
(that must have label ) 
right below , and similarly for .  
The reader can verify that the
resulting tree is still a model of : the regular conditions remain 
obviously satisfied.  
Conditions \ref{it:Di}--\ref{it:IiDi}  are still valid because the node of label  
matching the parent of  was already below the initial position of
 and its new position is upward in the tree. 
Finally conditions \ref{it:Ttheta}--\ref{it:LRtheta} remain valid by construction.

Repeating this argument eventually yields a model 
of  such that  is a correct sequencing of encodings of
transitions a . 
This encoding is actually a real run because 
conditions \ref{it:Di}--\ref{it:IiDi} of  immediately enforces that no counter is ever negative.\end{proof}
Theorem~\ref{thm-bvass-fodeux} is now immediate from Lemma~\ref{lemma-ebvass-fo}.
\end{proof}

\section{Conclusion}\label{sec-conclusion}We have seen that satisfiability of \fotwo, emptiness of \dad and reachability
of \ebvass are equivalent problems in terms of decidability. The main open
problem is of course whether they are all decidable or not.


The use of the \ebvass constraints of the form 

is crucial for the construction of Section~\ref{sec-dad-counter}.
Their semantics cannot be directly simulated with the usual BVASS,
but it is not clear whether \ebvass are strictly more expressive than BVASS,
and whether this extension is needed in order 
to capture the expressive power of \fotwo on data trees. 

In our definition of \ebvass the constraints of the form 
have a ``commutative'' semantics. 
Without commutativity, \textit{i.e.}, the rule modifies
only counter  on the left child and counter  on the right child,
the automata model is more powerful. 
In order to describes its runs as in the
proof of Theorem~\ref{thm-bvass-fodeux}, the logic needs to be able to enforce
that a  must be to the left of the  with the same data value. 
This can be done by adding the document order predicate into the logic.
A close inspection of the proof of Theorem~\ref{th-fotwodad} and
Theorem~\ref{prop-reduct} then shows that the extension of \fotwo with the
document order predicate can be captured by a \dad without the commutativity
rule and that such automata can be captured by the non-commutative version of
\ebvass.


In~\cite{BjSch10} it was shown that, over data words, the Data Automata model
of~\cite{BDMSS11} is more expressive than the Register Automata
of~\cite{KF94}. It is not obvious that our automata model \dad extends the
expressive power of the straightforward extension of register automata to data
trees. This remains to be investigated.



\bibliographystyle{abbrv} 


\bibliography{FO2BVASS} 

\end{document}
