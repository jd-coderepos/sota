\documentclass{article} \usepackage{iclr2019_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak

 


\usepackage{graphicx} \usepackage{caption}
\usepackage{subcaption}



\usepackage{tcolorbox}

\usepackage{hyperref}
\usepackage{url}
\usepackage{booktabs}
\usepackage{amsmath,amssymb}
\usepackage{array}
\usepackage{multirow}

\usepackage{natbib}

\usepackage{bibunits}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{algorithmicx}
\usepackage{xspace}

\newcommand{\alicom}[1]{{\color{blue} Ali: #1}}
\newcommand{\bcom}[1]{{\color{red} Ben: #1}}
\newcommand{\aaroncom}[1]{{\color{green} Aaron: #1}}
\newcommand{\oriol}[1]{{\color{magenta} Oriol: #1}}

\renewcommand{\figref}[1]{Fig.~\ref{#1}}
\newcommand{\tblref}[1]{Table~\ref{#1}}
\newcommand{\sref}[1]{Sect.~\ref{#1}}
\newcommand{\aref}[1]{Appendix~\ref{#1}}

\def\eg{\emph{e.g. }}
\def\ie{\emph{i.e. }}
\def\Eg{\emph{E.g.}}
\def\etal{\emph{et al.}}
\newcommand{\todo}[1]{\hl{TODO: #1}}
\newcommand{\ours}{-VAE}

\iclrfinalcopy

\title{Preventing posterior collapse with -VAEs}

\author{Ali Razavi \\
  Deepmind \\
  \texttt{alirazavi@google.com}
  \And
  A\"aron van den Oord \\
  Deepmind \\
  \texttt{avdnoord@google.com}
  \And
  Ben Poole \\
  Google Brain \\
  \texttt{pooleb@google.com}
  \And
  Oriol Vinyals \\
  Deepmind \\
  \texttt{vinyals@google.com}
}

\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\begin{document}

\maketitle

\begin{abstract}
Due to the phenomenon of ``posterior collapse,'' current latent variable generative models pose a challenging design choice that either weakens the capacity of the decoder or requires augmenting the objective so it does not only maximize the likelihood of the data.
In this paper, we propose an alternative that utilizes the most powerful generative models as decoders, whilst optimising the variational lower bound all while ensuring that the latent variables preserve and encode useful information.
Our proposed -VAEs achieve this by constraining the variational family for the posterior to have a minimum distance to the prior.
For sequential latent variable models, our approach resembles the classic representation learning approach of slow feature analysis. We demonstrate the efficacy of our approach at modeling text on LM1B and modeling images: learning representations, improving sample quality, and achieving state of the art log-likelihood on CIFAR-10 and ImageNet .


\end{abstract}

\section{Introduction}
Deep latent variable models trained with amortized variational inference have led to advances in representation learning on high-dimensional datasets \citep{VAE, Rezende2014}. These latent variable models typically have simple decoders, where the mapping from the latent variable to the input space is uni-modal, for example using a conditional Gaussian decoder. This typically results in representations that are good at capturing the global structure in the input, but fail at capturing more complex local structure (e.g., texture \citep{vaegan}). In parallel, advances in autoregressive models have led to drastic improvements in density modeling and sample quality without explicit latent variables \citep{pixelcnn}. While these models are good at capturing local statistics, they often fail to produce globally coherent structures \citep{pixeliqn}.

Combining the power of tractable densities from autoregressive models with the representation learning capabilities of latent variable models could result in higher-quality generative models with useful latent representations. While much prior work has attempted to join these two models, a common problem remains. If the autoregressive decoder is expressive enough to model the data density, then the model can learn to ignore the latent variables, resulting in a trivial posterior that collapses to the prior. 
This phenomenon has been frequently observed in prior work and has been referred to as 
\textit{optimisation challenges} of VAEs by \citet{Bowman2015}, 
the \textit{information preference} property by \citet{VLAE}, and the \textit{posterior collapse} problems by several others (e.g., \citet{VQVAE, SAVAE}). 
Ideally, an approach that mitigates posterior collapse would not alter the evidence lower bound (ELBO) training objective, and would allow the practitioner to leverage the most recent advances in powerful autoregressive decoders to improve performance. To the best of our knowledge, no prior work has succeeded at this goal. Most common approaches either change the objective \citep{betavae, Alemi2017, InfoVAE, VLAE, agave}, or weaken the decoder \citep{Bowman2015, PixelVAE}. Additionally, these approaches are often challenging to tune and highly sensitive to hyperparameters \citep{Alemi2017, VLAE}.

In this paper, we propose -VAEs, a simple framework for selecting variational families that prevent posterior collapse without altering the ELBO training objective or weakening the decoder. By restricting the parameters or family of the posterior, we ensure that there is a minimum KL divergence, , between the posterior and the prior.

We demonstrate the effectiveness of this approach at learning latent-variable models with powerful decoders on images (CIFAR-10, and ImageNet ), and text (LM1B). We achieve state of the art log-likelihood results with image models by additionally introducing a sequential latent-variable model with an anti-causal encoder structure. Our experiments demonstrate the utility of -VAEs at learning useful representations for downstream tasks without sacrificing performance on density modeling.
 \section{Mitigating posterior collapse with -VAEs}
Our proposed -VAE builds upon the framework of variational autoencoders (VAEs) \citep{VAE, Rezende2014} for training latent-variable models with amortized variational inference. Our goal is to train a generative model  to maximize the marginal likelihood  on a dataset. As the marginal likelihood requires computing an intractable integral over the unobserved latent variable , VAEs introduce an encoder network  and optimize a tractable lower bound (the ELBO): . The first term is the reconstruction term, while the second term (KL) is the rate term, as it measures how many nats on average are required to send through the latent variables from the encoder () to the decoder () \citep{Hoffman2016, Alemi2017}.

The problem of posterior collapse is that the rate term,  reduces to 0. In this case, the approximate posterior  equals the prior , thus the latent variables do not convey any information about the input . A necessary condition if we want representations to be meaningful is to have the rate term be positive.


In this paper we address the posterior collapse problem with structural constraints so that the KL divergence between the  posterior and prior is lower bounded by design.
This can be achieved by choosing families of distributions for the prior and approximate posterior,  and  such that . We refer to  as the \emph{committed rate} of the model. 

Note that a trivial choice for  and  to have a non-zero committed rate is to set them to Gaussian distributions with fixed (but different) variance term. We study a variant of this case in the experiments, and provide more details of this setup in Appendix \ref{app:indep}. In the following section we describe our choices for  and  , but others should also be explored in future work.


\subsection{-VAE with Sequential Latent Variables}

Data such as speech, natural images and text exhibit strong spatio-temporal continuity. Our aim is to model variations in such data through latent variables, so that we have control over not just the global
characteristics of the generated samples (e.g., existence of an object), but also can influence their finer, often shifting attributes such as texture and pose in the case of natural images, tone, volume and accent in the case of speech, or style and sentiment in the case of natural language. Sequences of latent variables can be an effective modeling tool for expressing the occurrence and evolution of such features throughout the sequence. 

\par
To construct a -VAE in the sequential setting, we combine a mean field posterior with a correlated prior in time. We model the posterior distribution of each timestep as . For the prior, we use an first-order linear autoregressive process (AR(1)), where  with  zero mean Gaussian noise with constant variance . The conditional probability for the latent variable can be expressed as . This process is wide-sense stationary (that is, having constant sufficient statistics through its time evolution) if . If so, then  has zero mean and variance of . It is thus convenient to choose .  The mismatch in the correlation structure of the prior and the posterior results in the following positive lower bound on the KL-divergence between the two distributions (see \aref{app:deriv} for derivation):



where  is the length of the sequence and  is the dimension of the latent variable at each timestep. The committed rate between the prior and the posterior is easily controlled by equating the right hand side of the inequality in \eqref{eq:rate} to a given rate  and solving for . In  \figref{fig:toy}, we show the scaling of the minimum rate as a function of  and the behavior of -VAE in 2d.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/cirvae_toy_v2}
    \vspace{-3mm}
\caption{{\em Effect of  in a toy model.} Fitting an uncorrelated Gaussian for the posterior, , to a correlated Gaussian prior, , by minimizing  over . Left: committed rate ( as a function of the prior squared correlation  and the  dimensionality . Right: contours of the optimal posterior and prior in 2d. As the correlation increases, the minimum rate grows.} 
    \label{fig:toy}

\end{figure}

\subsubsection{Relation to Probabilistic Slowness Prior}
The AR(1) prior over the latent variables specifies the degree of temporal correlation in the latent space. As the correlation  approaches one, the prior trajectories get smoother . On the other hand in the limit of  approaching , the prior becomes the same as the independent standard Gaussian prior where there are no correlations between timesteps. This pairing of independent posterior with a correlated prior is related to the probabilistic counterpart to Slow Feature Analysis \citep{SFA} in \citet{TurnerSahani}. 
SFA has been shown to be an effective method for learning invariant spatio-temporal features \citep{SFA}. In our models, we infer latent variables with multiple dimensions per timestep, each with a different slowness filter imposed by a different value of , corresponding to features with different speed of variation. 


\subsection{Anti-Causal Encoder Network}\label{sec:anticausal}

 Having a high capacity autoregressive network as the decoder implies that it can accurately estimate .
Given this premise, what kind of complementary information can latent variables provide? Encoding information about the past seems wasteful as the autoregressive decoder has full access to past observations already. On the other hand, if we impose conditional independence between observations and latent variables at other timesteps given the current one (i.e., ), there will then be at best (by the data processing inequality \citep{ThomasCover}) a break-even situation between the KL cost of encoding information in  and the resulting improvement in the reconstruction loss. There is therefore no advantage for the model to utilize the latent variable even if it would transmit to the decoder the unobserved . The situation is different when  can inform the decoder at multiple timesteps, encoding information about  and . In this setting, the decoder pays the KL cost for the mutual information once, but is able to leverage the transmitted information multiple times to reduce its entropy about future predictions. 


\par
To encourage the generative model to leverage the latents for future timesteps, we introduce an \emph{anti-causal} structure for the encoder where the parameters of the variational posterior for a timestep cannot depend on past observations (\figref{fig:gengraph}).
Alternatively, one can consider a \emph{non-causal} structure that allows latents be inferred from all observations. 
In this non-causal setup there is no temporal order in either the encoder or the decoder, thus the model resembles a standard non-temporal latent variable model. While the anti-causal structure is
a subgraph of the non-causal structure, we find that the anti-causal structure often performs better, and we compare both approaches in different settings in \aref{app:encabl}. 

\par

\begin{figure}[th!]
    \centering

    \includegraphics[width=0.7\textwidth]{figures/cirvae_generative_schematic.pdf}
   
    \caption{Generative structures for the inference of sequential latent variables. The anti-causal structure introduces an inductive bias to encode
    in each latent variable information about the future}
    \label{fig:gengraph}
\end{figure}

 \section{Related Work}
The main focus of our work is on representation learning and density modeling in latent variable models with powerful decoders. Earlier work has focused on this kind of architecture, but has addressed the problem of posterior collapse in different ways. 


In terms of our architecture, the decoders for our image models build on advances in autoregressive modeling from \citet{pixelcnn, PixelCNN++, PixelSnail, ImageTransformer}. Unlike prior models, we use sequential latent variables to generate the image row by row. This differs from \citet{ConvDraw}, where the latent variables are sequential but the entire image is generated at each timestep. 
Our sequential image generation model resembles latent variable models used for timeseries \citep{VRNN, Babaeizadeh2017, Denton2018} but does not rely on KL annealing, and has an additional autoregressive dependence of the outputs over time (rows of the image). Another difference between our work and previous sequential latent variable models is our proposed anti-causal structure for the inference network (see \sref{sec:anticausal}). We motivate this structure from a coding efficiency and representation learning standpoint and demonstrate its effectiveness empirically in \sref{sec:exp}. For textual data, we use the Transformer architecture from \citet{Vaswani2017} as our main blueprint for the decoder. As shown in \sref{sec:exp}, our method is able to learn informative latent variables while preserving the performance of these models in terms of likelihoods.

To prevent posterior collapse, most prior work has focused on modifying the training objective. \citet{Bowman2015, Yang2017, SAVAE} and \citet{PixelVAE} use an annealing strategy, where they anneal the weight on the rate from 0 to 1 over the course of training. This approach does not directly optimize a lower bound on likelihood for most of training, and tuning the annealing schedule to prevent collapse can be challenging (see \sref{sec:exp}). Similarly, \citet{betavae} proposes using a fixed coefficient  on the rate term to learn disentangled representations. \citet{InfoVAE} adds a term to the objective to pick the model with maximal rate. \citet{VLAE, IAF} use free-bits to allow the model to hit a target minimum rate, but the objective is non-smooth which leads to optimization difficulties in our hands, and deviations from a lower bound on likelihood when the soft version is used with a coefficient less than 1. \citet{agave} add an auxiliary objective that reconstructs a low-resolution version of the input to prevent posterior collapse. \citet{Alemi2017} argue that the ELBO is a defective objective function for representation learning as it does not distinguish between models with different rates, and advocate for model selection based on downstream tasks. Their method for sweeping models was to use -VAE with different coefficients, which can be challenging as the mapping from  to rate is highly nonlinear, and model- and data-dependent. While we adopt the same perspective as \citet{Alemi2017}, we present a new way of achieving a target rate while optimizing the vanilla ELBO objective.


Most similar to our approach is work on constraining the variational family to regularize the model. 
VQ-VAE \citep{VQVAE} uses discrete latent variables obtained by vector quantization of the latent space that, given a uniform prior over the outcome, yields a fixed KL divergence equal to , where  is the size of the codebook. A number of recent papers have also used the von Mises-Fisher (vMF) distribution to obtain a fixed KL divergence and mitigate the posterior collapse problem. In particular, \citet{Guu2017, xu2018spherical, davidson2018hyperspherical} use vMF() with a fixed  as their posterior, and the uniform distribution (\ie vMF(, 0)) as the prior. The mismatching prior-posterior thus give a constant KL divergence. As such, this approach can be considered as the continuous analogue of VQ-VAE. Unlike the VQ-VAE and vMF approaches which have a constant KL divergence for every data point, -VAE can allow higher KL for different data points. This allows the model to allocate more bits for more complicated inputs, which has been shown to be useful for detecting outliers in datasets \citep{alemi2018uncertainty}. As such, -VAE may be considered a generalisation of these fixed-KL approaches.

The Associative Compression Networks (ACN) \citep{ACN} is a new method for learning latent variables with powerful decoders that exploits the associations between training examples in the dataset by amortizing the description length of the code among many similar training examples. ACN deviates from the i.i.d training regime of the classical methods in statistics and machine learning, and is considered a procedure for compressing whole datasets rather than individual training examples. GECO \citep{Geco} is a recently proposed method to stabilize the training of -VAEs by finding an automatic
annealing schedule for the KL that satisfies a tolerance constraint for maximum allowed distortion, and solving the resulting Lagrange multiplier for the KL penalty. The value of , however, does not necessarily approach one, which means that the optimized objective may not be a lower bound for the marginal likelihood. \section{Experiments}\label{sec:exp}

\subsection{Natural Images}
We applied our method to generative modeling of images on the CIFAR-10 \citep{cifar10} and downsampled ImageNet \citep{imagenet} ( as prepared in \cite{PixelRNN}) datasets. We describe the main components in the following. The details of our hyperparameters can be found in \aref{app:arch}.

\textbf{Decoder}: Our decoder network is closest to PixelSNAIL \citep{PixelSnail} but also incorporates elements from the original GatedPixelCNN \citep{pixelcnn}. In particular, as introduced by \cite{PixelCNN++} and used in \cite{PixelSnail}, we use a single channel network to output the components of discretised mixture of logistics distributions for each channel, and linear dependencies between the RGB colour channels. As in PixelSNAIL, we use attention layers interleaved with masked gated convolution layers. We use the same architecture of gated convolution introduced in \cite{pixelcnn}. We also use the multi-head attention module of \cite{Vaswani2017}. To condition the decoder, similar to Transformer and unlike PixelCNN variants that use 1x1 convolution,  we use attention over the output of the encoder. The decoder-encoder attention is causally masked to realize the anti-causal inference structure, and is unmasked for the non-causal structure. 

\par
\textbf{Encoder}. Our encoder also uses the same blueprint as the decoder. To introduce the anti-causal structure the input is reversed, shifted and cropped by one in order to obtain the desired future context. Using one latent variable for each pixel is too inefficient in terms of computation so we encode each row of the image with a multidimensional latent variable.

\par
\textbf{Auxiliary Prior}.
\cite{vamprior, Hoffman2016, Geco} show that VAE performance can suffer when there is a significant mismatch between the
prior and the aggregate posterior, . When such a gap exists, the decoder is likely to have never seen samples from regions of the prior distribution where the aggregate posterior assigns small probability density.
This phenomenon, also known as the ``posterior holes'' problem \citep{Geco}, can be exacerbated in -VAEs, where the systematic mismatch between the prior and the posterior might induce a large gap between the prior and aggregate posterior. Increasing the complexity of the variational family can reduce this gap \citep{NF}, but require changes in the objective to control the rate and prevent posterior collapse \citep{IAF}. To address this limitation, we adopt the approaches of \citet{VQVAE, roy2018theory} and train an auxiliary prior over the course of learning to match the aggregate posterior, but that does not influence the training of the encoder or decoder. We used a simple autoregressive model for the auxiliary prior : a single-layer LSTM network with conditional-Gaussian outputs.

\subsubsection{Density Estimation Results}
We begin by comparing our approach to prior work on CIFAR-10 and downsampled ImageNet 32x32 in \tblref{tbl:nll}.
As expected, we found that the capacity of the employed autoregressive decoder had a large impact on the overall performance. Nevertheless, our models with latent variables have a negligible gap compared to their powerful autoregressive latent-free counterparts, while also learning informative latent variables. In comparison, \citep{VLAE} had a 0.03 bits per dimension gap between their latent variable model and PixelCNN++ architecture\footnote{the exact results for the autoregressive baseline was not reported in \cite{VLAE}}. On ImageNet 32x32, our latent variable model achieves on par performance with purely autoregressive Image Transformer \citep{ImageTransformer}. On CIFAR-10 we achieve a new state of the art of 2.83 bits per dimension, again matching the performance of our autoregressive baseline. Note that the values for KL appear quite small as they are reported in bits per dimension (e.g. 0.02 bits/dim translates to 61 bits/image encoded in the latents). The results on CIFAR-10 also demonstrate the effect of the auxiliary prior on improving the efficiency of the latent code; it leads to more than  (on average 30 bits per image) reduction in the rate of the model to achieve the same performance.

\begin{table}[ht]
\centering
\begin{tabular}{@{}l|llll@{}}
          & \textbf{CIFAR-10 Test} & \textbf{ImageNet  Valid}  \\ \hline \textbf{Latent Variable Models} & & \\
\,\,\,ConvDraw (\cite{ConvDraw})                           &   3.85  &  -    \\
\,\,\,DenseNet VLAE (\cite{VLAE})                      &   2.95         &  -    \\
\,\,\,-VAE + PixelSNAIL + AR(1) Prior             &   2.85 (0.02)   &   3.78 (0.08) \\
\,\,\,-VAE + PixelSNAIL + Auxiliary Prior         &   \textbf{2.83} (0.01)  &   \textbf{3.77} (0.07) \\
\hline \textbf{Autoregressive Models} & & \\
\,\,\,Gated PixelCNN(\cite{pixelcnn})     &  3.03         &  3.83    \\
\,\,\,PixelCNN++ (\cite{PixelCNN++})      &  2.92         &  -    \\
\,\,\,PixelRNN   (\cite{PixelRNN})        &  3.00         &  -    \\
\,\,\,ImageTransformer (\cite{ImageTransformer}) &  2.90         &  \textbf{3.77}    \\
\,\,\,PixelSNAIL (\cite{PixelSnail})      &  2.85         &  3.80    \\
\hline
\,\,\,Our Decoder baseline                &  \textbf{2.83} & \textbf{3.77} \\ 

\bottomrule
\end{tabular}
\caption{ Estimated upper bound on negative log-likelihood along with KL-divergence (in parenthesis) in bits per dimension for CIFAR-10 and downsampled ImageNet.}
\label{tbl:nll}
\end{table}


\subsection{Utilization of Latent Variables}
In this section, we aim to demonstrate that our models learn meaningful representations of the data in the latent variables. We first investigate the effect of  on the generated samples from the model. \figref{fig:samples-samez} depicts samples from an ImageNet model (see Appendix for CIFAR-10), where we sample from the decoder network multiple times conditioned on a fixed sample from the auxiliary prior. We see similar global structure (e.g. same color background, scale and structure of objects) but very different details. This indicates that the model is using the latent variable to capture global structure, while the autoregressive decoder is filling in local statistics and patterns.

\begin{figure}[h]
    \centering
    \begin{subfigure}{0.49\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/imagenet_same_z_samples_1.png}
        \caption{Multiple decoding of the same }        
        \label{fig:imagenet-samez}
    \end{subfigure}
    ~
    \begin{subfigure}{0.49\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/imagenet_aux_prior_samples_1.png}
        \caption{Random samples from the our Auxiliary prior}
        \label{fig:imagenet-aux}
    \end{subfigure}
    \caption{Random samples from our ImageNet  model. Each column in \figref{fig:imagenet-samez} shows multiple samples from  for a fixed . Each image in \figref{fig:imagenet-aux} is decoded using a different sample from .}
    \label{fig:samples-samez}
\end{figure}

For a more quantitative assessment of how useful the learned representations are for downstream tasks, we performed linear classification from the representation to the class labels on CIFAR-10. We also study the effect of the chosen rate of the model on classification accuracy as illustrated in \figref{fig:ra}, along with the performance of other methods. We find that generally a model with higher rate gives better classification accuracy, with our highest rate model, encoding 92 bits per image, giving the best accuracy of . However, we find that improved log-likelihood does not necessarily lead to better linear classification results.  We caution that an important requirement for this task is the linear separability of the learned feature space, which may not align with the desire to learn highly compressed representations.


\subsection{Ablation studies}\label{sec:ablation}
We performed more extensive comparisons of -VAE with other approaches to prevent posterior collapse on the CIFAR-10 dataset. We employ the same medium sized encoder and decoder for evaluating all methods as detailed in \aref{app:arch}.
\figref{fig:rd} reports the rate-distortion results of our experiments for the CIFAR-10 test set. To better highlight the difference between models and to put into perspective the amount of information that latent variables capture about images, the rate and distortion results in 
\figref{fig:rd} are reported in bits per images. We only report results for models that encode a non-negligible amount information in latent variables. Unlike the committed information rate approach of -VAE, most alternative solutions required considerable amount of effort to get the training converge or prevent the KL from collapsing altogether. For example, with linear annealing of KL \citep{Bowman2015}, despite trying a wide range of values for the end step of the annealing schedule, we were not able to train a model with a significant usage of latent variables; the KL collapsed as soon as  approached 1.0.
A practical advantage of our approach is its simple formula to choose the target minimum rate of the model. Targeting a desired rate in -VAE, on the other hand, proved to be difficult, as many of our attempts resulted in either collapsed KL, or very large KL values that led to inefficient inference. As reported in \cite{VLAE}, we also observed that optimising models with the free-bits loss was challenging and sensitive to hyperparameter values.
\par
To assess each methods tendency to overfit across the range of rates, we also report the rate-distortion results for CIFAR-10 training sets in ~\aref{app:abl}. While beta-VAEs do find points along the rate-distortion optimal frontier on the training set, we found that they overfit more than delta-VAEs, with delta-VAEs dominating the rate-distortion frontier on heldout data.

\begin{figure}[h]
    \vspace{-1cm}
    \centering
    \begin{subfigure}{0.49\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/rd.pdf}
        \caption{Rate-Distortion}        
        \label{fig:rd}
    \end{subfigure}
    ~
    \begin{subfigure}{0.49\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/ra.pdf}
        \caption{Rate vs. Classification Accuracy}
        \label{fig:ra}
    \end{subfigure}
    \caption{Comparison of CIFAR-10 test performance of -VAEs vs. models trained with free-bits and -VAE across many rates. -VAE is significantly more stable, achieves competitive density estimation results across different rates, and its learned representations perform better in the downstream linear classification task.} 
    \label{fig:rda}
\end{figure}

Next, we compare the performance of the anti-causal encoder structure with the non-causal structure on the CIFAR-10 dataset discussed in \sref{sec:anticausal}. The results for several configurations of our model are reported in the Appendix \tblref{tab:anticausal}. 
In  models where the decoder is not powerful enough (such as our 6-layer PixelCNN that has no attention and consequently a receptive field smaller than the causal context for most pixels), the anti-causal structure does not perform as well as the non-causal structure. The performance gap is however closed as the decoder becomes more powerful and its receptive field grows by adding self-attention and more layers. We observed that the anti-causal structure outperforms the non-causal encoder for very high capacity decoders, as well as for medium size models with a high rate. We also repeated these experiments with both anti-causal and non-causal structures
but without imposing a committed information rate or using other mitigation strategies, and found that neither structure by itself is able to mitigate the posterior collapse issue; in both cases the KL divergence drops to negligible values ( bits per dimension) only after a few thousand training steps and never recovers. 


\subsection{Text}

For our experiments on natural language, we used the 1 Billion Words or LM1B \citep{lm1b} dataset in its processed form in the Tensor2Tensor \citep{tensor2tensor} codebase \footnote{https://github.com/tensorflow/tensor2tensor}. 
Our employed architecture for text closely follows the Transformer network of \cite{Vaswani2017}. Our sequence of latent variables has the same number of elements as in the number of tokens in the input, each having two dimensions with  and . Our decoder uses causal self-attention as in \cite{Vaswani2017}. For the anti-causal structure in the encoder, we use the inverted causality masks as in the decoder to only allow looking at the current timestep and the future. 
\par
Quantitatively, our model achieves slightly worse log-likelihood compared to its autoregressive counterpart (\tblref{tbl:lm1b}), but makes considerable use of latent variables, as demonstrated by the samples and interpolations in \aref{app:samples}.
\begin{table}[ht]
\centering
\begin{tabular}{@{}l|lll@{}}
    & AR(1) ELBO (KL)  & Aux prior ELBO (KL) &  AR baseline NLL  \\
\hline    
-VAE   &   &   &  \\
\bottomrule
\end{tabular}
\caption{The result of our text experiments on LM1B in nats / token.}
\label{tbl:lm1b}
\end{table}

 \section{Discussion}
In this work, we have demonstrated that -VAEs provide a simple, intuitive, and effective solution to posterior collapse in latent variable models, enabling them to be paired with powerful decoders. Unlike prior work, we do not require changes to the objective or weakening of the decoder, and we can learn useful representations as well as achieving state-of-the-art likelihoods. While our work presents two simple posterior-prior pairs, there are a number of other possibilities that could be explored in future work. Our work also points to at least two interesting challenges for latent-variable models: (1) can they exceed the performance of a strong autoregressive baseline, and (2) can they learn representations that improve downstream applications such as classification? 

\subsubsection*{Acknowledgments}
We would like to thank Danilo J. Rezende, 
Sander Dieleman, Jeffrey De Fauw,
Jacob Menick, Nal Kalchberner, Andy Brock, Karen Simonyan and Jeff Donahue for their help, insightful discussions and valuable feedback.


\bibliography{anon}
\bibliographystyle{anon}

\appendix

\section{Derivation of the KL divergence for sequential latent variables}\label{app:seqkl}




\section{Derivation of the KL-divergence between AR(1) and diagonal Gaussian, and its lower-bound}


Noting the analytic form for the KL-divergence for two uni-variate Gaussian distributions:


we now derive the lower-bound for KL-divergence.  Without loss of generality and to avoid clutter, we have assume the mean vector  has equal values in each dimension.\cite{Newell81}.




Where . Using the fact that , the  expectation inside the summation can be simplified as follows.


Plugging this back gives us the following analytic form for the KL-divergence for the sequential latent variable .



\section{Derivation of the lower-bound}\label{app:deriv}

Removing non-negative quadratic terms involving  in \eqref{eq:klseq} and expanding back  inside the summation yields



Consider  and its first and second order derivatives,   and . Thus,  is convex  and obtains its minimum value of  at . Substituting ,  and  yields the following lower-bound for the KL:



When using multi-dimensional  at each timestep, the committed rate is the sum of the KL for each individual dimension:







\section{Independent -VAEs}
\label{app:indep}
 The most common choice for variational families is to assume that the components of the posterior are independent, for example using a multivariate Gaussian with a diagonal covariance: . When paired with a standard Gaussian prior, , we can guarantee a committed information rate   by constraining the mean and variance of the variational family (see \aref{app:deriv})
 

We can, thus, numerically solve 

to obtain the feasible interval  where the above equation has a solution for , and the committed rate . Posterior parameters can thus be parameterised as:

Where  parameterises the data-dependent part of  ad , which allow the rate to go above the designated lower-bound . 

We compare this model with the temporal version of -VAE discussed in the paper and report the results in \tblref{tbl:indep-ablation}. While independent -VAE also prevents the posterior from collapsing to prior, its performance in density modeling lags behind temporal -VAE. 

\begin{table}[h]
    \centering
    \begin{tabular}{l|ll}
        \textbf{Method} &  Test ELBO (KL)     &  Accuracy  \\
        \toprule
         Independent -VAE  () & 3.08 (0.08) & 66\% \\
         Temporal -VAE  () & 3.02 (0.09)    & 65\% \\
         \bottomrule
    \end{tabular}
    \caption{Comparison of independent Gaussian delta-VAE and temporal delta-VAE with AR(1) prior on CIFAR-10 both targeting the same rate. While both models achieve a KL around the target rate and perform similarly in the downstream linear classification task, the temporal model with AR(1) prior achieves significantly better marginal likelihood.}
    \label{tbl:indep-ablation}
\end{table}

\section{Architecture Details}\label{app:arch}

\subsection{Image models}

In this section we provide the details of our architecture used in our experiments. The overall architecture diagram is depicted in
\figref{fig:arch}. To establish the anti-causal context for the inference network we first reverse the input image and pad each spatial dimension by one before feeding it to the encoder. The output of the encoder is cropped and reversed again. As show in \figref{fig:arch}, this gives each pixel the anti-causal context (i.e., pooling information from its own value and future values). We then apply average pooling to this representation to give us row-wise latent variables, on which the decoder network is conditioned. 

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/arch.pdf}
    \caption{Architecture for images}
    \label{fig:arch}
\end{figure}


The exact hyper-parameters of our network is detailed in \tblref{tbl:hyp}. We used dropout only in our decoder and applied it
the activations of the hidden units as well as the attention matrix. As in \citep{Vaswani2017}, we used rectified linear units and layer normalization \citep{layernorm} after the multi-head attention layers. We found layer normalization to be essential for stabilizing training. For optimization we used the Adam optimizer \citep{adam}. We used the learning rate schedule 
proposed in \citep{Vaswani2017} with a few tweaks as in the formulae:



    
We use multi-dimensional latent variables per each timestep, with different slowness factors linearly spaced between a chosen interval. For our ablation studies, we chose corresponding hyper-parameters of each method we compare against to target rates between 25-100 bits per image.

\begin{table}[h]
\centering
\begin{tabular}{@{}l|lllllllll@{}}
                    &   &  &  &  &  & &  &  & \\
\toprule
\textbf{Best} \\
Imagenet   & 6/20 & 128/512/1024 &  1024/2048 & 2/5 & 8 & 32 & 0.3 & 16 & [0.5, 0.95] \\
CIFAR-10     & 20/30 & 128/256/1024 &  1024/1024 & 11/16 & 8 & 32 & 0.5 & 8 & [0.3, 0.99] \\
\midrule
\textbf{Ablations} \\
CIFAR-10 & 8/8 & 128/128/1024 & 1024/1024 & 2/2 & 2 & 32 & 0.2 & 32 &\shortstack{[0.5, \\ 0.68-0.99]} \\
\bottomrule
\end{tabular}
\caption{Hyperparameter values for the models used for experiments. The subscripts , ,  respectively denote the encoder, the decoder, and the LSTM auxiliary prior.  is the number of layers,  is the hidden size of each layer,  is the size of the residual filter,  is the number of attention layers interspersed with gated convolution layers of PixelCNN,  is the number of components in the discrete mixture of logistics distribution,  is the probability of dropout applied to the decoder,  is the dimensionality of the latent variable used for each row, and the  column gives the range of of the AR(1) prior hyper-parameter for each latent.}\label{tbl:hyp}
\end{table}

We developed our code using Tensorflow \citep{tensorflow}. Our experiments on natural images were conducted on Google Cloud TPU accelerators. For ImageNet, we used 128 TPU cores with batch size of 1024. We used 8 TPU cores for CIFAR-10 with batch size of 64.




\subsection{Text Models}
The architecture of our model for text experiment is closely based on the Transformer network of \cite{Vaswani2017}. We realize the encoder anti-causal structure by inverting the causal attention masks to upper triangular bias matrices. The exact hyper-parameters are summarized in \tblref{tbl:txthyp}.

\begin{table}[ht]
\centering
\begin{tabular}{@{}l|llllllllll@{}}
                    &   &  &  &  &  &  & \\
\toprule
LM1B     & 4 & 512&  2048 & 8 & 0.1 & 2 & [0.2, 0.4] \\
\bottomrule
\end{tabular}
\caption{Hyperparameter values for our LM1B experiments.  is the number of layers,  is the hidden size of each layer,  is the size of the residual filters,  is the probability of dropout,  is the dimensionality of the latent variable, and the  column gives the range of of the AR(1) prior hyper-parameter for each latent dimension.}\label{tbl:txthyp}
\end{table}

\section{Ablation Studies}\label{app:abl}
For our ablation studies on CIFAR-10, we trained our model with the configuration listed in \tblref{tbl:hyp}. After training the model, we inferred the mean of the posterior distribution corresponding to each training example in the CIFAR-10 test set, and subsequently trained a multi-class logistic regression classifier on top of it. For each model, the linear classifier was optimized for 100 epochs using the Adam optimizer with the starting learning rate of . The learning rate was decayed by a factor of  every 30 epochs.

We also report the rate-distortion curves for the CIFAR-10 training set in \figref{fig:rdt}. In contrast to 
the graph of \figref{fig:rd} for the test set, -VAE achieves relatively higher negative log-likelihood compared to other methods on the training seen, especially for larger rates. This suggests that -VAE is less prone to overfitting compared to -VAE and free-bits.
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.49\textwidth]{figures/rdt.pdf}
    \caption{Rate-Distortion for CIFAR-10 training set.}        
    \label{fig:rdt}
\end{figure}

\subsection{Encoder Ablation}\label{app:encabl}
In table \tblref{tab:anticausal}, we report the details of evaluating our proposed anti-causal encoder architecture (discussed in \sref{sec:anticausal}) against the non-causal architecture in which there is no restriction in the connectivity of the encoder network. The reported experiments are conducted on the CIFAR-10 dataset. We trained 4 different configurations of our model to provide comparison in different capacity and information rate regimes, using the temporal -VAE approach to prevent posterior collapse.  We found that the anti-causal structure is beneficial when the decoder has sufficiently large receptive field, and also when encoding relatively high amount of information in latent variables.

\begin{table}[h]
    \centering
    \begin{tabular}{l|l|l|l|l}
         & \begin{tabular}{@{}l}\\ \\  \\ low-rate\end{tabular}
         & \begin{tabular}{@{}l}\\ \\ \\ low-rate\end{tabular}
         & \begin{tabular}{@{}l}\\ \\ \\  high-rate\end{tabular}
         & \begin{tabular}{@{}l},\\,\\\\ low-rate \end{tabular}\\
         \toprule
         Non-Causal AR(1) &  3.04 (0.02)  & 3.01 (0.03)  & 3.32 (0.22) & 2.88 (0.05)\\
         Non-Causal Aux  &  3.03 (0.01)  &  2.98 (0.004)  & 3.11 (0.02) & 2.85 (0.01)\\
         \hline
         Anti-Causal AR(1) &  3.07 (0.02) & 3.01 (0.03)  & 3.22 (0.22) & 2.87 (0.05)\\
         Anti-Causal Aux &  3.06 (0.01)  &  2.98 (0.006) & 3.03 (0.03) & 2.84 (0.02)\\
         \bottomrule
    \end{tabular}
    \caption{Ablation of anti-causal vs. non-causal structure. : number of layers, : hidden size, : number of attention layers. Subscripts  and  respectively denote encoder and decoder sizes, when they were different.
    The \textit{low-rate} (\textit{high-rate}) models had latent dimension of 8 (64) with  linearly placed in  () which gives the total rate of  () bits per image.}
    \label{tab:anticausal}
\end{table}


\section{Visualization of the Latent Space}
It is generally expected that images from the same class are mapped to the same region of the latent space. \figref{fig:tsne} illustrates the t-SNE \citep{TSNE} plot of latent variables inferred from 3000 examples from the test set of CIFAR-10 colour coded based on class labels. As can also be seen on the right hand plot classes that are closest are also mostly the one that have close semantic and often visual relationships (e.g., cat and dog, or deer and horse). 

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/tsne2.png}
    \caption{t-SNE plot of the posterior mean for 3000 CIFAR-10 images. Note the adjacent groups and mixed regions of the plot: cats and dogs images are mostly interspersed as are automobiles and trucks.The highest concentration of horses are on top of the region right above where deer examples are.
    }
    \label{fig:tsne}    
\end{figure}

\section{Additional Samples}\label{app:samples}


\begin{figure}[h!]
    \centering
    \includegraphics[width=0.49\textwidth]{figures/imagenet_interp_z_samples_1.png}
    \includegraphics[width=0.49\textwidth]{figures/imagenet_daydream_samples_1.png}
    \includegraphics[width=0.49\textwidth]{figures/imagenet_part_rec_z_samples_1.png}
    \includegraphics[width=0.49\textwidth]{figures/imagenet_full_rec_z_samples_1.png}
    \label{fig:more-imagenet-samez}
    \caption{Additional ImageNet samples. Top left: Each column is interpolation in the latent space.
     Top right: "Day dream" samples where we alternate between sampling  and .
     Bottom left: Each half-column contains in order an original image from the validation set, occlusion of
     that image, and two reconstructions from different posterior samples.
     Bottom right: Each half-column contains in order an original image from the validation set, followed by 3
     reconstructions from different posterior samples.}
\end{figure}

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.49\textwidth]{figures/cifar10_z64_interp_z_samples_1.png}
    \includegraphics[width=0.49\textwidth]{figures/cifar10_z64_daydream_samples_1.png}
    \includegraphics[width=0.49\textwidth]{figures/cifar10_z64_part_rec_z_samples_1.png}
    \includegraphics[width=0.49\textwidth]{figures/cifar10_z64_full_rec_z_samples_1.png}
    \label{fig:more-imagenet-samez}
    \caption{Additional CIFAR-10 samples. Top left: Each column is interpolation in the latent space.
     Top right: "Day dream" samples where we alternate between sampling  and .
     Bottom left: Each half-column contains in order an original image from the test set, occlusion of
     that image, and two reconstructions from different posterior samples.
     Bottom right: Each half-column contains in order an original image from the test set, followed by 3
     reconstructions from different posterior samples.}
\end{figure}


\begin{figure}[h!]
    \centering
    \includegraphics[width=0.49\textwidth]{figures/cifar10_z64_aux_prior_samples_1.png}
    \includegraphics[width=0.49\textwidth]{figures/cifar10_z64_prior_samples_1.png}
    \includegraphics[width=0.49\textwidth]{figures/cifar10_cirvae_aux_prior.png}
    \includegraphics[width=0.49\textwidth]{figures/cifar10_cirvae_prior.png}
    \label{fig:more-imagenet-samez}
    \caption{Random samples from the auxiliary (left) and AR(1) (right)  priors 
     of our high-rate (top) and low-rate(bottom) CIFAR-10 models.
     The high-rate (low-rate) model has -ELBO of 2.90 (2.83) and KL of 0.10 (0.01) bits/dim.
     Notice that in the high rate model that has a larger value of , samples from the AR(1)
     prior can turn out too smooth compared to natural images. This is because of the gap between the prior
     and the marginal posterior, that is closed by the auxiliary prior.}
\end{figure}



\begin{figure}[h!]
    \centering
    \includegraphics[width=0.49\textwidth]{figures/imagenet_same_z_samples_8.png}
    \includegraphics[width=0.49\textwidth]{figures/imagenet_same_z_samples_9.png}
    \includegraphics[width=0.49\textwidth]{figures/imagenet_same_z_samples_10.png}
    \includegraphics[width=0.49\textwidth]{figures/imagenet_same_z_samples_13.png}
    \label{fig:more-imagenet-samez}
    \caption{Additional unconditional random samples from Imagenet 32x32. 
    Each half-column in each block contains 4 decodings of the same sample }
\end{figure}


\begin{figure}[h!]
\centering
\begin{tcolorbox}

\small
====  Interpolating dimension 0 ====\\
\textup{The company's stock price is also up for a year-on-year rally, when the}\\
\textup{The company's shares are trading at a record high for the year, when they were trading at}\\
\textup{The company's shares were trading at \1.14, or 5.7 percent, to \2.15 to \\mu \pm 3\sigma2.2 billion.}\\

\textup{
\textbf{The company is now the world's} third-largest producer of the drug, after Pfizer and AstraZeneca, which is based in the UK.}\\

\textup{
\textbf{The company is now the world's} biggest producer of the popular games console, with sales of more than \3bn in the UK.}\\
\textup{
\textbf{The company is now the world's} largest company, with over \4.2 billion (£2.6 billion) and an annual turnover of \$400 million  (£343 million).}\\

\end{tcolorbox}
\caption{Text completion samples. For each sentence we prime the decoder with a fragment of a random sample
from the validation set (shown in bold), and condition the decoder on interpolations between two samples from the latent space.}\label{fig:txtint}
\end{figure}



 
\end{document}
