\documentclass{LMCS}

\usepackage{proof}
\usepackage[all]{xy}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{latexsym}
\usepackage{hyperref}

\newcommand{\unit}{\mathsf{unit}}
\newcommand{\val}{\mathsf{val}}
\newcommand{\mint}{\mathsf{int}}
\newcommand{\mlist}{\mathsf{list}}
\newcommand{\com}{\mathsf{com}}

\newcommand{\Spec}{\mathsf{Specs}}
\newcommand{\Assert}{\mathsf{Assertion}}


\newcommand{\new}{\mathsf{new}}
\newcommand{\free}{\mathsf{free}}
\newcommand{\nil}{\mathsf{nil}}
\newcommand{\cons}{\mathsf{cons}}
\newcommand{\listcase}{\mathsf{listcase}}
\newcommand{\ifz}{\mathsf{if}}
\newcommand{\fix}{\mathsf{fix}}
\newcommand{\mletin}[2]{\mathsf{let}\;{#1}\;\mathsf{in}\;{#2}}
\newcommand{\mlet}[1]{\mathsf{let}\;{#1}\;\mathsf{in}} 

\newcommand{\blank}{\mbox{-}}

\newcommand{\id}{\mathsf{id}}
\newcommand{\perm}{\mathsf{perm}}
\newcommand{\proj}{\mathsf{proj}}
\newcommand{\zero}{\mathsf{z}}
\newcommand{\msucc}{\mathsf{s}}
\newcommand{\letvin}[3]{\mathsf{let}\,{[{#1}]}\,{=}\,{#2}\,\mathsf{in}\,{#3}}

\newcommand{\emp}{\mathsf{emp}}
\newcommand{\pointsto}{\mapsto}


\newcommand{\Loc}{\mathit{Loc}}
\newcommand{\Heap}{\mathit{Heap}}
\newcommand{\Obs}{\mathit{O}}
\newcommand{\Good}{\mathit{G}}
\newcommand{\CPO}{\mathcal{C}}
\newcommand{\HYP}{\mathcal{H}}
\newcommand{\cR}{\mathcal{R}}
\newcommand{\cont}{\mathit{Cont}}
\newcommand{\sval}{\mathit{Val}}
\newcommand{\sint}{\mathit{Int}}

\newcommand{\lfix}{\mathit{leastfix}}
\newcommand{\Emp}{\mathit{Emp}}
\newcommand{\snil}{\mathit{nil}}
\newcommand{\ssucc}{\mathit{succ}}
\newcommand{\prim}{\mathit{primrec}}
\newcommand{\normal}{\mathit{normal}}
\newcommand{\error}{\mathit{err}}
\newcommand{\default}{\mathit{default}}

\newcommand{\mperp}{{\bot{\!\!}\bot}}
\newcommand{\fin}{\mathsf{fin}}
\newcommand{\FV}{\mathsf{fv}}
\newcommand{\dom}{\mathsf{dom}}
\newcommand{\bind}{{\scriptstyle\relax\rightarrow}}
\newcommand{\supp}{\mathsf{supp}}

\newcommand{\ff}[1]{[\![#1]\!]}
\newcommand{\cff}[1]{\llparenthesis#1\rrparenthesis}
\newcommand{\lrel}[1]{\langle\!\langle#1\rangle\!\rangle}

\newcommand{\key}[1]{{\sf #1}}

\newcommand{\ifthen}[2]{\key{if}\; #1 \; \key{then}\; #2}
\newcommand{\Ifthen}[2]{\begin{array}[t]{@{}l}
            \key{if}\; #1 \\
            \hspace{1em} \key{then}\; #2
            \end{array}}
\newcommand{\ifthenElse}[3]{\key{if}\; #1 \;\key{then}\; #2 \;\key{else}\; #3}
\newcommand{\IfthenElse}[3]{\begin{array}[t]{@{}l}
                \key{if}\; #1\; \key{then}\; #2 \\
                \key{else}\; #3
                \end{array}}
\newcommand{\mIfthenElse}[3]{\begin{array}[t]{@{}l}
                \key{if}\; #1\\
		\key{then}\; #2 \\
                \key{else}\; #3
                \end{array}}

\newcommand{\letin}[2]{\key{let}\; #1 \;\key{in}\; #2}
\newcommand{\letrec}[2]{\key{letrec}\; #1 \;\key{in}\; #2}
\newcommand{\letdyn}[2]{\key{letdyn}\; #1 \;\key{in}\; #2}
\newcommand{\Letin}[2]{\begin{array}[t]{@{}l}
                        \key{let}\; #1 \\
                        \key{in}\; #2
                       \end{array}}
\newcommand{\letbe}[3]{\key{let}\; #1 \; \key{be}\; #2 \;\key{in}\; #3}
\newcommand{\Letbe}[3]{\begin{array}[t]{@{}l}
                        \key{let}\; #1 \; \key{be}\; #2 \\
                        \key{in}\; #3
                       \end{array}}

\newcommand{\mtri}[3]{\{{#1}\}{#2}\{{#3}\}}
\newcommand{\ctri}[3]{\{{#1}\}\,{#2}\,\{{#3}\}}
\newcommand{\etri}[3]{\langle{#1}\rangle\,{#2}\,\langle{#3}\rangle}
\newcommand{\squad}[4]{{[{#1}]}
                        ({#2},  {#3})
                       {[{#4}]}}
\newcommand{\mquad}[4]{\{{#1}\}
                       {\small 
                        \begin{array}{@{\,}c@{\,}}
                        {#2} \\
                        {#3}
                        \end{array}}
                       \{{#4}\}}
\newcommand{\cquad}[4]{\{{#1}\}
                       {\small 
                        \begin{array}{@{\,}c@{\,}}
                        {#2} \\
                        {#3}
                        \end{array}}
                       \{{#4}\}}
\newcommand{\equad}[4]{\langle{#1}\rangle
                       {\small
                        \begin{array}{@{\,}c@{\,}}
                        {#2} \\
                        {#3}
                        \end{array}}
                       \langle{#4}\rangle}

\newcommand{\EQ}{\mathsf{eq}}


\newcommand{\defeq}{\stackrel{\mathit{def}}{=}}
\newcommand{\defsiff}{\stackrel{\mathit{def}}{\Leftrightarrow}}
\newcommand{\defliff}{\stackrel{\mathit{def}}{\iff}}

\newcommand{\cps}{\mathsf{cps}}
\newcommand{\fst}{\mathsf{fst}}

\newcommand{\init}{\mathsf{init}}
\newcommand{\inc}{\mathsf{inc}}
\newcommand{\mread}{\mathsf{read}}

\newcommand{\push}{\mathsf{push}}
\newcommand{\pop}{\mathsf{pop}}

\newcommand{\then}{\mathsf{then}}
\newcommand{\melse}{\mathsf{else}}

\newcommand{\data}{\mathsf{data}}
\newcommand{\mnext}{\mathsf{next}}

\newcommand{\hongseokcomment}[1]{
\begin{center}
\fbox{
\begin{minipage}{5.5in}
{\bf Hongseok's comment:} {\it #1}
\end{minipage}
}
\end{center}
}
\newcommand{\larscomment}[1]{
\begin{center}
\fbox{
\begin{minipage}{5.5in}
{\bf Lars's comment:} {\it #1}
\end{minipage}
}
\end{center}
}

\def\doi{4 (2:6) 2008}
\lmcsheading {\doi}
{1--27}
{}
{}
{Sep.~21, 2007}
{May~15, 2008}
{}   


\begin{document}


\title[Relational Parametricity and Separation Logic]
{Relational Parametricity and Separation Logic}

\author[L.~Birkedal]{Lars Birkedal\rsuper a}
\address{{\lsuper a}IT University of Copenhagen, Denmark}
\email{birkedal@itu.dk}

\author[H.~Yang]{Hongseok Yang\rsuper b}
\address{{\lsuper b}Queen Mary, University of London, UK}
\email{hyang@dcs.qmul.ac.uk}

\keywords{Program Verification, Separation Logic, Parametricity, Data 
Abstraction} 
\subjclass{F.3, D.3}

\begin{abstract}
  Separation logic is a recent extension of Hoare logic for reasoning about
  programs with references to shared mutable data structures.  In this paper, we
  provide a new interpretation of the logic for a programming language with
  higher types. Our interpretation is based on Reynolds's relational
  parametricity, and it provides a formal connection between separation
  logic and data abstraction.
\end{abstract}

\maketitle

\section{Introduction}

Separation
logic~\cite{reynolds02,ohearn-reynolds-yang01,birkedal-torpsmith-reynolds-popl04}
is a Hoare-style program logic, and variants of it have been applied
to prove correct interesting pointer algorithms such as copying a dag,
disposing a graph, the Schorr-Waite graph algorithm, and Cheney's
copying garbage collector.  The main advantage of separation logic
compared to ordinary Hoare logic is that it facilitates \emph{local
  reasoning}, formalized via the so-called \emph{frame rule} using a
connective called \emph{separating conjunction}.  The development of
separation logic initially focused on \emph{low-level} languages with
heaps and pointers, although in recent
work~\cite{yang-ohearn-reynolds-popl04,birkedal-torpsmith-yang-lics05} 
it was shown how to extend
separation logic first to
languages with a simple kind of
procedures~\cite{yang-ohearn-reynolds-popl04}
and then to languages also with
higher-types~\cite{birkedal-torpsmith-yang-lics05}.
Moreover, in~\cite{yang-ohearn-reynolds-popl04} a second-order frame rule
was proved sound and in~\cite{birkedal-torpsmith-yang-lics05} a whole range
of higher-order frame rules were proved sound for a separation-logic type
system. 

In~\cite{yang-ohearn-reynolds-popl04}
and~\cite{birkedal-torpsmith-yang-lics05}
it was explained how second and higher-order frame rules can be used
to reason about static imperative modules. The idea is roughly as
follows. Suppose that
we prove a specification for a client , depending
on a module ,

The proof of the client depends only on the ``abstract specification''
of the module, which describes the external behavior of . 
Suppose further that an actual implementation 
 of the module satisfies

Here  is the internal resource invariant of the module , describing
the internal heap storage used by the module  to implement the abstract
specification. We can then employ a (higher-order) frame rule on the specification for the
client to get

and combine it with the specification for  to obtain

A key advantage of this approach to modularity is that it facilitates
so-called ``ownership transfer.'' For example, if the module is a queue, 
then the ownership of cells transfers from the client to module upon
insertion into the queue. Moreover, the discipline allows clients to
maintain pointers into cells that have changed ownership to the module. 
See~\cite{yang-ohearn-reynolds-popl04} for examples and more explanations
of these facts.

Note that the higher-order frame rules in essence provide implicit
quantification over internal resource invariants.
In~\cite{biering-birkedal-torpsmith-esop05}
it is shown how one can employ a higher-order version of separation logic,
with explicit quantification of assertion predicates to reason about dynamic
modularity (where there can be several instances of the same abstract data
type implemented by an imperative module), see
also~\cite{parkinson-bierman-popl05}. The idea is to
existentially quantify over the internal resource invariants in
a module, so that in the above example,
 would depend on a specification for  of the form

As emphasized in the papers mentioned above, note that,
both in the case of implicit quantification over internal resource
invariants (higher-order frame rules) and in the case of explicit
quantification over internal resource invariants (existentials over
assertion predicates), reasoning about a client does not depend on the
internal resource invariant of possible module implementations.
Thus the methodology allows us to formally reason about \emph{mutable
abstract data types}, aka. \emph{imperative modules}.

However, the semantic models in the papers mentioned 
above do not allow us to make all the conclusions we would expect from
reasoning about mutable abstract data types. 
In particular, we would expect that \emph{clients should behave parametrically 
in the internal resource invariants}: When a client is applied to 
two different implementations of a mutable abstract data type, 
it should be the case that the client preserves 
relations between the internal resource invariants of the two
implementations. This is analogous to Reynolds's style 
relational parametricity for abstract data types with quantification over
type variables~\cite{reynolds}.

\begin{figure*}[t]
\hrule




\hrule
\caption{Counter Modules}
\label{fig:counters}
\end{figure*}

To understand this issue more clearly, 
consider the two implementations of a counter 
in Figure~\ref{fig:counters}.
A counter has three operations: 
 for initializing the counter, 
and  and  for increasing and reading
the value of the counter.
In the first implementation, 

takes a heap cell  containing
an initial value for the counter, and stores its address  
in the internal variable , thereby setting the value
of the counter to the contents of . The intention is that
when a client program calls this 
initialization routine with cell , it should
transfer the ownership of the cell to the counter -- 
it should not dereference the cell after calling .
The operation  increases the value of 
the transferred cell , and  returns
the value of cell , by storing it in a pre-determined
global variable . The second 
implementation is almost identical to the first, except that
the value of the counter is negated. Thus, when
 is the relation that relates a heap containing 
cell  and variable  with the same heap with the value of 
cell 
negated, all operations of these two implementations preserve
this relation .

Now suppose that we are given a client program of the form

whose body  satisfies the following
specification in separation logic:

for some  that do not mention cell .
We expect that the body  of the client preserves the relation  of the
two implementations, and that the client cannot detect the difference
between the two. Our expectation is based on the specification for ,
which says that the triple  can be proved in
separation logic, assuming only the ``abstract specification'' of the
 and  operations, where all the internal resources of the
module, such as cell , are hidden. This provability should prevent 
from accessing the internal resources of a counter directly and thus
detecting the difference between the two implementations.  However, none of the
existing models of separation logic can justify our expectation on the
client program above.

In this paper we provide a new parametric model of separation 
logic, which
captures that clients behave parametrically in internal resource
invariants of mutable abstract data types. For instance,
our model shows that  preserves
the relation , and thus it behaves
in the same way no matter whether we use the first or second
implementation of a counter. In the present paper,
we will focus on the implicit approach to quantification over
internal resource invariants via higher-order frame rules, since it is
technically simpler than the explicit approach.\footnote{The reason is that the
implicit quantification of separation logic uses quantification in a very
disciplined way so that the usual reading of assertions as sets of heaps
can be maintained; if we use quantification without any restrictions, 
as in \cite{Benton-CSL06}, it
appears that we cannot have the usual reading of assertions as sets of
heaps because, then, the rule of consequence is not sound.}

Our new model of separation logic is based on two novel ideas.
The first is to read specifications in separation logic
as relations
between two programs. For instance, in our model, the Hoare 
triple  describes 
a relationship between two instantiations
 and  of
the client's body  by environments  and .
Intuitively, environment  defines an implementation
of module operations  and 
, so  means 
 is linked with
the implementation  and .
Note that when used with appropriate 
(i.e.,  that maps  and  to
the meaning of  and ), 
the triple expresses how 
 
is related to .

The second idea is to parameterize the interpretation by
relations on heaps.
Mathematically, this means that the interpretation uses
a Kripke structure that consists of relations on heaps. 
The relation parameter describes
how the internal resource invariants of
two modules are related, and it lets us express the preservation
of this relation by client programs. In our counter example,
an appropriate parameter is the relation  above. When
the triple  is interpreted with
 (and  corresponding to ), 
it says, in particular, that
 and 
should preserve the relation  between the internal resources
of the two implementations of a counter.


\subsection{Related Work}
\label{sec:related-work} 
Technically, it has proven to be a very non-trivial problem to define
a parametric model for separation logic. 
One of the main technical challenges in developing a relationally
parametric model of separation logic, even for a simple first-order
language, is that the standard models of separation logic allow the
identity of locations to be observed in the model.  This means in
particular that allocation of new heap cells is not parametric because the
identity of the location of the allocated cell can be observed in the
model.  (We made this observation in earlier unpublished joint work with
Noah Torp-Smith, see~\cite[Ch.~6]{torp-smith-phd-2005}.)

This problem of non-parametric memory allocation has also been noticed by
recent work on data refinement for heap storage, which exploits semantic
ideas from separation logic
\cite{mijajlovic-torpsmith-ohearn-fsttcs04,mijajlovic-yang-aplas05}.
However, the work on data refinement does not provide a satisfactory
solution.  Either it avoids the problem by assuming that clients do not
allocate cells~\cite{mijajlovic-torpsmith-ohearn-fsttcs04}, or its solution
has difficulties for handling higher-order procedures and formalizing
(observational) equivalences, not refinements, between two implementations
of a mutable abstract data type \cite{mijajlovic-yang-aplas05}.

Our solution to this challenge is to define a more refined semantics of the
programming language using FM domain theory, in the style of Benton and
Leperchey~\cite{benton}, in which one can name locations but not observe the
identity of locations because of the built-in use of permutation of
locations. 
Part of the trick of \emph{loc. cit.} is to define the semantics
in a continuation-passing style so that one can ensure that new locations
are suitably fresh with respect to the remainder of the computation. (See
Section~\ref{sec:semantics-pl} for more details.)  Benton and Leperchey
used the FM domain-theoretic model to reason about contextual equivalence
and here we extend the approach to give a semantics of separation logic in
a continuation-passing style. We relate this new interpretation to the
standard direct-style interpretation of separation logic via the so-called
observation closure  of a relation, see
Section~\ref{sec:quadruples}.

The other main technical challenge in developing a relationally parametric
model of separation logic for reasoning about mutable abstract data types
is to devise a model which validates a wide range
of higher-order frame rules.  Our solution to this challenge is to
define an intuitionistic interpretation of the specification
logic over a Kripke structure, whose ordering relation intuitively
captures the framing-in of resources.
Technically, the intuitionistic interpretation, in particular the
associated Kripke monotonicity, is used to validate a generalized frame rule.
Further, to show that the semantics of the logic does indeed satisfy
Kripke monotonicity for the base case of triples, we
interpret triples using a universal quantifier, which
intuitively quantifies over resources that can possibly be framed in.
In the earlier non-parametric model of higher-order frame rules for
separation-logic typing in~\cite{birkedal-torpsmith-yang-lics05} we also
made use of a Kripke structure. The difference is that in the present work
the elements of the Kripke structure are \emph{relations} on heaps rather than
predicates on heaps because we build a \emph{relationally} parametric
model.

In earlier work, Banerjee and Naumann~\cite{banerjee:naumann:jacm} studied
relational parametricity for dynamically allocated heap objects in a
Java-like language. Banerjee and Naumann made use of a non-trivial semantic
notion of confinement to describe internal resources of a module; here
instead we use separation logic, in particular separating conjunction and
frame rules, to describe which resources are internal to the module.  Our
model directly captures that whenever a client has been proved correct in
separation logic with respect to an abstract view of a module, then it does
not matter how the module has been implemented internally. And, this holds
for a higher-order language with higher-order frame rules.

This paper is organized as follows.
In Section~\ref{sec:programs-and-assertions} we describe the
programming and assertion languages we consider and in
Section~\ref{sec:separation-logic} we define our version of separation
logic.  In Section~\ref{sec:semantics-pl} we define the semantics of our
programming language in the category of FM-cpos, and describe our
relational interpretation of separation logic in
Section~\ref{sec:reln-int-of-sep-logic}. In
Section~\ref{sec:general-construction} we present a general abstract
construction that provides models of specification logic with higher-order
frame rules and show that the semantics of the previous section is in fact
a special case of the general construction. 
Section~\ref{sec:quadruples}
relates our relational interpretation to the standard interpretation of
separation logic, and in Section~\ref{sec:abstraction-theorem} we present
the abstraction theorem that our parametric model validates. 
We describe examples in Section~\ref{sec:examples}, and
finally we conclude and discuss future work in
Section~\ref{sec:discussion-futurework}.

An extended abstract of this paper was presented at the FOSSACS 2007
conference~\cite{birkedal-yang-fossacs07}. This paper includes proofs that
were missing in the conference version, and describes a general
mathematical construction that lies behind our parametric model of
separation logic. We also include a new example that illustrates the
subtleties of the problems and results.



\section{Programs and Assertions}
\label{sec:programs-and-assertions}
In this paper, we consider a 
higher-order language with immutable stack variables.
The types and terms of the language are defined as follows:
{
}
The language separates expressions  from terms .
Expressions denote heap-independent values, which
are either the address of a heap cell or an integer.
Expressions are bound to 
{\em stack variables} . On the other hand,
terms denote possibly heap-dependent computations,
 and  they
are bound to {\em identifiers} . The syntax
of the language ensures that expressions always
terminate, while terms can diverge. The types are
used to classify terms only.  denotes commands, 
 means functions
that take an expression parameter, and
 denotes functions that
takes a term parameter. Note that to support
two different function types, the language
includes two kinds of abstraction and application,
one for expression parameters and the other for term 
parameters. We assume that term parameters are
passed by name, and expression parameters are
passed by value.

To simplify the presentation, we take a simple storage
model where each heap cell has only two fields  and .
Command 
 allocates such a binary heap cell, binds the 
address of the cell to , and runs  under this binding.
The 'th field of this newly allocated cell at address  is read by
 and updated by
. The cell  is deallocated by .

\begin{figure*}[t]
\hrule



\hrule
\caption{Typing Rules for Expressions and Terms}
\label{fig:typing}
\end{figure*}


The language uses typing judgments of the form
 and
,
where  is a finite set of stack variables
and  is a standard type environment for identifiers .
The typing rules for expressions and terms are shown in
Figure~\ref{fig:typing}.


We use the standard assertions from separation logic to describe properties
of the heap:\footnote{We omit separating implication 
to simplify presentation.}
{

}
The points-to predicate  means
that the current heap has only one cell at address  and 
that the -th field of the cell has the value .
The  predicate denotes the empty heap, and the separating
conjunction  means that the current heap can be split into
two parts so that  holds for the one and  holds for the other.
The other connectives have the usual meaning from classical logic.
All the missing connectives from classical logic are defined as usual. 

In the paper, we will use the three abbreviations 
, 
and . The first
 is a syntactic sugar for 
, and denotes heaps
with cell  only.
 is an abbreviation for
, and means
 heaps that contain only cell  and
store  in the second field of this unique cell .
The last  is defined similarly.

Assertions only depend on stack variables , not identifiers .
Thus assertions are typed by a judgment .  The typing rules for this judgment are completely standard, and
thus omitted from this paper.


\section{Separation Logic}
\label{sec:separation-logic}
Our version of separation logic is the first-order 
{\em intuitionistic\/} logic extended with Hoare triples 
and invariant extension.
The formulas in the logic are called {\em specifications},
and they are defined by the following grammar:
{

}
The formula  means
the extension of  by the invariant .
It can be viewed as 
a syntactic transformation of  that 
inserts  into the pre and post conditions of all triples 
in .  For instance, 
 is 
equivalent to 
.
We write  for the set of all specifications.

Specifications are typed by the judgment 
, where we
overloaded  to mean the type for specifications.

The logic includes all the usual proof rules from first-order
intuitionistic logic with equality, and a rule for fixed-point induction.
In addition, it contains proof rules from separation logic, and
\emph{higher-order frame rules}, expressed in terms of rules for invariant
introduction and distribution. Figure~\ref{fig:sl-rules} shows some of
these additional rules and a rule for fixed-point 
induction. In the figure, we often omit contexts  for specifications and also conditions about typing.


\begin{figure*}[t]
\hrule


\begin{center}
{\sc Proof Rules for Hoare Triples}
\end{center}

0.5ex]
(\mtri{P}{M}{Q} \wedge \mtri{P'}{M}{Q'})
  & \;\Rightarrow\; &
  \mtri{P \vee P'}{M}{Q \vee Q'}
\0.5ex]
\mtri{P}{M}{P_0} 
  \wedge
  \mtri{P_0}{N}{Q}
  & \;\Rightarrow\; &
  \mtri{P}{M;N}{Q}
\0.5ex]
(\forall i.\, \mtri{P*E\pointsto i,E_1}{M}{Q})
  & \;\Rightarrow\; &
  \mtri{\exists i.\,P*E\pointsto i,E_1}{\mletin{i{=}E.0}{M}}{Q}
\\
&&
\hfill
  (\mbox{where })
\0.5ex]
\multicolumn{3}{c}{
  \mtri{E\pointsto \blank,E_1}{E.0 := F}{E\pointsto F,E_1}
}
\

\begin{center}
{\sc Proof Rules for Invariant Extension }
\end{center}

0.5ex]
(E = F) \otimes Q 
  & \;\Leftrightarrow\; &
  E=F
&
(M = N) \otimes Q 
  & \;\Leftrightarrow\; &
  (M=N)
\0.5ex]
(\kappa x\colon \tau.\, \varphi)\otimes P 
  & \;\Leftrightarrow\; &
  \kappa x\colon \tau.\, \varphi \otimes P
&
(\kappa i.\, \varphi)\otimes P 
  & \;\Leftrightarrow\; &
  \kappa i.\, \varphi \otimes P
\\
\multicolumn{3}{r}{
  \qquad(\mbox{where } \kappa \in \{\forall,\exists\})
}
&
\multicolumn{3}{r}{
  \qquad(\mbox{where } \kappa \in \{\forall,\exists\} \mbox{ and } i \not\in \FV(P))
}
\\
\\
\end{array}

\begin{array}{@{}c@{}}
C ::= [\;] 
   \,{\mid}\, \lambda i. C
   \,{\mid}\, C\, E 
   \,{\mid}\, \lambda x\colon \tau. C
   \,{\mid}\, C\, M 
   \,{\mid}\, \fix\, C
   \,{\mid}\, C;M 
\qquad
\gamma ::= \mtri{P}{C}{Q}
  \,{\mid}\, \gamma {\wedge} \gamma 
  \,{\mid}\, \forall x\colon\tau. \gamma
  \,{\mid}\, \forall i. \gamma
\
where  is a capture-avoiding insertion of 
into the hole  in .
\vspace{1mm}
\hrule
\caption{Sample Proof Rules}
\label{fig:sl-rules}
\end{figure*}




The rules for Hoare triples are the standard proof rules
of separation logic adapted to our language. Note that in 
the rule of consequence, we use the standard
semantics of assertions ,
in order to express semantic implications between those assertions
(of course, standard logical derivability
 and
 are
sufficient conditions).
The rules for invariant extension 
formalize higher-order frame rules,
extending the idea in \cite{birkedal-torpsmith-yang-lics05}.  The generalized higher-order 
frame rule  adds
an invariant  to specification , and the other
rules distribute this added invariant all the way down to
the triples. 
We just show one use of those rules that lead
to the second-order frame rule: 
{

}
The last rule is for fixed-point induction,
and it relies on the restriction that
a specification is of the form . 
The grammar for  guarantees
that  defines an admissible predicate for ,
thus ensuring the soundness of fixed-point induction.
Moreover, it also guarantees that  holds 
when  means , so allowing us to
omit a usual base case, ``,'' from the rule. 

Note that the rules do \emph{not} include the so-called 
conjunction rule:

The omission of this rule is crucial, since
our parametricity interpretation does not validate
the rule. 
We discuss the conjunction rule further
in Section~\ref{sec:discussion-futurework}.

\begin{exa}\label{exa:client-counter}
Recall the counter example from the introduction and
consider the following simple client

whose body consists of .
The client initializes the value of the counter to ,
increases the counter, and reads the value of the counter.

In our logic, we can prove that the body of the client satisfies:

where  is a set of stack variables containing
 and  are defined by

Note that cell , which is transferred to the counter by ,
does not appear in any assertion of the specification for
the client's body. This implies, 
correctly, that the client does not dereference
the transferred cell , after calling .

The formal proof of the specification of the body
uses the first-order frame rule, and it is given below:

The interesting parts of the proof are steps ,
where we use rules for invariant extensions, in order
to add the frame axiom  into the pre
and post conditions of a triple. Note that
the addition of this frame axiom starts with a generalized
frame rule ,
and continues with the rule that moves  inside .
The remaining steps  are instances of
 usual rules for first-order intuitionistic logic
or Hoare logic, such as the
elimination rule for conjunction
and the rule of Consequence.
\qed
\end{exa}

\section{Semantics of Programming Language}
\label{sec:semantics-pl}
Let  be a countably infinite set of locations.
The programming language is interpreted in the category 
of FM-cpos on .

We remind the reader of the basics of FM domain theory.
Call a bijection  on  a {\em permutation\/}
when  only for finitely many ,
and let  be the set of all permutations.
An FM-set is a pair of a set  and a function
 of type , such
that (1)  and 
, and (2)
every  is {\em supported\/} 
by some finite subset  of , i.e.,

It is known that every element  in an FM-set  has
a smallest set  that supports . This smallest set
is denoted . An FM function  from an FM-set  to an FM-set  is
a function from  to  such that 
 for all .

An FM-poset is an FM-set  with a partial order  on 
 such that 
for all . We say that a (-)chain  in FM-poset
 is {\em finitely supported\/} 
iff there is a finite subset  of 
that supports all elements in the chain. Finally, an 
FM-cpo is an FM-poset  for which
 every finitely-supported 
chain  has a least upper bound, and an FM continuous
function  from an FM-cpo  to an FM-cpo  is
an FM function from  to  that preserves the least upper bounds
of all finitely supported chains.

Types are interpreted as pointed FM-cpos,
using the categorical structure of the category of FM-cpos,
see Figure~\ref{fig:interpretation-types}. In the figure,
we use the FM-cpo   of references defined by:

where  and  denotes a default value used for
type-incorrect expressions, such as the addition of two
locations.
The only nonstandard part
is the semantics of the command type
, which we define in the continuation passing
style following \cite{PittsAM:monsf,benton}:

Here  and  are cartesian product and exponential
in the category of FM-cpos. And  is the FM-cpo
of the finite partial functions from  to  whose order
and permutation action are defined below:
\begin{enumerate}
\item a \in \dom(f) 
\item .
\end{enumerate}


The first FM-cpo  specifies all 
possible observations, which are
normal termination , erroneous termination 
or divergence . The next FM-cpo  
denotes the set of heaps.  It formalizes that a heap
contains only finitely many allocated cells and each
cell in the heap has two fields. The third FM-cpo 
represents the set of continuations that consume heaps. Finally,
 is the set of cps-style commands. Those commands
take a current heap  and a continuation ,
and compute an observation in  (often by 
computing a final heap , and
calling the given continuation  with ).

\begin{figure*}[t]
\hrule
1.5ex]
\ff{\val \rightarrow \tau} & \defeq & 
   \sval \rightarrow \ff{\tau}
&
\ff{\tau \rightarrow \tau'} & \defeq &
   \ff{\tau} \rightarrow \ff{\tau'}
\\
\ff{\com} & \defeq & \Heap \times \cont \rightarrow \Obs 
\
\hrule
\caption{Interpretation of Types and Typing Contexts}
\label{fig:interpretation-types}
\end{figure*}

Note that  has the usual heap disjointness
predicate , which denotes the disjointness of 
and , and the usual partial heap combining operator
, which takes the union of (the graphs of) two
disjoint heaps. The  predicate and  operator fit
well with FM domain theory, because they 
preserve all permutations:
 and
.

The semantics of typing contexts  and 
is given by cartesian products:

and
.
The products here are taken over finite families,
so they give well-defined FM-cpos.\footnote{An infinite
product of FM-cpos is not necessarily an FM-cpo.} We
will use symbols  and  to denote environments
in  and , respectively.

\begin{figure*}[t]
\hrule
1.5ex]
\ff{\Delta,i \vdash i}_\rho \;\;\defeq\;\; \rho(i)
\qquad
\ff{\Delta \vdash 0}_\rho \;\;\defeq\;\; 0
\\
\ff{\Delta \vdash E_1+E_2}_\rho \;\;\defeq\;\;
\ifthenElse{(\ff{E_1}_\rho,\ff{E_2}_\rho \in \sint)}{(\ff{E_1}_\rho+\ff{E_2}_\rho)}{\default}
\\
\ff{\Delta \vdash E_1 - E_2}_\rho \;\; \defeq \;\;
\ifthenElse{(\ff{E_1}_\rho,\ff{E_2}_\rho \in \sint)}{(\ff{E_1}_\rho - \ff{E_2}_\rho)}{\default}
\end{array}
 
\begin{array}{@{}r@{\,}c@{\,}l@{}}
\ff{\Delta \,|\, \Gamma \vdash M \colon \tau} & : & \ff{\Delta}\times\ff{\Gamma} \rightarrow \ff{\tau}
\
\hrule
\caption{Interpretation of Terms}
\label{fig:interpretation-terms}
\end{figure*}




\section{Relational Interpretation of Separation Logic}
\label{sec:reln-int-of-sep-logic}
We now present the main result of this paper, 
a relational interpretation of separation logic.
In this interpretation, a specification
means a relation on terms,
rather than a set of terms
``satisfying'' the specification. 
This relational reading formalizes
the intuitive claim that proof rules in separation 
logic ensure parametricity with respect to the heap.

Our interpretation has two important components 
that ensure parametricity. The first is 
a Kripke structure . The possible
worlds of  are finitely supported binary 
relations  on heaps,\footnote{A relation  is 
finitely supported iff there is  
 s.t.
for every permutation , if  for all 
,
then
} 
and the accessibility relation is
the preorder defined by the separating conjunction for relations: 

Intuitively,  means that 
is a -extension of  by some . The Kripke structure  
parameterizes our interpretation, and it guarantees 
that all the logical connectives behave parametrically wrt. relations
between internal resource invariants. 

The second is {\em semantic quadruples}, which describe
the relationship between two commands. We use
the semantic quadruples to interpret Hoare triples relationally.
Consider 
and . 
For each subset  of an FM-cpo ,
define  to be the partial identity relation on  that 
equates only the elements in . A {\em semantic quadruple\/} 
 holds iff

where  is the set  of good
observations, and where  means
that  map heaps related in  into the diagonal of .
The above condition 
indirectly expresses that if the input heaps  are 
-related, then the output 
heaps are related by . Note that the definition 
quantifies over relations  for new heaps, thus implementing
relational parametricity.  In Section~\ref{sec:quadruples},
we show how semantic quadruples are related to a more
direct way of relating two commands and we also show
that the parametricity in the definition of semantic quadruples
implies the locality condition in separation logic~\cite{reynolds02}.

The semantics of the logic is defined by the satisfaction relation 
 between

and ,
such that  satisfies Kripke monotonicity:
 
One way to understand the satisfaction relation is to
assume two machines that execute the same set of terms.
Each of these machines contains a chip that implements 
a module with a fixed set of operations. 
Intuitively, the
 parameter of 
specifies the configurations of those machines:
one machine uses  to bind free stack variables
and identifiers of terms, and the other machine uses 
for the same purpose; and the internal resources of the
built-in modules
in those machines are related by . The judgment 
means that if two machines are configured by ,
then the meanings of the terms in two machines
are -related. Note that 
we allow different environments for the  context only,
not for the  context. This is because we are mainly
concerned with parametricity with respect to the heap
and only  entities, not  entities, 
depend on the heap. 



Figure~\ref{fig:definition-satisfaction} shows
the detailed interpretation of specifications. 
In the figure, we make use of the standard semantics of 
assertions~\cite{reynolds02}.
We now explain three cases in the definition of .


The first case is implication.
Our interpretation of implication exploits the
specific notion of accessibility in .  It is
equivalent to the standard Kripke semantics of implication:

because  iff  for some .

The second case is quantification. If a stack
variable  is quantified, we consider one semantic value, but
if an identifier  is quantified, we consider two semantic 
values. This is again to reflect that in
our relational interpretation, we are mainly concerned with 
heap-dependent entities. Thus, we only read quantifiers for 
heap-dependent entities  relationally.

The last case is invariant extension 
. Mathematically, it says that if we extend the 
 parameter by the partial equality for
predicate , specification  holds. Intuitively,
this means that some heap cells not appearing in a specification  
satisfy the invariant .

\begin{figure*}[t]
\hrule
1ex]
(\rho,\eta_0,\eta_1,r)
\models \mtri{P}{M}{Q}
& \defliff &
\squad{\EQ(\ff{P}_\rho)*r}{\ff{M}_{\rho,\eta_0}}{\ff{M}_{\rho,\eta_1}}{\EQ(\ff{Q}_\rho)*r}
\\
(\rho,\eta_0,\eta_1,r) 
\models \varphi \otimes P
& \defliff &
(\rho,\eta_0,\eta_1,r * \EQ(\ff{P}_\rho)) 
\models \varphi 
\\
(\rho,\eta_0,\eta_1,r) 
\models E = F
& \defliff &
\ff{E}_\rho = \ff{F}_\rho
\\
(\rho,\eta_0,\eta_1,r) 
\models M = N 
& \defliff &
\ff{M}_{\rho,\eta_0} = \ff{N}_{\rho,\eta_0}
\;\mbox{and}\;
\ff{M}_{\rho,\eta_1} = \ff{N}_{\rho,\eta_1}
\\
(\rho,\eta_0,\eta_1,r)
\models \varphi \Rightarrow \psi
& \defliff &
\begin{array}[t]{@{}l@{}}
\mbox{for all ,
if }, 
\\
\quad \mbox{then }
\end{array}
\\
(\rho,\eta_0,\eta_1,r)
\models \forall i.\,\varphi 
& \defliff &
\mbox{for all , }
(\rho[i\bind v],\eta_0,\eta_1,r)
\models \varphi 
\\
(\rho,\eta_0,\eta_1,r)
\models \exists i.\,\varphi 
& \defliff &
\mbox{there exists  s.t. }
(\rho[i\bind v],\eta_0,\eta_1,r)
\models \varphi 
\\
(\rho,\eta_0,\eta_1,r)
\models \forall x\colon\tau.\,\varphi 
& \defliff &
\mbox{for all , }
(\rho,\eta_0[x\bind m],\eta_1[x\bind n],r)
\models \varphi 
\\
(\rho,\eta_0,\eta_1,r)
\models \exists x\colon\tau.\,\varphi 
& \defliff &
\mbox{there exist  s.t. }
(\rho,\eta_0[x\bind m],\eta_1[x \bind n],r)
\models \varphi 
\\
(\rho,\eta_0,\eta_1,r)
\models \varphi \wedge \psi
& \defliff &
(\rho,\eta_0,\eta_1,r)
\models \varphi 
\;\mbox{and}\;
(\rho,\eta_0,\eta_1,r)
\models \psi
\\
(\rho,\eta_0,\eta_1,r)
\models \varphi \vee \psi
& \defliff &
(\rho,\eta_0,\eta_1,r)
\models \varphi 
\;\mbox{or}\;
(\rho,\eta_0,\eta_1,r)
\models \psi
\end{array}

\begin{array}{ll}
& (\rho,\eta_0,\eta_1,r) \models \mtri{P}{M}{Q} \otimes P_0
\\
\iff
&
(\rho,\eta_0,\eta_1,r*\EQ(\ff{P_0}_\rho)) \models \mtri{P}{M}{Q} 
\hfill
\quad(\mbox{by the semantics of }).
\\
\iff
&  \squad
        {\EQ(\ff{P}_\rho)*\EQ(\ff{P_0}_\rho)*r}
        {\ff{M}_{\rho,\eta_0}}
        {\ff{M}_{\rho,\eta_1}}
        {\EQ(\ff{Q}_\rho)*\EQ(\ff{P_0}_\rho)*r}
\\
\iff
& \squad
        {\EQ(\ff{P*P_0}_\rho)*r}
        {\ff{M}_{\rho,\eta_0}}
        {\ff{M}_{\rho,\eta_1}}
        {\EQ(\ff{Q*P_0}_\rho)*r}
\\
\iff
& (\rho,\eta_0,\eta_1,r) \models \mtri{P*P_0}{M}{Q*P_0}
\hfill
\quad(\mbox{by the semantics of triples}).
\end{array}

  (\rho,\eta_0,\eta_1,r) \models \varphi
\iff
  (\rho,\eta_0,\eta_1,r*\EQ(\ff{P}_\rho)) \models \varphi
\iff
  (\rho,\eta_0,\eta_1,r) \models \varphi \otimes P.

\begin{array}{@{}ll@{}}
&
(\rho,\eta_0,\eta_1,r) \models \exists i.\,\varphi\otimes P
\\
\iff 
&
\mbox{there exists  s.t. }
(\rho[i\bind v],\eta_0,\eta_1,r) \models \varphi\otimes P
\\
\iff 
&
\mbox{there exists  s.t. }
(\rho[i\bind v],\eta_0,\eta_1,r*\EQ(\ff{P}_{\rho[i\bind v]})) 
\models \varphi
\\
\iff 
&
\mbox{there exists  s.t. }
(\rho[i\bind v],\eta_0,\eta_1,r*\EQ(\ff{P}_{\rho}))
\models \varphi
\quad
\hfill
(\mbox{since })
\\
\iff 
&
(\rho,\eta_0,\eta_1,r*\EQ(\ff{P}_{\rho}))
\models \exists i\colon \delta.\, \varphi
\\
\iff 
&
(\rho,\eta_0,\eta_1,r)
\models (\exists i\colon \delta.\, \varphi) \otimes P.
\end{array}

\begin{array}{@{}ll@{}}
& (\rho,\eta_0,\eta_1,r) \models (\varphi \Rightarrow \psi) \otimes P
\\
\iff
& (\rho,\eta_0,\eta_1,r*\EQ(\ff{P}_\rho)) 
  \models \varphi \Rightarrow \psi
\\
\iff
& \forall s.\;
  \bigl((\rho,\eta_0,\eta_1,r*\EQ(\ff{P}_\rho)*s) \models \varphi\bigr)
  \implies
  \bigl((\rho,\eta_0,\eta_1,r*\EQ(\ff{P}_\rho)*s) \models \psi\bigr)
\\
\iff
& \forall s.\;
 \bigl((\rho,\eta_0,\eta_1,r*s) \models \varphi\otimes P\bigr)
 \implies
  \bigl((\rho,\eta_0,\eta_1,r*s) \models \psi\otimes P\bigr)
\\
\iff
& (\rho,\eta_0,\eta_1,r) \models 
  (\varphi\otimes P) \Rightarrow (\psi\otimes P).
\end{array}

  (\forall i. \mtri{P*i\pointsto 0,0}{M}{Q})
  \;\Rightarrow\;
  \mtri{P}{\mletin{i{=}\new}{M}}{Q}.

   \squad
     {\EQ(\ff{P}_\rho)*r}
     {\ff{\mletin{i{=}\new}{M}}_{\rho,\eta_0}}
     {\ff{\mletin{i{=}\new}{M}}_{\rho,\eta_1}}
     {\EQ(\ff{Q}_\rho)*r}.

   h_0[\EQ(\ff{P}_\rho)*r*s]h_1
   \;\;\mbox{and}\;\;
   k_0[(\EQ(\ff{Q}_\rho)*r*s) \rightarrow \EQ(\Good)]k_1.
\label{eqn:allocation}
  {\ff{\mletin{i{=}\new}{M}}_{\rho,\eta_j}}(h_j,k_j) 
  = 
  {\ff{M}_{\rho[i\bind l],\eta_j}}(h_j\bullet [l\bind 0,0],k_j).

\begin{array}{@{}ll@{}}
&
   h_0\bigl[\EQ(\ff{P}_\rho)*r*s\bigr]h_1\;\wedge\;
   k_0\bigl[(\EQ(\ff{Q}_\rho)*r*s) \rightarrow \EQ(\Good)\bigr]k_1
\\
\implies 
&
   h_0\bigl[\EQ(\ff{P}_{\rho'})*r*s\bigr]h_1
   \;\wedge\;
   k_0\bigl[(\EQ(\ff{Q}_{\rho'})*r*s) \rightarrow \EQ(\Good)\bigr]k_1
\\
\implies 
&
   h'_0\bigl[\EQ(\ff{P*i\pointsto 0,0}_{\rho'})*r*s\bigr]h'_1
   \;\wedge\;
   k_0\bigl[(\EQ(\ff{Q}_{\rho'})*r*s) \rightarrow \EQ(\Good)\bigr]k_1
\\
\implies 
&
  {\ff{M}}_{\rho',\eta_0}(h'_0,k_0) 
  \bigl[\EQ(\Good)\bigr]
  {\ff{M}}_{\rho',\eta_1}(h'_1,k_1)
\\
\implies
&
  {\ff{\mletin{i{=}\new}{M}}_{\rho,\eta_0}}(h_0,k_0) 
  \bigl[\EQ(\Good)\bigr]
  {\ff{\mletin{i{=}\new}{M}}_{\rho,\eta_1}}(h_1,k_1).
\end{array}

(\forall i. \mtri{P * E\pointsto i,E_1}{M}{Q}) 
\;\Rightarrow\;
\mtri
  {\exists i. P * E\pointsto i,E_1}
  {\mletin{i{=}E.0}{M}}
  {Q}. 

 h_0\bigl[\EQ(\ff{\exists i. P*E\pointsto i,E_1}_\rho)*r*s
     \bigr]h_1
  \;\wedge\;
 k_0\bigl[\EQ(\ff{Q}_\rho)*r*s \rightarrow \EQ(\Good)\bigr]k_1.

  v {=} \proj_0(h_0(l)) {=} \proj_0(h_1(l)),\;\;
  \rho'{=} \rho[i \bind v],\;\;\mbox{and}\;\;
  h_0\bigl[\EQ(\ff{P*E\pointsto i,E_1}_{\rho'})*r*s\bigr]h_1.
\label{eqn:lookup}
\ff{\mletin{i{=}E.0}{M}}_{\rho,\eta_j}(h_j,k_j) 
= 
\ff{M}_{\rho',\eta_j}(h_j,k_j).

\begin{array}{@{}ll@{}}
&
  k_0\bigl[\EQ(\ff{Q}_\rho)*r*s \rightarrow \EQ(\Good)\bigr]k_1
  \;\wedge\;
  h_0\bigl[\EQ(\ff{P*E\pointsto i,E_1}_{\rho'})*r*s\bigr]h_1
\\
\implies &
  k_0\bigl[\EQ(\ff{Q}_{\rho'})*r*s \rightarrow \EQ(\Good)\bigr]k_1
  \;\wedge\;
  h_0\bigl[\EQ(\ff{P*E\pointsto i,E_1}_{\rho'})*r*s\bigr]h_1
\\
\implies &
  \ff{M}_{\rho',\eta_0}(h_0,k_0)
  \bigl[\EQ(\Good)\bigr]
  \ff{M}_{\rho',\eta_1}(h_1,k_1)
\\
\implies &
  \ff{\mletin{i{=}E.0}{M}}_{\rho,\eta_0}(h_0,k_0)
  \bigl[\EQ(\Good)\bigr]
  \ff{\mletin{i{=}E.0}{M}}_{\rho,\eta_1}(h_1,k_1).
\end{array}

   h_0\bigl[\EQ(\ff{E\pointsto \blank}_\rho) * r * s\bigr]h_1
   \;\wedge\;
   k_0\bigl[\EQ(\ff{\emp}_\rho) * r * s 
            \rightarrow \EQ(\Good)\bigr]k_1.

   h_0\bigl[\EQ(\ff{E\pointsto \blank,E_1}_\rho) * r * s\bigr]h_1
   \;\wedge\;
   k_0\bigl[\EQ(\ff{E\pointsto F,E_1}_\rho) * r * s 
            \rightarrow \EQ(\Good)\bigr]k_1.

  h_0[\EQ(\ff{P}_\rho)*r*s]h_1\;\;\wedge\;\;
  k_0[\EQ(\ff{Q}_\rho)*r*s \rightarrow \EQ(\Good)]k_1.

\begin{array}{rcl}
  \EQ(\ff{P}_\rho)*r*s & \subseteq &
  \EQ(\ff{P'}_\rho)*r*s, \;\;\mbox{ and}
\\
  {[\EQ(\ff{Q}_\rho)*r*s \rightarrow \EQ(\Good)]} & \subseteq &
  {[\EQ(\ff{Q'}_\rho)*r*s \rightarrow \EQ(\Good)]}.
\end{array}

(\forall i. \mtri{P}{M}{Q})
 \Rightarrow \mtri{\exists i.P}{M}{\exists i.Q}.

   \squad
     {\EQ(\ff{\exists i.P}_\rho)*r}
     {\ff{M}_{\rho,\eta_0}}
     {\ff{M}_{\rho,\eta_1}}
     {\EQ(\ff{\exists i.Q}_\rho)*r}.

   h_0[\EQ(\ff{\exists i.P}_\rho)*r*s]h_1
   \;\;\mbox{and}\;\;
   k_0[(\EQ(\ff{\exists i.Q}_\rho)*r*s) \rightarrow \EQ(\Good)]k_1.

   \rho' = \rho[i\bind v],\;\;
   h_0[\EQ(\ff{P}_{\rho'})*r*s]h_1,\;\;
   \mbox{and}\;\;
   k_0[(\EQ(\ff{Q}_{\rho'})*r*s) \rightarrow \EQ(\Good)]k_1.

\begin{array}{@{}rl@{}}
&
   (h_0[\EQ(\ff{P}_{\rho'})*r*s]h_1)
   \;\wedge\;
   (k_0[(\EQ(\ff{Q}_{\rho'})*r*s) \rightarrow \EQ(\Good)]k_1)
\\
\implies\;
&
   \ff{M}_{\rho',\eta_0}(h_0,k_0)[\EQ(\Good)]
   \ff{M}_{\rho',\eta_1}(h_1,k_1)
\;\,\hfill
   (\mbox{since }
    (\rho,\eta_0,\eta_1,r) \models \forall i.\mtri{P}{M}{Q})
\\
\implies\;
&
   \ff{M}_{\rho,\eta_0}(h_0,k_0)[\EQ(\Good)]
   \ff{M}_{\rho,\eta_1}(h_1,k_1)
\quad\hfill
   (\mbox{since } i \not\in \FV(M)).
\end{array}

   h_0\bigl[\EQ(\ff{P\vee P'}_\rho)*r*s\bigr]h_1\;\wedge\;
   k_0\bigl[\EQ(\ff{Q \vee Q'}_\rho)*r*s \rightarrow 
             \EQ(\Good)\bigr]k_1.
\label{eqn:disjunction-one}
h_0\bigl[\EQ(\ff{P}_\rho)*r*s\bigr]h_1.
\label{eqn:disjunction-two}
k_0\bigl[\EQ(\ff{Q}_\rho)*r*s \rightarrow \EQ(\Good)\bigr]k_1.

  \ff{M}_{\rho,\eta_0}(h_0,k_0)
  \bigl[\EQ(\Good)\bigr]
  \ff{M}_{\rho,\eta_1}(h_1,k_1).

   h_0\bigl[\EQ(\ff{P}_\rho)*r*s\bigr]h_1\;\wedge\;
   k_0\bigl[\EQ(\ff{Q}_\rho)*r*s \rightarrow \EQ(\Good)\bigr]k_1.
\label{eqn:ifz}
   \ff{\ifz\,(E{=}F)\,\then\,M\,\melse\,N}_{\rho,\eta_j}(h_j,k_j) = 
   \ff{M}_{\rho,\eta_j}(h_j,k_j) \mbox{ for all }.

\begin{array}{@{}ll@{}}
&
   h_0\bigl[\EQ(\ff{P \wedge E=F}_\rho)*r*s\bigr]h_1 \;\wedge\;
   k_0\bigl[\EQ(\ff{Q}_\rho)*r*s \rightarrow \EQ(\Good)\bigr]k_1
\\
\implies &
   \ff{M}_{\rho,\eta_0}(h_0,k_0)
   \bigl[\EQ(\Good)\bigr]
   \ff{M}_{\rho,\eta_1}(h_1,k_1)
\\
\implies &
   \ff{\ifz\,(E{=}F)\,\then\,M\,\melse\,N}_{\rho,\eta_0}(h_0,k_0)  
   \bigl[\EQ(\Good)\bigr]
   \ff{\ifz\,(E{=}F)\,\then\,M\,\melse\,N}_{\rho,\eta_1}(h_1,k_1) .
\end{array}

   h_0\bigl[\EQ(\ff{P}_\rho)*r*s\bigr]h_1\;\wedge\;
   k_0\bigl[\EQ(\ff{Q}_\rho)*r*s \rightarrow \EQ(\Good)\bigr]k_1.

  k'_0 = \lambda h'_0.\ff{N}_{\rho,\eta_0}(h'_0,k_0)
  \bigl[\EQ(\ff{P_0}_\rho)*r*s \rightarrow \EQ(\Good)\bigr]
  \lambda h'_1.\ff{N}_{\rho,\eta_1}(h'_1,k_1) = k'_1.

\ff{M}_{\rho,\eta_0}(h_0,k'_0)
  \bigl[\EQ(\Good)\bigr]
  \ff{M}_{\rho,\eta_1}(h_1,k'_1).

  \{(m_0,m_1) \mid (\rho,\eta_0[x\bind m_0],\eta_1[x\bind m_1],r) \models \gamma(x)\}.

   (\pi \cdot a_0 = a_0)
   \;\;\wedge\;\;
   (\pi \cdot (f(a,b)) = f(\pi \cdot a, \pi \cdot b)) 
   \;\;\wedge\;\;
   ((a,b) \in r \iff (\pi \cdot a, \pi \cdot b) \in r).

   \bot,\top \in A,\;\;\;\;\mbox{and}\;\;\;\;
   \sqcup,\sqcap,\Rightarrow : A \times A \rightarrow A,

  m \sqsubseteq n \iff
  \exists m'. m*m' = n.

\begin{array}{r@{\;}c@{\;}l@{\qquad\qquad}r@{\;}c@{\;}l}
\bot & \defeq & \emptyset 
&
\top & \defeq & M
\\
M_0 \sqcup M_1 & \defeq & M_0 \cup M_1
&
M_0 \sqcap M_1 & \defeq & M_0 \cap M_1
\\
\multicolumn{6}{c}{
M_0 \Rightarrow M_1 \;\defeq\; 
\{m \,\mid\, \forall m'.\; (m \sqsubseteq m' \wedge m' \in M_0)
\implies m' \in M_1\}.
}
\end{array}

\forall m'.\; m*m' \in M_0 \implies m*m' \in M_1.

    M_0 \otimes m \;\;\defeq\;\; 
   \{ m' \,\mid\, m' * m \in M_0\}.

\begin{array}{rcl}
\mathsf{FMSet}(-,-\otimes m)
& : & 
\mathsf{FMSet}(-,L(M))
\rightarrow 
\mathsf{FMSet}(-,L(M)),
\end{array}

\begin{array}{rcl}
   \cps & : &
   (\Heap \rightarrow (\Heap + \{\error\})_\bot) 
   \;\rightarrow\;
   (\Heap \times \cont \rightarrow \Obs)
\\
   \cps(c) & \defeq &
   \lambda (h,k).\;
   \ifthenElse
      {(c(h)\not\in \{\bot,\error\})}
      {k(c(h))}
      {c(h)}.
\end{array}

   k(h) \defeq \ifthenElse{(h\in q)}{\bot}{\error}. 

(c(h) = \bot) \vee (c(h) \in \Heap \wedge k(c(h)) = \bot).

\begin{array}{rcl}
  k_0(h') & \defeq & \normal,
\\
  k_1(h') & \defeq & \ifthenElse{(h'=c(h))}{\normal}{\bot},
\\
  k_2(h') & \defeq & \ifthenElse{(c(h) \in \Heap \,\wedge\, h'=c(h)\bullet h_1)}{\normal}{\bot}.
\end{array}

   h[\EQ(p)*r](h\bullet h_1),\;\;
   k_0[\EQ(q)*r \rightarrow \EQ(\Good)]k_0,\;\;
   \mbox{and}\;\;
   k_1[\EQ(q)*r \rightarrow \EQ(\Good)]k_2.

   \cps(c)(h,k_0)[\EQ(\Good)]\cps(c)(h\bullet h_1,k_0)
   \;\;\mbox{and}\;\;
   \cps(c)(h,k_1)[\EQ(\Good)]\cps(c)(h\bullet h_1,k_2).

   h_1[\EQ(p)*r]h_2 \;\;\mbox{and}\;\;
   k_1[\EQ(q)*r \rightarrow \EQ(\Good)]k_2.

   c(h_1) = c(h'_1)\bullet h''_1[\EQ(q)*r]c(h'_1)\bullet h''_2 = c(h_2).

\begin{array}{rcl}
   k_1[r^\bot]k_2 
   & \defliff &
   \forall d_1,d_2 \in D.\;
       (d_1[r]d_2 \implies k_1(d_1)[\EQ(\Good)]k_2(d_2)),
\\
   d_1[r^\mperp]d_2 
   & \defliff &
   \forall k_1,k_2 \in [D \rightarrow \Obs].\;
       (k_1[r^\bot]k_2 \implies k_1(d_1)[\EQ(\Good)]k_2(d_2)). 
\end{array}

\forall (r',h_1,h_2).\;
h_1[r*r']h_2 
\implies
(c_1(h_1){=}c_2(h_2){=}\bot \vee c_1(h_1)[(s*r')^\mperp]c_2(h_2)).

  c_1(h_1) = \bot \iff c_2(h_2) = \bot.

   \cps(c_1)(h_1,k)[\EQ(\Good)]\cps(c_2)(h_2,k).

  \cps(c_1)(h_1,k_1)[\EQ(\Good)]\cps(c_2)(h_2,k_2).

k_1(c_1(h_1))[\EQ(\Good)]k_2(c_2(h_2)).

\cps(c_1)(h_1,k_1) = \bot\,[\EQ(\Good)]\,\bot = \cps(c_2)(h_2,k_2),

  \cps(c_1)(h_1,k_1) = k_1(c_1(h_1))
  \,[\EQ(\Good)]\,
  k_2(c_2(h_2)) = \cps(c_2)(h_2,k_2).

\squad
     {\EQ(\ff{P}_\rho)*r}
     {\ff{M}_{[x\bind c_0]}}
     {\ff{M}_{[x\bind c_1]}}
     {\EQ(\ff{Q}_\rho) * r}

\eta_0 = [x\bind c_0],\; \eta_1 = [x\bind c_1],\;\mbox{and}\;
(p_1,q_1,p,q) = (\ff{P_1}_\rho,\ff{Q_1}_\rho,\ff{P}_\rho,\ff{Q}_\rho).

\begin{array}{@{}cl@{}}
& (\rho,\eta_0,\eta_1,r) \models \mtri{P_1}{x}{Q_1} \Rightarrow \mtri{P}{M}{Q}
\\
{\implies} 
& (\forall s \in \cR.\;
   (\rho,\eta_0,\eta_1,r*s) \models \mtri{P_1}{x}{Q_1} \implies
   (\rho,\eta_0,\eta_1,r*s) \models \mtri{P}{M}{Q}) 
\\
{\implies} 
& ((\rho,\eta_0,\eta_1,r) \models \mtri{P_1}{x}{Q_1} \implies
   (\rho,\eta_0,\eta_1,r) \models \mtri{P}{M}{Q}) 
\\
{\implies} 
& (\squad{\EQ(p_1)*r}{c_0}{c_1}{\EQ(q_1)*r} \implies
   \squad{\EQ(p)*r}{\ff{M}_{\eta_0}}{\ff{M}_{\eta_1}}{\EQ(q)*r}).
\end{array} 

\begin{array}{rcl}
\multicolumn{3}{c}{
\begin{array}{@{}r@{}c@{}l@{}}
    \forall j.\; 
    \{\exists i.\,c\pointsto i,\blank * i\pointsto \blank,j\}
    & \inc_0 &
   \{\exists i.\,c\pointsto i,\blank * i\pointsto \blank,(j{+}1)\} 
\\
   \forall j.\;
   \{\exists i.\,c\pointsto i,\blank * i\pointsto \blank,j * g \pointsto \blank\}
    & \mread_0 &
    \{\exists i.\,c\pointsto i,\blank * i \pointsto \blank,j * g \pointsto \blank,j\}
\end{array}
}
\2.5ex]
    \inc_1 & \equiv & \mletin{i{=}c.0}{(\mletin{j{=}i.1}{i.1 := j{-}1})}
\\
    \mread_1 & \equiv & \mletin{i{=}c.0}{(\mletin{j{=}i.1}{g.1 := {-}j})}
\\
\\
\multicolumn{3}{c}{
     \Delta \,\mid\, \Gamma \;\;\vdash\;\; 
     (\mtri{\emp}{\inc}{\emp}\land
      \mtri{g\pointsto\blank}{\mread}{g\pointsto\blank})
     \;\Rightarrow\; 
     \mtri{g\pointsto\blank}{\inc;\mread}{g\pointsto \blank}
}
\\
\multicolumn{3}{r}{
  \hfill(\mbox{where  and
  })
}
\end{array}

f_i \defeq \ff{\inc_i}_{\rho,[]},\;\;\; 
g_i \defeq \ff{\mread_i}_{\rho,[]},\;\;\;
b_i \defeq \ff{\inc;\mread}_{\rho,[\inc\bind f_i, \mread\bind g_i]}.
\label{eq:ex1}
\begin{array}{c}
  \bigl(
    \squad
    {\EQ(\ff{\emp}_\rho)*r}
    {f_0}
    {f_1}
    {\EQ(\ff{\emp}_\rho)*r}
    \;\land\;
    \squad
    {\EQ(\ff{g\pointsto\blank}_\rho)*r}
    {g_0}
    {g_1}
    {\EQ(\ff{g\pointsto\blank}_\rho)*r}\big) 
\\
 {}
 \Rightarrow
 {}
\\
  \squad
    {\EQ(\ff{g\pointsto \blank}_\rho)*r}
    {b_0}
    {b_1}
    {\EQ(\ff{g\pointsto \blank}_\rho)*r}.
\end{array}

  r \;\defeq\; \{\, (h_0,h_1)\,\mid\,
         \begin{array}[t]{@{}l@{}}
         \exists i \in \Loc.\,
         \exists n \in \sint.\,
         \exists v_0,v_1,v_0',v_1' \in \sval.\; \\
         \quad
          i \not= l \,\land\,
          h_0 = [c\bind i,v_0] \bullet [i\bind v_0',n]  \,\land\,
          h_1 = [c\bind i,v_1]\bullet [i\bind v_1',{-}n] \,\}.
        \end{array}

  \squad
    {\EQ(\ff{g\pointsto \blank}_\rho)*r}
    {b_0}
    {b_1}
    {\EQ(\ff{g\pointsto \blank}_\rho)*r}
 
(\forall i.\,\mtri{i\pointsto\blank}{\putf(i)}{\emp}) 
\;\;\;\mbox{and}\;\;\; 
(\forall j.\,\mtri{j\pointsto\blank}{\getf(j)}{j\pointsto\blank}.

\begin{array}{rcl}
\multicolumn{3}{c}{
\begin{array}{@{}r@{}c@{}l@{}}
    \forall i,v.\;
    \{i\pointsto \blank,v * k\pointsto \blank\}
    & {\putf_0(i)} &
    \{k\pointsto \blank,v\} 
\\
    \forall j,v.\;
    \{j\pointsto \blank * k\pointsto \blank,v\} 
    & {\getf_0(j)} &
    \{j\pointsto \blank,v * k\pointsto \blank,v\}
\end{array}
}
\2.5ex]
    \putf_1 & \equiv & 
      \lambda i.\, \mletin{k' {=} k.0}{(\free(k'); k.0 {:=} i)}  
\\
    \getf_1 & \equiv &
     \lambda j.\,
        \mletin{k' {=} k.0}{\mathsf{let}\; v {=} k'.1\;\mathsf{in}\; j.1 {:=} v}
\\
\\
\multicolumn{3}{c}{
     \Delta \,\mid\, \Gamma \;\;\vdash\;\; 
     (\forall i. \mtri{i\pointsto\blank}{\putf(i)}{\emp})\land
     (\forall j. \mtri{j\pointsto\blank}{\getf(j)}{j\pointsto\blank})
     \;\Rightarrow\; 
     \mtri{j\pointsto \blank}{c}{j\pointsto \blank}
}
\\
\multicolumn{3}{r}{
  \hfill(\mbox{where  and
  })
}
\
\hrule
\caption{Two Implementations of a Buffer and a Simple Client}
\label{fig:impl}
\end{figure*}

Figure~\ref{fig:impl} shows
two implementations of the buffer and a client,
as well as the concrete specifications for
the implementations and the specification for the client.
Note that the first implementation just uses one cell for the buffer
and that the implementation follows the intuitive description given above. 
The second implementation uses two cells for the buffer. The additional
cell is used to hold the cell pointed to by  itself. Note that this
additional cell is transferred from the caller of , i.e.,
a client of the buffer. Finally, the specification of the client
describes the safety property of , assuming the abstract specification 
for the buffer.

Pick ,
and define  by

Our Abstraction Theorem gives that, for all ,

This result implies that the client behaves the same no matter
whether we run it with the first or second implementation of the
buffer. To see this, let  be  
and define a simulation relation
 between the two implementations:

For this relation , one can verify that the antecedent 
of the implication
in~(\ref{eq:ex2}) holds, and thus conclude that 

holds. This quadruple says, in particular, 
that  and  map -related
heaps to -related heaps, 
which means
that they behave the same for cell  and preserve the  
relation for the internal resource invariants of the two
implementations.



\section{Conclusion and Future Work}\label{sec:discussion-futurework}

We have succeeded in defining the first relationally parametric model of
separation logic. The model captures the informal idea that well-specified
clients of mutable abstract data types should behave parametrically in the
internal resource invariants of the abstract data type.

We see our work as a first step towards devising a logic for reasoning
about mutable abstract data types, similar in spirit to Abadi and
Plotkin's logic for parametricity~\cite{abadi-plotkin,BirkedalL:defp-mscs}. 
To this end, we also
expect to make use of the ideas of
relational separation logic in~\cite{yang-relational-separation-logic}
for reasoning about relations between different programs syntactically.
The logic should include a link between separation logic and
relational separation logic so that one could get a syntactic
representation of the semantic Abstraction Theorem and its corollary
presented above.

One can also think of our work as akin to the O'Hearn-Reynolds model for
idealized algol based on translation into a relationally parametric
polymorphic linear lambda calculus~\cite{ohearn-reynolds}.  In \emph{loc.
  cit.} O'Hearn and Reynolds show how to provide a better model of stack
variables for idealized algol by making a formal connection to
parametricity. Here we provide a better model for the more unwieldy world
of heap storage by making a formal connection to parametricity.

As mentioned in Section~\ref{sec:separation-logic}, 
the conjunction rule is not sound in our model. This is a consequence of
our interpretation, which ``bakes-in'' the frame rule by quantifying
over all relations . Indeed, using the characterization given by
Proposition~\ref{prop:quadruple-direct}, one sees that for the conjunction
rule 

to hold, we would need something like  to hold. We ``bake-in'' the frame rule in order to get a model
that validates a wide range of higher-order frame rules and it is known
that already for second-order frame rules, the conjunction rule is not
sound without some restrictions on the predicates
involved~\cite{yang-ohearn-reynolds-popl04}. 
We don't know whether it is possible to
develop a parametric model in which the conjunction rule is sound. 

Future work further includes developing a parametric model for 
the higher-order version of separation logic with explicit quantification
over internal resource invariants. 
Finally, we hope that ideas similar to those presented here can be used to
develop parametric models for other recent approaches to mutable abstract
data types (e.g.,~\cite{naumann-barnett}). 

\section*{Acknowledgments}
We would like to thank Nick Benton, Jacob Thamsborg and the anonymous
referees for their insightful comments. This work was supported by FUR
(FIRST). Yang was supported also by EPSRC.

\begin{thebibliography}{10}

\bibitem{banerjee:naumann:jacm}
A.~Banerjee and D.~Naumann.
\newblock Ownership Confinement Ensures Representation Independence for Object-oriented Programs.
\newblock {\em Journal of the ACM}, 52(6):894--960, 2005.

\bibitem{naumann-barnett}
M.~Barnett and D.~Naumann.
\newblock Towards imperative modules: Reasoning about invariants and sharing of
  mutable state.
\newblock In {\em Proc. of LICS'04}, 2004.

\bibitem{Benton-CSL06}
N.~Benton.
\newblock Abstracting {A}llocation:{T}he {N}ew new {T}hing.
\newblock In {\em Proc. of CSL'06}, 2006.

\bibitem{benton}
N.~Benton and B.~Leperchey.
\newblock Relational reasoning in a nominal semantics for storage.
\newblock In {\em Proc. of TLCA'05}, pages 88--101, Nara, Japan, 2005.

\bibitem{biering-birkedal-torpsmith-esop05}
B.~Biering, L.~Birkedal, and N.~Torp-Smith.
\newblock {BI}-hyperdoctrines and higher order separation logic.
\newblock In {\em Proc. of ESOP'05}, pages 233--247, Edinburgh, UK, 2005.

\bibitem{BirkedalL:defp-mscs}
L.~Birkedal and R.~M{\o}gelberg.
\newblock Categorical models for {A}badi-{P}lotkin's logic for parametricity.
\newblock {\em Mathematical Structures in Computer Science}, 15:709--772, 2005.

\bibitem{birkedal-torpsmith-reynolds-popl04}
L.~Birkedal, N.~Torp-Smith, and J.~C. Reynolds.
\newblock Local reasoning about a copying garbage collector.
\newblock In {\em Proc. of POPL'04}, pages 220--231, Venice, Italy, 2004.

\bibitem{birkedal-torpsmith-yang-lics05}
L.~Birkedal, N.~Torp-Smith, and H.~Yang.
\newblock Semantics of separation-logic typing and higher-order frame rules.
\newblock In {\em Proc. of LICS'05}, pages 260--269, 2005.

\bibitem{birkedal-yang-fossacs07}
L.~Birkedal and H.~Yang.
\newblock Relational Parametricity and Separation Logic.
\newblock In {\em Proc. of FOSSACS'07}, pages 93--107, 2007.

\bibitem{mijajlovic-torpsmith-ohearn-fsttcs04}
I.~Mijajlovi\'c, N.~Torp-Smith, and P.~O'Hearn.
\newblock Refinement and separation context.
\newblock In {\em Proc. of FSTTCS'04}, pages 421--433, Chennai, India, 2004.

\bibitem{mijajlovic-yang-aplas05}
I.~Mijajlovi\'c and H.~Yang.
\newblock Data refinements with low-level pointer operations.
\newblock In {\em Proc. of APLAS'05}, pages 19--36, Tsukuba, Japan, 2005.

\bibitem{ohearn-reynolds}
P.~O'Hearn and J.~Reynolds.
\newblock From {A}lgol to polymorphic linear lambda-calculus.
\newblock {\em Journal of the ACM}, 47(1):167--223, 2000.

\bibitem{ohearn-reynolds-yang01}
P.~W. O'Hearn, H.~Yang, and J.~C. Reynolds.
\newblock Local reasoning about programs that alter data structures.
\newblock In {\em Proc. of CSL'01}, pages 1--19, Paris, France, 2001.

\bibitem{yang-ohearn-reynolds-popl04}
P.~W. O'Hearn, H.~Yang, and J.~C. Reynolds.
\newblock Separation and information hiding.
\newblock In {\em Proc. of POPL'04}, pages 268--280, Venice, Italy, 2004.

\bibitem{parkinson-bierman-popl05}
M.~Parkinson and G.~Bierman.
\newblock Separation logic and abstraction.
\newblock In {\em Proc. of POPL'05}, pages 247--258, Long Beach, CA, USA, 2005.

\bibitem{abadi-plotkin}
G.~Plotkin and M.~Abadi.
\newblock A logic for parametric polymorphism.
\newblock In {\em Proc. of TLCA'93}, pages 361--375, Utrecht, Netherlands,
  1993.

\bibitem{reynolds}
J.~Reynolds.
\newblock Types, abstraction, and parametric polymorphism.
\newblock {\em Information Processing}, 83:513--523, 1983.

\bibitem{reynolds02}
J.~C. Reynolds.
\newblock Separation logic: A logic for shared mutable data structures.
\newblock In {\em Proc. of LICS'02}, pages 55--74, Copenhagen, Denmark, 2002.

\bibitem{PittsAM:monsf}
M.~R. Shinwell and A.~M. Pitts.
\newblock On a monadic semantics for freshness.
\newblock {\em Theoretical Computer Science}, 342:28--55, 2005.

\bibitem{torp-smith-phd-2005}
N.~Torp-Smith.
\newblock {\em Advances in Separation Logic --- A Study of Logics for Reasoning
  about Stateful Programs}.
\newblock PhD thesis, IT University of Copenhagen, 2005.

\bibitem{yang-relational-separation-logic}
H.~Yang.
\newblock Relational separation logic.
\newblock {\em Theoretical Comput. Sci.}, 2005.
\newblock (to appear).

\end{thebibliography}

\end{document}
