

\documentclass[letterpaper,10pt,conference]{ieeeconf}  \IEEEoverridecommandlockouts                              \overrideIEEEmargins
\pdfoutput=1

\usepackage{xspace}
\usepackage[english]{babel}
\usepackage[latin1]{inputenc}

\usepackage{amsmath,amssymb}
\usepackage{enumerate}



\usepackage{tikz}
\usetikzlibrary{automata,positioning}
\tikzset{initial text={},
    every state/.style={circle,minimum size=.3cm,draw=blue!50,very thick,fill=blue!20},
    secret/.style={minimum size=.4cm,draw=red!50,very thick,fill=red!20,rectangle},
    node distance=1.5cm,on grid,auto,
    bend angle=65}
\usetikzlibrary{positioning,calc,chains}
\usetikzlibrary{automata,fit}
\usetikzlibrary{backgrounds}
\usetikzlibrary{decorations.pathreplacing}
\usetikzlibrary{fadings}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{decorations.pathreplacing}

\def\ie{{i.e.},~}
\def\eg{{e.g.},~}
\def\wrt{{w.r.t.}~}
\def\st{{s.t.}~}
\def\emptyset{\varnothing}

\def\aonemove{\textit{Move}}
\def\parti{{\wp}}
\def\Trace{\textit{Tr}}
\def\trace{\textit{tr}}
\def\strace{\textit{Symbtr}}
\def\faulty{\textit{Faulty}}
\def\faultytr{\textit{Faulty}^{\textit{tr}}}
\def\nonfaulty{\textit{NonFaulty}}
\def\nonfaultytr{\textit{NonFaulty}^{\textit{tr}}}
\def\runs{\textit{Runs}} \def\lang{{\cal L}} \def\tr{\textsf{\upshape
    \bfseries trace}} \def\cost{\textit{Cost}}
\def\states{\textit{States}} \def\rond{\circ} \newcommand{\proj}[1]{\boldsymbol{\pi}_{/#1}} \newcommand{\card}[1]{|#1|} \newcommand{\pref}[1]{\textsf{\upshape \bfseries
    Pref}(#1)} 

\newcommand{\vect}[1]{\mathbf{#1}}

\newtheorem{prob}{Problem}  \newtheorem{definition}{Definition} 
\newtheorem{theorem}{Theorem} 
\newtheorem{remark}{Remark} 
\newtheorem{example}{Example} 
\newtheorem{corollary}{Corollary} 

\newcommand{\sem}[1]{[\![#1]\!]}

\newcommand{\setN}{\mathbb N}
\newcommand{\setR}{\mathbb R}
\newcommand{\setB}{\mathbb B}
\newcommand{\setZ}{\mathbb Z}
\newcommand{\setQ}{\mathbb Q}

\def\calA{{\cal A}}
\def\calB{{\cal B}}
\def\calD{{\cal D}}
\def\calM{{\cal M}}
\def\calC{{\cal C}}
\def\calF{{\cal F}}
\def\calO{{\cal O}}
\def\calP{{\cal P}}
\def\calR{{\cal R}}
\def\calU{{\cal U}}
\def\cc{\calC}
\def\next{\textit{Next}}
\def\diverge{\textsf{Diverge}}
\def\enabled{\textit{en}}
\def\post{\textsf{Succ}}
\def\hist{\textsf{Hist}}
\newcommand{\out}[1]{{\mathit{Out}}(#1)}
\def\cpre{\textit{Cpre}}
\def\last{\textit{last}}

\def\Cost{\textit{Cost}}
\def\MeanCost{\textit{}}

\newcommand{\setobs}[1]{[#1 \mapsto 2^{#1}]}
\newcommand{\setmask}[1]{[#1 \mapsto \setN^*]}




\def\endef{\ifmmode\squareforged\else{\unskip\nobreak\hfil
\penalty50\hskip1em\null\nobreak\hfil
\parfillskip=0pt\finalhyphendemerits=0\endgraf}\fi}

\def\endex{\ifmmode\squareforged\else{\unskip\nobreak\hfil
\penalty50\hskip1em\null\nobreak\hfil
\parfillskip=0pt\finalhyphendemerits=0\endgraf}\fi}




\def\ssi{iff\xspace}

\def\aonemove{\textit{Move}}
\def\atwomove{\textit{Move}}

\def\motvide{\varepsilon}
\def\tauac{\tau}

\def\det{\textit{Det}}

\def\delaimax{\textit{Max}_d}


\newcommand{\dur}{{\textit{Dur}}} \def\inv{\textit{Inv}}

\def\tw{\textit{TW\/}}

\def\dive{\textit{Div}} \def\bad{\textit{Bad}}
\def\untimed{\textit{Unt}} \def\dta{DTA\xspace}
\def\dtamu{DTA\xspace}

\def\true{\mbox{\textsc{true}}}
\def\false{\mbox{\textsc{false}}}
\def\obs{\textit{Obs}\xspace}
\def\rg{\textit{RG}}





\newcommand{\FC}[1]{\textcolor{blue}{#1}}
\def\uppaal{\textsc{Uppaal}\xspace}





\title{\LARGE \bf Dynamic Observers for Fault Diagnosis of Timed
  Systems}


\author{Franck Cassez, \IEEEmembership{Member, IEEE}\thanks{Franck Cassez is with National ICT Australia \& CNRS, Locked
    Bag 6016, The University of New South Wales, Sydney NSW~1466,
    Australia. \texttt{\scriptsize
      franck.cassez@cnrs.irccyn.fr,Franck.Cassez@nicta.com.au}}\thanks{Author supported by a Marie Curie International Outgoing
    Fellowship within the 7th European Community Framework Programme.}
}



\begin{document}
\maketitle
  
\thispagestyle{empty}

\begin{abstract} 
  In this paper we extend the work on \emph{dynamic ob\-servers} for
  fault diagnosis~\cite{cassez-acsd-07,cassez-tase-07,cassez-fi-08} to
  timed automata. We study sensor minimization problems with static
  observers and then address the problem of computing the most
  permissive dynamic observer for a system given by a timed automaton.
\end{abstract}

\section{Introduction}


Discrete-event systems~\cite{RW87} (DES) can be modelled by finite
automata over an alphabet of actions/events .  The fault
diagnosis problem~\cite{Raja95} for DES consists in detecting
\emph{faulty} sequences in the system.
A \emph{faulty} sequence is a sequence of the DES containing an
occurrence of a special event .  It is assumed that an external
\emph{observer} which has to detect faults, knows the
specification/model of the DES, but can partially observe the system
at runtime: it is able to observe sequences of \emph{observable}
events in .  Based on this knowledge, it
has to announce whether an observation (in ) stems from a
faulty sequence (in ). Checking diagnosability of DES can be done in PTIME and computing a
diagnoser amounts to determinizing the DES
(EXPTIME)~\cite{Raja95,Jiang-01,yoo-lafortune-tac-02}.
\smallskip

\noindent{\it \bfseries Fault Diagnosis for Timed Automata.} 
The fault diagnosis problem for Timed Automata (TA) has been
introduced and solved by S.~Tripakis in~\cite{tripakis-02}, where he
proved that checking {diagnosability} of a timed automaton is
PSPACE-complete.  In the timed case however, the diagnoser may be a
Turing machine.  In a subsequent work by P.~Bouyer~and
F.~Chevalier~\cite{Bouyerfossacs05}, the problem of checking whether a
timed automaton is diagnosable using a diagnoser which is a
\emph{deterministic} timed automaton (DTA) was studied, and they
proved that this problem was 2EXPTIME-complete.
\smallskip

\noindent{\it \bfseries Our Contribution and Related Work.} 
In~\cite{cassez-acsd-07,cassez-tase-07} (and~\cite{cassez-fi-08} for
an extended version), we have introduced \emph{dynamic observers} for
fault diagnosis of DES.  In this framework, an observer can choose
dynamically which events it is going to observe and make a new choice
after each occurrence of any (currently) observable event.
In~\cite{cassez-acsd-07,cassez-fi-08} we have shown how to compute
(2EXPTIME) a \emph{most permissive observer} which represents all the
the dynamic observers that ensures that a DES is diagnosable.
In~\cite{cassez-tase-07} we have furthermore introduced a notion of
\emph{cost} of an observer, and proved that an optimal observer could
also be computed in 2EXPTIME.


In this paper, we extend the previous results for systems given by
timed automata. We first settle the complexity of some optimization
problems with static observers (section~\ref{sec-static}).  We then
focus on dynamic \emph{timed} observers, and show how to compute
(section~\ref{sec-dynamic}) a most permissive (timed) dynamic
observer, under the assumption of bounded \emph{resources}. In
section~\ref{sec-cost}, we define a notion of \emph{cost} for timed
observers (which extends the one we have defined for DES
in\cite{cassez-tase-07}) and show how to compute the cost of a given
observer.  We also discuss the problem of synthesizing an optimal
timed dynamic observer.




\section{Preliminaries}\label{sec-prelim}
 denotes a finite alphabet and  where  is the \emph{unobservable}
action.   is the set of boolean values,
 the set of natural numbers,  the set of integers and
 the set of rational numbers.   is the set of real
numbers and  is the non-negative real numbers.

\subsection{Clock Constraints}
Let  be a finite set of variables called \emph{clocks}.  A
\emph{clock valuation} is a mapping . We let  be the set of clock valuations over
. We let  be the \emph{zero} valuation where all the
clocks in  are set to  (we use  when  is clear from
the context).  Given ,  denotes the
valuation defined by . We let 
be the set of \emph{convex constraints} on , \ie the set of
conjunctions of constraints of the form  with  and . Given a constraint  and a valuation , we write  if  is
satisfied by .  Given  and a valuation , 
is the valuation defined by  if  and
 otherwise.

\subsection{Timed Words}
The set of finite (resp. infinite) words over  is 
(resp. ) and we let . We let  be the empty word. A \emph{language}
 is any subset of . A finite (resp. infinite)
\emph{timed word} over  is a word in  (resp. ).   is the duration of a timed word 
which is defined to be the sum of the durations (in )
which appear in ; if this sum is infinite, the duration is
.  Note that the duration of an infinite word can be finite,
and such words which contain an infinite number of letters, are called
\emph{Zeno} words.

 is the set of finite timed words over ,
, the set of infinite timed words and
. A \emph{timed
  language} is any subset of . 

In this paper we write timed words as 
where the real values are the durations elapsed between two letters:
thus  occurs at global time . 
We let  be the \emph{untimed} ver\-sion of  ob\-tai\-ned by
erasing all the durations in ,
\eg .
Given a timed language , we
let .

Let  be the projection of timed words of 
over timed words of .  When projecting a timed word 
on a sub-alphabet , the durations elap\-sed
bet\-ween two events are set accordingly: for instance

(projection erases some letters but keep the time elapsed between two
letters).    Given ,
.

\subsection{Timed Automata}
Timed automata (TA) are finite automata extended with real-valued clocks to
specify timing constraints between occurrences of events.  For a
detailed presentation of the fundamental results for timed automata,
the reader is referred to the seminal paper of R.~Alur and
D.~Dill~\cite{AlurDill94}.
\noindent\begin{definition}[Timed Automaton]\label{def-ta} 
  A \emph{Timed Automaton}  is a tuple  
   where:
 is a finite set of  \emph{locations}; 
 is the \emph{initial location};
 is a finite set of \emph{clocks};
 is a finite set of \emph{actions}; 
 is a finite set of \emph{transitions}; for
,  is the \emph{guard},  the \emph{action},
and  the \emph{reset} set;
 associates with each location an
  \emph{invariant}; as usual we require the invariants to be
  conjunctions of constraints of the form  with .
 and  are respectively the
  \emph{final} and \emph{repeated} sets of locations. \endef
\end{definition}
A \emph{state} of  is a pair .
A \emph{run}  of  from  is a (finite or
infinite) sequence of alternating \emph{delay} and \emph{discrete}
moves:

\st for every :
\begin{itemize}
\item  for ;
\item there is some transition 
  \st: ()  and ()
  .
\end{itemize}
The set of finite (resp. infinite) runs from a state  is denoted  (resp. )
and we define ,
  and finally .  If 
is finite and ends in , we let .  Because of
the den\-se\-ness of the time domain, the transition graph of  is
infinite (uncountable number of states and delay edges).
The \emph{trace}, , of a run  is the timed
word .  We let
.  For , we
let \varrho \in V.


A finite (resp. infinite) timed word  is \emph{accepted} by  if
it is the trace of a run of  that ends in an -location (resp. a
run that reaches infinitely often an -location).  
(resp. ) is the set of traces of finite
(resp. infinite) timed words accepted by , and  is the set of timed words accepted by .
In the sequel we often omit the sets  and  in TA and this
implicitly means  and .

A timed automaton  is \emph{deterministic} if there is no 
labelled transition in , and if, whenever  and
 are transitions of , .   is \emph{complete} if from each state , and
for each action , there is a transition  such
that .  We note \dta the class of deterministic timed
automata.


\iffalse
\medskip

A finite automaton (FA) is a particular TA with .
Consequently guards and invariants are vacuously true and time
elapsing transitions do not exist.  We write 
 for a FA.  A run is thus a
sequence of the form:

where for each , .
Definitions of traces and languages are straightforward.  In this
case, the duration of a run  is the number of steps
(including -steps) of : if  is finite and
ends in ,  and otherwise
.
\fi


\subsection{Region Graph of a TA}
The \emph{region graph}  of a TA  is a finite quotient of
the infinite graph of  which is time-abstract bisimilar to
~\cite{AlurDill94}.  It is a finite automaton (FA) on the alphabet
. The states of  are pairs 
where  is a location of  and  is a \emph{region} of
. More generally, the edges of the graph are tuples
 where  are states of  and .
Genuine unobservable moves of  labelled  are labelled by
tuples of the form  in .
An edge  in the region graph corresponds to a discrete
transition of  with guard , action  and reset set .
A  move in  stands for a delay move to the
time-successor region.  The initial state of  is
.  A final (resp. repeated) state of  is a
state  with  (resp. ).  A
fundamental property of the region graph~\cite{AlurDill94} is:
\begin{theorem}[\cite{AlurDill94}] \label{thm-alur}
  . 
\end{theorem}
\iffalse
In other words:
  \begin{enumerate}
  \item if  is accepted by , then there is a timed word 
    with  \st  is accepted by .
  \item if  is accepted by , then  is accepted
    .
  \end{enumerate}
\fi
  The (maximum) size of the region graph is exponential in the number
  of clocks and in the maximum constant of the automaton 
  (see~\cite{AlurDill94}):  where  is the largest constant used in .

\subsection{Product of TA}
\begin{definition}[Product of two TA] \label{def-prod-sync} Let
    for ,
  be two TA \st .  The \emph{product} of
   and  is the TA   given by:
;
;
;
; and
 and
    
    if:
    \begin{itemize}
    \item either , and ()  for  and ; ()  and
      () ;
    \item or for  or , , and ()
      ; () 
      and () ;
\end{itemize}
and finally .
     \endef
\end{definition}





\section{Fault Diagnosis Problems \& Known Results}\label{sec-fd}

\subsection{The Model}
To model timed systems with faults, we use timed automata on the
alphabet  where  is
the \emph{faulty} (and unobservable) event. We only consider one type
of fault, but the results we give are valid for many types of
faults : indeed solving the many types
diagnosability problem amounts to solving  one type diagnosability
problems~\cite{yoo-lafortune-tac-02}.
The observable events are given by  and
 is always unobservable.

The system we want to supervise is given by a TA
. Fig.~\ref{fig-ex-diag1}
gives an example of such a system.  Invariants in the automaton 
 are written within square brackets as in .
\begin{figure}[hbtp]
  \centering
  \begin{tikzpicture}[thick,node distance=1cm and 2.5cm]\node[state,initial] (l0) {}; 
    \node[state] (l1) [above right=of l0,xshift=-1cm,yshift=0.5cm,label=-87:{}] {}; 
    \node[state] (l2) [above right=of l1,label=-87:{}] {};
    \node[state] (l3) [below right=of l1,label=-87:{}] {};
    \node[state] (l4) [above right=of l3] {};
    \node[state] (l5) [below right=of l0] {};
\path[->] (l0) edge node[pos=0.5] {} (l1) 
                edge[bend angle=30,bend left] node[pos=0.5]  {} (l5)
                edge node[pos=0.5]  {} (l5)
                edge[bend angle=30,bend right] node[swap,pos=0.7]  {} (l5)
              (l1) edge [pos=0.7] node  {; } (l2)
              (l1) edge  node  {; } (l3)
              (l2) edge  [] node  {} (l4)
              (l3) edge  [] node  {} (l4)
              ;
    \path[->] (l4) edge[loop above] node {} (l4);
    \path[->] (l5) edge[loop right] node {} (l5);
  \end{tikzpicture}
\caption{The Timed Automaton }
\label{fig-ex-diag1}
\end{figure}

\noindent Let . A run of 

is -faulty if: (1) there is an index  \st  and (2)
the duration of the run  is larger than .  We let
 be the set of -faulty runs of .
Note that by definition, if  then . We let
 be the set of faulty runs of , and  be the set of non-faulty runs of .
Moreover we use   and
 
which are the traces\footnote{Notice that  erases
   and .} of -faulty and non-faulty runs of .

\subsection{Diagnosers}
The purpose of fault diagnosis is to detect a fault as soon as
possible.  Faults are unobservable and only the events in 
can be observed as well as the time elapsed between these events.
Whenever the system generates a timed word , the observer can only
see .  If an observer can detect faults in this
way it is called a \emph{diagnoser}.  A diagnoser must detect a fault
within a given delay .

\begin{definition}[-Diagnoser]\label{def-diag}
  Let  be a TA over the alphabet ,  and .  A
  \emph{-diagnoser} for  is a mapping  such that:
  \begin{itemize}
  \item for each ,
    ,
  \item for each ,
    . \endef
  \end{itemize}
\end{definition}
 is -diagnosable if there exists a
-diagnoser for .  is -diagnosable
if there is some  \st  is
-diagnosable.

\begin{example}
  The TA  in Fig.~\ref{fig-ex-diag1} with
   is -diagnosable.  For the
  timed words with an  followed by either a  or a  a fault
  must have occurred.  Otherwise no fault should be reported.
If , in  there are two runs:
  
  that satisfy , and thus  is
  not -dia\-gnosable. To diagnose a fault in , 
  must be observed. \endex
\end{example}

\subsection{Classical Diagnosis Problems}
\noindent
Assume  is a TA
.  The
classical fault diagnosis problems are the following: \begin{prob}[Bounded or -Diagnosability] \label{prob-delta-diag} \mbox{} \\
  \textsc{Inputs:} A  TA , , and . \\
  \textsc{Problem:} Is  -diagnosable?
\end{prob}
\begin{prob}[Diagnosability] \label{prob-diag} \mbox{} \\
  \textsc{Inputs:} A TA  and . \\
  \textsc{Problem:} Is  -diagnosable?
\end{prob}
\begin{prob}[Maximum delay] \label{prob-delay} \mbox{} \\
  \textsc{Inputs:} A TA  and and . \\
  \textsc{Problem:} If  is -diagnosable, what is the
  minimum  \st  is -diagnosable ?
\end{prob}
\smallskip



According to Definition~\ref{def-diag}, 
is -diagnosable, \ssi, there is some  \st
 is -diagnosable. Thus  is not -diagnosable
\ssi ,  is not  -diagnosable.
Moreover a trace based definition of
-diagnosability can be stated as\footnote{This
  definition does not take into account \emph{Zeno} runs; this is not
  difficult to add and the reader is referred to~\cite{cassez-cdc-09}
  for more details.}:  is -diagnosable \ssi

This gives a necessary and sufficient condition for non
-diagnosability:

or in other words, there is no pair of runs  with
,  the
-traces of which are equal.


Complexity results for the diagnosis problems on timed automata were
established in~\cite{tripakis-02} (see~\cite{cassez-cdc-09} for a
comprehensive study) and
Problems~\ref{prob-delta-diag}--\ref{prob-delay} are PSPACE-complete
(note that PSPACE-completeness already holds for ).


\section{Sensor Minimization with Static Observers}
\label{sec-static}
In this section, we extend the results of~\cite{cassez-acsd-07} to
systems given by TA.


\begin{prob}[Minimum Cardinality Set] \label{prob-static-minimum} \mbox{} \\
  \textsc{Inputs:} A  TA  and . \\
  \textsc{Problem:}
  \begin{itemize}
  \item[(A)] Is there any set , with
     \st  is -diagnosable ?
  \item[(B)] If the answer to~(A) is ``yes'', compute the minimum
    value for .
  \end{itemize}
\end{prob}
\begin{theorem}
  Problem~\ref{prob-static-minimum} is PSPACE-complete.
\end{theorem}
\begin{proof}
  PSPACE-easiness for (A) can be established as follows: guess a set
   with  and check (in PS\-PACE) whether  is
  -diagnosable. This proves  NPSPACE and thus in
  PSPACE.  PSPACE-hardness follows from the reduction of
  Problem~\ref{prob-diag} to Problem~\ref{prob-static-minimum}.(A)
  with .  This establishes PSPACE-completeness for (A).
  Computing the minimum  can be done using a binary search
  (dichotomy) and thus (B) is also in PSPACE.
\end{proof}

\medskip The previous results also hold in a more general setting
using \emph{masks}.  Masks are useful to capture the notion of
\emph{distinguishability} among observable events.  Indeed, there are
cases where two events  and  are observable but not
distinguishable, that is, the diagnoser knows that  or 
occurred, but not which of the two. This is not the same as
considering  and  to be unobservable, since in that case the
diagnoser would not be able to detect the occurrence of  or .
Distinguishability of events is captured by the notion of a
\emph{mask}~{\cite{Varaiyaetal88}}.

\begin{definition}[Mask]\label{def-mask}
  A \emph{mask}  (of size ) over  is a total,
  surjective function . \endef
\end{definition}
 induces a morphism , where
 and , for
 and .  For example, if
,  and ,
, , then we have .


\begin{definition}[-diagnoser]\label{def-mask-diag} Let
   be a mask over . A mapping  is a
  \emph{-diagnoser} for  if:
  \begin{itemize}
  \item for each ,
    ;
  \item for each ,
    . \endef
  \end{itemize}
\end{definition}

 is -diagnosable if there is a
-diagnoser for .  is said to be
-diagnosable if there is some  such that  is
-diagnosable.  Given a mask  and , checking
whether  is -diagnosable can be done in PSPACE: it suffices
to replace each event  by  and check for
diagnosability. It is PSPACE-complete as using an identity mask of
cardinality  solves Problem~\ref{prob-diag}.

The counterpart of Problem~\ref{prob-static-minimum} with masks is the
following:

\begin{prob}[Minimum Cardinality Mask] \label{prob-static-mask} \mbox{} \\
  \textsc{Inputs:} A  TA  and . \\
  \textsc{Problem:}
  \begin{itemize}
  \item[(A)] Is there any mask , \st  is -diagnosable?
  \item[(B)] If the answer to~(A) is ``yes'', compute the minimum value for .
  \end{itemize}
\end{prob}
\begin{theorem}\label{thm-mask}
  Problem~\ref{prob-static-mask} is PSPACE-complete.
\end{theorem}
\begin{proof}
  PSPACE-easiness is proved by: 1) guessing a mask  and
  checking (in PSPACE) that  is -diagnosable.
  PSPACE-hardness is proved as follows.  If there is a mask 
  with  \st  is -diagnosable, then, as  is
  surjective, it must be the case that  is a one-to-one mapping
  from  to . It follows that
   is -diagnosable.  Conversely, assume
  .  If  is -diagnosable then
  there is a mask  with  \st  is
  -diagnosable.  Hence
  Problem~\ref{prob-static-mask}.(A) is PSPACE-complete.
  Problem~\ref{prob-static-mask}.(B) can be solved in PSPACE as well
  using a binary search. It is not difficult to reduce reachability
  for TA with one action to checking whether there is a mask of size
   and thus Problem~\ref{prob-static-mask}.(B) is PSPACE-complete.
\end{proof}
\begin{remark}
  The assumption that a mask is surjective can be lifted still
  preserving Theorem~\ref{thm-mask}. Indeed, if there is a mask
   \st  is -diagnosable and  is not
  surjective, then we can build  with  surjective
  \st  is -diagnosable (intuitively,  is more
  discriminating than  and has a greater distinguishing power).
\end{remark}

\section{Sensor Minimization with Dynamic Observers}
\label{sec-dynamic}
The use of \emph{dynamic observers} was already advocated for DES
in~\cite{cassez-acsd-07,cassez-fi-08}.  We start with an example that
shows that dynamically choosing what to observe can be even more
efficient using timing information.

\begin{example}
  Let  be the automaton of Figure~\ref{fig-ex-diag1}.  To
  diagnose , we can use a \emph{dynamic observer} that
  switches ,  and -sensors on/off.  If we do not measure time,
  to be able to detect faults in , we have to switch the 
  sensor on at the beginning. When an  has occurred, we must be
  ready for either an  or a  and therefore, switch on the 
  and  sensors on. A dynamic observer must thus first observe
   and after an occurrence of , observe .

  If the observer can measure time using a clock, say , it can
  first switch the  sensor on. If an  occurs when ,
  then switch the  sensor on and if  switch the  sensor
  on. This way the observer never has to observe more than event at
  each point in time. \endex
\end{example}


\subsection{Dynamic Observers}
The choice of the events to observe can depend on the choices the
observer has made before and on the observations (event, time-stamp) it
has made. Moreover an observer may have \emph{unbounded} memory.  The
following definition extends the notion of observers introduced
in~\cite{cassez-acsd-07} to the timed setting.
 
\begin{definition}[Observer]\label{def-observer2}
  An \emph{observer} \obs over  is a \emph{deterministic and
    complete} timed automaton 
   together with a mapping , where  is a (possibly infinite) set of
  locations,  is the initial location,  is the set
  of observable events,  is the transition function (a total
  function), and  is a labeling function that specifies the set of
  events that the observer wishes to observe when it is at location
  . The invariant\footnote{In the sequel, we omit the invariant
    when a TA is an observer, and replace it by the mapping .}
   maps every location to , implying that an
  observer cannot prevent time from elapsing. We require that, for any
  location  and any , if  then
  : this means the observer does
  not change its location nor resets its clocks when an event it has
  chosen not to observe occurs.  \endef
\end{definition}
As an observer is deterministic we let  
denote the state  reached after reading the timed word  and
 is the set of events  observes after .

\noindent An observer defines a {\em transducer} which is a mapping
. Given a word
,  is the out\-put of the transducer on .  It is
called the \emph{observation} of  by the observer \obs.

\subsection{Diagnosability with Dynamic Observers}
\begin{definition}[-diagnoser] \label{def-obsk-diag}
  Let  be a TA over  and \obs be an observer
  over .  is an
  \emph{-diagnoser} for  if:
  \begin{itemize}
  \item ,
     and
  \item ,
    . \endef
  \end{itemize}
\end{definition}
 is -diagnosable if there is an
-diagnoser for .  is \obs-diagnosable if there is
some  such that  is -diagnosable.

We now show how to check -diagnosability when the observer
 is a DTA.
\begin{prob}[Deterministic Timed Automata Observers] \label{prob-dynamic-ta} \mbox{} \\
  \textsc{Inputs:} A TA  and
  an observer given by a \dta
  . \\
  \textsc{Problem:}
  \begin{itemize}
  \item[(A)] Is  -diagnosable?
  \item[(B)] If the answer to~(A) is ``yes'', compute the minimum 
    \st  is -diagnosable.
  \end{itemize}
\end{prob}

\begin{theorem}
  Problem~\ref{prob-dynamic-ta} is PSPACE-complete.
\end{theorem}

\begin{proof}
  PSPACE-hardness follows from the fact that taking an observer which
  always observes  solves
  Problem~\ref{prob-diag}.  We prove that
  Problem~\ref{prob-dynamic-ta} is in PSPACE.  The following
  construction is an extension of the one for DES~\cite{cassez-fi-08}.
  Recall that  is complete.  Define the timed automaton  as follows:
   and the transition relation
   is given by:
\begin{itemize}
\item  iff  \st ,
   and  if ,  otherwise;
\item  iff 
   \st .
\end{itemize}
The TA  is an unfolding of  which reveals what is
observable at each product location.

From the previous construction, it follows that: for each ,  is -diagnosable iff  is
-diagnosable.  As the size of  is
, we can solve Problem~\ref{prob-dynamic-ta}.(A) in
PSPACE.  Problem~\ref{prob-dynamic-ta}.(B) can also be solved using a
binary search, in PSPACE.
\end{proof}

\subsection{Synthesis of the Most Permissive Dynamic Diagnoser}
In this section we address the problem of \emph{synthesizing} a \dta
dynamic observer which ensures
diagnosability. Following~\cite{cassez-fi-08}, we want to compute a
\emph{most permissive} observer ( if none exists), which
gives a representation of all the good observers.  Indeed, checking
whether there exists a DTA observer  \st  is
-diagnosable is not an interesting problem: it suffices to check
that  is -diagnosable as the DTA observer which observes
 continuously will be a solution.


When synthesizing (deterministic) timed automata, an important issue
is the amount of \emph{resources} the timed automaton can use: this
can be formally defined~\cite{BDMP-cav-2003} by the (number of) clocks, ,
that the automaton can use, the maximal constant , and a
\emph{granularity} . As an example, a TA of resource
 can use two clocks,  and , and the
clocks constraints using the rationals  where  and .  A \emph{resource}  is thus a triple
 where  is finite set of clocks,  and  is the \emph{granularity}.
\dtamu is the class of \dta of resource .
\begin{remark}
  Notice that the number of locations of the \dta in \dtamu is not
  bounded and hence this family has an infinite (yet countable) number
  of elements.
\end{remark}

We now focus on the following problem :
\begin{prob}[Most Permissive Dynamic -Diagnoser] \label{prob-dynamic-synth} \mbox{} \\
  \textsc{Inputs:} A TA ,
  ,
  and a resource .\\
  \textsc{Problem:} Compute the set  of all observers in \dtamu,
  \st  is -diagnosable iff .
\end{prob}
For DES, the previous problem can be solved by computing a most
permissive observer, and we refer to~\cite{cassez-fi-08} section~5.5
for the formal definition of the most permissive observer. This can be
done in 2EXPTIME~\cite{cassez-fi-08}, and the solution is a reduction
to a safety control problem under partial observation.  For the timed
case, we cannot use the same solution as controller synthesis under
partial observation is undecidable~\cite{BDMP-cav-2003}.  The solution
we present for Problem~\ref{prob-dynamic-synth} is a modification of
an algorithm originally introduced in~\cite{Bouyerfossacs05}. 


\subsection{Fault Diagnosis with DTA~\cite{Bouyerfossacs05}}\label{sec-algo}
In case a TA  is -diagnosable, the diagnoser is a
mapping~\cite{tripakis-02} which performs a state estimate of 
after a timed word  is read by .  For DES, it is obtained by
\emph{determinizing} the system, but we cannot always determinize a TA
 (see~\cite{AlurDill94}).  And unfortunately testing whether a
timed automaton is determinizable is
undecidable~\cite{Finkel05,TripakisFolk}.


P.~Bouyer and F.~Chevalier in~\cite{Bouyerfossacs05} considers the
problem of deciding whether there exists a diagnoser which is a DTA
using resources in :

\begin{prob}[\dtamu -Diagnoser~\cite{Bouyerfossacs05}] \label{prob-dtamu} \mbox{} \\
  \textsc{Inputs:} A TA ,
  ,
  and a resource .\\
  \textsc{Problem:} Is there any  \st  is
  -dia\-gnosable ?
\end{prob}
\begin{theorem}[\cite{Bouyerfossacs05}]
Problem~\ref{prob-dtamu}  is 2EXPTIME-complete.
\end{theorem}

The solution to the previous problem is based on the construction of a
\emph{two-player game}, the solution of which gives the \emph{set} of
all  diagnosers (the most permissive diagnosers) which
can diagnose  (or  is there is none).

We recall here the construction of the two-player game.

Let  be a TA, .  Define  as follows:
\begin{itemize}
\item , for , \ie 
  elements are copies of the locations in ,
\item  is (new) clock not in ,
\item for , ,
  , and 
  ,
\item the transition relation is given by:
  \begin{itemize}
  \item for ,  if  and ,
  \item for ,  if  and ,
  \item  if  and ,
  \item .
  \end{itemize}
\end{itemize}
The previous construction creates  copies of : the system starts
in copy , when a fault occurs it switches to copy , resetting
the clock , and when in copy  (a fault has occurred) it can
switch to copy  after  time units.  We can then define
 as the non-faulty locations, and  as the -faulty
locations.



Given a resource  (), a
\emph{minimal guard} for  is a guard which defines a region of
granularity . We define the (symbolic) \emph{universal automaton}
 by:
\begin{itemize}
\item ,
\item  for each  \st ,
  , and  is a minimal guard for .
\end{itemize}

 is finite because  is finite.  Nevertheless  is
not deterministic because it can choose to reset different sets of
clocks  for a pair ``(guard, letter)'' .  To diagnose ,
we have to find when a set of clocks has to be reset. This can provide
enough information to distinguish -faulty words from
non-faulty words.

The algorithm of~\cite{Bouyerfossacs05} requires the following steps:
\begin{enumerate}
\item define the region graph ,
\item compute a \emph{projection} of this region graph:
  \begin{itemize}
  \item let  be a label of an edge in ,
  \item let  be the unique minimal guard \st ;
  \item define the projection  by  with  if  and
     otherwise.
  \end{itemize}
  The projected automaton  is
  the automaton  where each label
   is repla\-ced by .
\item determinize  (removing
   actions) and obtain ,
\item build a two-player safety game  as follows:
  \begin{itemize}
  \item each transition 
in  yi\-elds a transition in  of
    the form:

\begin{center}
      \tikz[node distance=1cm and 2.8cm]{ \node[circle,draw] (l0)
        {}; \node[rectangle,draw,right=of l0] (l2) {};
        \node[circle,draw,right=of l2] (l1) {}; \path[->] (l0)
        edge node {} (l2) ; \path[->] (l2) edge node
        {} (l1) ; }
    \end{center}

  \item the round-shaped state are the states of Player~1, whereas the
    square-shaped states are Player~0 states (the choice of the clocks
    to reset).
  \item the  states (for Player~0) are the states of the
    form  with both
    a -faulty (in ) and a non-faulty (in ) location.
  \end{itemize}
\end{enumerate}
The main results of~\cite{Bouyerfossacs05} are:
\begin{itemize}
\item there is a TA  \dtamu \st  is -diagnosable
  iff Player~0 can win the safety game ``avoid Bad''
  ,
\item it follows that Problem~\ref{prob-dtamu} can be solved in
  2EXPTIME as  has size doubly exponential in ,
   and ,
\item the acceptance problem for Alternating Turing machines of exponential
  space can be reduced to Problem~\ref{prob-dtamu} and thus it
  is 2EXPTIME-hard.
\end{itemize}


\subsection{Problem~\ref{prob-dynamic-synth} is in 2EXPTIME} \label{sec-synth}
We now show how to modify the previous algorithm to solve
Problem~\ref{prob-dynamic-synth}, and obtain the following result:
\begin{theorem}
  Problem~\ref{prob-dynamic-synth} can be solved in 2EXPTIME.
\end{theorem}
\begin{proof}
  We modify the previous algorithm as follows:
  \begin{enumerate}
  \item the automaton  is defined as follows: each location
    corresponds to a choice of a subset of events to observe. Define
    the (symbolic) \emph{universal automaton}
     by:
\begin{itemize}
\item for , ,
\item  for each , 
  \st , , and  is a minimal guard for
  . 
\end{itemize}
\item when computing , the set of
  observable events (step~2 in the algorithm of
  section~\ref{sec-algo}) are defined according to the location  of
  .  Formally, the projection of  is  if the
  location of  is  and  and  otherwise.
  \end{enumerate}
  The size of  is  where  is
  the maximal constant of ; it is thus exponential in
   and .  The determinization is thus doubly exponential
  in ,  and . We can then build a new game
   as described in section~\ref{sec-algo} before.
  The proof that the most permissive strategy in the new game
   is the most permissive observer is along the
  lines of the one given in~\cite{Bouyerfossacs05} with minor
  modifications.
Solving a safety game is linear in the size of the game and thus
  computing the most permissive observer of resource  can de done
  in 2EXPTIME.
\end{proof}

\begin{remark}
  In~\cite{Bouyerfossacs05} it is also proved that for Event Recording
  Automata (ERA)~\cite{AFH94} Problem~\ref{prob-dtamu} becomes
  PSPACE-complete.  This result does not carry over in our case, as
  there is still an exponential step with the choice of the sets of
  events to be observed.
\end{remark}

\section{Optimal Dynamic Observers}\label{sec-cost}
In this section we extend the notion of \emph{cost} defined for finite
state observers in~\cite{cassez-fi-08} to the case of timed observers.

\subsection{Weighted/Priced Timed Automata}
Weighted/priced timed automata were introduced in~\cite{BFH+01,ATP01}
and they extend TA with \emph{prices/costs/weights} on the time
elapsing and discrete transitions.

\begin{definition}[Priced Timed Automata]
  A \emph{priced timed auto\-ma\-ton (PTA)} is a pair 
  where   is a timed automaton
  and  is a \emph{cost function} which is a mapping from  to . \endef
\end{definition}
Let 

be a run of . We denote by 
the discrete transition taken from  to
.

The \emph{cost} of the run  is defined by:

The \emph{mean cost} of  is defined to be the cost per time
unit and given\footnote{Runs of duration  are not taken into
  account.} by .  The
cost of runs of duration  is defined by
 The \emph{maximal mean cost} of
 is .  The minimal mean cost is defined dually and denoted
.

\subsection{Cost of an Observer}
To select a best or optimal dynamic observer which ensures
-diagnosability, we need to define a metric to compare them.
We extend the one defined in~\cite{cassez-fi-08} for DES to take into
account (real) time elapsing.

Let  be a TA and  a DTA observer.   is extended into a
P(D)TA by associating costs with locations and transitions.  The cost
associated with the discrete transitions is the cost of switching on
the sensors for a set of observable events, and the cost of a location
is the cost per time unit of having a set of sensors activated.

Let  be a run of .  As \obs is deterministic (and complete)
there is exactly one run of  the trace of which is
.  Given , let  be
this unique run. 
The average cost of the run   observed by \obs is
.

Given , the \emph{maximal mean cost} of runs of
duration  is defined by:

The \emph{maximal average cost} of the pair  is defined

We can then state the following problem:
\begin{prob}[Cost of an Observer] \label{prob-cost-obs} \mbox{} \\
  \textsc{Inputs:} A  TA   and  a PDTA observer. \\
  \textsc{Problem:} Compute .
\end{prob}


\subsection{Computing the Cost of a Given Timed Observer}
The computation of optimal infinite schedules for TA has been
addressed in~\cite{BBL-fmsd06}.  The main result of~\cite{BBL-fmsd06}  is:
\begin{theorem}[Minimal/Maximal Mean
  Cost~\cite{BBL-fmsd06}]\label{thm-pat}
  Given a PTA , com\-puting  and  is
  PSPACE-complete.
\end{theorem}
The definition of the cost of an observer is exactly the defi\-ni\-tion
of the maximal mean cost in~\cite{BBL-fmsd06} and thus:
\begin{theorem}
  Problem~\ref{prob-cost-obs} is PSPACE-complete.
\end{theorem}
\begin{proof}
  PSPACE-easiness follows from Theorem~\ref{thm-pat}: note that
  Theorem~\ref{thm-pat} assumes that the TA is bounded which is not a
  restriction as every TA can be transformed into an equivalent (timed
  bisimilar) bounded TA. For PSPACE-hardness, to compute the maximal
  mean cost of a PDTA , let  be the universal automaton on the
  alphabet of .  Consider  as an observer and solve
  Problem~\ref{prob-cost-obs}.  This solves the maximal mean cost
  computation problem for DTA.  This completes the hardness proof.
\end{proof}


\subsection{Optimal Synthesis Problem}
Checking whether the mean cost of a given observer is less than 
requires that we have computed or are given such an observer.  A more
difficult version of Problem~\ref{prob-cost-obs} is to check for the
existence of cheap dynamic observer:
\begin{prob}[Bounded Cost Dynamic Observer] \label{prob-bounded-cost} \mbox{} \\
  \textsc{Inputs:} A TA ,
  ,
   a resource and . \\
  \textsc{Problem:}
  \begin{itemize}
  \item[(A)] Is there a dynamic observer  \dtamu \st  is
    -diagnosable and  ?
  \item[(B)] If the answer to~(A) is ``yes'', compute a witness
    dynamic observer?
  \end{itemize}
\end{prob}
We cannot provide of proof that Problem~\ref{prob-bounded-cost} is
decidable.  However, we give a lower bound for
Problem~\ref{prob-bounded-cost} and later discuss the exact
complexity.
\begin{theorem}
  Problem~\ref{prob-bounded-cost} is 2EXPTIME-hard.
\end{theorem}
\begin{proof}
  We reduce Problem~\ref{prob-dtamu} which is
  2EXPTIME-hard~\cite{Bouyerfossacs05} to Problem~\ref{prob-bounded-cost}.
  Let  be a TA for which we want to check whether there exists a
  DTA observer  \dtamu \st  is -diagnosable.

  Let  be a fresh letter not in .  Define the
  automaton  depicted on Figure~\ref{fig-reduc-bounded}.  The
  upper part of  generates faulty and non-faulty runs with each
  letter including .  From each location of  (bottom part),
  we add a  transition to the initial state of .  The
  transitions of  are not depicted.
  
  For  to be diagnosable with , we must have: 1)
   always observable and 2)  always observable.
  Moreover, if  is -diagnosable, then  is
  -diagnosable. Conversely, if  is
  -diagnosable, then  is
  -diagnosable.  Hence  is
  -diagnosable iff  is
  -diagnosable.

  Define the cost of the locations to be , and  for the
  transitions in .   is diagnosable with a DTA  \dtamu
  iff there is a dynamic (yet it has to choose 
  continuously) observer  with .
  
  It follows that: there exists a \dtamu diagnoser  \st  is
  -diagnosable iff  is -diagnosable
  with a DTA observer  \dtamu and .
\end{proof}
\begin{figure}[t]
  \centering
    \begin{tikzpicture}[thick,node distance=1cm and 1cm]\small
    \tikzset{every state/.style={circle,minimum size=0.2cm,inner sep=0,draw=blue!50,very thick,fill=blue!20},bend angle=20}
    \node[state,initial] (l0) {}; 
    
    \node[state] (l1) [above right=of l0] {}; 
    \node[state] (l2) [right=of l0,xshift=1cm] {};
\node[state] (l4) [above right=of l2] {};
    \node[state] (l5) [right=of l2,xshift=1cm] {};

    \node (s1) [below left=of l0,xshift=-.3cm] {};
    \node[circle,draw,inner sep=0] (s2) [right=of s1,yshift=-.7cm,xshift=-.4cm,label=-90:{}] {};
    \node (s3) [below=of s2,xshift=1.2cm] {};
    \node (s4) [right=of s3,xshift=2cm] {};
    \node (s5) [right=of s2,xshift=1cm] {};
   \node[draw=black,inner sep=3pt,rounded corners,thick,fit= (s1) (s2) (s3) (s4) (s5),label=10:{}] (env) {};
   
\path[->] (l0) edge node[pos=0.5] {} (l1) 
                edge node[swap,pos=0.5,swap]  {} (l2)
              (l1)      edge [pos=0.5] node  {} (l2)
              (l2) edge  node  {} (l4)
              (l4) edge  node  {} (l5)
              (l2) edge  [] node  {} (l5);
    \path[->] (l0) edge[dashed,bend left] node {} (s2);
    \path[->] (s1) edge[dashed,bend left] node[pos=0.2] {} (l0);
    \path[->] (s2) edge[dashed,bend left] node[pos=0.2] {} (l0);
    \path[->] (s3) edge[dashed,bend right] node {} (l0);
    \path[->] (s4) edge[dashed,bend right,swap] node[pos=0.3] {} (l0);
    \path[->] (s5) edge[dashed,bend right,swap] node[pos=0.1] {} (l0);
    
\end{tikzpicture}
  \caption{Automaton }
  \label{fig-reduc-bounded}
\end{figure}
The status of Problem~\ref{prob-bounded-cost} is clearly unsettled as
the 2EXP\-TIME-hardness result does not imply it is even decidable.  A
solution to this problem would be to mimic the one given for
DES~\cite{cassez-fi-08}: solve a mean payoff \emph{timed} game with a
counterpart of Zwick and Paterson algorithm~\cite{zwick-95} using the
most permissive observers obtained in section~\ref{sec-synth}.  The
type of priced timed games we would have to solve has the following
features: 1) they are turn-based, as one Player picks up (controllable
moves) a set of events to be observed and then hands it over to the
other Player who tries to produce a confusing\footnote{Which is the
  trace of both a faulty and non-faulty run.} run (uncontrollable
moves); 2) they have at least two clocks (one for the system  and
one for the DTA observer); 3) the controllable choices are
\emph{urgent} \ie no time can elapse in Player~1 locations.  We denote
S-PTGA for the class of timed game automata previously defined.



Unfortunately, there is no counterpart of the general result of Zwick
\& Paterson for timed automata.  Only very few results are known for
timed mean payoff
games~\cite{BLMR-fsttcs2006,bflms-formats08,bbjlr-formats08,BFLM-hscc10}
and none of them can be used in our setting.  Nevertheless, due to the
particular nature of the mean payoff price timed game we construct (in
the class S-PTGA), we might be able to compute the optimal choices of
observable events using an algorithm similar to~\cite{BBL-fmsd06}.
Hence we could obtain a 2EXPTIME algorithm for
Problem~\ref{prob-bounded-cost}.


\section{Conclusion}\label{sec-conclu}



The results of the paper are summarized by the line ``TA'' in
Table~\ref{tab-summary}.  The complexity/decidability status of
Problem~\ref{prob-bounded-cost} is left open.  A solution to this
problem would be to solve the following optimization problem on the
class of S-PTGA:
\begin{prob}[Optimal Infinite Schedule in S-PTGA] \mbox{}\\
  \textsc{Inputs:} A S-PTGA , a set of \emph{Bad} states and .\\
  \textsc{Problem:} Is there a strategy  for Player~1 in  \st
   ( controlled by ) avoids \emph{Bad} and satisfies ?
\end{prob}

\newcommand{\vtab}[1]{
  \begin{tabular}[c]{c}
    #1
  \end{tabular}
}
\begin{table}[t]
  \centering
  \caption{Summary of the Results}
  \label{tab-summary}
  \begin{tabular}[t]{||c|c|c|c||}\hline\hline
    &  Static Observers   & \multicolumn{2}{c||}{Dynamic Observers} \\\cline{3-4}
    &  Min. Cardinality   & Most Perm. Obs. & Optimal Observer \\\hline\hline
    DES & NP-Complete~\cite{cassez-acsd-07} & 2EXPTIME~\cite{cassez-acsd-07} & 2EXPTIME~\cite{cassez-tase-07}   \\\hline
    TA & PSPACE-Complete & 2EXPTIME  &  2EXPTIME-hard \\\hline\hline
  \end{tabular}
\end{table}



\bibliographystyle{IEEEtran}
\begin{thebibliography}{10}
\providecommand{\url}[1]{#1}
\csname url@rmstyle\endcsname
\providecommand{\newblock}{\relax}
\providecommand{\bibinfo}[2]{#2}
\providecommand\BIBentrySTDinterwordspacing{\spaceskip=0pt\relax}
\providecommand\BIBentryALTinterwordstretchfactor{4}
\providecommand\BIBentryALTinterwordspacing{\spaceskip=\fontdimen2\font plus
\BIBentryALTinterwordstretchfactor\fontdimen3\font minus
  \fontdimen4\font\relax}
\providecommand\BIBforeignlanguage[2]{{\expandafter\ifx\csname l@#1\endcsname\relax
\typeout{** WARNING: IEEEtran.bst: No hyphenation pattern has been}\typeout{** loaded for the language `#1'. Using the pattern for}\typeout{** the default language instead.}\else
\language=\csname l@#1\endcsname
\fi
#2}}

\bibitem{cassez-acsd-07}
F.~Cassez, S.~Tripakis, and K.~Altisen, ``Sensor minimization problems with
  static or dynamic observers for fault diagnosis,'' in \emph{7th Int. Conf. on
  Application of Concurrency to System Design (ACSD'07)}.\hskip 1em plus 0.5em
  minus 0.4em\relax IEEE Computer Society, 2007, pp. 90--99.

\bibitem{cassez-tase-07}
------, ``Synthesis of optimal dynamic observers for fault diagnosis of
  discrete-event systems,'' in \emph{{P}roceedings of the 1st IEEE \& IFIP
  International Symposium on Theoretical Aspects of Software Engineering
  (TASE'07)}.\hskip 1em plus 0.5em minus 0.4em\relax IEEE Computer Society,
  2007, pp. 316--325.

\bibitem{cassez-fi-08}
F.~Cassez and S.~Tripakis, ``Fault diagnosis with static and dynamic
  diagnosers,'' \emph{Fundamenta Informaticae}, vol.~88, no.~4, pp. 497--540,
  Nov. 2008.

\bibitem{RW87}
P.~Ramadge and W.~Wonham, ``Supervisory control of a class of discrete event
  processes,'' \emph{SIAM Journal of Control and Optimization}, vol.~25, no.~1,
  pp. 1202--1218, 1987.

\bibitem{Raja95}
M.~Sampath, R.~Sengupta, S.~Lafortune, K.~Sinnamohideen, and D.~Teneketzis,
  ``Diagnosability of discrete event systems,'' \emph{IEEE Transactions on
  Automatic Control}, vol.~40, no.~9, Sept. 1995.

\bibitem{Jiang-01}
S.~Jiang, Z.~Huang, V.~Chandra, and R.~Kumar, ``A polynomial algorithm for
  testing diagnosability of discrete event systems,'' \emph{IEEE Transactions
  on Automatic Control}, vol.~46, no.~8, Aug. 2001.

\bibitem{yoo-lafortune-tac-02}
T.-S. Yoo and S.~Lafortune, ``Polynomial-time verification of diagnosability of
  partially-observed discrete-event systems,'' \emph{IEEE Transactions on
  Automatic Control}, vol.~47, no.~9, pp. 1491--1495, Sept. 2002.

\bibitem{tripakis-02}
S.~Tripakis, ``Fault diagnosis for timed automata,'' in \emph{{P}roceedings of
  the International Conference on Formal Techniques in Real Time and Fault
  Tolerant Systems (FTRTFT'02)}, ser. LNCS, W.~Damm and E.-R. Olderog, Eds.,
  vol. 2469.\hskip 1em plus 0.5em minus 0.4em\relax Springer Verlag, 2002, pp.
  205--224.

\bibitem{Bouyerfossacs05}
P.~Bouyer, F.~Chevalier, and D.~D'Souza, ``Fault diagnosis using timed
  automata,'' in \emph{FoSSaCS}, ser. LNCS, V.~Sassone, Ed., vol. 3441.\hskip
  1em plus 0.5em minus 0.4em\relax Springer Verlag, 2005, pp. 219--233.

\bibitem{AlurDill94}
R.~Alur and D.~Dill, ``A theory of timed automata,'' \emph{Theoretical Computer
  Science}, vol. 126, pp. 183--235, 1994.

\bibitem{cassez-cdc-09}
F.~Cassez, ``{A Note on Fault Diagnosis Algorithms},'' in \emph{48th IEEE
  Conference on Decision and Control and 28th Chinese Control
  Conference}.\hskip 1em plus 0.5em minus 0.4em\relax Shanghai, P.R. China:
  IEEE Computer Society, Dec. 2009.

\bibitem{Varaiyaetal88}
R.~Cieslak, C.~Desclaux, A.~Fawaz, and P.~Varaiya, ``Supervisory control of
  discrete-event processes with partial observations,'' \emph{IEEE Transactions
  on Automatic Control}, vol.~33, pp. 249--260, 1988.

\bibitem{BDMP-cav-2003}
P.~Bouyer, D.~D'Souza, P.~Madhusudan, and A.~Petit, ``Timed control with
  partial observability,'' in \emph{{P}roceedings of the 15th {I}nternational
  {C}onference on {C}omputer {A}ided {V}erification ({CAV}'03)}, ser. LNCS,
  W.~A. Hunt, Jr and F.~Somenzi, Eds., vol. 2725.\hskip 1em plus 0.5em minus
  0.4em\relax Boulder, Colorado, USA: Springer, July 2003, pp. 180--192.

\bibitem{Finkel05}
O.~Finkel, ``On decision problems for timed automata,'' \emph{Bulletin of the
  European Association for Theoretical Computer Science}, vol.~87, pp.
  185--190, 2005.

\bibitem{TripakisFolk}
S.~Tripakis, ``Folk theorems on the determinization and minimization of timed
  automata,'' \emph{Information Processing Letters}, vol.~99, no.~6, pp.
  222--226, 2006.

\bibitem{AFH94}
R.~Alur, L.~Fix, and T.~A. Henzinger, ``A determinizable class of timed
  automata,'' in \emph{{P}roceedings of the 6th International Conference on
  Computer Aided Verification (CAV'94)}, ser. LNCS, vol. 818.\hskip 1em plus
  0.5em minus 0.4em\relax Springer Verlag, 1994, pp. 1--13.

\bibitem{BFH+01}
G.~Behrmann, A.~Fehnker, T.~Hune, K.~G. Larsen, P.~Pettersson, J.~Romijn, and
  F.~Vaandrager, ``Minimum-cost reachability for priced timed automata,'' in
  \emph{Proc. 4th International Workshop on Hybrid Systems: Computation and
  Control (HSCC'01)}, ser. LNCS, vol. 2034.\hskip 1em plus 0.5em minus
  0.4em\relax Springer, 2001, pp. 147--161.

\bibitem{ATP01}
R.~Alur, S.~La~Torre, and G.~J. Pappas, ``Optimal paths in weighted timed
  automata,'' in \emph{Proc. 4th Int. Work. Hybrid Systems: Computation and
  Control (HSCC'01)}, ser. LNCS, vol. 2034.\hskip 1em plus 0.5em minus
  0.4em\relax Springer, 2001, pp. 49--62.

\bibitem{BBL-fmsd06}
P.~Bouyer, E.~Brinksma, and K.~G. Larsen, ``Optimal infinite scheduling for
  multi-priced timed automata,'' \emph{Formal Methods in System Design},
  vol.~32, no.~1, pp. 2--23, Feb. 2008.

\bibitem{zwick-95}
U.~Zwick and M.~Paterson, ``The complexity of mean payoff games on graphs,''
  \emph{Theoretical Computer Science}, vol. 158, no. 1--2, pp. 343--359, 1996.

\bibitem{BLMR-fsttcs2006}
P.~Bouyer, K.~G. Larsen, N.~Markey, and J.~I. Rasmussen, ``Almost optimal
  strategies in one-clock priced timed automata,'' in \emph{{P}roceedings of
  the 26th {C}onference on {F}oundations of {S}oftware {T}echnology and
  {T}heoretical {C}omputer {S}cience ({FSTTCS}'06)}, ser. LNCS, N.~Garg and
  S.~Arun-Kumar, Eds., vol. 4337.\hskip 1em plus 0.5em minus 0.4em\relax
  Kolkata, India: Springer, Dec. 2006, pp. 345--356.

\bibitem{bflms-formats08}
P.~Bouyer, U.~Fahrenberg, K.~G. Larsen, N.~Markey, and J.~Srba, ``Infinite runs
  in weighted timed automata with energy constraints,'' in \emph{{P}roceedings
  of the 6th {I}nternational {C}onference on {F}ormal {M}odelling and
  {A}nalysis of {T}imed {S}ystems ({FORMATS}'08)}, ser. LNCS, F.~Cassez and
  C.~Jard, Eds., vol. 5215.\hskip 1em plus 0.5em minus 0.4em\relax Saint-Malo,
  France: Springer, Sept. 2008, pp. 33--47.

\bibitem{bbjlr-formats08}
P.~Bouyer, {\relax Th}.~Brihaye, M.~Jurdzi{\'n}ski, R.~Lazi{\'c}, and
  M.~Rutkowski, ``Average-price and reachability-price games on hybrid automata
  with strong resets,'' in \emph{{P}roceedings of the 6th {I}nternational
  {C}onference on {F}ormal {M}odelling and {A}nalysis of {T}imed {S}ystems
  ({FORMATS}'08)}, ser. LNCS, F.~Cassez and C.~Jard, Eds., vol. 5215.\hskip 1em
  plus 0.5em minus 0.4em\relax Saint-Malo, France: Springer, Sept. 2008, pp.
  63--77.

\bibitem{BFLM-hscc10}
P.~Bouyer, U.~Fahrenberg, K.~G. Larsen, and N.~Markey, ``Timed automata with
  observers under energy constraints,'' in \emph{{P}roceedings of the 13th
  {I}nternational {C}onference on {H}ybrid {S}ystems: {C}omputation and
  {C}ontrol ({HSCC}'10)}, K.~H. Johansson and W.~Yi, Eds.\hskip 1em plus 0.5em
  minus 0.4em\relax Stockholm, Sweden: ACM Press, Apr. 2010, to appear.

\end{thebibliography}


\end{document}
