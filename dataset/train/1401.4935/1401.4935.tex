\documentclass[journal]{IEEEtran}



\usepackage{amsmath} \usepackage{amssymb}  \usepackage{bm}  \usepackage{dsfont}
\usepackage{graphicx,color} \usepackage{epsfig} \usepackage{color}
\usepackage[tight,footnotesize]{subfigure}
\usepackage{cite}
\usepackage{url}
\usepackage{array}
\usepackage[svgnames,table]{xcolor}
\usepackage{dpfloat, booktabs}
\usepackage{pdflscape}
\usepackage{rotating}
\usepackage{longtable}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage[colorlinks,linkcolor=Black,citecolor=Black,urlcolor=Black,breaklinks=true]{hyperref}
\newenvironment{rcases}
  {\left.\begin{aligned}}
  {\end{aligned}\right\rbrace}

\def\I{{\mathds{I}}}
\def\Ick{{\mathds{I}^{^C}_k}}

\DeclareMathOperator*{\E}{{\mathbf E}}        \let\Pr\undefined \DeclareMathOperator{\Pr}{{\mathbf P}}        \DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator{\diag}{diag}            \DeclareMathOperator{\dist}{dist}
\DeclareMathOperator{\round}{round}
\DeclareMathOperator{\tr}{tr}

\newcommand{\vect}[1]{\bm{#1}} \newcommand{\D}{\displaystyle}
\newcommand{\T}{\textstyle}
\newcommand{\Sst}{\scriptstyle}
\newcommand{\sscr}{\scriptscriptstyle}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{conjecture}[theorem]{Conjecture}

\newtheorem{definition}{Definition}[section]
\newtheorem{property}{Property}[section]
\newtheorem{assumption}{Assumption}[section]
\newtheorem{example}{Example}[section]

\newtheorem{remark}{Remark}[section]

\newenvironment{proof}[1][Proof]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}


%
 \usepackage{epstopdf}
\graphicspath{{figuresTR/}}
\hyphenation{net-works }

\begin{document}

\title{Performance Analysis of \\
a Network of Event-based Systems}
\author{Chithrupa~Ramesh,~\IEEEmembership{Student~Member,~IEEE,}
        Henrik~Sandberg,~\IEEEmembership{Member,~IEEE,}
        and~Karl~H.~Johansson,~\IEEEmembership{Fellow,~IEEE}\thanks{This work was supported by the Swedish Research Council,
        VINNOVA (The Swedish Governmental Agency for Innovation
        Systems), the Swedish Foundation for Strategic Research,
        the Knut and Alice Wallenberg Foundation and the EU
        project Hycon.}\thanks{C. Ramesh, H. Sandberg and Karl H. Johansson are with the ACCESS Linnaeus Centre,
Electrical Engineering, KTH Royal Institute of Technology, Stockholm,
Sweden. e-mail: \{cramesh,hsan,kallej\}@kth.se.}}
\maketitle


\begin{abstract}

We consider a scenario where multiple event-based systems use a wireless network to communicate with their respective controllers. These systems use a contention resolution mechanism (CRM) to arbitrate access to the network. We present a Markov model for the network interactions between the event-based systems. Using this model, we obtain an analytical expression for the reliability, or the probability of successfully transmitting a packet, in this network. There are two important aspects to our model. Firstly, our model captures the joint interactions of the event-triggering policy and the CRM. This is required because event-triggering policies typically adapt to the CRM outcome. Secondly, the model is obtained by decoupling interactions between the different systems in the network, drawing inspiration from Bianchi's analysis of IEEE~. This is required because the network interactions introduce a correlation between the system variables. We present Monte-Carlo simulations that validate our model under various network configurations, and verify our performance analysis as well.

\end{abstract}

\section{Introduction} \label{S:Intro}

\subsection{Motivation}

Digital control systems often use the time-triggered paradigm, where a measurement is periodically sent to the controller to generate a control signal. Event-based systems provide an alternative, wherein only measurements that qualify as `events' are sent to the controller. These systems could result in fewer transmissions \cite{Astrom1999,Otanez2002}, which is an important consideration when multiple closed-loop systems use a shared network to communicate with their respective controllers. Many wireless networked control systems operate in this manner, as shown in Fig.~\ref{Fig:macNCS}, where wireless links connect sensors with controllers while the controller-actuator links are wired. The shared network may be able to support more number of event-based systems than time-triggered ones, with comparable system performances. To achieve this target, one must understand the interaction of multiple event-based systems in a shared network. Only then will it be possible to predict their performance, and design event-triggering policies that are matched to the available network resources. 
\begin{figure*}[tb]
        \centering


\begingroup
  \makeatletter
  \providecommand\color[2][]{\errmessage{(Inkscape) Color is used for the text in Inkscape, but the package 'color.sty' is not loaded}
    \renewcommand\color[2][]{}}
  \providecommand\transparent[1]{\errmessage{(Inkscape) Transparency is used (non-zero) for the text in Inkscape, but the package 'transparent.sty' is not loaded}
    \renewcommand\transparent[1]{}}
  \providecommand\rotatebox[2]{#2}
  \ifx\svgwidth\undefined
    \setlength{\unitlength}{351.14819336pt}
  \else
    \setlength{\unitlength}{\svgwidth}
  \fi
  \global\let\svgwidth\undefined
  \makeatother
  \begin{picture}(1,0.50533886)\put(0,0){\includegraphics[width=\unitlength]{macNCSnew.eps}}\put(0.2475,0.28){\color[rgb]{0,0,0}\makebox(0,0)[lt]{\resizebox{1cm}{!}{}}}\put(0.73542196,0.37704413){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{ Plant}}}\put(0.73542196,0.32860914){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{ Controller}}}\put(0.6375,0.165){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\parbox[b][4em][c]{0.33\textwidth}{\centering{Network Feedback}}}}\put(0.6225,0.065){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\parbox[b][4em][c]{0.33\textwidth}{\centering{Sensor/Actuator \\ Link}}}}\put(0.73,0.28){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{Network}}}\put(0.1175,0.44){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.40835214,0.44){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.0375,0.325){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.494,0.3275){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.65118088,0.37600374){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.65118088,0.32756875){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.65,0.28){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.4875,0.1575){\color[rgb]{0,0,0}\makebox(0,0)[lb]{}}\put(0.0325,0.147){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.41,0.0375){\color[rgb]{0,0,0}\makebox(0,0)[lb]{}}\put(0.1175,0.03367134){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\end{picture}\endgroup
 \caption[NCSs with a shared sensing link]{A network of  closed-loop systems, with each loop consisting of a plant  and a controller  for . The systems share access to a common medium on the sensor link, and adapt their traffic rates to the feedback from the network. The controllers and actuators communicate over dedicated links.} \label{Fig:macNCS}
\end{figure*}
\begin{figure*}[tb]
        \centering
        

\begingroup
  \makeatletter
  \providecommand\color[2][]{\errmessage{(Inkscape) Color is used for the text in Inkscape, but the package 'color.sty' is not loaded}
    \renewcommand\color[2][]{}}
  \providecommand\transparent[1]{\errmessage{(Inkscape) Transparency is used (non-zero) for the text in Inkscape, but the package 'transparent.sty' is not loaded}
    \renewcommand\transparent[1]{}}
  \providecommand\rotatebox[2]{#2}
  \ifx\svgwidth\undefined
    \setlength{\unitlength}{384.82546387pt}
  \else
    \setlength{\unitlength}{\svgwidth}
  \fi
  \global\let\svgwidth\undefined
  \makeatother
  \begin{picture}(1,0.57648541)\put(0,0.075){\includegraphics[width=\unitlength]{NWcomparison2.eps}}\put(0.125,0.45){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{A Non-Adaptive}}}\put(0.115,0.4){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{Application (User)}}}\put(0.1275,0.23){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{Network Stack}}}\put(0.075,0.18){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{Multiple Access (CRM)}}}\put(0.105,0.535){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{A Typical Network}}}\put(0.685,0.45){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{An Adaptive}}}\put(0.645,0.4){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{Event-based System}}}\put(0.635,0.535){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{An Adaptive Network}}}\put(0.67,0.23){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{Network Stack}}}\put(0.615,0.18){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{Multiple Access (CRM)}}}\put(0.08,0.0){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{: Source Traffic Rate}}}\put(0.45,0.0){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{: Collision Probability}}}\put(0.8,0.0){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{: Throughput}}}\put(0.17,0.32){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.6,0.32){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.83,0.32){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.11,0.065){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.66,0.065){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.022,0.0){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.4,0.0){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.78,0.0){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\end{picture}\endgroup
 \caption[Need for Joint Analysis in Event-based Networks]{A typical network can be analyzed by evaluating the traffic rate of the user, and the collision probability of the multiple access protocol, in isolation. In an event-based network, the input traffic is adapted to the traffic in the network, i.e.,  is a function of . The event-triggering policy and multiple access protocol must be jointly analyzed in such a network. }\label{fig:NWcomparison}
\end{figure*}

The design of an event-based network must be accompanied by the selection of a suitable multiple access protocol, which determines the order of accessing the shared network. In a time-triggered network, transmission requests can be anticipated a priori, and a schedule can be drawn up to accommodate all the transmissions. In contrast, transmission requests cannot be anticipated in an event-based network. Thus, the access decisions must be taken at each sensor node, in a distributed manner. Furthermore, coordinating access decisions between nodes is not easy to accomplish on wireless networks. Thus, we choose to use a random access protocol; these protocols use a Contention Resolution Mechanism (CRM) to arbitrate access in a distributed, non-coordinated manner, between the nodes in the network. A protocol from the Carrier Sense Multiple Access (CSMA) family \cite{Rom1990}, called CSMA/CA (Collision Avoidance), is particularly well-suited to wireless networks and is used in Wifi \cite{ieee80211}, Zigbee \cite{zigbee} and WirelessHart \cite{WirelessHART2007}. In this paper, we use the -persistent CSMA protocol, which provides an analytical approximation for the CRM in CSMA/CA \cite{Kleinrock1975}.

\subsection{Contribution}

An unavoidable consequence of distributed access decisions is packet collisions, which result when two or more nodes transmit at the same time. All the packets involved in a collision are lost, which can be detrimental to the performance of the closed-loop systems in the network. To minimize the impact of these collisions, one could adapt the event-triggering policy to the CRM response. However, such systems are inherently harder to analyze, as illustrated in Fig~\ref{fig:NWcomparison}. A typical network user generates traffic at a certain rate, and the network returns a probability of collision, which is a function of all the users' traffic rates. Thus, the user's rate and the performance of the multiple access protocol can be analyzed in isolation, in this case. In adaptive event-based networks, however, the traffic rate of each user is a function of the probability of collision of the network. Hence, a joint analysis of the event-triggering policy and the CRM is required.

Another consequence of random access is that network access for a node implies lack of access for all the other nodes in the network. Thus, the network access decisions are correlated, and for closed-loop systems, this correlation propagates to the system state. Closed-loop systems with exogenous noise processes become correlated due to their network interactions \cite{Cervin2008,Rabi2009}. Now, analyzing the resulting network is not a trivial task. To solve this problem, we derive inspiration from Bianchi's much-acclaimed analysis of the Distributed Coordination Function \cite{Bianchi2000} in IEEE~. To counter a similar problem of network-induced correlation between traffic sources, Bianchi assumes that a node that is ready to transmit, sees a busy channel as a time-averaged, independent process. The independence aspect of this assumption restores a renewal property in our setup, enabling the use of a Markov model to represent the interactions in an event-based network. The time-average assumption permits a performance analysis in steady state. We verify these assumptions through simulations.

There are two main contributions of this paper. We present a joint analysis of the event-triggering policy and the CRM. The analysis is made possible by the use of Bianchi's assumption. In doing so, we also present a new configuration for the applicability of Bianchi's assumption. Our final contribution is the resulting network model; a Markov chain which describes the event-triggering policy and the multiple access protocol. With this model, we can view the event-triggering policy as a set of steady state probabilities. This model facilitates the design of a set of probabilities that ensure a system-level guarantee. In other words, the model and analysis presented in this paper can be used to design a network of event-based systems.

\subsection{Related Work}
Event-based systems were proposed as a means to reduce congestion in Networked Control Systems (NCS) \cite{Astrom1999,Yook2002,Otanez2002}. Early work showed that the same control performance can be achieved using fewer samples with event-based systems, for a single system \cite{Tomovic1966,Astrom1999}. Various event-triggering policies have been proposed for different problem formulations \cite{Rabi2006,Tabuada2007,Heemels2008,Henningsson2008}. However, the multiple access problem for event-based systems has not received as much attention. Much of the work focussing on the design of event-based systems for a shared network \cite{Wang2011,Molin2012} does not explicitly deal with the problem of multiple access. Others use protocols such as the CAN bus for wired networks \cite{Anta2009a}, or dynamic real-time scheduling for multiple tasks on a single processor \cite{Tabuada2007}. These protocols are not well-suited to wireless networks \cite{Akyildiz1999,Gummalla2000}.

There have been some attempts to analyze a network of event-based systems with random access. This includes a partial analysis of event-triggered nodes with CSMA/CA \cite{Cervin2008}, which highlighted the difficulties in analyzing such a network due to network-induced correlations. A more complete analysis with Aloha was presented in \cite{Rabi2009}, which assumed independent packet losses. A simple steady state model was presented in \cite{Henningsson2010}, but with an idealized multiple access protocol that results in no collisions. More recently, event-based systems which use Aloha and Slotted Aloha have been analyzed \cite{Blind2011a}, but with an event-triggering policy that is not adapted to the network. The work presented in this paper highlights the need for a joint analysis between the multiple access protocol and the event-triggering policy. An initial version of this work was presented in \cite{Ramesh2011b}.

\begin{figure*}[tb]
    \centering
    

\begingroup
  \makeatletter
  \providecommand\color[2][]{\errmessage{(Inkscape) Color is used for the text in Inkscape, but the package 'color.sty' is not loaded}
    \renewcommand\color[2][]{}}
  \providecommand\transparent[1]{\errmessage{(Inkscape) Transparency is used (non-zero) for the text in Inkscape, but the package 'transparent.sty' is not loaded}
    \renewcommand\transparent[1]{}}
  \providecommand\rotatebox[2]{#2}
  \ifx\svgwidth\undefined
    \setlength{\unitlength}{479.39765625pt}
  \else
    \setlength{\unitlength}{\svgwidth}
  \fi
  \global\let\svgwidth\undefined
  \makeatother
  \begin{picture}(1,0.40047623)\put(0,0){\includegraphics[width=\unitlength]{SystemModel2.eps}}\put(0.08,0.36){\color[rgb]{0,0,0}\makebox(0,0)[lt]{\resizebox{1.5cm}{!}{}}}\put(0.34,0.385){\color[rgb]{0,0,0}\makebox(0,0)[lt]{\resizebox{1.5cm}{!}{}}}\put(0.08,0.1){\color[rgb]{0,0,0}\makebox(0,0)[lt]{\resizebox{1.5cm}{!}{}}}\put(0.565,0.275){\color[rgb]{0,0,0}\makebox(0,0)[lt]{}}\put(0.29,0.25){\color[rgb]{0,0,0}\rotatebox{90}{\makebox(0,0)[lb]{\smash{ACK}}}}\put(0.385,0.18){\color[rgb]{0,0,0}\makebox(0,0)[lt]{\resizebox{1cm}{!}{}}}\put(0.56,0.11){\color[rgb]{0,0,0}\makebox(0,0)[lt]{}}\put(0.757,0.297){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{ Plant}}}\put(0.757,0.262){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{ Controller}}}\put(0.757,0.16){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{Network}}}\put(0.696,0.297){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.696,0.262){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.696,0.16){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.696,0.226){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.757,0.226){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{ State-based}}}\put(0.8,0.195){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{Scheduler}}}\put(0.685,0.125){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{CRM}}}\put(0.757,0.125){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{Contention Resolution}}}\put(0.8,0.095){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{Mechanism}}}\put(0.00225,0.34){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\resizebox{8mm}{!}{}}}\put(0.19,0.34){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\resizebox{8mm}{!}{}}}\put(0.19,0.08){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\resizebox{8mm}{!}{}}}\put(0.275,0.16){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\resizebox{8mm}{!}{}}}\put(0.335,0.22){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\resizebox{8mm}{!}{}}}\put(0.49,0.215){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\resizebox{8mm}{!}{}}}\put(0.49,0.071){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\resizebox{9mm}{!}{}}}\put(0.42,0.319){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\end{picture}\endgroup
 \caption{A network of  event-based systems using a CRM to access the network, where the  control loop is illustrated with its dependency on the other control loops , . The events are generated by the state-based schedulers. The other control loops are represented with their state-based schedulers alone.} \label{Fig:SystemModel}
\end{figure*}

\subsection{Outline}
The rest of the paper is organized as follows. We present the problem formulation in Section~\ref{S:Problem} and derive some important properties of the event-triggering policy, with no network traffic, in Section~\ref{S:ETprop}. We present the consequences of multiple access, and our solution using Bianchi's assumption in Section~\ref{S:MA_ET}. The Markov model describing the joint interactions, and the corresponding performance analysis are presented in this section. Finally, we present some simulation results in Section~\ref{S:Sims} and validate the assumptions of our model.

\section{Problem Formulation} \label{S:Problem}

We consider a network of  plants and controllers (indexed by ), which communicate over a shared channel with an event-trigger in the loop, as shown in Fig.~\ref{Fig:SystemModel}. A model for the interactions between each event-based system and the network is depicted in Fig.~\ref{Fig:DualPred}. The blocks in this figure are explained below.

\noindent \textbf{Plant: } The plant  has state dynamics given by

where ,  and the initial state  and the process noise  are i.i.d. zero-mean Gaussians with covariance matrices  and , respectively. They are independent and uncorrelated to each other and to the initial states and process noises of other plants in the network. This discrete time model is defined with respect to a sampling period  for each plant, and the sampling instants are generated by a synchronized network clock.

\begin{figure*}[tb]
    \centering
    \def\svgwidth{\textwidth}
    

\begingroup
  \makeatletter
  \providecommand\color[2][]{\errmessage{(Inkscape) Color is used for the text in Inkscape, but the package 'color.sty' is not loaded}
    \renewcommand\color[2][]{}}
  \providecommand\transparent[1]{\errmessage{(Inkscape) Transparency is used (non-zero) for the text in Inkscape, but the package 'transparent.sty' is not loaded}
    \renewcommand\transparent[1]{}}
  \providecommand\rotatebox[2]{#2}
  \ifx\svgwidth\undefined
    \setlength{\unitlength}{430.07734375pt}
  \else
    \setlength{\unitlength}{\svgwidth}
  \fi
  \global\let\svgwidth\undefined
  \makeatother
  \begin{picture}(1,0.4257795)\put(0,0){\includegraphics[width=\unitlength]{StateBasedDualPred2.eps}}\put(0.15,0.385){\color[rgb]{0,0,0}\makebox(0,0)[lt]{\resizebox{1.5cm}{!}{}}}\put(0.245,0.1){\color[rgb]{0,0,0}\makebox(0,0)[lt]{\resizebox{1.5cm}{!}{}}}\put(0.59,0.2){\color[rgb]{0,0,0}\makebox(0,0)[lt]{\resizebox{1cm}{!}{}}}\put(0.855,0.315){\color[rgb]{0,0,0}\makebox(0,0)[lt]{\resizebox{1.5cm}{!}{}}}\put(0.855,0.095){\color[rgb]{0,0,0}\makebox(0,0)[lt]{\resizebox{1.5cm}{!}{}}}\put(0.54,0.191){\color[rgb]{0.29411765,0.29411765,0.29411765}\rotatebox{90}{\makebox(0,0)[lb]{\smash{ACK}}}}\put(0.055,0.105){\color[rgb]{0,0,0}\makebox(0,0)[lt]{\resizebox{1.5cm}{!}{}}}\put(0.76,0.07){\color[rgb]{0.29411765,0.29411765,0.29411765}\makebox(0,0)[lb]{\smash{ACK}}}\put(0.4825,0.305){\color[rgb]{0,0,0}\makebox(0,0)[lt]{}}\put(0.685,0.305){\color[rgb]{0,0,0}\makebox(0,0)[lt]{}}\put(0.05,0.36){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\resizebox{8mm}{!}{}}}\put(0.28,0.36){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\resizebox{8mm}{!}{}}}\put(0.16,0.075){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\resizebox{8mm}{!}{}}}\put(0.36,0.08){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\resizebox{8mm}{!}{}}}\put(0.46,0.18){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\resizebox{8mm}{!}{}}}\put(0.565,0.31){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.575,0.25){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\resizebox{8mm}{!}{}}}\put(0.765,0.305){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.745,0.20){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\resizebox{8mm}{!}{}}}\put(0.745,0.12){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\resizebox{1cm}{!}{}}}\put(0.945,0.095){\color[rgb]{0,0,0}\makebox(0,0)[lb]{}}\put(0.945,0.24){\color[rgb]{0,0,0}\makebox(0,0)[lb]{}}\end{picture}\endgroup
 \caption{A model of the network in Fig.~\ref{Fig:SystemModel}, from the perspective of a single event-based system. The event-triggering policy uses the prediction error to determine when to transmit. An explicit ACK is needed to track the estimation error at the sensor node. } \label{Fig:DualPred}
\end{figure*}

\noindent \textbf{State-based Scheduler: } There is a local scheduler , situated in the sensor node, between the plant and the controller, which decides if the state  is to be ignored or selected for transmission. The scheduler output  is correspondingly chosen from the set , by the event-triggering policy , implemented within this block. The policy used in our setup is presented below, but motivated in Section~\ref{S:ETprop}. The scheduler output is given by

where,  is the threshold, which typically depends on the memory index of the event-triggering policy . This index tracks the delay since the last received packet, , for delays smaller than the maximum memory index , i.e., . In the above equation,  plays the role of a memory-limited predicted estimate at the sensor node (\ref{Eq:PredEst}).

\noindent \textbf{Other Network Traffic}: The block  models a fictionalized source, representing traffic from all other event-based systems in the network. This traffic is represented by the network traffic index .

\begin{figure}[tb]
    \centering
    \def\svgwidth{9cm}
    

\begingroup
  \makeatletter
  \providecommand\color[2][]{\errmessage{(Inkscape) Color is used for the text in Inkscape, but the package 'color.sty' is not loaded}
    \renewcommand\color[2][]{}}
  \providecommand\transparent[1]{\errmessage{(Inkscape) Transparency is used (non-zero) for the text in Inkscape, but the package 'transparent.sty' is not loaded}
    \renewcommand\transparent[1]{}}
  \providecommand\rotatebox[2]{#2}
  \ifx\svgwidth\undefined
    \setlength{\unitlength}{417.2453125pt}
  \else
    \setlength{\unitlength}{\svgwidth}
  \fi
  \global\let\svgwidth\undefined
  \makeatother
  \begin{picture}(1,0.27763124)\put(0,0.065){\includegraphics[width=\unitlength]{TimeScales.eps}}\put(0.325,0.25){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{Sampling Period}}}\put(0.02,0.25){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{Slot Duration}}}\put(-0.1,-0.07){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\parbox[b][4em][c]{0.33\textwidth}{\centering{Packet \\ Generated}}}}\put(0.205,-0.07){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\parbox[b][4em][c]{0.33\textwidth}{\centering{Packet \\ Expires}}}}\put(0.405,-0.07){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\parbox[b][4em][c]{0.33\textwidth}{\centering{Packet \\ Generated}}}}\put(0.20,0.16){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.29,0.16){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.35,0.16){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.49,0.16){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\end{picture}\endgroup
     \caption{The sampling period, corresponding to the system time scale, consists of many small slots, corresponding to the CRM time scale. For each packet generated by the event-based system, the CRM attempts  retransmissions before it declares a packet loss due to congestion. This feature increases the reliability of the multiple access protocol.} \label{Fig:TimeScales}
\end{figure}

\noindent \textbf{CRM}: The multiple access protocol implements a CRM in each sensor node, which resolves contention between simultaneous channel access requests in a distributed manner. We consider the -persistent CSMA mechanism, with  retransmissions. The retransmissions occur in the CRM time scale, which is much finer in resolution than the system time scale, as indicated in Fig.~\ref{Fig:TimeScales}. The time scales are assumed to be separated, i.e., all retransmissions corresponding to a single event are completed before the next sampling period. The access indicator for each retransmission  is denoted  at time . The persistence probability in the  retransmission attempt is defined as , and denoted by  for brevity.

\noindent \textbf{Channel Access Indicator}: The channel access indicator  denotes transmission failure or success, respectively, after  retransmission attempts. A transmission is successful if there is only one system that attempts to access the channel in that CRM slot, as  given by

and then, . Thus, the number of retransmissions, , also determines the maximum number of transmissions supported by the network protocol, for every system sampling instant.

\noindent \textbf{Observer:} The observer  receives , given by

where  denotes a packet erasure when there is no event. The estimate is computed as

with . We define the corresponding estimation error as . A copy of this observer is used at the sensor node to facilitate the event-triggering policy by generating the predicted estimate . This is used to generate the memory-limited predicted estimate  in (\ref{Eq:InnoSched}), which is given by

Thus,  is given by the predicted estimate  when the delay is less than the memory  of the scheduler. When the delay exceeds this value,  takes the value , which is generated by assuming knowledge of , in place of .

\noindent \textbf{Controller:} The controller  generates an appropriate control signal, such as

where  is selected to minimize an appropriate cost function, such as the linear quadratic Gaussian cost.

We are interested in analyzing the joint performance of the event-trigger and CRM in this network, in steady state. To do so, we define two metrics that characterize the network performance.
\begin{definition}[Steady-state Delay Distribution]
The delay since the last received packet is given by , where  is the time index of the last received packet, as illustrated in Fig.~\ref{Fig:TimeLines}. To avoid notational overhead, we skip the index  for  and , when the context is clear. The time index of the last received packet is defined as , for  and . Note that . Then, the steady-state delay distribution is defined as , for .
\end{definition}
\begin{figure}[tb]
    \centering
    \def\svgwidth{9cm}
    

\begingroup
  \makeatletter
  \providecommand\color[2][]{\errmessage{(Inkscape) Color is used for the text in Inkscape, but the package 'color.sty' is not loaded}
    \renewcommand\color[2][]{}}
  \providecommand\transparent[1]{\errmessage{(Inkscape) Transparency is used (non-zero) for the text in Inkscape, but the package 'transparent.sty' is not loaded}
    \renewcommand\transparent[1]{}}
  \providecommand\rotatebox[2]{#2}
  \ifx\svgwidth\undefined
    \setlength{\unitlength}{362.12607422pt}
  \else
    \setlength{\unitlength}{\svgwidth}
  \fi
  \global\let\svgwidth\undefined
  \makeatother
  \begin{picture}(1,0.46044994)\put(0,0){\includegraphics[width=\unitlength]{TimeLines2.eps}}\put(0,0.43){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{Samples at}}}\put(0,0.37){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{Plant/Sensor}}}\put(0,0.27){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{Samples at}}}\put(0,0.21){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{Scheduler: }}}\put(0,0.11){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{Samples at}}}\put(0,0.05){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{Controller: }}}\put(0.393,0.41){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.355,0.345){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.435,0.345){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.975,0.345){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.515,0.345){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.645,0.345){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.725,0.345){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.805,0.345){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.885,0.345){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.355,0.185){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.435,0.185){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.975,0.185){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.515,0.185){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.645,0.185){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.725,0.185){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.805,0.185){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.885,0.185){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.355,0.03){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.435,0.03){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.975,0.03){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.515,0.03){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.64,0.03){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.725,0.03){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.805,0.03){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.885,0.03){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.585,0.105){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.818,0.095){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\end{picture}\endgroup
 \caption{An illustration of the delay since the last received packet  and the index of the last received packet . The topmost sample trace indicates the discrete sampling instants, the middle one indicates the events selected at the state-based scheduler, and the bottom one indicates the events that successfully reach the controller. } \label{Fig:TimeLines}
\end{figure}

\begin{definition}[Steady-state Reliability]
Recall that  is the channel access indicator. The steady state probability of a successful transmission as a consequence of the joint actions of the event-trigger and CRM is defined as . This indicates the network reliability on the sensing link for a given closed-loop system.
\end{definition}

The above information is a prerequisite for any design methodology that seeks to achieve a certain network or system guarantee.

\subsection{Motivating Example}
Before we delve into the main results, we present an example of a network of systems, and examine a performance analysis curve for this example obtained using Monte-Carlo simulations. With this example, we wish to motivate the methods used in the rest of this paper.
\begin{example}[Network and Experiment Setup] \label{Ex:Setup}
We consider a homogenous network of  nodes, with  retransmissions in the CRM. The dynamics of the plants are given by \eqref{Eq:StateSpace} for  and . The plants are identical with state transition matrix  and control matrix . We use a state-based scheduler (\ref{Eq:InnoSched}) with the event-triggering policy , where  is a constant scheduler threshold and  denotes the memory-limited predicted estimate (\ref{Eq:PredEst}) at time . When the delay exceeds the memory of the policy , the value  is assumed to be the last successfully received value while computing , thus limiting the memory of the event-triggering policy. To realize a scheduler such as this, we implement the dual predictor architecture presented in Fig.~\ref{Fig:DualPred}. The CRM used to arbitrate access is the -persistent CSMA protocol, and  for all  retransmission stages of the CRM.

A plot of the simulated values of reliability  versus the scheduler threshold  is shown in Fig.~\ref{Fig:pDeltaVSepsilonTeaser}. This plot has been obtained using Monte-Carlo simulations. The non-linear relationship depicted in the plot is not surprising, considering that a given scheduler threshold translates to a certain traffic rate depending on the distribution of the estimation error. However, it is important to note that the distribution of the estimation error with delay evolves based on the probability of a successful transmission, as a consequence of the adaptation illustrated in Fig.~\ref{fig:NWcomparison}. Thus, it is apparent from Fig.~\ref{Fig:pDeltaVSepsilonTeaser} that there is no simple loss process that captures the interaction of a single system with the rest of the network.
\end{example}

We return to this example in Section~\ref{S:Sims}, where we comment on the non-monotonic relationship obtained from simulations.
\begin{figure}[tb]
\begin{center}
\includegraphics*[scale=0.2,viewport=75 75 1400 525]{pDeltaVSepsilon_Intro.eps}
\caption{A plot of the simulated values of the reliability versus the scheduler threshold. This plot clearly shows that the above relationship cannot be approximated by an i.i.d. loss process or any other such simplistic modelling technique. } \label{Fig:pDeltaVSepsilonTeaser}
\end{center}
\vspace{-5mm}
\end{figure}

\section{The Event-triggering Policy} \label{S:ETprop}

We examine our event-triggering policy, to understand what it does for a single closed-loop system without other network traffic. We show that this policy adapts to the estimation error, or a part of it, when its memory is constrained. The renewal property of the estimation error is used to construct a Markov model that represents the functioning of the event-triggering policy. Since we only consider a single closed-loop system in this section, we drop the index . The lack of other network traffic implies that  for all . Now, there is no need for a multiple access protocol and every event results in a successful transmission, i.e., .

\subsection{Properties of the Event-triggering Policy}
We begin by motivating our selection of the event-triggering policy in (\ref{Eq:InnoSched}). The events generated by our policy are not influenced by the past applied controls, resulting in a structural separation between the state-based scheduler, observer and controller, as shown in \cite{Ramesh2013}. Thus, the role of the controller is limited to regulating the estimate (\ref{Eq:EstO}), and the role of the state-based scheduler is limited to reducing the estimation error. Accordingly, the policy defined in (\ref{Eq:InnoSched}) adapts to the estimation error across the network; the input to this policy is the estimation error, for delays not exceeding , or a related quantity, when the delay is  or larger. This can be seen from

Note that the estimation error for  is given by . However, the value used in its place in the event-triggering policy is obtained by assuming that  was successfully transmitted, i.e., . Thus, the statistical properties of the inputs to the above event-triggering policy vary with delay for , but remain constant for . Hence, we limit the memory of our adaptive policy to .

Following a successful transmission, the estimation error is reset to zero at the observer, and this leads to some desirable properties for our policy, discussed below. For a sequence , the notation  is used to denote the set .
\begin{lemma} \label{Lemma:Markovian_EstErr}
For a single system given by (\ref{Eq:StateSpace})--(\ref{Eq:InnoSched}), (\ref{Eq:EstO})--(\ref{Eq:Controller}), with ,  is a Markovian representation for the estimation error at the observer, . In other words,

\end{lemma}
\begin{IEEEproof}
At any time ,  represents the time index corresponding to the last received packet. Then, , as the state  is received by the observer. At time , the estimation error corresponds to the process noise . The process noise is i.i.d., and hence, independent of the state at  or prior to it. This is also true for any future estimation error. Thus, we have

The delay since the last transmission, along with the measurement values since the last transmission form a sufficient statistic for the estimation error. Using this, and the relationship  when , we obtain (\ref{Eq:Markovian_EstErr}).
\end{IEEEproof}

\begin{corollary} \label{Corollary:ETrenewal}
For a single system given by (\ref{Eq:StateSpace})--(\ref{Eq:InnoSched}), (\ref{Eq:EstO})--(\ref{Eq:Controller}), with , the inter-arrival times at the controller are independent.
\end{corollary}
\begin{IEEEproof}
The inter-arrival times are given by , where  denotes the packet reception instants. Following the successful reception of a packet at time , the future estimation error is independent of . For the event-triggering policy in (\ref{Eq:InnoSched}), the estimation error , for , determines . Thus,  is independent of .
\end{IEEEproof}
From Corollary~\ref{Corollary:ETrenewal}, we can thus conclude that the event-triggering policy in (\ref{Eq:InnoSched}) results in a traffic source that is a renewal process.

\subsection{Markov Chain Representation} \label{S:MCnotraffic}

\begin{figure*}[tb]
    \centering
    

\begingroup
  \makeatletter
  \providecommand\color[2][]{\errmessage{(Inkscape) Color is used for the text in Inkscape, but the package 'color.sty' is not loaded}
    \renewcommand\color[2][]{}}
  \providecommand\transparent[1]{\errmessage{(Inkscape) Transparency is used (non-zero) for the text in Inkscape, but the package 'transparent.sty' is not loaded}
    \renewcommand\transparent[1]{}}
  \providecommand\rotatebox[2]{#2}
  \ifx\svgwidth\undefined
    \setlength{\unitlength}{427.24853516pt}
  \else
    \setlength{\unitlength}{\svgwidth}
  \fi
  \global\let\svgwidth\undefined
  \makeatother
  \begin{picture}(1,0.15836622)\put(0,0){\includegraphics[width=\unitlength]{MC_etDualPred.eps}}\put(0.115,0.10){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.315,0.10){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.52,0.10){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.87,0.10){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.20,0.12){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.4,0.12){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.59,0.12){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.76,0.12){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(-0.045,0.1){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.21,0.0775){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.386,0.06){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.7175,0.045){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(1.0025,0.10){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\end{picture}\endgroup
 \caption{A Markov chain model representing the event-triggering policy in (\ref{Eq:InnoSched}), when there is no exogenous network traffic. The estimation error grows with delay, resulting in different probabilities for events and non-events until . } \label{Fig:MCet}
\end{figure*}

Using Lemma~\ref{Lemma:Markovian_EstErr}, we construct a Markov chain to represent the event-triggering policy, as shown in Fig.~\ref{Fig:MCet}. The state indices  represent the memory of the event-triggering policy in (\ref{Eq:InnoSched}). A return to the state  denotes a successful transmission, when the estimation error is reset to zero. From here on, the number of terms contributing to the input of the event-triggering policy continue to grow, as can be seen from the expression . For , we see two transitions out of every state; one to the next state  indicating a non-transmission, and the other to  indicating a successful transmission. The corresponding probabilities are denoted  and , respectively, and defined as

For , there are two transitions again, but a non-transmission returns to the same state, with probability . The probability  is defined as in (\ref{Eq:TransProb_pgm}), with .

\begin{remark}[Event Probabilities:]
The probabilities of events and non-events in (\ref{Eq:TransProb_pgm}) can be computed given the event thresholds in (\ref{Eq:InnoSched}), though this computation is not trivial as the estimation error does not have a Gaussian distribution. However, an event-triggered policy can be specified both in terms of event-thresholds or event-probabilities. For the rest of this paper, we assume that the event-triggering policy in (\ref{Eq:InnoSched}) is specified in terms of event probabilities, rather than event thresholds. The conversion from event probabilities to event thresholds becomes relevant when the event-triggering policy must be implemented, and we deal with that in Section~\ref{S:Sims}.
\end{remark}

\begin{remark}[Effect of independent Packet Losses:]
It is straightforward to extend the above model to include independent packet losses, which occur with probability . A simple change of variables, with  in place of  and  in place of  gives us our modified Markov chain. This is because the future estimation error and events remain independent of the past, after a transmission, and hence the statement of Lemma~\ref{Lemma:Markovian_EstErr} continues to hold when there are packet losses.
\end{remark}

\section{The Multiple Access Event-triggered Problem} \label{S:MA_ET}

We now look at what happens when there are many event-based systems in the same network, i.e., . In this case, the CRM plays an important role as . We first examine the consequences of introducing the CRM in the network. Then, we use introduce Bianchi's assumption, and use this to construct a Markov model to represent the dynamics of the event-triggering policy and CRM.

\subsection{Consequences of the CRM} \label{S:MAconsequences}
The CRM impacts the network in two ways. The first consequence is that the event-triggered policy must be jointly analyzed with the CRM, as has already been illustrated in Fig.~\ref{fig:NWcomparison}. The other consequence is the correlation introduced between the various systems due to network interactions. We state and prove this below. 
\begin{lemma} \label{Lemma:CorrelatedNW}
For the system described by (\ref{Eq:StateSpace})--(\ref{Eq:Controller}), the estimation errors corresponding to different plants in the network are correlated, i.e., 
\end{lemma}
\begin{IEEEproof}
A network that supports  retransmissions must satisfy the constraint . Due to this, and the definition of  in (\ref{Eq:Delta}), the probability of a successful transmission depends on the probabilities of all the events in the network at time . This can be expressed as

The estimate (\ref{Eq:EstO}) and the corresponding estimation error  are determined by . Hence, the estimation error is correlated to all the events at time . This is true for all the plants in the network, and thus, they become correlated to one another as indicated in (\ref{Eq:CorrelatedNW}).
\end{IEEEproof}

The above result reaffirms that the CRM introduces correlations between different event-based systems, as has been noted earlier in \cite{Cervin2008,Rabi2009}. The correlation between the estimation errors leads to correlation in the states, prediction errors and future scheduler outputs. An example of a scenario that might arise due to the above result is as follows; a large estimation error in a system that does not get to transmit, perhaps due to random access or collisions, might result in increased congestion for the entire network due to persistent events from this system. This in turn might cause the estimation error to grow in other systems, and lead to further congestion. Hence, the properties in Lemma~\ref{Lemma:Markovian_EstErr} and Corollary~\ref{Corollary:ETrenewal} do not hold for the systems in such a network, as formally proven below.

\begin{lemma} \label{Lemma:LostProp}
For the system described in (\ref{Eq:StateSpace})--(\ref{Eq:Controller}),  is not a Markovian process. Consequently, the inter-arrival times at the observer are not independent.
\end{lemma}
\begin{IEEEproof}
The Markovian properties of  in Lemma~\ref{Lemma:Markovian_EstErr} followed from the independence of the estimation error, following a transmission, from its past. This is no longer true when there are interactions through the CRM. To see this, let us examine the prediction and estimation error following a transmission instant, , for the  plant and for some . The prediction error is given by , and it is independent of the estimation error prior to  due to the independence of the process noise . Thus, we have


Consequently,  is independent of all the other scheduler outputs. However,  is still determined by all the scheduler outputs at time , as shown in (\ref{Eq:corrPrdelta}). Thus, the estimation error  is correlated with the estimation errors from all the other plants in the network, as shown in Lemma~\ref{Lemma:CorrelatedNW}, some of which may be correlated with the estimation error of plant  prior to . Thus, the network interaction reintroduces a correlation with its past, and the estimation error following a reception instant is not independent of its past. In other words,

Consequently,  is not Markovian. The lack of independence implies that arrival times are also correlated in this setup.
\end{IEEEproof}

A successful transmission for a node in a congested network need not reduce congestion for the other nodes in the network. The event-backlog may take a few sampling periods to dissipate. In the meanwhile, new events from the successful nodes will continue to see traffic conditions similar to those encountered by previous events from these nodes. Thus, the independence of the estimation error following a successful transmission is lost due to these network interactions. Analyzing the joint performance of the event-triggering policy and CRM is a challenging task due to the correlations in the network.

\subsection{Bianchi's Assumption} \label{S:BianchiAssumption}

We now use an assumption from Bianchi's seminal paper \cite{Bianchi2000} that simplifies the network interactions. While presenting this assumption and utilizing it to construct a model, we consider the simplest setup in the multiple access network, which corresponds to the case when the CRM permits no retransmissions, i.e., . Accordingly, we denote the CRM access indicator  simply as , with corresponding probability . These results can be extended to include multiple retransmissions, which we discuss in Section~\ref{S:Extn}.

\begin{assumption} \label{Assumption:Bianchi}
For the systems described in (\ref{Eq:StateSpace})--(\ref{Eq:Controller}), the conditional probability of a busy channel for a node that attempts to transmit in steady state, is given by an independent probability  for each node. Thus,

for all .
\end{assumption}

Simulations in Section~\ref{S:Sims} validate this assumption as a reasonable one to make for our problem setup. There are two aspects to this assumption; Firstly, (\ref{Eq:Bianchi}) removes the correlation of the channel access indicator  with the scheduler outputs of all the other plants in the network, which was shown in (\ref{Eq:corrPrdelta}). Secondly, notice that  is not indexed by ; it is a time-average, and results in a steady state analysis, as we show in the rest of the paper. Now, we use the independence aspect to extend the desirable properties of Lemma~\ref{Lemma:Markovian_EstErr} and Corollary~\ref{Corollary:ETrenewal}, to systems in the multiple access network.

\begin{theorem} \label{Theorem:Markovian_EstErr}
For the systems described in (\ref{Eq:StateSpace})--(\ref{Eq:Controller}), with Assumption~\ref{Assumption:Bianchi},  is a Markovian representation for the steady state estimation error at the observer, , for all . In other words,

Consequently, the inter-arrival times at the observer for each plant is independent.
\end{theorem}
\begin{IEEEproof}
In Corollary~\ref{Lemma:LostProp}, we showed that the estimation error following a packet reception instant , for some , is not independent of its past due to the correlation introduced by . Re-examining (\ref{Eq:corrPrdelta}), with Assumption~\ref{Assumption:Bianchi}, we now get

which implies that

Thus, the dependence on the other scheduler outputs vanishes due to Assumption~\ref{Assumption:Bianchi}. Now, the estimation error remains independent of its past, i.e.,

Thus, using the same arguments as in the proof of Lemma~\ref{Lemma:Markovian_EstErr}, we can establish the Markovian property of  in (\ref{Eq:Markovian_EstErrMultiple}). Consequently, the inter-arrival times are independent.
\end{IEEEproof}

Bianchi's assumption has converted the traffic source corresponding to the event-triggering policy and the CRM, into a renewal process. Now, analyzing the performance of this network is straightforward.

\subsection{Markov Chain Representation} \label{S:MCtraffic}

\begin{figure*}[tb]
\begin{center}


\begingroup
  \makeatletter
  \providecommand\color[2][]{\errmessage{(Inkscape) Color is used for the text in Inkscape, but the package 'color.sty' is not loaded}
    \renewcommand\color[2][]{}}
  \providecommand\transparent[1]{\errmessage{(Inkscape) Transparency is used (non-zero) for the text in Inkscape, but the package 'transparent.sty' is not loaded}
    \renewcommand\transparent[1]{}}
  \providecommand\rotatebox[2]{#2}
  \ifx\svgwidth\undefined
    \setlength{\unitlength}{449.92768555pt}
  \else
    \setlength{\unitlength}{\svgwidth}
  \fi
  \global\let\svgwidth\undefined
  \makeatother
  \begin{picture}(1,0.46140743)\put(0,0){\includegraphics[width=\unitlength]{MC_etDualPred_crm.eps}}\put(0.79,0.26){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{: Idle}}}\put(0.79,0.225){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{: Non-event}}}\put(0.79,0.19){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{: Event}}}\put(0.79,0.1575){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{: Transmission}}}\put(0.83,0.1225){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{through CRM}}}\put(0.225,0.425){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.225,0.3){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.225,0.07){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.03,0.3){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.4105,0.3){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.6031,0.3){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.03,0.07){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.4105,0.07){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.6031,0.07){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.125,0.365){\color[rgb]{0,0,0}\rotatebox{38.00}{\makebox(0,0)[lb]{\smash{}}}}\put(0.125,0.14){\color[rgb]{0,0,0}\rotatebox{38.00}{\makebox(0,0)[lb]{\smash{}}}}\put(0.14,0.045){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.33,0.3942){\color[rgb]{0,0,0}\rotatebox{-39.00}{\makebox(0,0)[lb]{\smash{}}}}\put(0.33,0.1709){\color[rgb]{0,0,0}\rotatebox{-39.00}{\makebox(0,0)[lb]{\smash{}}}}\put(0.315,0.045){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.325,0.32){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.51,0.32){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.145,0.315){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.7,0.32){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.4279,0.27){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.325,0.09){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.51,0.09){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.145,0.085){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.7,0.09){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.4279,0.0172){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\end{picture}\endgroup
 \caption{A Markov chain representation for the event-triggering policy in (\ref{Eq:InnoSched}) and a simple CRM with no retransmissions. The variable  denotes the memory limit of the transmission history used by the scheduler.} \label{Fig:MCetCRM}
\end{center}
\vspace{-5mm}
\end{figure*}

We use Bianchi's assumption to construct a Markov model of the event-triggering policy and CRM. The presentation in this section corresponds to a single system in the network, and thus, we skip the index .

In the Markov chain in Fig.~\ref{Fig:MCetCRM}, we assign two indices, , to each state and denote the probability of being in the state as . The index  represents the steady state memory of the scheduler and is given by . The states  and  are one sampling period away from each other. The index  represents the four states a packet can be in during a sampling period. These are
\begin{enumerate}
\item  [Idle State]: For , non-events and unsuccessful events return to this state before the next sampling instant. The initial state  indicates the idle state before the next sampling instant following a successful transmission.
\item  [Non-event State]: This state is reached when the scheduler output . A transition out of this state occurs instantaneously, and always to the idle state to wait for the next sampling instant.
\item  [Event State]: This state is reached when . A transition out of this state occurs to the transmission state or the idle state, depending on the CRM access indicator . When , the event is discarded and the system moves to the idle state to wait for the next sampling instant.
\item  [Transmission in CRM State]: The CRM's inclusion can be seen directly in this state; it is reached only when the CRM permits channel access, or when . Note that only a node in state  actually attempts a transmission. A transition out of this state occurs instantaneously, with two possibilities: transmission success or failure.
\end{enumerate}

The transition probabilities in Fig.~\ref{Fig:MCetCRM} are explained below:
\begin{itemize}
\item  and  denote the probability of an event and non-event respectively, and are defined in (\ref{Eq:TransProb_pgm}).
\item  and  denote the probability of an event and non-event, respectively, when .
\item  denotes the probability of accessing the channel through the CRM. Conversely,  represents the probability of discarding an event.
\item  denotes the conditional probability of a busy channel, as defined in (\ref{Eq:Bianchi}). A successful transmission occurs with probability .
\end{itemize}

Note that the Markov chain in Fig.~\ref{Fig:MCetCRM} represents the event-triggering and CRM of one system in the network. Thus, each system has its own such Markov chain, and these interact to produce the busy channel process in (\ref{Eq:Bianchi}).

\section{Steady State Performance Analysis} \label{S:SSanal}

In this section, we use the time-averaged aspect of Bianchi's assumption along with the Markov chain in Fig.~\ref{Fig:MCetCRM} to derive a steady state analysis. We also present extensions to more advanced network settings.

\subsection{Steady State Performance}
\begin{theorem} \label{Theorem:SteadyStateAnalysis}
For a system described by (\ref{Eq:StateSpace})--(\ref{Eq:Controller}), with Assumption~\ref{Assumption:Bianchi}, the network reliability is given by

where,  is the conditional probability of a busy channel for nodes attempting to transmit as defined in (\ref{Eq:Bianchi}), and  is the steady state probability that a node attempts to transmit, or is in any of the  states.
\end{theorem}
\begin{IEEEproof}
We begin by evaluating the probabilities , in steady state, using the transition probabilities defined above. Then, we describe the interaction between the Markov models (Fig.~\ref{Fig:MCetCRM}) corresponding to each of the systems in the network, to find an expression for the probability of a successful transmission.

The state , for , is always reached unless there is a successful transmission. The probability of a successful transmission in the  stage is given by . Thus, we obtain the recursive expression

In the final stage,  can be reached from state  and from state  itself, which gives us the above equation. Also, at any sampling instant, a node must be in any of the  states. Thus, we have


The states  and  are reached by transitioning from state  with probabilities  and , respectively. Thus, we have  and , respectively, for . The final states  and  can be reached both from , or , and from , or , respectively. This gives us  and , respectively. The states , are reached only from the event states , and so we have . Note that a node in any of the  states gets to transmit. The transmission probability of a node, denoted . A busy channel results when more than one such node accesses the channel at the same time. For a network with  nodes, the  node's probability of a busy channel is

where  is the transmission probability of any of the other  nodes. Note that we use the independence aspect of Assumption~\ref{Assumption:Bianchi} here, which simplifies the analysis.

For a network with  nodes, we have  equations (\ref{Eq:sumb0}) and (\ref{Eq:p}) in  variables,  and  for . These can be solved to find the corresponding steady state solution for each node in the network. Finally, a node that is successful in transmission, transitions to the state . Thus, the probability of a successful transmission is given by  in (\ref{Eq:PrDelta1}).
\end{IEEEproof}

The reliability is a joint measure of transmission obtained from the event-triggering policy and CRM. Other performance measures can also be found from the above Markov chain-based analysis. The steady state conditional probability of a successful transmission given that an event has occurred is given by , which does not depend on the memory of the scheduler in steady state. This quantity measures the contribution of the CRM and other network traffic towards congestion, or the lack of it. Similarly, we can evaluate the delay distribution for a node in this network, as we show below.

\begin{corollary} \label{Corollary:DelayDist}
The delay distribution for a system described by (\ref{Eq:StateSpace})--(\ref{Eq:Controller}), with Assumption~\ref{Assumption:Bianchi} and , is given by

where .
\end{corollary}
\begin{IEEEproof}
The probability of a delay  is given by the probability of a successful transmission from the state  to the state , in Fig.~\ref{Fig:MCetCRM}. We use the same principle while computing the probability of a delay . A delay of  is incurred when a successful transmission from  is preceded by a transition from state  to . A delay of  is incurred when a successful transmission from  is preceded by  transitions from state  to itself and the aforemention transition from state  to . Using the expressions in (\ref{Eq:pIdleState}), we obtain (\ref{Eq:DelayDist}).
\end{IEEEproof}

Thus, the Markov model in Fig.~\ref{Fig:MCetCRM} helps us characterize the performance of the event-triggering policy and the CRM, for the entire network.

\subsection{An Event-triggering Policy as a Set of Probabilities}

In the Markov model presented in Fig.~\ref{Fig:MCetCRM}, the probability of an event  varies with . This is because the input arguments to the policy, defined in (\ref{Eq:ETesterrip}), and the event thresholds,  in (\ref{Eq:InnoSched}), vary with . Now, given that the event-triggering policy uses the estimation error as input, the set of thresholds , for , represent the chosen policy. This set of thresholds can be translated into the corresponding set of probabilities  using (\ref{Eq:TransProb_pgm}). Thus, the set of probabilities are an alternative representation of the chosen policy. In fact, the set of probabilities can represent any given event-triggering policy. Furthermore, this set of probabilities determines the performance of the event-based network, as we saw in Theorem~\ref{Theorem:SteadyStateAnalysis} and Corollary~\ref{Corollary:DelayDist}. Thus, we consider this set of probabilities as the specification of our event-triggering policy.

To implement a given event-triggering policy, a set of thresholds corresponding to the specified set of probabilities must be found. This is not a trivial task, as the prediction errors are not Gaussian. Furthermore, its probability densities are determined by the conditional probability of a busy channel . However, it is worth noting that finding the set of probabilities corresponding to a set of thresholds is equally hard, as the underlying density functions need to be evaluated either way. It is easier to accomplish a translation from one representation to the other numerically, as we show in Section~\ref{S:Sims}.

\subsection{Extensions to More General Network Settings} \label{S:Extn}

We now extend the Markov model presented in Fig.~\ref{Fig:MCetCRM} to include more general network settings, such as retransmissions in the CRM and asynchrony. 
\subsubsection{CSMA with retransmissions}

\begin{figure*}[!t]
\begin{center}


\begingroup
  \makeatletter
  \providecommand\color[2][]{\errmessage{(Inkscape) Color is used for the text in Inkscape, but the package 'color.sty' is not loaded}
    \renewcommand\color[2][]{}}
  \providecommand\transparent[1]{\errmessage{(Inkscape) Transparency is used (non-zero) for the text in Inkscape, but the package 'transparent.sty' is not loaded}
    \renewcommand\transparent[1]{}}
  \providecommand\rotatebox[2]{#2}
  \ifx\svgwidth\undefined
    \setlength{\unitlength}{348.46242676pt}
  \else
    \setlength{\unitlength}{\svgwidth}
  \fi
  \global\let\svgwidth\undefined
  \makeatother
  \begin{picture}(1,0.59702399)\put(0,0){\includegraphics[width=\unitlength]{MCretx2.eps}}\put(0.265,0.555){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\resizebox{1.2cm}{!}{}}}\put(0.28,0.3918){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.0262,0.3918){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.81,0.255){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.815,0.0907){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.5342,0.255){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.54,0.0907){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.165,0.255){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.17,0.0907){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.15,0.47){\color[rgb]{0,0,0}\rotatebox{38.00000034}{\makebox(0,0)[lb]{\smash{}}}}\put(0.49,0.5){\color[rgb]{0,0,0}\rotatebox{-27.99999994}{\makebox(0,0)[lb]{\smash{}}}}\put(0.1803,0.4128){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.7,0.28){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.45,0.28){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.1995,0.3292){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.8763,0.1893){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.765,0.1893){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.6036,0.1893){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.5037,0.1893){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.234,0.1893){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.14,0.1893){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.8763,0.04){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.6036,0.04){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\put(0.234,0.04){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{}}}\end{picture}\endgroup
 \caption{Embedding a CRM with  distinct re-transmission stages in the Markov chain model} \label{Fig:MCretx}
\end{center}
\end{figure*}

A realistic CRM is likely to use retransmissions to spread congested network traffic over the sampling interval, as described in Fig.~\ref{Fig:TimeScales}. The model corresponding to such a CRM requires a Markov chain of its own, as shown in Fig.~\ref{Fig:MCretx}. Here, the event and CRM states,  and  for each , are replaced by multiple states,  and , for  retransmission attempts. Each successive retransmission attempt sees the same or lesser traffic from all the nodes in the network, due to a strictly non-negative probability of successful transmission in the previous attempt. Thus, the resulting Markov chain must have a unique conditional probability of a busy channel, , for each retransmission attempt , analogous to  in Assumption~\ref{Assumption:Bianchi}.
\begin{assumption} \label{Assumption:BianchiMulti}
For the systems described in (\ref{Eq:StateSpace})--(\ref{Eq:Controller}), the conditional probability of a busy channel for a node that attempts to transmit is given by an independent probability  for each retransmission stage and each system. Thus,

for all  and all .
\end{assumption}

Generating a complete Markov chain for , using the states shown in Fig.~\ref{Fig:MCretx}, we can re-evaluate all the probabilities in the proof of Theorem~\ref{Theorem:SteadyStateAnalysis}. Note that only some of the terms change. The probability of an unsuccessful transmission in the  stage is now given by , as follows from Fig.~\ref{Fig:MCretx}. This gives us

The probability of the states  is given by , and the corresponding probability of transmission from any of the  states, for different values of , is given by . Now, the conditional probability of a busy channel in the  retransmission stage can be derived as

Using the above equations in place of (\ref{Eq:pIdleState}) and (\ref{Eq:p}), we obtain similar expressions for the reliability and delay distribution as in Theorem~\ref{Theorem:SteadyStateAnalysis} and Corollary~\ref{Corollary:DelayDist}, respectively.

We present simulations to validate Assumption~\ref{Assumption:BianchiMulti} in Section~\ref{S:Sims}.

\subsubsection{Asynchronous networks}

Consider an asynchronous network, with the CRM operating in a beacon-enabled mode. In this mode, the CRM slots remain synchronized across the network, but different systems can choose to initiate sampling at randomly selected CRM slots. Consecutive samples are spaced by the sampling period  CRM slots, for all the systems in the network. An illustration of the behaviour, with and without retransmissions in the CRM, for synchronous and asynchronous networks, is provided in Fig.~\ref{Fig:AsyncRetx}. For an asynchronous network with no retransmissions in the CRM, the number of interfering transmissions in the  states is given by , where  is the number of nodes whose sampling instants lie in the same MAC slot of the  node. Thus, the performance of the network depends on the initial sampling slots chosen by the nodes. The more spread apart they are, the better the performance. For an asynchronous network with retransmissions in the CRM, the steady state seen by each retransmission state  can only be determined by knowing which of the retransmission states of other nodes interferes with transmissions from the  stage. Thus, to predict the performance of such a network, one must know the initial sampling slots chosen by all the nodes in the network.

\begin{figure*}[!t]
\begin{center}
\def\svgwidth{10cm}


\begingroup
  \makeatletter
  \providecommand\color[2][]{\errmessage{(Inkscape) Color is used for the text in Inkscape, but the package 'color.sty' is not loaded}
    \renewcommand\color[2][]{}}
  \providecommand\transparent[1]{\errmessage{(Inkscape) Transparency is used (non-zero) for the text in Inkscape, but the package 'transparent.sty' is not loaded}
    \renewcommand\transparent[1]{}}
  \providecommand\rotatebox[2]{#2}
  \ifx\svgwidth\undefined
    \setlength{\unitlength}{407.53259277pt}
  \else
    \setlength{\unitlength}{\svgwidth}
  \fi
  \global\let\svgwidth\undefined
  \makeatother
  \begin{picture}(1,0.5105372)\put(0.1,0){\includegraphics[width=\unitlength]{Disc_AsyncRetx.eps}}\put(-0.35,0.375){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\parbox[b][4em][c]{0.5\textwidth}{\centering{Synchronous, No retransmissions:}}}}\put(-0.33,0.235){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\parbox[b][4em][c]{0.5\textwidth}{\centering{Synchronous,  retransmissions:}}}}\put(-0.35,0.095){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\parbox[b][4em][c]{0.5\textwidth}{\centering{Asynchronous, No retransmissions:}}}}\put(-0.33,-0.045){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\parbox[b][4em][c]{0.5\textwidth}{\centering{Asynchronous,  retransmissions:}}}}\end{picture}\endgroup
 \caption{A comparison between synchronous and asynchronous traffic, with and without retransmissions in the CRM. The steady state analysis differs for each traffic pattern, as nodes in the  or  states see different traffic patterns under each configuration. } \label{Fig:AsyncRetx}
\end{center}
\end{figure*}

If we assume that the initial sampling slots are chosen uniformly across a frame, we can predict the average performance of an asynchronous network. We can compute the conditional probability of a busy channel by averaging across all possible combinations of interactions in each retransmission state. This averaging makes a node in the state  see a busy channel due to other nodes in any of their  states, for all  and . Thus, the probability of a busy channel is uniform across all retransmission states, i.e.,  for . The modified version of Assumption~\ref{Assumption:Bianchi} is stated below.
\begin{assumption} \label{Assumption:BianchiAsync}
For the systems described in (\ref{Eq:StateSpace})--(\ref{Eq:Controller}) in an asynchronous network, the conditional probability of a busy channel for a node that attempts to transmit, is given by an independent probability  for all retransmission stages, for each system. Thus,

for all  and all .
\end{assumption}

To evaluate the probability in \eqref{Eq:BianchiAsync}, we average across all the competing transmissions during the slots corresponding to state  of the  node, for some  and . There are  different combinations of interactions between the  retransmission stages of the other  nodes in the network, due to different initial sampling slots. If each of these interactions are equally likely, the resulting expression is quite simple. The conditional probability can be found to be

where  denotes the average transmission probability across all retransmission states. This equation can be used in place of (\ref{Eq:p}) to find expressions for the reliability and delay distribution as before. We perform simulations in Section~\ref{S:Sims} to validate Assumption~\ref{Assumption:BianchiAsync} and the resulting analysis. However, note that to obtain this result, we simulate across  different combinations of interactions, due to  different combinations of initial sampling slots. The result obtained for a single selection of sampling slots can be quite different from the averaged values.





\section{Examples and Simulations} \label{S:Sims}

We now return to Example~\ref{Ex:Setup}, and apply our analysis to this experimental setup. We present a number of variations of this example to validate each of the assumptions we have used for analyzing different network configurations. In each case, we present the reliability obtained through Monte-Carlo simulations, and compare it to the analytical value obtained using the analysis presented above. The differences are negligible in each case, thus validating our assumptions and verifying our analysis. We also evaluate the Linear Quadratic Gaussian (LQG) control cost, defined as

where  and  are the state and control weighting matrices, respectively. We use the LQG cost as a control-theoretic performance metric for a given event-triggering policy.

\begin{example}[Event-Triggering Policy as a Set of Probabilities] \label{Ex:Setup2}
We use the same setup described in Example~\ref{Ex:Setup}, comprising of a homogenous network of  scalar systems, with  retransmissions. The event-triggering policies are described by \eqref{Eq:InnoSched}, with constant thresholds. For a chosen set of event probabilities, we discuss the implementation of the event-triggering policy. We also compare the results of Monte-Carlo simulations with results obtained from our analysis.

\begin{table}[!t]
\begin{center}
\caption{A comparison of analytical and simulated values of }\label{Tb:SimResults}
\begin{tabular}{c | c c}
\hline\hline Parameter & Simulation & Analysis \\ \hline
 &  &  \\
 &  &  \\
 &  &  \\
 &  &  \\
 &  &  \\
 &  &  \\
\hline
\end{tabular}
\end{center}
\vspace{-2mm}
\end{table}

The event probabilities are given to be  for . Computing thresholds from a set of event probabilities is not easy, as the estimation error distributions are not Gaussian. In fact, a closed-form expression cannot be found for the distribution, though the evolution of the distribution can be described iteratively. Thus, we empirically select thresholds which result in the desired probabilities. In fact,  achieves the given probabilities.

The values of reliability and the conditional probabilities of a busy channel obtained through simulations and analysis are presented in Table~\ref{Tb:SimResults}. The simulated values agree closely with the analytical values computed using Theorem~\ref{Theorem:SteadyStateAnalysis}. Thus, Assumption~\ref{Assumption:BianchiMulti} is a reasonable approximation and motivates the Markov modelling.
\end{example}

\begin{example}[Simple Network with No Retransmissions] \label{Ex:NoRetx}
We now consider a setup consisting of  nodes. There are no retransmissions in this network, i.e., , and the CRM probability is . The plant model and event-triggering policy are identical to the ones in Example~\ref{Ex:Setup}. The scheduler threshold is varied from  to  in this experiment. Each value of  results in a set of event probabilities and a corresponding network performance. The reliability  obtained through analysis and simulations is plotted against the threshold in Fig.~\ref{Fig:pDeltaVSeps_NoRetx}. As the threshold increases, the reliability decreases. Thus, at larger thresholds, too few events are being generated to completely utilize the network resources. Note the close correspondence between the simulated and analytical values, validating Assumption~\ref{Assumption:Bianchi}. The corresponding control costs obtained through simulations are also plotted in the graph below, indicating an expected increase in cost with decreasing reliability.

\begin{figure*}[tb]
\begin{center}
\includegraphics*[scale=0.35, viewport = 80 55 1400 800]{pDeltaVSeps_M2R1.eps}
\caption{A comparison of the analytical and simulated values of the reliability versus the event-triggering threshold, in a simple network with no retransmissions in the CRM. The close correspondence of these values validates Assumption~\ref{Assumption:Bianchi} and the results of Theorem~\ref{Theorem:SteadyStateAnalysis}.} \label{Fig:pDeltaVSeps_NoRetx}
\end{center}
\end{figure*}
\end{example}

\begin{example}[Retransmissions in the CRM] \label{Ex:Retx}
We return to the problem setup in Example~\ref{Ex:Setup}, with  nodes and  retransmissions. A comparison of analytical and simulated values of the reliability versus the threshold for this synchronized network is shown in Fig.~\ref{Fig:pDeltaVSepsilon}. The performance obtained from the network is, in accordance with expectations, poor due to synchronization and congestion. Low thresholds cause many packets to flood the network, and result in a low probability of a successful transmission due to congestion. High thresholds reduce the utilization of the network, and the probability of a successful transmission decreases again. Note that there is a threshold that optimizes use of the network resources. A system-level performance analysis is required to characterize this threshold.

\begin{figure*}[tb]
\begin{center}
\includegraphics*[scale=0.35, viewport = 80 55 1400 800]{pDeltaVSeps_M10R5Sync.eps}
\caption{A comparison of the analytical and simulated values of the reliability versus the scheduler threshold, with retransmissions in the CRM. This example validates Assumption~\ref{Assumption:BianchiMulti}. Note that low thresholds result in a low  due to congestion. High thresholds also result in a low , but due to under-utilization of the network. } \label{Fig:pDeltaVSepsilon}
\end{center}
\end{figure*}
\end{example}

\begin{example}[Unsaturated Traffic] \label{Ex:Unsat}
In this example, we look at sparse traffic and show that Bianchi's assumption holds well even in this scenario. We have now validated Bianchi's assumption in two different scenarios, with and without retransmissions in the CRM. However, Bianchi's assumption is theoretically motivated by a mean field analysis. Thus, it is important to ascertain that this assumption holds just as well when there is not much traffic in the network. So, consider a network with  nodes and  retransmissions in the CRM. The sampling period corresponds to  CRM slots. Thus, each of the nodes has sufficient slots to transmit successfully. The plant model and event-triggering policy are the same as in Example~\ref{Ex:Setup}.

A comparison of the reliability obtained for different thresholds is shown in Fig.~\ref{Fig:pDeltaVSeps_unsat}. Note that the maximum reliability obtained in this network is for the lowest value of the threshold, i.e., . In other words, all samples are chosen as events, and even so, the network is largely successful in delivering them to the respective controllers. Also note that the reliability falls sharply as the threshold increases, indicating that too few events are generated to fully utilize the available network resources.

\begin{figure*}[tb]
\begin{center}
\includegraphics*[scale=0.35, viewport = 80 55 1400 800]{pDeltaVSeps_M2R5UnsatSync.eps}
\caption{A comparison of the analytical and simulated values of the reliability versus the scheduler threshold, with unsaturated traffic. There are just  nodes in the network and the CRM permits  retransmissions. Even so, Bianchi's assumption seems to hold, indicating that this is a good approximation of unsaturated and saturated network conditions.} \label{Fig:pDeltaVSeps_unsat}
\end{center}
\end{figure*}
\end{example}

\begin{example}[Asynchronous Traffic] \label{Ex:Async}
We now look at an asynchronous network, with  nodes, a sampling period of  slots and  retransmissions in the CRM. The plant model and event-triggering policy are identical to the setup in Example~\ref{Ex:Setup}. The persistence probabilities of the CRM are chosen to be . A comparison of the reliabilities obtained for various thresholds is shown in Fig.~\ref{Fig:pDeltaVSeps_Async}. The analytical and simulated values bear close correspondence, thus validating Assumption~\ref{Assumption:BianchiAsync}. Note that the values obtained in this experiment are averaged across all possible selections of initial sampling slots by all five nodes in the network. The results may be quite different for a given selection of initial sampling slots. In other words, the highest reliability obtainable from this system may far exceed the average reliability shown in Fig.~\ref{Fig:pDeltaVSeps_Async}.
\begin{figure*}[tb]
\begin{center}
\includegraphics*[scale=0.35, viewport = 80 55 1400 800]{pDeltaVSeps_M5R3_2_Async.eps}
\caption{A comparison of the analytical and simulated values of the reliability versus the event-triggering threshold, for an asynchronous network. The network consists of  nodes, with sampling periods of  slots and  retransmissions in the CRM. The reliability obtained through analysis and simulations is averaged across all possible selections of initial sampling slots by the  nodes in the network. This plot validates Assumption~\ref{Assumption:BianchiAsync}.} \label{Fig:pDeltaVSeps_Async}
\end{center}
\end{figure*}
\end{example}


\subsection{Discussion}

Let us now compare the results we have obtained in the above examples, to comment on the underlying network configurations. Examples~\ref{Ex:NoRetx}~and~\ref{Ex:Unsat} deal with networks consisting of two closed-loop systems each, but permitting one and five re-transmissions, respectively. The higher number of retransmissions results in a significantly higher reliability, and correspondingly lower LQG cost. This can be seen by comparing Figures~\ref{Fig:pDeltaVSeps_NoRetx}~and~\ref{Fig:pDeltaVSeps_unsat}. Example~\ref{Ex:Retx} deals with a network consisting of ten synchronized closed-loop systems and five retransmissions. The ratio of transmissions slots to number of systems is equal to , which is the same as for Example~\ref{Ex:NoRetx}. A comparison of Figures~\ref{Fig:pDeltaVSepsilon}~and~\ref{Fig:pDeltaVSeps_NoRetx} indicates a slightly reduced reliability in the multiple retransmission case, especially for small values of the event-triggering threshold . This can be attributed to the increase in congestion at every sampling instant in a synchronized network with more systems. The reliability curve for the asynchronous network in Fig.~\ref{Fig:pDeltaVSeps_Async} improves the performance for small values of .

We now comment on Bianchi's assumption, which has been shown to hold under different network configurations. The above results validate the use of Bianchi's assumption for modelling the interactions of event-triggering policies and CRMs. Previously, Bianchi's assumption has been shown to hold in setups where the probability of accessing the network in different stages results from independent random processes, such as random backoffs in CSMA/CA. The probability of accessing the network in our model is not independent in each stage, as the estimation error for event-triggering policies is correlated to its past, as shown in Lemma~\ref{Lemma:LostProp}. Thus, what we have here is a new configuration for the applicability of Bianchi's assumption. A theoretical motivation of this assumption is beyond the scope of this paper. An explanation of Bianchi's assumption in the context of CSMA/CA is presented in \cite{Bordenave2010}.

\section{Conclusions} \label{S:Concl}

We have presented a method to analyze the performance of a network of event-based systems that use a CRM to access the shared network. We have shown that a Markov model can be constructed to represent the event-triggering policy and CRM, once we use Bianchi's assumption. Based on this model, we have analyzed the steady state performance of the resulting network. This analysis assumed conditional independence from other traffic when a node attempts to transmit. We validated this assumption through simulations, and provided extensions to more complex network configurations. For future work, we wish to use the insights obtained through this work to design adaptive event-triggering policies.

\bibliographystyle{ieeetr}
\bibliography{FullList}


\end{document}
