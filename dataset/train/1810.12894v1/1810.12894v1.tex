\documentclass{article} \usepackage[dvipsnames]{xcolor}
\usepackage{iclr2019_conference}
\usepackage{times}
\usepackage{tabularx, algorithm,algorithmic}

\usepackage{graphics,graphicx,subfigure,caption,float,booktabs,xcolor,multirow,array,color,bm,ifthen,tabu,colortbl,dblfloatfix,amsmath,amssymb,xspace,amsfonts,nicefrac,microtype,wrapfig, color,natbib}
\usepackage{hyperref}
\hypersetup{colorlinks=true,citecolor=black}
\usepackage[bottom]{footmisc}
\usepackage{url}




\newif\ifincludecomment
\includecommenttrue \ifincludecomment
  \newenvironment{guidance}{\color{ForestGreen}\it}{\color{black}\rm}
\else
  \NewEnviron{guidance}{}{}
\fi

\setlength{\marginparwidth}{16mm}
\usepackage[colorinlistoftodos,textsize=tiny, textwidth=18mm]{todonotes}
\ifincludecomment
\newcommand{\maybecomment}[1]{\todo[color=olive!40]{#1}} 
\newcommand{\maybetohere}[1]{\todo[color=red!40]{#1}} 
\newcommand{\maybedelete}[1]{\todo[color=blue!40]{#1}} 
\newcommand{\maybeinsert}[1]{\color{ForestGreen} #1}
\else
  \newcommand{\maybecomment}[1]{}
  \newcommand{\maybeinsert}[1]{#1}
\newcommand{\maybedelete}[1]{} 
\fi
\newcommand{\amostohere}[1]{{\color{black}\maybetohere{AMOS HERE}}}

\newcommand{\harri}[1]{{\color{ForestGreen}\maybecomment{RK: #1}}}
\newcommand{\amos}[1]{{\color{blue}\maybecomment{AJS: #1}}}


\newcommand{\amosed}[1]{{\maybeinsert{#1}}}
\newcommand{\harried}[1]{{\maybeinsert{#1}}}

\newcommand{\amosdel}[1]{{\maybedelete{DEL: #1}}}
\newcommand{\harridel}[1]{{\maybedelete{DEL: #1}}}


\DeclareMathOperator*{\argmin}{arg\,min}

\title{Exploration by Random Network Distillation}



\author{Yuri Burda\\
OpenAI\\
\And
Harrison Edwards\thanks{Alphabetical ordering; the first two authors contributed equally.}\\
OpenAI
\And
Amos Storkey\\
Univ. of Edinburgh
\And
Oleg Klimov\\
OpenAI
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}
We introduce an exploration bonus for deep reinforcement learning methods that is easy to implement and adds minimal overhead to the computation performed. The bonus is the error of a neural network predicting features of the observations given by a fixed randomly initialized neural network. We also introduce a method to flexibly combine intrinsic and extrinsic rewards. We find that the random network distillation (RND) bonus combined with this increased flexibility enables significant progress on several hard exploration Atari games. In particular we establish state of the art performance on Montezuma's Revenge, a game famously difficult for deep reinforcement learning methods. To the best of our knowledge, this is the first method that achieves better than average human performance on this game without using demonstrations or having access to the underlying state of the game, and occasionally completes the first level.\end{abstract}

\begin{figure}[!b]
\vspace*{-8pt}
\centering
\includegraphics[width=\linewidth]{figures/spikes.pdf}
\caption{RND exploration bonus over the course of the first episode where the agent picks up the torch (19-21). To do so the agent passes 17 rooms and collects gems, keys, a sword, an amulet, and opens two doors. Many of the spikes in the exploration bonus correspond to meaningful events: losing a life (2,8,10,21), narrowly escaping an enemy (3,5,6,11,12,13,14,15),  passing a difficult obstacle (7,9,18), or picking up an object (20,21). The large spike at the end corresponds to a novel experience of interacting with the torch, while the smaller spikes correspond to relatively rare events that the agent has nevertheless experienced multiple times.  See \href{https://github.com/openai/random-network-distillation}{here} for videos.}
\label{fig:spikes}
\end{figure}


\section{Introduction}
Reinforcement learning (RL) methods work by maximizing the expected return of a policy. This works well when the environment has dense rewards that are easy to find by taking random sequences of actions, but tends to fail when the rewards are sparse and hard to find. In reality it is often impractical to engineer dense reward functions for every task one wants an RL agent to solve. In these situations methods that explore the environment in a directed way are necessary.

Recent developments in RL seem to suggest that solving the most challenging tasks \citep{SilverHuangEtAl16nature,zoph2016neural,horgan2018distributed,espeholt2018impala,openai2018dota,openai2018dexterous} requires processing large numbers of samples obtained from running many copies of the environment in parallel. In light of this it is desirable to have exploration methods that scale well with large amounts of experience. However many of the recently introduced exploration methods based on counts, pseudo-counts, information gain or prediction gain are difficult to scale up to large numbers of parallel environments.

This paper introduces an exploration bonus that is particularly simple to implement, works well with high-dimensional observations, can be used with any policy optimization algorithm, and is efficient to compute as it requires only a single forward pass of a neural network on a batch of experience. Our exploration bonus is based on the observation that neural networks tend to have significantly lower prediction errors on examples similar to those on which they have been trained. This motivates the use of prediction errors of networks trained on the agent's past experience to quantify the novelty of new experience.

As pointed out by many authors, agents that maximize such prediction errors tend to get attracted to transitions where the answer to the prediction problem is a stochastic function of the inputs. For example if the prediction problem is that of predicting the next observation given the current observation and agent's action (forward dynamics), an agent trying to maximize this prediction error will tend to seek out stochastic transitions, like those involving randomly changing static noise on a TV, or outcomes of random events such as coin tosses. This observation motivated the use of methods that quantify the relative improvement of the prediction, rather than its absolute error. Unfortunately, as previously mentioned, such methods are hard to implement efficiently.

We propose an alternative solution to this undesirable stochasticity by defining an exploration bonus using a prediction problem where the answer is a deterministic function of its inputs. Namely we predict the output of a fixed randomly initialized neural network on the current observation.

Atari games have been a standard benchmark for deep reinforcement learning algorithms since the pioneering work by \cite{mnih2013playing}. \cite{bellemare2016unifying} identified among these games the hard exploration games with sparse rewards: Freeway, Gravitar, Montezuma's Revenge, Pitfall!, Private Eye, Solaris, and Venture. RL algorithms tend to struggle on these games, often not finding even a single positive reward.

In particular, Montezuma's Revenge is considered to be a difficult problem for RL agents, requiring a combination of mastery of multiple in-game skills to avoid deadly obstacles, and finding rewards that are hundreds of steps apart from each other even under optimal play. Significant progress has been achieved by methods with access to either expert demonstrations \citep{pohlen2018observe,aytar2018playing,garmulewicz2018expert}, special access to the underlying emulator state \citep{tang2016exploration,stanton2018deep}, or both \citep{salimans2018mz}. However without such aids, progress on the exploration problem in Montezuma's Revenge has been slow, with the best methods finding about half the rooms \citep{bellemare2016unifying}. For these reasons we provide extensive ablations of our method on this environment.

We find that even when disregarding the extrinsic reward altogether, an agent maximizing the RND exploration bonus consistently finds more than half of the rooms in Montezuma's Revenge. To combine the exploration bonus with the extrinsic rewards we introduce a modification of Proximal Policy Optimization (PPO, \cite{ppo}) that uses two value heads for the two reward streams. This allows the use of different discount rates for the different rewards, and combining episodic and non-episodic returns. With this additional flexibility, our best agent often finds 22 out of the 24 rooms on the first level in Montezuma's Revenge, and occasionally (though not frequently) passes the first level. The same method gets state of the art performance on Venture and Gravitar.
\section{Method}
\subsection{Exploration bonuses}
\label{sec:method}
Exploration bonuses are a class of methods that encourage an agent to explore even when the environment's reward  is sparse. They do so by replacing  with a new reward , where  is the exploration bonus associated with the transition at time .

To encourage the agent to visit novel states, it is desirable for  to be higher in novel states than in frequently visited ones. Count-based exploration methods provide an example of such bonuses. In a tabular setting with a finite number of states one can define  to be a decreasing function of the visitation count  of the state . In particular  and  have been used in prior work \citep{bellemare2016unifying, neuralcount}. In non-tabular cases it is not straightforward to produce counts, as most states will be visited at most once. One possible generalization of counts to non-tabular settings is pseudo-counts \citep{bellemare2016unifying} which uses changes in state density estimates as an exploration bonus. In this way the counts derived from the density model can be positive even for states that have not been visited in the past, provided they are similar to previously visited states.

An alternative is to define  as the prediction error for a problem related to the agent's transitions. Generic examples of such problems include forward dynamics \citep{schmidhuber_curiosity,stadie2015incentivizing,josh_surprise,pathakICMl17curiosity,burda18largescale} and inverse dynamics \citep{haber2018learning}. Non-generic prediction problems can also be used if specialized information about the environment is available, like predicting physical properties of objects the agent interacts with \citep{denil2016learning}. Such prediction errors tend to decrease as the agent collects more experience similar to the current one. For this reason even trivial prediction problems like predicting a constant zero function can work as exploration bonuses \citep{fox2018dora}.

\subsection{Random Network Distillation}

\label{sec:rnd}



This paper introduces a different approach where the prediction problem is randomly generated. This involves two neural networks: a fixed and randomly initialized \emph{target} network which sets the prediction problem, and a \emph{predictor} network trained on data collected by the agent. The target network takes an observation to an embedding  and the predictor neural network  is trained by gradient descent to minimize the expected MSE  with respect to its parameters . This process distills a randomly initialized neural network into a trained one. The prediction error is expected to be higher for novel states dissimilar to the ones the predictor has been trained on.

To build intuition we consider a toy model of this process on MNIST. We train a predictor neural network to mimic a randomly initialized target network on training data consisting of a mixture of images with the label 0 and of a target class, varying the proportion of the classes, but not the total number of training examples. We then test the predictor network on the unseen test examples of the target class and report the MSE. In this model the zeros are playing the role of states that have been seen many times before, and the target class is playing the role of states that have been visited infrequently. The results are shown in Figure \ref{fig:mnist}. The figure shows that test error decreases as a function of the number of training examples in the target class, suggesting that this method can be used to detect novelty. Figure \ref{fig:spikes} shows that the intrinsic reward is high in novel states in an episode of Montezuma's Revenge.

One objection to this method is that a sufficiently powerful optimization algorithm might find a predictor that mimics the target random network perfectly on any input (for example the target network itself would be such a predictor). However the above experiment on MNIST shows that standard gradient-based methods don't overgeneralize in this undesirable way.

\subsubsection{Sources of prediction errors}
\label{sec:prediction_error}In general, prediction errors can be attributed to a number of factors:
\begin{enumerate}
    \item \emph{Amount of training data}. Prediction error is high where few similar examples were seen by the predictor (epistemic uncertainty).
    \item \emph{Stochasticity}. Prediction error is high because the target function is stochastic (aleatoric uncertainty). Stochastic transitions are a source of such error for forward dynamics prediction.
    \item \emph{Model misspecification}. Prediction error is high because necessary information is missing, or the model class is too limited to fit the complexity of the target function.
    \item \emph{Learning dynamics}. Prediction error is high because the optimization process fails to find a predictor in the model class that best approximates the target function.
\end{enumerate}

Factor 1 is what allows one to use prediction error as an exploration bonus. In practice the prediction error is caused by a combination of all of these factors, not all of them desirable.

For instance if the prediction problem is forward dynamics, then factor 2 results in the `noisy-TV' problem. This is the thought experiment where an agent that is rewarded for errors in the prediction of its forward dynamics model gets attracted to local sources of entropy in the environment. A TV showing white noise would be such an attractor, as would a coin flip.

To avoid the undesirable factors 2 and 3, methods such as those by \cite{schmidhuber1991curious,oudeyer2007intrinsic,lopes2012exploration,josh_surprise} instead use a measurement of how much the prediction model improves upon seeing a new datapoint. However these approaches tend to be computationally expensive and hence difficult to scale.

RND obviates factors 2 and 3 since the target network can be chosen to be deterministic and inside the model-class of the predictor network.

\subsubsection{Relation to uncertainty quantification}
RND prediction error is related to an uncertainty quantification method introduced by \cite{osband2018randomized}. Namely, consider a regression problem with data distribution . In the Bayesian setting we would consider a prior  over the parameters of a mapping  and calculate the posterior after updating on the evidence. 

Let  be the distribution over functions , where  is drawn from  and  is given by minimizing the expected prediction error 

where  is a regularization term coming from the prior (see Lemma 3, \cite{osband2018randomized}).
\citet{osband2018randomized} argue (by analogy to the case of Bayesian linear regression) that the ensemble  is an approximation of the posterior.

If we specialize the regression targets  to be zero, then the optimization problem  is equivalent to distilling a randomly drawn function from the prior. Seen from this perspective, each coordinate of the output of the predictor and target networks would correspond to a member of an ensemble (with parameter sharing amongst the ensemble), and the MSE would be an estimate of the predictive variance of the ensemble (assuming the ensemble is unbiased). In other words the distillation error could be seen as a quantification of uncertainty in predicting the constant zero function.

\subsection{Combining intrinsic and extrinsic returns}
\label{sec:methods_two_heads}
In preliminary experiments that used only intrinsic rewards, treating the problem as non-episodic resulted in better exploration. In that setting the return is not truncated at ``game over". We argue that this is a natural way to do exploration in simulated environments, since the agent's intrinsic return should be related to all the novel states that it could find in the future, regardless of whether they all occur in one episode or are spread over several. It is also argued in \citep{burda18largescale} that using episodic intrinsic rewards can leak information about the task to the agent.

We also argue that this is closer to how humans explore games. For example let's say Alice is playing a videogame and is attempting a tricky maneuver to reach a suspected secret room. Because the maneuver is tricky the chance of a game over is high, but the payoff to Alice's curiosity will be high if she succeeds. If Alice is modelled as an episodic reinforcement learning agent, then her future return will be exactly zero if she gets a game over, which might make her overly risk averse. The real cost of a game over to Alice is the opportunity cost incurred by having to play through the game from the beginning (which is presumably less interesting to Alice having played the game for some time).

However using non-episodic returns for extrinsic rewards could be exploited by a strategy that finds a reward close to the beginning of the game, deliberately restarts the game by getting a game over, and repeats this in an endless cycle.

It is not obvious how to estimate the combined value of the non-episodic stream of intrinsic rewards  and the episodic stream of extrinsic rewards . Our solution is to observe that the return is linear in the rewards and so can be decomposed as a sum  of the extrinsic and intrinsic returns respectively. Hence we can fit two value heads  and  separately using their respective returns, and combine them to give the value function . This same idea can also be used to combine reward streams with different discount factors.

Note that even where one is not trying to combine episodic and non-episodic reward streams, or reward streams with different discount factors, there may still be a benefit to having separate value functions since there is an additional supervisory signal to the value function. This may be especially important for exploration bonuses since the extrinsic reward function is stationary whereas the intrinsic reward function is non-stationary.

\subsection{Reward and Observation Normalization}
One issue with using prediction error as an exploration bonus is that the scale of the reward can vary greatly between different environments and at different points in time, making it difficult to choose hyperparameters that work in all settings. In order to keep the rewards on a consistent scale we normalized the intrinsic reward by dividing it by a running estimate of the standard deviations of the intrinsic returns.

Observation normalization is often important in deep learning but it is  crucial when using a random neural network as a target, since the parameters are frozen and hence cannot adjust to the scale of different datasets. Lack of normalization can result in the variance of the embedding being extremely low and carrying little information about the inputs. To address this issue we use an observation normalization scheme often used in continuous control problems whereby we whiten each dimension by subtracting the running mean and then dividing by the running standard deviation. We then clip the normalized observations to be between -5 and 5. We initialize the normalization parameters by stepping a random agent in the environment for a small number of steps before beginning optimization. We use the same observation normalization for both predictor and target networks but not the policy network.

\section{Experiments}
We begin with an intrinsic reward only experiment on Montezuma's Revenge in Section \ref{sec:int_only_exp} to isolate the inductive bias of the RND bonus, follow by extensive ablations of RND on Montezuma's Revenge in Sections \ref{sec:exp_episodic}-\ref{sec:exp_scale} to understand the factors that contribute to RND's performance, and conclude with a comparison to baseline methods on 6 hard exploration Atari games in Section \ref{sec:baselines}. For details of hyperparameters and architectures we refer the reader to Appendices \ref{sec:proprocessing} and \ref{sec:ppornd_hyperparams}. Most experiments are run for 30K rollouts of length  per environment with  parallel environments, for a total of  billion frames of experience. 
\subsection{Pure exploration}
\label{sec:int_only_exp}
\begin{figure}[t]
\begin{minipage}[t]{0.5\linewidth}
\centering
\vspace{0pt}
\includegraphics[width=\linewidth]{figures/mnist.png}
\end{minipage}\hspace{.02\textwidth}
\begin{minipage}[t]{0.46\linewidth}
\centering
\vspace{0pt}
\includegraphics[width=\linewidth]{figures/int_only_arxiv.png}
\end{minipage}\par
\begin{minipage}[t]{0.5\linewidth}
\caption{Novelty detection on MNIST: a predictor network mimics a randomly initialized target network. The training data consists of varying proportions of images from class ``0'' and a target class. Each curve shows the test MSE on held out target class examples plotted against the number of training examples of the target class (log scale).}
\label{fig:mnist}
\end{minipage}\hspace{.02\textwidth}
\begin{minipage}[t]{0.46\linewidth}
\caption{Mean episodic return and number of rooms found by pure exploration agents on Montezuma's Revenge trained without access to the extrinsic reward. The agents explores more in the non-episodic setting (see also Section \ref{sec:methods_two_heads})}
\label{fig:int_only}
\end{minipage}\vspace*{-20pt}
\end{figure}
In this section we explore the performance of RND in the absence of any extrinsic reward. In Section \ref{sec:methods_two_heads} we argued that exploration with RND might be more natural in the non-episodic setting. By comparing the performance of the pure exploration agent in episodic and non-episodic settings we can see if this observation translates to improved exploration performance.

We report two measures of exploration performance in Figure \ref{fig:int_only}: mean episodic return, and the number of rooms the agent finds over the training run. Since the pure exploration agent is not aware of the extrinsic rewards or number of rooms, it is not directly optimizing for any of these measures. However obtaining some rewards in Montezuma's Revenge (like getting the key to open a door) is required for accessing more interesting states in new rooms, and hence we observe the extrinsic reward increasing over time up to some point. The best return is achieved when the agent interacts with some of the objects, but the agent has no incentive to keep doing the same once such interactions become repetitive, hence returns are not consistently high.

We clearly see in Figure \ref{fig:int_only} that on both measures of exploration the non-episodic agent performs best, consistent with the discussion in Section \ref{sec:methods_two_heads}. The non-episodic setting with  explores more rooms than , with one of the runs exploring 21 rooms. The best return achieved by 4 out 5 runs of this setting was 6,700. 

\subsection{Combining episodic and non-episodic returns}
\label{sec:exp_episodic}
In Section \ref{sec:int_only_exp} we saw that the non-episodic setting resulted in more exploration than the episodic setting when exploring without any extrinsic rewards. Next we consider whether this holds in the case where we combine intrinsic and extrinsic rewards. As discussed in Section \ref{sec:methods_two_heads} in order to combine episodic and non-episodic reward streams we require two value heads. This also raises the question of whether it is better to have two value heads even when both reward streams are episodic. In Figure \ref{fig:dual_value} we compare episodic intrinsic rewards to non-episodic intrinsic rewards combined with episodic extrinsic rewards, and additionally two value heads versus one for the episodic case. The discount factors are .

\begin{figure}[htbp]
\begin{minipage}{.48\textwidth}
\centering
\includegraphics[width=\linewidth]{figures/dual_value_arxiv.png}
(a) RNN policies
\end{minipage}\hspace{.02\textwidth}
\begin{minipage}{.48\textwidth}
\centering
\includegraphics[width=\linewidth]{figures/dual_value_cnn_arxiv.png}
(b) CNN policies
\end{minipage}\vspace*{-4pt}
\caption{Different ways of combining intrinsic and extrinsic rewards. Combining non-episodic stream of intrinsic rewards with the episodic stream of extrinsic rewards outperforms combining episodic versions of both steams in terms of number of  explored rooms, but performs similarly in terms of mean return. Single value estimate of the combined stream of episodic returns performs a little better than the dual value estimate. The differences are more pronounced with RNN policies. CNN runs are more stable than the RNN counterparts.}
\label{fig:dual_value}
\end{figure}

In Figure \ref{fig:dual_value} we see that using a non-episodic intrinsic reward stream increases the number of rooms explored for both CNN and RNN policies, consistent with the experiments in Section \ref{sec:int_only_exp}, but that the difference is less dramatic, likely because the extrinsic reward is able to preserve useful behaviors. We also see that the difference is less pronounced for the CNN experiments, and that the RNN results tend to be less stable and perform worse for .

Contrary to our expectations (Section \ref{sec:methods_two_heads}) using two value heads did not show any benefit over a single head in the episodic setting. Nevertheless having two value heads is necessary for combining reward streams with different characteristics, and so all further experiments use two value heads.
\subsection{Discount factors}
Previous experiments \citep{salimans2018mz, pohlen2018observe,garmulewicz2018expert} solving Montezuma's Revenge using expert demonstrations used a high discount factor to achieve the best performance, enabling the agent to anticipate rewards far into the future. We compare the performance of the RND agent with  and . We also investigate the effect of increasing  to 0.999. The results are shown in Figure \ref{fig:discount}.

In Figure \ref{fig:discount} we see that increasing  to 0.999 while holding  at 0.99 greatly improves performance. We also see that further increasing  to 0.999 hurts performance. This is at odds with the results in Figure \ref{fig:int_only} where increasing  did not significantly impact performance.
\begin{figure}[tbp]
\centering
\begin{minipage}[t]{0.48\linewidth}
\centering
\includegraphics[width=\linewidth]{figures/discount_arxiv.png}
\end{minipage}\hspace{.02\textwidth}
\begin{minipage}[t]{0.48\linewidth}
\centering
\includegraphics[width=\linewidth]{figures/scale_ablation_arxiv.png}
\end{minipage}\par
\vspace*{-5pt}
\begin{minipage}[t]{0.48\linewidth}
\caption{Performance of different discount factors for intrinsic and extrinsic reward streams. A higher discount factor for the extrinsic rewards leads to better performance, while for intrinsic rewards it hurts exploration.}
\label{fig:discount}
\end{minipage}\hspace{.02\textwidth}
\begin{minipage}[t]{0.48\linewidth}
\caption{Mean episodic return improves as the number of parallel environments used for collecting the experience increases for both the CNN policy (left) and the RNN policy (right). The runs have processed 0.5,2, and 16B frames.}
\label{fig:scale}
\end{minipage}\vspace*{-20pt}
\end{figure}


\subsection{Scaling up training}
\label{sec:exp_scale}
In this section we report experiments showing the effect of increased scale on training. The intrinsic rewards are non-episodic with , and .

To hold the rate at which the intrinsic reward decreases over time constant across experiments with different numbers of parallel environments, we downsample the batch size when training the predictor to match the batch size with 32 parallel environments (for full details see Appendix \ref{sec:ppornd_hyperparams}). Larger numbers of environments results in larger batch sizes per update for training the policy, whereas the predictor network batch size remains constant. Since the intrinsic reward disappears over time it is important for the policy to learn to find and exploit these transitory rewards, since they act as stepping-stones to nearby novel states.

Figure \ref{fig:scale} shows that agents trained with larger batches of experience collected from more parallel environments obtain higher mean returns after similar numbers of updates.  They also achieve better final performance. This effect seems to saturate earlier for the CNN policy than for the RNN policy.

We allowed the RNN experiment with 32 parallel environments to run for more time, eventually reaching a mean return of 7,570 after processing 1.6 billion frames over 1.6 million parameter updates. One of these runs visited all 24 rooms, and passed the first level once, achieving a best return of 17,500. The RNN experiment with 1024 parallel environments had mean return of 10,070 at the end of training, and yielded one run with mean return of 14,415.

\subsection{Recurrence}
\label{sec:cnnrnn}
Montezuma's Revenge is a partially observable environment even though large parts of the game state can be inferred from the screen. For example the number of keys the agent has appears on the screen, but not where they come from, how many keys have been used in the past, or what doors have been opened. To deal with this partial observability, an agent should maintain a state summarizing the past, for example the state of a recurrent policy. Hence it would be natural to hope for better performance from agents with recurrent policies. Contrary to expectations in Figure \ref{fig:dual_value} recurrent policies performed worse than non-recurrent counterparts with . However in Figure \ref{fig:scale} the RNN policy with  outperformed the CNN counterpart at each scale\footnote{The results in Figure \ref{fig:discount} for the CNN policy were obtained as an average of 5 random seeds. When we ran 10 different seeds for the best performing setting for Figure \ref{fig:scale} we found a large discrepancy in performance. This discrepancy is likely explained by the fact that the distribution of results on Montezuma's Revenge dominated by effects of discrete choices (such as going left or right from the first room), and hence contains a preponderance of outliers. In addition, the results in Figure \ref{fig:discount} were run with an earlier version of our code base and it is possible that subtle differences between that version and the publicly released one have contributed to the discrepancy. The results in Figure \ref{fig:scale} were reproduced with the publicly released \href{https://github.com/openai/random-network-distillation}{code} and so we suggest that future work compares against these results.}. Comparison of Figures \ref{fig:ext_comparison} and \ref{fig:ext_comparison_cnn} shows that across multiple games the RNN policy outperforms the CNN more frequently than the other way around.

\subsection{Comparison to baselines}
\label{sec:baselines}
In this section we compare RND to two baselines: PPO without an exploration bonus and an alternative exploration bonus based on forward dynamics error. We evaluate RND's performance on six hard exploration Atari games: Gravitar, Montezuma's Revenge, Pitfall!, Private Eye, Solaris, and Venture. We first compare to the performance of a baseline PPO implementation without intrinsic reward. For RND the intrinsic rewards are non-episodic with  , while  for both PPO and RND. The results are shown in Figure \ref{fig:ext_comparison} for the RNN policy and summarized in Table \ref{table:baselines} (see also Figure \ref{fig:ext_comparison_cnn} for the CNN policy).

\begin{figure}[h!]
\centering
\includegraphics[width=\linewidth]{figures/ext_vs_ext-plus-int_tall_arxiv.png}
\caption{Mean episodic return of RNN-based policies: RND, dynamics-based exploration method, and PPO with extrinsic reward only on 6 hard exploration Atari games. RND achieves state of the art performance on Gravitar, Montezuma's Revenge, and Venture, significantly outperforming PPO on the latter two.}
\label{fig:ext_comparison}
\vspace*{-8pt}
\end{figure}

In Gravitar we see that RND does not consistently exceed the performance of PPO. However both exceed average human performance with an RNN policy, as well as the previous state of the art. On Montezuma's Revenge and Venture RND significantly outperforms PPO, and exceeds state of the art performance and average human performance. On Pitfall! both algorithms fail to find any positive rewards. This is a typical result for this game, as the extrinsic positive reward is very sparse. On Private Eye RND's performance exceeds that of PPO. On Solaris RND's performance is comparable to that of PPO. 

Next we consider an alternative exploration bonus based on forward dynamics error. There are numerous previous works using such a bonus \citep{schmidhuber_curiosity,stadie2015incentivizing,josh_surprise,pathakICMl17curiosity,burda18largescale}. Fortuitously \citet{burda18largescale} show that training a forward dynamics model in a random feature space typically works as well as any other feature space when used to create an exploration bonus. This means that we can easily implement an apples to apples comparison and change the loss in RND so the predictor network predicts the random features of the next observation given the current observation and action, while holding fixed all other parts of our method such as dual value heads, non-episodic intrinsic returns, normalization schemes etc. This provides an ablation of the prediction problem defining the exploration bonus, while also being representative of a class of prior work using forward dynamics error. Our expectation was that these methods should be fairly similar except where the dynamics-based agent is able to exploit non-determinism in the environment to get intrinsic reward.

Figure \ref{fig:ext_comparison} shows that dynamics-based exploration performs significantly worse than RND with the same CNN policy on Montezuma's Revenge, PrivateEye, and Solaris, and performs similarly on Venture, Pitfall, and Gravitar. By analyzing agent's behavior at convergence we notice that in Montezuma's Revenge the agent oscillates between two rooms. This leads to an irreducibly high prediction error, as the non-determinism of sticky actions makes it impossible to know whether, once the agent is close to crossing a room boundary, making one extra step will result in it staying in the same room, or crossing to the next one. This is a manifestation of the `noisy TV' problem, or aleatoric uncertainty discussed in Section \ref{sec:prediction_error}. Similar behavior \href{https://github.com/openai/random-network-distillation}{emerges} in PrivateEye and Pitfall!. In Table \ref{table:baselines} the final training performance for each algorithm is listed, alongside the state of the art from previous work and average human performance.
\begin{table}[ht]
\centering
\tabcolsep=0.11cm
\begin{tabular}{c | c  c  c  c  c  c} 
            & Gravitar          & Montezuma's Revenge & Pitfall! & PrivateEye           & Solaris & Venture   \\ [0.5ex] 
 \hline
 RND    & \textbf{3,906}    &  \textbf{8,152}               &  -3      &  8,666               &  3,282    &   \textbf{1,859}   \\ 
 PPO    & 3,426              & 2,497                &  0       &  105                 &  3,387     &  0          \\
 Dynamics    & 3,371              & 400                &  0       &  33                 &  3,246     &  1,712          \\
 SOTA       & 2,209\textsuperscript{1}&3,700\textsuperscript{2}&\textbf{0}&\textbf{15,806}\textsuperscript{2}&\textbf{12,380}\textsuperscript{1}& \textbf{1,813}\textsuperscript{3}\\ \hline
 Avg. Human & 3,351          &  4,753              & 6,464    &69,571                & 12,327    &  1,188   \\ [1ex] 
\end{tabular}
\caption{Comparison to baselines results. Final mean performance for various methods. State of the art results taken from: [1] \citep{fortunato2017noisy} [2] \citep{bellemare2016unifying} [3] \citep{horgan2018distributed}}
\label{table:baselines}
\end{table}
\subsection{Qualitative Analysis: Dancing with skulls}
By \href{https://github.com/openai/random-network-distillation}{observing} the RND agent, we notice that frequently once it obtains all the extrinsic rewards that it knows how to obtain reliably (as judged by the extrinsic value function), the agent settles into a pattern of behavior where it keeps interacting with potentially dangerous objects. For instance in Montezuma's Revenge the agent jumps back and forth over a moving skull, moves in between laser gates, and gets on and off disappearing bridges. We also observe similar behavior in Pitfall!. It might be related to the very fact that such dangerous states are difficult to achieve, and hence are rarely represented in agent's past experience compared to safer states.


\section{Related Work}
\textbf{Exploration.} Count-based exploration bonuses are a natural and effective way to do exploration \citep{strehl2008analysis} and a lot of work has studied how to tractably generalize count bonuses to large state spaces \citep{bellemare2016unifying,fu2017ex2,pixelcnncount,tang2016exploration,machado2018count,fox2018dora}.

Another class of exploration methods rely on errors in predicting dynamics \citep{schmidhuber_curiosity,stadie2015incentivizing,josh_surprise,pathakICMl17curiosity,burda18largescale}. As discussed in Section \ref{sec:rnd}, these methods are subject to the `noisy TV' problem in stochastic or partially-observable environments. This has motivated work on exploration via quantification of uncertainty \citep{still2012information,houthooft2016vime} or prediction improvement measures \citep{schmidhuber1991curious,oudeyer2007intrinsic,lopes2012exploration,josh_surprise}.

Other methods of exploration include adversarial self-play \citep{sukhbaatar2017intrinsic}, maximizing empowerment \citep{gregor2017variational}, parameter noise \citep{plappert2017parameter, fortunato2017noisy}, identifying diverse policies \citep{diyn, achiam2018variational}, and using ensembles of value functions \citep{osband2018randomized,osband2016deep,chen2017ucb}.

\textbf{Montezuma's Revenge.} Early neural-network based reinforcement learning algorithms that were successful on a significant portion of Atari games \citep{dqn,a3c,hessel2017rainbow} failed to make meaningful progress on Montezuma's Revenge, not finding a way out of the first room reliably. This is not necessarily a failure of exploration, as even a random agent finds the key in the first room once every few hundred thousand steps, and escapes the first room every few million steps. Indeed, a mean return of about 2,500 can be reliably achieved without special exploration methods \citep{horgan2018distributed,espeholt2018impala,oh2018self}.

Combining DQN with a pseudo-count exploration bonus \cite{bellemare2016unifying} set a new state of the art performance, exploring 15 rooms and getting best return of 6,600. Since then a number of other works have achieved similar performance \citep{o2017uncertainty,neuralcount,machado2018count,osband2018randomized}, without exceeding it.

Special access to the underlying RAM state can also be used to improve exploration by using it to hand-craft exploration bonuses \citep{kulkarni2016hierarchical,tang2016exploration,stanton2018deep}. Even with such access previous work achieves performance inferior to average human performance.

Expert demonstrations can be used effectively to simplify the exploration problem in Montezuma's Revenge, and a number of works \citep{salimans2018mz, pohlen2018observe,aytar2018playing,garmulewicz2018expert} have achieved performance comparable to or better than that of human experts. Learning from expert demonstrations benefits from the game's determinism. The suggested training method \citep{machado2017revisiting} to prevent an agent from simply memorizing the correct sequence of actions is to use sticky actions (i.e. randomly repeating previous action) has not been used in these works. In this work we use sticky actions and thus don't rely on determinism.

\textbf{Random features.} Features of randomly initialized neural networks have been extensively studied in the context of supervised learning \citep{rahimi2008random, saxe2011random, jarrett2009best, yang2015deep}. More recently they have been used in the context of exploration \citep{osband2018randomized, burda18largescale}. The work \cite{osband2018randomized} provides motivation for random network distillation as discussed in Section \ref{sec:rnd}.

\textbf{Vectorized value functions.} \cite{pong2018temporal} find that a vectorized value function (with coordinates corresponding to additive factors of the reward) improves their method. \cite{bellemare2017distributional} parametrize the value as a linear combination of value heads that estimate probabilities of discretized returns. However the Bellman backup equation used there is not itself vectorized.

\section{Discussion}
This paper introduced an exploration method based on random network distillation and experimentally showed that the method is capable of performing directed exploration on several Atari games with very sparse rewards. These experiments suggest that progress on hard exploration games is possible with relatively simple generic methods, especially when applied at scale. They also suggest that methods that are able to treat the stream of intrinsic rewards separately from the stream of extrinsic rewards (for instance by having separate value heads) can benefit from such flexibility.

We find that the RND exploration bonus is sufficient to deal with local exploration, i.e. exploring the consequences of short-term decisions, like whether to interact with a particular object, or avoid it. However global exploration that involves coordinated decisions over long time horizons is  beyond the reach of our method.

To solve the first level of Montezuma's Revenge, the agent must enter a room locked behind two doors. There are four keys and six doors spread throughout the level. Any of the four keys can open any of the six doors, but are consumed in the process. To open the final two doors the agent must therefore forego opening two of the doors that are easier to find and that would immediately reward it for opening them.

To incentivize this behavior the agent should receive enough intrinsic reward for saving the keys to balance the loss of extrinsic reward from using them early on. From our analysis of the RND agent's behavior, it does not get a large enough incentive to try this strategy, and only stumbles upon it rarely.

Solving this and similar problems that require high level exploration is an important direction for future work.

\bibliography{bib}
\bibliographystyle{iclr2019_conference}

\appendix
\section{Appendix}
\subsection{Reinforcement Learning Algorithm}
An exploration bonus can be used with any RL algorithm by modifying the rewards used to train the model (i.e., ). We combine our proposed exploration bonus with a baseline reinforcement learning algorithm PPO \citep{ppo}. PPO is a policy gradient method that we have found to require little tuning for good performance. For algorithmic details see Algorithm \ref{alg:rnd}.
\subsection{RND Pseudo-code}
Algorithm \ref{alg:rnd} gives an overall picture of the RND method. Exact details of the method can be found in the \href{https://github.com/openai/random-network-distillation}{code} accompanying this paper.
\begin{algorithm}[!ht]
    \caption{RND pseudo-code}
    \label{alg:rnd}
    \begin{algorithmic}
        \STATE   number of rollouts
        \STATE  number of optimization steps
        \STATE  length of rollout
        \STATE  number of initial steps for initializing observation normalization 
        \STATE  
        \STATE Sample state 
        \FOR{ {\bfseries to} }
            \STATE sample 
            \STATE sample 
            \STATE Update observation normalization parameters using 
            \STATE t += 1
            
        \ENDFOR
        \FOR{ {\bfseries to} }
            \FOR{ {\bfseries to} }
               \STATE sample 
               \STATE sample 
               \STATE calculate intrinsic reward 
               \STATE add  to optimization batch 
               \STATE Update reward normalization parameters using 
               \STATE t += 1
            \ENDFOR
            \STATE Normalize the intrinsic rewards contained in 
            \STATE Calculate returns  and advantages  for intrinsic reward
            \STATE Calculate returns  and advantages  for extrinsic reward
            \STATE Calculate combined advantages 
            \STATE Update observation normalization parameters using 
            \FOR{ {\bfseries to} }
            \STATE optimize  wrt PPO loss on batch  using Adam
            \STATE optimize  wrt distillation loss on  using Adam
            \ENDFOR
        \ENDFOR
    \end{algorithmic}
    \end{algorithm}
\subsection{Preprocessing details}
\label{sec:proprocessing}
Table \ref{table:preprocessing_env} contains details of how we preprocessed the environment for our experiments. We followed the recommendations in \cite{machado2017revisiting} in using sticky actions in order to make the environments non-deterministic so that memorization of action sequences is not possible. In Table \ref{table:preprocessing_policy} we show additional preprocessing details for the policy and value networks. In Table \ref{table:preprocessing_predictor} we show additional preprocessing details for the predictor and target networks.
\begin{table}[ht]
\centering
\begin{tabular}{c | c} 
 Hyperparameter & Value  \\ [0.5ex] 
 \hline
 Grey-scaling & True  \\ 
 Observation downsampling & (84,84)  \\
 Extrinsic reward clipping &   \\
 Intrinsic reward clipping & False  \\
 Max frames per episode & 18K \\
 Terminal on loss of life & False \\
 Max and skip frames & 4 \\
 Random starts & False \\
 Sticky action probability & 0.25 \\ [1ex] 
\end{tabular}
\caption{Preprocessing details for the environments for all experiments.}
\label{table:preprocessing_env}
\end{table}

\begin{table}
\begin{minipage}[t]{0.48\textwidth}
\centering
\begin{tabular}{c | c} 
 Hyperparameter & Value  \\ [0.5ex] 
 \hline
 Frames stacked & 4  \\
 Observation &  \\ 
 normalization &  \1ex] 
\end{tabular}
\caption{Preprocessing details for target and predictor networks for all experiments.}
\label{table:preprocessing_predictor}
\end{minipage}
\end{table}

\subsection{PPO and RND hyperparameters}
\label{sec:ppornd_hyperparams}
In Table \ref{table:ppo_rnd_hyperparameters} the hyperparameters for the PPO RL algorithm along with any additional hyperparameters used for RND are shown. Complete details for how these hyperparameters are used can be found in the \href{https://github.com/openai/random-network-distillation}{code} accompanying this paper.

\begin{table}[!ht]
\centering
\begin{tabular}{c | c} 
 Hyperparameter & Value  \\ [0.5ex] 
 \hline
 Rollout length & 128  \\
 Total number of rollouts per environment & 30K  \\
 Number of minibatches & 4  \\
 Number of optimization epochs & 4  \\
 Coefficient of extrinsic reward & 2  \\
 Coefficient of intrinsic reward & 1  \\
 Number of parallel environments & 128  \\
 Learning rate &   \\
 Optimization algorithm & Adam (\citet{kingma2014adam})  \\
  & 0.95 \\
 Entropy coefficient & 0.001 \\
 Proportion of experience used for training predictor & 0.25 \\
  & 0.999 \\
  & 0.99 \\
 Clip range &  \\
 Policy architecture & CNN \\
\end{tabular}
\caption{Default hyperparameters for PPO and RND algorithms for experiments where applicable. Any differences to these defaults are detailed in the main text.}
\label{table:ppo_rnd_hyperparameters}
\end{table}

Initial preliminary experiments with RND were run with only 32 parallel environments. We expected that increasing the number of parallel environments would improve performance by allowing the policy to adapt more quickly to transient intrinsic rewards. This effect could have been mitigated however if the predictor network also learned more quickly. To avoid this situation when scaling up from 32 to 128 environments we kept the effective batch size for the predictor network the same by randomly dropping out elements of the batch with keep probability . Similarly in our experiments with 256 and 1,024 environments we dropped experience for the predictor with respective probabilities  and .


\subsection{Architectures}
In this paper we use two policy architectures: an RNN and a CNN. Both contain convolutional encoders identical of those in the standard architecture from \citep{dqn}. The RNN architecture additionally contains GRU \citep{cho2014learning} cells to capture longer contexts. The layer sizes of the policies were chosen so that the number of parameters matches closely. The architectures of the target and predictor networks also have convolutional encoders identical to the ones in \citep{dqn} followed by dense layers. Exact details are given in the \href{https://github.com/openai/random-network-distillation}{code} accompanying this paper.
\subsection{Additional experimental results}
\label{sec:additional_results}


\begin{figure}[htbp]
\centering
\hspace{.02\textwidth}
\begin{minipage}[t]{0.98\linewidth}
\centering
\includegraphics[width=\linewidth]{figures/ae_arxiv.png}
\end{minipage}\par
\vspace*{-5pt}
\hspace{.02\textwidth}
\begin{minipage}[t]{0.98\linewidth}
\caption{Comparison of RND with a CNN policy with  and  with an exploration defined by the reconstruction error of an autoencoder, holding all other choices constant (e.g. using dual value, treating intrinsic return as non-episodic etc). The performance of the autoencoder-based agent is worse than that of RND, but exceeds that of baseline PPO.}
\label{fig:ae}
\end{minipage}\vspace*{-20pt}
\end{figure}



Figure \ref{fig:ae} compares the performance of RND with an identical algorithm, but with the exploration bonus defined as the reconstruction error of an autoencoder. The autoencoding task is similar in nature to the random network distillation, as it also obviates the second (though not necessarily the third) sources of prediction error from section \ref{sec:prediction_error}. The experiment shows that the autoencoding task can also be successfully used for exploration.

Figure \ref{fig:ext_comparison_cnn} compares the performance of RND to PPO and dynamics prediction-based baselines for CNN policies.

\begin{figure}[h!]
\centering
\includegraphics[width=\linewidth]{figures/ext_vs_ext-plus-int_tall_cnn_arxiv.png}
\caption{Mean episodic return of CNN-based policies: RND, dynamics-based exploration method, and PPO with extrinsic reward only on 6 hard exploration Atari games. RND significantly outperforms PPO on Montezuma's Revenge, Private Eye, and Venture.}
\label{fig:ext_comparison_cnn}
\vspace*{-8pt}
\end{figure}
\subsection{Additional Experimental Details}
\label{sec:additional_details}
In Table \ref{table:seeds} we show the number of seeds used for each experiment, indexed by figure.

\begin{table}[!ht]
\centering
\begin{tabular}{c | c} 
 Figure number & Number of seeds  \\ [0.5ex] 
 \hline
 1 & NA  \\
 2 & 10  \\
 3 & 5  \\
 4 & 5  \\
 5 & 10  \\
 6 & 5  \\
 7 & 3  \\
 8 & 5  \\
 9 & 5  \\
\end{tabular}
\caption{The numbers of seeds run for each experiment is shown in the table. The results of each seed are then averaged to provide a mean curve in each figure, and the standard error is used make the shaded region surrounding each curve.}
\label{table:seeds}
\end{table}

\end{document}
