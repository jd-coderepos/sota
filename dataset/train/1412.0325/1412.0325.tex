\documentclass{llncs}
\usepackage[latin2]{inputenc}
\usepackage[english]{babel}
\usepackage[numbers]{natbib}
\usepackage{dsfont, complexity}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{float}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{xcolor}
\usepackage{xspace}
\usepackage{paralist,bold-extra}
\usetikzlibrary{arrows,decorations.markings,patterns,calc, positioning, matrix}
\usepackage{hyperref}
\usepackage[capitalise]{cleveref}

\newtheorem{pr}[theorem]{Problem}
\newtheorem{ex}[theorem]{Example}
\newtheorem{cor}[theorem]{Corollary}
\newtheorem{defi}[theorem]{Definition}
\newtheorem{conj}[theorem]{Conjecture}
\usepackage{algpseudocode}
\usepackage[ruled]{algorithm}

\usepackage{thmtools, mathtools}
\usepackage{thm-restate}

\makeatletter \def\@seccntformat#1{\@ifundefined{#1@cntformat}{\csname the#1\endcsname\quad}  {\csname #1@cntformat\endcsname}}
\let\oldappendix\appendix \renewcommand\appendix{\oldappendix
    \newcommand{\section@cntformat}{\appendixname~\thesection\quad}
}
\makeatother

\newcommand{\OPT}{\textup{OPT}}
\newcommand{\tw}{\operatorname{tw}}
\newcommand{\set}[1]{\left\{#1\right\}} 
\newcommand{\setc}[2]{\left\{#1\right.\ \left|\ #2\right\}}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}

\begin{document}

  \title{Matchings with lower quotas:\\ Algorithms and complexity\thanks{A preliminary version of this paper appeared at the 26th International Symposium on Algorithms and Computation (ISAAC 2015). The authors were supported by the Deutsche Telekom Stiftung, COST Action IC1205 on Computational Social Choice, DFG within project A07 of CRC TRR 154, EPSRC grant EP/K010042/1, DAAD with funds of BMBF and the EU Marie Curie Actions. Part of this work was carried out whilst \'A.~Cseh was visiting the University of Glasgow.}}

\author{
Ashwin Arulselvan\inst{1}\and 
\'{A}gnes Cseh\inst{2}
\and 
Martin Gro{\ss}\inst{3}
\and 
David F. Manlove\inst{4}
\and 
Jannik Matuschke\inst{5}
}

\institute{Department of Management Science, University of Strathclyde, UK\\              \email{ashwin.arulselvan@strath.ac.uk}
           \and
           School of Computer Science, Reykjavik University, Iceland\\ 
           \email{cseh@ru.is}
           \and Institute for Mathematics, TU Berlin, Germany\\
              \email{gross@math.tu-berlin.de}
              \and
           School of Computing Science, University of Glasgow, UK \\ 
           \email{David.Manlove@glasgow.ac.uk}
           \and TUM School of Management, Technische Universit\"{a}t M\"{u}nchen, Germany\\
              \email{jannik.matuschke@tum.de}
}
\date{}
\maketitle

\begin{abstract}
We study a natural generalization of the maximum weight many-to-one matching problem. We are given an undirected bipartite graph  with weights on the edges in , and with lower and upper quotas on the vertices in~. We seek a maximum weight many-to-one matching satisfying two sets of constraints: vertices in  are incident to at most one matching edge, while vertices in  are either unmatched or they are incident to a number of matching edges between their lower and upper quota. This problem, which we call \emph{maximum weight many-to-one matching with lower and upper quotas} ({\sc wmlq}), has applications to the assignment of students to projects within university courses, where there are constraints on the minimum and maximum numbers of students that must be assigned to each project.

In this paper, we provide a comprehensive analysis of the complexity of {\sc wmlq} from the viewpoints of classical polynomial time algorithms, fixed-parameter tractability, as well as approximability. We draw the line between -hard and polynomially tractable instances in terms of degree and quota constraints and provide efficient algorithms to solve the tractable ones. We further show that the problem can be solved in polynomial time for instances with bounded treewidth; however, the corresponding runtime is exponential in the treewidth with the maximum upper quota  as basis, and we prove that this dependence is necessary unless . The approximability of {\sc wmlq} is also discussed: we present an approximation algorithm for the general case with performance guarantee , which is asymptotically best possible unless . Finally, we elaborate on how most of our positive results carry over to matchings in arbitrary graphs with lower quotas.

\end{abstract}


\section{Introduction}

Many university courses involve some element of team-based project work. A set of projects is available for a course and each student submits a subset of projects as acceptable. For each acceptable student--project pair , there is a weight  denoting the \emph{utility} of assigning  to~. The question of whether a given project can run is often contingent on the number of students assigned to it. 
Such quota constraints also arise in various other contexts involving the centralized formation of groups, including organizing team-based activities at a leisure center, opening facilities to serve a community and coordinating rides within car-sharing systems. In these and similar applications, the goal is to maximize the utility of the assigned agents under the assumption that the number of participants for each open activity is within the activity's prescribed limits.

We model this problem using a weighted bipartite graph , where the vertices in  represent \emph{applicants}, while the vertices in  are \emph{posts} they are applying to. So in the above student--project allocation example,  and  represent the students and projects respectively, and  represents the set of acceptable student--project pairs. The edge weights capture the cardinal utilities of an assigned applicant--post pair. Each post has a lower and an upper quota on the number of applicants to be assigned to it, while each applicant can be assigned to at most one post.  In a feasible assignment, a post is either \emph{open} or \emph{closed}: the number of applicants assigned to an open post must lie between its lower and upper quota, whilst a closed post has no assigned applicant. The objective is to find a maximum weight many-to-one matching satisfying all lower and upper quotas. We denote this problem by {\sc wmlq}.

In this paper, we study the computational complexity of {\sc wmlq} from various perspectives.  We begin by defining the problem formally in \cref{sec:probdef}.  Then in \cref{sec:com_rest}, we show that {\sc wmlq} can be solved efficiently if the degree of every post is at most , whereas the problem becomes hard as soon as posts with degree~ are permitted, even when lower and upper quotas are all equal to the degree, and every applicant has a degree of~. Furthermore, we show the tractability of the case of pair projects, i.e., when all upper quotas are at most~2. In \cref{sec:bounded_tw}, we study the fixed parameter tractability of {\sc wmlq}. To this end, we generalize the known dynamic program for maximum independent set with bounded treewidth to \textsc{wmlq}. The running time of our algorithm is exponential in the treewidth of the graph, with , the maximum upper quota of any vertex, as the basis. This yields a fixed-parameter algorithm when parameterized by both the treewidth and . We show that this exponential dependence on the treewidth cannot be completely separated from the remaining input by establishing a -hardness result for {\sc wmlq} parameterized by treewidth. Finally, in \cref{se:approx}, we discuss the approximability of the problem. We show that a simple greedy algorithm yields an approximation guarantee of  for {\sc wmlq} and  in the case of unit edge weights. We complement these results by showing that these approximation factors are asymptotically best possible, unless . We briefly comment on the generalizability our aforementioned results in \cref{sec:many} for matchings in arbitrary graphs with lower quotas.

\subsection{Related work}\label{sec:rWork}

Among various applications of centralized group formation, perhaps the assignment of medical students to hospitals has received the most attention. In this context, as well as others, the underlying model is a bipartite matching problem involving lower and upper quotas. The \emph{Hospitals / Residents problem with Lower Quotas} ({\sc hrlq})~\cite{BFIM10,HIM14} is a variant of {\sc wmlq} where applicants and posts have ordinal preferences over one another, and we seek a \emph{stable matching} of residents to hospitals. Hamada et al.~\cite{HIM14} considered a version of {\sc hrlq} where hospitals cannot be closed, whereas the model of Bir\'o et al.~\cite{BFIM10} permitted hospital closures. Strategyproof mechanisms have also been studied in instances with ordinal preferences and no hospital closures~\cite{FITUY15,GHIKUYY14,GKHIY15}.

The \emph{Student / Project Allocation problem}~\cite[Section 5.6]{Man13} models the assignment of students to projects offered by lecturers subject to upper and lower quota restrictions on projects and lecturers. Several previous papers have considered the case of ordinal preferences involving students and lecturers~\cite{AIM07,IMY12,MO08} but without allowing lower quotas. However two recent papers~\cite{Kam13,MT13} do permit lower quotas together with project closures, both in the absence of lecturer preferences. Monte and Tumennasan~\cite{MT13} considered the case where each student finds every project acceptable, and showed how to modify the classical ``serial dictatorship'' mechanism to find a Pareto optimal matching. Kamiyama~\cite{Kam13} generalized this mechanism to the case where students need not find all projects acceptable, and where there may be additional restrictions on the sets of students that can be matched to certain projects. This paper also permits lower quotas and project closures, but our focus is on cardinal utilities rather than  ordinal preferences.

The unit-weight version of {\sc wmlq} is also closely related to the \emph{-matching problem}~\cite{Cor88,Lov73,Seb93}, a variant of graph factor problems~\cite{Plu07}.  In an instance of the -matching problem, we are given a graph , and a domain of integers is assigned to each vertex. The goal is to find a subgraph  of  such that every vertex has a degree in  that is contained in its domain. Lov\'asz~\cite{Lov72} showed that the problem of deciding whether such a subgraph exists is -complete, even if each domain is either  or~. On the other hand, some cases are tractable.  For example, if for each domain , the complement of  contains no consecutive integers, the problem is polynomially solvable~\cite{Seb93}. 
As observed in~\cite{SS11}, -matchings are closely related to \emph{extended global cardinality constraints} and the authors provided an analysis of the fixed-parameter tractability of a special case of the -matching problem; see~\cref{sec:bounded_tw} for details.

The problem that we study in this paper corresponds to an optimization version of the -matching problem. We consider the special case where  is bipartite and the domain of each applicant vertex is , whilst the domain of each post vertex  is , where  and  denote the lower and upper quotas of  respectively.  Since the empty matching is always feasible in our case, our aim is to find a domain-compatible subgraph  such that the total weight of the edges in  is maximum.

\section{Problem definition}
\label{sec:probdef}
In this section we provide a formal definition of the maximum weight many-to-one matching problem with lower quotas (\textsc{wmlq}).

\paragraph{Basic notation}
Let  be a graph.
For a subset of vertices  we denote by  the set of edges incident to exactly one vertex in . For a vertex , we write , and for a subset of edges  we write .
By  we denote the \emph{neighborhood} of , i.e., the set of vertices that are adjacent to~.
\medskip

In our problem, a set of applicants  and a set of posts  are given.  and  constitute the two vertex sets of an undirected bipartite graph~ with  and  represents the set of acceptable applicant-post pairs. 
Each edge carries a \emph{weight} , representing the utility of the corresponding assignment. The set of posts is equipped with functions  and  such that  for every .  Here  is called the \emph{lower quota} of  and  is called the \emph{upper quota} of .  These functions bound the number of admissible applicants for the post (independent of the weight of the corresponding edges). Furthermore, every applicant can be assigned to at most one post.
Thus, an \emph{assignment} is a subset  of the edges such that  for every applicant  and  for every . With respect to an assignment , a post is said to be \emph{open} if the number of applicants assigned to it is greater than~, and \emph{closed} otherwise. The \emph{size} of an assignment , denoted , is the number of assigned applicants, while the \emph{weight} of , denoted , is the total weight of the edges in , i.e., . The goal is to find an assignment of maximum weight.
 
\begin{remark}
Note that when not allowing closed posts, the problem immediately becomes tractable. It is easy to see this in the unweighted case as any algorithm for maximum flow with lower capacities can be used to determine an optimal solution in polynomial time. Maximum flow with lower capacities can be easily reduced to the classical maximum flow problem. The method can be naturally extended to the weighted case as the flow-based linear program has integral extreme points due to its total unimodularity property.
\end{remark}

\begin{pr}\textsc{wmlq}\ \\
	Input: ; a bipartite graph  with edge weights , lower quotas  and upper quotas .\\
Task: Find an assignment of maximum weight.\\
If  for all , we refer to the problem as \textsc{mlq}.
\label{pr:wmlq}
\end{pr}
 


Some trivial simplification of the instance can be executed right at the start. If  for a post , then  can be replaced by . On the other hand, if , then post  can immediately be deleted, since no feasible solution can satisfy the lower quota condition. Moreover, a post  with  behaves identically to the case that , so we assume that no post  has . From now on we assume that the instances have already been simplified this way.

\section{Degree- and quota-restricted cases}\label{sec:com_rest}
In this section we characterize the complexity of {\sc wmlq} in the presence of upper bounds placed on vertex degrees or the posts' upper quotas.  \cref{sec:degreerest} deals with degree-restricted cases, whilst \cref{sec:quotarest} studies cases involving bounded upper quotas.

\subsection{Degree-restricted cases}
\label{sec:degreerest}
In this subsection we will consider \textsc{wmlq}, the special case of \textsc{wmlq} in which  for all , and  for all . That is, every applicant submits at most  applications and every post receives at most  applications. In order to establish our first result, we reduce the maximum independent set problem (\textsc{mis}) to \textsc{mlq}. In \textsc{mis}, a graph with  vertices and  edges is given and the task is to find an independent vertex set of maximum size. 
\textsc{mis} is not approximable within a factor of~ for any~, unless ~\cite{Zuc07}. The problem remains -complete even for cubic (3-regular) graphs~\cite{AK00}.

\begin{theorem}
	\label{th:max_spa_np}
	\textsc{mlq(2,3)} is -complete.
\end{theorem}

\begin{proof}
	First of all, \textsc{mlq(2,3)} is in  because the problem has a -approx\-ima\-tion that can be found in polynomial time (see Theorem~\ref{thm:greedy-approximation}).
	
	To each instance  of \textsc{mis} on cubic graphs we create an instance  of \textsc{mlq} such that there is an independent vertex set of size at least  in  if and only if  admits an assignment of size at least~, yielding an approximation-preserving reduction.  The construction is as follows. To each of the  vertices of graph  in~, a post with upper and lower quota of~3 is created. The  edges of  are represented as  applicants in~. For each applicant ,  and  comprises the two posts representing the two end vertices of the corresponding edge. Since we work on cubic graphs,  for every post~.
	
	First we show that an independent vertex set of size  can be transformed into an assignment of at least  applicants. All we need to do is to open a post with its entire neighborhood assigned to it if and only if the vertex representing that post is in the independent set. Since no two posts stand for adjacent vertices in~, their neighborhoods do not intersect. Moreover, the assignment assigns exactly three applicants to each of the  open posts.
	
	To establish the opposite direction, let us assume that an assignment of cardinality at least  is given. The posts' upper and lower quota are both set to~3, therefore, the assignment involves at least  open posts. No two of them can represent adjacent vertices in , because then the applicant standing for the edge connecting them would be assigned to both posts at the same time.
    
Note that every solution of the constructed instance of \textsc{mlq} serves an integer multiple of 3 applicants. In particular, the \textsc{mlq} instance has a solution serving  applicants if and only if there is an independent set of size  in the \textsc{mis} instance. Hence, this reduction  preserves the approximation factors. Since \textsc{mlq(2,3)} belongs to  and \textsc{mis} is -complete in cubic graphs, it follows that \textsc{mlq(2,3)} is -complete.
\qed
\end{proof}

So far we have established that if  for every applicant  and  for every post , then \textsc{mlq} is -hard. In the following, we also show that these restrictions are the tightest possible. If  for every post , then a maximum weight matching can be found efficiently, regardless of~. Note that the case \textsc{wmlq(1,)} is trivially solvable.

\begin{theorem}
\label{th:infty_2}
	\textsc{wmlq(,2)} is solvable in  time, where .
\end{theorem}

\begin{proof}
	After executing the simplification steps described at the end of \cref{sec:probdef}, we apply two more changes to derive our helper graph~. Firstly, if ,  and , we separate 's two edges, splitting  into two posts with upper quota~1. After this step, all posts with  also have . All remaining vertices are of upper quota~1. Then, we substitute all edge pairs of posts with  with a single edge connecting the two applicants. This edge will carry the weight equal to the sum of the weights of the two deleted edges.
    
    Clearly, any matching in  translates into an assignment of the same weight in  and vice versa. Finding a maximum weight matching in a general graph with  vertices and  edges can be done in  time~\cite{Gab90}, which reduces to  in our case. \qed
\end{proof}

\subsection{Quota-restricted cases}
\label{sec:quotarest}
In this section, we consider restrictions of \textsc{wmlq} with bounded upper quotas. Note that Theorem~\ref{th:max_spa_np} already tells us that the case of  for all posts  is -hard to solve. We will now settle the complexity of the only remaining case, where we have instances with every post  having an arbitrary degree and . This setting models posts that need to be assigned  to none, one or pairs of applicants.



Here we present a solution for \textsc{wmlq} with . Our algorithm is based on -factors of graphs. In the {\em -factor problem}, a graph  and a function  is given. A set of edges  is called an \emph{-factor} if  for every , where , as per our earlier definition, is the degree of  in the graph~. Constructing an -factor of maximum weight in a graph with  vertices and  edges or proving that none exists can be done in  time, where  is the sum of all -values in the graph~\cite{Gab83,Gab90}.

\begin{restatable}{theorem}{restatepairs}
\label{th:u2}
	\textsc{wmlq} with  for every  can be solved in  time, where  and .
\end{restatable}

\begin{proof}

We partition  into  and , where  denotes the set of posts with . For posts in  we can assume that  for every post~. For, a post  with  and  can be transformed into a post with  by giving it two dummy edges with zero weight, allowing us to pick the dummy edges in order to make up for the raised lower quota. 

The graph  of the constructed -factor instance contains the graph  of our \textsc{wmlq} instance, as shown in \cref{fi:ffactor}. We add a dummy post  to  and connect it to every applicant in~. We connect every post  to~. For every post  we add two dummy vertices  and  and a triangle on the vertices  and~. All new edges in  carry zero weight. 

We set ,  for every  and  for the rest of the vertices. In the initial version of our algorithm, we solve a weighted -factor problem for every , and later we will show a slightly modified version of the -factor instance so that it is sufficient to construct only two instances.
    
\begin{figure}[ht]
\centering
\begin{tikzpicture}[scale=1, transform shape]

\tikzstyle{vertex} = [circle, draw=black, fill=black, scale= 0.5]
\tikzstyle{edgelabel} = [rectangle, fill=white]
\definecolor{MyPurple}{RGB}{197,0,205}
\pgfmathsetmacro{\d}{0.7}
\pgfmathsetmacro{\b}{3}



\node[vertex, label=above:] (m_d) at (-2, 3) {};
\node[vertex, label=above:] (m_1) at (0, 3) {};
\node[vertex, label=above:] (m_2) at (2, 3) {};
\node[vertex, label=above:] (m_3) at (4, 3) {};
\node[vertex, label=above:] (m_4) at (6, 3) {};
\node[vertex, label=above:] (m_5) at (8, 3) {};

\node[vertex, label=below:] (w_1) at (-1, 0) {};
\node[vertex, label=below:] (w_2) at (1, 0) {};
\node[vertex, label=below:] (w_3) at (3, 0) {};
\node[vertex, label=below:] (w_4) at (5, 0) {};
\node[vertex, label=below:] (w_5) at (7, 0) {};
\node[vertex, label=below:] (w_6) at (9, 0) {};

\node[vertex, label=above:] (q_11) at () {};
\node[vertex, label=above:] (q_12) at () {};

\node[vertex, label=above:] (q_41) at () {};
\node[vertex, label=above:] (q_42) at () {};

\node[vertex, label=above:] (q_51) at () {};
\node[vertex, label=above:] (q_52) at () {};

\node[vertex, shape=coordinate] (q_21) at () {};
\node[vertex, shape=coordinate] (q_31) at () {};

\draw [very thick, dotted, MyPurple] (m_d) --  (w_1);
\draw [very thick, dotted, MyPurple] (m_d) --  (w_2);
\draw [very thick, dotted, MyPurple] (m_d) --  (w_3);
\draw [very thick, dotted, MyPurple] (m_d) --  (w_4);
\draw [very thick, dotted, MyPurple] (m_d) --  (w_5);
\draw [very thick, dotted, MyPurple] (m_d) --  (w_6);

\draw [very thick, dotted, MyPurple] (q_41) --  (q_42);
\draw [very thick, dotted, MyPurple] (m_4) --  (q_41);
\draw [very thick, dotted, MyPurple] (m_4) --  (q_42);

\draw [very thick, dotted, MyPurple] (q_11) --  (q_12);
\draw [very thick, dotted, MyPurple] (m_1) --  (q_11);
\draw [very thick, dotted, MyPurple] (m_1) --  (q_12);

\draw [very thick, dotted, MyPurple] (q_51) --  (q_52);
\draw [very thick, dotted, MyPurple] (m_5) --  (q_51);
\draw [very thick, dotted, MyPurple] (m_5) --  (q_52);

\draw [thick] (m_1) -- (w_1);
\draw [thick] (m_1) -- (w_2);
\draw [thick] (m_1) -- (w_3);
\draw [thick] (m_2) -- (w_2);
\draw [thick] (m_3) -- (w_3);
\draw [thick] (m_3) -- (w_2);
\draw [thick] (m_4) -- (w_4);
\draw [thick] (m_4) -- (w_6);
\draw [thick] (m_5) -- (w_4);
\draw [thick] (m_5) -- (w_3);
\draw [thick] (m_3) -- (w_4);
\draw [thick] (m_5) -- (w_5);
\draw [thick] (m_5) -- (w_6);

\draw [very thick, dotted, MyPurple] (m_2) to[out=120,in=0, distance=1cm ] (q_21);
\draw [very thick, dotted, MyPurple] (q_21) to[out=180,in=60, distance=1cm ] (m_d);
\draw [very thick, dotted, MyPurple] (m_3) to[out=120,in=0, distance=2cm ] (q_31);
\draw [very thick, dotted, MyPurple] (q_31) to[out=180,in=60, distance=2cm ] (m_d);

\end{tikzpicture}
\caption{The transformation from \textsc{wmlq} to an -factor problem. The solid edges form , while the dotted edges are the added ones, carrying weight~0.  Here,  and .}
\label{fi:ffactor}
\end{figure}

First we show that if there is a feasible assignment  in  so that the number of unmatched applicants and the number of closed posts in  add up to , then it can be extended to an -factor  of the same weight in~. We construct  starting with  and then adding the following edges to it:

\begin{itemize}
 \item  for every applicant  that is unmatched in~;
 \item  and  for every post  that is closed in~;
 \item  for every post  that is open in~;
 \item  for every post  that is closed in~;
\end{itemize}

For all vertices~, it immediately follows from the construction that . The same holds for  as well, because an edge is assigned to it either because an applicant is unmatched or because a post in  is closed and we assumed that these add up to~. 

It is easy to see that if there is an -factor  in , then its restriction to  is a feasible assignment  of the same weight so that the number of unmatched applicants and the number of closed posts in  add up to~. Since every post  is connected to  and , it is either the case that  is open in  or . Regarding posts outside of , we need to show that the two edges incident to them are either both in  or neither of them are in~. Assume without loss of generality that  and  for some . Since  and ,  cannot be an -factor.

So far we have shown that it is sufficient to test   values for , and collect the optimal assignments given by the maximum weight -factors. Comparing the weight of these locally optimal solutions delivers a global optimum. A slight modification on the the graph corresponding to the -factor instance will allow us to solve the problem by constructing just two instances, as against  instances. Similar to the triangles attached to posts in , triangles are added to  as well. The added vertices have -value~1 and the added edges carry weight~0. The number of such triangles hanging on  is~. These triangles can take up all the -value of  if necessary, but by choosing the edge not incident to  they can also allow  to fill up its -value with other edges. Since a triangle either takes up 0 or 2 of 's -value, we need to separate the two different parity cases. Thus, to cover all the  cases for possible values for , in one instance we set  to  and in the other instance .
\qed
\end{proof}











\section{Bounded treewidth graphs}
\label{sec:bounded_tw}

In this section, we investigate \textsc{wmlq} from the point of view of fixed-parameter tractability and analyze how efficiently the problem can be solved for instances with a bounded treewidth.

\paragraph{Fixed-parameter tractability.}
This field of complexity theory is motivated by the fact that in many applications of optimization problems certain input parameters stay small even for large instances. 
A problem, parameterized by a parameter , is fixed-parameter tractable () if there is an algorithm solving it in time , where  is a function,  is a polynomial function, and  is the input size of the instance. Note that this definition not only requires that the problem can be solved in polynomial time for instances where  is bounded by a constant, but also that the dependence of the running time on  is separable from the part depending on the input size. On the other hand, if a problem is shown to be \emph{-hard}, then the latter property can only be fulfilled if , which would imply . For more details on fixed-parameter algorithms see, e.g.,~\cite{Nie06}.

\paragraph{Treewidth.}
In case of {\sc wmlq} we focus on the parameter \emph{treewidth}, which, on an intuitive level, describes the likeness of a graph to a tree.
A \emph{tree decomposition} of graph  consists of a tree whose nodes---also called \emph{bags}---are subsets of~. These must satisfy the following three requirements.
\begin{enumerate}
\item Every vertex of  belongs to at least one bag of the tree.
\item For every edge , there is a bag containing both  and .
\item If a vertex in  occurs in two bags of the tree, then it also occurs in all bags on the unique tree-path connecting them.
\end{enumerate}
The \emph{width} of a tree decomposition with a set of bags  is .
The \emph{treewidth} of a graph , , is the smallest width among all tree decompositions of~. It is well known that a tree decomposition of smallest width can be found by a fixed-parameter algorithm when parameterized by ~\cite{Bod96}.
\medskip

In the following, we show that {\sc wmlq} is fixed-parameter tractable when parameterized simultaneously by the treewidth and , whereas it remains -hard when only parameterized by the treewidth.
A similar study of the fixed-parameter tractability of the related \emph{extended global cardinality constraint problem} (\textsc{egcc}) was conducted in~\cite{SS11}.
\textsc{egcc} corresponds to the special case of the -matching problem where the graph is bipartite and on one side of the bipartition all vertices have the domain . In contrast with \textsc{wmlq}, \textsc{egcc} is a feasibility problem (note that the feasibility version of \textsc{wmlq} is trivial, as the empty assignment is always feasible).
 The authors of~\cite{SS11} provided a fixed-parameter algorithm for \textsc{egcc} when parameterized simultaneously by the treewidth of the graph and the maximum domain size, and they showed that the problem is -hard when only parameterized by the treewidth. These results mirror our results for \textsc{wmlq}, and indeed both our FPT-algorithm for \textsc{wmlq} and the one in~\cite{SS11} are extensions of the same classic dynamic program for the underlying maximum independent set problem. However, our hardness result uses a completely different reduction than the one in~\cite{SS11}. The latter makes heavy use of the fact that the domains can be arbitrary sets, whereas in \textsc{wmlq}, we are confined to intervals.

\subsection{Algorithm for bounded treewidth graphs}

We will now describe an algorithm for solving \textsc{wmlq} in polynomial time for graphs with constant treewidth. The algorithm is a dynamic program that inductively computes a set of partial solutions for each bag of the tree decomposition. We will show how to obtain these solutions for a bag from the solutions of the children of that bag by a sequence of lemmas. Before we state these lemmas, we need to introduce a few more concepts.

\paragraph{Nice tree decomposition.}
For every tree decomposition with a specific treewidth, a \emph{nice tree decomposition}
of the same treewidth can be found in linear time~\cite{Klo94}. A nice tree decomposition
is characterized by an exclusive composition of the following four kinds of bags:
\begin{itemize}
\item leaf bag:  and  has no child;
\item introduce bag:  has exactly one child , so that  and ;
\item forget bag:  has exactly one child , so that  and ;
\item join bag:  has exactly two children  and , so that .
\end{itemize}
We will henceforth assume we are given such a nice tree decomposition.



\paragraph{Basic notation.}
For ease of exposition, we will define  for all . Furthermore, throughout this section we will deal with vectors  for some . We define the notion of extension and restriction of such a vector .
For  and  define  as the \emph{restriction} of  to , i.e.,  and  for all . For  and  let further  be the \emph{extension} of  to  defined by  for all  and . 
For a set of edges  we define  by , for all .
We will also use the standard notation  for the set of edges with both endpoints in .

\paragraph{Assignment vectors.}
For any bag , let  denote the set of vertices contained in the union of bags present in the subtree rooted at~. We will define a graph  where . A \emph{partial assignment} for bag  is an assignment  of  such that  or  for all . Note that this definition allows applicants and posts in  to be assigned arbitrarily often and that by definition of , no vertex in  is assigned to another vertex in~. An \emph{assignment vector} for bag  is a vector . We say a partial assignment  for  \emph{agrees} with an assignment vector , if  for all .
For every bag  and every , let  be the set of partial assignments for  that agree with  and let 

denote the optimal value of any assignment that agrees with  for the graph~ (note that a value of  implies that no partial assignment  agrees with~). We further denote the set of optimal partial assignments agreeing with  by

In the following, we will provide a series of lemmas that reveals how to efficiently obtain an element of  for every  for a bag   (or showing ), assuming such representatives of each set  have already been computed for every child  of  for all .

\begin{lemma}\label{lem:leaf}
	Let  be a leaf bag. Then  and  for any .
\end{lemma}
\begin{proof}
This follows directly from the fact that  for all leaf bags and thus the only element in  cannot be assigned.\qed
\end{proof}

\begin{lemma}\label{lem:introduce}
	Let  be an introduce bag such that  is the only child of  and . Let . Then
	 
\end{lemma}
\begin{proof}
  Note that  by Properties~2 and 3 of a tree decomposition. This implies  and hence the lemma follows.\qed
\end{proof}

\begin{lemma}\label{lem:forget}
	Let  be a forget bag such that  is the unique child of  and  for some . Let . 
	Let  be an optimal solution to
	
	Then  for all . If the optimal solution to [forget] has value , then .
\end{lemma}
\begin{proof}
  Assume  and let . Let \mbox{} and let . Observe that  is a feasible solution to [forget] and that . We conclude that . In particular, this implies that the optimal solution value of [forget] is finite and thus there is some \mbox{}.

  Thus let . Observe that indeed  for all . Furthermore  for all  by feasibility of . Finally, , implying . As , we conclude that indeed .
   \qed
\end{proof}

\begin{lemma}\label{lem:join}
	Let  be a join bag such that  for the two children  of .
	Let . Let  be optimal solutions to
	
	Then  for all .
	If the optimal solution of [join] has value , then .
\end{lemma}
\begin{proof}
  Let  for some . We first observe that  by Properties 2 and 3
  of the tree decomposition and hence . This implies that
  
  Hence .
   
  Now let . Let  and . We observe that  is a feasible solution to [join] and hence
   .\qed
\end{proof}

Finally, we observe that after computing  and the corresponding elements of  for each  for the root bag , an optimal assignment for  can be easily obtained.
\begin{lemma}\label{lem:root}
  Let  be an optimal solution of
  
  Then  is an optimal solution to \textsc{wmlq} for any .
\end{lemma}

\begin{proof}
Let  for some . Note that for , we have  and hence  by the feasibility of~. Furthermore, for , we have  by the feasibility of  for [root]. We conclude that  is indeed a feasible solution to \textsc{wmlq}.

Now let  be any solution to \textsc{wmlq}.
Define  and . Observe that  is a feasible solution to [root] and that further .
We conclude that 

and thus  is indeed an optimal solution to \textsc{wmlq}.\qed
\end{proof}

\begin{restatable}{theorem}{restateThmFPT}
\label{th:bounded_tw}
\textsc{wmlq} can be solved in time , where  is the time needed for computing a tree decomposition of  of width . In particular, {\sc wmlq} can be solved in polynomial time when restricted to instances of bounded treewidth, and {\sc wmlq} parameterized by  is fixed-parameter tractable. 
\end{restatable}

\begin{proof} 
  In order to solve a given \textsc{wmlq} instance, the algorithm starts by computing a nice tree decomposition of~ of width .  Note that  is of the same order for tree decompositions and nice tree decompositions. Using \cref{lem:leaf,lem:introduce,lem:forget,lem:join,lem:root}, we can inductively compute a representative  for every bag  and every , or deduce that . We first observe that , thus only  representatives have to be computed per bag. Furthermore, for each of the above lemmas, the necessary computations to derive an  from representatives of  of children  of  can be done in time . This is obvious for \cref{lem:leaf,lem:introduce}. For \cref{lem:forget,lem:join,lem:root} we observe that the sets of feasible solutions for the corresponding optimization problems [forget], [join], and [root] have size at most ,  , and , respectively (note that without loss of generality we can assume  to be of constant size by introducing at most  additional forget bags). The theorem then follows from the fact that the number of bags is linear.\qed
\end{proof}

\subsection{-hardness for parameterizing by treewidth only}

While our algorithm runs in polynomial time for bounded treewidth, the degree of the polynomial depends on the treewidth and the algorithm only becomes a fixed-parameter algorithm when parameterizing by treewidth and  simultaneously. We will now show by a reduction from \textsc{Minimum Maximum Outdegree} that this dependence is necessary under the assumption that . 

\begin{pr}\textsc{Minimum Maximum Outdegree}\ \\
	Input: A graph , edge weights  encoded in unary and a degree-bound .\\
Task: Find an orientation  of  such that  for all , where  stands for the set of edges oriented so that their tail is~.
\end{pr}

\begin{theorem}[Theorem~5 from~\cite{Sze11}]
  \textsc{Minimum Maximum Outdegree} is -hard when parameterized by treewidth.
\end{theorem}

\newcommand{\edgestartpost}[2]{p_{#1,#2}\xspace}
\newcommand{\edgeendpost}[2]{p_{#1,#2}\xspace}
\newcommand{\nodepost}[1]{p_{#1}\xspace}
\newcommand{\edgestartapp}[3]{a^{#3}_{#1,#2}\xspace}
\newcommand{\edgeendapp}[3]{a^{#3}_{#1,#2}\xspace}
\newcommand{\edgeapp}[1]{z_{#1}\xspace}

\begin{theorem}
  \textsc{mlq} is -hard when parameterized by treewidth, even when restricted to instances where  for every .
\end{theorem}

\begin{proof}
  Given an instance  of \textsc{Minimum Maximum Outdegree}, we construct an instance  of \textsc{mlq} as follows:
  \begin{itemize}
   \item For every vertex  we introduce a post  with lower quota  and upper quota . 
   \item For every edge , we introduce two posts  and  with identical lower and upper quotas of , i.\,e.\,, 
   
   We also add  applicants , 
   which are connected to the posts by the edges 
    as well as  and . This construction is shown in \cref{fi:theorem6}.
  \end{itemize}

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[scale=0.72, transform shape]

\tikzstyle{post} = [circle, draw=black, fill=black, scale= 0.8]
\tikzstyle{applicant} = [circle, draw=black, fill=white, scale= 0.8]
\tikzstyle{edgelabel} = [rectangle, fill=white]
\definecolor{MyPurple}{RGB}{197,0,205}
\pgfmathsetmacro{\d}{0.7}
\pgfmathsetmacro{\b}{3}



\begin{scope}[xshift=12cm, yshift=5cm]
 \node[post, label=below:]  (v) at            (0, 0) {};
 \node[post, label=above:]  (w) at            (1.5, 2) {};
 \node[post, label=below:]  (x) at            (3, 0) {};
 \draw[very thick] (v) -- node[auto] {} node[auto,swap] {} (w) -- node[auto] {} node[auto,swap] {} (x) -- node[auto] {} node[auto,swap] {} (v);
 \node[]  (r) at            (0, 2) {};
\end{scope}

\begin{scope}[xshift=2cm, yshift=6.7cm]
 \node[post,rectangle] (pr) at            (0, 0) {};
 \node[anchor=west] (text) at (pr.east) {\begin{minipage}{4.25cm} post vertex  with lower quota~0 and upper quota \end{minipage}};
 \node[post]  (pc) at   (0, -1) {};
 \node[anchor=west] (text) at (pc.east) {\begin{minipage}{4.25cm} post vertex  with lower quota and upper quota \end{minipage}}; 
 \node[applicant]  (a) at                            (0, -1.75) {};
 \node[anchor=west] (text) at (a.east) {\begin{minipage}{4.25cm} applicant vertex \end{minipage}};  
 \draw[thick] () rectangle ();
\end{scope}


\node[post, rectangle, label=45:]  (v) at            (16, 3) {};
\node[post, rectangle, label=above:]  (w) at            (6, 3) {};
\node[post, rectangle, label=above:]  (x) at            (10, 3) {};

\node[post, label=above:] (ev) at    (2, 3) {};
\node[post, label=above:] (ew) at      (4, 3) {};
\node[applicant, label=below:] (ae_2) at (1, 0) {};
\node[applicant, label=below:] (ae_3) at (2, 0) {};
\node[applicant, label=below:] (ae_1) at            (3, 0) {};
\node[applicant, label=below:] (ae_4) at   (4, 0) {};
\node[applicant, label=below:] (ae_5) at   (5, 0) {};

\node[post, label=above:] (fw) at    (7.5, 3) {};
\node[post, label=above:] (fx) at      (8.5, 3) {};
\node[applicant, label=below:] (af_2) at (7, 0) {};
\node[applicant, label=below:] (af_1) at             (8, 0) {};
\node[applicant, label=below:] (af_3) at   (9, 0) {};

\node[post, label=above:] (gx) at    (13, 3) {};
\node[post, label=above:] (gv) at      (15, 3) {};
\node[applicant, label=below:] (ag_2) at (11, 0) {};
\node[applicant, label=below:] (ag_3) at (12, 0) {};
\node[applicant, label=below:] (ag_4) at (13, 0) {};
\node[applicant, label=below:] (ag_1) at            (14, 0) {};
\node[applicant, label=below:] (ag_5) at   (15, 0) {};
\node[applicant, label=below:] (ag_6) at   (16, 0) {};
\node[applicant, label=below:] (ag_7) at   (17, 0) {};

\draw [very thick] (ae_1) --  (ev);
\draw [very thick] (ae_1) --  (ew);
\draw [very thick] (ae_2) --  (ev);
\draw [very thick] (ae_3) --  (ev);
\draw [very thick] (ae_4) --  (ew);
\draw [very thick] (ae_5) --  (ew);

\draw [very thick] (af_1) --  (fw);
\draw [very thick] (af_1) --  (fx);
\draw [very thick] (af_2) --  (fw);
\draw [very thick] (af_3) --  (fx);

\draw [very thick] (ag_1) --  (gx);
\draw [very thick] (ag_1) --  (gv);
\draw [very thick] (ag_2) --  (gx);
\draw [very thick] (ag_3) --  (gx);
\draw [very thick] (ag_4) --  (gx);
\draw [very thick] (ag_5) --  (gv);
\draw [very thick] (ag_6) --  (gv);
\draw [very thick] (ag_7) --  (gv);

\draw [very thick] (af_3) --  (x);
\draw [very thick] (ag_2) --  (x);
\draw [very thick] (ag_3) --  (x);
\draw [very thick] (ag_4) --  (x);
\draw [very thick] (ae_2) -- ++(0,4) -| (v.25);
\draw [very thick] (ae_3) -- ++(1,3.8) -| (v);
\draw [very thick] (ag_5) --  (v);
\draw [very thick] (ag_6) --  (v);
\draw [very thick] (ag_7) --  (v);
\draw [very thick] (af_2) --  (w);
\draw [very thick] (ae_4) --  (w);
\draw [very thick] (ae_5) --  (w);



\end{tikzpicture}
\caption{The transformation of the \textsc{Minimum Maximum Outdegree} instance in the upper right corner to a \textsc{mlq} instance. The numbers on the edges of the \textsc{Minimum Maximum Outdegree} instance are the edge weights.}
\label{fi:theorem6}
\end{figure}

  We show that the constructed instance has a solution serving all applicants if and only if the \textsc{Minimum Maximum Outdegree} instance has an orientation respecting the bound on the weighted outdegree. 
  
  First assume there is an orientation  of  with maximum weighted outdegree at most~. Then consider the assignment that assigns for every oriented edge  the  applicants  to  and the  applicants  and  to~. As the weighted outdegree of vertex  is at most , every post  gets assigned at most  applicants.
  
  Now assume  is a feasible assignment of applicants to posts serving every applicant. In particular, for every edge , applicant  is assigned to either  or  and exactly one of these two posts is open because the lower bound of  can only be met if  is assigned to the respective post. If  is open then all  applicants  are assigned to  and none of the applicants  is assigned to , and vice versa if  is open. Consider the orientation obtained by orienting every edge  from  to  if and only if  is open. By the above observations, the weighted outdegree of vertex  corresponds to the number of applicants assigned to post , which is at most~.
  
  Finally, note that  can be constructed in time polynomial in the input size of the \textsc{Minimum Maximum Outdegree} instance as the weights are encoded in unary there. Furthermore, the treewidth of  is at most . To see this, start with a tree decomposition of  and identify each vertex  with the corresponding post~. For every edge , there is a bag  with . We add the new bag  as a child to~. We further add the bags ,  and  for  as children to~. Observe that the tree of bags generated by this construction is a tree decomposition. Furthermore, since we did not increase the size of any of the existing bags and added only bags of size at most , the treewidth of  is at most .\qed
\end{proof}

\section{Approximation}
\label{se:approx}
Having established the hardness of \textsc{wmlq} even for very restricted instances in Theorem~\ref{th:max_spa_np}, we turn our attention towards approximability. In this section, we give an approximation algorithm and corresponding inapproximability bounds expressed in terms of  and upper quotas in the graph.

The method, which is described formally in Algorithm~\ref{al:greedy}, is a simple greedy algorithm. We say a post  is \emph{admissible} if it is not yet open and . The algorithm iteratively opens an admissible post maximizing the assignable weight, i.e., it finds a post  and a set  of applicants in its neighborhood  with  such that  is maximized among all such  pairs. It then removes the assigned applicants from the graph (potentially rendering some posts inadmissible) and re-iterates until no admissible post is~left.

\begin{algorithm}[h]
\caption{Greedy algorithm for \textsc{wmlq}}
\label{al:greedy}
\begin{algorithmic}
\State Initialize .
\State Initialize .
\While{}
    \State Find a pair  and  with  such that  is maximized among all such pairs. 
    \State Open  and assign all applicants in  to it.
    \State Remove  from  and remove the elements of  from .
    \For{ with }
    	\State Remove  from .
    \EndFor
\EndWhile
\end{algorithmic}
\end{algorithm}

\begin{remark}
As an alternative to Algorithm~\ref{al:greedy}, one could use a reduction from \textsc{wmlq} to the set packing problem. The elements in the universe of the set packing problem would be . For each post  and for each subset , such that , we create a set  for the set packing instance. A feasible set packing then corresponds to a feasible assignment of the same weight. However, if the difference between 's upper and lower quota is not bounded by a constant, this would create an exponential-sized input for the set packing problem and we could only employ an oracle-based algorithm known for the set packing problem to solve \textsc{wmlq}. The greedy algorithm known for the set packing problem~\cite{CH01} can be made to work in a fashion similar to the algorithm presented above.
\end{remark}

In the following we give a tight analysis of the algorithm, establishing approximation guarantees in terms of the number of posts , the number of applicants , and the maximum upper quota  over all posts. We also provide two examples that show that our analysis of the greedy algorithm is tight for each of the described approximation factors. We further show that the approximation ratios given above for \textsc{wmlq} are almost tight from the point of view of complexity theory.

\begin{restatable}{theorem}{restategreedypos}\label{thm:greedy-approximation}
  Algorithm~\ref{al:greedy} is an -approximation algorithm for \textsc{wmlq} with \linebreak \mbox{}. Furthermore, for \textsc{mlq}, Algorithm~\ref{al:greedy} is a -approximation algorithm. It can be implemented to run in time .
\end{restatable}

\begin{proof}
Let  be the posts chosen by the algorithm and let  be the corresponding sets of applicants. Furthermore, consider an optimal solution of weight~, consisting of open posts  and the corresponding sets of applicants  assigned to those posts.

We first observe that the first two approximation ratios of  and  are already achieved by the initial selection of  and  chosen in the first round of the algorithm. For every~\mbox{}, post  is an admissible post in the first iteration of the algorithm. The first iteration's choice of the pair~ implies  for every . As the optimal solution opens at most  posts and serves at most  applicants, we deduce that~.

We now turn our attention to the remaining approximation guarantees, which are  for \textsc{wmlq} and  for \textsc{mlq}. For every , let  denote the first iteration of the algorithm such that  or . This is the first iteration in which post  is opened or an applicant assigned to it in the optimal solution becomes assigned. Note that such an iteration exists, because  is not admissible after the termination of the algorithm. Furthermore, observe that , because the pair  was a valid choice for the algorithm in iteration . Now for iteration  define  and observe that , because  can only contain one index~ with , and all other  must have  (where the sets  are disjoint). We conclude that


Note that  and therefore  proving the third approximation guarantee. Now consider the unit-weight \textsc{mlq} case and define . If , then . Therefore assume .
Note that in this case, the above inequalities imply , proving the improved approximation guarantee for \textsc{mlq}.

We now turn to proving the bound on the running time. We will describe how to implement the search for the greedy choice of the pair  in each iteration efficiently using a heap data structure. Initially, for every post , we sort the applicants in its neighborhood by non-increasing order of . This takes time at most  as the total number of entries to sort is . We then introduce a heap containing all admissible posts, and associate with each post  the total weight of the first  edges in its neighborhood list. 
Note that these entries can be easily kept up to date whenever the algorithm opens a post and assigns applicants to it: In the list of every other post  we simply replace the assigned applicants with the first not-yet-assigned entry in the list (or we remove the post if less than  applicants are available). As every edge in the graph can only trigger one such replacement, only  updates can occur and each of these requires  time for reinserting the post at the proper place in the heap. Now, in each iteration of the algorithm, the optimal pair  can be found by retrieving the maximum element from the heap. This happens at most  times and requires  time in each step. \qed
\end{proof}

\begin{ex}
The following two examples show that our analysis of the greedy algorithm is (asymptotically) tight for each of the described approximation factors.

\begin{itemize}
  \item[(a)] The bounds  and  are tight, and  is asymptotically tight:
  
  Consider an instance of \textsc{mlq} with  posts  and  applicants . Let  for . Each applicant  applies to post , and if , additionally to post .
   For the greedy algorithm, opening post  and assigning applicants  to it is a valid choice in its first iteration, after which no further posts are admissible. Thus, it only assigns  applicants in total. The optimal solution, however, can assign all  applicants by assigning applicants  to  for each . Therefore, the greedy algorithm cannot achieve an approximation factor better than  on this family of instances, for which , , and .
   
  \item[(b)] The bound  is tight:
  
  To see that the approximation ratio of  is  tight for \textsc{wmlq} consider the following instance with  posts  and  applicants . Let  and  for every . Every applicant applies for every post, and  for every  but  for every  for some arbitrarily small . In its first iteration, the greedy algorithm might choose to open post  and assign all applicants to it. This solution accumulates a weight of , while the weight of the optimal solution is .
  \end{itemize}
\end{ex}

\begin{restatable}{theorem}{restategreedyneg}
\label{th:inappr}
	\textsc{mlq} is not approximable within a factor of  or  or~ for any~, unless , even when restricting to instances where  for every  and  for every .
\end{restatable}

\begin{proof}
	Once again we use the maximum independent vertex set problem. Given an instance of \textsc{mis} on a graph  with  and , we create an \textsc{mlq} instance with  posts , post  corresponding to vertex . We also introduce  applicants as follows. Initially, we introduce  applicants  applying for each post . Then, for every edge , we merge the applicants  and , obtaining a single applicant applying for both  and . Furthermore, we set  for every post. This construction is shown in \cref{fi:theorem9}.

\begin{figure}[htbp]
 \centering
\begin{tikzpicture}
\tikzstyle{post} = [circle, draw=black, fill=black, scale= 0.8]
\tikzstyle{applicant} = [circle, draw=black, fill=white, scale= 0.8, align=center]
\begin{scope}[xshift=-3cm, yshift=8cm]
 \node[applicant]  (v1) at (0:1) {};
 \node[applicant]  (v2) at (72:1) {};
 \node[applicant]  (v3) at (144:1) {};
 \node[applicant]  (v4) at (216:1) {};
 \node[applicant]  (v5) at (288:1) {};
 \draw[very thick] (v1) -- (v2) -- (v3) -- (v4)-- (v5) -- (v1);
\end{scope}

\begin{scope}[xshift=0cm, yshift=8.25cm]
 \node[post]  (pc) at   (0, 0) {};
 \node[anchor=west] (text3) at (pc.east) {\begin{minipage}{4.25cm} post vertex  with lower quota and upper quota \end{minipage}}; 
 \node[applicant]  (a) at                            (0, -0.75) {};
 \node[anchor=west] (text2) at (a.east) {\begin{minipage}{4.25cm} applicant vertex \end{minipage}};  
 \draw[thick] () rectangle ();
\end{scope}

\begin{scope}[xshift=0cm, yshift=1.7cm, every node/.style={anchor=center, text depth=.4ex,text height=2ex,text width=1.3em}, scale=0.8]
 \matrix (A) [matrix of math nodes, nodes = {draw,circle}, column 1/.style={nodes={fill=black,text=white,align=center}},row sep=10mm, column sep=6 mm] 
  { p_1 & a_{1,1} & a_{1,2} & a_{1,3} & a_{1,4} & a_{1,5}\\
    p_2 &         & a_{2,2} & a_{2,3} & a_{2,4} & a_{2,5}\\
    p_3 & a_{3,1} &         & a_{3,3} & a_{3,4} & a_{3,5}\\
    p_4 & a_{4,1} & a_{4,2} &         & a_{4,4} & a_{4,5}\\
    p_5 &         & a_{5,2} & a_{5,3} &         & a_{5,5}\\
  };


\draw[thick] (A-1-1) -- (A-1-2);
  \draw[thick] (A-1-1.45) -- ++ (0.50,0.4) -| (A-1-3);
  \draw[thick] (A-1-1.60) -- ++ (0.33,0.6) -| (A-1-4);
  \draw[thick] (A-1-1.75) -- ++ (0.16,0.8) -| (A-1-5);
  \draw[thick] (A-1-1.90) -- ++ (0.00,1.0) -| (A-1-6);
  \draw[thick] (A-2-1) -- (A-2-1 -| A-1-2) -- (A-1-3);
  \draw[thick] (A-2-1.45) -- ++ (0.50,0.4) -| (A-2-3);
  \draw[thick] (A-2-1.60) -- ++ (0.33,0.6) -| (A-2-4);
  \draw[thick] (A-2-1.75) -- ++ (0.16,0.8) -| (A-2-5);
  \draw[thick] (A-2-1.90) -- ++ (0.00,1) -| (A-2-6);
  \draw[thick] (A-3-1) -- (A-3-2); \coordinate (X) at (); \coordinate (Y) at (X -| A-2-3);
  \draw[thick] (A-3-1.45) -- ++ (0.50,0.4) -- (Y) -- (A-2-4);
  \draw[thick] (A-3-1.60) -- ++ (0.33,0.6) -| (A-3-4);
  \draw[thick] (A-3-1.75) -- ++ (0.16,0.8) -| (A-3-5);
  \draw[thick] (A-3-1.90) -- ++ (0.00,1) -| (A-3-6);  
  \draw[thick] (A-4-1) -- (A-4-2); \coordinate (X) at (); \coordinate (Y) at (X -| A-3-4);
  \draw[thick] (A-4-1.45) -- ++ (0.50,0.4) -| (A-4-3);
  \draw[thick] (A-4-1.60) -- ++ (0.33,0.6) -- (Y) -- (A-3-5);
  \draw[thick] (A-4-1.75) -- ++ (0.16,0.8) -| (A-4-5);
  \draw[thick] (A-4-1.90) -- ++ (0.00,1) -| (A-4-6);  
  \draw[thick] (A-5-1) -- (A-5-1 -| A-1-2) -- ++(0,-0.7) -- ++(8.5,0) |- (A-1-6);
  \coordinate (X) at (); \coordinate (Y) at (X -| A-4-5);
  \draw[thick] (A-5-1.45) -- ++ (0.50,0.4) -| (A-5-3);
  \draw[thick] (A-5-1.60) -- ++ (0.33,0.6) -| (A-5-4);
  \draw[thick] (A-5-1.75) -- ++ (0.16,0.8) -- (Y) -- (A-4-6);
  \draw[thick] (A-5-1.90) -- ++ (0.00,1) -| (A-5-6);  
  \end{scope}
\end{tikzpicture}
\caption{The transformation of the \textsc{mis} instance in the upper left corner to a \textsc{mlq} instance.}
\label{fi:theorem9}
\end{figure}

	Note that due to the choice of upper and lower bounds, any open post must be assigned to all the applicants in its neighborhood. Thus, a solution to the \textsc{wmlq} instance is feasible if and only if  for all open posts  and  with , which is equivalent to  and  not being adjacent in  by construction of the instance. Therefore, the \textsc{mlq} instance has a feasible solution opening  posts (and thus serving  applicants) if and only if there is an independent set of size  in~. We conclude that  for the two instances under consideration.
	
	Note that in the constructed \textsc{mlq} instance, . Therefore any approximation algorithm with a factor better than  or  or  for  yields a solution of the instance that serves at least~ applicants and therefore opens at least  posts, corresponding to an independent set of the same size. By~\cite{Zuc07}, this implies . \qed
\end{proof}

\section{Matchings with lower quotas in general graphs}
\label{sec:many}

Throughout this paper, we focused on many-to-one matchings in bipartite graphs because these fit most applications in the centralized formation of groups that motivated our investigation. A straightforward generalization of {\sc wmlq} to matchings in an arbitrary (not necessarily bipartite) graph  allows \textit{all} vertices of the graph to have lower and upper quotas. 

\begin{pr} \textsc{gwmlq}\ \\
	Input: ; a not necessarily bipartite graph  with edge weights , lower quotas  and upper quotas .\\
Task: Find an assignment of maximum weight.\\
If  for all , we refer to the problem as \textsc{gmlq}.
\end{pr}

One can see this generalization as a variant of the -matching problem (see \cref{sec:rWork}), where each vertex has a domain consisting of 0 and an interval. Clearly, the hardness results derived in the previous sections are valid for {\sc gwmlq} as well. We now briefly argue that the positive results from Sections~\ref{sec:com_rest} and \ref{sec:bounded_tw} carry over to this generalized setting. However, our approximation results do not hold even if  is bipartite and only a single applicant is equipped with lower and upper quotas. In fact, {\sc gwmlq} does not allow for any approximation even in this very restricted case unless .
\smallskip

The two positive results in \cref{sec:com_rest}, namely Theorems~\ref{th:infty_2} and \ref{th:u2}, are applicable to {\sc gwmlq}. Note that \cref{th:infty_2} (bounded degree for all posts) is a special case of \cref{th:u2} (bounded upper quota for all posts).

\begin{theorem}
	 {\sc gwmlq} can be solved in polynomial time when restricted to instances with  for all .
\end{theorem}

\begin{proof}
We will work with the proof of \cref{th:u2}, which requires some simple modifications to fit the case of arbitrary graphs. All we need to do is to add a dummy vertex  to  -- this resembles dummy post  in the proof of \cref{th:u2}. The steps corresponding to a post vertex should now be executed for all vertices of the graph. We can assume there are no vertices with lower quota~0 and upper quota~2 by a similar reasoning given in \cref{th:infty_2}. For every vertex  with , we add two dummy vertices  and  and connect them to each other and~.  Then, the dummy vertex  is connected to vertices with upper quota~1. We finish the construction by adding triangles to  to ensure that only two -factors need to be computed. The arguments in the proof of \cref{th:u2} can now be applied to this -factor instance. \qed
\end{proof}

As for \cref{th:bounded_tw}, the algorithm for bounded treewidth and upper quota carries over to {\sc gwmlq} without any modification. Note that in the proof we never used the bipartiteness of  or that  for the applicants.

\begin{theorem}
	  {\sc gwmlq} can be solved in time , where  is the time needed for computing a tree decomposition of  of width . In particular, {\sc gwmlq} can be solved in polynomial time when restricted to instances of bounded treewidth, and {\sc wmlq} parameterized by  is fixed-parameter tractable.
\end{theorem}

	Finally, we prove that \cref{al:greedy} cannot be generalized even for bipartite {\sc mlq} with lower and upper quotas on both sides.

\begin{theorem}
	It is -hard to decide whether  for an instance of {\sc gmlq}, even if the graph is bipartite and on one side of the bipartition all vertices except for one have unitary upper and lower quota.
\end{theorem}

\begin{proof}
	To every instance of {\sc mis} we construct an instance of {\sc gmlq} so that the {\sc mis} instance admits an independent set of size  if and only if  for the {\sc gmlq} instance. We start with the same {\sc mlq} instance that was constructed from an {\sc mis} instance in the proof of \cref{th:inappr}. The changes are depicted in \cref{fi:theorem11}. A dummy applicant  is added to the graph and connected to all posts. We set  and change  to  for every post .
	
		\begin{figure}[htbp]
 \centering
\begin{tikzpicture}
\tikzstyle{post} = [circle, draw=black, fill=black, scale= 0.7]
\tikzstyle{applicant} = [circle, draw=black, fill=white, scale= 0.7, align=center]
\begin{scope}[xshift=-3cm, yshift=8cm]
 \node[applicant]  (v1) at (0:1) {};
 \node[applicant]  (v2) at (72:1) {};
 \node[applicant]  (v3) at (144:1) {};
 \node[applicant]  (v4) at (216:1) {};
 \node[applicant]  (v5) at (288:1) {};
 \draw[very thick] (v1) -- (v2) -- (v3) -- (v4)-- (v5) -- (v1);
\end{scope}

\begin{scope}[xshift=0cm, yshift=8.65cm]
 \node[post]  (pc) at   (0, 0) {};
 \node[anchor=west] (text3) at (pc.east) {\begin{minipage}{4.25cm} post vertex  with lower quota and upper quota \end{minipage}}; 
 \node[applicant]  (a) at                            (0, -0.75) {};
 \node[anchor=west] (text2) at (a.east) {\begin{minipage}{4.25cm} applicant vertex \end{minipage}};  
	\node[applicant,rectangle]  (a) at                            (0, -1.5) {};
 \node[anchor=west] (text1) at (a.east) {\begin{minipage}{4.25cm} dummy applicant vertex with lower quota and upper quota \end{minipage}};  
 \draw[thick] () rectangle ();
\end{scope}

\begin{scope}[xshift=0cm, yshift=1.2cm, every node/.style={anchor=center, text depth=.4ex,text height=2ex,text width=1.3em}, scale=0.8]
 \matrix (A) [matrix of math nodes, nodes = {draw,circle}, column 1/.style={nodes={fill=black,text=white,align=center}},row sep=10mm, column sep=6 mm] 
  { p_1 & a_{1,1} & a_{1,2} & a_{1,3} & a_{1,4} & a_{1,5}\\
    p_2 &         & a_{2,2} & a_{2,3} & a_{2,4} & a_{2,5}\\
    p_3 & a_{3,1} &         & a_{3,3} & a_{3,4} & a_{3,5}\\
    p_4 & a_{4,1} & a_{4,2} &         & a_{4,4} & a_{4,5}\\
    p_5 &         & a_{5,2} & a_{5,3} &         & a_{5,5}\\
  };
	 \node[applicant, rectangle, text height=2ex,text width=1.4em,inner sep=3mm] (a_d) at () {};
	
	\draw[thick] (a_d) |- (A-1-1);
	\draw[thick] (a_d) -- (A-2-1);
	\draw[thick] (a_d) -- (A-3-1);
	\draw[thick] (a_d) -- (A-4-1);
	\draw[thick] (a_d) |- (A-5-1);
  \draw[thick] (A-1-1) -- (A-1-2);
  \draw[thick] (A-1-1.45) -- ++ (0.50,0.4) -| (A-1-3);
  \draw[thick] (A-1-1.60) -- ++ (0.33,0.6) -| (A-1-4);
  \draw[thick] (A-1-1.75) -- ++ (0.16,0.8) -| (A-1-5);
  \draw[thick] (A-1-1.90) -- ++ (0.00,1.0) -| (A-1-6);
  \draw[thick] (A-2-1) -- (A-2-1 -| A-1-2) -- (A-1-3);
  \draw[thick] (A-2-1.45) -- ++ (0.50,0.4) -| (A-2-3);
  \draw[thick] (A-2-1.60) -- ++ (0.33,0.6) -| (A-2-4);
  \draw[thick] (A-2-1.75) -- ++ (0.16,0.8) -| (A-2-5);
  \draw[thick] (A-2-1.90) -- ++ (0.00,1) -| (A-2-6);
  \draw[thick] (A-3-1) -- (A-3-2); \coordinate (X) at (); \coordinate (Y) at (X -| A-2-3);
  \draw[thick] (A-3-1.45) -- ++ (0.50,0.4) -- (Y) -- (A-2-4);
  \draw[thick] (A-3-1.60) -- ++ (0.33,0.6) -| (A-3-4);
  \draw[thick] (A-3-1.75) -- ++ (0.16,0.8) -| (A-3-5);
  \draw[thick] (A-3-1.90) -- ++ (0.00,1) -| (A-3-6);  
  \draw[thick] (A-4-1) -- (A-4-2); \coordinate (X) at (); \coordinate (Y) at (X -| A-3-4);
  \draw[thick] (A-4-1.45) -- ++ (0.50,0.4) -| (A-4-3);
  \draw[thick] (A-4-1.60) -- ++ (0.33,0.6) -- (Y) -- (A-3-5);
  \draw[thick] (A-4-1.75) -- ++ (0.16,0.8) -| (A-4-5);
  \draw[thick] (A-4-1.90) -- ++ (0.00,1) -| (A-4-6);  
  \draw[thick] (A-5-1) -- (A-5-1 -| A-1-2) -- ++(0,-0.7) -- ++(8.5,0) |- (A-1-6);
  \coordinate (X) at (); \coordinate (Y) at (X -| A-4-5);
  \draw[thick] (A-5-1.45) -- ++ (0.50,0.4) -| (A-5-3);
  \draw[thick] (A-5-1.60) -- ++ (0.33,0.6) -| (A-5-4);
  \draw[thick] (A-5-1.75) -- ++ (0.16,0.8) -- (Y) -- (A-4-6);
  \draw[thick] (A-5-1.90) -- ++ (0.00,1) -| (A-5-6);  
  \end{scope}
\end{tikzpicture}
\caption{The transformation of the \textsc{mis} instance in the upper left corner to a generalized \textsc{mlq} instance.}
\label{fi:theorem11}
\end{figure}
    
    Since every post is adjacent to exactly  applicants, opening a post requires allocating all its applicants to it, including  as well. Thus, opening any post implies allocating  to exactly  posts. These  open posts do not share applicants other than , which is equivalent to the  vertices corresponding to them in the {\sc mis} instance forming an independent set.\qed
\end{proof}

\section{Conclusion}

We discussed the complexity, approximability and fixed-parameter tractability of {\sc wmlq} from various viewpoints such as bounded degree, quota and treewidth.

Further work on the topic might include imposing common quotas on some groups of posts. That is, we may have subsets , where for each  (), ,  has a \emph{common quota} , where , and any assignment  must now satisfy the additional property that . Common quotas can model constraints such as the limited availability of resources required for certain projects -- for example  might correspond to those projects that require access to high-performance computing facilities.

We have seen that {\sc wmlq} as defined in \cref{pr:wmlq} has a natural application in the context of student-project allocation, where the weight on a given edge  corresponds to the utility of student  being assigned to project~. However in many applications students have ordinal preferences over projects. Cardinal utilities can of course follow from these via the use of Borda scores, so we can obtain {\sc wmlq} as before.  But ordinal preferences themselves allow alternative optimality criteria to be formulated. For example we may optimize on the \emph{profile} of a matching , which is a vector whose th position indicates the number of students who obtain their th-choice project in ~\cite{Man13}. A \emph{greedy maximum matching} is a matching whose profile is lexicographically maximum, taken over all maximum cardinality matchings, whilst a \emph{generous maximum matching} is a matching whose reverse profile is lexicographically minimum, taken over all maximum cardinality matchings. There are efficient algorithms to find greedy and generous maximum matchings in the absence of lower quotas~\cite{KIMS15}, but it remains open to extend the positive results in this paper to the setting involving both lower quotas and preferences.

\subsubsection*{Acknowledgements}
We would like to thank Andr\'as Frank and Krist\'of B\'erczi for their observations that led us to \cref{th:u2}.

\bibliographystyle{plain} \bibliography{mybib}
\end{document}