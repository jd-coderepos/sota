

\documentclass[fleqn]{llncs}
\usepackage{pgamd}

\pagestyle{plain}
\raggedbottom
\setlength{\marginparwidth}{64pt}

\title{Programming an Interpreter Using\\ Molecular Dynamics\thanks{This research was partly carried out in the framework of
               the Jacquard-project Symbiosis, which is funded by the
               Netherlands Organisation for Scientific Research (NWO).}}
\author{J.A. Bergstra\inst{1}\fnmsep\inst{2}
        \and
        C.A. Middelburg\inst{1}
       }
\institute{Programming Research Group,
           University of Amsterdam, \\
           P.O.~Box~41882, 1009~DB~Amsterdam, the Netherlands \\
           \and
           Department of Philosophy,
           Utrecht University, \\
           P.O.~Box~80126, 3508~TC~Utrecht, the Netherlands \\
           \email{J.A.Bergstra@uva.nl,C.A.Middelburg@uva.nl}
          }

\begin{document}
\maketitle

\begin{abstract}
\sloppy
\PGA\ (ProGram Algebra) is an algebra of programs which concerns
programs in their simplest form: sequences of instructions.
Molecular dynamics is a simple model of computation developed in the
setting of \PGA, which bears on the use of dynamic data structures in
programming.
We consider the programming of an interpreter for a program notation
that is close to existing assembly languages using \PGA\ with the
primitives of molecular dynamics as basic instructions.
It happens that, although primarily meant for explaining programming
language features relating to the use of dynamic data structures, the
collection of primitives of molecular dynamics in itself is suited to
our programming wants.
\1.5ex]
{\sl 1998 ACM Computing Classification:}
D.1.4, D.3.1, D.3.4, F.1.1, F.3.2.
\end{abstract}

\section{Introduction}
\label{sect-intro}

In this paper, we consider the programming of an interpreter for a
program notation that is close to existing assembly languages using
\PGA\ (ProGram Algebra).
With that we carry on the line of research with which a start was made
in~\cite{BL02a}.
The object pursued with that line of research is the development of a
theoretical understanding of possible forms of sequential programs,
starting from the simplest form of sequential programs, and associated
ways of programming.
The view is taken that sequential programs in the simplest form are
sequences of instructions.
\PGA, an algebra of programs in which programs are looked upon as
sequences of instructions, is taken for the basis of the development
aimed at.
Until now, the research was rather focussed on the development of a
theoretical understanding of possible forms of sequential programs.
The work presented in the current paper is primarily concerned with
programming using the simplest form of sequential programs and molecular
dynamics.

For the programming of the interpreter, we use \PGA\ with the primitives
of molecular dynamics as basic instructions.
Molecular dynamics is a simple model of computation bearing on the use
of dynamic data structures in programming.
In this model, states of computations resemble collections of molecules
composed of atoms and computations take place by means of actions which
transform the structure of molecules like in chemical reactions.
Molecular dynamics has been developed mainly in the setting of \PGA.
The model introduced in the current paper is a small expansion of the
model that was first described informally in~\cite{BB02a} and formally
in~\cite{BM06c}.

In the line of research carried on, the view is taken that the
behaviours exhibited by sequential programs on execution are threads as
considered in \BTA\ (Basic Thread Algebra).\footnote
{In~\cite{BL02a}, basic thread algebra is introduced under the name
 basic polarized process algebra.
 Prompted by the development of thread algebra~\cite{BM04c}, which is a
 design on top of it, basic polarized process algebra has been renamed
 to basic thread algebra.
}
A thread proceeds by doing steps in a sequential fashion.
A thread may do certain steps for having itself affected by some service
or affecting some service.
In the current paper, we will use a generalization of the use mechanism
introduced in~\cite{BM04c} and a complementary mechanism of that
mechanism for such interactions between threads that are behaviours
exhibited by sequential programs on execution and services that deal
with steps that relate to molecular dynamics.
A slightly different generalization of the use mechanism
from~\cite{BM04c} is introduced in~\cite{BM07f} under the name action
transforming thread-service composition.

A hierarchy of program notations rooted in \PGA\ is introduced
in~\cite{BL02a}.
In the current paper, we consider the programming of an interpreter for
one program notation that belongs to this hierarchy.
The program notation in question, called \PGLD\ (ProGramming
Language~D), is a very simple program notation which is close to
existing assembly languages.
The hierarchy also includes a program notation, called \PGLS\
(ProGramming Language for Structured programming), that supports
structured programming by offering a rendering of conditional and loop
constructs instead of (unstructured) jump instructions.
Each \PGLS\ program can be translated into a semantically equivalent
\PGLD\ program.
In~\cite{BM07e}, a variant of \PGLD\ with indirect jump instructions is
introduced.
In the current paper, we show how to adapt the interpreter for \PGLD\ to
the presence of indirect jump instructions.

This paper is organized as follows.
First, we review \BTA, \PGA, and \PGLD\ (Sections~\ref{sect-BTA},
\ref{sect-PGA}, and~\ref{sect-PGLD}).
Next, we extend \BTA\ with the mechanisms for interaction between
threads and services used, introduce a state-based approach to describe
services, and give a state-based description of services for molecular
dynamics (Sections~\ref{sect-TSI}, \ref{sect-service-descr},
and~\ref{sect-MDS}).
Following this, we give \PGA\ programs for creating representations of
\PGLD\ programs by molecules and a \PGA\ program for interpreting those
representations (Sections~\ref{sect-representation}
and~\ref{sect-interpretation}).
After that, we introduce the variant of \PGLD\ with indirect jump
instructions and adapt the above-mentioned \PGA\ programs to the
presence of indirect jump instructions (Sections~\ref{sect-PGLDij}
and~\ref{sect-interpretation-ij}).
Finally, we make some concluding remarks (Section~\ref{sect-concl}).


\section{Basic Thread Algebra}
\label{sect-BTA}

In this section, we review \BTA, a form of process algebra which is
tailored to the description of the behaviour of deterministic sequential
programs under execution.
The behaviours concerned are called \emph{threads}.

In \BTA, it is assumed that there is a fixed but arbitrary finite set of
\emph{basic actions}  with .
We write  for .
The members of  are referred to as \emph{actions}.

The intuition is that each basic action performed by a thread is taken
as a command to be processed by a service provided by the execution
environment of the thread.
The processing of a command may involve a change of state of the service
concerned.
At completion of the processing of the command, the service produces a
reply value.
This reply is either  or  and is returned to the thread
concerned.

Although \BTA\ is one-sorted, we make this sort explicit.
The reason for this is that we will extend \BTA\ with an additional sort
in Section~\ref{sect-TSI}.

The algebraic theory \BTA\ has one sort: the sort  of
\emph{threads}.
To build terms of sort , \BTA\ has the following constants and
operators:
\begin{iteml}
\item
the \emph{deadlock} constant ;
\item
the \emph{termination} constant ;
\item
for each , the binary \emph{postconditional composition}
operator .
\end{iteml}
Terms of sort  are built as usual (see e.g.~\cite{ST99a,Wir90a}).
Throughout the paper, we assume that there are infinitely many variables
of sort , including .

We use infix notation for postconditional composition.
We introduce \emph{action prefixing} as an abbreviation: ,
where  is a term of sort , abbreviates .

Let  and  be closed terms of sort  and .
Then  will perform action , and after that proceed as
 if the processing of  leads to the reply  (called a
positive reply), and proceed as  if the processing of  leads to
the reply  (called a negative reply).
The action  plays a special role.
It is a concrete internal action: performing  will never lead to a
state change and always lead to a positive reply, but notwithstanding
all that its presence matters.

\BTA\ has only one axiom.
This axiom is given in Table~\ref{axioms-BTA}.\begin{table}[!tb]
\caption{Axiom of \BTA}
\label{axioms-BTA}
\begin{eqntbl}
\begin{axcol}
\pcc{x}{\Tau}{y} = \pcc{x}{\Tau}{x}                      & \axiom{T1}
\end{axcol}
\end{eqntbl}
\end{table}
Using the abbreviation introduced above, axiom T1 can be written as
follows: .

Each closed \BTA\ term of sort  denotes a finite thread, i.e.\ a
thread of which the length of the sequences of actions that it can
perform is bounded.
Guarded recursive specifications give rise to infinite threads.

A \emph{guarded recursive specification} over \BTA\ is a set of
recursion equations , where  is a
set of variables of sort  and each  is a term of the form
,  or  with  and  \BTA\ terms of
sort  that contain only variables from .
We write  for the set of all variables that occur on the
left-hand side of an equation in .
We are only interested in models of \BTA\ in which guarded recursive
specifications have unique solutions, such as the projective limit model
of \BTA\ presented in~\cite{BB03a}.
A thread that is the solution of a finite guarded recursive
specification over \BTA\ is called a \emph{finite-state} thread.

We extend \BTA\ with guarded recursion by adding constants for solutions
of guarded recursive specifications and axioms concerning these
additional constants.
For each guarded recursive specification  and each ,
we add a constant of sort  standing for the unique solution of 
for  to the constants of \BTA.
The constant standing for the unique solution of  for  is denoted
by .
Moreover, we add the axioms for guarded recursion given in
Table~\ref{axioms-REC} to \BTA,\begin{table}[!tb]
\caption{Axioms for guarded recursion}
\label{axioms-REC}
\begin{eqntbl}
\begin{saxcol}
\rec{X}{E} = \rec{t_X}{E} & \mif X \!=\! t_X \in E       & \axiom{RDP}
\\
E \Implies X = \rec{X}{E} & \mif X \in \vars(E)          & \axiom{RSP}
\end{saxcol}
\end{eqntbl}
\end{table}
where we write  for  with, for all ,
all occurrences of  in  replaced by .
In this table, ,  and  stand for an arbitrary variable of
sort , an arbitrary \BTA\ term of sort  and an arbitrary
guarded recursive specification over \BTA, respectively.
Side conditions are added to restrict the variables, terms and guarded
recursive specifications for which ,  and  stand.
The equations  for a fixed  express that
the constants  make up a solution of .
The conditional equations  express that this
solution is the only one.

We will use the following abbreviation: , where
, abbreviates .

We will write \BTA+\REC\ for \BTA\ extended with the constants for
solutions of guarded recursive specifications and axioms RDP and RSP.


In~\cite{BM05c}, we show that the threads considered in \BTA+\REC\ can
be viewed as processes that are definable over ACP~\cite{Fok00}.

Closed terms of sort  from the language of \BTA+\REC\ that denote
the same infinite thread cannot always be proved equal by means of the
axioms of \BTA+\REC.
We introduce the approximation induction principle to remedy this.
The approximation induction principle, \AIP\ in short, is based on the
view that two threads are identical if their approximations up to any
finite depth are identical.
The approximation up to depth  of a thread is obtained by cutting it
off after performing a sequence of actions of length .

\AIP\ is the infinitary conditional equation given in
Table~\ref{axioms-AIP}.\begin{table}[!tb]
\caption{Approximation induction principle}
\label{axioms-AIP}
\begin{eqntbl}
\begin{axcol}
\AND{n \geq 0} \proj{n}{x} = \proj{n}{y} \Implies x = y   & \axiom{AIP}
\end{axcol}
\end{eqntbl}
\end{table}
Here, following~\cite{BL02a}, approximation of depth  is phrased in
terms of a unary \emph{projection} operator
.
The axioms for the projection operators are given in
Table~\ref{axioms-proj}.\begin{table}[!tb]
\caption{Axioms for projection operators}
\label{axioms-proj}
\begin{eqntbl}
\begin{axcol}
\proj{0}{x} = \DeadEnd                                   & \axiom{P0} \\
\proj{n+1}{\Stop} = \Stop                                & \axiom{P1} \\
\proj{n+1}{\DeadEnd} = \DeadEnd                          & \axiom{P2} \\
\proj{n+1}{\pcc{x}{a}{y}} =
                       \pcc{\proj{n}{x}}{a}{\proj{n}{y}} & \axiom{P3}
\end{axcol}
\end{eqntbl}
\end{table}
In this table,  stands for an arbitrary member of .

We will write \BTA+\REC+\AIP\ for \BTA+\REC\ extended with the
projection operators and the axioms from Tables~\ref{axioms-AIP}
and~\ref{axioms-proj}.

\section{Program Algebra}
\label{sect-PGA}

In this section, we review \PGA, an algebra of sequential programs based
on the idea that sequential programs are in essence sequences of
instructions.
\PGA\ provides a program notation for finite-state threads.

In \PGA, it is assumed that there is a fixed but arbitrary finite set
 of \emph{basic instructions}.
\PGA\ has the following \emph{primitive instructions}:
\begin{iteml}
\item
for each , a \emph{plain basic instruction} ;
\item
for each , a \emph{positive test instruction} ;
\item
for each , a \emph{negative test instruction} ;
\item
for each , a \emph{forward jump instruction} ;
\item
a \emph{termination instruction} .
\end{iteml}
We write  for the set of all primitive instructions.

The intuition is that the execution of a basic instruction  may
modify a state and produces  or  at its completion.
In the case of a positive test instruction , basic instruction
 is executed and execution proceeds with the next primitive
instruction if  is produced and otherwise the next primitive
instruction is skipped and execution proceeds with the primitive
instruction following the skipped one.
In the case where  is produced and there is not at least one
subsequent primitive instruction and in the case where  is
produced and there are not at least two subsequent primitive
instructions, deadlock occurs.
In the case of a negative test instruction , the role of the
value produced is reversed.
In the case of a plain basic instruction , the value produced is
disregarded: execution always proceeds as if  is produced.
The effect of a forward jump instruction  is that execution
proceeds with the -th next instruction of the program concerned.
If  equals  or the -th next instruction does not exist, then
 results in deadlock.
The effect of the termination instruction  is that execution
terminates.

\PGA\ has the following constants and operators:
\begin{iteml}
\item
for each , an \emph{instruction} constant \,;
\item
the binary \emph{concatenation} operator \,;
\item
the unary \emph{repetition} operator \,.
\end{iteml}
Terms are built as usual.
Throughout the paper, we assume that there are infinitely many
variables, including .

We use infix notation for concatenation and postfix notation for
repetition.

Closed \PGA\ terms are considered to denote programs.
The intuition is that a program is in essence a non-empty, finite or
periodic infinite sequence of primitive instructions.\footnote
{A periodic infinite sequence is an infinite sequence with only finitely
 many subsequences.}
These sequences are called \emph{single pass instruction sequences}
because \PGA\ has been designed to enable single pass execution of
instruction sequences: each instruction can be dropped after it has been
executed.
Programs are considered to be equal if they represent the same single
pass instruction sequence.
The axioms for instruction sequence equivalence are given in
Table~\ref{axioms-PGA}.\begin{table}[!t]
\caption{Axioms of \PGA}
\label{axioms-PGA}
\begin{eqntbl}
\begin{axcol}
(x \conc y) \conc z = x \conc (y \conc z)              & \axiom{PGA1} \\
(x^n)\rep = x\rep                                      & \axiom{PGA2} \\
x\rep \conc y = x\rep                                  & \axiom{PGA3} \\
(x \conc y)\rep = x \conc (y \conc x)\rep              & \axiom{PGA4}
\end{axcol}
\end{eqntbl}
\end{table}
In this table,  stands for an arbitrary natural number greater than
.
For each , the term  is defined by induction on  as
follows:  and .
The \emph{unfolding} equation  is
derivable.
Each closed \PGA\ term is derivably equal to a term in
\emph{canonical form}, i.e.\ a term of the form  or ,
where  and  are closed \PGA\ terms that do not contain the
repetition operator.

Each closed \PGA\ term is considered to denote a program of which the
behaviour is a finite-state thread, taking the set  of basic
instructions for the set  of actions.
The \emph{thread extraction} operator  assigns a thread to
each program.
The thread extraction operator is defined by the equations given in
Table~\ref{axioms-thread-extr} (for ,  and
)\begin{table}[!t]
\caption{Defining equations for thread extraction operator}
\label{axioms-thread-extr}
\begin{eqntbl}
\begin{eqncol}
\extr{a} = a \bapf \DeadEnd \\
\extr{a \conc x} = a \bapf \extr{x} \\
\extr{\ptst{a}} = a \bapf \DeadEnd \\
\extr{\ptst{a} \conc x} =
\pcc{\extr{x}}{a}{\extr{\fjmp{2} \conc x}} \\
\extr{\ntst{a}} = a \bapf \DeadEnd \\
\extr{\ntst{a} \conc x} =
\pcc{\extr{\fjmp{2} \conc x}}{a}{\extr{x}}
\end{eqncol}
\qquad
\begin{eqncol}
\extr{\fjmp{l}} = \DeadEnd \\
\extr{\fjmp{0} \conc x} = \DeadEnd \\
\extr{\fjmp{1} \conc x} = \extr{x} \\
\extr{\fjmp{l+2} \conc u} = \DeadEnd \\
\extr{\fjmp{l+2} \conc u \conc x} = \extr{\fjmp{l+1} \conc x} \\
\extr{\halt} = \Stop \\
\extr{\halt \conc x} = \Stop
\end{eqncol}
\end{eqntbl}
\end{table}
and the rule given in Table~\ref{rule-thread-extr}.\begin{table}[!t]
\caption{Rule for cyclic jump chains}
\label{rule-thread-extr}
\begin{eqntbl}
\begin{eqncol}
x \scongr \fjmp{0} \conc y \Implies \extr{x} = \DeadEnd
\end{eqncol}
\end{eqntbl}
\end{table}
This rule is expressed in terms of the \emph{structural congruence}
predicate , which is defined by the formulas given in
Table~\ref{axioms-scongr} (for  and
).\begin{table}[!t]
\caption{Defining formulas for structural congruence predicate}
\label{axioms-scongr}
\begin{eqntbl}
\begin{eqncol}
\fjmp{n+1} \conc u_1 \conc \ldots \conc u_n \conc \fjmp{0}
\scongr
\fjmp{0} \conc u_1 \conc \ldots \conc u_n \conc \fjmp{0}
\\
\fjmp{n+1} \conc u_1 \conc \ldots \conc u_n \conc \fjmp{m}
\scongr
\fjmp{m+n+1} \conc u_1 \conc \ldots \conc u_n \conc \fjmp{m}
\\
(\fjmp{n+l+1} \conc u_1 \conc \ldots \conc u_n)\rep \scongr
(\fjmp{l} \conc u_1 \conc \ldots \conc u_n)\rep
\\
\fjmp{m+n+l+2} \conc u_1 \conc \ldots \conc u_n \conc
(v_1 \conc \ldots \conc v_{m+1})\rep \scongr {} \\ \hfill
\fjmp{n+l+1} \conc u_1 \conc \ldots \conc u_n \conc
(v_1 \conc \ldots \conc v_{m+1})\rep
\\
x \scongr x
\\
x_1 \scongr y_1 \And x_2 \scongr y_2 \Implies
x_1 \conc x_2 \scongr y_1 \conc y_2 \And
{x_1}\rep \scongr {y_1}\rep
\end{eqncol}
\end{eqntbl}
\end{table}

The equations given in Table~\ref{axioms-thread-extr} do not cover the
case where there is a cyclic chain of forward jumps.
Programs are structural congruent if they are the same after removing
all chains of forward jumps in favour of single jumps.
Because a cyclic chain of forward jumps corresponds to ,
the rule from Table~\ref{rule-thread-extr} can be read as follows:
if  starts with a cyclic chain of forward jumps, then 
equals .
It is easy to see that the thread extraction operator assigns the same
thread to structurally congruent programs.
Therefore, the rule from Table~\ref{rule-thread-extr} can be replaced by
the following generalization:
.

Let  be a finite guarded recursive specification over \BTA, and let
 be a closed \PGA\ term for each .
Let  be the set of equations that results from replacing in  all
occurrences of  by  for each .
If  can be obtained by applications of axioms PGA1--PGA4, the
defining equations for the thread extraction operator and the rule for
cyclic jump chains, then  is the solution of  for .
Such a finite guarded recursive specification can always be found.
Thus, the behaviour of each closed \PGA\ term, is a thread that is
definable by a finite guarded recursive specification over \BTA.
Moreover, each finite guarded recursive specification over \BTA\ can be
translated to a closed \PGA\ term of which the behaviour is the solution
of the finite guarded recursive specification concerned
(cf.\ Section~4 of~\cite{PZ06a}).

Closed \PGA\ terms are loosely called \PGA\ \emph{programs}.
\PGA\ programs in which the repetition operator do not occur
are called \emph{finite} \PGA\ programs.


\section{The Program Notation \PGLD}
\label{sect-PGLD}

In this section, we review a program notation which is rooted in \PGA.
This program notation, called \PGLD, belongs to a hierarchy of program
notations introduced in~\cite{BL02a}.
\PGLD\ is close to existing assembly languages.
It has absolute jump instructions and no explicit termination
instruction.

In \PGLD, like in \PGA, it is assumed that there is a fixed but
arbitrary finite set of \emph{basic instructions} .
Again, the intuition is that the execution of a basic instruction 
may modify a state and produces  or  at its completion.

\PGLD\ has the following primitive instructions:
\begin{itemize}
\item
for each , a \emph{plain basic instruction} ;
\item
for each , a \emph{positive test instruction} ;
\item
for each , a \emph{negative test instruction} ;
\item
for each , a \emph{direct absolute jump instruction}
.
\end{itemize}
\PGLD\ programs have the form , where 
are primitive instructions of \PGLD.

The plain basic instructions, the positive test instructions, and the
negative test instructions are as in \PGA.
The effect of a direct absolute jump instruction  is that
execution proceeds with the -th instruction of the program concerned.
If  is itself the -th instruction, then deadlock occurs.
If  equals  or  is greater than the length of the program, then
termination occurs.

We define the meaning of \PGLD\ programs by means of a function
 from the set of all \PGLD\ programs to the set of all \PGA\
programs.
This function is defined by
\begin{ldispl}
\pgldpga(u_1 \conc \ldots \conc u_k) =
(\psi_1(u_1) \conc \ldots \conc \psi_k(u_k) \conc
 \halt \conc \halt)\rep\;,
\end{ldispl}
where the auxiliary functions  from the set of all primitive
instructions of \PGLD\ to the set of all primitive instructions of \PGA\
are defined as follows ():
\begin{ldispl}
\begin{aceqns}
\psi_j(\ajmp{l}) & = & \fjmp{l-j}       & \mif j \leq l \leq k\;, \\
\psi_j(\ajmp{l}) & = & \fjmp{k+2-(j-l)} & \mif 0   <  l   <  j\;, \\
\psi_j(\ajmp{l}) & = & \halt            & \mif l = 0 \Or l > k\;, \\
\psi_j(u)        & = & u
                    & \mif u\; \mathrm{is\;not\;a\;jump\;instruction}\;.
\end{aceqns}
\end{ldispl}

\sloppy
Let  be a \PGLD\ program.
Then  represents the meaning of  as a \PGA\ program.
The intended behaviour of  is the behaviour of .
That is, the \emph{behaviour} of , written , is
.

We use the phrase \emph{projection semantics} to refer to the approach
to semantics followed in this section.
The meaning function  is called a \emph{projection}.

\section{Threads Interacting with Action Transforming Services}
\label{sect-TSI}

A thread may perform certain actions for having itself affected by some
service or affecting some service.
When processing an action performed by a thread, an action transforming
service affects that thread in one of the following ways:
(i)~by returning a reply value to the thread at completion of the
processing of the action performed by the thread;
(ii)~by turning the processed action into another action.
In this section, we introduce a mechanism that allows for services to
affect threads in either way.
The mechanism is a generalization of the use mechanism introduced
in~\cite{BM04c}.\footnote
{In later papers, the original use mechanism is also called
 thread-service composition.}
We also introduce a complementary mechanism of that generalized use
mechanism and an abstraction mechanism.
The difference between the generalized use mechanism and the
complementary mechanism is a matter of perspective:
the former is concerned with the effect of services on threads and
therefore produces threads, whereas the latter is concerned with the
effect of threads on services and therefore produces services.
The abstraction mechanism serves for concealment of the presence of
internal actions, which arise primarily from the generalized use
mechanism.

We will use the generalized use mechanism and the complementary
mechanism of that mechanism for interactions between threads that are
behaviours exhibited by sequential programs on execution and services
that process actions that relate to molecular dynamics.

It is assumed that there is a fixed but arbitrary finite set of
\emph{foci}  and a fixed but arbitrary finite set of
\emph{methods} .
Each focus plays the role of a name of a service provided by the
execution environment that can be requested to process a command.
Each method plays the role of a command proper.
For the set  of actions, we take the set
.
Performing an action  is taken as making a request to the
service named  to process command .

We introduce yet another sort: the sort  of \emph{services}.
 is considered to stand for the set of all services.
We identify services with pairs , where
 and
,
satisfying the following conditions:
\begin{ldispl}
\Forall{m \in \Meth}{{}}
\\ \quad
 {(\Exists{\alpha \in \seqof{\Meth}}
    {H_1(\alpha \concat \seq{m}) = \Mless} \Implies
   \Forall{\alpha' \in \seqof{\Meth}}
    {H_1(\alpha' \concat \seq{m}) \not\in \set{\True,\False}})}\;,
\eqnsep
\Forall{\alpha \in \neseqof{\Meth},m \in \Meth}
 {(H_1(\alpha) = \Blocked \Implies H_1(\alpha \concat \seq{m}) =
   \Blocked)}\;,
\eqnsep
\Forall{\alpha \in \neseqof{\Meth}}
 {(H_1(\alpha) \neq \Mless \Iff H_2(\alpha) = \Tau)}\;.
\end{ldispl}

Let  be a service, and let  and  be the unique functions
such that .
Then we write  and  for  and ,
respectively.
Given a service  and a method ,
the \emph{derived service} of  after processing ,
written , is defined by
 and
.

A service  can be understood as follows:
\begin{iteml}
\item
if , then the request to process  is
accepted by the service, a positive reply is produced,  is turned into
, and the service proceeds as ;
\item
if , then the request to process  is
accepted by the service, a negative reply is produced,  is turned into
, and the service proceeds as ;
\item
if , then the request to process  is
accepted by the service, no reply is produced,  is turned into
, and the service proceeds as ;
\item
if , then the request to process  is
rejected by the service.
\end{iteml}
The three conditions imposed on services can be paraphrased as follows:
\begin{iteml}
\item
if it is possible that no reply is produced at completion of the
processing of a command, then it is impossible that a positive or
negative reply is produced at completion of the processing of that
command;
\item
after a request to process a command has been rejected, any request to
process a command will be rejected;
\item
a reply is produced at completion of the processing of a command if and
only if the command is turned into .
\end{iteml}

We introduce the following additional constant and operators:
\begin{iteml}
\item
the \emph{divergent service} constant ;
\item
for each , the binary \emph{use} operator
;
\item
for each , the binary \emph{apply} operator
.
\end{iteml}
We use infix notation for use and apply.

 is the unique service  with the property that
 for all .
The operators  and  are
complementary.
Intuitively,  is the thread that results from processing
all actions performed by thread  that are of the form  by the
service .
When an action of the form  performed by thread  is processed by
the service , that action is turned into another action and, if this
action is , postconditional composition is removed in favour of
action prefixing on the basis of the reply value produced.
Intuitively,  is the service that results from
processing all basic actions performed by thread  that are of the
form  by service .
When an action of the form  performed by thread  is processed by
service , that service is changed into .

The axioms for the use and apply operators are given in
Tables~\ref{axioms-use} and~\ref{axioms-apply}.\begin{table}[!t]
\caption{Axioms for use operators}
\label{axioms-use}
\begin{eqntbl}
\begin{saxcol}
\use{\Stop}{f}{H} = \Stop                            & & \axiom{TSU1} \\
\use{\DeadEnd}{f}{H} = \DeadEnd                      & & \axiom{TSU2} \\
\use{\Tau \bapf x}{f}{H} =
                          \Tau \bapf (\use{x}{f}{H}) & & \axiom{TSU3} \\
\use{(\pcc{x}{g.m}{y})}{f}{H} =
\pcc{(\use{x}{f}{H})}{g.m}{(\use{y}{f}{H})}
 & \mif f \neq g                                       & \axiom{TSU4} \\
\use{(\pcc{x}{f.m}{y})}{f}{H} =
\Tau \bapf (\use{x}{f}{\derive{m}H})
                  & \mif \rfunc{H}(\seq{m}) = \True    & \axiom{TSU5} \\
\use{(\pcc{x}{f.m}{y})}{f}{H} =
\Tau \bapf (\use{y}{f}{\derive{m}H})
                  & \mif \rfunc{H}(\seq{m}) = \False   & \axiom{TSU6} \\
\use{(\pcc{x}{f.m}{y})}{f}{H} =
\use{(\pcc{x}{\afunc{H}(\seq{m})}{y})}{f}{\derive{m}H}
& \mif \rfunc{H}(\seq{m}) = \Mless   & \axiom{TSU7} \\
\use{(\pcc{x}{f.m}{y})}{f}{H} = \DeadEnd
                  & \mif \rfunc{H}(\seq{m}) = \Blocked & \axiom{TSU8} \\
\use{(\pcc{x}{f.m}{y})}{f}{\DivServ} = \DeadEnd      & & \axiom{TSU9}
\end{saxcol}
\end{eqntbl}
\end{table}
\begin{table}[!t]
\caption{Axioms for apply operators}
\label{axioms-apply}
\begin{eqntbl}
\begin{saxcol}
\apply{\Stop}{f}{H} = H                              & & \axiom{TSA1} \\
\apply{\DeadEnd}{f}{H} = \DivServ                    & & \axiom{TSA2} \\
\apply{(\Tau \bapf x)}{f}{H} = \apply{x}{f}{H}       & & \axiom{TSA3} \\
\apply{(\pcc{x}{g.m}{y})}{f}{H} = \DivServ
                                       & \mif f \neq g & \axiom{TSA4} \\
\apply{(\pcc{x}{f.m}{y})}{f}{H} = \apply{x}{f}{\derive{m}H}
                  & \mif \rfunc{H}(\seq{m}) = \True    & \axiom{TSA5} \\
\apply{(\pcc{x}{f.m}{y})}{f}{H} = \apply{y}{f}{\derive{m}H}
                  & \mif \rfunc{H}(\seq{m}) = \False   & \axiom{TSA6} \\
\apply{(\pcc{x}{f.m}{y})}{f}{H} =
\apply{(\pcc{x}{\afunc{H}(\seq{m})}{y})}{f}{\derive{m}H}
                  & \mif \rfunc{H}(\seq{m}) = \Mless   & \axiom{TSA7} \\
\apply{(\pcc{x}{f.m}{y})}{f}{H} = \DivServ
                  & \mif \rfunc{H}(\seq{m}) = \Blocked & \axiom{TSA8} \\
\apply{(\pcc{x}{f.m}{y})}{f}{\DivServ} = \DivServ    & & \axiom{TSA9} \\
(\AND{n \geq 0} \apply{\proj{n}{x}}{f}{H} = \DivServ) \Implies
\apply{x}{f}{H} = \DivServ                           & & \axiom{TSA10}
\end{saxcol}
\end{eqntbl}
\end{table}
In these tables,  and  stand for an arbitrary foci from ,
 stands for an arbitrary method from , and  is a variable
of sort .
Axioms TSU3 and TSU4 express that the action  and actions of
the form , where , are not processed.
Axioms TSU5--TSU7 express that a thread is affected by a service
as described above when an action of the form  performed by the
thread is processed by the service.
Axiom TSU8 expresses that deadlock takes place when an action to be
processed is not accepted.
Axiom TSU9 expresses that the divergent service does not accept any
action.
Axiom TSA3 expresses that a service is not affected by a thread when the
action  is performed by the thread and axiom TSA4 expresses that a
service is turned into the divergent service when an action of the form
, where ,  is performed by the thread.
Axioms TSA5--TSA7 express that a service is affected by a thread as
described above when an action of the form  performed by the thread
is processed by the service.
Axiom TSA8 expresses that a service is turned into the divergent service
when an action performed by the thread is not accepted.
Axiom TSA9 expresses that the divergent service is not affected by a
thread when an action of the form  is performed by the thread.

We say that  is a \emph{divergent thread application}
if  for all .
Axiom TSA10 can be read as follows: if  is a divergent
thread application, then it equals .

The use operators introduced in~\cite{BM04c} deals in essence with
services  where  for all
.
For these services, the use operators introduced here coincide with
those use operators.

Let  stand for either \BTA, \BTA+\REC\ or \BTA+\REC+\AIP.
Then we will write  for , taking the set
 for , extended with
the divergent service constant, the use and apply operators, and the
axioms from Tables~\ref{axioms-use} and~\ref{axioms-apply}, with the
exception of axiom TSA10 in the case where  does not stand for
\BTA+\REC+\AIP.

The action  is an internal action whose presence matters.
To conceal its presence in the case where it does not matter after all,
we also introduce the unary \emph{abstraction} operator
.

The axioms for the abstraction operator are given in
Table~\ref{axioms-abstr}.\begin{table}[!t]
\caption{Axiom for abstraction}
\label{axioms-abstr}
\begin{eqntbl}
\begin{axcol}
\abstr(\Stop) = \Stop                                    & \axiom{TT1} \\
\abstr(\DeadEnd) = \DeadEnd                              & \axiom{TT2} \\
\abstr(\pcc{x}{\Tau}{y}) = \abstr(x)                     & \axiom{TT3} \\
\abstr(\pcc{x}{a}{y}) = \pcc{\abstr(x)}{a}{\abstr(y)}    & \axiom{TT4}
\end{axcol}
\end{eqntbl}
\end{table}
In this table,  stands for an arbitrary basic action from .

Abstraction can for instance be appropriate in the case where 
arises from turning actions of an auxiliary nature into  on
use of a service.
An example of this case will occur in Section~\ref{sect-interpretation}.
Unlike the use mechanisms introduced in~\cite{BM04c} and in the current
paper, the use mechanism introduced in~\cite{BP02a} incorporates
abstraction.

Let  stand for either \BTA, \BTA+\REC, \BTA+\REC+\AIP, \BTA+\TSI,
BTA+\REC+\TSI\ or \BTA+\REC+\AIP+\TSI.
Then we will write +\ABSTR\ for  extended with the abstraction
operator and the axioms from Table~\ref{axioms-abstr}.

The equation  is derivable from the
axioms of \BTA+\REC+\linebreak[2]\AIP+\ABSTR.

To simplify matters, from now on the set

is taken as the set  of basic instructions when \PGA\ or \PGLD\
is concerned.
Thereby no real restriction is imposed on the set : in the case
where the cardinality of  equals~, all basic instructions have
the same focus and the set  of methods can be looked upon as the
set  of basic instructions.
We use the convention to omit foci from \PGA\ programs in which all
basic instructions have the same focus.

Strictly speaking, the propositions and theorems presented in this paper
are proved in the algebraic theory obtained by:
(i)~combining \PGA\ with \BTA+\REC+\AIP+\TSI+\ABSTR, resulting in a
theory with three sorts: a sort  of programs, a sort  of
threads, and a sort  of services;
(ii)~extending the result by taking  for an additional
operator from sort  to sort  and taking the semantic
equations and rule defining thread extraction for
additional\linebreak[2] axioms.


\section{State-Based Description of Services}
\label{sect-service-descr}

In this section, we introduce the state-based approach to describe
families of services that will be used in Section~\ref{sect-MDS}.
This approach is similar to the approach to describe state machines
introduced in~\cite{BP02a}.

In this approach, a family of services is described by
\begin{itemize}
\item
a set of states ;
\item
an effect function ;
\item
a yield function
;
\item
an action function
;
\end{itemize}
satisfying the following conditions:
\pagebreak[2]
\begin{ldispl}
\Forall{m \in \Meth}
 {(\Exists{s \in S}{\yld(m,s) = \Mless} \Implies
   \Forall{s' \in S}{\yld(m,s') \not\in \set{\True,\False}})}\;,
\eqnsep
\Exists{s \in S}
 {\Forall{m \in \Meth}
   {{} \\ \quad
    (\yld(m,s) = \Blocked \And
     \Forall{s' \in S}
      {(\yld(m,s') = \Blocked \Implies \eff(m,s') = s)})}}\;,
\eqnsep
\Forall{m \in \Meth,s \in S}
 {(\yld(m,s) \neq \Mless \Iff \act(m,s) = \Tau)}\;.
\end{ldispl}
The set  contains the states in which the services may be, and the
functions ,  and  give, for each method  and state
, the state, reply and action, respectively, that result from
processing  in state .

We define, for each , a cumulative effect function
 in terms of  and  as follows:
\begin{ldispl}
\ceff_s(\emptyseq) = s\;,
\\
\ceff_s(\alpha \concat \seq{m}) = \eff(m,\ceff_s(\alpha))\;.
\end{ldispl}
We define, for each , a service  in terms of ,
 and  as follows:
\begin{ldispl}
\rfunc{H_s}(\alpha \concat \seq{m})  = \yld(m,\ceff_s(\alpha))\;,
\\
\afunc{H_s}(\alpha \concat \seq{m}) = \act(m,\ceff_s(\alpha))\;.
\end{ldispl}
 is called the service with \emph{initial state}  described by
, ,  and .
We say that  is the \emph{family of services}
described by , ,  and .

The conditions that are imposed on , ,  and  imply
that, for each ,  is a service indeed.
It is worth mentioning that ,
, and
.

\section{Services for Molecular Dynamics}
\label{sect-MDS}

In this section, we describe a family of services which concerns
molecular dynamics.
The formal description given here elaborates on an informal description
of molecular dynamics given in~\cite{BB02a}.

The states of molecular dynamics services resemble collections of
molecules composed of atoms and the methods of molecular dynamics
services transform the structure of molecules like in chemical
reactions.
An atom can have \emph{fields} and each of those fields can contain an
atom.
An atom together with the ones it has links to via fields can be viewed
as a submolecule, and a submolecule that is not contained in a larger
submolecule can be viewed as a molecule.
Thus, the collection of molecules that make up a state can be viewed as
a fluid.
By means of methods, new atoms can be created, fields can be added to
and removed from atoms, and the contents of fields of atoms can be
examined and modified.
A few methods use a \emph{spot} to put an atom in or to get an atom
from.
By means of methods, the contents of spots can be compared and modified
as well.
Creating an atom is thought of as turning an element of a given set of
\emph{proto-atoms} into an atom.
If there are no proto-atoms left, then atoms can no longer be created.

It is assumed that a finite set  of \emph{spots} such that
, a total order  on , and a
finite set  of \emph{fields} have been given.
It is further assumed that a countable set  of
\emph{proto-atoms} such that  and a bijection
 have been given.
Although the set of proto-atoms may be infinite, there exists at any
time only a finite number of atoms.
Each of those atoms has only a finite number of fields.
Molecular dynamics services accept the following methods:
\begin{itemize}
\item
for each , a \emph{create atom method} ;
\item
for each , a \emph{set spot method} ;
\item
for each , a \emph{clear spot method} ;
\item
for each ,
an \emph{equality test method} ;
\item
for each ,
an \emph{undefinedness test method} ;
\item
for each  and ,
a \emph{add field method} ;
\item
for each  and ,
a \emph{remove field method} ;
\item
for each  and ,
a \emph{has field method} ;
\item
for each  and ,
a \emph{set field method} ;
\item
for each  and ,
a \emph{get field method} ;
\item
for each ,
a \emph{generate action method} .
\end{itemize}
We write  for the set of all generate action methods and
 for the set of all methods of molecular dynamics services.
It is assumed that .

The states of molecular dynamics services comprise the contents of all
spots, the fields of the existing atoms, and the contents of those
fields.
The methods accepted by molecular dynamics services can be explained as
follows:
\begin{itemize}
\item
:
if an atom can be created, then the contents of spot  becomes a newly
created atom and the reply is ; otherwise, nothing changes and
the reply is ;
\item
:
the contents of spot  becomes the same as the contents of spot 
and the reply is ;
\item
:
the contents of spot  becomes undefined and the reply is ;
\item
:
if the contents of spot  equals the contents of spot , then
nothing changes and the reply is ; otherwise, nothing changes and
the reply is ;
\item
:
if the contents of spot  is undefined, then nothing changes and the
reply is ; otherwise, nothing changes and the reply is ;
\item
:
if the contents of spot  is an atom and  is not yet a field of
that atom, then  is added (with undefined contents) to the fields of
that atom and the reply is ; otherwise, nothing changes and the
reply is ;
\item
:
if the contents of spot  is an atom and  is a field of that atom,
then  is removed from the fields of that atom and the reply is
; otherwise, nothing changes and the reply is ;
\item
:
if the contents of spot  is an atom and  is a field of that atom,
then nothing changes and the reply is ; otherwise, nothing
changes and the reply is ;
\item
:
if the contents of spot  is an atom and  is a field of that atom,
then the contents of that field becomes the same as the contents of spot
 and the reply is ; otherwise, nothing changes and the reply
is ;
\item
:
if the contents of spot  is an atom and  is a field of that atom,
then the contents of spot  becomes the same as the contents of that
field and the reply is ; otherwise, nothing changes and the reply
is ;
\item
:
if the contents of spots  and  are atoms and there exist
 and   such that the contents of spot 
equals the contents of spot  and the contents of spot  equals the
contents of spot , then nothing changes, there is no reply, and
 is turned into  where  and  are the least
 and  with respect to  that satisfy
the conditions formulated above; otherwise,  is
rejected.
\end{itemize}
In the explanation given above, wherever we say that the reply is
 or the reply is , this is meant to imply that the method
concerned is turned into .
Moreover, wherever we say that the contents of a spot or field becomes
the same as the contents of another spot or field, this is meant to
imply that the former contents becomes undefined if the latter contents
is undefined.

Let
\begin{ldispl}
\begin{aeqns}
\nm{SS}  & = & \Spot \to (\PAtom \union \set{\bot})\;,
\eqnsep
\nm{AS}  & = &
\Union{A \in \fsetof{(\PAtom)}}
 (A \to
  \Union{F \in \fsetof{(\Field)}} (F \to (\PAtom \union \set{\bot})))\;,
\eqnsep
\nm{MDS} & = &
\set{\tup{\sigma,\alpha} \in \nm{SS} \x \nm{AS} \where
     \rng(\sigma) \subseteq \dom(\alpha) \union \set{\bot} \And {}
\\ & & \hfill
         \Forall{a \in \dom(\alpha)}
          {\rng(\alpha(a)) \subseteq
           \dom(\alpha) \union \set{\bot}}}\;,
\eqnsep
s        & \in & \nm{MDS}\;.
\end{aeqns}
\end{ldispl}
Then we write  for the service with initial state  described
by , where
, and the functions ,  and 
defined in Tables~\ref{eff-mds}, \ref{yld-mds} and~\ref{act-mds}.\footnote
{We use the following notation for functions:
  for the empty function;
  for the function  with  such that
 ;
  for the function  with 
 such that for all ,\,  if
  and  otherwise;
 and  for the function  with 
 such that for all ,\, .}\begin{table}[!t]
\caption{Effect function for molecular dynamics services}
\label{eff-mds}
\begin{eqntbl}
\begin{axcol}
\eff(\creatom{s},\tup{\sigma,\alpha}) = {} \\ \;\;
\tup{\sigma \owr \maplet{s}{\newatom(\dom(\alpha))},
     \alpha \owr \maplet{\newatom(\dom(\alpha))}{\emptymap}}
 & \mif \newatom(\dom(\alpha)) \neq \bot
\\
\eff(\creatom{s},\tup{\sigma,\alpha}) = \tup{\sigma,\alpha}
 & \mif \newatom(\dom(\alpha)) = \bot
\\
\eff(\setspot{s}{s'},\tup{\sigma,\alpha}) =
\tup{\sigma \owr \maplet{s}{\sigma(s')},\alpha}
\\
\eff(\clrspot{s},\tup{\sigma,\alpha}) =
\tup{\sigma \owr \maplet{s}{\bot},\alpha}
\\
\eff(\equaltst{s}{s'},\tup{\sigma,\alpha}) = \tup{\sigma,\alpha}
\\
\eff(\undeftst{s},\tup{\sigma,\alpha}) = \tup{\sigma,\alpha}
\\
\eff(\addfield{s}{v},\tup{\sigma,\alpha}) = {} \\ \;\;
\tup{\sigma,
     \alpha \owr
     \maplet{\sigma(s)}{\alpha(\sigma(s)) \owr \maplet{v}{\bot}}}
 & \mif \sigma(s) \neq \bot \And v \not\in \dom(\alpha(\sigma(s)))
\\
\eff(\addfield{s}{v},\tup{\sigma,\alpha}) = \tup{\sigma,\alpha}
 & \mif \sigma(s) = \bot \Or v \in \dom(\alpha(\sigma(s)))
\\
\eff(\rmvfield{s}{v},\tup{\sigma,\alpha}) =
\tup{\sigma,
     \alpha \owr
     \maplet{\sigma(s)}{\alpha(\sigma(s)) \dsub \set{v}}}
 & \mif \sigma(s) \neq \bot \And v \in \dom(\alpha(\sigma(s)))
\\
\eff(\rmvfield{s}{v},\tup{\sigma,\alpha}) = \tup{\sigma,\alpha}
 & \mif \sigma(s) = \bot \Or v \not\in \dom(\alpha(\sigma(s)))
\\
\eff(\hasfield{s}{v},\tup{\sigma,\alpha}) = \tup{\sigma,\alpha}
\\
\eff(\setfield{s}{v}{s'},\tup{\sigma,\alpha}) = {} \\ \;\;
\tup{\sigma,
     \alpha \owr
     \maplet
      {\sigma(s)}
      {\alpha(\sigma(s)) \owr \maplet{v}{\sigma(s')}}}
 & \mif \sigma(s) \neq \bot \And v \in \dom(\alpha(\sigma(s)))
\\
\eff(\setfield{s}{v}{s'},\tup{\sigma,\alpha}) = \tup{\sigma,\alpha}
 & \mif \sigma(s) = \bot \Or v \not\in \dom(\alpha(\sigma(s)))
\\
\eff(\getfield{s}{s'}{v},\tup{\sigma,\alpha}) =
\tup{\sigma \owr \maplet{s}{\alpha(\sigma(s'))(v)},\alpha}
 & \mif \sigma(s') \neq \bot \And v \in \dom(\alpha(\sigma(s')))
\\
\eff(\getfield{s}{s'}{v},\tup{\sigma,\alpha}) = \tup{\sigma,\alpha}
 & \mif \sigma(s') = \bot \Or v \not\in \dom(\alpha(\sigma(s')))
\\
\eff(\genact{s}{s'},\tup{\sigma,\alpha}) = \tup{\sigma,\alpha}
 & \mif \gacnd(\sigma,s,s') = \True
\\
\eff(\genact{s}{s'},\tup{\sigma,\alpha}) = \undef
 & \mif \gacnd(\sigma,s,s') = \False
\\
\eff(m,\tup{\sigma,\alpha}) = \undef
 & \mif m \not\in \Meth_\md
\\
\eff(m,\undef) = \undef
\end{axcol}
\end{eqntbl}
\end{table}
\begin{table}[!t]
\caption{Yield function for molecular dynamics services}
\label{yld-mds}
\begin{eqntbl}
\begin{axcol}
\yld(\creatom{s},\tup{\sigma,\alpha}) = \True
 & \mif \newatom(\dom(\alpha)) \neq \bot
\\
\yld(\creatom{s},\tup{\sigma,\alpha}) = \False
 & \mif \newatom(\dom(\alpha)) = \bot
\\
\yld(\setspot{s}{s'},\tup{\sigma,\alpha}) = \True
\\
\yld(\clrspot{s},\tup{\sigma,\alpha}) = \True
\\
\yld(\equaltst{s}{s'},\tup{\sigma,\alpha}) = \True
 & \mif \sigma(s) = \sigma(s')
\\
\yld(\equaltst{s}{s'},\tup{\sigma,\alpha}) = \False
 & \mif \sigma(s) \neq \sigma(s')
\\
\yld(\undeftst{s},\tup{\sigma,\alpha}) = \True
 & \mif \sigma(s) = \bot
\\
\yld(\undeftst{s},\tup{\sigma,\alpha}) = \False
 & \mif \sigma(s) \neq \bot
\\
\yld(\addfield{s}{v},\tup{\sigma,\alpha}) = \True
 & \mif \sigma(s) \neq \bot \And v \not\in \dom(\alpha(\sigma(s)))
\\
\yld(\addfield{s}{v},\tup{\sigma,\alpha}) = \False
 & \mif \sigma(s) = \bot \Or v \in \dom(\alpha(\sigma(s)))
\\
\yld(\rmvfield{s}{v},\tup{\sigma,\alpha}) = \True
 & \mif \sigma(s) \neq \bot \And v \in \dom(\alpha(\sigma(s)))
\\
\yld(\rmvfield{s}{v},\tup{\sigma,\alpha}) = \False
 & \mif \sigma(s) = \bot \Or v \not\in \dom(\alpha(\sigma(s)))
\\
\yld(\hasfield{s}{v},\tup{\sigma,\alpha}) = \True
 & \mif \sigma(s) \neq \bot \And v \in \dom(\alpha(\sigma(s)))
\\
\yld(\hasfield{s}{v},\tup{\sigma,\alpha}) = \False
 & \mif \sigma(s) = \bot \Or v \not\in \dom(\alpha(\sigma(s)))
\\
\yld(\setfield{s}{v}{s'},\tup{\sigma,\alpha}) = \True
 & \mif \sigma(s) \neq \bot \And v \in \dom(\alpha(\sigma(s)))
\\
\yld(\setfield{s}{v}{s'},\tup{\sigma,\alpha}) = \False
 & \mif \sigma(s) = \bot \Or v \not\in \dom(\alpha(\sigma(s)))
\\
\yld(\getfield{s}{s'}{v},\tup{\sigma,\alpha}) = \True
 & \mif \sigma(s') \neq \bot \And v \in \dom(\alpha(\sigma(s')))
\\
\yld(\getfield{s}{s'}{v},\tup{\sigma,\alpha}) = \False
 & \mif \sigma(s') = \bot \Or v \not\in \dom(\alpha(\sigma(s')))
\\
\yld(\genact{s}{s'},\tup{\sigma,\alpha}) = \Mless
 & \mif \gacnd(\sigma,s,s') = \True
\\
\yld(\genact{s}{s'},\tup{\sigma,\alpha}) = \Blocked
 & \mif \gacnd(\sigma,s,s') = \False
\\
\yld(m,\tup{\sigma,\alpha}) = \Blocked
 & \mif m \not\in \Meth_\md
\\
\yld(m,\undef) = \Blocked
\end{axcol}
\end{eqntbl}
\end{table}
\begin{table}[!t]
\caption{Action function for molecular dynamics services}
\label{act-mds}
\begin{eqntbl}
\begin{axcol}
\act(m,\tup{\sigma,\alpha}) = \Tau
 & \mif m \not\in \Meth_\ga
\\
\act(\genact{s}{s'},\tup{\sigma,\alpha}) = \gares(\sigma,s,s')
 & \mif \gacnd(\sigma,s,s') = \True
\\
\act(\genact{s}{s'},\tup{\sigma,\alpha}) = \Tau
 & \mif \gacnd(\sigma,s,s') = \False
\\
\act(m,\undef) = \Tau
\end{axcol}
\end{eqntbl}
\end{table}In these tables, the functions
,
, and
 are used.
These functions are defined as follows:
\begin{ldispl}
\begin{aceqns}
\newatom(A) & = & \proatom(m + 1) & \mif m  <   \card(\PAtom)\;,
\\
\newatom(A) & = & \bot            & \mif m \geq \card(\PAtom)\;,
\end{aceqns}
\end{ldispl}
where ;
\begin{ldispl}
\gacnd(\sigma,s,s') = \True\; \mathsf{iff}
\\ \;\; \sigma(s) \neq \bot \And \sigma(s') \neq \bot \And
        \Exists{f \in \Foci}{\sigma(f) = \sigma(s)} \And
        \Exists{m \in \Meth}{\sigma(m) = \sigma(s')}\;;
\end{ldispl}
\begin{ldispl}
\gares(\sigma,s,s') = f.m\;,
\end{ldispl}
where 
and   .
We write  for the family of services described by , ,
, and .
We write  for the service from this family of which the
initial state is the unique  such that
.

Let , let , let
, and let .
Then  is the contents of spot  if ,
 is a field of atom , and  is the contents of field
 of atom  if .
The contents of spot  is undefined if , and the
contents of field  of atom  is undefined if .
Notice that  is taken for the set of all existing atoms.
Therefore, the contents of each spot, i.e.\ each element of
, must be in  if the contents is defined.
Moreover, for each existing atom , the contents of each of its
fields, i.e.\ each element of , must be in
 if the contents is defined.
Molecular dynamics services get into state  when refusing a
request to process a command.
The molecular dynamics service with initial state  is the same
as the divergent service .
The function  turns proto-atoms into atoms.
After all proto-atoms have been turned into atoms,  yields
.
This can only happen if the number of proto-atoms is finite.
The initial state of  is the unique state in which no
proto-atoms have been turned into atoms yet.

\section{Representing Programs by Molecules}
\label{sect-representation}

In this section, we associate each \PGLD\ program with a \PGA\ program
for constructing a representation of the \PGLD\ program by a molecule.

Let  be a \PGLD\ program in which the foci
 and the methods  occur.
The idea is that:
\begin{iteml}
\item
an atom is created for each of the foci  and the methods
, using the focus or method itself as the spot into
which the atom concerned is brought on its creation, and an atom is
created for each of the instructions ;
\item
each atom that corresponds to an instruction is linked via fields to
other atoms as follows:
\begin{iteml}
\item
if the corresponding instruction is of the form ,  or
, then the atom is linked to the atoms that correspond to
the focus and method concerned and the atoms that correspond to the
instructions with which execution must proceed in the cases of a positive
and a negative reply;
\item
if the corresponding instruction is of the form  and
, then the atom is linked to the atom that corresponds
to the instruction with which execution must proceed, i.e.\ the -th
instruction;
\end{iteml}
\item
to prevent that an exception must be made of the instruction  in
the case where it is of the form ,  or ,
two additional atoms are created that are not linked to other atoms;
\item
the atom that corresponds to the first instruction is brought into spot
.
\end{iteml}
Notice that, if an atom corresponds to an instruction of the form
 and not , then the atom is not linked to
another atom.

We make the assumptions that  and  are disjoint and that
 is infinite.
Under these assumptions, atom creation always leads to a positive reply
and no test instructions are needed in the programs for constructing
representations of \PGLD\ programs.
The first assumption is only made because it permits this
simplification.
The second assumption is primarily made because there will be \PGLD\
programs for which there are no \PGA\ programs for constructing their
representation if  is finite.

We define the \PGA\ programs for constructing representations of \PGLD\
programs by means of a function
 from the set of all \PGLD\ programs to the set of all \PGA\
programs.
This function is defined by
\begin{ldispl}
\begin{aeqns}
\pgldmd(u_1 \conc \ldots \conc u_k) & = &
\creatom{f_1} \conc \ldots \conc \creatom{f_n} \conc
\creatom{m_1} \conc \ldots \conc \creatom{m_{n'}} \conc
\creatom{s_1} \conc \ldots \conc \creatom{s_{k+2}} \conc
{} \\ & &
\rho_1(u_1) \conc \ldots \conc \rho_k(u_k) \conc
{} \\ & &
\addfield{s_{k+1}}{\stopf} \conc \addfield{s_{k+2}}{\stopf} \conc
{} \\ & &
\setspot{s}{s_1} \conc
\halt\;,
\end{aeqns}
\end{ldispl}
where the auxiliary functions  from the set of all primitive
instructions of \PGLD\ to the set of all \PGA\ programs are defined as
follows ():
\begin{ldispl}
\begin{aeqns}
\rho_j(f.m) & = &
\addfield{s_j}{\focusf} \conc \addfield{s_j}{\methodf} \conc
\addfield{s_j}{\posf} \conc \addfield{s_j}{\negf} \conc
{} \\ & &
\setfield{s_j}{\focusf}{f} \conc \setfield{s_j}{\methodf}{m} \conc
\setfield{s_j}{\posf}{s_{j+1}} \conc
\setfield{s_j}{\negf}{s_{j+1}}\;, \\
\rho_j(\ptst{f.m}) & = &
\addfield{s_j}{\focusf} \conc \addfield{s_j}{\methodf} \conc
\addfield{s_j}{\posf} \conc \addfield{s_j}{\negf} \conc
 {} \\ & &
\setfield{s_j}{\focusf}{f} \conc \setfield{s_j}{\methodf}{m} \conc
\setfield{s_j}{\posf}{s_{j+1}} \conc
\setfield{s_j}{\negf}{s_{j+2}}\;, \\
\rho_j(\ntst{f.m}) & = &
\addfield{s_j}{\focusf} \conc \addfield{s_j}{\methodf} \conc
\addfield{s_j}{\posf} \conc \addfield{s_j}{\negf} \conc
 {} \\ & &
\setfield{s_j}{\focusf}{f} \conc \setfield{s_j}{\methodf}{m} \conc
\setfield{s_j}{\posf}{s_{j+2}} \conc
\setfield{s_j}{\negf}{s_{j+1}}\;,
\end{aeqns}
\end{ldispl}
\begin{ldispl}
\begin{aceqns}
\rho_j(\ajmp{l}) \hspace*{.5em} & = &
\addfield{s_j}{\ajmpf} \conc \setfield{s_j}{\ajmpf}{s_l} \quad
 & \mif 1 \leq l \leq k\;, \\
\rho_j(\ajmp{l}) & = & \addfield{s_j}{\stopf}
 & \mif \Not (1 \leq l \leq k)
\end{aceqns}
\end{ldispl}
and
\begin{iteml}
\item
 are the different foci that occur in
;
\item
 are the different methods that occur in
;
\item
.
\end{iteml}
In this definition, the omitted focus is considered to be .

The properties stated in the following proposition show that it is easy
to retrieve the \PGLD\ program  from its representation constructed by
.
\begin{proposition}
\label{prop-representation}
Let  be a \PGLD\ program, and
let  be such that
.
Then  and
for all ,  and :
\begin{iteml}
\normalfont
\item
 iff \\ 
\begin{tabular}[t]{@{}ll@{}}
, &
, \\
, &
, \\
, &
, \\
, &
;
\end{tabular}
\item
 iff \\ 
\begin{tabular}[t]{@{}ll@{}}
, &
, \\
, &
, \\
, &
, \\
, &
;
\end{tabular}
\item
 iff \\ 
\begin{tabular}[t]{@{}ll@{}}
, &
, \\
, &
, \\
, &
, \\
, &
;
\end{tabular}
\item
 iff \\ 
,
;
\item
 for some  iff
.
\end{iteml}
\end{proposition}
\begin{proof}
From the assumption that  and  are disjoint, the assumption
that  is infinite, and the definition of , it follows
easily that:
\begin{iteml}
\item
all atom creations are successful;
\item
the content of each spot used in an atom creation does not change after
the atom creation concerned;
\item
 modifies the atom that is the contents of spot  only
(),
 modifies the atom that is the contents of
spot  only, and
 modifies the atom that is the contents of
spot  only.
\end{iteml}
From this, the properties stated in the proposition follow
straightforwardly by case distinction as in the definition of .
\qed
\end{proof}

\section{Interpreting Programs Represented by Molecules}
\label{sect-interpretation}

In this section, we introduce a \PGA\ program for interpreting \PGLD\
programs represented by molecules.

The idea is that:
\begin{iteml}
\item
if the atom to be interpreted has the field , then the
interpretation terminates;
\item
if the atom to be interpreted has the field , then the
interpretation proceeds with the atom to which it is linked via this
field;
\item
otherwise, first the basic instruction represented by the atoms to which it
is linked via the fields  and  is executed and then
the interpretation proceeds with the atom to which it is linked via the
field  or the field , depending upon the reply being
positive or negative.
\end{iteml}

The following is the \PGA\ program for interpreting \PGLD\ programs
represented by molecules:
\begin{ldispl}
\begin{aeqns}
(\ptst{\hasfield{s}{\stopf}} \conc \halt \conc
{} \\ \phantom{(}
 \ptst{\hasfield{s}{\ajmpf}} \conc \fjmp{9} \conc
{} \\ \phantom{(}
 \getfield{u}{s}{\focusf} \conc \getfield{v}{s}{\methodf} \conc
 \ptst{\genact{u}{v}} \conc \fjmp{3} \conc
  \getfield{s}{s}{\negf} \conc \fjmp{4} \conc
  \getfield{s}{s}{\posf} \conc \fjmp{2} \conc
{} \\ \phantom{(}
 \getfield{s}{s}{\ajmpf}) \rep\;,
\end{aeqns}
\end{ldispl}
where .
Again, the omitted focus is considered to be .
Below, we write  for this \PGA\ program.

The program  interprets \PGLD\ programs correctly in the sense that,
for all \PGLD\ programs , the intended behaviour of  under
execution coincides with the behaviour of the interpreter under
execution on interaction with the molecular dynamics service that holds
the representation of  constructed by the program  when
abstracted from .
This is stated rigorously by Theorem~\ref{theorem-correctness} below.
The theorem is preceded by Proposition~\ref{prop-interpretation} which is
used in the proof of the theorem.
The proposition concerns the local use of the spots  and  in .

For convenience, we introduce some abbreviations.
Let  be a \PGLD\ program and let
.
Then we write  for
 and  for
.

\begin{proposition}
\label{prop-interpretation}
Let  be a \PGLD\ program,
let , and
let  be such that
.
Then
.
\end{proposition}
\begin{proof}
By \AIP, it is sufficient to prove that for all , for all
,
.
This property is straightforward to prove by induction on .
\qed
\end{proof}

\begin{theorem}
\label{theorem-correctness}
For all \PGLD\ programs :
\begin{ldispl}
\extr{P}_\sPGLD =
\abstr(\use{\extr{I}}{\md}{\MDS_{\repr(P)}})\;.
\end{ldispl}
\end{theorem}
\begin{proof}
In the proof, we make use of an auxiliary function  from
the set of all natural numbers and the set of all \PGLD\ programs to the
set of all closed terms of sort .
It gives, for each natural number  and \PGLD\ program
, a closed term of sort  that denotes
the behaviour of  when executed from
position  if  and  otherwise.
This function is defined as follows:
\begin{ldispl}
\begin{aceqns}
\extr{i,u_1 \conc \ldots \conc u_k} & = &
\multicolumn{2}{@{}l@{}}
{\extr{\psi_i(u_i) \conc \ldots \conc \psi_k(u_k) \conc
       \halt \conc \halt \conc
       (\psi_1(u_1) \conc \ldots \conc \psi_k(u_k) \conc
        \halt \conc \halt)\rep}
} \\ & &
& \hspace*{17.25em} \mif 1 \leq i \leq k\;,
\\
\extr{i,u_1 \conc \ldots \conc u_k} & =  & \Stop
& \hspace*{17.25em} \mif \Not 1 \leq i \leq k\;
\end{aceqns}
\end{ldispl}
(where  is as in the definition of ).
It follows easily from the definition of  and the axioms
of \PGA\ that if :
\begin{ldispl}
\begin{aceqns}
\extr{i,u_1 \conc \ldots \conc u_k} & = &
a \bapf \extr{i+1,u_1 \conc \ldots \conc u_k}
& \mif u_i = a\;, \\
\extr{i,u_1 \conc \ldots \conc u_k} & = &
\pcc{\extr{i+1,u_1 \conc \ldots \conc u_k}}{a}
    {\extr{i+2,u_1 \conc \ldots \conc u_k}}
& \mif u_i = \ptst{a}\;, \\
\extr{i,u_1 \conc \ldots \conc u_k} & = &
\pcc{\extr{i+2,u_1 \conc \ldots \conc u_k}}{a}
    {\extr{i+1,u_1 \conc \ldots \conc u_k}}
& \mif u_i = \ntst{a}\;, \\
\extr{i,u_1 \conc \ldots \conc u_k} & = &
\extr{l,u_1 \conc \ldots \conc u_k}
& \mif u_i = \ajmp{l}\;.
\end{aceqns}
\end{ldispl}

Let  be a \PGLD\ program,
let
\begin{ldispl}
T  = \set{\extr{i,P} \where i \in [1,k]}\;, \\
T' = \set{\abstr(\use{\extr{I}}{\md}{\MDS_{\repr(i,P)}}) \where
          i \in [1,k]}\;,
\end{ldispl}
and let  be the bijection defined by
\begin{ldispl}
\beta(\extr{i,P}) =
\abstr(\use{\extr{I}}{\md}{\MDS_{\repr(i,P)}})\;.
\end{ldispl}
For each closed term  of sort , write  for 
with, for all , all occurrences of  in  replaced by
.
Then, using the equations concerning the auxiliary function
 given above and Propositions~\ref{prop-representation}
and~\ref{prop-interpretation}, it is straightforward to prove that there
exists a set~ consisting of one derivable equation  for each
 such that, for all equations  in :
\begin{iteml}
\item
the equation  is derivable;
\item
 only if  can be rewritten to a  using the
equations in  from left to right.
\end{iteml}
Because
 and
,
this means that
 and 
are solutions of the same guarded recursive specification.
Because guarded recursive specifications have unique solutions, it
follows immediately that
.
\qed
\end{proof}
In the program , we could have
replaced  by

because the program  does not use the spots .
However, we cannot conceive a proof of Theorem~\ref{theorem-correctness}
in which these auxiliary spots are not found.
The main problem is that we cannot find a way of formulating the gist of
Proposition~\ref{prop-representation}, which looks to be material to a
proof of the theorem, without referring to the spots
.

\section{\PGLD\ with Indirect Jumps}
\label{sect-PGLDij}

In this section, we introduce a variant of \PGLD\ with indirect jump
instructions.
This variant is called \PGLDij.
However, preceding the introduction of \PGLDij, we give a state-based
description of the very simple family of services that constitute a
register file of which the registers can contain natural numbers up to
some bound.
This register file will be used later on to describe the behaviour of
\PGLDij\ programs.

It is assumed that a fixed but arbitrary number  has been given,
which is considered the number of registers available.
It is also assumed that a fixed but arbitrary number  has been
given, which is considered the greatest natural number that can be
contained in a register.

The register file services accept the following methods:
\begin{itemize}
\item
for each  and ,
a \emph{register set method} ;
\item
for each  and ,
a \emph{register test method} .
\end{itemize}
We write  for the set
.
It is assumed that .

The methods accepted by register file services can be explained as
follows:
\begin{itemize}
\item
\,:
the contents of register  becomes  and the reply is ;
\item
\,:
if the contents of register  equals , then nothing changes and the
reply is ; otherwise nothing changes and the reply is .
\end{itemize}

Let .
Then we write  for the service with initial state  described
by , where
, and the functions ,
 and  defined as follows (,
, ):
\begin{ldispl}
\begin{gceqns}
\eff(\setr{:}i{:}n,\rho) = \rho \owr \maplet{i}{n}\;,
\\
\eff(\eqr{:}i{:}n,\rho)  = \rho\;,
\\
\eff(m,\rho)      = \undef       & \mif m \not\in \Meth_\rf\;,
\\
\eff(m,\undef) = \undef\;,
\eqnsep
\yld(\setr{:}i{:}n,\rho) = \True\;,
\\
\yld(\eqr{:}i{:}n,\rho) = \True  & \mif \rho(i) = n\;,
\\
\yld(\eqr{:}i{:}n,\rho) = \False & \mif \rho(i) \neq n\;,
\\
\yld(m,\rho)      = \Blocked     & \mif m \not\in \Meth_\rf\;,
\\
\yld(m,\undef) = \Blocked\;,
\eqnsep
\act(m,\rho) = \Tau\;,
\\
\act(m,\undef) = \Tau\;.
\end{gceqns}
\end{ldispl}We write  for
.

We pass on to \PGLD\ with indirect jump instructions.
In \PGLDij, it is assumed that there is a fixed but arbitrary finite set
of \emph{foci}  with  and a fixed but arbitrary
finite set of \emph{methods} .
Moreover, we adopt the assumptions made about register file services
above.
The set  is
taken as the set  of basic instructions.

\PGLDij\ has the following primitive instructions:
\begin{iteml}
\item
for each , a \emph{plain basic instruction} ;
\item
for each , a \emph{positive test instruction} ;
\item
for each , a \emph{negative test instruction} ;
\item
for each , a \emph{direct absolute jump instruction}
;
\item
for each  and ,
a \emph{register set instruction} ;
\item
for each , an \emph{indirect absolute jump instruction}
.
\end{iteml}
\PGLDij\ programs have the form , where
 are primitive instructions of \PGLDij.

The plain basic instructions, the positive test instructions, the
negative test instructions, and the direct absolute jump instructions
are as in \PGLD.
The effect of a register set instruction  is that the
content of register  becomes~.
The effect of an indirect absolute jump instruction  is that
execution proceeds with the -th instruction of the program concerned,
where  is the content of register .
If  is itself the -th instruction, then deadlock occurs.
If  equals  or  is greater than the length of the program,
termination occurs.
We stipulate that the content of each register is initially .

Like before, we define the meaning of \PGLDij\ programs by means of a
function  from the set of all \PGLDij\ programs to the set
of all \PGLD\ programs.
This function is defined by
\begin{ldispl}
\pgldijpgld(u_1 \conc \ldots \conc u_k) = \\ \quad
\psi(u_1) \conc \ldots \conc \psi(u_k) \conc
\ajmp{0} \conc \ajmp{0}  \conc {} \\ \quad
\ptst{\rf.\eqr{:}1{:}1} \conc \ajmp{1} \conc \ldots \conc
\ptst{\rf.\eqr{:}1{:}n} \conc \ajmp{n} \conc \ajmp{0} \conc {} \\
\qquad \vdots  \\ \quad
\ptst{\rf.\eqr{:}\maxr{:}1} \conc \ajmp{1} \conc \ldots \conc
\ptst{\rf.\eqr{:}\maxr{:}n} \conc \ajmp{n} \conc \ajmp{0}\;,
\end{ldispl}where  and the auxiliary function  from the set
of all primitive instructions of \PGLDij\ to the set of all primitive
instructions of \PGLD\ is defined as follows:
\begin{ldispl}
\begin{aceqns}
\psi(a)         & = & a\;, \\
\psi(\ptst{a})  & = & \ptst{a}\;, \\
\psi(\ntst{a})  & = & \ntst{a}\;, \\
\psi(\ajmp{l})  & = & \ajmp{l} & \mif l \leq k\;, \\
\psi(\ajmp{l})  & = & \ajmp{0} & \mif l   >  k\;, \\
\psi(\setr{:}i{:}n) & = & \rf.\setr{:}i{:}n\;, \\
\psi(\iajmp{i}) & = & \ajmp{l_i}\;,
\end{aceqns}
\end{ldispl}and for each :
\begin{ldispl}
\begin{aeqns}
l_i & = & k + 3 + (2 \mul \min(k,\maxn) + 1) \mul (i - 1)\;.
\end{aeqns}
\end{ldispl}The idea is that each indirect absolute jump can be replaced by a direct
absolute jump to the beginning of the instruction sequence
\begin{ldispl}
\begin{aeqns}
\ptst{\rf.\eqr{:}i{:}1} \conc \ajmp{1} \conc \ldots \conc
\ptst{\rf.\eqr{:}i{:}n} \conc \ajmp{n} \conc \ajmp{0}\;,
\end{aeqns}
\end{ldispl}where  is the register concerned and .
The execution of this instruction sequence leads to the intended jump
after the content of the register concerned has been found by a linear
search.
To enforce termination of the program after execution of its last
instruction if the last instruction is a plain basic instruction, a
positive test instruction or a negative test instruction,
 is appended to
.
Because the length of the translated program is greater than , care
is taken that there are no direct absolute jumps to instructions with a
position greater than .
Obviously, the linear search for the content of a register can be
replaced by a binary search.

Let  be a \PGLDij\ program.
Then  represents the meaning of  as a \PGLD\ program.
The intended behaviour of  is the behaviour of  on
interaction with a register file when abstracted from .
That is, the \emph{behaviour} of , written , is
.



A slightly different variant of \PGLD\ with indirect jump instructions
is introduced in~\cite{BM07e} under the same name.

\section{The Interpretation of \PGLDij\ Programs}
\label{sect-interpretation-ij}

In this section, we associate each \PGLDij\ program with a \PGA\ program
for constructing a representation of the \PGLDij\ program by a molecule
and introduce a \PGA\ program for interpreting \PGLDij\ programs
represented by molecules.
This amounts to enhancing the \PGA\ programs given in
Sections~\ref{sect-representation} and~\ref{sect-interpretation}.
\PGLDij\ programs without indirect absolute jump instructions are
represented and interpreted exactly as before.

The idea of the enhancements is that:
\begin{iteml}
\item
an atom is created for each of the registers;
\item
each atom that corresponds to a register is handled as if it concerns a
direct jump instruction to the instruction with the content of the
register as position;
\item
each atom that corresponds to an indirect jump instruction is handled as
if it concerns a direct jump instruction to the direct jump instruction
that takes the place of the register concerned;
\item
each register set instruction is handled as if it concerns an
instruction for overwriting the direct jump instruction that takes the
place of the register concerned.
\end{iteml}

We define the \PGA\ programs for constructing representations of
\PGLDij\ programs by means of a function  from the set of all
\PGLDij\ programs to the set of all \PGA\ programs.
This function is defined by
\pagebreak[2]
\begin{ldispl}
\begin{geqns}
\pgldijmd(u_1 \conc \ldots \conc u_k) =
{} \\ \quad
\creatom{f_1} \conc \ldots \conc \creatom{f_n} \conc
\creatom{m_1} \conc \ldots \conc \creatom{m_{n'}} \conc
\creatom{s_1} \conc \ldots \conc \creatom{s_{k+2}} \conc
\creatom{s'_1} \conc \ldots \conc \creatom{s'_I} \conc
{} \\ \quad
\rho_1(u_1) \conc \ldots \conc \rho_k(u_k) \conc
{} \\ \quad
\addfield{s_{k+1}}{\stopf} \conc \addfield{s_{k+2}}{\stopf} \conc
{} \\ \quad
\addfield{s'_1}{\ajmpf} \conc \setfield{s'_1}{\ajmpf}{s_{k+2}} \conc
 \ldots \conc
\addfield{s'_I}{\ajmpf} \conc \setfield{s'_I}{\ajmpf}{s_{k+2}} \conc
{} \\ \quad
\setspot{s}{s_1} \conc
\halt\;,
\end{geqns}
\end{ldispl}
where the auxiliary functions  from the set of all primitive
instructions of \PGLDij\ to the set of all \PGA\ programs are defined as
follows ():
\begin{ldispl}
\begin{aeqns}
\rho_j(f.m) & = &
\addfield{s_j}{\focusf} \conc \addfield{s_j}{\methodf} \conc
\addfield{s_j}{\posf} \conc \addfield{s_j}{\negf} \conc
{} \\ & &
\setfield{s_j}{\focusf}{f} \conc \setfield{s_j}{\methodf}{m} \conc
\setfield{s_j}{\posf}{s_{j+1}} \conc
\setfield{s_j}{\negf}{s_{j+1}}\;, \\
\rho_j(\ptst{f.m}) & = &
\addfield{s_j}{\focusf} \conc \addfield{s_j}{\methodf} \conc
\addfield{s_j}{\posf} \conc \addfield{s_j}{\negf} \conc
 {} \\ & &
\setfield{s_j}{\focusf}{f} \conc \setfield{s_j}{\methodf}{m} \conc
\setfield{s_j}{\posf}{s_{j+1}} \conc
\setfield{s_j}{\negf}{s_{j+2}}\;, \\
\rho_j(\ntst{f.m}) & = &
\addfield{s_j}{\focusf} \conc \addfield{s_j}{\methodf} \conc
\addfield{s_j}{\posf} \conc \addfield{s_j}{\negf} \conc
 {} \\ & &
\setfield{s_j}{\focusf}{f} \conc \setfield{s_j}{\methodf}{m} \conc
\setfield{s_j}{\posf}{s_{j+2}} \conc
\setfield{s_j}{\negf}{s_{j+1}}\;,
\end{aeqns}
\\
\begin{aceqns}
\rho_j(\ajmp{l}) \hspace*{.5em} & = &
\addfield{s_j}{\ajmpf} \conc \setfield{s_j}{\ajmpf}{s_l}
 & \mif 1 \leq l \leq k\;, \\
\rho_j(\ajmp{l}) & = & \addfield{s_j}{\stopf}
 & \mif \Not (1 \leq l \leq k)\;, \\
\rho_j(\setr{:}i{:}l) & = &
\addfield{s_j}{\regf} \conc \addfield{s_j}{\contf} \conc
\addfield{s_j}{\nxtf} \conc
 {} \\ & &
\setfield{s_j}{\regf}{s'_i} \conc \setfield{s_j}{\contf}{s_l} \conc
\setfield{s_j}{\nxtf}{s_{j+1}}
 & \mif 1 \leq l \leq k\;, \\
\rho_j(\setr{:}i{:}l) & = &
\addfield{s_j}{\regf} \conc \addfield{s_j}{\contf} \conc
\addfield{s_j}{\nxtf} \conc
 {} \\ & &
\setfield{s_j}{\regf}{s'_i} \conc \setfield{s_j}{\contf}{s_{k+2}} \conc
\setfield{s_j}{\nxtf}{s_{j+1}}
 & \mif \Not (1 \leq l \leq k)\;, \\
\rho_j(\iajmp{i}) & = &
\addfield{s_j}{\ajmpf} \conc \setfield{s_j}{\ajmpf}{s'_i}
\end{aceqns}
\end{ldispl}
and
\begin{iteml}
\item
 are the different foci that occur in
;
\item
 are the different methods that occur in
;
\item
.
\end{iteml}

The following is the \PGA\ program for interpreting \PGLDij\ programs
represented by molecules:
\begin{ldispl}
\begin{aeqns}
(\ptst{\hasfield{s}{\stopf}} \conc \halt \conc
{} \\ \phantom{(}
 \ptst{\hasfield{s}{\ajmpf}} \conc \fjmp{16} \conc
{} \\ \phantom{(}
 \ptst{\hasfield{s}{\regf}} \conc \fjmp{9} \conc
{} \\ \phantom{(}
 \getfield{u}{s}{\focusf} \conc \getfield{v}{s}{\methodf} \conc
 \ptst{\genact{u}{v}} \conc \fjmp{3} \conc
  \getfield{s}{s}{\negf} \conc \fjmp{9} \conc
  \getfield{s}{s}{\posf} \conc \fjmp{7} \conc
{} \\ \phantom{(}
 \getfield{u}{s}{\regf} \conc \getfield{v}{s}{\contf} \conc
 \setfield{u}{\ajmpf}{v} \conc
 \getfield{s}{s}{\nxtf} \conc \fjmp{2} \conc
{} \\ \phantom{(}
 \getfield{s}{s}{\ajmpf}) \rep\;,
\end{aeqns}
\end{ldispl}
where .
Below, we write  for this \PGA\ program.

Theorem~\ref{theorem-correctness-ij} below states rigorously that
program  interprets \PGLDij\ programs correctly.
In that theorem, other than in Theorem~\ref{theorem-correctness}, we
write  for
.
\begin{theorem}
\label{theorem-correctness-ij}
For all \PGLDij\ programs :
\begin{ldispl}
\extr{P}_\sPGLDij =
\abstr(\use{\extr{I'}}{\md}{\MDS_{\repr(P)}})\;.
\end{ldispl}
\end{theorem}
\begin{proof}
The proof follows the same line as the proof of
Theorem~\ref{theorem-correctness}.
This is possible because on interpretation any change of the state of
the register file is reflected by a corresponding change of its
molecular representation.
\qed
\end{proof}

\section{Conclusions}
\label{sect-concl}

In this paper, we have considered the programming of an interpreter for
a program notation that is close to existing assembly languages using
\PGA\ with the primitives of molecular dynamics as basic instructions.
We have given \PGA\ programs for constructing representations of the
programs to be interpreted by molecules and a \PGA\ program for
interpreting those representations and we have shown that the latter
\PGA\ program does the interpretation correctly.
We have experienced that, although primarily meant for explaining
programming language features relating to the use of dynamic data
structures, the collection of primitives of molecular dynamics in itself
is suited to the programming wants concerned.

We observe that:
(i)~the program notation for which the presented interpreter has been
designed belongs to the simplest program notations devised ever,
(ii)~it is hard to imagine that the programs to be interpreted can be
represented by molecules in a way that is simpler than the way chosen
for the presented interpreter,
(iii)~it is hard to conceive of an interpreter that is simpler than the
presented interpreter.
This means not at all that the design of the interpreter was simple.
On the contrary, the design turned out to be disappointingly difficult.
It happened that, owing to the quest for a simple interpreter, it was
inescapable that the design was to a great extent a trial-and-error
matter.

Dynamic data structures modelled using molecular dynamics can
straightforwardly be implemented in programming languages ranging from
PASCAL~\cite{Wir71a} to C\#~\cite{HWG03a} through pointers or
references, provided that fields are not added or removed dynamically.
Using molecular dynamics, we need not be aware of the existence of the
pointers used for linking data.
The name molecular dynamics refers to the molecule metaphor used in the
introduction.
By that, there is no clue in the name itself to what it stands for.
To remedy this defect, we suggest data linkage dynamics as an
alternative name.

\bibliographystyle{plain}
\bibliography{TA}



\end{document}
