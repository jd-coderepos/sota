
\documentclass{article}
\usepackage{iclr2022_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage[T5,T3,T1]{fontenc}

\usepackage[utf8]{inputenc}
\usepackage[mathletters]{ucs}
\usepackage{hyperref}
\usepackage{url}
\usepackage{graphicx}
\usepackage{tabularx} 
\usepackage{wrapfig}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{xspace}
\usepackage{tablefootnote}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{mathtools}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{inconsolata}
\usepackage{euflag}
\usepackage{wrapfig}
\usepackage{pifont}
\newcommand{\cmark}{\ding{51}}\newcommand{\xmark}{\ding{55}}

\definecolor{darkblue}{rgb}{0, 0, 0.5}
\definecolor{gr}{HTML}{363636}

\usepackage{colortbl}
\colorlet{tableheadcolor}{gray!85}
\newcommand{\headcol}{\rowcolor{tableheadcolor}} \colorlet{tablerowcolor}{gray!20}
\newcommand{\rowcol}{\rowcolor{tablerowcolor}} \newcommand{\tc}{\textcolor{tableheadcolor}} 

\renewcommand{\algorithmiccomment}[1]{{\color{darkblue}\hfill \textit{#1}}}
\algdef{SE}{Input}{Output}{\textbf{Input: }}{\textbf{Output: }}

\usepackage{siunitx}
\sisetup{output-exponent-marker=\ensuremath{
e}}
\sisetup{tight-spacing=true}

\newcommand{\blue}[1]{\textcolor{blue}{#1}}

\newcommand{\copenhagen}{1}
\newcommand{\rff}{2}
\newcommand{\johnshopkins}{3}
\newcommand{\uppsala}{4}
\newcommand{\leuven}{5}
\newcommand{\pioneer}{6}


\title{Language Modelling with Pixels}

\author{Phillip Rust ~ Jonas F. Lotz ~ Emanuele Bugliarello \\ \textbf{Elizabeth Salesky} ~ \textbf{Miryam de Lhoneux} ~ \textbf{Desmond Elliott}\\
  University of Copenhagen \quad
  ROCKWOOL Foundation Research Unit \\
  Johns Hopkins University\quad
  KU Leuven \quad 
  Pioneer Centre for AI\\
\texttt{p.rust@di.ku.dk}
}

\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}
\newcommand{\model}{\textsc{pixel}\xspace}

\newcommand{\arabi}{\textsc{ara}\xspace}
\newcommand{\english}{\textsc{eng}\xspace}
\newcommand{\coptic}{\textsc{cop}\xspace}
\newcommand{\japanese}{\textsc{jpn}\xspace}
\newcommand{\hindi}{\textsc{hin}\xspace}
\newcommand{\korean}{\textsc{kor}\xspace}
\newcommand{\vietnamese}{\textsc{vie}\xspace}
\newcommand{\chinese}{\textsc{zho}\xspace}
\newcommand{\tamil}{\textsc{tam}\xspace}
\newcommand{\amharic}{\textsc{amh}\xspace}
\newcommand{\hausa}{\textsc{hau}\xspace}
\newcommand{\igbo}{\textsc{ibo}\xspace}
\newcommand{\kinyarwanda}{\textsc{kin}\xspace}
\newcommand{\luganda}{\textsc{lug}\xspace}
\newcommand{\luo}{\textsc{luo}\xspace}
\newcommand{\naija}{\textsc{pcm}\xspace}
\newcommand{\swahili}{\textsc{swa}\xspace}
\newcommand{\wolof}{\textsc{wol}\xspace}
\newcommand{\yoruba}{\textsc{yor}\xspace}
\newcommand{\french}{\textsc{fra}\xspace}
\newcommand{\spanish}{\textsc{spa}\xspace}
\newcommand{\german}{\textsc{deu}\xspace}
\newcommand{\bulgarian}{\textsc{bul}\xspace}
\newcommand{\greek}{\textsc{ell}\xspace}
\newcommand{\russian}{\textsc{rus}\xspace}
\newcommand{\thai}{\textsc{tha}\xspace}
\newcommand{\turkish}{\textsc{tur}\xspace}
\newcommand{\urdu}{\textsc{urd}\xspace}
\newcommand{\bengali}{\textsc{ben}\xspace}
\newcommand{\finnish}{\textsc{fin}\xspace}
\newcommand{\indonesian}{\textsc{ind}\xspace}
\newcommand{\telugu}{\textsc{tel}\xspace}

\newcommand{\modernarabic}{\textsc{msa}\xspace}
\newcommand{\egyptarabic}{\textsc{ea}\xspace}

\newcommand{\circa}{{\raise.17ex\hbox{}}}

\makeatletter
\g@addto@macro{\UrlBreaks}{\UrlOrds}
\makeatother

\iclrfinalcopy
\begin{document}


\maketitle

\begin{abstract}

Language models are defined over a finite set of inputs, which creates a \emph{vocabulary bottleneck} when we attempt to scale the number of supported languages. Tackling this bottleneck results in a trade-off between what can be represented in the embedding matrix and computational issues  in the output layer. This paper introduces \model, the \textbf{Pix}el-based \textbf{E}ncoder of \textbf{L}anguage, which suffers from neither of these issues. \model is a pretrained language model that renders text as images, making it possible to transfer representations across languages based on orthographic similarity or the co-activation of pixels. \model is trained to reconstruct the pixels of masked patches instead of predicting a distribution over tokens.\footnote{See Appendix~\ref{app:abstract_reconstructions} for reconstructions of this abstract.} We pretrain the M parameter \model model on the same English data as \textsc{bert} and evaluate on syntactic and semantic tasks in typologically diverse languages, including various non-Latin scripts.
We find that \model substantially outperforms \textsc{bert} on syntactic and semantic processing tasks on scripts that are not found in the pretraining data, but \model is slightly weaker than \textsc{bert} when working with Latin scripts. 
Furthermore, we find that \model is more robust than \textsc{bert} to orthographic attacks and linguistic code-switching, further confirming the benefits of modelling language with pixels. 


\end{abstract}

\section{Introduction}
\label{sec:intro}
\vspace{-2mm}

Natural language processing has rapidly progressed in recent years due to a combination of self-supervised representation learning, i.e.\ pretrained language models (PLMs) like \textsc{bert} \citep{devlin-etal-2019-bert}, GPT-3 \citep{brown-etal-2020-language}, and XLM-R \citep{conneau-etal-2020-unsupervised}; large unlabelled datasets; such as C4 \citep{raffel-etal-2020-t5}, The Pile \citep{gao2020pile}; and large-scale computing power \citep{hirschberg2015advances}.
Despite this progress, these models only cover a fraction of the world's languages, with large inequalities in performance \citep{pires-etal-2019-multilingual,lauscher-etal-2020-zero},   
and the majority of languages are falling behind English 
\citep{joshi-etal-2020-state,bugliarello-etal-2022-iglue}. Even within English, these models struggle when tasked with processing noisy inputs \citep{SunADV-BERT, eger-benz-2020-hero}.
In this paper, we show how to effectively support \textit{thousands} of written languages in a single model while being robust to variations caused by character-level noise.

Language models typically support a finite vocabulary of categorical inputs, e.g.\ characters, subwords or even words, and much effort has been devoted to vocabulary construction~\citep{wan2022fairness}.
On one end of the spectrum, a vocabulary over words has three problems: (i) it is not possible to encode out-of-vocabulary words because they lack an entry in a closed vocabulary, e.g.\ ``doxing'', (ii) there are too many parameters in the word embedding layer, and relatedly, (iii) the normalising constant for the softmax activation in the output layer is too expensive to compute. 
On the other end of the spectrum, vocabularies over bytes or characters are much smaller, which leads to increased sequence lengths \citep{keren-etal-2022-breaking}. 
In practice, most current models operate over inputs smaller than words but larger than characters: subword units \citep{sennrich-etal-2016-neural,kudo-2018-subword}. 
Subwords prevent the problem of extremely large embedding and output layers, and support open vocabulary processing. 
While this is a practical solution in a monolingual context and for some languages like English, dealing with many languages with a variety of scripts will either result in a very large vocabulary or a trade-off over what is represented within a fixed number of subwords (see \S \ref{sec:related_work}). 
Taken together, given a language model with a finite vocabulary, there is a bottleneck in two locations: at the level of the encoding of the inputs and at the level of estimating the probability distribution over the vocabulary. 
We call this the \textit{vocabulary bottleneck}. A language model that can handle thousands of languages needs to deal with this problem.


We propose to rethink language modelling as a visual recognition task, removing the need for a finite vocabulary. 
Our proposal is inspired by \citet{salesky-etal-2021-robust}, who showed how to train a machine translation model with ``visual text representations'' in the encoder instead of subwords.
Our \textbf{Pix}el-based \textbf{E}ncoder of \textbf{L}anguage (\textbf{\model}) is built on the Masked Autoencoding Visual Transformer \citep[ViT-MAE; ][]{he-etal-2022-mae}. ViT-MAE is a Transformer-based encoder-decoder trained to reconstruct the pixels in masked image patches.
\model does not have a vocabulary embedding layer; instead, text is rendered as a sequence of fixed-sized patches, which are processed using a Vision Transformer encoder \citep{dosovitskiy2021an}.
\model also does not have an expensive output layer
when it reconstructs the pixels of the masked patches. In effect, \model provides a solution to the vocabulary bottleneck without needing the prohibitively long sequences of character-based models. 

\model is pretrained on the same data as \textsc{bert}, given our computational resources. This means that it has encountered only \circa0.05\% non-English text \citep{blevins-zettlemoyer-2022-language}.\footnote{We do not claim that a language model designed to support thousands of languages should be pretrained only on English text. 
We expect that pretraining on an appropriate choice of another language or multilingually may provide more remarkable results. \model represents an initial effort at smaller scale.
}
We evaluate \model on a range of syntactic and semantic tasks in 32 typologically diverse languages across 14 scripts, showing that it can rapidly adapt to new languages and unseen scripts. 
\model is also evaluated on its ability to handle noisy text caused by orthographic attacks, where pixel-based encoding is a clear improvement over subword-based vocabularies. In lexical code-switching experiments, \model performs on-par with \textsc{bert} and sometimes outperforms the multilingually pretrained \textsc{mBert}.

\model is a new type of language model that can theoretically support any language that can be typeset by a modern computer. We make the implementation, the pretrained model including intermediate training checkpoints, and the fine-tuned models freely available for the community.\footnote{\url{https://github.com/xplip/pixel}}

\begin{figure*}[t]
    \centering
    \begin{subfigure}[b]{0.48\textwidth}\centering
    \includegraphics[width=0.85\textwidth]{figures/pixel_architecture_v6.pdf}
    \caption{\model pretraining}
    \end{subfigure}
    \quad
    \begin{subfigure}[b]{0.48\textwidth}\centering
    \includegraphics[width=0.85\textwidth]{figures/pixel_finetuning_v6.pdf}
    \caption{\model finetuning}
    \end{subfigure}
    \vspace{-2mm}
    \caption{Overview of \model's architecture. Following \cite{he-etal-2022-mae}, we use a masked autoencoder with a ViT architecture and a lightweight decoder for pretraining (left). At finetuning time (right), the decoder is replaced by a task-specific classification head that sits on top of the encoder.}
    \label{fig:architecture}
    \vspace{-4mm}
\end{figure*}

\vspace{-2mm}
\section{Approach}
\vspace{-3mm}

The Pixel-based Encoder of Language, \model, consists of three major components: a text renderer, which draws text as an image; an encoder, which encodes the unmasked regions of the image; and a decoder, which reconstructs the masked regions at the pixel level. Figure~\ref{fig:architecture} provides an illustration.

\vspace{-3mm}
\subsection{Text Renderer}
\vspace{-2mm}

\label{sec:renderer}

\begin{figure*}[t]
    \includegraphics[width=\textwidth]{figures/three_rendered_text_examples.png}
    \caption{Illustrative examples of our rendered text. \model natively supports most writing systems, colour emoji (a), and complex text layouts such as right-to-left writing and ligatures (b). Black patches serve as separators and end-of-sequence markers. Blank patches to the right of the end-of-sequence marker are treated as sequence padding. For word-level tasks, horizontal spacing can be added between words (c) so that every patch can be assigned to exactly one word (dotted lines indicate patch boundaries for demonstration).} 
    \label{fig:rendered_examples}
    \vspace{-2mm}
\end{figure*}

The key component of \model is a text renderer that takes one or more pieces of text and renders them onto a blank RGB image . We set height  and width  and choose  RGB input channels, which is equivalent to a square colour image with a  resolution and corresponds to a sequence of  image patches of size  pixels.\footnote{We chose a sequence length of 529 so that the memory requirements at maximum length are approx. equal to those of \textsc{bert}. Forward and backward passes of the transformer layers at equal length are also equally fast.}
Figure~\ref{fig:rendered_examples} shows examples of text inputs
rendered by the text renderer. 
The renderer supports (a) colour emoji and hieroglyphs scripts, (b) left-to-right and right-to-left writing systems, and (c) text that requires ligatures.  Analogous to \textsc{bert}, a sequence can either contain a single paragraph of text or a text pair; we use black  patches to serve as separators and end-of-sequence ({\footnotesize\texttt{EOS}}) markers. Blank (white) patches after the end-of-sequence marker are treated as padding by \model, where no attention scores or losses are computed. Sequences longer than the maximum length are either truncated or split into multiple sequences. Further technical details about the renderer are provided in Appendix~\ref{app:text_renderer}.

\vspace{-2mm}
\subsection{Architecture}
\vspace{-2mm}

\model-base is a 112M parameter ViT-MAE architecture \citep{he-etal-2022-mae} with a 12-layer ViT encoder \citep{dosovitskiy2021an} and an 8-layer Transformer decoder \citep{DBLP:conf/nips/VaswaniSPUJGKP17}. The encoder has M parameters and the decoder has M parameters, respectively. The 8-layer decoder is not used for downstream tasks. We give an overview of the architecture below, with more details in Appendix~\ref{app:architecture_details}. We did not train larger \model variants for lack of computational resources.

\vspace{-2mm}
\paragraph{Patch Embeddings} The images produced by the text renderer (\S\ref{sec:renderer}) are patch-wise linearly projected to obtain a sequence of patch embeddings with a 16  16 pixel resolution, to which fixed sinusoidal position embeddings are added.\footnote{This is a fast operation that does not require the large text embedding layer found in subword-based models, saving parameters which could in theory be re-allocated to the self-attention stack. We refer to \citet{xue-etal-2022-byt5} for a discussion regarding benefits and drawbacks of re-allocation of embedding layer weights.}

\begin{wrapfigure}{r}{0.35\textwidth}
    \vspace{-2.25em}
    \centering
    \begin{minipage}{\linewidth}
    \begin{algorithm}[H]
    \caption{\model Span Masking}\label{algo:span_masking}
    \begin{algorithmic}
        \scriptsize
        \Input{\#Image patches , masking ratio , maximum masked span length , span length cumulative weights }
        \Output{Masked patches }
        \State 
        \Repeat{
            \State ) \State 
            \State 
            \If{ \textbf{and} \\\hspace{8mm}}
            \State 
            \EndIf
        }
        \Until{} \Return{}
    \end{algorithmic}
    \end{algorithm}
    \end{minipage}
    \vspace{-1em}
\end{wrapfigure}

\vspace{-2mm}
\paragraph{Patch Span Masking} Instead of the random masking procedure used in ViT-MAE or block-wise masking in BEiT \citep{bao2022beit}, \model uses span masking with a 25\% masking ratio as outlined in Algorithm~\ref{algo:span_masking}, which masks spans of up to  consecutive image patches with a dynamic number of unmasked patches left between them. The idea behind the span masking approach, inspired by T5 \citep{raffel-etal-2020-t5} and SpanBERT \citep{joshi-etal-2020-spanbert}, is that it masks more meaningful units of text (full words or phrases) than random masking where the model more often has to fill in (parts of) individual characters, thereby encouraging \model to model a higher level of abstraction.
In practice, span masking was slightly more effective than random masking in early prototypes of \model. 
This effect may be less noticeable at higher masking ratios (such as the 75\% used in ViT-MAE), when random masking would more often masks consecutive patches.
We found 25\% masking ratio to work well for \model-base, which is in line with recent findings for \textsc{bert}-type models of similar size \citep{wettig-etal-2022-mask}. 
We mask spans of  patches in length, each with 20\% probability, and spans of  patches with 10\% probability each, so .


\vspace{-2mm}
\paragraph{Encoder} Following ViT-MAE \citep{he-etal-2022-mae}, the \model encoder only processes unmasked patches (i.e.,  396 ``visible'' patches at 25\% masking) rather than on a sequence including mask tokens, which not only reduces memory requirements and increases training speed, but also has the advantage of not creating a mismatch between pretraining and finetuning. This mismatch would occur when training the encoder with inserted mask tokens because they are not inserted during finetuning \citep{he-etal-2022-mae}. We also prepend the special \texttt{CLS} embedding to the unmasked patches.\footnote{In pretraining, no loss is computed for the \texttt{CLS} embedding but it can be used for finetuning.} The resulting \texttt{CLS} and unmasked patches are processed by a 12-layer Transformer encoder to produce a sequence of encoder output representations.

\vspace{-2mm}
\paragraph{Decoder} The \model decoder first projects the encoder outputs into the same space as the decoder model hidden size. It then inserts learnable mask embeddings at the masked positions; these are what \model tries to reconstruct at the pixel level. Fixed sinusoidal position embeddings \citep{DBLP:conf/nips/VaswaniSPUJGKP17} are added to inject order information. After processing this sequence via 8 Transformer layers, a linear projection yields patch logits. Note that the decoder does not have to compute an expensive softmax over a subword vocabulary and circumvents the question of whether to tie the subword embedding weights.
\model is trained with a normalised mean squared error (MSE) pixel reconstruction loss measuring the discrepancy between normalised target image patches and reconstructed patches. This loss is only computed for \emph{masked, non-blank (text)} patches. 

\vspace{-2mm}
\subsection{Pretraining}
\vspace{-2mm}

\model-base is pretrained on a rendered version of the English Wikipedia and the Bookcorpus \citep{Zhu_2015_ICCV}, which is roughly equivalent to the \textsc{bert} pretraining data.\footnote{We use a similar Wikipedia dump \citet{devlin-etal-2019-bert} used for \textsc{bert} (February 1, 2018) and a slightly newer version of the Bookcorpus available at \url{https://huggingface.co/datasets/bookcorpusopen}.} For better compute efficiency, we concatenate paragraphs until the maximum sequence length is reached, albeit not across document and book boundaries. Wikipedia has 2B words rendered into 11.4M examples and the Bookcorpus has 1.1B words rendered into 5.4M examples; in total \circa3.1B words (\textsc{bert} used 3.3B) rendered into 16.8M examples.\footnote{This rendering is quite compact; see Appendix~\ref{app:text_renderer}.} \model is pretrained for 1M steps with batch size 256 (i.e.\ \circa16 epochs) using the AdamW optimizer \citep{kingma-ba-2015-adam, loshchilov2018decoupled} with a linear warmup over the first 50k steps to a peak learning rate of \num{1.5e-4} and a cosine decay to a minimum learning rate of \num{1e-5}. Pretraining took 8 days on 840GB Nvidia A100 GPUs. We show the loss curve
and additional pretraining details in Appendix~\ref{app:architecture_details}. We stored \model checkpoints every 10k steps and make them available alongside the fully trained model on the HuggingFace Hub \citep{wolf-etal-2020-transformers},
which we hope will be useful to analyze training dynamics of \model models \citep{sellam2022the}. Figure~\ref{fig:pretraining_dynamics} in Appendix~\ref{app:steps_reconstructions} shows, for three unseen examples, how \model learns to model language over the course of pretraining.

\vspace{-2mm}
\subsection{Finetuning}
\label{sec:finetuning}
\vspace{-2mm}

\model can be finetuned for downstream NLP tasks in a similar fashion to \textsc{bert}-like encoders by simply replacing the \model decoder with a suitable classification head. By truncating or interpolating the sinusoidal position embeddings, we can finetune with sequences shorter or longer than 529 patches, respectively. The latter, in particular, is common in computer vision applications to finetune on higher resolution images \citep{touvron-etal-2019, kolesnikov-etal-2020, dosovitskiy2021an, he-etal-2022-mae}. For most common NLP tasks, we can typically finetune with sequences shorter than 529 to accelerate training while retaining performance. To demonstrate that \model supports a variety of downstream tasks, we conduct finetuning experiments in four settings as follows:

\vspace{-2mm}
\paragraph{Word Classification} For word-level tasks like part-of-speech (POS) tagging and named entity recognition (NER), we render each word at the start of a new image patch so that we can create a bijective mapping between words and patches (see Figure~\ref{fig:rendered_examples} for an example).\footnote{This particular formulation assumes that word boundaries are available. We note that subword-based and character-based models also make this assumption. For further discussion on the implications, see Appendix~\ref{app:finetuning_details}.} To finetune \model on these images, we add a linear classifier with dropout. We assign the label of a word only to its first corresponding image patch and compute a cross-entropy loss with softmax.

\vspace{-2mm}
\paragraph{Dependency Parsing} For dependency parsing, we render text as above but obtain word-level representations by mean pooling over all corresponding image patches of a word and employ a biaffine parsing head \citep{DBLP:conf/iclr/DozatM17}, following the implementation from \cite{glavas-vulic-2021-supervised}.

\vspace{-2mm}
\paragraph{Sequence Classification} For sequence-level tasks, e.g.\ in GLUE \citep{wang-etal-2018-glue}, we render text as in pretraining. For sentence-pair tasks like natural language inference (NLI) we separate the sentences with a black patch. We finetune with different strategies, including training a classifier on top of
(1) the {\footnotesize\texttt{CLS}} embedding, (2) the mean-pooled or max-pooled representations of all patches, (3) a multi-head attention block. Although we did not notice significant performance differences between them in our experiments, we mainly used option (1), which is exactly the same as in \textsc{bert}, and (2), which has been shown to work well for image classification \citep{https://doi.org/10.48550/arxiv.2205.14540}.

\vspace{-2mm}
\paragraph{Extractive Question Answering (QA)} For extractive QA datasets like SQuAD \citep{rajpurkar-etal-2016-squad}, we render the question and context like in sequence-pair tasks above and, same as \cite{devlin-etal-2019-bert}, use a sliding window approach to extract answers for examples exceeding the maximum sequence length. We use a linear classifier to predict the start and end patches of the span containing the answer. Appendix~\ref{app:text_renderer} explains how we obtain the mapping between characters and rendered text.

\vspace{-2mm}
\section{Experiments}
\vspace{-2mm}

We finetune \model on common NLP tasks and evaluate its syntactic and semantic processing capabilities in English, as well as its adaptability to unseen languages. Table~\ref{tab:language_overview} (Appendix \ref{app:finetuning_details}) describes the languages used in these experiments, and our language and data selection is also motivated below.

\vspace{-2mm}
\subsection{Tasks and Languages}
\label{sec:tasks_languages}
\vspace{-2mm}

\paragraph{Syntactic Tasks} We evaluate \model on part-of-speech (POS) tagging and dependency parsing using data from Universal Dependencies v2.10 treebanks \citep{nivre-etal-2020-universal, zeman-etal-2022-ud} for a set of typologically diverse languages that captures a large variety of unseen scripts\footnote{By unseen, we mean not present in the pretraining data.}: Arabic (\arabi), Coptic (\coptic), English (\english), Hindi (\hindi), Japanese (\japanese), Korean (\korean), Tamil (\tamil), Vietnamese (\vietnamese), Chinese (\chinese).\footnote{Table~\ref{tab:treebank_overview} in Appendix~\ref{app:finetuning_details} gives an overview of the treebanks we use.}
We compare how well \model{} transfers to these languages compared to \textsc{bert}. Note that \textsc{bert} does not support all of these writing systems. However, both models have been trained on the same data. This comparison allows us to gauge the extent to which \model can overcome the script barrier and vocabulary bottleneck of subword-based models.

\vspace{-2mm}
\paragraph{Semantic Tasks} We evaluate both monolingual (\english) and cross-lingual \emph{word-level} understanding on MasakhaNER \citep{adelani-etal-2021-masakhaner}, a named entity recognition (NER) benchmark for 10 African languages (\amharic, \hausa, \igbo, \kinyarwanda, \luganda, \luo, \naija, \swahili, \wolof, \yoruba), which also includes a copy of the ConLL-2003 dataset \citep[\english; ][]{tjong-kim-sang-de-meulder-2003-introduction}. For monolingual \english \emph{sentence-level} understanding we rely on GLUE \citep{wang-etal-2018-glue} and SQuAD \citep{rajpurkar-etal-2016-squad}. 
Finally, we evaluate cross-lingual sentence-level understanding on TyDiQA-GoldP \citep{clark-etal-2020-tydi} in the \emph{in-language multitask} setting where we train on the combined gold data in all 9 target languages (\arabi, \bengali, \english, \finnish, \indonesian, \korean, \russian, \swahili, \telugu) at once, and on two additional larger monolingual extractive question answering (QA) corpora: KorQuAD 1.0 \citep[\korean; ][]{lim-etal-2019-korquad} and JaQuAD \citep[\japanese; ][]{so2022jaquad}.

\vspace{-2mm}
\subsection{Baselines and Finetuning protocols}
\vspace{-2mm}

We compare results to \textsc{bert}-base which is trained on the same data.\footnote{We use \textsc{bert} weights from \url{https://huggingface.co/bert-base-cased}.} We do not compare to newer monolingual English models like \textsc{roberta} \citep{DBLP:journals/corr/abs-1907-11692}, \textsc{T5} \citep{raffel-etal-2020-t5} or \textsc{deberta} \citep{he-etal-2020-deberta, he-etal-2021-debertav3} because these models have been pretrained longer on much larger corpora.\footnote{We do not intend to claim state-of-the-art performance, but to demonstrate that \model can overcome the vocabulary bottleneck and to provide a starting point for further research on pixel-based encoding of language.} 
Likewise, we do not compare against models trained on massively multilingual corpora.
However, to contextualise the performance of \model in cross-lingual settings, we report results for \textsc{mbert} and, if results are available, for \textsc{canine} \citep{DBLP:journals/tacl/ClarkGTW22}. For \textsc{bert}, we use the standard finetuning protocols used by \cite{devlin-etal-2019-bert} and the same biaffine classifier for parsing as for \model. We list finetuning details for all tasks in Appendix~\ref{app:finetuning_details}.

\vspace{-2mm}
\subsection{Results}
\label{sec:results}
\vspace{-2mm}

\paragraph{Syntactic Tasks} We present results for POS tagging and dependency parsing in Table~\ref{res:syntactic_task_results}. While \textsc{bert} is slightly better than \model in the monolingual setting (\english), \model clearly outperforms \textsc{bert} in the remaining languages. On the lower end, the accuracy gap in favor of \model in \arabi and \vietnamese, both languages covered by \textsc{bert}'s vocabulary, is relatively small (\circa1\%). On the higher end, in \coptic, where \textsc{bert} has an out-of-vocabulary ({\footnotesize{[\texttt{UNK}]}}) token ratio of 93\%, the gap is \circa70\% for both tasks. There is a strong correlation\footnote{Pearson correlation ,  for POS tagging, ,  for dependency parsing.} between the proportion of {\footnotesize{[\texttt{UNK}]}}s (shown in Table~\ref{res:syntactic_task_results} on the right) and the performance gap, which shows that \model overcomes \textsc{bert}'s vocabulary bottleneck. These results are further analysed in Appendix~\ref{app:analysis}.

\begin{table*}[t]
\centering
\resizebox{0.765\textwidth}{!}{\begin{tabular}{@{}lcccccccccc@{}}
\toprule
 &
 &
\english &
\arabi &
\coptic &
\hindi &
\japanese &
\korean &
\tamil &
\vietnamese &
\textsc{zho} \\ \midrule \addlinespace[0.3em] \rowcol\multicolumn{11}{c}{\textit{POS Tagging (Accuracy)}}                                                                           \\\addlinespace[0.2em]
\textsc{bert}  & 110M & \textbf{97.2}        & 95.4         & 26.5         &   86.4 & 87.9        & 60.0         & 45.4         & 84.5         & 58.6         \\
\model         & ~~86M & 96.7        & \textbf{95.7}         & \textbf{96.0}         &  \textbf{96.3} & \textbf{97.2}       & \textbf{94.2}         & \textbf{81.0}        & \textbf{85.7}         & \textbf{92.8}         \\ \midrule \addlinespace[0.3em] \rowcol\multicolumn{11}{c}{\textit{Dependency Parsing (LAS)}}                                                                    \\\addlinespace[0.2em]
\textsc{bert}  & 110M & \textbf{90.6} & \textbf{77.7} & 13.0 &  75.9 & 73.8 & 30.2 & 15.2 & 49.4 & 28.8 \\
\textsc{\model} & ~~86M  & 88.7 & 77.3 & \textbf{83.5} & \textbf{89.2} & \textbf{90.7} & \textbf{78.5} & \textbf{52.6} &\textbf{50.5} & \textbf{73.7} \\ \bottomrule
\end{tabular}}
\quad
\resizebox{0.195\textwidth}{!}{\begin{tabular}{@{}lrc@{}}
\toprule
         & {\footnotesize{[\texttt{UNK}]}}\% & Fertility \\ \midrule
\english    & 0 \qquad                                  & 1.2       \\
\arabi      & 1.8 \qquad                                & 3.7       \\
\coptic     & 93.6 \qquad                               & 1.0       \\
\hindi      & 32.6 \qquad                               & 2.7       \\
\japanese   & 45.5 \qquad                               & 1.5       \\
\korean     & 84.7 \qquad                               & 1.0       \\
\tamil      & 82.3 \qquad                               & 1.3       \\
\vietnamese & 4.5 \qquad                               & 2.5       \\
\chinese    & 73.2 \qquad                               & 1.5       \\ \bottomrule
\end{tabular}}
\caption{Results for \model and \textsc{bert} finetuned for POS tagging and dependency parsing on various Universal Dependencies treebanks. We report test set results averaged over 5 runs each.  denotes the number of model parameters. The table on the right shows \textsc{bert}'s proportion of {\footnotesize{[\texttt{UNK}]}}s as a measure of (inverse) vocabulary coverage and fertility \citep[i.e., number of subwords per tokenized word; ][]{acs:2019, rust-etal-2021-good} as a measure of over-segmentation in respective UD treebanks. }
\label{res:syntactic_task_results}
\vspace{-2mm}
\end{table*}

\begin{table*}[t!]
\centering
\resizebox{\textwidth}{!}{\begin{tabular}{lccccccccccccc}
\toprule
&
\textsc{\#l} &
 &
\english &
\amharic &
\hausa &
\igbo &
\kinyarwanda &
\luganda &
\luo &
\naija &
\swahili &
\wolof &
\yoruba \\ \midrule
\tc{\textsc{mbert*}} &
  \tc{104} &
  \tc{179M} &
  \tc{92.2} &
 \tc{0} &
  \tc{87.3} &
  \tc{85.3} &
  \tc{72.6} &
  \tc{79.3} &
  \tc{73.5} &
  \tc{86.4} &
  \tc{87.5} &
  \tc{62.2} &
  \tc{80.0} \\
\tc{\textsc{canine-c} + n-gram*} &
\tc{104} &
\tc{167M} &
\tc{89.8} &
\tc{50.0} &
\tc{88.0} &
\tc{85.0} &
\tc{72.8} &
\tc{79.6} &
\tc{74.2} &
\tc{88.7} &
\tc{83.7} &
\tc{66.5} &
\tc{79.1} \\
\tc{\textsc{canine-c*}} &
  \tc{104} &
  \tc{127M} &
  \tc{79.8} &
  \tc{44.6} &
  \tc{76.1} &
  \tc{75.6} &
  \tc{58.3} &
  \tc{69.4} &
  \tc{63.4} &
  \tc{66.6} &
  \tc{72.7} &
  \tc{60.7}&
  \tc{67.9} \\
 \midrule
\textsc{bert} &
  \quad 1 &
  110M &
  \textbf{92.9} &
  0             &
  \textbf{86.6} &
  \textbf{83.5} &
  \textbf{72.0} &
  \textbf{78.4} &
  \textbf{73.2} &
  \textbf{87.0} &
  \textbf{83.3} &
  \textbf{62.2} &
  \textbf{73.8} \\
\model &
  \quad 1 & 
  ~~86M &
  89.5 &
  \textbf{47.7} &
  82.4 &
  79.9 &
  64.2 &
  76.5 &
  66.6 &
  78.7 &
  79.8 &
  59.7 &
  70.7 \\ \bottomrule
\end{tabular}}
\caption{Results for \model and \textsc{bert} finetuned for NER on MasakhaNER. We report test set  scores averaged over 5 runs each. \textsc{bert} outperforms \model in all of the languages that use Latin script, whereas \model does better on \amharic, whose script is not covered by \textsc{bert}'s vocabulary. The performance gap is smaller for languages heavier in diacritics, e.g.\ \yoruba. It is larger for languages closer to English such as Naija Pidgin (\naija), an English-based creole. \textsc{\#l} denotes the number of pretraining languages and \textbf{*} indicates results taken from \cite{DBLP:journals/tacl/ClarkGTW22} for additional context.}
\label{res:ner_results}
\vspace{-2mm}
\end{table*}

\vspace{-2mm}
\paragraph{Semantic Tasks} We present results for NER in Table~\ref{res:ner_results}, for GLUE in Table~\ref{res:glue_results}, for QA in Table~\ref{res:qa_results}.
We also conduct experiments on XNLI in the \emph{translate-train-all} setting which we present in Table~\ref{res:xnli} in Appendix~\ref{app:analysis}, for brevity.
We find that \textsc{bert} consistently achieves higher performance than \model in its pretraining language \english. Likewise, it often outperforms on languages using the Latin writing system; for instance in NER where all languages besides \amharic use Latin script, in QA for \finnish, \indonesian and \swahili.
Although \textsc{bert} has more trainable parameters, this finding indicates that a \model model pretrained for the same number of steps as \textsc{bert} is slightly worse at semantic tasks, and it may require longer pretraining or an additional inductive bias to close the performance gap. 
Similarly, character-based models also tend to underperform subword-based models on NER \citep{keren-etal-2022-breaking}, here seen by the \textsc{canine-c} results.
Since the addition of n-gram embeddings improves the performance of \textsc{canine-c}, likely due to boosting entity memorisation capabilities \citep{DBLP:journals/tacl/ClarkGTW22}, we hypothesize that \model may benefit from equivalent enhancements.


For languages where \textsc{bert} only partially covers the script, such as \korean, \japanese and \telugu in QA,
\model consistently outperforms \textsc{bert}, sometimes by large amounts (e.g.\ , +63  points better on KorQuAD). In the extreme case where \textsc{bert} has no coverage of the script whatsoever, seen in NER for \amharic, \textsc{bert} fails completely (0~) while \model outperforms the larger, multilingually trained \textsc{canine} and performs competitively with its n-gram variant. In other words, \model also overcomes the vocabulary bottleneck of subword-based PLMs in semantics-driven tasks.
Note that although \textsc{bert} was trained on English, its vocabulary has a high coverage of the Arabic script, explaining its good performance in \arabi and \urdu.\footnotemark

While the same may apply to languages like \bengali and \russian in QA, where one may otherwise expect \model to outperform \textsc{bert}, there is an external factor at play; in the standard QA task formulation used by \textsc{bert}, answer spans are extracted by predicting start and end tokens. We adopt this procedure in \model for simplicity. However, an image patch will often overlap two words at variable positions, so the answer may actually start or end mid-patch. By only predicting on a full-patch level, and extracting the entire content of the patch, \model will sometimes extract leading and trailing characters that should not be part of the answer, which degrades the  score---even though the model may have correctly identified the span. Languages not using whitespace to delimit words are particularly affected, which also explains why \model is only slightly better than \textsc{bert} in \japanese.

\begin{table*}[t]
\centering
\resizebox{\textwidth}{!}{\begin{tabular}{@{}lccccccccccc@{}}
\toprule
&
 &
  \begin{tabular}[c]{@{}c@{}}\textsc{MNLI-M/MM}\\ 393k\end{tabular} &
  \begin{tabular}[c]{@{}c@{}}\textsc{QQP}\\ 364k\end{tabular} &
  \begin{tabular}[c]{@{}c@{}}\textsc{QNLI}\\ 105k\end{tabular} &
  \begin{tabular}[c]{@{}c@{}}\textsc{SST-2}\\ 67k\end{tabular} &
  \begin{tabular}[c]{@{}c@{}}\textsc{COLA}\\ 8.6k\end{tabular} &
  \begin{tabular}[c]{@{}c@{}}\textsc{STS-B}\\ 5.8k\end{tabular} &
  \begin{tabular}[c]{@{}c@{}}\textsc{MRPC}\\ 3.7k\end{tabular} &
  \begin{tabular}[c]{@{}c@{}}\textsc{RTE}\\ 2.5k\end{tabular} &
  \begin{tabular}[c]{@{}c@{}}\textsc{WNLI}\\ 635\end{tabular} &
  \textsc{AVG} \\ \midrule
\textsc{bert} &
  110M &
  \textbf{84.0} / \textbf{84.2} &
   \textbf{87.6} &
   \textbf{91.0} &
   \textbf{92.6} &
   \textbf{60.3} &
   \textbf{88.8} &
   \textbf{90.2} &
  \textbf{69.5} &
  51.8 &
  \textbf{80.0} \\
\model &
  ~~86M &
  78.1 / 78.9 &
  84.5 &
  87.8 &
  89.6 &
  38.4 &
  81.1 &
  88.2 &
  60.5 &
  \textbf{53.8} &
  74.1 \\ \bottomrule
\end{tabular}}
\caption{Results for \model and \textsc{bert} finetuned on \textsc{glue}. We report \emph{validation} set performance averaged over 5 runs. The metrics are  score for \textsc{qqp} and \textsc{mrpc}, Matthew's correlation for \textsc{cola}, Spearman's  for \textsc{sts-b}, and accuracy for the remaining datasets. \model achieves non-trivial performance scores on \textsc{glue}, indicating \emph{pixel-based encoders can learn higher-level semantic tasks}, but performs worse overall than \textsc{bert}, so it may require (a) more pretraining steps than subword-tokenized PLMs or (b) additional inductive bias to acquire the same level of monolingual abstraction.}
\label{res:glue_results}
\vspace{-2mm}
\end{table*}

\begin{table*}[bt!]
\centering
\resizebox{\textwidth}{!}{\begin{tabular}{lccccccccccccccc}
\toprule
\multirow{2}{*}{} &
  \multirow{2}{*}{\textsc{\#l}} &
  \multicolumn{1}{c}{\multirow{2}{*}{}} &
  \multicolumn{10}{c}{TyDiQA-GoldP} &
  \multicolumn{1}{c}{SQuAD} &
  KorQuAD &
  JaQuAD \\
 &
   &
  \multicolumn{1}{l}{} &
  \english &
  \arabi &
  \bengali &
  \finnish &
  \indonesian &
  \korean &
  \russian &
  \swahili &
  \telugu &
  \textbf{\textsc{AVG}} &
  \english &
  \korean &
  \japanese \\ \midrule
\tc{\textsc{mbert}} &
  \tc{104} &
  \tc{179M} &
  \tc{75.6} &
  \tc{78.1} &
  \tc{74.7} &
  \tc{75.5} &
  \tc{84.3} &
  \tc{64.8} &
  \tc{74.9} &
  \tc{83.1} &
  \tc{81.6} &
  \tc{77.1} &
  \tc{88.6} &
  \tc{90.0} &
  \tc{76.4} \\ \midrule
\textsc{bert} &
  \quad 1 &
  110M &
  \textbf{68.5} &
  \textbf{58.0} &
  \textbf{43.2} &
  \textbf{58.3} &
  \textbf{67.1} &
  12.4 &
  \textbf{53.2} &
  \textbf{71.3} &
  48.2 &
  51.5 &
  \textbf{88.2} &
  14.9 &
  28.8 \\
\model &
  \quad 1 &
  ~~86M &
  59.6 &
  57.3 &
  36.3 &
  57.1 &
  63.6 &
  \textbf{26.1} &
  50.5 &
  65.9 &
  \textbf{61.7} &
  \textbf{52.3} &
  81.4 &
  \textbf{78.0} &
  \textbf{34.1} \\ \bottomrule
\end{tabular}}
\caption{Results for \model and \textsc{bert} finetuned on extractive QA datasets. We report validation set  scores averaged over 5 runs each. Average (\textsc{avg}) scores for TyDiQA-GoldP exclude \english as customary \citep{clark-etal-2020-tydi}. While \textsc{bert} clearly outperforms \model in \english, \model is much better in \korean, \telugu, and \japanese---a consequence of the vocabulary bottleneck in \textsc{bert}---thereby gaining an edge on average. In some languages, answer span extraction adversely affects results (see \S\ref{sec:results}).}
\label{res:qa_results}
\vspace{-4mm} 
\end{table*}


Generally, and in particular when transferring to unseen scripts, we find that \model performs best when finetuning on larger corpora. An example of this behaviour can be seen in QA, where \model performs significantly better on KorQuAD (60k examples) than the \korean subset of TyDi (1.6k examples). While large corpora may often not be available when dealing with unseen scripts, we hypothesize that multilingual pretraining will alleviate the need for long finetuning, while potentially being even more conducive to \emph{positive transfer} \citep{conneau-etal-2020-unsupervised, chau-etal-2020-parsing, pfeiffer-etal-2021-unks} by not being vocabulary-bottlenecked.

\footnotetext{Arabic is lexically sparse \citep{antoun-etal-2020-arabert, 10.1145/3086575}, so the characters can be covered in the vocabulary. However, it is morphologically complex, which leads to over-segmentation, as the fertility of 3.7 in Table~\ref{res:syntactic_task_results} shows. This over-segmentation is not necessarily problematic in our selection of tasks \citep{keren-etal-2022-breaking}, e.g.\ due to the sliding window in QA, but can be a disadvantage in others \citep{rust-etal-2021-good}.}

\vspace{-2mm}
\section{Robustness to Orthographic Attacks and Code-Switching}
\vspace{-2mm}

Informal text, commonly found on social media, often contains orthographic noise such as typos and other variations \citep{baldwin-etal-2015-shared, EschWritingAcrossWorld, caswell2020language}.
Previous work has demonstrated the vulnerability of pretrained language models to character-level adversarial attacks and noise  \citep{SunADV-BERT, eger-benz-2020-hero}, with text normalization typically required to maintain performance \citep{pruthi-etal-2019-combating, keller-etal-2021-bert}.
To evaluate \model{}'s robustness to textual noise and variation and inspired by the robustness tests of \citet{salesky-etal-2021-robust}, we experiment with the \textit{Zeroé} benchmark \citep{eger-benz-2020-hero,keller-etal-2021-bert} which covers a variety of low-level orthographic attacks as illustrated in Table \ref{tab:zeroe-examples}.
We replace their version of visual attacks with the Unicode Technical Standard \#39 set of visually-confusable characters.\footnote{\url{https://util.unicode.org/UnicodeJsps/confusables.jsp}} 
We apply \textit{Zeroé} attacks during finetuning and evaluation of two English downstream tasks, POS tagging and NLI \citep{bowman-etal-2015-large}, where we expect models to rely on different levels of abstraction. 


Figures~\ref{fig:robustness_snli} and \ref{fig:robustness_pos} in Appendix~\ref{app:zeroe} compare \model and \textsc{bert} across three levels of token-level noise for POS tagging and NLI. 
There is little impact on POS tagging performance with either model from most low-level attacks, with the exception of visually-confusable character substitutions (\textsc{confusable}); here \model expectedly maintains performance above 92\% as it generalizes across orthographic similarities but \textsc{bert} drops to 38\%. 
For NLI, both models are negatively affected, but \model exhibits less degradation than \textsc{bert} with higher proportions of noise, with the impact varying across the types of attacks which each affect subword tokenization differently. Figure~\ref{fig:pixel_interpretability} shows relevancy heatmaps \citep{Chefer_2021_ICCV} for SNLI predictions made with and without \textsc{confusable} substitutions. The heatmaps are similarly clear with and without noise, providing qualitative evidence that \model is indeed robust to the noise. 
The illustrated robustness may be dependent upon finetuning, however; we find that \model can struggle in zero-shot applications when text is rendered differently from observed during pretraining (see Appendix~\ref{app:text_renderer} on using different fonts). 
Future work could explore the impact of data augmentation during pretraining on \model's robustness and ability to transfer across scripts. Furthermore, it would be interesting to investigate how the choice of font influences the search space during reconstruction of masked patches \citep{Bland2022StoryBT}.

\begin{wraptable}{r}{0.45\textwidth}
\vspace{-1em}
\setlength\tabcolsep{2pt}
\centering
\resizebox{0.43\textwidth}{!}{\begin{tabular}{lccccc}
\toprule
\multirow{2}{*}{} &
  \multicolumn{2}{c}{POS Tagging} &
  \multicolumn{3}{c}{Named Entity Recognition} \\
 &
  \spanish-\english &
  \hindi-\english &
  \spanish-\english &
  \hindi-\english &
  \modernarabic-\egyptarabic \\ 
\midrule
\tc{\textsc{mbert}} &
  \tc{97.1} &
  \tc{86.3} &
  \tc{64.0} &
  \tc{72.6} &
  \tc{65.4} \\
\midrule
\textsc{bert} &
  \textbf{96.9} &
  {87.0} &
  \textbf{61.1} &
  \textbf{74.5} &
  {59.4} \\
\model &
  {96.8} &
  \textbf{88.2} &
  {61.0} &
  {73.0} &
  \textbf{63.7} \\ 
\bottomrule
\end{tabular}}
\vspace{-0.15cm}
\caption{Code-switching results on \textsc{LinCE}.}
\label{res:cs_results}
\vspace{-0.3cm}
\end{wraptable}

In addition to robustness to orthographic noise, dealing with character-level substitutions is important for effectively modelling different morphological forms.
There are also many types of higher-level token, phrase or sequence-level variations such as code-switching---when a speaker alternates between two or more languages in the same utterance, while being grammatically consistent in each language~\citep{joshi-1982-processing}---or the lexical substitutions in social media text.
We evaluate \model{} on the LinCE benchmark~\citep{aguilar-etal-2020-lince}, which includes core tasks and downstream applications for linguistic code-switching.
\model{} is fine-tuned on POS Tagging and NER in Spanish-English, Hindi-English and Modern Standard Arabic-Egyptian Arabic.
Table~\ref{res:cs_results} shows that \model{} and \textsc{bert} perform similarly on \spanish-\english tasks, with \textsc{bert} outperforming \model{} on NER for (romanised) \hindi-\english.
On the other tasks, \model{} performs better than \textsc{bert} and even outperforms \textsc{mbert} on \hindi-\english POS tagging. The gap between \textsc{mbert} and \model{} is larger on Arabic scripts, which were extensively seen by \textsc{mbert} during pretraining.

\vspace{-2mm}
\section{Related Work}
\label{sec:related_work}
\vspace{-2mm}

\begin{figure*}[!t]
    \centering
    \begin{subfigure}[]{0.31\textwidth}
        {\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{1pt}\fbox{\includegraphics[width=\textwidth]{figures/contra1_0confus_crop.png}}}\caption{0\%, \emph{contradiction}}
    \end{subfigure}
    \quad
    \begin{subfigure}[]{0.31\textwidth}
        {\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{1pt}\fbox{\includegraphics[width=\textwidth]{figures/contra_1_80confus_crop.png}}}\caption{80\%, \emph{contradiction}}
    \end{subfigure}
    \quad
    \begin{subfigure}[]{0.31\textwidth}
        {\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{1pt}\fbox{\includegraphics[width=\textwidth]{figures/entailment1_80confus_crop.png}}}\caption{80\%, \emph{entailment}}
    \end{subfigure}
    \caption{Visual explanations of correct \model predictions (for classes \emph{contradiction} and \emph{entailment}) for NLI examples with 0\% and 80\% \textsc{confusable} substitutions using method by \cite{Chefer_2021_ICCV}, providing qualitative evidence for \model's robustness to character-level noise and the interpretability of its predictions.
    Red heatmap regions represent high relevancy.}
    \label{fig:pixel_interpretability}
    \vspace{-2mm}
\end{figure*}

The question of vocabulary construction is an open problem in NLP, especially in a multilingual context.\footnote{See \citet{DBLP:journals/corr/abs-2112-10508} for a recent, comprehensive survey on open-vocabulary modeling and tokenization.}
The most widely used language models, e.g.\ BERT, RoBERTa, T5, GPT-2 \textit{inter alia}, rely on different tokenizers, such as WordPiece \citep{devlin-etal-2019-bert}, Byte-Pair Encoding \citep[BPE; ][]{sennrich-etal-2016-neural} and Unigram LM \citep{kudo-2018-subword}. There is an established ecosystem around subword tokenizers, such as the SentencePiece \citep{kudo-richardson-2018-sentencepiece} and HuggingFace Tokenizers.

In a monolingual context and for some languages like English, vocabularies of subwords are a good tradeoff between vocabularies of characters and vocabularies of words.
When representing a large number of languages in multilingual PLMs like mBERT and XLM-R, adequately representing the vocabulary of each individual language would be computationally prohibitive. 
The tokenization then becomes a bottleneck when trying to scale up to a large number of languages \citep{conneau-etal-2020-unsupervised, rust-etal-2021-good}, which manifests itself in degraded cross-lingual performance to languages and language families that are underrepresented in the data used for training multilingual PLMs. There are large inequalities in the performance of these models across typologically diverse languages \citep{wu-dredze-2020-languages, lauscher-etal-2020-zero}. 
This issue is further exacerbated by tokenizations out-of-the-box not being compatible across languages \citep{maronikolakis-etal-2021-wine-v}. Language imbalance and poor character coverage in the vocabulary can also decrease downstream performance \citep{zhang2022robust}.
To some extent, these problems can be attenuated through techniques such as subword mapping \citep{vernikos-popescu-belis-2021-subword-mapping}, transliteration \citep{DBLP:journals/corr/abs-2201-12501}, leveraging lexical overlap \citep{patil-etal-2022-overlap}, vocabulary clustering and reallocation \citep{chung-etal-2020-improving}, continued or language-adaptive pretraining \citep{ebrahimi-kann-2021-adapt}, adaptation via bilingual lexica \citep{wang-etal-2022-expanding}, and embedding matrix adaptation \citep{artetxe-etal-2020-cross}. However, these are post-hoc workarounds to expand model vocabularies after training. They do not provide a direct solution to the vocabulary bottleneck problem.

Some subword-based algorithms can also produce undesirable segmentations for morphologically rich languages \citep{klein-tsarfaty-2020-getting, amrhein-sennrich-2021-suitable-subword}, so dedicated morphologically-aware tokenizers have been developed (e.g.\ \citet{smit-etal-2014-morfessor}), but this process often requires expert-level knowledge and may only work for individual languages.

Due to the limitations of subword vocabularies in multilingual language modelling, some works have used vocabularies over characters \citep[][\emph{inter alia}]{lee-etal-2017-fully, ma-etal-2020-charbert} or bytes \citep{DBLP:conf/aaai/WangCG20, DBLP:journals/corr/abs-2101-09469}. These provide benefits over purely subword-based models in terms of robustness and most of them are readily applicable in a multilingual context,\footnote{Character-aware models are not directly applicable to languages that do not use whitespace to delimit sentences \citep{tay2021charformer}, for example.} but they typically come at the cost of increased sequence lengths or latency. Also, such models cannot exploit orthographic similarities between characters across and within scripts and do not account for the fact that meaning of language may be carried visually such as in writing systems that are (partially) logographic like Chinese, in ancient hieroglyphs, or when using emoji.

Finally, some works have developed pixel-based approaches. \cite{broscheit-2018-learning} embedded images of Chinese glyphs but still relied on a fixed vocabulary. 
\cite{Wu2019GlyceGF} combined character-level images and embeddings for a variety of Chinese tasks. 
\cite{DBLP:conf/icml/RadfordKHRGASAM21} trained a linear probe for CLIP, which also incorporates a tokenizer,
on a rendered version of SST-2 \citep{socher-etal-2013-recursive}. Other works have trained pixel-based models that removed the need for a fixed vocabulary: 
\cite{Sun2019SquaredEW} trained a convolutional sentiment classifier on pixels. 
\cite{mansimov-etal-2020-towards} used images of text for in-image MT. 
\cite{salesky-etal-2021-robust} employed a convolutional embedder for a Transformer-based MT system with a subword-based decoder. Our method differs from these in that it provides a general-purpose language encoder that completely removes the need for a vocabulary.

\vspace{-2mm}
\section{Conclusion}
\vspace{-2mm}

This paper introduced \model, a pretrained language model that renders text as images, which allows it to represent any written language that can be typeset using its text renderer. \model was pretrained on the predominantly English Wikipedia and Bookcorpus datasets, and evaluated on part-of-speech tagging, dependency parsing, question answering, and language understanding tasks. The results demonstrate that \model readily transfers to unseen scripts, as shown by its performance on 14 scripts across 32 languages. \model currently lags behind \textsc{bert} when processing languages with a Latin script, including English; however, \model is more robust than \textsc{bert} against low-level orthographic attacks and performs competitively to \textsc{bert} and \textsc{mBert} on linguistic code-switching tasks. Overall, these results show that pixel-based representations are a strong backbone for cross-lingual and cross-script transfer learning. The limitations of this work are discussed in Appendix~\ref{app:limitations}.

In future work, we will investigate inductive biases and additional objectives that can better capture long-range dependencies in \model models. We hope that this will help overcome the limits of \model in semantic processing.
We also plan to pretrain \model on multilingual text with a view to further improving its cross-script and cross-lingual abilities. This will also allow us to more fairly compare pixel-based models against larger subword-based and tokenization-free \textit{multilingual} models. Finally, we will also develop new rendering and finetuning formulations that are better tailored to pixel-based models, e.g. for improving downstream question answering.

\section*{Acknowledgments}
We thank Ákos Kádár, Barbara Plank, and Kris Cao for their comments on an earlier draft. We also thank Davide Rigoni, Rita Ramos, Stella Frank, and members of the CoAStaL and LAMP groups for discussions. Miryam de Lhoneux is funded by the Swedish Research Council (grant 2020-00437). Phillip Rust is funded by the Novo Nordisk Foundation (grant NNF 20SA0066568). Jonas F. Lotz is funded by the ROCKWOOL Foundation (grant 1242). {\scriptsize\euflag} Emanuele Bugliarello is supported by funding from the European Union's Horizon 2020 research and innovation programme under the Marie Sk\l{}odowska-Curie grant agreement No 801199. Elizabeth Salesky is supported by the Apple Scholars in AI/ML fellowship. Desmond Elliott is partially supported by the Innovation Foundation (grant 0176-00013B) and the Novo Nordisk Foundation (grant NNF 20SA0066568). This work was supported by a research grant (VIL53122) from VILLUM FONDEN. The computing power was generously supported by EuroHPC grants 2010PA5869, 2021D02-068, and 2021D05-141, and with Cloud TPUs from Google's TPU Research Cloud (TRC).

\bibliography{bibliography}
\bibliographystyle{iclr2022_conference}

\clearpage
\appendix
\section{Abstract Reconstructions} 
\label{app:abstract_reconstructions}
\begin{figure*}[ht!]
\begin{subfigure}[]{0.32\textwidth}
        \centering
        {\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{1pt}\fbox{\includegraphics[width=\textwidth]{figures/pixel_short_mask_1.png}}}\end{subfigure}\hfill
    \vspace{0.25em}
    \begin{subfigure}[]{0.32\textwidth}
\centering
        {\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{1pt}\fbox{\includegraphics[width=\textwidth]{figures/pixel_short_mask_2.png}}}\end{subfigure}\hfill
    \vspace{0.25em}
    \begin{subfigure}[]{0.32\textwidth}
        \centering
        {\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{1pt}\fbox{\includegraphics[width=\textwidth]{figures/pixel_short_mask_3.png}}}\end{subfigure}
    \vspace{0.5em}
\begin{subfigure}[]{0.32\textwidth}
        \centering
        {\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{1pt}\fbox{\includegraphics[width=\textwidth]{figures/pixel_medium_mask_1.png}}}\end{subfigure}\hfill
    \begin{subfigure}[]{0.32\textwidth}
        \centering
        {\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{1pt}\fbox{\includegraphics[width=\textwidth]{figures/pixel_medium_mask_2.png}}}\end{subfigure}\hfill
    \begin{subfigure}[]{0.32\textwidth}
        \centering
        {\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{1pt}\fbox{\includegraphics[width=\textwidth]{figures/pixel_medium_mask_3.png}}}\end{subfigure}
    \vspace{0.5em}
\begin{subfigure}[]{0.32\textwidth}
        \centering
        {\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{1pt}\fbox{\includegraphics[width=\textwidth]{figures/pixel_medium_mask_4.png}}}\end{subfigure}\hfill
    \begin{subfigure}[]{0.32\textwidth}
        \centering
        {\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{1pt}\fbox{\includegraphics[width=\textwidth]{figures/pixel_medium_mask_5.png}}}\end{subfigure}\hfill
    \begin{subfigure}[]{0.32\textwidth}
        \centering
        {\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{1pt}\fbox{\includegraphics[width=\textwidth]{figures/pixel_medium_mask_6.png}}}\end{subfigure}
    \vspace{0.5em}
        \begin{subfigure}[]{0.32\textwidth}
        \centering
        {\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{1pt}\fbox{\includegraphics[width=\textwidth]{figures/pixel_long_mask_1.png}}}\end{subfigure}\hfill
    \begin{subfigure}[]{0.32\textwidth}
        \centering
        {\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{1pt}\fbox{\includegraphics[width=\textwidth]{figures/pixel_long_mask_2.png}}}\end{subfigure}\hfill
    \begin{subfigure}[]{0.32\textwidth}
        \centering
        {\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{1pt}\fbox{\includegraphics[width=\textwidth]{figures/pixel_long_mask_3.png}}}\end{subfigure}
    \caption{\model image reconstructions of the abstract with different span masks.}
    \label{fig:abstract_reconstructions}
\end{figure*}

\clearpage
\section{Web Text Reconstructions}
\label{app:steps_reconstructions}
\begin{figure*}[ht!]
\begin{subfigure}[]{0.32\textwidth}
        \centering
        {\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{1pt}\fbox{\includegraphics[width=\textwidth]{figures/peanut100k.png}}}\end{subfigure}\hfill
    \vspace{0.25em}
    \begin{subfigure}[]{0.32\textwidth}
        \centering
        {\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{1pt}\fbox{\includegraphics[width=\textwidth]{figures/peanut500k.png}}}\end{subfigure}\hfill
    \vspace{0.25em}
    \begin{subfigure}[]{0.32\textwidth}
        \centering
        {\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{1pt}\fbox{\includegraphics[width=\textwidth]{figures/peanut1m.png}}}\end{subfigure}
    \vspace{0.5em}
\begin{subfigure}[]{0.32\textwidth}
        \centering
        {\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{1pt}\fbox{\includegraphics[width=\textwidth]{figures/penguin100k.png}}}\end{subfigure}\hfill
    \begin{subfigure}[]{0.32\textwidth}
        \centering
        {\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{1pt}\fbox{\includegraphics[width=\textwidth]{figures/penguin500k.png}}}\end{subfigure}\hfill
    \begin{subfigure}[]{0.32\textwidth}
        \centering
        {\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{1pt}\fbox{\includegraphics[width=\textwidth]{figures/penguin1m.png}}}\end{subfigure}
    \vspace{0.5em}
\begin{subfigure}[]{0.32\textwidth}
        \centering
        {\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{1pt}\fbox{\includegraphics[width=\textwidth]{figures/fish_100k.png}}}\caption{100k steps}
    \end{subfigure}\hfill
    \begin{subfigure}[]{0.32\textwidth}
        \centering
        {\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{1pt}\fbox{\includegraphics[width=\textwidth]{figures/fish_500k.png}}}\caption{500k steps}
    \end{subfigure}\hfill
    \begin{subfigure}[]{0.32\textwidth}
        \centering
        {\setlength{\fboxsep}{0pt}\setlength{\fboxrule}{1pt}\fbox{\includegraphics[width=\textwidth]{figures/fish_1m.png}}}\caption{1M steps}
    \end{subfigure}
    \caption{\model image reconstructions after 100k, 500k, and 1M steps of pretraining. We overlay the masked original image with the model's predictions. Images are wrapped into squares and resized for visualization purposes only. The texts were not part of the training data. We see that the fully trained \model (1M) predicts masked spans more clearly and accurately. For longer spans with a larger possible prediction space, multiple predictions may appear together creating blurred text.}
    \label{fig:pretraining_dynamics}
\end{figure*}

Reconstructions of three sources of text\footnote{\url{https://www.nationalpeanutboard.org/peanut-info/our-message.htm}} \footnote{\url{https://www.penguinsinternational.org/2019/07/10/do-penguins-have-knees-and-other-frequently-asked-questions/}} \footnote{\url{https://www.theatlantic.com/science/archive/2021/05/electric-fish-pause/618993/}} after 100K, 500K and 1M pretraining steps. The figure also shows how \model (visually) expresses uncertainty, e.g.\ for reconstructions of long spans where the space of possible outputs is much larger than for short spans, and how it captures long-range dependencies. In the third row, we can for instance see that \model uses context from the beginning of a sequence (\emph{Barack Obama}) to correctly fill in a gap later in the sequence, and vice-versa (\emph{Brienomyrus}).
\section{Code}
\label{app:implementation}

\model is implemented in PyTorch \citep{DBLP:conf/nips/PaszkeGMLBCKLGA19} and built on HuggingFace transformers \citep{wolf-etal-2020-transformers}. We make our code available at \url{https://github.com/xplip/pixel}. Our pretrained \model model, including a large number of intermediate checkpoints, is available at \url{https://huggingface.co/Team-PIXEL/pixel-base} and our finetuned models, including multiple seeds each, are available through the model hub.

\section{Text Renderer Details}
\label{app:text_renderer}

\paragraph{Rendering backend} We experimented with different text rendering backends. Following \citet{salesky-etal-2021-robust}, our first implementation was based on PyGame,\footnote{\url{https://www.pygame.org/}} which \model was also pretrained with. Later on, we switched to a backend based on Pango \citep{taylor-2004-pango} and Cairographics,\footnote{\url{https://www.cairographics.org/}} which has native support for complex text layouts, making it possible to specify fallback fonts, and has faster rendering speed. Without fallback fonts, we would be limited to a maximum number of  glyphs that can fit into a single OpenType or TrueType font file due to a technical limitation.\footnote{See \url{https://en.wikipedia.org/wiki/Unicode_font} for an explanation.} By leveraging fallback fonts, we can theoretically cover all Unicode codepoints, including emojis. 

\paragraph{Fonts} We rely on the Google Noto Sans fonts collection,\footnote{\url{https://fonts.google.com/noto}} which covers the majority of Unicode codepoints and is actively growing.\footnote{See \url{https://notofonts.github.io/overview/} for an overview of Noto's Unicode coverage.}. Note, however, that \model is compatible with any font and can therefore encode anything that can be typeset on a computer screen. We used a font size of 8 at 120 DPI for pretraining with PyGame, which was selected manually to fit most scripts into a rendered height of 16px. It can, however, also be adjusted at finetuning time. For finetuning with PangoCairo, we use a font size of  which yields roughly the same outputs as the PyGame renderer. Due to how glyphs are shaped by the two backends, the outputs of the two renderers do not \emph{exactly} match. Because we did not employ data augmentation to make \model robust to such changes in font size,  we recommend using the PyGame renderer it was pretrained with for \emph{zero-shot} applications with \model. When finetuning, this minor mismatch in rendering outputs is easily overcome by \model, so we generally recommend using the PangoCairo renderer.

\paragraph{Characters versus glyphs} For extractive QA, it is necessary to obtain a mapping between the characters in the context paragraph and where they appear on the rendered image. Obtaining this mapping is not straightforward due to how text is rendered. The \emph{shaping} step in the rendering pipeline converts characters into glyphs.\footnote{See \url{https://docs.gtk.org/Pango/pango_rendering.html} for an overview of the rendering pipeline.} In ligatures, as common for instance in Arabic, a glyph is composed of multiple characters. Likewise, an emoji often consists of a base codepoint and a modifier codepoint (e.g.\ to change the emoji skin colour) which are represented by a single glyph. For accents, on the other hand, one character might yield multiple glyphs.\footnote{\url{https://docs.gtk.org/Pango/pango_fonts.html\#glyphs}} In practice, the renderer therefore uses grapheme clusters, whose logical boundaries in the rendered image we can map to the input characters.\footnote{\url{https://unicode.org/reports/tr29/\#Grapheme\_Cluster\_Boundaries}} For simplicity, we assign each codepoint of a grapheme cluster to the logical horizontal offset at which the cluster starts on the rendered image. Future work may investigate alternative mapping strategies.

\paragraph{RGB rendering} \model supports RGB rendering which may be useful to accurately represent colour emoji and for multimodal applications in the future. However, 24-bit RGB rendering is slightly slower than 8-bit grayscale rendering (see Table~\ref{tab:speed_comparison} below) for text written in Latin script, which is why we made RGB rendering an optional setting. In our pretraining and finetuning experiments we rendered text in grayscale, and we generally recommend doing so when not working with coloured inputs.

\paragraph{Right-to-left scripts} \model's renderer natively supports right-to-left (RTL) writing. In the default setting, the base text direction (which for instance determines on which side of a sentence punctuation marks are placed) is inferred automatically by the rendering backend based on the first ``strong directional'' character in a given paragraph.\footnote{See \url{https://unicode.org/reports/tr9/} for an overview of the Unicode bidi algorithm.} The mirroring of RTL characters is also handled automatically according to their Unicode bidi attributes.
Optionally, the base text direction can be set manually, which is useful when working on monolingual data, e.g.\ in Arabic or Hebrew, as the renderer does not have to go through the direction check. In \S \ref{app:limitations}, we describe limitations of how we currently handle RTL writing.

\begin{figure*}[ht]
  \centering
  \includegraphics[width=0.75\textwidth]{figures/sentence_length.pdf}\caption{Distributions of sentence lengths from monolingual UD corpora after tokenizing by \textsc{bert} and \textsc{mbert} and rendering by \model, compared to the reference by UD treebank annotators.}
  \label{fig:ud_sent_len}
\end{figure*}

\begin{table*}[h]
\centering
\resizebox{0.48\textwidth}{!}{\begin{tabular}{@{}lccc@{}}
\toprule
Processor & Batched & \multicolumn{2}{c}{Throughput [ex / s]} \\
 &  & ~~\textsc{eng} & ~~\textsc{zho} \\ \midrule
Renderer (Grayscale)   & \xmark  & ~~3944.1 & ~~6309.0            \\
Renderer (RGB)         & \xmark  & ~~3615.1 & ~~6849.5            \\
\midrule
\multirow{2}{*}{Tokenizer (Rust)}   & \cmark  & \textbf{19128.9} & \textbf{18550.5}  \\
                                         & \xmark  & ~~4782.9 & ~~5684.4           \\
\midrule
\multirow{2}{*}{Tokenizer (Python)} & \cmark  & ~~1286.6 &  ~~2637.1          \\
                                         & \xmark  &   ~~1286.8  &  ~~2580.9             \\ \bottomrule
\end{tabular}}
\caption{Throughput comparison between \model's PangoCairo renderer and the fast and slow \textsc{bert} tokenizers, implemented in Rust and Python respectively, from the HuggingFace tokenizers library. We estimate throughput, measured in examples per second, by how long it takes to process 1M lines of English (\textsc{eng}) and Chinese (\textsc{zho}) Wikipedia text on the same desktop workstation (AMD Ryzen 9 3900X 12-core CPU). We distinguish between tokenizing all lines individually (Batched = \xmark) and as one single batch (\cmark).
}

\label{tab:speed_comparison}
\end{table*}

\paragraph{Efficiency analysis}

We briefly analyze the text processing (rendering versus tokenizing) efficiency in terms of a) length of the processed sequence, which has a direct effect on GPU memory consumption and the time it takes to compute forward and backward passes, and b) processing throughput.

For a), we follow \cite{rust-etal-2021-good} and process the training and validation splits of all available UD v2.10 treebanks in various languages with the \model renderer and the tokenizers of \textsc{bert} and \textsc{mbert}. We plot the resulting sentence length distributions in Figure~\ref{fig:ud_sent_len}, including a comparison with the reference segmentations from the UD annotators. For English text, the \model renderer is slightly less efficient, i.e., it produces slightly longer sequences on average than the tokenizers. For other languages with Latin script, e.g. Finnish and Turkish, the renderer is more efficient than the \textsc{bert} tokenizer, albeit slightly less efficient than the \textsc{mbert} tokenizer. For non-Latin scripts such as Arabic and Japanese, we see that the renderer can be a lot more efficient than both tokenizers. The English \textsc{bert} tokenizer is technically fairly space-efficient for non-Latin scripts but this is misleading because it largely produces {\footnotesize{[\texttt{UNK}]}}s (recall right side of Table~\ref{res:syntactic_task_results}) and each {\footnotesize{[\texttt{UNK}]}} is a single token; the functionality of the \textsc{bert} model on a sequence of {\footnotesize{[\texttt{UNK}]}} is strongly compromised.

For b), we compare the processing throughput of HuggingFace's \textsc{bert} tokenizers and our \model renderer in Table~\ref{tab:speed_comparison}. We find that the Rust-based \textsc{bert} tokenizer with batch processing achieves the highest throughput by leveraging parallelization. When not using batch processing, it is comparable in throughput with \model's renderer, i.e. depending on the language or script, rendering can be slightly slower (\textsc{eng}) or faster (\textsc{zho}) than tokenizing. Since the rendering backend (PangoCairo) is implemented in C, we expect to achieve similar gains in rendering throughput by also leveraging parallelization for batch processing (in contrast to the Python-based tokenizer which is limited by Python's global interpreter lock (GIL)). We plan to implement batch rendering functionality in the future.


\section{Architecture \& Pretraining Details}
\label{app:architecture_details}

\begin{table}[H]
\centering
\resizebox{0.75\textwidth}{!}{\begin{tabular}{@{}ll@{}}
\toprule
\textsc{parameter}            & \textsc{value} \\ \midrule
Image size                    & (16, 8464, 3)  \\
Patch size                    & 16             \\
Encoder hidden size  & 768            \\
Encoder intermediate size     & 3072           \\
Encoder num attention heads   & 12             \\
Encoder num layers         & 12             \\
Decoder hidden size  & 512            \\
Decoder intermediate size     & 2048           \\
Decoder num attention heads   & 16             \\
Decoder num layers         & 8              \\
Layer norm  \citep{DBLP:journals/corr/BaKH16}       & \num{1e-12}    \\
Span masking ratio                 & 0.25           \\
Span masking max length  & 6 \\
Span masking cumulative weights  &  \\
Span masking spacing & Dynamic \\
Dropout probability           & 0.1            \\ 
Hidden activation & GeLU \citep{DBLP:journals/corr/HendrycksG16} \\
Optimizer              & AdamW \citep{loshchilov2018decoupled, kingma-ba-2015-adam}                \\
Adam      & (0.9, 0.999) \\
Adam        & \num{1e-8}     \\
Weight decay               & 0.05           \\
Peak learning rate         & \num{1.5e-4}   \\
Learning rate schedule & Cosine Decay \citep{DBLP:conf/iclr/LoshchilovH17}                         \\
Minimum learning rate      & \num{1e-5}     \\
Learning rate warmup ratio & 0.05           \\
Training steps             & 1M             \\
Batch size                 & 256       \\ \bottomrule
\end{tabular}}
\caption{\model pretraining settings}
\label{tab:pretraining_settings}

\end{table}

\begin{figure*}[t]
    \centering
    \includegraphics[width=\textwidth]{figures/pretrain_loss.pdf}
    \caption{\model pretraining loss curve}
    \label{fig:training_loss}
\end{figure*}

\paragraph{Patch Embeddings} \model reshapes each image  into a sequence of  non-overlapping flattened 2D patches , where  is the patch size, and linearly projects them via  to obtain patch embeddings  with encoder hidden size .\footnote{This is equivalent to projecting each rendered image  via a 2D-convolutional layer with  input channels and  output channels and kernel size and stride both equal to the patch size , which we do in practice.} Afterwards, fixed sinusoidal position embeddings  are added, leaving out the position vector in position~0 for a classification (CLS) embedding later: .

\paragraph{Span Masking} \model then masks out  of the  embedded patches via span masking with max span length  and cumulative span weights , i.e. , as outlined in Algorithm~\ref{algo:span_masking}. Applying the mask , we obtain the unmasked patches .

\paragraph{Encoder} Following ViT-MAE \citep{he-etal-2022-mae}, the \model encoder only operates on unmasked patches (i.e.,  396 patches at 25\% masking) and a special CLS embedding with its positional encoding  is prepended to the sequence: .\footnote{In pretraining, no loss is computed for the CLS embedding but it can optionally be used when finetuning \model for sequence-level downstream tasks.} Let  be the encoder hidden states after each of the  encoder transformer layers, and  denotes the input sequence. The outputs of each transformer layer are computed as detailed in \citep{DBLP:conf/nips/VaswaniSPUJGKP17}, \footnote{Note that encoder and decoder do not attend to the blank (padding) patches that appear after the {\footnotesize \texttt{EOS}} patch.} and the last layer's output  is passed to the decoder.

\paragraph{Decoder} The \model decoder first projects the encoder outputs via  to obtain decoder embeddings , where .
Next, mask embeddings  are inserted at the masked-out positions and fixed sinusoidal position embeddings are added to obtain
.  are the decoder hidden states after each of the  decoder transformer layers, computed in the same way as the encoder hidden states, and  denotes the input sequence. There is no encoder-decoder cross-attention. The decoder output  is projected via  to obtain patch-wise logits . Finally, the CLS logits are removed and a normalized mean squared error (MSE) pixel reconstruction loss is computed:  with  denoting the indices in the set of \emph{masked, non-blank (text)} patches  and  dividing the difference between the target patch and its mean by its standard deviation.

\section{Finetuning Details}
\label{app:finetuning_details}
Table~\ref{tab:language_overview} gives an overview of all languages used in our finetuning experiments, Table~\ref{tab:dataset_overview} links to our finetuning datasets, and Table~\ref{tab:treebank_overview} lists the UD treebanks we used.

We list our finetuning recipes in Table~\ref{tab:finetuning_details1} for \textsc{pos} tagging, dependency parsing, \textsc{ner}, \textsc{qa}, and \textsc{xnli} and in Table~\ref{tab:finetuning_details2} for the GLUE tasks. Due to compute limitations we did not run comprehensive hyperparameter sweeps. Instead, we relied on sensible priors from finetuning \textsc{bert} and made slight modifications as needed. In most cases, hyperparameters that work well for \textsc{bert} also work well for \model. For some of the semantic tasks, in particular \textsc{nli} and \textsc{sst-}{\footnotesize2}, we found that some random initializations did not converge. In those cases, minor tweaks to the learning rate or increasing the batch size usually helped. For \textsc{glue}, we found that \model performed slightly better on some tasks with the PangoCairo renderer, whereas for others, using the PyGame renderer (which \model was pretrained with) was more stable. We plan to further optimize the training recipes and study \model's convergence behaviour in the future. 

For word-level tasks, we add padding in order to render each word at the start of a new image patch and so create a bijective mapping between words and patches.
Doing so assumes that word boundaries are available. We note that subword-based and character-based models also make this assumption. In \textsc{bert}, for instance, word-level tasks are formulated such that a word's label is assigned to its first subword token, requiring word boundaries. During training, continuation tokens are then masked out when computing the loss. Consequently, predictions for continuation tokens also need to be masked out at inference time, which again requires word boundaries or aggregation strategies that may introduce errors. The same applies to character-based models. For \model, should this assumption be violated, it is still possible to render the text without adding spacing, although the mapping is then no longer bijective as multiple words can overlap on one image patch. In such cases, assigning the prediction for a patch to either word can cause loss of information. Although in practice this approach does not necessarily affect performance negatively, future work will investigate alternative approaches.

\begin{table*}[ht]
\centering
\resizebox{0.6\textwidth}{!}{\begin{tabular}{@{}llll@{}}
\toprule
Language     & ISO 639-3    & Language Family & Script       \\ \midrule
Amharic      & \amharic     & Afro-Asiatic    & Ge\fontencoding{T3}\selectfont{\textrevapostrophe}ez        \\
Arabic       & \arabi       & Afro-Asiatic    & Arabic       \\
Bengali      & \bengali     & Indo-European   & Bengali      \\
Bulgarian    & \bulgarian   & Indo-European   & Cyrillic     \\
Chinese      & \chinese     & Sino-Tibetan    & Chinese      \\
Coptic       & \coptic      & Afro-Asiatic    & Coptic       \\
English      & \english     & Indo-European   & Latin        \\
Finnish      & \finnish     & Uralic          & Latin        \\
French       & \french      & Indo-European   & Latin        \\
German       & \german      & Indo-European   & Latin        \\
Greek        & \greek       & Indo-European   & Greek        \\
Hausa        & \hausa       & Afro-Asiatic    & Latin        \\
Hindi        & \hindi       & Indo-European   & Devanagari   \\
Igbo         & \igbo        & Niger-Congo     & Latin        \\
Indonesian   & \indonesian  & Austronesian    & Latin        \\
Japanese     & \japanese    & Japonic         & Japanese     \\
Kinyarwanda  & \kinyarwanda & Niger-Congo     & Latin        \\
Korean       & \korean      & Koreanic        & Korean       \\
Luganda      & \luganda     & Niger-Congo     & Latin        \\
Luo          & \luo         & Nilo-Saharan    & Latin        \\
Naija Pidgin & \naija       & English Creole  & Latin        \\
Russian      & \russian     & Indo-European   & Cyrillic     \\
Spanish      & \spanish     & Indo-European   & Latin        \\
Swahili      & \swahili     & Niger-Congo     & Latin        \\
Tamil        & \tamil       & Dravidian       & Tamil        \\
Telugu       & \telugu      & Dravidian       & Telugu       \\
Thai         & \thai        & Kra-Dai         & Thai         \\
Turkish      & \turkish     & Turkic          & Latin        \\
Urdu         & \urdu        & Indo-European   & Perso-Arabic \\
Vietnamese   & \vietnamese  & Austro-Asiatic  & Latin        \\
Wolof        & \wolof       & Niger-Congo     & Latin        \\
Yorùbá       & \yoruba      & Niger-Congo     & Latin        \\ \bottomrule
\end{tabular}}
\caption{Overview of languages used in our experiments.}
\label{tab:language_overview}
\end{table*}

\begin{table*}[t]
\centering
\resizebox{\textwidth}{!}{\begin{tabular}{@{}lll@{}}
\toprule
Dataset      & Download Link                                                                         & Reference \\ \midrule
Universal Dependencies 2.10 & \url{https://lindat.mff.cuni.cz/repository/xmlui/handle/11234/1-4758} & \citep{zeman-etal-2022-ud, nivre-etal-2020-universal} \\
MasakhaNER                  & \url{https://github.com/masakhane-io/masakhane-ner/tree/main/data}       &  \citep{adelani-etal-2021-masakhaner} \\
GLUE         & \url{https://huggingface.co/datasets/glue}     & \citep{wang-etal-2018-glue}          \\
TyDiQA-GoldP & \url{https://huggingface.co/datasets/tydiqa} &  \citep{clark-etal-2020-tydi}         \\
SQuADv1.1    & \url{https://huggingface.co/datasets/squad}   &  \citep{rajpurkar-etal-2016-squad}         \\
KorQuAD 1.0                 & \url{https://huggingface.co/datasets/squad\_kor\_v1}                                   & \citep{lim-etal-2019-korquad} \\
JaQuAD                      & \url{https://huggingface.co/datasets/SkelterLabsInc/JaQuAD}                     &  \citep{so2022jaquad} \\
XNLI         & \url{https://huggingface.co/datasets/xnli}     & \citep{conneau-etal-2018-xnli} \\ \bottomrule          
\end{tabular}}
\caption{Links and references to the datasets we used in our finetuning experiments.}
\label{tab:dataset_overview}
\end{table*}

\begin{table*}[ht]
\centering
\resizebox{0.6\textwidth}{!}{\begin{tabular}{@{}llrl@{}}
\toprule
Language    & Treebank           & \#Sentences  & Reference \\ \midrule
\english    & English-EWT        & 16621        &  \citet{silveira-etal-2014-gold}\\
\arabi      & Arabic-PADT        & 7664         & \citet{hajivc2009prague}\\
\coptic     & Coptic-Scriptorium & 2011         & \citet{zeldes-abrams-2018-coptic}\\
\hindi      & Hindi-HDTB         & 16647        & \citet{Palmer2009HindiSA}\\
\japanese   & Japanese-GSD       & 8100         & \citet{asahara-etal-2018-universal}\\
\korean     & Korean-GSD         & 6339         & \citet{chun-etal-2018-building}\\
\tamil      & Tamil-TTB          & 600          & \citet{ramasamy-zabokrtsky-2012-prague}\\
\vietnamese & Vietnamese-VTB     & 3000         & \citet{nguyen-etal-2009-building}\\
\chinese    & Chinese-GSD        & 4997         & \citet{shen-etal-2016-chinese}\\ \bottomrule
\end{tabular}}
\caption{Overview of the Universal Dependencies v2.10 \citep{zeman-etal-2022-ud, nivre-etal-2020-universal} treebanks used in our POS tagging and dependency parsing experiments with the number of sentences in their respective training splits. As mentioned in \S\ref{sec:tasks_languages}, these treebanks were chosen with typological and script diversity in mind.}
\label{tab:treebank_overview}
\end{table*}

\begin{table}[ht]
\centering
\resizebox{0.65\textwidth}{!}{\begin{tabular}{@{}lccccc@{}}
\toprule
\textsc{parameter} & \textsc{pos} & \textsc{dp}                  & \textsc{ner} & \textsc{qa}                             & \textsc{xnli} \\ \midrule
Rendering backend                   & \multicolumn{5}{c}{PangoCairo}        \\
Classification head pooling & --- & --- & --- & --- & CLS \\
Optimizer                  & \multicolumn{5}{c}{AdamW}             \\
Adam                & \multicolumn{5}{c}{(0.9, 0.999)}      \\
Adam             & \multicolumn{5}{c}{\num{1e-8}}        \\
Weight decay               & \multicolumn{5}{c}{0}                 \\
Learning rate      & \num{5e-5}   &  & \num{5e-5}   &  & \num{2e-5}    \\
Learning rate warmup steps & 100   & 100   & 100   & 100   & 1000  \\
Learning rate schedule     & \multicolumn{5}{c}{Linear decay}      \\
Max sequence length        & 256   & 256   & 196   & 400   & 196   \\
Stride                     & ---   & ---   & ---   & 160   & ---   \\
Batch size                 & 64    & 64    & 64    & 32    & 256   \\
Max steps                  & 15000 & 15000 & 15000 & 20000 & 50000 \\
Early stopping              & \multicolumn{5}{c}{\checkmark}                                      \\
Eval steps                 & 500   & 500   & 500   & 500   & 1000  \\
Dropout probability              & \multicolumn{5}{c}{0.1}               \\ \bottomrule
\end{tabular}}
\caption{Finetuning settings for \textsc{pos} tagging, dependency parsing (\textsc{dp}), \textsc{ner}, \textsc{qa}, and \textsc{xnli}. We did not run a comprehensive hyperparameter search due to compute limitations; these settings were manually selected based on a small number of preliminary runs. Maximum performance was often reached well before the specified number of max steps.}
\label{tab:finetuning_details1}
\end{table}

\begin{table}[ht]
\centering
\resizebox{\textwidth}{!}{\begin{tabular}{@{}lccccccccc@{}}
\toprule
\textsc{parameter} & \textsc{mnli} & \textsc{qqp} & \textsc{qnli} & \textsc{sst-2} & \textsc{cola} & \textsc{sts-b} & \textsc{mrpc} & \textsc{rte} & \textsc{wnli} \\ \midrule
Rendering backend           & PangoCairo    & PyGame       & PangoCairo    & PyGame         & PyGame        & PyGame         & PyGame        & PyGame       & PyGame        \\
Classification head pooling & \multicolumn{9}{c}{Mean}                                            \\
Optimizer                   & \multicolumn{9}{c}{AdamW}                                           \\
Adam                 & \multicolumn{9}{c}{(0.9, 0.999)}                                    \\
Adam              & \multicolumn{9}{c}{\num{1e-8}}                                      \\
Weight decay                & \multicolumn{9}{c}{0}                                               \\
Learning rate      & \num{3e-5}    & \num{3e-5}   & \num{3e-5}    & \num{3e-5}     & \num{2e-5}    & \num{2e-5}     & \num{3e-5}    & \num{3e-5}   & \num{1e-5}    \\
Learning rate warmup steps  & 100   & 100   & 100   & 100   & 200   & 100   & 100   & 200   & 100 \\
Learning rate schedule      & \multicolumn{9}{c}{Linear decay}                                    \\
Max sequence length         & \multicolumn{9}{c}{256}                                             \\
Batch size                  & 64    & 256   & 64    & 256   & 256   & 64    & 64    & 64    & 256 \\
Max steps                   & 15000 & 15000 & 15000 & 15000 & 15000 & 15000 & 15000 & 15000 & 400 \\
Early stopping              & \multicolumn{9}{c}{\checkmark}                                      \\
Eval interval      & 500 steps     & 500 steps    & 500 steps     & 500 steps      & 100 steps     & 100 steps      & 100 steps     & 250 steps    & 1 epoch       \\
Dropout probability                & \multicolumn{9}{c}{0.1}                                             \\ \bottomrule
\end{tabular}}
\caption{Finetuning settings for \textsc{glue} tasks. We did not run a comprehensive hyperparameter search due to compute limitations; these settings were manually selected based on a small number of preliminary runs. Increasing the batch size to 256 and switching to the PyGame renderer helped achieve more consistent convergence behaviour for some tasks. For the smaller datasets (to the right of \textsc{qqp}), maximum performance was reached well before the specified number of max steps.}
\label{tab:finetuning_details2}
\end{table}

\clearpage

\section{Examples of \textit{Zeroé} orthographic attacks}
\label{app:zeroe}
\begin{table}[h]
\vspace{-1em}
\centering
\resizebox{0.49\textwidth}{!}{
\setlength\tabcolsep{10pt} 
\begin{tabular}{ll}
    \toprule
    Attack & Sentence \\ 
    \midrule
    \tc{\textsc{None}} & \tc{Penguins are designed to be streamlined} \\
    \midrule
    \textsc{Confusable} & \includegraphics[width=0.42\textwidth]{figures/penguins_confusable.png} \\ 
    \textsc{Shuffle (inner)} & Pegnuins are dnesiged to be sieatrnmled \\
    \textsc{Shuffle (full)} & ngePnius rae dsgednei to be etimaslernd \\
    \textsc{Disemvowel} & Pngns r dsgnd to be strmlnd \\
    \textsc{Intrude} & Pe`nguins a\{re d)esigned t;o b*e stre\textless{}amlined \\
    \textsc{Keyboard typo} & Penguinz xre dwsigned ro ne streamllned \\
    \textsc{Natural noise} & Penguijs ard design4d ti bd streamlinfd \\
    \textsc{Truncate} & Penguin are designe to be streamline \\
    \textsc{Segmentation} & Penguinsaredesignedtobestreamlined \\
    \textsc{Phonetic} & Pengwains's ar dhiseind te be storimlignd \\
    \bottomrule
\end{tabular}
}
\caption{Examples of low-level orthographic attacks based on the \textit{Zeroé} benchmark.}
\label{tab:zeroe-examples} 
\end{table}

\begin{figure}[ht!]
  \centering
  \includegraphics[width=0.74\textwidth]{figures/robustness_snli.pdf}\caption{Test set accuracy for a single run of \model{} and \textsc{bert} across different levels of noise introduced through various orthographic attacks in SNLI. The results show that \model is more robust than \textsc{bert} to most of these attacks.}
  \label{fig:robustness_snli}
\end{figure}

\begin{figure}[ht!]
  \centering
  \includegraphics[width=0.75\textwidth]{figures/robustness_pos.pdf}\caption{Test set accuracy for a single run of \model{} and \textsc{bert} across different levels of noise introduced through various orthographic attacks in POS tagging. The results show that \model is more robust than \textsc{bert} to most of these attacks, especially when dealing with visually-confusable character substitutions. \textsc{Segmentation} is not applied to the task of POS tagging, since the joined words would not have a proper tag.}
  \label{fig:robustness_pos}
\end{figure}

\section{Font Transfer Analysis}
\label{app:font_transfer}

In this section, we analyse the adaptation capabilities of \model to new fonts at finetuning time. Specifically, we finetune \model models for POS tagging and dependency parsing on the UD\_English-EWT treebank and sentiment analysis on SST-2, once with a font similar to our  {\footnotesize \texttt{GoNotoCurrent / NotoSans-Regular}} pretraining font, {\footnotesize \texttt{NotoSerif-Regular}}, and once with a font strikingly different from it, {\footnotesize\texttt{JournalDingbats1}}. We compare the three fonts in Table~\ref{tab:font_transfer_examples} below:

\begin{table}[ht]
\centering
\resizebox{0.6\textwidth}{!}{\begin{tabular}{ll}
    \toprule
    Font & Rendered Example Sentence \\ 
    \midrule
    {\footnotesize \texttt{GoNotoCurrent}} & \includegraphics[width=0.5\textwidth]{figures/notosans-example.png} \\ 
    {\footnotesize \texttt{NotoSerif-Regular}} & \includegraphics[width=0.5\textwidth]{figures/notoserif-example.png} \\ 
    {\footnotesize\texttt{JournalDingbats1}} & \includegraphics[width=0.5\textwidth]{figures/journaldingbats1-example.png} \\
    \bottomrule
\end{tabular}
}
\caption{An example sentence rendered in three different fonts.}
\label{tab:font_transfer_examples} 
\end{table}

\begin{table*}[ht]
\centering
\resizebox{0.6\textwidth}{!}{\begin{tabular}{@{}lccc@{}}
\toprule
      & {\footnotesize \texttt{GoNotoCurrent}} & {\footnotesize \texttt{NotoSerif-Regular}} & {\footnotesize\texttt{JournalDingbats1}} \\ \midrule
POS   & 96.7                    & 95.9                        & 93.9                          \\
DP    & 90.6                    &  88.1                           & 81.3                          \\
SST-2 & 89.6                    & 84.2                        & 72.9                          \\ \bottomrule
\end{tabular}}
\caption{Results for fine-tuning \model for POS tagging, dependency parsing (DP), and sentiment analysis on SST-2 with three different fonts: the font used in pretraining ({\footnotesize \texttt{GoNotoCurrent}}), a visually similar font ({\footnotesize \texttt{NotoSerif-Regular}}), and a highly dissimilar font ({\footnotesize\texttt{JournalDingbats1}}). We report test accuracy for POS, test LAS for DP, and validation accuracy for SST-2, each averaged over 5 runs.}
\label{tab:font_transfer_results}
\end{table*}

The font transfer results are shown in Table~\ref{tab:font_transfer_results}. We find that \model exhibits fairly high font transfer ability \emph{out-of-the-box}, i.e. without any font or image augmentation strategies employed during pretraining.\footnote{We believe such augmentation strategies would further improve robustness to font variations and leave this experiment to future work. Considering that we have full control over the font when working with NLP text datasets, robustness to font variations was not a primary goal in this work.} In line with our expectations, transfer to a visually similar font ({\footnotesize \texttt{NotoSerif-Regular}}) is easier than to a dissimilar font ({\footnotesize\texttt{JournalDingbats1}}). Nevertheless, \model is able to transfer surprisingly well to the {\footnotesize\texttt{JournalDingbats1}} font, in which every letter is simply mapped to the icon of an object or animal. 

\section{Further analysis}
\label{app:analysis}

To investigate where \model currently lags behind \textsc{bert}, we analyse the impact that dependency length has on both models in dependency parsing in \english. 
We can see in Figure~\ref{fig:en_dep_len} that the LAS gap between \textsc{bert} and \model increases with longer dependencies, indicating that \model struggles slightly more with long syntactic dependencies.


\begin{figure*}[ht!]
  \centering
\includegraphics[scale=0.3]{figures/dep_length.pdf} 
\caption{LAS scores (\english) across different dependency lengths averaged over 5 random intitializations of \textsc{bert} and \model. In \english, long syntactic dependencies are more challenging for \model.}
\label{fig:en_dep_len}
\vspace{2em}
\end{figure*}

\begin{table*}[htp]
\centering
\resizebox{\textwidth}{!}{\begin{tabular}{lccccccccccccccccc}
\toprule
   &
  \textsc{\#l} &
   &
  \english &
  \arabi &
  \bulgarian &
  \german &
  \greek &
  \french &
  \hindi &
  \russian &
  \spanish &
  \swahili &
  \thai &
  \turkish &
  \urdu &
  \vietnamese &
  \chinese \\ \midrule
\tc{\textsc{mbert}} & \tc{104} & \tc{179M} & \tc{83.3}  & \tc{73.2}  & \tc{77.9}  & \tc{78.1}  & \tc{75.8}  & \tc{78.5}  & \tc{70.1}  & \tc{76.5}  & \tc{79.7}  & \tc{67.2} & \tc{67.7} & \tc{73.3} & \tc{66.1}  & \tc{77.2}  & \tc{77.7}           \\ \midrule
\textsc{bert} &
  \quad 1 &
  110M &
  \textbf{83.7} &
  \textbf{64.8} &
  \textbf{69.1} &
  \textbf{70.4} &
  \textbf{67.7} &
  \textbf{72.4} &
  \textbf{59.2} &
  \textbf{66.4} &
  \textbf{72.4} &
  \textbf{62.2} &
  35.7 &
  \textbf{66.3} &
  \textbf{54.5} &
  \textbf{67.6} &
  46.2 \\
\model         & \quad 1   & ~~86M  & 77.2 & 58.9 & 66.5 & 68.0 & 64.9 & 69.4 & 57.8 & 63.4 & 70.3 & 60.8 & \textbf{50.2} & 64.0 & 54.1 & 64.8 & \textbf{52.0} \\ \bottomrule
\end{tabular}}
\caption{Results for \model and \textsc{bert} finetuned on XNLI in the \emph{translate-train-all} setting where we train on the joint training data in all 15 languages, originally translated from \english by \cite{conneau-etal-2018-xnli}. We report test set accuracy averaged over 5 runs each. Despite the relatively large performance gap in favor of \textsc{bert} in \english (which is in line with the GLUE results in Table~\ref{res:glue_results}), the gap is much smaller for other languages, particularly those not using the Latin writing system. \model is overall more consistent across scripts, outperforming \textsc{bert} in \thai and \chinese.}
\label{res:xnli}
\end{table*}


\section{Limitations}
\label{app:limitations}
This paper introduces a new approach to processing written language as images, which removes the need for a finite vocabulary, providing a solution to the \emph{vocabulary bottleneck}. While our results show that \model is a promising approach in this direction, this is only the first step.
Here, we highlight current limitations and avenues for future work for pixel-based models:
\begin{itemize}
\itemsep-0.04em
\item \model is pretrained on predominantly English text written in the Latin script. The choice of English is driven by the scientific goal of comparing against a widely used model (English \textsc{bert}) but English may not be the best source language for cross-lingual transfer \citep{turc2021revisiting,blevins2022analyzing}.
We expect that \model{} trained on typologically diverse languages in multiple scripts would considerably surpass the cross-script and cross-lingual transferability of English-only \model{} but this remains to be verified, and training a model on large amounts of data will require large computational resources. 
\item \model currently seems to be less sample-efficient than subword-based PLMs. \model{} excels at syntactic tasks after being pretrained for the same number of steps/datapoints as \textsc{bert} (a challenging setup within an academic budget), but still lags behind in semantic processing.
As a consequence, it also requires more training steps  than \textsc{bert} to converge during finetuning.
Closing this gap might involve longer pretraining with additional (long-dependency) objectives.
\item There are challenges to be addressed when working with languages written right-to-left. \model{} currently processes sentences in such languages from the end to the beginning which may lead to learning inadequate features for sentence separation and position embeddings.
\item \model cannot be used for language generation tasks because it is not possible to produce discrete words from the pretrained decoder.

\item Rendering text as images requires more disk space than reading text from a file. This can be alleviated by caching the dataset in a compressed format, or rendering the images on-the-fly. Rendering images on-the-fly will create additional overhead when training for multiple epochs.

\end{itemize}

\end{document}
