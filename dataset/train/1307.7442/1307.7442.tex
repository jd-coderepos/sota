\documentclass[submission,copyright,creativecommons]{eptcs}
\providecommand{\event}{EXPRESS/SOS 2013} \usepackage{breakurl}             

\usepackage{svn-multi}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{verbatim} 
\usepackage{stmaryrd}
\usepackage{paralist}
\usepackage{cite}
\usepackage{appendix}
\usepackage{url}
\usepackage[]{units}
\usepackage{tikz}
\usepackage{subfig}
\usetikzlibrary{calc,arrows,positioning}
\allowdisplaybreaks

\svnid{}

\DeclareFontFamily{U}{mathb}{\hyphenchar\font45}
\DeclareFontShape{U}{mathb}{m}{n}{
      <5> <6> <7> <8> <9> <10> gen * mathb
      <10.95> mathb10 <12> <14.4> <17.28> <20.74> <24.88> mathb12
}{}
\DeclareSymbolFont{mathb}{U}{mathb}{m}{n}
\DeclareMathSymbol{\sqdoublecup} {2}{mathb}{"5F} \DeclareMathSymbol{\boxplus} {2}{mathb}{"60} 



\usepackage[amsmath]{ntheorem}
\makeatletter
\renewtheoremstyle{plain}{\item[\hskip\labelsep \theorem@headerfont ##1\ ##2\theorem@separator]}{\item[\hskip\labelsep \theorem@headerfont ##1\ ##2, ##3\theorem@separator]}
\makeatother



\newcommand{\dupl}[2]{\mathit{dupl}\!_{\rho}(#1)(#2)}

\newcommand{\SOSrule}[2]{\frac{\displaystyle #1}{\displaystyle #2}}
\newcommand{\vect}[1]{\overrightarrow{#1}}
\newcommand{\Rz}{\mathbb{R}_{\ge 0}}

\newcommand{\bisim}{\sim}
\newcommand{\relR}{\mathrel{\textsf{R}}}

\newcommand{\closed}[1]{{#1}\text{-closed}}

\newcommand{\DT}{\textsf{DT}}
\newcommand{\DFDT}{\textsf{DFDT}}
\newcommand{\MT}{\textsf{MT}}

\newcommand{\N}{\mathbb{N}} \newcommand{\Ninfty}{\mathbb{N}^\infty} \newcommand{\Z}{\mathbb{Z}} \newcommand{\Q}{\mathbb{Q}} \newcommand{\R}{\mathbb{R}} 

\newcommand{\powerset}{\mathscr{P}}

\newcommand{\cardof}[1]{|{#1}|}

\newcommand{\ddedrule}[2]{\frac{\displaystyle #1}{\displaystyle #2}}
\newcommand{\dedrule}[2]{\frac{#1}{#2}}
\newcommand{\trans}[1][]{\xrightarrow{\, {#1} \, }}
\newcommand{\ntrans}[1][]{\mathrel{{\trans[#1]}\makebox[0em][r]{\hspace{2ex}}}{\!}}
\newcommand{\ptrans}[1][]{\ \tikz[baseline=-0.5ex]{ \path[->] (0,0) [dotted] edge node [above] {{\tiny }} (0.5,0);}\ }

\newcommand{\gtgeq}{\trianglerighteq}

\newcommand{\strans}[1][]{\stackrel{#1}{\longrightarrow}}


\newcommand{\tuple}[1]{\langle{#1}\rangle}

\newcommand{\rank}{\mathop{\sf r}}
\newcommand{\openT}{\mathbb{T}}
\newcommand{\openLT}{\mathbb{LT}}
\newcommand{\openTerms}{\openT(\Sigma)}
\newcommand{\closedTerms}{T(\Sigma)}
\newcommand{\LopenTerms}{\openLT(\Sigma)}
\newcommand{\LclosedTerms}{LT(\Sigma)}
\newcommand{\openDT}{\mathbb{DT}}
\newcommand{\openDTerms}{\openDT(\Sigma)}
\newcommand{\closedDTerms}{\DT(\Sigma)}
\newcommand{\Var}{\ensuremath{\textstyle{\Countvar}}}
\newcommand{\pprem}[1]{\textrm{pprem}(#1)}
\newcommand{\nprem}[1]{\textrm{nprem}(#1)}
\newcommand{\qprem}[1]{\textrm{qprem}(#1)}
\newcommand{\prem}[1]{\textrm{prem}(#1)}
\newcommand{\conc}[1]{\textrm{conc}(#1)}
\newcommand{\reduce}[1]{\textrm{Reduce}(#1)}
\newcommand{\Red}[2]{\textrm{Red}}
\newcommand{\nvdg}{n_{\mathrm{VDG}}}
\newcommand{\lattice}{{\mathcal M}}



\newcommand{\TVar}{\mathcal{V}}
\newcommand{\PVar}{\mathcal{D}}


\newcommand{\yes}{\textit{yes}}
\newcommand{\no}{\textit{no}}
\newcommand{\FPr}{\textsf{Pr}}
\newcommand{\FB}{\textsf{B}}
\newcommand{\Ttr}{\textsf{\itshape T}}

\newcommand{\Tr}{\textsf{Tr}}


\newcommand{\support}{\mathsf{support}}

\newcommand{\FC}{\textsf{C}}


\newcommand{\V}{\mathcal{V}}
\newcommand{\M}{\mathcal{M}}

\newcommand{\degPTSS}{\textsf{D}}

\newcommand{\Lab}{\mathcal{L}}
\newcommand{\nullproc}{\mathbf{0}}
\newcommand{\ppop}[4]{{{#1}.\sum_{i=1}^{#2}[{#3}_i]{#4}_i}}
\newcommand{\ppopt}[4]{{{#1}.\textstyle\sum_{i=1}^{#2}[{#3}_i]{#4}_i}}
\newcommand{\parop}[1]{\mathop{||_{#1}}}
\newcommand{\unreach}{\textsf{U}}
\newcommand{\dk}{\textsf{dk}}
\newcommand{\Act}{A}
\newcommand{\tick}{{\surd}}

\newcommand{\set}{\mathop{set}}

\newcommand{\tyft}{\ensuremath{\textit{tyft}}}
\newcommand{\tyxt}{\ensuremath{\textit{tyxt}}}
\newcommand{\tyfxt}{\ensuremath{\tyft\textit{/}\tyxt}}

\newcommand{\ntmufnu}{\ensuremath{\textit{nt}\mu\textit{f}\nu}}
\newcommand{\ntmuxnu}{\ensuremath{\textit{nt}\mu\textit{x}\nu}}
\newcommand{\ntmufxnu}{\ensuremath{\mathit{nt}\mkern-1.25mu \mu\mkern-1.0mu \mathit{f}\mkern-1.5mu \nu\mkern-2mu /\mkern-2mu \mathit{nt}\mkern-1.5mu \mu\mkern-0.75mu \mathit{x}\mkern-0.5mu \nu}}
\newcommand{\bntmufnu}{\ensuremath{\textit{\bfseries nt}\boldmath\mu\textit{\bfseries f}\boldmath\nu}}
\newcommand{\bntmuxnu}{\ensuremath{\textit{\bfseries nt}\boldmath\mu\textit{\bfseries x}\boldmath\nu}}
\newcommand{\bntmufxnu}{\ensuremath{\bntmufnu/\bntmuxnu}}

\newcommand{\tmuft}{\ensuremath{\textit{t}\mu\textit{f}\theta}}
\newcommand{\tmuxt}{\ensuremath{\textit{t}\mu\textit{x}\theta}}
\newcommand{\tmufxt}{\ensuremath{\tmuft\textit{/}\tmuxt}}
\newcommand{\ntmuft}{\ensuremath{\mathit{nt}\mkern-1.25mu \mu\mkern-1.0mu \mathit{f}\mkern-1.5mu \theta}}
\newcommand{\entmuft}{\ensuremath{\epsilon}-\ensuremath{\ntmuft}}
\newcommand{\ntmuxt}{\ensuremath{\mathit{nt}\mkern-1.5mu \mu\mkern-0.75mu \mathit{x}\mkern-0.5mu \theta}}
\newcommand{\entmuxt}{\ensuremath{\epsilon}-\ensuremath{\ntmuxt}}
\newcommand{\ntmufxt}{\ensuremath{\mathit{nt}\mkern-1.25mu \mu\mkern-1.0mu \mathit{f}\mkern-1.5mu \theta\mkern-1.75mu /\mkern-1.75mu \mathit{nt}\mkern-1.5mu \mu\mkern-0.75mu \mathit{x}\mkern-0.5mu \theta}}
\newcommand{\ntyfxt}{\ensuremath{\mathit{ntyft}\mkern-1.75mu /\mkern-1.75mu \mathit{ntyxt}}}
\newcommand{\entmufxt}{\ensuremath{\epsilon\text{-}\mathit{nt}\mkern-1.25mu \mu\mkern-1.0mu \mathit{f}\mkern-1.5mu \theta\mkern-1.75mu /\mkern-1.75mu\epsilon\text{-}\mathit{nt}\mkern-1.5mu \mu\mkern-0.75mu \mathit{x}\mkern-0.5mu \theta}}
\newcommand{\bntmuft}{\ensuremath{\textit{\bfseries nt}\boldmath\mu\textit{\bfseries f}\boldmath\theta}}
\newcommand{\bntmuxt}{\ensuremath{\textit{\bfseries nt}\boldmath\mu\textit{\bfseries x}\boldmath\theta}}
\newcommand{\bntmufxt}{\ensuremath{\bntmuft/\bntmuxt}}


\newcommand{\xmuft}{\ensuremath{\textit{x}\mu\textit{f}\theta}}
\newcommand{\xmuxt}{\ensuremath{\textit{x}\mu\textit{x}\theta}}
\newcommand{\xmufxt}{\ensuremath{\tmuft\textit{/}\xmuxt}}
\newcommand{\nxmuft}{\ensuremath{\textit{nx}\mu\textit{f}\theta}}
\newcommand{\nxmuxt}{\ensuremath{\textit{nx}\mu\textit{x}\theta}}
\newcommand{\nxmufxt}{\ensuremath{\ntmuft\textit{/}\nxmuxt}}

\newcommand{\nxmutt}{\ensuremath{\textit{nx}\mu\textit{t}\theta}}


\newcommand{\ntyft}{\ensuremath{\textit{ntyft}}}
\newcommand{\ntyxt}{\ensuremath{\textit{ntyxt}}}


\newcommand{\Diag}{\mathop{\textsf{Diag}}}
\newcommand{\diag}[1]{\textsf{Diag}\{#1\}}
\newcommand{\family}[3][]{{\left\{{#2}\right\}_{#3}^{#1}}}

\newcommand{\partZ}{\Xi}

\newcommand{\limp}{\Rightarrow}



\newcommand{\msopen}{\{\!|}
\newcommand{\msclose}{|\!\}}

\newcommand{\congclosure}[1]{\simeq_{#1}}
\newcommand{\congclosureap}[1]{\simeq_{#1}^{ap}}

\newcommand{\MVarMax}{\ensuremath{\textstyle{\MVar}}}
\newcommand{\MVarSum}{\ensuremath{\textstyle{\MVar^{\,\oplus}}}}
\newcommand{\MVarMaxMult}{\ensuremath{\textstyle{\MVar^{\,\sqdoublecup}}}}
\newcommand{\MVarSumMult}{\ensuremath{\textstyle{\MVar^{\,\oplus\hspace{-0.25cm}\bigcirc}}}}

\DeclareMathOperator{\der}{der}
\DeclareMathOperator{\last}{lst}
\DeclareMathOperator{\free}{free}
\DeclareMathOperator{\bound}{bound}
\DeclareMathOperator{\source}{src}
\DeclareMathOperator{\target}{trgt}
\DeclareMathOperator{\MVar}{MVar}
\DeclareMathOperator{\expbound}{exp}
\DeclareMathOperator{\expboundnew}{\triangledown^\star}
\DeclareMathOperator{\expboundMetric}{\blacktriangledown}
\DeclareMathOperator{\Countvar}{Var}

\newcommand{\FF}{\ensuremath{F}}
\newcommand{\VV}{\ensuremath{T}}
\newcommand{\GF}{m_{\FF}}
\newcommand{\GV}{m_{\VV}}
\newcommand{\HF}{h_{\FF}}
\newcommand{\HV}{h_{\VV}}
\newcommand{\functor}{M}

\newcommand{\rmultab}[3]{\ensuremath{\lfpF^{#1}(#2,#3)}}
\newcommand{\rmultmetric}[2]{\ensuremath{\textstyle{\divideontimes_{#2}^{#1}}}}
\newcommand{\reactdist}[2]{\ensuremath{\textstyle{\curlyveeuparrow\!(#1,#2)}}}

\newcommand{\lfpF}{\omega_F}
\newcommand{\lfpT}{\omega_T} \newcommand{\compileTimeZone}{CET}
\newcommand{\renderTimeZone}{CET}

\usepackage[ddmmyyyy]{datetime}
\usepackage{datenumber}
\usepackage{expl3}
\usepackage{color}

\usepackage{etex}
\reserveinserts{30}

\let\doendproof\endproof
\let\doendexample\endexample
\newenvironment{apx-proof}[1] 
        {\noindent \rm \textbf{Proof of #1.}} 
        {\qed}
\renewcommand{\figurename}{Figure}

\makeatletter
\newcommand*\getnumtz[2]{\expandafter\@getnumtz\the\numexpr 0#2\relax
        \empty\relax\relax\@nnil{#1}{#2}}

\def\@getnumtz#1\relax#2\relax#3\@nnil#4#5{\ifx\relax#2\relax
        \edef#4{#1}\else
        \begingroup\expandafter\endgroup
        \expandafter\let\expandafter#4\csname getnumtz@#5\endcsname \fi
}

\newcommand*\definetz[2]{\@namedef{getnumtz@#1}{#2}}

\definetz{Z}{+0000}
\definetz{GMT}{+0000}
\definetz{UTC}{+0000}
\definetz{CET}{+0100}
\definetz{CEST}{+0200}

\newcommand*\converttimezone[9]{\begingroup
\c@myyear=\numexpr#2\relax
    \c@mymonth=\numexpr#3\relax
    \c@myday=\numexpr#4\relax
    \c@myhour=\numexpr#5\relax
    \c@myminute=\numexpr#6\relax
    \c@mysecond=\numexpr#7\relax
\getnumtz\origtz{#8}\getnumtz\targettz{#9}\c@myhourminute=\numexpr (#5)*100+(#6) - \origtz + \targettz \relax
    \c@myhour=\numexpr \c@myhourminute / 100\relax \c@myminute=\numexpr \c@myhourminute - \c@myhour*100\relax
    \loop\ifnum\c@myminute<\z@
        \advance\c@myhour by \m@ne
        \advance\c@myminute by 60\relax
    \repeat
    \loop\ifnum\c@myminute>59\relax
        \advance\c@myhour by \@ne
        \advance\c@myminute by -60\relax
    \repeat
\ifnum\c@myhour<0\relax
        \setmydatenumber{mydatenumber}{\value{myyear}}{\value{mymonth}}{\value{myday}}\advance\c@mydatenumber by \m@ne
        \setmydatebynumber{\value{mydatenumber}}{myyear}{mymonth}{myday}\advance\c@myhour by 24\relax
    \else\ifnum\c@myhour>23\relax
        \setmydatenumber{mydatenumber}{\value{myyear}}{\value{mymonth}}{\value{myday}}\advance\c@mydatenumber by \@ne
        \setmydatebynumber{\value{mydatenumber}}{myyear}{mymonth}{myday}\advance\c@myhour by -24\relax
    \fi\fi
    \edef\@tempa{\unexpanded{#1}{\themyyear}{\themymonth}{\themyday}{\themyhour}{\themyminute}{\themysecond}{#9}}\expandafter
    \endgroup\@tempa
}
\newcounter{myhourminute}
\newcounter{myyear}
\newcounter{mymonth}
\newcounter{myday}
\newcounter{myhour}
\newcounter{myminute}
\newcounter{mysecond}
\newcounter{mydatenumber}
\makeatother

\newcommand\myshowdate[7]{\formatdate{#3}{#2}{#1} \formattime{#4}{#5}{#6} #7}

\ExplSyntaxOn
\cs_set_eq:NN \lgt_file_date: \today

\cs_new_nopar:Npn \lgt_file_time:
  {
    \lgt_get_time:N \currenthour :
    \lgt_get_time:N \currentminute :
    \lgt_get_time:N \currentsecond
  }

\cs_new_nopar:Npn \lgt_get_time:N #1
  {
    \int_compare:nNnT { #1 } < { 10 } { 0 }
    \int_use:N #1
  }

\ExplSyntaxOff

\newcommand{\lastchange}{\converttimezone\myshowdate{\svnfileyear}{\svnfilemonth}{\svnfileday}{\svnfilehour}{\svnfileminute}{\svnfilesecond}{\svnfiletimezonehour \svnfiletimezoneminute}{\renderTimeZone}}
\newcommand{\build}{\converttimezone\myshowdate{\year}{\month}{\day}{\currenthour}{\currentminute}{\currentsecond}{\compileTimeZone}{\renderTimeZone}}

\newcommand{\wipinfo}{\textcolor{darkgrey}{
  Last change:  \lastchange \\
  \qquad\quad Build: \build \\
  Revision: \svnfilerev \qquad\qquad\qquad\quad
}}




\definecolor{lightblue}{RGB}{224,224,255}
\definecolor{lightred}{RGB}{255,224,224}
\definecolor{lightgreen}{RGB}{224,255,224}
\definecolor{lightyellow}{RGB}{255,255,224}
\definecolor{lightpurple}{RGB}{255,224,255}
\definecolor{darkerred}{RGB}{64,0,0}
\definecolor{darkred}{RGB}{128,0,0}
\definecolor{darkblue}{RGB}{0,0,128}
\definecolor{darkgreen}{RGB}{0,128,0}
\definecolor{darkpurple}{RGB}{128,0,128}
\definecolor{grey}{rgb}{0.745098,0.745098,0.745098}
\definecolor{lightgrey}{rgb}{0.9,0.9,0.9}
\definecolor{darkgrey}{rgb}{0.6,0.6,0.6}

\newcommand{\colorpar}[3]{\colorbox{#1}{\parbox{#2}{#3}}}

\newcommand{\marginremark}[3]{\marginpar{\colorpar{#2}{\linewidth}{\color{#1}#3}}}

\makeatletter
\def\THICKhrulefill{\leavevmode \leaders \hrule height 5pt\hfill \kern \z@}
\makeatother
\newcommand{\highlightedremark}[4]{\begin{center}\fcolorbox{#1}{#2}{\begin{minipage}{.98\linewidth}\color{#1}\textbf{\THICKhrulefill[ #3 ]\THICKhrulefill}\par\noindent#4\end{minipage}}\end{center}}

\newcommand{\remarkDG}[1]{}
\newcommand{\remarkST}[1]{}
\newcommand{\remarkDW}[1]{}
\newcommand{\remarkWF}[1]{}

\newcommand*\widefbox[1]{\fbox{\hspace{1em}#1\hspace{1em}}}

 \usepackage{empheq}

\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}
\newtheorem{fact}{Fact}
\newtheorem{corollary}{Corollary}
\newenvironment{proof}{{\bf Proof. }}{\\ \smallskip}
\newcommand{\qed}{\hfill\ensuremath{\square}}
\newenvironment{example}{\ \!\!\!\!\!\!\!\!\!\!\!{\bf Example 1}}{}





\title{Compositionality of Approximate Bisimulation for Probabilistic Systems}
\author{Daniel Gebler
\institute{
	Department of Computer Science, VU University Amsterdam,\\
	De Boelelaan 1081a, NL-1081~HV~Amsterdam, The Netherlands}
\email{e.d.gebler@vu.nl}
\and 
Simone Tini
\institute{
	Department of Scienza e Alta Tecnologia, \\
	University of Insubria, Via Valleggio 11, I-22100, Como, Italy}
\email{simone.tini@uninsubria.it}
}
\def\titlerunning{Compositionality of Approximate Bisimulation for Probabilistic Systems}
\def\authorrunning{D. Gebler \& S. Tini}

\begin{document}

\maketitle

\begin{abstract}
Probabilistic transition system specifications using the rule format \ntmufxt\ provide structural operational semantics for Segala-type systems
and guarantee that probabilistic bisimilarity is a congruence. Probabilistic bisimilarity is for many applications too sensitive to the exact probabilities of transitions. Approximate bisimulation provides a robust semantics that is stable with respect to 
implementation and measurement errors of probabilistic behavior. We provide a general method to quantify how much a process combinator 
expands the approximate bisimulation distance. As a direct application we derive an appropriate rule format that 
guarantees compositionality with respect to approximate bisimilarity. Moreover, we describe how specification formats for non-standard compositionality requirements may be derived. 
\end{abstract}




\section{Introduction}\label{sec:introduction}


\remarkST{Decide the term operator/opearions/functions}
\remarkDG{Standard term in SOS literature is `function symbol' for the element of the signature. When one refers to the semantics terms in use are operators and process combinator.}
Over the last decade a number of researchers have started to develop a theory of structural operational semantics (SOS) \cite{Plo04} for probabilistic transition systems (PTSs). Several rule formats for various PTSs were proposed that ensure compositionality (in technical terms congruence) of probabilistic bisimilarity \cite{Bar04,LT05,LT09,DL12,LGD12,BM12}. The rule format \ntmufxt\cite{DL12,LGD12} subsumes all earlier formats and can be understood as the probabilistic variant of the \ntyfxt\ format \cite{Gro93}. 




Probabilistic bisimilarity is very sensitive to the exact probabilities of transitions. The slightest perturbation of the probabilities can destroy bisimilarity. Two proposals for a more robust semantics of probabilistic processes have been put forward. The \emph{metric bisimulation} approach 
\cite{GJS90,DGJP04,BW05} 
is the quantitative analogue of the relational notion of probabilistic bisimulation. It assigns a distance to each pair of processes, which measures the proximity of their quantitative properties. 
Another approach is the \emph{approximate bisimulation} (also called -bisimulation) 
approach \cite{GJS90,DLT08,TDZ11}. Approximate bisimulations are probabilistic bisimulations where the transfer condition is relaxed, namely two processes are related by an -bisimulation if their probability to reach a set of states related by that -bisimulation differs by at most .
Processes that are related by an -bisimulation with  being small are ``almost bisimiliar''. 
Approximate bisimulations are not transitive in general, as two states with quite different behaviors could be linked by a sequence of states, which pairwise have only little behavioral difference. Approximate bisimulations have been characterized in operational terms \cite{GJS90}, by a modal logic 
\cite{DLT08,TDZ11}, and in terms of games \cite{DLT08}. 
The metric and approximate bisimulation approach are in general not comparable (see \cite{Trac10,Tin10,TDZ11}). The main difference is that in the approximate bisimulation approach (contrary to the metric bisimulation approach) the differences along paths are neither accumulated nor weighted by the probability of the realization of that path. In this paper we consider approximate bisimulations.


In order to allow for compositional specification and reasoning, it is necessary that the considered behavioral semantics is compatible with all operators of the language of interest. For behavioral equivalences (e.g. probabilistic bisimulations) this is the well-known congruence property. For approximate bisimulations the quantitative analogue to the congruence property requires that when different processes are combined by a process combinator (i.e., an operator of the language), then the distance between the resulting combined processes 
is (reasonably) bounded. 
A natural notion for this bound is the sum of the distances between the processes to be combined \cite{DGJP04}. A process combinator respecting this specific bound is called \emph{non-expansive}. Intuitively, this bound expresses that a process combinator does not increase the behavioral distance of the processes to be combined.  The congruence property and non-expansivity property of an -ary process combinator  can be expressed by the following proof rules (with  denoting the probabilistic bisimilarity and  denoting the approximate bisimulation distance):

However, for specific applications, alternative compositionality requirements are required that allow for more or less variance (than the linear sum used in non-expansivity) of the combined processes. For instance, a process combinator that combines a number of distributed systems with a measurement unit may allow for some variance in the combined distributed systems, but must enforce that the measurement unit itself is strict.

In this paper we report a substantial first step towards a theory of robust specifications for probabilistic processes. As an operational model for probabilistic processes, we consider Segala-type PTSs that exhibit both probabilistic and nondeterministic behavior. The probabilistic processes are specified by probabilistic transition system specifications (PTSS) with simple \ntmufxt\ rules. By simple \ntmufxt\ rules we mean \ntmufxt\ rules without lookahead. 
In order to facilitate compositional specification and reasoning, we study how the distance between two terms with the same topmost function symbol depends on the distances of the arguments. In detail, we characterize the \emph{expansivity} of a process combinator,
which gives an upper bound on the distance of the combined processes given the distance between their components.
Formally, the expansivity of a process combinator  with  arguments is defined as a mapping  taking distances of the arguments  to , with  defined as the maximal distance between all  and  whenever all  and  are in approximate bisimulation distance .

The first contribution of our paper is the characterization of the expansivity of each process combinator. The expansivity of a process combinator is defined as the least fixed point of a monotone function that counts recursively how often the processes are copied. Our second contribution is to deduce, from the expansivity of process combinators, an appropriate rule format that guarantees non-expansivity of all operators specified in this format. The rule format is derived from the simple \ntmufxt\ rule format by prohibiting that source processes or derivatives are copied. Finally, we demonstrate how the expansivity of process combinators can be used to derive rule formats for alternative compositionality requirements. 
























We consider in this paper approximate bisimulations because the relaxed transfer condition preserves the basic relational nature of probabilistic bisimulations and allows us to apply (adapted and extended) known proof techniques developed for congruence rule formats. Moreover, the new techniques introduced in this paper to quantify the expansivity of process combinators translate naturally to bisimulation metrics. In this sense, we are also opening the door to develop a theory of robust process specifications with respect to bisimulation metrics.

This is the first paper that explores systematically the approximate bisimulation distance of probabilistic processes specified by transition system specifications.
Tini already proposed a rule format for reactive probabilistic processes \cite{Tin08,Tin10}. Our format significantly generalizes and extends that format. First of all, we apply the more general Segala-type systems that admit, besides probabilistic behavior (probabilistic choice), nondeterministic reactive behavior (internal nondeterministic branching). Furthermore, while Tini used a notion of approximate bisimulation, which is an equivalence but not closed under union, we are using the (by now) standard notion \cite{DLT08,TDZ11}, which is only reflexive and symmetric but closed under union. Finally, the novel rule format 
based on counting of copies of processes and their derivatives in its defining rules allows us to handle a wider class of process combinators that ensure non-expansivity.











\section{Preliminaries}\label{sec:preliminaries}


We assume an infinite set of (state) variables . We let  range over . A \emph{signature} is a structure , where 
\begin{inparaenum}[(i)]
	\item  is a set of \emph{function names} (operators) disjoint from , and
	\item  is a \emph{rank function}, which gives the arity of a function name. An operator  is called a \emph{constant} if .
\end{inparaenum}
We write  for .  
Let  be a set of variables. The set of -terms (also called state terms) over , denoted by , is the least set satisfying: 
\begin{inparaenum}[(i)]
	\item , and
	\item if  and , then .
\end{inparaenum}
 is the set of all \emph{closed terms} and abbreviated as .  is the set of \emph{open terms} and abbreviated as . We may refer to operators as process combinators, and refer to terms as processes.  denotes the set of variables in . 
 denotes for  how often the variable  occurs in .
A (state variable) \emph{substitution} is a mapping .
A substitution is closed if it maps each variable to a closed term. A substitution extends to a mapping from terms to terms as usual.
\remarkWF{Should the substitution not be better a partial map?}
\remarkDG{Total function is easier to handle when later defining closed instantiations of rules (otherwise one always needs to say that variables are replaced by closed terms AND the domain of the substitution is at least the set of variables of a rule)}


Let  denote the set of all (discrete) probability distributions on . We let  range over . For  we define . For each , let  denote the \emph{Dirac distribution}, i.e.,  and   if  and  are not syntactically equal. The convex combination  of a family  of probability distributions with  and  is defined by . 
By  we denote the distribution that is defined by . We may use the infix notation where appropriate.


In order to describe probabilistic behavior, we need expressions that denote probability distributions. We assume an infinite set of distribution variables . We let  range over  and  range over . Let  be a set of distribution variables and  be a set of state variables.  The set of \emph{distribution terms} over  and , notation , is the least set satisfying: 
\begin{inparaenum}[(i)]
	\item \label{def:DT:var_and_inst_dirac}
		, 
	\item \label{def:DT:sum} 
		 if  and  with , and
	\item \label{def:DT:prod} 
		 if  and .\footnote{This fixes a flaw in \cite{LGD12,DL12} where arbitrary functions  were allowed. In this case probabilistic bisimilarity (Definition~\ref{def:bisimulation}) may not be a congruence (Theorem~\ref{thm:bisimilarity_as_congruence}). Example: PTSS , constants  in , ,  with . Now  but .} 
\end{inparaenum}
A \emph{distribution variable}  is a variable that takes values from . An \emph{instantiable Dirac distribution}  with  is a symbol that takes value  when variables in  are substituted so that  becomes the closed term . Case \ref{def:DT:sum} allows one to construct convex combinations of distributions. For concrete terms we use the infix notation, e.g.,  for . Case \ref{def:DT:prod} lifts the structural inductive construction of state terms to distribution terms.
 is abbreviated as .



 denotes for  how often the variable  occurs in . For convex combinations  the maximal occurrence in some  is considered because the probabilistic choice selects (probabilistically) exactly one of the summands.
Formally, we have ,  if , , , , and  = . 
A substitution on state and distribution variables is a mapping  such that  if , and  if . A substitution extends to distribution terms by ,  and . Notice that closed instances of distribution terms are probability distributions. 


\section{Probabilistic Transition System Specifications}\label{sec:ptss}


Probabilistic transition systems (PTSs) generalize labelled transition systems (LTSs) by allowing for probabilistic choices in the transitions. 
We consider nondeterministic PTSs (Segala-type systems) \cite{Seg95a} with countable state spaces.

\begin{definition}{\ \!\!\!\emph{(PTS)}\bf{.}\,}
A \emph{probabilistic labeled transition system} (PTS) is a triple , where  is a signature,  is a countable set of actions, and  is a transition relation.
\end{definition}
We write  for . PTSs are specified by means of transition system specifications \cite{Plo04,Gro93,GV92,LGD12}.


\begin{definition}{\ \!\!\!\emph{(Simple \ntmufxt-rule)}\bf{.}\,} \label{def:simple_ntmuft}
A \emph{simple \ntmuft-rule} has the form:

with , , , , and constraints:
\begin{enumerate}
	\item \label{cond:simple_ntmufxt:pairwise_difference_positive_literal} 
		all  for  are pairwise different; 
	\item \label{cond:simple_ntmufxt:pairwise_difference_source}
		all  are pairwise different.
\end{enumerate}
A \emph{simple \ntmuxt-rule} is as above with source of its conclusion  instead of .
A \emph{simple \ntmufxt-rule} is either a simple \ntmuft-rule or a simple \ntmuxt-rule. 
\end{definition}
The expressions  (resp.\ ) above the line are called \emph{positive} (resp. \emph{negative}) \emph{premises}. We call  in  a \emph{derivative} for each . For rule  we denote the set of positive (resp.\ negative) premises by  (resp.\ ), and the set of all premises by .
A rule without premises is called an \emph{axiom}. We allow 
the sets of positive and negative premises to be infinite.
The expression  below the line is called \emph{conclusion}, notation . The term  is called the \emph{source} of , notation , and  are the \emph{source variables}, notation .  is the \emph{target} of , notation .
An expression  (resp.\ ) is called a \emph{positive} (resp.\ \emph{negative}) \emph{literal}.
Hence, premises and conclusions are literals. We denote the set of variables in  by , \emph{bound variables} by , and \emph{free variables} by .



A \emph{probabilistic transition system specification} (PTSS) in simple \ntmufxt-format, called simple \ntmufxt-PTSS for short, is a triple  with  a signature,  a set of action labels, and  a set of simple \ntmufxt-rules. 




As PTSS have negative premises, there are multiple approaches to assign a meaning (see \cite{vG04} for an overview). We will use the stratification approach presented in \cite{DL12} to assign to each PTSS  (if possible) a PTS . A closed literal  (resp.\ ) \emph{holds in} , notation  (resp.\ ), if  (resp.\ there is no  s.t.\ ).
A substitution  extends to literals by , and , and to rules as expected.

\begin{definition}{\ \!\!\!\emph{(Stratification \cite{DL12})}\bf{.}\,} \label{def:stratification}
Let  be a PTSS.  A function , where  is an ordinal, is called a \emph{stratification} of  if for every rule 

in  and substitution  
we have:
\begin{inparaenum}[(i)]
	\item  for all , and
	\item  for all .
  \end{inparaenum}
The set , with , is called a \emph{stratum}. 
\end{definition}
We call  \emph{stratifiable} if  has some stratification. A transition relation is constructed stratum by stratum in an increasing manner.
\begin{definition}{\ \!\!\!\emph{(Induced PTS \cite{DL12})}\bf{.}\,} \label{def:pts_induced_by_ptss}
Let  be a PTSS with stratification . For all rules , let  be the smallest regular cardinal greater than , and let  be the smallest regular cardinal such that  for all . The \emph{induced PTS}  
is defined by , where  and  is .7ex]
		     \textstyle(\bigcup_{ \gamma < \beta} {\trans_{P_\gamma}}) \cup (\bigcup_{ j' < j} {\trans_{P_{\beta,j'}}}) \models {\pprem{\sigma(\rho)}}, \text{ and} \
\end{definition}
The induced PTS is independent from the chosen stratification \cite{DL12}. We can construct for each simple \ntmufxt-PTSS  a PTSS  with only simple \ntmuft-rules that induces the same PTS \cite{LGD12}. The construction defines  as  where each rule with a source of the form  is replaced by a set of rules where  is substituted by  for each  . Hence, all our results below for simple \ntmuft-PTSS generalize to simple \ntmufxt-PTSS. 



Given a relation , a set  is ,
denoted by , if  where .

\begin{definition}{\ \!\!\!\emph{(Probabilistic Bisimulation \cite{LS91,DGJP03})}\bf{.}\,} \label{def:bisimulation}
Let  be a PTS. A symmetric relation  is a \emph{probabilistic bisimulation} if whenever  and  then there exists a transition   such that , where

\end{definition}
Notice that this standard definition can be slightly reformulated to relate it to the later introduced -bisimulation (Definition~\ref{def:epsilon_bisim}) by requiring that  iff  for all  \cite{DLT08}. The union of all probabilistic bisimulations is the largest probabilistic bisimulation, called probabilistic bisimilarity, and denoted by . 
We shall refer to probabilistic bisimulation as strict bisimulation to distinguish it from the later introduced relaxed notion of -bisimulation.

A crucial property of process description languages to ensure compositional modelling and verification is the compatibility of process operators with the behavioral relation chosen for the application context. In algebraic terms the compatibility of a behavioral equivalence  with operator  is expressed by the congruence property which is defined as  whenever  for . The rule format of Definition~\ref{def:simple_ntmuft} is an instance of the \ntmufxt\ rule format \cite{LGD12}, which ensures that bisimilarity is a congruence.

\begin{theorem}{\ \!\!\!\emph{(Probabilistic Bisimilarity as a congruence \cite{LGD12})}\bf{.}\,} \label{thm:bisimilarity_as_congruence}
Let  be a stratifiable simple \ntmufxt-PTSS. Then probabilistic bisimilarity is a congruence for all operators defined in .
\end{theorem}
In order to allow for robust reasoning on PTSs, the behavioral relations 
should allow for (limited) perturbation of probabilities \cite{GJS90}. -bisimulation is a behavioral relation based on strict probabilistic bisimulation, where the transfer condition is relaxed by some upper bound on the pertubation of probabilities. 

\begin{definition}{\ \!\!\!\emph{(-Bisimulation \cite{DLT08})}\bf{.}\,} \label{def:epsilon_bisim} 
Let  be a PTS and . A symmetric relation  is an \emph{-bisimulation} if whenever  and  then there exists a transition   such that , where

\end{definition}
We call  and  (resp.\  and ) -bisimilar if  (resp.\ ) for some -bisimulation . Notice that -bisimulations are reflexive and symmetric but 
not necessarily transitive. 
-bisimulations are closed under union. We denote the largest -bisimulation, called -bisimilarity, by .  
According to \cite{DLT08}, -bisimulations induce a pseudo-metric over the set of closed terms  with , where . We say that  and  are within the approximation bisimulation distance  if .





\section{Expansivity of Process Combinators}\label{sec:aptss}


The expansivity of an operator  is defined as the maximal approximate bisimulation distance of terms with an outermost function symbol  in relation to the approximate bisimulation distances of its arguments.
In this section we quantify the expansivity of operators defined by a PTSS. We start by showing that 
the expansivity of an operator  defined by a rule  depends on
\begin{inparaenum}[(i)]
	\item the \emph{multiplicity} (i.e. number of occurrences) of source variables and their derivatives in the target of ; 
	\item the \emph{expansivity power} of operators (i.e. how much does the operator multiply the distance of its arguments) that define a context 
around the source variables or their derivatives;
and
	\item the (reactive behavior) \emph{discriminating power} of the premises of .
\end{inparaenum}



\begin{example}{\,(Factors of Expansivity)\bf{.}\,} \label{ex:expansivity_of_operators_approx_bisim}
Let  be a PTSS with a signature  that contains constants , unary function symbols , binary function symbols  and a quaternary function symbol , action set , and axioms  for some fixed . It is not hard to see that  in the PTS induced by . Consider the rules:

These rules together with  define . In the first rule the derivative  of source variable  appears twice in the rule target . The induced PTS of   contains the following transitions:

\vspace{0.2cm}\hspace{1cm}
\begin{tikzpicture}
	\node (r) at (0,0) {} ;
	\node (pir) at () {};
	\path[->] (r)  edge node [right] {{\scriptsize }} (pir);
	\path[->] (pir) [bend left = 70,dotted] edge node [left] {{\scriptsize }} (r);

	\node (s) at () {} ;
	\node (pis) at () {};
	\node (s') at () {};

	\path[->] (s)  edge node [left] {{\scriptsize }} (pis);
	\path[->] (pis) [bend right = 70,dotted]  edge node [right] {{\scriptsize }} (s);		
	\path[->] (pis) [dotted] edge node [right] {{\scriptsize }} (s');

	\node (r) at () {} ;
	\node (pir1) at () {};
	\node (r') at () {} ;

	\path[->] (r) edge node [left] {{\scriptsize }} (pir1);
	\path[->] (pir1) [dotted] edge node [right] {{\scriptsize }} (r');
    \path[->] (r') [bend left = 70] edge node [left] {{\scriptsize }} (pir1);

	\node (fs) at () {} ;
	\node (pis) at () {};
	\node (hs1) at () {} ;
	\node (hs2) at () {} ;
	\node (hs3) at () {} ;
	\node (hs4) at () {} ;
	
	\path[->] (fs) edge node [right] {{\scriptsize }} (pis);
	\path[->] (pis) [dotted, bend right = 25] edge node [above] {{\scriptsize }} (hs1);
	\path[->] (pis) [dotted] edge node [left] {{\scriptsize }} (hs2);
	\path[->] (pis) [dotted] edge node [right] {{\scriptsize }} (hs3);
	\path[->] (pis) [dotted, bend left = 25] edge node [above] {{\scriptsize }} (hs4);
	\path[->] (hs1) [bend left = 85,distance=1.05cm] edge node [left,xshift=-0.1cm] {{\scriptsize }} (pis);
\end{tikzpicture}
\vspace{0.1cm}

\noindent
Observe that . The power of  in the distance reflects directly the multiplicity of  of the derivative  in the rule target. 
The same effect can be observed for multiple occurrences of source variables in the rule target, e.g. consider for the -defining rule  instead of  as target.

Furthermore, the expansivity power of operators used in the rule target determine the expansivity of the operator defined by that rule. A simple example is the axiom . While the variable  occurs only once in the rule target,
we still have , because the operator  
has an expansivity power of 2 
wrt.\ its single argument. This indicates that the expansivity power of (arguments of) operators need to be defined recursively.


The multiplicity of source variables and their derivatives and the expansivity power of operators applied on those variables multiply. Consider the rules:

These rules together with  define . 
\noindent
Now . As explained above for , in the rule defining operator  the derivative  appears twice in the rule target. Additionally the operator  that is applied to  has for both of its arguments an expansivity power of two because in the -defining rule the derivatives  of both arguments  appear twice in the rule target. 


The expansivity power of an operator may be unbounded. Consider the recursive unary operator  defined by the rules:

These rules together with  define . In the rule that defines the operator  the derivative  occurs twice in the target. Moreover, each occurrence of  is put in the context of that operator , which is defined by this rule (recursive call). Additionally both occurrences of  are put in the binary context , which enforces that the distances of the two copies of  multiply.
Recursive multiplication of the distances leads to an approximate bisimulation distance of . 
The expansivity power of  will in this case be denoted by . 

On the other hand, an operator may also absorb the approximate bisimulation distance.
Consider the rules:

These rules together with  define . The first rule applies the undefined operator  to the two copies of the derivative . As 
 has no rules, we get . Similarly, the rule defining  applies operator  in the target. The operator  allows one to derive an unconditional move to the idle process .
Hence, .


However, if the reactive behavior of the process associated to a source variable is tested by some premise, then the operator defined by this rule may discriminate states with different reactive behavior.
Consider the rules:

These rules together with  define . 
We get  because the -transition of term  leads to a distribution where all states can perform the action , but the -transition of term  leads to a distribution where only states with a total probability mass of  can perform the action .
\end{example}


We denote by 
those rules of  that define the operator .
We define by  the (reactive behavior) discriminating power of argument  of
. Formally,  if the source variable  appears in a premise of some , i.e., if for some  there is a  with  or 
a  with . Otherwise, . 
With  we denote , with the natural ordering extended by  for each , and the usual arithmetic extended for summation by  for  and multiplication by  and  for .


We quantify the 
expansivity power of operators  as least fixed point of a monotone function. Let  with  be a PTSS. We define a poset 
 with , , , equipped with the point-wise partial order  iff , for all , and  for all . Elements of  are pairs of maps . 
 denotes the 
expansivity power of argument  in operator , i.e., how much the operator  multiplies the approximate bisimulation distance of argument .
 defines the frequency of variable  in the state or distribution term  weighted by the 
expansivity power of the operators applied on top of .
 forms a complete lattice with bottom element  and top element , defined by constant maps  and   for each , , , . 
\begin{proposition}\label{prop:s_complete_lattice}
	 is a complete lattice.	
\end{proposition}



The function  defined in Fig.~\ref{fig:functor_multiplicity_approx_bisim} computes in parallel the expansivity power of arguments of operators, and the multiplicities of variables in terms weighted by the expansivity power of the operators applied on top of them. The expansivity power  of argument  of operator  is defined as the maximum expansivity power over each -defining rule . For  the expansivity power is defined as the sum of the multiplicity of  in the rule target  and of the multiplicity of  in some premise  weighted by the multiplicity of the derivative  in the rule target . Note that source variables and derivatives in the rule target contribute equally to the expansivity power of an argument. The multiplicity  of  in a state term  counts the occurrences of variable  in  and weights them by the expansivity power of the operators applied on top of . The multiplicity  of  in a distribution term  counts the occurrences of variable  in  and weights them by the expansivity power of the operators applied on top of , but at least by the discriminating power of those operators. Note that the discriminating power of operators is considered only for distribution terms. To understand this, consider the reactive behavior of -bisimilar state and distribution terms. 
For a state term  we have that  implies  iff  for each , i.e.,  and   agree on their immediate reactive behavior. However, for a distribution term  we have that if  then  and  may have states with different reactive behavior (cf.  in Example~1). 

 is order-preserving.
\remarkDG{Reviewer: Monotonicity is enough (continuity not required) since  is a complete lattice.}
This ensures the existence and uniqueness of the least fixed point of  by the Knaster-Tarski fixed point theorem.

\begin{proposition}\label{prop:fb_order_preserving}
	 is order-preserving.
\end{proposition}













\begin{figure}[!t]
-0.1cm]
&\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\text{Function }\functor: S \to S \text{ is defined by }\functor(\GF,\GV) = (\GF',\GV')\text{ with}\-0.1cm]
\GV'(t)(\zeta) &= 
	\begin{cases}
		1 & \text{if } \zeta \in \TVar \text{ and }t=\zeta\\
\displaystyle \sum_{i=1}^{\rank(f)} \left( \GF(f,i) \,\cdot\, \GV(t_i)(\zeta)\right)  \qquad\qquad\qquad & \text{if }t=f(t_1,\ldots,t_{\rank(f)})\\
0 & \text{otherwise}
	\end{cases}\0.2cm]
\GV(t)(\zeta) 	& \text{if } \theta = \delta_t \0.2cm]
\displaystyle \sum_{i=1}^{\rank(f)} \left( \max (\GF(f,i),\reactdist{f}{i} ) \,\cdot\, \GV(\theta_i)(\zeta)\right) & \text{if }\theta=f(\theta_1,\ldots,\theta_{\rank(f)}) \-0.2cm]
\expbound^f(\epsilon_1,\ldots,\epsilon_{\rank(f)}) = 1 -\prod_{i=1}^{\rank(f)} (1-\epsilon_i)^{\lfpF(f,i)}

	f(t_1,\dots,t_{\rank(f)}) \bisim_{\epsilon} f(t_1',\dots,t_{\rank(f)}') \quad\text{whenever}\quad t_i \bisim_{\epsilon_i} t_i' \ \text{ for } i=1,\ldots,\rank(f)

	\SOSrule{x\trans[a]\mu}{{x; y}\trans[a] \mu; \delta_y}{\ a\neq\tick}
\qquad\qquad
	\SOSrule{x\trans[\tick]\mu \quad y\trans[a]\mu'}{{x; y}\trans[a]\mu'}

	f(t_1,\dots,t_{\rank(f)}) \bisim_{\epsilon} f(t_1',\dots,t_{\rank(f)}') \quad\text{whenever}\quad t_i \bisim_{\epsilon_i} t_i'\, \text{ for all }\, i=1,\ldots,\rank(f)

	\MVarMax(\target(\rho))(x_i) + \displaystyle \!\!\!\!\!\!\!\sum_{t_k \trans[a_k] \mu_k \in \atop \pprem{\rho}}\!\!\!\!\!\!\! \MVar(t_k)(x_i) \cdot \MVarMax(\target(\rho))(\mu_k) \le 1.

	\SOSrule{x \trans[a] \mu}{!x \trans[a] \mu \parallel \delta_{!x}}
\qquad
	\SOSrule{x \trans[a] \mu}{!^px \trans[a] \mu \oplus_p (\mu \parallel \delta_{!^px})} 
\qquad
\SOSrule{x_1 \trans[a] \mu_1 \quad x_2 \trans[a] \mu_2}{x_1 \parallel x_2 \trans[a] \mu_1 \parallel \mu_2}

The first two rules defining both variants of the replication operator are not in \entmuft-format. The expansivity power of both operators is unbounded with . Hence, both operators are expansive. However, if the synchronous parallel composition defined in the third rule above is replaced by the non-communicating asynchronous parallel composition, then both variants of the replication operator would become non-expansive. 















\begin{table}[t!]
	\qquad\quad\qquad\ \ 
	\subfloat{\vtop{\vskip0pt\hbox{
	\begin{tikzpicture}
		\node (r) at (0,0) {} ;
		\node (pi) at () {};

		\path[->] (r)  [bend right = 80,distance=1.25cm] edge node [left] {{\scriptsize }} (pi);
		\path[->] (r)  [bend left = 80,distance=1.25cm] edge node [right] {{\scriptsize }} (pi);
		\path[->] (pi) [dotted] edge node [right] {{\scriptsize }} (r);
	\end{tikzpicture}
	}}}
	\quad\ \ 
	\subfloat{\vtop{\vskip0pt\hbox{
	\begin{tikzpicture}
		\node (s) at (0,0) {} ;
		\node (pi) at () {};
		\node (s') at () {};

		\path[->] (s)  [bend right = 80,distance=1.25cm] edge node [left] {{\scriptsize }} (pi);
		\path[->] (s)  [bend left = 80,distance=1.5cm] edge node [right] {{\scriptsize }} (pi);
		\path[->] (pi) [dotted] edge node [right] {{\scriptsize }} (s);		
		\path[->] (pi) [dotted] edge node [right] {{\scriptsize }} (s');
		\path[->] (s')  [bend right = 80,distance=1.25cm] edge node [right] {{\scriptsize }} (pi);
	\end{tikzpicture}
	}}}
	\quad\ \ 
	\subfloat{\vtop{\vskip0pt\hbox{
	\begin{tikzpicture}
		\node at (0,0) {Common rule};
		\node at (0,-1) {};
	\end{tikzpicture}
	}}}
\vspace{0cm}\\
\begin{center}
\begin{tabular}{|@{\hskip 0.4cm}l@{\hskip 0.4cm}|@{\hskip 0.4cm}c@{\hskip 0.4cm}|}
\hline 
\hspace{0.5cm}Description & Rule \\ 
\hline
& \\&\vspace{-0.5cm}\\
 &  \\&\vspace{-0.2cm}\\
 &  \\&\vspace{-0.2cm}\\
 &  \\&\vspace{-0.2cm}\\
 &  \\&\vspace{-0.2cm}\\
 &  \\&\vspace{-0.2cm}\\
 &  \\&\vspace{-0.2cm}\\
 &  \\&\vspace{-0.2cm}\\
 &  \\&\vspace{-0.2cm}\\
 &  \vspace{-0.2cm}\\&\\
\hline
\end{tabular}
\end{center}
\vspace{0cm}
\caption{SOS rules that specify expansive operators}\label{tab:counterexample_rule_restrictions_entmufxt}
\end{table}

We summarize the structural patterns of rules that may lead to expansive behavior in Table~\ref{tab:counterexample_rule_restrictions_entmufxt}. None of these rules is in the \entmuft\ format. For cases 1 to 7 the expansivity power of  is  and, therefore, the expansivity bound is .
Cases 8 and 9 indicate that lookahead cannot be admitted and we need to employ simple \ntmuft-rules (Definition~\ref{def:simple_ntmuft}) instead of \ntmuft-rules \cite{LGD12}. The expressions  and  (with , ) are quantitative premises as introduced by the \ntmufxt\ format \cite{DL12}.
As argued above, -bisimilar instances may have states with different reactive behavior. 
For instance, in case 8, while distributions  and  are -bisimilar, only  has in its support a state that can perform a -move. Similarly, in case 9, only for  we have that all states in the support can perform an -move.


We conjecture that a notion of \emph{non-expansivity up to } for some  (bounded non-expansivity) would allow for limited lookahead. An operator is non-expansive up to  if it is non-expansive whenever its arguments have an approximate bisimulation distance of at most . In this case, quantitative premises  that measure the probability of  and test against the boundary  could be allowed, if  is in the interval . On the other hand, quantitative premises with  or  cannot be permitted because they allow for lookahead with respect to probabilistic choices that do not mimic each other's reactive behavior.



The expansivity bound (Definition~\ref{def:upper_bound_expansion_approx_bisim}) allows rule formats to be derived for alternative compositionality requirements. For instance, consider an -ary process combinator  with the compositionality requirements that the approximate bisimulation distance of the combined processes should not depend on the approximate bisimulation distance of processes at some argument . From the expansivity bound we derive that either argument  of operator  is behavioral distance absorbing (), or the application context guarantees that processes for argument  are strictly bisimilar (). 


The non-expansivity requirement (Definition~\ref{def:non_expansivity}) is in fact the Manhattan norm, or more general the -norm  with . Consider the alternative compositionality requirement that the expansivity of a process combinator  should be bounded by the -norm with  (which includes the Euclidean norm by  and the maximum norm by ). From the expansivity bound we derive that  for at most one argument , and all other arguments  are behavioral distance absorbing with . 









































\section{Conclusion and Future Work}\label{sec:conclusion}


We studied structural specifications of probabilistic processes that are robust with respect to bounded implementation and measurement errors of probabilistic behavior. We provided for each process combinator an upper bound on the distance between the combined processes using the structural specification of the process combinator (Theorem~\ref{thm:bounded_expansion_ntmuft_bisim}). We derived an appropriate rule format that guarantees non-expansivity (standard compositionality requirement) of process combinators (Theorem~\ref{thm:nonexp_entmuft_ptss}). All standard process algebraic operators are compatible for approximate reasoning and satisfy the rule format, except operators which replicate processes and combine them by synchronous parallel composition. We exemplified how rule formats for non-standard compositionality requirements can be derived. 

Our work can be extended in several directions. In Section~\ref{sec:aptss} and Section~\ref{sec:applications} we sketched already how the expansivity bound can be further refined and how a restricted form of lookahead in the rules specifying the process combinators could be admitted. The techniques and results developed in this paper for approximate bisimulation can be carried over to bisimulation metrics. 
Initial work in this direction suggests 
that the \entmuft\ format presented in this paper ensures also non-expansivity for the bisimulation metric based on the Kantorovich and Hausdorff metric. Moreover, for the bisimulation metric the rule format can be further generalized because in this case convex combinations weigh the distance and multiplicity of processes (unlike approximate bisimilarity, see case~7 of Table~\ref{tab:counterexample_rule_restrictions_entmufxt}). Furthermore, we will investigate the expansivity of process combinators and rule formats for variants of bisimulation metrics and -bisimulation that discount the influence of future transitions \cite{DGJP04,TDZ11}.













































\paragraph{Acknowledgements} We are grateful to Jos\'ee Desharnais for discussions on -bisimulation, Matteo Mio for discussions on approximate semantics of structurally defined probabilistic systems, and Wan Fokkink and David Williams for feedback on earlier versions of this paper. Furthermore, we thank the anonymous referees for thorough reviews and very helpful comments.

\bibliographystyle{eptcs}
\bibliography{concur}



\end{document}
