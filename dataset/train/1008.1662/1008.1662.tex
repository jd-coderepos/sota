\documentclass[copyright]{eptcs}
\providecommand{\event}{DCFS 2010} 

\usepackage{breakurl}             \usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{verbatim}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{proposition}{Proposition}
\newtheorem{conjecture}{Conjecture}
\newtheorem{myalgorithm}{Algorithm}
\newtheorem{definition}{Definition}

\newcommand{\eps}{\varepsilon}
\newcommand{\shift}[1]{\textsc{shift}(#1)}
\newcommand{\nsc}{\mathrm{nsc}}

\renewcommand{\sc}{\mathrm{sc}}
\renewcommand{\le}{\leqslant}
\renewcommand{\ge}{\geqslant}

\def\shu{\mathbin{\mathchoice
  {\rule{.3pt}{1ex}\rule{.3em}{.3pt}\rule{.3pt}{1ex}
  \rule{.3em}{.3pt}\rule{.3pt}{1ex}}
  {\rule{.3pt}{1ex}\rule{.3em}{.3pt}\rule{.3pt}{1ex}
  \rule{.3em}{.3pt}\rule{.3pt}{1ex}}
  {\rule{.2pt}{.7ex}\rule{.2em}{.2pt}\rule{.2pt}{.7ex}
  \rule{.2em}{.2pt}\rule{.2pt}{.7ex}}
  {\rule{.3pt}{1ex}\rule{.3em}{.3pt}\rule{.3pt}{1ex}
  \rule{.3em}{.3pt}\rule{.3pt}{1ex}}\mkern2mu}}

\title{Complexity in Prefix-Free Regular Languages}
\author{Galina Jir\'askov\'a
\thanks{Research supported by VEGA grant 2/0111/09}
\institute{Mathematical Institute\\ Slovak Academy of Sciences\\
   Gre{\v s}{\' a}kova 6, 040 01 Ko\v{s}ice\\ Slovak Republic}
\email{jiraskov@saske.sk}
\and
 Monika Krausov\'a
\institute{Institute of Computer Science\\ Pavol Jozef \v Saf\'arik University,\\
   Jesenn\'a 5, 041 54 Ko\v{s}ice\\ Slovak Republic}
\email{mon.krausova@gmail.com}
}
\def\titlerunning{Complexity in Prefix-Free Regular Languages}
\def\authorrunning{G. Jir\'askov\'a \& M. Krausov\'a}

\begin{document}
\maketitle

\begin{abstract}
  We examine  deterministic and nondeterministic state complexities
  of regular operations on prefix-free languages.
  We strengthen several results by providing witness languages
  over smaller alphabets, usually as small as possible.
  We next provide the tight bounds
  on  state complexity of symmetric difference,
  and deterministic and nondeterministic state complexity of
  difference and cyclic shift of prefix-free languages.
\end{abstract}

\section{Introduction}
\label{***intro}
 A language  is prefix-free 
 if for every string  in  the language,
 no proper prefix of the string is in the language.
 Deterministic and nondeterministic state complexity 
 of basic  operations on prefix-free regular languages
 have  recently been studied by Han and Salomaa \cite{hs09n,hs09}.
 The two papers follow   current research that focuses 
 on complexity in  various sublasses of regular languages
 \cite{bhk09,bjl10,bjz10,hs09s}.

 Here we continue this research and study
 the descriptional complexity of regular operations
 in the class of prefix-free regular languages.
 We strengthen several results on state complexity
 in \cite{hs09n,hs09}
 by providing witness languages over smaller alphabets,
 usually as small as possible.
 We also correct some errors in these two papers,
 in particular, the binary automata used for the result on reversal
 do not provide the claimed lower bound.
 We next study the state complexity of
 difference, symmetric difference, and cyclic shift,
 and provide  tight bounds.

 In the second part of the paper,
 we examine the nondeterministic state complexity of regular operations.
 We introduce a new fooling-set lemma,
 which allows us to give a correct proof for union,
 and to get the tight bound for cyclic shift.
 The idea behind the lemma is
 to find a fooling-set for a regular language
 and then show  that one more state is necessary
 by finding two appropriate strings. 
 We prove tight bounds on the nondeterministic state complexity
 of all basic operations including difference and cyclic shift.

 \section{State Complexity in Prefix-Free Languages}
 \label{***state}

 We start with investigation of
 state complexity of regular operations on prefix-free languages.
 The languages are represented by minimal dfa's,
 thus each of the dfa's has
 exactly one final state going to the dead state
 on every input symbol~\cite{hs09}.
 Then an operation is applied, and we are asking how many states,
 depending on the state complexities of operands,
 are sufficient and necessary in the worst case for a dfa
 to accept the language resulting from the operation.
 The next theorem provides the tight bounds for Boolean operations.
 In the case of union and intersection, the upper bounds are from \cite{hs09},
 where witness languages were defined 
 over a three- and four-letter alphabet, respectively.
 We provide binary witnesses for both operations.
 Then we study symmetric difference and difference,
 and get the tight bounds in the binary and ternary case, respectively.

 \begin{theorem}[Boolean Operations]\label{thm:sc_boolean}
  Let  and let   and 
  be  prefix-free regular languages  with  and .
  Then \\
  1. , and the bound is tight in the binary case; \\
  2. , and the bound is tight in the binary case;\\
  3. , and the bound is tight in the binary case;\\
  4. , and the bound is tight in the ternary case.
 \end{theorem}

 \noindent\emph{Proof.}
  Let the dfa's have states  and ,
  of which  and  are final, and  and  are dead. 
  The initial state is 0.
  
  1.~For tightness, consider binary prefix-free 
  dfa's of Figure~\ref{fig:sc_intersection}.
  The strings
  , , and  with  
  and  are pairwise distinct
  in the right-invariant congruence defined by language .

  \begin{figure}[t]
  \centerline{\includegraphics[scale=.39]{pics/sc_intersection.eps}}
  \caption{The prefix-free  dfa's
           meeting the  bound  for intersection.}
  \label{fig:sc_intersection}
  \end{figure}

  2.~Let 
   and
  . 
  The strings   with   and ,
   and   with , 
  and  and 
  are pairwise distinct 
  for  .
 
  3.~In the cross-product automaton for symmetric difference, the rejecting 
  state  is equivalent to the dead state, and 
  states  and  accept only .
  The same languages as for union meet the bound.

  4.~ All the states 
  of the cross-product automaton
  in the last row and state 
  are dead,  the other states in the last but one row only accept .
  Pairs  and  are equivalent as well.
  This gives the upper bound, 
  which is met by
   and
  .
  \hfill\bigskip

 We now continue with concatenation and star,
 and slightly improve the results from \cite{hs09}
 by providing unary witnesses for concatenation,
 and the complexity of star in the unary case.

 \begin{theorem}[Concatenation and Star]\label{thm:con,star}
  Let 
  and let   and  be  prefix-free regular languages with  . .
  Then \\
  1.  and the bound is tight in the unary case;\\
  2. . The bound is tight in the binary case if .\\
  The tight bound for star in the unary case is  if .
 \end{theorem}

 \noindent\emph{Proof.}
  1. We can get a dfa for the concatenation
  from the dfa's   as follows \cite{hs09}.
  We remove the dead state from the first dfa,
  and merge  the final state in the first dfa  
  with the initial state in the second dfa. 
  All transitions going from a non-final state
  in the first dfa to the dead state will go to the dead state in the second dfa.
  The resulting automaton is a dfa of  states for  concatenation.
  The bound is met 
  by unary prefix-free languages  and .

  2. We make the final state initial,
  and redirect  transitions  from the final state
  to such states, to which they go from the start state.
  The resulting dfa for star has at most  states.
  The upper bound  is met by the binary prefix-free  
  language  \cite{hs09}.
  In the unary case, if , the only -state dfa 
  prefix-free language is .
  The star of this language, , is an -state dfa language.
 \hfill\medskip

 Before dealing with reversal, let us investigate  nfa-to-dfa conversion.
 We recall the result from \cite[Theorem 19, which uses the proof of Theorem 6,
 which in turn uses Moore's proof in \cite{mo71}]{bhk09}.
 We present different ternary witnesses, and give a simple proof. 
 Then we show that the  bound cannot be met in the binary case.

 \begin{theorem}[NFA to DFA Conversion]\label{thm:nfa-to-dfa}
  Let  and let  be a prefix-free language  with .
  Then .
  The bound is tight in the ternary case,  but cannot be met in the binary case.
 \end{theorem}

 \noindent\emph{Proof.}
  Consider an -state nfa recognizing a non-empty prefix-free language.
  The corresponding minimal dfa has
  exactly one final state,
  and so we can merge all final states in the subset automaton.
  This gives the upper bound .

  For tightness, consider the ternary nfa of Figure~\ref{fig:nfa-to-dfa}.
  In the corresponding subset automaton,
  each singleton set and the empty set are reachable.
  Each set  with 
  of size    is reached from 
  set  of size  by .
  Since for each state , the string 
  is accepted by the nfa only from state ,
  no two different states of the subset automaton are equivalent.

  \begin{figure}[b]
  \centerline{\includegraphics[scale=.40]{pics/nfa-to-dfa}}
  \caption{The prefix-free  nfa
            meeting the  bound  for nfa-to-dfa conversion.}
  \label{fig:nfa-to-dfa}
  \end{figure}

  Now consider the binary case.
  In a minimal binary -state prefix-free nfa
  denote by   the final state,
  and by  a state that goes to  by a symbol~.
  In the corresponding subset automaton,
  there must be a state  in 
  that goes to a non-empty subset  of   
  by symbol  because otherwise
  the nfa on states  would be unary, and so
  the number of reachable states in the corresponding subset automaton
  could not be .
  Since all subsets of 
  must be reachable, the subset  is reachable.
  However,  subset  goes to a superset of state  by ,
  which in turn goes by a non-empty string  
  to an accepting state that is reached from the superset.
  This contradicts to prefix-freeness of the accepted language.
 \hfill\medskip

  In the case of reversal, the result in \cite{hs09}
  uses  binary dfa's from \cite{swy04}.
  It is claimed in \cite[Theorem~3]{swy04} that 
  the automata meet the upper bound 
  on the state complexity of reversal. However, this is not  true.
  In the case of , with initial and final state 1,
  the number of reachable states in the subset automaton 
  corresponding to the reverse of
  the dfa is 252 instead of 256: subsets 
  , , , and 
  cannot be reached from any subset by  
  since each of them  contains exactly one of states 1 and 3; 
  and by , there is a cycle among these states.
  A similar reasoning shows that, whenever ,
  the automata with the initial and final state 1 in \cite{swy04}
  do not meet the bound .
  The  binary automata with a single accepting state 
  meeting the upper bound for reversal
  have recently been presented in \cite{se10}.
  We use them to get correct ternary prefix-free witnesses for reversal.

 \begin{theorem}[Reversal]\label{thm:sc_reversal}
  Let  and let  be a prefix-free regular language with .
  Then . The bound is tight in the ternary case,
  but cannot be met in the binary case. 
 \end{theorem}

 \noindent\emph{Proof.}
  We first construct an nfa for the reversal from the given dfa
  by removing the dead state,
  reversing all transitions,
  and switching the role of the initial and final state.
  Since no transition in the resulting nfa goes to the initial state,
  the corresponding subset automaton has at most   states.
  
  \begin{figure}[t]
  \centerline{\includegraphics[scale=.40]{pics/binary}}
  \caption{The binary dfa requiring  states for reversal.}
  \label{fig:binary}
  \end{figure} 

  For tightness, first consider  the binary dfa of  states
  depicted in Figure~\ref{fig:binary}.
  It has been show in \cite{se10}, that the reversal of the language
  recognized by this dfa requires  states.
  Now change the dfa as follows.
  Add two more states  and .
  State  will be the sole final state, while state  will be dead.
  Define transitions on a new symbol :
  state 2 goes to the new final state  by ,
  and each other state  goes to the dead state .
  The resulting automaton is a prefix-free ternary -state dfa 
  requiring  deterministic states for reversal.
 
  Now consider the binary case. 
  Let  be a binary prefix-free witness language.
  Then  because  the minimal dfa for  has the dead state.
  Since ,  language 
  is a binary witness for  nfa-to-dfa conversion.
  Theorem~\ref{thm:nfa-to-dfa} shows that this cannot happen.
 \hfill\medskip

 The state complexity of cyclic shift was examined in \cite{jo08}, 
 where the upper and lower
 bound are only asymptotically tight. The next theorem provides the tight bound
 for this operation in the class of prefix-free regular languages.

 \begin{theorem}[Cyclic Shift]\label{thm:sc_cyclic}
  Let  be a prefix-free  language with .
  Then . The bound is tight
  for a six-letter alphabet. 
 \end{theorem}

 \noindent\emph{Proof.}
  Consider an -state dfa  for a prefix-free language 
  with states ,
  of which 1 is the initial state,
   is the sole final state that goes to the dead state  on each symbol.
  If a string  is in the language ,
  then  for some strings  such that .
  That is, the initial state 1 goes to a state  by ,
  and then from state  to the accepting state  by .
  Thus, a string  is in  if and only if
  there is a state  such that  goes to the accepting state  by ,
  and the initial state 1 goes to state  by .
  Because of prefix-freeness,
  state  is less then  .
  Hence the cyclic shift is the union of  concatenations
  , , where
   and
   (cf. \cite{jo08}).
  Each such concatenation is recognized by a dfa of  states
  since we first remove a dead state from ,
  then merge the final state of  and the initial state of ,
  and finally merge states  and  in 
  since they are dead.
  Thus we have the union of  dfa's,
  each of which has  states,
  which gives the upper bound .

  For tightness, set  and let
  .
  Define a prefix-free dfa  over  of  states ,
  of which 1 is the initial state,
   is the sole accepting state that goes to the dead state  
  by each symbol;
  and for states , the transitions, except for symbol , are defined
  as in Figure~\ref{fig:dfa_cyclic-dany}:
  Next,     by , state  goes to state ,
  and each other state to itself.
  The proof proceeds by showing the reachability 
  and inequivalence of all -tuples in the subset automaton 
  corresponding to  -state nfa for cyclic shift.
  \begin{figure}[t]
  \centerline{\includegraphics[scale=.40]{pics/dfa_cyclic-dany}}
  \caption{The transitions on  in the prefix-free 
           witness dfa for cyclic shift.}
  \label{fig:dfa_cyclic-dany}
  \end{figure}
 \hfill

 \section{Nondeterministic State Complexity}
 \label{***nondet}

 This section deals with the nondeterministic state complexity
 of regular operations on prefix-free languages.
 This time, the languages are represented by nfa's.
 The nfa's have exactly one final state that goes to the empty set by each symbol.
 However,  such an nfa is not guaranteed
 to accept a prefix-free language.
 On the other hand, if such an nfa is a partial dfa, 
 then it accepts a prefix-free language
 since to get the prefix-free dfa for the language 
 we only need to add a dead state.
 If accepted language consists of  strings ending in a symbol 
 that does not occur anywhere else in the string, 
 then such a language is prefix-free as well.

 We are asking how many states, depending 
 on the nondeterministic state complexity of operands, 
 are sufficient and necessary in the worst case for an nfa 
 with a single initial state
 to accept the language resulting from some operation.
 To prove the results we use
 a fooling set lower-bound technique. 
 A set of pairs of strings 
 is called a \emph{fooling set} for a language  if
 (1) for all , the string  is in the language , and
 (2) if , then at least one of  strings
  and  is not in the language .
 It is well-known that the size of a fooling set for a regular language
 provides a lower bound on the number of states
 in any nfa for this language. 
 The next lemma shows that sometimes one more state is necessary.

 \begin{lemma}[\cite{jm10}]\label{le:fool}
  Let  be a regular language.
  Let  and  be sets of pairs of strings
  and let  and  be two strings such that
  ,
  , and
   are fooling sets for .
  Then every nfa for  has at least  states.
 \hfill
 \end{lemma}

 \begin{theorem}[Boolean Operations]\label{thm:boolean}
  Let . Let   and 
  be  prefix-free languages  with  and .
  Then \\
  1. , and the bound is tight in the binary case;\\
  2. , and the bound is tight in the binary case;\\
  3. ,
     and the bound is tight in the ternary case;\\
  4. ,
    and the bound is tight for a four-letter alphabet.
 \end{theorem}

 \noindent\emph{Proof.}
  1.~Let  and  be  and -state prefix-free nfa's
  with initial states  and ,
  and transition functions  and , respectively.
  To get an nfa for the union we add a new initial state
  going to  by each symbol .
  Since both automata are prefix-free,
  we can merge their final states.
  Therefore, the upper bound is .
  To prove tightness, consider  prefix-free languages
   and 
  accepted by an -state and -state nfa, respectively.
  Let  and  be the following set of pairs of strings:
  
  
                       
   \\
   Let us show that the set 
   is a fooling set for  language .
   The concatenation of the first and the second part in each pair results
   in a string in .
   Each of these strings is in language .
   If we concatenate
   the first and the second part in two distinct pairs,
   we get a string in 
    or in
   
   or a string in .
   None of them  is in .
   Next,  
   and 
   are fooling sets for .
   By Lemma~\ref{le:fool}, every nfa for the union
   has at least  states. 
   Notice that the set of pairs in \cite{hs09n} is not a fooling set. 

\label{nsc_intersection}
  2.~In the cross-product automaton for the intersection,
  no string is accepted from states  and ,
  except for the sole final state .
  We can exclude all these states, and get an nfa of  states.
  For tightness, consider binary prefix-free
   nfa's of Figure~\ref{fig:nsc_intersection}.
  \begin{figure}[tb]
  \centerline{\includegraphics[scale=.40]{pics/nsc_intersection}}
  \caption{The prefix-free  nfa's
           meeting the  bound  for intersection.}
  \label{fig:nsc_intersection}
  \end{figure}
  The languages are the same as in the deterministic case for intersection,
  but now they are accepted by nfa's, and so we do not need  dead states.
  Consider the cross-product nfa for the intersection of the two languages,
  and let  be the set of its  states excluding all states
   and , but including state .
   For each state  in ,
  there exist strings  and 
  such that the initial state goes \emph{only} to state  by ,
  and the string  is accepted by the cross-product \emph{only} 
  from state .
  It follows that  the set of pairs 
  is a fooling set for the intersection of the two languages
  since each string  is accepted by the cross-product automaton,
  while  is not if .

\label{part3}
  3. Let  be an -state  nfa for a prefix-free language .
  The equivalent minimal dfa  has exactly one final state ,
  from which all transitions go to the dead state .
  It follows that  dfa  has at most  states.
  After interchanging the accepting and rejecting states in dfa ,
  we get  dfa  for  language  
  with the same number of states as in  .
  In  dfa , all states are accepting, except for state ,
  and moreover, accepting state  goes to itself 
  by each symbol since it was dead in .
  The initial state  of  dfa  is accepting as well.
  Let us construct  nfa  of  states 
  for  from  dfa  as follows.
  First, add a transition by a symbol  from a state 
  to the initial (and accepting) state ,
  whenever  there is a transition in  dfa  from  to  by 
  (in particular,  add transition from  to  by each symbol).
  Next,   make state  rejecting. 
  Finally,  redirect all transitions going to state  to state ,
  and remove state  with all its ingoing and outgoing transitions. 
  The resulting language is  the same, that is ,
  and the nfa  has  states. 
  The prefix-free language , where  is the binary -state 
  nfa language   reaching the bound  for complement \cite{ji05},
  meets the bound since  the set
     is in the fooling set for \  \cite{ji05}
  is a fooling set of size  for language .

\label{part4}
  4. The upper bound 
  for intersection of a  prefix-free -state nfa language 
  and a  regular -state nfa language
  is , and 
  the upper bound for 
  , then follows from part 3.
  For tightness, first let  be the ternary -state nfa 
  prefix-free language from part 3 meeting the bound  for complement.
  Let  be the fooling set for  described in part 3.
  In each state of the nfa for , except for final state ,
  add a loop by , and denote the resulting prefix-free language by~.
  Next, define an -state nfa prefix-free language 
  by .
  Consider the following set 
  
  For each pair in  ,
  the string  is in  .
  The nfa for , as well as the nfa for ,
  goes to a subset of  by .
  In each state of this subset, there is a loop by  in the nfa for ,
  so the nfa is in the same subset after reading .
  Then it proceeds as the nfa for  and rejects since  is in .
  Thus  . 
  On the other hand, if ,
  then  .
  Now assume that , and that  
  and  are two distinct pairs in .
  Then, without loss of generality, , and so .
  Thus there exists an accepting computation of the nfa for  on  string .
  It follows that there also exists an accepting computation 
  of the nfa for  on 
  since after reading  the nfa for  is in a state in ,
  in which there is a loop by  in the nfa for .
  Therefore,  , and so  .
  Hence  
  is a fooling set for language  of size .
  Now, add one more pair  .
  The resulting set is again a fooling set for .
 \hfill

 \begin{theorem}[Concatenation, Reversal, Star]\label{thm:con,rev,star}
  Let   and 
  be  prefix-free  languages  with  and .
  Then \\
  1. , and the bound is tight in the unary case; \\
  2. , and the bound is tight in the unary case;\\
  3. , and the bound is tight in the binary case.
 \end{theorem}

 \noindent\emph{Proof.}
  1. Since both languages are prefix-free,
  to get an nfa for their concatenation,
  we  merge the final state in the nfa for 
  with the initial state  in the nfa for .
  This gives the upper bound .
  For tightness, consider unary  prefix-free regular languages 
   and .
  Their concatenation  is .
  Every singleton language 
  is accepted by a -state nfa, and the nfa is minimal
  since  
  is a fooling set for such a language.

  2. To obtain an -state nfa for the reversal,
  we reverse all transitions in the nfa for a prefix-free language ,
  and switch the role of the initial and the sole accepting state.
  The unary language  meets the bound.

  3. Since  language  is prefix-free,
  we can construct an nfa for  language 
  from the nfa for , with the initial state , final state ,
  and transitions function  as follows.
  We make  final  state  initial, thus  will be accepted.
  We add transitions by each symbol 
  from state   to .
  The resulting -state nfa recognizes .
  For tightness, consider  binary prefix-free language .
  Since the set 
   
  is a fooling set for  language  of size ,
  every nfa for the star  requires  states.
 \hfill

 \begin{theorem}[Cyclic Shift]\label{thm:cyclic}
  Let  and let  be a prefix-free regular language  with .
  Then .
  The bound is tight in the binary case.
 \end{theorem}

 \noindent\emph{Proof.}
  The construction in  Theorem~\ref{thm:sc_cyclic}
  gives an -state nfa for the cyclic shift
  with a set 
  of initial states.
  To get an nfa with a single initial state,
  we add a new initial state going to  by the empty string.
  \begin{figure}[b]
  \centerline{\includegraphics[scale=.40]{pics/cyclic}}
  \caption{The prefix-free nfa meeting the bound  on cyclic shift.}
  \label{fig:cyclic}
  \end{figure}
  For tightness, consider the binary language
  accepted by the nfa of Figure~\ref{fig:cyclic}.
  The proof proceeds by  describing a fooling set 
  for the cyclic shift of this language
  of size . Then we use Lemma~\ref{le:fool}
  to prove that one more state is necessary. 
 \hfill

\bibliographystyle{eptcs}
\bibliography{bibliography}

\end{document}
