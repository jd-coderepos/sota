\newcommand{\short}[1]{#1}
\newcommand{\full}[1]{#1}
\renewcommand{\short}[1]{}


\documentclass{llncs} 

\usepackage{times}

\usepackage{xspace}


\newcommand{\eg}{e.g.,\xspace}
\newcommand{\ie}{i.e.,\xspace}
\newcommand{\etc}{etc\@.\xspace}
\usepackage{graphicx}
\usepackage[font=small,skip=0pt]{caption}
\usepackage{epstopdf}



\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\algnewcommand\algorithmicswitch{\textbf{switch}}
\algnewcommand\algorithmiccase{\textbf{case}}
\algdef{SE}[SWITCH]{Switch}{EndSwitch}[1]{\algorithmicswitch\ #1\ \algorithmicdo}{\algorithmicend\ \algorithmicswitch}\algdef{SE}[CASE]{Case}{EndCase}[1]{\algorithmiccase\ #1}{\algorithmicend\ \algorithmiccase}\algtext*{EndSwitch}\algtext*{EndCase}

\newcommand{\atlr}{RBATL\xspace}
\newcommand{\atlm}{ATL^m}
\newcommand\RBATL{RB-ATL\xspace}
\newcommand\nat{\mathbb{N}}
\newcommand\natinfty{\nat_{\infty}}
\newcommand\integer{\mathbb{Z}}
\newcommand\arb{\ensuremath{\mathit{arb}}}
\newcommand{\llangle}{(\!(}
\newcommand{\rrangle}{)\!)}
\newcommand{\ceil}[1]{\lceil #1 \rceil}
\newcommand{\NBox}{\ensuremath{\mathbf{G}}}
\newcommand{\NDiam}{\ensuremath{\mathbf{F}}}
\newcommand\jact[1]{(#1)}
\newcommand\idle{idle\xspace}

\newcommand{\Res}{Res}
\newcommand{\Act}{Act}

\newcommand\PNtran[1]{\,[{#1})\,}

\usepackage{macrosbulling2015}
\newcommand{\share}{\ensuremath{\mathsf{sh}}}
\newcommand{\rbm}{\acro{RBM}}
\newcommand{\Resources}{\resourcedomain}
\newcommand{\resourcedomain}{\ensuremath{{\mathcal{R}\!\mathit{es}}}}
\newcommand{\rop}[1]{\ensuremath{\circ^{#1}}}
\newcommand{\rhooutcome}[3]{\ensuremath{\mathit{out}(#1,#2,#3)}}
\newcommand{\krhooutcome}[3]{\ensuremath{\mathit{out_k}(#1,#2,#3)}}
\newcommand{\cooppro}[1]{\ensuremath{(#1)}}
\renewcommand{\model}{\ensuremath{\mathfrak{M}}\xspace}
\newcommand{\enment}{\ensuremath{\eta}\xspace}
\newcommand{\rqm}{\acro{rqm}}
\newcommand{\production}{\mathsf{prod}}
\newcommand{\consumption}{\mathsf{cons}}
\newcommand{\Enments}{\ensuremath{\mathsf{En}}}

\newcommand{\nils}[1]{{\text{\color{red}Nils: #1}}}
\newcommand{\brian}[1]{{\color{blue}Brian: #1}}
\newcommand{\nga}[1]{{\color{magenta}Nga: #1}}
\renewcommand{\brian}[1]{}


\newcommand{\modelsR}{\ensuremath{\models_R}\xspace}
\newcommand{\modelsr}{\ensuremath{\models_r}\xspace}

\newcommand\AO[2]{\llangle #1 \rrangle \!\bigcirc\! #2}
\newcommand\AOd[2]{\llangle #1 \rrangle^{\downarrow} \!\bigcirc\! #2}
\newcommand\AOe[2]{\llangle #1 \rrangle^{\enment} \!\bigcirc\! #2}

\newcommand\AG[2]{\llangle #1 \rrangle \NBox #2}
\newcommand\AGd[2]{\llangle #1 \rrangle^{\downarrow} \NBox #2}
\newcommand\AGe[2]{\llangle #1 \rrangle^{\enment} \NBox #2}

\newcommand\AU[3]{\llangle #1 \rrangle #2 \,{\cal U}\, #3}
\newcommand\AUd[3]{\llangle #1 \rrangle^{\downarrow} #2 \,{\cal U}\, #3}
\newcommand\AUe[3]{\llangle #1 \rrangle^{\enment} #2 \,{\cal U}\, #3}

\newcommand{\coopeta}[1]{\ensuremath{\coop{#1}}}

\newcommand{\coopdown}[2][]{\ensuremath{\coop{#2}{}_{#1}^{\downarrow}}}
\newcommand{\coopdownpr}[1]{\ensuremath{\coop[pr]{#1}^{\downarrow}}}


\newcommand{\ralnew}{\ensuremath{\mathsf{RL}}\xspace}
\newcommand{\ralnewrf}{\ensuremath{\mathsf{rf\!\!-\!\!RL}}\xspace}
\newcommand{\rbmif}{\textsf{if-RBM}\xspace}
\newcommand{\rbmi}{\acro{iRBM}}
\newcommand{\ral}{\ensuremath{\mathsf{RAL}}\xspace}
\renewcommand{\modelsR}{\models}
\newtheorem{observation}{Observation}
\newcommand{\fral}{\ensuremath{\mathsf{prRAL^r}}\xspace}


\newcommand{\rfral}{\ensuremath{\mathsf{rfRAL}}\xspace}
\newcommand{\prral}{\ensuremath{\mathsf{prRAL}}\xspace}
\newcommand{\rfprral}{\ensuremath{\mathsf{rfprRAL}}\xspace}

\renewcommand{\CTL}{\ensuremath{\mathsf{CTL}}\xspace}
\renewcommand{\ATL}{\ensuremath{\mathsf{ATL}}\xspace}








\newcommand{\wall}{\begin{aligned}[t] &}
\newcommand{\next}{\\ &}
\newcommand{\return}{\end{aligned}}


\newcommand{\inductioncase}[1]{\noindent\textbf{#1}}

\let\phi\varphi

\title{Model Checking Resource Bounded Systems with Shared Resources via Alternating B\"uchi Pushdown Systems}
\author{Nils Bulling\inst{1}  \and Hoang Nga Nguyen\inst{2} }
\institute{
Delft University of Technology, The Netherlands \and
School of Computer Science, University of Nottingham, UK\\
}





\begin{document}

\maketitle


\begin{abstract}
It is well known that the verification of resource-constrained multi-agent systems is undecidable in general. In many such settings, resources are private to agents. In this paper, we investigate the model checking problem for a resource logic based on Alternating-Time Temporal Logic (\ATL) with shared resources. Resources can be consumed and produced up to any amount. We show that the model checking problem is undecidable if two or more of such unbounded resources are available. Our main technical result is that in the case of a single shared resource, the problem becomes decidable. Although intuitive, the proof of decidability is non-trivial. We  reduce model checking to a problem over alternating B\"uchi pushdown systems. An  intermediate result connects to general automata-based  verification: we show that model checking Computation Tree Logic (\CTL) over (compact) alternating B\"uchi pushdown systems is decidable.
\end{abstract}

\section{Introduction and Related Work}
Research on resource-constrained multi-agent systems has become a popular topic in recent years, e.g.~\cite{BullingFarwer09rtl-clima-post,Bulling/Farwer:10a,Alechina//:10a,DellaMonica//:13a,Alechina//:14c,Bulling15ral-IJCAI}. In particular, the verification of strategic agents acting under resource-constraints has been investigated by  researchers; many of these approaches extend the alternating-time temporal logic (\ATL)~\cite{Alur//:02a} with actions that, in the general case, consume or produce resources. If no bound on the possible amount of resources is given the model checking problems are easily undecidable~\cite{Bulling/Farwer:10a}. Exceptions are possible if restrictions are imposed on the language~\cite{Bulling15ral-IJCAI} or on the semantics~\cite{Alechina//:14c,DellaMonica//:13a}. In many settings,  resources are private to agents, each agent has its own set of resources. In~\cite{DellaMonica//:13a}  resources are shared and a resource money is used to claim resources. The authors present a decidable model checking result which is possible as the amount of resources is bounded. In this paper we are interested in the model checking problem where resources are shared and \emph{unbounded}; resources can be consumed and produced without an upper bound on the total number of resources. The setting is rather natural. Resources are shared in e.g.,  the travel budget of a computer science department. All departmental members compete for the travel budget. Parts of the travel money of a successful grant application will be credited to the department's budget; there is no a priori bound on the total budget.

In this paper, we show that the model checking problem for the resource agent logic ~\cite{Bulling/Farwer:10a} considered here is undecidable in general  when there are more than two of such unbounded shared resources. This result follows as a corollary from~\cite{Bulling/Farwer:10a,Bulling15ral-IJCAI} where model checking resource bounded systems with private, unbounded resources has been proved undecidable. 
Secondly, we show that model checking  \ral is decidable in case of  a single shared, unbounded resource. Although this seems intuitive, as a single unbounded resource can intuitively  be encoded by a single stack/counter, its proof is (technically)  non-trivial and is based on a reduction to  alternating B\"uchi pushdown systems~\cite{song2014efficient,bouajjani1997reachability}. We first introduce  compact alternating B\"uchi pushdown systems (CABPDSs)  to encode the resource bounded models of our logic such  that the runs of the automaton can be related to execution trees of a given set of agents in the model. We show that model checking \CTL over these systems is decidable using results of~\cite{song2014efficient}. Finally, we reduce model checking \ral to model checking \CTL over CABPDSs. These results extend work on model checking \CTL over pushdown systems where atomic propositions can be given by regular languages~\cite{song2014efficient}. The latter results, in turn, are based on~\cite{bouajjani1997reachability} where reachability of alternating pushdown systems and model checking problems over pushdown systems with standard labelling functions are investigated. Model checking \CTL  over pushdown systems and its computational complexity have also been considered in~\cite{bozzelli2007complexity}. Our model checking problem is also related to reachability in B\"uchi games~\cite{cachat2002symbolic}. Many complexity results about ABPDSs and their variants are known and established in the above mentioned pieces of work. In our future research we  plan to determine the exact computational complexity of the model checking problem for resource agent logic (\ral) over  -unbounded resource bounded models.

The paper is organised as follows. In Section~\ref{sec:logic} we \full{discuss different resource types and} introduce our version of resource agent logic with shared resources.  In Section~\ref{sec:ABPDS} we recall  alternating B\"uchi pushdown systems (ABPDSs) and variants thereof. We propose compact ABPDSs for encoding our models. We show that model checking \CTL over them is decidable. In Section \ref{sec:decidable} we give our main decidability result for a single unbounded resource\short{ and also conclude undecidability for the general setting with more than 1-unbounded shared resource}. Finally, \full{in Section~\ref{sec:undecidable} we consider the general case and show that model checking is undecidability if at least two unbounded resource types are available, and }\short{we }conclude in Section~\ref{sec:concl}. \short{Due to lack of space, we have to skip details and proofs. An extended version of this paper  can be found  in~\cite{Bulling15ABPDS-xarchive}.}
\vspace{-0.4cm}

\section{Resource Agent Logic} \label{sec:logic} 
In this section we define the logic \emph{resource agent logic} \ral and resource-bounded models. The framework is essentially based on~\cite{Bulling15ral-IJCAI}. \full{We begin with a discussion on different resource types which can be classified among different dimensions:
\begin{description}
\item \emph{Private} resources are assigned to individual agents.
\item \emph{Shared} resources can be accessed by all agents; they are global.
\item \emph{Consumable/producible} resources can be consumed and produced. They often disappear after usage, like gasoline and energy, and may thus also be  labelled \emph{fluent}.
\item \emph{Re-usable} resources do not in general disappear after usage. They may also be produced.
\item \emph{Bounded/unbounded} resource types characterise whether arbitrarily many resources can be produced or if there is a bound on the maximal amount.
\end{description}
We note that the property of boundedness has a different flavour in comparison to the other properties. It is better understood as a property of the agents or of the specific modelling rather than of the resource itself. For example, the agent can only carry up to two heavy boxes, or there are legislations which prohibit to have more than three cars in a household. In this paper we are interested in shared, unbounded, consumable  resource types. That is, there is a common pool of resources for which all agents compete. Agents' actions may consume resources or produce them, always affecting the common pool of resources. Moreover, there can be arbitrarily many resources of a resource type.


Clearly, in real settings there will usually be a combination of different resource types. Adding bounded resources will in general not affect the decidability of model checking. Such resources can be encoded in the states, blowing up the model. One has to be more careful with unbounded resources. Having at least two  unbounded resource types is often a first indication for an  undecidable model checking problem if no other restrictions are imposed on the  setting.} \short{But, in this paper we are intersted in \emph{shared resources}. There is a common pool of resources and agents compete for them. There are more dimensions along which resources can be classified~\cite{Bulling15ABPDS-xarchive}, one of these dimensions is \emph{boundedness}. A resource is called \emph{unbounded} if there is no a priori bound on the number of available resources, in principle they can be produced without limit. Settings with only bounded resources are often  decidable~\cite{Bulling/Farwer:10a}. In the following we consider unbounded resources and assume that   is a finite non-empty set of such unbounded, shared resource types. } 
\full{Following the discussion above, we define a}\short{A }  \emph{(shared) endowment (function)} 
\full{to specify}\short{specifies} the available shared resources of the resource types   in the system; i.e.,  is the number of shared resources of type .  With  we denote the set of all possible endowments.  A special minimal endowment function is denoted by . It expresses that there are no resources at all. 

\full{\begin{definition}[Shared resource structure, unbounded]
A \emph{(shared) resource structure} is a tuple  where  is a finite set of shared  consumable resources. Function  is called \emph{resource bound}. It specifies the maximal number of resources of a specific type in the model. We say that  is \emph{-unbounded} iff the number of unbounded resource types is at most .
\end{definition}}

\textbf{Syntax.} Resource agent logic (\ral) is defined over a set of agents  and a set of propositional symbols .  
\ral-formulae\footnote{Note that we slightly change the notation in comparison with~\cite{Bulling/Farwer:10a} where  has the meaning of . Moreover, we only use operators that refer to the currently available resources in the system.}
are essentially generated according to the grammar of ~\cite{Alur//:02a} 
as follows:  
where  is a proposition and  is a set of agents. 
        
        A formula   is called \emph{flat} if  contains no  cooperation modalities. The operators , , and  denote the standard temporal operators expressing that some property holds in the \emph{next} point in time,  \emph{until} some other property holds, and \emph{now and always} in the future, respectively.  The \emph{eventually} operator is defined as macro:  (\emph{now or sometime in the future}).  
The  cooperation modality    assumes that \emph{all} agents  in \Agents act under resource constraints. The reading of  is that
           \emph{agents  have a strategy compatible with the currently available resources} to enforce . 
This  means that the strategy can be executed given the agents' resources. Thus, it is necessary to keep track of resource production and consumption during the execution of a strategy. 



           
\textbf{Semantics.} We define the models of \ral as in~\cite{Bulling15ral-IJCAI}. We also introduce a special class of these models in which agents have an \emph{idle action} in their repertoire that neither consumes nor produces resources. Note that a model with idle actions is a special case of the general model.
           


\vspace{-1ex}
\begin{definition}[\rbm, \rbmi, unbounded]
A resource-bounded model (\rbm) is given by  where \full{ is a shared resource structure}\short{ is a set of shared, unbounded resources},  is a set of agents;  is a valuation of
propositions;  is a finite set of actions; and the function  indicates the actions available to agent  at state . We write  instead of , and use  to denote the set
 of action profiles in state . Similarly,  denotes the action tuples available to  at .  is a
 transition function which maps each state  and action profile
 (specifying a
move for each agent) to another state . Finally, the
function  models the resources consumed and
produced by actions. We define  (resp.\ ) as the
amount of resource  produced (resp.\ consumed) by action .  For , we use
 to denote the sub-tuple consisting of the actions of agents .\short{ We call an \rbm \emph{-unbounded} if  for a natural number .} 



An \emph{\rbm with idle actions},  for short, is an \rbm \model such that for all agents , all states , there is an action  such that for all resource types  in \model we have that  . We refer to this action (or to one of them if there is more than one) as the \emph{idle action} of  and denote it by .
\end{definition}



\vspace{-2ex}
A \emph{path}   is an infinite sequence
of states such that there is a transition between two adjacent states. A
\emph{resource-extended} path  is an infinite sequence over
 such that the restriction to states (the first component),
denoted by , is a path in the underlying model.  The projection of
 to the second component of each element in the sequence is denoted by
. 
We define  to be the -th element of , and
 to be the suffix . A \emph{strategy}\footnote{{We note that differently from~\cite{Bulling/Farwer:10a,Alechina//:14c,Bulling15ral-IJCAI}, our notion of strategy takes the history of states as well as the history of endowments into account. In the setting considered here such strategies are more powerful than strategies only taking the state-component into account.}} for a coalition  is a function 
 such that  for . Such a strategy gives rise to a set of (resource-extended) paths that can emerge if agents  follow their  strategies. A \emph{-path} is a resource-extended path  such that for all 
with  there is an action profile
 such that:
\full{\begin{enumerate}}
\full{\item }\short{(i) } and   for all  (describes  initial configuration); 
\full{\item }\short{(ii) }  
 ( follow their strategy); 
\full{\item }\short{(iii) }  
 (transition according to ); 
\full{\item }\short{(iv) } for all  and for all :  
 (enough resources to perform the actions are available); and
 \full{\item}\short{(v)}    for all .
\full{\end{enumerate}} Condition (iv) models that the opponents have priority when claiming resources.









The \emph{-outcome} of a strategy  in ,
, is defined as the set of all  -paths
starting in . We also refer to this set as an \emph{execution tree} of .  Truth is defined over an \rbm , a state , and an endowment
. The \emph{semantics} is given by the satisfaction relation
\full{ defined below}. \short{Here, we only present clauses for two types of formulae: 
  iff  and ; and 
    iff  there exists a strategy  for  such that for all , there is an  with  and 
     such that 
    for all  with  it holds that 
    . The other clauses are given analogously, cf.~\cite{Bulling15ABPDS-xarchive}. }
\full{\begin{description}
\item[]
  iff  and .
 \item[]
   iff  and 
 \item[]
   iff it is not the case that  
\item[]
  iff there is a strategy  for  such that
  for all , 
  


\item[]
  iff  there exists a strategy  for  such that for all , there is an  with  and 
   such that 
  for all  with  it holds that 
  
  
 \item[]
   iff there exists a strategy  for  such that for all  and 
   all , 
    



\end{description}}
The  \emph{model checking problem} is to determine whether   holds. 













\textbf{Example.} We illustrate the framework by extending  the introductory example on the departmental 
travelling budget. Consider a  department
which consists of a dean , two professors  and three lecturers 
 and . The department's  travel budget 
is allocated  annually and can be spent 
to attend  conferences. 
There
are three categories to request money: premium, 
advanced, and economic. All options are available to the dean,
the last two to professors, and only the last one to the lecturers.
For instance, if the cost of attending PRIMA\full{\footnote{PRIMA is the acronym for the conference Principles and Pratice of Multi-Agent Systems. A short version of this paper was accepted for PRIMA 2015~\cite{Bulling15ABPDS}.}} is, depending on the category, \1000, and \4000 not all lecturers can be sure to be able to attend PRIMA. Because,  the dean and the professors could all decide to attend PRIMA and to request the advanced category. In that case, only \\coopdown{d,p_1,p_2}\Sometm(\prop{d}\wedge \prop{p_1}\wedge\prop{p_2}\wedge\neg \coopdown{\{l_1,l_2,l_3\}}\Sometm(\prop{l_1}\wedge \prop{l_2}\wedge\prop{l_3}))\prop{x}x\neg \coopdown{\{l_1,l_2,l_3\}}\Sometm(\prop{l_1}\wedge \prop{l_2}\wedge\prop{l_3}))\coopdown{\{p_1,p_2,l_1,l_2,l_3\}}\Sometm (\prop{l_1}\wedge \prop{l_2}\wedge\prop{l_3})\Gamma\Gamma^*\Gamma\epsilon\Gammaa,b,\ldotsw,v,u,\ldots\Props\Gamma\Gamma^*\Gamma\epsilon\Gammaa,b,\ldotsw,v,u,\ldots\Propsw=a_1\ldots a_na_1a_2a_n\APDS=(P,\Gamma,\Delta)P\Gamma\Delta\subseteq(P\times \Gamma)\times \powerset{P\times\Gamma^*}(s,a)\Delta X|X|=1X\in\powerset{P\times\Gamma^*}\ABPDS=(P,\Gamma,\Delta,F)F\subseteq P(p,a)\Delta\{(p_1,w_1),\ldots,(p_n,w_n)\}panip_iaw_i1\leq i\leq n(p,a)\Delta\{(p_1,w_1),\ldots,(p_n,w_n)\}w\in\Gamma^*(p,wa)\{(p_1,ww_1),\ldots,(p_n,ww_n)\}(p,wa)\Rightarrow_\ABPDS\{(p_1,ww_1),\ldots,(p_n,ww_n)\}\{(p_1,ww_1),\ldots,(p_n,ww_n)\}(p,wa)(p,a)\Delta(p',w)(p,a)\Delta\{(p',w)\}\#\#\#\Gamma\#\#\ABPDS\Cnf_\ABPDS=P\times\Gamma^*c\rhoc\ABPDSc(p,w)n(p_1,w_1),\ldots,(p_n,w_n)(p,w)\Rightarrow_\ABPDS\{(p_1,w_1),\ldots,(p_n,w_n)\}\Runs_\ABPDS(c)cX(p,a)\Delta X\Runs_\ABPDS=\bigcup_{c\in\Cnf_\ABPDS}\Runs_\ABPDS(c)\rho\rho\in\Runs_\ABPDS(c)\kappa=c_0c_1\ldots\rhoc\rho\kappa\in\rho\kappa\rho\kappa\in\rhoF\kappa\kappa\in\rhoc\rho\in\Runs_\ABPDS(c)\ABPDSL(\ABPDS)\Rightarrow^*_\ABPDS\subseteq(P\times\Gamma^*)\times\powerset{P\times\Gamma^*}\Rightarrow_\ABPDSc\Rightarrow^*_\ABPDS\{c\}cc\Rightarrow_\ABPDS Cc\Rightarrow^*_\ABPDS Cc\Rightarrow^*_\ABPDS \{c_1,\ldots,c_n\}c_i\Rightarrow^*_\ABPDS C_i1\leq i\leq nc\Rightarrow^*_\ABPDS\bigcup_i C_i\AAut=(S,\Sigma,\delta, I, S_f)S\delta\subseteq S\times \Sigma\times\powerset{S}\SigmaI\subseteq SS_f\subseteq S\Rightarrow^*_\ABPDS\rightarrow^*_\AAut\subseteq (S\times\Sigma^*)\times \powerset{S}s\stackrel{w}{\rightarrow}^*_\AAut S'(s,w,S')\in\rightarrow^*_\AAuts\stackrel{\epsilon}{\rightarrow}^*_\AAut\{s\}(s,a,S')\in\deltas\stackrel{a}{\rightarrow}^*_\AAut S's\stackrel{w}{\rightarrow}^*_\AAut\{s_1,\ldots,s_n\}s_i\stackrel{a}{\rightarrow}^*_\AAut S_i1\leq i\leq ns\stackrel{wa}{\rightarrow}^*_\AAut\bigcup_iS_i(s,w)\in S\times\Sigma^*s\stackrel{w}{\rightarrow}^*_\AAut S'S'\subseteq S_fs\in Iw\AAutL(\AAut)\ABPDS=(P,\Gamma,\Delta,F)(S,\Sigma,\delta, I, S_f)I\subseteq P\subseteq S\Gamma=\Sigma\ABPDS\AAutL(\AAut)=L(\ABPDS)\ral\phi::= \prop{p} \mid \neg\phi\mid \phi \wedge \phi \mid 
\Epath\Next \varphi\mid \Epath\Always \varphi \mid \Epath( \varphi \NUntil \psi)\prop{p}\in\Props\Epath\Epath\varphi\varphi\Sometm\varphi\equiv \true\NUntil\varphi\Apath\Next\varphi\equiv\neg\Epath\Next\neg\varphi\Apath\Always\varphi\equiv\neg\Epath\Sometm\neg\varphi\Apath\varphi\NUntil\psi\equiv \neg\Epath((\neg\psi)\NUntil(\neg\varphi\wedge\neg\psi))\wedge\neg\Always\neg\psi\Apath\varphi\varphi\vee\Release\Apath\varphi_1\Release\varphi_2=\neg\Epath(\neg\varphi_1)\NUntil(\neg\varphi_2)\Epath\varphi_1\Release\varphi_2=\neg\Apath(\neg\varphi_1)\NUntil(\neg\varphi_2)\varphi\varphi\varphi\varphi\cl(\varphi)\varphi\Props^+(\varphi)=\{\prop{p}\in\Props\mid \prop{p}\in\cl(\varphi)\}\Props^-(\varphi)=\{\prop{p}\in\Props\mid \neg\prop{p}\in\cl(\varphi)\}\varphi\cl_\Release(\varphi)\Apath(\varphi_1\Release\varphi_2)\Epath(\varphi_1\Release\varphi_2)\cl(\varphi)\LogCTL\Epath\Apath\Epath\varphi\varphi\Apath\varphi\varphi\lab\lab:\Props\rightarrow\powerset{P}\lab:\Props\rightarrow\powerset{P\times\Gamma^*}\lab\AAut_{\prop{p}}L(\AAut_{\prop{p}})=\lab(\prop{p})\prop{p}\in\Props\PDS=(P,\Gamma,\Delta)c\in\Cnf_\PDS\lab:\Props\rightarrow\powerset{P\times\Gamma^*}\PDS,c,\lab\models \Epath\Always\varphic\rho=c_0c_1,\ldots\in\Runs_\PDS(c)\PDS,c_i,\lab\models\varphii\geq 0\models\PDS,c,\lab\models \prop{p}c\in\lab({\prop{p}})\PDS,c,\lab\models \neg\varphi\PDS,c,\lab\models \varphi\PDS,c,\lab\models \varphi_1\wedge\varphi_2 \PDS,c,\lab\models \varphi_1\PDS,c,\lab\models \varphi_2\PDS,c,\lab\models \Epath\Next\varphic\rho=c_0c_1,\ldots\in\Runs_\PDS(c)\PDS,c_1,\lab\models\varphi\PDS,c,\lab\models \Epath\Always\varphic\rho=c_0c_1,\ldots\in\Runs_\PDS(c)\PDS,c_i,\lab\models\varphii\geq 0\PDS,c,\lab\models \Epath\varphi_1\NUntil\varphi_2c\rho=c_0c_1,\ldots\in\Runs_\PDS(c)i\in\mathbb{N}_0\PDS,c_i,\lab\models\varphi_20\leq j<i\PDS,c_j,\lab\models\varphi_1\PDS\lab\varphi\ABPDS_{\PDS,\varphi}\PDS,(p,w),\lab\models\varphi((p,\varphi),w)\in L(\ABPDS_{\PDS,\varphi})\cl(\varphi)\varphi\cl(\varphi)\varphi\ABPDS_{\PDS,\varphi}(p,\psi)\in P\times\cl(\varphi)\lab\varphi\AAut_{\PDS,\varphi}c=(p,w)\in\Cnf_\PDS\PDS,c,\lab\models\varphi((p,\varphi),w)\in L(\AAut_{\PDS,\varphi})\ABPDS,c,\lab\models \Epath\varphi\rho\in\Runs_\ABPDS(c)\varphi\rho\varphi\varphi\kappa\in\rho\Epath\varphi\rho\varphi\kappa\in\rhoc\in\Cnf_\ABPDS\lab\ABPDS,c,\lab\models \Epath\Always\varphic\rho\in\Runs_\ABPDS(c)c_0c_1\ldots\in\rho\ABPDS,c_i,\lab\models\varphii\geq 0c\in\Cnf_\ABPDS\lab\ABPDS,c,\lab\models \prop{p}c\in\lab(\prop{p})\ABPDS,c,\lab\models \neg\varphi\ABPDS,c,\lab\models \varphi\ABPDS,c,\lab\models \varphi_1\wedge\varphi_2 \ABPDS,c,\lab\models \varphi_1\ABPDS,c,\lab\models \varphi_2\ABPDS,c,\lab\models \Epath\Next\varphic\rho\in\Runs_\ABPDS(c)c_0c_1\ldots\in \rho\ABPDS,c_1,\lab\models\varphi\ABPDS,c,\lab\models \Epath\Always\varphic\rho\in\Runs_\ABPDS(c)c_0c_1\ldots\in\rho\ABPDS,c_i,\lab\models\varphii\geq 0\ABPDS,c,\lab\models \Epath\varphi_1\NUntil\varphi_2c\rho\in\Runs_\ABPDS(c)c_0c_1\ldots\in\rhoi\in\mathbb{N}_0\ABPDS,c_i,\lab\models\varphi_20\leq j<i\ABPDS,c_j,\lab\models\varphi_1\lab\varphi\AAut_{\ABPDS,\varphi}c=(p,w)\in\Cnf_\ABPDS\ABPDS,c,\lab\models\varphi((p,\varphi),w)\in L(\AAut_{\ABPDS,\varphi})\ABPDS_{\varphi}\ABPDS=(P,\Gamma,\Delta,F)\lab:\Props\rightarrow\powerset{P\times\Gamma^*}\varphi\prop{p}\in\Props\AAut_{\prop{p}}=(S_\prop{p},\Gamma,\delta_\prop{p},I_\prop{p},F_\prop{p})\ABPDSL(\AAut_\prop{p})=\lab(\prop{p})\AAut_{\neg \prop{p}}L(\AAut_{\neg \prop{p}})=P\times\Gamma^*\backslash \lab(\prop{p})\prop{p}S_\prop{p}pp_\prop{p}L(\AAut_\prop{p})\subseteq P_\prop{p}\times \Gamma^*L(\AAut_\prop{p})\subseteq P\times \Gamma^*P_\prop{p}P\ABPDS_{\varphi}(p,\prop{p})\AAut_{\prop{p}}\AAut_\prop{p}p_{\prop{p}}\AAut_{\neg\prop{p}}\ABPDS_{\varphi}=(P',\Gamma,\Delta',F')P'=(P\times\cl(\varphi))\cup\bigcup_{\prop{p}\in\Props^+(\varphi)}S_{\prop{p}}\cup\bigcup_{\prop{p}\in\Props^-(\varphi)}S_{\neg\prop{p}}F'=(P\times\cl_\Release(\varphi))\cup\bigcup_{\prop{p}\in\Props^+(\varphi)}F_{\prop{p}}\cup\bigcup_{\prop{p}\in\Props^-(\varphi)}F_{\neg\prop{p}}\Delta'\subseteq (P'\times\Gamma)\times\powerset{P'\times\Gamma^*}((p,\prop{p}),a)\Delta'(p_\prop{p},a)\prop{p}\in\Props((p,\neg\prop{p}),a)\Delta'(p_{\neg\prop{p}},a)\prop{p}\in\Props((p,\varphi\wedge\psi),a)\Delta'\{(p,\varphi),a),((p,\psi),a)\}((p,\varphi\vee\psi),a)\Delta'\{(p,\xi),a)\}\xi\in\{\varphi,\psi\}((p,\Epath\Next\varphi),a)\Delta'\{((p',\varphi),w') \mid (p',w') \in X\}(p,a)\Delta X((p,\Apath\Next\varphi),a)\Delta'\bigcup_{(p,a)\Delta X}\{((p',\varphi),w') \mid (p',w') \in X\}((p,\Epath\varphi\NUntil\psi),a) \Delta'((p,\psi),a)((p,\Epath\varphi\NUntil\psi),a)\Delta'\{((p,\varphi),a)\}\cup \{((p',\Epath\varphi\NUntil\psi),w')\mid (p',w') \in X\}(p,a)\Delta X((p,\Apath\varphi\NUntil\psi),a) \Delta'((p,\psi),a)((p,\Apath\varphi\NUntil\psi),a)\Delta'\{((p,\varphi),a)\}\cup \bigcup_{(p,a)\Delta X}\{((p',\Apath\varphi\NUntil\psi),w')\mid (p',w') \in X\}((p,\Epath\varphi\Release\psi),a) \Delta'((p,\varphi),a)((p,\Epath\varphi\Release\psi),a)\Delta'\{((p,\psi),a)\}\cup\{((p',\Epath\varphi\Release\psi),w')\mid (p',w') \in X\}(p,a)\Delta X((p,\Apath\varphi\Release\psi),a) \Delta'((p,\varphi),a)((p,\Apath\varphi\Release\psi),a)\Delta'\{((p,\psi),a)\}\cup\bigcup_{(p,a)\Delta X}\{((p',\Apath\varphi\Release\psi),w')\mid (p',w') \in X\}(s,a,S')\in (\bigcup_{\prop{p}\in \Props^+(\varphi)}\delta_\prop{p}\cup \bigcup_{\prop{p}\in \Props^-(\varphi)}\delta_{\neg\prop{p}})(s,a)\Delta'\{(s',\epsilon) \mid s' \in S'\}s\in(\bigcup_{\prop{p}\in \Props^+(\varphi)}F_\prop{p}\cup \bigcup_{\prop{p}\in \Props^-(\varphi)}F_{\neg\prop{p}})(s,\#)\Delta'(s,\#)\ABPDS_{\varphi}\CTL\ABPDS_\varphi((p,\Epath\Next\psi),wa)\ABPDS_\varphiX\Epath(p,a)\Delta X\ABPDS_\varphiX\Next\ABPDS_\varphiP\times\cl_\Release(\varphi)\ABPDS,(p,w),\lab\models\psi((p,\psi),w)\in L(\ABPDS_{\varphi})\psi \in \cl(\phi)1r\geq 1r\CABPDS=(P,\Gamma,\Delta,F,r)\Delta \subseteq P\times \Gamma^{\leq r} \times \powerset{P\times\Gamma^*}\Gamma^{\leq r} = \bigcup_{i=1}^r\Gamma^i\Gammarr(p,a_1\ldots a_n)(p,b_1\ldots b_j)\Delta\{(p_1,w_1),\ldots,(p_m,w_m)\}n\geq ja_{n-j+1}\ldots a_n=b_1\ldots b_j(p,a_1\ldots a_n)\Rightarrow_\CABPDS\{(p_1,a_1\ldots a_{n-j} w_1),\ldots,\linebreak(p_m,a_1\ldots a_{n-j} w_m)\}1\ABPDS(\CABPDS)\CABPDSc\in L(\CABPDS)c\in L(\ABPDS(\CABPDS))c\in P\times\Gamma^*r\CABPDSr\ABPDS(\CABPDS)=(P',\Gamma,\Delta',F)P'=P\cup P\times \Gamma^{\leq r} \times \Gamma^{\leq r-1}P(p,w,v)wv\Delta'\subseteq P'\times\Gamma\times\powerset{P'\times\Gamma^*}p \in P, a \in \Gamma, w,v \in \Gamma^+X\subseteq P\times\Gamma^*(p,a)\Delta X(p,a)\Delta' X(p,wa)\Delta X(p,a)\Delta'((p,wa,w),\epsilon)((p,vaw,va),a)\Delta' ((p,vaw,v),\epsilon)(p,vaw)\Delta X((p,aw,a),a)\Delta'X(p,aw)\Delta X\CABPDS\ABPDS(\CABPDS)\CABPDS\ABPDS(\CABPDS)a(p,wa,w)wawa\epsilonava(p,vaw)\Delta{}Xa(p,aw)\Delta{}Xr\CABPDS=(P,\Gamma,\Delta,F,r)c\in L(\CABPDS)c\in L(\ABPDS(\CABPDS))c\in P\times\Gamma^*f\rho \in \Runs_\CABPDS\Runs_{\ABPDS(\CABPDS)}\rho = (p,w)(\rho_1,\ldots,\rho_n)c(\rho_1,\ldots,\rho_n)cn\rho_1,\ldots,\rho_nc(p_i,w_i)\rho_i(p,w) \Rightarrow_\CABPDS \{(p_i,w_i)\mid 1 \leq i \leq n\}f\rho(p,w) \Rightarrow_\CABPDS \{(p_i,w_i)\mid 1 \leq i \leq n\}(p,a) \Delta\{(p_i,w_i')\mid 1 \leq i \leq n\}a\in \Gammaf(\rho) = (p,w)(f(\rho_1),\ldots,f(\rho_n))(p,w) \Rightarrow_\CABPDS \{(p_i,w_i)\mid 1 \leq i \leq n\}(p,a_1\ldots a_m) \Delta\{(p_i,w_i')\mid 1 \leq i \leq n\}m > 1a_1,\ldots,a_m \in \Gammaw = w'a_1\ldots a_mf(\rho) = (p,w)(((p,a_1\ldots a_m,a_1\ldots,a_{m-1}),w'a_1\ldots a_{m-1})(\ldots(((p,a_1\ldots a_m,\linebreak a_1),w'a_1)(f(\rho_1),\ldots,f(\rho_n)))\ldots))\kappa \in f(\rho)f^{-1}(\kappa)\rhof^{-1}((p,w)(p_i,w_i)\ldots) = (p,w)f^{-1}((p_i,w_i)\ldots)f^{-1}((p,w)((p,a_1\ldots a_m,a_1\ldots a_{m-1}),w'a_1\ldots a_{m-1})\ldots((p,a_1\ldots a_m,a_1),w'\linebreak a_1)(p_i,w_i)\ldots) = 
(p,w)f^{-1}((p_i,w_i)\ldots)f^{-1}(\kappa)\kappa(\Rightarrow):c \in L(\CABPDS)\rho \in \Runs_\CABPDS(c)f(\rho)\in \Runs_{\ABPDS(\CABPDS)}(c)\kappa \in f(\rho)f^{-1}(\kappa)F\kappa\kappaf(\rho)c \in L(\ABPDS(\CABPDS))(\Leftarrow):f^{-1}\rho \in \Runs_{\ABPDS(\CABPDS)}(c)\Runs_\CABPDS(c)L(\CABPDS)=L(\ABPDS(\CABPDS))L(\ABPDS(\CABPDS))P \times \Gamma^*L(\CABPDS)r\CABPDS=(P,\Gamma,\Delta,F,r)\lab : \Pi \to 2^{P\times\Gamma^*}\varphi\Propsa \in \Pi^+(\phi)\lab(a)\AAut_\prop{p} = (S_\prop{p},\Gamma,\delta_\prop{p}, I_\prop{p},F_\prop{p})\prop{p} \in \Pi^-(\phi)P \times \Gamma^* \setminus \lab(\prop{p})\AAut_{\neg \prop{p}} = (S_{\neg \prop{p}},\Gamma,\delta_{\neg \prop{p}}, I_{\neg \prop{p}},F_{\neg \prop{p}})r\CABPDS_{\phi}=(P',\Gamma,\Delta',F',r)P' = (P \times \cl(\phi)) \cup 
            \bigcup_{\prop{p} \in \Pi^+(\phi)} S_{\prop{p}} \cup 
			\bigcup_{{\prop{p}} \in \Pi^-(\phi)} S_{\neg \prop{p}}F' = (P \times \cl_\Release(\phi)) \cup \bigcup_{\prop{p} \in \Pi^+(\phi)} F_{ \prop{p}} \cup 
			\bigcup_{{\prop{p}} \in \Pi^-(\phi)} F_{\neg \prop{p}}\Delta'aw\CABPDS_{\phi}\ABPDS_\varphi\CABPDS,(p,w),\lab \models \psi((p,\psi),w) \in L(\CABPDS_{\phi})\psi \in \cl(\phi)(\Rightarrow):\CABPDS,(p,w),\lab \models \psi((p,\psi),w)\CABPDS_{\phi}\psi\psi = \prop{p}\CABPDS,(p,w),\lab \models \psi(p,w) \in \lab(\prop{p})\AAut_\prop{p}p_\prop{p} \stackrel{w}{\rightarrow}_{\AAut_\prop{p}}^* S'p_\prop{p} \in I_\prop{p}S' \subseteq F_\prop{p}\subseteq F'((p,\prop{p}),w) \Rightarrow_{\CABPDS_\phi} (p_\prop{p},w) \Rightarrow^*_{\CABPDS_\phi} \{ (s',\#) \mid s' \in S'\} \Rightarrow_{\CABPDS_\phi} 
\{ (s',\#) \mid s' \in S'\} \Rightarrow_{\CABPDS_\phi} \ldots\Runs_{\CABPDS_{\phi}}\psi = \psi_1\lor\psi_2\CABPDS,(p,w),\lab \models \psi_1\lor\psi_2\CABPDS,(p,w),\lab \models \psi_1\CABPDS,(p,w),\lab \models \psi_2\CABPDS,(p,w),\lab \models \psi_1((p,\psi_1),w)\in L(\CABPDS_\varphi)((p,\psi_1),w)\rho((p,\psi_1\lor\psi_2),w)((p,\psi_1\lor\psi_2),w)(\rho)((p,\psi_1\lor\psi_2),w)\in L(\CABPDS_\varphi)\psi = \psi_1\land\psi_2\CABPDS,(p,w),\lab \models \psi_1\land\psi_2\CABPDS,(p,w),\lab \models \psi_1\CABPDS,(p,w),\lab \linebreak \models \psi_2((p,\psi_1),w)\in L(\CABPDS_\varphi)((p,\psi_2),w)\in L(\CABPDS_\varphi)((p,\psi_1),w)\rho_1((p,\psi_2),w)\rho_2((p,\psi_1\land\psi_2),w)((p,\psi_1\land\psi_2),w)(\rho_1,\rho_2)((p,\psi_1\land\psi_2),w)\in L(\CABPDS_\varphi)\psi = \Epath\Next\psi_1\CABPDS,(p,w),\lab \models \psi(p,w)\rho = (p,w)(\rho_1,\ldots,\linebreak\rho_n)c(\rho_1,\ldots,\rho_n)cn\rho_1,\ldots,\rho_n(p_i,w_i)\rho_i\CABPDS,(p_i,w_i),\lab \models \psi_11 \leq i \leq n((p_i,\psi_1),w_i) \in L(\CABPDS_{\phi})((p_i,\psi_1),w_i)\rho_i'((p,\Epath\Next\psi_1),w)((p,\Epath\Next\psi_1),w)(\rho_1',\linebreak\ldots,\rho_n')((p,\Epath\Next\psi_1),w)\in L(\CABPDS_\varphi)\psi = \Epath\psi_1\NUntil\psi_2\CABPDS,(p,w),\lab \models \psi(p,w)\rho\kappa = (p^\kappa_0,w^\kappa_0) (p^\kappa_1,w^\kappa_1) \ldots \in \rho \in \Runs_\CABPDS((p,w))\exists i_\kappa \geq 0\CABPDS,(p^\kappa_{i_\kappa},w^\kappa_{i_\kappa}),\lab \models \psi_2\forall 0 \leq j < i_\kappa\CABPDS,(p^\kappa_j,w^\kappa_j),\lab \models \psi_1((p^\kappa_{i_\kappa},\psi_2),w^\kappa_{i_\kappa}) \in L(\CABPDS_{\phi})((p^\kappa_j,\psi_1),w^\kappa_j) \in L(\CABPDS_{\phi})0 \leq j < i_\kappa((p^\kappa_i,\psi),w^\kappa_i) \in L(\CABPDS_\phi)\kappa\in\rho0 \leq i \leq i_\kappai_\kappa-ii=0((p,\psi),w) \in L(\CABPDS_\phi)i = i_\kappa((p^\kappa_{i_\kappa}),\psi),w^\kappa_{i_\kappa}) \Rightarrow_{\CABPDS_\phi} ((p^\kappa_{i_\kappa},\psi_2),w^\kappa_{i_\kappa})((p^\kappa_{i_\kappa},\psi_2),w^\kappa_{i_\kappa}) \in L(\CABPDS_{\phi})((p^\kappa_{i_\kappa}),\psi),w^\kappa_{i_\kappa})\in L(\CABPDS_{\phi})((p^\kappa_i,\psi),w^\kappa_i) \in L(\CABPDS_\phi)\kappa\in\rho0 < i \leq i_\kappa\kappa\in\rho((p^\kappa_{i-1},\psi),w^\kappa_{i-1})(p^\kappa_{i-1},w^\kappa_{i-1}) \Delta XX = \{ (p^{\kappa'}_{i},w^{\kappa'}_{i}) \mid \kappa' \in \rho, 
(p^{\kappa'}_{i-1},w^{\kappa'}_{i-1})=(p^\kappa_{i-1},w^\kappa_{i-1}) \}(p^\kappa_{i-1},w^\kappa_{i-1})\rho((p^{\kappa'}_{i},\psi),w^{\kappa'}_{i}) \in L(\CABPDS_\phi)\kappa' \in \rho(p^{\kappa'}_{i-1},w^{\kappa'}_{i-1})=(p^\kappa_{i-1},w^\kappa_{i-1})((p',\psi),w') \in L(\CABPDS_\phi)(p',w') \in X((p^\kappa_{i-1},\psi),w^\kappa_{i-1}) \Rightarrow_{\CABPDS_\varphi}
\{ ((p^\kappa_{i-1},\psi_1),w^\kappa_{i-1}) \}
\cup 
\{ ((p',\psi),w') \mid (p',w') \in X \}((p^\kappa_{i-1},\psi_1),w^\kappa_{i-1}) \in L(\CABPDS_\phi)((p^\kappa_{i-1},\psi),w^\kappa_{i-1}) \in L(\CABPDS_\phi)\psi(\Rightarrow):((p,\psi),w) \in L(\CABPDS_{\phi})\CABPDS,(p,w),\lab \models \psi\psi\psi = \prop{p}((p,\prop{p}),w) \in L(\CABPDS_{\phi})(p,\prop{p}),w)\rho\rho((p,\prop{p}),w) \Rightarrow_{\CABPDS_\varphi} (p_\prop{p},w) \Rightarrow_{\CABPDS_\varphi}^* (f,\#)f \in F_\prop{p}\AAut_\prop{p}p_\prop{p} \stackrel{w}{\rightarrow}^*_{\AAut_\prop{p}} f(p,w) \in L(\AAut_\prop{p}) = \lab(\prop{p})\CABPDS,(p,w),\lab \models \prop{p}\psi = \psi_1\lor\psi_2((p,\psi_1\lor\psi_2),w) \in L(\CABPDS_{\phi})((p,\psi_1\lor\psi_2),w)\rho\rho((p,\psi_1\lor\psi_2),w)(\rho')\rho'((p,\psi_1),w)((p,\psi_2),w)((p,\psi_1),w)\rho'\rho'((p,\psi_1),w) \in L(\CABPDS_{\phi})\CABPDS,(p,w),\lab \models \psi_1\CABPDS,(p,w),\lab \models \psi_1 \lor \psi_2\psi = \psi_1\land\psi_2((p,\psi_1\land\psi_2),w) \in L(\CABPDS_{\phi})((p,\psi_1\land\psi_2),w)\rho\rho((p,\psi_1\land\psi_2),w)(\rho_1,\rho_2)\rho_i((p,\psi_i),w)\rho_1\rho_2((p,\psi_1),w) \in L(\CABPDS_{\phi})((p,\psi_2),w) \in L(\CABPDS_{\phi})\CABPDS,(p,w),\lab \models \psi_1\CABPDS,(p,w),\lab \models \psi_2\CABPDS,(p,w),\lab \models \psi_1 \land \psi_2\psi = \Epath\Next\psi_1((p,\Epath\Next\psi_1),w) \in L(\CABPDS_{\phi})((p,\Epath\Next\psi_1),\linebreak w)\rho\rho((p,\Epath\Next\psi_1),w)(\rho_1,\ldots,\rho_n)(p,a_1\ldots a_m) \Delta \{(p_1,w_1),\ldots,(p_n,w_n)\}w=w'a_1\ldots a_m\rho_i((p_i,\psi_1),w'w_i')1\leq i \leq n\rho_i((p_i,\psi_1),w'w_i') \in L(\CABPDS_{\phi})\CABPDS,(p_i,w'w_i'),\lab \models \psi_1\CABPDS,(p,w),\lab \models \Epath\Next\psi_1\psi = \Epath\psi_1\NUntil\psi_2((p,\Epath\psi_1\NUntil\psi_2),w) \in L(\CABPDS_{\phi})((p,\Epath\psi_1\NUntil\psi_2),w)\rho\rhog(\rho)\CABPDS\rhog(((p,\Epath\psi_1\NUntil\psi_2),w)(\rho')) = (p,w)\rho'\rhog(((p,\Epath\psi_1\NUntil\psi_2),w)(\rho',\rho_1,\ldots,\rho_n)) = (p,w)(g(\rho_1),\ldots,g(\rho_n))((p,\linebreak\Epath\psi_1\NUntil\psi_2),w)\Rightarrow_{\CABPDS_\varphi} \{((p,\psi_1),w)\} \cup 
\{((p,\Epath\psi_1\NUntil\psi_2),w') \mid (p',w') \in X\}(p,w)\Rightarrow_\CABPDS X\kappa = (p_0,w_0)\ldots(p_m,w_m) \in g(\rho)m \geq 0p_0 = pw_0=w\rho((p_0,\Epath\psi_1\NUntil\psi_2),w_0)\linebreak\ldots((p_m,\Epath\psi_1\NUntil\psi_2),w_m)((p_m,\psi_2),w_m)m \geq 0i < m((p_i,\psi_1),w_i)((p_i,\Epath\psi_1\NUntil\psi_2),w_i)i < m((p_i,\psi_1),\linebreak w_i) \in L(\CABPDS_{\phi})((p_m,\psi_2),w_m) \in L(\CABPDS_{\phi})\CABPDS,(p_i,w_i\linebreak),\lab \models \psi_1i < m\CABPDS,(p_m,w_m),\lab \models \psi_2\CABPDS,(p,w),\lab \models \Epath\psi_1\NUntil \psi_2\psi\lab\varphi\AAut_{\CABPDS,\varphi}c=(p,w)\in\Cnf_\CABPDS\CABPDS,c,\lab\models\varphi((p,\varphi),w)\in L(\AAut_{\CABPDS,\varphi})\varphi(p,w)\lab\CABPDS_\varphi(\star)\CABPDS,(p,w)\models\varphi((p,\varphi),w)\in L(\CABPDS_\varphi)(\star)((p,\varphi),w)\in L(\ABPDS(\CABPDS_\varphi))\ABPDS(\CABPDS_\varphi)\ABPDS(\CABPDS_\varphi)\AAut(\star)((p,\varphi),w)\in L(\AAut)kk\geq 2k{\rbmi}sk\geq 21\model =
(\Agt,Q,\Pi,\pi,\Act,d,o,\short{\Resources},\full{\mathfrak{R},}t)1\mathfrak{R}A\bar{A}=\Agt\backslash A\eta\eta(r)\consumption(\alpha)\consumption(\alpha,r)\vec{\alpha}_A\consumption(\vec{\alpha}_A)\production(\vec{\alpha}_A)\sum_{a\in A}\consumption(\alpha_a)\sum_{a\in A}\production(\alpha_a)x\encone{x}||\ldots|x\encone{x}x\encone{0}=\epsilon\encten{y}y=\encone{x}xq\model\vec{\alpha}_AA\vec{\alpha}_{\bar{A}}\bar{A}\mn_{\bar A}(q) = \max\{\consumption(\vec{\alpha}_{\bar{A}}) \mid  \vec{\alpha}_{\bar{A}} \in d_{\bar A}(q)\}\con_A(q,\vec{\alpha}_A) = \consumption(\vec{\alpha}_A)+\mn_{\bar A}(q)\prd_A(q,\vec{\alpha}_A,\vec{\alpha}_{\bar{A}}) = \mn_{\bar A}(q)-\consumption(\vec{\alpha}_{\bar{A}})+\production((\vec{\alpha}_A,\vec{\alpha}_{\bar{A}}))\mn_{\bar A}(q)q\con_A(q,\vec{\alpha}_A)A\vec{\alpha}_A\prd_A(q,\vec{\alpha}_A,\vec{\alpha}_{\bar{A}})(\vec{\alpha}_A,\vec{\alpha}_{\bar{A}})q(\vec{\alpha}_A,\vec{\alpha}_{\bar{A}})\bar{A}\vec{\alpha}=(\vec{\alpha}_A,\vec{\alpha}_{\bar{A}})\vec{\alpha}_AA\vec{\alpha}_{\bar{A}}\bar{A}q\model\production(\vec{\alpha})-\consumption(\vec{\alpha})=\prd_A(q,\vec{\alpha}_A,\vec{\alpha}_{\bar{A}})-\con_A(q,\vec{\alpha}_A)x\vec{\alpha}'\in \Act_{\bar{A}}x \geq \sum_{a \in \bar{A}}\consumption(\alpha'_a)+\sum_{a \in A}\consumption(\alpha_a)x\geq  \con_A(q,\vec{\alpha}_A)\prd_A(q,\vec{\alpha}_A,\vec{\alpha}_{\bar{A}})-\con_A(q,\vec{\alpha}_A) = 
     \mn_{\bar A}(q)-\consumption(\vec{\alpha}_{\bar{A}})+\production((\vec{\alpha}_A,\linebreak\vec{\alpha}_{\bar{A}})) - 
     (\consumption(\vec{\alpha}_A)+\mn_{\bar A}(q)) = 
      \production((\vec{\alpha}_A,\vec{\alpha}_{\bar{A}})) - (\consumption(\vec{\alpha}_A)+\consumption(\vec{\alpha}_{\bar{A}}))=
      \production(\vec{\alpha})-\consumption(\vec{\alpha})\sum_{a \in \bar{A}}\consumption(\alpha'_a)+\sum_{a \in A}\consumption(\alpha_a) \leq x\vec{\alpha}'\in \Act_{\bar{A}}\consumption(\vec{\alpha}_A)+\mn_{\bar A}(q)\linebreak \leq x\con_A(q,\vec{\alpha}_A) \leq x\modelArr=\encone{\max_{q,\vec{\alpha}_A,\vec{\alpha}_{\bar{A}}}\{\linebreak\con_A(q,\vec{\alpha}_A), \prd_A(q,\vec{\alpha}_A,\vec{\alpha}_{\bar{A}})\}}\CABPDS_{\model,A}r\CABPDS_{\model,A}(S,\Gamma,\Delta,F,r)S=F=Q\Gamma=\{|\}q \in Q\vec{\alpha}_A \in d_A(q)}(q,\encone{\con_A(q,\vec{\alpha}_A)})\Delta\{(o(q,(\vec{\alpha}_A,\vec{\alpha}_{\bar{A}})),\encone{\prd_A(q,\vec{\alpha}_A,\vec{\alpha}_{\bar{A}})}) \mid \vec{\alpha}_{\bar{A}} \in d_{\bar A}(q)\}.\full{}\short{\CABPDS_{\model,A}r\CABPDS_{\model,A}out(q,s_A,\eta)qs_Aw\in\{|\}^*\rho\in\Runs_{\CABPDS_{\model,A}}h(w)=\encten{w}hh((p,w))=(p,h(w))c_0c_1\ldotsh(c_0c_1\ldots)=h(c_0)h(c_1)\ldotsh(\rho)=\{h(\kappa)\mid\kappa\in\rho\}\CABPDS_{\model,A}As_A\rho\in\Runs_{\CABPDS_{\model,A}}h(\rho)=out(q,s_A,\eta)\vec{\alpha}_Abs_As_A(h(b))=\vec{\alpha}_Ah:\Runs_{\CABPDS_{\model,A}}\rightarrow \{out(q,s_A,\eta)\mid (q,\eta)\in Q\times\Enments \linebreak\text{ and  is a strategy of }\}s_At=out(q,s_A,\eta)(q,s_A,\eta)\rho\in\Runs_{\CABPDS_{\model,A}}((q,\encone{\eta}))h(\rho)=tt^i\rho^it\rhoi\geq 0\rhoh(\rho^0)=h(t^0)b^it^i(q',\eta')\{(q_1,\eta_1),\ldots,(q_n,\eta_n)\}\vec{\alpha}_{\bar{A}}^j(q_j,\eta_j)s_A(t^i)=\vec{\alpha}_Ao(q',(\vec{\alpha}_A,\vec{\alpha}^j_{\bar{A}}))=q_j1\leq j\leq n(q',\encone{\con_A(q',\vec{\alpha}_A)})\Delta\{(q_j,\encone{\prd_A(q',\vec{\alpha}_A,\vec{\alpha}_{\bar{A}})}) \mid \vec{\alpha}_{\bar{A}} \in 1\leq  j\leq n\}\kappa^i\rho^ib^ih(\kappa^i)=b^i\kappa^ic'=(q',\encone{\eta'})b^i\eta'\geq \con_A(q',\vec{\alpha}_A)\{(q_1,\encone{\eta_1}),\ldots,(q_n,\encone{\eta_n})\}c'\rho\in\Runs_{\CABPDS_{\model,A}}(c)\kappa^i=(q_0,w_0)\ldots(q_n,w_n)\rho(q_n,\encone{\con_A(q_n,\vec{\alpha}_A)})\Delta\{(o(q_n,(\vec{\alpha}_A,\vec{\alpha}_{\bar{A}})),\encone{\prd_A(q_n,\vec{\alpha}_A,\vec{\alpha}_{\bar{A}})}) \mid \vec{\alpha}_{\bar{A}} \in d_{\bar A}(q)\}s_A(h(\kappa^i))=\vec{\alpha}_As_A\rhobb'1\pi : \Pi \to 2^{Q\times\Enments}\ral1\pi : \Pi \to 2^{Q\times\Enments}\pi':\Props\rightarrow \powerset{Q}\model\pi(\prop{p})=\{(q,\enment)\mid \enment\in\Enments, q\in\pi'(\prop{p})\}\pi\model,q_0,\eta\models\coopdown{A}\phi\coopdown{A}\phi\Epath\varphi\CABPDS_{\model,A}A\lab(q,\encone{\eta})\in\lab(\prop{p})(q,\enment)\in\pi(\prop{p})\model,q_0,\eta\models\coopdown{A}\phi\CABPDS_{\model,A},(q,\encone{\enment}),\lab\models \Epath\varphi\AAut_{\CABPDS_{\model,A},\Epath\varphi}((q,\Epath\varphi),\encone{\eta})\model\coop{A}\varphi\ral\AAut_{\CABPDS_{\model,A},\Epath\varphi}((q,\Epath\varphi),\encone{\eta})\in L(\AAut_{\CABPDS_{\model,A},\Epath\varphi})\model,q,\eta\models\coopdown{A}\phi\ral\varphi\psi\varphi\psi\psi\prop{p}_{\psi}\model\prop{p}_{\psi}\psi1\model,q,\enment\models \coop{A}\Sometm\phi\xi=\coop{B}\chi\phi\AAut_{\CABPDS_{\model,B},\Epath\chi}((q',\Epath\chi),h(\enment'))\model,q',\eta'\models\xi\xi\phi\prop{p}_\xi\pi\pi(p_\xi)=L(\AAut'_{\CABPDS_{\model,B},\Epath\chi})\AAut'_{\CABPDS_{\model,B},\Epath\chi}L(\AAut'_{\CABPDS_{\model,B},\Epath\chi})=\{(q,\eta)\mid ((q,\Epath\chi),\encone{\eta})\in L(\AAut_{\CABPDS_{\model,B},\Epath\chi})\}\phi\model,q,\enment\models \coop{A}\Sometm\phi\coopdown{1}\mathbf{F}\prop{halt}\coopdown{1}(\neg\coopdown{1}\Next\prop{err})\NUntil\prop{halt}k{\rbmi}sk\geq 2\coopdown{1}(\neg\coopdown{1}\Next\prop{p})\NUntil\prop{q}\coopdown{1}\mathbf{F}\prop{p}$.
\end{enumerate}
\end{corollary}}


\vspace{-0.7cm}

\section{Conclusions}\label{sec:concl}
In this paper, we have introduced a variant of resource agent logic \ral~\cite{Bulling/Farwer:10a} with shared resources, which can be consumed and produced. We showed that the model checking problem is undecidable in the presence of at least two unbounded resource types. Our main technical result is a decidability proof of model checking \ral with one shared, unbounded resource type. Otherwise, we impose no restrictions, in particular nested cooperation modalities do not reset the resources available to agents. This property is sometimes called \emph{non-resource flatness}. In order to show decidability, we first
show how \CTL can be model-checked with respect to (compact) alternating B\"{u}chi pushdown systems extending results on model checking \CTL over pushdown and alternating pushdown systems~\cite{song2014efficient,bouajjani1997reachability}. A compact alternating B\"{u}chi pushdown system allows to read and to pop more than one symbol from its stack at a time. It is used for  encoding resource bounded models in order to apply the automata-based model checking algorithm.  

\textbf{Acknowledgement.} We would like to thank Natasha Alechina and Brian Logan for the many discussions on this topic and their valuable comments.


\bibliographystyle{plain}
\bibliography{prima,prima-bibs} \vspace{-0.5cm}




\end{document}
