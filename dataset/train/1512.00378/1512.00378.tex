\documentclass[11pt]{llncs}
\usepackage{llncsdoc}
\usepackage{etex}
\usepackage{amsmath,epsfig,amsfonts}
\usepackage{fullpage}
\usepackage{array}
\usepackage{listings}
\lstset{
  basicstyle=\ttfamily,
  mathescape
}

\usepackage{times}
\usepackage[ruled,vlined,linesnumbered]{algorithm2e}
\usepackage{qtree}
\usepackage{subfigure}
\usepackage{hyperref}


\usepackage{caption}

\usepackage[usenames,dvipsnames]{pstricks}
\usepackage{epsfig}
\usepackage{pst-grad} \usepackage{pst-plot} 

\usepackage{tikz}
\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
  \node[shape=circle,draw,inner sep=0.7pt] (char) {#1};}}


\newtheorem{observation}{Observation}\newtheorem{openproblem}{Open Problem}\newtheorem{fact}{Fact}
\newcommand{\qedsymb}{\hfill{\rule{2mm}{2mm}}}
\newenvironment{proofsketch}{\begin{trivlist}
\item[\hspace{\labelsep}{\noindent Proof Sketch: }]
}{\qedsymb\end{trivlist}}


\newcommand{\st}{:}


\newcommand{\remove}[1]{}

\DeclareMathOperator{\sus}{\mathit{SUS}}
\DeclareMathOperator{\lsus}{\mathit{LSUS}}
\DeclareMathOperator{\sa}{\mathit{SA}}
\DeclareMathOperator{\rank}{\mathit{RA}}
\DeclareMathOperator{\lcp}{\mathit{LCP}}
\DeclareMathOperator{\sls}{\mathit{SLS}}
\DeclareMathOperator{\can}{\mathit{Candidate}}
\DeclareMathOperator{\lr}{\mathit{LR}}
\DeclareMathOperator{\llr}{\mathit{LLR}}
\DeclareMathOperator{\llrc}{\mathit{LLRc}}
\DeclareMathOperator{\llrs}{\mathit{LLRS}}
\DeclareMathOperator{\lrs}{\mathit{LRS}}
\DeclareMathOperator{\nil}{\mathit{NIL}}
\DeclareMathOperator{\seq}{\mathit{S}}
\DeclareMathOperator{\e}{E}
\DeclareMathOperator{\var}{Var}

\newcommand\pred{\mathtt{pred}}




\title{ 
An In-place Framework for Exact and Approximate\\Shortest Unique
  Substring Queries \thanks{Authors are listed in alphabetical order.
    A preliminary version of this paper appears in Proceedings of the
    26th International Symposium on Algorithms and Computation
    (ISAAC),  Nagoya, Japan, 2015.
}
}

\author{Wing-Kai Hon\inst{1} \and Sharma V.\ Thankachan\inst{2} \and
  Bojian Xu\inst{3}
\thanks{Corresponding author. Phone:
+1 (509) 359-2817. Fax: +1 (509) 359-2215.}  
}

\institute{Department of CS, National Tsing Hua University,
Taiwan
\and
School of CSE, Georgia Institute of Technology, 
USA
\and
Department of CS, Eastern Washington University, 
USA\\
\email{wkhon@cs.nthu.edu.tw, sthankac@cc.gatech.edu, bojianxu@ewu.edu}
}

\begin{document}
\maketitle
\begin{abstract}
  We revisit the exact shortest unique substring (SUS) finding
  problem,
and propose its approximate version where mismatches are allowed,
  due to its applications in subfields such as computational
  biology. We design a generic in-place framework that fits to solve
  both the exact and approximate -mismatch SUS finding, using the
  minimum  memory words plus  bytes space, where   is the input
  string size.
By using the in-place framework, we can find the exact and
  approximate -mismatch SUS for every string position using a total
  of  and  time, respectively, regardless of the value
  of .
Our framework does not involve any compressed or succinct data
  structures and thus is practical and easy to implement.
  \remove{ 
   Unlike prior work that used either suffix tree or suffix array
    augmented by longest common prefix array, our method uses suffix
    array only for the exact SUS finding and does not use any indexing
    structures for the approximate SUS finding, making our solution
    practical and easy to implement.
}
\end{abstract}


 




\begin{keywords}
string pattern matching, shortest unique substring,
in-place algorithms
 \end{keywords}


\section{Introduction}
\label{sec:intro}
We consider a {\bf string} , where
each character  is drawn from an
alphabet . 
We say the character  {\bf occupies} the string position .
A {\bf substring}  of  represents 
if , and is an empty string if .  
We call  the {\bf start position} and  the 
{\bf ending position} of .  
We say the substring  {\bf covers} the th
position of , if .  String  is a {\bf
  proper substring} of another string  if  and .
The {\bf length} of a non-empty substring , denoted as
, is . We define the length of an empty string
as zero. 

The {\bf Hamming distance} of two non-empty strings  and  of
equal length, denoted as , is defined as the number of string
positions where the characters differ.  A substring 
is {\bf -mismatch unique}, for some , if there does
not exist another substring , such that ,
, and .  A substring is a
{\bf -mismatch repeat} if it is not -mismatch unique.


\begin{definition}[-mismatch SUS]
\label{def:sus}
For a particular string position  in  and an integer , , the \emph{-mismatch shortest unique substring (SUS)
  covering position }, denoted as , is a -mismatch
unique substring , such that (1) , and (2) there
does not exist another -mismatch unique substring , such
that  and .
\end{definition}

We call -mismatch SUS as {\bf exact SUS},
and the case  as {\bf approximate SUS}.

For any  and ,  must exist, because at least the
string  can be , if none of its proper substrings is
.  On the other hand, there might be multiple choices for
.  For example, if ,  can be
either  or , and  can be
either  or .
Note that in Definition~\ref{def:sus}, we require , because
finding  is trivial:  for any string
position .



\bigskip  

\noindent
{\bf Problem (-mismatch SUS finding).}
Given the string , the value of , and two empty integer arrays
 and , we want to work in the place of , , and , such
that, in the end of computation: (1)  does not change. (2) Each
 pair saves the start and ending positions of the
rightmost\footnote{Since any SUS may have multiple choices, it is our
  arbitrary decision to resolve the ties by picking the rightmost
  choice. However, our solution can also be easily modified to find
  the leftmost choice.}  , i.e., 
,
 using a total of  time for
 and  time for any .


\subsection{Prior work and our contribution}
Exact SUS finding was proposed and studied recently by Pei et
al.~\cite{PWY-ICDE2013}, due to its application in locating snippets 
in document
search, event analysis, and bioinformatics, such as
finding the distinctness
between closely related organisms~\cite{HPMW-bio2005}, polymerase chain reaction
(PCR) primer design in molecular biology, genome
mapability~\cite{DEMKRGR-2012}, and next-generation short reads
sequencing~\cite{ABFMK-2015}.  The algorithm in~\cite{PWY-ICDE2013} can find all
exact SUS in  time using a suffix tree of  space.
Following their proposal, there has been a sequence of
improvements~\cite{TIBT2014,IKX-tcs2015}
for exact SUS finding, reducing the time cost from  to 
and alleviating the underlying data structure from suffix tree to
suffix array of  space. 
Hu et al.~\cite{HPT-spire2014} proposed an RMQ (range minimum query)
technique based indexing structure, which can be constructed in 
time and space, such that any future exact SUS covering any interval of
string positions can be answered in  time.
In this work, we make the following contributions: 
\begin{itemize}
\item 
We revisit the exact SUS finding problem and also
propose its approximate version where mismatches are allowed, which
significantly increases the difficulty as well as
the usage of SUS finding in subfields such as
bioinformatics, where approximate string matching is unavoidable due
to genetic mutation and errors in biological experiments.

\item 
We propose a generic in-place algorithmic framework that fits to solve
both the exact and approximate -mismatch SUS finding, using 
words plus  bytes space. It is worth mentioning that  words
plus  bytes is the minimum memory space needed to save those 
calculated SUSes: (1) It needs  words to save each SUS by saving
its start and ending positions (or one endpoint and its length) and
there are  SUSes. (2) It needs another  bytes to save the
original string  in order to output the actual content of any SUS
of interest from queries. Note that all prior
work~\cite{PWY-ICDE2013,TIBT2014,IKX-tcs2015,HPT-spire2014} use 
space but there is big leading constant hidden within the big-oh
notation (see the experimental study in~\cite{IKX-tcs2015}).

\item After the suffix array is constructed, all the computation in
  our solution happens in the place of two integer arrays, 
 using non-trivial techniques. It is worth noting that our solution
 does not 
  involve any compressed or succinct data structures, making our solution
  practical and easy to implement.  Our preliminary experimental study
  shows that our solution for exact SUS finding is even faster than
  the fastest one
  among~\cite{PWY-ICDE2013,TIBT2014,IKX-tcs2015}\footnote{Note
    that the work of~\cite{HPT-spire2014} studies a different problem and its
    computation is of the query-answer model, and thus is not
    comparable with~\cite{PWY-ICDE2013,TIBT2014,IKX-tcs2015} and
    ours.}, in addition to a lot more space saving than them, enabling
  our solution to handle larger data sets.  Due to page limit, we will
  deliver the details of our experimental study in the journal version
  of this paper.
\end{itemize}



\remove{

\begin{figure}[t]
  \centering

 \begin{tabular}{||l|l|l|l|l|l||}
\hline
          &  & \cite{PWY-ICDE2013} & \cite{TIBT2014} &
          \cite{IKX-tcs2015} & Ours\\
\hline
\hline
  English & & & & &\\
 Protein & & & & &\\
 DNA & & & & &\\
\hline
\end{tabular}
  figure on time here ...


  \caption{Time and space usage of different proposals for exact SUS
    finding over different strings, where  is the string size in
    MB.}
\label{fig:time-space}
\end{figure}

}

\section{Preparation}
\label{sec:prep}
A {\bf prefix} of  is a substring , . 
A {\bf proper prefix}  is a prefix of  where .
A {\bf suffix} of  is a substring
, denoted as , .  
  is a  {\bf proper suffix} of , if .



For two strings  and , we write  (and say  is {\bf
  equal} to ), if  and .  
We say  is lexicographically smaller than ,
denoted as , if (1)  is a proper prefix of , or (2)
, or (3) there exists an integer  such that
 for all  but .


The {\bf suffix array}  of the string  is a permutation
of , such that for any  and , , we have .  That is, 
is the start position of the th smallest suffix in the
lexicographic order.
The {\bf rank array}  is the inverse of the suffix
array, i.e.,  iff .
The {\bf -mismatch longest common prefix (LCP)} between two strings
 and , , denoted as , is the LCP
of  and  within
Hamming distance . For example, if  and ,
then: 
 is  and  = 1;
 is  and  and
.



\begin{definition}[-mismatch LSUS]
\label{def:lsus}
For a particular string position  in  and an integer , , the \emph{-mismatch left-bounded shortest unique
  substring (LSUS) starting at position }, denoted as ,
is a -mismatch unique substring , such that either 
or any proper prefix of  is not -mismatch unique.
\end{definition}

We call -mismatch LSUS as {\bf exact
  LSUS}, and the case  as {\bf approximate
  LSUS}.

Observe that for any ,  always exists, because
at least the whole string  can be . However, for any
 and ,  may not exist. For example, if
, none of  and  exists, for all
, . It follows that some string positions may not be
covered by any -mismatch LSUS. For example, for the same string
, positions  and  are not covered by any exact
or -mismatch LSUS. On the other hand, if any  does
exist, there must be only one choice for , because
 has its start position fixed on  and need to be as
short as possible.
Note that in Definition~\ref{def:lsus}, we require , because
finding  is trivial as  and 
does not exist for all .  



\begin{definition}[-mismatch SLS]
\label{def:sls}
For a particular string position  in  and an integer , , we use  to denote the \emph{shortest -mismatch LSUS 
covering position }.
\end{definition}

We call -mismatch SLS as {\bf exact
  SLS}, and the case  as {\bf approximate
  SLS}.

 may not exist, since position  may not be covered by any
-mismatch LSUS at all. For example, if , then none
of  and  exists, for all .  On the other
hand, if  exists, there might be multiple choices for
.  For example, if ,  can be
either  or , and 
can be any one of , , and
.
Note that in Definition~\ref{def:sls}, we require , because
finding  is trivial as  for all .





\begin{lemma}
\label{lem:exist}
For any  and : (1)  always exists. (2) If
 exists, then  exists, for all .
 (3) If  does not exist, then none of  exists,
for all  .
\end{lemma}

\begin{proof}
(1)  must exist, because at least the string  can be
 if every proper prefix of  is a -mismatch repeat. 
(2) If  exists, say , ,
then 
 exists for every , because at least  is
-mismatch unique.
(3) It is true, because otherwise we get a contradiction to the second
statement in the lemma. 
\remove{
If  does not exist, it means  is a
-mismatch repeat. It follows that
every suffix  of , , is
also a -mismatch repeat, i.e., none of 
 exists, for all .}
\qed
\end{proof}


\begin{lemma}
\label{lem:lsus2}
For any  and , , if
 exists. 
\end{lemma}


\begin{proof}
\remove{
  Since  exists, so does 
  (Lemma~\ref{lem:exist}).  
}
  Suppose the -mismatch substring 
  , for some . Then, 
   is also -mismatch unique. It follows immediately that, 
  .\qed
\remove{
First, the lemma is trivially correct if
  , because .  Next, we
  prove the lemma for the case where
  , using contradiction.  Let's say
  , .  Suppose , it means  for some ,
  . Because  is -mismatch unique, so is . Now we get a -mismatch unique
  substring , which is shorter than . However,
  we know , the shortest -mismatch
  unique substring starting at position , raising a
  contradiction. }
\end{proof}

\remove{
By Lemma~\ref{lem:exist}, we know that given the string  and the
integer , there exists a unique integer , , such
that  exists for all , and none of 
exists for all  (if ). Further, by Lemma~\ref{lem:lsus2},
we can observe that, of those existing
, , their
start positions strictly increase and their ending positions
monotonically increase.
}


\begin{lemma}
\label{lem:ext}
  For any  and ,  is either 
  or , for some ,
  . That is,  is either the shortest -mismatch
  LSUS that covers position , or a right extension (through
  position ) of a -mismatch LSUS. 
\end{lemma}



\begin{proof}
  We know  must exist, because at least the string  can
  be . Let's say , . 
  If  is neither
   nor a right extension of , it means
   is a proper prefix of  and thus is a
  -mismatch repeat, which is a contradiction to the fact that
   is -mismatch unique. Therefore,
   is either , or a right extension of 
   (clearly,  in this case).
  Further, if , it is obvious that
   must be the shortest
  -mismatch LSUS covering position , i.e., .
 \qed
\end{proof}

For example, let , then:
(1)  can be either  , 
or , which is a right
extension of .
(2) .
(3) , which is a right extension 
of .
(4) . 
(5) , which is a right extension 
of  . 

\bigskip 

The next lemma further says that if  is an
extension of an -mismatch LSUS,  can be quickly obtained
from .

\begin{lemma}
\label{lem:ext2}
  For any  and , if  and  , i.e.,  is a right extension
  (through position ) 
of
  , then the following must be true: (1) ; (2) the
  rightmost character of  is ; (3)
  , the substring 
   appended by the character .
\end{lemma}

\begin{proof}
  If  is a right extension (through position ) of a
  -mismatch LSUS, it is certain
  that , because , which always exists
  (Lemma~\ref{lem:exist}).

  Because  is a right extension (through position ) of a
  -mismatch LSUS, we have
   for some , and 
  for some .  We also know  is -mismatch unique, because
  the -mismatch unique substring  is a prefix of .
  Note that any substring starting from a position before  and
  covering position  is longer than the -mismatch unique substring
  , so  must be starting from a position
  between  and , inclusive.
Next, we show  actually must start at position .  

  The fact that  implies  for every ; otherwise,
  rather than , any one of these  whose size is
  smaller than  would be a better choice for . That
  means, any -mismatch unique substring starting from  has a length at least . However,  and  is -mismatch unique already and
  covers position  as well, so  is the only choice
  for . This also means  is indeed the
  substring  appended by the character .  \qed
\end{proof}






\section{The High-Level Picture}
\label{sec:highlevel}
In this section, we present an overview of our in-place framework for
finding both the exact and approximate SUS. The framework is composed
of three stages, where all computation happens in the place of three
arrays, , , and , each of size . Arrays  and  are of
integers, whereas array  always saves the
input string. 
The following table summarizes the roles of 
 and  at different stages by showing their content at the end of
each stage.


\begin{center}
    \begin{tabular}{||c|m{7.5cm}|m{6.5cm}||}
      \hline
      \ Stages \ & \hspace*{30mm}  & \hspace*{30mm} \\
      \hline\hline
      1 & Used as temporary workspace during stage 1, but the content
      is useless for stages  and . & Ending position of , if  exists; otherwise, {\tt NIL}.\\
      \hline
      2  & The largest , such that  is 
           an , if  exists;
      otherwise, {\tt NIL}.
      & Ending position of , if  exists; otherwise, {\tt NIL}. \\
      \hline
      3  & Start position of the rightmost  & Ending
      position of the rightmost \\
      \hline
   \end{tabular}
\end{center}




\noindent {\bf Stage 1} (Section~\ref{sec:lsus}). We take the array
 that saves the input string as input to compute  for
all , in the place of  and . At the end of the stage, each
 saves the ending position of , if  exists. Since each existing
 has its start position fixed at , at the end of
stage~1, each existing .
For those non-existing -mismatch LSUSes, we assign {\tt NIL} to the
corresponding  array elements. The time cost of this stage is
 for exact LSUS finding (), and is  for approximate
LSUS finding, for any .

\medskip 
\noindent {\bf Stage 2} (Section~\ref{sec:sls}). Given the array 
(i.e., the -mismatch LSUS array of ) from stage~1, we compute
the rightmost , the rightmost shortest LSUS covering
position , for all , in the place of  and . At the end of
stage 2, each  saves the largest , such that  is
an , i.e., the rightmost , if  exists; otherwise, we assign . Array  does not change during stage~2. The time cost of
this stage is , for any .

\medskip 
\noindent {\bf Stage 3} (Section~\ref{sec:sus}).  Given 
and  from stage~2,
we compute , for all , in the place of  and . At
the end of stage~3, each  pair saves the start and ending
positions of the rightmost , i.e., . The time cost of this stage is ,
for any .

\medskip 

Algorithms~\ref{algo:lsus-exact}, \ref{algo:lsus-approx}, 
\ref{algo:sls}, and~\ref{algo:sus} 
in the appendix give the pseudocode of the
in-place procedures that we will describe in 
Sections~\ref{sec:lsus-0}, \ref{sec:lsus-k},
\ref{sec:sls}, and~\ref{sec:sus}, respectively.


\section{Finding -mismatch LSUS}
\label{sec:lsus} 
The goal of this section is that, given the input string  and two
integer arrays  and , we want to work in the place of  and
, such that  saves the ending position of 
 for all existing ;
otherwise,  is assigned .
We take different approaches in finding 
the exact LSUS () and approximate LSUS (). 



\subsection{Finding exact LSUS ()}
\label{sec:lsus-0}

\begin{lemma}[Lemma 7.1 in~\cite{Nong-TIS2013}]
\label{lem:sa}
Given the string  of size , drawn from an alphabet of
size , we can construct the suffix array  of  in
 time, using  words plus  bytes, where the space of
 bytes saves , the space of  words saves , and the extra
space of  words is used as the workspace for the run of the
 construction algorithm.
\end{lemma}

Given the input string , we first use the -time suffix array
construction algorithm from~\cite{Nong-TIS2013} to create the  of
, where the array  is used to save the  and the array 
is used as the workspace. Note that  is always true,
because otherwise we will prune from the alphabet those characters
that do not appear in the string.
After  (saved in ) is constructed, we can easily spend
another  time to create the rank array  of  (saved in
):  (i.e., ), for all .
Next, we use and work in the place of   (i.e., ) and
 (i.e., ) to compute the ending position of each existing
 and save the result in , using another 
time. 

\begin{definition}
\label{def:hl}


That is,  (, resp.) is the length of the longest
common prefix of 
and its lexicographically preceding (succeeding, resp.)
suffix, if the preceding (succeeding, resp.) suffix exists. 
\end{definition}


\begin{fact}
\label{fact:lsus-length}
For every string position ,  : 

\end{fact}

First, observe that in the sequence of 's, if , then  must be true, because at least  can be the lexicographically preceding suffix of ,
and they share the leading  characters.  That means, when we compute
, we can skip over the comparisons of the first  pair
of characters between  and its lexicographically
preceding suffix. It follows that, given the  and  of  and using the
above observation, we can compute the sequence of 's in 
time. 
Using the similar observation, we can compute the sequence of 's in
 time, provided that  and its  and  are given.

Second, since we can compute the sequences of 's and 's in
parallel (i.e., compute the sequence of () pairs), we can use
Fact~\ref{fact:lsus-length} to compute the sequence of  in
 time.  Further, since  is used only for retrieving
the lexicographically preceding and succeeding suffixes of 
when we compute the pair (), we can save each computed
 (indeed, , the ending position of
) in the place of  (i.e., ).  In the case
, meaning  does not exist,we will
assign {\tt NIL} to  (i.e., ) for all 
(Lemma~\ref{lem:exist}). The overall time cost for computing the
sequence of  is thus , yielding the following lemma.

\begin{lemma}
\label{lem:lsus-exact}
  Given the character array  of size  that saves the input string, 
  and the integer arrays  and , each of size , we can work
  in the place of , , and , using  time, such that at
  the end of the computation,  does not change,  saves the
  ending of position of , if  exists (otherwise,
  ).
\end{lemma}



\subsection{Finding approximate LSUS ()}
\label{sec:lsus-k}

\begin{definition}
\label{def:llr}
For a particular string position  in  
and an integer , , 
\emph{the -mismatch left-bounded longest repeat (LLR)}
starting at position , denoted as , is a -mismatch
repeat , 
such that either  or  is
-mismatch unique.   
\end{definition}

\begin{fact}
\label{fact:llr}
(1) If , i.e., the ending position of  is
less than , then , the substring of
 appended by the character following .
(2) Otherwise,  does not exist. 
\end{fact}

Our high-level strategy for finding  for all  is as
follows.  We first find  for all . Then we use
Fact~\ref{fact:llr} to find each  from : If
 does not end on position , we will extend it 
for one more character on its right side and make the extension to be
; otherwise,  does not exist. Next, we 
explain how to find , for all . 

Clearly, , for all
i. The way we calculate  for all  is simply to let
every pair of two distinct suffixes to be compared with each other. In
order to do so, we work over  phases, named as 
through . On a particular phase
, we compare suffixes  and  for
all . Obviously, over these  phases,
every pair of distinct suffixes have been compared with each other
exactly once. 
Over these  phases, we simply record in , which is
initialized to be , the length of 
the longest -mismatch LCP that each suffix 
has seen when compared with any other suffixes. 
Next, we explain the details of a particular phase
.

On a particular phase , , we
compare suffixes  and  for all
. When we compare  and ,
we save in , which is initialized to be empty at the
beginning of each phase, the leftmost mismatched  positions in
. We will see later how to update  efficiently
over the progress of a particular phase and use it to update the 
array. 

We treat  as a circular array,
i.e.,  when , and  when . Let , which is initialized to be  at the beginning of each
phase, denote the number of mismatched positions being saved in
 so far in . We can describe the
work of phase , inductively, as follows.

\begin{enumerate}
\item We compare  and  by only comparing 
 and , since .
\begin{enumerate}
\item If :
Save  in any position in ;
.

\item 
;
.

\end{enumerate} 

\item 
  Suppose we have finished the comparison between the suffixes
   and , for some , .
  The leftmost  mismatched positions (if existing) between them
  have been saved in the circular array . Let 
  be the element that 
  is saving the first mismatched position (if existing) between the two
  suffixes. 

\item  Next, we compare the suffixes  and  by
  only comparing  and , since  and
   have been compared. Remind that 
  below is in its cyclic manner.

  \begin{enumerate}
  \item If : ;  Save 
    in  and overwrite the old content in  if
    there is; .

  \item If : 
    ;
    .
  \item Else:
    ;
    .
    Note that  is saving the th
    mismatched position between  and .
\end{enumerate}

\end{enumerate}


After the computation of all  is finished, using the above 
 phases, each  is saving .
Next,
we can use Fact~\ref{fact:llr} to convert each  to
 by simply checking each : If , i.e.,
 does not end on position , then we assigne , the ending position of ; otherwise, we assign
, meaning  does not exist.

\medskip 

The computation 
of all  takes
  phases and each phase clearly has no more
than  comparisons, giving a total of  time cost. 
The procedure of converting each  to  spends
another  time. Altogether, we get an -time in-place
procedure for finding approximate LSUS, for any .

\begin{lemma}
\label{lem:lsus-k}
  Given the character array  of  size  that saves the input string, 
  the integer arrays  and , each of size , and the value
  of integer , we can work
  in the place of , , and , using  time, such that at
  the end of the computation,  does not change,  saves the
  ending of position of ,
i.e., ,
 if  exists; otherwise,
  .
\end{lemma}




\section{Finding -mismatch SLS}
\label{sec:sls}
Now we are given the array , where each  saves the ending
position of  if  exists and {\tt NIL}
otherwise. In this section, we want to work in the place of  and
, such that in the end of computation:  saves , such that
 is the rightmost , if such  exists;
otherwise, .
That means, in the end of this section, the rightmost , if  exists; otherwise,
.

Recall that some -mismatch LSUS may not exist and some positions
may not be covered by any -mismatch LSUS (see the examples after
Definition~\ref{def:lsus}). Further, due to Lemmas~\ref{lem:exist}
and~\ref{lem:lsus2}, we know such positions that are not covered by any
-mismatch LSUS must comprise a continuous chunk on the right end of
string .

\begin{definition}
\label{def:rz}
Let , , be the rightmost existing
-mismatch LSUS of the input string .
Let , , be the rightmost string position that is
covered by any -mismatch LSUS  of the string .
\end{definition}


Again, due to Lemmas~\ref{lem:exist} and~\ref{lem:lsus2}, it is trivial
to find the values of  and  in  time: scan array  (i.e.
LSUS array) from right to left, and stop when seeing the first
non-NIL  array element, which is exactly , then .
If , we can then simply set 
for all . Recall that 
already for all  from stage~1. In the rest of this section, we 
only need to work with the two subarrays  and , 
wanting to make  to be the start position of the rightmost
, for all .




Let  and an integer , , be the input, where
(1)~ is of monotonically nondecreasing integers
(Lemma~\ref{lem:lsus2}), with , (2)~ are
all {\tt NIL}, if , and (3)~.

We can use each , , as a compact representation of the
interval . Let , and  be the length of . Let
 be an output array such that , where  is the
rightmost shortest interval in  that covers .

\medskip

To illustrate the ideas and
concepts that we will present in the rest of this section, 
let us use the following as a running example, 
where , , and 
(we add
 as a sentinel).

{\small
\begin{center}

\end{center}
}

\remove{
\begin{center}

\end{center}
}

\begin{definition}
For an interval , we define the \emph{effective covering region} 
with respect to the previous intervals 
 to be  where 

We call  the starting point of the effective covering region of .
\end{definition}
The effective covering region of  is exactly those regions that
would set  as the answer, provided that all the intervals  before  are present, and all the intervals  are absent.

\medskip

\noindent
We next define  as a list\footnote{In actual run,
   saves the largest number in that list, as we will see
  more clearly later.}, such that  if and only if . Observe that since  by
definition, any value  in  must have , and the
effective region of  must cover .

\begin{lemma}
\label{lem:b}
For :

\end{lemma}
\begin{proof}
  Let  This means that for the
  effective region of any , with , none of them covers
  .  Next, observe that  must cover ; otherwise, for all
  the intervals  with , we have , so
  that none of them can cover , and thus a contradiction occurs.
Finally, we show that for those ,  can be
    pruned by , thus implying that  is a correct
    answer.

\medskip

\noindent
Consider all those  with :  
\begin{enumerate}
\item If  is longer than ,  can be pruned away
  directly.

\item Else, if  and  have equal length,  can be pruned
  away also, regardless of its coverage on ,
since we pick the rightmost shortest interval that covers
  .

\item Else,  must appear in . By the
  definition of , we have ; thus,  does
  not cover , and can be pruned away.
\end{enumerate}
\remove{
\begin{enumerate}
\item If  is no shorter than ,  can be pruned away
  directly.

\item Else, if  appears in , by the
  definition of , we have ; thus.  does
  not cover , and can be pruned away.

\item Else,  does not appear in .  Then,
  we have , so that the effective region of  does not
  cover ; so  can be pruned away.
\end{enumerate}
}
Thus, the first equality in the lemma follows, while the second
equality in the lemma is trivial once we have the first equality. 
\qed 
\end{proof}

\begin{lemma}
Suppose that all , , can be 
generated incrementally in  time.  
Then, we can obtain all , , 
in  time.
\end{lemma}

\begin{proof}
  We examine each , , and write 
  at entry  of
  the  array; if such an entry contains a value  already,
  we simply overwrite  with the latter . \qed
\end{proof}

\noindent
Indeed, we may scan  from right to left, i.e., , and update  as we proceed. Firstly, if ,
we set . Else, let  (whose value
is at least ), and we check if  is defined: If not,
simply set ; otherwise, no update is needed.

\smallskip

\noindent
The advantage of the `right-to-left' approach is that we can construct
 in-place, by re-using the memory space of .  To see
why it is so, by the time we need to update a certain entry 
at step , the information  has been used (and will never be
used), so that we can safely overwrite the original entry, storing
, to store  instead.  This gives the following
corollary.

\begin{corollary}
\label{cor:t}
  Suppose that all 's are generated, and are stored in a certain array
  . Then, we can obtain  for all 's,
  in-place,
  by storing the results in the same array ; the time cost is
  .
\end{corollary}
 

\noindent
Our goal is to make our algorithm in-place. Suppose that we can have
in-place incremental generation of . Then, by the above lemma, we
may store  temporarily at ; afterwards, by the
second equality of Lemma~\ref{lem:b}, we can compute the correct
output  by a simple scan of  from left to right.

Thus, to make the whole process in-place, it remains to show how 
can be computed in  time, in-place.  For this, we define
 to be the largest  (if it exists) such that  and
length of  is shorter than .  It is easy to check that if
 is defined, then 
(and  otherwise).\footnote{For each , if  covers ,  would also cover
  ; in such a case, .  For each ,  is longer than .}  Moreover,
 for all 's can be computed incrementally, with a way
analogous to the construction of the failure function in KMP
algorithm: we check  and so on, until we obtain  in the
process such that  is shorter than , and set .\footnote{Intuitively,  defines the shortcuts so that we can
  skip some intervals in  to compute .} If such  does
not exist, we set . The running time
is bounded by .

\bigskip

\noindent
This gives the following -time in-place algorithm (where  is read-only):
\begin{enumerate}
  \setlength{\itemsep}{0pt} \item Compute ,
  , and store this in .
  Note that this step requires the length information of the intervals
  of , which can be obtained in  time, on the fly, from
   .
\item Scan  (i.e., ) incrementally,
  and obtain  from
  the above discussion.  The value of  is stored in .  Note
  that this step requires the access to the original .
\item Scan  (i.e., ) from right to left, and obtain
   decrementally (stored in ) by
  Corollary~\ref{cor:t}. 
\item Scan  (i.e., )
  incrementally (), and obtain the
  desired  by the second equality in Lemma~\ref{lem:b}.
\end{enumerate}


\begin{lemma}
\label{lem:sls}

Given the integer array  and , each of size , 
where each  saves the ending
position of , if  exists and {\tt NIL}
otherwise, we can work in the place of
array  and , using  time, such that, 
in the end of computation,
array  does not change, and  saves , where
 is the rightmost , 
if such  exists; otherwise, .
That is, 
, if  exists;
otherwise, .
\end{lemma}




\section{Finding -mismatch SUS}
\label{sec:sus}
Now we have array , where , such that  is the
rightmost , if position  is covered by any
-mismatch LSUS; otherwise, . Note that 
is recording the start position of the rightmost  already,
because  starts on position .  We also have array ,
where , the ending position of , if
 exists; otherwise, .

\remove{
Recall that it is possible that some positions may not be covered by
any -mismatch LSUS (see the example after
Definition~\ref{def:lsus}). Due to Lemma~\ref{lem:exist}
and~\ref{lem:lsus2}, we know such positions must comprise a continuous
chunk on the right end of string . Let , , denote
the rightmost position that is covered by at least one -mismatch
LSUS, i.e.,  is the rightmost non-NIL element in array
. Again, due to Lemma~\ref{lem:exist} and~\ref{lem:lsus2}, it is
trivial to find the value of  in  time: scan
array  from right toward left, and stop when meeting the first
non-NIL  array element, say , then .
}


\paragraph{Step I.} We want to transform  and , such that each
 pair saves the start and ending positions of ,
if  exists; otherwise, we set .  Since each  is already recording the start
position of  already, as we have explained at the beginning
of this section, we only need to make changes to array .  We first
set  for all  (Definition~\ref{def:rz}). Then, we
scan array  from right to left, starting from position  through
, and set each , the ending position of the
rightmost . Because the leftmost position that any existing
 can cover is position , we know  and we no
longer need  (i.e., the information of ) after
 is computed. Therefore, it is safe to record  by
overwriting  by  (i.e., the ending position of
), in this right-to-left scan.


\paragraph{Step II.} 
We use arrays  and  to calculate  for each 
and save the result in the place of  and , i.e., each
 pair saves the start and ending position of .
Because of Lemma~\ref{lem:ext} and \ref{lem:ext2}, we can use arrays
 and  to compute each  inductively, as follows: 
\begin{enumerate}
\item 
. 
\item 
For , we compute : 
\begin{enumerate}
\item 
If , meaning 
does not exist, we set  to be  appended by the
character , i.e., , and save 

by setting ; 
\item Else, if  ends at position  and 
 is shorter 
than , 
we set ; 
\item Else,  and thus we leave 
  and  unchanged.
\end{enumerate}
\end{enumerate}



\begin{lemma}
\label{lem:sus}  
Given arrays  and :
\begin{itemize}
\item 
, such that  is the
rightmost , if  exists; 
otherwise, ; 
\item , the ending position of , if
 exists; otherwise, . 
\end{itemize}
we can work in the place of  and , using  time, 
such that, in the end of
computation, each  saves the start and ending
positions of , i.e., 
, .  
\end{lemma}

\noindent
By concatenating the claims in Lemmas~\ref{lem:lsus-exact},
\ref{lem:lsus-k}, \ref{lem:sls}, and \ref{lem:sus}, we get the
final result.

\begin{theorem} 
\label{thm:sus} 
Given the array  of size  that
  saves the input string, two empty integer arrays  and , each
  of size , and the value of integer , we can work in the
  place of arrays , , and , using a total of  time for
   and  time for any , such that in the end of
  computation,  does not change, each  pair
  represents the start and ending positions of the rightmost
  , i.e., . 
\end{theorem}



\remove{

\section{Extension: finding all SUSes for every position}
The current solution for both exact and mismatched SUS finding only
find one candidate for each . Can we find all candidates for
each  ? Of course, doing so will need more than  words. 




\section{Extension: finding  SUS covering chunk of position with k-mm}

The exact SUS version covering chunk of positions 
has been studied by HU et al in SPIRE 2014. The
solution to the
mm version can be the following. 

Compute all the existing LSUS's and RSUS's (right-bounded shortest
unique substring). We have no more than  intervals here. Delete
all duplicated intervals if there are. Given any chunk of positions,
its SUS is the shortest interval (or the extension of some interval)
that cover the chunk of positions. The exact-SUS problem can eventually be reduced to
range-minimum-query problem. I somehow believe this is also possible
for the mm version. It shouldn't take much time to think through it if we
want to add this extension, which of course won't be in the  words   Bytes
framework though. 

}

\section{Conclusion}
In this paper, we revisited the exact SUS finding problem, and
proposed its approximate version where mismatches are allowed, and
thus significantly extended the usage of SUS finding in subfields such
as computational biology. We designed a generic in-place algorithmic
framework that uses the minimum  words plus  bytes space and
can fit to find both exact and approximate -mismatch SUS, with
 and  time complexities, respectively, regardless of the
value of any . 
An urgent future work will be researching for a faster (and still
practical) in-place algorithm for finding approximate LSUS to replace
the current algorithm discussed in Section~\ref{sec:lsus-k}.  Such new
algorithm will lead to an overall faster in-place solution for
approximate SUS finding.



\small
\bibliographystyle{splncs03}
\bibliography{bibjsv,repeat,pm}



\newpage

\appendix

\section*{Appendix}


\begin{algorithm}[h!]
 \caption{Finding exact LSUS}
\label{algo:lsus-exact}
\KwIn{String  and integer arrays  and , each of size .} 
\KwOut{ does not change.  = ending position of
  , if  exists; otherwise, .}

\bigskip 

Create the  of  using the suffix array construction algorithm
from~\cite{Nong-TIS2013}, where array  is used to save the
resulting  and  is used as the workspace for the run of the
algorithm. 

\medskip 

\tcc{Create the  of  and save the result in the array .}
\lFor{}{}
\tcp*{i.e., , , and .}

\medskip 


\tcc{From here on,   and  are the same physical array. 
, , and  are the same physical array.}

\medskip 

;
\;

\For{}{
  \If{}{
    \;
    \tcc{Calculate the length of the -mismatch LCP
        between   and its lexicographically preceding suffix.}
    \lWhile{}
    {}
  }
  \lElse{
    \;
  }
  \If{}{
    \;
    \tcc{Calculate the length of the -mismatch LCP
        between   and its lexicographically succeeding suffix.}
   \lWhile{}{\;}
  }
  \lElse{
    \;
  }
  \lIf {}{
    \tcp*{ending position of }
  }
  \Else(\tcp*[f]{ does not exist. Early stop.}){
    \lFor{}{
      \;
    }
    Break\;
  }

  \lIf{}{\;}
  \lIf{}{\;}
}
\end{algorithm}





\begin{algorithm}[h!]
 \caption{Finding approximate LSUS}
\label{algo:lsus-approx}
\KwIn{String  and integer arrays  and , each of size , the
  value of .} 
\KwOut{ does not change.  = ending position of
  , if  exists; otherwise, .}

\bigskip 

\lFor{}{
   \tcp*{Initialization}
}

\medskip

\tcc{We use  as a circular array to save the  most recently
found mismatched positions.}

\medskip 

\tcp*{The capacity of the circular array that 
  records at most  mismatched positions.}

\medskip

\tcp*{The index of the circular array position that is
  saving the most recently founded mismatched position. It can be
  initialized to be any value from .}

\medskip


\For(\tcp*[f]{ phases}){}{
   \tcp*{The number of recorded mismatched positions
    in the circular array in the current phase.}
    \medskip
  \For{ down to }{
    \medskip
    \tcc{Comparing suffixes  and  by comparing
      their leading characters, as their remaining characters 
      have been
      compared in previous steps of this phase.}
    \medskip
   \If{}{
      \tcp*{We use 1-based indexing.}
      \;
      ; 
    }
    \If{}{
         \tcp*{}
      \;
    }
    \Else{
      \tcp*{We use 1-based indexing.}
      ;
    }
  }
}

\For{}{
  \lIf{}{
    \tcp*{ does not exist.}
  }
  \lElse{
    \tcp*{The ending position of .}
  }
}
\end{algorithm}





\begin{algorithm}[h!]
 \caption{Finding SLS (exact or approximate)}
\label{algo:sls}
\KwIn{Integer arrays  and , each of size . Each  saves
  the ending position of , if  exists;
  {\tt NIL}, otherwise.} 
\KwOut{Array  does not change. Each , such that
   is the rightmost , if  exists;
 otherwise, .}

\bigskip 

\tcc{Find the index of the rightmost existing -mismatch LSUS.}
\lFor{ down to }{
  \lIf{}{
    break\;
  }
}

\medskip 

\tcc{Compute the  array, using the memory space of 
  array.   is the largest , such that  and , if such  exists; otherwise .  If
   does not exist,  also.  
   From here on,  and  are the same physical array.}

\medskip 

\lIf{}{
  \lFor{}{
     \tcp*{Positions that do not have
      -mismatch LSUS}
  }
}

\medskip

\; 

\For{}{
   \tcp*{}
  
  \;

 \lWhile{ and  }{
    ;
  }

 \lIf{} {
    ;
  }
  \lElse{
    ;
  }
}

\medskip 

\tcc{ Compute the  array, using the memory space of  array.
   is the start position of the effective region of ,
  if  exists; , otherwise. From here on,  and 
  are the same physical array.}

\medskip 

\For{}{
  \lIf{}
  ;
  \lElse{
    ;}
}

\medskip

\tcc{ Compute the  array, using the memory space of array .
 is the largest , such that the effective region
  of  starts on position , if such  exists;
  otherwise, . From here on,  and  are the same
  physical array.}
  
\medskip

\For{ down to }{
  \lIf{}{
    \;
  }
  \lIf{}{
    \tcp*{Enable us to update
      this place 
      in the future when needed.}
  }
}

\medskip 

\tcc{ Compute  array using the memory space of array .
  , such that  is the rightmost 
, if  exists;
, otherwise. From here on,  and  are the same
  physical array.}

\medskip

  \;

  \lFor{}{
    ;
  }

\end{algorithm}






\begin{algorithm}[h!]
 \caption{Finding  SUS (exact or approximate)}
\label{algo:sus}
\KwIn{Integer arrays  and , each of size . (1) ,
  such that  is the rightmost ,
 if  exists; otherwise, . (2)  is the ending
  position of , if  exists; otherwise, .} 
\KwOut{Each  pair represents the start and ending
  positions of . }

\bigskip 

\For{ down to }{
  \If{}{
    \tcp*{The rightmost position covered
    by at least one -mismatch LSUS.}
    break;
  }
}

\If{}{
  \For{}{
     \tcp*{Positions not covered by any
      -mismatch LSUS.}
  }
}

\For{ down to }{
   \tcp*{The ending position of .}
}

\medskip 

\tcc{By this point, , if
   exists; otherwise . \newline 
 Note that , which must
  be existing and has been computed.\newline 
   Next, we compute  for all . }

\medskip 


\For{}{
 \If{}{
    ; 
     \tcp*{}
  }
  \ElseIf{ and }{
    ; 
     \tcp*{}
  }
  
  \tcc{Otherwise, do nothing. .}
}
\end{algorithm}





\end{document}
