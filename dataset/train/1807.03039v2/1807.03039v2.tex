\documentclass{article}



\usepackage[preprint]{nips_2018}







\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{comment}

\usepackage{longtable}
\usepackage{todonotes}
\usepackage{caption}
\usepackage{subcaption}

\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{comment}
\usepackage{csquotes}
\usepackage[framemethod=tikz]{mdframed}

\usepackage{appendix}
\usepackage{chngcntr}
\usepackage{etoolbox}

\usepackage[ruled]{algorithm2e}
\usepackage{algpseudocode}

\usepackage{lettrine}

\usepackage{mathtools}\usepackage{amsmath}

\usepackage{tabularx}

\usepackage{listings}
\usepackage{color}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ backgroundcolor=\color{white},   breaklines=true,                 captionpos=b,                    commentstyle=\color{mygreen},    escapeinside={\%*}{*)},          keywordstyle=\color{blue},       stringstyle=\color{red},     columns=fullflexible,
  keepspaces=true,
  frame=lines,
  basicstyle=\ttfamily,
}



\newcommand{\durk}[1]{{\textcolor{green}{[#1]}}}
\newcommand{\praf}[1]{{\textcolor{blue}{[#1]}}}

\newcommand{\bb}[1]{\mathbf{#1}}
\newcommand{\bbb}{\bb{b}}
\newcommand{\ba}{\bb{a}}
\newcommand{\bx}{\bb{x}}
\newcommand{\bxi}{\bx^{(i)}}
\newcommand{\bxl}{\bx^{(l)}}
\newcommand{\bt}{\bb{t}}
\newcommand{\by}{\bb{y}}
\newcommand{\bv}{\bb{v}}
\newcommand{\bw}{\bb{w}}
\newcommand{\bW}{\bb{W}}
\newcommand{\bc}{\bb{c}}
\newcommand{\bd}{\bb{d}}
\newcommand{\bg}{\bb{g}}
\newcommand{\bh}{\bb{h}}
\newcommand{\br}{\bb{r}}
\newcommand{\bu}{\bb{u}}
\newcommand{\bp}{\bb{p}}
\newcommand{\byl}{\by^{(l)}}
\newcommand{\bz}{\bb{z}}
\newcommand{\bzi}{\bz^{(i)}}
\newcommand{\bzl}{\bz^{(l)}}
\newcommand{\bzil}{\bz^{(i,l)}}
\newcommand{\bpa}{\bb{pa}}
\newcommand{\bbf}{\bb{f}}

\newcommand{\bT}{\boldsymbol{\theta}}
\newcommand{\bTl}{\boldsymbol{\theta}^{(l)}}
\newcommand{\boldeta}{\boldsymbol{\eta}}
\newcommand{\balpha}{\boldsymbol{\alpha}}
\newcommand{\bphi}{\boldsymbol{\phi}}
\newcommand{\beps}{\boldsymbol{\epsilon}}
\newcommand{\bepsilon}{\boldsymbol{\epsilon}}
\newcommand{\bepsl}{\beps^{(l)}}
\newcommand{\bepsil}{\beps^{(i,l)}}
\newcommand{\bzeta}{\boldsymbol{\zeta}}
\newcommand{\bzetal}{\zeta^{(l)}}
\newcommand{\bsigma}{\boldsymbol{\sigma}}
\newcommand{\bmu}{\boldsymbol{\mu}}
\newcommand{\bzero}{\bb{0}}
\newcommand{\bs}{\mathbf{s}}
\newcommand{\bmm}{\mathbf{m}}

\newcommand{\btPa}{\widetilde{\bb{Pa}}}
\newcommand{\btpa}{\widetilde{\bb{pa}}}

\newcommand{\tz}{\widetilde{z}}
\newcommand{\tZ}{\widetilde{Z}}
\newcommand{\tf}{\widetilde{f}}
\newcommand{\btZ}{\widetilde{\bb{Z}}}
\newcommand{\btz}{\widetilde{\bz}}
\newcommand{\btT}{\widetilde{\bT}}
\newcommand{\tPa}{\widetilde{Pa}}

\newcommand{\pT}{p_{\bT}}
\newcommand{\pTl}{p_{\bT^{(l)}}}
\newcommand{\pA}{p_{\balpha}}
\newcommand{\qT}{q_{\bT}}
\newcommand{\qPhi}{q_{\bphi}}
\newcommand{\qP}{q_{\bphi}}
\newcommand{\qD}{q_\mathcal{D}}
\newcommand{\qDP}{q_{\mathcal{D},\bphi}}
\newcommand{\fT}{\bbf_{\bT}}
\newcommand{\gT}{\bg_{\bT}}
\newcommand{\fPhi}{f_{\bphi}}
\newcommand{\fTPhi}{\bbf_{\bT,\bphi}}
\newcommand{\gPhi}{g_{\bphi}}
\newcommand{\hPhi}{h_{\bphi}}
\newcommand{\rPhi}{r_{\bphi}}

\title{
Glow: Generative Flow\\with Invertible 11 Convolutions
}

\author{Diederik P. Kingma\textsuperscript{*}, Prafulla Dhariwal\thanks{Equal contribution.}\\
OpenAI, San Francisco}

\begin{document}


\maketitle

\begin{abstract}
Flow-based generative models ~\citep{dinh2014nice} are conceptually attractive due to tractability of the exact log-likelihood, tractability of exact latent-variable inference, and parallelizability of both training and synthesis. In this paper we propose \emph{Glow}, a simple type of generative flow using an invertible  convolution. Using our method we demonstrate a significant improvement in log-likelihood on standard benchmarks. Perhaps most strikingly, we demonstrate that a generative model optimized towards the plain log-likelihood objective is capable of efficient realistic-looking synthesis and manipulation of large images. The code for our model is available at \url{https://github.com/openai/glow}.
\end{abstract}

\section{Introduction}

\begin{comment}
 - Put paper into context. Explain importance of generative modeling.
 - Explain likelihood-based generative models.
 - Explain (in words) what sets NICE/RealNVP type models apart from other likelihood-based models.
 - Summarize our contribution and its importance.
 - Add cool-looking figure of generated faces to lure the reader.
\end{comment}

\begin{figure}[!b]
	\centering
	\includegraphics[width=0.8\textwidth]{figures/selected_samples/composite.png}
	\caption{Synthetic celebrities sampled from our model; see Section~\ref{sec:method} for architecture and method, and Section~\ref{sec:experiments} for more results.}
	\label{fig:xor}
\end{figure}

Two major unsolved problems in the field of machine learning are (1) data-efficiency: the ability to learn from few datapoints, like humans; and (2) generalization: robustness to changes of the task or its context. AI systems, for example, often do not work at all when given inputs that are different from their training distribution. A promise of \emph{generative models}, a major branch of machine learning, is to overcome these limitations by:
(1) learning realistic world models, potentially allowing agents to plan in a world model before actual interaction with the world, and (2) learning meaningful features of the input while requiring little or no human supervision or labeling. Since such features can be learned from large unlabeled datasets and are not necessarily task-specific, downstream solutions based on those features could potentially be more robust and more data efficient. In this paper we work towards this ultimate vision, in addition to intermediate applications, by aiming to improve upon the state-of-the-art of generative models.

Generative modeling is generally concerned with the extremely challenging task of modeling all dependencies within very high-dimensional input data, usually specified in the form of a full joint probability distribution. Since such joint models potentially capture all patterns that are present in the data, the applications of accurate generative models are near endless. Immediate applications are as diverse as speech synthesis, text analysis, semi-supervised learning and model-based control; see Section~\ref{sec:relatedwork} for references.

The discipline of generative modeling has experienced enormous leaps in capabilities in recent years, mostly with likelihood-based methods~\citep{graves2013generating,kingma2013auto,kingma2018vaes,dinh2014nice,pixelrnn} and generative adversarial networks (GANs)~\citep{goodfellow2014generative} (see Section ~\ref{sec:relatedwork}). Likelihood-based methods can be divided into three categories:
\begin{enumerate}
\item Autoregressive models~\citep{hochreiter1997long,graves2013generating,pixelrnn,oord2016conditional,van2016wavenet}. Those have the advantage of simplicity, but have as disadvantage that synthesis has limited parallelizability, since the computational length of synthesis is proportional to the dimensionality of the data; this is especially troublesome for large images or video.
\item Variational autoencoders (VAEs) ~\citep{kingma2013auto,kingma2018vaes}, which optimize a lower bound on the log-likelihood of the data. Variational autoencoders have the advantage of parallelizability of training and synthesis, but can be comparatively challenging to optimize~\citep{kingma2016improving}.
\item Flow-based generative models, first described in NICE~\citep{dinh2014nice} and extended in RealNVP~\citep{dinh2016density}. We explain the key ideas behind this class of model in the following sections.
\end{enumerate}

Flow-based generative models have so far gained little attention in the research community compared to GANs~\citep{goodfellow2014generative} and VAEs~\citep{kingma2013auto}. Some of the merits of flow-based generative models include:
\begin{itemize}
\item Exact latent-variable inference and log-likelihood evaluation. In VAEs, one is able to infer only approximately the value of the latent variables that correspond to a datapoint. GANâ€™s have no encoder at all to infer the latents. In reversible generative models, this can be done exactly without approximation. Not only does this lead to accurate inference, it also enables optimization of the exact log-likelihood of the data, instead of a lower bound of it.
\item Efficient inference and efficient synthesis. Autoregressive models, such as the PixelCNN~\citep{oord2016conditional}, are also reversible, however synthesis from such models is difficult to parallelize, and typically inefficient on parallel hardware. Flow-based generative models like Glow (and RealNVP) are efficient to parallelize for both inference and synthesis.
\item Useful latent space for downstream tasks. The hidden layers of autoregressive models have unknown marginal distributions, making it much more difficult to perform valid manipulation of data. In GANs, datapoints can usually not be directly represented in a latent space, as they have no encoder and might not have full support over the data distribution. ~\citep{grover2018flow}. This is not the case for reversible generative models and VAEs, which allow for various applications such as interpolations between datapoints and meaningful modifications of existing datapoints.
\item Significant potential for memory savings. Computing gradients in reversible neural networks requires an amount of memory that is constant instead of linear in their depth, as explained in the RevNet paper~\citep{gomez2017reversible}.
\end{itemize}

In this paper we propose a new a generative flow coined \emph{Glow}, with various new elements as described in Section~\ref{sec:method}. In Section~\ref{sec:experiments}, we compare our model quantitatively with previous flows, and in Section ~\ref{sec:qualexperiments}, we study the qualitative aspects of our model on high-resolution datasets.

\section{Background: Flow-based Generative Models}\label{sec:flow}
\begin{comment}
 - Explain mathematics behind NICE / RealNVP
 - Explain benefits
 - Explain downsides: potential downsides of bipartite structure
\end{comment}

Let  be a high-dimensional random vector with unknown true distribution .
We collect an i.i.d. dataset , and choose a model  with parameters . In case of discrete data , the log-likelihood objective is then equivalent to minimizing:

In case of \emph{continuous} data , we minimize the following:

where  with , and  where  is determined by the discretization level of the data and  is the dimensionality of . Both objectives (eqs.~\eqref{eq:loss1} and \eqref{eq:loss2}) measure the expected compression cost in nats or bits; see ~\citep{dinh2016density}. Optimization is done through stochastic gradient descent using minibatches of data~\citep{kingma2015adam}.

In most flow-based generative models~\citep{dinh2014nice,dinh2016density}, the generative process is defined as:

where  is the latent variable and  has a (typically simple) tractable density, such as a spherical multivariate Gaussian distribution: . The function  is invertible, also called \emph{bijective}, such that given a datapoint , latent-variable inference is done by . For brevity, we will omit subscript  from  and .

We focus on functions where  (and, likewise, ) is composed of a sequence of transformations: , such that the relationship between  and  can be written as:

Such a sequence of invertible transformations is also called a (normalizing) \emph{flow}~\citep{rezende2015variational}. Under the \emph{change of variables} of eq.~\eqref{eq:changeofvariables}, the probability density function (pdf) of the model given a datapoint can be written as:

where we define  and  for conciseness.
The scalar value  is the logarithm of the absolute value of the determinant of the Jacobian matrix , also called the \emph{log-determinant}. This value is the change in log-density when going from  to  under transformation . While it may look intimidating, its value can be surprisingly simple to compute for certain choices of transformations, as previously explored in~\citep{deco1995higher,dinh2014nice,rezende2015variational,kingma2016improving}. The basic idea is to choose transformations whose Jacobian  is a triangular matrix. For those transformations, the log-determinant is simple:
\SetKwFunction{sum}{sum}
\SetKwFunction{fabs}{abs}
\SetKwFunction{fdiag}{diag}

where  takes the sum over all vector elements,  takes the element-wise logarithm, and  takes the diagonal of the Jacobian matrix.


\begin{figure*}[t]
    \centering
    \vspace{-0cm}
    \begin{subfigure}[b]{0.45\textwidth}
    \begin{center}
        \centering
        \includegraphics[width=.7\textwidth]{figures/keynote_figures/figure_flow_1.pdf}
        \caption{One step of our flow.}
    \end{center}
    \end{subfigure}\vspace{5mm}
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \includegraphics[width=.99\textwidth]{figures/keynote_figures/figure_flow_2.pdf}
        \caption{Multi-scale architecture~\citep{dinh2016density}.}
    \end{subfigure}
    \caption{We propose a generative flow where each step (left) consists of an \emph{actnorm} step, followed by an invertible  convolution, followed by an affine transformation~\citep{dinh2014nice}. This flow is combined with a multi-scale architecture (right). See Section~\ref{sec:method} and Table~\ref{functions}.}
    \label{fig:flow}
\end{figure*}

\section{Proposed Generative Flow}\label{sec:method}

We propose a new flow, building on the NICE and RealNVP flows proposed in~\citep{dinh2014nice,dinh2016density}. It consists of a series of steps of flow, combined in a multi-scale architecture; see Figure~\ref{fig:flow}. Each step of flow consists of \emph{actnorm} (Section~\ref{sec:actnorm}) followed by an \emph{invertible  convolution} (Section~\ref{sec:invconv}), followed by a coupling layer (Section~\ref{sec:affine}).

This flow is combined with a multi-scale architecture; due to space constraints we refer to ~\citep{dinh2016density} for more details. This architecture has a depth of flow , and number of levels  (Figure~\ref{fig:flow}).

\SetKwFunction{fsplit}{split}
\SetKwFunction{fconcat}{concat}
\SetKwFunction{neuralNet}{NN}
\SetKwFunction{fsqueeze}{squeeze}
\SetKwFunction{funsqueeze}{unsqueeze}
\SetKwFunction{flowStep}{flowStep}
\SetKwFunction{convtwod}{conv2D}
\SetKwFunction{reverseFlowStep}{reverseFlowStep}
\SetKwFunction{return}{return}

\begin{table}
    \smaller
    \caption[The three main components of our proposed flow, their reverses, and their log-determinants]{The three main components of our proposed flow, their reverses, and their log-determinants. Here,  signifies the input of the layer, and  signifies its output. Both  and  are tensors of shape  with spatial dimensions  and channel dimension . With  we denote spatial indices into tensors  and . The function  is a nonlinear mapping, such as a (shallow) convolutional neural network like in ResNets~\citep{he2016identity} and RealNVP~\citep{dinh2016density}.}
    \label{functions}
  \centering
  \begin{tabularx}{\textwidth}{ X | X | X | l}
    \toprule
    Description & Function & Reverse Function & Log-determinant
    \\\midrule
    \begin{tabular}[t]{@{}l@{}}
    Actnorm.\\
    See Section~\ref{sec:actnorm}.
    \end{tabular}
    &
    
    &
    
    &
    
    \\\midrule
    \begin{tabular}[t]{@{}l@{}}
    Invertible  convolution.\\
.\\
    See Section~\ref{sec:invconv}.
    \end{tabular}
    &
    
    &
    
    &
    \begin{tabular}[t]{@{}l@{}}
    \\
    or\\
    \\
    (see eq.~\eqref{eq:lu})
    \end{tabular}
    \\\midrule
    \begin{tabular}[t]{@{}l@{}}
    Affine coupling layer.\\
    See Section~\ref{sec:affine} and\\\citep{dinh2014nice}
    \end{tabular}
    &
    \begin{tabular}[t]{@{}l@{}}
    \\
    \\
    \\
    \\
    \\
    
    \end{tabular}
    &
    \begin{tabular}[t]{@{}l@{}}
    \\
    \\
    \\
    \\
    \\
    
    \end{tabular}
    &
    
\\\bottomrule
  \end{tabularx}
\end{table}





\subsection{Actnorm: scale and bias layer with data dependent initialization}
\label{sec:actnorm}

In \cite{dinh2016density}, the authors propose the use of batch normalization~\citep{ioffe2015batch} to alleviate the problems encountered when training deep models. However, since the variance of activations noise added by batch normalization is inversely proportional to minibatch size per GPU or other processing unit (PU), performance is known to degrade for small per-PU minibatch size. For large images, due to memory constraints, we learn with minibatch size 1 per PU. We propose an \emph{actnorm} layer (for \emph{activation normalizaton}), that performs an affine transformation of the activations using a scale and bias parameter per channel, similar to batch normalization. These parameters are initialized such that the post-actnorm activations per-channel have zero mean and unit variance given an initial minibatch of data. This is a form of \emph{data dependent initialization}~\citep{salimans2016weight}. After initialization, the scale and bias are treated as regular trainable parameters that are independent of the data.

\subsection{Invertible  convolution}
\label{sec:invconv}

~\citep{dinh2014nice,dinh2016density} proposed a flow containing the equivalent of a permutation that reverses the ordering of the channels. We propose to replace this fixed permutation with a (learned) invertible  convolution, where the weight matrix is initialized as a random rotation matrix. Note that a  convolution with equal number of input and output channels is a generalization of a permutation operation.

The log-determinant of an invertible  convolution of a  tensor  with  weight matrix  is straightforward to compute:

The cost of computing or differentiating  is , which is often comparable to the cost computing  which is . We initialize the weights  as a random rotation matrix, having a log-determinant of 0; after one SGD step these values start to diverge from 0.

\paragraph{LU Decomposition.} This cost of computing  can be reduced from  to  by parameterizing  directly in its LU decomposition:

where  is a permutation matrix,  is a lower triangular matrix with ones on the diagonal,  is an upper triangular matrix with zeros on the diagonal, and  is a vector. The log-determinant is then simply:

The difference in computational cost will become significant for large , although for the networks in our experiments we did not measure a large difference in wallclock computation time.

In this parameterization, we initialize the parameters by first sampling a random rotation matrix , then computing the corresponding value of  (which remains fixed) and the corresponding initial values of  and  and  (which are optimized).

\subsection{Affine Coupling Layers}
\label{sec:affine}

A powerful reversible transformation where the forward function, the reverse function and the log-determinant are computationally efficient, is the \emph{affine coupling} layer introduced in~\citep{dinh2014nice,dinh2016density}. See Table~\ref{functions}. An \emph{additive coupling layer} is a special case with  and a log-determinant of 0.

\paragraph{Zero initialization.} We initialize the last convolution of each  with zeros, such that each affine coupling layer initially performs an identity function; we found that this helps training very deep networks.

\paragraph{Split and concatenation.} As in \citep{dinh2014nice}, the  function splits  the input tensor into two halves along the channel dimension, while the  operation performs the corresponding reverse operation: concatenation into a single tensor. In~\citep{dinh2016density}, another type of split was introduced: along the spatial dimensions using a checkerboard pattern. In this work we only perform splits along the channel dimension, simplifying the overall architecture.

\paragraph{Permutation.} Each step of flow above should be preceded by some kind of permutation of the variables that ensures that after sufficient steps of flow, each dimensions can affect every other dimension. The type of permutation specifically done in~\citep{dinh2014nice,dinh2016density} is equivalent to simply \emph{reversing the ordering} of the channels (features) before performing an additive coupling layer. An alternative is to perform a (fixed) random permutation. Our invertible 1x1 convolution is a generalization of such permutations. In experiments we compare these three choices.

\section{Related Work}
\label{sec:relatedwork}

This work builds upon the ideas and flows proposed in ~\citep{dinh2014nice} (NICE) and ~\citep{dinh2016density} (RealNVP); comparisons with this work are made throughout this paper. In~\citep{papamakarios2017masked} (MAF), the authors propose a generative flow based on IAF~\citep{kingma2016improving}; however, since synthesis from MAF is non-parallelizable and therefore inefficient, we omit it from comparisons. Synthesis from autoregressive (AR) models~\citep{hochreiter1997long,graves2013generating,pixelrnn,oord2016conditional,van2016wavenet} is similarly non-parallelizable. Synthesis of high-dimensional data typically takes multiple orders of magnitude longer with AR models; see~\citep{kingma2016improving,oord2017parallel} for evidence. Sampling  images with our largest models takes less than one second on current hardware. \footnote{More specifically, generating a  image at batch size 1 takes about 130ms on a single 1080 Ti, and about 550ms on a K80}

GANs~\citep{goodfellow2014generative} are arguably best known for their ability to synthesize large and realistic images~\citep{karras2017progressive}, in contrast with likelihood-based methods. Downsides of GANs are their general lack of latent-space encoders, their general lack of full support over the data~\citep{grover2018flow}, their difficulty of optimization, and their difficulty of assessing overfitting and generalization.



\section{Quantitative Experiments}\label{sec:experiments}

We begin our experiments by comparing how our new flow compares against RealNVP~\citep{dinh2016density}. We then apply our model on other standard datasets and compare log-likelihoods against previous generative models. See the appendix for optimization details. In our experiments, we let each  have three convolutional layers, where the two hidden layers have ReLU activation functions and 512 channels. The first and last convolutions are , while the center convolution is , since both its input and output have a large number of channels, in contrast with the first and last convolution.

\begin{figure}
	\centering
	\begin{subfigure}{0.5\textwidth}
    	\includegraphics[width=\textwidth]{figures/invconv_additive.pdf}
    	\caption{Additive coupling.}
    \end{subfigure}\begin{subfigure}{0.5\textwidth}
    	\includegraphics[width=\textwidth]{figures/invconv_affine.pdf}
    	\caption{Affine coupling.}
    \end{subfigure}\caption{Comparison of the three variants - a reversing operation as described in the RealNVP, a fixed random permutation, and our proposed invertible  convolution, with additive (left) versus affine (right) coupling layers. We plot the mean and standard deviation across three runs with different random seeds.}
	\label{fig:invconv}
\end{figure}

\paragraph{Gains using invertible  Convolution.} We choose the architecture described in Section~\ref{sec:method}, and consider three variations for the permutation of the channel variables - a reversing operation as described in the RealNVP, a fixed random permutation, and our invertible  convolution. We compare for models with only additive coupling layers, and models with affine coupling. As described earlier, we initialize all models with a data-dependent initialization which normalizes the activations of each layer. All models were trained with  and . The model with  convolution has a negligible  larger amount of parameters.

We compare the average negative log-likelihood (bits per dimension) on the CIFAR-10 \citep{krizhevsky2009learning} dataset, keeping all training conditions constant and averaging across three random seeds. The results are in Figure \ref{fig:invconv}. As we see, for both additive and affine couplings, the invertible  convolution achieves a lower negative log likelihood and converges faster. The affine coupling models also converge faster than the additive coupling models. We noted that the increase in wallclock time for the invertible  convolution model was only , thus the operation is computationally efficient as well.

\paragraph{Comparison with RealNVP on standard benchmarks.}
\label{sec:exp_ll}
Besides the permutation operation, the RealNVP architecture has other differences such as the spatial coupling layers. In order to verify that our proposed architecture is overall competitive with the RealNVP architecture, we compare our models on various natural images datasets. In particular, we compare on CIFAR-10, ImageNet \citep{russakovsky2015imagenet} and LSUN \citep{yu15lsun} datasets. We follow the same preprocessing as in \citep{dinh2016density}. For Imagenet, we use the  and  downsampled version of ImageNet ~\citep{oord2016pixel}, and for LSUN we downsample to  and take random crops of . We also include the bits/dimension for our model trained on  CelebA HQ used in our qualitative experiments.\footnote{Since the original CelebA HQ dataset didn't have a validation set, we separated it into a training set of 27000 images and a validation set of 3000 images} As we see in Table \ref{tab:models:results}, our model achieves a significant improvement on all the datasets.

\begin{table}[]
    \centering
    \caption{Best results in bits per dimension of our model compared to RealNVP.}
    \label{tab:models:results}
    \resizebox{\textwidth}{!}{\begin{tabular}{l | l | l | l | l | l | l}
    \toprule
    Model     & CIFAR-10 & ImageNet 32x32 & ImageNet 64x64 & LSUN (bedroom) & LSUN (tower) & LSUN (church outdoor)
    \\\midrule
    RealNVP &  &  &  & 2.72 & 2.81 & 3.08
    \\\midrule
    Glow    &  &  &  &   &   & 
    \\\bottomrule
    \end{tabular}}
\end{table}

\begin{figure}[t]
	\centering
	\includegraphics[width=0.8\textwidth]{figures/raw_samples/epoch_6350_random_samples.png}
	\caption{Random samples from the model, with temperature }
	\label{fig:samples}
\end{figure}
\begin{figure}[t]
	\centering
	\includegraphics[width=0.8\textwidth]{figures/interpolation/interpolation.png}
	\caption{Linear interpolation in latent space between real images}
	\label{fig:interpolation}
\end{figure}

\section{Qualitative Experiments}\label{sec:qualexperiments}
We now study the qualitative aspects of the model on high-resolution datasets. We choose the CelebA-HQ dataset \citep{karras2017progressive}, which consists of  high resolution images from the CelebA dataset, and train the same architecture as above but now for images at a resolution of ,  and . To improve visual quality at the cost of slight decrease in color fidelity, we train our models on -bit images. We aim to study if our model can scale to high resolutions, produce realistic samples, and produce a meaningful latent space. Due to device memory constraints, at these resolutions we work with minibatch size 1 per PU, and use gradient checkpointing \citep{gradcheckpointing}. In the future, we could use a constant amount of memory independent of depth by utilizing the reversibility of the model \citep{gomez2017reversible}.

Consistent with earlier work on likelihood-based generative models~\citep{parmar2018image}, we found that sampling from a reduced-temperature model often results in higher-quality samples. When sampling with temperature , we sample from the distribution . In case of additive coupling layers, this can be achieved simply by multiplying the standard deviation of  by a factor of .

\paragraph{Synthesis and Interpolation.}
Figure \ref{fig:samples} shows the random samples obtained from our model. The images are extremely high quality for a non-autoregressive likelihood based model. To see how well we can interpolate, we take a pair of real images, encode them with the encoder, and linearly interpolate between the latents to obtain samples. The results in Figure \ref{fig:interpolation} show that the image manifold of the generator distribution is extremely smooth and almost all intermediate samples look like realistic faces.

\paragraph{Semantic Manipulation.}
\begin{figure}[t]
    \centering
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/manipulation/Smiling.png}
        \caption{Smiling}
    \end{subfigure}
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/manipulation/Pale_Skin.png}
        \caption{Pale Skin}
    \end{subfigure}
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/manipulation/Blond_Hair.png}
        \caption{Blond Hair}
    \end{subfigure}
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/manipulation/Narrow_Eyes.png}
        \caption{Narrow Eyes}
    \end{subfigure}
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/manipulation/Young.png}
        \caption{Young}
    \end{subfigure}
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/manipulation/Male.png}
        \caption{Male}
    \end{subfigure}
    \caption{Manipulation of attributes of a face. Each row is made by interpolating the latent code of an image along a vector corresponding to the attribute, with the middle image being the original image}
    \label{fig:manipulation}
\end{figure}
We now consider modifying attributes of an image. To do so, we use the labels in the CelebA dataset. Each image has a binary label corresponding to presence or absence of attributes like smiling, blond hair, young, etc. This gives us  binary labels for each attribute. We then calculate the average latent vector  for images with the attribute and  for images without, and then use the difference  as a direction for manipulating. Note that this is a relatively small amount of supervision, and is done after the model is trained (no labels were used while training), making it extremely easy to do for a variety of different target attributes. The results are shown in Figure \ref{fig:manipulation}.

\begin{figure}
	\centering
	\begin{subfigure}{0.32\textwidth}
    	\includegraphics[width=\textwidth]{figures/lsun_samples/qualitative/64_rnvp/epoch_7650_sample_5.png}
    \end{subfigure}\hspace{0.01\textwidth}\begin{subfigure}{0.32\textwidth}
    	\includegraphics[width=\textwidth]{figures/lsun_samples/qualitative/96/epoch_4650_sample_5.png}
    \end{subfigure}\hspace{0.01\textwidth}\begin{subfigure}{0.32\textwidth}
    	\includegraphics[width=\textwidth]{figures/lsun_samples/qualitative/128/epoch_7250_sample_5.png}
    \end{subfigure}\caption[Samples from model trained on 5-bit LSUN bedrooms, at temperature 0.875. Resolutions 64, 96 and 128 respectively]{Samples from model trained on 5-bit LSUN bedrooms, at temperature 0.875. Resolutions 64, 96 and 128 respectively \footnotemark}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[width=0.6\textwidth]{figures/raw_samples/temperature.png}
	\caption{Effect of change of temperature. From left to right, samples obtained at temperatures }
	\label{fig:temperature}
\end{figure}
\begin{figure}
	\centering
	\includegraphics[width=0.6\textwidth]{figures/deep-notdeep/deep-vs-nondeep.png}
	\caption{Samples from shallow model on left vs deep model on right. Shallow model has  levels, while deep model has  levels}
	\label{fig:depth}
\end{figure}


\paragraph{Effect of temperature and model depth.} Figure \ref{fig:temperature} shows how the sample quality and diversity varies with temperature. The highest temperatures have noisy images, possibly due to overestimating the entropy of the data distribution, and thus we choose a temperature of  as a sweet spot for diversity and quality of samples. Figure \ref{fig:depth} shows how model depth affects the ability of the model to learn long-range dependencies.

\begin{comment}
 - Show random samples from face model
 - Show interpolations between faces
 - Show samples of not-deep-enough model with the deep model
 - Show manipulations of faces
\end{comment}

\footnotetext{For  and  versions, we centre cropped the original image, and downsampled. For  version, we took random crops from the  downsampled image as done in \cite{dinh2016density}}
\section{Conclusion}

We propose a new type of flow, coined~\emph{Glow}, and demonstrate improved quantitative performance in terms of log-likelihood on standard image modeling benchmarks. In addition, we demonstrate that when trained on high-resolution faces, our model is able to synthesize realistic images. Our model is, to the best of our knowledge, the first likelihood-based model in the literature that can efficiently synthesize high-resolution natural images.

\smaller
\bibliographystyle{apalike}
\bibliography{bib}





\appendix
\normalsize

\section{Additional quantitative results}
See Table~\ref{tab:models:moreresults}.
\begin{table}[h]
    \centering
    \caption{Quantiative results in bits per dimension on the test set.}
    \label{tab:models:moreresults}
    \begin{tabular}{l | l}
    \toprule
    Dataset & Glow
    \\\midrule
    CIFAR-10, 3232, 5-bit & 1.67
    \\\midrule
    ImageNet, 3232, 5-bit & 1.99
    \\\midrule
    ImageNet, 6464, 5-bit & 1.76
    \\\midrule
    CelebA HQ, 256256, 5-bit & 1.03
    \\\bottomrule
    \end{tabular}
\end{table}

\section{Simple python implementation of the invertible  convolution}
\lstinputlisting[language=Python]{code.py}
\section{Optimization details}\label{sec:opt}

We use the Adam optimizer~\citep{kingma2015adam} with  and default  and . In out quantitative experiments (Section \ref{sec:experiments}, Table \ref{tab:models:results}) we used the following hyperparameters (Table \ref{tab:models:hyper}). \\
\begin{table}[h]
    \centering
    \caption{Hyperparameters for results in Section \ref{sec:experiments}, Table \ref{tab:models:results}}
    \label{tab:models:hyper}
    \begin{tabular}{l | l | l | l | l}
    \toprule
    Dataset & Minibatch Size & Levels (L) & Depth per level (K) & Coupling
    \\\midrule
    CIFAR-10 & 512 & 3 & 32 & Affine
    \\\midrule
    ImageNet, 3232 & 512 & 3 & 48 & Affine
    \\\midrule
    ImageNet, 6464 & 128 & 4 & 48 & Affine
    \\\midrule
    LSUN, 6464 & 128 & 4 & 48 & Affine
    \\\bottomrule
    \end{tabular}
\end{table}

In our qualitative experiments (Section \ref{sec:qualexperiments}), we used the following hyperparameters (Table \ref{tab:models:hyper_qual})
\begin{table}[h]
    \centering
    \caption{Hyperparameters for results in Section \ref{sec:qualexperiments}}
    \label{tab:models:hyper_qual}
    \begin{tabular}{l | l | l | l | l}
    \toprule
    Dataset & Minibatch Size & Levels (L) & Depth per level (K) & Coupling
    \\\midrule
    LSUN, 6464, 5-bit & 128 & 4 & 48 & Additive
    \\\midrule
    LSUN, 9696, 5-bit & 320 & 5 & 64 & Additive
    \\\midrule
    LSUN, 128128, 5-bit & 160 & 5 & 64 & Additive
    \\\midrule
    CelebA HQ, 256256, 5-bit & 40 & 6 & 32 & Additive
    \\\bottomrule
    \end{tabular}
\end{table}
\section{Extra samples from qualitative experiments}
For the class conditional CIFAR-10 and 3232 ImageNet samples, we used the same hyperparameters as the quantitative experiments, but with a class dependent prior at the top-most level. We also added a classification loss to predict the class label from the second last layer of the encoder, with a weight of . The results are in Figure \ref{fig:cif_img_qual}.
\begin{figure}[h]
	\centering
	\begin{subfigure}{0.69\textwidth}
    	\includegraphics[width=\textwidth]{figures/cifar_samples/qualitative/epoch_1000_sample_4.png}
	\caption{Class conditional CIFAR-10 samples}
	\end{subfigure}\hspace{0.01\textwidth}\begin{subfigure}{0.69\textwidth}
    	\includegraphics[width=\textwidth]{figures/imagenet_samples/qualitative/32/epoch_4150_sample_4.png}
	\caption{Class conditional  ImageNet samples}
	\end{subfigure}
\caption{Class conditional samples on 5-bit CIFAR-10 and  ImageNet respectively. Temperature 0.75}
\label{fig:cif_img_qual}
\end{figure}

\section{Extra samples from the quantitative experiments}
For direct comparison with other work, datasets are preprocessed exactly as in \cite{dinh2016density}. Results are in Figure \ref{fig:lsun_quant} and Figure \ref{fig:my_label}.
\begin{figure}[h]
	\centering
	\begin{subfigure}{0.49\textwidth}\includegraphics[width=\textwidth]{figures/lsun_samples/quantitative/bdr_rnvp/epoch_7600_sample_6.png}
	\end{subfigure}\hspace{0.01\textwidth}\begin{subfigure}{0.49\textwidth}\includegraphics[width=\textwidth]{figures/lsun_samples/quantitative/crh_rnvp/epoch_7500_sample_6.png}
	\end{subfigure}\hspace{0.01\textwidth}\begin{subfigure}{0.49\textwidth}\includegraphics[width=\textwidth]{figures/lsun_samples/quantitative/twr_rnvp/epoch_7950_sample_6.png}
	\end{subfigure}\caption{Samples from 8-bit,  LSUN bedrooms, church and towers respectively. Temperature 1.0}
\label{fig:lsun_quant}
\end{figure}


\begin{figure}
    \centering
    \includegraphics[width=0.69\textwidth]{figures/cifar_samples/quantitative/epoch_2050_sample_6.png}
    \caption{Samples from an unconditional model with affine coupling layers trained on the CIFAR-10 dataset with temperature 1.0.}
    \label{fig:my_label}
\end{figure}

\end{document}
