\section{Introduction}

Church's type theory~\cite{Church40} is a basic
formulation of higher-order logic.
Henkin~\cite{Henkin50} found a natural class of models
for which Church's Hilbert-style proof system turned
out to be complete.  Equality, originally expressed
with higher-order quantification, was later identified
as the primary primitive of the
theory~\cite{Henkin63,Andrews72a,AndrewsBook}.
In this paper we consider simple type theory with
primitive equality but without descriptions or choice.
We call this system STT for simple type
theory.  The semantics of STT is given by Henkin
models with equality.


Modern proof theory started with
Gentzen's~\cite{Gentzen1935} invention of a cut-free
sequent calculus for first-order logic.  While Gentzen
proved a cut-elimination theorem for his calculus,
Smullyan~\cite{SmullyanBook} found an elegant technique
(abstract consistency classes) for proving the
completeness of cut-free first-order calculi.
Smullyan~\cite{SmullyanBook} found it advantageous to
work with a refutation-oriented variant of Gentzen's
sequent calculi~\cite{Gentzen1935} known as tableau
calculi~\cite{Beth1955,Hintikka1955,SmullyanBook}.

The development of complete cut-free proof systems for
simple type theory turned out to be hard.  In 1953,
Takeuti~\cite{Takeuti53} introduced a sequent calculus
for a version of simple type theory without primitive equality
and conjectured that cut elimination holds for
this calculus.  Gentzen's~\cite{Gentzen1935} inductive
proof of cut-elimination for first-order sequent
calculi does not generalize to the higher-order case
since instances of formulas may be more complex than
the formula itself.
Moreover, Henkin's~\cite{Henkin50} completeness proof
cannot be adapted for cut-free systems.  Takeuti's
conjecture was answered positively by
Tait~\cite{Tait66} for second-order logic, by
Takahashi~\cite{Takahashi67} and
Prawitz~\cite{Prawitz68} for higher-order logic without
extensionality, and by Takahashi~\cite{Takahashi68} for
higher-order logic with extensionality.  
Building on
the possible-values technique of
Takahashi~\cite{Takahashi67} and
Prawitz~\cite{Prawitz68}, Takeuti \cite{Takeuti75}
finally proves Henkin completeness of a cut-free
sequent calculus with extensionality.



The first cut-elimination result for a calculus similar
to Church's type theory was obtained by
Andrews~\cite{Andrews71} in 1971.  Andrews considers
elementary type theory (Church's type theory without
equality, extensionality, infinity, and choice) and
proves that a cut-free sequent calculus is complete
relative to a Hilbert-style proof system.  
Andrews' proof employs both the possible-values
technique~\cite{Takahashi67,Prawitz68} and the abstract
consistency technique~\cite{SmullyanBook}.
In 2004 Benzm\"uller, Brown and Kohlhase~\cite{BBKweb04} gave
a completeness proof for an extensional cut-free sequent calculus.
The constructions in~\cite{BBKweb04} also employ abstract consistency
and possible values.

None of the cut-free calculi discussed above has
equality as a primitive.  Following Leibniz, one can
define equality of  and  to hold whenever  and
 satisfy the same properties.  While this yields
equality in standard models (full function spaces),
there are Henkin models where this is not the
case as was shown by Andrews~\cite{Andrews72a}.  
A particularly disturbing fact about the model Andrews constructs
is that while it is extensional (indeed, it is a Henkin model),
it does not satisfy a formula corresponding to extensionality
(formulated using Leibniz equality).
In~\cite{Andrews72a} Andrews gives
a definition of a {\em general model} which is essentially a Henkin model
with equality.
This notion of a general model was generalized to include non-extensional models in~\cite{BBK04}
and a condition called property 
was explicitly included to ensure Leibniz equality is the same as semantic equality.
The constructions of Prawitz, Takahashi, Andrews and Takeuti described above
do not produce models guaranteed to satisfy property .
A similar generalization of Henkin models to non-extensional models is given by Muskens~\cite{Muskens07}
but without a condition like property .  Muskens uses the Prawitz-Takahashi method
to prove completeness of a cut-free sequent calculus for a formulation of elementary type theory
via a model existence theorem, again producing a model in which Leibniz equality may not be the same as semantic equality.
The models constructed in~\cite{BBK04} do satisfy property ,
as do the models constructed in~\cite{BBKweb04}.

In addition
to the model-theoretic complication, defined equality also destroys the cut-freeness of a proof system.  As shown
in~\cite{BBK2009} any use of Leibniz equality to say
two terms are equal provides for the simulation of 
cut.\footnote{From a Leibniz formula of the form  one can easily infer  for any formula , and then use  as a formula introduced by cut.} Hence calculi that define equality as Leibniz equality
cannot claim to provide cut-free equational reasoning.
In the context of resolution,
Benzm\"uller gives serious consideration to primitive equality
and its relationship to Leibniz equality in his 1999 doctoral thesis~\cite{Benzmuller99a} (see also~\cite{Benzmuller99b}).
The completeness proofs there are relative to an assumption that corresponds to cut.


The first completeness proof for a cut-free proof system
for extensional simple type theory with primitive equality
relative to Henkin models was given by
Brown in his 2004 doctoral thesis~\cite{Brown2004a}
(later published as a book~\cite{BrownARHO}).  Brown
proves the Henkin completeness of a novel one-sided
sequent calculus with primitive equality.  His model
construction starts with Andrews'~\cite{Andrews71}
non-extensional possible-values relations and then
obtains a structure isomorphic to a Henkin model by
taking a quotient with respect to a partial equivalence
relation.  Finally, abstract consistency
classes~\cite{SmullyanBook,Andrews71} are used to
obtain the completeness result.  The equality-based
decomposition rules of Brown's sequent calculus have
commonalities with the unification rules of the systems
of Kohlhase~\cite{KohlhaseTableaux1995} and
Benzm\"uller~\cite{Benzmuller99b}.  Note, however, that
the completeness proofs of Kohlhase and Benzm\"uller
assume the presence of cut.

In this paper we improve and simplify Brown's
result~\cite{BrownARHO}.  
For the proof system we
switch to a cut-free tableau calculus  that employs an
abstract normalization operator.  With the
normalization operator we hide the details of lambda
conversion from the tableau calculus and most of the
completeness proof.  For the completeness proof we use
the new notion of a value system to directly construct
surjective Henkin models.  Value systems are logical
relations~\cite{Statman85a} providing a relational
semantics for simply-typed lambda calculus.  The
inspiration for value systems came from the
possible-values relations used
in~\cite{BrownARHO,BrownSmolkaBasic,BrownSmolkaEFO}.
In contrast to Henkin models, which obtain values for
terms by induction on terms, value systems obtain
values for terms by induction on types.  Induction on
types, which is crucial for our proofs, has the
advantage of hiding the presence of the lambda binder.
As a result, only a single lemma of our completeness
proof deals explicitly with lambda abstractions and
substitutions.

Once we have established the results for STT, we turn
to its first-order fragment EFO (for extended
first-order), which restricts equality and
quantification to base types but retains lambda
abstraction and higher-order variables.  EFO contains
the usual first-order formulas but also contains
formulas that are not first-order in the traditional
sense.  For instance, a formula 
is EFO even though the predicate  is applied to a
-abstraction and the negation appears embedded
in a nontrivial way.  We sharpen the results for STT by
proving that they hold for EFO with respect to standard
models and for a constrained rule for the universal
quantifier (first published in~\cite{BrownSmolkaEFO}).

Finally, we consider three decidable fragments of EFO:
the lambda-free fragment, the pure fragment
(disequations between simply typed -terms not
involving logic), and the Bernays-Sch\"onfinkel-Ramsey
fragment.  For each of these fragments, decidability
follows from termination of the tableau calculus for EFO
(first published in~\cite{BrownSmolkaBasic}
and~\cite{BrownSmolkaEFO}).

























\section{Basic Definitions}

We assume a countable set of \emph{base types}
().  \emph{Types} (, , ) are
defined inductively: (1)~every base type is a type;
(2)~if  and  are types, then 
is a type.  We assume a countable set of \emph{names}
(, ), where every name comes with a unique type,
and where for every type there are infinitely many names of this 
type.\footnote{Later we will partition names into variables and logical constants.} \emph{Terms} (, , , )
are defined inductively: (1)~every name is a term;
(2)~if  is a term of type  and  is a
term of type , then  is a term of type ;
(3)~if  is a name of type  and  is a term
of type , then  is a term of type
.  We write \emph{} to say that
 is a term of type .  Moreover, we write
\emph{} for the set of all terms of type
.  We assume that the set of types and the set of terms
are disjoint.

A \emph{frame} is a function  that maps every
type to a nonempty set such that  is
a set of total functions from  to
 for all types ,  (i.e.,
).
An
\emph{assignment} into a frame  is a function
 that extends  (i.e., ) and
maps every name  to an element of 
(i.e., ).  If~ is an
assignment into a frame ,  is a
name, and ,
then~\emph{} denotes the assignment
into  that agrees everywhere with~ but
possibly on~ where it yields .  For every frame
 we define a function \emph{} that for
every assignment~ into  yields a
function  that for some terms 
returns an element of .  The definition is
by induction on terms.

We call  the \emph{evaluation function} of
.  
The evaluation function may be partial since in the last clause  of the definition even assuming there is some function  such that  for every , this  may not be in .  In such a case,  will not be defined on .  Of course, in such a case  will also not be defined on a term of the form  since
the second clause of the definition will fail. An \emph{interpretation} is an
assignment whose evaluation function is defined on
all terms.  An assignment  is
\emph{surjective} if for every type  and every
value  there exists a term 
such that .

\begin{prop}
  Let  be an interpretation, ,
  and .  Then~ is an
  interpretation.
\end{prop}



\begin{prop}
  If  is a surjective interpretation, then
   is a countable set for every type
  .
\end{prop}

A \emph{standard frame} is a frame  such that
 for all
types , .  A \emph{standard
  interpretation} is an assignment into a standard
frame.  Note that every standard interpretation is, in fact, an
interpretation.

We assume a \emph{normalization operator } that provides for lambda conversion.  The normalization
operator  must be a type preserving total function from terms to terms.  We call  the
\emph{normal form of } and say that  is
\emph{normal} if .  One possible
normalization operator is a function that for every
term  return a -normal term that can be
obtained from  by -reduction.  We will not
commit to a particular normalization operator but state
explicitly the properties we require for our results.
To start, we require the following properties:
\begin{description}
\item[{N1}~] 
\item[{N2}~] 
\item[{N3}~]  
  \quad if  and 
\item[{N4}~] 
  \quad if  is an interpretation
\end{description}

\begin{prop}
   is normal iff  are normal.
\end{prop}



For the proofs of Lemma~\ref{lem-admissibility} and
Theorem~\ref{theo-admissible-interpretations} we need
further properties of the normalization operator that
can only be expressed with substitutions.  A
\emph{substitution} is a type preserving partial
function from names to terms.  If  is a
substitution,  is a name, and  is a term that has
the same type as , we write \emph{} for the substitution that agrees everywhere
with~ but possibly on  where it yields .
We assume that every substitution  can be
extended to a type preserving total function
\emph{} from terms to terms such that the
following conditions hold:
\enlargethispage*{5mm} \begin{description}
\item[{S1}~] 
\item[{S2}~] 
\item[{S3}~] 
\item[{S4}~] 
\end{description}
Note that  (the empty set) is the substitution
that is undefined on every name.

\section{Value Systems}
\label{sec:value-sys}

We introduce value systems as a tool for constructing
surjective interpretations.  Value systems are
logical relations inspired by the possible-values
relations used
in~\cite{BrownARHO,BrownSmolkaEFO,BrownSmolkaBasic}.

A \emph{value system} is a function  that maps
every base type  to a binary
relation~ such that
 and  iff .  For every value
system~ we define by induction on types:

Note that
 for all
types .  We usually drop the type index in
 and read  as  can be
 or  is a \emph{possible value} for .

\begin{prop}
  \label{prop-norm-poss-value}
  For every value system: \
   iff .
\end{prop}

\begin{proof}
  By induction on .  For base types the claim
  holds by the definition of value systems.  Let
  .
  For all , , , and ,
  
  by the inductive hypothesis and N2.
  Hence  iff .
\end{proof}

A value system  is \emph{functional} if
 is a functional relation for every base
type .
(That is, for each  there is at most one  such that .) 

\begin{prop}
  \label{prop-functional-vs}
  If  is functional, then  is a
  functional relation for every type~.
\end{prop}

\begin{proof}
  By induction on .  For , the
  claim is trivial.  Let  and
  .  We show .  Let
  .  Then  for some .
  Now .  By inductive hypothesis
  .
\end{proof}

A value system  is \emph{total} if
 for every name .  An
assignment  is \emph{admissible} for a value
system  if  for all
types  and  for all names .
(Recall that  is used to define .) Note that every total value system has admissible
assignments.  We will show that admissible
assignments are interpretations that
evaluate terms to possible values.


\begin{lem}
  \label{lem-admissibility}
  Let  be an assignment that is admissible
  for a value system  and  be a
  substitution such that  for
  all .  Then  and
   for every term .
\end{lem}

\begin{proof}
  By induction on .  Let  be a term.  Case
  analysis.

  \br .  The claim holds by assumption and S1.

  \br .  Then , \
  , \
  , \ and
   by inductive
  hypothesis.  Thus  and
   using S2.

  \br ,  and .  
  We need to prove  and .
  First we prove
  
  Let .  
  By inductive hypothesis we have 
  and .
  Now
   using~S3.
  Using Proposition~\ref{prop-norm-poss-value} we conclude (\ref{lem-adm-funcase}) holds.

  By definition of  for every  there is a  such that .
  Using this and (\ref{lem-adm-funcase}) we know  for every .
  Let  be defined by 
  for each .  
  For all  we have  by (\ref{lem-adm-funcase}).
  Hence .
  This implies , , 
  and  as desired.
\end{proof}

\begin{thm}
  \label{theo-admissible-interpretations}
  Let  be an assignment that is admissible
  for a value system~.  Then  is an
  interpretation such that  for all
  terms .  Furthermore, ~is surjective
  if~ is functional.
\end{thm}

\begin{proof}
  Follows from Lemma~\ref{lem-admissibility} with
  Proposition~\ref{prop-norm-poss-value} and S4.
  To prove the second claim, let  be given.  By definition of  there is some  such that .
  Since  we know  by
  Proposition~\ref{prop-functional-vs}. \end{proof}










\section{Simple Type Theory}

We now define the terms and semantics of simple type theory (\emph{STT}).
We fix a base type  for the truth values and a
name  for negation.
Moreover, we fix for every type
 a name  for the
identity predicate for .
An assignment
 is \emph{logical} if ,
 is the negation
function and  is the identity
predicate for .
We refer to the base types
different from  as \emph{sorts}, to the names
 and  as \emph{logical constants}, 
and to all other names as \emph{variables}.  
From now on \emph{} will range
over variables. Moreover, \emph{} will range over logical constants
and \emph{} will range over sorts.

A \emph{formula} is a term of type .  We employ
infix notation for formulas obtained with 
 and often write \emph{equations}  without the type index.  
We write \emph{} for 
and speak of a \emph{disequation}.
Note that
quantified formulas  can be expressed as
equations .

A logical interpretation  \emph{satisfies}
a formula  if .  A \emph{model} of a
set of formulas  is a logical interpretation
that satisfies every formula~.  A set of
formulas is \emph{satisfiable} if it has a model.

\section{Tableau Calculus}

We now give a deductive calculus for STT.
A \emph{branch} is a set of normal formulas.  The
\emph{tableau calculus } operates on finite branches
and employs the rules shown in
Figure~\ref{fig-tableau-rules}.
\begin{figure}[t]
\begin{mathpar}
  \inferrule*[left=\emph{\TRDN}~]{\neg\neg s}{s}
  \and
\inferrule*[left=\emph{\TRBQ}~]{s =_ot}{s\,,\,t~\mid~\neg s\,,\,\neg t}
  \and
  \inferrule*[left=\emph{\TRBE}~]{s\neq_ot}{s\,,\,\neg t~\mid~\neg s\,,\,t}
  \\
  \inferrule*[left=\emph{\TRFQ}~,right=~ normal]
  {s =_{\sigma\tau} t}{\nf{su} =\nf{tu}}
  \and
  \inferrule*[left=\emph{\TRFE}~,right=~ fresh]
  {s\neq_{\sigma\tau} t}{\nf{sx}\neq\nf{tx}}
  \\
\inferrule*[left=\emph{\TRMat}~,right=~] {xs_1\dots
    s_n\,,\,\neg xt_1\dots t_n} {s_1\neq t_1\mid\dots\mid s_n\neq t_n}
\and
  \inferrule*[left=\emph{\TRDec}~,right=~] {xs_1\dots
    s_n\neq_\alpha xt_1\dots t_n} {s_1\neq t_1\mid\dots\mid s_n\neq t_n}
  \\\
  \inferrule*[left=\emph{\TRCon}~]
  {s=_\alpha t\,,\,u\neq_\alpha v}
  {s\neq u\,,\,t\neq u\mid s\neq v\,,\,t\neq v}
\end{mathpar}
\caption{Tableau rules for STT}
\label{fig-tableau-rules}
\end{figure}
The side condition ``~fresh'' of rule \TRFE requires
that  does not occur free in the branch the rule is
applied to.  
We say a branch  is \emph{closed} if  for some variable 
or if  for some variable .
Note that  is closed if and only if either the  or  rule 
applies with .
We impose the following restrictions:
\begin{enumerate}[(1)]
\item We only admit rule instances  where  is not closed.
\item \TRFE can only be applied to a disequation
   if there is no variable  such that .
\end{enumerate}
The set of \emph{refutable branches} is
defined inductively: if  is
an instance of a rule of~ and  are
refutable, then  is refutable.
Note that the base cases of this inductive definition are when .
The rules where  may be  are  and .
Figure~\ref{fig:refutation} shows a refutation
in~.

\begin{figure}[t]
  
\caption{Tableau refuting 
  where  and }
\label{fig:refutation}
\end{figure}

A remark on the names of the rules: \TRMat is called
the mating rule, \TRDec the decomposition rule, \TRCon
the confrontation rule, \TRBQ the Boolean equality rule, \TRBE
the Boolean extensionality rule, \TRFQ the functional equality
rule, and \TRFE the functional extensionality rule.

\begin{prop}[Soundness] \label{prop:ts-sound}
  Every refutable branch is unsatisfiable.
\end{prop}

\begin{proof}
  Let  be an instance of a rule of 
  such that  is satisfiable.  It suffices to show
  that one of the branches  is satisfiable.
  Straightforward.
\end{proof}

We will show that the tableau calculus  is
\emph{complete}, that is, can refute every finite
unsatisfiable branch.  The rules of  are designed
such that we obtain a strong completeness result.
For practical purposes one can of course include rules 
that close branches including 
or .

To avoid redundancy, our definition of STT only covers the logical
constants  and .
Adding further constants such as , , ,
 and  is straightforward.
In fact, all logical constants can be expressed with the identities
~\cite{AndrewsBook}.  We have included  since we need
it for the formulation of the tableau calculus.  The refutation
in Figure~\ref{fig:refutationneg}
suggests that the elimination of  is not straightforward.


\begin{figure}[t]
  
\caption{Tableau refuting  where }
\label{fig:refutationneg}
\end{figure}

\section{Evidence}

A branch  is \emph{evident} if it satisfies the
\emph{evidence conditions} in
Figure~\ref{fig:evidence}.  The evidence conditions
correspond to the tableau rules and are designed such
that every branch that is closed under the
tableau rules is either closed or evident.  We will show that evident
branches are satisfiable.

\begin{figure}[t]
  \renewcommand{\arraystretch}{1.4}
  \begin{tabular}{c>{\raggedright}p{120mm}}
\emph{\EDN}&If  is in , then  is in .
    \tabularnewline
\emph{\EBQ}&If  is in , 
    then either  and  are in  or  and  are in .
    \tabularnewline
    \emph{\EBE}&If  is in , 
    then either  and  are in  or  and  are in .
    \tabularnewline
    \emph{\EFQ}&If  is in , 
    then  is in  for every normal .
    \tabularnewline
\emph{\EFE}&If  is in , 
    then  is in  for some variable .
    \tabularnewline
    \emph{\EMat}&If  and  are in ,\ignore{\\}
    then  and  is in  for some .
    Note that if , this means if , then .
    \tabularnewline
\emph{\EDec}&If  is in ,\ignore{\\}
    then  and  is in  for some .
    Note that if , this means .
    \tabularnewline
    \emph{\ECon}&If  and   are in ,\\
    then either  and  are in  
    or  and  are in .
  \end{tabular}
  \caption{Evidence conditions}
  \label{fig:evidence}
\end{figure}

A branch  is \emph{complete} if for every normal
formula  either  or  is in .  The
cut-freeness of  shows in the fact that there are
many evident sets that are not complete.  For instance,
 is an incomplete
evident branch if .













\subsection{Discriminants}

Given an evident branch , we will construct a value
system whose admissible logical interpretations are
models of .  We start by defining the values for the
sorts, which we call discriminants.
Discriminants first appeared in~\cite{BrownSmolkaBasic}.

Let  be a fixed evident branch in the following. 
A term  is \emph{-discriminating in }
if there
is some term  such that either  or
 is in .
An \emph{-discriminant} is a maximal set  of
discriminating terms of type  such that there
is no disequation  such that .
We write \emph{} if  contains the
disequation  or~.

In~\cite{Brown2004a} a sort was interpreted using
maximally compatible sets of terms of the sort (where  and 
are compatible unless ).
The idea is that the set  insists that certain terms cannot be
equal, but leaves open that other terms ultimately may be identified
by the interpretation.  In particular, two compatible terms  and  may be identified by
taking a maximally compatible set of terms containing both  and  as a value.
It is not difficult to see that a maximally compatible set is simply the union of an -discriminant
with all terms of sort  that are not -discriminating.
We now find that it is clearer to use -discriminants as values instead of maximally compatible sets.
In particular, it is easier to count the number of -discriminants, as we now show.


\begin{exa}
  Suppose  and
  .  There are~3
  \text{-discriminants}: , ,
  .
\end{exa}


\begin{exa}
  Suppose  where
  the  and  are pairwise distinct variables.
  Then  is evident and there are uncountably many
  \text{-discriminants}.
\end{exa}

\begin{prop}
  \label{prop-finite-discs}
  If  contains exactly  disequations at ,
  then there are at most~ -discriminants.
  If  contains no disequation at , then
   is the only -discriminant.
\end{prop}

\begin{prop}
  \label{prop-diff-discs}
  Let  and  be different discriminants.
  Then:
  \begin{enumerate}[\em(1)]
  \item  and  are separated by a disequation
    in , that is, there exist terms  and
     such that .
  \item  and  are not connected by an
    equation in , that is, there exist no terms
     and  such that .
  \end{enumerate}
\end{prop}

\begin{proof}
  The first claim follows by contradiction.  Suppose
  there are no terms  and  such that
  .  Let .  Then  since 
  is a maximal set of discriminating terms.  Thus
   and hence  since  is maximal.
  Contradiction.

  The second claim also follows by contradiction.
  Suppose there is an equation  such
  that  and .  By the first
  claim we have terms  and 
  such that .  By \ECon we have  or .  Contradiction since 
  and~ are discriminants.
\end{proof}

\subsection{Compatibility}\label{sec:compat}

For our proofs we need an auxiliary notion for evident
branches that we call compatibility.  Let  be a
fixed evident branch in the following.  We define
relations
 by
induction on types:

We say that  and  are \emph{compatible} if
.

\begin{lem}[Compatibility]
  \label{lem-compatibility}~\\
  For  and all terms , , ,
   of type~:
  \begin{enumerate}[\em(1)]
  \item We do not have both  and .
  \item Either 
    or  for some
    .
  \end{enumerate}
\end{lem}

\begin{proof}
  By induction on .  Case analysis.

  .  Claim~(1) follows with \EBE.
  Claim~(2) follows with N3 and \EMat.

  .  Claim~(1) is trivial.  Claim~(2)
  follows with N3 and \EDec.

  .  We show~(1) by contradiction.
  Suppose  and .
  By \EFE  for some
  variable .  By inductive hypothesis~(2) we have
  .  Hence .
  Contradiction by inductive hypothesis~(1) and N2.

  To show~(2), suppose .  Then there exist terms such that
   and .  By inductive hypothesis~(1) we know
  that  does not hold.  Hence
   for some 
  by inductive hypothesis~(2).
\end{proof}



\section{Model Existence}
\label{sec:model-existence}

Let  be a fixed evident branch.  We define a value
system~ for :

Note that N1 ensures the property  iff
.

\begin{prop}
  \label{prop-mod-ex-o}
  For all variables , either  and 
  or  and .
  In particular, .
\end{prop}

\begin{proof}
  By  either  or .
  If , then  and  by N3 and .
  If , then  and  by N3.
\end{proof}

\begin{lem}
  \label{lemma-adm-model}
  A logical assignment is a model of  if it is
  admissible for .
\end{lem}

\begin{proof}
  Let  be a logical assignment that is
  admissible for , and let .  By
  Theorem~\ref{theo-admissible-interpretations} we know
  that  is an interpretation and that
  .  Thus  since
  .  Hence .
\end{proof}

It remains to show that  admits logical
interpretations.  First we show that all sets
 are nonempty.  To do so, we prove that
compatible equi-typed terms have a common value.  A set
 of equi-typed terms is \emph{compatible} if  for all terms .  We write
\emph{} if ,
, and  for every~.

\begin{lem}[Common Value]
  \label{lem-common-value}
  Let .  Then  is compatible if
  and only if there exists a value~ such that
  .
\end{lem}

\begin{proof}
  By induction on .  

  \br .  Let  be
  compatible.  Then there exists an
  -discriminant  that contains all the
  -discriminating terms in .  
  Clearly, . 

  \br . 
  Suppose  and  is not compatible.  Then there
  are terms  such that
  .  Thus  and
   cannot be both in .  This contradicts
   since  and  are
  discriminating.

  \br .  By contraposition.
  Suppose  and . Then there are
  terms  such that .
  Thus .  Hence  is not compatible.

  \br .  By contraposition.
  Suppose  for .  Then
   without loss of generality.
  Hence  and .  Thus 
  and .

  \br .  Let  be
  compatible.  We define  for every value 
  and show that  is compatible.  Let  and .  It suffices to show
  .  By the inductive hypothesis
  .
  Since  is compatible, .
  Hence .


  By the inductive hypothesis we now know that for
  every  there is a  such
  that .  Hence there is a function
   such that  for
  every .  Thus .

  \br .  Let
   and .  We show
  .  Let .  It suffices
  to show .  By the inductive hypothesis
   for some value .  Hence
  .  Thus  by
  the inductive hypothesis.
\end{proof}

\begin{lem}[Admissibility]
  \label{lemma-inhabitation}
  For every variable  there is some 
  such that .  In particular,
   is a nonempty set for every type
  .
\end{lem}

\begin{proof}
  Let  be a variable.  By
  Lemma~\ref{lem-compatibility}\,(2) we know .
  Hence  is compatible.  By
  Lemma~\ref{lem-common-value} there exists a value 
  such that .  The claim follows
  since  by definition of .
\end{proof}

\begin{lem}[Functionality]
  \label{lem-functionality}
  If , , and
   , then .
\end{lem}

\begin{proof}
  By contradiction and induction on .  Assume
  , , , and .  Case analysis.

  .  By  either  or .  Hence  and  are either both
   or both .  Contradiction.

  .  Since , there must be
  discriminating terms of type .  Since
  , we know by N3 and \ECon that  and
   are normal and discriminating.  Hence 
  and .  Contradiction by
  Proposition~\ref{prop-diff-discs}\,(2).

  .  Since , there is some
   such that .
  By the
  definition of  and
  Lemma~\ref{prop-norm-poss-value} there is a normal
  term  such that .
  Hence  and .  By
  Proposition~\ref{prop-norm-poss-value}  and .
  By  the
  equation  is in~.
  Contradiction by the inductive hypothesis.
\end{proof}

We now define the canonical interpretations for the logical constants:


\begin{lem}[Logical Constants]
  \label{lem-log-constants}
   for every logical constant .
\end{lem}

\begin{proof}
  We show  by contradiction.
  Let  and assume . Case analysis.
  \begin{enumerate}[]
  \item .  Then  and .  Contradiction
    by N3 and~.
  \item .  Then  and .
    Contradiction by N3.
  \end{enumerate}
Finally, we show  by
  contradiction.  Let ,
  , and
  .  Case analysis.
  \begin{enumerate}[]
  \item .  Then  by N3 and
    .  Thus  by
    Lemma~\ref{lem-common-value}.  Contradiction by
    Lemma~\ref{lem-compatibility}\,(1).
  \item .  Then  by
    N3. Hence  by
    Proposition~\ref{prop-norm-poss-value}
    and Lemma~\ref{lem-functionality}.  Contradiction.\qedhere
  \end{enumerate}
\end{proof}

\begin{thm}[Model Existence]
  \label{theo-model-exist}
  Every evident branch is satisfiable.  Moreover, every
  complete evident branch has a surjective model, and
  every finite evident branch has a finite model.
\end{thm}

\begin{proof}
  Let  be an evident branch and  be the
  value system for .  By
  Proposition~\ref{prop-mod-ex-o},
  Lemma~\ref{lemma-inhabitation}, and
  Lemma~\ref{lem-log-constants} we have a logical
  interpretation  that is admissible for
  .  By Lemma~\ref{lemma-adm-model}  is a
  model of .  

  Let  be complete.  By
  Theorem~\ref{theo-admissible-interpretations} we know
  that  is surjective if  is functional.
  Let  and .  We show
  .  By Proposition~\ref{prop-norm-poss-value} we
  can assume that  is normal.  Thus  is
  normal by N3. Since  is a model of , we know
  that the formula  is not in .  Since 
  is complete, we know that  is
  in~.  By Lemma~\ref{lem-functionality} we have
  .

  If  is finite,  is finite
  by Proposition~\ref{prop-finite-discs}.
\end{proof}

\section{Abstract Consistency}

We now extend the model existence result for evident
branches to abstract consistency classes, following the
corresponding development for first-order
logic~\cite{SmullyanBook}.
Notions of abstract consistency for simple type theory have
been previously considered in~\cite{Andrews71,Kohlhase93a,KohlhaseTableaux1995,Benzmuller99a,BenzKoh98,BBK04,BBKweb04,Brown2004a,BrownARHO}.
Equality was treated as Leibniz equality in~\cite{Andrews71}.
Abstract consistency conditions for
primitive equality corresponding to reflexivity and substutivity properties
were given by Benzm\"uller in~\cite{Benzmuller99a,Benzmuller99b}. 
A primitive identity predicate  was considered in~\cite{BBK04}
but the abstract consistency conditions for  essentially reduced it
to Leibniz equality.  
Conditions for  analogous to  first appeared in~\cite{Brown2004a}.

An \emph{abstract consistency class} is a set 
of branches such that every branch 
satisfies the conditions in
Figure~\ref{fig:abs-consistency}.  An abstract
consistency class  is \emph{complete} if for
every branch  and every normal formula 
either  or  is
in~.  
The completeness condition was called ``saturation'' in~\cite{BBK04}.
As discussed in~\cite{BBK2009} and the conclusion of~\cite{BBK04},
the condition corresponds to having a cut rule in a calculus.
In~\cite{BBKweb04} conditions analogous to  and  appear (using Leibniz equality)
and a model existence theorem is proven with these conditions replacing saturation.
The use of Leibniz equality means that there was still not a cut-free treatment of equality in~\cite{BBKweb04}.


\begin{figure}[tp]
  \renewcommand{\arraystretch}{1.4}
  \begin{tabular}{c>{\raggedright}p{120mm}}
\emph{\ADN}&If  is in , 
    then  is in .
\tabularnewline
    \emph{\ABQ}&If  is in , 
    then either 
    or  is in .
    \tabularnewline
    \emph{\ABE}&If  is in , 
    then either 
    or  is in .
    \tabularnewline
    \emph{\AFQ}&If  is in ,\\ 
    then  is in  for every normal~.
    \tabularnewline
    \emph{\AFE}&If  is in , 
    then  is in  for some variable .
    \tabularnewline
    \emph{\AMat}&If  is in  and  is in ,\\
    then  and  is in  for some .
    \tabularnewline
\emph{\ADec}&If  is in ,
    then  and  is in  for some .
    \tabularnewline
    \emph{\ACon}&If  and   are in ,\\
    then either 
    or  is in .
  \end{tabular}
  \caption{Abstract consistency conditions (must hold for every )}
  \label{fig:abs-consistency}
\end{figure}

\begin{prop}
  Let  be a branch.  Then  is evident if and only
  if  is an abstract consistency class.
  Moreover,  is a complete evident branch if and
  only if  is a complete abstract consistency
  class.
\end{prop}


\begin{lem}[Extension Lemma]
  \label{lem:extension}
  Let  be an abstract consistency class and
  .  Then there exists an evident branch
   such that .  Moreover, if 
  is complete, a complete evident branch  exists
  such that .
\end{lem}

\begin{proof}
  Let  be an enumeration of all
  normal formulas.  We construct a sequence
   of
  branches such that every .  Let .  We define  by cases.  If there is
  no  such that , then let .  Otherwise, choose
  some  such that
  .  We consider two
  subcases.
  \begin{enumerate}[(1)]
\item If  is of the form ,
    then choose  to be
     for some
    variable .  This is possible since 
    satisfies .
  \item If  is not of this form, then let
     be .
  \end{enumerate}
  Let . 
We show that  satisfies the evidence conditions.
\begin{enumerate}[\EMat]
\item[{\EDN}] Assume  is in .
  Let  be such that .  Let
   be such that  is in .
  By ,
  .  Since
  , we have .
\item[{\EMat}] Assume  and  are in .  For each
  , let  be such that 
  is .  Let  be such
  that  and  are in .
  By   and there is some  such
  that .  Since
  , we have .
\item[{\EDec}] Similar to   \item[{\ECon}] Assume  and  are in .  Let  be such that
   is ,  is ,  is
   and  is .  Let 
  be such that  and  are in
  .  By  either  or  is in .
  Assume  is in .
  Since , we have .  Since , we have .  Next assume  is in .
  By a similar argument we know  and  must be in .
\item[{\EBQ}] Assume  is in .  Let
   be such that , , 
  and .  Let  be such that
   is in .  By  either
   or  is in
  .  Assume  is in
  .  Since , we have .  Since
  , we
  have .  Next assume  is in .  Since , we have .  Since , we have .
\item[{\EBE}] Similar to  \item[{\EFQ}] Assume  is in  and
   is normal.  Let  be such that
   is .
  Let  be
  such that  is in .
  By  we know  is
  in .  Hence  is in
   and also in .
\item[{\EFE}] Assume  is in
  .  Let  be such that  is
  .  Let  be such that
   is in .  Since
  , there is some
  variable  such that  is
  in .
\end{enumerate}
It remains to show that~ is complete if  is
complete.  Let  be complete and  be a normal
formula.  We show that  or  is in .
Let ,  be such that  and .
We consider . (The case  is symmetric.)  If
, we have .  If , then  is not in .
Hence  is in  since
 is complete.  Hence .
\end{proof}

\begin{thm}[Model Existence]
  \label{theo-acc-model-existence}
  Every member of an abstract consistency class has a
  model, which is surjective if the consistency class
  is complete.
\end{thm}

\begin{proof}
  Let  where  is an abstract
  consistency class.  By Lemma~\ref{lem:extension} we
  have an evident set  such that , where
   is complete if  is complete.  The claim
  follows with Theorem~\ref{theo-model-exist}.
\end{proof}


\section{Completeness}
\label{sec:completeness}

It is now straightforward to prove the completeness of
the tableau calculus . 
Let~\emph{} be the
set of all finite branches that are not refutable.



\begin{lem}
  \label{lem:acc-completeness}
   is an abstract consistency class.
\end{lem}

\proof
    We have to show that  satisfies the
    abstract consistency conditions.
\begin{enumerate}[\AMat]
\item[{\ADN}] Assume  is in  and
  .  Then we can refute 
  using .
\item[{\AMat}] Assume  and  for all .
  Then we can refute  using \TRMat.
\item[{\ADec}] Assume  is in  and 
  for all .
  Then we can refute  using \TRDec.
\item[{\ACon}] Assume  and
   are in  but  and  are not in
  .  Then we can refute  using \TRCon.
\item[{\ABQ}] Assume  is in ,
   and .
  Then we can refute  using
  \TRBQ.
\item[{\ABE}] Assume  is in ,
   and .  Then we can refute  using
  \TRBE.
\item[{\AFQ}] Let .
  Suppose 
  for some normal .  Then
   is refutable and so
   is refutable by .
\item[{\AFE}] Let .  Suppose
   for
  every variable .  Then
   is refutable for
  every .  Hence  is refutable using~\TRFE
  and the finiteness of .  Contradiction.\qed
\end{enumerate}

\begin{thm}[Completeness]
  \label{thm:completeness}
  Every unsatisfiable finite branch is refutable.
\end{thm}

\begin{proof}
  By contradiction.  Let  be an unsatisfiable finite
  branch that is not refutable.  Then  and
  hence  is satisfiable by
  Lemma~\ref{lem:acc-completeness} and
  Theorem~\ref{theo-acc-model-existence}.  Contradiction.
\end{proof}

\section{Compactness and Countable Models}

It is known~\cite{Henkin50,AndrewsBook} that
simple type theory is compact and has the
countable-model property.  We use the opportunity and
show how these properties follow with the results we
already have.  It is only for the existence of countable
models that we make use of complete evident sets and
complete abstract consistency classes.

A branch  is \emph{sufficiently pure} if for every
type  there are infinitely many variables of
type  that do not occur free in the formulas of .
Let  be the set of all sufficiently pure
branches  such that every finite subset of  is
satisfiable.  We write \emph{} for the
finite subset relation.

\begin{lem}
  \label{lem-aux-compactness}
  Let  and  be finite branches
  such that  for all
  .  Then there exists a finite
  branch  such that  is
  unsatisfiable for all .
\end{lem}

\begin{proof}
  By the assumption, we have for every  a finite and unsatisfiable branch .  The branch  satisfies the claim.
\end{proof}

\begin{lem}
  \label{lem:acc-compactness}
   is a complete abstract consistency
  class.
\end{lem}

\begin{proof}
  We verify the abstract consistency conditions using
  Lemma~\ref{lem-aux-compactness} tacitly.
\begin{enumerate}[\AMat]
\item[{\ADN}] Assume  is in  and
  .  There is some
   such that  is
  unsatisfiable.  There is a model of
  .
  This is also a model of
  , contradicting our choice of .
\item[{\AMat}] Assume  and  are in  and  for all .
  There is some  such that
   is unsatisfiable for all
  .  There is a model  of
  .
  Since , we must have 
  for some  (and in particular  must not be ).  Thus  models
  , contradicting our choice
  of~.
\item[{\ADec}] Similar to  \item[{\ACon}] Assume  and 
  are in ,  and .  There is some 
  such that  and
   are unsatisfiable.  There
  is a model  of .  Since 
  and , we either have
   and  or  and
  .  Hence  models
  either  or , contradicting our choice of .
\item[{\ABQ}] Assume  is in ,
   and .  There is some  such that  and  are unsatisfiable.  There is a model of
  .  This is also a
  model of  or .
\item[{\ABE}] Assume  is in ,
   and .  There is some  such that  and  are unsatisfiable.  There is a model of
  .  This is also a
  model of  or .
\item[{\AFQ}] Assume  is in 
  but  is not in
   for some normal .
  There is some  such that
   is unsatisfiable.  There
  is a model  of .
  Since , we know
   using N4.  Hence
   is a model of , a
  contradiction.  
\item[{\AFE}] Assume  is in .
  Since  is sufficiently pure, there is a variable
   which does not occur in .  Assume
  .  There
  is some  such that
   is unsatisfiable.
  There is a model  of .  Since
  , there must be some
   such that
  .  Since  does not
  occur free in , we know
   and
   is a model of .  Since
  
  and  by N4, we
  conclude  is a model of
  , contradicting our
  choice of .
\end{enumerate}
We show the completeness of 
by contradiction.  Let  and  be a
normal formula such that  and
 are not in .  Then
there exists  such that
 and  are
unsatisfiable.  Contradiction since~ is
satisfiable.
\end{proof}

\begin{thm}\label{thm:compactness-ls}
  Let  be a branch such that every finite subset of
   is satisfiable.  Then  has a countable model.
\end{thm}

\begin{proof}
  Without loss of generality we assume  is
  sufficiently pure.  Then .  Hence 
  has a countable model by
  Lemma~\ref{lem:acc-compactness} and
  Theorem~\ref{theo-acc-model-existence}.
\end{proof}

\section{EFO Fragment}



We now turn to the EFO fragment of STT as first reported in~\cite{BrownSmolkaEFO}.
The EFO fragment contains first-order logic
and enjoys the usual properties of first-order logic.
We will show completeness and compactness with respect to standard models.
We will also prove that countable models for evident EFO sets exist.

Suppose STT were given with , ,  and .
Then the natural definition of EFO would restrict
 and  to the case where  is a base type.
To avoid redundancy our definition of EFO will also exclude the case where .

Our definition of EFO assumes the logical constants , ,
 and  where
 ranges over sorts.  We call these constants \emph{EFO constants}.
For an assignment to be logical we require that it interprets the logical
constants as usual.  In particular,  must be
the function returning  iff its argument is the constant  function.

We say a term is \emph{EFO} if it only contains the logical constants , ,  and .
Let \emph{} be the set of EFO terms of type .
A term is \emph{quasi-EFO} if it is EFO or of the form  where  are EFO
and  is a type. A branch  is \emph{EFO} if every member of  is quasi-EFO.
The example tableau shown in Figure~\ref{fig:refutation} only contains EFO branches.

\begin{figure}
\begin{mathpar}
  \inferrule*[left=\emph{\TRFDN}~]{\neg\neg s}{s}
  \and
  \inferrule*[left=\emph{\TRFBE}~]{s\neq_ot}{s\,,\,\neg t~\mid~\neg s\,,\,t}
  \and
  \inferrule*[left=\emph{\TRFImp}~]{s\limplies t}{\neg s\mid t}
  \and
  \inferrule*[left=\emph{\TRFImpN}~]{\neg(s\limplies t)}{s\,,\,\neg t}
  \\
  \inferrule*[left=\emph{\TRFMat}~,right=~] {xs_1\dots
    s_n\,,\,\neg xt_1\dots t_n} {s_1\neq t_1\mid\dots\mid s_n\neq t_n}
  \and
  \inferrule*[left=\emph{\TRFDec}~,right=~] {xs_1\dots
    s_n\neq_\alpha xt_1\dots t_n} {s_1\neq t_1\mid\dots\mid s_n\neq t_n}
  \\
  \inferrule*[left=\emph{\TRFFE}~,right=~ fresh]
  {s\neq_{\sigma\tau} t}{\nf{sx}\neq\nf{tx}}
  \and
  \inferrule*[left=\emph{\TRFCon}~]
  {s=_\alpha t\,,\,u\neq_\alpha v}
  {s\neq u\,,\,t\neq u\mid s\neq v\,,\,t\neq v}
  \\
\inferrule*[left=\emph{\TRFall}~,right=~ normal]
  {\forall_{\!\alpha} s}{\nf{su}}
  \and
  \inferrule*[left=\emph{\TRFalln}~,right=~ fresh]
  {\neg\forall_{\!\alpha} s}{\neg\nf{sx}}
\end{mathpar}
\caption{Tableau rules for EFO}
\label{fig:rulesefo}
\end{figure}
The tableau rules in Figure~\ref{fig:rulesefo} define a tableau calculus 
for EFO branches
up to restrictions on applicability given in Section~\ref{sec:efo-complete}.
After showing a model existence theorem,
we will precisely define the tableau calculus  
and prove it is complete for EFO branches.
The completeness result will be with respect to standard models.
For some fragments of EFO
the tableau calculus  will terminate, yielding decidability results.

\section{EFO Evidence and Compatibility}

We say an EFO branch  is evident if it satisfies the evidence conditions in Figure~\ref{fig:evidence}
and the following additional conditions.\\
  \renewcommand{\arraystretch}{1.4}
  \begin{tabular}{c>{\raggedright}p{120mm}}
    \emph{\EImp}&If  is in , then  or  is in .
    \tabularnewline
    \emph{\EImpN}&If  is in , then  and  are in .
    \tabularnewline
    \emph{\Eall}&If  is in , 
    then  is in  for every -discriminating  in .
    \tabularnewline
    \emph{\Ealld}&If  is in ,
    then  is in  for some normal EFO term .  \tabularnewline
    \emph{\Ealln}&If  is in , 
    then  is in  for some variable .
  \end{tabular}\
  \N{\mcd o}& = \{0,1\} \\
  \N{\mcd\alpha}& = \{a | a  {\mbox{ is an -discriminant}}\} \\
  \N{\mcd(\sigma\tau)}& = \mcd\sigma \to \mcd\tau

  \N{s \canbe_o 0}&\iffdef s\in\Wff_o \text{ and } \nf{s}\notin E\\
  \N{s \canbe_o 1}&\iffdef s\in\Wff_o \text{ and } \neg\nf{s}\notin E\\
  \N{s\canbe_\alpha a}\!&\iffdef 
  s\in\Wff_\alpha,~a \text{ is an -discriminant, and } 
  \nf{s}\in a \text{ if } \nf{s} \text{ is discriminating}\\
  \N{\canbe_{\sigma\tau}}&\eqdef\mset{(s,f)\in\Wff_{\sigma\tau}\times(\mcd\sigma\to\mcd\tau)}
  {\forall(t,a)\in\canbe_\sigma\col~(st,fa)\in\canbe_\tau}

  \N{\mcl({\limplies}})&\eqdef\lam{a{\in}\mcd o}{~\lam{b{\in}\mcd o}{~\Cond{a{=}1}b1}}\\
  \N{\mcl({\forall_{\!\alpha}})}&\eqdef\lam{f{\in}\mcd\alpha\to\mcd o}{~\Cond{f = (\lam{x\in\mcd\alpha}{~1})}10}
2mm]
We say an abstract consistency class  is \emph{EFO-complete}
if for all  and all normal  either  or .

Let~\emph{} be the
set of all finite EFO branches that are not refutable.
\begin{lem}
  \label{lem:acc-efo-completeness}
   is an abstract consistency class.
\end{lem}
\proof  Similar to Lemma~\ref{lem:acc-completeness}.
We only check the new conditions: , , ,
   and .
\begin{enumerate}[\AImpN]
\item[{\AImp}] Let .
  Suppose  and .
  By  we have  is refutable.  Contradiction.
\item[{\AImpN}] If  and ,
  then  using the rule .
\item[{\Aall}] Let .
  Suppose  for some normal -discriminating .
Then  is refutable.
  Hence  can be refuted using \TRFall (with the restriction).
\item[{\Aalld}] Let .
  If there is some -discriminating term, then  follows from .
  Assume there are no -discriminating terms
  and  for all normal .
  In particular,  for all normal .
  Choose a variable  occurring free in  (or any variable 
  if none occurs free in ).
  Since ,  is refutable.
  Using  (with the restriction),  is refutable.  Contradiction. \item[{\Aalln}] Let .  Suppose
   for every variable .
  Let  be fresh for .
  Then  is refutable
  and so  can be refuted using .\qed
\end{enumerate}

\begin{lem}[EFO Extension Lemma]
  \label{lem:efo-extension}
  Let  be an abstract consistency class and
   be an EFO branch.  Then there exists an evident EFO branch
   such that .  Moreover, if 
  is EFO-complete, a EFO-complete evident EFO branch  exists
  such that .
\end{lem}
\begin{proof}  Similar to Lemma~\ref{lem:extension}.  Instead of using an enumeration of all normal formulas,
  we use an enumeration of all normal EFO formulas.  The proof goes through when one makes
  some obvious modifications.
\end{proof}

\begin{thm}[EFO Completeness]
  \label{thm:efo-completeness}
  Every finite EFO branch is either refutable
  or has a standard model.
\end{thm}
\begin{proof}
  Follows from Lemma~\ref{lem:acc-efo-completeness}, Lemma~\ref{lem:efo-extension} and
  Theorem~\ref{thm:efo-model-exist}.
\end{proof}

We now turn to compactness and the existence of countable models.
Let  be the set of all sufficiently pure
EFO branches  such that every finite subset of  has a standard model.

\begin{lem}
  \label{lem:acc-efo-compactness}
   is an EFO-complete abstract consistency
  class.
\end{lem}
\begin{proof}  Similar to Lemma~\ref{lem:acc-compactness}.
\end{proof}

\begin{thm}\label{thm:efo-compactness-ls}
  Let  be a branch such that every finite subset of
   has a standard model.  Then  has a standard model where  is countable for all sorts .
\end{thm}
\begin{proof}  Similar to Theorem~\ref{thm:compactness-ls}.
\end{proof}

\begin{cor}\label{cor:efo-stdsat}
  Let  be a satisfiable EFO branch.
  Then  has a standard model where  is countable for all sorts .
\end{cor}
\begin{proof}
  To apply Theorem~\ref{thm:efo-compactness-ls}
  we only need to show every subset of  has a standard model.
  Let  be a finite subset of .
  Since  is satisfiable,  is not refutable by Proposition~\ref{prop-e-soundness}.
  By Theorem~\ref{thm:efo-completeness}  has a standard model.
\end{proof}

\section{Decidable EFO Fragments}

Given the completeness result for the tableau calculus 
(Theorem~\ref{thm:efo-completeness}),
we can show a fragment of EFO is decidable by proving 
terminates on branches in the fragment.  We will use this technique to argue
decidability of three fragments:
\begin{enumerate}[]
\item The \emph{-free fragment}, which is EFO without -abstraction.
\item The \emph{pure fragment}, which consists of disequations  where no name used in  and  has a type that contains .
\item The \emph{BSR fragment (Bernays-Sch\"onfinkel-Ramsey)}, which consists of relational first-order -formulas with equality.
\end{enumerate}

\begin{prop}[Verification Soundness]
  \label{prop-verif-soundness}
  Let  be a finite EFO branch that is not closed and
  cannot be extended with .  Then 
  is evident and has a finite model.
\end{prop}
\begin{proof}
  Checking  is evident is easy.  The existence of a finite model follows from Theorem~\ref{thm:efo-model-exist}.
\end{proof}

We now have a general method for proving decidability of satisfiability
within a fragment.

\begin{prop}
  Let  terminate on a set  of finite
  EFO branches.  Then satisfiability of the branches in
   is decidable and every satisfiable branch in
   has a finite model.
\end{prop}

\begin{proof}
  Follows with Propositions~\ref{prop-e-soundness}
  and~\ref{prop-verif-soundness} and
  Theorem~\ref{thm:efo-model-exist}.
\end{proof}

The decision procedure depends on the normalization
operator employed with .  A normalization
operator that yields -normal forms provides for
all termination results proven in this section.  Note
that the tableau calculus applies the normalization
operator only to applications  where  and 
are both normal and  has type  (for some sort ) if it is not a
variable.  Hence at most one -reduction is
needed for normalization if  and  are
-normal.  Moreover, no -renaming is
needed if the bound variables are chosen differently
from the free variables.  For clarity, we continue to
work with an abstract normalization operator and state
further conditions as they are needed.

\subsection{Lambda-Free Formulas}

In~\cite{BrownSmolkaBasic} we study lambda- and
quantifier-free EFO and show that the concomitant
subsystem of  terminates on finite branches.  The
result extends to lambda-free branches containing
quantifiers (e.g., ).

\begin{prop}[Lambda-Free Termination]
  Let the normalization operator satisfy\lmcs{\linebreak}
   for
  every lambda-free EFO term .  Then 
  terminates on finite lambda-free branches.
\end{prop}

\begin{proof}
  An application of \TRFFE disables a disequation
   and introduces new subterms
  as follows: a variable , two terms
   and , and the formula .  The types of the new
  subterms are smaller than the type of  and ,
  and the new subterms introduced by the other rules
  always have type  or .
  For each branch,
  consider the multiset of types
   where
   are subterms of formulas on the branch but
  there is no  such that
   is on the branch.
  By considering the multiset ordering, we see that no derivation can
  employ \TRFFE infinitely often.

  Let  be a possibly infinite
  derivation that issues from a finite lambda-free
  branch and does not employ \TRFFE.  It suffices to
  show that the derivation is finite.  
  Consider the new variables  which may be introduced
  by the  and  rules.
  For each subterm  at most one new variable will
  be introduced by these rules.
  Since the branches are -free, no rule creates new subterms of the form .
  Hence only finitely many new variables of type 
  are introduced.
  Let  be a branch in the sequence such that no new
  variables are introduced after this point.  
  Let  be the set of all subterms of type  of the formulas in .
  Let  be the union of the three finite sets 
  , 
  and .
  Every branch  with 
  can only contain members of .  Hence the derivation is finite.
\end{proof}

\subsection{Pure Disequations}

A type is \emph{pure} if it does not contain .  A
term is \emph{pure} if the type of every name occurring
in it (bound or unbound) is pure.  An equation  or
disequation  is \emph{pure} if  and  are
pure terms.

We add a new property of normalization in order to prove termination.
\begin{description}
\item[{N5}] 
  The least relation  on terms such that
  \begin{enumerate}[(1)]
  \item  \ if 
    
  \item  \ if  and 
  \end{enumerate}
  terminates on normal terms.
\end{description}

\begin{prop}[Pure Termination]
  Let the normalization operator satisfy N5.  Then
   terminates on finite branches containing only
  pure disequations.
\end{prop}

\begin{proof}
  Let  be a possibly infinite
  derivation that issues from a finite branch
  containing only pure disequations.  Then no other
  rules but possibly \TRFDec and \TRFFE apply
  and thus no  contains a formula that is not
  a pure disequation (using S5).  Using N5
  it follows that the derivation is finite.
\end{proof}

\subsection{Bernays-Sch\"onfinkel-Ramsey Formulas}

It is well-known that the satisfiability of Bernays-Sch\"onfinkel-Ramsey
formulas (relational first-order -prenex
formulas with equality) is decidable and the fragment has the
finite model property~\cite{BGG97}.  We reobtain this
result by showing that  terminates for the
respective fragment.  We call a type \emph{BSR} if it
is  or  or has the form .
We call an EFO formula  \emph{BSR} if it satisfies
two conditions:
\begin{enumerate}
\item The type of every variable that occurs in  is
  BSR.
\item  does not occur below a negation or an implication in
  .
\end{enumerate}
Note that every subterm of a BSR formula that has type 
is a variable.
For simplicity, our BSR formulas don't provide for
outer existential quantification.  We need one more
condition for the normalization operator:
\begin{description}
\item[{N6}] If  is BSR and ,
  then  is BSR.
\end{description}

\begin{prop}[BSR Termination]
  Let the normalization operator satisfy N5 and~N6.
  Then  terminates on finite branches containing
  only BSR formulas.
\end{prop}

\begin{proof}
  Let  be a possibly infinite
  derivation that issues from a finite branch
  containing only BSR formulas.  Then \TRFalln and
  \TRFFE are not applicable and all  contain only
  BSR formulas (using N6).  Furthermore, for each sort 
  used in  at most one new
  variable of sort  is introduced (by the restriction on  in ).
  Since all terms of sort  are variables, there is only a finite supply.
  Using N5 it follows that the derivation is finite.
\end{proof}

\section{Conclusion}

In this paper we have studied a complete cut-free tableau calculus
for simple type theory with primitive equality (STT).  For the first-order
fragment of STT (EFO) we have shown that the tableau system is complete with respect
to standard models.  Our development demonstrates
that first-order logic can be treated naturally as a fragment of STT.

For the EFO fragment we gave an interesting restriction on instantiations.
In particular, one can restrict most instantiations of sort  to be -discriminating terms.
Such a restriction can also be included in the tableau calculus for STT without sacrificing
completeness.  Confining instantiations to -discriminating terms
is a serious restriction since each branch has only finitely many such terms.

Automated theorem proving would be a natural application of the tableau calculi presented here.
When designing a search procedure one often starts with a complete ground calculus (like our
tableau calculi  and ), then extends this to include metavariables to be instantiated
during search, and finally proves a lifting lemma showing the tableaux with metavariables can
simulate a refutation in the ground calculus.
A design principle of our calculi  and  is that none of the
rules look deeply into the structure of any formula on the branch.
For example, consider the mating rule
\begin{mathpar}
  \inferrule*[right=~] {xs_1\dots
    s_n\,,\,\neg xt_1\dots t_n} {s_1\neq t_1\mid\dots\mid s_n\neq t_n}
\end{mathpar}
To check if this rule applies to two formulas  on the branch ,
one only needs to check if  has a variable  at the head
and if  is the negation of a formula with  at the head.
When trying to prove a lifting lemma, we would need to show how the 
calculus with metavariables could simulate the mating rule.
This may involve partially instantiating metavariables to expose
the head  in the counterpart to  or
the negation and the head  in the counterpart to .
On the other hand, suppose our ground calculus included a rule to close branches with 
a formula of the form .
To simulate this in the calculus with metavariables we would need to know if
some instantiation for the metavariables can yield a formula of the form .
In the worst case this is a problem requiring full higher-order unification.
We have been careful to only include rules in our calculi which will
not require arbitrary instantiations of metavariables to prove a lifting lemma.
Formulating such a calculus with metavariables and proving such a lifting lemma
is left for future work.



