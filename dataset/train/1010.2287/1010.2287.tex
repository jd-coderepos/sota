\documentclass[]{llncs}
\usepackage{float}
\floatstyle{boxed}
\newfloat{figure}{h}{ext}
\floatname{figure}{Figure}
\usepackage{graphicx} 
\usepackage{amssymb}
\usepackage{pstricks}
\usepackage{multirow}
\newcommand{\buchi}{{B\"{u}chi}}

\newcommand{\Points}{{\it Points}}
\newcommand{\nat}{{\bf N}}

\newcommand{\lang}{{\cal L}}


\newcommand{\dlvrd}{{\tt dlvrd}}
\newcommand{\rr}{{\tt rr}}
\newcommand{\kc}{{\tt kc}}
\newcommand{\said}{{\tt said}}
\newcommand{\keyleft}{{\tt keyleft}}
\newcommand{\keyright}{{\tt keyright}}
\newcommand{\sender}{{\tt sender}}

\newcommand{\rcvd}{{\tt rcvd}}

\newcommand{\conflictfree}{{\tt conflict\mbox{-}free}}


\newcommand{\false}{0} 
\newcommand{\true}{1} 



\newcommand{\rimp}{\Rightarrow}
\newcommand{\dimp}{\Leftrightarrow}

\newcommand{\val}{V}
\newcommand{\I}{{\cal I}}
\newcommand{\A}{\cal A}
\newcommand{\C}{\cal C}
\newcommand{\R}{{\cal R}}
\newcommand{\intn}[2]{[| #1 |]_{#2}}
\newcommand{\Next}{X}
\newcommand{\some}{E}
\newcommand{\powerset}[1]{{\cal P}(#1)}
\newcommand{\glob}{{\cal G}}
\newcommand{\Vars}{{\it Vars}}
\newcommand{\Ags}{{\it Ags}}
\newcommand{\slotrequest}{{\tt slot\mbox{-}request}}
\newcommand{\msg}{{\tt message}}
\newcommand{\conflict}{\tt conflict}
\newcommand{\roundresult}{{\tt round\mbox{-}result}}
\newcommand{\be}{\begin{enumerate}}
\newcommand{\ee}{\end{enumerate}}




\newcommand{\sysI}{{\cal I}}




\newcommand{\obs}{O}
\newcommand{\xor}{\otimes}
\newcommand{\keys}{{\it keys}}
\newcommand{\rand}{{\it rand}}
\newcommand{\broadcast}{{\it broadcast}}
\newcommand{\omap}{{\it ov}}
\newcommand{\Agt}{{\it Agt}}
\newcommand{\Var}{{\it Var}}


\newcommand{\xm}{\xor m} 


\begin{document}

\title{Abstraction for Epistemic Model Checking of Dining Cryptographers-based 
Protocols
\thanks{ This material is based on research sponsored by the Air Force Research Laboratory, under agreement number FA2386-09-1-4156. The U.S. Government is authorized to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright notation thereon. The views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of the Air Force Research Laboratory or the U.S. Government.
\today}}

\author{Omar I. Al-Bataineh and Ron van der Meyden}
\institute{School of Computer Science and Engineering,\\
University of New South Wales}
\maketitle

\begin{abstract}
The paper describes an abstraction for protocols that are based on multiple rounds of 
Chaum's Dining Cryptographers protocol. It is proved that the abstraction preserves a rich class of 
specifications in the logic of knowledge, including specifications 
describing what an agent knows about other agents' knowledge. 
This result can be used to optimize model checking of 
Dining Cryptographers-based protocols, and applied within a methodology 
for knowledge-based program implementation and verification. 
Some case studies of such an application are given,  
for a protocol that uses the Dining Cryptographers protocol 
as a primitive in an anonymous broadcast system. 
Performance results are given for model checking 
knowledge-based specifications in the concrete and abstract models of this protocol, and some
new conclusions about the protocol are derived. 
\end{abstract}

\section{Introduction}

Relations of abstraction (and their converse, refinement) 
are valuable tools for program verification. In this approach, 
we relate a (structurally complex) concrete program to a (simpler) abstract program
by means of a relation that is known to preserve the properties that we wish to verify 
in the concrete program. When such a relation can be shown to hold, 
we are able to verify these properties in the concrete program by 
showing that they hold in the abstract program, which is 
generally easier in view of the lesser structural complexity of the 
abstract program. In particular, model checkers can be expected to 
run more efficiently on the abstract program than on the concrete program, 
and abstraction is often used to bring the verification problem within the 
bounds of feasibility  for model checking. 
Conversely, starting with the abstract program, and 
having verified that this satisfies the desired properties, 
we may derive the concrete program and conclude that this also satisfies 
these properties. This perspective is the basis for ``correctness-by-construction" or top-down refinement 
approaches to program verification.  

Our contribution in this paper is to establish the correctness of an abstraction relation 
for abstract programs based on use a trusted third party for anonymous broadcast, 
which is implemented in the related concrete programs by means of the {\em Dining Cryptographers} protocol 
proposed by Chaum \cite{chaum}. That Chaum's  protocol implements anonymous 
broadcast is, of course, well-known, but we show that this statement holds in a more
general sense than is usually considered in the literature, where the focus is generally on the very particular property of anonymity. 
Specifically, we consider a broad class of properties formulated in the logic of knowledge, including properties in which agent knowledge is nested, 
such as ``Alice knows that Bob knows that ". We show that the abstraction relation 
between programs based on the trusted third party and programs based on 
the Dining Cryptographers protocol preserves all properties from this class. 

As an application of this result, we consider a protocol from Chaum's paper \cite{chaum} 
that uses multiple rounds of the Dining Cryptographers protocol to build a more general 
anonymous broadcast system. We have previously studied this protocol from the 
perspective of  a model checking based methodology for the implementation of 
knowledge-based programs \cite{AlBatainehMeyden10}, by treating the specification of the 
protocol as a knowledge-based program containing nested knowledge formulas. 

Knowledge-based programs \cite{FHMVbook} are an abstract, program-like form of specification, 
that describe how an agent's actions are related to conditions stated in terms of the agent's knowledge. The advantage of this 
level of abstraction is that it provides a highly intuitive description of the intentions 
of the programmer, that has been argued to be easier to verify than the complex 
implementations one typically finds for highly optimized distributed programs \cite{HZ92,FHMVbook}. 
Knowledge-based programs cannot be directly implemented, however, so they 
must be {\em implemented} by concrete programs in which the 
knowledge  conditions are replaced by concrete predicates of the agent's local state. 
The implementation relation between a knowledge-based program and a putative implementation 
holds when these concrete predicates are equivalent to the knowledge formulas that 
they replace (interpreted with respect to the system generated by running the putative implementation). 
Our partially-automated methodology for the implementation of knowledge-based programs 
uses a model checker for the logic of knowledge  to check whether this equivalence holds, 
and if it does not, uses the counter-examples generated by the model checker to 
generate a revised putative implementation. (This process is iterated until an implementation is found.) 

In our previous work on the application of this methodology, we considered 
model checking problems generated in this way from a knowledge-based 
program based on multiple rounds of the Dining Cryptographers protocol. 
Our experience was that the model checking problems we considered  
were close to the bounds of feasibility for our model checker even for instances with 
small numbers of agents, and we were prevented from considering instances of scale as a result. 
In the present paper, we apply our abstraction result in order to optimize the 
model checking problem, by performing model checking on the abstracted 
(trusted third party) version of the programs we consider rather than the concrete 
(Dining Cryptographers based) versions.  We give performance results
showing the difference, which indicate that the abstraction is effective in 
reducing the model checking runtime by several  orders of magnitude, enabling 
systems involving larger numbers of rounds of the  Dining Cryptographers protocol
and larger numbers of agents to be model checked. We use the efficiency gains to extend 
our previous analysis of the knowledge based program to larger numbers of agents, 
leading to an improved understanding of its implementations. 

The structure of the paper is as follows. We begin in Section~\ref{sec:knowledge}  
by introducing the logic of knowledge, which provides the specification language for the
properties that are preserved by our abstraction technique, and give its semantics in 
terms of a class of Kripke structures. We define a notion of bisimulation
on these Kripke structures that provides the semantic basis for our program abstraction technique. 
In Section~\ref{sec:programs}, we introduce a simple programming language 
used to represent our concrete and abstract programs.  In Section~\ref{sec:DC}, we 
introduce the Dining Cryptographers protocol and, in Section~\ref{sec:DCa},   its abstraction using a trusted 
third party. In Section~\ref{sec:abstraction} we state and prove correct the abstraction relation.  
The remainder of the paper deals with our application of this result. 
We recall the two-phase protocol in Section~\ref{sec:rounds}. In Section~\ref{sec:kbp} we describe knowledge-based programs 
and an approach to the use of model checking to identify their implementations. 
In Section~\ref{sec:dckbp} we recall our formulation of the two-phase protocol 
as a knowledge-based program and describe the associated verification conditions. 
Section~\ref{sec:results} discusses the comparative performance of
model checking in the concrete and abstract models when using the model checker MCK. 
We highlight some of the interesting conclusions we are able to make about implementations 
of the knowledge-based program for the round-based protocol in Section~\ref{sec:imp-results}. 
We discuss related work in Section~\ref{sec:related}. Finally, in Section~\ref{sec:concl},  we draw some conclusions and 
discuss future directions.  

\section{Epistemic Logic and Bisimulations}\label{sec:knowledge} 

Epistemic logics are a class of modal logics that
include operators whose meaning concerns
the information available to agents in a 
distributed or multi-agent system. 
In epistemic model checking, one is generally concerned
with the combination of such operators with 
temporal operators, and a semantics using 
a class of structures  known in the literature as  {\em interpreted 
systems} \cite{FHMVbook} that combines temporal and epistemic 
expressiveness. We focus here on a simpler framework that omits temporal operators, 
since we are mostly interested, in our application, on what knowledge agents have after some program has run, 
and this also simplifies the statement and proof of our results. 

Suppose that we are interested in systems comprised of  agents
from a set  whose states are described using a set  of 
boolean variables.\footnote{We use the term ``variable" rather than ``proposition" in this paper, since our
atomic propositions arise as boolean variables in a program.} 
The syntax of the  logic of knowledge 
is given by the following grammar: 

where  is a variable and  is an agent. 
(We freely use standard boolean operators that can be defined 
using the two given.) Intuitively, the meaning of  
is that agent  knows that  is true. 

The semantics for the language is given in terms of {\em Kripke structures} 
of the form  
, 
where 
\be 
\item  is the set of agents, 
\item  is a set of worlds, or situations,  
\item for each ,  is an equivalence relation on ,
\item  is a set of variables, 
\item  is a valuation. 
\ee 
Intuitively,  is the set of situations that the agents
consider that they could be in, and  if, 
when the actual situation is , agent  considers it possible that 
they are in situation . The value  is the truth value of variable
 in situation . Such a Kripke structure  is {\em fit} for the 
language  if  and 
.  The semantics of the language is given by the 
relation , where  is a Kripke structure fit for ,  
is a world of , 
and  is a formula, meaning intuitively that the formula  holds at the 
world . The definition is given inductively by 
\be 
\item  if , for . 
\item  if not , 
\item  if  and , 
\item  if  for all  with , for . 
\ee
Intuitively, the final clause says that 
agent  knows  if it does not consider it possible that not . 
We write , and say that  is {\em valid} in ,   if  for
all . The {\em Kripke structure model checking} problem  is to compute, given  and , 
whether .  We will use this formulation of the model checking problem as the basis for another 
notion of model checking, to be introduced below, that concerns a way of generating  from a program. 

One of the difficulties to be faced in model checking, the {\em state space explosion} problem, 
is the potentially large size of the set of worlds  of the structures  of interest. 
Abstractions are useful techniques for mitigating
state space explosion problem. They are often applied 
as a preliminary step to model checking. 
Systems often encode details
that are irrelevant to the properties that we aim
to verify. Abstraction techniques enable us to eliminate such unnecessary,  redundant details. 
However, abstractions must be sound, in the sense that properties that hold in the abstract model must
also hold in the concrete model.

For Kripke structures, {\em bisimulations}
may provide an 
effective way to simplify redundant structure 
while preserving properties of interest. We formulate here a 
version that is suited to our application, in which we allow both the 
set of agents and the set of propositions to vary  in the structures 
we consider. 

Suppose we are given a set of variables , a set of agents , 
and two Kripke structures 
  
and   
such that  and . 
(Note that these conditions imply that both  and  are fit for .) 
A -bisimulation  between  and  is defined to be a binary relation
 such that:
\begin{enumerate}
\item \textbf{Atoms:}  whenever  and ; 

\item  \textbf{Forth:}  if ,  and  are two worlds in  and  is a world in 
such that  and , then there is
a world   such that 
and ; and 
\item \textbf{Back:}  if   and  are two worlds in  and  is a world in 
such that  and , then there is
a  such that 
and .

\end{enumerate}
If there exists an -bisimulation  between  and  such that ,
then we write . 
If there  exists an -bisimulation  between  and  such that 
for every  there exists  such that  and, conversely, 
for every  there exists  such that ,  then we write . 
The following result shows that -bisimulation preserves properties in the language . 

\begin{lemma}
If  and  are Kripke structures and  and  are worlds of 
 and  such that
 , then 
 for all  we have 
 if and only if . 
If  then for all  we have 
 if and only if .
\end{lemma}
 
We omit the proof since it is a minor variant of well-known results 
in the literature.  
In our applications of this result, 
we will consider a complex, concrete structure  
and a simper, more abstract structure , and show that 
. This enables us to verify 
 using the model checking problem
, which is likely to be computationally 
easier in view of the smaller size of . However, we need 
to also develop an abstraction technique for the programs that 
generate these Kripke structures. We develop this technique in the following sections. 

\section{A Programming Language and its Semantics} \label{sec:programs} 

We use a small multi-agent programming language equipped with a notion of observability. 
All variables are Boolean,  and expressions are formed from variables  using the usual Boolean operators. 
The language has the following 
atomic actions, 
in which  and  are  agents,   is a variable name and  is an expression: 
\be 
\item   ---  agent  evaluates  and assigns the result to , 
\item  --- agent  assigns a random value to ,  
\item  --- agent  evaluates  and transmits the result across a private channel  to agent , 
 who assigns it to its variable , 
 \item  --  agent  broadcasts the value of the variable  to all other agents. 
\ee
Note that we write  for agent 's variable  (the variables  and  are considered distinct when )
but may omit the agent name when this is clear from the context.   In particular,  in
an atomic action , any variable  not explicitly associated with an agent
refers to . For example, we may write  rather than . 
Similarly, when  is an expression in which agent indices are omitted, and  is an agent, 
the expression  refers to the result of replacing each occurrence of a variable name  in  
that is not already associated to an agent index 
with . Thus  represents  . 


 Each atomic action {\em reads}  and {\em writes}  certain variables. 
 Specifically, the action   reads the (agent ) variables in  and writes , the action 
 reads nothing and writes , the action 
 reads the (agent ) variables in  and writes , and the action 
 reads   and writes nothing. 
A {\em  joint action} is  a set of atomic actions in which no variable is 
written more than once.   Intuitively,  a joint action is executed by first evaluating all the expressions and then performing a  simultaneous
assignment  to the variables. 

A {\em program}  is given by a sequence of joint actions
. 
A {\em program for agent } is a program in which  each atomic action  in any step 
has . We permit parallelism within an agent, in the sense that we do {\em not} require that 
a joint action contains at most one atomic action for each agent. 
If we are given for each agent  a program , all of the same
length , then we may form the joint program . 

Some well-formedness conditions are required on agent programs. 
An {\em observability mapping} is a function   mapping each agent 
to a set of variables, intuitively, the set of variables that it may observe. 
A program runs in the context of an observability mapping, and modifies that 
mapping. We say that {\em a joint action  is  enabled} at an observability 
map  if 
\be 
\item no variable written to by  is in   for any agent 
(that is, all variables written to are 
{\em new} variables), and 
\item for each atomic action  and  in , 
the expression  contains only variables in , and 
\item for each action  we have . 
\ee 
These constraints may be understood as access control constraints stating that 
agent  may read only the variables in  and may write only new variables. 

Executing the action  transforms the  observability map 
to the  observability map   
such that  is  the result of adding to 
\be 
\item 
all variables   such that an action of the form  or  or   occurs in , and 
\item 
all variables    such that  
occurs in . 
\ee 
These definitions are  generalised to programs: 
{\em the program   is enabled}  at
the observability map   if for each , 
the action  is  enabled at , 
and we define  to be . 


\begin{example} 
Consider a two-agent system with agents . 
The action  is not enabled at the observability map  
given by . However, the 
program  is enabled at , 
since  the action  is enabled at , and 
transforms  to  ,
at  which the action  is enabled. 
\end{example} 

We say that an  observability map is {\em  consistent} with a Kripke  structure

when for all agents , if  is a variable in  then , and for 
 all worlds  such that 
we have . Intuitively,  is consistent with   if all 
variables declared to be local to agent  by  are in fact defined and  semantically 
local  to agent  in .

The {\em program  is enabled at a Kripke structure } if 
there exists an observability map  such that
\be 
\item   is consistent with , 
\item  is enabled at , and 
\item all variables   written by  are not defined in  (i.e., ). 
\ee 
In particular, note that if a single joint action  is enabled at , then 
for all variables  read by , and all worlds , the value  is
defined. Consequently, we may also evaluate at  any expression  
required to be computed  by . We write  for the result. 

We can now give a semantics of programs,  in which a program applied to a Kripke structure
representing the  initial states of information of the agents, 
transforms the structure into another Kripke structure  representing 
the states of information of the agents after running the program. The definition is 
given inductively, on an action-by-action basis. 
Let  be  a Kripke structure and 
 a joint action. We define a Kripke structure 
 as follows. 
Let  be the set of variables  such that  includes
the atomic action . Intuitively, such actions increase the 
amount of non-determinism in the system, whereas all other actions  
have deterministic effects. We define
 and take   to be the set of states of the form  where 
 and   is 
an assignment of boolean values to the variables  in . 
We may write  for the pair . 
In case  is the empty set,  is always the null
 function, so we 
may write just  for . The set  of variables defined in 
 is obtained by adding to  all variables written to by . 
The assignment  is obtained by extending  to these new variables
by defining  as follows on worlds : 
\be
\item if  then  , 
\item if  occurs in  then  , 
\item if  occurs in  then , and 
\item if  occurs in  then .  
\ee 
Finally, the indistinguishability relations  are defined using the observability map 
: we define 
 when  
and for all variables  in , we have . 
Intuitively, this reflects that the agent recalls any information it had in the structure , 
and adds to this information that it is able to observe in the new state. 
Note that in fact  implies 
for {\em all} variables , 
since we have assumed that for  we have that   implies . 
Moreover, since the set  is just the set of 
variables written to by  that are made observable to , this observation 
also yields that the definition of  is independent of the 
choice of observation map  consistent with . 

\section{Chaum's Dining Cryptographers Protocol}\label{sec:DC} 

Chaum's Dining Cryptographers protocol is an example of an anonymous broadcast
protocol: it allows an agent to send a message without revealing
its  identity. Chaum introduces the protocol 
with the following story:

\begin{quote}
Three cryptographers are sitting down to dinner at their favourite restaurant.
Their waiter informs them that arrangements have been made with the maitre d'hotel
for the bill to be paid anonymously. One of the cryptographers might be paying for
the dinner, or it might have been NSA (U.S National Security Agency). The three
cryptographers respect each other's right to make an anonymous payment, but they
wonder if NSA is paying. They resolve their uncertainty fairly by carrying out the following protocol:\\
Each cryptographer flips an unbiased coin behind his menu, between him and the cryptographer on his right, so that only the two of them can see the outcome. Each cryptographer then states aloud whether the two coins he can see--the one he flipped and the one his left-hand neighbor flipped--fell on the same side or on different sides. If one of the cryptographers is the payer, he states the opposite of what he sees. An odd number of differences uttered at the table indicates that a cryptographer is paying; an even number indicates that NSA is paying (assuming that the dinner was paid for only once). Yet if a cryptographer is paying, neither of the other two learns anything from the utterances about which cryptographer it is.
\end{quote}

\newcommand{\inedges}{{\it in}} 
\newcommand{\outedges}{{\it out}} 

Chaum shows that this protocol solves the problem, and notes that it can be considered
as a mechanism enabling a signal to be anonymously transmitted, under the  
assumption that at most one of the agents wishes to transmit. 
He goes on to generalize the idea to -agent settings where, in 
place of the ring of coins, we have a graph 
representing the key-sharing arrangement. 

The more general protocol can be represented in our
programming language as follows. We assume that there is a set 
 of agents, who share secrets based on a (directed) key sharing graph 
 in which the vertices are the agents in  and the edges  
describe the keysharing arrrangement amongst the agents. 
We model keysharing by assuming that for each edge , 
agent  generates the key corresponding to the edge, and 
communicates the key to  across a secure channel. 
For each edge  we write  for the source agent  and  for the destination agent . 
For each agent  we define  and 
.  Accordingly, we use two variables for each edge : the variable 
 stores 's copy of the key corresponding to the edge,  and the variable 
 stores  's copy. We write  for , i.e., the set of edges incident on . 
The protocol  of an agent  (in which the message represented by the expression  
is transmitted anonymously by agent ) consists of  the following five steps: 

\begin{figure} [h]
 
\textbf{ \caption{The protocol }}
\end{figure}

We write  for the joint program .

Intuitively, the protocol DC operates by first generating keys and setting up the key sharing graph, 
and then having each of the agents make a public announcement encrypted using all the keys 
available to them. The directionality of an edge in the key sharing graph indicates who
generates the key corresponding to the edge, viz, the source agent of the edge. 
The first step of the protocol corresponds to each agent generating the key values for which they are responsible.  
In the second step, these keys are shared with the other agent on the edge by transmission across a secure channel. 
Each agent now has the value of each of the key edges on which it is incident, and computes the 
xor of its message with all these key values in the 3rd step, and broadcasts the result in the 4th step. 
In the final step of the protocol, each agent computes the xor of the messages broadcast as the 
result of the protocol. 

\section{An Abstraction of the Dining Cryptographers Protocol} \label{sec:DCa} 

We are interested in protocols in which the DC protocol is used as a basic building block, 
and in model checking the agent's knowledge in the resulting protocols. 
In order to optimize this model checking problem, we now introduce a protocol 
that we will show to be an abstraction of the DC protocol that preserves epistemic properties. 

The abstracted version of the protocol omits the use of keys, but adds to the set of agents  a trusted third party
 who computes the result of the protocol on behalf of the agents, and then broadcasts it. 
Here, we take . The protocol  for agent  is given in four steps, see Figure~\ref{fig:dca}. 
\begin{figure}[h]
 
\textbf{ \caption{The abstract protocol \label{fig:dca}}}
\end{figure}
We write  for the joint program .
Intuitively, in the abstract protocol, the agents transmit their bits across a 
secure channel to the trusted third party, who computes the exclusive-or
and broadcasts it. 

Note that since the protocol  makes no use of randomization, the set of worlds of the structure 
 is identical to the set of worlds of the structure ; only the set of defined variables
and the indistinguishability relation change. We can characterize the indistinguishability relations of 
 as follows, where we introduce the abbreviation  for . 


\begin{lemma} \label{lem:simdca} 
If  is a Kripke structure at which  is enabled, and  are worlds of  then 
 iff  and .
\end{lemma} 


The program  makes use of randomization, so the structure  has more worlds than 
the structure . More specifically, it can be seen that the worlds of   have the form 
, where  assigns boolean values to the variables 
 for  and , and   assigns boolean values to the variables 
 for  and . Note that by the second step of the protocol, we always have 
 for all . We may therefore abbreviate such a world to , 
where , and 
we have 
\be 
\item , 
\item , 
\item , 
and 
\item . 
\ee 
Note that the final equation may be simplified as follows:  
 
where the third step follows using the fact each term  occurs twice, 
once for  and once for . 
Based on this representation, we can characterize the indistinguishability relations of 
 as follows: 

\begin{lemma} \label{lem:simdc} 
If  is a Kripke structure at which  is enabled, and  and  are worlds of  then 
 iff 
\be \item  and 
\item  for all  and 
\item  for all 
. 
\ee 
\end{lemma} 

\section{Proof of Abstraction} \label{sec:abstraction}

The following is implicit\footnote{Chaum's result is stated probabilistically, but the proof is 
largely non-probabilistic and establishes this result.} 
in the proof of a key result concerning the DC protocol that is proved in Chaum \cite{chaum} (Section 1.4).
 

\begin{lemma} \label{lem:chaum} 
For all  and for all  functions   and  and  
such that , there exists a function  
such that  and
for all , we have  
\end{lemma} 




Note that the variables introduced by  are the variables ,  and  for  and .  
The variables introduced by  are ,  and  for . 
Hence the set of variables introduced by both protocols is the set  . 
The following result states that these variables are introduced by these protocols in such a way as to extend a bisimulation
between given concrete and abstract structures to the new variables. 

\begin{theorem} \label{thm:abstractdc}
Suppose that    for a set of variables  containing all variables in the expressions  for , 
and let  be enabled at  and  be enabled at . 
Then . 
\end{theorem} 


\begin{proof} 
Let  and
let 
We write 
 and

As noted above, we have  and 
 

Let  be the bisimulation relation witnessing  . 
We define the relation  as follows:
 if . 
We claim that this relation witnesses . 


{\em Atoms:} We need to check that for all , 
if  then . For propositions , this 
is immediate from the facts that  implies , that  is a -bisimulation, 
and that  and . For the variables , we argue as follows. Note that since 
the variables in  are included in , it follows that , 
and hence that  .
As noted above, we have 
. 
By the program for , we also have 
. 
Combining these equations yields . 
Thus, we have that  preserves all propositions in . 


\textit{Forth:} Let , , and let  
such that  
and . We need to show that there exists  
such that  and . 
We argue as follows. From  it follows that 
.  Also,  from  it follows 
by Lemma~\ref{lem:simdc} that .
Since  is a bisimulation, we obtain that there exists a world 
such that  and . Since  we may 
define  to be . It is immediate from the definition of  
and the fact that  that . 
To show    we use the characterization of  
of Lemma~\ref{lem:simdca}. We already have that  by construction, 
so it remains to show . 

From the fact that 
, and that all variables in  are in , 
we have that .
Similarly, from , 
we have that . 
Further, since  , it follows 
by Lemma~\ref{lem:simdc} that  . 
Combining these equations yields , 
giving the remainder of what we require for the conclusion that 
. 


\textit{Back:}  Let , , and let  
such that  and  . 
We need to show that there exists  
such that  and .
We identify the world  as follows. 
From  we have  that  and 
from   we have (by Lemma~\ref{lem:simdc})
that . Since  is a bisimulation, there exists a 
value  such that   and . 

From  and Lemma~\ref{lem:simdca}, we obtain that 
, 
hence also . 
From the fact that  is a bisimulation preserving the propositions , 
we get from   and   that 
 and . 
Combining these equations yields . 

Note that    implies that  for all 
, giving half of what we require. 
It therefore remains to find a value of  such that 
. Since we already have ,  
 this requires, by Lemma~\ref{lem:simdc}, that we find  such that 
 for all  and 
 for all 
.  Since , the existence of such a function  is guaranteed by Lemma~\ref{lem:chaum}, 
on taking  and . 
\qed
\end{proof} 


This result gives us that, modulo bisimulation, the programs  and  have the
same effect on the agent's mutual states of knowledge. We have a similar result if we consider 
the effect of joint actions : 

\begin{lemma} \label{lem:actions} 
Let  and  be Kripke structures such that , and 
let  be a joint action, writing variables , such that  is enabled at both  and . 
Then ,
\end{lemma} 
\begin{proof} 
Suppose  is a bisimulation witnessing , 
and we represent the worlds of 
as  where  is a  world of  
and , where 
 for . 
(This requires some constraints on the set of , to handle the case of 
variables  that are not written by  statements.) 
The worlds of  may be similarly represented as  where  is a world of . 

Then it is easily shown that the  relation  defined by 
 if  and  
is a bisimulation.  \qed
\end{proof} 


Combining Theorem~\ref{thm:abstractdc} and Lemma~\ref{lem:actions}, we obtain the following
by a straightforward induction.
(Note that we 
use fresh variables  
 and  in each of the instances of  and .)

\begin{theorem} \label{thm:main} 
Let  and  be Kripke structures with , and 
let   
5pt] 
P^a = Q_1; DC^a(m_1); Q_2 ;  DC^a(m_2); \ldots  DC^a(m_k); Q_{k+1}
\end{array} \conflict(s) = \bigvee_{i\neq j} (i\verb+.slot-request+= s= j\verb+.slot-request+)~. \sender(i,x) = \bigvee_{j\neq i} (j.{\tt message} = x \land j.\slotrequest \neq 0)~. \sender(i,x) = \bigvee_{j} (j.{\tt message} = x \land j.\slotrequest \neq 0)~. i.\verb+kc[s]+ \dimp \neg K_{i} (\conflict(s))~~~~~~~(1) i.\rcvd0 \dimp K_i(\sender(i,0) ~~~~~~~~~(2a) i.\rcvd1 \dimp K_i(\sender(i,1)) ~~~~~~~~~ (2b)
\begin{array}{l} 
 i.\dlvrd \dimp 
\bigwedge_{x\in Bool} (i.\msg = x  \land i.\slotrequest \neq 0\\
~~~~~~~~~~~~~~~~~~~~~~~~~ \rimp K_i ( \bigwedge_{j\neq i} K_j\sender(j,x)))
\end{array} 
  \bigvee_{x=0,1} K_i( \bigwedge_{j\neq i} (j.\msg = x)) \lor 
\bigwedge_{j\neq i} ( \neg \hat{K}_i(j.\msg))~.
\begin{array}[t]{l}
i. \conflictfree(s)  := C_{0} = 0 \lor C_{0} = 1 \lor (C_0 = 2 \land i.\slotrequest = 0) \lor \\ 
~~~~~((C_0 = 2 \lor C_0 = 3) \land \bigvee_{t=1}^n (s\neq t \land i.\slotrequest = t \land \rr[t] = 0 )) \lor  \\ 
~~~~~((C_0 = 2 \lor C_0 = 3) \land \bigvee_{t=1}^n (s\neq t \land i.\slotrequest = t \land \rr[t] =1 \\
\hspace{2in} \land \rr[n+t] \neq i.\msg))
\end{array} 
 
\begin{array}[t]{l}
i.\rcvd x : = \bigvee_{s=1}^n ((i.\slotrequest \neq s \land \rr[s] =1 \land \rr[n+s] =x) ~ \lor \\ 
~~~~~~~~~~~~~~~~~~~~~~~~~(i.\slotrequest =s\land   \rr[s] =1\land  \rr[n+s]\neq i.\msg) )
\end{array} 
  
\begin{array}{l} 
\dlvrd := (\slotrequest \neq 0 \land (C_0 = 0\lor C_0 = 1) ) \lor \\ 
~~~~~         (\slotrequest \neq 0 \land  \msg = 1 ~\land \\
\hspace{1in}   \bigvee_{s\neq t,~s,t =1..n} (\rr[s] = \rr[t] = 1 \land \rr[n+s] = \rr[n+t] = 1)) \lor  \\         
~~~~~          (\slotrequest \neq 0 \land \msg = 0~ \land \\
\hspace{1in}  \bigvee_{s\neq t,~s,t =1..n} (\rr[s] = \rr[t] = 1 \land  \rr[n+s] = \rr[n+t] = 0)) 
\end{array} 
\rcvd x := (\slotrequest \neq 0 \land \msg = x) \lor   \bigvee_{s=1}^n (\rr[s] = 1 \land \rr[n+s] =x)\dlvrd :=  \slotrequest \neq 0 \land  \bigvee_{s=1}^n (\rr[s] = 1 \land \rr[n+s] = \msg) 
Intuitively, in this case, an agent's own message counts as a delivery, and 
messages observed  on reserved slots can be taken at face value. 

Finally, the anonymity property, Specification 4, has been verified to hold in all the implementations obtained
from the assignments discussed above, when . 

\section{Related Work}\label{sec:related} 

Abstractions of the kind we have studied, relating a  protocol  
involving a trusted third party to a
protocol that omits the trusted third party, are often used in  
theoretical studies to specify the
objectives of a multi-party protocol. One example where this is done  
in a formal methods setting
is work by Backes et al \cite{BMM10}, who study the abstraction of pi- 
calculus programs based on
multi-party computations. Where we consider a model checking approach  
to verification, with an expressive epistemic 
specification language, they use a type-checking approach.  Their  
notion  of abstraction is richer than the bisimulation-based approach  
we have taken,
in that they also deal with probabilistic and computational concerns.
However, as we have noted, we are interested in the preservation of a  
set of epistemic
properties (nested knowledge formulas) that is richer in some  
dimensions than is usually considered in this literature.
Our abstraction result could be easily strengthened to incorporate  
probability, as was done for
a secure channel abstraction by van der Meyden and Wilke  
\cite{MeydenWilke07}.
However computational complexity issues mesh less well with
epistemic logic, and developing a satisfactory solution to this  
remains an open problem.

Epistemic model checking is less developed than model checking for  
temporal logic, and
many possible optimization techniques remain to be explored for this  
field. Other approaches
using abstraction in the context of epistemic model checking include
\cite{CohenDLR09,CohenDLQ09}. These works are orthogonal to ours in that
where we are concerned with an abstraction of a particular primitive  
(the Dining Cryptographers protocol), that works for all formulas,  
they are concerned with symmetry reductions or deal with a more  
general class of programs than we have considered,
but need to restrict the class of formulas preserved by the abstraction.

Other model checkers for the logic of knowledge are under development
but MCK remains unique in supporting the perfect recall semantics for  
knowledge
using symbolic techniques.  DEMO \cite{demo} implicitly deals with  
perfect recall,
but is based on a somewhat different logic (epistemic update logic),  
and uses explicit state model checking techniques,
so it is not clear if it could be used for the type of analysis
and scale of programs we have considered in this paper.
MCMAS \cite{mcmas}, MCTK \cite{mctk} and  VERICS \cite{verics} are  
based on the observational semantics
for knowledge (which is also supported in MCK).

It is possible in some cases to represent the perfect
recall semantics using the observational semantics (essentially by  
encoding all history variables into the
state) and this approach is used in \cite{LSGWY} to analyse the same 2- 
phase protocol as
we considered in this paper.
However, this modelling is ad-hoc and the transformation from perfect  
 recall to observational semantics is
handled manually, making it susceptible to missing timing channels if  
not done correctly.
(Moreover, we did briefly experiment with such a modeling for the  
large programs studied in this paper, but
found that the perfect recall model checking algorithms outperform the  
observational semantics
model checking algorithm on these programs.)
The work of \cite{LSGWY} does not view the protocol as a knowledge- 
based program, as we have done,
nor do they consider abstraction.

Knowledge-based programs have been applied successfully in a number of  
applications such as
distributed systems, AI, and game theory. They have been used in  
papers such as
\cite{DM86,Had87,HZ92,BaukusM04,NT93} in order to help in the  
design of new protocols or to clarify
the understanding of existing protocols.
Examples of the development of standard programs from knowledge-based  
programs
can be found in \cite{APPG88,DM86,SR86}.
The approach described in these papers is different from the one we  
discussed here in that it is done by pencil and paper analysis and proof.
Examples of the use of epistemic model checkers to identify  
implementations of knowledge-based programs
remain limited. One is the  work of Baukus and van der Meyden  
\cite{BaukusM04} who use MCK
to analyze several protocols for the cache coherence problem using  
knowledge-based framework.

The 2-phase protocol has been implemented in the Herbivore system  
\cite{Herbivore}, which elaborates it
with protocols allowing agents to enter and exit the system, as well  
as grouping agents in
anonymity cliques for purposes of effciency. Variants of the protocol  
have also been considered by
Pfitzman and Waidner \cite{WP}.
These would make interesting case studies for future applications of  
our approach.

\section{Conclusion}\label{sec:concl} 

We have established the soundness of an abstraction for 
of protocols based on the Dining Cryptographers, and applied this result to 
optimize epistemic model checking of protocols that use Dining Cryptographers
as a primitive. Our experimental results clearly demonstrate that the abstraction 
yields efficiency gains for epistemic model checking in interesting examples. In particular, 
we have used these gains to extend an analysis of a knowledge-based program for the 
2-phase protocol, and derived some interesting conclusions about the subtle information 
flows in the protocol. Several research directions suggest themselves as a result of this work. 
One is to complete the analysis of the knowledge-based program for all numbers of agents. 
We conjecture that our present implementation can be shown to work for all numbers of agents, 
and it would be interesting to have a proof of this claim: this would have to be done manually 
rather than by model checking, unless an induction result can be found for the model checking 
approach.  Another direction is to consider richer extensions of the 2-phase protocol, 
addressing issues such as messages longer than a single bit, 
agent entry and exit protocols, as well as adversarial concerns such as 
collusion, cheating and disruption of the protocol. We hope to address these in future work.

{\bf Acknowledgments:} Thanks to Xiaowei Huang and Kai Englehardt for comments on an earlier version of the paper. 

\bibliographystyle{plain}
\bibliography{references}

\end{document}