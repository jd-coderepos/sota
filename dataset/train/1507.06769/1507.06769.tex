\documentclass{acm_proc_article-sp}
\usepackage{graphicx,comment}
\usepackage{amssymb}
\usepackage{enumerate}
\usepackage{multirow}
\usepackage{amsmath}
\usepackage{tabularx}
\usepackage{dsfont}
\usepackage{extarrows}
\usepackage{epstopdf}
\usepackage[]{algorithm2e}
\usepackage{xcolor}
\usepackage{fixltx2e}


\begin{document}

\title{Modelling and Analysis of Network Security\\- a Probabilistic Value-passing CCS Approach}

\numberofauthors{3}
\author{
\alignauthor Qian Zhang\\
       \affaddr{State Key Laboratory of Computer Science,Institute of Software Chinese Academy of Sciences}\\
       \affaddr{Beijing, China}\\
       \email{zhangq@ios.ac.cn}
\alignauthor Ying Jiang\\
       \affaddr{State Key Laboratory of Computer Science, Institute of SoftwareChinese Academy of Sciences}\\
       \affaddr{Beijing, China}\\
       \email{jy@ios.ac.cn}
\alignauthor Liping Ding\\
       \affaddr{National Engineering Research Center for Fundamental Software,Institute of Software Chinese Academy of Sciences}\\
       \affaddr{Beijing, China}\\
       \email{liping@nfs.iscas.ac.cn}
       }
\maketitle

\begin{abstract}
In this work, we propose a probabilistic value-passing CCS (Calculus of Communicating System) approach to model and analyze a typical network security scenario with one attacker and one defender.
By minimizing this model with respect to probabilistic bisimulation and abstracting it through graph-theoretic methods,
two algorithms based on backward induction are designed to compute Nash Equilibrium strategy and Social Optimal strategy respectively. For each algorithm,
the correctness  is proved and an implementation is realized.
Finally, this approach is illustrated by a detailed case study.
\end{abstract}

\category{C.2.0}{Computer-Communication Networks}{General}[Security and protection]

\terms{Security}
\keywords{Network security; Nash equilibrium strategy; Social optimal strategy; Reactive model;
Probabilistic value passing CCS}

\section{Introduction}
Modeling and analysis of network security has been a hot research spot in the network security domain.
It has been studied from different perspectives.  Among them are two main approaches, one based on game-theoretic methods \cite{martin},  and
one based on (probabilistic) process algebra \cite{robin,rob,yuxin}.
In the later 1990's, game theoretic methods were introduced for modeling and analyzing network security \cite{syverson}.
These methods consist in applying different kinds of games to different network scenarios with one attacker and one defender \cite{sankardas}.
Roughly speaking,
{\it static game} is a one-shot game in which players choose action simultaneously.
It is often used to model the scenarios in which the attacker and defender have no idea on the action chosen by the adversary (for instance the scenario of information warfare),
and to compute the best strategy for players in a quantitative way \cite{jormakka}.
{\it Stochastic game} is often used to model the scenarios which involve probabilistic transitions through states of network systems according to the actions chosen by the attacker and the defender \cite{nguyen,klye}.
{\it Markov game} is an extension of game theory to MDP-like environments \cite{vander}.
It is often used to model the scenarios in which the future offensive-defensive behaviors will impact on the present action choice of attacker and defender \cite{xiaolin}.
In {\it Bayesian game}, the characteristics about other players is incomplete and players use Bayesian analysis in predicting the outcome \cite{Harsanyi}.
A dynamic Bayesian game with two players, called {\it Signaling game}, is often used to model intrusion detection in mobile ad-hoc networks and to analyze Nash equilibrium in a qualitative way \cite{patcha}.
On the other hand, as far as we know, (probabilistic) process algebra approach focus on verifying network security protocols.
For example, in the earlier 1980's, a simple version of the alternating bit protocol
in  (Algebra of Communicating Processes with silent actions) was verified \cite{bergstra}.
For describing and analyzing cryptographic protocols, the spi calculus, an extension of the  calculus, was designed \cite{abadi}.
Recently, a generalization of the bisimilarity pseudo-metric based on the Kantorovich lifting is proposed,
this metric allows to deal with a wider class of properties such as those used in security and privacy \cite{lilixu}.

In this paper, we propose a probabilistic value-passing CCS (PVCCS) approach for modeling and analyzing a typical network security scenario with one attacker and one defender.
A network system is supposed to be composed of three participants: one attacker, one defender and the network environment which is the hardware and software services of the network under consideration. We consider all possible behaviors of the participants at each state of the system as processes and assign each state with a process describing all possible interactions currently performed among the participants.
In this way we establish  a network state transition model, often called reactive model in the literature \cite{rob}, based on PVCCS.
By minimizing this model with respect to probabilistic bisimulation and abstracting it via graph-theoretic methods,
two algorithms based on backward induction are designed to compute Nash Equilibrium Strategy (NES) \cite{xiannuan, jean,ls} and Social Optimal Strategy (SOS) \cite{rd,david} respectively.
The former represents a stable strategy of which neither the attacker nor the defender is willing to change the current situation, and
the latter is the policy to minimize the damages caused by the attacker. For each algorithm, the correctness  is proved and an implementation is realized. This approach is illustrated by a detailed case study on an example introduced in \cite{klye}. The example
describes a local network connected to Internet under the assumption that the firewall is unreliable, and the operating system on the machine is insufficiently hardening, and the attacker has chance to pretend as a root user in web server, stealing or damaging data stored in private file server and private workstation.
The major contributions of our work are:
\begin{itemize}
\item
establish a reactive model based on PVCCS for a typical network security scenario
which is usually modeled via perfect and complete information games.
\item
minimize the state space of network system via probabilistic bisimulation and abstract it via graph-theoretic methods.
This allows us to reduce the search space and hence considerably optimize the complexity of the concerned algorithms.

\item
propose two algorithms to compute Nash Equilibrium and Social Optimal strategy respectively.
The novelty consists in combing graph-theoretic methods with backward induction,  which  enables us on the one hand to increase reuseness and on the other hand to make the backward induction possible in the setting of some infinite paths.
\end{itemize}
Note that our method can filter out invalid Nash Equilibrium strategies from the results obtained by traditional game-theoretic methods. For instance, in the example introduced in \cite{klye},
three Nash Equilibrium strategies obtained ultimately by game-theoretic approach methods,
while only two of them obtained by our method:
we filter out the invalid Nash Equilibrium strategy from the results in \cite{klye}.
Note also our method can be applied to other network security scenarios.
For example, the proposed reactive model can be extended conservatively to a generative model based on PVCCS.
In this way we provide a uniform framework for modeling and analyzing network security scenarios which are usually modeled either via perfect and complete information games or via perfect and incomplete games.
However, for the limited space of this paper, we will focus on the reactive setting for the conciseness and easier understanding of this work.

In the remaining sections, we shall
review some notions of graph theory and establish the reactive model based on PVCCS (Section 2);
present the formal definitions of NES and SOS in this model, as well as the corresponding algorithms
and their correctness proofs (Section 3);
then illustrate our method by a case study (Section 4);
fianlly, discuss the conclusion (Section 5).
Appendix shows proofs of theorems, tables referred to the case study and a notation index.

\section{Preliminaries and Reactive model based on PVCCS}

\subsection{Graph theory}
We firstly recall some notions of graph theory: Strongly Connected Component (SCC), Directed Acyclic Graph (DAG) and Path Contraction \cite{reinhard,serge,david}.

\textbf{SCC} of an arbitrary directed graph form a partition into subgraphs that are themselves strongly connected (it is possible to reach any vertex starting from any other vertex by traversing edges in the direction).

\textbf{DAG} is a directed graph with no directed cycles. There are two useful DAG related properties we used in our paper: (1) if  is a weakly connected graph,  is obtained by viewing each SCC in  as one vertex,  must be a DAG; (2) if  is a DAG,  has at least one vertex whose out-degree is 0.

\textbf{Path Contraction}
Let  be an edge of a graph .  is a graph  with vertex set , and edge set  (Figure \ref{edgecontraction}). Path contraction occurs upon the set of edges in a path that contract to form a single edge between the endpoints of the path after a series of edge contractions.
\begin{figure}[htpb]
\begin{center}
\includegraphics[scale=0.6]{figures/edgecontraction.png}
\caption{Edge contraction}
\label{edgecontraction}
\end{center}
\end{figure}
\subsection{PVCCS\textsubscript{R}}
\newtheorem{definition}{Definition}[section]
\newtheorem{Theorem}{Theorem}[section]
\newtheorem{Lemma}{Lemma}[section]
 is a reactive model for Probabilistic Value-passing CCS, proposed based on the reactive model for probabilistic CCS \cite{rob}.

\textbf{Syntax:}
Let  be a set of channel names ranged over by , and  be the set of co-names, i.e., , and  by convention. .  is a set of value variables ranged over by  and  is a value set ranged over by .  and  denote value expression and boolean expression respectively. The set of actions, ranged over by , ,  where  is the silent action.  and  are a set of process identifiers and a set of process variables respectively. Each process identifier  is assigned an arity, a non-negative integer representing the number of parameters which it takes.

 is the set of processes in  defined inductively as follows, where ,  are already in :\\

where , . ,  are index sets, and , , , and  if .  and  are summation notations for processes and real numbers respectively. Furthermore, each process constant  is defined recursively by associating to each identifier an equation of the form , where  contains no process variables and no free value variables except .

 is an empty process which does nothing;  is a summation process with probabilistic choice which means if performs action ,  will be chosen to be proceed with probability , for example,  is a process which will choose process  with probability 0.2 and  with probability 0.8 if performs action , or will choose  with probability 1 if performs action , here  stands for an action prefix and there are two kinds of prefixes: input prefix  and output prefix . If  is a singleton set, then we will omit the probability from the summation process, such as  will be written as , and if both  and  are singleton sets, then the summation process is written as ;  represents the combined behavior of  and  in parallel;  is a channel restriction, whose behavior is like that of  as long as  does not perform any action with channel ;
 is a conditional process which enacts  if  is , else .

\textbf{Semantics:}
The operational semantics of  is defined by the rules in Table \ref{operationalsemanticspvccs}, where  describes a transition that, by performing an action , starts from  and leads to  with probability . Mapping , i.e., . And  means substituting  for every free occurrences of  in process . By convention, if  and , then we use  to represent multi-step transition.
\begin{table*}
\centering
\renewcommand{\arraystretch}{2.5}
\begin{tabular}{ll}\hline
&
\\
) &
\\
&
\\
 & \\
 & \\
\hline
\end{tabular}
\caption{\label{operationalsemanticspvccs}Operational semantics of }
\end{table*}

\textbf{Probabilistic Bisimulation:}
We recall the definition of \textsf{cumulative probability distribution function} (cPDF) \cite{rob} which computes the total probability in which a process derives a set of processes.  is the powerset operator and we write  to denote the set of equivalence classes induced by equivalence relation  over .
\begin{definition}
 is the total function given by: , , , . \end{definition}

\begin{definition}
An equivalence relation  is a \textsf{probabilistic bisimulation} if  implies: , , .
\end{definition}
 and  are probabilistic bisimilar, written as , if there exists a probabilistic bisimulation  s.t. .

\subsection{Modelling for Network Security based on  PVCCS\textsubscript{R}}
\textbf{ComModel} focuses on modeling the network security scenario modeled usually via perfect and complete information game: a network system state considers the situations of attacker, defender and network environment together; the participants act in turn at each state and the interactions among the participants will cause the network state transition with certain probability; each state transition produces immediate payoff to attacker and defender, and the former (positive values) is in terms of the extent of damage he does to the network while the latter (negative values) is measured by the time of recovery; the future offensive-defensive behaviors will impact on the action choice of attacker and defender at each state. Nash Equilibrium strategy represents a stable plan of action for attacker and defender in long run, while the Social Optimal strategy is a policy to minimize the damage caused by attacker.

Assuming  is the set of network system state, ranged over by , ,  is an index set; action sets of attacker and defender are  and  respectively,  represent the general values,   is the action set of attacker at , as well as  is that of defender; state transition probability is a function , and immediate payoff associated with each transition is a function , where  is the real number set, and we use index to distinguish the first and the second element, and  represents the immediate payoff of attacker, while  is that of defender.

\textbf{ComModel}, a model based on PVCCS\textsubscript{R}, is used to modeling for the network security scenario depicted as above. The processes represent all possible behaviors of the participants in network system at each state. Each state is assigned with a process depicting all possible interactions currently performed among the participants. Then we establish a network state transition system based on the process transitions.

In \textbf{ComModel}, the channel set   , . The value set , where .  is the set of value variables.   is the union of behavior sets of the three participants (, and ) defined as follows:


\begin{figure}[!htpb]
\begin{center}
\includegraphics[scale=0.3]{figures/modelAction.pdf}
\caption{Interactions among participants at state }
\label{interactions}
\end{center}
\end{figure}
Figure \ref{interactions} shows one interaction among the participants at state .  means attacker takes attack , similar to  for defender;  (or ) means network environment is attacked (or is defended);  (or ) means network environment informs defender (or attacker) the action chosen by attacker (or defender);  (or ) means defender (or attacker) is informed that attack (or defense) has happened;  means the network environment writes the values of  and  into a log file, where  and  is used to receive the values of  attack and defense respectively;  stands for the network environment records the immediate payoff to attacker and defender if they choose  and  at state  respectively.

The processes describing all possible behaviors of the participants at state , denoted by ,  and , are defined as follows:


The process assigned to each state  is defined as 
We get the network state transition system, \textbf{TS} for short, based on process transitions. Minimizing  by shrinking probabilistic bisimilar pairs of states. We conduct a series of path contractions on  and obtained a new graph named as  without information loss as follows:
\begin{definition}
\begin{bf}ConTS\end{bf} is a tuple 
\begin{itemize}
\item  is the process we assign to state 
\item  ranged over , if there exists a multi-transition 
\item 
\begin{itemize}
\item action pair: 
\begin{itemize}
\item , 
\end{itemize}
\item transition probability: 
\item weight pair: 
\begin{itemize}
\item 
\item  
\end{itemize}
\end{itemize}
\end{itemize}
\end{definition}
 denotes the sum of absolute weight pair of .
By convention, in any network security scenario, for any , , if  then .

\section{Analyzing Properties as Graph Theory Approach}
We firstly introduce the definitions of Nash Equilibrium strategy (\textit{NES}) and Social Optimal strategy (\textit{SOS}) in our model, and then we illustrate the algorithms proposed to comput \textit{NES} and \textit{SOS} respectively.
\subsection{NES and SOS}
\begin{definition}
, an \textsf{execution} of  in \begin{bf}{ConTS}\end{bf}, denoted by , is a walk (vertices and edges appearing alternately) starting from  and ending with a cycle, on which every vertex's out-degree is 1.
\end{definition}
According to the definition of execution,  is in the form of  which is ended by a cycle starting with , where  and  may be the same node.  can be written as  if  is the first edge of ;
 denotes the subsequence of  starting from , where  is a vertex on .
\begin{definition}
The \textsf{payoff} to attacker and defender on execution , denoted by  and  respectively, are defined as follows:

where  is a discount factor. The sum of absolute payoff on  of attacker and defender is denoted as , and  .
\end{definition}
\begin{Theorem}
\label{payoffconverged}
,  is an execution of ,  and   are converged.
\end{Theorem}
\begin{proof}
Based on the definition of payoff on an execution of  and limiting laws, we show the proof details for  in Appendix. The proof for  is similar.
\end{proof}
Nash Equilibrium Execution and Social Optimal Execution are defined coinductively \cite{davide07} as follows:
\begin{definition}
 is \textsf{Nash Equilibrium Execution (NEE)} of  if it satisfies:

where  is \textit{NEE} of ,  is the first edge of ,  including , and  .
\end{definition}

\begin{definition}
 is \textsf{Social Optimal Execution (SOE)} of , if it satisfies:

where  is \textit{SOE} of 
\end{definition}

\begin{definition}
\textsf{Strategy} is a sequence consisting of action pair (one from attacker and one from defender) at each state.
\end{definition}

\begin{definition}
\textsf{Nash Equilibrium Strategy} (\textit{NES}) is a strategy of which every 's execution based on is NEE of .
\end{definition}

\begin{definition}
\textsf{Social Optimal Strategy} (\textit{SOS}) is a strategy of which every 's execution based on is SOE of .
\end{definition}

\subsection{Algorithms}
The way to compute  (or ) in \textbf{ConTS} is to find a spanning subgraph of \textbf{ConTS} satisfying following conditions:\\
. Each vertex's outdegree is 1;\\
. Each vertex's execution in this subgraph is its  (or ).

For backward inductive analysis, we firstly find SCC of \textbf{ConTS} based on Tarjan's algorithm \cite{reinhard} and construct \textbf{Abstraction} (\textbf{Abs} for short) by viewing each SCC as one vertex. (\textbf{Abs}) denotes the vertex set of \textbf{Abs} ranged over by . \textbf{Abs} is a DAG, and we rename  with  if its out-degree is 0, else with \textit{Non-Leave}. By convention, (\textbf{Abs}),  belongs to the SCC represented by .
\begin{definition}
, the \textsf{priority} of , denoted by \textit{prior}(D), is defined inductively:\\
(1) , if  is a , and  is the size of (\begin{bf}{Abs}\end{bf}).\\
(2)   is any direct successor of  in \begin{bf}Abs\end{bf}
\end{definition}

\begin{definition}
 \textsf{depends on}  if  appears in one of the paths starting from  in \begin{bf}Abs\end{bf}.
\end{definition}

\begin{Theorem}
If  then  does not depend on .
\end{Theorem}
\begin{proof}
We prove it by contradiction: if  depends on , then  appears in one of the paths starting from  in \begin{bf}Abs\end{bf}, so we have   is any direct successor of  in \begin{bf}Abs\end{bf}, contradiction.
\end{proof}

If  does not depend on , then computing \textit{NES/SOS} of  has no impaction on computing \textit{NES/SOS} of . To find \textit{NES/SOS} of  is to find \textit{NEE/SOE} of all .

The algorithms for computing  and , denoted as  and  respectively, are both based on backward induction. The framework of  is as follows:\\
(1) Compute priority of each vertex  in \textbf{Abs};\\
(2) Compute  for  firstly, then compute backward inductively for .\\
The framework of  is similar.

Pseudo code of  is shown in Algorithm \ref{algorithm}.

\begin{algorithm}[h]
\scriptsize
 \KwData{\textbf{Abs}}
 \KwResult{ of \textbf{Abs}}
 \;
 \For{(\begin{bf}{Abs}\end{bf})}{
  ComputePrior()\;
 }
 List  list of  in descending order on priority\;
 pointer \;
 \While{ is not the tail of }{
 \;
 \While{prior(D) is the highest in }{
 \;
 \;
 \;
 }
 \;
 \;
 \;
 }
 \caption{Pseudo code of ()}
 \label{algorithm}
\end{algorithm}

\textbf{NES/SOS for Leave}\\
The key point of computing  (or ) for   is to find a cycle in  satisfying conditions  and  as above.

\textbf{NES in Leave}: The method of finding  for   is a value iteration method, denoted as \textbf{NESinLeave}(). The value function is \textbf{BackInd}() which returns some edge  of  and \textbf{RefN}() is used to refresh the value of the weight pair for each edge of , .

As the narrative convenience, we introduce some auxiliary symbols: , the weight pair initializes with , and  is used to keep the new weight pair of  obtained by \textbf{RefN}() on the nth iteration; , , initialized with , is used to keep , where  is the result of \textbf{BackInd}() on the nth iteration. The iterative process will be continued until , .

The framework of \textbf{NESinLeave}() is as follows:\\
(1) Value iteration initializes with \textbf{BackInd}(), where for each , the weight pair of  is . Assuming  is the result obtained by \textbf{BackInd}(), then ;\\
(2) Loops through the method \textbf{RefN}() and \textbf{BackInd}() by order until , ;\\
(3) , execute \textbf{BackInd}(). The cycle obtained is what we want.

Rules of method \textbf{BackInd} on the nth iteration,  :\\
(1) Let ;\\
(2) If  satisfying , refresh  by filtering the edge ;\\
(3) Refresh  by keeping edge \\
(4) Return .

Rules in method \textbf{RefN} on the (n+1)th iteration, :\\
(1) , compute its   componentwise by following formula:

(2) Keep , ;

Pseudo code of \textbf{NESinLeave}(), \textbf{BackInd}() and \textbf{RefN}() are shown in Algorithm \ref{nesinleave}, \ref{backwardinduction} and \ref{refreshweip} respectively.
\begin{algorithm}[!h]
\scriptsize
 \KwData{ of \textbf{Abs}: }
 \KwResult{ of  }
 Label  with \begin{bf}NonConducted\end{bf}\;
 \;
 \While{ is \begin{bf}NonConducted\end{bf}}{
 \;
 \;
 Label  with \begin{bf}Conducted\end{bf}\;
 }
 \While{  componentwise}{
 \begin{bf}RefN\end{bf}() \;
 \;
 \;
 }
 \;
 \caption{Pseudo code of ()}
 \label{nesinleave}
\end{algorithm}

\begin{algorithm}[!h]
\scriptsize
 \KwData{}
 \KwResult{edge }
 create \;
 \While{ with }{
 \;
 }
 \;
 return \;
 \caption{Pseudo code of ()}
 \label{backwardinduction}
\end{algorithm}

\begin{algorithm}[!h]
\scriptsize
 \KwData{}
 \KwResult{, }
 Label all  with \begin{bf}NonRef\end{bf}\;
 \While{ is \begin{bf}NonRef\end{bf}}{
 \;
 \;
 Label  with \begin{bf}Ref\end{bf}\;
 }
 \caption{Pseudo code of ()}
 \label{refreshweip}
\end{algorithm}


\textbf{SOS in Leave}: The method \textbf{SOSinLeave}() used to find  for   is also a value iteration method. The \textit{value function} is \textbf{LocSoOp}() which returns some edge  of  and \textbf{RefS}() is used to refresh the absolute sum value of the weight pair for each edge of , .

Here are some other auxiliary symbols for convenience: , its sum of absolute weight pair initializes with , and  is used to keep the new sum of absolute weight pair of  obtained by \textbf{RefS}() on the nth iteration;  initialized with , is used to keep , where  is the result of \textbf{LocSoOp}() on the nth iteration. The iterative process will be continued until , .

The framework of \textbf{SOSinLeave}() is as follows:\\
(1) Value iteration initializes with \textbf{LocSoOp}(), where for , the sum of absolute weight pair of  is . Assuming the result obtained by \textbf{LocSoOp}() is , then ;\\
(2) Loops through the method \textbf{RefS}() and \textbf{LocSoOp}() by order until , ;\\
(3) , execute \textbf{LocSoOp}(). The cycle obtained is what we want.

Rules of method \textbf{LocSoOp} on nth iteration, :\\
(1) Compare , ;\\
(2) Return edge .

Rules of method \textbf{RefS} on (n+1)th iteration, : \\
(1) , compute its   by following formula:

(2) Keep , ;

Pseudo code of \textbf{SOSinLeave}(), \textbf{LocSoOp}() and \textbf{RefS}() are given in Algorithm \ref{sosinleave}, \ref{localsocialoptimal} and \ref{refreshsum} respectively.
\begin{algorithm}[!h]
\scriptsize
 \KwData{ of \textbf{Abs}: }
 \KwResult{ of  }
 Label  with \begin{bf}NonConducted\end{bf}\;
 \;
 \While{ is \begin{bf}NonConducted\end{bf}}{
  \begin{bf}LocSoOp\end{bf}()\;
 \;
 Label  with \begin{bf}Conducted\end{bf}\;
 }
 \While{ }{
 \begin{bf}RefS\end{bf}() \;
  \begin{bf}LocSoOp\end{bf}()\;
 \;
 }
 \;
 \caption{Pseudo code of ()}
 \label{sosinleave}
\end{algorithm}
\begin{algorithm}[!h]
\scriptsize
 \KwData{}
 \KwResult{edge }
 \While{ is not compared}{
 \;}
 return \;
 \caption{Pseudo code of ()}
 \label{localsocialoptimal}
\end{algorithm}
\begin{algorithm}[!h]
\scriptsize
 \KwData{}
 \KwResult{}
 Label all  with \begin{bf}NonRef\end{bf}\;
 \While{ is \begin{bf}NonRef\end{bf}}{
 \;
 Label  with \begin{bf}Ref\end{bf}\;
 }
 \caption{Pseudo code of ()}
 \label{refreshsum}
\end{algorithm}


\textbf{NES/SOS for Non-Leave}\\
\textbf{NES of Non-Leave}: For  vertex  in \textbf{Abs}, the method of computing its NES is \textbf{NESinNonLeave}() and its framework is as follows:\\
(1) if the size of  is more than 1, we will pre-process  with method \textbf{PrePro}() firstly, then get its  by \textbf{NESinLeave}();\\
(2) if  for some , then the  of  is the result obtained from \textbf{BackInd}() directly.

Rules in method \textbf{PrePro}() are as follows:\\
(1)  is one direct successor of  in \textbf{Abs}, and if the edge  connecting  and  is contributed by the connection between  and , then  componentwise, where  is the nash equilibrium execution of ;\\
(2) Change  to be the self-loop edge of .

Pseudo code of \textbf{NESinNonLeave}() and \textbf{PrePro}() are shown in Algorithm \ref{nesinnonleave} and Algorithm \ref{preprocess} respectively.
\begin{algorithm}[!h]
\scriptsize
 \KwData{: }
 \KwResult{ of }
 \;
 \eIf{the size of  is bigger than 1}{
  \begin{bf}PrePro()\end{bf}\;
 \begin{bf}NESinLeave()\end{bf}\;
 }
 {
 \begin{bf}BackInd\end{bf}(), if \;
 }
 \caption{Pseudo code of }
 \label{nesinnonleave}
\end{algorithm}

\begin{algorithm}[!h]
\scriptsize
 \KwData{: }
 \KwResult{new }
 \;
 \While{ with endpoint }{
 \;
 \;
 Change  to be self-loop edge of \;
 }
 \;
 Return \;
 \caption{Pseudo code of }
 \label{preprocess}
\end{algorithm}
\textbf{SOS of Non-Leave}: The method \textbf{SOSinNonLeave}() computing  for   is identical to \textbf{NESinNonLeave}() except for the preprocessing method \textbf{PreProS}(). The computing steps of \textbf{PreProS}() are as follows: \\
(1)  is one direct successor of  in \textbf{Abs}, if the edge  connecting  and  is contributed by connection between  and , then , where  is social optimal execution of ;\\
(2) Change  to be self-loop edge of .

Pseudo code of \textbf{SOSinNonLeave}() and \textbf{PreProS}() is shown in Algorithm \ref{sosinnonleave} and Algorithm \ref{preprocessforSOS} respectively in Appendix.
\begin{algorithm}[!h]
\scriptsize
 \KwData{: }
 \KwResult{ of }
 \;
 \eIf{the size of  is bigger than 1}{
  \begin{bf}PreProS()\end{bf}\;
 \begin{bf}SOSinLeave()\end{bf}\;
 }
 {
 \begin{bf}LocSoOp\end{bf}(), if \;
 }
 \caption{Pseudo code of }
 \label{sosinnonleave}
\end{algorithm}
\begin{algorithm}[!h]
\scriptsize
 \KwData{: }
 \KwResult{new }
 \;
 \While{ with endpoint }{
 \;
 Change  to be self-loop edge of \;
 }
 \;
 Return \;
 \caption{Pseudo code of }
 \label{preprocessforSOS}
\end{algorithm}

\subsection{Correctness of Algorithms}

\textbf{Correctness of \textbf{NESinLeave}()}\\
Inspired by a technique in dynamic programming which is called \textit{value-iteration} \cite{vander, ls}, \textbf{BackInd}() is formalized as a mapping , on kth iteration, . \textbf{RefN}() defines a set of vertex  denotes  with  whose weight pair is refreshed by the rule componentwise: . According to the rules of \textbf{NESinLeave}(),   for any . It is convenient to define the shorthand operator notation , that is .

\begin{Lemma}
\label{provenesterminatedpre}
For any , we have


\end{Lemma}

\begin{proof}
We prove by contradiction for the first inequality in details. According to the rules in \textbf{BackInd}(), we need to consider all possible results obtained by \textbf{BackInd}() on kth and (k+1)th iteration respectively. The details are shown in Appendix. The proof for the second inequality is similar.
\end{proof}

\begin{Lemma}
\label{provenesterminated}
 is a contraction.
\end{Lemma}
\begin{proof}
For any real vector ,  is an index set, let . According to Lemma \ref{provenesterminatedpre}, then we have

similar proof for . Therefore, we claim that , satisfying .
\end{proof}

\begin{Theorem}
\label{provenesinleave}
If  is a  of \textbf{Abs}, then the result obtained by \textbf{NESinLeave}() is  of .
\end{Theorem}
\begin{proof}
We need to prove two issues: \\
1. \begin{bf}NESinLeave\end{bf}() is terminated.\\
2. The execution of , , based on the result of \textbf{NESinLeave}() is its nash equilibrium execution.\\
The details are shown in Appendix.
\end{proof}

\textbf{Correctness of \textbf{SOSinLeave}()}\\
The way to prove the correctness of \textbf{SOSinLeave}() is similar to that of \textbf{NESinLeave}(). We will give the outline of the proofs.

We can formalize \textbf{LocSoOp}() as a mapping , so on kth iteration, we have . \textbf{RefS}() defines a set of vertex  denotes  with  whose sum of absolute weight pair is refreshed by the rule: . According to the rules of  \textbf{SOSinLeave}(), for any ,  . It is convenient to define another shorthand operator notation , that is . By the same way as Lemma \ref{provenesterminatedpre} and Lemma \ref{provenesterminated}, we can prove operator  is a contraction.

\begin{Lemma}
\label{provesosterminatedpre}
For any , we have\\

\end{Lemma}

\begin{proof}
The proof is similar to that of Lemma \ref{provenesterminatedpre}.
\end{proof}

\begin{Lemma}
\label{provesosterminated}
 is a contraction.
\end{Lemma}

\begin{proof}
The proof is similar to that of Lemma \ref{provenesterminated}.
\end{proof}
\begin{Theorem}
If  is a  of \textbf{Abs}, then the result obtained by \textbf{SOSinLeave}() is  of .
\end{Theorem}
\begin{proof}
The proof is similar to that of Theorem \ref{provenesinleave}.
\end{proof}

\textbf{Correctness of AlgNES() and AlgSOS()}
\begin{Theorem}
The results obtained from \textbf{AlgNES(Abs)} and \textbf{AlgSOS(Abs)} are  and  of \textbf{Abs} respectively.
\end{Theorem}
\begin{proof}
We prove the correctness of \textbf{AlgNES(Abs)} in details. Prove inductively on priority of vertex  in \textbf{Abs}.\\
(1) If  is a , we need to prove the result of \textbf{NESinLeave}() is  of , according to Theorem \ref{provenesinleave}, trivial;\\
(2) For  , and we assume , by induction hypothesis,  has got its NES by \textbf{AlgNES}(). If  for some , according to the definition of  and rules of \textbf{BackInd}(), the proof is trivial; if the size of  is bigger than 1, according to the theorem \ref{provenesinleave}, trivial.
\end{proof}

\section{Case study}
The details of the example we used can be found in \cite{klye}. It shows a local network connected to Internet (see Figure \ref{example}). By the assumption that the firewall is unreliable, and the operating system on the machine is insufficiently hardened, the attacker has chance to pretend as a root user in web server and steal or damage data stored in private file server and private workstation.
\begin{figure}[!htpb]
\begin{center}
\includegraphics[scale=0.32]{figures/example.png}
\caption{Case study}
\label{example}
\end{center}
\end{figure}
The state set  of example is shown in Table \ref{state}; ,  is given in Table \ref{attckeraction} and Table \ref{defenderaction} respectively; for convenience, we will mostly refer to the states and actions using their symbolic number; state transition probability is shown in Table \ref{statetransition}, in which ; the immediate payoff to attacker and defender at each state is shown in Table \ref{rewardcost}, in which  and , where  means any action available at current state.

\subsection{Modeling for Case study}
We modeling for state  in \textbf{ComModel} as example, then we have , ,  as follows:


We find three pairs of states which are probabilistic bisimilar: ,  and . Figure \ref{ComModelcasestudy} shows the \textbf{ConTS} of case study.

\begin{figure}[htpb]
\begin{center}
\includegraphics[scale=0.32]{figures/ComModelExample.pdf}
\caption{ConTS of Example}
\label{ComModelcasestudy}
\end{center}
\end{figure}

\subsection{Analyzing NES/SOS for Case study}
We implement the algorithms using Java in Eclipse development environment on machine with 3.4GHz Inter(R) Core(TM) i72.99G RAM.
We get two Nash Equlibrium Strategies and one Social Optimal strategy for our case study, shown in Figure \ref{nash1}, \ref{nash2}, \ref{sos}  respectively.
\begin{figure}[!htb]
\begin{center}
\includegraphics[scale=0.3]{figures/NEE1.pdf}
\caption{Nash Equilibrium strategy 1}
\label{nash1}
\end{center}
\end{figure}

\begin{figure}[!htb]
\begin{center}
\includegraphics[scale=0.3]{figures/NEE2.pdf}
\caption{Nash Equilibrium strategy 2}
\label{nash2}
\end{center}
\end{figure}

\begin{figure}[!htb]
\begin{center}
\includegraphics[scale=0.3]{figures/SOS.pdf}
\caption{Social Optimal strategy}
\label{sos}
\end{center}
\end{figure}

\subsection{Evaluation}
We compare our results with those obtained in \cite{klye} by game-theoretic approach: \\
(1) We filter the invalid Nash Equilibrium strategy from the results in \cite{klye}. We filter the action pair \textit{(,   )} at state  and the action pair \textit{(  , Compromised\_account\_ restart\_\textit{ftpd}} at  which obtained in the second Nash Equilibrium strategy in \cite{klye} but have no practical state transition.\\
(2) We minimize the state space by probabilistic bisimulation while   \cite{klye} focuses on the whole state set. Time consumed to compute Nash Equilibrium strategy and Social Optimal strategy for this example with our approach is shown in Table 2. Although it is incomparable with the time consumed in \cite{klye} because of evaluating on different machine models, our approach should be faster theoretically.

\begin{table}[htpd]
\centering
\scriptsize
\label{comsume}
\begin{tabular}{ccc}\hline
ComModel& Nash Equilibrium & Social Optimal\\
Creation &  strategy &  strategy \\\hline
2.8s & 3.7s & 1.4s\\\hline
\end{tabular}
\caption{Time consumed for example with our approach}
\end{table}

\section{Conclusion}
We proposed a probabilistic value-passing CCS (PVCCS) approach for modeling and analyzing a typical network security scenario with one attacker and one defender which is usually modeled by perfect and complete information game.
Extention of this method might provide uniform framework for modelling and analyzing network security scenarios which are usually modeled via different games.
We designed two algorithms for computing Nash Equilibrium strategy and Social Optimal strategy based on this PVCCS approach and on graph-theoretic methods. Advantages of these algorithms are also discussed.

\bibliographystyle{abbrv}
\bibliography{reference}

\newpage
\appendix

\section{Proofs of Theorems}
Proof of Theorem \ref{payoffconverged}
\begin{proof}
As vertex set  is finite, then any infinite execution  of  is in form of  which means ending with a cycle starting with , and  is the number of vertex on this cycle except , then we have

\end{proof}
Proof of Lemma \ref{provenesterminatedpre}
\begin{proof}
Assuming without loss of generality,  and , where , . Let , ,  and , where , , ,  are positive number.\\
\textbf{case 1}: \\
According to the rules of \textbf{BackInd}(), we have  and . If the first inequality in lemma doesn't hold, then we have  and , then we get  and  which deduce , contradiction.\\
\textbf{case 2}: \\
Let us define two conditions:\\
Cond 1: on kth iteration,  is kept by step (2) of \textbf{BackInd}(). \\
Cond 2: on (k+1)th iteration,  is kept by step (2) of \textbf{BackInd}().\\
There are four subcases to be considered:\\
\textbf{}: both Cond 1 and Cond 2\\
According to the rules of \textbf{BackInd}(), we have  and . If  and , then we get , contradiction. \\
\textbf{}: not Cond 2 but Cond 1 \\
According to the rules of \textbf{BackInd}(),  with . Assuming  and , then we have ,  and . If  and , then we have  and . If , it is trivial to get contradiction; If , then we have  and , then we have  and . If , then we have , contradiction; If , contradiction. \\
\textbf{}: not Cond 1 but Cond 2\\
According to the rules of \textbf{BackInd}(),  with . proof is similar to \textbf{}.\\
\textbf{}: neither Cond 1 nor Cond 2\\
According to the rules of \textbf{BackInd}(),  with  and . Assuming  and , and , then we have , ,  and . If  and , then we have  and . If  and , then we have  and , and if , then we , contradiction; If  and  or  and , it is trivial to get contradiction; If  and , then we get  and , and if , then we get , contradiction.\\
Proof for second inequality is similar. We skip the details.\\
\end{proof}

Proof for Theorem \ref{provenesinleave}.
\begin{proof}
We need to prove two issues: \\
1. \begin{bf}NESinLeave\end{bf}() is terminated.\\
The way to prove termination of \begin{bf}NESinLeave\end{bf}() is to prove  that after kth iteration, .
According to Lemma \ref{provenesterminated}, trivial;\\
2. The result of \begin{bf}NESinLeave\end{bf}() is  of . , assuming  whose first edge is  is the execution of  based on the result obtained by \begin{bf}NESinLeave\end{bf}(), we need to prove  is  of  coinductively. As  is ended by a cycle, we just need to prove any  on , , is the first edge of \textit{NEE} of . We prove edge  of  as example. If  is not \textit{NEE} of , according to the definition of \textit{NEE}, there exists  satisfying:
(1)  where  or
(2)  where , and both of them are contradicted with the rules in \textbf{BackInd}().\\
\end{proof}

\section{Tables of case study}
To make paper self-contained, we list the data related in example created in \cite{klye}.
\newcounter{Rownumber}
\newcommand{\Rown}{\stepcounter{Rownumber}\theRownumber}
\begin{table}[htbp]
\scriptsize
\centering
\begin{tabular}{cc}\hline
State number & State name\\\hline
\Rown        & \\
\Rown        & \\
\Rown        & \\
\Rown        & \\
\Rown        & \\
\Rown        & \\
\Rown        & \\
\Rown        & \\
\Rown        & \\
\Rown        & \\
\Rown        & \\
\Rown        & \\
\Rown        & \\
\Rown        & \\
\Rown        & \\
\Rown        & \\
\Rown        & \\
\Rown        & \\
\hline
\end{tabular}
\caption{\label{state}Network state}
\end{table}

\newcounter{Rownumbera}
\newcommand{\Rowna}{\stepcounter{Rownumbera}\theRownumbera}
\renewcommand{\multirowsetup}{\centering}
\begin{table}[htpb]
\scriptsize
\centering
\begin{tabular}{cccc}\hline
  &  1      &  2       & 3         \\
Action no.             &         &          &           \\\hline
\Rowna                 &   &    &     \\
\Rowna                 &   &    &     \\
\Rowna                 &   &  &   \\
                       &    &    &   \\
\Rowna                 &   &       &   \\
                       &  &   &  \\
\Rowna                 &   &    &   \\
                       &   &  &    \\
\Rowna                 &   &    &   \\
                       &   &  &  \\
\Rowna                 &   &       &   \\
                       &   &   &   \\
\Rowna                 &   &       &   \\
\Rowna                 &   &       &   \\
                       &   &     &   \\
\Rowna                 &   &       &    \\
                       &   &   &   \\
\Rowna                 &   &       &   \\
                       &   &   &   \\
\Rowna                 &   &       &   \\
                       &   &    &   \\
\Rowna                 &   &       &   \\
\Rowna                 &   &       &   \\
                       &  &  &  \\
\Rowna                 &   &       &   \\
\Rowna                 &   &       &   \\
                       &   & & \\
\Rowna                 &   &       &   \\
\Rowna                 &   &       &   \\
\hline
\end{tabular}
\caption{\label{defenderaction} Defender's action set}
\end{table}

\newcounter{Rownumberb}
\newcommand{\Rownb}{\stepcounter{Rownumberb}\theRownumberb}
\begin{table}[htbp]
\scriptsize
\centering
\begin{tabular}{cccc}\hline
  &  1      &  2       & 3         \\
Action no.             &         &          &           \\\hline
\Rownb                 &   &       &   \\
\Rownb                 &   &       &   \\
                       &   &  &  \\
\Rownb                 &   &       &   \\
                       &    &  &  \\
\Rownb                 &   &       &   \\
                       &    &  &  \\
\Rownb                 &   &       &   \\
                       &    &   &  \\
\Rownb                 &   &       &   \\
                       &   &  &  \\
\Rownb                 &   &    &     \\
\Rownb                &   &   &   \\
                       &  & & \\
\Rownb                 &   &    &     \\
\Rownb                 &   &    &     \\
\Rownb                 &   &    &     \\
\Rownb                 &   &    &     \\
\Rownb                 &   &    &     \\
                       &  &  &  \\
\Rownb                 &   &    &     \\
                       &  &  &  \\
\Rownb                 &   &    &     \\
                       &  &  &  \\
\Rownb                 &   &    &     \\
                       &  &  &  \\
\Rownb                 &   &    &     \\
\Rownb                 &   &    &     \\
\hline
\end{tabular}
\caption{\label{attckeraction} Attacker's action set}
\end{table}

\begin{table}[htbp]
\centering
\scriptsize
\begin{tabular}{ll}\hline
           &  \\
                 &   \\
                 &\\
              &\\
          &\\
          &\\
          &\\
          &\\
          &\\
          &\\
          &\\
          &\\
          &\\
          &\\
          &\\
          &\\
                 &   \\
                 &   \\
\hline
\end{tabular}
\caption{\label{rewardcost} Immediate payoff to Attacker and Defender}
\end{table}

\begin{table}[htbp]
\scriptsize
\centering
\begin{tabular}{lll}\hline
         &        &\\
                &             &\\
                &             &\\
                &             &\\
                &             &\\
                &             &\\
         &        &\\
                &             &\\
                &             &\\
                &             &\\
                &             &\\
                &             &\\
                &             &\\
         &        &\\
                &             &\\
                &             &\\
                &             &\\
         &        &\\
                &             &\\
                &             &\\
                &             &\\
         &        &\\
                &             &\\
                &             &\\
                &             &\\
                &             &\\
                &             &\\
                &             &\\
         &        &\\
                &             &\\
                &             &\\
                &             &\\
                &             &\\
                &             &\\
                &             &\\
\hline
\end{tabular}
\caption{\label{statetransition} State transition probabilities}
\end{table}
\\

\section{Notation Index}
\begin{table}[htbp]
\small
\begin{tabular}{ll}
& \\
& \\
& \\
& \\
& \\
& \\
&\\
& \\
&\\
&\\
& \\
& \\
& \\
& \\
& \\
\end{tabular}
\end{table}
\end{document}
