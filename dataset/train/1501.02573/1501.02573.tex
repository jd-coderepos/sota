\documentclass{llncs}
\let\proof\relax
\let\endproof\relax
\usepackage{times}\usepackage{amsthm}
\usepackage{booktabs}
\usepackage{rotating}
\usepackage{xcolor}
\definecolor{darkred}{rgb}{0.7, 0.0, 0.0}
\usepackage{caption}
\usepackage{listings}
\usepackage{xspace}
\usepackage{hyperref}
\usepackage{amsfonts}
\usepackage{amsmath}
\newcommand{\comment}[1]{}
\newcommand{\cwnote}[1]{\textcolor{red}{\textbf{CW says: #1}}}
\newcommand{\rbnote}[1]{\textcolor{blue}{\textbf{RB says: #1}}}
\newcommand{\bknote}[1]{\textcolor{blue}{\textbf{BK says: #1}}}
\newcommand{\rknote}[1]{\textcolor{blue}{\textbf{RK says: #1}}}
\usepackage{amssymb}
\usepackage{temporal}
\usepackage{hyperref}
\usepackage{breakurl}
\usepackage{stmaryrd}
\usepackage{enumerate}
\usepackage{wrapfig} 

\newcounter{exacounter}
\newenvironment{exa}{
\refstepcounter{exacounter}
\smallskip\noindent
\textbf{Example \theexacounter.}
}{\vspace{2mm}}



\usepackage{tikz}
\usetikzlibrary{arrows,automata}
\newcommand{\nd}{3cm} \tikzset{initial text={}}
\tikzset{every picture/.style=semithick} \tikzset{>=stealth'} \tikzset{->} \tikzset{shorten >=1pt} 


\newcommand{\buchi}{B\"uchi\xspace}
\newcommand{\win}{\mathsf{win}}
\newcommand{\B}{\mathbb{B}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\NI}{\mathbb{N}^{\infty}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Rp}{\mathbb{R}^+}
\newcommand{\design}{\mathcal{D}}
\newcommand{\shield}{\mathcal{S}}
\newcommand{\game}{\mathcal{G}}
\newcommand{\obj}{\mathsf{obj}}
\newcommand{\gstates}{G}
\newcommand{\ginit}{g_0}
\newcommand{\states}{Q}
\newcommand{\init}{q_0}
\newcommand{\din}{I}
\newcommand{\dinalph}{\Sigma_I}
\newcommand{\dinletter}{{\sigma_I}}
\newcommand{\dintrace}{{\overline{\sigma_I}}}
\newcommand{\dout}{O}
\newcommand{\sout}{{O'}}
\newcommand{\doutalph}{\Sigma_O}
\newcommand{\doutletter}{{\sigma_O}}
\newcommand{\douttrace}{{\overline{\sigma_O}}}
\newcommand{\dalph}{\Sigma}
\newcommand{\dletter}{\sigma}
\newcommand{\dtrace}{\overline{\dletter}}
\newcommand{\lang}{L}
\newcommand{\langset}{\mathcal{L}}
\newcommand{\spec}{\varphi}
\newcommand{\specv}{\varphi^v}
\newcommand{\distt}{d^\sigma}
\newcommand{\distl}{d^L}
\newcommand{\distta}{\mathcal{M}}
\newcommand{\distla}{\mathcal{N}}
\newcommand{\ds}{\mathsf{d2s}}
\newcommand{\sd}{\mathsf{s2d}}
\newcommand{\prop}{\mathsf{prop}}
\newcommand{\pr}{\mathsf{pr}}
\newcommand{\kin}{\!\in\!}
\newcommand{\err}{{\color{darkred}}}
\newcommand{\comp}{\circ}

\bibliographystyle{plain}

 \newif \ifextended
\usepackage{makeidx}  \begin{document}
\extendedtrue
\frontmatter          \pagestyle{plain}
\mainmatter              \title{Shield Synthesis:}
\subtitle{Runtime Enforcement for Reactive Systems\thanks{This work was supported in part by the Austrian Science Fund
  (FWF) through the research network RiSE (S11406-N23) and by the
  European Commission through project STANCE (317753). Chao Wang is
  supported by the National Science Foundation grant CNS-1128903.}}
\titlerunning{Shield Synthesis}  \author{Roderick Bloem\inst{1} \and
        Bettina K\"onighofer\inst{1} \and
        Robert K\"onighofer\inst{1} \and
        Chao Wang\inst{2}}
\authorrunning{Roderick Bloem et al.} \institute{
    IAIK, Graz University of Technology,  Austria\\
    Department of ECE, Virginia Tech, Blacksburg, VA 24061, USA
          }

\maketitle              


\begin{abstract}
Scalability issues may prevent users from verifying critical properties 
of a complex hardware design.  In this situation, we propose to 
synthesize a ``safety shield'' that is attached to the design to enforce 
the properties at run time.  \emph{Shield synthesis} can succeed where 
model checking and reactive synthesis fail, because it only considers a 
small set of critical properties, as opposed to the complex design, or 
the complete specification in the case of reactive synthesis. The shield 
continuously monitors the input/output of the design and corrects its 
erroneous output only if necessary, and as little as possible, so other 
non-critical properties are likely to be retained.  Although runtime 
enforcement has been studied in other domains such as action systems, 
reactive systems pose unique challenges where the shield must act 
without delay.  We thus present the first shield synthesis solution for 
reactive hardware systems and report our experimental results.
\ifextended
This is an extended version of~\cite{conference}, featuring an 
additional appendix.
\fi
\end{abstract}

\section{Introduction}

Model checking~\cite{Clarke81,Quiell81} can formally verify that a 
design satisfies a temporal logic specification.  Yet, due to 
scalability problems, it may be infeasible to prove all critical 
properties of a complex design.  Reactive 
synthesis~\cite{Pnueli89,BloemJPPS12} is even more ambitious since it 
aims to generate a provably correct design from a given specification. 
In addition to scalability problems, reactive synthesis has the drawback 
of requiring a complete specification, which describes every aspect of 
the desired design.  However, writing a complete specification can 
sometimes be as hard as implementing the design itself.


\begin{wrapfigure}[7]{r}{0.45\textwidth}
\vspace{-0.6cm}
\includegraphics[width=0.45\textwidth]{figs/attach_shield}
\caption{Attaching a safety shield.\\}
\label{fig:attach_shield}
\end{wrapfigure}

We propose \emph{shield synthesis} as a way to complement model checking 
and reactive synthesis.  Our goal is to enforce a small set of critical 
properties at runtime even if these properties may occasionally be 
violated by the design.  Imagine a complex design and a set of 
properties that cannot be proved due to scalability issues or other 
reasons (e.g., third-party IP cores). In this setting, we are in good 
faith that the properties hold but we need to have certainty.  We would 
like to automatically construct a component, called the \emph{shield}, 
and attach it to the design as illustrated in 
Fig.~\ref{fig:attach_shield}. The shield monitors the input/output of 
the design and corrects the erroneous output values instantaneously, but 
only if necessary and as little as possible.

The shield ensures both \emph{correctness} and \emph{minimum 
interference}.  By correctness, we mean that the properties must be 
satisfied by the combined system, even if they are occasionally violated 
by the design.  By minimum interference, we mean that the output of the 
shield deviates from the output of the design only if necessary, and the 
deviation is kept minimum.  The latter requirement is important because 
we want the design to retain other (non-critical) behaviors that are not 
captured by the given set of properties.  We argue that shield synthesis 
can succeed even if model checking and reactive synthesis fail due to 
scalability issues, because it has to enforce only a small set of 
critical properties, regardless of the implementation details of a 
complex design. 

This paper makes two contributions. First, we define a general framework 
for solving the shield synthesis problem for reactive hardware systems. 
Second, we propose a new synthesis method, which automatically 
constructs a shield from a set of safety properties. To minimize 
deviations of the shield from the original design, we propose a new 
notion called \emph{-stabilization}:  When the design arrives at a 
state where a property violation becomes unavoidable for some possible 
future inputs, the shield is allowed to deviate for at most  
consecutive steps.  If a second violation happens during the -step 
recovery phase, the shield enters a \emph{fail-safe} mode where it only 
enforces correctness, but no longer minimizes the deviation. We show 
that the -stabilizing shield synthesis problem can be reduced to 
\emph{safety games}~\cite{Mazala01}. Following this approach, we present a 
proof-of-concept implementation and give the first experimental 
results.

Our work on shield synthesis can complement model checking by enforcing 
any property that cannot be formally proved on a complex design.  There 
can be more applications.  For example, we may not trust third-party IP 
components in our system, but in this case, model checking cannot be 
used because we do not have the source code. Nevertheless, a shield can 
enforce critical interface assumptions of these IP components at run 
time.
Shields may also be used to simplify certification.  Instead of 
certifying a complex design against critical requirements, we can 
synthesize a shield to enforce them, regardless of the behavior of the 
design.  Then, we only need to certify this shield, or the synthesis 
procedure, against the critical requirements.
Finally, shield synthesis is a promising new direction for synthesis in 
general, because it has the strengths of reactive synthesis while 
avoiding its weaknesses --- the set of critical properties can be small 
and relatively easy to specify --- which implies scalability and 
usability.


\noindent \textbf{Related work.}  
Shield synthesis is different from recent works on reactive 
synthesis~\cite{Pnueli89,BloemJPPS12,EhlersT14}, which revisited 
Church's problem~\cite{Church63,Buchi69,Rabin72} on constructing correct 
systems from logical specifications. Although there are some works on 
runtime enforcement of properties in other 
domains~\cite{Schneider00,LigattiBW09,FalconeFM12}, they are based on 
assumptions that do not work for reactive hardware systems. 
Specifically, Schneider~\cite{Schneider00} proposed a method that simply 
halts a program in case of a violation.  Ligatti et 
al.~\cite{LigattiBW09} used edit automata to suppress or insert actions, 
and Falcone et al.~\cite{FalconeFM12} proposed to buffer actions and 
dump them once the execution is shown to be safe. None of these 
approaches is appropriate for reactive systems where the shield must act 
upon erroneous outputs on-the-fly, i.e., without delay and without 
knowing what future inputs/outputs are.  In particular, our shield 
cannot insert or delete time steps, and cannot halt in the case 
of a violation.

Methodologically, our new synthesis algorithm builds upon the existing 
work on synthesis of robust systems~\cite{BloemCGHHJKK14}, which aims to 
generate a complete design that satisfies as many properties of a 
specification as possible if assumptions are violated.  However, our 
goal is to synthesize a shield component , which can be attached to 
any design , to ensure that the combined system  
satisfies a given set of critical properties.  Our method aims at 
minimizing the ratio between shield deviations and property violations 
by the design, but achieves it by solving pure safety games.  
Furthermore, the synthesis method in \cite{BloemCGHHJKK14} uses 
heuristics and user input to decide from which state to continue 
monitoring the environmental behavior, whereas we use a subset 
construction to capture all possibilities to avoid unjust verdicts by 
the shield.  We use the notion of -stabilization to quantify the 
shield deviation from the design, which has similarities to Ehlers and 
Topcu's notion of -resilience in robust synthesis~\cite{EhlersT14} 
for GR(1) specifications~\cite{BloemJPPS12}.  However, the context of 
our work is different, and our -stabilization limits the length of 
the recovery period instead of tolerating bursts of up to  glitches.


\noindent \textbf{Outline.}  
The remainder of this paper is organized as follows.  We illustrate the 
technical challenges and our solutions in Section~\ref{sec:ex} using an 
example.  Then, we establish notation in Section~\ref{sec:prelim}.  We 
formalize the problem in a general framework for shield synthesis in 
Section~\ref{sec:frame}, and present our new method in 
Section~\ref{sec:sol}.  We present our experimental results in 
Section~\ref{sec:exp} and, finally, give our conclusions in 
Section~\ref{sec:conc}.

\section{Motivation}
\label{sec:ex}

In this section, we illustrate the challenges associated with shield 
synthesis and then briefly explain our solution using an example.  
We start with a traffic light controller that handles a single crossing 
between a highway and a farm road.  There are red (\textsf{r}) or green 
(\textsf{g}) lights for both roads.  An input signal, denoted 
, indicates whether an emergency vehicle is 
approaching.  The controller takes  as input and returns 
 as output.  Here,  and 
 are the lights for highway and farm road, 
respectively.
Although the traffic light controller interface is simple, the actual 
implementation can be complex.  For example, the controller may have to 
be synchronized with other traffic lights, and it can have input sensors 
for cars, buttons for pedestrians, and sophisticated algorithms to 
optimize traffic throughput and latency based on all sensors, the time 
of the day, and even the weather.  As a result, the actual design may 
become too complex to be formally verified.  Nevertheless, we want to 
ensure that a handful of safety critical properties are satisfied with 
certainty.  Below are three example properties:
\begin{enumerate}
\item The output \textsf{gg} --- meaning that both roads have green
  lights --- is never allowed.
\item If an emergency vehicle is approaching (), the
  output must be \textsf{rr}.
\item The output cannot change from \textsf{gr} to \textsf{rg}, or
  vice versa, without passing \textsf{rr}.
\end{enumerate}
We want to synthesize a safety shield that can be attached to any 
implementation of this traffic light controller, to enforce these 
properties at run time.

In a first exercise, we only consider enforcing Properties 1 and 2.  
These are simple invariance properties without any temporal aspects.  
Such properties can be represented by a truth table as shown in 
Fig.~\ref{fig:traffic_spec2} (left). We use 0 to encode \textsf{r}, and 
1 to encode \textsf{g}.  Forbidden behavior is marked in bold red.  The 
shield must ensure both correctness and
minimum interference. That is, it should only change the output for red
entries. 
\begin{wrapfigure}[9]{r}{0.52\textwidth}
\vspace{-0.7cm}
\begin{minipage}{0.21\textwidth}
\centering
{\scriptsize \tt
\begin{tabular}{ccc|cc}\hline
    \textsf{p}~ & \textsf{h}~ & \textsf{f}~ & ~\textsf{h'} & 
~\textsf{f'} \\\hline
    0~ & 0~ &  0~ &  ~0 &  0\\ 
    0~ & 0~ &  1~ &  ~0 &  1\\
    0~ & 1~ &  0~ &  ~1 &  0\\
    0~ & \textcolor{darkred}{\bf 1}~ &\textcolor{darkred}{\bf 1}~ & 
~\textcolor{blue}{\bf 1} & \textcolor{blue}{\bf 0}\\
\hline
    1~ & 0~ &  0~ &  ~0 &  0\\ 
    1~ & \textcolor{darkred}{\bf 0}~ &\textcolor{darkred}{\bf 1}~ & 
~\textcolor{blue}{\bf 0} & \textcolor{blue}{\bf 0}\\
    1~ & \textcolor{darkred}{\bf 1}~ &\textcolor{darkred}{\bf 0}~ & 
~\textcolor{blue}{\bf 0} & \textcolor{blue}{\bf 0}\\
    1~ & \textcolor{darkred}{\bf 1}~ &\textcolor{darkred}{\bf 1}~ & 
~\textcolor{blue}{\bf 0} & \textcolor{blue}{\bf 0}\\
\hline
\end{tabular}
}
\end{minipage}

\begin{minipage}{.27\textwidth}
\centering
{\scriptsize \tt
\\
\\
}
\verb' '\\
\scalebox{.5}{\begin{picture}(0,0)\includegraphics{./shield_spec2.pstex}\end{picture}\setlength{\unitlength}{3947sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(2324,1565)(1179,-1122)
\put(1201,-811){\makebox(0,0)[lb]{\smash{{\SetFigFont{14}{16.8}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1201,-300){\makebox(0,0)[lb]{\smash{{\SetFigFont{14}{16.8}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1201,239){\makebox(0,0)[lb]{\smash{{\SetFigFont{14}{16.8}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3241,164){\makebox(0,0)[lb]{\smash{{\SetFigFont{14}{16.8}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3241,-511){\makebox(0,0)[lb]{\smash{{\SetFigFont{14}{16.8}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} }
\end{minipage}
\caption{Enforcing Properties 1 and 2.}
\label{fig:traffic_spec2}
\end{wrapfigure} 
In particular, it should not ignore the design and hard-wire 
the output to \textsf{rr}.  When  but the output is not 
, the shield must correct the output to .  
When  but the output is \textsf{gg}, the shield must turn 
the original output \textsf{gg} into either \textsf{rg}, \textsf{gr}, or 
\textsf{rr}.  Assume that \textsf{gr} is chosen.  As illustrated in 
Fig.~\ref{fig:traffic_spec2} (right),  we can construct the transition 
functions  and , as 
well as the shield circuit accordingly.

Next, we consider enforcing Properties 1--3 together.  Property 3 
brings in a temporal aspect, so a simple truth table does not suffice 
any more. Instead, we express the properties by an automaton, which is 
shown in Fig.~\ref{fig:traffic_spec}. Edges are labeled by values of 
, where  is the controller's input 
and  are outputs for highway and farm road.  
\begin{wrapfigure}[6]{r}{0.45\textwidth}
\vspace{-0.9cm}
\scalebox{0.95}{\begin{tikzpicture}[auto,node distance=\nd]
\node[state,initial]  at  (0,0)       (H) {H};
\node[state]          at  (1.8,0)       (B) {B};
\node[state]          at  (3.6,0)       (F) {F};

\path
(H) edge [loop above]  node[xshift=-4.5mm,yshift=-4mm] {\textsf{0gr}} (H)
(B) edge [loop above]  node[xshift=-4mm,yshift=-3mm] {\textsf{-rr}} (B)
(F) edge [loop above]  node[xshift=-4.5mm,yshift=-4mm] {\textsf{0rg}} (F)
(H) edge [bend left]   node[xshift=0mm,yshift=-1mm] {\textsf{-rr}} (B)
(B) edge [bend left]   node[xshift=0mm,yshift=5mm] {\textsf{0gr}} (H)
(F) edge [bend left]   node[xshift=0mm,yshift=4mm] {\textsf{-rr}} (B)
(B) edge [bend left]   node[xshift=-1mm,yshift=-1mm] {\textsf{0rg}} (F);
\end{tikzpicture}
%
 }
\caption{Traffic light specification.}
\label{fig:traffic_spec}
\end{wrapfigure}
There are three non-error states: H denotes the state where highway has 
the green light, F denotes the state where farm road has the green 
light, and B denotes the state where both have red lights.  There is 
also an error state, which is not shown. Missing edges lead to this 
error state, denoting forbidden situations, e.g., \textsf{1gr} is not 
allowed in state H.
Although the automaton still is not a complete specification, the 
corresponding shield can prevent catastrophic failures.  By 
automatically generating a small shield as shown in 
Fig.~\ref{fig:attach_shield}, our approach has the advantage of 
combining the functionality and performance of the aggressively 
optimized implementation with guaranteed safety.

While the shield for Property 1 and 2 could be realized by purely 
combinational logic, this is not possible for the specification in 
Fig.~\ref{fig:traffic_spec}.  The reason is the temporal aspect brought 
in by Property 3.
For example, if we are in state F and observe \textsf{0gg}, which is not 
allowed, the shield has to make a correction in the output signals to 
avoid the violation.  There are two options: changing the output from 
\textsf{gg} to either \textsf{rg} or \textsf{rr}.  However, this fix may 
result in the next state being either B or F.  The question is, without 
knowing what the future inputs/outputs are, how do we decide \emph{from 
which state the shield should continue to monitor} the behavior of the 
design in order to best detect and correct future violations?  If the 
shield makes a wrong guess now, it may lead to a suboptimal 
implementation that causes unnecessarily large deviation in the future.


To solve this problem, we adopt the most conservative approach. That is, 
we assume that the design  meant to give one of the allowed 
outputs, so either \textsf{rr} or \textsf{rg}. Thus, our shield 
continues to monitor the design from both F and B.  Technically, this is 
achieved by a form of subset construction (see Sec.~\ref{sec:k-stab}), 
which tracks all possibilities for now, and then gradually refines its 
knowledge with future observations.  For example, if the next 
observation is \textsf{0gr}, we assume that the design  meant 
\textsf{rr} earlier, and so it must be in B and traverse to H.
If it were in F, we could only have explained \textsf{0gr} by assuming a 
second violation, which is less optimistic than we would like to be.  
In this work, we assume that a second violation occurs only if an 
observation is inconsistent with \emph{all} states that it could 
possibly be in.  For example, if the next observation is not 
\textsf{0gr} but \textsf{1rg}, which is neither allowed in F nor in B, 
we know that a second violation occurs.  Yet, after observing 
\textsf{1rg}, we can be sure that we have reached the state B, because 
starting from both F and B, with input , the only allowed 
output is \textsf{rr}, and the next state is always B.
In this sense, our construction implements an ``innocent until proved 
guilty'' philosophy, which is key to satisfy the \emph{minimum 
interference} requirement.

To bound the deviation of the shield when a property violation becomes 
unavoidable, we require the shield to deviate for at most  
consecutive steps after the initial violation.  We shall formalize this 
notion of \emph{-stabilization} in subsequent sections and present 
our synthesis algorithm.
For the safety specification in Fig.~\ref{fig:traffic_spec}, our method 
would reduce the shield synthesis problem into a set of \emph{safety 
games}, which are then solved using standard techniques 
(cf.~\cite{Mazala01}).  We shall present the synthesis results in 
Section~\ref{sec:exp}.

\section{Preliminaries}
\label{sec:prelim}

We denote the Boolean domain by , denote the set of 
natural numbers by , and abbreviate  by 
.
We consider a reactive system with a finite set 
 of Boolean inputs and a finite set 
 of Boolean outputs.  The input alphabet is 
, the output alphabet is , and 
. The set of finite (infinite) words 
over  is denoted by  (), and 
.  We will also refer 
to words as \emph{(execution) traces}.  We write  for the 
length of a trace . For  and , we write  for the 
composition . A set  of infinite words is called a \emph{language}. 
We denote the set of all languages as .

\noindent
\textbf{Reactive Systems.}
A \emph{reactive system}  is a Mealy machine, where  is a 
finite set of states,  is the initial state,  is a complete transition 
function, and  
is a complete output function.  Given the input trace , the system  produces the 
output trace , where  for all .  The set of words produced by 
 is denoted .  We also refer to 
a reactive system  as a \emph{(hardware) design}.

Let  
and  be reactive systems.  Their serial composition is constructed 
by feeding the input and output of  to  as input.  We 
use  to denote such a composition 
, where
, 
,
, and
.   

\noindent
\textbf{Specifications.}
A \emph{specification}  defines a set  of allowed traces.  A specification  is 
\emph{realizable} if there exists a design  that realizes it. 
 \emph{realizes} , written , iff 
.
We assume that  is a (potentially incomplete) set of 
\emph{properties}  such that , and a design satisfies  iff it 
satisfies all its properties.
In this work, we are concerned with a \emph{safety} specification 
, which is represented by an automaton , where , 
, and  is a set of safe states.  The \emph{run} induced by trace 
 is the state 
sequence  such that .  Trace  (of a design ) 
\emph{satisfies}  if the induced run visits only the safe 
states, i.e., .  The \emph{language} 
 is the set of all traces satisfying .  


\noindent
\textbf{Games.}
A (2-player, alternating) \emph{game} is a tuple , where  is a 
finite set of game states,  is the initial state, 
 
is a complete transition function, and  is a winning condition.  The game is played by two 
players: the system and the environment.  In every state  
(starting with ), the environment first chooses an input letter 
, and then the system chooses some output 
letter . This defines the next state , and so on. The resulting (infinite) 
sequence  of game states is called a 
\emph{play}.  A play is \emph{won} by the system iff 
 is .

A \emph{safety game} defines  via a set  of 
safe states:  is  iff , i.e., if only safe states are visited.
A (memoryless) \emph{strategy} for the system is a function . A strategy is 
\emph{winning} for the system if all plays  that can be 
constructed when defining the outputs using the strategy satisfy 
. The \emph{winning region} is the set of states 
from which a winning strategy exists. We will use safety games to 
synthesize a shield, which implements the winning strategy in a new 
reactive system  with .






\section{The Shield Synthesis Framework} 
\label{sec:frame}

We define a general framework for shield synthesis in this section 
before presenting a concrete realization of this framework in the next 
section.

\begin{definition}[Shield]
Let  
be a design,  be a set of properties, and  
be a valid subset such that .  A reactive system 
 is 
a \emph{shield} of  with respect to  
iff .
\end{definition}

\noindent
Here, the design is known to satisfy . 
Furthermore, we are in good faith that  also satisfies , but it is not guaranteed.  We synthesize , 
which reads the input and output of  while correcting its 
erroneous output as illustrated in Fig.~\ref{fig:attach_shield}.

\begin{definition}[Generic Shield]
Given a set  of properties.  
A reactive system  is a \emph{generic shield} iff it is a 
shield of \emph{any} design  such that .
\end{definition}

\noindent
A generic shield must work for any design . 
Hence, the shield synthesis procedure does not need to consider the 
design implementation.  This is a realistic assumption in many 
applications, e.g., when the design  comes from the third 
party.  Synthesis of a generic shield also has a scalability advantage 
since the design , even if available, can be too complex to 
analyze, whereas  often contains only a small set of critical
properties.  Finally, a generic shield is more robust against design 
changes, making it attractive for safety certification.  In this work, 
we focus on the synthesis of generic shields.

Although the shield is defined with respect to  (more 
specifically, ), we must refrain from ignoring the 
design completely while feeding the output with a replacement circuit.  
This is not desirable because the original design may satisfy additional 
(non-critical) properties that are not specified in  but should 
be retained as much as possible.  In general, we want the shield to 
deviate from the design \emph{only if necessary, and as little as 
possible}.  For example, if  does not violate , the 
shield  should keep the output of  intact.  This 
rationale is captured by our next definitions.

\begin{definition}[Output Trace Distance Function]
An output trace distance function (OTDF) is a function  such 
that
\begin{enumerate}
\item  
      when ; 
\item  
      when , and
\item  
      when .
\end{enumerate}
\end{definition}

\noindent
An OTDF measures the difference between two output sequences (of the 
design  and the shield ).  The definition requires 
monotonicity with respect to prefixes: when comparing trace prefixes 
with increasing length, the distance can only become larger.  

\begin{definition}[Language Distance Function]
A language distance function (LDF) is a function  such that 
.
\end{definition}

\noindent
An LDF measures the severity of specification violations by the design 
by mapping a language (of ) and a trace (of ) to a 
number.  Given a trace , its distance to 
 is 0 if  satisfies .  Greater distances 
indicate more severe specification violations.  An OTDF can (but does 
not have to) be defined via an LDF by taking the minimum output distance 
between  and any trace in the 
language :

The input trace is ignored in  because the design  can 
only influence the output.  If no alternative output trace makes the 
word part of the language, the distance is set to  to express that it 
cannot be the design's fault. If  is defined by a realizable 
specification , this cannot happen anyway, since  is a 
necessary condition for the realizability of .

\begin{definition}[Optimal Generic Shield]
\label{def:ogs}
Let  be a specification,  be the valid 
subset,  be an OTDF, and  be an LDF.  A reactive system 
 is an \emph{optimal generic shield} if and only if for all 
 and , 

\end{definition}


\noindent
The implication means that we only consider traces that satisfy  
since  is assumed.   This can be exploited by 
synthesis algorithms to find a more succinct shield. 
Part~(\ref{eq:kopt1}) of the implied formula ensures correctness: 
 must satisfy .\footnote{Applying  
instead of ``'' adds flexibility: the user can 
define  in such a way that  even if 
 to allow such traces as well.} 
Part~(\ref{eq:kopt2}) ensures minimum interference: ``small'' violations 
result in ``small'' deviations. Def.~\ref{def:ogs} is designed to be 
flexible: Different notions of minimum interference can be realized with 
appropriate definitions of  and .  One realization will 
be presented in Section~\ref{sec:sol}.


\begin{proposition}
An optimal generic shield  cannot deviate from the design's 
output before a specification violation by the design  is 
unavoidable.
\end{proposition}
\begin{proof}
If there has been a deviation  on the finite input prefix , but this 
prefix can be extended into an infinite trace  such that 
, meaning that a violation is 
avoidable, then Part~(\ref{eq:kopt2}) of Def.~\ref{def:ogs} is violated 
because of the (prefix-)monotonicity of  (the deviation can only 
increase when the trace is extended), and the fact that  is  if .
\end{proof}

\section{Our Shield Synthesis Method}
\label{sec:sol}

In this section, we present a concrete realization of the shield 
synthesis framework by defining OTDF and LDF in a practical way. We call 
the resulting shield a \emph{-stabilizing} generic shield. While our 
framework works for arbitrary specifications, our realization assumes 
safety specifications.  

\subsection{-Stabilizing Generic Shields}

A -stabilizing generic shield is an optimal generic shield according 
to Def.~\ref{def:ogs}, together with the following restrictions.  When a 
property violation by the design  becomes unavoidable (in the 
worst case over future inputs), the shield  is allowed to 
deviate from the design's outputs for at most  consecutive time 
steps, including the current step.  Only after these  steps, the next 
violation is tolerated. This is based on the assumption that 
specification violations are rare events.  If a second violation happens 
within the -step recovery period, the shield enters a 
\emph{fail-safe} mode, where it enforces the critical properties, but 
stops minimizing the deviations.  
More formally, a -stabilizing generic shield requires the following 
configuration of the OTDF and LDF functions:
\begin{enumerate}
\item The LDF  is defined as follows: 
  Given a trace , its distance to
   is  initially, and increased to  when the 
  shield enters the \emph{fail-safe} mode.
\item The OTDF function  returns 
  initially, and is set to  if  outside of a -step recovery period.
\end{enumerate}
To indicate whether the shield is in the fail-safe mode or a recovery 
period, we add  a counter . Initially,  is 0. 
Whenever there is a property violation by the design,  is set to  
in the next step.  In each of the subsequent steps,  decrements until 
it reaches 0 again. The shield can deviate if the next state has .  
If a second violation happens when , then the shield enters the 
fail-safe mode.  A -stabilizing shield can only deviate in the 
time step of the violation, and can never enter the fail-safe mode.

\subsection{Synthesizing -Stabilizing Generic Shields}
\label{sec:k-stab}

The flow of our synthesis procedure is illustrated in 
Fig.~\ref{fig:k-stab}.  Let  be the 
critical safety specification, where each  is represented as 
an automaton  .  The 
synchronous product of these automata is again a safety automaton.  We 
use three product automata:
 is the product of
all properties in ;
 is the product
of properties in ; and 
 is the product
of properties in .
Starting from these automata, our shield synthesis procedure consists of 
five steps.

\begin{figure}[tb]
  \begin{center}
    \includegraphics[width=0.85\textwidth]{figs/k_stab_overview}
    \caption{Outline of our -stabilizing generic shield synthesis procedure.}
    \label{fig:k-stab}
  \end{center}
\end{figure}



\noindent
\textbf{Step 1. Constructing the Violation Monitor :}
From , which represents , we build 
 to monitor property 
violations by the design.  The goal is to identify the latest point in 
time from which a specification violation can still be corrected with a 
deviation by the shield.  This constitutes the start of the recovery 
period.

The first phase of this construction (Step 1-a) is to consider the 
automaton   as a 
\emph{safety game} and compute its winning region .  
The meaning of  is such that every reactive system 
 must produce outputs in such a 
way that the next state of  stays in .  Only when the 
next state of  would be outside of , our shield will 
be allowed to interfere.

\begin{exa}
Consider the safety automaton  in Fig.~\ref{fig:win_ex}, 
where  is an input,  is an output, and  is unsafe.  The 
winning region is  because from  the input  controls 
whether  is visited.  The shield must be allowed to deviate from 
the original transition  if . In  it 
is too late because visiting an unsafe state cannot be avoided any more, 
given that the shield can modify the value of  but not .  \qed
\end{exa}


\begin{figure}[tb]
\centering
\begin{minipage}{0.38\textwidth}
\scalebox{0.9}{\begin{tikzpicture}[auto,node distance=\nd]
\node[state,initial] at  (0,0)       (r0) {};
\node[state]         at  (2,0)       (r1) {};
\node[state]         at  (3.4,0)     (rx) {};

\path
(r0) edge [loop above]  
     node [xshift=-6mm,yshift=-4mm] {} (r0)
(r0) edge               
     node [xshift=0mm,yshift=-5mm]  {} (r1)
(r1) edge [bend right]
     node [xshift=0mm,yshift=4mm]   {} (r0)
(r1) edge               
     node                           {} (rx)
(rx) edge [loop above]  
     node [xshift=-5mm,yshift=-4mm] {} (rx)
     
;
\end{tikzpicture}
%
 }
\caption{The safety automaton .}
\label{fig:win_ex}
\end{minipage}
\hspace{0.08\textwidth}
\begin{minipage}{0.5\textwidth}
\scalebox{0.9}{\begin{tikzpicture}[auto,node distance=\nd]
\node[initial,state] at  (0,0)       (t0) {};
\node[state]         at  (3,0)       (t1) {};

\path 
(t0) edge [loop above] 
     node [xshift=-9mm,yshift=-4mm] {} (t0)
(t0) edge 
     node [xshift=0mm,yshift=-5mm] {} (t1)
(t1) edge [loop above]  
     node [xshift=10mm,yshift=-4mm] {} (t1)
(t1) edge [bend right] 
     node [xshift=1mm,yshift=5mm] {} (t0)
;
\end{tikzpicture}
 }
\caption{The deviation monitor .}
\label{fig:dev_monitor}
\end{minipage}
\end{figure}

The second phase (Step 1-b) is to expand the state space from  to 
 via a subset construction.  The rationale behind it is as 
follows.  If the design makes a mistake (i.e., picks outputs such that 
 enters a state  from which the 
specification cannot be enforced), we have to ``guess'' what the design 
actually meant to do in order to find a state from which we can continue 
monitoring its behavior.  We follow a generous approach in order not to 
treat the design unfairly: we consider all output letters that would 
have avoided falling out of , and continue monitoring the design 
behavior from all the corresponding successor states in parallel.  Thus, 
 is essentially a subset construction of , 
where a state  of  represents a set of states in 
.

The third phase (Step 1-c) is to expand the state space of  
by adding a counter  as described in the previous 
subsection, and adding a special fail-safe state .   
The final violation monitor is , where  is 
the set of states,  is the initial state,  
is the set of input letters, and  is the next-state function, 
which obeys the following rules:
\begin{enumerate}
\item  
      (meaning that  is a trap state), \label{eq:subset_s}
\item  if  and
      , 
      \label{eq:subset_a}
\item \\
if  and , 
and
\label{eq:subset_m}
\item 
if ,
where  and  if .  
\label{eq:subset_n}
\end{enumerate}
Our construction sets  whenever the design leaves the winning 
region, and not when it enters an unsafe state.  Hence, the shield 
 can take remedial action as soon as the ``the crime is 
committed'', before the damage is detected, which would have been too 
late to correct the erroneous outputs of the design. 


\begin{exa}
We illustrate the construction of  using the specification 
from Fig.~\ref{fig:traffic_spec}, 
\begin{wrapfigure}[10]{r}{0.42\textwidth}
\vspace{-0.7cm}
\begin{tabular}{l|cccccccc}
    &1g-   &1rg   &-rr &0gg     &0gr    &0rg    \\
\hline
H   &B\err &B\err &B   &HB\err  &H      &HB\err \\
B   &B\err &B\err &B   &HFB\err &H      &F      \\
F   &B\err &B\err &B   &FB\err  &FB\err &F      \\
HB  &B\err &B\err &B   &HFB\err &H      &F      \\
FB  &B\err &B\err &B   &HFB\err &H      &F      \\
HFB &B\err &B\err &B   &HFB\err &H      &F      \\
\hline
\end{tabular}
\caption{ for the spec from Fig.~\ref{fig:traffic_spec}.}
\label{fig:traffic_subset}
\end{wrapfigure}
which is a safety automaton if we make all missing edges point to an 
(additional) unsafe state.  The winning region consists of all safe 
states, i.e., .  The resulting violation monitor is 
, where 
 is illustrated in Fig.~\ref{fig:traffic_subset} as a table
(the graph would be messy), which lists the next state for all possible 
present states as well as inputs and outputs by the design.  Lightning 
bolts denote specification 
violations. The update of the counter , which is not included in 
Fig.~\ref{fig:traffic_subset}, is as follows: whenever the design 
commits a violation (indicated by lightning) and , then  is 
set to . If  at the violation, the next state is .  
Otherwise,  is decremented.  \qed

\end{exa}

\noindent
\textbf{Step 2. Constructing the Validity Monitor :}
From , which represents 
, we build an automaton  to monitor the validity 
of  by solving a safety game on  and computing the 
winning region . We will use  to increase the 
freedom for the shield: since we assume that 
, we are only interested in the cases where 
 never leaves .  If it does, our shield is 
allowed to behave arbitrarily from that point on.  
We extend the state space from  to  by adding a bit to 
memorize if we have left the winning region .  Hence, the 
validity monitor is defined as , where  is the set of states, 
 is the initial state, 
, where 
 if  or , and 
 otherwise, and  .

\noindent
\textbf{Step 3. Constructing the Deviation Monitor :}
We build  
to monitor the deviation of the shield's output from the design's 
output. Here,  and  iff . That is, 
 will be in  if there was a deviation in the last time 
step, and in  otherwise.  This deviation monitor is shown in 
Fig.~\ref{fig:dev_monitor}.

\noindent
\textbf{Step 4. Constructing the Safety Game :}
Given the monitors  and the 
automaton , which represents , we construct a safety 
game  
, which is the synchronous product of , 
,  and , such that  is the state space,  
is the initial state,  is the input of the 
shield,  is the output of the shield,  is the 
next-state function, and  is the set of safe states, such that


and .

In the definition of , the term  reflects our 
assumption that .  If this assumption is 
violated, then  will hold forever, and our shield is 
allowed to behave arbitrarily.  This is exploited by our synthesis 
algorithm to find a more succinct shield  by treating such states as 
\emph{don't cares}.  If , we require that , 
i.e., it is a safe state in , which ensures that the shield 
output will satisfy . The last term ensures that the shield can 
only deviate in the -step recovery period, i.e., while  in 
.  If the design makes a second mistake within this period, 
 enters  and arbitrary deviations are allowed.  Yet, 
the shield will still enforce  in this mode (unless ).

\noindent
\textbf{Step 5. Solving the Safety Game:}  
We use standard algorithms for safety games (cf.  e.g.~\cite{Mazala01}) 
to compute a winning strategy  for .  Then, we 
implement this strategy in a new reactive system  with .  is the 
-stabilizing generic shield.  If no winning strategy exists, we 
increase  and try again.  In our experiments, we start with  and 
then increase  by 1 at a time.

\begin{theorem}
Let  be a set of critical safety 
properties  , and let  be a subset of valid properties. 
 Let  be the cardinality 
of the product of the state spaces of all properties of . 
Similarly, let . A 
-stabilizing generic shield with respect to  
and  can be synthesized in  time
(if one exists).
\end{theorem}
\begin{proof}
Safety games can be solved in  time~\cite{Mazala01}, where  
is the number of states and  is the number of edges in the game 
graph.  Our safety game  has at most  states, 
so at most  edges. 
\end{proof}

\noindent
\textbf{Variations.}
The assumption that no second violation occurs within the recovery 
period increases the chances that a -stabilizing shield exists.  
However, it can also be dropped with a slight 
modification of  in Step 1: if a violation is committed and 
, we set  to  instead of visiting .  This ensures 
that synthesized shields will handle violations within a 
recovery period normally.  
The assumption that the design meant to give one of the allowed outputs 
if a violation occurs can also be relaxed.  Instead of continuing to 
monitor the behavior from the allowed next states, we can just continue 
from the set of all states, i.e., traverse to state  in 
.  The assumption that , i.e., the 
design satisfies some properties, is also optional.  By removing 
 and , the construction can be 
simplified at the cost of less implementation freedom for the shield.

By solving a \buchi game (which is potentially more expensive) instead 
of a safety game, we can also eliminate the need to increase  
iteratively until a solution is found. 
\ifextended
This is outlined in Appendix~\ref{sec:app}.
\else
This is outlined in the appendix of an extended version~\cite{extended} 
of this paper.
\fi

\section{Experiments} 
\label{sec:exp}

We have implemented the -stabilizing shield synthesis procedure in a 
proof-of-concept tool.  Our tool takes as input a set of safety 
properties, defined as automata in a simple textual representation. The 
product of these automata, as well as the subset construction in Step 1 
of our procedure is done on an explicit representation.  The remaining 
steps are performed symbolically using Binary Decision Diagrams (BDDs).  
Synthesis starts with  and increments  in case of 
unrealizability until a user-defined bound is hit.  Our tool is written 
in Python and uses CUDD~\cite{Somenz95} as the BDD library.  Our tool 
can output shields in Verilog and SMV. It can also use the model checker 
VIS~\cite{VIS96} to verify that the synthesized shield is correct.

We have conducted three sets of experiments, where the benchmarks are 
(1) selected properties for a traffic light controller from the 
VIS~\cite{VIS96} manual, (2) selected properties for an ARM AMBA bus 
arbiter~\cite{BloemJPPS12}, and (3) selected properties from LTL 
specification patterns~\cite{DwyerAC99}.  None of these examples makes 
use of , i.e.,  is always empty. The source code of our 
proof-of-concept synthesis tool as well as the input files and 
instructions to reproduce our experiments are available for 
download\footnote{\scriptsize\url{ 
http://www.iaik.tugraz.at/content/research/design_verification/others/}
}.

\noindent
\textbf{Traffic Light Controller Example.}
We used the safety specification in Fig.~\ref{fig:traffic_spec} as 
input, 
\begin{wrapfigure}[7]{r}{0.42\textwidth}
\vspace{-0.9cm}
\scalebox{0.95}{\begin{tikzpicture}[auto,node distance=\nd]
\definecolor{darkred}{rgb}{0.7, 0.0, 0.0}
\node[state,initial]  at  (0,0)         (X) {X};
\node[state]          at  (1.8,0)       (Y) {Y};
\node[state]          at  (3.6,0)       (Z) {Z};

\path
(X) edge [loop above]
    node[xshift=-4.5mm,yshift=-4mm] {\textsf{0gr}} (X)
(Y) edge [loop above]                 
    node[xshift=-4mm,yshift=-3mm] {\textsf{-rr}} (Y)
(Y) edge [loop below,dashed,color=darkred]                 
    node[xshift=0mm,yshift=1mm] {else \textsf{rr}} (Y)    
(Z) edge [loop above]                 
    node[xshift=-4.5mm,yshift=-4mm] {\textsf{0rg}} (Z)
(X) edge [bend angle=45, bend left]   
    node[xshift=0mm,yshift=-1mm] {\textsf{-rr}} (Y)
(X) edge [bend angle=30, bend right, dashed,color=darkred]       
    node[xshift=-1mm,yshift=-4mm] {else \textsf{rr}} (Y)
(Y) edge                              
    node[xshift=0mm,yshift=5mm] {\textsf{0gr}} (X)
(Z) edge                   
    node[xshift=0mm,yshift=4mm] {\textsf{-rr}} (Y)
(Z) edge [bend angle=30, bend left, dashed,color=darkred]       
    node[xshift=1mm,yshift=1mm] {else \textsf{rr}} (Y)
(Y) edge [bend angle=45, bend left]                  
    node[xshift=-2mm,yshift=-1mm] {\textsf{0rg}} (Z);
\end{tikzpicture}
%
 }
\vspace{-0.3cm}
\caption{Traffic light shield.}
\label{fig:traffic_shield}
\end{wrapfigure}
for which our tool generated a -stabilizing shield within a fraction 
of a second.  The shield has 6 latches and 95 (2-input) multiplexers, 
which is then reduced by ABC~\cite{BraytonM10} to 5 latches and 41 
(2-input) AIG gates.  However, most of the states are either unreachable 
or equivalent.  The behavior of the shield is illustrated in 
Fig.~\ref{fig:traffic_shield}.  Edges are labeled with the inputs of the 
shield.  Red dashed edges denote situations where the output of the 
shield is different from its inputs.  The modified output is written 
after the arrow.  For all non-dashed edges, the input is just copied to 
the output.  Clearly, the states X, Y, and Z correspond to H, B, and F 
in Fig.~\ref{fig:traffic_spec}.

We also tested the synthesized shield using the traffic light controller 
of~\cite{vlsi}, which also appeared in the user manual of 
VIS~\cite{VIS96}. This controller has one input (\textsf{car}) from a 
car sensor on the farm road, and uses a timer to control the length of 
the different phases.  We set the ``short'' timer period to one tick and 
the ``long'' period to two ticks.  

\begin{wrapfigure}[8]{r}{0.58\textwidth}
\vspace{-0.9cm}
\scalebox{0.8}{\begin{tikzpicture}[auto,node distance=\nd]
\definecolor{darkred}{rgb}{0.7, 0.0, 0.0}
\node[state,initial above,inner sep=0pt,align=center] at  (0,0)  (S0)  {S0\\gr};
\node[state,inner sep=0pt,align=center]          at  (1.2,0.3)   (S1)  {S1\\gr};
\node[state,inner sep=0pt,align=center]          at  (2.4,0.6)   (S2)  {S2\\gr};
\node[state,inner sep=0pt,align=center]          at  (3.8,1.0)   (S3)  {S3\\rr};
\node[state,inner sep=0pt,align=center]          at  (5.0,0.6)   (S4)  {S4\\rr};
\node[state,inner sep=0pt,align=center]          at  (6.2,0.3)   (S5)  {S5\\rg};
\node[state,inner sep=0pt,align=center]          at  (6.2,1.5)   (S6)  {S6\\rg};
\node[state,inner sep=0pt,align=center]          at  (7.8,1.5)   (S7)  {S7\\rg};
\node[state,inner sep=0pt,align=center]          at  (7.8,0)     (S8)  {S8\\rr};
\node[state,inner sep=0pt,align=center]          at  (3.8,0)     (S9)  {S9\\rr};

\path
(S0) edge (S1)
(S1) edge (S2)
(S2) edge [loop above,looseness=6] 
     node[xshift=6mm,yshift=-4mm] {car} (S2)
(S2) edge               
     node[xshift=4.1mm,yshift=-4mm] {car} (S3)
(S3) edge (S4)
(S4) edge (S5)
(S5) edge 
     node[xshift=-5mm,yshift=-0.7mm] {car} (S8)
(S5) edge               
     node[xshift=0mm,yshift=0mm] {car} (S6)
(S6) edge               
     node[xshift=-4.4mm,yshift=1mm] {car} (S8)
(S6) edge               
     node[xshift=0mm,yshift=0mm] {car} (S7)
(S6) edge [bend right,dashed,color=darkred] 
     node[xshift=10mm,yshift=1.5mm] {car} (S0)
(S7) edge (S8)
(S8) edge [bend angle=12, bend left]   (S9)
(S9) edge [bend angle=12, bend left]   (S0)
;
\end{tikzpicture}
%
 }
\caption{Traffic light implementation.}
\label{fig:traffic_impl}
\end{wrapfigure}

The resulting behavior without preemption is visualized in 
Fig.~\ref{fig:traffic_impl}, where nodes are labeled with names and 
outputs, and edges are labeled with conditions on the inputs.  The red 
dashed arrow represents a subtle bug we introduced: if the last car on 
the farm road exits the crossing at a rare point in time, then the 
controller switches from \textsf{rg} to \textsf{gr} without passing 
\textsf{rr}. This bug only shows up in very special situations, so it 
can go unnoticed easily.  Preemption is implemented by modifying both 
directions to \textsf{r} without changing the state if .  
We introduced another bug here as well: only the highway is switched to 
\textsf{r} if , whereas the farm road is not. This bug can 
easily go unnoticed as well, because the farm road is mostly red anyway.
The following trace illustrates how the synthesized shield handles these 
errors:

\begin{center}
\setlength{\tabcolsep}{1.3pt}
\begin{tabular}{l|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c}\hline
Step                                 &0 &1 &2 &3 &4 &5 &6 &7     &8  &9 &10&11&12    &13&14&15    \\
\hline
State in Fig.~\ref{fig:traffic_spec} (safety spec.)
                                     &H &H &B &H &B &B &F &F     &F,B&H &H &B &B     &B &B &\ldots\\
State in Fig.~\ref{fig:traffic_impl} (buggy design)
                                     &S0&S1&S2&S3&S4&S5&S6&S0    &S1 &S2&S3&S4&S5    &S8&S9&\ldots\\
State in Fig.~\ref{fig:traffic_shield} (shield)
                                     &X &X &Y &X &Y &Y &Z &Z     &Y  &X &X &Y &Y     &Y &Y &\ldots\\

                                     
Input (\textsf{p,car})               &00&11&01&01&01&01&00&00    &00 &01&01&00&10    &00&00&\ldots\\
Design output                        &gr&rr&gr&rr&rr&rg&rg&gr\err&gr &gr&rr&rr&rg\err&rr&rr&\ldots\\
Shield output                        &gr&rr&gr&rr&rr&rg&rg&rr    &gr &gr&rr&rr&rr    &rr&rr&\ldots\\
\hline
\end{tabular}
\end{center}

\noindent
The first bug strikes at Step 7. The shield corrects it with output 
\textsf{rr}. A -stabilizing shield could also have chosen 
\textsf{rg}, but this would have made a second deviation necessary in 
the next step. Our shield is -stabilizing, i.e., it deviates only at 
the step of the violation. After this correction, the shield continues 
monitoring the design from both state F and state B of 
Fig.~\ref{fig:traffic_spec}, as explained earlier, to detect future 
errors. Yet, this uncertainty is resolved in the next step.  The second 
bug in Step 12 is simpler: outputting \textsf{rr} is the only way to 
correct it, and the next state in Fig.~\ref{fig:traffic_spec} must be B.

When only considering the properties 1 and 2 from Section~\ref{sec:ex}, 
the synthesized shield has no latches and three AIG gates after 
optimization with ABC~\cite{BraytonM10}.

\noindent
\textbf{ARM AMBA Bus Arbiter Example.}
We used properties of an ARM AMBA bus arbiter~\cite{BloemJPPS12} as 
input to our shield synthesis tool.  Due to page limit, we only present 
the result on one example property, and then present the performance 
results for other properties. 
The property that we enforced was Guarantee 3 from the specification 
of~\cite{BloemJPPS12}, which says that if a length-four locked burst 
access starts, no other access can start until the end of this burst. 
The safety automaton is shown in Fig.~\ref{fig:amba_g3}, where 
\texttt{B}, \texttt{s} and \texttt{R} are short for , \texttt{start}, and \texttt{HREADY}, 
respectively.  Lower case signal names are outputs, and upper-cases are 
inputs of the arbiter.  S is unsafe. S0 is the idle state waiting 
for a burst to start (). The burst is over 
if input \texttt{R} has been   times.  State S, where 
, means that \texttt{R} must be  for  more times.  
The counting includes the time step where the burst starts, i.e., where 
S0 is left.  Outside of S0, \texttt{s} is required to be .

\begin{figure}[tb]
\centering
\begin{minipage}{0.47\linewidth}
\vspace{-0.3cm}
\hspace{-1ex}
\scalebox{0.8}{\begin{tikzpicture}[auto,node distance=\nd]
\node[state,initial above] at  (0,0)       (S0) {S0};
\node[state]               at  (0.6,-1.3)    (S4) {S4};
\node[state]         at  (2.3,0)     (S3) {S3};
\node[state]         at  (4.2,0)     (S2) {S2};
\node[state]         at  (6.1,0)     (S1) {S1};
\node[state]         at  (4.2,-1.3)  (SX) {S};

\path
(S0) edge [in=100,out=130,loop]  
     node [xshift=12mm,yshift=-1mm] 
     {} (S0)
(S0) edge               
     node [xshift=-7mm,yshift=-1.5mm]  
     {} (S4)   
(S0) edge               
     node [xshift=0mm,yshift=0mm]  
     {} (S3)
     
(S4) edge               
     node [rotate=35,xshift=5.7mm,yshift=-4mm]  
     {} (S3) 
(S4) edge [in=-40,out=-10,loop]  
     node [xshift=-1mm,yshift=3mm] 
     {} (S4)    
(S4) edge  
     node [xshift=0mm,yshift=0mm] 
     {} (SX)
     
(S3) edge               
     node [xshift=0mm,yshift=0mm]  
     {} (S2) 
(S3) edge [loop above]  
     node [xshift=8mm,yshift=-5mm] 
     {} (S3)
(S3) edge  
     node [xshift=-1mm,yshift=-1mm] 
     {} (SX)
     
(S2) edge               
     node [xshift=0mm,yshift=0mm]  
     {} (S1) 
(S2) edge [loop above]  
     node [xshift=8mm,yshift=-5mm] 
     {} (S2)
(S2) edge  
     node [xshift=-1mm,yshift=1mm] 
     {} (SX)
     
(S1) edge [in=60, out=90, controls=+(90:1.5) and +(60:1.5)]              
     node [xshift=0mm,yshift=1mm]  
     {} (S0) 
(S1) edge [loop below]  
     node [xshift=-3mm,yshift=0mm] 
     {} (S1) 
(S1) edge  
     node [xshift=-1mm,yshift=1mm] 
     {} (SX)
     
(SX) edge [in=-10,out=-40,loop]  
     node [xshift=8mm,yshift=-2mm] 
     {} (SX)  



;
\end{tikzpicture}
%
 }
\vspace{-0.4cm}
\caption{Guarantee 3 from~\cite{BloemJPPS12}.}
\label{fig:amba_g3}
\end{minipage}
\begin{minipage}{0.507\linewidth}
\vspace{-2mm}
\setlength{\tabcolsep}{1.1pt}
\begin{tabular}{l|c|c|c|c|c|c|c|c|c|c}\hline
Step                           &3 &4 &5 &6 &7    &8 &9 &10&11&12    \\
\hline
State in Fig.~\ref{fig:amba_g3}&S0&S4&S3&S2&S1   &S0&S0&S0&S0&\ldots\\
State in Design                &S0&S3&S2&S1&S0   &S3&S2&S1&S0&\ldots\\
\texttt{B}                     &1 &1 &1 &1 &1    &1 &1 &1 &1 &\ldots\\
\texttt{R}                     &0 &1 &1 &1 &1    &1 &1 &1 &1 &\ldots\\
\texttt{s} from Design         &1 &0 &0 &0 &1\err&0 &0 &0 &0 &\ldots\\
\texttt{s} from Shield         &1 &0 &0 &0 &0    &0 &0 &0 &0 &\ldots\\
\hline
\end{tabular}
\caption{Shield execution results.}
\label{fig:amba_g3_result}
\end{minipage}
\end{figure}

Our tool generated a 1-stabilizing shield within a fraction of a second. 
The shield has 8 latches and 142 (2-input) multiplexers, which is then 
reduced by ABC~\cite{BraytonM10} to 4 latches and 77 AIG gates. We 
verified it against an arbiter implementation for 2 bus masters, where 
we introduced the following bug: the design does not check \texttt{R} 
when the burst starts, but behaves as if \texttt{R} was .  This 
corresponds to removing the transition from S0 to S4 in 
Fig.~\ref{fig:amba_g3}, and going to S3 instead.  An execution trace is 
shown in Fig.~\ref{fig:amba_g3_result}.  The first burst starts with 
 in Step 3.  \texttt{R} is , so the design 
counts wrongly.  The erroneous output shows up in Step 7, where the 
design starts the next burst, which is forbidden, and thus blocked by 
the shield.  The design now thinks that it has started a burst, so it 
keeps  until \texttt{R} is  4 times.  
Actually, this burst start has been blocked by the shield, so the shield 
waits in S0.  Only after the suppressed burst is over, the components 
are in sync again, and the next burst can start normally.


\begin{wraptable}[10]{r}{0.46\textwidth}
\centering
\setlength{\tabcolsep}{5pt}
\vspace{-5ex}
\caption{Performance for AMBA~\cite{BloemJPPS12}.}
\vspace{-0.3cm}
\label{tab:perf}
\scalebox{0.8}{\begin{tabular}{|lccccc|}
\hline
Property        & &    &      & &Time [sec] \\
\hline
G1              &3     &1        &1         &1   &0.1        \\
G1+2            &5     &3        &3         &1   &0.1        \\
G1+2+3          &12    &3        &3         &1   &0.1        \\
G1+2+4          &8     &3        &6         &2   &7.8        \\
G1+3+4          &15    &3        &5         &2   &65         \\
G2+3+4          &17    &3        &6         &?   &3600    \\
G1+2+3+5        &18    &3        &4         &2   &242        \\
G1+2+4+5        &12    &3        &7         &?   &3600    \\
G1+3+4+5        &23    &3        &6         &?   &3600    \\
\hline
\end{tabular}}
\end{wraptable}
To evaluate the performance of our tool, we ran a stress test with 
increasingly larger sets of safety properties for the ARM AMBA bus 
arbiter in~\cite{BloemJPPS12}.  Table~\ref{tab:perf} summarizes the 
results.  The columns list the number of states, inputs, and outputs, 
the minimum  for which a -stabilizing shield exists, and the 
synthesis time in seconds.  All experiments were performed on a machine 
with an Intel i5-3320M CPU@2.6 GHz, 8 GB RAM, and a 64-bit Linux.  
Time-outs (G2+3+4, G1+2+4+5 and G1+3+4+5) occurred only when the number 
of states and input/output signals grew large.  However, this should not 
be a concern in practice because the set of critical properties of a 
system is usually much smaller, e.g., often consisting of invariance 
properties with a single state.  

\begin{wraptable}[18]{r}{0.631\textwidth}
\centering
\setlength{\tabcolsep}{1pt}
\vspace{-5ex}
\caption{Synthesis results for the LTL patterns~\cite{DwyerAC99}.}
\label{tab:dwyer}
\vspace{-2ex}
\scalebox{0.85}{
\begin{tabular}{|l|l|c||c|c|c|c|}
\hline
Nr. &Property   && &Time      &\#Lat-    &\#AIG-      \\
    &           &   &      &[sec]     &ches      &Gates       \\
\hline
1   &
                &-  &2     &0.01      &0         &0           \\
2   &
                &-  &4     &0.34      &2         &6           \\
3   &
                &-  &3     &0.34      &2         &6           \\
4   &
                &-  &4     &0.34      &1         &9           \\
5   &
                &-  &3     &0.01      &2         &14          \\
6   &
                &0  &3     &0.34      &1         &1           \\
6   &
                &256&259   &33        &18        &134         \\
7   &
                &-  &3     &0.05      &3         &11          \\
8   &
                &0  &3     &0.04      &3         &11          \\
8   &
                &4  &7     &0.04      &6         &79          \\
8   &
                &16 &19    &0.03      &10        &162         \\
8   &
                &64 &67    &0.37      &14        &349         \\
8   &
                &256&259   &34        &18        &890         \\
9   &
                &-  &3     &0.05      &2         &12          \\
10   &
                &12 &14    &5.4       &14        &2901        \\
10   &
                &14 &16    &38        &15        &6020        \\
10   &
                &16 &18    &377       &18        &13140       \\
\hline                
\end{tabular}
}
\end{wraptable}



\noindent
\textbf{LTL Specification Patterns.}
Dwyer et al.~\cite{DwyerAC99} studied the frequently used LTL 
specification patterns in verification.  As an exercise, we applied our 
tool to the first 10 properties from their list~\cite{LTLpattern-URL} 
and summarized the results in Table~\ref{tab:dwyer}.  For a property 
containing liveness aspects (e.g., something must happen eventually), we 
imposed a bound on the reaction time to obtain the safety 
(bounded-liveness) property. The bound on the  reaction time is shown in 
Column~3.  The last four columns list the number of states in the safety 
specification, the synthesis time in seconds, and the shield size 
(latches and AIG gates). Overall, our method runs sufficiently fast on 
all properties and the resulting shield size is small. We also 
investigated how the synthesis time increased with an increasingly 
larger bound .  For Property 8 and Property 6, the run time and 
shield size remained small even for large automata. For Property 10, the 
run time and shield size grew faster, indicating room for further 
improvement.  As a proof-of-concept implementation, our tool has not yet 
been optimized specifically for speed or shield size -- we leave such 
optimizations for future work.

\section{Conclusions}
\label{sec:conc}

We have formally defined the shield synthesis problem for reactive 
systems and presented a general framework for solving the problem.  We 
have also implemented a new synthesis procedure that solves  a concrete 
instance of  this problem, namely the synthesis of -stabilizing 
generic shields. We have evaluated our new method  on two hardware 
benchmarks and a set of LTL specification patterns.  We believe that our 
work points to an exciting new direction for applying synthesis, because 
the set of critical properties of a complex system tends to be small and 
relatively easy to specify, thereby making shield synthesis scalable and 
usable. Many interesting extensions and variants remain to be explored, 
both theoretically and experimentally, in the future.

\bibliography{references}
\ifextended
\newpage
\appendix

\section{Synthesis of Stabilizing Generic Shields}
\label{sec:app}

In this section, we present a method for synthesizing -stabilizing 
shields with arbitrary but finite .  We call such shields 
\emph{stabilizing} (without the ``'').  A synthesis procedure for 
stabilizing shields is also useful as a preprocessing step if we want to 
enforce a particular (or minimal) : Even for a realizable 
specification, the -stabilizing shield synthesis problem may be 
unrealizable for any finite .  When specification  is 
realizable, there exists a reactive system  such that 
.  However, it does not mean that a shield 
 exists for any design , such that , and  deviates from 
 for at most  time steps.

\begin{exa}
Consider the safety specification on the right, where  and  
are 
\begin{wrapfigure}[6]{r}{0.42\textwidth}
\vspace{-1.0cm}
\begin{tikzpicture}[auto,node distance=\nd]
\node[state,initial above] at  (0,0)       (r0) {};
\node[state]               at  (2,0.8)   (r1) {};
\node[state]               at  (2,-0.6)  (r2) {};
\node[state]               at  (4.2,0)  (rx) {};
\path
(r0) edge               
     node [rotate=21,xshift=7.5mm,yshift=0mm]  {} (r1)
(r0) edge               
     node [rotate=-20,xshift=-4mm,yshift=-4mm] {} (r2)
(r0) edge               
     node [xshift=-3mm,yshift=-1mm] {} (rx)
(r1) edge [in=30,out=0,loop]              
     node [xshift=15mm,yshift=2mm]  {} (r1)
(r2) edge [loop right]              
     node [xshift=-5mm,yshift=-3.5mm]  {} (r2)
(r2) edge          
     node [rotate=20,xshift=4mm,yshift=-4mm]  {} (rx)
(rx) edge [loop below,looseness=6]              
     node [xshift=0mm,yshift=1mm]  {} (rx)
(r1) edge          
     node [rotate=-18,xshift=-7.0mm,yshift=-0.7mm]  {} (rx)
     
;
\end{tikzpicture}
%
 \end{wrapfigure}
outputs, and  is unsafe.  The design must produce either  globally or  globally.  The -stabilizing 
shield synthesis problem is unrealizable for any finite : if the 
design produces  initially, the shield must deviate to 
either  or .  In the former case, the 
design could produce  from that point on, in the latter case 
.  This would cause an indefinite deviation with 
only a single violation.  \qed

\end{exa}

Whether a -stabilizing shield exists for some finite  is difficult 
to detect with the synthesis procedure from Section~\ref{sec:k-stab}.  
In case of unrealizability of the shield for a given , we cannot know 
if we just need to increase , or if no finite  would work.  The 
synthesis process presented in the following sub-section will decide the 
realizability problem.  We can also synthesize a stabilizing shield, 
measure its , and minimize this  further with the procedure from 
Section~\ref{sec:k-stab} until we hit the unrealizability barrier.

\subsection{Construction for Synthesizing Stabilizing Shields} 
\label{sec:stab-app}

A generic stabilizing shield can be synthesized (if one exists) with 
only a few modifications to the procedure from Section~\ref{sec:k-stab}. 
Instead of a counter , we use a counter 
 with only three different values.  Intuitively,  is 
an abstraction for .  
We construct a \buchi game that is won if  infinitely often 
(and all the other shield requirements are satisfied).  A \buchi game is 
like a safety game, but the given set of final states must be visited 
infinitely often for the system to win the game.  A winning strategy for 
this \buchi game corresponds to a -stabilizing shield with some 
finite , and the  can even be computed during synthesis.  The 
construction is similar to Section~\ref{sec:k-stab}, with only a few 
modifications:

\noindent
\textbf{Step 1.} Instead of using a counter , we 
use a three-valued counter  to track whether we are 
currently in the recovery phase or not. Intuitively,  if  would 
be . That is,  is  initially.  If  and the design 
makes a mistake (leaves ), then  is set to .  If it was 
already , we enter .  In order to decide when to decrement  
from  to , we add a special output  to the shield.  If this 
output is set to  and , then  is set to  in the next 
step. The behavior for  is the same as in Section~\ref{sec:k-stab}: 
if another violation occurs,  is set to . Otherwise,  is 
decremented to .  We denote this slightly modified violation monitor 
by  
with . The subsequent steps will 
ensure that the shield will only be allowed to deviate if  in the 
next step.  We will also require that  cannot be  indefinitely.

\noindent
\textbf{Step 2 and Step 3} are performed as described in 
Section~\ref{sec:k-stab}.

\noindent
\textbf{Step 4.} We construct a \buchi game  as the synchronous product of , , 
 and  as follows: 
\begin{itemize}
\item , 
\item ,
\item ,
where
 \begin{itemize}
 \item  iff  or 
 \item  iff  or , and
 \end{itemize}
\item .
\end{itemize}
The intuition behind this construction is as follows.  We extend the 
state space of the synchronous product by two bits,  and .  The 
bit  is  if the execution has ever visited an unsafe state in 
.  The bit  is  if there has been an illegal 
deviation\footnote{Recall that  means that the counter  
introduced in Step 1 is , i.e., no deviation was allowed in the 
previous time step;  indicates that a deviation has occurred in 
the previous time step.}. With this information, the accepting states 
(that need to be visited infinitely often) are then defined as follows. 
Outside of , everything is accepting.  This makes sure that the 
shield can behave arbitrarily if .  Otherwise, 
a state is accepting if  (the last recovery period is over), 
 is  ( so far) and  is 
 (no illegal deviations so far).  Visiting  infinitely 
often implies that recovery periods are over infinitely often, and  
and  are never  (these bits cannot change back to ).

\noindent
\textbf{Step 5.}  Just like safety games, \buchi games also have a 
memoryless strategy.  We compute such a strategy and implement it as 
described in Section~\ref{sec:k-stab}. If no such strategy exists (which 
is easy to detect during synthesis), then this is reported to the user.

\noindent
\textbf{Discussion.}
Note that the \buchi objective ensures that recovery phases are over 
infinitely often, but not that they are bounded in time.  There may 
exist a strategy to satisfy the \buchi objective without any finite 
bound on the recovery time.  E.g., the first recovery phase could take 2 
steps, the second one 4 steps, the third one 8 steps, etc.  However, 
such a strategy would require infinite memory. We construct and 
implement a memoryless strategy, which guarantees a bounded recovery.  
We can even measure the maximum length of any recovery phase while 
synthesizing the shield: \buchi games can be solved with a doubly-nested 
fixpoint computation~\cite{Mazala01}.  The number of iterations of the 
inner fixpoint (in the last iteration of the outer fixpoint) corresponds 
to the maximum number of steps needed to reach a state of , 
i.e., a state where the recovery is over.  Hence, this value is also the 
maximum length of a recovery period, i.e., the value  for the 
resulting -stabilizing shield.
\fi
\end{document}
