\documentclass{article} \usepackage{iclr2017_workshop,times}
\usepackage{hyperref}
\usepackage{url}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}

\usepackage{graphicx}

\usepackage{wrapfig}

\newcommand\note[1]{\textcolor{blue}{[NOTE: #1]}}

\newcommand{\tp}{{\tilde p}}
\newcommand{\tr}{{\tilde r}}
\newcommand{\pt}{{p_\theta}}
\newcommand{\tpt}{{\tilde p_\theta}}
\newcommand{\Exp}{\mathbb{E}}
\newcommand{\Dc}{{\mathcal D}}
\newcommand{\x}{\chi}
\newcommand{\e}{\epsilon}
\newcommand{\xti}{x^{(i)}}
\newcommand{\yti}{y^{(i)}}

\title{ Audio Super-Resolution using Neural Nets }


\author{Volodymyr Kuleshov, S. Zayd Enam, and Stefano Ermon \\
Department of Computer Science, \\
Stanford University\\
\texttt{\{kuleshov,ermon\}@cs.stanford.edu}\\
\texttt{zayd@stanford.edu}
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\begin{document}


\maketitle

\begin{abstract}
We introduce a new audio processing technique that increases the sampling rate of  signals such as speech or music using deep convolutional neural networks.
Our model is trained on pairs of low and high-quality audio examples; at test-time, it predicts missing samples within a low-resolution signal in an interpolation process 
similar to image super-resolution.
Our method is simple and does not involve specialized audio processing techniques; in our experiments, it outperforms baselines 
on standard speech and music benchmarks at upscaling ratios of $2\times$, $4\times$, and $6\times$. The method has practical applications in telephony, compression, and text-to-speech generation; it demonstrates the effectiveness of convolutional architectures on an audio generation task.

\end{abstract}

\section{Introduction}

The generative modeling of audio signals is a fundamental problem at the intersection of signal processing and machine learning; recent learning-based algorithms have enabled advances in speech recognition~\citep{hinton2012deep}, audio synthesis \citep{DBLP:journals/corr/OordDZSVGKSK16, mehri2016samplernn}, music recommendation systems~\citep{coviello2012multivariate, wang2014improving, liang2015content}, and in many other areas~\citep{acevedo2009automated}. Audio processing also raises basic research questions pertaining to time series and generative modeling~\citep{haykin2005cocktail,bilmes2004graphical}.

One of the most significant recent advances in machine learning-based audio processing has been the ability to directly model {\em raw signals} in the time domain using neural networks \citep{DBLP:journals/corr/OordDZSVGKSK16, mehri2016samplernn}. Although this affords us the maximum modeling flexibility, it is also computationally expensive, requiring us to handle $>10,000$ audio samples at every second. 

In this paper, we explore new lightweight modeling algorithms for audio.
In particular, we focus on a specific audio generation problem called {\em bandwidth extension}, in which the task is to reconstruct high-quality audio from a low-quality, down-sampled input containing only a small fraction (15-50\%) of the original samples. We introduce a new neural network-based technique for this problem that is inspired image super-resolution algorithms~\citep{Dong:2016:ISU:2914182.2914303}, which use machine learning techniques to interpolate a low-resolution image into a higher-resolution one. Learning-based methods often perform better in this context than general-purpose interpolation schemes such as splines because they leverage sophisticated domain-specific models of the appearance of natural signals.
 
As in image super-resolution, our model is trained on pairs of low and high-quality samples; at test-time, it predicts the missing samples of a low-resolution input signal. Unlike recent neural networks for generating raw audio, our model is fully feedforward and can be run in real-time. In addition to having multiple practical applications, our method also suggests new ways to improve existing generative models of audio.

\subsection{Contributions}



From a practical perspective, our technique has applications in telephony, compression, text-to-speech generation, forensic analysis, and in other domains. It outperforms baselines at $2\times$, $4\times$, and $6\times$ upscaling ratios, while also being significantly simpler than previous methods. Whereas most existing audio enhancement methods make substantial use of signal processing theory, our approach is conceptually very simple and requires no specialized knowledge to implement. Our neural networks are simply trained to map one audio time series into another. Our approach is also among the first to use convolutional architectures for bandwidth extension; as a result, it scales better with dataset size and computational resources relative to current alternatives.

From a generative modeling perspective, our work demonstrates that purely feedforward architectures operating in a non-discretized output space can achieve good performance on an important audio generation task. 
This hints at the possibility of designing improved generative models for audio that combine both feedforward and recurrent components.

\section{Setup and background}

\paragraph{Audio processing.} 
We represent an audio signal as a function $s(t) : [0,T] \to \mathbb{R}$, where $T$ is the duration of the signal (in seconds) and $s(t)$ is the amplitude at $t$. Taking a digital measurement of $s$ requires us to discretize the continuous function $s(t)$ into a vector $x(t) :  \{\frac{1}{R}, \frac{2}{R},..., \frac{RT}{R}\} \to \mathbb{R}$. We refer to $R$ as the {\em sampling rate} of $x$ (in Hz). Sampling rates may range from 4 KHz (low-quality telephone speech) to 44 Khz (high-fidelity music).

In this work, we interpret $R$ as the resolution of $x$; our goal is to increase the resolution of audio samples by predicting $x$ from a fraction of its samples taken at $\{\frac{1}{R}, \frac{2}{R},..., \frac{RT}{R}\}$. Note that by basic signal processing theory, this is equivalent to predicting the higher frequencies of $x$.

\paragraph{Bandwidth extension.}

Audio upsampling has been studied in the audio processing community under the name {\em bandwidth extension} \citep{ekstrand2002bandwidth,larsen2005audio}. Several learning-based approaches have been proposed, including Gaussian mixture models \citep{cheng1994statistical, park2000narrowband} and neural networks \citep{li2015dnn}. These methods typically involve hand-crafted features and use relatively simple models (e.g., neural networks with at most 2-3 densely connected layers) that are often part of a larger, more complex systems. 
In comparison, our method is conceptually simple (operating directly on the raw audio signal), scalable (our neural networks are fully convolutional and fully feed-forward), more accurate, and is also among the few to have been tested on non-speech audio.





\section{Method}

\begin{figure}[t]
\vspace{-7mm}
\begin{center}
\includegraphics[width=12cm]{figures/generator2-compact.png}
\end{center}
\caption{Deep residual network used for audio super-resolution. We extract features via $B$ residual blocks; upscaling is done via stacked SubPixel layers.}
\end{figure}

\subsection{Setup}

Given a low resolution signal $x = \{x_{1/R_1}, ... x_{R_1 T_1 / R_1}\}$ sampled at a rate $R_1$, our goal is to reconstruct a high-resolution version $y = \{y_{1 / R_2}, ... y_{R_2 T_2 / R_2}\}$ of $x$ that has a sampling rate $R_2 > R_1$. For example, $x$ may be a voice signal transmitted via a standard telephone connection at 4 KHz; $y$ may be a high-resolution 16 KHz reconstruction of the orignal.
We use $r = R_2/R_1$ to denote the {\em upsampling ratio} of the two signals, which in our work equals $r=2,4,6$. We thus expect that $y_{r t / R_2} \approx x_{t / R_1}$ for $t = 1,2,...,T_1 R_1$.

To recover the under-defined signal, we learn a model $p(y \vert x)$ of the higher-resolution $y$, conditioned on its low-resolution instantiation $x$. 
We assume that the relationship between the time series $x, y$ follows the equation
$y = f_\theta(x) + \epsilon,$
where $\epsilon \sim \mathcal{N}(0,1)$ is Gaussian noise and $f_\theta$ is a model parametrized by $\theta$. Our framework also extends to more complex noise models which the user may provide as a prior or that may be themselves parametrized by the model (similarly to how one parametrizes the normal distribution in a variational autoencoder).

The above formulation naturally leads to a mean squared error (MSE) objective  
\begin{equation}
\ell(\mathcal{D}) = \frac{1}{n} \sqrt{ \sum_{i=1}^n ||y_i - f_\theta(x_i)||_2^2 }
\end{equation}
for determining the parameters $\theta$ based on a dataset $\mathcal{D} = \{x_i, y_i\}_{i=1}^n$ of source/target time series pairs. Since our model is fully convolutional, we may take the $x_i, y_i$ to be small patches sampled from the full time series.

\begin{figure}[t]
\begin{center}
\includegraphics[width=14cm]{figures/spectrogram2.pdf}
\end{center}
\vspace{-5mm}
\caption{Audio super-resolution visualized using spectrograms. A high-quality speech signal (leftmost) is subsampled at $r=4$, resulting in the loss of high frequencies (2nd from left). We recover the missing signal using a trained neural network (rightmost), greatly outperforming the cubic baseline (second from right). }
\end{figure}

\subsection{Model Architecture} 

We parametrize the function $f$ with a deep convolutional neural network with residual connections; our neural network architecture is based on ideas from \citet{ShiCHTABRW16}, \citet{Dong:2016:ISU:2914182.2914303}, and \citet{pix2pix2016}, and is shown in Figure 1.
We highlight its main features below.




\paragraph{Bottleneck architecture.}

Our model contains $B$ successive downsampling and upsampling {\em blocks}: each performs a convolution, batch normalization, and applies a ReLU non-linearity. Downsampling block $b=1,2,...,B$ contains $\max(2^{6+b}, 512)$ convolutional filters of length $\min(2^{7-b}+1, 9)$ and a stride of $2$. Upsampling block $b$ has $\max(2^{7+(B-b+1)}, 512)$ filters of length $\min(2^{7-(B-b+1)}+1, 9)$.

Thus, at a downsampling step, we halve the spatial dimension and double the filter size; during upsampling, this is reversed. This bottleneck architecture is inspired by auto-encoders, and is known to encourage the model to learn a hierarchy of features. For example, on an audio task, bottom layers may extract wavelet-style features, while higher ones may correspond to phonemes \cite{DBLP:conf/nips/AytarVT16}. Note that the model is fully convolutional, and may run on input sequences of arbitrary length.

\paragraph{Skip connections.}

When the source series $x$ is similar to the target $y$, downsampling features will be also be useful for upsampling \citep{pix2pix2016}. We thus add additional skip connections which stack the tensor of $b$-th downsampling features with the $(B-b+1)$-th tensor of upsampling features. We also add an additive residual connection from the input to the final output: the model thus only needs to learn $y-x$, which in practice speeds up training.

\paragraph{Subpixel shuffling layer.}

In order to increase the time dimension during upscaling, we have implemented a one-dimensional version of the Subpixel layer of \citet{ShiCHTABRW16}, which has been shown to be less prone to produce artifacts \citep{odena2016deconvolution}.

An upscaling block's convolution maps an input tensor of dimension $F \times d$ into one of size $F/2 \times d$.
The subpixel layer reshuffles this $F/2 \times d$ tensor into another one of size $F/4 \times 2d$ (while preserving the tensor entries intact); these are concatenated with $F/4$ features from the downsampling stage, for a final output of size $F/2 \times 2d$. Thus, we have halved the number of filters and doubled the spatial dimension.

\section{Experiments}

\paragraph{Datasets.} 

We use the VCTK dataset \citep{yamagishienglish} --- which contains 44 hours of data from 108 different speakers --- and the Piano dataset of \citet{mehri2016samplernn} (10 hours of  Beethoven sonatas). 
We generate low-resolution audio signal from the 16 KHz originals by applying an order 8 Chebyshev type I low-pass filter before subsampling the signal by the desired scaling ratio.

We evaluate our method in three regimes.
The {\sc SingleSpeaker} task trains the model on the first 223 recordings of VCTK Speaker 1 (about 30 mins) and tests on the last 8 recordings.
The {\sc MultiSpeaker} task assesses our ability to generalize to new speakers. We train on the first 99 VCTK speakers and test on the 8 remaining ones; our recordings feature different voices and accents (Scottish, Indian, etc.)
Lastly, the {\sc Piano} task extends audio-super resolution to non-vocal data; we use the standard 88\%-6\%-6\% data split.


\paragraph{Methods.}

We compare our method relative to two baselines: a cubic B-spline --- which corresponds to the bicubic upsampling baseline used in image super-resolution --- and the recent neural network-based technique of \citet{li2015dnn}, 



The latter approach takes as input the short-time Fourier transform (STFT) of the input and predicts directly the phase and the magnitudes of the high frequency components using a dense neural network with three hidden layers of size 2048 and ReLU nonlinearities.
\citet{li2015dnn} have shown that this method is preferred over Gaussian Mixture Models in 84\% of cases in a user study.
This model requires that the scaling ratio be a power of $2$, hence it is not applicable when $r=6$.


We instantiate our model with $B=4$ blocks and train it for 400 epochs on patches of length 6000 (in the high-resolution space) using the ADAM optimizer with a learning rate of $10^{-4}$. To ensure source/target series are of the same length, the source input is pre-processed with cubic upscaling.
We do not compare against previously-proposed matrix factorization techniques \citep{Bansal05bandwidthexpansion,DBLP:conf/ismir/LiangHE13}, as they are typically trained on $<$ 10 input examples \citep{DBLP:conf/mlsp/SunM13} (due to the cost of jointly factorizing a large number of matrices), and do not scale to the size of our datasets.



\paragraph{Metrics}

Given a reference signal $y$ and an approximation $x$, the Signal to Noise Ratio (SNR) is defined as
\begin{equation}
\text{SNR}(x,y) = 10 \log \frac{|| y ||_2^2}{|| x-y ||_2^2}.
\end{equation}
The SNR is a standard metric used in the signal processing literature.
The Log-spectral distance (LSD) \citep{gray1976distance} measures the reconstruction quality of individual frequencies as follows:
\begin{equation}
\text{LSD}(x,y) = \frac{1}{L} \sum_{\ell=1}^L \sqrt{\frac{1}{K} \sum_{k=1}^K \left( X(\ell, k) - \hat X(\ell, k) \right)^2 }, 
\end{equation}
where $X$ and $\hat X$ are the log-spectral power magnitudes of $y$ and $x$, respectively. These are defined as $ X = \log |S|^2 $, where $S$ is the short-time Fourier transform (STFT) of the signal. We use $\ell$ and $k$ index frames and frequencies, respectively; in our experiments, we used frames of length 2048.

\paragraph{Evaluation} 

\begin{wraptable}{r}{0.5\textwidth}
\vspace{-3mm}
\begin{tabular}{rcccc|c}
& \multicolumn{4}{c}{MultiSpeaker Sample} & \\
\hline
 & 1 & 2 & 3 & 4 & Average \\
\hline
Ours & 69 & 75 & 64 & 37 & 61.3 \\
DNN & 51 & 55 & 66 &  53 & 56.3 \\
Spline & 31 & 25 & 38 & 47 & 35.3 \\
\hline
\end{tabular}
\caption{MUSHRA user study scores. We show scores for each sample, averaged individual users. Average across all samples is also displayed}
\label{mos}
\end{wraptable}

The results of our experiments are summarized in Table 2. Our objective metrics show an improvement of 1-5 dB over the baselines, with the strongest improvements at higher upscaling factors.
Although, the spline baseline achieves a high SNR, its signal often lacks higher frequencies; the LSD metric is better at identifying this problem. 
Our technique also improves over the DNN baseline; our convolutional architecture appears to use our  modeling capacity more efficiently than a dense neural network, and we expect such architectures will soon be more widely used in audio generation tasks.










\begin{table}[t]
\label{multispeaker}
\begin{center}
\begin{tabular}{lr|rrr|rrr|rrr}
& & \multicolumn{3}{c}{SingleSpeaker}  & \multicolumn{3}{c}{MultiSpeaker} & \multicolumn{3}{c}{Piano}                  \\
\hline
Ratio & Obj. & Spline & DNN & Ours  & Spline & DNN & Ours  & Spline & DNN & Ours \\
\hline
$r=2$    & SNR & 20.3 & 20.1 & 21.1 & 19.7 & 19.9 & 20.7 & 29.4 & 29.3 & 30.1 \\
    & LSD & 4.5 & 3,7 & 3.2 & 4.4 & 3.6 & 3.1 & 3.5 & 3.4 & 3.4 \\
$r=4$    & SNR & 14.8 & 15.9 & 17.1  & 13.0 & 14.9 & 16.1  & 22.2 & 23.0 & 23.5 \\
    & LSD & 8.2 & 4.9 & 3.6  & 8.0 & 5.8 & 3.5 & 5.8 & 5.2 & 3.6 \\
$r=6$    & SNR & 10.4 & n/a & 14.4  & 9.1 & n/a & 10.0 & 15.4 & n/a & 16.1 \\
    & LSD & 10.3 & n/a & 3.4  & 10.1 & n/a & 3.7 & 7.3 & n/a & 4.4 \\
\end{tabular}
\end{center}
\caption{Accuracy evaluation of audio-super resolution methods (in dB) on each of the three super-resolution tasks at upscaling ratios $r=2,4,6$.}
\end{table}


Next, we confirmed our objective experiments with a study in which human raters were asked to assess the quality of super-resolution using a MUSHRA (MUltiple Stimuli with Hidden Reference and Anchor) test. For each trial an audio sample was upscaled using different techniques\footnote{We have posted a our set of samples to: {\texttt https://kuleshov.github.io/audio-super-res/}.}. We collected four VCTK speaker recordings audio samples from the {\sc MultiSpeaker} testing set. For each recording, we collected the original utterance, a downsampled version at $r=4$, as well as signals super-resolved using Splines, DNNs, and our model (six versions in total). We recruited 10 subjects and used an online survey to ask each of them to rate each sample on a scale of 0 (extremely bad) to 100 (excellent) reconstruction.
The results from the experiment are summarized in Table \ref{mos}.
Our method ranked as being the best out of the three upscaling techniques.

\paragraph{Domain adaptation.}

\begin{wraptable}{r}{0.45\textwidth}
\vspace{-3mm}
\begin{small}
\begin{tabular}{rrrrr}
\hline
 & \multicolumn{2}{c}{LPF {\scriptsize (Test)}} & \multicolumn{2}{c}{No LPF {\scriptsize (Test)}} \\
  & SNR & LSD & SNR & LSD  \\
\hline
LPF {\scriptsize (Train)}  & 30.1 & 3.4 & 0.42 & 4.5   \\
No LPF {\scriptsize (Train)}  & 0.43 & 4.4 & 33.2 & 3.3  \\
\hline
\end{tabular}
\caption{Sensitivity of the model to whether low-resolution audio was subject to a low-pass filter (LPF) in dB.
}\label{scaling}
\vspace{-1mm}
\end{small}
\end{wraptable}

We tested the sensitivity of our method to out-of-distribution input via an audio super-resolution experiment in which the training set did not use a low-pass filter, while the test set did, and vice-versa.
We focused on the {\sc Piano} task and $r=2$. The output from the model was noisier than expected, indicating that generalization is an important practical concern. 
We suspect this behavior may be common in super-resolution algorithms, but has not been widely documented. A potential solution would be to train on data that has been generated using multiple techniques.

In addition, we examined the ability of our model to generalize from speech to music and vice versa. 
We found that switching domains produced noisy output, again highlighting the specialization of the model.






\paragraph{Architectural analysis.}


We examined the importance of our various architectural design choices via an ablation analysis on the {\sc MultiSpeaker} audio super-resolution task using an upscaling ratio of $r=4$. The adjacent figure displays the result: the green-ish line display the validation set $\ell_2$ loss of the original model over time; the yellow curve removes the additive residual connection; the green curve further removes the additive skip connection (while preserving the same total number of filters). This shows that symmetric skip connections are crucial for attaining good performance; additive connections add an additional small, but perceptible, improvement.

\begin{wrapfigure}{r}{0.53\textwidth}
\label{fig:curves}
\vspace{-5mm}
\includegraphics[width=8cm]{figures/ablation.pdf}
\vspace{-7mm}
\begin{small}
\caption{Model ablation analysis on the MultiSpeaker audio super-resolution task with $r=4$.
}\end{small}
\end{wrapfigure}





\paragraph{Computational performance.}

Our model is computationally efficient and can be run in real time. 
On the {\sc Piano} task (where all input signals are 12s in length), our method processed a single second of audio in 0.11s on average on a Titan X GPU. Training our models, however, required about 2 days for the {\sc MultiSpeaker} task.
Unlike sequence-to-sequence architectures our model does not require the complete input sequence in order to begin generating an output sequence.

\subsection{Limitations}

Finally, to explore the limits of our approach, we evaluated our method on the MagnaTagATune dataset, which consists of about 200 hours of music from 188 different genres. This dataset is larger and much more diverse that the ones we considered so far. We found that our model underfit the dataset, with very little reduction in the training error, and no improvement over the spline baseline. Other learning-based baselines fared similarly. However, we expect improved results with a larger model and more computational resources.

\section{Previous Work and Discussion}

\paragraph{Time series modeling.}

In the machine learning literature, time series signals have most often been modeled with auto-regressive models, of which variants of recurrent networks are a special case \citep{gers2001applying,45168,mehri2016samplernn}.
Our approach instead generalizes conditional modeling ideas used in computer vision for tasks such as
image super-resolution \citep{Dong:2016:ISU:2914182.2914303,DBLP:journals/corr/LedigTHCATTWS16} or colorization \citep{zhang2016colorful}. 

We identify a broad class of conditional time series modeling problems that arise in signal processing, biomedicine, and other fields and that are characterized by a natural alignment among source/target series pairs and differences that are well-represented by local transformations. We propose a general architecture for such problems and show that it works well in different domains. 


\paragraph{Bandwidth extension.}

Existing learning-based approaches include Gaussian mixture models \citep{cheng1994statistical,park2000narrowband,pulakka2011speech}, linear predictive coding \citep{bradbury2000linear}, and neural networks \citep{li2015dnn}. 
Our work proposes the first convolutional architecture, which we find to scale better with dataset size and outperform recent, specialized methods.
Moreover, while existing techniques involve many hand-crafted features (see e.g., \citet{pulakka2011speech}); our approach is fully domain-agnostic.





\paragraph{Audio applications.} In telephony, commercial efforts are underway to transmit voice at higher rates (typically 16 Khz) in specific handsets; audio-super resolution is a step towards recreating this experience in software. Similar applications could be found in compression, text-to-speech generation, and forensic analysis.
More generally, our work demonstrates the effectiveness of feedforward convolutional architectures on an audio generation task.

\section{Conclusion}

Machine learning techniques based on deep neural networks have been successful at solving under-defined problems in signal processing such as image super-resolution, colorization, in-painting, and many others. 
Learning-based methods often perform better in this context than general-purpose algorithms because they leverage sophisticated domain-specific models of the appearance of natural signals.

In this work, we proposed new techniques that use this insight to upsample audio signals. Our technique extends previous work on image super-resolution to the audio domain; it outperforms previous bandwidth extension approaches on both speech and non-vocal music. Our approach is fast and simple to implement, and has applications in telephony, compression, and text-to-speech generation. It also demonstrates the effectiveness of feedforward architectures on an important audio generation task, suggesting new directions for generative audio modeling.





\bibliography{all}
\bibliographystyle{iclr2017_workshop}

\end{document}
