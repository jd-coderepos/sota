\documentclass{article} 

\usepackage{titling}
\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{amsmath}
\usepackage{nicefrac}       \usepackage{microtype}      \usepackage{amsthm}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{wrapfig}
\usepackage{bm}
\usepackage{multirow}
\usepackage{mathtools}
\usepackage{lscape}
\newcommand{\eat}[1]{}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{definition}{Definition}
\newtheorem{corollary}{Corollary}
\newtheorem{remark}{Remark}



\usepackage{iclr2020_conference,times}
\iclrfinalcopy


\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{hyperref}
\usepackage{url}
\graphicspath{{./}{./figures/}}
\pdfinfo{
/Title (DropEdge: Towards Deep Graph Convolutional Networks on Node Classification)
/Author (Yu Rong, Wenbing Huang, Tingyang Xu, Junzhou Huang)
}

\title{DropEdge: Towards Deep Graph Convolutional Networks on Node Classification}



\author{
  Yu Rong, Wenbing Huang, ~Tingyang Xu, Junzhou Huang \\
  Tencent AI Lab \\
  Beijing National Research Center for Information Science and Technology (BNRist),\\
 State Key Lab on Intelligent Technology and Systems,\\
 Department of Computer Science and Technology, Tsinghua University\\
 \texttt{yu.rong@hotmail.com, hwenbing@126.com}\\
 \texttt{tingyangxu@tencent.com, jzhuang@uta.edu} \\
 }

\iclrfinalcopy


\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\begin{document}


\maketitle

\begin{abstract}
\emph{Over-fitting} and \emph{over-smoothing} are two main obstacles of developing deep Graph Convolutional Networks (GCNs) for node classification. In particular, over-fitting weakens the generalization ability on small dataset, while over-smoothing impedes model training by isolating output representations from the input features with the increase in network depth. This paper proposes DropEdge, a novel and flexible technique to alleviate both issues. At its core, DropEdge randomly removes a certain number of edges from the input graph at each training epoch, acting like a data augmenter and also a message passing reducer. Furthermore, we theoretically demonstrate that DropEdge either reduces the convergence speed of over-smoothing or relieves the information loss caused by it. More importantly, our DropEdge is a general skill that can be equipped with many other backbone models (\emph{e.g.} GCN, ResGCN, GraphSAGE, and JKNet) for enhanced performance. Extensive experiments on several benchmarks verify that DropEdge consistently improves the performance on a variety of both shallow and deep GCNs. The effect of DropEdge on preventing over-smoothing is empirically visualized and validated as well. Codes are released on~\url{https://github.com/DropEdge/DropEdge}.




\end{abstract}

\section{Introduction}

Graph Convolutional Networks (GCNs), which exploit message passing or equivalently certain neighborhood aggregation function to extract high-level features from a node as well as its neighborhoods, have boosted the state-of-the-arts for a variety of tasks on graphs, such as node classification~\citep{Bhagat2011,Zhang2018}, social recommendation~\citep{Freeman2000,perozzi2014deepwalk}, and link prediction~\citep{Liben-Nowell2007} to name some. In other words, GCNs have been becoming one of the most crucial tools for graph representation learning.
Yet, when we revisit typical GCNs on node classification~\citep{Kipf2017}, they are usually shallow (\emph{e.g.} the number of the layers is 2\footnote{When counting the number of layers (or network depth) of GCN, this paper does not involve the input layer.}). Inspired from the success of deep CNNs on image classification, several attempts have been proposed to explore how to build deep GCNs towards node classification~\citep{Kipf2017,Li2018,Xu2018, li2019can}; nevertheless, none of them delivers sufficiently expressive architecture. The motivation of this paper is to analyze the very factors that impede deeper GCNs to perform promisingly, and develop method to address them.




We begin by investigating two factors: \emph{over-fitting} and \emph{over-smoothing}. Over-fitting comes from the case when we utilize an over-parametric model to fit a distribution with limited training data, where the model we learn fits the training data very well but generalizes poorly to the testing data. It does exist if we apply a deep GCN on small graphs (see 4-layer GCN on Cora in Figure~\ref{fig.compare}).
Over-smoothing, towards the other extreme, makes training a very deep GCN difficult.
As first introduced by~\citet{Li2018} and further explained in~\citet{Wu2019,Xu2018,Klicpera2019}, graph convolutions essentially push representations of adjacent nodes mixed with each other, such that, if extremely we go with an infinite number of layers, all nodes' representations will converge to a stationary point, making them unrelated to the input features and leading to vanishing gradients. We call this phenomenon as over-smoothing of node features.
To illustrate its influence, we have conducted an example experiment with 8-layer GCN in Figure~\ref{fig.compare}, in which the training of such a deep GCN is observed to converge poorly.

Both of the above two issues can be alleviated, using the proposed method, DropEdge. The term ``DropEdge'' refers to randomly dropping out certain rate of edges of the input graph for each training time.
There are several benefits in applying DropEdge for the GCN training (see the experimental improvements by DropEdge in Figure~\ref{fig.compare}). First, DropEdge can be considered as a data augmentation technique. By DropEdge, we are actually generating different random deformed copies of the original graph; as such, we augment the randomness and the diversity of the input data, thus better capable of preventing over-fitting.
Second, DropEdge can also be treated as a message passing reducer. In GCNs, the message passing between adjacent nodes is conducted along edge paths. Removing certain edges is making node connections more sparse, and hence avoiding over-smoothing to some extent when GCN goes very deep. Indeed, as we will draw theoretically in this paper, DropEdge either reduces the convergence speed of over-smoothing or relieves the information loss caused by it.




We are also aware that the dense connections employed by JKNet~\citep{Xu2018} are another kind of tools that can potentially prevent over-smoothing. In its formulation, JKNet densely connects each hidden layer to the top one, hence the feature mappings in lower layers that are hardly affected by over-smoothing are still maintained. Interestingly and promisingly, we find that the performance of JKNet can be promoted further if it is utilized along with our DropEdge.  Actually, our DropEdge---as a flexible and general technique---is able to enhance the performance of various popular backbone networks on several benchmarks, including GCN~\citep{Kipf2017}, ResGCN~\citep{li2019can}, JKNet~\citep{Xu2018}, and GraphSAGE~\citep{hamilton2017inductive}. We provide detailed evaluations in the experiments.

\begin{figure}[t]
\centering
\includegraphics [width=0.4\textwidth]{deepcompare_deep_muti_train.pdf}
\includegraphics [width=0.4\textwidth]{deepcompare_deep_muti_val.pdf}
\caption{Performance of Multi-layer GCNs on Cora.
We implement 4-layer GCN w and w/o DropEdge (in orange), 8-layer GCN w and w/o DropEdge (in blue)\protect\footnotemark. GCN-4 gets stuck in the over-fitting issue attaining low training error but high validation error; the training of GCN-8 fails to converge satisfactorily due to over-smoothing. By applying DropEdge, both GCN-4 and GCN-8 work well for both training and validation.}
\label{fig.compare}
\end{figure}\footnotetext{To check the efficacy of DropEdge more clearly, here we have removed bias in all GCN layers, while for the experiments in~\textsection~\ref{sec:exps}, the bias are kept.}













\section{Related Work}
\paragraph{GCNs}
Inspired by the huge success of CNNs in computer vision, a large number of methods come redefining the notion of convolution on graphs under the umbrella of GCNs. The first prominent research on GCNs is presented in \citet{bruna2013spectral}, which develops graph convolution based on spectral graph theory. Later, \citet{Kipf2017,defferrard2016convolutional,henaff2015deep,Li2018a,Levie2017} apply improvements, extensions, and approximations on spectral-based GCNs. To address the scalability issue of spectral-based GCNs on large graphs, spatial-based GCNs have been rapidly developed~\citep{hamilton2017inductive,Monti2017,niepert2016learning,Gao2018}. These methods directly perform convolution in the graph domain by aggregating the information from neighbor nodes. Recently, several sampling-based methods have been proposed for fast graph representation learning, including the node-wise sampling methods~\citep{hamilton2017inductive}, the layer-wise approach~\citep{chen2018fastgcn} and its layer-dependent variant~\citep{Huang2018}. Specifically, GAT~\citep{DBLP:journals/corr/abs-1710-10903} has discussed applying dropout on edge attentions. While it actually is a post-conducted version of DropEdge before attention computation, the relation to over-smoothing is never explored in~\citet{DBLP:journals/corr/abs-1710-10903}. In our paper, however, we have formally presented the formulation of DropEdge and provided rigorous theoretical justification of its benefit in alleviating over-smoothing. We also carried out extensive experiments by imposing DropEdge on several popular backbones. One additional point is that we further conduct adjacency normalization after dropping edges, which, even simple, is able to make it much easier to converge during training and reduce gradient vanish as the number of layers grows.    


\paragraph{Deep GCNs}
Despite the fruitful progress, most previous works only focus on shallow GCNs while the deeper extension is seldom discussed. The attempt for building deep GCNs is dated back to the  GCN paper~\citep{Kipf2017}, where the residual mechanism is applied; unexpectedly, as shown in their experiments, residual GCNs still perform worse when the depth is 3 and beyond.
The authors in~\citet{Li2018} first point out the main difficulty in constructing deep networks lying in over-smoothing, but unfortunately, they never propose any method to address it. The follow-up study~\citep{Klicpera2019} solves over-smoothing by using personalized PageRank that additionally involves the rooted node into the message passing loop; however, the accuracy is still observed to decrease when the depth increases from 2.
JKNet~\citep{Xu2018} employs dense connections for multi-hop message passing which is compatible with DropEdge for formulating deep GCNs. \citet{oono2019asymptotic} theoretically prove that the node features of deep GCNs will converge to a subspace and incur information loss. It generalizes the conclusion in~\citet{Li2018} by further considering the ReLu function and convolution filters. Our interpretations on why DropEdge can impede over-smoothing is based on the concepts proposed by~\citet{oono2019asymptotic}. A recent method ~\citep{li2019can} has incorporated residual layers, dense connections and dilated convolutions into GCNs to facilitate the development of deep architectures. Nevertheless, this model is targeted on graph-level classification (\emph{i.e.} point cloud segmentation), where the data points are graphs and naturally disconnected from each other. In our task for node classification, the samples are nodes and they all couple with each other, thus the over-smoothing issue is more demanded to be addressed. By leveraging DropEdge, we are able to relieve over-smoothing, and derive more enhanced deep GCNs on node classification.


\section{Notations and Preliminaries}

\paragraph{Notations.}

Let   represent the input graph of size  with nodes  and edges . The node features are denoted as , and the adjacency matrix is defined as  which associates each edge  with its element . The node degrees are given by  where  computes the sum of edge weights connected to node . We define  as the degree matrix whose diagonal elements are obtained from .




\paragraph{GCN}
is originally developed by~\citet{Kipf2017}. The feed forward propagation in GCN is recursively conducted as
\vskip -0.25in

\vskip -0.1in
where  are the hidden vectors of the -th layer with  as the hidden feature for node ;  is the re-normalization of the adjacency matrix, and  is the corresponding degree matrix of ;  is a nonlinear function, \emph{i.e.} the ReLu function; and  is the filter matrix in the -th layer with  refers to the size of -th hidden layer. We denote one-layer GCN computed by~\Eqref{Eq:gcn} as Graph Convolutional Layer (\textbf{GCL}) in what follows.


\section{Our Method: DropEdge}

This section first introduces the methodology of the DropEdge technique as well as its layer-wise variant where the adjacency matrix for each GCN layer is perturbed individually. We also explain how the proposed DropEdge can prevent over-fitting and over-smoothing in generic GCNs. Particularly for over-smoothing, we provide its mathematical definition and theoretical derivations on showing the benefits of DropEdge.

\subsection{Methodology}
\label{sec:methodology}
At each training epoch, the DropEdge technique drops out a certain rate of edges of the input graph by random. Formally, it randomly enforces  non-zero elements of the adjacency matrix  to be zeros, where  is the total number of edges and  is the dropping rate. If we denote the resulting adjacency matrix as , then its relation with  becomes

where  is a sparse matrix expanded by a random subset of size  from original edges . Following the idea of~\cite{Kipf2017}, we also perform the re-normalization trick  on , leading to . We replace  with  in \Eqref{Eq:gcn} for propagation and training. When validation and testing, DropEdge is not utilized.

\paragraph{Preventing over-fitting.}
DropEdge produces varying perturbations of the graph connections. As a result, it generates different random deformations of the input data and can be regarded as a data augmentation skill for graphs. To explain why this is valid, we provide an intuitive understanding here.
The key in GCNs is to aggregate neighbors' information for each node, which can be understood as a weighted sum of the neighbor features (the weights are associated with the edges). From the perspective of neighbor aggregation, DropEdge enables a random subset aggregation instead of the full aggregation during GNN training. Statistically, DropEdge only changes the expectation of the neighbor aggregation up to a multiplier , if we drop edges with probability . This multiplier will be actually removed after weights normalization, which is often the case in practice. Therefore, DropEdge does not change the expectation of neighbor aggregation and is an unbiased data augmentation technique for GNN training, similar to typical image augmentation skills (\emph{e.g.} rotation, cropping and flapping) that are capable of hindering over-fitting in training CNNs. We will provide experimental validations in \textsection~\ref{sec.cmpdropedge}.



\paragraph{Layer-Wise DropEdge.}
The above formulation of DropEdge is one-shot with all layers sharing the same perturbed adjacency matrix. Indeed, we can perform DropEdge for each individual layer. Specifically, we obtain  by independently computing~\Eqref{Eq:DropEdge} for each -th layer. Different layer could have different adjacency matrix . Such layer-wise version brings in more randomness and deformations of the original data, and we will experimentally compare its performance with the original DropEdge in \textsection~\ref{sec:exp-dropedge}.

Over-smoothing is another obstacle of training deep GCNs, and we will detail how DropEdge can address it to some extent in the next section. For simplicity, the following derivations assume all GCLs share the same perturbed adjacency matrix, and we will leave the discussion on layer-wise DropEdge for future exploration.


\subsection{Towards preventing over-smoothing}
\label{sec:over-smoothing}
By its original definition in~\citet{Li2018}, the over-smoothing phenomenon implies that the node features will converge to a fixed point as the network depth increases. This unwanted convergence restricts the output of deep GCNs to be only relevant to the graph topology but independent to the input node features, which as a matter of course incurs detriment of the expressive power of GCNs. \citet{oono2019asymptotic} has generalized the idea in~\citet{Li2018} by taking both the non-linearity (\emph{i.e.} the ReLu function) and the convolution filters into account; they explain over-smoothing as convergence to a subspace rather than convergence to a fixed point. This paper will use the concept of subspace by~\citet{oono2019asymptotic} for more generality.

We first provide several relevant definitions that facilitate our later presentations.
\begin{definition}[subspace]
Let  be an -dimensional subspace in , where  is orthogonal, \emph{i.e.} , and .
\end{definition}
\begin{definition}[-smoothing]
We call the -smoothing of node features happens for a GCN, if all its hidden vectors  beyond a certain layer  have a distance no larger than  () with respect to a subspace  that is independent to the input features, namely,

where  computes the distance between the input matrix and the subspace .\footnote{The definition of  is provided in the supplementary material.}
\end{definition}
\begin{definition}[the -smoothing layer]
Given the subspace  and , we call the minimal value of the layers that satisfy~\Eqref{Eq:mix} as the -smoothing layer, that is, .
\end{definition}

Since conducting analysis exactly based on the -smoothing layer is difficult, we instead define the relaxed -smoothing layer which is proved to be an upper bound of .
\begin{definition}[the relaxed -smoothing layer] 
Given the subspace  and , we call  as the relaxed smoothing layer, where,  computes the ceil of the input,  is the supremum of the filters' singular values over all layers, and  is the second largest eigenvalue of . Besides, we have \footnote{ All detailed definitions and proofs are provided in the appendix.}.
\end{definition}


According to the conclusions by the authors in~\citet{oono2019asymptotic}, a sufficiently deep GCN will certainly suffer from the -smoothing issue for any small value of  under some mild conditions (the details are included in the supplementary material). Note that they only prove the existence of -smoothing in deep GCN without developing any method to address it.

Here, we will demonstrate that adopting DropEdge alleviates the -smoothing issue in two aspects: \textbf{1.} By reducing node connections, DropEdge is proved to slow down the convergence of over-smoothing; in other words, the value of the relaxed -smoothing layer will only increase if using DropEdge. \textbf{2.} The gap between the dimensions of the original space and the converging subspace, \emph{i.e.}  measures the amount of information loss; larger gap means more severe information loss. As shown by our derivations, DropEdge is able to increase the dimension of the converging subspace, thus capable of reducing information loss.

We summarize our conclusions as follows.
\begin{theorem}
\label{The:smoothing}
We denote the original graph as  and the one after dropping certain edges out as . Given a small value of , we assume  and  will encounter the -smoothing issue with regard to subspaces  and , respectively. Then, either of the following inequalities holds after sufficient edges removed.
\begin{itemize}
    \item The relaxed smoothing layer only increases: ;
    \item The information loss is decreased: .
\end{itemize}
\end{theorem}

The proof of Theorem~\ref{The:smoothing} is based on the derivations in~\citet{oono2019asymptotic} as well as the concept of \emph{mixing time} that has been studied in the random walk theory~\citep{Lovasz1993}. We provide the full details in the supplementary material. Theorem~\ref{The:smoothing} tells that DropEdge either reduces the convergence speed of over-smoothing or relieves the information loss caused by it. In this way, DropEdge enables us to train deep GCNs more effectively.


\subsection{discussions}\label{sec.discussions}
This sections contrasts the difference between DropEdge and other related concepts including Dropout, DropNode, and Graph Sparsification.

\paragraph{DropEdge vs. Dropout}
The Dropout trick~\citep{Hinton2012} is trying to perturb the feature matrix by randomly setting feature dimensions to be zeros, which may reduce the effect of over-fitting but is of no help to preventing over-smoothing since it does not make any change of the adjacency matrix. As a reference, DropEdge can be regarded as a generation of Dropout from dropping feature dimensions to dropping edges, which mitigates both over-fitting and over-smoothing. In fact, the impacts of Dropout and DropEdge are complementary to each other, and their compatibility will be shown in the experiments.

\paragraph{DropEdge vs. DropNode}
Another related vein belongs to the kind of node sampling based methods, including GraphSAGE~\citep{hamilton2017inductive}, FastGCN~\citep{chen2018fastgcn}, and AS-GCN~\citep{Huang2018}. We name this category of approaches as DropNode. For its original motivation, DropNode samples sub-graphs for mini-batch training, and it can also be treated as a specific form of dropping edges since the edges connected to the dropping nodes are also removed. However, the effect of DropNode on dropping edges is node-oriented and indirect. By contrast, DropEdge is edge-oriented, and it is possible to preserve all node features for the training (if they can be fitted into the memory at once), exhibiting more flexibility. Further, to maintain desired performance, the sampling strategies in current DropNode methods are usually inefficient, for example, GraphSAGE suffering from the exponentially-growing layer size, and AS-GCN requiring the sampling to be conducted recursively layer by layer. Our DropEdge, however, neither increases the layer size as the depth grows nor demands the recursive progress because the sampling of all edges are parallel.


\paragraph{DropEdge vs. Graph-Sparsification}
Graph-Sparsification~\citep{eppstein1997sparsification} is an old research topic in the graph domain. Its optimization goal is removing unnecessary edges for graph compressing while keeping almost all information of the input graph. This is clearly district to the purpose of DropEdge where no optimization objective is needed. Specifically, DropEdge will remove the edges of the input graph by random at each training time, whereas Graph-Sparsification resorts to a tedious optimization method  to determine which edges to be deleted, and once those edges are discarded the output graph keeps unchanged.



\section{Experiments}
\label{sec:exps}

\paragraph{Datasets} Joining the previous works' practice, we focus on four benchmark datasets varying in graph size and feature type: (1) classifying the research topic of papers in three citation datasets: Cora, Citeseer and Pubmed~\citep{sen2008collective}; (2) predicting which community different posts belong to in the Reddit social network~\citep{hamilton2017inductive}. Note that the tasks in Cora, Citeseer and Pubmed are transductive underlying all node features are accessible during training, while the task in Reddit is inductive meaning the testing nodes are unseen for training. We apply the full-supervised training fashion used in~\citet{Huang2018} and \citet{chen2018fastgcn} on all datasets in our experiments. The statics of all datasets are listed in the supplemental materials.

\begin{table}[htbp]
  \centering
  \caption{Testing accuracy (\%) comparisons on different backbones w and w/o DropEdge.}
    \vspace{-2ex}
    \small
    \begin{tabular}{rl|rr|rr|rr}
    \hline
    \multicolumn{1}{c}{\multirow{2}[4]{*}{Dataset}} & \multicolumn{1}{c|}{\multirow{2}[4]{*}{Backbone}} & \multicolumn{2}{c|}{2 layers} & \multicolumn{2}{c|}{8 layers} & \multicolumn{2}{c}{32 layers} \\
\cline{3-8}          &       & \multicolumn{1}{c}{Orignal} & \multicolumn{1}{c|}{DropEdge} & \multicolumn{1}{c}{Orignal} & \multicolumn{1}{c|}{DropEdge} & \multicolumn{1}{c}{Orignal} & \multicolumn{1}{c}{DropEdge} \\
    \hline
    \multicolumn{1}{c}{\multirow{5}[2]{*}{Cora}} & GCN   & 86.10 & \textbf{86.50} & 78.70 & \textbf{85.80} & 71.60 & \textbf{74.60} \\
          & ResGCN & -     & -     & 85.40 & \textbf{86.90} & 85.10 & \textbf{86.80} \\
          & JKNet & -     & -     & 86.70 & \textbf{87.80} & 87.10 & \textbf{87.60} \\
          & IncepGCN & -     & -     & 86.70 & \textbf{88.20} & 87.40 & \textbf{87.70} \\
          & GraphSAGE & 87.80 & \textbf{88.10} & 84.30 & \textbf{87.10} & 31.90 & \textbf{32.20} \\
    \hline
    \multicolumn{1}{c}{\multirow{5}[2]{*}{Citeseer}} & GCN   & 75.90 & \textbf{78.70} & 74.60 & \textbf{77.20} & 59.20 & \textbf{61.40} \\
          & ResGCN & -     & -     & 77.80 & \textbf{78.80} & 74.40 & \textbf{77.90} \\
          & JKNet & -     & -     & 79.20 & \textbf{80.20} & 71.70 & \textbf{80.00} \\
          & IncepGCN & -     & -     & 79.60 & \textbf{80.50} & 72.60 & \textbf{80.30} \\
          & GraphSAGE & 78.40 & \textbf{80.00} & 74.10 & \textbf{77.10} & 37.00 & \textbf{53.60} \\
    \hline
    \multicolumn{1}{c}{\multirow{5}[2]{*}{Pubmed}} & GCN   & 90.20 & \textbf{91.20} & 90.10 & \textbf{90.90} & 84.60 & \textbf{86.20} \\
          & ResGCN & -     & -     & 89.60 & \textbf{90.50} & 90.20 & \textbf{91.10} \\
          & JKNet & -     & -     & 90.60 & \textbf{91.20} & 89.20 & \textbf{91.30} \\
          & IncepGCN & -     & -     & 90.20 & \textbf{91.50} & OOM   & \textbf{90.50} \\
          & GraphSAGE & 90.10 & \textbf{90.70} & 90.20 & \textbf{91.70} & 41.30 & \textbf{47.90} \\
    \hline
    \multicolumn{1}{c}{\multirow{5}[2]{*}{Reddit}} & GCN   & 96.11 & \textbf{96.13} & 96.17 & \textbf{96.48} & 45.55 & \textbf{50.51} \\
          & ResGCN & -     & -     & 96.37 & \textbf{96.46} & 93.93 & \textbf{94.27} \\
          & JKNet & -     & -     & 96.82 & \textbf{97.02} & OOM   & OOM \\
          & IncepGCN & -     & -     & 96.43 & \textbf{96.87} & OOM   & OOM \\
          & GraphSAGE & 96.22 & \textbf{96.28} & 96.38 & \textbf{96.42} & 96.43 & \textbf{96.47} \\
    \hline
    \end{tabular}\label{tab:dropvsnodrop_small}\end{table}


\subsection{Can DropEdge generally improve the performance of deep GCNs?}\label{sec.cmpdropedge}

In this section, we are interested in if applying DropEdge can promote the performance of current popular GCNs (especially their deep architectures) on node classification.




\paragraph{Implementations}
We consider five backbones: GCN~\citep{Kipf2017}, ResGCN~\citep{he2016deep,li2019can}, JKNet~\citep{Xu2018}, IncepGCN\footnote{The formulation is given in the appendix.} and GraphSAGE~\citep{hamilton2017inductive} with varying depth from 2 to 64.\footnote{For Reddit, the maximum depth is 32 considering the memory bottleneck.} Since different structure exhibits different training dynamics on different dataset, to enable more robust comparisons, we perform random  hyper-parameter search for each model, and report the case giving the best accuracy on validation set of each benchmark. The searching space of hyper-parameters and more details are provided in Table~\ref{tab:hyperparameterdescription} in the supplementary material. Regarding the same architecture w or w/o DropEdge, we apply the same set of hyper-parameters except the drop rate  for fair evaluation.

\paragraph{Overall Results}
Table~\ref{tab:dropvsnodrop_small} summaries the results on all datasets. We only report the performance of the model with 2/8/32 layers here due to the space limit, and provide the accuracy under other different depths in the supplementary material.
It's observed that DropEdge consistently improves the testing accuracy for all cases. The improvement is more clearly depicted in Figure~\ref{fig:dropimprovement}, where we have computed the average absolute improvement over all backbones by DropEdge on each dataset under different numbers of layers. On Citeseer, for example,
DropEdge yields further improvement for deeper architecture; it gains 0.9\% average improvement for the model with 2 layers while achieving a remarkable 13.5\% increase for the model with 64 layers. In addition, the validation losses of all 4-layer models on Cora are shown in Figure~\ref{fig:dropvallosscmp}. The curves along the training epoch are dramatically pulled down after applying DropEdge, which also explains the effect of DropEdge on alleviating over-fitting.
Another valuable observation in Table~\ref{tab:dropvsnodrop_small} is that the 32-layer IncepGCN without DropEdge incurs the Out-Of-Memory (OOM) issue while the model with DropEdge survives, showing the advantage of DropEdge to save memory consuming by making the adjacency matrix sparse.



\paragraph{Comparison with SOTAs}
We select the best performance for each backbone with DropEdge, and contrast them with existing State of the Arts (SOTA), including GCN, FastGCN, AS-GCN and GraphSAGE in Table~\ref{tab:cmpwithdropnode}; for the SOTA methods, we reuse the results reported in~\citet{Huang2018}. We have these findings: (1) Clearly, our DropEdge obtains significant enhancement against SOTAs; particularly on Reddit, the best accuracy by our method is 97.02\%, and it is better than the previous best by AS-GCN (96.27\%), which is regarded as a remarkable boost considering the challenge on this benchmark.
(2) For most models with DropEdge, the best accuracy is obtained under the depth beyond 2, which again verifies the impact of DropEdge on formulating deep networks.
(3) As mentioned in \textsection~\ref{sec.discussions}, FastGCN, AS-GCN and GraphSAGE are considered as the DropNode extensions of GCNs. The DropEdge based approaches outperform the DropNode based variants as shown in Table~\ref{tab:cmpwithdropnode}, which somehow confirms the effectiveness of DropEdge. Actually, employing DropEdge upon the DropNode methods further delivers promising enhancement, which can be checked by revisiting the increase by DropEdge for GraphSAGE in Table~\ref{tab:dropvsnodrop_small}.




\begin{figure}
\centering
\hspace{-5mm}
\begin{subfigure}[t]{.6\textwidth}
    \centering
    \includegraphics[width=0.98\textwidth]{figures/dropvsnodrop_improvement.pdf}
    \caption{The average absolute improvement by DropEdge.}
    \label{fig:dropimprovement}
\end{subfigure}\hspace{5mm}
\begin{subfigure}[t]{.32\textwidth}
\includegraphics [width=0.98\textwidth]{figures/dropedgevsnodropedge/edgedropcompare_cora_4.pdf}
\caption{The validation loss on different backbones w and w/o DropEdge.}
\label{fig:dropvallosscmp}
\end{subfigure}\vskip -0.15in
\caption{}
\vskip -0.15in
\label{fig.performance}
\end{figure}




\begin{table}[htbp]
  \centering
  \caption{Accuracy (\%) comparisons with SOTAs. The number in parenthesis denotes the network depth for the models with DropEdge.}
  \vspace{-2ex}
\begin{tabular}{lrrrr}
\hline
\multirow{2}[4]{*}{} & \multicolumn{3}{c}{Transductive } & \multicolumn{1}{l}{Inductive} \\
\cline{2-5}      & \multicolumn{1}{c}{Cora} & \multicolumn{1}{c}{Citeseer} & \multicolumn{1}{c}{Pubmed} & \multicolumn{1}{c}{Reddit} \\
\hline
GCN   & 86.64 & 79.34 & 90.22 & 95.68 \\
\hline
FastGCN & 85.00 & 77.60 & 88.00 & 93.70 \\
ASGCN & 87.44 & 79.66 & 90.60 & 96.27 \\
GraphSAGE & 82.20 & 71.40 & 87.10 & 94.32 \\
\hline
GCN+DropEdge & 87.60(4) & 79.20(4) & 91.30(4) & 96.71(4) \\
ResGCN+DropEdge & 87.00(4) & 79.40(16) & 91.10(32) & 96.48(16) \\
JKNet+DropEdge & 88.00(16) & 80.20(8) & 91.60(64) & \textbf{97.02(8)} \\
IncepGCN+DropEdge & \textbf{88.20(8)} & \textbf{80.50(8)} & 91.60(4) & 96.87(8) \\
GraphSAGE+DropEdge & 88.10(4) & 80.00(2) & \textbf{91.70(8)} & 96.54(4) \\
\hline
\end{tabular}\label{tab:cmpwithdropnode}\end{table}

\subsection{How does DropEdge help?}
\label{sec:exp-dropedge}
This section continues a more in-depth analysis on DropEdge and attempts to figure out why it works. Due to the space limit, we only provide the results on Cora, and defer the evaluations on other datasets to the supplementary material.

Note that this section mainly focuses on analyzing DropEdge and its variants,  without the concern with pushing state-of-the-art results. So, we do not perform delicate hyper-parameter selection.
We employ GCN as the backbone in this section. Here, GCN- denotes GCN of depth . The hidden dimension, learning rate and weight decay are fixed to 256, 0.005 and 0.0005, receptively. The random seed is fixed. We train all models with 200 epochs. Unless otherwise mentioned, we do not utilize the ``withloop'' and ``withbn'' operation (see their definitions in Table~\ref{tab:hyper-desc} in the appendix).

\subsubsection{On preventing over-smoothing}


As discussed in \textsection~\ref{sec:over-smoothing}, the over-smoothing issue exists when the top-layer outputs of GCN converge to a subspace and become unrelated to the input features with the increase in depth. Since we are unable to derive the converging subspace explicitly, we measure the degree of over-smoothing by instead computing the difference between the output of the current layer and that of the previous one. We adopt the Euclidean distance for the difference computation. Lower distance means more serious over-smoothing. Experiments are conducted on GCN-8.


\begin{figure}
\centering
\includegraphics [width=0.32\textwidth]{smoothcompare_before.pdf}
\includegraphics [width=0.32\textwidth]{smoothcompare_after.pdf}
\includegraphics [width=0.32\textwidth]{smoothcompare_cora_8-train.pdf}
\vskip -0.11in
\caption{Analysis on over-smoothing. Smaller distance means more serious over-smoothing.}
\vskip -0.11in
\label{fig.featuresmooth}
\end{figure}

Figure~\ref{fig.featuresmooth}~(a) shows the distances of different intermediate layers (from 2 to 6) under different edge dropping rates (0 and 0.8). Clearly, over-smoothing becomes more serious in GCN as the layer grows, which is consistent with our conjecture. Conversely, the model with DropEdge () reveals higher distance and slower convergent speed than that without DropEdge (), implying the importance of DropEdge to alleviating over-smoothing.
We are also interested in how the over-smoothing will act after training. For this purpose, we display the results after 150-epoch training in Figure~\ref{fig.featuresmooth}~(b). For GCN without DropEdge, the difference between outputs of the 5-th and 6-th layers is equal to 0, indicating that the hidden features have converged to a certain stationary point. On the contrary, GCN with DropEdge performs promisingly, as the distance does not vanish to zero when the number of layers grows; it probably has successfully learned meaningful node representations after training, which could also be validated by the training loss in Figure~\ref{fig.featuresmooth}~(c).

\subsubsection{On Compatibility with Dropout}
\textsection~\ref{sec.discussions} has discussed the difference between DropEdge and Dropout. Hence, we conduct an ablation study on GCN-4, and the validation losses are demonstrated in Figure~\ref{fig.abstudy.drop}. It reads that while both Dropout and DropEdge are able to facilitate the training of GCN, the improvement by DropEdge is more significant, and if we adopt them concurrently, the loss is decreased further, indicating the compatibility of DropEdge with Dropout.


\subsubsection{On layer-wise DropEdge}
\textsection~\ref{sec:methodology} has descried the Layer-Wise (LW) extension of DropEdge. Here, we provide the experimental evaluation on assessing its effect. As observed from Figure~\ref{fig.abstudy.layer-independent}, the LW DropEdge achieves lower training loss than the original version, whereas the validation value between two models is comparable. It implies that LW DropEdge can facilitate the training further than original DropEdge. However, we prefer to use DropEdge other than the LW variant so as to not only avoid the risk of over-fitting but also reduces computational complexity since LW DropEdge demands to sample each layer and spends more time.


\begin{figure}
\centering
\begin{subfigure}[t]{.45\textwidth}
\includegraphics [width=0.9\textwidth]{dropvsdrop_cora_4.pdf}
\vskip -0.15in
\caption{Dropout vs DropEdge on Cora. }
\label{fig.abstudy.drop}
\end{subfigure}\hspace{5mm}
\begin{subfigure}[t]{.45\textwidth}
\includegraphics [width=0.9\textwidth]{figures/eachlayersampling/each_layer_sampling_compare_Cora_4_0_2.pdf}
\vskip -0.15in
\caption{Comparison between DropEdge and layer-wise (LW) DropEdge.}
\label{fig.abstudy.layer-independent}
\end{subfigure}\vskip -0.15in
\caption{}
\vskip -0.27in
\label{fig.abstudy}
\end{figure}






















































\section{Conclusion}

We have presented DropEdge, a novel and efficient technique to facilitate the development of deep Graph Convolutional Networks (GCNs). By dropping out a certain rate of edges by random, DropEdge includes more diversity into the input data to prevent over-fitting, and reduces message passing in graph convolution to alleviate over-smoothing. Considerable experiments on Cora, Citeseer, Pubmed and Reddit have verified that DropEdge can generally and consistently promote the performance of current popular GCNs, such as GCN, ResGCN, JKNet, IncepGCN, and GraphSAGE. It is expected that our research will open up a new venue on a more in-depth exploration of deep GCNs for broader potential applications.


\section{Acknowledgements}
This research was funded by National Science and Technology Major Project of the Ministry of Science and Technology of China (No. 2018AAA0102900).
Finally, Yu Rong wants to thank, in particular, the invaluable love and support from Yunman Huang over the years. Will you marry me?

\bibliography{iclr2020_conference}
\bibliographystyle{iclr2020_conference}
\clearpage

\appendix
\section{Appendix: Proof of Theorem 1}
To prove Theorem 1, we need to borrow the following definitions and corollaries from \citet{oono2019asymptotic}. First, we denote the maximum singular value of  by  and set . We assume that  of all layers are initialized so that . Second, we denote the distance that induced as the Frobenius norm from  to  by . Then, we recall Corollary 3 and Proposition 1 in \citet{oono2019asymptotic} as Corollary 1 below.
\begin{corollary}
\label{col:1}
Let  be the eigenvalues of , sorted in ascending order. Suppose the multiplicity of the largest eigenvalue  is , i.e.,  and the second largest eigenvalue is defined as

Let  to be the eigenspace associated with . 
Then we have , and

where . Besides, , implying that the output of the -th layer of GCN on  exponentially approaches .
\end{corollary}


We also need to adopt some concepts from \citet{Lovasz1993} in proving Theorem 1. Consider the graph  as an electrical network, where each edge represents an unit resistance. Then the effective resistance,  from node  to node  is defined as the total resistance between node  and . According to Corollary 3.3 and Theorem 4.1 (i) in \citet{Lovasz1993}, we can build the connection between  and  for each connected component via commute time as the following inequality.






Prior to proving Theorem 1, we first derive the lemma below.
\begin{lemma}
\label{lemma:mixing_time}
The -smoothing happens whenever the layer number satisfies

where  computes the ceil of the input. It means .
\end{lemma}



\begin{proof}
We start our proof from Inequality~\ref{equ:distance}, leading to

When it reaches -smoothing, the following inequality should be satisfied as

Since , then . Therefore, the Inequality~\ref{ineq:lemma2_step1} becomes

Clearly, we have  since  is defined as the minimal layer that satisfies -smoothing.
The proof is concluded.
\end{proof}



Now, we prove Theorem~\ref{The:smoothing}.
\begin{proof}
Our proof relies basically on the connection between  and  in Equation (\ref{eq:res}).
We recall Corollary 4.3 in \cite{Lovasz1993} that removing any edge from  can only increase any , then according to (\ref{eq:res}), the lower bound of   only increases if the removing edge is not connected to either  or  (\emph{i.e.} the degree  and  keep unchanged). 
Since there must exist a node pair satisfying  after sufficient edges (except self-loops) are removed from one connected component of , we have the infinite case  given in Equation (\ref{eq:res}) that both  and  are consistently bounded by a finite number,\emph{i.e.} . It implies  does increase before it reaches .  As  is positively related to  (see the right side of Equation (\ref{Eq:l}) where  <0), we have proved the first part of Theorem 1, \emph{i.e.}, {\em } after removing sufficient edges.

When there happens , the connected component is disconnected into two parts, which leads to the increment of the dimension of  by 1 and proves the second part of Theorem 1. i.e.,
{\em the information loss is decreased: }. 

\end{proof}


\newpage
\section{Appendix: More Details in Experiments}
\subsection{Datasets Statistics}
\paragraph{Datasets} The statistics of all datasets are summarized in Table~\ref{table:data}.
\begin{table}[htbp]
  \centering
  \caption{Dataset Statistics}
  \vspace{-2ex}
  \small
\begin{tabular}{lrrrrcl}
\hline
Datasets & \multicolumn{1}{l}{Nodes} & \multicolumn{1}{l}{Edges} & \multicolumn{1}{l}{Classes} & \multicolumn{1}{l}{Features} & \multicolumn{1}{l}{Traing/Validation/Testing} & Type \\
\hline
Cora  & 2,708 & 5,429 & 7     & 1,433 & 1,208/500/1,000 & Transductive \\
Citeseer & 3,327 & 4,732 & 6     & 3,703 & 1,812/500/1,000 & Transductive \\
Pubmed & 19,717 & 44,338 & 3     & 500   & 18,217/500/1,000 & Transductive \\
Reddit & 232,965 & 11,606,919 & 41    & 602   & 152,410/23,699/55,334 & Inductive \\
\hline
\end{tabular}\label{table:data}\end{table}


\subsection{Models and Backbones}
\paragraph{Backbones}
Other than the multi-layer GCN, we replace the CNN layer with graph convolution layer to implement three popular backbones recasted from image classification. They are residual network (ResGCN)\citep{he2016deep,li2019can}, inception network (IncepGCN)\citep{szegedy2016} and dense network (JKNet) \citep{Huang2017,xu2018representation}. Figure~\ref{fig:backbones} shows the detailed architectures of  four backbones. Furthermore, we employ one input GCL and one output GCL on these four backbones. Therefore, the layers in ResGCN, JKNet and InceptGCN are at least 3 layers. All backbones are implemented in Pytorch~\citep{paszke2017automatic}. For GraphSAGE, we utilize the Pytorch version implemented by DGL\citep{wang2019dgl}.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.85\textwidth]{figures/backbones.pdf}
    \caption{The illustration of four backbones. GCL indicates graph convolutional layer.}
    \label{fig:backbones}
\end{figure}

\paragraph{Self Feature Modeling}
We also implement a variant of graph convolution layer with self feature modeling \citep{fout2017protein}:

where .

\paragraph{Hyper-parameter Optimization}
We adopt the Adam optimizer for model training. To ensure the re-productivity of the results, the seeds of the random numbers of all experiments are set to the same. We fix the number of training epoch to  for all datasets. All experiments are conducted on a NVIDIA Tesla P40 GPU with 24GB memory.

Given a model with  layers, the hidden dimension is  and we conduct a random search strategy to optimize the other hyper-parameter for each backbone in \textsection~\ref{sec.cmpdropedge}.  The decryptions of hyper-parameters are summarized in Table~\ref{tab:hyperparameterdescription}. Table~\ref{tab:normalization} depicts the types of the normalized adjacency matrix that are selectable in the ``normalization'' hyper-parameter. For GraphSAGE, the aggregation type like GCN, MAX, MEAN, or LSTM is a hyper-parameter as well.

For each model, we try 200 different hyper-parameter combinations via random search and select the best test accuracy as the result. Table~\ref{tab:hyperparameterdetails} summaries the hyper-parameters of each backbone with the best accuracy on different datasets and their best accuracy are reported in Table~\ref{tab:cmpwithdropnode}.

\subsection{The Validation Loss on Different Backbones w and w/o DropEdge.}
Figure~\ref{fig.dropvallosscmpaddtional} depicts the additional results of validation loss on different backbones w and w/o DropEdge.
\begin{figure}[htbp]
\centering
\includegraphics [width=0.31\textwidth]{figures/dropedgevsnodropedge/edgedropcompare_cora_6.pdf}
\includegraphics [width=0.31\textwidth]{figures/dropedgevsnodropedge/edgedropcompare_citeseer_4.pdf}
\includegraphics [width=0.31\textwidth]{figures/dropedgevsnodropedge/edgedropcompare_citeseer_6.pdf}
\caption{The validation loss on different backbones w and w/o DropEdge. GCN- denotes PlainGCN of depth ; similar denotation follows for other backbones.}
\label{fig.dropvallosscmpaddtional}
\end{figure}

\subsection{The Ablation Study on Citeseer}
Figure~\ref{fig.abstudyaddtional.drop} shows the ablation study of Dropout vs. DropEdge and Figure~\ref{fig.abstudy.layer-independent} depicts a comparison between the proposed DropEdge and the layer-wise DropEdge on Citeseer.
\begin{figure}[htbp]
\centering
\begin{subfigure}[t]{.45\textwidth}
\includegraphics [width=0.98\textwidth]{dropvsdrop_citeseer_4.pdf}
\caption{Ablation study of Dropout vs. DropEdge on Citeseer. }
\label{fig.abstudyaddtional.drop}
\end{subfigure}\hspace{5mm}
\begin{subfigure}[t]{.45\textwidth}
\includegraphics [width=0.98\textwidth]{figures/eachlayersampling/each_layer_sampling_compare_Citeseer_4_0_8.pdf}
\caption{Performance comparison of layer-wise DropEdge.}
\label{fig.abstudyaddtional.layer-independent}
\end{subfigure}\vskip -0.15in
\caption{}
\vskip -0.15in
\label{fig.abstudyaddtional}
\end{figure}

\begin{table}[htbp]
  \centering
  \caption{Hyper-parameter Description}
  \label{tab:hyper-desc}
      \vspace{-2ex}
    \small
    \begin{tabular}{l|l}
    \hline
    Hyper-parameter & Description \\
    \hline
    lr    & learning rate \\
    weight-decay & L2 regulation weight \\
    sampling-percent     & edge preserving percent () \\
    dropout & dropout rate \\
    normalization & the propagation models \citep{Kipf2017} \\
    withloop & using self feature modeling \\
    withbn & using batch normalization  \\
    \hline
    \end{tabular}\label{tab:hyperparameterdescription}\end{table}

\begin{table}[htbp]
  \centering
  \caption{The normalization / propagation models}
      \vspace{-2ex}
    \scriptsize
    \begin{tabular}{l|l|l}
    \hline
    Description & Notation &  \\
    \hline
    First-order GCN & FirstOrderGCN &  \\
    Augmented Normalized Adjacency & AugNormAdj &  \\
    Augmented Normalized Adjacency with Self-loop & BingGeNormAdj &  \\
    Augmented Random Walk & AugRWalk & \\
    \hline
    \end{tabular}\label{tab:normalization}\end{table}

\begin{table}[p]
  \centering
  \caption{The hyper-parameters of best accuracy for each backbone on all datasets.}
  \vspace{-2ex}
    \small
    \begin{tabular}{cl|r|r|p{0.6\textwidth}}
    \hline
    \multicolumn{1}{l}{Dataset} & Backbone & \multicolumn{1}{l|}{nlayers} & \multicolumn{1}{l|}{Acc.} & Hyper-parameters \\
    \hline
    \multirow{5}[10]{*}{Cora} & GCN   & 4     & 0.876 & lr:0.010, weight-decay:5e-3, sampling-percent:0.7, dropout:0.8, normalization:FirstOrderGCN \\
\cline{2-5}          & ResGCN & 4     & 0.87  & lr:0.001, weight-decay:1e-5, sampling-percent:0.1, dropout:0.5, normalization:FirstOrderGCN \\
\cline{2-5}          & JKNet & 16    & 0.88  & lr:0.008, weight-decay:5e-4, sampling-percent:0.2, dropout:0.8, normalization:AugNormAdj \\
\cline{2-5}          & IncepGCN & 8     & 0.882 & lr:0.010, weight-decay:1e-3, sampling-percent:0.05, dropout:0.5, normalization:AugNormAdj \\
\cline{2-5}          & GraphSage & 4     & 0.881 &  lr:0.010, weight-decay:5e-4, sampling-percent:0.4, dropout:0.5, aggregator:mean \\
    \hline
    \multirow{5}[10]{*}{Citeseer} & GCN   & 4     & 0.792 & lr:0.009, weight-decay:1e-3, sampling-percent:0.05, dropout:0.8, normalization:BingGeNormAdj, withloop, withbn \\
\cline{2-5}          & ResGCN & 16    & 0.794 &  lr:0.001, weight-decay:5e-3, sampling-percent:0.5, dropout:0.3, normalization:BingGeNormAdj, withloop \\
\cline{2-5}          & JKNet & 8     & 0.802 &  lr:0.004, weight-decay:5e-5, sampling-percent:0.6, dropout:0.3, normalization:AugNormAdj, withloop \\
\cline{2-5}          & IncepGCN & 8     & 0.805 &  lr:0.002, weight-decay:5e-3, sampling-percent:0.2, dropout:0.5, normalization:BingGeNormAdj, withloop \\
\cline{2-5}          & GraphSage & 2     & 0.8   & lr:0.001, weight-decay:1e-4, sampling-percent:0.1, dropout:0.5, aggregator:mean \\
    \hline
    \multirow{5}[10]{*}{Pubmed} & GCN   & 4     & 0.913 & lr:0.010, weight-decay:1e-3, sampling-percent:0.3, dropout:0.5, normalization:BingGeNormAdj, withloop, withbn \\
\cline{2-5}          & ResGCN & 32    & 0.911 &  lr:0.003, weight-decay:5e-5, sampling-percent:0.7, dropout:0.8, normalization:AugNormAdj, withloop, withbn \\
\cline{2-5}          & JKNet & 64    & 0.916 &  lr:0.005, weight-decay:1e-4, sampling-percent:0.5, dropout:0.8, normalization:AugNormAdj, withloop,withbn \\
\cline{2-5}          & IncepGCN & 4     & 0.916 & lr:0.002, weight-decay:1e-5, sampling-percent:0.5, dropout:0.8, normalization:BingGeNormAdj, withloop, withbn \\
\cline{2-5}          & GraphSage & 8     & 0.917 &   lr:0.007, weight-decay:1e-4, sampling-percent:0.8, dropout:0.3, aggregator:mean \\
    \hline
    \multirow{5}[10]{*}{Reddit} & GCN   & 4     & 0.9671 &  lr:0.005, weight-decay:1e-4, sampling-percent:0.6, dropout:0.5, normalization:AugRWalk, withloop \\
\cline{2-5}          & ResGCN & 16    & 0.9648 & lr:0.009, weight-decay:1e-5, sampling-percent:0.2, dropout:0.5, normalization:BingGeNormAdj, withbn \\
\cline{2-5}          & JKNet & 8     & 0.9702 & lr:0.010, weight-decay:5e-5, sampling-percent:0.6, dropout:0.5, normalization:BingGeNormAdj, withloop,withbn \\
\cline{2-5}          & IncepGCN & 8     & 0.9687 &  lr:0.008, weight-decay:1e-4, sampling-percent:0.4, dropout:0.5, normalization:FirstOrderGCN, withbn \\
\cline{2-5}          & GraphSAGE & 4     & 0.9654 &  lr:0.005, weight-decay:5e-5, sampling-percent:0.2, dropout:0.3, aggregator:mean \\
    \hline
    \end{tabular}\label{tab:hyperparameterdetails}\end{table}

\begin{landscape}
    \topskip0pt
    \vspace*{\fill}
\begin{table}[htbp]
  \centering
  \caption{Accuracy (\%) comparisons on different backbones with and without DropEdge}
    \vspace{-1ex}
    \small
    \begin{tabular}{cl|rr|rr|rr|rr|rr|rr}
    \hline
    \multirow{2}[4]{*}{Dataset} & \multicolumn{1}{c|}{\multirow{2}[4]{*}{Backbone}} & \multicolumn{2}{c|}{2} & \multicolumn{2}{c|}{4} & \multicolumn{2}{c|}{8} & \multicolumn{2}{c|}{16} & \multicolumn{2}{c|}{32} & \multicolumn{2}{c}{64} \\
\cline{3-14}          &       & \multicolumn{1}{c}{Orignal} & \multicolumn{1}{c|}{DropEdge} & \multicolumn{1}{c}{Orignal} & \multicolumn{1}{c|}{DropEdge} & \multicolumn{1}{c}{Orignal} & \multicolumn{1}{c|}{DropEdge} & \multicolumn{1}{c}{Orignal} & \multicolumn{1}{c|}{DropEdge} & \multicolumn{1}{c}{Orignal} & \multicolumn{1}{c|}{DropEdge} & \multicolumn{1}{c}{Orignal} & \multicolumn{1}{c}{DropEdge} \\
    \hline
    \multirow{5}[2]{*}{Cora} & GCN   & 86.10 & 86.50 & 85.50 & 87.60 & 78.70 & 85.80 & 82.10 & 84.30 & 71.60 & 74.60 & 52.00 & 53.20 \\
          & ResGCN & -     & -     & 86.00 & 87.00 & 85.40 & 86.90 & 85.30 & 86.90 & 85.10 & 86.80 & 79.80 & 84.80 \\
          & JKNet & -     & -     & 86.90 & 87.70 & 86.70 & 87.80 & 86.20 & 88.00 & 87.10 & 87.60 & 86.30 & 87.90 \\
          & IncepGCN & -     & -     & 85.60 & 87.90 & 86.70 & 88.20 & 87.10 & 87.70 & 87.40 & 87.70 & 85.30 & 88.20 \\
          & GraphSAGE & 87.80 & 88.10 & 87.10 & 88.10 & 84.30 & 87.10 & 84.10 & 84.50 & 31.90 & 32.20 & 31.90 & 31.90 \\
    \hline
    \multirow{5}[2]{*}{Citeseer} & GCN   & 75.90 & 78.70 & 76.70 & 79.20 & 74.60 & 77.20 & 65.20 & 76.80 & 59.20 & 61.40 & 44.60 & 45.60 \\
          & ResGCN & -     & -     & 78.90 & 78.80 & 77.80 & 78.80 & 78.20 & 79.40 & 74.40 & 77.90 & 21.20 & 75.30 \\
          & JKNet & -     & -     & 79.10 & 80.20 & 79.20 & 80.20 & 78.80 & 80.10 & 71.70 & 80.00 & 76.70 & 80.00 \\
          & IncepGCN & -     & -     & 79.50 & 79.90 & 79.60 & 80.50 & 78.50 & 80.20 & 72.60 & 80.30 & 79.00 & 79.90 \\
          & GraphSAGE & 78.40 & 80.00 & 77.30 & 79.20 & 74.10 & 77.10 & 72.90 & 74.50 & 37.00 & 53.60 & 16.90 & 25.10 \\
    \hline
    \multirow{5}[2]{*}{Pubmed} & GCN   & 90.20 & 91.20 & 88.70 & 91.30 & 90.10 & 90.90 & 88.10 & 90.30 & 84.60 & 86.20 & 79.70 & 79.00 \\
          & ResGCN & -     & -     & 90.70 & 90.70 & 89.60 & 90.50 & 89.60 & 91.00 & 90.20 & 91.10 & 87.90 & 90.20 \\
          & JKNet & -     & -     & 90.50 & 91.30 & 90.60 & 91.20 & 89.90 & 91.50 & 89.20 & 91.30 & 90.60 & 91.60 \\
          & IncepGCN & -     & -     & 89.90 & 91.60 & 90.20 & 91.50 & 90.80 & 91.30 & OOM   & 90.50 & OOM   & 90.00 \\
          & GraphSAGE & 90.10 & 90.70 & 89.40 & 91.20 & 90.20 & 91.70 & 83.50 & 87.80 & 41.30 & 47.90 & 40.70 & 62.30 \\
    \hline
    \multirow{5}[2]{*}{Reddit} & GCN   & 96.11 & 96.13 & 96.62 & 96.71 & 96.17 & 96.48 & 67.11 & 90.54 & 45.55 & 50.51 & -   & - \\
          & ResGCN & -     & -     & 96.13 & 96.33 & 96.37 & 96.46 & 96.34 & 96.48 & 93.93 & 94.27 & -   & - \\
          & JKNet & -     & -     & 96.54 & 96.75 & 96.82 & 97.02 & OOM   & 96.78 & OOM   & OOM   & -  & - \\
          & IncepGCN & -     & -     & 96.48 & 96.77 & 96.43 & 96.87 & OOM   & OOM   & OOM   & OOM   & -  & - \\
          & GraphSAGE & 96.22 & 96.28 & 96.45 & 96.54 & 96.38 & 96.42 & 96.15 & 96.18 & 96.43 & 96.47 & - & - \\
    \hline
    \end{tabular}\label{tab:dropvsnodrop}\end{table}\vspace*{\fill}
\end{landscape}
\end{document}
