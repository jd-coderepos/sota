\documentclass[a4paper,UKenglish]{lipics-v2016}


\usepackage{microtype}



\bibliographystyle{plainurl}

\title{Confluence of an extension of Combinatory Logic by Boolean
  constants\footnote{Supported by Marie Sk{\l}odowska-Curie action ``InfTy'',
    program H2020-MSCA-IF-2015, number~704111, and by Narodowe Centrum
    Nauki grant 2012/07/N/ST6/03398.}}


\author[1]{{\L}ukasz Czajka}
\affil[1]{DIKU, University of Copenhagen, Copenhagen, Denmark\\
  \texttt{luta@di.ku.dk}}
\authorrunning{{\L}. Czajka} 

\Copyright{{\L}. Czajka}

\subjclass{F.4.2 Grammars and Other Rewriting Systems}\keywords{combinatory logic, conditional linearization, unique normal
  form property, confluence}

\EventEditors{Dale Miller}
\EventNoEds{1}
\EventLongTitle{2nd International Conference on Formal Structures for Computation and Deduction (FSCD 2017)}
\EventShortTitle{FSCD 2017}
\EventAcronym{FSCD}
\EventYear{2017}
\EventDate{September 3--9, 2017}
\EventLocation{Oxford, UK}
\EventLogo{}
\SeriesVolume{84}
\ArticleNo{14} 

\newcommand{\Ps}{\mathsf{P}}
\newcommand{\Cs}{\mathsf{C}}
\newcommand{\Fs}{\mathsf{F}}
\newcommand{\Ts}{\mathsf{T}}
\newcommand{\Ss}{\mathsf{S}}
\newcommand{\Ks}{\mathsf{K}}
\newcommand{\Is}{\mathsf{I}}

\newcommand{\from}{\ensuremath{\leftarrow}}
\newcommand{\To}{\ensuremath{\Rightarrow}}
\newcommand{\From}{\ensuremath{\Leftarrow}}

\newcommand{\Da}{\ensuremath{\Downarrow}}

\newcommand{\reduces}{\ensuremath{\to^*}}
\newcommand{\contr}{\ensuremath{\rightarrow}}
\newcommand{\eqv}{\ensuremath{\leftrightarrow}}
\newcommand{\erase}[1]{\ensuremath{|#1|}}

\newcommand{\Var}{\mathrm{Var}}
\newcommand{\Nbb}{\ensuremath{\mathbb{N}}}

\newcommand{\la}{\ensuremath{\langle}}
\newcommand{\ra}{\ensuremath{\rangle}}

\newcommand{\leftidx}[3]{{\;\vphantom{#2}}#1\!\!#2#3}

\newcommand{\Sc}{\ensuremath{{\mathcal S}}}

\newcommand{\CLC}{{\mbox{}}}
\newcommand{\CLCz}{{\mbox{}}}
\newcommand{\CLCp}{{\mbox{}}}
\newcommand{\sCLC}{{\ensuremath{\text{\rm CL-pc}^1}}}
\newcommand{\sCLCz}{\ensuremath{\text{\rm CL-pc}}}
\newcommand{\sCLCp}{\ensuremath{\text{\rm CL-pc}^{\mathrm{L}}}}
\newcommand{\CLCs}{{\mbox{}}}

\newcommand{\equiverased}{\succ}

\begin{document}

\maketitle

\begin{abstract}
  We show confluence of a conditional term rewriting system~,
  which is an extension of Combinatory Logic by Boolean
  constants. This solves problem~15 from the~RTA list of open
  problems. The proof has been fully formalized in the~Coq proof
  assistant.
\end{abstract}

\section{Introduction}

Combinatory Logic is a term rewriting system defined by two rules:

Using only~ and~, it is possible to encode natural numbers via
Church numerals. Any computable function may then be represented by a
term in the system. However, a conditional~ encoded in this way
does not have a desirable property that  if 
encodes neither true nor false. It is therefore interesting to
investigate extensions of Combinatory Logic incorporating a
conditional directly. Perhaps the most natural such extension
is~:

The system~ is known to be not confluent~\cite{Klop1980}. One
may thus try other ways of adding a conditional and Boolean constants
to Combinatory Logic.

We show confluence of a conditional term rewriting system~
defined by the rules:

Confluence of this system\footnote{Strictly speaking, in the
  literature the systems~,  and~ also contain the
  rule . This rule could be added to our definitions
  without significantly changing the proofs. However, this would
  increase the number of cases to consider, making the proofs less
  readable. The formalization of our results uses the definitions from
  the literature.} appears as problem~15 on the RTA list of open
problems~\cite{DershowitzJouannaudKlop1991}.

The equality in the side condition for the third rule for~
in~ refers to equality in the system~ itself, thus the
definition is circular. This circularity is an essential property
of~ which distinguishes it from~.

A system related to~ is~, which consists of all rules
of~ plus:

It is known that~ is confluent~\cite{Vrijer1999}. However, the
confluence proof in~\cite{Vrijer1999} essentially depends on a
``semantic'' argument to first establish . We
provide a ``syntactic'' proof of confluence of both~
and~.

The systems~ and~ are conditional linearizations
of~. The notion of conditional linearization was introduced in
the hope of providing a simpler proof of Chew's
theorem~\cite{Chew1981,ManoOgawa2001} which states that all compatible
term rewriting systems have the unique normal form (UN)
property. Compatibility imposes certain restrictions on the term
rewriting system, but it does not require termination or
left-linearity. In particular, Chew's theorem is applicable to many
term rewriting systems which are not confluent. For instance,~
satisfies the conditions of Chew's theorem, but it is not
confluent. As shown in~\cite{Vrijer1999}, to prove the unique normal
form property of a term rewriting system, it suffices to prove
confluence of one of its conditional linearizations. The proof of
Chew's theorem in~\cite{ManoOgawa2001} is quite complicated and uses a
related but different approach, relying on left-right separated
conditional linearizations instead of the more straightforward ones
from~\cite{Vrijer1999}. The original proof by Chew~\cite{Chew1981}
uses yet another different but related method, but Chew's proof was
later found to contain a gap.

In general, the methods of the present paper are broadly related to
the problem of establishing the~UN property for classes of term
rewriting systems which include non-left-linear non-confluent
systems. Aside of Chew's theorem, some other work in this direction
has been carried out in
e.g.~\cite{KlopVrijer1989,ToyamaOyamaguchi1995,Verma1997,Stovring2006,KahrsSmith2016}.

In order to increase confidence in the correctness of the main result
of this paper, we have formalized our proof of confluence of~ in
the~Coq proof assistant. The formalization is available
online\footnote{\url{http://www.mimuw.edu.pl/~lukaszcz/clc.tar.gz}}. It
follows closely the development presented here. We used the
CoqHammer~\cite{CzajkaKaliszyk2017Submitted} tool and the automated
reasoning tactics included with it.

\section{Proof overview}\label{sec_overview}

In this section we present an informal overview of the proof, trying
to convey the underlying intuitions. Section~\ref{sec_definitions}
presents formal definitions of the notions informally motivated here,
and Section~\ref{sec_proof} provides details of the proof itself.

We assume familiarity with basic
term-rewriting~\cite{BaaderNipkow1999,Terese2003}. By~ we
denote the transitive-reflexive closure of a relation~,
by~ its reflexive closure, by~ the
symmetric closure, and by~ the reflexive-transitive-symmetric
closure. We use~ to denote identity of terms. By~ we
denote reduction to normal form, i.e.,  if 
and~ is in normal form. By~ we denote composition of
relations, e.g.~ holds iff there exists~
such that  and . We use the standard notions
of subterms and subterm occurrences, which could be formally defined
by introducing the notion of positions. If~ is a redex,
i.e.~ for some term~ and substitution~,
then a subterm~ \emph{occurs below a variable position} of the
redex~ if~ occurs in a subterm of~ occurring at the position
of a variable in~. The contraction in  \emph{occurs at
  the root} if~ is the contracted redex.

Let~ be a normal form w.r.t.~a relation~. The relation~
(or the underlying rewrite system) is \emph{-normal} if for
every~ such that  we have .

The most difficult part of our confluence proof is to show that~
is -normal (Lemma~\ref{lem_f_nf}). The confluence of~
(and~) is then obtained by a relatively simple argument similar
to the one used in~\cite{Vrijer1999} to derive the confluence
of~ from~.

An important observation is that  and
 are in fact equivalent
(Lemma~\ref{lem_clc_equivalent}). Hence, we will use~
and~ interchangeably. In particular, we actually prove
that for any term~, if  then
.

A naive approach to prove this could be to proceed by induction on the
length of the conversion . In the inductive step we
would need to prove:
\begin{enumerate}
\item if  and  then
  ,
\item if  and
   then .
\end{enumerate}
The second part is obvious, but the first one is hard. The difficulty
stems from the existence of a non-trivial overlap between the rules
for~. If  then 
by the third rule of~ and  by
the second rule of~. We do not know enough about~
and~ to easily infer that they have a common reduct in~.

One may try to strengthen the inductive hypothesis in the hope of
making the first part easier to prove. A naive attempt would be to
claim that \emph{all} reductions starting from~ end in~,
instead of claiming that \emph{some} reduction ends in~. This
would make the first part trivial, but the second one would not go
through as this is false in general, e.g., consider 
where  and
.

The idea is to consider, for a given conversion , a
certain set  of reductions, all starting
from~. The set  depends on the exact form of
. Then our two parts of the proof for the inductive
step become:
\begin{enumerate}
\item if  is nonempty and all reductions in it
  end in~, and , then
   is nonempty
  and all reductions in it end in~,
\item if  is nonempty and all reductions in it
  end in~, and , then
   is nonempty and all reductions
  in it end in~.
\end{enumerate}
The hope is that if we define  appropriately,
then showing both parts will become feasible.

Essentially, the set  will be encoded in the
labeling of certain constants in~. The labels determine which
contractions are permitted when a given constant appears as the
leftmost constant in a redex\footnote{E.g.~in the redex
   the constant~ is the leftmost constant.}. At
present the author does not know an ``explicit'' characterization of
the set of reductions  implicitly defined by the
labelings described below.

Terms with the leftmost constant labeled will be called
``significant'', or -terms, whereas others will not contain any
labels and will be called ``insignificant'', or -terms
(c.f.~Definition~\ref{def_terms}). Reductions occurring in -terms
will be ``insignificant'', or -reductions. A ``significant''
contraction, or -contraction, will be a contraction of a term with
the leftmost constant labeled, in a way permitted by the label of the
leftmost constant. Contraction of a redex in which the leftmost
constant is not labeled is not permitted in -contractions. See
Definition~\ref{def_clc_s}. The intuition is that we do not need to
care about the expansions and contractions occurring in
``insignificant'' subterms of a given term, since they cannot
influence the -reductions starting from this term and ending
in~.

The set  will be encoded in a labeled
variant\footnote{By a ``labeled variant'' of a term~ we mean a term
  with certain constants labeled which is identical with~ when the
  labels are ``erased''.}~ of~, and it will consist of all
-reductions starting from~ and ending in a normal form
(w.r.t.~-contraction). Strictly speaking, we have just silently
shifted from considering contractions in ``plain'' terms of the
system~ to contractions in their labeled variants, in a
different rewriting system which we have not yet defined. In
particular, we will actually be interested in -reductions ending in
a labeled variant~ of~. However, it will be later shown
that -reductions defined on labeled terms may be ``erased'' to
appropriate reductions in the system~. In the next section we
define the system~ (Definition~\ref{def_clc_s}) over labeled
terms (Definition~\ref{def_terms}) which will give precise rules of
-contraction. In this section we only give informal motivations.

The labels constrain the ways in which -redexes may be contracted
and encode permissible -reductions to~. Each term decomposes
into a ``significant'' prefix and an ``insignificant'' suffix
(c.f.~\ref{std_i_or_s_or_tuple} in Definition~\ref{def_standard}). The
``significant'' prefix contains all labeled constants and no unlabeled
constants. The ``insignificant'' suffix consists of all
``insignificant'' subterms. All constants in the ``insignificant''
suffix are unlabeled. This is analogous to the existence of a needed
prefix and a non-needed suffix in orthogonal
TRSs~\cite[Section~9.2.2]{Terese2003}. An ``insignificant'' subterm
does not overlap with any needed redexes. In particular, it does not
contain any needed redexes. No position inside an ``insignificant''
subterm (dynamically) traces to~ along any -reduction
to~ (c.f.~\cite[Definition~8.6.7]{Terese2003}). In contrast,
each -redex needs to be either -contracted or erased by a rule
for~ (see Definition~\ref{def_clc_s}) in any -reduction
to~. Each position of a labeled constant either traces
to~ along a given -reduction to~, or is erased in
that -reduction by a rule for~. An -reduct of an -term
is always also an -term (c.f.~\ref{std_s_term_reduce} in
Definition~\ref{def_standard}).

We write  for one-step reduction in~. We use the
abbreviation -NF for -normal form. We write 
when, among other conditions to be defined later,  is complete,
i.e.~terminating and confluent, w.r.t.~-reductions with~ as
the normal form (c.f.~Definition~\ref{def_standard}).

With the set  coded by labels, the two parts of
the inductive step become:
\begin{enumerate}
\item if~ is a labeled variant of~ such that ,
  and , then there exists a labeled variant~
  of~ such that  (c.f.~Corollary~\ref{cor_contr}),
\item if~ is a labeled variant of~ such that ,
  and , then there exists a labeled
  variant~ of~ such that 
  (c.f.~Corollary~\ref{cor_expand}).
\end{enumerate}

Now we provide some explanations on how the terms will be labeled. For
this purpose we analyze why the second part fails when we take
 to be the set of all reductions starting
from~. We indicate how to introduce the labeled variants so as to
make the second part go through while still retaining the feasibility
of showing the first part.

Suppose  at the root and we have
already decided on the labeled variant~ of~. We need to decide
on a labeled variant~ of~, and assign appropriate meaning to
the labels, in such a way that the second part goes through. In short,
in~ we preserve the labelings of the subterms of~ which are
copied to~ in , we do not label the new subterms
of~ which are erased in  (they become
-terms), and we ensure that -terms and cannot influence
\emph{any} -reduction from~ to~. First of all, if~ is
an -term, i.e., , then we may take . So
assume~ is an -term. Then there are the following possibilities.
\begin{itemize}
\item If  then~ is a new
  subterm. We take . The labeling~
  of~ will be interpreted as not permitting contraction by the
  third rule, i.e., in~ we will only have the rules
   and . This ensures
  that~ gets erased in every -reduction of~ to~.
\item The case when  is
  analogous: we take .
\item If  by the third rule,
  then~ is a new term. We take . In the
  system~ we have two rules for~
  
  where  means that the ``erasures'' of
  the labeled terms substituted for~ and~ must be equal
  in~ for the rule to be applicable. These rules ensure
  that~ cannot influence any -reduction of~ to~ --
  it gets erased in each.

  The presence of the second rule for~ is not a problem,
  because we will only consider terms terminating in~. Whenever
  the second rule is applicable, so is the first one, hence if all
  maximal -reductions end in~, then there is an
  -reduction ending in~ which does not use the second rule
  for~ (Lemma~\ref{lem_good_reduction}). It will be easy to
  ``erase'' an -reduction not using the second rule for~ to
  obtain a reduction in~ (Lemma~\ref{lem_s_minus_erase}).
\item If  then we take
  . The rule for~ in~ is
  .
\item If
  
  then we run into a problem with our labeling approach, because the
  labeled variants of the distinct occurrences of~ may be
  distinct. Suppose~ is the labeled variant of~, the
  term~ of~, the term~ of the first~, and~
  of the second~. We cannot just arbitrarily choose e.g.~
  and say that  is the labeled variant of~,
  because contracting  yields ,
  not , and now the second occurrence of~ has
  the wrong labeling.

  A solution is to remember both labeled variants of~. So the
  labeled variant of~ would be
  e.g.~. In~ the rule
  for~ would be
  
  However, once we introduce such pairs, terms of the form
   may appear in the terms being
  expanded. This is not a problem for any of the rules of~
  except the rule for~, because the right sides of all other
  rules are variables.

  Consider for instance
  . Suppose
  . Now the
  term~ has three possibly distinct labeled variants, and we need
  to remember all of them in a tuple. We will thus introduce a new
  labeling of~ for every possible labeling of the right
  side~ of the rule for~ in the system~.

  By introducing the tuples in the labelings we in essence put
  constraints on the order in which -redexes may be contracted
  (think of all reductions inside a tuple as ``really'' occuring after
  the surrounding -redex is contracted). At present the author
  does not know a precise ``explicit'' characterization of these
  constraints.
\end{itemize}
Note that by labeling  differently in  and
 we effectively eliminated in~ the problematic
non-trivial overlap occuring in~. Now a new ``insignificant''
term created in an expansion cannot later on appear in place of a
``significant'' term as a result of an ``incompatible'' contraction. A
redex inside an ``insignificant'' subterm cannot suddenly become
needed in an -reduction -- it is erased in any -reduction to
normal form.

We also need to ensure that we can handle the first part of the
inductive step when . Suppose~ is the labeled
variant of~. We need to find a labeled variant for~. For
simplicity assume that there is only one position in~ which
corresponds to the position of the contraction in~. If the
contraction occurs inside an -term in~, then it does not matter
and we may label~ in the same way as~. If an -term is
contracted in a way permitted for significant contraction, then it is
also obvious how to label~ -- just take the labeled variant
of~ to be the reduct of the labeled variant of~. But what if
neither of the two holds?

For instance, what if  but
? This possibility is not
problematic, provided that~ or ,
which will be the case because~ was ``obtained'' from~
or~ by a conversion with the intermediate terms labeled
appropriately (c.f.~\ref{std_c_1} in Definition~\ref{def_standard}
and~\ref{prop_std_c_1} in Lemma~\ref{lem_standard_properties}). If
e.g.~ then we take~ to be the labeling
of~. We then have 
and the contraction  is permitted for
``significant'' contractions.

The last problematic case is when e.g.~ is
the labeling of~, and  by
the second rule. However, because  was ``obtained''
from  we will have 
(c.f.~\ref{std_c_2} in Definition~\ref{def_standard}). Then the second
rule for~ in~ is applicable and we may take~ as the
labeling of~.

\section{Definitions}\label{sec_definitions}

This section is devoted to fixing notation and introducing definitions
of various technical concepts. First, we clarify the formal definition
of conditional term rewriting systems. For more background on
conditional rewriting see e.g.~\cite{Terese2003}.

\begin{definition}\label{def_trs}
  A \emph{conditional rewrite rule} is a rule of the form
  , where~ is not a variable,
  , ,
  and~ is the \emph{condition} of the rule,
  with~ a fixed predicate on terms. The predicate~ may refer to
  the conversion relation~ of the conditional term rewriting system
  being defined. A term~ is a \emph{redex} (\emph{contractum}) by
  this rule if there is a substitution~ such that
   () and
   holds. A \emph{conditional term
    rewriting system}~ is a set of conditional rewrite
  rules. Because the conditions in the rules may refer to the
  conversion relation of~, the definition is circular. Formally, an
  -contraction  is defined in the following
  way. Define~ to be the system~ but using the equality
  relation in place of~ in the conditions, and~ to be the
  system~ with the conversion relation~ of~ used in
  place of~. We then define  to hold if there
  is~ with . The least such~ is
  called the \emph{level} of the contraction. If the conditions are
  continuous w.r.t.~ then the relation~ is a fixpoint of
  the above construction, i.e., it is the contraction relation of the
  system~ which uses~ in place of~. Let~ be a
  binary relation on terms. If for any substitution~ such
  that~ holds, and any~
  such that  for all variables~,
  also~ holds, then the
  condition~ is \emph{stable under~}.
\end{definition}

The following is a simple but crucial observation, which implies that
it suffices to consider conversions in~. A generalization of
this fact was already shown in~\cite[Lemma~3.7]{Vrijer1999}. The proof
is by induction on the maximum level of the contractions/expansions in
.

\begin{lemma}\label{lem_clc_equivalent}
  The following are equivalent: , ,
  and .
\end{lemma}

\begin{definition}\label{def_terms}
  We define \emph{insignificant terms}, or \emph{-terms}, to be the
  terms of~, i.e., terms over the
  signature~ where~ is a
  binary function symbol and the other symbols are constants. We write
   instead of .  The set of \emph{labeled terms},
  or \emph{-terms}, is the set of terms over the signature
  consisting of the symbols of~, the \emph{labeled constants}
   and  for
  each , and an -ary function
  symbol~ for each . We write
   instead of . We
  adopt the convention . If
   with , then we say
  that~ is a \emph{tuple of length~}. Note that
   is just a notational convention. We say that
   is a tuple \emph{only when }.

  An \emph{erasure} of an -term is defined as follows:
  \begin{itemize}
  \item an -term is an erasure of itself,
  \item  is an erasure of  and~;  is an erasure of
    ;  is an erasure of ;  is an erasure of ; 
    is an erasure of ,
  \item if ,  are erasures of , , respectively,
    then~ is an erasure of~,
  \item if  is an erasure of , for some ,
    then~ is an erasure of .
  \end{itemize}
  The \emph{leftmost erasure} of~, denoted~, is the
  erasure in which we always choose~ in the last point above. We
  write  if \emph{every} erasure of~ is identical
  with~.

  We define \emph{significant terms}, or \emph{-terms},
  inductively.
  \begin{itemize}
  \item Any labeled constant is an -term.
  \item If  is an -term and  is an -term, then  is an -term.
  \end{itemize}
  In other words, an -term is an -term whose leftmost constant
  is labeled.
\end{definition}

In what follows , , , , , , , ,
etc.~stand for -terms; and , , , etc.~stand for
-terms; unless otherwise qualified. Also, whenever we talk about
terms without further qualification, we implicitly assume them to be
-terms.

\begin{definition}\label{def_clc_s}
  The system~ is defined by the following \emph{significant
    reduction rules}:
  
  
  where
  
  and  stands for , and  stands
  for , for . When dealing
  with terms whose leftmost constant is~, we
  will often use this kind of vector notation. Recall the convention
  . Hence, if e.g.~, then
   in the
  above rule. The condition~ ensures that the leftmost
  erasures of all~ are convertible in~, and that the
  leftmost erasures of all~ are convertible in~. Some
  examples of significant reduction rules for~
  (omitting the conditions) are:
  
  For instance, the condition for the second of these rules states
  that ,
  ,
  ,
  , , etc.

  Note that the equality~ in the conditions refers to the
  system~, not~. Note also that all rules of~ are
  linear, disregarding the side-conditions.

  Reduction by a rule in~ is called \emph{significant
    reduction}, or -reduction. One-step -reduction is denoted
  by~. Analogously, we use the terminology and notation of
  -contraction, -expansion, -redex, -normal form (-NF),
  etc. Note that every -redex is an -term. We write
   if  and the -contraction is not by
  the second rule for~ and it does not occur inside a tuple.

  An \emph{-redex} is a -redex which is also an -term. An
  -term~ is said to \emph{-reduce} to~,
  denoted~, if~ and the redex
  contracted in~ is an -term. An -term~ is said to
  \emph{-expand} to~ if . We write
   if  or .
\end{definition}

Actually, we will consider mostly -terms whose all erasures are
identical. For such a term an -contraction by a rule
for~ in~ naturally corresponds to a
-contraction on its erasure. We could get rid of the side
conditions in the rules for~ and consider exclusively
terms whose all erasures are identical. But then we would need to
require /-contractions/expansions to always occur ``in the same
way'' (modulo labeling) in all components of a tuple. This would
complicate the inductive proofs concerning the relations~,
, etc. Hence, the role of the conditions in the rules
for~ is purely technical.

\begin{lemma}\label{lem_sn}
  The system  is terminating.
\end{lemma}

\begin{proof}
  The number of labeled constants decreases with each
  -contraction.
\end{proof}

\begin{lemma}
  If  then .
\end{lemma}

The above simple lemma implies that the conditions in significant
reduction rules are stable under -reduction and -expansion. It
is obvious that they are also stable under -reduction and
-expansion.

\begin{lemma}\label{lem_s_minus_erase}
  If  and  then there is~ with
   and .
\end{lemma}

\begin{proof}
  Because all erasures of~ are identical and the second rule
  for~ is not used, the -reduction may be simulated by a
  -reduction in an obvious way. Because the -contraction
  does not occur inside a tuple, all erasures of~ are still
  identical.
\end{proof}

In the next definition we introduce the predicate~ and
the notion of standard -terms. Intuitively, an -term~ is
standard if the labelings in~ have the meaning we intend to assign
them, i.e.~if~ is a term obtained by the process informally
described in the previous section.

\begin{definition}\label{def_standard}
  An -term~ is \emph{standard} if for every subterm~ of~
  the following hold:
  \begin{enumerate}
  \item\label{std_i_or_s_or_tuple}  is either an -term, an
    -term or a tuple,
  \item\label{std_c_1} if  and  is in
    -NF, then  or ,
  \item\label{std_c_2} if  then
    ,
  \item\label{std_s} if 
    then~ is a tuple of length  and if 
    then~ is a tuple of length~,
  \item\label{std_s_term_reduce} if  is an -term and
    , then~ is also an -term,
  \item\label{std_no_nested_tuple} if
     with , then none of
     is a tuple.
  \end{enumerate}
  An -term~ is \emph{strongly standard} if 
  implies that~ is standard. We write  if~ is
  strongly standard and has no -NFs other than~, i.e.~if
   then .
\end{definition}

Point~\ref{std_i_or_s_or_tuple} in Definition~\ref{def_standard}
essentially ensures that a standard term may be decomposed into a
``significant'' prefix and an ``insignificant'' suffix. A labeled term
which is not standard is e.g.~, because it is neither an
-term, nor an -term, nor a tuple. Other examples of non-standard
terms are: , ,
, , ,
,
, . Examples of standard terms which are not strongly standard are:
,
,
.

\begin{lemma}\label{lem_standard_properties}
  \begin{enumerate}
  \item Any -term is standard.
  \item Any labeled constant is standard.
  \item Every subterm of a standard term is also standard.
  \item Every subterm of a term to which some strongly standard term
    -reduces, is strongly standard.
  \item If  is standard then  is not a tuple.
  \item\label{prop_std_c_1} If  is a subterm of a
    strongly standard term, then  or
    .
  \end{enumerate}
\end{lemma}

\begin{proof}
  Follows from definitions. For the last point one also needs
  Lemma~\ref{lem_sn}.
\end{proof}

\section{Confluence proof}\label{sec_proof}

We now give technical details of our confluence proof. As outlined in
Section~\ref{sec_overview}, we show:
\begin{enumerate}
\item if  and , and ,
  then there is~ with  and 
  (Corollary~\ref{cor_contr}),
\item if  and , and
  , then there is~ with
   and  (Corollary~\ref{cor_expand}).
\end{enumerate}
The first part is proven by showing that -reductions in~ may
be simulated by -reductions and -reductions in~, and that
/-reductions preserve~ (Lemma~\ref{lem_eqv_i} and
Lemma~\ref{lem_contr_s}). For the second part, we show that
-expansions in~ may be simulated by -expansions and
-expansions (Definition~\ref{def_a_redex}) in~. The technical
notion of -expansion is needed to ensure that the new subterms
of~ are labeled appropriately, in the way outlined in
Section~\ref{sec_overview} (-contraction by itself does not put any
labeling restrictions on the terms erased in the
contraction). Moreover, -expansion is also needed to facilitate the
proof that  (see the discussion before
Definition~\ref{def_a_redex}). Plain -expansion does not
necessarily preserve~, while -expansion does
(Lemma~\ref{lem_expand_a}).

In other words, we show that -reductions (expansions) in
unlabeled terms may be simluated by /-reductions
(/-expansions) in their labeled variants, and that
/-reductions (/-expansions) preserve~. A
conversion  can then be translated into a conversion
 with no -expansions or -reductions, and
with~. For instance, a conversion in~

will be translated to

Since~ and we prove that /-reductions and
/-expansions preserve~, we may conclude
that~. Then by the definition of~ we
obtain a significant reduction . In fact, the
reduction may be assumed to be a -reduction
(Lemma~\ref{lem_good_reduction}). By Lemma~\ref{lem_s_minus_erase}
this reduction  may be translated into a
-reduction by erasing the labelings. Hence finally
 (Lemma~\ref{lem_f_nf}).

We first show that a -contraction may be simulated by
-reductions and -reductions.

\begin{lemma}\label{lem_erase_contr}
  If~ is strongly standard,  and
  , then there exists a term~ such that
   and .
\end{lemma}

\begin{proof}
  Induction on the size of~. First assume~ is not a tuple
  and~ is the -redex contracted in . If~ then  and we may take
  . If~ then~ is not an -term
  because . Hence by~\ref{std_i_or_s_or_tuple} in
  Definition~\ref{def_standard} we conclude that~ is an
  -term. We have the following possibilities.
  \begin{itemize}
  \item If  then the
    leftmost constant in~ is either~ or~.
    \begin{itemize}
    \item If  then  and
      , so we may take .
    \item The case  is impossible
      by~\ref{std_c_1} in Definition~\ref{def_standard}.
    \item If  then 
      and  by~\ref{std_c_2} in
      Definition~\ref{def_standard}. Thus  and we may
      take .
    \end{itemize}
  \item If  then the
    argument is analogous. Note that the presence of the second rule
    for~ is necessary here.
  \item If  then  with , ,
     and .
    \begin{itemize}
    \item If  then  or  by Lemma~\ref{lem_standard_properties}. Hence  or . In the first case we may
      take , and in the second we take .
    \item If  then  because
      . Thus we take .
    \end{itemize}
  \item If  then
     with . We
    take .
  \item If 
    then
     where the conventions regarding
    the vector notation are as in Definition~\ref{def_clc_s}, and
    , and  for
    , and  for ,
    . Thus
    
    and we may take~.
  \end{itemize}
  If~ is a tuple or~ is not the contracted -redex, then
  the claim follows from the inductive hypothesis.
\end{proof}

The following technical lemma shows that~ may be postponed
after~.

\begin{lemma}\label{lem_i_postpone}
  If  then
  .
\end{lemma}

\begin{proof}
  Suppose . We proceed by induction on the
  definition of .

  If~ is the contracted -redex then, because an -redex
  (-contractum) is an -term, it is easy to see by inspecting
  Definition~\ref{def_clc_s} that the -redex (-contractum)
  in~ must occur below a variable position of the
  -redex. Since significant reduction rules are linear and their
  conditions are stable under -reductions (-expansions), the
  claim holds. Note that we need~ instead
  of~ in the conclusion, because the -redex
  (-contractum) may be erased by the -contraction.

  If~ is not the -redex, then  or  with , and the claim is easily
  established possibly appealing to the inductive hypothesis.
\end{proof}

The next lemmas show that -reductions/expansions and
-reductions preserve~.

\begin{lemma}\label{lem_eqv_i_std}
  If  is standard and  then  is standard.
\end{lemma}

\begin{proof}
  We check that the conditions in Definition~\ref{def_standard} hold
  for every subterm~ of~. Note that because -redexes and
  -contracta are -terms,  is an -term or there is a
  subterm~ of~ such that .
  \begin{enumerate}
  \item If  is not an -term, then there is a subterm~ of~
    such that . If~ is an -term or a
    tuple then so is~. Otherwise,~ is an -term
    by~\ref{std_i_or_s_or_tuple} in
    Definition~\ref{def_standard}. Then~ is also an -term.
  \item Suppose  with  in
    -NF. Since~ is not an -term, there is a subterm~
    of~ such that  and
     for . Since~ is in
    -NF and , the term~ is also in
    -NF. Thus  or 
    by~\ref{std_c_1} in Definition~\ref{def_standard}. Hence
     or .
  \item Suppose . Since~ is not an
    -term, there is a subterm~ of~ such that
     and  for
    . By~\ref{std_c_2} in Definition~\ref{def_standard} we
    have . Hence also
    , because
     implies
    .
  \item Suppose . Since~ is not an -term, there is a subterm~
    of~ such that  and
     for . By~\ref{std_s} in
    Definition~\ref{def_standard} we conclude that~ is a tuple of
    length , and if  then~ is a tuple
    of length~. The same holds for~ and~, because a
    tuple cannot be an -redex or an -contractum.
  \item Suppose  is an -term. There is a subterm~ of~
    such that . Since~ is an -term, so
    is~. Suppose . By Lemma~\ref{lem_i_postpone}
    there is~ such that . By~\ref{std_s_term_reduce} in Definition~\ref{def_standard},
    the term~ is an -term. Hence,~ is also an -term.
  \item Suppose  with . Since~ is not an -term, there is a subterm~ of~
    such that  and
     for
    . By~\ref{std_no_nested_tuple} in
    Definition~\ref{def_standard} none of  is a
    tuple. Hence, none of  is a tuple either.
  \end{enumerate}
\end{proof}

\begin{lemma}\label{lem_eqv_i}
  If  and  then .
\end{lemma}

\begin{proof}
  Suppose . By Lemma~\ref{lem_i_postpone} there
  is~ with  and . Because~ is strongly standard,  is
  standard. Hence~ is standard by
  Lemma~\ref{lem_eqv_i_std}. Therefore~ is strongly standard.

  Suppose  with~ in -NF. By
  Lemma~\ref{lem_i_postpone} there is~ with
  . Since~ is in -NF,
  so is~, because an -contraction or an -expansion cannot
  create an -redex. Since  we obtain
  . Thus .
\end{proof}

\begin{lemma}\label{lem_contr_s}
  If  and  then .
\end{lemma}

\begin{corollary}\label{cor_contr}
  If ,  and  then
  there is~ with  and .
\end{corollary}

\begin{proof}
  Follows from Lemma~\ref{lem_erase_contr}, Lemma~\ref{lem_eqv_i} and
  Lemma~\ref{lem_contr_s}.
\end{proof}

With the above corollary we have finished the first half of the
proof. Now we need to show an analogous corollary for
-expansions. First, we want to prove that -expansions in
unlabeled terms may be simulated by -expansions and -expansions
in their strongly standard labeled variants. We have already shown in
Lemma~\ref{lem_eqv_i} that -expansions preserve~. We
need to show that -expansions also preserve~.

One trivial reason why -expansions do not necessarily
preserve~ is that if 
then~ may be not standard even if~ is, e.g., consider
. A more profound
reason is that with -expansion we do not sufficiently ``control''
the expansion by a rule for~.
E.g.~. Then
 but
 does not -reduce to~.

Hence, we use -expansions which put additional restrictions on the
-redexes, essentially implementing the labeling of expansions
described in Section~\ref{sec_overview}. They also allow to ``delay''
the reductions in a contractum of~ to facilitate
the proof of an analogon of Lemma~\ref{lem_i_postpone}.

Like in the proof of Lemma~\ref{lem_eqv_i} we show that if
 then any reduction  may be simulated by
a reduction  with . The most
interesting case is when
 (where~ is a
context), which is obtained from a -expansion by the rule
. We now informally describe the idea for the proof
in this case. Thus suppose . If a contracted
-redex does not overlap with a descendant\footnote{Note that
  because the rules of significant reduction are linear there may be
  at most one descendant.} of~, then the
-reduction is simulated by the same -reduction. If a descendant
of~ occurs inside a contracted -redex, but it is
different from this redex, then the descendant must occur below a
variable position of the -redex, because there are no non-root
overlaps between the rules of significant reduction. Thus we may
simulate this -reduction by the same -reduction. If a contracted
-redex occurs inside a descendant~
of~, but it is different from this descendant, then
it must occur in~,~ or~. In this case we ignore the
-contraction while at all times maintaining the invariant: if
 is a descendant of~ then
 and , and the descendant
of~ in the simulated reduction is always identical with~,
i.e.~ (the -contractum of ) is not changed
by the simulated -reduction. Finally, if a
descendant~ of~ is
-contracted, then either  or
. In any case we can -reduce~
to~ or~. In other words, we defer the choice of the
simulated reduction path till the descendant of the -redex is
actually contracted.

\begin{definition}\label{def_a_redex}
  An -term~ is an \emph{-redex} and~ its
  \emph{-contractum}, if~ is an -term and one of the
  following holds:
  \begin{itemize}
  \item  and~ is an -term,
  \item  and~ is an -term,
  \item , ,  and~ is an -term,
  \item  and~ is an -term,
  \item  where the conventions regarding
    vector notation are as in Definition~\ref{def_clc_s},  for ,  for ,
    , , none of the~
    or~ is a tuple, and .
  \end{itemize}
  Because of the third point, an -contractum of an -redex is not
  unique. The notations , , , etc.~are
  used accordingly. Note that any -redex is an -redex.
\end{definition}

\begin{lemma}\label{lem_a_to_erased_equiv}
  If  then , and
  hence .
\end{lemma}

The above simple lemma implies that the conditions in significant
reduction rules are stable under -reduction and -expansion. Note
that if  then not necessarily  because of the
third point in Definition~\ref{def_a_redex}.

\begin{lemma}\label{lem_erase_expand}
  If~ is standard,  and
   then there is~ with
   and .
\end{lemma}

\begin{proof}
  Induction on the size of~. First assume~ is not a tuple
  and~ is the -contractum expanded in
  . If~ is an -term, then
   and we may take
  . If~ is not an -term, then it is an -term
  by~\ref{std_i_or_s_or_tuple} in Definition~\ref{def_standard}. We
  have the following possibilities, depending on the rule of~
  used in the expansion.
  \begin{itemize}
  \item If  then
    we take  and we have  and
    .
  \item If  then
    we may take .
  \item If  then we may
    take .
  \item If  then we may take
    .
  \item If 
    then  and~ is an
    -term. Hence  with ,  and .
    Recalling the convention  for any term~, we
    may assume
    \begin{itemize}
    \item[()] , , for , if 
      then~ is not a tuple, and if  then~ is not a
      tuple.
    \end{itemize}
    In other words, if e.g.~ is a tuple, then
     for some
    . If~ is not a tuple then we take
     and consider
    . This is chiefly to
    reduce the number of cases to consider. Let . Because~, we have~
    for . Also none of  is a tuple, by
    condition~\ref{std_no_nested_tuple} in
    Definition~\ref{def_standard}, or by~() if . Since
    , we have . Also~ cannot be a tuple, by
    condition~\ref{std_no_nested_tuple} in
    Definition~\ref{def_standard}, or by~() if . Thus
     where  stands for
    , and  and
     for , where none of
    the~ is a tuple, by definition (if ) or by
    condition~\ref{std_no_nested_tuple} in
    Definition~\ref{def_standard}. By
    Lemma~\ref{lem_standard_properties} also none of 
    is a tuple. We may thus take
     where  stands
    for . We have  and
    .
  \end{itemize}
  If~ is a tuple or~ is not the -contractum, then the
  claim follows from the inductive hypothesis.
\end{proof}

\begin{lemma}\label{lem_s_a_commute}
  If  and  is standard then
  .
\end{lemma}

\begin{proof}
  Suppose ,  and~ is standard. By
  induction on the definition of  we show that there
  is~ with  and . The
  base case is when the -contraction in  occurs at
  the root.

  If the -contraction occurs at the root, but the -contraction
  in  does not occur at the root, then it is easy to see
  by inspecting the definitions that the -redex in~ must
  occur below a variable position of the -redex. Since significant
  reduction rules are linear and their conditions are stable under
  -reduction, the claim holds in this case.

  Assume that both the -contraction and the -contraction occur
  at the root. If  then
  ,  and the -contraction of~
  yields either~ or~. We may thus take either
   or , and we have
  . If
   then the -contraction must be
  by the first rule of~, so  and we may take
  . All other cases are analogous.

  If neither the -contraction nor the -contraction occurs at the
  root, then the claim is easily established, possibly appealing to
  the inductive hypothesis.

  Finally, assume that the -contraction occurs at the root, but the
  -contraction does not occur at the root. We have the following
  possibilities.
  \begin{itemize}
  \item If  then the
    -contraction must occur inside~. So~ for
    some term~. Note that~ is an -term by definition of
    -contraction. Therefore~ is also an -term,
    by~\ref{std_s_term_reduce} in
    Definition~\ref{def_standard}. Thus~ satisfies the required
    conditions.
  \item If  then ,
     and the -contraction must occur inside~
    or~. We may take  and we still have
    .
  \item The cases  and
     are analogous to the first case.
  \item If
     then
    ,
     for  as in
    Definition~\ref{def_a_redex}, none of the  or  is a
    tuple, and
    . The -contraction must occur
    inside one of the~ or the~, or in~. For
    instance, assume . Since~ is a subterm
    of~ and it is not a tuple, it cannot -reduce to a tuple by
    Definition~\ref{def_standard}. Hence~ is not a tuple. Take
    . Note that
    . Thus~ is an -term, because~ is an
    -term and it -reduces only to -terms,
    by~\ref{std_s_term_reduce} in Definition~\ref{def_standard}.
  \end{itemize}
\end{proof}

\begin{corollary}\label{cor_s_a_commute}
  If  and~ is strongly
  standard then .
\end{corollary}

\begin{lemma}\label{lem_properly_in_a_redex}
  If  is a strongly standard -contractum of an -redex~,
  and~ is a proper subterm of~, then~ is standard.
\end{lemma}

\begin{proof}
  It suffices to show that~ is a subterm of some standard term.
  \begin{itemize}
  \item Suppose  with~ an
    -term. Both~ and~ are standard and~ is a
    subterm of one of them. The cases  and
     are analogous.
  \item Suppose  with~ an
    -term. Because  and~ is strongly standard,
     are standard. Also~ is an -term. This implies that
     is also standard. Since~ occurs in~ or
    , it is standard.
  \item Suppose
    . The
    term~ and each of~ and~ (with  as in
    Definition~\ref{def_a_redex}) is standard. Note that none of~
    or~ is a tuple by Definition~\ref{def_a_redex}. Since
    each~ is also standard, by inspecting
    Definition~\ref{def_standard} we may conclude
    that~ is standard. Similarly
     is standard. Also
     is standard. This
    implies that~ is standard, because it occurs in
     or
    .
  \end{itemize}
\end{proof}

\begin{lemma}\label{lem_a_preserves_s_term}
  If  is an -term and  then  is also an
  -term.
\end{lemma}

\begin{proof}
  Induction on the structure of~.
\end{proof}

\begin{lemma}\label{lem_expand_a_std}
  If~ is strongly standard and  then~ is standard.
\end{lemma}

\begin{proof}
  We check that the conditions in Definition~\ref{def_standard} hold
  for every subterm~ of~. We may assume that~ does not
  occur in~, as otherwise the claim follows from the fact that~
  is standard. Therefore,~ occurs in the -redex contracted in
  , or the -redex occurs inside~. If  is a
  proper subterm of the -redex, then our claim holds by
  Lemma~\ref{lem_properly_in_a_redex}. Hence, we may assume that the
  -redex~ is a subterm of~. Then  with~ a
  subterm of~ (so~ is strongly standard).
  \begin{enumerate}
  \item Suppose~ is the -contractum of~ and . By Definition~\ref{def_a_redex}, the term~ is an
    -term. Thus~ cannot be an -term. If~ is a tuple, then
    so is~. Otherwise,~ is an -term,
    by~\ref{std_i_or_s_or_tuple} in
    Definition~\ref{def_standard}. Hence  is also an -term by
    Lemma~\ref{lem_a_preserves_s_term}.
  \item Suppose  and~ is in
    -NF. If  then 
    or , hence  or
    . If~ is a proper subterm of~,
    then~ must be a subterm of~ or~, because
    -redexes are not in -NF. Thus,
     for some terms ,
    where~ is a subterm of~. Hence,  or
     by~\ref{std_c_1} in
    Definition~\ref{def_standard}.
  \item Suppose . If 
    then  and . Hence
    . If
     then  with
    . Because~ is standard,
     by~\ref{std_c_2} in
    Definition~\ref{def_standard}. Thus also
     by
    Lemma~\ref{lem_a_to_erased_equiv}.
  \item Suppose . If
    , then
    , as in
    Definition~\ref{def_a_redex}, so the claim holds. If~ is a
    proper subterm of~, then
     where 
    for , and~ is a subterm of~. By~\ref{std_s} in
    Definition~\ref{def_standard}, the term~ is a tuple of
    length~, and if  then~ is a tuple of
    length~. Since an -contractum is an -term, and hence not
    a tuple,  is not an -contractum, and if  then~
    is not an -contractum. Thus we may conclude that~ is a
    tuple of length~, and if  then~ is a
    tuple of length~.
  \item Suppose  is an -term and . Because
    also  and  is strongly standard, by
    Corollary~\ref{cor_s_a_commute} there is~ with
     and . By
    Definition~\ref{def_a_redex}, the term~ is an -term,
    so~ is also an -term by~\ref{std_s_term_reduce} in
    Definition~\ref{def_standard}. So~ is an -term by
    Lemma~\ref{lem_a_preserves_s_term}.
  \item Suppose  with . We
    have  where  for
    . By~\ref{std_no_nested_tuple} in
    Definition~\ref{def_standard}, none of  is a
    tuple. Thus it is easy to see by inspecting
    Definition~\ref{def_a_redex} that none of~ can
    be a tuple.
  \end{enumerate}
\end{proof}

\begin{lemma}\label{lem_expand_a}
  If  and  then .
\end{lemma}

\begin{proof}
  Suppose . By Corollary~\ref{cor_s_a_commute}
  there is~ with  and . Since~ is strongly standard, so is~. Therefore,~
  is standard by Lemma~\ref{lem_expand_a_std}.

  Suppose  with~ in -NF. By
  Corollary~\ref{cor_s_a_commute} there is~ with
   and . Since an -redex
  is an -redex and~ is in -NF, we conclude that
  . But then , because
  .
\end{proof}

\begin{corollary}\label{cor_expand}
  If ,  and
   then there is~ with
   and .
\end{corollary}

\begin{proof}
  Follows from Lemma~\ref{lem_erase_expand}, Lemma~\ref{lem_eqv_i} and
  Lemma~\ref{lem_expand_a}.
\end{proof}

\begin{lemma}\label{lem_good_reduction}
  If~ has no -NFs other than~ then
  .
\end{lemma}

\begin{proof}
  Since -reduction is terminating, by reducing -redexes outside
  any tuples and not using the second rule for~ we will
  ultimately obtain a term~ with all -redexes inside tuples,
  and such that . Note that an -redex in~
  may only occur inside a tuple, because any -redex by the second
  rule for~ is also an -redex by the first rule
  for~. If~ is in -NF then . Otherwise,
  any -NF of~ must contain a tuple, because -reduction
  inside a tuple cannot erase this tuple or create an -redex
  outside of it. But since any -NF of~ is an -NF of~,
  this contradicts the fact that~ has no -NFs other
  than~.
\end{proof}

We now have everything we need to show the central lemma of the
confluence proof.

\begin{lemma}\label{lem_f_nf}
  The system~ is -normal, i.e., if  then
  .
\end{lemma}

\begin{proof}
  If  then by Lemma~\ref{lem_clc_equivalent} we have
  . Note that  and
  . Thus, using Corollary~\ref{cor_contr}
  and Corollary~\ref{cor_expand} it is easy to show by induction on
  the length of  that there is~ with
   and . By
  Lemma~\ref{lem_good_reduction} we have . But
  then, because , using
  Lemma~\ref{lem_s_minus_erase} it is easy to show by induction on the
  length of  that
  .
\end{proof}

It remains to derive the confluence of~ and~ from
Lemma~\ref{lem_f_nf}. We use a trick with an auxiliary term rewriting
system~, in a way similar to how the confluence of~ is
derived from the condition~
in~\cite{Vrijer1999}. The idea is to eliminate the non-trivial overlap
between the rules of~ by imposing additional side conditions.

\begin{definition}
  The term rewriting system~ is defined by the following rules:
  
\end{definition}

\begin{lemma}\label{lem_clc_0_to_r}
  If  then .
\end{lemma}

\begin{lemma}\label{lem_r_to_clc}
  If  then .
\end{lemma}

\begin{proof}
  Follows from definitions and Lemma~\ref{lem_f_nf}.
\end{proof}

\begin{lemma}\label{lem_r_confluent}
  The system~ is confluent.
\end{lemma}

\begin{proof}
  Because  by Lemma~\ref{lem_f_nf}, the system~
  is weakly orthogonal (i.e.~it is left-linear and all its critical
  pairs are trivial). By Lemma~\ref{lem_r_to_clc} the conditions are
  stable under reduction. Weakly orthogonal conditional term rewriting
  systems whose conditions are stable under reduction are
  confluent~\cite[Chapter 4]{Terese2003}.
\end{proof}

\begin{theorem}
  The systems~ and~ are confluent.
\end{theorem}

\begin{proof}
  Since  implies , it
  suffices to show that if  then there is~ with
   and . So suppose . Then by Lemma~\ref{lem_clc_equivalent} we have . By Lemma~\ref{lem_clc_0_to_r} we obtain . By Lemma~\ref{lem_r_confluent} there is~ with  and . By Lemma~\ref{lem_r_to_clc} we
  have  and .
\end{proof}

\bibliography{biblio}{}

\end{document}
