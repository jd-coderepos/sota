

\documentclass{article}

\usepackage{times}
\usepackage{graphicx} \usepackage{subfigure} 

\usepackage{natbib}

\usepackage{algorithm}
\usepackage{algorithmic}

\usepackage{amsmath, amssymb, amsthm}

\usepackage{hyperref}

\newcommand{\theHalgorithm}{\arabic{algorithm}}



\usepackage[accepted]{icml2016}


\icmltitlerunning{On Greedy Column Subset Selection}

\newtheorem{defin}{Definition}\newtheorem{thm}{Theorem}\newtheorem{exe}{Exercise}\newtheorem{exa}{Example}\newtheorem{fact}{Fact}\newtheorem{prop}{Proposition}\newtheorem{lemma}{Lemma}\newtheorem{corol}{Corollary}\newtheorem{conj}{Conjecture}\newtheorem{remark}{Remark}\newtheorem{discussion}{Discussion}\newtheorem{conc}{Conclusion}

\newcommand{\Real}{\mathbb{R}}
\newcommand{\E}{\mathbb{E}}
\newcommand{\argmin}{\text{arg min}}
\newcommand{\argmax}{\text{arg max}}
\newcommand{\Tr}{\text{tr}}
\newcommand{\Proj}{\text{proj}}
\newcommand{\Span}{\text{span}}
\newcommand{\Pow}{\mathcal{P}}
\newcommand{\eps}{\varepsilon}
\newcommand{\del}{\delta}
\newcommand{\re}{\mathbb{R}}
\newcommand{\norm}[1]{\lVert #1 \rVert}
\newcommand{\calN}{\mathcal{N}}
\newcommand{\plusminus}{\raisebox{.2ex}{}}
\newcommand{\TODO}{\textbf{TODO}}
\newcommand{\nnz}{\text{nnz}}
\newcommand{\enum}[1]{\begin{enumerate} #1 \end{enumerate}}
\newcommand{\greedy}{\textsc{Greedy}}
\newcommand{\greedypp}{\textsc{Greedy++}}
\newcommand{\ltlgreedy}{\textsc{Lazier-than-lazy Greedy}}
\newcommand{\distgreedy}{\textsc{Distgreedy}}
\newcommand{\iprod}[1]{\langle #1 \rangle}
\newcommand{\opt}{OPT}
\newcommand{\gcss}{\textsf{GCSS}}
\newcommand{\maxcoverage}{\textsf{MAX-COVERAGE}}

\setlength{\parskip}{4pt}

\begin{document} 

\twocolumn[
\icmltitle{Greedy Column Subset Selection: \\ 
           New Bounds and Distributed Algorithms}

\icmlauthor{Jason Altschuler}{jasonma@princeton.edu}
\icmladdress{Princeton University,
            Princeton, NJ 08544}
\icmlauthor{Aditya Bhaskara}{bhaskara@cs.utah.edu}
\icmladdress{School of Computing, 50 S. Central Campus Drive,
             Salt Lake City, UT 84112}
\icmlauthor{Gang (Thomas) Fu}{thomasfu@google.com}
\icmlauthor{Vahab Mirrokni}{mirrokni@google.com}
\icmlauthor{Afshin Rostamizadeh}{rostami@google.com}
\icmlauthor{Morteza Zadimoghaddam}{zadim@google.com}
\icmladdress{Google, 76 9th Avenue, New York, NY 10011}


\icmlkeywords{column selection, greedy algorithms, coresets}

\vskip 0.3in
]

\begin{abstract}
The problem of column subset selection has recently attracted a
large body of research, with feature selection serving as one obvious
and important application. Among the techniques that have been
applied to solve this problem, the greedy algorithm has been shown to
be quite effective in practice. However, theoretical guarantees on its performance have not been explored thoroughly, especially
in a distributed setting.  In this paper, we study the greedy
algorithm for the column subset selection problem from a theoretical and
empirical perspective and show its effectiveness in a distributed
setting. In particular, we provide an improved 
approximation guarantee for the greedy algorithm which we show is tight up to a constant factor, and
present the first distributed implementation with provable
approximation factors. We use the idea of randomized composable core-sets, developed recently in the context of submodular maximization. 
Finally, we validate the effectiveness of this distributed algorithm via an
empirical study.
\end{abstract} 

\section{Introduction}
Recent technological advances have made it possible to collect unprecedented amounts of data. However, extracting patterns of information from these high-dimensional massive datasets is often challenging. How do we automatically determine, among millions of measured features (variables), which are informative, and which are irrelevant or redundant? The ability to select such features from high-dimensional data is crucial for computers to recognize patterns in complex data in ways that are fast, accurate, and even human-understandable \cite{Guyon}.

An efficient method for feature selection receiving increasing attention is Column Subset Selection (CSS). CSS is a constrained low-rank-approximation problem that seeks to approximate a matrix (e.g. instances by features matrix) by projecting it onto a space spanned by only a few of its columns (features). Formally, given a matrix  with  columns, and a target rank , we wish to find a size- subset  of 's columns such that each column  of  () is contained as much as possible in the subspace , in terms of the Frobenius norm:


While similar in spirit to general low-rank approximation, some advantages with CSS include flexibility,
interpretability and efficiency during inference. CSS is an
unsupervised method and does not require labeled data, which is
especially useful when labeled data is sparse.  We note, on the other
hand, unlabeled data is often very abundant and therefore scalable
methods, like the one we present, are often needed.  
Furthermore, by subselecting features, as opposed to generating new
features via an arbitrary function of the input features, we keep the
semantic interpretation of the features intact. This is especially
important in applications that require interpretable models.  A third
important advantage is the efficiency of applying the solution CSS
feature selection problem during inference. Compared to PCA or other
methods that require a matrix-matrix multiplication to project input
features into a reduced space during inference time, CSS only requires
selecting a subset of feature values from a new instance vector. This
is especially useful for latency sensitive applications and when the
projection matrix itself may be prohibitively large, for example in
restricted memory settings.

While there have been significant advances in CSS~\cite{Boutsidis1,Boutsidis2,Guruswami}, most of the algorithms are either impractical and not applicable in a distributed setting for large datasets, or they do not have good (multiplicative ) provable error bounds. 
Among efficient algorithms  studied for the CSS problem is the simple {\em greedy algorithm}, which iteratively selects the best column and keeps it. Recent work shows that it does well in practice and even in a distributed setting~\cite{Farahat1, Farahat2} and admits a performance guarantee \cite{Civril1}. However, the known guarantees depend on an arbitrarily large matrix-coherence parameter, which is unsatisfactory. Also, even though the algorithm is relatively fast, additional optimizations are needed to scale it to datasets with millions of features and instances. 

\subsection{Our contributions}
Let  be the given matrix, and let  be the target number of columns. Let  denote the {\em optimal} set of columns, i.e., one that {\em covers} the maximum Frobenius mass of . Our contributions are as follows.

{\em Novel analysis of Greedy.} For any , we show that the natural greedy algorithm (Section~\ref{section-2}), after  steps, gives an objective value that is within a   factor of the optimum. We also give a matching lower bound, showing that  is tight up to a constant factor. Here  is the smallest squared singular value of the {\em optimal} set of columns (after scaling to unit vectors).

Our result is similar in spirit to those of~\cite{Civril1, Liberty}, but with an important difference. Their bound on  depends on the {\em least}  over \textit{all}  of size , while ours depends on . Note that these quantities can differ significantly. For instance, if the data has even a little bit of redundancy (e.g. few columns that are near duplicates), then there exist  for which  is tiny, but the optimal set of columns could be reasonably well-conditioned (in fact, we would {\em expect} the optimal set of columns to be fairly well conditioned).



{\em Distributed Greedy.} We consider a natural distributed implementation of the greedy algorithm (Section~\ref{section-2}). Here, we show that an interesting phenomenon occurs: even though partitioning the input does not work in general (as in coreset based algorithms), {\em randomly} partitioning works well. This is inspired by a similar result on submodular maximization~\cite{Mirrokni}. Further, our result implies a -pass streaming algorithm for the CSS problem in the {\em random arrival} model for the columns.



We note that if the columns each have sparsity ,~\cite{Boutsidis2015} gives an algorithm with total communication of . Their algorithm works for ``worst case'' partitioning of the columns into machines and is much more intricate than the greedy algorithm. In constrast, our algorithm is very simple, and for a random partitioning, the communication is just the first term above, along with an extra  term. Thus depending on  and , each of the bounds could be better than the other.

{\em Further optimizations.} We also present techniques to speed up the implementation of the greedy algorithm. We show that the recent result of~\cite{Mirzasoleiman} (once again, on submodular optimization) can be extended to the case of CSS, improving the running time significantly.


We then compare our algorithms (in accuracy and running times) to various well-studied CSS algorithms. (Section 6.)

\subsection{Related Work}
The CSS problem is one of the central problems related to matrix approximation. Exact solution is known to be UG-hard~\cite{Civril2}, and several approximation methods have been proposed over the years. Techniques such as importance sampling \cite{Drineas1, Frieze}, adaptive sampling \cite{Deshpande1}, volume sampling \cite{Deshpande2, Deshpande4}, leverage scores \cite{Drineas-Leverage}, and projection-cost preserving sketches \cite{Cohen} have led to a much better understanding of the problem. \cite{Guruswami} gave the optimal dependence between column sampling and low-rank approximation.
Due to the numerous applications, much work has been done on the implementation side, where adaptive sampling and leverage scores have been shown to perform well. A related, extremely simple algorithm is the greedy algorithm, which turns out to perform well and be scalable \cite{Farahat1, Farahat2}. This was first analyzed by~\cite{Civril1}, as we discussed. 

There is also substantial literature about distributed algorithms for CSS \cite{Pi, Feldman, Cohen, Farahat3, Farahat4, Boutsidis2015}. In particular, \cite{Farahat3, Farahat4} present distributed versions of the greedy algorithm based on MapReduce. Although they do not provide theoretical guarantees, their experimental results are very promising.

The idea of composable coresets has been applied explicitly or implicitly to several problems~\cite{FeldmanSS13,BalcanEL13,VahabPODS2014}. Quite recently, for some problems in which coreset methods do not work in general, surprising results have shown that randomized variants of them give good approximations~\cite{BarbosaENW15,Mirrokni}. We extend this framework to the CSS problem.


\subsection{Background and Notation}
We use the following notation throughout the paper. The set of integers  is denoted by . For a matrix ,  denotes the th column (). Given ,  denotes the submatrix of  containing columns indexed by . The projection matrix  projects onto the column span of . Let  denote the Frobenius norm, i.e., . We write  to denote the minimum \textit{squared} singular value, i.e., . We abuse notation slightly, and for a set of vectors , we write  for the  of the matrix with columns .

\iffalse
{\bf Submodular optimization.}  Given a finite set  and a set function , define the marginal gain of adding an element  to a set  by .  is said to be submodular if  for any subsets  and any element . This is a formalization of the well-known economic principle of decreasing marginal utility.  is further said to be nonnegative if  for any , and monotonically nondecreasing if  for any . The theory of maximizing submodular functions subject to a cardinality constraint has been well studied, and has been shown to be NP-hard [Nemhauser and
Wolsey 1978; Feige 1998]. However, it is a key result in combinatorial optimization that a simple greedy algorithm to this problem for nonnegative, monotone nondecreasing submodular functions admits a  constant factor approximation [Nemhauser '78].
\fi

\begin{defin}\label{defn:css-problem}
Given a matrix  and an integer , the \textbf{Column Subset Selection (CSS) Problem} asks to find

i.e., the set of columns that {\em best explain} the full matrix .
\end{defin}

We note that it is also common to cast this as a minimization problem, with the objective being . While the exact optimization problems are equivalent, obtaining multiplicative approximations for the minimization version could be harder when the matrix is low-rank.

For a set of vectors  and a matrix , we denote

\iffalse
In this article, instead of minimizing the unexplained (error) part  of , we maximize the explained part  of . Formally,

Thus, a subset of columns that maximizes explanation of  will also minimized the unexplained error.
\fi
Also, the case when  is a single vector will be important. For any vector , and a set of vectors , we write


\begin{remark} \label{rem:not-submodular} Note that  can be viewed as the extent to which we can {\em cover} matrix  using vectors .  However, unlike combinatorial covering objectives, our definition is not submodular, or even subadditive.
\iffalse
\begin{defin} \label{f definition matrix}
Given , define the function:  by:  over the columns  of . 
\end{defin}
\fi
As an example, consider covering the following  using its own columns. Here, .

\end{remark}

\iffalse
\subsection{Overview of article}
In section 2.1, we present a ``vanilla'' greedy algorithm GREEDY for choosing  columns of a matrix  that can approximate all of 's other columns linearly. This provides intuition for our proposed algorithm ALG, presented in section 2.2. ALG is a much more efficient version of GREEDY because of three optimizations: (1) an efficient calculation of marginal gain; (2) a random projection to compress the ambient dimension of 's columns; and (3) only looking over a small random subset of all  columns in each iteration. These optimizations make analyzing ALG slightly more involved than GREEDY. To this end, we first analyze GREEDY in section 3, and then use those results to analyze ALG in section 4.
\fi


\section{Greedy Algorithm for Column Selection} \label{section-2}

Let us state our algorithm and analysis in a slightly general form. Suppose we have two matrices  with the same number of rows and ,  columns respectively. The  problem is that of finding a subset  of columns of , that maximizes  subject to .
Clearly, if , we recover the CSS problem stated earlier. Also, note that scaling the columns of  will not affect the solution, so let us assume that the columns of  are all unit vectors. The greedy procedure iteratively picks columns of  as follows:

\begin{algorithm} \label{alg:greedy}
\caption{(, , )}
\begin{algorithmic}[1]
\STATE 
\FOR{}
\STATE Pick column  that maximizes 
\STATE 
\ENDFOR
\STATE Return 
\end{algorithmic}
\end{algorithm}

Step (3) is the computationally intensive step in  -- we need to find the column that gives the most {\em marginal gain}, i.e., .  In Section~\ref{section-5}, we describe different techniques to speed up the calculation of marginal gain, while obtaining a  approximation to the optimum  value. Let us briefly mention them here. 

{\em Projection to reduce the number of rows.}  We can left-multiply both  and  with an  Gaussian random matrix.  For , this process is well-known to preserve , for any -subset of the columns of  (see~\cite{Sarlos} or Appendix Section~\ref{app:random-projections} for details).

{\em Projection-cost preserving sketches.}
Using recent results from \cite{Cohen}, we can project each {\em row} of  onto a random  dimensional space, and then work with the resulting matrix. Thus we may assume that the number of columns in  is . This allows us to efficiently compute .

\iffalse
\textbf{Random projections to reduce the number of rows.} We can project each column of  and  onto a random  dimensional space, and then work with the resulting matrices. Thus we may assume that the number of rows in both  and  is , which can be a big improvement. This can be obtained by a union bound on Lemma 10 from \cite{Sarlos}. (Full details in appendix.)
\fi

{\em Lazier-than-lazy greedy.}
\cite{Mirzasoleiman} recently proposed the first algorithm that achieves a constant factor approximation for maximizing submodular functions with a {\em linear} number of marginal gain evaluations. We show that a similar analysis holds for , even though the cost function is not submodular.

We also use some simple yet useful ideas from \cite{Farahat2} to compute the marginal gains (see Section~\ref{section-5}).

\subsection{Distributed Implementation}
We also study a distributed version of the greedy algorithm, shown below (Algorithm~\ref{alg:cs-greedy}).  is the number of machines.

\begin{algorithm} \label{alg:cs-greedy}
\caption{(, , , )}
\begin{algorithmic}[1]
\STATE {\em Randomly} partition the columns of  into 
\STATE (Parallel) compute 
\STATE (Single machine) aggregate the , and compute 
\STATE Return 
\end{algorithmic}
\end{algorithm}

As mentioned in the introduction, the key here is that the partitioning is done {\em randomly}, in contrast to most results on {\em composable summaries}. We also note that machine  only sees columns  of , but requires evaluating  on the full matrix  when running \greedy.\footnote{It is easy to construct examples in which splitting both  and  fails badly.} The way to implement this is again by using projection-cost preserving sketches. (In practice, keeping a small sample of the columns of  works as well.) The sketch is first passed to all the machines, and they all use it to evaluate .



We now turn to the analysis of the single-machine and the distributed versions of the greedy algorithm.


\section{Peformance analysis of GREEDY} \label{section-3}

The main result we prove is the following, which shows that by taking only slightly more than  columns, we are within a  factor of the optimal solution of size .

\begin{thm} \label{thm:greedy-main}
Let  and . Let  be a set of columns from  that maximizes  subject to .  Let  be any constant, and let  be the set of columns output by , for . Then we have
\end{thm}

We show in Appendix Section \ref{app:tight-ex} that this bound is tight up to a constant factor, with respect to  and . Also, we note that  is a harder problem than , implying that if we can choose only  columns, it is impossible to approximate to a ratio better than , unless P=NP. (In practice,  does much better, as we will see.)

The basic proof strategy for Theorem~\ref{thm:greedy-main} is similar to that of maximizing submodular functions, namely showing that in every iteration, the value of  increases significantly. The key lemma is the following.

\begin{lemma} \label{lem:large-gain}
Let  be two sets of columns, with .  Then there exists  such that

\end{lemma}

Theorem~\ref{thm:greedy-main} follows easily from Lemma~\ref{lem:large-gain}, which we show at the end of the section. Thus let us first focus on proving the lemma.  Note that for submodular , the analogous lemma simply has  on the right-hand side (RHS).
The main ingredient in the proof of Lemma~\ref{lem:large-gain} is its {\em single vector} version:
\begin{lemma}\label{lem:one-vector}
Let  be two sets of columns, with . Suppose .  Then

\end{lemma}

Let us first see why Lemma~\ref{lem:one-vector} implies Lemma~\ref{lem:large-gain}. Observe that for any set of columns ,  (sum over the columns), by definition. For a column , let us define . Now, using Lemma~\ref{lem:one-vector} and plugging in the definition of , we have

To get \eqref{eq:temp5}, we used Jensen's inequality () treating  as a probability distribution over indices . Thus it follows that there exists an index  for which the gain is at least a  factor, proving Lemma~\ref{lem:large-gain}.


\begin{proof}[Proof of Lemma~\ref{lem:one-vector}]
Let us first analyze the quantity , for some .  As mentioned earlier, we may assume the  are normalized. If , this quantity is . Thus we can assume that such  have been removed from . Now, adding  to  gives a gain because of the component of  orthogonal to , i.e., , where  denotes the projector onto . Define
 By definition, . Thus the projection of a vector  onto  is , which is a vector whose squared length is
.
This implies that


Thus, to show the lemma, we need a lower bound on . Let us start by observing
that a more explicit definition of  is the squared-length of the projection of  onto , i.e. . Let  be a maximizer. Since , by the definition of the smallest squared singular value, we have .  Now, decomposing , we have

Thus (since the worst case is when all signs align),

where we have used the fact that , which is true from the definition of  (and since  is a vector of length  in ). 

Now, because , we have . Thus,

where we have used Cauchy-Schwartz, and then the fact that  (because  are unit vectors). Finally, we know that , which implies 

Combined with~\eqref{eq:gain-single}, this proves the lemma. 
\end{proof}


 \begin{proof}[Proof of Theorem~\ref{thm:greedy-main}]
 For notational convenience, let  and . Define , , ,  until . Note that the gap . We show that it takes at most  iterations (i.e. additional columns selected) to reduce the gap from  to . To prove this, we invoke Lemma \ref{lem:large-gain} to see that the gap filled by  iterations is at least . Thus the total number of iterations  required to get a gap of at most  is:
\vspace{-0.1cm}

 where the last step is due to  and . Therefore, after  iterations, we have . Rearranging proves the lemma.
 \end{proof}


\section{Distributed Greedy Algorithm} \label{section-4}
We will now analyze the distributed version of the greedy algorithm that was discussed earlier. We show that in one {\em round}, we will find a set of size  as before, that has an objective value , where  is a condition number (defined below). We also combine this with our earlier ideas to say that if we perform  {\em rounds} of \distgreedy, we get a  approximation (Theorem~\ref{thm:core-set-2}).

\subsection{Analyzing one round}
\iffalse
Often modern data sets are too large for us to run GREEDY or ALG on a single processor. The approach of randomized composable core-sets has received increased popularity as a provably good way to subdivide a large problem into smaller problems, each of which can be approached by a separate machine in a computer cluster. This type of approach is especially scalable because it can easily be used in tandem with mainstream distributed paradigms such as MapReduce.
\\ \\ Recently, Mirrokni and Zadimoghaddam showed that randomized composable core-sets give a constant factor approximation for maximizing submodular functions \cite{Mirrokni}. We show that here that although our cost function is not submodular, a similar result still holds (up to the condition number).
\\ \\ Formally, consider as before Column Subset Section on a matrix  with target rank . The difference is that now we have  machines at our disposal. The approach we take is to randomly partition the  columns into  submatrices, each of dimension roughly . We give each submatrix to a different machine, and run GREEDY on each of these machines with target rank  to produce a ``core-set'' solution. Finally, we collect the  core-sets, and run GREEDY a final time on a single machine to produce our final set of  columns.
\\ \\ The parameter  must be chosen with care, since there is a natural tradeoff between precision and efficiency. Importantly, it must be sufficiently large such that we have enough options in the final stage to choose a a set of  columns with a constant factor approximation. But from a practical standpoint,  must be small enough such that the final stage with approximately  can be run on a single machine. If this is not possible, we can run the above procedure with multiple rounds.

\subsection{Constant factor approximation (up to condition number)}
\fi

We consider an instance of , and let  denote an optimum set of  columns.
 Let  denote the number of machines available.
 The columns (of ) are partitioned across machines, such that machine  is given columns . It runs  as explained earlier and outputs  of size . Finally, all the  are moved to one machine and we run  on their union and output a set  of size . Let us define .

\begin{thm}\label{thm:distributed-main}
Consider running  on an instance of . We have
 
\end{thm}
The key to our proof are the following definitions:

In other words,  contains all the vectors in  that would have been selected by machine  if they had been added to the input set . By definition, the sets  form a partition of  for every .

\iffalse
\begin{remark} \label{rem-opt-partition}
By definition,  is a union of disjoint sets for all . That is,  and  partition .
\end{remark}
\fi

{\bf Proof outline.} Consider any partitioning , and consider the sets . Suppose one of them (say the th) had a large value of . Then, we claim that  is also large. The reason is that the greedy algorithm does {\em not} choose to pick the elements of  (by definition) -- this can only happen if it ended up picking vectors that are ``at least as good''. This is made formal in Lemma~\ref{lem:opt-ns}.  Thus, we can restrict to the case when {\em none} of  is large. In this case, Lemma~\ref{lem:additivity} shows that  needs to be large for each . Intuitively, it means that most of the vectors in  will, in fact, be picked by  (on the corresponding machines), and will be considered when computing . The caveat is that we might be unlucky, and for every , it might have happened that it was sent to machine  for which it was not part of . We show that this happens with low probability, and this is where the random partitioning is crucial (Lemma~\ref{lem:opt-s}).  This implies that either , or one of the  has a large value of .

Let us now state two lemmas, and defer their proofs to Sections~\ref{app:opt-ns} and~\ref{app:additivity} respectively. 

\begin{lemma} \label{lem:opt-ns}
For  of size , we have
 
\end{lemma}
\iffalse
Fix . Let  denote the output of  on  for target rank . By definition of  and , we know . Denote  for shorthand. Recall from Lemma \ref{Large marginal gain lemma} that for any  such that , then:

Note that since  by construction, so  and also . Thus:

Let , , \dots,  until . We show that it takes at most  iterations (i.e. additional columns selected) to reduce the gap from  to . To see this, invoke equation \eqref{eq-lem-coreset-2-gain} above to see that:

So the total number of iterations  required to get a gap of at most  is:

Equation \eqref{eq-lem-coreset-2-geo-1} is due to the fact that  is a geometric series by construction. Equation \ref{eq-lem-coreset-2-geo-2} is because  and . 
\\ \\ Thus, after  iterations, we have . Rearranging proves the lemma.
\end{proof}
\fi

\begin{lemma} \label{lem:additivity}
For any matrix , and any partition  of :

\end{lemma}
\iffalse
Let  be a maximizer. Define  and . Note that by bilinearity of the inner product:

Thus by a simple averaging argument, either  or . WLOG, let the first one be true. Let  denote the normalization of . Then:

Now observe that since , so:

In particular, this implies that:

Combining equations \eqref{eq-lem-coreset-final-1} and \eqref{eq-lem-coreset-final-2} finishes the proof, since  is non-negative by Lemma \ref{f structure lemma}.
\end{proof}


Let  be the set of  items that Greedy selects on set , i.e.   . 
\fi
Our final lemma is relevant when none of  are large and, thus,  is large for {\em all}  (due to Lemma~\ref{lem:additivity}). In this case, Lemma~\ref{lem:opt-s} will imply that the expected value of  is large.

Note that  is a random partition, so the , the , , , and  are all random variables. However, all of these value are fixed given a partition . In what follows, we will write  to mean .

\begin{lemma}\label{lem:opt-s}
For a random partitioning , and  of size , we have

\end{lemma}
\begin{proof}
At a high level, the intuition behind the analysis is that many of the vectors in  are selected in the first phase, i.e., in . For an  , let  denote the indicator for .

Suppose we have a partition . Then if  had gone to a machine  for which , then by definition,  will be in . Now the key is to observe (see definitions) that the event  does not depend on where  is in the partition! In particular, we could think of partitioning all the elements except  (and at this point, we know if  for all ), and {\em then} randomly place .  Thus

where  denotes the indicator.

We now use this observation to analyze . Consider the execution of the greedy algorithm on , and suppose  denotes the set of vectors picked at the th step (so  has  vectors). The main idea is to give a lower bound on
where the expectation is over the partitioning . Let us denote by  the RHS of \eqref{eq:main-lem-to-show}, for convenience.  Now, the trick is to show that for {\em any}  such that , the expectation in~\eqref{eq:diff-expectations} is large. One lower bound on  is (where  is the indicator as above) 

Now for every , we can use~\eqref{eq:n14} to obtain
 
  Now, using~\eqref{eq:start}-\eqref{eq:temp6}, we can bound the inner sum by

Now, we use  and the identity that for any two nonnegative reals : .
Together, these imply

and consequently: 
 
for . 
If for some , we have , the proof is complete because  is monotone, and . 
Otherwise,   is at least  for each of the  values of . We conclude that  should be at least  which completes the proof. 
\iffalse
For any , we define  to be the set of first  columns that Greedy chooses from .
In particular, we have .
To lower bound , we apply linearity of expectation and lower bound the expected marginal value  at step .
Since algorithm Greedy chooses the column with the maximum marginal value at each step, we know that the marginal value at step  is at least  for any column .
In particular we are interested in lower bounding the marginal values using  where  is the set of columns in  that are selected for the second stage, i.e. . For the sake of analysis, suppose  is a random column in .
This column is sent to a random machine , i.e. .
By definition,  is selected () if and only if , and in that case, we know the marginal value at this step is lower bounded by  , 
otherwise we just lower bound the marginal by zero.
Therefore,  is at least  where  is the indicator function, and is one when  is in , and zero otherwise. Since the choice of  and  are independent of each other, we can imagine that machine  is chosen randomly at first, then a random column  is drawn from . We conclude that: 



Using Lemma~\ref{Large marginal gain helper lemma}, we know the sum  is lower bounded by . The quadratic form of this lower bound makes it harder to use it for expectations. Therefore we use the following relaxed inequality:



where the first inequality can be seen by the identity  for any  and , and the second inequality holds because  is a subset of , and  is a non-decreasing function. Taking the expected value of both sides of equations Equations \eqref{eq:marginal-2}, and \eqref{eq:marginal-3}, and combining the result with equation \eqref{eq:marginal-1} yields the following lower bound on the expected value of marginal value at each step:



We note that  is at least  times the above lower bound since we select that many items in the second round. Therefore we have  which completes the proof.
\fi
\end{proof}
\begin{proof}[Proof of Theorem~\ref{thm:distributed-main}]
If  for some , then we are done, because Lemma~\ref{lem:opt-ns} implies that  is large enough.  Otherwise, by Lemma~\ref{lem:additivity},  for all . 
Now we can use Lemma~\ref{lem:opt-s} to conclude that , completing the proof.
\end{proof}

\subsection{Multi-round algorithm}
We now show that repeating the above algorithm helps achieve a -factor approximation.

We propose a framework with  epochs for some integer . In each epoch , we run the  algorithm to select set . The only thing that changes in different epochs is the objective function: in epoch , the algorithm selects columns based on the function  which is defined to be:  for any . We note that function  is indeed the same as . The final solution is the union of solutions: . 


\begin{thm}\label{thm:core-set-2}
For any , the expected value of the solution of the -epoch  algorithm, for , is at least .
\end{thm}

The proof is provided in Section~\ref{app:core-set-2} of the appendix.

{\em Necessity of Random Partitioning.}  We point out that the random partitioning step of our algorithm is crucial for the  problem.  We adapt the instance from~\cite{VahabPODS2014} and show that even if each machine can compute  exactly, and is allowed to output  columns, it cannot compete with the optimum. Intuitively, this is because the partition of the columns in  could ensure that in each partition , the best way of covering  involve picking some vectors , but the 's for different  could overlap heavily, while the global optimum should use different  to capture different {\em parts} of the space to be covered. (See Theorem \ref{thm:rand-part} in Appendix~\ref{app:rand-part} for details.)


\section{Further optimizations for \greedy} \label{section-5}
We now elaborate on some of the techniques discussed in Section~\ref{section-2} for improving the running time of . 
We first assume that we left-multiply both  and  by a random Gaussian matrix of dimension , for . Working with the new instance suffices for the purposes of  approximation to CSS (for picking  columns). (Details in the Appendix, Section~\ref{app:random-projections})









\subsection{Projection-Cost Preserving Sketches}
Marginal gain evaluations of the form  require summing the marginal gain of  onto each column of . When  has a large number of columns, this can be very expensive. To deal with this, we use a {\em sketch} of  instead of  itself. This idea has been explored in several recent works; we use the following notation and result: 

\begin{defin}[\cite{Cohen}] \label{defin:pcps} For a matrix , 
 is a \emph{rank- Projection-Cost Preserving Sketch (PCPS)} with error  if for any set of  vectors , we have: 
where  is a constant that may depend on  and  but is independent of .
\end{defin}

\begin{thm}\label{thm:pcps}[Theorem 12 of \cite{Cohen}]
Let  be a random matrix with  rows and  columns, where each entry is set independently and uniformly to . Then for any matrix , with probability at least ,  is a rank- PCPS for .
\end{thm}

Thus, we can use PCPS to sketch the matrix  to have roughly  columns, and use it to compute  to a  accuracy for any  of size .  This is also used in our distributed algorithm, where we send the sketch to every machine.

\subsection{Lazier-than-lazy Greedy}
The natural implementation of  requires  evaluations of  since we compute the marginal gain of all  candidate columns in each of the  iterations. For submodular functions, one can do better: the recently proposed  algorithm obtains a   approximation with only a linear number  of marginal gain evaluations \cite{Mirzasoleiman}. We show that a similar result holds for \gcss, even though our cost function  is not submodular. 

The idea is as follows. Let  be the current solution set. To find the next element to add to , we draw a sized  subset uniformly at random from the columns in . We then take from this set the column with largest marginal gain, add it to , and repeat. We show this gives the following guarantee (details in Appendix Section~\ref{app:thm-lazier-than-lazy}.)

\begin{thm} \label{thm-lazier-than-lazy:main}
Let  and . Let  be the set of columns from  that maximizes  subject to . Let  be any constants such that . Let  be the set of columns output by , for . Then we have:

Further, this algorithm evaluates marginal gain only a linear number  of times.
\end{thm}

Note that this guarantee is nearly identical to our analysis of  in Theorem \ref{thm:greedy-main}, except that it is in expectation. The proof strategy is very similar to that of Theorem \ref{thm:greedy-main}, namely showing that the value of  increases significantly in every iteration (see Appendix Section~\ref{app:thm-lazier-than-lazy}).

{\bf Calculating marginal gain faster.} We defer the discussion to Appendix Section~\ref{sec:app:marginal}. 


\section{Experimental results}\label{section-6}

\begin{figure*}[t]
\centering
\includegraphics[scale=0.32]{figure.pdf}
\caption{A comparison of reconstruction accuracy, model classification
accuracy and runtime of various column selection methods (with PCA
proved as an upper bound). The runtime is shown plot shows the
relative speedup over the naive GREEDY algorithm.}
\label{fig}
\end{figure*}

In this section we present an empirical investigation of
the GREEDY, GREEDY++ and \distgreedy\ algorithms.
Additionally, we will compare with several baselines:
\\
    {\bf Random:}
    The simplest imaginable baseline, this method selects
    columns randomly. \\
{\bf 2-Phase:}
    The two-phased algorithm of \cite{Boutsidis2}, which
operates by first sampling  columns based on
properties of the top- right singular space of the input matrix
(this requires computing a top- SVD), then finally selects exactly
 columns via a deterministic procedure. The overall complexity is
dominated by the top- SVD, which is . \\
{\bf PCA:}
    The columns of the rank- PCA projection matrix will be
used to serve as an upper bound on performance, as they explicitly
minimize the Forbenius reconstruction criteria. Note this method only
serves as an upper bound and does not fall into  the framework of
column subset selection.


We investigate using these algorithms using two datasets, one with a small
set of columns (mnist) that is used to compare both scalable and
non-scalable methods, as well as a sparse dataset with a large number of
columns (news20.binary) that is meant to demonstrate the scalability of the
GREEDY core-set algorithm.\footnote{Both datasets can be
found at:
www.csie.ntu.edu.tw/cjlin/libsvmtools/datasets/multiclass.html.}

Finally, we are also interested in the effect of column selection as a
preprocessing step for supervised learning methods. To that end, we will train
a linear SVM model, using the LIBLINEAR library \citep{fan2008}, with the
subselected columns (features) and measure the effectiveness of the model on a
held out test set. For both datasets we report test error for the best
choice of regularization parameter .
We run GREEDY++ and \distgreedy\ with 
marginal gain evaluations per iteration and the distributed
algorithm uses  machines with each machine
recieving  columns.


\subsection{Small scale dataset (mnist)}
We first consider the MNIST digit recognition task, which is a
ten-class classification problem. There are  = 784 input features
(columns) that represent pixel values from the -pixel
images. We use  = 60,000 instances to train with and 10,000 instances
for our test set.

From Figure~\ref{fig} we see that all column sampling methods, apart
from Random, select columns that approximately provide the same amount
of reconstruction and are able to reach within 1\% of the performance
of PCA after sampling 300 columns. We also see a very similar trend
with respect to classification accuracy. It is notable that, in
practice, the core-set version of GREEDY incurs almost no additional
error (apart from at the smallest values of ) when compared to the
standard GREEDY algorithm.

Finally, we also show the relative speed up of the competitive methods
over the standard GREEDY algorithm. In this small dataset regime, we
see that the core-set algorithm does not offer an improvement over the single
machine GREEDY++ and in fact the 2-Phase algorithm is the fastest.
This is primarily due to the overhead of the distributed core-set
algorithm and the fact that it requires two greedy selection stages
(e.g.\ map and reduce). Next, we will consider a dataset that is large enough that a distributed model is in fact necessary. 

\subsection{Large scale dataset (news20.binary)}

\begin{table}
\begin{small}
\begin{center}
  \begin{tabular}{|c|c|c|c|c|}
    \hline
    \bf n & \bf Rand & \bf 2-Phase & \bf  &  \bf PCA \\
    \hline
\hline
    500 & 54.9 & 81.8 (1.0) & 80.2 (72.3) & 85.8 (1.3) \\
    \hline
    1000 & 59.2 & 84.4 (1.0) & 82.9 (16.4) & 88.6 (1.4)\\
    \hline
    2500 & 67.6 & 87.9 (1.0) & 85.5 (2.4) & 90.6 (1.7) \\
    \hline
\end{tabular}
\end{center}
\vspace{-0.1cm}
\end{small}
  \caption{A comparison of the classification accuracy of selected features. Also, the relative speedup over the 2-Phase algorithm for selecting features is shown in parentheses.
\vspace{-0.4cm}
  }
\label{table}
\end{table}

In this section, we show that the  algorithm can indeed
scale to a dataset with a large number of columns.
The news20.binary dataset is a binary class text classification
problem, where we start with  = 100,000 sparse features (0.033\%
non-zero entries) that represent text trigrams, use  = 14,996
examples to train with and hold-out 5,000 examples to test with.

We compare the classification accuracy and column selection runtime of
the naive random method, 2-Phase algorithm
as well as PCA (that serves as an upper bound on performance)
to the  algorithm.
The results are presented in Table~\ref{table}, which shows that
 and 2-Phase both perform significantly better than random sampling and
come relatively close to the PCA upper bound in terms of accuracy. However,
we also find that  can be magnitudes of order faster than the 2-Phase
algorithm. This is in a large part because the 2-Phase algorithm suffers from the bottleneck of
computing a top- SVD. We note that an approximate SVD method
could be used instead,
however, it was outside the scope of this preliminary empirical investigation.

In conclusion, we have demonstrated that \distgreedy\ is able to scale to
larger sized datasets while still selecting effective features.




\bibliographystyle{icml2016}
\bibliography{icml_main}

\clearpage
\appendix


\section{Appendix}

\subsection{Proof of Lemma~\ref{lem:opt-ns}}\label{app:opt-ns}
\begin{proof}
Let us fix some machine . The main observation is that running greedy with  is the same as running it with  (because by definition, the added elements are not chosen).  Applying Theorem~\ref{thm:greedy-main}\footnote{To be precise, Theorem~\ref{thm:greedy-main} is presented as comparing against the optimum set of  columns. However, an identical argument (simply stop at the last line in the proof of Theorem~\ref{thm:greedy-main}) shows the same bounds for any (potentially non-optimal) set of  columns. This is the version we use here.} with  and , we have that for
,
then . Now since  is a subset of , we have that  is of size at most , and also . Thus the above bound certainly holds whenever .
\end{proof}

\subsection{Proof of Lemma~\ref{lem:additivity}} \label{app:additivity}

\begin{proof} [Lemma~\ref{lem:additivity}]
As before, we will first prove the inequality for one column  instead of , and adding over the columns gives the result. Suppose , and let us abuse notation slightly, and use  to also denote subsets of indices that they correspond to. Now, by the definition of , there exists an , such that , and .

Let us write , where . Then,

Now, we have

from the definition of , and we clearly have , as  is a subset. Using the same argument with , we have

Now, since , the definition of  gives us that , thus completing the proof.
\end{proof}





\subsection{Tight example for the bound in Theorem~\ref{thm:greedy-main}} \label{app:tight-ex}

We show an example in which we have a collection of (nearly unit)
vectors such that:
\enum{
\item Two of them can exactly represent a target vector
 (i.e., ). 
\item The  of the matrix with these two vectors as
columns is , for some parameter .
\item The greedy algorithm, to achieve an error  in
the squared-length norm, will require at least  steps.
}

The example also shows that using the greedy algorithm, we cannot
expect to obtain a multiplicative guarantee on the {\em error}. In the
example, the optimal error is zero, but as long as the full set of
vectors is not picked, the error of the algorithm will be non-zero.

\paragraph{The construction.} 
Suppose  are orthogonal vectors.  The vectors in
our collection are the following: , , and
, for . Thus we have  vectors. The
target vector  is .  Clearly we can write  as a linear
combination of the first two vectors in our collection.

Let us now see what the greedy algorithm does. In the first step, it
picks the vector that has maximum squared-inner product with .
This will be  (breaking ties arbitrarily). We claim
inductively that the algorithm never picks the first two vectors of
our collection. This is clear because  are all
orthogonal, and the first two vectors have a strictly smaller
component along , which is what matters for the greedy choice (it
is an easy calculation to make this argument formal).

Thus after  iterations, we will have picked .  Let us call them
 resp. Now, what is the unit vector in the span
of these vectors that has the largest squared dot-product with ?

It is a simple calculation to find the best linear combination of the
 -- all the coefficients need to be equal. Thus the best unit
vector is a normalized version of , which is


For this , to have , we must have 

which simplifies (for ) to , or .


\subsection{Proof of Theorem~\ref{thm-lazier-than-lazy:main}} \label{app:thm-lazier-than-lazy}
The key ingredient in our argument is that in every iteration, we obtain large marginal gain in expectation. This is formally stated in the following lemma.

\begin{lemma} \label{lem:large-gain-lazier-than-lazy}
Let  be two sets of columns from , with . Let , and let  be a size  subset drawn uniformly at random from the columns of .  Then the expected gain in an iteration of  is at least .
\end{lemma}

\begin{proof}[Proof of Lemma~\ref{lem:large-gain-lazier-than-lazy}]
The first part of the proof is nearly identical to the proof of Lemma 2 in \cite{Mirzasoleiman}. We repeat the details here for the sake of completeness.

Intuitively, we would like the random sample  to include vectors we have not seen in . In order to lower bound the probability that , we first upper bound the probability that .

where we have used the fact that  for . Recalling that , we have:

The next part of the proof relies on techniques developed in the proof of Theorem 1 in \cite{Mirzasoleiman}. For notational convenience, define  to be the marginal gain of adding  to . Using the above calculations, we may lower bound the expected gain  in an iteration of  as follows:

Equation \eqref{Stochastic greedy lemma eq 3} is due to conditioning on the event that , and lower bounding the probability that this happens with Equation \eqref{Stochastic greedy lemma eq 2}. Equation \eqref{Stochastic greedy lemma eq 5} is due to the fact each element of  is equally likely to be in , since  is chosen uniformly at random. Equation \eqref{Stochastic greedy lemma eq 6} is a direct application of equation \eqref{eq:temp8} because .
\end{proof}

We are now ready to prove Theorem~\ref{thm-lazier-than-lazy:main}. The proof technique is similar to that of Theorem~\ref{thm:greedy-main}.
\begin{proof}[Proof of Theorem~\ref{thm-lazier-than-lazy:main}]
For each , let  denote the set of  columns output by . We adopt the same notation for  as in the proof of Theorem \ref{thm:greedy-main}. We also use a similar construction of  except that we stop when .

We first demonstrate that it takes at most  iterations to reduce the gap from  to  in expectation. To prove this, we invoke Lemma \ref{lem:large-gain-lazier-than-lazy} on each  to see that the expected gap filled by  iterations is lower bounded by . Thus the total number of iterations  required to decrease the gap to at most  in expectation is:

where equation \eqref{Stochastic greedy theorem eq 3} is because  and . Therefore, after  iterations, we have that:

because . Rearranging proves the theorem.
\end{proof}

\subsection{Random Projections to reduce the number of rows} \label{app:random-projections}
Suppose we have a set of vectors  in
, and let  be given accuracy parameters. For an integer , we say that a vector  is in the -span of  if we can write , with at most  of the  non-zero. Our main result of this section is the following.

\begin{thm} \label{thm:random-projections}
Let  be given, and set , where we use  to omit  terms.  Let  be a matrix with entries drawn independently from . Then with probability at least ,
for {\em all} vectors  that are in the -span of
, we have

\end{thm}

The proof is a standard -net argument that is similar to the proof of Lemma 10 in \cite{Sarlos}. Before giving the proof, we first state the celebrated lemma of Johnson and Lindenstrauss.
\begin{thm}\label{thm:jl-classic}\cite{Johnson}
Let , and suppose  be a matrix with entries drawn independently from .  Then for any , we have 
\end{thm}

Now we prove Theorem ~\ref{thm:random-projections}.
\begin{proof}[Proof of Theorem ~\ref{thm:random-projections}]
The proof is a simple `net' argument for unit vectors in the -span
of .  The details are as follows.

First note that since the statement is scaling invariant, it suffices
to prove it for {\em unit} vectors  in the -span. Next, note
that it suffices to prove it for vectors in a -net for the
unit vectors in the -span, for a small enough . To recall,
a -net for a set of vectors  is a finite set subset
 with the property that for all , there exists a
 such that .

Suppose we fix some -net for the set of unit vectors in the
-span of , and suppose we show that for all , we have

Now consider any  in the -span. By definition, we can write , where  and .  Thus we
have

where  is the spectral norm of .  From now, let us set
.  Now, whenever
,
equation~\eqref{eq:eps-net-bound} implies


The proof follows from showing the following two statements: (a) there
exists a net  (for the above choice of ) such
that Eq.~\eqref{eq:eps-net-needed} holds for all 
with probability , and (b) we have  w.p. at least .

Once we have (a) and (b), the discussion above completes the proof. We
also note that (b) follows from the concentration inequalities on the
largest singular value of random matrices \cite{Rudelson}. Thus it only remains to prove (a).

For this, we use the well known result that every
-dimensional space, the set of unit vectors in the space has a
-net (in  norm, as above) of size at most
 \cite{Vershynin}. In our setting, there are 
such spaces we need to consider (i.e., the span of every possible
-subset of ).  Thus there exists a -net
for the unit vectors in the -span, which has a size at most

where we used the crude bound .

Now Theorem~\ref{thm:jl-classic} implies that for any (given)  (replacing  by  and noting ), that


Thus by a union bound, the above holds for all 
with probability at least .
For our choice of , it is easy to verify that this quantity is at
least .  This completes the proof of the theorem.
\end{proof}

\subsection{Efficient Calculation of Marginal Gain}\label{sec:app:marginal}
A naive implementation of calculating the marginal gain  takes  floating-point operations (FLOPs) where . The first term is from performing the Grahm-Schmidt orthonormalization of , and the second term is from calculating the projection of each of 's columns onto span.

However, it is possible to significantly reduce the marginal gain calculations to  FLOPs in  by introducing  updates, each of which takes  FLOPs. This idea was originally proven correct by \cite{Farahat2}, but we discuss it here for completeness.

The simple yet critical observation is that  permanently keeps a column  once it selects it. So when we select , we immediately update all columns of  and  by removing their projections onto . This allows us to calculate marginal gains in future iterations without having to consider  again.


\subsection{Proof of Theorem~\ref{thm:core-set-2}} \label{app:core-set-2}
\begin{proof}
  Let  be the union of first  solutions: . The main observation is that to compute , we can think of first subtracting off the components of the columns of  along  to obtain , and simply computing . Now, a calculation identical to the one in Eq.~\eqref{eq:dotprod-lb2} followed by the ones in Eq.~\eqref{eq:start}-\eqref{eq:temp8} (to go from one vector to the matrix) implies that .  Now we can complete the proof as (Theorem~\ref{thm:greedy-main}).
\iffalse
For any , we use  as the benchmark, and note that . On the other hand,  is equal to . So there is a gap of at least  to be exploited.  
Using Theorem~\ref{thm:core-set-1}, we know that in epoch  we find a set  with expected  at least . This can be rewritten as: 

 

where  is . By monotonicity of  and induction, we can prove that  is at least  which completes the proof. 
\fi
\end{proof}

\subsection{Necessity of Random Partitioning} \label{app:rand-part}
We will now make the intuition formal. We consider the  problem, in which we wish to cover the columns of  using columns of . Our lower bound holds not just for the greedy algorithm, but for any {\em local} algorithm we use -- i.e., any algorithm that is not aware of the entire matrix  and only works with the set of columns it is given and outputs a poly sized subset of them.

\begin{thm} \label{thm:rand-part}
For any square integer  and constants , there exist two matrices  and , and a partitioning of  with the following property. Consider any local, possibly randomized, algorithm that takes input  and outputs  columns .  Now pick  elements  from  to maximize . Then, we have the expected value of  (over the randomization of the algorithm) is at most .
\end{thm}

\begin{proof}
Let , for some integer .  We consider matrices with  rows.  Our target matrix  will be a single vector containing all 's.  The coordinates (rows) are divided into sets as follows: , and for ,  is the set .  Thus we have  blocks,  of size  and the rest of size .

Now, let us describe the matrix  that is sent to machine .  It consists of all possible -sized subsets of .\footnote{As described, it has an exponential in  number of columns, but there are ways to deal with this.}  Thus we have  machines, each of which gets  as above.

Let us consider what a local algorithm would output given .  Since the instance is extremely symmetric, it will simply pick  sets, such that all the elements of  are {\em covered}, i.e., the vector  restricted to these coordinates is spanned by the vectors picked. But the key is that the algorithm cannot distinguish  from ! Thus we have that any set in the cover has at most  overlap with the elements of .\footnote{To formalize this, we need to use Yao's minmax lemma and consider the uniform distribution.}

Now, we have sets  that all of which have  overlap with the corresponding .  It is now easy to see that if we select at most  sets from , we can cover at most  of the coordinates of the  coordinates in . The optimal way to span  is to pick precisely the indicator vectors for , which will cover a  fraction of the mass of .  Noting that , we have the desired result.
\iffalse
We construct the set of columns  based on  and  as follows. 
We put  rows in  one for each number in .
We set the number of machines  to be equal to .
For any size  subset , we put an indicator column  in  with  ones in entries that belong to , and zeros elsewhere. 
Finally we set  to be just one column with all its entries equal to one. The symmetry we observe in each machine makes any algorithm unable to distinguish between entries in  and entries in . Therefore in expectation every selected column will have at most  non-zero entries in . Therefore we can say with high probability each column in  has at most  non-zero entries in  since  has size at most  (polynomial in ). So in the pool of selected columns  with high probability each column has at most  non-zero entries in . So any subset of   columns among the selected columns will not cover more than  entries of the  entries of . The proof completes by observing that  fraction of entries of  are in . 
\fi
\end{proof}




\end{document} 
