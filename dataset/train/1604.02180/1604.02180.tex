
\documentclass[10pt, conference, letterpaper]{IEEEtran}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{xcolor}
\usepackage[linesnumbered,algoruled,vlined]{algorithm2e}
\usepackage{xparse} \usepackage{array,multirow}
\usepackage{mathabx} \usepackage{graphicx}
\usepackage{comment}
\usepackage{url}
\usepackage{relsize}

 \newcolumntype{F}{>{}@{\hspace{0.0em}}}
 \newcolumntype{C}{>{}@{\hspace{0.0em}}}
 \newcolumntype{B}{>{}@{\hspace{0.0em}}}
 \newcolumntype{R}{>{}@{\hspace{0.2em}}}
 \newcolumntype{S}{>{}@{\hspace{0.2em}}}
 \newcolumntype{L}{>{}@{\hspace{0.2em}}}
 \newcolumntype{Q}{>{}@{\hspace{0.3em}}}
 \newcommand{\muRow}[1]{\multirow{2}{*}{}}
 \newcommand{\muRowThree}[1]{\multirow{3}{*}{}}
 \newcommand{\muColL}[1]{\multicolumn{1}{L}{}}
 \newcommand{\muColC}[1]{\multicolumn{1}{c}{}}
 \newcommand{\muColR}[1]{\multicolumn{1}{R}{#1}}

 \newcounter{IPnumber}
 \setcounter{IPnumber}{0}
\newcommand{\tagIt}[1]{\refstepcounter{equation}\textnormal{({\theequation})} \label{#1}}
 
 
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{corollary}[theorem]{Corollary}
 
\newcommand{\ALG}{\textsc{Schain}}

\newcommand{\stefan}[1]{\textit{\textcolor{red}{[stefan]: #1}}} 

\begin{document}




\title{{\smaller[0]{Service Chain and Virtual Network Embeddings:}} \\ {\smaller[0]{Approximations using Randomized Rounding}} }


\author{
\IEEEauthorblockN{Matthias Rost}
\IEEEauthorblockA{TU Berlin, Germany \\
\texttt{mrost@inet-tu-berlin.de}}
\and
\IEEEauthorblockN{Stefan Schmid}
\IEEEauthorblockA{Aalborg University, Denmark \\
\texttt{schmiste@cs.aau.dk}}
}



\date{}



\newcommand{\TODO}[1]{\textcolor{red}{TODO: #1}}

\newcommand\numberthis{\addtocounter{equation}{1}\tag{\theequation}}

\newcommand{\NULL}{\textnormal{\texttt{NULL}}}
\newcommand{\scale}{\ensuremath{\lambda}}



\newcommand{\preals}{\ensuremath{\mathbb{R}_{\geq 0}}}



\newcommand{\requests}{\ensuremath{\mathcal{R}}}
\newcommand{\requestsP}{\ensuremath{\mathcal{R}'}}
\newcommand{\req}{r}
\newcommand{\types}{\ensuremath{\mathcal{T}}}
\newcommand{\type}{\ensuremath{\tau}}
\newcommand{\SVTypes}[1][\type]{\ensuremath{V^{#1}_{S}}}
\newcommand{\SVTypesCycle}[1][C_k]{\ensuremath{V^{#1}_{S,t}}}
\newcommand{\VG}[1][\req]{\ensuremath{G_{#1}}}
\newcommand{\VV}[1][\req]{\ensuremath{V_{#1}}}
\newcommand{\VE}[1][\req]{\ensuremath{E_{#1}}}
\newcommand{\VGbar}[1][\req]{\ensuremath{\bar{G}_{#1}}}
\newcommand{\VVbar}[1][\req]{\ensuremath{\bar{V}_{#1}}}
\newcommand{\VEbar}[1][\req]{\ensuremath{\bar{E}_{#1}}}
\newcommand{\Vstart}[1][\req]{\ensuremath{s_{#1}}}
\newcommand{\Vend}[1][\req]{\ensuremath{t_{#1}}}

\newcommand{\VGext}[1][\req]{\ensuremath{G^{\textnormal{ext}}_{#1}}}
\newcommand{\VGextFlow}[1][\req]{\ensuremath{G^{\textnormal{ext}}_{#1,f}}}
\NewDocumentCommand{\VGP}{O{\req} O{i} O{j}}{\ensuremath{G^{#2,#3}_{#1}}}
\newcommand{\VVext}[1][\req]{\ensuremath{V^{\textnormal{ext}}_{#1}}}
\newcommand{\VEext}[1][\req]{\ensuremath{E^{\textnormal{ext}}_{#1}}}
\newcommand{\VEextHorizontal}[1][\req]{\ensuremath{E^{\textnormal{ext}}_{#1,u,v}}}
\newcommand{\VEextVertical}[1][\req]{\ensuremath{E^{\textnormal{ext}}_{#1,\type,u}}}

\newcommand{\Vsource}[1][\req]{\ensuremath{o^+_{\req}}}
\newcommand{\Vsink}[1][\req]{\ensuremath{o^-_{\req}}}


\newcommand{\VMultiplicity}[1][\req]{\ensuremath{M_{#1}}}
\newcommand{\Vprofit}[1][\req]{\ensuremath{b_{#1}}}
\newcommand{\VprofitMax}{\ensuremath{b_{\max}}}

\newcommand{\Vcap}[1][\req]{\ensuremath{d_{#1}}}
\newcommand{\Vloc}[1][\req]{\ensuremath{l_{#1}}}
\newcommand{\Vtype}[1][\req]{\ensuremath{\tau_{#1}}}



\newcommand{\SG}{\ensuremath{G_S}}
\newcommand{\SR}{\ensuremath{R_{S}}}
\newcommand{\SRV}{\ensuremath{R^V_{S}}}
\newcommand{\SV}{\ensuremath{V_S}}
\newcommand{\SE}{\ensuremath{E_S}}

\newcommand{\Scap}{\ensuremath{d_{S}}}
\newcommand{\ScapType}[1][\type]{\ensuremath{d^{#1}_{\SV}}}
\newcommand{\ScapTypePrime}[1][\type]{\ensuremath{{{d'}^{#1}_{\SV}}}}

\newcommand{\Scost}{\ensuremath{c_{S}}}
\newcommand{\ScostType}[1][\type]{\ensuremath{c^{#1}_{\SV}}}



\newcommand{\map}[1][\req]{\ensuremath{m_{#1}}}
\newcommand{\mapV}[1][\req]{\ensuremath{m^V_{#1}}}
\newcommand{\mapE}[1][\req]{\ensuremath{m^E_{#1}}}

\newcommand{\FeasibleLP}{\ensuremath{\mathcal{F}_{\textnormal{LP}}}}
\newcommand{\FeasibleIP}{\ensuremath{\mathcal{F}_{\textnormal{IP}}}}





\makeatletter
\newcommand{\removelatexerror}{\let\@latex@error\@gobble}
\makeatother


\newcounter{ipCounter}
\NewDocumentEnvironment{IPFormulation}{m}{\refstepcounter{ipCounter}
\begin{algorithm}[#1]\renewcommand\thealgocf{\arabic{ipCounter}}
}{\end{algorithm}
\addtocounter{algocf}{-1}
}

\NewDocumentEnvironment{IPFormulationStar}{m}{\refstepcounter{ipCounter}
\begin{algorithm*}[#1]\renewcommand\thealgocf{\arabic{ipCounter}}
}{\end{algorithm*}
\addtocounter{algocf}{-1}
}
	







\newcommand{\spaceSolReq}[1][\req]{\ensuremath{\mathcal{M}_{#1}}}
\newcommand{\spaceLP}{\ensuremath{\mathcal{F}^{\textnormal{mcf}}_{\textnormal{LP}}}}
\newcommand{\spaceIP}{\ensuremath{\mathcal{F}^{\textnormal{mcf}}_{\textnormal{IP}}}}
\newcommand{\spaceLPNew}{\ensuremath{\mathcal{F}^{\textnormal{new}}_{\textnormal{LP}}}}
\newcommand{\spaceLPD}{\ensuremath{\mathcal{F}^{\mathcal{D}}_{\textnormal{LP}}}}
\newcommand{\spaceLPDreq}[1][\req]{\ensuremath{\mathcal{F}^{\mathcal{D}}_{\textnormal{LP},#1}}}

\DeclareDocumentCommand{\OptProfit}{}{\ensuremath{\hat{P}}}




\DeclareDocumentCommand{\NodeG}{O{\req} O{\pi}}{\ensuremath{G^N_{#1,#2}}}
\DeclareDocumentCommand{\NodeV}{O{\req} O{\pi}}{\ensuremath{V^N_{#1,#2}}}
\DeclareDocumentCommand{\NodeE}{O{\req} O{\pi}}{\ensuremath{E^N_{#1,#2}}}


\DeclareDocumentCommand{\EdgeG}{O{\req} O{i} O{j} O{u}}{\ensuremath{G^E_{#1,#2,#3,#4}}}
\DeclareDocumentCommand{\EdgeV}{O{\req} O{i} O{j} O{u}}{\ensuremath{V^E_{#1,#2,#3,#4}}}
\DeclareDocumentCommand{\EdgeE}{O{\req} O{i} O{j} O{u}}{\ensuremath{E^E_{#1,#2,#3,#4}}}

\DeclareDocumentCommand{\VESD}{O{\req}}{\ensuremath{\overrightarrow{E}_{#1}}}
\DeclareDocumentCommand{\VEOD}{O{\req}}{\ensuremath{\overleftarrow{E}_{#1}}}
\DeclareDocumentCommand{\VESigmaD}{O{\req} O{\sigma}}{\ensuremath{E_{#1,#2}}}


\DeclareDocumentCommand{\NodeVRange}{O{\req} O{i} O{j}}{\ensuremath{V^N_{#1,#2,#3}}}
\DeclareDocumentCommand{\NodeVRangeRange}{O{\req} O{i} O{j} O{u} O{v}}{\ensuremath{V^N_{#1,#2,#3,#4,#5}}}

\DeclareDocumentCommand{\path}{O{\req} O{k }}{\ensuremath{P_{#1,#2}}}

\DeclareDocumentCommand{\NodePaths}{O{\req}}{\ensuremath{\mathcal{P}_{#1}}}



\DeclareDocumentCommand{\loadV}{O{\req} O{u}}{\ensuremath{l_{#1,#2}}}
\DeclareDocumentCommand{\loadE}{O{\req} O{u} O{v}}{\ensuremath{l_{#1,#2,#3}}}
\DeclareDocumentCommand{\loadX}{O{\req} O{x}}{\ensuremath{l_{#1,#2}}}
\DeclareDocumentCommand{\decomp}{O{\req} O{k}}{\ensuremath{D_{#1}^{#2}}}
\DeclareDocumentCommand{\decompHat}{O{\req} O{k}}{\ensuremath{{\hat{D}}_{#1}^{#2}}}
\DeclareDocumentCommand{\load}{O{\req} O{k}}{\ensuremath{l_{#1}^{#2}}}
\DeclareDocumentCommand{\prob}{O{\req} O{k}}{\ensuremath{f_{#1}^{#2}}}
\DeclareDocumentCommand{\mapping}{O{\req} O{k}}{\ensuremath{m_{#1}^{#2}}}

\DeclareDocumentCommand{\loadHat}{O{\req} O{k}}{\ensuremath{\hat{l}_{#1}^{#2}}}
\DeclareDocumentCommand{\probHat}{O{\req} O{k}}{\ensuremath{\hat{f}_{#1}^{#2}}}
\DeclareDocumentCommand{\mappingHat}{O{\req} O{k}}{\ensuremath{\hat{m}_{#1}^{#2}}}

\DeclareDocumentCommand{\loadHat}{O{\req} O{k}}{\ensuremath{\hat{l}_{#1}^{#2}}}
\DeclareDocumentCommand{\probHat}{O{\req} O{k}}{\ensuremath{\hat{f}_{#1}^{#2}}}
\DeclareDocumentCommand{\mappingHat}{O{\req} O{k}}{\ensuremath{\hat{m}_{#1}^{#2}}}


\DeclareDocumentCommand{\Exp}{}{\ensuremath{\mathbb{E}}}
\DeclareDocumentCommand{\randVarX}{O{\req} O{k}}{\ensuremath{X_{#1}^{#2}}}
\DeclareDocumentCommand{\randVarY}{O{\req}}{\ensuremath{Y_{#1}}}
\DeclareDocumentCommand{\randVarZ}{O{\req}}{\ensuremath{Z_{#1}}}
\DeclareDocumentCommand{\randVarL}{O{x}}{\ensuremath{L_{x}}}
\DeclareDocumentCommand{\randVarLX}{O{\req} O{x} O{y}}{\ensuremath{L_{#1,#2,#3}}}
\DeclareDocumentCommand{\randVarLNode}{O{\req} O{\type} O{u}}{\ensuremath{L_{#1,#2,#3}}}
\DeclareDocumentCommand{\randVarLEdge}{O{\req} O{u} O{v}}{\ensuremath{L_{#1,#2,#3}}}
\DeclareDocumentCommand{\randVarM}{O{\req}}{\ensuremath{M_{#1}}}
\DeclareDocumentCommand{\randVarC}{O{\req}}{\ensuremath{C_{#1}}}

\DeclareDocumentCommand{\ProbVarX}{O{1}}{\ensuremath{\mathbb{P}(\randVarX = #1)}}
\DeclareDocumentCommand{\ProbVarY}{O{1}}{\ensuremath{\mathbb{P}(\randVarY = #1)}}
\DeclareDocumentCommand{\ProbVarZ}{O{1}}{\ensuremath{\mathbb{P}(\randVarZ = #1)}}
\DeclareDocumentCommand{\ProbVarL}{O{1}}{\ensuremath{\mathbb{P}(\randVarL = #1)}}
\DeclareDocumentCommand{\ProbVarM}{O{1}}{\ensuremath{\mathbb{P}(\randVarM = #1)}}
\DeclareDocumentCommand{\ProbVarC}{O{1}}{\ensuremath{\mathbb{P}(\randVarC = #1)}}

\DeclareDocumentCommand{\randVarObjApprox}{}{\ensuremath{Obj_{\textnormal{Alg}}}}
\DeclareDocumentCommand{\optLP}{}{\ensuremath{\textnormal{Opt}_{\textnormal{LP}}}}
\DeclareDocumentCommand{\optLPstd}{}{\ensuremath{\textnormal{Opt}^{\textnormal{mcf}}_{\textnormal{LP}}}}
\DeclareDocumentCommand{\optLPnew}{}{\ensuremath{\textnormal{Opt}^{\textnormal{new}}_{\textnormal{LP}}}}
\DeclareDocumentCommand{\optIP}{}{\ensuremath{\textnormal{Opt}_{\textnormal{IP}}}}

\DeclareDocumentCommand{\WAC}{O{\req}}{\ensuremath{\textnormal{WC}_{\req}}}





\DeclareDocumentCommand{\PotEmbeddings}{O{\req}}{\ensuremath{\mathcal{D}_{#1}}}
\DeclareDocumentCommand{\PotEmbeddingsHat}{O{\req}}{\ensuremath{\hat{\mathcal{D}}_{#1}}}




\DeclareDocumentCommand{\maxLoadX}{O{x}}{\ensuremath{\textnormal{max}^{L,\sum}_{#1}}}
\DeclareDocumentCommand{\maxLoadV}{O{\req} O{\type} O{u}}{\ensuremath{\textnormal{max}^{L}_{#1,#2,#3}}}
\DeclareDocumentCommand{\maxLoadE}{O{\req} O{u} O{v}}{\ensuremath{\textnormal{max}^{L}_{#1,#2,#3}}}
\DeclareDocumentCommand{\maxLoadVSum}{O{\req} O{\type} O{u}}{\ensuremath{\textnormal{max}^{L,\sum}_{#1,#2,#3}}}
\DeclareDocumentCommand{\maxLoadESum}{O{u} O{v}}{\ensuremath{\textnormal{max}^{L,\sum}_{#1,#2}}}

\DeclareDocumentCommand{\DeltaV}{}{\ensuremath{\Delta_V}}
\DeclareDocumentCommand{\DeltaE}{}{\ensuremath{\Delta_E}}




\DeclareDocumentCommand{\VVroot}{O{\req}}{\ensuremath{r_{#1}}}
\DeclareDocumentCommand{\VVpred}{O{\req}}{\ensuremath{\pi_{#1}}}

\newcommand{\VGbfs}[1][\req]{\ensuremath{G^{\textnormal{bfs}}_{#1}}}
\newcommand{\VVbfs}[1][\req]{\ensuremath{V^{\textnormal{bfs}}_{#1}}}
\newcommand{\VEbfs}[1][\req]{\ensuremath{E^{\textnormal{bfs}}_{#1}}}


\DeclareDocumentCommand{\Cycles}{O{\req}}{\ensuremath{\mathcal{C}_{#1}}}
\DeclareDocumentCommand{\Paths}{O{\req}}{\ensuremath{\mathcal{P}_{#1}}}


\DeclareDocumentCommand{\VVcycleSource}{O{\req} O{k}}{\ensuremath{s^{C_{#2}}_{#1}}}
\DeclareDocumentCommand{\VVcycleTarget}{O{\req} O{k}}{\ensuremath{t^{C_{#2}}_{#1}}}
\DeclareDocumentCommand{\VVpathSource}{O{\req} O{k}}{\ensuremath{s^{P_{#2}}_{#1}}}
\DeclareDocumentCommand{\VVpathTarget}{O{\req} O{k}}{\ensuremath{t^{P_{#2}}_{#1}}}


\DeclareDocumentCommand{\VGcycle}{O{\req} O{k}}{\ensuremath{G^{C_{#2}}_{#1}}}
\DeclareDocumentCommand{\VVcycle}{O{\req} O{k}}{\ensuremath{V^{C_{#2}}_{#1}}}
\DeclareDocumentCommand{\VEcycle}{O{\req} O{k}}{\ensuremath{E^{C_{#2}}_{#1}}}
\DeclareDocumentCommand{\VEcycleSame}{O{\req} O{k}}{\ensuremath{\overrightarrow{E}^{C_{#2}}_{#1}}}
\DeclareDocumentCommand{\VEcycleDiff}{O{\req} O{k}}{\ensuremath{\overleftarrow{E}^{C_{#2}}_{#1}}}

\DeclareDocumentCommand{\VGpath}{O{\req} O{k}}{\ensuremath{G^{P_{#2}}_{#1}}}
\DeclareDocumentCommand{\VVpath}{O{\req} O{k}}{\ensuremath{V^{P_{#2}}_{#1}}}
\DeclareDocumentCommand{\VEpath}{O{\req} O{k}}{\ensuremath{E^{P_{#2}}_{#1}}}
\DeclareDocumentCommand{\VEpathSame}{O{\req} O{k}}{\ensuremath{\overrightarrow{E}^{P_{#2}}_{#1}}}
\DeclareDocumentCommand{\VEpathDiff}{O{\req} O{k}}{\ensuremath{\overleftarrow{E}^{P_{#2}}_{#1}}}

\DeclareDocumentCommand{\VEDiff}{O{\req}}{\ensuremath{\overleftarrow{E}^{\textnormal{bfs}}_{#1}}}

\DeclareDocumentCommand{\VEcycles}{O{\req}}{\ensuremath{E^{\mathcal{C}}_{#1}}}
\DeclareDocumentCommand{\VEpaths}{O{\req}}{\ensuremath{E^{\mathcal{P}}_{#1}}}

\DeclareDocumentCommand{\VVcycleSourcesTargets}{O{\req}}{\ensuremath{V^{\mathcal{C},\pm}_{#1}}}
\DeclareDocumentCommand{\VVpathSourcesTargets}{O{\req}}{\ensuremath{V^{\mathcal{P},\pm}_{#1}}}
\DeclareDocumentCommand{\VVSourcesTargets}{O{\req}}{\ensuremath{V^{\pm}_{#1}}}



\DeclareDocumentCommand{\VVcycleSources}{O{\req}}{\ensuremath{V^{\mathcal{C},+}_{#1}}}
\DeclareDocumentCommand{\VVpathSources}{O{\req}}{\ensuremath{V^{\mathcal{P},+}_{#1}}}


\DeclareDocumentCommand{\VVcycleTargets}{O{\req}}{\ensuremath{V^{\mathcal{C},-}_{#1}}}
\DeclareDocumentCommand{\VVpathTargets}{O{\req}}{\ensuremath{V^{\mathcal{P},-}_{#1}}}

\DeclareDocumentCommand{\VEcycleBranchR}{O{\req} O{k}}{\ensuremath{B^{C_{#2}}_{#1,1}}}
\DeclareDocumentCommand{\VEcycleBranchL}{O{\req} O{k}}{\ensuremath{B^{C_{#2}}_{#1,2}}}

\DeclareDocumentCommand{\VGdecomp}{O{\req} O{k}}{\ensuremath{G^{\mathcal{D}}_{#1}}}
\DeclareDocumentCommand{\VVdecomp}{O{\req} O{k}}{\ensuremath{V^{\mathcal{D}}_{#1}}}
\DeclareDocumentCommand{\VEdecomp}{O{\req} O{k}}{\ensuremath{E^{\mathcal{D}}_{#1}}}


\DeclareDocumentCommand{\VVbranching}{O{\req} }{\ensuremath{\mathcal{B}_{#1}}}
\DeclareDocumentCommand{\VVbranchingcycle}{O{\req} O{k}}{\ensuremath{\mathcal{B}^{C_{#2}}_{#1}}}
\DeclareDocumentCommand{\VVbranchingpath}{O{\req} O{k}}{\ensuremath{\mathcal{B}^{P_{k}}_{#1}}}
\DeclareDocumentCommand{\VVjoin}{O{\req} }{\ensuremath{\mathcal{J}_{#1}}}
\DeclareDocumentCommand{\VVaggregation}{O{\req} }{\ensuremath{\mathcal{A}_{#1}}}


\DeclareDocumentCommand{\VGextcycle}{O{\req} O{k}}{\ensuremath{G^{C_{#2}}_{#1,\textnormal{ext}}}}

\DeclareDocumentCommand{\VVextcycle}{O{\req} O{k}}{\ensuremath{V^{C_{#2}}_{#1,\textnormal{ext}}}}
\DeclareDocumentCommand{\VVextcycleSources}{O{\req} O{k}}{\ensuremath{V^{C_{#2}}_{#1,+}}}
\DeclareDocumentCommand{\VVextcycleTargets}{O{\req} O{k}}{\ensuremath{V^{C_{#2}}_{#1,-}}}
\DeclareDocumentCommand{\VVextcycleSubstrate}{O{\req} O{k}}{\ensuremath{V^{C_{#2}}_{#1,S}}}

\DeclareDocumentCommand{\VEextcycle}{O{\req} O{k}}{\ensuremath{E^{C_{#2}}_{#1,\textnormal{ext}}}}
\DeclareDocumentCommand{\VEextcycleSources}{O{\req} O{k}}{\ensuremath{E^{C_{#2}}_{#1,+}}}
\DeclareDocumentCommand{\VEextcycleTargets}{O{\req} O{k}}{\ensuremath{E^{C_{#2}}_{#1,-}}}
\DeclareDocumentCommand{\VEextcycleSubstrate}{O{\req} O{k}}{\ensuremath{E^{C_{#2}}_{#1,S}}}
\DeclareDocumentCommand{\VEextcycleF}{O{\req} O{k}}{\ensuremath{E^{C_{#2}}_{#1,F}}}

\DeclareDocumentCommand{\VGextpath}{O{\req} O{k}}{\ensuremath{G^{P_{#2}}_{#1,\textnormal{ext}}}}

\DeclareDocumentCommand{\VVextpath}{O{\req} O{k}}{\ensuremath{V^{P_{#2}}_{#1,\textnormal{ext}}}}
\DeclareDocumentCommand{\VVextpathSources}{O{\req} O{k}}{\ensuremath{V^{P_{#2}}_{#1,+}}}
\DeclareDocumentCommand{\VVextpathTargets}{O{\req} O{k}}{\ensuremath{V^{P_{#2}}_{#1,-}}}
\DeclareDocumentCommand{\VVextpathSubstrate}{O{\req} O{k}}{\ensuremath{V^{P_{#2}}_{#1,S}}}

\DeclareDocumentCommand{\VEextpath}{O{\req} O{k}}{\ensuremath{E^{P_{#2}}_{#1,\textnormal{ext}}}}
\DeclareDocumentCommand{\VEextpathSources}{O{\req} O{k}}{\ensuremath{E^{P_{#2}}_{#1,+}}}
\DeclareDocumentCommand{\VEextpathTargets}{O{\req} O{k}}{\ensuremath{E^{P_{#2}}_{#1,-}}}
\DeclareDocumentCommand{\VEextpathSubstrate}{O{\req} O{k}}{\ensuremath{E^{P_{#2}}_{#1,S}}}
\DeclareDocumentCommand{\VEextpathF}{O{\req} O{k}}{\ensuremath{E^{P_{#2}}_{#1,F}}}





\DeclareDocumentCommand{\varFlowInput}{O{\req} O{i} O{u}}{\ensuremath{f^+_{#1,#2,#3}}}
\DeclareDocumentCommand{\varFlowOutput}{O{\req} O{i} O{u}}{\ensuremath{f^+_{#1,#2,#3}}}

\DeclareDocumentCommand{\VEextcycleHorizontal}{O{\req} O{k} O{u} O{v}}{\ensuremath{E^{C_{#2}}_{#1,\textnormal{ext},#3,#4}}}
\DeclareDocumentCommand{\VEextpathHorizontal}{O{\req} O{k} O{u} O{v}}{\ensuremath{E^{P_{#2}}_{#1,\textnormal{ext},#3,#4}}}
\DeclareDocumentCommand{\VEextcycleVertical}{O{\req} O{k} O{\type} O{u}}{\ensuremath{E^{C_{#2}}_{#1,\textnormal{ext},#3,#4}}}
\DeclareDocumentCommand{\VEextpathVertical}{O{\req} O{k} O{\type} O{u}}{\ensuremath{E^{P_{#2}}_{#1,\textnormal{ext},#3,#4}}}

\DeclareDocumentCommand{\VEextCGHorizontal}{O{\req} O{u} O{v}}{\ensuremath{E^{\textnormal{ext,SCG}}_{#1,#2,#3}}}
\DeclareDocumentCommand{\VEextCGVertical}{O{\req} O{\type} O{u}}{\ensuremath{E^{\textnormal{ext,SCG}}_{#1,#2,#3}}}

\DeclareDocumentCommand{\VVextCGFlowNodes}{O{\req}}{\ensuremath{V^{\textnormal{ext,SCG}}_{#1,\textnormal{flow}}}}
\DeclareDocumentCommand{\VEextCGFlowEdges}{O{\req}}{\ensuremath{E^{\textnormal{ext,SCG}}_{#1,\textnormal{flow}}}}




\DeclareDocumentCommand{\Queue}{}{\ensuremath{\mathcal{Q}}}
\DeclareDocumentCommand{\QueueC}{}{\ensuremath{\mathcal{Q}_{\mathcal{C}}}}
\DeclareDocumentCommand{\QueueP}{}{\ensuremath{\mathcal{Q}_{\mathcal{P}}}}
\DeclareDocumentCommand{\UsedPaths}{}{\ensuremath{\mathcal{P}}}
\DeclareDocumentCommand{\Variables}{}{\ensuremath{\mathcal{V}}}

\DeclareDocumentCommand{\VGextcycleFlow}{O{\req} O{k}}{\ensuremath{G^{C_{#2}}_{#1,\textnormal{ext},f}}}

\DeclareDocumentCommand{\VGextcycleFlowBranchR}{O{\req} O{k}}{\ensuremath{G^{C_{#2},{B}_1}_{#1,\textnormal{ext},f}}}
\DeclareDocumentCommand{\VVextcycleFlowBranchR}{O{\req} O{k}}{\ensuremath{V^{C_{#2},{B}_1}_{#1,\textnormal{ext},f}}}
\DeclareDocumentCommand{\VEextcycleFlowBranchR}{O{\req} O{k}}{\ensuremath{E^{C_{#2},{B}_1}_{#1,\textnormal{ext},f}}}

\DeclareDocumentCommand{\VGextcycleFlowBranchL}{O{\req} O{k}}{\ensuremath{G^{C_{#2},{B}_2}_{#1,\textnormal{ext},f}}}
\DeclareDocumentCommand{\VVextcycleFlowBranchL}{O{\req} O{k}}{\ensuremath{V^{C_{#2},{B}_2}_{#1,\textnormal{ext},f}}}
\DeclareDocumentCommand{\VEextcycleFlowBranchL}{O{\req} O{k}}{\ensuremath{E^{C_{#2},{B}_2}_{#1,\textnormal{ext},f}}}

\DeclareDocumentCommand{\VGextpathFlow}{O{\req} O{k}}{\ensuremath{G^{P_{#2}}_{#1,\textnormal{ext},f}}}
\DeclareDocumentCommand{\VVextpathFlow}{O{\req} O{k}}{\ensuremath{V^{P_{#2}}_{#1,\textnormal{ext},f}}}
\DeclareDocumentCommand{\VEextpathFlow}{O{\req} O{k}}{\ensuremath{E^{P_{#2}}_{#1,\textnormal{ext},f}}}

\DeclareDocumentCommand{\VVKSource}{O{\req} O{K}}{\ensuremath{s^{K}_{#1}}}
\DeclareDocumentCommand{\VVKTarget}{O{\req} O{K}}{\ensuremath{t^{K}_{#1}}}
\DeclareDocumentCommand{\VVKSourcesTargets}{O{\req}}{\ensuremath{V^{K,\pm}_{#1}}}


 


\maketitle

\begin{comment}
\begin{abstract}
\TODO{Heavily revise that. The results hold nevertheless when only service cacti are allowed.}
In this paper we consider the Offline Virtual Network Embedding Problem~(VNEP): Given a substrate~(or host)~graph~ the task is to embed a set of request graphs~ for~ onto~ while respecting node and link capacities. We consider two problem variants:~(1)~All requests must be embedded and the overall embedding cost is to be minimized.~(2)~Embedding a request incurrs a profit and the task is to select a subset of requests to admit while maximizing the profit minus the embedding costs.

We develop a novel Linear Programming formulation for the VNEP and apply randomized rounding techniques. Within our framework, we obtain the following main results:
\begin{enumerate}
\item For the case without admission control, we obtain a bi-criteria approximation with high probability such that the costs are within a constant of the optimal and edge and node capacities might be violated by a factor of~.
\item For the case with access control, we obtain a bi-criteria approximation with high probability such that edge and node capacicities are violated at most by a factor of~ and achieving at least an~ of the optimum profit. 
\end{enumerate}
Both results hold only under the mild assumption that any feasible embedding of a request may, in total, not use more than the square of available resources of any node or edge in the substrate. We show how the above results can be improved in terms of capacity violations if requests may consume maximally a~ fraction of available resources for~.
\end{abstract}
\end{comment}

\begin{abstract}
The SDN and NFV paradigms enable novel 
network services which can be realized and embedded in a flexible
and rapid manner.
For example, SDN can be used to flexibly steer traffic
from a source to a destination through a sequence of virtualized middleboxes, 
in order to realize so-called service chains. 
The service chain embedding problem consists of
three tasks: admission control, finding suitable locations to allocate the virtualized
middleboxes and computing corresponding routing paths.
This paper considers the offline batch embedding of multiple service chains. Concretely, we consider the objectives of maximizing the profit by embedding an optimal subset of requests or minimizing the costs when all requests need to be embedded. 
Interestingly, while the service chain embedding problem
has recently received much attention, so far, only
non-polynomial time algorithms~(based on integer programming)
as well as heuristics~(which do not provide any formal guarantees)
are known. 
This paper presents the first polynomial time service chain
 approximation algorithms both for the case with admission and without admission control.
Our algorithm is based on a novel extension of the classic linear programming and randomized rounding 
technique, which may be of independent interest. 
In particular, we show that our approach can also be extended to more complex service graphs, containing cycles or sub-chains, hence also
  providing new insights into the classic virtual
  network embedding problem.
\end{abstract}

 
\section{Introduction}

Computer networks are currently undergoing a phase transition, and
especially the Software-Defined Networking~(SDN)~and
Netwok Function Virtualization~(NFV)~paradigms 
have the potential to overcome the ossification of computer
networks and to introduce interesting new flexiblities
and novel service abstractions such as service chaining.

In a nutshell, in a Software-Defined Network~(SDN), the control over the forwarding
switches in the data plane
is outsourced and consolidated to a logically centralized software in the so-called
control plane. This separation enables faster innovations, as the control plane
can evolve independently from the data plane: software often trumps hardware in terms 
of supported innovation speed.
Moreover, the logically centralized perspective introduced by SDN is natural and attractive, as
many networking tasks~(e.g., routing, spanning tree constructions)~are inherently non-local.
Indeed, a more flexible traffic engineering is considered one of the key benefits
of SDN~\cite{b4,sdx}.
Such routes are not necessarily shortest paths or destination-based,
or
not even loop-free~\cite{flowtags}.
 In particular,  
OpenFlow~\cite{OpenFlow}, the standard SDN protocol today, allows to define routing paths 
which depend on Layer-2, Layer-3 and even Layer-4 header fields. 

Network Function Virtualization~(NFV)~introduces flexibilities in terms
of function and service deployments. Today's computer networks 
rely on a large number of middleboxes~(e.g., NATs, firewalls, WAN optimizers),
typically realized using expensive hardware appliances which are cumbersome to manage.
For example, it is known that the number of middleboxes in enterprise 
networks can be of the same order of magnitude as the number
of routers ~\cite{someone}.
The virtualization of these functions renders the network management
more flexible, and allows to define and quickly deploy novel in-network services~\cite{routebricks,opennf,sosr15,modeling-middleboxes,clickos}.
Virtualized network functions can easily be instantiated 
on the most suitable
network nodes, e.g., running in a virtual machine
on a commodity x86 server.
The transition to NFV is discussed
within standardization groups such as ETSI, and we currently also
witness first
deployments, e.g., TeraStream~\cite{terastream}.

Service chaining~\cite{ewsdn14,stefano-sigc,merlin} is a particularly interesting new service model,
that combines the flexibilities from SDN and NFV.
In a nutshell, a service chain describes a sequence of
network functions which need to be traversed on the way
from a given source~ to a given destination~. 
For example, a service chain could define that
 traffic originating at the source is first steered through
an intrusion detection system
for security,
next through a traffic optimizer,
and only then is routed towards the destination.
While NFV can be used to flexibly allocate network functions,
SDN can be used to steer traffic through them.

\subsection{The Scope and Problem} 

This paper studies the problem of how to algorithmically exploit the flexibilities 
introduced by the SDN+NFV paradigm. 
We attend the service chain embedding problem, which has recently
received much attention. The problem generally consists of three tasks:
(1)~(if possible)~admission control, i.e. selecting and serving
only the most valuable requests,
(2)~the allocation of the virtualized
middleboxes at the optimal locations 
and~(3)~the computation of routing paths via them. 
Assuming that one is allowed to exert admission control, the objective is to maximize the profit, i.e., the prizes collected for embedding service chains. We also study the problem variant, in which a given set of requests must be embedded, i.e. when admission control cannot be exerted. In this variant we consider the natural objective of minimizing the cumulative allocation costs.
The service chain embedding algorithms presented
so far in the literature either have a
non-polynomial runtime~(e.g., are based on integer programming~\cite{mehraghdam2014specifying,stefano-sigc,merlin}),
do not provide any approximation guarantees~\cite{karl-chains},
or ignore important aspects of the problem (such as 
link capacity constraints~\cite{sirocco15}). 

More generally, we also attend to the current trend towards more complex service chains, 
connecting network functions not only in a linear order 
but as arbitrary graphs, i.e. as a kind of \emph{virtual network}. 

\subsection{Our Contributions}
 
This paper makes the following contributions.
We present the first polynomial time algorithms for the (offline)~service chain
embedding problem with and without admission control, which provide provable approximation guarantees.

We also initate the study of approximation algorithms 
for more general service graphs (or ``virtual networks''). In particular, 
we present polynomial time
approximation algorithms for the embedding of service 
\emph{cactus graphs}, which may contain branch sub-chains and even cycles. To this end, we develop a novel Integer Program formulation together with a novel decomposition algorithm, 
enabling the randomized rounding: we prove that known Integer Programming formulations are not applicable. 

\subsection{Technical Novelty}

Our algorithms are based on the well-established  
randomized rounding approach~\cite{Raghavan-Thompson}:
the algorithms use an exact Integer Program, 
for which however we only compute \emph{relaxed, i.e. linear, solutions}, 
in polynomial time.
Given the resulting fractional solution, an approximate
integer solution is derived using randomized rounding, 
in the usual resource augmentation model.

However, while randomized rounding has been studied
intensively and applied successfully in the context of path embeddings~\cite{Raghavan-Thompson},
to the best of our knowledge, besides our own work,
the question of how to extend this approach to service chains~(where
paths need to traverse certain flexible waypoints)~or even more
complex graphs~(such as virtual networks),  has not been explored
yet. 
Moreover, we are not aware of any extensions of the randomized rounding
approach to problems allowing for admission control. 

Indeed, the randomized rounding of more complex graph requests
and the admission control pose some interesting new challenges. 
In particular, the more general setting requires both a novel Integer Programming formulation as well as a novel decomposition approach. 
Indeed, we show that solutions obtained using the standard formulation \cite{vnep,rostSchmidFeldmann2014} may not be decomposable at all,
as the relaxed embedding solutions are \emph{not} 
a linear combination of elementary solutions. Besides the fact that the randomized rounding approach can therefore not be applied, we prove that the relaxation of our novel formulation is indeed provably stronger than the well-known formulation.

\subsection{Organization}

The remainder of this paper is organized as follows.
Section~\ref{sec:model} formally introduces our model.
Section~\ref{sec:decompo} presents the 
Integer Programs and our decomposition method.
Section~\ref{sec:randround} presents our randomized approximation algorithm for the service chain embedding problem with admission control and Section~\ref{sec:approximation-without-admission-control} extends the approximation for the case without admission control.
In Section~\ref{sec:cactus} we derive a novel Integer Program and decomposition approach for approximating service graphs, and show why classic formulations are not sufficient.
Section~\ref{sec:relwork} reviews related work and Section~\ref{sec:conclusion} concludes our work.

\section{Offline Service Chain Embedding Problem}\label{sec:model}

This paper studies the Service Chain Embedding Problem, short SCEP.
Intuitively, a service chain consists of a set of Network Functions~(NFs), 
such as a firewall or a NAT, and routes between these functions. 
We consider the offline setting, where batches of service chains
have to be embedded simultaneously. 
Concretely, we study two problem variants: (1)~SCEP-P where the task is to embed a subset of service chains to maximize the profit and (2)~SCEP-C where \emph{all} given service chains need to be embedded and the objective is to minimize the resource costs. Hence, service chain requests might be attributed with prizes and resources as e.g., link bandwidth 
or processing~(e.g., of a firewall network function)~may come at a certain cost.



\subsection{Definitions \& Formal Model}
\label{sec:problem-definitions}

Given is a substrate network~(the physical network representing
the physical resources)~which is modeled as directed network 
. We assume that the substrate network 
offers a finite set~ of different network 
functions~(NFs)~at nodes. The set of network function types may contain e.g., `FW'~(firewall), `DPI'~(deep packet inspection), etc. For each such type , we use the set  to denote the subset of substrate nodes that can host this type of 
network function. To simplify notation we introduce the set  to denote all \emph{node} resources and denote by  the set of all \emph{substrate} resources.
Accordingly, the processing capabilities of substrate nodes and the available bandwidth on substrate edges are given by the function . Hence, for each type and substrate node we use a single numerical value to describe the node's processing capability, e.g. given as the maximal throughput in Mbps. 
Additionally, we also allow to reference substrate node locations via types. To this end we introduce for each substrate node  the \emph{abstract} type , such that  and~ and  for nodes . 


The set of service chain requests is denoted by~. 
A request~ is a directed chain graph~ 
with start node~ and end node~. 
Each of these virtual nodes corresponds to a specific network function type 
which is given via the function~. We assume 
that the types of~ and~ denote specific nodes in the substrate. 
Edges of the service chain represent forwarding paths. 
Since the type for each node is well-defined, we again use consolidated 
capacities or demands~ for both edges and functions of any type. 
Note that capacities on edges may differ, as for instance, a 
function `WAN optimizier' can compress traffic. 

In the problem variant with admission control, requests~ are attributed with a 
certain profit or benefit~. On the other hand, costs are defined via . Note that this definition allows to assign different costs for using \emph{the same} network function \emph{on different substrate nodes}. This allows us to model 
scenarios where, e.g., 
a firewall~(`FW')~costs more in terms of management overhead if implemented using a particular hardware appliance, than 
if it is implemented as a virtual machine~(`VM')
on commodity hardware.

We first define the notion of valid mappings, i.e. embeddings that obey the request's function types and connection requirements:

\begin{definition}[Valid Mapping]
\label{def:valid-mapping}
A valid mapping~ of request~ is a tuple~ of 
functions. The function~ maps each virtual network functions to 
a single substrate node. The function~ maps edges between network functions onto paths in the substrate network, such that:
\begin{itemize}
\item All network functions  are mapped onto nodes that can host the particular function type. Formally,  holds for all~.
\item The edge mapping  connects the respective network functions using simple paths, i.e. 
given a virtual edge~ the embedding~ is an edge-path~ such that~ for~ and~ and~.
\end{itemize}
\end{definition}

Next we define the notion of a feasible embedding for a set of requests, i.e. an embedding that obeys the network function and edge capacities.

\begin{definition}[Feasible Embedding]
\label{def:feasible-embedding}
A feasible embedding of a subset of requests~ is given by 
valid mappings~ for~, such that network function and edge capacities are obeyed:
\begin{itemize}
\item For all types~ and nodes~ holds: 
~.\vspace{6pt}
\item For all edges~ holds: \\~.
\end{itemize}
\end{definition}

We first define the SCEP variant with admission control whose objective is to maximize the net profit (SCEP-P), i.e. the achieved profit for embedding a subset of requests.  

\begin{definition}[SCEP for Profit Maximization: SCEP-P]~\{1}
\label{eq:cost-definition}
\begin{array}{rl}
c(\map)~= & \sum_{i \in \VV} \Vcap(i)~\cdot \Scost(\Vtype(i), \mapV(i))~+ \\
          & \sum_{(i,j) \in  \VE} \Vcap(i,j)~\sum_{(u,v) \in  \mapE(i,j)} \Scost(u,v)
\end{array}
-12pt]
\label{def:scep-without-admission-control}
\begin{description}
\item[Given:] A substrate network~ and a set of requests~ as described above.
\item[Task:] Find a feasible embedding  for all requests~ of minimal cost~.
\end{description}
\end{definition}

\subsection{NP-Hardness}
\label{sec:np-hardness}

Both introduced SCEP variants are strongly NP-hard, i.e. they are hard independently of the parameters as e.g. the capacities. We prove the NP-hardness 
by establishing a connection to multi-commodity flow problems.
Concretely, we present a polynomial time reduction from the Unsplittable Flow (USF)~and the Edge-Disjoint Paths (EDP)~problems~\cite{Guruswami2003473} to the  the respective SCEP variants. Both USF and EDP are defined on a (directed)~graph  with capacities  on the edges. The task is to route a set of  commodities  with demands  for  from   to  along simple paths inside . Concretely, EDP considers the decision problem in which both the edge capacities and the demands are  and the task is to find a feasible routing. The variant of EDP asking for the maximum number of routable commodities was one of Karp's original 21 NP-complete problems and the decision variant was shown to be NP-complete even on series-parallel graphs~\cite{Nishizeki2001177}. In the USF problem, for each commodity an additional benefit , , is given and the task is to find a selection of commodities to route, such that capacities are not violated and the sum of benefits of the selected commodities is maximized. Solving the USF problem is NP-hard and proven to be hard to approximate within a factor of  for any ~\cite{Guruswami2003473}.

We will argue in the following that EDP can be reduced to SCEP-C and USF can be reduced to SCEP-P. Both reductions use the same principal idea of expressing the given commodities as requests. Hence, we first describe this construction before discussing the respective reductions. For commodities  with  a request  consisting only of the two virtual nodes  and  and the edge  is introduced. By setting  and  and  and , we can enforce that flow of request  originates at  and terminates at , hence modeling the original commodities. In both reductions presented below, we do not make use of network functions, i.e. , and accordingly we do not need to specify network function capacities.

Regarding the polynomial time reduction from EDP to SCEP-C, we simply use unitary virtual demands and substrate capacities. As this yields an equivalent formulation of EDP, which is NP-hard, \emph{finding} a feasible solution for SCEP-C is NP-hard. Hence, there cannot exist an approximation algorithm that (always)~finds a feasible solutions within polynomial time unless  or unless capacity violations are allowed. 

Regarding the reduction from USF to SCEP-P, we adopt the demands by setting  for , adopt the network capacities via  for , and setting the profits accordingly  for . It is easy to see, that any solution to this SCEP-P instance also induces a solution to the original USF instance. It follows that SCEP-P is strongly NP-hard. 


\subsection{Further Notation}

We generally denote directed graphs by~. We use~ to denote the outgoing edges of node~ with respect to~ and similarly define~ to denote the incoming edges. If the set of 
edges~ can be derived from the the context, we often omit stating~ explicitly.
When considering functions on tuples, we often omit the (implicit)~braces around a tuple and write e.g.  instead of .
Furthermore, when only some specific elements of a tuple are of importance, we write  in favor of .

\section{Decomposing Linear Solutions}\label{sec:decompo}

In this section, we lay the foundation for the approximation algorithms for both SCEP variants by introducing Integer Programming (IP)~formulations to compute optimal embeddings (see Section~\ref{sec:integer-linear-program}). Given the NP-hardness of the respective problems, solving any of the IPs to optimality is not possible within polynomial time (unless ). Hence, we consider the linear relaxations of the respective formulations instead, as these naturally represent a conical or convex combination of valid mappings.  We formally show that linear solutions can be decomposed into valid mappings in Section~\ref{sec:decomp-algorithm-synopsis}. Given the ability to decompose solutions, we apply randomized rounding techniques in Sections~\ref{sec:randround} and \ref{sec:approximation-without-admission-control} to obtain tri-criteria approximation algorithms for the respective SCEP variants.

\begin{figure}[t!]
\includegraphics[width=1\columnwidth]{line-construction.pdf}
\caption{Example for the extended graph construction (cf. Definition~\ref{def:extended-graph}).}
\label{fig:extended-graph-linear}
\end{figure}

\subsection{Integer Programming}
\label{sec:integer-linear-program}

To formulate the service chain embedding problems as Integer Programs we employ a flow formulation on a graph construction reminiscent of the one used by Merlin~\cite{merlin}. Concretely, we construct an extended and layered graph consisting of copies of the substrate network together with super sources and sinks. The underlying idea is to model the usage (and potentially the placement)~of network functions by traversing inter-layer edges while intra-layer edges will be used for connecting the respective network functions. Figure~\ref{fig:extended-graph-linear} depicts a simple example of the used graph construction. The request  consists of the three nodes , , and . Recall that we assume that the start and the end node specify locations in the substrate network (cf. Section~\ref{sec:model}). Hence, in the example the start node  and the end node  can only be mapped onto the substrate nodes  and  respectively, while the virtual node  may be placed on the substrate nodes  and . Since for each connection of network functions a copy of the substrate network is introduced, the edges between these \emph{layers} naturally represent the utilization of a network function.
Additionally, the extended graph  contains a single super source  and a super sink , such that any path from  to  represents a valid mapping of the request (cf. Discussion in Section~\ref{sec:decomp-algorithm-synopsis}). Formally, the extended graph \emph{for each request}  is introduced as follows.
\begin{definition}[Extended Graph]
\label{def:extended-graph}
Let~ be a request. The extended graph~ is defined as follows:
6pt]
 \VEext = & 
\begin{array}{l}
\{ (u^{i,j}_{\req}, v^{i,j}_{\req}) | (i,j) \in \VE, (u,v) \in \SE \} \cup \\
\{ (\Vsource,u^{\Vstart, j}_{\req}) | (\Vstart,j) \in \VE, u \in \SVTypes[\Vtype(\Vstart)] \} \cup \\
\{ (u^{i,\Vend}_{\req}, \Vsink) | (i,\Vend) \in \VE, u \in \SVTypes[\Vtype(\Vend)] \} \cup \\
 \{ (u^{i,j}_{\req}, u^{j,k}_{\req}) | (i,j), (j,k) \in \VE, u \in \SVTypes[\Vtype(j)] \}
\end{array}
10pt]
  \sum \limits_{e \in \delta^+(\Vsource)} f_{\req, e} & = & x_{\req} & \forall \req \in \requests, i \in \VV & \tagIt{alg:SCEP:FlowInduction} \\
	\sum \limits_{(u,v)\in \delta^+(u)} f_{\req, e}  & = & \hspace{-12pt} \sum \limits_{(v,u) \in \delta^-(u)} \hspace{-8pt} f_{\req, e}   &  \forall \req \in \requests, u \in \VVext \setminus \{ \Vsource, \Vsink \} & \tagIt{alg:SCEP:FlowPreservation} \\
	
	
	\sum \limits_{(e,i)\in \VEextVertical} \hspace{-16pt}\Vcap(i)\cdot f_{\req,e}  & = & l_{\req,\type,u} & \forall \req \in \requests,  (\type,u)\in \SRV & \tagIt{alg:SCEP:nodeLoad} \\
	
	\sum \limits_{	(e,i,j)\in \VEextHorizontal} \hspace{-16pt} \Vcap(i,j)\cdot f_{\req,e} & = & l_{\req,u,v} & \forall \req \in \requests, (u,v)\in \SE & \tagIt{alg:SCEP:edgeLoad} \\

\sum \limits_{\req \in \requests } l_{\req,x,y}& \leq & \Scap(x,y)& \forall (x,y)\in \SR & \tagIt{alg:SCEP:capacities} \\	

	
  x_{\req} & \in & \{0,1\} &  \forall \req \in \requests & \tagIt{alg:SCEP:embedding_variable} \\
  f_{\req,e} & \in & \{0,1\} &  \forall \req \in \requests, e \in \VEext     & \tagIt{alg:SCEP:pathVariable} \\
  l_{\req,x,y} & \geq & 0 &  \forall \req \in \requests, (x,y)\in \SR     & \tagIt{alg:SCEP:VariableLoad} \\
 \end{tabular}
 }
 \caption{SCEP-P}
 \label{alg:SCEP-IP}
 \end{IPFormulation}
 }
 
{

 \newcolumntype{F}{>{}@{\hspace{0.0em}}}
 \newcolumntype{C}{>{}@{\hspace{0.0em}}}
 \newcolumntype{B}{>{}@{\hspace{0.0em}}}
 \newcolumntype{R}{>{}@{\hspace{0.2em}}}
 \newcolumntype{S}{>{}@{\hspace{0.2em}}}
 \newcolumntype{L}{>{}@{\hspace{0.2em}}}
 \newcolumntype{Q}{>{}@{\hspace{0.3em}}}
 
 
\LinesNotNumbered
\renewcommand{\arraystretch}{1.5}

\begin{IPFormulation}{t!}

\SetAlgorithmName{Integer Program}{}{{}}

\scalebox{0.94}{

\newcommand{\spaceIt}{\qquad\quad\quad}
\newcommand{\miniSpace}{\hspace{1.5pt}}

\centering
\hspace{-32pt}
\begin{tabular}{FFCLLBB}
\multicolumn{5}{C}{\textnormal{min~}   \sum \limits_{\req \in \requests} \sum \limits_{(x,y) \in   \SR} \Scost(x,y)~\cdot l_{\req,x,y} } & ~ & \tagIt{alg:SCEPObj_without}\
\sum_{\req \in \requests} \sum_{\decomp \in \PotEmbeddings} \prob \cdot \Vprofit = \hat{B}~.

\sum_{\req \in \requests} \sum_{\decomp \in \PotEmbeddings} \prob \cdot c(\mapping)~\leq \hat{C}~.

\sum_{\req \in \requests} \sum_{D^k_{\req} \in \mathcal{D}_\req} f^k_\req \cdot l^k_{\req}(x,y)~\leq \sum_{\req \in \requests} l_{\req, x,y} \leq  \Scap(x,y)\,,
\label{eq:lem:allocations}

\label{eq:modeling-B-as-random-variables}
	B = \sum_{\req \in \requests} \randVarY ~.

	\optLP = \sum_{\req \in \requests}\sum_{\decomp \in \PotEmbeddings} \prob \cdot \Vprofit = \Exp(B)~~,

\mathbb{P} \big( X \leq (1-\varepsilon)\cdot \mathbb{E}(X)~\big)~\leq exp(-\varepsilon^2\cdot \mathbb{E}(X)/2)

\mathbb{P} \big( B' \leq (1/3)\cdot \mathbb{E}(B')~\big)~\leq exp(-2\cdot \mathbb{E}(B')/9)\,.

\mathbb{P} \big( B' \leq (1/3)\cdot \mathbb{E}(B')~\big)~\leq exp(-2/9)\,.

\mathbb{P} \big( B \leq (1/3)\cdot \mathbb{E}(B)~\big)~\leq exp(-2/9)\,.
\label{eq:probability-of-one-thirds-of-the-profit}

\frac{\optIP}{3} \leq 
\frac{\optLP}{3} = 
\frac{\Exp(B)}{3 }

\mathbb{P} \Big(\sum_i X_i - \mathbb{E}(\sum_i X_i))~\geq t\Big)~\leq exp \big(-2t^2 /~(\sum_i~(b_i - a_i)^2)\big)
{5}
\maxLoadV && = & \max_{i \in \VV: \Vtype(i)~= \type} \Vcap(i)~& & \quad \textnormal{for}~ \req \in \requests, (\type,u) \in  \SRV & \\
\maxLoadE && = & \max_{~(i,j) \in  \VE} \Vcap(i,j)~& &\quad  \textnormal{for}~ \req \in \requests,~(u,v) \in  \SE & 
{3}
\maxLoadVSum && = & \sum_{i \in \VV: \Vtype(i)~= \type} \Vcap(i)~& \quad \textnormal{for}~ \req \in \requests, \type \in \types, u \in \SV
{3}
\maxLoadV[\req][x][y] && \leq & \Scap(x,y)~& \quad \forall (x,y) \in  \SR
{3}
\mathbb{E}(L_{x,y})~&& = & \sum_{\req \in \requests} \sum_{\decomp \in \PotEmbeddings} \prob \cdot \load(x,y)~ \,.
{5}
\mathbb{E}(L_{x,y})~&& \leq & \Scap(x,y)~& \quad & \textnormal{for}~ (x,y) \in  \SRV \label{eq:load-vs-capacity}
{2}
& \mathbb{P} \Big(L_{\type,u} - \mathbb{E}(L_{\type,u})~\geq t \Big)~&&  \notag \\
& ~~~ \leq exp \Bigg(\frac{-2\cdot t^2}{\sum_{\req \in \requests}~(\maxLoadVSum)^2} \Bigg)~&& \\
& ~~~ \leq exp \Bigg(\frac{-4 \log~(|\SV|\cdot|\types|)~\cdot \DeltaV \cdot  \Scap(\type,u)^2}{\sum_{\req \in \requests}~(\Scap(\type,u)\cdot \maxLoadVSum / \maxLoadV)^2} \Bigg)~&& \numberthis \label{formula:proof:singleNodeViolation:upperCapacities}
{2}
& ~~~ = exp \Bigg(\frac{-4 \log~(|\SV|\cdot|\types|)~\sum_{\req \in \requests}~(\maxLoadVSum / \maxLoadV)^2 }{\sum_{\req \in \requests}~( \maxLoadVSum / \maxLoadV)^2} \Bigg)~&& \\
& ~~~ = exp \Bigg(\frac{-4 \log~(|\SV|\cdot|\types|)~\sum_{\req \in \requests}~(\maxLoadVSum / \maxLoadV)^2 }{\sum_{\req \in \requests}~( \maxLoadVSum / \maxLoadV)^2} \Bigg)~&& \\
& ~~~ =~(|\SV|\cdot |\types|)^{-4} && 

\maxLoadVSum \leq \Scap(\type,u)~\cdot \maxLoadVSum / \maxLoadV \label{formula:proof:singleNodeViolation:estimation}

\mathbb{P} \Big(L_{\type,u} \geq (1+\sqrt{2\cdot \log~(|\SV|\cdot|\types|)~\cdot \DeltaV})~\cdot \Scap(\type,u)~\Big)~\leq (|\SV|\cdot |\types|)^{-4}
{2}
& \mathbb{P} \Big(L_{u,v} - \mathbb{E}(L_{u,v})~\geq t \Big)~&&  \notag \\
& ~~~ \leq exp \Bigg(\frac{-2\cdot t^2}{\sum_{\req \in \requests}~(\maxLoadE \cdot |\VE|)^2} \Bigg)~&& \\
& ~~~ \leq exp \Bigg(\frac{-4 \log |\SV| \cdot \DeltaE \cdot  \Scap(u,v)^2}{\sum_{\req \in \requests} \Scap(u,v)^2\cdot|\VE|^2} \Bigg)~&& \label{formula:proof:singleEdgeViolation:upperCapacities}\\
& ~~~ \leq exp \Bigg(\frac{-4 \log |\SV| \cdot \sum_{\req \in \requests} |\VE|^2 \cdot  \Scap(u,v)^2}{\Scap(u,v)^2 \cdot \sum_{\req \in \requests} |\VE|^2} \Bigg)~&& \label{formula:proof:singleEdgeViolation:upperCapacities_2}\\
& ~~~ = exp \Bigg(\frac{-4 \log |\SV| \sum_{\req \in \requests} |\VE|^2 }{\sum_{\req \in \requests} |\VE|^2} \Bigg)~&& \\
& ~~~ = |\SV|^{-4} && 

\sum_{\req \in \requests} \WAC = \optLP~.
{5}
& \WAC ~& = & ~\sum_{\decomp \in \PotEmbeddings} \prob \cdot c(\mapping)~\label{eq:a}\\
&      & \leq & ~\sum_{\decomp \in \PotEmbeddings: c(\mapping)~> 2 \cdot \WAC} \prob \cdot c(\mapping)~\label{eq:b}\\
&      & \leq  & ~\sum_{\decomp \in \PotEmbeddings: c(\mapping)~> 2 \cdot \WAC} \prob \cdot 2\cdot \WAC \label{eq:c}\\
&      & \leq  & ~(1-\lambda_{\req})~\cdot 2 \cdot \WAC \label{eq:d}\\
&      & < & ~\WAC \label{eq:e}
{3}
\sum_{\req \in \requests} \sum_{\decompHat \in \PotEmbeddingsHat} \probHat \cdot \load(x,y)~\leq 2\cdot \Scap(x,y)
\label{eq:lem:scaling-allocations}

2\cdot \sum_{\req \in \requests} \sum_{D^k_{\req} \in \mathcal{D}_\req} f^k_\req \leq 2\cdot \Scap(x,y)
\label{eq:lem:scaling-allocations-2}

\sum_{\req \in \requests} \sum_{\decompHat \in \PotEmbeddingsHat} \probHat \cdot \load(x,y)~\leq 2\cdot \sum_{\req \in \requests} \sum_{\decomp \in \PotEmbeddings} \prob \cdot \load(x,y)
{3}
\mathbb{E}(L_{x,y})~&& = & \sum_{\req \in \requests} \sum_{\decompHat \in \PotEmbeddingsHat} \probHat \cdot \load(x,y)~ \,.
{5}
\mathbb{E}(L_{x,y})~&& \leq & 2\cdot \Scap(x,y)~& \quad & \textnormal{for}~ (x,y) \in  \SRV \label{eq:load-vs-capacity-without}
{2}
& \mathbb{P} \Big(L_{\type,u} - \mathbb{E}(L_{\type,u})~\geq t \Big)~&&  \notag \\
& ~~~ \leq exp \Bigg(\frac{-2\cdot t^2}{\sum_{\req \in \requests}~(\maxLoadVSum)^2} \Bigg)~&& \\
& ~~~ \leq exp \Bigg(\frac{-2 \log~(|\SV|\cdot|\types|)~\cdot \DeltaV \cdot  \Scap(\type,u)^2}{\sum_{\req \in \requests}~(\Scap(\type,u)\cdot \maxLoadVSum / \maxLoadV)^2} \Bigg)~&& \numberthis \label{formula:proof:singleNodeViolation:upperCapacities-without}\\
& ~~~ = exp \Bigg(\frac{-2 \log~(|\SV|\cdot|\types|)~\sum_{\req \in \requests}~(\maxLoadVSum / \maxLoadV)^2 }{\sum_{\req \in \requests}~( \maxLoadVSum / \maxLoadV)^2} \Bigg)~&& \\
& ~~~ = exp \Bigg(\frac{-2 \log~(|\SV|\cdot|\types|)~\sum_{\req \in \requests}~(\maxLoadVSum / \maxLoadV)^2 }{\sum_{\req \in \requests}~( \maxLoadVSum / \maxLoadV)^2} \Bigg)~&& \\
& ~~~ =~(|\SV|\cdot |\types|)^{-2} && 

\maxLoadVSum \leq \Scap(\type,u)~\cdot \maxLoadVSum / \maxLoadV \label{formula:proof:singleNodeViolation:estimation-without}
{6}
\VVcycleSources &=&&~ \{\VVcycleSource| C_k \in \Cycles\} &\quad&&~
\VVpathSources &=&&~ \{\VVpathSource | P_k \in \Paths\} \\
\VVcycleTargets &=&&~ \{\VVcycleTarget | C_k \in \Cycles\} 
&\quad&&~
\VVpathTargets &=&&~ \{\VVpathTarget | P_k \in \Paths\} \\
\VVcycleSourcesTargets &=&&~ \{\VVcycleSource, \VVcycleTarget | C_k \in \Cycles\} 
&\quad&&~
 \VVpathSourcesTargets &=&&~ \{\VVpathSource, \VVpathTarget | P_k \in \Paths\}
{3}
\VVSourcesTargets &= &&~ \VVcycleSourcesTargets \cup \VVpathSourcesTargets
{6}
\VEcycles &=&&~ \{ e \in \VEcycle | C_k \in \Cycles\} 
&\quad&&~
\VEpaths  &=&&~ \{e \in \VEpath | P_k \in \Paths\} \\
\VEcycleSame &=&&~ \VE \cap \VEcycle
&\quad&&~
\VEcycleDiff &=&&~ \VEcycle \setminus \VEcycleSame \\
\VEpathSame &=&&~ \VE \cap \VEpath
&\quad&&~
\VEpathDiff &=&&~ \VEpath \setminus \VEpathSame
{3}
\VEDiff &=&&~ \{\VEcycleDiff | C_k \in \Cycles\} \cup \{\VEpathDiff | P_k \in \Paths\} 
{3}
\VVbranchingcycle &=&&~ \{i \in \VVcycle | |\delta_{\VEbfs}^+(i)| > 1, i \notin \VVcycleSourcesTargets \}
{3}
\VVextpathSources & = &&~ \{ u^+_{r,i} | i = \VVpathSource, u \in \SVTypes[\Vtype(i)]\}\\
\VVextpathTargets & = &&~  \{ u^-_{r,j} | j = \VVpathTarget, u \in \SVTypes[\Vtype(j)]\} \\
\VVextpathSubstrate & = &&~ \{ u^{i,j}_{r} |~(i,j) \in  \VEpath, u \in \SV \}
{3}
\VEextpathSubstrate && = & \{~(u^{i,j}_{\req}, v^{i,j}_{\req})~|~(i,j) \in  \VEpathSame,~(u,v) \in  \SE \} \cup \\
 && & \{~(v^{i,j}_{\req}, u^{i,j}_{\req})~|~(i,j) \in  \VEpathDiff,~(u,v) \in  \SE \} \\
\VEextpathSources && = & \{~(u^+_{\req,i}, u^{i,j}_{\req})~| i = \VVpathSource,~(i,j) \in  \VEpath, u \in \SVTypes[\Vtype(i)]\} \\
\VEextpathTargets &&= &\{~(u^{i,j}_{\req}, u^-_{\req,j})~| j = \VVpathTarget,~(i,j) \in  \VEpath, u \in \SVTypes[\Vtype(j)]\}  \\
\VEextpathF && = & \{~(u^{i,j}_{\req}, u^{j,l}_{\req})~|~(i,j),~(j,l) \in  \VEpath, u \in \SVTypes[\Vtype(j)] \}
{3}
\VVextcycleSources && = &  \{ u^+_{r,i} | i = \VVcycleSource, u \in \SVTypes[\Vtype(i)]\}\\
\VVextcycleTargets && = &  \{ u^-_{r,j} | j = \VVcycleTarget, u \in \SVTypes[\Vtype(j)]\} \\
\VVextcycleSubstrate && = &  \{ u^{i,j}_{r,w} |~(i,j) \in  \VEcycle, u \in \SV, w \in \SVTypesCycle \}
{3}
\VEextcycleSubstrate && = & \{(u^{i,j}_{\req,w}, v^{i,j}_{\req,w})|(i,j)\in \VEcycleSame,(u,v)\in \SE, w \in \SVTypesCycle \} \cup \\
 && & \{(v^{i,j}_{\req,w}, u^{i,j}_{\req,w})|(i,j) \in \VEcycleDiff,(u,v)\in \SE, w \in \SVTypesCycle \} \\
\VEextcycleSources && = & \{(u^+_{\req,i}, u^{i,j}_{\req,w})| i = \VVcycleSource,(i,j)\in \VEcycle, u \in \SVTypes[\Vtype(i)]\hspace{-5pt},  w \in \SVTypesCycle \} \\
\VEextcycleTargets &&= &\{(w^{i,j}_{\req,w}, w^-_{\req,j})| j = \VVcycleTarget,(i,j) \in \VEcycle, w \in \SVTypesCycle \}  \\
\VEextcycleF && = &\{(u^{i,j}_{\req,w}, u^{j,k}_{\req,w})|(i,j),(j,k)\in \VEcycle, u \in \SVTypes[\Vtype(j)], w \in \SVTypesCycle \}
10pt]
  
  \sum \limits_{u \in \SVTypes[\Vtype(\VVroot)]} \varFlowInput[\req][\VVroot] & = & x_{\req} & \forall \req \in \requests & \tagIt{alg:SCGEP:FlowInduction-Initial} \\
  
      \sum \limits_{w \in \SVTypesCycle} f_{\req,~(u^+_{\req,i}, u^{i,j}_{\req,w})} & = & \varFlowInput[\req][i] & \forall \req \in \requests, C_k \in \Cycles, ~(i,j) \in  \VEcycleBranchR, i = \VVcycleSource, u \in \SVTypes[\Vtype(i)] & \tagIt{alg:SCGEP:FlowInduction-cycle-Right} \\
  
  f_{\req,~(u^+_{\req,i}, u^{i,j}_{\req,w})} -  f_{\req,~(u^+_{\req,i}, u^{i,j'}_{\req,w})}& = & 0 & \forall \req \in \requests, C_k \in \Cycles,~(i,j) \in  \VEcycleBranchR,~(i,j') \in  \VEcycleBranchL, i = \VVcycleSource, w \in  \SVTypesCycle & \tagIt{alg:SCGEP:FlowInduction-cycle-Left} \\
  
  f_{\req,~(u^+_{\req,i}, u^{i,j}_{\req})} & = & \varFlowInput[\req][i] & \forall \req \in \requests, P_k \in \Paths, ~(i,j) \in  \VEpath, i = \VVpathSource, u \in \SVTypes[\Vtype(i)] & \tagIt{alg:SCGEP:FlowInduction-path} \\
    
  
	\sum \limits_{e \in \delta^+(u)} f_{\req, e}  -  \sum \limits_{e \in \delta^-(u)}  f_{\req, e}& = & 0   &  \forall \req \in \requests, u \in \VVextCGFlowNodes & \tagIt{alg:SCGEP:FlowPreservation} \\
	
   f_{\req,~(w^{i,j}_{\req,w}, w^-_{\req,j})}  & = &  \varFlowInput[\req][j][w]   &  \forall \req \in \requests, C_k \in \Cycles,~(i,j) \in  \VEcycleBranchR, j = \VVcycleTarget, w \in \SVTypes[\Vtype(j)]\  & \tagIt{alg:SCGEP:setting-next-input-cycle-end} \\
   
   f_{\req,~(u^{i,j}_{\req}, u^-_{\req,j})}  & = &  \varFlowInput[\req][j][u]   &  \forall \req \in \requests, P_k \in \Paths,~(i,j) \in  \VEpath, j = \VVpathTarget, u \in \SVTypes[\Vtype(j)]\  & \tagIt{alg:SCGEP:setting-next-input-path-end} \\
   
   \sum \limits_{w\in \SVTypesCycle}  f_{\req,~(u^{i,j}_{\req,w}, u^{j,l}_{\req,w})}  & = &  \varFlowInput[\req][j][u]   &  \forall \req \in \requests, C_k \in \Cycles, j \in \VVbranchingcycle, (i,j),(j,l) \in  \VEcycle, u \in \SVTypes[\Vtype(j)]\  & \tagIt{alg:SCGEP:setting-next-input-cycle-middle} \\
	
	
	 \sum \limits_{\scriptsize
	 
	(e,i) \in  \VEextCGVertical[\req][\type]
	}  \hspace{-12pt} \Vcap(i)~\cdot f_{\req,e} + \hspace{-12pt}
	 \sum \limits_{\scriptsize
	 \begin{array}{c}
	 i \in  \VVSourcesTargets \setminus \VVbranchingcycle\\
	 \Vtype(i)~= \type
	 \end{array}
	 } \hspace{-16pt} \Vcap(i)~\cdot \varFlowInput[\req][i][u]   & = & l_{\req,\type,u} & \forall \req \in \requests, (\type,u) \in  \SRV & \tagIt{alg:SCGEP:nodeLoad} \\
	
	
	\sum \limits_{	(e,i,j) \in  \VEextCGHorizontal} \Vcap(i,j)~\cdot f_{\req,e} & = & l_{\req,u,v} & \forall \req \in \requests, (u,v) \in  \SE & \tagIt{alg:SCGEP:edgeLoad} \\
	

\sum \limits_{\req \in \requests } l_{\req,x,y}& \leq & \Scap(x,y)~& \forall (x,y) \in  \SR & \tagIt{alg:SCGEP:capacities} \\	

	
  x_{\req} & \in & \{0,1\} &  \forall \req \in \requests & \tagIt{alg:SCGEP:embedding_variable} \\
  
  \varFlowInput & \in & \{0,1\} & \forall i \in \VVSourcesTargets & \tagIt{alg:SCGEP:flow-input-variable} \\
  
  f_{\req,e} & \in & \{0,1\} &  \forall \req \in \requests, e \in \VEextCGFlowEdges     & \tagIt{alg:SCGEP:fow-variables} \\
  
  
  l_{\req,x,y} & \geq & 0 &  \forall \req \in \requests, (x,y) \in  \SR     & \tagIt{alg:SCGEP:VariableLoad} \\
 
 \end{tabular}
 }
 \caption{SCGEP-P}
 \label{alg:SCGEP-IP}
 \end{IPFormulationStar}
 }
\end{figure*}

Embeddings are realized as follows. If,~ holds, by Constraint~\ref{alg:SCGEP:FlowInduction-Initial} exactly one of the flow values~ is set to~ for~ and hence a flow will be induced in all paths and cycles having the arbitrarily chosen root~ as source. Specifically, for all paths~, Constraint~\ref{alg:SCGEP:FlowInduction-path} sets the flow values of edges incident to the respective super source nodes in the extended graphs~ according to the values to~. For cycles, Constraint~\ref{alg:SCGEP:FlowInduction-cycle-Right} induces a flow analogously, albeit deciding which target substrate node~ will host the function~. Importantly, Constraint~\ref{alg:SCGEP:FlowInduction-cycle-Right} only induces flow in the branch~ of cycle~. Indeed, Constraint~\ref{alg:SCGEP:FlowInduction-cycle-Left} forces the flow in the branch  to reflect the flow decisions of the branch~. Having induced flow in the extended networks for paths~ and cycles~, Constraint~\ref{alg:SCGEP:FlowPreservation} enforces flow preservation in all of the extended networks. Here we define ~ to be all nodes that are neither a super source nor a super sink in the respective extended graphs. As flow preservation is enforced within all extended graphs, the flow of path and cycle graphs must eventually terminate in the respective super sinks. By Constraints~\ref{alg:SCGEP:setting-next-input-cycle-end} and \ref{alg:SCGEP:setting-next-input-path-end} the variables~ of the target of the cycle~ -- i.e.~ -- or the target of the path~ -- i.e.~ -- are set according to the amount of flow that reaches the respective sink in the respective extended graph. This effectively induces flows in all the extended graphs of cycle~ or path~ for which~ or~ holds, respectively.
However, paths~ or cycles~ may be spawned also at nodes lying inside another cycle~. This is e.g. the case for path  in Figure~\ref{fig:service-cactus-request}, as the virtual node  is an inner node of the branch  of cycle . To nevertheless, induce the right amount of flow at the different super sources in the graph , the sum of flows along processing edges inside the \emph{parallel path constructions} have to be computed, as visualized in Figure~\ref{fig:service-cactus-construction-cycle}: the flow variable  needs to equal the sum of the flow along edges  and  and the flow variable  needs to equal the sum of the flow along edges  and  as the respective edges denote the processing of function  on node  and  respectively. Constraint~\ref{alg:SCGEP:setting-next-input-cycle-middle} realizes this functionality, i.e. the inter-layer edges that denote processing are summed up to set the respective flow inducing variables . As paths may only overlap at sources and sinks (cf. Definition~\ref{def:service-cactus-graph-decomposition}), Constraints~\ref{alg:SCGEP:setting-next-input-cycle-end}-\ref{alg:SCGEP:setting-next-input-cycle-middle} propagate flow induction across extended graphs.

Constraints~\ref{alg:SCGEP:nodeLoad} and \ref{alg:SCGEP:edgeLoad} set the load variables  induced by the embeding of request  substrate resources . Within the Integer Program~\ref{alg:SCGEP-IP}, we again make use of specific index sets to simplify notation (cf. Definition of  and~ in Section~\ref{sec:integer-linear-program} and Integer~Program~\ref{alg:SCEP-IP}). Concretely, we introduce index sets~ and~ to contain the edges that indicate the processing on substrate resource   and the edge   respectively as follows:


In contrast to the definition of~ in Section~\ref{sec:integer-linear-program}, the set~ only collects the internal edges of extended graphs representing the processing at node  having type . Hence, processing at nodes that are the start or the target of any of the decomposed paths or cycles must be separately accounted for. Concretely, in Constraint~\ref{alg:SCGEP:nodeLoad}, for all nodes , the respective flow induction variables~ are added. 

With respect to accounting for the load of substrate edges~, we note that the only difference to the construction in Section~\ref{sec:integer-linear-program} is the re-reorientation of edge directions and the consideration of both paths and cycles. 

Lastly, the objective~\ref{alg:SCGEPObj} as well as the Constraint~\ref{alg:SCGEP:capacities} have not changed with respect to~(Integer)~Linear Program~\ref{alg:SCEP-IP}.

Summarizing the workings of~Integer Program~\ref{alg:SCGEP-IP}, we note the following:
\begin{itemize}
\item For each request , a breadth-first search from an arbitrarily root  is performed to obtain graph . This graph is decomposed according to Definition~\ref{def:service-cactus-graph-decomposition}.
\item Within IP~\ref{alg:SCGEP-IP}, for each request~ flow is induced in the respective extended graphs of cycles and paths via the variables~ for all nodes~ and substrate nodes~~(see Constraints~\ref{alg:SCGEP:FlowInduction-cycle-Right}, \ref{alg:SCGEP:FlowInduction-cycle-Left}, and \ref{alg:SCGEP:FlowInduction-path}).
\item Within each extended graph flow preservation holds (excluding super sources and sinks).
\item For cycles~, it is additionally enforced that the amount of flow sent towards destination~ must be equal for both branches~(see Constraints~\ref{alg:SCGEP:FlowInduction-cycle-Right} and \ref{alg:SCGEP:FlowInduction-cycle-Left}).
\item As flow must terminate at the sinks of the extended graphs, the variables~ of path~ and the variables~ are eventually set~(see Constraints~\ref{alg:SCGEP:setting-next-input-cycle-end} and \ref{alg:SCGEP:setting-next-input-path-end}), thereby potentially inducing flows in other extended graphs. Additionally, if another cycle or path is spawned at a node internal to a branch of a cycle the respective flow input variables  are set in  Constraint~\ref{alg:SCGEP:setting-next-input-cycle-middle}.
\item Hence, if~ holds for request~, then by Constraint~\ref{alg:SCGEP:FlowInduction-Initial} one of the variables~ must be set to one. By the above observations, this will induce flows in \emph{all} extended graphs. 
\end{itemize}




{

 \newcolumntype{F}{>{}@{\hspace{0.0em}}}
 \newcolumntype{C}{>{}@{\hspace{0.0em}}}
 \newcolumntype{B}{>{}@{\hspace{0.0em}}}
 \newcolumntype{R}{>{}@{\hspace{0.2em}}}
 \newcolumntype{S}{>{}@{\hspace{0.2em}}}
 \newcolumntype{L}{>{}@{\hspace{0.2em}}}
 \newcolumntype{Q}{>{}@{\hspace{0.3em}}}
 
 
\LinesNotNumbered
\renewcommand{\arraystretch}{1.5}

\begin{IPFormulation}{tb}

\SetAlgorithmName{Integer Program}{}{{}}

\scalebox{0.94}{

\newcommand{\spaceIt}{\qquad\quad\quad}
\newcommand{\miniSpace}{\hspace{1.5pt}}

\centering
\hspace{-32pt}
\begin{tabular}{FFCLLBB}
\multicolumn{5}{C}{\textnormal{min~}  \sum_{\req \in \requests} \sum \limits_{(x,y) \in   \SR} \Scost(x,y)~\cdot l_{\req,x,y} } & ~ & \tagIt{alg:SCGEPObj-C}\
\sum_{\req \in \requests} \sum_{\decomp \in \PotEmbeddings} \prob \cdot \load(x,y)~\leq \sum_{\req \in \requests} l_{\req, x,y} \leq  \Scap(x,y)\,,
\label{eq:lem:allocations-scgep}

\sum_{\req \in \requests} \sum_{\decomp \in \PotEmbeddings} \prob \cdot \Vprofit = \hat{B}~.

\sum_{\req \in \requests} \sum_{\decomp \in \PotEmbeddings} \prob \cdot c(\mapping)~\leq \hat{C}~.

\{\sum^n_{k=1} \lambda_k \cdot \varphi(\{r\},M_k)~| n \in \mathbb{N}, M_k \in \spaceSolReq, \lambda_k \geq 0, \sum^n_{k=1} \lambda_k \leq 1 \}\,.
2pt]
\item  for all requests , virtual nodes  and substrate nodes . \2pt]
\item  for all requests , virtual edges  and substrate edges .
\end{itemize}
As the Formulation~\ref{alg:SCGEP-IP} and the decomposition Algorithm~\ref{alg:decompositionAlgorithmSCGEP} are valid, it is easy to check that the above projection is valid, i.e.  holds.
Furthermore, given any solution , it is obvious that the projected solution  is decomposable, as the respective mappings were computed explicitly in the decomposition algorithm. Thus,  holds and under this projection all solutions are decomposable. Together with Lemma~\ref{lem:non-decomposability}, we obtain .
Lastly, as  holds, the relaxations of Integer Program~\ref{alg:SCGEP-IP} are indeed provably stronger than the ones of Integer Program~\ref{alg:VNEP-IP-old}.
\end{proof}
\end{theorem}

The above theorem is based on the structural deficits of the Integer Program~\ref{alg:VNEP-IP-old} and does neither depend on the particular way we have formulated IP~\ref{alg:VNEP-IP-old} nor does it depend on whether we consider SCGEP-P or SCGEP-C. Furthermore, we note that the above theorem can also have practical implications, when trying to obtain obtain \emph{good bounds} via linear relaxations, as the difference in the benefit (or cost)~can be unbounded.

\begin{lemma}
The objectives of the linear relaxations of Integer Programs~\ref{alg:SCGEP-IP} and \ref{alg:VNEP-IP-old} can diverge arbitrarily. Concretely, considering the embedding of a particular set of requests  on substrate  and denoting the benefit obtained by Integer Program~\ref{alg:SCGEP-IP} as  and the benefit obtained by Integer Program~\ref{alg:VNEP-IP-old} as , the absolute difference  as well as the relative difference  may be unbounded. 
\begin{proof}
We first note that by Theorem~\ref{thm:stronger-formulation} we have  as  holds. We reuse the example depicted in Figure~\ref{fig:non-decomp} and we assume that the depicted request is the only one. As discussed, the depicted fractional solution is a feasible relaxation of Integer Program~\ref{alg:VNEP-IP-old}. As  holds, we have .  

Considering the relaxations of Integer Program~\ref{alg:SCGEP-IP}, we claim that only  is feasible. This is easy to check as there does not exist a potential substrate location for virtual node , such that the branches  and  can end in the same substrate location while also emerging at the same location. Hence, the benefit obtained by the relaxation of Integer Program~\ref{alg:SCGEP-IP} is .

Hence, the absolute difference is  and -- as  can be set arbitrarily -- the absolute as well as the relative difference are unbounded.
\end{proof}
\end{lemma}



\section{Related Work}\label{sec:relwork}

Service chaining
has recently received much attention by
both researchers and practitioners~\cite{karl-chains,ewsdn14,stefano-sigc,merlin}. 
Soul\'{e} et al.~\cite{merlin} present Merlin,
a flexible framework which allows
to define and embed service chain policies.
The authors also present an integer program
to embed service chains, however, solving
this program requires an exponential runtime. 
Also
Hartert et al.~\cite{stefano-sigc} have studied
the service chain embedding problem,
and proposed a constraint optimization
approach. However also this approach
requires exponential runtime in the worst case.
Besides the optimal but exponential
solutions presented in~\cite{stefano-sigc,merlin}, 
there also exist heuristic solutions, e.g.,~\cite{karl-chains,ewsdn14}:
while heuristic approaches may be attractive for their
low runtime, they do not provide any
worst-case quality guarantees. 
We are the first to present
polynomial time algorithms for service chain embeddings
which comes with formal approximation guarantees.
Concretely, our results based on randomized rounding techniques
are structured into two papers:
In~\cite{swat-guy}, we only consider the admission control variant
and derive a constant approximation under assumptions on the relationship
between demands and capacities as well as on the optimal benefit.
In contrast, we have considered in this paper a more general
setting, in which the decomposition approach based on random walks~\cite{swat-guy}
 is not feasible, as we allow for arbitrary service cactus graphs.
Importantly, while our approach does not require specific assumptions on loads and benefits, we obtain
worse approximation ratios. 

From an algorithmic perspective, 
the service chain embedding problem
can be seen as a variant of  a
graph embedding problem, see~\cite{diaz2002survey} for a survey.
Minimal Linear Arrangement~(MLA)~is the archetypical
embedding footprint minimization problem,
where the substrate network has a most simple topology:
a linear chain.
It is known that MLA can be~ approximated in
polynomial time~\cite{best-mla-1,mla-best-2}.
However, the approximation algorithms 
for VLSI layout problems~\cite{diaz2002survey,vlsi-layout},
cannot be adopted for embedding service chains in 
general substrate graphs.

\begin{comment}
From an algorithmic perspective, 
the service chain embedding problem
can be seen as a variant of 
graph embedding problems studied
in the context of VPNs~\cite{Fingerhut,vpn-true,Gupta-VPN},
parallel architectures~\cite{faulty-emulation-leighton,parallel-arch-Leighton},
and especially VLSI layout problems~\cite{diaz2002survey,vlsi-layout},
which also exhibit flexibilities for the endpoint placement,
and which has been studied for various objective functions,
from cutwidth~\cite{cutwidth-1,cutwidth-2},
over sum cuts~\cite{minsumcut}, profiles~\cite{profile} 
to minimal linear arrangements~\cite{harper}.
Oversimplifying, embedding problems can be categorized
into to classes: load minimization and sum / footprint minimization problems.
While the former has received more attention in the literature,
our model can be seen as an instance of the latter,
and in some sense, the Minimal Linear Arrangement~(MLA)~is the archetypical
embedding footprint minimization problem,
where the substrate network has a most simple topology:
a linear chain.
Garey, Johnson, and Stockmeyer were the first to prove
its NP-hardness on general graphs~\cite{mla-np-hard}.
Amb\"uhl, Mastrolilli, and Svensson showed that the MLA
on general graphs does not have a polynomial time
approximation scheme unless NP-complete problems
can be solved in randomized subexponential time~\cite{mla-ptas}.
A major result in the area is due to Leighton et al.~\cite{vlsi-leighton-maxminflow},
who generalized
the classic 1-commodity max-flow min-cut theorem for problems with
multiple commodities. The result has interesting applications to the field of approximation
algorithmsm, and the authors showed polynomial time~(polylog
n-times-optimal)~approximation algorithms for many 
NP-hard optimization problems, such as
graph partitioning, min-cut linear arrangement, crossing number, VLSI layout~\cite{vlsi-layout,Yeh-circuit}, and minimum
feedback arc set.
MLA can be~ approximated in
polynomial time, as shown by
 to Charikar, Hajiaghayi,
Karloff, and Rao~\cite{best-mla-1}, and by Feige and Lee~\cite{mla-best-2}.
The latter algorithm is a combination of techniques of earlier works by
Rao and Richa~\cite{rao04new-approximation}, and Arora, Rao, and Vazirani~\cite{arora-jacm}.
However, while several approximation algorithms are known
for VLSI layout problems~\cite{diaz2002survey,vlsi-layout},
they cannot be adopted for embedding service chains in 
general substrate graphs.
\end{comment}

Very general graph embedding problems have recently also 
been studied by the networking community
in the context of virtual network embeddings~(sometimes
also known as testbed mapping problems).
Due to the inherent computational hardness of the underlying
problems, the problem has mainly been approached using mixed integer
programming~\cite{vnep} and heuristics~\cite{vnep-rethink}.
For a survey on the more practical literature, we refer
the reader to~\cite{vnep-survey}.
Algorithmically interesting and computationally tractable embedding problems
arise in more specific contexts, e.g., 
in fat-tree like datacenter networks~\cite{oktopus,ccr15emb}.
In their interesting work, 
Bansal et al.~\cite{bansal2011minimum} 
give an
 time~-approximation algorithm 
for minimizing the load of embeddings in tree-like datacenter
networks, based on a strong LP relaxation
inspired by the Sherali-Adams hierarchy.
The problem of embedding star graphs 
has recently also been explored on various substrate topologies~(see also~\cite{ccr15emb}),
but to the best of our knowledge, no approximation algorithm
is known for embedding chain- and cactus-like virtual networks on arbitrary topologies.


Finally, our work is closely related to unsplittable
path problems, for which various approximation algorithms
exist,
also for admission control variants~\cite{Kleinberg-admission-control}.
In particular, our work leverages  
techniques introduced by Raghavan and Thompson~\cite{Raghavan-Thompson}:
in their seminal work, the authors 
develop provably
good algorithms based on relaxed, polynomial time versions of 
0-1 integer programs. 
However, our more general setting not only requires a novel
and more complex decomposition approach,   but also a novel and advanced
formulation of the mixed integer program itself: as we have shown, 
standard formulations cannot be decomposed at all.
Moreover, we are not aware of any extensions of the randomized rounding
approach to problems allowing for admission control and the objective of maximizing the profit. 



\section{Conclusion}\label{sec:conclusion}

This paper initiated the study of 
polynomial time approximation algorithms
for the service chains embedding problem, and beyond. 
In particular, we have presented novel approximation algorithms,
which apply randomized rounding on the decomposition of linear programming solutions, and which also support admission control. 
We have shown that using this approach, a constant approximation of the objective
is possible in multi-criteria models with non-trivial augmentations, both for
service chains as well as for more complex virtual networks, particularly
service cactus graphs.
Besides our result and decomposition technique,
we believe that also our new integer program formulation may be of independent interest.

Our paper opens several interesting directions
for future research. In particular, we believe that our
algorithmic approach is of interest beyond the service chain 
and service cactus graph embedding problems considered in this paper, and can be used 
more generally. In particular, we have shown that our approach can be employed as long as the relaxations can be decomposed. Hence, we strongly believe that our approach can be applied to further graph classes as well.
Moreover, it will also be interesting 
to study the tightness of the novel bounds obtained in this work.


\textbf{Acknowledgement.}
This research was supported by the EU project UNIFY FP7-IP-619609.




{

\bibliographystyle{plain}
\bibliography{references}
}


\end{document}