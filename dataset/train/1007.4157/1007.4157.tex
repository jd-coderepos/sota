\documentclass[english]{tlp}
\usepackage{aopmath}

\usepackage{babel}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{latexsym}
\usepackage{stmaryrd}
\usepackage{vaucanson-g}
\usepackage{graphicx}

\newtheorem{definition}{Definition} \newtheorem{example}{Example}       \newtheorem{remark}{Remark}         

\newtheorem{note}[theorem]{Note} \newtheorem{notation}[theorem]{Notation} 



\newcommand{\wrt}{w.r.t.\ }
\newcommand{\If}{\leftarrow}
\newcommand{\Imp}{\rightarrow}
\newcommand{\Iff}{\leftrightarrow}
\newcommand{\IF}{\Leftarrow}
\newcommand{\IMP}{\Rightarrow}
\newcommand{\IFF}{\Leftrightarrow}
\newcommand{\diff}{\!\neq\!}
\newcommand{\gr}{\!>\!}
\newcommand{\greq}{\!\geq\!}
\newcommand{\less}{\!<\!}
\newcommand{\lesseq}{\!\leq\!}
\newcommand{\mgu}{\mathit{mgu}}
\newcommand{\vars}{}
\newcommand{\true}{\mathit{true}}
\newcommand{\false}{\mathit{false}}
\newcommand{\hd}{\mathit{hd}}
\newcommand{\bd}{\mathit{bd}}

\newcommand{\af}{\mathit{af}}
\newcommand{\ex}{\mathit{ex}}
\newcommand{\eu}{\mathit{eu}}
\newcommand{\ef}{\mathit{ef}}
\newcommand{\eq}{\! =\!}
\newcommand{\pl}{\!+\!}

\newcommand{\bk}{\hspace*{-.3mm}}
\newcommand{\eqdef}{=_{\mathit{\scriptstyle{d\!e\!f}}}}
\newcommand{\precsimemc}{\precsim_{\mathit{emc}}}
\newcommand{\nat}{n\bk a\bk t}
\newcommand{\subeu}{e\bk u}
\newcommand{\subaf}{a\bk f}
\newcommand{\weu}{w\bk e\bk u}
\newcommand{\waf}{w\bk a\bk f}

\newcommand{\gel}{\geq_{\mathit{lex}}}
\newcommand{\gl}{>_{\mathit{lex}}}
\newcommand{\bif}{\;{\mathit{if}}\;}
\newcommand{\bth}{\;{\mathit{then}}\;}
\newcommand{\bel}{\;{\mathit{else}}\;}
\newcommand{\tA}{{\widetilde{A}}}
\newcommand{\tB}{{\widetilde{B}}}
\newcommand{\tC}{{\widetilde{C}}}
\newcommand{\tD}{{\widetilde{D}}}
\newcommand{\tH}{{\widetilde{H}}}
\newcommand{\tK}{{\widetilde{K}}}
\newcommand{\tL}{{\widetilde{L}}}
\newcommand{\tM}{{\widetilde{M}}}
\newcommand{\tN}{{\widetilde{N}}}


\newcommand{\U}{\raisebox{1.pt}{\bf \b{ }}}
\renewcommand{\mathit}{\displaystyle}  



\newcommand{\Mathit}[1]{\mbox{\it #1}}  

\newcommand{\Iob}{{\it{inf}}\_{\it{often}}\_{\it{b}}} \newcommand{\Lo}{{\it{last}}\_{\it{occ}}}  \newcommand{\Pred}{\Mathit{Pred}}
\newcommand{\DefsPrk}{\Mathit{Defs}}
\newcommand{\Defsk}{\Mathit{Defs}}
\newcommand{\Defsn}{\Mathit{Defs}}
\newcommand{\Defsz}{\Mathit{Defs}\/}
\newcommand{\Defs}{\Mathit{Defs}}

\makeatother


\begin{document}

\thispagestyle{empty}

\long\def\comment#1{}


\title[Transformations of Logic Programs on Infinite
Lists] {Transformations of Logic Programs on\\ Infinite Lists}

\author[A. Pettorossi, M. Proietti, and V. Senni]
{ALBERTO PETTOROSSI\\
DISP, University of Rome Tor Vergata,
Via del Politecnico 1, I-00133 Rome, Italy\\
\email{pettorossi@disp.uniroma2.it} \and
MAURIZIO PROIETTI\\
IASI-CNR, Viale Manzoni 30, I-00185 Rome, Italy\\
\email{maurizio.proietti@iasi.cnr.it} \and
VALERIO SENNI\\
DISP, University of Rome Tor Vergata,
Via del Politecnico 1, I-00133 Rome, Italy\\
\email{senni@disp.uniroma2.it} }

\pagerange{\pageref{firstpage}--\pageref{lastpage}}
\volume{\textbf{nn} (n):} \jdate{month 2010} \setcounter{page}{1}
\pubyear{2010}

\maketitle

\label{firstpage}

\maketitle
\begin{abstract}
We consider an extension of logic
programs, called {\em -programs}, that can be used to define predicates
over {\em infinite lists}. 
\mbox{-programs} allow us to specify properties of the 
infinite behavior of
reactive systems and, in general, properties of infinite sequences of events. 
The  semantics of \mbox{-programs} is
an extension of the perfect model semantics. 
We present variants of the familiar unfold/fold rules which can be
used for transforming -programs. We show that these new rules are correct, that is,
their application preserves the perfect model semantics. 
Then we outline a general methodology based on program transformation
for verifying properties of -programs.
We demonstrate the power of our transformation-based verification methodology
by proving some properties of B\"uchi automata and \mbox{-regular} languages.

\smallskip

\noindent{\em KEYWORDS}: Program Transformation, Program Verification, Infinite Lists.
\end{abstract}


\section{Introduction
\label{sec:introduction}}The problem of specifying and verifying
properties of {\em reactive systems}, such as protocols and
concurrent systems, has received much attention over the past fifty
years or so. The main peculiarity of reactive systems is that they
perform nonterminating computations and, in order to specify and
verify the properties of these computations, various formalisms
dealing with infinite sequences of events have been proposed. Among
these we would like to mention: (i)~B\"uchi automata and other
classes of finite automata on infinite sequences~\cite{Tho90},
(ii)~-languages~\cite{Sta97}, and (iii)~various temporal and
modal logics (see~\cite{Cl&99} for a brief overview of these
logics).

Also logic programming has been proposed as a formalism for
specifying computations over infinite structures, such as infinite
lists or infinite trees (see, for
instance,~\cite{Col82,Llo87,Si&06,MiG09}). One advantage of using
logic programming languages is that they are general purpose
languages and, together with a model-theoretic semantics, they also have
an operational semantics. Thus, logic programs over infinite
structures can be used for {\em specifying\/} infinite computations
and, in fact, providing executable specifications for them. However,
very few techniques which use logic programs over infinite
structures, have been proposed in the literature for {\em verifying\/}
properties of infinite computations. We are aware only of a recent
work presented in~\cite{Gu&07}, which is based on {\rm coinductive}
logic programming, that is, a logic programming language whose
semantics is based on greatest models.

In this paper our aim is to develop a 
methodology based on the familiar unfold/fold transformation rules~\cite{BuD77,TaS84} 
for reasoning about infinite structures and verifying properties
of programs over such structures. In order to do so,
we do not introduce a new 
programming language, but we consider a simple 
extension of logic programming on finite terms by introducing
the class of the so-called {\em -programs}, which are 
logic programs on infinite lists. 
Similarly to the case of logic programs,
for the class of {\em locally stratified}  -programs
we define the {\em perfect model}
semantics (see~\cite{ApB94} for a survey on negation in 
logic programming). 

We extend to
-programs the transformation 
rules for locally stratified programs presented
in~\cite{Fi&04a,PeP00a,Ro&02,Sek91,Sek09} and, 
in particular: (i)~we introduce
an {\em instantiation\/} rule which is specific for programs on
infinite lists, (ii)~we weaken the applicability conditions for
the {\em  negative unfolding\/} rule, and 
(iii)~we consider a more powerful {\em negative
folding\/} rule (see Sections~\ref{sec:rules} and \ref{sec:corr_of_rules}
for more details).
We prove that these rules preserve
the perfect model semantics of -programs.

Then we extend to -programs the transformation-based
methodology for verifying properties of programs presented in~\cite{PeP00a}.
We  demonstrate the power of our verification methodology
through some examples. In particular, we prove: (i)~the non-emptiness of the
language recognized by a B\"uchi automaton,
 and (ii)~the containment between languages
denoted by -regular expressions.

The paper is structured as follows. In
Section~\ref{sec:omega-programs} we introduce the class of 
\mbox{-pro}{\-grams} and we define the perfect model semantics for locally stratified
\mbox{-programs}. In Section~\ref{sec:rules} we present the transformation rules
and in Section~\ref{sec:corr_of_rules} we prove that they preserve the  semantics of -programs. In Section~\ref{sec:verification} we
present the transformation-based verification method and we see it in action in
some examples. Finally, in Section~\ref{sec:related} we discuss related work in
the area of program transformation and program verification.



\section{Programs on Infinite Lists
\label{sec:omega-programs}}

Let us consider a first order language  given
by a set {\it{Var}} of variables, a set {\it{Fun}} of function
symbols, and a set {\it{Pred}} of predicate symbols. We assume that
{\it{Fun}} includes: (i)~a {\em finite}, {\em non-empty} set  of
constants, (ii)~the constructor  of the infinite lists of
elements of , and (iii)~at least one constant not in 
. Thus,  is an
infinite list whose head is  and whose tail is the
infinite list~. Let  denote the set of the
infinite lists of elements of .

We assume that  is a typed
language~\cite{Llo87} with three basic types:  (i)~\texttt{fterm},
which is the type of the finite terms, (ii)~\texttt{elem}, which is
the type of the constants in , and (iii)~\texttt{ilist},
which is the type of the infinite lists of .
Every function symbol in {\it{Fun}}, with arity , has type
, where  occurs  times to the left of
. The function symbol  has
type .
A predicate symbol of arity  in {\it{Pred}} has type
of the form , where
.
For every term  (or formula) ,
we denote by  
the set of variables occurring in~. 

An {\mbox{{\em -clause} }} is a formula of the form
, with ,
where  is an atom and  are (positive or
negative) literals, constructed as usual from symbols in the typed
language~, with the following extra
condition:~every predicate in  has, among its
arguments, {\em at most one} argument of type . This
condition makes it easier to prove the correctness of the positive and
negative unfolding rules
(see Section~\ref{sec:rules} for further details).
We denote by {\it true} the empty conjunction of literals.
An {\em -program} is a set of
-clauses. 

Let \mbox{\it{HU}} be the Herbrand universe constructed from the set
{\it{Fun}} of
function symbols. 
An interpretation for our typed language
, called an
{\mbox{-in\-ter}}\-pretation, is a function  such that:
(i)~ assigns to the types \texttt{fterm}, \texttt{elem},
 and \texttt{ilist}, respectively,
the sets , , and 
(which by our assumptions are non-empty),
(ii)~ assigns to the function symbol~, the function  such that, for any
element , for any infinite list ,
 is the infinite list ,
(iii)~ is an Herbrand interpretation for all function symbols in
,
and~(iv)~ assigns to every -ary predicate \,{\it{Pred}}
of type \mbox{}, a relation
on~, where, for ,
 is~either  or  or , if
 is~either  or  or
, respectively. We say that an
-interpretation  is an {\mbox{-{\it model}}} of
an \mbox{-program } if for every clause 
we have that , where
.

A \emph{valuation} is a function  {\it{Var}} 
\mbox{\it{HU}}  such
that: (i) if  has type  then
, (ii)~if  has type 
then , and (iii)~if  has type 
then . The valuation function  can be
extended to any term~, or literal , or clause , by
making the function  act on the variables occurring in , or , or
.
We extend the notion of {\em Herbrand base}~\cite{Llo87} to
-programs by defining it to be the set  is an -ary predicate 
symbol in {\it Pred} and 
is a valuation. Thus, any -interpretation can be identified with a
subset of~.

A \emph{local stratification} is a function : , where  is the set of
countable ordinals. Given , we define
. Given an -clause  of the
form  
and a local stratification , we
say that  is \emph{locally stratified} w.r.t.~ if, for , for every valuation , \emph{}. An -program 
is \emph{locally stratified w.r.t.~}, or 
is a \emph{local stratification for} , if every clause in  is locally stratified w.r.t.~. An -program
 is \emph{locally stratified} if there exists a local
stratification  such that  is \emph{locally
stratified w.r.t.~}. 

A \emph{level mapping} is a function . A level mapping is extended to
literals as follows: for any literal  having predicate , if
 is a positive literal, then  and, if  is a
negative literal then . An -clause
 of the form  is {\em stratified} w.r.t.~ if, for ,
. An -program  is
\emph{stratified} if there exists a level mapping  such that
all clauses of  are stratified w.r.t.~~\cite{Llo87}. 
Clearly, every stratified
-program is a locally stratified -program.
Similarly to the case of logic programs on finite terms, for every locally
stratified -program~, we can construct a unique {\em perfect
-model} (or {\em perfect model}, for short) denoted by
 (see~\cite{ApB94} for the case of logic programs on finite
terms). Now we present an example of this construction.


\begin{example}\label{ex:omega_prog}
Let: (i)~ be the set of constants of type
, (ii)  be a variable of type
, and (iii)~ be a variable of type
. Let ~and  be predicates of type
. Let us consider the
following -program :

\smallskip

\makebox[45mm][l]{}
\makebox[35mm][l]{}
\makebox[30mm][l]{}

\smallskip

\noindent We have that: (i)~ holds iff  is an infinite list of 's 
and (ii)~ holds iff at least one  occurs in .
Program  is  stratified w.r.t.~the level mapping  such that
 and {\mbox{}}. 
The perfect model~ is constructed by
starting from the ground atoms of level 0 (i.e., those with predicate
). We have that, for all~,
 iff  , that is, 
 iff  . Then, we
consider the ground atoms of level~1 (i.e., those with predicate~). 
For all~,  iff .
Thus,  iff . 
\end{example}



\section{Transformation Rules\label{sec:rules}}

Given an -program , a \emph{transformation sequence} is a sequence
, with , of \mbox{-programs} 
constructed as follows. Suppose that we have constructed a sequence
, for . Then, the next
program  in the sequence is derived from program 
by applying one of the following transformation rules \mbox{R1--R7}.

First we have the \emph{definition introduction} rule which allows
us to introduce a new predicate definition.

\medskip

\noindent \textbf{R1. Definition Introduction.} Let us consider  ( clauses of the form:
\smallskip{}

 {\it{newp}}{\it{newp}}

\smallskip{}

\noindent where: (i) {\it{newp}} is a predicate symbol not occurring
in , (ii)  are
distinct variables occurring in ,
(iii)~none of the 's is the empty conjunction of literals,
and (iv)~every predicate symbol occurring in  also occurs in . The set  of clauses is said to be the {\em definition} of
{\it{newp}}.

\noindent By \emph{definition introduction} from program  we derive the new program . For ,
\Defsn~denotes the set of clauses introduced by the definition rule
during the transformation sequence . In
particular, \Defsz.

\medskip{}

\noindent In the following {\em instantiation} rule we assume that the set
 of constants of type~\texttt{elem} in the language
 is the finite set
.

\smallskip

\noindent \textbf{R2. Instantiation.}\label{rule:inst} Let~:
 be a clause in program~ and  be a variable
of type~\texttt{ilist} occurring in~. By
\emph{instantiation} of~ in~, we get the clauses:

\smallskip

: ,
~~\ldots,~~ : 

\smallskip

\noindent and we say that clauses  are
{\it{derived from}} . From~ we derive the new
program~.

\medskip

The \emph{unfolding} rule consists in replacing an atom 
occurring in the body of a clause by its definition in . We
present two unfolding rules: (1)~the {\em positive unfolding}, and
(2)~the {\em negative unfolding}. They correspond, respectively, to
the case where  or  occurs in the body of the clause to
be unfolded.

\medskip

\noindent \textbf{R3. Positive Unfolding.} Let  be a clause in program  and let  be a variant of  without
variables in common with . Let

\smallskip

 \ \ \ (

\smallskip{}

\noindent be all clauses of program  such that, for ,  is unifiable with , with most
general unifier .

\noindent By \emph{unfolding  w.r.t.~} we get
the clauses , where for ,  is , and we say that clauses  are {\it{derived from}} . From  we
derive the new program .

\medskip{}

In rule R3, and also in the following rule R4, the 
most general unifier can be computed by using a unification
algorithm for finite terms~(see, for instance,~\cite{Llo87}). 
Note that 
this is correct, even in the presence on infinite terms, 
because in any -program
each predicate has at most one argument of type~\texttt{ilist}.
On the contrary, if predicates may have
more than one argument of type~\texttt{ilist},
in the unfolding rule it is necessary to use 
a unification algorithm for infinite structures~\cite{Col82}.
For reasons of simplicity, here
we do not make that extension of the unfolding rule
and we stick to our assumption
that every predicate has at most one argument of type~\texttt{ilist}.

\medskip

The {\em existential variables} of a clause  are the
variables occurring in the body of~ and not in its head.

\medskip

\noindent \textbf{R4. Negative Unfolding.}\label{rule:neg-unfold}
Let :  be a
clause in program  and let  be a variant of 
without variables in common with . Let

\smallskip

 \ \ \ (

\smallskip{}

\noindent be all clauses of program , such that, for ,  is unifiable with , with most
general unifier . Assume that: (1)~, that is, for
,  is an instance of , (2)~for
,  has no existential variables,
and (3)~from  we get a logically equivalent disjunction  of conjunctions of literals, with , by first pushing  inside and then pushing  outside.

\noindent By \emph{unfolding   w.r.t.~}
 \emph{using } we get the clauses  where, for , clause  is
, and we say that clauses
 are {\it{derived from}} .
From  we derive the new program .

\medskip

\noindent The following \emph{subsumption} rule allows us to remove
from  a clause  such that
.

\medskip

\noindent \textbf{R5. Subsumption.}\label{rule:subsumption} Let
:  be a clause in program  and let
 in  be a variant of , for some conjunction of literals  and substitution
. Then, we say that  {\it is subsumed} by
 and by  \emph{subsumption}, from  we derive the
new program .

\medskip

\noindent The \emph{folding} rule consists in replacing instances of
the bodies of the clauses that define an atom  by the
corresponding instance of . Similarly to the case of the
unfolding rule, we have two folding rules: (1)~\emph{positive folding}
and (2)~\emph{negative folding}. They correspond, respectively, to the
case where folding is applied to positive or negative occurrences of
literals.

\smallskip{}

\noindent \textbf{R6. Positive Folding.} Let  be a clause in
 and let  be a variant of
 without variables in common with . Let the
definition of a predicate in \DefsPrk~consist of the clause , where  is a non-empty conjunction of literals.
Suppose that there exists a substitution  such that
clause  is of the form  and, for every variable , the following conditions hold: (i)  is a variable not occurring in , and (ii)~ does not occur in the term , for any variable  occurring in  and
different from .

\noindent By \emph{folding  using } we get the
clause : , and we say that clause   is {\it{derived from}}
. From  we derive the new program .

\medskip{}

\noindent \textbf{R7. Negative Folding.} Let  be a clause in
 and let \DefsPrk~be a variant of \Defskwithout
variables in common with . Let the definition of a predicate
in \DefsPrk~consist of the  clauses , with , such that, for
,  is a literal and  
has no existential variables. Suppose that there exists a
substitution  such that clause  is of the
form , where, for , if~ is the negative
literal~ then~ is~, and if~ is the
positive literal~ then~ is~.

\noindent By \emph{folding  using
} we get the clause : , and we
say that clause   is {\it{derived from}} . From  we derive the program .

\medskip

Note that the negative folding 
rule is not included in the sets of transformation rules
presented in~\cite{Ro&02,Sek91,Sek09}.
The negative folding rule presented in~\cite{Fi&04a,PeP00a} corresponds 
to our rule~R7 in the case where . 



\section{Correctness of the Transformation Rules}
\label{sec:corr_of_rules}

Now let us introduce the notion of correctness of a\,transformation
sequence w.r.t.\,the perfect model semantics.

\begin{definition}
[Correctness of a Transformation Sequence]
\label{def:correctness-of-transf-sequence} Let  be a locally
stratified -program and , with ,
 be a transformation
sequence. We say that  is {\em correct} if
(i)~\Defsn~and  are locally stratified
-programs and (ii)~\Defsn.
\end{definition}


In order to guarantee the correctness of a transformation sequence
 (see Theorem~\ref{th:corr_of_rules} below) we
will require that the application of the transformation rules
satisfy some suitable conditions that refer to a given local
stratification . In order to state those
conditions we need the following definitions.
\vspace{0mm}
 
\begin{definition}
[-Maximal Atom] \label{def:sigma-maximal} Consider a clause
: . An atom  in  is
said to be {\em -maximal} if, for every
valuation~ and for every literal  in , we have
.
\end{definition}
\vspace{-2mm}

\begin{definition}
[-Tight Clause]\label{def:sigma-tight-definition}
A clause :  is said to be {\mbox{-{\em
tight}}} if there exists a -maximal atom  in 
such that, for every valuation~, .
\end{definition}
\vspace{-2mm}

\begin{definition}
[Descendant Clause] \label{def:descen-clause-definition} A clause
 is said to be a {\em descendant} of a clause  if
{\it{either}}  is  itself {\it{or}} there exists a
clause~ such that  is {\it{derived from}}  by
using a rule in , and~ is a descendant of .
\end{definition}
\vspace{-2mm}

\begin{definition}
[Admissible Transformation Sequence] \label{def:adm-transformation}
Let  be a locally stratified -program and let
 be a local stratification for . A transformation
sequence , with , is said to be \emph{admissible} if:

\noindent\textup{(1)}~every clause in \Defsn \ is locally stratified w.r.t.~,

\noindent \textup{(2)}~for , if  is
derived from  by positive folding of clause 
 using clause , then: (2.1)~ is 
-tight and {\em either} (2.2.i)~the head
predicate of  occurs in , {\em or}~(2.2.ii)~ is a
descendant of a clause  in , with , such that  has been derived by positive unfolding of a clause
 in  w.r.t. an atom 
which is -maximal in the body of~
and whose predicate occurs in , and

\noindent \textup{(3)}~for , if  is
derived from  by applying the negative folding rule thereby
deriving a clause , then  is locally stratified
w.r.t.~.
\end{definition}

Note that Condition (1) can always be fulfilled because the
predicate introduced in program  by rule~R1 does
not occur in any of the programs .
Conditions (2) and (3) cannot be checked in an algorithmic way for
arbitrary programs and local stratification functions. In particular,
the program property of being locally stratified is undecidable.
However, there are significant classes of programs, such as the 
stratified programs, where these conditions are decidable and easy to
verify.

The following Lemma~\ref{lem:sigma-preservation} and
Theorem~\ref{th:corr_of_rules}, whose proofs can be found in
the Appendix, show that: (i)~when constructing an
admissible transformation sequence , the application
of the transformation rules preserves the local
stratification~ for the initial program  and, thus, all
programs in the transformation sequence are locally stratified
w.r.t.~, and (ii)~any admissible transformation sequence
preserves the perfect model of the initial program.

\begin{lemma}[Preservation of Local Stratification]
\label{lem:sigma-preservation} Let   be a locally stratified
-program,  be a local stratification for , and
\,be\,an\,admissible transformation sequence.\,Then
the\,programs\,\Defsn,  are all
locally stratified w.r.t.~.
\end{lemma}

\begin{theorem}[Correctness of Admissible Transformation
Sequences]\label{th:corr_of_rules} Every admissible transformation
sequence is correct.
\end{theorem}

Now let us make a few comments on Condition (2) of
Definition~\ref{def:adm-transformation} and related conditions
presented in the literature. Transformation sequences of stratified
programs over finite terms constructed by using rules R1, R3, and R6
have been first considered in~\cite{Sek91}. In that paper there is a
sufficient condition, called (F4), for the preservation of the
perfect model. Condition~(F4) is like our Condition~(2) except that (F4) 
does not require the -maximality of the atom w.r.t.~which positive
unfolding is performed. A set of transformation rules which includes
also the negative unfolding rule R4, was proposed in~\cite{PeP00a}
for locally stratified logic programs, and in~\cite{Fi&04a} for
locally stratified constraint logic programs. 
In~\cite{Sek09} Condition (F4) is shown
to be insufficient for the preservation of the perfect model if
rule R4 is used together with rules R1, R3, and R6, as demonstrated
by the following example.

\begin{example}
\label{ex:seki} Let us consider the initial program  .
By rule R1 we introduce the clause 
:  
and we derive program  and . 
By rule R3 we unfold  w.r.t.~ and we get the clause
: .
We derive program . Thus, Condition~(F4) is satisfied.
By rule R4 we unfold   w.r.t.~
and we get 
: .
We derive program .
By rule R6 we fold clause  using clause , and we get 
: . 
\noindent
We derive program  and . We have that  and .  Thus, the 
transformation sequence  is not correct.
\end{example}

In order to guarantee the preservation of the perfect model
semantics,~\cite{Sek09} has proposed the following stronger
applicability condition for negative unfolding:

\smallskip \noindent
{\em{Condition}} (NU):
the negative unfolding rule R4 can be applied only if it does not
increase the number of positive occurrences of atoms in
the body of any derived clause. 

\smallskip \noindent
Indeed, in the incorrect transformation
sequence of Example~\ref{ex:seki} the negative unfolding does not
comply with this Condition~(NU).
However, Condition~(NU) is very restrictive, because it forbids  the
unfolding of a clause w.r.t.~a negative literal  when
 the body of a clause defining  contains an occurrence of a
negative literal. Unfortunately, many of the correct
transformation strategies proposed in~\cite{PeP00a,Fi&04a} would be
ruled out if Condition~(NU) is enforced. Our Condition (2) is more
liberal than Condition (NU) and, in particular, it allows us to
unfold w.r.t.~a negative literal  also if the body of a
clause defining~ contains occurrences of negative literals.
The following is an example of a correct, admissible transformation 
sequence which violates Condition (NU).

\begin{example}\label{ex:not_seki}\nopagebreak 
Let us consider the initial program  , \ \ 
\ \ 
, \ \ 

and the transformation sequence we now construct starting from~.
By rule R1 we introduce the following clause

: 

\noindent and we derive . 
By taking a local stratification function  such that, 
for all ground terms~ and , , we have that  is \mbox{-tight} and
 is a \mbox{-maximal} atom in its body.
By unfolding  w.r.t.  we derive 
,
where

: \hspace{2cm}

: 

\noindent
By unfolding, clause  is removed and we derive
. By unfolding 
w.r.t.~ we derive , where

: 

\noindent
By unfolding
 w.r.t.~, we derive , where

: 

\noindent
By applying rule R6, we fold clause  using
clause  and derive the final program , where

: .

\noindent The transformation
sequence  is admissible and, thus, correct. In particular, the
application of rule R6 satisfies Condition~(2) of
Definition~\ref{def:adm-transformation} because  is -tight
and 
is a descendant of  which has been derived by unfolding 
w.r.t.~a -maximal atom whose predicate occurs in . 

Note that,  violates Condition (NU) 
because, by unfolding clause  
w.r.t.~,
the number of positive occurrences of atoms in
the body of the derived clause  is larger
than that number in .
\end{example}

Finally, note that the incorrect transformation sequence of
Example~\ref{ex:seki} is {\it{not}} an admissible transformation
sequence in the sense of our
Definition~\ref{def:adm-transformation}, because it does not comply
with Condition (2). Indeed, consider any local stratification .
The atom  is not -maximal in  because  depends  on  and, hence,
. Thus, the positive folding rule R6 is
applied to the clause  which is not a descendant of any
clause derived by unfolding w.r.t.~a -maximal atom.

\section{Verifying Properties of -Programs by
Program Transformation}
\label{sec:verification}

In this section we will outline a general method, based on the
transformation rules presented in Section~\ref{sec:rules},
for verifying properties of -programs.
Then we will see our transformation-based
verification method in action in the proof of: (i)~the
non-emptiness of the language accepted by a B\"{u}chi automaton, 
and (ii)~containment between -regular languages.

We assume that we are given an -program  
defining a unary predicate {\it prop} of type {\tt ilist},
which specifies a property of interest,
and we want to check whether or not .
Our verification method consists of two steps. 

\smallskip

\noindent {\em Step 1.} 
By using the transformation rules for  -programs presented in 
Section~\ref{sec:rules} we derive a {\em monadic} -program 
(see Definition~\ref{def:monadic_omega_programs} below), such that

 iff .

\smallskip

\noindent {\em Step 2.} 
We apply to  the decision procedure of~\cite{Pe&09b} for
monadic -programs and we check whether or not 
.

\smallskip

Our verification method is an extension to -programs of
the transformation-based method for proving properties of logic programs on
finite terms presented in~\cite{PeP00a}. 
Furthermore, our method is more powerful than the transformation-based
method for verifying CTL properties of finite state reactive
systems presented in~\cite{Pe&09b}. Indeed, at Step 1 of the verification
method proposed here,
(i)~we start from an arbitrary -program,
instead of an -program which encodes the
branching time temporal logic CTL, and 
(ii)~we use transformation rules more powerful than those in~\cite{Pe&09b}.
In particular, similarly to~\cite{PeP00a}, the rules
applied at Step 1 allow us to
eliminate the existential variables from program , while the
transformation presented in~\cite{Pe&09b} consists of a specialization
of the initial program w.r.t.~the property to be verified.

Note that there exists no algorithm which always succeeds in transforming an
\mbox{-program} into a monadic -program.
Indeed, (i) the problem of verifying whether or not, for any -program
 and unary predicate {\it prop},
 is undecidable, 
because the class of \mbox{-programs} includes
the locally stratified logic programs on finite terms,
and (ii) the proof method for monadic
-programs presented in~\cite{Pe&09b} is complete.
However, we believe that automatic transformation strategies
can be proposed for significant subclasses of \mbox{-programs} along the lines 
of~\cite{PrP95a,PeP00a}.

\begin{definition} [Monadic -Programs]
\label{def:monadic_omega_programs}\rm A~{\em monadic}
\mbox{-clause} is an -clause of the form
, with , such
that: (i)~ is an atom of the form~ or~,
where~ is a predicate of type~\texttt{ilist} and
, (ii)~for   is either an atom
 or a negated atom , where  is of the form 
or , and  is a predicate of type~\texttt{ilist}, and
(iii)~there exists a level mapping  such that, for
 if  is an atom and
, then
 else . A~{\em monadic
-program} is a finite set of monadic -clauses.
\end{definition}

\vspace*{-2mm}

\begin{example}[Non-Emptiness of Languages Accepted by B\"{u}chi Automata]
\label{ex:buechi}

In this first application of our verification method,
we will consider {\em B\"{u}chi automata},
which are finite automata acting on infinite words~\cite{Tho90}, 
and we will check whether or not the language 
accepted by a {B\"{u}chi automaton} is empty. 
It is
well known that this verification problem has important applications
in the area of model checking (see, for instance,~\cite{Cl&99}).

A {\em B\"{u}chi automaton}  is a nondeterministic finite automaton
 , where, as usual,  is the input
alphabet,  is the set of states,  is the initial state,
 is the transition
relation, and  is the set of final states. A~{\em run} of the
automaton~ on an infinite input word
 is an infinite sequence
 of states such that 
is the initial state  and, for all~, . Let 
denote the set of states that occur infinitely often in the
infinite sequence~ of states. An infinite word
 is {\em accepted} by  if there
exists a run  of  on  such that
 or, equivalently, if there is
no state  in  such that every  state ,
with , is not final. The {\em language accepted} by 
is the subset of , denoted , of the
infinite words accepted by~.
In order to check whether or not the language  is
empty, we construct an -program which defines a unary predicate 
{\it{accepting\_run}} such that:

\smallskip
\noindent\makebox[5mm][l]{}~~~iff~~

\smallskip
\noindent The predicate  is defined by the
following formulas:

\smallskip
\noindent\makebox[5mm][l]{()}~

\smallskip
\noindent\makebox[5mm][l]{(2)}~\\
\noindent\makebox[9mm][l]{} 

\smallskip
\noindent\makebox[5mm][l]{(3)}~

\smallskip
\noindent where, for all , for all , for all
, for all , 
(i)~ iff , 
(ii)~ iff , 
(iii)~ iff , 
(iv)~ iff 
     , 
(v)~ iff , and
(vi)~ iff .

By  and (1)--(3) above,  iff there
exists an infinite sequence  of
states such that: (i)~ is the initial state , (ii)~for 
all , there exists  such that 
 (see (2)), and (iii)~there exists no state 
, with , in   such that, for all ,  (see (3)).

Now we introduce an 
-program  defining the predicates
{\it {accepting\_run}}, {\it run}, {\it{rejecting}},
, , and~.
In particular, clause~1 corresponds to formula (1),
clauses~2--4 correspond to formula (2), and
clauses~5 and~6 correspond to formula~(3). 
(Actually, 
clauses 1--6 can be derived from formulas~(1)--(3)
by applying the Lloyd-Topor transformation~\cite{Llo87}.)
In program
 any infinite sequence  of states is
represented by the infinite list
 of constants.

Given a B\"{u}chi automaton , the encoding -program
 consists of the following clauses (independent of
):

\smallskip

\makebox[2mm][r]{1.}~

\makebox[2mm][r]{2.}~

\makebox[2mm][r]{3.}~


\makebox[2mm][r]{4.}~

\makebox[2mm][r]{5.}~

\makebox[2mm][r]{6.}~

\makebox[60mm][l]{\makebox[2mm][r]{7.}~}

\makebox[2mm][r]{8.}~

\makebox[60mm][l]{\makebox[2mm][r]{9.}~}

\makebox[2mm][r]{10.}~


\makebox[60mm][l]{\makebox[2mm][r]{11.}~}

\makebox[2mm][r]{12.}~

\smallskip

\noindent together with the clauses (depending on )
which define the predicates , , and
, where: for all states~, for all
symbols~, (i)~ holds iff
 is , (ii)~ holds iff , and (iii)~
holds iff .
 
The -program  is locally stratified w.r.t.~the
stratification function  defined as follows: for every atom
 in , , except that: for every
element  in \mbox{,} for every infinite list
 in ,
(i)~, and (ii)~ {\Mathit{ac\-cept\-ing\_run}}.

Now,  let us consider a B\"{u}chi automaton
 such that:

, , ,
, 

\noindent which can be represented by the following graph:

\vspace{-1.5mm}
\begin{center}
\includegraphics[bb=80mm 244mm 125mm 263mm,clip,width=35mm]{buechi.ps}
\end{center}
\vspace{-1mm}

\noindent For this automaton , program  consists of clauses 1--12 
and the following clauses~\mbox{13--18} that encode
 the initial state (clause~13), the transition relation \linebreak
(clauses~14--17), and the final state (clause~18):

\smallskip

\makebox[30mm][l]{\makebox[3mm][r]{13.}~}
\makebox[30mm][l]{\makebox[3mm][r]{14.}~}
\makebox[30mm][l]{\makebox[3mm][r]{15.}~}

\makebox[30mm][l]{\makebox[3mm][r]{16.}~}
\makebox[30mm][l]{\makebox[3mm][r]{17.}~}
\makebox[3mm][r]{18.}~

\smallskip
\noindent \noindent \noindent In order to check whether or not  we proceed in two steps as indicated at the 
beginning of this Section~\ref{sec:verification}. 
In the first step we use
the rules of Section~\ref{sec:rules} for transforming the
-program  into a monadic -program~.
This transformation aims at the elimination of the existential variables
from clauses~1--6, with the objective of deriving unary
predicates of type {\texttt{ilist}}. We start from clause~6 and, by
instantiation of the variable  of type {\texttt{ilist}}, we get:

\smallskip

\makebox[3mm][r]{19.}~

\makebox[3mm][r]{20.}~

\smallskip

\noindent By some unfolding and subsumption steps, from clauses 19 and 20 we
get:

\smallskip

\makebox[3mm][r]{21.}~

\makebox[3mm][r]{22.}~

\makebox[3mm][r]{23.}~

\makebox[3mm][r]{24.}~

\smallskip

\noindent Note that clauses 21--24 are descendants of clauses derived by
unfolding clauses~19 and 20 w.r.t. the -maximal atom
. By rule R1, we introduce:

\smallskip

\makebox[3mm][r]{25.}~

\smallskip

\noindent This clause is -tight by taking, for
every infinite list  of states, . By
folding clause 21 using clause 25, and folding clauses 22 and 24 using clause~6
(indeed, without loss of generality, we may assume that clauses 1--6 have been
introduced by rule R1), we get:

\smallskip

\makebox[3mm][r]{26.}~

\makebox[3mm][r]{27.}~

\makebox[3mm][r]{28.}~

\smallskip

\noindent By instantiation of the variable  and by some unfolding and
subsumption steps, from clause 25 we get:

\smallskip

\makebox[3mm][r]{29.}~\hspace{2cm}

\makebox[3mm][r]{30.}~

\smallskip

\noindent Note that clause 29 is a descendant of clause~25, that has
been unfolded w.r.t. the -maximal atom . By folding clause 29 using clause 25 we get:

\smallskip

\makebox[3mm][r]{31.}~

\smallskip

\noindent At this point we have obtained the definitions of the
predicates  and  (that is,
clauses~23, 26--28, 30, and 31) that do not have existential variables.

Now the transformation of program  proceeds by
performing on clauses~1--5 a sequence of transformation steps,
which is similar to the one we have performed above on clause~6 for
eliminating its existential variables. By doing so, we get:

\smallskip
\makebox[3mm][r]{32.}~

\makebox[3mm][r]{33.}~

\makebox[3mm][r]{34.}~

\makebox[65mm][l]{\makebox[3mm][r]{35.}~}

\makebox[65mm][l]{\makebox[3mm][r]{36.}~}

\makebox[65mm][l]{\makebox[3mm][r]{37.}~}

\makebox[3mm][r]{38.}~

\makebox[3mm][r]{39.}~

\makebox[3mm][r]{40.}~

\smallskip
\noindent The final -program  obtained from program
, consists of clauses 30--40 and it
is a monadic -program.

Now, in the second step of our verification method, we check whether
or not  holds in  by
applying the proof method of~\cite{Pe&09b}. We construct
the tree depicted in Figure~\ref{fig:proof-ex1}, where the literals
occurring in the two lowest levels are the same (see the two rectangles) 
and, thus, we have detected an infinite loop.
According to the conditions given in Definition~6 of~{\protect\cite{Pe&09b}}, this tree
is a proof of . The run
 is a witness for  and corresponds to the
accepted word~. Thus, .

\begin{figure}
 \setlength{\unitlength}{1mm}\begin{picture}(120,32)(0,-32)\thicklines

\put(37,-4){\makebox[16mm][l]{}}
\put(50,-5){\line(6,-1){38}}\put(24,-8){\footnotesize }
\put(50,-5){\line(-6,-1){38}}\put(58.5,-10){\footnotesize }
\put(50,-5){\line(3,-2){10}}\put(74,-8){\footnotesize }

\put(0,-14){\makebox[16mm][l]{}}
\put(53,-14){\makebox[16mm][l]{}}
\put(78,-14){\makebox[16mm][l]{}}

\put(12,-15.3){\line(0,-1){6.5}}\put(9.5,-19){\footnotesize }
\put(12,-15.3){\line(3,-1){18}}\put(23,-18){\footnotesize }
\put(60,-15){\line(0,-1){6.5}}\put(61,-19){\footnotesize }
\put(90,-15){\line(0,-1){6.5}}\put(91,-19){\footnotesize }

\put(5,-24){\makebox[16mm][l]{}}
\put(23,-24){\makebox[16mm][l]{}}
\put(57,-24){\makebox[16mm][l]{}}
\put(78,-24){\makebox[16mm][l]{}}

\put(12,-25){\line(0,-1){6.5}}\put(9.5,-29){\footnotesize }
\put(36,-25.3){\line( 0,-1){6.2}}\put(33.5,-29){\footnotesize }
\put(36,-25.3){\line(3,-1){18}}\put(47,-28){\footnotesize }
\put(90,-25){\line(0,-1){6.5}}\put(91,-29){\footnotesize }

\put(9,-34){\makebox[16mm][l]{}}
\put(24,-34){\makebox[16mm][l]{}}
\put(44,-34){\makebox[16mm][l]{}}
\put(78,-34){\makebox[16mm][l]{}}

\thinlines
\put(3,-35.5){\line(1,0){100}}
\put(3,-30.5){\line(1,0){100}}
\put(3,-30.5){\line(0,-1){5}}
\put(103,-30.5){\line(0,-1){5}}
\put(3,-25.5){\line(1,0){100}}
\put(3,-20.5){\line(1,0){100}}
\put(3,-20.5){\line(0,-1){5}}
\put(103,-20.5){\line(0,-1){5}}
\put(104.4,-28.5){\oval(5,10)[r]}
\put(104.4,-33.55){\line(-1,0){0.8}}
\put(104.4,-23.53){\vector(-1,0){1}}

\put(115,-3.5){\circle*{1.5}}\put(115,-4.5){\vector(0,-1){8}}
\put(116,-9){\footnotesize }
\put(115,-13.5){\circle*{1.5}}\put(115,-14.5){\vector(0,-1){8}}
\put(116,-19){\footnotesize }
\put(115,-23.5){\circle*{1.5}}\put(115,-24.5){\vector(0,-1){8}}
\put(116,-29){\footnotesize }
\put(115,-33.5){\circle*{1.5}}\put(117,-28.5){\oval(5,10)[r]}
\put(117,-33.55){\line(-1,0){0.8}}
\put(117,-23.53){\vector(-1,0){1}}
\end{picture}
\vspace{2mm}
\caption{Proof of 
w.r.t.~the monadic -program . On the right we have shown the infinite loop and
the associated accepting run  (that is, ).
\label{fig:proof-ex1}}
\vspace{-2mm}
\end{figure}
\end{example}

\begin{example}[Containment Between -Regular Languages]

In this second application of our verification method, we will consider
regular sets of infinite words over a finite alphabet ~\cite{Tho90}. 
These sets are
denoted by -regular expressions whose syntax is defined as follows: 

\smallskip
\makebox[45mm][l]{}\makebox[25mm][l]{with }(regular expressions)

\smallskip
\makebox[70mm][l]{}(-regular expressions)

\smallskip
\noindent Given a regular (or an -regular) expression ,
by  we indicate the set of all words in  
(or , respectively) denoted by~.
In particular, given a regular expression , we have that
for~.

Now we introduce an -program, called
, which defines the predicate - such
that for any -regular expression , for any infinite word~,
\mbox{-} holds iff .
Any infinite word  is represented by the infinite
list   of symbols in . 
The -program  is made out of the following clauses:

\smallskip



\makebox[3mm][r]{1.}~

\makebox[3mm][r]{2.}~

\makebox[3mm][r]{3.}~

\makebox[3mm][r]{4.}~

\makebox[3mm][r]{5.}~

\makebox[3mm][r]{6.}~



\makebox[65mm][l]{\makebox[3mm][r]{7.}~--}

\makebox[3mm][r]{8.}~--

\makebox[3mm][r]{9.}~-



\makebox[3mm][r]{10.}~--

\makebox[3mm][r]{11.}~

\makebox[3mm][r]{12.}~

\makebox[3mm][r]{13.}~--

\makebox[3mm][r]{14.}~--


\makebox[47mm][l]{\makebox[3mm][r]{15.}~}

\makebox[3mm][r]{16.}\makebox[70mm][l]{~}

\makebox[47mm][l]{\makebox[3mm][r]{17.}~}

\makebox[3mm][r]{18.}~

\makebox[47mm][l]{\makebox[3mm][r]{19.}~}

\makebox[3mm][r]{20.}~





\makebox[47mm][l]{\makebox[3mm][r]{21.}~}

\makebox[3mm][r]{22.}~

\smallskip

\noindent together with the clauses defining the predicate
, where  holds iff .
We have that  holds iff  is the list of the 
leftmost symbols of the infinite list .
Clauses 1--6 stipulate that, for any finite word  and regular expression~,
 holds iff . Analogously,
clauses 7--14 stipulate that, for any infinite word~ and
-regular expression~, \mbox{-} holds iff
. In particular, clauses 9, 11, and 12 correspond to the
following definition:

\smallskip
-

\hspace*{15mm}

\smallskip
\noindent The -program  is stratified and, thus, locally stratified.

Now, let us consider the -regular expressions  
and . The following two clauses:

\smallskip
\makebox[60mm][l]{\makebox[3mm][r]{23.}~-} \makebox[3mm][r]{24.}~-

\smallskip
\noindent together with program , define the predicates
 and  such that, for every
infinite word ,  holds iff  and  holds iff .
If we introduce the following clause:

\smallskip
\makebox[3mm][r]{25.}~

\smallskip
\noindent 
we have that  iff .
By performing a sequence of transformation steps which is similar to the one
we have performed in Example~\ref{ex:buechi}, from program
 we get the following monadic -program :

\smallskip
\makebox[78mm][l]{\makebox[1mm][r]{26.}\,}
\makebox[1mm][r]{31.}\,

\makebox[78mm][l]{\makebox[1mm][r]{27.}\,}
\makebox[1mm][r]{32.}\,

\makebox[78mm][l]{\makebox[1mm][r]{28.}\,}
\makebox[1mm][r]{33.}\,

\makebox[78mm][l]{\makebox[1mm][r]{29.}\,}
\makebox[1mm][r]{34.}\,

\makebox[78mm][l]{\makebox[1mm][r]{30.}\,}
\makebox[1mm][r]{35.}\,

\smallskip
\noindent By using the proof
method for monadic -programs
of~\cite{Pe&09b} we have that  and, thus, .
\end{example}


\section{Related Work and Conclusions}
\label{sec:related}

There have been various proposals for extending logic programming languages to
infinite structures (see, for instance,~\cite{Col82,Llo87,MiG09,Si&06}). 
In order to provide the semantics of infinite
structures, these
languages introduce new concepts, 
such as {\em complete Herbrand interpretations}, {\em rational
trees}, and {\em greatest models}. Moreover, the operational semantics of these
languages requires an extension of SLDNF-resolution by means of equational reasoning 
 and new inference rules, such as the so-called {\em coinductive hypothesis} rule.

On the contrary, the semantics of -programs we consider in this paper is very
close to the usual perfect model semantics for logic programs
on finite terms, and we do not define any new operational semantics.
Indeed, the main objective of this paper is {\em not} to provide a
new model for computing over infinite structures, but to present a
methodology, based on unfold/fold transformation rules, for reasoning about
such structures and proving their properties.

Very little work has been done for applying transformation techniques to
logic languages that specify the (possible infinite) 
computations of reactive systems.  Notable
exceptions are~\cite{UeF88} and~\cite{Et&01}, where the unfold/fold
transformation rules have been studied in the context of {\em
guarded Horn clauses} (GHC) and {\em concurrent constraint programs}
(CCP). However, GHC and CCP programs are {\em definite} programs and
do not manipulate terms denoting infinite lists. 

The transformation rules presented in this paper extend to 
-programs the
rules for general programs proposed 
in~\cite{Fi&04a,PeP00a,Ro&02,Sek91,Sek09}. In 
Sections~\ref{sec:rules} and~\ref{sec:corr_of_rules}
we discuss in detail 
the relationship of the rules in those papers with our rules here.

In Section~\ref{sec:verification} we have used our transformation 
rules for extending to infinite lists a verification
methodology proposed in~\cite{PeP00a} 
and, as an example, we have shown how to verify
properties of the infinite behaviour of B\"uchi automata and 
properties of -regular languages.
This extends our previous work (see~\cite{Pe&09b}), as already
illustrated at the beginning of Section~\ref{sec:verification}.

The verification methodology based on transformations we have 
proposed here is very general. It can be applied to the proof 
of properties of infinite state reactive systems; thus it goes 
beyond the capabilities of finite state model checkers.
The focus of our paper has been the proposal of correct 
transformation rules, that is, rules which preserve the
perfect model, while the automation of the verification 
methodology itself is 
left for future work.
This automation 
requires the design of suitable transformation strategies that can be 
defined by adapting to -programs some strategies 
already developed in the case of logic programs on finite 
terms (see, for instance,~\cite{PrP95a,PeP00a}).

Many other papers use logic programming, possibly with constraints,
for specifying and verifying properties of finite or infinite state 
reactive systems~(see, 
for instance,~\cite{AbM89,DeP01,FrO97a,Ja&04,LeM99,NiL00,Ra&97}), but 
they do not consider terms which explicitly represent infinite
structures. As we have seen in the examples of Section~\ref{sec:verification}, 
infinite lists are very convenient for specifying those properties
and the use of infinite lists avoids
 ingenious encodings which would have been otherwise required.







\newpage

\appendix

\section{Proofs for Section~\ref{sec:corr_of_rules}}
\label{appendix:corr_of_rules}

We start off by showing that admissible transformation sequences
preserve the local stratification~ for the initial
program  as stated in the following lemma.

\medskip

\noindent {\bf Lemma~\ref{lem:sigma-preservation} (Preservation of
Local Stratification)}

\noindent Suppose that  is a locally stratified
-program,  is a local stratification for , and
  is an admissible transformation sequence. Then
the programs {\it{Defs}}, 
are locally stratified
w.r.t.~.

\begin{proof}
Since  is an admissible transformation
sequence, every definition in  
is locally stratified w.r.t.~ (see Point~(1) of
Definition~\ref{def:adm-transformation}). Since, by hypothesis, 
is locally stratified w.r.t.~, also  is locally stratified w.r.t.~.

\noindent Now we will prove that, for ,  is locally stratified w.r.t.~ by induction on .

\medskip

\noindent \emph{Basis} (. By hypothesis  is
locally stratified w.r.t.~.

\medskip

\noindent \emph{Step}. We assume that  is
locally stratified w.r.t.~ and we show that  is locally stratified w.r.t.~. We proceed by cases
depending on the transformation rule which is applied to derive  from~.

\medskip

\noindent \emph{Case} 1. Program  is derived by
definition introduction (rule R1). We have that , where  is locally
stratified w.r.t.~ by the inductive hypothesis. Since
 is an admissible transformation sequence, 
 
is locally stratified w.r.t.~
(see Point~(1) of Definition~\ref{def:adm-transformation}). Thus,  is locally
stratified w.r.t.~.

\medskip

\noindent \emph{Case} 2. Program  is derived by
instantiation (rule R2). We have that
,
where  is the clause  and, for
,  is the clause . 

\noindent Take any . 
Let  be a literal in the body of . Let 
be any valuation and  be the valuation such that
 and  for every
variable  different from . We have:

\smallskip

\makebox[3.3cm][l]{}
\makebox[4cm][l]{}
 (definition of )

\hspace*{3.3cm} \makebox[4cm][l]{} ( is
locally stratified w.r.t.~)

\hspace*{3.3cm} \makebox[4cm][l]{} (definition of )

\smallskip

\noindent Thus,  is locally stratified w.r.t.~.
Hence,  is locally stratified w.r.t.~.

\medskip

\noindent \emph{Case} 3. Program  is derived by
positive unfolding (rule R3). We have that ,
where  is a clause in  of the form  and clauses  are derived by unfolding 
w.r.t.~. Since, by the induction hypothesis,  is locally stratified w.r.t.~,
it remains to show that, for , clause  is locally stratified w.r.t.~. For ,  is of the form , where :  is a clause in a variant of   
such that  has no variable in common with  and
. Take any valuation  and let
 be a valuation such that, for every variable  occurring in
 or , .

Let  be the conjunction of 
literals . Without loss of generality, we assume
that  is  and  is
, with .

\noindent For , we have:

\smallskip

\makebox[1.75cm][l]{} \makebox[3cm][l]{} (definition of )

\hspace*{1.75cm} \makebox[3cm][l]{} (
is locally stratified w.r.t.~)

\hspace*{1.75cm} \makebox[3cm][l]{}
(definition of )

\smallskip

\noindent \noindent For , we have:


\smallskip

\makebox[1.75cm][l]{} \makebox[3cm][l]{} (definition of )

\hspace*{1.75cm} \makebox[3cm][l]{} ( is
locally stratified w.r.t.~)

\hspace*{1.75cm} \makebox[3cm][l]{} (definition of
 and because )

\hspace*{1.75cm} \makebox[3cm][l]{}
( is locally stratified w.r.t.~)

\hspace*{1.75cm} \makebox[3cm][l]{}
(definition of )

\smallskip

\noindent Thus, the clause  is locally stratified
w.r.t.~.

\medskip

\noindent \emph{Case} 4. Program  is derived by
negative unfolding (rule R4). We have that ,
where  is a clause in  of the form  and clauses  are derived by negative unfolding  w.r.t.~. Since, by the inductive hypothesis,
 is locally stratified w.r.t.~,
it remains to show that, for , clause  is locally stratified w.r.t.~.

Let :   :
 be the clauses in a variant of 
such that, for ,  for
some substitution . Then,  for ,  is of the form  and, by construction, for ,  is a
literal such that either (Case~a)~ is an atom that occurs
positively in , or (Case~b)~ is a negated
atom that occurs in , or (Case~c)~ is an atom
 and  occurs in , for some , or (Case~d)~ is a negated atom 
and  is an atom that occurs positively in , for
some .

Take any .
Take any . Take any valuation . In Cases~(a) and (b) we have
 because, by the inductive
hypothesis,  is locally stratified w.r.t.~. 
In Case~(c) we have:

\smallskip

\makebox[1.4cm][l]{} \makebox[3cm][l]{} ( is locally stratified w.r.t.~ and

\makebox[48mm][l]{}
 occurs in the body of )

\hspace*{1.4cm} \makebox[3cm][l]{}
()

\hspace*{1.4cm} \makebox[3cm][l]{} (
is locally stratified w.r.t.~)

\smallskip

\noindent In Case (d) we have:
\smallskip

\makebox[1.4cm][l]{} \makebox[3cm][l]{} ( is locally stratified
w.r.t.~ and 

\makebox[48mm][l]{}
 occurs in the body of )

\hspace*{1.4cm} \makebox[3cm][l]{}
()

\hspace*{1.4cm} \makebox[3cm][l]{}
( is locally stratified w.r.t.~)

\smallskip

\noindent Thus,  is locally stratified w.r.t.~. Hence,  is locally stratified w.r.t.~.

\medskip

\noindent \emph{Case} 5. Program  is derived by
subsumption (rule R5).  is locally stratified w.r.t.~ by the inductive hypothesis because . 


\medskip

\noindent \emph{Case} 6. Program  is derived by
positive folding (rule R6). We have that , where  is a clause of the form  derived by positive
folding of clause  of the form  using a clause  of the form . We have to show that 
is locally stratified w.r.t.~, that is, for every valuation
, . 

Take any
valuation~. 
By the inductive hypothesis, since  is locally stratified 
w.r.t.~, we have that: ~for every literal 
occurring in , we have . 

By the applicability conditions of rule R6, clause
 is the unique clause defining the predicate of its head and, by the
hypothesis that the transformation sequence is admissible, this
definition is -tight (see Point~(2) of
Definition~\ref{def:adm-transformation}). Thus, for every
valuation~, we have that: (1)~for every  in , 
,
and (2)~there exists an atom  in  such that 
. 


Let the valuation  be defined as follows: for every variable ,
. Then, we have that: 
~for every  in , ,
and ~there exists an atom  in  such that 
. 
Thus, from , , and , we get that
. Hence,  is locally stratified
w.r.t.~.

\medskip

\noindent \emph{Case} 7. Program  is derived by
negative folding (rule R7). We have that  and, by the hypothesis that the transformation
sequence is admissible,  is locally stratified
w.r.t.~ (see Point~(3) of
Definition~\ref{def:adm-transformation}).
\end{proof}

\medskip
In the rest of this Appendix we will consider:

\noindent
\makebox[6mm][r]{(i)}~a local stratification~, 

\noindent
\makebox[6mm][r]{(ii)}~an -program  
which is locally stratified w.r.t.~, and 

\noindent
\makebox[6mm][r]{(iii)}~an
admissible transformation sequence . 


\begin{definition}[Old and New Predicates, Old and New Literals]
\label{def:old-new}Each predicate
occurring in  is called an {\em old predicate} and each
predicate introduced by rule {\rm{R1}} is called a {\em new
predicate}. An {\em{old literal}} is a literal with an old predicate.
A {\em{new literal}} is a literal with a new predicate.
\end{definition}

Thus, the new predicates are the ones
which occur in the heads of the clauses of .

Without loss of generality, we will assume that the admissible
transformation sequence  is of the form , with , where:

\smallskip

\noindent \textup{(1)} the sequence , with
, is constructed by applying  times the
definition introduction rule, and

\noindent \textup{(2)} the sequence , is
constructed by applying any rule, except the definition introduction
rule R1.

\smallskip{}

\noindent Thus, . In order to
prove the correctness of the admissible transformation sequence
 (see
Proposition~\ref{prop:preserv-mu-consistency} below) we will show that
. In order to prove
Proposition~\ref{prop:preserv-mu-consistency}, we introduce
the notion of a {\em proof tree}  which is the proof-theoretic counterpart of the perfect model semantics (see
Theorem~\ref{th:proof_trees_perfect_model} below). 
A proof tree for an atom  and a locally stratified -program
 is constructed by transfinite induction as indicated in the
following definition.

\begin{definition}[Proof Tree for Atoms and Negated Atoms]
\label{def:proof_tree}  Let  be an atom in
, let  be a locally stratified
-program, and let  be a local stratification for
. Let  denote the set of proof trees for  and
, where  and . 

\noindent
A \emph{proof tree} for  and  is a finite tree
 such that\/{\rm :} 

\hangindent=8mm\noindent
\makebox[6mm][r]{\rm{(i)}}~the root of  is labeled by ,

\noindent
\makebox[6mm][r]{\rm{(ii)}}~a node  of  has children labeled by   iff  is labeled by an atom
 and there exist a clause  and a valuation  such that  is , and 

\noindent
\makebox[6mm][r]{\rm{(iii)}}~every leaf
of  is either labeled by the empty conjunction  or by a negated atom~, with
, such that there is no proof tree for
 and  in .

\hangindent=0mm\smallskip
\noindent Let  be an atom in 
and  be a locally stratified
-program. 

\noindent A \emph{proof tree} for~ and  exists iff there are no proof
trees for~ and . There exists at most one proof tree 
for~ and  and, when it exists, it consists of the single root node labeled by~.

\end{definition}

\vspace{-3mm} 
\noindent
\begin{remark}\label{rem:proof-tree} 
{\rm(i)}~For any 
 
if  there is a proof tree for~ and , then
there is no proof tree for  and~.

\noindent
{\rm(ii)}~In any proof tree if a node  is an ancestor of a 
node  then
.
\end{remark}

The following theorem, whose proof is omitted, shows that proof trees
can be used for defining a semantics equivalent to the perfect model
semantics.

\begin{theorem}[Proof Tree and Perfect
Model] \label{th:proof_trees_perfect_model}  Let  be a
locally stratified -program. For every , there exists a proof tree for 
and  iff .
\end{theorem}

In order to show that , we will use
Theorem~\ref{th:proof_trees_perfect_model} and we will show that,
given any atom , there exists a proof
tree for  and  iff there exists a proof tree for
 and~. 

\smallskip
In the following, we will use suitable \emph{measures} which we now introduce.

\begin{definition}[Three Measures:   ] 
\label{def:measure} \hangindent=7mm{\rm{(i)}}~For any proof tree , 
denotes the number of nodes in~ labeled by atoms in
.

\noindent {\rm{(ii)}}~For any atom , the ordinal  is said 
to be the {\em{stratum}} of . 

\hangindent=7mm\hspace{3mm}For any ordinal , for any proof tree ,
 is the number of nodes 
of  whose label is an atom with stratum .
{\rm{(}}Recall that , that is,
the empty conjunction of literals, is {\it{not}} an atom.{\rm{)}}





\noindent {\rm{(iii)}}~For any atom , we
define\/{\rm{:}}

\smallskip

\hspace*{8mm}

\makebox[69mm][l]{}A.

\smallskip

\noindent {\rm{(iv)}}~For any atom  such that 
 there exists at least a proof tree for  and , we
define\/{\rm{:}}
\smallskip{}

\hspace*{8mm}\makebox[18mm][l]{}
\makebox[45mm][l]{}   is an old atom

\hspace*{8mm}\makebox[18mm][l]{}
\makebox[45mm][l]{{\mathit{if}}~AAP_d\mu (\neg A)=_{\mathit{def}}\langle \sigma (A),0\rangle A\in\mathcal{B}_{\omega}  \mu (A)  A  P_d  \mu  \oplus:\, (W\times \mathbb
N)^{2}\rightarrow (W\times \mathbb{N})  L_{1}\wedge \ldots
\wedge L_{r}  \mu (L_{1}\wedge \ldots \wedge L_{r})=_{\mathit{def}} \mu (L_{1})\oplus \cdots
\oplus \mu (L_{r}) A\in\mathcal{B}_{\omega}\mu A \mathcal{B}_{\omega}  P_{d},\ldots,P_{n}  T  A  P_{k} \mu H
L_{1},\ldots ,L_{r}  H  T  \mu (H)\geq_{\mathit{lex}}\mu
(L_{1})\oplus \cdots \oplus \mu (L_{r})  \mu
(H)>_{\mathit{lex}}\mu (L_{1})\oplus \cdots \oplus \mu (L_{r}) B L  B  T 
\gamma \in P  v  v(\gamma )  B\leftarrow L_{1}\wedge \ldots \wedge L_{r} 
P_{0},\ldots ,P_{d}  P_{0},\ldots ,P_{d},\ldots
,P_{n} 
P_{0},\ldots ,P_{d}  A \in \mathcal{B}_{\omega} A  P_{k}  A
 P_d\mu
 A  P_d \mu A  P_{k} A\in\mathcal{B}_{\omega}  P_{k+1}  A 
 P_{k} A\in\mathcal{B}_{\omega} \mu P_k \mu A   P_{k+1}  \sigma
(A)  A  A'\in\mathcal{B}_{\omega}  \sigma (A')\! <\! \sigma (A)  A'   P_{k+1}  A'   P_{k}  A'\in\mathcal{B}_{\omega}  \sigma (A')\! <\! \sigma (A) 
\mu A'   P_{k} \mu  A' 
P_{k+1} A'\in\mathcal{B}_{\omega}  \sigma (A')\! <\! \sigma (A)  A'   P_{k}  A'   P_{k+1}  U  A
  P_{k+1}  T  A   P_{k}  \mathit{size}(U) A'\in\mathcal{B}_{\omega} U'   P_{k+1} 
\mathit{size}(U')<\mathit{size}(U)  T'  A'   P_{k}  \eta    P_{k+1}  v  v(\eta) U  \eta   P_{k}  \eta   P_{k} P_{k}  i=1,\ldots ,r 
T_{i}   P_{k}  L_{i}  T_{i}  L_{i}   P_{k}  L_{i}  \neg A_{i}   P_{k+1}  \sigma
 A_{i}   P_{k}  T_{i}   P_{k}  \eta   \eta   \eta   \eta   \eta \mu  A   P_{k}  \mu  A 
 P_{k+1}  \mu  A'\in\mathcal{B}_{\omega}
 A\succ A' \mu  T'  A'  P_{k} \mu U'  A'   P_{k+1}  \gamma    P_{k}  v  v(\gamma) 
A\leftarrow L_{1}\wedge \ldots \wedge L_{r}  T 
\gamma   P_{k+1}  \gamma   P_{k+1}  i=1,\ldots ,r U_{i}  L_{i}  P_{k+1}  i=1,\ldots ,r  i=1,\ldots ,r U_{i}  L_{i}  P_{k+1} 
i=1,\ldots ,q i=2,\ldots ,r  i=1,\ldots ,q,V_{i}  M_{i}  P_{k+1} 
i=2,\ldots ,r U_{i}
 L_{i}  P_{k+1}  i=1,\ldots ,m,V_{i}  P_{k+1}  i=2,\ldots ,r U_i L_{i}  P_{k+1}
 \eta   i=q+1,\ldots,r U_{i}  L_{i}  P_{k+1}  i=q\!+\!1,\ldots ,r U_{i}  L_{i}  P_{k+1} . A proof tree  for  and  is
constructed by using   at the root of  and the proof trees  for , respectively,
and .

In order to show that  is -consistent we need to consider two cases. 

In
the first case, we assume that  is old or  is -max derived. Thus, in this case, also  is -max derived. By -consistency of , we
have . By
Lemma~\ref{lemma:properties_of_oplus}~(ii.5), we have that . Since the transformation sequence  is admissible, clause  is locally
stratified and, thus, . Hence,
 \{by definition of 
 \{by definition of . Therefore, by 
Lemma~\ref{lemma:properties_of_oplus}~(ii.4), we have that: . Thus,  is 
\mbox{-consistent.}

In the second case,  is new and  is not -max derived. As a
consequence, also  is not -max derived. By -consistency of
 we have . And, by
Lemma~\ref{lemma:properties_of_oplus}~(ii.5), . Since  (see the first case), 
by Lemma~\ref{lemma:properties_of_oplus}~(ii.4), we have that:
. Thus,  is
-consistent. This completes the proof.
\end{proof}

\medskip
The correctness of admissible transformation sequences, that is,
Theorem~\ref{th:corr_of_rules} of
Section~\ref{sec:corr_of_rules}, follows immediately from
Theorem~\ref{th:proof_trees_perfect_model} and
Proposition~\ref{prop:preserv-mu-consistency} because: (i)~, and (ii)~a -consistent proof tree is a
proof tree.

\section*{Acknowledgements}
We thank Hirohisa Seki for stimulating conversations on
the topics of this paper. We also thank John Gallagher for
his comments and 
the anonymous referees of ICLP 2010 for their constructive criticism.

We also acknowledge the financial support of: (i)~PRIN 2008 
(Progetto di Ricerca di Interesse Nazionale)
Project no.~9M932N-003, and (ii)~the GNCS Group of \mbox{INdAM}
(Istituto Nazionale di Alta Matematica) under the grant
`Contributo Progetto 2009'.


\begin{thebibliography}{}

\bibitem[\protect\citeauthoryear{Abadi and Manna}{Abadi and
  Manna}{1989}]{AbM89}
{\sc Abadi, M.} {\sc and} {\sc Manna, Z.} 1989.
\newblock Temporal logic programming.
\newblock {\em Journal of Symbolic Computation\/}~{\em 8,\/}~3, 277--295.

\bibitem[\protect\citeauthoryear{Apt and Bol}{Apt and Bol}{1994}]{ApB94}
{\sc Apt, K.~R.} {\sc and} {\sc Bol, R.~N.} 1994.
\newblock Logic programming and negation: A survey.
\newblock {\em Journal of Logic Programming\/}~{\em 19, 20}, 9--71.

\bibitem[\protect\citeauthoryear{Burstall and Darlington}{Burstall and
  Darlington}{1977}]{BuD77}
{\sc Burstall, R.~M.} {\sc and} {\sc Darlington, J.} 1977.
\newblock A trans\-form\-ation system for developing recursive pro\-grams.
\newblock {\em Journal of the {ACM}\/}~{\em 24,\/}~1 (January), 44--67.

\bibitem[\protect\citeauthoryear{Clarke, Grumberg, and Peled}{Clarke
  et~al\mbox{.}}{1999}]{Cl&99}
{\sc Clarke, E.~M.}, {\sc Grumberg, O.}, {\sc and} {\sc Peled, D.} 1999.
\newblock {\em Model Checking}.
\newblock MIT Press.

\bibitem[\protect\citeauthoryear{Colmerauer}{Colmerauer}{1982}]{Col82}
{\sc Colmerauer, A.} 1982.
\newblock Prolog and infinite trees.
\newblock In {\em Logic Pro\-gramming}, {K.~L. Clark} {and} {S.-{\AA}.
  T{\"a}rnlund}, Eds. Academic Press, 231--251.

\bibitem[\protect\citeauthoryear{Delzanno and Podelski}{Delzanno and
  Podelski}{2001}]{DeP01}
{\sc Delzanno, G.} {\sc and} {\sc Podelski, A.} 2001.
\newblock Constraint-based deductive model checking.
\newblock {\em International Journal on Software Tools for Technology
  Transfer\/}~{\em 3,\/}~3, 250--270.

\bibitem[\protect\citeauthoryear{Etalle, Gabbrielli, and Meo}{Etalle
  et~al\mbox{.}}{2001}]{Et&01}
{\sc Etalle, S.}, {\sc Gabbrielli, M.}, {\sc and} {\sc Meo, M.~C.} 2001.
\newblock Transformations of {CCP} programs.
\newblock {\em ACM Transactions on Programming Languages and Systems\/}~{\em
  23,\/}~3, 304--395.

\bibitem[\protect\citeauthoryear{Fioravanti, Pettorossi, and
  Proietti}{Fioravanti et~al\mbox{.}}{2004}]{Fi&04a}
{\sc Fioravanti, F.}, {\sc Pettorossi, A.}, {\sc and} {\sc Proietti, M.} 2004.
\newblock Transformation rules for locally stratified constraint logic
  programs.
\newblock In {\em Program Development in Computational Logic}, {K.-K. Lau}
  {and} {M.~Bruynooghe}, Eds. Lecture Notes in Computer Science 3049.
  Springer-Verlag, 292--340.

\bibitem[\protect\citeauthoryear{Fribourg and Ols\'en}{Fribourg and
  Ols\'en}{1997}]{FrO97a}
{\sc Fribourg, L.} {\sc and} {\sc Ols\'en, H.} 1997.
\newblock A decompositional approach for computing least fixed-points of
  {D}atalog programs with {Z}-counters.
\newblock {\em Constraints\/}~{\em 2,\/}~3/4, 305--335.

\bibitem[\protect\citeauthoryear{Gupta, Bansal, Min, Simon, and Mallya}{Gupta
  et~al\mbox{.}}{2007}]{Gu&07}
{\sc Gupta, G.}, {\sc Bansal, A.}, {\sc Min, R.}, {\sc Simon, L.}, {\sc and}
  {\sc Mallya, A.} 2007.
\newblock Coinductive logic programming and its applications.
\newblock In {\em Proceedings ICLP'07, Porto, Portugal}, {V.~Dahl} {and}
  {I.~Niemel{\"a}}, Eds. Lecture Notes in Computer Science 4670. Springer,
  27--44.

\bibitem[\protect\citeauthoryear{Jaffar, Santosa, and Voicu}{Jaffar
  et~al\mbox{.}}{2004}]{Ja&04}
{\sc Jaffar, J.}, {\sc Santosa, A.~E.}, {\sc and} {\sc Voicu, R.} 2004.
\newblock A {CLP} proof method for timed automata.
\newblock In {\em The 25th IEEE International Real-Time Systems Symposium},
  {J.~Anderson} {and} {J.~Sztipanovits}, Eds. IEEE Computer Society, 175--186.

\bibitem[\protect\citeauthoryear{Leuschel and Massart}{Leuschel and
  Massart}{2000}]{LeM99}
{\sc Leuschel, M.} {\sc and} {\sc Massart, T.} 2000.
\newblock Infinite state model checking by abstract interpretation and program
  specialization.
\newblock In {\em Proceedings LOPSTR'99, Venezia, Italy},
  {A.~Bossi}, Ed. Lecture Notes in Computer Science 1817. Springer, 63--82.
  
\bibitem[\protect\citeauthoryear{Lloyd}{Lloyd}{1987}]{Llo87}
{\sc Lloyd, J.~W.} 1987.
\newblock {\em Foundations of Logic Pro\-gramming}.
\newblock Springer, Berlin. 
\newblock 2nd Edition.

\bibitem[\protect\citeauthoryear{Min and Gupta}{Min and Gupta}{2010}]{MiG09}
{\sc Min, R.} {\sc and} {\sc Gupta, G.} 2010.
\newblock Coinductive logic programming with negation.
\newblock In {\em Proc. LOPSTR'09,
  Coimbra, Portugal}, {D.~{De Schreye}}, Ed.  
  Lecture Notes in Computer Science 6037. Springer, 97--112.
  
  
  \bibitem[\protect\citeauthoryear{Nilsson and L{\"u}bcke}{Nilsson and
  L{\"u}bcke}{2000}]{NiL00}
{\sc Nilsson, U.} {\sc and} {\sc L{\"u}bcke, J.} 2000.
\newblock Constraint logic programming for local and symbolic model-checking.
\newblock In {\em Proceedings CL 2000, London, UK}, {J.~W. Lloyd}, Ed.
  Lecture Notes in Artificial Intelligence 1861. Springer-Verlag, 384--398.

\bibitem[\protect\citeauthoryear{Pettorossi and Proietti}{Pettorossi and
  Proietti}{2000}]{PeP00a}
{\sc Pettorossi, A.} {\sc and} {\sc Proietti, M.} 2000.
\newblock Perfect model checking via unfold/fold transformations.
\newblock In {\em Proceedings CL 2000, London, UK}, {J.~W. Lloyd}, Ed.
  Lecture Notes in Artificial Intelligence 1861. Springer-Verlag, 613--628.

\bibitem[\protect\citeauthoryear{Pettorossi, Proietti, and Senni}{Pettorossi
  et~al\mbox{.}}{2010}]{Pe&09b}
{\sc Pettorossi, A.}, {\sc Proietti, M.}, {\sc and} {\sc Senni, V.} 2010.
\newblock Deciding full branching time logic by program transformation.
\newblock In {\em Proc. LOPSTR'09,
  Coimbra, Portugal}, {D.~{De Schreye}}, Ed. 
  Lecture Notes in Computer Science 6037. Springer, 5--21.

\bibitem[\protect\citeauthoryear{Proietti and Pettorossi}{Proietti and
  Pettorossi}{1995}]{PrP95a}
{\sc Proietti, M.} {\sc and} {\sc Pettorossi, A.} 1995.
\newblock Unfolding-definition-folding, in this order, for avoiding unnecessary
  variables in logic pro\-grams.
{\em Theoretical Computer Science\/}~{\em 142,\/}\,1,\,89--124.

\bibitem[\protect\citeauthoryear{Ramakrishna, Ramakrishnan, Ramakrishnan,
  Smolka, Swift, and Warren}{Ramakrishna et~al\mbox{.}}{1997}]{Ra&97}
{\sc Ramakrishna, Y.~S.}, {\sc Ramakrishnan, C.~R.}, {\sc Ramakrishnan, I.~V.},
  {\sc Smolka, S.~A.}, {\sc Swift, T.}, {\sc and} {\sc Warren, D.~S.} 1997.
\newblock Efficient model checking using tabled resolution.
\newblock In {\em Proc. CAV'97}. Lecture Notes in Computer Science 1254.
  Springer-Verlag, 143--154.

\bibitem[\protect\citeauthoryear{Roychoudhury, Kumar, Ramakrishnan, and
  Ramakrishnan}{Roychoudhury et~al\mbox{.}}{2002}]{Ro&02}
{\sc Roychoudhury, A.}, {\sc Kumar, K.~N.}, {\sc Ramakrishnan, C.~R.}, {\sc
  and} {\sc Ramakrishnan, I.~V.} 2002.
\newblock Beyond {T}amaki-{S}ato style unfold/fold transformations for normal
  logic programs.
\newblock {\em International Journal on Foundations of Computer Science\/}~{\em
  13,\/}~3, 387--403.

\bibitem[\protect\citeauthoryear{Seki}{Seki}{1991}]{Sek91}
{\sc Seki, H.} 1991.
\newblock Unfold/fold trans\-form\-ation of stratified pro\-grams.
\newblock {\em Theoretical Computer Science\/}~{\em 86}, 107--139.

\bibitem[\protect\citeauthoryear{Seki}{Seki}{2010}]{Sek09}
{\sc Seki, H.} 2010.
\newblock On inductive and coinductive proofs via unfold/fold transformations.
\newblock In {\em Proc. LOPSTR'09,
  Coimbra, Portugal}, {D.~{De Schreye}}, Ed.  
  Lecture Notes in Computer Science 6037. Springer, 82--96.

\bibitem[\protect\citeauthoryear{Simon, Mallya, Bansal, and Gupta}{Simon
  et~al\mbox{.}}{2006}]{Si&06}
{\sc Simon, L.}, {\sc Mallya, A.}, {\sc Bansal, A.}, {\sc and} {\sc Gupta, G.}
  2006.
\newblock Coinductive logic programming.
\newblock In {\em Proceedings ICLP'06, Seattle, USA}, {S.~Etalle} {and}
  {M.~Truszczy\'{n}ski}, Eds. Lecture Notes in Computer Science 4079. Springer,
  330--345.

\bibitem[\protect\citeauthoryear{Staiger}{Staiger}{1997}]{Sta97}
{\sc Staiger, L.} 1997.
\newblock -{L}anguages.
\newblock In {\em Handbook of Formal Languages}, {G.~Rozenberg} {and}
  {A.~Salomaa}, Eds. Vol.~3. Springer, Berlin, 339--387.

\bibitem[\protect\citeauthoryear{Tamaki and Sato}{Tamaki and
  Sato}{1984}]{TaS84}
{\sc Tamaki, H.} {\sc and} {\sc Sato, T.} 1984.
\newblock Unfold/fold trans\-form\-ation of logic pro\-grams.
\newblock In {\em Proceedings ICLP'84}, {S.-{\AA}. T{{\"a}}rnlund}, 
Ed. Uppsala University,
  Uppsala, Sweden, 127--138.

\bibitem[\protect\citeauthoryear{Thomas}{Thomas}{1990}]{Tho90}
{\sc Thomas, W.} 1990.
\newblock Automata on infinite objects.
\newblock In {\em Handbook of Theoretical Computer Science}, {J.~{Van
  Leeuwen}}, Ed. Vol.~B. Elsevier, Amsterdam, 135--191.

\bibitem[\protect\citeauthoryear{Ueda and Furukawa}{Ueda and
  Furukawa}{1988}]{UeF88}
{\sc Ueda, K.} {\sc and} {\sc Furukawa, K.} 1988.
\newblock Trans\-formation rules for {GHC} pro\-grams.
\newblock In {\em Proceedings International Conference on Fifth Generation
  Computer Systems, ICOT, Tokyo, Japan}. 582--591.

\end{thebibliography}

\end{document}
