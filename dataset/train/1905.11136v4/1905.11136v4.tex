\documentclass{article}



\usepackage[final]{neurips_2019}







\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype,xcolor}      \usepackage{wrapfig}
\usepackage{graphicx}
\usepackage{xr}



\usepackage{amsmath,amsfonts,bm,amsthm}

\newcommand{\bell}{\mathrm{b}}
\newcommand{\norm}[1]{\left\Vert#1\right\Vert}
\newcommand{\Norm}[1]{\lvert \! \lvert \! \lvert #1 \rvert \! \rvert \! \rvert}
\newcommand{\abs}[1]{\left\vert#1\right\vert}
\newcommand{\babs}[1]{\Big \vert#1 \Big \vert}
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\mset}[1]{\left\{\kern-.5em\left\{ #1 \right\}\kern-.5em\right\}}
\newcommand{\mmset}[1]{\{\kern-.4em\{ #1 \}\kern-.4em\}}




\newcommand{\parr}[1]{\left (#1\right )}
\newcommand{\brac}[1]{\left [#1\right ]}
\newcommand{\ip}[1]{\left \langle #1 \right \rangle }
\newcommand{\Real}{\mathbb R}
\newcommand{\Nat}{\mathbb N}
\newcommand{\Complex}{\mathbb C}
\newcommand{\eps}{\varepsilon}
\newcommand{\too}{\rightarrow}
\newcommand{\bbar}[1]{\overline{#1}}
\newcommand{\wt}[1]{\widetilde{#1}} \newcommand{\wh}[1]{\widehat{#1}} \newcommand{\diag}{\textrm{diag}} 

\newcommand{\trace}{\textrm{tr}} \def \bfi{\textbf{\footnotesize{i}}} \newcommand{\one}{\mathbf{1}}
\newcommand{\vcc}[1]{\mathrm{vec}(#1)}
\newcommand{\mat}[1]{\bm{[} #1 \bm{]}}

\makeatletter
\newtheorem*{rep@theorem}{\rep@title}
\newcommand{\newreptheorem}[2]{\newenvironment{rep#1}[1]{\def\rep@title{#2 \ref{##1}}\begin{rep@theorem}}{\end{rep@theorem}}}
\makeatother

\newtheorem{theorem}{Theorem}
\newreptheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newreptheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}
\newtheorem{corollary}{Corollary}


\newtheorem{definition}{Definition}




\makeatletter
\newcommand{\subalign}[1]{\vcenter{\Let@ \restore@math@cr \default@tag
    \baselineskip\fontdimen10 \scriptfont\tw@
    \advance\baselineskip\fontdimen12 \scriptfont\tw@
    \lineskip\thr@@\fontdimen8 \scriptfont\thr@@
    \lineskiplimit\lineskip
    \ialign{\hfil&\crcr
      #1\crcr
    }}
}
\makeatletter


\def \etal{{et al}.}
\newcommand{\eg}{{e.g.}}
\newcommand{\ie}{{i.e.}}
\newcommand{\haggai}[1]{{\color{red}{\bf[Haggai:} #1{\bf]}}}
\newcommand{\yl}[1]{{\color{magenta}{\bf[Yaron:} #1{\bf]}}}
\newcommand{\heli}[1]{{\color{blue}{\bf[Heli:} #1{\bf]}}}
\newcommand{\hadar}[1]{{\color{purple}{\bf[Hadar:} #1{\bf]}}}
\newcommand{\revision}[1]{{\color{black} #1}}







\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}
\def\valpha{{\bm{\alpha}}}
\def\vbeta{{\bm{\beta}}}
\def\vgamma{{\bm{\gamma}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} \newcommand{\ldblbrace}{\left\{\!\!\left\{}
\newcommand{\rdblbrace}{\right\}\!\!\right\}}


\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak

 

\title{Provably Powerful Graph Networks}



\author{
	Haggai Maron\thanks{Equal contribution} \ \ \   \  Heli Ben-Hamu \ \  Hadar Serviansky \ \ 	Yaron Lipman \\
Weizmann Institute of Science\\
	Rehovot, Israel \\
}


\begin{document}


\maketitle

\begin{abstract}
Recently, the Weisfeiler-Lehman (WL) graph isomorphism test was used to measure the expressive power of graph neural networks (GNN). It was shown that the popular message passing GNN cannot distinguish between graphs that are indistinguishable by the -WL test \citep{morris2018weisfeiler,xu2018how}. Unfortunately, many simple instances of graphs are indistinguishable by the -WL test. 

In search for more expressive graph learning models we build upon the recent -order invariant and equivariant graph neural networks \citep{maron2018invariant, maron2019universality}  and present two results: 

First, we show that such -order networks can distinguish between non-isomorphic graphs as good as the -WL tests, which are provably stronger than the -WL test for . This makes these models strictly stronger than message passing models. Unfortunately, the higher expressiveness of these models comes with a computational cost of processing high order tensors. 

Second, setting our goal at building a provably stronger, \emph{simple} and \emph{scalable}  model we show that a reduced -order network containing just scaled identity operator, augmented with a single quadratic operation (matrix multiplication) has a provable -WL expressive power. Differently put, we suggest a simple model that interleaves applications of standard Multilayer-Perceptron (MLP) applied to the feature dimension and matrix multiplication. 
We validate this model by presenting state of the art results on popular graph classification and regression tasks. To the best of our knowledge, this is the first practical invariant/equivariant model with guaranteed -WL expressiveness, strictly stronger than message passing models.




\end{abstract}
\section{Introduction}








Graphs are an important data modality which is frequently used in many fields of science and engineering. Among other things, graphs are used to model social networks, chemical compounds, biological structures and high-level image content information. One of the major tasks in graph data analysis is learning from graph data. As classical approaches often use hand-crafted graph features that are not necessarily suitable to all datasets and/or tasks (\eg, \cite{kriege2019survey}), a significant research effort in recent years is to develop deep models that are able to learn new graph representations from raw features (\eg, \citet{Gori2005,Duvenaud2015,Niepert2016,kipf,Velickovic2017,monti2017geometric,Hamilton2017,morris2018weisfeiler,xu2018how}).

Currently, the most popular methods for deep learning on graphs are \emph{message passing neural networks} in which the node features are propagated through the graph according to its connectivity structure \citep{Gilmer2017}.  In a successful attempt to quantify the expressive power of message passing models, \citet{morris2018weisfeiler,xu2018how} suggest to compare the model's ability to \emph{distinguish} between two given graphs to that of the hierarchy of the Weisfeiler-Lehman (WL) graph isomorphism tests \citep{grohe2017descriptive,babai2016graph}. Remarkably, they show that the class of message passing models has limited expressiveness and is not better than the first WL test (-WL, a.k.a.~color refinement).  For example, Figure \ref{fig:wl_example} depicts two graphs (\ie, in blue and in green) that -WL cannot distinguish, hence indistinguishable by any message passing algorithm.  

\begin{wrapfigure}[12]{r}{0.25\textwidth}
\vspace{-10pt}
\hspace{7pt}
\includegraphics[width=0.20\textwidth]{1WL.pdf}
\vspace{0pt}
\caption{Two graphs not distinguished by -WL.}\label{fig:wl_example}
\end{wrapfigure} 


The goal of this work is to explore and develop GNN models that possess higher expressiveness while maintaining scalability, as much as possible. We present two main contributions. First, establishing a baseline for expressive GNNs, we prove that the recent -order invariant GNNs \citep{maron2018invariant,maron2019universality} offer a natural hierarchy of models that are as expressive as the -WL tests, for . Second, as -order GNNs are not practical for  we develop a simple, novel GNN model, that incorporates standard MLPs of the feature dimension and a matrix multiplication layer. This model, working only with  tensors (the same dimension as the graph input data), possesses the expressiveness of -WL. Since, in the WL hierarchy, -WL and -WL are equivalent, while -WL is strictly stronger, this model is provably more powerful than the message passing models. For example, it can distinguish the two graphs in Figure \ref{fig:wl_example}. As far as we know, this model is the first to offer both expressiveness (-WL) and scalability (). 

The main challenge in achieving high-order WL expressiveness with GNN models stems from the difficulty to represent the multisets of neighborhoods required for the WL algorithms.  We advocate a novel representation of multisets based on Power-sum Multi-symmetric Polynomials (PMP) which are a generalization of the well-known elementary symmetric polynomials. This representation provides a convenient theoretical tool to analyze models' ability to implement the WL tests. 


A related work to ours that also tried to build graph learning methods that surpass the -WL expressiveness offered by message passing is \citet{morris2018weisfeiler}. They develop powerful deep models generalizing message passing to higher orders that are as expressive as higher order WL tests. Although making progress, their full model is still computationally prohibitive for -WL expressiveness and requires a relaxed local version compromising some of the theoretical guarantees. 


Experimenting with our model on several real-world datasets that include classification and regression tasks on social networks, molecules, and chemical compounds, we found it to be on par or better than state of the art. 





\section{Previous work}

\paragraph{Deep learning on graph data.}
The pioneering works that applied neural networks to graphs are \cite{Gori2005,Scarselli2009} that learn node representations using recurrent neural networks, which were also used in \cite{Li2015}. Following the success of convolutional neural networks \citep{krizhevsky2012imagenet}, many works have tried to generalize the notion of convolution to graphs and build networks that are based on this operation. \cite{Bruna2013} defined graph convolutions as operators that are diagonal in the graph laplacian eigenbasis. This paper resulted in multiple follow up works with more efficient and spatially localized convolutions \citep{Henaff2015,Defferrard2016,kipf,Levie2017}. Other works define graph convolutions as local stationary functions that are applied to each node and its neighbours (\eg, \cite{Duvenaud2015,Atwood2015,Niepert2016,hamilton2017representation,Velickovic2017,Monti2018}). Many of these works were shown to be instances of the family of message passing neural networks \citep{Gilmer2017}: methods that apply parametric functions to a node and its neighborhood and then apply some pooling operation in order to generate a new feature for each node. 
 In a recent line of work, it was suggested to define graph neural networks using permutation equivariant operators on tensors describing -order relations between the nodes. \cite{Kondor2018} identified several such linear and quadratic equivariant operators and showed that the resulting network can achieve excellent results on popular graph learning benchmarks. \cite{maron2018invariant} provided a full characterization of linear equivariant operators between tensors of arbitrary order. In both cases, the resulting networks were shown to be at least as powerful as message passing neural networks. In another line of work, \cite{murphy2019relational} suggest expressive invariant graph models defined using averaging over all permutations of an arbitrary base neural network.    



\paragraph{Weisfeiler Lehman graph isomorphism test.} The Weisfeiler Lehman tests is a hierarchy of increasingly powerful graph isomorphism tests \citep{grohe2017descriptive}. 
The WL tests have found many applications in machine learning: in addition to \cite{xu2018how,morris2018weisfeiler}, this idea was used in \cite{shervashidze2011weisfeiler} to construct a graph kernel method, which was further generalized to higher order WL tests in \cite{morris2017glocalized}. \citet{lei2017deriving} showed that their suggested GNN has a theoretical connection to the WL test. WL tests were also used in \cite{zhang2017weisfeiler} for link prediction tasks. In a concurrent work, \citet{morris2019towards} suggest constructing graph features based on an equivalent sparse version of high-order WL achieving great speedup and expressiveness guarantees for sparsely connected graphs. \vspace{-5pt}







\section{Preliminaries}\label{s:prelim}\vspace{-5pt}
We denote a set by , an ordered set (tuple) by  and a multiset (\ie, a set with possibly repeating elements) by . We denote , and . Let  denote the permutation group on  elements. 
We use multi-index  to denote a -tuple of indices, .  acts on multi-indices  entrywise by . 
 acts on -tensors  by , where , . 



\vspace{-5pt}
\subsection{-order graph networks}\label{ss:k_order_networks}
\vspace{-5pt}
\citet{maron2018invariant} have suggested a family of permutation-invariant deep neural network models for graphs. Their main idea is to construct networks by concatenating maximally expressive linear equivariant layers. More formally, a -order invariant graph network is a composition , where , , are \emph{equivariant linear layers}, namely satisfy 
 is an entrywise non-linear activation, ,  is an \emph{invariant linear layer}, namely satisfies 

and  is a Multilayer Perceptron (MLP). The invariance of  is achieved by construction (by propagating  through the layers using the definitions of equivariance and invariance):  
When , \citet{maron2018invariant} proved that this construction gives rise to a model that can approximate any message passing neural network \citep{Gilmer2017} to an arbitrary precision; \citet{maron2019universality} proved these models are universal for a very high tensor order of , which is of little practical value (an alternative proof was recently suggested in \cite{keriven2019universal}).   




\vspace{-5pt}
\subsection{The Weisfeiler-Lehman graph isomorphism test}\label{ss:WL}
\vspace{-5pt}
Let  be a colored graph where  and  defines the color attached to each vertex in ,  is a set of colors.  The Weisfeiler-Lehman (WL) test is a family of algorithms used to test graph isomorphism. Two graphs  are called isomorphic if there exists an edge and color preserving bijection . 


There are two families of WL algorithms: -WL and -FWL (Folklore WL), both parameterized by . 
-WL and -FWL both construct a coloring of -tuples of vertices, that is . Testing isomorphism of two graphs  is then performed by comparing the histograms of colors produced by the -WL (or -FWL) algorithms.

We will represent coloring of -tuples using a tensor , where ,  denotes the color of the -tuple .  In both algorithms, the initial coloring  is defined using the \emph{isomorphism type} of each -tuple. That is, two -tuples  have the same isomorphism type (\ie, get the same color, ) if for all : (i) ; (ii) ; and (iii) . Clearly, if  are two isomorphic graphs then there exists  so that  . 

In the next steps, the algorithms refine the colorings ,  until the coloring does not change further, that is, the subsets of -tuples with same colors do not get further split to different color groups. It is guaranteed that no more than  iterations are required \citep{douglas2011weisfeiler}.   

\begin{wrapfigure}[7]{R}{0.12\textwidth}
\vspace{-12pt}
\includegraphics[scale=0.2]{wl_vs_wlf.pdf}
\vspace{10pt}
\end{wrapfigure}
The construction of  from  differs in the WL and FWL versions. The difference is in how the colors are aggregated from neighboring -tuples. We define two notions of neighborhoods of a -tuple :

,  is the -th neighborhood of the tuple  used by the WL algorithm, while ,  is the -th neighborhood used by the FWL algorithm. Note that  is a set of  -tuples, while  is an ordered set of   -tuples. The inset to the right illustrates these notions of neighborhoods for the case : the top figure shows  in purple and  in orange. The bottom figure shows  for all  with different colors for different .



The coloring update rules are:

where  is a bijective map from the collection of all possible tuples in the r.h.s.~of  Equations (\plaineqref{e:WL_update})-(\plaineqref{e:FWL_update}) to . 

When  both rules, (\plaineqref{e:WL_update})-(\plaineqref{e:FWL_update}), degenerate to , which will not refine any initial color. Traditionally, the first algorithm in the WL hierarchy is called WL, -WL, or the \emph{color refinement algorithm}. In color refinement, one starts with the coloring prescribed with . Then, in each iteration, the color at each vertex is refined by a new color representing its current color and the multiset of its neighbors' colors. 

Several known results of WL and FWL algorithms \citep{cai1992optimal,grohe2017descriptive,morris2018weisfeiler,grohe2015pebble} are:
\begin{enumerate}
    \item -WL and -WL have equivalent discrimination power. 
    \item -FWL is equivalent to -WL for .
    \item For each  there is a pair of non-isomorphic graphs distinguishable by -WL but not by -WL. \vspace{-3pt}
\end{enumerate}

\section{Colors and multisets in networks}\label{s:colors_and_multisets}
\vspace{-5pt}
Before we get to the two main contributions of this paper we address three challenges that arise when analyzing networks' ability to implement WL-like algorithms: (i) Representing the colors  in the network; (ii) implementing a multiset representation; and  (iii) implementing the encoding function. 

\vspace{-3pt}
\paragraph{Color representation.}\vspace{-3pt}
We will represent colors as vectors. That is, we will use tensors  to encode a color per -tuple; that is, the color of the tuple  is a vector . This effectively replaces the color tensors  in the WL algorithm with .

\vspace{-3pt}
\paragraph{Multiset representation.}\vspace{-3pt}
A key technical part of our method is the way we encode multisets in networks. Since colors are represented as vectors in , an -tuple of colors is represented by a matrix , where ,  are the rows of . Thinking about  as a multiset forces us to be indifferent to the order of rows. That is, the color representing  should be the same as the color representing , for all . One possible approach is to perform some sort (\eg, lexicographic) to the rows of . Unfortunately, this seems challenging to implement with equivariant layers. 

Instead, we suggest to encode a multiset  using a set of -invariant functions called the \emph{Power-sum Multi-symmetric Polynomials} (PMP) \citep{briand2004algebra,rydh2007minimal}. The PMP are the multivariate analog to the more widely known \emph{Power-sum Symmetric Polynomials}, , , where . They are defined next. 
Let  be a multi-index and for  we set . Furthermore, . The PMP of degree  is 
 



A key property of the PMP is that the finite subset , for  generates the ring of \emph{Multi-symmetric Polynomials} (MP), the set of polynomials  so that  for all ,  (see, \eg,  \citep{rydh2007minimal} corollary 8.4). The PMP generates the ring of MP in the sense that for an arbitrary MP , there exists a polynomial  so that , where

As the following proposition shows, a useful consequence of this property is that the vector  is a unique representation of the multi-set . 
\begin{proposition}\label{prop:u}
For arbitrary :  so that  if and only if . 
\end{proposition}
We note that Proposition \ref{prop:u} is a generalization of lemma 6 in \citet{zaheer2017deep} to the case of multisets of vectors. \revision{This generalization was possible since the PMP  provide a continuous way to encode \textit{vector} multisets (as opposed to scalar multisets in previous works). } The full proof is provided in the supplementary material.

\paragraph{Encoding function.} One of the benefits in the vector representation of colors is that the encoding function can be implemented as a simple concatenation: Given two color tensors , , the tensor that represents for each -tuple  the color pair  is simply .  






\section{-order graph networks are as powerful as -WL}\label{s:as_powerful}
Our goal in this section is to show that, for every , -order graph networks \citep{maron2018invariant} are at least as powerful as the -WL graph isomorphism test in terms of distinguishing non-isomorphic graphs. This result is shown by constructing a -order network model and learnable weight assignment that implements the -WL test. 

To motivate this construction we note that the WL update step, \Eqref{e:WL_update}, is equivariant (see proof in the supplementary material). Namely, plugging in  the WL update step would yield . Therefore, it is plausible to try to implement the WL update step using linear equivariant layers and non-linear pointwise activations. 


\begin{theorem}\label{thm:k_wl_k_order}
Given two graphs ,  that can be distinguished by the -WL graph isomorphism test, there exists a -order network  so that . On the other direction for every two isomorphic graphs  and -order network , .
\end{theorem}
The full proof is provided in the supplementary material. Here we outline the basic idea for the proof. First, an input graph  is represented using a tensor of the form  , as follows. 
The last channel of , namely  ('' stands for all possible values ) encodes the adjacency matrix of  according to . The first  channels  are zero outside the diagonal, and  is the color of vertex . 

Now, the second statement in Theorem \ref{thm:k_wl_k_order} is clear since two isomorphic graphs  will have tensor representations satisfying  and therefore, as explained in Section \ref{ss:k_order_networks}, . 

More challenging is showing the other direction, namely that for non-isomorphic graphs   that can be distinguished by the -WL test, there exists a -network distinguishing  and . The key idea is to show that a -order network can encode the multisets  for a given tensor . These multisets are the only non-trivial component in the WL update rule, \Eqref{e:WL_update}. 
Note that the rows of the matrix  are the colors (\ie, vectors) that define the multiset . Following our multiset representation (Section \ref{s:colors_and_multisets}) we would like the network to compute  and plug the result at the -th entry of an output tensor . 

This can be done in two steps: First, applying the polynomial function ,  entrywise to , where  is defined by  (note that  is the number of multi-indices  such that ). Denote the output of this step . Second, apply a linear equivariant operator summing over the -the coordinate of  to get , that is
  
where  as desired. Lastly, we use the universal approximation theorem \citep{cybenko1989approximation,hornik1991approximation} to replace the polynomial function  with an approximating MLP  to get a -order network (details are in the supplementary material). Applying  feature-wise, that is , is in particular a -order network in the sense of Section \ref{ss:k_order_networks}.  

\section{A simple network with 3-WL discrimination  power}\label{s:3WL_network}

\begin{wrapfigure}[12]{R}{0.35\textwidth}
\vspace*{-8pt}\hspace{-5pt}
\includegraphics[scale=0.3]{prod_layer.pdf}
\caption{Block structure.}\label{fig:block}
\end{wrapfigure}
In this section we describe a simple GNN model that has -WL discrimination power. The model has the form 

where as in -order networks (see Section \ref{ss:k_order_networks})  is an invariant layer and  is an MLP.  are blocks with the following structure (see figure \ref{fig:block} for an illustration). Let  denote the input tensor to the block. First, we apply three MLPs ,  to the input tensor, , . This means applying the MLP to each feature of the input tensor independently, \ie, , . Second, matrix multiplication is performed between matching features, \ie, , . The output of the block is the tensor  .  

We start with showing our basic requirement from GNN, namely invariance:
\begin{lemma}\label{lem:qmlp_invariance}
The model  described above is invariant, \ie, , for all , and .
\end{lemma}
\begin{proof}
Note that matrix multiplication is equivariant: for two matrices  and  one has . This makes the basic building block  equivariant, and consequently the model  invariant, \ie,  . 
\end{proof}


Before we prove the -WL power for this model, let us provide some intuition as to why matrix multiplication improves expressiveness. Let us show matrix multiplication allows this model to distinguish between the two graphs in Figure \ref{fig:wl_example}, which are -WL indistinguishable. The input tensor  representing a graph  holds the adjacency matrix at the last channel . We can build a network with  blocks computing  and then take the trace of this matrix (using the invariant layer ). Remember that the -th power of the adjacency matrix computes the number of -paths between vertices; in particular  computes the number of cycles of length . Counting shows the upper graph in Figure \ref{fig:wl_example} has  such cycles while the bottom graph has .  The main result of this section is:


\begin{theorem}\label{thm:3_WL}
Given two graphs ,  that can be distinguished by the -WL graph isomorphism test, there exists a network  (\eqref{e:qmlp}) so that . On the other direction for every two isomorphic graphs  and  (\Eqref{e:qmlp}), .
\end{theorem}
The full proof is provided in the supplementary material. Here we outline the main idea of the proof. The second part of this theorem is already shown in Lemma \ref{lem:qmlp_invariance}. To prove the first part, namely that the model in \Eqref{e:qmlp} has -WL expressiveness, we show it can implement the -FWL algorithm, that is known to be equivalent to -WL (see Section \ref{ss:WL}). As before, the challenge is in implementing the neighborhood multisets as used in the -FWL algorithm. That is, given an input tensor  we would like to compute an output tensor  where  represents a color matching the multiset .  
As before, we use the multiset representation introduced in section \ref{s:colors_and_multisets}. Consider the matrix  defined by

Our goal is to compute an output tensor , where . 

Consider the multi-index set  of cardinality , and write it in the form . 

Now define polynomial maps  by , and . We apply  to the features of , namely ; similarly, . Now,

hence
 
where  is defined in \Eqref{e:mX}. To get an implementation with the  model in \Eqref{e:qmlp} we need to replace  with MLPs. We use the universal approximation theorem to that end (details are in the supplementary material). 

To conclude, each update step of the -FWL algorithm is implemented in the form of a block  applying  to the input tensor , followed by matrix multiplication of matching features, . Since \Eqref{e:FWL_update} requires pairing the multiset with the input color of each -tuple, we take  to be identity and get  as the block output. 

\paragraph{Generalization to -FWL.} One possible extension is to add a generalized matrix multiplication to -order networks to make them as expressive as -FWL and hence -WL. Generalized matrix multiplication is defined as follows. Given , then .


\revision{\paragraph{Relation to \citep{morris2018weisfeiler}.} Our model offers two benefits over the 1-2-3-GNN suggested in the work of \cite{morris2018weisfeiler}, a recently suggested GNN that also surpasses the expressiveness of message passing networks. First, it has lower space complexity (see details below). This allows us to work with a provably 3-WL expressive model while \cite{morris2018weisfeiler} resorted to a local 3-GNN version, hindering their 3-WL expressive power. Second, from a practical point of view our model is arguably simpler to implement as it only consists of fully connected layers and matrix multiplication (without having to account for all subsets of size 3). }

\revision{ \paragraph{Complexity analysis of a single block.}  Assuming a graph with  nodes, dense edge data and a
constant feature depth, the layer proposed in \cite{morris2018weisfeiler} has  space complexity (number of subsets) and  time complexity ( subsets with  neighbors each). Our layer (block), however, has  space complexity as only second order tensors are stored (i.e., linear in the size of the graph data), and time complexity of  due to the matrix multiplication. We note that the time complexity of \cite{morris2018weisfeiler} can probably be improved to  while our time complexity can be improved to  due to more advanced matrix multiplication algorithms. }





\section{Experiments}

\begin{table}[t]
	\centering
	\tiny
	\caption{Graph Classification Results on the datasets from \cite{Yanardag2015}}
	\resizebox{\columnwidth}{!}{
	
	\begin{tabular}{@{\hskip8pt}l@{\hskip8pt}r@{\hskip8pt}r@{\hskip8pt}r@{\hskip8pt}r@{\hskip8pt}r@{\hskip8pt}r@{\hskip8pt}r@{\hskip8pt}r@{\hskip8pt}}
		\toprule
		dataset & \multicolumn{1}{l}{MUTAG} & \multicolumn{1}{l}{PTC} & \multicolumn{1}{l}{PROTEINS} & \multicolumn{1}{l}{NCI1} & \multicolumn{1}{l}{NCI109} & \multicolumn{1}{l}{COLLAB} & \multicolumn{1}{l}{IMDB-B} & \multicolumn{1}{l}{IMDB-M} \\
		\midrule
		size  & 188   & 344   &  1113  & 4110  & 4127  & 5000  & 1000  & 1500 \\
		classes & 2     & 2     &  2     & 2     & 2     & 3     & 2     & 3 \\
		avg node \# & 17.9  & 25.5  &  39.1  & 29.8  & 29.6  & 74.4  & 19.7  & 13 \\
		\midrule
		\multicolumn{9}{c}{Results} \\
		\midrule
		GK \citep{shervashidze2009efficient}    & 81.391.7 & 55.650.5 &  71.390.3 & 62.490.3 & 62.350.3 & NA    & NA    & NA \\
		RW  \citep{vishwanathan2010graph}   & 79.172.1 & 55.910.3 &  59.570.1 &  days & NA    & NA    & NA    & NA \\
		PK \citep{neumann2016propagation}    & 762.7 & 59.52.4 &  73.680.7 & 82.540.5 & NA    & NA    & NA    & NA \\
		WL \citep{shervashidze2011weisfeiler}    & 84.111.9 & 57.972.5 &  \bf{74.680.5} & \bf{84.460.5} & \bf{85.120.3} & NA    & NA    & NA \\
		
		FGSD  \citep{verma2017hunt}  & \bf{92.12} & \bf{62.80} &  73.42 & 79.80 & 78.84 & \bf{80.02}  & 73.62    & \bf{52.41} \\
		
		AWE-DD \citep{ivanov2018anonymous}   & NA & NA &  NA & NA & NA & 73.93    & \bf{74.45  5.8}    & 51.54  \\
		AWE-FB \citep{ivanov2018anonymous}    & 87.879.7&NA &  NA & NA & NA & 70.99  1.4  & 73.13 3.2    & 51.58  4.6 \\
		
		\midrule
			DGCNN \citep{Zhang} & 85.831.7 & 58.592.5 &  75.540.9 & 74.440.5 & NA    & 73.760.5 & 70.030.9 & 47.830.9 \\
		PSCN \citep{Niepert2016}{\tiny (k=10)} & 88.954.4 & 62.295.7 & 752.5 & 76.341.7 & NA    & 72.62.2 & 712.3 & 45.232.8 \\
		DCNN \citep{Atwood2015}  & NA    & NA    &  61.291.6 & 56.61 1.0 & NA    & 52.110.7 & 49.061.4 & 33.491.4 \\
		ECC \citep{Simonovsky2017}  & 76.11 & NA    &  NA    & 76.82 & 75.03 & NA    & NA    & NA \\
		DGK \citep{Yanardag2015}  & 87.442.7 & 60.082.6 &  75.680.5 & 80.310.5 & 80.320.3 & 73.090.3 & 66.960.6 & 44.550.5 \\
		DiffPool \citep{Ying2018} & NA    & NA    &  \bf{78.1}  & NA    & NA    & 75.5  & NA    & NA \\
		CCN \citep{Kondor2018}  & \bf{91.647.2} & \bf{70.627.0} &  NA    & 76.274.1 & 75.543.4 & NA    & NA    & NA \\
		
		
	Invariant Graph Networks \citep{maron2018invariant}  & 83.8912.95     & 58.536.86     &  76.585.49     & 74.332.71     & 72.821.45     & 78.362.47  & 72.05.54   & 48.733.41 \\
		GIN  \citep{xu2018how}& 89.45.6     & 64.67.0     &  76.22.8     & 82.71.7     & NA     & 80.21.9  & \bf{75.15.1} & \bf{52.32.8} \\
		1-2-3 GNN \citep{morris2018weisfeiler} & 86.1    & 60.9     &  75.5     & 76.2     & NA     & NA  & 74.2 & 49.5 \\
Ours 1  & 90.558.7     & 66.176.54     &  77.24.73     &  \bf{83.191.11}  & \bf{81.841.85}     & 80.161.11  & 72.64.9 & 503.15 \\
		Ours 2  & 88.887.4  &  64.77.46  &  76.395.03  &  81.212.14  &  \bf{81.771.26}  &  \bf{81.381.42}  &  72.24.26  &  44.737.89  \\
		Ours 3  & 89.448.05  &  62.946.96  &  76.665.59  &  80.971.91  &  \bf{82.231.42}  &  \bf{80.681.71}  &  735.77  &  50.463.59   \\
		Rank &  &  &  &  &  &  &  &  \\
		\bottomrule
	\end{tabular}}
	\label{tab:class_res}\vspace{-10pt}
\end{table}\paragraph{Implementation details.} We implemented the GNN model as described in Section \ref{s:3WL_network} (see \Eqref{e:qmlp}) using the TensorFlow framework \citep{abadi2016tensorflow}. We used three identical blocks , where in each block  we took  to be the identity (\ie,  acts as a skip connection, similar to its role in the proof of Theorem \ref{thm:3_WL});  are chosen as  layer MLP with hidden layers of  features. After each block  we also added a single layer MLP . Note that although this fourth MLP is not described in the model in Section \ref{s:3WL_network} it clearly does not decrease (nor increase) the theoretical expressiveness of the model; we found it efficient for coding as it reduces the parameters of the model. For the first block, , , where for the other blocks . The MLPs are implemented with  convolutions.




\begin{wraptable}[13]{R}{0.45\textwidth} \vspace*{-5pt}
\caption{Regression, the QM9 dataset.}\label{tab:regression}
  \centering
   \resizebox{0.45\textwidth}{!}{ \begin{tabular}{lrrrrr}
    \toprule
    Target & \multicolumn{1}{l}{DTNN} & \multicolumn{1}{l}{MPNN} & \multicolumn{1}{l}{123-gnn} & \multicolumn{1}{l}{Ours 1} & \multicolumn{1}{l}{Ours 2} \\
    \midrule
        & 0.244 & 0.358 & 0.476 & \bf{0.231} & \bf{0.0934} \\
     & 0.95  & 0.89  & \bf{0.27}  & 0.382 & 0.318 \\
     & 0.00388 & 0.00541 & 0.00337 & \bf{0.00276} & \bf{0.00174} \\
    & 0.00512 & 0.00623 & 0.00351 & \bf{0.00287} & \bf{0.0021} \\
    & 0.0112 & 0.0066 & 0.0048 & \bf{0.00406} & \bf{0.0029} \\
     & 17    & 28.5  & 22.9  & \bf{16.07} &  \bf{3.78} \\
    & 0.00172 & 0.00216 & \bf{0.00019} & 0.00064 & 0.000399 \\
    & -  & -  & 0.0427 & 0.234 & \bf{0.022} \\
    & -  & -     & 0.111 & 0.234 & \bf{0.0504} \\
    & -  & -  & 0.0419 & 0.229 & \bf{0.0294} \\
    & -  & -  & 0.0469 & 0.238 & \bf{0.024} \\
    & 0.27  & 0.42  & \bf{0.0944} & 0.184 & 0.144 \\
    \bottomrule
    \end{tabular}}
  \label{tab:reg_res}\end{wraptable}
Parameter search was conducted on learning rate and learning rate decay, as detailed below.  
We have experimented with two network suffixes adopted from previous papers: (i) The suffix used in \cite{maron2018invariant} that consists of an invariant max pooling (diagonal and off-diagonal) followed by a three Fully Connected (FC) with hidden units' sizes of ;  (ii) the suffix used in \cite{xu2018how} adapted to our network: we apply the invariant max layer from \cite{maron2018invariant} to the output of every block followed by a single fully connected layer to . These outputs are then summed together and used as the network output on which the loss function is defined.




\paragraph{Datasets.} We evaluated our network on two different tasks: Graph classification and graph regression. For classification, we tested our method on eight real-world graph datasets from \citep{Yanardag2015}: three datasets consist of social network graphs, and the other five datasets come from bioinformatics and represent chemical compounds or protein structures. Each graph is represented by an adjacency matrix and possibly categorical node features (for the bioinformatics datasets). For the regression task, we conducted an experiment on a standard graph learning benchmark called the QM9 dataset \citep{ramakrishnan2014quantum, wu2018moleculenet}. It is composed of 134K small organic molecules (sizes vary from 4 to 29 atoms). Each molecule is represented by an adjacency matrix, a distance matrix (between atoms), categorical data on the edges, and node features; the data was obtained from the pytorch-geometric library \citep{fey2019fast}. The task is to predict 12 real valued physical quantities for each molecule. 




\paragraph{Graph classification results.} 
We follow the standard 10-fold cross validation protocol and splits from \cite{Zhang} and report our results according to the protocol described in \cite{xu2018how}, namely the best averaged accuracy across the 10-folds. Parameter search was conducted on a fixed random 90-10 split: learning rate in ; learning rate decay in  every  epochs.
We have tested three architectures: (1) , , and suffix (ii); (2) , , and suffix (i); and (3) , , and suffix (ii). (See above for definitions of  and suffix). Table \ref{tab:class_res} presents a summary of the results (top part - non deep learning methods). The last row presents our ranking compared to all previous methods; note that we have scored in the top  methods in  out of  datasets.  




\pagebreak
\paragraph{Graph regression results.}  
The data is randomly split into 80\% train, 10\% validation and 10\% test. We have conducted the same parameter search as in the previous experiment on the validation set.  We have used the network (2) from classification experiment, \ie, , , and suffix (i), with an absolute error loss adapted to the regression task. Test results are according to the best validation error. We have tried two different settings: (1) training a single network to predict all the output quantities together and (2) training a different network for each quantity. Table \ref{tab:regression} compares the mean absolute error of our method with three other methods: 123-gnn \citep{morris2018weisfeiler} and \citep{wu2018moleculenet}; results of all previous work were taken from \citep{morris2018weisfeiler}. Note that our method achieves the lowest error on 5 out of the 12 quantities when using a single network, and the lowest error on 9 out of the 12 quantities in case each quantity is predicted by an independent network. 

\paragraph{Equivariant layer evaluation.} 

\begin{wrapfigure}[19]{r}{0.31\textwidth}\vspace{-15pt}
\includegraphics[scale=0.3]{comparison.pdf}
\end{wrapfigure}
The model in Section \ref{s:3WL_network} does not incorporate all equivariant linear layers as characterized in \citep{maron2018invariant}. It is therefore of interest to compare this model to models richer in linear equivariant layers, as well as a simple MLP baseline (\ie, without matrix multiplication). We performed such an experiment on the NCI1 dataset \citep{Yanardag2015} comparing: (i) our suggested model, denoted Matrix Product (MP); (ii) matrix product + full linear basis from \citep{maron2018invariant} (MP+LIN); (iii) only full linear basis (LIN); and (iv) MLP applied to the feature dimension. 

Due to the memory limitation in \citep{maron2018invariant} we used the same feature depths of , and . The inset shows the performance of all methods on both training and validation sets, where we performed a parameter search on the learning rate (as above) for a fixed decay rate of  every  epochs. Although all methods (excluding MLP) are able to achieve a zero training error, the (MP) and (MP+LIN) enjoy better generalization than the linear basis of \cite{maron2018invariant}. Note that (MP) and (MP+LIN) are comparable, however (MP) is considerably more efficient. 

\section{Conclusions}
We explored two models for graph neural networks that possess superior graph distinction abilities compared to existing models. First, we proved that -order invariant networks offer a hierarchy of neural networks that parallels the distinction power of the -WL tests. This model has lesser practical interest due to the high dimensional tensors it uses. Second, we suggested a simple GNN model consisting of only MLPs augmented with matrix multiplication and proved it achieves -WL expressiveness. 
This model operates on input tensors of size  and therefore useful for problems with dense edge data. The downside is that its complexity is still quadratic, worse than message passing type methods. An interesting future work is to search for more efficient GNN models with high expressiveness. Another interesting research venue is quantifying the generalization ability of these models. 

\subsection*{Acknowledgments}
This research was supported in part by the European Research Council (ERC Consolidator Grant, "LiftMatch" 771136) and the Israel Science Foundation (Grant No. 1830/17).

\bibliography{graph.bib}
\bibliographystyle{apalike}
\appendix
\section{Proof of Proposition \ref{prop:u}} \label{app:prop1}
\begin{proof}
First, if , then  for all  and therefore . In the other direction assume by way of contradiction that  and , for all . That is,  and  represent different multisets. 
Let  denote the orbit of  under the action of ; similarly denote . Let  be a compact set containing , where  by assumption. 

By the Stone–Weierstrass Theorem applied to the algebra of continuous functions  there exists a polynomial  so that  and .  Consider the polynomial  

By construction , for all . Therefore  is a multi-symmetric polynomial. Therefore,  for some polynomial .
On the other hand,  where we used the assumption that . We arrive at a contradiction.
\end{proof}


\section{Proof of equivairance of WL update step}\label{app:thm_equi_wl}
Consider the formal tensor  of dimension  with multisets as entries:
 Then the -WL update step (\Eqref{e:WL_update}) can be written as 
 To show equivariance, it is enough to show that each entry of the r.h.s.~tuple is equivariant. For its  first entry: . For the other entries, consider w.l.o.g.~: 
 We get that feeding -WL update rule with   we get as output . 




\section{Proof of Theorem \ref{thm:k_wl_k_order}}\label{app:thm1}

\begin{proof}

We will prove a slightly stronger claim: Assume we are given some finite set of graphs. For example, we can think of all combinatorial graphs (\ie, graphs represented by binary adjacency matrices) of  vertices . Our task is to build a -order network  that assigns different output  whenever  are non-isomorphic graphs distinguishable by the -WL test. 

Our construction of  has three main steps. First in Section \ref{sss:input_and_init} we implement the initialization step. Second, Section \ref{sss:update_step} we implement the coloring update rules of the -WL. Lastly, we implement a histogram calculation providing different features to -WL distinguishable graphs in the collection. 



\subsection{Input and Initialization}\label{sss:input_and_init}

\paragraph{Input.}
The input to the network can be seen as a tensor of the form   encoding an input graph , as follows. 
The last channel of , namely  ('' stands for all possible values ) encodes the adjacency matrix of  according to . The first  channels  are zero outside the diagonal, and  is the color of vertex . 
Our assumption of finite graph collection means the set  of possible input tensors  is finite as well. 
Next we describe the different parts of -WL implementation with -order network. For brevity, we will denote by  the input to each part and by  the output. 

\paragraph{Initialization.}
We start with implementing the initialization of -WL, namely computing a coloring representing the isomorphism type of each -tuple. 
Our first step is to define a linear equivariant operator that extracts the sub-tensor corresponding to each multi-index : let  be the linear operator defined by 
 
for . 

 is equivariant with respect to the permutation action. Indeed, for , 
 
For  we have 

Since  is linear and equivariant it can be represented as a single linear layer in a -order network. Note that  contains the sub-tensor of  defined by the -tuple of vertices , and  represents the equality pattern of the -tuple , which is equivalent to the equality pattern of the -tuple of vertices . Hence,  represents the isomorphism type of the -tuple of vertices . The first layer of our construction is therefore . 



\subsection{-WL update step} \label{sss:update_step}
We next implement \Eqref{e:WL_update}. We achieve that in 3 steps. As before let  be the input tensor to the the current -WL step.

First, apply the polynomial function ,  entrywise to , where  is defined by  (note that  is the number of multi-indices  such that ). This gives  where .

Second, apply the linear operator   
 is equivariant with respect to the permutation action. Indeed, 
 
Now, note that  where  as desired. 

Third, the -WL update step is the concatenation: . 


To finish this part we need to replace the polynomial function  with an MLP . Since there is a finite set of input tensors , there could be only a finite set  of colors in  in the input tensors to every update step. Using MLP universality \citep{cybenko1989approximation,hornik1991approximation} , let  be an MLP so that  for all possible colors .  We choose  sufficiently small so that for all possible , ,  satisfies the same properties as  (see Proposition \ref{prop:u}), namely  iff  so that . Note that the 'if' direction is always true by the invariance of the sum operator to permutations of the summands. The 'only if' direction is true for sufficiently small . Indeed, , since . Since this error can be made arbitrary small,  is injective and there is a finite set of possible  then  can be made injective by sufficiently small . 

\subsection{Histogram computation}
So far we have shown we can construct a -order equivariant network  implementing  steps of the -WL algorithm. We take  sufficiently large to discriminate the graphs in our collection as much as -WL is able to. Now, when feeding an input graph this equivariant network outputs  which matches a color  (\ie, vector in ) to each -tuple . 

To produce the final network we need to calculate a feature vector per graph that represents the histogram of its -tuples' colors . As before, since we have a finite set of graphs, the set of colors in  is finite; let  denote this number of colors. Let  be an MLP mapping each color  to the one-hot vector in  representing this color. Applying  entrywise after , namely , followed by the summing invariant operator  defined by ,  provides the desired histogram. Our final -order invariant network is 



\end{proof}

\section{Proof of Theorem \ref{thm:3_WL}}\label{app:thm2}


\begin{proof}
The second claim is proved in Lemma \ref{lem:qmlp_invariance}. Next we construct a network as in \Eqref{e:qmlp} distinguishing a pair of graphs that are -WL distinguishable. As before, we will construct the network distinguishing any finite set of graphs of size . That is, we consider a finite set of input tensors .  

\paragraph{Input.}
We assume our input tensors have the form . The first  channels are as before, namely encode vertex colors (features) and adjacency information. The  channel is simply taken to be the identity matrix, that is .  


\paragraph{Initialization.}
First, we need to implement the -FWL initialization (see Section \ref{ss:WL}). Namely, given an input tensor  construct a tensor that colors -tuples according to their isomorphism type. In this case the isomorphism type is defined by the colors of the two nodes and whether they are connected or not. Let  denote the adjacency matrix, and  the input vertex colors. Construct the tensor  defined by the concatenation of the following colors matrices into one tensor: 
and .
Note that  encodes the isomorphism type of the -tuple sub-graph defined by , since each entry of  holds a concatenation of the node colors times the adjacency matrix of the graph () and the adjacency matrix of the complement graph (); the last channel also contains an indicator if . Note that the transformation  can be implemented with a single block .


\paragraph{-FWL update step.}
Next we implement a -FWL update step, \Eqref{e:FWL_update}, which for  takes the form , , and the input tensor . To implement this we will need to compute a tensor , where the coloring  encodes the multiset . 

As done before, we use the multiset representation described in section \ref{s:colors_and_multisets}. Consider the matrix  defined by

Our goal is to compute an output tensor , where . 

Consider the multi-index set  of cardinality , and write it in the form . Now define polynomial maps  by , and . We apply  to the features of , namely ; similarly, . Now,

hence
 
where  is defined in \Eqref{e:mX_a}. 

To implement this in the network we need to replace  with MLPs , . That is, 

where  is defined in \Eqref{e:mX_a}.

As before, since input tensors belong to a finite set , so are all possible multisets  and all colors, , produced by any part of the network. Similarly to the proof of Theorem \ref{thm:k_wl_k_order} we can take (using the universal approximation theorem) MLPs  so that . We choose  to be sufficiently small so that the map  defined in \Eqref{e:m1_m2}  maintains the injective property of  (see Proposition \ref{prop:u}): It discriminates between  not representing the same multiset. 


Lastly, note that taking  to be the identity transformation and concatenating   concludes the implementation of the -FWL update step. The computation of the color histogram can be done as in the proof of Theorem \ref{thm:k_wl_k_order}.

\end{proof}




\end{document}
