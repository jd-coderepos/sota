\documentclass{article}



\usepackage[final]{neurips_2019}







\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype,xcolor}      \usepackage{wrapfig}
\usepackage{graphicx}
\usepackage{xr}



\usepackage{amsmath,amsfonts,bm,amsthm}

\newcommand{\bell}{\mathrm{b}}
\newcommand{\norm}[1]{\left\Vert#1\right\Vert}
\newcommand{\Norm}[1]{\lvert \! \lvert \! \lvert #1 \rvert \! \rvert \! \rvert}
\newcommand{\abs}[1]{\left\vert#1\right\vert}
\newcommand{\babs}[1]{\Big \vert#1 \Big \vert}
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\mset}[1]{\left\{\kern-.5em\left\{ #1 \right\}\kern-.5em\right\}}
\newcommand{\mmset}[1]{\{\kern-.4em\{ #1 \}\kern-.4em\}}




\newcommand{\parr}[1]{\left (#1\right )}
\newcommand{\brac}[1]{\left [#1\right ]}
\newcommand{\ip}[1]{\left \langle #1 \right \rangle }
\newcommand{\Real}{\mathbb R}
\newcommand{\Nat}{\mathbb N}
\newcommand{\Complex}{\mathbb C}
\newcommand{\eps}{\varepsilon}
\newcommand{\too}{\rightarrow}
\newcommand{\bbar}[1]{\overline{#1}}
\newcommand{\wt}[1]{\widetilde{#1}} \newcommand{\wh}[1]{\widehat{#1}} \newcommand{\diag}{\textrm{diag}} 

\newcommand{\trace}{\textrm{tr}} \def \bfi{\textbf{\footnotesize{i}}} \newcommand{\one}{\mathbf{1}}
\newcommand{\vcc}[1]{\mathrm{vec}(#1)}
\newcommand{\mat}[1]{\bm{[} #1 \bm{]}}

\makeatletter
\newtheorem*{rep@theorem}{\rep@title}
\newcommand{\newreptheorem}[2]{\newenvironment{rep#1}[1]{\def\rep@title{#2 \ref{##1}}\begin{rep@theorem}}{\end{rep@theorem}}}
\makeatother

\newtheorem{theorem}{Theorem}
\newreptheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newreptheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}
\newtheorem{corollary}{Corollary}


\newtheorem{definition}{Definition}




\makeatletter
\newcommand{\subalign}[1]{\vcenter{\Let@ \restore@math@cr \default@tag
    \baselineskip\fontdimen10 \scriptfont\tw@
    \advance\baselineskip\fontdimen12 \scriptfont\tw@
    \lineskip\thr@@\fontdimen8 \scriptfont\thr@@
    \lineskiplimit\lineskip
    \ialign{\hfil$\m@th\scriptstyle##$&$\m@th\scriptstyle{}##$\crcr
      #1\crcr
    }}
}
\makeatletter


\def \etal{{et al}.}
\newcommand{\eg}{{e.g.}}
\newcommand{\ie}{{i.e.}}
\newcommand{\haggai}[1]{{\color{red}{\bf[Haggai:} #1{\bf]}}}
\newcommand{\yl}[1]{{\color{magenta}{\bf[Yaron:} #1{\bf]}}}
\newcommand{\heli}[1]{{\color{blue}{\bf[Heli:} #1{\bf]}}}
\newcommand{\hadar}[1]{{\color{purple}{\bf[Hadar:} #1{\bf]}}}
\newcommand{\revision}[1]{{\color{black} #1}}







\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{$\eta$}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}
\def\valpha{{\bm{\alpha}}}
\def\vbeta{{\bm{\beta}}}
\def\vgamma{{\bm{\gamma}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} \newcommand{\ldblbrace}{\left\{\!\!\left\{}
\newcommand{\rdblbrace}{\right\}\!\!\right\}}


\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak

 

\title{Provably Powerful Graph Networks}



\author{
	Haggai Maron\thanks{Equal contribution} \ \ \   \  Heli Ben-Hamu$^*$ \ \  Hadar Serviansky$^*$ \ \ 	Yaron Lipman \\
Weizmann Institute of Science\\
	Rehovot, Israel \\
}


\begin{document}


\maketitle

\begin{abstract}
Recently, the Weisfeiler-Lehman (WL) graph isomorphism test was used to measure the expressive power of graph neural networks (GNN). It was shown that the popular message passing GNN cannot distinguish between graphs that are indistinguishable by the $1$-WL test \citep{morris2018weisfeiler,xu2018how}. Unfortunately, many simple instances of graphs are indistinguishable by the $1$-WL test. 

In search for more expressive graph learning models we build upon the recent $k$-order invariant and equivariant graph neural networks \citep{maron2018invariant, maron2019universality}  and present two results: 

First, we show that such $k$-order networks can distinguish between non-isomorphic graphs as good as the $k$-WL tests, which are provably stronger than the $1$-WL test for $k>2$. This makes these models strictly stronger than message passing models. Unfortunately, the higher expressiveness of these models comes with a computational cost of processing high order tensors. 

Second, setting our goal at building a provably stronger, \emph{simple} and \emph{scalable}  model we show that a reduced $2$-order network containing just scaled identity operator, augmented with a single quadratic operation (matrix multiplication) has a provable $3$-WL expressive power. Differently put, we suggest a simple model that interleaves applications of standard Multilayer-Perceptron (MLP) applied to the feature dimension and matrix multiplication. 
We validate this model by presenting state of the art results on popular graph classification and regression tasks. To the best of our knowledge, this is the first practical invariant/equivariant model with guaranteed $3$-WL expressiveness, strictly stronger than message passing models.




\end{abstract}
\section{Introduction}








Graphs are an important data modality which is frequently used in many fields of science and engineering. Among other things, graphs are used to model social networks, chemical compounds, biological structures and high-level image content information. One of the major tasks in graph data analysis is learning from graph data. As classical approaches often use hand-crafted graph features that are not necessarily suitable to all datasets and/or tasks (\eg, \cite{kriege2019survey}), a significant research effort in recent years is to develop deep models that are able to learn new graph representations from raw features (\eg, \citet{Gori2005,Duvenaud2015,Niepert2016,kipf,Velickovic2017,monti2017geometric,Hamilton2017,morris2018weisfeiler,xu2018how}).

Currently, the most popular methods for deep learning on graphs are \emph{message passing neural networks} in which the node features are propagated through the graph according to its connectivity structure \citep{Gilmer2017}.  In a successful attempt to quantify the expressive power of message passing models, \citet{morris2018weisfeiler,xu2018how} suggest to compare the model's ability to \emph{distinguish} between two given graphs to that of the hierarchy of the Weisfeiler-Lehman (WL) graph isomorphism tests \citep{grohe2017descriptive,babai2016graph}. Remarkably, they show that the class of message passing models has limited expressiveness and is not better than the first WL test ($1$-WL, a.k.a.~color refinement).  For example, Figure \ref{fig:wl_example} depicts two graphs (\ie, in blue and in green) that $1$-WL cannot distinguish, hence indistinguishable by any message passing algorithm.  

\begin{wrapfigure}[12]{r}{0.25\textwidth}
\vspace{-10pt}
\hspace{7pt}
\includegraphics[width=0.20\textwidth]{1WL.pdf}
\vspace{0pt}
\caption{Two graphs not distinguished by $1$-WL.}\label{fig:wl_example}
\end{wrapfigure} 


The goal of this work is to explore and develop GNN models that possess higher expressiveness while maintaining scalability, as much as possible. We present two main contributions. First, establishing a baseline for expressive GNNs, we prove that the recent $k$-order invariant GNNs \citep{maron2018invariant,maron2019universality} offer a natural hierarchy of models that are as expressive as the $k$-WL tests, for $k\geq 2$. Second, as $k$-order GNNs are not practical for $k>2$ we develop a simple, novel GNN model, that incorporates standard MLPs of the feature dimension and a matrix multiplication layer. This model, working only with $k=2$ tensors (the same dimension as the graph input data), possesses the expressiveness of $3$-WL. Since, in the WL hierarchy, $1$-WL and $2$-WL are equivalent, while $3$-WL is strictly stronger, this model is provably more powerful than the message passing models. For example, it can distinguish the two graphs in Figure \ref{fig:wl_example}. As far as we know, this model is the first to offer both expressiveness ($3$-WL) and scalability ($k=2$). 

The main challenge in achieving high-order WL expressiveness with GNN models stems from the difficulty to represent the multisets of neighborhoods required for the WL algorithms.  We advocate a novel representation of multisets based on Power-sum Multi-symmetric Polynomials (PMP) which are a generalization of the well-known elementary symmetric polynomials. This representation provides a convenient theoretical tool to analyze models' ability to implement the WL tests. 


A related work to ours that also tried to build graph learning methods that surpass the $1$-WL expressiveness offered by message passing is \citet{morris2018weisfeiler}. They develop powerful deep models generalizing message passing to higher orders that are as expressive as higher order WL tests. Although making progress, their full model is still computationally prohibitive for $3$-WL expressiveness and requires a relaxed local version compromising some of the theoretical guarantees. 


Experimenting with our model on several real-world datasets that include classification and regression tasks on social networks, molecules, and chemical compounds, we found it to be on par or better than state of the art. 





\section{Previous work}

\paragraph{Deep learning on graph data.}
The pioneering works that applied neural networks to graphs are \cite{Gori2005,Scarselli2009} that learn node representations using recurrent neural networks, which were also used in \cite{Li2015}. Following the success of convolutional neural networks \citep{krizhevsky2012imagenet}, many works have tried to generalize the notion of convolution to graphs and build networks that are based on this operation. \cite{Bruna2013} defined graph convolutions as operators that are diagonal in the graph laplacian eigenbasis. This paper resulted in multiple follow up works with more efficient and spatially localized convolutions \citep{Henaff2015,Defferrard2016,kipf,Levie2017}. Other works define graph convolutions as local stationary functions that are applied to each node and its neighbours (\eg, \cite{Duvenaud2015,Atwood2015,Niepert2016,hamilton2017representation,Velickovic2017,Monti2018}). Many of these works were shown to be instances of the family of message passing neural networks \citep{Gilmer2017}: methods that apply parametric functions to a node and its neighborhood and then apply some pooling operation in order to generate a new feature for each node. 
 In a recent line of work, it was suggested to define graph neural networks using permutation equivariant operators on tensors describing $k$-order relations between the nodes. \cite{Kondor2018} identified several such linear and quadratic equivariant operators and showed that the resulting network can achieve excellent results on popular graph learning benchmarks. \cite{maron2018invariant} provided a full characterization of linear equivariant operators between tensors of arbitrary order. In both cases, the resulting networks were shown to be at least as powerful as message passing neural networks. In another line of work, \cite{murphy2019relational} suggest expressive invariant graph models defined using averaging over all permutations of an arbitrary base neural network.    



\paragraph{Weisfeiler Lehman graph isomorphism test.} The Weisfeiler Lehman tests is a hierarchy of increasingly powerful graph isomorphism tests \citep{grohe2017descriptive}. 
The WL tests have found many applications in machine learning: in addition to \cite{xu2018how,morris2018weisfeiler}, this idea was used in \cite{shervashidze2011weisfeiler} to construct a graph kernel method, which was further generalized to higher order WL tests in \cite{morris2017glocalized}. \citet{lei2017deriving} showed that their suggested GNN has a theoretical connection to the WL test. WL tests were also used in \cite{zhang2017weisfeiler} for link prediction tasks. In a concurrent work, \citet{morris2019towards} suggest constructing graph features based on an equivalent sparse version of high-order WL achieving great speedup and expressiveness guarantees for sparsely connected graphs. \vspace{-5pt}







\section{Preliminaries}\label{s:prelim}\vspace{-5pt}
We denote a set by $\set{a,b,\ldots,c}$, an ordered set (tuple) by $(a,b,\ldots,c)$ and a multiset (\ie, a set with possibly repeating elements) by $\mmset{a,b,\ldots,c}$. We denote $[n]=\set{1,2,\ldots,n}$, and $(a_i \ \vert \ i\in[n])=(a_1,a_2,\ldots,a_n)$. Let $S_n$ denote the permutation group on $n$ elements. 
We use multi-index $\vi\in[n]^k$ to denote a $k$-tuple of indices, $\vi=(i_1,i_2,\ldots,i_k)$. $g\in S_n$ acts on multi-indices $\vi\in [n]^k$ entrywise by $g(\vi)=(g(i_1), g(i_2), \ldots, g(i_k))$. 
$S_n$ acts on $k$-tensors $\tX\in\Real^{n^k\times a}$ by $(g\cdot \tX)_{\vi,j} = \tX_{g^{-1}(\vi),j}$, where $\vi\in [n]^k$, $j\in [a]$. 



\vspace{-5pt}
\subsection{$k$-order graph networks}\label{ss:k_order_networks}
\vspace{-5pt}
\citet{maron2018invariant} have suggested a family of permutation-invariant deep neural network models for graphs. Their main idea is to construct networks by concatenating maximally expressive linear equivariant layers. More formally, a $k$-order invariant graph network is a composition $F=m\circ h \circ L_d \circ \sigma \circ \cdots \circ \sigma \circ L_1$, where $L_i:\Real^{n^{k_i}\times a_i} \too \Real^{n^{k_{i+1}} \times a_{i+1}}$, $\max_{i\in [d+1]} k_i = k$, are \emph{equivariant linear layers}, namely satisfy $$L_i(g\cdot \tX) = g\cdot L_i(\tX), \qquad \forall g\in S_n, \quad \forall \tX\in \Real^{n^{k_i}\times a_i},$$
$\sigma$ is an entrywise non-linear activation, $\sigma(\tX)_{\vi,j}=\sigma(\tX_{\vi,j})$, $h:\Real^{n^{k_{d+1}} \times a_{d+1}}\too \Real^{a_{d+2 }}$ is an \emph{invariant linear layer}, namely satisfies 
$$h(g\cdot \tX) = h(\tX), \qquad \forall g\in S_n, \quad \forall \tX\in \Real^{n^{k_{d+1}}\times a_{d+1}},$$
and $m$ is a Multilayer Perceptron (MLP). The invariance of $F$ is achieved by construction (by propagating $g$ through the layers using the definitions of equivariance and invariance):  $$F(g\cdot \tX)=m(  \cdots ( L_1(g\cdot \tX)) \cdots ) = m( \cdots ( g\cdot L_1( \tX)) \cdots )=\cdots=m(h(g\cdot L_d(\cdots)))=F(\tX).$$
When $k=2$, \citet{maron2018invariant} proved that this construction gives rise to a model that can approximate any message passing neural network \citep{Gilmer2017} to an arbitrary precision; \citet{maron2019universality} proved these models are universal for a very high tensor order of $k=poly(n)$, which is of little practical value (an alternative proof was recently suggested in \cite{keriven2019universal}).   




\vspace{-5pt}
\subsection{The Weisfeiler-Lehman graph isomorphism test}\label{ss:WL}
\vspace{-5pt}
Let $G=(V,E,d)$ be a colored graph where $|V|=n$ and $d:V\too \Sigma$ defines the color attached to each vertex in $V$, $\Sigma$ is a set of colors.  The Weisfeiler-Lehman (WL) test is a family of algorithms used to test graph isomorphism. Two graphs $G,G'$ are called isomorphic if there exists an edge and color preserving bijection $\phi:V\too V'$. 


There are two families of WL algorithms: $k$-WL and $k$-FWL (Folklore WL), both parameterized by $k=1,2,\ldots,n$. 
$k$-WL and $k$-FWL both construct a coloring of $k$-tuples of vertices, that is $c:V^k \too \Sigma$. Testing isomorphism of two graphs $G,G'$ is then performed by comparing the histograms of colors produced by the $k$-WL (or $k$-FWL) algorithms.

We will represent coloring of $k$-tuples using a tensor $\tC \in \Sigma^{n^k}$, where $\tC_{\vi}\in \Sigma$, $\vi\in [n]^k$ denotes the color of the $k$-tuple $v_\vi=(v_{i_1},\ldots,v_{i_k}) \in V^k$.  In both algorithms, the initial coloring $\tC^0$ is defined using the \emph{isomorphism type} of each $k$-tuple. That is, two $k$-tuples $\vi,\vi'$ have the same isomorphism type (\ie, get the same color, $\tC_\vi=\tC_{\vi'}$) if for all $q,r\in [k]$: (i) $v_{i_q}=v_{i_r} \iff v_{i'_q}=v_{i'_r}$; (ii) $d(v_{i_q})=d(v_{i'_q})$; and (iii) $(v_{i_r},v_{i_q})\in E \iff (v_{i'_r},v_{i'_q})\in E$. Clearly, if $G,G'$ are two isomorphic graphs then there exists $g\in S_n$ so that  $g\cdot\tC'^{0}=\tC^{0}$. 

In the next steps, the algorithms refine the colorings $\tC^l$, $l=1,2,\ldots$ until the coloring does not change further, that is, the subsets of $k$-tuples with same colors do not get further split to different color groups. It is guaranteed that no more than $l=poly(n)$ iterations are required \citep{douglas2011weisfeiler}.   

\begin{wrapfigure}[7]{R}{0.12\textwidth}
\vspace{-12pt}
\includegraphics[scale=0.2]{wl_vs_wlf.pdf}
\vspace{10pt}
\end{wrapfigure}
The construction of $\tC^l$ from $\tC^{l-1}$ differs in the WL and FWL versions. The difference is in how the colors are aggregated from neighboring $k$-tuples. We define two notions of neighborhoods of a $k$-tuple $\vi\in[n]^k$:
\begin{align}
    N_j(\vi) &= \set{ (i_1,\ldots,i_{j-1},i',i_{j+1},\ldots,i_k) \ \Big \vert \  i'\in [n] }   \\
    N^F_j(\vi) &= \Big ( (j,i_2,\ldots,i_k), (i_1,j,\ldots,i_k), \ldots, (i_1,\ldots,i_{k-1},j) \Big )  
\end{align}
$N_j(\vi)$, $j\in [k]$ is the $j$-th neighborhood of the tuple $\vi$ used by the WL algorithm, while $N_j^F(\vi)$, $j\in[n]$ is the $j$-th neighborhood used by the FWL algorithm. Note that $N_j(\vi)$ is a set of $n$ $k$-tuples, while $N^F_j(\vi)$ is an ordered set of $k$  $k$-tuples. The inset to the right illustrates these notions of neighborhoods for the case $k=2$: the top figure shows $N_1(3,2)$ in purple and $N_2(3,2)$ in orange. The bottom figure shows $N^F_j(3,2)$ for all $j=1,\dots,n$ with different colors for different $j$.



The coloring update rules are:
\begin{align}\label{e:WL_update}
\text{WL:} \quad \tC^l_\vi & = \mathrm{enc} \Big( \tC^{l-1}_\vi , \Big( \ \mmset{\tC^{l-1}_\vj \ \vert\  \vj\in N_j(\vi)}  \  \Big\vert \ j\in [k] \ \Big)  \ \ \Big) \\ \label{e:FWL_update}
  \text{FWL:} \quad \tC^l_\vi &= \mathrm{enc}\Big( \tC^{l-1}_\vi , \mset{ \big( \tC^{l-1}_\vj \ \vert \ \vj\in N^F_j(\vi) \big) \ \Big \vert \ j\in [n] } \ \Big)
\end{align}
where $\mathrm{enc}$ is a bijective map from the collection of all possible tuples in the r.h.s.~of  Equations (\plaineqref{e:WL_update})-(\plaineqref{e:FWL_update}) to $\Sigma$. 

When $k=1$ both rules, (\plaineqref{e:WL_update})-(\plaineqref{e:FWL_update}), degenerate to $\tC^l_i=\mathrm{enc} \parr{\tC^{l-1}_i, \mmset{\tC^{l-1}_j \ \vert \ j\in [n]}  }$, which will not refine any initial color. Traditionally, the first algorithm in the WL hierarchy is called WL, $1$-WL, or the \emph{color refinement algorithm}. In color refinement, one starts with the coloring prescribed with $d$. Then, in each iteration, the color at each vertex is refined by a new color representing its current color and the multiset of its neighbors' colors. 

Several known results of WL and FWL algorithms \citep{cai1992optimal,grohe2017descriptive,morris2018weisfeiler,grohe2015pebble} are:
\begin{enumerate}
    \item $1$-WL and $2$-WL have equivalent discrimination power. 
    \item $k$-FWL is equivalent to $(k+1)$-WL for $k\geq 2$.
    \item For each $k\geq 2$ there is a pair of non-isomorphic graphs distinguishable by $(k+1)$-WL but not by $k$-WL. \vspace{-3pt}
\end{enumerate}

\section{Colors and multisets in networks}\label{s:colors_and_multisets}
\vspace{-5pt}
Before we get to the two main contributions of this paper we address three challenges that arise when analyzing networks' ability to implement WL-like algorithms: (i) Representing the colors $\Sigma$ in the network; (ii) implementing a multiset representation; and  (iii) implementing the encoding function. 

\vspace{-3pt}
\paragraph{Color representation.}\vspace{-3pt}
We will represent colors as vectors. That is, we will use tensors $\tC\in \Real^{n^k\times a}$ to encode a color per $k$-tuple; that is, the color of the tuple $\vi\in[n]^k$ is a vector $\tC_\vi \in \Real^a$. This effectively replaces the color tensors $\Sigma^{n^k}$ in the WL algorithm with $\Real^{n^k\times a}$.

\vspace{-3pt}
\paragraph{Multiset representation.}\vspace{-3pt}
A key technical part of our method is the way we encode multisets in networks. Since colors are represented as vectors in $\Real^a$, an $n$-tuple of colors is represented by a matrix $\mX=[x_1,x_2,\ldots,x_n]^T\in\Real^{n \times a}$, where $x_j\in\Real^a$, $j\in[n]$ are the rows of $\mX$. Thinking about $\mX$ as a multiset forces us to be indifferent to the order of rows. That is, the color representing $g\cdot \mX$ should be the same as the color representing $\mX$, for all $g\in S_n$. One possible approach is to perform some sort (\eg, lexicographic) to the rows of $\mX$. Unfortunately, this seems challenging to implement with equivariant layers. 

Instead, we suggest to encode a multiset $\mX$ using a set of $S_n$-invariant functions called the \emph{Power-sum Multi-symmetric Polynomials} (PMP) \citep{briand2004algebra,rydh2007minimal}. The PMP are the multivariate analog to the more widely known \emph{Power-sum Symmetric Polynomials}, $p_j(y)=\sum_{i=1}^n y_i^j$, $j\in [n]$, where $y\in \Real^n$. They are defined next. 
Let $\valpha=(\alpha_1,\ldots,\alpha_a)\in[n]^a$ be a multi-index and for $y\in\Real^a$ we set $y^\valpha = y_1^{\alpha_1} \cdot y_2^{\alpha_2} \cdots y_a^{\alpha_a}$. Furthermore, $\abs{\valpha} = \sum_{j=1}^a \alpha_j$. The PMP of degree $\valpha\in [n]^a$ is 
$$p_\valpha(\mX) = \sum_{i=1}^{n} x_i^\valpha, \quad \mX\in\Real^{n\times a}.$$ 



A key property of the PMP is that the finite subset $p_\valpha$, for $\abs{\valpha}\leq n$ generates the ring of \emph{Multi-symmetric Polynomials} (MP), the set of polynomials $q$ so that $q(g\cdot \mX)=q(\mX)$ for all $g\in S_n$, $\mX\in\Real^{n\times a}$ (see, \eg,  \citep{rydh2007minimal} corollary 8.4). The PMP generates the ring of MP in the sense that for an arbitrary MP $q$, there exists a polynomial $r$ so that $q(\mX)=r\parr{u(\mX)}$, where
\begin{equation}\label{e:u}
    u(\mX):=\parr{p_{\valpha}(\mX) \ \big\vert \ \abs{\valpha}\leq n}.
\end{equation}
As the following proposition shows, a useful consequence of this property is that the vector $u(\mX)$ is a unique representation of the multi-set $\mX\in\Real^{n\times a}$. 
\begin{proposition}\label{prop:u}
For arbitrary $\mX,\mX' \in \Real^{n\times a}$: $\exists g\in S_n$ so that $\mX'=g\cdot \mX$ if and only if $u(\mX)=u(\mX')$. 
\end{proposition}
We note that Proposition \ref{prop:u} is a generalization of lemma 6 in \citet{zaheer2017deep} to the case of multisets of vectors. \revision{This generalization was possible since the PMP  provide a continuous way to encode \textit{vector} multisets (as opposed to scalar multisets in previous works). } The full proof is provided in the supplementary material.

\paragraph{Encoding function.} One of the benefits in the vector representation of colors is that the encoding function can be implemented as a simple concatenation: Given two color tensors $\tC\in\Real^{n^k\times a}$, $\tC'\in \Real^{n^k\times b}$, the tensor that represents for each $k$-tuple $\vi$ the color pair $(\tC_\vi, \tC'_\vi)$ is simply $(\tC,\tC')\in\Real^{n^k\times(a+b)}$.  






\section{$k$-order graph networks are as powerful as $k$-WL}\label{s:as_powerful}
Our goal in this section is to show that, for every $2\leq k \leq n$, $k$-order graph networks \citep{maron2018invariant} are at least as powerful as the $k$-WL graph isomorphism test in terms of distinguishing non-isomorphic graphs. This result is shown by constructing a $k$-order network model and learnable weight assignment that implements the $k$-WL test. 

To motivate this construction we note that the WL update step, \Eqref{e:WL_update}, is equivariant (see proof in the supplementary material). Namely, plugging in $g\cdot \tC^{l-1}$ the WL update step would yield $g\cdot \tC^l$. Therefore, it is plausible to try to implement the WL update step using linear equivariant layers and non-linear pointwise activations. 


\begin{theorem}\label{thm:k_wl_k_order}
Given two graphs $G=(V,E,d)$, $G'=(V',E',d')$ that can be distinguished by the $k$-WL graph isomorphism test, there exists a $k$-order network $F$ so that $F(G)\ne F(G')$. On the other direction for every two isomorphic graphs $G\cong G'$ and $k$-order network $F$, $F(G)=F(G')$.
\end{theorem}
The full proof is provided in the supplementary material. Here we outline the basic idea for the proof. First, an input graph $G=(V,E,d)$ is represented using a tensor of the form  $\tB \in \Real^{n^2\times (e+1)}$, as follows. 
The last channel of $\tB$, namely $\tB_{:,:,e+1}$ ('$:$' stands for all possible values $[n]$) encodes the adjacency matrix of $G$ according to $E$. The first $e$ channels $\tB_{:,:,1:e}$ are zero outside the diagonal, and $\tB_{i,i,1:e}=d(v_i)\in\Real^e$ is the color of vertex $v_i\in V$. 

Now, the second statement in Theorem \ref{thm:k_wl_k_order} is clear since two isomorphic graphs $G,G'$ will have tensor representations satisfying $\tB'=g\cdot \tB$ and therefore, as explained in Section \ref{ss:k_order_networks}, $F(\tB)=F(\tB')$. 

More challenging is showing the other direction, namely that for non-isomorphic graphs  $G,G'$ that can be distinguished by the $k$-WL test, there exists a $k$-network distinguishing $G$ and $G'$. The key idea is to show that a $k$-order network can encode the multisets $\mmset{\tB_\vj \ \vert \ \vj\in N_j(\vi)}$ for a given tensor $\tB\in\Real^{n^k\times a}$. These multisets are the only non-trivial component in the WL update rule, \Eqref{e:WL_update}. 
Note that the rows of the matrix $\mX = \tB_{i_1,\ldots,i_{j-1},:,i_{j+1},\ldots,i_k,:} \in \Real^{n\times a}$ are the colors (\ie, vectors) that define the multiset $\mmset{\tB_\vj \ \vert \ \vj\in N_j(\vi)}$. Following our multiset representation (Section \ref{s:colors_and_multisets}) we would like the network to compute $u(\mX)$ and plug the result at the $\vi$-th entry of an output tensor $\tC$. 

This can be done in two steps: First, applying the polynomial function $\tau:\Real^{a}\too \Real^b$, $b=\left(\begin{smallmatrix}n+a\\ a\end{smallmatrix}\right)$ entrywise to $\tB$, where $\tau$ is defined by $\tau(x)=(x^\valpha \ \vert \ \abs{\valpha}\leq n )$ (note that $b$ is the number of multi-indices $\valpha$ such that $\abs{\valpha}\leq n$). Denote the output of this step $\tY$. Second, apply a linear equivariant operator summing over the $j$-the coordinate of $\tY$ to get $\tC$, that is
$$\tC_{\vi,:} := L_j(\tY)_{\vi,:} = \sum_{i'=1}^n \tY_{i_1,\cdots,i_{j-1},i',i_{j+1},\ldots,i_k,:}=\sum_{\vj\in N_j(\vi)} \tau(\tB_{\vj,:})=u(\mX), \quad \vi\in [n]^k,$$  
where $\mX = \tB_{i_1,\ldots,i_{j-1},:,i_{j+1},\ldots,i_k,:}$ as desired. Lastly, we use the universal approximation theorem \citep{cybenko1989approximation,hornik1991approximation} to replace the polynomial function $\tau$ with an approximating MLP $m:\Real^{a}\too \Real^b$ to get a $k$-order network (details are in the supplementary material). Applying $m$ feature-wise, that is $m(\tB)_{\vi,:}= m(\tB_{\vi,:})$, is in particular a $k$-order network in the sense of Section \ref{ss:k_order_networks}.  

\section{A simple network with 3-WL discrimination  power}\label{s:3WL_network}

\begin{wrapfigure}[12]{R}{0.35\textwidth}
\vspace*{-8pt}\hspace{-5pt}
\includegraphics[scale=0.3]{prod_layer.pdf}
\caption{Block structure.}\label{fig:block}
\end{wrapfigure}
In this section we describe a simple GNN model that has $3$-WL discrimination power. The model has the form 
\begin{equation}\label{e:qmlp}
 F=m\circ h \circ B_d \circ B_{d-1} \cdots \circ B_1,   
\end{equation}
where as in $k$-order networks (see Section \ref{ss:k_order_networks}) $h$ is an invariant layer and $m$ is an MLP. $B_1,\ldots,B_d$ are blocks with the following structure (see figure \ref{fig:block} for an illustration). Let $\tX\in\Real^{n\times n\times a}$ denote the input tensor to the block. First, we apply three MLPs $m_1,m_2:\Real^{a}\too \Real^{b}$, $m_3:\Real^{a}\too \Real^{b'}$ to the input tensor, $m_l(\tX)$, $l\in[3]$. This means applying the MLP to each feature of the input tensor independently, \ie, $m_l(\tX)_{i_1,i_2,:} := m_l(\tX_{i_1,i_2,:})$, $l\in [3]$. Second, matrix multiplication is performed between matching features, \ie, $\tW_{:,:,j} := m_1(\tX)_{:,:,j} \cdot m_2(\tX)_{:,:,j}$, $j\in [b]$. The output of the block is the tensor  $(m_3(\tX),\tW)$.  

We start with showing our basic requirement from GNN, namely invariance:
\begin{lemma}\label{lem:qmlp_invariance}
The model $F$ described above is invariant, \ie, $F(g\cdot \tB)=F(\tB)$, for all $g\in S_n$, and $\tB$.
\end{lemma}
\begin{proof}
Note that matrix multiplication is equivariant: for two matrices $\mA,\mB\in\Real^{n\times n}$ and $g\in S_n$ one has $(g\cdot \mA)\cdot (g\cdot \mB) = g\cdot (\mA\cdot \mB)$. This makes the basic building block $B_i$ equivariant, and consequently the model $F$ invariant, \ie,  $F(g\cdot \tB)=F(\tB)$. 
\end{proof}


Before we prove the $3$-WL power for this model, let us provide some intuition as to why matrix multiplication improves expressiveness. Let us show matrix multiplication allows this model to distinguish between the two graphs in Figure \ref{fig:wl_example}, which are $1$-WL indistinguishable. The input tensor $\tB$ representing a graph $G$ holds the adjacency matrix at the last channel $\mA:=\tB_{:,:,e+1}$. We can build a network with $2$ blocks computing $\mA^3$ and then take the trace of this matrix (using the invariant layer $h$). Remember that the $d$-th power of the adjacency matrix computes the number of $d$-paths between vertices; in particular $\mathrm{tr}(\mA^3)$ computes the number of cycles of length $3$. Counting shows the upper graph in Figure \ref{fig:wl_example} has $0$ such cycles while the bottom graph has $12$.  The main result of this section is:


\begin{theorem}\label{thm:3_WL}
Given two graphs $G=(V,E,d)$, $G'=(V',E',d')$ that can be distinguished by the $3$-WL graph isomorphism test, there exists a network $F$ (\eqref{e:qmlp}) so that $F(G)\ne F(G')$. On the other direction for every two isomorphic graphs $G\cong G'$ and $F$ (\Eqref{e:qmlp}), $F(G)=F(G')$.
\end{theorem}
The full proof is provided in the supplementary material. Here we outline the main idea of the proof. The second part of this theorem is already shown in Lemma \ref{lem:qmlp_invariance}. To prove the first part, namely that the model in \Eqref{e:qmlp} has $3$-WL expressiveness, we show it can implement the $2$-FWL algorithm, that is known to be equivalent to $3$-WL (see Section \ref{ss:WL}). As before, the challenge is in implementing the neighborhood multisets as used in the $2$-FWL algorithm. That is, given an input tensor $\tB\in\Real^{n^2\times a}$ we would like to compute an output tensor $\tC\in\Real^{n^2\times b}$ where $\tC_{i_1,i_2,:}\in\Real^b$ represents a color matching the multiset $\mmset{(\tB_{j,i_2,:},\tB_{i_1,j,:}) \ \vert \ j\in [n]}$.  
As before, we use the multiset representation introduced in section \ref{s:colors_and_multisets}. Consider the matrix $\mX\in\Real^{n \times 2a}$ defined by
\begin{equation}\label{e:mX}
 \mX_{j,:}=(\tB_{j,i_2,:},\tB_{i_1,j,:}), \quad j\in [n].
\end{equation}
Our goal is to compute an output tensor $\tW\in\Real^{n^2\times b}$, where $\tW_{i_1,i_2,:} = u(\mX)$. 

Consider the multi-index set $\set{\valpha \ \vert \ \valpha\in [n]^{2a},  \abs{\valpha}\leq n}$ of cardinality $b=\left(\begin{smallmatrix}n+2a\\ 2a\end{smallmatrix}\right)$, and write it in the form $\set{(\vbeta_l,\vgamma_l) \ \vert \ \vbeta,\vgamma\in [n]^a , \abs{\vbeta_l}+\abs{\vgamma_l} \leq n, l\in b}$. 

Now define polynomial maps $\tau_1,\tau_2 : \Real^a \too \Real^b$ by $\tau_1(x)=(x^{\vbeta_l} \ \vert \ l\in [b])$, and $\tau_2(x)=(x^{\vgamma_l}\ \vert \ l\in [b])$. We apply $\tau_1$ to the features of $\tB$, namely $\tY_{i_1,i_2,l}:=\tau_1(\tB)_{i_1,i_2,l}=(\tB_{i_1,i_2,:})^{\vbeta_l}$; similarly, $\tZ_{i_1,i_2,l}:=\tau_2(\tB)_{i_1,i_2,l}=(\tB_{i_1,i_2,:})^{\vgamma_l}$. Now,
$$\tW_{i_1,i_2,l}:=(\tZ_{:,:,l} \cdot \tY_{:,:,l})_{i_1,i_2} = \sum_{j=1}^n \tZ_{i_1,j,l} \tY_{j,i_2, l} = 
\sum_{j=1}^n \tB_{j,i_2,:}^{\vbeta_l} \tB_{i_1,j,:}^{\vgamma_l}=
\sum_{j=1}^n (\tB_{j,i_2,:},\tB_{i_1,j,:})^{(\vbeta_l,\vgamma_l)},$$
hence
$\tW_{i_1,i_2,:} = u(\mX),$ 
where $\mX$ is defined in \Eqref{e:mX}. To get an implementation with the  model in \Eqref{e:qmlp} we need to replace $\tau_1,\tau_2$ with MLPs. We use the universal approximation theorem to that end (details are in the supplementary material). 

To conclude, each update step of the $2$-FWL algorithm is implemented in the form of a block $B_i$ applying $m_1,m_2$ to the input tensor $\tB$, followed by matrix multiplication of matching features, $\tW = m_1(\tB)\cdot m_2(\tB)$. Since \Eqref{e:FWL_update} requires pairing the multiset with the input color of each $k$-tuple, we take $m_3$ to be identity and get $(\tB,\tW)$ as the block output. 

\paragraph{Generalization to $k$-FWL.} One possible extension is to add a generalized matrix multiplication to $k$-order networks to make them as expressive as $k$-FWL and hence $(k+1)$-WL. Generalized matrix multiplication is defined as follows. Given $\tA^1,\ldots,\tA^k\in\Real^{n^k}$, then $(\odot_{i=1}^k \tA^i)_{\vi} = \sum_{j=1}^n \tA^1_{j,i_2,\ldots,i_k}\tA^2_{i_1,j,\ldots,i_k}\cdots \tA^k_{i_1,\ldots,i_{k-1},j}$.


\revision{\paragraph{Relation to \citep{morris2018weisfeiler}.} Our model offers two benefits over the 1-2-3-GNN suggested in the work of \cite{morris2018weisfeiler}, a recently suggested GNN that also surpasses the expressiveness of message passing networks. First, it has lower space complexity (see details below). This allows us to work with a provably 3-WL expressive model while \cite{morris2018weisfeiler} resorted to a local 3-GNN version, hindering their 3-WL expressive power. Second, from a practical point of view our model is arguably simpler to implement as it only consists of fully connected layers and matrix multiplication (without having to account for all subsets of size 3). }

\revision{ \paragraph{Complexity analysis of a single block.}  Assuming a graph with $n$ nodes, dense edge data and a
constant feature depth, the layer proposed in \cite{morris2018weisfeiler} has $O(n^3)$ space complexity (number of subsets) and $O(n^4)$ time complexity ($O(n^3)$ subsets with $O(n)$ neighbors each). Our layer (block), however, has $O(n^2)$ space complexity as only second order tensors are stored (i.e., linear in the size of the graph data), and time complexity of $O(n^3)$ due to the matrix multiplication. We note that the time complexity of \cite{morris2018weisfeiler} can probably be improved to $O(n^3)$ while our time complexity can be improved to $O(n^{2.x})$ due to more advanced matrix multiplication algorithms. }





\section{Experiments}

\begin{table}[t]
	\centering
	\tiny
	\caption{Graph Classification Results on the datasets from \cite{Yanardag2015}}
	\resizebox{\columnwidth}{!}{
	
	\begin{tabular}{@{\hskip8pt}l@{\hskip8pt}r@{\hskip8pt}r@{\hskip8pt}r@{\hskip8pt}r@{\hskip8pt}r@{\hskip8pt}r@{\hskip8pt}r@{\hskip8pt}r@{\hskip8pt}}
		\toprule
		dataset & \multicolumn{1}{l}{MUTAG} & \multicolumn{1}{l}{PTC} & \multicolumn{1}{l}{PROTEINS} & \multicolumn{1}{l}{NCI1} & \multicolumn{1}{l}{NCI109} & \multicolumn{1}{l}{COLLAB} & \multicolumn{1}{l}{IMDB-B} & \multicolumn{1}{l}{IMDB-M} \\
		\midrule
		size  & 188   & 344   &  1113  & 4110  & 4127  & 5000  & 1000  & 1500 \\
		classes & 2     & 2     &  2     & 2     & 2     & 3     & 2     & 3 \\
		avg node \# & 17.9  & 25.5  &  39.1  & 29.8  & 29.6  & 74.4  & 19.7  & 13 \\
		\midrule
		\multicolumn{9}{c}{Results} \\
		\midrule
		GK \citep{shervashidze2009efficient}    & 81.39$\pm$1.7 & 55.65$\pm$0.5 &  71.39$\pm$0.3 & 62.49$\pm$0.3 & 62.35$\pm$0.3 & NA    & NA    & NA \\
		RW  \citep{vishwanathan2010graph}   & 79.17$\pm$2.1 & 55.91$\pm$0.3 &  59.57$\pm$0.1 & $>3$ days & NA    & NA    & NA    & NA \\
		PK \citep{neumann2016propagation}    & 76$\pm$2.7 & 59.5$\pm$2.4 &  73.68$\pm$0.7 & 82.54$\pm$0.5 & NA    & NA    & NA    & NA \\
		WL \citep{shervashidze2011weisfeiler}    & 84.11$\pm$1.9 & 57.97$\pm$2.5 &  \bf{74.68$\pm$0.5} & \bf{84.46$\pm$0.5} & \bf{85.12$\pm$0.3} & NA    & NA    & NA \\
		
		FGSD  \citep{verma2017hunt}  & \bf{92.12} & \bf{62.80} &  73.42 & 79.80 & 78.84 & \bf{80.02}  & 73.62    & \bf{52.41} \\
		
		AWE-DD \citep{ivanov2018anonymous}   & NA & NA &  NA & NA & NA & 73.93$\pm 1.9$    & \bf{74.45 $\pm$ 5.8}    & 51.54 $\pm3.6$ \\
		AWE-FB \citep{ivanov2018anonymous}    & 87.87$\pm$9.7&NA &  NA & NA & NA & 70.99 $\pm $ 1.4  & 73.13 $\pm$3.2    & 51.58 $\pm$ 4.6 \\
		
		\midrule
			DGCNN \citep{Zhang} & 85.83$\pm$1.7 & 58.59$\pm$2.5 &  75.54$\pm$0.9 & 74.44$\pm$0.5 & NA    & 73.76$\pm$0.5 & 70.03$\pm$0.9 & 47.83$\pm$0.9 \\
		PSCN \citep{Niepert2016}{\tiny (k=10)} & 88.95$\pm$4.4 & 62.29$\pm$5.7 & 75$\pm$2.5 & 76.34$\pm$1.7 & NA    & 72.6$\pm$2.2 & 71$\pm$2.3 & 45.23$\pm$2.8 \\
		DCNN \citep{Atwood2015}  & NA    & NA    &  61.29$\pm$1.6 & 56.61$\pm$ 1.0 & NA    & 52.11$\pm$0.7 & 49.06$\pm$1.4 & 33.49$\pm$1.4 \\
		ECC \citep{Simonovsky2017}  & 76.11 & NA    &  NA    & 76.82 & 75.03 & NA    & NA    & NA \\
		DGK \citep{Yanardag2015}  & 87.44$\pm$2.7 & 60.08$\pm$2.6 &  75.68$\pm$0.5 & 80.31$\pm$0.5 & 80.32$\pm$0.3 & 73.09$\pm$0.3 & 66.96$\pm$0.6 & 44.55$\pm$0.5 \\
		DiffPool \citep{Ying2018} & NA    & NA    &  \bf{78.1}  & NA    & NA    & 75.5  & NA    & NA \\
		CCN \citep{Kondor2018}  & \bf{91.64$\pm$7.2} & \bf{70.62$\pm$7.0} &  NA    & 76.27$\pm$4.1 & 75.54$\pm$3.4 & NA    & NA    & NA \\
		
		
	Invariant Graph Networks \citep{maron2018invariant}  & 83.89$\pm$12.95     & 58.53$\pm$6.86     &  76.58$\pm$5.49     & 74.33$\pm$2.71     & 72.82$\pm$1.45     & 78.36$\pm$2.47  & 72.0$\pm$5.54   & 48.73$\pm$3.41 \\
		GIN  \citep{xu2018how}& 89.4$\pm$5.6     & 64.6$\pm$7.0     &  76.2$\pm$2.8     & 82.7$\pm$1.7     & NA     & 80.2$\pm$1.9  & \bf{75.1$\pm$5.1} & \bf{52.3$\pm$2.8} \\
		1-2-3 GNN \citep{morris2018weisfeiler} & 86.1$\pm$    & 60.9$\pm$     &  75.5$\pm$     & 76.2$\pm$     & NA     & NA  & 74.2$\pm$ & 49.5$\pm$ \\
Ours 1  & 90.55$\pm$8.7     & 66.17$\pm$6.54     &  77.2$\pm$4.73     &  \bf{83.19$\pm$1.11}  & \bf{81.84$\pm$1.85}     & 80.16$\pm$1.11  & 72.6$\pm$4.9 & 50$\pm$3.15 \\
		Ours 2  & 88.88$\pm$7.4  &  64.7$\pm$7.46  &  76.39$\pm$5.03  &  81.21$\pm$2.14  &  \bf{81.77$\pm$1.26}  &  \bf{81.38$\pm$1.42}  &  72.2$\pm$4.26  &  44.73$\pm$7.89  \\
		Ours 3  & 89.44$\pm$8.05  &  62.94$\pm$6.96  &  76.66$\pm$5.59  &  80.97$\pm$1.91  &  \bf{82.23$\pm$1.42}  &  \bf{80.68$\pm$1.71}  &  73$\pm$5.77  &  50.46$\pm$3.59   \\
		Rank & $\mathbf{3^{rd}}$ & $\mathbf{2^{nd}}$ & $\mathbf{2^{nd}}$ & $\mathbf{2^{nd}}$ & $\mathbf{2^{nd}}$ & $\mathbf{1^{st}}$ & $\mathbf{6^{th}}$ & $\mathbf{5^{th}}$ \\
		\bottomrule
	\end{tabular}}
	\label{tab:class_res}\vspace{-10pt}
\end{table}\paragraph{Implementation details.} We implemented the GNN model as described in Section \ref{s:3WL_network} (see \Eqref{e:qmlp}) using the TensorFlow framework \citep{abadi2016tensorflow}. We used three identical blocks $B_1,B_2,B_3$, where in each block $B_i:\Real^{n^2\times a} \too \Real^{n^2\times b}$ we took $m_3(x)=x$ to be the identity (\ie, $m_3$ acts as a skip connection, similar to its role in the proof of Theorem \ref{thm:3_WL}); $m_1,m_2:\Real^a \too \Real^b$ are chosen as $d$ layer MLP with hidden layers of $b$ features. After each block $B_i$ we also added a single layer MLP $m_4:\Real^{b+a}\too \Real^b$. Note that although this fourth MLP is not described in the model in Section \ref{s:3WL_network} it clearly does not decrease (nor increase) the theoretical expressiveness of the model; we found it efficient for coding as it reduces the parameters of the model. For the first block, $B_1$, $a=e+1$, where for the other blocks $b=a$. The MLPs are implemented with $1\times 1$ convolutions.




\begin{wraptable}[13]{R}{0.45\textwidth} \vspace*{-5pt}
\caption{Regression, the QM9 dataset.}\label{tab:regression}
  \centering
   \resizebox{0.45\textwidth}{!}{ \begin{tabular}{lrrrrr}
    \toprule
    Target & \multicolumn{1}{l}{DTNN} & \multicolumn{1}{l}{MPNN} & \multicolumn{1}{l}{123-gnn} & \multicolumn{1}{l}{Ours 1} & \multicolumn{1}{l}{Ours 2} \\
    \midrule
    $\mu$    & 0.244 & 0.358 & 0.476 & \bf{0.231} & \bf{0.0934} \\
    $\alpha$ & 0.95  & 0.89  & \bf{0.27}  & 0.382 & 0.318 \\
    $\epsilon_{homo}$ & 0.00388 & 0.00541 & 0.00337 & \bf{0.00276} & \bf{0.00174} \\
    $\epsilon_{lumo} $& 0.00512 & 0.00623 & 0.00351 & \bf{0.00287} & \bf{0.0021} \\
    $\Delta_\epsilon $& 0.0112 & 0.0066 & 0.0048 & \bf{0.00406} & \bf{0.0029} \\
    $\langle R^2 \rangle$ & 17    & 28.5  & 22.9  & \bf{16.07} &  \bf{3.78} \\
    $ZPVE  $& 0.00172 & 0.00216 & \bf{0.00019} & 0.00064 & 0.000399 \\
    $U_0    $& -  & -  & 0.0427 & 0.234 & \bf{0.022} \\
    $U    $& -  & -     & 0.111 & 0.234 & \bf{0.0504} \\
    $H     $& -  & -  & 0.0419 & 0.229 & \bf{0.0294} \\
    $G     $& -  & -  & 0.0469 & 0.238 & \bf{0.024} \\
    $C_v  $& 0.27  & 0.42  & \bf{0.0944} & 0.184 & 0.144 \\
    \bottomrule
    \end{tabular}}
  \label{tab:reg_res}\end{wraptable}
Parameter search was conducted on learning rate and learning rate decay, as detailed below.  
We have experimented with two network suffixes adopted from previous papers: (i) The suffix used in \cite{maron2018invariant} that consists of an invariant max pooling (diagonal and off-diagonal) followed by a three Fully Connected (FC) with hidden units' sizes of $(512,256, \# \text{classes})$;  (ii) the suffix used in \cite{xu2018how} adapted to our network: we apply the invariant max layer from \cite{maron2018invariant} to the output of every block followed by a single fully connected layer to $\# \text{classes}$. These outputs are then summed together and used as the network output on which the loss function is defined.




\paragraph{Datasets.} We evaluated our network on two different tasks: Graph classification and graph regression. For classification, we tested our method on eight real-world graph datasets from \citep{Yanardag2015}: three datasets consist of social network graphs, and the other five datasets come from bioinformatics and represent chemical compounds or protein structures. Each graph is represented by an adjacency matrix and possibly categorical node features (for the bioinformatics datasets). For the regression task, we conducted an experiment on a standard graph learning benchmark called the QM9 dataset \citep{ramakrishnan2014quantum, wu2018moleculenet}. It is composed of 134K small organic molecules (sizes vary from 4 to 29 atoms). Each molecule is represented by an adjacency matrix, a distance matrix (between atoms), categorical data on the edges, and node features; the data was obtained from the pytorch-geometric library \citep{fey2019fast}. The task is to predict 12 real valued physical quantities for each molecule. 




\paragraph{Graph classification results.} 
We follow the standard 10-fold cross validation protocol and splits from \cite{Zhang} and report our results according to the protocol described in \cite{xu2018how}, namely the best averaged accuracy across the 10-folds. Parameter search was conducted on a fixed random 90$\%$-10$\%$ split: learning rate in $\set{5\cdot10^{-5},10^{-4},5\cdot10^{-4},10^{-3}}$; learning rate decay in $[0.5,1]$ every $20$ epochs.
We have tested three architectures: (1) $b=400$, $d=2$, and suffix (ii); (2) $b=400$, $d=2$, and suffix (i); and (3) $b=256$, $d=3$, and suffix (ii). (See above for definitions of $b,d$ and suffix). Table \ref{tab:class_res} presents a summary of the results (top part - non deep learning methods). The last row presents our ranking compared to all previous methods; note that we have scored in the top $3$ methods in $6$ out of $8$ datasets.  




\pagebreak
\paragraph{Graph regression results.}  
The data is randomly split into 80\% train, 10\% validation and 10\% test. We have conducted the same parameter search as in the previous experiment on the validation set.  We have used the network (2) from classification experiment, \ie, $b=400$, $d=2$, and suffix (i), with an absolute error loss adapted to the regression task. Test results are according to the best validation error. We have tried two different settings: (1) training a single network to predict all the output quantities together and (2) training a different network for each quantity. Table \ref{tab:regression} compares the mean absolute error of our method with three other methods: 123-gnn \citep{morris2018weisfeiler} and \citep{wu2018moleculenet}; results of all previous work were taken from \citep{morris2018weisfeiler}. Note that our method achieves the lowest error on 5 out of the 12 quantities when using a single network, and the lowest error on 9 out of the 12 quantities in case each quantity is predicted by an independent network. 

\paragraph{Equivariant layer evaluation.} 

\begin{wrapfigure}[19]{r}{0.31\textwidth}\vspace{-15pt}
\includegraphics[scale=0.3]{comparison.pdf}
\end{wrapfigure}
The model in Section \ref{s:3WL_network} does not incorporate all equivariant linear layers as characterized in \citep{maron2018invariant}. It is therefore of interest to compare this model to models richer in linear equivariant layers, as well as a simple MLP baseline (\ie, without matrix multiplication). We performed such an experiment on the NCI1 dataset \citep{Yanardag2015} comparing: (i) our suggested model, denoted Matrix Product (MP); (ii) matrix product + full linear basis from \citep{maron2018invariant} (MP+LIN); (iii) only full linear basis (LIN); and (iv) MLP applied to the feature dimension. 

Due to the memory limitation in \citep{maron2018invariant} we used the same feature depths of $b_1=32, b_2=64, b_3=256$, and $d=2$. The inset shows the performance of all methods on both training and validation sets, where we performed a parameter search on the learning rate (as above) for a fixed decay rate of $0.75$ every $20$ epochs. Although all methods (excluding MLP) are able to achieve a zero training error, the (MP) and (MP+LIN) enjoy better generalization than the linear basis of \cite{maron2018invariant}. Note that (MP) and (MP+LIN) are comparable, however (MP) is considerably more efficient. 

\section{Conclusions}
We explored two models for graph neural networks that possess superior graph distinction abilities compared to existing models. First, we proved that $k$-order invariant networks offer a hierarchy of neural networks that parallels the distinction power of the $k$-WL tests. This model has lesser practical interest due to the high dimensional tensors it uses. Second, we suggested a simple GNN model consisting of only MLPs augmented with matrix multiplication and proved it achieves $3$-WL expressiveness. 
This model operates on input tensors of size $n^2$ and therefore useful for problems with dense edge data. The downside is that its complexity is still quadratic, worse than message passing type methods. An interesting future work is to search for more efficient GNN models with high expressiveness. Another interesting research venue is quantifying the generalization ability of these models. 

\subsection*{Acknowledgments}
This research was supported in part by the European Research Council (ERC Consolidator Grant, "LiftMatch" 771136) and the Israel Science Foundation (Grant No. 1830/17).

\bibliography{graph.bib}
\bibliographystyle{apalike}
\appendix
\section{Proof of Proposition \ref{prop:u}} \label{app:prop1}
\begin{proof}
First, if $\mX'=g\cdot \mX$, then $p_\valpha(\mX)=p_\valpha(\mX')$ for all $\valpha$ and therefore $u(\mX)=u(\mX')$. In the other direction assume by way of contradiction that $u(\mX)=u(\mX')$ and $g\cdot \mX \ne \mX'$, for all $g\in S_n$. That is, $\mX$ and $\mX'$ represent different multisets. 
Let $[\mX]=\set{g\cdot \mX \ \vert \ g\in S_n}$ denote the orbit of $\mX$ under the action of $S_n$; similarly denote $[\mX']$. Let $K\subset \Real^{n\times a}$ be a compact set containing $[\mX],[\mX']$, where $[\mX]\cap [\mX'] = \emptyset$ by assumption. 

By the Stone–Weierstrass Theorem applied to the algebra of continuous functions $C(K,\Real)$ there exists a polynomial $f$ so that $f\vert_{[\mX]}\geq 1$ and $f\vert_{[\mX']}\leq 0$.  Consider the polynomial $$q(\mX)=\frac{1}{n!}\sum_{g\in S_n} f(g\cdot \mX).$$ 

By construction $q(g\cdot \mX)=q(\mX)$, for all $g\in S_n$. Therefore $q$ is a multi-symmetric polynomial. Therefore, $q(\mX)=r(u(\mX))$ for some polynomial $r$.
On the other hand, $$1\leq q(\mX) = r(u(\mX)) = r(u(\mX')) = q(\mX') \leq 0,$$ where we used the assumption that $u(\mX)=u(\mX')$. We arrive at a contradiction.
\end{proof}


\section{Proof of equivairance of WL update step}\label{app:thm_equi_wl}
Consider the formal tensor $\tB^j$ of dimension ${n^k}$ with multisets as entries:
\begin{equation}\label{e:Bj}
    \tB^j_\vi = \mmset{\tC^{l-1}_\vj \ \vert\  \vj\in N_j(\vi)}.
\end{equation} Then the $k$-WL update step (\Eqref{e:WL_update}) can be written as 
\begin{equation}\label{e:WL_update_simpler}
    \tC^l_\vi=\mathrm{enc}\parr{\tC^{l-1}_\vi, \tB^1_\vi, \tB^2_\vi,\ldots, \tB^k_\vi}.
\end{equation} To show equivariance, it is enough to show that each entry of the r.h.s.~tuple is equivariant. For its  first entry: $(g\cdot \tC^{l-1})_\vi=\tC^{l-1}_{g^{-1}(\vi)}$. For the other entries, consider w.l.o.g.~$\tB^j_\vi$: 
$$\mmset{(g\cdot\tC^{l-1})_{\vj} \ \vert \ \vj \in N_j(\vi) } = \mmset{\tC^{l-1}_{g^{-1}(\vj)} \ \vert \ \vj \in  N_j(\vi) } = \mmset{\tC^{l-1}_{\vj} \ \vert \ \vj \in N_j(g^{-1}(\vi)) }=\tB^j_{g^{-1}(\vi)}.$$ We get that feeding $k$-WL update rule with  $g\cdot \tC^{l-1}$ we get as output $\tC^l_{g^{-1}(\vi)}=(g\cdot \tC^l)_\vi$. 




\section{Proof of Theorem \ref{thm:k_wl_k_order}}\label{app:thm1}

\begin{proof}

We will prove a slightly stronger claim: Assume we are given some finite set of graphs. For example, we can think of all combinatorial graphs (\ie, graphs represented by binary adjacency matrices) of $n$ vertices . Our task is to build a $k$-order network $F$ that assigns different output $F(G)\ne F(G')$ whenever $G,G'$ are non-isomorphic graphs distinguishable by the $k$-WL test. 

Our construction of $F$ has three main steps. First in Section \ref{sss:input_and_init} we implement the initialization step. Second, Section \ref{sss:update_step} we implement the coloring update rules of the $k$-WL. Lastly, we implement a histogram calculation providing different features to $k$-WL distinguishable graphs in the collection. 



\subsection{Input and Initialization}\label{sss:input_and_init}

\paragraph{Input.}
The input to the network can be seen as a tensor of the form  $\tB \in \Real^{n^2\times (e+1)}$ encoding an input graph $G=(V,E,d)$, as follows. 
The last channel of $\tB$, namely $\tB_{:,:,e+1}$ ('$:$' stands for all possible values $[n]$) encodes the adjacency matrix of $G$ according to $E$. The first $e$ channels $\tB_{:,:,1:e}$ are zero outside the diagonal, and $\tB_{i,i,1:e}=d(v_i)\in\Real^e$ is the color of vertex $v_i\in V$. 
Our assumption of finite graph collection means the set $\Omega\subset \Real^{n^2\times (e+1)}$ of possible input tensors $\tB$ is finite as well. 
Next we describe the different parts of $k$-WL implementation with $k$-order network. For brevity, we will denote by $\tB\in\Real^{n^k\times a}$ the input to each part and by $\tC \in \Real^{n^k\times b}$ the output. 

\paragraph{Initialization.}
We start with implementing the initialization of $k$-WL, namely computing a coloring representing the isomorphism type of each $k$-tuple. 
Our first step is to define a linear equivariant operator that extracts the sub-tensor corresponding to each multi-index $\vi$: let $L:\Real^{n^2 \times (e+1)}\too \Real^{n^k \times k^2 \times (e+2)}$ be the linear operator defined by 
\begin{align*}
    &L(\tX)_{\vi,r,s,w} =\tX_{i_{r},i_{s},w}, \quad w\in [e+1] \\ 
    &L(\tX)_{\vi,r,s,e+2} = \begin{cases} 1 & i_r=i_s \\ 0 & \text{otherwise} \end{cases}
\end{align*} 
for $\vi\in [n]^k, r,s\in[k]$. 

$L$ is equivariant with respect to the permutation action. Indeed, for $w\in[e+1]$, 
$$(g\cdot L(\tX))_{\vi,r,s,w} = L(\tX)_{g^{-1}(\vi),r,s,w} = \tX_{g^{-1}(i_r),g^{-1}(i_s),w} = (g\cdot \tX)_{i_r,i_s,w}= L(g\cdot \tX)_{\vi,r,s,w}.$$ 
For $w=e+2$ we have 
$$(g\cdot L(\tX))_{\vi,r,s,w} = L(\tX)_{g^{-1}(\vi),r,s,w} =  \begin{cases} 1 & g^{-1}(i_r)=g^{-1}(i_s) \\ 0 & \text{otherwise} \end{cases} = 
\begin{cases} 1 & i_r=i_s \\ 0 & \text{otherwise} \end{cases} = L(g\cdot \tX)_{\vi,r,s,w}.$$
Since $L$ is linear and equivariant it can be represented as a single linear layer in a $k$-order network. Note that $L(\tB)_{\vi,:,:,1:(e+1)}$ contains the sub-tensor of $\tB$ defined by the $k$-tuple of vertices $(v_{i_1},\ldots,v_{i_k})$, and $L(\tB)_{\vi,:,:,e+2}$ represents the equality pattern of the $k$-tuple $\vi$, which is equivalent to the equality pattern of the $k$-tuple of vertices $(v_{i_1},\ldots,v_{i_k})$. Hence, $L(\tB)_{\vi,:,:,:}$ represents the isomorphism type of the $k$-tuple of vertices $(v_{i_1},\ldots,v_{i_k})$. The first layer of our construction is therefore $\tC=L(\tB)$. 



\subsection{$k$-WL update step} \label{sss:update_step}
We next implement \Eqref{e:WL_update}. We achieve that in 3 steps. As before let $\tB\in\Real^{n^k\times a}$ be the input tensor to the the current $k$-WL step.

First, apply the polynomial function $\tau:\Real^{a}\too \Real^b$, $b=\left(\begin{smallmatrix}n+a\\ a\end{smallmatrix}\right)$ entrywise to $\tB$, where $\tau$ is defined by $\tau(x)=(x^\valpha)_{\abs{\valpha}\leq n}$ (note that $b$ is the number of multi-indices $\valpha$ such that $\abs{\valpha}\leq n$). This gives $\tY\in\Real^{n^k\times b}$ where $\tY_{\vi,:}=\tau(\tB_{\vi,:})\in\Real^b$.

Second, apply the linear operator $$\tC^j_{\vi,r} := L_j(\tY)_{\vi,r} = \sum_{i'=1}^n \tY_{i_1,\cdots,i_{j-1},i',i_{j+1},\ldots,i_k,r}, \quad \vi\in [n]^k, r\in [b].$$  
$L_j$ is equivariant with respect to the permutation action. Indeed, 
$L_j(g\cdot \tY)_{\vi,r}=$ $$\sum_{i'=1}^n (g\cdot \tY)_{i_1,\cdots,i_{j-1},i',i_{j+1},\ldots,r}
=\sum_{i'=1}^n \tY_{g^{-1}(i_1)\cdots,g^{-1}(i_{j-1}),i',g^{-1}(i_{j+1}),\ldots,r}=L_j(\tY)_{g^{-1}(\vi),r} = (g\cdot L_j(\tY))_{\vi,r}.$$
Now, note that $$\tC^j_{\vi,:}=L_j(\tY)_{\vi,:}=\sum_{i'=1}^n \tau(\tB_{i_1,\cdots,i_{j-1},i',i_{j+1},\ldots,i_k,:})=\sum_{\vj\in N_j(\vi)} \tau(\tB_{\vj,:})=u(\mX),$$ where $\mX = \tB_{i_1,\ldots,i_{j-1},:,i_{j+1},\ldots,i_k,:}$ as desired. 

Third, the $k$-WL update step is the concatenation: $(\tB,\tC^1,\ldots,\tC^k)$. 


To finish this part we need to replace the polynomial function $\tau$ with an MLP $m:\Real^a\too\Real^b$. Since there is a finite set of input tensors $\Omega$, there could be only a finite set $\Upsilon$ of colors in $\Real^{a}$ in the input tensors to every update step. Using MLP universality \citep{cybenko1989approximation,hornik1991approximation} , let $m$ be an MLP so that $\norm{\tau(x)-m(x)}<\epsilon$ for all possible colors $x\in\Upsilon$.  We choose $\epsilon$ sufficiently small so that for all possible $\mX = \parr{\tB_{\vj} \ \vert \ \vj\in N_j(\vi)}\in\Real^{n\times a} $, $\vi\in[n]^k,j\in [k]$, $v(\mX)=\sum_{i\in [n]}m(x_i)$ satisfies the same properties as $u(\mX)=\sum_{i\in[n]}\tau(x_i)$ (see Proposition \ref{prop:u}), namely $v(\mX)=v(\mX')$ iff $\exists g\in S_n$ so that $\mX'=g\cdot \mX$. Note that the 'if' direction is always true by the invariance of the sum operator to permutations of the summands. The 'only if' direction is true for sufficiently small $\epsilon$. Indeed, $\norm{v(\mX)-u(\mX)}\leq n \max_{i\in [n]}{\norm{m(x_i)-\tau(x_i)}} \leq n\epsilon$, since $x_i\in \Upsilon$. Since this error can be made arbitrary small, $u$ is injective and there is a finite set of possible $\mX$ then $v$ can be made injective by sufficiently small $\epsilon>0$. 

\subsection{Histogram computation}
So far we have shown we can construct a $k$-order equivariant network $H= L_d \circ \sigma \circ \cdots \circ \sigma \circ L_1$ implementing $d$ steps of the $k$-WL algorithm. We take $d$ sufficiently large to discriminate the graphs in our collection as much as $k$-WL is able to. Now, when feeding an input graph this equivariant network outputs $H(\tB)\in\Real^{n^k\times a}$ which matches a color $H(\tB)_{\vi,:}$ (\ie, vector in $\Real^a$) to each $k$-tuple $\vi\in [n]^k$. 

To produce the final network we need to calculate a feature vector per graph that represents the histogram of its $k$-tuples' colors $H(\tB)$. As before, since we have a finite set of graphs, the set of colors in $H(\tB)$ is finite; let $b$ denote this number of colors. Let $m:\Real^a\too \Real^b$ be an MLP mapping each color $x\in\Real^a$ to the one-hot vector in $\Real^b$ representing this color. Applying $m$ entrywise after $H$, namely $m(H(\tB))$, followed by the summing invariant operator $h:\Real^{n^k\times b}\too \Real^b$ defined by $h(\tY)_j= \sum_{\vi\in [n]^k} \tY_{\vi,j}$, $j\in [b]$ provides the desired histogram. Our final $k$-order invariant network is 
$$F=h \circ m \circ L_d \circ \sigma \circ \cdots \circ \sigma \circ L_1.$$


\end{proof}

\section{Proof of Theorem \ref{thm:3_WL}}\label{app:thm2}


\begin{proof}
The second claim is proved in Lemma \ref{lem:qmlp_invariance}. Next we construct a network as in \Eqref{e:qmlp} distinguishing a pair of graphs that are $3$-WL distinguishable. As before, we will construct the network distinguishing any finite set of graphs of size $n$. That is, we consider a finite set of input tensors $\Omega\subset \Real^{n^2\times (e+2)}$.  

\paragraph{Input.}
We assume our input tensors have the form $\tB\in\Real^{n^2\times(e+2)}$. The first $e+1$ channels are as before, namely encode vertex colors (features) and adjacency information. The $e+2$ channel is simply taken to be the identity matrix, that is $\tB_{:,:,e+2} = I_d$.  


\paragraph{Initialization.}
First, we need to implement the $2$-FWL initialization (see Section \ref{ss:WL}). Namely, given an input tensor $\tB\in\Real^{n^2\times (e+1)}$ construct a tensor that colors $2$-tuples according to their isomorphism type. In this case the isomorphism type is defined by the colors of the two nodes and whether they are connected or not. Let $\mA:=\tB_{:,:,e+1}$ denote the adjacency matrix, and $\tY:=\tB_{:,:,1:e}$ the input vertex colors. Construct the tensor $\tC\in\Real^{n^2\times (4e+1)}$ defined by the concatenation of the following colors matrices into one tensor: $$\mA\cdot \tY_{:,:,j}, \quad (\one\one^T - \mA)\cdot \tY_{:,:,j}, \quad  \tY_{:,:,j}\cdot \mA, \quad \tY_{:,:,j}\cdot (\one\one^T - \mA), \quad  j\in[e],$$
and $\tB_{:,:,e+2}$.
Note that $\tC_{i_1,i_2,:}$ encodes the isomorphism type of the $2$-tuple sub-graph defined by $v_{i_1},v_{i_2}\in V$, since each entry of $\tC$ holds a concatenation of the node colors times the adjacency matrix of the graph ($\mA$) and the adjacency matrix of the complement graph ($\one \one^T-A$); the last channel also contains an indicator if $v_{i_1}=v_{i_2}$. Note that the transformation $\tB\mapsto \tC$ can be implemented with a single block $B_1$.


\paragraph{$2$-FWL update step.}
Next we implement a $2$-FWL update step, \Eqref{e:FWL_update}, which for $k=2$ takes the form $\tC_\vi = \mathrm{enc}\Big( \tB_\vi , \mset{ (\tB_{j,i_2},\tB_{i_1,j}) \ \Big \vert \ j\in [n] } \ \Big)$, $\vi=(i_1,i_2)$, and the input tensor $\tB\in\Real^{n^2\times a}$. To implement this we will need to compute a tensor $\tY$, where the coloring $\tY_\vi$ encodes the multiset $\mset{ (\tB_{j,i_2,:},\tB_{i_1,j,:}) \ \Big \vert \ j\in [n] }$. 

As done before, we use the multiset representation described in section \ref{s:colors_and_multisets}. Consider the matrix $\mX\in\Real^{n \times 2a}$ defined by
\begin{equation}\label{e:mX_a}
 \mX_{j,:}=(\tB_{j,i_2,:},\tB_{i_1,j,:}), \quad j\in [n].
\end{equation}
Our goal is to compute an output tensor $\tW\in\Real^{n^2\times b}$, where $\tW_{i_1,i_2,:} = u(\mX)$. 

Consider the multi-index set $\set{\valpha \ \vert \ \valpha\in [n]^{2a},  \abs{\valpha}\leq n}$ of cardinality $b=\left(\begin{smallmatrix}n+2a\\ 2a\end{smallmatrix}\right)$, and write it in the form $\set{(\vbeta_l,\vgamma_l) \ \vert \ \vbeta,\vgamma\in [n]^a , \abs{\vbeta_l}+\abs{\vgamma_l} \leq n, l\in b}$. Now define polynomial maps $\tau_1,\tau_2 : \Real^a \too \Real^b$ by $\tau_1(x)=(x^{\vbeta_l} \ \vert \ l\in [b])$, and $\tau_2(x)=(x^{\vgamma_l}\ \vert \ l\in [b])$. We apply $\tau_1$ to the features of $\tB$, namely $\tY_{i_1,i_2,l}:=\tau_1(\tB)_{i_1,i_2,l}=(\tB_{i_1,i_2,:})^{\vbeta_l}$; similarly, $\tZ_{i_1,i_2,l}:=\tau_2(\tB)_{i_1,i_2,l}=(\tB_{i_1,i_2,:})^{\vgamma_l}$. Now,
\begin{align*}
  \tW_{i_1,i_2,l} &:=(\tZ_{:,:,l} \cdot \tY_{:,:,l})_{i_1,i_2} = \sum_{j=1}^n \tZ_{i_1,j,l} \tY_{j,i_2, l}=\sum_{j=1}^n \tau_1(\tB)_{j,i_2,l}\  \tau_2(\tB)_{i_1,j,l}  \\&= 
\sum_{j=1}^n \tB_{j,i_2,:}^{\vbeta_l} \tB_{i_1,j,:}^{\vgamma_l}=
\sum_{j=1}^n (\tB_{j,i_2,:},\tB_{i_1,j,:})^{(\vbeta_l,\vgamma_l)},  
\end{align*}
hence
$\tW_{i_1,i_2,:} = u(\mX),$ 
where $\mX$ is defined in \Eqref{e:mX_a}. 

To implement this in the network we need to replace $\tau_i$ with MLPs $m_i$, $i=1,2$. That is, 
\begin{align}\label{e:m1_m2}
  \tW_{i_1,i_2,l} &:= \sum_{j=1}^n m_1(\tB)_{j,i_2,l}\  m_2(\tB)_{i_1,j,l} = v(\mX),
\end{align}
where $\mX\in\Real^{n\times 2a}$ is defined in \Eqref{e:mX_a}.

As before, since input tensors belong to a finite set $\Omega\subset \Real^{n^2\times(e+1)}$, so are all possible multisets $\mX$ and all colors, $\Upsilon$, produced by any part of the network. Similarly to the proof of Theorem \ref{thm:k_wl_k_order} we can take (using the universal approximation theorem) MLPs $m_1,m_2$ so that $\max_{x\in \Upsilon, i=1,2}\norm{\tau_i(x)-m_i(x)}<\epsilon$. We choose $\epsilon$ to be sufficiently small so that the map $v(\mX)$ defined in \Eqref{e:m1_m2}  maintains the injective property of $u$ (see Proposition \ref{prop:u}): It discriminates between $\mX,\mX'$ not representing the same multiset. 


Lastly, note that taking $m_3$ to be the identity transformation and concatenating  $(\tB, m_1(\tB)\cdot m_2(\tB))$ concludes the implementation of the $2$-FWL update step. The computation of the color histogram can be done as in the proof of Theorem \ref{thm:k_wl_k_order}.

\end{proof}




\end{document}
