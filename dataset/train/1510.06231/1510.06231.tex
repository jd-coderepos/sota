\documentclass[10pt,journal]{IEEEtran}

\usepackage[latin1]{inputenc}
\usepackage[english]{babel}
\usepackage[cmex10]{amsmath}
\interdisplaylinepenalty=2500
\usepackage{amssymb}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{rotating}
\usepackage{enumitem}
\usepackage{MnSymbol}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{fancybox}
\usepackage{array}
\usepackage{adjustbox}
\usepackage{cite}




\newcommand{\Z}{\mathbb{Z}}




\newcommand{\alg}[1]{\mathsf{#1}}
\newcommand{\sch}[1]{\mathsf{#1}}

\newcommand{\rv}[1]{{#1}}

\newcommand{\vertmapsto}[0]{\begin{turn}{90} \end{turn}}
\newcommand{\vertupmapsto}[0]{\begin{turn}{90} \end{turn}}

\newtheorem{definition}{Definition}[section]
\newtheorem{proposition}{Proposition}[section]
\newtheorem{corollary}{Corollary}[section]


\begin{document}

\title{Symmetric Blind Decryption with Perfect Secrecy}

\author{Juha~Partala\thanks{
J.~Partala is with the Department of Computer Science and Engineering, University of Oulu, Finland (e-mail: juha.partala@ee.oulu.fi).}}



\maketitle

\begin{abstract}
A blind decryption scheme 
enables a user to query decryptions from a decryption server without revealing
information about the plaintext message.
Such schemes are useful, for example, for the implementation of privacy preserving
encrypted file storages and
payment systems. 
In terms of functionality,
blind decryption is close to oblivious transfer.
For noiseless channels, information-theoretically secure oblivious transfer is impossible.
However, in this paper we show that this is not the case for blind decryption.
We formulate a definition of perfect secrecy of symmetric blind decryption for the following setting:
at most one of the scheme participants is a malicious observer.
We also devise a symmetric blind decryption scheme
based on modular arithmetic on a ring , where  is a prime,
and show that it satisfies our notion of perfect secrecy.
\end{abstract}

\begin{IEEEkeywords}
Communication system security, Cryptography, Encryption, Information security
\end{IEEEkeywords}





\section{Introduction}

Over the past 15 years, data has moved from local storage to
centralized data warehouses in the cloud.
The 
accessibility
of large amounts of personal data through a public network has given rise to
many security and privacy issues~\cite{Thuraisingham_2015}.
Fortunately, such issues have generally been taken seriously.
For example,
ethical and legal requirements have been imposed on guaranteeing
the confidentiality of medical records~\cite{HIPAA,DataProtDirective}.
However, the implementation of privacy technologies is non-trivial,
especially if the data storage has been outsourced to a cloud operator.
Sensitive information can often be inferred from simple access patterns either
by outsiders or by the operator of the storage.
For example, being able to observe a medical doctor
to access the medical record of a patient can leak sensitive information.
Therefore, such access patterns should be kept hidden both from
outsiders and from the party that is administering the records.

Oblivious databases~\cite{Coull_2009} and privacy-preserving encrypted filesystems~\cite{Green_2011}
are examples of technologies that can be used 
to hide the access information from the administrator.
For such systems, the decryption of data is typically handled by a central decryption server.
Such systems can be conveniently implemented using \emph{blind decryption schemes}~\cite{Sakurai_1996}.
Blind decryption is a versatile primitive.
It can be used as a building block for many privacy critical applications,
such as privacy-preserving
payment systems~\cite{Chaum_1983}, key escrow systems, oblivious transfer protocols~\cite{Green_2007},
privacy-preserving systems for digital rights management~\cite{Perlman_2010,Lei_2012}
and private information retrieval~\cite{Schnorr_2000}.

A blind decryption scheme consists of an encryption scheme together with a blind decryption protocol
intended to decrypt messages in a privacy-preserving fashion.
The meaning of ''blind decryption'' can be easily described based on the following scenario depicted in \figurename~\ref{fig:blind_decryption_basic}.
\begin{figure}[!t]
\centering
\begin{tabular}{m{3.1cm}m{1.3cm}m{0.5cm}m{2.1cm}}
Alice & & & Encryptor\\
\includegraphics[width=0.7in]{Alice.png}~ &  &  & \includegraphics[width=0.7in]{Bob.png} key \\
~~~~~ \\
\\
\includegraphics[width=0.5in]{Decryptor.png}key \\
Decryptor
\end{tabular}
\caption{Blind decryption. Alice has obtained  ciphertexts from an encryptor and is entitled to choose exactly one of those for decryption. Alice interacts with a decryptor that shares a key 
with the encryptor to transform
the ciphertext message  into a plaintext message . Neither the encryptor nor the decryptor learn the plaintext message chosen by Alice.}
\label{fig:blind_decryption_basic}
\end{figure}
Suppose that Alice has obtained several encrypted messages from an encryptor. Alice is entitled to choose and decrypt exactly one of those messages.
Suppose that the decryption key  is stored on a decryption server and Alice wishes to have the server decrypt the message for her
in such a way that neither the encryptor nor the decryptor learn the message chosen by Alice.


There are suggestions for practical blind decryption based on public key cryptography~\cite{Sakurai_1996,Sakurai_1998,Sameshima_1998,Ogata_2009,Green_2011}.
It is also possible to implement the blind decryption functionality with other protocols
such as secure multi party computation~\cite{Yao_1986}.
However, the resulting schemes would
be computationally demanding.
For many applications symmetric primitives are sufficient and
computationally more efficient.
In addition, they can provide secrecy that is not based on computational assumptions.
Oblivious transfer schemes~\cite{Rabin_1981,Even_1985} deliver the same functionality
directly between the sender and the receiver without the decryption server.
However, for noiseless channels, information-theoretically secure oblivious transfer is impossible~\cite{Damgard_1999}.
In addition, there does not seem to exist
blind decryption schemes such that the privacy of the user is based on information-theoretic security.
Our work aims to fill this shortage.
In this paper, we give a meaningful definition of perfect secrecy
for the blind decryption scenario.
In particular, we formulate
perfect secrecy of symmetric blind decryption
in a setting where at most one of the participants is maliciously observing
but adhering to the protocol.
We also propose
a
symmetric key blind decryption scheme  that satisfies
our definition.
The scheme is based on modular arithmetic on a ring , where 
is a prime.

The paper is organized as follows.
In Section~\ref{sec:Related work}, we describe work that is related to ours.
 Section~\ref{sec:Preliminaries} discusses the
fundamental definitions and the preliminaries for the rest of the paper.
In Section~\ref{sec:Perfect secrecy for symmetric blind decryption}, we formulate
three perfect secrecy properties that
the blind decryption scheme needs to satisfy.
In Section~\ref{sec:Perfectly secure encryption},
we give a description of a symmetric blind decryption scheme .
In Section~\ref{sec:Security of devised scheme}, we
show that the devised scheme
satisfies our definition of perfect secrecy.
Finally, Section~\ref{sec:Future work}
considers future work and Section~\ref{sec:Conclusion}
provides the conclusion.

\section{Related work}
\label{sec:Related work}

Chaum was the first to consider blindness in the context of digital signatures
and privacy preserving payment systems~\cite{Chaum_1983}. He described the
first public key blind signature scheme~\cite{Chaum_1985} by utilizing the properties of RSA encryption~\cite{Rivest_1978}.
The scheme can be also used for encryption and can be therefore considered as the first blind decryption scheme.
In the early articles, blind decryption is referred to as ''blind decoding''.
Discrete logarithm based blind signature schemes were suggested in~\cite{Chaum_1992,Okamoto_1992,Horster_1995,Camenisch_1995}.
Sakurai and Yamane were the first to consider public key
blind decryption based on the discrete logarithm problem~\cite{Sakurai_1996}.
Their method was based on the ElGamal cryptosystem~\cite{ElGamal_1985}
and related to the blind signature of Camenisch, Piveteau and Stadler~\cite{Camenisch_1995}. The method was later applied for
the implementation of a key escrow system~\cite{Sakurai_1998}.
Mambo, Sakurai and Okamoto were the first to consider blind decryption that is secure against chosen
plaintext attacks by signing the ciphertext messages~\cite{Mambo_1996}. The resulting scheme
is not capable of public key encryption since a secret signing key is required.
Green described the first public key blind decryption scheme~\cite{Green_2011} that is secure against
adaptive chosen ciphertext attacks (IND-CCA2) using bilinear groups.
The security of these constructions has been considered computationally
either in the random oracle model~\cite{Schnorr_2000} or using computational indistinguishability
and infeasibility assumptions~\cite{Green_2011}.

\emph{Oblivious transfer} protocols are symmetric primitives 
that offer functionality similar to blind decryption.
For oblivious transfer, there are two participants: a sender and
a receiver. For the original definition of oblivious transfer, the sender transmits a message which
the receiver gets with probability . The sender remains oblivious whether the receiver actually
got the message. This form of oblivious transfer was introduced by Rabin~\cite{Rabin_1981}. The 
concept was later extended by Even, Goldreich and Lempel~\cite{Even_1985}.
For -oblivious transfer, the receiver can choose one from two messages without the sender
knowing which of the messages were chosen.
A related concept that can be considered as a further generalization
is \emph{all-or-nothing disclosure of secrets}~\cite{Brassard_1987}
for which Alice is willing to disclose at most one secret from a set
to Bob without Bob learning information about the rest of the secrets. Alice must not learn which secret Bob chose.

Adaptive queries were considered by Naor and Pinkas~\cite{Naor_1999_2}. They also considered active adversaries
and provided security definitions relating to the simulatability of the receivers.
Camenisch, Neven and Shelat extended the work of Naor and Pinkas by defining \emph{simulatable} oblivious transfer~\cite{Camenisch_2007}
and providing practical constructions for such a scheme.
There are other suggestions for oblivious transfer based on problems in bilinear groups~\cite{Green_2008},
groups of composite order~\cite{Jarecki_2009} and the Diffie-Hellman problem~\cite{Kurosawa_2009,Kurosawa_2010,Green_2011_2,Kurosawa_2011,Zhang_2013,Guleria_2015}.
These schemes
are based on computational assumptions.
It is impossible to achieve information-theoretic
security for both of the parties using noiseless channels~\cite{Damgard_1999}. However, it
is possible using noisy channels such as discrete memoryless channels~\cite{Crepeau_2005}
or a trusted initializer~\cite{Rivest_1999}.

General \emph{multiparty computation} protocols can be also applied to implement blind decryption capabilities.
Secure multiparty computation was originally introduced by Yao~\cite{Yao_1982_2} for two party case.
The general case for  is due to Goldreich, Micali and Wigderson~\cite{Goldreich_1987}.
However, secure multiparty computation protocols are computationally intensive in comparison
to pure blind decryption and oblivious transfer.

\section{Preliminaries}
\label{sec:Preliminaries}

\subsection{Notation}

For the set of integers modulo ,
we denote  and equate a congruence class
with its least non-negative representative. That is,
we consider . By the notation  we mean
the unique  such that .

We denote the uniform distribution on a set  by . If a random variable
 is uniformly distributed on a set , we denote it by .
When an element  is sampled from , we denote it by .

\subsection{Symmetric encryption}

A symmetric encryption scheme 
with keyspace , plaintext space  and ciphertext space 
consists of three algorithms:
\begin{enumerate}
	\item The key generation algortihm : On input a security parameter ,  outputs a key .
	\item The encryption algorithm : On input a key  and a message ,  outputs a ciphertext .
	\item The decryption algorithm : On input a key  and a ciphertext ,  outputs a message 
	such that .
\end{enumerate}




\subsection{Blind decryption}
\label{sec:Blind decryption}

Blind decryption has been considered in the literature for the asymmetric case.
However, in this paper we are interested in the symmetric case which is
easily adapted from the asymmetric one~\cite{Green_2011}.
A symmetric blind decryption scheme 
consists of a symmetric
encryption scheme 
and a two-party protocol .
The protocol  is conducted between an honest user Alice and the decryption server which we shall call the Decryptor. The protocol
enables Alice, that is in possession of a ciphertext , to finish the protocol
with the correct decryption of .	
	As a result of running , Alice on input a ciphertext 
	outputs either the message  or an error message .
  The Decryptor, on input the key , outputs nothing or an error message .


 To be secure,
the exchanged messages
must not leak information to malicious users (the \emph{leak-freeness property}~\cite{Green_2007}).
The property can be formalized based on computational indistinguishability.
For every adversary, there has to be a simulator so that the following two games are well defined.
For the first game, a probabilistic polynomial time (PPT) adversary  can choose any number  of ciphertexts  for .
It is then given the correct decryptions by executing  with the Decryptor. Finally,
 outputs the plaintext message, ciphertext pairs  for .
For the second game,
a simulator  chooses any number  of ciphertexts  for .
In this game, the plaintext messages are obtained by querying a trusted party.
 is \emph{leak-free} if for every PPT adversary  there is a simulator 
such that for every PPT distinguisher  the probability of distinguishing between
these two games is negligible~\cite{Green_2011}.

Another important property for secure blind decryption is the \emph{blindness property}.
It formalizes the idea that the Decryptor must not learn anything
about the actual plaintext message.
This can be formalized
by giving a PPT algorithm  the possibility to choose
two ciphertexts  and giving it oracle access
to two instances of  based on these choices. If the probability of distinguishing
these two instances is negligible for every PPT algorithm , then 
 satisfies \emph{ciphertext blindness}.
For a formal and rigorous definition, see for example~\cite{Green_2011}.



\subsection{Perfect secrecy}

The notion of perfect secrecy is due to Shannon~\cite{Shannon_1949}. Let  be an encryption
scheme with keyspace , plaintext space  and ciphertext space .
Let  denote a random variable on the keyspace
induced by .

satisfies perfect secrecy if for every random variable 
on the plaintext space, every plaintext  and every
ciphertext ,

Equivalently, 

satisfies perfect secrecy if and only if for every random variable 
on the plaintext space,
every plaintext messages  and every
ciphertext ,


\section{Perfect secrecy for symmetric blind decryption}
\label{sec:Perfect secrecy for symmetric blind decryption}

Instead of computational indistinguishability, we shall now consider secrecy of
symmetric blind decryption based on the information observed by the parties.
In the following, let  together with
 be a symmetric blind decryption
scheme with keyspace , plaintext space  and ciphertext space .

\subsection{The scenario}



For the sake of clarity, we do not consider active adversaries. We assume that the parties adhere to
the blind decryption protocol and only observe the flow of messages (and possibly deduce information from those messages).
Active adversaries could, for example, induce errors to the protocol messages.
Such adversarial scenarios are left for future work.
In addition, we do not consider the case that the Decryptor
is colluding with either Alice or the Encryptor
against the other.
Such a case is equivalent to the oblivious transfer scenario and information-theoretic security is impossible
for noiseless channels~\cite{Damgard_1999}.
However, we note that such collusion scenarios are important for certain applications and need to be investigated in the future.
We do consider the case that the adversary is impersonating one of the parties which is a paramount
requirement for many applications.

For clarity, we also restrict to the case that Alice decrypts a single message . Similar to the one-time pad, we assume
that a new key is derived after every decryption.
However, in our case there could be several ciphertexts
 encrypted under the same key.
Nevertheless, once Alice has decrypted one of the messages
we consider that particular key used and a new key and a new set of ciphertexts is generated.

The scenario is the following.
The Encryptor chooses a set of  plaintext messages  for .
He encrypts those messages under a key  to obtain ciphertext
messages  for  that he transmits to Alice.
Alice chooses one of those messages .
To hide the actual ciphertext , we assume that there is a
ciphertext transformation space  so that
Alice can derive a related ciphertext message 
that she transmits to the Decryptor. The Decryptor responds
with its decryption 
which Alice transforms to the correct plaintext message .
The general scenario has been depicted in \figurename~\ref{fig:general_scenario}.
The used variables have been collected into Table~\ref{tab:Table of symbols} for easier reference.
\begin{figure}[!t]
\centering
\begin{tabular}{lcl}
Alice & & Encryptor \\
\includegraphics[width=0.4in]{Alice.png} & & \includegraphics[width=0.4in]{Bob.png}\\
& &  \\
& &  \\
 &  &  \\
Pick  & & \\
& & Decryptor\\
Derive  from  & & \includegraphics[width=0.4in]{Decryptor.png}\\
 &  &  \\
& &  \\
 &  &  \\
Derive  from  & & \\
\end{tabular}
\caption{The general blind decryption scenario. Alice chooses a ciphertext  and derives a related ciphertext  that she transmits to the decryptor. The decryptor responds with the corresponding plaintext message  from which Alice can recover .}
\label{fig:general_scenario}
\end{figure}
\begin{table}
\caption{Variables}
\begin{tabular}{|c|l|}
\hline
Symbol & Description\\
\hline
\hline
 & key space\\
 & plaintext space\\
 & ciphertext space\\
 & ciphertext transformation space\\
 & blind encryption / decryption key\\
 & the number of messages encrypted under\\ & a single blind decryption key\\
 & plaintext messages chosen by the Encryptor\\
 & ciphertext messages obtained by encrypting \\ & with the blind encryption key\\
 or  & ciphertext message chosen by Alice\\
 or  & transformed ciphertext message chosen by Alice\\
 or  & decryption of  under the blind decryption key\\
 or  & the plaintext message Alice obtains at the end\\ & of the scheme\\
\hline
\end{tabular}
\vspace{4pt}
\label{tab:Table of symbols}
\end{table}



\subsection{Security requirements}

As described in Section~\ref{sec:Blind decryption}, the scheme has to satisfy the following property.
\begin{enumerate}
	\item Leak-freeness. Malicious observers
	must not learn information about the plaintext messages by observing the exchanges.
\end{enumerate}
The easiest way to provide leak-freeness against malicious observers
that are not participants of the scheme
is to
protect each exchange
with an encryption scheme that satisfies perfect secrecy.
However, leakage need to
be also addressed considering maliciousness of the protocol participants.
Considering each individual party, we can divide leak-freeness as follows.
\begin{enumerate}[label*=1.\arabic*)]
	\item Leak-freeness against the Encryptor. Malicious encryptor
	must not learn information about the plaintext message obtained by Alice at the end of the protocol
	by observing the blind decryption messages. The situation is depicted in
\figurename~\ref{fig:malicious_Bob}.
	\item Leak-freeness against Alice. This property ensures that, after obtaining , Alice does not learn information about
	the remaining  plaintexts  for . The situation is depicted in \figurename~\ref{fig:adversary_alice}.
\end{enumerate}
In contrast to computational security, we cannot define
leak-freeness as a distinguishing problem. Instead, we shall consider
the probability distributions regarding the exchanged elements.
\begin{figure}[!t]
\centering
\begin{tabular}{ccc}
\ovalbox{\begin{minipage}{0.3\columnwidth}
\centering
Alice\\
\vspace{0.1cm}
\includegraphics[width=0.4in]{Alice.png}\\

\end{minipage}
}
&  & 
\color{red}
\Ovalbox{\begin{minipage}{0.3\columnwidth}
\centering
Adversary\\
\\
?
\end{minipage}
}\\
 & & \\
 & & \\
 & & \\
\ovalbox{\begin{minipage}{0.25\columnwidth}
\centering
\\
\vspace{0.1cm}
\includegraphics[width=0.4in]{Decryptor.png}\\
\vspace{-0.1cm}
Decryptor\\
\end{minipage}
}
\end{tabular}
\caption{Malicious Encryptor. The adversary attempts to learn which message was chosen by Alice.}
\label{fig:malicious_Bob}
\end{figure}

\begin{figure}[!t]
\centering
\begin{tabular}{ccc}
\color{red}
\Ovalbox{\begin{minipage}{0.3\columnwidth}
\centering
Adversary\\
\\

\end{minipage}
}
&  & 
\ovalbox{\begin{minipage}{0.3\columnwidth}
\centering
Encryptor\\
\vspace{0.1cm}
\includegraphics[width=0.4in]{Bob.png}\\

\end{minipage}
}\\
 & & \\
 & & \\
 & & \\
\ovalbox{\begin{minipage}{0.3\columnwidth}
\centering
\\
\vspace{0.1cm}
\includegraphics[width=0.4in]{Decryptor.png}\\
\vspace{-0.1cm}
Decryptor\\
\end{minipage}
}
\end{tabular}
\caption{Malicious Alice. The adversary attempts to decrypt additional messages.}
\label{fig:adversary_alice}
\end{figure}

We also want to prevent Decryptor from deducing information about the plaintext message .
\begin{enumerate}
\setcounter{enumi}{1}
	\item Blindness against the Decryptor. This property ensures that a malicious decryption server does not learn the message Alice wants to decrypt. The situation
is depicted in \figurename~\ref{fig:malicious_server}.
\end{enumerate}
\begin{figure}[!t]
\centering
\begin{tabular}{ccc}
\ovalbox{\begin{minipage}{0.3\columnwidth}
\centering
Alice\\
\vspace{0.1cm}
\includegraphics[width=0.4in]{Alice.png}\\

\end{minipage}
}
&  & 
\ovalbox{\begin{minipage}{0.3\columnwidth}
\centering
Encryptor\\
\vspace{0.1cm}
\includegraphics[width=0.4in]{Bob.png}\\

\end{minipage}
}\\
 & & \\
 & & \\
 & & \\
\color{red}
\Ovalbox{\begin{minipage}{0.3\columnwidth}
\centering
\\
\\
Adversary
\end{minipage}
}
\end{tabular}
\caption{Malicious Decryptor. The adversary attempts to learn the plaintext message that Alice obtains.}
\label{fig:malicious_server}
\end{figure}
In the computational security setting, there can be multiple applications of the blind decryption
protocol for a fixed key.
In our case, we want a fresh key for every decryption to achieve perfect secrecy.
Therefore, we formulate leak-freeness and blindness for a single decryption.
However, as was described before, we want to be able to encrypt multiple messages with the same key.
For example, in privacy-preserving payment
systems blind decryption is used to enable Alice to choose one -- but only one -- item from a selection of items.
This results in
a scenario in which there are  plaintext, ciphertext pairs  for 
but there is only a single application of .












In the following section, we formulate these conditions based on information. Note that these
conditions also provide secrecy against malicious observers that are not participants of the
scheme since the information possessed by such observers is a proper subset of that of any of the participants.
The following
notation is used.
Let 
denote the random variable of blind decryption keys on the key space 
induced by .
Let  for  denote
the random variables corresponding to the choice of  for 
by the Encryptor and let  denote the random variable corresponding to the plaintext 
Alice obtains at the end of the scheme. Following the standard practice~\cite{Katz_2007}, we assume that  is independent
with  and  for every .
Let  denote the random variable on the ciphertext transformation space 
for the ciphertext message  that Alice discloses to the Decryptor.
Finally, let  denote the random variable corresponding to the message 
that the Decryptor responds with. These variables have been collected into Table~\ref{tab:Table of random variables}.
\begin{table}
\caption{Random variables}
\begin{tabular}{|c|l|}
\hline
Random variable & Description\\
\hline
\hline
 & random variable on  induced by  \\
 & random variables corresponding to the choice\\ & of  by the encryptor\\
 & random variable on  induced by Alice\\ & using \\
 & random variable on  induced by decryption\\ & of  by the decryptor\\
 & random variable corresponding to the plaintext\\ &  message  Alice obtains at the end of the scheme\\
\hline
\end{tabular}
\vspace{4pt}
\label{tab:Table of random variables}
\end{table}



\subsection{Perfect leak-freeness against the encryptor}

We shall first formulate leak-freeness against the Encryptor.
The blind decryption protocol messages  and 
should not disclose any information about  to the Encryptor. Equivalently,
the messages should not leak information about the  that
was chosen by Alice even if the Encryptor knows the key  and the right
plaintext messages  for .
\begin{definition}[Perfect leak-freeness against encryptor]
\label{def:leak-freeness_against_encryptor}
A symmetric blind decryption
scheme
is \emph{perfectly leak-free against the encryptor} for a single decryption
of a maximum of  messages
if for every random variable  for  on the plaintext space
and every  for  and every ,
\begin{IEEEeqnarray}{l}
\Pr \left[ M = m \left| C' = c' \cap M' = m' \bigcap_{j = 1}^L M_j = m_j \right. \right] \nonumber\\
\quad\quad = \Pr \left[ M = m \left| \bigcap_{j = 1}^L M_j = m_j \right. \right]. \nonumber
\end{IEEEeqnarray}
\end{definition}
Our definition states that a malicious Encryptor can equally easily
guess the plaintext message Alice wanted to be decrypted with or without information
provided by the blind decryption protocol messages  and .
Note that, in the normal scenario,  for some .
However, we do not want to restrict the definition to such a case. For example, there could be homomorphic
blind decryption schemes
for which certain operations could be permitted on the ciphertexts.
Note also
that the Encryptor inherently possesses more information about  than an outsider
since  is dependent on .




\subsection{Perfect leak-freeness against Alice}

In order to be practical, the scheme needs to ensure that Alice is not able to decrypt messages.
Therefore, we need to ensure that 
Alice obtains neither the
decryption key nor any information about the decryptions of  without interacting with
the Decryptor. In addition, after a single application of , Alice must not have
any information about the remaining  messages.
To make the requirement precise, we require that the observation of a single 
plaintext, ciphertext pair 
does not leak any information about the decryption of another ciphertext .
The property is, in fact, a property of the encryption scheme.
\begin{definition}[Perfect leak-freeness against Alice]
\label{def:Perfect leak-freeness against Alice}
A symmetric encryption scheme  satisfies \emph{perfect leak-freeness against Alice}
for a single decryption
if
for every 
random variable  on the plaintext space, every
 and every  such that ,
\begin{IEEEeqnarray}{c}
\Pr \left[ c_1 = \alg{Enc}(K,M_1)  \cap c_2 = \alg{Enc}(K,M_2) \right. \nonumber\\
\left. \left| M_1 = m_1 \cap M_2 = m_2 \right. \right] \nonumber\\
= \Pr \left[ c_1 = \alg{Enc}(K,M_1) \cap c_2 = \alg{Enc}(K,M_2) \right. \nonumber\\
\left. \left| M_1 = m_1 \cap M_2 = m \right. \right]. \nonumber
\end{IEEEeqnarray}
\end{definition}
The condition states that
the probability of obtaining
the ciphertext pair  is the same whether we encrypt  or .
That is, observation of the ciphertexts 
does not yield information about the decryption of  even if we know the decryption of .


\subsection{Perfect blindness against the decryptor}

We still need to consider privacy against a malicious Decryptor.
It is reasonable to assume that  have been delivered to Alice
using a private channel.
If the Decryptor can observe  for , it means that
he knows the corresponding plaintext messages since he is
in possession of the blind decryption key.
Therefore,
it is natural to
require that the ciphertexts are protected by a separate secure channel
between Alice and the Encryptor.
For the blindness property we want the server to learn nothing of the actual message  that Alice
derives at the end of the blind decryption scheme. 
In this case, the Decryptor knows the correct key 
as well as the messages  and  exchanged with Alice.



\begin{definition}[Perfect ciphertext blindness against the decryptor]
\label{def:Perfect ciphertext blindness against decryptor}
A symmetric blind decryption
scheme
satisfies \emph{perfect ciphertext blindness against the decryptor}
if for every random variable  on the plaintext space
and every  and every 

\end{definition}
The condition states that it is equally easy to guess the correct plaintext message with
and without the information possessed by the decryptor. Note that we have
assumed that  have been delivered to Alice in perfect secrecy.



\subsection{Perfect secrecy for symmetric blind decryption}

Finally, we can state our definition of perfect secrecy based on the properties defined above.
\begin{definition}[Perfect secrecy of blind decryption]
\label{def:Perfect secrecy of blind decryption}
A symmetric blind decryption
scheme consisting of a symmetric encryption scheme  and a blind decryption protocol 
satisfies perfect secrecy for symmetric blind decryption
for a single decryption of a maximum of  messages
against a single malicious party
if the scheme is perfectly leak-free against the encryptor for a maximum of  messages,
 is leak-free against Alice 
and the scheme satisfies perfect ciphertext blindness against the decryptor.
\end{definition}

\section{A concrete blind decryption scheme}
\label{sec:Perfectly secure encryption}

We shall now devise a blind decryption scheme 
that satisfies Def.~\ref{def:Perfect secrecy of blind decryption}.
We shall implement our scheme using two tiers of symmetric encryption.
For the outer tier we apply a scheme that satisfies
ordinary perfect secrecy.
Let that scheme be denoted by .
The outer encryption scheme will
hide information about  from the Decryptor and
also provide secrecy for  and  against the Encryptor. To achieve perfect blindness
and leak-freeness against Alice, we
design an inner tier encryption scheme called  that 
satisfies a useful transformation property. The property enables us to construct a blind
decryption protocol .
To sum it up, our final construction
will consist of two tiers of encryption and a protocol for Alice to query a single decryption
from the Decryptor. The general overview of the scheme is depicted in \figurename~\ref{fig:General overview}.
\begin{figure}[!t]
\centering
\begin{tabular}{ll}
Alice & Encryptor\\
\includegraphics[width=0.3in]{Alice.png} & \includegraphics[width=0.3in]{Bob.png}\\
\multicolumn{2}{c}{
\ovalbox{
\begin{minipage}{0.7\columnwidth}
\\
\begin{tabular}{lcr}
 &  & 
\ovalbox{
\begin{minipage}{0.3\columnwidth}
\\

\end{minipage}
}
\end{tabular}
\end{minipage}
}
}\\
Alice & Decryptor\\
\includegraphics[width=0.3in]{Alice.png} & \includegraphics[width=0.3in]{Decryptor.png} \\
\rule{0pt}{4ex}
\shadowbox{
\begin{minipage}{0.25\columnwidth}
 Map\\

\end{minipage}} & \\
\multicolumn{2}{c}{
\ovalbox{
\begin{minipage}{0.7\columnwidth}
\\
\begin{tabular}{lll}
 &  & 
\ovalbox{
\begin{minipage}{0.3\columnwidth}
\\

\end{minipage}
}\\
 &  & 
\end{tabular}
\end{minipage}
}
}\\
\rule{0pt}{8ex}
\shadowbox{
\begin{minipage}{0.25\columnwidth}
 Map\\

\end{minipage}}
\end{tabular}
\caption{General overview of . Two tiers of encryption are applied. The outer tier () satisfies ordinary perfect secrecy. The inner tier () provides perfect leak-freeness against Alice and has a transformation property enabling perfect blindness against the decryptor.}
\label{fig:General overview}
\end{figure}



It would be possible to implement some of the required privacy properties
with multiple applications of the one time pad.
For example, if , Alice could hide
the plaintext message from the Decryptor by querying for the decryption of , where  is only known to Alice.
The correct plaintext message would be obtained from 
by computing .
However, such a protocol would leak  to the Decryptor since  would be needed for decryption. In addition,
for a single decryption, the Decryptor would have to maintain a set of 
keys which would quickly grow to an unmanageable size as  grows.
In contrast, the optimal key size for single decryption would be , where  is
the bit length of , assuming that each
plaintext message is of the same bit length.
Therefore, simply applying the one time pad is not sufficient.





In the following, we first describe our inner encryption scheme  that will provide perfect leak-freeness against Alice,
as well as the required message transformation property.
Then, we proceed to the description of a blind decryption protocol utilizing this scheme. 
Finally, we combine the inner encryption scheme with an outer encryption scheme that satisfies
ordinary perfect secrecy and describe the complete blind decryption scheme.

\subsection{The inner encryption scheme}

We shall first construct an inner encryption scheme called 
with some useful properties.
Our inner scheme is based on modular arithmetic on the ring , where 
is a prime. Our plaintext space is  and every  is mapped to 
 which is the ciphertext space.
To satisfy Def.~\ref{def:Perfect leak-freeness against Alice}, we want to add an amount
of randomness that is at least twice the binary length of  in the encryption operation.
Therefore, the keys of  will consist of a pair .


Let . Then,

where .
Therefore, we can essentially represent  with two elements of .
Using such a representation, we encrypt a single message  by
first sampling a random element  and
setting
. Then, we add the key  by computing

which is the ciphertext message. Such an encryption operation
entails a useful transformation property.
For every  and  such that ,

Namely, if we know a plaintext  and its encryption
,
we know the decryption  of 
for every  since it can be computed by the following algorithm.
\begin{algorithmic}[1]
  \Procedure{}{}
		\State If  output 
		\State 
  \State \textbf{output} 
  \EndProcedure
\end{algorithmic}
Let .
The algorithm works because
\begin{IEEEeqnarray}{lll}
(c_2 - c_1 + p m_1) / p & {}={} & (p x_{k} z^2 + p y_{k} z + p m_2 + z \nonumber\\
& & {-}\:p x_{k} z^2 - p y_{k} z - p m_1 - z + p m_1) / p\nonumber\\
& {}={} & (p m_2) / p \nonumber\\
& {}={} & m_2. \nonumber
\end{IEEEeqnarray}
The  algorithm can transform the decryption  of a ciphertext  to the decryption  of  whenever .

Decryption is straightforward knowing the key . Its operation, as well as the
complete encryption scheme is described below.
\begin{definition}[]
The symmetric encryption scheme

consists of the following three algorithms.
\begin{algorithmic}[1]
  \Procedure{}{} \Comment{ determines the size for the plaintext space}
		\State Choose a public prime  such that  and 
\State 
		\State 
\State \textbf{output} 
  \EndProcedure
\end{algorithmic}
\begin{algorithmic}[1]
  \Procedure{}{} \Comment{Input consists of a key  and a message }
		\State 
		\State 
		\State 
  \State \textbf{output} 
  \EndProcedure
\end{algorithmic}
\begin{algorithmic}[1]
  \Procedure{}{} \Comment{Input consists of a key  and a ciphertext }
		\State 
		\State 
		\State 
  \State \textbf{output} 
  \EndProcedure
\end{algorithmic}
\end{definition}
The plaintext and ciphertext spaces of  depend on the chosen prime .
In particular, the plaintext space is  while the ciphertext space is .
Let us show the correctness of the scheme. That is,

for every key  and plaintext .
Let .
Then we have
\begin{IEEEeqnarray}{lll}
c & {}={} & p x_{k} b^2 + p y_{k} b + b \nonumber\\
& {}\equiv{} & p x_{k} z^2 + p y_{k} z + p m + z \pmod{p^2} \nonumber
\end{IEEEeqnarray}
and , where . Now,
\begin{IEEEeqnarray}{lll}
\alg{Dec}_{\sch{2PAD}}(x_{k},y_{k},c)
& {}={} & (t - z) / p \nonumber\\
& {}={} & (p (-x_{k}) z^2 + p (-y_{k}) z \nonumber\\
& &  {+}\:p x_{k} z^2 + p y_{k} z + p m + z - z)/p \nonumber\\
& {}={} & (p m + z - z) / p = m.\nonumber
\end{IEEEeqnarray}








We shall later show that given a single
plaintext, ciphertext pair  and a ciphertext  such that
 we still have information theoretic security for .
That is,  satisfies perfect leak-freeness against Alice whenever
 for .
However, suppose that we have two plaintext, ciphertext pairs
 such that .
We can show that
the key  can be completely determined
from such two pairs.


\begin{proposition}
\label{lem:solvexy_lemma}
For every plaintext, ciphertext pair 
such that 
there is a unique key  such that
\begin{IEEEeqnarray}{lll}
c_1 & {}={} & \alg{Enc}_{\sch{2PAD}}(x_{k}, y_{k}, m_1), \nonumber\\
c_2 & {}={} & \alg{Enc}_{\sch{2PAD}}(x_{k}, y_{k}, m_2). \nonumber
\end{IEEEeqnarray}
\end{proposition}
\begin{IEEEproof}
Let  such that  and .
Let also  and .
Then, we have a system of
two equations
\begin{IEEEeqnarray}{lll}
v_1 & {}={} & x_{k} z_1^2 + y_{k} z_1, \nonumber\\
v_2 & {}={} & x_{k} z_2^2 + y_{k} z_2,\nonumber
\end{IEEEeqnarray}
where  are known. Let now

Note that
since 
and 
we have  and
 is invertible modulo . Therefore, the equation pair has a unique solution
\begin{IEEEeqnarray}{lll}
\begin{pmatrix}
v_1 & v_2
\end{pmatrix}
\cdot Z^{-1}
& {}={} &
\begin{pmatrix}
x_{k} z_1^2 + y_{k} z_1 & x_{k} z_2^2 + y_{k} z_2
\end{pmatrix}
\cdot Z^{-1} \nonumber\\
& {}={} &
\begin{pmatrix}
x_{k} & y_{k}
\end{pmatrix}
\begin{pmatrix}
z_1^2 & z_2^2 \\
z_1 & z_2
\end{pmatrix}
\cdot Z^{-1} \nonumber\\
& {}={} &
\begin{pmatrix}
x_{k} & y_{k}
\end{pmatrix}. \nonumber
\end{IEEEeqnarray}

\end{IEEEproof}

Due to , we require that if Bob sends  ciphertext messages

to Alice we have  for every .
Therefore, the maximum number of ciphertext messages under the same key is determined by .

\subsection{Blind decryption protocol}

Next, we give a description of a blind decryption protocol based on the transformation
algorithm .
\begin{definition}[]
Suppose that the Encryptor and the Decryptor share a key 
intended for a single decryption by Alice.
Furthermore, let Alice have an encrypted message 
that is not known to the Decryptor.
Finally, suppose that the prime  is public knowledge.
Let the protocol  be defined by the following exchange between Alice and the Decryptor:
\begin{enumerate}
	\item Alice: Compute  and transmit it to the Decryptor.
	\item Decryptor: Reply with
.
	\item Alice: Compute the plaintext message .
\end{enumerate}
\end{definition}
Let us quickly check the correctness of .
Let .
Then,
, where 
is the plaintext message.
The Decryptor replies with

But now Alice can compute
\begin{IEEEeqnarray}{l}
\alg{Map}( c',m',c) = (c - z + p m')/p \nonumber\\
\quad\quad = (p x_{k} z^2 + p y_{k} z + p m + z - z + p m')/p \nonumber\\
\quad\quad = (p x_{k} z^2 + p y_{k} z + p m - p x_{k} z^2 - p y_{k} z)/p \nonumber\\
\quad\quad = (p m)/p \nonumber\\
\quad\quad = m \nonumber
\end{IEEEeqnarray}
which is the correct plaintext message.





\subsection{The complete blind decryption scheme}

As was mentioned earlier, the communication between Alice and the Encryptor has to be protected 
in order to prevent
the Decryptor from obtaining
the plaintext messages corresponding to . If the Decryptor can observe these ciphertext messages,
it can freely decrypt all them since it knows the correct key. Therefore,
we need to apply an outer encryption scheme that hides the ciphertext messages.
The same solution is
the easiest way to provide perfect leak-freeness against the Encryptor
since it enables us to simplify
the secrecy conditions.
In our case, we want to protect both of these exchanges
with an outer tier of encryption that provides perfect secrecy.
Let  be any symmetric encryption scheme
such that the plaintext and ciphertext space is .
Let it also satisfy (ordinary) perfect secrecy.
We apply  together
with  to provide the required leak-freeness and blindess properties.


The outer tier is composed in the following way. Alice and the Encryptor shares
a set of keys . The Encryptor protects each ciphertext message
by computing  for . It sends
 to Alice. Similarly, Alice and the Decryptor
share a pair of keys  that are used to protect
 and . Alice sends  to the Decryptor
who responds with .
The resulting scheme  is defined as follows.
\begin{definition}[]
\label{def:the_final_scheme}
Let  be a symmetric encryption scheme
such that the plaintext and ciphertext space is  and
let  satisfy perfect secrecy.
Let Alice and the Encryptor share a set of keys . Let
Alice and the Decryptor share a pair of keys  intended for
a single blind decryption by Alice. Let also the Encryptor and the Decryptor
share a blind decryption key , where ,
that is intended for single blind decryption
by Alice.  is determined by the following protocol.
\begin{center}
\begin{tabular}{|lll|}
\hline
\underline{Alice} & & \underline{Encryptor} \\
& & Choose  \\
& &  \\ & &  \\
& & such that \\
& & \\
& &  \\
 &  &  \\
 & & \\
Pick  & & \\
 & & \\
 & & \underline{Decryptor}\\
 &  &  \\
& &  \\
& &  \\
& &  \\
 &  &  \\
 & & \\
 & & \\
\hline
\end{tabular}
\end{center}
\end{definition}




\section{Security of SymmetricBlind}
\label{sec:Security of devised scheme}

We shall now consider the security of . We proceed to show that the devised
scheme satisfies the three conditions formulated in Section~\ref{sec:Perfect secrecy for symmetric blind decryption}:
perfect leak-freeness against the encryptor and Alice and perfect blindness against the decryptor.

\subsection{Perfect leak-freeness against the encryptor}

\begin{proposition}
 satisfies perfect leak-freeness against the encryptor for a single decryption
of a maximum of  messages, where  is determined by .
\end{proposition}
\begin{IEEEproof}
The claim follows directly from the observation that the Encryptor sees only  and . By the description
of , 
and  are protected by encryption satisfying perfect secrecy and thus do not
leak information to the Encryptor.
\end{IEEEproof}

It is easy to see that the outer tier of encryption is necessary.
Suppose that the outer encryption scheme was not applied. Then 
would leak  which would betray  to the Encryptor.

\subsection{Perfect blindness against decryptor}

We shall now prove that the Decryptor does not get information about the plaintext message.
\begin{proposition}
 satisfies perfect blindness againt the decryptor for a single blind decryption.
\end{proposition}
\begin{IEEEproof}
Since  are protected with perfect secrecy, we only need to show that

where  and  are the random variables associated to the messages  and , respectively.
Let  denote the random variables corresponding to the key elements ,
respectively.
The reply  from the Decryptor is completely determined by the key 
and the element  since . Therefore,
\begin{IEEEeqnarray}{l}
\Pr \left[ M = m \left| C' = c' \cap M' = m' \right. \right] \nonumber\\
\quad \quad = \Pr \left[ M = m \left| \rv{X} = x_{k} \cap \rv{Y} = y_{k} \cap C' = c' \right. \right]. \nonumber
\end{IEEEeqnarray}

Let us consider . By the description of the scheme, we have
, where  is the chosen index of Alice. But for every
 we have, by the description of , that .
Therefore,  is independent with  and  and
\begin{IEEEeqnarray}{l}
\Pr \left[ M = m \left| \rv{X} = x_{k} \cap \rv{Y} = y_{k} \cap C' = z \right. \right] \nonumber\\
\quad \quad = \Pr \left[ M = m \left| \rv{X} = x_{k} \cap \rv{Y} = y_{k} \cap C' = z' \right. \right] \nonumber
\end{IEEEeqnarray}
for every 
and
\begin{IEEEeqnarray}{l}
\Pr \left[ M = m \left| \rv{X} = x_{k} \cap \rv{Y} = y_{k} \right. \right] \nonumber\\
\quad \quad = \sum_{z \in \Z_p \setminus \{0\}}
\Pr \left[ M = m \left| \rv{X} = x_{k} \cap \rv{Y} = y_{k} \cap C' = z \right. \right] \nonumber\\
\quad \quad \quad \quad \quad \quad \cdot \Pr \left[  C' = z \left| \rv{X} = x_{k} \cap \rv{Y} = y_{k} \right. \right] \nonumber\\
\quad \quad = \frac{1}{p-1} \cdot \sum_{z \in \Z_p \setminus \{0\}}
\Pr \left[ M = m \left| \rv{X} = x_{k} \cap \rv{Y} = y_{k} \cap C' = z \right. \right] \nonumber\\
\quad \quad = \Pr \left[ M = m \left| \rv{X} = x_{k} \cap \rv{Y} = y_{k} \cap C' = z \right. \right] \nonumber
\end{IEEEeqnarray}
for any .

By our assumption,  is independent with  and  and therefore we have

which shows our claim.
\end{IEEEproof}


The proof shows that the Decryptor (with the knowledge of the key  and  and )
does not gain any information
about the plaintext message 
assuming that
 for  have been delivered to Alice in perfect secrecy.
Considering the secrecy against the Decryptor, it would suffice send 
without the additional level of encryption.
However, the additional level is necessary
to achieve leak-freeness against the Encryptor.


\subsection{Perfect leak-freeness against Alice}

We shall now
consider a malicious Alice and
show that the observation of a single plaintext, ciphertext pair
 does not yield information about the decryption of  for .
\begin{proposition}
\label{prop:ConjE_secure}

satisfies
perfect leak-freeness against Alice for a single decryption
of a maximum of  ciphertexts.
\end{proposition}
\begin{IEEEproof}
By the description of , 
the ciphertext messages 
are of different congruence class modulo .
Let  be random variables over the plaintext space .
Let
 denote the random variables corresponding to the key elements
.
We have to show that
\begin{IEEEeqnarray}{l}
\Pr \left[ c_1 = \alg{Enc}_{\sch{2PAD}}(\rv{X},\rv{Y},M_1) \cap c_2 = \alg{Enc}_{\sch{2PAD}}(\rv{X},\rv{Y},M_2) \right. \nonumber\\
\quad \quad \left. | M_1 = m_1 \cap M_2 = m_2 \cap c_1 \not \equiv c_2 \pmod{p} \right] \nonumber \\
=
\Pr
\left[ c_1 = \alg{Enc}_{\sch{2PAD}}(\rv{X},\rv{Y},M_1) \cap c_2 = \alg{Enc}_{\sch{2PAD}}(\rv{X},\rv{Y},M_2) \right. \nonumber\\
\quad \quad \left. | M_1 = m_1 \cap M_2 = m \cap c_1 \not \equiv c_2 \pmod{p} \right] \nonumber
\end{IEEEeqnarray}
for every  and  such that .

Given a valid assignment for  and , it suffices to show that
\begin{IEEEeqnarray}{l}
\Pr
\left[ c_1 = \alg{Enc}_{\sch{2PAD}}(\rv{X},\rv{Y},M_1) \cap c_2 = \alg{Enc}_{\sch{2PAD}}(\rv{X},\rv{Y},M_2) \right. \nonumber\\
\quad \quad \left. | M_1 = m \cap M_2 = m_2 \cap c_1 \not \equiv c_2 \pmod{p} \right] = 1 / p^2 \nonumber
\end{IEEEeqnarray}
for every .
By Proposition~\ref{lem:solvexy_lemma}, for every plaintext, ciphertext pair 
such that 
there is a unique key .
Therefore,
\begin{IEEEeqnarray}{l}
\Pr
\left[ c_1 = \alg{Enc}_{\sch{2PAD}}(\rv{X},\rv{Y},M_1) \cap c_2 = \alg{Enc}_{\sch{2PAD}}(\rv{X},\rv{Y},M_2)\right. \nonumber\\
\quad\quad \quad\quad \left. | M_1 = m_1 \cap M_2 = m \cap c_1 \not \equiv c_2 \pmod{p} \right] \nonumber \\
\quad\quad =
\Pr
\left[ \rv{X} = x_{k} \cap \rv{Y} = y_{k} \right]. \nonumber
\end{IEEEeqnarray}
By the definition of ,  and  are independent
and we have 
\begin{IEEEeqnarray}{lll}
\Pr
\left[ \rv{X} = x_{k} \cap \rv{Y} = y_{k} \right]
& {}={} &
\Pr \left[ \rv{X} = x_{k} \right]
\cdot
\Pr \left[ \rv{Y} = y_{k} \right] \nonumber\\
& {}={} & 1 / p^2.\nonumber
\end{IEEEeqnarray}

\end{IEEEproof}



We have now established the perfect secrecy of 
 according to Def.~\ref{def:Perfect secrecy of blind decryption}.

\subsection{The parameters}

An optimal encryption scheme, with plaintext space ,
that satisfies perfect leak-freeness against Alice for a single decryption
needs
 bits of randomness for a key.
 achieves exactly this bound
since the plaintext space is  and
a single key  contains  bits of randomness.
Assuming that messages and keys are represented by binary strings, we
need  bits of key
to encrypt messages of length .
For a single decryption with , the Decryptor needs to store the key elements , as well as
the keys .
The keys  are used to encrypt messages of . Therefore, 
 bits for each of these keys suffices for perfect secrecy.
In total, the Decryptor needs to store
key material of  bits
for a single decryption of a message of bit length .

Since the ciphertext space is ,
the ciphertext length in bits is approximately twice the plaintext length.
Depending on the length of the plaintext messages and the needed maximum number of encryptions , we should therefore
choose the smallest possible , since its bit size has no effect on the security of the scheme. Table~\ref{tab:Various parameter examples}
lists some possible choices for  and the resulting key, plaintext and ciphertext lengths in bits. Note that
for long plaintext messages the maximum number of messages  is practically unlimited.
\begin{table}\caption{Parameter examples for SymmetricBlind}
\begin{tabular}{ccccc}
 & Decryptor key length & plaintext length & ciphertext length\\
& [bits] & [bits] & [bits]\\
\hline
5 & 12 & 3 & 5\\
7 & 12 & 3 & 6\\
11 & 16 & 4 & 7\\
23 & 20 & 5 & 10\\
101 & 28 & 7 & 14\\
1009 & 40 & 10 & 20\\
5003 & 52 & 13 & 25\\
20011 & 60 & 15 & 29\\
 & 124 & 31 & 62\\
 & 244 & 61 & 122\\
 & 508 & 127 & 254\\
\end{tabular}
\vspace{4pt}
\label{tab:Various parameter examples}
\end{table}






\section{Future work}
\label{sec:Future work}

There are two main drawbacks of the construction presented in this paper.
First, we have not considered active adversaries. Similar to the one time pad, we have only considered
such adversaries that observe the flow of messages. For practical scenarios, we need to consider
adversaries that actively induce errors into the protocol flow. However, such considerations
are most naturally conducted in the computational infeasibility model which has been used, for instance, in~\cite{Green_2011}.
In the active adversaries setting, it would also be
natural to consider the security of the devised scheme in the framework of computational indistinguishability such that
the truly random keys are exchanged with pseudorandom bit strings. In particular, the computationally hard version of
our scheme yields efficient practical implementations.

The second drawback is that we have only considered the case of a single malicious party. While it does not make
sense to consider a scenario where Alice is colluding with the Encryptor against the Decryptor,
the scenario where the Encryptor and the Decryptor are colluding is an important one. For many scenarios Alice cannot be certain
whether the Encryptor and the Decryptor are in fact separate entities.
However, if they are a single entity, the scenario is identical to oblivious transfer.
We cannot achieve information-theoretic security in such a case~\cite{Damgard_1999}.
For example,
it is easy to see that our construction fails for colluding Encryptor and Decryptor.
If that is the case, we effectively remove the outer layer of encryption which means
that  leaks  to the adversary.
To provide security against
colluding Encryptor and Decryptor, we would need to detect such collusion or to turn to computational
assumptions. We leave the question as an open problem for future research. 

Another interesting question for future work is to consider the case where we do not apply the outer layer
of encryption from the Encryptor to Alice. Thus far, we have defined perfect blindness so that the Decryptor has absolutely no information about
the plaintext message.
However, we could relax the requirement so that -- similar to leak-freeness against the encryptor --
the information is conditioned on the plaintexts . In other words, we could relax the requirement so
that the Decryptor may observe the selection (and the corresponding plaintext messages) given to Alice.
Such a relaxation
is natural in the oblivious transfer case where the Encryptor and the Decryptor are the same entity.
We could then define blindness as a property
requiring only that the selection  is hidden. It is again easy to see that our scheme without the outer layer
of encryption fails such a property. If  are not protected, then  leaks the selection .
We leave this consideration also for future work.

\section{Conclusion}
\label{sec:Conclusion}

In this paper, we give a definition of perfect secrecy for symmetric blind decryption in the setting where
one of the parties may be malicious but adhering to the protocol of the scheme.
We neither consider active adversaries nor the setting where two of the participants
are colluding against the third.
We construct a symmetric blind decryption scheme  and show that it satisfies our definition
of perfect secrecy. The scheme is based on two layers of encryption, where the inner layer utilizes a novel
encryption scheme  given in this paper.  is based on modular arithmetic with 
as the ciphertext space,  as the plaintext space and  as the key space, where  is a prime.
The security of  is shown information theoretically and does not depend on the size of .
For a fixed blind decryption key,  supports a single blind decryption from a selection
of  messages.
For a single decryption of a message of bit length , the decryption server
needs to store key material of  bits.



\begin{thebibliography}{10}
\providecommand{\url}[1]{#1}
\csname url@samestyle\endcsname
\providecommand{\newblock}{\relax}
\providecommand{\bibinfo}[2]{#2}
\providecommand{\BIBentrySTDinterwordspacing}{\spaceskip=0pt\relax}
\providecommand{\BIBentryALTinterwordstretchfactor}{4}
\providecommand{\BIBentryALTinterwordspacing}{\spaceskip=\fontdimen2\font plus
\BIBentryALTinterwordstretchfactor\fontdimen3\font minus
  \fontdimen4\font\relax}
\providecommand{\BIBforeignlanguage}[2]{{\expandafter\ifx\csname l@#1\endcsname\relax
\typeout{** WARNING: IEEEtran.bst: No hyphenation pattern has been}\typeout{** loaded for the language `#1'. Using the pattern for}\typeout{** the default language instead.}\else
\language=\csname l@#1\endcsname
\fi
#2}}
\providecommand{\BIBdecl}{\relax}
\BIBdecl

\bibitem{Thuraisingham_2015}
\BIBentryALTinterwordspacing
B.~Thuraisingham, ``Big data security and privacy,'' in \emph{Proceedings of
  the 5th ACM Conference on Data and Application Security and Privacy}, ser.
  CODASPY '15.\hskip 1em plus 0.5em minus 0.4em\relax New York, NY, USA: ACM,
  2015, pp. 279--280. [Online]. Available:
  \url{http://doi.acm.org/10.1145/2699026.2699136}
\BIBentrySTDinterwordspacing

\bibitem{HIPAA}
{Office for Civil Rights, United State Department of Health and Human
  Services}, ``Medical privacy. national standards of protect the privacy of
  personal-health-information,''
  http://www.hhs.gov/ocr/privacy/hipaa/administrative/privacyrule/index.html
  (retrieved 29 April 2013).

\bibitem{DataProtDirective}
{European Parliament}, ``Directive {95/46/EC} of the {E}uropean {P}arliament
  and of the {C}ouncil of 24 october 1995 on the protection of individuals with
  regard to the processing of personal data and on the free movement of such
  data,'' http://eur-lex.europa.eu/ (retrieved 21.9.2012), 1995.

\bibitem{Coull_2009}
\BIBentryALTinterwordspacing
S.~Coull, M.~Green, and S.~Hohenberger,
  ``\BIBforeignlanguage{English}{Controlling access to an oblivious database
  using stateful anonymous credentials},'' in
  \emph{\BIBforeignlanguage{English}{Public Key Cryptography -- PKC 2009}},
  ser. Lecture Notes in Computer Science, S.~Jarecki and G.~Tsudik, Eds.\hskip
  1em plus 0.5em minus 0.4em\relax Springer Berlin Heidelberg, 2009, vol. 5443,
  pp. 501--520. [Online]. Available:
  \url{http://dx.doi.org/10.1007/978-3-642-00468-1\_28}
\BIBentrySTDinterwordspacing

\bibitem{Green_2011}
\BIBentryALTinterwordspacing
M.~Green, ``Secure blind decryption,'' in \emph{Public Key Cryptography -- PKC
  2011}, ser. Lecture Notes in Computer Science, D.~Catalano, N.~Fazio,
  R.~Gennaro, and A.~Nicolosi, Eds.\hskip 1em plus 0.5em minus 0.4em\relax
  Springer Berlin / Heidelberg, 2011, vol. 6571, pp. 265--282,
  10.1007/978-3-642-19379-8\_16. [Online]. Available:
  \url{http://dx.doi.org/10.1007/978-3-642-19379-8\_16}
\BIBentrySTDinterwordspacing

\bibitem{Sakurai_1996}
\BIBentryALTinterwordspacing
K.~Sakurai and Y.~Yamane, ``Blind decoding, blind undeniable signatures, and
  their applications to privacy protection,'' in \emph{Information Hiding},
  ser. Lecture Notes in Computer Science, R.~Anderson, Ed.\hskip 1em plus 0.5em
  minus 0.4em\relax Springer Berlin Heidelberg, 1996, vol. 1174, pp. 257--264.
  [Online]. Available: \url{http://dx.doi.org/10.1007/3-540-61996-8\_45}
\BIBentrySTDinterwordspacing

\bibitem{Chaum_1983}
\BIBentryALTinterwordspacing
D.~Chaum, ``\BIBforeignlanguage{English}{Blind signatures for untraceable
  payments},'' in \emph{\BIBforeignlanguage{English}{Advances in Cryptology}},
  D.~Chaum, R.~Rivest, and A.~Sherman, Eds.\hskip 1em plus 0.5em minus
  0.4em\relax Springer US, 1983, pp. 199--203. [Online]. Available:
  \url{http://dx.doi.org/10.1007/978-1-4757-0602-4\_18}
\BIBentrySTDinterwordspacing

\bibitem{Green_2007}
\BIBentryALTinterwordspacing
M.~Green and S.~Hohenberger, ``Blind identity-based encryption and simulatable
  oblivious transfer,'' in \emph{Advances in Cryptology -- ASIACRYPT 2007},
  ser. Lecture Notes in Computer Science, K.~Kurosawa, Ed.\hskip 1em plus 0.5em
  minus 0.4em\relax Springer Berlin Heidelberg, 2007, vol. 4833, pp. 265--282.
  [Online]. Available: \url{http://dx.doi.org/10.1007/978-3-540-76900-2\_16}
\BIBentrySTDinterwordspacing

\bibitem{Perlman_2010}
\BIBentryALTinterwordspacing
R.~Perlman, C.~Kaufman, and R.~Perlner, ``Privacy-preserving {DRM},'' in
  \emph{Proceedings of the 9th Symposium on Identity and Trust on the
  Internet}, ser. IDTRUST '10.\hskip 1em plus 0.5em minus 0.4em\relax New York,
  NY, USA: ACM, 2010, pp. 69--83. [Online]. Available:
  \url{http://doi.acm.org/10.1145/1750389.1750399}
\BIBentrySTDinterwordspacing

\bibitem{Lei_2012}
L.~L. Win, T.~Thomas, and S.~Emmanuel, ``Privacy enabled digital rights
  management without trusted third party assumption,'' \emph{Multimedia, IEEE
  Transactions on}, vol.~14, no.~3, pp. 546--554, June 2012.

\bibitem{Schnorr_2000}
C.~P. Schnorr and M.~Jakobsson, ``Security of signed {E}l{G}amal encryption,''
  in \emph{Advances in cryptology---ASIACRYPT 2000}, ser. Lecture Notes in
  Comput. Sci.\hskip 1em plus 0.5em minus 0.4em\relax Berlin: Springer, 2000,
  vol. 1976, pp. 73--89.

\bibitem{Sakurai_1998}
\BIBentryALTinterwordspacing
K.~Sakurai, Y.~Yamane, S.~Miyazaki, and T.~Inoue, ``A key escrow system with
  protecting user's privacy by blind decoding,'' in \emph{Information
  Security}, ser. Lecture Notes in Computer Science, E.~Okamoto, G.~Davida, and
  M.~Mambo, Eds.\hskip 1em plus 0.5em minus 0.4em\relax Springer Berlin
  Heidelberg, 1998, vol. 1396, pp. 147--157. [Online]. Available:
  \url{http://dx.doi.org/10.1007/BFb0030417}
\BIBentrySTDinterwordspacing

\bibitem{Sameshima_1998}
\BIBentryALTinterwordspacing
Y.~Sameshima, ``A key escrow system of the {RSA} cryptosystem,'' in
  \emph{Information Security}, ser. Lecture Notes in Computer Science,
  E.~Okamoto, G.~Davida, and M.~Mambo, Eds.\hskip 1em plus 0.5em minus
  0.4em\relax Springer Berlin Heidelberg, 1998, vol. 1396, pp. 135--146.
  [Online]. Available: \url{http://dx.doi.org/10.1007/BFb0030416}
\BIBentrySTDinterwordspacing

\bibitem{Ogata_2009}
W.~Ogata \emph{et~al.}, ``New identity-based blind signature and blind
  decryption scheme in the standard model,'' \emph{{IEICE} transactions on
  fundamentals of electronics, communications and computer sciences}, vol.~92,
  no.~8, pp. 1822--1835, 2009.

\bibitem{Yao_1986}
A.~C.-C. Yao, ``How to generate and exchange secrets,'' in \emph{Foundations of
  Computer Science, 1986., 27th Annual Symposium on}, Oct 1986, pp. 162--167.

\bibitem{Rabin_1981}
M.~O. Rabin, ``How to exchange secrets with oblivious transfer,'' Technical
  Report TR-81, Aiken Computation Lab, Harvard University, 1981.

\bibitem{Even_1985}
\BIBentryALTinterwordspacing
S.~Even, O.~Goldreich, and A.~Lempel, ``A randomized protocol for signing
  contracts,'' \emph{Commun. ACM}, vol.~28, no.~6, pp. 637--647, Jun. 1985.
  [Online]. Available: \url{http://doi.acm.org/10.1145/3812.3818}
\BIBentrySTDinterwordspacing

\bibitem{Damgard_1999}
\BIBentryALTinterwordspacing
I.~Damg{\aa}rd, J.~Kilian, and L.~Salvail, ``On the (im)possibility of basing
  oblivious transfer and bit commitment on weakened security assumptions,'' in
  \emph{Proceedings of the 17th International Conference on Theory and
  Application of Cryptographic Techniques}, ser. EUROCRYPT'99.\hskip 1em plus
  0.5em minus 0.4em\relax Berlin, Heidelberg: Springer-Verlag, 1999, pp.
  56--73. [Online]. Available:
  \url{http://dl.acm.org/citation.cfm?id=1756123.1756131}
\BIBentrySTDinterwordspacing

\bibitem{Chaum_1985}
\BIBentryALTinterwordspacing
D.~Chaum, ``Security without identification: Transaction systems to make big
  brother obsolete,'' \emph{Commun. ACM}, vol.~28, no.~10, pp. 1030--1044, Oct.
  1985. [Online]. Available: \url{http://doi.acm.org/10.1145/4372.4373}
\BIBentrySTDinterwordspacing

\bibitem{Rivest_1978}
R.~L. Rivest, A.~Shamir, and L.~Adleman, ``A method for obtaining digital
  signatures and public-key cryptosystems,'' \emph{Comm. ACM}, vol.~21, no.~2,
  pp. 120--126, 1978.

\bibitem{Chaum_1992}
\BIBentryALTinterwordspacing
D.~Chaum and T.~Pedersen, ``\BIBforeignlanguage{English}{Wallet databases with
  observers},'' in \emph{\BIBforeignlanguage{English}{Advances in Cryptology --
  CRYPTO'92}}, ser. Lecture Notes in Computer Science, E.~Brickell, Ed.\hskip
  1em plus 0.5em minus 0.4em\relax Springer Berlin Heidelberg, 1993, vol. 740,
  pp. 89--105. [Online]. Available:
  \url{http://dx.doi.org/10.1007/3-540-48071-4\_7}
\BIBentrySTDinterwordspacing

\bibitem{Okamoto_1992}
\BIBentryALTinterwordspacing
T.~Okamoto, ``\BIBforeignlanguage{English}{Provably secure and practical
  identification schemes and corresponding signature schemes},'' in
  \emph{\BIBforeignlanguage{English}{Advances in Cryptology -- CRYPTO'92}},
  ser. Lecture Notes in Computer Science, E.~Brickell, Ed.\hskip 1em plus 0.5em
  minus 0.4em\relax Springer Berlin Heidelberg, 1993, vol. 740, pp. 31--53.
  [Online]. Available: \url{http://dx.doi.org/10.1007/3-540-48071-4\_3}
\BIBentrySTDinterwordspacing

\bibitem{Horster_1995}
\BIBentryALTinterwordspacing
P.~Horster, M.~Michels, and H.~Petersen,
  ``\BIBforeignlanguage{English}{Meta-message recovery and meta-blind signature
  schemes based on the discrete logarithm problem and their applications},'' in
  \emph{\BIBforeignlanguage{English}{Advances in Cryptology -- ASIACRYPT'94}},
  ser. Lecture Notes in Computer Science, J.~Pieprzyk and R.~Safavi-Naini,
  Eds.\hskip 1em plus 0.5em minus 0.4em\relax Springer Berlin Heidelberg, 1995,
  vol. 917, pp. 224--237. [Online]. Available:
  \url{http://dx.doi.org/10.1007/BFb0000437}
\BIBentrySTDinterwordspacing

\bibitem{Camenisch_1995}
\BIBentryALTinterwordspacing
J.~Camenisch, J.-M. Piveteau, and M.~Stadler,
  ``\BIBforeignlanguage{English}{Blind signatures based on the discrete
  logarithm problem},'' in \emph{\BIBforeignlanguage{English}{Advances in
  Cryptology -- EUROCRYPT'94}}, ser. Lecture Notes in Computer Science,
  A.~De~Santis, Ed.\hskip 1em plus 0.5em minus 0.4em\relax Springer Berlin
  Heidelberg, 1995, vol. 950, pp. 428--432. [Online]. Available:
  \url{http://dx.doi.org/10.1007/BFb0053458}
\BIBentrySTDinterwordspacing

\bibitem{ElGamal_1985}
T.~ElGamal, ``A public key cryptosystem and a signature scheme based on
  discrete logarithms,'' \emph{IEEE Trans. Inform. Theory}, vol.~31, no.~4, pp.
  469--472, 1985.

\bibitem{Mambo_1996}
\BIBentryALTinterwordspacing
M.~Mambo, K.~Sakurai, and E.~Okamoto, ``\BIBforeignlanguage{English}{How to
  utilize the transformability of digital signatures for solving the oracle
  problem},'' in \emph{\BIBforeignlanguage{English}{Advances in Cryptology --
  ASIACRYPT '96}}, ser. Lecture Notes in Computer Science, K.~Kim and
  T.~Matsumoto, Eds.\hskip 1em plus 0.5em minus 0.4em\relax Springer Berlin
  Heidelberg, 1996, vol. 1163, pp. 322--333. [Online]. Available:
  \url{http://dx.doi.org/10.1007/BFb0034858}
\BIBentrySTDinterwordspacing

\bibitem{Brassard_1987}
\BIBentryALTinterwordspacing
G.~Brassard, C.~Cr{\'e}peau, and J.-M. Robert, ``All-or-nothing disclosure of
  secrets,'' in \emph{Proceedings on Advances in cryptology -- CRYPTO
  '86}.\hskip 1em plus 0.5em minus 0.4em\relax London, UK, UK: Springer-Verlag,
  1987, pp. 234--238. [Online]. Available:
  \url{http://dl.acm.org/citation.cfm?id=36664.36681}
\BIBentrySTDinterwordspacing

\bibitem{Naor_1999_2}
\BIBentryALTinterwordspacing
M.~Naor and B.~Pinkas, ``\BIBforeignlanguage{English}{Oblivious transfer with
  adaptive queries},'' in \emph{\BIBforeignlanguage{English}{Advances in
  Cryptology -- CRYPTO 99}}, ser. Lecture Notes in Computer Science, M.~Wiener,
  Ed.\hskip 1em plus 0.5em minus 0.4em\relax Springer Berlin Heidelberg, 1999,
  vol. 1666, pp. 573--590. [Online]. Available:
  \url{http://dx.doi.org/10.1007/3-540-48405-1\_36}
\BIBentrySTDinterwordspacing

\bibitem{Camenisch_2007}
\BIBentryALTinterwordspacing
J.~Camenisch, G.~Neven, and a.~shelat, ``Simulatable adaptive oblivious
  transfer,'' in \emph{Advances in Cryptology -- EUROCRYPT 2007}, ser. Lecture
  Notes in Computer Science, M.~Naor, Ed.\hskip 1em plus 0.5em minus
  0.4em\relax Springer Berlin Heidelberg, 2007, vol. 4515, pp. 573--590.
  [Online]. Available: \url{http://dx.doi.org/10.1007/978-3-540-72540-4\_33}
\BIBentrySTDinterwordspacing

\bibitem{Green_2008}
\BIBentryALTinterwordspacing
M.~Green and S.~Hohenberger, ``Universally composable adaptive oblivious
  transfer,'' in \emph{Advances in Cryptology - ASIACRYPT 2008}, ser. Lecture
  Notes in Computer Science, J.~Pieprzyk, Ed.\hskip 1em plus 0.5em minus
  0.4em\relax Springer Berlin Heidelberg, 2008, vol. 5350, pp. 179--197.
  [Online]. Available: \url{http://dx.doi.org/10.1007/978-3-540-89255-7\_12}
\BIBentrySTDinterwordspacing

\bibitem{Jarecki_2009}
\BIBentryALTinterwordspacing
S.~Jarecki and X.~Liu, ``\BIBforeignlanguage{English}{Efficient oblivious
  pseudorandom function with applications to adaptive ot and secure computation
  of set intersection},'' in \emph{\BIBforeignlanguage{English}{Theory of
  Cryptography}}, ser. Lecture Notes in Computer Science, O.~Reingold,
  Ed.\hskip 1em plus 0.5em minus 0.4em\relax Springer Berlin Heidelberg, 2009,
  vol. 5444, pp. 577--594. [Online]. Available:
  \url{http://dx.doi.org/10.1007/978-3-642-00457-5\_34}
\BIBentrySTDinterwordspacing

\bibitem{Kurosawa_2009}
\BIBentryALTinterwordspacing
K.~Kurosawa and R.~Nojima, ``\BIBforeignlanguage{English}{Simple adaptive
  oblivious transfer without random oracle},'' in
  \emph{\BIBforeignlanguage{English}{Advances in Cryptology -- ASIACRYPT
  2009}}, ser. Lecture Notes in Computer Science, M.~Matsui, Ed.\hskip 1em plus
  0.5em minus 0.4em\relax Springer Berlin Heidelberg, 2009, vol. 5912, pp.
  334--346. [Online]. Available:
  \url{http://dx.doi.org/10.1007/978-3-642-10366-7\_20}
\BIBentrySTDinterwordspacing

\bibitem{Kurosawa_2010}
\BIBentryALTinterwordspacing
K.~Kurosawa, R.~Nojima, and L.~T. Phong, ``Efficiency-improved fully
  simulatable adaptive ot under the ddh assumption,'' in \emph{Proceedings of
  the 7th International Conference on Security and Cryptography for Networks},
  ser. SCN'10.\hskip 1em plus 0.5em minus 0.4em\relax Berlin, Heidelberg:
  Springer-Verlag, 2010, pp. 172--181. [Online]. Available:
  \url{http://dl.acm.org/citation.cfm?id=1885535.1885554}
\BIBentrySTDinterwordspacing

\bibitem{Green_2011_2}
\BIBentryALTinterwordspacing
M.~Green and S.~Hohenberger, ``\BIBforeignlanguage{English}{Practical adaptive
  oblivious transfer from simple assumptions},'' in
  \emph{\BIBforeignlanguage{English}{Theory of Cryptography}}, ser. Lecture
  Notes in Computer Science, Y.~Ishai, Ed.\hskip 1em plus 0.5em minus
  0.4em\relax Springer Berlin Heidelberg, 2011, vol. 6597, pp. 347--363.
  [Online]. Available: \url{http://dx.doi.org/10.1007/978-3-642-19571-6\_21}
\BIBentrySTDinterwordspacing

\bibitem{Kurosawa_2011}
\BIBentryALTinterwordspacing
K.~Kurosawa, R.~Nojima, and L.~Phong, ``\BIBforeignlanguage{English}{Generic
  fully simulatable adaptive oblivious transfer},'' in
  \emph{\BIBforeignlanguage{English}{Applied Cryptography and Network
  Security}}, ser. Lecture Notes in Computer Science, J.~Lopez and G.~Tsudik,
  Eds.\hskip 1em plus 0.5em minus 0.4em\relax Springer Berlin Heidelberg, 2011,
  vol. 6715, pp. 274--291. [Online]. Available:
  \url{http://dx.doi.org/10.1007/978-3-642-21554-4\_16}
\BIBentrySTDinterwordspacing

\bibitem{Zhang_2013}
\BIBentryALTinterwordspacing
B.~Zhang, H.~Lipmaa, C.~Wang, and K.~Ren,
  ``\BIBforeignlanguage{English}{Practical fully simulatable oblivious transfer
  with sublinear communication},'' in
  \emph{\BIBforeignlanguage{English}{Financial Cryptography and Data
  Security}}, ser. Lecture Notes in Computer Science, A.-R. Sadeghi, Ed.\hskip
  1em plus 0.5em minus 0.4em\relax Springer Berlin Heidelberg, 2013, vol. 7859,
  pp. 78--95. [Online]. Available:
  \url{http://dx.doi.org/10.1007/978-3-642-39884-1\_8}
\BIBentrySTDinterwordspacing

\bibitem{Guleria_2015}
\BIBentryALTinterwordspacing
V.~Guleria and R.~Dutta, ``\BIBforeignlanguage{English}{Efficient adaptive
  oblivious transfer without q-type assumptions in uc framework},'' in
  \emph{\BIBforeignlanguage{English}{Information and Communications Security}},
  ser. Lecture Notes in Computer Science, L.~C.~K. Hui, S.~H. Qing, E.~Shi, and
  S.~M. Yiu, Eds.\hskip 1em plus 0.5em minus 0.4em\relax Springer International
  Publishing, 2015, vol. 8958, pp. 105--119. [Online]. Available:
  \url{http://dx.doi.org/10.1007/978-3-319-21966-0\_8}
\BIBentrySTDinterwordspacing

\bibitem{Crepeau_2005}
\BIBentryALTinterwordspacing
C.~Cr{\'e}peau, K.~Morozov, and S.~Wolf,
  ``\BIBforeignlanguage{English}{Efficient unconditional oblivious transfer
  from almost any noisy channel},'' in
  \emph{\BIBforeignlanguage{English}{Security in Communication Networks}}, ser.
  Lecture Notes in Computer Science, C.~Blundo and S.~Cimato, Eds.\hskip 1em
  plus 0.5em minus 0.4em\relax Springer Berlin Heidelberg, 2005, vol. 3352, pp.
  47--59. [Online]. Available:
  \url{http://dx.doi.org/10.1007/978-3-540-30598-9\_4}
\BIBentrySTDinterwordspacing

\bibitem{Rivest_1999}
R.~Rivest, ``Unconditionally secure commitment and oblivious transfer schemes
  using private channels and a trusted initializer,'' Unpublished manuscript,
  1999.

\bibitem{Yao_1982_2}
A.~C. Yao, A.~C. Yao, A.~C. Yao, and A.~C. Yao, ``Protocols for secure
  computations,'' in \emph{Foundations of Computer Science, 1982. SFCS '08.
  23rd Annual Symposium on}, Nov 1982, pp. 160--164.

\bibitem{Goldreich_1987}
\BIBentryALTinterwordspacing
O.~Goldreich, S.~Micali, and A.~Wigderson, ``How to play any mental game,'' in
  \emph{Proceedings of the Nineteenth Annual ACM Symposium on Theory of
  Computing}, ser. STOC '87.\hskip 1em plus 0.5em minus 0.4em\relax New York,
  NY, USA: ACM, 1987, pp. 218--229. [Online]. Available:
  \url{http://doi.acm.org/10.1145/28395.28420}
\BIBentrySTDinterwordspacing

\bibitem{Shannon_1949}
\BIBentryALTinterwordspacing
C.~E. Shannon, ``Communication theory of secrecy systems*,'' \emph{Bell System
  Technical Journal}, vol.~28, no.~4, pp. 656--715, 1949. [Online]. Available:
  \url{http://dx.doi.org/10.1002/j.1538-7305.1949.tb00928.x}
\BIBentrySTDinterwordspacing

\bibitem{Katz_2007}
J.~Katz and Y.~Lindell, \emph{Introduction to Modern Cryptography}.\hskip 1em
  plus 0.5em minus 0.4em\relax Chapman \& Hall/CRC, 2007.

\end{thebibliography}


\end{document}
