\documentclass[copyright,creativecommons]{eptcs}


\usepackage{times}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{alltt}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{array}
\usepackage[T1]{fontenc}
\usepackage{verbatim}
\usepackage{color}
\usepackage{url}
\usepackage{multirow}
\usepackage{breakurl}   \usepackage{eucal}
\usepackage{xspace}


\graphicspath{{images/}}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}

\theoremstyle{definition}
\newtheorem{definition}{Definition}

\newenvironment{example}[1][Example]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newenvironment{remark}[1][Remark]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}

 
\renewcommand{\paragraph}[1]{\medskip \noindent {\bf #1}}


\newcommand{\id}[1]{\mathit{#1}}
\newcommand{\trans}[1]{\,{\stackrel{{#1}}{\longrightarrow}}\,}
\newcommand{\gtrans}[2]{\,{\stackrel{{#2}}{\longrightarrow_{#1}}}\,}
\newcommand{\transtwo}[1]{\, { \stackrel {{  \stackrel{{#1}}{\longrightarrow} }} {{#1}} }   \,}
\newcommand{\M}{\mathcal{M}}
\newcommand{\Nat}{\mathbb N}

\newcommand{\Sch}{\textit{Sch}\xspace}
\newcommand{\act}{\textit{act}\xspace}
\newcommand{\Act}{\textit{Act}\xspace}
\newcommand{\obs}{\textit{obs}\xspace}
\newcommand{\Traces}{\textit{Traces}\xspace}
\newcommand{\TC}{\textit{TC}\xspace}
\newcommand{\TP}{\textit{TP}\xspace}
\newcommand{\compat}{\mathsf{\ compat\ }}
\newcommand{\passes}{\mathsf{\ passes\ }}
\newcommand{\para}{\!\parallel\!}
\newcommand{\true}{\textit{true}\xspace}
\newcommand{\STraces}{\textit{STraces}\xspace}
\newcommand{\Spec}{\textit{Spec}\xspace}
\newcommand{\IUT}{\textit{IUT}\xspace}
\newcommand{\Uppaal}{{\sc Uppaal}\xspace}
\newcommand{\MutEx}{\lstinline{MutEx}\xspace}
\newcommand{\scaleIndex}{.9}
\newcommand{\trule}[1]{\big[\hspace{-.1cm}\underline{\big[#1\big]}\hspace{-.1cm}\big]}
\newcommand{\tneg}{\sim\!}

\lstdefinelanguage{Credo}
{morekeywords={interface, class, facade, component, manager, inherits, implements, begin, end, while, do, od, if, fi, then, else, and,  op, with, in, out, inout, or, var, port, new, inports, return, int, bool, outports, syncports, sync_event, async_event, await, release, raise_event, skip},
sensitive=true,
morecomment=[l]{//},
morecomment=[s]{/*}{*/},
morestring=[b]",
}
\lstdefinelanguage{maude}
{morekeywords={mod, is, pr, op, eq, rew, endm},
sensitive=true,
morecomment=[l]{***},
morecomment=[s]{/*}{*/},
morestring=[b]",
}
\lstdefinelanguage{Uppaal}
{morekeywords={while, do, if, else, and,  or, new, return, int, bool, clock, void, const, meta},
sensitive=true,
morecomment=[l]{//},
morecomment=[s]{/*}{*/},
morestring=[b]",
}


\lstset{language=Uppaal, numbers=left, numbersep=8pt, numberblanklines=false, basicstyle=\footnotesize\ttfamily, frame=single, lineskip=2.5pt, xleftmargin=30pt, framexleftmargin=20pt, xrightmargin=10pt
}


\begin{document}

\title{Timed Automata Semantics for Analyzing Creol\thanks{This work is partly funded by the European IST-33826 STREP project CREDO on Modeling and Analysis of Evolutionary Structures for Distributed Services.}}

\def\titlerunning{Timed Automata Semantics for Analyzing Creol}  

\author{
Mohammad Mahdi Jaghoori
\institute{LIACS, Leiden University, Leiden\\
CWI, Amsterdam, The Netherlands}
\email{jaghouri@cwi.nl}
\and
Tom Chothia
\institute{School of Computer Science\\
University of Birmingham, United Kingdom}
\email{t.chothia@cs.bham.ac.uk}
}

\def\authorrunning{M. Jaghoori and T. Chothia}   


\maketitle



\begin{abstract}
We give a real-time semantics for the concurrent, object-oriented modeling language Creol, by mapping Creol processes to a network of timed automata. We can use our semantics to verify real time properties of Creol objects, in particular to see whether processes can be scheduled correctly and meet their end-to-end deadlines.
Real-time Creol can be useful for analyzing, for instance, abstract models of multi-core embedded systems.
We show how
analysis can be done
in \Uppaal.


\end{abstract}





\section{Introduction}
Parallel and distributed systems span a wide range of applications, from internet-based services to multi-core embedded systems.
Concurrent objects, as in Creol \cite{johnsen07sosym}, have dedicated processors and thus provide a natural way of modeling these systems.
In a real-time setting, a major analysis problem is schedulability, that is, whether all tasks are accomplished within their deadlines.
We enrich Creol with real-time and provide  a timed-automata semantics for it where in particular schedulability can be analyzed; this semantics allows for explicit modeling of  scheduling strategies.
For practicality, we define this semantics in terms of a translation algorithm such that the generated automata can be handled by \Uppaal\ \cite{LarsenPY97}.








Each Creol method is mapped to exactly one automaton with the possibility of tracing from automata back to Creol code; the semantics of an object consists of a network of the automata for its methods together with a scheduler automaton (e.g., Earliest Deadline First, Fixed Priority Scheduling, etc.).
We have implemented a program that translates Creol code to the corresponding timed automata, which can then be run and verified in \Uppaal. We validate the automated verification cycle by checking a coordinator class by Johnsen and Owe \cite {johnsen07sosym}, augmented with real-time, for correctness as well as schedulability.




A distinctive feature of Creol is that it gives the programmer a high degree of control over the scheduling. At ``processor release points'', a method can choose to give up control of the processor and specify conditions on when it should be resumed.
Previous work on Creol has not addressed particular scheduling policies; instead processes are scheduled in a completely non-deterministic manner. The real time extensions and schedulability analysis we present here can be seen as a complementary feature for the basic Creol language.

In Creol, object references are typed only by interfaces, allowing for a strongly typed language with support for features such as multiple inheritance and type-safe dynamic class upgrades \cite{yu06fmoods}. We augment an interface with a notion of high-level behavioral specification given in a timed automaton; this is given by the modeler as the first step in modeling an object. A class can implement multiple interfaces. In this case, the timed automata for behavioral interfaces should be interleaved; intuitively, allowing more behavior than each automaton separately. The justification is that a class with multiple interfaces can participate in multiple protocols independently. Creol supports multiple inheritance for both interfaces and classes.  Interfaces form a subtype hierarchy, which is distinct from inheritance at the level of classes used merely for code reuse \cite{JohnsenOY06}. In a subtype hierarchy, the timed automata for the inherited behavioral interfaces should synchronize on similar actions; intuitively, allowing less behavior in the subtype. The justification is that a subtype should be a refinement of its supertypes \cite{PR94}.






We use a statement-based delay semantics for our notion of real-time in Creol, namely, we annotate each statement with best- and worst-case execution times, as it naturally fits the operational semantics of Creol and it is the normal trend in schedulability analysis \cite{EDF08,ClossePPSVWY01,FersmanYi07acc,KloukinasY03}.
Also, all method calls are given a deadline, which specifies the time before which the callee {\it should} finish.
By giving the annotations in comments, we allow the standard Creol interpreter to behave normally by ignoring the real-time information if necessary.
One could specify cumulative delays for a group of statements (by assigning the default delay of zero to all statements except the last one).
When a Creol model is schedulable, it gives us requirements on point-to-point execution times that should be fulfilled by the final implementation in programming language like C; this can also be tested by checking conformance \cite{AichernigGJSS08}. 

Whenever a called method finishes, it sends a `reply' back to the caller. By waiting for the reply, one can model synchronous method calls. Timely replies ensure end-to-end deadlines. Method invocations are labeled to help match replies with the originating invocations.
Dynamic labels lead to infinite state models for non-terminating systems. To model this using finite state timed automata, we label method invocations statically;
thus, replies to repeated invocations associated with the same label are not distinguished in our automata semantics.
Furthermore, we abstract from other dynamic statements in Creol.
Although in our semantics, we abstract from the dynamic behavior, i.e., dynamic object creation and reconfiguration, it is worth noting that these actions have no effect in individual object analysis.




In Section \ref{sec:prelim}, we briefly introduce timed automata and \Uppaal models.
Section \ref{sec::rtcreol} describes Creol and discusses how it can be extended with real time.
In Section \ref{sec::translation} we discuss how Creol with real time can be given a semantics using timed automata.
We show how this semantics can be applied to analyze schedulability in Section \ref{sec::analysis}.
We conclude in Section \ref{sec:conc}.




\paragraph{\bf Related Work}
In previous work \cite{Jaghoori09jlap,JaghouriDBC08RTSS}, we provided a high-level framework for modular schedulability analysis of purely asynchronous objects modeled as timed automata. This past work assumes methods run until completion without interruption, unlike the work we present here. In this paper we apply this automata theoretic framework to the concurrent object modeling language Creol \cite{johnsen07sosym} by defining a mapping from Creol processes to timed-automata; to accomodate Creol features, the scheduler model is also extensively extended.

We discussed a possible encoding from Creol to timed automata in a past paper \cite{fsen09}, however this encoding was incomplete, both in the Creol features covered and because it discussed only translation of one method; it would generate  many automata to encode each method.
In the full, efficient encoding presented in this paper, we improve scalability by reducing the number of generated automata (i.e., release statements do not generate a new automaton now). Further, we improve label handling by making the scheduler responsible for this; we add features like multiple interfaces; blocking statements are now also handled by the scheduler; our improved scheduler allows for local synchronous calls, which may incur recursive calls. With this semantics, we can now verify Creol models for schedulability; examples of other properties we can check include deadlock, or timed reachability of any specific line of code.


 \cite{KyasJ08} is a real-time extension of Creol along the lines of   Hoare logic extended with real-time.
In , time can affect the functional behavior of the object, but we use only descriptive annotations.
It is possible in  to specify contradicting invariants, which is not the case in our simple delay model.
By automatically generating timed automata, we can readily use \Uppaal\ for model checking and schedulability analysis, however, to the best of our knowledge,  has no automated tool support.
Another important difference is that we can model and compare explicit scheduling strategies, and so say which strategies would and would not lead to missed deadlines.


With respect to schedulability analysis, a characteristic of our work is modularity. A behavioral interface models the most general input/output behavior allowed for an object and thus can be used as an abstraction of the environment. A behavioral interface can be viewed as a contract as in ``design by contract'' \cite{Meyer92} or as a most general assumption in modular model checking ~\cite{KupfermanVW01} (based on assume-guarantee reasoning); schedulability is guaranteed if the real use of the object satisfies this assumption.
In the literature,
a model of the environment is usually the task generation scheme in a specific situation. For example, in TAXYS \cite{ClossePPSVWY01}, different models of the environment can be used to check schedulability of the application in different situations. However, a behavioral interface in our analysis
covers all allowable usages of the object, and is thus an over-approximation of all environments in which the object can be used.
This adds to the modularity of our approach; every use of the object foreseen in the interface is verified to be schedulable.
Finally, TAXYS deals with a programming language, whereas we work at modeling level. It is also the case with the works of \cite{KloukinasY03} where they extract automata from code for schedulability analysis. As mentioned above, they deal with programming languages (like TAXYS) and timings are usually obtained by profiling the real system. Our work, on the contrary, is applied on a model before the implementation of the real system. Therefore, our main focus is on studying different scheduling policies and design decisions.
These models can be used for automatic code generation or conformance checking with later or existing implementations.



\section{Preliminaries}
\label{sec:prelim}

We give a brief introduction to Timed Automata, for a full description we refer the reader to previous papers on timed automata (e.g. \cite{AlurD94}) and documentation for the \Uppaal tool \cite{LarsenPY97}.

\begin{definition}[\bf Timed Automata]\label{def:timeAut}
Suppose  is the set of all clock constraints on the set of clocks . A timed automaton over actions  and clocks  is a tuple  representing
\begin{itemize}
\item a finite set of locations  (including an initial location );
\item the set of edges ; and,
\item a function  assigning an invariant to each location.
\end{itemize}
\end{definition}

An edge   implies that action `' may change the location  to  by resetting the clocks in ,  if the clock constraints in  (as well as the invariant of ) hold.
A timed automaton is called {\em deterministic} if and only if for
each , if there are two edges  and  from  labeled by the same
action 
then the guards  and  are disjoint (i.e.,  is unsatisfiable).
Since we use \Uppaal~\cite{LarsenPY97}, we allow defining variables of type boolean
and bounded integers. Variables can appear in
guards and updates.










A system may be described as a {\em network} of communicating timed automata. In these automata, the action set is partitioned into input, output and internal actions.
The behavior of the system is defined as the parallel composition of those automata . Semantically, the system can delay if all automata can delay and can perform an action if one of the automata can perform an internal action or if two automata can synchronize on complementary actions (inputs and outputs are complementary).
In a network of timed automata, variables can be defined locally for one automaton, globally (shared between all automata), or as  parameters to the automata.

A location can be marked  {\em urgent} in an automaton to indicate that the automaton cannot spend any time in that location. This is equivalent to resetting a fresh clock  in all of its incoming edges and adding an invariant  to the location.
In a network of timed automata, the enabled transitions from an urgent location may be interleaved with the enabled transitions from other automata (while time is frozen).
Like urgent locations, {\em committed} locations freeze time; furthermore, if any process is in a committed location, the next step must involve an edge from one of the committed locations.


\begin{definition}[\bf {\textsc {\bfseries Uppaal}} Model]
An \Uppaal\ model consists of: (1)  a set of timed automata templates (); (2) global declarations; and, (3) system declarations.
\end{definition}

An automata template in an \Uppaal model consists of a name, a set of arguments, local declarations and a timed automaton definition (as above); formally, .
Global and local declarations contain the definition of clocks and variables.
The network of timed automata to be analyzed is defined in the system declarations by instantiating the timed automata templates.




\section{Creol with Real-Time}
\label{sec::rtcreol}

\lstset{language=Credo, basicstyle=\scriptsize\ttfamily} 

\begin{figure}[tb]
\begin{tabular}{ll}
{ \small \begin{tabular}{l@{~}c@{~~}l}
b &:& Boolean \\
e &:& Expression \\
g&:& Guard  \\
m&:&Method \\
n &:& Identifier \\
s &:& Statement \\
t &:& Label \\
x &:& Object \\

\end{tabular}
}
&
{\small

}
\end{tabular}
\caption{BNF  grammar for Creol (adapted from \cite{johnsen07sosym}) where  and  show repetition for at least 0 and 1 times, respectively;  denotes an optional element; and, a subscript  implies a comma-separated list.}\label{fig::creolSyntax}
\end{figure}


Creol~\cite{johnsen07sosym} is an object oriented modeling language for distributed systems, where each object implicitly has a dedicated processor.
A simplified syntax for Creol, for which we give a semantics is shown in Figure~\ref{fig::creolSyntax}.
We use, as running example, a coordinator class, taken from \cite{johnsen07sosym}, concretized for three-way synchronization (while abstracting data away), shown in Figure~\ref{fig::creolCode}.

A Creol model is defined as objects typed by interfaces, which are in turn a set of method definitions; a method can define a cointerface using the \lstinline{with} keyword to restrict the type of its caller to the given interface.
A class implementing some interfaces realizes their methods possibly introducing private methods and local variables.
With inheritance of interfaces, one can create a subtype hierarchy.
We abstract from method parameters and dynamic object creation.
However, classes and interfaces can have parameters. Instances of a class can communicate by objects given as class parameters, called the {\em known objects}. We  can thus define the static topology of the system.
The class behavior is defined in its methods, where a method is a sequence of statements separated by semicolon.
For expressions, we assume the syntax that is accepted by \Uppaal.
The \lstinline{Coordinator} class implements three interfaces, each with one method, e.g., \lstinline{with Any op m1} that defines method \lstinline{m1} which can be called from objects of {\em any} type.
The method \lstinline{init} in an object is immediately executed upon object creation.
The method \lstinline{run} specifies active behavior of the object; it will have to compete with other tasks in the queue if any.

\begin{figure}[t]

\begin{tabular}{m{.60\textwidth}m{.30\textwidth}}

\begin{lstlisting}
interface C1 begin with Any op m1 end
interface C2 begin with Any op m2 end
interface C3 begin with Any op m3 end
class Coordinator implements C1, C2, C3 begin
  var s1,s2,s3,sync : bool
  op init ==
    s1 := false; // assume zero exec. time by
    s2 := false; // default, resulting in a
    s3 := false; // collective delay
    sync := true /* specified here: @b2 @w4*/
  op body ==
    skip                          /*@b2 @w5*/
  op run ==
    await (s1 /\ s2 /\ s3);       /*@b1 @w2*/
    b!body();  /* invoc. delay @b1 @w1 @d10*/
    b?;        // force sync call
    sync := false;
    await (~s1 /\ ~s2 /\ ~s3);    /*@b1 @w2*/
    sync := true;                 /*@b1 @w1*/
    !run()                        /*   @d50*/
  with Any
  op m1 ==
    await (sync /\ ~s1);
    s1 := true;                   /*@b1 @w1*/
    await ~sync;
    s1 := false                   /*@b1 @w1*/
  op m2 ==  ...like m1...
  op m3 ==  ...like m1...
end
\end{lstlisting}


&

{\small
\centering
\includegraphics{FOCLASA_C1} \\ Behavioral specification for C1 \\ ~ \\~ \\
\includegraphics{FOCLASA_C2} \\ Behavioral specification for C2 \\ ~ \\~ \\
\includegraphics{FOCLASA_C3} \\ Behavioral specification for C3
}

\end{tabular}
\vspace{-0.5cm}
\caption{A real-time coordinator in Creol with periodic task generation in the behavioral interfaces.}
\label{fig::creolCode}\label{fig::periodicBeh}

\end{figure}


\lstset{language=Uppaal, basicstyle=\footnotesize}


Methods can have processor release points which define interleaving points explicitly.
When a process is executing, it is not interrupted until it finishes or reaches a release point.
Release points can be conditional, written as \lstinline  (e.g., line 14).
If \lstinline  is satisfied, the process keeps the control; otherwise, it releases  the processor.
A suspended process will be enabled when the guard evaluates to true.
When the processor is free, an enabled process is nondeterministically selected and started.
The \lstinline  statement unconditionally releases the processor and the continuation of the  method is an enabled process.



If a method invocation \lstinline  is associated with a label \lstinline , written as \lstinline , the sender can wait for a reply using the blocking statement \lstinline  or in a nonblocking way by including \lstinline  in a release point, e.g., as in  \lstinline.
A reply is sent back automatically when the called method finishes.
Before the reply is available, executing  \lstinline releases the processor whereas  the blocking statement \lstinline  does not. While the processor is not released, the other processes in the object do not get a chance for execution; if \lstinline is related to a self call and its reply is not yet available, it forces synchronous execution of the called method.
For example, line 16 in Figure \ref{fig::creolCode} forces synchronous execution of the method \lstinline{body}.



\paragraph{Adding Real-Time}
The modeler should specify for every statement how long it takes to execute.
The directives \lstinline{@b} and \lstinline{@w} are used for specifying the best-case and worst-case execution times for each statement.
We assume zero execution time for statements with no annotations; there must be, however, non-zero execution time in each process before the processor is released.
Furthermore, every method call, including self calls, must be associated with a deadline using \lstinline{@d} directive. This deadline specifies the relative time before which the corresponding method should be scheduled and executed. Since we do not have message transmission delays, the deadline expresses the time until a reply is received. Thus, it corresponds to an {\em end-to-end} deadline.
A worst-case execution time delay for a blocking statement \lstinline is ignored.
The delay associated to release statements specifies only the time for invoking the command and not the waiting time afterwards.








Creol interfaces are enriched with behavioral interfaces given in timed automata, which specify
the abstract behavior of an object. This interface consists of the messages the object may receive and send and provides an overview of the object behavior in a single automaton. It should also contain the reply signals the object may receive.
A behavioral interface abstracts from specific method implementations, the queue in the object and the scheduling strategy.
Figure \ref {fig::periodicBeh} shows the behavioral interfaces for the coordinator example that  assume  periodic arrival of events.
To formally define behavioral interfaces in \Uppaal, we assume two finite global sets  for method names and  for labels; and, two \Uppaal channels \lstinline{invoke} and \lstinline{reply} (cf. modeling schedulers in the next section).


\begin{definition}[\bf Behavioral interface]\label{def:behavioral_interface}
A behavioral interface , with known objects , providing a set of method names  is formally defined as a deterministic timed automaton over alphabet   such that  is partitioned into three sets of actions (assume  and ):
\begin{itemize}
\item object inputs sent by the environment:
~ 
\item object outputs received by the environment:
~ 
\item replies to the object outputs:
~ 
\end{itemize}
Transitions specifying an input to the object must update the variable \lstinline with an integer specifying the deadline for that input.
If  has no known objects then  by default.
\end{definition}


\section{Timed Automata Semantics For Creol}\label{sec::translation}


The semantics of a Creol class consists of the automata for its methods. When instantiating a class, it should also be associated with a scheduler automaton.
In this section, we explain the algorithm for automatically deriving automata from Creol code.
This semantics maps each method to one automaton.
For practicality, we define this semantics in terms of a translation algorithm
that generates an \Uppaal model containing the automata for methods together with other necessary global declarations.


\begin{definition}[\bf Class]\label{def:class}
The semantics of a class  implementing a set of behavioral interfaces  is defined as follows.
Recall that each  has a set of method names .
 is a set  of tasks, where
\begin{itemize}
\item  is a set of task names such that  for every .
 includes the sub-tasks created at release points, as well as the methods; however, there is exactly one automaton for each method.
\item for all , ,  is a timed automaton representing the method containing the task . \item for all , ,  is the enabling condition for .
\end{itemize}
\end{definition}

We assume that the given Creol models are correctly typed and annotated with timing information.
We use the same syntax for expressions and assignments in Creol, as is used by \Uppaal. This allows for a more direct translation.
For the sake of simplicity, we abstract from parameter passing, however, it can be modeled in \Uppaal\ by extending the queue to hold the parameters (cf. Section \ref{sec::scheduler}).
Figure~\ref{fig::run}  shows the automata generated for the methods \lstinline and \lstinline from Figure~\ref{fig::creolCode}.
The automata for \lstinline and \lstinline are similar.
As can be seen in these automata, the method and variable names are prefixed in order to avoid name clashes with \Uppaal\ keywords.
As explained in Section \ref{sec:formal}, function  will link each automata location to its corresponding part of the original code;
this is shown in Figure~\ref{fig::run} as line numbers refering to the original Creol code in Figure~\ref{fig::creolCode}.


\begin{figure*}[tb]
\begin{center}
\begin{tabular}{@{} m{11.6cm}  m{4.35cm}}
\includegraphics[scale=0.9]{FOCLASA_run} &
{\footnotesize\bfseries
\renewcommand{\arraystretch}{1.25}
\begin{tabular}{@{}l@{~}|@{~}c@{}}
Task & Enabling Condition\\
\hline
\verb"run" & \\
\verb"run1" & \\
\verb"run2" &  \\
\end{tabular}
\vspace{.5cm}
}
\end{tabular}
\\
(a) The automaton for method {\tt run} and the enabling conditions for its subtasks. \\
\end{center}



\centering
\begin{tabular}{@{} m{8.2cm} >{\centering\arraybackslash} m{4.35cm}}
\includegraphics[scale=0.9]{FOCLASA_m1}
 &
{\footnotesize\bfseries
\renewcommand{\arraystretch}{1.25}
\begin{tabular}{l|c}
Task & Enabling Condition\\
\hline
\verb"m1" & \\
\verb"m11" & \\
\verb"m12" & \\
\end{tabular}
}
\end{tabular}
\\
(b) The automaton for method {\tt m1} and the enabling conditions for its subtasks. \caption{The labels on automata location refer to line numbers in Figure~\ref{fig::creolCode} (cf. function  in Table \ref{tab:function}).}\label{fig::run}
\end{figure*}



Methods may  release the processor before their completion, as in the `\lstinline{await}' statement in line 14 in Figure \ref{fig::creolCode}.
In these cases, the rest of the method is modeled as a sub-task, e.g., the  transition from location 14 to \verb"U" in Figure \ref{fig::run} generates a sub-task \lstinline{op_run1} if the guard associated to \lstinline{await} does not hold; the processor is released by the subsequent transition with the action \lstinline{finish} going back to the initial location.
This sub-task inherits the remaining deadline of the original task; this is done by the scheduler when handling the \lstinline{delegate} channel (see next subsection).
The enabling condition of the sub-tasks are equivalent to the guard used in the corresponding release point (see tables in Figure \ref{fig::run}).
The sub-task \lstinline{op_run1} can be triggered with the \lstinline{start} transition entering location 15.


In standard Creol, different invocations of a method call are associated with different values of the label. For instance executing the statement \lstinline twice results in two  instances of the label \lstinline . Dynamic labels give rise to an infinite state space for  non-terminating reactive systems.
To be able to use model checking, we treat every label as a static tag. Therefore, different invocations of a method call with the same label are not distinguished in our framework.
Alternatively, one could associate replies to message names, but this is too restrictive.
By associating replies to labels, we can still distinguish the same message sent from different methods with different labels.

We handle labels with a global boolean array \lstinline{labels}, and assuming that label names are unique in each class, we can define constants for each label such that \lstinline{labels[t][self]} uniquely identifies label .
When the condition in a release point includes \lstinline, i.e., waiting until the reply to the call with label  is available, we replace  with \lstinline{labels[t][self]} which is set to true by the scheduler when called method finishes.
For outgoing messages, the behavioral interface should capture when a reply is expected (cf. Definition \ref{def:behavioral_interface}).


Blocking statements use the \lstinline{wait} channel to transfer the control to the scheduler, which then can check whether the label is associated to a local call; thus it can decide whether to block the object or do a synchronous call.
To allow recursive synchronous calls, the \lstinline{wait} transition goes back to the initial state making the method reentrant, e.g., the transition from location 16 modeling the statement \lstinline{b?}.



Another complication in translation is how to map a possibly infinite state Creol model to finite state automata.
We do this by abstracting away some information. One automatic way of abstracting is as follows:  variables from a finite domain can be mapped to themselves but conditions on potentially infinite variables are mapped to true, we perform this with the function   in Figure \ref{fig::generation}. We do it semi-automatically, i.e., the user states which variables are abstracted away. In other words, we over-approximate the behavior of the Creol model. A more advanced abstraction would map potentially infinite variables to finite domains in order to narrow the over-approximation.







\subsection{Modeling schedulers}
\label{sec::scheduler}

\begin{figure}
\centering
 \includegraphics[scale=.9]{FOCLASA_scheduler}
 \caption{An Earliest-Deadline-First scheduler modeled in \Uppaal (details explained in the text).}
 \label{fig:scheduler}
\end{figure}

A scheduler manages the buffering and execution of the tasks.
A typical {\em scheduler automaton} is given in Figure \ref{fig:scheduler}.
A transition numbered  in this figure is referred to as  in the text.
This model is generic except for the strategy, explained below.
The keyword \lstinline{self} holds the current object identifier.
Local declarations including function definitions are not given due to space limitations.


\paragraph{Queue}
The queue has the size \lstinline.
A scheduler automaton uses multiple arrays of size \lstinline to implement the queue and its clocks. The message in \lstinline is received from object \lstinline; and, \lstinline points to a clock in array \lstinline that records how long the message has been in the queue: this message should be processed before the clock \lstinline reaches its deadline value \lstinline.
A clock \lstinline may be assigned to more than one task, the count of which is stored in \lstinline.
We have shown in \cite{Jaghoori09jlap} that schedulable objects need bounded queues, i.e., with a proper \lstinline value, queue overflow implies nonschedulability.
An \lstinline location is reachable when a queue overflow occurs () or a task in the queue explicitly misses its deadline ().
Support for parameters can be added with an array \lstinline such that \lstinline holds the \lstinlineth parameter of \lstinline.

\paragraph{Channels}
The \lstinline{start} channel is for starting execution of a task ( and ), which later gives up the processor with a signal on \lstinline{finish} channel (,  and ). The \lstinline{invoke} channel is for sending/receiving messages (async call);  generates a new task with the deadline given in the variable \lstinline{deadline} by putting the message name, sender and the associated label in the queue.
The \lstinline{delegate} channel generates a sub-task (), which inherits the deadline of the parent task.
A reply to an async call is reported on \lstinline{reply} channel ().
The blocking statement \lstinline  passes control to the scheduler using \lstinline{wait} channel (); this allows the scheduler to perform a synchronous call when needed. A blocked task is resumed using \lstinline{resume} channel ().
To avoid context-switch delays, \lstinline{start} and \lstinline{resume} defined urgent.


\paragraph{Start-up}
An object is initialized by putting `init' and `run' methods in its queue (), immediately followed by executing the `init' method ().
During `init', the object may receive other messages which are allowed to compete with the `run' method for execution.



\paragraph{Context-switch}
Tasks can have enabling conditions, which may include the availability of a reply, but does not depend on clock values. Therefore, we can define in \Uppaal\ a boolean function \lstinline to evaluate the enabling condition for each method when needed.
Whenever a task finishes, the scheduler selects another {\em enabled} task, based on its strategy (), sets \lstinline to point to this task, and executes it ().
There are two special cases: (1) the last task in the queue has just finished (); since \lstinline is zero and \lstinline gets \lstinline after \lstinline, the processor becomes idle until a new task arrives ().
(2) all remaining tasks in the queue are disabled (); \lstinline is set to \lstinline to block the processor. In this case, the object may be enabled either by receiving a new task () or receiving a reply signal (). The functions \lstinline{insertInvoke} and \lstinline{invokeReply} take care of these cases.

\paragraph{Labels}
The array \lstinline associates a boolean to each label. Upon completion of a method, the label used for its invocation is set to true in the \lstinline{shift} function (, , ). Since these transitions fire also at processor release points, the function \lstinline{shift} uses the variable \lstinline{complete}. This variable is true by default and will be reset to false at release points.

\paragraph{Synchronous call}
Executing the blocking \lstinline statement (\lstinline channel) on a remote call blocks the object until a reply is received. However, if \lstinline is associated to a local call, the scheduler will start the called method (modeling synchronous function call); upon termination of the called method, the scheduler will resume the blocked process (\lstinline channel). In order to allow nested synchronous invocations, each message in the queue stores a pointer to the caller method.
As explained in the next section, the blocked method goes back to its initial location allowing recursive synchronous function calls. Note that this recursion is bounded with the queue length.

\paragraph{Scheduling strategy}
The selection strategy is specified as a guard on . Parts of this guard ensure that we consider only non-empty queue elements (\lstinline) containing an enabled task (by calling \lstinline) different from the currently running one (\lstinline).
Figure \ref{fig:scheduler} compares the remaining deadline of task \lstinline, obtained by \lstinline, with other tasks in the queue; task \lstinline is selected when its deadline is strictly less than that of task \lstinline for \lstinline and less than or equal for \lstinline.
By replacing deadlines with a priori defined task priorities, we can model fixed-priority-scheduling.
By fixing \lstinline to zero, we obtain first-come-first-served strategy.
Nevertheless, the model is not restricted to these strategies.




\subsection{A Formal Encoding from Creol Syntax to Timed Automata}
\label{sec:formal}

We define this semantics in terms of a translation algorithm.
The input to this algorithm is a Creol model consisting of class and interface specifications.
The output is one \Uppaal\ model for each class; this \Uppaal\ model consists of only a set of timed automata templates (), one for each method, and the global declarations ().
The system declarations is not generated automatically, because it depends, among others, on the choice of scheduling strategy (cf. Section \ref {sec::analysis}).
We formally define the translation for a class: , where
{\small

}
Functions  and  return the user defined automata and their local declarations for the interface with the name .
All automata templates have as arguments:
{\small

}.
First we define automata templates for methods and later  in this section.


\begin{table}
{\small
\begin{tabular}{@{}p{.19\linewidth}|p{.33\linewidth}|p{.40\linewidth}}
Function & Input & Output \\ \hline
 & A method & A timed automaton \\ \hline
 &   A  Creol statement, two automata locations &
Part of a timed automaton (transitions, locations, invariants), set of enabling conditions \\\hline
&  A location in a method automaton & A Creol statement in the method body \\\hline
 & A guard & \Uppaal\ update statements\\\hline
 & Creol expression & \Uppaal\ expression\\ \hline
 & overloaded & label names \\ \hline
 & overloaded & method names  \\
\end{tabular}
}
\caption{Some functions used for translation}
\label{tab:function}
\end{table}




\begin{figure*}[tbp]
\begin{center}

\begin{tabular}{
@{\hspace{-5pt}} m{.59\linewidth} @{~~~~~}
m{.135\linewidth}  m{.015\linewidth}  m{.145\linewidth} m{.001\linewidth}
}


{\small

}
{\smallskip}
& &
\includegraphics [scale=\scaleIndex]{images/generation/method}
&&
\\\hline

\noalign{\medskip}


{\small

}
{\smallskip}
&
\includegraphics[scale=\scaleIndex]{generation/seqL} &
 &
~\includegraphics[scale=\scaleIndex]{generation/seqR} &

\\\hline
\noalign{\smallskip}


{\small

}
&
\includegraphics[scale=\scaleIndex]{generation/skipL} &
&
~\includegraphics[scale=\scaleIndex]{generation/skipR} &


{\smallskip}
\\\hline
\noalign{\smallskip}


{\small

}
&
\includegraphics[scale=\scaleIndex]{generation/assignmentL} &
&
~\includegraphics[scale=\scaleIndex]{generation/assignmentR} &


{\smallskip}
\\\hline
\noalign{\smallskip}


{\small

}
&
\includegraphics[scale=\scaleIndex]{generation/callL}
&

 &
\includegraphics[scale=\scaleIndex]{generation/callR}   
&


{\smallskip}
\\\hline
\noalign{\smallskip}



{\small

{\smallskip}
}
&
\includegraphics[scale=\scaleIndex]{generation/labelL}  &
 &
\includegraphics[scale=\scaleIndex]{generation/labelR} &


\\\hline
\noalign{\medskip}


{\small

{\smallskip}
}
&
\includegraphics[scale=\scaleIndex]{generation/blockL}  &
 &
\includegraphics[scale=\scaleIndex]{generation/blockR}&


\\\hline
\noalign{\medskip}


{\small

{\smallskip}
}
&
\includegraphics[scale=\scaleIndex]{generation/relL}
&  &
\includegraphics[scale=\scaleIndex]{generation/relR} &


\\\hline
\noalign{\medskip}


{\small

{\smallskip}
}
&
\includegraphics[scale=\scaleIndex]{generation/awaitgL}  &
 &
\includegraphics[scale=\scaleIndex]{generation/awaitgR} &


\\\hline
\noalign{\medskip}



{\small

{\smallskip}
}
&
\includegraphics[scale=\scaleIndex]{generation/ifL} &
~ &
\includegraphics[scale=\scaleIndex]{generation/ifR} &



\\\hline
\noalign{\medskip}



{\small

}
&
\includegraphics[scale=\scaleIndex]{generation/whileL}  &
 &
\includegraphics[scale=\scaleIndex]{generation/whileR} & 

\end{tabular}
\\
\end{center}
\caption{The rules for translating methods to timed automata. 
For each rule, we write only non-empty sets.
The union of two tuples is defined as  
}
\label{fig::generation}
\end{figure*}

 
\paragraph{Automata Templates}
The timed automata for each method is obtained using the function  defined in Figure \ref{fig::generation}.
For the translation of each method, the locations  and  refer to the unique locations representing the {\em initial} and {\em final} location of the method automaton, respectively.
The final location  is urgent and is connected to  to allow multiple incarnations of the method execution.

The partial function  assigns to the locations of a method automaton, their corresponding statements in the method body. This function is not defined for the  initial and the urgent final locations in the generated method automata. With each automaton corresponding to exactly one method, one can use this function to trace from automata back to methods.
In Figure \ref{fig::run}, this function is depicted as labels on locations, referring to line numbers in Figure \ref{fig::creolCode}.

The function  translates the statements  to a set of transitions  on locations  and with location invariants .  Processing  should start from the location  and finish at  (obviously  will contain  and ).
Additionally,  will correspond to a set of pairs , where  is the name of a sub-task (generated by a release point) with the enabling condition  (e.g., see tables in Figure \ref{fig::run}).


Given a method , the corresponding timed automaton is computed as shown in Figure~\ref{fig::generation} by computing , which uses the overloaded function  to compute the automaton transitions.
A cointerface given using  keyword is ignored.
The intuition behind the translation function is given on the right hand side of Figure~\ref{fig::generation} using a notation similar to graph transformation rules.


The translation uses some helper functions.
As explained in the scheduler, there is a global boolean array .
For every label  that is checked in guard ,  resets  to false.
 is the abstract of the expression or assignment  with proper renaming of the variables; the abstract must map the expressions to a finite domain, mapping everything to  is correct but not optimal.
If the domains of the variable are finite we can leave them unchanged, however if they are possibly infinite then we must approximate them.  The user of our translation can decide the exact approximation, as it will need to balance between state-space size and accuracy. A possible definition of these functions are:

{\footnotesize
\begin{tabular}{@{}l@{~~}l@{~~}l}
\6pt]
\end{tabular}
\begin{tabular}{l@{~~}l@{~~}l}
&=& \\
&&for variables  and labels .
\end{tabular}
}


Next, we explain two most complex rules with the example in Figure \ref{fig::run}.

\paragraph{ret.}
The statement \lstinline{t?} stops the current method and triggers the scheduler (on \lstinline{wait} channel). If \lstinline is associated to a local call, the scheduler immediately starts the called method (i.e., sync call). This can be a recursive call because the  rule moves the method to the initial location  (transition from 16 to  in  Figure \ref{fig::run}). If \lstinline refers to a remote call, the object is blocked (no method is executed). The caller is {\em resumed} when the callee has finished and a reply signal is available (transition from  to 17 in Figure \ref{fig::run}). Since the upper bound on this statement depends on the called methods, we can only express a lower bound (\lstinline{/*@b*/})  on its execution time.

\paragraph{crel.}
With the \lstinline{await g} statement, if \lstinline holds, the processor is not released and the method continues (e.g., transition 25 to 26 in  Figure \ref{fig::run}).
If \lstinline does not hold, control moves to the final location  (e.g., from location 25); therefore, the current task will finish. Instead, it generates a subtask \lstinline using the \lstinline channel (thus it inherits the deadline), with enabling condition \lstinline. The transition \lstinline defines the subtask \lstinline such that it will execute the rest of the original task (e.g., from  to 26).


\paragraph{Global Declarations}
In Figure \ref{fig::helper}, we define some helper functions we need for computing the global declarations  for `'.
To save space, we do not write the real-time execution information when not relevant for these function definitions.
We use   as a short hand to return the element  returned by  for .





\begin{figure}
\begin{center}

\begin{tabular}{@{~}l@{\hspace{-2cm}}l}
\\
\6pt]

 &
\\
{\small
\begin{tabular}{@{} l @{~} c @{~} l}
&&\\
&&\\
&&\\
&&\\
&&
\end{tabular}
}
&
{\small
\begin{tabular}{@{} l @{~} c @{~} l}
&&\\
&&\\
&&\\
&&\\
&&
\end{tabular}
}
\end{tabular}

\end{center}
\caption{Encoding helper functions. As parameter  represents other possibilities.}\label{fig::helper}
\end{figure}


Given a minimum , a maximum  and an initial value  for deadline,
the global declarations  are defined as follows.
The global declarations  consists of the following elements. For easier reading, we put them in a list. Treating each item as a set,  is formally defined as their union.
The functions ,  and  below produce unique integer values, starting from zero ( starts from 1) and incrementing by one every time they are called.


\begin{itemize}
\item global constants. The  function returns the number of elements in a set.\\
{\footnotesize
\verb+;+\\
\verb+;+\\
\verb+;+
}

\item  the global clock used by all method automata and the deadline variable. \\
{\footnotesize }

\item a unique number for each task and subtask. \\
{\footnotesize  }

\item a unique number for each label, and a boolean array. \\
{\footnotesize  }\\
{\footnotesize \verb}

\item an array for each variable, either a bool or an int.\\
{\footnotesize  }

\item a bool to indicate method completion, helping scheduler decide whether to issue a reply signal.\\
{\footnotesize \verb}

\item a unique number for each method called on the objects provided as arguments.\\
{\footnotesize  }

\item
the channels used by the scheduler.
{\footnotesize
\begin{verbatim}
chan delegate [MSG+1][nObj];
chan invoke [LBL+1][MSG+1][nObj][nObj];
urgent chan start [MSG+1][nObj];
chan finish[nObj];
chan wait[LBL+1][nObj];
urgent chan resume[LBL+1][nObj];
chan reply[LBL+1][nObj];
\end{verbatim}
}

\item code to help the scheduler start the tasks correctly. \\
{\footnotesize
\\
 for all  \}\\
 \\
\verb+}+
}





\end{itemize}


































\section{Analysis of Real-Time Objects}\label{sec::analysis}


The generated timed automata fit our automata-theoretic framework for modular schedulability analysis of asynchronous objects~\cite{Jaghoori09jlap,JaghouriDBC08RTSS}. The extensions to the original framework  are as follows.
Methods (and their corresponding messages) have enabling conditions.
The completion of each method is reported back to the caller with a reply signal; this enables modeling Creol synchronization mechanisms.
Static labels are used to match replies with their originating calls.
A blocking synchronization statement waiting for reply from a local call leads to a deadlock; instead, as in basic Creol, we transform this situation to the  synchronous execution of the called method.
On the generated timed automata, one can perform normal \Uppaal analyses like reachability; using the  function (see Table \ref{tab:function}), automata locations can be traced back to the original Creol code.
As the original framework is intended, one can perform schedulability analysis to check whether called methods can finish within the required deadlines.

\medskip
\noindent {\bf Schedulability Analysis}
An object  is an instance of a class together with a scheduler automaton.
An object is schedulable, i.e., all tasks finish within their deadlines,
 if and only if the scheduler cannot reach the \lstinline location with a queue length of ,
where  is the longest deadline for any method called on any transition of the automata and  is the shortest termination time of any of the method automata \cite{Jaghoori09jlap}.
However, schedulable objects usually need a much smaller queue length in practice.

We can analyze a closed system of multiple objects, but it may lead to state-space explosion.
We can avoid that by analyzing one object in isolation; the modular analysis is explained in detail in \cite{Jaghoori09jlap}.
In this case, we need to restrict the possible ways in which  the methods of this object could be called.
Therefore, we only consider the incoming method calls specified in its behavioral interfaces.
Receiving a message from another object (i.e., an input action in the behavioral interface) creates a new task (for handling that message) and adds it to the queue.
The behavioral interface does not capture (internal tasks triggered by) self calls.
To analyze the schedulability of an object, one needs to consider both the internal tasks and the tasks triggered by the (behavioral interface, which abstractly models the acceptable) environment.


If a class implements multiple interfaces, we check schedulability with all interfaces together.
Intuitively, that is because such a class should be able to take part in the protocols provided by these behavioral interfaces together. This is also the case in the coordinator example.
We can generate the possible behaviors of an object by making a network of timed automata consisting of its method automata, behavioral interface automaton  and a concrete scheduler automaton.



Once an object is verified to be schedulable with respect to its behavioral interface, it can be used as an off-the-shelf component. To ensure the schedulability of a system composed of individually schedulable objects, we need to make sure their real use is {\em compatible} with their expected use specified in the behavioral interfaces.
For the details of checking compatibility, we refer to our previous work \cite{Jaghoori09jlap,JaghouriDBC08RTSS}.




\paragraph{Example}
To be able to perform  analysis on an object in isolation, we need the behavioral interface specifications; we consider the specification in Figure~\ref {fig::periodicBeh}.
The behavioral interfaces, the methods and a scheduler automaton are put together in \Uppaal.
We verified this object for schedulability with an `earliest deadline first' strategy.
As a result, we found out that there must be at least an inter-arrival of \lstinline=25 time units (\lstinline in Figure~\ref {fig::periodicBeh}); with this inter-arrival time, the methods need a deadline of at least \lstinline=21 until synchronization is successful.
Methods \lstinline and \lstinline meet their given deadlines of 10 and 50.
In this case, we observe that no more than 7 queue slots is needed.
It is interesting that a jitter for each of the messages  causes nonschedulability, because in the long run, this message will be either too early or too late at some point for synchronization to take place in time.


We can furthermore model check the correctness of the algorithm.
First of all, we can check whether \lstinline{m1} can go through its both release points; this is done by checking the reachability of location marked 26 in \lstinline{m1} automaton.
Furthermore, we added counters for each method, counting the number of times it has synchronized. We can thus check whether, for instance, \lstinline can be in its third round, while \lstinline has performed only one round. To ensure that \lstinline is triggered fast enough, we add three instances of \lstinline at time zero.
We observe that such a scenario is indeed not possible.



\section{Conclusions and Future Work}
\label{sec:conc}
We bridge the gap between high-level declarative automata theory and object-orientation; we elevate scheduling that is normally deeply buried in deployment infrastructure up in high-level modeling.
Creol is a full-fledged object oriented modeling language
strong in formal modeling but the great amount of nondeterminism makes model checking impractical.
In this paper, we have extended Creol with real-time and the possibility of specifying scheduling strategies as a complementary feature; nondeterminism is reduced, among others, by specifying scheduling strategies.
We presented a timed-automata semantics, which can be used for verifying real-time properties and in particular schedulability and timed reachability.
This semantics supports features in Creol like processor release points, replies and synchronous method calls, multiple interfaces and loops.



To allow verification we only allow finite state models. We can put a bound on the length of the queues for schedulable systems; therefore using a finite queue length is not an issue.
However, abstracting possibly infinite variables to finite ones may lead to transitions that would not be possible in the original rewrite semantics of Creol. This can only add possible behaviors, with respect to the rewrite semantics, therefore if we say a Creol program meets its deadlines we can be sure that it does.

The automata model of a class consists of the following: one automaton for every method defined in the class, behavioral interfaces describing the overall input/output behavior and a scheduler automaton with the desired scheduling strategy. Using automata, behavioral interfaces can specify non-uniformly recurring tasks rather than for instance periodic tasks or using pessimistic approximations \cite{FersmanYi07acc}.






As further work, we are  looking into extending the original rewrite semantics of Creol with real-time for simulation purposes.
Instead of automatically generating automata from Creol, one may manually create abstract automata models corresponding to the Creol models, like \cite{BoerGJSY09}; to ensure schedulability of the corresponding Creol model, we will study conformance between Creol and timed automata.



\bibliographystyle{eptcs}
\bibliography{Mmajid}


\end{document}
