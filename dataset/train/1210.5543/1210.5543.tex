\pdfoutput=1
\documentclass[10pt]{article}

\usepackage[section]{placeins}

\usepackage[linesnumbered, ruled,vlined]{algorithm2e}
\usepackage{tikz}

\usepackage{bibspacing}
\setlength{\bibspacing}{\baselineskip}

\usepackage[paper=letterpaper,centering]{geometry}
\setlength{\topmargin}{-11mm}
\setlength{\textwidth}{139mm}
\setlength{\textheight}{205mm}


\usepackage{graphics}
\usepackage{lhelp}
\usepackage{bbm}
\usepackage{amsmath,amscd}
\usepackage{graphicx,pifont,color} \usepackage{url}
\usepackage{pstricks,pst-node,pst-grad,pst-plot}
\usepackage{amsfonts}
\usepackage{epsfig, color}
\usepackage{latexsym}
 \usepackage{amsthm}
\usepackage{multirow}
\usepackage{comment}
\usepackage{longtable}





\def\A {\ensuremath{\mathbb{A}}}
\def\B {\ensuremath{\mathbb{B}}}
\def\C {\ensuremath{\mathbb{C}}}
\def\I {\ensuremath{\mathcal{I}}}
\def\J {\ensuremath{\mathcal{J}}}
\def\K {\ensuremath{\mathbf{k}}}
\def\L {\ensuremath{\mathbf{c}}}
\def\N {\ensuremath{\mathcal{N}}}
\def\Q {\ensuremath{\mathbb{Q}}}
\def\R {\ensuremath{\mathbb{R}}}
\newcommand{\T}{\mathfrak{T}}
\newcommand{\G}{\mathfrak{C}}
\newcommand{\D}{\mathfrak{D}}
\def\Z {\ensuremath{\mathbb{Z}}}
\def\W {\ensuremath{\mathbf{W}}}
\def\KK {\ensuremath{\mathbf{K}}}
\def\var{\ensuremath{\mathbf{V}}}
\newcommand{\uu}{\mathbf{u}}
\newcommand{\xx}{\mathbf{x}}
\newcommand{\yy}{\mathbf{y}}
\def\u {\ensuremath{\mathbf{u}}}
\def\x {\ensuremath{\mathbf{x}}}
\def\y {\ensuremath{\mathbf{y}}}
\newtheorem{Algorithm}{Algorithm}
\newtheorem{Notation}{Notation}
\newtheorem{Theorem}{Theorem}
\newtheorem{Proposition}{Proposition}
\newtheorem{Definition}{Definition}
\newtheorem{Lemma}{Lemma}
\newtheorem{Corollary}{Corollary}
\newtheorem{Conjecture}{Conjecture}
\newtheorem{Remark}{Remark}
\newtheorem{Problem}{Problem}
\newtheorem{Example}{Example}
\def\SProof{\textsc{Sketch of proof.} }
\def\Proof{\textsc{Proof.} }
\def\foorp{\hfill}
\newcommand{\lc}[1]{\mbox{{\rm lc}}}
\newcommand{\lm}[1]{\mbox{{\rm lm}}}
\newcommand{\lt}[1]{\mbox{{\rm lt}}}

\newcommand{\disc}[1]{\mbox{{\rm disc}}}
\newcommand{\ideal}[1]{\langle#1\rangle}
\newcommand{\init}[1]{\mbox{{\rm init}}}
\newcommand{\iter}[1]{\mbox{{\rm res}}}
\newcommand{\mdeg}[1]{\mbox{{\rm mdeg}}}
\newcommand{\mvar}[1]{\mbox{{\rm mvar}}}
\newcommand{\prem}[1]{\mbox{{\rm prem}}}
\newcommand{\pquo}[1]{\mbox{{\rm pquo}}}
\newcommand{\rank}[1]{\mbox{{\rm rank}}}
\newcommand{\res}[1]{\mbox{{\rm res}}}
\newcommand{\ires}[1]{\mbox{{\rm res}}}
\newcommand{\sat}[1]{\mbox{{\rm sat}}}
\newcommand{\sep}[1]{\mbox{{\rm sep}}}
\newcommand{\head}[1]{\mbox{{\rm head}}}
\newcommand{\tail}[1]{\mbox{{\rm tail}}}
\newcommand{\coeff}[1]{\mbox{{\rm coeff}}}
\renewcommand{\min}[1]{\mbox{{\rm min}}}
\renewcommand{\max}[1]{\mbox{{\rm max}}}
\newcommand{\height}[1]{\mbox{{\rm height}}}
\newcommand{\NF}[1]{\mbox{{\rm NF}}}
\newcommand{\dsplit}{\mbox{}}
\newcommand{\Extend}[1]{\mbox{{\sf Extend}}}
\newcommand{\Regularize}[1]{\mbox{{\sf Regularize}}}
\newcommand{\RegularizeDimZero}[1]{\mbox{{\sf RegularizeDim0}}}
\newcommand{\WeakRegularizeDimZero}[1]{\mbox{{\sf WeakRegularizeDim0}}}
\newcommand{\IsInRadical}[1]{\mbox{{\bf IsInRadical}}}
\newcommand{\IsInSaturate}[1]{\mbox{{\bf IsInSaturate}}}
\newcommand{\Intersect}[1]{\mbox{{\sf Intersect}}}
\newcommand{\Triangularize}[1]{\mbox{{\sf Triangularize}}}
\newcommand{\RegularizeInitial}[1]{\mbox{{\sf MakeLeadingCoefficientInvertible}}}
\newcommand{\IntersectAlgebraic}[1]{\mbox{{\sf IntersectAlgebraic}}}
\newcommand{\SubresultantChain}[1]{\mbox{{\sf SubresultantChain}}}
\newcommand{\resultant}[1]{\mbox{{\sf resultant}}}
\newcommand{\RegularGcd}[1]{\mbox{{\sf Gcd}}}
\newcommand{\RegularizeList}[1]{\mbox{{\sf RegularizeList}}}
\newcommand{\RegularizeSingle}[1]{\mbox{{\sf RegularizeSingle}}}
\newcommand{\RegularizeFree}[1]{\mbox{{\sf RegularizeFree}}}
\newcommand{\RegularizeAlgebraic}[1]{\mbox{{\sf RegularizeAlgebraic}}}
\newcommand{\IntersectFree}[1]{\mbox{{\sf IntersectFree}}}
\newcommand{\CleanChain}[1]{\mbox{{\sf CleanChain}}}
\newcommand{\RegularOnly}[1]{\mbox{{\sf RegularOnly}}}
\newcommand{\Squarefree}[1]{\mbox{{\sf Squarefree}}}
\newcommand{\SquarefreeChain}[1]{\mbox{{\sf SquarefreeChain}}}
\newcommand{\SquarefreePart}[1]{\mbox{{\sf SquarefreePart}}}
\newcommand{\Equations}[1]{\mbox{{\sf Equations}}}
\newcommand{\PCTD}[1]{\mbox{{\bf PCTD}}}
\newcommand{\CTD}[1]{\mbox{{\bf CTD}}}
\newcommand{\MPD}[1]{\mbox{{\sf MPD}}}
\newcommand{\SMPD}[1]{\mbox{{\sf SMPD}}}
\newcommand{\PairRefine}[1]{\mbox{{\sf PairRefine}}}

\newcommand{\AXIOM}{{\tt \small AXIOM}}
\newcommand{\Aldor}{{\tt \small Aldor}}
\newcommand{\Maple}{{\sc  Maple}}
\newcommand{\rmaple}{{\tt rmaple}}
\newcommand{\Singular}{{\tt \small Singular}}
\newcommand{\CoCoA}{{\tt \small CoCoA}}
\newcommand{\MAGMA}{{\tt \small MAGMA}}
\newcommand{\Triade}{{\tt \small Triade}}
\newcommand{\RegularChains}{{\tt  Regu\-lar\-Chains}}
\newcommand{\CSTools}{{\tt \small Cons\-truc\-ti\-ble\-Set\-Tools}}
\newcommand{\PSTools}{{\tt \small Pa\-ra\-me\-tric\-Sys\-tem\-Tools}}
\newcommand{\CHTools}{{\tt \small Chain\-Tools}}


\newcommand{\sMPD}{\mbox{{\tt \small MPD}}}
\newcommand{\sSMPD}{\mbox{{\tt \small SMPD}}}

\newcommand{\Epsilon}{{\small \tt Epsilon}}
\newcommand{\Discoverer}{{\small \tt DISCOVERER}}
\newcommand{\WSolve}{{\tt \small WSolve}}
\newcommand{\DISCOVERER}{{\small \tt DISCOVERER}}
\newcommand{\DPGB}{{\small \tt DPGB}}
\newcommand{\DV}{{\small \tt DV}}
\newcommand{\QuasiAlgebraicSet}{{\small \tt QuasiAlgebraicSet}}
\newcommand{\RootFinding}{{\small \tt RootFinding[Parametric]}}
\newcommand{\SACGB}{{\small \tt SACGB}}
\newcommand{\CGB}{{\small \tt CGB}}
\newcommand{\rs}{{\em regular\_system}}
\newcommand{\rc}{{\em regular\_chain}}
\newcommand{\cs}{{\em constructible\_set }}
\def\zero{\ensuremath{Z}}


\def\x {\ensuremath{\mathbf{x}}}

\newcommand{\dpol}[1]{\mbox{{\rm dpol}}}
\newcommand{\mat}[1]{\mbox{{\rm mat}}}
\renewcommand{\red}[1]{\mbox{{\rm red}}}
\renewcommand{\gcd}[1]{\mbox{{\rm gcd}}}

\newcommand{\p}{\mathfrak{p}}
\def\DD {\ensuremath{\mathcal{D}}}
\def\LL {\ensuremath{\mathbb{L}}}
\def\TT {\ensuremath{T}}


\newcommand{\gcdb}[1]{\mbox{{\rm gcd}}}
\def\FL {\ensuremath{\mathfrak{L}}}
\def\CC {\ensuremath{\mathcal{C}}}
\newcommand{\Modpn}{{\sc Modpn}}
\newcommand{\FATools}{{\tt  Fast\-Arithmetic\-Tools}}
\newcommand{\der}[1]{\mbox{{\rm der}}}
\newcommand{\discrim}[1]{\mbox{{\rm discrim}}}
\def\FC {\ensuremath{\mathfrak{C}}}
\newcommand{\RefineTreeByPoly}[1]{\mbox{{\sf RefineTree}}}
\newcommand{\MakeSquarefree}[1]{\mbox{{\sf MakeSquarefree }}}
\newcommand{\level}[1]{\mbox{{\rm level}}}
\newcommand{\src}[1]{\mbox{{\rm src}}}
\newcommand{\CylindrizePoly}[1]{\mbox{{\rm CylindrizePoly}}}
\newcommand{\RegularizeCylindricalCell}[1]{\mbox{{\rm RegularizeCylindricalCell}}}
\newcommand{\MergeTree}[1]{\mbox{{\rm MergeTree}}}
\newcommand{\Project}[1]{\mbox{{\sf ExtractProjection}}}
\newcommand{\Merge}[1]{\mbox{{\sf Merge}}}
\newcommand{\IntersectMain}[1]{\mbox{{\sf IntersectMain}}}
\newcommand{\Initialize}[1]{\mbox{{\sf Initialize}}}
\newcommand{\CylindricalDecompose}[1]{\mbox{{\sf CylindricalDecompose}}}
\newcommand{\CoFactor}[1]{\mbox{{\sf CoFactor}}}
\newcommand{\Reali}[1]{\mbox{{\rm Reali}}}
\newcommand{\MakeClosed}[1]{\mbox{{\sf MakeDerivativeFactorClosed}}}
\newcommand{\MakeCoprime}[1]{\mbox{{\sf MakeCoprime}}}
\newcommand{\TowardsClosed}[1]{\mbox{{\sf TowardsDerivativeFactorClosed}}}
\newcommand{\PropagateTruthValue}[1]{\mbox{{\sf PropagateTruthValue}}}
\newcommand{\QuantifierElimination}[1]{\mbox{{\sf QuantifierElimination}}}
\newcommand{\MakeSemiAlgebraic}[1]{\mbox{{\sf MakeSemiAlgebraic}}}
\newcommand{\AttachTruthValue}[1]{\mbox{{\sf AttachTruthValue}}}
\newcommand{\ConstructSolutionFormula}[1]{\mbox{{\sf ConstructSolutionFormula}}}
\newcommand{\NextPathToDo}[1]{\mbox{{\sf NextPathToDo}}}
\newcommand{\Sign}[1]{\mbox{{\sf Sign}}}
\newcommand{\NextPath}[1]{\mbox{{\sf NextPath}}}
\newcommand{\NextChild}[1]{\mbox{{\sf NextChild}}}
\newcommand{\InheritTruthValue}[1]{\mbox{{\sf InheritTruthValue}}}
\newcommand{\GenerateSolutionFormula}[1]{\mbox{{\sf GenerateSolutionFormula}}}
\newcommand{\MakeProjectionDefinable}[1]{\mbox{{\sf MakeProjectionDefinable}}}


\newcommand{\ConflictingPairs}[1]{\mbox{{\sf ConflictingPairs}}}
\newcommand{\Update}[1]{\mbox{{\sf UpdatePath}}}

\def\EE {\ensuremath{\mathcal{E}}}

\newif\ifcomment
\commentfalse

\newcommand{\PCAD}{{\sc PCAD}}
\newcommand{\CCAD}{{PCAD}}
\newcommand{\TCAD}{{\sc TCAD}}
\newcommand{\IntersectPath}[1]{\mbox{{\sf IntersectPath}}}
\newcommand{\CAD}{{CAD}}
\newcommand{\QE}{{QE}}
\newcommand{\QEPCAD}{{\sc Qepcad}}
\newcommand{\QETCAD}{{\sc Qetcad}}

\begin{document}

\begin{center}
  {\Large\bf 
    An Incremental Algorithm for Computing Cylindrical Algebraic Decompositions
  }
\mbox{}\5pt] 
ORCCA, University of Western Ontario (UWO) \\
London, Ontario, Canada \\
{\tt \{cchen252,moreno\}@csd.uwo.ca}\
D_{i,j}=\{(\alpha,x_n)\in\KK^n\mid \alpha\in D_i 
\ {\rm and} \  p_{i,j}(\alpha,x_n)=0\},

\begin{array}{c}
\left\{
\begin{array}{c}
a(x_1) b(x_1) = 0 \\
c(x_1, x_2) = 0
\end{array}
\right., \  
\left\{
\begin{array}{c}
a(x_1) b(x_1) = 0 \\
d(x_1, x_2) = 0
\end{array}
\right., \
\left\{
\begin{array}{c}
a(x_1) b(x_1) = 0 \\
c(x_1, x_2) d(x_1, x_2) \neq 0
\end{array}
\right., \  
\left\{
\begin{array}{c}
a(x_1) b(x_1) \neq 0 \\
\end{array}
\right.
\end{array}

\left\{
\begin{array}{c}
a(x_1) = 0 \\
c(x_1, x_2) = 0
\end{array}
\right., \  {\rm and} \ 
\left\{
\begin{array}{c}
b(x_1) = 0 \\
c(x_1, x_2) = 0.
\end{array}
\right.

\left\{
\begin{array}{c}
a(x_1) = 0 \\
d(x_1, x_2) = 0
\end{array}
\right., \  {\rm and} \ 
\left\{
\begin{array}{c}
b(x_1) = 0 \\
d(x_1, x_2) = 0.
\end{array}
\right.

{\sf IntersectMain}_n\rightarrow{\sf Squarefree_n}
\rightarrow{\sf IntersectMain}_{n-1}\rightarrow\cdots,

{\sf IntersectMain}_n\rightarrow{\sf Gcd_n}
\rightarrow{\sf IntersectMain}_{n-1}\rightarrow\cdots

T := \left\{
\begin{array}{ll}
{x = 0}  & \left\{
        \begin{array}{rcl}
         {y = 0}   &:& { y^2+x=0}\\
         y\neq 0 &:& { y^2+x\neq0}
        \end{array}
        \right.\\
&\\
x\neq 0& \left\{
        \begin{array}{rcl}
         y^2+x = 0   &:& { y^2+x=0} \\
         y^2+x\neq 0 &:& { y^2+x\neq0}
        \end{array}
        \right.\\ 
\end{array}
\right.

\left\{
\begin{array}{ll}
{ x = 0}  & \left\{
        \begin{array}{rcl}
         {y = 0}   &:& { y^2+x=0}\\
         { y = -1}  &:& { y^2+x\neq0\wedge y^2+y=0}\\
         { \rm otherwise} &:& { y^2+x\neq0\wedge y^2+y\neq 0}\\
        \end{array}
        \right.\\
&\\
x\neq 0& \left\{
        \begin{array}{rcl}
         y^2+x = 0   &:& { y^2+x=0} \\
         y^2+x\neq 0 &:& { y^2+x\neq0}
        \end{array}
        \right.\\ 
\end{array}
\right.

T := \left\{
\begin{array}{ll}
x < 0  & \left\{
        \begin{array}{lcl}
         y < -\sqrt{|x|}   &:& { y^2+x>0}\\
         y = -\sqrt{|x|}   &:& { y^2+x=0}\\
         y > -\sqrt{|x|}\wedge y<\sqrt{|x|}   &:& { y^2+x<0}\\
         y = \sqrt{|x|}   &:& { y^2+x=0}\\
         y > \sqrt{|x|}   &:& { y^2+x>0}
        \end{array}
        \right.\\
&\\
x = 0  & \left\{
        \begin{array}{rcl}
         y <0    &:& { y^2+x>0}\\
         y = 0   &:& { y^2+x=0}\\
         y > 0 &:& { y^2+x>0}
        \end{array}
        \right.\\
&\\
x> 0&   \;{\rm for~ any~}y\,  :\;\, { y^2+x > 0}
\end{array}
\right.
PF := (Q_{k+1}x_{k+1}\cdots Q_nx_n)FF(x_1,\ldots,x_n), be 
a prenex formula, where  is a DNF formula. 
To perform {\QE} by {\CAD},
 the first computation step is to collect all the polynomials 
appearing in  as a polynomial set  and compute an -invariant CAD of .
This process of computing an -invariant CAD  exhausts all possible sign combinations of , 
including those which do not appear in , 
and thus often computes much more than needed for solving the input QE problem.
Different techniques in the literature have been proposed for taking advantage of the structure of the input problem.
These methods include partial CAD~\cite{ch91} for lazy lifting, 
simplified projection operator for handling pure strict inequalities~\cite{scott93,adam00}, 
smaller projection sets for making use of equational constraints~\cite{Collins98, McCallum2001, Brown05, McCallum2009}.


To make the discussion clear, we first quote a paragraph of~\cite{Brown05}.
``The idea is as follows: if an input formula includes the constraint , 
then decompose  into regions in which  has invariant sign, 
and then refine the decomposition so that the other polynomials 
have invariant sign in those cells in which . 
The signs of the other polynomials in cells in which  are, 
after all, irrelevant. 
Additionally, the method of equational constraints seeks 
to deduce and use constraints that are not explicit in the input 
formula, but rather arise as consequences of two or more explicit
constraints (e.g. if  and  are explicit constraints, 
then  is also a constraint.)''

This idea, of course, is attractive.
Much progress on it has also been made. 
However, the reason why it is a generally hard problem 
for CAD is that the framework of {\CCAD} does not have 
much flexibility to allow propagation of equational constraints. 
In the world of {\CCAD}, one always tries to obtain a generic 
projection operator and then applies the same projection operator 
recursively. To obtain a generic projection operator 
for handling equational constraints is hard
because many problems inherently require different projection operators
during projection. 
Therefore case discussion is important.

In fact, case discussion is very common in algorithms for computing 
triangular decompositions.
For such algorithms, equational constraints are natural input of these algorithms. 
The two keys ideas ``splitting only above '' and  ``if  and  are explicit constraints, 
then  is also a constraint'' have already been systematically 
taken care of in the {\sf Intersect} operation of the authors' paper
for  computing triangular decompositions~\cite{CM11}.

Next we explain how to modify algorithms presented in Section~\ref{sec:incremental} to 
automatically implement these ideas.

Suppose now that the input of Algorithm {\sf CylindricalDecompose} is a 
system of equations or inequations, 
this algorithm will then compute a partial cylindrical tree 
such that its zero set is exactly the zero set of input system.
This can be simply achieved by passing an equation or inequation 
to the function {\sf Intersect}.
W.l.o.g., let us assume that an equation  is passed as 
an argument of {\sf Intersect}.
Then for this function and all its called subroutines, 
we will cut the computation branches above which  is known to be nonzero 
and never proceed with computation branches above which  cannot be zero.
For example, we will not create a new vertex at step  
in Algorithm {\sf IntersectMain}.
We will delete the vertex  at step , ,  since  is nonzero on .

The first important optimization in {\sf IntersectMain} which can be implemented 
is to avoid {\sf Squarefree} computation at step  if 
is an equational constraint.
This idea is quite close to ``splitting only above ''.
Another important optimization can be done 
at step  of {\sf IntersectMain}. 
Assume that  is an equational constraint , 
then when {\sf Gcd} is called, 
in step  of Algorithm~\ref{Algo:Gcdi},
we can do as follows. 
If , then  is the resultant of  and .
Thus we should pass  to the {\sf IntersectPath} operation
in order to avoid useless computations 
on the branch .
This addresses the idea ``if  and  are explicit constraints, 
then  is also a constraint.''
Moreover, these optimizations are systematically performed during the whole 
computation.

Next we briefly mention several other important optimizations.
Let  be a leaf of a path  of a cylindrical tree. 
Assume that  is of the form  or of  the form  .
We can safely replace  by its primitive part since 
is invertible modulo . 
Replacing  by its irreducible factors over  is often a 
more efficient choice.
Last but not least,
recall that a path  in the cylindrical tree is a simple system.
Writing  as two parts , where  is 
a set of equations and  is a set of inequations. 
We know that  is a regular chain and  is a squarefree regular system. 
Thus the Zariski closure of  is the variety of the saturated ideal of .
We can call the pseudo division operation  or 
to test whether  or  is zero modulo . 
And sometimes replacing  by  and  by 
also ease the computations.

\begin{Example}
Let  be a system of equations. 
Taking  as input, Algorithm {\sf CylindricalDecompose} generates the 
following partial cylindrical tree  of  such that the zero set of 
is exactly the union of the zero sets of the paths in .
\begin{figure}[htbp]
\begin{center}
\scalebox{0.4}{\begin{picture}(0,0)\includegraphics{tree-eqs.pdf}\end{picture}\setlength{\unitlength}{6216sp}\begingroup\makeatletter\ifx\SetFigFontNFSS\undefined \gdef\SetFigFontNFSS#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(2952,2862)(2956,-2137)
\put(3331,-781){\makebox(0,0)[lb]{\smash{{\SetFigFontNFSS{25}{30.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2971,-2041){\makebox(0,0)[lb]{\smash{{\SetFigFontNFSS{25}{30.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5446,-781){\makebox(0,0)[lb]{\smash{{\SetFigFontNFSS{25}{30.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5131,-2041){\makebox(0,0)[lb]{\smash{{\SetFigFontNFSS{25}{30.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture}  }
\caption{A partial cylindrical tree  adapted to }
\label{fig:tree-eqs}
\end{center}
\end{figure}
\end{Example}


\section{Benchmark}
\label{sec:benchmark}
In this section, we report on the experimental results 
of a preliminary implementation 
in the {\RegularChains} 
library of {\Maple} of the algorithms of Sections~\ref{sec:incremental}
and \ref{sec:cad}.

The examples in Table~\ref{table:cd} and Table~\ref{table:cad}
are from papers on polynomial system solving,
such as~\cite{CGLMP07,BoulierChenLemaireMorenoMaza09}
and the references therein.
All the tests were launched
on a machine with Intel Core 2 Quad {\small CPU} (2.40{\small GHz}) 
and 8.0{\small Gb} total memory.
The time-out is set as  hour.
In the tables, the symbol  means time-out.

The {\Maple} functions are launched in {\Maple}~15
with the latest {\RegularChains} library.
The memory usage is limited to  of total memory.
The software {\QEPCAD} is launched with the option , 
where the first option specifies the memory to be pre-allocated 
(about  of total memory for our machine)
and the second option specifies the number of prime numbers to be used.


\begin{table}
\centering
\caption{Timings for computing cylindrical decomposition of the complex space}
\label{table:cd}
\begin{tabular}{|c|c|c|c||c|c|c|c|}\hline
System             & tcd-rec & tcd-inc & tcd-eqs & System & tcd-rec & tcd-inc & tcd-eqs \\ \hline
AlkashiSinus & 	  3373.966 & 	  14.568 & 	  4.168 &MontesS10 &  	  &  	  & 	  2.952 \\
Alonso & 	  9.636 & 	  1.404 & 	  0.700 &MontesS12 &  	  &  	  & 	  7.528 \\
Arnborg-Lazard-rev & 	  2759.940 & 	  2419.543 & 	  16.233 &MontesS15 &  	  &  	  & 	  77.048 \\
Barry & 	  39.346 & 	  1.808 & 	  0.556 &MontesS16 &  	  &  	  & 	  8.228 \\
blood-coagulation-2 & 	  235.310 & 	  9.472 & 	  0.808 &MontesS4 & 	  556.390 & 	  102.122 & 	  0.488 \\
Bronstein-Wang & 	  255.427 & 	  35.990 & 	  1.120 &MontesS5 & 	  1449.810 & 	  119.059 & 	  1.004 \\
cdc2-cyclin &  	  & 	  68.920 & 	  65.976 &MontesS7 &  	  &  	  & 	  1.060 \\
circles & 	  276.389 & 	  2.280 & 	  0.520 &MontesS9 & 	  269.636 & 	  4.212 & 	  0.980 \\
genLinSyst-3-2 & 	  916.245 & 	  19.537 & 	  1.384 &nql-5-4 &  	  & 	  1.056 & 	  0.528 \\
genLinSyst-3-3 &  	  & 	  160.406 & 	  12.408 &r-5 & 	  68.364 & 	  3.232 & 	  0.876 \\
Gerdt &  	  &  	  & 	  1.188 &r-6 & 	  1456.883 & 	  46.458 & 	  1.200 \\
GonzalezGonzalez & 	  141.072 & 	  53.451 & 	  0.732 &Raksanyi & 	  1471.351 & 	  118.227 & 	  1.000 \\
hereman-2 &  	  & 	  40.042 & 	  0.908 &Rose &  	  & 	  51.855 & 	  1.072 \\
lhlp5 & 	  31.069 & 	  3.984 & 	  0.648 &Wang93 &  	  &  	  & 	  18.877 \\
Maclane &  	  &  	  & 	  6.420 &YangBaxterRosso & 	  54.895 & 	  1.560 & 	  0.844 \\
\hline
\end{tabular}
\end{table}

\begin{table}
\centering
\caption{Timings for computing {\CAD}}
\label{table:cad}
\begin{tabular}{|c|c|c|c|c|c|}\hline
System & qepcad & qepcad-eqs & mathematica-eqs & tcad & tcad-eqs\\ \hline
Alonso & 7.516 & 5.284 & 0.74& 	  61.591 & 	  5.776 \\
Arnborg-Lazard-rev & & & 0.952&  	  & 	  17.325 \\
Barry & Fail& 216.425 & 0.032& 	  8.580 & 	  1.004 \\
blood-coagulation-2 &  &  & & 	  985.709 & 	  7.260 \\
Bronstein-Wang &  &  & 26.726& 	  333.892 & 	  2.564 \\
cdc2-cyclin &  &  & 0.208& 	  574.127 & 	  503.863 \\
circles & 21.633 & 5.996 & 41.211&  	  & 	  40.902 \\
GonzalezGonzalez & 10.528 & 10.412 & 0.012& 	  214.213 & 	  1.136 \\
lhlp2 & 960.756 & 5.076 & 0.016& 	  3.124 & 	  0.952 \\
lhlp5 & 10.300 & 10.068 & 0.016& 	  35.338 & 	  1.084 \\
MontesS4 &   &  & 0.004& 	  2682.391 & 	  0.888 \\
MontesS5 & Fail & Fail & &  	  & 	  9.400 \\
nql-5-4 & 93.073 & 5.420 & 1303.07& 	  113.675 & 	  1.004 \\
r-5 & & 1802.676 & 0.016& 	  1282.928 & 	  1.208 \\
r-6 & &  & 0.024&  	  & 	  1.500 \\
Rose & Fail&   & & 	  606.361 & 	  3.136 \\
AlkashiSinus &                     &                     & 2.232&  	  & 	  58.775 \\
genLinSyst-3-2 &   Fail     &   Fail    & 217.062& 	  3013.764 & 	  6.588 \\
MontesS10 &    &    & &  	  & 	  22.797 \\
MontesS12 &   &   & &  	  & 	  330.996 \\
MontesS15 & & & 0.004&  	  & 	  395.964 \\
MontesS7 &  & & 245.807&  	  & 	  2.452 \\
MontesS9 &Fail & Fail & & 	  110.902 & 	  4.944 \\
Wang93 & Fail& Fail& &  	  & 	  152.673 \\

\hline
\end{tabular}
\end{table}



In Table~\ref{table:cd}, we report on timings 
for computing cylindrical decomposition of the complex space
with different algorithms and options.
Each input system is a set of polynomials.
The notation tcd-rec denotes an 
implementation of the original recursive algorithm in~\cite{CMXY09},
while the notation tcd-inc denotes the incremental algorithm
presented in Section~\ref{sec:incremental}.
Both  tcd-rec and tcd-inc take a set of polynomials as input. 
The notation tcd-eqs refers to an optimized version of 
tcd-inc which makes use of equational constraints, as 
explained in Section~\ref{sec:equation}.
With the implementation tcd-eqs, every input polynomial set
is regarded as a set of equations (equating each input polynomial
to zero).
As we can see in Table~\ref{table:cd}, the incremental algorithm presented 
in this paper is much more efficient than the original recursive algorithm. 
The timings of tcd-eqs show that the optimizations
presented in Section~\ref{sec:equation}
for making use of equational constraints are very effective.


In Table~\ref{table:cad}, we report on timings 
for computing {\CAD} with three different computer algebra
packages: {\QEPCAD}, the {\sf CylindricalDecomposition} command 
of {\sf Mathematica} and the algorithm
presented in Section~\ref{sec:incremental}.
Each system is a set of polynomials.
Two categories of experimentation are conducted.
The first category is concerned with the timings 
for computing a full {\CAD} of a set of polynomials.
For {\sf Mathematica}, we cannot find
any options of {\sf CylindricalDecomposition} 
for computing a full {\CAD} of a set of 
polynomials.
Therefore for this category, 
only the timings of {\QEPCAD} and {\TCAD} are reported.
The second category is concerned with 
the timings for computing a {\CAD} of a variety.
For this category, the timings for {\QEPCAD}, {\sf Mathematica}
and {\sf TCAD} are all reported.


The notation qepcad denotes computations 
that {\QEPCAD} performs by (1) treating each input system as a set of 
non-strict inequalities and, (2) treating all variables as free 
variables and, (3) executing with the ``full-cad'' option.
The notation tcad corresponds to computations that {\TCAD}
performs by (1) treating each input system as a set of 
non-strict inequalities and,
(2) computing a sign invariant full {\CAD} of 
polynomials in the input system and, 
(3) selecting the cells which satisfy those non-strict inequalities. 
In this way, both qepcad and {\TCAD} compute a full {\CAD} of a set of 
polynomials.


The notation qepcad-eqs denotes the computations 
that {\QEPCAD} performs by (1) treating each input system as a set of 
equations and, (2) treating all variables as free 
variables and, (3) executing with the default option.
The notation mathematica-eqs represents
computations where the {\sf CylindricalDecomposition} command 
of {\sf Mathematica} treats each input system as a set of equations.
The notation tcad-eqs corresponds to  computations where {\TCAD}
treats each input system as a set of equations.

From Table~\ref{table:cad}, we make the following observations.
When full {\CAD}s are computed, within one hour time limit, 
{\QEPCAD} only succeeds on  out of  examples while
{\TCAD} succeeds on  out of  examples. 
When {\CAD}s of varieties are computed, 
for all the  out of  examples that {\QEPCAD}
can solve within one hour time limit, 
both {\sf Mathematica} and {\sf TCAD}
succeed with usually less time. 
For the rest  examples, {\sf TCAD}
solves all of them while {\sf Mathematica} 
only succeeds on  of them.


\section{Conclusion}
In this paper, we present an incremental algorithm for computing CADs.
A key part of the algorithm is an {\sf Intersect} 
operation for refining a given complex cylindrical tree. 
If this operation is supplied with an equational constraint,
it only computes a partial cylindrical tree, which 
provides an automatic solution for propagating equational constraints.
We have implemented our algorithm in {\sc Maple}. 
The experimentation 
shows that the new algorithm is much more efficient than
our previous recursive algorithm. 
We also compared our implementation with the software packages 
{\QEPCAD} and {\sf Mathematica}. 
For many examples, our implementation outperforms the other two. 
This incremental algorithm can support quantifier elimination. 
We will present this work in a future paper.

\section*{Acknowledgments} 
The authors would like to thank the
readers who helped improve the earlier versions 
of this paper.
This research was supported by 
Academic Development Fund ADF-Major-27145
of The University of Western Ontario.


\bibliographystyle{plain}
\begin{thebibliography}{10}

\bibitem{Arnon84b}
D.~S. Arnon, G.~E. Collins, and S.~McCallum.
\newblock Cylindrical algebraic decomposition {II}: an adjacency algorithm for
  the plane.
\newblock {\em SIAM J. Comput.}, 13(4):878--889, 1984.

\bibitem{Thomas10}
T.~B\"{a}chler, V.~Gerdt, M.~Lange-Hegermann, and D.~Robertz.
\newblock Thomas decomposition of algebraic and differential systems.
\newblock In {\em Proc. of CASC'10}, pages 31--54, 2010.

\bibitem{BoulierChenLemaireMorenoMaza09}
F.~Boulier, C.~Chen, F.~Lemaire, and M.~{Moreno Maza}.
\newblock Real root isolation of regular chains.
\newblock In {\em Proc. of {ASCM'09}}, pages 15--29, 2009.

\bibitem{brown01}
C.~W. Brown.
\newblock Improved projection for cylindrical algebraic decomposition.
\newblock {\em J. Symb. Comput.}, 32(5):447--465, 2001.

\bibitem{Bro03}
C.~W. Brown.
\newblock {\sc qepcad b}: a program for computing with semi-algebraic sets
  using {CAD}s.
\newblock {\em SIGSAM Bull.}, 37(4):97--108, 2003.

\bibitem{BrownDavenport2007}
C.~W. Brown and J.~H. Davenport.
\newblock The complexity of quantifier elimination and cylindrical algebraic
  decomposition.
\newblock In {\em Proc. ISSAC'07}, pages 54--60.

\bibitem{Brown05}
C.~W. Brown and S.~McCallum.
\newblock On using bi-equational constraints in {CAD} construction.
\newblock In {\em ISSAC'05}, pages 76--83, 2005.

\bibitem{BH91}
B.~Buchberger and H.~Hong.
\newblock Speeding-up quantifier elimination by {Gr\"{o}bner} bases.
\newblock Technical Report 91-06, {RISC} (Research Institute for Symbolic
  Computation), Johannes Kepler University, Linz, Austria, February 1991.

\bibitem{CavinesJohnson98}
B.~Caviness and J.~Johnson, editors.
\newblock {\em Quantifier Elimination and Cylindical Algebraic Decomposition,
  Texts and Mongraphs in Symbolic Computation}.
\newblock Springer, 1998.

\bibitem{Chen11}
C.~Chen.
\newblock {\em {Solving Polynomial Systems via Triangular Decomposition}}.
\newblock PhD thesis, University of Western Ontario, 2011.

\bibitem{CGLMP07}
C.~Chen, O.~Golubitsky, F.~Lemaire, M.~{{Moreno Maza}}, and W.~Pan.
\newblock Comprehensive triangular decomposition.
\newblock In {\em {Proc. of CASC'07}}, volume 4770 of {\em Lecture Notes in
  Computer Science}, pages 73--101. Springer Verlag, 2007.

\bibitem{CM11}
C.~Chen and M.~{Moreno Maza}.
\newblock Algorithms for computing triangular decompositions of polynomial
  systems.
\newblock In {\em Proc. of ISSAC'11}, pages 83--90, 2011.

\bibitem{CM12}
C.~Chen and M.~{Moreno Maza}.
\newblock Algorithms for computing triangular decomposition of polynomial
  systems.
\newblock {\em Journal of Symbolic Computation}, 47(6):610 -- 642, 2012.

\bibitem{CMXY09}
C.~Chen, M.~{Moreno Maza}, B.~{Xia}, and L.~Yang.
\newblock Computing cylindrical algebraic decomposition via triangular
  decomposition.
\newblock In {\em ISSAC'09}, pages 95--102, 2009.

\bibitem{col75}
G.~E. Collins.
\newblock Quantifier elimination for real closed fields by cylindrical
  algebraic decomposition.
\newblock {\em Springer Lecture Notes in Computer Science}, 33:515--532, 1975.

\bibitem{Collins98}
G.~E. Collins.
\newblock Quantifier elimination by cylindrical algebraic decomposition -
  twenty years of progress.
\newblock In B.~Caviness and J.~Johnson, editors, {\em Quantifier Elimination
  and Cylindrical Algebraic Decomposition}, pages 8--23. Springer, 1998.

\bibitem{ch91}
G.~E. Collins and H.~Hong.
\newblock Partial cylindrical algebraic decomposition.
\newblock {\em Journal of Symbolic Computation}, 12(3):299--328, 1991.

\bibitem{Collins02}
G.~E. Collins, J.~R. Johnson, and W.~Krandick.
\newblock Interval arithmetic in cylindrical algebraic decomposition.
\newblock {\em J. Symb. Comput.}, 34(2):145--157, 2002.

\bibitem{DMSWX05a}
X.~{Dahan}, M.~{{Moreno Maza}}, {\'E}.~{Schost}, W.~{Wu}, and Y.~{Xie}.
\newblock Lifting techniques for triangular decompositions.
\newblock In {\em ISSAC'05}, pages 108--115. ACM Press, 2005.

\bibitem{Dolzmann04}
A.~Dolzmann, A.~Seidl, and T.~Sturm.
\newblock Efficient projection orders for {CAD}.
\newblock In {\em Proc. ISSAC '04}, pages 111--118. ACM, 2004.

\bibitem{Dolzmann96}
A.~Dolzmann and T.~Sturm.
\newblock Redlog computer algebra meets computer logic.
\newblock {\em ACM SIGSAM Bulletin}, 31:2--9, 1996.

\bibitem{Ducos00}
L.~Ducos.
\newblock Optimizations of the subresultant algorithm.
\newblock {\em {Journal of Pure and Applied Algebra}}, 145:149--163, 2000.

\bibitem{hong90}
H.~Hong.
\newblock An improvement of the projection operator in cylindrical algebraic
  decomposition.
\newblock In {\em ISSAC '90}, pages 261--264. ACM, 1990.

\bibitem{QEPCAD}
H.~{Hong {\it et al.}}
\newblock {QEPCAD B}, \url{www.usna.edu/Users/cs/qepcad/}.

\bibitem{Iwane09}
H.~Iwane, H.~Yanami, H.~Anai, and K.~Yokoyama.
\newblock An effective implementation of a symbolic-numeric cylindrical
  algebraic decomposition for quantifier elimination.
\newblock In {\em Proc. of SNC'2009}, pages 55--64, 2009.

\bibitem{scott88}
S.~McCallum.
\newblock An improved projection operation for cylindrical algebraic
  decomposition of 3-dimensional space.
\newblock {\em J. Symb. Comput.}, 5(1-2):141â€“--161, 1988.

\bibitem{scott93}
S.~McCallum.
\newblock Solving polynomial strict inequalities using cylindrical algebraic
  decomposition.
\newblock {\em The Computer Journal}, 36(5):432--438, 1993.

\bibitem{scott98}
S.~McCallum.
\newblock An improved projection operator for cylindrical algebraic
  decomposition.
\newblock In B.~Caviness and J.~Johnson, editors, {\em Quantifier Elimination
  and Cylindical Algebraic Decomposition, Texts and Mongraphs in Symbolic
  Computation}. Springer, 1998.

\bibitem{McCallum2001}
S.~McCallum.
\newblock On propagation of equational constraints in {CAD}-based quantifier
  elimination.
\newblock In {\em Proc. of ISSAC '01}, pages 223--231, 2001.

\bibitem{McCallum2009}
S.~McCallum and C.W. Brown.
\newblock On delineability of varieties in {CAD}-based quantifier elimination
  with two equational constraints.
\newblock In {\em Proc. of ISSAC '09}, pages 71--78, 2009.

\bibitem{Mis93}
B.~Mishra.
\newblock {\em Algorithmic Algebra}.
\newblock Springer-Verlag, New York, 1993.

\bibitem{moreno00}
M.~{{Moreno Maza}}.
\newblock On triangular decompositions of algebraic varieties.
\newblock Technical Report TR {4/99}, NAG Ltd, Oxford, UK, 1999.
\newblock http://www.csd.uwo.ca/moreno.

\bibitem{adam00}
A.~Strzebo\'{n}ski.
\newblock Solving systems of strict polynomial inequalities.
\newblock {\em J. Symb. Comput.}, 29(3):471--480, 2000.

\bibitem{adam06}
A.~Strzebo\'{n}ski.
\newblock Cylindrical algebraic decomposition using validated numerics.
\newblock {\em Journal of Symbolic Computation}, 41(9):1021 -- 1038, 2006.

\bibitem{Strzebonski2010a}
A.~Strzebo\'nski.
\newblock {Computation with Semialgebraic Sets Represented by Cylindrical
  Algebraic Formulas}.
\newblock In {\em Proc. of ISSAC'2010}, pages 61--68, 2010.

\bibitem{Thomas37}
J.~M. Thomas.
\newblock {\em {Differential System}}.
\newblock American Mathematical Society, New York, 1937.

\bibitem{Wang98a}
D.~M. Wang.
\newblock Decomposing polynomial systems into simple systems.
\newblock {\em J. Symb. Comp.}, 25(3):295--314, 1998.

\bibitem{Wang00}
D.~M. Wang.
\newblock Computing triangular systems and regular systems.
\newblock {\em J. Sym. Comp.}, 30(2):221--236, 2000.

\bibitem{WBD12}
D.J. Wilson, R.J. Bradford, and J.H. Davenport.
\newblock Speeding up cylindrical algebraic decomposition by {Gr{\"o}bner}
  bases.
\newblock In {\em AISC/MKM/Calculemus}, pages 280--294, 2012.

\end{thebibliography}


\end{document}
