\documentclass[11pt]{article}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{url}

\parindent0cm
\parskip 9pt plus 2pt minus 1pt

\newcommand{\2}{\vspace{0.2 cm}}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{example}[theorem]{Example}

\newcommand\eps{\varepsilon}
\newcommand\cA{\mathcal{A}}
\newcommand\cB{\mathcal{B}}
\newcommand\cC{\mathcal{C}}
\newcommand\cE{\mathcal{E}}
\newcommand\cF{\mathcal{F}}
\newcommand\Prob{\mathbb{P}}
\newcommand\co{\mathrm{co}}
\newcommand\sco{\mathcal{CO}}
\newcommand\cc{\mathrm{cc}}
\newcommand\scc{\mathcal{CC}}

\newcommand\cs{{}}

\begin{document}
\date{\today}
\title{Algorithms for Generating Convex Sets in Acyclic Digraphs}
\author{P. Balister\thanks{Department of Mathematical Sciences,
University of Memphis, TN 38152-3240, USA. E-mail:
pbalistr@memphis.edu} \and S. Gerke\thanks{Department of Mathematics, Royal Holloway,
University of London, Egham, TW20 0EX, UK, E-mail:
stefanie.gerke@rhul.ac.uk} \and G. Gutin\thanks{Department of Computer Science, Royal Holloway,
University of London, Egham, TW20 0EX, UK, E-mail:
gutin@cs.rhul.ac.uk}\and A. Johnstone \thanks{Department of Computer Science, Royal Holloway,
University of London, Egham, TW20 0EX, UK, E-mail:
adrian@cs.rhul.ac.uk} \and J. Reddington\thanks{Department of Computer Science, Royal Holloway,
University of London, Egham, TW20 0EX, UK, E-mail:
joseph@cs.rhul.ac.uk} \and E. Scott\thanks{Department of Computer Science, Royal Holloway,
University of London, Egham, TW20 0EX, UK, E-mail:
eas@cs.rhul.ac.uk}\and A. Soleimanfallah\thanks{Department of Computer Science, Royal Holloway,
University of London, Egham, TW20 0EX, UK, E-mail:
arezou@cs.rhul.ac.uk} \and A. Yeo\thanks{Department of Computer Science, Royal Holloway,
University of London, Egham, TW20 0EX, UK, E-mail:
anders@cs.rhul.ac.uk}}

\maketitle

\begin{abstract}
A set  of vertices of an acyclic digraph  is convex if  and there is no directed path between vertices of 
which contains a vertex not in . A set  is connected if  and the underlying undirected graph of the subgraph of
 induced by  is connected. Connected convex sets and convex
sets of acyclic digraphs are of interest in the area of modern
embedded processor technology. We construct an algorithm 
for enumeration of all connected convex sets of an acyclic digraph
 of order . The time complexity of  is , where  is the number of connected convex sets in
. We also give an optimal algorithm for enumeration of all (not
just connected) convex sets of an acyclic digraph  of order .
In computational experiments we demonstrate that our algorithms
outperform the best algorithms in the literature.

Using the same approach as for , we design an algorithm for
generating all connected sets of a connected undirected graph .
The complexity of the algorithm is  where  is
the order of  and  is the number of connected sets of 
The previously reported algorithm for connected set enumeration is
of running time , where  is the number of edges
in 
\end{abstract}

\section{Introduction}

A set  of vertices of an acyclic digraph  is {\em convex} if
 and there is no directed path between vertices of
 which contains a vertex not in . A set  is {\em connected}
if  and the underlying undirected graph of the
subgraph of  induced by  is connected. A set is {\em connected
convex} (a {\em cc-set}) if it is both connected and convex.


In Section \ref{ccsec}, we introduce and study an algorithm 
for generating all connected convex sets of a connected acyclic
digraph  of order . The running time of  is , where  is the number of connected convex sets in
. Thus, the algorithm is (almost) optimal with respect to its
time complexity. Interestingly, to generate only  cc-sets using
 we need  time. In Section \ref{expersec}, we
give experimental results demonstrating that the algorithm is
practical on reasonably large data dependency graphs for basic
blocks generated from target code produced by
Trimaran~\cite{trimaran} and SimpleScalar~\cite{simplescalar}. Our
experiments show that  is better than the state-of-the-art
algorithm of Chen, Maskell and Sun \cite{chen}. Moreover, unlike the
algorithm in \cite{chen}, our algorithm has a provable (almost)
optimal worst time complexity.

Although such algorithms are of less importance in our application
area because of wider scheduling issues, there also exist algorithms
that enumerate all of the convex sets of an acyclic graph. Until
recently the algorithm of choice for this problem was that of Atasu,
Pozzi and Ienne~\cite{atasu2003, atasu2006}, however the CMS
algorithm~\cite{chen} (run in general mode) outperforms the API
algorithm in most cases. In Section \ref{all}, we give a different
algorithm, for enumeration of all the convex sets of an acyclic
digraph, which significantly outperforms the CMS and API
algorithms and which has a (optimal) runtime performance of the
order of the sum of the sizes of the convex sets.

Avis and Fukuda \cite{avisDAM65} designed an algorithm for
generating all connected sets in a connected graph  of order 
and size  with time complexity  and space
complexity , where  is the number of connected sets in
. Observe that when  is bipartite there is an orientation 
of  such that every connected set of  corresponds to a cc-set
of  and vice versa. To obtain  orient every edge of  from
 to , where  and  are the partition classes of .

The algorithm of Avis and Fukuda is based on a so-called reverse
search. Applying the approach used to design the algorithm  to connected
set enumeration, in Section \ref{consec}, we describe an algorithm
 for generating all connected sets in a connected graph 
of order  with much better time complexity, .
This demonstrates that our approach can be applied with success to
various vertex set/subgraph enumeration problems. The space
complexity of our algorithm matches that of the algorithm of Avis
and Fukuda.

\subsection{Algorithms Applications}\label{aasec}

There is an immediate application for  in the field of
so-called {\em custom computing} in which central processor
architectures are parameterized for particular applications.

An embedded or {\em application specific} computing system only ever
executes a single application. Examples include automobile engine
management systems, satellite and aerospace control systems and the
signal processing parts of mobile cellular phones. Significant
improvements in the price-performance ratio of such systems can be
achieved if the instruction set of the application specific
processor is specifically tuned to the application.

This approach has become practical because many modern integrated
circuit implementations are based on Field Programmable Gate Arrays
(FPGA). An FPGA comprises an array of logic elements and a
programmable routing system, which allows detailed design of logic
interconnection to be performed directly by the customer, rather
than a complete (and very high cost) custom integrated circuit
having to be produced for each application. In extreme cases, the
internal logic of the FPGA can even be modified whilst in operation.

Suppliers of embedded processor architectures are now delivering
{\em extensible} versions of their general purpose processors.
Examples include the ARM OptimoDE~\cite{arm}, the MIPS Pro
Series~\cite{mips} and the Tensilica Xtensa~\cite{tens}. The
intention is that these architectures be implemented either as
traditional logic with an accompanying FPGA containing the hardware
for extension instructions, or be completely implemented within a
large FPGA. By this means, hardware development has achieved a new
level of flexibility, but sophisticated design tools are required to
exploit its potential.


The goal of such tools is the identification of time critical or
commonly occurring patterns of computation that could be directly
implemented in custom hardware, giving both faster execution and
reduced program size, because a sequence of base machine
instructions is being replaced by a single custom {\em extension}
instruction. For example, a program solving simultaneous linear
equations may find it useful to have a single instruction to perform
matrix inversion on a set of values held in registers.



The approach proceeds by first locating the {\em basic blocks} of
the program, regions of sequential computation with no control
transfers into them. For each basic block we construct a {\em data
dependency graph} (DDG) which contains vertices for each base
(unextended) instruction in the block, along with a vertex for each
initial input datum. Figure~\ref{ddg} shows an example of a DDG.
There is an arc to the vertex for the instruction  from each
vertex whose instruction computes an input operand of . DDG's are
acyclic because execution within a basic block is by definition
sequential.



\begin{figure}
\begin{center}
\unitlength 1mm \linethickness{0.4pt}
\ifx\plotpoint\undefined\newsavebox{\plotpoint}\fi \begin{picture}(88,66)(0,0)
\put(2,62){\framebox(11,4)[cc]{VAR:a}}
\put(17,62){\framebox(11,4)[cc]{VAR:c}}
\put(32,62){\framebox(11,4)[cc]{INT:4}}
\put(61,62){\framebox(11,4)[cc]{VAR:b}}
\put(70,26){\framebox(11,4)[cc]{ROOT}}
\put(15,27){\framebox(11,4)[cc]{INT:2}}
\put(10,53){\framebox(9,4)[cc]{MUL}}
\put(22,45){\framebox(9,4)[cc]{MUL}}
\put(10,11){\framebox(9,4)[cc]{MUL}}
\put(53,34){\framebox(9,4)[cc]{SUB}}
\put(70,47){\framebox(9,4)[cc]{MUL}}
\put(66,11){\framebox(9,4)[cc]{ADD}}
\put(41,26){\framebox(9,4)[cc]{NEG}}
\put(36,0){\framebox(9,4)[cc]{DVI}}
\put(13,57){\vector(4,-3){0}}\multiput(7,62)(.04026846,-.03355705){149}{\line(1,0){.04026846}}
\put(16,57){\vector(-4,-3){0}}\multiput(23,62)(-.04697987,-.03355705){149}{\line(-1,0){.04697987}}
\put(25,49){\vector(3,-1){0}}\multiput(14,53)(.09243697,-.03361345){119}{\line(1,0){.09243697}}
\put(28,49){\vector(-2,-3){0}}\multiput(37,62)(-.033707865,-.048689139){267}{\line(0,-1){.048689139}}
\put(13,15){\vector(1,-4){0}}\multiput(7,62)(.03370787,-.26404494){178}{\line(0,-1){.26404494}}
\put(42,4){\vector(-4,-1){0}}\multiput(71,11)(-.13942308,-.03365385){208}{\line(-1,0){.13942308}}
\put(39,4){\vector(4,-1){0}}\multiput(14,11)(.12019231,-.03365385){208}{\line(1,0){.12019231}}
\put(76,51){\vector(0,-1){0}}\qbezier(67,62)(76.5,59.5)(76,51)
\put(72,51){\vector(1,-1){0}}\qbezier(67,62)(66.5,55.5)(72,51)
\put(58,38){\vector(-2,-1){0}}\multiput(75,47)(-.063670412,-.033707865){267}{\line(-1,0){.063670412}}
\put(27,45){\vector(4,-1){28}}
\put(75,30){\vector(4,-1){0}}\multiput(58,34)(.14285714,-.03361345){119}{\line(1,0){.14285714}}
\put(72,15){\vector(-1,-3){0}}\multiput(76,26)(-.03361345,-.09243697){119}{\line(0,-1){.09243697}}
\put(69,15){\vector(2,-1){0}}\multiput(46,26)(.070336391,-.033639144){327}{\line(1,0){.070336391}}
\put(46,30){\vector(-2,-3){0}}\multiput(67,62)(-.033707865,-.051364366){623}{\line(0,-1){.051364366}}
\put(16,15){\vector(-1,-2){0}}\multiput(21,27)(-.03355705,-.08053691){149}{\line(0,-1){.08053691}}
\put(66,22){\makebox(19,33)[cc]{}}
\multiput(65.93,21.93)(.95,0){21}{{\rule{.4pt}{.4pt}}}
\multiput(65.93,54.93)(.95,0){21}{{\rule{.4pt}{.4pt}}}
\multiput(65.93,54.93)(0,-.97059){35}{{\rule{.4pt}{.4pt}}}
\multiput(84.93,54.93)(0,-.97059){35}{{\rule{.4pt}{.4pt}}}
\put(6,7){\makebox(73,12)[cc]{}}
\multiput(5.93,6.93)(.98649,0){75}{{\rule{.4pt}{.4pt}}}
\multiput(5.93,18.93)(.98649,0){75}{{\rule{.4pt}{.4pt}}}
\multiput(5.93,18.93)(0,-.9231){14}{{\rule{.4pt}{.4pt}}}
\multiput(78.93,18.93)(0,-.9231){14}{{\rule{.4pt}{.4pt}}}
\put(6,43){\makebox(29,16)[cc]{}}
\multiput(5.93,42.93)(.9667,0){31}{{\rule{.4pt}{.4pt}}}
\multiput(5.93,58.93)(.9667,0){31}{{\rule{.4pt}{.4pt}}}
\multiput(5.93,58.93)(0,-.9412){18}{{\rule{.4pt}{.4pt}}}
\multiput(34.93,58.93)(0,-.9412){18}{{\rule{.4pt}{.4pt}}}
\put(4,55){\makebox(0,0)[cc]{{\bf A}}}
\put(88,51){\makebox(0,0)[cc]{{\bf C}}}
\put(4,15){\makebox(0,0)[cc]{{\bf B}}}
\end{picture}
\end{center}
\caption{Data dependency graph for }
\label{ddg}
\end{figure}

Extension instructions are combinations of base machine instructions
and are represented by sets of the DDG. In Figure~\ref{ddg},
sections A and B are convex sets that represent candidate extension
instructions. However, Section B is not connected.  If such a region
were implemented as a single extension instruction we should have
separate independent hardware units within the instruction. Although
this presents no special difficulties, and in Section~\ref{all} we
give an optimal algorithm for constructing all such sets, present
engineering practice is to restrict the search to connected convex
components on the grounds that unconnected convex components are
composed of connected ones, and that the system's code scheduler
will perform better if it is allowed to arrange the independent
computations in different ways at different points in the program.

Unlike connectivity however, convexity is not optional. An extension
instruction cannot perform computations that depend on instructions
external to the extension instruction. This means that there can be
no data flows out of and then back into the extension instruction:
the set corresponding to an extension instruction must be convex.
Thus section C in Figure~\ref{ddg} does not represent a candidate
extension instruction since it breaches the `no external computation
rule' because it is non-convex: there is a path {\em via} the {\tt
SUB} node that is not in the set.



Ideally we would like to fully consider all possible candidate
instructions and select the combination which results in the most
efficient implementation. In practice this is unlikely to be
feasible as, in worst case, the number of candidates will be
exponential in the number of original program instructions. However,
it is useful to have a process which can find all the potential
instructions, even if the set of instructions used for final
consideration has to be restricted. In this work we only deal with
generation of a set of possible candidate instructions. Interested
readers can refer to~\cite{atasu2006,yu}.




\subsection{ Related Theoretical Research}\label{rtrsec}

Many other algorithms for special vertex set/subgraph generation
have been studied in the literature. Kreher and Stinson
\cite{kreher} describe an algorithm for generating all cliques in a
graph  of order  with running time , where
 is the number of cliques in 

Several algorithms have been suggested for the generation of all spanning
trees in a connected graph  of order  and size . Let  be
the number of spanning trees in . The first spanning trees
generating algorithms \cite{gabowSIAMJC7,mintyIEEETCT12,readN5} used
backtracking which is useful for enumerating various kinds of
subgraphs such as paths and cycles. Using the algorithms from
\cite{mintyIEEETCT12,readN5}, Gabow and Myers \cite{gabowSIAMJC7}
suggested an algorithm with time complexity  and space
complexity . If we output all spanning trees by their edges,
this algorithm is optimal in terms of time and space complexities.
Later algorithms of a different type were developed; these algorithms
(see, e.g., \cite{kapoorSIAMJC24,shiouraJORSJ38,shiouraSIAMJC26})
find a new spanning tree by exchanging a pair of edges. As a result,
the algorithms of Kapoor and Ramesh \cite{kapoorSIAMJC24} and
Shioura and Tamura \cite{shiouraJORSJ38} require only 
time and  space. The algorithm of Shioura, Tamura and Uno
\cite{shiouraSIAMJC26} is of the same optimal running time, but also
of optimal space: 



An out-tree is an orientation of a tree such that all vertices but
one are of in-degree 1. Kapoor, Kumar and Ramesh \cite{kapoorA27}
presented an algorithm for enumerating all spanning out-trees of a
digraph with  vertices,  arcs and  spanning out-trees. The
algorithm takes  time per spanning tree; more precisely,
it runs in , where  is the
Inverse Ackermann function. It first outputs a single spanning
out-tree and then a list of arc swaps; each spanning out-tree can be
generated from the first spanning out-tree by applying a prefix of
this sequence of arc swaps.



\section{Terminology, Notation and Preliminaries}

Let  be a digraph. If  is an arc of  (), we
say that  is an {\em out-neighbor} of  and  is an {\em
in-neighbor} of . The set of out-neighbors of  is denoted by
 and the set of in-neighbors of  is denoted by
. For a set  of vertices of , its {\em
out-neighborhood} (resp.\ {\em in-neighborhood}) is  (resp.\ ). A digraph  is called the {\em transitive closure} of
 if  and a vertex  is an in-neighbor of a
vertex  in  if and only if there is a path from  to
 in 

Let  be a non-empty set of vertices of a digraph . A directed
path  of  is an -{\em path} if  has at least three
vertices, its initial and terminal vertices are in  and the rest
of the vertices are not in   For a digraph , 
() denotes the collection of cc-sets (convex sets) in 
 and  An ordering
 of vertices of an acyclic digraph  is
called {\em acyclic} if for every arc  of  we have
.


\begin{lemma} \label{lemma_transitive}
Let  be a connected acyclic digraph and let  be a vertex set
in . Then  is a cc-set in  if and only if it is a cc-set in
.
\end{lemma}
\begin{proof} Let  be a set of vertices of . We will first prove that
there is an -path in  if and only if there is an -path in
 Since all arcs of  are in , every -path in
 is an -path in  Let  be an
-path in . Then there are paths 
such that  is a path in 
( must be a path since  is acyclic). Since  and 
belong to  and  does not belong to , there is a subpath
of  which is an -path.

If  is connected in  then it is clearly connected in ,
which implies that if  is a cc-set in  then it is a cc-set in
. Now let  be a cc-set in . Assume that  is
not connected and let  and  be vertices in different connected
components in , but which are connected by an arc in .
Without loss of generality  is the arc in  and  is a
path from  to  in . However as  is convex all vertices
in  also belong to  and therefore  and  belong to the
same connected component in , a contradiction. \end{proof}

\vspace{3mm}

It is well-known  (see, e.g., the paper
\cite{fisher1971}  by Fisher and Meyer, or \cite{furmanSMD11} by
Furman) that the transitive closure problem and the matrix
multiplication problem are closely related: there exists an
-algorithm, with , to compute the transitive
closure of a digraph of order  if and only if the product of
two boolean  matrices can be computed in  time. 
Coppersmith and Winograd \cite{coppersmith1987}
showed that there exists an -algorithm for the
matrix multiplication. Thus, we have the following:

\begin{theorem}\label{remtr}
The transitive closure of a digraph of order  can be found in
 time. 
\end{theorem}

We will need the following two results proved in \cite{GuYe}.

\begin{theorem} \label{lower_bound}
For every connected acyclic  digraph  of order ,  . If an acyclic digraph  of order  has a Hamiltonian path, then
  .
\end{theorem}

\begin{theorem}\label{upper_bound}
Let , where  for every even
 and  for every odd . For every
connected acyclic  digraph  of order ,   Let
 denote the digraph obtained from the complete
bipartite graph  by orienting every edge from the partite
set of cardinality  to the partite set of cardinality  We
have  provided .
\end{theorem}




\section{Algorithm for Generating CC-Sets of an Acyclic
Digraph}\label{ccsec}

In this section  denotes a connected acyclic digraph of order 
and size . Now we describe the main algorithm of this paper; we
denote it by . The input of  is  and  outputs all cc-sets of . The formal description of 
is followed by an example and proofs of correctness of 
and its complexity. Finally, we show that to produce  cc-sets
 requires  time. The algorithm works as follows. 
Given a digraph
 on  vertices, it considers an acyclic ordering  of the
transitive closure of .
For each vertex  we consider the sets  and  and call the subroutine  which finds all cc-sets  in
 such
that .
At each step, if possible  removes an element  from  and adds
it to . If  has out-neighbors we choose  to be the
`largest' out-neighbor in the acyclic ordering(line 3), otherwise if  has
in-neighbors
we choose  to be the `smallest' in-neighbor (line 8).  Then we
find the other vertices required to maintain convexity (line 4 or
line 9). If there are no in- or out-neighbors we output ,
otherwise we find find all the cc-sets such that  and  (line 12) and then all the cc-sets
such that  and  (line
13). 


\begin{description}
  \item[Step 1:] Find the transitive closure of  and
  set 
  \item[Step 2:] Find an acyclic ordering  of
  .
  \item[Step 3:] For each  do the following.  Set ,
 and call .

\item[Step 4 subroutine :]\mbox{}\\
{ \obeylines\obeyspaces{
 \ 1.   set 
 \ 2.  {\bf if}  
 \ 3.        set , where max
 \ 4.        set   
 \ 5.  {\bf else} 
 \ 6.        set 
 \ 7.       {\bf if}  
 \ 8.             set , where min
 \ 9.             set    
 \ 10. {\bf if}  and   output  
 \ 11. {\bf else} 
 \ 12.        
 \ 13.          
}}
\end{description}
Before proving the correctness of , we consider an example.

\begin{example} Let  be the graph on the left below
\begin{center}
\footnotesize
\unitlength .6mm \linethickness{0.4pt}
\ifx\plotpoint\undefined\newsavebox{\plotpoint}\fi \begin{picture}(148.1,35.1)(0,0)
\put(5,15){\circle{10.2}}
\put(96,15){\circle{10.2}}
\put(24,23){\circle{10.2}}
\put(115,23){\circle{10.2}}
\put(41,30){\circle{10.2}}
\put(132,30){\circle{10.2}}
\put(52,15){\circle{10.2}}
\put(143,15){\circle{10.2}}
\put(28,5){\circle{10.2}}
\put(119,5){\circle{10.2}}
\put(5,15){\makebox(0,0)[cc]{}}
\put(96,15){\makebox(0,0)[cc]{}}
\put(24,23){\makebox(0,0)[cc]{}}
\put(115,23){\makebox(0,0)[cc]{}}
\put(41,30){\makebox(0,0)[cc]{}}
\put(132,30){\makebox(0,0)[cc]{}}
\put(52,15){\makebox(0,0)[cc]{}}
\put(143,15){\makebox(0,0)[cc]{}}
\put(28,5){\makebox(0,0)[cc]{}}
\put(119,5){\makebox(0,0)[cc]{}}
\put(45,27){\vector(1,-1){7}}
\put(136,27){\vector(1,-1){7}}
\put(9,12){\vector(2,-1){14}}
\put(100,12){\vector(2,-1){14}}
\put(36,29){\vector(-3,-1){8}}
\put(127,29){\vector(-3,-1){8}}
\put(48,12){\vector(-2,-1){15}}
\put(139,12){\vector(-2,-1){15}}
\put(19,23){\vector(-3,-1){11}}
\put(110,23){\vector(-3,-1){11}}
\put(115,18){\vector(1,-3){2.67}}
\put(132,25){\vector(-3,-4){11.25}}
\put(96,20){\vector(-1,-2){.12}}\qbezier(127,32)(100.5,30)(96,20)
\put(5,32){\makebox(0,0)[cc]{}}
\put(95,32){\makebox(0,0)[cc]{}}
\end{picture}
 \end{center}
In Step 1, we find 
(above right). Observe that  is an acyclic
ordering. We may assume that this is the ordering found in Step 2.

For  in Step 3, we have  and
, and we call . Then in Step 4, line 1, we compute
 and then, lines 3 and 4, obtain ,
 and .
Then, at line 12, we make a recursive call to . In this call we have  so, at
line 10, the set  is output and the
recursive call returns, to line 13 of , where we make a call to . We are now effectively looking at the graph
 below.
\begin{center}
\footnotesize
\unitlength .6mm \linethickness{0.4pt}
\ifx\plotpoint\undefined\newsavebox{\plotpoint}\fi \begin{picture}(163.1,25.1)(0,0)
\put(5,5){\circle{10.2}}
\put(79,5){\circle{10.2}}
\put(24,13){\circle{10.2}}
\put(98,13){\circle{10.2}}
\put(141,13){\circle{10.2}}
\put(41,20){\circle{10.2}}
\put(115,20){\circle{10.2}}
\put(158,20){\circle{10.2}}
\put(52,5){\circle{10.2}}
\put(5,5){\makebox(0,0)[cc]{}}
\put(79,5){\makebox(0,0)[cc]{}}
\put(24,13){\makebox(0,0)[cc]{}}
\put(98,13){\makebox(0,0)[cc]{}}
\put(141,13){\makebox(0,0)[cc]{}}
\put(41,20){\makebox(0,0)[cc]{}}
\put(115,20){\makebox(0,0)[cc]{}}
\put(158,20){\makebox(0,0)[cc]{}}
\put(52,5){\makebox(0,0)[cc]{}}
\put(45,17){\vector(1,-1){7}}
\put(36,19){\vector(-3,-1){8}}
\put(110,19){\vector(-3,-1){8}}
\put(153,19){\vector(-3,-1){8}}
\put(19,13){\vector(-3,-1){11}}
\put(93,13){\vector(-3,-1){11}}
\put(5,10){\vector(-1,-2){.12}}\qbezier(36,22)(9.5,20)(5,10)
\put(79,10){\vector(-1,-2){.12}}\qbezier(110,22)(83.5,20)(79,10)
\put(4,23){\makebox(0,0)[cc]{}}
\put(78,23){\makebox(0,0)[cc]{}}
\put(140,22){\makebox(0,0)[cc]{}}
\end{picture}
 \end{center}
In Step 4, lines 1-4, we compute  and obtain
,  and .  At lines 12 and
13 we make recursive calls to  and 
respectively.

In the call to , lines 1-4, we
obtain  and . This in turn generates calls to
, which just outputs
 and returns, and . The latter call generates calls to
 and , which output  and
, respectively.

In the call to , where we are
effectively looking at  above, we obtain  and
. This in turn generates calls to , which just outputs
 and returns, and 
(graph  above). The latter call generates calls to  and ,
which output  and , respectively. This
completes the case  in Step 3, and all the cc-sets containing
 have been output.



Now we perform Step 3 with , effectively looking at the graph
.
\begin{center}
\footnotesize
\unitlength .6mm \linethickness{0.4pt}
\ifx\plotpoint\undefined\newsavebox{\plotpoint}\fi \begin{picture}(157.1,28.1)(0,0)
\put(7,15){\circle{10.2}}
\put(105,15){\circle{10.2}}
\put(26,23){\circle{10.2}}
\put(54,15){\circle{10.2}}
\put(152,15){\circle{10.2}}
\put(30,5){\circle{10.2}}
\put(128,5){\circle{10.2}}
\put(7,15){\makebox(0,0)[cc]{}}
\put(105,15){\makebox(0,0)[cc]{}}
\put(26,23){\makebox(0,0)[cc]{}}
\put(54,15){\makebox(0,0)[cc]{}}
\put(152,15){\makebox(0,0)[cc]{}}
\put(30,5){\makebox(0,0)[cc]{}}
\put(128,5){\makebox(0,0)[cc]{}}
\put(11,12){\vector(2,-1){14}}
\put(109,12){\vector(2,-1){14}}
\put(50,12){\vector(-2,-1){15}}
\put(148,12){\vector(-2,-1){15}}
\put(21,23){\vector(-3,-1){11}}
\put(26,18){\vector(1,-3){2.67}}
\put(5,25){\makebox(0,0)[cc]{}}
\put(103,25){\makebox(0,0)[cc]{}}
\end{picture}
 \end{center}
The call to  
generates further recursive calls in the following order\\
\mbox{\qquad} \\
\mbox{\qquad\qquad} , output
\\
\mbox{\qquad\qquad} , output \\
\mbox{\qquad} \\
\mbox{\qquad\qquad} , output \\
\mbox{\qquad\qquad} , output .\\
Thus all the cc-sets containing  but not  are output.

Performing Step 3 again with , effectively looking at the graph
 above, the call to ,
generates the following recursive calls\\
\mbox{\qquad} \\
\mbox{\qquad\qquad} , output \\
\mbox{\qquad\qquad} , output \\
\mbox{\qquad} , output \\
which ouput all the cc-sets containing  but not  or .


For the case  in Step 3 we get the following calls\\
\mbox{\qquad} \\
\mbox{\qquad\qquad} , output \\
\mbox{\qquad\qquad} , output \\
and for  we get\\
\mbox{\qquad} , output \\
after which  terminates.
\end{example}

\2

\begin{lemma}\label{corlem}
Algorithm  correctly outputs all cc-sets of .
\end{lemma}
\begin{proof}
Recall, the convex (connected) sets of  are precisely the convex
(connected) sets of . We prove the result for .

Firstly we show that all the sets  output by  are in
. We will show that within , for any call
 we have that ,  is
convex and  is a cc-set. This is clearly sufficient as  is the only set output.

These properties hold for Step 3 when  is called as we have chosen an acyclic
ordering of the vertices.  Thus we assume that the properties hold for the sets
,  and consider the pairs of sets ,  and ,
 constructed in . In both cases
clearly the intersections are empty, and since ,  is connected.

Now we will prove that  is convex. Suppose that there is a path 
where . Note that if there exists an -path then by
transitivity of  there exists an -path of length two. By
convexity of  we have . Also,  as we have chosen 
to be either the maximal element of  or the minimal element of
, and  is transitive and thus the presence of the arcs 
and  implies the presence of the arc  Assume that . Then
. Since  and the arc 
exists, the transitivity of  implies that . Since 
is convex it follows that not both vertices   can be in   and that there is
no arc from  to . Thus  and so 
. By the transitivity of  and the fact that
 exists and that  we have  and thus
. Similarly if   then  and by the
transitivity of  and since   we have  
and thus . 






Secondly we show that if  is cc then  is output
by .
If  is a cc-set and  then . Thus it is
sufficient to show that if  is cc and  then  outputs . We prove this by
induction on .

If  then, since  is connected,
 and  outputs  at line 10. This proves the
result for , and for  we may assume that .

If  then we have  and , so
by induction the call to  at line 13
outputs . If , we have arcs  and
, for some . Thus, if , by convexity
of  we have . Then, since ,
the call to  at line 12 outputs
.
\end{proof}

\begin{lemma}\label{runtlem}
The running time of  is 
\end{lemma}
\begin{proof} Note that by Theorem \ref{lower_bound} and the fact that  is
connected we have . Therefore the
transitive closure of  can be found in  time,
by Theorem \ref{remtr}. It is well-known that an acyclic ordering can
be found in time , see, e.g., \cite{bang2000}, and clearly
the sets  and  can be computed at
the start of the algorithm in  time, for each .


We will now show that  runs in time , where  is the number of cc-sets 
such that  and  is the
sum of the sizes of the sets . Note that  returns at
line 10 or makes two recursive calls to  (lines 12,13). If
 returns at line 10 then we call this a {\em leaf} call
otherwise the function call is an {\em internal} call. All function
calls can be viewed as nodes of a binary tree (every node is a leaf
or has two children) whose leaves and internal nodes correspond to
calls to . It is easy to see, by induction, that the number
of internal nodes equals the number of leaves minus one. It is easy
to see, by induction on the depth of the call tree, that 
outputs each set  only once (
and  output those that contain 
and do not contain , respectively). Thus we have  leaf
calls and  internal calls.

We assume that the set implementation allows us to find the size of
a set and the largest and smallest elements of the set in unit time.
Then the time taken by a call   depends on the time
taken to calculate the sets ,  and . Since , the time to compute  is at most . If we implement
 so that  and 
are passed in as parameters then the time taken to calculate  and
 is at most . By definition of  we have that   and  provided , and 
and  provided
 (and ). Since , these
sets can be computed in  time.

If  calls  then  thus
a call to  at an internal node takes at most   time,
and a call at a leaf node takes at most  time, giving
the desired total time bound of .

We let  denote the sum of the sizes of all the cc-sets  such
that , and observe that
.

Finally, by Step 3, we conclude that the total running time is
\end{proof}

\begin{theorem}\label{maint}
Algorithm  is correct and its time and space complexities
are  and , respectively.
\end{theorem}
\begin{proof} The correctness and time complexity follows from the two lemmas
above. The space complexity is dominated by the space complexity of
Step 1, \end{proof}

\2

Since  may well be exponential, we may wish to generate only
a restricted number  of cc-sets. Theorem \ref{kccsets} can be
viewed as a result in fixed-parameter algorithmics \cite{downey1999}
with  being a parameter.

\begin{theorem}\label{kccsets}
To output  cc-sets the algorithm  requires 
time.
\end{theorem}
\begin{proof} We may assume that  is at most the number
of cc-sets containing vertex  since otherwise the proof is
analogous.

We consider the binary tree  introduced in the proof of Lemma
\ref{runtlem} and prove our claim by induction on . It takes
 time to perform Steps 1,2 and 3. It takes  internal
nodes of  to reach the first leaf of  and, thus, for  we
obtain  time. Assume that . Let  be the first
leaf of  reached by , let  be the parent of  on
, let  be another child of  on  and let  be the
parent of . Observe that after deleting the nodes  and  and
adding an edge between  and , we obtain a new binary tree
. By induction hypothesis, to reach the first  leaves in
, we need  time. To reach the first  leaves in
, we need to reach  and the first  leaves in . Thus,
we need to add to  the time required to visit  and
 only, which is  Thus, we have proved the desired bound
.
\end{proof}





\section{Generating Convex Sets in Acyclic Digraphs}\label{all}

It is not hard to modify  such that the new algorithm will
generate all convex sets of an acyclic digraph  in time , where  is the number of convex sets in . However,
a faster algorithm is possible and we present one in this section.

To obtain all convex sets of  (and , which is not
convex by definition), we call the following recursive procedure
with the original digraph  and with . This call
yields an algorithm whose properties are studied below.

A vertex  is a {\em source} ({\em sink}) if it has no in-neighbors (out-neighbors).
In general, the procedure {\cs}\  takes as input an acyclic digraph
 and a set  and outputs all convex sets of 
which contain .  The procedure {\cs}\ outputs  and then
considers all sources and sinks of the graph that are not in . 
For each such source or sink , we call {\cs} and then
add  to . Thus, for each sink or source 
we consider all sets that contain  and all sets that do not
contain .



{\obeylines\obeyspaces{

     {\cs}()
     1.  {\bf output} 
     2.  {\bf for all}  with  or  {\bf do} \{
     3.       {\bf for all} vertices  find  and 
     4.        call {\cs}; set 
     5.       {\bf for all} vertices  find  and             \}

}}






\subsection{Correctness of the procedure}

Proposition \ref{prop:convex} and Theorem \ref{prop:unique} imply
that the procedure {\cs}\ is correct. We first show that all sets
generated in line 1 are, in fact, convex sets. To this end, we use
the following lemma.

\begin{lemma}\label{lem:delete}
Let  be an acyclic graph, let  be a convex set of , and let
 be a source or sink of . Then  is a
convex set of .
\end{lemma}
\begin{proof}
Suppose that   is not convex in . Then there
exist two vertices  and a directed path 
from  to  which contains a vertex not in .
Since  is convex,  only uses vertices of  and in particular . 
Thus, there is a subpath  of  with .
But since  is a source or a sink in  such a subpath cannot
exist, a contradiction.
\end{proof}

Now we can prove the following proposition.

\begin{proposition}\label{prop:convex}
Let  be an acyclic digraph and let . Then
every set output by {\cs}() is convex.
\end{proposition}
\begin{proof}
We prove the result by induction on the number of vertices of the
outputted set. The entire vertex set  is convex and is outputted
by the procedure. Now assume all sets of size  that are
outputted by the procedure are convex. We will show that all sets of
size  that are outputted are also convex. When a set  is
outputted the procedure  {\cs} was called for some set
. The only way {\cs} can be invoked is
that there exist a set  and a source or sink  of
 with . Moreover  will be outputted
by the procedure and, thus, by our assumption is convex. The result
now follows from Lemma~\ref{lem:delete}.
\end{proof}

\begin{theorem}\label{prop:unique}
Let  be an acyclic digraph and let . Then
every convex set of  containing  is outputted exactly once by
{\cs}.
\end{theorem}
\begin{proof}
Let  be a convex set of  containing . We first claim that
there exist vertices  with
 and  is a source or sink of
 for all . To prove the claim we will show that for every convex set 
with
 , there exists a source or sink  of
the digraph . This will prove our claim as by
Lemma~\ref{lem:delete}  is a convex set of  and we
can repeatedly apply the claim.

If there exists no arc from a vertex of  to  a vertex of
 then any source of  is a source of
. Note that  is an acyclic digraph and, thus,
has at least one source (and sink). Thus we may assume that there is
an arc from a vertex  of  to a vertex  of .
Consider a longest path  in 
leaving . Observe that  is a sink of  and,
moreover, there is no arc from  to any vertex of  since
otherwise there would be a directed path from  to a vertex
in  containing vertices in  which is impossible as
 is convex. Hence  is a sink of  and the claim is
shown.

Next note that a sink or source remains a sink or source when
vertices are deleted. Thus when {\cs} is executed and  a
source or sink  is considered, then we distinguish the cases when
 for some  or when this is not the
case. If   and we currently consider the digraph  and the
fixed set , then we follow the execution path calling
{\cs}. Otherwise we follow the execution path that adds
 to the fixed set. When the last  is deleted, we call
{\cs}  for some  and the set  is outputed. It
remains to show that there is a unique execution path yielding .
To see this, note that when we consider a source or sink  then
either it is deleted of moved to the fixed set . Thus every
vertex is considered at most once and then deleted or fixed.
Therefore each time we consider a source or sink there is a unique
decision that finally yields .
\end{proof}

\subsection{Running time of \cs}

We assume that the input acyclic digraph  is given by
the two adjacency lists for each vertex, and the number of in-neighbors and
out-neighbors is stored for each vertex. One can obtain this
information at the beginning in  time, where  () is
the number of vertices (arcs) of the input connected acyclic digraph . Observe
that we output the vertex set of  as one convex set. Thus, it
suffices to show that the running time of {\cs} without the
recursive calls is . This will yield the running time
 of {\cs}\ by
Theorem~\ref{prop:unique}.

Since we have stored the number of in-neighbors and out-neighbors
for every vertex , we can determine \emph{all} sources and
sinks in  time. For the recursive calls of {\cs}\ we delete
one vertex and have to update the number of in- respectively
out-neighbors of all neighbors of the deleted vertex . The vertex
 has at most  neighbors and we can charge the cost of the
updating information to the call of {\cs}. Moreover we store the neighbours
of  so that we can reintroduce them after the call of  {\cs}. Moving the
sinks
and sources to  needs constant time for each source or sink and
thus we obtain  time in total.

In summary we initially need  time, and then each call of
{\cs} is charged with  before it is called and then
additionally with  time during its execution. Since we
output a convex set of size , the total running time is
. Since
  by Theorem \ref{lower_bound}, the running
time of {\cs}\  is .

\section{Implementation and Experimental Results}\label{expersec}


In order to test our algorithms  and {\cs}  for
practicality we have implemented and run them on several instances
of DDG's of basic blocks. We have compared our algorithm with the
state-of-the-art algorithm of Chen, Maskell and Sun \cite{chen}
(the CMS algorithm) using their own implementation, but with the
code for I/O constraint checking removed so as to ensure that their
algorithm was not disadvantaged. For completeness we have also
compared {\cs}\ to Atasu, Pozzi and Ienne's
algorithm~\cite{atasu2006} (the API06 algorithm). All the algorithms
were coded in C++ and all experiments were carried out on a 2 x Dual
Core AMD Opteron 265 1.8GHz processor with 4 Gb RAM, running SUSE
Linux 10.2 (64 bit).

Our first set of tests is based on C and C++ programs taken from the
benchmark suites of MiBench~\cite{MIBENCH} and
Trimaran~\cite{trimaran}. We compiled these benchmarks for both the
Trimaran (A,B,C,D,E) and SimpleScalar~\cite{simplescalar} (F,G,H,I)
architectures. From here we examined the control-flow graph for each
program to select a basic block within a critical loop of the
program (often this block had been unrolled to some degree to
increase the potential for efficiency improvements).


We considered basic blocks, ranging from  20 to 45 lines of low
level, intermediate, code, for which we generated the DDGs. We then
selected, from these DDGs, the non-trivial connected components on
which to run our algorithms.


We give some preference to benchmarks which suite the intended
application of the research taking our test cases from security
applications including benchmarks for the Advanced Encryption
Standard (B,C) and safety-critical software (A, E). We also include
a basic example from the Trimaran benchmark suite: Hyper (D), an
algorithm that performs quick sort (F), part of a jpeg algorithm
(G), and an example from the fft benchmark in mibench containing C
source code for performing Discrete Fast Fourier Transforms (H). The
final example is taken from the standard blowfish benchmark, an
encryption algorithm.


The results we have obtained are given in Table~\ref{ri:basic}.  In
the following tables NV denotes the number of vertices, NS denotes
the number of generated sets, NA number of arcs, CT denotes clock
time in  CPU seconds, and for the benchmark data ID
identifies the benchmark.

\begin{table}
\begin{center}
\begin{tabular}{|c|c|c|c||c||c|
} \hline ID&NV&NA&NS&CMS (CT)& (CT)\cr\hline\hline A &35 &38
&139,190 & 170& 96\cr\hline B &42 & 45& 4,484,110& 5,546 &
3,246\cr\hline C &26&28&5,891&6&4\cr\hline D
&39&94&3,968,036&4,346&2,710\cr\hline E
&45&44&1,466,961&1,750&1,156\cr\hline F &24&22&46,694&60&30\cr\hline
G &20&19&397&0&0\cr\hline H &20&21&1,916&0&0\cr\hline I
&43&47&10,329,762&13,146&7,210\cr\hline
\end{tabular}
\end{center}
\caption{cc-sets for benchmark programs} \label{ri:basic}
\end{table}
For examples G and H both algorithms ran in almost 0 time. For the
other examples, the above results demonstrate that our algorithm
 outperforms the CMS algorithm.



We also consider examples with worst-case numbers of cc-sets. Let,
as in Theorem \ref{upper_bound},  denote the digraph
obtained from the complete bipartite graph  by orienting
every edge from the partite set of cardinality  to the partite
set of cardinality  By Theorem \ref{upper_bound} the digraphs
 with  have the maximum possible
number of cc-sets. Our experimental results for digraphs
 with  are given in
Table~\ref{ri:max}. Again we see that  outperforms the CMS
algorithm.

\begin{table}
\begin{center}
\begin{tabular}{|c|c|c||c||c|}
\hline NV &NA&NS&CMS (CT)& (CT)\cr\hline\hline 15& 56&  32,400&
30&16\cr\hline 16& 64&  65,041&     56&23\cr\hline 17& 72&  130,322&
114&60\cr\hline 18& 81&  261,139&    240&113\cr\hline 19& 90&
522,722&    540&253\cr\hline 20& 100& 1,046,549&  1,080&513\cr\hline
21& 110& 2,094,102&  2,166&1,048\cr\hline 22& 121& 4,190,231&
4,086&2,156\cr\hline
\end{tabular}
\end{center}
\caption{cc-sets for graphs with maximum number of cc-sets}
\label{ri:max}
\end{table}



We have compared algorithm {\cs}\ with both CMS running in
`unconnected' mode and with API06. The examples used are the same as
in Table 1, however we do not give results for examples B, D, E and
I as these graphs produce an extremely large number of convex sets
and as a result, do not terminate in reasonable time. The results
are shown in Table~\ref{ri:basicB}. We can see that although CMS
generally out-performs API06, there are two cases where API06 is
marginally better. However, {\cs}\ is consistantly three to five
times faster than either of the other algorithms.

\begin{table}
\begin{center}
\begin{tabular}{|c|c|c|c||c||c||c|
} \hline ID&NV&NA&NS&API06&CMS (CT)&{\cs}\ (CT)\cr\hline\hline A &35
&38 &1,123,851 &2,560 &1,390& 270\cr\hline C
&26&28&120,411&250&120&40\cr\hline F
&24&22&3,782,820&3,250&3,630&860\cr\hline G
&20&19&122,111&70&120&30\cr\hline H
&20&21&55,083&110&110&20\cr\hline
\end{tabular}
\end{center}
\caption{All convex sets for benchmark programs} \label{ri:basicB}
\end{table}

For interest we have also compared API06, CMS and {\cs}\ on the
digraphs that have maximal numbers of cc-sets. The results are shown
in Table~\ref{ri:maxB}. Again, while CMS and API06 are roughly
comparable, {\cs}\ is a least twice as fast as both of them.


\begin{table}
\begin{center}
\begin{tabular}{|c|c|c||c||c||c|}
\hline NV &NA&NS&API06&CMS (CT)&{\cs}\ (CT)\cr\hline\hline 15& 56&
32,768&     40&40&10\cr\hline 16& 64&  65,536&     70&70&30\cr\hline
17& 72&  131,072&    140&130&60\cr\hline 18& 81&  261,144&
320&320&130\cr\hline 19& 90&  524,288&    720&700&320\cr\hline 20&
100& 1,046,575&  1,590&1,500&710\cr\hline 21& 110& 2,097,152&
3,320&3,010&1,500\cr\hline 22& 121& 4,194,304&
7,140&6,310&3,120\cr\hline
\end{tabular}
\end{center}
\caption{All convex sets for graphs with maximum number of cc-sets}
\label{ri:maxB}
\end{table}


\section{Connected Sets Generation Algorithm}\label{consec}


Let  be a connected (undirected) graph with vertex set
 and let  have  edges. For a
vertex  and a set , let  and  The
following is an algorithm, , for generating all connected
sets of .

\begin{description}
\item[Step 1:]
For each  do the following.  Set  and
. Initiate the set  as
.

\item[Step 2 (subroutine ):]
{\em Comment:  finds all connected sets  in  such that
}.

\begin{description}
\item[(2a):] If  then return the connected set  (and stop).

\item[(2b):] If , then let  be arbitrary.

\item[(2c):]  {\em Comment: In this step we will find all connected sets 
such that }.\\
Set
,  and . Remove  from  and
, and add it to . For every  check
whether  has an edge to  and if it does then add it to .

\2 Make a recursive call to subroutine . {\em Comment: we
consider the new  and }.

\2 Change , , and  back to their original state by
setting , , and .

\item[(2d):] {\em Comment: In this step we will find all connected
sets   such that  and }. Remove  from  and remove  from .

\2

Make a recursive call to subroutine .

\2

Change  back to its original state by adding  back to .
Also change  back to its original state by adding  to it.
\end{description}
\end{description}

Similarly to Theorem \ref{maint}, one can prove the following:

\begin{theorem}
Let  be the number of connected sets of a connected graph .
Algorithm  is correct and its time and space complexities
are  and , respectively.
\end{theorem}



\section{Discussions and Open Problems}\label{discsec}



Our computational experiments show that  performs well and
is of definite practical interest. We have tried various heuristic
approaches to speed up the algorithm in practice, but all approaches
were beneficial for some instances and inferior to the original
algorithm for some other instances. Moreover, no approach could
significantly change the running time. The algorithm was developed
independently from the CMS algorithm. However, the two algorithms
are closely related, and work continues to isolate the
implementation effects that give the performance differences.


\2 \2

\noindent{\bf Acknowledgements.}  We are grateful to the authors of
\cite{chen} for helpful discussions and for giving us access to
their code allowing us to benchmark our algorithm against theirs.
Research of Gregory Gutin and Anders Yeo was supported in part by an
EPSRC grant. Research of Gutin was also supported in part by the IST
Programme of the European Community, under the PASCAL Network of
Excellence, IST-2002-506778.


\begin{thebibliography}{99}
\bibitem{arm} ARM, \url{www.arm.com}



\bibitem{atasu2003} K. Atasu, L. Pozzi and P. Ienne, Automatic
application-specific instruction-set extensions under
microarchitectural constraints. In {\em Proc. 40th Conf. Design
Automation}, ACM Press (2003), 256--261.

\bibitem{simplescalar}
T. Austin, E. Larson and D. Ernst, SimpleScalar: An Infrastructure
for Computer System Modeling. {\em Computer} {\bf 35} (2002),
59--67.

\bibitem{avisDAM65} D. Avis and K. Fukuda, Reverse search for enumeration. {\em
Discrete
Appl. Math.} {\bf 65} (1996), 21ï¿½-46.

\bibitem{bang2000} J. Bang-Jensen and G. Gutin, {\em Digraphs: Theory, Algorithms
and Applications}. Springer-Verlag, London, 2000, 754 pp.


\bibitem{chen} X. Chen, D.L. Maskell, and Y. Sun,
Fast identification of custom instructions for extensible
processors. {\em IEEE Trans. Computer-Aided Design Integr. Circuits
Syst.} {\bf 26} (2007), 359--368.

\bibitem{coppersmith1987} D. Coppersmith and S. Winograd, Matrix multiplication via arithmetic progressions. In {\em
Proceedings of the 19th Ann. ACM Symp. on Theory of Computation} (1987), 1--6.

\bibitem{downey1999} R.G. Downey and M.R.~Fellows,
{\em Parameterized Complexity\/}, Springer--Verlag, New York, 1999.

\bibitem{fisher1971} M.J. Fisher an A.R. Meyer, 
Boolean matrix multiplication and transitive closure. In
{\em Proceedings of the 12th Ann. ACM Symp. on Switching and Automata Theory} (1971), 
129--131.

\bibitem{furmanSMD11} M.E. Furman, 
Application of a method of fast multiplication
of matrices in the problem of finding the transitive closure of a graph.
{\em Sov. Math. Dokl.}
{\bf 11} (1970), 1252.

\bibitem{gabowSIAMJC7} H.N. Gabow and E.W. Myers, Finding All Spanning Trees of
Directed and Undirected Graphs. {\em SIAM J. Comput.} {\bf 7}
(1978), 280--287.

\bibitem{GuYe} G. Gutin and A. Yeo, On the number of connected convex subgraphs
of a connected acyclic graph. Submitted.

\bibitem{MIBENCH} M. R. Guthaus, J. S. Ringenberg, D. Ernst,
T. M. Austin, T. Mudge and R. B. Brown, MiBench: A free,
commercially representative embedded benchmark suite, In {\em
Proceedings of the WWC-4, 2001 IEEE International Workshop on
Workload Characterization}, (2001), 3--14.

\bibitem{kapoorA27} S. Kapoor, V. Kumar and H. Ramesh, An Algorithm
for numerating All Spanning Trees of a Directed Graph. {\em
Algorithmica} {\bf 27} (2000), 120--130.


\bibitem{kapoorSIAMJC24} S. Kapoor and H. Ramesh, Algorithms for
enumerating all spanning trees of undirected and weighted graphs.
{\em SIAM J. Comput.} {\bf 24} (1995), 247--265.

\bibitem{kreher} D.L. Kreher and D.R. Stinson, {\em Combinatorial
Algorithms: Generation, Enumeration and Search}, CRC, 1999.



\bibitem{mintyIEEETCT12} G.J. Minty, A simple algorithm for listing all trees of a
graph. {\em IEEE Trans. Circuit Theory} {\bf CT-12} (1965),  120.


\bibitem{mips} MIPS, \url{www.mips.com}

\bibitem{atasu2006} L. Pozzi, K. Atasu and P Ienne, Exact and
approximate algorithms for the extension of embedded processor
instruction sets. {\em IEEE Trans. on CAD of Integrated Circuits and
Systems}, {\bf 25} (2006), 1209--1229.

\bibitem{readN5} R.C Read and R.E Tarjan, Bounds on backtrack algorithms for
listing cycles, paths, and spanning trees. {\em Networks} {\bf 5}
(1975), 237--252.


\bibitem{tens} Tensilica, \url{www.tensilica.com}

\bibitem{trimaran} The Trimaran Compiler Infrastructure, \url{www.trimaran.org}


\bibitem{shiouraJORSJ38} A. Shioura and A. Tamura, Efficiently scanning all spanning
trees of
an undirected graph. {\em J. Operation Research Society Japan} {\bf
38} (1995), 331--344.



\bibitem{shiouraSIAMJC26} A. Shioura, A. Tamura and T. Uno, An optimal algorithm for
scanning all spanning trees of undirected graphs. {\em SIAM J.
Comput.} {\bf 26} (1997), 678--692.




\bibitem{yu} P. Yu and T. Mitra,
Satisfying real-time constraints with custom instructions. {\em
CODES+ISSS '05: Proceedings of the 3rd IEEE/ACM/IFIP international
conference on Hardware/software codesign and system synthesis}, ACM,
New York (2005), 166--171.


\end{thebibliography}


\end{document}
