\documentclass[11pt,twoside]{article}\usepackage{amssymb,latexsym,graphicx,hyperref}\usepackage{epstopdf}
\setlength{\evensidemargin}{+0.00in}   \setlength{\oddsidemargin} {+0.00in}
\setlength{\textwidth}     {+6.50in}
\setlength{\topmargin}     {-0.50in}   \setlength{\textheight}    {+9.00in}
\renewcommand{\baselinestretch}{1.1}
\parskip=5pt
\normalsize
\bibliographystyle{plain}
\makeatletter
\@addtoreset{equation}{section}
\makeatother
\renewcommand{\theequation}{\thesection.\arabic{equation}}
\newtheorem{theorem}{Theorem}\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}[section]
\newtheorem{conjecture}{Conjecture}[section]
\newtheorem{problem}{Problem}[section]
\newenvironment{proof}{{\sc Proof. }}{\hfill\vspace{0.2in}}
\newcommand{\drawline}  {\rule{5.0in}{.4mm}}
\pagestyle{myheadings}
\thispagestyle{plain}
\markboth
{\sc Tong {\it et al.}}
{\sc Approximating the Bandpass- problem}
\title{An approximation algorithm for the Bandpass- problem}
\author{Weitian Tong\thanks{Department of Computing Science, University of Alberta.
Edmonton, Alberta T6G 2E8, Canada.}\thanks{Email: {\tt weitian@ualberta.ca}}
\and
Zhi-Zhong Chen\thanks{Division of Information System Design, Tokyo Denki University.
Hatoyama, Saitama 350-0394, Japan.
Email: {\tt zzchen@mail.dendai.ac.jp}}
\and
Lusheng Wang\thanks{Department of Computer Science, City University of Hong Kong.
Kowloon, Hong Kong, China.
Email: {\tt cswangl@cityu.edu.hk}}
\and
Yinfeng Xu\thanks{Business School, Sichuan University.
Chengdu, Sichuan 610065, China.}\thanks{Email: {\tt yfxu@scu.edu.cn}}
\and
Jiuping Xu\thanks{Email: {\tt xujiuping@scu.edu.cn}}
\and
Randy Goebel\thanks{Email: {\tt rgoebel@ualberta.ca}}
\and
Guohui Lin\thanks{Correspondence author.  Email: {\tt guohui@ualberta.ca}}}
\date{\today}
\begin{document}
\maketitle
\begin{abstract}
The general Bandpass- problem is NP-hard and can be approximated by a reduction into the weighted -set packing problem,
with a worst case performance ratio of .
When , a maximum weight matching gives a -approximation to the problem.
In this paper, we call the Bandpass- problem simply the Bandpass problem.
The Bandpass problem can be viewed as a variation of the maximum traveling salesman problem,
in which the edge weights are dynamic rather than given at the front.
We present a -approximation algorithm for the problem.
Such an improved approximation is built on an intrinsic structural property proven for the optimal solution and
several novel schemes to partition a -matching into desired matchings.

\paragraph{Keywords:}
The Bandpass problem, maximum weight -matching, acyclic -matching, approximation algorithm, worst case performance ratio
\end{abstract}



\section{Introduction}
In optical communication networks,
a sending point uses a binary matrix  to send  information packages to  different destination points,
in which the entry  if information package  is {\em not} destined for point , or  otherwise.
To achieve the highest cost reduction via wavelength division multiplexing technology,
an optimal packing of information flows on different wavelengths into groups is necessary~\cite{BBN09}. 
Under this binary matrix representation,
every  consecutive 's in a column indicates an opportunity for merging information to reduce the communication cost,
where  is a pre-specified positive integer called the {\em bandpass number}.
Such a set of  consecutive 's in a column of the matrix is said to form a {\em bandpass}.
When counting the number of bandpasses in the matrix, no two of them in the same column are allowed to share any common rows.
The computational problem, the {\em Bandpass- problem},
is to find an optimal permutation of rows of the input matrix 
such that the total number of extracted bandpasses in the resultant matrix is maximized~\cite{BB04,BBN09,Lin11}.
Note that though multiple bandpass numbers can be used in practice, for the sake of complexities and costs,
usually only one fixed bandpass number is considered~\cite{BBN09}.


The general Bandpass- problem, for any fixed , has been proven to be NP-hard~\cite{Lin11}.
In fact, the NP-hardness of the Bandpass- problem can be proven by a reduction from the well-known {\em Hamiltonian path} problem~\cite{GJ79},
where in the constructed binary matrix , a row maps to a vertex, a column maps to an edge,
and  if and only if edge  is incident to vertex .
It follows that there is a row permutation achieving  bandpasses if and only if there is a Hamiltonian path in the graph.


On the approximability, the Bandpass- problem has a close connection to the weighted -set packing problem~\cite{GJ79}.
Given an instance  of a maximization problem ,
let  (, respectively) denote the value of the optimal solution (the value of the solution produced by an algorithm, respectively).
The performance ratio of the algorithm on  is .
The algorithm is a -approximation if .
By taking advantages of the approximation algorithms designed for the weighted -set packing problem~\cite{AH98,CH99},
the Bandpass- problem can be approximated within ~\cite{Lin11}.
Moreover, since the maximum weight matching problem is solvable in cubic time,
the Bandpass- problem admits a simple maximum weight matching based -approximation algorithm~\cite{Lin11}.
In the sequel, we call the Bandpass- problem simply the Bandpass problem.


In a preliminary version of this paper~\cite{TGD12},
Tong {\it et al.} presented a first improved approximation algorithm for the Bandpass problem using two maximum weight matchings.
Their algorithm has a worst case performance ratio of .
In more details, their algorithm computes a maximum weight matching in the edge-weighted graph constructed from the input matrix,
and then computes another maximum weight matching in the residual graph;
Through breaking cycles in the union of these two matchings, a collection of paths are achieved and concatenated into a Hamiltonian path.
When estimating the weight of this Hamiltonian path, the authors present an intrinsic structural property for the optimal row permutation,
and show that the weight of the second maximum weight matching is greater than or equal to a portion of certain bandpasses in the optima.
These special bandpasses in the optima are characterized using the first maximum weight matching.

Instead of breaking cycles in the union of two matchings,
Chen and Wang~\cite{CW12} presented an alternative to compute a second matching such that the union of the two matchings is guaranteed acyclic.
The keys to this success are two lemmas that partition a -matching (an acyclic -matching, respectively)
into  (, respectively) candidate matchings.
Still based on the structural property characterized in~\cite{TGD12},
this alternative algorithm achieves a better performance ratio of .


In this paper, we advance the novel -matching partitioning scheme to show that two edge disjoint -matchings
can be partitioned into  desired matchings such that the union of each of them and the very first maximum weight matching is guaranteed acyclic.
Including here all the detailed proofs missed from the two preliminary versions~\cite{TGD12,CW12},
we show that our new approximation algorithm has a performance ratio of .


\section{The approximation algorithm}
A reduction from the Hamiltonian path problem has been used to prove the NP-hardness of the Bandpass problem.
But the Bandpass problem does not readily reduce to the maximum traveling salesman problem (Max-TSP) \cite{GJ79} for approximation algorithm design.
The main reason is that, an instance graph of Max-TSP is {\em static}, in that all (non-negative) edge weights are given at the front,
while in the Bandpass problem the number of bandpasses extracted between two consecutive rows in a row permutation is permutation dependent.
Nevertheless, as shown in the sequel, our design idea is based on maximum weight -matchings for , and ,
similarly as in approximating Max-TSP~\cite{Ser84,HR00,COW05,PMM09}.
Formally, in Max-TSP, a complete edge-weighted graph is given, where the edge weights are non-negative integers,
and the goal is to compute a Hamiltonian cycle with the maximum weight.
Note that there are several variants of Max-TSP been studied in the literature.
In our case, the input graph is undirected (or symmetric) and the edge weights do not necessarily satisfy the triangle inequality.
The following Lemma~\ref{lemma1} states the currently best approximation result for Max-TSP.


\begin{lemma}
\label{lemma1}{\rm \cite{PMM09}}
The Max-TSP admits an -time -approximation algorithm, where  is the number of vertices in the graph.
\end{lemma}


In our Bandpass problem, since we can always add a row of all 's if needed,
we assume without loss of generality that the number of rows, , is even.
A {\em -matching} of a graph is a subgraph in which the degree of each vertex is at most .
A maximum weight -matching of an edge weighted graph can be computed in  time~\cite{Gab83,Ans87,MP95},
where  is the number of vertices and  is the number of edges in the graph.
Note that a -matching is a collection of vertex-disjoint cycles and paths.
A -matching is {\em acyclic} if it does not contain any cycle ({\it i.e.}, it is a collection of vertex-disjoint paths).


Given the input binary matrix , let  denote the -th row.
We first construct a graph  of which the vertex set is exactly the row set .
Between rows  and , the {\em static} edge weight is defined as the maximum number of bandpasses that can be formed between the two rows,
and is denoted as .
In the sequel we use row (of the matrix) and vertex (of the graph) interchangeably.


For a row permutation , its -th row is the -th row in the input matrix.
We call a maximal segment of consecutive 's in a column of  a {\em strip} of .
The length of a strip is defined to be the number of 's therein.
A length- strip contributes exactly  bandpasses to the permutation .
We use  to denote the set of all length- strips of , and .
Let  denote the number of bandpasses extracted from the permutation .
We have

Let  denote the number of pairs of consecutive 's in the permutation .
A length- strip contributes exactly  pairs to the permutation .
We have



\subsection{Algorithm description}
In our algorithm denoted as {\sc Approx}, the first step is to compute a maximum weight matching  in graph .
Recall that there are an even number of rows.
Therefore,  is a perfect matching (even though some edge weights could be ).
Let  denote the sum of its edge weights, indicating that exactly  bandpasses can be extracted from the row pairings suggested by .
These bandpasses are called the bandpasses of .


Next, every  involved in a bandpass of  is changed to .
Let the resultant matrix be denoted as ,
the resultant edge weight between rows  and  be 
--- which is the maximum number of bandpasses can be formed between the two revised rows,
and the corresponding residual graph be denoted as .
One can see that if an edge  belongs to , then the new edge weight .
In the second step of {\sc Approx}, we compute a maximum weight -matching  in graph ,
which is further decomposed in  time into two -matchings denoted as  and ~\cite{Har69,Die05}.
Let  denote the weight (the number of bandpasses) of  in the residual graph .
It is noted that no bandpass of  shares a  with any bandpass of .
Using  and  and , by Lemma~\ref{lemma41},
we can compute a matching  from  of weight at least  such that  is guaranteed acyclic.

In the third step, we use the -approximation algorithm described in~\cite{PMM09} to compute a Hamiltonian path  in 
whose weight is at least  of the maximum weight of a Hamiltonian path.
Then, using  and , by Lemma~\ref{lem:mine},
we can compute another matching  from  of weight at least  such that  is guaranteed acyclic.

In the last step, we choose the larger one between the two 's found in the last two steps,
and arbitrarily stack the paths in  to give a row permutation .
Note that the number of bandpasses extracted from , , is greater than or equal to .


\subsection{Performance analysis}
Let  denote the optimal row permutation such that its  is maximized over all row permutations.
Correspondingly,  denotes the set of length- strips in , which contributes exactly  bandpasses towards .
The key part in the performance analysis for algorithm {\sc Approx} is to estimate , as done in the following.


First, we partition the bandpasses of  into four groups: , , , .
Note that bandpasses of  do not share any  each other.
 consists of the bandpasses of  that also belong to matching  (such as the one between rows  and  in Figure~\ref{s2});
 consists of the bandpasses of  such that they are uniquely paired up to contribute a  each to form a bandpass of 
(the other  in each bandpass of  is thus not shared by any other bandpass of );
 consists of the bandpasses of , each of which shares a  with at least one bandpass of ,
and if it shares a  with only one bandpass of  then the other  of this bandpass of  is not shared by any other bandpass of ;
 consists of the remaining bandpasses of .
Figure~\ref{s2} illustrates some examples of these bandpasses, where bandpasses of  are in ovals and bandpasses of  are in boxes.
\begin{figure}[htb]
\begin{center}
\unitlength=0.4mm
\begin{picture}(220, 130)
\put(50, 10){}
\put(0, 30){}
\put(20, 35){\line(1, 0){200}}
\put(100, 30){}
\put(0, 40){}
\put(20, 45){\line(1, 0){200}}
\put(100, 40){}
\put(98, 28){\framebox(6, 22){}}
\put(101, 39){\oval(11, 18){}}
\put(111, 30){}
\put(50, 50){}
\put(0, 60){}
\put(20, 65){\line(1, 0){200}}
\put(100, 60){}
\put(0, 70){}
\put(20, 75){\line(1, 0){200}}
\put(100, 70){}
\put(0, 80){}
\put(20, 85){\line(1, 0){200}}
\put(100, 80){}
\put(98, 78){\framebox(6, 22){}}
\put(101, 79){\oval(11, 18){}}
\put(0, 90){}
\put(20, 95){\line(1, 0){200}}
\put(100, 90){}
\put(0, 100){}
\put(20, 105){\line(1, 0){200}}
\put(100, 100){}
\put(101, 99){\oval(11, 18){}}
\put(0, 110){}
\put(20, 115){\line(1, 0){200}}
\put(100, 110){}
\put(130, 110){}
\put(30, 100){}
\put(30, 110){}
\put(28, 98){\framebox(6, 22){}}
\put(160, 60){}
\put(160, 70){}
\put(158, 58){\framebox(6, 22){}}
\put(141, 97){}
\put(130, 70){}
\put(130, 80){}
\put(128, 78){\framebox(6, 22){}}
\put(130, 90){}
\put(130, 100){}
\put(131, 99){\oval(11, 18){}}
\put(81, 80){}
\put(180, 110){}
\put(180, 80){}
\put(180, 100){}
\put(180, 90){}
\put(182, 98){\oval(11, 18){}}
\put(191, 97){}
\put(50, 120){}
\end{picture}
\end{center}
\caption{An illustration of the bandpasses of  (in ovals) and the bandpasses of  (in boxes) for grouping purpose.
	A horizontal line in the figure represents a row, led by its index.
    Rows that are adjacent in  and/or row pairs of  are intentionally ordered adjacently.
	In this figure, rows  and  are adjacent in , denoted as , and edge  as well;
	the bandpasses between these two rows in  thus belong to .
	Edges , while ;
	the bandpasses between rows  and  and between rows  and  in  shown in the figure
	have their group memberships indicated beside them respectively.\label{s2}}
\end{figure}


By the definition of partition, we have

From these ``group'' definitions, we know all bandpasses of  are in .
Also, one pair of bandpasses of  correspond to a distinct bandpass of .
Bandpasses of  can be further partitioned into subgroups such that
a subgroup of bandpasses together with a distinct maximal subset of bandpasses of  form into an alternating cycle or path of length at least .
Moreover,
1) when the path length is even, the number of bandpasses of this subgroup of  is equal to the number of bandpasses of this subset of bandpasses of ;
2) when the path length is odd,
2a) either the number of bandpasses of this subgroup of  is  greater than the number of bandpasses of this subset of bandpasses of ,
2b) or the path length has to be at least  and
so the number of bandpasses of this subgroup of  is at least  of the number of bandpasses of this subset of bandpasses of .
It follows from 1), 2a) and 2b) that with respect to ,  contains at least  corresponding bandpasses.
That is,

Clearly, all bandpasses of  are in the residual graph ,
while none of  is in graph  since each one of them shares a  with at least a bandpass of .


Note that the bandpasses of  are paired up such that each pair of the two bandpasses share a  with a bandpass of .
Assume without loss of generality that these two bandpasses of  are formed between rows  and  and between rows  and ,
respectively, and that the involved bandpass of  is formed between rows  and  (see Figure~\ref{s2}).
That is, in the optimal row permutation , rows  and  are adjacent, and rows  and  are adjacent;
while edge .
We remark that these four rows are distinct, and conclude that edge .
The proof is simple as otherwise in the particular column a bandpass would be formed between rows  and ,
making the two bandpasses of  lose their group memberships ({\it i.e.}, they would belong to ).


\begin{lemma}
\label{lemma2}
Assume edge , and that one bandpass of  shares  with two bandpasses of .
Then in graph  edge  is adjacent to at most four edges in the optimal row permutation ,
at most two of which are incident at row ,
and at most two of which are incident at row .
\end{lemma}
\begin{proof}
The lemma is straightforward from the above discussion, and the fact that edge  does not belong to the Hamiltonian path .
\end{proof}


Continuing with the above discussion, assuming that edge ,
and that one bandpass of  shares  with two bandpasses of ,
which are formed between rows  and  and between rows  and , respectively (see Figure~\ref{s2}).
We know that in residual graph , between rows  and , in the same column there is a bandpass
(which contributes  towards the edge weight ).
We call bandpasses identified in this way the {\em induced} bandpasses.
From Lemma~\ref{lemma2}, edge  is adjacent to at most two edges of  incident at row .
It follows that in residual graph , row  can form induced bandpasses with at most four other rows.
In other words, the subgraph of  induced by the edges containing induced bandpasses, denoted as , is a -matching in .


\begin{lemma}
\label{lemma3}
 is a -matching in graph , and its weight .
\end{lemma}
\begin{proof}
From the above discussion,  is a -matching in residual graph .
Since the edge set of  and the edge set of  are the same, disregarding edge weights,  is a -matching of graph .
The second half of the lemma can be simply argued as follows.
Since every pair of bandpasses of  leads to an induced bandpass, all the edge weights in  sum up to at least ,
which is the number of bandpass pairs in .
This finishes the proof.
\end{proof}


In  time, a -matching such as  can be decomposed into two -matchings~\cite{Har69,Die05},
each of which is a collection of vertex-disjoint cycles or paths.


\begin{lemma}
\label{lem:HR}
Let  be a -matching of graph  such that no edge of  is also an edge of .
Then, we can partition the edge set of  into four matchings  
such that  is an acyclic -matching for all .
Moreover, the partitioning takes  time, where  is the inverse Ackerman function. 
\end{lemma}
\begin{proof}
Hassin and Rubinstein~\cite{HR00} have shown that we can compute two disjoint matchings 
 and  in  such that the following two conditions hold:
\begin{itemize}
\item
	Both  and  are acyclic -matchings of .
\item
	Each vertex of  is incident to at least one edge of . 
\end{itemize}
For convenience, let  be the set of edges in  but not in .
By the second condition,  is a matching.
Consider the graph .
Obviously,  is a collection of vertex-disjoint paths and cycles, and each cycle of  contains at least two edges of .
For each cycle  of , we mark an arbitrary edge of  that also belongs to .
Let  be the set of marked edges, and .
Then, both  and  are acyclic -matchings of . 

It is not hard to see that with the famous union-find data structure~\cite{Tar75}, 
the computation of  and  described in \cite{HR00} can be done in  time.
Once knowing  and , we can obtain  and  in  time. 
\end{proof}


In general, Lemma~\ref{lem:HR} cannot be improved by partitioning the edge set of 
 into three matchings instead of four matchings. To see this, it suffices to 
consider a concrete example, where  is just a cycle of length~4 and 
 consists of the two edges connecting nonadjacent vertices in .


Let  and  denote the two -matchings constituting to the maximum weight -matching  of residual graph .
Using Lemma~\ref{lem:HR} alone,  can be partitioned into four matchings  and
 can be partitioned into four matchings ,
such that  is an acyclic -matching for all  and .
The following lemma states a slightly better partition when we consider  and  simultaneously.


\begin{lemma}
\label{lemma41}
The weight of matching  is .
\end{lemma}
\begin{proof}
Let  and  denote the two -matchings constituting to the maximum weight -matching  of residual graph .
Based on the discussion in the last paragraph,
we firstly use Lemma~\ref{lem:HR} to partition the edge set of  into four matchings  and
the edge set of  into four matchings ,
such that  is an acyclic -matching for all  and .

Note that by Lemma~\ref{lem:HR},  is a matching and that  contains the marked edges,
each of which, say , is the lightest edge of the corresponding cycle, say , formed in .
 is an even cycle.
If  contains at least  edges, then .
The following process is to swap certain edges among  and  to guarantee property
\begin{itemize}
\item[(P)]
	that each of  for  and  for  is an acyclic -matching, and
	that  is a matching and  contains no length- cycles.
\end{itemize}

Let  be a length- cycle in , and assume that .
Then, we call edges  and  a {\em problematic pair}.
Our swapping process is to {\em resolve} such problematic pairs.
We distinguish three cases.


In the first case, edges  and .

Assume the other edges of  incident at  are , , , , respectively.
These four edges thus all belong to  and .
If at least three of them belong to , then in  three vertices among  have degree  and
thus they cannot be in the same connected component of .
We can move (exactly) one of edges  and  to , while maintaining property (P).

We examine next where exactly two of the four edges belong to .
Assume without loss of generality that .
If , then the connected component in  containing  has only one edge , which belongs to .
Thus, if the other edge of  incident at vertex  belongs to , we can move edge  from  to ,
and move edge  from  to ;
if the other edge of  incident at vertex  does not belong to  (and thus it must be in ),
we can move edge  from  to , and move edge  from  to .
Either way, we maintain property (P) while resolving a problematic pair of .

If , then vertices  and  have degree  in .
Thus, if the other edge of  incident at vertex  does not belong to , then vertex  has degree  in  as well.
We conclude that vertices  cannot reside in the same connected component of .
When  and  are not connected, we can move edge  from  to ;
when  and  are not connected, we can move edge  from  to , and move edge  from  to .
Again, either way, we maintain property (P) while resolving a problematic pair of .
Symmetric scenarios can be argued in the same way for vertices .
In the remaining scenario, the other edges of  incident at vertices  all belong to .
We then move edges  from  to ,
and move edges  (, respectively) from  to  (, respectively).
Note that none of these four edges would form with any other edge into a problematic pair.

Lastly, if , then vertices  and  have degree  in .
Thus, if the other edge of  incident at vertex  belongs to , then vertex  has degree  in .
We can move edge  from  to , and move edge  from  to .
If the other edge of  incident at vertex  does not belong to , then vertex  has degree  in  as well.
We conclude that vertices  cannot reside in the same connected component of .
When  and  are not connected, we can move edge  from  to , and move edge  from  to .
Symmetric scenarios can be argued in the same way for vertices .
In the remaining scenario, none of the other edges of  incident at vertices  belongs to ,
and that vertices  and  ( and ,  and ,  and , respectively) are connected in 
(, , , respectively).
It follows that we may move edge  from  to , move edge  from  to ,
and move edge  from  to , to resolve the problematic pair.


In the second case, edges  but .

Assume the other edges of  incident at  are , , respectively.
These two edges and edge  all belong to  and .
Without loss of generality, assume ;
it follows that vertices  and  have degree  in .
If one of edges  and  does not belong to , say , then we can move  from  to ,
while maintaining property (P).


If both edges  and  belong to , then vertices  and  have degree  in .
When the other edge of  incident at vertex  does not belong to  (but ),
we can move edge  from  to , and move edge  from  to ;
the symmetric scenario can be argued in the same way for vertex ;
When the other edge of  incident at vertex  and the other edge of  incident at vertex  both belong to ,
we can move edges  and  from  to ,
move edge  from  to ,
move edge  from  to ,
and move edge  from  to .
Note that none of these three edges ,  and  would form with any other edge into a problematic pair.


In the last case, edges  and .

Assume without loss of generality that  and .
Since  do not share any edge with , we consider the degrees of vertices  in  for .
If in one of these four acyclic -matchings, say , at least three of the four vertices have degree , say ,
then we can move edge  from  to , and thus the problematic pair of  is resolved.
In the other cases, in each  for , exactly two of the four vertices have degree .

Let the two edges of  incident at  (, respectively) be  and  ( and ,
 and ,  and , respectively).

If , then  and  both have degree  in one of  for , say in .
It follows that if the other edge of  incident at vertex  does not belong to ,
then we can move edge  from  to , and move edge  from  to  to resolve the problematic pair of ;
or if the other edge of  incident at vertex  does not belong to ,
then we can move edge  from  to , and move edge  from  to  to resolve the problematic pair of .
In the remaining scenario, the other edge of  incident at vertex  (vertex , respectively) belongs to .
Note that in either  or , vertex  has degree ,
and we assume without loss of generality that vertex  has degree  in .
Note also that vertex  has degree  in .
If edge , then vertex  has degree  as well, and thus
we can move edge  from  to , and move edge  from  to  to resolve the problematic pair of ;
if edge  but the other edge of  incident at vertex  does not belong to ,
then we can move edge  from  to , move edge  from  to ,
and move edge  from  to  to resolve the problematic pair of .
Therefore, we only need to argue the scenario where the other edge of  incident at vertex  belongs to .
Symmetrically considering , we may assume without loss of generality that the other edge of  incident at vertex  belongs to .
Consequently, vertices  all have degree  in , and thus  and at least one of  and  are not connected.
If  and  are not connected, we can move edge  from  to ,
and move edge  from  to  to resolve the problematic pair of ;
if  and  are not connected, we can move edge  from  to , move edge  from  to ,
and move edge  from  to  to resolve the problematic pair of .


If , then  and  both have degree  in one of  for , say in .
The following discussion is very similar to the above paragraph, though slightly simpler.
Firstly, if  and  are not connected in  ( and  are not connected in , respectively),
then we can move edge  (, respectively) from  to  (, respectively)
to directly resolve the problematic pair of .
Secondly, if the other edge of  incident at vertex  does not belong to ,
then we can move edge  from  to , and move edge  from  to  to resolve the problematic pair of ;
or if the other edge of  incident at vertex  does not belong to ,
then we can move edge  from  to , and move edge  from  to  to resolve the problematic pair of .
Symmetrically and without loss of generality that ,
if either of the other edges of  incident at vertices  and  does not belong to , the problematic pair can be resolved.
In the remaining scenario, we assume that vertices  and  have degree  in  (and ).
Note that vertices  all have degree  in  too.
If  and  are not connected in , then we can swap edges of  and of ,
and move edge  from  to , to resolve the problematic pair of .
Otherwise,  and  should not be connected in ,
and we can move edge  from  to , and move edge  from  to ,
to resolve the problematic pair of .


All the other pairs of edges occurring in  can be analogously discussed as in either of the above two paragraphs.
Repeatedly applying the above process to resolve the problematic pairs of , if any,
we achieve the Property (P) that each of  for  and  for  is an acyclic -matching,
and that  is a matching and  contains no length- cycles.
Subsequently, we let  denote the set of marked edges, guaranteeing that .


It follows that at least one of  has its weight greater than or equal to

where the last inequality follows from Lemma~\ref{lemma3} and the fact that .
\end{proof}


The next lemma says that Lemma~\ref{lem:HR} can be improved if the input -matching is acyclic. 

\begin{lemma}\label{lem:mine}
Let  be an acyclic -matching of  such that no edge of  is also an edge of .
Then, we can partition the edge set of  into three matchings 
such that  is an acyclic -matching for all .
Moreover, the partitioning takes  time. 
\end{lemma}
\begin{proof}
Note that  is a collection of vertex-disjoint paths.
We claim that if  has two or more connected components,
then we can connect the connected components of  into a single path by adding edges not in  to .
To see this claim, suppose that  has two or more connected components.
Obviously, we can connect the connected components of  into a single path by adding edges to . 
Unfortunately, some edges of  may have been added to . 
To remove edges of  from , we start at one endpoint of  and process the edges of  in order as follows: 
\begin{itemize}
\item
	Let  and  be the current endpoints of , and  be the current edge we want to process.
	Without loss of generality, we may assume that the removal of  from  yields a path  from  to 
	and another path  from  to , and further assume that the edges of  have been processed.
	Note that at most one of  and  is possible because .
	If , then we proceed to process the other edge incident to  than .
	Otherwise,  or  because  is a matching and at most one of  and  is possible.
	If , then we modify  by deleting edge  and adding edge  and
	proceed to process the other edge incident to  than .
	On the other hand, if , then we modify  by deleting edge  and adding edge  and
	proceed to process the other edge incident to  than . 
\end{itemize}

By the above claim, we may assume that  is a single path ,
and denote  for . 


We next detail how to partition the edge set of  into three required matchings , , and .
Initially, we set , , and .
Then, for  (in this order), we try to find a  such that
 is a matching and  is an acyclic -matching of . 
To explain how to find , fix an integer . 
Let  be the integer in  with , and  and  be the two integers in . 
If  (respectively, ) contains no path between  and ,
then we can set  (respectively, ) and we are done.
So, we may also assume that  contains a path  between  and  and
 contains a path  between  and .
See Figure~\ref{fig:3part}. 

Let  (respectively, ) be the neighbor of  in  (respectively, ),
and  (respectively, ) be the neighbor of  in  (respectively, ).
Then, none of edges , , and  can appear in  (respectively, ),
because  and neither  nor  has been processed.
So, all of , , , and  belong to .
Thus,  and  because  is a matching.
Consequently, one edge incident to  (respectively, ) in  belongs to  and the other belongs to .
Hence,  and . 

Since , either  or . 
We assume that ; the case where  is similar. 
Since  is a path between  and  in ,  contains no path between  and .
Thus,  is an acyclic -matching of .
Hence, we move  from  to . 
A crucial point is that the degree of  in  is . 
This is true, because  appears in both  and  and in turn cannot be incident to an edge in .
By this crucial point and the fact that  and  belong to the same connected component in ,
we know that  is an acyclic -matching of .
Therefore, we can set . 


\begin{figure}[ht]
\centerline{\includegraphics[angle=0,width=0.9\textwidth]{3part}}
\caption{An illustration of moving  from  to  and 
adding  to , where (1)~the dashed lines indicate edges in ,  
(2)~the thin solid lines indicate edges of  that have not been processed, 
(3)~the lines labeled with  (respectively, , or ) indicate edges in  
(respectively, , or ), and 
(4)~the two curves may contain edges of .} 
\label{fig:3part}
\end{figure}


Obviously, with the famous union-find data structure~\cite{Tar75},
the above partitioning of the edge set  into  can be done in  time. 
\end{proof}


In general, Lemma~\ref{lem:mine} cannot be improved by partitioning the edge set of  into two matchings instead of three matchings.
To see this, it suffices to consider a concrete example,
where  is just a path with edges , ,  and
 consists of edges  and . 


\begin{lemma}
\label{lemma42}
The weight of matching  is .
\end{lemma}
\begin{proof}
Note that graph  contains all bandpasses of , which is an acyclic -matching.
From Lemma~\ref{lemma1}, we can compute a Hamiltonian path  in  of weight at least  of the optimum,
and thus of weight at least .
The above Lemma~\ref{lem:mine} guarantees that

\end{proof}


\begin{theorem}
\label{theorem1}
Algorithm {\sc Approx} is an -time -approximation for the Bandpass problem.
\end{theorem}
\begin{proof}
The running time of algorithm {\sc Approx} is dominated by the computing for those maximum weight -matchings, for ,
which can be done in  time.
Since  is the maximum weight matching in graph , from Eq.~(\ref{eq2}) we have



Combining Eqs.~(\ref{eq4}) and (\ref{eq5}), we have for any real number ,



The permutation  produced by algorithm {\sc Approx} contains  bandpasses, as indicated at the end of Section 2.1.
From Lemmas~\ref{lemma41} and \ref{lemma42}, we have for any real number ,



Together with Eqs.~(\ref{eq3}) and (\ref{eq6}), the above Eq.~(\ref{eq7}) becomes,

where the last inequality is achieved by setting  and .
Note that for all , .
It then follows from Eqs.~(\ref{eq8}) and (\ref{eq1}) that


That is, the worst-case performance ratio of algorithm {\sc Approx} is at most .
\end{proof}


\section{Conclusions and future work}
In this paper, we presented a -approximation algorithm for the Bandpass problem (),
which improves the first non-trivial approximation () and a subsequent approximation ().
Our algorithm is based on maximum weight -matchings, for , similar to tackling the closely related Max-TSP.
The intrinsic structural property we proved for the optimal row permutation and the maximum weight matching is fundamental,
without which no better lower bound on the optimum can be built.
The schemes we developed to partition a -matching, for  and , into desired matchings are also interesting,
and could potentially be further improved.


For the Max-TSP, Serdyukov presented a -approximation algorithm based on
the maximum weight {\em assignment} (or called {\em cycle cover}) and the maximum weight matching~\cite{Ser84},
which has been improved to the currently best -approximation algorithm in Lemma~\ref{lemma1}.
We believe that the Bandpass problem can be better approximated by
either improving the two key -matching partitioning schemes presented in this paper,
or introducing new structural properties and/or new techniques;
yet we also believe that there will be a gap from , due to the ``dynamic'' edge weights.


On the other hand, Hassin and Rubinstein gave a randomized approximation algorithm for the Max-TSP
with expected performance ratio ~\cite{HR00} (which was subsequently de-randomized in \cite{COW05}).
It would be interesting to design a randomized approximation for the Bandpass problem too, with a better than  expected performance ratio.


\section*{Acknowledgement}
Weitian Tong, Randy Goebel, and Guohui Lin are supported in part by NSERC.


\begin{thebibliography}{10}

\bibitem{Ans87}
R.~P. Anstee.
\newblock A polynomial algorithm for -matching: An alternative approach.
\newblock {\em Information Processing Letters}, 24:153--157, 1987.

\bibitem{AH98}
E.~M. Arkin and R.~Hassin.
\newblock On local search for weighted packing problems.
\newblock {\em Mathematics of Operations Research}, 23:640--648, 1998.

\bibitem{BBN09}
D.~A. Babayev, G.~I. Bell, and U.~G. Nuriyev.
\newblock The bandpass problem: combinatorial optimization and library of
  problems.
\newblock {\em Journal of Combinatorial Optimization}, 18:151--172, 2009.

\bibitem{BB04}
G.~I. Bell and D.~A. Babayev.
\newblock Bandpass problem.
\newblock In {\em Annual INFORMS meeting}, 2004.
\newblock October 2004, Denver, CO, USA.

\bibitem{CH99}
B.~Chandra and M.~M. Halld\'{o}rsson.
\newblock Greedy local improvement and weighted set packing approximation.
\newblock In {\em ACM-SIAM Proceedings of the Tenth Annual Symposium on
  Discrete Algorithms (SODA'99)}, pages 169--176, 1999.

\bibitem{COW05}
Z.-Z. Chen, Y.~Okamoto, and L.~Wang.
\newblock Improved deterministic approximation algorithms for {Max} {TSP}.
\newblock {\em Information Processing Letters}, 95:333--342, 2005.

\bibitem{CW12}
Z.-Z. Chen and L.~Wang.
\newblock An improved approximation algorithm for the bandpass-2 problem.
\newblock In {\em Proceedings of the 6th Annual International Conference on
  Combinatorial Optimization and Applications (COCOA 2012)}, volume 7402 of
  {\em LNCS}, pages 185--196, 2012.

\bibitem{Die05}
R.~Diestel.
\newblock {\em Graph Theory}.
\newblock Springer, 3rd edition, 2005.

\bibitem{Gab83}
H.~Gabow.
\newblock An efficient reduction technique for degree-constrained subgraph and
  bidirected network flow problems.
\newblock In {\em Proceedings of the 15th Annual ACM Symposium on Theory of
  Computing (STOC'83)}, pages 448--456, 1983.

\bibitem{GJ79}
M.~R. Garey and D.~S. Johnson.
\newblock {\em Computers and Intractability: A Guide to the Theory of
  NP-completeness}.
\newblock W. H. Freeman and Company, San Francisco, 1979.

\bibitem{Har69}
F.~Harary.
\newblock {\em Graph Theory}.
\newblock Addison-Wesley, 1969.

\bibitem{HR00}
R.~Hassin and S.~Rubinstein.
\newblock Better approximations for {Max} {TSP}.
\newblock {\em Information Processing Letters}, 75:181--186, 2000.

\bibitem{Lin11}
G.~Lin.
\newblock On the {Bandpass} problem.
\newblock {\em Journal of Combinatorial Optimization}, 22:71--77, 2011.

\bibitem{MP95}
D.~L. Miller and J.~F. Pekny.
\newblock A staged primal-dual algorithm for perfect -matching with edge
  capacities.
\newblock {\em ORSA Journal on Computing}, 7:298--320, 1995.

\bibitem{PMM09}
K.~E. Paluch, M.~Mucha, and A.~Madry.
\newblock A 7/9 - approximation algorithm for the maximum traveling salesman
  problem.
\newblock In {\em Proceedings of the 12th International Workshop on APPROX and
  the 13th International Workshop on RANDOM}, volume 5687 of {\em LNCS}, pages
  298--311, 2009.

\bibitem{Ser84}
A.~I. Serdyukov.
\newblock An algorithms for with an estimate for the traveling salesman problem
  of the maximum.
\newblock {\em Upravlyaemye Sistemy}, 25:80--86, 1984.

\bibitem{Tar75}
R.~E. Tarjan.
\newblock Efficiency of a good but not linear set union algorithm.
\newblock {\em Journal of the ACM}, 22:215--225, 1975.

\bibitem{TGD12}
W.~Tong, R.~Goebel, W.~Ding, and G.~Lin.
\newblock An improved approximation algorithm for the bandpass problem.
\newblock In {\em Proceedings of the Joint Conference of the Sixth
  International Frontiers of Algorithmics Workshop and the Eighth International
  Conference on Algorithmic Aspects of Information and Management (FAW-AAIM
  2012)}, LNCS 7285, pages 351--358, 2012.

\end{thebibliography}
\end{document}
