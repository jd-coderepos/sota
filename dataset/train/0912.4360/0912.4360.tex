\documentclass[envcountsame]{tlp}


\bibliographystyle{acmtrans}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{subfigure}
\usepackage{epsfig}
\usepackage{graphics}
\usepackage{url}




\setcounter{secnumdepth}{3}




\newcommand{\point}{\mbox{\Huge}}
\newcommand{\incase}{:\!\!-\;}

\newcounter{polycons2ctr}
\newcounter{auxctr}
\newcounter{polycons1ctr}
\newcounter{ex:der-lastsymconsctr} 


\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{algorithm}{Algorithm}
\newtheorem{proposition}{Proposition}

\newtheorem{procedure}{Procedure}


\submitted {18 February 2008}
\revised {30 November 2009}
\accepted{11 December 2009}

\author[Manh Thang Nguyen et al.]{
    MANH THANG NGUYEN \\
	Deceased on June 3, 2009
    \and DANNY DE SCHREYE \\
	Department of Computer Science, K.~U.\ Leuven \\ Celestijnenlaan 200A, B-3001 Heverlee,
    Belgium \\
    Danny.DeSchreye@cs.kuleuven.ac.be
    \and J\"{U}RGEN GIESL \\
	LuFG Informatik 2, RWTH Aachen \\ Ahornstr.\ 55,  D-52074 Aachen, Germany \\
    giesl@informatik.rwth-aachen.de
    \and PETER SCHNEIDER-KAMP  \\
	Dept. of Mathematics and Computer Science, U.\ Southern Denmark \\ Campusvej 55, DK-5230 Odense M,
    Denmark \\
    petersk@imada.sdu.dk
        }

\title[Polynomial Interpretations for Termination Analysis of Logic Programs]{\textsf{Polytool}: Polynomial Interpretations as a Basis for Termination Analysis of Logic Programs}
\begin{document}
\maketitle
\begin{abstract}
Our goal is to study the feasibility of
porting termination analysis techniques developed for one programming paradigm to 
another paradigm. 
In this paper, we show how to adapt
termination analysis techniques based on polynomial interpretations - very well
known in the context of term rewrite systems (TRSs) -
to obtain new (non-transformational) 
termination analysis techniques for definite logic programs (LPs). 
This leads to an approach that can be seen as a
direct generalization of the traditional techniques in termination analysis of LPs, where
linear norms and level mappings are used. Our extension generalizes these to
arbitrary polynomials. We extend a number of standard concepts and results on termination
analysis to the context of polynomial interpretations. We also propose a constraint-based
approach for automatically generating polynomial interpretations that satisfy the
termination conditions. Based on this approach, we implemented a new tool, called
\textsf{Polytool}, for automatic termination analysis of LPs.
\\
\\
\end{abstract}

\begin{keywords}
Termination analysis, acceptability, polynomial interpretations.
\end{keywords}

\section{Introduction}\label{sec:intro}
Termination analysis plays an important role in the study of program correctness. A
termination proof is mostly based on a mapping from computational states to some
well-founded ordered set. Termination is guaranteed if the mapped values of the
encountered states during a computation, under this mapping, decrease w.r.t.\ the
order.

For LPs, termination analysis is done by mapping terms and atoms to a
well-founded set of natural numbers by means of norms and level mappings. Proving
termination is based on the search for a suitable norm and level mapping such
that
the resulting predicate calls decrease under the
mapping. 

Until now, most termination techniques for LPs are based on the use of
linear
norms and linear level mappings,
which measure the size of each term or atom as a linear combination of the sizes of its
sub-terms. For example, the \textsf{Hasta-La-Vista} system
\cite{SerebrenikandDeSchreye03} 
infers one specific linear norm and linear level mapping. In the context of numerical
computations, it includes a refinement on this, based on a case analysis. 
The tool \textsf{cTI}
\cite{MesnardBagnara05} uses a concrete linear norm. The analyzers \textsf{TermiLog}
\cite{lindenstrauss97,Termilog} and \textsf{TerminWeb} \cite{Codishetal99,terminWeb02} use
a combination of several linear norms to obtain an
approximation of the program and then infer linear level mappings for termination
analysis of the approximated program. However, the
restriction to linear norms and level mappings limits the power of termination analysis
considerably. 
To
illustrate this point, consider the following example, \emph{der}, that formulates rules
for computing the repeated derivative of a function in some variable
. This example from \cite{DeSchreyeSerebrenik01,NaomiWST97} is inspired by a
similar term rewriting example 
from \cite{Dershowitz95}.

\begin{example}[der]\label{exam:der}

We are interested in proving termination of this program w.r.t.\ the set of queries  is a ground term and  is an arbitrary term\}.  So
the set of queries is specified by a \emph{mode} that considers
the first argument of  as an input argument and the second as an output.

As
shown in \cite{NaomiWST97,MNTDannyd05}, the termination proof is impossible when using
a linear norm and a linear level mapping. Indeed,
it turns out that all existing non-transformational termination analyzers for LPs
mentioned above fail to prove termination of this example.
{\hfill{}}
\end{example}

In this paper, we propose a general framework for termination proofs of LPs based on
polynomial interpretations. Using polynomial interpretations as a basis for ordering
terms in TRSs was first introduced by Lankford in
\cite{Lankford79}. It is currently one of the best known and most widely used techniques
in TRS termination analysis.

We develop the approach within an LP context. 
Classical approaches in LP termination use 
interpretations that map to
natural numbers (using linear polynomial functions). In contrast, we will use interpretations that
map to polynomials (using arbitrary polynomial functions). To adapt the
classical LP approaches to polynomial interpretations, we use the concepts
of ``abstract norm'' and ``abstract level mapping''
\cite{Verschaetse&DeSchreye91}.
We show that with our new approach, one can also prove termination of programs
like Example \ref{exam:der}.

We also developed an automated tool (\textsf{Polytool}) for termination analysis based on
our approach \cite{Nguyen&DeSchreye06}. 
We embedded this within the constraint-based approach developed in
\cite{Decorteetal98} and combined it with the non-linear Diophantine constraint solver
developed by  Fuhs et al.\ \cite{Fuhsc07} (implemented in the \textsf{AProVE} system
\cite{Giesletal06}) to provide a completely automated system.

The paper is organized as follows. In the next section, we present some preliminaries. In
Section \ref{sec:interpretation}, we introduce the notion of polynomial interpretations
in logic programming and show how this approach can be used to prove termination.
In Section \ref{sec:automation}, we discuss the automation of the approach. In
Section \ref{sec:experiment}, we provide and discuss the results of our experimental
evaluation. We end with a conclusion in Section \ref{conclusion}.

\section{Preliminaries}\label{sec:preliminaries}


After
introducing the basic terminology of LPs in Section
\ref{subsec:notation}, we recapitulate the concepts of \emph{norms} and \emph{level
mappings} in Section \ref{subsec:norm&levelmapping} and explain their use for termination
proofs in Section \ref{subsec:conditions}.


\subsection{Notations and Terminology}\label{subsec:notation}

We assume familiarity with LP concepts and with the main results of logic programming
\cite{Apt90,Lloyd87}. In the following,  denotes a definite logic program.
We use , , and  to denote the sets of
variables, function, and predicate symbols of . Given an atom , 
denotes the predicate occurring in . Let ,  be predicates occurring in the
program . We say that  \emph{refers to}  if there is a clause in  such that
 is in its head and  is in its body. We say that  \emph{depends on}  if
 is in the transitive closure of the relation ``refers to''. If  depends on 
and vice versa,  and  are called \emph{mutually recursive}, denoted by . A clause in  with a predicate  in its head and a predicate  in
its body, such that  and  are mutually recursive, is called a 
\emph{(mutually) recursive clause}. Within such a recursive clause, the body-atoms 
with predicate symbol  are called \emph{(mutually) recursive atoms}. 
Let  and  denote, respectively, the sets
of all terms and atoms that can be constructed from . 

In this paper, we focus our attention on definite logic programs and SLD-derivations
where the left-to-right selection rule is used. Such derivations are referred to as
LD-derivations; the corresponding derivation tree is called \emph{LD-tree}. We say that a
query  \emph{LD-terminates} for a program , if the LD-tree for  is finite
(left-termination \cite{Lloyd87}). In the following, we usually speak of ``termination''
instead of ``LD-termination'' or ``left-termination''.

\subsection{Norms and Level Mappings}\label{subsec:norm&levelmapping}

The concepts of \emph{norm} and \emph{level mapping} are central in termination analysis
of logic programs.

\begin{definition}[norm, level mapping]\label{def:norm&levelmapping}
A \emph{norm} is a mapping . A \emph{level-mapping} is a mapping .
\end{definition}

Several examples of norms can be found in the literature \cite{Bossietal91}. One of the
most commonly used norms is the \emph{list-length norm}
 which maps lists to their lengths 
and any other term to 0. Another frequently used norm is the \emph{term-size} norm

which counts
the number of function symbols in a term. Both of them belong to a class of norms called
linear norms which is defined as follows.

\begin{definition}[linear norm and level mapping \cite{Serebrenik03}] \label{def:linearnorm}
A norm  is a \emph{linear} norm if it is recursively defined by
means of the following schema:
\begin{enumerate}
\item[-] for any variable ,
\item[-] where  and .
\end{enumerate}
Similarly, a level mapping  is a \emph{linear} level mapping if it is
defined by means of the following schema:
\begin{enumerate}
\item[-] where  and .
\end{enumerate}
\end{definition}
\subsection{Conditions for Termination w.r.t.\ General Orders}\label{subsec:conditions}

A
\emph{quasi-order} on a set  is a reflexive and transitive binary relation
 defined on elements of . We define the \emph{associated equivalence
relation}  as  if and only if  and .
A \emph{well-founded order} on  is a transitive relation  where there is no
infinite sequence  with . A \emph{reduction pair}
 consists of a quasi-order  and a well-founded order 
that are \emph{compatible} (i.e.,  implies ).
We also need the following notion of a call set.

\begin{definition}[call set]\label{def:callset}
Let  be a program and  be a set of atomic queries. The \emph{call
set}, , is the set of all atoms , such that a variant of
 is the selected atom in some derivation for , for some .
\end{definition}

Most often, one regards infinite sets  of queries. For instance,
this is the case in Example 1. As in Example 1,  is then specified in 
terms of modes or types. As a consequence, in an automated approach, a safe over-approximation
of  needs to be computed, using a mode or a type inference
technique (e.g.,
\cite{Bruynoogheetal05,GallagherHB05,HeatonACK00,Janssensetal92}).

In order to obtain a termination criterion that is
suitable for automation, one usually estimates the effect of the atoms in the
bodies of clauses
by suitable \emph{interargument relations}. This notion can be defined for arbitrary
reduction pairs.


\begin{definition}[interargument relation
\cite{DeSchreyeSerebrenik01}]
\label{def:interargument} Let  be a program,  be a
predicate in , and  be a reduction pair on . An
\emph{interargument relation} for  in  w.r.t.\  is a relation
 with the same arity as p:
1 \leq i \leq n, where:
\begin{enumerate}
\item[-]  is a boolean expression (in terms of
disjunction, conjunction, and negation) of inequalities  or ,
in which
\item[-]  are constructed from  by applying 
function symbols from .
\end{enumerate}
 is a \emph{valid} interargument relation for  in  w.r.t.\
 if and only if for every :  implies .
\end{definition}

\begin{example}[interargument relation]\label{exam:interagr}
Let  be the 
standard  program that computes list concatenation. Then
there are a number of valid interargument
relations. Consider the reduction
pair  corresponding to the list-length norm ,
i.e.,  if and only if  and  if and only if
.
For instance, valid 
interargument relations for  w.r.t.  are 
 , where  could be:
\begin{enumerate}
\item[-] ,
\item[-] ,
\item[-] , or
\item[-] 
\end{enumerate}
Of course, usually only the first two interargument relations
are useful for termination analysis.
{\hfill{}}
\end{example}
 

Finally, we need the notion of \emph{rigidity}, in order to deal with
bindings that are due to 
unification in LD-derivations. These bindings would have to be back-propagated
to the variables in the initial goal. We reformulate rigidity for arbitrary reduction
pairs.

\begin{definition}[rigidity - adapted from \cite{DeSchreyeSerebrenik01}] \label{def:rigidity}
A term or atom  is called \emph{rigid}
w.r.t.\ a reduction pair  if  holds for any
substitution . A set of terms (or atoms)  is called \emph{rigid}
w.r.t.\  if all its elements are rigid w.r.t.\ .
\end{definition}

\begin{example}[rigidity]\label{exam:rigidity}
The list  ( is a variable,  is a ground term) is rigid w.r.t.\ the reduction
pair  corresponding to the list-length norm.
For any substitution
, we have . Therefore,
 w.r.t. .

However, the list  is not rigid w.r.t.\ the reduction pair 
corresponding to the term-size norm , i.e., 
if and only if  and  if and only if . 
{\hfill{}}
\end{example}

The following definition introduces the desired termination criterion, i.e., it
recalls the definition of \emph{rigid order-acceptability} w.r.t.\ a set of atoms.


\begin{definition}[rigid order-acceptability
\cite{DeSchreyeSerebrenik01}]\label{def:rigidacceptability} 
Let  be a set of atomic queries. A  program  is
\emph{rigid order-acceptable} w.r.t.\  if there exists a reduction pair 
on  
where  is rigid w.r.t.\  and
where for each predicate  in , there is a valid  interargument
relation  in 
w.r.t.\  such that
\begin{enumerate}
\item[-] for any clause  in ,
\item[-] for any atom  such that ,
\item[-] for any substitution  such that the atoms
 are elements of their associated
interargument relations : 
                    \center{}.
\end{enumerate}
\end{definition}

Theorem \ref{thm:rigidacceptability} states that 
rigid order-acceptability is a sufficient condition for termination. 
We refer to \cite{Serebrenik03}, Theorems 3.32 and 3.54, for the 
proof of Theorem \ref{thm:rigidacceptability}.


\begin{theorem}[termination criterion by rigid order-acceptability]
\label{thm:rigidacceptability} If  is rigid
order-acceptable w.r.t.\ , then  terminates for any query in .
\end{theorem}

Rigid order-acceptability is sufficient for
termination, but is not necessary for it (see
\cite{DeSchreyeSerebrenik01}). With Definition \ref{def:rigidacceptability}
and Theorem \ref{thm:rigidacceptability}, proving termination of a program
requires verifying the rigidity of the call set, verifying the validity of interargument
relations for predicates,  and verifying the decrease conditions for the (mutually)
recursive clauses. 

We will not discuss here the decidability or undecidability results
related to various problems concerning: (i) the rigidity of the call set
and (ii) the validity of interargument relations. The interested reader may refer
to the relevant literature.

In the remainder of this paper we provide some answers to the question in the setting of
a given set , an inferred order based on polynomial interpretations, abstractions
of  based on types, type inference to approximate the call set, and
interargument relations
based on inequalities between polynomials. 



\section{Polynomial Interpretation of a Logic Program}\label{sec:interpretation}


The approach presented in the previous section can be considered a theoretical
framework for termination analysis of LPs based on general
orders on terms and atoms. In this section, we specialize it to orders
based on polynomial interpretations. 

We first introduce polynomial interpretations in Section \ref{poly_interpretation}. Then in
Section \ref{Termination poly_interpretation} we reformulate the termination
conditions for LPs from Section \ref{subsec:conditions} for polynomial interpretations. 


\subsection{Polynomial Interpretations}
\label{poly_interpretation}



In this paper, we only consider polynomials with natural numbers as
coefficients (so-called ``natural coefficients'').
Because natural numbers will occur many times in this paper, we will 
simply refer to them as ``numbers''.

We say that a variable  \emph{occurs} in a polynomial  if the polynomial
contains a monomial with a coefficient different from 0 and  occurs in
this monomial.
If  are all the variables occurring in a polynomial , we often
denote  as . For every polynomial ,
there is an associated polynomial function  .
For numbers or polynomials , we often write
``''
instead of ``''.
Given  and  we also have 
an associated polynomial function  . For such 
an associated function on an extended domain, we often write 
``'' to denote 
``''.








\begin{definition}[orders on polynomials]
\label{ordersonnaturals}
Let  and  be two polynomials.
Let  be all variables occurring
in  or . The quasi-order
  is defined as
 if and only if  for
all .
The strict order 
is defined as  if and only
if   for
all .
\end{definition}










Observe that  is a reduction pair.
In other words, 
 is well-founded and transitive,
 is reflexive and transitive, and  and 
 are compatible.
Let  we denote the set of all polynomials with natural
coefficients.  Note that all these polynomials  are \emph{weakly
monotonic}, i.e.,  for all  implies
.

A \emph{polynomial interpretation} maps
each function and each predicate symbol of the program to a polynomial.

















\begin{definition}[polynomial interpretation]
\label{def:interpretation}
A \emph{polynomial interpretation}  for a logic program 
maps each 
symbol  of arity  in  to a
polynomial .
\end{definition}

Every polynomial interpretation induces a norm and a level mapping.
Although it is standard in logic programming to distinguish between norms and level
mappings, to simplify the formalization, here
we will only introduce a level mapping and define it
on both terms and atoms.


\begin{definition}[polynomial level mapping]
\label{def:polynomiallevelmapping}
The \emph{level mapping} associated with a polynomial interpretation , 
is a mapping ,
which is defined recursively as: 
\begin{enumerate}
    \item[-]  if  is a variable,
    \item[-] ,
where . 
\end{enumerate}
\end{definition}













\noindent
Every polynomial interpretation induces corresponding orders.


\begin{definition}[reduction pair corresponding to polynomial interpretation]\label{def:order-on-atom}
Let  be a polynomial
interpretation. We define the relations  and  on
 as follows:
\begin{enumerate}
\item[-]  if and only if
 for any

\item[-]  if and only if
 for any

\end{enumerate}
\end{definition}

Again, observe that the orders induced by a polynomial interpretation form a reduction pair.






\begin{example}[polynomial interpretation for ``\textit{der}'']\label{exam:dist}
Let  be a polynomial interpretation with 

Then , since
.
\end{example}






\subsection{Termination of Logic Programs by Polynomial Interpretations}
\label{Termination poly_interpretation}















We now re-state Definition \ref{def:rigidacceptability} and Theorem
\ref{thm:rigidacceptability} for the special case of 
polynomial interpretations.
So instead of interargument relations for arbitrary orders as in Definition
\ref{def:interargument}, 
we now use
interargument relations \emph{w.r.t.\ polynomial interpretations}.

\begin{definition}[interargument relation w.r.t.\ a polynomial interpretation]
\label{def:polynomialinterargumentrelation}
Let  be a program,  be a
predicate in , and  be a polynomial interpretation. 
 is an \emph{interargument relation}  for  in  w.r.t.\

iff  is an interargument relation  for  in  w.r.t.\
.
\end{definition}



Instead of rigidity w.r.t.\ general orders as in Definition
\ref{def:rigidity}, we define \emph{rigidity w.r.t.\ polynomial interpretations}.



\begin{definition}[rigidity w.r.t.\ a polynomial interpretation]
\label{def:rigidity-preinterpretation}
A term or atom  is called
\emph{rigid w.r.t.\ a polynomial interpretation}
 iff
 is rigid w.r.t.\ , i.e., 
iff 
 holds for any
substitution . A set of terms (or atoms)  is called \emph{rigid}
w.r.t.\  if all its elements are rigid w.r.t.\ .
\end{definition}



For polynomial interpretations, rigidity can also be characterized in an
alternative way using \emph{relevant variables}.



\begin{definition}[relevant variables]\label{def:relevantvar}
Let  be a polynomial interpretation and  be a term or
atom. A variable  in
 is called \emph{relevant} w.r.t.\  if there exists a substitution
 of a term  for ,
such that
. 
\end{definition}


\begin{example}[relevant variables]
Let  and  be the interpretation corresponding to the
list-length norm ,
i.e., . Then
the only relevant variable of  is .{\hfill{}} 
\end{example}

\begin{proposition}[alternative characterization of rigidity]\label{prop:relevantvar}
Let  be a polynomial interpretation and  be a term or atom. 
Then  is rigid w.r.t.\
 iff  has no relevant variables w.r.t.\ .
\end{proposition}
\begin{proof}\label{proof:relevantvar}
Obvious from Definitions \ref{def:rigidity-preinterpretation} and  \ref{def:relevantvar}. 
\end{proof}



Using the notions of interargument relations and 
rigidity w.r.t.\ a
polynomial 
interpretation, we obtain the following specialization of Theorem
\ref{thm:rigidacceptability}: 

\begin{corollary}[termination criterion with polynomial rigid order-ac\-ceptability]
\label{prop:polynomialacceptability}
    Let  be a set of atomic queries and  be a program. Let  be a
polynomial interpretation,
where  is rigid w.r.t. 
and where for each predicate  in ,
there is a valid interargument relation 
 in  w.r.t.\
 such that 
\begin{enumerate}
    \item[-] for any clause  in ,
    \item[-] for any atom   such that ,
    \item[-] for any substitution  such that the atoms
	   are elements of their associated
interargument relations : \\
   \item[] \begin{center}.
 \end{center}
\end{enumerate}
Then  terminates for any query in  .
\end{corollary}
\begin{proof}
The corollary immediately follows from 
Theorem \ref{thm:rigidacceptability}.
\end{proof}

Corollary \ref{prop:polynomialacceptability} can be applied to verify termination of a
logic program w.r.t.\ a set of queries. More precisely, we have to check that all conditions
in the following termination proof procedure are satisfied by some polynomial interpretation 
. In Section \ref{sec:automation} we will discuss how to find such an interpretation
automatically.

\begin{procedure}[a procedure for automatic termination analysis]
The termination proof procedure derived from Corollary \ref{prop:polynomialacceptability}
contains the following three steps:
	\label{proof_procedure}
	\begin{enumerate}
		\item[] \textbf{\underline{Step 1}:} The call set  must
be rigid w.r.t.\ .  In other words, no query  in the call set may have a relevant
variable w.r.t.\ . 
\item[] \textbf{\underline{Step 2}:} For a clause that has 
body-atoms between the head and a (mutually) recursive body-atom,  valid interargument
relations of those atoms w.r.t.\  need to be inferred. 
\item[] \textbf{\underline{Step 3}:} For every clause, the polynomial level
mapping of the head w.r.t.\  should be larger than that of any (mutually) recursive
body-atom, given that interargument relations for intermediate body-atoms hold.  
	\end{enumerate}
\end{procedure}

For Step 2, we can follow the standard approach for LPs to verify that a
relation 
holds for all elements
of the Herbrand model (see e.g. \cite{Lloyd87}). To this end, 
one has to verify , where
 is the immediate consequence operator corresponding to the program .
Thus, we verify the validity of interargument
relations by first checking whether they are correct for the facts in the program. Then for every
clause, if the interargument relations hold for all body-atoms, the
interargument
relation for the head
should also hold.




\begin{example}[applying Corollary \ref{prop:polynomialacceptability} to the
``\textit{der}''-program]\label{rigid-order:der}
Consider again the ``\textit{der}''-program from Example \ref{exam:der}
and the  set of queries  is a ground
term and
 is an arbitrary term\}. Note that here, .
Let  be the polynomial interpretation from Example \ref{exam:dist}. 
Then no  has a relevant variable w.r.t.\
.
This
means that  is rigid w.r.t.\ .


Let  be an
interargument relation for the predicate .
Checking the validity of  is equivalent to
verifying the correctness of the following conditions for any substitution
:
\begin{center}
    \\\vspace{3mm} 
     and 
 implies \\  
    \\\vspace{3mm} 

     and 
 implies \\ 
\\\vspace{3mm}
     and 
 implies\\
    .\\\vspace{3mm}
\end{center}

To prove termination, we also need the following decrease conditions for any substitution
:
\begin{center}
    \\\vspace{2mm}
     satisfies  implies \\
\\\vspace{2mm}
    \\\vspace{2mm}
     satisfies  implies \\
\\\vspace{2mm}
    \\\vspace{2mm}
     satisfies  implies \\

\end{center}

The conditions above 
are equivalent to the following inequalities on the
variables . For the conditions on the valid interargument
relation, we obtain:

\vspace*{-.4cm}

{\small
}

\vspace*{-.2cm}



\noindent
And for the decrease conditions we obtain:


\vspace*{-.3cm}



{\scriptsize
}


\vspace*{-.2cm}


The above inequalities are easily
verified for all instantiations of the variables by numbers. 
Hence, the program terminates w.r.t.\ the set of queries . {\hfill{}}
\end{example}







\section{Automating the Termination Proof}
\label{sec:automation}

A key question is how to automate the search for a polynomial interpretation
and for interargument relations. In other words, to prove
termination of a logic program, one has to synthesize the coefficients of the polynomials
associated with the function and predicate symbols as well as the formulas
 defining the 
interargument relations.
In the philosophy of the constraint-based approach in
\cite{Decorteetal98}, we do not choose a particular polynomial interpretation
and particular interargument relations. Instead, we introduce a general symbolic form
for the polynomials associated with the function and predicate symbols and for
the interargument relations. As 
an example,  assume that polynomials of degree 2 are selected for the
interpretation. Then instead of assigning the polynomial  to a predicate symbol  of arity 2, we would, for example, assign
the \emph{symbolic} polynomial ,
where the  and  
are unknown coefficients ranging
over . So our approach for termination analysis works as follows:
\begin{itemize}
\item   introduce symbolic versions of the 
polynomials associated with function and predicate symbols, 
\item   express all conditions resulting from Corollary
\ref{prop:polynomialacceptability} as constraints on the coefficients
(e.g. ), 
\item   solve the resulting system of constraints to obtain values for the coefficients.
\end{itemize}
Each solution for this constraint system gives rise to a concrete polynomial
interpretation and to concrete valid interargument
relations such that all conditions of 
Corollary
\ref{prop:polynomialacceptability} are satisfied. 
Therefore, each solution gives a termination proof. 

In order to assign symbolic polynomials to the function and predicate symbols,
we make the decision of assigning linear polynomials to predicate symbols
and linear or simple-mixed polynomials to function symbols.
These classes of polynomials are defined as follows:
\begin{enumerate}
\item[-] \emph{The linear class:} each monomial of a polynomial in this class
contains at most one variable of at most degree 1:\\
  \vspace*{.2cm}
\item[-] \emph{The simple-mixed class:} each monomial of a polynomial in this
class contains either a single variable of at most degree 2 or several
variables of at most degree 1:\\ 

\end{enumerate}
The above classes of polynomials have proved to be particularly useful for
automated termination proofs of TRSs. 
For more details on these classes of polynomials we refer to
\cite{contejean05jar,Steinbach92}.
In our work, these choices resulted from extensive experiments
with different kinds of polynomials, where our goal was to optimize both the
efficiency and the power of the termination analyzer.








In Section \ref{Reformulating 
the Termination Conditions Symbolically}, we first reformulate the conditions
of our termination criterion in  Corollary
\ref{prop:polynomialacceptability}, using the above symbolic forms of
polynomials. Then in Section \ref{rewriting}, we transform these symbolic conditions
into constraints on the unknown coefficients of the symbolic polynomials. Afterwards, 
in Section \ref{Solving Diophantine Constraints} we show how these resulting
Diophantine constraints 
can be solved automatically. Finally, we conclude with a comparison of our
contributions with related work from term rewriting in Section \ref{Discussion}. 


\subsection{Reformulating the Termination Conditions}\label{Reformulating 
the Termination Conditions Symbolically}


In this subsection, we reformulate all termination conditions of Corollary
\ref{prop:polynomialacceptability}, i.e., of Procedure \ref{proof_procedure}. 
These include the rigidity property (Step 1),
the valid interargument relations (Step 2), and the
decrease conditions (Step 3). The reformulation results in
symbolic constraints, based on the
symbolic forms of the polynomial interpretations.

 
\subsubsection{Rigidity Conditions (Procedure \ref{proof_procedure}, Step 1)}\label{Rigidity Conditions}\hspace*{\fill}

\vspace*{.2cm}



\noindent
There are several ways to approximate  (e.g.,
\cite{Bruynoogheetal05,GallagherHB05,HeatonACK00,Janssensetal92}). 
In this paper, we apply the approximation technique
of \cite{GallagherHB05,Janssensetal92}. More precisely, we first
specify the set of queries as a set of rigid
type graphs. 
Then the technique in \cite{GallagherHB05,Janssensetal92} is used to 
compute a new, finite set of rigid type graphs which 
approximate
. Each of these new rigid type graphs represents
 a so-called
call pattern.
For further details, we
refer to \cite{GallagherHB05,Janssensetal92}.  

In the following, we 
recapitulate the notion of rigid type graphs
and show how rigidity conditions are derived from the set of call patterns. First,
we recall and extend some basic definitions from 
\cite{Janssensetal92}, which are based on linear norms and
level-mappings, to the case of general polynomial
interpretations.  Example \ref{der:symbolrigidcond} will illustrate these definitions.




\begin{definition}[rigid type graph \cite{Janssensetal92}] 
\label{rigidtypegraph}
A rigid type graph  is a 5-tuple, , where 
\begin{enumerate}
    \item[1.]  is a finite non-empty set of nodes.
    \item[2.]  such that 
 is a tree.
    \item[3.] 
 such that for every
arc , node  is an ancestor of node  in the tree .
    \item[4.]  is a function .
    \item[5.] If a node  is labelled with  and  has arity , then the node  has exactly  outgoing arcs (counting both 
and ). These arcs are labelled with the numbers
.  For every such arc ,  returns
the corresponding label from .
\end{enumerate}
\end{definition}




The intuition behind rigid type graphs is related to the tree representation 
of terms and atoms in LP. A rigid type graph generalizes the tree representation
of an atom by allowing:
\begin{itemize}
\item nodes labeled by \mbox{\rm \textbf{MAX}}, denoting any term,
\item nodes labeled by \mbox{\rm \textbf{OR}}, denoting the union of all denotations of the sub-graphs rooted at this node,
\item backarcs, denoting repeated traversals of a sub-graph.
\end{itemize}


For each rigid type graph representing a set of atoms , each node  in
the graph corresponds to a possible occurrence of a variable in the atoms of . The
set  is rigid w.r.t.\ the polynomial interpretation  iff all these variables
are not relevant w.r.t.\ . In the following, we formulate this
rigidity condition syntactically based on the rigid type graph.
\begin{definition}[critical path \protect\cite{Decorteetal98}]
\label{criticalpath}
    Let  be a rigid type graph. A 
critical path in  is a path of arcs from the tree  which goes from
the root node of the tree to a node 
labelled . 
\end{definition}


The following proposition is extended from \cite{Decorteetal93}, where in
\cite{Decorteetal93} each function or predicate symbol is associated with a
linear norm or level mapping. It provides a method to generate 
constraints for rigidity.



\begin{proposition}[checking rigidity by critical paths]
\label{rigiditysyntax}
    Let  be a program and  be
a rigid type graph representing a set of atoms . Let
 be a polynomial
interpretation, where for any function or predicate symbol  of arity  we
have . 
The set  is rigid w.r.t.\  iff 
on every critical path of  there exists an arc 
with , , and  such that
, where  is the arity of .
\end{proposition}
\begin{proof}
Since we only regard polynomials with non-negative
coefficients
, 
the condition  
is equivalent to the requirement that , whenever
. This in turn is equivalent to the condition that  is not 
involved in . Hence, the condition in the above proposition
is equivalent to the requirement that
for any 
node, there is at least one function or predicate symbol  on the critical path to this
 node, for 
which the argument position corresponding to the path is not involved in
. So equivalently, the atoms in the set  have no relevant variables
w.r.t.\ .
According to Proposition \ref{prop:relevantvar}, this is equivalent to rigidity 
w.r.t.\ .
\end{proof}



The following corollary shows how to express the above rigidity check as a
constraint on the coefficients of the polynomial interpretation. To this end,
we express the existence condition of an appropriate arc 
by a suitable multiplication.



\begin{corollary}[symbolic condition for checking rigidity]
\label{corol-rigid2}
    Let  be a rigid type graph
 representing a set of atoms  and let  be a critical path of . Let
 be all arcs in
 such that for all , 

is a function or predicate symbol of some arity  and . 
If for any such  we have
 
then  is rigid w.r.t.\ .
\end{corollary}


        \begin{figure}[t]
                \centering
\begin{picture}(220,170)(10,100)
                \includegraphics[scale=0.40]{der.eps}
\end{picture}
                \caption{Rigid type graph for Example \ref{der:symbolrigidcond}}
                \label{fig:example:rigidcondi-der}
        \end{figure}


\begin{example}[symbolic polynomial interpretation and 
rigidity constraints for the ``\textit{der}''-program]
\label{der:symbolrigidcond}
For Example \ref{exam:der},
we define a symbolic polynomial interpretation  as 
follows.








We will reformulate the termination conditions for this example in symbolic form. However
for reasons of space, we
will not give all polynomial constraints. Instead, in order to illustrate the main
ideas, in each sub-section we only present one constraint for the corresponding type of
conditions. 

Instead of checking termination of the ``''-program w.r.t.\
the set of queries  is a ground term,  is an
arbitrary term  
as in Example \ref{exam:der}, we now regard the set of queries  is of the form ,  
where  is a ground term constructed from the function symbols , , ,
, and  is an arbitrary term.  is represented by the type graph in
Figure \ref{fig:example:rigidcondi-der}. 

Obviously, termination of
the program w.r.t.\  also implies termination w.r.t. . 
This can be proved easily by showing
		that for any query , the program trivially 
terminates by finite failure. 


In our example,
type inference \cite{Janssensetal92} computes the call set ,
i.e., the graph in Figure \ref{fig:example:rigidcondi-der} also represents
. Its only critical path consists of just the arc from the root to the
node labelled \textbf{MAX}. Hence from 
the graph, the following rigidity
condition is generated according to Corollary \ref{corol-rigid2}: 
               
\hfill{}
\end{example}






\subsubsection{Valid Interargument Relations (Procedure \ref{proof_procedure}, Step 2)}
\label{Valid_Interargument_Relations}
\hspace*{\fill}

\vspace*{.2cm}

\noindent
Next we consider the other symbolic constraints, derived for valid interargument 
relations and decrease conditions. We will show that they all take the form:
\setcounter{polycons2ctr}{\value{equation}}


\noindent
where  and  are polynomials with natural
coefficients. Here,  is the tuple of all variables occurring in .


There are a number
of works on inferring valid interargument relations of predicates. In
\cite{Decorteetal98}, interargument relations are
formulated as inequalities between a linear
combination of the ``\textit{inputs}'' and a linear combination of the
``\textit{outputs}''. We will not define input and output arguments formally in this paper,
since we do not use them in our approach, but informally, inputs are the arguments of a
predicate symbol which are only called with ground terms and outputs are the remaining arguments.

We propose a new form of interargument relation, namely
\emph{polynomial}
interargument relations, which are of the following form: 

where  and  are polynomials with natural coefficients.

The form of interargument relations in \cite{Decorteetal98} can be
considered a special case of the form (\ref{interarg}) above, 
where  is constructed from the
input arguments only and  is only constructed from the
outputs.


Since the approach in \cite{Decorteetal98} only considers relations between
the input and output arguments of the predicates, it has
some limitations. In some cases, the desired relation does not compare
inputs with outputs, but the relation holds among the inputs only or among 
the outputs only. In particular, if all arguments of a predicate
are inputs (or outputs), then the approach in
\cite{Decorteetal98} fails to infer any useful relation among them. The following
example shows this point. It computes the natural division of the first and second
arguments of the predicate  and returns the result in its
third argument.

\begin{example}[div]
\label{div}


We consider the set of queries    and  are ground terms, and  is an arbitrary 
term\}.
This program terminates for all these queries. If we look at Clause (\ref{div2}),
the decrease in size between the head and the recursive body-atom can be established if
we can infer a suitable valid interargument relation for . This relation 
should imply that within Clause (\ref{div2}), the 
first argument of  is greater than its third argument. However, if we apply the
approach in \cite{Decorteetal98}, inferring such an interargument relation for
 is impossible. Since  the
first two -arguments are used as input and the last one is output,
the approach can only infer interargument
relations where a linear combination of the sizes of the first
and second arguments is greater than or equal to the size of the third
argument. Then, we cannot conclude 
that for every successful answer substitution for the call  in Clause
(\ref{div2}), the first -argument  is strictly greater than the 
third -argument .

In contrast, if we use Form (\ref{interarg}), then it
is possible to infer the following valid interargument relation for : 
 
Note that in the right-hand side   of the 
above inequality, we have both an input argument  and an output
argument .
This valid polynomial interargument relation guarantees that for any
successful answer substitution for
the call  in Clause (\ref{div2}), we have
 if
.
Our implementation in the system
\textsf{Polytool} is indeed able to infer this
interargument relation using the constraint solving technique explained below.
Therefore, \textsf{Polytool} can
prove termination of
``\textit{div}''. 
If
we used the form of interargument relations in \cite{Decorteetal98} instead,
\textsf{Polytool} would not be able to solve this problem.
\hfill{}.
\end{example}




Similar to the symbolic form of polynomial interpretations, we also use
a symbolic form of polynomial interargument relations. To this end,
we take
symbolic  polynomials  and
. For the inference of valid interargument relations, we then apply the technique
proposed in \cite{Decorteetal98}, cf.\ Procedure \ref{proof_procedure}, Step 2.
For any sequence of terms , let  abbreviate
the inequality  . 
The goal is to impose constraints on the polynomials  and  which
ensure that the corresponding interargument relation

is valid. To this end,
we generate for every clause of the program:

the constraint 

It is clear that
this formula has Form (\ref{polycons2}).






\begin{example}[symbolic interargument relation for the 
``\textit{der}''-program]
\label{symbolic-der}
 We continue Example \ref{der:symbolrigidcond} and
use linear polynomials for 
 and 
, i.e.,  and
. Hence, the 
the symbolic form of the polynomial interargument relation for the predicate   is

There are four clauses (\ref{der1}) -
(\ref{der4}) from which constraints for 
valid interargument relations are inferred. We only present the constraint
resulting from the last clause
(\ref{der4}):

Here, we obtain the constraint

{\hfill{}}		
\end{example}



\subsubsection{Decrease Conditions (Procedure \ref{proof_procedure}, Step
3)}\label{Decrease Conditions}\hspace*{\fill} 

\vspace*{.2cm}

\noindent
Finally, one has to require the decrease condition between the head and any
(mutually) recursive body-atom in any (mutually) recursive clause.
So for any clause 

of the program where 
 (i.e., where  and  are mutually recursive),
we require

Obviously, 
the formula is in Form 
(\ref{polycons2}). 


\begin{example}[constraints for
the decrease conditions of  ``\textit{der}''] 
\label{der:symboldecreasecond}
	There are three recursive clauses  
(\ref{der2}) - (\ref{der4}) 
where decrease conditions can be
inferred. We present the decrease condition for the 
	recursive body-atom  of the
last clause (\ref{der4}):  
        	
{\hfill{}}
\end{example}


\subsection{From Symbolic Conditions to Constraints on Coefficients}
\label{rewriting}

Our goal is to find a polynomial interpretation such that all
constraints generated in the previous section are satisfied. To this
end, we transform all these constraints into Diophantine
constraints. In this transformation, we first eliminate
implications, cf.\ Section \ref{First Phase}. Afterwards, in Section \ref{poly-inter-generating},  
the universally quantified variables
(e.g., ) are removed
and the former unknown
coefficients (e.g., )
become the new variables. If the resulting
Diophantine constraints can be solved, then the program under consideration is
terminating.

As we analyzed in Section \ref{Rigidity Conditions}, all generated rigidity
constraints have the Form (\ref{form:rigid}). Hence, these are already Diophantine
constraints which only contain unknown coefficients, but no universally
quantified variables. 

The other 
constraints, generated for the
valid interargument relations and the decrease conditions, have the following
form:
\setcounter{auxctr}{\value{equation}}
\setcounter{equation}{\value{polycons2ctr}}
 
where  and  are polynomials with natural
coefficients.
\setcounter{equation}{\value{auxctr}}

In the following, we introduce a two-phase method to transform
all constraints of Form (\ref{polycons2}) into
Diophantine constraints on the unknown coefficients. 


\subsubsection{First Phase: Removing Implications}\label{First Phase}\hspace*{\fill}

\vspace*{.2cm}

\noindent
The constraints of Form (\ref{polycons2}) are implications. In the first
phase, such constraints are transformed into inequalities without premises,
i.e., into constraints of the form
\setcounter{polycons1ctr}{\value{equation}}
 
However, here  is a polynomial with integer (i.e., possibly negative)
coefficients. The transformation is \emph{sound}:
if the new constraints of Form
(\ref{polycons1}) are satisfied by some
substitution which instantiates the unknown coefficients with numbers, 
then this substitution also satisfies the
original constraints of Form (\ref{polycons2}).


The idea for the transformation is the following. Constraints
of the form (\ref{polycons2}) may have an arbitrary number  of
premises . We first transform them into
constraints with at most 
one premise. 
Obviously,  implies . Thus, instead
of (\ref{polycons2}), it would be sufficient to demand


So in order to combine the  polynomials in the premise, we can use the
polynomial . Then instead
of (\ref{polycons2}), we may require

A similar method
was also used  for termination
analysis of logic programs in \cite{Decorteetal98} and  for termination of term rewriting
in \cite[Section 7.2]{JAR07} to transform
disjunctions of polynomial inequalities into one single inequality.


For example, the constraint

can now be transformed into

Since the latter constraint is valid, the former one is valid as well.

However, in order to make the approach more powerful, one could also use other
polynomials  in order to combine the  inequalities in the
premise. The reason is that if  is restricted to be the
addition, then many valid constraints of the form (\ref{polycons2}) would be
transformed into invalid ones. For example, the valid constraint

would be transformed into the invalid constraint

For instance, the constraint does not hold for
, , and .



To make the transformation more general and more powerful,
we therefore permit
the use of \emph{arbitrary} polynomials  with natural
coefficients. In the above example, now the resulting constraint

would indeed be valid for a suitable choice of . For instance,
one could choose  to be the addition of the first argument with
the square of the second argument (i.e., ). 

By the introduction of the new polynomial , 
every constraint of the form (\ref{polycons2}) can now be transformed into an
implication with at most one premise. It remains to
transform such implications further into unconditional 
inequalities.
Obviously, instead of 

it is sufficient to demand 

This observation
was already used in the work of \cite{Decorteetal98} and also in termination
techniques for term rewriting  
to handle such conditional
polynomial inequalities
\cite{CADE98,CADE07}.

However, the approach can still be improved.
Recall that we used an arbitrary polynomial  to combine the
polynomials in the former premises. In a similar way, one could also apply an
arbitrary polynomial   to the polynomials  and
 in
the former conclusion.
To see why this can be necessary, consider the valid constraint

With the transformation of (\ref{version1}) into 
(\ref{version2})
above, it would be transformed into the unconditional
constraint

which is invalid. 
We have encountered several examples of this kind in our experiments, 
which motivates this further extension. In such examples, it 
would be better to apply a suitable
polynomial   to the polynomials  and  in the former
conclusion. Then we would obtain

instead. By choosing , now the resulting constraint
is valid.

So to summarize, in the first phase of our transformation,
any constraint of the form
(\ref{polycons2})
is transformed into the  unconditional constraint

Here,  and  are two arbitrary
new polynomials. The only requirement that we have to impose is that
  must not be a constant. Indeed, if  would 
be a constant, then (\ref{newpolycons}) no longer implies that
(\ref{version1}) holds for all instantiations of the variables in the
polynomials . 
Note that we do not need a similar requirement on .
If a constant  would satisfy (\ref{newpolycons}), then 
(\ref{polycons2}) trivially holds.
 The following proposition proves the soundness of this transformation. 






\begin{proposition}[Soundness of Removing Implications]\label{Soundness of First Phase of the Transformation} 
Let  and  be two polynomials with
natural coefficients, where  is not a constant.
Moreover, let  be
arbitrary polynomials with  natural coefficients.
If

is valid, then

is also valid.
\end{proposition}
\begin{proof}
For any tuple of
numbers , let
 and 
denote the numbers that result from  and  by instantiating the
variables  by the numbers . So if  is the
polynomial ,
then . 

Suppose that there is a tuple of numbers 
 with

for all . We have to show that then
 holds as well.

Since  only has natural coefficients, it is weakly monotonic.
Thus,
 for all 
implies
 and thus,
.
The prerequisites of the proposition ensure 

for all instantiations of the variables. Hence, we also obtain
\linebreak
 or, equivalently,

Now suppose that . Since 
 and  are \emph{numbers} (not
polynomials with variables), we would then have . Since 
  only has non-negative coefficients and since it is not a
constant, it is strictly monotonic. Thus,   would imply 

in contradiction to (\ref{aux}). Hence, we have , as desired. 

\end{proof}

For the symbolic form of  and
, we again choose linear
or simple-mixed  polynomials. 
From our experiments, this choice
provided good results on the benchmark programs, while remaining reasonably 
efficient. 
By applying Proposition \ref{Soundness of First Phase of the Transformation},
we can now transform all constraints for the termination proof into unconditional constraints
of the form (\ref{polycons1}). If there exists a substitution of the unknown
coefficients by numbers that makes the resulting unconditional constraints valid,
then the same substitution also satisfies the original conditional constraints.

\begin{example}[applying Proposition \ref{Soundness of First Phase of the
Transformation} to the  ``\textit{der}''-program] 
\label{ex-der:sym_cons} 
We choose the decrease
condition (\ref{der:decreasecons})
in Example \ref{der:symboldecreasecond}
as an example showing how
to transform an implication 
into an unconditional constraint. 

Since the constraint (\ref{der:decreasecons}) has only one premise, here the
polynomial  has arity 1. We
choose a simple-mixed form for  and a linear form for 
:

Since  must not be a constant, one also has to impose the constraint
            

Now we can transform (\ref{der:decreasecons})  into an unconditional
constraint. Here, we use the following abbreviations:

Then  (\ref{der:decreasecons}) is the constraint

and its transformation yields

By applying standard simplifications, the constraint can be rewritten to  
the following form:
\setcounter{ex:der-lastsymconsctr}{\value{equation}}

where  are 
polynomials over the unknown coefficients
, , , , and
 with  and  with .
For example, we have

\hfill{}
\end{example}
\subsubsection{Second Phase: Removing Universally Quantified Variables}\label{poly-inter-generating}\hspace*{\fill}

\vspace*{.2cm}

\noindent
In this phase, we transform any constraint of the form
\setcounter{auxctr}{\value{equation}}
\setcounter{equation}{\value{polycons1ctr}}
 
into a set of Diophantine
constraints on the unknown coefficients. 
The transformation is again \emph{sound}:
if
there is a solution for the resulting set of Diophantine constraints,
then 
this solution also satisfies 
the original constraint (\ref{polycons1}).
\setcounter{equation}{\value{auxctr}}

We use a straightforward transformation proposed by \cite{Hongetal98}, which
is also  used in all
related 
tools for termination of term rewriting. One only requires that all
coefficients of the polynomial  are non-negative integers. Obviously, the criterion
is only sufficient, because, for instance,
, but  does not have non-negative
coefficients only.

\begin{example}[removing universally quantified variables for the ``\textit{der}''-program] 
\label{positivenessexample}
We continue the transformation of Example \ref{ex-der:sym_cons}. Here, we
obtained the constraint (\ref{ex:der-lastsymcons}).
We derive the following set of Diophantine 
constraints which contains the unknown coefficients ,
, , , , and 
 as variables: .
\hfill{}
\end{example}


\subsection{Solving Diophantine Constraints}
\label{Solving Diophantine Constraints}

The previous sections showed that one can formulate all termination conditions in
symbolic form and that one can transform them automatically into a set of Diophantine
constraints. The problem then becomes solving a system of non-linear
Diophantine constraints with the unknown coefficients as variables.
If the Diophantine constraints are solvable, then the logic program under
consideration is terminating. 
Solving such problems has been studied 
intensively, especially in
the context of constraint logic programming.
Moreover, there are approaches from termination of term rewriting in order to
solve such restricted Diophantine constraints automatically e.g.,
\cite{SMTCADE09,contejean05jar,Fuhsc07}.
In
\cite{Fuhsc07}, Diophantine constraints are encoded as a SAT-problem, and then a SAT
solver is used to solve the resulting SAT-problem. As shown in \cite{Fuhsc07},
this approach is significantly more efficient than solving 
Diophantine constraints by 
dedicated  solvers like \cite{contejean05jar} or by standard
implementations of constraint logic programming like in \textsf{SICStus Prolog}.


\begin{example}[solving Diophantine constraints for the``\textit{der}''-program]
\label{der:diocondsolving}
We start with the symbolic polynomial interpretation
from Example \ref{der:symbolrigidcond} (e.g., with
) 
and obtain the solution  and , 
which corresponds to
. Similarly, we
start with the symbolic form of the polynomial interargument relation as in
Example \ref{symbolic-der}:

Then we get the solution , , , .
This corresponds to the interargument relation
.
So we obtain the concrete simple-mixed polynomial interpretation from Example
\ref{exam:dist} and the concrete interargument relation from Example \ref{rigid-order:der}.
\hfill{}
\end{example}




\subsection{Relation to Approaches from Term Rewriting}
\label{Discussion}

Finally, we briefly discuss the connection between our approach for automated
LP termination proofs  from Section \ref{Reformulating 
the Termination Conditions Symbolically} - \ref{Solving Diophantine Constraints} and related approaches used for
termination analysis of TRSs.

Section \ref{Reformulating 
the Termination Conditions Symbolically} describes how to obtain constraints for a
symbolic polynomial order which guarantee that the requirements
of our termination criterion are fulfilled. This is similar
to related approaches used in term rewriting. Here, one also chooses
a symbolic polynomial interpretation and constructs
corresponding inequalities.
If one applies polynomial interpretations
directly for termination analysis of TRSs, then these
inequalities ensure that every rewrite rule is strictly decreasing.
If one uses more sophisticated termination techniques like the
dependency pair method \cite{ArtsGiesl00,JAR07,Hirokawa_Middeldorp04}, then one
builds inequalities which ensure 
that dependency pairs are weakly or strictly decreasing and that
rules are weakly decreasing. The decrease conditions of
dependency pairs correspond to our decrease conditions in Section \ref{Decrease Conditions}
and the requirement that rules are weakly decreasing roughly
corresponds to our symbolic constraints for valid interargument
relations in Section \ref{Valid_Interargument_Relations}. Still, there are
subtle
differences. For example, in
LPs, a predicate symbol may have several output arguments which is the
reason for the different polynomials  and  in our polynomial
interargument relations. Moreover, while term rewriting uses matching
for evaluation, in logic programming one uses unification. This is the
reason for our additional rigidity conditions in Section \ref{Rigidity Conditions}.

The approach in Section \ref{rewriting} shows how to find suitable values for
the symbolic coefficients. This is the same problem as in
the corresponding techniques for term rewriting. However, the
usual techniques in term rewriting can only handle unconditional
inequalities. Therefore, we have developed a new method in Section \ref{First Phase}
to remove conditions. This is a new contribution of the present paper.
In fact, after having developed this contribution for the current paper, due
to its success in the tool \textsf{Polytool}, two of the authors
of the current paper later even adapted this method to term rewriting (see
\cite[Footnote 14]{MAXPOLO}). 

The techniques of the short sections \ref{poly-inter-generating} and \ref{Solving Diophantine
Constraints}
are identical to the corresponding approaches 
used in term rewriting. We only included them here in order
to have a self-contained presentation of our approach
and to finish its illustration with the ``''-example.

\section{Experimental Evaluation}
\label{sec:experiment} 


In this section we discuss the experimental evaluation of our
approach. We implemented our technique in a system called \textsf{Polytool} 
\cite{Nguyen&DeSchreye06} written in \textsf{SICStus Prolog}.\footnote{For the
source code, we refer to \url{http://www.cs.kuleuven.be/~manh/polytool}.} 
Essentially, the \textsf{Polytool} system consists of four modules:
The
first module is the type inference engine,
where we use the
inference
system of 
\cite{GallagherHB05}.
The second module 
generates all termination conditions using symbolic polynomials
as in Section \ref{Reformulating 
the Termination Conditions Symbolically}. 
The third module transforms the resulting polynomial constraints 
into Diophantine constraints, as in Section
\ref{rewriting}. 
The final module is a Diophantine
constraint solver, cf.\ Section \ref{Solving Diophantine Constraints}. 
We selected the SAT-based Diophantine solver \cite{Fuhsc07} 
of the \textsf{AProVE} tool \cite{Giesletal06}.







We tested the performance of \textsf{Polytool} on 
a collection of 296 examples. The collection (Table
\ref{table1}) consists of all
benchmarks for logic programming from the \emph{Termination Problem
Data Base} (TPDB),\footnote{\url{http://www.termination-portal.org/wiki/Termination_Competition}}
where all examples that contain arithmetic or
built-in predicates were removed.  




{\sf Polytool} applies the following strategy:
first, we search for a linear polynomial interpretation. If
we cannot find such an interpretation satisfying the termination conditions,
then we 
search for a simple-mixed polynomial interpretation. More precisely, then we
still interpret predicate symbols by linear polynomials, but we map function
symbols to simple-mixed polynomials.
We use
  similar symbolic polynomials for 
 and  from
Section \ref{First Phase}: if the polynomial interpretation is linear, 
  then both  and  are linear. Otherwise, we use a linear
form for  and a simple-mixed form for . 
The domain for all
unknown coefficients in the generated Diophantine constraints is fixed to the set
.
The experiments were performed 
on an AMD 64 bit, 2GB RAM running Linux.

We performed an experimental comparison with other leading systems for
automated termination analysis of logic programs,
namely: \textsf{Polytool-WST07}, \textsf{cTI-1.1} \cite{MesnardBagnara05}, \textsf{TerminWeb}
\cite{Codishetal99,terminWeb02}, \textsf{TALP} \cite{OhlebuschAAECC}
and \textsf{AProVE}
\cite{Giesletal06}. 
For \textsf{TALP}, the option of non-linear polynomial
interpretations was chosen. For \textsf{cTI-1.1}, we selected the 
``default'' option. For
\textsf{AProVE} and \textsf{TerminWeb}, the fully automatic modes were
chosen. We did not include the tool \textsf{Hasta-La-Vista}
\cite{SerebrenikandDeSchreye03} in the evaluation because it is a predecessor of
\textsf{Polytool}.
We used a time limit of 60 seconds for testing each benchmark on each
termination tool. This time limit is also used in the
annual termination
  competition.



In Table \ref{table1},
we give the numbers of benchmarks which
are proved terminating (\textsf{"YES"}), the number of benchmarks which could
not be proved terminating but where processing ended within the time limit
(\textsf{"FAILURE"}), and the number of benchmarks where the tool did not stop
before the timeout (\textsf{"TIMEOUT"}). The number in square brackets is the
average runtime (in seconds) that a particular tool uses to prove termination
of benchmarks (or fails to prove termination of them within the time
limit). The detailed experiments (including also the source code of the
benchmarks and the termination proofs 
produced by the tools) can be found at 
\url{http://www.cs.kuleuven.be/~manh/polytool/POLY/journal07.html}.
Note that the two examples  and  presented
in this paper do not occur in the TPDB. For completeness we just mention that
\textsf{Polytool} and \textsf{AProVE} succeed on , whereas
\textsf{cTI-1.1}
and
\textsf{TerminWeb} fail, and \textsf{TALP} reaches the timeout.
For , all systems  except \textsf{TALP} succeed.
In the next sub-sections we discuss the results of the experiments. For a more
detailed discussion, we refer to \cite{ThangThesis}.
\begin{table}[ht]

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
     & \textsf{TALP} & \textsf{cTI-1.1} & \textsf{TerminWeb}	 &  \textsf{Polytool} & \textsf{AProVE}\\ \hline
\textsf{YES} & 163 [2.54] & 167 [0.06]      & 177 [0.54]  & 214 [4.28] & 232 [6.34]             \\ \hline
\textsf{FAILURE} & 112 [1.45] & 129 [0.05]      & 118 [0.6] & 62[10.48]    & 57 [19.08]         \\\hline
\textsf{TIMEOUT} & 21  & 0      & 1   & 20     & 7            \\\hline
\end{tabular}
\end{center}
\caption{The results for 296 benchmarks of the TPDB}
\label{table1}
\end{table}

\subsection{Comparison between \textsf{Polytool} and \textsf{cTI-1.1}}
\label{polytool-cti}

Similar to \textsf{Polytool}, \textsf{cTI-1.1} deploys a global constraint-based approach to termination
analysis. However, different from \textsf{Polytool}, in \textsf{cTI-1.1} termination
inference of the analyzed program relies on its two main abstract
approximations: a program in \textsf{CLP()}, where all terms of
the program are mapped to expressions in  according to a fixed
symbolic norm (e.g., the symbolic\footnote{The difference between the
``term-size norm'' and the ``\emph{symbolic} term-size norm'' is that the
``term-size norm'' maps all variables to , whereas the
``symbolic term-size norm'' maps any variable to itself (as in polynomial
interpretations).}
term-size norm by default), and a program in
\textsf{CLP()}, where  denotes the booleans, which is obtained from the
program in \textsf{CLP()} by mapping any number to
	, any variable to itself, and addition to logical conjunction. The
		purpose of these abstractions is to capture the decrease conditions
		(the program in \textsf{CLP()}) and the boundedness information
			(the program in \textsf{CLP()}) of the program.

As shown in Table \ref{table1}, \textsf{Polytool} outperforms
\textsf{cTI-1.1}. The only benchmark where \textsf{cTI-1.1} can prove
termination and \textsf{Polytool} fails is the example
\textsf{incomplete2.pl} in the directory \textsf{SGST06} of the TPDB. 
However, if we reset the range for the values of the unknown coefficients in the
generated Diophantine constraints to , then \textsf{Polytool}
can prove termination for the example as well.

There are several reasons for the less powerful performance of \textsf{cTI-1.1}
in comparison with \textsf{Polytool}.  
First of all, \textsf{cTI-1.1} uses a fixed symbolic norm 
to map the analyzed program to a program in
\textsf{CLP()}, for which all termination conditions are
formulated. However, in some cases, the selected symbolic norm is not suitable
to capture the decrease in the analyzed program. Then as
a result, \textsf{cTI-1.1} cannot prove termination. The TPDB
contains a number of such benchmarks, e.g., \textsf{flat.pl},
\textsf{normal.pl} in the \textsf{talp} directory and
 \textsf{countstack.pl}, \textsf{factor.pl},
\textsf{flatten.pl} in the \textsf{SGST06} directory.






Secondly, when we use the term-size or list-length norm for
the abstract approximation in \textsf{cTI-1.1}, all constant symbols are mapped to the same
number in .
As a result, \textsf{cTI-1.1} fails  for examples where
the difference among constant symbols plays a role for the termination
behavior. 
In \textsf{Polytool}, different constant symbols can be mapped to different
numbers in . Therefore, termination of 
examples such as \textsf{simple.pl} in the
\textsf{talp} directory,
\textsf{pl2.3.1.pl} in the \textsf{plumer} directory, \textsf{at.pl} in the
\textsf{SGST06} directory, etc. can be proved, whereas \textsf{cTI-1.1} fails.



Thirdly, since termination analysis of \textsf{cTI-1.1} is based on linear
symbolic norms, it cannot prove termination of
programs such as Example \ref{exam:der} or the example \textsf{hbal\_tree.pl} in
the TPDB. 
In contrast,
\textsf{Polytool} can prove termination of these examples using simple-mixed
polynomial interpretations. 

Finally, there are examples like \textsf{applast.pl},
\textsf{bappend.pl},
\textsf{blist.pl}, \textsf{btappend.pl}, \textsf{btapplast.pl},
  \textsf{confdel.pl} and
\textsf{btree.pl} in the \textsf{SGST06} directory, 
whose termination cannot be proved by
\textsf{cTI-1.1}, since
\textsf{cTI-1.1} only uses groundness instead of type analysis.
The termination proof of these examples also fails with
 \textsf{TALP} for the same reason. In
contrast,
\textsf{Polytool} and \textsf{AProVE}
succeed for them and \textsf{TerminWeb} succeeds for some of them (i.e., \textsf{applast.pl},
	\textsf{bappend.pl}, \textsf{blist.pl}, \textsf{confdel.pl}). The
success of
  \textsf{Polytool} and \textsf{TerminWeb} is due to the use of types
  instead of modes and \textsf{AProVE} succeeds because of
so-called \emph{argument filterings} which
remove argument positions of function and
predicate symbols that are irrelevant for termination.
 But \textsf{TerminWeb} still fails on some of these examples, since it uses a fixed
  norm for part of its analysis.





A strong point of \textsf{cTI-1.1} is that it is very fast (it is by far 
the fastest tool in the experiments). The reason is
that \textsf{cTI-1.1} fixes the norm in advance. Therefore it requires much
less unknown coefficients to formulate termination conditions.  
Another strong point of \textsf{cTI-1.1} is its ability of performing
termination inference (i.e., it can try to detect all terminating modes for a
program), 
which is impossible for \textsf{Polytool} at this
moment. 
Finally, recent extensions of \textsf{cTI-1.1} include non-termination proofs,
which are not supported by the other systems in our experiments.



\subsection{Comparison between \textsf{Polytool} and \textsf{TerminWeb}}
\label{polytool-terminweb}

Similar to \textsf{cTI-1.1}, \textsf{TerminWeb} also uses fixed symbolic norms,
e.g., the term-size norm, the list-length norm, or (as in our experiments) a
combination of type-based norms \cite{Bruynoogheetal07} to 
approximate the analyzed program. Therefore, it has similar problems as
\textsf{cTI-1.1}. In fact, termination of examples such as \textsf{flat.pl},
\textsf{normal.pl},
 \textsf{countstack.pl}, \textsf{factor.pl},
\textsf{flatten.pl} 
discussed in Section
\ref{polytool-cti} cannot be proved by \textsf{TerminWeb} either.

Different from \textsf{Polytool} and \textsf{cTI-1.1}, \textsf{TerminWeb}
applies a local approach to termination analysis, where different norms and
level mappings
are used for different loops in the program
\cite{Codishetal99}. Hence, \textsf{TerminWeb} can prove termination of a
class of programs where lexicographic orders are required (e.g., the
benchmarks \textsf{ackermann.pl} and \textsf{vangelder.pl} in the TPDB). 
In fact, these programs could already be proven terminating by \textsf{TermiLog}
\cite{lindenstrauss97,Termilog}, the first generally available automatic
termination analyzer for LPs. \textsf{TermiLog} succeeds on these programs due to the
query-mapping pairs approach \cite{Lindenstrauss}, which has some similarity to the
dependency pair approach \cite{ArtsGiesl00,JAR07,Hirokawa_Middeldorp04}.
For termination of such programs, the global technique
based on polynomial interpretations deployed in \textsf{Polytool} is
insufficient. We are working on an extension using dependency graphs
that is able to deal with such
programs as well
\cite{Nguyenetall-LOPSTR07,LOPSTR09}.


Similar to \textsf{cTI-1.1}, \textsf{TerminWeb} is much faster than
\textsf{Polytool}. This is again due to the fact that \textsf{TerminWeb} uses
a fixed symbolic norm to approximate the analyzed program. 

\subsection{Comparison between \textsf{Polytool}, \textsf{AProVE}, and \textsf{TALP}}



A
point of similarity between \textsf{Polytool}, \textsf{TALP}, and \textsf{AProVE} is
that all these systems use polynomial interpretations as the  basis for the termination
analysis. 
However in \textsf{TALP} and \textsf{AProVE}, polynomial interpretations are
applied indirectly: given a 
logic program and a set of queries, these tools first transform them into a TRS
whose termination is sufficient for the termination of the original logic
program.
Then, termination analysis is applied to
the resulting TRS. Due to this transformational approach, 
several  other termination techniques developed for TRSs
become applicable for the analysis of LPs as well. In particular, \textsf{AProVE} uses
many different methods for proving
termination.

A limitation of the transformational approach in \textsf{TALP} is that it can
only handle well-moded
logic programs.
There are many non-well-moded examples in the TPDB that can
be solved by most other tools but not by \textsf{TALP}.

 \textsf{AProVE} instead applies a
quite strong transformational approach, which can also deal with non-well-moded logic
programs \cite{LOPSTR06}. Together with the powerful back-end TRS
termination prover, this makes \textsf{AProVE} a very strong LP termination system. In fact, in
both our experiments and in the termination competitions,
\textsf{AProVE} was always in the first place. In particular, it can prove
termination of most examples whenever some other tool can. Nevertheless, there exists 
one example in the TPDB (i.e., \textsf{incomplete.pl}) where
{\sf AProVE} fails to prove its termination but {\sf Polytool}
succeeds. In general, the main important observation when comparing {\sf
Polytool} and {\sf AProVE} is that although \textsf{Polytool} only
uses polynomial interpretations and {\sf AProVE} uses a large collection of
different termination techniques, {\sf Polytool} is already almost as powerful
as {\sf AProVE}. 







Similar to 
\textsf{TerminWeb}, \textsf{cTI-1.1}, and \textsf{TALP}, \textsf{AProVE} uses
mode analysis and does not provide the expressivity of types. However, it can
express classes like bounded lists, since it uses
argument filterings.
Nevertheless, in some cases,
the effect of argument filterings is not ``deep'' enough to represent
redundant argument positions adequately, cf.\ \cite{ThangThesis}.
Finally, as shown in Table \ref{table1}, \textsf{AProVE} is 
the slowest tool in the experiments. One reason is that
the transformation may generate quite complex TRSs that require more time for
termination analysis. Another reason is that \textsf{AProVE} contains much
more different termination techniques than the other tools and it tries to
apply them all after each other.


\section{Conclusions}\label{conclusion}
Since a few years, the LP  and the TRS
termination analysis communities jointly organize the ``\emph{International Workshop on
Termination}'' (WST). As a part of this workshop, the
\emph{International Competition of
Termination Tools} is organized annually,
allowing different termination tools from different categories, including
term rewriting and logic programming, to compete.
These workshops have raised a
considerable interest in 
gaining a better understanding of each other's approaches. It soon became clear
that there has to be a close relationship between one of the most popular
techniques for TRSs, polynomial interpretations, and one of the key techniques
for LPs, acceptability with linear norms and level mappings. However,
partly because of the distinction between orders over the numbers
(LPs) versus orders over polynomials (TRSs), the actual relation between the
approaches was unclear. 

One
main conclusion of the research that led to this paper is that the
distinction is a superficial one. 
So one outcome of our work is that,
indeed, the polynomial interpretations used for TRSs are a direct generalization of
the current practice for LPs. 

On the more technical level, the contribution of this paper is
twofold. Firstly, we provide a complete and revised theoretical framework for
polynomial interpretations in LP 
termination analysis (cf.\ Section \ref{sec:interpretation}). A first variant
of such a framework was introduced in a preliminary version of 
this paper \cite{MNTDannyd05}. Parts of this build on the results in
\cite{DeSchreyeSerebrenik01} on order-acceptability and the results in \cite{Decorteetal98}
	on the constraint-based approach for termination analysis. Another part extends the
results of Bossi et al. \cite{Bossietal91} on the syntactic characterization of
rigidity. The main revisions are in the concept of polynomial interpretations
and the concept of rigidity. Secondly, we adapt the constraint-based approach
in \cite{Decorteetal98} to represent all termination conditions symbolically, and introduce
a new approach to find such polynomial interpretations
automatically (cf.\ Section \ref{sec:automation}).

We also developed an automated tool (\textsf{Polytool}
\cite{Nguyen&DeSchreye06}) for termination proofs of LPs 
based on polynomial interpretations. 
The main contribution of the implementation
is the integration of a number of techniques including the termination
framework in Section \ref{sec:interpretation}, the call pattern inference tools in
\cite{Bruynoogheetal05,GallagherHB05,HeatonACK00,Janssensetal92},
the constraint-based approach
in Section \ref{sec:automation}, and the Diophantine constraint solver in
\cite{Fuhsc07}, to provide a completely automated termination
analyzer. 
\textsf{Polytool} participated in the annual \emph{International 
Competitions of Termination Tools} since 2007 and reached the second place, just after
\textsf{AProVE}.

We have also conducted extensive experimental evaluation for \textsf{Polytool}
and compared it empirically with other
termination analyzers such as \textsf{cTI-1.1}, \textsf{TerminWeb}, \textsf{TALP}, and
\textsf{AProVE}, cf.\ Section \ref{sec:experiment}. The evaluation shows that
\textsf{Polytool} is powerful 
enough to solve a large number of benchmarks. In particular, it can also verify
termination of examples for which non-linear norms are required. 

The current paper and the corresponding tool
provide a good basis to adapt
further techniques from the area of TRS
termination to the LP domain. In this way, 
the power of automated termination analysis can be increased
substantially. Moreover, such adaptations will clarify
the connections between the numerous termination techniques
developed for TRSs and for LPs, respectively. First steps into this direction
are
\cite{Nguyenetall-LOPSTR07,LOPSTR09}.

\section{Acknowledgements}
Manh Thang Nguyen was partly supported by \emph{GOA Inductive Knowledge Bases} and partly by
\emph{FWO Termination Analysis: Crossing Paradigm Borders}. J\"urgen Giesl and
Peter
Schneider-Kamp were supported by the \emph{Deutsche Forschungsgemeinschaft (DFG)
           grant GI 274/5-2}.
We thank John Gallagher for making his type inference engine available,
Carsten Fuhs for his SAT-based Diophantine constraint solver within
\textsf{AProVE}, Fr\'ed\'eric Mesnard and Roberto  
Bagnara for providing us the {\sf cTI} system and the \textsf{Parma Polyhedra
Library}, Michael Codish and Samir Genaim for their \textsf{TerminWeb}
system. We thank the anonymous reviewers for their valuable comments.

\bibliography{polynomial}
\end{document}
