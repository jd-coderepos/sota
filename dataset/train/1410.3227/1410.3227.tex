\section{Introduction}
\label{sec:Introduction}

Regular expressions have many applications in the context of software
development and information technology: text processing, program analysis, compiler
construction, query processing, and so on. Modern programming languages
either come with standard libraries for regular expression processing or they
provide built-in facilities (e.g., Perl, Ruby, and JavaScript). Many
of these implementations augment the basic regular operations $\regexOrOp$,
$\regexConcatOp$, and ${}^\regexStarOp$ (union, concatenation, and
Kleene star) with enhancements like character classes and wildcard
literals, cardinalities, sub-matching, intersection, or
complement.

Regular expressions (\RE) are advantageous in these domains because they provide a concise means to
encode many interesting problems. \RE{}s are well suited for verification applications, because
there are decision procedures for many problems involving them: the word problem
($w\in\lang{\regexr}$), emptiness ($\lang{\regexr}=\emptyset$), finiteness, containment
($\lang{\regexr}\subseteq\lang{\regexs}$), and equivalence ($\lang{\regexr}=\lang{\regexs}$). Here
we let $\regexr$ and $\regexs$ range over \RE{} and write $\lang{\cdot}$ for the function that maps
a regular expression to the regular language that it denotes. There are also effective constructions
for operations like union, intersection, complement, prefixes, suffixes, etc on regular languages.

Recent applications impose new demands on operations involving
regular expressions. The Unicode character set with its more than
1.1 million code points requires the ability to deal effectively with very large
character sets and hence character classes. Similarly, formalizing
access contracts for objects in scripting languages even requires
regular expressions over an infinite alphabet: in this application,
the alphabet itself is an infinite formal language (the language of field
names) and a ``character class'' (i.e., a set of field names) is described
by a regular expression \cite{KeilThiemann2013-Proxy,HeideggerBieniusaThiemann2012-popl}. Hence, a
``character class'' may also have infinitely many elements.

We study the containment problem for regular expressions with two enhancements.
First, we consider \emph{extended regular expressions} (\ERE) that
contain intersection and complement operators beyond the standard regular operators of union, concatenation,
and Kleene star. An \ERE{} also denotes a regular language but it can be much
more concise than a standard \RE.
Second, we consider \ERE{}s on any alphabet that is presented as an effective boolean algebra. This
extension encompasses some infinite alphabets like the set of all field names in a scripting
language. 

The first enhancement is known to be decidable, but we give a new
symbolic decision procedure based on Brzozowski's regular expression
derivatives~\cite{Brzozowski1964} and Antimirov's rewriting approach
to check containment~\cite{Antimirov1995}. The
second enhancement has been studied previously \cite{Watson1996,vanNoordGerdemann2001,Veanes2013}, but 
in the context of automata and finite state transducers. It has not been investigated on the level
of regular expressions and in particular not in the context of Brzozowski's and Antimirov's work. We
give sufficient conditions to ensure applicability of our modification of Brzozowski's and
Antimirov's approach to the containment problem while retaining decidability.



\label{sec:related_work}
\subsection{Related Work}

The practical motivation for considering this extension is drawn from
the authors' work on checking access contracts for objects in a scripting language at run 
time~\cite{KeilThiemann2013-Proxy}. In that work, an access contract specifies a set of access paths
that start from a specific anchor object. An access path is a word over the field names of the
objects traversed by the path and we specify a set of such paths by a regular expression on the
field names. We claim that such a regular expression draws from an infinite alphabet because a field
name in a scripting language is an arbitrary string (of characters). For succinctness, we specify
sets of field names using a second level of regular expressions on characters.

In our implementation, checking containment is required to reduce memory consumption.
If the same object is restricted by more than one contract, 
then we apply containment checking to remove
redundant contracts. In that previous work, contracts were limited to
basic regular expressions and the field-level expressions were limited
to disjunctions of literals. Applying the results of the present paper
enables us to lift both restrictions.

The standard approach to checking regular expression containment is
via translation to finite automata, which may involve an exponential
blowup, and then construction of a simulation (or a bisimulation for
equivalence)~\cite{HopcroftKarp1971}. A related approach based on
non-deterministic automata is given
by Bonchi and Pous~\cite{BonchiPous2013}.

The exponential blowup is due to the construction of a deterministic
automaton from the regular expression.
Thompson's construction~\cite{Thompson1968}, creates a
non-deterministic finite automaton with $\regexEmpty$-transitions
where the number of states and transitions is linear to the length of
the (standard) regular expression.
Glushkov's~\cite{Glushkov1961} and McNaughton and
Yamada's~\cite{McNaughtonYamada1960} position automaton computes a
$n+1$-state non-deterministic automaton with up to $n^2$ transitions from a $n$-symbol expression. They are the first to
use the notion of a first symbol.
Brzozowski's regular expression derivatives~\cite{Brzozowski1964} directly calculate a deterministic
automaton from an \ERE. Antimirov's partial derivative approach~\cite{Antimirov1996} computes a $n+1$-state 
non-deterministic automation, but again without intersection and complement. 
We are not aware of an extension of Glushkov's algorithm to extended regular expressions. 

Owens and other have implemented an extension of Brzozowski's approach with character classes and
wildcards~\cite{OwensReppyTuron2009}. 

Antimirov~\cite{Antimirov1995} also proposes a symbolic method for solving regular expression inequalities, based on
partial derivatives, with exponential worst-case run time. His 
\emph{containment calculus} is closely related to the simulation technique used by Hopcroft and Karp~\cite{HopcroftKarp1971} for proving
equivalence of automata. In fact, a decision procedure for containment of regular expressions leads to one for
equivalence and vice versa.
Ginzburg~\cite{Ginzburg1967} gives an equivalence procedure based on
Brzozowski derivatives.
Antimirov's original work does not consider
intersection and complement. Caron and
coworkers~\cite{CaronChamparnaudMignot2011} extend Antimirov's work to
\ERE{} using antichains, but the resulting procedure is very complex compared to ours. 

A shortcoming of all existing approaches is their restriction to
finite alphabets. Supporting both
makes a significant difference in practice: an iteration over the
alphabet $\regexAlphabet$ is feasible for small alphabets, but it is
impractical for very large alphabets (e.g., Unicode) or infinite ones
(e.g., another level of regular languages as for our
contracts). Furthermore, most regular expressions used in practice
contain character sets. We apply techniques developed for symbolic
finite automata to address these issues~\cite{Veanes2013}.

\subsection{Overview}
This paper is organized as follows. In Section~\ref{sec:preliminaries}, we recall notations and concepts used in this
paper. Section~\ref{sec:characterlevel} introduces the notion of an effective boolean algebra for representing sets of
symbols abstractly. Section~\ref{sec:antimirovs-algorithm-containment} explains Antimirov's algorithm for checking
containment, which is the starting point of our work. Next, Section~\ref{sec:derivatives} defines two notions of
derivatives on regular expressions with respect to symbol sets. It continues to introduce the key notion of \emph{next
literals}, which ensures finiteness of our extension to Antimirov's algorithm. Section~\ref{sec:inequalities} contains
the heart of our extended algorithm, a deduction system that determines containment of extended regular expressions
along with a soundness proof.



This paper concludes with an appendix
with further technical details, examples, and proofs of theorems.



\section{Regular Expressions}
\label{sec:preliminaries}

An \emph{alphabet} $\regexAlphabet$ is a denumerable, potentially infinite set of
symbols. $\regexWords$ is the set of all finite words over symbols from
$\regexAlphabet$ with $\regexEmpty$ denoting the empty word.
Let $\symbola,\symbolb,\symbolc\in\regexAlphabet$
range over symbols; $\wordu,\wordv,\wordw\in\regexWords$ over words;
and
$\seta,\setb,\setc\subseteq\regexAlphabet$ over sets of symbols. 


Let $\langl, \langl'\subseteq\regexWords$ be languages.
The \emph{left quotient} of $\langl$ by a word $\wordu$, written
$\leftquotient{\wordu}{\langl}$, is the language $\{
\wordv~|~\wordu\wordv\in\langl \}$. It is immediate from the
definition that $\leftquotient{(\symbola\wordu)}{\langl} =
\leftquotient{\wordu}{(\leftquotient{\symbola}{\langl})}$ and that 
$\wordu\in\langl$ iff
$\regexEmpty\in\leftquotient{\wordu}{\langl}$. Furthermore,
$\langl\subseteq\langl'$ iff
$\leftquotient{\wordu}{\langl}\subseteq\leftquotient{\wordu}{\langl'}$
for all words $\wordu\in\regexWords$. The left quotient of one
language by another is defined by  $\leftquotient\langl{\langl'} = \{
\wordv~|~\wordu\wordv\in\langl', \wordu\in\langl \}$.
We abbreviate the concatenation of languages $\{\wordu\wordv~|~\wordu\in\langl,\wordv\in\langl'\}$
to $\regexConcat{\langl}{\langl'}$ and we write $\langl^*$ for the iteration $\regexConcat{\langl}{\langl^*}$.
We sometimes write $\overline\langl$ for the complement $\regexWords\setminus\langl$ and  
$\overline\seta$ for $\regexAlphabet\setminus\seta$.

An \emph{extended regular expression} (\ERE) on an alphabet
$\regexAlphabet$ is a syntactic phrase derivable from non-terminals $\regexr,\regexs,\regext$. It
comprises the the empty word, literals, union, concatenation, Kleene star, as well as
negation and intersection operators.
\begin{mathpar}
  \regexr,\regexs,\regext~\df{}~\regexEmpty~|~\literall
  ~|~\regexOr{\regexr}{\regexs}
  ~|~\regexConcat{\regexr}{\regexs}
  ~|~\regexStar{\regexr}~|~\regexAnd{\regexr}{\regexs}~|~\regexNeg{\regexr}
\end{mathpar}
Compared to standard definitions, a \emph{literal} is a set $\seta$ of symbols, which stands for an
abstract, possibly empty, character class. We write $\symbola$ instead of $\{\symbola\}$ for the
frequent case of a single letter literal. We consider
regular expressions up to similarity \cite{Brzozowski1964}, that is,
up to associativity and commutativity of the union operator with the empty set as identity.

The language $\lang{\regexr}\subseteq\regexWords$ of a regular
expression $\regexr$ is defined inductively by:
\begin{mathpar}
  \begin{array}{l@{~}l@{~}l}
    \lang{\regexEmpty} &=& \{\regexEmpty\}\\
    \lang{\regexSet} &=& \{\symbola~|~\symbola\in\regexSet\}\\
    &&
  \end{array}

  \begin{array}{l@{~}l@{~}l}
    \lang{\regexOr{\regexr}{\regexs}} &=& \lang{\regexr} \cup \lang{\regexs}\\
    \lang{\regexConcat{\regexr}{\regexs}} &=& \regexConcat{\lang{\regexr}}{ \lang{\regexs}} \\
    \lang{\regexStar{\regexr}} &=&
    \lang{{\regexr}}^*  \\
  \end{array}

  \begin{array}{l@{~}l@{~}l}
    \lang{\regexAnd{\regexr}{\regexs}} &=& \lang{\regexr} \cap \lang{\regexs}\\
    \lang{\regexNeg{\regexr}} &=& \overline{\lang{\regexr}} \\
    &&
  \end{array}
\end{mathpar}
For finite alphabets, $\lang\regexr$ is a regular language. For arbitrary alphabets, we
\emph{define} a language to be regular, if it is equal to $\lang\regexr$, for some {\ERE} $\regexr$.

We write $\isSubSetOf{\regexr}{\regexs}$ ($\regexr$ is
\emph{contained} in  $\regexs$) to express that $\lang{\regexr}\subseteq\lang{\regexs}$. 

The \emph{nullable} predicate $\isNullable{\regexr}$ indicates whether
$\lang{\regexr}$ contains the empty word, that is,
$\isNullable\regexr$ iff $\regexEmpty\in\lang{\regexr}$.  It is
defined inductively by: 
\begin{mathpar}
  \begin{array}{lll}
    \isNullable{\regexEmpty} &=& \true\\
    \isNullable{\regexSet} &=& \false\\
    &&
  \end{array}

  \begin{array}{lll} 
    \isNullable{\regexOr{\regexr}{\regexs}} &=& \isNullable{\regexr} \vee \isNullable{\regexs}\\
    \isNullable{\regexConcat{\regexr}{\regexs}} &=& \isNullable{\regexr} \wedge \isNullable{\regexs}\\
    \isNullable{\regexStar{\regexr}} &=& \true \\
  \end{array}

  \begin{array}{lll}
    \isNullable{\regexAnd{\regexr}{\regexs}} &=& \isNullable{\regexr} \wedge \isNullable{\regexs}\\
    \isNullable{\regexNeg{\regexr}} &=& \neg\isNullable{\regexr}\\
    &&
  \end{array}
\end{mathpar}
The \emph{Brzozowski derivative}
$\deriv{\symbola}{\regexr}$ of an expression
$\regexr$ w.r.t.\ a symbol $\symbola$ computes a regular expression
for the left quotient $\leftquotient{\symbola}{\lang{\regexr}}$ (see~\cite{Brzozowski1964}).
It is defined inductively as follows:
\begin{mathpar}
  \begin{array}{l@{~}l@{~}l}
    \deriv{\symbola}{\regexEmpty} &=& \regexNull\\
    \deriv{\symbola}{\seta} &=&
    \begin{cases}
      \regexEmpty, & \symbola\in\seta \\
      \regexNull,  & \symbola\notin\seta
    \end{cases}
    \\
    \deriv{\symbola}{\regexOr{\regexr}{\regexs}} &=& \regexOr{\deriv{\symbola}{\regexr}}{\deriv{\symbola}{\regexs}}\\
    \\
  \end{array}

  \begin{array}{l@{~}l@{~}l}
    \deriv{\symbola}{\regexConcat{\regexr}{\regexs}} &=& \begin{cases}
      \regexOr{\regexConcat{\deriv{\symbola}{\regexr}}{\regexs}}{\deriv{\symbola}{\regexs}}, &\isNullable{\regexr}\\
      \regexConcat{\deriv{\symbola}{\regexr}}{\regexs}, &\neg\isNullable{\regexr}
    \end{cases}
    \\
    \deriv{\symbola}{\regexStar{\regexr}} &=&
    \regexConcat{\deriv{\symbola}{\regexr}}{\regexStar{\regexr}} \\
    \deriv{\symbola}{\regexAnd{\regexr}{\regexs}} &=& \regexAnd{\deriv{\symbola}{\regexr}}{\deriv{\symbola}{\regexs}}\\
    \deriv{\symbola}{\regexNeg{\regexr}} &=& \regexNeg{\deriv{\symbola}{\regexr}}\\
  \end{array}
\end{mathpar}
The case for the set literal $\seta$ generalizes Brzozowski's
definition. The definition is extended to words by
$\deriv{\symbola\wordu}{\regexr}=\deriv{\wordu}{\deriv{\symbola}{\regexr}}$
and $\deriv{\regexEmpty}{\regexr}=\regexr$. Hence,
$\wordu\in\lang\regexr$ iff $\regexEmpty\in\lang{\deriv\wordu\regexr}$.

\section{Representing Sets of Symbols}
\label{sec:characterlevel}

The definition of an \ERE{} in Section~\ref{sec:preliminaries} just
states that a literal is a set of symbols
\mbox{$\seta\subseteq\regexAlphabet$}. However, to define tractable
algorithms, we require that $\seta$ is an element of an
effective boolean algebra \cite{Veanes2013} $(U, \sqcup,
\sqcap, \inv{\cdot}, \bot, \top)$ where $U \subseteq
\powerset\regexAlphabet$ is closed under the boolean operations. Here
$\sqcup$ and $\sqcap$ denote 
union and intersection of symbol sets, $\inv{\cdot}$ the complement,
and $\bot$ and $\top$ the empty set and the full set $\regexAlphabet$,
respectively. In this algebra, we need to be able to decide
equality of sets (hence the term \emph{effective}) and to represent
singleton symbols. 
\begin{itemize}
  \item For finite (small) alphabets, we may just take $U =
    \powerset{\regexAlphabet}$. A set of symbols may be enumerated
    and ranges of symbols may be represented by character classes, as
    customarily supported in regular expression
    implementations. Alternatively, a bitvector representation may be used.
  \item 
    If the alphabet is infinite (or just too large), then the boolean
    algebra of finite and cofinite sets of symbols is the basis for a
    suitable representation. That is, the set $U = \{\seta\in\powerset{\regexAlphabet}
    \mid \seta \text{ finite} \vee \inv{\seta}
    \text{ finite} \}$ is effectively closed under the boolean operations.
  \item
    In our application to checking access contracts in scripting
    languages~\cite{KeilThiemann2013-Proxy}, the alphabet itself is a set of words (the field names of
    objects) composed from another set $\Gamma$ of symbols:
    $\regexAlphabet \subseteq \powerset{\Gamma^*}$. To obtain an
    effective boolean algebra, we choose the set $U = \{ \seta \subseteq \powerset{\Gamma^*} \mid \seta \text{ is regular}\}$,
    which is effectively closed under the boolean operations.
  \item
    Sets of symbols may also be represented by formulas drawn from a
    decidable first-order theory over a (finite or infinite) alphabet.
    For example, the character range
    \texttt{[a-z]} would be represented by the formula $x\ge\verb|'a'|
    \wedge x\le\verb|'z'|$. 
    In this case, the boolean operations get mapped to the disjunction,
    conjunction, or negation of predicates; bottom and top are false and true,
    respectively. An SMT solver can decide equality and subset constraints.
    This approach has been demonstrated to be
    effective for very large character sets in the work on symbolic finite
    automata~\cite{Veanes2013}.
\end{itemize}
The rest of this paper is generic with respect to the choice
of an effective boolean algebra. 



\section{Antimirov's algorithm for checking containment}
\label{sec:antimirovs-algorithm-containment}

Given two regular expressions $\regexr$, $\regexs$, the
\emph{containment problem} asks whether
$\isSubSetOf{\regexr}{\regexs}$.
This problem is decidable using standard techniques 
from automata theory: construct a deterministic finite
automaton for $\regexAnd\regexr{\regexNeg\regexs}$ and check it for
emptiness. The drawback of this approach is the expensive construction
of the automaton. In general, this expense cannot be avoided because
problem is PSPACE-complete 
\cite{HuntRosenkrantzSzymanski1976,JiangRavikumar1993,MeyerStockmeyer1972}.

Antimirov~\cite{Antimirov1995} proposed an algorithm for deciding
containment of standard regular expressions (without intersection and
negation) that is based on rewriting of inequalities. His algorithm
has the same asymptotic complexity as the automata construction, but it can fail early and is
therefore better behaved in practice. We phrase the algorithm in
terms of Brzozowski derivatives to avoid introducing Antimirov's
notion of partial derivatives.
\begin{theorem}[{Containment~\cite[Proposition 7(2)]{Antimirov1995}}]\label{thm:containment-antimirov}
  For regular expressions $\regexr$ and $\regexs$,
  \begin{displaymath}
    \isSubSetOf{\regexr}{\regexs}
    \Leftrightarrow
    (\forall\wordu\in\regexWords)~\isSubSetOf{\deriv{\wordu}\regexr}{\deriv{\wordu}\regexs}.
  \end{displaymath}
\end{theorem}
Antimirov's algorithm applies this theorem exhaustively to an
inequality $\checkSubSetOf\regexr\regexs$ (i.e., a proposed
containment) to generate
all pairs $\checkSubSetOf{\deriv\wordu\regexr}{\deriv\wordu\regexs}$ of
iterated derivatives until it finds a
contradiction or saturation. More precisely, Antimirov defines a
\emph{containment calculus} $\CC$ which works on sets $S$ of atoms, where an
atom is either an inequality $\checkSubSetOf\regexr\regexs$ or a boolean
constant $\true$ or $\false$. It consists of the rule
\RefTirName{CC-Disprove} which infers $\false$ from a trivially
inconsistent inequality and the rule \RefTirName{CC-Unfold} that applies
Theorem~\ref{thm:containment-antimirov} to generate new inequalities.
\begin{mathpar}
  \infer[CC-Disprove]
  {\isNullable\regexr \wedge \neg\isNullable\regexs}
  {\checkSubSetOf\regexr\regexs \impliesCC \false}

  \infer[CC-Unfold]
  {\isNullable\regexr \Rightarrow \isNullable\regexs}
  {\checkSubSetOf\regexr\regexs \impliesCC
    \{
      \checkSubSetOf{\deriv{\symbola}\regexr}{\deriv{\symbola}\regexs}
      \mid
      \symbola\in\regexAlphabet
    \}
  }
\end{mathpar}
An inference in the calculus for checking whether
$\isSubSetOf{\regexr_0}{\regexs_0}$ is a sequence $S_0 \impliesCC S_1 
\impliesCC S_2 \impliesCC \dots$ where $S_0 =
\{\checkSubSetOf{\regexr_0}{\regexs_0}\}$ and $S_{i+1}$ is an extension of $S_i$
by selecting an inequality in $S_i$ and adding the consequences of
applying one of the $\CC$ rules to it. That is, if
$\checkSubSetOf\regexr\regexs \in S_i$ and
$\checkSubSetOf\regexr\regexs \impliesCC S$, then $S_{i+1} = S_i \cup S$.

Antimirov argues \cite[Theorem~8]{Antimirov1995} that this algorithm is sound and complete by proving
(using Theorem~\ref{thm:containment-antimirov})
that $\isSubSetOf\regexr\regexs$ does not hold if and only if a set of
atoms containing $\false$ is derivable from
$\checkSubSetOf\regexr\regexs$.
The algorithm terminates because there are only finitely many
different inequalities derivable from $\checkSubSetOf\regexr\regexs$
using rule \RefTirName{CC-Unfold}. 

The containment calculus $\CC$ has two drawbacks. First, the
choice of an inequality for the next inference step is
nondeterministic. Second, an adaptation to a setting with an infinite alphabet seems
doomed because rule \RefTirName{CC-Unfold} requires us to compute the derivative for infinitely many
$\symbola\in\regexAlphabet$ at each application. We address the second
drawback next.



\section{Derivatives on Literals}
\label{sec:derivatives}

In this section, we develop a variant of
Theorem~\ref{thm:containment-antimirov} that enables us to define an
\RefTirName{CC-Unfold} rule that is guaranteed to add finitely many
atoms, even if the alphabet is infinite.
First, we observe that we may restrict the symbols considered
in rule \RefTirName{CC-Unfold} to initial symbols of the left hand side
of an inequality.
\begin{definition}[First]
  Let $\getNext{\regexr} \df
  \{\symbola~|~\symbola\wordw\in\lang{\regexr}\}$
  be the set of initial symbols derivable from regular expression $\regexr$.
\end{definition}
Clearly,
$(\forall\symbola\in\regexAlphabet)~\isSubSetOf{\deriv\symbola\regexr}{\deriv\symbola\regexs}$
iff
$(\forall\symbolb\in\getNext\regexr)~\isSubSetOf{\deriv\symbolb\regexr}{\deriv\symbolb\regexs}$
because $\deriv{\symbolb}{\regexr} = \regexNull$ for all
$\symbolb\notin\getNext\regexr$. Thus, \RefTirName{CC-Unfold} does not
have to consider the entire alphabet, but unfortunately
$\getNext\regexr$ may still be an infinite set of 
symbols. For that reason, we propose to compute derivatives with
respect to \emph{literals} (i.e., non-empty sets of symbols) instead
of single symbols. However, generalizing derivatives to literals has
some subtle problems.

To illustrate these problems, let us recall the specification of the Brzozowski derivative:
\begin{displaymath}
  \lang{\deriv{\symbola}{\regexr}} = \leftquotient{\symbola}{\lang{\regexr}}
\end{displaymath}
Now we might be tempted to consider 
the following naive extension of the derivative to a set of symbols
$\seta$.
\begin{align*}
  \lang{\deriv{\seta}{\regexr}}~=~\leftquotient{\seta}{\lang{\regexr}}~=~\bigcup_{\symbola\in\seta} \leftquotient{\symbola}{\lang{\regexr}} =
  \bigcup_{\symbola\in\seta} \lang{\deriv{\symbola}{\regexr}}
  \tag{wrong}
\end{align*}
However, this attempt at a specification yields inconsistent results. To see
why, consider the case where $\regexr = \regexNeg\regexs$. Generalizing from 
$\deriv{\symbola}{\regexNeg{\regexs}} = \regexNeg{\deriv{\symbola}{\regexs}}$,
we might try to define
$\deriv{\seta}{\regexNeg{\regexs}} \df{} \regexNeg{\deriv{\seta}{\regexs}}$.
If this definition was sensible, then~(\ref{eq:1}) and~(\ref{eq:2}) should yield
the same results:
\begin{eqnarray}
  \label{eq:1}
  \lang{\deriv{\seta}{\regexNeg\regexs}}
  &\stackrel{\textrm{(wrong)}}{=}&  \bigcup_{\symbola\in\seta} \lang{\deriv{\symbola}{\regexNeg\regexs}}
  \stackrel{\textrm{def}~\derivSymbol_\symbola}=  \bigcup_{\symbola\in\seta} \overline{\lang{\deriv{\symbola}{\regexs}}}
  \\
  \label{eq:2}
  \lang{\regexNeg{\deriv{\seta}{\regexs}}}
  &\stackrel{\textrm{def}~\derivSymbol_\symbola}{=}& \overline{\lang{{\deriv{\seta}{\regexs}}}}
  \stackrel{\textrm{(wrong)}}{=} \overline{\bigcup_{\symbola\in\seta} \lang{{\deriv{\symbola}{\regexs}}}} 
  \stackrel{\textrm{de Morgan}}{=} {\bigcap_{\symbola\in\seta} \overline{\lang{{\deriv{\symbola}{\regexs}}}}} 
\end{eqnarray}
However, we obtain a contradiction: with $\seta = \{\symbola, \symbolb\}$ and $\regexs =
\regexOr{\regexConcat\symbola\symbola}{\regexConcat\symbolb\symbolb}$,
\eqref{eq:1} yields $\regexWords$ whereas~\eqref{eq:2} yields
$\overline{\{\symbola, \symbolb\}}$, which is clearly different.

\subsection{Positive and Negative Derivatives}

To address this problem, we introduce two types of derivative operators with respect to symbol
sets. The \emph{positive derivative} $\pderiv{\seta}{\regexr}$ computes an
expression that contains the union of all $\deriv{\symbola}{\regexr}$ with
$\symbola\in\seta$, whereas the \emph{negative derivative}
$\nderiv{\seta}{\regexr}$ computes an expression contained in the intersection of
all $\deriv{\symbola}{\regexr}$ with $\symbola\in\seta$. 

The positive and negative derivative operators are defined by mutual
induction and flip at the {complement operator}. Most cases of their
definition are identical to the Brzozowski derivative
(cf. Section~\ref{sec:preliminaries}), thus we only show the cases that are
different\footnote{See also Appendix~\ref{sec:derivatives_full}.}. For all literals $\literall$ with $\lang{\literall}\neq\emptyset$:

\vspace{-\baselineskip}
\begin{minipage}[t]{0.4\textwidth}
  \begin{align*}
    \begin{array}{lll}
      \pderiv{\setb}{\regexSet} &\df{}& \begin{cases}
        \regexEmpty, & \regexSet\sqcap\setb\ne\bot \\
        \regexNull, & \textit{otherwise}
      \end{cases}\\
      \pderiv{\setb}{\regexNeg{\regexr}} &\df{}&  \regexNeg{\nderiv{\setb}{\regexr}}\\
    \end{array}
  \end{align*}
\end{minipage}
\begin{minipage}[t]{0.4\textwidth} 
  \begin{align*}
    \begin{array}{lll}
      \nderiv{\setb}{\regexSet} &\df{}& \begin{cases}
        \regexEmpty, & \overline{\regexSet}\sqcap\setb=\bot\\
        \regexNull, & \textit{otherwise}
      \end{cases}\\
      \nderiv{\setb}{\regexNeg{\regexr}} &\df{}&  \regexNeg{\pderiv{\setb}{\regexr}}\\
    \end{array}
  \end{align*}
\end{minipage}
\vspace{\baselineskip}

\noindent
For single symbol literals of the form $\setb=\{\symbola\}$, it holds
that  $\pderiv{\symbola}{\regexr}=\nderiv{\symbola}{\regexr}=\deriv{\symbola}{\regexr}$.
Derivatives with respect to the empty set are defined as
$\pderiv{\emptyset}{\regexr}=\regexNull$ and $\nderiv{\emptyset}{\regexr}=\regexWords$.

The following lemma states the connection between the derivative by a literal and the derivative by a symbol.
\begin{lemma}[Positive and negative derivatives]\label{thm:derivatives}
  For any $\regexr$ and $\setb$, it holds that:
  \begin{mathpar}
    \lang{\pderiv{\setb}{\regexr}}\supseteq\bigcup_{\symbola\in\setb} \lang{\deriv{\symbola}{\regexr}}

    \lang{\nderiv{\setb}{\regexr}}\subseteq\bigcap_{\symbola\in\setb} \lang{\deriv{\symbola}{\regexr}}    
  \end{mathpar}
\end{lemma}

\begin{proof}[Proof of Lemma~\ref{thm:derivatives}]
  Both inclusions are proved simultaneously by induction on $\regexr$. See Appendix~\ref{sec:proof-derivative}.
\end{proof}
The following examples illustrate the properties of the derivatives.
\begin{example}[Positive derivative]\label{exp:pderivatives}
  Let $\regexr$ be
  $\regexAnd{(\symbola\concat\symbolc)}{(\symbolb\concat\symbolc)}$
  and let the literal $\literall = \{\symbola,\symbolb\}$. 
  $$\pderiv{\literall}{\regexr} =
  \regexAnd{\pderiv{\literall}{\symbola\concat\symbolc}}{\pderiv{\literall}{\symbolb\concat\symbolc}}
  = \regexAnd{\symbolc}{\symbolc}
  \supersetof \regexOr{\deriv{\symbola}{\regexr}}{\deriv{\symbolb}{\regexr}} =
  \regexOr{\emptyset}{\emptyset}$$
\end{example}

\begin{example}[Negative derivative]\label{exp:nderivatives}
  Let $\regexr$ be
  $\regexOr{(\symbola\concat\symbolc)}{(\symbolb\concat\symbolc)}$ and
  let the literal $\literall = \{\symbola,\symbolb\}$. 
  $$\nderiv{\literall}{\regexr} =
  \regexOr{\nderiv{\literall}{\symbola\concat\symbolc}}{\nderiv{\literall}{\symbolb\concat\symbolc}}
  = \regexOr{\regexNull}{\regexNull}
  \subsetof \deriv{\symbola}{\regexr} \regexAndOp \deriv{\symbolb}{\regexr} =
  \symbolc \regexAndOp \symbolc$$
\end{example}
Positive (negative) derivatives yield an upper (lower)
approximation to the information expected from a derivative.
This approximation arises because we tried to define the derivative
with respect to an \emph{arbitrary} literal $\literall$. 
To obtain the precise information, we need to restrict these literals
suitably to \emph{next literals}.

\subsection{Next Literals}
\label{sec:next}

An occurrence of a literal $\literall$ in a regular expression $\regexr$ is \emph{initial} if there is
some $\symbola\in\regexAlphabet$ such that $\deriv\symbola\regexr$ reduces this occurrence. That is,
the computation of $\deriv\symbola\regexr$ involves $\deriv\symbola\literall$. Intuitively,
$\literall$ helps determine the first symbol of an element of $\lang\regexr$.
\begin{example}[Initial Literals]\label{example:next-literals} ~\\[-\baselineskip]
  \begin{enumerate}
    \item 
      Let $\regexr_1 = \{a,b\}.a^*$. Then $ \{a,b\}$ is an initial literal.
    \item 
      Let $\regexr_2 = \{a,b\}.a^* + \{b,c\}.c^*$. Then $ \{a,b\}$ and $\{b, c\}$ are initial.
  \end{enumerate}
\end{example}

\noindent
Generalizing from the first example, we might be tempted to conjecture that if $\literall$ is initial
in $\regexr$,
then $(\forall \symbola, \symbolb\in\literall)$ $\deriv\symbola\regexr =
\deriv\symbolb\regexr$. However, the second example shows that this conjecture is wrong:
$\{\symbola, \symbolb\}$ is initial in $\regexr_2$, but $\deriv\symbola{\regexr_2} = a^*$ and
$\deriv\symbolb{\regexr_2} = a^* + c^*$.

The problem with the second example is that $\{a,b\} \cap \{b,c\} \ne \emptyset$. Hence, instead of
identifying initial literals of an {\ERE} $\regexr$, we define a set $\getFirst\regexr$ of next
literals which are mutually disjoint, whose union contains $\getNext\regexr$, and where the symbols in
each literal yield the same derivative. In the second example, it must be that $\getFirst{\regexr_2}
= \{ \{a\}, \{b\}, \{c\} \}$.

It turns out that this problem arises in a number of cases when defining $\getFirst\regexr$
inductively. Hence, we define an operation $\literaljoin$ that builds a set of mutually
disjoint literals that cover the union of two sets of mutually disjoint literals.
\begin{definition}[Join]\label{def:join}
  Let $\literalset_1$ and $\literalset_2$ be two sets of mutually
  disjoint literals.
  \begin{align*}
    \literalset_1 \literaljoin \literalset_2~\df&
    \{
      (\literall_1\literalcap\literall_2),
      (\literall_1\literalcap\inv{\literalbigcup\literalset_2}),
      (\inv{\literalbigcup\literalset_1}\literalcap\literall_2)
      \mid
    \literall_1\in \literalset_1, \literall_2\in \literalset_2\}
  \end{align*}
\end{definition}
The following lemma states the properties of the join operation.
\begin{lemma}[Properties of Join]\label{lemma:properties-of-join}
  Let $\literalset_1$ and $\literalset_2$ be non-empty sets of mutually disjoint literals.
  \begin{enumerate}
    \item $\bigcup (\literalset_1 \literaljoin \literalset_2) = \bigcup \literalset_1 \cup \bigcup \literalset_2$.
    \item $(\forall \literall\ne\literall' \in \literalset_1 \literaljoin \literalset_2)$ $\literall\sqcap\literall' = \emptyset$.
    \item $(\forall \literall \in \literalset_1 \literaljoin \literalset_2)$ $(\forall \literall_i \in \literalset_i)$
      $\literall \sqcap \literall_i \ne \emptyset \Rightarrow \literall \sqsubseteq \literall_i$.
  \end{enumerate}
\end{lemma}

\begin{proof}[Proof of Lemma~\ref{lemma:properties-of-join}]
  See Appendix~\ref{sec:properties-join}.
\end{proof}

\begin{figure}[tp]
  \begin{mathpar}
    \begin{array}[t]{lll}
      \getFirst{\regexEmpty} &=& \{ \emptyset \}\\
      \getFirst{\regexSet} &=& \{\regexSet\}\\
    \end{array}

    \begin{array}[t]{lll}
      \getFirst{\regexOr{\regexr}{\regexs}} &=& \getFirst{\regexr} \literaljoin \getFirst{\regexs}\\
      \getFirst{\regexConcat{\regexr}{\regexs}} &=& \begin{cases}
        \getFirst{\regexr}\literaljoin\getFirst{\regexs}, & \isNullable{\regexr}\\
        \getFirst{\regexr}, & \neg\isNullable{\regexr}
      \end{cases}\\
      \getFirst{\regexStar{\regexr}} &=& \getFirst{\regexr}\\
      \getFirst{\regexAnd{\regexr}{\regexs}} &=&
      \getFirst{\regexr}\literalcap\getFirst{\regexs}\\
      \getFirst{\regexNeg{\regexr}} &=&
      \getFirst{\regexr} \cup \{ \literalbigcap\{\inv{\literall}~|~\literall\in\getFirst{\regexr}\} \}
    \end{array}
  \end{mathpar}
  \caption{Computing next literals.}
  \label{fig:first-literals}
\end{figure}

\noindent
Figure~\ref{fig:first-literals} contains the definition of $\getFirst\regexr$.
For $\regexEmpty$ the set of next literals consists
of the empty set.
The next literal of a literal $\literall$ is $\literall$.
The next literals of a union $\regexOr{\regexr}{\regexs}$ are computed as the join of the next literals of
$\regexr$ and $\regexs$ as explained in Example~\ref{example:next-literals}. 
The next literals of a concatenation $\regexConcat{\regexr}{\regexs}$ are the next literals of
$\regexr$ if $\regexr$ is not nullable. Otherwise, they are the join of the next literals of both
operands. 
The next literals of a Kleene star expression $\regexStar{\regexr}$ are the next literals of
$\regexr$.
For an intersection $\regexAnd{\regexr}{\regexs}$, the set of next literals is the set of all
intersections $\literall\literalcap\literall'$ of the next literals of both operands.
In this case, the join operation $\literaljoin$ is not needed because symbols that only appear in literals from one
operand can be elided. To see this, consider
$\getFirst{\regexAnd\symbola\symbolb} = \{ \{\symbola\} \sqcap
\{\symbolb\} \} = \{ \emptyset \}$ whereas $\{ \{\symbola\} \} \literaljoin 
\{\{\symbolb\} \} = \{ \emptyset, \{\symbola\}, \{\symbolb\} \}$.

The set of next literals of $\regexNeg{\regexr}$ comprises the next
literals of $\regexr$ and a new literal, which is the intersection of
the complements of all literals in $\getFirst{\regexr}$.
We might contemplate to exclude literals that contain symbols
$\symbola$ such that $\deriv\symbola\regexr$ is equivalent to
$\regexWords$, but we refrain from doing so because this equivalence
cannot be decided with a finite set of rewrite
rules~\cite{Redko1964}. 

The function $\getFirst\regexr \setminus \{\emptyset\}$ computes the
equivalence classes of a partial equivalence relation $\sim$ on
$\regexAlphabet$ such that equivalent symbols yield the same
derivative on $\regexr$. The relation is defined by $\symbola \sim \symbolb$ if there exists
$\literall\in\getFirst\regexr$ such that $\symbola\in\literall$ and
$\symbolb\in\literall$. Furthermore, the derivative by a symbol that is not part of the 
relation yields the empty set.
\begin{lemma}[Partial Equivalence]\label{lemma:partial-equivalence}
  Let $\literalset = \getFirst\regexr$.
  \begin{enumerate}
    \item\label{item:1} $(\forall \literall\in\literalset)$ $(\forall \symbola,\symbolb\in \literall)$
      $\deriv\symbola\regexr = \deriv\symbolb\regexr$
    \item $(\forall \symbola\notin \bigcup \literalset)$
      $\deriv\symbola\regexr = \regexNull$
  \end{enumerate}
\end{lemma}
\begin{proof}[Proof of Lemma~\ref{lemma:partial-equivalence}]
  See Appendix~\ref{sec:partial-equivalence}.
\end{proof}
It remains to show that $\getFirst\regexr$ covers all symbols in
$\getNext\regexr$.
\begin{lemma}[First]\label{thm:first}
  For all $\regexr$,
  $\bigcup \getFirst\regexr \supseteq \getNext\regexr$.
\end{lemma}
\begin{proof}[Proof of Lemma~\ref{thm:first}]
  See Appendix~\ref{sec:first-next}.
\end{proof}
Moreover, there are only finitely many different next literals for each regular
expression. 
\begin{lemma}[Finiteness]\label{thm:cardinality}
  For all $\regexr$,
  $|\getFirst{\regexr}|$ is finite.
\end{lemma}
\begin{proof}[Proof of Lemma~\ref{thm:cardinality}]
  By induction on $\regexr$. The base cases construct finite sets and the inductive cases build a
  finite number of combinations of the results from the subexpressions.
\end{proof}
Now, we put next literals to work.
If we only take positive or negative derivatives with respect to next literals, then the inclusions in
Lemma~\ref{thm:derivatives} turn into equalities. The result is that both the positive and the negative
derivative, when applied to a next literal $\literall$, calculate a regular expression for the left quotient $\literall^{-1}\lang{\regexr}$. 
\begin{theorem}[Left Quotient]\label{thm:firstderivative}
  For all $\regexr$, $\literall\in\getFirst{\regexr} \setminus \{\emptyset\}$, and $\symbola\in\lang{\literall}$:
  \begin{align*}
    \lang{\pderiv{\literall}{\regexr}}=\lang{\nderiv{\literall}{\regexr}}=\lang{\deriv{\symbola}{\regexr}}
  \end{align*}
\end{theorem}
\begin{proof}[Proof of Lemma~\ref{thm:firstderivative}]
  By induction on $\regexr$. See Appendix~\ref{sec:proof-firstderivative}.
\end{proof}
Motivated by this result, we define the Brzozowski derivative for a non-empty subset $\literall$ of a literal in
$\getFirst\regexr$. This definition involves an arbitrary choice of $\symbola\in\literall$, but this choice does not
influence the calculated derivative according to Lemma~\ref{lemma:partial-equivalence}, part 1.
\begin{definition}\label{def:derivative-literals}
  Let $\literall' \in \getFirst\regexr$. For each $\emptyset \ne \literall \subseteq \literall'$ define
  $\deriv\literall\regexr \df \deriv\symbola\regexr$, where $\symbola \in \literall$.
\end{definition}
\begin{lemma}[Coverage]\label{thm:coverage}
  For all $\symbola$, $\wordu$, and $\regexr$ it holds that:
  \begin{align*}
    \wordu\in\lang{\deriv{\symbola}{\regexr}}~\Leftrightarrow~\exists\literall\in\getFirst{\regexr}:
    \symbola \in \literall \wedge
    \wordu\in\lang{\pderiv{\literall}{\regexr}} \wedge
    \wordu\in\lang{\nderiv{\literall}{\regexr}}
  \end{align*}
\end{lemma}
\begin{proof}[Proof of Lemma~\ref{thm:coverage}]
  This result follows from Theorem~\ref{thm:firstderivative} and Lemma~\ref{thm:first}.
\end{proof}
We conclude that to determine a finite set of  representatives for all derivatives of a regular
expression $\regexr$ it is sufficient to select one symbol $\symbola$ from each equivalence class 
$\literall \in \getFirst\regexr \setminus \{\emptyset\}$ and calculate $\deriv\symbola\regexr$.
Alternatively, we may calculate $\pderiv\literall\regexr$ or
$\nderiv\literall\regexr$ according to Theorem~\ref{thm:firstderivative}.
It remains to lift this result to solving inequalities.

\section{Solving Inequalities}
\label{sec:inequalities}

Theorem~\ref{thm:containment-antimirov} is the foundation of
Antimirov's algorithm. It turns out that we can prove a stronger
version of this theorem, which makes the rules \RefTirName{CC-Disprove}
and \RefTirName{CC-Unfold} sound and complete and which also encompasses
the soundness of the restriction to first sets.

\begin{theorem}[Containment]\label{thm:symbol-containment}
  \begin{align*}
    \isSubSetOf{\regexr}{\regexs}~\Leftrightarrow&~(\isNullable{\regexr}\Rightarrow\isNullable{\regexs})~\wedge~(\forall\symbola\in\getNext{\regexr})~\isSubSetOf{\deriv{\symbola}{\regexr}}{\deriv{\symbola}{\regexs}}
  \end{align*}
\end{theorem}

\begin{proof}[Proof of Theorem~\ref{thm:symbol-containment}]
  See Appendix~\ref{sec:proof-semantic-containment}.
\end{proof}
As we remarked before, it may be very expensive (or even impossible) to construct all derivatives with respect to the first
symbols, particularly for negated expressions and for large or infinite alphabets. To obtain a decision procedure for
containment, we need a finite set of derivatives. Therefore, we use next literals as representatives of the first
symbols and use Brzozowski derivatives on literals (Definition~\ref{def:derivative-literals}) on both sides.

To define the next literals of an inequality $\checkSubSetOf{\regexr}{\regexs}$, it would be sound to use the join of
the next literals of both sides: $\getFirst\regexr \literaljoin \getFirst\regexs$. However, we can do slightly
better. Theorem~\ref{thm:symbol-containment} proves that the first symbols of $\regexr$ are sufficient to prove
containment. Using the full join operation, however, would cover $\getNext\regexr \cup \getNext\regexs$ (by
Lemma~\ref{thm:first}). Hence, we define a left-biased version of the join operator that only covers the symbols of its
left operand.
\begin{definition}[Left Join]\label{def:left-join}
  Let $\literalset_1$ and $\literalset_2$ be two sets of mutually
  disjoint literals.
  \begin{align*}
    \literalset_1 \literalleftjoin \literalset_2~\df&
    \{
      (\literall_1\literalcap\literall_2),
      (\literall_1\literalcap\inv{\literalbigcup\literalset_2})
      \mid
    \literall_1\in \literalset_1, \literall_2\in \literalset_2\}
  \end{align*}
\end{definition}
The following lemma states the properties of the left join operation.
\begin{lemma}[Properties of Left Join]\label{lemma:properties-of-left-join}
  Let $\literalset_1$ and $\literalset_2$ be non-empty sets of mutually disjoint literals.
  \begin{enumerate}
    \item $\bigcup (\literalset_1 \literalleftjoin \literalset_2) = \bigcup \literalset_1$.
    \item $(\forall \literall\ne\literall' \in \literalset_1 \literalleftjoin \literalset_2)$ $\literall\sqcap\literall' = \emptyset$.
    \item $(\forall \literall \in \literalset_1 \literalleftjoin \literalset_2)$ $(\forall \literall_i \in \literalset_i)$
      $\literall \sqcap \literall_i \ne \emptyset \Rightarrow \literall \sqsubseteq \literall_i$.
  \end{enumerate}
\end{lemma}
\begin{proof}[Proof of Lemma~\ref{lemma:properties-of-left-join}]
  Analogous to the proof of Lemma~\ref{lemma:properties-of-join} in Appendix~\ref{sec:properties-join}.
\end{proof}
\begin{definition}[Next Literals of an Inequality]
  Let $\checkSubSetOf{\regexr}{\regexs}$ be an inequality.
  \begin{align*}
    \getFirst{\checkSubSetOf{\regexr}{\regexs}} \df
    \getFirst\regexr \literalleftjoin \getFirst\regexs
  \end{align*}
\end{definition}
Finally, we can state a generalization of Antimirov's containment theorem for
\ERE{}s, where each unfolding step generates only finitely many derivatives.
\begin{theorem}[Containment]\label{thm:containment}
  For all regular expressions $\regexr$ and $\regexs$,
  \begin{align*}
    \isSubSetOf{\regexr}{\regexs}~\Leftrightarrow&
    ~(\isNullable{\regexr}\Rightarrow\isNullable{\regexs})
    ~\wedge~
    (\forall\literall\in\getFirst{\checkSubSetOf{\regexr}{\regexs}})~\isSubSetOf{\deriv{\literall}{\regexr}}{\deriv{\literall}{\regexs}}.
  \end{align*}
\end{theorem}
\begin{proof}[Proof of Theorem~\ref{thm:containment}]
  The proof is by contraposition.
  If $\isNotSubSetOf{\regexr}{\regexs}$ then $\exists\literall\in\getFirst{\checkSubSetOf{\regexr}{\regexs}}:$
  $ \isNotSubSetOf{\deriv{\literall}{\regexr}}{\deriv{\literall}{\regexs}}$ or
  $\neg(\isNullable{\regexr}\Rightarrow\isNullable{\regexs})$.
  See also Appendix~\ref{sec:proof-symbolic-containment}.
\end{proof}
For $\literall\in\getFirst{\checkSubSetOf{\regexr}{\regexs}}$ define
$\nderiv\literall{\checkSubSetOf{\regexr}{\regexs}}
\df (\checkSubSetOf{\nderiv\literall\regexr}{\pderiv\literall\regexs})
= (\checkSubSetOf{\deriv\literall\regexr}{\deriv\literall\regexs})$.
\begin{theorem}[Finiteness]\label{thm:finiteness}
  Let $R$ be a finite set of regular inequalities. Define
  \begin{displaymath}
    F (R) =
    R \cup \{ \nderiv{\literall}{ \checkSubSetOf{{\regexr}}{{\regexs}}} \mid \checkSubSetOf{\regexr}{\regexs} \in R, \literall\in\getFirst{\checkSubSetOf{\regexr}{\regexs}} \}
  \end{displaymath}
  For each $\regexr$ and $\regexs$, the set $\bigcup_{i\in\nat}F^{(i)}
  (\{\isSubSetOf{\regexr}{\regexs}\})$ is finite.
\end{theorem}
\begin{proof}[Proof of Theorem~\ref{thm:finiteness}]
  As we consider regular expressions up to similarity (as defined by Brzozowski \cite{Brzozowski1964}) and
  $\nderiv{\literall}{ \checkSubSetOf{{\regexr}}{{\regexs}}} = \checkSubSetOf{\deriv\literall\regexr}{\deriv\literall\regexs}$ is
  essentially applying the Brzozowski derivative to a pair of (extended) regular expressions, we know that the set of
  these pairs is finite (because there are only finitely many dissimilar iterated Brzozowski derivatives for a regular
  expression \cite{Brzozowski1964}). 
\end{proof}
\begin{figure}[t]
  \begin{mathpar}
    \inferrule[\RuleCCDisprove]
    {\isNullable{\regexr}\\
      \neg\isNullable{\regexs}
    }
    {\ccCtx~\entails~\checkSubSetOf{\regexr}{\regexs}~:~\false }
    \and
    \inferrule[\RuleCCDelete]
    {\inCcCtx{\checkSubSetOf{\regexr}{\regexs}}}
    {\ccCtx~\entails~\checkSubSetOf{\regexr}{\regexs}~:~\true }\and
    \inferrule[\RuleCCUnfoldTrue]
    {\notInCcCtx{\checkSubSetOf{\regexr}{\regexs}}\\
      \isNullable\regexr \Rightarrow \isNullable\regexs\\
      \forall\literall\in\getFirst{\checkSubSetOf{\regexr}{\regexs}}:
      ~\ccCtx \cup\{\checkSubSetOf{\regexr}{\regexs}\}~\entails~
      \checkSubSetOf{\deriv{\literall}{\regexr}}{\deriv{\literall}{\regexs}}~:~\true }
    {\ccCtx~\entails~\checkSubSetOf{\regexr}{\regexs}~:~\true }\and
    \inferrule[\RuleCCUnfoldFalse]
    {\notInCcCtx{\checkSubSetOf{\regexr}{\regexs}}\\
      \isNullable\regexr \Rightarrow \isNullable\regexs\\
      \exists\literall\in\getFirst{\checkSubSetOf{\regexr}{\regexs}}:
      ~\ccCtx \cup\{\checkSubSetOf{\regexr}{\regexs}\}~\entails~
      \checkSubSetOf{\deriv{\literall}{\regexr}}{\deriv{\literall}{\regexs}}~:~\false }
    {\ccCtx~\entails~\checkSubSetOf{\regexr}{\regexs}~:~\false }
  \end{mathpar}
  \caption{Decision procedure for containment.}\label{fig:cc_unfold}
\end{figure}
These results are the basis for a complete decision procedure for
solving inequalities on extended regular expressions where literals are defined via an effective boolean algebra.
Figure~\ref{fig:cc_unfold} defines this procedure as a judgment of the form
$\ccCtx\entails\checkSubSetOf{\regexr}{\regexs}~:~b$, where $\ccCtx$ is a set of previous visited inequalities
$\checkSubSetOf\regexr\regexs$ with $\isNullable\regexr \Rightarrow \isNullable\regexs$ that are assumed to be true and
$b \in \{\true, \false\}$. The effective boolean algebra comes into play in the computation of the next literals
and in the computation of the derivatives.

Rule \Rule{\RuleCCDisprove} detects contradictory inequalities in the same way as Antimirov's rule \RefTirName{CC-Disprove}.
Rule \Rule{\RuleCCDelete} detects circular reasoning: Under the assumption that $\checkSubSetOf\regexr\regexs$ holds we
were not (yet) able to derive a contradiction and thus conclude that $\checkSubSetOf\regexr\regexs$ holds. This rule
guarantees termination because of the finiteness result (Theorem~\ref{thm:finiteness}).
The rules \Rule{\RuleCCUnfoldTrue} and \Rule{\RuleCCUnfoldFalse} apply only if $\checkSubSetOf{\regexr}{\regexs}$ is
neither contradictory nor in the context. A deterministic implementation would generate the literals
$\literall\in\getFirst{\checkSubSetOf\regexr\regexs}$ and recursively check
$\nderiv{\literall}{\checkSubSetOf{\regexr}{\regexs}}$. If any of these checks returns false, then
\Rule{\RuleCCUnfoldFalse} fires. Otherwise \Rule{\RuleCCUnfoldTrue} signals a successful containment
proof. Theorem~\ref{thm:containment} is the basis for soundness and completeness of the unfolding rules.
\begin{theorem}[Soundness]\label{thm:soundness}
  For all regular expression $\regexr$ and $\regexs$:
  \begin{align*}
    \emptyset~\entails~\checkSubSetOf{\regexr}{\regexs}~:~\top~\Leftrightarrow~\isSubSetOf{\regexr}{\regexs}
  \end{align*}
\end{theorem}
\begin{proof}[Proof of Theorem~\ref{thm:soundness}]
  We prove that $\ccCtx \entails \checkSubSetOf{\regexr}{\regexs} ~:~ \false$ iff $\isNotSubSetOf{\regexr}{\regexs}$, for
  all contexts $\ccCtx$ where $\checkSubSetOf{\regexr}{\regexs} \notin \ccCtx$. This is sufficient because each regular
  inequality gives rise to a finite derivation by Theorem~\ref{thm:finiteness}.
  See Appendix~\ref{sec:proof-soundness} for details.
\end{proof}
\begin{figure}[t]
  \centering
  \begin{mathpar}
    \inferrule[\RuleCCProveIdentity]
    {}
    {\ccCtx~\entails~\isSubSetOf{\regexr}{\regexr}~:~\true }\and
    \inferrule[\RuleCCProveEmpty]
    {}
    {\ccCtx~\entails~\isSubSetOf{\regexNull}{\regexs}~:~\true }\and
    \inferrule[\RuleCCProveNullable]
    {\isNullable{\regexs}
    }
    {\ccCtx~\entails~\isSubSetOf{\regexEmpty}{\regexs}~:~\true }\and
    \inferrule[\RuleCCDisproveEmpty]
    {\exists\literall\in\getFirst{\regexr}:~{\literall}\neq\emptyset }
    {\ccCtx~\entails~\isSubSetOf{\regexr}{\regexNull}~:~\false }
  \end{mathpar}
  \caption{Prove and disprove axioms.}\label{fig:cc_axioms}
\end{figure}
In addition to the rules from Figure~\ref{fig:cc_unfold}, we may add
auxiliary rules to detect trivially consistent or inconsistent
inequalities early (Figure~\ref{fig:cc_axioms} contains some examples). Such rules may be used to improve
efficiency. They decide containment directly instead of unfolding repeatedly. 

\section{Conclusion}

We extended Antimirov's algorithm for proving containment of regular expressions to extended regular expressions on
potentially infinite alphabets. To work effectively with such alphabets, we require that literals in regular expressions
are drawn from an effective boolean algebra. As a slight difference, we work with Brzozowski derivatives instead of
Antimirov's notion of partial derivative.

The main effort in lifting Antimirov's algorithm is to identify, for each regular inequality
$\checkSubSetOf\regexr\regexs$, a finite set of symbols such that calculating the derivation with respect to these
symbols covers all possible derivations with all symbols. We regard the construction of the set of suitable
representatives, embodied in the notion of next literals $\getFirst{\checkSubSetOf\regexr\regexs}$, as a key
contribution of this work.
