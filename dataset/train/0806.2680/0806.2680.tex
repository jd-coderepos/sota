In this section we define a translation
from stream constants in flat
or friendly nesting specifications to production terms.
In particular, the root $\rootsc$ of a specification $\atrs$
is mapped by the translation to a production term $\trnsl{\rootsc}$
with the property that if\/ $\atrs$ is flat (friendly nesting),
then the \daob{} lower bound on the production of $\rootsc$ in $\atrs$
equals (is bounded from below by)
the production of~$\trnsl{\rootsc}$.

\subsection{Translation of Flat and Friendly Nesting Symbols}\label{sec:translation:subsec:functions}





As a first step of the translation,
we describe how for a flat (or friendly nesting)
stream function symbol $\astrfun$ in a stream specification $\atrs$
a periodically increasing function $\sdtrnsl{\astrfun}$
can be calculated
that is (that bounds from below)
the \daob{} lower bound on the production of $\astrfun$
in $\atrs$. 

Let us again consider the rules
(i)~$\funap{\astrfun}{\strcns{\numsuc{x}}{\strcns{y}{\astr}}}
  \red \strcns{\numadd{\numsuc{x}}{y}}{\funap{\astrfun}{\strcns{y}{\astr}}}$,
and
(ii)~$\funap{\astrfun}{\strcns{\numzer}{\astr}}
  \red \strcns{\numzer}{\strcns{\numsuc{\numzer}}{\funap{\astrfun}{\astr}}}$
  from Fig.~\ref{fig:pascal}.
We model the \daob{} lower bound on the production of $\astrfun$
by a function from $\conat$ to $\conat$ defined as the unique solution for $\specvar{\astrfun}$ of the following system of equations.\label{transl:Pascal:f}
We disregard what the concrete stream elements are,
and therefore we take the infimum over all possible traces:
\[
  \specvarap{\astrfun}{n}
  = \inf\, \big\{ \specvarap{\astrfun,\text{(i)}}{n}, \specvarap{\astrfun,\text{(ii)}}{n} \big\}
\]
where the solutions for $\specvar{\astrfun,\text{(i)}}$ and $\specvar{\astrfun,\text{(ii)}}$
are the \daob{} lower bounds of $\astrfun$ assuming
that the first rule applied in the rewrite sequence is (i) or (ii), respectively.
The rule~(i) consumes two elements, produces one element
and feeds one element back to the recursive call.
For rule~(ii) these numbers are 1, 2, 0 respectively.
Therefore we get:
\begin{align*}
  \specvarap{\astrfun,\text{(i)}}{n}
  & = \letin{n' \defdby n-2},\;
      \text{if $n' < 0$ then $0$ else $1 + \specvarap{\astrfun}{1 + n'}$}
  \punc,
  \\
  \specvarap{\astrfun,\text{(ii)}}{n}
  & = \letin{n' \defdby n-1},\;
      \text{if $n' < 0$ then $0$ else $2 + \specvarap{\astrfun}{n'}$}
  \punc.
\end{align*}
The unique solution for $\specvar{\astrfun}$ is $n \mapsto \cosubtr{n}{1}$,
represented by the \ioterm{} $\ios{-}{-+}$. \label{trans:pascal:f}

In general, functions may have multiple arguments,
which during rewriting may get permuted, deleted or duplicated.
The idea is to trace single arguments, and to take the infimum
over traces in case an argument is duplicated.

In the definition of the translation of stream functions,
we need to distinguish the cases according to whether a symbol is weakly guarded or not:
On $\Ssmincns$ we define
\(
  {\sugsfsleadsto}
  \defdby
  \{
    \pair{\rootsymb{\ell}}{\rootsymb{r}}
    \where {\ell\to r} \in \Rs,\; \text{`$\sstrcns$'} \neq \rootsymb{r} \in \Ssmincns
  \}
  \punc.
\)
the \emph{dependency relation} between symbols in $\Ssmincns$.
We say that a symbol $\astrfun \in \Ssmincns$ is \emph{weakly guarded}
if $\astrfun$ is strongly normalising with respect to $\sugsfsleadsto$
and \emph{unguarded}, otherwise.
Note that since $\Ssmincns$ is finite it is (easily) decidable whether
a symbol $\astrfun\in\Ssmincns$ is weakly guarded or unguarded.


The translation of a stream function symbol
is defined as the unique solution of a (usually infinite)
system of defining equations where the unknowns are functions.
More precisely, for each symbol $\astrfun \in \Sfnest \supseteq \Ssf$ of a flat
or friendly nesting stream specification,
this system has a \pein{} function
$\sdtrnsl{\astrfun}$ as the solution for $\specvar{\astrfun}$,
which is unique among the continuous functions.
Later we will see 
(Prop.~\ref{prop:corr:pein:gate:transl} and Lem.~\ref{lem:transl:soundness})
that the translation $\sdtrnsl{\astrfun}$ of a flat (friendly nesting)
stream function symbol $\astrfun$ coincides with (is a lower bound for)
the \daob~lower bound $\doLow{\atrs}{\astrfun}$ of $\astrfun$. 
\begin{definition}\normalfont
  \label{def:transl:flat:fn:symbols:pifuncspec}
Let $\atrs = \pair{\Sigma}{R}$ be a stream specification.
For each flat or friendly nesting symbol
  $\astrfun \in \Sfnest \supseteq \Sflat$ with
  arities $k = \arityS{\astrfun}$ and $\ell = \arityD{\astrfun}$
  we define $\sdtrnsl{\astrfun}\funin\conat^{\,k}\to\conat$,
  called the \emph{(\pein~function) translation of\/ $\astrfun$ in $\atrs$}, 
  as the unique solution $s_{\specvar{\astrfun}}$ for $\specvar{\astrfun}$ 
  of the following system of defining equations,
  where the solution of an equation of the form
  $\specvarap{}{n_1,\ldots,n_k} = \ldots$ is a function 
  $s_\sspecvar\funin\conat^{k}\to\conat$
  (it is to be understood that $s_\sspecvar\in\conat$ if $k=0$):
For all $n_1,\ldots,n_k\in\conat$, 
  $i \in \{\argnone,1,\ldots,k\}$, and $n\in\nat$:
\begin{gather*}
    \specvarap{\astrfun}{n_1,\ldots,n_k}
    = \min(
        \specvar{\astrfun,\argnone},
        \specvarap{\astrfun,1}{n_1},
        \ldots,
        \specvarap{\astrfun,k}{n_k}
      )
    \punc{,}
    \\
    \specvar{\astrfun,\argnone}
    = \begin{cases}
        \inf\,
          \big\{
            \specvar{\astrfun,\argnone,\rho}
            \where \text{$\rho$ a defining rule of $\astrfun$}
          \big\}
        & \text{if $\astrfun$ is weakly guarded,} \\[-0.4ex]
        0 & \text{if $\astrfun$ is unguarded,}
      \end{cases}
    \\
    \specvarap{\astrfun,i}{n}
    = \begin{cases}
        \inf\,
          \big\{
            \specvarap{\astrfun,i,\rho}{n}
            \where \text{$\rho$ a defining rule of $\astrfun$}
          \big\}
        & \text{if $\astrfun$ is weakly guarded,} \\[-0.4ex]
        0 & \text{if $\astrfun$ is unguarded.}
      \end{cases}
  \end{gather*}
We write $\strcns{\vec{\adattrm}_i}{\astr_i}$ for
  $\strcns{\adattrm_{i,1}}{\strcns{\ldots}{\strcns{\adattrm_{i,p}}{\astr_i}}}$,
  and $\lstlength{\vec{\adattrm}_i}$ for $p$.
For specifying $\specvar{\astrfun,i,\rho}$ we distinguish
  the possible forms the rule $\rho$ can have.
If $\rho$ is nesting, then
  $\specvar{\astrfun,\argnone,\rho} = \conattop$,
  and 
  $\specvarap{\astrfun,i,\rho}{n} = n$ for all $n \in \conat$.
  Otherwise, $\rho$ is non-nesting and of the form:
  \[
    \funap{\astrfun}{
      (\strcns{\vec{\adattrm}_1}{\astr_1}),
      \ldots,
      (\strcns{\vec{\adattrm}_{k}}{\astr_{k}}),
      \bdattrm_1,\ldots,\bdattrm_{\ell}
    }
    \red
    \strcns{\cdattrm_{1}}{\strcns{\ldots}{\strcns{\cdattrm_{m}}{\astrtrm}}}
    \punc,
  \]
  where either (a)~$\astrtrm \equiv \astr_j$, or
  (b)~\(
        \astrtrm \equiv
        \funap{\bstrfun}{
        (\strcns{\vec{\ddattrm}_{\!1}}{\astr_{\permut{1}}}),
        \ldots,
        (\strcns{\vec{\ddattrm}_{\!k'}}{\astr_{\permut{k'}}}),
        \edattrm_1,\ldots,\edattrm_{\ell'}}
      \)
  with $k' = \arityS{\bstrfun}$, $\ell' = \arityD{\bstrfun}$, and
  $\spermut \funin \{1,\ldots,k'\} \to \{1,\ldots,k\}$.
Let:
  \begin{align*}
    \specvar{\astrfun,\argnone,\rho} = \
      &
      \begin{cases}
        \conattop &\text{case~(a)} \\
        m + \specvar{\bstrfun,\argnone} &\text{case~(b)}
      \end{cases}
    \\
    \specvarap{\astrfun,i,\rho}{n} = \
      &\letin{n' \defdby n - \lstlength{\vec{\adattrm}_i}}
      \text{, if $n' < 0$ then $0$ else }\\
      &
      m +
      \begin{cases}
        n'
        &\text{case~(a), $i = j$} \\
        \conattop
        &\text{case~(a), $i \neq j$} \\
        \inf\,
          \big\{
            \specvarap{\bstrfun,j}{n' + \lstlength{\vec{\ddattrm}_{\!j}}}
            \where j \in {\funap{\invfun{\spermut}}{i}}
          \big\}
        &\text{case~(b)}
      \end{cases}
  \end{align*}
where we agree $\inf \setemp = \conattop$.
\end{definition}


We mention a useful intuition for understanding the fabric of 
the formal definition above of the translation $\sdtrnsl{\astrfun}$ 
of a stream function $\astrfun$,
the solution $s_{\specvar{\astrfun}}$ for $\specvar{\astrfun}$
of the system of equations in Def.~\ref{def:transl:flat:fn:symbols:pifuncspec}. 
For each $i\in\{1,\ldots,k\}$ where $k = \arityS{\astrfun}$
the solution $s_{\specvar{\astrfun,i}}$ for $\specvar{\astrfun,i}$
(a unary \pein~function) in this system
describes to what extent consumption from the $i$-th component of $\astrfun$
`delays' the overal production.
Since in a \daob~rewrite sequence from
$\funap{\astrfun}{\strcns{\pebble^{n_1}}{\aiosq_1}, \ldots, \strcns{\pebble^{n_k}}{\aiosq_k}}$
it may happen that all stream variables $\aiosq_1$, \ldots, $\aiosq_k$
are erased at some point, and that the sequence subsequently continues rewriting stream constants,
monitoring the delays caused by individual arguments is not sufficient
alone to define the production function of $\astrfun$.
This is the reason for the use, in the definition of $\sdtrnsl{\astrfun}$,
of the solution $s_{\specvar{\astrfun,\argnone}}$ for the variable
$\specvar{\astrfun,\argnone}$, which defines a `glass ceiling' for
the not adequate `overall delay' function
$ \min(
        s_{\specvarap{\astrfun,1}{n_1}},
        \ldots,
        s_{\specvarap{\astrfun,k}{n_k}}
      )
$,
taking account of situations in which in \daob~rewrite sequences
from terms
$\funap{\astrfun}{\strcns{\pebble^{n_1}}{\aiosq_1}, \ldots, \strcns{\pebble^{n_k}}{\aiosq_k}}$
all input components have been erased.

Concerning non-nesting rules on which defining rules for
friendly nesting symbols depend via $\sdependson$,
this translation uses the fact that
their production is bounded below by `$\min$'.
These bounds are not necessarily optimal,
but can be used to show productivity of examples like
$\strcf{X} \to \strcns{\datf{0}}{\funap{\astrfun}{\strcf{X}}}$ with
$\funap{\astrfun}{\strcns{x}{\astr}} \to \strcns{x}{\funap{\astrfun}{\funap{\astrfun}{\astr}}}$.

Def.~\ref{def:transl:flat:fn:symbols:pifuncspec} can be used to define, 
for every flat or friendly nesting symbol $\astrfun\in\Ssf$ 
in a stream specification~$\atrs$, a `gate translation' of $\astrfun$:
by defining this translation by choosing
a gate that represents the \pein~function~$\sdtrnsl{\astrfun}$. 

However, it is desirable to define this translation also in an
equivalent way that lends itself better for computation,
and where the result directly is a production term (gate) representation 
of a \pein~function:
by specifying the \ioterm{s} in a gate translation
as denotations of rational \ioseq{s} that are
the solutions of `\ioseq\ specifications'. 
In particular, the gate translation of a symbol $\astrfun\in\Ssf$
will be defined in terms of the solutions, 
for each argument place of a stream function symbol $\astrfun$, 
of a finite \ioseq\ specification
that is extracted from an infinite one which precisely
determines the \daob{} lower bound of $\astrfun$ in that argument place.






\begin{definition}\normalfont\label{def:infioseqspecs}
  Let $\setvars$ be a set of variables.
  The set of \emph{\infioseqspecexp{s} over $\setvars$}
  is defined by the following grammar:
  \begin{equation*}
    \iosqsyx
    \BNFis
    \iosqemp
    \BNFor
    X
    \BNFor
    \iosqcns{\ioin}{\iosqsyx}
    \BNFor
    \iosqcns{\ioout}{\iosqsyx}
    \BNFor
    \iotermspecinf{\iosqsyx}{\iosqsyx}
  \end{equation*}
where $ X\in\setvars $.
  Guardedness is defined by induction:
  An \infioseqspecexp\ is called \emph{guarded}
  if it is of one of the forms 
  $\iosqemp$, $\iosqcns{\ioin}{\iosqsyx_0}$,
  or $\iosqcns{\ioout}{\iosqsyx_0}$, or if it is of the form
  $\iotermspecinf{\iosqsyx_1}{\iosqsyx_2}$ for guarded $\iosqsyx_1$
  and $\iosqsyx_2$.

  Suppose that $ \setvars = \{ X_{\alpha} \mid \alpha\in A \} $
  for some (countable) set $A$.
  Then by an \emph{\infioseqspec\ over (the set of recursion variables) $\setvars$}
  we mean
  a family $ \{ X_{\alpha} = \iosqsyx_{\alpha} \}_{\alpha\in A} $
  of \emph{recursion equations}, where, for all $\alpha\in A$,
  $\iosqsyx_{\alpha}$ is an \infioseqspecexp\ over $\setvars$.
  Let $\aioseqspec$ be an \infioseqspec.
  If $\aioseqspec$  consists of finitely many recursion equations,
  then it is called \emph{finite}.
  $\aioseqspec$ is called \emph{guarded} (\emph{weakly guarded})
  if the right-hand side of every recursion equation in $\aioseqspec$
  is guarded (or respectively, can be rewritten, using equational logic
  and the equations of $\aioseqspec$, to a guarded \infioseqspecexp).

  Let $ \aioseqspec = \{ X_{\alpha} = \iosqsyx_{\alpha} \}_{\alpha\in A} $
  an \infioseqspec. Furthermore let $\alpha_0\in A$ and $\biosq\in\infiosq$.
  We say that $\biosq$ is \emph{a solution of $\aioseqspec$ for $X_{\alpha_0}$}
  if there exist \ioseq{s} $\{\aiosq_{\alpha}\}_{\alpha\in A}$ 
  such that $ \aiosq_{\alpha_0} = \biosq $,
  and all of the recursion equations in $\aioseqspec$ 
  are true statements 
  (under the interpretation of $\siosqinf$ as defined in
   Def.~\ref{def:iosq:inf}),
  when, for all $\alpha\in A$,
  $\aiosq_{\alpha}$ is substituted for $X_{\alpha}$, respectively.
\end{definition}


It turns out that weakly guarded \infioseqspec{s} have unique solutions,
and that the solutions of finite, weakly guarded \infioseqspec{s} 
are rational \ioseq{s}.


\begin{lemma}\label{lem:wgnf}\label{lem:infioseqspec:ratsol}
For every weakly guarded \infioseqspec~$\aioseqspec$
  and recursion variable $X$ of $\aioseqspec$,
  there exists a unique solution $\aiosq\in\iosq$ of $\aioseqspec$ for $X$.
  Moreover, if $\aioseqspec$ is finite then the solution $\aiosq$
  of $\aioseqspec$ for $X$ is a rational \ioseq{}, 
  and an \ioterm\ that denotes $\aiosq$ can
  be computed on the input of $\aioseqspec$ and $X$. 
\end{lemma}








  Let $\atrs$ be a stream specification, and $\astrfun\in\Ssf$.
  By exhaustiveness of $\atrs$ for $\astrfun$, there is at least one
  defining rule for $\astrfun$ in $\atrs$.
  Since $\atrs$ is a constructor stream TRS, it follows that
  every defining rule $\rho$ for $\astrfun$ is of the form:
 \label{page:simple:non-nest:form}
  \begin{equation}
    \funap{\astrfun}{p_1, \ldots, p_{\arityS{\astrfun}}, q_1, \ldots, q_{\arityD{\astrfun}} }
    \to \strcns{\adattrm_{1}}{\strcns{\ldots}{\strcns{\adattrm_{m}}{\astrtrm}}}
    \tag{$\rho$}
  \end{equation}
  with $p_1, \ldots, p_{\arityS{\astrfun}} \in \ter{\cnssymb{\asig}}_\sortS$,
  $q_1, \ldots, q_{\arityD{\astrfun}} \in \ter{\cnssymb{\asig}}_\sortD$,
  $\adattrm_1,\ldots,\adattrm_m\in\ter{\asig}_\sortD$
  and $\astrtrm \in \ter{\asig}_\sortS$ where $\rootsymb{\astrtrm}\ne\text{`$\sstrcns$'}$.
If $\rho$ is non-nesting then either $\astrtrm \equiv \astr_j$ or
  \(
    \astrtrm \equiv
    \funap{\bstrfun}{
      \strcns{\vec{\cdattrm}_1}{\astr_{\permut{1}}},
      \ldots,
      \strcns{\vec{\cdattrm}_{\arityS{\strff{g}}}}{\astr_{\permut{\arityS{\strff{g}}}}},
      \ddattrm_1,\ldots,\ddattrm_{\arityD{\strff{g}}}
    }
  \)
  where $\strcns{\vec{\cdattrm}_i}{\astr_i}$ is shorthand for
  $\strcns{\cdattrm_{i,1}}{\strcns{\ldots}{\strcns{\cdattrm_{i,m_i}}{\astr_i}}}$,
  and $\spermut\funin{\{1,\ldots,\arityS{\strff{g}}\}\to\{1,\ldots,\arityS{\astrfun}\}}$
  is a function that describes how the stream arguments are permuted and
  replicated.


We now define, for every given stream specification $\atrs$, 
an infinite \infioseqspec~$\aioseqspec_{\atrs}$ that will be instrumental
for defining gate translations of the stream function symbols in $\atrs$.


\begin{definition}\normalfont
  \label{def:infioseqspec}
Let $\atrs = \pair{\Sigma}{R}$ be a stream specification.
Based on the set:
\begin{align*}
A \defdby & \: 
      \{ \pair{\lstemp}{\ios{-}{{}}},
         \pair{\lstemp}{\ios{+}{{}}},
         \pair{\lstemp}{\ios{-+}{{}}} 
      \}
    \\
      &
      \;\cup
      \Bigl\{
         \parbox{80pt}{$
           \pair{\astrfun}{\argnone},\,       
           \triple{\astrfun}{\argnone}{\rho},$\\
           $\triple{\astrfun}{i}{q} ,\,
           \quadruple{\astrfun}{i}{q}{\rho}
                       $}
           \,\Big| \;
             \parbox{170pt}{
               $\astrfun\in\Sfnest$, 
               $q\in\nat$,
               $\rho$ defining rule for $\astrfun$,
               \hspace*{\fill}$1\le i\le \arityS{\astrfun}$\hspace*{\fill}      
             }
           \Bigr\}
\end{align*}
of tuples
  we define the infinite \infioseqspec~$\aioseqspec_{\atrs} = \{ X_{\alpha} = E_{\alpha} \}_{\alpha\in A}$
  by listing the equations of $\aioseqspec_{\atrs}$.
  We start with the equations
\begin{align*}
  \Xm & = \iosqemp \punc,
  &
  \Xp & = \iosqcns{\ioout}{\Xp}
  \punc,
  &
  \Xid & = \iosqcns{\ioin}{\iosqcns{\ioout}{\Xid}}
  \punc.
  \end{align*}
  Then we let, for all friendly nesting (or flat) $\astrfun\in\Ssf$
  with arities $k = \arityS{\astrfun}$ and $\ell = \arityD{\astrfun}$:
  \begin{equation*}
\Xfi{\astrfun}{\argnone}
    = \begin{cases}
        \min
          \big\{
            \Xfiq{\astrfun}{\argnone}{\rho}
            \where \text{$\rho$ a defining rule of $\astrfun$}
          \big\}
        & \text{if $\astrfun$ is weakly guarded,} \\[-0.4ex]
        \Xm & \text{if $\astrfun$ is unguarded,}
      \end{cases}
  \end{equation*}
  and
for all
  $1\leq i\leq\arityS{\astrfun}$, and $q\in\nat$:
  \begin{equation*}
\Xfiq{\astrfun}{i}{q}
    = \begin{cases}
        \siosqInfm
          \big\{
            \Xfiqr{\astrfun}{i}{q}{\rho}
            \where \text{$\rho$ a defining rule of $\astrfun$}
          \big\}
        & \text{if $\astrfun$ is weakly guarded,} \\[-0.4ex]
        \Xm & \text{if $\astrfun$ is unguarded.}
      \end{cases}
\end{equation*}
  For specifying $\Xfiq{\astrfun}{\argnone}{\rho}$ and $\Xfiqr{\astrfun}{i}{q}{\rho}$
  we distinguish the possible forms the rule $\rho$ can have.
In doing so, we abbreviate terms 
  $\strcns{\adattrm_{i,1}}{\strcns{\ldots}{\strcns{\adattrm_{i,p}}{\astr_i}}}$
  with $\astr_i$ a variable of sort stream by $\strcns{\vec{\adattrm}_i}{\astr_i}$
  and let $\lstlength{\vec{\adattrm}_i} \defdby p$.
If $\rho$ is nesting, then we let 
\begin{align*}
    \Xfiq{\astrfun}{\argnone}{\rho} &= \Xp
    \punc,
    &
    \Xfiqr{\astrfun}{i}{q}{\rho} &= \Xid
    \punc.
  \end{align*}
Otherwise, $\rho$ is non-nesting and of the form:
  \[
    \funap{\astrfun}{
      (\strcns{\vec{\adattrm}_1}{\astr_1}),
      \ldots,
      (\strcns{\vec{\adattrm}_{k}}{\astr_{k}}),
      \bdattrm_1,\ldots,\bdattrm_{\ell}
    }
    \red
    \strcns{\cdattrm_{1}}{\strcns{\ldots}{\strcns{\cdattrm_{m}}{\astrtrm}}}
    \punc,
  \]
  where either (a)~$\astrtrm \equiv \astr_j$, or
  (b)~\(
        \astrtrm \equiv
        \funap{\bstrfun}{
        (\strcns{\vec{\ddattrm}_{\!1}}{\astr_{\permut{1}}}),
        \ldots,
        (\strcns{\vec{\ddattrm}_{\!k'}}{\astr_{\permut{k'}}}),
        \edattrm_1,\ldots,\edattrm_{\ell'}}
      \)
  with $k' = \arityS{\bstrfun}$, $\ell' = \arityD{\bstrfun}$, and
  $\spermut \funin \{1,\ldots,k'\} \to \{1,\ldots,k\}$.
Let:
\begin{align*}
    \Xfiq{\astrfun}{\argnone}{\rho} =
      & 
      \begin{cases}
        \Xp &\text{case~(a)} \\
        \iosqcns{\ioout^m}{\Xfi{\bstrfun}{\argnone}} &\text{case~(b)}
      \end{cases}
    \\
    \Xfiqr{\astrfun}{i}{q}{\rho} = 
      & \; \letin{p \defdby \cosubtr{\lstlength{\vec{\adattrm}_i}}{q}}, \:
                  q' \defdby \cosubtr{q}{\lstlength{\vec{\adattrm}_i}}
        \text{ in}
      \\
      &
      \iosqcat{\ioin^{p}}{\iosqcat{\ioout^{m}}}
      \begin{cases}
        \iosqcat{\ioout^{q'}}{\Xid}
        &\text{case~(a), $i = j$} \\
        \Xp
        &\text{case~(a), $i \neq j$} \\
        \siosqInfm
          \big\{
            \Xfiq{\bstrfun}{j}{q' + \lstlength{\vec{\ddattrm}_{\!j}}}
            \where j \in {\funap{\invfun{\spermut}}{i}}
          \big\}
        &\text{case~(b)} \end{cases}
  \end{align*}
where we agree $\iosqInfm{}{\setemp} \defdby \Xp$.
\end{definition}


We formally state an easy observation about the system $\aioseqspec_{\atrs}$
defined in Def.~\ref{def:transl:flat:fn:symbols:infioseqspec},
and an immediate consequence due to Lem.~\ref{lem:infioseqspec:ratsol}.


\begin{proposition}\label{prop:infioseqspec:wg}
Let $\atrs$ be a stream specification. 
  The \infioseqspec~$\aioseqspec_{\atrs}$ (defined in
  Def.~\ref{def:transl:flat:fn:symbols:infioseqspec}) is weakly guarded.
  As a consequence, 
  $\aioseqspec_{\atrs}$ has a unique solution in $\iosq$
  for every variable $X$ in $\aioseqspec_{\atrs}$.
\end{proposition}


Another easy observation is that the solutions for the 
variables $\Xfi{\astrfun}{\argnone}$ in a system $\aioseqspec_{\atrs}$
correspond very directly to numbers in $\conat$.


\begin{proposition}\label{prop:infioseqspec:argnone}
Let $\atrs$ be a stream specification and $\astrfun\in\Ssf$.
  The unique solution of $\aioseqspec_{\atrs}$ (defined in
  Def.~\ref{def:transl:flat:fn:symbols:infioseqspec})
  for $\Xfi{\astrfun}{\star}$ is of the form
  $\ioout^{\omega}$ or $\iosqcns{\ioout^n}{\iosqemp}$.
\end{proposition}

Furthermore observe that $\aioseqspec_{\atrs}$ is infinite in case that
$\Ssf\neq\emptyset$, and hence typically is infinite.
Whereas Lem.~\ref{lem:infioseqspec:ratsol} implies unique solvability
of $\aioseqspec_{\atrs}$ for individual variables
in view of (the first statement in) Prop.~\ref{prop:infioseqspec:wg}, 
it will usually not
guarantee that these unique solutions are rational \ioseq{s}.
Nevertheless it can be shown that all solutions
of $\aioseqspec_{\atrs}$ are rational \ioseq{s}.
For our purposes it will suffice to show this only for the solutions 
of $\aioseqspec_{\atrs}$ for certain of its variables.

We will only be interested in the solutions of $\aioseqspec_{\atrs}$
for variables $\Xfiq{\astrfun}{i}{0}$ and $\Xfi{\astrfun}{\argnone}$.
It turns out that from $\aioseqspec_{\atrs}$
a finite weakly guarded specification $\aioseqspec'_{\atrs}$ can be extracted
that, 
for each of the variables $\Xfiq{\astrfun}{i}{0}$ and $\Xfi{\astrfun}{\argnone}$,
has the same solution as $\aioseqspec_{\atrs}$, respectively.
Lem.~\ref{lem:infioseqspec:build:finite} below states that,
for a stream specification $\atrs$, the finite 
\infioseqspec~$\aioseqspec'_{\atrs}$ can always be obtained algorithmically,
which together with Lem.~\ref{lem:infioseqspec:ratsol} implies that
the unique solutions of $\aioseqspec_{\atrs}$ for the
variables $\Xfiq{\astrfun}{i}{0}$ and $\Xfi{\astrfun}{\argnone}$
are rational \ioseq{s}\
for which representing \ioterm{s} can be computed. 
As a consequence these solutions, for a stream specification $\atrs$,
of the recursion system $\aioseqspec_{\atrs}$, can be viewed to represent \pein~functions: 
the \pein~functions that are represented by the \ioterm\
denoting the respective solution, a rational \ioseq. 



As an example let us consider an \infioseqspec\ that corresponds to 
 the defining rules for $\astrfun$ in Fig.~\ref{fig:pascal}:
\begin{align*}
  X & = \iotermspecinf
        {\iosqcns{\ioin}{\iosqcns{\ioout}{\iosqcns{\ioout}{X}}}}
        {\iosqcns{\ioin}{\iosqcns{\ioin}{\iosqcns{\ioout}{Y}}}}
  &
  Y & = \iotermspecinf
        {\iosqcns{\ioout}{\iosqcns{\ioout}{X}}}
        {\iosqcns{\ioin}{\iosqcns{\ioout}{Y}}} \; .
\end{align*}
The unique solution for $X$ of this system is the rational \ioseq\
(and respectively, \ioterm)
$\iosqcns{\ioin}{\iosqcyc{\iosqcns{\ioin}{\iosqcns{\ioout}{\nix}}}}$,
which is the translation of $\astrfun$ (as mentioned earlier).



\begin{lemma}\label{lem:infioseqspec:build:finite}
Let $\atrs$ be a stream specification.
There exists an \infioseqspec\
  $\aioseqspec'_{\atrs} = \{ X_{\alpha} = E'_{\alpha} \}_{\alpha\in A'}$
such that:
\begin{enumerate}
    \renewcommand{\labelenumi}{(\roman{enumi})}
\item $\aioseqspec'_{\atrs}$ is finite and weakly guarded;    
\item $\{ \langle \astrfun,i,0 \rangle,
              \langle \astrfun,\argnone \rangle \,\mid\,
          \astrfun\in\Ssf, \, i,q\in\nat, \, 
          i\in\{1,\ldots,\arityS{\astrfun}\} \,\}
          \subseteq A' $;\\
for each $\astrfun\in\Ssf\cap\Sfnest$ 
      and $i\in\{1,\ldots,\arityS{\astrfun}\}$,
      $\aioseqspec'_{\atrs}$ has the same solution 
      for $\Xfiq{\astrfun}{i}{0}$,
      and respectively for $\Xfi{\astrfun}{\argnone}$,
      as the \infioseqspec{s}~$\aioseqspec_{\atrs}$ 
      (see Def.~\ref{def:infioseqspec});
\item on the input of $\atrs$, $\aioseqspec'_{\atrs}$ 
      can be computed. 
\end{enumerate}
\end{lemma}

\begin{proof}[Sketch]
An algorithm for obtaining $\aioseqspec'_{\atrs}$
  from $\aioseqspec_{\atrs}$ can be obtained as follows.
  On the input of $\aioseqspec_{\atrs}$,
  set $\aioseqspec\defdby\aioseqspec_{\atrs}$ and 
  repeat the following step on $\aioseqspec$ as long as it is applicable:
\begin{description}
\item[{\sf (RPC)}]
      Detect and remove a reachable \emph{non-consuming pseudo-cycle} from the 
      \infioseqspec~$\aioseqspec\,$:
      Suppose that, for a function symbol $\strff{h}$, for $j,k,l\in\nat$,
      and for a recursion variable $\Xfiq{\strff{h}}{j}{k}$ that is reachable
      from $\Xfiq{\astrfun}{i}{0}$, we have
      $ \lts{\Xfiq{\strff{h}}{j}{k}}{w}{\Xfiq{\strff{h}}{j}{l}} $
      (from the recursion variable $\Xfiq{\strff{h}}{j}{k}$
       the variable $\Xfiq{\strff{h}}{j}{l}$ is reachable
       via a path in the specification on which the finite~\ioseq~$w$
       is encountered as the word formed by consecutive labels),
      where $k<l$ and $w$ only contains symbols `$\ioout$'.
      Then modify $\aioseqspec$ by setting
      $ \Xfiq{\strff{h}}{j}{k} = \Xp $.
\end{description}
It is not difficult to show that a step {\sf (RPC)} 
  preserves weakly guardedness and the unique solution 
  of $\aioseqspec_{\atrs}$, 
  and that, on the input of $\aioseqspec_{\atrs}$, 
  the algorithm terminates in finitely many steps, 
  having produced an \infioseqspec~$\aioseqspec'_{\atrs}$ 
  with $\trnsli{\astrfun}{i}$ as the solution for $\Xfiq{\astrfun}{i}{0}$
  and the property
  that only finitely many recursion variables are reachable
  in $\aioseqspec'_{\atrs}$ from
  $\Xfiq{\astrfun}{i}{0}$.
  \qed
\end{proof}


As an immediate consequence of 
Lem.~\ref{lem:infioseqspec:build:finite},
 
and of Lem.~\ref{lem:infioseqspec:ratsol} we obtain the following lemma.


\begin{lemma}\label{lem:wd:def:transl:flat:fn:symbols:infioseqspec}
Let $\atrs$ be a stream specification,
  and let $\astrfun\in\Ssf$.
\begin{enumerate}
\item For each $i\in\{1,\ldots,\arityS{\astrfun}\}$
       there is precisely one \ioseq~$\aiosq$ that solves
       $\aioseqspec_{\atrs}$ for $\Xfiq{\astrfun}{i}{0}$;
       furthermore, $\aiosq$ is rational.
       Moreover there exists an algorithm that,
       on the input of $\atrs$, $\astrfun$, and $i$,
       computes the shortest \ioterm\ that denotes the 
       solution of $\aioseqspec_{\atrs}$ for $\Xfiq{\astrfun}{i}{0}$.
\item There is precisely one \ioseq~$\aiosq$ that solves
       $\aioseqspec_{\atrs}$ for $\Xfi{\astrfun}{\argnone}$;
       this \ioseq\ is rational.
       And there is an algorithm that, 
       on the input of $\atrs$ and $\astrfun$,
       computes the shortest \ioterm\ that denotes the 
       solution of $\aioseqspec_{\atrs}$ 
       for $\Xfi{\astrfun}{\argnone}$.
\end{enumerate}
\end{lemma}


Lem.~\ref{lem:wd:def:transl:flat:fn:symbols:infioseqspec} guarantees 
the well-definedness in the definition below
of the `gate translation' for flat or friendly nesting stream functions 
in a stream specification. 

\begin{definition}\normalfont
  \label{def:transl:flat:fn:symbols:infioseqspec}
Let $\atrs = \pair{\Sigma}{R}$ be a stream definition. 
For each flat or friendly nesting symbol
  $\astrfun \in \Ssf \cap \Sfnest $ 
  with stream arity $k = \arityS{\astrfun}$ we define the \emph{gate translation $\trnsl{\astrfun}$ of\/~$\astrfun$} by:
\begin{equation*}
    \trnsl{\astrfun}
    \defdby
    \egate{\trnsli{\astrfun}{\argnone}}{
      \trnsli{\astrfun}{1},\ldots,\trnsli{\astrfun}{\arityS{\astrfun}}
    }
    \punc,
  \end{equation*}
where $\trnsli{\astrfun}{\argnone}\in\conat$ is defined by:
\begin{equation*}
\trnsli{\astrfun}{\argnone} \defdby
      \begin{cases}
n & \text{the unique solution of $\aioseqspec_{\atrs}$ 
              for $\Xfi{\astrfun}{\argnone}$ is $\iosqcns{\ioout^{n}}{\iosqemp}$}
        \\
        \conattop &
          \text{the unique solution of $\aioseqspec_{\atrs}$ 
              for $\Xfi{\astrfun}{\argnone}$ is $\ioout^{\omega}$}    
      
      \end{cases}
\end{equation*}
and, for $1\le i\le \arityS{\astrfun}$,
  $\trnsli{\astrfun}{i}$ is the shortest \ioterm\ that denotes
  the unique solution for $\Xfiq{\astrfun}{i}{0}$
  of the weakly guarded \infioseqspec~$\aioseqspec_{\atrs}$
  in Def.~\ref{def:infioseqspec}.
\end{definition}


From Lem.~\ref{lem:wd:def:transl:flat:fn:symbols:infioseqspec}
we also obtain that, for every stream specification,
the function which maps stream function symbols
to their gate translations is computable. 


\begin{lemma}\label{lem:transl:termination}
There is an algorithm that, on the input
  of a stream specification~$\atrs$, and
  a flat or friendly nesting symbol~$\astrfun\in\Ssf\cap\Sfnest$,
  computes the gate translation $\trnsl{\astrfun}$ of $\astrfun$.
\end{lemma}


\begin{example}
Consider a flat stream specification
consisting of the rules:
\begin{gather*}
\funap{\astrfun}{\strcns{x}{\astr}}
    \to \strcns{x}{\tfunap{\bstrfun}{\astr}{\astr}{\astr}}
    \punc,
\\
    \tfunap{\bstrfun}{\strcns{x}{\strcns{y}{\astr}}}{\bstr}{\cstr}
    \to \strcns{x}{\tfunap{\bstrfun}{\strcns{y}{\bstr}}{\strcns{y}{\cstr}}{\strcns{y}{\astr}}}
    \punc.
\end{gather*}
The translation of $\astrfun$ is $\trnsl{\astrfun}=\netgate{\trnsli{\astrfun}{1}}$,
  where $\trnsli{\astrfun}{1}$ is the unique solution for $\Xfiq{\astrfun}{1}{0}$
  of the \infioseqspec~$\aioseqspec_{\atrs}$:
\begin{gather*}
\Xfiq{\astrfun}{1}{0}
      =
    \iosqcns{\ioin}{\iosqcns{\ioout}{
(\iotermspecinf{\Xfiq{\bstrfun}{1}{0}}{\iotermspecinf{\Xfiq{\bstrfun}{2}{0}}{\Xfiq{\bstrfun}{3}{0}}})
      }}
    \\
    \begin{aligned}
\Xfiq{\bstrfun}{1}{0}
      & = \iosqcns{\ioin}{\iosqcns{\ioin}{\iosqcns{\ioout}{\Xfiq{\bstrfun}{3}{1}}}}
      &
     \Xfiq{\bstrfun}{1}{1}
      & = \iosqcns{\ioin}{\iosqcns{\ioout}{\Xfiq{\bstrfun}{3}{1}}}
\end{aligned}
    \\
    \Xfiq{\bstrfun}{1}{q}
      = \iosqcns{\ioout}{\Xfiq{\bstrfun}{3}{q-1}}
      \quad (q \geq 2)
    \\
    \Xfiq{\bstrfun}{2}{q}
      = \iosqcns{\ioout}{\Xfiq{\bstrfun}{1}{q+1}}
    \quad (q\in\nat)
    \\
    \Xfiq{\bstrfun}{3}{q}
      = \iosqcns{\ioout}{\Xfiq{\bstrfun}{2}{q+1}}
    \quad (q\in\nat)
\end{gather*}

  By the algorithm referred to in Lem.~\ref{lem:transl:termination}
  this infinite specification can be turned into a finite one. The `non-consuming pseudocycle'
  $\lts{\Xfiq{\bstrfun}{3}{1}}{\ioout\ioout\ioout}{\Xfiq{\bstrfun}{3}{2}}$
  justifies the modification of $\aioseqspec_{\atrs}$ by setting
  $\Xfiq{\bstrfun}{3}{1} = \iosqcns{\ioout}{\Xfiq{\bstrfun}{3}{1}}$;
  likewise we set $\Xfiq{\bstrfun}{3}{0} = \iosqcns{\ioout}{\Xfiq{\bstrfun}{3}{0}}$.
  Furthermore all equations not reachable from $\Xfiq{\astrfun}{1}{0}$ are removed
  (garbage collection), 
  and we obtain a finite specification $\aioseqspec'_{\atrs}$, which,
  by Lem.~\ref{lem:infioseqspec:ratsol}, has a periodically increasing
  solution, with \ioterm-denotation
  $\trnsli{\astrfun}{1} = \pair{\ios{-+--}{\nix}}{\ios{+}{\nix}} $.
The reader may try to calculate the gate corresponding to $\bstrfun$,
  it is:
  \(
    \trnsl{\bstrfun} = \netgate{\ios{--}{+},\ios{+-}{+},\ios{}{+}}
  \).

  Second, consider the flat stream specification
  with data constructor symbols $\datf{0}$ and $\datf{1}$:
\begin{gather*}
    \begin{aligned}
      \funap{\astrfun}{\strcns{\datf{0}}{\astr}} & \to \funap{\bstrfun}{\astr} \punc,
      & \hspace*{1ex}
      \funap{\astrfun}{\strcns{\datf{1}}{\strcns{x}{\astr}}} & \to \strcns{x}{\funap{\bstrfun}{\astr}} \punc,
    \end{aligned}
    \\
    \funap{\bstrfun}{\strcns{x}{\strcns{y}{\astr}}} \to \strcns{x}{\strcns{y}{\funap{\bstrfun}{\astr}}} \punc,
  \end{gather*}
denoted $\rho_{\astrfunsub\datf{0}}$, $\rho_{\astrfunsub\datf{1}}$,
  and $\rho_{\bstrfunsub}$, respectively.
  Then, $\trnsli{\astrfun}{1}$ is the solution
  for $\Xfiq{\astrfun}{1}{0}$ of \begin{gather*}
\Xfiq{\astrfun}{1}{0}
      =
    \iotermspecinf{
      \Xfiqr{\astrfun}{1}{0}{\rho_{\astrfunsub\datf{0}}}}{
      \Xfiqr{\astrfun}{1}{0}{\rho_{\astrfunsub\datf{1}}}
                   }
    \\
\begin{aligned}
\Xfiqr{\astrfun}{1}{0}{\rho_{\astrfunsub\datf{0}}}
        & =
      \iosqcns{\ioin}{\Xfiq{\bstrfun}{1}{0}}
      & \hspace*{0.5ex}
      \Xfiqr{\astrfun}{1}{0}{\rho_{\astrfunsub\datf{1}}}
        & =
      \iosqcns{\ioin}{\iosqcns{\ioin}{\iosqcns{\ioout}{\Xfiq{\bstrfun}{1}{0}}}}
\end{aligned}
\\
\Xfiq{\bstrfun}{1}{0}
      =
    \iosqcns{\ioin}{\iosqcns{\ioin}{\iosqcns{\ioout}{\iosqcns{\ioout}{\Xfiq{\bstrfun}{1}{0}}}}}
    \punc.
\end{gather*}
\end{example}

\begin{example}\label{ex:pure}
  Consider a pure stream specification with the function layer: \begin{gather*}
    \funap{\astrfun}{\strcns{x}{\astr}} \to \strcns{x}{\tfunap{\bstrfun}{\astr}{\astr}{\astr}} \punc,
    \\
    \tfunap{\bstrfun}{\strcns{x}{\strcns{y}{\astr}}}{\bstr}{\cstr}
    \to \strcns{x}{\tfunap{\bstrfun}{\strcns{y}{\bstr}}{\strcns{y}{\cstr}}{\strcns{y}{\astr}}} \punc.
  \end{gather*}
The translation of $\astrfun$ is $\sdtrnsl{\astrfun}$,
  the unique solution for $\specvar{\astrfun}$ of the system:
\begin{align*}
    \specvarap{\astrfun}{n}
    =\ &\min(\specvarap{\astrfun,\argnone}{0}, \specvarap{\astrfun,1}{n})\\
    \specvarap{\astrfun,1}{n}
    =\ &\letin{n' \defdby n-1}\\
      &\text{if $n' < 0$ then $0$ else }
      1 +
      \inf\, \big\{ \specvarap{\bstrfun,1}{n'},\, \specvarap{\bstrfun,2}{n'},\,
                 \specvarap{\bstrfun,3}{n'} \big\}
    \\
    \specvarap{\astrfun,\argnone}{n}
    =\ &1 + \specvarap{\bstrfun,\argnone}{0}
    \\
    \specvarap{\bstrfun,1}{n}
    =\ &\letin{n' \defdby n-2},\;
      \text{if $n' < 0$ then $0$ else $1 + \specvarap{\bstrfun,3}{1 + n'}$}
    \\
    \specvarap{\bstrfun,2}{n}
    =\ &1 + \specvarap{\bstrfun,1}{1 + n}
    \\
    \specvarap{\bstrfun,3}{n}
    =\ &1 + \specvarap{\bstrfun,2}{1 + n}
    \\
    \specvarap{\bstrfun,\argnone}{n}
    =\ &1 + \specvarap{\astrfun,\argnone}{0}
  \end{align*}
An algorithm for solving such systems of equations is described
  in (the proof of) Lemma~\ref{lem:infioseqspec:build:finite}; here we solve the system directly.
  Note that
  $\specvarap{\bstrfun,3}{n} = 1 + \specvarap{\bstrfun,2}{n+1} = 2 + \specvarap{\bstrfun,1}{n+2} = 3 + \specvarap{\bstrfun,3}{n}$,
  hence $\myall{n \in \nat}{\specvarap{\bstrfun,3}{n} = \conattop}$.
  Likewise we obtain $\specvarap{\bstrfun,2}{n} = \conattop$ if $n \ge 1$ and $1$ for $n = 0$,
  and $\specvarap{\bstrfun,1}{n} = \conattop$ if $n \ge 2$ and $0$ for $n \le 1$.
  Then we get $\dtrnsl{\astrfun}{0}=0$, $\dtrnsl{\astrfun}{1}=\dtrnsl{\astrfun}{2}=1$,
  and $\dtrnsl{\astrfun}{n}=\conattop$ for all $n\geq 2$,
  represented by the gate $\trmrep{\sdtrnsl{\astrfun}}=\netgate{\ios{-+--}{+}}$.
  The gate corresponding to $\bstrfun$ is
  $\trmrep{\sdtrnsl{\bstrfun}}=\netgate{\ios{--}{+},\ios{+-}{+},\ios{}{+}}$.
  \end{example}
\begin{example}\label{ex:flat}
  Consider a flat stream function specification
  with the following rules which use pattern matching on the data constructors $\datf{0}$ and $\datf{1}$:
  \begin{align*}
    \funap{\astrfun}{\strcns{\datf{0}}{\astr}} &\to \funap{\bstrfun}{\astr}
    &
    \funap{\astrfun}{\strcns{\datf{1}}{\strcns{x}{\astr}}} &\to \strcns{x}{\funap{\bstrfun}{\astr}}
    &
    \funap{\bstrfun}{\strcns{x}{\strcns{y}{\astr}}} &\to \strcns{x}{\strcns{y}{\funap{\bstrfun}{\astr}}}
  \end{align*}
denoted $\rho_{\astrfunsub_\datf{0}}$, $\rho_{\astrfunsub_\datf{1}}$,
  and $\rho_{\bstrfunsub}$, respectively.
  Then, $\sdtrnsl{\astrfun}$ is the solution for $\specvar{\astrfun,1}$ of:
\begin{align*}
    \specvarap{\astrfun}{n}
    &= \min(\specvarap{\astrfun,\argnone}{0}, \specvarap{\astrfun,1}{n})\\
    \specvarap{\astrfun,1}{n}
    &=
    \inf\, \big\{
      \specvarap{\astrfun,1,\rho_{\astrfunsub_\datf{0}}}{n},\,
      \specvarap{\astrfun,1,\rho_{\astrfunsub_\datf{1}}}{n} \big\}
    \\
    \specvarap{\astrfun,1,\rho_{\astrfunsub_\datf{0}}}{n}
    & =
    \letin{n' \defdby n-1},\;
    \text{if $n' < 0$ then $0$ else $\specvarap{\bstrfun,1}{n'}$}
    \\
    \specvarap{\astrfun,1,\rho_{\astrfunsub_\datf{1}}}{n}
    &=
    \letin{n' \defdby n-2},\;
    \text{if $n' < 0$ then $0$ else $1 + \specvarap{\bstrfun,1}{n'}$}
    \\
    \specvarap{\astrfun,\argnone}{n}
    &= \min(\specvarap{\bstrfun,\argnone}{0}, 1 + \specvarap{\bstrfun,\argnone}{0})
    \\
    \specvarap{\bstrfun,1}{n}
    &=
    \letin{n' \defdby n-2},\;
    \text{if $n' < 0$ then $0$ else $2 + \specvarap{\bstrfun,1}{n'}$}
    \\
    \specvarap{\bstrfun,\argnone}{n}
    &= 2 + \specvarap{\bstrfun,\argnone}{0}
    \punc.
  \end{align*}
  As solution we obtain an overlapping of both traces
  $\sdtrnsli{\astrfun}{1,\rho_{\astrfunsub_\datf{0}}}$ and
  $\sdtrnsli{\astrfun}{1,\rho_{\astrfunsub_\datf{1}}}$,
  that is,
  $\dtrnsli{\astrfun}{1}{n} = \cosubtr{n}{2}$
  represented by the gate $\trmrep{\sdtrnsl{\astrfun}} = \netgate{\ios{--}{-+}}$.
\end{example}


The following proposition explains the correspondence between
Def.~\ref{def:transl:flat:fn:symbols:pifuncspec}
and Def.~\ref{def:transl:flat:fn:symbols:infioseqspec}.


\begin{proposition}\label{prop:corr:pein:gate:transl}
Let $\atrs$ be a stream specification.
  For each $\astrfun\in\Ssf$ it holds:
\begin{equation*}
\funap{\sdtrnsl{\astrfun}}{n_1,\ldots,n_k}
      = \iosqprd{\trnsl{f}}{n_1,\ldots,n_k}
    \qquad
    \text{(for all $n_1,\ldots,n_k\in\conat$),} 
\end{equation*}
where $k = \arityS{\astrfun}$.
  That is,
  the \pein~function translation $\sdtrnsl{\astrfun}$ of\/ $\astrfun$
  coincides with the \pein~function that is represented by the
  gate translation $\trnsl{\astrfun}$.
\end{proposition}


The following lemma states that the translation $\sdtrnsl{\astrfun}$
of a flat stream function symbol $\astrfun$ 
(as defined in Def.~\ref{def:transl:flat:fn:symbols:pifuncspec})
is the \daob{} lower bound on the production function of $\astrfun$.
For friendly nesting stream symbols $\astrfun$ it states
that $\sdtrnsl{\astrfun}$ pointwisely bounds from below
the \daob{} lower bound on the production function of $\astrfun$.


\begin{lemma}\label{lem:transl:soundness}
  Let $\atrs$ be a stream specification,
  and let\/ $\astrfun \in \Sfnest \supseteq \Sflat$.
\begin{enumerate}
    \item If\/ $\astrfun$ is flat, then:\/
      $\sdtrnsl{\astrfun} = \doLow{\atrs}{\astrfun}$.
      Hence, $\doLow{\atrs}{\astrfun}$ is periodically increasing.
    \item If\/ $\astrfun$ is friendly nesting, then it holds:\/
      $\sdtrnsl{\astrfun} \le \doLow{\atrs}{\astrfun}$
      (pointwise inequality).
  \end{enumerate}
\end{lemma}




\subsection{Translation of Stream Constants}
  \label{sec:translation:subsec:constants}



In the second step, we now define a translation of
stream constants
in a flat or friendly nesting stream specification into production terms
under the assumption that gate translations for the stream functions are given.
Here the idea is that the recursive definition of a stream constant
$\msf{M}$ is unfolded step by step;
the terms thus arising are translated according to their
structure using gate translations of the stream function symbols
from a given family of gates;
whenever a stream constant is met that has been unfolded before,
the translation stops after establishing a binding to a $\mu$-binder
created earlier.


\begin{definition}\label{def:trnsl:nets}\normalfont
Let $\atrs = \pair{\asig}{R} $ be a stream specification,
  and $\afam = \{\fgate\}_{\astrfun\in\Ssf}$ a family of gates that
  are associated with the symbols in $\Ssf$.
  
  Let $\ter{\asig}_{\sortS}^0$ be the set of terms in $\atrs$
  of sort stream that do not contain variables of sort stream. 
The \emph{translation function}
  $\trnslF{\cdot}{\afam} \funin \ter{\asig}_{\sortS}^0 \to \net$
  is defined by $\astrtrm \mapsto \trnslF{\astrtrm}{\afam} \defdby \trnsliF{\astrtrm}{\setemp}{\afam}$
  based on the following definition of expressions
  $\trnsliF{\astrtrm}{\alst}{\afam}$, where $\alst \subseteq \Ssc$,
  by induction 
  on the structure of $\astrtrm\in\ter{\asig}_{\sortS}^0$,
  using the clauses:
\begin{gather*}
\begin{aligned}
\trnsliF{\funap{\astrcon}{\vec{\adattrm}}}{\alst}{\afam}
&\defdby
      \begin{cases}
      \netrec{M}{\snetmeet\; \{ \trnsliF{r}{\setunion{\alst}{\{\astrcon\}}}{\afam}
                         \where \funap{\astrcon}{\vec{\bdattrm}} \to r \in R\} }
      &\text{if $\astrcon\not\in\alst$}
      \\
      M
      &\text{if $\astrcon\in\alst$}
      \end{cases}
    \\
\trnsliF{\strcns{\adattrm}{\astrtrm}}{\alst}{\afam}
    &\defdby \netpeb{\trnsliF{\astrtrm}{\alst}{\afam}}
\end{aligned}
\\
\trnsliF{\funap{\astrfun}{\astrtrm_1,\ldots,\astrtrm_{\arityS{\astrfun}},\adattrm_1,\ldots,\adattrm_{\arityD{\astrfun}}}}{\alst}{\afam}
    \defdby
    \funap{\fgate}
       {\trnsliF{\astrtrm_1}{\alst}{\afam},\ldots,
          \trnsliF{\astrtrm_{\arityS{\astrfun}}}{\alst}{\afam}}
\end{gather*}
where $\astrcon\in\Ssc$, 
  $\vec{\adattrm} = \langle \adattrm_1, \ldots, \adattrm_{\arityD{\astrcon}} \rangle$
  a vector of terms in $\ter{\asig}_{\sortD}$, 
  $\astrfun\in\Ssf$,\linebreak
  $\astrtrm, \astrtrm_1, \ldots \astrtrm_{\arityS{\astrfun}} \in\ter{\asig}_{\sortS}^0$,
  and 
  $\adattrm, \adattrm_1,\ldots,\adattrm_{\arityD{\astrfun}}\in\ter{\asig}_{\sortD}$.
Note that the definition
  of $\trnsliF{\funap{\astrcon}{\vec{\adattrm}}}{\alst}{\afam}$
  does not depend on the vector $\vec{\adattrm}$ of terms
  in $\ter{\asig}_{\sortD}$.
  Therefore we define, for all $\astrcon\in\Ssc$,
  the \emph{translation of $\astrcon$ with respect to $\afam$} by 
  $\trnslF{\astrcon}{\afam} \defdby 
    \trnsliF{\funap{\astrcon}{\vec{x}}}{\emptyset}{\afam}
    \in \net $
  where $\vec{x} = \langle x_1, \ldots, x_{\arityD{\astrcon}} \rangle$
  is a vector of data variables. 
\end{definition}





The following lemma is the basis of our result in Sec.~\ref{sec:results},
Thm.~\ref{thm:decide:prod:flat:pure}, concerning the decidability of 
\daob{} productivity for flat stream specifications.
In particular the lemma states that if we use gates that represent \daobly{} optimal lower bounds
on the production of the stream functions,
then the translation of a stream constant $\astrcon$
yields a production term that rewrites to the \daob{} lower bound of the production of $\astrcon$.




\begin{lemma}
  \label{lem1:outsourcing}
Let $\atrs = \pair{\Sigma}{R}$ be a stream specification, and
  $\afam = \{\fgate\}_{\astrfun\in\Ssf}$ be a family of gates
  such that, for all\/ $\astrfun\in\Ssf$, the arity of\/ $\fgate$
  equals the stream arity of\/ $\astrfun$.
  Then the following statements hold:
\begin{enumerate}
    \renewcommand{\labelenumi}{(\roman{enumi})}
\item\label{lem1:outsourcing:item:1}
      Suppose that\/ $\siosqprd{\fgate} = \doLow{\atrs}{\astrfun}$
      holds for all\/ $\astrfun \in \Ssf$.
Then for all\/ $\astrcon\in\Ssc$ 
      and vectors $\vec{\adattrm} = \langle \adattrm_1, \ldots, \adattrm_{\arityD{\astrcon}} \rangle$ 
      of data terms
$\; \netprd{\trnslF{\astrcon}{\afam}}
                = \doLow{\atrs}{\funap{\astrcon}{\vec{u}}} $
      holds.                   
And consequently, $\atrs$ is \daobly{} productive
      if and only if\/ $\netprd{\trnslF{\rootsc}{\afam}} = \infty$.
\vspace*{0.75ex}
\item\label{lem1:outsourcing:item:2}
      Suppose that\/ $\siosqprd{\fgate} = \doUp{\atrs}{\astrfun}$
      holds for all\/ $\astrfun \in \Ssf$.
Then for all\/ $\astrcon\in\Ssc$ 
      and vectors $\vec{\adattrm} = \langle \adattrm_1, \ldots, \adattrm_{\arityD{\astrcon}} \rangle$ 
      of data terms 
$\; \netprd{\trnslF{\astrcon}{\afam}}
                = \doUp{\atrs}{\funap{\astrcon}{\vec{u}}} $
      holds.          
And consequently, $\atrs$ is \daobly{} non-productive
      if and only if\/ $\netprd{\trnslF{\rootsc}{\afam}} < \infty$.
\end{enumerate}
\end{lemma}
Lem.~\ref{lem1:outsourcing} is an immediate consequence of the following lemma,
which also is the basis of our result in Sec.~\ref{sec:results} 
concerning the recognizability of productivity for flat and friendly nesting
stream specifications. 
In particular the lemma below asserts that if we use gates that
represent \pein{} functions which are lower bounds 
on the production of the stream functions,
then the translation of a stream constant $\astrcon$
yields a production term that rewrites to a number in $\conat$
smaller or equal to the \daob{} lower bound of the production of $\astrcon$.


\begin{lemma}
  \label{lem2:outsourcing}
Let $\atrs$ be a stream specification, and let\/
  $\afam = \{\fgate\}_{\astrfun\in\Ssf}$ be a family of gates
  such that, for all\/ $\astrfun\in\Ssf$, the arity of\/ $\fgate$
  equals the stream arity of\/ $\astrfun$.
Suppose that one of the following statements holds:
\begin{enumerate}[(a)]
\item $\siosqprd{\fgate} \le \doLow{\atrs}{\astrfun}$ for all\/ $\astrfun \in \Ssf\,$;\label{lem2:outsourcing:item:1}\vspace{0.5ex}
\item $\siosqprd{\fgate} \ge \doLow{\atrs}{\astrfun}$ for all\/ $\astrfun \in \Ssf\,$;\label{lem2:outsourcing:item:2}\vspace{0.5ex}
\item $\doUp{\atrs}{\astrfun} \le \siosqprd{\fgate}$ for all\/ $\astrfun \in \Ssf\,$;\label{lem2:outsourcing:item:3}\vspace{0.5ex} 
\item $\doUp{\atrs}{\astrfun} \ge \siosqprd{\fgate}$ for all\/ $\astrfun \in \Ssf\,$.\label{lem2:outsourcing:item:4}\vspace{0.5ex}
\end{enumerate}
Then, for all $\astrcon\in\Ssc$
  and vectors 
  $\vec{\adattrm} = \langle \adattrm_1, \ldots, \adattrm_{\arityD{\astrcon}} \rangle$ 
  of data terms in $\atrs$,
  the corresponding one of the following statements holds:
\begin{enumerate}[(a)]
\item $\netprd{\trnslF{\astrcon}{\afam}} \le \doLow{\atrs}{\funap{\astrcon}{\vec{u}}}\,$;\vspace{0.5ex}
\item $\netprd{\trnslF{\astrcon}{\afam}} \ge \doLow{\atrs}{\funap{\astrcon}{\vec{u}}}\,$;\vspace{0.5ex}
\item $\doUp{\atrs}{\funap{\astrcon}{\vec{u}}} \le \netprd{\trnslF{\astrcon}{\afam}}\,$;\vspace{0.5ex}
\item $\doUp{\atrs}{\funap{\astrcon}{\vec{u}}} \ge \netprd{\trnslF{\astrcon}{\afam}}\,$.
\end{enumerate}
\end{lemma}



