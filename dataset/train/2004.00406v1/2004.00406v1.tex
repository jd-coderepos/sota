\documentclass[10pt,twocolumn,letterpaper]{article}

\usepackage{cvpr}
\usepackage{times}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{subfigure}
\usepackage{array}
\usepackage{booktabs}
\usepackage{comment}
\usepackage{multirow}





\cvprfinalcopy 

\def\cvprPaperID{7673} \def\httilde{\mbox{\tt\raisebox{-.5ex}{\symbol{126}}}}

\ifcvprfinal\pagestyle{empty}\fi
\begin{document}

\title{Image Demoireing with Learnable Bandpass Filters}

\author{\normalsize Bolun Zheng\\
\footnotesize Hangzhou Dianzi University\\
{\tt\scriptsize zhengbolun1024@163.com}
\and
\normalsize Shanxin Yuan\\
\footnotesize Huawei Noah's Ark Lab\\
{\tt\scriptsize shanxin.yuan@huawei.com}
\and
\normalsize Gregory Slabaugh\\
\footnotesize Huawei Noah's Ark Lab\\
{\tt\scriptsize gregory.slabaugh@huawei.com}
\and
\normalsize Ale\v{s} Leonardis\\
\footnotesize Huawei Noah's Ark Lab\\
{\tt\scriptsize ales.leonardis@huawei.com}
\and
}

\maketitle


\begin{abstract}
Image demoireing is a multi-faceted image restoration task involving both texture and color restoration. 
In this paper, we propose a novel multiscale bandpass convolutional neural network (MBCNN) to address this problem. 
As an end-to-end solution, MBCNN respectively solves the two sub-problems.
For texture restoration, we propose a learnable bandpass filter (LBF) to learn the frequency prior for moire texture removal.
For color restoration, we propose a two-step tone mapping strategy, which first applies a global tone mapping to correct for a global color shift, and then performs local fine tuning of the color per pixel.
Through an ablation study, we demonstrate the effectiveness of the different components of MBCNN. 
Experimental results on two public datasets show that our method outperforms state-of-the-art methods by a large margin (more than 2dB in terms of PSNR).
\end{abstract}

\section{Introduction}
Digital screens are ubiquitous in modern daily life. We have TV screens at home, laptop/desktop screens in the office, and large LED screens in public spaces. It is becoming common practice to take pictures of these screens to quickly save information. Sometimes taking a photo is the only practical way to save information.
Unfortunately, a common side effect is that moire patterns can appear, degrading the image quality of the photo. 
Moire patterns appear when two repetitive patterns interfere with each other. In the case of taking pictures of screens, the cameraâ€™s color filter array (CFA) interferes with the screen's subpixel layout.

Unlike other image restoration problems, including denoising~\cite{zhang2017beyond}, demosaicing~\cite{DemosaicNet}, color constancy~\cite{FFCC}, sharpening~\cite{romano2016raisr}, etc., much less attention has been paid to image demoireing, which is to recover the underlying clean image from an image contaminated by moire patterns.
Only very recently, a few attempts \cite{sun2018moire, liu2018demoir, gao2019moire, he2019mop} have been made to address image demoireing. However, the problem remains to a large extent an unsolved problem, due to the large variation of moire patterns in terms of frequencies, shapes, colors, etc.

Recent works~\cite{sun2018moire, cheng2019multi, he2019mop} tried to remove moire patterns of different frequency bands through multi-scale design. 
DMCNN~\cite{sun2018moire} proposed to deal with moire patterns with a multi-scale CNN with multi-resolution branches and summed up the outputs from different scales to obtain a final output. 
MDDM~\cite{cheng2019multi} improved DMCNN by introducing an adaptive instance normalization~\cite{adain} based on a dynamic feature encoder.
DCNN~\cite{liu2018demoir} proposed a coarse-to-fine structure to remove moire patterns from two scales. The coarse scale result was upsampled and concatenated with the fine scale input for further residual learning.
MopNet~\cite{he2019mop} used a multi-scale feature aggregation sub-module to address the complex frequency, and two other sub-modules to address edges and pre-defined moire types.
Our model also adopts a multi-scale design with three branches for three different scales. Among different scales, our model adopts a gradual upsampling strategy to smoothly increase the resolution. 

\begin{figure}[t]
	\centering
	\includegraphics[width=1.0\linewidth]{pic/MOIRE.pdf}
	\caption{Moire texture of different scales, frequencies, and colors.}
	\label{MOIRE}
\end{figure}

Generally, none of the existing methods tried to model the moire patterns explicitly. 
In our model, we explicitly model the moire patterns by learning the frequency prior of moire patterns and respectively restore the moire image from texture and color.
Our contributions are as follows. 
\begin{itemize}
\item We introduce a unified framework namely multi-scale bandpass CNN (MBCNN) for image demoireing. The network performs both texture restoration and color restoration within the same model.
\item We propose a learnable bandpass filter (LBF) for efficient moire texture removal. The LBF introduces a learnable bandpass to learn the frequency prior, which could precisely separate moire texture from normal image texture. 
\item Our method includes global/local tone mapping for accurate color restoration. The global tone mapping learns the global color shift from moire images to clean images, while the local tone mapping is to make a local fine-grained color restoration.
\item We also propose an advanced Sobel loss (ASL) to learn the structural high-frequency information. With the ASL, we develop a multi-scale supervision to remove moire patterns in three scales.
\end{itemize}
\begin{comment}
\begin{itemize}
    \item Learnable bandpass filter, to expand
    \item global/local tone mapping, to expand
    \item sobel loss, expand
\end{itemize}
\end{comment}



\section{Related work}

Image demoireing requires both texture and color restoration, rendering it a complex challenge.
In this section, we make a brief introduction of several CNN-based methods in related tasks, where deep learning has made significant impact.

\textbf{Image restoration.} Dong \textit{et al.}~\cite{ARCNN,SRCNN} were the first to propose end-to-end convolutional neural networks for image super-resolution and compression artifact reduction. 
Subsequent research~\cite{Svoboda2016,vdsr,IRCNN} further improved these models by increasing the network depth, introducing skip connections~\cite{long2015fully} and residual learning. 
Much deeper networks~\cite{DRCN, DRRN, MemNet, RDN} were then introduced. DRCN~\cite{DRCN} proposed recursive learning for parameter sharing. Tai \textit{et al.}~\cite{DRRN,MemNet} introduced a recursive residual learning and proposed a memory block. Zhang \textit{et al.}~\cite{RDN} replaced the recursive connection in the memory block by a dense connection~\cite{DenseNet}. 
Moreover, several studies focused on multi-scale CNNs inspired by high-level computer vision methods. Mao \textit{et al.}~\cite{RED-Net} proposed a skip connection-based multi-scale autoencoder. 
Cavigelli \textit{et al.}~\cite{CAS-CNN} introduced a multi-supervised network for compression artifact reduction. 

\textbf{Frequency domain learning.} Several studies~\cite{MWCNN,DDCN,IDCN} focus on frequency domain. 
Liu \textit{et al.}~\cite{MWCNN} introduced the discrete wavelet transform and its inverse to replace conventional upscaling and downscaling operations for image restoration. 
Guo \textit{et al.}~\cite{DDCN} introduced convolution-based window sampling, Discrete Cosine Transform (DCT) and inverse DCT (IDCT) to construct a DCT-domain learning network. 
Zheng et al.~\cite{IDCN} introduced implicit DCT to extend the DCT-domain learning to color image compression artifact reduction.

\textbf{Color restoration.}  Image dehazing and image enhancement are two classic color restoration problems. 
Eilertsen et al.~\cite{HDRCNN} proposed a Gamma correction based loss function and trained a U-Net~\cite{UNet} based CNN for high dynamic range (HDR) image reconstruction. 
Gharbi \textit{et al.}~\cite{HDRNet} proposed HDRNet to learn local piece-wise linear tone mapping.  
Inspired by the guided filter~\cite{guidedfilter}, Wu \textit{et al.}~\cite{wu2018fast} proposed an end-to-end trainable guided filter for image enhancement. 
Ren et al.~\cite{ren2018gated} grouped a hazy image and several pre-enhanced images together as input, and proposed a symmetric autoencoder to learn a gated fusion for image dehazing.
Zhang et al.~\cite{zhang2018densely} proposed a densely connected pyramid CNN for image dehazing. 
Remarkably, few of these color restoration methods introduce residual connection in their solutions.

\textbf{Image demoireing.} Recently, several end-to-end image demoireing solutions have been proposed. 
Sun \textit{et al.}~\cite{sun2018moire} first introduced a CNN for image demoireing (DMCNN) and created an ImageNet~\cite{russakovsky2015imagenet}-based moire dataset for training and testing. 
Cheng \textit{et al.}~\cite{cheng2019multi} improved DMCNN by introducing an adaptive instance normalization~\cite{adain} based dynamic feature encoder.
He \textit{et al.}~\cite{he2019mop} introduced additional moire attribute labels based on shape, color, and frequency for more precise moire pattern removal.
None of the existing methods modeled the moire patterns explicitly. We treat the image demoireing problem as moire texture removal and color restoration.

\section{Proposed method}

A moire image captured by a digital camera can be modeled as:

where  is the clean image displayed on the screen,  is the introduced moire texture, and  is the color degradation caused by the screen and the camera sensor. 
 can be then expressed as:

where  is the inverse function of , which is known as the tone mapping function in the image processing field. 
Modeled in this way, the image demoireing task can be divided into two steps, \textit{i.e.}, moire texture removal and tone mapping. 


\subsection{Multiscale bandpass CNN}

\begin{figure*}
	\centering
	\includegraphics[width=1.0\linewidth]{pic/MBCN.png}
	\caption{The architecture of our multi-scale bandpass CNN.}
	\label{MBCNN}
\end{figure*}

We propose a Multi-scale Bandpass CNN (MBCNN) to do image demoireing, \textit{i.e.}, to recover the underlying clean image from the moire image. 
Our model works in three scales and has three different types of blocks, which are moire texture removal block (MTRB), global tone mapping block (GTMB), and local tone mapping block (LTMB).  
The details of each block are described in Sec.~\ref{sec3_2} and Sec.~\ref{sec3_3}.

The architecture of MBCNN is shown in Figure~\ref{MBCNN}. 
The input image  with the shape of  is first reversibly downsampled into four subimages  with the shape of . With the tensor  as input, the following network consists of three branches, each to recover the moire image in a specific scale. 
Following Eq. \ref{eq02}, each branch sequentially executes the moire texture removal and tone mapping, and finally outputs an up-scaled image to be fused in the finer scale branch. 
In branch I and II, after fusing the feature of current branch and the output of the coarser scale branch, additional GTMB and MTRB are stacked to remove the texture and color errors caused by the scale change.


\begin{comment}
Branch I starts with a   layer  to transform  into convolution domain, denoted as . Then block  removes the moire texture components from  and outputs the tensor . 
Next, a  stride   layer  starts the branch II by outputting  from . 
Similarly, the  outputs the  from , and  a  stride   layer  outputs  from  starting the branch III.

In the branch III, the  first removes moire texture components from , then the  and the  are stacked to make a tone mapping outputting the convolution domain representation of restored image . 
At the end, the upsampling decoder , including a  convolution layer and a  pixel shuffle upsampling layer~\cite{espcn}, transforms the  to the restored image  with the shape of . 
After obtaining , we concatenated  and  together and fuse these two tensors as , then took the  to make a global color balance. 
Then, the , ,  and  are sequentially stacked to output the restored image  with the shape of . 
Being similar to the branch II, the branch II adopts the same architecture to fuse  and  together and output the final restored image  with the shape of .
\end{comment}

\subsection{Moire texture removal}
\label{sec3_2}
Moire patterns exhibit considerable variation in shape, frequency, color, \textit{etc}. Some examples are shown in Figure~\ref{MOIRE}, where the moire patterns have different characteristics. The moire texture can be written as:

where  denotes the moire texture component of scale  and frequency . 
Following this formulation, we can first estimate the components of moire texture at different scales and frequencies, and then reconstruct the moire texture based on all the estimated components.

Block-DCT is an effective way for handling frequency related problems.
Assuming that the frequency spectrum in block-DCT domain of each  is , then Eq.~\ref{eq1} can be rewritten as

where  denotes the block-IDCT function. 

Given a color image patch , we denote the moire texture of each color channel as , . Then the representation of the moire texture  is

where  denotes a learnable convolution.
Based on Eq.~\ref{eq5}, Eq.~\ref{eq2} can be rewritten as 

where  is the combined frequency spectrum of channel  with the scale of . 
Here, we define the  as the implicit frequency spectrum (IFS) denoted as . 
Now, we can have


\textbf{Learnable Bandpass Filter.} 
Inspired by the implicit DCT~\cite{IDCN}, we can directly estimate   with a deep CNN block. 
Since the transforms presented in Eq.~\ref{eq4} are all linear, they can be modeled by a simple convolution layer. 
As the frequency spectrum of moire texture is always regular, we can use a bandpass filter to amplify certain frequencies and diminish others. 
However, it's difficult to get the frequency spectrum prior modeling the moire texture, because there would be several frequencies in different scales and they can also affect each other. 
To solve this problem, we propose a learnable bandpass filter (LBF) to learn the prior from moire images. 
LBF introduces a learnable weights for each frequency, which can be expressed as

where  denotes the learnable weights of DCT domain frequencies for the scale . 

Assuming the size of block-IDCT is , then the corresponding DCT domain frequency spectrum totally has  frequencies, so the size of  is . 
All parameters of   are initialized to be 1 and constrained to be non-negative, the passbands are learned from the image data during training. 
 can be implemented by a predefined  convolution layer, whose weights are fixed as the IDCT matrix.


\begin{figure}[t]
	\centering
	\includegraphics[width=1.0\linewidth]{pic/MTRB.png}
	\caption{The structure of moire texture removal block.}
	\label{MTRB}
\end{figure}

\textbf{CNN Structure.} 
Following Eq.~\ref{eq6}, we can respectively remove moire texture from different scales. 
For each specific scale,  we propose a moire texture removal block (MTRB), see Figure~\ref{MTRB}. 
\begin{comment}
Assuming the input of the MTRB is , a dense block is first used for feature extraction, which is denoted as . 
The dense block has  densely connected~\cite{DenseNet}  -channel dilated convolution~\cite{DILATED_CONV} with ReLU activation () layers, which can be represented as

where  denotes the ,  denotes the dilation rate of the th dilated convolution layer, and  denotes the channel concatenating. 
Then a  convolution layer estimates the IFS  from , which can be represented as

\end{comment}

Assuming the input of the MTRB is , a dense block is first used for feature extraction, which is denoted as . Then a  convolution layer estimates the IFS  from .
The dense block has  densely connected~\cite{DenseNet}   -channel dilated convolution~\cite{DILATED_CONV} with ReLU activation () layers. 
We adopt dilated convolution rather than normal convolution to enlarge the receptive field of the dense block to produce , so that the  sized  can be easily estimated from the .
After estimating , the learnable weight  and the block-IDCT layer , a convolution layer  is added as indicated in Eq.~\ref{eq6}. 

Considering that the  might lead to large local output and produce excessive gradient, we stacked a Feature Scale Layer (FSL) to linearly constrain the output of . 
Finally, we introduce the residual connection~\cite{ResNet} to remove the moire texture in convolution domain. Thus, the final output of MTRB  can be obtained by

where  denotes the FSL. 

Directly multiplying  and  will consume large amount of calculations. Instead, we reshape  to the size of , and multiply it with the convolution kernel of  layer, then the  is directly sent to  layer. In this way, the product  can be avoided.

\subsection{Tone mapping}
\label{sec3_3}
The RGB color space is an extremely large space containing  colors, making it difficult to do point-wise tone mapping. 
Observing that there are color shifts between the moire and clean images, we  propose a two-step tone mapping strategy with two types of tone mapping blocks: Global Tone Mapping Block (GTMB) and Local Tone Mapping Block (LTMB).

\begin{figure}[t]
	\centering
	\includegraphics[width=1.0\linewidth]{pic/GTMB.png}
	\caption{The structure of global tone mapping block.}
	\label{GTMB}
\end{figure}

\begin{table}[ht]
\normalsize 
  \centering
  \resizebox{1.0\columnwidth}{!}{
  \begin{tabular}{lcccccc}
  \toprule 
  Layer &
   & 	 &
   &
    &
    &
   \\
	\midrule
	Stride       &  &  &  & - & - & -\\
	Kernel     &  &  &  & - & - & -\\
	Output Ch. &  &  &  &  &  & \\
  \bottomrule
  \end{tabular}}
	\caption{Attributions of learnable layers in GTMB.}
	\label{table1}
\end{table}
\textbf{Global tone mapping block.} 
The GTMB is proposed to learn the global color shift, see Figure~\ref{GTMB} for the detailed structure. 
\begin{comment}
Assuming the input is , a   layer with the stride of 2 and a global average pooling (GAP) layer first extract the global feature  from , which can be represented as

where  denotes the GAP. 
Then, two fully connected (FC) with ReLU activation () layers and a FC layer are stacked to output the inner channel attention , which can be represented as

where , denotes the FC, and  denotes the . 
Besides, another   layer extracts the inner feature  from , which can be represented as

After obtaining the  and , the final output of GTMB can be obtained as

\end{comment}
Given the input , we first extract a global feature  through a   layer with the stride of 2 and a global average pooling (GAP) layer.
Then, to extract a deep global feature , we stack two fully connected (FC) layers with ReLU activation (, ) and a FC layer without ReLU activation ().
Besides, we use an   layer extracts the local feature  from .
The output of GTMB can be obtained as

Assuming the  outputs a -channel tensor, Table~\ref{table1} lists the attributions of all learnable layers in GTMB.

\textbf{GTMB vs. Channel Attention.} The attention mechanism has proven to be effective in many tasks\cite{yan2019stat,wang2019edvr,yan2020TPMAI, 3droom}, and several channel attention blocks have been proposed \cite{rcan, hu2018squeeze}. Our GTMB can be view as a channel attention block.
However, GTMB is different from existing channel attention blocks in several aspects. 
First, existing channel attention blocks are always activated by a Sigmoid unit, while there are no such constraints for the  in GTMB. 
Second, channel attention is directly applied on the input of the existing channel attention blocks,  while the  in GTMB is applied on the local feature .
Finally, existing channel attention blocks are aimed at making an adaptive channel-wise feature re-calibration; the goal of GTMB is to make a global color shift and avoid the irregular and inhomogeneous local color artifacts (more analysis are described in Sec. \ref{sec4_4_1}).
\begin{comment}
\begin{table}
	\begin{center}
		\begin{tabular}{|l|c|c|c|}
			\hline
			Layer & Stride & Kernel & Output Ch. \\
			\hline\hline
			 &  &  & \\
			 &  &  & \\
			 &  &  & \\
			 & - & - & \\
			 & - & - & \\
			 & - & - & \\
			\hline
		\end{tabular}
	\end{center}
	\caption{Attributions of learnable layers in GTMB.}
	\label{table1}
\end{table}
\end{comment}


\begin{figure}[t]
	\centering
	\includegraphics[width=1.0\linewidth]{pic/LTMB.png}
	\caption{The structure of local tone mapping block.}
	\label{LTMB}
\end{figure}
\textbf{Local tone mapping block.} 
The LTMB is developed to fit a local fine-grained tone mapping function. 
As shown in Figure~\ref{LTMB}, the structure of LTMB is similar to MTRB. 
LTMB first takes a similar dense block in MTRB to extract the deep feature  from the input of LTMB . 
Then, the output of LTMB is obtained by 

where  is a  convolution, and  has the same shape with .




\subsection{Loss function}

In this paper, we use the L1 loss as the base loss function, as it has been proven \cite{lim2017enhanced,RDN,zhao2016loss} that L1 loss is more effective than L2 loss for image restoration tasks.
However, the L1 loss itself is not enough as it is a point-wise loss that cannot provide structural information, while moire patterns are structural artifact. 
We propose an Advanced Sobel Loss (ASL) to solve this problem. 
The proposed ASL can be expressed as

where  denotes the groundtruth,  denotes the output of CNN, and  denotes the advanced Sobel filtering. Figure~\ref{ASL} illustrates the details of ASL.
Compared to classic Sobel filters (Figure~\ref{ASL-a}), the advanced Sobel filters provide two additional  filters of  directions (Figure~\ref{ASL-b}), which could provide richer structure information. 
We combine ASL and L1 loss as the final loss function, which can be expressed as,

where  denotes the L1 loss,  denotes the ASL, and  is a hyper-parameter to balance the L1 loss and ASL.
 
When training MBCNN, we adopt the multi-supervising strategy that supervising the outputs from all branches, which can be expressed as, 

where , , and  indicate branch 1, 2, and 3, respectively. 
\begin{figure}
	\centering
	\subfigure[]{
		\begin{minipage}[htbp]{0.45\linewidth}
			\includegraphics[width=\textwidth]{pic/ASL_a}	
		\end{minipage}
		\label{ASL-a}
	}
	\subfigure[]{
		\begin{minipage}[htbp]{0.45\linewidth}
			\includegraphics[width=\textwidth]{pic/ASL_b.pdf}	
		\end{minipage}
		\label{ASL-b}
	}
	\caption{Details of advanced Sobel loss. (a) Classic Sobel filters. (b) Two additional filters for advanced Sobel filters.}
	\label{ASL}
\end{figure}

\begin{comment}
\section{Discussions}
In this section, we discussed about the difference between MBCNN and several prior works.

\subsection{Difference to MWCNN}

MWCNN~\cite{MWCNN} introduces DWT and IDWT to enlarge and reduce the scale of feature maps, and finally outputs the residual between noised image and clean image. 
Due to the global residual connection, MWCNN can well solve the texture restoration problems. 
However, it cannot handle the color restoration problem. 
Moreover, the DWT cannot well distinguish the moire texture from the normal texture. 
The relevant experimental results will be provided in Section.\ref{EXP_SEC}.

\subsection{Difference to CAS-CNN}
Both CAS-CNN\cite{CAS-CNN} and our MBCNN adopt the multiscale supervising strategy to training the network.
However, CAS-CNN directly upsamples the supervised output and concatenates it to upper scale feature maps. 
This is an inefficient operation because the after-supervised upsampling is probably inaccurate and hardly provides more information. 
MBCNN directly outputs an upsampled image can well solve this problem. 
\subsection{Difference to DMCNN}
DMCNN is a recent proposed method for image demoireing. 
DMCNN introduced several consecutive upsampling layers to directly transform the low-resolution feature maps into high resolution. 
Because none reference and supervision are included, the consecutive upsampling layers would probably lead unnatural texture and produce an over smooth result. 
Comparatively, MBCNN adopts the gradual upsampling strategy to smoothly increase the resolution of the final output can well overcome this limitation.
\end{comment}

\section{Experiments} 
\label{EXP_SEC}

We have conducted extensive ablation studies and outperformed state-of-the-art by large margins on two public datasets: \emph{LCDMoire}~\cite{AIM19demoireDataset} and \emph{TIP2018}~\cite{sun2018moire}
The \emph{LCDMoie} dataset consists of 10,200 synthetically generated image pairs with 10,000 training images, 100 validation images and 100 testing images.
The \emph{TIP2018} dataset consists of real photographs constructed by photographing images of the ImageNet~\cite{russakovsky2015imagenet} dataset displayed on computer screens with various combinations of different camera and screen hardware. It has 150,000 real clean and moire image pairs, split into 135,000 training images and 15,000 testing images.
Both \emph{LCDMoire} and \emph{TIP2018} datasets are used to do comparison with state-of-the-art methods. \emph{LCDMoire} dataset is also used for ablation study. The ablation study is conducted on the validation set, as the test dataset's ground truth is not available. Please note: the validation dataset is completely independent and not used in training.

\subsection{Implementation details}
\label{imp details}
For the MBCNN model, we adopt the following settings, with , , , . Adam~\cite{adam} is used as our training optimizer. The learning rate is initialized to be . The validation was conducted after every training epoch. If the decrease in the validation loss was lower than 0.001 dB for four consecutive epochs, the learning rate was halved. 
When the learning rate became lower than , the training procedure was completed. 
For \emph{LCDMoire} dataset, we  patches were randomly cropped from the images, with the batch size set to 16. When the  patch trained model converged, we re-grouped the training data into  patches for fine-tuning the model. This time, the learning rate was set to , the batch size was set to 4. Training a MBCNN roughly takes 40 hours with a NVidia RTX2080Ti GPU.
For \emph{TIP2018} dataset, we follow~\cite{sun2018moire} and set the patch size as  through out the training. 

\subsection{Ablation Study}

To verify the effectiveness of each component in our model, we conduct extensive ablation studies, including evaluation of MTRB vs. GTMB and LTMB, learnable bandpass filter, and loss function.

\begin{figure}[t]
  \centering
  \includegraphics[width=1.0\linewidth]{pic/INTERNAL1.pdf}
  \caption{Demoireing results produced by MBCNN with and without MTRB.}
  \label{MTRB-Comp}
\end{figure}

\subsubsection{MTRB vs. GTMB and LTMB}

As described in previous sections, the 
MTRB is designed for removing moire texture, GTMB and LTMB are designed for color restoration. 
We investigate the effect of the MTRB using a trained MBCNN, and visualize the experimental results in Figure.~\ref{MTRB-Comp}. 
Due to the residual connection in MTRB, we can separate the effect of MTRB from the two tone mapping blocks by forcing the learned scale in the feature scaling layer to be zero. 
As shown in Figure~\ref{MTRB-Comp}, without MTRBs, the degraded color can still be well restored, and some of very high frequency moire texture can also be well removed. 
However many high frequency image details are lost, and the low-frequency moire texture largely remains. 
The result is mainly caused by two reasons. 
First, because  convolutions are used in GTMB and LTMB, the CNN has certain denoising and local smoothing capabilities. 
Second, although the proposed tone mapping blocks do have a great ability to restore color, the major contribution to moire texture removal is made by MTRBs. 
This experiment demonstrates that the MTRBs have strong capability to do moire texture removing, while the GTMBs and LTMBs are good at restoring colors. 



\subsubsection{Learnable bandpass filter}
In this section, we investigate the contribution of LBF and explain the reasons why we choose the relevant settings. 

\begin{table}[h]
\small
  \centering
  \resizebox{1.0\columnwidth}{!}{
  \begin{tabular}{lccc}
  \toprule 
  	Model & MBCNN-nDDT & MBCNN-nLP & MBCNN\\
  \midrule 
			PSNR/SSIM & 42.91/0.9932 & 43.09/0.9936 & 44.04/0.9948\\
  \bottomrule
  \end{tabular}}
	\caption{Performance of MBCNN, MBCNN-nLP and MBCNN-nDDT on \textit{LCDMoire} validation set.}
	\label{table2}
\end{table}
\textbf{Structural contribution.} 
The LBF is constructed by two parts, DCT domain transform (DDT) and the learnable passband (LP). 
We applied the settings described in Section~\ref{imp details}, and respectively removed the DDT and LP from the MTRBs to conduct the investigation. 
We removed the entire DDT by replacing it by a  convolution layer to keep the output shape unchanged. In this case, the MTRB degenerates to a residual dense block (RDB). 
We removed the LP by keeping the entire DDT, but forcing all parameters in the passbands to be 1, which will not be updated during training phase.

We denote the networks constructed without LP or DDT as MBCNN-nLP and MBCNN-nDDT, respectively. 
We tested the performance of these three models on the validation set of \emph{LCDMoire}. 
As shown in Table \ref{table2}, MBCNN-nLP introduces the DDT which could provide a structural learning path and explicitly ensure the internal receptive field (block-IDCT size), and finally leads to a slight improvement of 0.18dB from MBCNN-nDDT. 
MBCNN introduces the learnable bandpass to learn the frequency prior of the moire texture and leads a significant improvement of 0.95 dB from MBCNN-nLP. 
Some demoireing results produced by these three models are shown in Figure~\ref{demoire_comp_1}. 
The LBFs enable the MBCNN to better sense the moire texture and recover more accurate details from moire images.

\begin{figure}[t]
	\centering
	\includegraphics[width=1.0\linewidth]{pic/COMP11.pdf}
	\caption{Demoireing results produced by MBCNN-nDDT, MBCNN-nLP and MBCNN.}
	\label{demoire_comp_1}
\end{figure}



\begin{table}[ht]
\normalsize 
  \centering
  \resizebox{1.0\columnwidth}{!}{
  \begin{tabular}{lcccc}
  \toprule 
   Model & MBCNN-6 & MBCNN-8 & MBCNN-10 & MBCNN-12\\
  \midrule 
   PSNR/SSIM & 43.25/0.9937 & 44.04/0.9948 & 43.45/0.9939 & 43.17/0.9937 \\
  \bottomrule
  \end{tabular}}
  \caption{Comparison of MBCNNs with different  values.}
\label{table3}
\end{table}

\textbf{Block-IDCT size .}
 is a very important parameter for DDT. With a larger , the LBF can learn a more accurate and more complete frequency prior. 
We denoted the MBCNN constructed with the block-IDCT size of  as MBCNN-. 
We respectively validated the performance of MBCNNs constructed with .  is found to be the best for moire texture removal. 
As shown in Table~\ref{table3}, larger  doesn't always lead to a better result. 
There are two reasons for this observation. First, enlarging  increases the complexity and difficulty of the frequency prior learning. 
Second, the receptive field provided by the front dense block cannot support a  that is too large. 
We visualize the learned passbands in the LBFs from an MBCNN-8 model in Figure~\ref{passbands}. 
The LBFs perform band suppression mainly at the beginning of the branches.
The LBFs at the end of the branches are primarily avoiding over-smoothing caused by concatenating the output from the upper scale.
\begin{figure}[t]
	\centering
	\includegraphics[width=1.0\linewidth]{pic/LBF.png}
	\caption{The learned frequency domain priors from the LBFs in different MTRBs.}
	\label{passbands}
\end{figure}

\subsubsection{Study of the loss function}
\label{loss_study}
\begin{comment}
In this section, we investigate the contribution from the loss functions by validating the performance of MBCNN models trained by L1 loss, L1 loss plus Sobel loss (SL), L1 loss plus ASL, respectively. 
\end{comment}
In this subsection, we investigate the contribution from the loss functions. To demonstrate the effectiveness of the proposed ASL, we compare it with several related and well-known loss functions, including Sobel loss, Laplace loss, SSIM loss~\cite{zhao2016loss} and perceptual loss basing on pre-trained Vgg16 network~\cite{vggloss}.
\begin{comment}
Here, the SL is defined as

where  denotes the classic Sobel filtering. 
Then, the final loss function of L1 loss plus SL can be defined as 

where  in Eq.~\ref{SL} is set to 0.5.
\end{comment}
Generally, all loss function are loaded through the multi-supervising strategy stated in Eq. \ref{eq14} and finally measured by an MAE function. 
To balance the outputs of these losses and L1 loss, we assigned different  (in Eq, \ref{eq13}) to different losses.
As shown in Table~\ref{table4}, the structural high frequency loss provided by the Sobel loss leads to a significant improvement of 1.81dB, and the additional two directional filters from ASL further improve the performance of 0.40dB. 
Though Laplace loss is also a high frequency descriptor, because it has a much higher weight on the center pixel than the neighbouring pixels, it behaves similar to the L1 loss.
Besides, the SSIM loss and perceptual loss also can improve the performance. The SSIM loss behaves similar to Laplace loss, while the perceptual loss is the second best loss function which is only 0.21 dB inferior to ASL. 
Generally, our ASL is an simple and effective loss function for image demoireing task.


\begin{comment}
Moreover, we visualized the demoireing results produced by these three models in Figure~\ref{LOSS_COMP}.
The results clearly show that with more direction information provided by the loss function, a better demoireing model can be learned.
\begin{figure}[t]
	\centering
	\includegraphics[width=1.0\linewidth]{pic/LOSS_COMP1.pdf}
	\caption{Demoireing results produced by MBCNN-nDDT, MBCNN-nLP and MBCNN.}
	\label{LOSS_COMP}
\end{figure}
\end{comment}

\begin{comment}
\begin{table}
	\begin{center}
		\begin{tabular}{|l|c|c|c|}
			\hline
			Model & Loss & PSNR & SSIM\\
			\hline\hline
			\multirow{3}*{MBCNN} & L1 & 41.83 & 0.9845 \\
			  & L1+SL & 43.64 & 0.9900\\
			  & L1+ASL & 44.04 & 0.9903\\
			\hline
		\end{tabular}
	\end{center}
	\caption{Performance comparison of MBCNN models trained with different loss functions.}
	\label{table4}
\end{table}
\end{comment}


\begin{table}[ht]
\normalsize 
  \centering
  \resizebox{0.9\columnwidth}{!}{
  \begin{tabular}{lccc}
  \toprule 
   	Loss &  & PSNR (dB) & SSIM\\
  \midrule 
   L1  & - & 41.83 & 0.9905\\
   L1 + Sobel & 0.5 & 43.64 & 0.9945 \\
   L1 + Laplace & 0.5 & 42.92 & 0.9927 \\
   L1 + SSIM & 0.2 & 43.36 & 0.9946 \\
   L1 + perceptual & 1.0 & 43.83 & 0.9946 \\
   L1 + ASL & 0.25 & 44.04 & 0.9948 \\
  \bottomrule
  \end{tabular}}
    		\caption{Performance comparison of MBCNN models trained with different loss functions.}
	\label{table4}
\end{table}

\begin{comment}
\begin{table*}[t]
\normalsize 
  \centering
  \resizebox{2.\columnwidth}{!}{
  \begin{tabular}{lcccccccc}
  \toprule 
   & Input & DnCNN & VDSR & EDSR & UNet & DMCNN & MopNet & MBCNN & MBCNN-light \\
  \midrule 
PSNR & 20.30 & 24.54 & 24.68 &  26.82
 & 26.49 & 26.77 & 27.75 & \textbf{29.82} & 27.59\\
SSIM & 0.738 & 0.834 & 0.837 &  0.853  & 0.864 & 0.871 & \textbf{0.895} & 0.892 & 0.864 \\
  \bottomrule
  \end{tabular}}
    	\caption{Performance comparison of MBCNN models and other related works on \emph{TIP2018}}
	\label{table6}
\end{table*}
\end{comment}


\begin{figure}
	\centering
	\includegraphics[width=1.0\linewidth]{pic/LCDM1.jpg}
	\caption{Demoireing results on the validation set of \emph{LCDMoire} produced by proposed methods and other prior mehods.}
	\label{LCDM}
\end{figure}


\begin{figure*}[t]
	\centering
	\includegraphics[width=1.0\linewidth]{pic/TIPResult1.png}
	\caption{Qualitative comparison on \textit{TIP2018} dataset.}
	\label{pic:TIP}
\end{figure*}

\subsection{Comparison with prior work}
\label{comp_prior}
In this subsection, we compare the proposed method with several most related prior work. 


\begin{table*}[t]
\normalsize 
  \centering
  \resizebox{2.\columnwidth}{!}{
  \begin{tabular}{lccccccccc}
  \toprule 
   	Model & IPCV IITM & PCALab & IAIR & XMU-VIPLab & KU-CVIP & MoePhoto & Islab-zju & MBCNN\\
  \midrule 


		PSNR/SSIM  &
		32.23/0.96 & 
		32,39.0.97 & 
		35.27/0.97 &
		39.21/0.99 &
		40.17/0.98 &
		41.91/0.99 &
		42.90/0.99 &
	    \textbf{44.04/0.9948}\\
\bottomrule
  \end{tabular}}
 	\caption{Performance comparison of MBCNN models and the top 7 participating methods in the AIM19 demoireing challenge.}
	\label{tab:challenge}
\end{table*}

\begin{table}[th]
\normalsize 
  \centering
  \resizebox{1.\columnwidth}{!}{
  \begin{tabular}{lccccccc}
  \toprule 
   	Model & CAS-CNN & MWCNN & DMCNN & MBCNN & MBCNN-light & \\
  \midrule 
	PSNR &  36.16 & 28.93 & 35.48 & 44.04 & 42.81 & 33.65\\
	SSIM &  0.9873 & 0.9698 & 0.9785 & 0.9948 & 0.9940 & 0.9859\\
Time(s)  & 0.14 & 0.14 & 0.10 & 0.25 & 0.12 & 1.14\\
  \bottomrule
  \end{tabular}}
 	\caption{Performance comparison of MBCNN models and other prior work on the validation set of \emph{LCDMoire}.}
	\label{table5}
\end{table}


\begin{table}[h]
\normalsize 
  \centering
  \resizebox{1.\columnwidth}{!}{
  \begin{tabular}{lcccccccc}
  \toprule 
   & DnCNN & VDSR & EDSR & UNet & DMCNN & MopNet & \textbf{MBCNN}  \\
  \midrule 
PSNR  & 24.54 & 24.68 &  26.82
 & 26.49 & 26.77 & 27.75 & \textbf{30.03} \\
SSIM & 0.834 & 0.837 &  0.853  & 0.864 & 0.871 & \textbf{0.895} & 0.893  \\
  \bottomrule
  \end{tabular}}
    	\caption{Performance comparison of MBCNN models and other related works on \emph{TIP2018} dataset.}
	\label{table6}
\end{table}




\subsubsection{Comparison on LCDMoire dataset}
\label{sec4_4_1}
We first compare with the participating methods in the AIM19 image demoireing challenge~\cite{AIM19demoireMethods}. The results on the validation set (again, independent and not used in training) is shown in Table~\ref{tab:challenge}.
Since the ground-truth of the \emph{LCDMoire} testing set is not released, we provide the performance on the \emph{LCDMoire} validation set.   
We also compared with several methods that did not participate in the challenge, including CAS-CNN~\cite{CAS-CNN}, MWCNN~\cite{MWCNN}, DMCNN~\cite{sun2018moire}. The result and average running time per image are shown in Table~\ref{table5}.  
Because we have demonstrated the superiority of the ASL, we trained the methods (CAS-CNN, MWCNN, DMCNN) with L1 loss plus ASL. 
Limited by the global residual connection, MWCNN fails to solve the image demoireing problem, while CAS-CNN achieves a very close performance to DMCNN. 
The proposed MBCNN method clearly outperforms these other methods, with a significant performance gain of dB/ PSNR than CAS-CNN. 
From the visualized results shown in Figure~\ref{LCDM}, our MBCNN accurately removes moire texture and restores most image details. 

However, since MBCNN consumes considerable parameters compared to several compared methods, we propose a light version of MBCNN (MBCNN-light) by setting , , while keeping other settings unchanged. 
As shown in Table~\ref{table5}, the fewer parameters leads to a performance reduction of  dB/ from MBCNN. 
Nevertheless, MBCNN-light still outperforms other participating methods even in this reduced form of the method. 


Recently, several studies have reported that the geometric self-ensemble could reasonably enhance the performance in the final testing phase. 
We adopted this strategy during testing time by rotating the input image by ,  and  to generate three augmented input images, and calculating the mean image of the original output and three augmented outputs (rotated back) as the final output. 
We denoted this self-ensemble MBCNN as . 
Perhaps surprisingly, this strategy leads to a dramatic reduction in performance. 
We speculate that because the moire texture is a strongly direction-aware artifact, changing the direction would mislead the network to make an inaccurate restoration.


\subsubsection{Comparison on TIP2018 dataset}
Since some related work is evaluated on the \emph{TIP2018} dataset, we further evaluated our MBCNN on the \emph{TIP2018} dataset to compare with several related methods including
DnCNN \cite{zhang2017beyond}, VDSR \cite{kim2016accurate}, EDSR \cite{lim2017enhanced}, UNet \cite{UNet}, DMCNN \cite{sun2018moire}, MopNet \cite{he2019mop}.
As shown in Table~\ref{table6}, our proposed MBCNN beats the second best method by  dB, in terms of PSNR, and achieved the second best SSIM result which is only 0.002 lower than the best. 
Moreover, the visualized results shown in Figure~\ref{pic:TIP} also demonstrates the proposed method outperformed other compared methods. More qualitative examples are shown in the supplementary material.


\section{Conclusion}

In this paper, we propose a multiscale bandpass CNN (MBCNN) for image demoireing, and significantly outperform state-of-the-art methods by more than 2dB in terms of PSNR. A learnable bandpass filter (LBF) is proposed to learn the frequency prior. Our model has two steps: moire texture removal and tone mapping. A LBF-based residual CNN block is used for moire texture removal, and another two CNN blocks for global and local tone mappings. An ablation study was conducted to show the importance of the components in the network. We have also clarified the the effect of the block-IDCT size in the LBF, and demonstrated that the block-IDCT size of 8 is the best for the image demoireing task. Experiments on two public datasets show that our model outperformed state-of-the-art methods by large margins.




{\small
\bibliographystyle{ieee_fullname}
\bibliography{egbib}
}

\end{document}
