\documentclass{llncs}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{float}
\usepackage{url}
\usepackage{hyperref}
\usepackage{subfigure}
\usepackage[margin=2cm]{geometry}

\usepackage{tikz}
\usetikzlibrary{arrows, automata, decorations.pathmorphing, fit, shapes}
\tikzstyle{every picture}=[
  >=stealth',
  shorten >=1pt,
  shorten <=1pt,
  node distance=1.5cm,
  auto,
  bend angle=45,
  initial text=,
  every state/.style={
	rounded rectangle, 
	rounded rectangle arc length=90,
  	inner sep=0.5mm,
  	minimum size=5mm
  },
]





\bibliographystyle{plain}

\setlength{\abovedisplayskip}{0pt}
\setlength{\belowdisplayskip}{0pt}
\setlength{\abovedisplayshortskip}{0pt}
\setlength{\belowdisplayshortskip}{0pt}
\allowdisplaybreaks[1]




\begin{document}

\title{On the Hierarchy of Block Deterministic Languages}
  
\author{Pascal Caron \and Ludovic Mignot \and Clément Miklarz} 

\institute{
  LITIS, Université de Rouen, 76801 Saint-Étienne du Rouvray Cedex, France\\
  \email{\{pascal.caron,ludovic.mignot,clement.miklarz1\}@univ-rouen.fr}
}
  
\maketitle

  \begin{abstract}
    A regular language is -lookahead deterministic (resp. -block deterministic) if it is specified by a -lookahead deterministic (resp. -block deterministic) regular expression.
	These two subclasses of regular languages have been respectively introduced by Han and Wood (-lookahead determinism) and by Giammarresi \emph{et al.} (-block determinism) as a possible extension of one-unambiguous languages defined and characterized by Brüggemann-Klein and Wood.

	In this paper, we study the hierarchy and the inclusion links of these families.
	We first show that each -block deterministic language is the alphabetic image of some one-unambiguous language. 
	Moreover, we show that the conversion from a minimal DFA of a -block deterministic regular language to a -block deterministic automaton not only requires state elimination, and that the proof given by Han and Wood of a proper hierarchy in -block deterministic languages based on this result is erroneous.
	Despite these results, we show by giving a parameterized family that there is a proper hierarchy in -block deterministic regular languages. 
	We also prove that there is a proper hierarchy in -lookahead deterministic regular languages by studying particular properties of unary regular expressions.
	Finally, using our valid results, we confirm that the family of -block deterministic regular languages is strictly included into the one of -lookahead deterministic regular languages by showing that any -block deterministic unary language is one-unambiguous.
  \end{abstract} 

\section{Introduction}\label{se:int}

	A Document Type Definition (DTD) containing a grammar is used to know whether an XML file fits some specification. These grammars are made of rules whose right-hand part is a restricted regular expression.
	Brüggemann-Klein and Wood have formalized these regular expressions and have shown that the set of languages specified is strictly included in the set of regular ones.
	The distinctive aspect of such expressions is the one-to-one correspondence between each letter of the input word and a unique position in them.
	The resulting Glushkov automaton is deterministic.
	The languages specified are called one-unambiguous regular languages.

	Several extensions of one-unambiguous expressions have been considered:
\begin{itemize}
	\item -block deterministic regular expressions~\cite{GMW01} are such that while reading an input word, there is a one-to-one correspondence between the next at most  input symbols and the same number of symbols of the expression.
These expressions have particular Glushkov automata.
The transitions of these automata can be labeled by words of length at most  and for every couple of words labeling two output transitions of a single state, these words are not prefix from each other. 
	\item -lookahead deterministic regular expressions form another generalization.
This time, the reading of the next  symbols of the input word allows one to know the next position in the expression. 
This extension has been proposed in~\cite{HW08}. 
  \item -unambiguous regular expressions~\cite{CFM14} is another extension of one-unam\-bi\-guity, where the next  symbols may induce several paths, but with at most one common state.
\end{itemize}

	These three families of expressions fit together as families of languages in the way that a language is -block deterministic (resp. -lookahead deterministic, -unambiguous) if there exists a -block deterministic (resp. -lookahead deterministic, -unambiguous) expression to represent it. 

	In~\cite{HW08}, Han and Wood show that there is a proper hierarchy in block deterministic languages and there is a strict inclusion of the family of -block deterministic languages into the one of -lookahead deterministic languages.
	However, they based their proofs on an erroneous statement due to Giammaresi \emph{et al.}~\cite{GMW01}, invalidating them.
	In this paper, we first show that there is indeed a proper hierarchy in block deterministic languages by giving our own parameterized family.
	Then, we show that there is also a proper hierarchy in -lookahead deterministic languages by studying the structural properties of unary Glushkov automata.
	Finally, using our valid results, we demonstrate that the family of -block deterministic languages is strictly included into the one of -lookahead deterministic languages by showing that any -block deterministic unary language is also one-unambiguous.

	Preliminaries are gathered in Section~\ref{se:pre}.
	In Section~\ref{se:PrevRes}, we recall several results from~\cite{GMW01,HW08} on which we question their truthfulness.
	Indeed, we show in Section~\ref{se:kbd_witness} that, due to an erroneous statement of Lemma~\ref{le:GMWH}, the witness family given as a proof of Theorem~\ref{th:HW} is invalid; and present an alternative family, proving the infinite hierarchy of -block deterministic regular languages w.r.t. .
	In Section~\ref{se:kld_witness}, we give another witness family to prove that there is also an infinite hierarchy in -lookahead deterministic regular languages w.r.t. .
	Then, in Section~\ref{se:inclusion_kbd_kld}, we give our own proof that -block deterministic regular languages are a proper subfamily of -lookahead deterministic regular languages w.r.t. .


\section{Preliminaries}\label{se:pre}

\subsection{Languages and Automata Basics}
	Let  be a non-empty finite \emph{alphabet}.
A \emph{word  over } is a finite sequence of symbols from .
The \emph{length} of a word  is denoted by , and the \emph{empty word} is denoted by .
Let  be words such that , then  is a \emph{prefix} of  and  is a \emph{subword} of .
The set of all prefixes (respectively subwords) of  is denoted by  (respectively ).

	Let  denote the set of all words over .
A \emph{language over } is a subset of .
Let  and  be two languages over . The following operations are defined:
\begin{itemize}
	\item \emph{the union}: 
	\item \emph{the concatenation}: 
	\item \emph{the Kleene star}:  with  and 
\end{itemize}

	A \emph{regular expression over } is built from  (the empty set), , and symbols in  using the binary operators  and , and the unary operator .
	The \emph{language}  \emph{specified by a regular expression } is defined as follows:

with , and ,  some regular expressions over .
	Given a language , if there exists a regular expression  such that , then  is a \emph{regular language}.
	A regular expression is trimmed if it is equal to  or does not contain any occurrence of .
	We consider only trimmed regular expressions in the rest of this paper.

	A \emph{finite automaton}  is a 5-tuple  where:
 is a finite set of states,  is the set of initial states,  is the set of final states, and  is a set of transitions.
The set  is equivalent to a function of  : .
This function can be extended to  as follows: for any subset , for any symbol , for any word : , , ; finally, we set .

	A set  is called an \emph{orbit} if it is a strongly connected component.
An orbit is \emph{trivial} if it consists of only one state and there is no transition from it to itself in .
The set of orbits of  is denoted by .
	Let  be an orbit and  be a state. The state  is an \emph{out-gate of } (respectively an \emph{in-gate of }) if  (respectively if ).
	The set of out-gates (respectively in-gates) of  is denoted by  (respectively ).


	The \emph{language}  \emph{recognized by } is the set .
Two automata are \emph{equivalent} if they recognize the same language.
The \emph{right language of a state  of } is denoted by .
Two states are \emph{equivalent} if they have the same right language.

	An automaton  is trimmed if .
	If an automaton is not trimmed, it is possible to compute an equivalent trimmed automaton by getting rid of any useless state.
	We consider only trimmed automata in the rest of this paper.

	An automaton  is \emph{standard} if  and .
If  is not a standard automaton, then it is possible to compute an equivalent standard automaton  as follows:
\begin{itemize}
	\item  with 
	\item 
	\item  if ,  otherwise
	\item 
\end{itemize}
This operation is called \emph{standardization}.

	An automaton  is \emph{deterministic} if  and , .
	If  is not deterministic, then it is possible to compute an equivalent deterministic automaton by using the powerset construction described in~\cite{RS59}.
	
	A deterministic automaton  is \emph{minimal} if there is no equivalent deterministic automaton  such that .
	If  is not minimal, then it is possible to compute an equivalent minimal deterministic automaton by merging equivalent states~\cite{Hop71,Moo56}.
	Notice that two equivalent minimal deterministic automata are isomorphic.

    Kleene's Theorem~\cite{Kle56} asserts that the set of the languages specified by regular expressions is the same as the set of languages recognized by finite automata.
The conversion of regular expressions into automata has been deeply studied, \emph{e.g.} by Glushkov~\cite{Glu61}.
To differentiate each occurence of the same symbol in a regular expression, 
a \emph{marking} of all the symbols of the alphabet is performed by indexing them with their relative position in the expression. 
The marking of a regular expression  produces a \emph{marked regular expression} denoted by  over the alphabet of indexed symbols denoted by  where each indexed symbol occurs at most once in .
	The reverse of marking is the \emph{dropping} of subscripts, denoted by , such that if  and , then .
	It is then extended to marked regular expressions such that .
	
	Let  be a regular expression over an alphabet . The following functions are defined:
\begin{itemize}
	\item  if ,  otherwise
	\item 
	\item 
	\item , 
\end{itemize}

	From these functions, an automaton recognizing  can be computed:

\begin{definition}\label{def:Glushkov}
	The \emph{Glushkov automaton of a regular expression  over an alphabet } is denoted by  with:
	\begin{itemize}
		\item 
		\item 
		\item  if ,  otherwise
		\item  
		  \begin{tabular}[t]{l@{\ }l}
		   & \\
		  & 
		  \end{tabular}
	\end{itemize}
\end{definition}
Finally, an automaton is a \emph{Glushkov automaton} if it is the Glushkov automaton of a regular expression .

\begin{example}
	Let . Then  with , and  is given in Figure~\ref{ExempleGlushkov}.
\end{example}

\begin{figure}[H]
	\centering
	
	\begin{tikzpicture}
		\node[state, accepting, initial] (i) {};
	    \node[state, accepting, right of=i] (3) {};
    	\node[state, above right of=3] (1) {};
		\node[state, below right of=3] (2) {};
	    \path[->]
    		(i) edge [bend left=45] node {} (1)
    		(i) edge node {} (3)
   			(i) edge [swap, bend right=45] node {} (2)
   		    (1) edge [loop above] node {} ()
        	(1) edge [bend left=10] node {} (2)
			(1) edge [swap] node {} (3)
   		    (2) edge [loop below] node {} ()
        	(2) edge [bend left=10] node {} (1)
   		    (2) edge node {} (3)
		;
	\end{tikzpicture}

  \caption{The Glushkov automaton  of }
  \label{ExempleGlushkov}
\end{figure}


\subsection{One-Unambiguous Regular Languages}
	We present the notion of one-unambiguity introduced in~\cite{BW98}.

\begin{definition}
	A regular expression E is \emph{one-unambiguous} if  is deterministic.
	A regular language is \emph{one-unambiguous} if it is specified by some one-unambiguous regular expression.
\end{definition}

	Brüggemann-Klein and Wood showed that the one-unambiguity of a regular language is structurally decidable over its minimal DFA. This decision procedure is related to the orbits of the underlying graph and to their links with the remaining parts:
	An automaton has the \emph{orbit property} if all the out-gates of each orbit have identical connections to the outside.
	More formally:
	
\begin{definition}
	An automaton  has the orbit property if, for any orbit  in , for any two states  in , the two following conditions are satisfied:
	\begin{itemize}
		\item ,
		\item .
	\end{itemize}
\end{definition}
	Let  be a state. 
	The \emph{orbit of a state }, denoted by  is the orbit to which  belongs.
	The \emph{orbit automaton}  \emph{of the state  in } is the automaton obtained by restricting the states and the transitions of  to  with initial state  and final states . For any state , the languages  are called the \emph{orbit languages of }.
	A symbol  is \emph{-consistent} if there exists a state  such that all final states of  have a transition labelled by  to . 
	A set  of symbols is -consistent if each symbol in  is -consistent.
The \emph{-cut}  of  is constructed from  by removing, for each , all transitions labelled by  that leave a final state of .
	All these notions can be used to characterize one-unambiguous regular languages:



\begin{theorem}[\cite{BW98}]\label{th:1NA}
	Let  be a minimal deterministic automaton and  be a -consistent set of symbols. 
	Then,  is one-unambiguous if and only if:
	\begin{enumerate}
		\item the -cut  of  has the orbit property
		\item all orbit languages of  are one-unambiguous.
	\end{enumerate}
	Furthermore, if  consists of a single non-trivial orbit and  is one-unambi\-guous, then  has at least one -consistent symbol.
\end{theorem}
	This theorem suggests an inductive algorithm to decide, given a minimal deterministic automaton  whether  is one-unambiguous: 
	the \emph{BKW test}.
Furthermore, the theorem defines a sufficient condition over non-minimal deterministic automaton:

\begin{lemma}[\cite{BW98}]\label{lm:1NA}
	Let  be a deterministic automaton and  be its equivalent minimal deterministic automaton.
	\begin{enumerate}
		\item If  has the orbit property, then so does 
		\item If all orbit languages of  are one-unambiguous, then so are all orbit languages of .
	\end{enumerate}
\end{lemma}
	Consequently, 
	the BKW test is extended to deterministic automata which are not minimal.
	Reinterpreting the results in~\cite{BW98}, it can be shown that
	
\begin{lemma}\label{lm:GlushkovBKW}
	  The Glushkov automaton of a one-unambiguous regular expression passes the BKW test.
\end{lemma}
	
	
\subsection{Lookahead Deterministic Regular Languages}

	We present the notion of lookahead determinism introduced in~\cite{HW08}.
	The basic idea is that the reading of the next  symbols of the input word allows one to know the next position in the expression or in the automaton.
	
\begin{definition}
	An automaton  is \emph{-lookahead deterministic} if the following conditions hold:
	\begin{itemize}
		\item 
		\item .
	\end{itemize}
\end{definition}

\begin{definition}
	A regular expression  is -lookahead deterministic if  is -lookahead deterministic.
	A regular language is -lookahead deterministic if it is specified by some -lookahead deterministic regular expressions.
\end{definition}

	Since a -lookahead deterministic automaton is deterministic, the family of -lookahead deterministic language is the same as the family of one-unambiguous language.

\begin{example}
	Let ,  is given in Figure~\ref{fg:Glushkov2LA}.
	Notice that the states  and  admit two successors by  and , but since , then  and  are -lookahead deterministic. 
\end{example}


\begin{figure}[H]
	\centering
	
	\begin{tikzpicture}
		\node[state, initial] (i) {};
	    \node[state, right of=i] (2) {};
    	\node[state, above of=2] (1) {};
		\node[state, below of=2] (4) {};
		\node[state, left of=4] (3) {};
		\node[state, accepting, below right of=2] (5) {};
		\node[state, accepting, right of=5] (6) {};		
	    \path[->]
    			(i) edge node {b} (1)
			(i) edge node {a} (2)
   		    (1) edge [loop above] node {b} ()
        		(1) edge [swap] node {a} (2)
			(2) edge [swap] node {b} (3)
   		    (2) edge [swap] node {a} (4)
   		    (2) edge node {a} (5)
   		    (2) edge [bend left=20] node {b} (6)
        		(3) edge [loop left] node {b} ()
			(3) edge [bend left=10] node {a} (4)
			(4) edge [bend left=10] node {b} (3)
        		(4) edge [loop below] node {a} ()
   		    (4) edge node {a} (5)
   		    (4) edge [swap, bend right=20] node {b} (6)
		;
	\end{tikzpicture}

	\caption{The -lookahead deterministic Glushkov automaton }
	\label{fg:Glushkov2LA}
\end{figure}

	It has been proved in~\cite{HW08} that the language  is not one-unambiguous.
	Thus, one-unambiguous regular languages are a proper subfamily of -lookahead deterministic regular languages.
		
	
\subsection{Block Deterministic Regular Languages}

	We present the notion of block determinism introduced in~\cite{GMW01}.
	
	Let  be an alphabet and  be an integer. The \emph{set of blocks}  is the set . The notions of regular expression and automaton can be extended to ones over set of blocks.
	Let  be a regular expression over  and  be an automaton. Let  be an alphabet and  be an integer, if  then  and  are \emph{-block}.
	And since , a language over  is also a language over .
	To distinguish blocks as syntactic components in a regular expression, we write them between square brackets.
Those are omitted for one letter blocks.

	Since , regular expressions and automata can be considered as ones over a set of blocks.
Moreover, the blocks can be treated as single symbols, as we do when we refer to the elements of an alphabet.
With this assumption,  the marking of block regular expressions induces the construction of a Glushkov automaton from a block regular expression, and the usual automaton transformations such as determinization and minimization can be easily performed.

\begin{example}
	Let . Then , and  is given in Figure~\ref{fg:GlushkovBloc}.
\end{example}

\begin{figure}[H]
	\centerline{
		\begin{tikzpicture}
			\node[state, initial] (i) {};
		    \node[state, below of=i] (1) {};
		    \node[state, left of=1] (4) {};
		    \node[state, right of=1] (2) {};
		    \node[state, accepting, below of=2] (3) {};
		    \node[state, accepting, below of=4] (5) {};
	    	\node[state, accepting, below of=1] (6) {};
		    \path[->]
	    		(i) edge node {} (1)
	    		(i) edge [swap] node {} (4)
	       		(i) edge [bend left=45] node {} (2)
	        	(1) edge [loop below] node {} ()
	    		(1) edge node {} (4)
	   		    (1) edge [swap] node {} (2)
	   		    (2) edge node {} (3)
	  		    (3) edge node {} (6)
	   		    (4) edge [swap] node {} (5)
	   		    (5) edge [swap] node {} (6)
	   		    (6) edge [loop below] node {} ()
			;
		\end{tikzpicture}
	}
  \caption{The -block Glushkov automaton }
  \label{fg:GlushkovBloc}
\end{figure}

\begin{figure}[H]
	\centering
	
	\begin{tikzpicture}
		\node[state, initial] (i) {};
	    \node[state, right of=i] (1) {1};
	    \node[state, below of=i] (2) {2};
	    \node[state, right of=1] (3) {3};
	    \node[state, accepting, below of=3] (4) {4};
	    \path[->]
	    		(i) edge [bend left=10] node {a} (1)
    		    (i) edge [swap] node {b} (2)
    		    (1) edge [bend left=10] node {a} (i)
    		    (1) edge node {b} (3)
    		    (2) edge [swap] node {a} (4)
   		    (3) edge node {b} (4)
    		    (4) edge [loop right] node {b} ()
		;
	\end{tikzpicture}

  \caption{The minimal DFA of }
  \label{fg:mdfa_kbd}
\end{figure}

The notion of determinism can also be extended to block determinism as follows:

\begin{definition}
	An automaton  is \emph{-block deterministic} if the following conditions hold:
		\begin{itemize}
			\item there exists an alphabet  such that  is -block,
			\item ,
			\item .
		\end{itemize}
\end{definition}	

Finally, the block determinism of a Glushkov automaton can be used to extend the block determinism to block expression:

\begin{definition}
	A block regular expression  is -block deterministic if  is -block deterministic.
	A regular language is -block deterministic if it is specified by some -block deterministic regular expressions.
\end{definition}

Since a -block deterministic automaton is a deterministic automaton, the family of -block deterministic language is the same as the family of one-unambi\-guous language.

\begin{example}
	Since the Glushkov automaton in Figure~\ref{fg:GlushkovBloc} is -block deterministic,  is -block deterministic.
\end{example}
	
	Let  be an automaton and  be a set. Then the automaton  is \emph{an alphabetic image of}  if there exists an injection  from  to  such that . In this case, we set .	
Caron and Ziadi showed in~\cite{CZ97} that an automaton is a Glushkov one if and only if the two conditions hold:
\begin{itemize}
  \item it is homogeneous (for any state , for any two transitions  and , the symbols  and  are the same);
  \item it satisfies some structural properties over the transition structure.
\end{itemize}
One can check that any injection  from  to  preserves such conditions, since
the alphabetical image preserves the transition structure by only changing the symbol labeling a transition.
Therefore 
	\begin{lemma}\label{lm:ImageGlushkov}
	  The alphabetic image of an automaton  is a Glushkov automaton if and only if  is a Glushkov automaton. 
	\end{lemma}	
	Let us show that the BKW test can be used to characterize the -block determinism of a regular language:
\begin{theorem}\label{th:KBD}
	A regular language  is -block deterministic if and only if it is recognized by a -block deterministic automaton  such that  is the alphabetic image of a deterministic automaton which passes the BKW test.
\end{theorem}
\begin{proof}
  Let us show the double implication.
  \begin{enumerate}
	\item Let  be a -block deterministic regular language over .
	Then there exists a -block deterministic Glushkov automaton  that recognizes .
	Let  be an alphabet,  be
	the bijection such that for every . Let  be a Glushkov automaton such that .
	Let us suppose that  is not deterministic.
	Then, there exist two transitions  such that .
	Thus, , which contradicts the fact that  is -block deterministic.
	So,  is a deterministic Glushkov automaton, and therefore passes the BKW test following Lemma~\ref{lm:GlushkovBKW}.
	
	\item Let  be a deterministic automaton which passes the BKW test,  be a -block deterministic automaton, and  be an injection such that .
	Now,  is extended into the morphism  such that for every letter  and every word  we have  and .
	In this case, .
	Since  passes the BKW test, there exists an equivalent deterministic Glushkov automaton . Following Lemma~\ref{lm:ImageGlushkov}, there also exists a Glushkov automaton  such that  and .
	Since  and  are equivalent deterministic automata,
	.
	And so .
	Let us suppose that  is not -block deterministic, then there exist two transitions  such that either  or .
	By definition,  .
	But since  and  are equivalent deterministic automata, there exist two transitions , , and by definition, , .
	Let us suppose that .
	Since  is an injection, , which contradicts the fact that  is deterministic.
	So let us suppose that , it contradicts the fact that  is -block deterministic.
	Therefore,  is a -block deterministic Glushkov automaton, and  is -block deterministic.
\end{enumerate}
\end{proof}

	It has been proved that one-unambiguous regular languages are a proper subfamily of -block deterministic regular languages.
	As an example, the language  is -block deterministic but not one-unambiguous since its minimal deterministic automaton given in Figure \ref{fg:mdfa_kbd} does not pass the BKW test.
Therefore one can wonder whether there exists an infinite hierarchy in -block deterministic regular languages regarding .
That has been achieved by Han and Wood~\cite{HW08}, but with an invalid assumption.


\section{Previous Results on Block Deterministic Languages}\label{se:PrevRes}

	In~\cite{GMW01}, a method is presented for creating from a block automaton an equivalent block automaton with larger blocks by eliminating states while preserving the right language of every other states.
	
	Let  be a block automaton.
	The \emph{state elimination of  in } creates a new block automaton, denoted by , computed as follows: first, the state  and all transitions going in and out of it are removed; second, for every two transitions  and  in , the transition  is added.
	This transformation is illustrated in Figure~\ref{fg:StateElim}.

\begin{figure}[H]
	\begin{minipage}[b]{.48\linewidth}
		\centering
		
		\begin{tikzpicture}
			\node[state] (q) {};
			\node[state, above left of=q] (r1) {};
		    \node[state, below left of=q] (r2) {};
    		\node[state, above right of=q] (s1) {};
    		\node[state, below right of=q] (s2) {};
		    \path[->]
    		    (r1) edge [swap]node {} (q)
    		    (r2) edge node {} (q)
    		    (q) edge [bend left=10] node {} (s1)
	   			(q) edge node {} (s2)
	   			(s1) edge [bend left=10] node {} (q)
			;
		\end{tikzpicture}
	
	\end{minipage}
	\hfill
	\begin{minipage}[b]{.48\linewidth}
		\centering
			
		\begin{tikzpicture}	
			\node (q) {};
			\node[state, above left of=q] (r1) {};
		    \node[state, below left of=q] (r2) {};
    		\node[state, above right of=q] (s1) {};
    		\node[state, below right of=q] (s2) {};
		    \path[->]	    		
    		    (r1) edge node {} (s1)
    		    (r1) edge [swap, near start] node {} (s2)
    		    (r2) edge [near start] node {} (s1)
	   			(r2) edge [swap] node {} (s2)
	   			(s1) edge [loop above] node {} ()
    		    (s1) edge node {} (s2)	   			
			;
		\end{tikzpicture}

	\end{minipage}
	\caption{The state elimination of the state }
	\label{fg:StateElim}
\end{figure}

\begin{definition}
	Let  be a block automaton.
	A state  satisfies the \emph{state elimination precondition} if it is neither an initial state nor a final state and it has no self-loop.
\end{definition}

	The state elimination is extended to a set  of states if every state in  satisfies the state elimination precondition, and the subgraph induced by  is acyclic. In this case, we can eliminate the states in  in any order. Giammarresi \emph{et al.} \cite{GMW01} suggest that state elimination is sufficient to decide the -block determinism of a regular language.

\begin{lemma}[\cite{GMW01,HW08}]\label{le:GMWH}
	Let  be a minimal deterministic automaton of a -block deterministic regular language. We can transform  to a -block deterministic automaton that satisfies the orbit property using state elimination.
\end{lemma}

Using this lemma, Han and Wood stated that:

\begin{theorem}[\cite{HW08}]\label{th:HW}
	There is a proper hierarchy in -block deterministic regular languages.
\end{theorem}
\begin{proof}
	Han and Wood exhibited the family of languages  specified by regular expressions  whose minimal deterministic automata  are represented in Figure~\ref{fg:LEk}.
	Following Lemma~\ref{le:GMWH}, there is no other choice but to eliminate states  to , in any order, to have the orbit property.
	Thus,  is -block deterministic and not -block deterministic.
\end{proof}


\begin{figure}[H]
	\begin{minipage}[b]{.55\linewidth}
		\centering
		
		\begin{tikzpicture}
			\tikzstyle{every state}=[rounded rectangle, rounded rectangle arc length=90, inner sep=0.5mm, minimum size=5mm]		
		
			\node[state, initial] (qk) {};
			\node[state, below of=qk] (1) {};
		    \node[state, above of=qk] (qk1) {};
    		\node[state, right of=qk1] (qk2) {};
    		\node[state, right of=qk2, xshift=0.5cm] (q3) {};
    		\node[state, right of=q3] (q2) {};
    		\node[state, below of=q2] (q1) {};
    		\node[state, below of=q1] (2) {};
    		\node[state, accepting, left of=2] (3) {};
		    \path[->]
    		    (qk) edge node {} (qk1)
    		    (qk) edge [swap] node {} (1)
    		    (qk1) edge node {} (qk2)
    		    (q3) edge node {} (q2)
    		    (q2) edge node {} (q1)
    		    (q1) edge [swap] node {} (qk)
	   			(q1) edge node {} (2)
	   			(2) edge node {} (3)
	   			(1) edge [swap] node {} (3)
	   			(3) edge [loop above] node {} ()
			;
			\draw[densely dashed] (qk2) -- (q3);
		\end{tikzpicture}
	
	\end{minipage}
	\hfill
	\begin{minipage}[b]{.44\linewidth}
		\centering
			
		\begin{tikzpicture}
			\tikzstyle{every state}=[rounded rectangle, rounded rectangle arc length=90, inner sep=0.5mm, minimum size=5mm]		
		
			\node[state, initial] (qk) {};
			\node[state, below of=qk] (1) {};
    		\node[state, accepting, right of=1] (3) {};
    		\node[state, right of=3] (2) {};
		    \path[->]
    		    (qk) edge [loop above] node {} ()
    		    (qk) edge [swap] node {} (1)
    		    (qk) edge [bend left=35] node {} (2)
	   			(2) edge node {} (3)
	   			(1) edge [swap] node {} (3)
	   			(3) edge [loop above] node {} ()
			;
		\end{tikzpicture}

	\end{minipage}
		
	\caption{
	The minimal deterministic automaton  and its equivalent -block de\-ter\-mi\-nistic automaton after having eliminated states  to 
	}
	\label{fg:LEk}
\end{figure}


\section{A Witness for the Infinite Hierarchy of Block Deterministic Languages}\label{se:kbd_witness}

In this section, we exhibit a counter-example for Lemma~\ref{le:GMWH}. We can find a -block deterministic language with a minimal deterministic automaton from which we cannot get any -block deterministic automaton that satisfies the orbit property. 
	In Figure~\ref{mp:dfam}, the leftmost automaton is minimal and none of its states can be eliminated.
	However, by applying standardization, we create an equivalent deterministic automaton from which we can eliminate the state  to get the rightmost equivalent -block deterministic automaton.
	
\begin{figure}[H]
	\begin{minipage}[b]{.32\linewidth}		
		\centerline{
			\begin{tikzpicture}
				\node[state, initial] (i) {};
			    \node[state, accepting, above right of=i] (1) {};
		    	\node[state, accepting, below right of=i] (2) {};
			    \path[->]
		    		(i) edge [bend left=10] node {} (1)
		    		(i) edge [swap] node {} (2)
		   			(1) edge [bend left=10] node {} (i)
				;
			\end{tikzpicture}
		}
	\end{minipage}
	\hfill
	\begin{minipage}[b]{.32\linewidth}		
		\centerline{
			\begin{tikzpicture}
				\node[state, initial] (i') {};
				\node[state, right of=i'] (i) {};
			    \node[state, accepting, above right of=i] (1) {};
		    	\node[state, accepting, below right of=i] (2) {};
			    \path[->]
			    	(i') edge [bend left=30] node {} (1)
			    	(i') edge [swap, bend right=30] node {} (2)
		    		(i) edge [bend left=10] node {} (1)
		    		(i) edge [swap] node {} (2)
		   			(1) edge [bend left=10] node {} (i)
				;
			\end{tikzpicture}
		}
	\end{minipage}
	\hfill
	\begin{minipage}[b]{.32\linewidth}	
		\centerline{	
			\begin{tikzpicture}
				\node[state, initial] (i) {};
			    \node[state, accepting, above right of=i] (1) {};
		    	\node[state, accepting, below right of=i] (2) {};
			    \path[->]
		    	    (i) edge  node {} (1)
		    		(i) edge [swap] node {} (2)
		   		    (1) edge [loop right] node {} ()
		        	(1) edge node {} (2)
				;
			\end{tikzpicture}
		}
	\end{minipage}
	  	\caption{The counter-example}
	  	\label{mp:dfam}
\end{figure}	

This clearly shows that the only action of state elimination is not enough to decide whether a language is -block deterministic.
Using this operation, we show that:

\begin{proposition}
	, the language  is -block deterministic.
\end{proposition}
\begin{proof}
	As shown in Figure~\ref{fg:ContreEx}, we can always standardize , proceed to the state elimination of  and get a -block deterministic automaton which respects the conditions stated in Theorem~\ref{th:KBD}.
Thus,  is -block deterministic and is specified by the regular expressions .
\end{proof}


\begin{figure}[H]
	\begin{minipage}[b]{.48\linewidth}
		\centering	
		\begin{tikzpicture}[transform shape, scale=0.9]
			\tikzstyle{every state}=[rounded rectangle, rounded rectangle arc length=90, inner sep=0.5mm, minimum size=5mm]	
			\node[state, initial] (i) {};
			\node[state, right of=i] (qk) {};
			\node[state, below of=i] (1) {};
		    \node[state, above of=i] (qk1) {};
    		\node[state, right of=qk1] (qk2) {};
    		\node[state, right of=qk2, xshift=0.5cm] (q3) {};
    		\node[state, right of=q3] (q2) {};
    		\node[state, below of=q2] (q1) {};
    		\node[state, below of=q1] (2) {};
    		\node[state, accepting, left of=2] (3) {};
		    \path[->]
	    		(i) edge node {} (qk1)
    		    (i) edge [swap] node {} (1)
    		    (qk) edge [swap] node {} (qk1)
    		    (qk) edge node {} (1)
    		    (qk1) edge node {} (qk2)
    		    (q3) edge node {} (q2)
    		    (q2) edge node {} (q1)
    		    (q1) edge [swap] node {} (qk)
	   			(q1) edge node {} (2)
	   			(2) edge node {} (3)
	   			(1) edge [swap] node {} (3)
	   			(3) edge [loop above] node {} ()
			;
			\draw[densely dashed] (qk2) -- (q3);
		\end{tikzpicture}	
	\end{minipage}
	\hfill
	\begin{minipage}[b]{.48\linewidth}
		\centering	
		\begin{tikzpicture}[transform shape, scale=0.9]
			\tikzstyle{every state}=[rounded rectangle, rounded rectangle arc length=90, inner sep=0.5mm, minimum size=5mm]			
			\node[state, initial] (i) {};
			\node[state, below of=i] (1) {};
		    \node[state, above of=i] (qk1) {};
    		\node[state, right of=qk1] (qk2) {};
    		\node[state, right of=qk2, xshift=0.5cm] (qa3) {};
    		\node[state, right of=q3] (qa2) {};
    		\node[state, below of=q2] (qa1) {};
    		\node[state, below of=q1] (2) {};
    		\node[state, accepting, left of=2] (3) {};
	   		\path[->]
    		    (i) edge node {} (qk1)
    		    (i) edge [swap] node {} (1)
    		    (qk1) edge node {} (qk2)
    		    (q3) edge node {} (q2)
    		    (q2) edge node {} (q1)
		    	(q1) edge [bend left=10, swap] node {} (qk1)
    		    (q1) edge [bend right=10] node {} (1)
   				(q1) edge node {} (2)
	   			(2) edge node {} (3)
	   			(1) edge [swap] node {} (3)
   				(3) edge [loop above] node {} ()
			;
			\draw[densely dashed] (qk2) -- (q3);
		\end{tikzpicture}
	\end{minipage}	
	\caption{The standardization of  followed by the state elimination of }
	\label{fg:ContreEx}
\end{figure}

	However, Theorem~\ref{th:HW} is still correct since we can give proper details about the proof with our own parameterized family of languages.
Let  be an integer and  be the automaton (given in Figure~\ref{fg:Ak}) such that:
	\begin{itemize}
		\item 
		\item 
		\item 
		\item 
		\item  with:
			\begin{itemize}
				\item 
				\item 
			\end{itemize}
	\end{itemize}	
	
\begin{figure}[H]
	\centering
	
	\begin{tikzpicture}
		\tikzstyle{every state}=[rounded rectangle, rounded rectangle arc length=90, inner sep=0.5mm, minimum size=5mm]
	
		\node (anchor) {};	
		\node[state, initial, accepting, above right of=anchor] (bk) {};
		\node[state, right of=bk] (bk1) {};
		\node[state, right of=bk1] (bk2) {};
		\node[state, right of=bk2, xshift=0.5cm] (b2) {};
		\node[state, right of=b2] (b1) {};
	    \node[state, accepting, below right of=anchor] (ak) {};
		\node[state, right of=ak] (ak1) {};
		\node[state, right of=ak1] (ak2) {};
		\node[state, right of=ak2, xshift=0.5cm] (a2) {};
		\node[state, right of=a2] (a1) {};
    		\node[state, accepting, below right of=b1] (f) {};
	    \path[->]
		    (bk) edge node {} (bk1)
		    (bk) edge [swap] node {} (ak)
		    (bk1) edge node {} (bk2)
		    (bk2) edge [densely dashed] node {} (b2)
	   	 	(b2) edge node {} (b1)
	  	  	(b1) edge node {} (f)
   			(ak) edge [loop left] node {} ()
   			(ak) edge [swap] node {} (ak1)
   			(ak1) edge [swap] node {} (ak2)
   			(ak2) edge [densely dashed] node {} (a2)
		    	(a2) edge [swap] node {} (a1)
		    	(a1) edge [swap] node {} (f)
		   	(a1) edge [out=135, in=315, swap] node {} (bk)
		;
	\end{tikzpicture}
	
	\caption{The deterministic automaton }
	\label{fg:Ak}
\end{figure}	

	First of all, let us notice that the word  if and only if .
	Thus, for all , . Furthermore,

\begin{proposition}
	,  is -block deterministic.
\end{proposition}
\begin{proof}
	By construction, for all ,  is trimmed and deterministic.
	So, any automaton that we can get from eliminating states such that the state elimination precondition is respected is a block deterministic automaton. 

	For any integer  in , we can eliminate the set of states  because none of these states are initial or final and their induced subgraph is acyclic.	
	Thus, we can get a -block deterministic automaton , such that , shown in Figure~\ref{fg:bk}. 	
	Obviously  respects the conditions stated in Theorem~\ref{th:KBD}, so  is -block deterministic. Furthermore, it can be checked that  is specified by the -block deterministic regular expression .
\end{proof}


\begin{figure}[H]
	\centering
	
	\begin{tikzpicture}
		\tikzstyle{every state}=[rounded rectangle, rounded rectangle arc length=90, inner sep=0.5mm, minimum size=5mm]
	
		\node (anchor) {};	
		\node[state, initial, accepting, above right of=anchor] (bk) {};
		\node[state, accepting, below right of=anchor] (ak) {};
    	\node[state, accepting, below right of=bk] (f) {};
	    \path[->]
		    (bk) edge [bend left=25] node {} (f)
		    (bk) edge [bend left=10] node {} (ak)
   			(ak) edge [loop left] node {} ()
   			(ak) edge [bend right=25, swap] node {} (f)
	    	(ak) edge [bend left=10] node {} (bk)
		;
	\end{tikzpicture}
	
	\caption{The -block deterministic automaton }
	\label{fg:bk}
\end{figure}		

Finally, let us show that the index cannot be reduced:

\begin{proposition}
	,  is not -block deterministic.
\end{proposition}
\begin{proof}
	Let  be a -block deterministic automaton equivalent to .
	
	We first show that there exists a non-trivial orbit  and two states  such that  and .
	Let us consider the following state sequences:  and , such that ,  and .
	It follows that  and .
	Notice that the existence of  and  is ensured by the fact that .
	Let us suppose that there exists  such that .
	Then there exists  such that , where for any two sets  and , .
	And since , .
	Thus,  which is contradictory.
	So, for every , we have .
	The proof that for every , we have , is done in the same way.
	Now, let us suppose that for every , we have  and .
	Then  would be infinite, which would contradict the fact that  is a finite automaton.
	So, there exist  such that  or .
	Thus, either there exists a path going from  to  and a path going from  to , and  and  belong to the same orbit; or there exists a path going from  to  and a path going from  to , and  and  belong to the same orbit.
	
	Finally, let us focus on such an orbit  with two out-gates  and  such that  and .
	We know that for every  such that , we have  with .
	Since  and  is -block deterministic, there exist  and  such that ,  and .
	This means that , so .
	Now, if there does not exist a state  such that , then  does not have the orbit property.
	So, let us suppose that such a state exists.
	We know that for every  such that , we have  with .
	Since , we have  and .
	So  and  does not have the orbit property.
	
	Since  cannot be recognized by a -block deterministic alphabetic image of an automaton passing the BKW test, following Theorem \ref{th:KBD} it holds that  is not -block deterministic.
\end{proof}


\section{A Witness for the Infinite Hierarchy of Lookahead Deterministic Languages}\label{se:kld_witness}

	In this section, we give a parameterized family  such that  is -lookahead deterministic but not -lookahead deterministic.
	In order to prove it, we show that any -lookahead deterministic Glushkov automaton does not recognize .

	Let  and let  be the automaton (given in Figure \ref{fg:Aj}) such that:
	\begin{itemize}
		\item 
		\item 
		\item 
		\item 
		\item 
	\end{itemize}

\begin{figure}[H]
	\centering
	
	\begin{tikzpicture}
		\node[state, initial, accepting] (a0) {};
		\node[state, below right of=a0] (a1) {};
		\node[state, right of=a1, xshift=0.5cm] (ajm1) {};
		\node[state, accepting, above right of=ajm1] (aj) {};
	    \node[state, above left of=aj] (ajp1) {};
		\node[state, left of=ajp1, xshift=-0.5cm] (a2j) {};
	    \path[->]
		    (a0) edge [swap] node {} (a1)
		    (a1) edge [densely dashed, swap] node {} (ajm1)
		    (ajm1) edge [swap] node {} (aj)
		    (aj) edge [swap] node {} (ajp1)
		    (ajp1) edge [densely dashed, swap] node {} (a2j)
	   	 	(a2j) edge [swap] node {} (a0)
		;
	\end{tikzpicture}
	
	\caption{The minimal deterministic automaton }
	\label{fg:Aj}
\end{figure}	

Let us first show that the languages in the family are distinct and satisfy the condition of lookahead determinism.

\begin{proposition}
	,  is a minimal deterministic automaton.
\end{proposition}
\begin{proof}
	By construction, ,  is trimmed and deterministic.
	Then, if , there is only one state which is initial and final, so  is minimal.
	Otherwise, if ,  such that  and .
	Thus,  and  are not equivalent, and so are every non final states.
	Therefore, for every ,  is also minimal.
\end{proof}

Thus, for all , since , then .
Furthermore,

\begin{proposition}\label{prop:Aj_jp1_ld}
	,  is -lookahead deterministic.
\end{proposition}
\begin{proof}
	Let us consider the regular expression .
	Then  is -lookahead deterministic
	And since the minimal deterministic automaton recognizing  is isomorphic to , then .
	So  is -lookahead.
\end{proof}


	Let  and let  be a -lookahead deterministic Glushkov automaton.
	We demonstrate that  cannot recognized , that is to say that  is not -lookahead deterministic.
 
	In order to do so, we consider a property of Glushkov automata from Proposition 4.2 of \cite{CZ97}:
\begin{lemma}\label{lm:CZ_stability}
	Let  be a non-trivial orbit of .
	Then for every in-gate  of  and for every out-gate  of , .
\end{lemma}

	Let us first restrain the set of Glushkov automata to consider.
	We show that a state in a lookahead deterministic unary automaton cannot admit two distinct successors with infinite right languages.

\begin{proposition}\label{prop:klau_Lq_infinite}
	.
\end{proposition}
\begin{proof}
	Let us suppose that there exist 3 states  such that , ,  and .
	Then, necessarily,  and .
	Thus  is not -lookahead deterministic.
\end{proof}

\begin{corollary}\label{prop:klau_orbite_non_triviale}
	Among the orbit of , at most one is non-trivial.
\end{corollary}

	Furthermore, let us suppose that  has no non-trivial orbit, then .
But, since for every , we have , then  could not recognize .
Thus,  must have a single non-trivial orbit denoted by , of size .
Moreover, the gates of  are remarkable:

\begin{proposition}\label{prop:klau_portes_uniques}
	 has a single in-gate and a single out-gate.
\end{proposition}
\begin{proof}
	The fact that there exists a single in-gate is also a direct consequence of Proposition \ref{prop:klau_Lq_infinite}.
	Furthermore, let us suppose that there exist 2 distinct states .
	Let  be the single in-gate of .
	Since  is a Glushkov automaton, following Lemma~\ref{lm:CZ_stability}, .
	Consequently, there exists  such that , contradicting Proposition~\ref{prop:klau_Lq_infinite}.
\end{proof}

	Consequently, we denote by  the single in-gate of  and by  its single out-gate.

	As a corollary of Proposition \ref{prop:klau_Lq_infinite}, and since Glushkov automata are standard, then there exists a single state  such that , which can be reached from the initial state by a single word  such that .
	This allows us to characterize the words reaching  from .

\begin{lemma}\label{lm:ooPathLength}
	.
\end{lemma}
\begin{proof}
	Following Proposition \ref{prop:klau_Lq_infinite}, we can deduce: .
	Thus, .
	And following Lemma \ref{lm:CZ_stability},  and thus .
	Since  and , then .
\end{proof}

	Moreover, we give a necessary condition over words in .

\begin{lemma}\label{lm:w123}
	Let  such that  and for every  such that , either  or .
	Then, either  and , or  and .
\end{lemma}
\begin{proof}
	Since , then either  and , or  and .
\end{proof}
	
	From the two previous lemmas, we show that  cannot recognize .
	
\begin{proposition}
	.
\end{proposition}
\begin{proof}
	Let  be the set of direct successors of  outside of , and  be the union of their right languages.
	Then, since  is -lookahead deterministic, the length of any word of  is strictly smaller than .
	
	Let us consider the set  of words reaching a final state from  without going through .
	By definition,  if ,  otherwise.
	Then, the length of any word  is strictly smaller than .
	
	If , then  and .
	
	Now, let us suppose that there exist two distinct words  such that , then .
	Moreover, there exists a word  such that .
	Thus,  and .
	Following Lemma \ref{lm:w123}, .
	
	Now, let us suppose that .
	Since  is the single non-trivial orbit and  is its single out-gate, then there exists  such that for every word , if  then  with .
	Let  such that  and for every  such that , either  or .
	Then, following Lemma \ref{lm:ooPathLength}, , which means that .
\end{proof}

	Thus,  cannot be recognized by a -lookahead deterministic Glushkov automaton.
	Consequently:
	
\begin{proposition}\label{prop:Aj_non_j_ld}
	,  is not -lookahead deterministic.
\end{proposition}

	We can conclude that:
\begin{theorem}
	There is a proper hierarchy in -lookahead deterministic regular languages.
\end{theorem}


\section{Relationship Between Block Deterministic Languages and Lookahead Deterministic Languages}\label{se:inclusion_kbd_kld}

	Han and Wood stated in~\cite{HW08} that block deterministic languages are a proper subfamily of lookahead deterministic languages.
	However, in their proof of the block deterministic languages being a proper subfamily of the lookahead deterministic languages, they used a statement made by Giammarresi \emph{et al.} in~\cite{GMW01} about the family of languages  not being -block deterministic.
	But we proved that Lemma \ref{le:GMWH}, which is used as a basis for deciding if a language is block deterministic, is wrong.
	So we cannot be sure that their example is not block deterministic and give our own proof.

\subsection{Block Deterministic Languages as a Subfamily of Lookahead Deterministic Languages}

	We start by presenting some properties of block regular expressions and regular expressions over the language of their marked expressions.
	

\begin{lemma}
	A block regular expression  is -block deterministic if and only if: 
	.
\end{lemma}
\begin{proof}
	Giammarresi \emph{et al.} in \cite{GMW01} defined a block regular expression  being block deterministic if the following two conditions hold:
	\begin{itemize}
		\item 
		\item .
	\end{itemize}
	And we can deduce from it the aforementioned property.
\end{proof}

\begin{lemma}[\cite{HW08}]
	A regular expression  is -lookahead deterministic if and only if:
	
\end{lemma}


	Let  be a ()-block regular expression over an alphabet  and  its marked block regular expression  over the alphabet .
	Let  be an alphabet,  a function such that for every , .
	
\begin{example}
	.
\end{example}
	
	Every symbol of  is linked to only one position of block of  and represents the position of a letter in a position of block.
	Considering that every block of  is indexed differently, every element of  is produced by only one block.
	We define the following functions for every  :
	\begin{itemize}
		\item  with 
		\item  with 
		\item  with 
	\end{itemize}
	
	A word  is \emph{simple block complete} if there exists  such that .
	The set of simple block complete words over  is denoted by .
	Let , then  is \emph{block complete} and the set of block complete words is denoted by .
	Then, we can define  as a bijection between  and , and extend it by morphism between  and .
	
	Let  be the function which takes a marked block regular expression  and transform it into a marked regular expression  over the alphabet  such that, for every subexpression , .
	In this way, we extend the definition of marked regular expresion to regular expressions over an alphabet indexed by any number of element, and whose symbol appear only once in the regular expression.
	
	\begin{example}
		Let , then  and .
	\end{example}
	
	In the rest of this section, we consider the following regular expression :  a ()-block regular expresion, its marked block regular expression  over ,  a marked regular expression over  and  a regular expression over .

We can deduce some obvious properties about :
	

	
	We can also deduce some properties about block complete words, such that for every ,  is bloc complete if  or if it validates all of the following conditions:
	
	
	

	Let us show that the previous statements induce important conditions concerning .

\begin{proposition}\label{prop:mot_bc}
	Every word  is block complete.
\end{proposition}
\begin{proof}
	Let .
	If , then  is block complete.
	Now let us suppose that .
	Following property \eqref{claim:first},  validates property \eqref{claim:CB_BP1}.
	Following property \eqref{claim:last},  validates property \eqref{claim:CB_BPBL}.
	And following property \eqref{claim:follow},  validates the properties \eqref{claim:CB_BP_eq} and \eqref{claim:CB_BP_neq}.
	Therefore  is block complete.
\end{proof}


\begin{proposition}\label{prop:fourche}
	Let  and  such that  and .
	Then  and .
\end{proposition}
\begin{proof}
	Since the words , then .
	Following property \eqref{claim:follow},  implies that   and .
	Then, using Proposition \ref{prop:mot_bc}, we can conclude that .
	Moreover, since  and , then .
\end{proof}


\begin{proposition}\label{prop:bijectionLangage}
	 is a bijection between  and .
\end{proposition}
\begin{proof}
	Following property \eqref{claim:null}, .
	Since , then .

	Let  such that , according to the definition of function , .
	
	Let  such that .
	Following Proposition \ref{prop:mot_bc},  is block complete.
	Let set  such that for every , .
	Then:
	\begin{itemize}
		\item 
		\item 
		\item .
	\end{itemize}
	This means that :
	\begin{itemize}
		\item  (following property \eqref{claim:first})
		\item  (following property \eqref{claim:last})
		\item  (following property \eqref{claim:follow}).
	\end{itemize}
	Therefore, .
	This demonstrates that  is also a bijection between .
\end{proof}

In the same way, we can also prove that  is a bijection between  and .

\begin{proposition}\label{prop:preservationLangage}
	.
\end{proposition}
\begin{proof}
	Let  such that  and .
	According to the definition of the bijection , for every .
	And since , then:\\
	

\end{proof}

\begin{theorem}\label{th:kbd_kla}
	If  is -block deterministic, then  is -lookahead deterministic.
\end{theorem}
\begin{proof}
	Let us suppose that  is not -lookahead deterministic.
	Then, there exist  and  such that ,  et .
	Since  then, following Proposition \ref{prop:fourche},  and .
	Let  and  such that .
	Then .
	Since , then .
	And since , then .
	But since  is -block deterministic, then  and .
	So  and .
	But since , then either , or .
	Thus  cannot be -block deterministic.
	Therefore, if  is -block deterministic, then  is indeed -lookahead deterministic.
\end{proof}

To conclude, following Theorem \ref{th:kbd_kla} and Proposition \ref{prop:preservationLangage} :

\begin{theorem}
	The family of -block deterministic languages is included in the family of -lookahead deterministic languages.
\end{theorem}



\subsection{Block Deterministic Languages as a Proper Subfamily of Lookahead Deterministic Languages}

	In this section, we show that the family block deterministic languages is strictly included in the one of lookahead deterministic languages.
	We first show that unary -block deterministic languages are one-unambiguous, and then conclude using the parameterized family provided in Section \ref{se:kld_witness}.

\begin{proposition}
	Let  be a regular expression over an unary alphabet .
	If  is -block deterministic, then  and .
\end{proposition}
\begin{proof}
	Let us suppose that  is -block deterministic.
	If , then there exist  such that .
	And since  is defined over an unary alphabet, then necessarily, either , or , which means that  is not -block deterministic.
	Therefore , and the same reasoning can be applied to .
\end{proof}

\begin{lemma}
	Let  be an alphabet and  be a -block deterministic regular expression over an alphabet .
	If  and   , then  is -block deterministic.
\end{lemma}
\begin{proof}
	Let  be a marked regular expression and  a regular expression over .
	Following Proposition \ref{prop:preservationLangage}, .
	Now, following property \eqref{claim:first},  imply that .
	And following property \eqref{claim:follow},  imply that .
	Therefore, following the construction of Glushkov automata in Defintion \ref{def:Glushkov},  is deterministic and  is one-unambiguous (that is to say -block deterministic).
\end{proof}

	Consequently:

\begin{theorem}
	If an unary language is block deterministic, then it is -block deterministic.
\end{theorem}

	Therefore:

\begin{proposition}
	For any , there exists unary languages which are -lookahead deterministic without being block deterministic.	
\end{proposition}
\begin{proof}
	In Section \ref{se:kld_witness}, we showed that for any ,  is -lookahead deterministic without being -lookahead deterministic.
	And since they are not -lookahead deterministic (that is to say one-unambiguous), they are not block deterministic for any .
	Thus, for any ,  is -lookahead deterministic without being block deterministic.
\end{proof}

	Finally:

\begin{theorem}
	, the family of -block deterministic languages is strictly included in the one of -lookahead deterministic languages.
\end{theorem}


\section{Conclusion and Perspectives}

In this paper, we demonstrated that despite some erroneous results, there exists an infinite hierarchy in block deterministic languages.
We showed that such an infinite hierarchy also exists in lookahead deterministic languages.
And finally, showing that block-deterministic unary languages are one-unambiguous, we gave our own proof of the family of block deterministic languages being strictly included in the family of lookahead deterministic languages.

From these results, one can wonder whether there exists a -lookahead deterministic language which is -block deterministic without being -block deterministic.
Another open problem is the decidability of the lookahead determinism of a language.
Finally, the decidability of the block determinism of a language has been studied by Giammarresi \emph{et al.} but proved with Lemma~\ref{le:GMWH} which we invalidated.
Thus, this problem is still open.


\bibliography{biblioRapport}

\end{document}
