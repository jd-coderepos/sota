
\documentclass{article}

\usepackage{fullpage,times,comment,epsfig,algorithm,algorithmic,graphicx,cite,multirow,enumerate,amssymb,amsthm,url}

\usepackage[cmex10]{amsmath}
\usepackage{array}
\usepackage{mdwtab}
\usepackage[tight,footnotesize]{subfigure}
\usepackage{tikz}
\usepackage[para]{threeparttable}

\newcommand{\sknnb}{SNN}
\newcommand{\sknnm}{SNN}

\usepackage{tikz-qtree}
\usetikzlibrary{arrows}

\tikzset{
  treenode/.style = {align=left, inner sep=.5pt, text centered,
    font=\sffamily \tiny},
  arn_n/.style = {treenode, circle, white, font=\sffamily\bfseries, draw=black,
    fill=black, text width=1em},arn_r/.style = {treenode, circle, red, draw=red, 
    text width=1em, very thick},arn_x/.style = {treenode, rectangle, draw=black,
    minimum width=0.3em, minimum height=0.3em}}




\newtheorem{example}{Example}
\newtheorem{definition}{Definition}
\newtheorem{observation}{Observation}
\newtheorem{claim}{Claim}
\newtheorem{theorem}{Theorem}

\begin{document}
\begin{center}
\vspace*{5cm}
{\huge\bf\sf Secure {\em k}-Nearest Neighbor Query over\\ Encrypted Data in Outsourced Environments}\\
\vspace{3cm}

{\Large\bf\sf Yousef Elmehdwi, Bharath K. Samanthula and Wei Jiang}\\


{\large\sf \emph{Email:} \{ymez76, bspq8, wjiang\}@mst.edu}\\

\vspace{3cm}
{\Large\sf \today}\\ \vspace{1cm}
\hrule
\begin{center}
{\large\sf Technical Report \\
Department of Computer Science, Missouri S\&T\\
500 West 15th Street, Rolla, Missouri 65409}\\
\end{center}

\begin{comment}
\begin{figure}[!h]
\centering
\epsfig{file=logo-new, width= .3\textwidth}
\label{fig: logo}
\end{figure}
\end{comment}
\end{center}

\title{}
\author{}



\date{}
\maketitle

\begin{abstract}
For the past decade, query processing on relational data has been studied extensively, 
and many theoretical and practical  
solutions to query processing have been proposed under various scenarios. 
With the recent popularity of cloud computing, 
users now have the opportunity to outsource their data as well as the data management 
tasks to the cloud. However, due 
to the rise of various privacy issues, sensitive data (e.g., medical records) need to be
encrypted before outsourcing to the cloud. In addition, query processing tasks should be handled 
by the cloud; otherwise, there would be no point to outsource the data at the first place. 
To process queries over encrypted data without the cloud ever decrypting the data is a 
very challenging task.  
In this paper, 
we focus on solving the -nearest neighbor (NN) query problem over encrypted database
outsourced to a cloud: a user issues an encrypted query record to the cloud, and the 
cloud returns the  closest records to the user. 
We first present a basic scheme  
and demonstrate that such a naive solution is not secure. To provide better security, 
we propose a secure NN protocol that protects  
the confidentiality of the data, user's input query, and data access patterns. Also, we empirically analyze 
the efficiency of our protocols through various experiments. These results indicate that
our secure protocol is very efficient on the user end, and this 
lightweight scheme allows a user to use any mobile device to perform the NN query.\\

\noindent \textbf{Keywords}: Security, -NN Query, Encryption, Cloud Computing 
\end{abstract}
\section{Introduction}
\label{sec:intr}
As an emerging computing paradigm, cloud computing attracts many 
organizations to consider utilizing the benefits of a cloud in terms of  
cost-efficiency, flexibility, and offload of administrative overhead. 
In cloud computing model \cite{hu2011processing,mell2011nist}, a data 
owner outsources his/her database  and the DBMS functionalities to the 
cloud that has the infrastructure to host outsourced databases and 
provides access mechanisms for querying and managing the hosted database. 
On one hand, by outsourcing, the data owner gets the benefit of reducing the data management
 costs and improves the quality of service. On the other hand, hosting and query processing of data out
 of the data owner control raises security challenges such as preserving data confidentiality and query privacy.

One straightforward way to protect the confidentiality of 
the outsourced data from the cloud as well 
as from the unauthorized users is to encrypt data by the data owner before outsourcing\cite{abadi2009data,pearson2009privacy,li2012toward}. 
By this way, the data owner can protect the privacy of his/her own data. 
In addition, to preserve query privacy, authorized users require encrypting their queries before sending them to the cloud for evaluation.
Furthermore, during query processing,
 the cloud can also derive useful and sensitive information 
about the actual data items by observing the data access 
patterns even if the data and query are encrypted \cite{williams2008building,de2012managing}.
Therefore, following from the above discussions, secure query processing needs to guarantee (1) 
confidentiality of the encrypted data (2) 
confidentiality of a user's query record and (3) hiding data access patterns.

Using encryption as a way to achieve data confidentiality may cause another issue
during the query processing step in the cloud. In general, it is very
difficult to process encrypted data without ever having to decrypt it. 
The question here is how the cloud can execute the queries over encrypted data while the data stored at the 
cloud are encrypted at all times.
In the literature, various techniques related to query processing over 
encrypted data have been proposed, including range queries \cite{agrawal2004order,hore2004privacy,shi2007multi, hore2012secure} 
and other aggregate queries \cite{hacigumucs2004efficient,mykletun2006aggregation}.  
However, these techniques are either not applicable or inefficient to solve advanced queries such 
as the -nearest neighbor (NN) query. 

In this paper, we address the problem of secure processing 
of -nearest neighbor query over encrypted data (SNN) in the cloud. 
Given a user's input query , the objective of the SNN problem is to securely 
identify the -nearest data tuples to  using the encrypted database of 
 in the cloud, without allowing the cloud to learn anything regarding the actual contents of 
the database  and the query record .
More specifically, when encrypted data are outsourced to the cloud, we observe that 
an effective SNN protocol needs to satisfy the following properties: 
\begin{itemize}\itemsep=0pt
\item Preserve the confidentiality of  and  at all times
\item Hiding data access patterns from the cloud
\item Accurately compute the -nearest neighbors of query 
\item Incur low computation overhead on the end-user
 \end{itemize}
In the past few years, researchers have proposed various methods \cite{wong2009secure,hu2011processing,yaosecure} to 
address the SNN problem. However, we emphasize that the 
existing SNN methods proposed in \cite{wong2009secure,hu2011processing} violate at 
least one of the above mentioned desirable properties of a SNN protocol.
On one hand, the methods in \cite{wong2009secure,hu2011processing} are insecure because they 
are vulnerable to chosen and known plaintext attacks. 
On the other hand, recent method in \cite{yaosecure} returns non-accurate 
NN result to the end-user. More precisely, in \cite{yaosecure}, the cloud retrieves the relevant encrypted 
partition instead of finding the encrypted exact -nearest neighbors. Furthermore, in 
\cite{hu2011processing,yaosecure}, the end-user involves in heavy computations during the query processing step. 
By doing so, the method in \cite{yaosecure} utilizes cloud as just a storage medium, i.e., no significant 
work is done on the cloud side.   
More details about the existing SNN methods are provided in Section \ref{sec:related-work}. 

Along this direction, with the goal of providing better security, this paper proposes a 
novel SNN protocol that satisfies the above properties altogether. 
\subsection{Problem Definition}\label{sec:problemfor}
Suppose the data owner Alice owns a database  of 
 records, denoted by ,  
and  attributes. Let
 denote the  attribute value of record . In our problem setting, we 
assume that Alice 
initially encrypts her database attribute-wise, that is, 
she computes , for  and , where  denotes the encryption 
function of a public-key cryptosystem that is semantically 
secure \cite{paillier-99}. Let the encrypted database be denoted by . We assume 
that Alice outsources  as well as the future querying processing services to the cloud.

Consider an authorized user Bob who wants 
to ask the cloud for -neighbor records that are closest to his 
input query  based on . 
During this process, Bob's query  and contents of database  should not be 
revealed to the cloud. In addition, the access patterns to the data should be protected 
from the cloud. We refer 
to such a process as Secure NN (SNN) query over encrypted 
data in the cloud. Without loss of generality, let  denote 
the -nearest records to . Then, we formally define the SNN protocol as follows: 
 
We emphasize that, at the end of the SNN protocol, the output  should 
be revealed only to Bob. We now present a real-life application of the SNN protocol. 


\renewcommand{\tabcolsep}{.15cm}
\begin{table}[!t]
\centering
\caption{Sample Heart Disease Dataset } \begin{tabular}{ccccccccccc}  
     \hline\hline record-id &\;age&\;sex&\;cp&\;trestbps&\;chol&\;fbs&\;slope&\;ca&\;thal&\;num \\ [1ex] \hline  &63 & 1 & 1 & 145 & 233 & 1 & 3 & 0 &6 & 0  \\  & 56 & 1  & 3	&130& 256 & 1& 2 & 1 & 6&2\\
    	 & 57 & 0 & 3  & 140 & 241 & 0 & 2 & 0 & 7 & 1 \\
    	 & 59 & 1 & 4 & 144 & 200 & 1 & 2 & 2 & 6 & 3 \\
    	 & 55 & 0 & 4  & 128 & 205 & 0 & 2 & 1 &7 & 3 \\
    	 & 77 & 1 & 4 & 125 & 304 & 0 & 1 & 3 & 3 & 4 \\ [1ex] \hline \end{tabular}\label{table:example} \end{table} 


\begin{example}\label{sec:example}
Consider a physician who would like to know the risk factor of heart disease in a specific patient.
Let  denote the sample heart disease dataset with attributes \textit{record-id}, \textit{age}, \textit{sex}, \textit{cp}, 
\textit{trestbps}, \textit{chol}, \textit{fbs}, \textit{slope}, \textit{ca}, \textit{thal}, and \textit{num} 
as shown in Table \ref{table:example}. The description and range for each of these attributes 
are shown in Table \ref{table:map}. The heart disease dataset 
given in Table  \ref{table:example} is obtained from the UCI machine learning repository \cite{uci-dataset-heart}.

Initially, the data owner (hospital) encrypts  attribute-wise, outsources the encrypted database  
to the cloud for easy management. In addition, the data owner delegates the future query processing 
services to the cloud. Now, we consider a doctor working at the hospital, say Bob, who would 
like to know the risk factor of heart disease in a specific 
patient based on . Let the patient medical information 
be  . In the SNN protocol, Bob first need to encrypt 
 (to preserve the privacy of his query) and send it to the cloud. Then the cloud searches on the encrypted database 
 to figure out the -nearest neighbors to the user's request. For simplicity, 
let us assume . Under this case, the  nearest neighbors to  are  and 
 (by using Euclidean distance as the similarity metric). After this, the cloud 
sends  and  (in encrypted form) to Bob. Here, the cloud should identify the 
nearest neighbors of  in an oblivious manner without knowing any sensitive information, i.e., all 
the computations have to be carried over encrypted records. Finally, Bob receives  
 and  that will help him to make medical decisions. 
\hfill 
\end{example}

\renewcommand{\tabcolsep}{.15cm}
\begin{table}[t]
\caption{Attribute Description of Heart Disease Dataset }
\centering
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{|l | l|}
\hline
\; age& \; age in years \\
\hline
\; sex&\; 1=male, 0=female \\ 
\hline
\; cp &\; chest pain type: 1=typical angina, 2=atypical angina,\\
&\;  3=non-anginal pain, 4=asymptomatic \\
\hline
 \; trestbps&\; resting blood pressure (mm Hg)\\
\hline
\; chol&\; serum cholesterol in mg/dl\\
\hline
 \; fbs&\; fasting blood sugar  120 mg/dl (1=true; 0=false) \\
\hline
\; slope&\; slope of the peak exercise ST segment \\
         &\; (1=upsloping, 2=flat, 3=downsloping) \\
\hline
 \; ca&\; number of major vessels (0-3) colored by flourosopy \\
\hline
 \; thal&\; 3=normal, 6=fixed defect, 7=reversible defect\\
\hline
 \; num&\; diagnosis of heart disease  from 0 (no presence) to 4\\
\hline 
\end{tabular}
\label{table:map}
\end{table}


\subsection{Our Contribution} 
In this paper, we propose a novel SNN protocol to facilitate the -nearest neighbor 
search over encrypted data in the cloud that preserves both the data privacy and query privacy. In our 
protocol, once the encrypted data are outsourced to the cloud, Alice does not participate in any 
computations. Therefore, no information is revealed to Alice. 
In particular, the proposed protocol meets the following requirements:
\begin{itemize}\itemsep=0pt
\item \textbf{Data confidentiality - } Contents of  or any intermediate results should not be revealed to the cloud. 
\item \textbf{Query privacy - } Bob's input query  should not be revealed to the cloud.
\item  \textbf{Correctness - } The output  
should be revealed only to Bob. In addition, no information other than  
should be revealed to Bob.
\item \textbf{Low computation overhead on Bob - } After sending his encrypted 
query record to the cloud, Bob involves only in a little computation 
compared with the existing works \cite{wong2009secure,hu2011processing,yaosecure}. More details are 
given in Section \ref{sec:method}.
\item \textbf{Hidden data access patterns - } Access patterns to the data, such as 
the records corresponding to the -nearest neighbors 
of , should 
not be revealed to Alice and the cloud (to prevent any inference attacks). 
\end{itemize}
We emphasize that the intermediate results seen by the cloud in our protocol 
are either newly generated randomized encryptions or 
random numbers. Thus, which data records 
correspond to the -nearest neighbors of  are 
not known to the cloud.  In addition, after sending his encrypted 
query record to the cloud, Bob does not involve in any computations (less workload at Bob's local machine). Hence, 
data access patterns are further protected from Bob. More details are given in Section \ref{sec:method}.

The rest of the paper is organized as follows. 
We discuss the existing related work and some background concepts    
in Section \ref{sec:related-work}. A set of security primitives that are utilized 
in the proposed protocols and their possible implementations are provided in Section \ref{sec:sub-methods}. 
The proposed protocols are explained in detail in 
Section \ref{sec:proposed}. Section \ref{sec:exp} discusses the performance 
of the proposed protocols based on various experiments. We conclude the paper along 
with future work in Section \ref{sec:concl}.

\section{Related Work and Background}\label{sec:related-work}

In this section, we first present an overview of the existing secure -nearest neighbor techniques. Then, we present 
the security definition adopted in this paper and the Paillier cryptosystem along with its additive 
homomorphic properties as a background. 
\subsection{Existing SNN Techniques}
Retrieving the  -nearest neighbors to a given query  is one of the most 
fundamental problem in many application domains such as similarity search, 
pattern recognition, and data mining. In the literature, many techniques 
have been proposed to address the SNN problem, which can be classified into 
two categories based on whether the data are encrypted or not: \textit{centralized} and \textit{distributed}.
\subsubsection{Centralized Methods}
In the centralized methods, we assume that the data owner outsources his/her database and DBMS 
functionalities (e.g., NN query) to an untrusted external service provider which 
manages the data on behalf of the data owner where only trusted users 
are allowed to query the hosted data at the service provider. 
By outsourcing data to an untrusted server, many security issues arise, 
such as data privacy (protecting the confidentiality of the data from 
the server as well as from query issuer). 
To achieve data privacy, data owner is required to use data anonymization models 
(e.g., -anonymity) or cryptographic (e.g., encryption and data perturbation) techniques 
over his/her data before outsourcing them to the server.


Encryption is a traditional technique used to protect the confidentiality 
of sensitive data such as medical records. Due to data encryption, the process of 
query evaluation over encrypted data becomes challenging. 
Along this direction, various techniques have been proposed for processing range \cite{agrawal2004order,hore2004privacy,shi2007multi, hore2012secure} 
and aggregation queries \cite{hacigumucs2004efficient,mykletun2006aggregation} over encrypted data. 
However, in this paper, 
we restrict our discussion to secure evaluation of NN query.

In the past few years, researchers have proposed different methods 
\cite{wong2009secure,hu2011processing,yaosecure} to  address the SNN problem. 
Wong et al.\cite{wong2009secure} proposed a new encryption scheme called asymmetric 
scalar-product-preserving encryption (ASPE) that preserves scalar product  
between the query vector  and any tuple vector  from database  for 
distance comparison which is sufficient to find NN. 
In\cite{wong2009secure}, data and query are encrypted using 
slightly different encryption schemes before outsourcing to the server.
As an alternative, Hu et al.\cite{hu2011processing} proposed a method based on Privacy 
Homomorphism (PH) encryption scheme. More specifically, they used a provably 
secure privacy homomorphism encryption scheme from\cite{domingo2002provably} 
that supports modular addition, subtraction and multiplication over encrypted data. They addressed 
the SNN problem under the following setting: the client has the ciphertexts of all data 
points in database  and the encryption function of  whereas the server has 
the decryption function of  and some auxiliary information regarding each data 
point. However, both methods in \cite{wong2009secure,hu2011processing} are not secure because they are 
vulnerable to chosen-plaintext attacks. We refer the reader to\cite{yaosecure} for more details 
on these security issues.

Recently, Yao et al.\cite{yaosecure} designed a new SNN method based on partition-based 
secure Voronoi diagram (SVD). Instead of asking the cloud to retrieve the exact NN, 
they required, from the cloud, to retrieve a relevant encrypted partition  for 
 such that  is guaranteed to contain the -nearest neighbors of . 
However, in our work, we are able to solve the SNN problem accurately by letting the  
cloud to retrieve the exact -nearest neighbors of  (in encrypted form). 
In addition, most of the computations during the query 
processing step in \cite{hu2011processing,yaosecure} are performed locally by the end-user (i.e., query issuer)  
which conflicts the very purpose of outsourcing the DBMS functionalities to the cloud. 
Since our proposed protocol solves the problem of finding -nearest neighbors 
of  over encrypted data, 
it can also be used in other relevant data mining tasks 
such as secure clustering, classification, and outlier detection. 

\subsubsection{Data Distribution Methods}
In the data distributed methods, data are assumed to be partitioned either 
vertically or horizontally and distributed among a set of independent, 
non-colluding parties. 
In the literature, the data distributed methods 
rely on secure multiparty computation (SMC) techniques 
that enable multiple parties to securely evaluate a function using their respective 
private inputs without disclosing the input of one party to the others. Many 
efforts have been made to address the problem of NN query in a distributed 
environment. Shaneck et al.\cite{shaneck2009privacy} proposed privacy-preserving algorithm to perform  
-nearest neighbor search.
The protocol in\cite{shaneck2009privacy} is based on secure multiparty computation for privately 
computing NN points in a horizontally partitioned dataset. 
Qi et al.\cite{qi2008efficient} proposed a single-step NN search protocol that 
is provably secure with linear computation and communication complexities. 
Vaidya et al.\cite{vaidya2005privacy} studied privacy-preserving top- queries in which the data are vertically partitioned. 
Ghinita et al.\cite{ghinita2008private} proposed a private information retrieval (PIR) framework 
for answering NN queries in location-based services. However, 
their solution protects only the query privacy, i.e., it does not address data confidentiality and access 
pattern issues. 

We emphasize that the above data distribution methods are not 
applicable to perform NN queries over encrypted data for two reasons: (1). 
In our work, we deal with encrypted form of database and query 
which is not the case in the above methods (2). The 
database in our case is encrypted and stored on the cloud 
whereas in the above methods it is partitioned (in plaintext format) 
among different parties.
\subsection{Security Definition}
In this paper, 
privacy/security is closely related to the 
amount of information disclosed during the execution of a protocol. 
There are many ways to define information disclosure. To maximize privacy or 
minimize information disclosure, we adopt the security definitions in the literature 
of secure multiparty computation (SMC) first introduced by Yao's Millionaires' problem
for which a provably secure
solution was developed \cite{Yao82,Yao86}.
In this paper, we assume that parties are
semi-honest; that is,
a semi-honest party (also referred to as honest-but-curious)
follows the rules of the protocol using its correct input,
but is free to later use what it sees during execution of the protocol
to compromise security. We refer the reader to \cite{smc-2004,Goldreichnc} 
for detailed security definitions and models. Briefly, the following 
definition captures the above discussion
regarding a secure protocol under the semi-honest model.

\begin{definition}\label{def:semi-honest}
Let  be the input of party ,  be  's 
execution image of the protocol  and  be the result computed from  for .
 is secure if  can be simulated from
 and
distribution of the simulated image is computationally indistinguishable
from .

\end{definition}

\subsection{Paillier Cryptosystem}
The Paillier cryptosystem is an additive homomorphic and probabilistic 
asymmetric encryption scheme \cite{paillier-99}. Let  be the encryption 
function with public key  given by (), where  is a product of two large primes and 
 is in . Also, let  be 
the decryption function with secret key . 
Given , the Paillier encryption scheme exhibits the following properties:

\begin{enumerate}[a.]
     \item \textbf{Homomorphic Addition -} 
     \item \textbf{Homomorphic Multiplication -} 
     \item \textbf{Semantic Security -} The encryption scheme is semantically 
secure\cite{goldwasser-89,Goldreichnc}. Briefly, given a set of ciphertexts, an 
adversary cannot deduce any additional information about the plaintext. 
\end{enumerate}
In this paper, we assume that a data owner encrypted his or her data using 
Paillier cryptosystem before outsourcing them to a cloud. Some common 
notations that are used extensively in this paper are shown in Table \ref{tb:notations}.
\section{ Basic Security Primitives}\label{sec:sub-methods}
In this section, we present a set of generic protocols that will be used 
as sub-routines while constructing our proposed SNN protocol in Section \ref{sec:method}. All of 
the below protocols are considered under two-party semi-honest setting. In particular, 
we assume the existence of two semi-honest parties  and  such that the 
Paillier's secret key  is known only to  whereas  is treated as public. 
\begin{table}[t]
\caption{Common Notations}
\centering
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{| l | l |}
\hline
~Alice & ~The data owner of database \\
\hline
~ & ~Attribute-wise encryption of  \\ 
\hline
~Bob & ~An authorized user who can access  in the cloud \\
\hline
~ & ~Number of data records in \\
\hline
~ & ~Number of attributes in  \\
\hline
~ & ~ record in  \\
\hline
~ & ~Bob's query record \\
\hline
~ & ~ nearest record to  based on \\
\hline
~ & ~Domain size (in bits) of the squared Euclidean distance\\
& ~based on  \\
\hline
~ & ~The most and least significant bits of integer \\
\hline
~ & ~Vector of encryptions of the individual bits of \\
\hline 
\end{tabular}
\label{tb:notations}
\end{table}
  
\begin{itemize}
\item Secure Multiplication (SM) Protocol:\\ 
This protocol considers  
with input  and outputs  to , where  and 
 are not known to  and . 
During this process, no information regarding  and  is revealed to  and . The output  is known only to .
\item Secure Squared Euclidean Distance (SSED) Protocol:\\ 
 with input  
and  securely compute the encryption of squared Euclidean distance between vectors  and . 
Here  and  are  dimensional vectors where  and 
. At the end, the output  
 is known only to .
\item Secure Bit-Decomposition (SBD) Protocol:\\ 
 with input  and  securely compute the 
encryptions of the individual bits of , where . The 
output  is known only to . Here  and  
denote the most and least significant bits of integer  respectively.
\item Secure Minimum (SMIN) Protocol:\\ 
 with input  and  with  securely compute 
the encryptions of the individual bits of minimum number between  and . 
That is, the output is  which will be known only to . During this protocol, 
no information regarding  and  is revealed to  and .
\item Secure Minimum out of  Numbers (SMIN) Protocol:\\ 
In this protocol,  has  encrypted vectors  and 
 has . Here  such that 
 and  are the most and least significant bits of integer  respectively, 
for .  and  jointly compute the output . 
At the end of this protocol,  is known only to . During the SMIN 
protocol, no information regarding any of 's is revealed to  and .
\item Secure Bit-OR (SBOR) Protocol:\\
 with input  and  securely compute 
, where  and  are two bits. The output  is 
known only to . 
\end{itemize}
We now discuss each of these protocols in detail. 
Also, we either propose new solution or refer to the most efficient 
known implementation to each one of them. \\


\noindent \textbf {Secure Multiplication (SM). }
Consider a party  with private input  and a 
party  with the secret key . The goal of the secure multiplication (SM) 
protocol is to return the encryption 
of , i.e.,  as output to . During this protocol, no information regarding 
 and  is revealed to  and . The basic idea of the SM protocol 
is based on the following property which holds 
for any given : 

\begin{algorithm}[t]
\begin{algorithmic}[1]
\REQUIRE  has  and ;  has 
\STATE :
\begin{enumerate}\itemsep=0pt
    \item[(a).]  Pick two random numbers 
    \item[(b).]  
    \item[(c).]  ; send  to     
\end{enumerate}
\STATE :
\begin{enumerate}\itemsep=0pt
    \item[(a).]  Receive  and  from  
    \item[(b).]  ;~ 
    \item[(c).] 
    \item[(d).] ; send  to 
\end{enumerate}
\STATE :
\begin{enumerate}\itemsep=0pt
    \item[(a).]  Receive  from  
    \item[(b).]  
    \item[(c).]  
    \item[(d).]  
\end{enumerate}
\end{algorithmic}
\caption{SM}
\label{alg:sm}
\end{algorithm}
\noindent where all the arithmetic operations are performed under . The overall 
steps in SM are shown in Algorithm \ref{alg:sm}. Briefly,  initially 
randomizes  and  by computing  and , and 
sends them to . Here  and  are random numbers in  known only to . 
Upon receiving,  decrypts and multiplies them to get . 
Then,  encrypts  and sends it to . After this,  removes extra random factors 
from  based on Equation \ref{eq:mult} to get . 
Note that, for any given ,  ``'' is equivalent to ``'' under . 
Hereafter, we use the notation  to denote  as a random number in .
\begin{example} Suppose  and . For simplicity, let  and . Initially, 
 computes ,  and 
sends them to . Then,  decrypts  
and multiplies them to get . After this,  encrypts  to get  and sends it to . 
Upon receiving ,  computes , and 
. Finally,  computes 
.
\hfill \\
\end{example}
\noindent \textbf{Secure Squared Euclidean Distance (SSED). }
In the SSED protocol,  holds two encrypted vectors  and 
 holds the secret key . Here  and  are two -dimensional vectors 
where  and 
. The goal 
of the SSED protocol is to securely compute , where  denotes 
the Euclidean distance between vectors  and . During this protocol, no information regarding 
 and  is revealed to  and . 
The basic idea of SSED follows from 
following equation:

The main steps involved in SSED are shown in  Algorithm \ref{alg:ssed}. Briefly, for ,  initially 
computes   by using the homomorphic properties. Then  and  jointly compute 
 using the SM protocol, for . Note that the outputs of the SM protocol are known 
only to . After this, by applying homomorphic properties on ,  
computes  locally based on Equation \ref{eq:euclidean}.
\begin{example} Refer to Table \ref{table:example}, let us assume that  
 holds the encrypted data records of  and  as  and  respectively. That is, 
   and   
 . During the SSED protocol,   
initially computes . 
Then,  and  jointly compute  .  locally computes . 
\hfill \\
\end{example}
\begin{algorithm}[!t]
\begin{algorithmic}[1]
\REQUIRE  has  and ;  has 
\STATE , \textbf{for}  \textbf{do}:
\begin{enumerate}\itemsep=0pt
    \item[(a).]     
\end{enumerate}
\STATE  and , \textbf{for}  \textbf{do}:
\begin{enumerate}\itemsep=0pt
    \item[(a).] Compute  using the SM protocol        
\end{enumerate}
\STATE :
\begin{enumerate}\itemsep=0pt
\item[(a).] 
\end{enumerate}
\end{algorithmic}
\caption{SSED }
\label{alg:ssed}
\end{algorithm}
\noindent \textbf{Secure Bit-Decomposition (SBD). } 
We assume that  has  and  has , where  is not 
known to both parties and . The goal 
of the secure bit-decomposition (SBD)  
protocol is to compute the encryptions of 
the individual bits of binary representation of \cite{schoenmaker-2006,bksam-asiaccs13}. That is, 
the output is , 
where   and  
denote the most and least significant bits of  respectively. At the end, the output  is known 
only to . 

Since the goal of this paper is not to investigate existing SBD protocols, we simply 
use the most efficient SBD protocol that was recently proposed in \cite{bksam-asiaccs13}.

\begin{example} Let us suppose that  and . Then the SBD protocol with private input  gives 
  as the output to .
\hfill \\
\end{example} 
\noindent \textbf{Secure Minimum (SMIN). }
In this protocol,  with 
input  and  with  securely compute 
the encryptions of the individual bits of , i.e., 
the output is . Here  
and , where  (resp., ) and 
 (resp., ) are the most and least significant bits of  (resp., ). At 
the end, the output  is known only to . 

\begin{algorithm}[!t]
\begin{algorithmic}[1]
\REQUIRE  has  and , where ;  has \\
\STATE :
\begin{enumerate}\itemsep=0pt
        \item[(a).] Randomly choose the functionality 
        \item[(b).]  \textbf{for}  to  \textbf{do}:
                  \begin{itemize}\itemsep=0pt
                           \item   
                           \item :
                           \begin{itemize}\itemsep=0pt                              
                              \item                                
                              \item ; 
                           \end{itemize}
                               \textbf{else} 
                           \begin{itemize}\itemsep=0pt                               
                              \item                                  
                              \item ;  
                           \end{itemize}
                           \item 
                           \item ;  and  
                           \item   
                           \item ;   
                  \end{itemize}
    \item[(c).]    
    \item[(d).]  ; send  and  to 
\end{enumerate}
\STATE :
\begin{enumerate}\itemsep=0pt
        \item[(a).] Receive  and  from 
        \item[(b).]  , for                    
        \item[(c).]  \\                            
                                      
       \item[(d).]  , for                     
       \item[(e).] Send  and  to 
\end{enumerate}
\STATE :
\begin{enumerate}\itemsep=0pt
        \item[(a).] Receive  and  from 
        \item[(b).]   
        \item[(c).] \textbf{for}  to  \textbf{do}:
                  \begin{itemize}\itemsep=0pt
                           \item 
                           \item  \\                           
                           \textbf{else}                                                       
                  \end{itemize}  
\end{enumerate}               
\end{algorithmic}
\caption{SMIN}
\label{alg:sm2n}
\end{algorithm}
We assume that  and propose a novel 
SMIN protocol. The basic idea of the proposed SMIN protocol is 
for  to randomly choose the functionality  (by flipping a coin), where 
 is either  or , and to obliviously execute  with 
. Since  is randomly chosen and known only to , the output of 
the functionality  is oblivious to . Based on the output and chosen , 
 computes  locally using homomorphic properties. 

The overall steps involved in the SMIN protocol are shown in 
Algorithm \ref{alg:sm2n}. To start with,  initially 
chooses the functionality  as either  or  
randomly. Then, using the SM protocol,  computes  
with the help of , for . Now, depending on , 
 proceeds as follows, for :
\begin{itemize}
\item If , compute

\item If , compute:

where  is a random number in 
\item Observe that if , then  only if , 
and  otherwise. Similarly, when , we have  only 
if , and  otherwise. Also, depending of ,  stores the encryption of 
randomized difference between  and  which will be used in later computations. 
\item Compute the encrypted bit-wise XOR 
between the bits  and  as   using the 
below formulation:
\begin{center}
\end{center} In general, for any two given bits  and , we have 

\item Compute an encrypted vector  by preserving the first occurrence of  (if there 
exists one) in  by initializing . The  
rest of the entries of  are computed as . 
We emphasize that at most one of the entry in  is  and the remaining 
entries are encryptions of either 0 or a random number. Also, if there exists an index 
 such that , then index  is the first position (starting from the most significant bit) 
at which the corresponding bits of 
 and  differ.

\item Then,  computes . Note that ``'' is 
equivalent to ``'' under . From 
the above discussions, it is clear that  at most once since  is 
equal to  at most once. Also, if , then index  is the position 
at which the bits of  and  differ first.
\item Compute an encrypted vector  by combining  and . Note that  stores 
the result of   or  which depends on  known only to . 
Precisely,  computes , where  is a 
random number in . The observation here is if  an index  such 
that , denoting 
the first flip in the bits of  and , then  stores the 
corresponding desired information, i.e., whether  or  in encrypted form. 
\end{itemize}
\renewcommand{\tabcolsep}{.15cm}
\begin{table}[!t]
\centering
\caption{  chooses  as  where  and } \begin{tabular}{ccccccccccccc}  
     \hline &\;&\; &\;&\;&\;&\;&\;&\;'&\;&\;&\;&\;\\ [1ex] \hline 1&1&0&  & &   & &&&&& & 1\\ 
    	1&1&0&  & &   & &&&&& & 1\\  
    	0&1&1&  & &  & & &&&&& 0\\   
    	1&0&0&  & &&&&&&& & 1\\   
    	1&1&0&  && &&&& && & 1\\  
    	1&0&0&  & &&&&&&& & 1\\  \hline \end{tabular}\begin{tablenotes}
      \small
      \item All column values are in encrypted form except  column. Also, 
 is different for each row and column. 
\end{tablenotes}

\label{table:SMIN-example} \end{table} 
After this,  permutes the encrypted vectors  and  using two random permutation 
functions  and . Specifically,  computes  and 
, and sends them to . Upon receiving,  decrypts  component-wise to get 
, for , 
and checks for index  (decide the output of ). That is, if 
, then the output of  is 1, and 0 otherwise. Let the output 
be . Note that since 
 is not known to , the output  is oblivious to . In addition,  computes a new encrypted vector  where 
, for , sends  and  to 
. After receiving  and ,  computes the inverse permutation of  
as . Then,  performs the following homomorphic 
operations to compute the encryption of  bit of , i.e., 
, for :
\begin{itemize}
\item Remove the randomness from  by 
computing 
\item If , compute the  encrypted bit of  as 
. Otherwise, compute
.
\end{itemize}
In the SMIN protocol, one main observation (upon 
which we can also justify the correctness of the final output) is that 
if , then  always holds, for . 
Similarly, if , then  always holds.

\begin{example}
Consider that , , and . 
Assume that  holds   and
. In addition, we assume that 
's random permutation functions are as given below. 
\begin{table}[h]
\centering
\renewcommand{\arraystretch}{1.5}
\begin{tabular}{l l l l l l l l}
 &=& \quad 1 & \quad 2 & \quad 3 & \quad 4 & \quad 5 & \quad 6\\
& & \quad  & \quad  & \quad  & \quad  & \quad  & \quad  \\
~~&=& \quad 6 & \quad 5 & \quad 4 & \quad 3 & \quad 2 & \quad 1\\
~~&=& \quad 2 & \quad 1 & \quad 5 & \quad 6 & \quad 3 & \quad 4\\
\end{tabular}
\end{table}
Without loss of generality, suppose  chooses the functionality . Then, 
various intermediate results based on the SMIN protocol 
are as shown in Table \ref{table:SMIN-example}. Following from Table \ref{table:SMIN-example}, we observe that: 
\begin{itemize}
     \item At most one of the entry in  is  () and the remaining 
entries are encryptions of either 0 or a random number in .
     \item  Index  is the first position at which the corresponding bits of 
 and  differ.
      \item   since  is 
equal to . Also, since ,  sets  to 1.
\end{itemize}
At the end, only  knows .
\hfill \\
\end{example}
\noindent \textbf{Secure Minimum out of  Numbers (SMIN). } 
Consider  with private input  and  with , where 
 and , 
for . The goal of the SMIN protocol is 
to compute  without revealing any information about 's 
to  and . Here we construct a new SMIN protocol by utilizing SMIN  as 
the building block. The proposed SMIN protocol is an iterative approach and it computes the desired 
output in an hierarchical fashion. In each iteration, minimum between a pair of values is computed and are 
feeded as input to the next iteration. Therefore, generating a binary execution 
tree in a bottom-up fashion. At the end, only  knows the final result .  
\begin{algorithm}[t]
\begin{algorithmic}[1]
\REQUIRE  has ;  has 
\STATE : 
\begin{enumerate}\itemsep=0pt
  \item[(a).] , for 
  \item[(b).] 
\end{enumerate}    
\STATE  and , \textbf{for}  to :
\begin{enumerate}\itemsep=0pt
    \item[(a).] \textbf{for} : 
              \begin{itemize}
               \item : 
                             \begin{itemize}\itemsep=2pt
                                 \item ~SMIN
                                 \item   
                             \end{itemize} 
                      \textbf{else}
                            \begin{itemize}\itemsep=2pt
                                 \item ~SMIN
                                  \item  
                            \end{itemize} 
                                                                  
                 \end{itemize}               
    \item[(b).]  
\end{enumerate}
\STATE :
\begin{enumerate}\itemsep=2pt
    \item[(a.)] 
\end{enumerate}
\end{algorithmic}
\caption{SMIN}
\label{alg:smkn}
\end{algorithm}

The overall steps involved in the proposed SMIN protocol are highlighted in 
Algorithm \ref{alg:smkn}. Initially,  assigns  to a temporary vector , for 
. Also, he/she creates a global variable  and initialize it to 
, where  represents 
the number of (non-zero) vectors involved in each iteration. Since the 
SMIN protocol executes in a binary tree hierarchy (bottom-up fashion), we have 
 iterations, and in each iteration, the number of vectors 
involved varies. In the first iteration (i.e., ),   
with private input   and  with  involve 
in the SMIN protocol, for 
. At the end of the 
first iteration, only  knows 
 and nothing is revealed to , for .
Also,  stores the result  in , 
updates  to zero and  to . 

During the  iteration, only the non-zero vectors are involved, for . 
For example, during second iteration (i.e., ), only , and so on are involved. Note that 
in each iteration, the output is revealed only to  and  is updated to . 
At the end of the SMIN protocol,  assigns the final encrypted binary vector of global 
minimum value, i.e.,  which is stored in  to .
 \tikzset{edge from parent/.style=
     {draw, edge from parent path={(\tikzparentnode) -- (\tikzchildnode)}}}
\begin{figure}[!t]
\centering


\Tree [. [. [.    ] [.    ] ]
[. [.   ]  ] ]
\caption{Binary execution tree for  based on the SMIN protocol} \label{figure:SMIN_n-example}
\end{figure}
 
For example, assume that  holds  (i.e., ). 
Then, based on the SMIN protocol, the binary execution tree (in a bottom-up fashion) 
to compute  is as shown in Figure \ref{figure:SMIN_n-example}. Note that, 
 is initially set to , for . \\\\
\noindent \textbf{Secure Bit-OR (SBOR). }
Let us assume that  holds  and  holds , where  and  are 
two bits not known to both parties. The goal of 
the SBOR protocol is to securely compute . At the end of this protocol, 
only  knows . During this process, no information related to  and 
 is 
revealed to  and . Given the secure multiplication (SM) protocol,  can compute 
 as follows:
\begin{itemize}
\item  with input  and  with  involve in the SM protocol. At 
the end of this step, the output  is known only to . Note that, since 
 and  are bits, .
\item .
\end{itemize} 
We emphasize that, for any given two bits  and , the property 
 always holds. Note that, by 
homomorphic addition property, .


\section{The Proposed Protocols}\label{sec:proposed}
In this section, we first present a basic SNN protocol and demonstrate why such a simple 
solution is not secure. Then, we discuss our second approach, a fully secure 
NN protocol. 
Both protocols are constructed using the security 
primitives discussed in Section \ref{sec:sub-methods} as building blocks. 

As mentioned earlier, we assume that Alice's 
database consists of  records, denoted by , 
and  attributes, 
where  denotes the  attribute value of record . Initially, Alice 
encrypts her database attribute-wise, that is, 
she computes , for  and . Let the encrypted database be denoted by . We assume 
that Alice outsources  as well as the future query processing service to the cloud. 
Without loss of generality, we assume that all attribute values and their Euclidean distances lie in . 

In our proposed protocols, we assume the existence of two non-colluding semi-honest 
cloud service providers, denoted by  and , which together form 
a federated cloud. We emphasize that such an assumption is not new and has been 
commonly used in the related problem domains\cite{twinclouds-2011,wang-fuzzy-2013}. The intuition behind 
such an assumption is as follows. Most of the cloud service providers in the market are well-established 
IT companies, such as Amazon and Google. Therefore,  a collusion 
between them is highly unlikely as it will damage their reputation which 
in turn effects their revenues. 

Under this setting, Alice outsources her encrypted database  
to  and the secret key  to . 
The goal of the proposed protocols is to retrieve the top 
 records that are closest to the user query  
in an efficient and secure manner. Briefly, consider an authorized user Bob who wants 
to find  records that are closest to his query 
record  based on  in . 
Bob initially sends his query  (in encrypted form) to . After
this,  and  involve in a set of sub-protocols to securely retrieve 
(in encrypted form) the set of  records corresponding 
to the -nearest neighbors of the input query . At the end of 
our protocols, only Bob will receive the -nearest neighbors to  as the output. 

\subsection{Basic Protocol}\label{sec:basic-method}

In the basic secure -nearest neighbor query protocol, denoted by SNN, 
we relax the desirable properties 
to produce an efficient protocol (more details are given in the later part of this section). 

The main steps involved in the \sknnb~protocol are given in Algorithm \ref{alg:basic}.
Bob initially encrypts his query  attribute-wise, that 
is, he computes  and 
sends it to . 
Upon receiving  from Bob,  with private input  
and  with the secret key  jointly involve in the SSED protocol, where 
, for . 
The output of this step, denoted by , is the encryption of 
squared Euclidean distance between  and , i.e., . As mentioned earlier,  is 
known only to , for . 
We emphasize that computation of exact Euclidean distance between encrypted 
vectors is hard to achieve as it involves square root. However, in our 
problem, it is sufficient to compare the squared Euclidean distances as 
it preserves relative ordering. After this,  sends  to , where entry  
correspond to data record , for . 
Upon receiving , 
 decrypts the encrypted distance in each entry to 
get . Then,  generates an index list  
  
such that  are the top  smallest distances 
among . After this,  sends  to . 
Upon receiving ,  proceeds as follows: 
\begin{itemize}
\item Select the encrypted records  as the -nearest 
records to  and randomize them attribute-wise. More specifically,  computes 
, for  and . 
Here  is a random number in  and  denotes the column  attribute 
value of data record . Send  to  and  to Bob, for  and . 
\end{itemize}
Upon receiving , for  and ,  decrypts it 
to get  and sends them to Bob. Note that, due to randomization 
by ,  is always a random number in .

Finally, upon receiving  from  and  from , 
Bob computes the attribute values of  nearest neighbor to  as 
, for  and . Note that 
 is the RSA modulus or part of the public key .

\begin{algorithm}[!htbp]
\begin{algorithmic}[1]
\REQUIRE  has ;  has ; Bob has 
\STATE  Bob:
\begin{enumerate}\itemsep=0pt
     \item[(a).] Compute , for      
     \item[(b).] Send  to 
\end{enumerate}

\STATE  and :
\begin{enumerate}\itemsep=0pt
     \item[(a).]  receives  from Bob
     \item[(b).] \textbf{for}  to  \textbf{do}: 
\begin{itemize}
      \item 
\end {itemize}     
\item[(c).] Send  to 
  \end{enumerate}

\STATE :
\begin{enumerate}\itemsep=0pt
     \item[(a).] Receive  from 
     \item[(b).] , for 
\item[(c).] Generate , such that 
 are the top  smallest distances among 
     \item[(d).] Send  to   
 \end{enumerate}

\STATE :
\begin{enumerate}\itemsep=0pt
     \item[(a).] Receive  from 
     \item[(b).] \textbf{for}  and  \textbf{do}:
       \begin{itemize}
                 \item , where 
                 \item Send  to  and  to Bob   
       \end{itemize}            
\end{enumerate}

\STATE :
\begin{enumerate}\itemsep=0pt
\item[(b).] \textbf{for}  and  \textbf{do}:
       \begin{itemize}
                \item Receive  from 
                \item ; send  to Bob 
       \end{itemize}           
 \end{enumerate}

\STATE  Bob:
\begin{enumerate}\itemsep=0pt
     \item[(a).] \textbf{for}  and  \textbf{do}:
       \begin{itemize}
                \item Receive  from  and  from      
                \item 
       \end{itemize}           
\end{enumerate}

\end{algorithmic}
\caption{SNN}
\label{alg:basic}
\end{algorithm} 

\subsection{Fully Secure NN Protocol}\label{sec:method}
The above-mentioned \sknnb~protocol reveals the data access patterns to  and . 
That is, for any given ,   and  know which data records 
correspond to the -nearest neighbors of . Also, 
it reveals  values to . However, leakage of such information may not be acceptable 
in privacy-sensitive applications such as medical data. Along this direction, 
we propose a fully secure protocol, denoted by \sknnm (where m stands for maximally secure), to retrieve 
the -nearest neighbors of . The proposed \sknnm~protocol preserves all 
the desirable properties of a secure NN protocol as mentioned in Section \ref{sec:intr}.

The main steps involved in the proposed \sknnm~protocol are as shown 
in Algorithm \ref{alg:main}. Initially, Bob sends his attribute-wise encrypted query , that 
is,   
to . Upon receiving,  with private input  
and  with the secret key  jointly involve in the SSED protocol. The output 
of this step is  which will be known only to , for 
. Then,  with input  and  with  securely 
compute the encryptions of the individual bits of  using the SBD protocol. Note 
that the output of this step  is known 
only to , where  and  are the most 
and least significant bits of  respectively. Note that , for . 


After this,  and  compute the top  (in encrypted form) records that are 
closest to  in an iterative manner. More specifically, they compute 
 in the first iteration,  in the second iteration, and so on. Here  denotes 
the  nearest neighbor to , for . At the end of 
 iterations, only  knows . 
To start with, in the first iteration,  and  jointly compute the encryptions 
of the individual bits of the minimum value among  using 
SMIN. That is,  with input  
and  compute , where  is the minimum value 
among . The output  is known only to . Now,  performs 
the following operations locally:
\begin{itemize}
\item Compute the encryption of  from its encrypted individual bits as below 

where  and  are the most and least significant bits of  respectively.
\item Compute the encryption of difference between  and each . That is, 
 computes , for . 
\item Randomize  to get , where 
 is a random number in . Note that  is an encryption of 
either 0 or a random number, for . Also, permute  using a 
random permutation function  (known only to ) to get  and 
send it to .
\end{itemize} 
Upon receiving ,  decrypts it component-wise to get , 
for . After this, he/she computes an encrypted vector  of length  
such that  if , and  otherwise. Here we assume that 
exactly one of the entries in  equals to zero and rest of them are random. This further 
implies that exactly one of the entries in  is an encryption of 1 and 
rest of them are encryptions of 0's. However, we emphasize that if  has more than one 0's, 
then  can randomly pick one of those indexes and 
assign  to the corresponding index of  and  to the rest. Then,  sends  to . 
After receiving ,  performs inverse permutation on it to get 
. Note that exactly one of the entry in  is  and the remaining are 
encryption of 0's. In addition, if , then  is the closest record 
to . However,  and  do not know which entry in  corresponds 
to . 

Finally,  computes , encryption of the closest record 
to , and updates the distance vectors as follows: 
\begin{itemize}
\item  and  jointly involve in the secure multiplication (SM) protocol to compute 
, for  and .  The output  from the SM protocol is known only 
to . After this, by using homomorphic properties,  computes the 
encrypted record  locally, 
, where . Note that  
denotes the  attribute value of record .
\item It is important to note that the first nearest tuple to  should be 
obliviously excluded from further computations. However, since  does not 
know the record corresponding to , we need to obliviously eliminate 
the possibility of choosing this record again in next iterations. For this, 
 obliviously updates the distance corresponding to   
to the maximum value, i.e., . More specifically,  updates the distance vectors 
with the help of  using the SBOR protocol as below, for  and .
\begin{center}\end{center}
Note that when , the corresponding distance vector  is set 
to the maximum value. That is, under this case, . 
However, when , the OR operation has no affect on . 
\end{itemize} 
The above process is repeated until  iterations, and in each iteration  corresponding 
to the current chosen record is set to the maximum value. However, since  does 
not know which  is updated, he/she has to re-compute  in each iteration using 
their corresponding encrypted binary vectors , for . 
In iteration ,  is known only to .

At the end of the iterative step (i.e., step 3 of Algorithm \ref{alg:main}), 
 has  - the list of encrypted 
records of -nearest neighbors to the input query . The rest of the process is similar to 
steps 4 to 6 of Algorithm \ref{alg:basic}. Briefly,  randomizes  attribute-wise 
to get  and sends  to  and  to Bob, 
for  and . 
Here  is a random number in . Upon receiving 's,  decrypts 
them to get the randomized -nearest records as  and sends them to Bob, for  and . 
Finally, upon receiving  from  and  from , 
Bob computes the  nearest 
neighboring record to , as , for  and .
\begin{algorithm}[!htbp]
\begin{algorithmic}[1]
\REQUIRE  has  and ;  has ; Bob has 
\STATE  Bob sends  to 
\STATE  and :
\begin{enumerate}\itemsep=-1pt
\item[(a).] \textbf{for}  to  \textbf{do:}
               \begin{itemize}
                      \item  and                       
               \end{itemize}         
\end{enumerate}
\STATE \textbf{for}  to  \textbf{do:}
\begin{enumerate}\itemsep=-1pt
    \item[(a).]  and :                            
              \begin{itemize}               
               \item ~SMIN   
              \end{itemize}  
    \item[(b).] :
              \begin{itemize}\itemsep=-1pt
                \item 
                \item \textbf{if}  \textbf{then}, for 
                \begin{itemize}       
                    \item   
                \end{itemize}      
                \item \textbf{for}  to  \textbf{do:}     
                \begin{itemize}\itemsep=0pt                                 
                    \item 
                    \item , where 
                \end{itemize}  
                \item ; send  to  
              \end{itemize}  
    \item[(c).] :
              \begin{itemize}\itemsep=-1pt
\item , for 
                \item Compute , for :
                     \begin{itemize}\itemsep=-1pt   
                             \item \textbf{if}  \textbf{then}  
                             \item \textbf{else} 
                     \end{itemize}
                \item Send  to      
               \end{itemize}
    \item[(d).] :
              \begin{itemize}\itemsep=-1pt
\item 
                 \item , for  and   
                 \item , for 
                 \item   
              \end{itemize} 
    \item[(e).]  and , for :
              \begin{itemize}
                \item , for 
              \end{itemize}    
\end{enumerate}
\hspace{-0.45cm} The rest of the steps are similar to steps 4-6 of \sknnb
\begin{comment}
\STATE :
\begin{enumerate}\itemsep=-1pt
     \item[(b).] Compute  where 
     \item[(c).] Send   to  and  to Bob
 \end{enumerate}

\STATE :
\begin{enumerate}\itemsep=-1pt
     \item[(a).] Receive  from 
     \item[(b).] Compute  
     \item[(c).] Send  to Bob 
 \end{enumerate}

\STATE  Bob:
\begin{enumerate}\itemsep=-1pt
     \item[(a).] Receive  from  and  from      
     \item[(b).] 
\end{enumerate}
\end{comment}
\end{algorithmic}
\caption{SNN}
\label{alg:main}
\end{algorithm} 



\subsection{Security Analysis} 
Here we analyze the security guarantees of the proposed protocols. First, 
due to the encryption of  and by semantic security 
of the Paillier cryptosystem, Bob's input query  is protected from 
Alice,  and  in both protocols. 

In the \sknnb~protocol, 
the decryption operations at step 3(b) of Algorithm \ref{alg:basic} 
reveal  values to . In addition, since  generates the top  index list (at 
step 3(c) of Algorithm \ref{alg:basic}) and sends it to , the data access patterns are revealed 
to  and . Therefore, our basic \sknnb~protocol is secure under 
the assumption that  values can be revealed to  and 
data access patterns can be revealed to  and . 

On the other hand, the security analysis of \sknnm~is as follows. At step 2 of Algorithm \ref{alg:main}, 
the outputs of SSED and SBD are in encrypted format, and are 
known only to . In addition, all the intermediate results decrypted  
by  in SSED are uniformly random in . Also, 
as mentioned in \cite{bksam-asiaccs13}, the SBD protocol is secure. Thus, 
no information is revealed during step 2 of Algorithm \ref{alg:main}. In each 
iteration, the output of SMIN is known only to  and no information 
is revealed to . Also,  and  do not know which record belongs 
to current global minimum. Thus, data access patterns are protected 
from both  and . At step 3(c) of Algorithm \ref{alg:main}, a component-wise decryption 
of  reveals the tuples that satisfy the current global minimum 
distance to . However, due to permutation by ,  cannot trace back 
to the corresponding data records. Also, note that decryption 
of  gives either encryptions of 0's or random numbers in . 
Similarly, since  is an encrypted 
vector,  cannot know which tuple corresponds to current global minimum distance. 
Thus, data access patterns are further protected at this step from . In addition, 
the update process at step 3(e) of Algorithm \ref{alg:main} does not leak any information 
to  and . In summary,  and  do not know which data records correspond  
to the output set .

Based on the above discussions, it is clear that the proposed \sknnm~protocol 
protects the confidentiality of the data, privacy of user's input query, and hides 
the data access patterns.

\subsection{Complexity Analysis}\label{sec:complexity}
The computation complexity of \sknnb~is bounded by  encryptions, decryptions and 
exponentiations. In practice ; therefore, the computation complexity of 
\sknnb~is bounded by  encryptions and exponentiations (assuming that encryption and decryption 
operations under Paillier cryptosystem take similar amount of time). 

In the \sknnm~protocol, the computation complexity is bounded by  
instantiations of SBD and SSED,  instantiations of SMIN, and  instantiations 
of SBOR. We emphasize that the computation complexity of the SBD protocol 
proposed in \cite{bksam-asiaccs13} is bounded by  encryptions and  exponentiations. 
Also, the computation complexity of SSED is bounded by  encryptions and  exponentiations. In 
addition, the computation complexity of SMIN is bounded by  encryptions 
and  exponentiations. Since SBOR utilizes SM as a sub-routine, 
the computation cost of SBOR is bounded by (small) constant number of encryptions and exponentiations. 
Based on the above analysis, the total computation complexity of the \sknnm~protocol 
is bounded by  
encryptions and exponentiations.
 

\section{Empirical Results} \label{sec:exp}
In this section, we discuss the  
performances of the proposed protocols in detail under different parameter settings. 
We used Paillier cryptosystem\cite{paillier-99} 
and implemented the proposed protocols in C. Various experiments 
were conducted on a Linux machine with an 
Intel\textregistered~Xeon\textregistered~Six-Core\texttrademark~CPU 3.07 GHz 
processor and 12GB RAM running Ubuntu 10.04 LTS. 


Since it is difficult to control the parameters in a real dataset, 
we randomly generated synthetic datasets depending on the parameter values in consideration. 
Using these synthetic datasets we can  
perform a more elaborated analysis on the computation costs of the proposed protocols under different 
parameter settings. 
We encrypted these datasets attribute-wise, using the Paillier encryption 
whose key size is varied in our experiments, and the encrypted data were
stored on our machine. Based on the protocols protocols, we then 
executed a random query over this encrypted data. For the rest 
of this section, we do not discuss about the performance of Alice 
since it is a one-time cost. Instead, we evaluate 
and analyze the performances of \sknnb~and \sknnm~separately. In addition, 
we compare the two protocols. In all our experiments, the Paillier 
encryption key size, denoted by , is set to either 512 or 1024 bits.


\subsection{Performance of \sknnb} 
In this sub-section, we analyze the computation costs of \sknnb~by 
varying the number of data records (), number of 
attributes (), number of nearest neighbors (), and encryption key size (). Note 
that \sknnb~is independent of the domain size of attributes (). 

First, by fixing  and , we evaluated the computation costs 
of \sknnb~for varying  and . As shown in Figure \ref{fig:sknnb-512}, 
the computation costs of \sknnb~grows linearly with  and . For example, 
when , the computation time of \sknnb~increases from 44.08 to 87.91 seconds 
when  is varied from 2000 to 4000. A similar trend is observed for   
as shown in Figure \ref{fig:sknnb-1024}. For any fixed parameters, 
we observed that the computation time of \sknnb~increases almost by a factor 
of 7 when  is doubled. 

Next, by fixing  and , we evaluated the running times of \sknnb~for 
varying  and . The results are shown in Figure \ref{fig:sknnb-vary-K}. Irrespective 
of , the computation time of \sknnb~does not change much with varying . This is because 
most of the cost in \sknnb~comes from the SSED protocol which is independent of . 
E.g., when  bits, the computation time of \sknnb~changes from 44.08 to 44.14 seconds 
when  is changed from 5 to 25. Based on the above discussions, it is clear that the running time of \sknnb~mainly 
depends on (or grows linearly with)  and  which further justifies our complexity 
analysis in Section \ref{sec:complexity}.


\subsection{Performance of \sknnm}
We also evaluated the computation costs of \sknnm~for 
varying values of ,  and . 
Throughout this sub-section, we fix  and . However, we observed that the 
running time of \sknnm~grows linearly with  and .
\begin{figure*}[!tbp]
\centering
\subfigure[\sknnb~for  and ]
{
     \epsfig{file=figs/sknnb-512, width= .31\textwidth}
\label{fig:sknnb-512}
}
\subfigure[\sknnb~for  and ]
{
     \epsfig{file=figs/sknnb-1024, width= .31\textwidth}
\label{fig:sknnb-1024}
}
\subfigure[\sknnb~for  and ]
{
     \epsfig{file=figs/sknnb-vary-K, width= .31\textwidth}
\label{fig:sknnb-vary-K}
}
\subfigure[\sknnm~for  and ]
{
     \epsfig{file=figs/sknnm-512, width= .31\textwidth}
\label{fig:sknnm-512}
}
\subfigure[\sknnm~for  and ]
{
     \epsfig{file=figs/sknnm-1024, width= .31\textwidth}
\label{fig:sknnm-1024}
}
\subfigure[\sknnb~Vs.~\sknnm~for  and ]
{
     \epsfig{file=figs/comp-512, width= .31\textwidth}
\label{fig:comp-512}
}
\caption{Time complexities of \sknnb~and \sknnm~for varying values of , , ,  and encryption key size  }
\label{fig:complexity}
\end{figure*}


For  = 512 bits, the computation costs of \sknnm~for varying  and  are 
as shown in Figure \ref{fig:sknnm-512}. Following from Figure \ref{fig:sknnm-512}, 
for , the running time of \sknnm~varies from 11.93 to 55.65 minutes when  is changed from 5 
to 25 respectively. Also, for , the running time 
of \sknnm~varies from 20.68 to 97.8 minutes when  is changed from 
5 to 25 respectively. In either case, the cost of \sknnm~grows 
almost linearly with  and . 

A similar trend is observed for  as shown in Figure \ref{fig:sknnm-1024}. In 
particular, for any given fixed parameters, we identified 
that the computation cost of \sknnm~increases by almost a factor 
of 7 when  is doubled. For example, when  = 10, \sknnm~ took 22.85 and  
157.17 minutes to generate the 10 nearest neighbors of  
under  = 512 and 1024 bits respectively. Furthermore, 
when  = 5, we observed that around 69.7\% of cost in \sknnm~is accounted due to SMIN which is 
initiated  times in \sknnm~(once in each iteration). Also, the cost incurred 
due to SMIN increases from 69.7\% to at least 75\% when  is increased from 
5 to 25.

In addition, by fixing  and , we compared the 
running times of both protocols for varying values of . As shown in Figure \ref{fig:comp-512}, 
the running time of \sknnb~remains to be constant at 0.73 minutes since it 
is almost independent of . However, 
the running time of \sknnm~changes from 11.93 to 55.65 minutes as we increase  from 5 to 25. 

Based on the above results, it is clear that the computation costs 
of \sknnm~are significantly higher than that of \sknnb. However, we emphasize that \sknnm~is 
more secure than \sknnb; therefore, the two protocols act as a trade-off between security 
and efficiency. Also, it is important to note that Bob's computation cost is mainly due to the 
encryption of his input query record. As an example, for , Bob's computation costs are 4 and 17 milliseconds 
when  is 512 and 1024 bits respectively. This further shows that our proposed protocols are very efficient from 
end-user's perspective.

\subsection{Towards Performance Improvement}
At first, it seems that the proposed protocols are costly and may 
not scale well for large datasets. However, in both protocols, we emphasize 
that the computations involved on each data record are 
independent of others. Therefore, we can parallelize the operations on data records for 
efficiency purpose. To 
further justify this claim, we implemented a 
parallel version of our \sknnb~protocol using OpenMP programming and compared its 
computation costs with its serial version. As mentioned earlier, our machine has 6 cores which can be used to 
perform parallel operations on 6 threads. For  and  bits, the comparison 
results are as shown in Figure \ref{fig:comp-with-parallel}. 
\begin{figure}
\centering
\epsfig{file=figs/comp-with-parallel-512, width= .31\textwidth}
\caption{Comparison of parallel and serial versions of \sknnb~for  and  bits}
\label{fig:comp-with-parallel}
\end{figure}
The observation is 
that the parallel version of \sknnb~is roughly 6 times more efficient than its serial version. This 
is because of the fact that the parallel version can execute operations on 6 data records at a time (i.e., 
on 6 threads in parallel). For example, when , the running times of 
parallel and serial versions of \sknnb~are 40 and 215.59 seconds respectively. 
 


We believe that similar efficiency gains can be achieved by parallelizing the operations in \sknnm. 
Based on the above discussions, especially in a cloud 
computing environment where high performance parallel processing can easily be 
achieved, we claim that the scalability issue of the proposed protocols can be eliminated or mitigated.
In addition, using the existing map-reduce techniques, we can drastically 
improve the performance further by executing parallel operations 
on multiple nodes. We will leave this analysis to future work. 

\section{Conclusion} \label{sec:concl}
Query processing is an important task in database management systems. In particular, 
-nearest neighbors is one of the commonly used query in many data mining applications 
such as detection of fraud by credit card companies and prediction of tumor cells levels 
in blood. With the recent growth of cloud computing as a new IT paradigm, data owners are more 
interested to outsource their databases as well as DBMS functionalities to the cloud. Under an outsourced 
database environment, where encrypted data are stored in the cloud, secure query processing over 
encrypted data becomes challenging. To protect user privacy, various secure  
-nearest neighbor (SNN) techniques have been proposed in the literature. However, the existing 
SNN techniques over encrypted data are not secure. 

Along this direction, we proposed 
two novel SNN protocols over encrypted 
data in the cloud. The first protocol, which acts as a basic solution, leaks some information to 
the cloud. On the other hand, our second protocol is fully secure, that is, it protects the confidentiality of the data, user's 
input query, and also hides 
the data access patterns. However, the second protocol is more expensive compared to the basic protocol. 
Also, we evaluated the performance of our protocols under different parameter settings. As a future work, 
we will investigate and extend our research to other complex conjuctive queries over 
encrypted data. 


\bibliographystyle{abbrv}
\bibliography{ref} 


\end{document}
