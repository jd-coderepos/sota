\documentclass{article} \usepackage[nonatbib, final]{mod_neurips}
\usepackage[numbers]{styles/natbib}
\usepackage{url}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{color}
\usepackage{mathtools}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{subcaption}
\usepackage{float}
\usepackage{styles/svg}
\usepackage{lipsum} \usepackage{bm}
\usepackage{multicol}
\usepackage{booktabs}
\usepackage{array}
\usepackage{wrapfig}
\usepackage{enumitem}
\usepackage{caption}
\usepackage{subcaption}


\clearpage{}\makeatletter
\def\blfootnote{\xdef\@thefnmark{}\@footnotetext}
\makeatother

\newcommand{\cmt}[1]{{\footnotesize\textcolor{red}{#1}}}
\newcommand{\todo}[1]{\cmt{(TODO: #1)}}

\newcommand{\eg}{e.g.\ }
\newcommand{\ie}{i.e.\ }
\newcommand{\etal}{et al.\ }

\newcommand{\E}[2]{\operatorname{\mathbb{E}}_{#1}\left[#2\right]}
\newcommand{\EEE}{\mathbb{E}}
\newcommand{\density}{p}
\newcommand{\proposal}{q}  \newcommand{\target}{p}  \newcommand{\prop}{P}
\newcommand{\kl}[2]{\mathrm{D_{KL}}\left(#1\;\middle\|\;#2\right)}
\newcommand{\entropy}{\mathcal{H}}
\newcommand{\ent}{\mathcal{H}}
\newcommand{\sdots}{\,\cdot\,}
\newcommand{\func}{\mathbf{f}}

\newcommand{\ones}{\boldsymbol{1}}
\newcommand{\eye}{\boldsymbol{I}}
\newcommand{\zeros}{\boldsymbol{0}}

\newcommand{\sspace}{\mathcal{S}}
\newcommand{\aspace}{\mathcal{A}}
\newcommand{\state}{\mathbf{s}}
\newcommand{\sz}{{\state_0}}
\newcommand{\stm}{{\state_{t-1}}}
\newcommand{\st}{{\state_t}}
\newcommand{\sti}{{\state_t^{(i)}}}
\newcommand{\sT}{{\state_T}}
\newcommand{\stp}{{\state_{t+1}}}
\newcommand{\stpi}{{\state_{t+1}^{(i)}}}
\newcommand{\pdyn}{\density_\state}
\newcommand{\horizon}{T}
\newcommand{\action}{\mathbf{a}}
\newcommand{\az}{{\action_0}}
\newcommand{\atm}{{\action_{t-1}}}
\newcommand{\at}{{\action_t}}
\newcommand{\ati}{{\action_t^{(i)}}}
\newcommand{\atj}{{\action_t^{(j)}}}
\newcommand{\attildej}{{\tilde{\action}_t^{(j)}}}
\newcommand{\atij}{{\action_t^{(i,j)}}}
\newcommand{\atp}{{\action_{t+1}}}
\newcommand{\aT}{{\action_T}}
\newcommand{\atk}{{\action_t^{(k)}}}
\newcommand{\aTm}{\action_{\horizon-1}}
\newcommand{\opt}{^*}

\newcommand{\dataset}{\mathcal{D}}
\newcommand{\traj}{\tau}
\newcommand{\ptraj}{\density_\traj}
\newcommand{\visits}{\rho}  

\newcommand{\reward}{r}
\newcommand{\rz}{\reward_0}
\newcommand{\rt}{\reward_t}
\newcommand{\rti}{\reward^{(i)}_t}
\newcommand{\rmin}{r_\mathrm{min}}
\newcommand{\rmax}{r_\mathrm{max}}
\newcommand{\return}{\eta}




\newcommand{\V}{V}
\newcommand{\Vsoft}{V_\mathrm{soft}}
\newcommand{\Vsoftparams}{V_\mathrm{soft}^\qparams}
\newcommand{\Vhatsoftparams}{\hat V_\mathrm{soft}^\qparams}
\newcommand{\Vhatsoft}{\hat V_\mathrm{soft}}
\newcommand{\Vhard}{V^{\dagger}}
\newcommand{\Q}{Q}
\newcommand{\Qsoft}{Q_\mathrm{soft}}
\newcommand{\Qsoftparams}{Q_\mathrm{soft}^\qparams}
\newcommand{\Qhatsoft}{\hat Q_\mathrm{soft}}
\newcommand{\Qhatsoftparams}{\hat Q_\mathrm{soft}^{\bar\qparams}}
\newcommand{\Qhard}{Q^{\dagger}}
\newcommand{\A}{A}
\newcommand{\Asoft}{A_\mathrm{soft}}
\newcommand{\Asoftparams}{A_\mathrm{soft}^\qparams}
\newcommand{\Ahatsoft}{\hat A_\mathrm{soft}}

\newcommand{\energy}{\mathcal{E}}

\newcommand{\task}{\mathcal{T}}
\newcommand{\loss}{\mathcal{L}}
\newcommand{\data}{\mathcal{D}}
\newcommand{\inp}{\mathbf{x}}
\newcommand{\out}{\mathbf{y}}
\newcommand{\learner}{f}
\newcommand{\lossi}{\loss_{\task_i}}
\newcommand{\losst}{\loss_{\task}}
\newcommand{\buffer}{\mathcal{B}}

\newcommand{\ftml}{FTML }
\newcommand{\mdml}{MDML }

\newcommand{\cW}{\mathcal{W}}
\newcommand{\cM}{\mathcal{M}}
\newcommand{\cD}{\mathcal{D}}
\newcommand{\cP}{\mathcal{P}}
\newcommand{\cS}{\mathcal{S}}
\newcommand{\cX}{\mathcal{X}}
\newcommand{\cA}{\mathcal{A}}
\newcommand{\cT}{\mathcal{T}}
\newcommand{\cG}{\mathcal{G}}
\newcommand{\cR}{\mathcal{R}}
\newcommand{\cL}{\mathcal{L}}
\newcommand{\cO}{\mathcal{O}}
\newcommand{\cH}{\mathcal{H}}
\newcommand{\cB}{\mathcal{B}}
\newcommand{\cN}{\mathcal{N}}
\newcommand{\cF}{\mathcal{F}}

\newcommand{\bR}{\mathbb{R}}
\newcommand{\bE}{\mathbb{E}}
\newcommand{\bP}{\mathbb{P}}
\newcommand{\bT}{\mathbb{T}}

\newcommand{\Vpi}{V^{\pi}}
\newcommand{\Qpi}{Q^{\pi}}
\newcommand{\Api}{A^{\pi}}
\newcommand{\pith}{\pi_\theta}
\newcommand{\Vth}{\hat{V}_\theta}

\newcommand{\Vht}{\hat{V}}
\newcommand{\Vst}{V^*}
\newcommand{\piht}{\hat{\pi}}
\newcommand{\pist}{\pi^*}
\newcommand{\Vpiht}{V^{\hat{\pi}}}
\newcommand{\tauht}{\hat{\tau}}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{definition}{Definition}
\newtheorem{assumption}{Assumption}
\newtheorem{corollary}{Corollary}
\newtheorem{proposition}{Proposition}

\newcommand{\ftil}{\tilde{f}}
\newcommand{\wtil}{\tilde{w}}
\newcommand{\fht}{\hat{f}}



\DeclareMathOperator*{\argmin}{\mathrm{argmin}}

\newcommand{\param}{{\bm{\phi}}}               \newcommand{\paramspace}{\Phi}

\newcommand{\prior}{{\bm{\theta}}}               \newcommand{\priorspace}{\Theta}
\newcommand{\udparam}{\param}     \newcommand{\dparam}{{\param'}}             \newcommand{\mlprior}{\prior^*_{\mathrm{ML}}}
\newcommand{\fn}{\mathcal{L}}                  \newcommand{\udfn}{\tilde{\fn}}        \newcommand{\fnht}{\hat{\fn}}        \newcommand{\ud}{\alg}
\newcommand{\fnreg}{F^\lambda}
\newcommand{\dloss}{\ell}            \newcommand{\alg}{\mathcal{A}lg}
\newcommand{\alghat}{\alg^\delta}
\newcommand{\algwidehat}{\widehat{\alg}}
\newcommand{\algstar}{\mathcal{A}lg^\star}

\newcommand{\px}{\mathbf{u}}    \newcommand{\py}{\mathbf{v}}    \newcommand{\pz}{\mathbf{z}}    \newcommand{\step}{k} 
\newcommand{\udpx}{\tilde{\px}}
\newcommand{\udpy}{\tilde{\py}}

\newcommand{\eps}{\epsilon}
\newcommand{\grad}{\bm{d}}
\newcommand{\pgrad}{\nabla}

\newcommand{\datatr}{\data^{\mathrm{tr}}}
\newcommand{\datatest}{\data^{\mathrm{test}}}\clearpage{}
\graphicspath{{figures/}{../figures/}{./}{../../figures/}}

\hypersetup{
 colorlinks=True,
 linkcolor=blue,
 citecolor=blue,
 urlcolor=blue}

\newcommand{\ar}[1]{\textsf{\color{magenta} AR : #1}}
\newcommand{\sk}[1]{\textsf{\color{magenta} SK : #1}}
\newcommand{\cf}[1]{\textsf{\color{magenta} CF : #1}}

\makeatletter
\def\blfootnote{\xdef\@thefnmark{}\@footnotetext}
\makeatother

\title{Meta-Learning with Implicit Gradients}
\author{
	Aravind Rajeswaran$^{*,1}$ \hspace*{7pt} Chelsea Finn$^{*,2}$ \hspace*{7pt} Sham Kakade$^1$ \hspace*{7pt} Sergey Levine$^2$ \\[0.2cm]
	$^1$ University of Washington Seattle \hspace*{10pt} $^2$ University of California Berkeley
}

\begin{document}

\maketitle
\blfootnote{$^*$ Equal contributions. Project page: \url{http://sites.google.com/view/imaml}}

\begin{abstract}
A core capability of intelligent systems is the ability to quickly learn new tasks by drawing on prior experience. Gradient (or optimization) based meta-learning has recently emerged as an effective approach for few-shot learning. In this formulation, meta-parameters are learned in the outer loop, while task-specific models are learned in the inner-loop, by using only a small amount of data from the current task. A key challenge in scaling these approaches is the need to differentiate through the inner loop learning process, which can impose considerable computational and memory burdens. By drawing upon implicit differentiation, we develop the implicit MAML algorithm, which depends only on the solution to the inner level optimization and not the path taken by the inner loop optimizer. This effectively decouples the meta-gradient computation from the choice of inner loop optimizer. As a result, our approach is agnostic to the choice of inner loop optimizer and can gracefully handle many gradient steps without vanishing gradients or memory constraints.
Theoretically, we prove that implicit MAML can compute accurate meta-gradients with a memory footprint no more than that which is required to compute a single inner loop gradient and
at no overall increase in the total computational cost. Experimentally, we show that these benefits of implicit MAML translate into empirical gains on few-shot image recognition benchmarks.
\end{abstract}

\section{Introduction}
A core aspect of intelligence is the ability to quickly learn new tasks by drawing upon prior experience from related tasks. Recent work has studied how meta-learning algorithms~\cite{schmidhuber1987, thrun, naik} can acquire such a capability by learning to efficiently learn a range of tasks, thereby enabling learning of a new task with as little as a single example~\cite{mann,matchingnets,maml}. 
Meta-learning algorithms can be framed in terms of recurrent~\cite{hochreiter,mann,ravi2016optimization} or attention-based~\cite{matchingnets,mishra2017simple} models that are trained via a meta-learning objective, to essentially encapsulate the learned learning procedure in the parameters of a neural network.
An alternative formulation is to frame meta-learning as a bi-level optimization procedure~\cite{maclaurin2015gradient,maml}, where the ``inner'' optimization represents adaptation to a given task, and the ``outer'' objective is the meta-training objective. Such a formulation can be used to learn the initial parameters of a model such that optimizing from this initialization leads to fast adaptation and generalization. In this work, we focus on this class of optimization-based methods, and in particular the model-agnostic meta-learning (MAML) formulation~\cite{maml}. MAML has been shown to be as expressive as black-box approaches~\cite{universality}, is applicable to a broad range of settings~\cite{finn2017one,langauge_maml,AlShedivat2017ContinuousAV,ftml}, and recovers a convergent and consistent optimization procedure~\cite{finn2018learning}.

\begin{figure}[t!]
\centering
\includegraphics[width=0.99\linewidth]{figures/imaml8.png}
\caption{To compute the meta-gradient $\sum_i\frac{d\mathcal{L}_i(\phi_i)}{d\theta}$, the MAML algorithm differentiates through the optimization path, as shown in green, while first-order MAML computes the meta-gradient by approximating $\frac{d\param_i}{d\prior}$ as $\eye$. Our implicit MAML approach derives an analytic expression for the exact meta-gradient without differentiating through the optimization path by estimating local curvature.}
\label{fig:diagram}
\vspace*{-0.5cm}
\end{figure}

Despite its appealing properties, meta-learning an initialization requires backpropagation through the inner optimization process. As a result, the meta-learning process requires higher-order derivatives, imposes a non-trivial computational and memory burden, and can suffer from vanishing gradients. These limitations make it harder to scale optimization-based meta learning methods to tasks involving medium or large datasets, or those that require many inner-loop optimization steps. Our goal is to develop an algorithm that addresses these limitations. 




The main contribution of our work is the development of the implicit MAML~(iMAML) algorithm, an approach for optimization-based meta-learning with deep neural networks that removes the need for differentiating through the optimization path. Our algorithm aims to learn a set of parameters such that an optimization algorithm that is initialized at and regularized to this parameter vector leads to good generalization for a variety of learning tasks. By leveraging the implicit differentiation approach, we derive an analytical expression for the meta (or outer level) gradient that depends only on the solution to the inner optimization and not the path taken by the inner optimization algorithm, as depicted in Figure~1. This decoupling of meta-gradient computation and choice of inner level optimizer has a number of appealing properties.

First, the inner optimization path need not be stored nor differentiated through, thereby making implicit MAML memory efficient and scalable to a large number of inner optimization steps. Second, implicit MAML is agnostic to the inner optimization method used, as long as it can find an approximate solution to the inner-level optimization problem. This permits the use of higher-order methods, and in principle even non-differentiable optimization methods or components like sample-based optimization, line-search, or those provided by proprietary software (e.g.~Gurobi). Finally, we also provide the first (to our knowledge) non-asymptotic theoretical analysis of bi-level optimization. We show that an $\epsilon$--approximate meta-gradient can be computed via implicit MAML using $\tilde{O}(\log(1/\epsilon))$ gradient evaluations and $\tilde{O}(1)$ memory, meaning the memory required does not grow with number of gradient steps.



 \vspace{-0.25cm}
\section{Problem Formulation and Notations}
\vspace{-0.25cm}

We first present the meta-learning problem in the context of few-shot supervised learning, and then generalize the notation to aid the rest of the exposition in the paper.

\vspace{-0.2cm}
\subsection{Review of Few-Shot Supervised Learning and MAML} 
In this setting, we have a collection of meta-training tasks $\{ \task_i \}_{i=1}^M$ drawn from $P(\task)$. Each task~$\task_i$ is associated with a dataset $\data_i$, from which we can sample two disjoint sets: $\datatr_i$ and $\datatest_i$. These datasets each consist of $K$ input-output pairs. Let $\inp \in \mathcal{X}$ and $\out \in \mathcal{Y}$ denote inputs and outputs, respectively. The datasets take the form $\datatr_i = \{ (\inp_i^k, \out_i^k) \}_{k=1}^{K}$, and similarly for $\datatest_i$. 
We are interested in learning models of the form $h_\param(\inp): \mathcal{X} \rightarrow \mathcal{Y}$, parameterized by $\param \in \paramspace \equiv \bR^d$.
Performance on a task is specified by a loss function, such as the cross entropy or squared error loss. We will write the loss function in the form $\fn(\param, \data)$, as a function of a parameter vector and dataset. The goal for task $\task_i$ is to learn task-specific parameters $\param_i$ using $\datatr_i$ such that we can minimize the population or test loss of the task, $\fn(\param_i, \datatest_i)$.

In the general bi-level meta-learning setup, we consider a space of algorithms that compute task-specific parameters using a set of meta-parameters $\prior \in \priorspace \equiv \bR^d$ and the training dataset from the task, such that $\param_i = \alg(\prior, \datatr_i)$ for task $\task_i$. The goal of meta-learning is to learn meta-parameters that produce good task specific parameters after adaptation, as specified below:
\begin{equation}
    \label{eq:objective}
    \overbrace{ \mlprior := \argmin_{\prior \in \priorspace} F(\prior)}^{\mathrm{outer-level}} \, , 
    \textrm{ where } F(\prior) 
    = \frac{1}{M} \sum_{i=1}^M \ \fn \bigg( \overbrace{ \alg \big( \prior, \datatr_i \big) }^{\mathrm{inner-level}}, \ \datatest_i \bigg).
  \end{equation}
We view this as a bi-level optimization problem since we typically interpret $\alg \big( \prior, \datatr_i \big)$ as either explicitly or implicitly solving an underlying optimization problem.
At meta-test (deployment) time, when presented with a dataset $\datatr_j$ corresponding to a new task $\task_j \sim P(\task)$, we can achieve good generalization performance (i.e., low test error) by using the adaptation procedure with the meta-learned parameters as $\param_j = \alg(\mlprior, \datatr_j)$.

In the case of MAML~\cite{maml}, $\alg(\prior, \data)$ corresponds to
one or multiple steps of gradient descent initialized at $\prior$. For
example, if one step of gradient descent is used, we have:
\begin{equation}
    \label{eq:maml_gd}
  \param_i \equiv \alg(\prior, \datatr_i) = \prior - \alpha \nabla_\prior \loss(\prior,
\datatr_i).  \hspace*{15pt} \text{(inner-level of MAML)}
\end{equation}
Typically, $\alpha$ is a scalar hyperparameter, but can also be a learned vector~\cite{metasgd}. Hence, for MAML, the meta-learned parameter ($\mlprior$) has a learned inductive bias that is particularly well-suited for fine-tuning on tasks from $P(\task)$ using $K$ samples.
To solve the outer-level problem with gradient-based methods, we require a way to differentiate through $\alg$. In the case of MAML, this corresponds to backpropagating through the dynamics of gradient descent.


\vspace*{-0.1cm}
\subsection{Proximal Regularization in the Inner Level}
\vspace*{-0.1cm}
\label{sec:proximal_regularization}
To have sufficient learning in the inner level while also avoiding over-fitting, $\alg$ needs to incorporate some form of regularization. Since MAML uses a small number of gradient steps, this corresponds to early stopping and can be interpreted as a form of regularization and Bayesian prior~\cite{erin}. In cases like ill-conditioned optimization landscapes and medium-shot learning, we may want to take many gradient steps, which poses two challenges for MAML. First, we need to store and differentiate through the long optimization path of $\alg$, which imposes a considerable computation and memory burden. Second, the dependence of the model-parameters $\{ \param_i \}$ on the meta-parameters $(\prior)$ shrinks and vanishes as the number of gradient steps in $\alg$ grows, making meta-learning difficult.
To overcome these limitations, we consider a more explicitly regularized algorithm: 
\begin{equation}
    \label{eq:update_rule_supervised}
    \algstar(\prior, \datatr_i) = \underset{\dparam \in \paramspace}{\argmin}~\loss(\dparam, \datatr_i) + \frac{\lambda}{2}~||\dparam - \prior||^2.
  \end{equation}
\vspace*{-0.1cm}

The proximal regularization term in Eq.~\ref{eq:update_rule_supervised} encourages $\param_i$ to remain close to $\prior$, thereby retaining a strong dependence throughout. The regularization strength $(\lambda)$ plays a role similar to the learning rate $(\alpha)$ in MAML, controlling the strength of the prior~$(\prior)$ relative to the data~$(\datatr_\task)$. Like $\alpha$, the regularization strength $\lambda$ may also be learned. Furthermore, both $\alpha$ and $\lambda$ can be scalars, vectors, or full matrices. For simplicity, we treat $\lambda$ as a scalar hyperparameter.
In Eq.~\ref{eq:update_rule_supervised}, we use $\star$ to denote that the optimization problem is solved exactly. In practice, we  use iterative algorithms (denoted by $\alg$) for finite iterations, which return approximate minimizers. We explicitly consider the discrepancy between approximate and exact solutions in our analysis.

\vspace*{-0.1cm}
\subsection{The Bi-Level Optimization Problem} 
\vspace*{-0.1cm}

For notation convenience, we will sometimes express the dependence on
task $\task_i$ using a subscript instead of arguments, e.g.
we write:
\begin{eqnarray*}
  \fn_i(\param) := \fn \big(\param, \ \datatest_i \big), & 
  \fnht_i(\param) :=  \fn \big(\param, \datatr_i \big), &
\alg_i \big( \prior \big) :=  \alg \big( \prior, \datatr_i \big).
\end{eqnarray*}



With this notation, the bi-level meta-learning
problem can be written more generally as:   
\begin{equation}
\begin{aligned}
\label{eq:update_rule}
& \mlprior := \argmin_{\prior \in \priorspace} F(\prior) \, , 
\textrm{ where } F(\prior) 
= \frac{1}{M} \sum_{i=1}^M \ \fn_i \big( \algstar_i (\prior) \big), \text{ and} \\
& \algstar_i(\prior) := \underset{\dparam \in \paramspace}{\argmin} \ G_i(\dparam, \prior), \text{ where } G_i(\dparam, \prior) = \fnht_i(\dparam) + \frac{\lambda}{2}~||\dparam - \prior||^2.
\end{aligned}
\end{equation}

\subsection{Total and Partial Derivatives}

We use $\grad$ to denote the total derivative and $\pgrad$ to denote partial derivative. For nested function of the form $\fn_i(\param_i)$ where $\param_i=\alg_i(\prior)$, we
have from chain rule  
\begin{equation*}
\grad_\prior \fn_i(\alg_i(\prior))
= {\frac{d\alg_i(\prior)}{d\prior} \pgrad_\param \fn_i(\param)\mid_{\param=\alg_i(\prior)}}
= {\frac{d\alg_i(\prior)}{d\prior} \pgrad_\param \fn_i(\alg_i(\prior))}
\end{equation*}
Note the important distinction between $\grad_\prior
\fn_i(\alg_i(\prior))$ and $\pgrad_\param \fn_i(\alg_i(\prior))$. The former
passes derivatives through $\alg_i(\prior)$ while the latter does
not. $\pgrad_\param \fn_i(\alg_i(\prior))$ is simply the gradient
function, i.e. $\pgrad_\param \fn_i(\param)$, evaluated at
$\param=\alg_i(\prior)$. Also note that $\grad_\prior
\fn_i(\alg_i(\prior))$ and $\pgrad_\param \fn_i(\alg_i(\prior))$ are $d$--dimensional vectors, while $\frac{d\alg_i(\prior)}{d\prior}$ is a $(d \times d)$--size Jacobian matrix. Throughout this text, we will also use $\grad_\prior$ and
$\frac{d}{d\prior}$ interchangeably.  \section{The Implicit MAML Algorithm}

Our aim is to solve the bi-level meta-learning problem in Eq.~\ref{eq:update_rule} using an iterative gradient based algorithm of the form $\prior \leftarrow \prior - \eta \ \grad_\prior F(\prior)$. Although we derive our method based on standard gradient descent for simplicity, any other optimization method, such as quasi-Newton or Newton methods, Adam~\cite{adam}, or gradient descent with momentum can also be used without modification.
The gradient descent update be expanded using the chain rule as
\begin{equation}
    \label{eq:outer_update_rule}
    \prior \leftarrow \prior - \eta \ \frac{1}{M} \sum_{i=1}^M \frac{d \algstar_i (\prior)}{d \prior} \ \pgrad_\phi \fn_i(\algstar_i(\prior)).
\end{equation}
Here, $\pgrad_\param \fn_i(\algstar_i(\prior))$ is simply
$\pgrad_\param \fn_i(\param)\mid_{\param=\algstar_i(\prior)}$ which
can be easily obtained in practice via automatic differentiation. For
this update rule, we must compute
$\frac{d\algstar_i(\prior)}{d\prior}$, where $\algstar_i$ is
implicitly defined as an optimization
problem~(Eq.~\ref{eq:update_rule}), which presents the primary
challenge. We now present an efficient algorithm (in compute and memory) to compute the meta-gradient..

\subsection{Meta-Gradient Computation}
\label{sec:implicit_jacobian}
If $\algstar_i(\prior)$ is implemented as an iterative algorithm, such as gradient descent, then one way to compute $\frac{d\algstar_i(\prior)}{d\prior}$ is to propagate derivatives through the iterative process, either in forward mode or reverse mode. However, this has the drawback of depending explicitly on the path of the optimization, which has to be fully stored in memory, quickly becoming intractable when the number of gradient steps needed is large. Furthermore, for second order optimization methods, such as Newton's method, third derivatives are needed which are difficult to obtain. Furthermore, this approach becomes impossible when non-differentiable operations, such as line-searches, are used.
However, by recognizing that $\algstar_i$ is implicitly defined as the
solution to an optimization problem, we may employ a different
strategy that does not need to consider the path of the optimization
but only the final result. This is derived in the following Lemma.

\begin{lemma}
\label{lemma:alg_derivative}
(Implicit Jacobian) 
Consider $\algstar_i(\prior)$ as defined in Eq.~\ref{eq:update_rule} for task $\task_i$. Let $\param_i = \algstar_i(\prior)$ be the result of $\algstar_i(\prior)$. If $\left( \eye + \frac{1}{\lambda} \pgrad_\param^2 \fnht_i(\param_i) \right)$ is invertible, then the derivative Jacobian is
\begin{equation}
    \label{eq:alg_derivative}
    \frac{d \algstar_i(\prior)}{d \prior} = \left( \eye + \frac{1}{\lambda}~ \pgrad_\param^2 \fnht_i (\param_i) \right)^{-1}.
\end{equation}
\end{lemma}



Note that the derivative (Jacobian) depends only on the final result of the algorithm, and not the path taken by the algorithm. Thus, in principle any approach of algorithm can be used to compute $\algstar_i(\prior)$, thereby decoupling meta-gradient computation from choice of inner level optimizer.


\begin{algorithm}[t!]
   \caption{Implicit Model-Agnostic Meta-Learning (iMAML)}
   \label{alg:iMAML}
\begin{algorithmic}[1]
\STATE {\bf Require:} Distribution over tasks $P(\task)$, outer step size $\eta$, regularization strength $\lambda$, 
\WHILE{not converged}
    \STATE Sample mini-batch of tasks $\{ \task_i \}_{i=1}^B \sim P(\task)$
    \FOR{Each task $\task_i$}
        \STATE Compute task meta-gradient $\bm{g}_i=$~\texttt{Implicit-Meta-Gradient}$(\task_i, \prior, \lambda)$
    \ENDFOR
    \STATE Average above gradients to get $\hat{\pgrad} F(\prior) = (1/B) \sum_{i=1}^B \bm{g}_i$
    \STATE Update meta-parameters with gradient descent: $\prior \leftarrow \prior - \eta \hat{\pgrad} F(\prior)$ \ \ //~\textit{(or Adam)}
\ENDWHILE
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[t!]
   \caption{Implicit Meta-Gradient Computation}
   \label{alg:implicit_grad}
\begin{algorithmic}[1]
\STATE {\bf Input:} Task $\task_i$, meta-parameters $\prior$, regularization strength $\lambda$
\STATE {\bf Hyperparameters:} Optimization accuracy thresholds $\delta$ and $\delta'$
\STATE Obtain task parameters $\param_i$ using iterative optimization solver such that:
$
\|\param_i- \algstar_i(\prior)\| \leq \delta
$
\STATE Compute partial outer-level gradient $\bm{v}_i=\pgrad_\param \fn_\task(\param_i)$
\STATE Use an iterative solver (e.g. CG) along with  reverse mode differentiation (to compute Hessian vector products) to compute $\bm{g}_i$ such that: 
$
\|\bm{g}_i - \big( \eye + \frac{1}{\lambda} \pgrad^2 \fnht_i(\param_i) \big)^{-1} \bm{v}_i\|\leq \delta'
$
\STATE {\bf Return:} $\bm{g}_i$
\end{algorithmic}
\end{algorithm}


\textbf{Practical Algorithm:} While Lemma~\ref{lemma:alg_derivative} provides an idealized way to compute the $\algstar_i$ Jacobians and thus by extension the meta-gradient, it may be difficult to directly use it in practice. Two issues are particularly relevant. First, the meta-gradients require computation of $\algstar_i(\prior)$, which is the exact solution to the inner optimization problem. In practice, we may be able to obtain only approximate solutions. Second, explicitly forming and inverting the matrix in Eq.~\ref{eq:alg_derivative} for computing the Jacobian may be intractable for large deep neural networks. To address these difficulties, we consider approximations to the idealized approach that enable a practical algorithm.

First, we consider an approximate solution to the inner optimization
problem, that can be obtained with iterative optimization algorithms
like gradient descent.  
\begin{definition}
\label{def:delta_approx_alg}
($\delta$--approx. algorithm)
Let $\alg_i(\prior)$ be a $\delta$--accurate approximation of $\algstar_i(\prior)$, i.e.
\[
\| \alg_i(\prior) - \algstar_i(\prior) \| \leq \delta
\]
\end{definition}

Second, we will perform a partial or approximate matrix inversion given by:
\begin{definition}
\label{def:delta_approx_inversion}
($\delta'$--approximate Jacobian-vector product) Let $\bm{g}_i$ be a vector such that
\[
\| \bm{g}_i - \bigg(\eye + \frac{1}{\lambda}~\pgrad_\param^2 \fnht_i(\param_i) \bigg)^{-1} \pgrad_\param \fn_i(\param_i) \| \leq \delta'
\]
where $\param_i = \alg_i(\prior)$ and $\alg_i$ is based on definition~\ref{def:delta_approx_alg}.
\end{definition}

Note that $\bm{g}_i$ in definition~\ref{def:delta_approx_inversion} is
an approximation of the meta-gradient for task $\task_i$. Observe that $\bm{g}_i$ can be obtained as an approximate solution to the optimization problem:
\begin{equation}\label{eq:sub_problem}
\min_{\bm{w}} \ \ \bm{w}^\top \bigg(\eye + \frac{1}{\lambda}~\pgrad_\param^2 \fnht_i(\param_i) \bigg) \bm{w} - \bm{w}^\top \pgrad_\param \fn_i(\param_i)
\end{equation}
The conjugate gradient (CG) algorithm is particularly well suited for this problem due to its excellent iteration complexity and requirement of only Hessian-vector products of
the form $\pgrad^2 \fnht_i(\param_i) \bm{v} $. Such hessian-vector products can be obtained cheaply without explicitly forming or storing the Hessian matrix (as we discuss in Appendix~\ref{sec:hvp}).
This CG
based inversion has been successfully deployed in Hessian-free or
Newton-CG methods for deep
learning~\cite{Martens2010DeepLV,NocedalBook} and trust region methods
in reinforcement
learning~\cite{trpo,Rajeswaran17nips}. Algorithm~\ref{alg:iMAML}
presents the full practical algorithm. Note that these approximations
to develop a practical algorithm introduce errors in the meta-gradient
computation. We analyze the impact of these errors in
Section~\ref{sec:analysis} and show that they are controllable. See Appendix~\ref{app:other_algs} for how iMAML generalizes prior gradient optimization based meta-learning algorithms.


\subsection{Theory}
\label{sec:analysis}
In Section~\ref{sec:implicit_jacobian}, we outlined a practical algorithm that makes approximations to the idealized update rule of Eq.~\ref{eq:outer_update_rule}. Here, we attempt to analyze the impact of these approximations, and also understand the computation and memory requirements of iMAML. We find that iMAML can match the minimax computational complexity of backpropagating through the path of the inner optimizer, but is substantially better in terms of memory usage. This work to our knowledge also provides the first non-asymptotic result that analyzes approximation error due to implicit gradients. Theorem~\ref{thm:approx_error} provides the computational and memory complexity for obtaining an $\epsilon$--approximate meta-gradient. We assume $\fn_i$ is smooth but do not require it to be convex. We assume that $G_i$ in Eq.~\ref{eq:update_rule} is strongly convex, which can be
made possible by appropriate choice of $\lambda$. The key to our analysis is a second order Lipshitz assumption, i.e. $\fnht_i (\cdot)$
is $\rho$-Lipshitz Hessian. This assumption and setting has received
considerable attention in recent optimization and deep learning
literature~\cite{Jin2017HowTE, Nesterov2006CubicRO}. 

Table~\ref{table:compare} summarizes our complexity results and compares with MAML and
truncated backpropagation~\cite{Shaban2018TruncatedBF} through the path of the inner optimizer. We
use $\kappa$ to denote the condition number of the inner problem
induced by $G_i$ (see Equation~\ref{eq:update_rule}), which can be
viewed as a measure of hardness of the inner optimization
problem. $\textrm{Mem}({\pgrad \fnht_i})$ is the memory taken to compute
a single derivative $\pgrad \fnht_i$. Under the assumption that
Hessian vector products are computed with the reverse mode of
autodifferentiation, we will have that both:
the compute time and memory used for computing a Hessian vector product
are with a (universal) constant factor of the compute time
and memory used for computing $\pgrad \fnht_i$ itself
(see Appendix~\ref{sec:hvp}). This allows us to measure
the compute time in terms of the number of $\pgrad \fnht_i$
computations. We refer readers to Appendix~\ref{sec:compute_memory_discussion} for additional discussion about the algorithms and their trade-offs.


\iffalse
The table refers to two now define our notions of error. Let $\bm{g}_i$ be the computed meta-gradient for task $\task_i$. We define two notions of error:

\begin{definition}
\label{def:exact_error}
Exact-solve error (our notion of error): Our goal
is to accurately compute the
gradient of $F(\theta)$ as defined in Equation~\ref {eq:update_rule},
where $\algstar_i(\theta)$ is an exact algorithm. Specifically, we seek to compute a $\bm{g}_i$ such that:
\[
\| \bm{g}_i - \grad_\prior \fn_i(\algstar_i(\prior)) \| \leq \eps
\]
where $\eps$ is the error in the gradient computation.
\end{definition}

\begin{definition}
\label{def:approx_error}
Approx-solve error: Here we suppose that $\alg_i$ computes a $\delta$--accurate solution to the inner optimization problem over $G_i$ in Eq.~\ref{eq:update_rule}, i.e. that $\alg_i$ satisfies $\| \alg_i(\prior) - \algstar_i(\prior) \| \leq \delta$, as per definition~\ref{def:delta_approx_alg}. Then the objective is to compute a $\bm{g}$ such that:
\[
\| \bm{g} - \grad_\prior \fn_i(\alg_i(\prior)) \| \leq \eps
\]
where $\eps$ is the error in the gradient computation of $\grad_\prior \fn_i(\alg_i(\prior))$. Subtly, note that the gradient is with respect to the $\delta$-approximate algorithm, as opposed to using $\algstar_i$.
\end{definition}

We now summarize the table: We assume that MAML invokes $\alg_i$ to get a $\delta$-approximate solution for inner problem. The exact-solve
error for MAML is not known in the literature; in particular, even as
$\delta\rightarrow 0$ it is not evident if the approx-solve solution
tends to the exact-solve solution, unless further regularity
conditions are imposed. The approx-solve error for MAML is exactly $0$
(ignoring finite-precision and numerical issues) since it
backpropagates through the path. Truncated
backprop~\cite{Shaban2018TruncatedBF} also invokes $\alg_i$ to obtain a $\delta$-approximate solution but instead performs a truncated or partial back-propagation so that it uses a smaller number of
iterations when computing the gradient through the path of
$\alg_i(\prior)$. Exact-solve error for truncated backprop is also not
known, but a small approx-solve error can be obtained with less memory
than full back-prop. We use Prop 3.1 of Shaban et al.~\cite{Shaban2018TruncatedBF} to provide a guarantee that leads to an
$\epsilon$--accurate approximation of the full-backprop (i.e. MAML)
gradient. It is not evident how accurate the truncated procedure is
when an accelerated method is used instead. Finally, our iMAML
algorithm also invokes an approximate solver $\alg_i$ rather than $\algstar_i$. However, importantly, we guarantee a
small exact-solve error even though we do not require access to
$\algstar_i$. Furthermore, the iMAML algorithm also requires substantially less
memory. Up to small constant factors, it only utilizes the memory required for computing a single
gradient of $\fnht_i(\cdot)$.
\fi

\begin{table}[t!]
\caption{\label{table:compare}\footnotesize Compute and memory for computing the
  meta-gradient when using a $\delta$--accurate $\alg_i$, and the
  corresponding approximation error. Our compute time is measured in
  terms of the number of $\pgrad \fnht_i$ computations. All results
  are in $\tilde O(\cdot)$ notation, which hide additional log factors; the error bound hides additional problem dependent Lipshitz and smoothness  parameters (see the respective Theorem statements). 
$\kappa \geq 1$ is the condition number for inner objective $G_i$ (see Equation~\ref{eq:update_rule}), and $D$ is the diameter of the search
space.
The notions
of error are subtly different: we assume all methods solve the inner
optimization to error level of $\delta$ (as per definition~\ref{def:delta_approx_alg}).  For our algorithm, the error refers to the $\ell_2$ error in the computation of $\grad_\prior \fn_i(\algstar_i(\prior)) $. For the other algorithms, the 
error refers to the $\ell_2$ error in the computation of $\grad_\prior
\fn_i(\alg_i(\prior)) $.
We use Prop 3.1 of Shaban et al.~\cite{Shaban2018TruncatedBF} to
provide the guarantee we use. See Appendix~\ref{sec:compute_memory_discussion} for additional discussion.
}
\begin{center}
\footnotesize
\renewcommand{\arraystretch}{1.5}
\begin{tabular}{|c|c|c|c|}
  \hline
Algorithm & Compute & Memory & Error \\ \hline
MAML (GD + full back-prop)  & $\kappa \log \left( \frac{D}{\delta} \right)$    & $\textrm{Mem}({\pgrad \fnht_i})\cdot \kappa \  \log \left( \frac{D}{\delta} \right) $      & $0$  \\ \hline
MAML (Nesterov's AGD + full back-prop)  & $ \sqrt{\kappa} \log \left( \frac{D}{\delta} \right) $    & $\textrm{Mem}({\pgrad \fnht_i})\cdot \sqrt{\kappa} \  \log \left( \frac{D}{\delta} \right) $      & $0$  \\ \hline
Truncated back-prop~\cite{Shaban2018TruncatedBF} (GD)  & $ \kappa \log \left( \frac{D}{\delta} \right) $    & $\textrm{Mem}({\pgrad \fnht_i})\cdot \kappa \  \log \left( \frac{1}{\color{black}{\epsilon}} \right) $      & $\color{black}{\epsilon}$ \\ \hline
Implicit MAML (this work)  &  ${\color{blue} \sqrt{\kappa} \log \left( \frac{D}{\delta} \right)} $       & $\color{blue}{\textrm{Mem}({\pgrad \fnht_i})}$ 
& $\color{blue}{\delta} $ \\ \hline
\end{tabular}
\end{center}

\end{table}


Our main theorem is as follows:

\begin{theorem}
\label{thm:approx_error}
(Informal Statement; Approximation error in Algorithm~\ref{alg:implicit_grad})
Suppose that: $\fn_i(\cdot)$ is $B$ Lipshitz and $L$ smooth function; that $G_i(\cdot,\prior)$ (in
Eq.~\ref{eq:update_rule}) is a $\mu$-strongly convex function with
condition number $\kappa$; that $D$ is the diameter of search space for
$\param$ in the inner optimization problem (i.e. $\|\algstar_i(\prior)
\|\leq D$);  and $\fnht_i (\cdot)$ is $\rho$-Lipshitz Hessian.

Let $\bm{g}_i$ be the task meta-gradient returned by
Algorithm~\ref{alg:implicit_grad}. For any task $i$ and desired
accuracy level $\epsilon$, Algorithm~\ref{alg:implicit_grad} computes
an approximate task-specific meta-gradient with the following guarantee:
\[
  ||\bm{g}_i - \grad_\prior \fn_i(\algstar_i(\prior))|| \leq \epsilon\, .
\]
Furthermore, under the assumption that the Hessian
vector products are computed by the reverse mode of
autodifferentiation (Assumption~\ref{assumption:HVP}),  Algorithm~\ref{alg:implicit_grad} can be implemented using at most $\tilde{O}\left( \sqrt{\kappa} \log \left(
\frac{\textrm{poly}(\kappa,D,B,L,\rho,\mu,\lambda)}{\epsilon}
\right) \right)$ gradient computations of $\fnht_i (\cdot) $ and using
at most $2\cdot \mathrm{Mem}(\pgrad \fnht_i)$ memory.
\end{theorem}

The formal statement of the theorem and the proof are provided the
appendix. Importantly, the algorithm's memory requirement is
equivalent to the memory needed for Hessian-vector products which is a
small constant factor over the memory required for gradient
computations, assuming the reverse mode of
auto-differentiation is used. 
Finally, the next corollary shows that iMAML efficiently finds a
stationary point of $F(\cdot)$, due to iMAML having 
controllable exact-solve error.

\begin{corollary} (iMAML finds stationary points)
Suppose the conditions of Theorem~\ref{thm:approx_error} hold and that
$F(\cdot)$ is an $L_F$ smooth function. Then
the implicit MAML algorithm (Algorithm~\ref{alg:iMAML}), when the
batch size is $M$ (so that we are doing gradient descent), will find a
point $\prior$ such that:
\[
\|\nabla F(\prior) \| \leq \eps
\]
in a number of calls to \texttt{Implicit-Meta-Gradient} that is at
most $\frac{4M L_f (F(0) - \min_\prior F(\prior))}{\eps^2}$.
Furthermore, the total number of gradient computations (of $\pgrad
\fnht_i$) is  at most $\tilde{O}\left( M \sqrt{\kappa} \frac{L_f (F(0) -
\min_\theta F(\theta))}{\eps^2} \log \left(
\frac{\textrm{poly}(\kappa,D,B,L,\rho,\mu,\lambda)}{\epsilon}
\right) \right)$, and only $\tilde{O}(\mathrm{Mem}(\pgrad \fnht_i))$ memory is required throughout.
\end{corollary}
 \section{Experimental Results and Discussion}
\label{sec:experiments}
In our experimental evaluation, we aim to answer the following questions empirically: (1) Does the iMAML algorithm asymptotically compute the exact meta-gradient? (2) With finite iterations, does iMAML approximate the meta-gradient more accurately compared to MAML? (3) How does the computation and memory requirements of iMAML compare with MAML? (4) Does iMAML lead to better results in realistic meta-learning problems?
We have answered (1) - (3) through our theoretical analysis, and now attempt to validate it through numerical simulations. For (1) and (2), we will use a simple synthetic example for which we can compute the exact meta-gradient and compare against it (exact-solve error, see definition~\ref{def:exact_error}). For (3) and (4), we will use the common few-shot image recognition domains of Omniglot and Mini-ImageNet.



To study the question of meta-gradient accuracy, Figure~\ref{fig:experiments} considers a synthetic regression example, where the predictions are linear in parameters. This provides an analytical expression for $\algstar_i$ allowing us to compute the true meta-gradient. We fix gradient descent~(GD) to be the inner optimizer for both MAML and iMAML. The problem is constructed so that the condition number $(\kappa)$ is large, thereby necessitating many GD steps. We find that both iMAML and MAML asymptotically match the exact meta-gradient, but iMAML computes a better approximation in finite iterations. 
We observe that with 2 CG iterations, iMAML incurs a small terminal error. This is consistent with our theoretical analysis. In Algorithm~\ref{alg:implicit_grad}, $\delta$ is dominated by $\delta'$ when only a small number of CG steps are used. However, the terminal error vanishes with just 5 CG steps. The computational cost of 1 CG step is comparable to 1 inner GD step with the MAML algorithm, since both require 1 hessian-vector product (see section~\ref{sec:hvp} for discussion). Thus, the computational cost as well as memory of iMAML with 100 inner GD steps is significantly smaller than MAML with 100 GD steps.



To study (3), we turn to the Omniglot dataset~\cite{omniglot} which is a popular few-shot image recognition domain. 
Figure~\ref{fig:experiments} presents compute and memory trade-off for MAML and iMAML (on 20-way, 5-shot Omniglot). Memory for iMAML is based on Hessian-vector products and is independent of the number of GD steps in the inner loop. The memory use is also independent of the number of CG iterations, since the intermediate computations need not be stored in memory. On the other hand, memory for MAML grows linearly in grad steps, reaching the capacity of a 12 GB GPU in approximately 16 steps. First-order MAML (FOMAML) does not back-propagate through the optimization process, and thus the computational cost is only that of performing gradient descent, which is needed for all the algorithms. 
The computational cost for iMAML is also similar to FOMAML along with a constant overhead for CG that depends on the number of CG steps. Note however, that FOMAML does not compute an accurate meta-gradient, since it ignores the Jacobian. Compared to FOMAML, the compute cost of MAML grows at a faster rate. FOMAML requires only gradient computations, while backpropagating through GD (as done in MAML) requires a Hessian-vector products at each iteration, which are more expensive.


\begin{figure}[b!]
    \centering
    \begin{subfigure}[b]{0.3\textwidth}
         \centering
         \includegraphics[width=\textwidth]{figures/grad_err_4.png} \\
         (a)
    \end{subfigure}
    \hspace*{10pt}
    \begin{subfigure}[b]{0.63\textwidth}
         \centering
         \includegraphics[width=\textwidth]{figures/compute_memory_4.png} \\
         (b)
    \end{subfigure}
    \caption{\footnotesize Accuracy, Computation, and Memory tradeoffs of iMAML, MAML, and FOMAML. (a) Meta-gradient accuracy level in synthetic example. Computed gradients are compared against the exact meta-gradient per Def~\ref{def:exact_error}. (b) Computation and memory trade-offs with 4 layer CNN on 20-way-5-shot Omniglot task. We implemented iMAML in PyTorch, and for an apples-to-apples comparison, we use a PyTorch implementation of MAML from: \url{https://github.com/dragen1860/MAML-Pytorch}}
    \label{fig:experiments}
\end{figure}

Finally, we study empirical performance of iMAML on the Omniglot and Mini-ImageNet domains.
Following the few-shot learning protocol in prior work~\cite{matchingnets}, we run the iMAML algorithm on the dataset for different numbers of class labels and shots (in the N-way, K-shot setting), and compare two variants of iMAML with published results of the most closely related algorithms: MAML, FOMAML, and Reptile. While these methods are not state-of-the-art on this benchmark, they provide an apples-to-apples comparison for studying the use of implicit gradients in optimization-based meta-learning. For a fair comparison, we use the identical convolutional architecture as these prior works. Note however that architecture tuning can lead to better results for all algorithms~\cite{autometa}.

The first variant of iMAML we consider involves solving the inner level problem (the regularized objective function in Eq.~\ref{eq:update_rule}) using gradient descent. The meta-gradient is computed using conjugate gradient, and the meta-parameters are updated using Adam. This presents the most straightforward comparison with MAML, which would follow a similar procedure, but backpropagate through the path of optimization as opposed to invoking implicit differentiation.
The second variant of iMAML uses a second order method for the inner level problem. In particular, we consider the Hessian-free or Newton-CG~\cite{NocedalBook, Martens2010DeepLV} method. This method makes a local quadratic approximation to the objective function (in our case, $G(\dparam, \prior)$ and approximately computes the Newton search direction using CG. Since CG requires only Hessian-vector products, this way of approximating the Newton search direction is scalable to large deep neural networks. 
The step size can be computed using regularization, damping, trust-region, or linesearch. We use a linesearch on the training loss in our experiments to also illustrate how our method can handle non-differentiable inner optimization loops. We refer the readers to Nocedal \& Wright~\cite{NocedalBook} and Martens~\cite{Martens2010DeepLV} for a more detailed exposition of this optimization algorithm. Similar approaches have also gained prominence in reinforcement learning~\cite{trpo, Rajeswaran17nips}.

\begin{table}[t!]
\label{table:omniglot_results}
\begin{center}
\caption{\footnotesize Omniglot results. MAML results are taken from the original work of Finn et al.~\cite{maml}, and first-order MAML and Reptile results are from Nichol et al.~\cite{nichol2018first}. iMAML with gradient descent (GD) uses 16 and 25 steps for 5-way and 20-way tasks respectively. iMAML with Hessian-free uses 5 CG steps to compute the search direction and performs line-search to pick step size. Both versions of iMAML use $\lambda=2.0$ for regularization, and 5 CG steps to compute the task meta-gradient.}  \vspace*{5pt}
\footnotesize
\renewcommand{\arraystretch}{1.1}
\begin{tabular}{l|c|c|c|c}
\toprule
Algorithm    & 5-way 1-shot     & 5-way 5-shot   & 20-way 1-shot  & 20-way 5-shot  \\ \midrule
MAML~\cite{maml}        & 98.7 $\pm$ 0.4\% & \textbf{99.9 $\pm$ 0.1\%}   & 95.8 $\pm$ 0.3\%   & 98.9 $\pm$ 0.2\%   \\ \hline
first-order MAML~\cite{maml}       & 98.3 $\pm$ 0.5\%     & 99.2 $\pm$ 0.2\%   & 89.4 $\pm$ 0.5\%   & 97.9 $\pm$ 0.1\%   \\ \hline
Reptile~\cite{nichol2018first}      & 97.68 $\pm$ 0.04\%   & 99.48 $\pm$ 0.06\% & 89.43 $\pm$ 0.14\% & 97.12 $\pm$ 0.32\% \\ \hline
iMAML, GD (ours) & 99.16 $\pm$ 0.35\% & 99.67 $\pm$ 0.12\% & 94.46 $\pm$ 0.42\%  & 98.69 $\pm$ 0.1\%  \\ \hline
iMAML, Hessian-Free (ours) & \textbf{99.50 $\pm$ 0.26\%}    & 99.74 $\pm$ 0.11\% & \textbf{96.18 $\pm$ 0.36\%} & \textbf{99.14 $\pm$ 0.1\%}  \\ \bottomrule
\end{tabular}
\end{center}
\vspace{-0.1cm}
\end{table}

\begin{wraptable}{r}{0.45\textwidth}
\label{table:imagenet_results}
\centering
\caption{\footnotesize Mini-ImageNet 5-way-1-shot accuracy}
\begin{tabular}{l|c}
\toprule
Algorithm    & 5-way 1-shot   \\ \midrule
MAML & 48.70 $\pm$ 1.84 \%  \\
first-order MAML & 48.07 $\pm$ 1.75 \% \\
Reptile & 49.97 $\pm$ 0.32 \% \\
iMAML GD (ours) &  48.96 $\pm$ 1.84 \% \\
iMAML HF (ours) &  49.30 $\pm$ 1.88 \% \\
\bottomrule
\end{tabular}
\label{table:imagenet}
\end{wraptable}
Tables~2~and~3 present the results on Omniglot and Mini-ImageNet, respectively. On the Omniglot domain, we find that the GD version of iMAML is competitive with the full MAML algorithm, and substatially better than its approximations (i.e., first-order MAML and Reptile), especially for the harder 20-way tasks. We also find that iMAML with Hessian-free optimization performs substantially better than the other methods, suggesting that powerful optimizers in the inner loop can offer benifits to meta-learning. In the Mini-ImageNet domain, we find that iMAML performs better than MAML and FOMAML. We used $\lambda=0.5$ and $10$ gradient steps in the inner loop. We did not perform an extensive hyperparameter sweep, and expect that the results can improve with better hyperparameters. $5$ CG steps were used to compute the meta-gradient. The Hessian-free version also uses $5$ CG steps for the search direction. Additional experimental details are Appendix~\ref{app:experiments}.


 

\vspace{-0.1cm}
\section{Related Work}
\vspace{-0.1cm}

Our work considers the general meta-learning problem~\cite{schmidhuber1987, thrun, naik}, including few-shot learning~\cite{omniglot,matchingnets}. Meta-learning approaches can generally be categorized into metric-learning approaches that learn an embedding space where non-parametric nearest neighbors works well~\cite{siameseoneshot,matchingnets,snell2017prototypical,oreshkin2018tadam,allen2019infinite}, black-box approaches that train a recurrent or recursive neural network to take datapoints as input and produce weight updates~\cite{hochreiter,andrychowicz2016learning,li2016learning,ravi2016optimization} or predictions for new inputs~\cite{mann,rl2,learningrl,munkhdalai2017meta,mishra2017simple}, and optimization-based approaches that use bi-level optimization to embed learning procedures, such as gradient descent, into the meta-optimization problem~\cite{maml,finn2018learning,bertinetto2018meta,zintgraf2018caml,metasgd,finn2018probabilistic,zhou2018deep,harrison2018meta}. Hybrid approaches have also been considered to combine the benefits of different approaches~\cite{rusu2018meta,triantafillou2019meta}.
We build upon optimization-based approaches, particularly the MAML algorithm~\cite{maml}, which meta-learns an initial set of parameters such that gradient-based fine-tuning leads to good generalization. 
Prior work has considered a number of inner loops, ranging from a very general setting where all parameters are adapted using gradient descent~\cite{maml}, to more structured and specialized settings, such as ridge regression~\cite{bertinetto2018meta}, Bayesian linear regression~\cite{harrison2018meta}, and simulated annealing~\cite{alet2018modular}.
The main difference between our work and these approaches is that we show how to analytically derive the gradient of the outer objective without differentiating through the inner learning procedure. 

Mathematically, we view optimization-based meta-learning as a bi-level optimization problem. Such problems have been studied in the context of few-shot meta-learning (as discussed previously), gradient-based hyperparameter optimization~\cite{maclaurin2015gradient, pedregosa2016hyperparameter, franceschi2017forward, domke2012, Do2007EfficientMH}, and a range of other settings~\cite{amos2017optnet,landry2019differentiable}. Some prior works have derived implicit gradients for related problems~\cite{pedregosa2016hyperparameter, domke2012, amos2017optnet} while others propose innovations to aid back-propagation through the optimization path for specific algorithms~\cite{maclaurin2015gradient, franceschi2017forward,Hascot2006EnablingUC}, or approximations like truncation~\cite{Shaban2018TruncatedBF}. While the broad idea of implicit differentiation is well known, it has not been empirically demonstrated in the past for learning more than a few parameters (e.g., hyperparameters), or highly structured settings such as quadratic programs~\cite{amos2017optnet}. In contrast, our method meta-trains deep neural networks with thousands of parameters.
Closest to our setting is the recent work of Lee et al.~\cite{lee2019meta}, which uses implicit differentiation for quadratic programs in a final SVM layer. In contrast, our formulation allows for adapting the full network for generic objectives (beyond hinge-loss), thereby allowing for wider applications. 

We also note that prior works involving implicit differentiation make a strong assumption of an exact solution in the inner level, thereby providing only asymptotic guarantees. In contrast, we provide finite time guarantees which allows us to analyze the case where the inner level is solved approximately. In practice, the inner level is likely to be solved using iterative optimization algorithms like gradient descent, which only return approximate solutions with finite iterations. Thus, this paper places implicit gradient methods under a strong theoretical footing for practically use.






\iffalse
\section{Related Work}
Our work builds on the literature of meta-learning and applies it to the problem of few-shot learning. The algorithmic tools we develop build upon the approach of implicit differentiation. We summarize the main connections to these threads of work below.


\textbf{Meta learning and few-shot learning.} \ 
Our work considers the general meta-learning problem~\cite{schmidhuber1987, thrun, naik}, including few-shot learning~\cite{omniglot,matchingnets}. Meta-learning approaches can generally be categorized into (a) metric-learning approaches that learn an embedding space where non-parametric nearest neighbors works well~\cite{siameseoneshot,matchingnets,snell2017prototypical,oreshkin2018tadam,allen2019infinite}, (b)~black-box approaches that train a recurrent or recursive neural network to take datapoints as input and produce weight updates~\cite{hochreiter,andrychowicz2016learning,li2016learning,ravi2016optimization} or predictions for new inputs~\cite{mann,rl2,learningrl,munkhdalai2017meta,mishra2017simple}, and (c)~optimization-based approaches that use bi-level optimization to embed learning procedures, such as gradient descent, into the meta-optimization problem~\cite{maml,finn2018learning,bertinetto2018meta,zintgraf2018caml}. Hybrid approaches have also been considered to combine the benefits of different approaches~\cite{rusu2018meta,triantafillou2019meta}.


\textbf{Optimization based meta-learning methods} \
We build upon optimization-based approaches, particularly the MAML algorithm~\cite{maml}, which meta-learns an initial set of parameters such that gradient-based fine-tuning leads to good generalization. 
For optimization-based, MAML-like approaches, the inner optimization can operate on all parameters~\cite{maml,metasgd,finn2018probabilistic} or a subset thereof~\cite{zintgraf2018caml,zhou2018deep,harrison2018meta}.
We address the former setting, though our method can be trivially extended to the latter case.
Prior work has considered a number of inner loops, ranging from a very general setting where all parameters are adapted using gradient descent~\cite{maml}, to more structured and specialized settings, such as ridge regression~\cite{bertinetto2018meta}, Bayesian linear regression~\cite{harrison2018meta}, and simulated annealing~\cite{alet2018modular}.
The main difference between our work and these approaches is that we show how to analytically derive the gradient of the outer objective without differentiating through the inner learning procedure. 


\textbf{Bilevel optimization and implicit differentiation} \
Mathematically, we view optimization-based meta-learning as a bi-level optimization problem. Such problems have been studied in the context of few-shot meta-learning (as discussed previously), gradient-based hyperparameter optimization~\cite{maclaurin2015gradient, pedregosa2016hyperparameter, franceschi2017forward, domke2012, Do2007EfficientMH}, and a range of other settings~\cite{amos2017optnet,landry2019differentiable}. Some prior works have derived implicit gradients for related problems~\cite{pedregosa2016hyperparameter, domke2012, amos2017optnet} while others propose innovations to aid back-propagation through the optimization path for specific algorithms~\cite{maclaurin2015gradient, franceschi2017forward,Hascot2006EnablingUC}, or approximations like truncation~\cite{Shaban2018TruncatedBF}. While the broad idea of implicit differentiation is well known, it has not been empirically demonstrated in the past for learning more than a few parameters (e.g., hyperparameters), or highly structured settings such as quadratic programs~\cite{amos2017optnet}. In contrast, our goal is to leverage implicit differentiation for meta-learning with large deep neural network models to alleviate difficulties associated with optimizing through the path of an iterative algorithm.
Closest to our setting is the recent work of Lee et al.~\cite{lee2019meta}, which uses implicit differentiation for quadratic programs in a final SVM layer. In contrast, our formulation allows for adapting the full network for generic objectives (beyond hinge-loss), thereby allowing for wider applications beyond classification. 

We also note that prior works involving implicit differentiation make a strong assumption of an exact solution in the inner level, thereby providing only asymptotic guarantees. In contrast, we provide finite time guarantees which allows us to analyze the case where the inner level is solved approximately. In practice, the inner level is likely to be solved using iterative optimization algorithms like gradient descent, which only return approximate solutions with finite iterations. Thus, this paper places implicit gradient methods under a strong theoretical footing for practically use.
\fi 
\section{Conclusion}

In this paper, we develop a method for optimization-based meta-learning that removes the need for differentiating through the inner optimization path, allowing us to decouple the outer meta-gradient computation from the choice of inner optimization algorithm. We showed how this gives us significant gains in compute and memory efficiency, and also conceptually allows us to use a variety of inner optimization methods. While we focused on developing the foundations and theoretical analysis of this method, we believe that this work opens up a number of interesting avenues for future study.

\textbf{Broader classes of inner loop procedures.} While we studied different gradient-based optimization methods in the inner loop, iMAML can in principle be used with a variety of inner loop algorithms, including dynamic programming methods such as $Q$-learning, two-player adversarial games such as GANs, energy-based models~\cite{Mordatch18concept}, and actor-critic RL methods, and higher-order model-based trajectory optimization methods.
This significantly expands the kinds of problems that optimization-based meta-learning can be applied to.

\textbf{More flexible regularizers.} We explored one very simple regularization, $\ell_2$ regularization to the parameter initialization, which already increases the expressive power over the implicit regularization that MAML provides through truncated gradient descent. To further allow the model to flexibly regularize the inner optimization, a simple extension of iMAML is to learn a vector- or matrix-valued $\lambda$, which would enable the meta-learner model to co-adapt and co-regularize various parameters of the model. Regularizers that act on parameterized density functions would also enable meta-learning to be effective for few-shot density estimation.

\clearpage

\section*{Acknowledgements}
Aravind Rajeswaran thanks Emo Todorov for valuable discussions about implicit gradients and potential application domains; Aravind Rajeswaran also thanks Igor Mordatch and Rahul Kidambi for helpful discussions and feedback. Sham Kakade acknowledges funding from the Washington Research Foundation for innovation in Data-intensive Discovery; Sham Kakade also graciously acknowledges support from ONR award N00014-18-1-2247, NSF Award CCF-1703574, and NSF CCF 1740551 award.


\bibliography{citations}
\bibliographystyle{plainnat}

\clearpage

\appendix


\section{Relationship between iMAML and Prior Algorithms}
\label{app:other_algs}

The presented iMAML algorithm has close connections, as well as notable differences, to a number of related algorithms like MAML~\cite{maml}, first-order MAML, and Reptile~\cite{nichol2018first}. Conventionally, these algorithms do not consider any explicit regularization in the inner-level and instead rely on early stopping, through only a few gradient descent steps. In our problem setting described in Eq.~\ref{eq:update_rule}, we consider an explicitly regularized inner-level problem (refer to discussion in Section~\ref{sec:proximal_regularization}). We describe the connections between the algorithms in this explicitly regularized setting below.

\textbf{MAML}. \ The MAML algorithm first invokes an iterative algorithm to solve the inner optimization problem (see definition~\ref{def:delta_approx_alg}). Subsequently, it backpropagates through the path of the optimization algorithm to update the meta-parameters as:
\[
\prior^{k+1} = \prior^k - \eta \ \frac{1}{M} \sum_{i=1}^M \grad_\prior \fn_i(\alg_i(\prior^k)).
\]
Since $\alg_i(\prior)$ approximates $\algstar_i(\prior)$, it can be viewed that both MAML and iMAML intend to perform the same idealized update in Eq.~\ref{eq:outer_update_rule}. However, they perform the meta-gradient computation very differently. MAML backpropagates through the path of an iterative algorithm, while iMAML computes the meta-gradient through the implicit Jacobian approach outlined in Section~\ref{sec:implicit_jacobian} (see Figure~\ref{fig:diagram} for a visual depiction). As a result, iMAML can be vastly more efficient in memory while having lesser or comparable computational requirements. It also allows for higher order optimization methods and non-differentiable components.

{\bf First-order MAML} ignores the effect of meta-parameters $\prior$ on task parameters $\{ \param_i \}$ in the meta-gradient computation and updates the meta-parameters as: 
$$\prior^{k+1} = \prior^k - \eta \ \frac{1}{M} \sum_{i=1}^M \pgrad_\param \fn_i (\param_i) \mid_{\param_i = \alg_i(\prior^k)}$$ 
Note that iMAML strictly generalizes this, since first-order MAML is simply iMAML when the conjugate gradient procedure is not invoked (or corresponds to 0 steps of CG). Thus, iMAML allows for an easy way to interpolate from first-order MAML to the full MAML algorithm.

{\bf Reptile}~\cite{nichol2018first}, similar to first-order MAML, ignores the dependence of task-parameters on meta-parameters. However, instead of following the gradients at $\param_i = \alg_i(\prior^k)$, Reptile uses the task-parameters as targets and slowly moves meta-parameters towards them: 
$$\prior^{k+1} = \prior^k - \eta \ \frac{1}{M} \sum_{i=1}^M (\prior^k - \param_i).$$ 
From the proximal point equation in the proof of Lemma~\ref{lemma:alg_derivative}, we have $\param_i = \prior^k - \frac{1}{\lambda} \pgrad_\param \fn_i(\param_i)$, using which we see that the Reptile equation becomes: \hbox{$\prior^{k+1}=\prior^k - \frac{\eta}{\lambda M} \sum_{i=1}^M \pgrad_\param \fn_i(\param_i)$}. Thus, Reptile and first-order MAML are identical in our problem formulation up to the choice of learning rate. Making the regularization explicit allows us to illustrate this equivalence. 





\section{Optimization Preliminaries}

Let $f:\mathbb{R}^d\rightarrow \mathbb{R}$.
A function $f$ is $B$ Lipschitz (or $B$-bounded gradient norm) if for all $x\in \mathbb{R}^d$
\[
  ||\nabla f(x) || \leq B \, .
\]
Similarly, we say that a matrix valued function $M:\mathbb{R}^d\times \mathbb{R}^{d^\prime}\rightarrow \mathbb{R}$ is $\rho$-Lipschitz if
\[
|| M(x) - M(x^\prime) || \leq \rho ||x - x^\prime|| 
\, ,
\]
where $\|\cdot\|$ denotes the spectral norm.

We say that $f$  is $L$-smooth if for all $x,x'\in \mathbb{R}^d$
\[
  || \nabla f(x) - \nabla f(x^\prime) || \leq L ||x - x^\prime|| 
\]
and that $f$ is $\mu$-strongly convex if $f$ is convex and if for all $x,x'\in \mathbb{R}^d$,
\[
|| \nabla f(x) - \nabla f(x^\prime) || \geq \mu ||x - x^\prime|| 
\, .
\]

We will make use of the following black-box complexity of first-order gradient
methods for minimizing strongly convex and smooth
functions. 

\begin{lemma}\label{lemma:opt}
  ($\delta$-approximate solver; see~\cite{bubeck_book}) Suppose $f$ is
  a function that is $L$-smooth and $\mu$ strongly convex. Define
  $\kappa:=L/\mu$, and let $x^\star = \argmin f(x)$.  Nesterov's
  accelerated gradient descent can be used to find a point $x$ such
  that:
\[
\|x -x^\star\| \leq \delta
\]
using a number of gradient computations of $f$ that is bounded as follows:
\[
\textrm{\# gradient computations of } f(\cdot) \leq 2\sqrt{\kappa}
\,  \log\left( 2\kappa \frac{ \|x^\star\| }{\delta}\right) \, .
\]
\end{lemma}



\section{Review: Time and Space Complexity of Hessian-Vector Products}
\label{sec:hvp}
We briefly discuss the time and space complexity of Hessian-vector
product computation using the reverse mode of automatic
differentiation. The reverse mode of automatic
differentiation~\citep{Baur1983TCo,Griewank:2008:EDP:1455489} is the
widely used method for automatic differentiation in modern software
packages like TensorFlow and
PyTorch~\citep{Baydin2015AutomaticDI}.
Recall that for a differentiable function $f(x)$, the reverse mode
of automatic differentiation computes $\pgrad f(x)$ in
time that is no more than a factor of $5$ of the time it takes to compute $f(x)$
itself (see ~\citep{Griewank:2008:EDP:1455489} for review).
As our algorithm makes use of Hessian vector products, we will make use of the
following assumption as to how Hessian vector products will be
computed when executing Algorithm~\ref{alg:implicit_grad}. 

\begin{assumption}  \label{assumption:HVP}
  (Complexity of Hessian-vector product)
We assume that the time to compute the Hessian-vector product
$\pgrad^2_\param \fnht_i(\param) \bm{v}$ is no more than a
(universal) constant over the time used to compute
$\pgrad \fnht_i(\param)$ (typically, this constant is
$5$). Furthermore, we assume that the memory used to compute the
Hessian-vector product $\pgrad^2_\param \fnht_i(\param) \bm{v}$ is
no more than twice the memory used when computing
$\pgrad \fnht_i(\param)$.  This
assumption is valid if the reverse mode of automatic differentiation is  used to compute Hessian vector products
(see~\cite{Griewank1993SomeBO}).
\end{assumption}



A few remarks about this assumption are in order. With regards to
computation, first observe that the gradient of the scalar function
$\pgrad_\param \fnht_i(\param)^\top \bm{v}$ is the desired Hessian vector product
$\pgrad_\param^2 \fnht_i(\param) \bm{v}$. Thus computing the Hessian vector product
using the reverse mode is within a constant
factor of computing the function itself, which is simply the cost of
computing $\pgrad \fnht_i(\param)^\top \bm{v}$. The issue of memory is
more subtle (see~\cite{Griewank1993SomeBO}), which we now discuss.
The memory used to compute the gradient of a scalar cost
function $f(x)$ using the reverse mode of auto-differentiation is proportional to the size
of the computation graph; precisely, the memory required to compute the
gradient is equal to the total space required to store all the
intermediate variables used when computing $f(x)$. In practice, this
is often much larger than the memory required to compute
$f(x)$ itself, due to that all intermediate variables need not be simultaneously stored in
memory when computing $f(x)$. However, for the special case of
computing the gradient of the function $f(\param)= \pgrad_\param
\fnht_i(\param)^\top \bm{v}$, the factor of $2$ in the memory bound is a consequence
of the following
reason: first, using the reverse mode to compute $f(\param)$ means we
already have stored the computation graph
of $\fnht_i(\param)$ itself. Furthermore, the size of the computation graph for computing $f(\param)= \pgrad_\param
\fnht_i(\param)^\top \bm{v}$
is essentially the same size as the computation graph of
$\fnht_i(\param)$.
This leads to the factor of $2$ memory bound; see
\citet{Griewank1993SomeBO} for further discussion.

\section{Additional Discussion About Compute and Memory Complexity}
\label{sec:compute_memory_discussion}

Our main complexity results are summarized in Table~1. For these results, we consider two notions of error that are subtly different, which we explicitly define below. Let $\bm{g}_i$ be the computed meta-gradient for task $\task_i$. Then, the errors we consider are:

\begin{definition}
\label{def:exact_error}
Exact-solve error (our notion of error): Our goal
is to accurately compute the
gradient of $F(\theta)$ as defined in Equation~\ref {eq:update_rule},
where $\algstar_i(\theta)$ is an exact algorithm. Specifically, we seek to compute a $\bm{g}_i$ such that:
\[
\| \bm{g}_i - \grad_\prior \fn_i(\algstar_i(\prior)) \| \leq \eps
\]
where $\eps$ is the error in the gradient computation.
\end{definition}

\begin{definition}
\label{def:approx_error}
Approx-solve error: Here we suppose that $\alg_i$ computes a $\delta$--accurate solution to the inner optimization problem over $G_i$ in Eq.~\ref{eq:update_rule}, i.e. that $\alg_i$ satisfies $\| \alg_i(\prior) - \algstar_i(\prior) \| \leq \delta$, as per definition~\ref{def:delta_approx_alg}. Then the objective is to compute a $\bm{g}$ such that:
\[
\| \bm{g} - \grad_\prior \fn_i(\alg_i(\prior)) \| \leq \eps
\]
where $\eps$ is the error in the gradient computation of $\grad_\prior \fn_i(\alg_i(\prior))$. Subtly, note that the gradient is with respect to the $\delta$-approximate algorithm, as opposed to using $\algstar_i$.
\end{definition}

For the complexity results, we assume that MAML invokes $\alg_i$ to get a $\delta$-approximate solution for inner problem (recall definition~\ref{def:delta_approx_alg}). The exact-solve
error for MAML is not known in the literature; in particular, even as
$\delta\rightarrow 0$ it is not evident if the approx-solve solution
tends to the exact-solve solution, unless further regularity
conditions are imposed. The approx-solve error for MAML is $0$,
ignoring finite-precision and numerical issues, since it
backpropagates through the path. Truncated
backprop~\cite{Shaban2018TruncatedBF} also invokes $\alg_i$ to obtain a $\delta$-approximate solution but instead performs a truncated or partial back-propagation so that it uses a smaller number of
iterations when computing the gradient through the path of
$\alg_i(\prior)$. Exact-solve error for truncated backprop is also not
known, but a small approx-solve error can be obtained with less memory
than full back-prop. We use Prop 3.1 of Shaban et al.~\cite{Shaban2018TruncatedBF} to provide a guarantee that leads to an
$\epsilon$--accurate approximation of the full-backprop (i.e. MAML)
gradient. It is not evident how accurate the truncated procedure is
when an accelerated method is used instead. Finally, our iMAML
algorithm also invokes an approximate solver $\alg_i$ rather than $\algstar_i$. However, importantly, we guarantee a
small exact-solve error even though we do not require access to
$\algstar_i$. Furthermore, the iMAML algorithm also requires substantially less
memory. Up to small constant factors, it only utilizes the memory required for computing a single
gradient of $\fnht_i(\cdot)$.


\section{Proofs}

{\bf Lemma 1, restated.}
Consider $\algstar_i(\prior)$ as defined in Eq.~\ref{eq:update_rule} for task $\task_i$. Let $\param_i = \algstar_i(\prior)$ be the result of $\algstar_i(\prior)$. If $\left( \eye + \frac{1}{\lambda} \pgrad_\param^2 \fnht_i(\param_i) \right)$ is invertible, then the derivative Jacobian is
\begin{equation*}
    \frac{d \algstar_i(\prior)}{d \prior} = \left( \eye + \frac{1}{\lambda}~ \pgrad_\param^2 \fnht_i (\param_i) \right)^{-1}.
\end{equation*}
\begin{proof}
We drop the task $i$ subscripts in the proof for convenience. Since $\param = \algstar(\prior)$ is the minimizer of $G(\dparam, \prior)$ in Eq.~\ref{eq:update_rule}, the stationary point conditions imply that
\[
\pgrad_\dparam G(\dparam, \prior) \mid_{\dparam = \udparam} \ = 0 \implies \pgrad \fnht(\udparam) + \lambda (\udparam - \prior) = 0 \implies \udparam = \prior - \frac{1}{\lambda}~\pgrad \fnht(\udparam),
\]
which is an implicit equation that often arises in proximal point methods. When the derivative exists, we can differentiate the above equation to obtain:
\[
\frac{d \udparam}{d \prior} = \eye - \frac{1}{\lambda}~\pgrad^2 \fnht(\udparam) \frac{d \udparam}{d \prior}
\implies 
\left( \eye + \frac{1}{\lambda}~\pgrad^2 \fnht(\udparam) \right) \frac{d \udparam}{d \prior} = \eye.
\]
which completes the proof.
\end{proof}

Recall that:
\[
G_i(\dparam, \prior) := \fnht_i(\dparam) + \frac{\lambda}{2}~||\dparam - \prior||^2.
\]

\begin{assumption} \label{assumption:regularity}
  (Regularity conditions)
Suppose the following holds for all tasks $i$:
\begin{enumerate}
\item $\fn_i(\cdot)$ is $B$ Lipshitz and $L$ smooth.
\item For all $\prior$, $G_i(\cdot,\prior)$ is both a $\beta$-smooth function
and a $\mu$-strongly convex function. Define:
\[
\kappa :=\frac{\beta}{\mu}  \, .
\]
\item $\fnht_i (\cdot)$ is $\rho$-Lipshitz Hessian, i.e. $\nabla^2 \fnht_i (\cdot)$ is $\rho$-Lipshitz.
\item  For all $\prior$, suppose the arg-minimizer of
  $G_i(\cdot, \prior)$ is unique and bounded in a ball of radius $D$,
  i.e. for all $\prior$,
  \[
    \|\algstar_i(\prior) \|\leq D \, .
  \]
\end{enumerate}
\end{assumption}

\begin{lemma}~\label{lemma:perturbation}
(Implicit Gradient Accuracy) Suppose
Assumption~\ref{assumption:regularity} holds. Fix a task $i$.
Suppose that $\param_i$ satisfies:
\[
  \|\param_i-\algstar_i(\prior)\|\leq \delta
\]
and that $\bm{g}_i$ satisfies:
  \[
    \|\bm{g}_i- \left( \eye + \frac{1}{\lambda}~ \pgrad^2 \fnht_i (\param) \right)^{-1}\pgrad_\param \fn_i(\param)\|
\leq \delta^\prime \, .
\]
Assuming that $\delta<\mu/(2\rho)$, we have that:
\[
\|\bm{g}_i - \grad_\prior \fn_i(\algstar_i(\prior)) \| \leq 
\left(2 \frac{\lambda\rho}{\mu^2} B
                + \frac{\lambda L}{\mu}\right)\delta+ \delta^\prime
\]
\end{lemma}

\begin{proof}
  First, observe that:
  \[
\grad_\prior \fn_i(\algstar_i(\prior)) =
\left( \eye + \frac{1}{\lambda}~ \pgrad^2 \fnht_i (\algstar_i(\prior)) \right)^{-1}\pgrad_\param \fn_i(\algstar_i(\prior))
    \]
For notational convenience,  we drop the $i$ subscripts within the
proof. We have:
\begin{eqnarray*}
&&
\|\grad_\prior \fn(\algstar(\prior))-\bm{g}\| \\
&\leq &
\|\grad_\prior \fn(\algstar(\prior))-\left( \eye + \frac{1}{\lambda}~ \pgrad^2 \fnht (\param) \right)^{-1}\pgrad_\param \fn(\param)  \|+ \delta^\prime\\
&\leq &
\|\grad_\prior \fn(\algstar(\prior))-\left( \eye + \frac{1}{\lambda}~ \pgrad^2 \fnht (\param) \right)^{-1}\pgrad_\param \fn(\algstar(\prior))  \|
                +\\
&&\|\left( \eye + \frac{1}{\lambda}~ \pgrad^2 \fnht (\param) \right)^{-1}
\left(\pgrad_\param \fn(\algstar(\prior))  -\pgrad_\param \fn(\param)\right)\|
 + \delta^\prime
\end{eqnarray*}
where the first inequality uses the triangle inequality.

We now bound each of these terms. For the second term,
\begin{eqnarray*}
&&\|\left( \eye + \frac{1}{\lambda}~ \pgrad^2 \fnht (\param) \right)^{-1}
\left(\pgrad_\param \fn(\algstar(\prior))  -\pgrad_\param \fn(\param)\right)\|
\\
&\leq &
\|\left( \eye + \frac{1}{\lambda}~ \pgrad^2 \fnht (\param) \right)^{-1}\|
\|\pgrad_\param \fn(\algstar(\prior))  -\pgrad_\param \fn(\param)\| \\
&\leq &
\lambda L \|\left( \lambda \eye + \pgrad^2 \fnht (\param) \right)^{-1}\|
\|\algstar(\prior)  - \param\| \\
&= &
\lambda L \| \nabla^2_\param G(\param,\prior)^{-1}\|
\|\algstar(\prior)  - \param\| \\
&\leq & \frac{\lambda L}{\mu}\delta
\end{eqnarray*}
where we the second inequality uses that  $\pgrad_\param \fn$ is
$L$-smooth and the final inequality uses that $G$ is $\mu$ strongly convex.


For the first term, we have:
  \begin{eqnarray*}
&&
\|\grad_\prior \fn(\algstar(\prior))-\left( \eye + \frac{1}{\lambda}~ \pgrad^2 \fnht (\param) \right)^{-1}\pgrad_\param \fn(\algstar(\prior))  \| \\
&= &
\| \left(\left( \eye + \frac{1}{\lambda}~ \pgrad^2 \fnht (\algstar(\prior)) \right)^{-1}
-\left( \eye + \frac{1}{\lambda}~ \pgrad^2 \fnht (\param) \right)^{-1}\right) \pgrad_\param \fn(\algstar(\prior))\| 
\\
&\leq &
\lambda \| \left( \lambda \eye + \pgrad^2 \fnht (\algstar(\prior)) \right)^{-1}
-\left( \lambda \eye + \pgrad^2 \fnht (\param) \right)^{-1}\| B,
  \end{eqnarray*}
using that $\pgrad_\param \fn$ is $B$ Lipshitz.
Now let
\[
\Delta := 
  \pgrad^2 \fnht (\algstar(\prior))-\pgrad^2 \fnht (\param) , \quad
  M:= \nabla^2_\param G(\param,\prior)= \lambda \eye + \pgrad^2 \fnht (\param)
\]
Due to that $\pgrad^2 \fnht (\cdot)$ is Lipshitz Hessian,
$\|\Delta\|\leq \rho \delta$. Also, by our assumption on
$\delta$, we have that:
\[
\|M^{-1}\Delta\| \leq \|\Delta\|/\mu \leq \rho
\delta/\mu \leq 1/2,
 \] 
which implies that $\|\left( \eye + M^{-1}\Delta \right)^{-1}\|\leq 2$.
Hence,
\begin{eqnarray*}
  &&\| \left( \lambda\eye + \pgrad^2 \fnht (\algstar(\prior)) \right)^{-1}
-\left( \lambda \eye + \pgrad^2 \fnht (\param)
     \right)^{-1}     \|\\
  &=&\| \left( M +\Delta \right)^{-1}-M^{-1}\|\\
  &\leq& \|M^{-1}\|\| \left( \eye + M^{-1}\Delta \right)^{-1}-\eye\|\\
  &=& \|M^{-1}\|\| \left( \eye + M^{-1}\Delta \right)^{-1}\left(\eye-\left(\eye + M^{-1}\Delta\right)\right)\|\\
  &\leq& \|M^{-1}\| \| \left( \eye + M^{-1}\Delta \right)^{-1}\| \| M^{-1}\Delta\|\\
  &\leq& \frac{1}{\mu} \cdot 2 \cdot \frac{\rho \delta}{\mu}=2 \frac{\rho}{\mu^2} \delta .
\end{eqnarray*}
The proof is completed by substitution.
\end{proof}


\begin{theorem}
(Approximate Implicit Gradient Computation)  Suppose
Assumption~\ref{assumption:regularity} holds. Fix a task $i$.   Let
  \begin{eqnarray*}
B_1& :=& 2 \frac{\lambda\rho}{\mu^2} B+ \frac{\lambda L}{\mu}\\
\end{eqnarray*}
Suppose Nesterov's accelerated gradient descent algorithm is used
to compute $\param$ (as desired in Algorithm~\ref{alg:implicit_grad}), using 
a number of iterations that is:
\[
2\sqrt{\kappa} \, \log\left( 8\kappa D\left(\frac{ B_1}{\eps}+\frac{\rho}{\mu}\right)\right) 
\]
and suppose Nesterov's accelerated gradient descent
algorithm (or the conjugate gradient algorithm~\footnote{The conjugate gradient descent algorithm also
  suffices and give a slightly improved iteration complexity in terms
  of log factors.}) is used to compute $\bm{g}_i$ using
a number of iterations that is:
\[
2\sqrt{\kappa} \, \log\left( 4\kappa \frac{ (\lambda / \mu)B}{\eps}\right) \, .
\]
We have that:
\[
\|\bm{g}_i - \grad_\prior \fn_i(\algstar_i(\prior)) \| \leq 
\eps.
\]
\end{theorem}

\begin{proof}
  The result will follow from the guarantees in
  Lemma~\ref{lemma:opt}. Specifically, let us set
  $\delta=\min\{\eps/(2B_1), \mu/(2\rho) \}$ and
  $\delta^\prime=\eps/2$. To ensure the bound of $\delta$, by
  Lemma~\ref{lemma:perturbation}, it suffices to use a number of
  iterations that is bounded by:
  \[
2\log\left( 2\kappa \frac{ \|D\| }{\delta}\right) \leq
2\sqrt{\kappa} \, \log\left( 8\kappa D\left(\frac{ B_1}{\eps}+\frac{\rho}{\mu}\right)\right) 
  \]
To ensure the bound of $\delta^\prime$, the algorithm will be solving
the sub-problem in Equation~\ref{eq:sub_problem}. First observe that in the
  context of in Lemma~\ref{lemma:opt}, note that
  $\|x^\star\|=\|\left( \eye + \frac{1}{\lambda}~ \pgrad^2 \fnht_i
    (\param) \right)^{-1}\pgrad
  \fn_i(\param)\| \leq (\lambda / \mu)B$, and so
it suffices to use a number of iterations that is bounded by:  
\[
2\log\left( 2\kappa \frac{ \|x^\star\| }{\delta}\right) \leq
2\log\left( 4\kappa \frac{ (\lambda / \mu)B }{\eps}\right) ,
\]
which completes the proof.
\end{proof}

 



\section{Experiment Details}
\label{app:experiments}

Here, we provide additional details of the experimental set-up for the experiments in Section~\ref{sec:experiments}. All training runs were conducted on a single NVIDIA (Titan Xp) GPU.

\subsection{Synthetic Experiments}

For the synthetic experiments, we consider a linear regression problem. We consider parametric models of the form $h_\param(\inp) = \param^T \inp$, where $\inp$ can either be the raw inputs or features (e.g. Fourier features) of the input. For task $\task_i$, we can equivalently write a quadratic objective that represents the task loss as:
\[
\fnht_i(\param) = \frac{1}{2} \bE_{(\inp, \out)\sim \datatr_i} \left[ \| h_\param(\inp) - \out \|^2 \right] = \frac{1}{2} \param^T A_i \param + \param^T b_i,
\]
where $A_i = \bE_{(\inp, \out)\sim \datatr_i} \left[ \inp \inp^T \right]$ and $b_i= \bE_{(\inp, \out)\sim \datatr_i} \left[ \inp^T \out \right]$. Thus, the inner level objective and corresponding minimizer can be written as:
\[
G_i(\dparam, \prior) = \frac{1}{2} \dparam^T A_i \dparam + \dparam^T b_i + \frac{\lambda}{2} (\dparam - \prior)^T (\dparam - \prior)
\]
\[
\algstar_i(\prior) = \left( A_i + \lambda \eye \right)^{-1} \left( \lambda \prior - b_i \right) 
\]
Thus, the exact meta-gradient can be written as
\[
\grad_\prior \fn_i(\algstar_i(\prior)) = \lambda (A_i + \lambda \eye)^{-1} \pgrad_\param \fn_i(\prior) \mid_{\param = \algstar_i(\prior)}.
\]
We compare this gradient with the gradients computed by the iMAML and MAML algorithms. We considered the case of $\inp \in \bR^{50}$, $\out \in \bR$, $\lambda=5.0$, and $\kappa=50$, for the presented results.

\subsection{Omniglot and Mini-ImageNet experiments}

We follow the standard training and evaluation protocol as in prior works~\cite{mann, matchingnets, maml}. 

\paragraph{Omniglot Experiments} The GD version of iMAML uses 16 gradient steps for 5-way 1-shot and 5-way 5-shot settings, and 25 gradient steps for 20-way 1-shot and 20-way 5-shot settings. A regularization strength of $\lambda=2.0$ was used for both. $5$ steps of conjugate gradient was used to compute the meta-gradient for each task in the mini-batch, and the meta-gradients were averaged before taking a step with the default parameters of Adam in the outer loop.

The Hessian-free version of MAML proceeds by using Hessian-free or Newton-CG method for solving the inner optimization problem (with respect to $\param$) with objective $G_i(\param, \prior)$. This method proceeds by constructing a local quadratic approximation to the objective and approximately computing the Newton direction with conjugate gradient. $5$ CG steps are used for this process in our experiments. This allows us to compute the search direction, following which a step size has to be picked. We pick the step size through line-search. This procedure of computing the approximate Newton direction and linesearch is repeated $3$ times in our experiments to solve the inner optimization problem well.

\paragraph{Mini-ImageNet}
For the GD version of iMAML, 10 GD steps were used with regularization strength of $\lambda=0.5$. Again, 5 CG steps are used to compute the meta-gradient. Similarly, in the Hessian-Free variant, we again use $5$ CG steps to compute the search direction followed by line search. This process is repeated $3$ times to solve the inner level optimization. Again, to compute the meta-gradient, 5 steps of CG are used.

\end{document}