\documentclass{article}

\PassOptionsToPackage{numbers}{natbib}






\usepackage[final]{nips_2018}



\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{booktabs}
\usepackage{array}
\usepackage{multirow}
\usepackage{caption}
\usepackage{arydshln}
\usepackage{blindtext}
\usepackage[labelformat=simple]{subcaption}

\usepackage{algorithm}
\usepackage{algpseudocode}

\usepackage{footnote}
\renewcommand\thesubfigure{(\alph{subfigure})}
\newcommand{\head}[1]{\textnormal{\textbf{#1}}}
\newcommand{\normal}[1]{\multicolumn{1}{l}{#1}}

\newcommand{\cT}{{\cal T}}
\newcommand{\ST}{S_{\cal T}}
\newcommand{\cX}{S_{\cal X}}
\newcommand{\cY}{S_{\cal Y}}
\newcommand{\eqdef}{ \triangleq}

\newcommand{\bx}{{\mathbf x}}
\newcommand{\bw}{{\mathbf w}}
\newcommand{\bv}{{\mathbf v}}
\newcommand{\bu}{{\mathbf u}}
\newcommand{\bz}{{\mathbf z}}
\newcommand{\bb}{{\mathbf b}}
\newcommand{\ba}{{\mathbf a}}
\newcommand{\by}{{\mathbf y}}

\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
    
\title{Deep Anomaly Detection Using Geometric Transformations}



\author{
	Izhak Golan \\
	Department of Computer Science\\
	Technion -- Israel Institute of Technology \\
	Haifa, Israel \\
	\texttt{izikgo@cs.technion.ac.il} \\
	\And
	Ran El-Yaniv \\
	Department of Computer Science\\
	Technion -- Israel Institute of Technology \\
	Haifa, Israel \\
	\texttt{rani@cs.technion.ac.il}
}

\begin{document}
	
	\maketitle
	
	\begin{abstract}
		We consider the problem of anomaly detection in images, and 
		present a new detection technique. Given a sample
		of images, all known to belong to a ``normal'' class (e.g., dogs), 
		we show how to train a deep neural model that can detect 
		out-of-distribution images (i.e., non-dog objects). The main 
		idea behind our scheme is to train a multi-class model to discriminate between
		dozens of geometric transformations applied on all the given images. The auxiliary expertise learned by the model generates 
		feature detectors that effectively identify, at test time, anomalous images based on 
		the softmax activation statistics of the model when applied on transformed images.
		We present extensive experiments using the proposed detector, which indicate that our technique consistently improves all known algorithms by a wide margin.
	\end{abstract}
	
	\section{Introduction}
	
	
	Future machine learning applications such as self-driving cars or domestic robots will, inevitably, encounter various kinds of risks including statistical uncertainties. To be usable, these applications should be as robust as possible to such risks. One such risk is exposure to statistical errors or inconsistencies due to distributional divergences or noisy observations. The well-known problem of {\em anomaly/novelty detection} highlights some of these risks, and its resolution is of the utmost importance to mission critical machine learning applications. While anomaly detection has long been considered in the literature, conclusive understanding of this problem in the context of deep neural models is sorely lacking.
	For example, in machine vision applications, presently available novelty detection methods can suffer from poor performance in some problems, as demonstrated by our experiments.
	
	In the basic anomaly detection problem, we have a sample from a ``normal'' class of instances, emerging from some distribution, and the goal is to construct a classifier capable of detecting out-of-distribution ``abnormal'' 
	instances \cite{chandola2009anomaly}.\footnote{Unless otherwise mentioned, the use of the adjective ``normal'' is unrelated to the Gaussian distribution.} There are quite a few variants of this basic anomaly detection problem. For example, in the {\em positive and unlabeled} version, we are given a sample from the ``normal'' class, as well as an unlabeled sample that is contaminated with abnormal instances. This contaminated-sample variant turns out to be easier than the pure version of the problem (in the sense that better performance can be achieved)~\cite{blanchard2010semi}. In the present paper, we focus on the basic (and harder) version of anomaly detection, and consider only machine vision applications for which deep models (e.g., convolutional neural networks) are essential.
	
	There are a few works that tackle the basic, pure-sample-anomaly detection problem in the context of images. The most 
	successful results among these are reported for methods that rely on one of the following two general schemes.
	The first scheme consists of methods that analyze errors in reconstruction, which is  based either on autoencoders or generative adversarial models (GANs) trained over the normal class.
In the former case, reconstruction deficiency of a test point indicates abnormality. 
	In the latter, the reconstruction error of  a test instance is estimated using optimization to find the approximate inverse of the generator. The second class of methods utilizes an autoencoder trained over the normal class to generate a low-dimensional embedding. 
	To identify anomalies, one uses classical methods over this embedding, such as low-density rejection~\cite{el2007optimal} or single-class SVM~\cite{scholkopf2000support, tax2004support}. 
	A more advanced variant of this approach combines these two steps (encoding and then detection) using an appropriate cost function, which is used to train a single neural model that performs both procedures~\cite{ruff2018deep}.
	
	In this paper we consider a completely different approach that bypasses reconstruction (as in autoencoders or GANs) altogether.
	The proposed method is based on the observation that learning to discriminate between 
	many types of geometric transformations applied to normal images, encourages learning of features that are useful for detecting novelties. 
	Thus, we train a multi-class neural classifier over a {\em self-labeled} dataset, which is created from the normal instances and their transformed versions, obtained by applying 
	numerous geometric transformations. At test time, this discriminative model is applied on transformed instances of the test example, and the distribution of softmax response values of the ``normal'' train images is used for effective detection of novelties.
	The intuition behind our method is that by training the classifier to distinguish between transformed images, it must learn salient geometrical features, some of which are likely to
	be unique to the single class.
	
	We present extensive experiments of the proposed method and compare it to several 
	state-of-the-art methods for pure anomaly detection. 
	We evaluate performance using a one-vs-all scheme over several image datasets such as CIFAR-100, which (to the best of our knowledge) have never been considered before in this setting. 
	Our results overwhelmingly indicate that the proposed method achieves dramatic improvements over the best available methods. For example, on the CIFAR-10 dataset (10 different experiments), we improved the top performing baseline AUROC by 32\% on average. In the CatsVsDogs dataset, we improve the top performing baseline AUROC by 67\%.
	
	\section{Related Work}
	The literature related to anomaly detection is extensive and beyond the scope of this paper
	(see, e.g.,  \cite{chandola2009anomaly, zimek2012survey} for wider scope surveys).
	Our focus is on 
	anomaly detection in the context of images and deep learning. 
	In this scope, most published works rely, implicitly or explicitly,
	on some form of (unsupervised) reconstruction learning. 
	These methods can be roughly categorized into two approaches.
	
	\paragraph{Reconstruction-based anomaly score.} 
	These methods assume that anomalies possess different visual attributes than their non-anomalous counterparts, so it will be difficult to compress and reconstruct them based on a reconstruction scheme optimized for single-class data. Motivated by this assumption, the anomaly score for a new sample is given by the quality of the reconstructed image, which is usually measured by the  distance between the original and reconstructed image. Classic methods belonging to this category include Principal Component Analysis (PCA)~\cite{jolliffe1986principal}, and Robust-PCA~\cite{candes2011robust}. In the context of deep learning, various forms of deep autoencoders are the main tool used for reconstruction-based anomaly scoring. \citet{xia2015learning} use a convolutional autoencoder with a regularizing term that encourages outlier samples to have a large reconstruction error. Variational autoencoder is used by \citet{an2015variational}, where they estimate the reconstruction probability through Monte-Carlo sampling, from which they extract an anomaly score. Another related method, which scores an unseen sample based on the ability of the model to generate a similar one, uses Generative Adversarial Networks (GANS)~\cite{goodfellow2014generative}. \citet{schlegl2017unsupervised} use this approach on optical coherence tomography images of the retina. \citet{deecke2018anomaly} employ a variation of this model called ADGAN, reporting slightly superior results on CIFAR-10~\cite{krizhevsky2009learning} and MNIST~\cite{lecun2010mnist}.
	
	\paragraph{Reconstruction-based representation learning.}
	Many conventional anomaly detection methods use a low-density rejection principle~\cite{el2007optimal}. Given data, the density at each point is estimated, and new samples are deemed anomalous when they lie in a low-density region. Examples of such methods are kernel density estimation (KDE)~\cite{parzen1962estimation}, and Robust-KDE~\cite{kim2012robust}. This approach is known to be problematic when handling high-dimensional data due to the \textit{curse of dimensionality}. To mitigate this problem, practitioners often use a two-step approach of learning a compact representation of the data, and then applying density estimation methods on the lower-dimensional representation~\cite{candes2011robust}. More advanced techniques combine these two steps and aim to learn a representation that facilitates the density estimation task. \citet{zhai2016deep} utilize an energy-based model in the form of a regularized autoencoder in order to map each sample to an energy score, which is the estimated negative log-probability of the sample under the data distribution. \citet{zong2018deep} uses the representation layer of an autoencoder in order to estimate parameters of a Gaussian mixture model.
	
	There are few approaches that tackled the anomaly detection problem without resorting to some form of reconstruction.
	A recent example was published by \citet{ruff2018deep}, who have developed a deep one-class SVM model. The model consists of a deep neural network whose weights are optimized using a loss function resembling the SVDD~\cite{tax2004support} objective.
	


	\section{Problem Statement}
	\label{sec:problem}
	In this paper, we consider the problem of anomaly detection in images. Let  be the space of all ``natural'' images, and let  be the set of images defined as {\em normal}.
	Given a sample , and a type-II error constraint (rate of normal samples that were classified as anomalies), we would like to learn the best possible (in terms of type-I error) classifier , where , which satisfies the constraint. Images that are not in  are referred to as {\em anomalies} or {\em novelties}.
	
	To control the trade-off between type-I and type-II errors when classifying, a common practice is to learn a scoring (ranking) function , such that higher scores indicate that samples are more likely to be in . Once such a scoring function has been learned, a classifier can be constructed from it by specifying an anomaly threshold ():
	
	As many related works~\cite{schlegl2017unsupervised, taylor2016anomaly, iwata2016multi}, in this paper we also focus only on learning the scoring function , and completely ignore the constrained binary decision problem.
	A useful (and common practice) performance metric to measure the quality of the trade-off of a given scoring function is the area under the Receiver Operating Characteristic (ROC) curve, which we denote here as AUROC. 
	When prior knowledge on the proportion of anomalies is available, the area under the precision-recall curve (AUPR) metric might be preferred~\cite{davis2006relationship}. We also report on performance in term of this metric in the supplementary material. 
	
	\section{Discriminative Learning of an Anomaly Scoring Function Using Geometric Transformations}
	
	As noted above, we aim to learn a scoring function  (as described in Section~\ref{sec:problem})
	in a discriminative fashion. To this end, we create a self-labeled dataset of images from our initial training set , by using a class of geometric transformations . The created dataset, denoted , is 
	generated by applying each geometric transformation in  on all images in ,
	where we label each transformed image with the index of the transformation that was applied on it. This process creates a self-labeled multi-class dataset (with  classes) whose cardinality is . After the creation of , we train a multi-class image classifier whose objective is to predict, for each image, the index of its generating transformation in .
	At inference time, given an unseen image , we decide whether it belongs to the normal class by first applying each transformation on it, and then applying the classifier on each of the  transformed images.
	Each such application results in a softmax response vector of size .
	The final normality score is defined using the combined log-likelihood of these vectors under an estimated distribution of ``normal'' softmax vectors (see details below).
	
	\subsection{Creating and Learning the Self-Labeled Dataset}
	\label{sec:selfLabeled}
	Let  be a set of geometric transformations, where for each , and
	 is the identity transformation. The set  is a hyperparameter of our method, on which we elaborate in Section~\ref{sec:intuition}. The self-labeled set  is defined as 
	 
	Thus, for any ,  is the label of .
	We use this set to straightforwardly learn a deep -class classification model, ,
	which we train over the self-labeled dataset  using
	the standard cross-entropy loss function.
	To this end, any useful classification architecture and optimization method can be employed for this task.
	


	\subsection{Dirichlet Normality Score} 
	\label{sec:normality_score}

    We now define our normality score function .	
    Fix a set of geometric transformations , 
    and assume that a -class classification model  has been trained on the self-labeled set 
    (as described above).
    For any image , let 
    , i.e.,
    the vector of softmax responses
	of the classifier  applied on .
    To construct our normality score we define: 
    
    which is the combined log-likelihood of a transformed image conditioned on each of the applied transformations in , under a na\"ive (typically incorrect) assumption that all of these conditional distributions are independent. 
    We approximate each conditional distribution to be 
	where , and  is the real data probability distribution of ``normal'' samples. Our choice of the Dirichlet distribution is motivated by two  reasons. 
	First, it is a common choice for distribution approximation when samples (i.e., ) reside in the unit  simplex. Second, there are efficient methods for numerically estimating the maximum likelihood parameters~\cite{minka2000estimating, wicker2008maximum}. 
We denote the estimation by . Using the estimated Dirichlet parameters, the normality score of an image  is:
	
Since all  are constant w.r.t , we can ignore the first two terms in the parenthesis and redefine a simplified normality score, which is equivalent in its normality ordering:
    
    


As demonstrated in our experiments, this score tightly captures normality in the sense that for two images  and ,  tend to imply that  is ``more normal'' than .
    For each , we estimate  using the fixed point iteration method described in~\cite{minka2000estimating}, combined with the initialization step proposed by~\citet{wicker2008maximum}. 
    Each vector  is estimated based on the set . We note that the use of an independent image set for estimating   may improve performance. A full and detailed algorithm is available in the supplementary material.
    
    A simplified version of the proposed normality score was used during preliminary stages of this research:
    
	This simple score function eliminates the need for the Dirichlet parameter estimation, is easy to implement, and still achieves excellent results that are only slightly worse than the above Dirichlet score.


	
	\section{Experimental Results}
	In this section, we describe our experimental setup and evaluation method,
	the baseline algorithms we use for comparison purposes, the datasets, and
	the implementation details of our technique (architecture used and geometric transformations applied).
	We then present extensive experiments on the described publicly available datasets, demonstrating the effectiveness of our scoring function. 
	Finally, we show that our method is also effective at identifying out-of-distribution samples in labeled multi-class datasets.
	
	\subsection{Baseline Methods}
	We compare our method to state-of-the-art deep learning approaches 
	as well as a few classic methods.
	
	\paragraph{One-Class SVM.} The one-class support vector machine (OC-SVM) is a classic and popular kernel-based method for novelty detection~\cite{scholkopf2000support, tax2004support}. It is typically employed with an RBF kernel, 
	and learns a collection of closed sets in the input space, containing most of the training samples. Samples residing outside of these enclosures are deemed anomalous. 
	Following~\cite{zhai2016deep, deecke2018anomaly}, 
	we use this model on raw input (i.e., a flattened array of the pixels comprising an image), as well as on a low-dimensional representation obtained by taking the bottleneck layer of a trained convolutional autoencoder. We name these models \textbf{RAW-OC-SVM} and \textbf{CAE-OC-SVM}, respectively.
	It is very important to note that in both these variants of OC-SVM, 
	we provide the OC-SVM with an \textbf{unfair significant advantage} by optimizing its hyperparameters in {\em hindsight}; i.e., the OC-SVM hyperparameters ( and ) were optimized to maximize AUROC and taken to be the best performing values among those in the parameter grid: , . Note that the hyperparameter optimization procedure has been 
	provided with a two-class classification problem. There are, in fact, methods for optimizing these parameters without hindsight knowledge~\cite{wang2018hyperparameter, burnaev2015model}.
	These methods are likely to degrade the performance of the OC-SVM models.
The convolutional autoencoder is chosen to have a similar architecture to that of DCGAN~\cite{radford2015unsupervised}, where the encoder is adapted from the discriminator, and the decoder is adapted from the generator. 
	
	In addition, we compare our method to a recently published, end-to-end variant of OC-SVM called \textbf{One-Class Deep SVDD}~\cite{ruff2018deep}. This model, which we name \textbf{E2E-OC-SVM}, uses an objective similar to that of the classic SVDD~\cite{tax2004support} to optimize the weights of a deep architecture. 
	However, there are constraints on the used architecture, such as lack of bias terms and unbounded activation functions. The experimental setup used by the authors is identical to ours, allowing us to report their published results as they are, on CIFAR-10.
	
	\paragraph{Deep structured energy-based models.} A deep structured energy-based model 
	(\textbf{DSEBM}) is a state-of-the-art 
	deep neural technique, whose output is the energy function	
	(negative log probability) associated with an input sample \cite{zhai2016deep}. 
	Such models can be trained efficiently using score matching in a similar way to a denoising autoencoder~\cite{vincent2011connection}. 
	Samples associated with high energy are considered anomalous. 
	While the authors of \cite{zhai2016deep} used a very shallow architecture in their model 
	(which is ineffective in our problems), we selected a deeper one when using their method. The chosen architecture is the same as that of the encoder part in the convolutional autoencoder used by CAE-OC-SVM, with ReLU activations in the encoding layer.
	
	\paragraph{Deep Autoencoding Gaussian Mixture Model.} 
	A deep autoencoding Gaussian mixture model (\textbf{DAGMM}) is another state-of-the-art deep autoencoder-based model, 
	which generates a low-dimensional representation of the training data, and leverages a Gaussian 
	mixture model to perform density estimation on the compact representation~\cite{zong2018deep}. A DAGMM jointly
	and simultaneously optimizes the parameters of the autoencoder and the mixture model 
	in an end-to-end fashion, thus leveraging a separate estimation network to facilitate the parameter learning of the mixture model. The architecture of the autoencoder we used is similar to that of the convolutional autoencoder from the CAE-OC-SVM experiment, but with linear activation in the representation layer. 
The estimation network is inspired by the one in the original DAGMM paper. 


	\paragraph{Anomaly Detection with a Generative Adversarial Network.} This network, 
	given the acronym ADGAN, is a GAN based model, which learns a one-way mapping from a low-dimensional multivariate Gaussian distribution to the distribution of the training set \cite{deecke2018anomaly}. 
	After training the GAN on the ``normal'' dataset, the discriminator is discarded. Given a sample, the training of ADGAN uses gradient descent to estimate the inverse mapping from the image to the low-dimensional seed. The seed is then used to generate a sample, and the anomaly score is the  distance between that image and the original one. In our experiments, for the generative model of the ADGAN we incorporated the same architecture used by the authors of the original paper, namely, the original DCGAN architecture~\cite{radford2015unsupervised}. As described, ADGAN requires only a trained generator. 


	
	\subsection{Datasets}
	We consider four image datasets in our experiments: CIFAR-10, CIFAR-100~\cite{krizhevsky2009learning}, CatsVsDogs~\cite{elson2007asirra}, and fashion-MNIST~\cite{Xiao2017FashionMNISTAN}, which are described below.
	We note that in all our experiments, pixel values of all images were scaled to reside 
	in . No other pre-processing was applied.
	


		{\bf \textbullet \ \ CIFAR-10:} 
		consists of 60,000 32x32 color images in 10 classes, with 6,000 images per class. There are 50,000 training images and 10,000 test images, divided equally across the classes.
		
		{\bf \textbullet \ \ CIFAR-100:} 
		similar to CIFAR-10, but with 100 classes containing 600 images each. 
		This set has a fixed train/test partition with 500 training images and 100 test images per class. 
		The 100 classes in the CIFAR-100 are grouped into 20 superclasses, which we use in our experiments.
		
		{\bf \textbullet \ \ Fashion-MNIST:} 
		a relatively new dataset comprising 28x28 grayscale images of 70,000 fashion products from 10 categories, with 7,000 images per category. 
		The training set has 60,000 images and the test set has 10,000 images. In order to be compatible with the CIFAR-10 and CIFAR-100 classification architectures, we zero-pad the images so that they are of size 32x32.
		
		{\bf \textbullet \ \ CatsVsDogs:} 
		extracted from the ASIRRA dataset, it contains 
		25,000 images of cats and dogs, 12,500 in each class. We split this dataset into a training set 
		containing 10,000 images, and a test set of 2,500 images in each class. We also rescale 
		each image to size 64x64. The average dimension size of the original images is roughly 360x400.


	
	
	
	
	
	\subsection{Experimental Protocol}
	We employ a one-vs-all evaluation scheme in each experiment. Consider a dataset with  classes, from which we create  different experiments.
	For each , we designate class  to be the single class of normal images. We take  to be the set of images in the training set belonging to class .
The set  is considered to be the set of ``normal'' samples based on which the model must learn a normality score function. We emphasize that  contains {\em only} normal samples, and no additional samples are provided to the model during training. The normality score function is then applied on all images in the test set, containing both anomalies (not belonging to class ) and normal samples (belonging to class ), in order to evaluate the model's performance. As stated in Section~\ref{sec:problem}, we completely ignore the problem of choosing the appropriate anomaly threshold () on the normality score, and quantify performance using the area under the ROC curve metric, which is commonly utilized as a performance measure for anomaly detection models. We are able to compute the ROC curve since we have full knowledge of the ground truth labels of the test set.\footnote{A complete code of the proposed method's implementation and the conducted experiments is available at \url{https://github.com/izikgo/AnomalyDetectionTransformations}.}
	
	\paragraph{Hyperparameters and Optimization Methods}
	For the self-labeled classification task, we use 72 geometric transformations. These transformations are
	specified in the supplementary material (see also Section~\ref{sec:intuition} discussing the intuition
	behind the choice of these transformations). Our model is implemented using the state-of-the-art Wide Residual Network (WRN) model~\cite{zagoruyko2016WRN}. The parameters for the depth and width of the model for all 32x32 datasets were chosen to be 10 and 4, respectively, and for the CatsVsDogs dataset (64x64), 16 and 8, respectively. These hyperparameters were selected prior to conducting any experiment, and were fixed for all runs.\footnote{The parameters 16, 8 were used on CIFAR-10 by the authors. Due to the induced computational complexity, we chose smaller values. When testing the parameters 16, 8 with our method on the CIFAR-10 dataset, anomaly detection results improved.}
	We used the Adam~\cite{kingma2014adam} optimizer with default hyperparameters. Batch size for all methods was set to 128. The number of epochs was set to 200 on all benchmark models, except for training the GAN in ADGAN for which it was set to 100 and produced superior results. We trained the WRN for  epochs on the self-labeled set , to obtain approximately the same number of parameter updates as would have been performed had we trained on  for 200 epochs.
	
	\subsection{Results}
    In Table~\ref{tab:res} we present our results. The table is composed of four blocks, with each block containing several anomaly detection problems derived from the same dataset (for lack of space we omit class names from the
    tables, and those can be found in the supplementary material).
    For example, the first row contains the results for an anomaly detection problem where the normal class is class 0 in CIFAR-10 ({\em airplane}), and the anomalous instances are images from all other classes in CIFAR-10 (classes 1-9). 
    In this row (as in any other row), we see the average AUROC results over five runs and the corresponding standard error of the mean for all baseline methods. The results of our algorithm are shown in the rightmost column. OC-SVM variants and ADGAN were run once due to their time complexity. The best performing method in each row appears in bold. For example, in the CatsVsDogs experiments where {\em dog} (class 1) 
    is the ``normal'' class, the best baseline (DSEBM) achieves 0.561 AUROC. 
    Note that the trivial average AUROC is always 0.5, regardless of the proportion of normal vs. anomalous instances. Our method achieves an average AUROC of 0.888.
   
	
	Several interesting observations can be made by inspecting the numbers in Table~\ref{tab:res}. Our relative advantage is most prominent when focusing on the larger images. All baseline methods, including OC-SVM variants, which enjoy hindsight information, only achieve performance that is slightly better than random guessing in the CatsVsDogs dataset. On the smaller-sized images, the baselines can perform much better. In most cases, however, our algorithm significantly outperformed the other methods. Interestingly, in many cases where the baseline methods struggled with separating normal samples from anomalies, our method excelled. See, for instance, the cases of {\em automobile} (class 1) and {\em horse} (class 7; see the CIFAR-10 section in the table). 
	Inspecting the results on CIFAR-100 (where 20 super-classes defined the partition), we observe that our method was challenged by the diversity inside the normal class. In this case, there are a few normal classes on which our method did not perform well; see e.g., 
	\emph{non-insect invertebrates} (class 13), \emph{insects} (class 7), and \emph{household electrical devices} (class 5). In Section~\ref{sec:intuition} we speculate why this might happen. 
	We used the super-class partitioning of CIFAR-100 (instead of the 100 base classes) because labeled data for single base classes is scarce. 
	On the fashion-MNIST dataset, all methods, excluding DAGMM, performed very well, with a slight advantage to our method. The fashion-MNIST dataset was designed as a drop-in replacement for the original MNIST dataset, which is {\em slightly} more challenging. Classic models, such as SVM with an RBF kernel, can perform well on this 
task, achieving almost 90\% accuracy~\cite{Xiao2017FashionMNISTAN}.
	
	\subsection{Identifying Out-of-distribution Samples in Labeled Multi-class Datasets}
	\label{sec:multiclass_ood}
    Although it is not the main focus of this work, we have also tackled the problem of identifying out-of-distribution samples in labeled multi-class datasets (i.e., identify images that belong to a different distribution than that of the labeled dataset). 
    To this end, we created a two-headed classification model based on the WRN architecture. 
    The model has two separate softmax output layers. One for categories (e.g., cat, truck, airplane, etc.) and another for classifying transformations (our method). We use the categories softmax layer only during training.
    At test time, we only utilize the transformations softmax layer output as described in section~\ref{sec:normality_score}, but use the simplified normality score.
    When training on the CIFAR-10 dataset, and taking the tiny-imagenet (resized) dataset to be anomalies as done by \citet{liang2018enhancing} in their ODIN method, we improved ODIN's AUROC/AUPR-In/AUPR-Out results from 92.1/89.0/93.6 to 95.7/96.1/95.4, respectively. It is important to note that in contrast to our method, ODIN is {\em inapplicable} in the pure single class setting, where there are no class labels.
	
	\section{On the Intuition for Using Geometric Transformations}
	\label{sec:intuition}
	In this section we explain our intuition behind the choice of the set of transformations used in our method. Any bijection of a set (having some geometric structure) to itself is a \emph{geometric transformation}. Among all geometric transformations, we only used compositions of {\em horizontal flipping, translations}, and {\em rotations} in our model, resulting in 72 distinct transformations (see supplementary material for the entire list). In the earlier stages of this work, we tried a few non-geometric transformations (e.g., Gaussian blur, sharpening, gamma correction), which degraded performance and we abandoned them altogether.
	We hypothesize that non-geometric transformations perform worse since they can eliminate important features of the learned image set.
	
	We speculate that the effectiveness of the chosen transformation set is affected by their ability to preserve spatial information about the given ``normal'' images, as well as the ability of our classifier to predict which transformation was applied on a given transformed image.
	In addition, for a fixed type-II error rate, the type-I error rate of our method decreases the harder it gets for the trained classifier to correctly predict the identity of the transformations that were applied on anomalies.
	
	We demonstrate this idea by conducting three experiments. Each experiment has the following structure.
	We train a neural classifier to discriminate between two transformations, where the normal class is taken to be images of a single digit from the MNIST~\cite{lecun2010mnist} training set. We then evaluate our method using AUROC on a set of images comprising normal images and images of another digit from the MNIST test set. The three experiments are:


{\bf \textbullet \ \ Normal digit: `8'. Anomaly: `3'. Transformations: Identity and horizontal flip.} 
     It can be expected that due to the invariance of `8' to horizontal flip, the classifier will have difficulties learning distinguishing features. Indeed, when presented with the test set containing `3' as anomalies (which do not exhibit such invariance), our method did not perform well, achieving an AUROC of 0.646.
     
	 {\bf \textbullet \ \ Normal digit: `3'. Anomaly: `8'. Transformations: Identity and horizontal flip.} 
	 In contrast to the previous experiment, the transformed variants of digit `3' can easily be classified to the correct transformation. Indeed, our method, using the trained model for `3', achieved 0.957 AUROC in this experiment.
	 
	 {\bf \textbullet \ \ Normal digit: `8'. Anomaly: `3'.}
	 {\bf Transformations: Identity and translation by 7 pixels.} In this experiment, the transformed images are distinguishable from each other. As can be expected, our method performs well in this case, achieving an AUROC of 0.919.
	
    
	To convince ourselves that high scores given by our scoring function indicate membership in the normal class, we tested how an image would need to change in order to obtain a high normality score. This was implemented by optimizing an input image using gradient ascent to maximize the simplified variant of the normality score described in section~\ref{sec:multiclass_ood} (see, e.g., \cite{yosinski2015understanding}).
	Thus, we trained a classifier on the digit `3' from the MNIST dataset, with a few geometric transformations. We then took an arbitrary image of the digit `0' and optimized it. 
	In Figure~\ref{fig:input_opt_a} we present two such images, where the left one is the original, and the right is the result after taking 200 gradient ascent steps that ``optimize'' the original image. It is evident that the
	`0' digits have deformed, now resembling the digit `3'. 
	This illustrates the fact that the classification model has learned features relevant to the ``normal'' class. To further strengthen our hypothesis, we conducted the same experiment using images from the normal class (i.e., images of the digit `3'). We expected these images to maintain their appearance during the optimization process, since they already contain the features that should contribute to a high normality score. Figure~\ref{fig:input_opt_b} contains two examples of the process, where in each row, the left image is the initial `3', and the right is the result after taking 200 gradient ascent steps on it. As hypothesized, it is evident that the images remained roughly unchanged at the end of the optimization process (regardless of their different orientations).

    \begin{figure}
    \parbox{\dimexpr.25\linewidth-.5em}{\includegraphics[width=\linewidth]{0_optimized.png}}
    \parbox[c][3.2cm][s]{\dimexpr.2\linewidth}{\subcaption{Left: original \textbf{`0'}s. Right: the \textbf{`0'}s optimized to a normality score learned on \textbf{`3'}.}\label{fig:input_opt_a}}\hfill \parbox{\dimexpr.25\linewidth-.5em}{\includegraphics[width=\linewidth]{3_optimized.png}}
    \parbox[c][3.1cm][s]{\dimexpr.2\linewidth}{\subcaption{Left: original \textbf{`3'}s. Right: the \textbf{`3'}s optimized to a normality score learned on \textbf{`3'}.}\label{fig:input_opt_b}}
\caption{Optimizing digit images to maximize the normality score}
    \label{fig:fig:input_opt}
    \end{figure}
    
	\section{Conclusion and Future Work}
	We presented a novel method for anomaly detection of images, which learns a meaningful representation of the learned training data in a fully discriminative fashion. The proposed method is computationally efficient, and as simple to implement as a multi-class classification task. Unlike best-known methods so far, our approach completely alleviates the need for a generative component (autoencoders/GANs). Most importantly, our method significantly advances the state-of-the-art by offering a dramatic improvement over the best available anomaly detection methods. Our results open many avenues for future research. First, it is important to develop a theory that grounds the use of geometric transformations. It would be interesting to study the possibility of selecting transformations that would best serve a given training set, possibly with prior knowledge on the anomalous samples. Another avenue is explicitly optimizing the set of transformations. Due to the effectiveness of our method, it is tempting to try to adapt it to other applications, for example, open-world scenario, and maybe even use it to improve multi-class classification performance. 
	Finally, it would be interesting to attempt using 
	our techniques to leverage deep uncertainty estimation \cite{GeifmanUE18,NIPS2017_7073}, and deep active learning \cite{GeifmanE17}.


	
	








	


\begin{table}[ht!]
\centering
\begin{minipage}{\linewidth}
\caption{Average area under the ROC curve in  with SEM (over 5 runs) of anomaly detection methods. For all datasets, each model was trained on the single class, and tested against all other classes. E2E column is taken from \cite{ruff2018deep}. OC-SVM hyperparameters in RAW and CAE variants were optimized with hindsight knowledge. The best performing method in each experiment is in bold.\\}
\label{tab:res}
\begin{tabular}{c c c c c c c c c}
\toprule[1.5pt]
\multirow{2}{*}{\head{Dataset}} & \multirow{2}{*}{\head{}} & \multicolumn{3}{c}{\head{OC-SVM}} & \multirow{2}{*}{\head{DAGMM}} & \multirow{2}{*}{\head{DSEBM}} & \head{AD-} & \multirow{2}{*}{\head{OURS}}\\
& & RAW & CAE & E2E & & & \head{GAN} & \\
\midrule
\multirow{11}{*}{\shortstack{CIFAR-10\32x32x3)}} 
& 0 & 68.0 & 68.4 & - & 43.43.9 & 64.00.2 & 63.1 & \textbf{74.70.4}\\
& 1 & 63.1 & 63.6 & - & 49.52.7 & 47.90.1 & 54.9 & \textbf{68.50.2}\\
& 2 & 50.4 & 52.0 & - & 66.11.7 & 53.74.1 & 41.3 & \textbf{74.00.5}\\
& 3 & 62.7 & 64.7 & - & 52.61.0 & 48.40.5 & 50.0 & \textbf{81.00.8}\\
& 4 & 59.7 & 58.2 & - & 56.93.0 & 59.76.3 & 40.6 & \textbf{78.40.5}\\
& 5 & 53.5 & 54.9 & - & 52.42.2 & 46.61.6 & 42.8 & \textbf{59.11.0}\\
& 6 & 55.9 & 57.2 & - & 55.01.1 & 51.70.8 & 51.1 & \textbf{81.80.2}\\
& 7 & 64.4 & 62.9 & - & 52.83.7 & 54.81.6 & 55.4 & \textbf{65.00.1}\\
& 8 & 66.7 & 65.6 & - & 53.24.8 & 66.70.2 & 59.2 & \textbf{85.50.4}\\
& 9 & 70.1 & 74.1 & - & 42.52.5 & 71.21.2 & 62.7 & \textbf{90.60.1}\\
& 10 & 83.0 & 84.1 & - & 52.73.9 & 78.31.1 & 79.8 & \textbf{87.60.2}\\
& 11 & 59.7 & 58.0 & - & 46.42.4 & 62.70.7 & 53.7 & \textbf{83.90.6}\\
& 12 & 68.7 & 68.5 & - & 42.73.1 & 66.80.0 & 58.9 & \textbf{83.20.3}\\
& 13 & \textbf{65.0} & 64.6 & - & 45.40.7 & 52.60.1 & 57.4 & 58.00.4\\
& 14 & 50.7 & 51.2 & - & 57.21.3 & 44.00.6 & 39.4 & \textbf{92.10.2}\\
& 15 & 63.5 & 62.8 & - & 48.81.5 & 56.80.1 & 55.6 & \textbf{68.30.1}\\
& 16 & 68.3 & 66.6 & - & 54.43.1 & 63.10.1 & 63.3 & \textbf{73.50.2}\\
& 17 & 71.7 & 73.7 & - & 36.42.3 & 73.01.0 & 66.7 & \textbf{93.80.1}\\
& 18 & 50.2 & 52.8 & - & 52.41.4 & 57.71.6 & 44.3 & \textbf{90.70.1}\\
& 19 & 57.5 & 58.4 & - & 50.31.0 & 55.50.7 & 53.0 & \textbf{85.00.2}\\
\cdashline{2-9}
&   & 62.6 & 63.1 & - & 50.5 & 58.8 & 54.7 & \textbf{78.7}\\
\midrule
\multirow{11}{*}{\shortstack{Fashion-\\MNIST\64x64x3)}} 
& 0 & 50.4 & 55.2 & - & 43.40.5 & 47.11.7 & 50.7 & \textbf{88.30.3}\\
& 1 & 53.0 & 49.9 & - & 52.01.9 & 56.11.2 & 48.1 & \textbf{89.20.3}\\
\cdashline{2-9}
&   & 51.7 & 52.5 & - & 47.7 & 51.6 & 49.4 & \textbf{88.8}\\

\bottomrule[1.5pt]
\end{tabular}
\end{minipage}
\end{table}


\section*{Acknowledgements}
This research was supported by the Israel Science Foundation (grant No. 81/017).
\bibliographystyle{abbrvnat}
\bibliography{citations}

\newpage

\setcounter{section}{0}
\renewcommand{\thesection}{\Alph{section}}

\section{List of Geometric Transformations Used By Our Method}
In all our experiments, except for those described in Section~6 we used a fixed set of 72 geometric transformations. These transformations can be succinctly described as the composition of the following transformations, applied on an image in the order they are listed:

\begin{itemize}
    \item \textbf{Horizontal flip}: denoted as , where . The parameter  indicates whether the flipping occurs, or the transformation is the identity.
\item \textbf{Translation}: denoted as , where . Applying this transformation on an image translates it by 0.25 of its height, and 0.25 of its width, in both dimensions. The direction of the translation in each axis is determined by  and , where  means no translation. A reflection is used to complete missing pixels. 
    \item \textbf{Rotation by multiples 90 degrees}: denoted as , where . Applying this transformation on an image rotates it counter-clockwise by  degrees.
\end{itemize}

The entire set of transformations is thus given by 

By taking all possible compositions, we obtain a total of  transformations,
where each composition is fully defined by a tuple, .
For example, the identity transformation is .

\section{Algorithm}
We present here a full and detailed algorithm of our deep anomaly detection technique. 
The function  is the Digamma function, and its inverse is calculated numerically using five Newton-Raphson iterations.

\begin{algorithm}[H]
\caption{Deep Anomaly Detection Using Geometric Transformations}\label{alg:anomaly_trans}
\begin{algorithmic}[1]
\Statex \textbf{Input:} : a set of ``normal'' images. : a set of geometric transformations. : a softmax classifier parametrized by .
\Statex \textbf{Output:} A normality scoring function .
\Procedure{GetNormalityScore}{}
\State 
\While {not converged}
    \State Train  on the labeled set 
\EndWhile
\State{}
\For {}
    \State{}
    \State{}
    \State{}
    \State{ } \Comment{Initialization from~\cite{wicker2008maximum}}
    \While {not converged}
        \State{} \Comment{Fixed point method from~\cite{minka2000estimating}}
    \EndWhile
\EndFor
\State \textbf{return}  
\EndProcedure
\end{algorithmic}
\end{algorithm}



\newpage
\section{Single Class Names}
The following table describes the content of all single classes.
\begin{table}[!ht]
\centering
\begin{tabular}{ c c c }
\toprule[1.5pt]
\head{Dataset} & \head{} & \head{Single Class Name}\\
\midrule
\multirow{10}{*}{CIFAR-10}  & 0 & Airplane\\
                            & 1 & Automobile\\
                            & 2 & Bird\\
                            & 3 & Cat\\
                            & 4 & Deer\\
                            & 5 & Dog\\
                            & 6 & Frog\\
                            & 7 & Horse\\
                            & 8 & Ship\\
                            & 9 & Truck\\
\midrule
\multirow{20}{*}{CIFAR-100} & 0 & Aquatic mammals\\
                            & 1 & Fish\\
                            & 2 & Flowers\\
                            & 3 & Food containers\\
                            & 4 & Fruit and vegetables\\
                            & 5 & Household electrical devices\\
                            & 6 & Household furniture\\
                            & 7 & Insects\\
                            & 8 & Large carnivores\\
                            & 9 & Large man-made outdoor things\\
                            & 10 & Large natural outdoor scenes\\
                            & 11 & Large omnivores and herbivores\\
                            & 12 & Medium-sized mammals\\
                            & 13 & Non-insect invertebrates\\
                            & 14 & People\\
                            & 15 & Reptiles\\
                            & 16 & Small mammals\\
                            & 17 & Trees\\
                            & 18 & Vehicles 1\\
                            & 19 & Vehicles 2\\
\midrule
\multirow{10}{*}{Fashion-MNIST} & 0 & Ankle-boot\\
                                & 1 & Bag\\
                                & 2 & Coat\\
                                & 3 & Dress\\
                                & 4 & Pullover\\
                                & 5 & Sandal\\
                                & 6 & Shirt\\
                                & 7 & Sneaker\\
                                & 8 & T-shirt\\
                                & 9 & Trouser\\
\midrule
\multirow{2}{*}{CatsVsDogs} & 0 & Cat\\
                            & 1 & Dog\\

\bottomrule[1.5pt]
\end{tabular}
\end{table}

\section{Examples from the Fashion-MNIST Dataset}
\includegraphics[width=\textwidth]{fashion-mnist-sprite.png}

\section{Area Under the Precision-Recall Curve}
When dealing with highly skewed datasets, precision-recall curves may be considered more informative
than the area under the ROC.
For completeness, we provide results of all baseline models in terms of area under the precision-recall curve. 
This score can be calculated in two ways: anomalies treated as the positive class (AUPR-out), and anomalies treated as the negative class (AUPR-in).

\begin{table}[ht!]
\centering
\caption{Average area under the PR curve in  with SEM (computed over 5 runs) of anomaly detection methods, when anomalies are taken as the negative class (AUPR-In). For all datasets, each model was trained on the single class, and tested against all other classes. The best performing method in each experiment is in bold.\\}
\label{tab:aupr-in}
\begin{tabular}{c c c c c c c c}
\toprule[1.5pt]
\multirow{2}{*}{\head{Dataset}} & \multirow{2}{*}{\head{}} & \multicolumn{2}{c}{\head{OC-SVM}} & \multirow{2}{*}{\head{DAGMM}} & \multirow{2}{*}{\head{DSEBM}} & \head{AD-} & \multirow{2}{*}{\head{OURS}}\\
& & RAW & CAE & & & \head{GAN} & \\
\midrule
\multirow{11}{*}{\shortstack{CIFAR-10\32x32x3)}} & 0 & 11.7 & \textbf{14.1} & 4.50.5 & 8.90.1 & 7.1 & 14.00.3\\
 & 1 & 12.9 & \textbf{14.9} & 5.80.9 & 5.10.0 & 5.8 & 12.50.3\\
 & 2 & 4.7 & 4.9 & 9.61.0 & 5.91.1 & 4.2 & \textbf{16.00.7}\\
 & 3 & 15.4 & 21.5 & 5.50.3 & 5.00.1 & 5.1 & \textbf{41.21.0}\\
 & 4 & 10.8 & 17.9 & 6.51.1 & 9.72.4 & 3.8 & \textbf{30.51.2}\\
 & 5 & 7.1 & \textbf{11.2} & 5.70.5 & 4.60.2 & 4.1 & 8.80.3\\
 & 6 & 6.2 & 7.5 & 6.30.5 & 5.20.1 & 5.1 & \textbf{36.11.0}\\
 & 7 & 9.0 & \textbf{13.0} & 5.80.7 & 7.60.7 & 6.7 & 9.30.1\\
 & 8 & 7.8 & 7.8 & 5.90.9 & 7.90.1 & 5.7 & \textbf{36.20.9}\\
 & 9 & 9.4 & 11.9 & 4.00.2 & 10.60.9 & 6.7 & \textbf{39.80.5}\\
 & 10 & 28.1 & 32.1 & 6.30.7 & 27.81.2 & 19.5 & \textbf{41.00.8}\\
 & 11 & 6.3 & 6.0 & 4.60.3 & 7.00.2 & 5.3 & \textbf{32.11.4}\\
 & 12 & 9.4 & 10.3 & 4.10.3 & 8.40.0 & 6.6 & \textbf{32.00.7}\\
 & 13 & 12.6 & \textbf{15.2} & 4.60.2 & 6.30.1 & 9.1 & 6.70.1\\
 & 14 & 15.2 & 53.6 & 6.10.4 & 4.10.1 & 3.7 & \textbf{63.60.5}\\
 & 15 & 8.9 & 10.3 & 5.00.3 & 7.50.1 & 6.4 & \textbf{10.40.1}\\
 & 16 & 12.8 & \textbf{15.6} & 6.10.5 & 8.10.0 & 8.3 & 13.40.2\\
 & 17 & 10.0 & 12.1 & 3.70.1 & 14.32.9 & 7.3 & \textbf{66.40.7}\\
 & 18 & 4.7 & 5.1 & 5.40.3 & 6.40.4 & 3.8 & \textbf{44.80.3}\\
 & 19 & 7.3 & 10.6 & 5.10.3 & 5.70.2 & 5.2 & \textbf{26.70.3}\\
\cdashline{2-8}
&   & 10.5 & 14.8 & 5.5 & 8.3 & 6.5 & \textbf{29.1}\\
\midrule
\multirow{11}{*}{\shortstack{Fashion-\\MNIST\64x64x3)}} & 0 & 50.5 & 54.6 & 45.40.3 & 49.01.3 & 51.0 & \textbf{90.60.3}\\
 & 1 & 52.1 & 40.7 & 56.74.7 & 54.01.0 & 48.6 & \textbf{91.10.2}\\
\cdashline{2-8}
&   & 51.3 & 47.6 & 51.1 & 51.5 & 49.8 & \textbf{90.9}\\

\bottomrule[1.5pt]
\end{tabular}
\end{table}

\begin{table}[!ht]
\centering
\caption{Average area under the PR curve in  with SEM (computed over 5 runs) of anomaly detection methods, when anomalies are taken as the positive class (AUPR-Out). For all datasets, each model was trained on the single class, and tested against all other classes. The best performing method in each experiment is in bold.\\}
\label{tab:aupr-out}
\begin{tabular}{c c c c c c c c}
\toprule[1.5pt]
\multirow{2}{*}{\head{Dataset}} & \multirow{2}{*}{\head{}} & \multicolumn{2}{c}{\head{OC-SVM}} & \multirow{2}{*}{\head{DAGMM}} & \multirow{2}{*}{\head{DSEBM}} & \head{AD-} & \multirow{2}{*}{\head{OURS}}\\
& & RAW & CAE & & & \head{GAN} & \\
\midrule
\multirow{11}{*}{\shortstack{CIFAR-10\32x32x3)}} & 0 & 97.3 & 97.3 & 93.90.6 & 96.90.0 & 97.0 & \textbf{98.00.0}\\
 & 1 & 96.9 & 96.8 & 94.70.5 & 94.80.0 & 95.9 & \textbf{97.40.0}\\
 & 2 & 95.4 & 95.7 & 97.30.1 & 95.80.5 & 93.8 & \textbf{97.80.0}\\
 & 3 & 96.8 & 96.7 & 95.20.1 & 94.40.1 & 94.7 & \textbf{98.20.1}\\
 & 4 & 96.3 & 96.0 & 96.40.3 & 96.40.7 & 93.9 & \textbf{98.20.1}\\
 & 5 & \textbf{97.3} & 95.3 & 95.10.3 & 94.20.2 & 93.9 & 95.90.1\\
 & 6 & 95.9 & 96.3 & 96.10.2 & 95.40.2 & 95.0 & \textbf{98.50.0}\\
 & 7 & 96.9 & 96.7 & 95.40.5 & 95.10.3 & 95.6 & \textbf{96.90.0}\\
 & 8 & 97.4 & 97.3 & 95.60.6 & 97.40.0 & 96.8 & \textbf{99.00.0}\\
 & 9 & 97.8 & 98.1 & 94.50.4 & 97.80.1 & 97.1 & \textbf{99.40.0}\\
 & 10 & 98.8 & 98.9 & 95.00.4 & 98.30.1 & 98.6 & \textbf{99.10.0}\\
 & 11 & 96.7 & 96.5 & 94.60.3 & 97.00.1 & 95.9 & \textbf{98.80.0}\\
 & 12 & 97.4 & 97.4 & 94.20.5 & 97.40.0 & 96.3 & \textbf{98.70.0}\\
 & 13 & \textbf{97.0} & 96.7 & 94.20.2 & 94.90.0 & 95.4 & 96.10.0\\
 & 14 & 97.5 & 97.6 & 96.20.1 & 94.70.1 & 94.0 & \textbf{99.40.0}\\
 & 15 & 97.0 & 96.9 & 94.50.2 & 95.40.0 & 95.6 & \textbf{97.40.0}\\
 & 16 & 97.4 & 97.1 & 95.50.4 & 96.80.0 & 96.8 & \textbf{97.90.0}\\
 & 17 & 97.9 & 98.1 & 93.90.5 & 97.90.1 & 97.6 & \textbf{99.60.0}\\
 & 18 & 95.5 & 95.8 & 95.70.2 & 96.30.1 & 94.8 & \textbf{99.40.0}\\
 & 19 & 96.5 & 96.5 & 95.20.2 & 95.70.1 & 95.7 & \textbf{98.90.0}\\
\cdashline{2-8}
&   & 97.0 & 96.9 & 95.2 & 96.1 & 95.7 & \textbf{98.2}\\
\midrule
\multirow{11}{*}{\shortstack{Fashion-\\MNIST\64x64x3)}} & 0 & 57.2 & 53.5 & 46.30.4 & 47.31.1 & 50.0 & \textbf{83.30.4}\\
 & 1 & 53.3 & 74.9 & 58.24.8 & 55.81.1 & 48.6 & \textbf{85.40.5}\\
\cdashline{2-8}
&   & 55.3 & 64.2 & 52.2 & 51.5 & 49.3 & \textbf{84.3}\\

\bottomrule[1.5pt]
\end{tabular}
\end{table}

\end{document}