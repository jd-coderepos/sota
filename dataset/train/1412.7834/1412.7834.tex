\documentclass[runningheads,proof]{llncs}
\usepackage[left]{lineno}

\usepackage{hyperref}

\usepackage{amsmath,amssymb,latexsym}
\usepackage{paralist,array,url}
\usepackage[ruled,lined,linesnumbered,boxed,vlined]{algorithm2e}
\usepackage{afterpage}
\usepackage{pgfplots}

\usetikzlibrary{patterns}
\usepgfplotslibrary{groupplots}



\newcommand{\set}[1]{\left\{#1\right\}}

\title{Pattern Backtracking Algorithm\\
for the Workflow Satisfiability Problem\\
with User-Independent Constraints}
\titlerunning{Pattern Backtracking Algorithm for the Workflow Satisfiability Problem}
\author{
D. Karapetyan\inst{1}
\and A. Gagarin\inst{2}
\and G. Gutin\inst{2}
}
\institute{
University of Nottingham, UK\\ 
\email{Daniel.Karapetyan@gmail.com}\\
           \and
Royal Holloway, University of London, UK \email{\{Andrei.Gagarin,G.Gutin\}@rhul.ac.uk}\\
           }
           
\usepackage{color}
\newcommand{\todo}[1]{\textbf{\textcolor{red}{#1}}}





\makeatletter
\g@addto@macro{\UrlBreaks}{\UrlOrds}
\makeatother

\begin{document}


\maketitle
\begin{abstract}
The workflow satisfiability problem (WSP) asks whether there exists an assignment of authorised users to the steps in a workflow specification, subject to certain constraints on the assignment.
(Such an assignment is called valid.)
The problem is NP-hard even when restricted to the large class of user-independent constraints.
Since the number of steps  is relatively small in practice, it is natural to consider a parametrisation of the WSP by .
We propose a new fixed-parameter algorithm to solve the WSP with user-independent constraints.
The assignments in our method are partitioned into equivalence classes such that the number of classes is exponential in  only.
We show that one can decide, in polynomial time, whether there is a valid assignment in an equivalence class.
By exploiting this property, our algorithm reduces the search space to the space of equivalence classes, which it browses within a backtracking framework, hence emerging as an efficient yet relatively simple-to-implement or generalise solution method.
We empirically evaluate our algorithm against the state-of-the-art methods and show that it clearly wins the competition on the whole range of our test problems and significantly extends the domain of practically solvable instances of the WSP.
\end{abstract}

\section{Introduction}\label{sec:intro}
In the \emph{workflow satisfiability problem} (WSP), we aim at assigning authorised users to the steps in a workflow specification, subject to some constraints arising from business rules and practices.
The WSP has applications in information access control (e.g.\ see~\cite{ANSI04,BaBuKa14,BeFeAt99}), and it is extensively studied in the security research community~\cite{BaBuKa14,BeFeAt99,Cr05,WaLi10}.  
In the WSP, we are given a set  of \emph{users}, a set  of \emph{steps}, a set  of \emph{authorisation lists}, where  denotes the set of steps for which user  is authorised, and a set  of \emph{(workflow) constraints}.
In general, a \emph{constraint}  can be described as a pair , where  is the \emph{scope} of the constraint and  is a set of functions from  to  which specifies those assignments of steps in  to users in  that satisfy the constraint (authorisations disregarded).  Authorisations and constraints described in WSP literature are relatively simple such that we may assume that all authorisations and constraints can be checked in polynomial time (in ,  and ).


Given a \emph{workflow} ,  is \emph{satisfiable} if there exists a function  such that
\begin{itemize}
\item for all ,  (each step is allocated to an authorised user);
\item for all ,  (every constraint is satisfied).
\end{itemize}
A function  is an \emph{authorised} (\emph{eligible}, \emph{valid}, respectively) \emph{complete plan} if it satisfies the first condition above (the second condition, both conditions, respectively).



For example, consider the following instance of WSP\@.
The step and user sets are  and . 
The authorisation lists are , , , . 
The constraints are  (the same user must be assigned to  and ),  ( and  must be assigned to different users),  , and . 
Since the function  assigning  to  and ,  to , and  to  is a valid complete plan, the workflow is satisfiable.  

Clearly, not every workflow is satisfiable, and hence
it is important to be able to determine whether a workflow is satisfiable or not and, if it is satisfiable, to find a valid complete plan.
Unfortunately, the WSP is  NP-hard~\cite{WaLi10} and, since the number  of steps is usually relatively small in practice (usually  and we assume, in what follows, that ), Wang and Li \cite{WaLi10} introduced its parameterisation\footnote{We use terminology of the recent monograph \cite{DoFe13} on parameterised algorithms and complexity.}  by . Algorithms for this parameterised problem were also studied in \cite{FAW2014,CoCrGaGuJo13,JOCO2014,CrGuYe13}. While in general the WSP is W[1]-hard \cite{WaLi10}, 
the WSP restricted\footnote{While we consider special families of constraints, we do not restrict authorisation lists.} to some practically important families of constraints is fixed-parameter tractable (FPT) ~\cite{CoCrGaGuJo13,CrGuYe13,WaLi10}. (Recall that a problem parameterised by  is FPT if it can be solved by an FPT algorithm, i.e.\ an algorithm of running time , where  is an arbitrary function depending on  only, and  suppresses not only constants, but also polynomial factors in  and other parameters of the problem formulation.)

Many business rules are not concerned with the identities of the users that perform a set of steps.  Accordingly, we say a constraint  is \emph{user-independent} if, whenever  and  is a permutation, then . 
In other words, given a complete plan  that satisfies  and any permutation , the plan , where , also satisfies .
The class of user-independent constraints is general enough in many practical cases; for example, all the constraints defined in the ANSI RBAC standard \cite{ANSI04} are user-independent. 
Most of the constraints studied in \cite{FAW2014,JOCO2014,CrGuYe13,WaLi10} and other papers are also user-independent. 
Classical examples of user-independent constraints are the requirements that two steps are performed by either two different users ({\em separation-of-duty}), or the same user ({\em binding-of-duty}). More complex constraints state that at least/at most/exactly  users are required to complete some sensitive set of steps (these constraints belong to the family of \emph{counting} constraints), where  is usually small. 
A simple reduction from {\sc Graph Colouring} shows that the WSP restricted to the separation-of-duty constraints is already NP-hard \cite{WaLi10}.

The WSP is an important applied problem and is thoroughly studied
in the literature.  However, as was shown by Cohen et al.~\cite{FAW2014}, 
the methods developed so far  were 
capable of solving user-independent WSP instances only for relatively small values of .  
In this paper we propose a new approach that, compared to the existing solution methods, significantly extends the number of steps in practically solvable instances now covering the values of  expected in the majority of real-world instances. 
Importantly, the proposed method is relatively simple to implement or extend with new constraints, such that its accessibility is similar to that of SAT-solvers used by practitioners~\cite{WaLi10}.



The proposed solution method is a deterministic algorithm that uses backtracking to browse the space of all the equivalence classes of partial solutions. 
We show that it is possible to test efficiently if there exists an authorised plan in a given equivalence class.
This makes our algorithm FPT as the number of equivalence classes is exponential in  only.







\section{Patterns and the User-Iterative Algorithm}
\label{sec:patterns-and-ui}




A \emph{plan} is a function , where  (note that if  then  is a complete plan).  We define an \emph{equivalence relation} on the set of all plans, which is a special case of an equivalence relation defined in \cite{CoCrGaGuJo13}.
For user-independent constraints, two plans  and  are \emph{equivalent}, denoted by , if and only if , and  if and only if  for every .
Assuming an ordering  of steps ,
every plan  can be encoded into a \emph{pattern}  defined by:

The pattern  uniquely encodes the equivalence class of , and  for every  in that equivalence class~\cite{CoCrGaGuJo13}. The pattern  represents an assignment of steps in  to some users in any plan of the equivalence class of .  
We say that a pattern is \emph{complete} if  for .

The state-of-the-art FPT algorithm for the WSP with counting constraints proposed in~\cite{FAW2014} and called here User-Iterative (UI), iterates over the set of users and gradually computes all encoded equivalence classes of valid plans until it finds a complete solution to the problem, or all the users have been considered. 
Effectively, it uses the breadth-first search in the space of plans.  
In the breadth-first search tree, equivalent plans can be generated but they are detected efficiently using patterns and the corresponding search branches are then merged together.  
Since the UI algorithm generates a polynomial number of plans per equivalence class and the number of equivalence classes is exponential in  only, the UI algorithm is FPT.
The results of~\cite{FAW2014,JOCO2014} show that the generic user-iterative FPT algorithm of~\cite{CoCrGaGuJo13} has a practical value, and its implementations are able to outperform the well-known pseudo-Boolean SAT solver SAT4J~\cite{BePa10}.


In this paper we propose a new FPT solution method for the WSP which also exploits equivalence classes and patterns but in a more efficient manner.  
Among other advantages, our algorithm never generates multiple plans within the same equivalence class.  
For further comparison of our algorithm with the UI algorithm, see Section~\ref{sec:comparison}.


























\section{The Pattern-Backtracking Algorithm}
\label{sec:pb}

We call our new method \emph{Pattern-Backtracking} (PB) as it uses the backtracking approach to browse the search space of patterns.
To describe it, we introduce several additional notations.
We will say that a plan  is \emph{authorised} if  for every , \emph{eligible} if it does not violate any constraint in , and \emph{valid} if it is both authorised and eligible.
Similarly, a pattern  is \emph{authorised}, \emph{eligible} or \emph{valid} if there exists a plan  such that  and  is authorised, eligible or valid, respectively.
By  we denote the value  in .  
We also use notations  for the set of users authorised for step  and  for all the steps assigned to the same user encoded by the value of  in \@.
Note that  for  for any complete pattern.





In Section~\ref{sec:pattern-validity} we show how to find a valid plan for an eligible pattern, which is an essential part of our algorithm, and in Section~\ref{sec:pb-backtracking} we describe the algorithm itself.


\subsection{Pattern Validity Test}
\label{sec:pattern-validity}

The PB algorithm searches the space of patterns; once an eligible complete pattern  is found, we need to check if it is valid and, if it is, then to find a plan  such that .
The following theorem allows us to address these two questions efficiently.

For a complete pattern , let  (note that the cardinality of the set  may be smaller than ).
Let  be a bipartite graph, where  if and only if  for each , . 



\begin{theorem}
\label{th:matching}
 A pattern  is authorised if and only if  has a matching of size .
\end{theorem}
\begin{proof}
Suppose  is a matching of size  in . 
Construct a plan  as follows: for each edge  and , set .  
Since  covers  for every  and  is a complete pattern, the above procedure defines  for every step .
Hence,  is a complete plan.
Now observe that, for each , all the steps  are assigned to exactly one user, and if  for some , then  by definition of matching.
Therefore . 
Observe also that  respects the authorisation lists; for each edge  and each step , we guarantee that . 
Thus, plan  is authorised and, hence, pattern  is also authorised.

\smallskip
On the other hand, assume there exists an authorised plan  such that  for a given pattern \@.  
Let .  
Construct a set  as follows: .  
Consider a pair , and find some .
Note that, as  and by definition of pattern,  for every .  
Since  is authorised,  for every , i.e.\  and .  In other words,  is a subset of edges of .

Now notice that, for each , there exists at most one edge  as  for every .  Moreover, for each , there exists at most one edge  as otherwise there would exist some  such that  and , which violates .  Hence, the edge set  is disjoint.  Finally,  because  is non-empty for every .  We conclude that  is a matching in  of size .
\qed
\end{proof}

Theorem~\ref{th:matching} implies that, to determine whether an eligible pattern  is valid, it is enough to construct the bipartite graph  and to find a maximum size matching in .  
It also provides an algorithm for converting a maximum matching  of size  in  into a valid plan  such that .

The matching problem arising in Theorem~\ref{th:matching} has some interesting properties:
\begin{itemize}
	\item The bipartite graph  is highly unbalanced as , and we assume that .  
	It is easy to see that the maximum length of an augmenting path in  is  and, hence, the time complexity of the Hungarian and Hopcroft-Karp methods are  and , respectively.
	\item We are interested only in matchings of size .  If the maximum matching is of a smaller size, we do not need to retrieve it.
	\item Once a matching of size  is found, the PB algorithm terminates since a valid plan is found.  
	However, the algorithm might test an exponential number (in ) of graphs with the maximum matching of size smaller than .
	Hence, we are mainly interested in time of checking whether the maximum matching is smaller than .
\end{itemize}

To exploit the above features, we use the Hungarian method with a speed-up heuristic provided by the following proposition.
\begin{proposition}
\label{lemma:matching}
If , , is a matching in the graph  such that there exists no -augmenting path in  starting at a vertex , then there is no matching covering all vertices of  in .
\end{proposition}
\begin{proof}
W.l.o.g, assume that  and . Now suppose that  has a matching  covering all of .
Consider the symmetric difference of two matchings . 
Since every vertex of  has degree at most , the graph induced by  consists of some disjoint paths and even cycles having edges alternating between  and . 
Since  is not in  but covered by , it is an end point of one of the alternating paths in , say . 
Now, it is possible to see that  is an augmenting path in  with respect to the matching ; since, starting at , every time we use an edge of  to go from a vertex in  to a vertex in ,  must have an end point in a vertex of  not covered by  ( covers all the vertices in ). 
This contradicts the fact that there is no augmenting path in  starting at  with respect to .\squareforqed
\end{proof}

The result of Proposition~\ref{lemma:matching} allows us to terminate the Hungarian algorithm as soon as a vertex  is found such that no augmenting path starting from  can be obtained.
Construction of the graph takes  time, and solving the maximum matching problem in  with the Hungarian method takes  time.



\subsection{The Backtracking Algorithm}
\label{sec:pb-backtracking}

The PB algorithm uses a backtracking technique to search the space of patterns, and for each eligible pattern, it verifies whether such a pattern is valid.  
If a valid pattern  is found, the algorithm returns a complete plan  such that , see Section~\ref{sec:pattern-validity} for details.  
If no valid pattern is found during the search, the instance is unsatisfiable.


The calling procedure for the PB algorithm is shown in Algorithm~\ref{alg:start}, which in turn calls the recursive search function in Algorithm~\ref{alg:recursion}. 
The recursive function tries all possible extensions  of the current pattern  by adding one new step  to it (line~\ref{line:extend-pattern}).
The step  is selected heuristically (line~\ref{line:select-s}), where function  is an empirically tuned function indicating the importance of step  in narrowing down the search space.  
The implementation of  depends on the specific types of constraints involved in the instance and should reflect the intuition regarding the structure of the problem.
See (\ref{eq:rho}) in Section~\ref{sec:experiments} for a particular implementation of  for the types of constraints we used in our computational study.
Note that our branching heuristic dynamically changes the steps ordering used in the pattern definition in Section~\ref{sec:patterns-and-ui}.
Nevertheless, this does not affect any theoretical properties of the pattern.

We use a heuristic (necessary but not sufficient) test (lines~\ref{line:authorisation-heuristic-begin}--\ref{line:authorisation-heuristic-end} of Algorithm~\ref{alg:recursion}) to check whether the pattern  can be authorised; that allows us to prune branches which are easily provable to include no authorised patterns.

In line~\ref{line:pattern-eligibility-test}, the algorithm checks whether the new pattern  violates any constraints and, if not, then executes the recursive call.



\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}

\begin{algorithm}[tb]
\caption{Backtracking search initialisation (entry procedure of PB)\label{alg:start}}
\Input {WSP instance }
\Output {Valid plan  or UNSAT}

Initialise  for each \;
\;

\Return{} ( may be UNSAT here)\;
\end{algorithm}

{\small
\begin{algorithm}[tb]
\caption{Recursion (recursive function for backtracking search)\label{alg:recursion}}
\Input {Pattern }
\Output {Eligible plan or UNSAT if no eligible plan exists in this branch of the search tree}
Initialise the set  of assigned steps \;
\If {}
{
	Verify if pattern  is valid (using the matching algorithm of Theorem~\ref{th:matching})\;
	\If {pattern  is valid}
	{
		\Return {plan  realising }\;
	}
	\Else
	{
		\Return {UNSAT}\;
	}
}
\Else
{
	Select unassigned step  that maximises \; \label{line:select-s}
	Calculate \;
	\For {}
	{
		Set  to obtain a new pattern \; \label{line:extend-pattern}
		Compute the set of steps  assigned to : \; \label{line:authorisation-heuristic-begin}
		\If {}
		{
			Proceed to the next value of  (reject )\; \label{line:authorisation-heuristic-end}
		}
		
		\If { is an eligible pattern}
		{\label{line:pattern-eligibility-test}
			\;
			\If {}
			{
				\Return{}\;
			}
		}
	}
}

\Return{UNSAT (for a particular branch of recursion; does not mean that the whole instance is unsat)}\;
\end{algorithm}
}





\section{Comparison of the PB and UI Algorithms} 
\label{sec:comparison}

In this section we analyse the time and memory complexity of the PB algorithm and compare it to the UI algorithm.
 


Observe that each internal node (corresponding to an incomplete plan) in the search tree of the PB algorithm has at least two children, and each leaf in this tree corresponds to a complete pattern.
Thus, the total number of patterns considered by the PB algorithm is less than twice the number of complete patterns. 
Observe that the number of complete patterns equals the number of partitions of a set of size , i.e.\ the th Bell number . 
Finally, observe that the PB algorithm spends time polynomial in  on each node of the search tree.\footnote{Assuming that the WSP instance does not include any exotic constraints.}
Thus, the time complexity of the PB algorithm is .
The PB algorithm follows the depth-first search order and, hence, stores only one pattern at a time.  
At each leaf node, it also solves the matching problem generating a graph with  edges.  
Hence, the memory complexity of the algorithm is .

It is interesting to compare the PB algorithm to the UI algorithm (briefly described in Section~\ref{sec:patterns-and-ui}).
Despite both algorithms using the idea of equivalence classes and being FPT, they have very different working principles and properties.




\begin{enumerate}
	\item Observe that, in the worst case, the UI algorithm may store all patterns, and the number of patterns is . Indeed, consider a pattern  and a set  Then each partition of the set corresponds to a pattern of , where  if and only if  and  are in the same subset of the partition.
	Therefore,  the UI algorithm takes  memory, which is in sharp contrast to the PB algorithm that requires very little memory.
	Considering that, e.g.\ , memory consumption poses a serious bottleneck for the UI algorithm as the RAM capacity of any mainstream machine is well below the 
	value of .
	Moreover, the UI algorithm accesses a large volume of data in a non-sequential order, which might have a dramatic effect on the algorithm's performance when implemented on a real machine as shown in~\cite{KaGuGo}.


	\item From the practical point of view, the PB algorithm considers less
patterns than the UI algorithm ( vs.\ ) as
the PB algorithm assigns the steps in a strict order, avoiding generation of duplicate patterns.  Moreover, the
PB algorithm generates each pattern at most once, while the UI
algorithm is likely to generate a pattern several times rejecting the duplicates afterwards.  


	\item Both algorithms use heuristics to determine the order in which the search tree is explored.
	However, while the UI algorithm has to use a certain fixed order of users for all the search branches, the PB algorithm has the flexibility of changing the order of steps in each branch of the search.
	Note that the order of assignments is crucial to the algorithm's performance as it can help to prune branches early.
\end{enumerate}




\section{Computational Experiments}
\label{sec:experiments}

In this section we empirically verify the efficiency of the PB algorithm.  We compare the following WSP solvers:
\begin{description}
	\item[PB] The algorithm proposed in this paper;
	\item[UI] Another FPT algorithm proposed in~\cite{CoCrGaGuJo13} and evaluated in \cite{FAW2014,JOCO2014};
	\item[SAT4J] A pseudo-Boolean SAT formulation~\cite{FAW2014,JOCO2014} of the problem solved with SAT4J.
\end{description}

Due to the difficulty of acquiring real-world WSP instances~\cite{FAW2014,WaLi10}, we use the random instance generator described in~\cite{FAW2014}.
Three families of user-independent constraints are used: \emph{not-equals} (also called \emph{separation-of-duty}) constraints \mbox{}, \emph{at-most-} constraints  and \emph{at-least-} constraints .
A not-equals constraint  is satisfied by a complete plan  if and only if .
An at-most- constraint  is satisfied if and only if , where  is the scope of the constraint.
Similarly, an at-least- constraint  is satisfied if and only if .
We do not explicitly consider the widely used binding-of-duty constraints, that require two steps to be assigned to one user, as those can be trivially eliminated during preprocessing.
While the binding-of-duty and separation-of-duty constraints provide the basic modelling capabilities, the at-most- and at-least- constraints impose more general ``confidentiality'' and ``diversity'' requirements on the workflow, which can be important in some business environments.

The instance generator (available for downloading~\cite{SourceCodes}) takes four parameters: the number of steps , the number of not-equals constraints , the number of at-most and at-least constraints  and the random generator seed value.
Each instance has  users.  
For each user , it generates a uniformly random authorisation list  such that  is selected uniformly from  at random.  
It also generates  distinct not-equals,  at-most and  at-least constraints uniformly at random.
All at-most and at-least constraints are of the form , where  and .

Our test machine is based on two Intel Xeon CPU E5-2630 v2 (2.6~GHz) and has 32~GB RAM installed.  
Hyper-threading is enabled, but we never run more than one experiment per physical CPU core concurrently.  
The PB algorithm is implemented in C\#, and the UI algorithm is implemented in C++.  
Concurrency is not exploited in any of the tested solution methods.
The PB algorithm is also available for downloading~\cite{SourceCodes}.

\bigskip

The branching heuristic implemented in line~\ref{line:select-s} of Algorithm~\ref{alg:recursion} selects a step  that maximises a ranking function :

where  is the number of not-equals constraints involving step ,  is the number of at-most- constraints involving  such that  distinct users are already assigned to it, and ,  and  are parameters.  The intuition is that the steps  that maximise  are tightening the search space quickly.  The parameters ,  and  were selected empirically.  We found out that the algorithm is not very sensitive to the values of these parameters, and settled down at ,  and .  Note that the function does not account for at-least constraints.  This reflects our empirical observation that the at-least constraints are usually relatively weak in our instances and rarely help in pruning branches of search.




\bigskip

We started from establishing what parameter values make the instances hard.  
However, due to the lack of space, we provide only the conclusions drawn from this series of experiments.
As it could be expected, greatly under- and over-subscribed instances are easier to solve than the instances in the region between those two extremes.
The behaviour of the analysed solvers is consistent in this regard.
The particular values of the number of not-equals constraints  and the number  of at-most and at-least constraints that make the instances most challenging depend on .
Thus, in our final experiment, which is to establish the maximum size  of instances practically solvable by each of the methods, we considered several instances with a range of parameters to ensure that at least one of them is hard.
In particular, we fixed the \emph{density} of not-equals constraints, calculated as , at  and the number  of at-most and at-least constraints at each of ,  and , producing three instances for each  and seed value.

\begin{figure}
\pgfplotsset{minor grid style={color=black!10, dashed}}

\beginpgfgraphicnamed{fig3}
\begin{tikzpicture}
\begin{groupplot}[
    group style={
        group name=my plots,
        group size=1 by 2,
        xlabels at=edge bottom,
        xticklabels at=edge bottom,
        vertical sep=2pt
    },
    width=\textwidth,
    xlabel={Number of steps },
    xmin=10, 
    xmax=65,
    tickpos=left,
]
\nextgroupplot[
		ymode=log, 
		compat=newest,
		width=\textwidth,
		height=13cm,
		legend cell align=left,
		legend style={/tikz/every even column/.append style={column sep=1em},at={(0.5, 1.005)}, anchor=south},
		legend columns={-1},
		grid=major,
		boxplot/draw direction=y,
		boxplot/variable width,
		area legend,
ylabel={Running time, sec},
		xmajorticks=false,
		ymin=0.0005,
		ymax=20000
	]
  \addplot+[black, very thick, solid, mark=x,
    boxplot prepared={draw position=13,
      lower whisker=0.000476,
      lower quartile=0.001436,
      median=0.002184,
      upper quartile=0.003801,
      upper whisker=0.006011,
      sample size=50,
      box extend=1.5pt,
    }
  ]
  coordinates {
    (0, 0.007736)
    (0, 0.020354)
  };
  \addplot+[black, very thick, solid, mark=x,
    forget plot,
    boxplot prepared={draw position=15,
      lower whisker=0.001083,
      lower quartile=0.00359,
      median=0.0063695,
      upper quartile=0.008226,
      upper whisker=0.014351,
      sample size=50,
      box extend=1.5pt,
    }
  ]
  coordinates {
    (0, 0.015326)
    (0, 0.016978)
    (0, 0.01851)
  };
  \addplot+[black, very thick, solid, mark=x,
    forget plot,
    boxplot prepared={draw position=17,
      lower whisker=0.001762,
      lower quartile=0.007718,
      median=0.0196905,
      upper quartile=0.025926,
      upper whisker=0.047271,
      sample size=50,
      box extend=1.5pt,
    }
  ]
  coordinates {
  };
  \addplot+[black, very thick, solid, mark=x,
    forget plot,
    boxplot prepared={draw position=19,
      lower whisker=0.002645,
      lower quartile=0.021961,
      median=0.038626,
      upper quartile=0.058766,
      upper whisker=0.10364,
      sample size=50,
      box extend=1.5pt,
    }
  ]
  coordinates {
    (0, 0.13225)
    (0, 0.139987)
  };
  \addplot+[black, very thick, solid, mark=x,
    forget plot,
    boxplot prepared={draw position=21,
      lower whisker=0.018383,
      lower quartile=0.055967,
      median=0.079714,
      upper quartile=0.116186,
      upper whisker=0.198879,
      sample size=50,
      box extend=1.5pt,
    }
  ]
  coordinates {
    (0, 0.208583)
    (0, 0.209689)
  };
  \addplot+[black, very thick, solid, mark=x,
    forget plot,
    boxplot prepared={draw position=23,
      lower whisker=0.01285,
      lower quartile=0.14087,
      median=0.232105,
      upper quartile=0.332575,
      upper whisker=0.573519,
      sample size=50,
      box extend=1.5pt,
    }
  ]
  coordinates {
    (0, 0.74413)
  };
  \addplot+[black, very thick, solid, mark=x,
    forget plot,
    boxplot prepared={draw position=25,
      lower whisker=0.131142,
      lower quartile=0.312837,
      median=0.4024705,
      upper quartile=0.563091,
      upper whisker=0.913841,
      sample size=50,
      box extend=1.5pt,
    }
  ]
  coordinates {
    (0, 1.016768)
    (0, 1.262158)
  };
  \addplot+[black, very thick, solid, mark=x,
    forget plot,
    boxplot prepared={draw position=27,
      lower whisker=0.216714,
      lower quartile=0.640635,
      median=1.0001535,
      upper quartile=1.460423,
      upper whisker=2.304617,
      sample size=50,
      box extend=1.5pt,
    }
  ]
  coordinates {
  };
  \addplot+[black, very thick, solid, mark=x,
    forget plot,
    boxplot prepared={draw position=29,
      lower whisker=0.64982,
      lower quartile=1.371382,
      median=2.1236805,
      upper quartile=2.472069,
      upper whisker=3.762215,
      sample size=50,
      box extend=1.5pt,
    }
  ]
  coordinates {
    (0, 4.164724)
    (0, 5.895961)
  };
  \addplot+[black, very thick, solid, mark=x,
    forget plot,
    boxplot prepared={draw position=31,
      lower whisker=0.842676,
      lower quartile=2.600601,
      median=4.0947615,
      upper quartile=4.960322,
      upper whisker=6.892071,
      sample size=50,
      box extend=1.5pt,
    }
  ]
  coordinates {
    (0, 9.140746)
    (0, 9.171519)
    (0, 14.382698)
    (0, 20.275003)
  };
  \addplot+[black, very thick, solid, mark=x,
    forget plot,
    boxplot prepared={draw position=33,
      lower whisker=2.29295,
      lower quartile=4.456875,
      median=6.4388,
      upper quartile=8.820871,
      upper whisker=15.198772,
      sample size=50,
      box extend=1.5pt,
    }
  ]
  coordinates {
    (0, 15.551329)
    (0, 32.236168)
  };
  \addplot+[black, very thick, solid, mark=x,
    forget plot,
    boxplot prepared={draw position=35,
      lower whisker=4.681195,
      lower quartile=8.869816,
      median=13.0063425,
      upper quartile=18.337313,
      upper whisker=32.19568,
      sample size=50,
      box extend=1.5pt,
    }
  ]
  coordinates {
    (0, 35.849169)
    (0, 42.208748)
    (0, 48.159818)
  };
  \addplot+[black, very thick, solid, mark=x,
    forget plot,
    boxplot prepared={draw position=37,
      lower whisker=5.623913,
      lower quartile=13.445044,
      median=26.0983755,
      upper quartile=37.761142,
      upper whisker=72.227123,
      sample size=50,
      box extend=1.5pt,
    }
  ]
  coordinates {
    (0, 75.162635)
    (0, 100.90242)
  };
  \addplot+[black, very thick, solid, mark=x,
    forget plot,
    boxplot prepared={draw position=39,
      lower whisker=8.943476,
      lower quartile=28.375575,
      median=42.4656015,
      upper quartile=58.098336,
      upper whisker=94.141117,
      sample size=50,
      box extend=1.5pt,
    }
  ]
  coordinates {
    (0, 103.681497)
    (0, 107.311756)
    (0, 108.610321)
    (0, 112.587834)
  };
  \addplot+[black, very thick, solid, mark=x,
    forget plot,
    boxplot prepared={draw position=41,
      lower whisker=25.118101,
      lower quartile=44.556554,
      median=75.1025285,
      upper quartile=100.806997,
      upper whisker=168.426267,
      sample size=50,
      box extend=1.5pt,
    }
  ]
  coordinates {
    (0, 222.189102)
    (0, 243.260515)
  };
  \addplot+[black, very thick, solid, mark=x,
    forget plot,
    boxplot prepared={draw position=43,
      lower whisker=20.395593,
      lower quartile=111.921908,
      median=169.619055,
      upper quartile=249.499935,
      upper whisker=448.01709,
      sample size=50,
      box extend=1.5pt,
    }
  ]
  coordinates {
    (0, 457.566798)
    (0, 521.22108)
    (0, 566.908721)
    (0, 567.348223)
  };
  \addplot+[black, very thick, solid, mark=x,
    forget plot,
    boxplot prepared={draw position=45,
      lower whisker=43.204185,
      lower quartile=137.510044,
      median=238.802683,
      upper quartile=374.504925,
      upper whisker=618.459209,
      sample size=50,
      box extend=1.5pt,
    }
  ]
  coordinates {
    (0, 966.407642)
    (0, 990.565459)
  };
  \addplot+[black, very thick, solid, mark=x,
    forget plot,
    boxplot prepared={draw position=47,
      lower whisker=54.395026,
      lower quartile=233.659425,
      median=333.775218,
      upper quartile=577.821641,
      upper whisker=1087.645798,
      sample size=50,
      box extend=1.5pt,
    }
  ]
  coordinates {
    (0, 1164.769332)
  };
  \addplot+[black, very thick, solid, mark=x,
    forget plot,
    boxplot prepared={draw position=49,
      lower whisker=146.132264,
      lower quartile=411.699173,
      median=649.277278,
      upper quartile=1012.700138,
      upper whisker=1684.826668,
      sample size=50,
      box extend=1.5pt,
    }
  ]
  coordinates {
    (0, 2251.429752)
  };
  \addplot+[black, very thick, solid, mark=x,
    forget plot,
    boxplot prepared={draw position=51,
      lower whisker=243.062238,
      lower quartile=644.2280335,
      median=963.9471765,
      upper quartile=1650.248838,
      upper whisker=2654.488805,
      sample size=48,
      box extend=1.5pt,
    }
  ]
  coordinates {
  };
  \addplot+[black, very thick, solid, mark=x,
    forget plot,
    boxplot prepared={draw position=53,
      lower whisker=260.562519,
      lower quartile=964.730892,
      median=1851.65855,
      upper quartile=2526.212144,
      upper whisker=4270.210487,
      sample size=46,
      box extend=1.5pt,
    }
  ]
  coordinates {
  };
  \addplot+[black, very thick, solid, mark=x,
    forget plot,
    boxplot prepared={draw position=55,
      lower whisker=403.459897,
      lower quartile=1259.0417945,
      median=2007.946837,
      upper quartile=3073.2675295,
      upper whisker=5727.98662,
      sample size=32,
      box extend=1.5pt,
    }
  ]
  coordinates {
  };
  \addplot+[black, very thick, solid, mark=x,
    forget plot,
    boxplot prepared={draw position=57,
      lower whisker=919.462006,
      lower quartile=2178.691215,
      median=3360.1088795,
      upper quartile=4369.589181,
      upper whisker=6685.702399,
      sample size=24,
      box extend=1.5pt,
    }
  ]
  coordinates {
  };
  \addplot+[black, very thick, solid, mark=x,
    forget plot,
    boxplot prepared={draw position=59,
      lower whisker=1303.468216,
      lower quartile=2094.130371,
      median=2978.162787,
      upper quartile=4699.327914,
      upper whisker=5442.125106,
      sample size=15,
      box extend=1.5pt,
    }
  ]
  coordinates {
  };
  \addplot+[black, very thick, solid, mark=x,
    forget plot,
    boxplot prepared={draw position=61,
      lower whisker=1633.346464,
      lower quartile=3464.865449,
      median=4543.7305435,
      upper quartile=5797.8269445,
      upper whisker=6932.911121,
      sample size=8,
      box extend=1.5pt,
    }
  ]
  coordinates {
    (0, 9973.606851)
  };
  \addplot+[black, very thick, solid, mark=x,
    forget plot,
    boxplot prepared={draw position=63,
      lower whisker=4405.708441,
      lower quartile=4405.708441,
      median=5105.8050785,
      upper quartile=5805.901716,
      upper whisker=5805.901716,
      sample size=2,
      box extend=1.5pt,
    }
  ]
  coordinates {
  };
  \addlegendentry{PB}
  
  
  \addplot+[black, densely dotted, mark=x,
    boxplot prepared={draw position=13,
      lower whisker=0.097929,
      lower quartile=0.17252,
      median=0.217659,
      upper quartile=0.332177,
      upper whisker=0.54285,
      sample size=50,
      box extend=1.5pt,
    }
  ]
  coordinates {
  };
  \addplot+[black, densely dotted, mark=x,
    forget plot,
    boxplot prepared={draw position=15,
      lower whisker=0.462819,
      lower quartile=0.721366,
      median=0.968152,
      upper quartile=1.299847,
      upper whisker=1.717526,
      sample size=50,
      box extend=1.5pt,
    }
  ]
  coordinates {
  };
  \addplot+[black, densely dotted, mark=x,
    forget plot,
    boxplot prepared={draw position=17,
      lower whisker=1.875156,
      lower quartile=4.64993,
      median=6.233385,
      upper quartile=7.366778,
      upper whisker=10.95103,
      sample size=50,
      box extend=1.5pt,
    }
  ]
  coordinates {
    (0, 12.151411)
    (0, 12.985824)
  };
  \addplot+[black, densely dotted, mark=x,
    forget plot,
    boxplot prepared={draw position=19,
      lower whisker=15.982353,
      lower quartile=26.644857,
      median=35.059312,
      upper quartile=43.737123,
      upper whisker=64.114321,
      sample size=50,
      box extend=1.5pt,
    }
  ]
  coordinates {
    (0, 77.516163)
    (0, 77.643756)
  };
  \addplot+[black, densely dotted, mark=x,
    forget plot,
    boxplot prepared={draw position=21,
      lower whisker=94.687893,
      lower quartile=195.648697,
      median=234.5228865,
      upper quartile=310.237386,
      upper whisker=452.617096,
      sample size=50,
      box extend=1.5pt,
    }
  ]
  coordinates {
  };
  \addplot+[black, densely dotted, mark=x,
    forget plot,
    boxplot prepared={draw position=23,
      lower whisker=1002.656896,
      lower quartile=1536.59437,
      median=1936.5805195,
      upper quartile=2226.660915,
      upper whisker=3192.961094,
      sample size=50,
      box extend=1.5pt,
    }
  ]
  coordinates {
    (0, 3311.748633)
    (0, 3882.293051)
    (0, 3886.655972)
  };
  \addplot+[black, densely dotted, mark=x,
    forget plot,
    boxplot prepared={draw position=25,
      lower whisker=2934.339681,
      lower quartile=4815.319143,
      median=5957.647354,
      upper quartile=6784.892482,
      upper whisker=8422.805868,
      sample size=11,
      box extend=1.5pt,
    }
  ]
  coordinates {
  };
	\addlegendentry{UI}
  \addplot+[black, solid, mark=x,
    boxplot prepared={draw position=13,
      lower whisker=1.5519,
      lower quartile=3.298295,
      median=4.9474165,
      upper quartile=11.397011,
      upper whisker=14.432836,
      sample size=50,
      box extend=1.5pt,
    }
  ]
  coordinates {
    (0, 29.003289)
    (0, 40.914349)
    (0, 113.891574)
    (0, 121.213033)
    (0, 218.434954)
    (0, 695.244766)
    (0, 844.956401)
  };
  \addplot+[black, solid, mark=x,
    forget plot,
    boxplot prepared={draw position=15,
      lower whisker=1.32617,
      lower quartile=9.537446,
      median=19.464273,
      upper quartile=66.579024,
      upper whisker=124.615792,
      sample size=50,
      box extend=1.5pt,
    }
  ]
  coordinates {
    (0, 185.561027)
    (0, 193.197594)
    (0, 196.784974)
    (0, 272.658958)
    (0, 288.918676)
    (0, 338.444516)
    (0, 361.077257)
    (0, 379.11828)
    (0, 1150.040985)
    (0, 1999.265304)
  };
  \addplot+[black, solid, mark=x,
    forget plot,
    boxplot prepared={draw position=17,
      lower whisker=10.006497,
      lower quartile=30.2191505,
      median=123.871791,
      upper quartile=1411.5373745,
      upper whisker=2867.856349,
      sample size=49,
      box extend=1.5pt,
    }
  ]
  coordinates {
  };
  \addplot+[black, solid, mark=x,
    forget plot,
    boxplot prepared={draw position=19,
      lower whisker=3.576515,
      lower quartile=40.01675,
      median=89.309031,
      upper quartile=591.170056,
      upper whisker=1391.322795,
      sample size=30,
      box extend=1.5pt,
    }
  ]
  coordinates {
    (0, 2691.696353)
    (0, 2827.461763)
    (0, 3159.936804)
    (0, 5494.46444)
  };
  \addplot+[black, solid, mark=x,
    forget plot,
    boxplot prepared={draw position=21,
      lower whisker=36.682713,
      lower quartile=232.174296,
      median=445.023041,
      upper quartile=1736.527092,
      upper whisker=3587.275551,
      sample size=19,
      box extend=1.5pt,
    }
  ]
  coordinates {
  };
  \addplot+[black, solid, mark=x,
    forget plot,
    boxplot prepared={draw position=23,
      lower whisker=197.402624,
      lower quartile=330.08742,
      median=994.9625765,
      upper quartile=1790.879925,
      upper whisker=3630.353077,
      sample size=6,
      box extend=1.5pt,
    }
  ]
  coordinates {
  };
  \addplot+[black, solid, mark=x,
    forget plot,
    boxplot prepared={draw position=25,
      lower whisker=346.389495,
      lower quartile=346.389495,
      median=505.275435,
      upper quartile=1147.681702,
      upper whisker=1147.681702,
      sample size=3,
      box extend=1.5pt,
    }
  ]
  coordinates {
  };
  \addplot+[black, solid, mark=x,
    forget plot,
    boxplot prepared={draw position=27,
      lower whisker=2341.841102,
      lower quartile=2341.841102,
      median=2572.338133,
      upper quartile=2802.835164,
      upper whisker=2802.835164,
      sample size=2,
      box extend=1.5pt,
    }
  ]
  coordinates {
  };
	\addlegendentry{SAT4J}

  
\nextgroupplot[
		compat=newest,
		height=4cm,
		grid=both,
		ymin=0,
		ylabel={Solved, \%},
		minor y tick num=4,
	]
	\addplot[black, very thick, solid] coordinates {
		(13, 100)
		(15, 100)
		(17, 100)
		(19, 100)
		(21, 100)
		(23, 100)
		(25, 100)
		(27, 100)
		(29, 100)
		(31, 100)
		(33, 100)
		(35, 100)
		(37, 100)
		(39, 100)
		(41, 100)
		(43, 100)
		(45, 100)
		(47, 100)
		(49, 100)
		(51, 96)
		(53, 92)
		(55, 64)
		(57, 48)
		(59, 30)
		(61, 16)
		(63, 4)
	};
	\addplot[black, densely dotted] coordinates {
		(13, 100)
		(15, 100)
		(17, 100)
		(19, 100)
		(21, 100)
		(23, 100)
		(25, 22)
		(27, 0)
	};
	\addplot[black, solid] coordinates {
		(13, 100)
		(15, 100)
		(17, 98)
		(19, 60)
		(21, 38)
		(23, 12)
		(25, 6)
		(27, 4)
	};
\end{groupplot}
\end{tikzpicture}
\endpgfgraphicnamed
 
\caption{Running time vs.\ number of steps . For each , we generate 50 instance sets with different seed values.  
The distributions are presented in the boxplot form, where the width of a box is proportional to the number of instance sets on which the solver succeeded.  
The plot at the bottom of the figure also shows the success rate of each solver.}
\label{fig:change-k}
\end{figure}
Each solver is given one hour limitation for each instance from the set. 
If a solver fails on at least one of the instances (could not terminate within 1~hour), we say that it fails on the whole set.
The intention is to make sure that the solver can tackle hard satisfiable and unsatisfiable instances within a reasonable time.
The results are presented in Figure~\ref{fig:change-k} in the form of boxplots.
The percentage of runs in which the solver succeeded is shown as the width of the box.
This information is also provided at the bottom of Figure~\ref{fig:change-k}.

The PB algorithm, being faster than the two other methods by several orders of magnitude, reliably solves all the instances of size up to .
Compare it to the UI and SAT4J solvers that succeed only for  and , respectively.
Moreover, its running time grows slower than that of the UI and SAT4J solvers, which indicates that it has higher potential if more computational power is allocated.
In other words, thanks to our new solution method, the previously unapproachable problem instances of practical sizes can now be routinely tackled.





\section{Conclusion}
\label{sec:conclusion}

We proposed a new FPT algorithm for the WSP with user-independent constraints.  
Our experimental analysis have shown that the new algorithm outperforms all the methods in the literature by several orders of magnitude and significantly extends the domain of practically solvable instances.
Another advantage of the new FPT algorithm is that it is relatively easy to implement and extend; for example, it is straightforward to parallelise it.

Future research is needed to establish further potential to improve the algorithm's performance.
Particular attention has to be paid to the branching heuristic.
Thorough empirical analysis has to be conducted to investigate the performance of the algorithms on easy and hard instances.

Another relevant subject was recently studied in~\cite{ValuedWSP-SACMAT}; the paper introduces an optimisation version of WSP and proposes an FPT branch and bound algorithm inspired by Pattern Backtracking.


\paragraph{Acknowledgment.}
This research was partially supported by EPSRC grant EP/\linebreak[1]K005162/1.
The source codes of the Pattern Backtracking algorithm and the instance generator are publicly available~\cite{SourceCodes}.



\begin{thebibliography}{10}
\providecommand{\url}[1]{\texttt{#1}}
\providecommand{\urlprefix}{URL }

\bibitem{ANSI04}
American National Standards Institute. \emph{ANSI INCITS 359-2004 for Role Based Access Control}, 2004.

\bibitem{BaBuKa14}
Basin, D.A., Burri, S.J., Karjoth, G.:
Obstruction-free authorisation enforcement: Aligning security and business objectives. 
Journal of Computer Security 22(5), 661--698 (2014).



\bibitem{BeFeAt99}
Bertino, E., Ferrari, E., Atluri, V.: The specification and enforcement of
  authorisation constraints in workflow management systems. ACM Trans. Inf.
  Syst. Secur.  2(1),  65--104 (1999)

\bibitem{ChKl10}
Chimani, M., Klein, K.: Algorithm engineering: Concepts and practice. In:
  Bartz-Beielstein, T., Chiarandini, M., Paquete, L., Preuss, M. (eds.)
  Experimental methods for the analysis of optimization algorithms, pp.
  131--158 (2010)

\bibitem{FAW2014}
Cohen, D., Crampton, J., Gagarin, A., Gutin, G., Jones, M.: 
Engineering algorithms for workflow satisfiability problem with user-independent constraints. 
Proc. 8th International Frontiers of Algorithmics Workshop (FAW 2014), J. Chen, J.E. Hopcroft, and J. Wang (Eds.), 2014, LNCS 8497, Springer, pp. 48--59.

\bibitem{CoCrGaGuJo13}
Cohen, D., Crampton, J., Gagarin, A., Gutin, G., Jones, M.: Iterative plan
  construction for the workflow satisfiability problem. \emph{Journal of Artificial Intelligence Research} 51, pp. 555--577 (2014)
  
\bibitem{JOCO2014}
Cohen, D., Crampton, J., Gagarin, A., Gutin, G., Jones, M.: 
Algorithms for the workflow satisfiability problem engineered for counting constraints, to appear in J.\ of Combin.\ Optim., (2014)

\bibitem{ValuedWSP-SACMAT}
Crampton, J., Gutin, G., Karapetyan, D.: 
Valued Workflow Satisfiability Problem, to appear in proc.\ of ACM symposium on Access control models and technologies (SACMAT), 1–3 June, Vienna, Austria.  ACM (2015)

\bibitem{Cr05}
Crampton, J.: A reference monitor for workflow systems with constrained task
execution. In: Ferrari, E., Ahn, G.J. (eds.) SACMAT. pp. 38--47. ACM (2005)



\bibitem{CrGuYe13}
Crampton, J., Gutin, G., Yeo, A.: On the parameterized complexity and
  kernelization of the workflow satisfiability problem. ACM Trans.\ Inf.\ Syst.\ Secur.  16(1), ~4 (2013)

\bibitem{DoFe13}
Downey, R.G., Fellows, M.R.: Foundations of Parameterized Complexity. Springer (2013)







\bibitem{SourceCodes}
Karapetyan, D., Gutin, G., Gagarin, A.:
Source codes of the Pattern Backtracking algorithm and the instance generator.  DOI:\href{http://dx.doi.org/10.6084/m9.figshare.1360237}{\texttt{10.6084/m9.figshare.1360237}} retrieved 31 March 2015.

\bibitem{KaGuGo}
Karapetyan, D., Gutin, G., Goldengorin, B.: Empirical evaluation of construction heuristics for the multidimensional assignment problem.  Proc. London Algorithmics 2008: Theory and Practice, 2009, Texts in Algorithmics 11, College Publications, pp.\ 107--122.

\bibitem{BePa10}
Le~Berre, D., Parrain, A.: The {SAT4J} library, release 2.2. J. Satisf. Bool.
  Model. Comput.  7,  59--64 (2010)







\bibitem{WaLi10}
Wang, Q., Li, N.: Satisfiability and resiliency in workflow authorisation
  systems. ACM Trans. Inf. Syst. Secur.  13(4), 40 (2010)

\end{thebibliography}

















\end{document}
