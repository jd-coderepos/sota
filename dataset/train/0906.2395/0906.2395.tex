\documentclass[11pt]{article}

\iffalse  

\usepackage{amsfonts}
\usepackage{amstext}
\usepackage{xspace}
\usepackage{graphicx}
\usepackage{color}
\usepackage{theorem}
\usepackage{hyperref}
\fi


\usepackage{times}
\usepackage{latexsym}
\usepackage{amsfonts,amsthm,amssymb}
\usepackage{euscript}
\usepackage{amstext}
\usepackage{graphicx}
\usepackage{color}
\usepackage{url,hyperref}
\usepackage{fullpage}






 \setlength{\textwidth}{6.5in} \setlength{\topmargin}{0.0in} \setlength{\headheight}{0in}
\setlength{\headsep}{0.0in}
\setlength{\textheight}{9in} \setlength{\oddsidemargin}{0in} \setlength{\evensidemargin}{0in}



\newtheorem{fact}{Fact}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{theorem}[lemma]{Theorem}
\newtheorem{assumption}[lemma]{Assumption}
\newtheorem{definition}[lemma]{Definition}
\newtheorem{corollary}[lemma]{Corollary}
\newtheorem{proposition}[lemma]{Proposition}
\newtheorem{claim}[lemma]{Claim}
\newtheorem{remark}[lemma]{Remark}
\newtheorem{prob}{Problem}
\newtheorem{conjecture}{Conjecture}
\newtheorem{observation}{Observation}



\renewcommand{\proofname}{\textbf{Proof}}
\newenvironment{proofof}[1]{\smallskip\noindent{\bf Proof of #1:}}{\hspace*{\fill}\par}

\newcommand{\Eqref}[1]{Eq.~(\ref{equation:#1})}
\newcommand{\obsref}[1]{Observation~\ref{observation:#1}}
\newcommand{\lemref}[1]{Lemma~\ref{lemma:#1}}
\newcommand{\clmref}[1]{Claim~\ref{claim:#1}}
\newcommand{\exmref}[1]{Example~\ref{example:#1}}
\providecommand{\conref}[1]{Conjecture~\ref{conj:#1}}
\newcommand{\algref}[1]{Algorithm~\ref{alg:#1}}
\newcommand{\factref}[1]{Fact~\ref{fact:#1}}
\newcommand{\proref}[1]{Proposition~\ref{prop:#1}}
\newcommand{\propref}[1]{Proposition~\ref{prop:#1}}
\newcommand{\exeref}[1]{Exercise~\ref{exer:#1}}
\newcommand{\probref}[1]{Problem~\ref{prob:#1}}
\newcommand{\theoref}[1]{Theorem~\ref{theo:#1}}
\newcommand{\theref}[1]{Theorem~\ref{theo:#1}}
\newcommand{\corref}[1]{Corollary~\ref{cor:#1}}
\newcommand{\figref}[1]{Figure~\ref{fig:#1}}
\newcommand{\tabref}[1]{Table~\ref{tab:#1}}
\newcommand{\Figref}[1]{Figure~\ref{fig:#1}}
\newcommand{\chapref}[1]{Chapter~\ref{chap:#1}}
\newcommand{\secref}[1]{Section~\ref{sec:#1}}
\newcommand{\apndref}[1]{Appendix~\ref{apnd:#1}}

\newcommand{\subsecref}[1]{Section~\ref{subsec:#1}}
\newcommand{\remref}[1]{Remark~\ref{rem:#1}}
\newcommand{\defref}[1]{Definition~\ref{def:#1}}
\newcommand{\mchapref}[1]{\ref{chap:#1}}
\newcommand{\msecref}[1]{\ref{sec:#1}}
\newcommand{\msubsecref}[1]{\ref{subsec:#1}}
\newcommand{\mtheoref}[1]{\ref{theo:#1}}
\newcommand{\mfigref}[1]{\ref{fig:#1}}
\newcommand{\eqnref}[1]{(\ref{eqn:#1})}

\providecommand{\conlab}[1]{\label{conj:#1}}
\newcommand{\remlab}[1]{\label{rem:#1}}
\newcommand{\obslab}[1]{\label{observation:#1}}
\newcommand{\alglab}[1]{\label{alg:#1}}
\newcommand{\eqlab}[1]{\label{equation:#1}}
\newcommand{\exmlab}[1]{\label{example:#1}}
\newcommand{\lemlab}[1]{\label{lemma:#1}}
\newcommand{\clmlab}[1]{\label{claim:#1}}
\providecommand{\deflab}[1]{\label{def:#1}}
\newcommand{\factlab}[1]{\label{fact:#1}}
\newcommand{\prolab}[1]{\label{prop:#1}}
\newcommand{\proplab}[1]{\label{prop:#1}}
\newcommand{\exelab}[1]{\label{exer:#1}}
\newcommand{\theolab}[1]{\label{theo:#1}}
\newcommand{\problab}[1]{\label{prob:#1}}
\newcommand{\thelab}[1]{\label{theo:#1}}
\newcommand{\chaplab}[1]{\label{chap:#1}}
\newcommand{\eqnlab}[1]{\label{eqn:#1}}
\newcommand{\corlab}[1]{\label{cor:#1}}
\newcommand{\figlab}[1]{\label{fig:#1}}
\newcommand{\tablab}[1]{\label{tab:#1}}
\newcommand{\seclab}[1]{\label{sec:#1}}
\newcommand{\apndlab}[1]{\label{apnd:#1}}
\newcommand{\subseclab}[1]{\label{subsec:#1}}


\newcommand{\opt}{\textrm{\sc OPT}}
\newcommand{\etal}{et al.\ }
\newcommand{\eps}{\epsilon}
\newcommand{\st}{S} \newcommand{\Algorithm}[1]{{\texttt{\bf{#1}}}} \newcommand{\lwf}{\Algorithm{LWF}}

\newcommand{\lp}{\texttt{LP}}
\newcommand{\one}{\texttt{Type1}}
\newcommand{\two}{\texttt{Type2}}
\newcommand{\grdy}{\Algorithm{LF}}
\newcommand{\len}{\mathfrak{\rho}}

\newcommand{\floor}[1]{\lfloor #1 \rfloor}
\newcommand{\ceil}[1]{\lceil #1 \rceil}

\newcommand{\fe}{F^e}
\newcommand{\fl}{F^l}
\newcommand{\we}{W^e}
\newcommand{\wl}{W^l}
\newcommand{\lwfs}{\lwf^{S}}
\newcommand{\lwfn}{\lwf^{N}}
\newcommand{\lwfne}{\lwf^{N^e}}
\newcommand{\lwfneone}{\lwf^{N_1^e}}
\newcommand{\lwfnetwo}{\lwf^{N_2^e}}
\newcommand{\lwfnl}{\lwf^{N^l}}
\newcommand{\opts}{\opt^{S}}
\newcommand{\optn}{\opt^{N}}
\newcommand{\optne}{\opt^{N^e}}
\newcommand{\optnl}{\opt^{N^l}}

\newcommand{\cJ}{{\cal J}}
\newcommand{\spone}{-3.5mm}
\newcommand{\sptwo}{-7mm}
\newcommand{\spbox}{-4mm}

\begin{document}






\iffalse
\author{Chandra Chekuri\thanks{Partially supported by NSF grants CCF-0728782 and CNS-0721899.}
 \and Sungjin Im\thanks{Partially supported by Samsung Fellowship.} \and Benjamin Moseley\thanks{Partially supported by NSF grant CNS-0721899.}}
\authorrunning{Chekuri, Im, Moseley}   \tocauthor{Chandra Chekuri(UIUC), Sungjin Im(UIUC) and Benjamin Moseley(UIUC) }
\institute{Dept.\ of Computer Science, University of
Illinois, Urbana, IL 61801. \\
\email{\{chekuri, im3, bmosele2\}@cs.uiuc.edu}}


\begin{titlepage}
\def\thepage{}
\maketitle
\fi

\title{Longest Wait First for Broadcast Scheduling}
\author{
Chandra Chekuri\thanks{Department of Computer Science, University of Illinois, 201 N.\ Goodwin Ave., Urbana, IL 61801.
{\tt chekuri@cs.uiuc.edu}. Partially supported by NSF grants CCF-0728782
 and CNS-0721899. }
 \and Sungjin Im\thanks{Department of Computer Science, University of
Illinois, 201 N.\ Goodwin Ave., Urbana, IL 61801. {\tt im3@uiuc.edu}} \and Benjamin Moseley\thanks{Department of
Computer Science, University of Illinois, 201 N.\ Goodwin Ave., Urbana, IL 61801. {\tt bmosele2@uiuc.edu}. Partially
supported by NSF grant CNS-0721899. } }
\date{\today}
\maketitle


\begin{abstract}
  We consider {\em online} algorithms for broadcast scheduling. In the
  pull-based broadcast model there are  unit-sized pages of
  information at a server and requests arrive online for pages. When
  the server transmits a page , all outstanding requests for that
  page are satisfied. There is a lower bound of  on the
  competitiveness of online algorithms to minimize average flow-time;
  therefore we consider resource augmentation analysis in which the
  online algorithm is given extra speed over the adversary. The {\em
    longest-wait-first} (LWF) algorithm is a natural algorithm that
  has been shown to have good empirical performance
  \cite{AksoyF98}. Edmonds and Pruhs showed that LWF is -speed
  -competitive using a very complex analysis; they also showed
  that LWF is not -competitive with less than -speed. In  this paper we make two main contributions to the analysis of LWF and
  broadcast scheduling.
  \begin{itemize}
  \item We give an intuitive and easy to understand analysis of LWF
    which shows that it is -competitive for average
    flow-time with  speed. Using a more involved analysis, we
    show that LWF is -competitive for average flow-time
    with  speed.
  \item We show that a natural extension of LWF is -speed
    -competitive for more general objective functions such as
    average delay-factor and  norms of delay-factor (for fixed
    ). These metrics generalize average flow-time and  norms
    of flow-time respectively and ours are the first non-trivial
    results for these objective functions in broadcast scheduling.
  \end{itemize}
\end{abstract}




\newpage
\setcounter{page}{1}


\section{Introduction}
We consider online algorithms for broadcast scheduling in the
pull-based model. In this model there are  pages (representing some
form of useful information) available at a server and clients request
a page that they are interested in. The server {\em broadcasts} pages
according to some online policy and {\em all} outstanding requests for
a page are satisfied when that page is transmitted/broadcast. This is
what distinguishes this model from the standard scheduling models
where the server has to process each request separately. Broadcast
scheduling is motivated by several applications. Example situations
where the broadcast assumption is natural include wireless and
satellite networks, LAN based systems and even some multicast
systems. See \cite{Wong88,AcharyaFZ95,AksoyF98,Hall03} for pointers to
applications and systems that are based on this model. In addition to
their practical interest, broadcast scheduling has been of much
interest in recent years from a theoretical point of view. There is by
now a good amount of literature in online and offline algorithms in
this model \cite{BarnoyBNS98,AksoyF98,AcharyaFZ95,BartalM00,Hall03}. There is
also substantial work in the stochastic and queuing theory literature
\cite{DebS73,Deb84,Weiss79,WeissP81} on related models which make
distributional assumptions on the request arrivals. In a certain
sense,  can be shown to be optimal when page arrivals are
independent and assumed to have a Poisson distribution
\cite{AmmarW85}.



It is fair to say that algorithmic development and analysis for
broadcast scheduling have been challenging even in the simplest
setting of unit-sized pages; so much so that a substantial amount of
technical work has been devoted to the development of {\em offline}
approximation algorithms
\cite{KalyanasundaramPV00,ErlebachH02,GandhiKKW04,GandhiKPS06,BansalCKN05,BansalCS06};
many of these offline algorithms are non-trivial and are based on
linear programming based methods. Further, most of these offline
algorithms, with the exception of \cite{BansalCS06}, are in the
resource augmentation model of Kalyanasundaram and Pruhs
\cite{KalyanasundaramP95} in which the analysis is done by giving the
algorithm a machine with speed  when compared to a speed 
machine for the adversary.  In this paper we are interested in {\em
  online} algorithms in the worst-case competitive analysis
framework. We consider the problem of minimizing average flow-time (or
waiting time) of requests and other more stringent objective
functions. It is easy to show an  lower bound on the
competitive ratio \cite{KalyanasundaramPV00} of any deterministic
algorithm and hence we also resort to resource augmentation analysis.
For average flow-time three algorithms are known to be
-competitive with -speed.  The first is the natural {\em
  longest-wait-first} () algorithm/policy: at any time  that
the server is free, schedule the page  for which the total waiting
time of all outstanding requests for  is the largest. Edmonds and
Pruhs \cite{EdmondsP04}, in a complex and original analysis, showed
that  is a -speed -competitive algorithm and also that
it is not -competitive with a speed less than
; they also conjectured that their lowerbound is tight. The same authors also gave a different algorithm
called BEQUI in \cite{EdmondsP03} and show that it is a
-speed -competitive algorithm; although the algorithm
has intuitive appeal, the proof of its
performance relies on an involved reduction to an algorithm for a
non-clairvoyant scheduling problem \cite{Edmonds00} whose analysis
itself is substantially complex. The recent improved result in
\cite{EdmondsP09} for the non-clairvoyant problem when combined with
the reduction mentioned above leads to a -speed
-competitive algorithm; however the new algorithm requires the
knowledge of  and hence is not as natural as the other
algorithms. The preemptive algorithms in \cite{EdmondsP03,EdmondsP09} are also
applicable when the page sizes are arbitrary; see
\cite{Hall03} for empirical evaluation in this model.
At a technical level, a main difficulty in online analysis for broadcast
scheduling is the fact shown in \cite{KalyanasundaramPV00} that no
online algorithm can be {\em locally}-competitive with an adversary\footnote{An algorithm is locally-competitive if at each time , its queue size
is comparable to that of the queue size of the adversary. Many results in
standard scheduling are based on showing local-competitiveness.}.

We focus on the  algorithm in the setting of unit-sized
pages. In addition to being a natural greedy policy, it has been shown
to outperform other natural policies \cite{AksoyF98}; moreover,
related variants are known to be optimal in certain stochastic
settings.  It is, therefore, of interest to better understand its
performance. We are motivated by the following questions. Is there a
simpler and more intuitive analysis of  for broadcast scheduling
than the analysis presented in \cite{EdmondsP04}?  Can we close the
gap between the upper and lower bounds on the speed requirement of
 to guarantee constant competitiveness?  Can we obtain
competitive algorithms for more stringent objective functions than
average flow-time such as  norms of flow-time, average
delay-factor\footnote{Delay-factor is a recently introduced metric and
  we describe it more formally later.}  and  norms of
delay-factor? We give positive answers to these questions.

\medskip
\noindent {\bf Results:} Our results are for unit-size pages. We make two
contributions.
\begin{itemize}
\item We give a simple and intuitive analysis of  that already
  improves the speed bound in \cite{EdmondsP04}; the analysis shows
  that  is -speed -competitive for
  average flow time. Using a more complex analysis, we show that
   is -speed -competitive.
\item We show that a natural generalization of  that we call
   is -speed -competitive for minimizing the 
  norm of flow time --- these bounds extend to average delay
  factor and  norms of delay factor. These are the first
  non-trivial results for  norms in broadcast scheduling for .
\end{itemize}
 norms for flow-time for some small  such as  have
been suggested as alternate and robust metrics of performance; see
\cite{BansalP03,Pruhs07} for more on this. Our results show that
-like algorithms have reasonable theoretical performance even
for these more difficult metrics. We derive these additional results
in a unified fashion via a general framework that is made possible by
our simpler analysis for . In our recent work \cite{ChekuriIM09}
we show that  is not -competitive with any constant speed
for the -norm of delay factor. This suggests that 
may require a speed that increases with  to obtain
-competitiveness for  norms. We note that the algorithms in
\cite{EdmondsP03,EdmondsP09} that perform well for average flow time
do not easily extend to the more general objective functions that we
consider.

Our analysis of  borrows several key ideas from
\cite{EdmondsP04}, however, we make some crucial simplifications. We
outline the main differences in Section~\ref{sec:overview} where we
give a brief overview of our approach.

\medskip
\noindent {\bf Notation and Formal Definitions:} We assume that
the server has  distinct unit-sized pages of
information.  We use  to denote 'th request for a page
.  We let  denote the arrival
time of the request . The finish time  of a
request  under a given schedule/algorithm is defined to
be the earliest time after  when the page  is
sequentially transmitted by the scheduler; to avoid notational
overload we assume that the algorithm is clear from the context.
Note that multiple requests for the same page can have the same
finish time. The total flow time for an algorithm over a sequence
of requests is now defined as .
Delay-factor is a recently introduced metric in scheduling
\cite{ChangEGK08,BenderCT08,ChekuriM09}.  In the context of
broadcast scheduling, each request  has a soft deadline
 that is known upon its arrival. The slack of 
is . The delay-factor of  with finish
time  is defined to be ; in other words it is the ratio of
the waiting time of the request to its slack. It can be seen that
delay-factor generalizes flow-time since we can set  for each (unit-sized) request . Given a
scheduling metric such as flow-time or delay-factor that, for each
schedule assigns a value  to a request , one can
define the  norm of this metric in the usual way as
. Note that minimizing the sum
of flow-times or delay-factors is simply the  norm problem.
In resource augmentation analysis, the online algorithm is given a
faster machine than the optimal offline algorithm. For ,
an algorithm  is -speed -competitive if  when the
given -speed machine achieves a competitive ratio of .

In this paper we assume, for simplicity, the discrete time model. In
this model, at each integer time , the following things happen
exactly in the following order; the scheduler make a decision of which
page  to broadcast; the page  is broadcast and all outstanding
requests of page  are immediately satisfied, thus having finish
time ; new requests arrive. Note that new pages which arrive at 
are not satisfied by the broadcasting at the time . It is important
to keep it in mind that all these things happen only at integer times.
See \cite{EdmondsP04} for more discussion on discrete time versus
continuous time models. For the most part, we assume for simplicity
of exposition, that the algorithm is given an integer speed  which
implies that the algorithm schedules (at most)  requests in each
time slot.  For this reason we present our analysis for -speed and
-speed which extend to -speed and -speed
respectively.  Due to space constraints we defer the details of the
extensions.

\iffalse
 In this paper we assume, for simplicity, the discrete unit-time slot model.  In this model, all requests arrive at
integer times; the algorithm and adversary make scheduling decisions at the beginning of each time slot. Each page take
unit-time to transmit; hence a request  that is satisfied by a transmission of  in time slot  has a finish
time .  For the most part, we assume for simplicity of exposition, that the algorithm is given an integer speed
 which implies that the algorithm schedules (at most)  requests in each time slot. We indicate, where necessary,
how the analysis extends to non-integer speeds. See \cite{EdmondsP04} for more discussion on discrete time versus
continuous time models. \fi

\noindent {\bf Our Recent Results:} Very recently, we
have proved that  is -speed -competitive. 
Also we have shown that  is
not -competitive with -speed for any , 
which disproves Edmonds and Pruhs's conjecture that 
their lowerbound 
is tight \cite{EdmondsP04}.
The analysis of these new results is complex and
built on the work of this paper. 
Due to insufficient space, we will
include these new results in the full version. 

\medskip
\noindent {\bf Related Work:} We give a very brief description of
related work due to space constraints. We refer the reader to the
survey on online scheduling by Pruhs, Sgall and Torng \cite{PruhsST}
for a comprehensive overview of results and algorithms (see also
\cite{Pruhs07}).  Broadcast scheduling has seen a substantial amount
of research in recent years; apart from the work that we have already
cited we refer the reader to
\cite{KalyanasundaramPV00,CharikarK06,KhullerK04}, the recent paper of
Chang \etal \cite{ChangEGK08}, and the surveys \cite{PruhsST,Pruhs07}
for several pointers to known results.  As we mentioned already, a
large amount of the work on broadcast scheduling has been on offline
algorithms including NP-hardness results and approximation algorithms
(often with resource augmentation). With few exceptions
\cite{EdmondsP03}, almost all the work has focused on the unit-size
page assumption. Apart from the work on average flow-time that has
been mentioned before, the other work on online algorithms for
flow-time are the following. Bartal and Muthukrishnan
\cite{BartalM00,ChangEGK08} showed that the first-come-first-serve
rule (FCFS) is -competitive for maximum flow-time. More recently,
Chekuri and Moseley \cite{ChekuriM09} developed a -speed
-competitive algorithm for maximum delay-factor; we note
that this algorithm requires knowledge of . Constant
competitive online algorithms for maximizing throughput are given in
\cite{Kimc04,ChanLTW04,ZhengFCCPW06,ChrobakDJKK06}. Algorithms to
minimize  norms of flow-time in the context of standard
scheduling have been studied in \cite{BansalP03} and
\cite{ChekuriGKK04}. \vspace{\spone}

\subsection{Overview of Analysis}\vspace{-2mm}
\label{sec:overview} We give a high level overview of our analysis of
.  Let  denote some fixed optimal 1-speed offline
solution; we overload notation and use  also to denote the value
of the optimal schedule. Recall that for simplicity of analysis, we
assume the discrete-time model in which requests arrive at integer
times. For the same reason we analyze  with an integer speed . We can assume that  is never idle. Thus, in each time step
 broadcasts  pages and the optimal solution broadcasts 
page. We also assume that requests arrive at integer times.  At time
, a request is in the set  if it is unsatisfied by the
scheduler at time . In the broadcast setting  with speed 
is defined as the following. \vspace{\spbox}\vspace{-2mm}

\begin{center}
\begin{tabular}[r]{|c|}
\hline
\textbf{Algorithm}:  \\

\begin{minipage}{\textwidth}
\begin{itemize}
\item At any integer time , broadcast the  pages with the
  largest waiting times, where the waiting time of page  is
  .
\end{itemize}
\vspace{-7mm}
\end{minipage}\\\\

\hline
\end{tabular}
\end{center}\vspace{-2mm}

Our analysis of  is inspired by that in \cite{EdmondsP04}.  Here we summarize our approach and indicate the main
differences from the analysis in \cite{EdmondsP04}. Given the schedule of  on a request sequence , the
requests are partitioned into two disjoint sets  (self-chargeable requests) and  (non-self-chargeable requests).
Let the total flow time accumulated by  for requests in  and  be denoted by  and 
respectively. Likewise, let  and  be the flow-time  accumulates for requests in  and ,
respectively.  is the set of requests whose flow-time is comparable to their flow-time in . Hence one
immediately obtains that  for some constant .  For requests in , instead of
charging them only to the optimal solution, these requests are charged to the total flow time accumulated by 
{\em
  and} . It will be shown that  for some ; this is crux of the proof. It follows that . This shows that , which will complete our analysis. Perhaps the key idea in \cite{EdmondsP04} is the idea of
charging  to  with a ; as shown in \cite{KalyanasundaramPV00}, no algorithm for any
constant speed can be locally competitive with respect to all adversaries and hence previous approaches in the
non-broadcast scheduling context that establish local competitiveness with respect to  cannot work.

In \cite{EdmondsP04}, the authors do not charge  directly to . Instead, they further split  into
two types and do a much more involved analysis to bound the flow-time of the type 2 requests via the flow-time of type
1 requests. Moreover, they first transform the given instance to canonical instance in a complex way and prove the
correctness of the transformation. Our simple proof shows that these complex arguments can be done away with. We also
improve the speed bounds and generalize the proof to other objective functions. \vspace{\spone}

\subsection{Preliminaries}
To show that , we will map the requests in  to other requests scheduled
by  which have comparable flow time.  An issue that can occur when using a charging scheme is that one has to
be careful not to overcharge.  In this setting, this means for a single request  we must bound of the number
of requests in  which are charged to .  To overcome the overcharging issue, we will appeal to a
generalization of Hall's theorem.  Here we will have a bipartite graph  where the vertices in  will
correspond to requests in .  The vertices in  will correspond to all requests scheduled by .  A vertex  will be adjacent to a vertex  if  and  have comparable flow time and  was satisfied while 
was in our queue and unsatisfied; that is,  can be charged to .  We then use a simple generalization of Hall's
theorem, which we call \emph{Fractional Hall's Theorem}. Here a vertex of  is matched to a vertex of 
with weight  where  is not necessarily an integer. Note that a vertex can be matched to
multiple vertices.
\vspace{-2mm}

\begin{definition} [-covering]
  \label{def:covering} Let  be a bipartite graph
  whose two parts are  and , and let  be an edge-weight function.  We say that  is a
  -covering if for each ,  and for each , .
\end{definition}


The following lemma follows easily from either Hall's Theorem or the Max-Flow Min-Cut Theorem.
\vspace{-1mm}
\begin{lemma}[Fractional Hall's theorem]
 \label{lem:Hall_thm}
 Let  be a bipartite graph whose two parts are
  and , respectively. For a subset  of , let , , be the neighborhood of . For
 every , if , then there
 exists a -covering for .
\end{lemma}

Throughout this paper we will discuss time intervals and unless explicitly mentioned we will assume that they are
closed intervals with integer end points. When considering some contiguous time interval  we will say that
 is the length of interval ; in other words it is the number of integers in . For simplicity, we abuse
this notation; when  is a set of closed intervals, we let  denote the number of distinct integers in some
interval of . Note that  also can be seen as the sum of the lengths of maximal contiguous sub-intervals if 
is composed of non-overlapping intervals.

\iffalse
 If  is not contiguous, then let  be sum of the lengths of the maximal contiguous sub-intervals of .
\fi


To be able to apply Lemma~\ref{lem:Hall_thm}, we show another lemma which will be used throughout
this paper. Lemma~\ref{lem:intervals} says that the union of some fraction of time intervals is comparable to that of the whole
time interval.


\begin{lemma}
\label{lem:intervals} Let  be a finite set of closed intervals and let  be an associated set of intervals such that for ,  and . Then .
\end{lemma}


\iffalse
\begin{lemma}
\label{lem:intervals}
    Let  be a finite set of intervals and .
    Then for , 
\end{lemma}
\begin{proof}
  For , let  and . We first prove that when
   forms a continuous interval, . Note that  is
  also a continuous interval. For simplicity, let  and . Let
   and  denote interval  and 's
  beginning and finishing times, respectively, i.e.  and . By definition, it must be the
  case that (1) . Let  be an
  interval such that . Then we know that . Thus, (2) . By combining (1) and (2), we get the
  desired result. If  is not one continuous interval, let
   be
  the set of maximal continuous intervals in . We can
  show that .
\end{proof}
\fi \vspace{-6mm}

\section{Minimizing Average Flow Time}\vspace{-2mm}
\label{sec:broadcast} \vspace{-2mm} We focus our attention to minimizing average flow time. A fair amount of notation
is needed to clearly illustrate our ideas.  Following \cite{EdmondsP04}, for each page, we will partition time into
intervals via \emph{events}.  Events for page  are defined by 's broadcasts of page . When 
broadcasts page  a new event occurs. An event  for page  will be defined as  where  is the beginning of the event and  is the end. Here  broadcast page
 at time  and this is the th broadcast of page . Then  broadcast page  at time 
and this is the st broadcast of page . This starts a new event . Therefore, the algorithm 
does not broadcast  on the time interval . Thus, it can be seen that for page , . It is important to note that the optimal offline solution may broadcast page  multiple (or zero)
times during an event for page .  See Figure~\ref{fig:event}.
\begin{figure}[tbh]
\begin{center}
\includegraphics[scale=.6]{lwf-pic.pdf}\vspace{-4mm}
\caption{Events for page .} \label{fig:event}
\end{center}
\vspace{-9mm}
\end{figure}


For each event  we let  denote the set of
requests for  that arrive in the interval  and are satisfied by  at . We let
 denote the flow-time in  of all requests in . Similarly we define  to be flow
time in  for all requests in . Note that  may or may not satisfy requests in  during
the interval .

An event  is said to be self-chargeable and in the set  if
 or , where  is a constant which will be fixed later.  Otherwise the event is
non-self-chargeable and is in the set . Implicitly we are
classifying the requests as self-chargeable or non-self-chargeable,
however it is easier to work with events rather than individual
requests. As the names suggest, self-chargeable events can be easily
charged to the flow-time of an optimal schedule. To help analyze the
flow-time for non-chargeable events, we set up additional notation and
further refine the requests in .

\iffalse The intuition behind this distinction is that for self-chargeable events the flow time  accumulates
during  for page  can be ``charged'' to the flow time the optimal solution accumulates for page  during
the event. For non-self-chargeable events, the flow time will not be charged directly to the optimal solution's flow
time. \fi


Consider a non-self-chargeable event .  Note that since this
event is non-self-chargeable, the optimal solution must broadcast page
 during the interval ; otherwise,  and the event is self-chargeable.  Let  be the
last broadcast of page  by the optimal solution during the interval
. We define  for a
non-self-chargeable event  as . This ensures that the interval  is
sufficiently long; this is for technical reasons and the reader should
think of  as essentially the same as .

Let  and  denote the the total flow time for
self-chargeable and non self-chargeable events
respectively. Similarly, let  and .  For
a non-chargeable event  we divide  into early
requests and late requests depending on whether the request arrives
before  or not.  Letting  and  denote
the flow-time of early and late requests respectively, we have
. Let  and 
denote the total flow time of early and late requests of
non-self-chargeable events for 's schedule,
respectively.

The following two lemmas follow easily from the definitions.

\begin{lemma} \label{lem:SC} .
\vspace{-1mm}
\end{lemma}


\iffalse
\begin{proof}
  If , then for each request  satisfied
  at time , , where
   and  is the wait time of  in 
  and  respectively. Thus we have 
  by summing over all requests which arrive for page  on the
  interval  for an event . By summing
  over all self-chargeable events , the lemma
  follows. \end{proof}

Now we show that requests which are late for some non-self-chargeable
event can be bound similarly.

\fi

\begin{lemma}
\label{lem:NSCl}
 .
\end{lemma}
\iffalse
\begin{proof}
  Consider an event . First consider the case where . Recall that  by
  definition. Because  did not broadcast page  during
  ,  has the same wait time as  for
  the requests which arrived on the interval  for page . If , then
  . Any request which arrived during
   for page  will be satisfied within 
  time steps, hence waiting at most  times as long as
  . Summing over requests finishes the proof.
\end{proof}

\textbf{(Another Alternate Short Proof of Lemma 2.1, and 2.2: Start)}

Lemma~\ref{lem:SC} and Lemma~\ref{lem:NSCl} can be shown by observing
any request of self-chargeable events or late request of
non-self-chargeable events is satisfied at the same time as OPT or is
satisfied within .

\textbf{(Another Alternate Short Proof of Lemma 2.1, and 2.2:End)}

The only requests which have yet to be bound are those that are early
for non-self-chargeable events.  For a non-self-chargeable event, we
want to charge the early requests' flow time to events ending during
the non-self-chargeable event. To do this, we show in the next lemma
that the flow time accumulated for the early requests of some
non-self-chargeable event is comparable to the flow time of any event
ending during the non-self-chargeable event.

\fi

Thus the main task is to bound . For a non-chargeable event
 we try to charge  to events ending in the interval
. The lemma below quantifies the relationship
between  and the flow-time of events ending in this interval.

\begin{lemma}
  \label{lem:close} For any , if  then .
\end{lemma}

\begin{proof}
  Let  be the total waiting time accumulated by  for
  page  on the time interval . We divide
   into two parts  and , which
  are the flow time due to early requests and to late requests,
  respectively. Note that .
  The early requests arrived before time , thus, for any , .

  Since  chose to transmit  at  when  was
  available to be transmitted, it must be the case that . Combining this with the
  fact that , the lemma follows.

\end{proof}

With the above setup in place, we now prove that  is 
competitive for  via a clean and simple proof, and for  via
a more involved proof. These proofs can be extended to non-integer
speeds with better bounds on the speed. In particular, we can show
that  is -competitive. We omit
these extensions in this version.

\iffalse First it is shown that with -speed the algorithm  achieves a competitive ratio of . This
proof is simple and is used to illustrate our techniques.  If non-integer speeds are allowed, this proof can be
extended to show that  is -competitive. We later improve our analysis to -speed with
a competitive ratio of . If non-integer speeds are used, this proof can be extended to show  is -competitive. \fi \vspace{-3mm}
\subsection{Analysis of -Speed}\vspace{-2mm}
\label{sec:5speed}

This section will be devoted to proving the following main lemma that
bounds the flow-time of early requests of non self-chargeable events.

\begin{lemma}
  \label{lem:5speedNSC} For , .
\end{lemma}

Assuming the lemma,  is -competitive, using the argument
outlined earlier in Section~\ref{sec:overview}.
\begin{theorem}
  \label{thm:5spd}
    .
\end{theorem}

\begin{proof}

\iffalse
 Set  and combine Lemma~\ref{lem:SC}, \ref{lem:NSCl} and \ref{lem:5speedNSC}.

\fi

By combining Lemma~\ref{lem:SC}, \ref{lem:NSCl} and
\ref{lem:5speedNSC}, we have that . Setting  completes the proof.
\end{proof}

We now prove Lemma~\ref{lem:5speedNSC}. In the analysis, we assume that  broadcasts  pages at each time;
otherwise we can apply the same argument to maximal subintervals when  is fully busy, respectively. 
Let . We define
two intervals  and .  Since , it follows that .  We wish to charge  to
events (could be in  or ) in the interval . By
Lemma~\ref{lem:close}, each event  that finishes in
 satisfies the property that . Moreover, there are 
such events to charge to since  transmits  pages in each
time slot.  Thus, locally for  there are enough events to
charge to if  is a sufficiently large constant.  However, an
event  with  may also be charged by
many other events if we follow this simple local charging scheme. To
overcome this overcharging, we resort to a global charging scheme by
setting up a bipartite graph  and invoking the fractional Hall's
theorem (see Lemma~\ref{lem:Hall_thm}) on this graph.

The bipartite graph  is defined as follows.  There is
exactly one vertex  for each non-self-chargeable event
 and there is exactly one vertex  for
each event , where  is the set of all events. Consider two vertices  and
. There is an edge  if and only
if .  By Lemma~\ref{lem:close}, if there is an
edge between  and  then .

The goal is now to show that  has a -covering. Consider any non-empty set  and a vertex . Recall that the interval 
contains at least one broadcast by  of page . Let
 be the union of the
time intervals corresponding to events in . Similarly, define
.

We claim that . This is because the optimal
solution has 1-speed and it has to do a separate broadcast for each
event in  during . Now consider the neighborhood of
, .  We note that  since
 broadcasts  pages for each time slot in 
and each such broadcast is adjacent to an event in  from the
definition of .  From Lemma~\ref{lem:intervals},  as we had already observed
that  for each . Thus we conclude that . Since this holds for , by
Lemma~\ref{lem:Hall_thm}, there must exist a -covering. Let  be such a covering. Finally, we prove
that the covering implies the desired bound on . \vspace{-2.5mm}



This finishes the proof of Lemma~\ref{lem:5speedNSC}.


\begin{remark}
  If non-integer speeds are allowed then the analysis in this
  subsection can be extended to show that  is -speed
  -competitive.
\vspace{-2.5mm}
\end{remark}

\subsection{Analysis of -Speed}\vspace{-2mm}
\label{sec:4speed}
Due to insufficient space, we only sketch the key idea.  We remind the
reader that early requests of each non-self-chargeable event 
were charged to only half the events that ended on .  Thus, fully utilizing all the events, which end during
, can improve the speed.
Lemma~\ref{lem:close}, however, does not provide a good comparison
between  and flow time of event  which is done
close to . We overcome this by further refining the class of
non self-chargeable events into  and . For an event
 in the interesting class , we are able to show that
all events in  have comparable flow-time to
that of . This allows us to effectively charge  to
events done at ; note that for any two events  and
 in , . The proof is technical and
requires several parameters; details can be found in
Appendix~\ref{sec:4speed}.


\iffalse In this section, we further improve the speed from  to  in the discrete time model.
\begin{theorem}
\label{thm:4spd}
 is -speed -competitive.
\end{theorem}
In Section~\ref{sec:5speed} early requests of each non-self-chargeable
event  were charged to events that ended on roughly the last
half of . This is because Lemma~\ref{lem:close}
does not provide a good comparison between  and flow time
of events which are done close to . In this section, we show
how all the events ending during  can be used
to pay for . To do this, non-self-chargeable events in 
are partitioned into two disjoint sets  and
. For simplicity, event  is said to have  if 
ends during .  Non-self-chargeable event
 is said to be  and in  if it has at least  self-chargeable events where  is
some constant to be fixed later. The rest of the events in  are in
 and said to be .  The  events can be charged to the
optimal solution because it has many self-chargeable events. For each
 event, we will bound  with events which end at
. Recall that Lemma~\ref{lem:close} cannot compare
 and , where . Thus we find a
\emph{bridge} events , and compare  with 
and  with , thereby  with .
\fi \vspace{-3mm}

\section{Generalization to Delay-Factor and   Norms}\vspace{-1mm}
\label{sec:metrics} \vspace{-2mm} In this section, our proof
techniques are extended to show that a generalization of  is
-speed -competitive for minimizing the average
delay-factor and minimizing the -norm of the delay-factor.
Recall that flow-time can be subsumed as a special case of
delay-factor. Thus, these results will also apply to  norms of
flow-time. Instead of focusing on specific objective functions, we
develop a general framework and derive results for delay-factor and
 norms as special cases. First, we set up some notation. We
assume that for each request  there is a non-decreasing
function  that gives the cost/penalty of that 
accumulates if it has {\em waited} for a time of  units after its
arrival. Thus the total cost/penalty incurred for a schedule that
finishes  at  is . For
flow-time  while for delay-factor it is . For  norms of delay-factor
we set .
Note that the  norm of delay-factor for a given sequence of
requests is  but we can
ignore the outer 'th root by focusing on the inner sum.

A natural generalization of  to more general metrics is described below; we refer to this (greedy) algorithm as
 for Longest First. We in fact describe  which is given  speed over the adversary. \vspace{-2mm}
\begin{center}
\begin{tabular}[r]{|c|}
\hline
\textbf{Algorithm}:  \\
\begin{minipage}{\textwidth}
\begin{itemize}
\item At any integer time , broadcast the  pages with the
largest -waiting times where the -waiting time of page  at 
 is  .
\end{itemize}
\end{minipage}\\
\hline
\end{tabular}
\end{center}

\begin{remark}
  The algorithm and analysis do not assume that the functions 
  are ``uniform'' over requests.  In principle each request 
  could have a different penalty function.
\end{remark}
In order to analyze , we need a lower bound on the ``growth''
rate of the functions . In particular we assume that there
is a function  such that
 for all . It is not to difficult to see that for flow-time and delay-factor
we can choose , and for  norms of
flow-time and delay-factor, we can set .
We also define a function 
as . The rest of the analysis depends
only on  and .

In the following subsection we outline a generalization of the
analysis from Section~\ref{sec:5speed} that applies to ; the
analysis bounds various quantities in terms of the functions  and
.  In Section~\ref{sec:metric-results}, we derive the results for
minimizing delay-factor and  norms of delay-factor.
\vspace{-2.5mm}

\subsection{Outline of Analysis} \vspace{-2mm}
\label{sec:gen-framework} To bound the competitiveness of , we use the same techniques we used for bounding
the competitiveness of . Events are again defined in the same fashion;  is the event defined by the
'th transmission of  by . We again partition events into self-chargeable and non self-chargeable events
and charge self-chargeable events to the optimal value and charge non-self-chargeable events to  for some . For an event , let  denote the total -cost of all requests for  that arrive in  that are
satisfied at . We let  be the -cost of the same set of requests for the optimal solution. An
event  is self-chargeable if  or  for some constant
 to be optimized later. The remaining events are non self-chargeable.  Again, requests for non-self-chargeable
events are divided into early requests and late requests based on whether they arrive before  or not where
.  Let  and  be the flow time accumulated for early and
late requests of a non-self-chargeable event , respectively.  The values of , ,
, and  are defined in the same way as , , , and
. Likewise for .  The following two lemmas are analogues of Lemmas~\ref{lem:SC} and \ref{lem:NSCl}
and follow from definitions.

\begin{lemma} \label{lem:GSC}
  .
\end{lemma}



\begin{lemma}
  \label{lem:GNSCl}
  .
\end{lemma}


We now show a generalization of Lemma~\ref{lem:close} that states that
any event  such that  is close to  has
-waiting time comparable to the -waiting time of early requests of
.

\begin{lemma}
\label{lem:rq_close} Suppose  and  are two events
  such that , .
\end{lemma}
\begin{proof}[Sketch]
  Consider an early request  in  and let .  Since
  , it follows that . Hence, . Summing over all early requests, it follows that
  . Since  chose
  to transmit  at  instead of , it follows that
  .
\end{proof}

As in Section~\ref{sec:5speed}, the key ingredient of the analysis is
to bound the waiting time of early requests. We state the analogue of
Lemma~\ref{lem:5speedNSC} below. Observe that we have an additional
parameter . In Lemma~\ref{lem:5speedNSC} we hard wire  to
be  to simplify the exposition. In the more general setting, the
parameter  needs to be tuned based on .

\begin{lemma}
    \label{lem:GNSC}
    For any , , where  is some
    scaling function for .
\end{lemma}

The proof of the above lemma follows essentially the same lines as
that of Lemma~\ref{lem:5speedNSC}. The idea is to charge 
to events in the interval . Using Lemma~\ref{lem:rq_close}, each
event in this interval is within a factor of  of .  The length of this interval is at least
 times the length of the interval . To avoid overcharging we
again resort to the global scheme using fractional Hall's theorem after we setup the bipartite graph. We can then prove
the existence of a -covering and since each event can pay to within a factor of
, the lemma follows.

Putting the above lemmas together we derive the following theorem.

\begin{theorem}
    \label{thm:G}
    Let  and  be given constants.  If 
    is an integer such that , then algorithm  is -speed
    -competitive.
\vspace{-2.5mm}
\end{theorem}


\subsection{Results for Delay-Factor and  Norms}
\label{sec:metric-results} \vspace{-0.5mm}

We can apply Theorem~\ref{thm:G} with appropriate choice of parameters
to show that  is -competitive with  speed.

For minimizing average delay-factor we have  and
. For this reason, average delay-factor behaves essentially
the same as average flow-time and we can carry over the results
from flow-time.

\begin{theorem}
  \label{thm:df_34spd}
  The algorithm  is -speed 
  competitive for minimizing the average delay-factor. For non-integer speeds
  it is -speed -competitive.
\end{theorem}

The analysis in Section~\ref{sec:4speed} also extends to delay-factor although it does not fall in the general
framework that we outlined in Section~\ref{sec:gen-framework}. Thus  is -speed
-competitive for average delay-factor.

For  norms of delay-factor we have  and . By choosing ,  and  in Theorem~\ref{thm:G}, we can show that
the algorithm  is -speed -competitive for minimizing .
Thus for minimizing the -norm delay factor, we obtain   competitiveness, which shows the following.


\begin{theorem}
    \label{thm:LP}
    For , the algorithm  is -speed
    -competitive for minimizing -norm of delay-factor.
\end{theorem}

\vspace{-7mm}

\section{Conclusion}\vspace{-3mm}
\label{sec:concl}
We gave a simpler analysis of  for minimizing average flow-time
in broadcast scheduling. This not only helps improve the speed bound
but also results in extending the algorithm and analysis to more
general objective functions such a delay-factor and  norms of
delay-factor. We hope that our analysis is useful in other scheduling
contexts.

Our recent work in \cite{ChekuriIM09} shows that  is not
-competitive with any speed for -norm of delay factor,
which is equivalent to minimizing the maximum delay factor. Thus, we
believe the speed requirement for  to obtain
-competitiveness needs to grow with  for -norms of delay
factor. It would be interesting to formally prove this. This raises
the question of whether there is an alternate algorithm that is
-speed -competitive for  norms of flow time and delay
factor. We remark that the lower bound for  \cite{ChekuriIM09}
applies only to delay factor and it is open whether  is
-speed -competitive for  norms of flow time.
It would be also an interesting direction
to find an -like algorithm that performs well when page sizes are different.

As we mentioned earlier, we have very recently obtained a tighter bound on : 
for any , it is -competitive with -speed and is not -competitive 
with -speed. We conjecture that our new lowerbound is tight. 
We will include our new results in the full version.

\bigskip
\noindent {\bf Acknowledgments:} We thank Kirk Pruhs for his helpful
comments and encouragement.


\bibliographystyle{plain}
\bibliography{LWF2}
\appendix



\section{Analysis of 4-speed}

\label{sec:4speed} In this section, we further improve the speed from  to  in the discrete time model. We assume
the speed  throughout this section.

\begin{theorem}
\label{thm:4spd}  is -speed -competitive.
\end{theorem}
\begin{proof}
    By combining Lemma~\ref{lem:SC}, \ref{lem:NSCl}, \ref{lem:type1} and \ref{lem:type2} (Lemma~\ref{lem:type1} and \ref{lem:type2} will be proved soon), it follows that

Setting ,  and  completes the proof.
\end{proof}



In Section~\ref{sec:5speed} early requests of each non-self-chargeable event  were charged to events that
ended on the last half of . This was a compromise between using more events vs. finding quality
events. In other words, if we use more events ending in , the average quality of those events degrades because  events ending close to  do not have flow time comparable to . On the other hand,
if we use only quality events, we can only charge to a small faction of events ending on . To overcome this issue, we will show that all events
ending in  have comparable flow time with  if only a small number of self-chargeable events end on .  This will then improve our bound on the speed.   For the other case where  has
many self-chargeable events,  will be directly charged to those self-chargeable events having comparable
flow time with , thus directly to .

We now describe this idea in more details. Non-self-chargeable events in  are partitioned into two disjoint sets
 and  depending on they have many self-chargeable events or not. Formally, Non-self-chargeable event
 is said to be  and in  if it has at least  self-chargeable events
where  is some constant to be fixed later. The rest of the events in  are in  and said to be .
We let  and  denote the total flow time of early requests of  and , respectively.
As mentioned already, the  events can be charged to the optimal solution because it has many self-chargeable
events. For each  event, we will bound  with events which end at . Recall that
Lemma~\ref{lem:close} cannot compare  and , where  is an event ending at , i.e.
. Thus we find a \emph{bridge} events which start from a way before  and end close to
. Since each bridge event  substantially overlap both with  and with , we can
compare  with  and  with , thereby  with . We also observe
that each  is charged by one event  such that , as each non-self-chargeable event
has its unique last broad cast time. Thus we are safe from overcharging.

\iffalse In this section, we show how all the events ending during  can be used to pay for
. To do this, non-self-chargeable events in  are partitioned into two disjoint sets  and
. For simplicity, event  is said to have  if  ends during .
Non-self-chargeable event  is said to be  and in  if it has at least 
self-chargeable events where  is some constant to be fixed later. The rest of the events in  are in 
and said to be .  The  events can be charged to the optimal solution because it has many self-chargeable
events. For each  event, we will bound  with events which end at . Recall that
Lemma~\ref{lem:close} cannot compare  and , where . Thus we find a
\emph{bridge} events , and compare  with  and  with , thereby
 with . \fi








In the following lemma, we directly charge early requests of  events to . For the goal, we charge early
requests of each  event  to self-chargeable events having flow time comparable to  which end
on . By the definition of  events, we know that each  event  has many
events that it can be charged to. However, to the overcharging issue, we resort to a global charging scheme again using
the modified Hall's theorem. We separate how to find a covering to Lemma~\ref{lem:cover2}, as we will use it again for
charging  events.


\begin{lemma}
\label{lem:type1} If , then .
\end{lemma}
\begin{proof}
  Let  be a bipartite graph where  iff ,  iff , and
   iff .
Note that if ,  by Lemma~\ref{lem:close}.
  It can be observed that each vertex
   has at least  neighbors.
  This follows from the observations that at least  self-chargeable
  events end during  by definition of  and
  at most  events end
  during . Thus
   has a -covering by Lemma~\ref{lem:cover2}. Let
   be such a covering. We now prove the final step.

\end{proof}

The following lemma states, when  is a bipartite graph whose parts are a subset of non-self-chargeable events and a
subset of all events respectively, the quality of covering in terms of how many neighbors each non-self-chargeable
event has. The main difference from what was done for finding a covering in the proof of Lemma~\ref{lem:5speedNSC} is
that here each non-self-chargeable event is not required to have all events ending in some sub-interval as its
neighbors.

\begin{lemma}
    \label{lem:cover2}
    Let  denote all events. Let  be a bipartite graph where there exists only one vertex  only if ,
    there exists only one vertex  only if  and  only if .
     Suppose that  such that . Then
     there exists -covering for .
\end{lemma}
\begin{proof}
  Consider any non-empty set  and its neighborhood .
  We will show that . Let  and . For simplicity we assume that  is a
  contiguous interval. Otherwise, the proof can be simply reduced to
  each maximal contiguous interval in .  First we show
  . We generously give up
  intervals in  which are contained in other intervals in
   and order the remaining intervals in increasing order
  of their starting points. After picking up the first interval, we
  greedily pick up the next interval which the least overlaps with
  the previous chosen interval or starts just after the end of the interval.
  We index the chosen intervals according
  to their orders, 1,2,3 and so on.  Let  and
   be the odd-indexed and even-indexed intervals,
  respectively. Note that no intervals in  overlap with each other.
  Likewise for . We have , since . WLOG, suppose
  .
  Let us consider any interval  in .
  We know that  (or ) has at least ,
  so by summing over all intervals in , we can find at least
  . Thus we have 
Also we have ; this is because the optimal solution has 1-speed and since it has to do a
separate broadcast for each event in . Combining these two inequalities, if follows that , and therefore  has -covering by Lemma~\ref{lem:Hall_thm}.
\end{proof}


Our attention is now shifted to  events. As mentioned previously, the main idea is to find bridge events for each
. Formally,  is said to be a \emph{bridge} event of  if  and ,
where  is a constant to be decided later. Let  be the set of bridge events of
. Recall that we want to compare  with  such that . Intuitively, a bridge
event  bridges two events  and  by stretching over both events.   The following lemma says
that every  event has many bridge events.

\begin{lemma}
  \label{lem:bdg_num} If , then for any , .
\end{lemma}
\begin{proof}
  Let . Let  and .
  Our argument is simple; because there are many non-self-chargeable events ending in ,
  the last optimal broadcast times of many of those events cannot be contained in , thus many events start a way
  earlier than . For the formal proof, we first show that
  (1)there are at least 
  non-self-chargeable events that end during . This is because
  there are at least  events which end during
   and  event  has at most  self-chargeable events which end during
   by definition. Note that for any non-self-chargeable event  which
  ends on ,  must broadcast  page  before ,
  more precisely , that is . Let .  Finally, (2)there are at most  time slots when 
  can broadcast pages during .
  From (1) and (2), we can deduce that .

\iffalse
  From (1) and (2), we
  can deduce that .
\fi
\end{proof}

In the next lemma, we show each bridge event  provides a good comparison between
 and the flow time of any event  which end at .

\begin{lemma}
  \label{lem:bdg} Suppose that . Let ,  and  be an
  event s.t. .  Then, .
\end{lemma}
\begin{proof}
  We start from an easy case that . We have
  . The first inequality comes from
  that  and
  the second by Lemma~\ref{lem:close}. Thus it holds that , which clearly satisfies the lemma.

  Now let us consider the other case that . By
  comparing  and , using Lemma~\ref{lem:close}, we
  have (1) . The first
  inequality holds because  and the second by Lemma~\ref{lem:close}. Next we compare  and . It follows that
  (2) . The first inequality can be shown by easy calculation
  using the fact that  and .
  The second follows from that . Combining (1) and (2), we get .
\end{proof}

\begin{remark}
Lemma~\ref{lem:bdg} holds for any event  such that . But we only need to
consider the case where  for our charging scheme.
\end{remark}


By taking the average of the inequalities in Lemma~\ref{lem:bdg} over the  events ending at , we have the
following corollary.

\begin{corollary}
    \label{cor:bdg}
    Suppose that . Let  and
    . \\ Then, 
\end{corollary}

Note that in Lemma~\ref{lem:bdg},  is bounded not only with  but also with , which
contributes to . If many events use  as their bridges,  can be overcharged. To avoid this, we
found many bridge candidates for each  event in Lemma~\ref{lem:bdg_num}. Using the modified Hall's theorem, we
will bound the number of events which use the same bridge event.

Now we are ready to bound early requests of  events, i.e. . Recall that each  event  is
charged to the  events which are finished at . Note that  is used only by  since
 is the only event such that . Thus  is not overcharged.


\begin{lemma}
    \label{lem:type2}
    If , .
\end{lemma}
\begin{proof}
  Let  be a bipartite graph where  iff ,  iff  and
   iff . By
  Lemma~\ref{lem:bdg_num},  has at least  neighbors, hence by Lemma~\ref{lem:cover2}, 
  has -covering. Let  be such a covering.
  Now we are ready to prove the final step. For simplicity,
  let .

It holds that (*)~, because for each
non-self-chargeable  there is only one event  such that .
\end{proof}

\begin{remark}
  If non-integer speeds are allowed then the analysis in this
  subsection can be extended to show that  is -speed
  -competitive.
\end{remark}


\section{Omitted Proofs}
\subsection{Proof of Lemma~\ref{lem:intervals}}
\begin{proof}
Let  be the union of all intervals in .  is similarly defined for . We prove the lemma when  is a
contiguous interval; otherwise we can simply sum over all maximal intervals in . WLOG, we can set 
and . This is because  must start with one interval in , say  and both  and 
must have the same ending point  by construction. Since , it is enough to show that  and it follows from the given condition that , (i.e. ) and .
\end{proof}


\end{document}
