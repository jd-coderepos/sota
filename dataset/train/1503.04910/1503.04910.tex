\documentclass[UKenglish]{eptcs}

\usepackage[usenames,dvipsnames]{color}

\usepackage{times}
\usepackage[latin1]{inputenc}
\usepackage{pslatex}
\usepackage{amsmath}\let\boldsymbol\pmb
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{hyperref}
\usepackage{breakurl}
\usepackage{prooftree}
\usepackage{txfonts}
\usepackage{lscape}
\usepackage[all]{xy}
\usepackage{textcomp}
\usepackage{breakurl}

\pagestyle{plain}






\usepackage{color}



\newif\ifmm
\mmtrue \newcommand{\mm}[1]
{\ifmm{\color{red}{#1}}\else{#1}\fi}

\newif\ifmc
\mcfalse \mctrue \newcommand{\MD}[1]
{\ifmc{\color{blue}{#1}}\else{#1}\fi}
\newcommand{\mc}[1]
{\ifmc{\color{magenta}{#1}}\else{#1}\fi}

\newcommand{\MDC}[1]
{\ifmc{\color{magenta}{#1}}\else\fi}
\newcommand{\MI}[1]
{\ifmc{\color{ForestGreen}{#1}}\else\fi}

\newtheorem{fact}{Fact}[section]

\newenvironment{notation}{\paragraph{{\bf Notation.}}}{}

\newtheorem{proposition}[fact]{Proposition}

\newtheorem{remark}[fact]{Remark}

\newtheorem{lemma}[fact]{Lemma}

\newtheorem{corollary}[fact]{Corollary}

\newtheorem{definition}[fact]{Definition}

\newtheorem{theorem}[fact]{Theorem}

\newtheorem{conjecture}[fact]{Conjecture}

\newcommand{\dup}{\! : \!}
\newcommand{\fhp}{\text{\small FHP}}   \newcommand{\fhi}{\text{\small FHI}}   \newcommand{\CC}{\mathcal{C}}
\newcommand{\DD}{\mathcal{D}}
\newcommand{\V}{\mathcal{V}}
\newcommand{\PP}{\mathcal{P}}
\newcommand{\tA}{\sigma}       \newcommand{\tB}{\tau}
\newcommand{\tC}{\rho}
\newcommand{\tD}{\zeta}
\newcommand{\tE}{\vartheta}
\newcommand{\tF}{\zeta}
\newcommand{\tG}{\varsigma}
\newcommand{\tM}{\mu}
\newcommand{\tN}{\nu}
\newcommand{\tl}{\lambda}
\newcommand{\te}{\xi}
\newcommand{\tv}{\eta}
\newcommand{\ti}{\chi}
\newcommand{\tk}{\kappa}
\newcommand{\tx}{\iota}
\newcommand{\tu}{\omega}
\newcommand{\tr}{\upsilon}
\newcommand{\tO}{\alpha}
\newcommand{\tP}{\beta}
\newcommand{\tQ}{\eta}
\newcommand{\tY}{\theta}
\newcommand{\tI}{\alpha}
\newcommand{\tL}{\beta}
\newcommand{\tV}{\eth}
\newcommand{\B}{\Gamma}
\newcommand{\imps}{\text{ implies }}
\newcommand{\db}{\displaystyle}
\newcommand{\rel}[3]{#1\circleright#2\rightarrow#3}
\newcommand{\relL}[3]{#1\Diamondright#2\rightarrow#3}
\newcommand{\sut}[2]{#1\leq#2}
\newcommand{\seq}[2]{\langle#1,\ldots,#2\rangle}
\newcommand{\seqs}[1]{\langle#1\rangle}
\newcommand{\tsi}{\sim}
\newcommand{\tsiw}{\sim^w}
\newcommand{\tS}{\sigma}       \newcommand{\tT}{\tau}
\newcommand{\tR}{\rho}
\renewcommand{\l}{\lambda}
\newcommand{\Pe}{\hfp}
\newcommand{\hfp}{P}
\newcommand{\der}[3]{#1\vdash #2\dup #3}
\newcommand{\p}{{\sf p}}
\newcommand{\cJ}{{\cal J}}
\newcommand{\calP}{{\cal P}}
\newcommand{\calL}{{\cal L}}
\newcommand{\calR}{{\cal R}}
\newcommand{\gO}{\Delta\Delta}
\newcommand{\spazio}{\ \ }
\newcommand{\ctasprimo}{\vdash^{\tytv'}}
\newcommand{\filterscheme}{{\cal S}}
\newcommand{\red}{\Longrightarrow}
\newcommand{\typ}[3]{#2\stackrel{#1}{\Longrightarrow}#3}
\newcommand{\s}[1]{\texttt{s}(#1)}
\newcommand{\na}[1]{|#1|}
\newcommand{\vf}{\varphi}
\newcommand{\w}[1]{\ensuremath{dw(#1)}}
\newcommand{\cw}[1]{\ensuremath{cw(#1)}}
\newcommand{\wt}[1]{\ensuremath{w(#1)}}
\newcommand{\set}[1]{\ensuremath{\{#1\}}}
\newcommand{\li}[2]{\langle#1,\ldots,#2\rangle}
\newcommand{\ag}[2]{#1\propto#2}
\newcommand{\agn}[2]{#1\not\propto#2}
\newcommand{\C}[1]{{\cal C}[#1]}
\newcommand{\pa}[1]{s(#1)}
\newcommand{\pad}[1]{d(#1)}
\newcommand{\Cp}[1]{{\cal C'}[#1]}
\newcommand{\nag}[2]{#1\not\propto#2}
\newcommand{\iso}{\approx}
\newcommand{\isow}{\;\approx^w\;}
\newcommand{\isowk}{\approx^w}
\newcommand{\id}{{\sf Id}}
\newcommand{\tob}{\;{_\beta}\!\!\longleftarrow}
\newcommand{\mtob}{\;^*\!\!\!\!{_\beta}\!\!\longleftarrow}
\newcommand{\tp}{\!\dup\!}
\newcommand{\unl}[1]{\underline{#1}}
\newcommand{\labelx}[1]{\label{#1}}
\newcommand{\ct}[2]{#1^\frown#2}
\newcommand{\rv}[2]{#1\upharpoonright FV(#2)}
\newcommand{\lp}{\swarrow}
\newcommand{\rp}{\searrow}
\newcommand{\ep}{\square}
\newcommand{\q}{{\sf p}}
\newcommand{\Sp}{e}
\newcommand{\Ip}{\#}
\newcommand{\isot}{\approx}
\newcommand{\isos}{\approx_{\sf s}}
\newcommand{\nisos}{\not\approx_{\sf s}}
\newcommand{\nf}[1]{#1\!\!\downarrow}
\newcommand{\nfw}[1]{#1\!\!\downarrow^w}
\newcommand{\peq}{\sim}
\newcommand{\pp}{\P}
\newcommand{\niso}{\not\approx}
\newcommand{\mi}{\leq^\wedge\!\!}
\newcommand{\muu}{\leq^\vee\!\!}
\newcommand{\mui}{\leq^\top}      \newcommand{\md}{\leq^{\Diamond}\!\!}
\newcommand{\mds}{\leq^{\Diamond}}
\newcommand{\subject}{Subject}
\newcommand{\reduction}{Reduction}
\newcommand{\core}[1]{c(#1)}
\newcommand{\ovarr}[1]{\overrightarrow{#1}}
\newcommand{\res}{\upharpoonleft}
\newcommand{\sminus}{\backslash}
\newcommand{\ta}[1]{\uparrow\!\!{(#1)}}
\newcommand{\myformula}[1]{\4pt]\centerline{#1}\4pt]\centerline{#1}}
\newcommand{\myformulaB}[1]{\10pt]
(C) ~~ \db \frac{\B_{1},x\dup\tA \vdash M\dup\tB\quad \B_{2} \vdash N\dup\tA}{\B_{1}, \B_{2} \vdash M[N/x]\dup\tB}
&\qquad&(\vee I') ~~ \db \frac{\B, x\dup\tA \vdash M\dup\tC\quad \B, x\dup\tB \vdash M\dup\tC}{\B, x\dup\tA\vee\tB \vdash M\dup\tC}
\1mm]
\tS \leq  \tT,\; \tS \leq  \tR \Rightarrow
              \tS  \leq  \tT \wedge  \tR \quad \quad \tS \leq  \tT,\; \tR \leq  \tT \Rightarrow
              \tS  \vee  \tR \leq  \tT
              \2pt]

\item \labelx{rrt2} The top type normalisation rules are:
\myformulaB{

}
\end{enumerate}
\end{definition}
The first two rules follow immediately from semantic type equivalence; moreover, since , an admissible rule is \hbox{.} The following four rules correspond to the distribution isomorphisms.  The last rule corresponds to the  \textbf{erase} isomorphism.
Note that in the inner rules  and  the isomorphism \mbox{\rm{\bfseries dist}} is used only on the left of an arrow and the isomorphism \mbox{\rm{\bfseries dist}} is used on the right of an arrow, respectively. These rules generate  normal forms for arrow types in which the type on the left is an intersection and the type on the right is a union. Moreover the top rule
 allows one to define for types a ``conjunctive" normal form.

For example:
\myformula{}
\myformula{}

\smallskip

Having two kinds of normalisation rules (inner and top) allows to apply only one of  the isomorphisms  \mbox{\rm{\bfseries dist}} and \mbox{\rm{\bfseries dist}} at each subtype of a type. This is crucial to assure termination of normalisation.

The present normalisation rules are much simpler than those in~\cite{CDMZ13a}. The functional behaviour of atomic types produces this simplification.
\begin{theorem}[Soundness of the normalisation rules]\labelx{srr}
\begin{enumerate}
\item \labelx{srr1}If , then .
\item \labelx{srr2}If , then .
\end{enumerate}
\end{theorem}
\begin{proof}
(\ref{srr1}). Rule  is obtained by orienting the equivalence relation between types, so it is sound since equivalent types are isomorphic. Rule  is sound because, by Lemma~\ref{ma}(\ref{ma2}), there is  an \fhi      such that , and obviously .  Rules ,   ,  and   are sound by the strong isomorphisms of Lemma~\ref{arrowIso}.
 Lemma~\ref{ma}(\ref{ma3}) implies the soundness of rule . \\
(\ref{srr2}). The soundness of the rule  is proved in Lemma~\ref{in}. The strong isomorphism \mbox{\rm{\bfseries dist}} gives the soundness of rule .

\end{proof}
For example , as shown before, and   proves \myformula{.}

\smallskip

The following theorem shows the existence and uniqueness of the normal forms, i.e. that the top normalisation rules are terminating and confluent.


\begin{theorem} [Uniqueness of normal form]\labelx{uni}
The top normalisation rules of Definition~\ref{rrt} are terminating and confluent.
\end{theorem}
\begin{proof}The {\em termination} follows from an easy adaptation of the recursive path ordering method~\cite{D82}. The partial order on operators is defined by:  for  holes at top level or in the right-hand-sides of arrow types and   for holes in the left-hand-sides of arrow types. Notice that the induced recursive path ordering  has the subterm property. This solves the case of rules , , .
For
rule , since , it is enough to observe that  and        .
For rules  and , since  for holes at top level or in the right-hand-sides of arrow types, it is enough to observe that  and        . The proof for the remaining rules are similar.

 For {\em confluence}, thanks to the Newman Lemma~\cite{N42}, it is sufficient to  prove  the convergence of the critical
 pairs. For example, the  types  and  give rise to critical pairs, as well as the following ones, when :
 \myformula{ ,\qquad ,\qquad , \qquad
,\qquad.
}
Other examples of critical pairs are
 if , and  if \end{proof}


The
normal form of a type , unique modulo commutativity and associativity, is denoted by . The soundness of the normalisation rules (Theorem~\ref{srr}) implies that each type is strongly isomorphic to its normal form.
\begin{corollary}\label{inf} .
\end{corollary}

As expected, semantic equivalent types have the same normal form. Clearly the inverse is false, since, for example, , but .

\begin{lemma}\labelx{nc}
If  , then .
\end{lemma}
\begin{proof} The proof is by cases on Definition~\ref{eq}. For the equivalences  and , rules  and  give  and , respectively. For the equivalences , ,  and , rule , with , gives  and . The congruence follows from rule .
\end{proof}

\section{Similarity as Isomorphism}\labelx{sse}
This section shows the main result of the paper, i.e. that two types with ``similar'' normal forms (Definition \ref{simil}) are isomorphic.
The basic aim of the similarity relation is that of formalising
isomorphism determined by argument permutations (as in the swap
equation). This relation has  to take into
account the fact that, for two types to be isomorphic, it is not
sufficient that they coincide modulo permutation of types in the
arrow sequences, as in the case of cartesian products. Indeed the
same permutation must be applicable to all types
in the corresponding intersections and unions. The key notion of similarity exactly expresses such a condition.

To define similarity, it is useful to distinguish between different kinds of types. So in the following:
\begin{itemize}
\item   range over atomic and normal arrow types, i.e. ;
\item  range over normal intersections of atomic and arrow types, i.e. ;
\item   range over normal unions of atomic and arrow types, i.e. ;
\item  range over normal types, i.e. .
\end{itemize}


\begin{definition}[Similarity]\labelx{simil}
The {\em similarity} relation between two sequences of normal types  and , written ,
is the smallest equivalence relation such that:
\begin{enumerate}
\item\labelx{simil1}  \item\labelx{simil2} if , then
\myformula{
 and}
\myformula{;}
\item\labelx{simil3} if  for  and , then
\myformula{}
where  is a permutation of .
\end{enumerate}
\emph{Similarity between normal types} is trivially defined as similarity between unary sequences:
 if .
\end{definition}
 \noindent
 For example, , ,  imply
 \myformula{ by (\ref{simil3}) and then }
 \myformula{ by (\ref{simil2})}. This, together with  ,   , , gives \myformula{} by  (\ref{simil3}).


\smallskip

The proof of the similarity soundness requires some ingenuity.
\begin{theorem}[Soundness]\labelx{ParteVera} If , then
there is a pair of \fhp s that proves , for
.
\end{theorem}
\begin{proof}
By induction on the definition of
 (Definition \ref{simil}). 

(\ref{simil1}). . The identity proves the isomorphism.

(\ref{simil2}).
~~ since ~~
 .
By the
induction hypothesis there is a pair  that proves , for
. By Corollary \ref{cor}(\ref{cor5}), the same pair proves . By Theorem \ref{srr} there are \fhi s  such that
 proves  and  proves . Clearly \mbox{} and  for .
Then the pair \mbox{} proves the required isomorphisms.
The proof for the case\\ \centerline{,} since
, is analogous.\\

(\ref{simil3}).

\vspace{-5mm}

 since  for  and .
 By the induction hypothesis, there are pairs  proving  and a pair  proving  for   and . Let\\
  \centerline{}
 It is easy to verify that
  \myformula{}
 for . Notice that \3pt]
since  are normal intersections of atomic and arrow types and  is a normal union of atomic and arrow types. Then , and,
by the typing rule :
 \myformula{}
 for .
 So  is the required pair.

\end{proof}

An immediate implication of the Soundness Theorem and of Corollary~\ref{inf} is that two types  with similar normal forms are isomorphic.

\begin{corollary} \label{sum}
If , then .
\end {corollary}

For example the isomorphism of the types, shown similar after Definition~\ref{simil}, is proved by
\myformula{.}



\section{Conclusion}\label{conc}

This paper studies type isomorphism for a typed -calculus with intersection and union types, in which all types have a functional character.
 Atomic types become types of functions by assuming
 an equivalence relation that equates any atomic type  to  . This equivalence has been introduced in~\cite{CDHL84} for constructing a filter model isomorphic to Scott's  and it is validated by the standard interpretation of types in this model. In the so obtained type system all types which are set-theoretically equal (using idempotence, commutativity, associativity and distributivity of intersection and union) are proved isomorphic
by the identity.

Basic notions for the given development are those of type normalisation and similarity between normal types. Similarity provides a remarkable insight on isomorphism and we conjecture that, indeed, it gives a complete characterisation of type isomorphism for the system considered in the paper. We leave the proof of this conjecture as future work.

Following  D\'iaz-Caro and Dowek~\cite{DD14} we aim to extend the type assignment systems developed in~\cite{CDMZ13}  and~\cite{CDMZ13a}, by equating all isomorphic types.  This would lead to introduce equivalence rules on -terms, see~\cite{DD14}.
Lastly we plan to study type isomorphism in other assignment system with intersection and union types as, for instance, the ones for the lazy -calculus.\\

\smallskip

\noindent
{\bf Acknowledgements} The authors gratefully thank the referees  and Alejandro D\'iaz-Caro for their numerous constructive remarks.


\bibliographystyle{eptcs}
\bibliography{biblio}


\end{document}
