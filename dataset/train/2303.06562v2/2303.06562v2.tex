
\documentclass{article} 
\usepackage{iclr2023_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}
\def\ie{\emph{i.e}\onedot}

\def\reta{{\textnormal{$\eta$}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{hyperref}
\usepackage{url}
\usepackage[english]{babel}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{multirow}
\usepackage{adjustbox}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{colortbl}
\usepackage{wrapfig}

\theoremstyle{definition}
\newtheorem{manualtheoreminner}{Proposition}
\newenvironment{manualproposition}[1]{\renewcommand\themanualtheoreminner{#1}\manualtheoreminner
}{\endmanualtheoreminner}

\newtheorem{definition}{Definition}[section]
\newtheorem{lemma}{Lemma}[section]

\theoremstyle{remark}
\newtheorem*{remark}{Remark}

\theoremstyle{theorem}
\newtheorem*{theorem}{Theorem}
\newtheorem{proposition}{Proposition}
\newcommand{\yifei}[1]{{\color{red}[Yifei: #1]}}
\newcommand{\tianqi}[1]{{\color{blue}[Tianqi: #1]}}

\linespread{0.949}

\title{ContraNorm: A Contrastive Learning Perspective on Oversmoothing and Beyond}


\author{Xiaojun Guo$^1$\thanks{Equal Contribution.}~~~ Yifei Wang$^{2*}$~~ Tianqi Du$^{2 *}$~~ Yisen Wang$^{1,3}$ \thanks{Corresponding Author: Yisen Wang (yisen.wang@pku.edu.cn)} \\
$^1$National Key Lab of General Artificial Intelligence,\\ \, School of Intelligence Science and Technology, Peking University\\
$^2$School of Mathematical Sciences, Peking University\\
$^3$Institute for Artificial Intelligence, Peking University
}

\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy 
\begin{document}


\maketitle


\begin{abstract}
Oversmoothing is a common phenomenon in a wide range of Graph Neural Networks (GNNs) and Transformers, where performance worsens as the number of layers increases. Instead of characterizing oversmoothing from the view of \textit{complete collapse} in which representations converge to a single point, we dive into a more general perspective of \textit{dimensional collapse} in which representations lie in a narrow cone. Accordingly, inspired by the effectiveness of contrastive learning in preventing dimensional collapse, we propose a novel normalization layer called \textbf{ContraNorm}. Intuitively, ContraNorm implicitly shatters representations in the embedding space, leading to a more uniform distribution and a slighter dimensional collapse. On the theoretical analysis, we prove that ContraNorm can alleviate both complete collapse and dimensional collapse under certain conditions. Our proposed normalization layer can be easily integrated into GNNs and Transformers with negligible parameter overhead. Experiments on various real-world datasets demonstrate the effectiveness of our proposed ContraNorm. Our implementation is available at \url{https://github.com/PKU-ML/ContraNorm}.
\end{abstract}

\section{Introduction}

Recently, the rise of Graph Neural Networks (GNNs) has enabled important breakthroughs in various fields of graph learning \citep{ying2018graph, senior2020improved}. Along the other avenue, although getting rid of bespoke convolution operators, Transformers \citep{vaswani2017attention} also achieve phenomenal success in multiple natural language processing (NLP) tasks \citep{lan2019albert, liu2019roberta, rajpurkar2018know} and have been transferred successfully to computer vision (CV) field \citep{dosovitskiy2020an, liu2021swin, strudel2021segmenter}. Despite their different model architectures, GNNs and Transformers are both hindered by the oversmoothing problem \citep{li2018deeper, tang2021augmented}, where deeply stacking layers give rise to indistinguishable representations and significant performance deterioration. 

In order to get rid of oversmoothing, we need to dive into the modules inside and understand how oversmoothing happens on the first hand. However, we notice that existing oversmoothing analysis fails to fully characterize the behavior of learned features. A canonical metric for oversmoothing is the average similarity \citep{zhou2021deepvit, gong2021vision, wang2022anti}. The tendency of similarity converging to 1 indicates representations shrink to a single point (complete collapse). However, this metric can not depict a more general collapse case, where representations span a low-dimensional manifold in the embedding space and also sacrifice expressive power, which is called dimensional collapse (left figure in Figure \ref{method-illustration}). In such cases, the similarity metric fails to quantify the collapse level. Therefore, we need to go beyond existing measures and take this so-called \textit{dimensional collapse} into consideration. Actually, this dimensional collapse behavior is widely discussed in the contrastive learning literature \citep{jing2021understanding, hua2021feature, chen2021exploring, grill2020bootstrap}, which may hopefully help us characterize the oversmoothing problem of GNNs and Transformers. The main idea of contrastive learning is maximizing agreement between different augmented views of the same data example (i.e. positive pairs) via a contrastive loss. Common contrastive loss can be decoupled into alignment loss and uniformity loss \citep{wang2020understanding}. The two ingredients correspond to different objectives: alignment loss expects the distance between positive pairs to be closer, while uniformity loss measures how well the embeddings are uniformly distributed. 
Pure training with only alignment loss may lead to a trivial solution where all representations shrink to one single point. Fortunately, the existence of uniformity loss naturally helps solve this problem by drawing representations evenly distributed in the embedding space.

Given the similarities between the oversmoothing problem and the representation collapse issue, we establish a connection between them. Instead of directly adding uniformity loss into model training, we design a normalization layer that can be easily used out of the box with almost no parameter overhead. To achieve this, we first transfer the uniformity loss used for training to a loss defined over graph node representations, thus it can optimize representations themselves rather than model parameters. Intuitively, the loss meets the need of drawing a uniform node distribution. Following the recent research in combining optimization scheme and model architecture \citep{yang2021graph, zhu2021interpreting, xie2021optimization,chen2022optimization}, we use the transferred uniformity loss as an energy function underlying our proposed normalization layer, such that descent steps along it corresponds with the forward pass. By analyzing the unfolding iterations of the principled uniformity loss, we design a new normalization layer \textbf{ContraNorm}. 
\begin{wrapfigure}{r}{0.5\textwidth}
  \begin{center}
    \includegraphics[width=0.48\textwidth]{images/ContraNorm.png}
  \end{center}
  \vspace{-0.1 in}
  \caption{An illustration of how our proposed ContraNorm solves the dimensional collapse. \textbf{Left}: Features suffer from dimensional collapse. \textbf{Right}: With the help of ContraNorm, features become more uniform in the space, and the dimensional collapse is eased.} \label{method-illustration}
  \vspace{-0.1 in}
\end{wrapfigure}
As a proof of concept, Figure \ref{method-illustration} demonstrates that ContraNorm makes the features away from each other, which eases the dimensional collapse. Theoretically, we prove that ContraNorm increases both average variance and effective rank of representations, thus solving complete collapse and dimensional collapse effectively. We also conduct a comprehensive evaluation of ContraNorm on various tasks. Specifically, ContraNorm boosts the average performance of BERT \citep{devlin2018bert} from 82.59\% to 83.54\% on the validation set of General Language Understanding Evaluation (GLUE) datasets \citep{wang2018glue}, and raises the test accuracy of DeiT \citep{touvron2021training} with 24 blocks from 77.69\% to 78.67\% on ImageNet1K \citep{russakovsky2015imagenet} dataset. For GNNs, experiments are conducted on fully supervised graph node classification tasks, and our proposed model outperforms vanilla Graph Convolution Network (GCN) \citep{kipf2016semi} on all depth settings. Our contributions are summarized as:
\begin{itemize}
    \item We dissect the limitations of existing oversmoothing analysis, and highlight the importance of incorporating the dimensional collapse issue into consideration.
    \item Inspired by the techniques from contrastive learning to measure and resolve oversmoothing, we propose ContraNorm as an optimization-induced normalization layer to prevent dimensional collapse.
    \item Experiments on a wide range of tasks show that ContraNorm can effectively mitigate dimensional collapse in various model variants, and demonstrate clear benefits across three different scenarios: ViT for image classification, BERT for natural language understanding, and GNNs for node classifications. 
\end{itemize}




\section{Background \& Related Work}

\textbf{Message Passing in Graph Neural Networks.} In the literature of GNNs, message-passing graph neural networks (MP-GNNs) are intensively studied. It progressively updates representations by exchanging information with neighbors. The update of node $i$'s representation in $l$-th layer is formalized as
$
    \vh^{(l)}_i = \mbox{UPDATE}\big(\vh^{(l-1)}, \mbox{AGGREGATE}(\vh^{(l-1)}_i, \{\vh^{(l-1)}_j \left\vert \right.j \in \gN(i)\})\big),
$
where $\gN(i)$ denotes the neighborhood set of node $i$, $\mbox{AGGREGATE}(\cdot)$ is the procedure where nodes exchange message, and $\mbox{UPDATE}(\cdot)$ is often a multi-layer perceptron (MLP). A classical MP-GNNs model is GCN \citep{kipf2016semi}, which propagates messages among one-hop neighbors.

\textbf{Self-Attention in Transformers.} Transformers encode information in a global scheme with self-attention as the key ingredient \citep{vaswani2017attention}. Self-attention module re-weights intermediate representations by aggregating semantically near neighbors. Formally, it estimates similarities between key and query, namely self-attention matrix, as $\bar{\mA} = \mbox{softmax}(\mQ\mK^{\top})$, $\mQ=\mX\mW_Q$, and $\mK=\mX\mW_K$ where $\mX$, $\mW_Q$, and $\mW_K$ are the input, weight matrices for query and key, respectively. A multi-head self-attention module with a residual connection can be formularized as $\mbox{\rm{attn}}(\mX) = \mX + \sum_{k=1}^h \bar{\mA}_k\mX\mV_k\mW_k^{\top},$
where $h$ is the number of heads, and $\mV$, $\mW$ are weights for value and final output.

\textbf{Connections between Message Passing and Self-Attention.}
Note that the self-attention matrix can be seen as a normalized adjacent matrix of a corresponding graph \citep{shi2022revisiting}. Considering a weighted fully connected graph $G$ with adjacency matrix denoted as $\hat{\mA}$, we map nodes to token representations and set weights of the edge between node $i$ and node $j$ to $\exp({\mQ_i^{\top}\mK_j})$. Then $(i,j)$ entry of a normalized adjacency matrix is $\tilde{\mA}_{ij} = \hat{\mA}_{ij} / \hat{\mD}_{ij} = \exp({\mQ_i^{\top}\mK_j}) / \sum_k \exp(\mQ_i^{\top}\mK_k)$, where diagonal matrix $\hat{\mD}_{ii} = \sum_j\hat{\mA}_{ij}$. Apparently, $\tilde{\mA}$ is equal to the form of self-attention matrix defined in Transformers. Simultaneously, $\tilde{\mA}$ plays a major part in the message-passing scheme by deciding which nodes to exchange information with.

\textbf{Oversmoothing in GNNs and Transformers.} The term oversmoothing is firstly proposed by \citet{li2018deeper} in research of GNNs. Intuitively, representations converge to a constant after repeatedly exchanging messages with neighbors when the layer goes to infinity. \citet{zhou2020graph} mathematically proves that, under some conditions, the convergence point carries only information of the graph topology. Coincidentally, an oversmoothing-like phenomenon is also observed in Transformers. Unlike CNNs, Transformers can not benefit from simply deepening layers, and even saturates with depth increasing. Early works empirically ascribe it to attention/feature collapse or patch/token uniformity \citep{tang2021augmented, zhou2021deepvit, gong2021vision, yan2022addressing}. To be specific, the attention maps tend to be overly similar in later layers, whereby features insufficiently exchange information and lose diversity in the end. Outputs of pure transformers, i.e., attention without skip connections or MLPs, are also observed to converge to a rank-1 matrix \citep{dong2021attention}. For illustration proposes, we also refer to the degeneration issue in Transformers as oversmoothing. 

\textbf{Whitening Methods for Dimensional Collapse.} Whitening methods ensure that the covariance matrix of normalized outputs is diagonal, making dimensions mutually independent and implicitly solving dimensional collapse. \citet{huang2018decorrelated,huang2019iterative,siarohin2018whitening,ermolov2021whitening} all adopt the idea of whitening, but differ in calculating details of whitening matrix and application domain. Compared with them, we avoid complicated calculations on the squared root of the inverse covariance matrix and delicate design of backward pass for differentiability. Moreover, \citet{huang2018decorrelated,huang2019iterative} are proposed for convolution operations, \citet{siarohin2018whitening} is for GAN, and \citet{ermolov2021whitening} works in self-supervised learning. In contrast, we borrow the idea from contrastive learning and solve the oversmoothing of neural networks.



\section{Mitigating Oversmoothing from the Perspective of Contrastive Learning}

In this section, we first empirically demonstrate that current similarity metric fails to characterize dimensional collapse, thus overlooking a crucial part of oversmoothing. To address this problem, we draw inspiration from contrastive learning whose uniformity property naturally rules out dimensional collapse. Specifically, we transfer the uniformity loss to a loss that directly acts on representations. By unfolding the optimization steps along this loss, we induce a normalization layer called ContraNorm. Theoretically, we prove our proposed layer helps mitigate dimensional collapse.


\subsection{The Characterization of Oversmoothing}

In this part, we begin by highlighting the limitations of existing metrics in characterizing oversmoothing. These limitations motivate us to adopt the effective rank metric, which has been demonstrated to be effective in capturing the degree of dimensional collapse in contrastive learning. 

Taking the oversmoothing problem of Transformers as an example without loss of generality, a prevailing metric is evaluating attention map similarity \citep{wang2022anti, gong2021vision, shi2022revisiting}. The intuition is that as attention map similarity converges to one, feature similarity increases, which can result in a loss of representation expressiveness and decreased performance. However, by conducting experiments on transformer structured models like ViT and BERT, we find that high attention map similarity does not necessarily correspond to high feature similarity. As shown in Figure \ref{fig:bert-sim} and Figure \ref{fig:vit-sim}, although attention map similarity is close to 0.8 or even higher, the feature similarity remains below 0.5 in most cases. It means the oversmoothing problem still occurs even with a low feature similarity. This finding suggests that similarity can not fully depict the quality of representations and the oversmoothing problem. 

Intuitively, we can consider a case that representations in the latent embedding space do not shrink to one single point but span a low dimensional space. In such cases, feature similarity may be relatively low, but representations still lose expressive power. Such representation degeneration problem is known as \textit{dimensional collapse}, and it is 
widely discussed in the literature of contrastive learning. In contrastive learning, common practice to describe dimensional collapse is the vanishing distribution of singular values \citep{gao2019representation,ethayarajh2019contextual, jing2021understanding}. To investigate whether dimensional collapse occurs in Transformers, we draw the singular value distribution of features in the last block of 12-layer BERT. As shown in Figure \ref{fig:bert-singular}, the insignificant (nearly zero) values dominate singular value distribution in the deep layer of vanilla BERT, indicating that representations reside on a low-dimensional manifold and dimensional collapse happens. To show the collapse tendency along layer index, we simplify the singular value distribution to a concise scalar \textit{effective rank} (erank) \citep{roy2007effective}, which covers the full singular value spectrum. 

\begin{definition}[Effective Rank] \textit{Considering matrix $\mX \in \R^{m \times n}$ whose singular value decomposition is given by $\mX = \mU\mathbf{\Sigma}\mV$, where $\mathbf{\Sigma}$ is a diagonal matrix with singular values $\sigma_1 \geq \sigma_2 \geq \cdots \geq \sigma_Q \geq 0$ with $Q = \min\{m, n\}$. The distribution of singular values is defined as $L_1$-normalized form
$p_i = \sigma_i/\sum_{k=1}^{Q} {\vert \sigma_k \vert}.$
The effective rank of the matrix $\mX$, denoted as $\mbox{erank}(\mX)$, is defined as
$\mbox{erank}(\mX) = \exp (H\{p_1, p_2, \cdots, p_Q\}),$
where $H(p_1, p_2, \cdots, p_Q)$ is the Shannon entropy given by
$H(p_1, p_2, \cdots, p_Q) = -\sum_{k=1}^Q p_k \log p_k.$}
\end{definition}

Based on erank, we revisit the oversmoothing issue of Transformers in Figure \ref{fig:bert-erank}. We can see that the effective rank descends along with layer index, indicating an increasingly imbalanced singular value distribution in deeper layers. This finding not only verifies dimensional collapse does occur in Transformers, but also indicates the effectiveness of effective rank to detect this issue.

\begin{figure}
     \centering
     \begin{subfigure}[b]{0.245\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/bert-stsb-similarity-pos7.pdf}
         \caption{Similarity on BERT}
         \label{fig:bert-sim}
     \end{subfigure}
     \begin{subfigure}[b]{0.245\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/vit-similarity-pos7.pdf}
         \caption{Similarity on ViT}
         \label{fig:vit-sim}
     \end{subfigure}
     \begin{subfigure}[b]{0.245\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/singular_distribution.pdf}
         \caption{Feature Distribution}
         \label{fig:bert-singular}
     \end{subfigure}
     \begin{subfigure}[b]{0.245\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/bert-stsb-erank-pos7.pdf}
         \caption{Effective Rank}
         \label{fig:bert-erank}
     \end{subfigure}
     \hfill
        \caption{Comparison between different metrics of oversmoothing of 12-layer BERT on GLUE sub-task STS-B and 12-layer ViT on CIFAR10. Figure \ref{fig:bert-sim} and Figure \ref{fig:vit-sim} show feature and attention map cosine similarity along layer index. Figure \ref{fig:bert-singular} and Figure \ref{fig:bert-erank} show the singular value distribution of features and effective rank of BERT w/ and w/o ContraNorm.}
        \label{fig:cossim}
        \vspace{-0.1 in}
\end{figure}


\subsection{Inspirations from the Uniformity Loss in Contrastive Learning}

The core idea of contrastive learning is maximizing agreement between augmented views of the same example (i.e., positive pairs) and disagreement of views from different samples (i.e. negative pairs). A popular form of contrastive learning optimizes feature representations using a loss function with limited negative samples \citep{chen2020simple}. Concretely, given a batch of randomly sampled examples, for each example we generate its augmented positive views and finally get a total of $N$ samples. Considering an encoder function $f$, the contrastive loss for the positive pair $(i, i^+)$ is 
\begin{equation} \label{eq:infonce}
\Ls(i, i^+) = -\log \frac{\mbox{exp}(f(\vx_i)^{\top}f(\vx_{i^+}) / \tau)}{\sum_{k=1}^{N} \mbox{exp}(f(\vx_i)^{\top}f(\vx_k) / \tau) - \mbox{exp}(f(\vx_i)^{\top}f(\vx_i) / \tau)},
\end{equation}
where $\tau$ denotes the temperature. The loss can be decoupled into \textit{alignment loss} and \textit{uniformity loss}:
\begin{equation} \label{eq:uniform}
    \Ls_{\rm{align}}(i,i^+) = - f(\vx_i)^{\top}f(\vx_{i^+})/\tau \qquad  \Ls_{\rm{uniform}}(i) = \log \sum_{k=1}^N \mbox{exp}(f(\vx_i)^{\top}f(\vx_k)/\tau).
\end{equation}
The alignment loss encourages feature representations for positive pairs to be similar, thus being invariant to unnecessary noises. However, training with only the alignment loss will result in a trivial solution where all representations are identical. In other words, complete collapse happens. While batch normalization \citep{ioffe2015batch} can help avoid this issue, it cannot fully prevent the problem of dimensional collapse, which still negatively impacts learning \citep{hua2021feature}. 

Thanks to the property of uniformity loss, dimensional collapse can be solved effectively. Reviewing the form of uniformity loss in Eq.~(\ref{eq:uniform}), it maximizes average distances between all samples, resulting in embeddings that are roughly uniformly distributed in the latent space, and thus more information is preserved. The inclusion of the uniformity loss in the training process helps to alleviate dimensional collapse. Intuitively, it can also serve as a sharp tool for alleviating oversmoothing in models such as GNNs and Transformers. 

An alternative approach to address oversmoothing is to directly incorporate the uniformity loss into the training objective. However, our experiments reveal that this method has limited effectiveness (see Appendix \ref{appen:uniformity} for more details). Instead, we propose a normalization layer that can be easily integrated into various models. Our approach utilizes the uniformity loss as an underlying energy function of the proposed layer, such that a descent step along the energy function corresponds to a forward pass of the layer. Alternatively, we can view the layer as the unfolded iterations of an optimization function. This perspective is adopted to elucidate GNNs \citep{yang2021graph, zhu2021interpreting}, Transformers \citep{yang2022transformers}, and classic MLPs \citep{xie2021optimization}. 

Note that the uniformity loss works by optimizing model parameters while what the normalization layer directly updates is representation itself. So we first transfer the uniformity loss, which serves as a training loss, to a kind of architecture loss. Consider a fully connected graph with restricted number of nodes, where node $\vh_i$ is viewed as representation of a random sample $\vx_i$. Reminiscent of $\Ls_{\rm{uniform}}$, we define $\hat{\Ls}_{\rm{uniform}}$ over all nodes in the graph as
\begin{equation}
     \hat{\Ls}_{\rm{uniform}} = \sum_i \Ls_{\rm{uniform}}(i) = \sum_i \log \sum_j e^{\vh_i^{\top}\vh_j / \tau}. \label{eq:uniform-graph}
\end{equation}
This form of uniformity loss is defined directly on representations, and we later use it as the underlying energy function for representation update.  

\subsection{The Proposed ContraNorm} \label{section:contranorm}
Till now, we are able to build a connection between layer design and the unfolded uniformity-minimizing iterations. Specifically, we take the derivative of $\hat{L}_{\rm{uniform}}$ on node representations:
\begin{equation} \label{eq-d}
    \frac{\partial \hat{\Ls}_{\rm{uniform}}}{\partial \vh_i} 
    = \sum_j \frac{\exp(\vh_i^{\top} \vh_j/\tau)}{\sum_k \exp(\vh_i^{\top} \vh_k/\tau)} \vh_j/\tau + \sum_j \frac{\exp(\vh_i ^{\top}\vh_j/\tau)}{\sum_k \exp(\vh_j ^{\top}\vh_k/\tau)} \vh_j/\tau.
\end{equation}
Denote the feature matrix as $\mH$ with the $i$-th row $\vh_i^{\top}$, we can rewrite Eq.~(\ref{eq-d}) into a matrix form:
\begin{equation} \label{eq-m}
    \frac{\partial \hat{\Ls}_{\rm{uniform}}}{\partial \mH} = (\mD^{-1}\mA + \mA\mD^{-1})\mH/\tau,
\end{equation}
where $\mA = \exp(\mH\mH^{\top}/\tau)$ and $\mD = \deg (\mA)$\footnote{$\deg(\mA)$ is a diagonal matrix, whose $(i,i)$-th element equals to the sum of the $i$-th row of $\mA$.}. To reduce the uniformity loss $\hat{\Ls}_{\rm{uniform}}$, a natural way is to take a single step of gradient descent that updates $\mH$ by
\begin{equation} \label{eq-contra}
    \mH_t = \mH_b - s\times\frac{\partial \hat{\Ls}_{\rm{uniform}}}{\partial \mH_b}=\mH_b - s/\tau \times (\mD^{-1}\mA + \mA\mD^{-1})\mH_b,
\end{equation}
where $\mH_b$ and $\mH_t$ denote the representations before and after the update, respectively, and $s$ is the step size of the gradient descent. By taking this update after a certain representation layer, we can reduce the uniformity loss of the representations and thus help ease the dimensional collapse.

In Eq.~(\ref{eq-contra}), there exist two terms $\mD^{-1}\mA$ and $\mA\mD^{-1}$ multiplied with $\mH_b$. Empirically, the two terms play a similar role in our method. Note that the first term is related to self-attention matrix in Transformers, so we only preserve it and discard the second one. Then Eq.~(\ref{eq-contra}) becomes 
\begin{equation} \label{eq-contra-1}
    \mH_t=\mH_b-s/\tau\times(\mD^{-1}\mA)\mH_b = \mH_b - s/\tau \times \text{softmax}(\mH_b \mH_b^{\top})\mH_b.
\end{equation}
In fact, the operation corresponds to the stop-gradient technique, which is widely used in contrastive learning methods \citep{He_2020_CVPR, grill2020bootstrap,tao2022exploring}. By throwing away some terms in the gradient, stop-gradient makes the training process asymmetric and thus avoids representation collapse with less computational overhead, which is discussed in detail in Appendix \ref{stop-gradient}.

However, the layer induced by Eq.~(\ref{eq-contra-1}) still can not ensure uniformity on representations. Consider an extreme case where $\softmax(\mH_b\mH_b^{\top})$ is equal to identity matrix $\mI$. Eq.~(\ref{eq-contra-1}) becomes $\mH_t = \mH_b - s/\tau \times \mH_b = (1-s/\tau)\mH_b$, which just makes the scale of $\mH$ smaller and does not help alleviate the complete collapse. To keep the representation stable, we explore two different approaches: feature norm regularization and layer normalization.

\textbf{I. Feature Norm regularization.} We add a regularization term $-\frac{1}{2}\sum_i\|h_i\|_2^2$ to the uniformity loss to encourage a larger feature norm. When the regularization term becomes smaller, the norm of $h_i$ becomes larger. Therefore, adding this term can help prevent the norm of representation $h_i$ from becoming smaller. In this way, the update form becomes
\begin{equation} \label{eq-contra-2}
    \mH_t = (1 + s) \mH_b - s/\tau \times \softmax(\mH_b\mH_b^{\top})\mH_b.
\end{equation}
\begin{proposition}
\label{proposition:complete}
    Let $\ve=(1,1,\dots,1)^{\top}/\sqrt{n}$. For attention matrix $\bar{\mA}=\operatorname{softmax}(\mH_b\mH_b^{\top})$, let $\sigma_{\min}$ be the smallest eigenvalue of  $\mP=(\mI-\ve\ve^{\top})(\mI-\bar{\mA})+(\mI-\bar{\mA})^{\top}(\mI-\ve\ve^{\top})$. For the update in Eq.~(\ref{eq-contra-2}), i.e. $\mH_t=((1+s)\mI-s\bar{\mA})\mH_b,\ s>0$, we have $Var(\mH_t)\geq (1+s\sigma_{\min})\cdot Var(\mH_b)$. Especially, if $\sigma_{\min}\geq0$, we have $Var(\mH_t)\geq Var(\mH_b)$.
\end{proposition}
Proposition \ref{proposition:complete} gives a bound for the ratio of the variance after and before the update. It shows that the change of the variance is influenced by the symmetric matrix $\mP=(\mI-\ve\ve^{\top})(\mI-\bar{\mA})+(\mI-\bar{\mA})^{\top}(\mI-\ve\ve^{\top})$. If $\mP$ is a semi-positive definite matrix, we will get the result that $Var(\mH_t)\geq Var(\mH_b)$, which indicates that the representations become more uniform. In Appendix \ref{appen:proof}, we will give out some sufficient conditions for that $\mP$ is semi-positive definite.

\textbf{II. Appending LayerNorm.} Another option is to leverage Layer Normalization (LayerNorm) \citep{ba2016layer} to maintain the feature scale. The update form of LayerNorm is $\text{LayerNorm}(\vh_i)=\gamma\cdot((\vh_i-\text{mean}(\vh_i))/\sqrt{\text{Var}(\vh_i)+\varepsilon})+\beta$, where $\gamma$ and $\beta$ are learnable parameters and $\varepsilon=10^{-5}$. The learnable parameters $\gamma$ and $\beta$ can rescale the representation $\vh_i$ to help ease the problem. We append LayerNorm to the original update in Eq.~(\ref{eq-contra-1}) and obtain
\begin{equation} \label{eq-contra-3}
    \mH_t = \mbox{LayerNorm}\left(\mH_b - s/\tau \times \softmax(\mH_b\mH_b^{\top})\mH_b\right),
\end{equation}
where applying the layer normalization to a representation matrix $\mH$ means applying the layer normalization to all its components $\vh_1,\dots,\vh_n$. 

\textbf{ContraNorm.} We empirically compare the two proposed methods and find their performance comparable, while the second one performs slightly better. Therefore, we adopt the second update form and name it Contrastive Normalization (\textbf{ContraNorm}). The ContraNorm layer can be added after any representation layer to reduce the uniformity loss and help relieve the dimensional collapse. We discuss the best place to plug our ContraNorm in Appendix \ref{appen:pos}. 

\textbf{ContraNorm-D: Scalable ContraNorm for Large-scale Graphs.}
From the update rule in Eq.~(\ref{eq-contra-3}), we can see that the computational complexity of the ContraNorm layer is $\gO(n^2d)$, where $n$ is the number of tokens and $d$ is the feature dimension per token, which is in the same order of self-attention \citep{vaswani2017attention}. Therefore, this operation is preferable when the token number $n$ is similar or less than the feature dimension $d$, as is usually the case in CV and NLP domains. However, for large-scale graphs that contain millions of nodes ($n\gg d$), the quadratic dependence on $n$ makes ContraNorm computationally prohibitive. To circumvent this issue, we propose Dual ContraNorm (\textbf{ContraNorm-D}), a scalable variant of ContraNorm whose computational complexity $\gO(nd^2)$ has a \textit{linear} dependence on $n$, with the following dual update rule,
\begin{equation} \label{eq-contra-4}
    \mH_t = \mbox{LayerNorm}\left(\mH_b - s/\tau \times \mH_b \times \softmax(\mH_b^{\top}\mH_b)\right),
\end{equation}
where we calculate the dimension-wise feature correlation matrix $\mH_b^{\top}\mH_b\in\sR^{d\times d}$ and multiple it to the right of features $\mH_b$ after softmax normalization. In Appendix \ref{appen:time}, we provide a more thorough explanation of it, showing how to derive it from the feature decorrelation normalization adopted in non-contrastive learning methods (like Barlow Twins \citep{zbontar2021barlow} and VICReg \citep{bardes2021vicreg}). As revealed in recent work \citep{garrido2022duality}, there is a dual relationship between contrastive and non-contrastive learning methods, and we can therefore regard ContraNorm-D as a dual version of ContraNorm that focuses on decreasing dimension-wise feature correlation.


\subsection{Theoretical Analysis}
\label{sec:theoretical-analysis}

In this part, we give a theoretical result of ContraNorm, and show that with a slightly different form of the uniformity loss, the ContraNorm update can help alleviate the dimensional collapse. 

\begin{proposition}
    Consider the update form $
    \mH_t=(1+s)\mH_b-s(\mH_b\mH_b^{\top})\mH_b,$
    let $\sigma_{\max}$ be the largest singular value of $\mH_b$. For $s>0$ satisfying $1+(1-\sigma^2_{\max})s>0$, we have $\operatorname{erank}(\mH_t)>\operatorname{erank}(\mH_b)$.\label{proposition:dimensional}
\end{proposition}
Proposition \ref{proposition:dimensional} gives a promise of alleviating dimensional collapse under a special update form. 
Denote $\hat{\Ls}_{\rm{dim}}=tr((\mI-\mH\mH^{\top})^2)/4$, then $\hat{\Ls}_{\rm{dim}}$ shares a similar form with Barlow Twins \citep{zbontar2021barlow}. This loss tries to equate the diagonal elements of the similarity matrix $\mH\mH^{\top}$ to 1 and equate the off-diagonal elements of the matrix to 0, which drives different features becoming orthogonal, thus helping the features become more uniform in the space. Note that $\frac{\partial \hat{\Ls}_{\rm{dim}}}{\partial \mH}=(\mI-\mH\mH^{\top})\mH$, therefore, the update above can be rewritten as $\mH_t=\mH_b+s\frac{\partial\hat{\Ls}_{\rm{dim}}(\mH_b)}{\partial \mH_b}$, which implies that this update form is a ContraNorm with a different uniformity loss. Proposition \ref{proposition:dimensional} reveals that this update can increase the effective rank of the representation matrix, when $s$ satisfies $1+(1-\sigma_{\max})s>0$. Note that no matter whether $\sigma_{\max}>0$ or not, if $s$ is sufficiently close to $0$, the condition will be satisfied. Under this situation, the update will alleviate the dimensional collapse.


\section{Experiments}
In this section, we demonstrate the effectiveness of ContraNorm by experiments including 1) language understanding tasks on GLUE datasets with BERT and ALBERT \citep{lan2019albert} as the backbones; 2) image classification task on ImageNet100 and ImageNet1k datasets with DeiT as the base model; 3) fully supervised graph node classification task on popular graph datasets with GCN as the backbone. Moreover, we conduct ablative studies on ContraNorm variants comparison and hyperparameters sensitivity analysis.


\subsection{Experiments on Language Models} \label{sec:nlp-task}
\textbf{Setup.} 
To corroborate the potential of ContraNorm, we integrate it into two transformer structured models: BERT and ALBERT, and evaluate it on GLUE datasets. GLUE includes three categories of tasks:  (i) single-sentence tasks CoLA and SST-2; (ii) similarity and paraphrase tasks MRPC, QQP, and STS-B; (iii) inference tasks MNLI, QNLI, and RTE. For MNLI task, we experiment on both the matched (MNLI-m) and mismatched (MNLI-mm) versions. We default plug ContraNorm after the self-attention module and residual connection (more position choices are in Appendix \ref{appen:pos}). We use a batch size of 32 and fine-tune for 5 epochs over the data for all GLUE tasks. For each task, we select the best scale factor $s$ in Eq.~(\ref{eq-contra}) among $(0.005, 0.01, 0.05, 0.1, 0.2)$. We use base models (BERT-base and ALBERT-base) of 12 stacked blocks with hyperparameters fixed for all tasks: number of hidden size 128, number of attention heads 12, maximum sequence length 384. We use Adam \citep{kingma2014adam} optimizer with the learning rate of $2e-5$. 

\textbf{Results.} As shown in Table \ref{table:nlp-dev}, ContraNorm substantially improves results on all datasets compared with vanilla BERT. Specifically, our ContraNorm improves the previous average performance from 82.59\% to 83.39\% for BERT backbone and from 83.74\% to 84.67\% for ALBERT backbone. We also submit our trained model to GLUE benchmark leaderboard and the results can be found in Appendix \ref{appen:test}. It is observed that BERT with ContraNorm also outperforms vanilla model across all datasets. To verify the de-oversmoothing effect of ContraNorm. We build models with/without ContraNorm on various layer depth settings. The performance comparison is shown in Figure \ref{fig:cola-acc}. Constant stack of blocks causes obvious deterioration in vanilla BERT, while BERT with ContraNorm maintains competitive advantage. Moreover, for deep models, we also show the tendency of variance and effective rank in Figure \ref{fig:cola-var} and Figure \ref{fig:cola-effect}, which verifies the power of ContraNorm in alleviating complete collapse and dimensional collapse, respectively.

\begin{figure}
     \centering
     \begin{subfigure}[b]{0.3\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/bert-cola-mcc.pdf}
         \caption{Deep Model Performance}
         \label{fig:cola-acc}
     \end{subfigure}
     \begin{subfigure}[b]{0.3\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/bert-cola-vars-pos7.pdf}
         \caption{Variance}
         \label{fig:cola-var}
     \end{subfigure}
     \begin{subfigure}[b]{0.3\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/bert-cola-eranks-pos7.pdf}
         \caption{Effective rank}
         \label{fig:cola-effect}
     \end{subfigure}
     \hfill
     \vspace{-0.1 in}
    \caption{Comparison of BERT and BERT+ContraNorm on COLA with various layer depths. Figure \ref{fig:cola-acc} presents performances of models with block number=12, 24, 36, 48, 60, 72. Figure \ref{fig:cola-var} and Figure \ref{fig:cola-effect} show the tendency of features variance and effective rank for models with 72 blocks.}
    \label{fig:deep-cola}
    \vspace{-0.1 in}
\end{figure}

\begin{table}[!t]
	\centering
	\caption{Results comparison on validation set of GLUE tasks. Following \cite{devlin2018bert}, we report F1 scores for QQP and MRPC, Spearman correlations for STS-B, and accuracy scores for the other tasks. ContraNorm* denotes the best model when varying plugging positions of ContraNorm. \textbf{Avg} denotes the average performance on all the tasks and bold denotes the best performance.} 
	\vspace{-0.13 in}
	\resizebox{\textwidth}{!}{
	\begin{tabular}{l cccccccccc}
		\toprule
		\textbf{Dataset} & COLA & SST-2 & MRPC & QQP & STS-B & MNLI-m & MNLI-mm & QNLI & RTE & \textbf{Avg}\\
		\midrule
		BERT-base & 55.28 & 92.89 & 88.96 & 88.24 & 88.61 & 84.65 & 84.61 & 91.51 & 68.59 & 82.59 \\
		BERT + ContraNorm & 58.83 & 93.12 & 89.49 & \bf88.30 & 88.66 & \bf84.87 & 84.66 & \bf91.78 & \bf70.76 & 83.39 \\
		BERT + ContraNorm* & \bf59.57 & \bf93.23 & \bf89.97 & \bf88.30 & \bf88.93 & \bf84.87 & \bf84.67 & \bf91.78 & \bf70.76 & \bf83.54 \\
		\midrule
		ALBERT-base &  57.35 & \bf93.69 & 92.09 & 87.23 & 90.54 & 84.56 & 84.37 & 90.90 & 76.53 & 83.74\\
		ALBERT + ContraNorm &  58.51 & 92.89 & 92.86 & 87.45 & 90.56 & 84.33 & 84.62 & 91.76 & \bf79.06 & 84.67\\
		ALBERT + ContraNorm* &  \bf58.76 & 93.23 & \bf92.89 & \bf87.67 & \bf90.72 & \bf84.69 & \bf84.95 & \bf92.28  & \bf79.06 & \bf84.92\\
		\bottomrule    
	\end{tabular}
	}
	\label{table:nlp-dev}
 \vspace{-0.1 in}
\end{table}


\subsection{Experiments on Vision Transformers}

We also validate effectiveness of ContraNorm in computer vision field. We choose DeiT as backbone and models are trained from scratch. Experiments with different depth settings are evaluated on ImageNet100 and ImageNet1k datasets. Based on the Timm \citep{rw2019timm} and DeiT repositories, we insert ContraNorm into base model intermediately following self-attention module.

\textbf{Setup.} 
We follow the training recipe of \citet{touvron2021training} with minimal hyperparameter changes. Specifically, we use AdamW \citep{loshchilov2017decoupled} optimizer with cosine learning rate decay. We train each model for 150 epochs and the batch size is set to 1024. Augmentation techniques are used to boost the performance. For all experiments, the image size is set to be $224 \times 224$. For Imagenet100, we set the scale factor $s$ to 0.2 for all layer depth settings. For Imagenet1k, we set $s$ to 0.2 for models with 12 and 16 blocks, and raise it to 0.3 for models with 24 blocks.

\textbf{Results.} In Table \ref{table:vit-acc}, DeiT with ContraNorm outperforms vanilla DeiT with all layer settings on both datasets. Typically, our method shows a gain of nearly 5\% on test accuracy for ImageNet100. For ImageNet1k, we boost the performance of DeiT with 24 blocks from 77.69\% to 78.67\%.


\begin{table}[!t]
	\centering
	\caption{Test accuracy (\%) comparison results. For ImageNet100 and ImageNet1k, we use DeiT-tiny and DeiT-small as the baseline respectively. The block number is set to 12, 16 and 24. The best result for each dataset is bolded.}
	\vspace{-0.13 in}
	\begin{tabular}{ll ccc}
		\toprule
		Dataset & Model & $\#$L=12 & $\#$L=16 & $\#$L=24 \\
		\midrule
		\multirow{2}{*}{ImageNet100} & DeiT-tiny & 76.58 & 75.34 & 76.76 \\
		~ & +ContraNorm  & \bf79.34 & \bf80.44 & \bf81.28 \\
		\midrule
		\multirow{2}{*}{ImageNet1k} & DeiT-small & 77.32 & 78.25 & 77.69 \\
		~ & +ContraNorm & \bf77.80 & \bf79.04 & \bf78.67 \\
		\bottomrule    
	\end{tabular}
	\label{table:vit-acc}
 \vspace{-0.1 in}
\end{table}


\subsection{Experiments on Graph Neural Networks}


\textbf{Setup.} We implement ContraNorm as a simple normalization layer after each graph convolution of GCN, and evaluate it on fully supervised graph node classification task. For datasets, we choose two popular citation networks Cora \citep{mccallum2000automating} and Citeseer \citep{giles1998citeseer}, and Wikipedia article networks Chameleon and Squirrel \citep{rozemberczki2021multi}. More information of datasets is deferred to Appendix \ref{appen:data}. We compare ContraNorm against a popular normalization layer PairNorm \citep{zhao2019pairnorm} designed for preventing oversmoothing. We also take LayerNorm as a baseline by setting the scale $s=0$.  We follow data split setting in \citet{kipf2016semi} with train/validation/test splits of 60\%, 20\%, 20\%, respectively. To keep fair in comparison, we fix the hidden dimension to 32, and dropout rate to 0.6 as reported in \citet{zhao2019pairnorm}. We choose the best of scale controller $s$ in range of $\{0.2, 0.5, 0.8, 1.0\}$ for both PairNorm and ContraNorm. For PairNorm, we choose the best variant presented by \citet{zhao2019pairnorm}.


\textbf{Results.} As shown in Table \ref{table:gnn-acc}, in shallow layers (e.g., two layer), the addition of ContraNorm reduces the accuracy of vanilla GCN by a small margin, while it helps prevent the performance from sharply deteriorating as the layer goes deeper. ContraNorm outperforms PairNorm and LayerNorm in the power of de-oversmoothing. Here, we show the staple in diluting oversmoothing is ContraNorm, and LayerNorm alone fails to prevent GCN from oversmoothing, even amplifying the negative effect on Cora with more than 16 layers.

\begin{table}[!t]
	\centering
	\caption{Test accuracy (\%) comparison results. We use GCN as backbone and apply LayerNorm, PairNorm and ContraNorm, respectively. We fairly tune the scale parameter in LayerNorm and ContraNorm. The layer number is set to 2, 4, 8, 16, 32. For every layer setting, the best accuracy is marked in blue background, and the second best is underlined. Results are averaged over 5 runs.}
	\vspace{-0.13 in}
	\resizebox{\textwidth}{!}{
	\begin{tabular}{ll cc ccc}
		\toprule
		Dataset & Model & $\#$L=2 & $\#$L=4 & $\#$L=8 & $\#$L=16 & $\#$L=32 \\
		\midrule
		\multirow{4}{*}{Cora} & Vanilla GCN & \cellcolor{blue!15}81.75 $\pm$ 0.51 & 72.61 $\pm$ 2.42 & 17.71 $\pm$ 6.89 & 20.71 $\pm$ 8.54 & 19.69 $\pm$ 9.54 \\
		~ & +LayerNorm  & \underline{79.96 $\pm$ 0.73} & \cellcolor{blue!15}77.45 $\pm$ 0.67 & 39.09 $\pm$ 4.68 & 7.79 $\pm$ 0.00 & 7.79 $\pm$ 0.00 \\
		~ & +PairNorm  & 75.32 $\pm$ 1.05 & 72.64 $\pm$ 2.67 & \underline{71.86 $\pm$ 3.31} & \underline{54.11 $\pm$ 9.49} & \underline{36.62 $\pm$ 2.73} \\
		~ & +ContraNorm  & 79.75 $\pm$ 0.33 & \underline{77.02 $\pm$ 0.96} & \cellcolor{blue!15}74.01 $\pm$ 0.64 & \cellcolor{blue!15}68.75 $\pm$ 2.10 & \cellcolor{blue!15}46.39 $\pm$ 2.46 \\
		\midrule
		\multirow{4}{*}{CiteSeer} & Vanilla GCN & \cellcolor{blue!15}69.18 $\pm$ 0.34 & 55.01 $\pm$ 4.36 & 19.65 $\pm$ 0.00 & 19.65 $\pm$ 0.00 & 19.65 $\pm$ 0.00 \\
		~ & +LayerNorm & 63.27 $\pm$ 1.15 & \cellcolor{blue!15}60.91 $\pm$ 0.76 & 33.74 $\pm$ 6.15 & 19.65 $\pm$ 0.00 & 19.65 $\pm$ 0.00 \\
		~ & +PairNorm & 61.59 $\pm$ 1.35 & 53.01 $\pm$ 2.19 & \underline{55.76 $\pm$ 4.45} & \underline{44.21 $\pm$ 1.73} & \underline{36.68 $\pm$ 2.55} \\
		~ & +ContraNorm & \underline{64.06 $\pm$ 0.85} & \underline{60.55 $\pm$ 0.72} &  \cellcolor{blue!15}59.30 $\pm$ 0.67 &  \cellcolor{blue!15}49.01 $\pm$ 3.49 & \cellcolor{blue!15}36.94 $\pm$ 1.70 \\
	    \midrule
		\multirow{4}{*}{Chameleon} & Vanilla GCN & 45.79 $\pm$ 1.20 & 37.85 $\pm$ 1.35 & 22.37 $\pm$ 0.00 & 22.37 $\pm$ 0.00 & 23.37 $\pm$ 0.00 \\
		~ & +LayerNorm  & \underline{63.95 $\pm$ 1.29} & 55.79 $\pm$ 1.25 & 34.08 $\pm$ 2.62 & 22.37 $\pm$ 0.00 & 22.37 $\pm$ 0.00 \\
		~ & +PairNorm & 62.24 $\pm$ 1.73 & \underline{58.38 $\pm$ 1.48} & \cellcolor{blue!15}49.12 $\pm$ 2.32 & \underline{37.54 $\pm$ 1.70} & \underline{30.66 $\pm$ 1.58} \\
		~ & +ContraNorm  & \cellcolor{blue!15}64.78 $\pm$ 1.68 & \cellcolor{blue!15}58.73 $\pm$ 1.12 & \underline{48.99 $\pm$ 1.52} & \cellcolor{blue!15}40.92 $\pm$ 1.74 & \cellcolor{blue!15}35.44 $\pm$ 3.16 \\
		\midrule
		\multirow{4}{*}{Squirrel} & Vanilla GCN & 29.47 $\pm$ 0.96 & 19.31 $\pm$ 0.00 & 19.31 $\pm$ 0.00 & 19.31 $\pm$ 0.00 & 19.31 $\pm$ 0.00 \\
		~ & +LayerNorm  & 43.04 $\pm$ 1.25 & 29.64 $\pm$ 5.50 & 19.63 $\pm$ 0.45 & 19.96 $\pm$ 0.44 & 19.40 $\pm$ 0.19 \\
		~ & +PairNorm & \underline{43.86 $\pm$ 0.41} & \underline{40.25 $\pm$ 0.55} & \cellcolor{blue!15}36.03 $\pm$ 1.43 & \underline{29.55 $\pm$ 2.19} & \cellcolor{blue!15}29.05 $\pm$ 0.91 \\
		~ & +ContraNorm  & \cellcolor{blue!15}47.24 $\pm$ 0.66 & \cellcolor{blue!15}40.31 $\pm$ 0.74 & \underline{35.85 $\pm$ 1.58} & \cellcolor{blue!15}32.37 $\pm$ 0.93 & \underline{27.80 $\pm$ 0.72} \\
		\bottomrule    
	\end{tabular}
	}
	\label{table:gnn-acc}
 \vspace{-0.1 in}
\end{table}


\subsection{Ablation Study}

Recalling Section \ref{section:contranorm}, we improve ContraNorm with stop-gradient technique (SG) by masking the second term. For solving data representation instability, we apply layer normalization (LN) to the original version, while for the convenience of theoretical analysis, layer normalization is replaced by $L_2$ normalization ($L_2$N). Here, we investigate the effect of these tricks and the results are shown in Table \ref{table:ablation-norm}. Compared with the variant with only LayerNorm, ContraNorm with both stop gradient and layer normalization presents better performance. As for the two normalization methods, they are almost comparable to our methods, which verifies the applicability of our theoretical analysis. 

In Appendix \ref{appen:abla}, we further conduct an ablation study regarding the gains of ContraNorm while using different values of scale factor $s$, and show that ContraNorm is robust in an appropriate range of $s$.

\begin{table}[!t]
	\centering
	\caption{Performance comparison among different variants of ContraNorm. SG, LN, $L_2$N are the abbreviations of stop gradient, layer normalization and $L_2$ normalization, respectively. All experiments are conducted on GLUE tasks with the same parameter settings. \textbf{Avg} denotes the average performance on all the tasks. We bold the best result for each task.} 
	\vspace{-0.13 in}
	\resizebox{\textwidth}{!}{
	\begin{tabular}{ccc ccccc ccccc}
		\toprule
		\multicolumn{3}{c}{\textbf{Variants}} & \multicolumn{9}{c}{\textbf{Datasets}} & \multirow{2}{*}{\textbf{Avg}} \\
		\cmidrule(lr){1-3}  \cmidrule(lr){4-12}
		SG & LN & $L_2$N & COLA & SST-2 & MRPC & QQP & STS-B & MNLI-m & MNLI-mm & QNLI & RTE & ~ \\
		\midrule
	    ~ & \checkmark & ~ & 58.80 & \bf93.12 & 89.60 & 88.35 & \bf88.97 & 84.81 & \bf84.67 & 91.47 & 68.23 & 83.11 \\
		\checkmark & ~ & \checkmark & \bf59.82 & 93.00 & 89.64 & \bf88.37 & 88.92 & 84.72 & 84.58 & \bf91.58 & \bf68.95 & 83.29 \\
		\checkmark & \checkmark & ~  & 59.57 & \bf93.12 & \bf89.97 & 88.30 & 88.93 & \bf84.84 & \bf84.67 & \bf91.58 & \bf68.95 & \bf83.33 \\
		\bottomrule    
	\end{tabular}
	}
	\label{table:ablation-norm}
 \vspace{-0.1 in}
\end{table}



\section{Conclusion}
In this paper, we point out the deficiencies of current metrics in characterizing over-smoothing, and highlight the importance of taking dimensional collapse as the entry point for oversmoothing analysis. Inspired by the uniformity loss in contrastive learning, we design an optimization-induced normalization layer ContraNorm. Our theoretical findings indicate ContraNorm mitigates dimensional collapse successfully by reducing variance and effective rank of representations. Experiments show that ContraNorm boosts the performance of Transformers and GNNs on various tasks. Our work provides a new perspective from contrastive learning on solving the oversmoothing problem, which helps motivate the following extensive research.


\section*{Acknowledgement}
Yisen Wang is partially supported by the National Key R\&D Program of China (2022ZD0160304), the National Natural Science Foundation of China (62006153), Open Research Projects of Zhejiang Lab (No. 2022RC0AB05), and Huawei Technologies Inc. Xiaojun Guo thanks for Hanqi Yan for her kind guidance on the implementation of BERT models. We thank anonymous reviewers for their constructive advice on this work. 


\bibliography{iclr2023_conference}
\bibliographystyle{iclr2023_conference}

\newpage

\appendix 


\section{More Details on Dual ContraNorm} \label{appen:time}

\subsection{Methodology}

The most time-consuming operation of ContraNorm is the matrix multiplication. Given $\mathbf{H} \in {\mathbb{R}^{n \times d}}$, where $n$ and $d$ denote the number of samples in a batch and feature size respectively, the time complexity of ContraNorm is $\mathcal{O}(n^2d)$, which is the same order as the self-attention operation in Transformer. Empirically, we report the training time of BERT with or without ContraNorm on GLUE tasks in Table \ref{table:time}. All experiments are conducted on a single NVIDIA GeForce RTX 3090. On average, we raise the performance of BERT on GLUE tasks from 82.59\% to 83.54\% (see Table \ref{table:nlp-dev}) with less than 4 minutes overhead. We think the time overhead is acceptable considering the benefits it brings. 

\begin{table}[h]
	\centering
	\caption{Estimated training time of BERT with or without ContraNorm on GLUE tasks. All experiments are conducted on a single NVIDIA GeForce RTX 3090. $s$ is the abbreviation for second. \textbf{Avg} denotes the average training time across all the tasks.} 
	\resizebox{\textwidth}{!}{
	\begin{tabular}{l ccccccccc}
		\toprule
		\textbf{Dataset} & COLA & SST-2 & MRPC & QQP & STS-B & MNLI-m (/mm) & QNLI & RTE & \textbf{Avg}\\
		\midrule
		BERT & 110$s$ & 851$s$ & 74$s$ & 6458$s$ & 110$s$ & 8186$s$ & 2402$s$ & 74$s$ & 2283$s$ \\
		+ContraNorm & 125$s$ & 983$s$ & 80$s$ & 7150$s$ & 122$s$ & 8941$s$ & 2594$s$ & 80s & 2509$s$ \\
		\bottomrule    
	\end{tabular}
	}
	\label{table:time}
\end{table}

However, the computation bottleneck will become more apparent when applying ContraNorm to large-scale graphs with $n\gg d$. And we draw our inspirations from the duality between contrastive and non-contrastive learning \citep{garrido2022duality} to resolve this issue. It is shown that the uniformity loss used for deriving ContraNorm is equivalent (under limited assumptions) to the feature decorrelation loss adopted in non-contrastive learning. As the computation complexity of the decorrelation loss is $\gO(nd^2)$ that has a linear dependence on $n$. For the sake of consistency with the original ContraNorm, we choose the dual version of the InfoNCE uniformity loss, named VICReg-exp proposed in \cite{garrido2022duality}, and apply it to the graph features $\mH\in\sR^{n\times d}$, leading to the following VICReg-exp decorrelation for $\mH$,
\begin{equation}
L_{\rm VICReg-exp}(\mH)=\sum_{i}\log\sum_je^{\vh_{:,i}^\top \vh_{:,j}},
\end{equation}
where $\vh_{:,i}$ denotes the $i$-th column vector (i.e., a feature) of $\mH$. We can observe its close resemblance to the InfoNCE uniformity loss in Eq.~(\ref{eq:uniform}). Following the same procedure as in Section \ref{section:contranorm}, we can drive the gradient descent rule of the decorrelation loss and arrive at the following normalization layer named Dual ContraNorm (ContraNorm-D):
\begin{equation}
   \mbox{ContraNorm-D}(\mathbf{H}) = \mbox{LayerNorm}(\mathbf{H}-s/\tau \times \mathbf{H}\times\mbox{softmax}(\mathbf{H}^T\mathbf{H})), 
\end{equation}
which is also very close in form to the ContraNorm layer in Eq.~(\ref{eq-contra-3}).
We can see that ContraNorm-D only involves computing the feature correlation matrix $\mH^\top \mH$ of complexity $\gO(nd^2)$. The linear dependence on the node number $n$ makes it very suitable for large-scale graphs. We note that other forms of feature decorrelation objectives in non-contrastive learning \citep{zbontar2021barlow,bardes2021vicreg} can also be applied, and we leave a more systematic study of their effects on neural network dynamics to future work.


\subsection{BERT Experiments on GLUE Benchmark}

To verify whether it performs equally well as ContraNorm, we conduct experiments on the validation set of GLUE tasks. The learning rate of BERT with ContraNorm-D is set to $4e-5$ and other experiment setups are the same in Section \ref{sec:nlp-task}. As shown from Table \ref{table:decorrelate}, for each task the performance of BERT with ContraNorm-D surpasses the vanilla BERT, and the average performance is raised from $82.59\%$ to $84.21\%$. The results imply effectiveness of this modified version of ContraNorm, which can also be explained with the relationship between Gram matrix ($\mathbf{G} = \mathbf{H}\mathbf{H}^T \in \mathbb{R}^{n \times n}$ ) and covariance matrix ( $\mathbf{C} = \mathbf{H}^T\mathbf{H} \in \mathbb{R}^{d \times d}$) \citep{ali2021xcit}. 


\begin{table}[h]
	\centering
	\caption{Results comparison of BERT with or without ContraNorm-D on validation set of GLUE tasks. Following \citet{devlin2018bert}, we report F1 scores for QQP and MRPC, Spearman correlations for STS-B, and accuracy scores for the other tasks. \textbf{Avg} denotes the average performance on all the tasks and bold denotes the best performance.} 
	\resizebox{\textwidth}{!}{
	\begin{tabular}{l cccccccccc}
		\toprule
		\textbf{Dataset} & COLA & SST-2 & MRPC & QQP & STS-B & MNLI-m & MNLI-mm & QNLI & RTE & \textbf{Avg}\\
		\midrule
		BERT & 55.28 & 92.89 & 88.96 & 88.24 & 88.61 & 84.65 & 84.61 & 91.51 & 68.59 & 82.59 \\
		+ ContraNorm-D & \bf62.08 & \bf93.69 & \bf91.78 & \bf88.36 & \bf89.59 & \bf85.24 & \bf85.19 & \bf91.95 & \bf70.04 & \bf84.21 \\
		\bottomrule    
	\end{tabular}
	}
	\label{table:decorrelate}
\end{table}

\subsection{GNN Experiments on Large-scale OGB Benchmark}

\textbf{Setup.} In order to assess the efficacy of ContraNorm-D in enhancing existing GNN techniques, we conduct tests on the ogbn-arxiv \citep{hu2020open} benchmark, which consists of a large number of nodes (169,343) and edges (1,166,243), rendering ContraNorm unsuitable for scalability. We choose the high-ranking GIANT \citep{chien2021node} method from the OGB leaderboard \footnote{See \url{https://ogb.stanford.edu/docs/leader_nodeprop/\#ogbn-arxiv}.} as the backbone, and combine it with RevGAT \cite{li2021training} and self-knowledge distillation (selfKD) as suggested in the original paper. We follow the experiment settings in \cite{chien2021node}, but reduce the optimization step for each layer of the hierarchical label trees to 1,000 (as opposed to 2,000 in the original method). For hyperparameters in ContraNorm-D, we set the scale $s$ to $2$ and the temperature $\tau$ to $5$. We insert a ContraNorm-D layer after the graph convolution operation. Our implement is based on the GIANT repository \footnote{See \url{https://github.com/elichienxD/deep_gcns_torch}.}. 

\textbf{Results.} As shown in Table \ref{table:cn-d}, despite the various tricks that have been applied to the GIANT* setting, the use of our ContraNorm-D variant can still boost its test performance from 76.15\% to 76.39\%. At the time of paper revision (April 17, 2023), we find that this gain is significant enough to improve the rank of GIANT* from the 6th place to the 2nd place, and achieves \textbf{SOTA results on the ogbn-arxiv dataset at this parameter scale}, since the 1st ranking method GLEM+RevGAT has more than 100x parameters than our model. This finding indicates that ContraNorm-D can serve as a plug-and-play component and boost existing state-of-the-art GNNs on large-scale graph datasets.

\begin{table}[h]
	\centering
	\caption{Comparison of GIANT* (GIANT-XRT+RevGAT+KD) with or without ContraNorm-D on the test set of ogbn-arxiv benchmark. } 
	\begin{tabular}{l cc|c}
		\toprule
		\textbf{Method} & GIANT* & GIANT* + ContraNorm-D & GLEM+RevGAT (SOTA) \\
		\midrule
		Test Accuracy & 76.15 & \textbf{76.39} & 76.94 \\
            Params & 1.3M & \textbf{1.3M} & 140.4M \\
            Peak Memory & 5.11G & 6.09G & - \\
            Average epoch time & 0.44s & 0.61s & - \\
		Rank on OGB leaderboard &  6 & \textbf{2} & 1 \\
  \bottomrule    
	\end{tabular}
	\label{table:cn-d}
\end{table}


\section{Additional Discussions and Ablating Experiments}

In this section, given more space, we elaborate more details on the choice of our architectural designs and evaluate their effects on real-world experiments.

\subsection{Explaining and Evaluating The Stop-Gradient Operation in Eq.~(\ref{eq-contra-1})}
\label{stop-gradient}
In this section, we will illustrate the stop-gradient operation in Eq.~(\ref{eq-contra-1}) by using the framework proposed by \cite{tao2022exploring}. The original update form should be Eq.~(\ref{eq-contra}):
\begin{equation*}
    \mH_t = \mH_b - s\times\frac{\partial \hat{\Ls}_{\rm{uniform}}}{\partial \mH_b}=\mH_b - s/\tau \times (\mD^{-1}\mA + \mA\mD^{-1})\mH_b.
\end{equation*}
We take SimCLR \citep{chen2020simple} as the contrastive learning framework. \cite{tao2022exploring} have studied the stop-gradient form of SimCLR and illustrated that the stop-gradient operation will make a similar performance with the original one. Based on this, we will elaborate on how $\mathbf{A}\mathbf{D}^{-1}$ is removed in the following part. In fact, we can directly illustrate how the second term in Eq.~(\ref{eq-d}) can be omitted.
\begin{equation*}
    \frac{\partial \hat{\Ls}_{\rm{uniform}}}{\partial \vh_i} 
    = \sum_j \frac{\exp(\vh_i^{\top} \vh_j/\tau)}{\sum_k \exp(\vh_i^{\top} \vh_k/\tau)} \vh_j/\tau + \sum_j \frac{\exp(\vh_i ^{\top}\vh_j/\tau)}{\sum_k \exp(\vh_j ^{\top}\vh_k/\tau)} \vh_j/\tau.
\end{equation*}

In SimCLR, by denoting the normalized features from the online branch as $u^o_i, i=1,2,\dots,n$, the normalized features from the target branch (although the two branches have no differences in SimCLR) are $u^t_i,i=1,2,\dots,n$ and $\mathcal{V}=\{u_1^o,u_2^o,\dots,u_n^o,u_1^t,u_2^t,\dots,u_n^t\},$ the SimCLR loss can be represented as
$$L=-\frac{1}{2n}\sum_{u_1\in\mathcal{V}}\log\frac{\exp(u_1^{\top}u_1'/\tau)}{\sum_{u\in\mathcal{V}/u_1}\exp(u_1^{\top}u/\tau)}$$
where $u_1$ and $u_1'$ are positive pairs and $\tau$ is the temperature. Then the gradient of $L$ on $u_1^o$ can be calculated as
$$\frac{\partial L}{\partial u_1^o}=\frac{1}{2\tau n}\left(-u_1^t+\sum_{v\in{\mathcal{V}/u_1^o}}s_vv\right)+\frac{1}{2\tau n}\left(-u_1^t+\sum_{v\in\mathcal{V}/u_1^o}t_vv\right)$$
where
$$s_v=\frac{\exp(u_1^{o\top}v/\tau)}{\sum_{v'\in\mathcal{V}/u_1^o}\exp(u_1^{o\top}v'/\tau)}$$
is the softmax results over similarities between $u_1^o$ and other samples, and
$$t_v=\frac{\exp(v^{\top}u_1^o/\tau)}{\sum_{v'\in\mathcal{V}/v}\exp(v^{\top}v'/\tau)}$$
is computed over similarities between sample $v$ and its contrastive samples $\mathcal{V}/v$. We can see that the first term of $\partial L/\partial u_1^o$ comes from the part which takes $u_1^o$ as the anchor, and the second term comes from the part which takes the other feature as the anchor. \cite{tao2022exploring} proposes to stop the second term and verifies that stopping the second gradient term will not affect the performance empirically.

Note that the $u_1^t$ term in the gradient is from the alignment loss. So the gradient of the uniformity loss on $u_1^o$ can be written as
\begin{equation}\frac{\partial L_{\rm{uniform}}}{\partial u_1^o}=\frac{1}{2\tau n}\left(\sum_{v\in{\mathcal{V}/u_1^o}}s_vv\right)+\frac{1}{2\tau n}\left(\sum_{v\in\mathcal{V}/u_1^o}t_vv\right)\label{tao-uniform}\end{equation}
It is noteworthy that by writing $\mathcal{V}=\{h_1,h_2,\dots,h_N\}$, Eq.~(\ref{eq-d}) shares the same form as Eq.~(\ref{tao-uniform}). By adopting the stop-gradient method just as \cite{tao2022exploring} takes, we remove the second term in Eq.~(\ref{eq-d}), which is just the $\mA\mD^{-1}$ term in Eq.~(\ref{eq-contra}). 

Empirically, we draw the singular value distribution of embeddings for vanilla BERT and +ContraNorm with only $\mA\mD^{-1}$ term or $\mD^{-1}\mA$ term on RTE task. As shown in Figure \ref{fig:singular-ablation}, compared with vanilla BERT with a long-tail distribution (dimensional collapse), adding ContraNorm with $\mD^{-1}\mA$ and $\mA\mD^{-1}$ both reduce the number of insignificant (nearly zero) singular values and make a more balanced distribution. The similar singular value distributions mean that they play a similar role in alleviating dimensional collapse. 

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{images/singular_distribution_ablation.pdf}
    \caption{Singular value distributions with ContraNorm using only $\mA\mD^{-1}$ term or $\mD^{-1}\mA$ term. Experiments are conducted with 12-layer BERT on RTE task.}
    \label{fig:singular-ablation}
\end{figure}

\subsection{Comparing ConraNorm to Uniformity Regularization} \label{appen:uniformity}
We conduct a comparative experiment on BERT model with straightforwardly applied uniformity loss and our proposed ContraNorm. Specifically, we add the uniformity loss ($loss_{\rm{uni}}$) to the classification loss (MSELoss, CrossEntropyLoss or BCELoss depending on the task type, denoted by $loss_{\rm{cls}}$). Formally, the final loss is written as

$$loss_{\rm{total}} = loss_{\rm{cls}} + loss_{\rm{uni}},$$

where $loss_{\rm{uni}} = \sum_{i=1}^{N} \log \sum_{j=1}^N \exp(f(\mathbf{x}_i)^Tf(\mathbf{x}_j) / \tau)$ and $N$ is the number of samples in the batch. We tune $\tau$ in the range of $[0.5, 0.8, 1.0, 1.2, 1.5]$ and choose the best one in terms of average performance. Other hyperparameters are kept the same as settings of ContraNorm. The results are shown in the Table \ref{table:uniform}

\begin{table}[h]
	\centering
	\caption{Results comparison on validation set of GLUE tasks. Following \cite{devlin2018bert}, we report F1 scores for QQP and MRPC, Spearman correlations for STS-B, and accuracy scores for the other tasks. \textbf{Avg} denotes the average performance on all the tasks. For each task, the best performance is bolded.}
	\vspace{0.1cm}
	\resizebox{\textwidth}{!}{
	\begin{tabular}{l cccccccccc}
		\toprule
		\textbf{Dataset} & COLA & SST-2 & MRPC & QQP & STS-B & MNLI-m & MNLI-mm & QNLI & RTE & \textbf{Avg}\\
		\midrule
		BERT-base & 55.28 & 92.89 & 88.96 & 88.24 & 88.61 & 84.65 & 84.61 & 91.51 & 68.59 & 82.59 \\
		BERT + Uniformity Loss & 58.08 & 93.00 & 89.46 & 88.14 & \bf88.69 & 84.45 & 84.43 & 91.60 & 68.59 & 82.94 \\
		BERT + ContraNorm & \bf58.83 & \bf93.12 & \bf89.49 & \bf88.30 & 88.66 & \bf84.87 & \bf84.66 & \bf91.78 & \bf70.76 & \bf83.39 \\
		\bottomrule    
	\end{tabular}
	}
	\label{table:uniform}
\end{table}

We can see that +ContraNorm gets the best score in 8 / 9 tasks, while +Uniformity loss reaches the best only in 1 / 9 tasks. ContraNorm also has the highest average score among all tasks. The reason is that updating the total loss is a combined process for objectives of correct classification and uniform distribution. Thus, a lower $loss_{\rm{total}}$ may be only caused by a lower classification loss while uniformity loss is kept the same, which cannot ensure a more uniform distribution of representations. In contrast, ContraNorm acts directly on representations in each layer and enforces the uniform property.

In fact, there are many methods in GNNs such as \citet{yang2021graph} and \citet{zhu2021interpreting}, which design the propagation mechanism under the guidance of the corresponding objective. The well-designed propagation mechanism is shown to be the most fundamental part of GNNs \citep{zhu2021interpreting}. Instead of directly using the loss function, these methods transfer the loss function into a specific propagation method and achieve superior performance, which indicates that changing the network may be more effective than directly adding the objective to the loss function.

\subsection{Analysis of the plugging position of ContraNorm} \label{appen:pos}
We explore two ways to integrate ContraNorm into BERT and ALBERT. Concretely, consider the update of $\mH^{(l)}$ in $l$-th block of Transformers 
\begin{align}
    &\mH^{(l)} = \mbox{MultiHeadAttention}(\mH^{(l)}), \label{eq:a1}\\
    &\mH^{(l)} = \mH^{(l)} + \mX, \label{eq:a2}\\
    &\mH^{(l)} = \mbox{LayerNorm}(\mH^{(l)}) \label{eq:a3},
\end{align}
where $\mX = \mH_b$ is the input tensor.

We choose positions 1) between Eq.~(\ref{eq:a1}) and Eq.~(\ref{eq:a2}), named as \textit{before-residual}; 2) between Eq.~(\ref{eq:a2}) and Eq.~(\ref{eq:a3}), named as \textit{after-residual}. The performance comparison between the two positions on GLUE datasets is shown in Table \ref{table:pos}. It is observed that putting ContraNorm after the residual connection slightly outperforms that before residual. Therefore, we choose the after-residual variant as our basic ContraNorm.

\begin{table}[h]
	\centering
	\caption{Results comparison on different plugging positions of ContraNorm. Experiments are evaluated on the validation set of GLUE tasks. \textbf{Avg} denotes the average performance on all the tasks. The best result for each task is bolded.} 
	\resizebox{\textwidth}{!}{
	\begin{tabular}{l cccccccccc}
		\toprule
		\textbf{Dataset} & COLA & SST-2 & MRPC & QQP & STS-B & MNLI-m & MNLI-mm & QNLI & RTE & \textbf{Avg}\\
		\midrule
		BERT-base & 55.28 & 92.89 & 88.96 & 88.24 & 88.61 & 84.65 & 84.61 & 91.51 & 68.59 & 82.59 \\
		before-residual & 59.57 & 93.12 & 89.97 & 88.30 & 88.93 & 84.84 & 84.67 & 91.58 & 68.95 & 83.33 \\
		after-residual & 58.83 & 93.12 & 89.49 & 88.30 & 88.66 & 84.87 & 84.66 & 91.78 & 70.76 & 83.39\\
		\bottomrule    
	\end{tabular}
	}
	\label{table:pos}
\end{table}


\section{More Experimental Details}

\section{Introduction of graph datasets} \label{appen:data}

Here, we introduce the properties of the graph datasets discussed in this work.

\textbf{Citation Network.} Cora, CiteSeer are three popular citation graph datasets. In these graphs, nodes represent papers and edges correspond to the citation relationship between two papers. Nodes are classified according to academic topics.

\textbf{Wikipedia Network.} Chameleon and Squirrel are Wikipedia page networks on specific topics, where nodes represent web pages and edges are the mutual links between them. Node features are the bag-of-words representation of informative nouns. The nodes are classified into four categories according to the number of the average monthly traffic of the page.

Statics of datasets are shown in Table \ref{table:graph}.

\begin{table}[h]
\caption{Graph datasets statics.}\label{table:graph}
\begin{center}
\begin{tabular}{ll ccccc}
    \toprule
        Category                &Dataset    &\# Nodes    &\# Edges    &\# Features &Degree    &\# Classes\\ 
    \midrule
    \multirow{2}*{Citation}     &Cora       &2708       &5278       &1433       &4.90       &7\\
            ~                   &CiteSeer   &3327       &4552       &3703       &3.77       &6\\
    \midrule 
    \multirow{2}*{Wikipedia}    &Chameleon  &2277       &36101      &500        &5.0        &6\\
            ~                   &Squirrel   &5201       &217073     &2089       &154.0      &4\\
    \bottomrule
\end{tabular}
\end{center}
\end{table}


\subsection{Metrics calculating feature and attention map cosine similarity } \label{appen:metrics}
Following \citet{wang2022anti}, given feature map $\mH \in \R^{N \times D}$ and attention map of the $h$-th head $\mA^{(h)} \in \R^{N \times N}$ with batch size $N$ and hidden embedding size $D$, the feature cosine similarity and the attention cosine similarity is computed as
\begin{equation*}
    \mbox{sim}_f = \frac{2}{N(N-1)}\sum_{i, j>i} \frac{{\vh_i}^{\top}\vh_j}{\Vert \vh_i \Vert_2 \Vert \vh_j \Vert_2}, \quad
    \mbox{sim}_{\rm{attn}} = \frac{2}{N(N-1)H}\sum_{i, j>i} \frac{{\va^{(h)}_i}^{\top}\va^{(h)}_j}{\Vert \va^{(h)}_i \Vert_2 \Vert \va^{(h)}_j \Vert_2},
\end{equation*}
where $\vh_i$ denotes the $i$-th row of $\mH$, $\va_i$ is the $i$-th column of $\mA$, and $H$ is the number of attention heads. 

\section{Additional Experimental Results}

\subsection{Results on test set of GLUE datasets} \label{appen:test}
We submit our trained model to GLUE benchmark leaderboard and the resultant feedback of performance is shown in Table \ref{table:nlp-test}. 

\begin{table}[h]
	\centering
	\caption{Results comparison on test set of GLUE tasks. \textbf{Avg} denotes the average performance on all the tasks.} 
	\resizebox{\textwidth}{!}{
	\begin{tabular}{l cccccccccc}
		\toprule
		\textbf{Dataset} & COLA & SST-2 & MRPC & QQP & STS-B & MNLI-m & MNLI-mm & QNLI & RTE & \textbf{Avg}\\
		\midrule
		BERT-base & 53.3 & 92.8 & 86.8 & 71.2 & 82.8 & 84.4 & 83.2 & 90.9 & 66.3 & 79.1 \\
		BERT + ContraNorm & 54.5 & 93.0 & 87.9 & 71.4 & 83.0 & 84.5 & 83.4 & 91.0 & 66.9 & 79.5\\
		\bottomrule    
	\end{tabular}
	}
	\label{table:nlp-test}
\end{table}


\subsection{More results of the Ablation Study} \label{appen:abla}
 We conduct experiments using BERT+ContraNorm with varying scaling factor $s$ on GLUE datasets. For each dataset, we vary the normalization scale around the best choice, and other parameters remain consistent. As shown in Figure \ref{fig:ablation-full}, the results illustrate that model with ContraNorm is robust in an appropriate range of normalization scaling factor.

\begin{figure}[h]
     \centering
     \begin{subfigure}{0.25\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/rte-ablation.pdf}
         \caption{RTE}
     \end{subfigure}
     \begin{subfigure}{0.25\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/cola-ablation.pdf}
         \caption{CoLA}
     \end{subfigure}
     \begin{subfigure}{0.25\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/stsb-ablation.pdf}
         \caption{STS-B}
     \end{subfigure}
     \hfill
     \begin{subfigure}{0.25\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/mrpc-ablation.pdf}
         \caption{MRPC}
     \end{subfigure}
     \begin{subfigure}{0.25\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/sst2-ablation.pdf}
         \caption{SST2}
     \end{subfigure}
     \begin{subfigure}{0.25\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/qnli-ablation.pdf}
         \caption{QNLI}
     \end{subfigure}
     \hfill
     \begin{subfigure}{0.25\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/mnli-m-ablation.pdf}
         \caption{MNLI-m}
     \end{subfigure}
     \begin{subfigure}{0.25\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/mnli-mm-ablation.pdf}
         \caption{MNLI-mm}
     \end{subfigure}
     \begin{subfigure}{0.25\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/qqp-ablation.pdf}
         \caption{QQP}
     \end{subfigure}

    \caption{Performance when varying scale factor $s$ on GLUE datasets. We choose BERT as the base model. The varying range is an interval containing the best choice of $s$. Here, we fix it to $[0.005, 0.1]$ for all tasks.}
    \label{fig:ablation-full}
\end{figure}

\section{Omitted Proofs} \label{appen:proof}
Here, we present the complete proof for Propositions in Section \ref{sec:theoretical-analysis}.

First, we give two lemmas that will be useful for the proof.
\begin{lemma}
    Denote $\ve=[1,1,\dots,1]^{\top}/\sqrt{n}$. For any update form $\mX_1=\mP\mX_0$ and $\lambda>0$, if the eigenvalues of $(\mI-\ve\ve^{\top})-\lambda\mP^{\top}(\mI-\ve\ve^{\top})\mP$ are all not larger than zero, then we have $\Var(\mX_1)\geq \lambda^{-1}\cdot \Var(\mX_0)$. \label{lemma1}
\end{lemma}
\begin{proof}
    We denote $\mX_0\mX_0^{\top}=\mY\text{diag}(\omega_1,\dots,\omega_n)\mY^{\top}$ for the eigen-decomposition of $\mX_0\mX_0^{\top}$, where $\mY=[\vy_1,\vy_2,\dots,\vy_n]$ is the orthogonal basis and all $\omega_i\geq 0$. Note that $(\mI-\ve\ve^{\top})^2=(\mI-\ve\ve^{\top})$. Therefore,
    \begin{equation}
    \begin{aligned}
        \Var(\mX_0)&=\|(\mI-\ve\ve^{\top})\mX_0\|_F^2\\
        &=tr\{|(\mI-\ve\ve^{\top})\mX_0\mX_0^{\top}(\mI-\ve\ve^{\top})\}\\
        &=tr\{(\mI-\ve\ve^{\top})\mY\text{diag}(\omega_1,\dots,\omega_n)\mY^{\top}(\mI-\ve\ve^{\top})\}\\
        &=tr\{\text{diag}(\omega_1,\dots,\omega_n)\mY^{\top}(\mI-\ve\ve^{\top})(\mI-\ve\ve^{\top})\mY\}\\
        &=tr\{\text{diag}(\omega_1,\dots,\omega_n)\mY^{\top}(\mI-\ve\ve^{\top})\mY\}\\
        &=\sum_{i=1}^{n}\omega_i\vy_i^{\top}(\mI-\ve\ve^{\top})\vy_i
    \end{aligned}
    \end{equation}
    Similarly, we have
    \begin{equation}
        \Var(\mX_1)=\sum_{i=1}^{n}\omega_i\vy_i^{\top}\mP(\mI-\ve\ve^{\top})\mP\vy_i.
    \end{equation}
    Therefore, we have
    \begin{equation}
        \Var(\mX_0)-\lambda\Var(\mX_1)=\sum_{i=1}^n\omega_i\vy_i^{\top}\{(\mI-\ve\ve^{\top})-\lambda\mP^{\top}(\mI-\ve\ve^{\top})\mP\}\vy_i.
    \end{equation}
    Thus, if the eigenvalues of $(\mI-\ve\ve^{\top})-\lambda\mP^{\top}(\mI-\ve\ve^{\top})\mP:=\bm{\Sigma}$ are all not larger than zero, $\bm{\Sigma}$ is semi-negative definite, then we have
    \begin{equation}
        \vy_i^{\top}\{(\mI-\ve\ve^{\top})-\lambda\mP^{\top}(\mI-\ve\ve^{\top})\mP\}\vy_i\leq 0,
    \end{equation}
    which implies that $\Var(\mX_0)-\lambda\Var(\mX_1)\leq 0$. Therefore, $\Var(\mX_1)\geq \lambda^{-1}\cdot\Var(\mX_0)$. 
\end{proof}
The second lemma is from the Eq.~(13) in \cite{eigenvalue}.
\begin{lemma}
    Let $A,B,C$ be symmetric matrices and $C=A+B.$ Suppose the eigenvalues of $A$ are  $\alpha_1\geq\alpha_2\geq\dots\geq\alpha_n$, the eigenvalues of $B$ are  $\beta_1\geq\beta_2\geq\dots\geq\beta_n$, and the eigenvalues of $C$ are $\gamma_1\geq\gamma_2\geq\dots\geq\gamma_n$. Then we have the inequality
    \begin{equation}
        \max_{i+j=n+k}\alpha_i+\beta_j\leq\gamma_k\leq\min_{i+j=k+1}\alpha_i+\beta_j.
    \end{equation}\label{lemma2}
\end{lemma}
We can now start to prove Proposition \ref{proposition:complete}.
\begin{manualproposition}{1}
   Let $\ve=(1,1,\dots,1)^{\top}/\sqrt{n}$. For attention matrix $\bar{\mA}=\operatorname{softmax}(\mH_b\mH_b^{\top})$, let $\sigma_{\min}$ be the smallest eigenvalue of  $\mP=(\mI-\ve\ve^{\top})(\mI-\bar{\mA})+(\mI-\bar{\mA})^{\top}(\mI-\ve\ve^{\top})$. For the ContraNorm update $\mH_t=((1+s)\mI-s\bar{\mA})\mH_b,\ s>0$, we have $Var(\mH_t)\geq (1-s\sigma_{\min})^{-1}\cdot Var(\mH_b)$. Especially, if $\sigma_{\min}\geq0$, we have $Var(\mH_t)\geq Var(\mH_b)$.
\end{manualproposition}
\begin{proof}
    We denote $\Sigma=(\mI-\ve\ve^{\top})-\lambda((1+s)\mI-s\bar{\mA})^{\top}(\mI-\ve\ve^{\top})((1+s)\mI-s\bar{\mA})$. Then,
    \begin{equation}
    \begin{aligned}
        \Sigma&=(1-\lambda)\mI-\lambda(s(\mI-\bar{\mA})^{\top}(\mI-\ve\ve^{\top})-s(\mI-\ve\ve^{\top})(\mI-\bar{\mA})-s^2(\mI-\bar{\mA})^{\top}(\mI-\ve\ve^{\top})(\mI-\bar{\mA}))\\
        &=(1-\lambda)\mI-\lambda s\mP-\lambda s^2(\mI-\bar{\mA})^{\top}(\mI-\ve\ve^{\top})(\mI-\bar{\mA}).
    \end{aligned}
    \end{equation}
    Let $\alpha_1\geq\alpha_2\geq\dots\geq\alpha_n$ be the eigenvalues of $\Sigma$. Since $\mI-\ve\ve^{\top}$ has a eigenvalue of 0 and $n-1$ eigenvalues of 1, $\mI-\ve\ve^{\top}$ is a semi-definite positive matrix. Thus, $s^2(\mI-\bar{\mA})^{\top}(\mI-\ve\ve^{\top})(\mI-\bar{\mA})$ is also a semi-definite positive matrix. Notice that the largest eigenvalue of $(1-\lambda)\mI-s\mP$ is $(1-\lambda)-s\sigma_{\min}$ and the largest eigenvalue of $-s^2(\mI-\bar{\mA})^{\top}(\mI-\ve\ve^{\top})(\mI-\bar{\mA})$ is $0$. Therefore, by Lemma \ref{lemma2}, the largest eigenvalue of $\Sigma$ is less or equal to $(1-\lambda)-s\sigma_{\min}$. Let $\lambda=1-s\sigma_{\min}$, then the largest eigenvalue of $\Sigma$ is less or equal to $0$. By Lemma \ref{lemma1}, we have $Var(\mH_t)\geq (1-s\sigma_{\min})^{-1}\cdot Var(\mH_b)$.
    
    Moreover, if $\sigma_{\min}\geq 0$, then $(1-s\sigma_{\min})^{-1}\geq 1$, leading to $Var(\mH_t)\geq Var(\mH_b)$.
\end{proof}
\textbf{Remark.} Now we discuss some sufficient conditions for $\sigma_{\min}\geq0.$ If $\mP$ is a diagonally dominant matrix, then we will have the result $\sigma_{\min}\geq0.$ Denote $a_{ij}=\bar{A}_{ij}$, $b_{ij}=\sigma_{ij}-a_{ij}$ and $\mQ=(\mI-\ve\ve^{\top})(\mI-\bar{A})$, where $\sigma_{ij}=1$ if $i=j$ and $\sigma_{ij}=0$ if $i\neq j$, then we have
\begin{equation}
    \mQ_{ij}=b_{ij}-\frac{1}{n}\sum_{k=1}^n(b_{kj}).
\end{equation}
If we have $\sum_{k=1}^na_{kj}\leq 1+na_{ij}$ for any $i,j$, then we will have
\begin{equation}
    b_{jj}\geq\frac{\sum_{k=1}^nb_{kj}}{n}\geq b_{ij},\ i\neq j .
\end{equation}
Notice that $\sum_{k=1}^nb_{kj}=0$, we have
\begin{equation}
    |Q_{jj}|=|\sum_{k\neq j}Q_{kj}|
\end{equation}
Since $\bar{A}$ is an attention matrix, we also have
\begin{equation}
    |Q_{jj}|=|\sum_{k\neq j}Q_{jk}|.
\end{equation}
Therefore, we have
\begin{equation}
    \begin{aligned}
        |\mP_{jj}|&=2|\mQ_{jj}|\\
        &=|\sum_{k\neq j}Q_{kj}|+|\sum_{k\neq j}Q_{jk}|\\
        &\geq |\sum_{k\neq j}Q_{kj}+\sum_{k\neq j}Q_{jk}|\\
        &\geq |\sum_{k\neq j}\mP_{kj}|,
    \end{aligned}
\end{equation}
which indicates that $\mP$ is a diagonally dominated matrix, thus $\sigma_{\min}\geq 0.$ Therefore, $\sum_{k=1}^na_{kj}\leq 1+na_{ij}$ for any $i,j$ is just a sufficient condition. A special case for this is $\sum_{k=1}^na_{kj}=1, \forall k$.

We now move on to the proof of Proposition \ref{proposition:dimensional}. We first give a lemma on the property of effective rank.
\begin{lemma}
    Let the eigenvalues of $AA^{\top}$ be $\lambda_1\geq\lambda_2\geq\dots\geq\lambda_n$ and the eigenvalues of $BB^{\top}$ be $\sigma_1\geq\sigma_2\geq\dots\sigma_n$. If $\sigma_i/\lambda_i$ is increasing as $i$ increases, then we have $\operatorname{erank}(B)\geq \operatorname{erank}(A).$ \label{lemma3}
\end{lemma}
This lemma can be proved just by using the definition of the effective rank.
\begin{manualproposition}{2}
Consider the update form
    \begin{equation}
    \mH_t=(1+s)\mH_b-s(\mH_b\mH_b^{\top})\mH_b,
    \end{equation}
    let $\sigma_{\max}$ be the largest singular value of $\mH_b$. For $s>0$ satisfying $1+(1-\sigma^2_{\max})s>0$, we have $\operatorname{erank}(\mH_t)>\operatorname{erank}(\mH_b)$.
\end{manualproposition}
\begin{proof}
    We have
    \begin{equation}
        \mH_t=((1+s)\mH_b-s\mH_b\mH_b^{\top})\mH_b.
    \end{equation}
    Therefore,
    \begin{equation}
        \mH_t\mH_t^{\top}=s^2(\mH_b\mH_b^{\top})^3-2s(1+s)(\mH_b\mH_b^{\top})^2+(1+s)^2(\mH_b\mH_b^{\top})
    \end{equation}
    Suppose $\lambda_1\geq\lambda_2\geq\dots\geq\lambda_n$ are the eigenvalues of $\mH_b\mH_b^{\top}$, then $\mH_t\mH_t^{T}$ has the same eigenvectors as $\mH_b\mH_b^{\top}$, and its eigenvalues are $(\lambda_is-(1+s))^2\lambda_i$. Since $s$ satisfies $1+(1-\sigma^2_{\max}s)>0$, we have $1+s>\lambda_i s$. Therefore, $(\lambda_is-(1+s))^2$ is increasing as $i$ increases, resulting the fact that $\operatorname{erank}(\mH_t)>\operatorname{erank}(\mH_b)$ by using Lemma \ref{lemma3}. 
\end{proof}


\end{document}
