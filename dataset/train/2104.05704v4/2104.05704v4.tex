\documentclass[10pt,twocolumn,letterpaper]{article}
\usepackage{iccv}
\usepackage{times}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{pifont}
\usepackage{color}
\usepackage{placeins}
\usepackage{afterpage}

\usepackage{algorithm}
\usepackage{listings}

\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}


\usepackage[pagebackref=true,breaklinks=true,colorlinks,bookmarks=false]{hyperref}

\iccvfinalcopy 

\def\iccvPaperID{****} \def\httilde{\mbox{\tt\raisebox{-.5ex}{\symbol{126}}}}

\usepackage{booktabs}
\usepackage{multicol}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\captionsetup[table]{skip=10pt}

\newcommand*\samethanks[1][\value{footnote}]{\footnotemark[#1]}

\newcommand{\mbb}[1]{\mathbb{#1}}
\newcommand{\mbf}[1]{\mathbf{#1}}
\newcommand{\op}[1]{\operatorname{#1}}

\newcommand{\cmark}{\ding{51}}
\newcommand{\xmark}{\ding{55}}
 
\begin{document}

\title{Escaping the Big Data Paradigm with \\Compact Transformers}

\author{Ali Hassani\textsuperscript{1}\thanks{Equal contribution. Our code and pre-trained models are publicly available at \href{https://github.com/SHI-Labs/Compact-Transformers}{https://github.com/SHI-Labs/Compact-Transformers}}, Steven Walton\textsuperscript{1}\footnotemark[1] \,, Nikhil Shah\textsuperscript{1},\\Abulikemu Abuduweili\textsuperscript{1}, Jiachen Li\textsuperscript{2,1}, Humphrey Shi\textsuperscript{1,2,3} \\
{\small \textsuperscript{1}SHI Lab  University of Oregon, \textsuperscript{2}University of Illinois at Urbana-Champaign, \textsuperscript{3}Picsart AI Research (PAIR)}\\
}

\maketitle

\begin{abstract}
With the rise of Transformers as the standard for language processing, and their advancements in computer vision, there has been a corresponding growth in parameter size and amounts of training data. Many have come to believe that because of this, transformers are not suitable for small sets of data.
This trend leads to concerns such as: limited availability of data in certain scientific domains and the exclusion of those with limited resource from research in the field.
In this paper, we aim to present an approach for small-scale learning by introducing Compact Transformers.
We show for the first time that with the right size, convolutional tokenization, transformers can avoid overfitting and outperform state-of-the-art CNNs on small datasets.
Our models are flexible in terms of model size, and can have as little as 0.28M parameters while achieving competitive results.
Our best model can reach 98\% accuracy when training from scratch on CIFAR-10 with only 3.7M parameters, which is a significant improvement in data-efficiency over previous Transformer based models being over 10x smaller than other transformers and is 15\% the size of ResNet50 while achieving similar performance.
CCT also outperforms many modern CNN based approaches, and even some recent NAS-based approaches.
Additionally, we obtain a new SOTA result on Flowers-102 with 99.76\% top-1 accuracy, and improve upon the existing baseline on ImageNet (82.71\% accuracy with 29\% as many parameters as ViT), as well as NLP tasks.
Our simple and compact design for transformers makes them more feasible to study for those with limited computing resources and/or dealing with small datasets, while extending existing research efforts in data efficient transformers.
\end{abstract}

\section{Introduction}

\begin{figure}
    \centering
    \vspace{2mm}
    \includegraphics[width=0.5\textwidth]{assets/images/model_sym.pdf}
    \vspace{1mm}
    \caption{Overview of \textbf{CVT} (right), the basic compact transformer, and \textbf{CCT} (left), the convolutional variant of our compact transformer models. CCT can be quickly trained from scratch on small datasets, while achieving high accuracy
    (in under 30 minutes one can get 90\% on an NVIDIA 2080Ti GPU or 80\% on an AMD 5900X CPU on CIFAR-10 dataset).
    }
    \label{fig:method_overview}
\end{figure}

Convolutional neural networks (CNNs)~\cite{lecun1989backpropagation} have been the standard for computer vision, since the success of AlexNet~\cite{krizhevsky2012imagenet}. Krizhevsky~\etal showed that convolutions are adept at vision based problems due to their invariance to spatial translations as well as having low relational inductive bias. He~\etal\cite{he2016deep} extended this work by introducing residual connections, allowing for significantly deeper models to perform efficiently. Convolutions leverage three important concepts that lead to their efficiency: \textit{sparse interaction}, \textit{weight sharing}, and \textit{equivariant representations}~\cite{goodfellow2016deep}. Translational equivariance and invariance are properties of the convolutions and pooling layers, respectively~\cite{goodfellow2016deep,schmidhuber2015deep}. They allow CNNs to leverage natural image statistics and subsequently allow models to have higher sampling efficiency~\cite{ruderman1994statistics,ruderman1994statistics}.

On the other end of the spectrum, Transformers have become increasingly popular and a major focus of modern machine learning research. Since the advent of Attention is All You Need~\cite{vaswani2017attention}, the research community saw a spike in transformer-based and attention-based research. While this work originated in natural language processing, these models have been applied to other fields, such as computer vision.
Vision Transformer (ViT)~\cite{dosovitskiy2020image} was the first major demonstration of a pure transformer backbone being applied to computer vision tasks.
ViT highlights not only the power of such models, but also that large-scale training can trump inductive biases. The authors argued that ``\textit{Transformers lack some of the inductive biases inherent to CNNs, such as translation equivariance and locality, and therefore do not generalize well when trained on insufficient amounts of data.}''
Over the past few years, an explosion in model sizes and datasets has also become noticeable which has led to a ``data hungry'' paradigm, making training transformers from scratch seem intractable for many types of pressing problems, where there are typically several orders of magnitude less data. It also limits major contributions in the research to those with vast computational resources.

As a result, CNNs are still the go-to models for smaller datasets because they are more efficient, both computationally and in terms of memory, when compared to transformers.
Additionally, local inductive bias shows to be more important in smaller images.
They require less time and data to train while also requiring a lower number of parameters to accurately fit data.
However, they do not enjoy the long range interdependence that attention mechanisms in transformers provide.
Reducing machine learning's dependence on large sums of data is important, as many domains, such as science and medicine, would hardly have datasets the size of ImageNet~\cite{deng2009imagenet}.
This is because events are far more rare and it would be more difficult to properly assign labels, let alone create a set of data which has low bias and is appropriate for conventional neural networks.
In medical research, for instance, it may be difficult to compile positive samples of images for a rare disease without other correlating factors, such as medical equipment being attached to patients who are actively being treated.
Additionally, for a sufficiently rare disease there may only be a few thousand images for positive samples, which is typically not enough to train a network with good statistical prediction unless it can sufficiently be pre-trained on data with similar attributes.
This inability to handle smaller datasets has impacted the scientific community where they are much more limited in the models and tools that they are able to explore.
Frequently, problems in scientific domains have little in common with domains of pre-trained models and when domains are sufficiently distinct pre-training can have little to no effect on the performance within a new domain~\cite{zhuang2019a}.
In addition, it has been shown that strong performance on ImageNet does not necessarily result in equally strong performance in other domains, such as medicine~\cite{ke2021chextransfer}.
Furthermore, the requisite of large data results in a requisite of large computational resources and this prevents many researchers from being able to provide insight.
This not only limits the ability to apply models in different domains, but also limits reproducibility.
Verification of state of the art machine learning algorithms should not be limited to those with large infrastructures and computational resources.

The above concerns motivated our efforts to build more efficient models that can be effective in less data intensive domains and allow for training on datasets that are orders of magnitude smaller than those conventionally seen in computer vision and natural language processing (NLP) problems.
Both Transformers and CNNs have highly desirable qualities for statistical inference and prediction, but each comes with their own costs. In this work, we try to bridge the gap between these two architectures and develop an architecture that can both attend to important features within images, while also being spatially invariant, where we have sparse interactions and weight sharing.
This allows for a Transformer based model to be trained from scratch on small datasets like CIFAR-10 and CIFAR-100, providing competitive results with fewer parameters and low computational requirements.

In this paper we introduce ViT-Lite, a smaller and more compact version of ViT, which can obtain over  accuracy on CIFAR-10.
We expand on ViT-Lite by introducing a sequence pooling and forming the Compact Vision Transformer (CVT). We further iterate by adding convolutional blocks to the tokenization step and thus creating the Compact Convolutional Transformer (CCT).
Both of these simple additions add to significant increases in performance, leading to a top-1\%accuracy of  on CIFAR-10.
This makes our work the only transformer based model in the top 25 best performing models on CIFAR-10, without pre-training, and significantly smaller than the vast majority.
Our model also outperforms most comparable CNN-based models within this domain, with the exception of certain Neural Architectural Search techniques~\cite{cai2018proxylessnas}.
Additionally, we show that our model can be lightweight, only needing  million parameters and still reach close to  top-1\%~accuracy on CIFAR-10.
On ImageNet, CCT achieves 80.67\% accuracy while still maintaining a small number of parameters and reduced computation.
CCT outperforms ViT, while containing less than a third of the number of parameters with about a third of the computational complexity (MACs).
Additionally, CCT outperform similarly sized and more recent models, such as DeiT~\cite{huang2020improving}.
This demonstrates the scalability of our model while maintaining compactness and computational efficiency.

\clearpage
The main contributions of this paper are:
\begin{itemize}
    \item Extending transformer-based research to small data regimes, by introducing ViT-Lite, which can be trained from scratch and achieve high accuracy on datasets such as CIFAR-10.
    \item Introducing Compact Vision Transformer (CVT) with a new sequence pooling strategy, which pools over output tokens and improves performance.
    \item Introducing Compact Convolutional Transformer (CCT) to increase performance and provide flexibility for input image sizes while also demonstrating that these variants do not depend as much on Positional Embedding compared to the rest.
\end{itemize}

In addition, we demonstrate that our CCT model is fast, obtaining  accuracy on CIFAR-10 using a single NVIDIA 2080Ti GPU and  when trained on a CPU (AMD 5900X), both in under 30 minutes.
Additionally, since our model has a relatively small number of parameters, it can be trained on the majority of GPUs, even if researchers do not have access to top of the line hardware.
Through these efforts, we aim to help enable and extend research around Transformers to cases with limited data and/or researchers with limited resources.

\section{Related Works}
\label{sec:related}

In NLP research, attention mechanisms~\cite{graves2014neural,bahdanau2016neural,luong2015effective} gained popularity for their ability to weigh different features within sequential data. Transformers~\cite{vaswani2017attention} were introduced as a fully attention-based model, primarily for machine translation and NLP in general.
Following this, attention-based models, specifically transformers have been applied to a wide variety of tasks beyond machine translation~\cite{devlin2019bert,liu2019roberta,yang2019xlnet}, including: visual question answering~\cite{lu2019vilbert,su2019vl}, action recognition~\cite{bertasius2021space,girdhar2019video}, and the like.
Many researchers also leveraged a combination of attention and convolutions in neural networks for visual tasks~\cite{wang2017residual,hu2018squeeze,bello2019attention,zhang2019self}.
Ramachandran~\etal~\cite{ramachandran2019stand} introduced one of the first vision models that rely primarily on attention.
Dosovitskiy~\etal~\cite{dosovitskiy2020image} introduced the first stand-alone transformer based model for image classification (ViT). In the following subsections, we briefly revisit ViT and several other related works.

\subsection{Vision Transformer}
\label{subsec:vits}
Dosovitskiy~\etal~\cite{dosovitskiy2020image} introduced ViT primarily to show that reliance on CNNs or their structure is unnecessary, as prior to it, most attention-based models for vision were used either with convolutions~\cite{wang2017residual,bello2019attention,zhang2019self,carion2020end}, or kept some of their properties~\cite{ramachandran2019stand}.
The motivation, beyond self-attention's many desirable properties for a network, specifically its ability to make long range connections, was scalability. It was shown that ViT can successfully keep scaling, while CNNs start saturating in performance as the number of training samples grew.
Through this, they concluded that large-scale training triumphs over the advantage of inductive bias that CNNs have, allowing their model to be competitive with CNN based architectures given sufficiently large amount of training data.
ViT is composed of several parts: Image Tokenization, Positional Embedding, Classification Token, the Transformer Encoder, and a Classification Head.
These subjects are discussed in more detail below.

\textbf{Image Tokenization:}
A standard transformer takes as input a sequence of vectors, called tokens.
For traditional NLP based transformers, word ordering provides a natural order to sequence the data, but this is not so obvious for images.
To tokenize an image, ViT subdivides an image into non-overlapping square patches in raster-scan order.
The sequence of patches,  with patch size , are flattened into 1D vectors and transformed into latent vectors of dimension .
This is equivalent to a convolutional layer with  filters, and  kernel size and stride.
This simple patching and embedding method has a few limitations, in particular: loss of information along the boundary regions.

\textbf{Positional Embedding:}
Positional embedding adds spatial information into the sequence.
Since the model does not actually know anything about the spatial relationship between tokens, adding extra information to reflect that can be useful.
Typically, this is either a learned embedding or tokens are given weights from two sine waves with high frequencies, which is sufficient for the model to learn that there exists a positional relationship between these tokens.


\textbf{Transformer Encoder:}
A transformer encoder consists of a series of stacked encoding layers. Each encoder layer is comprised of two sub-layers: Multi-Headed Self-Attention (MHSA) and a Multi-Layer Perceptron (MLP) head. Each sub-layer is preceded by a layer normalization (LN), and followed by a residual connection to the next sub-layer.

\textbf{Classification:}
Vision transformers typically add an extra learnable \verb|[class]| token to the sequence of the embedded patches, representing the class parameter of an entire image and its state after transformer encoder can be used for classification.
\verb|[class]| token contains latent information, and through self-attention accumulates more information about the sequence, which is later used for classification. ViT~\cite{dosovitskiy2020image} also explored averaging output tokens instead, but found no significant difference in performance. They did however find that the learning rates have to be adjusted between the two variants: \verb|[class]| token \vs average pooling.

\subsection{Data-Efficient Transformers}

In an effort to reduce dependence on data, Touvron~\etal~\cite{touvron2020training} proposed Data-Efficient Image Transformers (DeiT). Using more advanced training techniques, and a novel knowledge transfer method, DeiT improves the classification performance of ViT on ImageNet-1k without large-scale pre-training on datasets such as JFT-300M~\cite{sun2017revisiting} or ImageNet-21k~\cite{deng2009imagenet}. By relying only on more augmentations~\cite{cubuk2020randaugment} and training techniques~\cite{zhang2017mixup,yun2019cutmix}, it is shown that much smaller ViT variants that were unexplored by Dosovitskiy~\etal can outperform the larger ones on ImageNet-1k without pre-training. Furthermore, DeiT variants were pushed even further through their novel knowledge transfer technique, specifically when using a convolutional model as the teacher.
This work pushes forward accessibility of transformers in medium-sized datasets, and we aim to follow by extending the study to even smaller sets of data and smaller models.
However, we base our work on the notion that \textit{if a small dataset happens to be sufficiently novel, pre-trained models will not help train on that domain} and the model will not be appropriate for that dataset.
While knowledge transfer is a strong technique, it requires a pre-trained model for any given dataset, adding to training time and complexity, with an additional forward pass, and as pointed out by Touvron~\etal is usually only significant when there's a convolutional teacher available to transfer the inductive biases. As a result, it can be argued that if a network utilized just the bare minimum of convolutions, while keeping the pure transformer structure, it may need to rely less on large-scale training and transfer of inductive biases through knowledge transfer.

\begin{figure*}[ht!]
    \centering
    \includegraphics[width=0.85\textwidth]{assets/images/convvit-diagram.pdf}
    \caption{Comparing ViT (top) to CVT (middle) and CCT (bottom). CVT can be thought of as an ablated version of CCT, only utilizing sequence pooling and not a convolutional tokenizer. CVT may be preferable with more limited compute, as the patch-based tokenization is faster.}
    \label{fig:vit_comparison}
\end{figure*}

Yuan~\etal~\cite{yuan2021tokens} proposed Tokens-to-token ViT (T2T-ViT), which adopts a window- and attention-based tokenization strategy. Their tokenizer extracts patches of the input feature map, similar to a convolution, applies three sets of kernel weights, and produces three sets of feature maps, which are fed to self-attention as query and key-value pairs. This process is equivalent to convolutions producing the QKV projections in a self-attention module. Finally, this strategy is repeated twice, followed by a final patching and embedding. The entire process replaces patch and embedding in ViT.
This strategy, along with their small-strided patch extraction, allows their network to model local structures, including along the boundaries between patches.
This attention-based patch interaction leads to finer-grained tokens which allow T2T-ViT to outperform previous Transformer-based models on ImageNet.
T2T-ViT differs from our work, in that it focuses on medium-sized datasets like ImageNet, which are not only far too large for many research problems in science and medicine but also resource demanding. T2T tokenizer also has more parameters and complexity compared to a convolutional one.

\subsection{Convolution-inspired Transformers}
Many works have been motivated to improve vision transformers and eliminate the need for large-scale pre-training. ConViT~\cite{d2021convit} introduces a \textit{gated positional self-attention} (GPSA) that allows for a ``soft'' convolutional inductive bias within their model.
GPSA allows their network to have more flexibility with respect to positional information.
Since GPSA is able to be initialized as a convolutional layer, this allows their network to sometimes have the properties of convolutions or alternatively having the properties of attention.
Its \textit{gating parameter} can be adjusted by the network, allowing it to become more expressive and adapt to the needs of the dataset.
Convolution-enhanced image Transformers (Ceit)~\cite{yuan2021incorporating} utilize convolutions throughout their model.
They propose a convolution-based Image-to-Token module for tokenization. They also re-design the encoder with layers of multi-headed self-attention and their novel Locally Enhanced Feedforward Layer, which processes the spatial information form the extracted token.
This allows creates a network that is competitive with other works such as DeiT on ImageNet.
Convolutional vision Transformer (CvT)~\cite{wu2021cvt} introduces convolutional transformer encoder layers, which use convolutions instead of linear projections for the QKV in self-attention. They also introduce convolutions into their tokenization step, and report competitive results compared to other vision transformers on ImageNet-1k.
All of these works report results when trained from scratch on ImageNet (or larger) datasets.


\subsection{Comparison}

Our work differs from the aforementioned in several ways, in that it focuses on answering the following question: \textbf{Can vision transformers be trained from scratch on small datasets?}
Focusing on a small datasets, we seek to create a model that can be trained, from scratch, on datasets that are orders of magnitude smaller than ImageNet.
Having a model that is compact, small in size, and efficient allows greater accessibility, as training on ImageNet is still a difficult and data intensive task for many researchers.
Thus our focus is on an accessible model, with few parameters, that can quickly and efficiently be trained on smaller platforms while still maintaining SOTA results.

\section{Method}

In order to provide empirical evidence that vision transformers are trainable from scratch when dealing with small sets of data, we propose three different models: ViT-Lite, \textbf{C}ompact \textbf{V}ision \textbf{T}ransformers~(CVT), and \textbf{C}ompact \textbf{C}onvolutional \textbf{T}ransformers~(CCT).
ViT-Lite is nearly identical to the original ViT in terms of architecture, but with a more suitable size and patch size for small-scale learning.
CVT builds on this by using our \textbf{Seq}uence \textbf{Pool}ing method (SeqPool), that pools the entire sequence of tokens produced by the transformer encoder. SeqPool replaces the conventional \verb|[class]| token.
CCT builds on CVT and utilizes a convolutional tokenizer, generating richer tokens and preserving local information. The convolutional tokenizer is better at encoding relationships between patches compared to the original ViT~\cite{dosovitskiy2020image}. A detailed modular-level comparison of these models can be viewed in Figure~\ref{fig:vit_comparison}.

The components of our compact transformers are further discussed in the following subsections: Transformer-based Backbone, Small and Compact Models, SeqPool, and Convolutional Tokenizer.

\subsection{Transformer-based Backbone}
\label{sec:method-backbone}
In terms of model design, we follow the original Vision Transformer~\cite{dosovitskiy2020image}, and original Transformer~\cite{vaswani2017attention}.
As mentioned in Section~\ref{subsec:vits}, the encoder consists of transformer blocks, each including an MHSA layer and an MLP block.
The encoder also applies Layer Normalization,  activation, and dropout. Positional embeddings can be learnable or sinusoidal, both of which are effective.

\subsection{Small and Compact Models}
\label{sec:method-small}
We propose smaller and more compact vision transformers. The smallest ViT variant, ViT-Base, includes a 12 layer transformer encoder with 12 attention heads, 64 dimensions per head, and 2048-dimensional hidden layers in the MLP blocks. This, along with the classifier and 16x16 patch and embedder results in over 85M parameters. We propose variants with as few as 2 layers, 2 heads, and 128-dimensional hidden layers. In Appendix \ref{appdx:model_variants}, we summarized the details of the variants we propose, the smallest of which can have as little as 0.22M parameters, while the largest (for small-scale learning) only have 3.8M parameters. We also adjust the tokenizer (patch size) according to the dataset we're training on, based on its image resolution. These variants, which are mostly similar in architecture to ViT, but different in size, are referred to as ViT-Lite.
In our notation, we use the number of layers to specify size, as well as tokenization details: for instance, ViT-Lite-\textit{12}/\textbf{16} has \textit{12} transformer encoder layers, and a \textbf{16\texttimes16} patch size.

\subsection{SeqPool}
\label{sec:seqpool}
In order to map the sequential outputs to a singular class index, ViT~\cite{dosovitskiy2020image} and most other common transformer-based classifiers follow BERT~\cite{devlin2019bert}, in forwarding a learnable class or query token through the network and later feeding it to the classifier. Other common practices include global average pooling (averaging over tokens), which have been shown to be preferable in some scenarios.
We introduce SeqPool, an attention-based method which pools over the output sequence of tokens.
Our motivation is that the output sequence contains relevant information across different parts of the input image, therefore preserving this information can improve performance, and at no additional parameters compared to the learnable token. Additionally, this change slightly decreases computation, due one less token being forwarded.
This operation consists of mapping the output sequence using the transformation . Given:

where  is the output of an  layer transformer encoder ,  is batch size,  is sequence length, and  is the total embedding dimension.  is fed to a linear layer , and softmax activation is applied to the output:

This generates an importance weighting for each input token, which is applied as follows:

By flattening, the output  is produced. This output can then be sent through a classifier.

SeqPool allows our network to weigh the sequential embeddings of the latent space produced by the transformer encoder and correlate data across the input data.
This can be thought of this as attending to the sequential data, where we are assigning importance weights across the sequence of data, only after they have been processed by the encoder.
We tested several variations of this pooling method, including learnable and static methods, and found that the learnable pooling performs the best. Static methods, such as global average pooling have already been explored by ViT as well, as pointed out in section~\ref{subsec:vits}.
We believe that the learnable weighting is more efficient because each embedded patch does not contain the same amount of entropy.
This allows the model to apply weights to tokens with respect to the relevance of their information.
Additionally, sequence pooling allows our model to better utilize information across spatially sparse data.
We will further study the effects of this pooling in the ablation study (Sec~\ref{sec:ablation}).
By replacing the conventional \verb|class| token in ViT-Lite with SeqPool, Compact Vision Transformer is created. We use the same notations for this model: for instance, CVT-\textit{7}/\textbf{4} has \textit{7} transformer encoder layers, and a \textbf{4\texttimes4} patch size.

\subsection{Convolutional Tokenizer}
\label{sec:method-tokenizer}
In order to introduce an inductive bias into the model, we replace patch and embedding in ViT-Lite and CVT, with a simple convolutional block.
This block follows conventional design, which consists of a single convolution,  activation, and a max pool. Given an image or feature map :

where the  operation has  filters, same number as the embedding dimension of the transformer backbone.
Additionally, the convolution and max pool operations can be overlapping, which could increase performance by injecting inductive biases.
This allows our model to maintain locally spatial information.
Additionally, by using this convolutional block, the models enjoy an added flexibility over models like ViT, by no longer being tied to the input resolution strictly divisible by the pre-set patch size.
We seek to use convolutions to embed the image into a latent representation, because we believe that it will be more efficient and produce richer tokens for the transformer.
These blocks can be adjusted in terms of downsampling ratio (kernel size, stride and padding), and are repeatable for even further downsampling. Since self-attention has a quadratic time and space complexity with respect to the number of tokens, and number of tokens is equal to the resolution of the input feature map, more downsampling results in fewer tokens which noticeably decreases computation (at the expense of performance).
We found that on top of the added performance gains, this choice in tokenization also gives more flexibility toward removing the positional embedding in the model, as it manages to maintain a very good performance.
This is further discussed in Appendix~\ref{appdx:pe}.

This convolutional tokenizer, along with SeqPool and the transformer encoder create Compact Convolutional Transformers. We use a similar notation for CCT variants, with the exception of also denoting the number of convolutional layers: for instance, CCT-\textit{7}/\textbf{3}x\underline{2} has \textit{7} transformer encoder layers, and a \underline{2-layer} convolutional tokenizer with \textbf{3\texttimes3} kernel size.


\section{Experiments}
\label{sec:experiments}

\setlength{\tabcolsep}{6pt}
\begin{table*}[!ht]
    \begin{center}
        \caption{Top-1 validation accuracy comparisons.  variants were trained longer (see 
        Table~\ref{tab:extra_comparison}
        )}
        \label{tab:small_scale_comparison}
        \begin{tabular}{l|cccc|cr}
            \hline\noalign{\smallskip}
            \textbf{Model} & \textbf{C-10} & \textbf{C-100} & \textbf{Fashion} & \textbf{MNIST} & \textbf{\# Params} & \textbf{MACs}\\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \multicolumn{7}{l}{\textit{Convolutional Networks (Designed for ImageNet)}}\\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \textbf{ResNet18} &  &  &  &  &  M &  G \\
            \textbf{ResNet34} &  &  &  &  &  M &  G \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \textbf{MobileNetV2/0.5} &  &  &  &  &  M &  G \\
            \textbf{MobileNetV2/2.0} &  &  &  &  &  M &  G \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \multicolumn{7}{l}{\textit{Convolutional Networks (Designed for CIFAR)}}\\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \textbf{ResNet56\cite{he2016deep}} &  &  &  &  &  M &  G \\
            \textbf{ResNet110\cite{he2016deep}} &  &  &  &  &  M &  G \\
            \textbf{ResNet1k-v2\cite{he2016identity}} &  &  &  &  &  M &  G \\
            \textbf{Proxyless-G\cite{cai2018proxylessnas}} &  &  &  &  &  M &  \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \multicolumn{7}{l}{\textit{Vision Transformers}}\\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \textbf{ViT-12/16} &  &  &  &  &  M &  G \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \textbf{ViT-Lite-7/16} &  &  &  &  &  M &  G \\
            \textbf{ViT-Lite-7/8} &  &  &  &  &  M &  G \\
            \textbf{ViT-Lite-7/4} &  &  &  &  &  M &  G \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \multicolumn{7}{l}{\textit{Compact Vision Transformers}}\\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \textbf{CVT-7/8} &  &  &  &  &  M &  G \\
            \textbf{CVT-7/4} &  &  &  &  &  M &  G \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \multicolumn{7}{l}{\textit{Compact Convolutional Transformers}}\\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \textbf{CCT-2/3\texttimes2} &  &  &  &  &  M &  G \\
            \textbf{CCT-7/3\texttimes2} &  &  &  &  &  M &  G \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \textbf{CCT-7/3\texttimes1} &  &  &  &  &  M &  G \\
            \textbf{CCT-7/3\texttimes1} &  &  &  &  &  M &  G \\
            \hline
        \end{tabular}
    \end{center}
\end{table*} 
\setlength{\tabcolsep}{4pt}
\begin{table}[ht]
    \begin{center}
        \caption{\textbf{CCT-7/3\texttimes1} top-1 accuracy on CIFAR-10/100 when trained longer}
        \label{tab:extra_comparison}
        \begin{tabular}{l|c|cc}
            \hline\noalign{\smallskip}
            \textbf{\# Epochs} & \textbf{Pos. Emb.} & \textbf{CIFAR-10} & \textbf{CIFAR-100}\\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            300 & Learnable &  &  \\
            1500 & Sinusoidal &  &  \\
            5000 & Sinusoidal &  &  \\
            \hline
        \end{tabular}
    \end{center}
\end{table} 
\begin{figure}[ht]
\centering
\includegraphics[width=0.485\textwidth]{assets/images/cnn_comparison.pdf}
\caption{CIFAR-10 accuracy \vs{} model size (sizes M). CCT was trained longer.}
\label{fig:mobilenet_comparison}
\end{figure}

\setlength{\tabcolsep}{6pt}
\begin{table*}[ht]
    \begin{center}
        \caption{ImageNet Top-1 validation accuracy comparison
        (no extra data or pretraining).
        This shows that larger variants of CCT could also be applicable to medium-sized datasets
        }
        \label{tab:imagenet_comparison}
        \begin{tabular}{l|c|cc|c}
            \hline\noalign{\smallskip}
            \textbf{Model} & \textbf{Top-1} & \textbf{\# Params} & \textbf{MACs} & \textbf{Training Epochs}\\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \textbf{ResNet50 \cite{he2016deep}} &  &  M &  G &  \\
            \textbf{ResNet50 (2021) \cite{wightman2021resnet}} &  &  M &  G &  \\
            \textbf{ViT-S}~\cite{huang2020improving} &  &  M &  G &  \\
            \textbf{CCT-14/7\texttimes2} &  &  M &  G &  \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \textbf{DeiT-S}~\cite{huang2020improving} &  & M &  G &  \\
            \textbf{CCT-14/7\texttimes2 Distilled} &  &  M &  G &  \\
            \hline
        \end{tabular}
    \end{center}
\end{table*} 
\setlength{\tabcolsep}{6pt}
\begin{table*}[ht]
    \begin{center}
        \caption{Flowers-102 Top-1 validation accuracy comparison. CCT outperforms other competitive models, having significantly fewer parameters and GMACs. This demonstrates the compactness on small datasets even with large images}
        \label{tab:flowerscomparison}
        \begin{tabular}{l|cc|c|cc}
            \hline\noalign{\smallskip}
            \textbf{Model} & \textbf{Resolution} & \textbf{Pretraining} & \textbf{Top-1} & \textbf{\# Params} & \textbf{MACs}\\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \textbf{CCT-14/7\texttimes2} & 224 & - &  &  M &  G\\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \textbf{DeiT-B} & 384 & ImageNet-1k &  &  M &  G\\
            \textbf{ViT-L/16} & 384 & JFT-300M &  &  M &  G\\
            \textbf{ViT-H/14} & 384 & JFT-300M &  &  M &  G\\
            \textbf{CCT-14/7\texttimes2} & 384 & ImageNet-1k &  &  M &  G\\
            \hline
        \end{tabular}
    \end{center}
\end{table*} 
\subsection{Datasets}
We conducted image classification experiments using our method on the following datasets: CIFAR-10, CIFAR-100 (MIT License)~\cite{krizhevsky2009learning}, MNIST, Fashion-MNIST, Oxford Flowers-102~\cite{nilsback2008automated}, and ImageNet-1k~\cite{deng2009imagenet}. The first four datasets not only have a small number of training samples, but they are also small in resolution.
Additionally, MNIST and Fashion-MNIST only contain a single channel, greatly reducing the information density.
Flowers-102 has a relatively small number of samples, while having relatively higher resolution images and 102 classes.
We divided these datasets into three categories: small-scale small resolution datasets (CIFAR-10/100, MNIST, and Fashion-MNIST), small-scale larger resolution (Flowers-102), and medium-scale (ImageNet-1k) datasets.
We also include a study on NLP classification, presented in appendix \ref{appdx:nlp_exp}.

\subsection{Hyperparameters}
We used the timm package~\cite{rw2019timm} to train the models (see Appendix \ref{appdx:hyperparam} for details), except for cited works which are reported directly.
For all experiments, we conducted a hyperparameter sweep for every different method and report the best results we were able to achieve. We will release all checkpoints corresponding to the reported numbers, and detailed training settings in the form of YAML files, with our code. We also provide a report on hyperparamter settings in Appendix \ref{appdx:hyperparam}.
Unless stated otherwise, all tests were run for 300 epochs, and the learning rate is reduced per epoch based on cosine annealing~\cite{loshchilov2017sgdr}. All transformer based models (ViT-Lite, CVT, and CCT) were trained using the AdamW optimizer.


\subsection{Performance Comparison}
\textbf{Small-scale small resolution training:~} In order to demonstrate that vision transformers can be as effective as convolutional neural networks, even in settings with small sets of data, we compare our compact transformers to ResNets~\cite{he2016deep}, which are still very useful CNNs for small to medium amounts of data, as well as to MobileNetV2~\cite{sandler2018mobilenetv2}, which are very compact and small-sized CNNs. We also compare with results from~\cite{he2016identity} where He~\etal designed very deep (up to 1001 layers) CNNs specifically for CIFAR. The results are presented in Table \ref{tab:small_scale_comparison}, all of which are of models trained from scratch. We highlight the top performers. CCT-7/3x2 achieves on par results with the CNN models, while having significantly fewer parameters in some cases.
We also compare our method to the original ViT~\cite{dosovitskiy2020image} in order to express the effectiveness of smaller sized backbones, convolutional layers, as well our pooling technique. As these datasets were not trained from scratch in the original paper, we attempted to train the smallest variant: ViT-B/16 (ViT-12/16).
We trained our best performing model, CCT-7/3x1, for longer than the 300 epochs to see how far it can go. Surprisingly, this model can get as high as 98\% accuracy on CIFAR-10, and 82.87\% accuracy on CIFAR-100 when trained for 5000 epochs, which is still fewer iterations an ImageNet pre-training would have. We present results from training on CIFAR-10/100 for 300, 1500 and 5000 epochs in Table \ref{tab:extra_comparison}. We observed that sinusoidal positional embedding had a small but noticeable edge over learnable when training longer.
This represents the only transformer based model in the top 25 results on PapersWithCode for CIFAR-10 where models have no extra data or pre-training\footnote{https://paperswithcode.com/sota/image-classification-on-cifar-10}. In addition to this, it is also one of the smallest models, being 15\% the size of ResNet50 while maintaining similar performance. We present a plot of different models in Table~\ref{tab:small_scale_comparison} in Figure~\ref{fig:mobilenet_comparison}.

\textbf{Medium-scale training:~} ImageNet training results are presented in Table \ref{tab:imagenet_comparison}, and compared to ResNet50~\cite{he2016deep}, ViT, and DeiT. We report ResNet50 from the original paper~\cite{he2016deep}, as well as from Wightman~\etal~\cite{wightman2021resnet} which uses a similar training schedule to ours, and is therefore a fairer comparison. We also report a smaller ViT variant as proposed by Touvron~\etal~\cite{touvron2020training}. We also report CCT's performance with knowledge distillation, in order to compare it to DeiT~\cite{touvron2020training}. Similar to DeiT, we trained our CCT-14/7x2 with a convolutional teacher and hard distillation loss. We used a RegNetY-16GF~\cite{radosavovic2020designing} (84M parameters), the same model DeiT selected as the teacher. It is noticeable that distillation does not have as significant of an effect on CCT it does on DeiT. This can be attributed to the already existing inductive biases from the convolutional tokenizer. DeiT authors argued that a convolutional teacher would be able to transfer inductive biases to the student model.

\textbf{Small-scale higher-resolution training:~} We also present our results on Flowers-102, in which we successfully reach reasonable performance without any pre-training, and with the same model size as our ImageNet model. We also claim state of the art with \textbf{99.76\%} top-accuracy with ImageNet pretraining, which exceeds even far larger models pre-trained on JFT-300M.
In addition to this we note that our model is at least a quarter the size of the next best model and almost  smaller than ViT-H/14. It can also be seen that CCT is  more computationally efficient.

\subsection{Ablation Study}
\label{sec:ablation}
We extend our previous comparisons by doing an ablation study on our methods.
In this study, we progressively transform the original ViT into ViT-Lite, CVT, and CCT, and compare their top-1 accuracy scores. In this particular study, we report the results on CIFAR-10 and CIFAR-100 in Table \ref{tab:ablation_summary} in Appendix \ref{appdx:ablation}.



\section{Conclusion}
Transformers have commonly been perceived to be only applicable to larger-scale or medium-scale training.
While their scalability is undeniable, we have shown within this paper that with proper configuration, a transformer can be successfully used in  small data regimes as well, and outperform convolutional models of equivalent, and even larger, sizes.
Our method is simple, flexible in size, and the smallest of our variants can be easily loaded on even a minimal GPU, or even a CPU.
While part of research has been focused on large-scale models and datasets, we focus on smaller scales in which there is still much research to be done in data efficiency.
We show that CCT can outperform other transformer based models on small datasets while also having a significant reduction in computational costs and memory constraints.
This work demonstrates that transformers do not require vast computational resources and can allow for their applications in even the most modest of settings.
This type of research is important to many scientific domains where data is far more limited that the conventional machine learning datasets which are used in general research.
Continuing research in this direction will help open research up to more people and domains, extending machine learning research.

\bibliographystyle{ieee_fullname}
\bibliography{references}

\clearpage

\appendix

\begin{figure*}[ht!]
\centering
\begin{minipage}{.49\textwidth}
    \centering
    \includegraphics[width=0.98\textwidth]{assets/images/reduced_ds_training.pdf}
    \caption{Reduced \# samples / class (CIFAR-10)}
    \label{fig:redruns}
\end{minipage}
\begin{minipage}{.49\textwidth}
    \centering
    \includegraphics[width=0.98\textwidth]{assets/images/resolution_training.pdf}
    \caption{Image Size vs Accuracy (CIFAR-10)}
    \label{fig:sizeruns}
\end{minipage}
\end{figure*}

\section{Variants}
\label{appdx:model_variants}
Within this appendix, we present architectural details of our variants in Tables~\ref{tab:model_variants}~and~\ref{tab:patch_variants}.

\setlength{\tabcolsep}{4pt}
\begin{table}[htpb!]
    \begin{center}
        \caption{Transformer backbones in each variant.}
        \label{tab:model_variants}
        \begin{tabular}{l|cccc}
            \hline\noalign{\smallskip}
            \textbf{Model} & \textbf{\# Layers} & \textbf{\# Heads} & \textbf{Ratio} & \textbf{Dim} \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \textbf{ViT-Lite-6} & 6 & 4 & 2 & 256 \\
            \textbf{ViT-Lite-7} & 7 & 4 & 2 & 256 \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \textbf{CVT-6} & 6 & 4 & 2 & 256 \\
            \textbf{CVT-7} & 7 & 4 & 2 & 256 \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \textbf{CCT-2} & 2 & 2 & 1 & 128 \\
            \textbf{CCT-4} & 4 & 2 & 1 & 128 \\
            \textbf{CCT-6} & 6 & 4 & 2 & 256 \\
            \textbf{CCT-7} & 7 & 4 & 2 & 256 \\
            \textbf{CCT-14} & 14 & 6 & 3 & 384 \\
            \hline
        \end{tabular}
    \end{center}
\end{table}
\setlength{\tabcolsep}{4pt}
\begin{table}[htpb!]
    \begin{center}
        \caption{Tokenizers in each variant.}
        \label{tab:patch_variants}
        \begin{tabular}{l|cccc}
            \hline\noalign{\smallskip}
            \textbf{Model} & \textbf{\# Layers} & \textbf{\# Convs} & \textbf{Kernel} & \textbf{Stride} \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \textbf{ViT-Lite-7/8} & 7 & 1 & 8\texttimes8 & 8\texttimes8 \\
            \textbf{ViT-Lite-7/4} & 7 & 1 & 4\texttimes4 & 4\texttimes4 \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \textbf{CVT-7/8} & 7 & 1 & 8\texttimes8 & 8\texttimes8 \\
            \textbf{CVT-7/4} & 7 & 1 & 4\texttimes4 & 4\texttimes4 \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \textbf{CCT-2/3x2} & 2 & 2 & 3\texttimes3 & 1\texttimes1 \\
            \textbf{CCT-7/3x1} & 7 & 1 & 3\texttimes3 & 1\texttimes1 \\
            \textbf{CCT-7/7x2} & 7 & 2 & 7\texttimes7 & 2\texttimes2 \\
            \hline
        \end{tabular}
    \end{center}
\end{table}
 

\section{Computational Resources}
\label{appdx:resources}
For most experiments, we used a machine with an Intel(R) Core(TM) i9-9960X CPU @ 3.10GHz and 4 NVIDIA(R) RTX(TM) 2080Tis (11GB).
The exception was the CPU test which was performed with an AMD Ryzen 9 5900X.
Each ImageNet experiment was performed on a single machine either with 2 AMD EPYC(TM) 7662s and 8 NVIDIA(R) RTX(TM) A6000s (48GB), or 2 AMD EPYC(TM) 7713s and 8 NVIDIA(R) A100s (80GB).

\section{Additional analyses}
Within this appendix we present some additional performance analyses which were conducted.

\subsection{Positional Embedding}
\label{appdx:pe}
\setlength{\tabcolsep}{8pt}
\begin{table*}
    \begin{center}
        \caption{Top-1 validation accuracy comparison when changing the positional embedding method. Augmentations and training techniques such as Mixup and CutMix were turned off for these experiments to highlight differences better. The numbers reported are best out of 4 runs with random initializations.  denotes model trained with extra augmentation and hyperparameter tuning.}
        \label{tab:pe_comparison}
        \begin{tabular}{lc|cc}
            \hline\noalign{\smallskip}
            Model & PE & CIFAR-10 & CIFAR-100\\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \multicolumn{4}{l}{\textit{Conventional Vision Transformers are more dependent on Positional Embedding }}\\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            
            \multirow{3}{*}{ViT-12/16} & Learnable &  {\color{red}\small \textit{()}} &  {\color{red}\small \textit{()}} \\
            & Sinusoidal &  {\color{red}\small \textit{()}} &  {\color{blue}\small \textit{()}}\\
            & None &  {\color{black}(\small \textit{baseline)}} &  {\color{black}(\small \textit{baseline)}}\\
            
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            
            \multirow{3}{*}{ViT-Lite-7/8} & Learnable &  {\color{red}\small \textit{()}} &  {\color{red}\small \textit{()}} \\
            & Sinusoidal &  {\color{red}\small \textit{()}} &  {\color{red}\small \textit{()}} \\
            & None &  {\color{black}(\small \textit{baseline)}} &  {\color{black}(\small \textit{baseline)}} \\
            
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            
            \multirow{3}{*}{CVT-7/8} & Learnable &  {\color{red}\small \textit{()}} &  {\color{red}\small \textit{()}} \\
            & Sinusoidal &  {\color{red}\small \textit{()}} &  {\color{red}\small \textit{()}} \\
            & None &  {\color{black}(\small \textit{baseline)}} &  {\color{black}(\small \textit{baseline)}} \\
            
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \multicolumn{4}{l}{\textit{Compact Convolutional Transformers are less dependent on Positional Embedding }}\\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            
            \multirow{3}{*}{CCT-7/7} & Learnable &  {\color{red}\small \textit{()}} &  {\color{red}\small \textit{()}} \\
            & Sinusoidal &  {\color{blue}\small \textit{()}} &  {\color{red}\small \textit{()}} \\
            & None &  {\color{black}(\small \textit{baseline)}} &  {\color{black}(\small \textit{baseline)}} \\
            
            
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \multirow{3}{*}{CCT-7/3\texttimes2} & Learnable &  {\color{red}\small \textit{()}} &  {\color{red}\small \textit{()}} \\
            & Sinusoidal &  {\color{red}\small \textit{()}} &  {\color{red}\small \textit{()}} \\
            & None &  {\color{black}(\small \textit{baseline)}} &  {\color{black}(\small \textit{baseline)}} \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \multirow{3}{*}{CCT-7/3\texttimes2} & Learnable &  {\color{red}\small \textit{()}} &  {\color{red}\small \textit{()}} \\
            & Sinusoidal &  {\color{red}\small \textit{()}} &  {\color{red}\small \textit{()}} \\
            & None &  {\color{black}(\small \textit{baseline)}} &  {\color{black}(\small \textit{baseline)}} \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \multirow{3}{*}{CCT-7/3\texttimes1} & Learnable &  {\color{red}\small \textit{()}} &  {\color{red}\small \textit{()}} \\
            & Sinusoidal &  {\color{red}\small \textit{()}} &  {\color{blue}\small \textit{()}} \\
            & None &  {\color{black}(\small \textit{baseline)}} &  {\color{black}(\small \textit{baseline)}} \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            
            \multirow{3}{*}{CCT-7/7\texttimes1-noSeqPool} & Learnable &  {\color{red}\small \textit{()}} &  {\color{red}\small \textit{()}} \\
            & Sinusoidal &  {\color{blue}\small \textit{()}} &  {\color{red}\small \textit{()}} \\
            & None &  {\color{black}(\small \textit{baseline)}} &  {\color{black}(\small \textit{baseline)}} \\
            
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            
            \multirow{3}{*}{CCT-7/3\texttimes2-noSeqPool} & Learnable &  {\color{red}\small \textit{()}} &  {\color{red}\small \textit{()}} \\
            & Sinusoidal &  {\color{red}\small \textit{()}} &  {\color{blue}\small \textit{()}} \\
            & None &  {\color{black}(\small \textit{baseline)}} &  {\color{black}(\small \textit{baseline)}} \\
            \hline
        \end{tabular}
    \end{center}
\end{table*}
 
To determine the effects of our small \& compact design, sequence pooling, and convolutional tokenizer, we perform an ablation study focused on positional embedding, seen in Table~\ref{tab:pe_comparison}.
In this study, we experiment with ViT (original sizing), ViT-Lite, CVT, and CCT, and investigate the effects of: a learnable positional embedding, a standard sinusoidal embedding, as well as no positional embedding.
We finish the table with our best model, which also has augmented training and an optimal tuning (refer to Appendix \ref{appdx:hyperparam}).
In these experiments, we find that positional encoding matters in all variants, but to varying degrees. In particular, CCT relies less on positional encoding, and it can be safely removed much impact in accuracy.
We also tested our CCT model without SeqPool, using the standard \verb|[class]| token instead, and found that there was little to no effect from having a positional encoder or not, depending on model size.
This suggests that convolutions are what helps provide spatially sparse information to the transformer, while also helping the model overcome some of the previous limitations, allowing for more efficient use of data.
We do find that SeqPool helps slightly in this respect, but overall has a larger effect on increasing total accuracy.
Lastly, we find that with proper data augmentation and tuning, the overall performance can be increased, and a low dependence on positional information can be maintained.


\subsection{Performance vs Dataset Size}
\label{appdx:performance-vs-dataset}

In this experiment, we evaluated model performance on smaller subsets of CIFAR-10 to determine the relationship between performance and the number of samples within a dataset.
Samples were removed uniformly from each class in CIFAR-10. For this experiment, we compared ViT-Lite and CCT.
In Figure~\ref{fig:redruns}, we see the comparison of each model's accuracy vs the number of samples per class.
We show how each model performs when given only 500, 1000, 2000, 3000, 4000, or 5000 (original) samples per class, meaning the total training set ranges from one tenth the size to full.
It can be ovserved that CCT is more robust since it is able to obtain higher accuracy with a lower number of samples per class, especially in the low sample regime.

\subsection{Performance vs Dimensionality}
\label{appdx:performance-vs-dimensionality}
In order to determine whether transformers are dependant on high dimensional data, as opposed to the number of samples (explored in Appendix~\ref{appdx:performance-vs-dataset}), we experimented with downsampled and upsampled versions of CIFAR-10.
In Figure~\ref{fig:sizeruns}, we present the image dimensionality vs the performance of CCT \vs ViT-Lite. Both models were trained with images of sizes ranging from 16\texttimes16 to 64\texttimes64.
It can be observed that CCT performs better on all image sizes, with a widening difference as the number of pixels increases.
From this, it can be inferred that CCT is able to better utilize the information density of an image, while ViT does not see continued performance increases after the standard 32x32 size.

\section{Dimensionality Experiments}
\label{appdx:dimensionality}
Within this appendix, we extend the analysis from Appendix~\ref{appdx:performance-vs-dimensionality}, showing the difference in performance when using different types of positional embedding. Figure~\ref{fig:sizeruns_training} shows the difference of the accuracy when models are being trained from scratch. On the other hand, Figure~\ref{fig:sizeruns_inference} shows the performance difference when models are only used in inference and pre-trained on the 32\texttimes32 sized images. We note that in Figure~\ref{fig:sizeruns_inference}(a) that we do not provide inference for image sizes greater than the pre-trained image because the learnable positional embeddings do not allow us to extend in this direction.
We draw the reader's attention to Figure~\ref{fig:sizeruns_training}(c) and Figure~\ref{fig:sizeruns_inference}(c) to denote the large difference between the models when positional embedding is not used.
We can see that in training CCT has very little difference when positional embeddings are used.
Additionally, it should be noted that when performing inference our non-positional embedding CCT model has much higher generalizability than its ViT-Lite counterpart.


\begin{figure}[h!]
     \centering
     \begin{subfigure}[b]{0.42\textwidth}
         \centering
         \includegraphics[width=\textwidth]{assets/images/resolution_training.pdf}
         \caption{Learnable PEs}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{0.42\textwidth}
         \centering
         \includegraphics[width=\textwidth]{assets/images/resolution_training_sine.pdf}
         \caption{Sinusoidal Positional Embedding}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{0.42\textwidth}
         \centering
         \includegraphics[width=\textwidth]{assets/images/resolution_training_nope.pdf}
         \caption{No Positional Embedding}
     \end{subfigure}
    \caption{CIFAR-10 resolution vs top-1\% validation accuracy (training from scratch). Images are square.}
    \label{fig:sizeruns_training}
\end{figure}

\begin{figure}[h!]
     \centering
     \begin{subfigure}[b]{0.42\textwidth}
         \centering
         \includegraphics[width=\textwidth]{assets/images/resolution_inference.pdf}
         \caption{Learnable PEs (only possible up to 32x32 without changing weights)}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{0.42\textwidth}
         \centering
         \includegraphics[width=\textwidth]{assets/images/resolution_inference_sine.pdf}
         \caption{Sinusoidal PEs}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{0.42\textwidth}
         \centering
         \includegraphics[width=\textwidth]{assets/images/resolution_inference_nope.pdf}
         \caption{None}
     \end{subfigure}
    \caption{CIFAR-10 resolution vs top-1\% validation accuracy (inference only). Images are square.}
    \label{fig:sizeruns_inference}
\end{figure}

\section{Hyperparameter tuning}
\label{appdx:hyperparam}
We used the timm package~\cite{rw2019timm} for our experiments (excluding NLP experiments).
We also sued CutMix \cite{yun2019cutmix}, Mixup \cite{zhang2017mixup}, Randaugment \cite{cubuk2020randaugment}, and Random Erasing \cite{zhong2020random}.
For our small-scale small-resolution experiments, we conducted a hyperparameter sweep for each model on each dataset separately.
However, all experiments that trained models from scratch, were trained for 300 epochs, unless mentioned otherwise. ViT, CVT and CCT all used the weighted Adam optimizer ( and ). For CNNs, we observed that some models and datasets achieved their best results using AdamW, while most others performed best with SGD with momentum ().
We will release model checkpoints (PyTorch pickle files), as well as a full list of hyperparameters and training settings (in the form of YAML files readable by \verb|timm|) along with our code for reproduction.


\section{Ablation Study}
\label{appdx:ablation}
Here in Table~\ref{tab:ablation_summary} we present the results from section~\ref{sec:ablation}.
We provide a full list of ablated terms showing which factors give the largest boost in performances.
``Model'' column refers to variant (see Table \ref{tab:model_variants} for details), ``Conv'' specifies the number of convolutional blocks (if an), and ``Conv Size'' specifies the kernel size.
``Aug'' denotes the use of AutoAugment~\cite{cubuk2019autoaugment}.
``Tuning'' specifies a minor change in dropout, attention dropout, and/or stochastic depth (see Table \ref{tab:tuned_comparison}).
The first row in Table~\ref{tab:ablation_summary} is essentially ViT.
The next three rows are modified variants of ViT, which are not proposed in the original paper. These variants are more compact and use smaller patch sizes.
It should be noted that the numbers reported in this table are best out of 4.

\setlength{\tabcolsep}{6pt}
\begin{table*}[htb]
    \begin{center}
        \caption{CIFAR Top-1 validation accuracy when transforming ViT into CCT step by step. We disabled advanced training techniques and augmentations for these runs.}
        \label{tab:ablation_summary}
        \begin{tabular}{lccccc|cc|cc}
            \hline\noalign{\smallskip}
            Model & CLS & \# Conv & Conv Size & Aug & Tuning & C-10 & C-100 & \# Params & MACs\\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            ViT-12/16 & CT & \xmark & \xmark & \xmark & \xmark &  &  &  M &  G \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            ViT-Lite-7/16 & CT & \xmark & \xmark & \xmark & \xmark &  &  &  M &  G \\
            ViT-Lite-7/8 & CT & \xmark & \xmark & \xmark & \xmark &  &  &  M &  G \\
            ViT-Lite-7/4 & CT & \xmark & \xmark & \xmark & \xmark &  &  &  M &  G \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            CVT-7/16 & SP & \xmark & \xmark & \xmark & \xmark &  &  &  M &  G \\
            CVT-7/8 & SP & \xmark & \xmark & \xmark & \xmark &  &  &  M &  G \\
            CVT-7/8 & SP & \xmark & \xmark & \cmark & \xmark &  &  &  M &  G \\
            CVT-7/4 & SP & \xmark & \xmark & \xmark & \xmark &  &  &  M &  G \\
            CVT-7/4 & SP & \xmark & \xmark & \cmark & \xmark &  &  &  M &  G \\
            CVT-7/4 & SP & \xmark & \xmark & \cmark & \cmark &  &  &  M &  G \\
            CVT-7/2 & SP & \xmark & \xmark & \xmark & \xmark &  &  &  M &  G \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            CCT-7/7\texttimes1 & SP & 1 &  & \xmark & \xmark &  &  &  M &  G \\
            CCT-7/7\texttimes1 & SP & 1 &  & \cmark & \xmark &  &  &  M &  G \\
            CCT-7/7\texttimes1 & SP & 1 &  & \cmark & \cmark &  &  &  M &  G \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            CCT-7/3\texttimes2 & SP & 2 &  & \cmark & \cmark &  &  &  M &  G \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            CCT-7/3\texttimes1 & SP & 1 &  & \cmark & \cmark &  &  &  M &  G \\
            \hline
        \end{tabular}
    \end{center}
\end{table*} 
\setlength{\tabcolsep}{4pt}
\begin{table}[ht]
    \begin{center}
        \caption{Difference between \textbf{tuned} and not tuned runs in Table \ref{tab:ablation_summary}.}
        \label{tab:tuned_comparison}
        \begin{tabular}{c|cc}
            \hline\noalign{\smallskip}
            \textbf{Hyper Param} & \textbf{Not Tuned} & \textbf{Tuned} \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \textbf{MLP Dropout} & 0.1 & 0 \\
            \textbf{MSA Dropout} & 0 & 0.1 \\
            \textbf{Stochastic Depth} & 0 & 0.1 \\
            \hline
        \end{tabular}
    \end{center}
\end{table}

 


\section{NLP experiments}
\label{appdx:nlp_exp}

To demonstrate the general purpose nature of our model we extended it to the domain of Natural Language Processing, focusing on classification tasks.
This shows that our model is a general purpose classifier and is not restricted to the domain of image classification.
Within this section, we present our text classification results on 5 datasets: AGNews \cite{zhang2015character}, TREC \cite{liroth2002learning}, SST \cite{socher2013recursive}, IMDb \cite{maas2011learning}, DBpedia \cite{auer2007dbpedia}.
The results are summarized in Table \ref{tab:nlp_results}.
As can be seen, our model outperforms the vanilla transformer, demonstrating that the techniques we use here also help with NLP tasks.
The network is slightly modified from the vision CCT.
We use GloVe (Apache License 2.0) \cite{pennington2014glove} to provide the word embedding for the model, and do not train these parameters.
Note that model sizes do not reflect the number of parameters for GloVe, which is around 20M.
We treat text as single channel data and the embedding dimension as size 300.
Additionally, the convolution kernels have size 1.
Finally, we include masking in the typical manner.
By doing so, CCT can get upwards of a 3\% improvement on some datasets while using less parameters than vanilla transformers.
Similar to our vision results, we find that CCT performs well on small NLP datasets.
We note that the CCT models that perform best all have less than 1M parameters, which are significantly smaller than there vanilla counterparts, while out performing them.

\section{Additional experiments}

\subsection{Extended small-scale experiments}
We present the extended version of Table~\ref{tab:small_scale_comparison} here with additional models in Table~\ref{tab:small_scale_comparison_full}.

\setlength{\tabcolsep}{8pt}
\begin{table*}[!ht]
    \begin{center}
        \caption{Top-1 validation accuracy on text classification datasets. The number of parameters does not include the word embedding layer, because we use pretrained word-embeddings and freeze those layers while training.}
        \label{tab:nlp_results}
        \begin{tabular}{l|ccccc|r}
            \hline\noalign{\smallskip}
            \textbf{Model} & \textbf{AGNews} & \textbf{TREC} & \textbf{SST} & \textbf{IMDb} & \textbf{DBpedia} & \textbf{\# Params} \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \multicolumn{7}{l}{\textit{Vanilla Transformer Encoders}}\\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \textbf{Transformer-2} &   &   &   &   &   &  M \\
            \textbf{Transformer-4} &   &   &   &   &   &  M \\
            \textbf{Transformer-6} &   &   &   &   &   &  M \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \multicolumn{7}{l}{\textit{Vision Transformers}}\\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \textbf{ViT-Lite-2/1} &   &   &   &   &   &  M \\
            \textbf{ViT-Lite-2/2} &   &   &   &   &   &  M \\
            \textbf{ViT-Lite-2/4} &   &   &   &   &   &  M \\
            \textbf{ViT-Lite-4/1} &   &   &   &   &   &  M \\
            \textbf{ViT-Lite-4/2} &   &   &   &   &   &  M \\
            \textbf{ViT-Lite-4/4} &   &   &   &   &   &  M \\
            \textbf{ViT-Lite-6/1} &   &   &   &   &   &  M \\
            \textbf{ViT-Lite-6/2} &   &   &   &   &   &  M \\
            \textbf{ViT-Lite-6/4} &   &   &   &   &   &  M \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \multicolumn{7}{l}{\textit{Compact Vision Transformers}}\\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \textbf{CVT-2/1} &   &   &   &   &   &  M \\
            \textbf{CVT-2/2} &   &   &   &   &   &  M \\
            \textbf{CVT-2/4} &   &   &   &   &   &  M \\
            \textbf{CVT-4/1} &   &   &   &   &   &  M \\
            \textbf{CVT-4/2} &   &   &   &   &   &  M \\
            \textbf{CVT-4/4} &   &   &   &   &   &  M \\
            \textbf{CVT-6/1} &   &   &   &   &   &  M \\
            \textbf{CVT-6/2} &   &   &   &   &   &  M \\
            \textbf{CVT-6/4} &   &   &   &   &   &  M \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \multicolumn{7}{l}{\textit{Compact Convolutional Transformers}}\\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \textbf{CCT-2/1x1} &   &   &  &   &   &  M \\
            \textbf{CCT-2/2x1} &   &   &   &  &   &  M \\
            \textbf{CCT-2/4x1} &  &   &   &   &   &  M \\
            \textbf{CCT-4/1x1} &   &   &   & \%  & \%  &  M \\
            \textbf{CCT-4/2x1} &   &  &   &  &  &  M \\
            \textbf{CCT-4/4x1} &   &   &   &   &   &  M \\
            \textbf{CCT-6/1x1} &   &   &   &   &   &  M \\
            \textbf{CCT-6/2x1} &   &   &   &   &   &  M \\
            \textbf{CCT-6/4x1} &   &   &   &   &   &  M \\
            \hline
    \end{tabular}
    \end{center}
\end{table*}
 
\setlength{\tabcolsep}{6pt}
\begin{table*}[!ht]
    \begin{center}
        \caption{Top-1 comparisons.  were trained longer (see Tab \ref{tab:extra_comparison}).}
        \label{tab:small_scale_comparison_full}
        \begin{tabular}{l|cccc|cr}
            \hline\noalign{\smallskip}
            \textbf{Model} & \textbf{C-10} & \textbf{C-100} & \textbf{Fashion} & \textbf{MNIST} & \textbf{\# Params} & \textbf{MACs}\\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \multicolumn{7}{l}{\textit{Convolutional Networks (Designed for ImageNet)}}\\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \textbf{ResNet18} &  &  &  &  &  M &  G \\
            \textbf{ResNet34} &  &  &  &  &  M &  G \\
            \textbf{ResNet50} &  &  &  &  &  M &  G \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \textbf{MobileNetV2/0.5} &  &  &  &  &  M &  G \\
            \textbf{MobileNetV2/1.0} &  &  &  &  &  M &  G \\
            \textbf{MobileNetV2/1.25} &  &  &  &  &  M &  G \\
            \textbf{MobileNetV2/2.0} &  &  &  &  &  M &  G \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \multicolumn{7}{l}{\textit{Convolutional Networks (Designed for CIFAR)}}\\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \textbf{ResNet56\cite{he2016deep}} &  &  &  &  &  M &  G \\
            \textbf{ResNet110\cite{he2016deep}} &  &  &  &  &  M &  G \\
            \textbf{ResNet164-v1\cite{he2016identity}} &  &  &  &  &  M &  G \\
            \textbf{ResNet164-v2\cite{he2016identity}} &  &  &  &  &  M &  G \\
            \textbf{ResNet1k-v1\cite{he2016identity}} &  &  &  &  &  M &  G \\
            \textbf{ResNet1k-v2\cite{he2016identity}} &  &  &  &  &  M &  G \\
            \textbf{ResNet1k-v2\cite{he2016identity}} &  &  &  &  &  M &  G \\
            \textbf{Proxyless-G\cite{cai2018proxylessnas}} &  &  &  &  &  M &  \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \multicolumn{7}{l}{\textit{Vision Transformers}}\\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \textbf{ViT-12/16} &  &  &  &  &  M &  G \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \textbf{ViT-Lite-7/16} &  &  &  &  &  M &  G \\
            \textbf{ViT-Lite-6/16} &  &  &  &  &  M &  G \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \textbf{ViT-Lite-7/8} &  &  &  &  &  M &  G \\
            \textbf{ViT-Lite-6/8} &  &  &  &  &  M &  G \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \textbf{ViT-Lite-7/4} &  &  &  &  &  M &  G \\
            \textbf{ViT-Lite-6/4} &  &  &  &  &  M &  G \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \multicolumn{7}{l}{\textit{Compact Vision Transformers}}\\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \textbf{CVT-7/8} &  &  &  &  &  M &  G \\
            \textbf{CVT-6/8} &  &  &  &  &  M &  G \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \textbf{CVT-7/4} &  &  &  &  &  M &  G \\
            \textbf{CVT-6/4} &  &  &  &  &  M &  G \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \multicolumn{7}{l}{\textit{Compact Convolutional Transformers}}\\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \textbf{CCT-2/3\texttimes2} &  &  &  &  &  M &  G \\
            \textbf{CCT-4/3\texttimes2} &  &  &  &  &  M &  G \\
            \textbf{CCT-6/3\texttimes2} &  &  &  &  &  M &  G \\
            \textbf{CCT-7/3\texttimes2} &  &  &  &  &  M &  G \\
            \noalign{\smallskip}
            \hline
            \noalign{\smallskip}
            \textbf{CCT-6/3\texttimes1} &  &  &  &  &  M &  G \\
            \textbf{CCT-7/3\texttimes1} &  &  &  &  &  M &  G \\
            \textbf{CCT-7/3\texttimes1} &  &  &  &  &  M &  G \\
            \hline
        \end{tabular}
    \end{center}
\end{table*} 


\end{document}
