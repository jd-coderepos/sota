\documentclass[11pt]{article}  


\usepackage{fullpage}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage{boxedminipage}
\usepackage{xy}
\xyoption{all}

\newtheorem{theorem}{\bf Theorem}[section]
\newtheorem{corollary}[theorem]{\bf Corollary}
\newtheorem{lemma}[theorem]{\bf Lemma}
\newtheorem{fact}[theorem]{\bf Fact}
\newtheorem{definition}[theorem]{\bf Definition}
\newtheorem{proposition}[theorem]{\bf Proposition}
\newtheorem{claim}[theorem]{\bf Claim}
\newtheorem{observation}[theorem]{\bf Observation}

\newcommand {\myproof} {{\it Proof: }}
\newcommand {\myproofsketch} {{\it Proof Sketch: }}
\newcommand{\qed} {\hfill}

\newcommand{\eat}[1] {}
\newcommand{\proof} {{\it Proof: }}
\newcommand{\calP} {{\cal P}}
\newcommand{\calA} {{\cal A}}
\newcommand{\calE} {{\cal E}}
\newcommand{\calT} {{\cal T}}
\newcommand{\calH} {{\cal H}}
\newcommand{\calD} {{\cal D}}
\newcommand{\Acc} {{\rm Acc}}
\newcommand{\Inst} {{\rm Inst}}
\newcommand{\wh}[1] {\widehat{#1}}
\newcommand{\wt}[1] {\widetilde{#1}}
\newcommand{\Opt} {{\tt Opt}}
\newcommand{\LCA} {{\rm LCA}}
\newcommand{\mypath} {{\rm path}}
\newcommand{\val} {{\rm val}}
\newcommand{\mypred} {{\rm pred}}
\newcommand{\mysucc} {{\rm succ}}
\newcommand{\TMIS} {{\rm Time(MIS)}}
\newcommand{\pair}[2] {\langle #1,#2 \rangle}
\newcommand{\BuildBTD} {{\tt BuildBalTD}}
\newcommand{\BuildITD} {{\tt BuildIdealTD}}
\newcommand{\ceil}[1] {\lceil #1 \rceil}
\newcommand{\floor}[1] {\lfloor #1 \rfloor}
\newcommand{\rt} {{\rm rt}}
\newcommand{\dl} {{\rm dl}}
\newcommand{\len} {{\rm len}}
\newcommand{\depth} {{\rm depth}}
\newcommand{\mymid} {{\rm mid}}
\newcommand{\hmin} {h_{\min}}

\title{Distributed Algorithms for Scheduling on Line and Tree Networks} 
\author{
Venkatesan T. Chakaravarthy \and Sambuddha Roy \and Yogish Sabharwal
}
\date{IBM Research Lab, New Delhi, India\\
\{vechakra,sambuddha,ysabharwal\}@in.ibm.com
}

\begin{document}

\maketitle              

\begin{abstract}
We have a set of processors (or agents) and a set of graph networks defined over some vertex set.
Each processor can access a subset of the graph networks.
Each processor has a demand specified as a pair of vertices , along with a profit; 
the processor wishes to send data between  and .
Towards that goal, the processor needs to select a graph network accessible to it
and a path connecting  and  within the selected network.
The processor requires exclusive access to the chosen path, in order to route the data.
Thus, the processors are competing for routes/channels.
A feasible solution selects a subset of demands and schedules each selected demand
on a graph network accessible to the processor owning the demand; the solution also 
specifies the paths to use for this purpose.
The requirement is that for any two demands scheduled on the same graph network,
their chosen paths must be edge disjoint.
The goal is to output a solution having the maximum aggregate profit.
Prior work has addressed the above problem in a distibuted setting
for the special case where all the graph networks are simply paths (i.e, line-networks).
Distributed constant factor approximation algorithms are known for this case.

The main contributions of this paper are twofold. 
First we design a distributed constant factor approximation algorithm for the more general case of tree-networks.
The core component of our algorithm is a tree-decomposition technique, which may be of independent interest.
Secondly, for the case of line-networks, we improve the known approximation guarantees by a factor of .
Our algorithms can also handle the capacitated scenario, wherein the demands and edges have bandwidth requirements
and capacities, respectively.
\end{abstract}


\section{Introduction}
Consider the following fundamental scheduling/routing problem.
We have a set  consisting of  points or vertices.
A set of  undirected graphs provide communication networks over these vertices.
All the edges in the graphs provide a uniform bandwidth, say  unit.
There are  processors (or agents) each having access to a subset of the communication networks.
Each processor  has a demand/job  specified as a pair of vertices  and ,
and a bandwidth requirement (or {\em height}) .
The processor  wishes to send data between  and ,
and for this purpose, the processor can use any of the networks  accessible to it.
To send data over a network , the processor  
requires a bandwidth of  along some path (or route) connecting the pair of vertices 
 and  in . The input specifies a profit for each demand.
A feasible solution is to select a subset of demands and schedule each selected demand on some graph-network.
For each selected demand  scheduled on a graph-network ,
the feasible solution must also specify which path connecting  and  must be used for transmission.
The following conditions must be satisfied:
(i) {\em Accessibility requirement: }If a demand  owned by a processor 
is scheduled on a graph-network , then  should be able to access ;
(ii) {\em Bandwidth requirement: }For any network  and for any edge  in , 
the sum of bandwidth requirements of selected demands that use the edge  must not exceed  unit 
(the bandwidth offered by the edge).
We call this the {\em throughput maximization problem}\footnote{The generalization in which the bandwidths offered by edges can vary has also been studied.
For the case where there is only one graph, this is known as the {\em unsplittable flow problem} (UFP),
which has been well-studied (see survey \cite{UFPSurvey}). 
In this paper, we shall only consider the case where the bandwidth offered by all the edges are uniform, say  unit}.
We shall refer to the special case of the problem wherein the heights of all demands is  unit 
as the {\em unit height case}.
In this case, we see that the paths of any two demands scheduled on the same network should be edge disjoint. 
The general case wherein the heights can be arbitrary will be referred
to as the {\em arbitrary height case}.


It is known that the throughput maximization problem is 
NP-hard to approximate within a factor of , even for the unit height case of a 
single graph-network \cite{EDP-Hardness}.
Constant factor approximations are known for special cases of the throughput maximization problem (c.f. \cite{AmitKumar}).
Our goal in this paper is to study the problem in a distributed setting.
Prior work has addressed the problem in a distributed setting for the special case of line networks.
In our paper, we present distributed algorithms for the more general case of tree networks
and also improve the known approximation ratios for the case of line networks.
We first discuss the concept of line networks and summarize the known sequential and distributed algorithms
for this case. \\

\noindent
{\bf Line-Networks:} A {\em line-network} refers to a graph which is simply a path.
Consider the special case of the throughput maximization problem
wherein all the graph-networks are identical paths; say the path is .
We can reformulate this special case by viewing the path as a timeline.
We visualize each edge  as a timeslot so that the number of timeslots
is , say numbered ; then the timeline consisting of these
timeslots becomes a range .
Each demand pair  can be represented by the timeslots 
and can be viewed as a interval . 
Thus, each demand can be assumed to be specified as an interval ,
where  and  are the starting and ending timeslots.
Each graph network can be viewed as a resource offering a uniform bandwidth of  unit
throughout the timeline. We see that a feasible solution selects a set of 
demands and schedules each demand on a resource accessible to the processor owning
the demand such that for any resource and any timeslot, 
the sum of heights of the demands scheduled on the resource and active at the timeslot
does not exceed  unit. The goal is to choose a subset of demands with the maximum throughput.
See Figure \ref{fig:1} for an illustration.

\begin{figure}
\centering
\includegraphics[width=4.5in]{fig1.eps}
\caption{Illustration for the problem on line-networks. 
The bandwidth/capacity offered by the resource is  unit throughout the timeline. 
The sets of demands  and  can be scheduled
on the resource, but both  and  cannot be scheduled on the same resource.
}
\label{fig:1}
\end{figure}

In natural applications, a demand may specify a {\em window} 
 (release time and deadline) where it can be executed and a processing time .
The job can be executed on any time segment of length  contained within the window.
The rest of the problem description remains the same as above.
In the new setup, apart from selecting a set of demands and determining the resources where they must be executed,
a feasible solution must also choose a execution segment for each selected demand.
As before, the accessibility and the bandwidth constraints must be satisfied.
The goal is to find a feasible solution having maximum profit.

The throughput maximization problem on line-networks 
has been well-studied in the realm of classical, sequential computation. 
For the arbitrary height case, Bar-Noy et al. \cite{Bar-Noy-Jacm} presented a -approximation algorithm.
For the unit height case, Bar-Noy et al. \cite{Bar-Noy-Jacm}, and independently Berman and Dasgupta \cite{BermanDasgupta}
presented -approximation algorithms; both these algorithms can also handle the notion of windows.
Generalizations and special cases of the problem have also been studied\footnote{
For the case where there is only one line-network and there are no windows,
improved approximations are known \cite{Bar-Noy-Jacm,Calinescu}.
The UFP problem on line-networks (where the bandwidth offered varies over the timeline)
has also been well studied (see \cite{Bansal1,Bansal2,our-ipdps,AmitKumar,ChekuriUFP})
and a constant factor approximation algorithm is known \cite{Bonsma}.
}.

Panconesi and Sozio \cite{Pancc,Pancj} studied the throughput maximization problem on line-networks 
in a distributed setting. In this setup, two processors can communicate with each other, 
if they have access to some common resource.
We shall assume the standard synchronous, message passing model of computation:
in a given network of processors, each processor can communicate in one step with all
other processors it is directly connected to. The running time of the algorithm is given
by the number of communication rounds. This model is universally used in the context
of distributed graph algorithms. We require that the local computation at any processor
takes only polynomial time. To be efficient, we require the communication rounds
to be polylogarithmic in the input size. 
We can construct a communication graph taking the processors to be the vertices
and drawing an edge between two processors, if they can communicate (i.e., they share a common resource).
Notice that the diameter of the communication graph can be as large
as the number of processors . 
So, there may be a pair of processors such that the path connecting them has a large number of hops (or edges).
Hence, within the stipulated polylogarithmic number of rounds, it would be infeasible to
send information between such a pair of processors.
The above fact makes it challenging to design distributed algorithms with polylogarithmic number of rounds.

Under the above model, Panconesi and Sozio \cite{Pancj} designed distributed approximation
algorithms for the throughput maximization problem on line networks.
For the case of unit height demands, they presented an algorithm with an approximation ratio of 
(throughout the paper,  is a constant fixed arbitrarily).
For the general arbitrary height case, they devised an algorithm with an approximation ratio of .
Both the above algorithms can also handle the notion of windows.
The number of communication rounds of these algorithms is:
.
Here,  and  are the maximum and minimum length of any demand,
and  and  are the maximum and minimum profit of any demand.
The value  is the minimum height of any demand (recall that all demand heights are at most  unit);
in the case of unit height demands, .
The value  is the number of rounds needed for computing a maximal independent set (MIS) in general graphs.
The randomized algorithm of Luby \cite{Luby} can compute MIS in  rounds,
where  (,  and  are the number of timeslots, demands and resources, respectively);
if this algorithm is used, then the overall distributed algorithm would also be randomized.
Alternatively, via network-decompositions, \cite{PancSrini} present a deterministic algorithm 
with .\\

\noindent
{\bf Our Contributions: }In this paper, we make two important contributions. 
The first is that we provide improved approximation ratios
for the throughput maximization problems on line-networks addressed by Panconesi and Sozio \cite{Pancj}. 
Secondly, we present distributed approximation algorithms for the more general case of tree-networks.
A {\em tree-network} refers to a graph which is a tree. 
Notice that in a tree, the path between a pair of vertices  and  is unique
and so, it suffices if the feasible solution schedules each selected demand on a tree-network
and the paths will be determined uniquely (see Figure \ref{fig:2}).

\begin{figure}[t]
\centering
\includegraphics[width=4.5in]{fig2.eps}
\caption{
Tree-Networks: There are three demands ,  and .
In the unit height case, only one of the three demands can be scheduled on the given tree-network
(because they all share the edge ).
To illustrate the arbitrary height case, suppose their heights are ,  and , respectively.
Then, the first and third demand can be scheduled together.
}
\label{fig:2}
\end{figure}

Prior work has addressed the throughput maximization problem for the scenario where
the input consists of a single tree-network (and all processors have access to the sole tree-network).
Under this setup, Tarjan showed that the unit height case can be solved in polynomial time \cite{Tarjan}.
Lewin-Eytan et al. \cite{Lewin-Eytan} presented a -approximation algorithm for the arbitrary height case.
In the setting of multiple tree-networks, the problem is NP-hard even for the unit height case.
By extending the algorithm of Lewin-Eytan et al., we can show that the problem 
can be approximated within a factor of  and , for the unit height and arbitrary height cases, respectively.

One of the main goals of the current paper is to design distributed algorithms
for the throughput maximization problems on tree-networks. 
Our main result is:
\begin{quote}
{\bf Main result}: We present a distributed -approximation algorithm for the unit height case of the 
throughput maximization problem on tree-networks. 
\end{quote}
The number of communication rounds is polylogarithmic in the input size:
.
Here,  is the number of vertices;
 and  are the maximum and minimum profits.
 is the number of rounds taken for computing MIS in arbitrary graphs with  vertices,
where  ( is the number of processors/demands and  is the number of input tree-networks).
As in the work of Panconesi and Sozio \cite{Pancj}, the size of each message is
 where  is the number of bits needed for encoding the information about a demand 
(such as its profit, end-points and height).

Recall that Panconesi and Sozio \cite{Pancj} presented a 
distributed -approximation algorithm for the unit height case of the line-networks problem. 
The main result provides improvements over the above work along two dimensions:
the new algorithm can handle the more general concept of tree-networks and simultaneously, it
offers an improved approximation ratio. 

Extending the main result, we design a distributed -approximation algorithm for  the
arbitrary height case of the tree-networks problem
The number of communication rounds taken by this algorithm is
.
This algorithm assumes that the value  is known to all the processors.
Alternatively, we assume that a value  is fixed a priori
and all the demands are required to have height at least .

Next, we provide a improved approximation ratios
for the case of line-networks with windows. We design distributed algorithms
with approximation ratios  and , for the unit height case
and arbitrary height case, respectively
\footnote{The conference version of the paper \cite{podc} claimed approximation ratios of 
and  for the arbitrary height case of tree and line networks, respectively.
However, there was a minor error in analyzing the approximation guarantee of the algorithm.
The error is fixed in the current paper with an increase in the ratios}.
The number of communication rounds taken by these algorithms is the same as that
of Panconesi and Sozio \cite{Pancj}. 

\noindent
{\bf Proof Techniques and Discussion: }
At a technical level, our paper makes two main contributions. 
The algorithms of Panconesi and Sozio \cite{Pancj}, as well as our algorithms,
go via the primal-dual method (see \cite{ShmoysBook}). The sequential algorithms of Bar-Noy et al. \cite{Bar-Noy-Jacm}
and Lewin-Eytan et al. \cite{Lewin-Eytan} use the local ratio technique, but they
can also be reformulated as primal-dual algorithms. Given a demand/job,
there are multiple tree-networks (or line-networks) where the demand can be scheduled and we call each such possibility
as a demand instance. All of the above algorithms work in two phases: 
in the first phase, a subset of candidate demand instances are identified
and an assignment to dual variables is computed. In the second phase,
the candidate set is pruned and a feasible solution is constructed.
The dual assignment is used as a lowerbound for the optimal solution,
by appealing to the weak-duality theorem. In fact, approximation algorithms
for many other packing problems utilize the above two-phase strategy.

We first formulate the above two-phase method as a framework.
An important feature of the framework is that any algorithm following the framework
must produce an ordering of the demand instances and also for each demand instance,
it must determine the edges along the path whose dual variables will be increased (or {\em raised}).
The ordering and the chosen edges should satisfy a certain property called the ``interference property".
The number of edges chosen, denoted , is a factor in determining the approximation ratio.
In the case of line-networks, Panconesi and Sozio \cite{Pancj} 
classify the demand instances into logarithmic many groups based on their lengths
and obtain an ordering with .
In the case of tree-networks, it is more challenging to design an ordering
satisfying the interference property. Towards that goal, we introduce the notion of
``tree-decompositions". 
The efficacy of a tree-decomposition is measured by its
depth and ``pivot size" . As it turns out, the pivot size  determines the parameter 
and the depth determines the number of rounds taken by the algorithm. 
Our first main technical contribution is a tree-decomposition with depth  and
pivot size . Using this tree-decomposition, we show how to get an ordering with .
Our tree-decompositions may be of independent interest.

Another feature of the framework is that an algorithm following the framework should
produce an assignment for the dual variables in the first phase.
This assignment need not form a dual feasible solution, but it should be approximately feasible:
the dual assignment divided by a parameter  () should yield a
feasible solution. The approximation ratio is inversely related to the parameter .
The algorithm of Panconesi and Sozio \cite{Pancj} produces a dual assignment with parameter 
. Our second main technical contribution is a method
for constructing a dual assignment with parameter .
Thus, we get a improved approximation ratios for the case
of line-networks.

\section{Unit Height Case of Tree Networks: Problem Definition}
The input consists of a vertex set  containing  vertices,
a set of  processors , a set of  {\em demands}  and
a set of  {\em tree-networks}  (each defined over the vertex-set ).
A demand  is specified as a pair of vertices  
and it is associated with a profit ;
 and  are called the {\em end-points} of .
Each processor  owns a unique demand .
For each processor , the input also provides a set 
that specifies the set of tree-networks {\em accessible} to .
Let  and  be the maximum and minimum profits.
We will assume that all the tree-networks are connected. 
Note that the tree-networks can have different sets of edges and so, they are allowed to define different trees.

A feasible solution  selects a set of demands 
and schedules each  on some tree-network .
The feasible solution must satisfy the following properties:
(i) for any , if  is owned by a processor 
and  is scheduled on a tree-network , then  must be able to access  (i.e., );
(ii) for any two selected demands  and ,
if both  and  are scheduled on the same tree-network ,
then the path between  and , and the path between  and  in the
tree-network  must be edge-disjoint (meaning, the two paths must not share any edge).
The profit of solution  is defined to be the sum of profits of the selected demands;
this is denoted . The problem is to find the maximum profit feasible solution.

We next present a reformulation of the problem, which will be more convenient for our discussion.
Consider each demand  and let  be the processor which owns .
For each tree-network , create a copy of  with the same end-points and profit; 
we call this the {\em demand instance} of  belonging to the tree-network .
Let  denote the set of all demand instances over all the demands;
each demand instance  can represented by its two end-points and the tree-network to which it belongs.
For a demand  owned by a processor , 
let  denote the set of all instances of  (we have ). 
The profit of a demand instance  is defined to be the same
as that of the demand to which it belongs; we denote this as .
A feasible solution selects a subset of demand instances 
such that: 
(i) for any two demand instances , if  and  belong to the same tree-network ,
then their paths (in the tree-network ) do not share any edge;
(ii) for any demand , at most one demand instance of  is selected.
The profit of the solution is the sum of profits of the demand instance contained in it.
The goal is to find a feasible solution of maximum profit.

The communication among the processors is governed by the following rule:
two processors  and  are allowed to communicate, if
they have access to some common resource ().

{\it Notation: }The following notation will be useful in our discussion.
Let  denote the set of all edges over all the tree-networks;
any edge  is represented by a triple ,
where  and  are vertices of  and  is the tree-network to which  belongs.
For a tree-network , let  denote the set of all demand instances belonging to .
Any demand instance  can be viewed as a path in  and we denote this as .
For a demand instance  and an edge  in ,
we say that  is {\em active} on the edge , if the  includes ;
this is denoted . We say that two demand instances  and  are
{\em overlapping}, if  and  belong to the same tree-network, 
and  and  share some edge;
the demands are said to non-overlapping, otherwise.
Two demand instances  and  are said to be {\em conflicting}, 
if both  and  belong to the same demand or they overlap;
otherwise, the demands are said to be non-conflicting.
We shall alternatively use the term {\em independent} to mean a pair of non-conflicting demands.
A set of demand instances  is said to be {\em independent set},
if every pair of demand instances in  is independent.
Notice that a feasible solution is nothing but an independent set of demand instances.

\section{LP and the Two-phase Framework}
Our algorithm uses the well-known primal-dual scheme and goes via a two-phase framework.
We first present the primal and the dual LPs and then discuss the framework.

\subsection{LP Formulation}
The LP and its dual are presented below.
For each demand instance , we introduce a primal variable .
The first set of primal constraints capture the fact that a feasible solution cannot
select two demand instances active on the same edge.
Similarly, the second set of primal constraints capture the fact that a feasible solution
can select at most one demand instance belonging to any demand.
For each demand  and each edge , the dual includes a variable  and ,
respectively. Similarly, for each demand instance , 
the dual includes a constraint; we call this the {\em dual constraint of }.
Let  denote the demand to which a demand instance  belongs.
\begin{tabular}{p{3in}p{3in}}

&

\end{tabular}



\subsection{Two-phase framework}
We formulate the ideas implicit in \cite{Pancj,Bar-Noy-Jacm,Lewin-Eytan} 
in the form of a two-phase framework, described next. Our algorithm would follow this framework.

{\it First Phase: }
The procedure initializes all the dual variables  and  to 
and constructs an empty stack, and then it proceeds iteratively.
Consider an iteration. Let  be the set of all demand instances whose dual constraints are still unsatisfied.
We select a suitable independent set  (how to select  is clarified below).
For each , we wish to increase (or {\em raise}) the value of the dual variables 
suitably so that the dual constraint of  is satisfied tightly (i.e., the LHS becomes equal to the RHS).
For this purpose, we adopt the following strategy.
Consider each demand instance .
We first determine the {\em slackness}  of the constraint, which is the difference between the 
LHS and RHS of the constraint: 
.
We next select a suitable subset  consisting of edges on which  is active
(how to select  is clarified below).
Next we compute the quantity .
We then raise the value of  by the amount ;
and for each , we raise dual variable  by the amount .
We see that the dual constraint is satisfied tightly in the process.
The edges  are called the {\em critical edges} of .
We say that the demand instance  is {\em raised} by the amount .
Finally, the independent set  is pushed on to the stack (as a single object).
This completes an iteration.
In the above framework, in each iteration, we need to select
an independent set  and the critical set of edges  for each . 
These are left as choices that must be made by the
specific algorithm constructed via this framework.
Similarly, the algorithm must also decide the termination condition for the first phase.

{\it Second Phase: } We consider the independent sets in the reverse order
and construct a solution , as follows.
We initialize a set  and proceed iteratively. 
In each iteration, the independent set  on the top of the stack is popped.
For each , we add  to , if doing so does not violate feasibility 
(namely,  is an independent set).
The second phase continues until the stack becomes empty.
Let  be the feasible solution produced by the second phase.
This completes the description of the framework.

An important aspect of the above framework is that is parallelizable.
The set  chosen in each iteration of the first phase is an independent set.
Hence, for any two demand instances , the LHS of the 
constraints of  and  do not share any dual variable.
Consequently, all the demand instances  can be raised simultaneously.

As we shall see, we can derive an approximation ratio for any 
algorithm built on the above framework, provided it satisfies the following condition,
which we call the {\em interference property}:
for any pair of overlapping demand instances  and  raised in the first phase,
if  is raised before , 
then  must include at least one of the critical edges contained in . 

The following notation is useful in determining the approximation ratio.
Let  be any real number.
At any stage of the algorithm, we say that a demand instance  is
{\em -satisfied}, if in the dual constraint of ,
the LHS is at least  times the RHS:
.
If the above condition is not true, then we say that  is {\em -unsatisfied}.

We shall measure the efficacy of an algorithm following the above framework using three parameters.
(1) {\em Critical set size : }Let  be the maximum cardinality of ,
over all demand instances  raised by the algorithm.
(2) {\em Slackness parameter : }Let  be the largest number such that
at the end of the first phase, all the demand instances  are -satisfied.
(3) {\em Round complexity: }The number of iterations taken by the first phase.
The parameters  and  will determine the approximation ratio of the algorithm;
we would like to have  to be small and  to be close to .
The round complexity determines the number of rounds taken by the algorithm when implemented in a distributed setting.
We say that the algorithm is {\em governed} by the parameters  and .

The following lemma provides an approximation guarantee for any algorithm satisfying the interference property.
The lemma is similar to Lemma 1 {in} the work of Panconesi and Sozio \cite{Pancc}. 
Let  denote the optimal solution to the input problem instance.

\begin{lemma}
\label{lem:AAA}
Consider any algorithm satisfying the interference property and governed by parameters  and .
Then the feasible solution  produced by the algorithm satisfies 
.
\end{lemma}
\proof
At the end of the first phase,
the algorithm produces dual variable assignments  and .
Even though this assignment may not form a dual feasible solution,
it ensures that all the demand instances are -satisfied;
(intuitively, all the dual constraints are approximately satisfied).
It is easy to convert the assignment  into a dual feasible solution
by scaling the values by an amount :
for each demand instance , set  and 
for each edge , set .
Notice that the  forms a feasible dual solution.

Let  and  be the objective
value of the dual assignment 
and the dual feasible solution ,
respectively. By the weak duality theorem, .
The scaling process implies that .
We now establish a relationship between  and .

Let  denote the set of all demand instances that are raised in the first phase.
The value  can be computed as follows.
For any , at most  dual variables are raised by an amount  (because ).
So, whenever a demand instance  is raised, the objective value raises at most .
Therefore,


We next compute the profit of the solution ).
For a pair of demand instances , we say that  is a {\em predecessor} of ,
if the pair is conflicting and  is raised before ; in this case  is said to be a {\em successor} of .
For a demand instance , let  and  denote the set of predecessors and successors of ,
respectively; we include  in both the sets.

Consider an element . We claim that 

To see this claim, consider the iteration in which  is raised.
At the beginning of this iteration the constraint of  is unsatisfied 
and  is raised to make the constraint tightly satisfied.
The interference property ensures the following condition:
any demand instance  with  would have contributed a value of at least 
to the LHS of the constraint (because the property enforces that the LHS includes at least one of raising dual variables
of ). Thus, at the beginning of the iteration, the value of the LHS satisfies:

When  is raised, LHS increases at least by  and the constraint becomes tight.
This proves the claim.

We can now compute a lowerbound on the profit of :

The second statement follows from (\ref{eqn:BBB}) and 
the last statement follows from the fact that for any , either  belongs to 
or a successor of  belongs to  (this is by the construction of the second phase).

Comparing (\ref{eqn:AAA}) and (\ref{eqn:CCC}), we see that .
The lemma follows from the observations made at the beginning of the proof.
\qed

A local-ratio based sequential -approximation algorithm for the unit height case of tree-networks
is implicit in the work of Lewin-Eytan \cite{Lewin-Eytan}.
This algorithm can be reformulated in the two-phase framework with parameters 
critical set size  and slackness  (however, the round complexity can be as high as ).
We present the above algorithm in Appendix \ref{sec:Lewin};
the purpose is to provide a concrete exposition of the two-phase framework.

Panconesi and Sozio \cite{Pancj} designed a distributed algorithm for the 
throughput maximization problem restricted to line-networks.
In terms of the two-phase framework, their algorithm satisfies the interference property
with critical set size  and slackness .
To this end, they partition the demand instances in to logarithmic number of groups
based on their lengths, wherein the lengths of any pair of demand instances found within the same group 
differ at most by a factor of 2. Then they exploit the property that if  and 
are overlapping demand instances found within the same group , 
then  is active either at the left end-point, the right end-point or the mid-point of .
This way, they satisfy the interference property with .
We do not know how to extend such a length-based ordering to our setting of tree-networks.
Consequently, designing an ordering satisfying the interference property with a constant  
turns out to be more challenging. Nevertheless, we show an ordering for which .
Furthermore, we shall present a method for improving the slackness parameter  to .
The notion of {\em tree-decompositions} and {\em layered decompositions} form the core components
of our algorithms.

\section{Tree-Decompositions and Layered Decompositions}
We first define the notion of tree-decompositions and show how to
construct tree decompositions with good parameters. 
Then, we show how to transform tree decompositions into layered decompositions.

Let  be a rooted tree defined over the vertex-set  with  as the root.
For a node , define its {\em depth} to be the number
of nodes along the path from  to ; the root  itself is defined to have to depth .
With respect to , a node  is said to be an {\em ancestor} of ,
if  appears along the path from  to ; in this case,  is said to be a {\em descendent} of .
By convention, we do not consider  to be an ancestor or descendent of itself.
For a node  in , let  be the set consisting of  and its descendents in .

\subsection{Tree-decomposition: Definition}
Let  be a tree-network defined over the input vertex-set  consisting of  vertices.
A subset of nodes  is called a {\em component}, if  induces a (connected) subtree in .
We say that a node  is a {\em neighbor} of , if  is adjacent to some node in .
Let  denote the set of neighbors (or {\em neighborhood}) of .
Notice that for any two nodes  and , the path between  and  must pass through 
some node in the neighborhood .

Let  be a tree-network and  be a rooted-tree defined over  with  as the root.
We say that  is a {\em tree decomposition} for , 
if the following conditions are satisfied: 
(i) for any demand instance , if  passes through nodes  and  then  also passes through
, which is the least common ancestor of  and  in ;
(ii) for any node  in ,  forms a component in .

For a node , let  denote the set of neighbors of the component , i.e., .
We call  the {\em pivot set} of .
Clearly, for any nodes  and , the path between  and  in  must 
pass through one of the nodes in .
We shall measure the efficacy of a tree decomposition  using two parameters:
(i) {\em pivot size : } this is the maximum cardinality of  over all ;
(ii) the depth of the tree. 

See Figure \ref{fig:6} for an illustration.
This figure shows an example tree-decomposition for the tree-network shown in Figure \ref{fig:5}.
The demand instance  passes through nodes  and ; it also
passes through . For the node , the component ; its pivot set is .
On the other hand,  and its pivot set is .
This tree-decomposition has depth  and pivot set size .

\begin{figure}
\centering
\includegraphics[width=4.00in]{fig6.eps}
\caption{
Tree-decompositions: Illustration.
}
\label{fig:6}
\end{figure}

We note that it is not difficult to design tree-decompositions with 
parameters  or .
As it turns out the depth of the tree-decomposition will determine the number of rounds,
whereas the pivot size  will determine the approximation ratio.
Thus, neither of these two tree-decompositions would yield an algorithm
that runs in polylogarithmic number of rounds, while achieving a constant factor approximation ratio.
Our main contribution is a tree-decomposition with parameters 
(we call this the {\em ideal tree-decomposition}).
Interestingly, the ideal tree-decomposition builds on the two simpler tree-decompositions mentioned above.
For the sake of completeness, the two simpler tree-decompositions are discussed next.

\subsection{Two Simple Tree-decompositions}
\label{sec:simple-trees}
Here, we present two tree decompositions called {\em root-fixing tree decomposition}
and {\em balancing tree decomposition}. The first decomposition has pivot size ,
but its depth can be as high as . The second decomposition has depth ,
but its pivot size  can be as high as .
\\

\noindent
{\bf Root-fixing Decomposition: } 
Let  be any input tree-network. Convert  into a rooted-tree by 
arbitrarily picking a node  as the root; let the resulting rooted-tree be .
It is easy to see that  is a tree decomposition for .
Consider any node  and let  be its parent in ; let  be the descendants of  including  itself.
Notice that for any  and , the path between  and  must pass through
the parent . Thus the component  has only one neighbor.
We see that  has pivot size ; however, the depth of  can be as high as .
Figure \ref{fig:5} shows a root-fixing decomposition; the chosen root is node .
The sequential algorithm given in Section \ref{sec:Lewin} implicitly uses the root-fixing tree decomposition.
\\

\noindent
{\bf Balancing tree decomposition: }
Let  be a tree-network. Consider a component 
and let  be the (connected) subtree induced by .
Let  be a node in . If we delete the node  from ,
the tree  splits into subtrees  (for some ).
Let  be the vertex-set of these subtrees.
Every node in  is found in some component .
We say that the node  {\em splits}  into components .
The node  is said to be a {\em balancer} for , if for all , .
The following observation is easy to prove:
any component  contains a balancer .

Our procedure for constructing the tree decomposition for  works recursively
by calling a procedure {\BuildBTD} ({\em build balanced tree decomposition}).
The procedure takes as input a component  and outputs a rooted-tree
having  as the vertex-set. It works as follows.
Given a component , find a balancer  for .
Then split  by  and obtain components  (for some ).
Each component  has size at most .
For , call the procedure {\BuildBTD} recursively on the component 
and obtain a tree  with  as the root. Construct a tree  by making  as the root
and  as its children. Return the tree .

Given a tree-network , we obtain a rooted-tree  by calling {\BuildBTD} with the whole
vertex-set  as the input. 
It is easy to see that for any node ,  forms a component in .
For any node  in  with children  (for some ),
 are nothing but the components obtained by splitting  by .
This implies that  satisfies the first property of tree decompositions.
Since the size of the input component drops by a factor of two in each iteration,
the depth of  is at most .
Consider any node  in  and let  be the set consisting of descendants of  and  itself.
Observe that for any node  and , the path between  and 
must pass through one of the ancestors of  in  (because of the first property of tree decompositions).
In other words, the neighborhood of  is contained within the set of ancestors of .
The number of ancestors is at most  and
hence, the pivot size of  is at most .
Figure \ref{fig:6} shows an example balancing tree-decomposition for the tree given in Figure \ref{fig:5}.

\subsection{Ideal Tree-decomposition}
In this section, we present the ideal tree-decomposition with parameters .
The ideal tree-decomposition also goes via the notion of balancers.
Recall that any component  contains a balancer .

Fix a tree-network  and we shall construct an ideal tree decomposition  for  with pivot set size 
and depth . Intuitively, the tree  will be constructed recursively.
In each level of the recursion, we will add two nodes to the tree: a balancer and a node that we call a {\em junction}.
The output tree-decomposition will have depth at most .

The construction works via a recursive procedure {\BuildITD} ({\em build ideal tree decomposition}).
The procedure {\BuildITD} takes as input a set  forming a component in .
As a precondition, it requires the component  to satisfy the important property that  has at most
two neighbors in .
It outputs a rooted-tree  with  as the vertex set
having depth at most  such that for any node , 
the number of neighbors of  is at most ,
where  is the set consisting of  and its descendants in .

The procedure {\BuildITD} works as follows. We first find a balancer  for the component .
The node  splits  into components . 
We shall consider two cases based on whether  has a single neighbor or two neighbors.

\begin{figure}[t]
\centering
\includegraphics[width=6in]{fig3.eps}
\caption{Illustration for ideal tree-decomposition.}
\label{fig:3}
\end{figure}

{\it Case 1: }This is the easier case where  has only one neighbor, say .
See Figure \ref{fig:3}. For this case, ignore the nodes  and .
Let  be the node in  which is adjacent to  and 
without loss of generality, assume that  is the component to which  belongs.
Observe that  and for all , .
In other words, all the components  have at most two neighbors.
That is, they all satisfy the precondition set by the procedure.
For each , we recursively call the procedure {\BuildITD} on the component 
and obtain a tree  with  as the root. 
We construct a tree  by making  as the root and  as its children. 
Then, the rooted-tree  is returned. 

{\it Case 2: }Now consider the case where  has two neighbors, say  and .
Let  and  be the nodes in  which are neighbors of  and , respectively.
We consider two subcases.

{\it Case 2(a): }
The first subcase is when  and  lie in two different components, say  and , respectively. 
See Figure \ref{fig:3}.
Observe that ,  and for all ,
. Hence all the components  satisfy the precondition set by the procedure.
For each , we call the procedure {\BuildITD} with  as input and obtain 
a tree . We construct a tree  by making the balancer  as the root and  as its children. 
Then, the rooted-tree  is returned. 

\begin{figure}[t]
\centering
\includegraphics[width=6in]{fig4.eps}
\caption{Illustration for Case 2(b) of ideal tree-decomposition}
\label{fig:4}
\end{figure}

{\it Case 2(b): }
Now consider the second and comparatively more involved subcase wherein  and  belong to 
the same component, say . See Figure \ref{fig:4}.
Observe that there exists a unique node  such that all the three paths 
, , and  pass through . We call  as the {\em junction}.
Spilt the component  by the node  to obtain components  (for some ).
Observe that among , 
there exists three distinct components such that  is a neighbor of the first component,
and  and  belong to the other two components;
without loss of generality, let these components be ,  and , respectively.
We see that for , ; moreover,
, , 
and for , .
Thus, all the components  and 
satisfy the precondition set by the procedure.
For each , we call the procedure {\BuildITD} recursively with
 as input and obtain a tree  with  as the root.
For each , we call the procedure {\BuildITD} recursively with
 as input and obtain a tree  with  as the root.
Construct a tree  as follows. Make the junction  as the root;
make  as the children of ;
make  as a child of ; make  and  as the children of .
Return the rooted-tree . This completes the description of the procedure {\BuildITD}.

By induction, we can argue that {\BuildITD} satisfies the intended property:
for any node , the number of neighbors of  is at most .
As an example, consider the subcase in which  and  belong to the same component 
(the case where a junction  is created). The procedure creates only two nodes  and  on its own
and the rest of the nodes in  are created by the recursive calls. 
Consider the node .
It is guaranteed that the input component  has at most two neighbors (this is the precondition
set by the procedure). Since , we see that  satisfies the property.
Now, consider the node . The component  is the union 
of  and . We have that .
Thus,  also satisfies the property. The rest of the nodes satisfy the property by induction.

Let us now analyze the depth of the tree  output by the procedure.
Since  is a balancer for , the components  have size at most .
Moreover, since  are subsets of ,
these components also have size at most .
Thus, all the components input to the recursive calls have size at most . 
Thus, by induction,  has depth at most .

We next show how to construct a tree decomposition  for the tree-network .
First, find a balancer  for the entire vertex-set  and split  into components
. For each component , .
For each , call the procedure 
with  as input and obtain a tree  with  as the root.
Construct a tree  by making  as the root and each  as its children.
Return .

We can argue that for any node  in ,  forms a component in .
Furthermore, for any node  in  with children  (for some ),
 are nothing but the components obtained by splitting  by .
This implies that  satisfies the first property of tree decompositions.
It follows that  is indeed a tree decomposition.
The depth of  is at most . The properties of the {\BuildITD} procedure
ensure that the pivot size of  is at most . We have the following result

\begin{lemma}
\label{lem:BBB}
For any tree-network , there exists a tree decomposition  (called the ideal tree decomposition)
with depth  and pivot size .
\end{lemma}

\subsection{Layered Decompositions}
In this section, we define the notion of {\em layered decompositions} and 
show how to transform tree decompositions into layered decompositions.

Let  be a tree-network. A layered decomposition of  is a pair 
 and , where  is a partitioning of  into a
sequence of groups  and  maps each demand instance 
to a subset of edges in . The following property should be satisfied:
for any  and for any pair of demand instances  and ,
if  and  are overlapping, then  should include at least one of the 
edges in . The edges in  are called the {\em critical edges} of .
The value  is called the {\em length} (or depth) of the decomposition.

Notice that similarity between the inference property and the notion of layered decompositions.
We shall measure the efficacy of a layered decomposition by two parameters:
(i) {\it Critical set size } -  this is the maximum cardinality of  over all 
demand instances ; (ii) the length  of the sequence.
Our goal is to construct a layered decomposition with length 
and critical set size . Towards that goal we shall show how to transform 
tree-decompositions into layered decompositions. The following notations are useful for this purpose.

Let  be tree-network and  be a tree-decomposition for 
with pivot size  and depth . 
For a demand instance , let 
be the node with the least depth in  among all the nodes that  passes through.
The first property of tree decompositions ensure that  is unique.
We say that  is {\em captured} at . See Figure \ref{fig:6}.
In this figure, the demand  is captured at node .
Let  be a demand instance and  be a node in .
Observe that there exists a unique node  belonging to 
such that the path from  to  does not pass through any other node in .
We call  as the {\em bending point} of  with respect to .
For a node  in , we call the edges on  adjacent to  as the {\em wings} of  on .
If  is an end-point of , there will be only one wing; otherwise, there will be two wings.
See Figure \ref{fig:5}.
In this figure, with respect to nodes  and , 
the bending points of the demand  are  and , respectively.
With respect to , node  has only one wing , while node
 has two wings  and .

\begin{figure}
\centering
\includegraphics[width=4.00in]{fig5.eps}
\caption{
An example tree-network. 
}
\label{fig:5}
\end{figure}

Lemma \ref{lem:CCC} shows how to transform a tree-decomposition into a layered decomposition.
The lemma is proved by categorizing the demand instances into groups
, where  consists of all demand instances
captured at a node with depth .
For a demand instance , let .
The set  is constructed as follows:
(i) we include the wings of  on ;
(ii) for each neighbor  of , taking  to be the bending point of 
with respect to , we include the wings of  on .

\begin{lemma}
\label{lem:CCC}
Let  be a tree-network and  be a tree decomposition for 
with pivot size  and depth . Then  can be transformed into a layered
decomposition  with critical set size 
and length .
\end{lemma}
\proof
For , let  to be the set consisting of all demand instances 
 such that depth of  is . 
We define  to be the reverse of ;
namely, let , where , for .
Thus, in , the demand instances captured at the nodes having the highest depth are placed in 
and the demand instances captured at the root are placed in .
We now show how to construct the critical set  for each demand instance .
Let  be the node in  where  is captured.
Add the wing(s) of  on  to .
Then, consider the component  consisting of  and its descendents in .
Let  be the neighbors of , where .
For , let  be the bending point of  with respect to ;
add the wing(s) of  on  to . 
Notice that  has at most  edges.
This completes the construction of  and .

We now argue that the construction satisfies the properties of layered decompositions.
Consider any two groups  and  such that .
Consider two overlapping demand instances  and . 
Let  and  be the nodes in  where  and  are captured, respectively.
We consider two cases: (1) ; (2) . 

{\it Case 1: } In this case,  must be the same as  
(otherwise, we have ; this would contradict ).
Therefore,  should include at least one of the wings of  on . 
Recall that the wing(s) of  on  are included in .

{\it Case 2: }
By the LCA property of tree-decompositions,  will be constained within the component .
We have that  goes through the node  found outside of ;
moreover, it also goes through some node found within  (since  and  overlap).
By the second property of tree decompositions, such a path must also 
pass through one of the neighbors of ; let  be such a neighbor.
Let the bending point of  with respect to  be .
Since  passes through  and overlaps with ,
the  must also pass through the bending point . 
It follows that  must include one of the wings of  on .
Recall that the wing(s) of  on  are included in .
\qed

By applying Lemma \ref{lem:CCC} for the ideal tree decomposition (given by Lemma \ref{lem:BBB}),
we establish the following result.

\begin{lemma}
\label{lem:DDD}
For any tree-network , we can construct a layered decomposition with 
critical set size  and length at most .
\end{lemma}

\begin{figure}[t!]
\begin{center}
\begin{boxedminipage}{\hsize}
\begin{tabbing}
xx\=xx\=xx\=xx\=xxx\=xxx\=\kill
\textbf{Begin}  \\
\> // Initialize \\
\> For all , set ; for all , set .\\
\> Initialize an empty stack.\\
\> Let the input set of tree-networks be .\\
\> For each tree-network \\
\> \> Invoke Lemma \ref{lem:DDD} on  and \\
\> \> \> obtain a layered decomposition  and a mapping .\\
\> \> Let . \\
\> \> For each , define .\\
\> For each  =  to , \\
\> \> Define .\\
\>\\
\> // First phase\\
\> For  to  \quad\quad//Epochs\\
\> \> Let  be the smallest integer such that  \\
\> \> For  to  \quad \quad //Stages \\
\> \> \> While \quad \quad // Steps or iterations.\\
\> \> \> \> Let d(1-(14/15)^j)\\
\> \> \> \> If , exit the loop.\\
\> \> \> \> Find a maximal independent set  contained within \\
\> \> \> \> For each \\
\> \> \> \> \> Compute slackness: .\\
\> \> \> \> \> Compute: .\\
\> \> \> \> \> Raise the variables: ; 
		for all , .\\
\> \> \> \> Push  into the stack (as a single object).\\
\>\\
\> // Second Phase\\
\> \> .\\
\> \> While(stack not empty)\\
\> \> \> Pop the top element  of the stack\\
\> \> \> For each \\
\> \> \> \> If  is an independent set, then add  to .\\
\> Output .\\
\textbf{End}
\end{tabbing}
\end{boxedminipage}
\end{center}
\caption{Pseudocode of the overall algorithm}
\label{fig:full-pseudo}
\end{figure}

\section{Distributed Algorithm}
\label{sec:distributed}
In this section, we prove the main result of the paper by exhibiting
a two-phase procedure with critical set size 
 and slackness parameter , for any constant .

Let the input tree networks be .
For each tree-network , invoke Lemma \ref{lem:DDD} and obtain a layered decomposition
 of length  and a mapping .
Let . The lemma guarantees that  is 
and all the critical set sizes are at most . 
Let  and .
For the ease of exposition,
we combine all the mapping functions into single mapping function , as follows.
For each tree-network  and demand instance , define .

For each , let  be union of the th components
of all the layered decompositions: .
The algorithm would follow the two-phase framework.
All the dual variables are initialized to zero and an empty stack is created.
The first phase is split into  epochs.
Epoch  will process the group . Our goal is to ensure that at the end of the epoch,
all the demand instances in  are -satisfied.
Each epoch is divided into multiple stages, with each stage making a gradual progress towards the goal.
We will ensure that at the end of stage , all the demand instances in  are -satisfied.
Each stage is split into multiple steps (each step corresponds to an iteration of the two-phase framework).
A typical step is explained next.
Let  be the set of all demand instances in  that are -unsatisfied.
Find a maximal independent set  contained within .
For all demand instances , raise the demand instance  as prescribed by the framework,
taking  to be the critical edges.
Namely, for all demand instances , perform the raising as follows.
Compute the slackness 
and . Raise the dual variable  by the amount 
and for all , raise the dual variable  by .
The stage is completed when all the demand instances in  are -satisfied
and we proceed to the next stage. The epoch is completed when all the demand instances in 
are -satisfied. The second phase is the same as that of the two-phase framework.
The pseudocode is provided in Figure \ref{fig:full-pseudo}. 


Let us analyze the number of steps (or iterations) taken by the above algorithm.
The number of epochs is , which is .
Each epoch has at most  stages.
The lemma below provides a bound on the number of steps taken by each stage.
It follows that the total number of communication rounds
is at most ,
where  is the number of (communication) rounds needed to find a maximal independent set (see Introduction).

\begin{lemma}
\label{lem:EEE}
Consider any epoch  and stage  within the epoch.
The number of steps taken by the stage is at most .
\end{lemma}
\proof
Let the number of steps taken by the stage be .
For , let  be the demand instances in  that
are -unsatisfied at the beginning of step .
Let  be the sequence of maximal independent sets computed in these steps.
For two demand instances , we say that  {\em kills}  in step ,
if , , and  and  are conflicting.
Intuitively, both  and  are present in , and both are contenders for the maximal independent .
Of the two,  got selected in  and  was omitted;
even after the demand instances in  were raised,  was still -unsatisfied.
Since  and  are conflicting, only one of them can be included in the independent set. 
We imagine that  ``kills" .

\begin{claim}
Suppose  kills  in step . Then, their profits satisfy 
\end{claim}

We now prove the claim. Since , the demand instance is -unsatisfied
at the beginning of step . Hence, the difference between the LHS and RHS 
of the constraint is at least . The number dual variables raised for  is at most .
Hence, 

Since  and  are conflicting, either it is the case that  and  belong to the same demand 
or they belong to the same tree-network  (for some ) and overlap. 
In the former case, the dual constraints of  and  share the dual variable .
In the latter case, both  and  belong to the same group . 
Hence, the properties of layered decompositions imply that
one of the critical edges in  also appears in the .
Thus, in either case, when  is raised, the LHS of  is also raised by an amount .
On the other hand,  and so, even after the above raise in the LHS value,
 is still -unsatisfied. As we are considering stage ,
all the demand instances in  are -satisfied.
The gap between  and  is .
We see that even after the value of the LHS of the dual constraint of  is raised by an amount ,
the above gap is not bridged.  It follows that 

This implies that

We derive the claim by substituting  and .

Consider any demand instance . There must exist a demand instance  in 
such that  kills . In general, we can find a sequence of demand instances
 such that for ,  kills .
By the above claim, for , .
It follows that . 
Hence, .
\qed

The properties of layered decomposition imply that the above two-phase algorithm satisfies the interference
property, governed by parameters  and .
Therefore, by Lemma \ref{lem:AAA}, it follows that the algorithm has an approximation ratio of .
For , we can choose  suitably and obtain an approximation ratio of .
We have proved the main result of the paper.

\begin{theorem}
\label{thm:main}
There exists a distributed algorithm for the unit height case of the throughput maximization problem on tree-networks 
with approximation ratio  and number of (communication) rounds is at most 
,
where  is any constant.
\end{theorem}

\noindent
{\bf Remark: }Recall that Panconesi and Sozio \cite{Pancc} presented an algorithm for the unit height case of
line-networks. Their algorithm follows the two-phase framework with the slackness parameter .
On the other hand, our algorithm has .
A comparison of the two algorithms is in order. We reformulate their algorithm to suit our framework.
Their algorithm also classifies the demand instances into groups 
(based on length) and processes the groups in epochs. However, 
each epoch consists of only a single stage. They split the stage into multiple iterations/steps.
In any iteration, a demand instance  which is -satisfied is ignored
for the rest of the first phase. In contrast, our algorithm works in multiple stages,
where in each stage, we make gradual progress towards making the demand instances
within the group to be -satisfied. In particular,
in stage , a demand instance which is -satisfied is not ignored;
it exits the current stage, but it is included in the MIS computations in the next stage.
\\

\noindent
{\bf Distributed Implementation: }
Here, we sketch certain aspects of implementing the algorithm in a distributed manner.
Let  be the number of bits needed to encode the information about any demand 
(such as its end-points and profit).

For now, assume that the values  and  are known to all the processors.
Under this assumption, we can count the number of epochs, stages and iterations exactly.
The number of epochs is  (the maximum depth of ideal tree decompositions); 
the number of stages within each epoch is , where ;
the number of iterations within each stage is , where  is a suitable constant.

Each processor  computes the ideal tree-decomposition and the corresponding layered decomposition
for each tree-network  accessible to it.
Each processor maintains the values of the dual variables correspoding to its demand instances.
The algorithm proceeds in a synchronous fashion consisting of multiple communication rounds,
where each round corresponds to a tuple ,
where ,  and  are the epoch, stage and iteration number of the pseudocode.
Given a tuple ,
a processor  can determine which demand instances can participate in the MIS calculation of this 
communication round. The MIS calculation is performed considering the {\em conflict graph}:
the demand instances participating in the MIS computation form the vertices
and an edge is drawn between a pair of vertices, if they are conflicting.
The number of vertices is at most , where  is the number of demands
and  is the number of tree-networks.
The MIS can computed using either the randomized algorithm of Luby \cite{Luby}
or using the deterministic procedure of network decompositions \cite{PancSrini}.
In the former case, the number of (communication) rounds needed in , whereas
in the latter case, it is .
Each processor  contains at most one demand instance  belonging to the MIS.
The processor  raises the dual variables corresponding to  as given in the pseudocode.
The new dual variables are transmitted to the processors sharing a common resource with .
Upon receiving the new dual variables, each processor updates the dual variables of its demand instances suitably.
Each processor  raises at most a constant number of dual variables in each iteration (because the critical set 
size  is a constant) and the amount of increase is at most .
Thefore, the message size is bounded by .
The stack is implemented in a distributed manner. Each processor  maintains its own stack.
Whenever the processor  raises a demand instance , it pushes  onto its stack
along with a tuple  (consisting of the corresponding epoch, stage and iteration numbers).

The second phase proceeds in the reverse order. Each round of the second phase
is associated with a tuple  (consisting of epoch, stage and iteration numbers).  
A processor  will compare tuple  on the top of the stack
with the tuple ; if they match, then it will pop the demand instance  on the top of the stack.
It will output , if feasibility is maintained.
In this case, the processor  will inform its neighboring processors
that  has been included in the output solution.

Finally, we note that it is not difficult to bypass the assumption that all the processors know 
the values of  and .

\section{Arbitrary Height Case for Tree-Networks}
\label{sec:arbit}
Panconesi and Sozio \cite{Pancc} presented a distributed -approximation algorithm
for the unit height case of the line-networks. Then, they extended this algorithm 
for the arbitrary height case and obtained a -approximation algorithm \cite{Pancj}.
In this section, we extend our -approximation algorithm for the unit height case
of the tree-networks to the arbitrary height case and derive a -approximation algorithm. 
We note that the extra ideas needed for the extension roughly follow the theme of Panconesi and Sozio \cite{Pancj}. 
The main difference is that their algorithm follows the two-phase framework with the 
slackness parameter being , whereas we aim for .
Below we highlight the necessary changes.

We first develop some notation for the arbitrary height case.
The problem setup is as before, except that each demand 
also has a bandwidth requirement (or {\em height}) .
All the edges in all the tree-networks are assumed to provide a uniform bandwidth of  unit.
For each demand  owned by a processor  and each tree-network  accessible to ,
create a copy of  with the same end-points, height and profit; these copies are called
demand instances of .
Let  denote the set of all demand instances (over all demands).
A demand instance  belonging to a tree-network  has a height  and a profit ,
and it can be viewed as a path between its end-points in .
A feasible solution selects a subset of demand instances 
such that: (i) for any demand , at most one demand instance of  is selected;
(ii) for any edge  in some tree-network ,
among the demand instances in , the sum of heights of the demand instances passing through  is at most  unit.
The profit of the solution is the sum of profits of the demand instances contained in it.
The goal is to choose the solution having the maximum profit.

We classify the input demand instances  into two categories based on their height:
(i) {\em narrow instances: }  is said to be narrow, if ;
(ii) {\em wide instances: }  is said to be wide, if .
Notice that two wide demand instances which are overlapping cannot be picked by a feasible solution.
Hence, if our input consists only of wide demand instances, we can reuse the algorithm for the unit height case
and get a  approximation factor.
We next describe a -approximation algorithm for the special case where in the input
consists of only narrow instances. The final algorithm will be derived by combining the above two algorithms.

\subsection{Narrow Instances}
Here, we assume that the input consists of only narrow instances and develop a -approximation algorithm.

\subsubsection*{LP and Dual}
The LP and the dual have to be modified suitably to reflect the notion of heights.
Recall that for each demand instance , we have a variable .

The first set of constraints capture the fact that the cumulative height of the demand instances
active on an edge  cannot exceed one unit.
Similarly, the second set of constraints capture the fact that a feasible solution
can select at most one demand instance belonging to any demand.

The dual of the LP is as follows.
For each demand  and each edge , the dual includes a variable  and ,
respectively. Similarly, for each demand instance , 
the dual includes a constraint; we call this the {\em dual constraint of }.
Recall that  denotes the demand to which a demand instance  belongs.

The dual also consists of the non-negativity constraints: for all  and , 
and . 

\subsubsection*{Two-phase Framework}
We modify the two-phase framework as follows.
As before, the algorithm proceeds iteratively and a typical iteration is performed as below. 
We choose suitable independent set  and raise each demand instance .
The slackness computation is modified to reflect the notion of heights in the constraints.
Define the slackness to be:

We next select a suitable subset  consisting of critical edges on which  is active.
The strategy for raising the dual variables is modified slightly.
We raise  by  and for each , 
raise  by . Towards that goal, define .
We see that the dual constraint is satisfied tightly in the process.
The second phase of the algorithm remains the same.

The parameters critical set size  and slackness  are defined as before.
Similarly, the concept of interference property remains the same.
Lemma \ref{lem:AAA} can be extended as follows, using similar arguments.

\subsubsection*{Approximation Guarantee}
\begin{lemma}
\label{lem:JJJ}
Suppose the input consists of only narrow instances.
Consider any algorithm satisfying the interference property and governed by parameters  and .
Then the feasible solution  produced by the algorithm satisfies 
.
\end{lemma}
\proof
As before, let  and  be the dual variable assignment produced at the end of the first phase.
Convert the assignment  into a dual feasible solution
by scaling the values by an amount :
for each demand instance , set  and 
for each edge , set .
Notice that the  forms a feasible dual solution.

Let  and  be the objective
value of the dual assignment 
and the dual feasible solution ,
respectively. By the weak duality theorem, .
The scaling process implies that .
We now establish a relationship between  and .

Let  denote the set of all demand instances that are raised in the first phase.
The value  can be computed as follows.
For any , the variable  is raised by an amount 
and for each , the variable  is raised by an amount .
We have that .
So, whenever a demand instance  is raised, the objective value raises at most .
Therefore,


We next compute the profit of the solution .
For a pair of demand instances , we say that  is a {\em predecessor} of ,
if the pair is conflicting and  is raised before ;
in this case  is called the {\em successor} of .
For a demand instance , let  and  denote the set of predecessors and successors of ,
respectively; we exclude  from both the sets.

Define ; we say that demand instances in  are {\em killed} by the procedure.
We say that a demand  is killed by a demand  if the following three conditions are true: (i) ;
(ii) both  and  belong to the same demand;  (iii) .
For a demand , let  denote the set of demand instances killed by ; 
notice that .
Let  be the union of  over all demand instances .
Let  be the demand instances in  that could not be added to the solution because of bandwidth constraints
(i.e.,  consists of demand instances  such that for some edge , 
).

Consider any demand instance  and we shall computer a lowerbound on .
Consider the iteration in which  was raised; after the raise, the LHS of the constraint
of  becomes equal to the RHS (i.e., ). 
The demand instance  contributes at least  to the LHS.
In the previous iterations, any demand instance  would have contributed  to the LHS.
Similarly, for any  and any demand instance  such that ,
 would have contributed  to the LHS. Thus, we see that:

Summing up  over all the demand instances , we get that

Rewriting the second and the third terms of the RHS:

Now let us analyze the third term in the RHS.
Consider any .
The demand instance  could not be added to  because of the bandwidth constraint being
violated at some edge . Meaning,

Since all demand instances are assumed to be narrow, we have that . 
It follows that 

Let .
By the interference property, all the demand instances in  are active
at one of the edges in .
It follows that there exists an edge  such that 

where .
Consider the third term in the RHS of the formula (\ref{eqn:dxy}).
The second summation is over all the edges .
We replace this summation by the single quantity corresponding to .
We get that

Therefore,

The second statement follows from the fact that  is the union of ,  and .
Comparing (\ref{eqn:HHH}), we see that .
The lemma is proved by the observations made at the beginning of the proof.
\qed

\subsubsection*{Distributed Algorithm}
Fix any . 
Our goal is to design a two-phase procedure with critical set size  and slackness parameter 
.
The distributed algorithm is similar to that of the unit height case (Section \ref{sec:distributed}).
We use the same layered decompositions given by Lemma \ref{lem:DDD} (with  and length ).
The only difference is that we set the parameter , for some suitable constant .
Arguments similar that of Lemma \ref{lem:EEE} can be used to show that in any epoch  and any stage ,
the algorithm takes at most  steps (or iterations).
The number of epochs in , as before.
The number of stages within each epoch is .
The above value of  ensures that the above quantity is at most .
Therefore, the total number of steps is 
.
The above algorithm satisfies the interference property with critical set size  and slackness
parameter . By Lemma \ref{lem:JJJ}, 
the approximation ratio is .
We have established the following lemma.

\begin{lemma}
\label{lem:KKK}
Fix any  and . Consider the special case of the scheduling problem on tree-networks
with heights wherein all the demands  are narrow and satisfy .
There exists a distributed algorithm for the above problem with approximation ratio .
The number of (communication) rounds is at most 
.
\end{lemma}

\subsection*{Overall Algorithm}
Fix any . We present an algorithm within an approximation ratio of ,
for the arbitrary height case of tree-networks.

We classify the demand instances into wide and narrow instances.
Let  and  denote the optimal solutions considering only the wide and narrow instances,
respectively. Notice that .
For the wide instances, we run the algorithm for the unit height case (Theorem \ref{thm:main})
and obtain a solution  such that .
Next we run the algorithm for the narrow instances (Lemma \ref{lem:KKK})
and obtain a solution  such that .
Output a combined solution  as follows.
For each tree-network , consider the set of demand instances scheduled on  by the solution 
and the set of demand instances scheduled on  by the solution ; among the two sets, choose the one
with the higher profit. It is easy to see that the bandwidth constraints are satisfied by .
Furthermore, for any demand , either all the demand instances of  are narrow
or all of them are wide. Therefore,  will pick at most one demand instance from any demand.
This shows that  is indeed a feasible solution.
We have that . It follows that .
We have established the following theorem.

\begin{theorem}
\label{thm:LLL}
Fix any  and . Consider the scheduling problem on tree-networks
with arbitrary heights wherein all the demands  satisfy .
There exists a distributed algorithm for the above problem with approximation ratio .
The number of (communication) rounds is at most 
.
\end{theorem}

\section{Line-Networks}
Recall that Panconesi and Sozio \cite{Pancj} presented distributed algorithms
for the case of line-networks with windows. For the unit height case the approximation ratio was 
and for the arbitrary height case, the ratio was . 
In this section, we obtain a improved approximation ratios  and , respectively.
We next explain the new algorithms within our framework.

We first develop some notation. Let  be the set of  processors,  be the set of  resources
and  be the set of  demands.
We divide timeline into  discrete timeslots, . Each processor  owns a demand .
Each demand  is specified by a window  and a processing time ,
where  and  are the release time and deadline of .
A profit  and a height  are associated with each demand . 
Consider a processor  and the demand  owned by .
For each resource  accessible by  and each interval of length  contained within ,
create a demand instance ; its profit and height are the same as that of ;
the number of demand instances is at most , where 
is the set of resource accessible to . Let  denote the set of all demand instances.
Each demand instance  is described by a starting time , and ending time ,
a profit , a height  and the resource to which it belongs.
Recall that the time-line can be viewed as a tree-network with  vertices.
In other words, the case of line-networks can be reduced to the case of tree-networks.
Therefore, Theorem \ref{thm:main} and \ref{thm:LLL} apply to the case of line-networks.
We next show how to improve these results in the case of line networks.
The improvements are obtained by designing layered decompositions with better parameters.

\subsubsection*{Improved Layered Decomposition}
In the case of tree-networks, we derived decompositions with critical set size 
and length . In the case special of line-networks, we show how to construct
decompositions with parameters  and  ( and 
are the maximum and minimum length of the demand instances).
We note that this decomposition is implicit in \cite{Pancj}.

Partition the demand instances in to  categories based
on their length, where the length of a demand instance is .
For , define .
Define an ordering .
For each demand instance , let  be the mid-point of .
Define , for all .
It is not difficult to argue that the pair  forms layered decomposition.

\subsubsection*{Unit Height Case}
Fix . We modify the distributed algorithm given in Section \ref{sec:distributed}
to use the above layered decomposition. We suitably change the value of  to 
 (instead of ). This algorithm would satisfy the interference property with 
and . So, the approximation ratio is .
The number of (communication) 
rounds is .
We have established the following result.

\begin{theorem}
\label{thm:MMM}
There exists a distributed algorithm for the scheduling problem for the unit height case of line-networks with windows
with approximation ratio . The number of (communication) rounds is at most 
,
\end{theorem}

\subsubsection*{Arbitrary Height Case}
Here, we discuss the arbitrary height case. As in Section \ref{sec:arbit}, we partition
the set of demand instances into narrow and wide categories.
For the case of wide instances, Theorem \ref{thm:MMM} applies and 
yields an algorithm with an approximation ratio of .
For the case of narrow instances, the algorithm is similar to that of Lemma \ref{lem:KKK};
the only change is that we set the parameter , for a suitable constant .
This way we get an algorithm with an approximation ratio of  
(because, in the current setup ).
We obtain an overall algorithm by combining the solutions output by the above two algorithm;
the idea is same as that of Theorem \ref{thm:LLL}. We have established the following result.

\begin{theorem}
Fix any  and . Consider the scheduling problem on tree-networks
with arbitrary heights wherein all the demands  satisfy .
There exists a distributed algorithm for the above problem with approximation ratio .
The number of (communication) rounds is at most 
.
\end{theorem}

\bibliographystyle{plain}
\bibliography{main}

\appendix
\section{A Sequential Algorithm for Tree-networks}
\label{sec:Lewin}
Here, we present a sequential algorithm satisfying the interference property with 
critical set size  and slackness parameter .

Let  be the given set of tree-networks.
For , construct a rooted tree  by arbitrarily selecting a node  
and making  as the root of . Let 
be the set of rooted trees constructed by the above process.

Consider an input tree-network . 
Let  be the rooted tree corresponding to  with  as the root.
For a node , define its {\em depth} (or height) to be the number
of the nodes along the path from  to ; the root  itself is defined to have to depth .
For a demand instance , let  denote the node in 
having the least depth among all the nodes appearing in .
We say that  is {\em captured} at the node ; observe that  is uniquely determined.
See Figure \ref{fig:5}. A rooted-tree  has been constructed by picking the node  as the root.
The demand instance  will be captured at the node .
With respect to , a node  is said to be an {\em ancestor} of ,
if  appears along the path from  to ; in this case,  is said to be a {\em descendent} of .
By convention, we do not consider  to be an ancestor or descendent of itself.

Consider a demand instance . 
We have that  passes through the node . 
Let  denote the set of edges of  that are adjacent to .
If  is one of the end-points of  then  will have only one edge;
otherwise, it will have two edges. 
See Figure \ref{fig:5}. The set  for the demand instance 
is given by .
We can now make the following important observation.

\begin{figure}[t!]
\begin{center}
\begin{boxedminipage}{\hsize}
\begin{small}
\begin{tabbing}
xx\=xx\=xx\=xx\=xxx\=xxx\=\kill
\textbf{Begin}  \\
\> // Initialize \\
\> For all , set ; for all , set .\\
\> Initialize an empty stack.\\
\>\\
\> // First phase\\
\> For  =  to \\
\> \> While\\
\> \> \>Let d.\\
\> \> \>If , exit the loop.\\
\> \> \>Let  be the element of  appearing earliest in .\\
\> \> \>Compute slackness: .\\
\> \> \>Compute: .\\
\> \> \>Raise the variables: ; 
          for all , .\\
\> \> \>Push  into the stack.\\
\>\\
\> // Second Phase\\
\> \> .\\
\> \> While(stack not empty)\\
\> \> \> Pop the top element  of the stack\\
\> \> \> If  is an independent set, then add  to .\\
\> Output .\\
\textbf{End}
\end{tabbing}
\end{small}
\end{boxedminipage}
\end{center}
\caption{Sequential Algorithm: Pseudocode}
\label{fig:Lewin-pseudo}
\end{figure}

\begin{observation}
\label{obs:AAA}
Consider any two overlapping demand instances .
If  is captured at a node  and  is captured at an ancestor of ,
then  will include one of the edges from .
Furthermore, if  and  are captured at the same node ,
then also  will include one of the edges from .
\end{observation}

Based on the above observation, our algorithm works as follows.
In the two-phase framework, in each iteration, we need to determine an independent set .
We shall perform the above task by selecting a singleton demand instance  (forming a trivial independent set);
we can afford to do this, since we are designing a sequential algorithm.
Towards determining , we define an ordering of the demand instances for each tree-network.
Consider a tree-network  and let  be the rooted tree corresponding to  with  as the root. 
Order the demand instances  in the descending order of the depth of ;
ties are broken arbitrarily. Thus, demand instances captured at the bottom-most leaves of  will 
be placed first and those captured at the root will be placed last.
Let  denote the ordering obtained by the above process.

The first phase works in  rounds, where the th round will process the tree-network .
The round  works in multiple iterations, where each iteration is performed as described below.
Let  be the demand instances belonging to  whose constraint is unsatisfied (recall that ).
Among demand instances in , pick the demand instance  appearing earliest in the ordering 
and raise the demand : namely, raise the dual variable  and the dual variables
of the edges found in . The th round is completed when the dual constraints of 
all the demand instances of  are satisfied.
The pseudocode of the algorithm is presented in Figure \ref{fig:Lewin-pseudo}.

Observation \ref{obs:AAA} shows that the algorithm satisfies the interference property.
Furthermore, for any demand instance , .
Thus, we have a two-phase procedure with parameters  and .
Lemma \ref{lem:AAA} shows that the algorithm is a -approximation algorithm.
In the special case where there is only one tree-network, we do not need to raise
the dual variables  and the approximation ratio can be improved to .
The resulting algorithm would essentially be the same as that of Lewin-Eytan et al. \cite{Lewin-Eytan}.
The round complexity of the algorithm can be as high as , since only a single demand instance is 
raised in each iteration. 



\end{document}
