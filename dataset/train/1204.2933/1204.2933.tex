\documentclass[11pt]{article}
\usepackage{fullpage}
\usepackage{latexsym}
\usepackage{epsf}


\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{claim}{Claim}[section]

\newcommand{\qed}{\hspace*{\fill}\par\medskip}
\newenvironment{proof}{\noindent{\it Proof. }\ignorespaces}{\qed}

\title{{\bf Improved Randomized Online Scheduling of Intervals and Jobs}\thanks{The work described in this paper was fully supported by
grants from the Research Grant Council of the Hong Kong SAR,
China [CityU 119307] and NSFC Grant No. 60736027 and 70702030.}
}

\author{
Stanley P. Y. Fung\footnote{
Department of Computer Science, University of Leicester,
Leicester, United Kingdom. Email: {\tt pyfung@mcs.le.ac.uk}}
\and
Chung Keung Poon\footnote{
Department of Computer Science, City University of Hong Kong, Hong Kong.
Email: {\tt csckpoon@cityu.edu.hk}}
\and
Feifeng Zheng\footnote{
School of Management, Xi'an Jiaotong University, Xi'an, China. 
Email: {\tt zhengff@mail.xjtu.edu.cn}}
}

\begin{document}

\maketitle

\begin{abstract}
We study the online preemptive scheduling of intervals and jobs (with
restarts).  Each interval or job has an arrival time, a deadline,
a length and a weight.  The objective is to maximize the total weight of
completed intervals or jobs.  While the deterministic case for intervals
was settled a long time ago, the randomized case remains open.  In this
paper we first give a 2-competitive randomized algorithm for the case of 
equal length intervals.  The algorithm is barely random in the sense that 
it randomly chooses between two deterministic algorithms at the 
beginning and then sticks with it thereafter.  
Then we extend the algorithm to cover several other cases of interval 
scheduling including monotone instances, C-benevolent instances and 
D-benevolent instances, giving the same competitive ratio.
These algorithms are surprisingly simple but have the best competitive 
ratio against all previous (fully or barely) randomized algorithms.  
Next we extend the idea to give
a 3-competitive algorithm for equal length jobs. 
Finally, we prove a lower bound of 2 on the competitive ratio of all 
barely random algorithms that choose between two deterministic algorithms 
for scheduling equal length intervals (and hence jobs). \\

\noindent
{\bf keywords}: 
interval and job scheduling; preemption with restart;
online algorithms; randomized; lower bound

\end{abstract}

\section{Introduction}

In this paper, we study two online preemptive scheduling problems.
In the {\em interval scheduling problem},
we are to schedule a set of weighted intervals which arrive online
(in the order of their left endpoints)
so that at any moment, at most one interval is being processed.
We can abort the interval currently being processed in order to
start a new one.
The goal is to maximize the sum of the weights of completed
intervals.
The problem can be viewed as a job scheduling problem in which
each job has, besides its weight, an arrival time, a length and a deadline.
Moreover, the deadline is always tight,
i.e., deadline always equals arrival time plus length.
Thus, if one does not start an interval immediately upon its
arrival, or if one aborts it before its completion,
that interval will never be completed.
The problem is fundamental in scheduling and
is clearly relevant to a number of online problems
such as call control and bandwidth allocation
(see e.g., \cite{ABFR94,CanIra98,Woeg94}).

We also study the more general problem of
{\em job scheduling with restart}.
Here, the deadline of a job needs not be tight and
we can abort a job and restart it from the beginning some time later.
Both problems are in fact special cases of the {\em broadcast
scheduling problem} which gains much attention recently
due to its application in video-on-demand, stock market quotation, etc
(see e.g., \cite{KimChw04,Ting06,ZFCCPW06}).
In that problem, a server holding a number of pages
receives requests from its clients and schedules the
broadcasting of its pages.
A request is satisfied if the requested page is
broadcasted in its entirety after the arrival time and 
before the deadline of the request.
The page currently being broadcasted can be aborted
in order to start a new one,
and the aborted page can be re-broadcasted from the beginning later.
Interval and job scheduling with restart can be seen
as a special case in which each request asks for a different page.

Our results concern {\em barely random} algorithms,
 i.e., randomized algorithms that randomly choose from a very small
(constant) number of deterministic algorithms at the beginning
and then stick with it thereafter.
Quite some previous work in online scheduling considered the use of
barely random algorithms (see e.g. 
\cite{Albers02,CJST07,Sei98});
it is interesting to consider how the competitiveness improves
(upon their deterministic counterparts) 
by combining just a few deterministic algorithms.
From now on, whenever we refer to ``barely random algorithms'',
we mean algorithms that choose between {\em two} deterministic algorithms
but possibly with unequal probability.

\paragraph{Types of instances.}

In this paper, we consider the following special types of intervals or jobs:
\begin{enumerate}
\item
equal length instances where all intervals or jobs have the same
length, 
\item
monotone instances where intervals arriving earlier also have
earlier deadlines, and 
\item
C- and D-benevolent instances where 
the weight of an interval is given by some `nice' function of its length
(convex increasing for C-benevolent, and decreasing for D-benevolent).
\end{enumerate}
The models will be defined precisely in the next section.
These cases are already highly non-trivial, 
as we will see shortly, and many previous works on these
problems put further restrictions on the inputs
(such as requiring jobs to be unweighted
or arrival times to be integral, in addition to being equal-length).
The power of randomization for these problems is
especially unclear.

\subsection{Previous work}

The general case where intervals can have arbitrary lengths and weights
does not admit constant competitive algorithms \cite{Woeg94}, even with 
randomization \cite{CanIra98}.  Therefore, some special types of 
instances have been studied in the literature.

We first mention results for equal length interval scheduling.
The deterministic case was settled in \cite{Woeg94} where a 
4-competitive algorithm and a matching lower bound were given.
Miyazawa and Erlebach \cite{MiyErl04} were the first to give a better
randomized algorithm: its competitive ratio is 3
but it only works for a special case where the weights of the intervals 
form a non-decreasing sequence.
They also gave the first randomized lower bound of 5/4.
The first randomized algorithm for arbitrary weight that
has competitive ratio better than 4 (the bound for deterministic
algorithms) was devised in \cite{FuPoZh07}.
It is 3.618-competitive and is barely random,
choosing between two deterministic algorithms with equal probability.
In the same paper, a lower bound of 2 for such barely random algorithms
and a lower bound of 4/3 for general randomized algorithms
were also proved.
Recently, Epstein and Levin \cite{EpsLev10} 
gave a 2.455-competitive randomized algorithm
and a 3.227-competitive barely random algorithm.
They also gave a 1.693 lower bound on the randomized competitive ratio.

The class of monotone instances (also called {\it similarly ordered}
\cite{CJST07} or {\it agreeable} \cite{LiSS05} instances in the literature)
is a generalization of the class of equal length instances.
Therefore, the former class inherits all the lower bounds for the latter
class.
In the offline case, the class of monotone instances is actually
equivalent to that of equal length instances
because of the result (see e.g. \cite{BogWes99})
that the class of proper interval graphs 
(intersection graphs of intervals where no interval is
strictly contained in another)
is equal to the class of unit interval graphs.
In the online case however, it is not completely clear that 
such an equivalence holds although some of the algorithms 
for the equal length case also work for the monotone case
(e.g. \cite{MiyErl04,FuPoZh07,EpsLev10}).

Some of the aforementioned results for equal length instances also
work for C- and D-benevolent instances, including
Woeginger's 4-competitive deterministic algorithm,
the lower bound of 4/3 in \cite{FuPoZh07}\footnote{
This and most other lower bounds for D-benevolent instances
only work for a subclass of functions that satisfy a surjective
condition.},
the upper bounds in \cite{EpsLev10} (for D-benevolent instances only)
and the lower bound in \cite{EpsLev10} (for C-benevolent instances only;
they gave another slightly weaker lower bound of 3/2 for D-benevolent
instances).
A 3.732-competitive barely random algorithm
for C-benevolent instances was given by Seiden \cite{Sei98}.  
Table \ref{tab:ResultsInt} summarizes the various upper and lower bounds
for randomized interval scheduling.

\begin{table}
\centerline{
\begin{tabular}{|c|c|c|} \hline
  & upper bound                           & lower bound              \\ \hline
equal length  
  & 2.455 \cite{EpsLev10}                 & 1.693 \cite{EpsLev10}    \\
  & 3.227 (barely random) \cite{EpsLev10} &                          \\
  & 2 (barely random) [this paper]        & 2 (barely random) [this paper] \\ \hline
monotone     
  & same as above                         & same as above            \\ \hline
C-benevolent 
  & 3.732 \cite{Sei98}                    & 1.693 \cite{EpsLev10}    \\
  & 2 (barely random) [this paper]        &                          \\ \hline
D-benevolent 
  & 2.455 \cite{EpsLev10}                 & 1.5 \cite{EpsLev10}
                                            (with a surjective condition) \\
  & 3.227 (barely random) \cite{EpsLev10} &                          \\ 
  & 2 (barely random) [this paper]        &                          \\ \hline
\end{tabular}
}
\caption{Best previous and new results for randomized interval scheduling}
\label{tab:ResultsInt}
\end{table}


Next we consider the problem of job scheduling with restarts. 
Zheng et al. \cite{ZFCCPW06} gave a 4.56-competitive deterministic algorithm. 
The algorithm was for the more general problem
of scheduling broadcasts but it works for jobs scheduling
with restarts too.
We are not aware of previous results in the randomized case.
Nevertheless, Chrobak et al. \cite{CJST07} 
considered a special case where the jobs have no weights 
and the objective is to maximize the number of completed jobs.  
For the randomized nonpreemptive case 
they gave a 5/3-competitive barely random algorithm 
and a lower bound of 3/2 for barely random algorithms that choose between
two deterministic algorithms.
They also gave an optimal 3/2-competitive
algorithm for the deterministic preemptive (with restart) case, and
a lower bound of 6/5 for the randomized preemptive case.

We can also assume that the time is discretized into unit length slots
and all (unit) jobs can only start at the beginning of each slot.
Being a special case of the problem we consider in this paper,
this version of unit job scheduling has been widely studied
and has applications in buffer management of QoS switches.
For this problem, a -competitive randomized algorithm was given
in \cite{CCFJST06},
and a randomized lower bound of 1.25 was given in \cite{ChiFun03}.  
The current best deterministic algorithm is 1.828-competitive \cite{EngWes07}.

An alternative preemption model is to allow the partially-executed job to
resume its execution from the point that it is preempted.  This was
studied, for example, in \cite{BKMMR+92,KorSha95}.

\subsection{Our results}

In this paper we give new randomized algorithms for the different
versions of the online interval scheduling problem.
They are all barely random and have a competitive ratio of 2.
Thus they substantially improve previous results. 
See Table \ref{tab:ResultsInt}.
It should be noted that although the algorithms are fairly
simple, they were not discovered in 
several previous attempts by other researchers and ourselves
\cite{EpsLev10,FuPoZh07,MiyErl04}.
Moreover the algorithms for all these versions of the problem are based on 
the same idea, which gives a unified way of analyzing these algorithms 
that were not present in previous works.

Next we extend the algorithm to the case of job scheduling (with restarts),
and prove that it is 3-competitive.
This is the first randomized algorithm we are aware of for this problem.
The extension of the algorithm is very natural but the proof is
considerably more involved.

Finally we prove a lower bound of 2 for barely random algorithms for 
scheduling equal length intervals (and jobs)
that choose between two deterministic algorithms, not necessarily with
equal probability.  Thus it matches the upper bound of 2 for this
class of barely random algorithms.
Although this lower bound does not cover more general classes of
barely random or randomized algorithms, we believe that this is still
of interest.
For example, a result of this type appeared in \cite{CJST07}.
Also, no barely random algorithm using three or more deterministic
algorithms with a better performance is known.
The proof is also much more complicated than the
one in \cite{FuPoZh07} with equal probability assumption.

\section{Preliminaries}

A {\it job}  is specified by its arrival time , its deadline , 
its length (or processing time)  and its weight .  
All  and  are nonnegative real numbers.
An {\it interval} is a job with tight deadline, i.e. .
We further introduce the following concepts for intervals: for intervals 
and  with ,  \textit{contains}  if
; if , the two
intervals \textit{overlap}; and if , the intervals
are {\it disjoint}.

Next we define the types of instances that we consider in this paper.
The {\it equal length} case is where  is the same for all ;
without loss of generality we can assume .
The remaining notions apply to intervals only.
An instance is called {\it monotone} if for any two intervals  and
, if  then .  
An instance is called {\it C-benevolent} if the weights of intervals are
given by a function  of their lengths, where the function  satisfies
the following three properties: 
\begin{description}
\item[(i)]
 and  for all , 
\item[(ii)]
 is strictly increasing, and 
\item[(iii)]
 is convex,
i.e.   for 
.
\end{description}
Finally, an instance is called {\it D-benevolent} if the weights of 
intervals are given by a function  of their lengths where
\begin{description}
\item[(i)]
 and  for any , and
\item[(ii)]
 is decreasing in .
\end{description}

In our analysis, we partition the time axis into segments called
{\it slots}, ,
such that each time instant belongs to exactly one slot
and the union of all slots cover the entire time axis.
The precise way of defining the slots depends on the case being studied 
(equal-length, monotone, C- or D-benevolent instances).
Slot  is an {\it odd slot} if  is odd, and is an
{\it even slot} otherwise.  

The following is an important, though perhaps unusual, definition 
used throughout the paper.
We say that a job (or an interval) is {\it accepted} by an algorithm  
in a slot 
if it is started by  within the duration of slot  and is then 
completed without interruption.  
Note that the completion time may well be after slot .
 may start more than one job in a slot,
but it will become clear that for all online algorithms that we consider,
at most one job will be accepted in a slot; all other jobs that were started
will be aborted.
For  we can assume that it always completes each
interval or job it starts.

The {\it value} of a schedule is the total weight of the jobs that are 
completed in the schedule.
The performance of online algorithms is measured using
competitive analysis \cite{BorElY98}.  
An online randomized algorithm  is {\it -competitive}
if the expected value obtained by  is at least 
the value obtained by the optimal offline algorithm, for any input instance.
The infimum of all such  is called the {\it competitive ratio} of .
We use  to denote the optimal algorithm (and its schedule).


\section{Algorithms for Scheduling Intervals}

\subsection{Equal Length Instances}

In this section we describe and analyse a very simple algorithm 
 for the case of equal length intervals.
 is barely random and consists of two 
deterministic algorithms  and , described as follows.  
The time axis is divided into unit length slots, ,
where slot  covers time [) for .  
Intuitively,  takes care of odd slots and  takes care of even slots.
Within each odd slot ,  starts the interval arriving first.
If a new interval arrives in this slot while an interval 
is being processed,  will abort and start the new interval 
if its weight is larger than the current interval;
otherwise the new interval is discarded.  
At the end of this slot,
 is running (or about to complete) an interval with the largest weight 
among those that arrive within ; let  denote this interval.
 then runs  to completion without abortion during the 
next (even) slot .  
(Thus,  is the only interval accepted by  in slot .)
Algorithm  then stays idle until the beginning of the next odd slot.
 runs similarly on even slots.
 chooses one of  and  with equal probability 1/2 at the beginning.

\begin{theorem}
 is -competitive for online interval scheduling on equal length 
instances.
\end{theorem}
\begin{proof}
Each  is accepted by either  or .  
Therefore,  completes each  with probability 1/2. 
On the other hand,  can accept
at most one interval in each slot ,
with weight at most .
It follows that the total value of  is at most 2 times the
expected value of .
\end{proof}

Trivial examples can show that  is not better than 2-competitive
(e.g. a single interval).  In fact we will show in Section~\ref{sec:LB} 
that no barely random 
algorithm that chooses between two deterministic algorithms is better
than 2-competitive.
But first we consider how this result can be generalized to other
types of instances.

\subsection{Monotone Instances}

\paragraph{Algorithm -.} 
We adapt the idea of  to the case of 
monotone instances and call the algorithm -.
Similar to , - consists of two deterministic algorithms  
and , each chosen to execute with probability 1/2 at the beginning.
The difference is that we cannot use the idea of unit length slots
but we must define the lengths of the slots in an online manner.

The execution of the algorithm is divided into {\em phases}
and we name the slots in each phase locally as 
independent of other phases.
After the end of a phase and before the beginning of the next phase,
the algorithm (both  and ) is idle with no pending intervals.
A new phase starts when the first interval arrives while the algorithm is 
idle.
Among all intervals that arrive at this time instant, 
let  be the one with the earliest deadline (ties broken arbitrarily).
Then slot  is defined as .
 aims to accept the heaviest interval
among those with arrival time falling within slot .
To do this,  simply starts the first interval arriving in , and
then whenever a new interval arrives that is heavier than the
interval that  is currently executing,
 aborts the current one and starts the new heavier interval.
This is repeated until the time  is reached.
By the property of monotone instances and 
the choice of ,
these intervals all have finishing time on or after .  
Let  denote the interval that  is executing (or about to complete)
at the end of slot , i.e., time .  
 remains idle during the whole slot.
If  just finishes  at time , then it will become idle again
and this phase ends.  
Otherwise,  and 
slot  is now defined as .

In slot ,  continues to execute  to completion without any 
interruption.
(Thus,  is the only interval accepted by  in slot .)
 accepts the heaviest interval among 
those with arrival time falling within slot , in the same manner 
did in the previous slot.
This interval is denoted by  and  will
run it to completion during slot 
(if its deadline is after the end of slot ).

In general, slot  (where )
is defined as .  
If  is odd, then at the beginning of slot ,
 is executing  (the interval accepted by  in slot ) 
and  is idle.
 will run  to completion while
 will accept the heaviest interval among those arriving
during this slot.
If  is even, the actions are the same except that
the roles of  and  are reversed.

\begin{theorem}
RAN-M is -competitive for online interval scheduling on monotone instances.
\end{theorem}
\begin{proof}
No interval will arrive during the idle time between phases (since otherwise
- would have started a new phase), so each phase can be analyzed 
separately. Each interval completed by  will be analyzed according
to the slot its arrival time falls into.

In each slot ,  can accept at most one interval:
This is true for  by the way  is chosen.
For ,
consider the first interval  accepted by  in slot
.
(Recall that accepting a job means starting the job and then
executing it to completion without interruption.)
Since the start of slot  is after ,
we have .
By the monotone property, .
So,  cannot accept another interval in slot .
The rest of the proof is the same as the equal length case,
namely, that the interval accepted 
by  in each slot has weight at most that of the interval
accepted by  or  in the same slot.  
It follows that - is 2-competitive.  
\end{proof}

\subsection{C-benevolent Instances}

\paragraph{Algorithm -.}
Once again, the algorithm for C-benevolent instances
- consists of two deterministic algorithms  and ,
each with probability 1/2 of being executed.
The execution of the algorithm is divided into phases as in the monotone
case.

When a new phase begins,
the earliest arriving interval, denoted by , defines the
first slot , i.e., .
(If there are several intervals arriving at the same time,
let  be the one with the longest length.)
We first describe the processing of intervals in slot ,
which is slightly different from the other slots.
First,  starts and completes .  
During ,  accepts the longest interval among those
with arrival time during  and finishing time 
after . 
Denote this interval by .
(Note that there may be other intervals that arrive and end 
before  arrives. 
Naturally,  could finish them in order to gain more value.
However, to simplify our analysis, we assume that  will not
process them.)
If there is no such ,
i.e., no interval arrives within  and ends after ,
the phase ends at the end of .

Suppose  exists.
Then define slot  as .
 uses the entire slot  to complete  without interruption.
After completing  at time , 
 accepts the longest interval (denoted )
among those arriving within slot  and finishing after ,
in a way similar to the action of  in the previous slot.
Again, if such an  does not exist, 
the phase ends at the end of .
Otherwise, slot  is defined as 
and  will complete  that ends after .
Similarly, after  finishes  in time ,
it starts the longest interval (denoted by )
arriving during  and finishing after , and so on.

In general, slot  (for ) is defined as .
If  is odd, then  takes the entire slot to complete the interval
 without interruption while  accepts the longest interval 
 that arrives during slot  and ends after .  
If  is even then the roles of  and  are reversed.

\paragraph{Competitive Analysis.}

We first state the
following useful lemma which holds for any C-benevolent function .

\begin{lemma} \label{l1}
For any C-benevolent function , given any  positive
real numbers   and , if , then .
\end{lemma}
\begin{proof}
.  
\end{proof}

\begin{theorem} 
- is -competitive for online interval scheduling on 
C-benevolent instances.
\end{theorem}
\begin{proof}
As a first step to the proof we simplify the  schedule.
Within each slot  in a phase, ,
 starts a sequence of disjoint intervals 
(in increasing order of starting times)
.
Only the last interval, , may end later than
 (the ending time of ). 
If it does, then we merge  into 
one interval  such that  and 
, and thus
.  
By Lemma \ref{l1}, . 
Otherwise, (i.e.  ends before ), we merge all 
the intervals in  into one interval  such that
 and
.  
Thus, in both cases, such merging can only make 's value larger.  
So we can assume that  starts at most two intervals  and
 in slot .
After understanding the notations, we simply denote
the two intervals  and  by  and
, respectively. 

The interval  (if exist) is contained in  and so
.
The interval  (if exist) will end after ,
and  
since  is defined to be the longest interval that arrives
during slot  and ends after .
Note that  may also end after  for some . 
In this case, neither  nor  exist 
for . 
If any  or  does not exist,
we set its length to zero. 


We now analyze the competitive ratio of -.
As in the monotone case, each phase can be analyzed separately.
Consider an arbitrary schedule
 produced by - in a phase
with  slots, where  overlaps  , 
and the corresponding schedule

produced by  as - produces .
(Note that 
 cannot
exist since otherwise this means there are some intervals that arrive 
within  and end after , and hence 
the phase will not end and - will start an .)

For each slot ,  starts two intervals  and
 while - accepts . 
For presentation convenience,
let , 
and . 
We already have that
 for  
and  for .
We will show that 


The left hand side of (\ref{eqn:main}) represents the total weight of 
intervals in  (note that  does not exist)
while the right hand side represents the total weight of intervals in
. 
Since - completes each interval in  with probability 1/2,
its expected value is half of the right hand side of (\ref{eqn:main}).
Thus by proving (\ref{eqn:main}) we show the 2-competitiveness
of -.

We prove (\ref{eqn:main}) by induction on .
When , (\ref{eqn:main}) reduces to  
which is true since .
Assume the claim holds for , i.e.,
.
Consider ,  and .
We have  and .
If , then 
.
Adding this to the induction hypothesis gives

and thus the claim holds for .

Otherwise, if , we first change the schedule
 as follows: we increase the length of
 to  and decrease the length of  by the
same amount.  The corresponding  and  are
fixed while both  and  decrease by an amount
of .  
 will only get better since

by the properties of C-benevolent functions. 
After this change,  and  have the same length.
The new  now ends on or before .
We merge the new  into  so that the new 
extends its length to  and keeps its start time
 unchanged.  In the case that
 before merging , we set
.
The new  is still contained by 
and thus  still holds.
After merging,  and .  
Therefore
.
Thus the claim is true for .  
\end{proof}

\subsection{D-benevolent Instances}

\paragraph{Algorithm -.}
The basic idea of - is same as : 
two algorithms  or  are executed each with probability 1/2.
Intuitively, in an odd slot (where slots will be defined precisely 
in the following paragraphs), 
 accepts the largest-weight interval arriving during that slot, 
by starting an interval
and preempting if a new one arrives with a larger weight. We call the
interval being executed by  the {\it main interval}, denoted by . 
Meanwhile, 
continues to run to completion the interval started in the previous slot;
we call this the {\it residual interval}, denoted by .
This residual interval must be completed 
(as in the equal length case) because this is the interval accepted in the
previous slot. However in the D-benevolent case, 
if a shorter (and therefore larger weight) interval arrives, 
the residual interval can actually be preempted and replaced by this new
interval.  
For even slots the roles of  and  are reversed (and the interval
started by  is the main interval and the one completed by  the
residual interval).

Unlike - or -, here when slot  finishes, 
the next slot  is not completely determined: 
slot  begins where  ends,
but the ending time of slot  will only get a provisional value, 
which may become smaller (but not larger) later on. 
This is called the {\it provisional ending time} of the slot, 
denoted by .
Slots will also be grouped into phases as in the other types of instances.

Note that ,  and  change during the execution of the
algorithm, even within the same slot. 
But - always maintains the following invariant:

\begin{quote}
{\bf Invariant:} 
Suppose  and  are the residual and main interval respectively
during execution in a slot .
Then  (if the intervals exist).
Moreover  can only be decreased, not increased.
\end{quote}

We describe the processing of intervals in a slot  ().
Consider an odd slot  (the case of even slots is the same with the
roles of  and  reversed).
At the beginning of ,  is idle and 
 is continuing the execution of a residual interval . 
At this point  is provisionally set to .
In the case of the first slot, there is no residual interval left over
from the previous slot, so we set  to be the deadline of the first
interval that arrives. If more than one interval arrive at the same instant,
choose anyone.
 
Consider a time during  when an interval  arrives while
 and  are respectively executing some intervals  and .
If more than one interval arrive at the same instant, process them in any
order.
If  or  is idle, assume  or  to have weight 0.
Then  and  react according to the following three cases:

\begin{enumerate}
\item
If  and ,
then  preempts , and this  becomes the new .
In this case,  remains unchanged.
\item
If  (which implies  and 
because by the invariant, , 
and  arrives no earlier than either  or , 
and thus  is shorter),
then  preempts both  in  and  in .
Here  becomes the new  and , and
 is then set to .  
\item
Otherwise,  and  is discarded.
\end{enumerate}

Observe that the invariant is always maintained when we change any of ,
 or .

This process repeats until time  is reached and slot  ends.
If  at the end of slot , then a new slot  begins 
where slot  ends.
 has not finished execution of  yet, so it
now becomes the  of slot , and
 is provisionally set to .
Otherwise,  and  just finishes execution of , 
then the phase ends. 
In this case we wait until the next interval 
arrival, then a new phase starts.

Note that - needs to simulate the execution of both  and 
(to determine when slots end) but the actual execution follows only one 
of them.

\begin{theorem}
- is -competitive for online interval scheduling on
D-benevolent instances.
\end{theorem}
\begin{proof}
Consider each slot .
We claim that  can start at most one interval in 
and that this interval cannot finish strictly before .
The first part of the claim follows from the second since
if  starts two or more intervals within , then the first 
such interval must end strictly before . 
Assume to the contrary that  starts an interval  that finishes
strictly before . 
Then  also finishes strictly before the provisional value of  
at the moment  arrives, since the provisional ending time only decreases.
By the design of the algorithm, at that point
 will be reduced to . 
 may be reduced further subsequently, but in any case this contradicts
the fact that .
Hence the claim follows.

Now suppose  starts an interval  in an odd slot  and eventually
completes it.
We will show that if  is not the last slot in the phase, 
 will complete an interval of weight no less than  in slot ;
if  is the last slot, then  will complete an interval of weight
no less than  in slot .

Consider the moment when  arrives in .
If  has larger weight than the current ,
 will preempt it and start .
Thus, by the end of ,
 should have started a main interval  of weight at least .
If this is the last slot, then  completes  at the end of .
Otherwise,  becomes the residual interval in slot 
and  will execute it to completion (as an residual interval) in 
unless another interval  arrives in  such that 
 (and hence ).
Note that  will then be reduced to .
This  may still be preempted by intervals of even larger weight
and earlier deadline.
In any case, at exactly the end of the next slot ,
 would have completed the residual interval.

We can make a similar claim for even slots.
Therefore it follows that, for every interval started by , 
either  or  will complete an interval of at least the same weight 
in the same or the next slot.
Thus the total value of  and  is no less than that of .
The 2-competitiveness then follows since each of A/B is executed with
1/2 probability.  
\end{proof}

\section{Algorithms for Equal Length Jobs}

\paragraph{Algorithm -.}
In this section we extend  to the online scheduling of 
equal length jobs with restarts.
The algorithm remains very simple but the analysis is more involved.
Again - chooses between two deterministic algorithms  and , 
each with probability 1/2, and again
 takes care of odd slots and  takes care of even slots,
where the slots are defined as in the equal length interval case
(i.e. they all have unit length).  
At the beginning of each odd slot,  considers all pending jobs that can 
still be completed, and starts the one with the largest weight.
(If there are multiple jobs with the same maximum weight, start an 
arbitrary one.)
If another job of a larger weight arrives within the slot, 
 aborts the current job and starts the new one instead.  
At the end of this odd slot, the job that is being executed will run to
completion (into the following even slot) without abortion.
 will then stay idle until the beginning of the next odd slot.
Even slots are handled by  similarly.

The following simple example (see Figure \ref{fig:ran-j}(a))  
illustrates the algorithm, and shows that 
- is not better than 3-competitive. 
Consider three jobs , where  for
arbitrary small ;
; and
.
Both  and  will complete  only, but  can complete all three.

\paragraph{Notations.}
We define some additional notations that will be used in the rest of 
this section to make our discussion clearer.
The notation  denotes a range of slots 
from slot  to  inclusive, where  is before .
Arithmetic operators on slots carry the natural meaning,
so  is the slot immediately after ,
 is the slot immediately before , 
means  is before , etc.
The job accepted by an algorithm  in slot  is denoted by .
(Any algorithm can accept at most one job in each slot since the slot has
the same length as a job.)
We define the inverse  to be the slot  with , 
if it exists; otherwise it is undefined.

\paragraph{Charging scheme.}
Our approach to the proof is to map (or charge) the weights of jobs 
accepted by  to slots where  or  have accepted `sufficiently
heavy' jobs; namely, that each slot  
receives a charge at most 1.5 times of  or .
In some cases this is not possible and we pair up slots with large charges
with slots with small charges so that the overall ratio is still at most
1.5.  Since each job in  or  is completed with probability 1/2 only,
the expected value of the online algorithm is half the total value of 
 and .  This gives a competitiveness of 3.

The charging scheme is defined as follows.
Consider a slot  where  accepts the job .
Suppose  is odd (so  is choosing the heaviest job to start).
If , charge the weight of  to .
We call this a {\it downward charge}.
Otherwise,  must have 
accepted  at some earlier slot .
Charge half the weight of  to this slot .
This is called a {\it self charge}.
For , either it has accepted the job  before , 
in which case we charge the remaining half to that slot
(this is also a self charge);
or  is still pending at slot , which means at slot , 
 accepts a job with weight at least .
Charge the remaining half to the slot .
This is called a {\it backward charge}.
When  is an even slot the charges are similarly defined.

\begin{figure}
\centerline{ \epsfysize=2in \epsffile{ran-j.eps} }
\caption{(a) An example showing - is not better than 3-competitive.
(b) An example showing the charges and a bad slot.
The weight of the jobs are (for small ):
;
. Slot 4 is a bad slot.}
\label{fig:ran-j}
\end{figure}

Clearly, all job weights in  are charged to some slots.
Observe that for each charge from  to a slot,
the weight of the job generating the charge is no more than
that of the job accepted in the slot receiving the charge.
We define each downward charge to be of one {\it unit}, and each self
or backward charge to be of 0.5 unit.
With this definition, if every slot receives at most 1.5 units of charge, 
then we are done.
Unfortunately, slots can receive up to 2 units of charges
because a slot can receive at most one charge of each type.
Slots receiving 2 units of charges are called {\it bad}; they must receive
a backward charge.
Slots with at most 1 unit charge are called {\it good}.  
Each bad slot  can be characterized by a pair  where  is the 
job  or , and  is the job  generating the backward
charge.
The example in Figure \ref{fig:ran-j}(b) illustrates the charges 
and the existence of bad slots.

\paragraph{Competitive Analysis.}

The key part of the proof is to deal with bad slots.
For each bad slot, we pair it up with a good slot 
so that the `overall' charge is still under a ratio of 1.5.
The proof of the following lemma will show how this is done. 


\begin{lemma} \label{lem:match-slots}
For each bad slot , there is a good slot  such that 
the weight of  or  is at least .  
Moreover, any two bad slots are paired with different good slots.
\end{lemma}

If Lemma~\ref{lem:match-slots} is true, then we have

\begin{lemma}
Slots  and  as defined in Lemma~\ref{lem:match-slots} together 
receive a charge at most  times the total weight of the jobs in 
in the two slots.
\end{lemma}
\begin{proof}
Let  and  be the weight of jobs accepted by  in  and 
respectively.
The charges to  is at most  while the charges to 
is at most .  The overall ratio is therefore

since . 
\end{proof}

\begin{theorem}
- is -competitive for the online scheduling of equal length jobs 
with restarts.
\end{theorem}
\begin{proof}
All the weights of jobs accepted by  
are charged to slots in  or .
Each slot in  and  receives charges at most 1.5 times the weight
of the job in the slot,
either as a single slot or as a pair of slots as defined in 
Lemma~\ref{lem:match-slots}.  
Since each job in  or  is only completed 
with probability 1/2, the expected value of the online algorithm is half the
total weight of jobs in  and .  
It follows that the competitive ratio is 3. 
\end{proof}

Before proving Lemma~\ref{lem:match-slots}
we first show some properties of bad slots in the following
lemma.  (Although the lemma is stated in terms of odd slots,
the case of even slots is similar.)

\begin{lemma} \label{lem:badslot}
For each bad slot , where  is an odd slot,
\begin{description}
\item[(i)]
both  and  are accepted
by  in some slots before  (call the slots 
and , where ); and
\item[(ii)]
for each odd slot  in ,
, and
for each odd slot  in ,
.
\end{description}
\end{lemma}
\begin{proof}
(i) Since slot  makes a backward charge
instead of a downward charge, we have .  
Hence  must have accepted  before ,
or else  could have been a candidate for .
Furthermore, .
By the same reasoning,  must have accepted  before .

\noindent (ii)
If , then  has already arrived before the end of 
slot  but is not accepted by  at/before .
Hence  must have accepted jobs with weights at least 
in all odd slots in [].
If  then the same reasoning implies that 
 accepted jobs with weights at least , which is at
least , in these slots.
The same argument holds for []. \end{proof}

We now prove Lemma~\ref{lem:match-slots}.
We give a step-by-step procedure for identifying a good slot 
(in which  or  has accepted a job of sufficient weight) 
for every bad slot.
Consider an odd bad slot . (The case for even slots
is similar.)  
Roughly speaking, the procedure initially identifies the two slots
 and  defined in Lemma \ref{lem:badslot}
and designates  as a {\em special slot}, denoted by .
Then it checks if  or  is a good slot.
If a good slot is found, the procedure stops.
Otherwise, it will identify a new slot not found before,
pick a new special slot  from among the
identified slots;
and then move to the next step (which checks on , 
and so on).

In more detail, at the beginning of step  (),
a collection of  slots, ,
have been identified.
They are all even slots before the bad slot  and
one of them is designated as the special slot .
Denote by  the job  for all
 and for convenience, let
 denote .
Step  proceeds as follows:
\begin{description}
\item[{\rm Step .1.}] 
Consider the job  in slot .
By Lemma \ref{lem:A-weights}(i) below,
 has weight at least .
So, if the slot  receives at most 1 unit of charge,
then we have identified a good slot of sufficient weight
and we stop.

\item[{\rm Step .2.}] 
Otherwise,  has at least 1.5 unit of charge
and must therefore have a downward charge.
Denote by  the job .
By Lemma \ref{lem:A-weights}(ii) below, .
Since slot  must have a downward charge,
slot  cannot receive a backward charge.
If slot  receives no self charge as well, 
then it is a good slot and we are done.  

\item[{\rm Step .3.}]
Otherwise  receives a self charge and hence  is
accepted by  in some slot  after .
In Lemma \ref{lem:case3}, we will show that  must also
accept  at a slot  where .
Note that  is not in .
(A job in   is either the
job , which is not accepted by  before slot ,
or a job accepted by  in a slot other than
.)
Therefore,  is a different slot than 
.

Mark slot  or , whichever is later,
as the new special slot .
Re-index  and 
as  and
move on to Step ().
\end{description}

We need to show that
(i) the procedure always terminates,
(ii) the claims made in the above procedure are correct, and
(iii) any two bad slots are paired with different good slots
following this procedure.  
The first is easy: note that in each step, 
if a good slot is not found, a new slot, ,
which is before , is identified instead.
But there are only a finite number of slots before . 
Therefore, the procedure must eventually terminate and
return a good slot.

The claim in Step .1 and .2 is proved in the lemma below,
which is basically a generalization of Lemma~\ref{lem:badslot}.

\begin{lemma} \label{lem:A-weights}
For any step  () and any , 
\begin{description}
\item[(i)]

and
\item[(ii)]
for all odd slots  in ,
.
\end{description}
\end{lemma}

\begin{proof}
The proof is by induction on .
Clearly, (i) and (ii) are true for 
as proved by Lemma \ref{lem:badslot}.
Suppose (i) and (ii) are true at the beginning
of some step .
We will show that they are maintained
at the beginning of step .

Recall that  is accepted by  in slot
 and by  in slot .
By (ii), .
Thus,  and hence
(i) is maintained in the next step.

To show that (ii) is also maintained in the next step,
it suffices to show that for any odd slot
 in 
where  is the closest slot among
 after 
(or  if  lies after ), 
.
We consider two cases:

If ,
then  is available before the end of slot  and yet
is not accepted by  until .
See Figure \ref{fig:induction}(a).
Therefore, 
for every .

\begin{figure}[h]
\centerline{ \epsfysize=5cm \epsffile{induction-j.eps} }
\caption{Positions of  and  in  and .}
\label{fig:induction}
\end{figure}

If ,
then let  be the closest slot among
 before .
See Figure \ref{fig:induction}(b).
Such slot must exist because  is
one such candidate.
Then  or else  would
have been accepted in slot .
Therefore, 
for every odd slot .  
\end{proof}


\begin{lemma} \label{lem:case3}
In Step .3,  accepts  in a slot  where .
\end{lemma}
\begin{proof}
First notice that .
Therefore, 
or else  would have been a candidate for slot .

Now we assume that  and show that .
We distinguish two cases.

Case i.   is an odd slot.  
Let .
Let  be the slot in 
that is closest to and before  
(which must exist because  itself is a candidate).
Note that  must be before  since it must be 
before  and immediately before one of the 's
(in this case ), and  is the latest such
's before .  

\begin{figure}[h]
\centerline{ \epsfysize=1in \epsffile{s3.eps} }
\label{fig:s3}
\end{figure}

We have  since a self charge is made instead of a 
downward charge.
By Lemma \ref{lem:A-weights}(ii), .  
Therefore .
Hence  must be accepted before  
in  or else it can take 's place in .
By definition of , .
Hence .

Case ii.   is an even slot. 
Let .
Then  due to no downward charge in slot .  
Thus  must have accepted
 before , i.e., .

So in all cases  accepts  at some slot . 
\end{proof}


Finally, the lemma below shows that
two bad slots are paired with different good slots.

\begin{lemma} \label{lem:distinct}
All bad slots are paired with different good slots.
\end{lemma}
\begin{proof}
There are two possible places in our procedure where good slots can be
identified: in Step .1 or in Step .2 for some  and .
Call them substeps 1 and 2.
Note that, for an odd bad slot, good slots identified in substep 1 are 
always when  is accepting jobs, and good slot identified in substep 2 are 
always when  is accepting jobs, and vice versa for even bad slots.

Consider two distinct bad slots  and .
First, consider the case when  and  has different parity
(odd or even slots). 
Then they can match with the same good slot only if one of them identifies it 
in substep 1 and the other in substep 2.
However, a good slot in substep 1 must receive self-charge (this is how the 
's are identified) while a good slot in substep 2
cannot receive a self charge (otherwise we would have moved on to some 
Step .3 in the procedure).  
Thus it is impossible that a substep 1 good slot is
also a substep 2 good slot.

Next, consider the case when  and  are of the same parity.
Without loss of generality assume that they are both odd slots.
To facilitate our discussion, we re-index the 's in the order
they are identified.
So we let  be the chain of 's associated with 
where 
and for ,  is the job identified in step .3.
Similarly, we let  be the chain associated with .
We will show that
no job appears in both chains.
This proves the claim because
for two bad slots of the same parity to be matched to the same good slot,
they must both be identified in substep 1 or both in substep 2.
But if the chains of 's associated with them are different,
this is not possible.

To show the chains are distinct,
we first show that  and  are all distinct.
Recall that  and .
Clearly  and .
Thus we only need to show that  and .
If this is not true, then either:
(1)  is accepted in  in a bad slot; or
(2)  in  generates a backward charge.  
For (1), if , then  
would not make a backward charge to ; while if
, then  cannot get a self 
charge and hence receives at most 1.5 units of charge.
For (2),  due to the self charge to slot , and 
by Lemma~\ref{lem:badslot}(i),  must also be accepted in  before .  
Hence  cannot generate a backward charge.
Thus neither (1) nor (2) can be true.

We have now established that  and  are all different.
It is also clear that  and  for any  and .
Note that, if , for some  and , 
then there must be some  and  such that ,
because they are uniquely defined in such a way (in some substep 2). 
So the only remaining case to consider is  or  being the same 
as  for some . 
Recall  and  are the  and  of . 
 cannot be 
because by Lemma \ref{lem:case3},
both  and  accept  before  does
but  accepts  after . 
 cannot be  because this would mean the job  is  for 
some , so slot  should receive a downward charge 
but this contradicts that  makes a backward charge to  
instead of a downward charge. 
\end{proof}

\section{Lower Bound for Equal Length Intervals}
  \label{sec:LB}

In this section, we show a lower bound of 2 for barely
random algorithms for scheduling equal length intervals
that choose between two deterministic algorithms,
possibly with unequal probability.

\begin{theorem}
No barely random algorithm choosing between two deterministic algorithms
for the online scheduling of equal length intervals
has a competitive ratio better than .
\end{theorem}

Let  be a barely random algorithm that chooses between 
two deterministic algorithms  and  with 
probability  and  respectively
such that  and .
Let  be an arbitrarily small positive constant
less than 1.
We will show that there is an input on which 
gains at least  times of what  gains.

We will be using sets of intervals similar to
that in Woeginger \cite{Woeg94}.
More formally, let  be an arbitrary positive real number
and let  be any pair of real numbers such that
. 
We define  as a set of intervals of weight 
 
(where  is the largest number 
such that  and 
 is a multiple of )
and their relative arrival times are such that
intervals of smaller weight come earlier
and the last interval
(i.e., the one that arrives last and has weight )
arrives before the first interval finishes.
Thus, there is overlapping between any pair of
intervals in the set.
See Figure~\ref{fig:set}.
This presents a difficulty for the online algorithm
as it has to choose the right interval to process
without knowledge of the future.

\begin{figure}
\centerline{ \epsfysize=1.2in \epsffile{set.eps} }
\caption{.  On the left is the actual set of 
intervals; the vertical arrow on the right is the notation we use to denote 
such a set.}
\label{fig:set}
\end{figure}

To facilitate our discussion, 
we assume that all intervals have weight at least 1
throughout this section, except Section \ref{subsec:ylarge}.
If  is an interval in  and 
(i.e.,  is not the earliest interval in the set),
then  denotes the interval
that arrives just before  in .
So, .

\subsection{A Few Simple Cases}

We first present a few simple situations in which  can gain
a lot compared with what  can gain.
The first lemma shows that an algorithm should not start an interval
that is lighter than the current interval being processed by the
other algorithm.
The second lemma shows that it is not good to have
 processing an interval of equal or heavier weight
than the interval currently being processed by .
Moreover, the two algorithms should avoid processing
almost non-overlapping intervals
as shown in the third lemma.

\begin{lemma} \label{lem:YEarly}
Suppose at some moment,
one of the algorithms (say ) is processing
an interval  from a set 
while the other algorithm () is processing
another interval ,
where ,  and .
(Note that here the interval  cannot come from .)
Then  gains at least  of 's
gain on an input consisting of
,  and some subsequently arrived intervals.
\end{lemma}

\begin{proof}
We illustrate the scenario in Figure \ref{fig:yearly}.
(There, the vertical line represents the set  
and the horizontal line labelled  is one of the intervals
in .
The horizontal line labelled  arrives later than 
and has a smaller weight.)
To defeat , 
an interval  with the same weight as  is released
between  and 
and no more intervals are released.
(See Figure \ref{fig:yearly}.)
Then  completes  (which finishes just before  starts)
and , gaining  
while  gains at most  even if
it aborts  to start .
Since , .
\end{proof}

\begin{figure}
\centerline{ \epsfysize=0.9in \epsffile{yearly.eps} }
\caption{(Lemma \ref{lem:YEarly}) Starting a lighter interval later}
\label{fig:yearly}
\end{figure}

\begin{lemma} \label{lem:AHeavy}
Suppose at some moment, 
algorithm  is processing an interval  from
a set 
while  is processing an interval  from
a set ,
where , , 
and .
(Note that  and  can be the same set;
 and  can even be the same interval.)
Then  gains at least 
of 's gain on an input consisting of , 
and some subsequently arrived intervals.
\end{lemma}

\begin{proof}
An interval  with the same weight as  is released
between  and .
See Figure \ref{fig:aheavy}.
Clearly there is no point in algorithm  aborting  to
start .
If algorithm  continues with ,
then no more intervals arrived.
 gains 
while  gains  .
Since ,
we have .
If  aborts  and starts ,
then using Lemma \ref{lem:YEarly}, we can see that
 gains at least  of what  gains
on an input consisting of ,  and the subsequently
arrived intervals specified in Lemma \ref{lem:YEarly}.
\end{proof}

\begin{figure}
\centerline{ \epsfysize=0.9in \epsffile{aheavy.eps} }
\caption{(Lemma \ref{lem:AHeavy})  processing a heavier interval ()}
\label{fig:aheavy}
\end{figure}

\begin{lemma} \label{lem:ABSeparate}
Suppose at some moment, 
algorithm  is processing an interval  from
a set  
while algorithm  is processing an interval  from
another set , where ,
, 
and the intervals of  arrive between  and .
Then  gains at least  of 's
gain on an input consisting of
,  and some subsequently arrived intervals.
in the worst case.
\end{lemma}

\begin{proof}
An interval  with the same weight as  is
released between  and 
and no more intervals are released.
See Figure \ref{fig:abseparate}.
OPT completes  in ,  in  and .
So it gains 
.
On the other hand,  completes  and then 
while  completes .
Thus  gains at most 
.
Since , we have

.
\end{proof}

\begin{figure}
\centerline{ \epsfysize=0.9in \epsffile{abseparate.eps} }
\caption{(Lemma \ref{lem:ABSeparate})  and  processing
almost non-overlapping intervals}
\label{fig:abseparate}
\end{figure}

\subsection{Constructing the Sequence of Intervals}

Our lower bound proof takes a number of steps.
In each step, the adversary will release some set of intervals
 adaptively according to how  reacts
in the previous steps.
In each step, the adversary forces  not to finish any interval 
(and hence gain no value) while  will gain some.
Eventually,  will accumulate at least  times of
what  can gain no matter what  does in the last step.

\subsubsection{Step 1}
  \label{subsec:step1}

Let .
The adversary releases 
where  is some positive real number at least one,
 and .
Denote by  and , where ,
the intervals chosen by .
We claim that

\begin{lemma} \label{lem:x1>v1}
Both algorithms  and  do not process the smallest-weight
interval in , i.e.,
\begin{description}
\item[{\rm (i)}]
 and
\item[{\rm (ii)}]
.
\end{description}
Hence both  and  exist.
\end{lemma}

\begin{proof}
We first prove part (ii).
By Lemma \ref{lem:AHeavy}, we assume that  is processed by 
and  is processed by .
So, the expected gain by  is  .
Then we deduce that  or else the adversary stops,
 schedules the heaviest interval in  (of weight )
so that it gains at least  times the expected gain
by . 
Since  ,
we have .

To prove part (i), we assume to the contrary that .
Then an interval  with the same weight as 
is released between  and .
See Figure \ref{fig:step1}(a).
 can gain 
by executing  in  and then .
Upon finishing , algorithm  can go on to finish .
The expected gain of  is at most

.
Note that 

and  .
Thus 's gain is at most
 . 
So 's gain is more than  times that of
's.
\end{proof}

\begin{figure}
\centerline{ \epsfysize=1.1in \epsffile{i1small.eps} 
             \hspace{0.8in}
             \epsfysize=1.40in \epsffile{set2.eps} }
\caption{Step 1. (left) Lemma \ref{lem:x1>v1}, 
  (right) Lemma \ref{lem:mustmoveon} }
\label{fig:step1}
\end{figure}

\begin{lemma} \label{lem:case1}
.
\end{lemma}

We defer this to Section \ref{subsec:ylarge},
where we prove that if  then the adversary
can force the competitive ratio to be at least .

The adversary then releases a new set of intervals 

such that all these intervals arrive between
 and ,
where ,

and .
See Figure \ref{fig:step1}(b).

\begin{lemma} \label{lem:mustmoveon}
Upon the release of , 
both  and  must abort their current intervals in 
and start some intervals  and  respectively in .
Moreover, .
\end{lemma}
\begin{proof}
If  ignores  and continues with both  and ,
then the expected gain of  is 
while  can complete  and the last interval in ,
gaining   

.

Suppose algorithm  aborts  and starts some  in
 while algorithm  continues to process .
Then by Lemma \ref{lem:ABSeparate},  loses.
Suppose algorithm  continues with  but 
 aborts  to start some  in .
By Lemma \ref{lem:AHeavy}, it must be the case that
.
But then by Lemma \ref{lem:YEarly},  loses too.

Based on the above discussion, 
the only remaining sensible response for 
is to abort both  and 
and start some  and  in .
By Lemma \ref{lem:AHeavy},
we can further assume that .
Moreover, we claim that .
Otherwise,  is effectively aborting only  but not .
Then the construction of inputs given in Lemma \ref{lem:ABSeparate}
can be used to defeat .
\end{proof}

This finishes our discussion on Step 1 and we now proceed to Step 2.

\subsubsection{Step }

In general, at the beginning of Step ,
we have the following situation:
 has gained 
while  has not gained anything yet.
Moreover,  and  of  
are respectively executing  and 
in  
where , 
,

and .
We go through a similar analysis to that in Step 1.

First, as in Lemma \ref{lem:case1}, we have 
(the case  is handled in the next subsection). 
Next, the adversary releases  
in the period between  and 
where ,

and .
See Figure \ref{fig:stepi}.

\begin{figure}
\centerline{ \epsfysize=1.3in \epsffile{stepi.eps} }
\caption{Step }
\label{fig:stepi}
\end{figure}

Similar to Lemma \ref{lem:mustmoveon}, we can prove that

\begin{lemma} 
Upon the release of ,
both  and  must abort their current intervals in 
and start some intervals  and  respectively in .
Moreover, .
\end{lemma}

\begin{proof}
 cannot continue with both  and .
Otherwise,  schedules (after finishing )
 and then the last interval of ,
thus gaining at least


Suppose  aborts  in order to start some  in  
while  continues with .
Then by Lemma \ref{lem:ABSeparate},  loses.
Suppose  continues with  while
 aborts  to start .
By Lemma~\ref{lem:AHeavy}, we have that .
Then by Lemma \ref{lem:YEarly},  loses too.

Based on the above reasoning, we conclude that  has to abort
both  and  and start some  and  in .
By Lemma \ref{lem:AHeavy}, we can assume that .
We can also argue that  in the same way as proving
 in Step 1.
\end{proof}

We now proceed to Step .
Note that  has already gained
 while  still has not gained anything.
We will make use of Lemma 4.3 of Woeginger \cite{Woeg94}:

\begin{lemma} \label{lem:woeg}
(Woeginger \cite{Woeg94}).
For , any strictly increasing sequence of positive
numbers  fulfilling
the inequality
  
for every  must be finite.
\end{lemma} 

Consider the sequence .
It is strictly increasing since  for all .
Moreover, recall that  is set to be the maximum of either
 or .
If 
for all ,
then we have 




(since ) for all .
The existence of such an infinite sequence contradicts Lemma \ref{lem:woeg}.
So, eventually, there is a finite  such that 

and hence we set  and the next (and final)
set  consists of a single interval of weight 
().

In that situation, it makes no difference whether  or  of 
aborts  or  to start the interval in 
since it has weight equal to .
Its expected gain is still at most .
On the other hand,  schedules the interval of 
and gains in total 
 which is
at least  times of 's gain.

\subsection{The Case of } 
  \label{subsec:ylarge}

We now consider the case where in some Step ,
.
We will show how the adversary forces  to lose the game,
i.e.,  will gain at least  of what  can
on  and a set of subsequently arrived intervals.
For simplicity, we drop the subscript  in , , and
 in the following discussion.

Intuitively, when  is relatively large compared with ,
we can afford to let algorithm  finish the interval 
and gain , which is relatively small.
Therefore, a set  is released 
between  and ,
where  is some parameter to be determined
as a function of .
This allows algorithm  to finish  and then start
some job in this new set .
On the other hand, algorithm  has to decide whether to
abort or continue with the current interval .
We will show that there is a choice of  such that no matter
what  does,  can gain at least  of what 
gains.

\paragraph{Case 1: Algorithm  continues with .}

Then  gains at most 
while  can gain .
Therefore, the ratio of the gain by  to that of 
on  and  is at least

where the first inequality makes use of the condition that
.
This ratio is at least  provided

After simplifying using ,
this condition is satisfied by having


\paragraph{Case 2: Algorithm  aborts .}

Then algorithms  and  can start some intervals
 and  in .
By Lemma \ref{lem:AHeavy},
we can assume that .
Then another interval  with the same weight as  
is released between  and .

If  aborts  to start ,
by Lemma \ref{lem:YEarly},  gains at least
 of 's gain on  and a set of subsequently
arrived intervals.
Also, on the set of intervals ,
 gains  while  gains at least 
 .
So  loses.

On the other hand, if  does not abort ,
then its expected gain is at most 
.
 will complete  in ,
 in  and then .
(Note that if  is the first interval with weight 0
in , then we set  to be of weight 0 too.)
The ratio of the gain by  to that of  
on ,  and  is at least

Since , it suffices to show that

is at least .
Furthermore,  and
 .
Therefore, the fraction , as a function of ,
is minimized when  is maximized.
That means,

Observe that 

 
using  and .
Thus 
because .
Hence to show that , it suffices to
show that .
This condition is satisfied provided

or

This is satisfied if

i.e.,

By setting

both ineq. (1) and ineq. (2) are satsified.
This completes the proof for the case of .


\section{Conclusion}

In this paper, we designed 2-competitive barely random algorithms
for various versions of preemptive scheduling of intervals.
They are surprisingly simple and yet improved upon previous best
results.
Based on the same approach, we designed a 3-competitive algorithm
for the preemptive (with restart) scheduling of equal length jobs.
This is the first randomized algorithm for this problem.
Finally, we gave a 2 lower bound for barely random algorithms
that choose between two deterministic algorithms, possibly
with unequal probability.

An obvious open problem is to close the gap between the upper and
lower bounds for randomized preemptive scheduling of intervals
in the various cases.
We conjecture that the true competitive ratio is 2.
Also, it is interesting to prove a randomized lower bound for
the related problem of job scheduling with restart.


\bibliographystyle{alpha}




\begin{thebibliography}{10}

\bibitem{Albers02} S. Albers.
\newblock On randomized online scheduling.
\newblock In {\em Proc. 34th ACM Symposium on Theory of Computing},
134--143, 2002.

\bibitem{ABFR94}
B. Awerbuch, Y. Bartal, A. Fiat, and A. Rosen.
\newblock Competitive non-preemptive call control.
\newblock In {\em Proc. 5th ACM-SIAM Symposium on Discrete
  Algorithms}, 312--320, 1994.

\bibitem{BKMMR+92}
S.~Baruah, G.~Koren, D.~Mao, B.~Mishra, A.~Raghunathan, L.~Rosier, D.~Shasha,
  and F.~Wang.
\newblock On the competitiveness of on-line real-time task scheduling.
\newblock {\em Real-Time Systems}, 4:125--144, 1992.

\bibitem{BogWes99}
K. P. Bogart and D. B. West.
\newblock A short proof that `Proper = Unit'.
\newblock {\em Discrete Mathematics}, 201:21--23, 1999.

\bibitem{BorElY98}
A. Borodin and R. El-Yaniv.
\newblock Online Computation and Competitive Analysis.
\newblock {\em Cambridge University Press}, New York, 1998.

\bibitem{CanIra98}
R. Canetti and S. Irani.
\newblock Bounding the power of preemption in randomized scheduling.
\newblock {\em SIAM Journal on Computing}, 27(4):993--1015, 1998.

\bibitem{CCFJST06}
F. Y. L. Chin, M. Chrobak, S. P. Y. Fung, W. Jawor,
J. Sgall and T. Tich\'y.
\newblock Online competitive algorithms for maximizing weighted throughput 
of unit jobs.
\newblock {\em Journal of Discrete Algorithms}, 4(2):255--276, 2006.

\bibitem{ChiFun03}
F. Y. L. Chin and S. P. Y. Fung.
\newblock Online scheduling with partial job values: does
timesharing or randomization help?
\newblock {\em Algorithmica}, 37(3):149--164, 2003.

\bibitem{CJST07}
M. Chrobak, W. Jawor, J. Sgall and T. Tich\'y.
\newblock Online scheduling of equal-length jobs: randomization and restarts 
help. 
\newblock {\em SIAM Journal on Computing} 36(6):1709--1728, 2007.





\bibitem{EngWes07}
M. Englert and M. Westermann.
\newblock Considering suppressed packets improves buffer management
in QoS switches.
\newblock In {\em Proc. 18th ACM-SIAM Symposium on Discrete Algorithms}, 
209--218, 2007.

\bibitem{EpsLev10}
L. Epstein and A. Levin.
\newblock Improved randomized results for the interval selection problem.
\newblock {\em Theoretical Computer Science}, 411(34-36):3129--3135,
2010.

\bibitem{FuPoZh07}
S. P.~Y. Fung, C.~K. Poon and F. Zheng,
\newblock Online interval scheduling: randomized and multiprocessor cases.
\newblock In {\em Proc. 13th International Computing and Combinatorics
Conference}, LNCS 4598, 176--186, 2007.

\bibitem{KimChw04}
J.-H. Kim and K.-Y. Chwa.
\newblock Scheduling broadcasts with deadlines.
\newblock {\em Theoretical Computer Science}, 325(3):479--488, 2004.

\bibitem{KorSha95}
G.~Koren and D.~Shasha.
\newblock : An optimal on-line scheduling algorithm for overloaded
  uniprocessor real-time systems.
\newblock {\em SIAM Journal on Computing}, 24:318--339, 1995.

\bibitem{LiSS05}
F.~Li, J.~Sethuraman and C.~Stein.
\newblock An optimal online algorithm for packet scheduling with agreeable deadlines.
\newblock In {\em Proceedings of 16th ACM-SIAM Symposium on Discrete
  Algorithms}, pages 801--802, 2005.



\bibitem{MiyErl04}
H. Miyazawa and T. Erlebach.
\newblock An improved randomized on-line algorithm for a weighted interval
  selection problem.
\newblock {\em Journal of Scheduling}, 7(4):293--311, 2004.

\bibitem{Sei98}
S.~S. Seiden.
\newblock Randomized online interval scheduling.
\newblock {\em Operations Research Letters}, 22(4--5):171--177, 1998.

\bibitem{Ting06}
H.-F. Ting.
\newblock A near optimal scheduler for on-demand data broadcasts.
\newblock In {\em Proc. 6th Italian Conference on Algorithms and
  Complexity}, LNCS 3998, 163--174, 2006.

\bibitem{Woeg94}
G.~J. Woeginger.
\newblock On-line scheduling of jobs with fixed start and end times.
\newblock {\em Theoretical Computer Science}, 130(1):5--16, 1994.

\bibitem{ZFCCPW06}
F. Zheng, S. P.~Y. Fung, W.-T. Chan, F. Y.~L. Chin,
  C.~K. Poon, and P. W.~H. Wong.
\newblock Improved on-line broadcast scheduling with deadlines.
\newblock In {\em Proc. 12th International Computing and Combinatorics
  Conference}, LNCS 4112, 320--329, 2006.

\end{thebibliography}

\end{document}
