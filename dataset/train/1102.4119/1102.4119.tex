\documentclass[submission,copyright,creativecommons]{eptcs}
\providecommand{\event}{iWIGP 2010} \usepackage[utf8]{inputenc}
\usepackage{xspace}
\usepackage{color}
\usepackage{amsmath} 
\usepackage{amssymb}
\usepackage{stmaryrd} 
\usepackage{helvet}
\usepackage{courier}
\usepackage{formal}
\usepackage{tikz}
\usetikzlibrary{automata}
\usetikzlibrary{arrows}
\usepackage{color}
\newcommand{\ie}{i.\,e.~}
\newcommand{\eg}{e.\,g.~}
\usepackage{tabularx}
\usepackage{breakurl}


\begin{document}

\title{A LTL Fragment for GR(1)-Synthesis}

\author{Andreas Morgenstern and Klaus Schneider
\institute{University of Kaiserslautern\\
	P.O. Box 3049 \\
	67653 Kaiserslautern, Germany \\
	email: \{morgenstern,schneider\}@cs.uni-kl.de}
}
\def\titlerunning{A LTL Fragment for GR(1)-Synthesis}

\def\authorrunning{A. Morgenstern and K. Schneider}

\newtheorem{definition}{Definition}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\newtheorem{remark}{Remark}
\newtheorem{example}{Example}
\def\qed{\hfill \rule{2mm}{2mm}}


\maketitle

\begin{abstract}
The idea of automatic synthesis of reactive programs starting from temporal logic (\LTL{}) specifications is quite old, but was commonly thought to be infeasible due to the known double exponential complexity of the problem. However, new ideas have recently renewed the interest in \LTL{} synthesis: One major new contribution in this area is the recent work of Piterman et al. who showed how polynomial time synthesis can be achieved for a large class of \LTL{} specifications that is expressive enough to cover many practical examples. These \LTL{} specifications are equivalent to -automata having a so-called GR(1) acceptance condition. This approach has been used to automatically synthesize implementations of real-world applications. To this end, manually written deterministic -automata having GR(1) conditions were used instead of the original \LTL{} specifications. However, manually generating deterministic monitors is, of course, a hard and error-prone task. In this paper, we therefore present algorithms to automatically translate specifications of a remarkable large fragment of \LTL{} to deterministic monitors having a GR(1) acceptance condition so that the synthesis algorithms can start with more readable \LTL{} specifications.
\end{abstract}


\section{Introduction}

In the last decades, the influence of computer systems on our everyday life has been constantly growing. As computer systems enter more and more safety-critical areas, their correctness is essentially important to avoid malfunctioning systems. Thus, one of the main challenges in computer science is the design of provably correct systems. Many of these safety-critical computer systems are reactive embedded systems. These are non-terminating systems that interact with their environments during their infinite computations. Typically, concurrency and infinite computations with respect to the environment make it difficult to analyze and design such systems correctly.

There are currently two main approaches to the design of provably correct reactive systems: In the first approach, called \emph{formal verification}, one checks that a manually written implementation satisfies a given specification that is typically formulated in the temporal logic \LTL{} \cite{Pnue77a,Emer90}. In the second approach, called \LTL{} synthesis, a provably correct implementation is automatically derived from the given \LTL{} specification. While formal verification is nowadays even routinely used in safety-critical system designs, \LTL{} synthesis is still immature. Of course, the double exponential complexity of \LTL{} synthesis compared to the single exponential one of \LTL{} model checking is one reason for this situation. We believe, however, that the applicability of tools based on both methods can be significantly improved by better data structures and algorithms.

For example, a major breakthrough in formal verification has been achieved by symbolic representations of states and transitions with propositional formulas which became known as symbolic model checking \cite{BCMD90}. With the advent of these succinct data structures and efficient decision procedures for propositional formulas, it has become possible to verify complex systems. In a similar way, new methods for SAT checking and SMT solvers opened the way to verify even larger systems.

It is natural to try to make use of such data structures and algorithms also for \LTL{} synthesis. However, this is not directly possible, since the currently available \LTL{} synthesis procedures consist of two steps: The first step is the translation of the \LTL{} specification to an equivalent -automaton. The usual translation procedures generate a nondeterministic automaton that can be directly used for symbolic model checking. However, nondeterministic automata can, in general, not be used for \LTL{} synthesis. Even though there are pseudo-deterministic automata like the good-for-games automata that can still be used for \LTL{} synthesis, the second step usually consists of a determinization of the obtained automata (since deterministic automata can be definitely used without further restrictions). The problem is, however, that determinization is considerably more complex for -automata than for automata on finite words. In particular, a major drawback of the currently known determinization procedures is their explicit representation of the automata that does not make use of symbolic data structures. Since a translation from \LTL{} to deterministic automata may lead to automata having a double exponential size in terms of the length of the formula, explicit state space representations are limited to handle very small \LTL{} formulas.

One possibility to overcome the complexity problem of \LTL{} synthesis is to consider restricted classes of \LTL{}. For example, \cite{AlTo04,Maid00} consider subsets of \LTL{} to obtain deterministic automata with less than double exponential size. Wallmeier et al. \cite{WaHT03} developed a synthesis algorithm to synthesize request-response specifications which are of the form  for multiple  which leads to a synthesis procedure with only exponential complexity. Piterman et.~al proposed in \cite{PiPS06} an approach to synthesize generalized reactivity formulas with rank 1 (abbreviated as GR(1) formulas), \ie formulas of the form . Their algorithm runs in time  where  is the size of the state space of the design. If a collection  of \LTL{} formulas representing assumptions on the environment, and a collection  of formulas representing conclusions for the system, can all be represented by deterministic Büchi automata, this approach can be used to obtain a synthesis procedure for the entire \LTL{} specification . 

The work reported in \cite{PiPS06} has been extensively used. Its feasibility was demonstrated in \cite{BGJP07,BGJP07a,JGWB07} which considers ARM's Advance Micro-System Bus Architecture as well as a case study of a generalized buffer example included in IBM's RuleBase system. In those case studies, an implementation realizing the given formal specification has been derived and has been afterwards converted to a circuit. In fact, those case studies have been the first real-life blocks that have been automatically synthesized from high-level temporal logic specifications. Further applications include usage in the context of production of robot systems \cite{WoTM10}.

The main drawback of previously published works using the GR(1)-approach of Piterman et al. is that the unavoidable determinization step was carried out manually by a human developer, since no tool support for the translation of temporal logic formulas to corresponding -automata was available. The translation to deterministic automata is considerably hard in general \cite{KuVa98c} and may introduce errors due to the human intervention.

To eliminate this drawback from the GR(1)-approach, we present in this article a remarkable large subset of \LTL{} that can be translated to sets of deterministic Büchi automata representing the assumptions on the environment and the guarantees a system has to satisfy. To this end, we reconsider the temporal logic hierarchy that has been investigated by Chang, Manna, Pnueli, Schneider and others \cite{MaPn87c,ChMP92,MaPn90,MaPn91,Schn01b,Schn03}. This temporal logic hierarchy defines subsets of \LTL{} that correspond to the well-known automaton hierarchy, consisting of safety, guarantee/liveness, fairness/response/Büchi, persistence/co-Büchi properties as well as their boolean closures (obligation and reactivity properties). Using a syntactic characterization of this hierarchy \cite{Schn01b,Schn03}, we can, in particular, \emph{syntactically} determine for given \LTL{} formulas whether the formula can be represented by a deterministic Büchi automaton. Hence, given a set of formulas representing assumptions and conclusions, we can determine whether they can be used as an input for GR(1)-synthesis. Clearly, since we only check this syntactically, it may be the case that we reject formulas that could be used for GR(1)-synthesis, but we never produce an error. In practice, it turned out that essentially no GR(1) formula is rejected by our syntactic check.

The syntactic approximation to determine GR(1) membership is one contribution of this paper. Another one is the observation that the negation of each formula that can be translated to a deterministic Büchi automaton can be translated to a non-deterministic co-Büchi automaton. It is well-known that non-deterministic co-Büchi automata can be determinized by the Breakpoint construction \cite{MiHa84} that is well-suited for a symbolic implementation \cite{MoSL08,BoKu09a}. From this co-Büchi automaton, we can easily obtain a deterministic Büchi automaton (again via negation, which is trivial for deterministic automata \cite{Schn03}) that is equivalent to the original formula. Hence, our second observation leads to a very efficient translation procedure for the identified \LTL{} formulas to deterministic Büchi and co-Büchi automata.

We have implemented this synthesis procedure that (1) syntactically determines whether a formula can be represented with a GR(1)-property and (2) applies the mentioned symbolic determinization procedure for Büchi/co-Büchi automata. Finally, we apply the GR(1)-synthesis using an existing implementation of the GR(1)-Synthesis approach \cite{BCGH10a}.

\section{Preliminaries}

\subsection{\texorpdfstring{Linear Temporal Logic \LTL{}}{Linear Temporal Logic LTL}}
For a given set of Boolean variables , we define the set of  formulas by the following recursive definition:
\begin{definition}[Syntax of Linear Temporal Logic (\LTL{})]
The set of  LTL formulas over a set of variables  is the smallest set with the following properties:
\begin{itemize} \setlength{\itemsep}{-1mm}
\item  
\item  for 
\item boolean operators: , ,  if 
\item future temporal operators: , ,   if 
\item past temporal operators: , , ,   if 	
\end{itemize}
\end{definition}

\noindent The semantics of \LTL{} can be given with respect to a path through a structure (e.g. an -automaton), where a path is an infinite word over the alphabet .

 holds on a path  at position  if  holds at position  on the path.  holds at  iff  holds for some position  and  holds invariantly for every position  with  \ie  holds \emph{until}  holds. The \emph{weak before} operator  holds at  iff either  holds before  becomes true for the first time after  or  never holds after . 

In addition to the future time temporal operators, there are also the corresponding past time temporal operators. These are defined analogously with the only difference that the direction of the flow of time is reversed. For example,  holds on a path at position  iff there is a point of time  with  such that  holds on that path at position  and  holds for all positions  with . The past time correspondence of the next-time operator is called the previous operator:  holds on a path at position  iff  and  holds at position . Additionally, there is a weak variant, where  holds on a path at position  iff  holds or  holds at position .   

Other operators can be defined in terms of the above ones:


\noindent For example,  is the \emph{weak until} operator that can be alternatively defined as , \ie the event  that is awaited for need not hold in the future. To distinguish weak and strong operators, the strong variants of a temporal operator are underlined in this paper (as done above).


\subsection{\texorpdfstring{-Automata}{omega-Automata}}

\begin{definition}[-Automata ]
A \emph{-automaton}  over the alphabet  is given by a finite set of states , a set  of initial states, a transition relation  and an acceptance condition .
\end{definition}

Given an automaton  and an infinite word  over . Each infinite word  with  and  for  is called a run of  through . The run is \emph{accepting} if . We say that  accepts  whenever an accepting run of  through  exists.

Using standard terminology, we say that  is \emph{deterministic}, if exactly one initial state exists and for each  and each input  there exists exactly one  with  . In that case we write  with an initial state  and a deterministic transition function .
 
In the following, we assume that  for a set  of state variables. Moreover, we assume sets  and  of input and output variables that form the inputs  and outputs  of the system such that . Having this view, we define a state set  to contain exactly those states where the propositional encoding of the state variables  satisfy . Thus, we can conveniently define acceptance conditions by \LTL{} specifications.

\subsection{Classical Acceptance Conditions}

In the past, several kinds of acceptance conditions have been proposed and their different expressivenesses have been studied in depth. In particular, the following acceptance conditions have been considered \cite{Wagn79,Thom90a,Schn03}.

\begin{itemize}
\item A run is accepted by a safety condition  if the run exclusively runs through the set .
\item A run is accepted by a liveness condition  if the run visits at least one state of the set  at least once.
\item A run is accepted by a prefix\footnote{These condititions are also called Staiger-Wagner or obligation conditions.} condition
  if for all  either the run exclusively runs through the set  or visits  at least once.
\item A run is accepted by a Büchi condition   if the run visits at least one state of the set  infinitely often.
\item A run is accepted by a co-Büchi condition   if the run visits only states of the set  infinitely often.
\item Finally, a run is accepted by a Streett (or reactivity) condition  if for all  either the run visits at least one state from  or the run visits only states of the set  infinitely often. 
\end{itemize}












\subsection{GR(1)-Specifications for \texorpdfstring{\LTL{}}{LTL} Synthesis }
The task of \LTL{} synthesis is to develop a system that controls the output variables  so that no matter how the environment chooses the input variables , a \LTL{} specification is satisfied. Thus, instead of using one of the classical acceptance conditions, it is more convenient for synthesis to consider specifications of the form  where  represents assumptions on the environment and  represents conclusions/guarantees the system has to satisfy. In particular, Generalized Reactivity (1) acceptance \cite{BGJP07,BGJP07a,JGWB07,PiPS06} attracted some interest in the community: here the assumptions and guarantees are all Büchi conditions, \ie we seek a system satisfying the following
acceptance condition:



\noindent The class of specifications to which the algorithms of \cite{BGJP07,BGJP07a,JGWB07,PiPS06} can be applied is much more general than the limited form presented in equation \ref{eq:0}: The algorithm can be applied to any specification of the form  where each ,  is specified by a deterministic Büchi automaton.

\begin{definition}[\cite{KoHB09}]\label{def:GR1-Automaton}
Assume we are given  deterministic Büchi automata  for the environment's assumptions and  deterministic Büchi automata  for the system's guarantees with  and . Then, we define an automaton  as the product of all automata  and  where the state space is , the transition function is  and the initial state is . The acceptance condition  is a GR(1) condition.
\end{definition}
Thus, a run of  is accepting if either all sets  are visited infinitely often or at least some set  is visited only finitely often.


\subsection{Games}
A \emph{game}  is a deterministic -automaton with an input alphabet . A \emph{play} of  is an infinite sequence of states  where  for . The letters  are successively chosen by the players: in each step, the environment first chooses , and then the system chooses . A play  is won by the system if . Otherwise, the game is won by the environment. Note that the environment cannot react to the outputs generated by the system and thus acts like a Moore machine. In contrast, the system we would like to synthesize acts like a Mealy machine. 

We solve the game, attempting to decide whether the game is winning for the environment or the system. If the environment is winning, the specification is unrealizable. If the system is winning, we synthesize a winning strategy (which is essentially a Mealy automaton) using the algorithms given in \cite{BGJP07,BGJP07a,JGWB07,PiPS06}. 

\noindent Previous works regarding the synthesis with respect to GR(1)-synthesis had to manually generate the deterministic automata. In this paper, we show how to automatically obtain deterministic Büchi automata from a fragment of \LTL{} using the well-known Breakpoint construction. This fragment of \LTL{} is a natural fragment of \LTL{} embedded in the well-known temporal-logic hierarchy \cite{MaPn87c,ChMP92,MaPn90,MaPn91,Schn01b,Schn03}.













\section{Temporal Logic vs. Automaton Hierarchy}

\subsection{The Automaton Hierarchy}

\noindent The classical acceptance conditions, i.e., safety, guarantee/liveness, fairness/response/Büchi, persistence/co-Büchi properties, define the corresponding automaton classes , , , and , respectively. Moreover, their boolean closures can be represented by the automaton classes  and  whose acceptance conditions have the forms  and , respectively.

The expressiveness of these classes is illustrated in Figure~\ref{fig:automata_hierarchy}, where  means that for any automaton in , there is an equivalent one in . Moreover, we define  and . As can be seen, the hierarchy consists of six different classes, and each class has a deterministic representative. 

\begin{figure}
\begin{centering}
\tikzstyle{tikblock} = [draw, fill=blue!6, rounded corners]
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,auto]
\node[tikblock,minimum height=2cm,minimum width=1.8cm] (G) at (0,5) {};
\node[tikblock,minimum height=2cm,minimum width=1.8cm] (F) at (0,1)  {};
\node[tikblock,minimum height=2cm,minimum width=1.8 cm] (Prefix) at (4,3) {};
\node[tikblock,minimum height=2cm,minimum width=1.8cm] (GF) at (8,5) {};
\node[tikblock,minimum height=2cm] (FG) at (8,1) {};
\node[tikblock,minimum height=2cm] (Streett) at (12,3) {};
							
\node[tikblock,fill=blue!20,minimum width=1.5cm] at (0.025,4.5) {};
\node[tikblock,fill=blue!20,minimum width=1.5cm] at (0.025,0.4) {};
\node[tikblock,fill=blue!20,minimum width=1.5cm] at (4,2.4) {};
\node[tikblock,fill=blue!20,minimum width=1.5cm] at (12,2.3) {};
\node[tikblock,fill=blue!20,minimum width=1.4cm] at (8,4.5) {};
\node[tikblock,fill=blue!20,minimum width=1.5cm] at (8,0.4) {};

\path[->,color=white] (G) edge node [sloped,left=-0.3cm] {\color{black} } (Prefix)
	     (F) edge node [sloped,right=-0.3cm] {\color{black} } (Prefix)
	     (Prefix) edge node [sloped,right=-0.4cm] {\color{black} } (GF)
	     (Prefix) edge node [sloped,left=-0.4cm] {\color{black}  } (FG)	
	     (GF) edge node [sloped,left=-0.4cm] {\color{black} } (Streett)
	     (FG) edge node [sloped,right=-0.3cm] {\color{black} } (Streett)	;		
\end{tikzpicture}
\caption{(Borel) Hierarchy of -Automata and Temporal Logic}
\label{fig:automata_hierarchy}
\end{centering}
\end{figure}




\subsection{The Temporal Logic Hierarchy}

In \cite{ChMP92,Schn01b,Schn03}, corresponding hierarchies for temporal logics have been defined. Following \cite{Schn01b,Schn03}, we define the hierarchy of temporal logic formulas syntactically by the grammar rules of Fig.~\ref{fig:grammar}:

\begin{figure*}[!th] 
\caption{Syntactic Characterizations of the Classes of the Temporal Logic Hierarchy}
\label{fig:grammar}
\end{figure*}


\begin{definition}[Temporal Logic Classes] \label{temp_borel_1_def}
For , , , , , , we define the logics  by the grammars given in Fig.~\ref{fig:grammar}, where  is the set of formulas that can be derived from the nonterminal  ( represents any variable ).
\end{definition}

\noindent Typical safety conditions like  or  that state that something bad never happens, are contained in . Liveness conditions like  are contained in . Finally, fairness conditions like  that demand that something good infinitely often happens, are contained in  while stabilization/persistence properties like  that demand that after a finite interval, nothing bad happens are contained in .




\subsection{Relating the Temporal Logic and the Automata Hierarchy}

In \cite{Schn01b,Schn03} several translation procedures are given to translate formulas from  to equivalent  automata. In particular, the following is an important result:

\begin{theorem}[Temporal Logic and Automaton Hierarchy] \label{borel_thm}
Given a formula , we can construct a deterministic -automaton  of the class  in time  with  state variables. Therefore,  is a symbolic representation of a deterministic automaton with  states.
\end{theorem}

\noindent The above results are already proved in detail in \cite{Schn03}, where translation procedures from  to  have been constructed. Moreover, it has been shown in \cite{Schn03} that the subset construction can be used to determinize the automata that stem from the classes  and  and that the Miyano-Hayashi breakpoint construction is sufficient to determinize the automata that stem from the translation of formulas from  and . Since  and  are the boolean closures of  and , respectively, the remaining results for  and  follow from the boolean combinations of  and , respectively. 

The final step consists of computing the boolean closure of the acceptance conditions. To this end, it is shown in \cite{Schn03} how arbitrary boolean combinations of  and  with propositional formulas  are translated to equivalent  automata, and analogously, how arbitrary boolean combinations of  and  with propositional formulas  are translated to equivalent  automata.




\begin{figure*}[!th] 
\caption{A \LTL{} Fragment for GR(1)-Synthesis}
\label{fig:grammar2}
\end{figure*}





\section{A \texorpdfstring{\LTL{}}{LTL} Fragment for GR(1)-Synthesis}

Using the previously mentioned temporal logic hierarchy, we define a fragment of \LTL{} that can be easily translated to a set of deterministic Büchi automata for the assumptions and a set of deterministic Büchi automata for the guarantees (Figure \ref {fig:grammar2}). 

As can be seen, our \LTL{} fragment is naturally embedded in the temporal logic hierarchy. The formulas that syntactically belong to our \LTL{} fragment are those formulas that are derived from the nonterminal , thus, these are implications of formulas that are derived from the nonterminals  and , respectively, which are both conjunctions of -formulas. 

\noindent Concerning the automata hierarchy, we can translate these formulas to automata with a GR(1)-acceptance condition, i.e. a generalization of a Streett(1) condition. In \cite{BCGH10}, it is shown that a GR(1)-condition can be equivalently expressed by a Streett(1)-condition, \ie a Streett condition with only one acceptance pair. Hence, we obtain the "enriched" automata hierarchy shown in Figure~\ref{fig:automata_hierarchy2} together with the following corollary that easily follows from Theorem~\ref{borel_thm}:

\begin{corollary}
Given a -formula of the form , we can compute  deterministic Büchi automata  and  deterministic Büchi automata  such that  () is initially equivalent to  (resp. ). Hence the GR(1)-automaton obtained from those automata according to Definition \ref{def:GR1-Automaton} is initially equivalent to .
\end{corollary}



\begin{figure}
\begin{centering}
\scalebox{0.8}{
\tikzstyle{tikblock} = [draw, fill=blue!6, rounded corners]
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,auto]
    	 \node[tikblock,minimum height=2cm,minimum width=1.8cm] (G) at (0,5) {};
	 \node[tikblock,minimum height=2cm,minimum width=1.8cm] (F) at (0,1)  {};
	\node[tikblock,minimum height=2cm,minimum width=1.8 cm] (Prefix) at (4,3) {};
	\node[tikblock,minimum height=2cm,minimum width=1.8cm] (GF) at (8,5) {};
	\node[tikblock,minimum height=2cm] (FG) at (8,1) {};
	\node[tikblock,minimum height=2cm] (Streett1) at (12,3) {};
	\node[tikblock,minimum height=2cm] (Streett) at (16,3) {};
								
	\node[tikblock,fill=blue!20,minimum width=1.5cm] at (0.025,4.5) {};
	\node[tikblock,fill=blue!20,minimum width=1.5cm] at (0.025,0.4) {};
	\node[tikblock,fill=blue!20,minimum width=1.5cm] at (4,2.4) {};
	\node[tikblock,fill=blue!20,minimum width=1.5cm] at (16,2.3) {};
	
	\node[tikblock,fill=blue!20,minimum width=1.5cm] at (12,2.3) {};
	\node[tikblock,fill=blue!20,minimum width=1.4cm] at (8,4.5) {};
	\node[tikblock,fill=blue!20,minimum width=1.5cm] at (8,0.4) {};
	
	\path[->,color=white] (G) edge node [sloped,left=-0.3cm] {\color{black} } (Prefix)
		     (F) edge node [sloped,right=-0.3cm] {\color{black} } (Prefix)
		     (Prefix) edge node [sloped,right=-0.4cm] {\color{black} } (GF)
		     (Prefix) edge node [sloped,left=-0.4cm] {\color{black}  } (FG)	
		     (GF) edge node [sloped,left=-0.4cm] {\color{black} } (Streett1)
		     (FG) edge node [sloped,right=-0.3cm] {\color{black} } (Streett1)			
		     (Streett1) edge node {\color{black} } (Streett)	;		
		     
\end{tikzpicture}
}
\end{centering}
\caption{(Borel) Hierarchy of -Automata and Temporal Logic with GR(1)}
\label{fig:automata_hierarchy2}
\end{figure}




\section{Experiments}

In our previous work, we had already implemented a toolset Averest \cite{Schn09} whose inputs are programs written in the Esterel-like synchronous programming language Quartz \cite{Schn09}. Averest compiles the synchronous programs to guarded actions which can be used in turn to generate sequential and concurrent software, hardware or symbolic transition relations for formal verification. Specifications can be given in various temporal logics and the -calculus. Averest provides a lot of translations from temporal logic to either -automata or directly to the -calculus (see \cite{Schn03} for these translations).

For this paper, we implemented an additional tool Quartz2Marduk that takes as input a set of \LTL{} formulas that represent assumptions and assertions/guarantees of a GR(1) specification (see example shown in Figure~\ref{fig:example_spec}). We then check whether these specifications belong to the class that can be used for GR(1)-synthesis. If so, we automatically generate deterministic automata that are equivalent to the specification. The automata are automatically minimized using a form of delayed simulation \cite{Frit05b} and are afterwards used to generate a file as input to the Marduk\footnote{Actually, our current implementation generates an Anzu \cite{JGWB07} file and we use a tool included with Marduk to translate this Anzu file to a Marduk file.} tool \cite{BCGH10a}. Marduk is a re-implementation of Anzu \cite{JGWB07} with some new features.
It is basically a BDD-based implementation of the algorithm given in \cite{PiPS06}.

Included with Marduk came two case studies that are described in \cite{BGJP07,BGJP07a,JGWB07}. The first case study is the GenBuf example that is used asa tutorial in IBMs RuleBase system. The second example is \emph{ARM's Advanced Microcontroller Bus Architecture (AMBA)} which defines the \emph{Advanced High performance Bus (AHB)}, an on-chip communication standard that connects devices like processor cores, caches and DMA arbiters.

In \cite{BGJP07,BGJP07a,JGWB07} temporal logic specifications for those case studies are given along with some hints how deterministic automata for these specifications can be manually obtained. Marduk came with an input file that already contained those manually generated deterministic automata. In our tool, all we had to do is to simply write down the temporal logic specifications given in \cite{BGJP07,BGJP07a,JGWB07} and compile it to a Marduk input file.

After having compiled the Marduk input files, we ran Marduk with dynamic variable ordering enabled, leaving the other options untouched. The results of our experiments is given in table~\ref{fig:experiments}. The first column given there is the name of the case study, the second column is the time (in seconds) our tool needed to perform determinization. The third column lists the number of state variables that where generated by our tool and the manual generated deterministic automata.The next column lists the number of BDD Nodes for the generated strategy. Finally, the last column lists the runtime of Marduk for the automatically generated automata and the respective time for the manually generated automata. In the table, TO means that the synthesis procedure could not be finished within 50000 seconds\footnote{We can not satisfactorily explain why the synthesis for the AMBA model needed more time for 6  masters than for 7 masters using our determinization procedure. However, the same holds for the manually generated automata where this observation can be done for 8 respectively for 9 masters. However, a similar observation was also reported in \cite{BGJP07a}.}.



\begin{figure}
\includegraphics[scale=0.65]{GenBuf.png}
\caption{An Example Quartz File with a GR(1) Specification having only Assertions}
\label{fig:example_spec}	
\end{figure}


\begin{figure}[ht]
\centering
\begin{tabular}{|c|c|cc|cc|cc|}
	\hline
	Model & Det (s) & \multicolumn{2}{c|}{State Vars}& \multicolumn{2}{c|}{Strategy Nodes}& \multicolumn{2}{c|}{Solve(t)} \\
	& & Auto & Manu & Auto & Manu &Auto & Manu\\
	\hline
	GenBuf 2 & 0.1 & 12 & 3&8.755&3.344& 0.86 & 0.25\\
	GenBuf 3 & 0.1 & 12 &3&19.087&4.237& 1.96 & 0.3\\
	GenBuf 4 & 0.2 & 12 &3&25.653&5.546& 2.12 & 0.63\\
	GenBuf 5 & 0.2 &12 &3&39.356&11.916& 12.88 & 1.34\\
	GenBuf6 & 0.3 &12&3&26.139&15.605& 5.61 & 2.38\\
	GenBuf7 & 0.3 &12&3&117.625&18.894& 41.92 & 3.75\\
	GenBuf8 & 0.3 &12&3&45.238&24.302& 11.24 & 5.14\\
	GenBuf9 & 0.3 &12&3&27.507&24.493& 12.7 & 7.8\\
	GenBuf10 & 0.3 &12 &3&67.879&51.605& 44.91& 25.3\\
	Amba2 & 0.6 &9&7&38.107&50.816& 3.0 & 1.97\\
	Amba3 & 1.1 &10&8&77.033&122.027& 14.4& 10.64\\
	Amba4 & 1.8 &11&9&451.456&503.622& 66.9 & 98.32\\
	Amba5 & 7.2 &12&10&1.194.190&825.294& 1221.7 & 381.34\\
	Amba6 & 19.4 &13&11&4.929.635&989.482&  46815 & 420.96\\
	Amba7 & 42.0 &14&12&2.052.871&1.037.608&  4555.2 & 904.78 \\
	Amba8 &  83.1 &15&13&TO&3.625.518& TO & 13617.19\\
	Amba9 & 403.6 &16&14&TO&1.331.441& TO & 4215.94\\
	Amba10 & 580.16 &17&15&TO&3.034.060& TO & 7325.85\\
	\hline
\end{tabular}	
\caption{Experimental Results}
\label{fig:experiments}
\end{figure}



\section{Discussion}

The GR(1)-approach is one of the most successful approaches to \LTL{} synthesis today \cite{BGJP07,BGJP07a,JGWB07} that has already found applications apart from its primary target \cite{WoTM10}. One interesting question regarding the GR(1)-synthesis approach is its good algorithmic behavior of having a cubic runtime despite the fact that many specifications can be rewritten to a deterministic automaton having a GR(1)-acceptance condition. This question has been answered in \cite{BCGH10} where it is shown that in fact an automaton with GR(1)-acceptance condition is equivalent to a Streett automaton having only one acceptance pair. 

In this article, we gave the corresponding temporal logic view: We presented a fragment of \LTL{} that is `naturally' embedded in the temporal logic hierarchy and that can be easily translated to a corresponding deterministic GR(1)-automaton. We have implemented a tool that is able to translate any formula from this fragment to a corresponding deterministic GR(1)-automaton. This is a useful improvement in the expressivity and usage of the GR(1)-approach: instead of having the need to generate deterministic automata manually, the input to our tool is a more readable \LTL{} formula.

However, this higher expressivity comes to a cost: Not too surprisingly, running Marduk on the manually generated automata took a significant smaller amount of time than on the automatically generated automata and moreover, generated smaller BDDs for the strategies. However, the manually generated automata have undergone heavy (hand-crafted) minimization steps\footnote{Compare the difference in the runtime of the Anzu tool reported in \cite{BGJP07} with the one reported in \cite{BGJP07a}.} and hence we expect that further improvements on the determinization or the minimization step of our tool could also significantly improve our results.





\section{Acknowledgements}
We would like to thank Georg Hofferek for his kind help with the tool Marduk.

\bibliographystyle{eptcs} 
\bibliography{paper.bib}
\end{document}
