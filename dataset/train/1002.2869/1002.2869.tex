\documentclass[copyright,creativecommons]{eptcs}

\providecommand{\event}{B. Klin, P. Soboci\'nski (Eds.): \\
6th Workshop on Structural Operational Semantics (SOS'09)}
\providecommand{\volume}{19}
\providecommand{\anno}{2010}
\providecommand{\firstpage}{46}
\providecommand{\eid}{4}

\usepackage{breakurl}
\usepackage{graphicx}
\def\lastname{Bonchi, Gadducci, Monreale}
\usepackage{lscape}

\usepackage{epsfig}  \newcommand{\llbracket}{\mathopen{[\mkern-3mu[}}
\newcommand{\rrbracket}{\mathclose{]\mkern-3.2mu]}}
\usepackage{amsthm}
\usepackage{alltt}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{latexsym}
\usepackage{stmaryrd}
\usepackage[arrow,matrix,frame,curve,cmtip]{xy}\CompileMatrices
\usepackage{url}





\newcommand{\bisl}{\sim^{L}}


\newcommand{\harpoon}{\!\upharpoonleft\!}


\newcommand{\rulelabel}[1]{(\textsc{#1})}
\newcommand{\orbar}{\:\mathrel{\big|}\:}
\newcommand{\as}{\:\mathrel{::=}\:}
\newcommand{\Names}{\mathfrak{N}}
\newcommand{\Var}{\mathit{Var}}
\newcommand{\nil}{\mathbf{0}}
\newcommand{\respi}[1]{(\pmb{\nu} #1)\,}
\newcommand{\relfont}{\mathcal}
\newcommand{\Set}{\texttt{Set}}
\newcommand{\NSet}{\texttt{NSet}}
\newcommand{\idfus}{\varepsilon}
\newcommand{\lproc}{{P}}







\def\ured{\rightarrow}
     \def\tred#1{\overstackrel{\rightarrowfill}{#1}}
     \def\iured#1{\rightarrow_{\descr{\scriptsize #1}}}
     \def\itred#1#2{\mathrel{{\overstackrel{\rightarrowfill}{#2}}_{\descr
       {\scriptsize #1}}}}
     \def\sytr#1{\overstackrel{\longmapsto}{#1}}
     \def\tr#1{\stackrel{#1}{\to}}
     \def\IPOtr#1{\stackrel{#1}{\rightarrowfill_{IPO}}}
     \def\FULLtr#1{\stackrel{#1\ \ }{\rightarrowfill_{SAT}}}

\def\actr#1#2{\overstackrel{\rightarrowfill}{\act {#1}{#2}}}
     \def\iactr#1#2#3{\overstackrel{\rightarrowfill}{\act {#2}{#3}}_{\descr
       {\scriptsize #1}}}
     \def\dlarrow#1#2{\overunderstackrel{\rightarrowfill}{#1}{#2}}
     \def\ddlarrow#1#2{\overunderstackrel{\longmapsto}{#1}{#2}}
     \def\Dlarrow#1#2{\overunderstackrel{\Longrightarrow}{#1}{#2}}
     \def\dmtarrow#1#2{\overunderstackrel{\longmapsto}{#1}{#2}}
     \def\mtarrow#1{\overstackrel{\longmapsto}{#1}}
     \newcommand{\mylarrow}[1]{\overstackrel{\rightarrowfill}{#1}}

     \newcommand{\partarrow}[2]{\overunderstackrel{\rightarrowfill}{\ \ \mbox{\scriptsize }\ \ }{\ \mbox{\scriptsize }\ }\!\!\!>}
     \newcommand{\arw}[1]{\overstackrel{\rightarrowfill}{#1}}
     \newcommand{\newpartarrow}[2]{\partarrow{#1}{}}
     \newcommand{\spartarrow}[1]{\overstackrel{\rightarrowfill}{\ \ \mbox{\scriptsize }\ \ \ }\!\!\!\!\!>}
     \newcommand{\trlts}[1]{\overstackrel{\rule[.8mm]{7mm}{.2mm}}{#1}\!\!\blacktriangleright}
     \newcommand{\trred}{\overstackrel{\rule[.8mm]{7mm}{.2mm}}\!\!\vartriangleright}



  \newcommand{\namedef}[2]
    {\begin{center}\begin{tabular}{lr}
       {}
      & \qquad
       {\emph{#1}}
     \end{tabular}\end{center}
    }
  \newcommand{\st}{\ | \ }

  \newcommand{\id}[1]{\mathrm{id}_{#1}}
  \newcommand{\seq}{\stackrel{\cdot}{=}}
  \newcommand{\pws}[1]{\wp({#1})}
  \newcommand{\pwsf}[1]{\wp_{\mbox{\tiny fin}}({#1})}
  \newcommand{\newredlabel}[4]{\ensuremath{\mathbf{#1}(#3,#4)}}
\newcommand{\mypair}[2]{\langle #1, #2 \rangle}
  \newcommand{\proofend}{\mbox{}}
  \newenvironment{prova}{{\sc Proof.}}{\hfill\proofend}
  \newcommand{\smod}{\mid\!\equiv}
  \newcommand{\mmdef}{\mbox{}}
  \newcommand{\notd}{\stackrel{\mbox{\tiny Not}}{=}}
  \newcommand{\lar}[1]{\overstackrel{\longleftarrow}{#1}}
  \newcommand{\defuguale}{:=}
  \newcommand{\deduz}[2]{\frac{\displaystyle #1}{\displaystyle #2}}
  \newcommand{\dtr}[2]{\mathrel{\stackoverunder{\longrightarrow}{#1}{#2}}}






\newcommand{\Th}[1]{\Cat{Th[#1]}}



\newcommand{\names}{\mbox{}}






\newcommand{\SQUR}[5][]{\ensuremath{{{}_{#1{#2}}}_{\to#1{#4}\smash{{}^{\nearrow}}}^{{}_{\nearrow}#1{#3}\to#1{#5}}}}
\newcommand{\squr}[5][r]{\ifthenelse{\equal{#1}{r}}{\SQUR{#2}{#3}{#4}{#5}}{\ensuremath{\mathreflect{\SQUR[\mathreflect]{#2}{#3}{#4}{#5}}}}}

\renewcommand{\propto}{\fatsemi}
\let\oldrightarrow\to
\renewcommand{\to}[1][]{\ifthenelse{\equal{#1}{}}{\oldrightarrow}{\ensuremath{\xrightarrow{{}_{#1}}}}}


\let\oldleftarrow\gets
\renewcommand{\gets}[1][]{\ifthenelse{\equal{#1}{}}{\oldleftarrow}{\ensuremath{\xleftarrow{{}_{#1}}}}}

\makeatletter
\def \rightarrowfill{\m@th\mathord{\smash-}\mkern-6mu\cleaders\hbox{}\hfill
  \mkern-6mu\mathord\rightarrow}
\makeatother \makeatletter
\def \Rightarrowfill{\m@th\mathord{\smash-}\mkern-6mu\cleaders\hbox{}\hfill
  \mkern-6mu\mathord\Rightarrow}
\makeatother \makeatletter
\def \mapstofill{\m@th\mathord{\smash-}\mkern-6mu\cleaders\hbox{}\hfill
  \mkern-6mu\mathord\longmapsto}
\makeatother

\def \overunderstackrel#1#2#3{\mathrel{\mathop{#1}\limits^{#2}_{#3}}}
\def \overstackrel#1#2{\mathrel{\mathop{#1}\limits^{#2}}}
\def \understackrel#1#2{\mathrel{\mathop{#1}\limits_{#2}}}
\def\dlarrow#1#2{\overunderstackrel{\rightarrowfill}{#1}{#2}}







\newcommand{\Cat}[1]{{\bf #1}}
\newcommand{\Rea}[1]{\mathcal{#1}}
\newcommand{\Rules}[1]{\mathfrak{#1}}
\newcommand{\Hom}[1]{\mathfrak{#1}}
\newcommand{\React}{\Rea{R}= \<\Cat{C}, 0, \Cat{D}, \Rules{R}\>}

\newcommand{\barb}[1]{\downarrow_{#1}}
\newcommand{\weakbarb}[1]{\Downarrow_{#1}}


\newcommand{\bsbis}{\sim^{BS}}

\newcommand{\lts}{\textsc{lts}}

\newcommand{\satbis}{\sim^{S}}
\newcommand{\ipobis}{\sim^{IPO}}
\newcommand{\symbis}{\sim^{SYM}}
\newcommand{\ssbis}{\sim^{SS}}
\newcommand{\bssbis}{\sim^{BSS}}
\newcommand{\wbsbis}{\sim^{WBS}}
\newcommand{\wbssbis}{\sim^{WBSS}}

\newcommand{\cts}{\textsc{sts}}
\newcommand{\sts}{\textsc{scts}}
\newcommand{\ilts}{\textsc{ITS}}
\newcommand{\glts}{\textsc{gipots}}
\def\tr#1{\stackrel{#1}{\rightarrowfill}}
\def\IPOtr#1{\stackrel{#1}{\rightarrow_{IPO}}}
\def\FULLtr#1{\stackrel{#1\ \ }{\rightarrow_{SAT}}}
\newcommand{\react}{\rightsquigarrow}
\newcommand{\treact}{\rightsquigarrow^{*}}
\newcommand{\cointr}[1]{\tr{#1}_{CO}}

\newcommand{\impl}{\Longrightarrow}
\newcommand{\adj}{\dashv}
\renewcommand{\o}{\circ}
\newcommand{\<}{\langle}
\renewcommand{\>}{\rangle}
\newcommand{\N}{{\rm I\!l\!\!N}}
\newcommand{\tria}{}
\newcommand{\eqn}[1]{}
\newcommand{\from}{\leftarrow}
\newcommand{\To}{\Rightarrow}
\newcommand{\lax}{{\mbox{\small lx}}}
\newcommand{\ulax}{{\mbox{\small {lx}}}}
\def\notaF#1{ }
\def\nota#1{\marginpar{\small\textcolor{red}{#1}}}


\newcommand{\sign}{\Sigma}



\newcommand{\modelON}{\mathcal{N}}
\newcommand{\onsort}{|\onmssign|}
\newcommand{\onsign}{\sign^{\modelON}}
\newcommand{\onmssign}{\Cat{Tok}}
\newcommand{\onspec}{\Sig{\Gamma(\onmssign)}}
\newcommand{\ONPA}{\Alg{N}}
\newcommand{\ONSET}{N}
\newcommand{\actON}{O_{\modelON}}
\newcommand{\trON}{tr_{\modelON}}
\newcommand{\ONtr}{tr_{\modelON}}
\newcommand{\modelONAll}{\< \onmssign, \ONPA, \actON, \trON \>}
\newcommand{\ontr}[1]{\tr{#1}_{\modelON}}
\newcommand{\infON}{\ded{T}_{\modelON}}
\newcommand{\approxON}{\eta}
\newcommand{\onproc}{A}





\newcommand{\pr}{pre}
\newcommand{\pre}[1]{^{\bullet}#1}
\newcommand{\po}{post}
\newcommand{\post}[1]{#1^{\bullet}}

\newcommand{\onet}[1]{#1}

\newcommand{\CON}{\Cat{CON}}
\newcommand{\FON}{\Fun{ON}}
\newcommand{\short}[1]{}
\newcommand{\full}[1]{#1}





\newcommand{\dpo}{\textsc{dpo}}
\newcommand{\Graph}{\ensuremath{\mathbf{Graph}}}
\newcommand{\rg}[1]{\ensuremath{\mathbb{#1}}}
\newcommand{\src}[1]{\ensuremath{\mathit{src}({#1})}}
\newcommand{\trg}[1]{\ensuremath{\mathit{trg}({#1})}}
\newcommand{\Typed}[2]{\ensuremath{{#1}\mbox{-}{#2}}}
\newcommand{\RTyped}[2]{\ensuremath{{I}\mbox{-}{#1}\mbox{-}{#2}}}
\newcommand{\tgr}[1]{\ensuremath{|{#1}|}}
\newcommand{\tmap}[1]{\ensuremath{t_{{#1}}}}
\newcommand{\rew}[1]{\ensuremath{\stackrel{{#1}}{\Longrightarrow}}}
\newcommand{\longrew}[1]{\ensuremath{\!\xymatrix{ {} \ar@{=>}[r]^{#1} & }\!}}





\newcommand{\ccs}{CCS}

\newcommand{\sac}{SAC}

\newcommand{\ggo}{}\newcommand{\bisCCS}{\sim^{CCS}}
\def\GRAPHtr#1#2#3{\stackrel{#1 \rightarrowtail #2 \leftarrow #3}{\rightarrowfill}}
\def\RGRAPHtr#1#2#3{\stackrel{#1 \rightarrowtail #2 \leftarrowtail #3}{\rightarrowfill_{CO}}}
\def\tr#1{\stackrel{#1}{\rightarrowfill}}
\def\tl#1{\stackrel{#1}{\leftarrow}}
\newcommand{\SND}{\ensuremath{\mathit{SND}}}
\newcommand{\RCV}{\ensuremath{\mathit{RCV}}}
\newcommand{\FORGET}{\ensuremath{\mathit{FORGET}}}
\newcommand{\Reach}{\ensuremath{\mathit{Reachable}}}
\newcommand{\Lsinc}{L_s}
\newcommand{\Isinc}{I_s}
\newcommand{\Rsinc}{R_s}
\newcommand{\Ltau}{L_{\tau}}
\newcommand{\Itau}{I_{\tau}}
\newcommand{\Rtau}{R_{\tau}}


\newcommand{\vco}{\,{\scriptstyle\bullet}\,}
\newcommand{\xsta}[1]{\hbox{}}
\newcommand{\longxsta}[1]{\hbox{}}
\newcommand{\superlongxsta}[1]{\hbox{}}
\newcommand{\superduperlongxsta}[1]{\hbox{}}



\newcommand{\reacts}[1]{\mathbb{#1}}


\newcommand{\category}[1]{\mathcal{#1}}
\newcommand{\trans}[3]{#1\stackrel{#2}{\longrvi Haightarrow}#3}
\newcommand{\rtrans}[3]{#1\stackrel{#2}{\longrightarrow}^*#3}
\newcommand{\transalt}[3]{#1{\stackrel{#2}{\longrightarrow}}_{\rm alt}#3}
\newcommand{\transred}[3]{#1{\stackrel{#2}{\longrightarrow}}_{\rm red}#3}
\newcommand{\dnats}[3]{#1 : #2 \Rightarrow #3}
\newcommand{\dnat}[5]{\dfun{\dnats{#1}{#2}{#3}} {#4} {#5}}







\newcommand{\eg}{e.g.}
\newcommand{\ie}{i.e.}
\newcommand{\wrt}{w.r.t.}

\newcommand{\nat}{\mathbb{N}}


\makeatletter
\def \rightarrowfill{\m@th\mathord{\smash-}\mkern-6mu\cleaders\hbox{}\hfill
  \mkern-6mu\mathord\rightarrow}
\makeatother \makeatletter
\def \Rightarrowfill{\m@th\mathord{\smash-}\mkern-6mu\cleaders\hbox{}\hfill
  \mkern-6mu\mathord\Rightarrow}
\makeatother \makeatletter
\def \mapstofill{\m@th\mathord{\smash-}\mkern-6mu\cleaders\hbox{}\hfill
  \mkern-6mu\mathord\longmapsto}
\makeatother

\def \overunderstackrel#1#2#3{\mathrel{\mathop{#1}\limits^{#2}_{#3}}}
\def \overstackrel#1#2{\mathrel{\mathop{#1}\limits^{#2}}}
\def \understackrel#1#2{\mathrel{\mathop{#1}\limits_{#2}}}
\def\dlarrow#1#2{\overunderstackrel{\rightarrowfill}{#1}{#2}}

\def\sep{\quad\Big|\quad}
\newcommand{\bo}[1]{{\bf #1}}
\newcommand{\hmap}[1]{{\cal H}\bracket{#1}}
\newcommand{\alt}{\quad\mid\quad}
\def\is{\,\,\,:=\,\,\,}
\newcommand{\vett}[2]{\frac{\textstyle #1}{\textstyle #2}}







\newcommand{\dfun}[3]{#1 : #2 \longrightarrow #3}
\newcommand{\rsequ}[2]{#1 \Rightarrow #2}
\newcommand{\ursequ}[4]{#1 \Rightarrow #2: #3 \rightarrow #4}
\newcommand{\cellp}[5]{\xymatrix@C=#5cm{{#1} \ar[r]^{#2} \ar@{}[r]_{#3} & {#4}}}
\newcommand{\cell}[4]{{#1}\xymatrix{{} \ar[r]^{#2}_{#3} & {}}{#4}}




\newcommand{\irule}[2]{\frac{\textstyle\rule[-1.3ex]{0cm}{3ex}#1}{\textstyle\rule[-.5ex]{0cm}{3ex}#2}}
\newcommand{\sbtn}[2]{{#1}/{#2}}
\def\abs#1{\left|#1\right|}
\newcommand{\gr}[1]{ \{ \! | #1 |\! \}}
\newcommand{\qu}[1]{{[\![} #1 ]\!]}
\newcommand{\lb}[3]{\save []+<#2, #3>*\txt{\ensuremath{#1}}
  \restore}

\newtheorem{definition}{Definition}{}
\newtheorem{theorem}{Theorem}{}
\newtheorem{lemma}{Lemma}{}
\newtheorem{property}{Property}{}
\newtheorem{proposition}{Proposition}{}
\newtheorem{example}{Example}{}
\newtheorem{remark}{Remark}{}
 \title{On Barbs and Labels in Reactive Systems\thanks{Research
    partly supported by the EU within the FP6-IST IP 16004 \textsc{SEnSOria} (\emph{Software Engineering for
 Service-Oriented Overlay Computers}) and carried out during the first author's tenure of
an ERCIM ``Alain Bensoussan'' Fellowship Programme.}}



\author{Filippo Bonchi
\institute{Centrum voor Wiskunde en
Informatica, Amsterdam, The Netherlands}
\email{Filippo.Bonchi@cwi.nl}
\and
Fabio Gadducci
\institute{Dipartimento di Informatica,
Universit\`a di Pisa, Italy}
\email{fabio@di.unipi.it}
\and
Giacoma Valentina Monreale
\institute{Dipartimento di Informatica,
Universit\`a di Pisa, Italy}
\email{vale@di.unipi.it}
}

\def\titlerunning{On Barbs and Labels in Reactive Systems}
\def\authorrunning{F. Bonchi, F. Gadducci \& G. V. Monreale}

\begin{document}

\maketitle

\begin{abstract}
  Reactive systems (RSs) represent a meta-framework aimed at deriving
  behavioral congruences for those computational formalisms whose
  operational semantics is provided by reduction rules. RSs proved a
  flexible specification device, yet so far most of the efforts
  dealing with their behavioural semantics focused on idem pushouts
  (IPOs) and saturated (also known as dynamic) bisimulations. In this
  paper we introduce a novel, intermediate behavioural equivalence:
  \emph{L-bisimilarity}, which is able to recast both its IPO and
  saturated counterparts. The equivalence is parametric with respect
  to a set  of RSs labels, and it is shown that under mild
  conditions on  it is indeed a congruence. Furthermore,
  -bisimilarity can also recast the notion of barbed semantics for
  RSs, proposed by the same authors in a previous paper. In order to
  provide a suitable test-bed, we instantiate our proposal by
  addressing the semantics of (asynchronous) CCS and of the calculus
  of mobile ambients.
\end{abstract}



\section{Introduction}
\label{sec:Intro}

\emph{Reactive systems} (RSs)~\cite{DBLP:conf/concur/LeiferM00} are an
abstract formalism for specifying the dynamics of a computational
device. Indeed, the usual specification technique is based on a
reduction system, comprising a set of possible states of the device
and a relation among them, representing the possible evolutions of the
device.
The relation is often given inductively, freely instantiating
relatively few rewriting rules: despite its ease of use, the main
drawback of reduction-based solutions is poor compositionality, since
the dynamic behaviour of arbitrary stand-alone terms can be
interpreted only by inserting them in appropriate contexts, where a
reduction may take place. The theoretical appeal of RSs is their
ability to distill labelled transition systems (LTSs), hence,
behavioural equivalences, for devices specified by a reduction system.

The idea underlying RSs is simple: whenever a device specified by
a term  (i.e., a sub-term  inserted into a unary context
) may evolve to a state , the associated LTS has a transition
 (i.e., the state  evolves into  with a label
).
If all contexts are admitted, the resulting semantics is called
saturated, and the standard bisimilarity on the derived LTS is a
congruence.
However, it is unfeasible to check the bisimulation game under all
contexts, and usually it suffices to consider a subset of contexts
that guarantees that the distilled behavioural semantics is a
congruence.  Such a set, the ``minimal'' contexts allowing a reduction
to occur, was identified in~\cite{DBLP:conf/concur/LeiferM00} by the
notion of \emph{relative pushout}: the resulting strong bisimilarity
is a congruence, even if it often does not coincide with the saturated
one.

Several attempts have been made to encode various specification
formalisms (Petri nets~\cite{RobinBGPN,Sassone05}, logic
programming~\cite{LICS2006}, etc.) as RSs, either hoping to recover
the standard observational equivalences, whenever such a behavioural
semantics exists (CCS~\cite{MIL:CAC}, pi-calculus~\cite{Mil:PPCA},
etc.), or trying to distill a meaningful new semantics. The results
are often not fully satisfactory: bisimilarity via minimal contexts is
usually too fine-grained; while saturated semantics are often too
coarse (the standard CCS strong bisimilarity is e.g. strictly included
in the saturated one). As for process calculi, the standard way out of
the empasse it to consider \emph{barbs}~\cite{RobinICALP92} (i.e.,
predicates on the states of a system) and barbed equivalences
(i.e., adding the check of such predicates in the bisimulation game).
The flexibility
of the definition allows for recasting a variety of observational,
bisimulation-based equivalences. Indeed, the methodological
contribution of~\cite{BGMFOSSACS09} is the introduction of suitable
notions of barbed saturated semantics for RSs.

In this paper we move one step further, and we propose a novel
behavioural equivalence for RSs, namely, -bisimulation: a
flexible tool, parametric with respect to a set of minimal labels .
Also in this case the idea is very simple, and it just asymmetrically
refines the standard bisimulation game. If the minimal LTS has
a transition , then a bisimilar  has to react via
a minimal transition , whenever ;
or it must ensure that  may evolve into  (thus requiring no
minimality for  with respect to ), otherwise.
The associated bisimilarity is  intermediate between the standard semantics
(i.e., minimal and saturated)
for RSs: indeed, it is able to recover both of them, by simply
varying the set  and exploiting the so-called semi-saturated semantics.
It can be proved that, under mild closure conditions on the set ,
-bisimilarity is a congruence; and moreover, it can be shown
that  barbed saturated semantics can be recast, as long as 
satisfies suitable barb-capturing properties.

With respect to barbed saturated semantics, -bisimilarity admits a
streamlined definition, where state predicates play no role. It is
thus of simpler verification, and its introduction may have far
reaching consequences over the usability of the RS formalism. However,
as for any newly proposed semantics, its adequacy and ease of use have
to be tested against suitable case studies. We thus consider a recently
introduced, minimal context semantics for mobile ambients (MAs), as distilled
in~\cite{BoGaMo}; as well as two minimally labelled transition systems
for CCS and its asynchronous variant, reminiscent of those proposed in
\cite{bgk:bisimulation-graph-enc}. We show that in those cases, a set
 of minimal labels can be identified, such that -bisimilarity
precisely captures the standard semantics of the calculus at hand.

The paper is organized as follows. Section~2 recalls the basic notions
of RSs, while Section~3 and Section~4 perform the same for MAs and
(asynchronous) CCS, respectively. Section~5 presents the technical
core of the paper: the introduction of -bisimilarity for RSs, the
proof that (under mild conditions on ) it is indeed a congruence,
and moreover its correspondence with barbed semantics.  Finally,
Section~6 and Section~7 prove that, suitably varying the set , the
newly defined -bisimilarity captures the standard equivalences for
MAs and for CCS and its asynchronous variant, respectively.



\section{Reactive Systems}\label{sec:Rea}

This section summarizes the main results concerning (the theory of)
reactive systems (RSs)~\cite{DBLP:conf/concur/LeiferM00}.  The
formalism aims at deriving labelled transition systems (LTSs) and
bisimulation congruences for a system specified by a reduction
semantics, and it is centered on the concepts of \emph{term},
\emph{context} and \emph{reduction rule}: contexts are arrows of a
category, terms are arrows having as domain , a special object that
denotes groundness, and reduction rules are pairs of (ground) terms.

\begin{definition}[Reactive System] A \emph{reactive system} 
  consists of
  \begin{enumerate}
    \setlength{\itemsep}{0cm}
  \item a category ;
  \item a distinguished object ;
  \item a composition-reflecting subcategory  of
    \emph{reactive contexts};
  \item a set of pairs  of \emph{reduction rules}.
  \end{enumerate}
\end{definition}

Intuitively, reactive contexts are those in which a reduction may
occur. By composition-reflecting we mean that  implies .  Note that the rules have to
be ground, i.e., left-hand and right-hand sides have to be terms
without holes and, moreover, with the same codomain.

The reduction relation is generated from the reduction rules by
closing them under all reactive contexts.  Formally, the
\emph{reduction relation} is defined by taking  if there
is  and  such that
 and .

Thus the behaviour of an RS is expressed as an unlabelled transition
system.
In order to obtain a LTS, we can plug a term  into some context  and observe if a reduction occurs. In this case we have that . Categorically speaking, this means that  matches  for some rule  and some reactive context . This situation is formally depicted by diagram (i) in Fig.~\ref{figureRedex}: a commuting diagram like this is called a \emph{redex square}.

\begin{definition}[Saturated Transition System]
  The \emph{saturated transition system} (STS) is defined as
  follows \begin{itemize} \item states: arrows  in
  , for arbitrary ; \item transitions:  if .  \end{itemize}
\end{definition}

Note that  stands for : the same notation is
used in Definitions~\ref{defSB} and~\ref{defSSB} below, in order to
allow for an easier comparison with the process calculi notation, to
be adopted in the following sections.



\begin{definition}[Saturated Bisimulation]\label{defSB}
A symmetric relation  is a \emph{saturated
bisimulation} if whenever  then 
\begin{itemize}
\item if  then  and .
\end{itemize}
\emph{Saturated bisimilarity}  is the largest saturated bisimulation.
\end{definition}

It is obvious that  is a congruence. Indeed, it is the
coarsest symmetric relation satisfying the bisimulation game on
 that is also a congruence.


Note that STS is often infinite-branching since all contexts
allowing reductions may occur as labels.  Moreover, it has intuitively
redundant
transitions.  For example, consider the term  of CCS. We have
both the transitions  and
, yet 
does not ``concur'' to the reduction. We thus need a notion of
``minimal context allowing a reduction'', captured by \emph{idem
pushouts}.

\begin{definition}[RPO, IPO]\label{RPO}
  Let the diagrams in Fig.~\ref{figureRedex} be in a category
  , and let () be a commuting diagram.  A
  \emph{candidate} for (i) is any tuple 
  making (ii) commute.
A \emph{relative pushout (RPO)} is the smallest such candidate,
  i.e., such that for any other candidate  there exists a unique morphism 
  making (iii) and (iv) commute.
A commuting square such as diagram (i) of Fig.~\ref{figureRedex} is
  called \emph{idem pushout (IPO)} if  is its RPO.
\end{definition}


 \begin{figure}[t]
 \begin{center}
   \begin{tabular}{@{}c@{}c@{}c@{}c}

   \def\labelstyle{\scriptscriptstyle}
 \xymatrix@C=10pt@R=10pt
     {
       &I_4 & \\
       I_2\ar[ur]^{C[-]}&    &I_3\ar[ul]_d\\
       &0\ar[ul]^P\ar[ur]_l &
     }

     &
  \def\labelstyle{\scriptscriptstyle}
     \xymatrix@C=10pt@R=10pt
     {
       &I_4 & \\       I_2\ar[ur]^{C[-]} \ar[r]_e& I_5 \ar[u]^g   &I_3\ar[l]^f \ar[ul]_d\\
       &0\ar[ul]^P\ar[ur]_l &
     }

     &

     \def\labelstyle{\scriptscriptstyle}
     \xymatrix@C=10pt@R=10pt
     {
       &I_6 & \\
       I_2\ar[ur]^{e'} \ar[r]_e& I_5 \ar[u]^h   &I_3\ar[l]^f \ar[ul]_{f'}
     }
     &
     \def\labelstyle{\scriptscriptstyle}
     \xymatrix@C=10pt@R=10pt
     {
       &I_4\\
       I_6 \ar[ur]^{g'}&I_5\ar[u]_g \ar[l]^h
     }
 \\
 (i) &(ii) & (iii) & (iv)

   \end{tabular}
\caption{Redex Square and RPO}\label{figureRedex}
\end{center}
\end{figure}

Hereafter, we say that an RS \emph{has redex RPOs} (\emph{IPOs})
if every redex square has an RPO (IPO) as candidate.
For a better understanding of these two
notions, we refer the reader to \cite{LICS2006}.


\begin{definition}[IPO Transition System]
The \emph{IPO transition system}
  (\ilts) is defined as follows
  \begin{itemize}
  \item states:  in , for
    arbitrary ;
  \item transitions:  if
    ,
    ,
    and (i) in Fig.~\ref{figureRedex} is an IPO.
  \end{itemize}
\end{definition}

In other words, if inserting  into the context  matches
, and  is the ``smallest'' such context,
then  evolves to  with label .


Bisimilarity on  is referred to as \emph{IPO-bisimilarity}
().  Leifer and Milner have shown that if the RS has redex
RPOs, then it is a congruence.

\begin{proposition}\label{theoBiggest}
Let us consider an RS with redex RPOs. Then,  is a congruence.
\end{proposition}

Clearly, . In \cite{Bonchithesis} the first
author shows that this inclusion is strict for many formalisms. In
particular, it turns out that in some interesting cases  is
too strict, while  is too coarse. This fact is the reason for
introducing \emph{barbed bisimilarities} \cite{RobinICALP92}. Barbs
are predicates (representing some basic observations) on the states of
a system. For instance, in \cite{RobinICALP92} the authors use for CCS
barbs  and  representing the ability of a
process to perform an input, respectively an output, on channel .


In the following we fix a family  of barbs, and we write
 if  satisfies .

\begin{definition}[Barbed Saturated Bisimulation]\label{def:BSbis}
A symmetric relation  is a \emph{barbed saturated
bisimulation} if whenever  then 
\begin{itemize}
\item if  then ;
\item if  then  and .
\end{itemize}
\emph{Barbed saturated bisimilarity}  is the largest barbed
saturated bisimulation.
\end{definition}

It is easy to see that  is the largest barbed bisimulation
that is also a congruence.

\subsection{An Efficient Characterization of (Barbed) Saturated Bisimilarity}

Since the definition of saturated bisimulation involves a
quantification over all possible contexts, it is usually hard to
(automatically) prove the equivalence of two systems. For this
reason, the first author, with K\"onig and Montanari, introduced
\emph{semi-saturated bisimilarity} \cite{LICS2006}.

\begin{definition}[Semi-Saturated Bisimulation]\label{defSSB}
A symmetric relation  is a \emph{semi-saturated
  bisimulation} if whenever  then
\begin{itemize}
\item if  then  and .
\end{itemize}
\emph{Semi-saturated bisimilarity}  is the largest barbed
semi-saturated bisimulation.
\end{definition}

\begin{proposition}
  \label{theoSemiSatisSat}
Let us consider an RS with redex IPOs. Then,
 .
\end{proposition}
Reasoning on  is easier than on  because
instead of looking at the reductions in all contexts,
only IPO transitions are considered.




In \cite{BGMFOSSACS09}, the authors extended this technique to barbed
saturated bisimilarity.

\begin{definition}[Barbed Semi-Saturated Bisimulation]\label{def:BSSbis}
  A symmetric relation  is a \emph{barbed semi-saturated
  bisimulation} if whenever  then
\begin{itemize}
\item , if  then ;
\item if  then  and .
\end{itemize}
\emph{Barbed semi-saturated bisimilarity}  is the largest
barbed semi-saturated bisimulation.
\end{definition}



\begin{proposition} \label{PropBSS=BS}
Let us consider an RS with redex IPOs. Then,
 .
\end{proposition}

Also in this case, it is more convenient to work with 
instead of . Even if barbs are still quantified over all
contexts, for many formalisms (as for MAs) it is actually enough to
check if  implies , since this condition
implies that , if  then .
Barbs satisfying this property are called \emph{contextual} barbs.

\begin{definition}[Contextual Barbs] \label{contBarb}
A barb  is a \emph{contextual barb} if whenever
 implies  then , 
implies .
\end{definition}



\section{Mobile Ambients} \label{sec:MA}

In this section we first introduce the finite, communication-free fragment
of mobile ambients (MAs)~\cite{CG:MAmb} and its reduction semantics.
Then, we recall the IPO transition system for MAs presented in \cite{BoGaMo}.

Fig.~\ref{syntax} shows the syntax of the calculus. We assume a set
 of \emph{names} ranged over by .
Besides the standard constructors, we include a set 
of \emph{process variables} and a set  of \emph{name
  variables}.
We let  range over the set of \emph{pure} processes,
containing neither process nor name variables; while  range over the set of
\emph{well-formed} processes, i.e., such that no process or ambient
variable occurs twice.

Intuitively, an impure process such as  represents an
underspecified system, where either the process  or the name
of the ambient  can be further instantiated. These extended
processes are needed later for the presentation of the LTS.
We use the standard definitions for the set of free names of a pure
process , denoted by , and for -convertibility,
with respect to the restriction operators . We moreover
assume that  and .
We also consider a family of \emph{substitutions}, which may replace a
process/name variable with a pure process/name, respectively.
Substitutions avoid name capture: for a pure process , the
expression

corresponds to the pure process
,
for names .

The semantics of the calculus
exploits a \emph{structural congruence}, denoted by , which is
the least equivalence on pure processes that satisfies the axioms in
Fig.~\ref{cong}.
The \emph{reduction relation}, denoted by ,
describes the evolution of pure processes.
It is the smallest relation closed under the congruence  and
inductively generated by the set of axioms and inference rules in Fig. \ref{reduction}.

As already said, a \emph{barb}  is a predicate over the states of a system,
with  denoting that  satisfies .  In MAs, 
denotes the presence at top-level of an unrestricted ambient
. Formally, for a pure process ,  if  and , for processes  and  and a
set of restricted names .

\begin{figure}[!t]
\center
\begin{tabular}{p{7.3 cm} p{5 cm}}
\hline \\
 &     \bigskip\\
\hline
\end{tabular}
\caption{(Extended) Syntax of mobile ambients.}
\label{syntax}
\vspace{3mm}
\begin{tabular}{p{6 cm} p{6 cm}}
\hline
if  then  & \\
if  then  & \\
if  then  &  \hspace{3mm} if \\
if  then  &  \hspace{3mm} if \\
 &  \hspace{4mm} if \\
 &  \hspace{.75mm}if \\
\hline
\end{tabular}
\caption{Structural congruence.}
\label{cong}
\vspace{3mm}
\begin{tabular}{p{6 cm} p{6 cm}}
\hline
 & if   then  \\
 & if    then   \\
 & if    then  \\
\hline
\end{tabular}
\caption{Reduction relation on pure processes.}
\label{reduction}
\end{figure}

\begin{definition} [Reduction Barbed Congruences~\cite{PawelAmbient}]
\label{StrongCong}
\emph{Reduction barbed congruence}  is the largest symmetric relation  such that whenever
 then
\begin{itemize}
\item if  then ;
\item if  then  and ;
\item .
\end{itemize}
\end{definition}

A labelled characterization of the reduction barbed congruence over
MAs processes was first presented by Rathke and Soboci\'nski in
\cite{PawelAmbient}, and then by the authors of this paper in
\cite{BGMFOSSACS09}.  In the latter we exploit the notion of barbed
saturated bisimilarity over RSs that is able to capture the
behavioural semantics for MAs defined above.  Moreover, we give an
efficient characterization of such a semantics through the IPO
transition system presented in the next section, and the
semi-saturated game.

\paragraph{An ITS for Mobile Ambients.}
Here we present the   for MAs proposed in
\cite{BoGaMo}. The inference rules describing this LTS
are obtained
from an analysis of a LTS over (processes as) graphs, derived by the
borrowed context mechanism \cite{EK:06}, which is an instance of the
theory of RSs~\cite{graphslics}.  The labels of the
transitions are unary contexts, i.e., terms of the extended syntax
with a hole . Note that they are minimal contexts, that is, they
represent the exact amount of context needed by a system to react.  We
denote them by .  The formal definition of the LTS is
presented in Fig.~\ref{TableLTSProc2}.

The rule \textsc{Tau} represents the -actions
modeling internal computations.  Notice that the labels of the
transitions are identity contexts composed of just a hole , while the
resulting states are pure processes.


The other rules in Fig.~\ref{TableLTSProc2} model the interactions of
a process with its environment. Note that both labels and resulting
states contain process and name variables.  We define the LTS
 for processes over the standard syntax of MAs by
instantiating all the variables of the labels and of the resulting
states.

\begin{definition}
\label{instance}
Let  be pure processes and let  be a pure context.  Then,
we have that  if there exists a
transition  and a
substitution  such that  and
.
\end{definition}

In the above definition recall that substitutions replace process
variables by pure processes and that they do not capture bound names.

The rule \textsc{Open} models the opening of an ambient provided by
the environment. In particular, it enables a process  with a
capability  at top level, for , to
interact with a context providing an ambient  containing some
process . Note that the label  of the rule represents
the minimal context needed by the process 
for reacting.  The resulting state is the process over the extended
syntax , where  represents a process
provided by the environment.  Note that the instantiation of the
process variable  with a process containing a free name that
belongs to the bound names in  is possible only -converting
the resulting process  into a process that does
not contain that name among its bound names at top level.

The rule \textsc{CoOpen} instead models an environment that opens an
ambient of the process.  The rule \textsc{InAmb} enables an ambient of
the process to migrate into a sibling ambient provided by the
environment, while in the rule \textsc{In} both ambients are provided
by the environment. In the rule \textsc{CoIn} an ambient provided by
the environment enters an ambient of the process. The rule
\textsc{OutAmb} models an ambient of the process exiting from an
ambient provided by the environment, while in the rule \textsc{Out}
both ambients are provided by the environment.

\begin{figure}[!t]
\begin{center}
\begin{tabular}{p{6.5 cm} p{6 cm}}
\hline \\
\textsc{\scriptsize(Tau)}

& \textsc{\scriptsize (Out)}

\\ \\
\textsc{\scriptsize(In)}

& \textsc{\scriptsize(OutAmb)} 
\\ \\
\textsc{\scriptsize (InAmb)}

& \textsc{\scriptsize(Open)} 
\\ \\
\textsc{\scriptsize (CoIn)}

& \textsc{\scriptsize (CoOpen)} \\ \\
\hline \\
\end{tabular} \\
\caption{The LTS .} \label{TableLTSProc2}
\end{center}
\end{figure}












\section{On Synchronous and Asynchronous CCS}\label{sec:CCS}
This section introduces the ITSs for CCS and for its asynchronous
variant.  For the sake of space, we do not present the standard CCS,
while we indeed recall the syntax and the semantics of Asynchronous
CCS (ACCS). We then show an ITS for both CCS and ACCS: the former was
introduced in~\cite{bgk:bisimulation-graph-enc}, while the latter is
original. Finally, we show that the IPO-bisimilarity coincides with
the ordinary bisimilarity for CCS; while IPO-bisimilarity is strictly
contained in asynchronous bisimilarity.

\paragraph{Asynchronous CCS.}
Differently from synchronous calculi, where messages are
simultaneously sent and received, in asynchronous communication the
messages are sent and travel through some media until they reach
destination. Thus sending is non blocking (i.e., a process may send
even if the receiver is not ready to receive), while receiving is
(processes must wait until a message becomes available).
Observations reflect the asymmetry: since sending is non blocking,
receiving is unobservable.

Here we shortly introduce the finite fragment of ACCS.
We adopt a presentation reminiscent of
asynchronous ~\cite{AmadioCS98} that allows the non
deterministic choice for input prefixes (a feature missing
in~\cite{BorealeNP98,CastellaniH98}).



Fig.~\ref{syntaxA} shows the syntax of the calculus. We assume a set
 of \emph{names} ranged over by .
As for MAs, we included a set  of \emph{process
  variables}. These are needed for the presentation of the LTS in
Fig.~\ref{LTSACCS}.
We let  range over the set of \emph{pure} processes,
containing no process variables. Substitution of process variables is
defined analogously to MAs. Note that here we let 
range over the set of summation, while in MAs we used
those symbols for capabilities.

The main difference with respect to the standard CCS \cite{MIL:CAC} is the absence of
output prefixes. The occurrence of an unguarded  indicates
a message that is available on some communication media named ,
and it disappears whenever it is received.

\emph{Structural equivalence} () is the smallest congruence
induced by the axioms in Fig.~\ref{congA}.
The behaviour of a process  is then described as a reaction
relation () over processes up to , obtained by
closing the rules in Fig.~\ref{reductionA}.
For ACCS, there exists also an interactive semantics
expressed by an LTS. This is the transition relation over processes
up to , obtained by the rules in Fig.~\ref{LTSAs}. Here we
use  to range over the set of labels . The names of , denoted by , are
defined as usual.

\begin{figure}[!t]
\center
\begin{tabular}{p{7.3 cm} p{5 cm}}
\hline \\
   &  \bigskip\\
\hline
\end{tabular}
\caption{(Extended) Syntax of Asynchronous CCS.} \label{syntaxA}
\vspace{3mm}
\begin{tabular}{p{6 cm} p{6 cm}}
\hline
if  then  & \\
if  then  & \\
if  then  &  \hspace{3mm} if \\
if  then  &  \\
if  then  & \\
 &  \\
 &   \hspace{.75mm}if \\
\hline
\end{tabular}
\caption{Structural congruence.}
\label{congA}
\vspace{3mm}
\begin{tabular}{p{6 cm} p{6 cm}}
\hline
 & if   then  \\
 & if    then   \\
\hline
\end{tabular}
\caption{Reduction relation on pure processes.}
\label{reductionA}
\vspace{3mm}
\begin{tabular}{p{3 cm} p{9 cm}}
\hline
 & if   then   \hspace{3mm} if \\
 & if    then   \\
 & if   and  then   \\
\hline
\end{tabular}
\caption{Labelled transition system.} \label{LTSAs}
\end{figure}

The main difference with respect to the synchronous calculus lies in the notion
of \emph{observation}. Since sending messages is non-blocking, an
external observer can just send messages to a system without knowing
if they will be received or not. For this reason receiving should
not be observable and thus barbs take into account only outputs.
Formally,  if there exists process  such
that . This is reflected in the notion of
asynchronous bisimilarity~\cite{AmadioCS98}.

\begin{definition}[Asynchronous Bisimulation]\label{def:Abis}
A symmetric relation  is an \emph{asynchronous
bisimulation} if whenever  then

\begin{itemize}
\item if  then  and ,
\item if  then  and ,
\item if  then either  and  or  and .
\end{itemize}
\emph{Asynchronous bisimilarity}  is the largest
asynchronous bisimulation.
\end{definition}

For example, the processes  and 
are asynchronous bisimilar. If , then  and clearly .


\paragraph{An ITS for CCS.}
In \cite{bgk:bisimulation-graph-enc}, the first and the second
author together with K\"onig derived an ITS for the
ordinary CCS by employing the borrowed context mechanism
\cite{EK:06}.

Fig.~\ref{LTSCCS} shows the LTS . The labels of
 are minimal contexts, i.e., they represent the exact
amount of context needed by a process to react. The reactive
semantics of CCS (denoted by ) can be found in
\cite{Mil:PPCA}. Note that both the labels and the resulting states
contain the process variable . For the sake of space, we avoided to
report here the (extended) syntax of CCS: this is just the ordinary
syntax of CCS, together with process variables
(analogously to MAs and ACCS).

Following Definition~\ref{instance} for MAs, we define the LTS  for processes
over the standard syntax by instantiating the process variable
of the labels and of the resulting states.

Now let us consider the rule \textsc{Rcv}. If a process is ready
to receive on some unrestricted channel , then an interaction
takes place whenever it is embedded in an environment of the shape
\footnote{The LTS derived in
\cite{bgk:bisimulation-graph-enc} slightly differs from
. Besides dropping some not-engaged transitions (i.e.,
transitions that do not play any role in the notion of
bisimulation), we simplified the labels for \textsc{Snd} and \textsc{Rcv}:
these were, respectively,  and  for
 a summation variable. Since these variables do not occur in
the resulting states, they also play no role in the derived bisimilarity, and thus
we avoided to consider them in the labels.}. Recall that
the instantiation of the process variable  with a process
containing a free name that belongs to the bound names in  is
possible only -converting the resulting process .

Hereafter we use  (with ) to denote the ordinary LTS of CCS
\cite{MIL:CAC}. By comparing the latter with the LTS , it
is easy to see that  if and only if .
Moreover  iff  and
 iff . From these
facts, the main result of \cite{bgk:bisimulation-graph-enc}
follows: the ordinary bisimilarity of CCS (denoted by )
coincides with IPO bisimilarity. Instead, saturated bisimilarity is
too coarse: the (recursive) processes
 and  are e.g. saturated bisimilar.

\begin{figure}[!t]
\begin{center}
\begin{tabular}{p{6.5 cm} | p{6 cm}}
\begin{tabular}{l}
\textsc{\scriptsize(Tau)} \\\\
\textsc{\scriptsize(Rcv)} \\\\
\textsc{\scriptsize(Snd)} \\\\
\end{tabular}
\caption{The LTS }\label{LTSCCS} &
\begin{tabular}{l}
\textsc{\scriptsize(Tau)} \\\\
\textsc{\scriptsize(Rcv)} \\\\
\textsc{\scriptsize(Snd)} \\\\
\end{tabular}
\caption{The LTS }\label{LTSACCS}
\end{tabular}
\end{center}
\end{figure}

\paragraph{An ITS for ACCS.} Following \cite{bgk:bisimulation-graph-enc},
we propose an ITS for ACCS.
Fig.~\ref{LTSACCS} shows the LTS . The LTS
 is defined by instantiating the process variable of
the labels and of the resulting states.

The main difference between  and  is in
the rule \textsc{Rcv}: since outputs have no
continuation in ACCS, then the process variable  (that occurs
in ) is not needed in .

It is easy to see that also for ACCS there is a
close correspondence between the ordinary LTS semantics (in
Fig.~\ref{LTSAs}) and :  iff ,
 iff  and  iff .

However, in the asynchronous case, IPO-bisimilarity is too fine
grained. Indeed, the processes  and
 are asynchronously bisimilar, but they are not
IPO-bisimilar. In the next section we will introduce a new semantics
for RSs that generalizes both  and
.




\section{A New Semantics for Reactive Systems: -Bisimilarity} \label{sec:L1-Bisimulation}

As shown in Section \ref{sec:CCS}, IPO-bisimilarity coincides with the
ordinary bisimilarity in the case of CCS.  However, for many
interesting calculi, such as MAs and ACCS, it is often too
fine-grained. On the other side, as recalled above for CCS, saturated
bisimilarity is often too coarse.

In this section we introduce -indexed bisimilarity (shortly,
-bisimilarity), a novel kind of bisimilarity parametric with
respect to a class of contexts (also referred to as \emph{labels})
. For each class  satisfying some closure properties, the new
equivalence  is a congruence and .

Intuitively, -bisimulations can be thought of as something in between
IPO-bisimulations and semi-saturated bisimulations: if  belongs
to , then  must perform  whenever 
(as in the IPO-bisimulation), otherwise  (as in the
semi-saturated bisimulation).

\begin{definition}[-Bisimulation]\label{def:L1bis}
Let  be a class of contexts.
A symmetric relation  is an -\emph{bisimulation} if
whenever  then


-\emph{bisimilarity}  is the largest -bisimulation.
\end{definition}

It is easy to note that  generalizes both  and
 (and thus ). Indeed, in order to characterize
the former, it is enough to take as  the whole class of contexts,
while to characterize the latter, we take as  the empty class. In
Section~\ref{L=BS} we will show that for some ,
-bisimilarity also coincides with barbed saturated bisimilarity.
In the remainder of this section, we show that  is a
congruence. In order to prove this, we have to require the following
condition on .

\begin{definition} Let  be a class of arrows of a category. We say that  is
IPO-closed, if whenever the following diagram is an IPO and , then also .

\end{definition}

It is often hard to prove that a class of contexts is IPO-closed.
It becomes easier with concrete instances of RSs
that supply a constructive definition for IPOs, such as
bigraphs and borrowed contexts.

\begin{proposition}\label{prop:BISLisacongruence}

Let us consider a RS with redex RPOs and an IPO-closed
class  of contexts.
Then,   is a congruence.
\end{proposition}
\begin{center}
    \begin{tabular}{ccc}
      \xymatrix@C=15pt@R=15pt
      {
        &k_6\\
        k_4 \ar[ur]^{J[-]} & &\\
        &k_2\ar[ul]^{C[-]}  & &k_3 \ar[uull]_{D[-]}\\
        & &  0\ar[ul]^{P} \ar[ur]_{L}
      }

      &

      \xymatrix@C=15pt@R=15pt
     {
        &k_6\\
        k_4 \ar[ur]^{J[-]} & &k_5 \ar[ul]_{D_2[-]}\\
        &k_2\ar[ul]^{C[-]} \ar[ur]^{J'[-]} & &k_3 \ar[ul]_{D_1[-]}\\
        & &  0\ar[ul]^{P} \ar[ur]_{L}
      }

      &

      \xymatrix@C=15pt@R=15pt
     {
        &k_6\\
        k_4 \ar[ur]^{J[-]} & &k_5 \ar[ul]_{D_2[-]}\\
        &k_2\ar[ul]^{C[-]} \ar[ur]^{J'[-]} & &k_3 \ar[ul]_{E[-]}\\
        & &  0\ar[ul]^{Q} \ar[ur]_{L'}
      }
      \\
      ()&()&()
    \end{tabular}
  \end{center}
\begin{proof}

  In order to prove this theorem we will use the composition and decomposition properties
  of IPOs, namely Proposition 2.1 and Proposition 2.2 of \cite{DBLP:conf/concur/LeiferM00}.
  We have to prove that if  then .
We show that  s.t.  is an -bisimulation.



  Suppose that . Then there exists
  an IPO square like diagram (i) above, where
 , 
  and . Since, by hypothesis, the RS has
  redex RPOs, then we can construct an RPO as the one in diagram
  (ii) above. In this diagram, the lower square is an IPO, since RPOs
  are also IPOs (Proposition 1 of
  \cite{DBLP:conf/concur/LeiferM00}). Since the outer square is an IPO and the
  lower square is an IPO, by IPO decomposition property, it follows that
 also the upper square is an IPO.

Since  is composition-reflecting, then both  and
 belong to , and then . Now there
are two cases: either  or .

If , then also , because  is IPO-closed,
by hypothesis. Since , then  and . This means that there exists an IPO square like the
lower square of diagram (iii) above, where ,
 and . Now recall by the previous
observation that the upper square of diagram (iii) is also an IPO
and then, by IPO composition, also the outer square is an IPO. This
means that . Since , then
.

If , then either  or . In both
cases, from  we derive that  and
. This means that the lower square of diagram
(iii) above commutes. Since also the upper square commutes, then
also the outer square commutes. This means that . Since , then .
\end{proof}

\subsection{Barbed Saturated Bisimilarity via -bisimilarity}\label{L=BS}


Here we show that -bisimilarity can also characterize barbed
saturated bisimilarity, whenever the family of barbs and the set of
labels  satisfy suitable conditions. This result will be used in
later sections in order to show that -bisimilarity captures the
correct equivalences for MAs and ACCS.

In order to guarantee that , we need some
conditions ensuring that the checking of barbs of  is
already done in  by the labels in .
\begin{definition}\label{def:PredCapturing}
Let  be a set of labels and let  be a set of barbs. We say
that  is \emph{-capturing} if for each barb  there exists a
label  such that for each process ,  if and only if
.
\end{definition}

The next two definitions are needed to ensure that .

\begin{definition}\label{def:PredStable}
Let  be a relation and let  be a
predicate on processes. We say that  is
\emph{stable under } if whenever  and
 there exists  such that  and .
\end{definition}

For example, the predicates in Fig.~\ref{PredMA} and
Fig.~\ref{fig:arrayCCS} are stable under .

\begin{definition}\label{def:Lstable}
Let  be a relation and let  be a label. We say
that  is \emph{stable under } if the predicate
 is stable under .
\end{definition}

We can finally state a first correspondence result.

\begin{proposition} \label{Prop:BSB=LB} Let us consider an RS with
  redex RPOs, a set  of contextual barbs and a set  of
  labels. If  is -capturing and its labels are stable under
  , then  coincides with .
\end{proposition}

\begin{proof}
In order to prove that , we show that
 s.t.  is an
-bisimulation.

Suppose that . We have two cases: either  or . If , then  is stable under
 and thus, since ,  and
. For the case that , it is enough to
note that, since , then . Since
, then  and .

Now we show that  s.t. 
is a barbed semi-saturated bisimulation (i.e., ) and thus, since the RS has redex IPOs, by
Proposition \ref{PropBSS=BS} it follows that .

At first, we note that, since  is a set of contextual barbs,
in order to show that  satisfies the first condition of
Definition \ref{def:BSSbis} it suffices to show that 
implies . Since  is -capturing,  if 
then there is a label  such that 
if and only if . Since , then also
 and .

In order to prove the second condition of Definition
\ref{def:BSSbis}, it is enough to note that if 
then, for either  or ,
 with .
\end{proof}

As a corollary of the previous definition, we obtain the following property
that allows to check whenever IPO-bisimilarity coincides with barbed
saturated one.

\begin{lemma}
  Let us consider an RS with redex IPOs and a set  of contextual
  barbs. If the set of all labels is -capturing and each label is
  stable under , then  coincides with .
\end{lemma}



\section{-Bisimilarity for Mobile Ambients}\label{sec:LbisMA}
This section proposes a new labelled characterization of the
reduction barbed congruence for MAs, presented in Section~\ref{sec:MA}.
In particular, by using the ITS  (also
in Section~\ref{sec:MA}) we define an -bisimilarity
that captures barbed saturated bisimilarity for MAs,
coinciding with reduction barbed congruence.



\begin{proposition}[see~\cite{BGMFOSSACS09}, Theorem~3] 
\label{RBC=BSB}
  Reduction barbed congruence over MAs  coincides with
  barbed saturated bisimilarity .
\end{proposition}

As shown in Section~\ref{L=BS}, we can characterize barbed saturated bisimilarity
on a set of contextual barbs  through the IPO transition system and a set of labels .
In particular, as required by Proposition \ref{Prop:BSB=LB}, the set 
must be -capturing and each  must be stable under the barbed saturated bisimilarity.

We denote by  the set of barbs of MAs,
recalling that MAs barbs are contextual barbs~\cite{BGMFOSSACS09}.

\begin{proposition}[see~\cite{BGMFOSSACS09}, Proposition~6] 
  \label{MAsCB}
 is a set of contextual barbs.
\end{proposition}

Therefore, we can characterize reduction barbed congruence over MAs by instantiating
Definitions~\ref{def:L1bis} with the   and a set  of labels having the two properties
said above.

First of all, we find some labels of  that capture the barbs of MAs.
This ensures that the checking of barbs of the barbed saturated bisimilarity is
done in the -bisimilarity by the first condition of its definition.
It is easy to note that a MAs process  observes a unrestricted ambient  at top-level,
in symbols , if and only if it can execute a transition labelled with
 or with .
Therefore,  is -capturing if it contains at least one kind of these labels.
We choose to consider labels of the first type, that is, having
the shape  , for  ambient name and  pure process.

It is possible to prove that these labels are stable under
. Therefore,
if we consider the set  defined below, we obtain an -bisimilarity for MAs
that is able to characterize .





\begin{proposition} \label{LMAO-capturing}\label{def:LMAs}
Let  be the set of all labels of the   having
the shape  , for  ambient name and  pure process.
Then,  is -capturing.
\end{proposition}

\begin{proof}
We have to show that for each barb  there exists a label 
such that for each process ,  if and only if .

It is easy to note that, given a barb , we have that for each process ,  if and only if ,
with  pure process. Since we know that  contains all
labels having the shape  , for 
ambient name and  pure process, we can conclude that  is
-capturing.
\end{proof}

Now, in order to prove that each  is stable under
, we exploit a predicate such that
it is stable under  and equivalent
to the one of Definition \ref{def:Lstable}.

\begin{lemma} \label{lemma:PredMA}
Let  be the binary predicate
on MAs processes shown in Fig. \ref{PredMA}, for  ambient name
and  pure process.
Then,  is stable under 
and for each  and ,  if and only if
.
\end{lemma}

\begin{proof}
We begin by proving that the predicate 
is stable under .

Assume that  and  holds.
Since  holds, then
there exists a process  and an ambient  fresh for  and ,
such that , ,
 and , with
.

Since  and , then
 and .
Therefore, it is obvious that also .
Now, we know that , hence we can say
that  and .
From this follows that, since , then also .
So, we can conclude that  holds, hence 
is stable under .

Now we show that for each  and ,  iff
.

Assume that  holds.
This means that there exists a process  and an ambient  fresh for ,
such that , ,
 and , with
.
The fact that  and  means that
the capability  has been executed, hence
there must be a unrestricted ambient  at top-level of , i.e.,
 and .
From this follows that ,
and since , then .
Moreover, by knowing that  and ,
we can conclude that .

Assume that . This means that
, where ,  and
. We consider the context  with . It is easy to note that  s.t.  and .
Therefore, since , we also have that . Now, we can note that  and, since  is
fresh for , .
\end{proof}

\begin{figure}[!t]
\begin{tabular}{p{3 cm} p{12.1 cm}}
\hline
\\
 &  and  s.t.  and  \\
& with \\ \\
\hline
\end{tabular}
\caption{Predicate for the label .}
\label{PredMA}
\end{figure}

\begin{proposition} \label{LMAStable}
All labels in  are stable under .
\end{proposition}

The proof of the proposition above trivially follows from Lemma \ref{lemma:PredMA}.



We finally introduce the main characterization proposition.

\begin{proposition}
.
\end{proposition}

\begin{proof}
  First of all, by Proposition \ref{MAsCB}, we know that MAs barbs are
  contextual.  Moreover, by Propositions \ref{LMAO-capturing} and
  \ref{LMAStable}, we know that  is
  -capturing and it contains only labels
  that are stable under .  Therefore,
  thanks to Proposition \ref{Prop:BSB=LB}, we can conclude that
  .
\end{proof}

The -bisimilarity  presented above is not the only
one which is able to characterize barbed saturated bisimilarity
. For example, as said before, we
can choose to consider all labels of the shape : besides being able to capture MAs barbs, they are
also stable under . However,
generally, we can consider the sets  containing at least all
the labels of the shape  or  to capture barbs, and other labels of 
that are stable under , i.e., labels
such that it is possible to define a predicate analogous to the one
we defined for the labels .



\section{-Bisimilarity for (Asynchronous) CCS} \label{sec:L-BisCCS}

Section \ref{sec:CCS} has shown that IPO-bisimilarity coincides with
the ordinary bisimilarity of CCS (), while it is
strictly contained in asynchronous bisimilarity. In this section, we
first show that -bisimilarity generalizes both cases and then we
prove that these also coincide with their barbed saturated
bisimilarities.

\paragraph{-Bisimilarity for Asynchronous CCS.}
In asynchronous bisimulation (Definition \ref{def:Abis}),
transitions labelled with  and  (corresponding to 
and  in , respectively) must be matched by transitions
with the same labels. Moreover, when  (corresponding to
 in ) then either  and  or  and . This is equivalent to require that 
and .
Thus, in order to characterize  as -bisimilarity, it
suffices to choose as  the set of labels corresponding to 
and .



\begin{proposition}
  Let  be the set containing the labels of the ITS  of the
  shape  and , for  channel name and  pure
  process.  Then, .
\end{proposition}

\paragraph{-Bisimilarity for CCS.} Since IPO-bisimilarity coincides
with , in order to characterize  as
-bisimilarity, it is enough to include all the IPO-labels into
.



\begin{proposition}
Let  be the set containing all the labels of the ITS .
Then, .
\end{proposition}

\paragraph{From -Bisimilarity to Barbed Saturated Bisimilarity.}
It is important to note that the choice of  and  is
not arbitrary. Indeed, in both cases,  and
 coincide with barbed saturated bisimilarities. This is
not a new result, but it is interesting to see that it can be easily
proved by following the same approach that we have used for MAs in
Section~\ref{sec:LbisMA}.

For the synchronous case, barbs are defined as  if and
only if
 and  if and only if . Since
 contains the labels  and 
(corresponding to  and  in the ordinary LTS), then
 is barb capturing.

It is also easy to see that the barbs are contextual. Then, in order
to use Proposition \ref{Prop:BSB=LB}, we only have to prove that all
the labels in  are stable under barbed congruence.
Analogously to MAs, we define some additional predicates. These are
shown in Fig. \ref{fig:arrayCCS}. It is easy to see that for each
label ,  in  if and only if . It is also easy to show that all of them are stable
under .

\begin{figure}
\begin{tabular}{p{3 cm} p{12.1 cm}}
\hline
\\
 &  and   s.t.
   and  \\
   &  and   s.t.
   and  \\
   &  \\ \\
\hline
\end{tabular}
\caption{Predicates for CCS}\label{fig:arrayCCS}
\end{figure}

For the asynchronous case, recall that  only contains labels of
the form  and  (corresponding to labels  and
 in the ordinary LTS). Since only output barbs
 are defined, then  is barb capturing. In
order to prove that each label in  is stable under  we
can use for  and  the predicates that we have used in
the synchronous case (Fig.~\ref{fig:arrayCCS}).

It is worth noting that labels of the form  are not
stable under . Indeed, we cannot adopt the predicate used in
the synchronous case (the first in Fig.~\ref{fig:arrayCCS}), since
outputs have no continuation in ACCS.



\section{Conclusions and future work}
\label{sec:Concl}

The paper introduces a novel behavioural equivalence for RSs, namely,
-bisimulation: a flexible tool, parametric with respect to a set of
labels . The associated bisimilarity is proved to be a
congruence, and it is shown to be intermediate between the standard
IPO and saturated semantics for RSs: indeed, it is able to recover
both of them, by simply varying the set of labels . More
importantly, also the more expressive barbed saturated semantics can
be recast, as long as the set  satisfies suitable conditions.

As for any newly proposed semantics, its expressiveness and ease of
use have to be tested against suitable case studies. We thus
considered a recently introduced IPO transition system for
MAs, and two other IPO transition systems for CCS and its asynchronous
variant. We show that in all those cases, for a right choice of ,
-bisimilarity precisely captures the standard semantics for the calculus at hand.

We can foresee three immediate extensions of our work. First of all,
we would like to precisely understand the notion of IPO-closedness,
which is required for the set of labels , in order for
-bisimilarity to be a congruence. It would be important to
establish suitable and more manageable conditions under which a set of
arrows of a given category satisfies that property, especially for
those RSs where IPOs have an inductive presentation (such as for those
induced by the borrowed context mechanism).

Moreover, we would like to further elaborate on the connection between
-bisimilarity and barbed semantics, moving beyond the preliminary
results presented in Section~\ref{L=BS}. As a start, in order to
establish conditions ensuring that barbs satisfy the pivotal property
of being contextual; and, more to the point, for checking whenever a
set of labels is barb capturing and contains only labels stable under
barbed saturated bisimilarity.
As far as the specific MAs case study
is concerned, most of the IPO labels occurring in our transition
system are indeed stable, i.e., the relative labelled transitions
can be characterized by a
predicate which is stable under the barbed saturated bisimilarity.
The only labels that are not stable are the ones
of the shape  and  of the rule \textsc{InAmb}
and \textsc{OutAmb}, respectively.
It seems intriguing that those same labels required the
introduction of so-called Honda-Tokoro inference rules
in~\cite{PawelAmbient} for capturing the reduction barbed congruence
by means of standard bisimilarity.

Finally, we remark that so far in our methodology the choice of the
``right'' set , as well as the identification of a meaningful set
of barbs, is left to the ingenuity of the researcher. We would like to
devise a general theory that relying only on the syntax of the
calculus at hand and on the associated reduction semantics might allow
to automatically derive either a suitable family of barbs or some kind
of basic set of observations, along the lines of the proposals
in~\cite{HY,PawBarbs,RathkeS09}.

\paragraph{\textbf Acknowledgements.}
We are indebted to the anonymous referees for their useful remarks, which helped
us in improving the overall presentation of the paper.

\bibliographystyle{eptcs}
\bibliography{biblio}
\end{document}
