\PassOptionsToPackage{numbers, compress}{natbib}
\documentclass{article}





\usepackage[preprint]{neurips_2020}





\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{multirow}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{xspace}
\usepackage{xcolor}
\usepackage{array}
\usepackage{enumitem}
\usepackage[font=small,labelfont=bf]{caption}
\usepackage{adjustbox}
\usepackage{wrapfig}


\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\makeatletter
\DeclareTextCommand{\textprime}{\encodingdefault}{\mbox{}}
\newcommand{\elua}{\operatorname{CELU}}
\newcommand{\elu}{\operatorname{ELU}}
\newcommand{\srelu}{\operatorname{SmoothReLU}}


\usepackage{amssymb}\usepackage{pifont}\newcommand{\cmark}{\ding{51}}\newcommand{\xmark}{\ding{55}}\newcolumntype{H}{>{\setbox0=\hbox\bgroup}c<{\egroup}@{}}
\newlength\savewidth\newcommand\shline{\noalign{\global\savewidth\arrayrulewidth
  \global\arrayrulewidth 1pt}\hline\noalign{\global\arrayrulewidth\savewidth}}
\makeatletter\renewcommand\paragraph{\@startsection{paragraph}{4}{\z@}
  {.2em \@plus1ex \@minus.2ex}{-.5em}{\normalfont\normalsize\bfseries}}\makeatother
\newcommand{\app}{\raise.17ex\hbox{}}

\makeatletter
\DeclareRobustCommand\onedot{\futurelet\@let@token\@onedot}
\def\@onedot{\ifx\@let@token.\else.\null\fi\xspace}
\def\eg{\emph{e.g}\onedot} \def\Eg{\emph{E.g}\onedot}
\def\ie{\emph{i.e}\onedot} \def\Ie{\emph{I.e}\onedot}
\def\cf{\emph{c.f}\onedot} \def\Cf{\emph{C.f}\onedot}
\def\etc{\emph{etc}\onedot} \def\vs{\emph{vs}\onedot}
\def\wrt{w.r.t\onedot} \def\dof{d.o.f\onedot}
\def\etal{\emph{et al}\onedot}
\definecolor{Highlight}{HTML}{39b54a}
\definecolor{shapecolor}{HTML}{7030A0}
\definecolor{texturecolor}{HTML}{00B0F0}
\newcommand{\cihang}[1]{{\color{magenta}[cihang: #1]}}
\newcommand{\mx}[1]{{\color{blue}[MX: #1]}}
\newcommand{\BG}[1]{{\color{blue}[BG: #1]}}
\makeatother


\title{Smooth Adversarial Training}

\author{
Cihang Xie\textsuperscript{1,2}\footnotemark \quad
Mingxing Tan\textsuperscript{1} \quad
Boqing Gong\textsuperscript{1} \quad
Alan Yuille\textsuperscript{2} \quad
Quoc V. Le\textsuperscript{1} \vspace{.3em}\\
\textsuperscript{1}Google \qquad\qquad \textsuperscript{2}Johns Hopkins University
}

\begin{document}

\maketitle
 \renewcommand*{\thefootnote}{\fnsymbol{footnote}}
 \setcounter{footnote}{1}
 \footnotetext{Work done during an internship at Google.}
 \renewcommand*{\thefootnote}{\arabic{footnote}}
 \setcounter{footnote}{0}
 
\maketitle


\begin{abstract}
It is commonly believed that networks cannot be both accurate and robust, that gaining robustness means  losing accuracy. It is also generally believed that, unless making networks larger, network architectural elements would otherwise matter little in improving adversarial robustness. Here we present evidence to challenge these common beliefs by a careful study about adversarial training. Our key observation is that the widely-used ReLU activation function significantly weakens adversarial training due to its non-smooth nature. Hence we propose \emph{smooth adversarial training (SAT)}, in which we replace ReLU with its smooth approximations to strengthen adversarial training. The purpose of smooth activation functions in SAT is to allow it to find harder adversarial examples and compute better gradient updates during adversarial training. Compared to standard adversarial training, SAT improves adversarial robustness for ``free'', \ie, no drop in accuracy and no increase in computational cost. For example, without introducing additional computations, SAT significantly enhances ResNet-50's robustness from 33.0\% to 42.3\%, while also improving  accuracy by 0.9\% on ImageNet. SAT also works well with larger networks:  it helps EfficientNet-L1 to achieve 82.2\%  accuracy and 58.6\% robustness on ImageNet, outperforming the previous state-of-the-art defense by 9.5\% for accuracy and 11.6\% for robustness.
\end{abstract}


\section{Introduction}
Convolutional neural networks can be easily attacked by adversarial examples, which are computed by adding small perturbations to clean inputs \cite{Szegedy2014}. Many efforts have been devoted to improving network resilience against adversarial attacks~\cite{Guo2018,Papernot2016,Buckman2018,Xie2018,Madry2018,prakash2018,pang2019improving}. Among them, 
adversarial training \cite{Goodfellow2015,Kurakin2017,Madry2018}, which trains networks with adversarial examples on-the-fly, stands as one of the most effective methods.  Later works further improve adversarial training by feeding the networks with harder adversarial examples \cite{wang2019a}, maximizing the margin of networks \cite{ding2020}, optimizing a regularized surrogate loss \cite{Zhang2019a}, \etc. While these methods achieve stronger adversarial robustness, they sacrifice the accuracy on clean inputs. It is generally believed that this  trade-off between accuracy and robustness might be inevitable \cite{Tsipras2018}, unless additional computational budgets are introduced to enlarge network capacities \cite{Madry2018,xie2020intriguing}.

Another popular direction for increasing robustness against adversarial attacks is gradient masking \cite{papernot2017practical,Athalye2018}, which usually introduces non-differentiable operations (e.g., discretization \cite{Buckman2018,rozsa2019improved}) to obfuscate gradients. With degenerated gradients, attackers cannot successfully optimize the targeted loss and fail to break such defenses. Nonetheless, gradient masking will be ineffective if its differentiable approximation is used for generating adversarial examples \cite{Athalye2018}. 

The bitter history of gradient masking defenses motivates us to rethink the relationship between gradient quality and adversarial robustness, especially in the context of adversarial training where gradients are applied more frequently than standard training. In addition to computing gradients to update network parameters, adversarial training also requires gradient computation for generating training samples. Guided by this principle, we identify that ReLU, a widely-used activation function in most network architectures, significantly weakens adversarial training due to its non-smooth nature, \eg, ReLU's gradient gets an abrupt change when its input is zero, as illustrated in Figure~\ref{fig:forward_backward}.

\begin{figure}[t!]
    \centering
    \includegraphics[width=0.75\linewidth]{forward_backward.pdf}
    \vspace{-0.75em}
    \caption{Left Panel: ReLU and Parametric SoftPlus. Right Panel: the first derivatives for ReLU and Parametric SoftPlus. Compared to ReLU, Parametric Softplus is smooth with continuous derivatives.}
    \label{fig:forward_backward}
    \vspace{-1.35em}
\end{figure}


To fix the issue induced by ReLU, in this paper, we propose smooth adversarial training (SAT), which enforces architectural smoothness via replacing ReLU with its smooth approximations\footnote{More precisely, when we say a function is smooth in this paper, we mean this function is \textsuperscript{1} smooth, \ie, its first derivative is continuous everywhere.} for improving the gradient quality in adversarial training  (Figure~\ref{fig:forward_backward} shows Parametric SoftPlus, an example of smooth approximations for ReLU). With smooth activation functions, SAT is able to feed the networks with harder adversarial training samples and compute better gradient updates for network optimization, hence substantially strengthens adversarial training. 
Our experiment results show that SAT improves adversarial robustness for ``free'', \ie, without incurring additional computations or degrading standard accuracy. For instance, by training with the economical \emph{single-step PGD attacker}\footnote{Models trained with single-step PGD attackers only cost \app  training time than standard training}~\cite{Madry2018} on ImageNet \cite{Russakovsky2015}, SAT significantly improves ResNet-50's robustness by 9.3\%, from 33.0\% to 42.3\%, while increasing the standard accuracy by 0.9\% without incurring additional computational cost. 

We also explore the limits of SAT with larger networks. We obtain the best result by using EfficientNet-L1~\cite{Tan2019,Xie2019a}, which achieves 82.2\% accuracy and 58.6\% robustness on ImageNet, significantly outperforming the prior art~\cite{Qin2019} by 9.5\% for accuracy and 11.6\% for robustness. 


\section{Related Works}
\paragraph{Adversarial training.}
Adversarial training improves robustness by training models on adversarial examples \cite{Goodfellow2015,Kurakin2017,Madry2018}. Existing works suggest that, to further improve adversarial robustness, we need to either sacrifice accuracy on clean inputs \cite{wang2019a,wang2020,Zhang2019a,ding2020}, or incur additional computational cost \cite{Madry2018,xie2020intriguing}. This phenomenon is generally referred to as the \emph{no free lunch in adversarial robustness} \cite{Tsipras2018,Nakkiran2019,su2018robustness}. In this paper, we show that, with SAT, adversarial robustness can be improved for ``free''. 

\paragraph{Gradient masking.} 
Besides training models on adversarial data, alternatives for improving adversarial robustness include defensive distillation \cite{Papernot2016}, randomized transformations \cite{Xie2018,Dhillon2018,liu2018towards,wang2018defensive,bhagoji2018enhancing},  adversarial input purification \cite{Guo2018,prakash2018,meng2017magnet,song2017pixeldefend,samangouei2018defense,Liao2018,bhagoji2018enhancing}, \etc. Nonetheless, these defense methods degenerate the gradient quality, therefore induce the gradient masking issue \cite{papernot2017practical}, which gives a false sense of adversarial robustness \cite{Athalye2018}. In contrast to these works, we aim to improve adversarial robustness by providing networks with better gradients, but in the context of adversarial training.


\section{ReLU Weakens Adversarial Training} \label{sec:motivation}
We hereby perform a series of control experiments in the backward pass of gradient computations to investigate how ReLU weakens, and how its smooth approximation strengthens adversarial training. 

\subsection{Adversarial Training}
Adversarial training \cite{Goodfellow2015,Madry2018}, which trains networks with adversarial examples on-the-fly, aims to optimize the following framework:

where  is the underlying data distribution,   is the loss function,  is the network parameter,  is a training sample with the ground-truth label ,   is the added adversarial perturbation, and  is the allowed perturbation range. 
As shown in Equation~\eqref{eq:adv_training}, adversarial training consists of two computation steps: an \textbf{inner maximization step}, which computes adversarial examples, and an \textbf{outer minimization step}, which computes parameter updates.

\paragraph{Adversarial training setup.} We choose ResNet-50 \cite{He2016} as the backbone network. We apply the PGD attacker \cite{Madry2018} to generate adversarial perturbations . Specifically, we select the cheapest version of PGD, \emph{single-step PGD} (PGD-1), to lower the training cost. Following \cite{Shafahi2019,wong2020fast}, we set the maximum per-pixel change  and the attack step size . We follow the basic ResNet training recipes to train models on ImageNet: models are trained for a total of 100 epochs using momentum SGD optimizer, with the learning rate decreased by  at the 30-th, 60-th and 90-th epoch; no regularization except a weight decay of 1e-4 is applied.

When evaluating adversarial robustness, we measure the model's top-1 accuracy against the 200-step PGD attacker (PGD-200) on the ImageNet validation set, with the maximum perturbation size  and the step size . We note 200 attack iteration is enough to let PGD attacker converge. Meanwhile, we report the model's top-1 accuracy on the original ImageNet validation set.

\subsection{How Gradient Quality Affects Adversarial Training?}
As shown in Figure~\ref{fig:forward_backward}, the widely used activation function, ReLU, is non-smooth, \ie, its gradient takes an abrupt change, when its input is 0, which significantly degrades the gradient quality. We conjecture that this non-smooth nature hurts the training process, especially when we train models adversarially. This is because, compared to standard training which only computes gradients for updating network parameter , adversarial training requires additional computations for the inner maximization step to craft the perturbation . 

To fix this problem, we first introduce a smooth approximation of ReLU, named \emph{Parametric Softplus} \cite{Nair2010}, as follows, 

where the hyperparameter  is used to control the curve shape. The derivative of this function w.r.t. the input  is:

To better approximate the curve of ReLU, we empirically set . As shown in Figure~\ref{fig:forward_backward}, compared to ReLU, Parametric Softplus (=10) is smooth because it has a continuous derivative.

With Parametric Softplus, we next diagnose how gradient quality in \emph{the inner maximization step} and \emph{the outer minimization step} affects the accuracy and robustness of ResNet-50 in adversarial training. \textbf{To clearly benchmark the effects, we only substitute ReLU with Equation~\eqref{eqn:parametric_softplus} in the backward pass, while leaving the forward pass unchanged}, \ie, ReLU is always used for model inference. 

\paragraph{Improving gradient quality for the adversarial attacker.} We first take a look at the effects of gradient quality on computing adversarial examples (\ie, \emph{the inner maximization step}) during training. More precisely, in the inner step of adversarial training, we use ReLU in the forward pass, but Parametric Softplus in the backward pass; and in the outer step, we use ReLU in both the forward and the backward pass. As shown in the second row of Table \ref{tab:motivation}, when the attacker uses Parametric Softplus's gradient to craft training samples, the resulted model exhibits a performance trade-off compared to the ReLU baseline, \eg, it improves adversarial robustness by 1.5\% but degrades accuracy by 0.5\%. We hypothesize that the enhanced adversarial robustness can be attributed to harder adversarial examples generated during training, \ie, better gradients for the inner maximization step boost the attacker's strength. To further verify this hypothesis, we evaluate the robustness of two ResNet-50 models via PGD-1 (vs.\ PGd-200 in Table~\ref{tab:motivation}), one with standard training and one with adversarial training. Specifically, during the evaluation, the attacker uses ReLU in the forward pass, but Parametric Softplus in the backward pass. With better gradients, the PGD-1 attacker is strengthened and hurts models more: it can further decrease the top-1 accuracy by 4.0\% (from 16.9\% to 12.9\%) on the standard training and by 0.7\% (from 48.7\% to 48.0\%) on the adversarial training (both not shown in Table~\ref{tab:motivation}). Finally, as shown in Table 1 (second row), we note that this robustness improvement is at the expense of  accuracy, which is consistent with previous works~\cite{wang2019a}.

\paragraph{Improving gradient quality for network parameter updates.} We then study the role of gradient quality on updating network parameters (\ie, \emph{the outer minimization step}) during training. More precisely, in the inner step of adversarial training, we use ReLU; but in the outer step, we use ReLU in the forward pass, and Parametric Softplus in the backward pass. Surprisingly, this method improves adversarial robustness for ``free''. As shown in the third row of Table~\ref{tab:motivation}, without incurring additional computations, adversarial robustness is boosted by 2.8\%, and meanwhile accuracy is improved by 0.6\%, compared to the ReLU baseline. We note the corresponding training loss also gets lower: the cross-entropy loss on the training set is reduced from 2.71 to 2.59. These results of better robustness, accuracy, and lower training loss together suggest that, with Equation~\eqref{eqn:parametric_softplus_gradient}, networks are able to compute better gradient updates in adversarial training. Interestingly, we also observe that better gradient updates improve the standard training, \ie, with ResNet-50, training with better gradients is able to improve accuracy from 76.8\% to 77.0\%, and reduces the corresponding training loss from 1.22 to 1.18. These results on both adversarial and standard training  suggest that updating network parameters using better gradients could serve as a principle for improving performance in general, while keeping the inference process of the model unchanged (\ie, ReLU is still used during inference). 

\paragraph{Improving gradient quality for both the adversarial attacker and network parameter updates.} Given the observation that improving ReLU's gradient for either the adversarial attacker or the network optimizer
benefits robustness, we further enhance adversarial training by replacing ReLU with Parametric Softplus in all backward passes, but keeping ReLU in all forward passes. As expected, such a trained model reports the best robustness so far, \ie, as shown in the last row of Table~\ref{tab:motivation}, it substantially outperforms the ReLU baseline by 3.9\% for robustness. Interestingly, this improvement still comes for ``free'', \ie, it reports 0.1\% higher accuracy than the ReLU baseline. We conjecture this is mainly due to the positive effect on accuracy brought by computing better gradient updates (increase accuracy) slightly overriding the negative effects on accuracy brought by creating harder training samples (hurt accuracy) in this experiment.

\begin{table}[t!]
\centering
\resizebox{\linewidth}{!}{
\begin{tabular}{l|c|c|c|c}
                           & Improving Gradient Quality for & Improving Gradient Quality for & \multirow{2}{*}{Accuracy (\%)} & \multirow{2}{*}{Robustness (\%)}  \\ 
                           & the Adversarial Attacker &  the Network Parameter Updates &   &  \\ \shline
\multirow{4}{*}{ResNet-50} & \xmark                                           & \xmark                                    & 68.8                   & 33.0                        \\ \cline{2-5} 
                           & \cmark                                           & \xmark                                    & 68.3 \textcolor{red}{(-0.5)}            & 34.5 \textcolor{blue}{(+1.5)}                 \\ \cline{2-5} 
                           & \xmark                                           & \cmark                                    & 69.4 \textcolor{blue}{(+0.6)}            & 35.8 \textcolor{blue}{(+2.8)}                 \\ \cline{2-5} 
                           & \cmark                                           & \cmark                                    & 68.9 \textcolor{blue}{(+0.1)}            & 36.9 \textcolor{blue}{(+3.9)}                 
\end{tabular}
}
\caption{\textbf{ReLU significantly weakens adversarial training}. By improving gradient quality for either the adversarial attacker or the network optimizer, the resulted model obtains better robustness than ReLU baseline. The best robustness can be achieved by adopting better gradients for both the attacker and the network optimizer.}
\label{tab:motivation}
\vspace{-1.5em}
\end{table}



\subsection{Can Other Training Enhancements Remedy ReLU's Gradient Issue?}
\paragraph{More attack iterations.} It is known that increasing the number of attack iterations can create harder adversarial examples \cite{Madry2018}.
We confirm in our own experiments that by training with the PGD attacker with more iterations, the resulted model exhibits a similar behavior to the case where we apply better gradients for the attacker. By increasing the attacker's cost by , PGD-2 improves the ReLU baseline by 0.6\% for robustness while losing 0.1\% for accuracy. This result suggests we can remedy ReLU's gradient issue \emph{in the inner step of adversarial training} if more computations are given.

\paragraph{Training longer.} It is also known that longer training lowers the training loss \cite{hoffer2017train}, which we explore next.
Interestingly, with a  training cost compared to the standard setup (\eg, 200 epochs), though the final model indeed achieves a lower training loss (from 2.71 to 2.62), there is still a trade-off between accuracy and robustness. Longer training gains 2.6\% for accuracy but loses 1.8\% for robustness. On the contrary, applying better gradients for optimizing networks in the previous section improves both robustness and accuracy. 
This discouraging result suggests that training longer cannot fix the issues  \emph{in the outer step of adversarial training} caused by ReLU's poor gradient. 

\paragraph{Conclusion.} Given these results, we conclude that ReLU significantly weakens adversarial training. Moreover, it seems that the degenerated performance cannot be simply remedied even with training enhancements (\ie, increasing the number of attack iterations \& training longer). We identify that the key is ReLU's poor gradient---by replacing ReLU with its smooth approximation \emph{only in the backward pass} substantially improves robustness, even without sacrificing accuracy and incurring additional computational cost. In the next section, we show that making activation functions smooth is a good design principle for enhancing adversarial training in general.


\section{Smooth Adversarial Training}
As shown above, improving ReLU's gradient can both strengthen the attacker and provide better gradient updates. Nonetheless, this strategy may be suboptimal as there still is a discrepancy between the forward pass (which we use ReLU) and the backward pass (which we use Parametric Softplus). 

To fully exploit the potential of training with better gradients, we hereby propose smooth adversarial training (SAT), which enforces architectural smoothness via the exclusive usage of smooth activation functions in adversarial training. We keep all other network components the same, as most of them will not result in the issue of poor gradient.\footnote{We ignore the gradient issue caused by max pooling, which is also non-smooth, in SAT. This is because modern architectures rarely adopt it, \eg. only 1 max pooling layer in ResNet \cite{He2016}, and 0 in EfficientNet \cite{Tan2019}.}

\subsection{Adversarial Training with Smooth Activation Functions}
We consider the following activation functions as the smooth approximations of ReLU in SAT (Figure~\ref{fig:smooth_activation} plots these functions as well as their derivatives):
\begin{itemize}
[leftmargin=*]
  \setlength\itemsep{0.1em}
  \item \textbf{Softplus} \cite{Nair2010}: . We also consider its parametric version , and set  as in Section \ref{sec:motivation}.

  \item \textbf{Swish} \cite{ramachandran2017searching,elfwing2018sigmoid}: . Compared to other activation functions, Swish has a non-monotonic ``bump''  when .

  \item \textbf{Gaussian Error Linear Unit} (GELU) \cite{hendrycks2016gaussian}: , where  is the cumulative distribution function of the standard normal distribution. 
  
  
  \item \textbf{Exponential Linear Unit} (ELU) \cite{clevert2015fast}:
  
  where  as default. Note that when , the gradient of ELU is not continuously differentiable anymore. We will be discussing the effects of these non-smooth variants of ELU () on adversarial training in Section~\ref{sec:non-smooth ELU}.
\end{itemize}

\begin{figure}[t!]
    \centering
    \includegraphics[width=0.75\linewidth]{smooth_activation.pdf}
    \vspace{-0.5em}
    \caption{Visualizations of smooth activation functions and their derivatives.}
    \label{fig:smooth_activation}
    \vspace{-0.9em}
\end{figure}


\paragraph{Main results.} 
We follow the settings in Section~\ref{sec:motivation} to adversarially train ResNet-50 equipped with these smooth activation functions. The results are shown in Figure~\ref{fig:smooth_function}. Compared to the ReLU baseline, all smooth activation functions substantially boost robustness, while keeping the standard accuracy almost the same. For example, smooth activation functions at least boost robustness by 5.7\% (using Parametric Softplus, from 33\% to 38.7\%). The strongest robustness is achieved by Swish \cite{ramachandran2017searching}, which enables ResNet-50 to achieve 42.3\% robustness and 69.7\% standard accuracy. 

Additionally, we compare to the setting in Section \ref{sec:motivation} where Parametric Softplus is only applied at the backward pass. Interestingly, by additionally replacing ReLU with Parametric Softplus at the forward pass, the resulted model further improves robustness by 1.8\% (from 36.9\% to 38.7\%) while keeping the accuracy almost the same, demonstrating the importance of applying smooth activation functions in both forward and backward passes in SAT.

\subsection{Ruling Out the Effect From }
Compared to ReLU, in addition to being smooth, the functions above have non-zero responses to negative inputs () which may also affect adversarial training. To rule out this factor, we hereby propose SmoothReLU, which flattens the activation function by only modifying ReLU after ,

where  is a learnable variable shared by all channels, and is constrained to be positive. We note SmoothReLU is always continuously differentiable regardless the value of , as

SmoothReLU converges to ReLU when . Note that  needs to be initialized at a large enough value (\eg, 400 in our experiments) to avoid the gradient vanishing problem at the beginning of training. We plot SmoothReLU and its first derivative in Figure~\ref{fig:smooth_activation}.

We observe SmoothReLU substantially outperforms ReLU by 7.3\% for robustness (from 33.0\% to 40.3\%), and by 0.6\% for accuracy (from 68.8\% to 69.4\%), therefore clearly demonstrates the importance of a function to be smooth, and rules out the effect from having responses when .

\begin{figure}[t!]
\begin{minipage}{\linewidth}
  \begin{minipage}[b]{0.7\linewidth}
    \centering
    \includegraphics[width=\linewidth]{smooth_function.pdf}
    \captionof{figure}{Smooth activation functions improve adversarial training. Compared to ReLU, all smooth activation functions significantly boost robustness, while keeping accuracy almost the same.}
    \label{fig:smooth_function}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.22\linewidth}
    \centering
    \resizebox{\linewidth}{!}{
    \small
    \begin{tabular}{l|c|c}
    \multirow{2}{*}{} & \multicolumn{2}{c}{Robustness (\%)} \\ \cline{2-3} 
                          & ELU                     & CELU                   \\ \shline
    1                      & \multicolumn{2}{c}{41.1}                        \\ \hline
    1.2                    & \textcolor{gray}{-0.3}             & \textcolor{gray}{+0.1}                 \\ 
    1.4                    & \textcolor{orange}{-2.0}             & \textcolor{gray}{-0.3}            \\ 
    1.6                    & \textcolor{orange}{-3.7}             & \textcolor{gray}{-0.3}            \\ 
    1.8                    & \textcolor{red}{-6.2}             & \textcolor{gray}{-0.2}           \\ 
    2.0                    & \textcolor{red}{-7.9}             & \textcolor{gray}{-0.5}            \\ 
    \end{tabular}
    }
    \captionof{table}{Robustness comparison between ELU (non-smooth when ) and CELU (always smooth ).}
    \label{tab:elu_celu}
  \end{minipage}
\end{minipage}
\vspace{-1em}
\end{figure}


\subsection{Case Study: Stabilizing Adversarial Training with ELU using CELU}
\label{sec:non-smooth ELU}
In the analysis above, we show that adversarial training can be greatly improved by replacing ReLU with its smooth approximations. To further demonstrate the generalization of SAT (beyond ReLU), we discuss another type of activation function---ELU. The first derivative of ELU is shown below:

Here we mainly discuss the scenario when ELU is non-smooth, \ie, . As can be seen from Equation~\eqref{eqn:non-smooth ELU}, ELU's gradient is not continuously differentiable anymore, \ie,  when , therefore resulting in an abrupt gradient change like ReLU. Specifically, we consider the scenario , where the gradient abruption becomes more drastic with a larger value of .

We show the adversarial training results in Table~\ref{tab:elu_celu}. Interestingly, we observe that the adversarial robustness is highly dependent on the value of ---the strongest robustness is achieved when the function is smooth (\ie, , 41.4\% robustness), and all other choices of  monotonically decrease the robustness when  gradually approaches 2.0. For instance, with , the robustness drops to only 33.2\%, which is  lower than that of using . The observed phenomenon here is consistent with our previous conclusion on ReLU---non-smooth activation functions significantly weaken adversarial training.

To stabilize the adversarial training with ELU, we apply its smooth version, CELU \cite{barron2017continuously}, which re-parametrize ELU to the following format:

The first derivatives of CELU can be written as follows:

With this parameterization, CELU is now continuously differentiable regardless of the choice of . 

We observe that CELU greatly stabilizes adversarial training, \ie, compared to , the worst case in CELU is merely 0.5\% lower (shown in Table~\ref{tab:elu_celu}). Recall that this gap for ELU is 7.9\%. This case study provides another strong support on showing the importance of performing SAT.


\section{Exploring the Limits of Smooth Adversarial Training}
Recent works \cite{xie2020intriguing,gao2019convergence} show that, compared to standard training, adversarial training exhibits a much stronger requirement for larger networks to obtain better performance. Nonetheless, previous explorations in this direction only consider either deeper networks \cite{xie2020intriguing} or wider networks \cite{Madry2018}, which might be insufficient. To this end, we hereby present a systematic study on showing how network scaling up behaves in SAT. Specifically, we set Swish as the default activation function to perform SAT, as it achieves the best robustness among different candidates (as shown in Figure~\ref{fig:smooth_function}).

\subsection{Scaling-up ResNet}
We first perform the network scaling-up experiments with ResNet in SAT. In standard training, Tan \etal \cite{Tan2019} suggest that, all three scaling-up factors, \ie, \emph{depth, width and image resolutions}, are important to further improve ResNet performance. We hereby examine the effects of these factors in SAT. We choose ResNet-50 (with the default image resolution at 224) as the baseline network.

\paragraph{Depth \& width.}
Previous works \cite{Madry2018,xie2020intriguing} already show that making networks deeper or wider can further standard adversarial training. We re-verify this conclusion in SAT. As shown in the second to fifth rows of Table~\ref{tab:scaling_up}, we confirm that both deeper or wider networks consistently outperform the baseline network in SAT. For instance, by training a deeper ResNet-152, it improves ResNet-50's performance by 4.2\% for accuracy and 3.7\% for robustness. Similarly, by training a  wider ResNeXt-50-32x8d \cite{Xie2017}, it improves accuracy by 3.9\% and robustness by 2.8\%.

\paragraph{Image resolution.}
Though larger image resolution benefits standard training, it is generally believed that scaling up this factor will induce weaker adversarial robustness, as the attacker will have a larger room for crafting adversarial perturbations \cite{galloway2019batch}. However, surprisingly, this belief is invalid when taking adversarial training into consideration. As shown in the sixth and seventh rows of Table \ref{tab:scaling_up}, ResNet-50 consistently achieves better performance when training with larger image resolutions  in SAT. We conjecture this improvement is possible because a larger image resolution  (1) enables attackers to create stronger adversarial examples \cite{galloway2019batch}; and (2) increases network capacity \cite{Tan2019}, therefore benefits SAT overall. 

\paragraph{Compound scaling.}
So far, we have confirmed that the basic scaling of depth, width and image resolution are all important scaling-up factors in SAT. As argued in \cite{Tan2019} for standard training, scaling up all these factors simultaneously is better than just focusing on a single dimension (\eg, depth). To this end, we make an attempt to create a simple compound scaling for ResNet. As shown in the last row of Table~\ref{tab:scaling_up}, the resulted model, ResNeXt-152-32x8d with input resolution at 380, achieves a much stronger result than the ResNet-50 baseline, \ie, +8.5\% for accuracy and +8.9\% for robustness. 

\begin{table}[h!]
\centering
\vspace{-0.8em}
\resizebox{0.9\linewidth}{!}{
\begin{tabular}{l|c|c}
                                                 & Accuracy (\%) & Robustness (\%) \\ \shline
ResNet-50                                        & 69.7                         & 42.3            \\ \shline
+ 2x deeper (ResNet-101)                         & 72.9 (+3.2)                  & 45.5 (+3.2)            \\ 
+ 3x deeper (ResNet-152)                         & 73.9 (+4.2)                  & 46.0 (+3.7)           \\  \hline
+ 2x wider (ResNeXt-50-32x4d)                    & 71.2 (+1.5)                  & 42.5 (+0.2)            \\ 
+ 4x wider (ResNeXt-50-32x8d)                    & 73.6 (+3.9)                  & 45.1 (+2.8)           \\ \hline
+ larger resolution 299                          & 70.9 (+1.2)                  & 43.8 (+1.5)           \\ 
+ larger resolution 380                          & 71.6 (+1.9)                  & 44.1 (+1.8)           \\ \hline
+ 3x deeper \& 4x wider (ResNeXt-152-32x8d)  \& larger resolution 380 & \textbf{78.2 (+8.5)}                  & \textbf{51.2 (+8.9)}          
\end{tabular}
}
\caption{Scaling-up ResNet in SAT. We observe SAT consistently helps larger networks to get better performance.} 
\label{tab:scaling_up}
\vspace{-1.2em}
\end{table}



\paragraph{Discussion on standard adversarial training.} We first verify that basic scaling of depth, width and image resolution also matter in \emph{standard adversarial training}, \eg, by scaling up ResNet-50 (33.0\% robustness), the deeper ResNet-152 achieves 39.4\% robustness (+6.4\%), the wider ResNeXt-50-32x8d achieves 36.7\% robustness (+3.7\%) and the ResNet-50 with larger image resolution at 380 achieves 36.9\% robustness (+3.9\%). All these robustness performances are lower than the robustness (42.3\%) achieved by the ResNet-50 baseline in SAT (first row of Table~\ref{tab:scaling_up}). In other words, scaling up networks seems less effective than replacing ReLU with smooth activation functions. 

We also find compound scaling is more effective than basic scaling for standard adversarial training, \eg, ResNeXt-152-32x8d with input resolution at 380 here reports 46.3\% robustness. Although this result is better than adversarial training with basic scaling above, it is still \app5\% lower than SAT with compound scaling, \ie, 46.3\% v.s. 51.2\%. In other words, even with larger networks, applying smooth activation functions in adversarial training is still essential for improving performance.

\begin{wrapfigure}{r}{0.35\textwidth}
  \vspace{-1.7em}
  \begin{center}
    \includegraphics[width=0.34\textwidth]{eff_sat.pdf}
  \end{center}
  \vspace{-1.2em}
  \caption{Scaling-up EfficientNet in SAT. Note EfficientNet-L1 is not connected to the rest of the graph because it was not part of the compound scaling suggested by~\cite{Tan2019}.}
  \label{fig:eff_sat}
  \vspace{-1.5em}
\end{wrapfigure}


\subsection{SAT with EfficientNet}
The results on ResNet show that scaling up networks in SAT effectively improves performance. Nonetheless, the applied scaling policies could be suboptimal, as they are hand-designed without any optimizations. EfficientNet \cite{Tan2019}, which uses neural architecture search to automatically discover the optimal factors for network scaling, provides a strong family of models for image recognition. To examine the benefits of EfficientNet, we now use it to replace ResNet in SAT. Note that all other training settings are the same as described in our ResNet experiments.

Similar to ResNet, Figure~\ref{fig:eff_sat} shows that stronger backbones consistently achieve better performance in SAT. For instance, by scaling the network from EfficientNet-B0 to EfficientNet-B7, the robustness is improved from 37.6\% to 57.0\%, and the accuracy is improved from 65.1\% to 79.8\%.
Surprisingly, the improvement is still observable for larger networks: EfficientNet-L1~\cite{Xie2019a} further improves robustness by 1.0\% and accuracy by 0.7\% over EfficientNet-B7. 

\paragraph{Training enhancements on EfficientNet.} So far all of our experiments follow the training recipes from ResNet, which may not be optimal for EfficientNet training. To this end, we import the following settings to our experiments as in original EfficientNet training setups \cite{Tan2019}: we change weight decay from 1e-4 to 1e-5, and add Dropout \cite{Srivastava2014},  stochastic depth \cite{huang2016deep} and AutoAugment \cite{Cubuk2018} to regularize the training process. Besides, we train models longer (\ie, 200 epochs) to better cope with these training enhancements, and adopt the early stopping strategy to prevent the catastrophic overfitting issue in robustness \cite{wong2020fast}.  With these training enhancements, our EfficientNet-L1 gets further improved, \ie,  +1.7\% for accuracy (from 80.5\% to 82.2\%) and +0.6\% for robustness (from 58.0\% to 58.6\%).

\begin{wrapfigure}{r}{0.53\textwidth}
\centering
\vskip -0.25in
\resizebox{\linewidth}{!}{
\small
\begin{tabular}{l|c|c}
  &  Accuracy (\%) & Robustness (\%) \\
\shline
Prior art \cite{Qin2019}        & 72.7    &  47.0  \\ 
EfficientNet+SAT                & \textbf{82.2 (+9.5)}    &  \textbf{58.6 (+11.6)}  \\ \end{tabular}
}
\vskip -0.05in
\captionof{table}{Comparison to the previous state-of-the-art.}
\label{tab:sota_compare}
\vskip -0.2in
\end{wrapfigure}


\paragraph{Comparing to the prior art \cite{Qin2019}.} Table \ref{tab:sota_compare} compares our best results with the prior art. With SAT, we are able to train a model with strong performance on both adversarial robustness and standard accuracy---our best model (EfficientNet-L1 + SAT) achieves 82.2\% standard accuracy and 58.6\% robustness, which largely outperforms the previous state-of-the-art method \cite{Qin2019} by 9.5\% on standard accuracy and 11.6\% on adversarial robustness.

\paragraph{Discussion.}
Finally, we emphasize a large reduction in the accuracy gap between adversarially trained models and standard trained models for large networks. For example, with the training setup above (with enhancements), EfficientNet-L1 achieves 84.1\% accuracy in standard training, and this accuracy slightly decreases to 82.2\% (-1.9\%) in SAT. Note that this gap is substantially smaller than the gap in ResNet-50 of 7.1\% (76.8\% in standard training v.s. 69.7\% in SAT). Moreover, it is also worth mentioning that the high accuracy of 82.2\% provides strong support to \cite{Ilyas2019} on arguing robust features indeed can generalize well to clean inputs.


\section{Conclusion}
In this paper, we propose smooth adversarial training, which enforces architectural smoothness via replacing non-smooth activation functions with their smooth approximations in adversarial training. SAT improves adversarial robustness without sacrificing standard accuracy or incurring additional computation cost. 
Extensive experiments demonstrate the general effectiveness of SAT. 
With EfficientNet-L1, SAT reports the state-of-the-art adversarial robustness on ImageNet, which largely outperforms the prior art \cite{Qin2019} by 9.5\% for accuracy and 11.6\% for robustness.


\section*{Broader Impact}
Our work points out that architectural smoothness plays an essential role in learning a robust model, which has not been paid attention to in the community.
We believe this is a general design principle, and should well generalize to broader tasks like natural language processing, reinforcement learning, \etc. Our work also provides interesting observations on suggesting different architecture designs indeed will have significantly different performance on robustness, therefore have great potential to inspire later works on finding better architectures, \eg, through either hand design or neural architecture search, to further increase robustness. 
We strongly believe that SAT can have high practical impacts since our method can greatly enhance model robustness against adversarial attacks, which is important for enabling models to work reliably in real-world scenarios, especially for safety-critical applications like self-driving cars and surgical robots. 


\paragraph{Acknowledgment} 
We would like to thank Jiang Wang, Chongli Qin and Sven Gowal for valuable discussions at the early stage of this project. 


\bibliographystyle{plain}
{\small
	\bibliography{egbib}
}


\end{document}
