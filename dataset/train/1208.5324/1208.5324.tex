\documentclass[10pt]{scrartcl}
\usepackage[dvips]{color}
\usepackage{epsfig}

\usepackage{amsmath,amssymb,dsfont,paralist,graphicx}
\usepackage[thmmarks,amsmath,standard]{ntheorem}


\newtheorem{df}{Definition}[section]
\newtheorem{lm}[df]{Lemma}
\newtheorem{ex}[df]{Example}
\newtheorem{propos}[df]{Proposition}
\newtheorem{theo}[df]{Theorem}
\newtheorem{cor}[df]{Corollary}
\newtheorem{ob}[df]{Observation}
\newtheorem{nt}[df]{Note}
\newtheorem{princ}[df]{Principle}
\newtheorem{met}[df]{Method}

\DeclareMathOperator{\qfMSO}{\mathrm{qf-MSO}}
\DeclareMathOperator{\one}{\mathds{1}}
\DeclareMathOperator{\rec}{rec}
\DeclareMathOperator{\mso}{mso}


\newcommand{\Nu}{\mathcal{V}}
\newcommand{\sem}[1]{[\![#1]\!]}
\newcommand{\eop}{}
\newcommand{\nat}{\mathbb{N}}
\newcommand{\fl}{\langle \! \langle}
\newcommand{\fr}{\rangle \! \rangle}
\newcommand{\Bo}{\mathbb{B}}
\newcommand{\seml}{[\![}
\newcommand{\semr}{]\!]}
\newcommand{\gen}[1]{\langle #1\rangle}
\newcommand{\define}[1]{\emph{#1}}
\newcommand{\ser}[1]{\langle\!\langle #1\rangle\!\rangle}
\newcommand{\bimplies}{\stackrel{\mathrm{b}}{\rightarrow}}
\newcommand{\pimplies}{\stackrel{\mathrm{+}}{\rightarrow}}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\pset}{\mathcal{P}}
\newcommand{\pos}{\mathrm{pos}}
\newcommand{\height}{\mathrm{height}}
\newcommand{\cut}{\mathrm{cut}}
\newcommand{\im}{\mathrm{im}}
\newcommand{\MExp}{\mathrm{MExp}}
\newcommand{\RMSO}{\mathrm{RMSO}}
\newcommand{\MSO}{\mathrm{MSO}}
\newcommand{\bMSO}{\mathrm{BMSO}}
\newcommand{\bFO}{\mathrm{BFO}}
\newcommand{\bFOmod}{\mathrm{BFO}\! + \! \mathrm{mod}}
\newcommand{\srMSO}{\mathrm{srMSO}}

\newcommand{\Eastep}{\exists\forall_{\mathrm{step}}}
\newcommand{\auMSO}{\mathrm{auMSO}}
\newcommand{\suMSO}{\mathrm{suMSO}}
\newcommand{\FO}{\mathrm{FO}}

\newcommand{\Free}{\mathrm{Free}}
\newcommand{\rt}{\mathrm{root}}
\newcommand{\edge}{\mathrm{edge}}
\newcommand{\lab}{\mathrm{label}}
\newcommand{\partition}{\mathrm{part}}
\newcommand{\false}{\mathrm {false}}
\newcommand{\rmv}{\mathrm{v}}
\newcommand{\val}{\mathrm{val}}
\newcommand{\path}{\mathrm{path}}
\newcommand{\desc}{\mathrm{desc}}
\newcommand{\fork}{\mathrm{fork}}
\newcommand{\bd}{\mathrm{bd}}
\newcommand{\closed}{\mathrm{closed}}
\newcommand{\pattern}{\mathrm{pattern}}
\newcommand{\TC}{\mathrm{TC}}
\newcommand{\bTC}{\mathrm{bTC}}
\newcommand{\BTC}{\mathrm{B}\mbox{-}\mathrm{TC}}
\newcommand{\TCstep}{\mathrm{TC}_{\mathrm{step}}}
\newcommand{\BTCstep}{\mathrm{B}\n\mathrm{TC}_{\mathrm{step}}}
\newcommand{\pTC}{\psi\mbox{-}\mathrm{TC}}
\newcommand{\maxrk}{{\mathrm{maxrk}}}
\newcommand{\calV}{\mathcal{V}}
\newcommand{\lmp}{\mathrm{lmp}}
\newcommand{\formpath}{\mathrm{form}\mbox{-}\mathrm{path}}
\newcommand{\formlmp}{\mathrm{form}\mbox{-}\mathrm{lmp}}
\newcommand{\formcut}{\mathrm{form}\mbox{-}\mathrm{cut}}
\newcommand{\onlmp}{\mathrm{on}\mbox{-}\mathrm{lmp}}
\newcommand{\inhead}{\mathrm{in}\mbox{-}\mathrm{head}}
\newcommand{\intophead}{\mathrm{in}\mbox{-}\mathrm{tophead}}
\newcommand{\head}{\mathrm{head}}
\newcommand{\sibl}{\mathrm{sibl}}
\newcommand{\dec}{\mathrm{dec}}
\newcommand{\dfk}{\mathrm{Forks}}
\newcommand{\chk}{\mathrm{check}}
\newcommand{\scc}{\mathrm{succ}}

\newcommand{\Pred}{\mathrm{Pred}}
\newcommand{\lin}{\mathrm{Lin}}
\newcommand{\Flin}{\mathrm{Flin}}
\newcommand{\Plin}{\mathrm{Plin}}
\newcommand{\BC}{\mathrm{BC}}
\newcommand{\REC}{\mathrm{REC}}
\newcommand{\STT}{\mathrm{STT}}
\newcommand{\lSTT}{\mathrm{l}\n\mathrm{STT}}
\newcommand{\tSTT}{\mathrm{t}\n\mathrm{STT}}
\newcommand{\tdSTT}{\mathrm{td}\n\mathrm{STT}}
\newcommand{\dSTT}{\mathrm{d}\n\mathrm{STT}}
\newcommand{\slSTT}{\mathrm{sl}\n\mathrm{STT}}
\newcommand{\nSTT}{\mathrm{n}\n\mathrm{STT}}
\newcommand{\lnSTT}{\mathrm{ln}\n\mathrm{STT}}
\newcommand{\REL}{\mathrm{REL}}
\newcommand{\dREL}{\mathrm{dREL}}

\newcommand{\VR}{\mathrm{VR}}
\newcommand{\VP}{\mathrm{VP}}


\newcommand{\A}{{\cal A}}
\newcommand{\B}{{\cal B}}
\newcommand{\C}{{\cal C}}
\newcommand{\M}{{\cal M}}
\newcommand{\N}{{\cal N}}
\newcommand{\F}{{\cal F}}
\newcommand{\G}{{\cal G}}
\newcommand{\R}{{\cal R}}
\newcommand{\PS}{{\cal P}}



\DeclareMathOperator{\var}{var}
\DeclareMathOperator{\rk}{rk}
\DeclareMathOperator{\weights}{weights}
\DeclareMathOperator{\decomp}{dec}
\DeclareMathOperator{\match}{match}
\DeclareMathOperator{\id}{id}
\DeclareMathOperator{\ext}{ext}
\DeclareMathOperator{\Rec}{Rec}
\DeclareMathOperator{\size}{size}
\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\grd}{grd}
\DeclareMathOperator{\lhs}{lhs}
\DeclareMathOperator{\rhs}{rhs}
\DeclareMathOperator{\range}{range}
\DeclareMathOperator{\supp}{supp}
\DeclareMathOperator{\n}{-}


\providecommand*{\zero}    [0]{\ensuremath{\mathbf 0}}
\providecommand*{\one}     [0]{\ensuremath{\mathbf 1}}
\providecommand*{\sr}      [0]{\ensuremath{(K, \oplus,\odot,\zero,\one)}}
\providecommand*{\posr}    [0]{\ensuremath{(K,\oplus, \odot,\zero,\one,\leq)}}
\providecommand*{\srs}     [0]{\ensuremath{\mathcal K}}


\parskip0.4em


\let\s=\sigma
\let\d=\delta
\let\S=\Sigma
\let\R=\Delta
\def\-{}
\def\|{\hspace{1mm} | \hspace{1mm}}
\def\ts{T_\Sigma}
\def\td{T_\Delta}
\def\les#1#2#3{#1\leq #2\leq #3}       \def\seq#1#2#3{#1_{#2},\ldots,#1_{#3}} \def\seqq#1#2#3#4{#1_{#3}(#2_{#3}),\ldots,#1_{#4}(#2_{#4})}
\def\red#1{\rightarrow_{#1}}
\def\tred#1{\rightarrow_{#1}^{*}}
\def\thue#1{\leftrightarrow_{#1}}
\def\tthue#1{\leftrightarrow_{#1}^{*}}
\def\der#1{\Rightarrow_{#1}}
\def\tder#1{\Rightarrow_{#1}^{*}}
\def\ttder#1{\Leftrightarrow_{#1}^{*}}
\def\mac{M=(Q,\S,\R,q_0,R)}
\def\att{A=(Att,\S,\R,\rho,a_0,R)}
\def\as{Att_{syn}}
\def\ai{Att_{inh}}
\def\mt{macro tree transducer\ }
\def\at{attributed tree transducer\ }
\let\c=\circ
\let\u=\cup
\def\g0{\geq0}             \let\b=\Box                \def\pr{\noindent{\bf Proof.\ }}
\let\vp=\varphi


\def\su#1#2#3#4{[#1_{#3}\leftarrow#2_{#3},\ldots,
                      #1_{#4}\leftarrow#2_{#4}]}
\def\ui#1{^{(#1)}}




\begin{document}


\title{Forward and Backward Application of Symbolic Tree Transducers}

\author{Zolt\'an F\"ul\"op\thanks{Research of this author was supported by the program T\'AMOP-4.2.1/B-09/1/KONV-2010-0005  of the Hungarian National
    Development Agency.} and Heiko Vogler\\
  {\small  Department of Foundations of Computer Science,
    University of Szeged} \-.5ex]
  {\small Mommsenstr.~13, D-01062 Dresden, Germany.
    {Heiko.Vogler@tu-dresden.de}}}

\date{\today}

\maketitle

\sloppy


\begin{quote}{\bf Abstract:} We consider symbolic tree automata (sta) and symbolic tree transducers (stt). We characterize s-recognizable tree languages (which are the tree languages recognizable by sta) in terms of (classical) recognizable tree languages and relabelings. We prove that sta and the recently introduced variable tree automata are incomparable with respect to their recognition power.  We define symbolic regular tree grammars and characterize s-regular tree languages in terms of regular tree languages and relabelings. As a consequence, we obtain that s-recognizable tree languages are the same as s-regular tree languages.

We show that  the syntactic composition of two stt computes the composition of
the tree transformations computed by each stt, provided that (1) the first one is deterministic or the second one is linear and (2) the first one is total or the second is nondeleting.  We consider forward application and backward application of stt and prove  that the backward application of an stt to any s-recognizable tree language yields an s-recognizable tree language. We give a linear stt of which the range is not an s-recognizable tree language. We show that the  forward application of simple and linear stt preserves s-recognizability. As a corollary, we obtain  that the type checking problem of simple and linear stt and the inverse type checking problem of arbitrary stt is decidable.
\end{quote}


{\bf ACM classification:} F.1.1, F.4.2, F.4.3

{\bf Key words and phrases:} Tree automata, tree transducers, composition of tree transducers


\section{Introduction}

\label{introduction} Symbolic tree automata (sta) and symbolic tree transducers (stt) were introduced in \cite{veabjo11a} and \cite{veabjo11b}. They differ from classical finite-state tree automata and tree transducers \cite{gecste84,gecste97} in that they work with trees over an infinite, unranked set of symbols. 
According to \cite{grukupshe10}, examples of systems with finite control and infinite source of data are software with integer parameters \cite{bouhabmay03}, datalog systems with infinite data domain \cite{bouhabjursig07}, and XML documents of which the leaves are associated with data values from some infinite domain
\cite{bracercomframan03}. It was mentioned in \cite{veabjo11a} that lifting the finite alphabet restriction is useful to enable efficient symbolic analysis. Symbolic transducers are useful for exploring symbolic solvers when performing basic automata-theoretic transformations \cite{veahoolivmolbjo12}. 

In this paper we provide new formal definitions of sta and stt which slightly differs from those given in \cite{veabjo11a,veabjo11b}. At the end of Sections \ref{sect:sta-def} and \ref{sect:stt-def} we will compare our definitions with the original ones.


Roughly speaking, an sta is a finite-state tree automaton \cite{don70}  except that the input trees are built up over an infinite set of labels. In order to ensure a finite description of the potentially infinite set of transitions we bind the maximal number of the successors of a any node
occurring in an input tree by an integer , and we employ finitely many unary Boolean-valued predicates over the set of labels.  Then every transition of a symbolic k-bounded tree automaton (s-ta) has the form 

where ,  are states, and  is a unary Boolean-valued predicate. Such a transition is applicable to a node if  holds for the label of that node.
The tree language  recognized by an sta  is defined as the union of all tree languages , where  is a final state, and the family  is defined inductively in the same way as for finite-state tree automata. A tree language is s-recognizable if there is an s-ta which recognizes this language, and it is s-recognizable if it is s-recognizable for some .
An example of an s2-recognizable tree language is 
the set of all binary trees with labels taken from  such that every label is divisible by 2 or every label is divisible by 3 as, e.g.,  or  (cf. Example \ref{ex:sta}).  

By restricting the set of labels to a ranked alphabet  and just allowing, for every , the characteristic mapping on  as predicate, we reobtain the classical finite-state tree automata. In \cite{veabjo11a} it was proved that bottom-up sta are determinizable, that the class of s-recognizable tree languages is closed under the Boolean operations, and that the emptiness problem for s-recognizable tree languages is decidable provided the emptiness problem in the Boolean algebra of predicates is decidable.

Similarly, an stt is a top-down tree transducer \cite{tha70,rou70,eng75} except that its input and output trees  are built up over potentially infinite sets of (resp., input and output) labels. 
In the same way as for  sta, we ensure finiteness by an a priori bound  on the maximal number of the successors of a node and by using a finite set of unary predicates. The right-hand side of each rule of a symbolic -bounded tree transducer (s-tt) 
contains unary functions, rather than explicit output symbols as in top-down tree transducers. These functions are then applied to the current input label and thereby produce the output labels. More formally, a rule has the form

where ,  is a state,  is a unary Boolean-valued predicate over the set of input labels,  are the usual variables that represent input subtrees, and  is a tree in which each internal node has at most  successors and is labeled by a unary function symbol; the leaves of  can be labeled alternatively by objects  with state  and . Clearly, the leaf labels of the form  organize the recursive descent on the input tree as usual in a top-down tree transducer. The tree transformation  computed by an stt is defined in the obvious way by means of a binary derivation relation. 
For instance, there is a (nondeterministic) s2-tt which transforms each binary tree over  into a set of binary trees over  such that a subtree  of the input tree is transformed into  where
\begin{itemize}
\item , and  and  are transformations of  and , respectively, or
\item  if  is divisible by 6, and both  and  are transformations of 
(cf. Example \ref{stt-example}). 
\end{itemize} 

 By restricting the predicates on the input labels to some ranked alphabet (as for sta above) and by only allowing unary functions such that each one produces a constant symbols from some ranked (output) alphabet, we reobtain top-down tree transducers.  

Since sta and stt can check and manipulate data from an infinite set, they can be considered as tools for analyzing and transforming trees as they occur, e.g., in XML documents. Thus, the theoretical investigation of sta and stt is motivated by practical problems as e.g. type checking and inverse type checking. 


In this paper we further develop the theory of sta and stt. We prove  a characterization of s-recognizable tree languages in terms of (classical) recognizable tree languages and relabelings (Thm. \ref{th:char}). We compare the recognition power of sta with that of variable tree automata  \cite{menrah11} (also cf.  \cite{grukupshe10}). More specifically, we characterize the tree language recognized by a variable tree automaton by the union of infinitely many s-recognizable tree languages  (Prop. \ref{prop:vta-sta}) and we show that sta and variable tree automata are incomparable  with respect to recognition power (cf. Thm. \ref{var-vs-sym-theo}).
Moreover, as a generalization of (classical) regular tree grammars \cite{bra69} we introduce symbolic regular tree grammars and characterize s-regular tree languages in terms of
regular tree languages and relabelings (Thm. \ref{th:char-reg}). As a corollary, we obtain that s-recognizable tree languages are the same as s-regular tree languages (Thm. \ref{th:rec=reg}).

 For stt we recall the concept of the syntactic composition from \cite{veabjo11b}. We show that  syntactic composition of two stt  and  computes the composition of the tree transformations computed by  and , provided that (1)  is deterministic or  is linear or (2)  is total or  is nondeleting (Thm. \ref{comp-lemma}). Hereby, we generalize Baker's classical result  \cite[Thm. 1]{bak79}. 

Finally, we consider forward application and backward application of stt; these investigations are motivated by the (inverse) type checking problem (see among others \cite{milsucvia03,alomilnevsucvia03,engman03,manberpersei05}). 
We show that the backward application of an s-tt (which is the application of its inverse) to any s-recognizable tree language yields an s-recognizable tree language (Thm. \ref{backward-theo}). It is well-known that the forward application of linear top-down tree transducers preserves recognizability of tree languages (see e.g. \cite{tha69} or \cite[Ch. IV, Cor. 6.6]{gecste84}). It is surprising that for stt the corresponding result does not hold, in fact there is a linear s-tt of which the range is not an s-recognizable tree language (Lm. \ref{range-lin-lemma}). However, the application of simple and linear stt preserve s-recognizability (Thm. \ref{slin-theo}).
As a corollary, we obtain that the type checking problem of simple and linear stt, as well as, the inverse type checking problem of arbitrary stt is decidable (Thm. \ref{thm:type-checking}).

Since the theory of sta and stt is based on concepts which are slightly different from the foundations of classical finite-state tree automata and tree transducers, we list them in detail is Section  \ref{prel-section}.



\section{Preliminaries}\label{prel-section}


\subsection{General}

The set of nonnegative integers is denoted by  

For a set , we denote by  and  the cardinality and
the set of all subsets of . Moreover, we denote by  the identical mapping over . For a set , an \emph{-indexed family over } is a
mapping . We denote the family  also by . 

Let  be a relation. For every , we define .
For another relation , the composition of  and  is the relation
.
The reflexive and transitive closure of a relation  is denoted by .

\subsection{Trees}\label{sect:trees}

In this paper we mainly consider trees over a nonempty and unranked set. We note that our concept of a tree differs from that of \cite{veabjo11a,veabjo11b} in that we do not consider the empty tree as the base of the inductive definition. 

Let  be a (possibly infinite) nonempty set, called the set of {\em labels}, and  a further set. The {\em set of trees over } (or: {\em -trees}) {\em indexed by }, denoted by , is the smallest subset  of  such that  (i) , and (ii) if  and  with , then .  If , then we write  for . A {\em tree language over }  (or: {\em -tree language}) is any subset of .

Let  be a set with .  Then we denote by  the subset  of . 


We define the set of {\em positions in a  -tree} by means
of the mapping  inductively on the argument  as follows: (i) if  , then
, and (ii) if  for some , 
and , then . 

For every  and , the {\it
  label of  at   }, denoted by , the {\it
  subtree of  at   }, denoted by , 
and the {\it
  rank at }, denoted by , are defined inductively as follows: (i) if  , then
, and , and
(ii) if  for some ,
 and ,  then
 = , , and , and if   and , then , , and . 


Let  be a tree. For any , we define . If , then we write just  for . 
Moreover, for every  and , we denote by  the tree which is obtained by replacing the subtree  by .

We will consider trees with variables and the substitution of trees for variables. For this, let  be an infinite set of variables, disjoint with , and let   for every . For trees  and , we denote by
 the tree which we obtain by replacing  every occurrence of  by  for every . We note that . Moreover, we denote by  the set of trees in  in which each variable  occurs exactly once and the order of variables from left to right is . We call the elements of 
 {\em -contexts}.


Finally, let  and . 
We define the \emph{rank}  of  to be  and  we say that {\em  is -bounded} if . We denote 
the set of all -bounded -trees indexed by  by . Clearly, .
A \emph{-bounded -tree language} (or: -tree language) is a subset of . 
A -tree language  is \emph{bounded} if there is a  such that  is -bounded. 
Moreover, we define the set of {\em -bounded -contexts} to be .



\begin{quote}\it In this paper , , and  will always denote arbitrary nonempty sets unless specified otherwise.
\end{quote} 



\subsection{Tree transformations}\label{sect:tree-trans}


Let . A \emph{-bounded tree transformation} (or: \emph{-tree transformation}) is a mapping  (or: alternatively, a relation ). A \emph{tree transformation} is a -tree transformation for some .  If for every , there is exactly one  such that  (i.e., ~is a
mapping), then we also write . The {\em inverse }, the {\em domain },
and the {\em range } of a tree transformation  are defined in the standard way.



Let  be a tree transformation,  and  tree languages.
The \emph{forward   application} (or just: {\em application}) \emph{of~ to } is the tree language . The \emph{backward application} of~ to  is the tree
language  (which is
the forward application of  to ).

We extend the above concepts and the composition of tree transformations to classes of tree transformations and classes of tree languages in a natural way. For instance, if  and  are classes of -tree transformations, and  is a class of -tree languages, then we define  and .


A \emph{relabeling} is a mapping 
such that  is recursive and it is decidable if  for every ; it
is called \emph{deterministic} if  is a singleton for every
. Let . The \emph{-tree relabeling (induced by
  )} is the mapping , defined by 
Then the mapping  is extended to 
by  for every . 

We note that the composition of two -tree relabelings  and
  is again a -tree relabeling. In fact, if 
and , then 
induces . 
In the sequel, we drop the primes from  and  and
identify both mappings with . 

\subsection{Predicates and label structures}

 A (unary) \emph{predicate
  over } is a mapping . We denote
by  the set of all predicates over . 
Let  be a predicate. We introduce the notation  for . 


We define the operations
, , and  over  in the obvious way and extend  and 
to finite families  of predicates in .  In particular,
 and .

Let  be a finite set of  recursive predicates such that
 is decidable for every .
We call the pair  a \emph{label structure}.
 The \emph{Boolean closure of~}, denoted
by , is the smallest set  such that 
\begin{enumerate}
\item[(i)] ,
\item[(ii)]  where  and  for
  every ,  and
\item[(iii)] for every , the predicates ,
  , and  are in .
\end{enumerate}
It is clear that
 is a Boolean algebra for every .
 






\subsection{Tree automata, tree grammars, tree transducers}

We assume that the reader is familiar with the basic concepts of the theory of (classical) tree automata and tree transducers which can be found among others in \cite{gecste84,gecste97} and \cite{comdaugiljaclugtistom97}. In particular, we freely use the concept of a ranked alphabet, a tree language over a ranked alphabet, a finite-state tree automaton, a recognizable tree language, a regular tree grammar, a regular tree language, a top-down tree transducer, and of a tree transformation. Here we recall only some notations.

A {\em ranked alphabet} is a finite set  equipped with a rank mapping . We define  () and . 
It is clear that every tree  is -bounded.

A \emph{finite-state tree automaton} is a system , where  is a finite, nonempty  set (states),   is a ranked alphabet,   is the family of sets of transitions, i.e.,  for every  and  with , and  is the set of final states. The set of trees recognized by  is denoted by .
A tree language  is {\em recognizable} if there is a finite-state tree automaton  such that .


A \emph{regular tree grammar} is a tuple  where  is a finite set of states\footnote{Usually these symbols are called nonterminals; but since this notion leads to misunderstandings in the application area of natural language processing, we prefer to call these symbols states.},  is a ranked alphabet,  (initial state), and   is a finite set of rules of the form  with  and . The derivation relation induced by  and the tree language generated by  are denoted by  and , respectively.
We will also consider {\em reduced} regular tree grammars and regular tree grammars in {\em normal form} in the sense of \cite{comdaugiljaclugtistom97}.




\section{Symbolic tree automata}

In this section we formalize our adaptation of the concept of a symbolic tree automaton from \cite{veabjo11a} and compare our model with the original one. Then we prove basic properties of sta. Finally, we compare the recognition capacity of sta with that of variable tree automata.


\subsection{Definition of sta}\label{sect:sta-def}

\begin{df} \rm Let . A \emph{symbolic -bounded  tree automaton} (s-ta) is a tuple  where 
\begin{itemize}
\item  is a finite, nonempty set (states),
\item  is a label structure,
\item  (set of final states), and 
\item  is a finite set of rules of the form 
where , , and . 
\end{itemize} 
\end{df}
Let . We call  the {\em left-hand side},  the \emph{guard}, and   the {\em right-hand side} of the rule , and denote them by , , and  respectively. 
Clearly, every s-ta is an s-ta.  By a {\em symbolic tree automaton} (sta) we mean an s-ta for some .


For every , we define the tree language  recognized by  in state , as follows. The family   is the smallest -family  of tree languages such that 
\begin{enumerate}
\item[(i)] if , , and , then , and 
\item[(ii)] if ,  with  and , and , \ldots, , then .
\end{enumerate}
The condition that all predicates in  (and hence in ) are recursive ensure that we can decide whether  for every
 and .

The \emph{tree language recognized by }, denoted by , is the set 

A tree language  is {\em symbolically -recognizable} (s-recognizable) if there is an s-ta  such that . We denote the class of all s-recognizable -tree languages by . Moreover, we call a tree language {\em s-recognizable} if it is s-recognizable for some .

Two s-ta  and  are \emph{equivalent} if .


\begin{ex}\rm\label{ex:sta} We give an example of an  sta. For this we consider the set  and the -bounded tree language 
2mm]
&\big((\forall w \in \pos(\xi): \xi(w) \text{ is divisible by }) \vee (\forall w \in \pos(\xi): \xi(w) \text{ is divisible by }\big)\big\}
\end{array}
 \xi \in L(\A,q) \iff \exists(\zeta \in L(\A',q)) \text{ such that } \xi \in \tau(\zeta),
L({\cal B}) = \bigcup (\tau(L({\cal A})) \mid \tau \in \mathrm{\VR}(A,Z,Y))\enspace.
L({\cal B}) = \bigcup (L_\tau \mid \tau \in \VR(A,Z,Y)),L= \{ a, oa, eoa, oeoa, eoeoa, \ldots\}
L(\G,q) = \{\xi \in T_U\ui k \mid q \Rightarrow_\G^* \xi\}\enspace.
\Sigma_l = \{ [\varphi,l] \mid \exists (q \rightarrow u) \in R, 
w \in \pos_{\BC(\Phi)}(u):  u(w) = \varphi \text{ and } \rk_w(u) = l\},\seml \bigvee_{\substack{\rho\in R \\ \lhs(\rho)=(q,l)}}
\grd(\rho)\semr =U .
\M_q = \{(\xi,\zeta) \in T_U^{(k)} \times T_V^{(k)} \mid q(\xi) \Rightarrow_{\M}^* \zeta\}\enspace.

\begin{array}{lrcl}
\rho_1: & q\big([\mathrm{div}(2)\wedge \mathrm{div}(3)](x_1,x_2)\big) & \rightarrow &
[:6](q(x_1),q(x_1))\\
\rho_2: & q(\top(x_1,x_2)) & \rightarrow & [\mathrm{id}](q(x_1),q(x_2))\\
\rho_3: & q(\top) & \rightarrow & [\mathrm{id}]\\
\end{array}

\seml \grd(\rho_1) \semr \cap \seml \grd(\rho_1)\semr = 
\seml \mathrm{div}(2)\wedge \mathrm{div}(3) \semr \cap \seml \top
\semr = \seml \mathrm{div}(2)\wedge \mathrm{div}(3) \semr \not= \emptyset\enspace.

\seml \bigvee_{\substack{\rho\in R \\ \lhs(\rho)=(q,1)}}
\grd(\rho)\semr = 
\seml \bigvee_{\rho\in \emptyset} \grd(\rho)\semr = 
\seml \bot \semr = \emptyset \not= U\enspace.

\begin{array}{cl}
    & q(6(12(4,6),7)) \\
\Rightarrow & 1(q(12(4,6)), q(12(4,6))) \\
\Rightarrow^2 & 1(2(q(4),q(4)), 12(q(4),q(6))) \\
\Rightarrow^4 & 1(2(4,4), 12(4,6))
\end{array}

q(\varphi^\sigma(x_1,\ldots,x_l)) \to u \in R \text{ iff }  q(\sigma(x_1,\ldots,x_l)) \to u' \in R'\enspace,
 R_{=} = \{ q(\varphi(x_1,\ldots,x_l)){\rightarrow} \iota_U(q_1(x_{1}), \ldots, q_l(x_{l}))
\mid (q_1\ldots q_l,\varphi,q) \in R \}.
q(\varphi(y_1,\ldots,y_k)) \rightarrow \psi(u)

 \BC\left(\Phi\right)\times
T_\Sigma\Big(P\big(T_\Delta\left(Q\left(X_l\right)\right)\big)\cup (P\times Q)\left(X_l\right)\Big)
(\theta,t), (\theta',t') \in \BC\left(\Phi\right)\times
T_\Sigma\Big(P\big(T_\Delta\left(Q\left(X_l\right)\right)\big)\cup (P\times Q)\left(X_l\right)\Big)
 T_W\Big(P\big(T_V\left(Q\left(X_l\right)\right)\big)\cup (P\times Q)\left(X_l\right)\Big),
 \label{rule-1}
q(\varphi(x_1,\ldots,x_l)) \rightarrow u[q_1(x_{i_1}),\ldots,q_m(x_{i_m})]
\label{derivation-2}
&\big(\varphi,p(u[q_1(x_{i_1}),\ldots,q_m(x_{i_m})])\big) \,
(\stackrel{s}{\Rightarrow_{\N}})^* \, \big(\theta,v[\langle p_1,
q_{j_1}\rangle (x_{i_{j_1}}),\ldots,\langle p_n, q_{j_n}\rangle
(x_{i_{j_n}})]\big)\\ 
&\text{ and } \seml \theta \semr \not= \emptyset \notag
\label{rule-big}
\langle p,q\rangle(\theta(x_1,\ldots,x_l)){\rightarrow} v[\langle p_1, q_{j_1}\rangle (x_{i_{j_1}}),\ldots,\langle p_n, q_{j_n}\rangle (x_{i_{j_n}})]
\{i_{j_1},\ldots,i_{j_n}\}\subseteq \{i_1,\ldots,i_m\} \subseteq \{1,\ldots,l\}.\label{one-derivation}
\langle p,q\rangle (\xi) \Rightarrow^*_{\M;\N} \zeta
\label{two-derivations}
\text{there exists an } \eta \in T_V\ui k \text{ such that }
q(\xi) \Rightarrow^*_{\M} \eta \text{ and } p(\eta) \Rightarrow^*_{\N} \zeta.

\langle p,q\rangle (a(\xi_1,\ldots,\xi_l)) & \Rightarrow_{\M;\N} v(a)[\langle p_1, q_{j_1}\rangle (\xi_{i_{j_1}}),\ldots,\langle p_n, q_{j_n}\rangle (\xi_{i_{j_n}})] \\
    &   \Rightarrow^*_{\M;\N} v(a)[\zeta_1,\ldots,\zeta_n]

\langle p_1, q_{j_1}\rangle (\xi_{i_{j_1}}) \Rightarrow^*_{\M;\N}
\zeta_1 \; ,\ldots, \;
\langle p_n, q_{j_n}\rangle (\xi_{i_{j_n}}) \Rightarrow^*_{\M;\N} \zeta_n,
\label{ind-hypothesis}
q_{j_1}(\xi_{i_{j_1}}) \Rightarrow^*_{\M} \eta_1 \text{ and } p_1(\eta_1) \Rightarrow^*_{\N}\zeta_1,\ldots,
q_{j_n}(\xi_{i_{j_n}}) \Rightarrow^*_{\M} \eta_n \text{ and } p_n(\eta_n) \Rightarrow^*_{\N}\zeta_n.
\label{from-derivation-2}
p(u(a)[q_1(x_{i_1}),\ldots,q_m(x_{i_m})]) \,
(\stackrel{s}{\Rightarrow_{\N}})^* \, v(a)[\langle p_1, q_{j_1}\rangle (x_{i_{j_1}}),\ldots,\langle p_n, q_{j_n}\rangle (x_{i_{j_n}})].
q_\lambda(\xi_{i_\lambda})= q_{j_\alpha}(\xi_{i_{j_\alpha}})\Rightarrow_{\M}^* \eta_\alpha=\overline{\eta}_\lambda.
q(a(\xi_1,\ldots,\xi_l)) \Rightarrow_{\M} u(a)[q_1(\xi_{i_1}),\ldots,q_m(\xi_{i_m})] \Rightarrow^*_{\M}u(a)[\overline{\eta}_1,\ldots,\overline{\eta}_m].

p(u(a)[\overline{\eta}_1,\ldots,\overline{\eta}_m])& \Rightarrow^*_{\N} v(a)[p_1(\overline{\eta}_{j_1}),\dots,p_1(\overline{\eta}_{j_n})] = \\
v(a)[p_1(\eta_1),\dots,p_1(\eta_n)] & \Rightarrow^*_{\N}v(a)[\zeta_1,\ldots,\zeta_n].

 p_1(\varphi_1(x_1,\ldots,x_l)) \rightarrow u_1,
  \ldots, p_m(\varphi_m(x_1,\ldots,x_l)) \rightarrow u_m \label{rules} 

P\rightarrow (\varphi_1 \wedge \ldots \wedge \varphi_m)(P_1,\ldots,P_l)

\emptyset \rightarrow
\top(\emptyset,\ldots,\emptyset)

P \Rightarrow_\G^* \xi\text{  iff  for every  there is a  such that } p(\xi)
\Rightarrow_\M^* \zeta\Big). \label{equ:dom-G}
3mm]

iff & there is a rule   in  with \3mm]

iff & there are rules (\ref{rules}) in  with  and\3mm]

iff & for every   there is a rule  s.t.  \3mm]

iff & for every  there is  a tree  such that .
\end{tabular}


\

\noindent Statement \eqref{equ:dom-G} with  implies  . Hence, by Theorem \ref{th:rec=reg} we obtain that  is s-recognizable.
The other inclusion follows from Lemma \ref{ln-lemma}.
\end{proof}

\begin{ex}\rm We illustrate the construction of the s-rtg  in the proof
  of Theorem \ref{dom-theo} by an example. 

Let the s2-tt  contain the rules


Then s2-rtg  contains (among others) the following rules:


\end{ex}


Now we can prove that backward application of stt preserve recognizability of tree languages.

\begin{theo} \label{backward-theo}.
\end{theo}
\begin{proof} First we prove the inclusion from left to right. For this, let  be an s-tt, and  an s-recognizable tree language. It is an elementary fact that . By Lemma \ref{ln-lemma}, there is a linear and nondeleting s-tt 
with . Moreover, by Theorem \ref{comp-lemma}, the s-tt  induces . Hence , which is s-recognizable by Theorem \ref{dom-theo}.

The other inclusion follows from Lemma \ref{ln-lemma}.
\end{proof} 

It is well-known from the theory of classical tree automata and tree transducers that the forward application of linear top-down tree transformations preserve recognizability of tree languages (see e.g. \cite{tha69} or \cite[Ch. IV, Cor. 6.6]{gecste84}). In particular, the range of every linear top-down tree transformation is a recognizable tree language. We can show easily that a linear s-tt does not have the analogous property.

\begin{lm} \label{range-lin-lemma}\rm There is a linear s1-tt  such that  is not 1-recognizable.
\end{lm}
\begin{proof} Let us assume that  is infinite and define the s1-tt , where  consists of the only rule

It is clear that  induces the 1-tree transformation . Thus , which is not 1-recognizable
by the remark after Lemma \ref{non-rec-lemma}.
\end{proof}

The non-recognizability of  above is due to the fact that
 is able to ``duplicate" a node of the input tree by having two
occurrences of an appropriate function symbol on the right-hand side
of its rule. We would like to identify a restricted version of an stt
which does not have this capability in the hope of that such an stt
preserves recognizability. Therefore we define simple stt as
follows. An s-tt  is {\em simple} if
 contains exactly one function symbol for every rule . We denote the class of tree transformations computed by simple
and linear stt by . Then we can prove the desired result using
the following notation. If  and  is a mapping, then  denotes the
predicate defined by .



\begin{theo} \label{slin-theo}.
\end{theo}
\begin{proof} First we prove the inclusion from left to right. Let  be a simple and linear s-tt and 
 be an s-recognizable tree language such that  for some reduced s-rtg  which is
in normal form (cf. Theorem \ref{th:rec=reg} and Lemma \ref{lm:srtg-normal-form}).

We construct the s-rtg , where
\begin{itemize}
\item , and
\item  is the smallest set of rules satisfying that if  is in  and  is in , then 
the rule 

 is in .
\end{itemize} 
We show that . For this it suffices
to prove the following statement. For every , , and  we have

We prove only the direction  by induction on the number  of steps of the corresponding derivation and we show only the induction step  to . The other direction can be proved in a similar way.

\underline{Direction , step :} We assume that in the first step of the derivation we applied the rule (\ref{rule}) obtained from the rules
 in  and   in . (Note that .) Then we have

for some  and . By the I.H., there are trees  
such that  for every . Moreover, there is a  such that . Now define the tree , where  if  for some ; and let  be an arbitrary tree in  otherwise (note that  is reduced). Then 

hence .  Moreover



The inclusion from right to left follows from Lemma \ref{ln-lemma} and the fact that  is a simple and linear stt.
\end{proof}

\begin{cor} \rm \label{range-lemma}.
\end{cor}
\begin{proof}  Let  be a simple and linear s-tt. Obviously, . Moreover, by Observation \ref{ob:TU-k-rec},  is s-recognizable. Hence the statement follows from Theorem \ref{slin-theo}.
\end{proof}

\subsection{Type checking with stt}

Intuitively, type checking means to verify whether or not all documents in a view have a certain type. According to \cite{engman03}, a typical scenario of type checking is that   translates XML documents into HTML documents. Thus, for a set  of XML documents  is an HTML-view of the documents in . In practice, we are interested in particular XML documents, which turn to be a recognizable tree language of unranked trees over some alphabet. 
Also, certain desired properties of the so-obtained HTML documents can be described in terms of recognizability of tree languages. Thus, the type checking problem of  in fact means to check whether  for recognizable   tree languages  and . The inverse type checking problem can be described in a similar way. The type checking and the inverse type checking problem for different kinds of transducers was considered in several works, see among others \cite{milsucvia03,alomilnevsucvia03,engman03,manberpersei05}.
For stt we obtain the following results.

\begin{theo}\label{thm:type-checking} 

\

\begin{enumerate}
\item[(a)] The inverse type checking problem for stt is decidable.
\item[(b)] The type checking problem for simple and linear stt is decidable. 
\end{enumerate}
\end{theo}
\begin{proof}Both statements follow from the fact that the inclusion problem of s-recognizable tree languages is decidable. This latter fact can be seen as follows. By \cite[Thm. 3]{veabjo11a}, s-recognizable tree languages are effectively closed under Boolean operations, for closure under complement, see our correction at the end of Section \ref{sect:sta-def}. Moreover, by \cite[Thm. 4]{veabjo11a}, the emptiness problem is decidable for s-recognizable tree languages provided that the emptiness problem in the underlying label structure is decidable. Since, by our definition, the label structure underlying an s-ta has a decidable emptiness problem, we obtain that the inclusion problem of s-recognizable tree languages is decidable.

Then the proof of (a) is as follows. Let  be an s-tt and  and  s-recognizable tree languages.  By Theorem \ref{backward-theo},  the tree language   is effectively s-recognizable, thus we can decide if
 holds or not. Statement (b) can be proved in a similar way, using Theorem \ref{slin-theo}.
\end{proof} 





\section{Conclusion and an open problem}


In this paper we have further elaborated the theory of sta and stt. Our main contributions are: the characterization of s-recognizable tree languages in terms of relabelings of recognizable tree languages, the introduction of symbolic regular tree grammars and the proof of their equivalence to sta, the comparison of sta and variable tree automata, the composition of stt, and the forward and backward application of stt to s-recognizable tree languages.

Finally, we  mention an open problem.
In the definition of simple s-tt we required that the right-hand side of each rule contains exactly one function symbol. We conjecture that, for the closure result in Theorem \ref{slin-theo}, it is sufficient to require that right-hand sides of rules contain \underline{at most one} function 



\bibliographystyle{alpha}
\newcommand{\etalchar}[1]{}
\begin{thebibliography}{AMN{\etalchar{+}}03}

\bibitem[AMN{\etalchar{+}}03]{alomilnevsucvia03}
N.~Alon, T.~Milo, F.~Neven, D.~Suciu, and V.~Vianu.
\newblock {XML} with data values: typechecking revisited.
\newblock {\em J. Comput. Syst. Sci.}, 66(4):688--727, 2003.

\bibitem[Bak79]{bak79}
B.S. Baker.
\newblock Composition of top-down and bottom-up tree transductions.
\newblock {\em Inform. and Control}, 41(2):186--213, 1979.

\bibitem[BCC{\etalchar{+}}03]{bracercomframan03}
M.~Brambilla, S.~Ceri, S.~Comai, P.~Fraternali, and I.~Manolescu.
\newblock Specification and design of workflow-driven hypertexts.
\newblock {\em J. Web Eng.}, 2:163--182, 2003.

\bibitem[BHJS07]{bouhabjursig07}
A.~Bouajjani, P.~Habermehl, Y.~Jurski, and M.~Sighireanu.
\newblock Rewriting systems with data.
\newblock In {\em Proc. of FCT 2007}, volume 4639 of {\em Lecture Notes in
  Comput. Sci.}, pages 1--22. Springer-Verlag, 2007.

\bibitem[BHM03]{bouhabmay03}
A.~Bouajjani, P.~Habermehl, and R.~Mayr.
\newblock Automatic verification of recursive procedures with one integer
  parameter.
\newblock {\em Theoret. Comput. Sci.}, 295:85--106, 2003.

\bibitem[Bra69]{bra69}
W.~S. Brainerd.
\newblock Tree generating regular systems.
\newblock {\em Inform. and Control}, 14:217--231, 1969.

\bibitem[CDG{\etalchar{+}}97]{comdaugiljaclugtistom97}
H.~Comon, M.~Dauchet, R.~Gilleron, F.~Jacquemard, D.~Lugiez, S.~Tison, and
  M.~Tommasi.
\newblock Tree automata techniques and applications.
\newblock Available on: http://www.grappa.univ-lille3.fr/tata, 1997.

\bibitem[Don70]{don70}
J.~Doner.
\newblock Tree acceptors and some of their applications.
\newblock {\em J. Comput. System Sci.}, 4:406--451, 1970.

\bibitem[EM03]{engman03}
J.~Engelfriet and S.~Maneth.
\newblock A comparison of pebble tree transducers with macro tree transducers.
\newblock {\em Acta Inform.}, 39(9):613--698, 2003.

\bibitem[Eng75]{eng75}
J.~Engelfriet.
\newblock Bottom-up and top-down tree transformations - a comparison.
\newblock {\em Math. Systems Theory}, 9(3):198--231, 1975.

\bibitem[FV98]{fulvog98}
Z.~F{\"u}l{\"o}p and H.~Vogler.
\newblock {\em Syntax-directed semantics --- Formal Models Based on Tree
  Transducers}.
\newblock Monogr. Theoret. Comput. Sci. EATCS Ser. Springer-Verlag, 1998.

\bibitem[GKS10]{grukupshe10}
O.~Grumberg, O.~Kupferman, and S.~Sheinvald.
\newblock Variable automata over infinite alphabets.
\newblock In C.~Martin-Vide A.-H.~Dediu, H.~Fernau, editor, {\em LATA 2010},
  volume 6031 of {\em Lecture Notes in Computer Science}, pages 561--572.
  Springer-Verlag, 2010.

\bibitem[GS84]{gecste84}
F.~G{\'e}cseg and M.~Steinby.
\newblock {\em Tree Automata}.
\newblock Akad{\'e}miai Kiad{\'o}, Budapest, 1984.

\bibitem[GS97]{gecste97}
F.~G\'ecseg and M.~Steinby.
\newblock Tree languages.
\newblock In G.~Rozenberg and A.~Salomaa, editors, {\em Handbook of Formal
  Languages}, volume~3, chapter~1, pages 1--68. Springer-Verlag, 1997.

\bibitem[MBPS05]{manberpersei05}
S.~Maneth, A.~Berlea, T.~Perst, and H.~Seidl.
\newblock {XML} type checking with macro tree transducers.
\newblock In {\em Proceedings of the twenty-fourth ACM SIGMOD-SIGACT-SIGART
  symposium on Principles of database systems, PODS 2005, Baltimore, Maryland},
  pages 283--294. ACM Press, 2005.

\bibitem[MR11]{menrah11}
I.-E. Mens and G.~Rahonis.
\newblock Variable tree automata over infinite ranked alphabets.
\newblock In F.~Winkler, editor, {\em CAI 2011}, volume 6742 of {\em Lecture
  Notes in Compter Science}, pages 247--260. Springer-Verlag, 2011.

\bibitem[MSV03]{milsucvia03}
T.~Milo, D.~Suciu, and V.~Vianu.
\newblock Typechecking for {XML} transformers.
\newblock {\em J. Comput. System Sci.}, 66:688--727, 2003.

\bibitem[Rou70]{rou70}
W.C. Rounds.
\newblock Mappings and grammars on trees.
\newblock {\em Math. Systems Theory}, 4(3):257--287, 1970.

\bibitem[Tha69]{tha69}
J.W. Thatcher.
\newblock Generalized sequential machine maps.
\newblock IBM Res. Report RC 2466, 1969.

\bibitem[Tha70]{tha70}
J.W. Thatcher.
\newblock Generalized sequential machine maps.
\newblock {\em J. Comput. System Sci.}, 4(4):339--367, 1970.

\bibitem[VB11a]{veabjo11a}
M.~Veanes and N.~Bjorner.
\newblock Foundations of {F}inite {S}ymbolic {T}ree {T}ransducers.
\newblock {\em Bulletin of EATCS}, 105:141--173, 2011.

\bibitem[VB11b]{veabjo11b}
M.~Veanes and N.~Bjorner.
\newblock {S}ymbolic tree transducers.
\newblock In M.~Clarke, I.~Virbitskaite, and A.~Voronkov, editors, {\em Proc.
  of Perespectives of System Informatics (PSI' 11)}, volume 7162 of {\em LNCS},
  pages 371--387. Springer-Verlag, 2011.

\bibitem[VHL{\etalchar{+}}12]{veahoolivmolbjo12}
M.~Veanes, P.~Hooimeijer, B.~Livshits, D.~Molnar, and N.~Bjorner.
\newblock Symbolic {F}inite {T}ransducers: {A}lgorithms and {A}pplications.
\newblock In M.~Hicks, editor, {\em Proc. of the 39th ACM SIGPLAN-SIGACT
  Symposium on Principles of Programming Languages (POPL'12)}, pages 137--150.
  ACM SIGPLAN, 2012.

\end{thebibliography}
 
\end{document}
