\documentclass[11pt]{article} \usepackage{amsfonts,amsmath,amssymb,amsthm} 
\usepackage{amsxtra}
\usepackage{complexity}
\usepackage{pstricks,pst-plot} \usepackage[normalem]{ulem}
\usepackage{array}
\usepackage[margin=2.66	cm]{geometry}
\usepackage{makecell}


\usepackage[active]{srcltx}
\synctex=1
\usepackage{hyperref}  \hypersetup{
    colorlinks,citecolor=black,filecolor=black,linkcolor=black,urlcolor=black
}

\setlength{\floatsep}{7pt}
\setlength{\textfloatsep}{20pt}
\setlength{\intextsep}{6pt}
\setlength{\extrarowheight}{3pt}



\renewenvironment{proof}{{\bfseries\noindent Proof.}}{\qed\vspace{3.5ex}}



\newtheorem*{lemma*}{Lemma}
\newtheorem*{lemmaA}{Lemma~\ref{lem:shiftChange}}
\newtheorem*{lemmaB}{Lemma~\ref{lem:read upper or lower bound number of symbols}}
\newtheorem*{lemmaC}{Lemma~\ref{lem:binary tag system for PCP}}
\newtheorem*{theorem*}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary*}{Corollary}
\newtheorem{corollary}{Corollary}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}


\newcommand{\tnc}[1]{}
\newcommand{\tnm}[1]{\marginpar{\tiny\textsf{#1}}}
\newcommand{\tne}[1]{\ensuremath{\langle #1\rangle}}
\newcommand{\PCPfour}{\mathcal{P}}\newcommand{\CTS}{\mathcal{C}}\newcommand{\CTSp}{\mathcal{C'}}\newcommand{\TSTC}{\mathcal{T_{\CTS}}}\newcommand{\TSTCp}{\mathcal{T'_{\CTS}}}\def\Nset{\mathbb{N}}\def\Zset{\mathbb{Z}}\def\Qset{\mathbb{Q}}

\newcommand{\encodeOne}{\tne{1}}
\newcommand{\encodeOneSequence}{\ensuremath{b^{10}(ubb)^{\frac{x}{2}-7}u^{\frac{x}{2}+7}b^{2}ub^{x+2}}}
\newcommand{\encodeOneTrack}{\ensuremath{b^{10}(cbb)^{\frac{x}{2}-7}c^{\frac{x}{2}+7}b^{2}cb^{x+2}}}
\newcommand{\encodeOneTrackSpecialCaseA}{\ensuremath{b^9(cbb)^{\frac{x}{2}-7}c^{\frac{x}{2}+7}b^{2}cb^{x+2}}}
\newcommand{\encodeOneTrackSpecialCaseB}{\ensuremath{b^{10}(cbb)^{\frac{x}{2}-7}c^{\frac{x}{2}+7}b^{2}cb^{x+1}}}
\newcommand{\encodeZero}{\tne{0}}
\newcommand{\encodeZeroSequence}{\ensuremath{b^4ub^2u^{x-1}b^2ub^{2x-8}}}
\newcommand{\encodeZeroTrack}{\ensuremath{b^4cb^2c^{x-1}b^2cb^{2x-8}}}
\newcommand{\encodeZeroTrackSpecialCaseA}{\ensuremath{b^3cb^2c^{x-1}b^2cb^{2x-8}}}
\newcommand{\encodeZeroTrackSpecialCaseB}{\ensuremath{b^3cb^2c^{x-1}b^2cb^{2x-9}}}
\newcommand{\encodeDeletion}{\tne{\epsilon}}
\newcommand{\encodeDeletionSequence}{\ensuremath{b^2ub^{3x-2}}}
\newcommand{\encodeDeletionTrack}{\ensuremath{b^2cb^{3x-2}}}
\newcommand{\encodeDeletionTrackCaseA}{\ensuremath{bcb^{3x-2}}}
\newcommand{\encodeDeletionTrackCaseB}{\ensuremath{b^2cb^{3x-3}}}
\newcommand{\encodeDeletionPrime}{\tne{\epsilon'}}
\newcommand{\encodeDeletionPrimeSequence}{\ensuremath{b^4ub^2u^{x-2}b^2ub^{2x-8}}}
\newcommand{\encodeDeletionPrimeTrack}{\ensuremath{b^4cb^2c^{x-2}b^2cb^{2x-8}}}

\newcommand{\track}[2]{\raisebox{2.5pt}{\ensuremath{\underset{[#1]}#2}}}

\begin{document}

\title{Undecidability in binary tag systems and the Post correspondence problem for four pairs of words}

\author{Turlough Neary\\
Institute of Neuroinformatics, University of Z\"urich and ETH Z\"urich, Switzerland\\
tneary@ini.phys.ethz.ch
}
\date{}
\maketitle

\begin{abstract}
Since Cocke and Minsky proved 2-tag systems universal, they have been extensively used to prove the universality of numerous computational models. Unfortunately, all known algorithms give universal 2-tag systems that have a large number of symbols. 
In this work, tag systems with only 2 symbols (the minimum possible) are proved universal via an intricate construction showing that they simulate cyclic tag systems. 
Our simulation algorithm has a polynomial time overhead, and thus shows that binary tag systems simulate Turing machines in polynomial time. 

We immediately find applications of our result. 
We reduce the halting problem for binary tag systems to the Post correspondence problem for 4 pairs of words.
This improves on 7 pairs, the previous bound for undecidability in this problem.
Following our result, only the case for 3 pairs of words remains open, as the problem is known to be decidable for 2 pairs. 
As a further application, we find that the matrix mortality problem is undecidable for sets with five  matrices and for sets with two  matrices. 
The previous bounds for the undecidability in this problem was seven  matrices and two  matrices.  
\end{abstract}



\section{Introduction}
Introduced by Post~\cite{Post1943}, tag systems have been used to prove Turing universality in numerous computational models, including some of the simplest known universal systems~\cite{Baiocchi2001,Cook2004,HarjuMargenstern2005,Kudlek2002A,Minsky1962,Hooper1969,Robinson1971,Robinson1991,Rogozhin1996,Rothemund1996,SiegelmannMargenstern1999}. Many universality results rely either on direct simulation of tag systems or on a chain of simulations the leads back to tag systems. Such relationships between models means that improvements in one model often has applications to many others. The results in~\cite{WoodsNeary2006B} are a case in point, where an exponential improvement in the time efficiency of tag systems had the domino effect of showing that many of the simplest known models of computation~\cite{Baiocchi2001,Cook2004,HarjuMargenstern2005,Hooper1969,Kudlek2002A,LindgrenNordahl1990,Minsky1962,Robinson1971,Robinson1991,Rogozhin1996,Rothemund1996,SiegelmannMargenstern1999} are in fact polynomial time simulators of Turing machines. Despite being central to the search for simple universal systems for 50 years, tag systems have not been the subject of simplification~since~the~early~sixties. 

In 1961, Minsky~\cite{Minsky1961} solved Post's longstanding open problem by showing that tag systems, with deletion number 6, are universal.
Soon after, Cocke and Minsky~\cite{Cocke1964} proved that tag systems with deletion number 2 (2-tag systems) are universal. Later, Hao Wang~\cite{Wang1963} showed that 2-tag systems with even shorter instructions were universal. 
The systems of both Wang, and Cocke and Minsky use large alphabets and so have a large number of rules.
Here we show that tag systems with only 2 symbols, and thus only 2 rules, are universal. Surprisingly, one of our two rules is trivial. We find immediate applications of our result. Using Cook's~\cite{Cook2004} reduction of tag systems to cyclic tag systems,  it is a straightforward matter to give a binary cyclic tag system program that is universal and contains only two 1 symbols. We also use our binary tag system construction to improve the bound for the number of pairs of words for which the Post correspondence problem~\cite{Post1946} is undecidable, and the bounds for the simplest sets of matrices for which the mortality problem~\cite{Paterson1970} is undecidable.


 
The search for the minimum number of word pairs for which the Post correspondence problem is undecidable began in the 1980s~\cite{Claus1980,Pansiot1981}. 
The best result until now was found by Matiyasevich and S\'{e}nizergues, whose impressive 3-rule semi-Thue system~\cite{Matiyasevich1996,Matiyasevich2005}, along with a reduction due to Claus~\cite{Claus1980}, showed that the problem is undecidable for 7 pairs of words. 
Improving on this undecidability bound of 7 pairs of words seemed like a challenging problem. In fact, Blondel and Tsitsiklis~\cite{Blondel2000} stated in their survey ``The decidability of the intermediate cases () is unknown but is likely to be difficult to settle''. We give the first improvement on the bound of Matiyasevich and S\'{e}nizergues in 17 years: We reduce the halting problem for our binary tag system to the Post correspondence problem for 4 pairs of words. This leaves open only the case for 3 pairs of words, as the problem is known to be decidable for 2 pairs~\cite{Ehrenfeucht1982,Halava2002A}. 


A number of authors~\cite{Blondel1997,Cassaigne1998,Halava2001,Halava2007,Paterson1970}, have used undecidability bounds for the Post correspondence problem to find simple matrix sets for which the mortality problem is undecidable. 
The matrix mortality problem is, given a set of  integer matrices, decide if the zero matrix can be expressed as a product of matrices from the set. Halava et al.~\cite{Halava2007} proved the mortality problem undecidable for sets with seven  matrices, and using a reduction due Cassaigne and Karhum\"{a}ki~\cite{Cassaigne1998} they also showed the problem undecidable for sets with two  matrices. 
Using our new bound, and applying the reductions used in~\cite{Cassaigne1998,Halava2001}, we find that the matrix mortality problem is undecidable for sets with five  matrices and for sets with two  matrices. In addition, by applying reductions due to Halava and Hirvensalo~\cite{Halava2007A}, we improve on previous undecidability bounds for a number of decision problems in sets that consist of two matrices. These new bounds include a set with two  matrices for which the scalar reachability problem is undecidable.


We complete our introduction by recalling some decidability results and open problems for tag systems.  
Stephen Cook~\cite{Cook1966} proved that the reachability problem, and hence the halting problem, is decidable for non-deterministic
1-tag systems. More recently, De Mol~\cite{DeMol2010} has shown that the reachability (and thus halting) problem is decidable for binary 2-tag systems, a problem which Post~\cite{Post1965} claimed to have solved but never published. In the 1920s Post~\cite{Post1965} gave a simple binary 3-tag system (, ) whose halting problem is still open~\cite{DeMol2011}. De Mol~\cite{DeMol2008} reduced the well know Collatz problem to the halting problem for a remarkably simple 2-tag system that has 3 rules. The simple tag systems of Post and De Mol suggest that improving on existing decidability results would be quite difficult. 


\section{Preliminaries}
We write  if a configuration  is obtained from  via a single computation step. We let  denote a sequence of  computation steps. The length of a word  is denoted , and  denotes the empty word. We let  denote the encoding of , where  is a symbol or a word. We use the standard binary modulo operation , where , , and  and  are integers. 


\subsection{Tag systems}\label{sect:Tag systems}
\begin{definition}\label{def:Tag System}
A tag system consists of a finite alphabet of symbols , a finite set of rules  and a deletion number , .
\end{definition}
The tag systems we consider are deterministic. 
The computation of a tag system acts on a word  (here ) which we call the \emph{dataword}. The entire configuration is given by . 
In a computation step, the symbols~ are deleted and we apply the rule for , i.e. a rule of the form , by appending the word  (here ). A dataword (configuration)  is obtained from  via a single computation step as follows:

where . 
A tag system halts if~. As an example we give the first 5 steps of Post's~\cite{Post1965} binary tag system with deletion number 3 and the rules  and  on the input .

We use the term \emph{round} to describe the  or  computation steps that traverse the word  exactly once.
We say a symbol  is \emph{read} if and only if at the start of a computation step it is the leftmost symbol (i.e. the rule  is applied), and we say a word  is \emph{entered with shift } if  is the leftmost symbol that is read in . 
For example, in Figure~\ref{fig:Example shift change} the words , , and  are entered with shifts of 0, 3, and 2 respectively.
We let  denote the sequence of symbols that is read during a single round on  when it is entered with shift , and we call  a track of . 
If , then  where . 
For example, in Figure~\ref{fig:Example shift change} we have . 
A word  has a \emph{shift change} of  if  where  is a natural number. 
 
\begin{figure}
\setlength{\unitlength}{.6cm}
\begin{picture}(10,2.1)
\put(.8,1){} 
\put(.8,0){}
\end{picture}
\caption{Four computation steps of a tag system with deletion number  on the word . Here , , , and ,  and  are tag system symbols, and for simplicity we assume that all symbols append the empty word (i.e.~all rules have the form ).}\label{fig:Example shift change}
\end{figure}




\begin{lemma}\label{lem:shiftChange}
Given a tag system  with deletion number  and the word , where the word  has a shift change of  and , after one round of  on  entered with shift  the word  is entered with shift .
\end{lemma}
Before we give the proof of Lemma~\ref{lem:shiftChange} we note that Figure~\ref{fig:Example shift change} gives examples of the shift change caused by reading a word: In Figure~\ref{fig:Example shift change} the word  is entered with shift  and has shift change of  and so  is entered with shift , and the word  has a shift change of  so the word  is entered with shift .\\

\begin{proof}
Recall that when  is entered with shift  then  is the leftmost symbol read in . In Equation~\eqref{eq: shift change} the sequence of symbols read in  and the leftmost symbol read in  are given in bold. The rightmost symbol read in  is  for some  and the next symbol read is  in . It follows that symbols  to  are deleted in the computation step when  is read. Since  symbols are deleted at each computation step, from Equation~\eqref{eq: shift change} we get  which we rewrite as . The shift value  must be  which gives .

\end{proof}

\begin{lemma}\label{lem:read upper or lower bound number of symbols}
Given a tag system  with deletion number  and the word , where  with  and , one round of  on  entered with shift  reads  symbols if , and  symbols if .
\end{lemma}
\begin{proof}
In Equation~\eqref{eq: enter w with shift beta-s-1} the sequence of symbols read when  is entered with shift  is given in bold. This bold sequence has length .
It is fairly straightforward to see that if we enter  with a shift  we read  symbols and if we enter  with a shift  we read  symbols.

\end{proof}

 



\subsection{Cyclic tag systems}\label{sec:Cyclic tag systems}
\begin{definition}\label{def:Cyclic tag system}
A cyclic tag system  is a list 
of words  called appendants.
\end{definition}
A {\em configuration} of a cyclic tag system consists of (i) a {\em marker} that points to a single appendant~ in~, and (ii) a word . We call~ the {\em dataword}. Intuitively the list  is a program with the marker pointing to instruction~. In the initial configuration the marker points to appendant~ and~ is the binary input word.
\begin{definition}\label{def:Computation CTS}
A computation step is deterministic and acts on a configuration in one of 
two ways:
\begin{itemize}
\item If  then  is deleted and the marker moves to appendant 
.
\item If  then  is deleted, the word  is 
appended onto the right end of~,  and the marker moves to appendant 
.
\end{itemize}
\end{definition}
A cyclic tag system completes its computation if (i) the dataword is the empty word or (ii) it enters a repeating sequence of configurations.

As an example we give first 6 steps of the cyclic tag system  on the input word . In each configuration  is given on the left with the marked  appendant highlighted in bold~font.

Cyclic tag systems were introduced by Cook~\cite{Cook2004} and used to prove the cellular automaton Rule~110 universal. We gave an exponential improvement in the time efficiency of cyclic tag~systems~to~show:
\begin{theorem}[\cite{NearyWoods2006C}]\label{thm:CTS simulate TMs}
Let  be a single-tape deterministic Turing machine that computes in time~. Then there is a cyclic tag system  that simulates the computation of M in time . 
\end{theorem}
Given a cyclic tag system  we can construct another cyclic tag system  by concatenating an arbitrary number of copies of the program for . The system  simulates step for step the computation of . For example take  given above, if we define  then  will give the same sequence of computation steps for any computation of .

\section{Simulating cyclic tag systems with binary tag systems}\label{sec:simulating CTS with TS} 

In Theorem~\ref{thm:main theorem}, the tag system  simulates an arbitrary cyclic tag system with a program of length  where . 
We do not lose generality with this restriction since the cyclic tag systems given by the construction in~\cite{NearyWoods2006C} satisfy this condition and are Turing universal. 


\begin{theorem}\label{thm:main theorem}
Let  with  be a cyclic tag system that runs in time~. Then there is a binary tag system  that simulates the computation of  in time .
\end{theorem}

\subsubsection{Cyclic tag system  and binary tag system }\label{sec:Cyclic tag system C'}
Given the program , we can give a cyclic tag system  of length  that simulates  step for step when given the same input dataword as  (see the last paragraph of Section~\ref{sec:Cyclic tag systems}). 
The value  is chosen so that  for , such that  and , where  is the length of the longest appendant in . 

We construct a binary tag system  that simulates the computation of . The deletion number of  is , its alphabet is , and its rules are of the form  and , where . The binary word  encodes the entire program of  and is defined by Tables~\ref{tab:Tracks in u for Case 1} to~\ref{tab:Tracks in u for Case 2b}. We will explain how to read these tables later in Section~\ref{sec:simulating CTS with TS}.




\subsubsection{Encoding used by }\label{sec:Encoding used by tag system}
The cyclic tag system symbols 0 and 1 are encoded as the binary words  and  respectively. We refer to  and  as objects.

\begin{definition}\label{def:input encoding}
An arbitrary input dataword  to a cyclic tag system is encoded as the  input dataword .
\end{definition}
During the simulation we make use of two extra objects: the binary words  and . An arbitrary (not necessarily input) cyclic tag system dataword  is encoded~as

where  denotes the word given by an object  with its leftmost  symbols deleted. This implies that  is entered with the shift value  from Table~\ref{tab:equalities}. Finally, each appendant  of  is encoded via Equations~\eqref{eq:alpha m},~\eqref{eq:alphaPrime m1} or~\eqref{eq:alphaPrime m2}, (where ).\\
\begin{minipage}{.4\textwidth}
 
\end{minipage}
\begin{minipage}{.59\textwidth}

\end{minipage}





\begin{table}
\centering
\begin{tabular}{|@{\:}l@{}|}
\hline
,\quad\;\; ,\quad\;\; ,\quad\;\,  ,
\\  
,\qquad\;
,\qquad\; ,\quad\\ 
,\qquad\;  
,\qquad\; ,\\
,\qquad\; ,\qquad\; \\
\hline
\end{tabular}
\caption{Length of objects and shift change values. The shift change for  and  is , the shift change for  is , the deletion number of  is , and  is the number of appendants in . The value of  is given in Section~\ref{sec:Cyclic tag system C'}.}\label{tab:equalities}
\end{table}




\subsubsection{Lengths of objects and shift values}\label{sec:length of objects}
The sequence of symbols that is read in a word is determined by the shift value with which it is entered (see for example Figure~\ref{fig:u track and encodedOne track} (i)).
So in the simulation we use the shift value for algorithm control flow. 
In Table~\ref{tab:equalities} we give the length of objects , , , and , and their shift change values.
Recall from Section~\ref{sect:Tag systems} that an object of length  has a shift change of , where  and  is the deletion number. 
So, from the object lengths  and  we get the respective shift change values of  and  in Table~\ref{tab:equalities}.
From Lemma~\ref{lem:shiftChange}, the shift an object is entered with is determined by the shift change of the objects previously read in the dataword. 
So when we have a dataword containing only , ,  and  objects, we enter objects with shifts of the form  (see Table~\ref{tab:equalities}). 
The range of values for  and  in Table~\ref{tab:equalities} covers all possible shift values. 
To see this note that when , then   giving , and when , then  giving .








\begin{figure}
\setlength{\unitlength}{.6cm}
\begin{picture}(10,4.1)
\put(0,3){(i)}
\put(1.8,3){} 
\put(0,2){(ii)}
\put(1.8,2){} 
\put(0,1){(iii)}
\put(1.8,1){} 
\put(0,0){(iv)}
\put(1.8,0){}
 \end{picture}
\caption{Objects , ,  and  being read by  when entered with shift , where , and . In (i) and (ii) , in (iii) , and in (iv) . The encoded appendant  is given in Equation~\eqref{eq:alpha m}, and the values , , , and  are given in Table~\ref{tab:equalities}.}\label{fig:reading objects when number of symbols read is upperbound}
\end{figure}


\subsection{The simulation algorithm}\label{sec:Simulation algorithm}
Here we give a high level picture of our algorithm using Figures~\ref{fig:reading objects when number of symbols read is upperbound} and~\ref{fig:reading objects when number of symbols read is lowerbound}. Following this, in Sections~\ref{sec:Encoding the marked appendant} and~\ref{sec:Reading objects and  subwords}, the lower level details are then given. 

\subsubsection{Algorithm overview}\label{sec:Algorithm overview}
Figures~\ref{fig:reading objects when number of symbols read is upperbound} and~\ref{fig:reading objects when number of symbols read is lowerbound} give arbitrary examples that cover all possible cases for reading each of the four objects. 
In both figures  denotes the  computation steps that read the entire leftmost object in the dataword on the left and produce the new dataword on the right. 
For example, in Figure~\ref{fig:reading objects when number of symbols read is upperbound} (ii) when  is read it appends  in  computation steps.
There are two cases for reading , , and  objects with each case determined by the number of symbols read in the object (see Lemma~\ref{lem:read upper or lower bound number of symbols}). 
There is only one case for reading  as . 
The objects  and  are garbage objects that have no effect on the simulation.
To see this note from Figures~\ref{fig:reading objects when number of symbols read is upperbound} and~\ref{fig:reading objects when number of symbols read is lowerbound} that  and  objects append only more garbage objects, and as we will see in Section~\ref{sec:Encoding the marked appendant} the shift change caused by reading an  or an  does not effect algorithm control flow.
The garbage objects are introduced to simulate deletion as our binary tag system has no rule that appends the empty word~.

When  reads an  or an  object as shown in (i) and (ii) of Figures~\ref{fig:reading objects when number of symbols read is upperbound} and~\ref{fig:reading objects when number of symbols read is lowerbound} it simulates a computation step where  reads a  or a .
At the beginning of the simulated computation step the currently marked appendant  is encoded by the shift value . 

\emph{Simulating the Definition~\ref{def:Computation CTS} computation step read a 0:} In (ii) of Figures~\ref{fig:reading objects when number of symbols read is upperbound} and~\ref{fig:reading objects when number of symbols read is lowerbound} we have the two possible cases for reading a . In both cases when an  is read it gets deleted and only garbage objects are appended simulating that  appends nothing. After reading  the adjacent object  is entered with shift , simulating that the next appendant  is marked.


\emph{Simulating the Definition~\ref{def:Computation CTS} computation step read a 1:}
In (i) of Figures~\ref{fig:reading objects when number of symbols read is upperbound} and~\ref{fig:reading objects when number of symbols read is lowerbound} we have the two possible cases for reading a . In both cases when an  is entered with shift  it is deleted and the encoding of  is appended. After reading  the adjacent object  is entered with shift , simulating that the next appendant  is marked.

\begin{figure}
\setlength{\unitlength}{.6cm}
\begin{picture}(10,3.2)
\put(0,2){(i)}
\put(1.8,2){}
\put(0,1){(ii)}
\put(1.8,1){}
\put(0,0){(iii)}
\put(1.8,0){} 
\end{picture}
\caption{Objects ,  and  being read by  when entered with shift , where , and  . In (i) and (ii) , and in (iii) . The encoded appendant  is given in Equations~\eqref{eq:alphaPrime m1} and~\eqref{eq:alphaPrime m2}, and the values , , , and  are given in Table~\ref{tab:equalities}.}\label{fig:reading objects when number of symbols read is lowerbound}
\end{figure}

In both cases above  there is one further step that is needed to complete the simulation of the Definition~\ref{def:Computation CTS} computation step. 
Note from Equation~\eqref{eq:encoding CTS configuration} that between a pair of encoded cyclic tag system symbols  and  is a word of the from . 
So after  is read, the word  is read placing the object  at the left end of the dataword. This completes the simulated computation step as  is now ready to begin reading the next encoded symbol . 
At the end of the next section we see that reading the garbage objects  and  does not change the appendant encoded in the shift which means that  is entered with a shift value encoding the correct appendant .

We have not yet described how reading the objects , , , and  append the appendants shown in Figures~\ref{fig:reading objects when number of symbols read is upperbound} and~\ref{fig:reading objects when number of symbols read is lowerbound}. To do so we must give the sequence of symbols read in each object when entered with shift . 
The word  that appears in the objects , , , and  is defined such that the  words read in these objects append the appendants shown in Figures~\ref{fig:reading objects when number of symbols read is upperbound} and~\ref{fig:reading objects when number of symbols read is lowerbound}. 
The  symbols that appear in each object are used to control the shift with which we enter each  within an object and thus control the sequence of symbols read in each  (see Figure~\ref{fig:u track and encodedOne track} (i)). 
For example, if we enter an  with shift  then the leftmost pair of  symbols cause the  to be entered with shift  and we read track  (in this case  in Figure~\ref{fig:u track and encodedOne track} (i)). 
If we assign track  a value that will append an , then when  is entered with shift  the word  is entered with shift  and an  gets appended as shown in Figure~\ref{fig:reading objects when number of symbols read is upperbound} (iv).
So using the  symbols in each object we control the tracks read in each  within the object so that the correct appendant gets appended when the object is read. The details of reading objects and  subwords are given in Section~\ref{sec:Reading objects and  subwords}.





\subsubsection{Encoding the marked appendant of  in the shift of }\label{sec:Encoding the marked appendant} 
From Table~\ref{tab:equalities} the shift change when reading an  or an  object is . So from Lemma~\ref{lem:shiftChange}, when an  or an  object is entered with shift , the next object immediately to its right is entered with shift  as shown in (i) and (ii) of Figures~\ref{fig:reading objects when number of symbols read is upperbound} and~\ref{fig:reading objects when number of symbols read is lowerbound}.
This shift change of  simulates that the marked appendant changes from  to  (the length of the program for  is ). 
If  is at the marked appendant  and then reads  symbols, it traverses its entire circular program and returns to appendant . 
Notice from Table~\ref{tab:equalities} that , and so if we read  of the  and  objects, then the total shift change is .
Since the shift change value is , the encoding of the marked appendant remains unchanged after reading  of the  and  objects, correctly simulating a traversal of the entire circular program of .
In Lemma~\ref{lem:Encode appendant} it is proved that if  then  for all .
This shows that each shift value  encodes one and only one appendant . So reading , with its shift change of , moves from one shift value that encodes  to another shift value that also encodes  (as shown in (iii) of Figures~\ref{fig:reading objects when number of symbols read is upperbound} and~\ref{fig:reading objects when number of symbols read is lowerbound}). In other words, reading  does not change the value of the appendant encoded in the shift. Finally, since  has a shift change value of 0 it too does not change the appendant encoded in the shift.
\begin{figure}
\setlength{\unitlength}{.6cm}
\begin{picture}(10,2.2)
\put(0,1.1){(i)}
\put(1,1.1){} 
\put(0,0){(ii)}
\put(1,0){} 
\put(17.3,1.1){(iii)}
\put(18.5,1.1){} 
\put(14.6,0){(iv)}
\put(15.8,0){}
\end{picture}
\caption{Sequence of symbols read to append  (i),  (ii),  (iii), and  (iv). Rules  or  are applied to each symbol in sequence on the left to give the object it appends on the~right.}\label{fig:tracks for appending each object} 
\end{figure}

\subsubsection{Reading objects and defining the word \emph{u}}\label{sec:Reading objects and  subwords}
The word  is defined via Tables~\ref{tab:Tracks in u for Case 1} to~\ref{tab:Tracks in u for Case 2b} such that when each object is read it appends the correct appendant as shown in Figures~\ref{fig:reading objects when number of symbols read is upperbound} and~\ref{fig:reading objects when number of symbols read is lowerbound}. 
We will take the case of reading an  entered with shift  and show that it appends  as illustrated in Figure~\ref{fig:reading objects when number of symbols read is upperbound} (i). We will then explain how the method used to verify this case can be applied to verify the remaining cases in~Figures~\ref{fig:reading objects when number of symbols read is upperbound}~and~\ref{fig:reading objects when number of symbols read is lowerbound}.

Here we show that when  is entered with shift  the sequence of symbols read in the  subwords of  append . 
Recall that the sequence of symbols (or track) read in a word depends on the shift with which the word is entered (see Figure~\ref{fig:u track and encodedOne track} (i)). 
From Lemma~\ref{lem:shiftChange}, when  is entered with shift  then the leftmost  causes the leftmost  to be entered with shift , and because each  has a shift change of , following the  subword the second  is entered with shift , the third  with shift , and so on (as shown in Figure~\ref{fig:u track and encodedOne track} (ii)). 
Now we define the track read in each  in Figure~\ref{fig:u track and encodedOne track} (ii) so that it appends a single object from  at the right end of the dataword. 
The tracks that append each object are given in Figure~\ref{fig:tracks for appending each object}. For example in Figure~\ref{fig:tracks for appending each object} (iii) we see that applying the rules  and  to the sequence  appends the object .
Note from Figure~\ref{fig:tracks for appending each object} that the number of symbols read to append each object is either of length  or .
Now note from Table~\ref{tab:equalities} and Lemma~\ref{lem:read upper or lower bound number of symbols} that when a  word is read we read either  or  symbols, and so each  subword that is read can append a single object from . For example, in Figure~\ref{fig:u track and encodedOne track} (i) if we wish  to append  when entered with shift  then we define . 


To append the sequence of objects  when reading an , the track read in the   from the left in  appends the  object from the left in , where . 
Thus in Figure~\ref{fig:u track and encodedOne track} (ii), for  if , then track  is read causing the word  to be appended, and if , then track  is read causing the word  to be appended. 
There is an exception when  and  as we have . 
In this special case, tracks have the from  or  with one less  than usual. 
From Lemma~\ref{lem:read upper or lower bound number of symbols} and Table~\ref{tab:equalities}, when  is entered with shift  only  (instead of ) symbols are read. When  is entered with shift  then , and so the leftmost  in the  is read and provides the first  in the sequence  that prints an , or provides the first  in the sequence  that prints an . 
For , each track  appends the word , and for  each track  also appends the word . 
Track  appends the word . 
There is an exception if we have and  which gives . 
In this special case, tracks have the from  with one less  than usual. From Lemma~\ref{lem:read upper or lower bound number of symbols} and Table~\ref{tab:equalities}, when  is entered with shift  only  (instead of ) symbols are read. 
When  is entered with shift  a  from the  at the right end of the  is read and provides the last  in the sequence  that appends an .
The  tracks in this paragraph show that when an  is entered with shift  the encoding of  is appended at the right end of the dataword as shown in Figure~\ref{fig:reading objects when number of symbols read is upperbound} (i). The  tracks given above have the same values as the bottom eight  tracks in Table~\ref{tab:Tracks in u for Case 1}.

\begin{figure}
\setlength{\unitlength}{.6cm}
\begin{picture}(10,4.5)
\put(0,3.5){(i)}
\put(1.3,3.6){} 
\put(18.2,3.6){} 
\put(0,2.4){(ii)}
\put(1.3,2.4){\fontsize{10.5}{1.2}}
\put(1.4,1.2){\fontsize{10.5}{1.2}}
\put(1.3,-0.1){\fontsize{10.5}{1.2}}
\end{picture}
\caption{(i) The word  where . The symbols given in bold are read when  is entered shift value  and this bold symbol sequence defines track . (ii) The tracks read in each  when  is entered with shift .
The  symbols in (ii) are not part of~the~~tracks.}\label{fig:u track and encodedOne track}
\end{figure}

\setlength{\extrarowheight}{5pt}

\begin{table*}[!ht]
\centering\vspace{-1ex}
\begin{tabular}{@{}c|l|l}
   Object track  & Tracks read in  & Values for ,  and  \\ \hline
  &  & ,\;\;\;\;  \\ \cline{2-3}
  &  & ,\;\;\;\; \\  \cline{2-3}
  &  & ,\;\;\;  \\  
 \Xhline{2\arrayrulewidth}
 
    &   & ,\;\;\;\; \\  \cline{2-3}
&   & ,\;\;\;\; \\  \cline{2-3}
     &   &,\;\;\;\;  \\ \cline{2-3}
&   & ,\;\;\;\;  \\ \cline{2-3}
&   & ,\;\;\;\; \\ 
\Xhline{2\arrayrulewidth}
    &   & ,\;\;\;\; \\  \cline{2-3}
&   & ,\;\;\;\; \\  \cline{2-3}
&   &,\;\;\;\;   \\ \cline{2-3}
&   & ,\;\;\;\; \\ \cline{2-3}
&   & ,\;\;\;\; \\  \cline{2-3}
\Xhline{2\arrayrulewidth}

   &  & ,\;\;\;\; ,\;\;\;\;  \\ \cline{2-3}
  &  & ,\;\;\;\; ,\;\;\;\;  \\ \cline{2-3}\vspace{-3pt}
  &  &  ,\;\;\;\; ,\\  
 & &,\;\;\;\; \\ \cline{2-3}\vspace{-6pt}
  &  &  ,\;\;\;\; ,\\
Equation~\eqref{eq:alpha m} &&,\;\;\;\; \\ 
\cline{2-3}
 &  &  ,\;\;\;\; \\ \cline{2-3}
&  &  ,\;\;\;\; \\ \cline{2-3}
 &  & ,\;\;\;\; \\ \cline{2-3}
  &  & ,\;\;\;\; \\
\hline
\end{tabular}
\caption{Tracks read in each object. Here  is entered with shift ,  is entered with a shift ,  and  are entered with a shift . The values , , and  are given in Table~\ref{tab:equalities}, and ,  and  are given in Equation~\eqref{eq:alpha m}. The value  indexes the position of the  subword within the object being read (see Figure~\ref{fig:u track and encodedOne track} (ii)).  Here the  is dropped from the underscripts in  tracks as all of the underscript terms above are  and .}\label{tab:Tracks in u for Case 1}
\end{table*}


\setlength{\extrarowheight}{6pt}
\begin{table*}[!ht]
\centering
\begin{tabular}{@{}c|l|l@{\;}}
 Object track  & Tracks read in  & Values for , , , and  
 \\ \hline
					& & ,\;\;\;\;   
\\ \cline{2-3}
					& & ,\;\;\;\; , 
\\ \cline{2-3}
	&  & ,\;\;\;\; 
\\\cline{2-3}\vspace{-4pt}
		& &  \\
		&&  
\\ \cline{2-3} 
	& &  ,\;\;\;\; 
\\\cline{2-3}\vspace{-4pt}
					& & 
\\
					&&
\\
\Xhline{2\arrayrulewidth}

 
					& & ,\;\;\;\;  
\\  \cline{2-3}
					& & ,\;\;\;\;  
\\\cline{2-3}
		&  & ,\;\;\;\; 
\\\cline{2-3} \vspace{-4pt}
		& &  
\\ 
		& &
\\\cline{2-3}
		& &  ,\;\;\;\; 
\\\cline{2-3}
					& & ,\;\;\;\; 
\\
\hline

\end{tabular}
\caption{Tracks read in  when entered with shift , and tracks read in  when entered with shift . The values , , and  are given in Table~\ref{tab:equalities}. The value  indexes the position of the  subword within the object being read (see Figure~\ref{fig:u track and encodedOne track} (ii)). The value  gives the index of the  subword that appends  (see Figure~\ref{fig:reading objects when number of symbols read is lowerbound}). The  is dropped from underscripts where the term is  .}\label{tab:Tracks in u for Case 2a}
\end{table*}   



\setlength{\extrarowheight}{7pt}
\begin{table*}[!ht]
\centering
\begin{tabular}{@{}c|l|l@{\;}}
 Object track  & Tracks read in  & Values for , , , and  
 \\ \hline
							&   &  ,\;\;\;\;  ,\;\;\;\;\;
\\ \cline{2-3}
							&  &   ,\;\;\;\;  ,\;\;\;\; 
 \\ \cline{2-3}
 							&  &   ,\;\;\;\; 
\\ \cline{2-3}
							&  &   ,\;\;\;\; 
							\\
							&
							\\  \cline{2-3}
	&  &  ,\;\;\;\;  ,\;\;\;\;    
\\ \cline{2-3}
Equations						&  &  ,\;\;\;\;  ,\;\;\;\;  
  \\\cline{2-3}\vspace{-4pt}
 \eqref{eq:alphaPrime m1} and~\eqref{eq:alphaPrime m2} &  &    
 \\
							&&
 \\\cline{2-3}
							&  &  ,\;\;\;\;  \\
							\cline{2-3}\vspace{-4pt}
							&  	&  
   \\ 
							&&
   \\\cline{2-3}
							&  & ,\;\;\;\; \\\cline{2-3}\vspace{-4pt}
							&  &  \\
							&&\\ 
\hline
\end{tabular}
\caption{Track read in , when entered with shift . The values  and  are given in Table~\ref{tab:equalities}, and  and  are given in Equations~\eqref{eq:alphaPrime m1} and~\eqref{eq:alphaPrime m2}. The value  indexes the position of the  subword within the object being read (see Figure~\ref{fig:u track and encodedOne track} (ii)). The value  gives the index of the  subword that appends  (see Figure~\ref{fig:reading objects when number of symbols read is lowerbound}). The  is dropped from underscripts where the term is  .}\label{tab:Tracks in u for Case 2b}
\end{table*}



Using the same method as in the previous two paragraphs one can show that the  tracks given for each of the objects ,  and  in Table~\ref{tab:Tracks in u for Case 1} will cause the correct appendant to be appended as shown in Figure~\ref{fig:reading objects when number of symbols read is upperbound}. 
Note that once the shift values for the  tracks have been determined (as in Figure~\ref{fig:u track and encodedOne track} (ii)) we can use these shift values to determine the special cases. 
When  is entered with a shift , then from Lemma~\ref{lem:read upper or lower bound number of symbols} only  (instead of ) symbols are read and we have a special case where the object track is missing a single . 
For the special cases in Table~\ref{tab:Tracks in u for Case 1} (rows 1, 3, 4, 8, 9, 13, 14, 15 and 21) the missing  needed to complete the object track is provided by reading a  in a sequence of  symbols to the left or right of the  that is entered with shift . 
For example, from row 4 of Table~\ref{tab:Tracks in u for Case 1} when  is entered with shift  we read track  in the leftmost  of , and since  we also read the leftmost  in  which provides the leftmost  needed to complete the track  that appends an . 
Note that in Table~\ref{tab:Tracks in u for Case 1} there are no special cases (i.e.~tracks of length ) for  when reading , and for  when reading  and . 
This is because when  is entered with shifts , and when  and  are entered with shifts , it is not possible to enter the  subwords at these positions with shifts .
 

 
 



The method used earlier in this section can also be used to demonstrate that the  tracks for each object in Tables~\ref{tab:Tracks in u for Case 2a} and~\ref{tab:Tracks in u for Case 2b} will cause the appendants shown in Figure~\ref{fig:reading objects when number of symbols read is lowerbound} to be appended when each object is read. 
Note from the captions of Figures~\ref{fig:reading objects when number of symbols read is upperbound} and~\ref{fig:reading objects when number of symbols read is lowerbound} that the shift values differ between the two figures. 
From Table~\ref{tab:equalities} and Lemma~\ref{lem:read upper or lower bound number of symbols}, the number of symbols read in each object in  Figure~\ref{fig:reading objects when number of symbols read is upperbound} is  and the number of symbols read in each object in  Figure~\ref{fig:reading objects when number of symbols read is lowerbound} is  (there is only one case for reading  since ). 
Note from Figure~\ref{fig:tracks for appending each object}, to append an  object we read a symbol sequence of length , and to append an  object we read a symbol sequence of length . 
So when we read  symbols (instead of ) in an object as shown in Figure~\ref{fig:reading objects when number of symbols read is lowerbound}, we include an  object instead of one of the  objects as this gives an object track that is one symbol shorter than the tracks read in Figure~\ref{fig:reading objects when number of symbols read is upperbound}. 
Recall that only  symbols are read when  is entered with a shift , and so the location of the  object in the sequence of objects that are appended depends on which  is entered with a shift . 
In Tables~\ref{tab:Tracks in u for Case 2a} and~\ref{tab:Tracks in u for Case 2b} we introduce the variable  to denote the position of the  word within the object that appends the  object. 
In rows 2, 6, 8 and 12 in Table~\ref{tab:Tracks in u for Case 2a} and rows 7 and 11 in Table~\ref{tab:Tracks in u for Case 2b} the range of shift values for which  gets appended by  is less than the usual range of . 
The reason for this is that the object being read is entered with a shift  that does not give all values in the range  for these cases. 
For example, in row 12 of Table~\ref{tab:Tracks in u for Case 2a} we have  because it is not possible to have  when  is entered with shift .

In this section we provided a method for showing that  is defined via Tables~\ref{tab:Tracks in u for Case 1} to~\ref{tab:Tracks in u for Case 2b} such that each object appends the correct sequence of objects as shown in Figures~\ref{fig:reading objects when number of symbols read is upperbound} and~\ref{fig:reading objects when number of symbols read is lowerbound}. In Lemma~\ref{lem:Correctness of u} we prove the correctness of  by show that we have not assigned more than one value to the same track in the word .




\subsubsection{Complexity analysis}
We give the time analysis for  simulating the cyclic tag systems  that runs in time . 
During the simulation, for every  objects from  that are read, we enter one of these objects with shift  (this is because  and  have a shift change of ). 
From Figure~\ref{fig:reading objects when number of symbols read is lowerbound} (i) and (ii), if we enter an  or an  object with shift , then there is a single  object in the sequence of objects that are appended. So after reading  objects from  to simulate  steps of , we have  of the  objects in the dataword of . 
For each object read from , a constant number (independent of the input) of the  objects are appended, and so we have  of the  objects in the dataword of . 
There are  objects from  in the dataword, and so the space used by  is . 
Between each pair of objects  that encode adjacent symbols in the dataword of  there are  of the  and  objects. 
So the word  that is read to simulate a computation step, as described in the second last paragraph Section~\ref{sec:Algorithm overview}, has  objects.
From Figures~\ref{fig:reading objects when number of symbols read is upperbound} and~\ref{fig:reading objects when number of symbols read is lowerbound} it takes a constant number of steps to read each object, and thus reading  to simulate a single computation step takes time .
So,  simulates a single step of  in time , and  steps of  in time .


\subsection{Correctness of }
Note that in addition to the proof of correctness given here,  was implement in software and tested extensively. Below, the correctness of  is proved by showing that it correctly simulates an arbitrary computation step of the cyclic tag system . In the third, fourth and fifth paragraphs of Section~\ref{sec:Algorithm overview} is an overview of how  reads a word of the form  (where ) to simulate a computation step of . Lemma~\ref{lem:simulating a computation step of C} shows that  reads  to correctly simulate an arbitrary computation step of . The  dataword immediately before the simulated computation step is given by Equation~\eqref{eq:TS dataword before simulated computation step} and the  dataword immediately after the simulated computation step is given by Equation~\eqref{eq:TS dataword after simulated computation step}. In Equation~\eqref{eq:TS dataword after simulated computation step} the next encoded symbol to be read, , is at the left end of the dataword, and so after the simulated computation step  the dataword has the correct form to begin the simulation of the next computation step. It follows that  correctly simulates the computation . Recall that cyclic tag systems end their computation by entering a repeating sequence of configurations. While  correctly simulates this repeating sequence of configurations,  itself does not enter a repeating sequence as the number of garbage objects in the dataword increases with each simulated computation step.   


In Lemma~\ref{lem:simulating a computation step of C} the objects , , , and  are defined in Section~\ref{sec:Encoding used by tag system} and the values , ,  and  can be found in Table~\ref{tab:equalities}. Equations~\eqref{eq:TS dataword before simulated computation step} and~\eqref{eq:TS dataword after simulated computation step} encode arbitrary datawords of  in the manner described by Equation~\eqref{eq:encoding CTS configuration}.

\begin{lemma}[ simulates an arbitrary computation step of ]\label{lem:simulating a computation step of C}
Given a dataword of the form

where  and , then a single round of  on the word  gives a dataword of the form

where  and , and

\end{lemma}
\begin{proof}
We begin by showing that to prove this lemma it is sufficient to verify that  behaves as described in Figures~\ref{fig:reading objects when number of symbols read is upperbound} and~\ref{fig:reading objects when number of symbols read is lowerbound}. 
In (i) and (ii) of Figures~\ref{fig:reading objects when number of symbols read is upperbound} and~\ref{fig:reading objects when number of symbols read is lowerbound} each dataword on left gives one of the four possible cases for Equation~\eqref{eq:TS dataword before simulated computation step}. 
These four cases are given by the four possible values for the pair  which also determine the four cases in Equation~\eqref{eq:values for w'}. 
Note that if  behaves as described in the (i) and (ii) of Figures~\ref{fig:reading objects when number of symbols read is upperbound} and~\ref{fig:reading objects when number of symbols read is lowerbound}, then the correct value for  is appended for each of the four cases in Equation~\eqref{eq:values for w'}.
So proving the correctness of (i) and (ii) in Figures~\ref{fig:reading objects when number of symbols read is upperbound} and~\ref{fig:reading objects when number of symbols read is lowerbound} verifies that the correct value for  is appended. 

From (i) and (ii) of Figures~\ref{fig:reading objects when number of symbols read is upperbound} and~\ref{fig:reading objects when number of symbols read is lowerbound}, when  is entered with shift , the object immediately to the right is entered with a shift of the form . 
So from Equation~\eqref{eq:TS dataword before simulated computation step}, we enter the leftmost object in the word  with shift . From Table~\ref{tab:equalities} an  has a shift change of 0 and  has a shift change of , and so from Lemma~\ref{lem:shiftChange} each object in the word  is entered with a shift of the form . Here  since . 
From (iii) and (iv) in Figure~\ref{fig:reading objects when number of symbols read is upperbound} and (iii) in Figure~\ref{fig:reading objects when number of symbols read is lowerbound}, when  and  objects are entered with a shift of the form , they append only  and  objects. 
(From Section~\ref{sec:length of objects}, the range of values for  and  cover all possible shift values, and thus shift values of the from  are covered by the cases in Figures~\ref{fig:reading objects when number of symbols read is upperbound} and~\ref{fig:reading objects when number of symbols read is lowerbound}). 
So proving the correctness of (iii) and (iv) in Figure~\ref{fig:reading objects when number of symbols read is upperbound} and (iii) in Figure~\ref{fig:reading objects when number of symbols read is lowerbound} verifies that reading the word  in Equation~\eqref{eq:TS dataword before simulated computation step} appends a word of the from . 

From the two paragraphs above it follows that if Figures~\ref{fig:reading objects when number of symbols read is upperbound} and~\ref{fig:reading objects when number of symbols read is lowerbound} are correct, then given a dataword of the form shown in Equation~\eqref{eq:TS dataword before simulated computation step},  produces a dataword of the form shown in Equation~\eqref{eq:TS dataword after simulated computation step}. 
We complete the proof of this lemma by demonstrating the correctness of Figures~\ref{fig:reading objects when number of symbols read is upperbound} and~\ref{fig:reading objects when number of symbols read is lowerbound}. 
In each line of Figures~\ref{fig:reading objects when number of symbols read is upperbound} and~\ref{fig:reading objects when number of symbols read is lowerbound} the shift with which object  is entered follows immediately from the shift change caused by reading the leftmost object (see Lemma~\ref{lem:shiftChange} and Table~\ref{tab:equalities}). 
For example in Figure~\ref{fig:reading objects when number of symbols read is upperbound} (i) an  is entered with shift , and because  has a shift change of , the object  immediately to the right is entered with shift .
Given that we can show that  is entered with the correct shift for each case in Figures~\ref{fig:reading objects when number of symbols read is upperbound} and~\ref{fig:reading objects when number of symbols read is lowerbound}, it only remains to show that when each object is read the correct appendant gets appended. 
The method demonstrated in Section~\ref{sec:Reading objects and  subwords} can be applied to show that the word  is defined via Tables~\ref{tab:Tracks in u for Case 1} to~\ref{tab:Tracks in u for Case 2b} such that when each object is read it appends the appendants as shown in Figures~\ref{fig:reading objects when number of symbols read is upperbound} and~\ref{fig:reading objects when number of symbols read is lowerbound}. 
In Section~\ref{sec:Reading objects and  subwords} the method was applied to only the case in Figure~\ref{fig:reading objects when number of symbols read is lowerbound} (i), however in Section~\ref{sec:Reading objects and  subwords} it was also explained how to apply the method to the remaining cases in Figures~\ref{fig:reading objects when number of symbols read is upperbound} and~\ref{fig:reading objects when number of symbols read is lowerbound} and so we do not give them here. 

In the previous paragraph we have shown how to verify that in each object the tracks for  in Tables~\ref{tab:Tracks in u for Case 2a} to~\ref{tab:Tracks in u for Case 2b} will append the appendants shown in Figures~\ref{fig:reading objects when number of symbols read is upperbound} and~\ref{fig:reading objects when number of symbols read is lowerbound}. 
To complete our proof we show that all possible tracks read in  are given in Tables~\ref{tab:Tracks in u for Case 2a} to~\ref{tab:Tracks in u for Case 2b}, and that one and only one value has been assigned to each track.
Using the method in paragraph 2 of Section~\ref{sec:Reading objects and  subwords} and Figure~\ref{fig:u track and encodedOne track} (ii),
one can to verify that the set of all tracks for an object entered with shift  appears in Tables~\ref{tab:Tracks in u for Case 1} to~\ref{tab:Tracks in u for Case 2b}.
The entire range of values for  (given in  Section~\ref{sec:length of objects}) is covered in Tables~\ref{tab:Tracks in u for Case 1} to~\ref{tab:Tracks in u for Case 2b}.
So all possible  tracks are given in Tables~\ref{tab:Tracks in u for Case 1} to~\ref{tab:Tracks in u for Case 2b} and from Lemma~\ref{lem:Correctness of u} each  track in Tables~\ref{tab:Tracks in u for Case 1} to~\ref{tab:Tracks in u for Case 2b} is assigned one and only one value. 
\end{proof} 

The remainder of this section contains lemmas used in the proof of 
Lemma~\ref{lem:simulating a computation step of C} and in explanations in Section~\ref{sec:Simulation algorithm}. Before each lemma we briefly explain its significance for our algorithm.

Section~\ref{sec:Reading objects and  subwords} shows how to verify that in each object the tracks for  in Tables~\ref{tab:Tracks in u for Case 2a} to~\ref{tab:Tracks in u for Case 2b} will append the appendants shown in Figures~\ref{fig:reading objects when number of symbols read is upperbound} and~\ref{fig:reading objects when number of symbols read is lowerbound}.
Lemma~\ref{lem:Correctness of u} shows that there are no contradictions in Tables~\ref{tab:Tracks in u for Case 1},~\ref{tab:Tracks in u for Case 2a} and~\ref{tab:Tracks in u for Case 2b}.
\begin{lemma}\label{lem:Correctness of u}
Each track of the form  in Tables~\ref{tab:Tracks in u for Case 1},~\ref{tab:Tracks in u for Case 2a}, and~\ref{tab:Tracks in u for Case 2b} has been assigned one and only one value.  
\end{lemma}
\begin{proof} 
Below we state each case followed by the rows from Tables~\ref{tab:Tracks in u for Case 1},~\ref{tab:Tracks in u for Case 2a}, and~\ref{tab:Tracks in u for Case 2b} to which the case applies and then we give the proof of that case.

Case 1: Tracks of the form  for  (rows 14 to 18 in Table~\ref{tab:Tracks in u for Case 1} and rows 1 to 7 in Table~\ref{tab:Tracks in u for Case 2b}).
Tracks of this form are used to append the encoding of  (see Tables~\ref{tab:Tracks in u for Case 1} and~\ref{tab:Tracks in u for Case 2b}). 
There are three forms of encoding for  (see Equations~\eqref{eq:alpha m} to~\eqref{eq:alphaPrime m2}). 
The encoding that is used depends on the shift  with which  is entered. Equation~\eqref{eq:alpha m} is used when  and the choice between Equations~\eqref{eq:alphaPrime m1} and~\eqref{eq:alphaPrime m2} depend on whether  or  (see third column of Table~\ref{tab:Tracks in u for Case 2b}).
Note from rows 7, 9 and 11 of Table~\ref{tab:Tracks in u for Case 2b} that the value of  depends on the value of .
So the shift value  determines which of the encodings in Equations~\eqref{eq:alpha m} to~\eqref{eq:alphaPrime m2} to choose for , and from Lemma~\ref{lem:Encode appendant} the shift value  encodes  and only . 
It follows that there is one and only one encoding associated with each .
From Lemma~\ref{lem: ui words with unique shift values} each track of the form  for  is entered if and only if an  is entered with shift  and the   is being read. 
This means that track  will be read if and only if we are appending the  object in the encoding of appendant  as described in the third paragraph of Section~\ref{sec:Reading objects and  subwords}.
Since there is one and only one encoding associated with each  it follows that each track of the from  for  is assigned one and only one value.  


Case 2: Tracks of the form , where  and  for  (rows 2, 5, 6, 7, 10, 11, 12, 19 and 20 in Table~\ref{tab:Tracks in u for Case 1}, rows 1, 3, 5, 7, 9, and 11 in Table~\ref{tab:Tracks in u for Case 2a}, and rows 8 and 10 in Table~\ref{tab:Tracks in u for Case 2b}). All  tracks for this case append only  objects. This can be easily verified by checking the above mentioned rows. It follows that each track from this case is assigned one and only one value.

Case 3: Tracks of the form , where  and  for  (rows 1, 3, 4, 8, 9, 13 and 21 in Table~\ref{tab:Tracks in u for Case 1}, and rows 2, 4, 6, 8, 10 and 12 in Table~\ref{tab:Tracks in u for Case 2a} and rows 9 and 11 in Table~\ref{tab:Tracks in u for Case 2b}). The  tracks entered with shift   either append , or result in one of the special cases given by rows 1, 3, 4, 8, and 21 of Table~\ref{tab:Tracks in u for Case 1}. 
Here we omit rows 9 and 13 as they define the same tracks as rows 4 and 8. 
No two of the cases from rows 1, 3, 4, 8, and 21 in Table~\ref{tab:Tracks in u for Case 1} have the same underscript and thus no conflicts occurs when comparing one special case with another special case. 
Note that to see the difference between the underscripts in these special cases one should keep in mind that . For example, to show that the row 8 underscript  is not equal to the row 21 underscript  we must have .
Given that no conflicts occurs between the special cases, it only remains to show that these special cases have no conflicts with tracks that append . 
The  tracks that append  are given by rows 2, 4, 6, 8, 10 and 12 in Table~\ref{tab:Tracks in u for Case 2a} and rows 9 and 11 of Table~\ref{tab:Tracks in u for Case 2b}. 
(We need not consider row 7 of Table~\ref{tab:Tracks in u for Case 2b} as this was covered by Case 1.) 
For these cases comparing the underscripts  shows that the values in the underscripts of some of the special cases differ from those that append . 
For example, in Table~\ref{tab:Tracks in u for Case 1} the underscript in row 8 gives  (since ) and in Table~\ref{tab:Tracks in u for Case 2a} the underscript in row 4 gives  (since ). 
It follows that there is no conflict between these two rows as they define tracks in  for two different shift values. 
Comparing the underscript values  does not work for all cases as some underscript values may have different shift values but the same values . 
In each of these cases by looking at the range of values in the third column of the tables one sees that the shift values in the underscripts do not coincide. 
For example, in row 8 of Table~\ref{tab:Tracks in u for Case 1} we have a shift of  and in row 6 of Table~\ref{tab:Tracks in u for Case 2a} we have a shift . 
From the third column of row 6 in Table~\ref{tab:Tracks in u for Case 2a}, we have the range of values  and so here .
Using this method one finds for the remaining cases (i.e. those not covered by comparing underscripts ) that no underscript for a  track from rows 1, 3, 4, 8, and 21 has the same value as an underscript for a  track given by rows 2, 4, 6, 8, 10 and 12 in Table~\ref{tab:Tracks in u for Case 2a} and rows 9 and 11 of Table~\ref{tab:Tracks in u for Case 2b}.
So tracks of the form  are assigned one and only one value, where  and  for .
\end{proof}


Recall from paragraph 3 of Section~\ref{sec:Reading objects and  subwords}, that when an  is entered with shift , the   read appends the  object from the left in the encoding of . 
So the shift value for the track read in the   from the left when  is entered with shift  must be unique.
From Section~\ref{sec:Cyclic tag system C'},  and so we need not concern ourselves with values where . 
From Figure~\ref{fig:u track and encodedOne track} (ii), for  track  is read in the   from the left when  is entered with shift . 
For this reason, in Lemma~\ref{lem: ui words with unique shift values} we show for  that  is read if and only if  is entered with shift  and we are reading   from the left.

\begin{lemma}\label{lem: ui words with unique shift values}
Let  be the shift with which we enter , , , and  objects. Then track  is read if and only if  is entered with shift  and the   from the left is being read. Here  and .
\end{lemma}
\begin{proof}
From Figure~\ref{fig:u track and encodedOne track} (ii) and paragraph 2 of Section~\ref{sec:Reading objects and  subwords}, we know that if an  is entered with shift , then the track read in the   from the left is , where . To complete the proof we show that for any arbitrary track  that  when  is \emph{not} read in the   from the left in an  entered with shift . 
The values for  when entering the objects , , , and  with shift  are given by the underscripts of the  tracks in the middle column of Tables~\ref{tab:Tracks in u for Case 1} to~\ref{tab:Tracks in u for Case 2b}. 
In these tables the value  in  is of the form  (for example  in rows 1 to 3 of Table~\ref{tab:Tracks in u for Case 1}). 
So to show  we prove , which we rewrite as . Because  and  for all   it is sufficient to show that 

In Tables~\ref{tab:Tracks in u for Case 1} to~\ref{tab:Tracks in u for Case 2b} the value  denotes the position of the  word read in an object. For example,  is the leftmost  in the object,  is the second  from the left and so on. Below we use the value  to give the cases for  in each object.

Case 1: Reading track  in  when . From Tables~\ref{tab:Tracks in u for Case 1} and~\ref{tab:Tracks in u for Case 2b} we have , and from the previous paragraph we have . When we substitute this value for  in Equation~\eqref{eq:unique tracks in encoded 1} we get the inequality  which holds when ,  and . Note that here we do not consider the case  as this implies that  which means all the requirements (as given in the lemma statement) for reading  have been met.

Case 2: Reading track  in  when . From Tables~\ref{tab:Tracks in u for Case 1} and~\ref{tab:Tracks in u for Case 2b} we have , and from paragraph 1 of this lemma we have . When we substitute this value for  in Equation~\eqref{eq:unique tracks in encoded 1} we get the inequality  which holds for .


Case 3: Reading track  in  when . From Tables~\ref{tab:Tracks in u for Case 1} and~\ref{tab:Tracks in u for Case 2b} we have , and from paragraph 1 of this lemma we have .  When we substitute this value for  in Equation~\eqref{eq:unique tracks in encoded 1} we get the inequality  which holds for .


Case 4: Reading track  in  or  when . From Tables~\ref{tab:Tracks in u for Case 1} and~\ref{tab:Tracks in u for Case 2a} we have , and from paragraph 1 of this lemma we have . When we substitute this value for  in Equation~\eqref{eq:unique tracks in encoded 1} we get the inequality  which holds for .


Case 5: Reading track  in  when  or in  when . From Tables~\ref{tab:Tracks in u for Case 1} and~\ref{tab:Tracks in u for Case 2a} we have we have , and from paragraph 1 of this lemma we have . When we substitute this value for  in Equation~\eqref{eq:unique tracks in encoded 1} we get the inequality  which holds for .


Case 6: Reading track  in  when . From Tables~\ref{tab:Tracks in u for Case 1} and~\ref{tab:Tracks in u for Case 2a} we have we have , and from paragraph 1 of this lemma we have . When we substitute this value for  in Equation~\eqref{eq:unique tracks in encoded 1} we get the inequality  which holds for .

Case 7: Reading track  in  when . From Tables~\ref{tab:Tracks in u for Case 1} and~\ref{tab:Tracks in u for Case 2a} we have we have , and from paragraph 1 of this lemma we have . When we substitute this value for  in Equation~\eqref{eq:unique tracks in encoded 1} we get the inequality  which holds for .


Case 8: Reading track  in  when . From Table~\ref{tab:Tracks in u for Case 1} we have we have , and from paragraph 1 of this lemma we have . When we substitute this value for  in Equation~\eqref{eq:unique tracks in encoded 1} we get the inequality  which holds for .
\end{proof}

The following lemma shows that each shift  encodes one and only one appendant .
The variables in the Lemma statement are from Table~\ref{tab:equalities}.
\begin{lemma}\label{lem:Encode appendant}
For each pair  and , if  then .
\end{lemma}
\begin{proof}
From the values in Table~\ref{tab:equalities}, we get . 
Note that  and ,  and so we have  (and similarly  ). 
So if , then either  or  (here we can assume  as the argument is the same for ).
We rewrite these case as  and . 
Note that , and since  we also have , which means that for both cases . 
From the values in Table~\ref{tab:equalities} we have , and since  and  are relatively prime we get  for ,  and . It follows that the above equalities do not hold since  and  are divisible by  and  is not, and thus .
\end{proof}


\subsection{The halting problem for binary tag systems}

\begin{corollary}\label{cor:2 symbol tag halting problem}
The halting problem for binary tag systems is undecidable.
\end{corollary}
\begin{proof}
In Theorem~\ref{thm:main theorem} the  tracks at odd valued shifts are never read by . So setting  tracks at odd shifts to be sequences of all  symbols causes no change in the simulation algorithm.  simulates the cyclic tag system in~\cite{NearyWoods2006C} which has a special appendant  that is appended if and only if the Turing machine it simulates is halting. 
We can alter  so that instead of appending  when  halts, it appends an object of odd length so that all subsequent  subwords are entered with an odd shift. This means that a single round on the tag system dataword changes everything to  symbols. 
Now the rule , which appends one  and deletes  symbols, is repeated until number of symbols is  and the computation halts. So the computation halts if and only if the cyclic tag system is simulating a halting Turing machine.
\end{proof}




\section{The Post correspondence problem for 4 pairs of words}
In Theorem~\ref{thm:PCP 4 is undecidable} we show that the Post correspondence problem is undecidable for 4 pairs of words. Theorem~\ref{thm:PCP 4 is undecidable} is proved by reducing the halting problem for the binary tag system given in Lemma~\ref{lem:binary tag system for PCP} to the Post correspondence problem. The halting problem for the binary tag system in Lemma~\ref{lem:binary tag system for PCP} is proved undecidability by simulating the cyclic tag system given in Lemma~\ref{lem:CTS with input dataword 1}. 

\begin{definition}[Post correspondence problem]\label{def:PCP}
Given a set of pairs of words  where  is a finite alphabet, determine whether or not there is a non-empty sequence . 
\end{definition}

\begin{lemma}\label{lem:CTS with input dataword 1}
Let  be a cyclic tag system and let  be an input dataword to . Then there is a cyclic tag system  that takes a single 1 as its input and simulates the computation of  on .  
\end{lemma}
\begin{proof}
The binary dataword  is encoded as , and each binary appendant  in  is encoded as . The program for  is defined by the equation

where  is the empty word and  is defined above. The configuration for  at the start of the computation is given by
\begin{xalignat*}{2}
\pmb{\tne{w}},\tne{\alpha_0},\epsilon,\tne{\alpha_1},\epsilon,\tne{\alpha_2},\ldots,\epsilon\tne{\alpha_{p-1}}& & &1
\end{xalignat*}
where the program is given on the left with the marked appendant  in bold, and the input dataword is a single 1 and is given on the right. After the first computation step we have
\begin{xalignat*}{2}
\tne{w},\pmb{\tne{\alpha_0}},\epsilon,\tne{\alpha_1},\epsilon,\tne{\alpha_2},\ldots,\epsilon\tne{\alpha_{p-1}}& & &w_10w_20w_30\ldots w_n0
\end{xalignat*}
In the configuration above the encoding  of  has been appended. Now the simulation of the first computation step of  on  begins. Every second appendant in  is an  appendant and every second symbol in the dataword of  is a  symbol. So  on the input dataword 1 simulates the computation of  on .
\end{proof}

\begin{lemma}\label{lem:binary tag system for PCP}
The halting problem is undecidable for binary tag systems with deletion number , alphabet  and rules of the form  and  (), when given  as input.
\end{lemma}
\begin{proof}
We use the tag system  from Theorem~\ref{thm:main theorem} to construct a 2-symbol tag system  of the type mentioned in the lemma statement. From Lemma~\ref{lem:CTS with input dataword 1}, we can assume without loss of generality that  simulates cyclic tag systems whose input is a single 1.

Recall that  has rules of the form  and  (where ), and a deletion number . 
In  track  is never read, and so we can define  such that reading  appends the word . 
Note that  is obtained from  by removing a single  form the subword . 
Because each  in the subword  appends a garbage object that has no effect on the computation, reading an  simulates reading an . 
So given the input dataword  the sequence  is read appending  and the simulation of  on input 1 is ready to begin.

Now we replace the rule  in  with the rule  (where )
The new track that we defined above for appending  is  with its first symbol  deleted and for this reason we can delete  from  to give  as it is never read.
The extra  added at the right end of  means that . 
Following the replacement of  with , we make a few minor changes which we detail below so that the simulation of  on input 1 proceeds correctly.


The shift change from reading the input word  is  (as  and the shift change for  is ). 
Recall that reading  appends , so after reading the input  we enter  with the shift value .
Above to get  we deleted the leftmost symbol  from  and so every track in  is shifted one symbol to the left in . A shift of  corrects for this and so the shift change of  is in fact equivalent to a shift change of .
A shift of  simulates that the marked appendant is at  instead of . 
To see this note from Table~\ref{tab:equalities} that  for  and , which encodes that  is the marked appendant. 
If we alter the simulated cyclic tag system by taking the last appendant in the program and placing it at the start of the list of appendants, then every appendant get shifted one place to the right in the circular program. 
Now when we enter  with shift , we are simulating the marker at the correct encoded appendant. 

There is another problem to overcome. 
The object  has one less  than  and so has a different shift change to .
From the values in Table~\ref{tab:equalities}, the object  has a shift change of , and such a shift change value simulates no change in the marked appended (see the end of Section~\ref{sec:Encoding the marked appendant}). 
Recall that we are simulating , and so from Lemma~\ref{lem:CTS with input dataword 1}, when we read the encoded  we append the encoding of the dataword . 
If we change the dataword so that we encode the word  (instead of ), then the extra encoded  is read before we be read the encoding of . 
The shift change caused by the extra encoded  simulates the marker moving to the next appendant so that we enter the encoding of  with the correct shift. 
Now that we have successfully appended the encoding of  the remainder of the computation of  is simulated step for step. 

Finally, the technique from  Corollary~\ref{cor:2 symbol tag halting problem} can be use to modify the above system so that it halts if an only if it is simulating a halting Turing machine. Note that because the tracks from  are shifted one place to the left in  when we apply the technique from  Corollary~\ref{cor:2 symbol tag halting problem} we set the even tracks (instead of the odd tracks) in  to be sequences of all  symbols. This completes our construction of .
\end{proof}






\begin{theorem}\label{thm:PCP 4 is undecidable}
The Post correspondence problem is undecidable for 4 pairs of words. 
\end{theorem}
\begin{proof}
We reduce the halting problem for the binary tag system  in Lemma~\ref{lem:binary tag system for PCP} to the Post correspondence problem for 4 pairs of words. 
The symbols  and  in  are encoded as  and  respectively, where  is the deletion number of . 
The halting problem for  reduces to the Post correspondence problem given by the 4 pairs of binary words

where  is the empty word and . 
Let  and , where each  and  is a prefix of . 
We will call the pair  a configuration of . Because  has an initial input word that ends in a  and both of the rules of  append words that end in a  an arbitrary dataword of  has the from . The arbitrary dataword  is encoded by a  configuration of the form

In each configuration , the unmatched part of  (given by ) encodes the current dataword of . 


We must have  as the leftmost pair  in a match as having any other pair from  as the leftmost pair will not give a match. 
Starting from the pair , if  we add the pair  and this matches  simulating the deletion of . 
If, on the other hand,  we add the pair  followed by the pair  and this matches  simulating the deletion of . 
So after matching  we have .
We match  encoded  symbols in this way to give . 
The configuration is now of the form given in Equation~\eqref{eq:encoding of T'_C config for P} and the unmatched sequence  in  encodes the input dataword to  in Lemma~\ref{lem:binary tag system for PCP}. 


A computation step of  on the arbitrary dataword  is of one the two forms:



The two forms of computation step given in Equations~\eqref{eq:T'C timestep read symbol c} and~\eqref{eq:T'C timestep read symbol b} are simulated as follows: In Equation~\eqref{eq:encoding of T'_C config for P}, if  then  and we add the pair  to simulate the  rule ,  and this gives .
In Equation~\eqref{eq:encoding of T'_C config for P}, if  then  and we add the pair  to simulate the  rule , and this gives .
In both cases ( and ) to complete the simulation of the computation step we continue to match the pairs  and  as we did in the previous paragraph to simulate the deletion of a further  tag system symbols. 
Simulating the deletion of  symbols adds a further  of the 0 symbols at the right end of the encoded dataword. 
So if  this gives , with the unmatched part in this pair encoding the dataword on the right of Equation~\eqref{eq:T'C timestep read symbol c} after the computation step. 
Alternatively, if  we get , with the unmatched part in this pair encoding the dataword on the right of Equation~\eqref{eq:T'C timestep read symbol b} after the computation step.
The simulated computation step is now complete.

We now explain how  simulates  halting with a matching sequence. In  the rule  deletes  symbols and append a single  reducing the number of symbols in the dataword by , and the rule  deletes  symbols and appends  symbols (, see Table~\ref{tab:equalities} and Lemma~\ref{lem:binary tag system for PCP}) increasing the number of symbols in the dataword by .
So, because the input dataword  is of length  and the rules either increase the length by  or decrease it by , all datawords of  have lengths of , where . 
From Corollary~\ref{cor:2 symbol tag halting problem},  halts when the length of its final dataword (which consists entirely of  symbols) is less than the deletion number . 
So, when  halts we have  which means the dataword is a single . 
From Equation~\eqref{eq:encoding of T'_C config for P}, this is encoded as the configuration . 
By appending the pair  to , we get the pair of matching sequences  when  halts. 
Note that whenever there is choice of which pair to append, only the choice that follows the simulation as described above has the possibility to lead to a match (all other choices lead to a mismatch). 
Therefore,  has a matching sequence if and \mbox{only if  halts.}
\end{proof}

\subsection{Undecidability in simple matrix semi-groups}
Undecidability bounds for the Post correspondence problem have been used by a number of authors~\cite{Bell2008,Blondel1997,Bournez2002,Cassaigne1998,Halava2001,Halava2007,Halava2007A,Paterson1970} in the search for undecidable decision problems in simple matrix semi-groups. The undecidability of the Post correspondence problem for 7 pairs of words~\cite{Matiyasevich2005}
has been frequently used to find undecidability in simple matrix semi-groups. Theorem~\ref{thm:PCP 4 is undecidable} results in an immediate improvement on many of these results. Here we will just describe improvements for two of these problems. Of the decision problems on simple matrix semi-groups the mortality problem has in particular received much attention. 

\begin{definition}[Matrix mortality problem]
Given a finite set of  integer matrices  , is there a product the produces the zero matrix, where ? 
\end{definition}

To date the best known bounds for the undecidability of the matrix mortality problem are due to Halava et al.~\cite{Halava2007}. Improving on the reduction of Paterson~\cite{Paterson1970}, they showed that the matrix mortality problem is undecidable for sets with seven  matrices. 
Cassaigne and Karhum\"{a}ki~\cite{Cassaigne1998} showed that if the mortality problem is undecidable for a set of  matrices of dimension  then the mortality problem is undecidable for a pair of  matrices. 
So an immediate corollary of the result given by Halava et al.~is that the mortality problem is undecidable a set of two  matrices.
By applying the reductions in~\cite{Halava2001} and~\cite{Cassaigne1998} to  in Theorem~\ref{thm:PCP 4 is undecidable} we get Corollary~\ref{cor:matrix mortality}.
\begin{corollary}\label{cor:matrix mortality}
The matrix mortality problem is undecidable for sets with five  matrices and for sets with two  matrices. 
\end{corollary}

Halava and Hirvensalo~\cite{Halava2007A} give undecidability results for sets that consist of a pair of matrices with remarkably small dimensions. 
One of the problems they tackle is the scalar reachability problem which they prove undecidable for a pair of  matrices.
\begin{definition}[Scalar reachability problem]
Given a finite set of  integer matrices  , a vector ,  the transpose of vector , and a constant , is there a product ? 
\end{definition}
By applying the reductions in~\cite{Halava2007A} to  in Theorem~\ref{thm:PCP 4 is undecidable} we get Corollary~\ref{cor:scalar reachability}.
\begin{corollary}\label{cor:scalar reachability}
The scalar reachability problem is undecidable for two  matrices. 
\end{corollary}









\subsubsection*{Acknowledgements:}
This work was supported by Science Foundation Ireland, grant number 09/RFP/CMS2212 and by Swiss National Science Foundation grant number 200021-141029. I would like to thank Matthew Cook and Damien Woods for their comments and discussions, and Vesa Halava and Mika Hirvensalo for their advice on  undecidability in simple matrix semi-groups.

\bibliographystyle{abbrv}
\bibliography{Binary_tag_systems.bib}

\end{document}
