
\documentclass[11pt]{article}
\usepackage[a4paper,margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{multirow} 
\usepackage{subfig}
\usepackage[cmex10]{amsmath}
\graphicspath{{./figures/}} \usepackage{hyperref} 


\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}



\newenvironment{proof}[1][Proof]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newenvironment{definition}[1][Definition]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newenvironment{example}[1][Example]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newenvironment{remark}[1][Remark]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}

\newcommand{\qed}{\nobreak \ifvmode \relax \else
      \ifdim\lastskip<1.5em \hskip-\lastskip
      \hskip1.5em plus0em minus0.5em \fi \nobreak
      \vrule height0.75em width0.5em depth0.25em\fi}

\title{Randomized -Edge-Coloring via Quaternion of Complex Colors\\ (Extended Abstract)}
\author{
	Tony T. Lee \footnote{Tony T. Lee is with Dept. of Information Engineering, The Chinese University of Hong Kong, Hong Kong and Dept. of Electronics Engineering, Shanghai Jiao Tong University, Shanghai, China. Email: ttlee@ie.cuhk.edu.hk }
	\and
	 Yujie Wan \footnote{Yujie Wan is with Dept. of Information Engineering, The Chinese University of Hong Kong, Hong Kong. Email: wyj009@ie.cuhk.edu.hk}
	\and 
	Hao Guan  \footnote{Hao Guan is with Dept. of Information Engineering, The Chinese University of Hong Kong, Hong Kong. Email: hguan@ie.cuhk.edu.hk}
}

\begin{document}
\maketitle 

\begin{abstract}
	This paper explores the application of a new algebraic method of color exchanges to the edge coloring of simple graphs. Vizing's theorem states that the edge coloring of a simple graph  requires either  or  colors, where  is the maximum vertex degree of . Holyer proved that it is {\bf NP}-complete to decide whether  is -edge-colorable even for cubic graphs. By introducing the concept of complex colors, we show that the color-exchange operation follows the same multiplication rules as quaternion. An initially -edge-colored graph  allows variable-colored edges, which can be eliminated by color exchanges in a manner similar to variable eliminations in solving systems of linear equations. The problem is solved if all variables are eliminated and a properly -edge-colored graph is reached. For a randomly generated graph , we prove that our algorithm returns a proper -edge-coloring with a probability of at least 1/2 in  time if  is -edge-colorable. Otherwise, the algorithm halts in polynomial time and signals the impossibility of a solution, meaning that the chromatic index of  probably equals . Animations of the edge-coloring algorithms proposed in this paper are posted at YouTube \url{http://www.youtube.com/watch?v=KMnj4UMYl7k}.\\
\textbf{Keywords:} incidence graph, edge coloring, color exchange, Kempe path, directional path
\end{abstract}



\section{Introduction}


The chromatic index   of a simple graph , with vertex set  and edge set , is the minimum number of colors required to color the edges of the graph such that no adjacent edges have the same color. A theorem proved by Vizing \cite{west2001introduction} states that the chromatic index is either  or , where  is the maximum vertex degree of graph . The graph  is said to be Class 1 if ; otherwise, it is Class 2. Except for some particular types of graphs, such as bipartite graphs, it is inherently difficult to classify an arbitrary simple graph. In fact, Holyer has proved in \cite{holyer1981np} that it is {\bf NP}-complete to determine the chromatic index of arbitrary simple graph even if . 


In this paper, we describe a new algebraic method of color exchanges for edge coloring of simple graphs. The original color-exchange method was devised by Alfred Kempe in his endeavor to prove the four-color theorem \cite{kempe1879geographical}. Although his attempt was unsuccessful, his method remains critical to the final proof given by Appel and Haken \cite{appel1989every}. The Kempe chain method was defined on two-colored vertices. An extension of this method to two-colored edges, called alternating paths, constitutes the basis of the proof of Vizing's theorem and Edmonds' matching algorithm \cite{edmonds1987paths}. By introducing the concept of complex colors, we show that the color-exchange operation performed on alternating paths follows the same multiplication rules as quaternion, and edge coloring is a procedure of variable eliminations. 

We consider each edge  as a pair of links; each link is a half-edge. Let  be the set of colors. The coloring of graph  is a function  defined by assigning a color pair, or a complex color, to each , one color assigned for each link. If , then a color configuration  of  such that all links incident to the same vertex have different colors can be easily obtained. Suppose that the complex color assigned to edge  is , then the colored edge  is a {\it variable} if ; otherwise,  is a {\it constant} for any color . A proper -edge-coloring of graph  can be achieved by eliminating all variables.

Our edge-coloring algorithm starts with an arbitrary color configuration  of , which may contain variable edges. Applying a sequence of well-defined ``moves'' (color exchanges) of variables in a configuration may lead to other new configurations. Variables can be systematically eliminated when they encounter other variables while moving around the graph. For a graph  with , the algorithm can be initialized by a configuration of  with a set of  colors . First, we eliminate variables that contain color , then remove the remaining variables that contain color , and so on. The problem is solved if all variables are eliminated and a properly -edge-colored graph is reached; otherwise, the algorithm halts in polynomial time and signals the impossibility of a solution, meaning that the chromatic index of  probably equals , which implies that the graph  could be class 2.

Based on random walks on graphs, the average time that a variable hits another variable in a graph has a polynomial bound \cite{aldous2002reversible} \cite{Aleliunas1979random} \cite{lovsz1993random} . For a randomly generated graph , we prove that our algorithm returns a proper -edge-coloring with a probability of at least 1/2 in  time if chromatic index . On the other hand, it returns with absolute certainty if  is a class 2 graph. 

In existing literature, the only known exact algorithms are the  and  algorithms for 3-edge-coloring proposed by Beigel and Eppstein \cite{eppstein2001improved} \cite{beigel19953}. Vizing's proof implies an  time algorithm with  colors, which was later improved to  by Gabow et al. \cite{Gabowedgecoliring}. Some approximation algorithms with high probability of success were reported in \cite{grable1997nearly} \cite{dubhashi1998near} \cite{aggarwal2003switch}. Grable and Panconesi \cite{grable1997nearly} proposed an edge coloring algorithm using  colors, which operates in  rounds if  is larger than polylog but smaller than any positive power of . Dubhashi, Grable, and Panconesi \cite{dubhashi1998near} proposed another  time algorithm using  colors if  for some constants . For general multigraph with , Aggarwal et al. \cite{aggarwal2003switch} proposed an algorithm using  colors that runs in  steps. There are also some heuristics reported in \cite{hilgemeier2003fast} that do not provide any performance guarantees. Our randomized algorithm is the first polynomial time algorithm for -edge-coloring.


In principle, each vertex  and each edge  represent a constraint on coloring of edges, and the entire graph  can be considered as a set of simultaneous equations. The variable elimination procedure of edge coloring is similar to the Gaussian elimination of solving systems of linear equations. A comparison between these two procedures is summarized in Table \ref{tab:comp}.
\begin{table}[htpb]
	\centering
	{\footnotesize
		\begin{tabular}{|c || c| c| }
			\hline 
			& System of linear equations & Edge coloring \\
			\hline \hline 
			Operations & arithmetic operations & color exchanges \\ \hline 
			Constraints	& linear equations & vertices and edges \\ \hline 
			Unknowns & variables &  variable-colored edges \\ \hline 
			Algorithms &	variable elimination & variable elimination\\ \hline 
			Solutions	& consistency &	-colorable\\ \hline 
			No solution & inconsistency & infinite loop \\ \hline 
			Complexity & polynomial time & randomized polynomial time\\ 
			\hline		
		\end{tabular}	
		}
		\caption{Comparison between system of linear equations and edge coloring of simple graphs. }
	\label{tab:comp}
\end{table}

In spite of the similarity between solving linear equations and edge coloring, the main difference is  recognizing the final state. If a system of linear equations has no solution, the inconsistency of the system can be identified by variable eliminations in polynomial time. Eliminating variable edges of class 2 graphs may result in an infinite loop. Recognizing snarks, class 2 cubic graphs, could have been significant in determining the halting state of edge-coloring algorithms. A polynomial time algorithm for identifying snarks will immediately lead to the conclusion that {\bf P=NP}. 

The rest of this paper is organized as follows. In section 2, we define the color function of incidence graphs, and establish the rules of color exchanges and Kempe walks. In section 3, we describe the variable elimination procedure by Kempe walks, and introduce the concept of canonical configurations. Section 4 is devoted to walks on directional paths. In particular, we give a randomized algorithm based on walks on spanning tree with deflection. In addition, the performance of this randomized algorithm and the characterization of snarks are provided in this section. In section 5, we present experimental results and compare our method with existing heuristics. Section 6 provides a conclusion and discussions on future research.

\section{Color-Exchange Operations of Complex Colors}

This section introduces an algebraic method of color exchanges implemented on the edges of a colored simple graph. We first describe the properties of color function defined on incidence graphs, and then establish the rules of color exchanges and Kempe walks. 

Let  be a simple graph with vertex set , edge set . The {\it incidence graph}  is constructed from  by placing a fictitious vertex in the middle of each edge of . Let  denote the set of fictitious vertices on edges. Then edge , connecting two end vertices  and , consists of two {\it links}, denoted by  and . Fig. \ref{fig:incidencetetrahedron} (a) illustrates the incidence graph of the tetrahedron.

Let  be the set of links and  denote a set of  colors. A {\it coloring function}  defined on an incidence graph  is a mapping of color assignments on links . The color of link  is denoted as . Since each edge  consists of two links, the color function  can also be considered as a mapping defined on the set of edges: .	

We define the {\it colored edge}  as a two-tuple color vector, where  and  are respective colors of the two links of . The following properties of a color function  are related to the edge coloring of graph . 

\begin{definition}
\label{definition:coloring}
Let  be a coloring function of the incidence graph . Define\\
1.The colored edge  is a {\it constant} if ; otherwise it is a {\it variable}. The number of variables is denoted by .\\
2.{\it Vertex constraint}: The coloring function  is {\it consistent} if colors assigned to those links incident to the vertex  are all distinct for all .	\\
3.{\it Edge constraint}: The coloring function  is {\it proper} if it is consistent and all colored edges are constant.
\end{definition}

\begin{figure}[htpb]
	\centering
	\includegraphics[scale=0.85]{e_incidence_graph}
	\caption{(a) Incidence graph of tetrahedron. (b) Consistent coloring with variables  and . (c) Proper coloring of tetrahedron.}
	\label{fig:incidencetetrahedron}
\end{figure}

The coloring of incidence graph  is called a {\it configuration} of graph . As an example, a consistent configuration of a tetrahedron containing two variables is shown in Fig. \ref{fig:incidencetetrahedron} (b), and a proper configuration of a tetrahedron is shown in Fig. \ref{fig:incidencetetrahedron} (c) with the set of colors , where , , and , respectively represent green, red, and blue.


The edge constraints are sets of equalities of colors and the vertex constraints are un-equalities. The equality is a transitive binary relation but the un-equality is not. Most edge-coloring algorithms assign edge colors to satisfy vertex constraints, sets of un-equalities. However, mathematically, it is more natural and usually much easier to solve problems with equalities. Initially, we start with an arbitrary consistent color function  with  colors that satisfies the vertex constraint at every vertex of the graph, which may contain variable-colored edges. Our edge coloring algorithm is a systematic procedure to eliminate those variables, similar to the procedure of solving a system of simultaneous equations. 


\subsection{Kempe Walks}
In general, variable eliminations require a sequence of color exchanges, called {\it Kempe walks} that are performed on a two-colored {\it Kempe path} defined as follows.


\begin{definition}
\label{definition:KempePath}
In a consistently colored incidence graph, a {\it -Kempe path}, or simply {\it  path}, where  and , is a sequence of adjacent links  such that  for . The corresponding sequence of vertices contained in the path is defined as its {\it interior chain}. There are two types of maximum  path:\\
1. {\it  cycle} or {\it closed  path}: The two end-links  and  are adjacent to each other.\\
2. {\it Open  path}: Only one  or  colored link is adjacent to the end-links   and .
\end{definition}


A -variable edge is always contained in a maximum  path, either a  cycle or an open  path. Note that the open path may either end at a fictitious vertex or a real vertex. The following lemma can be obtained by simple counting arguments.

\begin{lemma}
\label{lemma:oddeven}
An even (odd)  cycle contains even (odd) number of  variables. 
\end{lemma}
\begin{proof}
Deleting all variables  in the  cycle by edge contraction, the remaining constant edges constitute an even  cycle. The lemma is established by the following relation:
\begin{center}
 variables=edges  even constant edges. \qed
\end{center}
\end{proof}

Variable eliminations can be achieved by the following color-exchange operation performed on adjacent colored edges.

\begin{definition}
\label{definition:colorexchange}
Let    and  be two colored edges incident to the same vertex , written as . Suppose that  and , for , the binary operation  defined below exchanges the colors of link  and  incident to :

\end{definition}

The binary operation  is non-commutative but associative, it can be considered as a transformation of a consistent coloring function  to another consistent coloring function  such that  and . Two adjacent variables may be eliminated by the color-exchange operation. For example, if the two colored edges are variables  and , then the color exchange  can eliminate one of these variables. On the other hand, color exchanges between two adjacent constant edges may introduce new variables. A color-exchange operation is {\it effective} if it does not increase the number of variables .

The Kempe walk of a  variable on a  path is a sequence of effective color-exchange operations performed on its interior chain. Examples of variable eliminations by Kempe walks are provided in Fig. \ref{fig:KempeWalk}. Consider the  path  shown in Fig. \ref{fig:KempeWalk} (a), the variable  can walk to another variable  by the following sequence of color exchanges performed on its interior chain:

in which two variables are eliminated by color exchanges.

In a regular graph , walks on an open  path always terminate on fictitious vertices at both ends; however, they may terminate on a vertex  with a missing  or  link if the graph  is irregular. A missing colored edge at a vertex can be regarded as a {\it don't care edge}, denoted as . At those degenerate vertices, the color-exchange operation involving a don't care edge is symbolically expressed as . The examples depicted in Fig. \ref{fig:KempeWalk} (b) and (c) show that a  variable on an open  path can be eliminated by walking to either end of the path, regardless if it is a vertex or a fictitious vertex.

\begin{figure}[t]
	\centering
	\includegraphics[scale=0.85]{e_KempeWalk}
	\caption{Variable eliminations by Kempe walks.}
	\label{fig:KempeWalk}
\end{figure}

Table \ref{tab:KempeWalkcase} summarizes all possible one-step Kempe walks of a  variable. Note that cases KW3 and KW4 only occur at the end of an open  path, and the number of variables  monotonically decreases as long as the  variable is walking on a  path.

\begin{table}[htbp]
	\centering
	{\footnotesize
		\begin{tabular}{|c |c| c| c| }
			\hline 
			Case & Next Step & Operation & Result \\
			\hline \hline
			KW1 &  & &step forward\\ \hline 
			KW2 &  & & eliminate two variables \\ \hline 
			KW3 &  & & eliminate one variable \\ \hline 
			KW4 &  & & eliminate one variable \\
			\hline		
		\end{tabular}	
		}
	\caption{One-step move of  variable on  path.}
	\label{tab:KempeWalkcase}
\end{table}

\subsection{Color Quaternion}
Define the {\it negation} of a colored variable , denoted by , as the color vector in the opposite direction of . The following color-inversion operation can change the direction of a  variable contained in a maximum  path.

\begin{definition}
\label{definition:colorinversion}
The {\it color inversion} performed on a maximum  path  exchanges color  and  on all links of .
\end{definition}

The color inversion operation requires a sequence of color exchanges involving all vertices of the interior chain of the  path. It can only apply to a maximum  path, either a  cycle or an open  path, to avoid increasing the number of variables . For consistency, we also use the notation  to denote the negation of a constant edge. With the notion of negation, the color-exchange operation of complex colors follows the same multiplication rules as quaternion.

The concept of quaternion was introduced by Hamilton in 1843 \cite{conway2003quaternions} as an extension of complex numbers. The basis elements of quaternions are customarily denoted as 1, , , and . The correspondences between quaternion multiplication and color-exchange operations are summarized in Table \ref{tab:Quaternion}. Note that the minus sign of diagonal entries in the color-exchange table indicates the necessary color inversion of the right operand due to the consistency requirement at each vertex of the color configuration. The exchange operation listed in Table \ref{tab:Quaternion} implies that if two adjacent variables have one color in common, then at least one of them can be eliminated. This is an important property in the construction of edge-coloring algorithms for eliminating variables involving more than three colors. 


\begin{table}[htbp]
	\centering
{\footnotesize
\begin{tabular}{|c|c|} \hline
\multicolumn{2}{|c|}{Correspondence} \\ \hline
\multicolumn{2}{|c|}{
} \\
\multicolumn{2}{|c|}{
} 
\\ \hline

Quaternion Multiplication & Color-exchange Operation \\ \hline
 & 
																		
																		 \\ 
\hline
\end{tabular}
}
\caption{Correspondence between quaternion multiplication and color-exchange operations.}
	\label{tab:Quaternion}
\end{table}



\section{Canonical Configurations}
Kempe walks provide the most efficient and natural way to eliminate variables. Almost all variables in an arbitrary initial color configuration can be eliminated by implementing Kempe walks. A configuration is called a {\it canonical configuration} if no variables can be further reduced by single variable Kempe walks. In a canonical configuration, it is easy to show from Lemma \ref{lemma:oddeven} that all remaining variables are contained in odd cycles, and every odd cycle only contains a single variable. The following algorithm exhaustively eliminates variables by Kempe walks.

\begin{table}[htbp]
	\centering
	{\footnotesize
			\begin{tabular}{|l|l| } \hline
			\multicolumn{2}{|c|}{Walk-on-Kempe-Path Algorithm (WKP)} \\ \hline
			{\bf Algorithm:} Walk-on-Kempe-Path (WKP)                        &  {\bf Subroutine:} Variable-Walk \\
 			{\bf Input:} an initial -edge-coloring configuration of  &  {\bf Input:} variable  \\
 			{\bf Output:} a proper -edge-coloring or a canonical            &  {\bf Output:} return true if  is eliminated;\\
			 configuration of                            &  otherwise, return false \\            
			1. {\it VariableList}  find all variables            &  9. ~{\it KempePath}  staring from one end  of \\
			2. {\bf if}  {\it VariableList} is empty {\bf then}              &  \quad ~ , say , search for  path until  \\
			\quad {\bf return} a properly colored graph                      &  \quad ~(1) it finds another variable   \\
			3. {\bf else}                                                    &  \quad ~(2) it terminates at a vertex with missing\\ 
			4. \quad {\bf for each} variable  in {\it VariableList} {\bf do}  & \quad ~  or  link\\
			5. \quad \quad {\bf if} Variable-Walk()=true            &  \quad ~(3) it returns to , thus forms a cycle \\
			6. \quad \quad {\bf then} update {\it VariableList} and {\bf goto} step 2 &  10.	{\bf if} case (3) occurred, {\bf then return} false \\
			7. \quad \quad {\bf else} continue 															 &  11. {\bf else} color exchange on interior chain of \\
			8. {\bf return} a canonical configuration                        &	\quad ~{\it KempePath} and {\bf return} true\\	
			\hline		
		\end{tabular}	
		}
	\label{algo:WKPAlgo}
\end{table}


\begin{theorem}
\label{theorem:canonical}
For graph , the algorithm WKP either returns a proper -edge-coloring or a canonical configuration. The running time of the algorithm is on the order of 
\end{theorem}

\begin{proof}
Because the subroutine {\it Variable-Walk} returns false at step 10 only when case (3) occurs, according to Lemma \ref{lemma:oddeven}, the input variable  must be the only variable contained in an odd  cycle. The algorithm returns a properly colored graph in step 2 if the {\it VariableList} is empty. Otherwise, every variable in the {\it VariableList} is contained in an odd Kempe cycle, and the algorithm returns a canonical configuration at step 8.

Next, the order of running time  can be estimated from the number of times that the subroutine {\it Variable-Walk} is executed, and the running time of the subroutine {\it Variable-Walk}. The number of times that the subroutine {\it Variable-Walk} is executed is a function of , the initial number of variables, denoted as . Since at least one variable is eliminated in an updated {\it VariableList} when the subroutine repeats in the loop (steps 4-7), then . The running time of the subroutine {\it Variable-Walk} is on the order of , because both the running time of path searching in step 9 and the number color-exchange operations performed in step 11 are bounded by the number of vertices . \qed
\end{proof}

An immediate consequence of the above theorem is the following corollary.
\begin{corollary}
For bipartite graph , the WKP algorithm always returns a proper -edge-coloring in  time.
\end{corollary}

\begin{proof}
Since there are no odd cycles in bipartite graphs, then the subroutine {\it Variable-Walk} always eliminates at least one variable and the subroutine is executed at most  times, where  is the initial number of variables. Let   be the length of the search path of the th input variable in step 9. Since the number of color exchanges and the path search time are proportional to the total path length  , the average path length in a random graph is on the order of  \cite{fronczak2004average}. Thus, the running time of the {\it WKP} algorithm for a bipartite graph   is bounded by 
 
\end{proof}
The above bound is a conservative estimate, because we did not take the trade-off between the number of variables  and the path lengths in a bipartite graph into consideration. 

\begin{figure}[htpb]
	\centering
	\includegraphics[scale=0.80]{e_Tutte}
	\caption{3-edge-colored Tutte graph.}
	\label{fig:Tutte}
\end{figure}

For non-bipartite graphs, two examples of the 3-edge-colored Tutte graphs that resulted from the {\it WKP} algorithm are depicted in Fig. \ref{fig:Tutte}, where green-colored edges and fictitious vertices are faded to highlight  cycles. The canonical configuration shown in Fig. \ref{fig:Tutte} (a) has two remaining  variables, respectively, contained in two disjoint odd  cycles. Fig. \ref{fig:Tutte} (b) shows that a properly colored Tutte graph has three even  cycles. 


\section{Walks on Directional Paths}

Despite the fact that an overwhelming number of variables in the initial color configuration can be eliminated by Kempe walks, the graph  is still not properly colored if some variables remain trapped in odd Kempe cycles. The Kempe walks are limited to color exchanges performed within alternating paths, which are fixed subgraphs  in any given color configuration. In this section, we introduce walks on directional paths, which involve more than two colors, to systematically eliminate remaining variables in a canonical configuration.  

Consider that a tagged variable   walks along a predetermined directional path. A move of    is effective if either the tagged variable can step forward, or some variables are eliminated along the way. If , where  and , is the next edge adjacent to  on the path, then it is necessary to change the colors of , either  or , such that the operation  yields an effective move of . That is, effective walks on directional paths are actually walks on dynamically changed Kempe paths. As indicated in Table \ref{tab:Quaternion} in color quaternion multiplication, any effective moves only involve three colors. Thus, there are only two useful types of color inversion on the next edge : 

Note that a color inversion operation applied to  may become invalid if the operation also involve . If a valid color conversion cannot be found, then the tagged variable  is {\it blocked}. All possible one-step non-Kempe moves of a tagged variable on a directional path in a canonical configuration are given in the Appendix.

It should be expected that blocking may occur along the way; otherwise, variables can all be eliminated by walking them to a common vertex, resulting in a proper -edge-colored graph. The Petersen graph is a well-known counterexample to show that this is impossible. In the reminder of this section, we describe a variable elimination algorithm by walks on a directional spanning tree with deflections.


\subsection{Walks on Spanning Trees with Deflections}
Intuitively, a spanning tree of the graph  can provide efficient directional paths that guide remaining variables in canonical configurations to walk to a common destination. In view of the analogy between variable edges and vectors, we can think of the paths of a spanning tree as {\it coordinates} of a vector space embedded in the graph  with the origin at the root of the tree. Presumably, if variables can freely walk on those directional paths, then they will either intercept each other on the way or eventually meet at the root. A blocked variable can be randomly deflected to another nearby directional path and resume the walking toward the root. The detailed steps of variable eliminations are listed in the {\it WST} algorithm.
\begin{table}[htbp]
	\centering
	{\footnotesize
			\begin{tabular}{|l|l| }		 \hline
			\multicolumn{2}{|c|}{Walk-on-Spanning-Tree Algorithm (WST) } \\ \hline
		  {\bf Algorithm:} Walk-on-Spanning-Tree(WST)    						 			 & {\bf Subroutine:} Walk-to-Next-Step 	\\	
			{\bf Input:} incidence graph 										  						 			 & {\bf Input:} variable , spanning tree {\it ST},	\\	
			{\bf Output:} proper -edge-coloring or claim  & color \}	\\	
			1.~ {\it ST}  construct a spanning tree of 	           		 & {\bf Output:} return true if variable containing    	\\	
			2.~ initial coloring of 																							 & is eliminated; otherwise, variable moves to  \\
			3.~ execute {\it KWP} algorithm on                                          & the next edge and returns false\\ 
			~ \quad ({\bf comment:} results in proper -edge-coloring,  or a    & 16. pick a next edge  toward the root of {\it ST}	\\
			~ \quad canonical configuration according to theorem \ref{theorem:canonical}) & 17. {\bf loop until}  succeeds	\\
			4.~ {\bf for each} color  in               &18. \quad  pick a fresh adjacent edge	\\
			5.~ \quad {\it VariableList}  all variable edges containing   & 19. {\bf end loop} \\
		  6.~ \quad {\bf if} {\it VariableList} is empty, {\bf then goto} step 4 and  & 20. {\bf if}  eliminates variable   \\ 
			~\quad \quad  continue with next color                            & ~ \quad containing  or Variable-Walk()=true  \\
			7.~ \quad {\bf else}                                                       & ~ \quad {\bf then return} true\\
			8.~ \quad \quad {\bf for each} variable  in {\it VariableList}    & ~ \quad 	({\bf comment:} execute  Variable-Walk  \\
			9.~ \quad \quad \quad {\bf loop}  times                          & ~ \quad  subroutine in WKP algorithm in case \\
			10. \quad \quad \quad \quad {\bf if} Walk-to-Next-Step()=true & ~ \quad  new Kempe paths are created)\\
			\quad \quad \quad \quad \quad ~~{\bf then} update {\it VariableList}, go to step 6 & 21. {\bf else return} false \\
			11. \quad \quad \quad  {\bf end loop}                                      & \\
			12. \quad \quad  {\bf end for each}                                        &\\
			13. \quad \quad  {\bf output}                          &\\
			14. {\bf end for each}                                                     &\\
			15. {\bf output} proper -edge-coloring of                       &\\
			
			\hline		
		\end{tabular}	
		}
	\label{tab:voice-languages}
\end{table}

The  {\it WST} algorithm is initialized by a spanning tree and an arbitrary color configuration of  with a set of  colors . In the canonical configuration generated in step 3, we firstly eliminate variables that contain color , then eliminate the remaining variables that contain color , and so on. The process is similar to the Gauss elimination for solving systems of linear equations, in which variables are eliminated one kind at a time. 

In the th iteration started at step 4, the {\it VariableList} only includes those variables containing color , sometime called -{\it variables}. In steps 8-12, each selected -variable is allowed to walk towards the root for  steps, where the parameter  is a function to be determined later in the next subsection. If the subroutine {\it Walk-to-Next-Step} returns true, indicating the elimination of a -variable, then another -variable will be selected from the {\it VariableList} and the above process is repeated. If the {\it VariableList} is empty, the algorithm goes back to step 4 and focuses on the next color . The problem is solved if all variables are eliminated and a proper -edge-coloring is reached. On the other hand, if a -variable in the th iteration fails to eliminate any -variables within   steps, then the algorithm halts in step 13 and claims that . 

In step 16 of the subroutine {\it Walk-to-Next-Step}, we first choose an adjacent edge  that is closer to the root. If the move to next edge  is blocked, then we choose another adjacent edge until it succeeds in steps 17-19. Since a blocked variable  can always be deflected to one of the two neighboring  or  links, there is no risk of running into an infinite loop in steps 17-19 even in the worst-case scenario. 

\subsection{Analysis of Randomized Algorithm}

In general, walks on carefully selected paths, such as spanning tree, are more efficient than random walks. However, the efficiency of guided walks depends on path selection, which makes the complexity analysis mathematically intractable. On the other hand, the complexity of path-independent random walks is easier to estimate, and it provides an upper bound of the complexity of all guided variable elimination methods. 

The basic idea of the random-walk algorithm is similar to that of the {\it WST} algorithm, except in step 16, the neighboring edge   of the next edge is randomly chosen. In the following analysis, we assume that, for randomly generated graph, the probability of the next edge, resulting from the execution of the subroutine {\it Walk-to-Next-Step}, is evenly distributed among all neighboring edges. If the chromatic index of the input graph is  and the parameter  in step 9 is properly chosen, we prove that the random-walk algorithm returns a proper -edge-coloring in polynomial time with a probability of at least 1/2. 

Consider a random walk that starts at a vertex  of an -vertices graph , and whenever it reaches any vertex , chooses an edge at random from those edges incident to , and traverses it. Suppose the random walk starts from a vertex  , the {\it access time} or {\it hitting time}  is the expected number of steps before vertex  is visited. An  upper bound on the access time was first obtained by Aleliunas, Karp, Lipton, Lov{\'a}sz, and Rackoff \cite{Aleliunas1979random}. Later, it was proved in \cite{lovsz1993random} that the access time is at most  for a regular graph. Let  be a proper subset of vertices and let , where , the access time  is the expected number of steps before any vertex  is visited, starting from vertex . A proof of the following bound is given in \cite{aldous2002reversible}.

\begin{lemma} 
\label{lemma:hittime}
Consider random walk on a regular graph . Let  and , then       

\end{lemma}

To be consistent with the above analysis of random walks on graphs, we consider that the random-walk algorithm is implemented on the line graph  induced from incidence graph . The set of vertices   is the set of fictitious vertices of , and an ``edge'' connecting two ``vertices''  if and only if  and   are incident to the same vertex in . Moreover, we assume, without loss of generality, that the input graph is -regular. The running time of the random walk searching algorithm is determined by the total number of moves required for finding a proper configuration. A move of a variable in the algorithm is a transformation from one configuration to another configuration. Since any simple graph  with maximum degree  is a subgraph of a -regular graph  with the same number of vertices, and those edges in  missing in  are all don't care edges. The -regular graph  admits far more color configurations than its subgraph . Thus, we are considering the worst case in our analysis. This point is verified by the experimental results described in section 5. 

Let  be the number of -variables at the beginning of the th iteration of the random-walk algorithm, corresponding to step 4 in the {\it WST} algorithm, and let  be a function defined by:

where   is a parameter representing the number of -variables in the {\it VariableList}. We show that the random-walk algorithm has the following property.

\begin{theorem} 
If input to the random-walk algorithm is a -edge-colorable graph  and the parameter in step 9 of the algorithm is , then the algorithm returns a proper -edge-coloring of  with a probability of at least 1/2. 
\end{theorem}
\begin{proof}
We first prove that 

in the th iteration of the algorithm. Let  be the set of  -variables in the {\it VariableList}. Suppose that the variable  takes  steps to hit another variable in the set . It follows from Lemma \ref{lemma:hittime} that the access time is bounded by

for . Since  are i.i.d. random variables, the probability that no variables in the set  can be eliminated is given by
 
From Markov inequality we have

The probability that all -variables can be eliminated in the th iteration of the algorithm is given by

Substituting (\ref{eq:Akfails}) and (\ref{eq:makoveieq}) into (\ref{eq:allelimiated}), we have

If , then the probability that the algorithm returns a proper -edge-coloring of  is given by

\end{proof}

\begin{theorem} 
The running time of the random-walk algorithm with  is .
\end{theorem}
\begin{proof}
The number of steps  for eliminating all -variables is bounded by
\end{proof}

Therefore, the total number of steps  after eliminating all variables is bounded by
 
The total number of variables is monotonic decreasing throughout the entire process, which implies . Then we have
 
Hence, the complexity in terms of the number of steps is bounded by 

From the proof of theorem \ref{theorem:canonical}, we know that the running time of the subroutine {\it Variable-Walk}, or the running time of each successful move, is on the order of . Therefore, the running time of random walk coloring algorithm is on the order of .\qed



\subsection{Snarks}
The main difference between solving linear equations and edge coloring is the recognizing of final state. The inconsistency of a system of linear equations can be easily identified by variable eliminations in polynomial time. But eliminating variables in a class 2 graph may run into an infinite loop. The smallest class 2 cubic graph, called {\it snark}, is Petersen graph. The 3-color canonical configuration of the Petersen graph shown in Fig. \ref{fig:snark} (a) contains two variables in two disjoint odd cycles. The two odd cycles behave the same as two parallel lines in a Euclidean space; they can never cross each other, which is the geometric interpretation of inconsistent linear equations.
 
In general, all 3-color canonical configurations of Petersen graph are isomorphic. That is, corresponding to any maximum  path   in a canonical configuration , there is a maximum  path   in another canonical configuration , such that the two subgraphs  and  are graph isomorphic \cite{west2001introduction}. This is the reason that any variable elimination procedures can never halt when all canonical configurations of graph  are isomorphic. 
\begin{figure}[htpb]
	\centering
	\includegraphics[scale=0.8]{e_snark}
	\caption{Isomorphic configurations of Petersen graph (red color is faded). (a) Canonical configuration. (b) Twin-cycle configuration,  and  are blocked. (c)  succeed. (d) Twin-cycle configuration after .}
	\label{fig:snark}
\end{figure}

The configuration shown in Fig. \ref{fig:snark} (b) is the same as that in Fig. \ref{fig:snark} (a), but the two disjoint  cycles are separated in the plane, and connected by constant  edges. In Fig. \ref{fig:snark} (b), we consider the walk on the shortest directional path  between the two variables   and  . Both moves,  and  are blocked according to the blocked move of DW1.2 described in Table \ref{tab:nonKempeWalkcase}(see the Appendix). In fact, walks on any shortest directional path will be blocked if the two variables are directly connected by a constant  edge. 

Fig. \ref{fig:snark} (c) shows that the variable  successfully walks to edge . However, the resulting configuration is the same as the previous one up to some permutation of vertices. The correspondence between the vertices in Fig. \ref{fig:snark} (b) and Fig. \ref{fig:snark} (c) is shown in Fig. \ref{fig:snark} (d). Therefore, whenever a blocked variable walks out of the odd cycle, the new configuration is isomorphic to the previous one.



The edge coloring of general graphs also faces the halting problem. In fact, any -regular graph  with an odd number of vertices is a class 2 graph. A simple example is , where  and . In a 4-color canonical configuration of , two distinct variables are mutually blocked and can never be eliminated, which corresponds to the blocked move of DW2.2 given in Table \ref{tab:nonKempeWalkcase} (see the Appendix).


\section{Experimental Study}

Experiments were conducted on randomly generated graphs and selected benchmark graphs. The results show that the performance of our algorithm on random graphs agrees with theoretical expectations, and our algorithm can efficiently solve many hard instances. All experiments ran on a Linux KVM virtual machine with one CPU core at 2.66 GHz and 512 MB memory. The coloring algorithm was implemented in C and compiled by GCC 4.4.3. Python scripts were used to generate random graph instances as well as manage the experiments.
	
\subsection{Results of Random Graphs}
All input random graphs in the testing of our coloring algorithm were generated by the graph generator provided by NetworkX\footnote{NetworkX is a Python package for the creation and manipulation of complex networks, it includes various graph generators as well.}. For regular graphs, 100 instances were randomly generated for each pair of , where degree  and the number of vertices . For irregular graphs, 100 instances were randomly generated for each pair of  where density  and . The distributions of the running time to color the edges are plotted in Figure~\ref{fig:random}. All randomly generated graphs can be properly -edge-colored by our algorithm. As shown in these figures, the running time of about 95\% of input graphs is highly predictable and quite stable. The experimental results also show that irregular graphs are generally easier to be colored than regular graphs, mainly because of the flexibility of ``coloring'' the don't care edges.
	
	\begin{figure}[htbp]
		\centering
		\subfloat[4-regular ]{\includegraphics[width=0.45\textwidth]{e_regular_4}}
		\subfloat[8-regular ]{\includegraphics[width=0.45\textwidth]{e_regular_8}}\\
		\subfloat[Irregular with ]{\includegraphics[width=0.45\textwidth]{e_irregular_2}}
		\subfloat[Irregular with ]{\includegraphics[width=0.45\textwidth]{e_irregular_4}}
		\caption{Experimental running time of edge coloring for random graphs.}
		\label{fig:random}
	\end{figure}

	
\subsection{Results of Benchmark Graphs}


For the purpose of comparisons, we use the same benchmark graphs provided in \cite{hilgemeier2003fast}, which were originally taken from CP2002 \cite{Johnson2002colorinstances}. Since all smaller graphs presented in \cite{hilgemeier2003fast} can be easily solved in a short time by heuristics and our algorithm, we only compare the results of benchmark graphs with more than 500 vertices, which are considered to be large graphs. The experiment results are listed in Table \ref{tab:benchmark_graphs} with graph qualities of each benchmark graph. The best result of each benchmark graph achieved by heuristic algorithms in \cite{hilgemeier2003fast} is compared with the performance of our algorithm. All eleven benchmark graphs considered are -edge-colorable. They were all properly -edge-colored by using our algorithm while only five of them were -edge-colored by the heuristic and evolutionary algorithms (EAs) described in \cite{hilgemeier2003fast}. In Table \ref{tab:benchmark_graphs}, the number of colors used for coloring a benchmark graph  is in {\bf bold} if it is equal to the maximum degree.

Since the performance of these algorithms depends on the particular implementation and computing environment, the absolute time listed in Table \ref{tab:benchmark_graphs} is only for reference, and does not indicate the time complexity of the algorithm. Nevertheless, these experiment results clearly reveal that our algorithm outperforms heuristic algorithms in accuracy and efficiency.


	\begin{table}[thbp]
		\centering
		\footnotesize
		\begin{tabular}{|c||c|c|c|c|c||c|c|c|c|}
			\hline
			\multicolumn{6}{|c||}{Graph Qualities} & \multicolumn{2}{c|}{Best Heuristic in \cite{hilgemeier2003fast}} & \multicolumn{2}{c|}{Our Algorithms} \\
			name & vertices & edges &  &  &  & colors & secs & colors & secs \\
			\hline\hline
			DJSC500.1 & 500 & 12458 & 24.92 & 68 & \emph{68} & 69 & 0.25 & \textbf{68} & 0.0227 \\
			ash331GPIA & 662 & 4185 & 6.32 & 23 & 23  & \textbf{23} & 0.01 & \textbf{23} & 0.0106 \\
			ash958GPIA & 1916 & 12506 & 6.53 & 24 & 24 & \textbf{24} & 0.01 & \textbf{24} & 0.0766 \\
			will199GPIA & 701 & 6772 & 9.66 & 38 & \emph{38} & 40 & 0.03 & \textbf{38} & 0.0158 \\
			4-FullIns\_4 & 690 & 6650 & 9.64 & 119 & 119 & 120 & 0.03 & \textbf{119} & 0.0114 \\
			5-FullIns\_4 & 1085 & 11395 & 10.50 & 160 & 160 & 161 & 0.09 & \textbf{160} & 0.0264 \\
			qg.order30 & 900 & 26100 & 29.00 & 58 & 58 & \textbf{58} & 0.59 & \textbf{58} & 0.2174 \\
			qg.order60 & 3600 & 212400 & 59.00 & 118 & 118 & \textbf{118} & 17.94 & \textbf{118} & 7.4265 \\
			qg.order100 & 10000 & 990000 & 99.00 & 198 & \emph{198} & 212 & 248.38 & \textbf{198} & 94.0123 \\
			wap04a & 5231 & 294902 & 56.38 & 351 & 351 & \textbf{351} & 24.98 & \textbf{351} & 3.2052 \\
			latin\_square\_10 & 900 & 202081 & 224.53 & 512 & \emph{512} & 554 & 268.85 & \textbf{512} & 2.1981 \\
			\hline
		\end{tabular}
		\caption{Performance on benchmark graphs.}
		\label{tab:benchmark_graphs}
	\end{table}

\section{Conclusions}

In this paper, edge coloring of simple graphs is solved by a variable elimination process similar to the solving of linear equations. The connections between graphs and linear equations provide cornerstones in many areas such as electric circuit theory and Markov chains. In edge coloring of simple graphs, variables are eliminated by color-exchange operations implemented on graphs. The problem is solved by a sequence of configuration transformations in the same manner as solving the puzzle of Rubik's Cube, which has a final configuration that can always be reached from any initial configuration. In the case of edge coloring of graphs, however, only -edge-colorable graphs have final configurations.

Another related problem that could be solved by color exchanges is finding the Hamiltonian cycles. A simple graph  may have more than one proper color configurations. Consider the set of all proper color configurations as the state space of a Markov chain associate with edge-colored graph . A state is Hamiltonian if it contains a two-colored Hamiltonian cycle, which can be reached by random walks on the Markov chain. In the future, the application of the algebraic method proposed in this paper to graph factors and Hamiltonian cycles could be challenging research topics.  






\bibliography{reference} \bibliographystyle{abbrv}

\section*{Appendix}

An effective one-step non-Kempe move of the tagged variable   to , where  and , requires one of the following two types of color inversion on the next edge : 

A color inversion applied to  may become invalid if the operation also involves . The following two cases are considered in a canonical configuration:

{\bf Case DW1}:  , where  and .
\begin{itemize}  
\itemsep -2pt \item {\bf (1.1)} , -type: inversion of the  cycle  shown in Fig. \ref{fig:nonKempe1} (a) that contains 
\item {\bf (1.2)} , -type: inverse the maximum  path  shown in Fig. \ref{fig:nonKempe1} (b) that contains the edge .\\
The variable  is {\it blocked} if . Note that the variable   is not blocked if , as illustrated in Fig. \ref{fig:nonKempe1} (c), the following sequence of operations can move  one step forward:
\begin{enumerate}
\itemsep -2pt \item exchange color on the interior chain from  to , hence  and .
\item 
\end{enumerate}
\end{itemize}

\begin{figure}[htpb]
	\centering
	\includegraphics[scale=0.85]{e_nonKempe1}
	\caption{Illustration of non-Kempe walk {\bf Case DW1}.}
	\label{fig:nonKempe1}
\end{figure}

{\bf Case DW2}:  , where  and .
\begin{itemize}  
\itemsep -2pt 
\item {\bf (2.1)} -type: inverse the maximum  path  shown in Fig. \ref{fig:nonKempe2} (a) that contains the vertex , or
\item {\bf (2.2)} -type: inverse the maximum  path  shown in Fig. \ref{fig:nonKempe2} (a) that contains the vertex .
\end{itemize}

The variable   is {\it blocked} if   and , as illustrated in Fig. \ref{fig:nonKempe2} (b). 



\begin{figure}[htpb]
	\centering
	\includegraphics[scale=0.85]{e_nonKempe2}
	\caption{Illustration of non-Kempe walk {\bf Case DW2}.}
	\label{fig:nonKempe2}
\end{figure}

Table \ref{tab:nonKempeWalkcase} lists all possible one-step non-Kempe moves of the tagged variable .

\begin{table}[!t]
	\centering
	{\footnotesize
		\begin{tabular}{|c|c| c| c|c| }
			\hline 
			Case & Next Step & Color Inversion& Operation & Result \\
			\hline \hline
			DW1.1 &  &  & &eliminate one variable\\ \hline	
			DW1.2 &  &  & & step forward \\ \hline 
			blocked DW1.2    &                                        &                                              & if   & blocked \\ \hline 
			DW2.1 &   &  & & eliminate one variable \\ \hline 
			DW2.2 &  &  && eliminate one variable \\ \hline	
		 blocked DW2    &                                       &                                              & if   and  & blocked \\ \hline	
		\end{tabular}
		}
	\caption{One-step non-Kempe moves of  variable on directional path.}
	\label{tab:nonKempeWalkcase}
\end{table}




\end{document}
