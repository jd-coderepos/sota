\documentclass[copyright,creativecommons]{eptcs}
\providecommand{\event}{CL\&C 2014} \usepackage{breakurl}             \usepackage{amsmath}
\usepackage{bussproofs}
\usepackage{stmaryrd}
\usepackage{cmll}
\usepackage{amssymb}
\usepackage{latexsym}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{wasysym}\usepackage{hyperref}
\usepackage{amssymb}
\usepackage{amsthm}




\def\eg{e.g., }
\def\cf{cf.  }
\def\ie{i.e., }
\def\loc{loc. cit. }
\def\wrt{w.r.t. }
\renewcommand{\b}{{}^{\bot}}


\newcommand{\vv}{\langle}
\newcommand{\ww}{\rangle}

\newcommand{\NN}{\mathbb{N}}
\newcommand{\FFF}{\mathbb{F}}
\newcommand{\FOR}[1]{\mathbf{FOR}\big(#1\big)}
\newcommand{\SUB}[1]{\mathbf{SUB}\big(#1\big)}
\newcommand{\SEQ}[1]{\mathbf{SEQ}\big(#1\big)}
\newcommand{\SQ}{\mathbf{SEQ}}
\newcommand{\CL}{\mathbf{CL}}
\newcommand{\OCC}[1]{\mathbf{OVAR}(#1)}
\newcommand{\FVAR}[1]{\mathbf{FV}\big(#1\big)}
\newcommand{\BVAR}[1]{\mathbf{BV}\big(#1\big)}
\newcommand{\FOVAR}[2]{\mathbf{FV}_{#1}\big(#2\big)}
\newcommand{\BOVAR}[2]{\mathbf{BV}_{#1}\big(#2\big)}
\newcommand{\FO}{\mathbf{FOR}}
\newcommand{\SYM}{\mathbf{LSYM}}
\newcommand{\DER}{\mathbf{DER}}
\newcommand{\LLAB}{\mathbf{LLAB}}
\newcommand{\RU}{\mathbf{RUL}}
\newcommand{\cn}{\mathsf{C}}
\newcommand{\dcn}{\overline{\mathsf{C}}}
\newcommand{\sS}{\mathsf{S}}
\newcommand{\sC}{\mathsf{C}}
\newcommand{\sQ}{\mathsf{Q}}
\newcommand{\sP}{\mathsf{P}}
\newcommand{\sN}{\mathsf{N}}
\newcommand{\sy}{\mathsf{S}}
\newcommand{\sz}{\mathsf{Z}}
\newcommand{\dsy}{\overline{\mathsf{S}}}

\newcommand{\axi}{\mathsf{ax}}

\newcommand{\arp}{\!\!\!\downharpoonright}

\newcommand{\va}[1]{\mathsf{v}_{#1}}
\newcommand{\dva}[1]{\overline{\mathsf{v}}_{#1}}

\newcommand{\inu}{ \,\rotatebox[origin=c]{90}{}\,}
\newcommand{\POS}{\mathbf{POS}}
\newcommand{\BT}{\mathbf{BIN}}
\newcommand{\FBT}{\mathbf{BIN_f}}
\newcommand{\DEC}[1]{\mathbf{DEC}\big(#1\big)}
\newcommand{\FDEC}[1]{\mathbf{DEC_f}\big(#1\big)}
\newcommand{\LBT}[1]{\mathbf{LBT}\big(#1\big)}
\newcommand{\FLBT}[1]{\mathbf{LBT_f}\big(#1\big)}
\newcommand{\eqdef}{\stackrel{\text{\tiny \textnormal{DEF}}}{=}}
\newcommand{\eqrec}{\stackrel{\text{\tiny \textnormal{REC}}}{=}}
\newcommand{\reldef}{\stackrel{\text{\tiny \textnormal{DEF}}}{\Longleftrightarrow}}
\newcommand{\pv}[1]{\mathsf{p}_{#1}}
\newcommand{\pn}[1]{\mathsf{n}_{#1}}
\newcommand{\all}[1]{\forall p_{#1}}
\newcommand{\up}[2]{{\mathord\Uparrow^{#1}\big(#2\big)}}
\newcommand{\dow}[1]{{\mathord\Downarrow^{1}\big(#1\big)}}\newcommand{\upa}[3]{{\mathord\Uparrow_{#1}^{#2}\big(#3\big)}}
\newcommand{\ex}[1]{\exists p_{#1}}
\newcommand{\tree}[1]{\mathsf{tree}\big(#1\big)}
\newcommand{\lab}[1]{\mathsf{lab}\big(#1\big)}

\newcommand{\Llab}[1]{\mathsf{lab_L}\big(#1\big)}
\newcommand{\Rlab}[1]{\mathsf{lab_R}\big(#1\big)}

\newcommand{\lb}{\big\{ \; }
\newcommand{\rb}{\; \big\}}
\newcommand{\Lb}{\Big\{ \; }
\newcommand{\Rb}{\; \Big\}}
\newcommand{\st}{ \ \ \big{|} \ \ }
\newcommand{\lp}{\langle}
\newcommand{\rp}{\rangle}
\newcommand{\roo}{\vv \, \ww}
\newcommand{\ssa}{\mathsf{a}}
\newcommand{\ssb}{\mathsf{b}}
\newcommand{\ssc}{\mathsf{c}}
\newcommand{\ssd}{\mathsf{d}}
\newcommand{\cX}{\mathcal{X}}
\newcommand{\cA}{\mathcal{A}}
\newcommand{\cB}{\mathcal{B}}
\newcommand{\cC}{\mathcal{C}}
\newcommand{\cD}{\mathcal{D}}
\newcommand{\cE}{\mathcal{E}}
\newcommand{\cF}{\mathcal{F}}
\newcommand{\cG}{\mathcal{G}}
\newcommand{\cH}{\mathcal{H}}
\newcommand{\cV}{\mathcal{V}}
\newcommand{\cL}{\mathcal{L}}
\newcommand{\cM}{\mathcal{M}}
\newcommand{\cN}{\mathcal{N}}
\newcommand{\cP}{\mathcal{P}}
\newcommand{\cQ}{\mathcal{Q}}
\newcommand{\cR}{\mathcal{R}}
\newcommand{\cW}{\mathcal{W}}
\newcommand{\cS}{\mathcal{S}}
\newcommand{\cT}{\mathcal{T}}
\newcommand{\cU}{\mathcal{U}}
\newcommand{\ccW}{\mathcal{W}}
\newcommand{\FF}{\mathbb{F}}
\newcommand{\CC}{\mathbb{C}}
\newcommand{\CD}{\mathbb{D}}
\newcommand{\CE}{\mathbb{E}}
\newcommand{\TT}{\mathbb{T}}
\newcommand{\LL}{\mathbb{L}}
\newcommand{\DD}{\mathbb{D}}
\newcommand{\PP}{\mathbb{P}}
\newcommand{\II}{\mathbb{I}}
\newcommand{\JJ}{\mathbb{J}}
\newcommand{\UU}{\mathbb{U}}
\newcommand{\SSS}{\mathbb{S}}


\newcommand{\sint}[2]{ \mathord{\, #1\, \rotatebox[origin=c]{90}{} \;#2\, }}
\newcommand{\sem}[2]{ \mathord{\, #1\, \rotatebox[origin=c]{90}{} \; #2\,}}


\newcommand{\pto}{\mathrel{\ooalign{\hfil\hfil\cr\cr}}}

\newcommand{\arro}{\Longrightarrow}
\newcommand{\arrop}{\Longrightarrow_p}

\newcommand{\arrow}{\longrightarrow}

\newcommand{\emb}{e}

\newcommand{\Dis}[1]{\big( #1 \big)}
\newcommand{\Con}[1]{\big[ #1 \big]}

\newcommand{\arpa}[2]{\textstyle\vee_{#2} \bG_{#1}}
\newcommand{\arn}[2]{\textstyle\wedge_{#2} \bG_{#1}}
\newcommand{\arpp}[2]{\textstyle\vee_{#2} \bF_{#1}}
\newcommand{\arnn}[2]{\textstyle\wedge_{#2} \bF_{#1}}
\newcommand{\arppp}[2]{\textstyle\vee_{#2} \bH_{#1}}
\newcommand{\arnnn}[2]{\textstyle\wedge_{#2} \bH_{#1}}
\newcommand{\arpppr}[2]{\textstyle\vee_{#2} \bH'_{#1}}
\newcommand{\arnnnr}[2]{\textstyle\wedge_{#2} \bH'_{#1}}

\newcommand{\Brp}[2]{\textstyle\bigsqcup_{#2} \bG_{#1}}
\newcommand{\Brn}[2]{\textstyle\bigsqcap_{#2} \bG_{#1}}
\newcommand{\Brpp}[2]{\textstyle\bigsacup_{#2} \bF_{#1}}
\newcommand{\Brnn}[2]{\textstyle\bigsqcap_{#2} \bF_{#1}}

\newcommand{\OO}{\mathbb{O}}
\newcommand{\ON}{\mathbb{ON}}
\newcommand{\MM}{\mathbb{M}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\XX}{\mathbb{X}}
\newcommand{\YY}{\mathbb{Y}}
\newcommand{\GG}{\mathbb{G}}
\newcommand{\bff}{\mathbf{f}}
\newcommand{\bs}{\mathbf{s}}
\newcommand{\bt}{\mathbf{t}}
\newcommand{\occ}{\textnormal{o}}

\newcommand{\bbl}{\pmb{\ell}}
\newcommand{\bbm}{\mathbf{m}}
\newcommand{\bbn}{\mathbf{n}}

\newcommand{\TRUE}{\pmb{t}}
\newcommand{\FALSE}{\pmb{f}}

\newcommand{\bTheta}{\pmb{\Theta}}
\newcommand{\bGamma}{\pmb{\Gamma}}
\newcommand{\bDelta}{\pmb{\Delta}}

\newcommand{\bu}{\mathbf{u}}
\newcommand{\bv}{\mathbf{v}}
\newcommand{\bw}{\mathbf{w}}
\newcommand{\lev}[1]{\mathsf{lev}(#1)}
\newcommand{\bod}[1]{\mathsf{body}(#1)}
\newcommand{\for}[2]{(#1 \phantom{i} #2)}


\newcommand{\bL}{\mathbf{L}}
\newcommand{\bA}{\mathbf{A}}
\newcommand{\bB}{\mathbf{B}}
\newcommand{\bF}{\mathbf{F}}
\newcommand{\bG}{\mathbf{G}}
\newcommand{\bH}{\mathbf{H}}
\newcommand{\bS}{\mathbf{S}}
\newcommand{\bT}{\mathbf{T}}
\newcommand{\bU}{\mathbf{U}}
\newcommand{\bW}{\mathbf{W}}
\newcommand{\bV}{\mathbf{V}}
\newcommand{\bE}{\mathbf{E}}



\newcommand{\bbp}{\mathbf{p}}
\newcommand{\bbq}{\mathbf{q}}
\newcommand{\bbr}{\mathbf{r}}

\newcommand{\bba}{\mathbf{a}}
\newcommand{\bbb}{\mathbf{b}}
\newcommand{\bbc}{\mathbf{c}}


\newcommand{\bbv}{\mathbf{v}}
\newcommand{\bbw}{\mathbf{w}}
\newcommand{\bbz}{\mathbf{z}}

\newcommand{\len}{\textnormal{lg}}
\newcommand{\ari}{\textnormal{ar}}
\newcommand{\dom}{\ensuremath{\textnormal{dom}}}
\newcommand{\ran}{\textnormal{range}}
\newcommand{\base}{\textnormal{base}}
\newcommand{\domage}{\textnormal{domage}}
\newcommand{\age}{\textnormal{age}}
\newcommand{\FV}{\textnormal{FV}}
\newcommand{\comp}{\textnormal{co}}
\newcommand{\ele}{\textnormal{EL}}
\newcommand{\form}{\textnormal{FORM}}
\newcommand{\seq}{\textnormal{SEQ}}
\newcommand{\conf}{\textnormal{CONF}}
\newcommand{\rules}{\textnormal{RULES}}
\newcommand{\deriv}{\textnormal{DER}}
\newcommand{\TES}{\textnormal{TESTS}}
\newcommand{\envir}{\textnormal{ENV}}
\newcommand{\CT}{\textnormal{IT}}
\newcommand{\intint}{\textnormal{INT}}
\newcommand{\synsyn}{\textnormal{SYNT}}

\newcommand{\alp}{\textnormal{alph}}
\newcommand{\ens}{\textnormal{set}}

\newcommand{\sR}{\mathsf{R}}
\newcommand{\sF}{\mathsf{F}}
\newcommand{\sG}{\mathsf{G}}
\newcommand{\sH}{\mathsf{H}}
\newcommand{\sL}{\mathsf{L}}
\newcommand{\fff}[3]{\sQ #1 \, #2 \, #3}

\newcommand{\arr}{\longrightarrow}
\newcommand{\arrp}{\longrightarrow_{\small\textnormal{PAR}}}
\newcommand{\red}{\ \, -\!\!\!\!\succ \ }
\newcommand{\ACT}{\mathbf{ACT}}


\newcommand{\rl}{\mathtt{l}}
\newcommand{\rr}{\mathtt{r}}
\newcommand{\rs}{\mathtt{s}}
\newcommand{\rt}{\mathtt{t}}

\newcommand{\trans}{\mathsf{TR}}

\newcommand{\rx}{\mathtt{x}}
\newcommand{\ry}{\mathtt{y}}
\newcommand{\rz}{\mathtt{z}}
\newcommand{\ru}{\mathtt{u}}
\newcommand{\rv}{\mathtt{v}}

\newcommand{\ord}[1]{\mathbf{ord}( #1)}
\newcommand{\dimm}[1]{\mathbf{dim}( #1)}
\newcommand{\derr}[1]{\mathbf{der}( #1)}
\newcommand{\nf}[1]{\mathbf{nf}( #1)}

\newcommand{\finsub}{\textbf{FINSUB}}

\newcommand{\tss}{\vec{\rt}}
\newcommand{\bx}{\underline{b}}
\newcommand{\cx}{\underline{c}}
\newcommand{\ax}{\underline{a}}


\newcommand{\axxx}{\vec{\underline{a}}}
\newcommand{\bxxx}{\vec{\underline{b}}}
\newcommand{\cxxx}{\vec{\underline{c}}}

\newcommand{\axx}{\alpha^\star}
\newcommand{\bxx}{\beta^\star}
\newcommand{\cxx}{\gamma^\star}
\newcommand{\dx}{\delta}

\newcommand{\seqq}{\mathbb{S}}

\newcommand{\lft}{\mathtt{left}}
\newcommand{\rig}{\mathtt{right}}

\newcommand{\fin}{\subseteq_{\textnormal{fin}}}
\newcommand{\finn}{\subseteq_{\leq m}}

\newcommand{\id}{\mathsf{i}}
\newcommand{\enc}{\mathsf{e}}
\newcommand{\dec}{\mathsf{d}}

\newcommand{\ov}[1]{\overline{#1}}

\newcommand{\ass}{\vec{a}}
\newcommand{\bss}{\vec{b}}
\newcommand{\css}{\vec{c}}
\newcommand{\dss}{\vec{d}}
\newcommand{\xss}{\vec{x}}

\newcommand{\fx}{\phi}
\newcommand{\dxx}{\delta^\star}

\newcommand{\fxx}{\phi^\star}

\newtheorem{theorem}{Theorem}[section]   \newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{Definition}[theorem]{Definition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{remarks}[theorem]{Remarks}
\newtheorem{example}[theorem]{Example}
\newtheorem{Example}[theorem]{Example}
\newtheorem{examples}[theorem]{Examples}
\newtheorem{examplesc}[theorem]{Examples and Counter--examples}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{Notation}[theorem]{Notation}
\newtheorem{convention}[theorem]{Convention}
\newtheorem{notation}[theorem]{Notation and Terminology}{\bfseries}{}

\newcommand{\squishlist}{
 \begin{list}{}
  { \setlength{\itemsep}{0pt}
     \setlength{\parsep}{3pt}
     \setlength{\topsep}{3pt}
     \setlength{\partopsep}{0pt}
     \setlength{\leftmargin}{1em}
     \setlength{\labelwidth}{1.5em}
     \setlength{\labelsep}{0.5em} } }
\newcommand{\squishend}{
  \end{list}  }


\newcommand{\squishlistt}{
 \begin{list}{}
  { \setlength{\itemsep}{0pt}
     \setlength{\parsep}{3pt}
     \setlength{\topsep}{3pt}
     \setlength{\partopsep}{0pt}
     \setlength{\leftmargin}{1em}
     \setlength{\labelwidth}{1.5em}
     \setlength{\labelsep}{0.3em} } }
\newcommand{\squishendd}{
  \end{list}  }

\newcommand{\sqi}{
 \begin{list}{}
  { \setlength{\itemsep}{0pt}
     \setlength{\parsep}{3pt}
     \setlength{\topsep}{3pt}
     \setlength{\partopsep}{0pt}
     \setlength{\leftmargin}{1.4em}
     \setlength{\labelwidth}{1.5em}
     \setlength{\labelsep}{0.3em} } }
\newcommand{\sqe}{
  \end{list}  }


\title{Infinitary Classical Logic: \\  Recursive Equations and  Interactive Semantics}
\author{Michele Basaldella\thanks{Supported by the ANR project ANR-2010-BLAN-021301 LOGOI.}
\institute{Universit\'e d'Aix--Marseille, CNRS, I2M, Marseille, France}
\email{michele.basaldella@gmail.com}
}
\def\titlerunning{Infinitary Classical Logic:   Recursive Equations and  Interactive Semantics}
\def\authorrunning{Michele Basaldella}
\begin{document}
\maketitle

\begin{abstract}
In  this paper, we  present an interactive semantics for derivations  in an infinitary
extension of classical logic.
The formulas of our language are possibly infinitary
 trees labeled by propositional variables and logical
connectives.
We show  that in our setting
 every recursive formula equation
has a unique solution.
As for derivations, we use an infinitary variant of
 Tait--calculus to derive sequents.

 The interactive  semantics for derivations that we introduce  in this article  is  presented as a  debate (interaction tree)
between a  test  (derivation candidate, Proponent) and
an environment    (negation of a sequent, Opponent).
We   show a
completeness theorem for derivations that we call
interactive completeness
 theorem: the interaction between  (test) and
  (environment)
does not produce errors   (\ie Proponent wins)  just in case  comes from a syntactical derivation
of  .


\end{abstract}


\section{Introduction}

In this article, we present an \emph{interactive semantics}
for \emph{derivations} | \ie formal proofs | in a proof--system
that we call \emph{infinitary classical logic}. \\

\vspace{-0.35cm}

 \noindent \textbf{Infinitary classical logic.} \
The system we consider is an infinitary extension of
\emph{Tait--calculus} \cite{Tait68},  a  sequent calculus  for \emph{classical logic}
which is often used to analyze the proof theory of classical arithmetic and its fragments.
In Tait--calculus, formulas
are  built from positive and negated propositional variables by using
disjunctions  and conjunctions 
 of arbitrary (possibly infinite)
arity. Negation  is  defined
by using a generalized form of  De Morgan's laws.
As for derivations,
sequents of formulas are derived by means of rules of
inference with a possibly infinite number of premises.
In Tait--calculus, formulas and derivations | when seen as trees |
 while not necessarily finitarily branching, are \emph{well--founded}.
In this work, we remove the assumption
of well--foundedness, and we let
formulas and derivations be
 infinitary in a broader sense. What  we get is the system that we
 call \emph{infinitary classical logic}. \\

 \vspace{-0.35cm}

 \noindent \textbf{Recursive equations.} \
 The main  reason for introducing infinitary classical logic
 is our interest in studying \emph{recursive}
 (\emph{formula}) \emph{equations} in a classical context.
 Roughly speaking, by recursive  equation we  mean  a
pair of formulas ,  that we write as  , where
 is an atom and   is a formula which depends on , \ie such that  occurs in . For instance,
 is a recursive equation.
  A \emph{solution} of a recursive equation, say ,
 is any formula  which is equal   to .
  Solutions of recursive equations are often called
 \emph{recursive types},
 and they have been studied extensively  in the literature
 (see \eg \cite{coppo,MelVou} and the references therein).
In this area,  one usually aims at finding a   mathematical space  in which the (interpretations of) equations
have a unique solution (or, at least, a canonical one).
In this paper,
we \emph{define} formulas as (possibly infinitary) labeled trees,
and we prove  existence and uniqueness of  solutions of equations
within the ``space" of the formulas.
As it turns out, if  is the solution of a recursive equation (\ie a recursive type), then 
is not  well--founded. This
fact motivates us to consider  infinitary formulas in our broader sense. \\
\vspace{-0.35cm}

 \noindent \textbf{Derivations and tests.} \
 Since formulas are infinitary, we  let derivations  be infinitary as well.
We obtain a cut--free sequent
calculus in which the
solutions of all recursive equations
are derivable (in the sense of Theorem \ref{recder}(2)).  As expected, since we deal with
ill--founded (\ie non--well--founded) derivations,
 the price to pay for this huge amount of expressivity is that our calculus
is inconsistent (in the  sense of Remark \ref{remcons}(c)).
In spite of this,  it is precisely
this notion of infinitary  derivation that we want
to study in this work.  To this aim, we introduce a semantics \emph{for derivations},  as we now explain.

Traditionally, the proof theory of classical logic is centered around the notion of  \emph{derivability}.
In this paper, we are interested in analyzing
the structure of  our infinitary \emph{derivations}. To this aim, we introduce the notion of \emph{test}.  A {test}  is a
 tree labeled by logical rules
(no sequents), and the fundamental relation between tests and derivations can be informally stated as follows: given a sequent ,
 if it is the case that by adding sequent information in an appropriate way to   we obtain  a  derivation of  , then
 we say that
  \emph{ comes from a derivation
of   \/}.
In this article,  the  \emph{syntactical} concept that we  investigate is `` comes from a derivation
of \/"  rather than the traditional one `` is derivable."
Also, note that our concept is \emph{stronger} than the usual  one:
 if  comes from a derivation of , then  is obviously derivable!

To grasp the idea behind our  concept from another  viewpoint, consider the lambda calculus. By the Curry--Howard correspondence, untyped  lambda terms can be seen as ``tests"
for  natural deduction derivations, and  `` comes from a derivation
of \/"
 can be read  as ``the untyped lambda term 
has (simple) type   in the Curry--style type assignment."\\
\vspace{-0.35cm}








 \noindent \textbf{Interactive semantics and completeness.} \
Traditionally, in order to study   the concept of derivability,   one  introduces a notion of model and eventually shows a \emph{completeness
theorem}:  the \emph{syntactical} notion of \emph{derivability}
and the \emph{semantical} notion  of \emph{validity}
(as usual, \emph{valid} means ``true in every model")
coincide. Here, we are interested in
proving a completeness theorem as well.
But, since we   replace the syntactical concept of derivability
with `` comes from a derivation
of \/", we   need to replace the semantical notion  of  validity with something else.
So, we now let our interactive semantics enter the stage.

In few words, our interactive semantics is organized as follows: first, we introduce the notion
of \emph{environment}  (the  negation  of a  sequent ) and then,
we make the test  and the environment  \emph{interact}.
More precisely, we  introduce the notion of \emph{configuration} (a pair of the form ) and define a procedure which makes configurations evolve from the initial configuration  by means of
a  transition relation. As a result, we get a tree of configurations
that we call an \emph{interaction tree}.
The procedure which determines
the interaction tree is \emph{interactive} in the sense
that it can be seen as a debate
between two players: Proponent  (the test )
and   Opponent (the environment ).
Opponent  \emph{wins the debate} if  the interaction between  and  produces
 an
\emph{error}, \ie a position
in the interaction tree generated  from   which is labeled by an  error symbol. Otherwise, Proponent \emph{wins the debate}. Our main result is the \emph{interactive completeness theorem}:
\vspace{-0.1cm}
\squishlist
\item[] {\centering
 comes from a derivation  of  \ \ \ \ \ \ if and only if \ \ \ \ \ \ \cT\neg \bS \hfill () \par}
\squishend

\noindent That is,  comes from a derivation  of  if and only if Proponent wins the debate.

The motivation for introducing our semantics comes
from our interest   in extending
the completeness theorem of ludics \cite{locus} to logics which
are not necessarily polarized fragments of linear logic.
 The completeness theorem of \cite{BT}
(called interactive completeness also there) can be stated, up to terminology and notation, in our setting as
\vspace{-0.1cm}
\squishlist
\item[] {\centering
 comes from a derivation  of  \ \ \ \ \ \ if and only if \ \ \ \ \ \ \cM \in \neg \bS\cT\cM \hfill () \par}
\squishend
The crucial point is, of course,
the RHS of ().
Here,  represents a formula of a polarized fragment of linear logic, and  and  are designs
(proof--like objects similar to our tests).
In \cite{BT}, formulas
are interpreted as sets of designs such that  , where  is the set
of designs given by:  
just in case for every , the interaction between   and 
does not produce errors (so, the RHS of () means ).
In \cite{BT},  the result of the interaction between  and    is determined by a procedure of reduction for designs which reflects the procedure of cut--elimination of the underlying logic.
Of course, it would be very nice if we could
use the same approach  in our setting!

Unfortunately, if one tries
to remove the polarities from  ludics, then one encounters
several \emph{technical} problems
related to cut--elimination (that we do not discuss here).
To the present author, the
most convenient way to cope with non--polarized logics, is to build
a new framework from the very beginning, keeping the \emph{format} of the statement () as guiding principle, the rest being | in case |  sacrificed.
The  choice here is purely personal:
the present author believes that
the significance of ludics is ultimately justified by the  completeness theorem not \eg
by the fact that   the interpretation of the logical formulas is induced by a procedure of reduction for designs.
This describes the origin of this work.

Finally, we note that
the RHS of ()
is just the  RHS of () in case  is a singleton
(and so, it can be identified with
 itself). Indeed, this is the case for the interactive semantics presented in this
paper.


As for future work, we plan to adapt our interactive  semantics to analyze derivations in
second--order propositional classical logic.\\


\vspace{-0.35cm}



 \noindent \textbf{Outline.} \  This paper is organized as follows.
In Section \ref{sec2} we recall some preliminary
notions about labeled trees.
In Section \ref{sec3} we introduce
formulas and
 recursive formula equations, 	and
we prove the existence and the uniqueness of solutions of equations.
We also define the  notion of derivation and discuss
the derivability of some sequents.
In Section \ref{sec4} we present our interactive semantics
and prove the   interactive  completeness theorem.




\section{Preliminaries: Positions and Labeled Trees} \label{sec2}

In this section, we recall  the basic  notions of
position
and labeled tree.
We also establish some  notation and terminology that
we  extensively  use in the sequel.



\begin{Definition}[Position, length]
Let  be the set of the natural numbers.
Let  be any object such that
. We call \textbf{position}
any function

which satisfies the following property:
\squishlist
\item[ (P)] \quad for some    , \
   for  all  
\ and \   for  all .
\squishend
Since ,  the natural number   above
is unique. We call it the \textbf{length} of the position and  denote it by .
The set of all  positions
is denoted by   and we
use  to range over its elements.
\hfill 
\end{Definition}



\begin{notation} Let ,  and  be positions,
and let ,  and  be sets of positions.

(1) A position   is also written  as .
In particular, we write  for the unique position of length  that we call the \emph{empty position}.

(2)
The \emph{concatenation}
of   and 
is the position  defined as follows:

\squishlist
\item[] {\centering
  k < \len(p)  k \geq \len(p)k \in \NN \par}
\squishend


\noindent In other words,
.
The operation of concatenation
is associative (\ie )
and it has  as neutral element (\ie ). Note also that .



(3) We write      if
  for some , and we
 say that  is an \emph{extension of} 
and that  is a \emph{restriction of} .
If  (resp. ), then we also say that  is a \emph{proper}
(resp. \emph{immediate}) extension of 
and that  is a  \emph{proper} (resp. \emph{immediate})  restriction of , and we write  (resp. ).


(4) We write 
for the set
  and .
Note that ,
and that , for every family  of sets
of positions.
 \hfill 
\end{notation}








\begin{Definition}[Labeled tree, domain] \label{tree}  Let  be a set.
Let  be any object such that
.
A \textbf{tree}  \textbf{labeled by}  is a function

which satisfies the following properties:
\squishlist
\item[ (T)] ;
\item[ (T)]  if  and ,  then .
\squishend
We call  the set  the \textbf{domain}
of  and we denote it as . \hfill 
\end{Definition}

Let  and  be  trees labeled by .
Since   for all
,  the tree  is completely determined
by  the values it takes on its domain.
In particular,
\squishlist
\item[] \centering{  \ \ \ \ if and only  if  \ \ \ \
 \,   and \,   for all \enspace. \par}
\squishend






\begin{notation} Let  and  be  trees labeled by , and let  .

(1)
 We say that
 is a \emph{leaf of } if  there is no  such that .







(2)
The \emph{subtree of  above } is the tree  labeled
by  defined as follows:

\squishlist
\item[] {\centering \hspace{-0.8cm}
 \ \ \ \ \ \  and \ \ \ \ \ \
  \enspace, \  for
 \enspace.  \par}
\squishend
Note that we have   and , for every   and  in   such that .

We  say that  is a \emph{subtree of} 
if , for some .
If  , then we also say that  is
 an \emph{immediate subtree of }.


(3)
 If  is a product, \ie  for some sets  and , then
 we write  and 
 for the  left and the right component
 of  respectively (\ie if
,  then
 and ).



(4) We say that  is  \emph{ill--founded}
if there exists a function 
such that
 for every . We also say that  is \emph{well--founded} if it is not ill--founded.  \hfill 
\end{notation}






\section{Infinitary Classical Logic} \label{sec3}


In this section, we present
 our infinitary version of classical logic.
In Subsection \ref{forsec}
we introduce formulas
as possibly infinitary labeled trees,
and in Subsection \ref{receqsec}
we introduce the notion of recursive formula equation and prove that
solutions of equations exist and they are unique.
Finally, in Subsection \ref{subder} we introduce the concept of derivation
and observe some basic properties.




\subsection{Formulas} \label{forsec}
We  now define the concept of   formula
and the operation of  negation.

 \begin{Definition}[Propositional variable]
 Let  and  be two distinct symbols. Let  and .
  We call  the elements of  (resp. )  \textbf{positive} (resp. \textbf{negated}) \textbf{propositional
 variables}, and
 we denote a generic element  of  (resp.  of  ) by   (resp. ).
   \hfill\end{Definition}

\begin{Definition}[Formula] \label{formula}
 Let  and  be two distinct symbols
 such that .
We call  \textbf{formula}  any tree   labeled by  which satisfies the following property:
 \squishlist
\item[ (F)]  \qquad   for every , if   ,  then   is a leaf of .
\squishend
In the sequel, we use the letters  to range over formulas.
\hfill
 \end{Definition}





\begin{notation}
Let  be a formula.

(1) Since
for every , the  subtree
 is a formula, we say that
 is a \emph{subformula of}  and that  \emph{occurs in} . If
 then we also say that
 is an \emph{immediate subformula of} .

(2) If  ,  then 
and we say that  is an \textbf{atom}.
If   (resp. ),  then we abusively   denote  by  (resp. ) and we  say that  is  a \textbf{positive} (resp. \textbf{negated}) \textbf{atom}.

(3) If , then we call   a \textbf{compound formula}. The set of natural numbers
\squishlist
\item[] \centering{ \par}
\squishend
\noindent is said to be the \textbf{arity of}  .
Let  (resp. ). Since for every  the formula  is
an immediate subformula of , we also denote  by
  
(resp.  )
and we say that   is a
\textbf{disjunctive} (resp. \textbf{conjunctive}) \textbf{formula}.
If  for some ,
 then
we also write 
(resp. )
for .
Obviously, if we write  something like ``let  be   \ldots " (resp.
), then
we mean that  is a disjunctive (resp. conjunctive)
 formula of arity  and that , for each .
Similarly, we may use the expression  (resp. ) to denote the disjunctive (resp. conjunctive) formula
 whose arity is  and such that  and
 , and so on.
 Finally, if
 | that is, ) |
then we write  (for \emph{false}) and   (for \emph{true})
rather than  (resp. ) respectively.
 \hfill


\end{notation}


 \begin{Definition}[Negation]
 Let  be a formula.
 The formula , that we call
 the \textbf{negation of} , is defined
 as follows:
 and

\squishlist
\item[]
{\centering
 {\bF}(p) = \bbv{\bF}(p) = \neg \bbv{\bF}(p) = \wedge{\bF}(p) = \veep \in \dom(\neg\bF)

\vspace{-0.55cm}
\hfill \par}
\squishend


 \end{Definition}
 We observe that the negation is involutive, \ie
, for every formula . Furthermore,
\squishlist
\item[] \centering{ \ \ \ \ and \ \ \ \
\enspace.  \par}
\squishend




 According to Definition \ref{formula},
 formulas are allowed to  be  \emph{infinitary}:
they  may have an infinite set  as  arity, and they  can also be ill--founded. In
Tait's work \cite{Tait68},  the situation is rather different:
 the arity of a compound  formula
 need not  be a subset of , and  only
well--founded formulas are  considered.

Let us  discuss our choices.
As for the first difference,
we restrict  attention to sets of natural numbers mainly for expository reasons; a pleasant  consequence of
this choice is
 that we can define  sequents as \emph{formulas}  (Definition \ref{seq})
rather than finite sets (as  in \cite{Tait68}),
multi--sets, or sequences of  formulas.
As for the second one, we have to  consider ill--founded
formulas because   solutions of   recursive equations
are formulas which \emph{always}   have this property (see Theorem \ref{recthem}).

We finally observe that
the principles of (transfinite)
induction and recursion cannot be applied to
ill--founded
formulas.  In particular, | even though we are in classical world | it is not possible to give to our formulas
a Tarskian definition of \emph{truth}. Nevertheless, in our setting it is possible to
define a reasonable notion of \emph{derivation}, as we do  in
 Subsection  \ref{subder}.

 \subsection{Recursive Formula Equations} \label{receqsec}
In this subsection, we  define the concepts of recursive equation and solution of an equation. We
 prove  that every recursive equation
has a unique solution. We also give some concrete examples.








\begin{Definition}[Substitution] \label{subdef}
Let  and  be  formulas, and let  be a
\emph{positive} atom.
We define the formula 
obtained by the \textbf{substitution of  for  and
of  for  in } as follows.
Let 
and .
We set  and

\squishlist
\item[]
{\centering
 p \in Sp = r \star q\bF(r) = \bbvp = r \star q\bF(r) = \neg \bbvp \in \dom(\bF[\bG/\bbv])

\vspace{-0.53cm}
\hfill \par}
\squishend
\end{Definition}
The correctness of the previous definition is justified by the following lemma.

\begin{lemma} \label{lemsub}
Let  \/\@ and \/\@ be as in \emph{Definition \ref{subdef}}.
\sqi
\item[\emph{(a)}]
For every \/\@ and every  \/\@, if \/\@  then  \/\@.
\item[\emph{(b)}]  Let  \/\@, and let   \/\@.
Suppose that  there are  \/\@,  \/ in \/\@ and    \/\@,   \/ in  \/\@ such that  \/\@ and \/\@.
Then, \/\@ and \/\@.

\sqe
\end{lemma}
\begin{proof}
(a)
If , then .
If , then ,  as  is a leaf of . Hence, .

(b)   Since   both  and 
are restrictions of ,  we have
 or .
 Since   and  are leaves of ,
we conclude   (and  hence ).  \end{proof}
The following proposition easily follows from our definition of substitution.

\begin{proposition} \label{subst} Let  \/\@ and \/\@ be  formulas, and
let \/\@  be a positive atom. Then:
\squishlist
\item[ \emph{(1)}]
\@ and  \/;
\item[ \emph{(2)}] \@ and
\/\@;
\item[ \emph{(3)}] \@,  if neither \/\@ nor \/\@ is a subformula of  \/\@;
\item[ \emph{(4)}]
\@. \hfill 
\squishend
\end{proposition}





\begin{Definition}[Recursive formula equation, solution] \label{receq}
A \textbf{recursive formula equation} (or  \textbf{recursive  equation}, or just \textbf{equation}) is an ordered  pair of formulas
, that we write as ,  such that: \squishlist
\item[ (R)]  is a positive atom;
\item[ (R)]   is  a compound formula;
\item[ (R)] ,  for some .
\squishend
 A \textbf{solution} of   is a formula  such that  .
\hfill 
\end{Definition}

We now discuss the previous definition.
To begin with, note that by (R),    a pair of atoms such as
 is   \emph{not} a recursive equation.
The reason to exclude such pairs is
to avoid  to consider  | which would be a trivial equation, as every formula would be a solution |
and  |
which would have  no solution at all.
Up to now, our  choices are perfectly in line with \cite{Courcelle,coppo}.
In our setting,  we also impose the additional condition   (R). The aim of this clause is to exclude pairs
of the form  where neither
 nor  actually occurs in .
The reason is  that   pairs like
the one above would be trivial equations as well:
by Proposition \ref{subst}(3),  itself would  be
 the unique solution, as   we have  for every formula .

We now turn attention to the literature on recursive types.
In this topic, the theorem which states
 existence and  uniqueness of solutions of recursive equations
is perhaps the most important result.
One usual way to prove  it is to show that  the mathematical space (in our case, it would be the set of formulas) forms a complete metric space with
respect to some  metric.  Then, the result  follows
by applying Banach's fixpoint theorem,  by using the fact
that the operation of substitution induces
a contractive map from the space  to itself  \cite{Courcelle,coppo}.
Another traditional way
 to prove that result requires to introduce  in the space  some  notion of approximation.  One then shows that   suitable  sequences of ``lower" (resp. ``upper") approximations
converge to a ``lower" (resp. ``upper") solution of the equation.
To prove the result, one eventually proves    that the two solutions coincide (see \eg \cite{MelVou,BT} and the references therein).

By contrast, in our setting we are able to prove the result in  a  direct and elementary way; our method does not require to  explicitly introduce any sort of metric or notions of approximation.
  We do  not claim that our \emph{result} is new, as there are several \emph{similar}  results in the literature.
However, we believe that
our \emph{proof} deserves some attention, as  it is quite simple and self--contained.




\begin{theorem}[Existence and uniqueness of solutions] \label{recthem}
Every recursive equation  \/\@  has
a unique solution \/\@. Furthermore,
\/\@ is ill--founded.  \end{theorem}
\begin{proof}
Let  and  be as in Definition \ref{subdef}.
First, we observe that by  condition   (R)  of Definition \ref{receq}, .
In particular, . Furthermore, by condition (R),  is non--empty.


We now remark that by definition of substitution, if  
is a solution
of the equation ,
then the set of positions  has to satisfy .
So, we are interested in studying   those sets of positions

such that  .
To this aim, we define



\squishlist
\item[] {\centering
 and  \par}
 \squishend


\noindent The key  property, that we show in  a moment, is that  is the \emph{unique} set
 such that .
This fact is known as \emph{Arden's Rule}
in the literature of formal languages
theory (see \eg \cite{manna}).

  We now  prove this fact in our setting (our proof is adapted from the one given in \cite{manna}).



\squishlist
\item[ (i)] \emph{Arden's Rule}: \ \ \   \ \  if and only if \ \
.
 \squishend
 \noindent\emph{Proof of} (i).
 If  , then   .


 To show the converse, let  be such that .
 For each   we define
.
By induction on , we show  that for every   we have
.
If , then .
Let   and assume .
We have  .
Now,
since ,  for  each    we have , as  
for every
.
Hence, if ,
then   .
Finally,
if , then  for some . Therefore, .
\qed



By (i),   the domain of \emph{any} solution of the recursive
equation  has to be .
However, this fact does not give us any hint about  how  to define  the \emph{values}
of a solution
 (\ie , for ).

To tackle this problem, we now  show the following  properties.





\squishlist
\item[ (ii)]  (a) For every , each  
 can be  factorized in a \emph{unique} way as \linebreak ,
where
   and  .

\!\! (b) \, \, \,\!\!\! For every  and every , if 
then  and  are disjoint.

 \squishend
 \noindent\emph{Proof of} (ii).
(a) By induction on .
If , then .
 By Lemma
 \ref{lemsub}(a),  for no  and
  we have . So, we set  .  If ,
then  .
By Lemma \ref{lemsub}(b),  there is a  unique  and  a unique  
such that .
By inductive hypothesis,  can be   written  as
.
Hence,     can be   factorized as , where   ,
 for every ,
and .

(b) Suppose, for a contradiction,  that  for some   there are
  and   in  such that ,
  and . Let  be the least natural number for which this fact holds.
 By Lemma \ref{lemsub}(a), we have , as for no  it is the case that
 and . Suppose now that ,
 and . Since , we can apply  Lemma \ref{lemsub}(b) and we obtain
 and .
But then, we have
  and .
This contradicts the minimality of .
 \qed





 By (ii), it follows that each  can be uniquely factorized as  , where
 is the unique  such that .
We are now ready to define .

 Let  and
let
    be the cardinality
of  . We  set
 and

\squishlist
\item[] {\centering
  m_pm_pp  \in \dom(\bG)\par}
\squishend

We now show that  is a formula and that it is a solution of .






\squishlist
\item[ (iii)]

(1) \   and if    , then .

\hspace{0.49cm}(2) \ If  ,  then   is a leaf of .

\hspace{0.49cm}(3) \ .
 \squishend
 \noindent\emph{Proof of} (iii).
(1)  .
If  then  either  and ,
or , for 
and  . In both cases, . Thus,   .

(2) Let  . As , we have  just in case .
Since     is a leaf of  and ,  no proper extension of  is in .
So,  is a leaf of .


(3)  By (i), .
Let  .
If , then   and .
Suppose now that .
 Let   be . By definition,  (see the proof of (ii)(a)).
If  , then  and
 .
If  , then  and
 . \qed


 We now prove that  is the unique solution of the recursive equation  .


\squishlist
\item[ (iv)] If   is a formula such that , then .
 \squishend
 \noindent\emph{Proof of} (iv).
By (i), .  We now prove that for every , for each  we have
 .
We reason by induction on .
If , then . Hence,
.
Suppose now that .
Let   be . By inductive hypothesis,  .
  If  , then .
 If  , then .
 \qed

Finally, we show that  is ill--founded.



\squishlist
\item[ (v)] There exists a function  such that
, for every .
 \squishend



 \noindent\emph{Proof of} (v).
Recall that   is non--empty and that . Let .
Define
\   and , for each .
As ,  we have  
and , for every .
So, .
Thus, the function  given by:  for every ,
has the required property. \qed



The proof of Theorem \ref{recthem} is now complete.
\end{proof}

 \begin{Example} \label{A to A}
Let us consider the recursive equations
\squishlist
\item[] {\centering  (1) \ \enspace, \ \  \qquad
(2) \ \quad \   and  \quad \  (3) \ \enspace. \par}
\squishend

\noindent Let ,  and  be the solutions of the equations (1), (2) and (3) respectively.
We have  , where  for all .
Moreover,  for , we have ,
  and
 \squishlist
\item[] {\centering
 \{ k \st p(k) = 0 \}\{ k \st p(k) = 0 \} \par}
\squishend
In our setting,   can be used to represent   the equation ``" which is a well--known  example of equation of \emph{mixed variance} in the literature of recursive types (see \eg \cite{MelVou}).
\hfill
 \end{Example}




\subsection{Derivations} \label{subder}
In this subsection, we introduce the notions of sequent and derivation. We also
show some  sequents which are derivable in our framework.
In this work, we   define sequents as special disjunctive formulas.  We think that this
choice  is convenient, as it  makes clearer the ``duality"
between sequents and environments (Definition \ref{envir}(2)).
Derivations are defined to be   trees labeled by sequents and rules. Our definition of derivation is
actually very similar to that of
 \emph{pre--proof} in \cite{PTLC} (very roughly, a pre--proof is a
 not necessarily well--founded
 derivation in
a sequent calculus for
classical logic with the
 --rule).




 \begin{Definition}[Sequent] \label{seq}
We call   \textbf{sequent}   any  \emph{disjunctive} formula  whose arity is , for some .
The set of all sequents is denoted by .
  \hfill 
\end{Definition}


\begin{Notation} \label{not}
 Let  be a sequent.  Let   be a formula. We write
,  and sometimes also ,
 for the sequent  of arity
  defined as follows:  and
\squishlist
\item[] {\centering


 p \in \dom(\bS)p = \vv n \ww \star qp  \in \dom(\bT)
 \par}
\squishend
 In particular, if   then   (recall that  is an abbreviation for ).\hfill 
\end{Notation}



 \begin{Definition}[Rule]
 A \textbf{rule}  is either an \emph{axiom
 rule} or a \emph{disjunctive rule} or a \emph{conjunctive rule}.
 \squishlist
 \item An \textbf{axiom rule} is an ordered triple , where   ,  and .
 \item
A \textbf{disjunctive rule} is an ordered triple  , where  and .
 \item A \textbf{conjunctive rule} is a ordered pair  , where .
  \squishend
  The set of all rules is denoted by .
    \hfill 
 \end{Definition}





 \begin{Definition}[Derivation] \label{deri}
 A \textbf{derivation}  is a tree  labeled by

such that
  for each 
 one of the following conditions  (),  () and  () holds.

\vspace{0.2cm}


{ \centering
\begin{tabular}{cc}
\!\!() \!\! : \!\! T(p) = \big( \vee[\bF_0,\ldots, \bF_{n-1}] \ , \ \Dis{\bbv, k,\ell} \big)k< n\ell < n\bF_k = \bbv\bF_\ell = \neg \bbvpT
&
\!\!() \!\! : \!\! T(p) = \big(  \vee[\bF_0,\ldots, \bF_{n-1}] \ , \ \Dis{\vee, k,i_0} \big)k < n\bF_k = \arpa{\vv i \ww}{I}i_0 \in Ip \star \vv i \ww \in\dom(T)i = i_0T_\sL(p \star \vv i_0 \ww) = \ \vee[\bF_0,\ldots, \bF_{n-1},\bG_{\vv i_0 \ww}]
\end{tabular}
\vspace{0.3cm}
\par}


{ \centering
\!\!() \!\! : \!\! T(p) = \big(  \vee[\bF_0,\ldots, \bF_{n-1}] \ , \ \Dis{\wedge, k} \big)k < n\bF_k = \arn{\vv i \ww}{I}p \star \vv i \ww \in\dom(T)i \in IT_\sL(p \star \vv i \ww) = \ \vee[\bF_0,\ldots, \bF_{n-1}, \bG_{\vv i \ww}] i \in I
\vspace{0.2cm}

\par}


\noindent  In the sequel, we use    to range over derivations.
  We say that  \textbf{ is a derivation of } if , and we say
that    \textbf{is derivable} if there exists
a derivation  of it.
\hfill
\end{Definition}


 \begin{remark} \label{remsubform}  Let   be a derivation.
Let ,
 and  let ,
for some .

(a) \emph{The subformula property.} \ \!
For every   , there exists  such that   is a subformula
 of   .

(b) \emph{Leaves.} \ \! The position  is a leaf of 
if and only if   is as in  ()
of Definition \ref{deri}, or
 is as in  ()
of Definition \ref{deri} and
 (recall that  is an abbreviation for ).

(c) \emph{Rules.} \ \! The rule  and  the sequent  completely determine the sequent ,
for each  which immediately extends
 in . In other words, if  and  are two derivations of the same sequent ,  then
   and  for all  together imply   . \hfill
 \end{remark}
Using  a more traditional notation for  derivations in the sequent calculus,  conditions (),   () and ()
of Definition \ref{deri} can be respectively  written as follows:

\vspace{0.25cm}

{\small

{\centering
\begin{tabular}{ccc}

\AxiomC{}
\RightLabel{()}
\UnaryInfC{}
\DisplayProof

&




  \def\fCenter{ \vdash \ \ }
\Axiom
\RightLabel{()}
\UnaryInf
\DisplayProof

&



  \def\fCenter{ \vdash \ \ }
\Axiom
\RightLabel{()}
\UnaryInf
\DisplayProof

\end{tabular}
\vspace{0.25cm}

\par}

}

\noindent where   in  (),   in  (), and  in  () the expression
`` for all " means that
 there is one premise for each  .
In particular, if , then
there is no premise above the conclusion.

The \emph{rules of inference} displayed above essentially correspond
to the \emph{normal rules} of Tait--calculus \cite{Tait68}. But in contrast with \cite{Tait68},  in our setting ill--founded derivations
  are permitted. As a consequence, we have the following results.



 \begin{theorem} \label{propder} \label{recder} \hfill
 \sqi
 \item[\emph{(1)}]
 Let \/\@ be a sequent. Suppose that for some  \/\@  either
 \/\@ is a disjunctive formula whose arity is not the empty set,  or  \/\@ is a conjunctive formula.
Then,  \/\@ is derivable.
\item[\emph{(2)}] Let  \/\@ be a recursive equation, and
let \/\@ be its  unique solution.
Then, the sequent
\/\@ is
derivable.
\sqe
 \end{theorem}
 \begin{proof} (1)
Let , for some
. Let
. We define a tree  labeled by
 as \linebreak

\vspace{-0.45cm}
\noindent follows:
 for all  and



\squishlist
\item[] {\centering
 p = \roop = q \star \vv i_0\ww p \in \dom(T) \par}
\squishend
\noindent
Suppose now that .  We analogously define a tree  labeled by
 as follows: \linebreak

 \vspace{-0.45cm}
\noindent
 for all  and


\squishlist
\item[] {\centering
 p = \roop = q \star \vv i \ww p \in \dom(U) \par}
\squishend
Since each  (resp. )
satisfies condition
  (resp. ) of Definition \ref{deri},
  (resp. )   is a derivation of .


(2) By condition (R) of Definition \ref{receq}, either  or . Furthermore, by
 (R) we have that
, as  or  (or both)
must occur in .
For ,  we have, by  Proposition \ref{subst}(2), that
  . Hence,  is a compound formula whose arity is .
Then, we can apply (1) above to 
and obtain the desired result.
     \end{proof}

\begin{remark} \label{remcons} Let  , , and  be the formulas defined   in Example \ref{A to A}.

(a) By  Theorem \ref{recder}(2),  for each 
the sequent 
 is derivable.
But, since the  subformulas of   are neither atoms nor equal to ,       it follows from Remark \ref{remsubform}(a)(b) that
every derivation of   has to be ill--founded.

(b)  There are several sequents which are not derivable. For instance,
 , , \ldots. Also, for each atom   the sequents  ,
 , ,
 \ldots are not derivable.

(c) Even though  is not derivable, our system is \emph{inconsistent}
in the sense that there is some formula  such that
both   and  are derivable.
For, consider   and , and note that . By (a) above,  and
 
are derivable.

(d) The \emph{cut--rule} is \emph{not admissible} in our
system, \ie it is not true that
\squishlist
\item[ (CUT)] \ for every sequent  and every formula ,
if 
and  are  derivable, then so is
.
\squishend
For, let  be .
By (c) above, both    and
and 
are derivable. But by (b) above,  is not derivable.
 \hfill
\end{remark}





\section{Interactive Semantics} \label{sec4}

We now present our interactive semantics
for derivations in infinitary classical logic.

Let  be a sequent.
Recall that in this paper
we are not interested
in studying the concept of derivability, \ie  `` is derivable." Rather,
the concept that we want to  analyze is    ``the test  comes from a derivation
of \/", in the sense we now make clear.
Before giving the formal definitions, we explain at an informal  level the
 three basic notions of our semantics:
\emph{test}, \emph{environment} and \emph{interaction tree}. \\



\vspace{-3.5mm}

\noindent \textbf{Tests}. \  In this paper,  a test is nothing but
 a tree  labeled by  such that
. This is actually the official definition of test  (that we repeat, for convenience, in the next subsection). Tests have to be thought as ``derivation candidates" for a derivation   of a sequent
. More precisely,  let the \emph{skeleton of the derivation  of } be
the tree  labeled by  whose domain is equal to  and such that , for all .  In other words,
the skeleton is just the object obtained
from a derivation  by erasing all the sequent information.
Then,
we say that \emph{the test  comes from the derivation  of }
(or that  is a ``successful candidate")
if   the skeleton of  is ``contained"
into  (see Definition \ref{interpretation} for the precise definition).
In general,  it is not  always the case that a test
contains the skeleton of some derivation.
In this paper, tests have to be understood as  \emph{untyped} objects in the sense that they are not necessarily related to formulas and sequents:
it may be the case that a test comes from a single derivation, or several derivations, or no derivation at all. The semantics we  define gives us a precise answer to the problem of determining when a test comes from a derivation or not.

 Finally, we also point out that the definition of ``to come from"
is \emph{syntactical}, as we use
the syntactical notions of derivation and skeleton  to define it.\\



\vspace{-3.5mm}

\noindent \textbf{Environments and interaction trees}. \
Technically speaking, an environment is just
the negation  of a sequent  (in particular, it is not a sequent).  In our setting,  tests and environments
\emph{interact}.
To be more specific, a pair
, called
\emph{configuration},
uniquely determines a tree which is labeled by configurations of the previous kind, or by  an error symbol . We call this tree the \emph{interaction tree of} .
The construction of the interaction tree is \emph{dynamical} in the sense that it can be seen as the (possibly
infinitary) ``unfolding" of the transition relation |  of a suitable  transition system |  starting from  . The procedure which determines the interaction tree has also a very simple and
natural  \emph{game interpretation}.
Now, recall that the statement of the \emph{interactive completeness theorem} is:
\vspace{-0.00cm}
\squishlist
\item[] {\centering
 comes from a derivation  of  \ \ \ \ \ \ if and only if \ \ \ \ \ \ \cT\neg \bS \par}
\squishend


\noindent We can now intuitively explain
how errors
come into play:
if for some position  in the domain of the interaction tree of  it is the case that the label is
, then we  say that \emph{the interaction between the test  and the environment  produces an error}.
 Observe that the notion of ``to produce an error" is
\emph{semantical} in the sense that we use the interaction
tree to determine the eventual presence of errors. In particular, we make no use of  the syntactical notions of derivation and skeleton. \\









\vspace{-0.3cm}


We now develop the technical part of this section.
In Subsection \ref{sec trees} we give the formal definitions
of test, environment and interaction tree. We also give
a game theoretical interpretation  of our   interaction trees.
 In Subsection \ref{compsec} we  prove the interactive completeness theorem.




\subsection{Interaction trees} \label{sec trees}


\begin{Definition}[Test, environment, configuration]
\label{envir} \hfill
\sqi
\item[(1)] A  \textbf{test} is a tree   labeled by  such that . The set of all tests is denoted by , and
we use   to denote its elements.
\item[(2)] We call \textbf{environment}   any formula
which is the negation of a sequent. That is, an environment
is a  \emph{conjunctive} formula
whose arity is , for some
.
The set of  all environments is denoted by .
\item[(3)] We define the set  of  \textbf{configurations} as
\squishlist
\item[]{ \centering
,
\par}
\squishend
\noindent where  (pronounced ``error")    is any object such that  .
In the sequel, we use the letters  to denote configurations.\hfill
\sqe

\end{Definition}





\begin{Notation}
Let 
 be an environment.
Let     be a formula. In the sequel, we write
,   and when convenient also   ,
 for the environment
  of arity . Recall that the sequent  is defined in
Notation \ref{not}.
 \hfill 

\end{Notation}







 \begin{Definition}[Interaction tree, production of errors] \label{comptree}
 Let  be a configuration.
The  \textbf{interaction tree of }
is the tree  labeled by 
 defined as follows.

\squishlist
\item[ (C)]  ,  and .

\item[ (C)]  Suppose that  has been
 defined. We define the immediate  extensions of
  in   \linebreak      and their labels by cases as follows:


\squishlist

\item[ ()] \hspace{-0.11cm}If , then  is  a leaf of .

\item[ ()] \hspace{-0.07cm}If  ,
  ,  , ,  and , then  \\
 is a leaf of .


\item[ ()] If  ,
, ,  and , then \linebreak
  if and only if ,
and .

\item[ ()] If   ,
,   and , then   \linebreak
 if and only if ,
and   for each .
\item [ ()]  \hspace{-0.20cm} In all the other cases,  if and only if   and
 .
\squishend
\squishend
We denote the interaction tree of a configuration
 as .

Let  be a test,  and let  be an environment.
We say that the \textbf{the interaction between  and  does not produce errors}
if
\squishlist
\item[] \centering{there is \emph{no} 
such that \,\!  \enspace.

\vspace{-0.57cm}
\hfill \par}
\squishend
\end{Definition}



We now discuss the previous bunch of definitions.\\

\vspace{-0.35cm}

\noindent \textbf{Global view of the interaction tree: interaction and transition systems}. \
The procedure which determines the interaction tree has to be read as follows. First, we have
 , by (C).
From  and its label,
we calculate, by using the clauses in (C), all the positions
of length one in  . Now,
we do the same thing for
each position
of length one
 in , and we  obtain
 all the positions
of length two in , and so on. This procedure might  not stop
and produce an ill--founded tree.



We call     \emph{interaction} tree
because (in the case )
when a test and an environment are combined into a configuration, they \emph{interact}. Namely, they evolve into  new configurations according to
the clauses given in Definition \ref{comptree}.
 Furthermore, given a configuration  its interaction tree  is defined
\emph{dynamically}: at each step one checks which clause
of Definition \ref{comptree} holds and then (possibly) proceeds to the
next step.  Indeed, one
can recognize the computational structure of \emph{transition system}  here: 
is the set of   \emph{states} and
the \emph{transition relation}  is
given according to the clauses
in (C).
Here,   the configuration   represents a final state.
Thus, the interaction tree of  can be seen
 as the (possibly
infinitary) ``unfolding" of the  transition relation  starting from the state  .\\

\vspace{-0.35cm}

\noindent \textbf{Local view of the interaction tree: a game theoretical interpretation}. \
At first view,   clauses (C)(),
(C)() and (C)()
 of Definition \ref{comptree}
seem to be just  the ``dual"  of   conditions
(), () and ()
of
Definition \ref{deri} respectively.
This is admittedly true,  but notice that
in Definition \ref{deri} we use (), () and ()  to \emph{define} the notion of derivation, whereas here
 we use (C)(),
(C)() and (C)() to (possibly) \emph{find errors}. Furthermore,
there is nothing which   corresponds to  clauses
(C)() and (C)() in Definition \ref{deri}. On the other hand,
these clauses are  crucial to the aim of finding errors.
Hence, even though derivations and interaction trees
seem to be similar,
they have  different purposes.

We can now  give a very simple and natural game interpretation
to the objects introduced so far. Specifically,
the interaction tree can be seen as   a  \emph{debate} between two players:    (Proponent) and  (Opponent). The moves of the game
are determined by   the clauses   given in Definition \ref{comptree}.
In our game,
 is always in charge of tests,
whereas
 is always in charge of environments.
Given a configuration ,
 (possibly)  makes a question and 
answers to the question by  producing a set of configurations. Then, for each  configuration produced by  ,
 (possibly) makes a question and 
answers to the question by  producing a set of configurations,  and so on.
The debate starts with a given configuration  different from . Then, for each configuration  given or  produced so far, the two players
 behave as follows.
\sqi
\item[(G)] \ \  If , then   does not make any question and   does not produce any configuration.

\sqe
Let  . Then,  asks 
and     answers as follows.
\sqi
\item[ (G)]  If    asks  , then
  checks the formulas  and  .
If  and , then   
does \linebreak   not
produce any configuration.
Otherwise,

produces .

\item[ (G)]  If    asks  , then
   checks the formula .
If   and ,
then  
 produces \linebreak  
.
Otherwise,

produces .

\item[ (G)]  If    asks  , then
   checks the formula .
If  ,
then  
 produces \linebreak  
, for each .
Otherwise,

produces .




  \sqe
Of course, up to terminology and the rearrangement of clause ()
inside the other clauses, this is  just a more informal reformulation  of the clauses given in  Definition \ref{comptree}.  We say that  \emph{wins the debate starting
from } if at some stage it is able to exhibit
an error, \ie to produce  the configuration
. Otherwise, we say that  \emph{wins the debate starting
from }.
With this game theoretical intuition in mind,
the statement of the interactive completeness theorem
can be reformulated as follows:   wins
the debate starting
from   just in case
 comes from a derivation  of .
\\

\vspace{-0.35cm}

\noindent \textbf{Special cuts.} \ A configuration of the form
 can also be understood as a \emph{special cut}, \ie as a  cut
  of the following special form
(here we use a more traditional notation)

\vspace{-1.5mm}

{\small

{\centering
\AxiomC{}
\noLine
\UnaryInfC{}
\AxiomC{}
\noLine
\UnaryInfC{}

\AxiomC{\!\!\!\!\!\!\!\!\!\!\!\!}

\AxiomC{}
\noLine
\UnaryInfC{}
\RightLabel{cut}
\QuaternaryInfC{}
\DisplayProof
\par} }

\vspace{2.0mm}

\noindent where we simultaneously  cut  with 
for each . Here, the derivation  (in the sense of the previous section)  corresponds to the tests  and, for each formula   of our logic, the derivation  is  given by:
 if  is an atom, then   has no premises; if  or
,  then there is one premise    for each   
(thus,  is not a derivation in the sense of the previous section, and it is akin to a derivation of the subformula tree of ).
In addition,
 the formulas   and  need not be the negation of  each other.
Hence, \emph{special cuts
are not cuts in the ordinary sense}, and  in particular,
special cuts have nothing to do with the notion of cut discussed in the previous section.

Under this interpretation, an environment  can be naturally understood as a \emph{conjunction} of formulas, as it represents a sequence  of (unary) traditional sequents.
With this picture in mind, the clauses given in
 Definition \ref{comptree} transform a  special cut
 into a set of special cuts or . So, they work as  steps of reduction for a procedure of cut--elimination
 for special cuts.
For instance,  in the case of  (C)()
we  obtain after one step of reduction (here  is any disjunctive formula such that   )

\vspace{-1.5mm}

{\small
{\centering
\AxiomC{}
\noLine
\UnaryInfC{}
\AxiomC{}
\noLine
\UnaryInfC{ \quad }

\AxiomC{}
\noLine
\UnaryInfC{\quad }

\AxiomC{}
\noLine
\UnaryInfC{}

\AxiomC{}
\noLine
\UnaryInfC{}
\RightLabel{cut}
\QuinaryInfC{}

\DisplayProof \par} }

\vspace{0.25cm}

\noindent which is again a
special cut.
The present discussion on special cuts is quite
informal, but the  point here is to develop
another intuition about the  concepts  introduced so far.


\subsection{Interactive completeness} \label{compsec}
In this section, we prove the interactive completeness theorem. First,
we give the formal definition of ``to come from",
and then we move to the statement and the proof of the theorem.





 \begin{Definition}[To come from] \label{interpretation} Let  be a sequent, and let  be a derivation of .
Let  be a test. We say that 
\textbf{comes from the derivation  of }
if \squishlist
\item[] \centering{\enspace,   \ for every \enspace.

\vspace{-0.57cm}
\hfill \par}

\squishend


 \end{Definition}


In other words,  comes from the derivation  of  if  ``contains" the \emph{skeleton} of , in the  sense of the beginning of this section.

 \begin{theorem}[Interactive completeness]
 Let  \/\@ be a sequent, and let  \/\@ be a test.
 Then, the following claims are equivalent.
 \squishlist
 \item[ \emph{(1)}] The test \/\@ comes from a derivation  of  \/\@.
 \item[ \emph{(2)}] The interaction between \/\@ and  \/\@
 does not produce errors.
 \squishend
  \end{theorem}



 \begin{proof} \ (1) implies (2) \ \!\! :   \ \!\!
 Let   be a derivation of , and assume that  comes from . Let  be .  To show that the interaction between \/\@ and  \/\@
 does not produce errors,
 we   now prove that
 every
 satisfies
one of the following (mutually exclusive) conditions:
\squishlist
\item[ (P)] : \ ,

and .
\item[ (P)] : \    and
.
\squishend
 We proceed  by induction on the length of .
The position  satisfies (P),
as ,   and .
Consider now an  arbitrary position .
Assume that  satisfies (P) or (P).
We  show that for each , the position
 satisfies (P) or (P).
If  satisfies (P), then
 and
, as  and 
 are labeled trees. Hence,
  satisfies (P).
Otherwise,   satisfies   (P). Since
 , we have  , as  comes from  by assumption.
 Moreover,
since  is a derivation,   satisfies
one of
 conditions  (), () and () of Definition
\ref{deri}. Let
 be  ,
so that .
 We now consider   the following subcases.




(i) If  ,
then  satisfies
 () of Definition
\ref{deri}.
 Hence, , ,
 ,
  and
   is a leaf of . Since   and
 ,   
is as in (C)()
 of Definition \ref{comptree}.  Hence,
 is  a  leaf of
  . In particular,
 satisfies (P).



(ii) If , then  
satisfies   () of Definition
\ref{deri}. This means that ,
 , ,
 only  immediately extends  in ,
 and .
Since    and ,     
is as in (C)()
 of Definition \ref{comptree}. Hence, only  immediately extends 
 and . So,  satisfies (P) if , and   satisfies (P) otherwise.



 (iii) Finally, if  ,
then  satisfies
 () of Definition
\ref{deri}. So,
 ,
 ,
 immediately extends  in  if and only if ,
 and 
  for each .
Since   ,  
is as in   (C)()
 of Definition \ref{comptree}.  Thus,
 immediately extends  in   if and only if

 and , for every .
Hence,  satisfies (P) if , and   satisfies (P) otherwise.



This proves that  each  satisfies
either  (P) or (P).
From  this fact, it follows that
 for all .
In particular, there  is no 
such that , \ie the interaction between \/\@ and  \/\@
 does not produce errors.

\vspace{0.05cm}

  (2) implies (1)   :      Let  be  and assume that (2) holds.
This means that each position 
 is labeled by a member of .  In  such a situation, it immediately  follows from the definition of interaction tree that     for each
  we have
, for some
 .
We  define a tree  labeled  as follows:  and  \squishlist
\item[] {\centering
 \enspace, \ \
 for    with   \enspace.
 \par}

\squishend
We now show that  is a derivation. To do this,
we need to check that for each 
one of    conditions  (),  () and  () of Definition
\ref{deri} holds.
Let   and let  be , so that
. There are the following cases to consider.



(1) Suppose that .
Since the interaction between \/\@ and  \/\@
 does not produce errors, the configuration

is as  in (C)()
 of Definition \ref{comptree}. This means that
 , ,
 ,
  and
   is a leaf of .  Since  and
 ,  and since   is  a leaf of , the position
  satisfies   () of Definition
\ref{deri}.



(2) Suppose that . Since the interaction between \/\@ and  \/\@
 does not produce errors,  the situation is as in
 (C)()
 of Definition \ref{comptree}. Hence,
 ,
 , ,
 only  immediately extends  in ,
 and   .
  Since  ,
  ,
 only  immediately extends  in 
 and   , we conclude that
 () of Definition
\ref{deri} holds for the position .



(3) Finally, suppose that .
Since the interaction between \/\@ and  \/\@
 does not produce errors, the configuration
 is as in  (C)()
 of Definition \ref{comptree}. Thus,
 ,
 ,
 immediately extends  in  if and only ,
 and   
 for every .
  Since ,
 immediately extends  in  if only if ,
    for every , we conclude that
 the position
  satisfies   () of Definition
\ref{deri}.



Hence,  is a derivation of .
By construction,  for all
. Therefore, the test \/\@ comes from a derivation of \/\@, namely \/\@. \end{proof}









\nocite{*}
\bibliographystyle{eptcs}
\bibliography{basaldellabibliography}



\end{document} 