\documentclass[11pt,letter]{article}

\usepackage{microtype}
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{xspace,enumerate,enumitem,boxedminipage,fullpage}
\usepackage{algorithm,algorithmic}
\usepackage{mathtools,amsmath,amssymb,amsfonts}
\usepackage{color,colortbl}

\usepackage{rotating}
\usepackage[mathscr]{euscript}		



\setlist[description]{listparindent=\parindent,leftmargin=0em,font=\textbf,itemsep=0.5em}


\usepackage{perpage}
\MakePerPage{footnote}

\newcommand{\ie}{\emph{i.e.}}
\newcommand{\eg}{\emph{e.g.}}
\newcommand{\etal}{\emph{et al.}}
\newcommand{\alg}[1]{\mbox{\textsf{#1}}}
\newcommand{\func}[1]{\mbox{}}
\newcommand{\simu}[1]{\mbox{}}
\newcommand{\view}[1]{\textsf{{\small VIEW}}_{#1}}
\newcommand{\mask}[1]{\widehat{#1}}



\newcommand{\e}{\mathrm{e}}
\newcommand{\F}{\mathbb{F}}

\DeclareMathOperator{\polylog}{polylog}
\DeclareMathOperator{\poly}{poly}
\DeclareMathOperator*{\Prob}{Prob}
\floatname{algorithm}{Protocol}

\let\openbox\relax
\usepackage{amsthm}
\newtheoremstyle{mytheoremstyle}
	{\topsep}                    {\topsep}                    {\itshape}                   {}                           {\bfseries}                   {.}                          {0.5em}                       {}  

\theoremstyle{mytheoremstyle}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{definition}{Definition}
\floatname{algorithm}{Protocol}

\let\savedCaption=\caption
\renewcommand*{\caption}[1]{\savedCaption[#1]{~#1}}  

\usepackage{caption}

\newcommand{\algfont}{}



\newcommand{\fbad}{1/8\xspace}
\newcommand{\fbadq}{\xspace}
\newcommand{\fgoodq}{7/8\xspace}
\newcommand{\fgoodqq}{\xspace}
\newcommand{\thresh}{5/8\xspace}
\newcommand{\threshq}{\xspace}
\newcommand{\dcl}{D}
\newcommand{\bins}{k}
\newcommand{\flag}{\xspace}
\newcommand{\flags}{{\flag}s\xspace}
\newcommand{\countm}{\xspace}
\newcommand{\done}{\xspace}
\newcommand{\oneinput}{-input\xspace}
\newcommand{\oneinputs}{-inputs\xspace}

\newcommand{\vssSh}{\textsf{VSS-Share}\xspace}
\newcommand{\vssRec}{\textsf{VSS-Reconst}\xspace}
\newcommand{\hw}{\mbox{\textsf{CMPC}}\xspace}
\newcommand{\ba}{\mbox{\textsf{BA}}\xspace}

\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
\newcommand{\tc}{\mbox{\textsf{-Counter}}\xspace}
\newcommand{\icPlayer}{\textsf{IC-Party}\xspace}
\newcommand{\icInput}{\textsf{IC-Input}\xspace}
\newcommand{\ce}{\textsf{Circuit-Eval}\xspace}
\newcommand{\outrec}{\textsf{Output-Rec}\xspace}
\newcommand{\outprop}{\textsf{Output-Prop}\xspace}

\newcommand{\maj}{\thresh-\textsc{Majority}\xspace}
\newcommand{\outnode}{output node}
\newcommand{\outval}{\langle\mathsf{O}\rangle\xspace}
\newcommand{\ct}{count tree\xspace}

\DeclareMathOperator{\depth}{\mathsf{depth}}
\DeclareMathOperator{\outnodemath}{\text{output-node}}

\newcommand{\toplev}{\ell^*}
\newcommand{\leaves}[1]{leaves(#1)}
\newcommand{\tree}[1]{T(#1)}
\newcommand{\lev}{\ell}

\newcommand{\Sendhop}{\textsf{Sendhop}}
\newcommand{\Send}{\textsf{Send}}
\newcommand{\MessagePass}{\textsf{MessagePass}}

\newcommand{\const}{12} \newcommand{\ctwo}{4}
\newcommand{\cthree}{4}
\newcommand{\cfour}{5} \newcommand{\heavyba}{{byzantine agreement}\xspace}
\newcommand{\lst}{\ensuremath{\mathsf{List}}}
\newenvironment{indentpar}[1]{\begin{list}{}{\setlength{\leftmargin}{#1}}\item[]}
{\end{list}}

\newcommand{\rs}{semi-random-string agreement\xspace}
\newcommand{\binelection}{{bin election}\xspace}
\newcommand{\es}{\mbox{\textsf{Elect-Subcommittee}}\xspace}
\newcommand{\simplees}{\mbox{\textsf{Simple-Elect-Subcommittee}}\xspace}
\newcommand{\rsAlg}{\mbox{\textsf{SRS-Agreement}}\xspace}
\newcommand{\rsToQ}{\mbox{\textsf{SRS-to-Quorum}}\xspace}

\newcommand{\papertitle}{Secure Multi-Party Computation in Large Networks}
\definecolor{Gray}{gray}{0.92}
\definecolor{darkblue}{rgb}{0,0,0.4}


\newcounter{claimcounter}
\newenvironment{claim}{\stepcounter{claimcounter}{\vspace{0.5em}\noindent \textit{Claim \theclaimcounter.~}}}{}

\usepackage{authblk}

\author[1]{\normalsize Varsha Dani\thanks{varsha@cs.unm.edu}}
\author[2]{Valerie King\thanks{val@uvic.ca}}
\author[1]{Mahnush Movahedi\thanks{movahedi@cs.unm.edu}}
\author[1]{Jared Saia\thanks{saia@cs.unm.edu}}
\author[1]{Mahdi Zamani\thanks{zamani@cs.unm.edu}}
\affil[1]{Department of Computer Science, University of New Mexico, Albuquerque, NM, USA\vspace{3pt}}
\affil[2]{Department of Computer Science, University of Victoria, Victoria, BC, Canada}



\begin{document}
\title{\papertitle\thanks{This is the extended version of the paper published in the proceedings of the 2014 International Conference on Distributed Computing and Networking (ICDCN 2014). This research was partially supported by NSF CAREER Award 0644058 and NSF grants CCR-0313160 and CCF-1320994.}}


\sloppy		

\maketitle
\begin{abstract}
We describe scalable protocols for solving the secure multi-party computation (MPC) problem among a large number of parties. We consider both the synchronous and the asynchronous communication models. In the synchronous setting, our protocol is secure against a static malicious adversary corrupting less than a  fraction of the parties. In the asynchronous setting, we allow the adversary to corrupt less than a  fraction of parties. For any deterministic function that can be computed by an arithmetic circuit with  gates, both of our protocols require each party to send a number of field elements and perform an amount of computation that is . We also show that our protocols provide perfect and universally-composable security.

\vspace{-1pt}
To achieve our asynchronous MPC result, we define the \emph{threshold counting problem} and present a distributed protocol to solve it in the asynchronous setting. This protocol is load balanced, with computation, communication and latency complexity of , and can also be used for designing other load-balanced applications in the asynchronous communication model.
\end{abstract}

\section{Introduction}
In \emph{secure multi-party computation (MPC)}, a set of parties, each having a secret value, want to compute a common function over their inputs, without revealing any information about their inputs other than what is revealed by the output of the function.
Recent years have seen a renaissance in MPC, but unfortunately, the distributed computing community is in danger of missing out. In particular, while new MPC algorithms boast dramatic improvements in latency and communication costs, none of these algorithms offer significant improvements in the highly \emph{distributed} case, where the number of parties is large.

This is unfortunate, since MPC holds the promise of addressing many important problems in distributed computing. How can peers in BitTorrent auction off resources without hiring an auctioneer? How can we design a decentralized Twitter that enables provably anonymous broadcast of messages. How can we create deep learning algorithms over data spread among large clusters of machines?

Most large-scale distributed systems are composed of nodes with limited resources. This makes it of extreme importance to \emph{balance} the protocol load across all parties involved. Also, large networks tend to have weak admission control mechanisms which makes them likely to contain malicious nodes. Thus, a key variant of the MPC problem that we consider will be when a certain hidden fraction of the nodes are controlled by a malicious adversary.

\subsection{Our Contribution} \label{sec:contribution}
In this paper, we describe general MPC protocols for computing arithmetic circuits. In terms of communication and computation costs per party, our protocols scale sublinearly with the number of parties and linearly with the size of the circuit. 

To achieve sublinear communication and computation costs, our protocols critically rely on the notion of \emph{quorums}. A quorum is a set of  parties, where the number of corrupted parties in each quorum is guaranteed not to exceed a certain fraction. We describe an efficient protocol for creating a sufficient number of quorums in the asynchronous setting.

To adapt to the asynchronous setting, we introduce the general problem of \emph{threshold counting}. We show how this problem relates to the problem of dealing with arbitrarily-delayed inputs in our asynchronous MPC protocol, and then propose an efficient protocol for solving it.

When a protocol is concurrently executed alongside other protocols (or with other instances of the same protocol), one must ensure this composition preserves the security of the protocol. We show that our protocols are secure under such concurrent compositions by proving its security in the \emph{universal composability (UC) framework} of Canetti~\cite{Canetti:UCSecurity:2001}.

\subsection{Model} \label{sec:model}
Consider  parties  in a fully-connected network with private and authenticated channels.
In our asynchronous protocol, we assume communication is via asynchronous message passing, so that sent messages may be arbitrarily and adversarially delayed. Latency (or running time) of a protocol in this model is defined as the maximum length of any chain of messages sent/received throughout the protocol (see \cite{CD,Attiya:DC:2004}).

We assume a \emph{malicious} adversary who controls an unknown subset of parties. We refer to these parties as \emph{corrupted} and to the remaining as \emph{honest}. The honest parties always follow our protocol, but the corrupted parties not only may share information with other corrupted parties but also can deviate from the protocol in any arbitrary manner, \eg, by sending invalid messages or remaining silent. 

We assume the adversary is \emph{static} meaning that it must select the set of corrupted parties at the start of the protocol. We assume that the adversary is computationally-unbounded; thus, we make no cryptographic hardness assumptions.

\subsection{Problem Statement} \label{sec:problem}
\begin{description}
	\item[Multi-Party Computation.]
	In the MPC problem,  parties, each holding a private input, want to jointly evaluate a deterministic -ary function  over their inputs while ensuring:
	
	\smallskip
	\begin{enumerate}
		\item Each party learns the correct output of ; and
		\item No party learns any information about other parties' inputs other than what is revealed from the output.
	\end{enumerate}
	
	\item[Constraints for the Asynchronous Model.]
	Consider a simple setting, where, the  parties send their inputs to a trusted party  who then locally computes  and sends the result back to every party.
	In the asynchronous setting, the MPC problem is challenging even with such a trusted party. In particular, since the  corrupted parties can refrain from sending their inputs to , it can only wait for  inputs rather than  inputs. Then, it can compute  over  inputs consisting of  values received from the parties and  dummy (default) values for the missing inputs. Finally, the trusted party sends the output back to the parties.
	The goal of asynchronous MPC is to achieve the same functionality as the above scenario but without the trusted party .
	
	discuss the termination condition based FLP impossibility. In this paper, we show that protocol terminates with high probability.  
	
	\item[Quorum Building.]
	A quorum is a set of  parties, where the fraction of corrupted parties in this set is at most  for a small positive constant . In the quorum building problem, there are  parties up to  of whom may be corrupted. The goal is to ensure all parties agree on a set of  quorums such that each party is mapped to  quorums.

	\item[Threshold Counting.]
	In this problem, there are  honest parties each with a flag bit initially set to . At least  of the parties will eventually set their bits to . The goal is for all the parties to learn when the number of bits set to  becomes greater than or equal to .
	
\end{description}



\subsection{Our Results} \label{sec:results}
The main results of this paper are summarized by the following theorems proved in Section~\ref{sec:mainproofs}. We consider an -ary function, , represented as an arithmetic circuit of depth  with  gates. 

\begin{theorem} \label{thm:main-sync}
	There exist a universally-composable protocol that with high probability solves the synchronous MPC problem and has the following properties:
	\begin{itemize}
		\item It is secure against  corrupted parties, for some fixed .
		\item Each party sends  field elements.
		\item Each party performs  computations.
		\item The expected running time is .
	\end{itemize}
\end{theorem}



\begin{theorem} \label{thm:main}
	There exist a universally-composable protocol that with high probability solves the asynchronous MPC problem and has the following properties:
	\begin{itemize}
		\item It is secure against  corrupted parties, for some fixed .
		\item Each party sends  field elements.
		\item Each party performs  computations.
		\item The expected running time is .
	\end{itemize}
\end{theorem}

\begin{description}
\item[Paper Organization.]
In Section~\ref{sec:relatedwork}, we discuss related work. In Section~\ref{sec:prelim}, we define our notation and discuss the building blocks used in our protocols. We present our MPC protocols in Section~\ref{sec:alg}. In Section~\ref{sec:mainproofs}, we prove the security of our MPC protocols. Section~\ref{sec:taucount} is a self-contained presentation of the threshold counting problem and our solution to this problem. In Section~\ref{sec:qf}, we describe an asynchronous protocol for the quorum building problem. Finally, we conclude in Section~\ref{sec:end} and discuss future directions.
\end{description}

\section{Related Work} \label{sec:relatedwork}
Due to the large body of work, we do not attempt a comprehensive review of the MPC literature here, but rather focus on seminal work and, in particular, schemes that achieve sublinear per-party communication costs.
The MPC problem was first described by Yao~\cite{Yao:1982:PSC:1382436.1382751}. He described an algorithm for MPC with two parties in the presence of a semi-honest adversary. Goldreich~\etal~\cite{Goldreich:1987:PAM:28395.28420} propose the first MPC protocol that is secure against a malicious adversary. This work along with~\cite{Chaum:1987:MCE:646752.704756,Galil:1987:CCS:646752.704741} are all based on cryptographic hardness assumptions. These were later followed by several cryptographic improvements~\cite{Beaver:1990:RCS:100216.100287,Gennaro:1998:SVF:277697.277716,Canetti:1996:ASM:888604}.

In a seminal work, Ben-Or~\etal~\cite{bgw88} show that every function can be computed with information-theoretic security in the presence of a semi-honest adversary controlling less than half of the parties, and in the presence of a malicious adversary controlling less than a third of the parties. They describe a protocol for securely evaluating an arithmetic circuit that represents the function. 

This work was later improved in terms of both communication and computation costs in \cite{chaum_crepeau_damgard:multiparty,Beaver:1991,Gennaro:1998:SVF:277697.277716}. Unfortunately, these methods all have poor communication scalability. In particular, if there are  parties involved in the computation, and the function  is represented by a circuit with  gates, then these algorithms require each party to send a number of messages and perform a number of computations that is .

These were followed by several improvements to the cost of MPC, when  (\ie, the circuit size) is much larger than ~\cite{damgard2006scalable,damgard2007scalable,damgard2008scalable}. For example, the protocol of Damg{\aa}rd~\etal~\cite{damgard2008scalable} incurs computation and communication costs that are  plus a polynomial in . Unfortunately, the additive polynomial in these algorithms is large (at least ) making them impractical for large . One may argue that for large circuits the circuit-dependent complexity dominates the polynomial complexity. However, we believe there are many useful circuits such as the ones used in~\cite{msz:sirocco:2015,Hamada:2012:MPCSorting} which have relatively small number of gates.

\begin{description}
	\item[Asynchronous MPC.]
	Foundational work in asynchronous MPC was presented by Ben-Or~\etal~\cite{benor_canetti_goldreich:asynchronous}. They adapt the protocol of \cite{bgw88} to the asynchronous setting and show that asynchronous MPC is possible for up to  fail-stop faults and up to  malicious faults. Improvements were made by Srinathan and Rangan~\cite{srinathan_pandu_rangan:efficient} and Prabhu~\etal~\cite{prabhu_srinathan_rangan:asynchronous} with a final
	communication cost of  per multiplication achieved by Beerliov\'{a}-Trub\'{\i}niov\'{a} and Hirt~\cite{Beerliova-Trubiniova:2007:SEP:1781454.1781486} for perfectly-secure asynchronous MPC with the optimal resiliency bound of up to .
	
	Damg{\aa}rd~\etal~\cite{Damgard:2009:AMC:1531954.1531967} describe a perfectly-secure MPC that guarantees termination only when the adversary allows a preprocessing phase to terminate. However, their protocol is not fully asynchronous, as they assume a few synchronization points; hence, they can achieve a resiliency bound of up to .
	
Choudhury~\etal~\cite{Choudhury:2013:AsyncMPC} propose an amortized asynchronous MPC protocols with linear communication complexity per multiplication gate meaning that the communication done by an individual party for each gate does not grow with the number of parties. This protocol is unconditionally-secure against up to  corrupted parties with a small failure probability. In our paper, we are directly addressing the third open problem of~\cite{Choudhury:2013:AsyncMPC} as we quote here: 
	
	\emph{``If one is willing to reduce the resilience t from the optimal resilience by a constant fraction, then by using additional techniques like packed secret sharing, committee election and quorum forming, one can achieve additional efficiency in the synchronous MPC protocols, as shown in [...]. It would be interesting to see whether such techniques can be used in the asynchronous settings to gain additional improvements.''}
	






	\item[MPC with Sublinear Overhead.]
	We first introduced the notion of using quorums to decrease message cost in MPC in a brief announcement~\cite{Dani:2012:BAB:2332432.2332473}. In that paper, we described a synchronous protocol with bit complexity of  per party that can tolerate a computationally unbounded adversary who controls up to  fraction of the parties for any fixed positive . As network size scales, it becomes infeasible to require each party to communicate with all other parties. 

	The current paper is the detailed version of our later extended abstract~\cite{DKMS-ICDCN-2014}, where we described algorithms to improve~\cite{Dani:2012:BAB:2332432.2332473} by handling asynchronous communication. One important challenge in the asynchronous communication model is to ensure that at least  inputs are committed to, before the circuit evaluation. To address this issue we introduce and solve the \emph{threshold counting problem.}
	
	Boyle~\etal~\cite{Boyle:2013:CLS:2450206.2450227} describe a synchronous MPC protocol for evaluating arithmetic circuits. The protocol is computationally-secure against an adversary corrupting up to () fraction of parties, for some fixed positive . Similar to~\cite{Dani:2012:BAB:2332432.2332473}, the protocol of~\cite{Boyle:2013:CLS:2450206.2450227} also uses quorums to achieve sublinear per-party communication cost. Interestingly, the communication cost of this protocol is independent of circuit size. This is achieved by evaluating the circuit over encrypted values using a \emph{fully-homomorphic encryption (FHE)} scheme~\cite{Gentry:2009:FHE:1536414.1536440}. Unfortunately, the protocol is not fully load-balanced as it evaluates the circuit using only one quorum (called the supreme committee). The protocol requires each party to send  messages of size  bits and requires  rounds.
	
	Chandran~\etal~\cite{cryptoeprint:2014:615} address two limitations of the protocol of~\cite{Boyle:2013:CLS:2450206.2450227}: tolerating an adaptive adversary and achieving optimal resiliency (\ie,  malicious parties). They replace the common reference string assumption of~\cite{Boyle:2013:CLS:2450206.2450227} with a different setup assumption called symmetric-key infrastructure, where every pair of parties share a uniformly-random key that is unknown to other parties. The authors also show how to remove the SKI assumption at a cost of increasing the communication locality by . Although this protocol provides small communication locality, the bandwidth cost seems to be super-polynomial due to large message sizes.
	


Boyle~\etal~\cite{cryptoeprint:2014:404} describe a scalable technique for secure computation of RAM programs~\cite{Goldreich:1996:SPS:233551.233553} in large networks by performing local communications in quorums of parties. For securely evaluating a RAM program , their protocol incurs a total communication and computation of  while requiring  memory per party, where  and  are time and space complexity of  respectively, and  denotes the input size.
	
	In Table~\ref{tab:SublinearMPC}, we review recent MPC results that provide sublinear communication locality. All of these results rely on some quorum building technique for creating a set of quorums each with honest majority.

\newcolumntype{L}[1]{>{\columncolor{Gray}\raggedright\let\newline\\\arraybackslash}p{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash}m{#1}}
\newcommand{\beforegap}{\rule{0px}{17px}}
\newcommand{\aftergap}{\\centering \mathbf{E}[X] = O(D\log{N}).\Pr(X \geq 2\mathbf {E}[X]) \leq 1/2.2\mathbf{E}[X]\log{N} = O(D\log^2{N})\label{eqn:bb-low}
	\Prob (E_1) \le \e\bins\sqrt{\alpha \bins}
	\left(\frac2{\e}\right)^{\alpha/2}
	\label{eqn:bb-high}
	\Prob (E_2) \le \e\bins\sqrt{\alpha \bins}
	\left(\frac{8\e}{27}\right)^{\alpha/2}\,.
	
		\Prob(E_1)&= \Prob\left(\exists i \mbox{ s.t. } X_i \le \alpha/2\right) \\
		& \le 2\Prob\left(\exists i \mbox{ s.t. } Y_i \le
		\alpha/2\right)\\
		&\le 2 \sum_{i=1}^{\bins}
		\Prob\left(Y_i \le \frac{\alpha}{2}\right) \\
		&\le 2 \bins\left(\frac{2}{\e}\right)^{\alpha/2},
	
		\Prob(E_2)&= \Prob\left(\exists i \mbox{ s.t. } X_i > 3\alpha/2\right) \\
		&\le 2 \Prob\left(\exists i \mbox{ s.t. } Y_i >
		3\alpha/2\right)\\
		&\le 2 \sum_{i=1}^{\bins}
		\Prob\left(Y_i \ge \frac{3\alpha}{2}\right) \\
		&\le 2\bins \left(\frac{8\e}{27}\right)^{\alpha/2},
	
		\Prob(E_1) &\le \frac{2\tau}{14\log{n}}\left(\frac2{\e}\right)^{7s\log{n}} \\
		&\le \frac{2 n}{14\log{n}} 2^{-0.4426 \times 7s\log n} \\
		&\le \frac{1}{7n^{2s}\log{n}}
	
		\Prob (E_2) &\le \frac{2 \tau}{14\log{n}}
		\left(\frac{8\e}{27}\right)^{7s\log{n}} \\
		&\le \frac{2 n}{14\log{n}}2^{-0.3121 \times 7s\log{n}} \\
		&\le \frac{1}{7n^{1.1s}\log{n}}
	
		\Prob(E'_1) &\le \frac{2\tau}{14\log{n}}\left(\frac2{\e}\right)^{7\log{n}} \\
		&\le \frac{2 n}{14\log{n}} 2^{-0.4426 \times 7\log n} \\
		&\le \frac{1}{7n^{2}\log{n}}
	
		\Prob (E'_2) &\le \frac{2 \tau}{14\log{n}} \left(\frac{8\e}{27}\right)^{7\log{n}}\\
		&\le \frac{2 n}{14\log{n}}2^{-0.3121 \times 7\log{n}} \\
		&\le \frac{1}{7n^{1.1}\log{n}}.
	{2}
	\Prob(E) &\le \frac{1}{7n^{2s}\log{n}} + \frac{1}{7n^{1.1s}\log{n}} + \frac{1}{7n^{2}\log{n}} \\
	&\quad\quad\quad + \frac{1}{7n^{1.1}\log{n}} \\
	&\le \frac{1}{7n\log{n}}
	
	\left(1- \frac{j-1}{7n\log{n}}\right)\left(1-\frac{1}{7n\log{n}}\right) \ge 1-\frac{j}{7n\log{n}},
	\frac{|F' \bigcap X'|}{|F'|} > \frac{|X'|}{|X|} + \delta.

In other words,  is the set of all subsets of  whose overlap with   is larger than the ``expected'' size by more than a  fraction.
Let  denote the neighbors of node  in a graph.

\begin{lemma} \label{l:expander}
	Let  be positive integers such that  and  are all no more than  and . Then, there is a bipartite graph  such that  and  and
	
	\begin{enumerate}
		\item Each node in  has degree .
		\item Each node in  has degree .
		\item Let  be the collection of sets  for each . Then, for any subset  of ,\\
		.
	\end{enumerate}
	
\end{lemma}

The proof of Lemma~\ref{l:expander} follows from a counting argument using the probabilistic method and is omitted.
The following corollaries follows immediately by repeated application of the above lemma.

\begin{corollary} \label{l:expander s-node connection}
	Let  be the smallest integer such that .
	There is a family of bipartite graphs , and constants  and  such that , , and
	
	\begin{enumerate}		
		\item Each node in  has degree .
		
		\item Each node in  has degree .
		
		\item Let  be the collection of sets  for each . Then, for any subset  of ,\\
		.
		
		\item Let  be the collection of sets  for each . Then, for any subset  of ,\\
		.		
	\end{enumerate}
	
\end{corollary}

\begin{corollary}
	\label{l:expander graph family}  Let  be the smallest integer such that . There is a family of bipartite graphs , such that , , and
	
	\begin{enumerate}		
		\item Each node in  has degree .		
		\item Each node in  has degree .		
		\item Let  be the collection of sets  for each . Then, for any subset  of ,\\
		.		
	\end{enumerate}
	
\end{corollary}

Lemma~\ref{l:expander} and its corollaries show there exists a family of bipartite graphs with strong expansion properties which allow the formation of subsets of parties where all but a small fraction contain a majority that are honest.

We are now ready to describe the election graph. Throughout, we refer to nodes of the election graph as \textsf{e-node}s to distinguish them from nodes of the static network. Let  be the minimum integer  such that ; note that . The topmost layer  has a single \textsf{e-node} which is adjacent to every \textsf{e-node} in layer . For the remaining layers , there are  \textsf{e-node}s. There is an edge between the th \textsf{e-node}, ,  in layer  and the th \textsf{e-node}, , in layer  if and only if there is an edge between the th node in  and the th node in  from Corollary~\ref{l:expander graph family}. In such a case, we say that  is the parent of , and  is the child of . Note that \textsf{e-node}s have many parents.

Each \textsf{e-node} will contain a set of parties known as a {\it committee}. All \textsf{e-node}s, except for the one on the top layer and those in layer 0, will contain  parties. Initially, we assign the  parties to \textsf{e-node}s on layer  using the bipartite graph  described in Corollary~\ref{l:expander graph family}. The  party is a member of the committee contained in the  \textsf{e-node} of layer 0 if and only if there is an edge in  between the  node of  and the  node of . Note every \textsf{e-node} on layer 0 has  parties in it.

The \textsf{e-node}s on higher layers have committees assigned to them during the course of the protocol. Let  be an \textsf{e-node} on layer , let  be the children of  on layer , and suppose that we have already assigned committees to \textsf{e-node}s on layers lower than . If , we assign a committee to  by running \es on the parties assigned to , and assigning the winning subcommittee to . (Note that we can run each of these elections in parallel.)  If  is at layer , the parties in , , run \heavyba\ for Byzantine agreement.

\subsection{Static Network with Polylog-Bounded Degree} \label{s: static network}

We now repeat the description of the bounded degree static network~\cite{King:2006:TSS:1170136.1170491} and show how it can be used to hold elections specified by the election graph. For each \textsf{e-node} , we form a collection of parties which we call it \textsf{s-node}: . Intuitively, the \textsf{s-node}  serves as a central communication point for an election occurring at \textsf{e-node} . 
Our goal is to bound the fraction of \textsf{s-node}s controlled by the adversary by a decreasing function in , namely , for each layer. As the number of \textsf{s-node}s grows much smaller with each layer, we need to make each \textsf{s-node} more robust. To do this, the number of parties contained in the \textsf{s-node} increases with the layer. Specifically, the \textsf{s-node}s for layer  are sets of  parties. We determine these \textsf{s-node}s using the bipartite graph from Lemma \ref{l:expander}, where  is a collection of  nodes, one for each party,  is the set of \textsf{s-node}s for layer  and the degree of each node in  is set to . The neighbors of each node in  constitute a set of parties in an \textsf{s-node} on layer .

We use the term {\em link} to denote a direct connection in the static network. The communications for an election  will all be routed through : a message from a party  to  on layer  will pass from the party to a layer  \textsf{s-node}, whose parties will forward the message to a layer  \textsf{s-node} and so on, the goal being to reliably transmit the message via increasingly larger \textsf{s-node}s up to .
Similarly, communications to an individual party  from  will be transmitted down to a layer  \textsf{s-node} whose parties will transmit the message to . We describe the connections in the static network.

\begin{description}
	\item[Connections in the static network.] Consider the following:
	\begin{itemize}	
		\item Let  be an \textsf{e-node} on layer  in the election graph.
		Every party in  has a link to every party in .
		
		\item Let  and  be \textsf{e-node}s in the election graph at levels  and  respectively such that  is a parent of . Thus,  has  parties in it and  has  parties in it. Let  be a bipartite graph as in Lemma~\ref{l:expander} where  is the set of parties in ,  is the set of parties in  and the degree of  is set to  and the degree of  is set to .  If there is an edge between two nodes in  and  respectively, then the corresponding party in  has a link to the corresponding party in . We will sometimes say that  is adjacent to  in the static network.
	\end{itemize}
\end{description}

The following lemma follows easily from the application of Lemma \ref{l:expander} and its corollaries.
Item (1) follows from Lemma 3.1; items (2) and (4)  from Corollary 3.2; and item (3) from Corollary 3.1. Although item (2) only makes a guarantee about layer 0 \textsf{e-node}s, we will see eventually that with high probability, the fraction of corrupted \textsf{e-node}s on every layer is small.

\begin{lemma}
	With high probability, the election graph and the static network have the following properties:
	
	\label{l:network properties}
	\begin{enumerate}
		\item (Bad \textsf{s-node}s) Any \textsf{s-node} whose fraction of corrupt parties exceeds  will be called {\it bad}. Else, we will call the \textsf{s-node} {\it good}. No more than a  fraction of \textsf{s-node}s on any given layer are bad.
		
		\item (Bad \textsf{e-node}s) Any \textsf{e-node} whose fraction of corrupt parties exceeds  will be called {\it bad}. Else we call the \textsf{e-node} {\it good}. No more than a  fraction of
		\textsf{e-node}s on layer 0 are bad.


		\item  (Bad \textsf{s-node} to \textsf{s-node} connection)
For any pair of \textsf{e-node}s  and  joined in the election graph, the parties in \textsf{s-node}s  and  are linked such that the following holds. For any subset  of parties in , at most a  fraction of parties in  have more than a  fraction of their links to  with parties in .
		
		\item  (Bad \textsf{e-node} to \textsf{e-node} connection) Let  represent the total number of \textsf{e-node}s on layer  in the election graph.
For any set  of \textsf{e-node}s on any layer ,  at most a  fraction of \textsf{e-node}s on layer  have more than  fraction of their neighbors in .
		
	\end{enumerate}
\end{lemma}

The degree of the static network is polylogarithmic.

\subsection{Communication Protocols} \label{s:low level communication}

A {\em permissible path} is a path of the form  where  is a party in ,  is the current layer of elections being held, each  is an \textsf{e-node} on layer , and there is an edge in the election graph between  and  for . Each party  in an \textsf{s-node}  on each layer  keeps a {\em List} of permissible paths that determine which parties' messages it will forward. The \lst\ (for ) represents 's view of which parties are elected (to the subcommittee) at  that are still participating in elections on higher layers. If 's \lst\ indicates that  is such a party, then the \lst\ will also have the entire path for , which stretches from  to the elections on layer  in which  is currently participating in. We have the following definitions.

\begin{itemize}
	\item We say a {\em \textsf{s-node} knows a message} [resp., {\em knows a permissible path}, or resp., {\em knows a \lst\ of permissible paths}] if  parties in the \textsf{s-node} are honest and receive the same message [resp., have the same path on their \lst s, or resp., all have the same \lst.]
	
	\item A permissible path  is good if every \textsf{s-node} on the path knows . Else the path is bad. We will show our construction of the static network ensures at most a  fraction of the permissible paths are bad.
\end{itemize}

We now describe three primitive communication subroutines: \Sendhop, \Send, and \MessagePass. The subroutine \Sendhop\ describes how \textsf{s-node}s (with direct links) communicate with each other, \Send\ describes how a party communicates with an \textsf{s-node}, and \MessagePass\ describes how two parties communicate with each other.

\begin{description}
	\item[\Sendhop.]
	A message  can be passed from  (the sender) to  (the receiver) from a level  to a level  or from a level  to a level , where  and  are \textsf{s-node}s on these layers or one of  is a 0-layer \textsf{s-node} and the other is a party. If a party  sends a message to a layer  \textsf{s-node}  it sends the message to every party in  (note by construction it will have a direct link with every party in ). Similarly if a message is sent from a layer  \textsf{s-node}  to a party , every party in  sends the message to .
\end{description}

When an \textsf{s-node}  sends a message to \textsf{s-node} , every party in  sends the message to those parties of  to which it has a direct link. When each party in  receives such a set of messages, it waits until it receives the same messages from the majority to determine the message. If there is no majority value, the party ignores the message. Along with sending the message the parties also send information which specifies along which path  the message is being sent. Each time a message is received by a party of an \textsf{s-node}  on layer , it checks that:

\begin{enumerate}
	\item The message came from the \textsf{s-node} previous to it in the path ; if not the message is dropped.
	\item The path  (or its reverse) is on its \lst\ of permissible paths. If not, the message is dropped.	
	\item Only messages that conform to the protocol in size and number are forwarded up and down the permissible paths. If more or longer messages are received from a party, messages from that party are dropped.
\end{enumerate}

\begin{description}
	\item[\Send.]
	Of the first two parameters, one must be a party (``'') and one must be an \textsf{s-node} (``''). The path  contains the first parameter  as its start and the second parameter  as its endpoint. \Send sends the message  from  to  along the path  via repeated application of \Sendhop.
	
	\item[\MessagePass.]
	Both  and  are adjacent \textsf{e-node}s. Hence,  and  are adjacent in the static network.
	A message from party  in \textsf{e-node}  sends message  to party  in
	\textsf{e-node}  by first calling \Send. Then,  sends  to  by calling \Sendhop, where  is the path consisting of two \textsf{s-node}s . Finally, the message is transmitted from  to  by calling \Send, where  is the reversal of path .
\end{description}

\subsection{\rsAlg Protocol} \label{sec:srs-agreement}

Before describing the \rsAlg protocol, we first adapt the \es protocol for the static network. Let  be an \textsf{e-node} with children , and let  be the set of all parties from . For each  and , let  denote a good path of \textsf{s-node}s from  to  concatenated with . At the start of the election for , we assume that each node in  knows  and  knows . 

We now describe the implementation of the \es algorithm. Every party   generate a vector of random numbers chosen uniformly and independently at random where each random number maps to one party. The parties use the \hw protocol to determine the winners 
(recall that the number of parties in \textsf{e-node}s is always polylogarithmic, so this can be done sending only polylogarithmic messages). The list of winners is sent up to , where each party in  takes a majority to determine the winners. Then,  sends down the list of winners along all the permissible paths to each party .
Parties on the path (\ie, in \textsf{s-node}s along the path) update their \lst s of permissible paths to remove those party-paths who lost as well as those party-pairs who won too many elections (we will quantify this shortly), and make  copies of each of the winners' paths and concatenate a different layer  \textsf{s-node} parent onto each one. We present a detailed description of \es in the following.
\begin{algorithm}
	\caption{\es}
	\medskip
	\algfont
	\textit{Goal.} Adapted version of \simplees for static networks.
	\medskip
	\begin{enumerate}
		\item For each  : {\em   // This stage done in parallel}
		\item
		\begin{indentpar}{0.5cm}
			Party  randomly selects one of  random numbers chosen uniformly and independently at random from zero to  where each random number maps to one party.
		\end{indentpar}
		\item Parties in  run \hw to compute the component-wise sum modulo  of all the vector. Arbitrarily, add enough additional numbers to the vector to ensure it has  unique numbers.
		\item Let  be the set of winning parties, which are those associated with some component of the vector sum.
		\item
		\begin{indentpar}{0.5cm}
			Each  sends  to  by calling \Send.
		\end{indentpar}
		\item
		\begin{indentpar}{0.5cm}
			Parties in  determine  by waiting until they receive the majority of same messages. These become the elected parties.
		\end{indentpar}
		\item For each party  that is elected, the parties in  use  \Send to tell , along with each \textsf{s-node} in , that  was elected.
		\item Each party in each \textsf{s-node} revises its list of permissible paths to:
		\begin{indentpar}{0.5cm}
			Retain only the winners.
			Eliminate parties who have won more than 8 elections.
			Make  copies of remaining permissive paths, concatenating each with a different \textsf{s-node} neighbor on layer .
		\end{indentpar}
		\item  sends its list to every adjacent \textsf{s-node}  on layer  using \Sendhop, where  is the path consisting only of , .
	\end{enumerate}
\end{algorithm}

The condition in Step  that requires parties who have won more than  elections to be eliminated is a technical condition that insures the protocol is load-balanced and parties in an \textsf{s-node} do not communicate more than a polylogarithmic number of bits. We now describe the \rsAlg protocol.
\begin{algorithm}
	\caption{{\sf Scalable-}\rsAlg}
		\medskip
		\algfont
		\textit{Goal.} Parties agree on a semi-random string.
	\begin{enumerate}
		\item For  to :
		\item
		\begin{indentpar}{0.3cm}
			For each \textsf{e-node}  in layer , let  be the children of  in layer  of the election graph, and
		\end{indentpar}
		\item
		\begin{indentpar}{0.6cm}
			If , run \es on the parties in nodes . Assign winning parties to node .
		\end{indentpar}
		\item
		\begin{indentpar}{0.6cm}
			Else parties in nodes  solve \rs problem.
		\end{indentpar}
		\item Let  be the \textsf{e-node} on layer , every party  assigned to  communicates the result of Step 4 to  using \Send.
		\item Every party in  waits for the majority of same message to determine the result of Step 4.
	\end{enumerate}
\end{algorithm}

Since every party is a member of , steps  and  will insure the final result of the protocol is communicated to every party.

\subsection{Proof of \textsf{Build-Quorums}} \label{sec:cq-proofs}
To establish the correctness of the protocol presented in Section~\ref{sec:srs-agreement}, we first state some claims regarding the primitive communication protocols. Their proofs follow by straightforward probabilistic arguments and are omitted in the interest of space. Recall the fraction of corrupted parties is , where  for any fix positive .

\begin{claim} \label{c:nodeToNode}
	Let  and  be \textsf{s-node}s on consecutive layers. Assume the following conditions hold:
	\begin{enumerate}		
		\item Both  and  are good.
		
		\item  is on a permissible path known by .
		
		\item There exists a set  of parties from  such that for every message ,  all parties in  are honest and agree on a message . Further  consists of at least a  fraction of the parties in .
	\end{enumerate}
	
	Then, there is a set  of parties from  such that for every message , every party in  is honest and agrees on the message  after \Sendhop is called. (Here,  is the path .)  Further,  consists of all but a  fraction of the honest parties in .
\end{claim}
\begin{proof}
	Every party in  is honest and sends the same massage to its connected parties in . The parties in  can afford to wait for the majority of same messages, since  is good and  consists of at least  fraction of parties which is more than  and for majority we need to receive a fraction of  same messages from the parties in . Thus, all honest party but a  fraction of parties in  will eventually receive the message based on corollary \ref{l:expander s-node connection}.
	\qed
\end{proof}

\begin{claim}\label{c:partyToNode}
	Let  be an honest party. Assume  is a good path.
	Then, after \Send is executed, there is a fixed set  of honest parties which contains all but a  fraction of the honest parties in  and every party  agrees on .	
\end{claim}

An election at \textsf{e-node}  is {\em legitimate} if the following two conditions hold simultaneously for more than a  fraction of parties  participating in the election at : (1) party  is honest; (2) The path  is good.

\begin{lemma}
	\label{l:legitimateElections}
	For a legitimate election at node , let  be a set of honest parties with good permissible paths. (Note .) Let  be the set of honest parties in  that know . Then, after the execution of {\sc Elect-subcommittee}, the parties in  know the winners of the election in , as do the \textsf{s-node}s that belong to good paths .
\end{lemma}
\begin{proof}
	From Claim~\ref{c:partyToNode}, we have that every message  sent by \MessagePass from  to  is received by some fixed set  of honest parties in , such that  contains at least  fraction of the parties in .
	By Claim~\ref{c:nodeToNode}, every message sent by  is received by . Since  contains more than  of the total parties participating in the election, (after running \hw) all the parties in  will all agree on the same set of for random parties. Thus, after the parties in  send these values to ,  will know the winners. When  sends these winners to , by repeated application of Claim~\ref{c:nodeToNode}, we have every  and every \textsf{s-node} in  will know these winners.
	\qed
\end{proof}

We have shown that in a legitimate election at node ,  knows the list of winners. We next consider when paths are dropped from the permissible path \lst s.

\subsubsection{Permissible Paths Removal}
\ Let  be a party in some \textsf{s-node} on layer . A permissible path  is removed from a party 's \lst\ on layer  if  receives a message from an \textsf{s-node} above it in , indicating either  has won more than 8 elections or  lost in the election held at the last node of . Here, we consider when  is removed for the former reason, \ie, we give an upper bound on the fraction of parties that are reported to have won too many elections on layer .

First we consider the effect of legitimate elections. The following lemma, a version of which appears in \cite{KSSV,King:2006:TSS:1170136.1170491}, shows that on a given layer a very small fraction of honest parties win more than 8 times in legitimate elections.

\begin{lemma}
	With high probability, the parties that win more than 8 elections, counting multiplicities, account for no more than a  fraction of the honest parties that are winners of legitimate elections.
\end{lemma}

Next, we bound the effect of elections that are not legitimate. We first consider the case where  is good, yet the fraction of honest parties participating in  with good paths is less than 3/4. For the remainder of the proof we shall treat such an \textsf{e-node}\   as a bad \textsf{e-node}.

\begin{claim}
	\label{c:bad election}
	Suppose less than a  fraction of the honest parties of a good  agree on a message . Then, after
	\Sendhop is executed, all but a  fraction of the honest parties in  will ignore .
\end{claim}

\noindent\begin{proof}
	Even if the corrupted parties agree on , since , the total fraction of parties in  sending the message  is less than 11/28. Thus, at most a  fraction of the parties in  will receive  from a majority of parties in .
	\qed
\end{proof}

Hence, a good  can only communicate with seven different sets of winners to the \textsf{s-node}s below it. Since each honest party will send  winners, the total number of winners sent is at most . Therefore, a bad \textsf{e-node} can cause at most  parties to have their permissible paths removed.

Next, we consider the effect of a bad \textsf{s-node}. We will assume one bad \textsf{s-node}  on layer  can cause the removal of all the permissible paths for every party participating in the election at . Since  parties participate in an election, and fewer than a  fraction of the \textsf{s-node}s are bad on a layer, the fraction of honest winners affected is less than . Thus, we can bound the fraction of the honest winners on any layer  that have their permissible paths removed by ; where  represents the fraction of bad \textsf{e-node}s on layer .
Thus, we have the following lemma.

\begin{lemma}
	\label{l:win too often} Assume the fraction of bad \textsf{e-node}s on layer  is bounded by , for some constant . Then, the fraction of honest winners that have their permissible paths removed on layer  is bounded by .
\end{lemma}

\subsubsection{Proof of Theorems~\ref{t:mainbyz}}

We now complete the proof of Theorem~\ref{t:mainbyz} which follows from the following lemma.

\begin{lemma}
	\label{l:main}
	On layer , with high probability, at least a  fraction of \textsf{s-node}s  have the following properties:
	\begin{enumerate}
		\item  is good.

		\item At least a  fraction of the parties in node  are honest and have good paths to  (note this implies  knows this path). That is,  is a good \textsf{e-node}.
	\end{enumerate}
\end{lemma}
\begin{proof}
	We prove the lemma by induction. On all layers and particularly layer 0, only a  fraction of the \textsf{s-node}s are bad. If  is good, then every party in  has a good path to . Further by construction all but a  fraction of the \textsf{e-node}s on layer 0 consist of at least a  fraction of honest parties. So the lemma is true on layer 0.
	
	Assume the lemma is true for layer . Then, a  fraction of \textsf{e-node}s are good, more specifically these \textsf{e-node}s have at least a  fraction of honest parties that have a good path to their corresponding \textsf{s-node}. Since the election is legitimate by Lemmas~\ref{lem:subcommittee}
	and~\ref{l:legitimateElections}, with high probability, after \es at least a  fraction of the parties elected are honest and have a good path to any good parent of their \textsf{s-node}. Thus, at least a  fraction of the parties elected at layer  are honest and have good paths to good parent \textsf{s-node}s on layer . By Lemma~\ref{l:win too often} this fraction is reduced by at most . Thus, at least a  fraction of the parties elected at layer  are honest and have good paths to good parent \textsf{s-node}s on layer . Since the fraction of bad \textsf{s-node}s on layer  is at most , by Corollary ~\ref{l:expander graph family} at least a  fraction of the
	\textsf{e-node}s (and their corresponding \textsf{s-node}s) are good on layer , and have at least a  fraction of honest parties that have good paths to their corresponding \textsf{s-node}s.
	\qed
\end{proof}

By Lemma~\ref{l:main}, with high probability the layer  \textsf{e-node} is good.
Thus, the parties in this \textsf{e-node} succeed in solving the \rs problem (Step 4 of algorithm \rsAlg). Since all the parties are in the \textsf{s-node} (though they may appear multiple times) corresponding to  on , by Claim~\ref{c:partyToNode} all but a  fraction of the honest parties learn the final result.
To prove the number of bits sent by each party is polylogarithmic we note each party is in a polylogarithmic number of \textsf{e-node}s and \textsf{s-node}s on each layer , and participates in at most a polylogarithmic number of election on layer . Since the number of layers is  Theorem~\ref{t:mainbyz} follows. Finally, the correctness of Theorem~\ref{thm:quorum-building} follows from Theorem~\ref{t:mainbyz} and the correctness of \rsToQ protocol.

\section{Conclusion} \label{sec:end}
We described a Monte Carlo algorithm to perform asynchronous MPC in an scalable manner. Our protocols are scalable in the sense that they require each party to send  messages and perform  computations. They tolerate a static adversary that controls up to a  fraction of the parties, for  any positive constant. We showed that our protocol is secure in the universal composability framework.
We also described efficient algorithms for two important building blocks of our protocol: threshold counting and quorum building. These algorithms can be used separately in other distributed protocols.

The following problems remain open. Can we prove lower bounds for the communication and computation costs for Monte Carlo MPC?  Can we implement and adapt our algorithm to make it practical for a MPC problem such as the beet auction problem described in~\cite{bogetoft2009secure}. Finally, can we prove upper and lower bounds for resource costs to solve MPC in the case where the adversary is \emph{adaptive}, able to take over parties at any point during the algorithm?

\section*{Acknowledgements}
The authors would like to acknowledge supports from NSF under grants CCF-1320994, CCR-0313160, and CAREER Award 644058. We are also grateful for valuable comments from Ran~Canetti (Boston University), Shafi~Goldwasser (MIT), Aniket~Kate (Saarland), Yehuda~Lindell (Bar-Ilan), and Seth~Pettie (UMich).

\bibliographystyle{alpha}
\bibliography{security}

\end{document}