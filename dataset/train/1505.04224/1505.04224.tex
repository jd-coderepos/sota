\documentclass[11pt]{article}
\usepackage{float}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{amsmath, amsthm, amssymb, amsfonts}
\usepackage{graphicx}
\usepackage{color}
\usepackage{xy}
\usepackage{fullpage}
\usepackage{ifthen}
\usepackage{enumitem}
\usepackage{comment}









\clearpage{}
\newcommand{\cA}{\ensuremath{\mathcal{A}}}
\newcommand{\ca}{\cA}
\newcommand{\cB}{\ensuremath{\mathcal{B}}}
\newcommand{\cb}{\cB}
\newcommand{\cC}{\ensuremath{\mathcal{C}}}
\newcommand{\cc}{\cC}
\newcommand{\cD}{\ensuremath{\mathcal{D}}}
\newcommand{\cE}{\ensuremath{\mathcal{E}}}
\newcommand{\cF}{\ensuremath{\mathcal{F}}}
\newcommand{\cG}{\ensuremath{\mathcal{G}}}
\newcommand{\cH}{\ensuremath{\mathcal{H}}}
\newcommand{\cI}{\ensuremath{\mathcal{I}}}
\newcommand{\ci}{\cI}
\newcommand{\cJ}{\ensuremath{\mathcal{J}}}
\newcommand{\cK}{\ensuremath{\mathcal{K}}}
\newcommand{\cL}{\ensuremath{\mathcal{L}}}
\newcommand{\cM}{\ensuremath{\mathcal{M}}}
\newcommand{\cN}{\ensuremath{\mathcal{N}}}
\newcommand{\cO}{\ensuremath{\mathcal{O}}}
\newcommand{\co}{\cO}
\newcommand{\cP}{\ensuremath{\mathcal{P}}}
\newcommand{\cQ}{\ensuremath{\mathcal{Q}}}
\newcommand{\cR}{\ensuremath{\mathcal{R}}}
\newcommand{\cS}{\ensuremath{\mathcal{S}}}
\newcommand{\cs}{\cS}
\newcommand{\cT}{\ensuremath{\mathcal{T}}}
\newcommand{\cU}{\ensuremath{\mathcal{U}}}
\newcommand{\cV}{\ensuremath{\mathcal{V}}}
\newcommand{\cW}{\ensuremath{\mathcal{W}}}
\newcommand{\cY}{\ensuremath{\mathcal{Y}}}
\newcommand{\cX}{\ensuremath{\mathcal{X}}}
\newcommand{\cZ}{\ensuremath{\mathcal{Z}}}

\newcommand{\cID}{\ensuremath{\mathcal{ID}}}
\newcommand{\cIS}{\ensuremath{\mathcal{IS}}}
\newcommand{\cIIS}{\ensuremath{\mathcal{IIS}}}
\clearpage{}
\clearpage{}\newcommand{\bbA}{\ensuremath{\mathbb{A}}}
\newcommand{\bbB}{\ensuremath{\mathbb{B}}}
\newcommand{\bbC}{\ensuremath{\mathbb{C}}}
\newcommand{\bbD}{\ensuremath{\mathbb{D}}}
\newcommand{\bbE}{\ensuremath{\mathbb{E}}}
\newcommand{\bbF}{\ensuremath{\mathbb{F}}}
\newcommand{\bbG}{\ensuremath{\mathbb{G}}}
\newcommand{\bbH}{\ensuremath{\mathbb{H}}}
\newcommand{\bbI}{\ensuremath{\mathbb{I}}}
\newcommand{\bbJ}{\ensuremath{\mathbb{J}}}
\newcommand{\bbK}{\ensuremath{\mathbb{K}}}
\newcommand{\bbL}{\ensuremath{\mathbb{L}}}
\newcommand{\bbM}{\ensuremath{\mathbb{M}}}
\newcommand{\bbN}{\ensuremath{\mathbb{N}}}
\newcommand{\bbO}{\ensuremath{\mathbb{O}}}
\newcommand{\bbP}{\ensuremath{\mathbb{P}}}
\newcommand{\bbQ}{\ensuremath{\mathbb{Q}}}
\newcommand{\bbR}{\ensuremath{\mathbb{R}}}
\newcommand{\rr}{\bbR}
\newcommand{\bbS}{\ensuremath{\mathbb{S}}}
\newcommand{\bbT}{\ensuremath{\mathbb{T}}}
\newcommand{\bbU}{\ensuremath{\mathbb{U}}}
\newcommand{\bbV}{\ensuremath{\mathbb{V}}}
\newcommand{\bbW}{\ensuremath{\mathbb{W}}}
\newcommand{\bbY}{\ensuremath{\mathbb{Y}}}
\newcommand{\bbX}{\ensuremath{\mathbb{X}}}
\newcommand{\bbZ}{\ensuremath{\mathbb{Z}}}
\clearpage{}
\clearpage{}\DeclareMathOperator{\Bary}{Bary}
\DeclareMathOperator{\Bd}{\partial}
\DeclareMathOperator{\Car}{Car}
\DeclareMathOperator{\Chains}{Chains}
\DeclareMathOperator{\Ch}{Ch}
\DeclareMathOperator{\Cone}{Cone}
\DeclareMathOperator{\Div}{Div}
\DeclareMathOperator{\Faces}{Faces}
\DeclareMathOperator{\Face}{Face}
\DeclareMathOperator{\Hyper}{Hyper}
\DeclareMathOperator{\Link}{Lk}
\DeclareMathOperator{\link}{Lk}
\DeclareMathOperator{\lk}{Lk}
\DeclareMathOperator{\Lk}{Lk}
\DeclareMathOperator{\Ostar}{Ost}
\DeclareMathOperator{\Star}{St}
\DeclareMathOperator{\act}{active}
\DeclareMathOperator{\argmax}{argmax}
\DeclareMathOperator{\bary}{Bary}
\DeclareMathOperator{\bdry}{\partial}
\DeclareMathOperator{\carrier}{Car}
\DeclareMathOperator{\clock}{clock}
\DeclareMathOperator{\codim}{codim}
\DeclareMathOperator{\diam}{diam}
\DeclareMathOperator{\dl}{dl}
\DeclareMathOperator{\idmap}{id}
\DeclareMathOperator{\ids}{names}\DeclareMathOperator{\id}{name}\DeclareMathOperator{\im}{Im}
\DeclareMathOperator{\inte}{Int}
\DeclareMathOperator{\latest}{latest}
\DeclareMathOperator{\mesh}{mesh}
\DeclareMathOperator{\names}{names}\DeclareMathOperator{\name}{name}\DeclareMathOperator{\sgn}{sgn}
\DeclareMathOperator{\skel}{skel}
\DeclareMathOperator{\stel}{stel}
\DeclareMathOperator{\vals}{views}
\DeclareMathOperator{\val}{view}
\DeclareMathOperator{\mvalue}{value}
\DeclareMathOperator{\vectorClock}{vectorClock}
\DeclareMathOperator{\views}{views}
\DeclareMathOperator{\view}{view}
\newcommand{\var}[1]{\lstinline+#1+}
\newcommand{\ang}[1]{\langle{#1}\rangle}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\false}{\textit{false}}
\newcommand{\true}{\textit{true}}
\clearpage{}
\clearpage{}\theoremstyle{remark}
\newtheorem{theorem}{Theorem}[section]

\newtheorem{claim}[theorem]{Claim}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{exercise}{Exercise}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{hypothesis}[theorem]{Hypothesis}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{pragma}[theorem]{Pragma}
\newtheorem{principle}[theorem]{Principle}
\newtheorem{property}[theorem]{Property}
\newtheorem{remark}[theorem]{Remark}
\clearpage{}

\newcommand{\set}[1]{\{#1\}} 
\newcommand{\send}[1]{\mathbf{send}({#1})}
\newcommand{\recv}[1]{\mathbf{recv}({#1})}

\newcommand{\runmap}[1]{{\, \underrightarrow{\quad {#1} \quad} \,}}
\newcommand{\piece}[2]{[{#1}:{#2}]}
\newcommand{\quorum}[1]{{\textrm{Quorum}({#1})}}
\newcommand{\validated}[2]{{\textrm{Valid}_{{#1}}({#2})}}
\newcommand{\completed}[2]{{\textrm{Complete}_{{#1}}({#2})}}
\newcommand{\setproc}[1]{\textrm{SetProc}({#1})}
\newcommand{\setcons}[1]{\textrm{SetCons}({#1})}

\DeclareMathOperator{\cont}{Cont}
\DeclareMathOperator{\interp}{Interp}

\algblockdefx[upon]{Upon}{EndUpon}[1]{\textbf{upon} #1 \textbf{do}}{}

\title{Tight Bounds for Connectivity and Set Agreement\\in Byzantine Synchronous Systems\\
~\\
{\large Regular Submission}}
\author{Hammurabi Mendes (Davidson College), Maurice Herlihy (Brown University)}
\date{}

\begin{document}

\maketitle

\begin{abstract}
In this paper,
we show that the protocol complex of a Byzantine synchronous system
can remain -connected for up to  rounds,
where  is the maximum number of Byzantine processes,
and .
This topological property implies that
 rounds are necessary to solve -set agreement
in Byzantine synchronous systems,
compared to   rounds in synchronous crash-failure systems.
We also show that our connectivity bound is tight
as we indicate solutions to Byzantine -set agreement in exactly
 synchronous rounds,
at least when  is suitably large compared to .
In conclusion,
we see how Byzantine failures can potentially require \emph{one} extra round
to solve -set agreement, and,
for  suitably large compared to , \emph{at most that}.
\end{abstract}

\section{Introduction}
\label{Sec-Introduction}

A \emph{task} is a distributed coordination problem
where multiple processes start with private inputs,
communicate among themselves (by shared memory or message passing),
and halt with outputs consistent with the task specification.
There are \emph{crash-failure} systems~\cite{DSBook},
where processes can fail only by permanent, unannounced halting,
or \emph{Byzantine-failure} systems~\cite{Lamport1982},
where processes can fail arbitrarily, even maliciously.
In \emph{synchronous} systems,
communication and computation are organized in discrete rounds.
In each round, each non-faulty process performs as follows, in order: (i) sends a message;
(ii) receives all messages sent in the current round by the other processes;
and (iii) performs internal computation.
In \emph{asynchronous} systems,
processes may have different relative speeds,
and communication is subject to unbound, finite delays.

The problem of consensus in the synchronous Byzantine message-passing
model was among the earliest to be investigated,
and upper and lower consensus bounds in that model are well-understood.
In this paper,
we turn our attention to overall computational power of this model,
including bounds for problems such as -set agreement.
We use concepts and techniques adapted from combinatorial topology.
In essence,
we can capture all possible information dissemination patterns
permitted by this model in a single combinatorial structure called a
\emph{simplicial complex} (or just \emph{complex}).
A classical topological property of a simplicial complex is its level
of \emph{connectivity}, which is, roughly speaking, the dimension below
which it has no holes.
Many classical proofs of consensus impossibility can be reformulated
as showing that certain complexes are 0-connected
(also called \emph{path-connected}),
and all known impossibility proofs for -set agreement rely on
showing that certain complexes are -connected.
Very informally, the higher the degree of connectivity imposed by the adversary,
the weaker the model's computational power.
Here, we present the first tight bounds on connectivity for the
synchronous Byzantine message-passing model.

Prior work using topological techniques is discussed in Sec.~\ref{Sec-RelatedWork}.
Our operational setting is detailed in Sec.~\ref{Sec-OperationalModel},
and our topological model is formalized in Sec.~\ref{Sec-TopologicalModel}.

Our \textbf{first contribution} comes in Sec.~\ref{Sec-ConnectivityUpperBound}.
We show that,
in a Byzantine synchronous system,
the protocol complex can remain \emph{-connected} for  rounds,
where  is an upper bound on the number of Byzantine processes.
Perhaps surprisingly,
this is only \emph{one} more round than the upper bound for crash-failure systems
(, shown in~\cite{ChaudhuriHLT2000}).
Technically,
we conceive a combinatorial operator modeling the ability of Byzantine processes
to \emph{equivocate} -- that is,
to transmit ambiguous state information --
without revealing their Byzantine nature.
We compose this operator with regular crash-failure operators,
extending the protocol complex connectivity for one extra round.
As noted, connectivity is of interest because a -connected
protocol complex prevents important problems such as -set
agreement~\cite{ksetagreement,dePriscoMR2001} from having solutions.

Our \textbf{second contribution} comes in Sec.~\ref{Sec-KSetLowerBound}.
We show that the above connectivity bound
is \emph{tight} in certain settings (described in Sec.~\ref{Sec-KSetLowerBound}),
by solving -set agreement in  rounds.
We do so with a full-information protocol that assumes  suitably large compared to .
The protocol suits well our purpose of tightening the  bound,
and also exposes clearly \emph{the reason why}  rounds is enough
to solve -set agreement.

These results give new insight into the power of Byzantine
adversaries for problems beyond consensus.
Although Byzantine adversaries seem much more powerful than
crash-failure ones,
we show that a Byzantine adversary can impose at most \emph{one} additional
synchronous round beyond that imposed by a crash-failure adversary.
In terms of solvability vs. number of rounds,
the penalty for moving from crash to Byzantine failures,
captured by -connectivity in the protocol complex,
can be \emph{quite limited} in synchronous systems,
particularly when  is relatively large compared to .

\section{Related Work}
\label{Sec-RelatedWork}

The Byzantine failure model was initially introduced by Lamport,
Shostak, and Pease~\cite{Lamport1982}.
The use of simplicial complexes to model distributed computations
was introduced by Herlihy and Shavit~\cite{HerlihyShavit1993}.
The asynchronous computability theorem for general tasks in~\cite{HerlihyShavit1999}
details the approach for asynchronous wait-free computation in the
crash-failure model.
This model was recently generalized by~Gafni, Kuznetsov, and Manolescu~\cite{GACT2014}.
Computability in Byzantine asynchronous systems,
where tasks are constrained in terms of non-faulty inputs,
was recently considered in~\cite{MendesHerlihy14}.

The -set agreement problem was originally defined by Chaudhuri~\cite{ksetagreement}.
Alternative formulations with
different validity notions, or failure/communication settings,
are discussed in~\cite{Neiger93,dePriscoMR2001}.
A full characterization of optimal translations between different failure settings
is given in~\cite{BazziNeiger01,NeigerToueg90},
which requires different number of rounds depending on the relation between
the number of faulty processes,
and the number of participating processes.

The relationship between connectivity and the impossibility of -set agreement
is described explicitly or implicitly in~\cite{ChaudhuriHLT2000,HerlihyShavit1999,SaksZ1993}.
Recent work by Casta√±eda, Gonczarowski, and Moses~\cite{CastaMosesBA2013}
considers an issue of chains of hidden values,
a concept loosely explored here.
The approach based on shellability and layered executions for lower bounds in connectivity
has been used by Herlihy, Rajsbaum, and Tuttle~\cite{HerlihyRT98,HerlihyRT09,ConcurrentShellable},
assuming crash-failure systems, synchronous or asynchronous.

\section{Operational Model}
\label{Sec-OperationalModel}

We have  processes\footnote{
Choosing  processes rather than  simplifies the topological notation,
but slightly complicates the computing notation.
Choosing  processes has the opposite trade-off.
We choose  for compatibility with prior work.
}

communicating by message-passing via pairwise, reliable, FIFO channels
(\emph{authenticated channels} in the literature~\cite{RSPBook}).
Technically,
all transmitted messages are delivered uniquely, in FIFO order,
and with sender reliably identified.

At most  processes are \emph{faulty} or \emph{Byzantine}~\cite{Lamport1982},
and may display arbitrary, even malicious behavior, at any point in the execution.
The actual behavior of Byzantine processes
is defined by an \emph{adversary}.
Byzantine processes may execute the protocol correctly or incorrectly,
at the discretion of the adversary.
Processes behaving in strict accordance to the protocol for rounds  up to some  (inclusive)
are called \emph{non-faulty processes up to round },
and are denoted by .
A non-faulty process up to any round  is called simply \emph{non-faulty} or \emph{correct},
which we denote by .

We model processes as state machines.
The input value (resp. output value) of a non-faulty process  is written  (resp. ).
Byzantine processes may have ``apparent'' inputs,
denoted as above.
Each non-faulty process  has an internal state called \emph{view}, which we denote by .
In the beginning of the protocol,  is .
At any round ,
any non-faulty process:
(1) sends its internal state to all other processes;
(2) receives the state information from other processes;
(3) concatenates that information to its own internal state.
After completing some number of iterations,
each process applies a decision function  to its current state in order to decide .
Thus,
we assume that processes follow a \emph{full-information} protocol~\cite{HerlihyRT09}.

For simplicity of notation,
we define a round  where processes are simply assigned their inputs.
Without losing generality,
all processes are assumed non-faulty up to round :
 and .
For any round ,
a \emph{global state} formally specifies:
(1) the non-faulty processes up to round ;
and (2) the view of all non-faulty processes up to round .

\section{Topological Model}
\label{Sec-TopologicalModel}

We now sketch the required concepts from combinatorial topology.
For details, please refer to Munkres~\cite{Munkres84}, Kozlov \cite{Kozlov07}, or Herlihy \emph{et al.}~\cite{MauriceBook}.





\textbf{Basics. }
A \emph{simplicial complex}  consists of a finite set 
along with a collection of subsets of  closed under containment.
An element of  is called a \emph{vertex} of .
The set of vertices of  is referred by .
Each set in  is called a \emph{simplex},
usually denoted by lower-case Greek letters: , etc.
The \emph{dimension}  of a simplex  is .

A subset of a simplex is called a \emph{face}.
The collection of faces of  with dimension exactly  is called .
A face  of  is called \emph{proper} if .
We use ``-simplex'' as shorthand for ``-dimensional simplex'',
also in ``-face.''
The dimension  of a complex is the maximal dimension of its simplexes,
and a \emph{facet} of  is any simplex having maximal dimension in .
A complex is said \emph{pure} if all facets have dimension .
The set of simplexes of 
having dimension at most~ is a subcomplex of ,
which is called \emph{-skeleton} of ,
denoted by .
 


\textbf{Maps. }
Let  and  be complexes.
A \emph{vertex map}  carries vertices of  to vertices of .
If  additionally carries simplexes of  to simplexes of ,
it is called a \emph{simplicial} map.
A~\emph{carrier map}  from  to  takes each
simplex  to a subcomplex ,
such that for all ,
we have .
A simplicial map  is \emph{carried by the carrier map}
 if, for every simplex ,
we have .

Although we defined simplexes and complexes in a purely combinatorial way,
they can also be interpreted geometrically.
An -simplex can be identified with the convex hull of 
affinely-independent points in the Euclidean space of appropriate dimension.
This geometric realization can be extended to complexes.
The point-set that underlies such \emph{geometric complex}  is called
the \emph{polyhedron} of , denoted by .
For any simplex , the \emph{boundary} of , which we denote ,
is the simplicial complex of -faces of .
The \emph{interior} of  is defined as
.

We can define simplicial/carrier maps between geometrical complexes.
Given a simplicial map  (resp. carrier map ),
the polyhedrons of every simplex in  and 
induce a continuous simplicial map  (resp. continuous carrier map ).
We say  (resp. ) is carried by 
if, for any ,
we have  (resp. ).



\textbf{Connectivity.} 
In light of topology,
two geometrical objects  and  are \emph{homeomorphic} if,
there is a continuous map from  into  or vice-versa.
Technically,
there exists a continuous map between those objects, in either direction \cite{Munkres00,Munkres84}.
We say that a simplicial complex 
is \emph{-connected}, ,
if every continuous map
of a subset of  homeomorphic to an -sphere in 
can be extended into
a subset of  homeomorphic to an -disk in .
In analogy,
think of the extremes of a pencil as a -disk,
and the pencil itself as a -sphere (the extension is possible if -connected);
the rim of a coin as a -sphere,
and the coin itself as a -disk (the extension is possible if -connected);
the outer layer of a billiard ball as a -sphere,
and the billiard ball itself as a -disk (the extension is possible if -connected).
For us,
-connected is understood as \emph{non-empty},
and -connected or lower imposes no restriction.



\begin{definition}
\label{definition-pseudosphere}
Let ,
where each  is an arbitrary set and .
A \emph{pseudosphere}  is a simplicial complex where
 if
.
\end{definition}

Essentially,
a pseudosphere
is a simplicial complex formed by independently assigning values to all the specified processes.
If  for all ,
we simply write .



\begin{definition}
\label{definition-shellable}
A pure, simplicial complex  is \emph{shellable} if we can arrange the facets of 
in a linear order  such that

is a pure -dimensional simplicial complex for all .
We call the above linear order  a \emph{shelling order}.
\end{definition}

Intuitively,
a simplicial complex is shellable
if it can be built by gluing its -simplexes along their  faces only,
where  is the dimension of the complex.
Note that  is a shelling order
if any  ()
is contained in a -face of  ().
Hence,

Shellability and pseudospheres are important tools to
characterize connectivity in simplicial complexes.
The following lemmas are proved
in~\cite{ConcurrentShellable} and~\cite{MauriceBook} (pp. 252--253).

\begin{lemma}
\label{lemma-pseudosphere-shellable}
Any pseudosphere  is shellable,
considering arbitrary .
\end{lemma}


\begin{lemma}
\label{lemma-shellable-connected}
For any ,
if the simplicial complex  is shellable and 
then  is -connected.
\end{lemma}




\textbf{Nerve Theorem.} 
Let  be a simplicial complex with a \emph{cover}
,
where  is a finite index set.
The \emph{nerve}  is the simplicial complex with vertexes 
and simplexes  whenever 
We can characterize the connectivity of  in terms of the connectivity of
the intuitively simpler nerve of 
with the next theorem.

\begin{theorem}[Nerve Theorem \cite{Kozlov07,Bjorner1995}]
\label{theorem-nerve}
If for any  denoting a simplex of 
(thus, )
we have that  is -connected,
then  is -connected if and only if  is -connected.
\end{theorem}



\textbf{Protocol Complexes.} 
We represent the evolution of the global state of the system throughout the rounds
by simplicial complexes that we call \emph{protocol complexes}.


\begin{definition}
\label{definition-labeled}
For ,
a \emph{name-view} simplex  is such that:
(i) ,
where  denotes 's view at round ;
and (ii) if  and  are both in ,
then .
\end{definition}

Unless otherwise noted, all of our simplicial and carrier maps  are such that , that is, they map between vertices associated with the same processes.

\begin{definition}
For any name-view simplex , define

and
.
\end{definition}

The round- protocol complex  has
name-view -simplexes ,
representing all the possible process inputs in the beginning of the protocol.
The round- protocol complex ,
for any ,
is defined as follows:
if ,
then ,
representing a possible global state of the system for round .

\section{Connectivity Upper Bound}
\label{Sec-ConnectivityUpperBound}
Informally, if the adversary displays Byzantine behavior early in the execution,
then in a synchronous, full-information protocol,
subsequent communication among the non-faulty processes can reveal
the identities of the Byzantine processes,
using simple techniques inspired from \cite{BazziNeiger01,Bracha,SriTouRB}.
Instead, it behooves the adversary to postpone malicious behavior to
the very last round, where it cannot detected.

Say that non-faulty processes start the computation with inputs in ,
\emph{arbitrarily} assigned,
with some  and .
To prove our upper bound,
we show how the adversary can impose a particular admissible execution
that preserves high connectivity in the protocol complex.

Let  and .
We have  \emph{crash rounds},
where in each round  processes fail by crashing, but display no Byzantine behavior.
If ,
we have an extra \emph{equivocation round},
where a single Byzantine process
sends different views to different processes,
causing extra confusion.
This round-by-round execution produces a sequence of protocol complexes
,
related by carrier maps
,
for ,
and .




In each of the first  rounds,
exactly  processes are failed by the adversary.
The crash-failure carrier maps are defined
as follows~\cite{ConcurrentShellable,MauriceBook}:

\begin{definition}
\label{definition-roundop-crash}
For any ,
the crash-failure operator  is such that

for any ,
with  denoting the set of simplexes  where .
\end{definition}

\begin{definition}
\label{definition-mapconnected}
A \emph{-connected} carrier map  is
a strict carrier map such that, for all ,

and
 is -connected.
\end{definition}

\begin{definition}
\label{definition-mapshellable}
A \emph{-shellable} carrier map  is
a strict carrier map such that, for all ,

and
 is shellable.
\end{definition}

After  rounds,
note that  only contains simplexes with dimension exactly .
In~\cite{ConcurrentShellable,MauriceBook},
the following lemmas are proved:

\begin{lemma}
\label{lemma-crashshellable}
For ,
the operator  is a -shellable carrier map.
\end{lemma}


\begin{lemma}
\label{lemma-compositionshellable}
If  are all -shellable carrier maps,
and  is a -connected carrier map,
the composition  is a -connected carrier map,
for any .
\end{lemma}


\textbf{Equivocation and Interpretation. }
After the crash-failure rounds,
if 
the adversary picks one of the remaining processes to behave maliciously at round .
This process, say , may send different views to different processes
(which is technically called \emph{equivocation}),
but,
informally speaking,
all views are ``plausible.''
For example,
two non-faulty processes  and 
could be indecisive after round  on whether the global state
is  or  in ,
while ,
a Byzantine process,
sends a state corresponding to  to ,
and a state corresponding to  to .
The faulty process  \emph{does not reveal} its Byzantine nature,
yet it \emph{promotes ambiguity} in the state information diffusion.

At the final round,
when a non-faulty process receives the states sent from the other processes,
it must decide correctly even if one other process equivocates.
If the non-faulty process can receive simplexes  and ,
representing global states that differ in only one process's contribution
(that is, ),
then the \emph{interpretation} of a message containing one such state
must be the same as a message containing the other.
We capture this notion using the \emph{equivocation} operator,
called ,
describing the behavior of a Byzantine process,
coupled with an \emph{interpretation} operator,
called ,
describing the required behavior of non-faulty processes.
Informally,

for processes in ,
where  with .
Formally:

\begin{definition}
\label{definition-interp}
For any simplexes  and  in ,
with ,
let  if and only if
; \textbf{or}
 where  and .
\end{definition}

\begin{definition}
\label{definition-roundop-equivocate}
For any pure simplicial complexes  and 
with  and ,
the -equivocation operator  is

\end{definition}
Note that  whenever  or ,
and also that

for any  with .
For convenience of notation,
define .

Next, we investigate some technical properties of these constructions
that allow us to prove that the final complex is -connected.
\begin{lemma}
\label{lemma-eqv:carrier}
For any pure, shellable simplicial complex with ,
the -equivocation operator  is a carrier map.
\end{lemma}
\begin{proof}
Let .
We show that .
If  then 
and  for any .
Otherwise,
if  then  and ,
as we assumed that .
The remaining case is when
 and ,
which makes 
in light of Definition~\ref{definition-roundop-equivocate}.
\end{proof}

Let  be the composite map such that .
While,
for an arbitrary complex ,
 is not a strict carrier map \emph{per se},
we show in the following lemmas that  is a -connected carrier map.
Lemma~\ref{lemma-lasttwo:strict} shows that  is a strict carrier map,
and Lemma~\ref{lemma-lasttwo:conn} shows that
for any ,
 is -connected.

\begin{lemma}
\label{lemma-lasttwo:strict}
 is a strict carrier map.
\end{lemma}
\begin{proof}
Consider ,
with  and .
Both  and  are pure, shellable simplicial complexes with dimension 
(Definition~\ref{definition-roundop-crash} and Lemma~\ref{lemma-crashshellable}).
Therefore,
both the -equivocation and -equivocation operators are well-defined.
Also,  is a strict carrier map,
hence .
Note that ,
if not empty,
is a pure, shellable simplicial complex with dimension .
Therefore,
the -equivocation operator is well-defined.

First, we show that ,
which implies one direction of our equality:

For clarity, let . Then,

For arbitrary  and ,
if , consider two cases:
\begin{enumerate}
\item
 and  are proper faces of .
In this case,

which is inside .

\item
Otherwise,  or .
In this case,

By Definition~\ref{definition-interp},
the above is non-empty only when
 with ,
 with ,
and there exists a non-empty set 
such that ,
where  with .
Let  be a maximal  satisfying such condition.
Note that , so .

Since  is non-empty,
it is pure, shellable with dimension ,
there must exist a simplex  with dimension .
Moreover,

and

for processes in ,
given the definition of .
In conclusion, we have
,
which is inside .
\end{enumerate}

In the other direction,
we have
,
since
(i)  for any 
(Definition~\ref{definition-roundop-equivocate});
and (ii)
 is a carrier map (Lemma~\ref{lemma-eqv:carrier}).
The same argument proves that ,
and therefore .
\end{proof}


\begin{lemma}
\label{lemma-lasttwo:conn}
For any ,
 is
-connected.
\end{lemma}
\begin{proof}
Consider  with .
By Lemma~\ref{lemma-crashshellable},
 is a pure, shellable simplicial complex with .
By Definition~\ref{definition-roundop-equivocate},
 is well-defined and
.
Note that ,
since  and .

First,
we show that  is ``highly-connected'' -- that is, -connected.
We proceed by induction on ,
a shelling order of facets of .
\begin{description}
	\item[Base.] We show that  is -connected.
Considering Definition~\ref{definition-roundop-equivocate},
we have that ,
with  being all the proper faces of .


Consider the cover  of ,
and its associated nerve .
For any index set ,
let

For any  with ,
we have ,
making  a non-empty pseudosphere
with dimension .
So,  is -connected
by Lemmas~\ref{lemma-pseudosphere-shellable} and~\ref{lemma-shellable-connected}.
The nerve is hence the -skeleton of ,
which is -connected.
By the Nerve Theorem,
 is also -connected.


	\item[IH.] Assume that  is  connected,
and let .
We must show that  is -connected.
Note that  is -connected by an argument identical to the one above for the base case .
Besides,

where  is such that .
The set  is well-defined since  is shellable.
The step  holds because:
(i)  must include at least ;
and (ii)  only if
 exists,
the latter inside 
for some ,
or we contradict the fact that  is shellable.


Using an argument identical to the one for ,
yet considering the cover ,
the nerve of  is either the -skeleton of  (if ) or the whole simplex  (otherwise).
By the Nerve Theorem,
 is -connected.

Once again,
using the Nerve Theorem,
since  is -connected,
 is -connected,
and  is -connected,
we have that  is -connected.
\end{description}
While the equivocation operator yields high connectivity ()
in the pseudosphere ,
the \emph{composition} of  and 
limits the connectivity to ,
since the former map is only defined for simplexes with codimension .
Formally,
as  for any simplex  with ,
we have that  is -connected.
\end{proof}

From Lemmas~\ref{lemma-lasttwo:strict} and~\ref{lemma-lasttwo:conn},
we conclude the following.
\begin{corollary}
\label{corollary-lasttwo:conn}
 is a -connected carrier map.
\end{corollary}

\begin{theorem}
An adversary can keep the protocol complex of a Byzantine synchronous system -connected
for  rounds.
\end{theorem}
\begin{proof}
If ,
,
and the adversary runs only the crash rounds failing  processes each time,
for  consecutive rounds.
We have the following scenario:

Since  is a -shellable carrier map
for  (Lemma~\ref{lemma-crashshellable}),
the composition 
is a -connected carrier map for any facet 
(Lemma~\ref{lemma-compositionshellable}).

If ,
the adversary performs  crash rounds (failing  processes each time),
followed by the extra equivocation round.
We have the following scenario:

Since  is a -shellable carrier map
for  (Lemma~\ref{lemma-crashshellable}),
and  is a -connected carrier map
(Corollary~\ref{corollary-lasttwo:conn}),
we have that the composition above 
is a -connected carrier map for any facet 
(Lemma~\ref{lemma-compositionshellable}).
\end{proof}

\section{-Set Agreement and Lower Bound}
\label{Sec-KSetLowerBound}

\begin{comment}
The -set agreement problem~\cite{ksetagreement},
is a fundamental task having important associations
with protocol complex connectivity.
In Byzantine systems,
it can be difficult to characterize the input of a faulty process,
since this process can ignore its ``prescribed'' input and behave as having a different one.
This intrinsically leads to many alternative formulations for the problem in Byzantine systems \cite{dePriscoMR2001}.

Here,
we adopt a formulation that is intended both to make sense in practice,
and to have implications on our connectivity arguments discussed before.
Each non-faulty process  starts with \emph{any} value  from ,
with  and ,
and finishes with a value  from , respecting:
\textbf{(1)~Agreement.}
At most  values are decided: .
\textbf{(2)~Strong Validity.}
For any non-faulty process , the output  is the input value of a non-faulty process.
\textbf{(3)~Termination.}
The protocol finishes in a finite number of rounds.

\begin{definition}
\label{definition-task}
A Byzantine, synchronous -set agreement task is a triple  where
\begin{enumerate}[noitemsep]
	\item
 is a pseudosphere , with , representing the input of the non-faulty processes.
We have  since, for any input assignment, we have an admissible execution where all processes are benign.
	\item
 is  where , representing the output of the non-faulty processes.
We have  since, for any output assignment, we have an admissible execution where all processes have been benign.
	\item
 where if ,
then , , and .
\end{enumerate}
\end{definition}
\end{comment}

The -set agreement problem and connectivity are closely related.
Lemma~\ref{lemma-connectivitykset},
proved in Appendix~\ref{App-ProofsConnectivity},
shows that
no solution is possible for -set agreement
with a -connected protocol complex,
which,
as seen in Sec.~\ref{Sec-ConnectivityUpperBound},
can occur at least until round .
\begin{lemma}
\label{lemma-connectivitykset}
If, starting ,
the protocol complex  is -connected,
then no decision function  solves the -set agreement problem.
\end{lemma}


We now present a simple -set agreement algorithm
for Byzantine synchronous systems,
running in  rounds.
The procedure requires a relatively large number of processes compared to :
we assume .
The procedure was designed 
with the purpose of tightening the connectivity lower bound,
favoring simplicity over the optimality on the number of processes.

Non-faulty processes initially execute a \emph{gossip phase}
for  rounds,
followed by a \emph{validation phase},
and a \emph{decision phase},
where the output is chosen.
Define ,
and consider the following tree,
where nodes are labeled with words over the alphabet .
The root node is labeled as ,
which represents an empty string.
Each node  such that 
has  child nodes labeled  for all .
Any non-faulty process  maintains such tree,
denoted .

All nodes  are associated with the value ,
called the \emph{contents} of .
The special value  represents an absent input.
We omit the subscript  when the process is implied or arbitrary.
We divide the processes into  disjoint groups: ,
for .
For any tree ,
we call  the subtree of  having only nodes  such that .

\begin{algorithm}[htb]
\caption{}
\label{Alg-Agree}
\begin{algorithmic}[1]
\If{}
	\State \Return 
\EndIf
\State  for all 
\State  \Comment{Gossip}
\For{}
	\State 
	\Upon{ from }
		\State  for all 
	\EndUpon
\EndFor \label{algAgree:gossip}
\State  \Comment{Validation}
\If{}
	\State Apply completion rule for all  where  and 
\EndIf
\State  any  such that  is pivotal \label{algAgree:dec1} \Comment{Decision}
\For{}
	\State Apply consensus rule for all non-validated  where  and  \label{algAgree:dec2}
\EndFor
\State \Return 
\end{algorithmic}
\end{algorithm}

In the validation phase,
if we have a set  containing  processes that acknowledge
all messages transmitted by process  (making sure that ),
at every round ,
we call such set the \emph{quorum} of ,
denoted .
Formally,

such that ,
,
and  whenever  implies ,
for any  with .
It should be clear that every non-faulty process has a quorum containing at least
all other non-faulty processes.
If a process  has a quorum as seen by process ,
we say that  has been \emph{validated} on ,
for any  with 
(and that  has been validated on ).
Note that in our definition either all entries  for  are validated,
or none is.
Lemma~\ref{lemma-validated-identical},
proven in Appendix~\ref{App-ProofsAlgorithm},
shows that validated entries are unique across non-faulty processes.
\begin{lemma}
\label{lemma-validated-identical}
If  has been validated on non-faulty processes  and ,
then  for any .
\end{lemma}


In the decision phase,
if we see  processes without a quorum,
we have technically identified all non-faulty processes .
In this case,
we fill -th round values of any  using the \emph{completion} rule:
we make  if we have  processes 
where 
for any  and .
If a process  has its -round values
completed as above in process ,
we say that  has been \emph{completed} on  for any .
Lemma~\ref{lemma-validated-completed},
proven in Appendix~\ref{App-ProofsAlgorithm},
shows that completed entries are identical and consistent
with validated entries across non-faulty processes.
(Intuitively,
the completion rule was done over identical values from correct processes.)
\begin{lemma}
\label{lemma-validated-completed}
If  has been completed or validated on a non-faulty process ,
and  has been completed on a non-faulty process ,
then .
\end{lemma}


We have two possible cases:
(i) there is a subtree  with less than 
non-validated processes --
call such subtree \emph{pivotal};
or (ii) no such tree exists,
in which case we apply the completion rule to -round values in ,
and define  as our pivotal subtree instead.
A pivotal subtree, therefore, must exist according to the definition above.


Denote the set of processes in the word  as .
For any non-validated  with  in a pivotal subtree ,
where ,
we establish consensus on .
We apply the \emph{consensus} rule:
 if the majority of processes in 
is such that .
This rule is applied first to entries labeled  where ,
and then moving upwards (please refer to Alg.~\ref{Alg-Agree}).
Our algorithm is essentially
separating the possible chains of unknown values across disjoint process groups,
which either forces one of these chains to be smaller than ,
or reveals all faulty processes,
giving us the ability to perform the completion rule.
This fundamental tradeoff underlies our algorithm,
and ultimately explains \emph{why} the  connectivity bound is tight.
Lemma~\ref{lemma-consensus-pivotal},
proven in Appendix~\ref{App-ProofsAlgorithm},
shows that the consensus rule indeed establishes consensus
across non-faulty processes that identify  as the pivotal subtree.

\begin{comment}
The decision is based on values resulting from consensus on ,
taking the minimum element appearing at least  times.
Define the multiset 
after applying the consensus rule,
and let .
Lemma~\ref{lemma-decision-pivotal},
proven in Appendix~\ref{App-ProofsAlgorithm},
shows that,
since ,
such value exists,
and we can decide on a value that has been necessarily input by a non-faulty process.
\end{comment}

\begin{lemma}
\label{lemma-consensus-pivotal}
For any two-non-faulty processes  and  that applied the consensus rule on a pivotal subtree ,
with ,
we have that  for any .
\end{lemma}


\begin{comment}
\begin{lemma}
\label{lemma-decision-pivotal}
For any two-non-faulty processes  and  that decide based on a pivotal subtree ,
with ,
the decision value
(i) is well-defined;
and (ii) is an input value of a non-faulty process.
\end{lemma}
\end{comment}

\begin{theorem}
\label{theorem-ksetcorrectness}
Algorithm~\ref{Alg-Agree} solves -set agreement
in  rounds.
\end{theorem}
\begin{proof}
Termination is trivial,
as we execute exactly  rounds. 
By Lemma~\ref{lemma-consensus-pivotal},
each pivotal subtree yields a unique decision value.
As we have at most  pivotal subtrees identified across non-faulty processes,
up to  values are possibly decided across non-faulty processes.
\end{proof}

\section{Conclusion}

In Byzantine synchronous systems,
the protocol complex can remain -connected for  rounds,
potentially \emph{one} more round than in crash-failure systems.
We conceive a combinatorial operator modeling the ability of Byzantine processes
to equivocate without revealing their Byzantine nature,
just after  rounds of crash failures.
We compose this operator with the regular crash-failure operators,
extending -connectivity up to  rounds.
We tighten this bound,
at least when  is relatively large compared to ,
via a full-information protocol
that solves a formulation of -set agreement.

It may be surprising that Byzantine failures
impose only \emph{one} additional synchronous round over the crash-failure model,
and \emph{at most that} in our standard setting,
where inputs are arbitrarily attributed to processes,
and the number of processes is strictly bigger than .
In terms of solvability vs. number of rounds,
the penalty for moving from crash to Byzantine failures
can thus be \emph{quite limited}.
Previous work has hinted this possibility operationally, since
(i) in synchronous systems where  is large enough compared to ,
we can simulate crash failures on Byzantine systems with a 1-round delay~\cite{BazziNeiger01};
and (ii) techniques similar to the reliable broadcast of~\cite{Bracha,SriTouRB}
deal with the problem of Byzantine equivocation,
also with a 1-round delay.
This extra round is crucial -- but enough -- to limit the impact of Byzantine behavior
in rather usual operational settings.



\newpage

\appendix

\section{Appendix: Proofs for the Connectivity Arguments}
\label{App-ProofsConnectivity}

\noindent \textbf{Proof of Lemma~\ref{lemma-connectivitykset}}
\begin{proof}
Consider a -simplex  with  different inputs.
Let  for any ,
and .
We construct a sequence of continuous maps 
where  is homeomorphic to  in .

\textbf{Base.} Let  map any vertex  to a vertex in .
We know that  is -connected since  and  is a -connected carrier map.
We just constructed

where  is isomorphic to a  in .

\textbf{Induction Hypothesis.} Assume  for any ,
where  is isomorphic to  in . 
For any ,
we have that  is -connected,
hence the continuous image of the -sphere in 
can be extended to the continuous image of the -disk in .
We just constructed

where  is isomorphic to  in .
In the end,
we have  where  is isomorphic to  in .

Now suppose,
for the sake of contradiction,
that -set agreement is solvable,
so there must be a simplicial map  carried by .
Then,
induce the continuous map  from  such that
 if ,
for any .
Also,
note that the composition of  with the continuous map 
induces another continuous map ,
since by assumption  never maps a -simplex of  to a simplex with  different views
(so  never maps a point to ).
We built a \emph{continuous retraction} of  to its own border ,
a contradiction (please refer to~\cite{Munkres84,Kozlov07}).
Since our assumption was that there existed
a simplicial map  carried by ,
we conclude that -set agreement is not solvable.
\end{proof}

\section{Appendix: Proofs for the -Set Agreement Procedure}
\label{App-ProofsAlgorithm}

\noindent \textbf{Proof of Lemma~\ref{lemma-validated-identical}.}
\begin{proof}
If  has been validated on ,
then  implies  for  different processes ,
and  implies  for  different processes ,
for any .
As we have at most  non-faulty processes and ,
,
containing at least one non-faulty process that,
by definition,
broadcasts values consistently in its run.
Hence,  and  must be identical.
\end{proof}

\noindent \textbf{Proof of Lemma~\ref{lemma-validated-completed}}
\begin{proof}
If  has been validated on ,
 implies  for  different processes .
When  applies the completion rule on ,
then  for  different processes ,
as we have at most  faulty processes.
Therefore,
.

If  has been completed on all non-faulty processes,
they all have identified  faulty processes,
and the completion rule is performed over identical entries associated with non-faulty processes.
Therefore,
 as well.
\end{proof}

\noindent \textbf{Proof of Lemma~\ref{lemma-consensus-pivotal}}
\begin{proof}
Consider a non-faulty process  establishing the value of 
with the consensus rule.
Define  for any  with ,
noting that  as  and .

Consider two cases:
(i) if  has been validated at a non-faulty process  with ,
at most  values from 
will be different than .
Hence, there will always be a majority of values in  that will contain ,
because .
(ii) otherwise, if  has not been validated at any non-faulty process,
all  values are being calculated over consistent values,
by Lemma~\ref{lemma-validated-completed},
which makes all non-faulty processes establish  consistently with the consensus rule.
\end{proof}

\begin{comment}
\noindent \textbf{Proof of Lemma~\ref{lemma-decision-pivotal}}
\begin{proof}
By Lemma~\ref{lemma-consensus-pivotal},
every process  from  will have an associated value 
resulting from the consensus rule,
and this value is consistent across non-faulty processes that decide based on .
If ,
 must be 's input ,
as  is necessarily validated.
Since we have at most  faulty processes and ,
more than  values are inputs of non-faulty processes,
and since we have at most  input values,
one value must appear  times.
Therefore,
our decision function is well-defined.

Since non-faulty processes that decide on 
decide consistently on a multiset of consistent values,
the decision is identical across those processes.
Also,
any value appearing at least  times must have been input
by a non-faulty process,
as we have at most  faulty processes.
\end{proof}
\end{comment}

\bibliography{Bibliography.bib}
\bibliographystyle{abbrv}

\end{document}
