\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=.8in]{geometry}
\usepackage{graphicx}
\usepackage{amsmath,lettrine}
\usepackage{gastex}

\def\proof{\noindent{\it Prova}. \ignorespaces}
\def\endproof{\hfill\vbox{\hrule height0.6pt\hbox{\vrule height1.3ex width0.6pt\hskip0.8ex
   \vrule width0.6pt}\hrule height0.6pt
  }}
  

\newtheorem{definicao}{Definition}
\newtheorem{lema}{Lemma}      
\newtheorem{fato}{Fact}      

\newcommand{\tr}{\mbox{\rm\emph{trie}}}
\newcommand{\trc}{\mbox{\rm\emph{trie} condensada}}

\newcommand{\rk}[1]{\mbox{\rm{rank}}(#1)}
\newcommand{\sk}[1]{\mbox{\rm{sketch}}(#1)}

\newcommand{\trs}[1]{\mbox{\rm{BuscaTrie}}(#1)}
\newcommand{\dlt}[2]{\Delta(#1,#2)}

\sloppy
\linespread{1.5}

\begin{document}



\title{Fusion Tree Sorting}




\author{Luis A. A. Meira \\ \small School of Technology  \\ \small University of Campinas, Brazil \and Rogério H. B. de Lima \\ \small Institute of Science and Technology \\ \small Federal University of S\~{a}o  Paulo, Brazil }

\maketitle




\begin{abstract}
 The sorting problem is one of the most relevant problems in computer science. Within the scope of modern computer science it has been studied for more than 70 years. In spite of these facts, new sorting algorithms have been developed in recent years. Among several types of sorting algorithms, some are quicker; others are more economic in relation to space, whereas others insert a few restrictions in relation to data input. This paper is aimed at explaining the fusion tree data structure, which is responsible for the first sorting algorithm with complexity time smaller than . The  time complexity has led to some confusion and generated the wrong belief in part of the community of being the minimum possible for this type of problem.
\end{abstract}

\section{Introduction}



The sorting problem is perhaps the most studied problem in Computer Science. Its use is implicit in intermediate stages of almost all existing programs, such as database, spreadsheets, multimedia, etc. In addition, sorting has been studied by computer science for over 70 years. The currently and broadly used merge sort algorithm was proposed by Von Neumann in 1945~\cite{cormen}.
 
 The sorting problem consists of receiving a sequence  of  numbers as input. The solution consists of a nondecreasing permutation   of . Although this work is focused on integers, the extension for rationals, floating point and character strings tend to be straight.
 



 All the sorting algorithms present characteristics that make them somehow more or less competitive in relation to their peers. Some of these characteristics are the sorting type, either stable or non-stable, extra space utilization for algorithm execution, and sorting time. Some algorithms can be quicker than others, depending on the characteristics of input data. For instance, selection sort tends to be advantageous when  is small. Insertion sort tends to be rapid when the vector is partially sorted. Counting sort is advantageous when the difference between the maximum and the minimum element is limited. 
 



The most broadly known sorting algorithms are comparison-based ones, such as merge sort, heap sort, insertion sort and quick sort, in addition to the counting-based ones, such as, for example, counting sort, bucket sort and radix sort. The counting-based algorithms require an input sequence with some restrictions. When such restrictions are satisfied, these algorithms can solve the sorting problem in linear time.




There is a lower bound of  comparisons for sorting algorithms~\cite{knuth}. Such limit is based on a decision tree with  leaves, each of them representing an input vector permutation. Each permutation is a candidate to solve the problem. Provided that a comparison can distinguish two branches of a tree, a minimum of  comparisons are required to sort a vector through a comparison-based sorting algorithm in the worst case. This lower bound was misinterpreted, thus generating a false belief in a part of the community in terms that sorting is a   problem. Such limit does not apply, for example, to algorithms using other operations rather than comparisons during the sorting process. The counting sort is able to sort a vector without performing any kind of comparison between the elements.




The algorithm under analysis in this paper is a comparison-based one and makes   comparisons. However,  numbers are compared in . This means that multiple operations are performed in constant time. The following paragraph was extracted from~\cite{cormen}:



\begin{quote}
``The case of sorting  -bit integers in  time has been considered by many researchers. Several positive results have been obtained, each under slightly different assumptions about the model of computation and the restrictions placed on the algorithm. All the results assume that the computer memory is divided into addressable -bit words. Fredman and Willard~\cite{fredman} introduced the fusion tree data structure and used it to sort  integers in . This bound was later improved to  time by Andersson~\cite{arne1}. These algorithms require the use of multiplication and several precomputed constants. Andersson, Hagerup, Nilsson, and Raman~\cite{arne2} have shown how to sort  integers in  time without using multiplication, but their method requires storage that can be unbounded in terms of . Using multiplicative hashing, we can reduce the storage needed to , but then the   worst-case bound on the running time becomes an expected-time bound. Generalizing the exponential search trees of Andersson~\cite{arne1}, Thorup~\cite{thorup} gave an -time sorting algorithm that does not use multiplication or randomization, and it uses linear space. Combining these techniques with some new ideas, 
Han~\cite{han} improved the bound for sorting to  time. Although these algorithms are important theoretical breakthroughs, they are all fairly complicated and at the present time seem unlikely to compete with existing sorting algorithms in practice".
\end{quote}


Results: The sorting algorithm  under analysis in this paper is known to the literature. Our contribution consists of detailing the fusion tree data structure and the related sorting algorithm  proposed 
by~\cite{fredman}. 







\subsection{Computational Model}


Consider a computer working with -bit words. This computer is able to perform elementary operations such as addition, subtraction, multiplication, division, and remainders with -bit integers in constant time. For example, a 64-bit computer has the capacity of processing 64 bits in constant time.



The general sorting case deals with integers with an arbitrary precision. For an integer with -bits, it is required  accesses to the memory before completing the number reading. This paper works with the restricted sorting case where numbers are integers with  bits. Such numbers are in the range   stored as binary integers, with 1 bit for the signal. Some special attention is needed to deal with repeated numbers. Thus, no repetition is assumed to simplify the explanation.






This work considered a computational model that is able to read and write any memory position in constant time, which is known as RAM memory. The RAM memory model is acceptable, though coexisting with the sequential access memory model. In the sequential access memory model, the tape needs to be moved up to the desired position before reading, thus spending linear time to read an integer. The merge sort algorithm is famous for keeping the complexity  even in a sequential memory model.





It is reasonable to assume that the computer is capable of processing  bits in constant time. In the case of  integers of  bits in the memory, the maximum memory address will have at least  bits. The assumption that it is possible to access any position in the memory in constant time is equivalent to the computer processing 
addresses of  bits in constant time. Notice that the number of bits in the problem is . This means that one operation for each bit is .




For a better understanding of the sorting process, we shall first show how to sort  numbers using the B-tree data structure. The fusion tree data structure was proposed by~\cite{fredman} and it is a modified B-tree.




\section{B-Trees}

B-trees are balanced search trees with a degree , where , for constant . Each node contains a minimum of  children and a maximum of  children, except for the leaves, which contain no child, and the root-node, which does not present restriction in the minimum number of children. Each node has  keys, and all the leaves are found in the same level. Notice that a degree-4 node has three keys. Figure~\ref{fig_arvoreB} illustrates a full B-tree, where all the nodes have  keys.




\begin{figure}[htb]
	\begin{center}
	\begin{picture}(50,50)(0,0)
	\node[Nadjust=wh,linecolor=white](CR)(0,26){\footnotesize } 
	\node[Nadjust=wh,linecolor=white](CR)(22,26){\footnotesize } 
	\node[Nadjust=wh,linecolor=white](CR)(50,26){\footnotesize } 	
\node[Nadjust=wh,Nmr=1](A)(25,45){\footnotesize} 
	\node[Nadjust=wh,Nmr=1](B1)(0,30){\footnotesize } 
	\node[Nadjust=wh,Nmr=1](B2)(22,30){\footnotesize } 
	\node[Nadjust=wh,Nmr=1](B3)(50,30){\footnotesize } 
	\node[Nadjust=wh,linecolor=white](BR)(36,30){\footnotesize } 
        \node[Nadjust=wh,linecolor=white](CR)(36,5){\footnotesize } 
	\drawedge[ATnb=0,AHnb=1](A,B1){} 
	\drawedge[ATnb=0,AHnb=1](A,B2){} 
	\drawedge[ATnb=0,AHnb=1](A,B3){} 
	\node[Nadjust=wh,Nmr=1](D)(25,20){\footnotesize} 
	\node[Nadjust=wh,Nmr=1](C1)(0,5){\footnotesize } 
	\node[Nadjust=wh,Nmr=1](C2)(22,5){\footnotesize } 
	\node[Nadjust=wh,Nmr=1](C3)(50,5){\footnotesize } 
	\drawedge[ATnb=0,AHnb=1](D,C1){} 
	\drawedge[ATnb=0,AHnb=1](D,C2){} 
	\drawedge[ATnb=0,AHnb=1](D,C3){} 	 
	\end{picture}	
	\caption{A full B-tree data structure.}
	\label{fig_arvoreB}
	\end{center}
\end{figure}


In addition, the B-tree respects the following property: Each non-root node has  sorted elements 
. Each non-leaf and non-root node has  children  ( where each child is a B-tree. The elements in the  tree are smaller than . The elements in  are greater
 than  and smaller than . The elements in  are all greater than . See Figure~\ref{fig_noArvoreB}. 





\begin{figure}[htb]
	\begin{center}
		\begin{picture}(50,15)(0,0)
\node[Nadjust=wh,Nmr=1,linecolor=white](b1)(4.5,8.5){} 
		\node[Nadjust=wh,Nmr=1,linecolor=white](b2)(21.5,8.5){} 
			\node[Nadjust=wh,Nmr=1,linecolor=white](b3)(45,8.5){} 	
	\node[Nadjust=wh,Nmr=1](A)(25,10){\footnotesize} 
	\node[Nadjust=wh,Nmr=1,linecolor=white](f1)(0,0){\footnotesize} 
	\node[Nadjust=wh,Nmr=1,linecolor=white](f2)(21.5,0){\footnotesize} 
	\node[Nadjust=wh,Nmr=1,linecolor=white](f3)(50,0){\footnotesize} 
	\drawedge[ATnb=0,AHnb=1](b1,f1){} 
	\drawedge[ATnb=0,AHnb=1](b2,f2){} 
	\drawedge[ATnb=0,AHnb=1](b3,f3){} 	
	\end{picture}	\caption{The structure of a B-tree node.}
	\label{fig_noArvoreB}
	\end{center}
\end{figure}


Searching a key  in a B-tree node requires finding the correct child  to continue the search. If , the search continues int  child. If , the search continues in  child. If , the search continues in  child, between  and . The B-tree operations complexity time are related to its height. The following lemma is based in~\cite{cormen}.







\begin{lema}
A B-tree with degree   and height  respect:




\end{lema}




A sequential search is made to search a key  in a B-tree node. Such search takes  and it is repeated in each B-tree level in the worst case. The result is an  overall time to search the key. As  is constant, the complexity is equivalent to .





The key insertion needs an initial search to find the recipient node. If such node is incomplete, the key can be accommodated into the node in . It is the cost to insert an element in a central position of a vector with  elements. If the recipient node is full, it must be split. See Figure~\ref{fig_separaArvoreB}.  Let  be the vector median. Such element is inserted in the parent node. One node is created with the elements smaller than  and other with the elements greater than . Such nodes become the left and the right child of  respectively. Both nodes have exactly  keys.



A vector can be split in half in  through elementary operations. If the parent node is complete, it must be also split. Such process can propagate up to the root.



\begin{figure}[htb]
	\begin{center}
\begin{picture}(81,25)(0,0)
\node[Nframe=n,Nadjust=wh,Nmr=1](i6)(6,9){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](f6)(6,1){\tiny} 
	\drawedge[ATnb=0,AHnb=1](i6,f6){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](i1)(17,19.1){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](f1)(17,11.2){} 
	\drawedge[ATnb=0,AHnb=1](i1,f1){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](i20)(63.5,18.8){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](f20)(58,11.2){} 
	\drawedge[ATnb=0,AHnb=1](i20,f20){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](i21)(65.5,18.8){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](f21)(72,11.1){} 
	\drawedge[ATnb=0,AHnb=1](i21,f21){} 	
	\node[Nframe=n,Nadjust=wh,Nmr=1](i7)(21.5,8.7){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](f7)(21.5,1){\tiny} 
	\drawedge[ATnb=0,AHnb=1](i7,f7){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](i8)(25,8.7){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](f8)(25,1){\tiny} 
	\drawedge[ATnb=0,AHnb=1](i8,f8){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](i9)(28,9){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](f9)(28,1){\tiny} 
	\drawedge[ATnb=0,AHnb=1](i9,f9){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](i2)(18.5,8.7){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](f2)(18.5,1){\tiny} 
	\drawedge[ATnb=0,AHnb=1](i2,f2){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](i3)(15.5,8.7){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](f3)(15.5,1){\tiny} 
	\drawedge[ATnb=0,AHnb=1](i3,f3){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](i4)(12.5,8.7){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](f4)(12.5,1){\tiny} 
	\drawedge[ATnb=0,AHnb=1](i4,f4){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](i5)(9,8.7){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](f5)(9,1){\tiny} 
		\drawedge[ATnb=0,AHnb=1](i5,f5){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](i17)(53.5,8.7){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](f17)(53.5,1){\tiny} 
	\drawedge[ATnb=0,AHnb=1](i17,f17){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](i18)(56.5,8.7){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](f18)(56.5,1){\tiny} 
	\drawedge[ATnb=0,AHnb=1](i18,f18){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](i19)(60,8.7){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](f19)(60,1){\tiny} 
	\drawedge[ATnb=0,AHnb=1](i19,f19){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](i12)(63,9){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](f12)(63,1){\tiny} 
	\drawedge[ATnb=0,AHnb=1](i12,f12){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](i13)(67,9.2){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](f13)(67,1){\tiny} 
	\drawedge[ATnb=0,AHnb=1](i13,f13){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](i14)(70.4,9){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](f14)(70.4,1){\tiny} 
	\drawedge[ATnb=0,AHnb=1](i14,f14){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](i15)(74,9){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](f15)(74,1){\tiny} 	
	\drawedge[ATnb=0,AHnb=1](i15,f15){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](i16)(77,9.3){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](f16)(77,1){\tiny} 	
	\drawedge[ATnb=0,AHnb=1](i16,f16){} 		
		\node[Nframe=n,Nadjust=wh](x)(30,15){} 	
		\node[Nframe=n,Nadjust=wh](y)(50,15){} 	
		\drawedge[ATnb=0,AHnb=1,linewidth=.4,AHLength=2.5](x,y){Split} 	
		\drawedge[ELside=r](x,y){} 			
\node[Nadjust=wh,Nmr=1](A1)(17,20){\footnotesize  N W } 
	\node[Nadjust=wh,Nmr=1](B1)(17,10){\footnotesize P Q R {\bf S} T U V} 
	\node[Nadjust=wh,Nmr=1](A2)(65,20){\footnotesize  N {\bf S} W } 
	\node[Nadjust=wh,Nmr=1](A)(58,10){\footnotesize P Q R} 
	\node[Nadjust=wh,Nmr=1](A)(72,10){\footnotesize T U V} 
	\end{picture}	

	\caption{Key insertion int a complete B-tree node~\cite{cormen}.}
	\label{fig_separaArvoreB}
	\end{center}
\end{figure}



If such process propagate to root, the split will have complexity . Such worst case complexity can be improved by an amortized analysis. Each split has an  cost and it creates an additional node. As the insertion of  elements creates  nodes, the overall cost will be . The split cost considering the insertion of  element takes , although a single insertion can waste .
Ignoring the split cost, each insertion will cost , which is the cost to search a key in the tree plus the cost to insert a key in a node. 




To sort a sequence with  elements using a B-tree, all elements must be inserted in an initially empty tree.
An in-order traversal result in a sorted sequence. See Figure~\ref{fig_pesquisaOrdenadaArvoreB}. The solid arrows represent the tree traversal path. The dashed arrows represent the reading sequence. Each arrow has an integer representing the traversal sequence.




The complexity time to sort  integers is the sum of the time to insert  keys in the tree that is . If  is a constant, such complexity will be .




\begin{figure}[h!]
	\begin{center}
	\begin{picture}(80,60)(0,0)
\node[Nframe=n,Nadjust=wh,Nmr=1](R)(70,58){Root} 
	\node[Nadjust=wh,Nmr=1](n1)(60,50){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](i1)(34.6,28.2){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](i2)(39.5,28.1){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](i3)(46.4,28.2){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](i4)(51.4,28.2){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](i5)(53,48.2){} 	
	\node[Nframe=n,Nadjust=wh,Nmr=1](i6)(60,48.2){} 	
	\node[dash={.5}0,Nadjust=wh,Nmr=1](x1)(7,54){\scriptsize} 
	\node[dash={.5}0,Nadjust=wh,Nmr=1](x1)(4,0){\scriptsize} 
	\node[dash={.5}0,Nadjust=wh,Nmr=1](x1)(9.5,0){\scriptsize} 
	\node[dash={.5}0,Nadjust=wh,Nmr=1](x1)(16,0){\scriptsize} 	
	\node[dash={.5}0,Nadjust=wh,Nmr=1](x1)(27,0){\scriptsize} 	
	\node[dash={.5}0,Nadjust=wh,Nmr=1](x1)(33,0){\scriptsize} 	
	\node[dash={.5}0,Nadjust=wh,Nmr=1](x1)(47,0){\scriptsize} 	
	\node[dash={.5}0,Nadjust=wh,Nmr=1](x1)(53,0){\scriptsize} 			
	\node[dash={.5}0,Nadjust=wh,Nmr=1](x1)(63,0){\scriptsize}
	\node[dash={.5}0,Nadjust=wh,Nmr=1](x1)(70,0){\scriptsize}
	\node[dash={.5}0,Nadjust=wh,Nmr=1](x1)(77,0){\scriptsize}
	\node[dash={.5}0,Nadjust=wh,Nmr=1](x1)(36,35){\scriptsize} 	
	\node[dash={.5}0,Nadjust=wh,Nmr=1](x1)(43,35){\scriptsize} 	
	\node[dash={.5}0,Nadjust=wh,Nmr=1](x1)(53,35){\scriptsize} 		
	\node[dash={.5}0,Nadjust=wh,Nmr=1](x1)(56,55){\scriptsize} 
			
	\node[Nframe=n,Nadjust=wh,Nmr=1](X)(20,58){\scriptsize ~Advance.~~~~~~~~~~~~} 	
	\node[Nframe=n,Nadjust=wh,Nmr=1](X)(20,54){\scriptsize ~~~~~~ Reading the key.~~~~~} 
	\drawedge[ATnb=0,AHnb=1](R,n1){} 
	\node[Nadjust=wh,Nmr=1](n2)(43,30){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](n3)(75,30){} 
	\drawedge[ATnb=0,AHnb=1,ELpos=40,ELside=r,ELdist=0](i5,n2){\scriptsize} 
	\drawedge[ATnb=0,AHnb=1,ELpos=40,ELdist=0](i5,n2){\scriptsize} 
	\drawedge[ATnb=0,AHnb=1,ELpos=40,ELdist=0](i6,n3){\scriptsize} 
	\node[Nadjust=wh,Nmr=1](n4)(10,5){} 
	\node[Nadjust=wh,Nmr=1](n6)(30,5){} 
	\node[Nadjust=wh,Nmr=1](n7)(50,5){} 
	\node[Nadjust=wh,Nmr=1](n9)(70,5){} 
	
	\drawedge[ATnb=0,AHnb=1,ELpos=40,ELside=r,ELdist=0](i1,n4){\scriptsize}
	\drawedge[ATnb=0,AHnb=0,ELpos=40,ELside=r,ELdist=0](n4,i1){\scriptsize}
	
	
	\drawedge[ATnb=0,AHnb=1,ELpos=40,ELside=r,ELdist=0](i2,n6){\scriptsize}
	\drawedge[ATnb=0,AHnb=0,ELpos=40,ELside=r,ELdist=0](n6,i2){\scriptsize}

	\drawedge[ATnb=0,AHnb=1,ELpos=40,ELside=r,ELdist=0](i3,n7){\scriptsize}
	\drawedge[ATnb=0,AHnb=0,ELpos=40,ELside=r,ELdist=0](n7,i3){\scriptsize}


	\drawedge[ATnb=0,AHnb=1,ELpos=10,ELside=r,ELdist=0](i4,n9){\scriptsize}
	\drawedge[ATnb=0,AHnb=0,ELpos=40,ELside=r,ELdist=0](n9,i4){\scriptsize}
		



	\end{picture}	
	\caption{B-tree in-order traversal.}
	\label{fig_pesquisaOrdenadaArvoreB}
	\end{center}
\end{figure}

\section{Fusion Tree}


This section describes the fusion tree data structure proposed by~\cite{fredman}. A fusion tree is similar to a B-tree in many aspects. One difference between B-tree and the fusion tree is the B value. In a B-tree the  value is a constant while in a fusion tree the  is a function of . More precisely,  . Another difference is the time to search a key in a node. The B-tree uses O(B) operations while the fusion tree uses O(1) operations to search a key  in a node.



Consider the problem of finding the predecessor or the successor of a key  in a set . Such problem consists in finding the number immediately above or below  in . Fusion tree is a data structure similar to B-tree but it solves the predecessor and successor problem in O(1) inside a node. Given a search key , the fusion tree is able to find the child branch relative to  in constant time despite the fact that the size of  increases with .





The following notation present in ~\cite{fredman} is needed:




\begin{definicao}{:}
Given a set of integer numbers  and an integer , let  be the value . In other 
words,  represents the number of elements smaller than or equal .
\end{definicao}

The problem of sort  number is equivalent to finding  for all . Such function provides the exact  position in the sorted vector. Moreover,  provides the correct child to continue the search of an element  in a B-tree node. Fusion tree is based in a trie data structure described in~\cite{ajtai}. Next subsection is devoted to the trie data structure.




\subsection{Trie data structure~\cite{ajtai}}



Let a trie be a binary tree with the following construction rule. Given a -bit integer , each bit of  is a node in the trie. If the most significant bit of  is ,  is a left root child. If it is ,  is a right root child. Such property is recursively applied to each bit of .



Given an arbitrary integer , let  be the -th least significant bit. Thus,  is the least significant bit,  is the second least significant bit and so on. Consider two binary integers  and . 
Figure~\ref{fig_trieBit} shows a trie with  and . The trie leaves are always sorted. We consider  calculated for all element in the trie.





\begin{figure}[htb]
	\begin{center}
	\setlength{\unitlength}{.8mm}
	\begin{picture}(70,90)(0,0)
\node[Nadjust=wh,Nmr=3](b0)(10,85){\small } 
	\node[Nadjust=wh,Nmr=3](b1)(20,75){\small } 
	\node[Nadjust=wh,Nmr=3](b2)(30,65){\small } 
	\node[Nadjust=wh,Nmr=3,linewidth=0.5](b3)(40,55){\small } 
	\node[Nadjust=wh,Nmr=3](b4)(50,45){\small } 
	\node[Nadjust=wh,Nmr=3](c4)(30,45){\small } 
	\node[Nadjust=wh,Nmr=3](b5)(60,35){\small } 
	\node[Nadjust=wh,Nmr=3](c5)(40,35){\small } 
	\node[Nadjust=wh,Nmr=3](b6)(50,25){\small } 
	\node[Nadjust=wh,Nmr=3](c6)(30,25){\small } 
	\node[Nadjust=wh,Nmr=3](b7)(40,15){\small } 
	\node[Nadjust=wh,Nmr=3](c7)(20,15){\small } 
	\node[Nadjust=wh,Nmr=0](c8)(30,5){\small } 
	\node[Nadjust=wh,Nmr=0](b8)(50,5){\small } 
	
	\drawedge[ATnb=0,AHnb=1](b0,b1){\small 1} 
	\drawedge[ATnb=0,AHnb=1](b1,b2){\small 1}  
	\drawedge[ATnb=0,AHnb=1](b2,b3){\small 1}
	\drawedge[ATnb=0,AHnb=1](b3,b4){\small 1}
	\drawedge[ATnb=0,AHnb=1](b4,b5){\small 1} 
	\drawedge[ATnb=0,AHnb=1](b5,b6){\small 0}   
	\drawedge[ATnb=0,AHnb=1](b6,b7){\small 0} 
	\drawedge[ATnb=0,AHnb=1](b7,b8){\small 1} 
	\drawedge[ATnb=0,AHnb=1](b3,c4){\small 0}
	\drawedge[ATnb=0,AHnb=1](c4,c5){\small 1} 
	\drawedge[ATnb=0,AHnb=1](c5,c6){\small 0}   
	\drawedge[ATnb=0,AHnb=1](c6,c7){\small 0} 
	\drawedge[ATnb=0,AHnb=1](c7,c8){\small 1} 			
	\end{picture}	
	\setlength{\unitlength}{1mm}
	\caption{
	Trie data structure for  and . It is enough to compare  to sort  and .
}
	\label{fig_trieBit}
	\end{center}
\end{figure}

Consider the following definition:
\begin{definicao}{:}
Given two integers   and , let  be the relevant bit between  and , meaning the most significant bit that diverges between  and .
\end{definicao}

When a set of integers are compared, some bits are irrelevant and can be discarded. Only a few-bit, named relevant bits, are sufficient to sort a set of integers. 

\begin{definicao}{\textbf{relevant bits}:} Consider a trie with a set of elements S. The relevant bits of S are the bits for which there is a branch in the trie.
\end{definicao}

In the previous example, to compare and sort the binary number  e , it is sufficient to compare the most significant bit that diverges between  and . Considering the previous numbers, such bit is , with values 0 in  and  in . Thus, . Such bit is used to conclude that  is greater than . All other bits are irrelevant. See Figure~\ref{fig_trieBitCondensado}.




Let  be a bitwise XOR between two words. Given two integers   and  ,  can be obtained as:




Consider an integer sequence  and a trie data structure. After inserting all  elements in the trie, a compression will be performed where all irrelevant bits will be discarded. Such new tree will be named compressed trie.




 

\begin{figure}[htb]
	\begin{center}
	\setlength{\unitlength}{.8mm}
	\begin{picture}(70,30)(0,0)
\node[Nadjust=wh,Nmr=3](b3)(35,20){\small } 
	\node[Nframe=n,Nadjust=wh,Nmr=3](x)(65,20){\small relevant bit} 
	
	\node[Nadjust=wh,Nmr=0](c8)(25,5){\small } 
	\node[Nadjust=wh,Nmr=0](b8)(45,5){\small } 
	\drawedge[ATnb=0,AHnb=1](b3,b8){\small 1}
	\drawedge[ATnb=0,AHnb=1,ELside=r](b3,c8){\small 0}
	\drawedge[ATnb=0,AHnb=1](x,b3){}
	\end{picture}	
	\setlength{\unitlength}{1mm}
	\caption{Compressed trie used to compare  and  with the relevant bit.}
	\label{fig_trieBitCondensado}
	\end{center}
\end{figure}

The compressed trie has each element of  as a leaf. The internal nodes store the respective relevant bit.



\begin{lema}
Given a compressed trie with , the numbers of relevant bit will be at most~.
\label{nbits}
\end{lema}

Lemma~\ref{nbits}  is correct because each relevant bit is related to a branch in the compressed trie. The number of branches will be exactly . Eventually, two distinct branches can occur at the same level.




To search a key  in a compressed trie, each bit of the trie is compared with the correspondent  bit from the root to the leaves. In each node, if the  bit is zero, the search continues in the left branch. If the bit is 1, the search continues in the right branch. Figure~\ref{fig_pesquisaTrie}  illustrates a search of a key  in a compressed trie with elements , ,  and . Let  be such search result. In Figure~\ref{fig_pesquisaTrie},  .





Ao realizar esse procedimento, chega-se a uma folha, que é um elemento  de . Isso  mostra que  e  têm os mesmos bits nas posições percorridas no caminho da .  





  No exemplo da Figura~\ref{fig_pesquisaTrie} nota-se que o primeiro bit a divergir entre  e  é o ,
  ou seja .
  A Figura~\ref{fig_insercaoTrie} mostra como a  fica após a inserção do elemento  na estrutura.




\begin{figure*}[htb]
	\begin{center}
\begin{picture}(120,80)(0,0)
\put(70,60){\begin{tabular}{cc}
	  S=\{a,b,c,d\}~~~~\\
	  a = 1 1 {\bf 0 1} 1 1 1 {\bf 1}\\
	  b = 1 1 {\bf 1 0}  0 0 0 {\bf 0}\\
	  c = 1 1 {\bf 1 0} 0 0 0 {\bf 1}\\
	  d = 1 1 {\bf 1 1} 1 1 1 {\bf 0}\\
	~\\		
	 x = 1 1 {\bf 1 0} 0 1 1 {\bf 1}			
	\end{tabular}}
	\node[Nadjust=wh,Nmr=3](fb2)(85,35){\small } 
	\node[Nadjust=wh,Nmr=3](fb3)(95,25){\small } 
	\node[Nadjust=wh,Nmr=3](fb7)(85,15){\small } 
	\node[Nadjust=wh,Nmr=0](fc)(105,15){\small } 
	\node[Nadjust=wh,Nmr=0](fb)(75,5){\small } 
	\node[Nadjust=wh,Nmr=0,linewidth=.4](fd)(95,5){\small } 
	\node[Nframe=n,Nadjust=wh,Nmr=0](x)(100,5){\small } 
	\node[Nadjust=wh,Nmr=0](fa)(75,25){\small } 
	\drawedge[ATnb=0,AHnb=1,ELside=r,linewidth=.5,AHLength=2,ELpos=70](fb3,fb7){\small }
	\drawedge[ATnb=0,AHnb=1,ELside=l](fb3,fc){\small 1}
	\drawedge[ATnb=0,AHnb=1,ELside=l,linewidth=.5,AHLength=2,ELpos=70](fb7,fd){\small }
	\drawedge[ATnb=0,AHnb=1,ELside=r](fb7,fb){\small 0}
	\drawedge[ATnb=0,AHnb=1,ELside=l,linewidth=.5,AHLength=2,ELpos=70](fb2,fb3){\small }
	\drawedge[ATnb=0,AHnb=1,ELside=r](fb2,fa){\small 0}	
	
		\node[Nadjust=wh,Nmr=3](b0)(10,75){\small } 
	\node[Nadjust=wh,Nmr=3](b1)(20,70){\small } 
	\node[Nadjust=wh,Nmr=3,linewidth=0.5](b2)(30,65){\small } 
	\node[Nadjust=wh,Nmr=3,linewidth=0.5](b3)(40,55){\small } 
	\node[Nadjust=wh,Nmr=3](a3)(00,55){\small } 
	\node[Nadjust=wh,Nmr=3](a4)(3,45){\small } 
	\node[Nadjust=wh,Nmr=3](a5)(6,35){\small } 
	\node[Nadjust=wh,Nmr=3](a6)(9,25){\small } 
	\node[Nadjust=wh,Nmr=3](a7)(12,15){\small } 
	\node[Nadjust=wh,Nmr=0](a8)(15,5){\small a} 
	\drawedge[ATnb=0,AHnb=1,ELside=r](b2,a3){\small 0} 
	\drawedge[ATnb=0,AHnb=1](a3,a4){\small 1} 
	\drawedge[ATnb=0,AHnb=1](a4,a5){\small 1} 	
	\drawedge[ATnb=0,AHnb=1](a5,a6){\small 1} 	
	\drawedge[ATnb=0,AHnb=1](a6,a7){\small 1} 	
	\drawedge[ATnb=0,AHnb=1](a7,a8){\small 1} 
	
	\node[Nadjust=wh,Nmr=3](b4)(47,45){\small } 
	\node[Nadjust=wh,Nmr=3](b5)(50,35){\small } 
	\node[Nadjust=wh,Nmr=3](b6)(53,25){\small } 
	\node[Nadjust=wh,Nmr=3](b7)(56,15){\small } 
	\node[Nadjust=wh,Nmr=0](b8)(53,5){\small d} 
	
	\node[Nadjust=wh,Nmr=3](c4)(37,45){\small } 
	
	
	\node[Nadjust=wh,Nmr=3](c5)(34,35){\small } 
	\node[Nadjust=wh,Nmr=3](c6)(31,25){\small } 
	\node[Nadjust=wh,Nmr=3,linewidth=0.5](c7)(28,15){\small } 
	\node[Nadjust=wh,Nmr=0](c8)(25,5){\small b} 
	\node[Nadjust=wh,Nmr=0](c9)(31,5){\small c} 


	
	\drawedge[ATnb=0,AHnb=1](b0,b1){\small 1} 
	\drawedge[ATnb=0,AHnb=1](b1,b2){\small 1}  
	\drawedge[ATnb=0,AHnb=1](b2,b3){\small 1}
	\drawedge[ATnb=0,AHnb=1](b3,b4){\small 1}
	\drawedge[ATnb=0,AHnb=1](b4,b5){\small 1} 
	\drawedge[ATnb=0,AHnb=1](b5,b6){\small 1}   
	\drawedge[ATnb=0,AHnb=1](b6,b7){\small 1} 
	\drawedge[ATnb=0,AHnb=1](b7,b8){\small 0} 
	\drawedge[ATnb=0,AHnb=1,ELside=r](b3,c4){\small 0}
	\drawedge[ATnb=0,AHnb=1,ELside=r](c4,c5){\small 0} 
	\drawedge[ATnb=0,AHnb=1,ELside=r](c5,c6){\small 0}   
	\drawedge[ATnb=0,AHnb=1,ELside=r](c6,c7){\small 0} 
	\drawedge[ATnb=0,AHnb=1,ELside=r](c7,c8){\small 0} 
	\drawedge[ATnb=0,AHnb=1,ELside=l](c7,c9){\small 1} 	
	
	\end{picture}	
	\caption{
	The search of  in the compressed trie data structure.
}
	\label{fig_pesquisaTrie}
	\end{center}
\end{figure*}


\begin{figure*}[htb]
	\begin{center}
	\setlength{\unitlength}{.9mm}
\begin{picture}(120,80)(0,0)
\put(70,65){\begin{tabular}{cc}
	  S=\{a,b,c,d\}~~~~\\
	  a = 1 1 {\bf 0 1} 1 1 1 {\bf 1}\\
	  b = 1 1 {\bf 1 0}  0 0 0 {\bf 0}\\
	  c = 1 1 {\bf 1 0} 0 0 0 {\bf 1}\\
	  d = 1 1 {\bf 1 1} 1 1 1 {\bf 0}\\
	 x = 1 1 {\bf 1 0} 0 1 1 {\bf 1}			
	\end{tabular}}
	\node[Nadjust=wh,Nmr=3](fb2)(85,45){\small } 
	\node[Nadjust=wh,Nmr=3](fb3)(93,35){\small } 
	\node[Nadjust=wh,Nmr=3,linewidth=0.5](fb5)(85,25){\small } 
	\node[Nadjust=wh,Nmr=3](fb7)(77,15){\small } 
	\node[Nadjust=wh,Nmr=0](fc)(99,25){\small d} 
	\node[Nadjust=wh,Nmr=0](fb)(71,5){\small b} 
	\node[Nadjust=wh,Nmr=0](fd)(85,5){\small c} 
	\node[Nadjust=wh,Nmr=0](x)(93,15){\small x} 
	\node[Nadjust=wh,Nmr=0](fa)(77,35){\small } 
	\drawedge[ATnb=0,AHnb=1,ELside=r](fb3,fb5){\small }
	\drawedge[ATnb=0,AHnb=1,ELside=r](fb5,fb7){\small }
	\drawedge[ATnb=0,AHnb=1,ELside=l](fb3,fc){\small 1}
	\drawedge[ATnb=0,AHnb=1,ELside=l](fb5,x){\small 1}
	\drawedge[ATnb=0,AHnb=1,ELside=l](fb7,fd){\small }
	\drawedge[ATnb=0,AHnb=1,ELside=r](fb7,fb){\small 0}
	\drawedge[ATnb=0,AHnb=1,ELside=l](fb2,fb3){\small }
	\drawedge[ATnb=0,AHnb=1,ELside=r](fb2,fa){\small 0}	
	
		\node[Nadjust=wh,Nmr=3](b0)(10,75){\small } 
	\node[Nadjust=wh,Nmr=3](b1)(20,70){\small } 
	\node[Nadjust=wh,Nmr=3](b2)(30,65){\small } 
	\node[Nadjust=wh,Nmr=3](b3)(40,55){\small } 
	\node[Nadjust=wh,Nmr=3](a3)(00,55){\small } 
	\node[Nadjust=wh,Nmr=3](a4)(3,45){\small } 
	\node[Nadjust=wh,Nmr=3](a5)(6,35){\small } 
	\node[Nadjust=wh,Nmr=3](a6)(9,25){\small } 
	\node[Nadjust=wh,Nmr=3](a7)(12,15){\small } 
	\node[Nadjust=wh,Nmr=0](a8)(15,5){\small a} 
	\drawedge[ATnb=0,AHnb=1,ELside=r](b2,a3){\small 0} 
	\drawedge[ATnb=0,AHnb=1](a3,a4){\small 1} 
	\drawedge[ATnb=0,AHnb=1](a4,a5){\small 1} 	
	\drawedge[ATnb=0,AHnb=1](a5,a6){\small 1} 	
	\drawedge[ATnb=0,AHnb=1](a6,a7){\small 1} 	
	\drawedge[ATnb=0,AHnb=1](a7,a8){\small 1} 
	
	\node[Nadjust=wh,Nmr=3](b4)(47,45){\small } 
	\node[Nadjust=wh,Nmr=3](b5)(50,35){\small } 
	\node[Nadjust=wh,Nmr=3](b6)(53,25){\small } 
	\node[Nadjust=wh,Nmr=3](b7)(56,15){\small } 
	\node[Nadjust=wh,Nmr=0](b8)(53,5){\small d} 
	
	\node[Nadjust=wh,Nmr=3](c4)(37,45){\small } 
	
	
	\node[Nadjust=wh,Nmr=3,linewidth=0.5](c5)(34,35){\small } 
	\node[Nadjust=wh,Nmr=3](c6)(31,25){\small } 
	\node[Nadjust=wh,Nmr=3](x6)(40,25){\small } 
	\node[Nadjust=wh,Nmr=3](x7)(42,15){\small } 
	\node[Nadjust=wh,Nmr=0](x8)(45,5){\small x} 
	\drawedge[ATnb=0,AHnb=1](c5,x6){\small 1} 
	\drawedge[ATnb=0,AHnb=1](x6,x7){\small 1} 
	\drawedge[ATnb=0,AHnb=1](x7,x8){\small 1} 			

	\node[Nadjust=wh,Nmr=3](c7)(28,15){\small } 
	\node[Nadjust=wh,Nmr=0](c8)(25,5){\small b} 
	\node[Nadjust=wh,Nmr=0](c9)(31,5){\small c} 


	
	\drawedge[ATnb=0,AHnb=1](b0,b1){\small 1} 
	\drawedge[ATnb=0,AHnb=1](b1,b2){\small 1}  
	\drawedge[ATnb=0,AHnb=1](b2,b3){\small 1}
	\drawedge[ATnb=0,AHnb=1](b3,b4){\small 1}
	\drawedge[ATnb=0,AHnb=1](b4,b5){\small 1} 
	\drawedge[ATnb=0,AHnb=1](b5,b6){\small 1}   
	\drawedge[ATnb=0,AHnb=1](b6,b7){\small 1} 
	\drawedge[ATnb=0,AHnb=1](b7,b8){\small 0} 
	\drawedge[ATnb=0,AHnb=1,ELside=r](b3,c4){\small 0}
	\drawedge[ATnb=0,AHnb=1,ELside=r](c4,c5){\small 0} 
	\drawedge[ATnb=0,AHnb=1,ELside=r](c5,c6){\small 0}   
	\drawedge[ATnb=0,AHnb=1,ELside=r](c6,c7){\small 0} 
	\drawedge[ATnb=0,AHnb=1,ELside=r](c7,c8){\small 0} 
	\drawedge[ATnb=0,AHnb=1,ELside=l](c7,c9){\small 1} 	
	
	\end{picture}	
	\setlength{\unitlength}{1mm}
	\caption{ Trie and compressed trie after the  insertion~\cite{ajtai}.}
	\label{fig_insercaoTrie}
	\end{center}
\end{figure*}



  \subsubsection{
   Computing 
}
  
  Suppose a set  inserted in a compressed trie. This section will describe how to compute  for a given key . An initial search  is computed. The  element has the same values than  in the relevant bits. If  is equal to  in the remaining bits,  and the rank is computed. 
In the other case, a new search will be performed. First, consider the bit .
  


\begin{lema} 
The bit  is the new relevant bit in the compressed trie with  elements.
\end{lema}

The  calculus will be dived in two cases. In the first, the bit   of  is 1, which means , while in the second case .





\begin{lema} 
The most significant bits of  and  are equals. The first bit to diverge is . Consider the branch between  and  in the trie with . If  , the  predecessor is the largest element in the  branch. If , the x successor is the smallest element in the branch .
\end{lema}



\textbf{Case a ()} Figure~\ref{rk} has an example in which the predecessor of  is the largest element in the subtree highlighted.






\begin{figure*}[htb]
	\begin{center}
	\setlength{\unitlength}{1mm}
\begin{picture}(160,80)(0,0)
\put(128,2){\dashbox(15,17)}	
	\put(0,65){\begin{tabular}{r}
	  S=\{a,b,c,d\}\hspace{1.07cm}~\\
	  a = 1 1 {\bf 0 1} 1 1 1 {\bf 1}\\
	  b = 1 1 {\bf 1 0}  0 0 0 {\bf 0}\\
	  c = 1 1 {\bf 1 0} 0 0 0 {\bf 1}\\
	 d = 1 1 {\bf 1 1} 1 1 1 {\bf 0}\\
	\end{tabular}}
	\put(0,43){\begin{tabular}{r}
	  = 1 1 {\bf 1 0} 0 1 1 {\bf 1}			
	\end{tabular}}
	
	

	\node[Nframe=n,Nadjust=wh](x)(33,25){} 	
	\node[Nframe=n,Nadjust=wh](y)(53,25){} 	
	\drawedge[ATnb=0,AHnb=1,linewidth=.4,AHLength=2.5](x,y){} 	

	\node[Nadjust=wh,Nmr=3](fb2)(15,35){\small } 
	\node[Nadjust=wh,Nmr=3](fb3)(25,25){\small } 
	\node[Nadjust=wh,Nmr=3](fb7)(15,15){\small } 
	\node[Nadjust=wh,Nmr=0](fc)(35,15){\small } 
	\node[Nadjust=wh,Nmr=0](fb)(5,5){\small } 
	\node[Nadjust=wh,Nmr=0,linewidth=.4](fd)(25,5){\small } 
	\node[Nframe=n,Nadjust=wh,Nmr=0](x)(30,5){\small  } 
	\node[Nadjust=wh,Nmr=0](fa)(5,25){\small } 
	\drawedge[ATnb=0,AHnb=1,ELside=r,linewidth=.5,AHLength=2,ELpos=70](fb3,fb7){\small }
	\drawedge[ATnb=0,AHnb=1,ELside=l](fb3,fc){\small 1}
	\drawedge[ATnb=0,AHnb=1,ELside=l,linewidth=.5,AHLength=2,ELpos=70](fb7,fd){\small }
	\drawedge[ATnb=0,AHnb=1,ELside=r](fb7,fb){\small 0}
	\drawedge[ATnb=0,AHnb=1,ELside=l,linewidth=.5,AHLength=2,ELpos=70](fb2,fb3){\small }
	\drawedge[ATnb=0,AHnb=1,ELside=r](fb2,fa){\small 0}	
	
		\node[Nadjust=wh,Nmr=3](b0)(60,75){\small } 
	\node[Nadjust=wh,Nmr=3](b1)(70,70){\small } 
	\node[Nadjust=wh,Nmr=3](b2)(80,65){\small } 
	\node[Nadjust=wh,Nmr=3](b3)(90,55){\small } 
	\node[Nadjust=wh,Nmr=3](a3)(50,55){\small } 
	\node[Nadjust=wh,Nmr=3](a4)(53,45){\small } 
	\node[Nadjust=wh,Nmr=3](a5)(56,35){\small } 
	\node[Nadjust=wh,Nmr=3](a6)(59,25){\small } 
	\node[Nadjust=wh,Nmr=3](a7)(62,15){\small } 
	\node[Nadjust=wh,Nmr=0](a8)(65,5){\small a} 
	\drawedge[ATnb=0,AHnb=1,ELside=r](b2,a3){\small 0} 
	\drawedge[ATnb=0,AHnb=1](a3,a4){\small 1} 
	\drawedge[ATnb=0,AHnb=1](a4,a5){\small 1} 	
	\drawedge[ATnb=0,AHnb=1](a5,a6){\small 1} 	
	\drawedge[ATnb=0,AHnb=1](a6,a7){\small 1} 	
	\drawedge[ATnb=0,AHnb=1](a7,a8){\small 1} 
	
	\node[Nadjust=wh,Nmr=3](b4)(97,45){\small } 
	\node[Nadjust=wh,Nmr=3](b5)(100,35){\small } 
	\node[Nadjust=wh,Nmr=3](b6)(103,25){\small } 
	\node[Nadjust=wh,Nmr=3](b7)(106,15){\small } 
	\node[Nadjust=wh,Nmr=0](b8)(103,5){\small d} 
	
	\node[Nadjust=wh,Nmr=3](c4)(87,45){\small } 
	
	
	\node[Nadjust=wh,Nmr=3,linewidth=.5](c5)(84,35){\small } 
	\node[Nadjust=wh,Nmr=3](c6)(81,25){\small }
	\node[Nadjust=wh,Nmr=3](c7)(78,15){\small } 
	\node[Nadjust=wh,Nmr=0](c8)(75,5){\small b} 
	\node[Nadjust=wh,Nmr=0](c9)(81,5){\small c} 


	\node[Nadjust=wh,Nmr=3](x6)(87,25){\small } 
	\node[Nadjust=wh,Nmr=3](x7)(90,15){\small } 
	\node[Nadjust=wh,Nmr=0](x8)(93,5){\small } 	
         \drawedge[ATnb=0,AHnb=1](c5,x6){\small 1} 
          \drawedge[ATnb=0,AHnb=1](x6,x7){\small 1} 
           \drawedge[ATnb=0,AHnb=1](x7,x8){\small 1} 
	
	\drawedge[ATnb=0,AHnb=1](b0,b1){\small 1} 
	\drawedge[ATnb=0,AHnb=1](b1,b2){\small 1}  
	\drawedge[ATnb=0,AHnb=1](b2,b3){\small 1}
	\drawedge[ATnb=0,AHnb=1](b3,b4){\small 1}
	\drawedge[ATnb=0,AHnb=1](b4,b5){\small 1} 
	\drawedge[ATnb=0,AHnb=1](b5,b6){\small 1}   
	\drawedge[ATnb=0,AHnb=1](b6,b7){\small 1} 
	\drawedge[ATnb=0,AHnb=1](b7,b8){\small 0} 
	\drawedge[ATnb=0,AHnb=1,ELside=r](b3,c4){\small 0}
	\drawedge[ATnb=0,AHnb=1,ELside=r](c4,c5){\small 0} 
	\drawedge[ATnb=0,AHnb=1,ELside=r](c5,c6){\small 0}   
	\drawedge[ATnb=0,AHnb=1,ELside=r](c6,c7){\small 0} 
	\drawedge[ATnb=0,AHnb=1,ELside=r](c7,c8){\small 0} 
	\drawedge[ATnb=0,AHnb=1,ELside=l](c7,c9){\small 1} 	
	
	
	\node[Nframe=n,Nadjust=wh](x)(108,25){} 	
	\node[Nframe=n,Nadjust=wh](y)(118,25){} 	
	\drawedge[ATnb=0,AHnb=1,linewidth=.4,AHLength=2.5](x,y){} 	


	\node[Nframe=n,Nadjust=wh](z)(139,25){} 	
	\node[Nmr=0,Nadjust=wh](w)(149,18){} 	
	\drawedge[ATnb=0,AHnb=1,linewidth=.4](z,w){1} 	

	
	\node[Nadjust=wh,Nmr=3](gb2)(135,45){\small } 
	\node[Nadjust=wh,Nmr=3](gb3)(145,35){\small } 
	\node[Nadjust=wh,Nmr=3](gb7)(135,15){\small } 
	\node[Nadjust=wh,Nmr=0](gc)(155,25){\small } 
	\node[Nadjust=wh,Nmr=0](gb)(132,5){\small } 
	\node[Nadjust=wh,Nmr=0](gd)(140,5){\small } 
	\node[Nframe=n,Nadjust=wh,Nmr=0](gx)(50,5){\small } 
	\node[Nadjust=wh,Nmr=0](ga)(125,35){\small } 
	\drawedge[ATnb=0,AHnb=1,ELside=r](gb3,gb7){\small 0}
	\drawedge[ATnb=0,AHnb=1,ELside=l](gb3,gc){\small 1}
	\drawedge[ATnb=0,AHnb=1,ELside=l](gb7,gd){\small 1}
	\drawedge[ATnb=0,AHnb=1,ELside=r](gb7,gb){\small 0}
	\drawedge[ATnb=0,AHnb=1,ELside=l](gb2,gb3){\small 1}
	\drawedge[ATnb=0,AHnb=1,ELside=r](gb2,ga){\small 0}	
	\put(115,55){}

	
	
	\end{picture}		
	\setlength{\unitlength}{1mm}
	\caption{
	Computing .
}
	\label{rk}
	\end{center}
\end{figure*}


A second search is needed to compute . From the most significant bit to the relevant bit , the compressed trie search uses the bits of . Starting from , the search looks for the largest element in the subtree, i.e., the search will down the tree always to the right branch in direction of the largest element.

A new search key  will be computed to obtain such behavior in the following way:




\begin{tabular}{rr}
& \\
OR &   \\ \hline
&
\end{tabular}

The number of 1’s at the end of  is . Such mask can be computed in  as .
When a bit of  is replaced by 1 from  to , the new search key will find  predecessor. Let . Then . Figure~\ref{rkd} has a sample.




\begin{figure*}[htb]
	\begin{center}
	\setlength{\unitlength}{1mm}
\begin{picture}(160,80)(0,0)
\put(0,65){\begin{tabular}{cc}
	  S=\{a,b,c,d\}~~~~\\
	  a = 1 1 {\bf 0 1} 1 1 1 {\bf 1}\\
	  b = 1 1 {\bf 1 0}  0 0 0 {\bf 0}\\
	  c = 1 1 {\bf 1 0} 0 0 0 {\bf 1}\\
	  d = 1 1 {\bf 1 1} 1 1 1 {\bf 0}\\
	\end{tabular}}
	\put(0,43){\begin{tabular}{cc}
	  = 1 1 {\bf 1 0} 1 0 0 {\bf 0}			
	\end{tabular}}
	
	

	\node[Nframe=n,Nadjust=wh](x)(33,25){} 	
	\node[Nframe=n,Nadjust=wh](y)(53,25){} 	
	\drawedge[ATnb=0,AHnb=1,linewidth=.4,AHLength=2.5](x,y){} 	

	\node[Nadjust=wh,Nmr=3](fb2)(15,35){\small } 
	\node[Nadjust=wh,Nmr=3](fb3)(25,25){\small } 
	\node[Nadjust=wh,Nmr=3](fb7)(15,15){\small } 
	\node[Nadjust=wh,Nmr=0](fc)(35,15){\small } 
	\node[Nadjust=wh,Nmr=0,linewidth=.4](fb)(5,5){\small } 
	\node[Nadjust=wh,Nmr=0](fd)(25,5){\small } 
	\node[Nframe=n,Nadjust=wh,Nmr=0](x)(0,5){\small  } 
	\node[Nadjust=wh,Nmr=0](fa)(5,25){\small } 
	\drawedge[ATnb=0,AHnb=1,ELside=r,linewidth=.4,AHLength=2.5,ELpos=70](fb3,fb7){\small }
	\drawedge[ATnb=0,AHnb=1,ELside=l](fb3,fc){\small 1}
	\drawedge[ATnb=0,AHnb=1,ELside=l](fb7,fd){\small }
	\drawedge[ATnb=0,AHnb=1,ELside=r,linewidth=.4,AHLength=2.5,ELpos=70](fb7,fb){\small }
	\drawedge[ATnb=0,AHnb=1,ELside=l,linewidth=.4,AHLength=2.5,ELpos=70](fb2,fb3){\small }
	\drawedge[ATnb=0,AHnb=1,ELside=r](fb2,fa){\small 0}	
	
		\node[Nadjust=wh,Nmr=3](b0)(60,75){\small } 
	\node[Nadjust=wh,Nmr=3](b1)(70,70){\small } 
	\node[Nadjust=wh,Nmr=3](b2)(80,65){\small } 
	\node[Nadjust=wh,Nmr=3](b3)(90,55){\small } 
	\node[Nadjust=wh,Nmr=3](a3)(50,55){\small } 
	\node[Nadjust=wh,Nmr=3](a4)(53,45){\small } 
	\node[Nadjust=wh,Nmr=3](a5)(56,35){\small } 
	\node[Nadjust=wh,Nmr=3](a6)(59,25){\small } 
	\node[Nadjust=wh,Nmr=3](a7)(62,15){\small } 
	\node[Nadjust=wh,Nmr=0](a8)(65,5){\small a} 
	\drawedge[ATnb=0,AHnb=1,ELside=r](b2,a3){\small 0} 
	\drawedge[ATnb=0,AHnb=1](a3,a4){\small 1} 
	\drawedge[ATnb=0,AHnb=1](a4,a5){\small 1} 	
	\drawedge[ATnb=0,AHnb=1](a5,a6){\small 1} 	
	\drawedge[ATnb=0,AHnb=1](a6,a7){\small 1} 	
	\drawedge[ATnb=0,AHnb=1](a7,a8){\small 1} 
	
	\node[Nadjust=wh,Nmr=3](b4)(97,45){\small } 
	\node[Nadjust=wh,Nmr=3](b5)(100,35){\small } 
	\node[Nadjust=wh,Nmr=3](b6)(103,25){\small } 
	\node[Nadjust=wh,Nmr=3](b7)(106,15){\small } 
	\node[Nadjust=wh,Nmr=0](b8)(103,5){\small d} 
	
	\node[Nadjust=wh,Nmr=3,linewidth=.5](c4)(87,45){\small } 
	
	
	\node[Nadjust=wh,Nmr=3](c5)(84,35){\small } 
	\node[Nadjust=wh,Nmr=3](c6)(81,25){\small }
	\node[Nadjust=wh,Nmr=3](c7)(78,15){\small } 
	\node[Nadjust=wh,Nmr=0](c8)(75,5){\small b} 
	\node[Nadjust=wh,Nmr=0](c9)(81,5){\small c} 


	\node[Nadjust=wh,Nmr=3](x5)(90,35){\small } 
	\node[Nadjust=wh,Nmr=3](x6)(92,25){\small } 
	\node[Nadjust=wh,Nmr=3](x7)(94,15){\small } 
	\node[Nadjust=wh,Nmr=0](x8)(96,5){\small  } 	
         \drawedge[ATnb=0,AHnb=1](x5,x6){\small 1} 
          \drawedge[ATnb=0,AHnb=1](x6,x7){\small 1} 
           \drawedge[ATnb=0,AHnb=1](x7,x8){\small 1} 
	
	\drawedge[ATnb=0,AHnb=1](c4,x5){\small 1} 
	
	\drawedge[ATnb=0,AHnb=1](b0,b1){\small 1} 
	\drawedge[ATnb=0,AHnb=1](b1,b2){\small 1}  
	\drawedge[ATnb=0,AHnb=1](b2,b3){\small 1}
	\drawedge[ATnb=0,AHnb=1](b3,b4){\small 1}
	\drawedge[ATnb=0,AHnb=1](b4,b5){\small 1} 
	\drawedge[ATnb=0,AHnb=1](b5,b6){\small 1}   
	\drawedge[ATnb=0,AHnb=1](b6,b7){\small 1} 
	\drawedge[ATnb=0,AHnb=1](b7,b8){\small 0} 
	\drawedge[ATnb=0,AHnb=1,ELside=r](b3,c4){\small 0}
	\drawedge[ATnb=0,AHnb=1,ELside=r](c4,c5){\small 0} 
	\drawedge[ATnb=0,AHnb=1,ELside=r](c5,c6){\small 0}   
	\drawedge[ATnb=0,AHnb=1,ELside=r](c6,c7){\small 0} 
	\drawedge[ATnb=0,AHnb=1,ELside=r](c7,c8){\small 0} 
	\drawedge[ATnb=0,AHnb=1,ELside=l](c7,c9){\small 1} 	
	
	
	\node[Nframe=n,Nadjust=wh](x)(108,25){} 	
	\node[Nframe=n,Nadjust=wh](y)(118,25){} 	
	\drawedge[ATnb=0,AHnb=1,linewidth=.4,AHLength=2.5](x,y){} 	




	
	\node[Nadjust=wh,Nmr=3](gb2)(135,45){\small } 
	\node[Nadjust=wh,Nmr=3](gb3)(145,35){\small } 
	\node[Nadjust=wh,Nmr=3](gb7)(135,23){\small } 
	\node[Nadjust=wh,Nmr=0](gc)(155,25){\small } 
	\node[Nadjust=wh,Nmr=0](gb)(132,10){\small } 
	\node[Nadjust=wh,Nmr=0,linewidth=.5](gd)(140,10){\small } 
	\node[Nframe=n,Nadjust=wh,Nmr=0](gx)(50,10){\small  x} 
	\node[Nadjust=wh,Nmr=0](ga)(125,35){\small } 
	\drawedge[ATnb=0,AHnb=1,ELside=r,linewidth=.5,ELpos=70](gb3,gb7){\small }
	\drawedge[ATnb=0,AHnb=1,ELside=l](gb3,gc){\small 1}
	\drawedge[ATnb=0,AHnb=1,ELside=l,linewidth=.5,ELpos=70](gb7,gd){\small }
	\drawedge[ATnb=0,AHnb=1,ELside=r](gb7,gb){\small 0}
	\drawedge[ATnb=0,AHnb=1,ELside=l,linewidth=.5,ELpos=70](gb2,gb3){\small }
	\drawedge[ATnb=0,AHnb=1,ELside=r](gb2,ga){\small 0}	
	\put(115,60){\begin{tabular}{cc}
	& \\
	&
	\end{tabular}
	}
	\put(120,0){}
	
	
	\end{picture}		
	\setlength{\unitlength}{1mm}
	\caption{
	Computing  after the second search in the compressed trie. 
}
	\label{rkd}
	\end{center}
\end{figure*}

\textbf{Case b () } In the Figure~\ref{rkb} example, the  successor is the smaller element in the highlighted subtree. A second search is performed to compute . From the most significant bit to the relevant bit , the compressed trie search uses the bits of . Starting from , the search looks for the smallest element in the subtree, i.e., the search will down the tree always to the left branch in direction of the smallest element.



\begin{figure*}[htb]
	\begin{center}
	\setlength{\unitlength}{.9mm}
\begin{picture}(180,79)(0,0)
\put(141,2){\dashbox(37,48)}	
	\put(0,65){\begin{tabular}{r}
	  S=\{a,b,c,d\}\hspace{1.07cm}~\\
	  a = 1 1 {\bf 0 1} 1 1 1 {\bf 1}\\
	  b = 1 1 {\bf 1 0}  0 0 0 {\bf 0}\\
	  c = 1 1 {\bf 1 0} 0 0 0 {\bf 1}\\
	  d = 1 1 {\bf 1 1} 1 1 1 {\bf 0}\\			
	\end{tabular}}
	\put(0,43){\begin{tabular}{r}	  		
	  = 0 1 {\bf 1 0} 0 1 1 {\bf 1}			
	\end{tabular}}
	
	

	\node[Nframe=n,Nadjust=wh](x)(33,25){} 	
	\node[Nframe=n,Nadjust=wh](y)(53,25){} 	
	\drawedge[ATnb=0,AHnb=1,linewidth=.4,AHLength=2.5](x,y){} 	

	\node[Nadjust=wh,Nmr=3](fb2)(15,35){\small } 
	\node[Nadjust=wh,Nmr=3](fb3)(25,25){\small } 
	\node[Nadjust=wh,Nmr=3](fb7)(15,15){\small } 
	\node[Nadjust=wh,Nmr=0](fc)(35,15){\small } 
	\node[Nadjust=wh,Nmr=0](fb)(5,5){\small } 
	\node[Nadjust=wh,Nmr=0,linewidth=.4](fd)(25,5){\small } 
	\node[Nframe=n,Nadjust=wh,Nmr=0](x)(30,5){\small  } 
	\node[Nadjust=wh,Nmr=0](fa)(5,25){\small } 
	\drawedge[ATnb=0,AHnb=1,ELside=r,linewidth=.5,AHLength=2,ELpos=90](fb3,fb7){\small }
	\drawedge[ATnb=0,AHnb=1,ELside=l](fb3,fc){\small 1}
	\drawedge[ATnb=0,AHnb=1,ELside=l,linewidth=.5,AHLength=2,ELpos=100](fb7,fd){\small }
	\drawedge[ATnb=0,AHnb=1,ELside=r](fb7,fb){\small 0}
	\drawedge[ATnb=0,AHnb=1,ELside=l,linewidth=.5,AHLength=2,ELpos=70](fb2,fb3){\small }
	\drawedge[ATnb=0,AHnb=1,ELside=r](fb2,fa){\small 0}	
	
	
	\node[Nadjust=wh,Nmr=3](bb6)(52,70){\small }
	\node[Nadjust=wh,Nmr=3](bb5)(60,65){\small } 
	\node[Nadjust=wh,Nmr=3](bb4)(63,55){\small } 
	\node[Nadjust=wh,Nmr=3](bb3)(60,45){\small } 
	\node[Nadjust=wh,Nmr=3](bb2)(57,35){\small } 
	\node[Nadjust=wh,Nmr=3](bb1)(60,25){\small } 
	\node[Nadjust=wh,Nmr=3](bb0)(63,15){\small } 
	\node[Nadjust=wh,Nmr=0](x3)(66,5){\small  }	
	\drawedge[ATnb=0,AHnb=1](bb6,bb5){\small 1} 
	\drawedge[ATnb=0,AHnb=1](bb5,bb4){\small 1} 
	\drawedge[ATnb=0,AHnb=1,ELside=r](bb4,bb3){\small 0} 
	\drawedge[ATnb=0,AHnb=1,ELside=r](bb3,bb2){\small 0} 	
	\drawedge[ATnb=0,AHnb=1](bb2,bb1){\small 1} 	
	\drawedge[ATnb=0,AHnb=1](bb1,bb0){\small 1} 	
	\drawedge[ATnb=0,AHnb=1](bb0,x3){\small 1} 		
		\node[Nadjust=wh,Nmr=3,linewidth=.4](b0)(80,75){\small } 
		\drawedge[ATnb=0,AHnb=1,ELside=r](b0,bb6){\small 0} 
		
	\node[Nadjust=wh,Nmr=3](b1)(90,70){\small } 
	\node[Nadjust=wh,Nmr=3](b2)(100,65){\small } 
	\node[Nadjust=wh,Nmr=3](b3)(110,55){\small } 
	\node[Nadjust=wh,Nmr=3](a3)(72,55){\small } 
	\node[Nadjust=wh,Nmr=3](a4)(75,45){\small } 
	\node[Nadjust=wh,Nmr=3](a5)(77,35){\small } 
	\node[Nadjust=wh,Nmr=3](a6)(79,25){\small } 
	\node[Nadjust=wh,Nmr=3](a7)(82,15){\small } 
	\node[Nadjust=wh,Nmr=0](a8)(85,5){\small a} 
	\drawedge[ATnb=0,AHnb=1,ELside=r](b2,a3){\small 0} 
	\drawedge[ATnb=0,AHnb=1](a3,a4){\small 1} 
	\drawedge[ATnb=0,AHnb=1](a4,a5){\small 1} 	
	\drawedge[ATnb=0,AHnb=1](a5,a6){\small 1} 	
	\drawedge[ATnb=0,AHnb=1](a6,a7){\small 1} 	
	\drawedge[ATnb=0,AHnb=1](a7,a8){\small 1} 
	
	\node[Nadjust=wh,Nmr=3](b4)(117,45){\small } 
	\node[Nadjust=wh,Nmr=3](b5)(120,35){\small } 
	\node[Nadjust=wh,Nmr=3](b6)(123,25){\small } 
	\node[Nadjust=wh,Nmr=3](b7)(126,15){\small } 
	\node[Nadjust=wh,Nmr=0](b8)(123,5){\small d} 
	
	\node[Nadjust=wh,Nmr=3](c4)(107,45){\small } 
	
	
	\node[Nadjust=wh,Nmr=3](c5)(104,35){\small } 
	\node[Nadjust=wh,Nmr=3](c6)(101,25){\small }
	\node[Nadjust=wh,Nmr=3](c7)(98,15){\small } 
	\node[Nadjust=wh,Nmr=0](c8)(95,5){\small b} 
	\node[Nadjust=wh,Nmr=0](c9)(101,5){\small c} 


	\node[Nadjust=wh,Nmr=3](x6)(107,25){\small } 
	\node[Nadjust=wh,Nmr=3](x7)(110,15){\small } 
	\node[Nadjust=wh,Nmr=0](x8)(113,5){\small  } 	
         \drawedge[ATnb=0,AHnb=1](c5,x6){\small 1} 
          \drawedge[ATnb=0,AHnb=1](x6,x7){\small 1} 
           \drawedge[ATnb=0,AHnb=1](x7,x8){\small 1} 
	
	\drawedge[ATnb=0,AHnb=1](b0,b1){\small 1} 
	\drawedge[ATnb=0,AHnb=1](b1,b2){\small 1}  
	\drawedge[ATnb=0,AHnb=1](b2,b3){\small 1}
	\drawedge[ATnb=0,AHnb=1](b3,b4){\small 1}
	\drawedge[ATnb=0,AHnb=1](b4,b5){\small 1} 
	\drawedge[ATnb=0,AHnb=1](b5,b6){\small 1}   
	\drawedge[ATnb=0,AHnb=1](b6,b7){\small 1} 
	\drawedge[ATnb=0,AHnb=1](b7,b8){\small 0} 
	\drawedge[ATnb=0,AHnb=1,ELside=r](b3,c4){\small 0}
	\drawedge[ATnb=0,AHnb=1,ELside=r](c4,c5){\small 0} 
	\drawedge[ATnb=0,AHnb=1,ELside=r](c5,c6){\small 0}   
	\drawedge[ATnb=0,AHnb=1,ELside=r](c6,c7){\small 0} 
	\drawedge[ATnb=0,AHnb=1,ELside=r](c7,c8){\small 0} 
	\drawedge[ATnb=0,AHnb=1,ELside=l](c7,c9){\small 1} 	
	
	
	\node[Nframe=n,Nadjust=wh](x)(128,25){} 	
	\node[Nframe=n,Nadjust=wh](y)(138,25){} 	
	\drawedge[ATnb=0,AHnb=1,linewidth=.4,AHLength=2.5](x,y){} 	



	
	\node[Nadjust=wh,Nmr=3](gb2)(155,45){\small } 
	\node[Nadjust=wh,Nmr=3](gb3)(165,35){\small } 
	\node[Nadjust=wh,Nmr=3](gb7)(155,15){\small } 
	\node[Nadjust=wh,Nmr=0](gc)(175,25){\small } 
	\node[Nadjust=wh,Nmr=0](gb)(152,5){\small } 
	\node[Nadjust=wh,Nmr=0](gd)(160,5){\small } 
\node[Nadjust=wh,Nmr=0](ga)(145,35){\small } 
	\drawedge[ATnb=0,AHnb=1,ELside=r](gb3,gb7){\small 0}
	\drawedge[ATnb=0,AHnb=1,ELside=l](gb3,gc){\small 1}
	\drawedge[ATnb=0,AHnb=1,ELside=l](gb7,gd){\small 1}
	\drawedge[ATnb=0,AHnb=1,ELside=r](gb7,gb){\small 0}
	\drawedge[ATnb=0,AHnb=1,ELside=l](gb2,gb3){\small 1}
	\drawedge[ATnb=0,AHnb=1,ELside=r](gb2,ga){\small 0}	


	
	\node[Nframe=n,Nadjust=wh](z2)(145,65){} 	
	\node[Nframe=n,Nadjust=wh](z)(147,63){} 	
	\node[Nmr=0,Nadjust=wh](w)(135,55){ } 	
	\drawedge[ATnb=0,AHnb=1,linewidth=.4,ELside=r](z,w){0} 	
	\drawedge[ATnb=0,AHnb=1,ELside=l](z2,gb2){\small 1} 	

	
	\end{picture}		
	\setlength{\unitlength}{1mm}
	\caption{
	Computing  after the second search in the compressed trie.}
	\label{rkb}
	\end{center}
\end{figure*}

A new search key  will be computed to obtain such behavior in the following way:



\begin{tabular}{rr}
& \\
AND &   \\ \hline
&
\end{tabular}

The number of zeros at the end of  is . When a bit of  is replaced by zero from  to , the new search key will find  successor. Let . Then . Figure~\ref{rkt} has a sample.




\begin{figure*}[htb]
	\begin{center}
	\setlength{\unitlength}{1mm}
\begin{picture}(160,80)(0,0)
\put(0,60){\begin{tabular}{rl}
	 & S=\{a,b,c,d\}\\
	  a\hspace{-.3cm}&\hspace{-.3cm}=1 1 {\bf 0 1} 1 1 1 {\bf 1}\\
	  b\hspace{-.3cm}&\hspace{-.3cm}=1 1 {\bf 1 0}  0 1 0 {\bf 0}\\
	  c\hspace{-.3cm}&\hspace{-.3cm}=1 1 {\bf 1 0} 0 1 0 {\bf 1}\\
	  d\hspace{-.3cm}&\hspace{-.3cm}=1 1 {\bf 1 1} 1 1 1 {\bf 0}\\
			
	 \hspace{-.3cm}&\hspace{-.3cm}=1 1 {\bf 1 0} 0 0 0 {\bf 1}			
	\end{tabular}}
	
	

	\node[Nframe=n,Nadjust=wh](x)(33,25){} 	
	\node[Nframe=n,Nadjust=wh](y)(53,25){} 	
	\drawedge[ATnb=0,AHnb=1,linewidth=.4,AHLength=2.5](x,y){} 	

	\node[Nadjust=wh,Nmr=3](fb2)(15,35){\small } 
	\node[Nadjust=wh,Nmr=3](fb3)(25,25){\small } 
	\node[Nadjust=wh,Nmr=3](fb7)(15,15){\small } 
	\node[Nadjust=wh,Nmr=0](fc)(35,15){\small } 
	\node[Nadjust=wh,Nmr=0](fb)(5,5){\small } 
	\node[Nadjust=wh,Nmr=0,linewidth=.4](fd)(25,5){\small } 
	\node[Nframe=n,Nadjust=wh,Nmr=0](x)(0,5){\small  } 
	\node[Nadjust=wh,Nmr=0](fa)(5,25){\small } 
	\drawedge[ATnb=0,AHnb=1,ELside=r,linewidth=.4,AHLength=2.5,ELpos=90](fb3,fb7){\small }
	\drawedge[ATnb=0,AHnb=1,ELside=l](fb3,fc){\small 1}
	\drawedge[ATnb=0,AHnb=1,ELside=l,linewidth=.4,AHLength=2.5,ELpos=90](fb7,fd){\small }
	\drawedge[ATnb=0,AHnb=1,ELside=r](fb7,fb){\small }
	\drawedge[ATnb=0,AHnb=1,ELside=l,linewidth=.4,AHLength=2.5,ELpos=70](fb2,fb3){\small }
	\drawedge[ATnb=0,AHnb=1,ELside=r](fb2,fa){\small 0}	
	
		\node[Nadjust=wh,Nmr=3](b0)(60,75){\small } 
	\node[Nadjust=wh,Nmr=3](b1)(70,70){\small } 
	\node[Nadjust=wh,Nmr=3](b2)(80,65){\small } 
	\node[Nadjust=wh,Nmr=3](b3)(90,55){\small } 
	\node[Nadjust=wh,Nmr=3](a3)(50,55){\small } 
	\node[Nadjust=wh,Nmr=3](a4)(53,45){\small } 
	\node[Nadjust=wh,Nmr=3](a5)(56,35){\small } 
	\node[Nadjust=wh,Nmr=3](a6)(59,25){\small } 
	\node[Nadjust=wh,Nmr=3](a7)(62,15){\small } 
	\node[Nadjust=wh,Nmr=0](a8)(65,5){\small a} 
	\drawedge[ATnb=0,AHnb=1,ELside=r](b2,a3){\small 0} 
	\drawedge[ATnb=0,AHnb=1](a3,a4){\small 1} 
	\drawedge[ATnb=0,AHnb=1](a4,a5){\small 1} 	
	\drawedge[ATnb=0,AHnb=1](a5,a6){\small 1} 	
	\drawedge[ATnb=0,AHnb=1](a6,a7){\small 1} 	
	\drawedge[ATnb=0,AHnb=1](a7,a8){\small 1} 
	
	\node[Nadjust=wh,Nmr=3](b4)(97,45){\small } 
	\node[Nadjust=wh,Nmr=3](b5)(100,35){\small } 
	\node[Nadjust=wh,Nmr=3](b6)(103,25){\small } 
	\node[Nadjust=wh,Nmr=3](b7)(106,15){\small } 
	\node[Nadjust=wh,Nmr=0](b8)(103,5){\small d} 
	
	\node[Nadjust=wh,Nmr=3](c4)(87,45){\small } 
	
	
	\node[Nadjust=wh,Nmr=3,linewidth=.5](c5)(84,35){\small } 
	\node[Nadjust=wh,Nmr=3](c6)(93,25){\small }
	\node[Nadjust=wh,Nmr=3](c7)(87,15){\small } 
	\node[Nadjust=wh,Nmr=0](c8)(84,5){\small b} 
	\node[Nadjust=wh,Nmr=0](c9)(90,5){\small c} 



	\node[Nadjust=wh,Nmr=3](x6)(79,25){\small } 
	\node[Nadjust=wh,Nmr=3](x7)(75,15){\small } 
	\node[Nadjust=wh,Nmr=0](x8)(75,5){\small  } 	
         \drawedge[ATnb=0,AHnb=1,ELside=r](c5,x6){\small 0} 
          \drawedge[ATnb=0,AHnb=1,ELside=r](x6,x7){\small 0} 
           \drawedge[ATnb=0,AHnb=1](x7,x8){\small 1} 


	\drawedge[ATnb=0,AHnb=1](b0,b1){\small 1} 
	\drawedge[ATnb=0,AHnb=1](b1,b2){\small 1}  
	\drawedge[ATnb=0,AHnb=1](b2,b3){\small 1}
	\drawedge[ATnb=0,AHnb=1](b3,b4){\small 1}
	\drawedge[ATnb=0,AHnb=1](b4,b5){\small 1} 
	\drawedge[ATnb=0,AHnb=1](b5,b6){\small 1}   
	\drawedge[ATnb=0,AHnb=1](b6,b7){\small 1} 
	\drawedge[ATnb=0,AHnb=1](b7,b8){\small 0} 
	\drawedge[ATnb=0,AHnb=1,ELside=r](b3,c4){\small 0}
	\drawedge[ATnb=0,AHnb=1,ELside=r](c4,c5){\small 0} 
	\drawedge[ATnb=0,AHnb=1,ELside=l](c5,c6){\small 1}   
	\drawedge[ATnb=0,AHnb=1,ELside=r](c6,c7){\small 0} 
	\drawedge[ATnb=0,AHnb=1,ELside=r](c7,c8){\small 0} 
	\drawedge[ATnb=0,AHnb=1,ELside=l](c7,c9){\small 1} 	
	
	
	\node[Nframe=n,Nadjust=wh](x)(108,25){} 	
	\node[Nframe=n,Nadjust=wh](y)(118,25){} 	
	\drawedge[ATnb=0,AHnb=1,linewidth=.4,AHLength=2.5](x,y){} 	




	
	\node[Nadjust=wh,Nmr=3](gb2)(135,45){\small } 
	\node[Nadjust=wh,Nmr=3](gb3)(145,35){\small } 
	\node[Nadjust=wh,Nmr=3](gb7)(135,23){\small } 
	\node[Nadjust=wh,Nmr=0](gc)(155,25){\small } 
	\node[Nadjust=wh,Nmr=0,,linewidth=.5](gb)(132,10){\small } 
	\node[Nadjust=wh,Nmr=0](gd)(140,10){\small } 
	\node[Nframe=n,Nadjust=wh,Nmr=0](gx)(50,10){\small  x} 
	\node[Nadjust=wh,Nmr=0](ga)(125,35){\small } 
	\drawedge[ATnb=0,AHnb=1,ELside=r,linewidth=.5,ELpos=70](gb3,gb7){\small }
	\drawedge[ATnb=0,AHnb=1,ELside=l](gb3,gc){\small 1}
	\drawedge[ATnb=0,AHnb=1,ELside=l](gb7,gd){\small }
	\drawedge[ATnb=0,AHnb=1,ELside=r,linewidth=.5,ELpos=70](gb7,gb){\small }
	\drawedge[ATnb=0,AHnb=1,ELside=l,linewidth=.5,ELpos=70](gb2,gb3){\small }
	\drawedge[ATnb=0,AHnb=1,ELside=r](gb2,ga){\small 0}	
	\put(115,60){\begin{tabular}{rl}
	& \\
	&
	\end{tabular}
	}
	\put(120,0){}
	
	
	\end{picture}		
	\setlength{\unitlength}{1mm}
	\caption{
	Computing  after the second search in the compressed trie.}
	\label{rkt}
	\end{center}
\end{figure*}

\subsection{Fusion Tree Characteristics}

Basically, the fusion tree is a B-tree with degree , i.e, the degree is an increasing function with respect to the number of elements. Figure~\ref{fig_arvore_fusao} has an example. 




\begin{figure}[htb!]
	\begin{center}
		\begin{picture}(80,50)(0,0)

	\node[Nframe=n,Nadjust=wh,Nmr=1](R)(35,48){Raiz} 
	\node[Nadjust=wh,Nmr=1](n1)(40,40){} 
	\drawedge[ATnb=0,AHnb=1](R,n1){} 
	\node[Nadjust=wh,Nmr=1](n2)(20,30){} 
	\node[Nadjust=wh,Nmr=1](n3)(60,30){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](x)(40,30){\ldots} 
	\drawedge[ATnb=0,AHnb=1](n1,n2){} 
	\drawedge[ATnb=0,AHnb=1](n1,n3){} 
	\node[Nadjust=wh,Nmr=1](n4)(15,15){} 
	\node[Nframe=n,Nadjust=wh,Nmr=1](n6)(33,15){} 
	\drawedge[ATnb=0,AHnb=1](n2,n4){}



	\imark[iangle=260,ATnb=0,AHnb=0](n2)
	\imark[iangle=270,ATnb=0,AHnb=0](n2)
	\imark[iangle=280,ATnb=0,AHnb=0](n2)
	\imark[iangle=290,ATnb=0,AHnb=0](n2)
	\imark[iangle=296,ATnb=0,AHnb=0](n2)

	\imark[iangle=245,ATnb=0,AHnb=0](n3)
	\imark[iangle=250,ATnb=0,AHnb=0](n3)
	\imark[iangle=260,ATnb=0,AHnb=0](n3)
	\imark[iangle=270,ATnb=0,AHnb=0](n3)
	\imark[iangle=280,ATnb=0,AHnb=0](n3)
	
	\node[Nframe=n,Nadjust=wh,Nmr=1](n7)(47,15){\ldots} 

	\node[Nadjust=wh,Nmr=1](n9)(65,15){} 
\drawedge[ATnb=0,AHnb=1](n3,n9){}  
		\imark[iangle=245,ATnb=0,AHnb=0](n3)
	
		\imark[iangle=245,ATnb=0,AHnb=0](n3)


	\imark[iangle=255,ATnb=0,AHnb=0](n4)
	\imark[iangle=260,ATnb=0,AHnb=0](n4)
	\imark[iangle=270,ATnb=0,AHnb=0](n4)
	\imark[iangle=280,ATnb=0,AHnb=0](n4)
	\imark[iangle=285,ATnb=0,AHnb=0](n4)


	\imark[iangle=255,ATnb=0,AHnb=0](n9)
	\imark[iangle=260,ATnb=0,AHnb=0](n9)
	\imark[iangle=270,ATnb=0,AHnb=0](n9)
	\imark[iangle=280,ATnb=0,AHnb=0](n9)
	\imark[iangle=285,ATnb=0,AHnb=0](n9)





	\node[Nw=5,Nh=5,Nmr=1](n10)(10,0){} 
	\node[Nframe=n,Nw=5,Nh=5,Nmr=1](x)(15,0){\ldots} 
	\node[Nw=5,Nh=5,Nmr=1](n11)(20,0){}
	\drawedge[ATnb=0,AHnb=1](n4,n10){}
	\drawedge[ATnb=0,AHnb=1](n4,n11){} 

	\node[Nw=5,Nh=5,Nmr=1](n16)(60,0){} 
	\node[Nframe=n,Nw=5,Nh=5,Nmr=1](x)(65,0){\ldots} 
	\node[Nw=5,Nh=5,Nmr=1](n17)(70,0){} 

	\drawedge[ATnb=0,AHnb=1](n9,n16){}
	\drawedge[ATnb=0,AHnb=1](n9,n17){} 

	\end{picture}	

	\caption{Structure of a complete fusion tree.}
	\label{fig_arvore_fusao}
	\end{center}
\end{figure}


As the height of a B-tree is proportional to  and the fusion tree has  so the height  has complexity:










The time to search the correct child to continue the search in a B-tree node is  using linear search. As the search occurs in each tree level, the overall time is   to perform a search. In a fusion tree, the child is found in 
 in a node and in  in the tree. As , the search complexity time is













As previously discussed, some irrelevant bits can be discarded in the sort process. A special structure name sketch is created to save only the relevant ones:



\begin{definicao}{\sk{s}:}
The sketch of a word  consists in discarding all irrelevant bits, keeping the relevant ones. Sketch operations preserve the words order, i.e.,  if and only if  . 
\end{definicao}

Figure~\ref{fig_pesquisaTrie} has the elements , ,  and  sketches. They are , ,  e  respectively. The sketches order doesn't change with respect to the original numbers.




The fusion tree central idea is concerned with how it stores the key in each node. Each node contains  keys, for . As stated in Lemma~\ref{nbits}, a trie with  keys has at most  relevant bits. A node contains  sketches each with  relevant bits. Thus, the overall sketch bits in a node are


The sum of sketches bits in a node fits in only one memory word. Thus, each fusion tree node has one word that keeps one sketch for each key plus some bits as defined above:




\begin{definicao}{Sketch Node}
The sketch node is a node that contains all keys sketches. Such sketches can be stored in only one word. Additionally, there is a separator bit between the sketches whose value is 1. The sketch node will be the concatenation of each key sketch:
 
Furthermore, sketches are concatenated in nondecreasing order.
\end{definicao}

The next subsection will show how to compare a key x with all keys in a node in constant times, based in~\cite{lec2011}.

\subsection{Multiple comparisons in constant time}







Consider a fusion tree node with elements  . Suppose the relevant bits with respect to  are  with . To compare a search key  with all node keys, first  is computed. 

To extract the first relevant bit  and store it in the first position of , it is computed a bitwise AND between  and a mask with value 1 only in the bit . Once the mask is applied, the bit must be moved to sketch vector position . Such movement of delta bits is obtained by a multiplication by .




To obtain all relevant bits of  in the initial position of , first a bitwise AND is performed between  and a mask with 1 only in the relevant bits . Such mask will be constructed with the compressed trie and is available when the  search is computed. After this, all relevant bits must be moved to the initial position of   in  as shown in the figure above.





\centerline{
\begin{picture}(110,20)(0,0)
\node[Nmr=0,Nw=4,Nh=4,linecolor=white](B)(24,16){}
\node[Nmr=0,Nw=4,Nh=4,linecolor=white](B)(86,16){}
\node[Nmr=0,Nw=4,Nh=4](B)(12,10){0}
\node[Nmr=0,Nw=4,Nh=4](B)(16,10){}
\node[Nmr=0,Nw=4,Nh=4](B)(20,10){}
\node[Nmr=0,Nw=4,Nh=4](B)(24,10){1}
\node[Nmr=0,Nw=4,Nh=4](B)(28,10){}
\node[Nmr=0,Nw=4,Nh=4](B)(32,10){0}
\node[Nmr=0,Nw=4,Nh=4](B)(36,10){}
\node[Nmr=0,Nw=4,Nh=4](B)(40,10){0}
\node[Nframe=n,Nadjust=wh](Y)(75,10){} 	
\node[Nframe=n,Nadjust=wh](X)(45,10){} 	
\drawedge[ATnb=0,AHnb=1,linewidth=.4,AHLength=2.5](X,Y){\footnotesize Repositioning}
\drawedge[ELside=r](X,Y){} 			 	
\node[Nmr=0,Nw=4,Nh=4](B)(80,10){0}
\node[Nmr=0,Nw=4,Nh=4](B)(84,10){1}
\node[Nmr=0,Nw=4,Nh=4](B)(88,10){0}
\node[Nmr=0,Nw=4,Nh=4](B)(92,10){0}
\end{picture}
}

When an arbitrary number  is multiplied by a predefined constant, it is possible to reposition the bits of . The problem of repositioning the relevant bits of  to the initial position of  in  is a nontrivial task. The work~\cite{lec2012} discuss the existence of predefined constants to reposition the relevant bits of . The result is imperfect because some additional zeros bits are added to the . Such additional zero bits do not change the algorithm behavior. The  computation is not covered by this work.






Once  is computed, its value is concatenated  times in the following way:


Suppose that  has 6 bits, so:
 


Thus,  is computed from  with only one multiplication.


\begin{fato}
When subtracting , the result starts with 1 if and only if .
\end{fato}

Let  and , thus . As the subtraction result starts with zero, then .




Suppose  and . Thus . As the subtraction result starts with 1, .


To compare  with all words in  in , a subtraction between  for all   is performed in one operation. That means many comparisons with only one operation.
The calculus is 



The first bit of each block will indicate if  is lesser than or equal or greater than . As the sketches are sorted in a , the first block that starts with 1 must be found. Suppose that the number of bits of a block  is . To remove all bits except the first bit of each block, a bitwise AND is performed between  and a mask with value 1 in the positions , ,  and so on. Let  the result of such bitwise AND. The next step consists in finding the most significant bit that values 1. Such operation is equivalent to calculate  and must be performed in O(1). Such problem is found in the literature~\cite{hackers}.





The element   can be computed from the position of the first 1 in a . Following the steps of previous section, the rank value can be computed in . Thus the correct child to continue the search in a fusion tree is computed in .

The following example will provide a step-by-step execution of  with the same values used in Figure~\ref{fig_pesquisaTrie}:


Consider . The sketches will be 



The sketch node will be

and the  will be . The word to subtract from   will be:


Performing the subtraction and applying a bitwise AND it will result in:




The first bit that values 1 is . The bits are zero indexed, thus there are 8 bits from the beginning to the first 1. Such value divided by the block size 4 results in 2, which 
is the penultimate element in the sequence . Thus, because .







\subsection{
Sorting in  
}

This work detailed how to search a -bit word in    in a fusion tree data structure. It also describes how to sort  elements using B-tree.  All elements inserted in a fusion tree result in a sorted set of elements.
The paper~\cite{dynamic} shows how to transform a static fusion tree in a dynamic one. A dynamic fusion tree is optimized to update keys in  by update. The resulting sort complexity is



\section{Conclusion}
\label{cap:conclusao}

This work aimed to describe the fusion tree data structured and the  sorting algorithm. Step by step examples is prepared for didactic purposes. Very few materials are available related to this relevant issue. The challenge was to understand many theorems and non trivial concepts and prepare a material to a wide community.

	This work let some open questions as \textit{(i)} how to discover the first bit 1 in -bit word in ; \textit{(ii)} how to compute  in  and \textit{(iii)} how to create dynamic fusion tree optimized to update keys. Anyway, this work successfully completes the task of detailing the fusion tree data structure, responsible for the first  sorting algorithm and a basis for many other subsequent algorithms.
	
Such work also reveals some pitfalls in the use of lower bounds. For instance, if a generic problem needs at least  operations, the real lower bound is  because the widely accepted computational models are able to process  bit in .

An opportune future work would be to implement the fusion tree sorting algorithm and compare it with traditional algorithms. Another relevant aspect is the possibility of multiple operations in  and the removal of irrelevant bits. Such possibilities present theoretical and practical consequences. In the theoretical field, the question is which problems could have their complexity decreased with multiple operations in . In applied computing, the use of multiple operations inside a single word and the removal of irrelevant bits can accelerate traditional algorithms.






\bibliography{bibl}
\bibliographystyle{plain}






\end{document}
