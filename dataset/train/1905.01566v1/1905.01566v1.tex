

\documentclass[11pt,a4paper]{article}
\usepackage[hyperref]{naaclhlt2019}
\usepackage{times}
\usepackage{latexsym}

\usepackage{url}


\usepackage{amsmath}
\usepackage{lipsum}
\usepackage{latexsym}
\usepackage[latin1]{inputenc}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{array}
\usepackage{setspace}
\usepackage{hyperref}
\usepackage{float}
\usepackage{multirow}
\usepackage{enumitem}


\newcommand{\bq}{\textbf{q}}
\newcommand{\bp}{\textbf{p}}
\newcommand{\bh}{\textbf{h}}
\newcommand{\bc}{\textbf{c}}
\newcommand{\bs}{\textbf{s}}
\newcommand{\bm}{\textbf{m}}
\newcommand{\bx}{\textbf{x}}
\newcommand{\by}{\textbf{y}}
\newcommand{\bz}{\textbf{z}}
\newcommand{\bv}{\textbf{v}}
\newcommand{\bmx}{\pmb{\mathnormal{x}}}
\newcommand{\bmy}{\pmb{\mathnormal{y}}}
\newcommand{\bmz}{\pmb{\mathnormal{z}}}
\newcommand{\prob}{\mathbb{P}}
\newcommand{\lclass}{\mathcal{L}_{\text{class}}}
\newcommand{\lreg}{\mathcal{L}_{\text{reg}}}
\newcommand{\loss}{\mathcal{L}}
\newcommand{\cev}[1]{\reflectbox{\ensuremath{\vec{\reflectbox{\ensuremath{#1}}}}}}

\newcommand{\greg}[1]{\textcolor{red}{#1}}
\definecolor{mygreen}{rgb}{0.114, 0.529, 0.106}
\newcommand{\yasu}[1]{\textcolor{mygreen}{#1}}
  
\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\usepackage[skip=4pt]{caption}
\usepackage{natbib}
\usepackage{todonotes}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{bbm}


\aclfinalcopy 



\newcommand\BibTeX{B{\sc ib}\TeX}

\title{Learning to Denoise Distantly-Labeled Data for Entity Typing}




\author{Yasumasa Onoe \and Greg Durrett\\
  Department of Computer Science \\
  The University of Texas at Austin \\
  {\tt\{yasumasa, gdurrett\}@cs.utexas.edu}}


\date{}

\begin{document}
\maketitle
\begin{abstract}
Distantly-labeled data can be used to scale up training of statistical models, but it is typically noisy and that noise can vary with the distant labeling technique. In this work, we propose a two-stage procedure for handling this type of data: denoise it with a learned model, then train our final model on clean and denoised distant data with standard supervised training. Our denoising approach consists of two parts. First, a filtering function discards examples from the distantly labeled data that are wholly unusable. Second, a relabeling function repairs noisy labels for the retained examples. Each of these components is a model trained on synthetically-noised examples generated from a small manually-labeled set.  We investigate this approach on the ultra-fine entity typing task of \citet{Eunsol_Choi_18}. Our baseline model is an extension of their model with pre-trained ELMo representations, which already achieves state-of-the-art performance. Adding distant data that has been denoised with our learned models gives further performance gains over this base model, outperforming models trained on raw distant data or heuristically-denoised distant data.

\end{abstract}




\section{Introduction}\label{intro}

With the rise of data-hungry neural network models, system designers have turned increasingly to unlabeled and weakly-labeled data in order to scale up model training. For information extraction tasks such as relation extraction and entity typing, distant supervision \cite{Mike_Mintz_09} is a powerful approach for adding more data, using a knowledge base \cite{delcorro-EtAl:2015:EMNLP,rabinovich-klein:2017:Short} or heuristics \cite{ratner16-data-programming,hancock2018} to automatically label instances. One can treat this data just like any other supervised data, but it is noisy; more effective approaches employ specialized probabilistic models \cite{Sebastian_Riedel10,ratner-snorkel}, capturing its interaction with other supervision \cite{Hai_Wang_18} or breaking down aspects of a task on which it is reliable \cite{Alexander_Ratner_18}. However, these approaches often require sophisticated probabilistic inference for training of the final model. Ideally, we want a technique that handles distant data just like supervised data, so we can treat our final model and its training procedure as black boxes.

This paper tackles the problem of exploiting weakly-labeled data in a structured setting with a two-stage denoising approach. We can view a distant instance's label as a noisy version of a true underlying label. We therefore learn a model to turn a noisy label into a more accurate label, then apply it to each distant example and add the resulting denoised examples to the supervised training set. Critically, the denoising model can condition on both the example and its noisy label, allowing it to fully leverage the noisy labels, the structure of the label space, and easily learnable correspondences between the instance and the label.







\begin{figure*}[t]
\centering
    \begin{minipage}[t]{0.45\textwidth}
    \centering
    \includegraphics[width=1.0\linewidth]{motivating_example2.pdf}
    \end{minipage}
    \hspace{24pt}
    \begin{minipage}[t]{0.45\textwidth}
    \centering
    \includegraphics[width=1.0\linewidth]{motivating_example1.pdf}
    \end{minipage}
    \caption{Examples selected from the Ultra-Fine Entity Typing dataset of \citet{Eunsol_Choi_18}. (a) A manually-annotated example. (b) The head word heuristic functioning correctly but missing types in (a). (c) Entity linking providing the wrong types. (d) Entity linking providing correct but incomplete types.}
    \label{fig:ds-example}
\end{figure*}



Concretely, we implement our approach for the task of fine-grained entity typing, where a single entity may be assigned many labels. We learn two denoising functions: a \emph{relabeling} function takes an entity mention with a noisy set of types and returns a cleaner set of types, closer to what manually labeled data has. A \emph{filtering} function discards examples which are deemed too noisy to be useful. These functions are learned by taking manually-labeled training data, synthetically adding noise to it, and learning to denoise, similar to a conditional variant of a denoising autoencoder \cite{Pascal_Vincent_08}. Our denoising models embed both entities and labels to make their predictions, mirroring the structure of the final entity typing model itself.

We evaluate our model following \citet{Eunsol_Choi_18}. We chiefly focus on their ultra-fine entity typing scenario and use the same two distant supervision sources as them, based on entity linking and head words. On top of an adapted model from \citet{Eunsol_Choi_18} incorporating ELMo \cite{ELMO_18}, na\"{i}vely adding distant data actually hurts performance. However, when our learned denoising model is applied to the data, performance improves, and it improves more than heuristic denoising approaches tailored to this dataset. Our strongest denoising model gives a gain of 3 F absolute over the ELMo baseline, and a 4.4 F improvement over naive incorporation of distant data. This establishes a new state-of-the-art on the test set, outperforming concurrently published work \cite{Wenhan_Xiong_2019} and matching the performance of a BERT model \cite{BERT18} on this task. Finally, we show that denoising helps even when the label set is projected onto the OntoNotes label set \cite{HovyEtAl2006,Dan_Gillick_14}, outperforming the method of \citet{Eunsol_Choi_18} in that setting as well.






\section{Setup}\label{setup}
We consider the task of predicting a structured target  associated with an input . Suppose we have high-quality labeled data of  (input, target) pairs , and noisily labeled data of  (input, target) pairs . For our tasks,  is collected through manual annotation and  is collected by distant supervision. 
We use two models to denoise data from : a filtering function  disposes of unusable data (e.g., mislabeled examples) and a relabeling function  transforms the noisy target labels  to look more like true labels. This transformation improves the noisy data so that we can use it to  without introducing damaging amounts of noise. In the second stage, a classification model is trained on the augmented data ( combined with denoised ) and predicts  given  in the inference phase. 



\subsection{Case Study: Ultra-Fine Entity Typing}

The primary task we address here is the fine-grained entity typing task of \citet{Eunsol_Choi_18}. Instances in the corpus are assigned types from a vocabulary of more than 10,000 types, which are divided into three classes:  \textit{general} types,  \textit{fine-grained} types, and  \textit{ultra-fine} types. This dataset consists of 6K manually annotated examples and approximately 25M distantly-labeled examples. 5M examples are collected using entity linking (EL) to link mentions to Wikipedia and gather types from information on the linked pages. 20M examples (HEAD) are generated by extracting nominal head words from raw text and treating these as singular type labels.






\begin{figure*}[t]
\centering
    \centering
    \includegraphics[width=1.0\linewidth]{fig2_camera_ready_revised.pdf}
    \caption{Denoising models. The \emph{Filter} model predicts whether the example should be kept at all; if it is kept, the \emph{Relabel} model attempts to automatically expand the label set.  is a mention encoder, which can be a state-of-the-art entity typing model.  encodes noisy types from distant supervision.}
    \label{fig:high-level}
\end{figure*}



Figure~\ref{fig:ds-example} shows examples from these datasets which illustrate the challenges in automatic annotation using distant supervision. The manually-annotated example in (a) shows how numerous the gold-standard labeled types are. By contrast, the HEAD example (b) shows that simply treating the head word as the type label, while correct in this case, misses many valid types, including more general types. The EL example (c) is incorrectly annotated as \texttt{region}, whereas the correct coarse type is actually \texttt{person}. This error is characteristic of entity linking-based distant supervision since identifying the correct link is a challenging problem in and of itself \cite{MilneWitten2008}: in this case, \emph{Gascoyne} is also the name of a region in Western Australia. The EL example in (d) has reasonable types; however, human annotators could choose more types (grayed out) to describe the mention more precisely. The average number of types annotated by humans is  per example while the two distant supervision techniques combined yields  types per example on average. 



In summary, distant supervision can (1) produce completely incorrect types, and (2) systematically miss certain types.





\section{Denoising Model}\label{cdae}

To handle the noisy data, we propose to learn a denoising model as shown in Figure~\ref{fig:high-level}. This denoising model consists of filtering and relabeling functions to discard and relabel examples, respectively; these rely on a shared mention encoder and type encoder, which we describe in the following sections. The filtering function is a binary classifier that takes these encoded representations and predicts whether the example is good or bad. The relabeling function predicts a new set of labels for the given example.

We learn these functions in a supervised fashion. Training data for each is created through synthetic noising processes applied to the manually-labeled data, as described in Sections~\ref{filter} and \ref{relabel}.

For the entity typing task, each example  takes the form , where  is the sentence,  is the mention span, and  is the set of types (either clean or noisy).


\subsection{Mention Encoder}

This encoder is a function  which maps a sentence  and mention  to a real-valued vector . This allows the filtering and relabeling function to recognize inconsistencies between the given example and the provided types. Note that these inputs  and  are the same as the inputs for the supervised version of this task; we can therefore share an encoder architecture between our denoising model and our final typing model. We use an encoder following \citet{Eunsol_Choi_18} with a few key differences, which are described in Section~\ref{model_details}.


\subsection{Type Encoder}

The second component of our model is a module which produces a vector . This is an encoder of an unordered bag of types. Our basic type encoder uses trainable vectors as embeddings for each type and combines these with summing. That is, the noisy types  are embedded into type vectors .
The final embedding of the type set . 

\paragraph{Type Definition Encoder} Using trainable type embeddings exposes the denoising model to potential data sparsity issues, as some types appear only a few or zero times in the training data.  Therefore, we also assign each type a vector based on its definition in WordNet \cite{wordnet_1995}. Even low-frequent types are therefore assigned a plausible embedding.\footnote{We found this technique to be more effective than using pretrained vectors from GloVe or ELMo. It gave small improvements on an intrinsic evaluation over not incorporating it; results are omitted due to space constraints.}

Let  denote the th word of the th type's most common WordNet definition. Each  is embedded using GloVe \cite{glove_14}. The resulting word embedding vectors  are fed into a bi-LSTM \cite{lstm, bilstm}, and a concatenation of the last hidden states in both directions is used as the definition representation . The final representation of the definitions is the sum over these vectors for each type: .  

Our final , the concatenation of the type and definition embedding vectors.



\vspace{6pt}
 

\subsection{Filtering Function}\label{filter}

The filtering function  is a binary classifier designed to detect examples that are completely mislabeled. Formally,  is a function mapping a labeled example  to a binary indicator  of whether this example should be discarded or not.

In the forward computation, the feature vectors  and  are computed using the mention and type encoders. The model prediction is defined as , where  is a sigmoid function,  is a parameter vector, and  is a 1-layer highway network \cite{highway15}. We can apply  to each distant pair in our distant dataset  and discard any example predicted to be erroneous ().

\vspace{-4pt}
\paragraph{Training data} We do not know a priori which examples in the distant data should be discarded, and labeling these is expensive. We therefore construct synthetic training data  for  based on the manually labeled data . For 30\% of the examples in , we replace the gold types for that example with \emph{non-overlapping} types taken from another example. The intuition for this procedure follows Figure~\ref{fig:ds-example}: we want to learn to detect examples in the distant data like \emph{Gascoyne} where heuristics like entity resolution have misfired and given a totally wrong label set.

Formally, for each selected example , we repeatedly draw another example  from  until we find  that does not have any common types with . We then create a positive training example . We create a negative training example  using the remaining  of examples.  is trained on  using binary cross-entropy loss. 



\subsection{Relabeling Function}\label{relabel}

The relabeling function  is designed to repair examples that make it through the filter but which still have errors in their type sets, such as missing types as shown in Figure~\ref{fig:ds-example}b and \ref{fig:ds-example}d.  is a function from a labeled example  to an improved type set  for the example.

Our model computes feature vectors  and  by the same procedure as the filtering function . The decoder is a linear layer with parameters . We compute , where  is an element-wise sigmoid operation designed to give binary probabilities for each type.

Once  is trained, we make a prediction  for each  and replace  by  to create the denoised data . For the final prediction, we choose all types  where , requiring at least two types to be present or else we discard the example.

\vspace{-4pt}
\paragraph{Training data} We train the relabeling function  on another synthetically-noised dataset  generated from the manually-labeled data . To mimic the type distribution of the distantly-labeled examples, we take each example  and randomly drop each type with a fixed rate  independent of other types to produce a new type set . We perform this process for all examples in  and create a noised training set , where a single training example is .  is trained on  with a binary classification loss function over types used in \citet{Eunsol_Choi_18}, described in the next section.

One can think of  as a type of denoising autoencoder \cite{Pascal_Vincent_08} whose reconstructed types  are conditioned on  as well as .




\section{Typing Model}\label{model_details}

In this section, we define the sentence and mention encoder , which is use both in the denoising model as well as in the final prediction task. We extend previous attention-based models for this task \cite{Sonse_Shimaoka_17,Eunsol_Choi_18}. At a high level, we have an instance encoder  that returns a vector , then multiply the output of this encoding by a matrix and apply a sigmoid to get a binary prediction for each type as a probability of that type applying.

Figure~\ref{fig:model} outlines the overall architecture of our typing model. The encoder  consists of four vectors: a sentence representation , a word-level mention representation , a character-level mention representation , and a headword mention vector . The first three of these were employed by \citet{Eunsol_Choi_18}. We have modified the mention encoder with an additional bi-LSTM to better encode long mentions, and additionally used the headword embedding directly in order to focus on the most critical word. These pieces use pretrained contextualized word embeddings (ELMo) \cite{ELMO_18} as input. 

\paragraph{Pretrained Embeddings} 
Tokens in the sentence  are converted into contextualized word vectors using ELMo; let  denote the embedding of the th word. As suggested in \citet{ELMO_18}, we learn task specific parameters  and  governing these embeddings. We do not fine-tune the parameters of the ELMo LSTMs themselves.




\begin{figure}[t]
\centering
    \centering
    \includegraphics[width=1.0\linewidth]{fig3_camera_ready_revised.pdf}
    \caption{Sentence and mention encoder used to predict types. We compute attention over LSTM encodings of the sentence and mention, as well as using character-level and head-word representations to capture additional mention properties. These combine to form an encoding which is used to predict types.}
    \label{fig:model}
\end{figure}



\vspace{-4pt}
\paragraph{Sentence Encoder}  Following \citet{Eunsol_Choi_18}, we concatenate the th word vector  in the sentence with a corresponding location embedding . Each word is assigned one of four location tokens, based on whether (1) the word is in the left context, (2) the word is the first word of the mention span, (3) the word is in the mention span (but not first), and (4) the word is in the right context. The input vectors  are fed into a bi-LSTM encoder, with hidden dimension is , followed by a span attention layer \cite{Kenton_Lee17,Eunsol_Choi_18}: , where  is the final representation of the sentence .

\vspace{-4pt}
\paragraph{Mention Encoder} To obtain a mention representation, we use both word and character information. For the word-level representation, the mention's contextualized word vectors  are fed into a bi-LSTM with hidden dimension is . The concatenated hidden states of both directions are summed by a span attention layer to form the word-level mention representation: .

Second, a character-level representation is computed for the mention. Each character is embedded and then a 1-D convolution \cite{nlpfromscratch11} is applied over the characters of the mention. This gives a character vector .

Finally, we take the contextualized word vector of the headword   as a third component of our representation.  This can be seen as a residual connection \cite{resnet16} specific to the mention head word.  We find the headwords in the mention spans by parsing those spans in isolation using the spaCy dependency parser \cite{spacy_15}. Empirically, we found this to be useful on long spans, when the span attention would often focus on incorrect tokens.

The final representation of the input  is a concatenation of the sentence, the word- \& character-level mention, and the mention headword representations, .

\vspace{-4pt}
\paragraph{Decoder}  We treat each label prediction as an independent binary classification problem. Thus, we compute a score for each type in the type vocabulary . 
Similar to the decoder of the relabeling function , we compute , where  and  . For the final prediction, we choose all types  where . If none of  is greater than , we choose  (the single most probable type).

\vspace{-4pt}
\paragraph{Loss Function} We use the same loss function as \citet{Eunsol_Choi_18} for training. This loss partitions the labels in general, fine, and ultra-fine classes, and only treats an instance as an example for types of the class in question if it contains a label for that class. More precisely:
\vspace{-6pt}


where  is a loss function for a specific type class: general, fine-grained, or ultra-fine, and  is an indicator function that is active when one of the types  is in the type class. Each  is a sum of binary cross-entropy losses over all types in that category. That is, the typing problem is viewed as independent classification for each type.

Note that this loss function already partially repairs the noise in distant examples from missing labels: for example, it means that examples from HEAD do not count as negative examples for general types when these are not present. However, we show in the next section that this is not sufficient for denoising.

\vspace{-4pt}
\paragraph{Implementation Details} The settings of hyperparameters in our model largely follows \citet{Eunsol_Choi_18} and recommendations for using the pretrained ELMo-Small model.\footnote{\url{https://allennlp.org/elmo}} The word embedding size  is . The type embedding size and the type definition embedding size are set to . For most of other model hyperparameters, we use the same settings as \citet{Eunsol_Choi_18}: , , .
The number of filters in the 1-d convolutional layer is . Dropout is applied with  for the pretrained embeddings, and  for the mention representations. We limit sentences to 50 words and mention spans to 20 words for computational reasons. The character CNN input is limited to  characters; most mentions are short, so this still captures subword information in most cases. The batch size is set to . For all experiments, we use the Adam optimizer \cite{Kingma_14}. The initial learning rate is set to 2e-03. We implement all models\footnote{The code for experiments is available at \url{https://github.com/yasumasaonoe/DenoiseET}} using PyTorch. To use ELMo, we consult the AllenNLP source code. 





\section{Experiments}\label{experiments}

\paragraph{Ultra-Fine Entity Typing}
We evaluate our approach on the ultra-fine entity typing dataset from \citet{Eunsol_Choi_18}.  The 6K manually-annotated English examples are equally split into the training, development, and test examples by the authors of the dataset. We generate synthetically-noised data,  and , using the 2K training set to train the filtering and relabeling functions,  and . We randomly select 1M EL and 1M HEAD examples and use them as the noisy data . Our augmented training data is a combination of the manually-annotated data  and . 

\vspace{-4pt}
\paragraph{OntoNotes}
In addition, we investigate if denoising leads to better performance on another dataset. We use the English OntoNotes dataset \cite{Dan_Gillick_14}, which is a widely used benchmark for fine-grained entity typing systems. The original training, development, and test splits contain 250K, 2K, and 9K examples respectively. \citet{Eunsol_Choi_18} created an augmented training set that has 3.4M examples. We also construct our own augmented training sets with/without denoising using our noisy data , using the same label mapping from ultra-fine types to OntoNotes types described in \citet{Eunsol_Choi_18}. 





\subsection{Ultra-Fine Typing Results}

We first compare the performance of our approach to several benchmark systems, then break down the improvements in more detail. We use the model architecture described in Section~\ref{model_details} and train it on the different amounts of data: manually labeled only, naive augmentation (adding in the raw distant data), and denoised augmentation. We compare our model to \citet{Eunsol_Choi_18} as well as to BERT \cite{BERT18}, which we fine-tuned for this task. We adapt our task to BERT by forming an input sequence "\texttt{[CLS] sentence [SEP] mention [SEP]}" and assign the segment embedding A to the sentence and B to the mention span.\footnote{We investigated several approaches, including taking the head word piece from the last layer and using that for classification (more closely analogous to what \citet{BERT18} did for NER), but found this one to work best.} Then, we take the output vector at the position of the \texttt{[CLS]} token (i.e., the first token) as the feature vector , analogous to the usage for sentence pair classification tasks. The BERT model is fine-tuned on the 2K manually annotated examples. We use the pretrained BERT-Base, uncased model\footnote{\url{https://github.com/google-research/bert}} with a step size of 2e-05 and batch size 32.





\vspace{-4pt}
\paragraph{Results} Table~\ref{tab:ultra-fine-dev-breakdown} compares the performance of these systems on the development set. Our model with no augmentation already matches the system of \citet{Eunsol_Choi_18} with augmentation, and incorporating ELMo gives further gains on both precision and recall. On top of this model, adding the distantly-annotated data lowers the performance; the loss function-based approach of \cite{Eunsol_Choi_18} does not sufficiently mitigate the noise in this data. However, denoising makes the distantly-annotated data useful, improving recall by a substantial margin especially in the general class. A possible reason for this is that the relabeling function tends to add more general types given finer types. BERT performs similarly to ELMo with denoised distant data. As can be seen in the performance breakdown, BERT gains from improvements in recall in the fine class.   


\renewcommand{\arraystretch}{1}
\begin{table*}[t]
	\centering
	\small
	\setlength{\tabcolsep}{4pt}
\begin{tabular}{l c c c c c c c c c c c c}
\toprule
		\multicolumn{1}{c}{} & \multicolumn{3}{c}{Total} & \multicolumn{3}{c}{General} & \multicolumn{3}{c}{Fine} & \multicolumn{3}{c}{Ultra-Fine} \\
	    \cmidrule(r){2-4}  \cmidrule(r){5-7} \cmidrule(r){8-10} \cmidrule(r){11-13}
		\multicolumn{1}{c}{Model}
		 & P & R & F1  & P & R & F1 & P & R & F1 & P & R & F1\\
		\midrule
Ours + GloVe w/o augmentation & 46.4 & 23.3 & 31.0  & 57.7 & 65.5 & 61.4 & 41.3 & 31.3 & 35.6 & 42.4 & 9.2 & 15.1\\
		Ours + ELMo w/o augmentation & \textbf{55.6} & 28.1 & 37.3  & \textbf{69.3} & 77.3 & 73.0 & \textbf{47.9} & 35.4 & 40.7 & \textbf{48.9} & 12.6 & 20.0\\
		Ours + ELMo w augmentation & 55.2 & 26.4 & 35.7  & 69.4 & 72.0 & 70.7 & 46.6 & 38.5 & 42.2 & 48.7 & 10.3 & 17.1\\
		Ours + ELMo w augmentation & 50.7 & \textbf{33.1} & \textbf{40.1}  & 66.9 & \textbf{80.7} & 73.2 & 41.7 & 46.2 & 43.8 & 45.6 & \textbf{17.4} & \textbf{25.2}\\
		\hspace{48pt} + filter \& relabel &  &  &  &  &  &  &  &  &  &  &  & \\
		BERT-Base, Uncased & 51.6 & 32.8 & \textbf{40.1}  & 67.4 & 80.6 & \textbf{73.4} & 41.6 & \textbf{54.7} & \textbf{47.3} & 46.3 & 15.6 & 23.4\\
		\midrule
		\citet{Eunsol_Choi_18} w augmentation &  48.1 & 23.2 & 31.3 & 60.3 & 61.6 & 61.0 & 40.4 & 38.4 & 39.4 & 42.8 & 8.8 & 14.6\\
		\bottomrule 
	\end{tabular}
\caption{Macro-averaged P/R/F1 on the dev set for the entity typing task of \citet{Eunsol_Choi_18} comparing various systems. ELMo gives a substantial improvement over baselines. Over an ELMo-equipped model, data augmentation using the method of \citet{Eunsol_Choi_18} gives no benefit. However, our denoising technique allow us to effectively incorporate distant data, matching the results of a BERT model on this task \cite{BERT18}.} \label{tab:ultra-fine-dev-breakdown}
\end{table*}






Table~\ref{tab:ultra-fine-test} shows the performance of all settings on the test set, with the same trend as the performance on the development set. Our approach outperforms the concurrently-published \citet{Wenhan_Xiong_2019}; however, that work does not use ELMo. Their improved model could be used for both denoising as well as prediction in our setting, and we believe this would stack with our approach.



\vspace{-4pt}
\paragraph{Usage of Pretrained Representations} Our model with ELMo trained on denoised data matches the performance of the BERT model. We experimented with incorporating distant data (raw and denoised) in BERT, but the fragility of BERT made it hard to incorporate: training for longer generally caused performance to go down after a while, so the model cannot exploit large external data as effectively. \citet{BERT18} prescribe training with a small batch size and very specific step sizes, and we found the model very sensitive to these hyperparameters, with only 2e-05 giving strong results. The ELMo paradigm of incorporating these as features is much more flexible and modular in this setting. Finally, we note that our approach could use BERT for denoising as well, but this did not work better than our current approach. Adapting BERT to leverage distant data effectively is left for future work.




\subsubsection{Comparing Denoising Models}

We now explicitly compare our denoising approach to several baselines. For each denoising method, we create the denoised EL, HEAD, and EL\:\&\:HEAD dataset and investigate performance on these datasets. Any denoised dataset is combined with the 2K manually-annotated examples and used to train the final model.

\vspace{-4pt}
\paragraph{Heuristic Baselines} These heuristics target the same factors as our filtering and relabeling functions in a non-learned way.\begin{description}[align=left, font=\sc, topsep=2pt, labelsep=\fontdimen2\font, leftmargin=0pt]
\setlength\itemsep{-0.1em}
\item [Synonyms and Hypernyms] \hspace{2pt} For each type observed in the distant data, we add its synonyms and hypernyms using WordNet \cite{wordnet_1995}. This is motivated by the data construction process in  \citet{Eunsol_Choi_18}.
\item [Common Type Pairs]  \hspace{2pt} We use type pair statistics in the manually labeled training data. For each base type that we observe in a distant example, we add any type which is seen more than 90\% of the time the base type occurs. For instance, the type \texttt{art} is given at least 90\% of the times the \texttt{film} type is present, so we automatically add \texttt{art} whenever \texttt{film} is observed.  
\item [Overlap] \hspace{2pt} We train a model on the manually-labeled data only, then run it on the distantly-labeled data. If there is an intersection between the noisy types  and the predicted type , we combine them and use as the expanded type . Inspired by tri-training \cite{tri05}, this approach adds ``obvious'' types but avoids doing so in cases where the model has likely made an error. \end{description}



\renewcommand{\arraystretch}{1}
\begin{table}[t]
	\centering
\small
	\setlength{\tabcolsep}{4pt}
\begin{tabular}{l  c  c  c }
\toprule
		\multicolumn{1}{c }{Model}
		 & P & R & F1\\
		\midrule
		Ours + GloVe w/o augmentation & 47.6 & 23.3 & 31.3  \\
		Ours + ELMo w/o augmentation & \textbf{55.8} & 27.7 & 37.0 \\
		Ours + ELMo w augmentation & 55.5 & 26.3 & 35.7 \\
		Ours + ELMo w augmentation & 51.5 & \textbf{33.0} & \textbf{40.2} \\
		\hspace{48pt} + filter \& relabel & &  \\
		BERT-Base, Uncased  & 51.6 & \textbf{33.0} & \textbf{40.2} \\
		\midrule
		\citet{Eunsol_Choi_18} w augmentation & 47.1 & 24.2 & 32.0  \\
		\textsc{LabelGCN} \cite{Wenhan_Xiong_2019} & 50.3 & 29.2 & 36.9\\
		\bottomrule 
	\end{tabular}
\caption{Macro-averaged P/R/F1 on the test set for the entity typing task of \citet{Eunsol_Choi_18}. Our denoising approach gives substantial gains over naive augmentation and matches the performance of a BERT model.}
	\label{tab:ultra-fine-test}
\end{table}




 
\renewcommand{\arraystretch}{1}
\begin{table*}[t]
	\centering
	\small
	\setlength{\tabcolsep}{4pt}
\begin{tabular}{l  l  c  c  c  c  c  c  c  c  c  c  c  c}
\toprule
		\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{3}{c}{EL\:\&\:HEAD} & \multicolumn{1}{c}{} & \multicolumn{3}{c}{EL} & \multicolumn{1}{c}{} & \multicolumn{3}{c}{HEAD}\\
	    \cmidrule(r){4-6}  \cmidrule(r){8-10} \cmidrule(r){12-14} 
		\multicolumn{1}{c}{Type} & \multicolumn{1}{c}{Denoising Method} & \multicolumn{1}{c}{} & P & R & F1 & & P & R & F1 & & P & R & F1\\
		\midrule
\multirow{1}{*}{\text{}} & \textsc{Raw Data} & & \textbf{55.2} & 26.4 & 35.7 & & 52.3 & 26.1 & 34.8 & & \textbf{52.8} & 28.4 & 36.9\\
		\multirow{1}{*}{\text{Heuristic Baselines}} & \textsc{Synonyms\:\&\:Hypernyms} & & 43.0 & 30.0 & 35.3 & & 47.5 & 26.3 & 33.9 & & 44.8 & 31.7 & 37.1\\
		& \textsc{Pair} & & 50.2 & 29.0 & 36.8 & & 49.6 & 27.0 & 35.0 & & 50.6 & 31.2 & 38.6\\
		\vspace{4pt}
		& \textsc{Overlap} & & 50.0 & 32.3 & 39.2 & &  49.5 & \textbf{30.8} & 38.0 & & 50.6 & 31.4 & 38.7\\
		\multirow{1}{*}{\text{Proposed Approach}} & \textsc{Filter} & & 53.1 & 28.2 & 36.8 & & 51.9 & 26.5 & 35.1 & & 51.2 & 31.2 & 38.7\\
		& \textsc{Relabel} & & 52.1 & 32.2 & 39.8 & & 50.2 & 31.4 & 38.6 & & 50.2 & 31.8 & 38.9\\
		& \textsc{Filter\:\&\:Relabel} & & 50.7 & \textbf{33.1} & \textbf{40.1} & & \textbf{52.7} & 30.5 & \textbf{38.7} & & 50.7 & \textbf{32.1} & \textbf{39.3}\\
		\midrule
		& \citet{Eunsol_Choi_18} & &  48.1 & 23.2 & 31.3 & & 50.3 & 19.6 & 28.2 & & 48.4 & 22.3 & 30.6\\
		\bottomrule 
	\end{tabular}
\caption{Macro-averaged P/R/F1 on the dev set for the entity typing task of \citet{Eunsol_Choi_18} with various types of augmentation added. The customized loss from \citet{Eunsol_Choi_18} actually causes a decrease in performance from adding any of the datasets. Heuristics can improve incorporation of this data: a relabeling heuristic (Pair) helps on HEAD and a filtering heuristic (Overlap) is helpful in both settings. However, our trainable filtering and relabeling models outperform both of these techniques.}\label{tab:ultra-fine-dev-denoise}
\end{table*}







\vspace{-4pt}
\paragraph{Results}  Table~\ref{tab:ultra-fine-dev-denoise} compares the results on the development set. We report the performance on each of the EL\:\&\:HEAD, EL, and HEAD dataset. On top of the baseline \textsc{Original}, adding synonyms and hypernyms by consulting external knowledge does not improve the performance. Expanding labels with the \textsc{Pair} technique results in small gains over \textsc{Original}. \textsc{Overlap} is the most effective heuristic technique.  This simple filtering and expansion heuristic improves recall on EL. \textsc{Filter}, our model-based example selector, gives similar improvements to \textsc{Pair} and \textsc{Overlap} on the HEAD setting, where filtering noisy data appears to be somewhat important.\footnote{One possible reason for this is identifying stray word senses; \emph{film} can refer to the physical photosensitive object, among other things.} \textsc{Relabel} and \textsc{Overlap} both improve performance on both EL and HEAD while other methods do poorly on EL. Combining the two model-based denoising techniques, \textsc{Filter\:\&\:Relabel} outperforms all the baselines. 




\subsection{OntoNotes Results}\label{dis-onto}

We compare our different augmentation schemes for deriving data for the OntoNotes standard as well. Table~\ref{tab:onto-test} lists the results on the OntoNotes test set following the adaptation setting of \citet{Eunsol_Choi_18}. Even on this dataset, denoising significantly improves over naive incorporation of distant data, showing that the denoising approach is not just learning quirks of the ultra-fine dataset. Our augmented set is constructed from 2M seed examples while \citet{Eunsol_Choi_18} have a more complex procedure for deriving augmented data from 25M examples. Ours (total size of 2.1M) is on par with their larger data (total size of 3.4M), despite having 40\% fewer examples. In this setting, BERT still performs well but not as well as our model with augmented training data.

One source of our improvements from data augmentation comes from additional data that is able to be used because \emph{some} OntoNotes type can be derived. This is due to denoising doing a better job of providing correct general types. In the EL setting, this yields 730k usable examples out of 1M (vs 540K for no denoising), and in HEAD, 640K out of 1M (vs. 73K).




\renewcommand{\arraystretch}{1}
\begin{table}[t]
	\centering
	\vspace{-18pt}
	\small
	\setlength{\tabcolsep}{4pt}
\begin{tabular}{lccc}
\toprule
		\multicolumn{1}{c}{Model}
		 &{Acc.} & {Ma-F1}& {Mi-F1} \\
		\midrule
		Ours + ELMo w/o augmentation & 42.7 & 72.7  & 66.7\\
		Ours + ELMo w augmentation & 59.3 & 76.5 & 70.7\\
		Ours + ELMo w augmentation & 63.9 & \textbf{84.5} & 78.9\\
		\hspace{48pt} + filter \& relabel  & & \\
		Ours + ELMo w augmentation & \textbf{64.9} & \textbf{84.5} & \textbf{79.2}\\
		\hspace{40pt} by \citet{Eunsol_Choi_18}  &  &  \\
		BERT-Base, Uncased  & 51.8 & 76.6 & 69.1 \\
		\midrule
		\citet{Sonse_Shimaoka_17} & 51.7 & 70.9 & 64.9\\
	    AFET \cite{Xiang_Ren_16a} & 55.1 & 71.1 & 64.7 \\
	    PLE \cite{Xiang_Ren_16b} & 57.2 & 71.5 & 66.1 \\
		\citet{Eunsol_Choi_18} & 59.5 & 76.8 & 71.8 \\
		\textsc{LabelGCN} \cite{Wenhan_Xiong_2019} & 59.6 & 77.8 & 72.2\\
		\bottomrule 
	\end{tabular}
\caption{Test results on OntoNotes. Denoising helps substantially even in this reduced setting. Using fewer distant examples, we nearly match the performance using the data from \citet{Eunsol_Choi_18} (see text).}
	\label{tab:onto-test}
\end{table}






\subsection{Analysis of Denoised Labels}

To understand what our denoising approach does to the distant data, we analyze the behavior of our filtering and relabeling functions. Table~\ref{tab:relabel} reports the average numbers of types added/deleted by the relabeling function and the ratio of examples discarded by the filtering function.

Overall, the relabeling function tends to add more and delete fewer number of types. The HEAD examples have more general types added than the EL examples since the noisy HEAD labels are typically finer. Fine-grained types are added to both EL and HEAD examples less frequently. Ultra-fine examples are frequently added to both datasets, with more added to EL; the noisy EL labels are mostly extracted from Wikipedia definitions, so those labels often do not include ultra-fine types. The filtering function discards similar numbers of examples for the EL and HEAD data:  and  respectively.

Figure~\ref{fig:relabel_ex} shows examples of the original noisy labels and the denoised labels produced by the relabeling function. In example (a), taken from the EL data, the original labels, {\tt \{location, city\}}, are correct, but human annotators might choose more types for the mention span, {\bf Minneapolis}. The relabeling function retains the original types about the geography and adds ultra-fine types about administrative units such as {\tt \{township, municipality\}}.
In example (b), from the HEAD data, the original label, {\tt \{dollar\}}, is not so expressive by itself since it is a name of a currency. The labeling function adds coarse types, {\tt \{object, currency\}}, as well as specific types such as {\tt \{medium of exchange, monetary unit\}}. In another EL example (c), the relabeling function tries to add coarse and fine types but struggles to assign multiple diverse {\it ultra-fine} types to the mention span {\bf Michelangelo}, possibly because some of these types rarely cooccur (\texttt{painter} and \texttt{poet}).


\renewcommand{\arraystretch}{1}
\begin{table}[t]
	\centering
	\small
	\setlength{\tabcolsep}{4pt}
\begin{tabular}{l c c c c c c c}
\toprule
		\multicolumn{1}{c}{} & \multicolumn{2}{c}{General} & \multicolumn{2}{c}{Fine} & \multicolumn{2}{c}{Ultra-Fine} \\
	    \cmidrule(r){2-3}  \cmidrule(r){4-5} \cmidrule(r){6-7}
		\multicolumn{1}{c}{Data}
		 & Add & Del & Add & Del  & Add & Del & Filter (\%) \\
		\midrule
EL & 0.87 & 0.01 & 0.36 & 0.17 & 2.03 & 0.12 & 9.4\\
		HEAD  & 1.18 & 0.00 & 0.51 & 0.01 & 1.15 & 0.16 & 10.0 \\
		\bottomrule 
	\end{tabular}
\caption{The average number of types added or deleted by the relabeling function per example. The right-most column shows that the rate of examples discarded by the filtering function.} \label{tab:relabel}
\end{table}








\section{Related Work}

Past work on denoising data for entity typing has used multi-instance multi-label learning \cite{Yaghoobzadeh15, Yaghoobzadeh17, Murty18}. One view of these approaches is that they delete noisily-introduced labels, but they cannot add them, or filter bad examples. Other work focuses on learning type embeddings \cite{Yogatama15,Xiang_Ren_16a, Xiang_Ren_16b}; our approach goes beyond this in treating the label set in a structured way. The label set of \citet{Eunsol_Choi_18} is distinct in not being explicitly hierarchical, making past hierarchical approaches difficult to apply.




\begin{figure}[t]
    \centering
    \includegraphics[width=1.0\linewidth]{relabeled_examples.pdf}
    \caption{Examples of the noisy labels (left) and the denoised labels (right) for mentions (bold). The colors correspond to type classes: {\it general} (purple), {\it fine-grained} (green), and {\it ultra-fine} (yellow).}
    \label{fig:relabel_ex}
\end{figure}




Denoising techniques for distant supervision have been applied extensively to relation extraction. Here, multi-instance learning and probabilistic graphical modeling approaches have been used \cite{Sebastian_Riedel10, Raphael_Hoffmann11, Mihai_Surdeanu12, Shingo_Takamatsu_12} as well as deep models \cite{Yankai_Lin16, Xiaocheng_Feng17, Bingfeng_Luo17, Kai_Lei18, Xu_Han18}, though these often focus on incorporating signals from other sources as opposed to manually labeled data.




\section{Conclusion}

In  this  work,  we investigated the problem of denoising distant data for entity typing tasks. We trained a filtering function that discards examples from the distantly labeled data that are wholly unusable and a relabeling function that repairs noisy labels for the retained examples. When distant data is processed with our best denoising model, our final trained model achieves state-of-the-art performance on an ultra-fine entity typing task.


\section*{Acknowledgments}

This work was partially supported by NSF Grant IIS-1814522, NSF Grant SHF-1762299, a Bloomberg Data Science Grant, and an equipment grant from NVIDIA. The authors acknowledge the Texas Advanced Computing Center (TACC) at The University of Texas at Austin for providing HPC resources used to conduct this research. Results presented in this paper were obtained using the Chameleon testbed supported by the National Science Foundation. Thanks as well to the anonymous reviewers for their thoughtful comments, members of the UT TAUR lab and Pengxiang Cheng for helpful discussion, and Eunsol Choi for providing the full datasets and useful resources.

\bibliography{naaclhlt2019}
\bibliographystyle{acl_natbib}

\end{document}