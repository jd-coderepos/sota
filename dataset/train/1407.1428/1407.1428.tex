\documentclass{llncs}

\usepackage{graphics}
\usepackage[dvips]{epsfig}
\usepackage{breakcites}


\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{algorithm, algorithmic}



\newcommand{\noproof}{\hfill }
\newcommand{\reals}{I\!\!R}
\newcommand{\np}{\mbox{{\sc NP}}}
\newcommand{\sing}{\mbox{{\sc Sing}}}
\newcommand{\con}{\mbox{{\sc Con}}}
\newcommand{\hop}{\mbox{{\sc Hops}}}
\newcommand{\atm}{\mbox{{\sc ATM}}}
\newcommand{\hopn}{\hop_{\cN}}
\newcommand{\atmn}{\atm_{\cN}}
\newcommand{\cC}{{\cal C}}
\newcommand{\cN}{{\cal N}}
\newcommand{\cP}{{\cal P}}
\newcommand{\cD}{{\cal D}}
\newcommand{\cH}{{\cal H}}
\newcommand{\cS}{{\cal S}}
\newcommand{\D}{\Delta}
\newcommand{\cA}{{\cal A}}
\newcommand{\cR}{{\cal R}}

\newcommand{\A}{{\cal{R}}}
\newcommand{\E}{{\cal{E}}}
\newcommand{\Si}{\Sigma}

\newcommand{\classletter}{\ensuremath{\mathcal{G}}}
\newcommand{\ourclass}{\ensuremath{\classletter (k,\ell)}}
\newcommand{\treasure}{\ensuremath{g_{\ell+1}}}



\newcommand{\succeed}{{\sc success}}
\newcommand{\explore}{{\sc explore}}
\newcommand{\fail}{{\sc failure}}
\newcommand{\ceil}[1]{\lceil #1 \rceil}
\newcommand{\lcm}{\mbox{lcm}}
\newcommand{\dist}{\mbox{dist}}
\newcommand{\caL}{{\cal{L}}}

\newcommand{\remove}[1]{}

\newcommand{\qq}{\hfill  \smallbreak}

\newcommand{\cO}{{\cal O}}
\newcommand{\cZ}{{\mathbb Z}}
\newcommand{\bt}{{\bar t}}
\newcommand{\GC}{{\sc Graph\-Cover}}
\newcommand{\CW}{{\sc Cover\-Walk}}

\newcommand{\F}{\vspace*{\smallskipamount}}
\newcommand{\FF}{\vspace*{\medskipamount}}
\newcommand{\FFF}{\vspace*{\bigskipamount}}
\newcommand{\B}{\vspace*{-\smallskipamount}}
\newcommand{\BB}{\vspace*{-\medskipamount}}
\newcommand{\BBB}{\vspace*{-\bigskipamount}}
\newcommand{\BBBB}{\vspace*{-2.5\bigskipamount}}
\newcommand{\T}{\hspace*{1em}}
\newcommand{\TT}{\hspace*{2em}}
\newcommand{\TTT}{\hspace*{4em}}
\newcommand{\TTTT}{\hspace*{6em}}
\newcommand{\TTTTT}{\hspace*{10em}}


\newcommand{\caA}{{\cal{A}}}
\newcommand{\BW}{\mbox{\sc bw}}
\newcommand{\CBW}{\mbox{\sc cbw}}
\newcommand{\reco}{\mbox{\tt recognize}}
\newcommand{\recobis}{\mbox{\tt recognize-bis}}
\newcommand{\prem}{\mbox{\tt prime}}
\renewcommand{\wedge}{\,|\,}



\begin{document}

\title{{\bf Fast Rendezvous with Advice}}
\date{}

\author{
Avery Miller,
Andrzej Pelc\thanks{Partially supported by NSERC discovery grant and by the Research Chair in Distributed Computing at the Universit\'e du Qu\'{e}bec en Outaouais.}\\
E-mails: \email{avery@averymiller.ca}, \email{pelc@uqo.ca}\\
}
\institute{Universit\'{e} du Qu\'{e}bec en Outaouais, Gatineau, Canada.}


\date{ }
\maketitle

\begin{abstract}

Two mobile agents (robots), starting from different nodes of an -node network at possibly different times, have to meet at the same node.
This problem is known as {\em rendezvous}.
Agents move in synchronous rounds using a deterministic algorithm.
In each round, an agent decides to either remain
idle or to move to one of the adjacent nodes. 
Each agent has a distinct integer label from the set , which it can
use in the execution of the algorithm, but it does not know the label of the other agent. 

The main efficiency measure of a rendezvous algorithm's performance is its {\em time} , i.e., the number of rounds from the start of the later agent until the meeting.
If  is the distance between the initial positions of the agents, then  is an obvious lower bound on the time of rendezvous. However, if each agent has no initial  knowledge other than its label,
 time  is usually impossible to achieve. We study the minimum amount of information that has to be available  {\em a priori} to the agents to achieve rendezvous in optimal time .
Following the standard paradigm of {\em algorithms
with advice}, this information is provided to the agents at the start by an oracle knowing the entire instance of the problem, i.e., the network, the starting  positions of the agents, their wake-up rounds,  and both of their labels. The oracle
helps the agents by providing them with the {\em same} binary string called {\em advice}, which can be used by the agents during their navigation. The length of this
string is called the {\em size of advice}.  Our goal is to find the smallest size of advice which enables the agents to meet in time . We show that this optimal size of advice is . 
The upper bound is proved by constructing an advice string of this size, and providing a natural rendezvous algorithm using this advice that works in time 
for all networks.
The matching lower bound, which is the main contribution of this paper, is proved by exhibiting classes of networks for which it is impossible to achieve
rendezvous in time 
with smaller advice. 


\vspace{2ex}

\noindent {\bf Keywords:} rendezvous, advice, deterministic distributed algorithm, mobile agent, time. 
\end{abstract}

\vspace{2ex}


\vfill

\thispagestyle{empty}
\pagebreak


\section{Introduction}


\subsection{Background}

Two mobile agents, starting from different nodes of a network, have to meet at the same node at the same time.
This distributed task is known as {\em rendezvous} and has received a lot of attention in the literature.
Agents can be any mobile autonomous entities. They might represent human-made objects, such as software agents in computer networks or mobile robots navigating in a network of corridors in a building or a mine. They might also be natural, such as animals seeking a mate,
or people who want to meet in an unknown city whose streets form a network. 
The purpose of meeting in the case of software agents or mobile robots might be the exchange of data previously collected by the agents
or samples collected by the robots. It may also be the coordination
of future network maintenance tasks, for example checking functionality of websites or of sensors forming a network, or decontaminating corridors of a mine.

\subsection{Model and Problem Description}

The network is modeled as an undirected connected graph with  unlabeled nodes.
We seek deterministic rendezvous algorithms that do not
rely on the agents perceiving node identifiers, and therefore can work in anonymous graphs as well  (cf. \cite{alpern02b}). 
The reason for designing such algorithms
is that, even when nodes of the network have distinct identifiers, agents may be unable to perceive them
because of limited sensory capabilities (e.g., a mobile robot may be unable to read signs at corridor crossings), 
or nodes may be unwilling to reveal their identifiers to software agents, e.g., due to security or privacy reasons.
From a methodological point of view, if nodes had distinct identifiers visible to the agents, the agents could explore the graph and meet at the node
with the smallest identifier. Hence, in this case, rendezvous
reduces to graph exploration.

On the other hand, we assume that, at each node ,
each edge incident to  has a distinct {\em port number} from the set 
, where  is the degree of . These port numbers are fixed and visible to the agents.
Port numbering is {\em local} to each node, i.e., we do not assume any relation between
port numbers at  the two endpoints of an edge. Note that in the absence of port numbers, edges incident to a node
would be undistinguishable for agents and thus rendezvous would be often impossible, 
as an agent may always miss some particular edge incident to the current node, and this edge could be a bridge to the part of the graph
where the other agent started.
The previously mentioned security and privacy reasons for not revealing node identifiers to software agents are irrelevant in the case of port numbers. If
the graph models a system of corridors of a mine or a building, 
port numbers can be made implicit, e.g., by marking one edge at each intersection
(using a simple mark legible even by a mobile robot with very limited vision),
considering it as corresponding to port 0, and all other port numbers increasing clockwise.
 

Agents are initially located at different nodes of the graph and  traverse its edges in synchronous rounds.
They cannot mark visited nodes or traversed edges in any way, and they cannot communicate before meeting.
The adversary wakes up each of the agents, possibly in different rounds. 
Each agent starts executing the algorithm in the round of its wake-up.
It has a clock that ticks at each round and starts at the wake-up round of the agent.
In each round, each agent either remains at the current node,
or chooses a port in order to move to one of the adjacent nodes. 
When an agent enters a node, it learns the node's degree and the port  number by which it enters the node. When agents cross each other
on an edge while traversing it simultaneously in different directions, they do not notice this fact.

Each agent has a distinct integer label from a fixed {\em label space} , which it can
use as a parameter in the same deterministic algorithm that both agents execute. It does not know the label nor the starting round of the other agent. 
Since we study deterministic rendezvous, the absence of distinct labels would preclude the possibility of meeting in highly
symmetric graphs, such as rings or tori, for which there exist non-trivial port-preserving automorphisms. Indeed, in such graphs,
identical agents starting simultaneously and executing the same deterministic algorithm can never meet, since they will keep the same positive distance in every round. 
Hence, assigning different labels to agents is the only way to break symmetry, as is needed to meet in every graph using a deterministic algorithm. 
On the other hand, if agents knew
each other's identities, then the smaller-labelled agent could stay inert, while the other agent would try to find it. In this case rendezvous reduces to graph exploration.   
Assuming such knowledge, however, is not realistic, as agents are often created independently in different parts of the graph, and they know nothing about each other
prior to meeting.



The rendezvous is defined as both agents being at the same node in the same round.
The main efficiency measure of a rendezvous algorithm's performance is its {\em time} , i.e., the number of rounds from the start of the later agent until the meeting.
If  is the distance between the initial positions of the agents, then  is an obvious lower bound on the time of rendezvous. However, if the agents have no additional knowledge,
time  is usually impossible to achieve. This is due to two reasons. First, without any knowledge about the graph, even the easier task of {\em treasure hunt} \cite{TSZ07}, in
which a single agent must find a target (treasure) hidden at an unknown node of the graph, takes asymptotically larger time  in the worst case. Treasure hunt is equivalent to a special case of rendezvous  where one of the agents is inert. In the worst case, this takes as much time as graph exploration, i.e., having a single agent visit all nodes.
Second, even when the graph is so simple that navigation of the agents is not a problem, breaking symmetry between the agents, which is often necessary to achieve a meeting, may take time larger than .
Indeed, even in the two-node graph, where , rendezvous requires time  \cite{DFKP}. 

We study the amount of information that has to be given  {\em a priori} to the agents to achieve rendezvous in optimal time .
Following the paradigm of {\em algorithms
with advice}  \cite{AKM01,CFP,CFIKP,DP,EFKR,FGIP,FIP1,FIP2,FKL,FP,FPR,GPPR02,IKP,KKKP02,KKP05,SN,TZ05}, this information is provided to the agents at the start, by an oracle knowing the entire instance of the problem, i.e., the graph, the starting  positions of the agents, their wake-up rounds, and both of their labels. The oracle
helps the agents by providing them with the {\em same} binary string called {\em advice}, which can be used by each agent, together with its own label, during the execution of the algorithm. The length of this
string is called the {\em size of advice}.  Our goal is to find the smallest size of advice (up to constant factors) which enables the agents to meet in time .
In other words we want to answer the question:

\begin{quotation}
What is the minimum information that permits the fastest possible rendezvous?
\end{quotation}

where both ``minimum'' and ``fastest'' are meant up to multiplicative constants. 

Notice that, since the advice given to both agents is identical, it could not help break symmetry if agents did not have distinct labels.
Hence, even with large advice, the absence of distinct labels would preclude rendezvous in highly symmetric networks, as argued above.
Using the framework of advice permits us to quantify the amount of information
needed for an efficient solution of a given network problem (in our case, rendezvous), regardless of the type of information that is provided. 

 







\subsection{Our Results}
\label{subsec:ourresults}

For agents with labels from the set ,
we show that, in order to meet in optimal time  in -node networks, the minimum size of advice that has to be provided to the agents is  . 
The upper bound is proved by constructing an advice string of this size, and providing a natural rendezvous algorithm using this advice that works in time 
for all networks.
The matching lower bound, which is the main contribution of this paper, is proved by exhibiting classes of networks for which it is impossible to achieve rendezvous in time 
with smaller advice. 

Our algorithm works for arbitrary starting times of the agents, and our lower bound is valid even for simultaneous start.
As far as the memory of the agents is concerned, our algorithm has very modest requirements: an agent must only be able to store the advice and its own label. Hence
memory of size  is sufficient. On the other hand, our lower bound on the size of advice holds even for agents with unlimited memory.













\subsection{Related Work}
\label{subsec:relatwork}








The problem of rendezvous has been studied both under randomized and deterministic scenarios.
An extensive survey of  randomized rendezvous in various models  can be found in
\cite{alpern02b}, cf. also  \cite{alpern95a,alpern02a,anderson90,baston98}. 
Deterministic rendezvous in networks has been surveyed in \cite{Pe}.
Several authors
considered geometric scenarios (rendezvous in an interval of the real line, e.g.,  \cite{baston98,baston01},
or in the plane, e.g., \cite{anderson98a,anderson98b}).
Gathering more than two agents was studied, e.g., in \cite{fpsw,lim96,thomas92}. 
 

For the deterministic setting, many authors studied the feasibility and time complexity of rendezvous. For instance, deterministic rendezvous of agents that are equipped with tokens used to mark nodes was considered, e.g., in~\cite{KKSS}. Most relevant to our work are the results about 
deterministic rendezvous in arbitrary graphs, when the two agents cannot mark nodes, but have unique labels  \cite{DFKP,KM,TSZ07}.
In \cite{DFKP}, the authors present a rendezvous algorithm whose running time is polynomial in the size of the graph, in the length of the shorter
label and in the delay between the starting times of the agents. In \cite{KM,TSZ07}, rendezvous time is polynomial in the first two of these parameters and independent of the delay.

Memory required by the agents to achieve deterministic rendezvous was studied in \cite{FP2} for trees and in  \cite{CKP} for general graphs.
Memory needed for randomized rendezvous in the ring is discussed, e.g., in~\cite{KKPM08}. 

Apart from the synchronous model used in this paper, several authors investigated asynchronous rendezvous in the plane \cite{CFPS,fpsw} and in network environments
\cite{BCGIL,CLP,DGKKP,DPV}.
In the latter scenario, the agent chooses the edge to traverse, but the adversary controls the speed of the agent. Under this assumption, rendezvous
at a node cannot be guaranteed even in very simple graphs. Hence the rendezvous requirement is relaxed to permit the agents to meet inside an edge.

Providing nodes or agents with arbitrary kinds of information that can be used to perform network tasks more efficiently has been
proposed in \cite{AKM01,CFP,CFIKP,DP,EFKR,FGIP,FIP1,FIP2,FKL,FP,FPR,GPPR02,IKP,KKKP02,KKP05,SN,TZ05}. This approach was referred to as
{\em algorithms with advice}.  
Advice is given either to nodes of the network or to mobile agents performing some network task.
In the first case, instead of advice, the term {\em informative labeling schemes} is sometimes used.
Several authors studied the minimum size of advice required to solve
network problems in an efficient way. 



 In \cite{KKP05}, given a distributed representation of a solution for a problem,
the authors investigated the number of bits of communication needed to verify the legality of the represented solution.
In \cite{FIP1} the authors compared the minimum size of advice required to
solve two information dissemination problems using a linear number of messages. 
In \cite{FKL} it was shown that advice of constant size given to the nodes enables the distributed construction of a minimum
spanning tree in logarithmic time. 
In \cite{EFKR} the advice paradigm was used for online problems.
In \cite{FGIP} the authors established lower bounds on the size of advice 
needed to beat time 
for 3-coloring cycles and to achieve time  for 3-coloring unoriented trees.  
In the case of \cite{SN} the issue was not efficiency but feasibility: it
was shown that  is the minimum size of advice
required to perform monotone connected graph clearing.
In \cite{IKP} the authors studied radio networks for
which it is possible to perform centralized broadcasting in constant time. They proved that constant time is achievable with
 bits of advice in such networks, while
 bits are not enough. In \cite{FPR} the authors studied the problem of topology recognition with advice given to nodes. 
In \cite{DP} the task of drawing an isomorphic map was executed by an agent in a graph and the problem was to determine the minimum advice that has to be given to the agent
for the task to be feasible.

Among the papers using the paradigm of advice, \cite{CFIKP,FIP2} are closest to the present work, as they both concern the task of graph exploration by an agent.
In \cite{CFIKP} the authors investigated the minimum size of advice that has to be given to unlabeled nodes (and not to the agent)
to permit graph exploration by an agent modeled as a -state automaton.
In \cite{FIP2} the authors
established the size of advice that has to be given to an agent in order to explore trees while obtaining 
competitive ratio better than 2.
To the best of our knowledge, rendezvous with advice has never been studied before.



\section{Algorithm and Advice}

Consider any  node graph, and suppose that the distance between the initial positions of the agents is  .
In this section, we construct an advice string of length  and a rendezvous algorithm which achieves time  using this advice.
We first describe the advice string. Let  be the underlying graph and let  and  be the distinct labels of the agents, both belonging to the  label space . Call the agent with label  the first agent and the agent with label  the second agent.
Let  be the smallest index such that the binary representations of  and  differ on the th bit. Without loss of generality assume that the th bit is 0
in the binary representation of   and 1 in the  binary representation of .

Let  be a fixed shortest path in  between the initial positions  and  of the agents.
The path  induces two sequences of ports of length : the sequence  of consecutive ports to
be taken at each node of path  to get from  to , and the sequence  of consecutive ports to
be taken at each node of path  to get from  to . Let  be the sequence 
corresponding to the direction from the initial position of the second agent to the initial position of the first agent.
Denote . Let , for , be the binary representation of the integer . Additionally,
let  be the binary representation of the integer . The binary strings   will be called substrings.
 
The sequence of substrings  is encoded into a single advice string to pass to the algorithm. More specifically, the sequence is encoded by doubling each digit in each substring and putting 01 between substrings. This permits the agent to unambiguously decode the original sequence. Denote by  this encoding and let  be the inverse (decoding) function, i.e., .
As an example, . Note that the encoding increases the total number of advice bits by a constant factor. The advice string 
given to the agents is .



The idea of the Algorithm {\tt Fast Rendezvous} using the advice string   is the following. Each agent decodes the sequence  from the string
. Then each agent looks at the th bit of its label, where  is the integer represented by . If this bit is 0, the agent stays inert at its initial position, otherwise it takes the 
consecutive ports , where , for , is the integer with binary representation . After these  moves, the agent meets the other agent
at the latter's initial position. Below is the pseudocode of the algorithm.

\begin{center}
\fbox{
\begin{minipage}{0.8\columnwidth}\small

{\bf Algorithm} {\tt Fast Rendezvous}\\

Input: advice string , label .\\

\\
 the integer with binary representation .\\
{\bf if} the th bit of  is 1 {\bf then}\\
\hspace*{1cm}{\bf for}  {\bf to}  {\bf  do}\\
\hspace*{2cm} the integer with binary representation \\
\hspace*{2cm}take port \\
stop.

\end{minipage}
}
\end{center}

\begin{theorem}\label{ub}
Let  be an -node graph with two agents initially situated at distance  from one another.
Algorithm {\tt Fast Rendezvous} achieves rendezvous in time , using advice of size
 .
\end{theorem}

\begin{proof}
The correctness and time of the algorithm are straightforward. It remains to prove that the
 length of the advice string  is . To do this, it is enough to show that the sum of the lengths  of substrings , for ,
 is . 
 
 Note that . 
 Also, note that
 , where  are consecutive nodes on some shortest path between the initial positions of the agents.
 It is well-known (cf. e.g.,  \cite{FP1}) that the sum of degrees on a shortest path between any two nodes in an -node graph is bounded above
 by . Hence . We have 
 
 The product of  positive numbers whose sum is at most  is maximized when they are all equal to .
 Hence . This concludes the proof.
\end{proof}









\section{Lower Bound}

In this section, we prove a lower bound on the size of advice permitting rendezvous in optimal time , where  is the initial distance between the agents. This lower bound will match the upper bound established in
Theorem \ref{ub}, which says that, for an arbitrary -node graph, rendezvous can be achieved in time  using advice of size
 . In order to prove that this size of advice cannot be improved in general, we present two classes of graphs: one that requires
 advice  and another that requires advice  to achieve optimal time of rendezvous. To make the lower bound even stronger, we show that it holds even in the scenario where agents start simultaneously. 
 
 The   lower bound will be first proved for the simpler problem of treasure hunt. Recall that in this task,
 a single agent must find a stationary target (treasure) hidden at an unknown node of the graph at distance  from the initial position of the agent. 
We then show how to derive the same lower bound on the size of advice for the rendezvous problem.
 
 The following technical lemma gives a construction of a graph which will provide the core of our argument for the  lower bound.


\begin{lemma}\label{lowerboundgraph}
Let  and  be positive integers such that .
Consider any treasure-hunting algorithm  that takes  bits of advice. For any fixed even integer  and every integer , there exists a graph of size , an initial position of the agent in this graph,  and a location of the treasure at distance  from this initial position, for which algorithm  uses  rounds.
\end{lemma}
\begin{proof}
We define a class of graphs  such that each graph in  has  nodes. We will prove that there is a non-empty subset  of  such that, on each graph in , algorithm  uses  rounds to complete treasure hunt, for some initial position of the agent and a location of the 
treasure at distance  from this location. 

Each graph  in the class consists of  copies of a -clique  
(with a port numbering to be described shortly), which are chained together in a special way. We will refer to these cliques as . 

Let  denote the nodes of . It should be stressed that names of nodes in cliques are for the convenience of the description only, and they are not visible to the agent. 
We choose an arbitrary edge-colouring of  using the colours , which is always possible for cliques of even size, cf. e.g., \cite{Gib}, Theorem 7.6. For an arbitrary edge  in , let  denote the colour assigned to . The port numbers of  are simply the edge colours, i.e., for any edge , the port numbers corresponding to this edge at  and  are both equal to . 

Each graph  is obtained by chaining together the copies  of the clique  in the following way. We will call node  in clique  the \emph{gate}  of . The initial position of the agent is . Each gate , for , is placed on (i.e., subdivides) one of the edges of clique  not incident to . We denote this edge by . Finally, an additional \emph{treasure node}  is placed on  (i.e., subdivides) one of the edges of clique  not incident to , and this edge is denoted by .
Hence  has degree , each , for , has degree , and  has degree 2, cf. Figure 1 (a).
Note that, since , for , subdivides an edge that is not incident to , we have .  
Port numbering of graph  is the following. Port numbers in each clique  are
unchanged, the new port numbers at each node , for , are  and , with  corresponding to the edge whose other endpoint has smaller index,
and the new port numbers at node  are  and , with  corresponding to the edge whose other endpoint has smaller index,
cf. Figure 1 (b).
All graphs in the class  are isomorphic and differ only by port numbering. 
Note that each graph in  is uniquely identified by the sequence of edges . Therefore, the number of graphs in  is 
.


\begin{figure}[!ht]
\begin{center}
\includegraphics[scale=0.6]{diagram}
\end{center}
\caption{(a) A graph in  (b) Port numbering of each clique , for , with gate  inserted }
\label{GraphDiagrams}
\end{figure}


Notice that an agent navigating in a graph   always knows when it arrives at a gate , for , because these are the only nodes of degree
. Call a walk of an agent {\em normal}, if the agent visits each gate , for , exactly once (i.e., never exits a gate by port  or ).
It is enough to prove our lower bound on the time of treasure hunt only for algorithms where the agent always performs a normal walk. Indeed,  for any walk, there exists a normal walk using at most the same time. From now on we restrict attention to such algorithms.


  


We prove our lower bound on the class of graphs . The idea is that, in order to find the treasure node, the agent must visit each of the nodes . To get from  to , the agent must find the edge  of  that the node  subdivides. With little advice, this amounts to searching many edges of the clique , and hence increases time.

For any graph , the agent is given some advice string  and executes its treasure-hunting algorithm . 
With  bits of advice, there exists a set  of at least  graphs for which the agent is given the same advice string. Next, we provide an upper bound on the number of graphs in .  By comparing this upper bound with , we will get the desired lower bound on the number of rounds needed to find the treasure.


Let  be the maximum running time of algorithm  on  graphs of class . 
Let  be the function that maps each graph from  to an -tuple , where, for each ,  is the number of edge traversals performed by the agent in clique . This function is well-defined since we consider only deterministic algorithms. We now prove that this function is injective.

\begin{claim}\label{injective}
For any two graphs  in the set , we have .
\end{claim}
\begin{proof}
Let  and  be represented by the  distinct sequences of edges  and , respectively.
Let  be the first index for which . Since the advice string for graphs  and  is the same, the sequence of ports taken by the agent in these graphs
is the same until the agent reaches nodes of different degree in  and . Let   and  .
Hence  for . Without loss of generality assume that . For each round , the agent  takes the same port number in  and . In round  the agent reaches the gate  in . Since , the agent does not reach the gate   in  in this round. Since the walk of the agent is normal, we conclude that
.  
\end{proof}

By Claim \ref{injective}, the number of graphs in  is bounded above by the size of the range of . Consider an arbitrary -tuple  in the range of . By the definition of , for each , the agent must traverse at least two edges to get from  to . Further,  is an upper bound on the number of edge traversals performed in any execution of the algorithm. Therefore, the size of the range of  is bounded above by the number of integer-valued -tuples with positive terms whose sum is at most .  Clearly, this is bounded above by the number of real-valued -tuples with non-negative terms whose sum is at most , i.e., by the size of the simplex i. From \cite{ellis}, the volume of  is equal to . Thus, we have shown that the  size of  is bounded above by . Comparing this to our lower bound  on the size of , we get


By Stirling's formula we have , for sufficiently large . Hence .
Since the first factor converges to 1 as  grows, we have . Hence the above bound on  implies .
\end{proof}

\begin{theorem}\label{lb1}
Let  and  be positive integers such that .
 If an algorithm   solves treasure hunting in  rounds whenever the treasure is at distance  from the initial position of the agent, 
 then there exists an -node graph  with treasure at this distance such that  requires  bits of advice.
\end{theorem}
\begin{proof}
We suppose that only  bits of advice are provided, and show that there is an -node graph for which  completes treasure hunt in  rounds.

{\bf Case 1.} .\\
The amount of advice provided is , where . By Lemma \ref{lowerboundgraph} with  or , whichever number is even, and , there exists a graph  such that, for some positive constant , algorithm  uses at least  rounds to reach the treasure located at some node  at distance 
from the initial position of the agent. 

{\bf Case 2.} .\\
Since  is constant and  bits of advice are provided, it follows that
the amount of advice provided is , where  for some integer function  such that . By Lemma \ref{lowerboundgraph} with  or , whichever number is even, and , there exists a graph  such that, for some positive constant , algorithm  uses at least  rounds to reach the treasure located at some node  at distance 
from the initial position of the agent. 


In both cases, graph  has  nodes and the treasure is located at distance  from the initial position of the agent.
We obtain a graph  with  nodes by attaching a path of  nodes  to node  in . In this graph  the initial position of the agent is unchanged
with respect to , and 
the treasure is located on the attached path at distance  from this initial position. 
\end{proof}

We now show how to deduce a lower bound on the size of advice for rendezvous (even with simultaneous start) from the lower bound for treasure hunt.

\begin{corollary}\label{cor}
Let  be positive integers. 
There exist  and  such that 
if an algorithm  solves rendezvous in time  in -node graphs
whenever the initial distance between the agents is , then there exists an -node graph for which  requires
 bits of advice.
\end{corollary}

\begin{proof}
Let  be a -node graph with a treasure located at distance  from the initial position of the agent
such that an -time treasure hunting algorithm requires  bits of advice. Such a graph exists by
Theorem \ref{lb1}. Let  be the initial position of the agent and let  be the location of the treasure in graph . 

Let  and . Hence  and .
Construct the graph  which consists of two disjoint copies of  with the treasure locations joined by an edge. Locate two agents in , each at the node  in different copies of .
The graph  has  nodes and the initial distance between the agents is . In order to accomplish rendezvous in time , at least one of the agents has to
traverse the edge joining the copies, hence it must find the node  in its copy in time ,  which requires advice of size .
\end{proof}



The second part of our lower bound on the size of advice, i.e., the lower bound , will be proved on the class of oriented rings.
A ring is {\em oriented} if every edge has port labels 0 and 1 at the two end-points.
Such a port labeling induces orientation of the ring: at each node, we will say that taking port 0 is going clockwise and taking port 1 is going counterclockwise.
We assume that agents operate in an oriented ring of size . In order to make the lower bound as strong as possible, we prove that it holds even for simultaneous start of the agents. 

\begin{theorem}\label{lb2}
Let  be positive integers. Consider any algorithm  that solves rendezvous for agents with labels from the set . 
There exist  and  such that if  uses time   in the -node oriented ring whenever the initial distance between the agents is , then the required size of advice is
.
\end{theorem}

\begin{proof}
Assume that  is the advice string given to the agents. Consider an agent with 
label  executing algorithm  using advice . The actions of the agent in consecutive rounds until rendezvous are specified by  
a \emph{behaviour vector} . In particular,  is a sequence with terms from  that specifies, for each round , whether agent   moves clockwise (denoted by ), remains idle (denoted by ), or moves counter-clockwise (denoted by ). Note that an agent's behaviour vector is independent of its starting position, since all nodes of the ring look the same to the agent.  This behaviour vector depends exclusively on the label of the agent and on the advice string .

Let ,  and . Hence , ,  divides , and . 
As the initial positions of the agents,
fix any nodes  and  of the -node oriented ring, where  is at clockwise distance  from . Since ,
agents are at distance  in the ring. 
Partition the nodes of the ring into  consecutive blocks  of size , starting clockwise from node .
Hence the initial positions  and  of the agents are the clockwise-first nodes of block  and block , respectively.
Since agents start simultaneously, we have the notion of global round numbers counted since their start.
Partition all rounds  into consecutive {\em time segments} of length . Hence, during any time segment, an agent can be
located in at most two (neighbouring) blocks.

Fix a behaviour vector  of an agent with label .
We define its {\em meta-behaviour vector} as a sequence   with terms from  as follows. 
Suppose that the agent is in block  in the first round of the -th segment.
The -th term of  is , if, in the first round of the -th time segment, the agent is in the block , where index addition is modulo . 
Since the initial position of an agent  is the clockwise-first node of a block, for a fixed behaviour vector of an agent its meta-behaviour vector is well defined.

Suppose that algorithm  takes at most  rounds, for some constant . This corresponds to  time segments for some constant . Hence,
all meta-behaviour vectors describing the actions of agents before the meeting are of length  (shorter meta-behaviour vectors can be padded by zeroes at the end.) Let  be the set of sequences of length  with 
terms from . Sequences from  represent possible meta-behaviour vectors of the agents. The size of  is . 

Since the initial positions of the agents are in blocks that are separated by two other blocks, agents with the same
meta-behaviour vectors must be in different blocks in every round, and hence they can never meet. Indeed, in the first round of every time segment they must be in blocks separated by two other blocks, and during any time segment, an agent can either stay in the same block or get to an adjacent block.

Suppose that the number of bits of advice is at most
. It follows that the set  of advice strings is of size at most . For any label , let 
 be the function from  to , whose value on an advice string  is the meta-behaviour vector of the agent with label  when given the advice string . Functions  are well-defined, as the meta-behaviour vector of an agent whose initial position is the clockwise-first node of a block depends only on its behaviour vector, which in turn depends only on the label of the agent and on the advice string.

 If the set  of all functions from  to  had fewer elements than , then there would exist two distinct labels  and  of agents
 such that, for any advice string , these agents would have an identical meta-behaviour vector. As observed above, these agents could never meet. This implies
 . Hence , which contradicts the fact that  is a constant.
 
 This shows that the number of bits of advice must be larger than .
\end{proof}

Corollary \ref{cor} and  Theorem \ref{lb2} imply:

\begin{theorem}\label{lb}
Let  be positive integers.
Consider any algorithm  that solves rendezvous for agents with labels from the set . 
There exist  and  such that, if  takes time  in all -node graphs
whenever the initial distance between the agents is , then the required size of advice is
.
\end{theorem}

Theorems \ref{ub} and \ref{lb} imply the following corollary which is the main result of this paper.

\begin{corollary}
The minimum number of bits of advice sufficient to accomplish rendezvous of agents with labels from the set  in all -node graphs in time , whenever the initial distance between the agents is , is .
\end{corollary} 





\section{Conclusion}

We established that   is the minimum amount of information (advice) that agents must have in order to meet in optimal time , where  is the initial distance between them.
It should be noted that the two summands in this optimal size of advice have very different roles. 
On one hand,  bits of advice are necessary and sufficient
to accomplish, in  time, the easier task of treasure hunt in -node networks, where a single agent must find a target (treasure) hidden at an unknown node of the network
at distance  from its initial position. This task is equivalent to a special case of rendezvous where one of the agents is inert. On the other hand, for agents whose labels are drawn from a label space of size ,
 bits of advice are needed to break symmetry quickly enough 
in order to solve rendezvous in time ,  
and hence, are necessary to meet in optimal time ,  even in constant-size networks.
 It should be stressed that the first summand in  is usually larger than the second. Indeed, only when  is very large with respect to  and  does the second summand dominate. This means that  ``in most cases'' the easier task of solving treasure hunt in optimal time is as demanding,
 in terms of advice,  as the harder task of solving rendezvous in optimal time.
 
 In this paper, we assumed that the advice given to both agents is identical. How does the result change when each agent can get different advice? It is clear that
 giving only one bit of advice, 0 to one agent and 1 to the other, breaks symmetry between them, e.g., the algorithm can make the agent that received bit 0 stay inert. Thus, if advice can be different,
 one bit of advice reduces rendezvous to treasure hunt. The opposite reduction is straightforward. 
 Hence it follows from our results that  bits of advice are necessary and sufficient
 to accomplish rendezvous in optimal time  in -node networks, if advice can be different. This holds regardless of the label space and is, in fact, 
 also true for anonymous (identical) agents.
 

 






\bibliographystyle{plain}
\begin{thebibliography}{12}


\bibitem{AKM01}
S.~Abiteboul, H.~Kaplan, T.~Milo, Compact labeling schemes for ancestor
queries, Proc. 12th Annual ACM-SIAM Symposium on Discrete
Algorithms (SODA 2001), 547--556.

\bibitem{alpern95a}
S. Alpern,
The rendezvous search problem,
SIAM J. on Control and Optimization 33 (1995), 673-683.


\bibitem{alpern02a}
S. Alpern,
Rendezvous search on labelled networks,
Naval Reaserch Logistics 49 (2002), 256-274.

\bibitem{alpern02b}
S. Alpern and S. Gal,
The theory of search games and rendezvous.
Int. Series in Operations research and Management Science,
Kluwer Academic Publisher, 2002.




\bibitem{anderson90}
E. Anderson and R. Weber,
The rendezvous problem on discrete locations,
Journal of Applied Probability 28 (1990), 839-851.

\bibitem{anderson98a}
E. Anderson and S. Fekete,
Asymmetric rendezvous on the plane,
Proc. 14th Annual ACM Symp. on Computational Geometry (1998), 365-373.

\bibitem{anderson98b}
E. Anderson and S. Fekete,
Two-dimensional rendezvous search,
Operations Research 49 (2001), 107-118.


\bibitem{BCGIL}
E. Bampas, J. Czyzowicz, L. Gasieniec, D. Ilcinkas, A. Labourel, Almost optimal asynchronous rendezvous in infinite multidimensional grids,
Proc. 24th International Symposium on Distributed Computing (DISC 2010),  297-311.


\bibitem{baston98}
V. Baston and S. Gal,
Rendezvous on the line when the players' initial distance is
given by an unknown probability distribution,
SIAM J. on Control and Opt. 36 (1998), 1880-1889.

\bibitem{baston01}
V. Baston and S. Gal,
Rendezvous search when marks are left at the starting
points,
Naval Reaserch Logistics 48 (2001), 722-731.

\bibitem{CFP}
S. Caminiti, I. Finocchi, R. Petreschi,
Engineering tree labeling schemes: a case study on least common ancestor,
Proc. 16th Annual European Symposium on Algorithms (ESA 2008), 234--245.



\bibitem{CFPS}
M. Cieliebak, P. Flocchini, G. Prencipe, N. Santoro, 
Distributed computing by mobile robots: Gathering, SIAM J. Comput. 41 (2012), 829-879.

\bibitem{CFIKP}
R. Cohen, P. Fraigniaud, D. Ilcinkas, A. Korman, D. Peleg, 
Label-guided graph exploration by a finite automaton, 
ACM Transactions on Algorithms 4 (2008).



\bibitem{CKP}
J. Czyzowicz, A. Kosowski, A. Pelc, How to meet when you forget: Log-space rendezvous in arbitrary graphs, Distributed Computing 25 (2012), 165-178. 

\bibitem{CLP}
J. Czyzowicz, A. Labourel, A. Pelc, How to meet asynchronously (almost) everywhere, 
ACM Transactions on Algorithms 8 (2012), article 37. 





\bibitem{DGKKP}
G. De Marco, L. Gargano, E. Kranakis, D. Krizanc, A. Pelc, U. Vaccaro, 
Asynchronous deterministic rendezvous in graphs, 
Theoretical Computer Science 355 (2006), 315-326.

\bibitem{DP}
D. Dereniowski, A. Pelc, Drawing maps with advice,  Journal of Parallel and Distributed Computing 72 (2012), 132--143. 



\bibitem{DFKP}
A. Dessmark, P. Fraigniaud, D. Kowalski, A. Pelc.
Deterministic rendezvous in graphs.
Algorithmica 46 (2006), 69-96.


\bibitem{DPV}
Y. Dieudonn\'{e}, A. Pelc, V. Villain, How to meet asynchronously at polynomial cost, Proc. 32nd Annual ACM Symposium on Principles of Distributed Computing (PODC 2013), 92-99.

\bibitem{ellis}
R. Ellis,
Volume of an N-Simplex by Multiple Integration, 
Elemente der Mathematik 31 (1976), 57-59.

\bibitem{EFKR}
Y. Emek, P. Fraigniaud, A. Korman, A. Rosen, Online computation with advice, Theoretical Computer Science 412 (2011), 2642--2656.




\bibitem{fpsw}
P. Flocchini, G. Prencipe, N. Santoro, P. Widmayer,
Gathering of asynchronous robots with limited visibility, Theoretical Computer Science 337 (2005), 147-168.




\bibitem{FGIP}
P. Fraigniaud, C. Gavoille, D. Ilcinkas, A. Pelc, 
Distributed computing with advice: Information sensitivity of graph coloring, 
Distributed Computing 21 (2009), 395--403.

\bibitem{FIP1}
P. Fraigniaud, D. Ilcinkas, A. Pelc, 
Communication algorithms with advice, Journal of  Computer and System Sciences 76 (2010), 222--232.


\bibitem{FIP2}
P. Fraigniaud, D. Ilcinkas, A. Pelc, 
Tree exploration with advice, Information and Computation 206 (2008), 1276--1287.


\bibitem{FKL}
P. Fraigniaud, A. Korman, E. Lebhar,
Local MST computation with short advice,
Theory of Computing Systems 47 (2010), 920--933.

\bibitem{FP2}
P. Fraigniaud, A. Pelc, Delays induce an exponential memory gap for rendezvous in trees, ACM Transactions on Algorithms 9 (2013), article 17. 




\bibitem{FP}
E. Fusco, A. Pelc, Trade-offs between the size of advice and broadcasting time in trees, Algorithmica 60 (2011), 719--734. 

\bibitem{FP1}
E. Fusco, A. Pelc, Communication complexity of consensus in anonymous message passing systems, Proc. 15th International Conference on Principles of Distributed Systems (OPODIS 2011), 191-206. 

\bibitem{FPR}
E. Fusco, A. Pelc, R. Petreschi, Use knowledge to learn faster: Topology recognition with advice, Proc. 27th International Symposium on Distributed Computing (DISC 2013), 31-45.

\bibitem{GPPR02}
C.~Gavoille, D.~Peleg, S.~P\'{e}rennes, R.~Raz.
Distance labeling in graphs, 
Journal of Algorithms 53 (2004), 85-112.

\bibitem{Gib}
A. Gibbons, Algorithmic Graph Theory, Cambridge University press 1985.






\bibitem{IKP}
D. Ilcinkas, D. Kowalski, A. Pelc, 
Fast radio broadcasting with advice, 
 Theoretical Computer Science, 411 (2012),  1544--1557.

\bibitem{KKKP02}
M.~Katz, N.~Katz, A.~Korman, D.~Peleg, Labeling schemes for flow and
connectivity, 
SIAM Journal of  Computing 34 (2004), 23--40.



\bibitem{KKP05}
A. Korman, S. Kutten, D. Peleg, Proof labeling schemes,
Distributed Computing 22 (2010), 215--233.  




\bibitem{KM}
D. Kowalski, A. Malinowski,
How to meet in anonymous network,
Proc. 13th Int. Colloquium on Structural Information and Communication Complexity,
(SIROCCO 2006), 44-58. 

\bibitem{KKPM08}
E. Kranakis, D. Krizanc, and P. Morin, 
Randomized Rendez-Vous with Limited Memory,
Proc. 8th Latin American Theoretical Informatics (LATIN 2008), 605-616.

\bibitem{KKSS}
E. Kranakis, D. Krizanc, N. Santoro and C. Sawchuk, 
Mobile agent rendezvous in a ring, 
Proc. 23rd Int. Conference on Distributed Computing Systems
(ICDCS 2003), 592-599.

\bibitem{lim96}
W. Lim and S. Alpern,
Minimax rendezvous on the line,
SIAM J. on Control and Optimization 34 (1996), 1650-1665.



\bibitem{SN}
N. Nisse, D. Soguet, Graph searching with advice,
Theoretical Computer Science 410 (2009), 1307--1318.



\bibitem{Pe}
A. Pelc, Deterministic rendezvous in networks: A comprehensive survey, 
Networks 59 (2012), 331-347. 




\bibitem{TSZ07}
A. Ta-Shma and U. Zwick.
Deterministic rendezvous, treasure hunts and strongly universal exploration sequences.
Proc. 18th ACM-SIAM Symposium on Discrete Algorithms (SODA 2007), 599-608.

\bibitem{thomas92}
L. Thomas,
Finding your kids when they are lost,
Journal on Operational Res. Soc. 43 (1992), 637-639.

\bibitem{TZ05}
M.~Thorup, U.~Zwick, Approximate distance oracles,
Journal of the ACM, 52 (2005), 1--24.







\end{thebibliography}


\end{document}
