\documentclass{article}
\usepackage{a4wide}
\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{amsmath}
\usepackage{amssymb}

\newcommand{\dist}          {d}
\newcommand{\vit}          {\mathrm{vit}}
\newcommand{\shval}          {\mathrm{shval}}
\newcommand{\shratio}          {\mathrm{shratio}}
\newcommand{\frag}          {\mathrm{frag}}
\newcommand{\girth}          {\mathrm{girth}}
\newcommand{\tail}          {\mathrm{tail}}
\newcommand{\head}          {\mathrm{head}}
\newcommand{\mincycle}          {\mathrm{mincycle}}
\newcommand{\apex}          {\mathrm{apex}}
\newcommand{\best}          {\mathrm{best}}
\newcommand{\degree}          {\mathrm{deg}}

\DeclareMathOperator*{\polylog}{polylog}
\newtheorem{theorem}{Theorem}
\newtheorem{property}{Property}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{remark}[theorem]{Remark}
\newcommand{\qed}{\hfill \ensuremath{\Box}}



\newenvironment{proof}{\vspace{1ex}\noindent{\bf Proof.}\hspace{0.5em}}
	{\hfill\qed\vspace{2ex}}

\newcommand{\nota}[1]{\textbf{(*)}\marginpar {\tiny \raggedright{(*) #1}}}
\newcommand{\commento}[1] {}
\newcommand{\floor}[1]       {\left\lfloor #1 \right\rfloor}
\newcommand{\ceil}[1]       {\left\lceil #1 \right\rceil}
\newcommand{\round}[1]       {\left( #1 \right)}
\newcommand{\braces}[1]       {\left\{ #1 \right\}}

\newcommand{\ResilientSpanner}{\texttt{ResilientSpanner}}
\newcommand{\ParsimoniousCycles}{\texttt{ParsimoniousCycles}}



\newenvironment{mylist}[1]{
\setbox1=\hbox{#1}
\begin{list}{}{
\setlength{\labelwidth}{\wd1}
\setlength{\leftmargin}{\wd1}
\addtolength{\leftmargin}{0em}
\addtolength{\leftmargin}{\labelsep}
\setlength{\rightmargin}{1em}}}{\end{list}}

\newcommand{\litem}[1]{\item[#1\hfill]}
\newcommand{\ritem}[1]{\item[#1]}




\newcounter{progcount}
\newcounter{linecount}[progcount]

\newcommand{\N}{\refstepcounter{linecount}\thelinecount. \>}
\newcommand{\NL}[1]{\refstepcounter{linecount}\thelinecount. \label{#1}\>}
\newcommand{\rem}[1]{\mbox{/* \textit{#1} */}}
\newenvironment{prog}[1]{
    \refstepcounter{progcount}\label{#1}
    \par\vspace{0.5ex}\noindent\hspace{1ex}
    \begin{minipage}{\linewidth}
    \small
    \begin{tabbing}
    =spa\=spa\=spa\=spa\=spa\=spa\=spa\=spa\=spa\=spa\=spa\=spa\=\kill
}{
    \end{tabbing}
    \end{minipage}\\frag_G(e) = \max_{x,y \in V} \left\{ \frac{\dist_{G\setminus e}(x,y)}{\dist_{G}(x,y)}\right\}\frac{\dist_{G \setminus e}(x,y)}{\dist_{G}(x,y)}
\leq
\frac{\dist_G(x, y) - \dist_G(u,v) + \dist_{G\setminus e}(u,v)}{\dist_{G}(x,y)}
\label{eq:1}
\frag_{S_f}(e) = \frac{\dist_{S_f \setminus e}(u,v)}{\dist_{S_f}(u,v)}
\leq
\frac{t \cdot \dist_{G \setminus e}(u,v)}{\dist_{S_f}(u,v)}
=
\frac{t \cdot \dist_{G \setminus e}(u,v)}{\dist_{G}(u,v)}
=
t \cdot \frag_G(e).\frag_R(e) = \frac{\dist_{R \setminus e}(u,v)}{\dist_R(u,v)} \leq t\cdot\frac{\dist_G(u,v)}{\dist_R(u,v)}
		\leq t \leq \sigma \leq \max\{\sigma, \frag_G(e)\}.\frag_R(e) = \frac{\dist_{R \setminus e}(u,v)}{\dist_R(u,v)} \leq t\cdot\frac{\dist_G(u,v)}{\dist_R(u,v)}
		\leq t \leq \sigma \leq \max\{\sigma, \frag_G(e)\}.\frag_R(e) = \frac{\dist_{R \setminus e}(u,v)}{\dist_R(u,v)} \leq \frac{\alpha\cdot\dist_G(u,v)+\beta}{\dist_R(u,v)}
		\leq \alpha  + \frac{\beta}{\dist_R(u,v)}\leq \alpha + \beta \leq \sigma \leq \max\{\sigma, \frag_G(e)\}.\frag_R(e) = \frac{\dist_{R \setminus e}(u,v)}{\dist_R(u,v)} \leq \frac{\dist_{G \setminus e}(u,v)}{\dist_G(u,v)} \leq \frag_G(e) \leq \max\{\sigma, \frag_G(e)\}\ .\frag_R(e) = \frac{\dist_{R \setminus e}(u,v)}{\dist_R(u,v)} \leq \frac{\dist_S(u,v)}{\dist_R(u,v)}
		\leq \frac{\dist_S(u,v)}{\dist_G(u,v)} \leq t \leq \sigma \leq \max\{\sigma, \frag_G(e)\}\ .
\sigma < \frag_G(e) \leq \frag_L(e)\ .
\label{eqn:frag}
\frag_L(e) =  \frac{\dist_{L\setminus e}(u,v)}{\dist_{L}(u,v)}=1\sigma < \frag_G(e) \leq \frag_L(e) =  \frac{\dist_{L\setminus e}(u,v)}{\dist_{L}(u,v)} \leq
\frac{\sum_{i=1}^{\ell-1} w(e_i)}{w(e)}\leq \ell -1\ .\girth(L') > \sigma + 1\ . \left|\bigcup_{i =1}^{q}  \left(E_i^{\mathrm{old}}\cup E_i^{\mathrm{new}}\cup E_i^{\mathrm{cross}}\right)\right| \leq 2  n + O\left(\min \left\{q \sqrt{n}+n, n \sqrt{q}+q\right\}\right)\shval_G(e) = \max_{x,y \in V}\braces{\dist_{G\setminus e}(x,y) - \dist_{G}(x,y)}\ .\shval_G(e) = \dist_{G\setminus e}(u,v) - \dist_{G}(u,v)\ .\frag_{G}(e) = \frac{\shval_G(e)}{\dist_G(u,v)} + 1\ ,1mm]

\vspace{0.3cm}\\
\N  \key{let}\\
\N  \key{for each}vertex  in \\
\N  \>  \key{let} be the set of -fragile edge in  incident to \\
\NL{row:cycle}  \>  \key{for each} edge ,\\
\NL{row:following}  \>  \>  add to  a short cycle  such that\\
\>  \>  \>  the sequence of added cycles is parsimonious\\
\end{prog}

\caption{Algorithm ResilientSpanner.}
\protect\label{fi:algobackup}
\noindent\hrulefill \end{figure}
}

\begin{figure}[ht]
\noindent\hrulefill \begin{prog}{pr:resilientspanner}
\key{Algorithm} ResilientSpanner(, , )\\
\key{input:}\\
\>  graph \\
\>  a -spanner  of \\
\>  a fragility threshold , with \\
\key{output:}\\
\>  a -resilient -spanner  of , with  \1mm]
\N  initialize the priority queue: \\
\N  \key{for each}\\
\N  \>  \key{insert} into  with priority  into \\

\N  \key{while}\\
\N  \>  \key{pop}the best priority vertex  from , let  be its priority\\
\N  \>  \key{if} \rem{ is a -vertex}\\
\N  \>  \>  \key{for each}-neighbor  of  with \\
\N  \>  \>  \>  \\
\N  \>  \>  \> \key{if}\\
\N  \>  \>  \>  \> \\
\N  \>  \>  \>  \key{else}\\
\N  \>  \>  \>  \> \\
\N  \>  \>  \>  \key{if}( does not have ) or  or ( and )\\
\N  \>  \>  \>  \>  ;\ \ \  ;\ \ \  \\
\N  \>  \>  \>  \>  \key{insert} (or decrease its priority if already present with higher priority)  with priority  into \\
\N  \>  \key{else} \rem{ is a -vertex}\\
\N  \>  \>  \key{let}  \rem{we only look for single cross paths}\\
\N  \>  \>  \key{if}\\
\N  \>  \>  \>  \\
\N  \>  \>  \> \key{if}\\
\N  \>  \>  \>  \> \\
\N  \>  \>  \>  \key{else}\\
\N  \>  \>  \>  \> \\
\N  \>  \>  \>  \key{if}( does not have ) or () or ( and )\\
\N  \>  \>  \>  \>  ;\ \ \  ;\ \ \  \\
\N  \>  \>  \>  \>  \key{insert} (or decrease its priority if already present with higher priority) with priority  into \\
\end{prog}

\caption{Algorithm SetParentsForBackupPaths.}
\protect\label{fi:mainalgo}
\noindent\hrulefill \end{figure}

\begin{figure}[ht]
\noindent\hrulefill \begin{prog}{pr:backuppaths}
\key{Algorithm} AddBackupPaths(, , , )\\
\key{input:}\\
\>  graph ,\\
\>  -spanner  of ,\\
\>  vertex \\
\>  the set  of vertices adjacent to  computed by Algorithm~\ref{fi:algobackup},\\
\key{output:}\\
\>  adds a best backup path for each vertex \\
\vspace{0.3cm}\\

\N  \key{for each}neighbor  of  in \\
\N  \>  \\
\N  \>  \key{do} \rem{follow  parents until we get out of subtree }\\
\N  \>  \>  \key{add}edge  to \\
\N  \>  \>  \\
\N  \>  \key{while};\\
\N  \>  \key{do} \rem{follow  parents until we get to root }\\
\N  \>  \>  \key{add}edge  to \\
\N  \>  \>  \\
\N  \>  \key{while};\\
\end{prog}

\caption{Algorithm AddBackupPaths.}
\protect\label{fi:addalgobackup}
\noindent\hrulefill \end{figure}
}


While computing a parsimonious shortest path tree  in  time, in the same bound we can compute and store in each vertex  the following information:
\begin{itemize}
\item : the distance from  to ;
\item : the number of edges from  in the (shortest) path from  to  in ;
\item : the vertex such that  is the first edge in the (shortest) path from  to  in ;
\item : the vertex immediately before  in the (shortest) path from  to  in .
\end{itemize} 

We are now ready to complete the low-level details of Algorithm \ResilientSpanner\ of Figure~\ref{fi:algobackup}
by showing how to implement 
Algorithm  \ParsimoniousCycles, whose pseudo-code is illustrated in Figure~\ref{fi:mainalgo}. We first sketch the main ideas behind the algorithm. We are given the current spanner , a vertex , and the set  of -fragile edges incident to . 
In the following, we denote  
by  a single-cross backup path for .
The objective of Algorithm  \ParsimoniousCycles\ is to  compute  for each vertex  such that .
By Lemma~\ref{le:bestbackup},  must be of the form
, where  denotes the unique path between vertices  and  in , and 
 is an edge in  with   and .
To compute , 
 it thus suffices to identify such an edge  in ,  so that the 
following two properties hold:
\begin{mylist}{(1) }
\litem{(1)} The path  is a shortest path in . Note that the weight of the path  can be  computed in constant time as .
\litem{(2)} Among all shortest paths between  and  in ,  has the smallest number of edges from . Note that the number of edges from  in  can be computed in constant time as  if , and as  otherwise.
\end{mylist}

Having this in mind, Algorithm \ParsimoniousCycles\ works
as follows. It stores in 
  the currently best single-cross backup path computed for each edge , where  is initialized in Lines 2--3 of Figure~\ref{fi:mainalgo}.
 Next, the algorithm
scans all edges  in 
such that , as illustrated in Lines 4--5. Note that  is further checked on Line 5, since by Lemma~\ref{le:bestbackup} when  then the edge  cannot be in a single-cross backup path. Otherwise, the edge  can potentially induce a single-cross backup path  for edge : if  improves the previously known value for , then  gets updated in Line 8. 
At the end of the loop in Lines 4--8, the algorithm has computed  for all edges . On Lines 9--11 it returns the corresponding short cycles.

\commento{
Due to Lemma~\ref{le:bestbackup}, we can find a best backup path for edge , by looking at the ``best possible'' path composed by a path in  from  to some vertex , a path in  from  to a vertex , and edge , with  and , where ``best possible'' means, among all paths having minimum length, the one that contains the minimum number of edges in . Given any two vertices  and , we denote by  the unique path in  between  and .
}



\begin{figure}[ht]
\noindent\hrulefill \begin{prog}{pr:backuppaths}
\key{Algorithm} ParsimoniousCycles(, , , )\\
\key{input:}\\
\>  graph ,\\
\>  -spanner  of ,\\
\>  the root vertex ,\\
\>  the set  of -fragile edges in  incident to \\

\key{output:}\\
\>  a set of short cycles, one for each edge in \\
\1mm]
\N  initialize the priority queue: \\
\N  \key{for each}\\
\N  \>  \key{set}the current backup path \\
\N  \>  \key{insert} into  with priority \\

\N  \key{while}\\
\N  \>  \key{pop}the best priority vertex  from \\
\N  \>  \key{for each}edge  with \\
\NL{li:isbetterpath}  \>  \>  \key{if}path  improves over \\
\N  \>  \>  \> \key{set}\\
\end{prog}

\caption{Algorithm FindBackupPaths.}
\protect\label{fi:mainalgo}
\noindent\hrulefill \end{figure}

}

\commento{
The length and the number of edges in  of path  to be considered at Line~\ref{li:isbetterpath} can be easily computed in constant time using values , , ,  together with the weights of edges  and , knowing whether  and/or .
}

The next theorem shows that the set of short cycles computed in Algorithm \ResilientSpanner\ by the  calls to 
\ParsimoniousCycles\ yields a parsimonious sequence (of short cycles).

\begin{theorem}\label{th:isparsimonious}
There exists an ordering of the short cycles computed by Algorithm \ResilientSpanner\ so that the resulting sequence is parsimonious.
\end{theorem}
\begin{proof}
Let  be the order in which the vertices in  are considered as roots by Algorithm \ResilientSpanner\ (on Line 2 in Figure~\ref{fi:algobackup}). For each root , with , 
let  be the set of -fragile edges incident to  in the original spanner . Note that Algorithm
\ResilientSpanner\ computes
 a short cycle   
 for each edge , with . Moreover, the short cycle 
 
consists of a single-cross backup path for edge  and the edge  itself. To prove the theorem, we show that the sequence of short cycles, , for  and , sorted lexicographically by increasing , is parsimonious.

Let  and  be any two short cycles in this sequence that share two vertices, with the pair  preceding pair  lexicographically. We now distinguish two cases, depending on whether  () or ( and ).

\begin{description}
\item{Case :} when cycle  is computed by Algorithm \ParsimoniousCycles, all the edges in  are already in the current spanner .
Recall that  is a short cycle for edge , and let  be the unique edge in  that does not belong to . By Lemma~\ref{le:bestbackup},
the short cycle  consists of the edge  plus two subpaths in : a path  from  to  and a path  consisting of  edge   followed by a path from  to  (see Figure~\ref{fi:parsimoniousDiffRoot}).  
\begin{figure}[t]
\begin{center}
\includegraphics[width=11cm]{parsimoniousDiffRoot.pdf}
\end{center}
\caption{Proof of Theorem~\ref{th:isparsimonious}. Case .}\protect\label{fi:parsimoniousDiffRoot}
\end{figure}
If  and  share two vertices  and , two cases may occur: either  and  are in the same subpath
or they are in two different subpaths of . Furthermore, 
since both  and  are short cycles, the portion of  from  to  must have the same weight as the portion of  from  to .
We now consider the two cases separately.



In the first case, assume without loss of generality that both  and  are in  (see Figure~\ref{fi:parsimoniousDiffRoot} (a)). 
Note that at this point  the portion of the cycle  between  and  is already contained in .
Since  is a parsimonious shortest path tree, the subpath  in  must contain the minimum number of edges in , which implies that 
also the portion of the subpath  between  and  must be contained in  (i.e., cycles  and  satisfy the condition for being part of a parsimonious sequence).

In the second case, assume without loss of generality that  is in  and  is in  (see  Figure~\ref{fi:parsimoniousDiffRoot} (b)). Once again, at this point  the portion of the cycle  between  and  is already contained in . When  is computed by Algorithm \ParsimoniousCycles, the portion of  between  and  passing through edge  must be contained in  (otherwise the portion of  between  to  would have produced a cycle with the same weight and fewer edges of  ).
Once again, cycles  and  satisfy the condition for being part of a parsimonious sequence.

\commento{An ordered sequence of cycles  is said to be \emph{parsimonious} if the following property holds: for any pair of cycles  and , with , if  and  have two common vertices  and , where  and  split  into paths  and , then either 
 or .
Intuitively speaking, in a parsimonious sequence of cycles, each new cycle  reuses as much as possible portions of paths from the union of previous cycles , , .
}

\item{Case  and :} cycles  and  are computed during the same call of Algorithm \ParsimoniousCycles\ from a root . Since Algorithm \ParsimoniousCycles\ computes single-cross backup paths, each short cycle produced passes through the root  and traverses exactly two subtrees of . 
We observe that if  and  do not share any subtree, then they can intersect only at the root .
Hence, only the following two cases are possible for short cycles  and  intersecting at two vertices:
\begin{itemize}
\item{ and  are contained in the same two subtrees:} this case is shown in Figure~\ref{fi:parsimoniousSameRoot} (a). The intersection among cycles  and  is the path in  joining the lowest common ancestor  of  and  and the lowest common ancestor  of  and , where  (resp., ) is the cross edge for  (resp., ). In this case, any relative ordering among  and  produces a parsimonious sequence. 

\item{ and  share one subtree:} this case is shown in Figure~\ref{fi:parsimoniousSameRoot} (b). Also in this case, cycles  and  share exactly a path, namely the path between the root  and the lowest common ancestor of  and . The same argument as in the previous case applies. 
\end{itemize}

\end{description}

\begin{figure}[t]
\begin{center}
\includegraphics[width=11cm]{parsimoniousSameRoot.pdf}
\end{center}
\caption{Proof of Theorem~\ref{th:isparsimonious}. Case .}\protect\label{fi:parsimoniousSameRoot}
\end{figure}


\end{proof}

The following theorems bound the running time of Algorithm \ResilientSpanner\ and the number of edges in the computed -resilient -spanner.

\begin{theorem}\label{th:shvalpreservingbis}
Algorithm \ResilientSpanner\ runs in  time in the worst case.
\end{theorem}
\begin{proof}
We first bound the time required by Algorithm \ParsimoniousCycles\ in Figure~\ref{fi:algobackup}. 
The parsimonious shortest path tree  in Line~\ref{li:tree} can be computed by a slight modification of Dijkstra's shortest path algorithm in  worst case time, together with the auxiliary information about 
 , ,  and  for each vertex . Using this auxiliary information, each edge  can be processed in constant time in Lines 5--8. This implies that the total time spent through the loop in Lines 4--8 is bounded by .
Also the time spent in the initialization (Lines 2--3) and for returning all short cycles (Lines 9--12) is . As a result, each call to 
Algorithm \ParsimoniousCycles\ can be implemented in time  in the worst case.

We now turn to Algorithm \ResilientSpanner\ of Figure~\ref{fi:mainalgo}. As it was previously mentioned, 
all the -fragile edges (Lines 2--3) can be computed in  worst-case time by using Brandes' algorithm for computing shortcut values~\cite{Dagstuhl4}. 
Since each call to Algorithm \ParsimoniousCycles\  requires  worst-case time, the overall running time of the algorithm is  in the worst case.
\end{proof}






\begin{theorem}\label{th:shvalpreserving}
Let  be a graph with  vertices, with positive edge weights in , and let .
Algorithm \ResilientSpanner\ computes a -resilient -spanner  of , , with , containing  edges.
\end{theorem}
\commento{
\begin{proof}
As explained above, a -resilient -spanner  can be computed by adding a set  of short cycles to , one for each edge  with . Let  be the cycle in  added to the spanner.

We partition edges  with  into three subsets ,  and , according to their fragility in . For each subset we separately bound the number of edges in the union of cycles in  according to constants  and , where  is an odd integer greater than , and .
\begin{description}
\item[low fragility edges:] . By Theorem~\ref{th:fewhighshval}, we have ,\nota{qui non mostriamo che non pu\`o superare il numero di archi di  \ldots Forse un ?} and since each cycle , , contains at most  edges, we have


\item [medium fragility edges:] . By Theorem~\ref{th:fewhighshval}, since the fragility of each edge in  is greater than , . Since each cycle , , contains at most  edges


\item [high fragility edges:] . By Theorem~\ref{th:fewhighshval}, , and by Theorem~\ref{th:smallcycles} we have that 


\end{description}

\noindent
Hence the total number of edges in  is 


\end{proof}
}
\begin{proof}
By Theorem~\ref{th:correctweigthed}, the subgraph  computed by Algorithm \ResilientSpanner\ is a -resilient -spanner of , since it is obtained by adding a parsimonious sequence  of short cycles to a -spanner , one for each -fragile edge  in .

Let  be the cycle in  added to the spanner, and let  be the number of edges in .
We partition -fragile edges  into three subsets, ,  and , according to their fragility in . For each subset we separately bound the number of edges in the union of cycles in .
\begin{description}
\item[low fragility edges:] . By Theorem~\ref{th:fewhighshval}, we have

Thus, if  we have
, while  for .
Let  be any edge in . Since , cycle  contains at most  edges ( contains exactly  edges when  and all other edges in  have weight ). So, we have

while  for ;

\item [medium fragility edges:] . By Theorem~\ref{th:fewhighshval}, since the fragility of each edge in  is greater than , then

Each cycle , with , contains at most  edges, so we have



\item [high fragility edges:] . By Theorem~\ref{th:fewhighshval}, , and by Theorem~\ref{th:smallcycles} we have


\end{description}

\noindent
The total number of edges in  depends on values of  and :
\begin{itemize}
\item for \\
the number of edges is ;

\item for  and \\
the number of edges is ;

\item for , or  and \\
the number of edges is .

\end{itemize}
\end{proof}

\noindent
Note that, in the case of unweighted graphs, the number of edges in  is always . Thanks to Corollary~\ref{coro:alfabeta}, Algorithm \ResilientSpanner\ can also be used to compute a -resilient -spanner  of an unweighted graph, for any , containing  edges in the worst case.

\commento{
Since\nota{questa frase si riferisce all'algo, spostare nella relativa subsection} the time required to compute all those underlying spanners is , 
in all those cases the time required to build a -resilient spanner is .
Theorem~\ref{th:shvalpreserving} can also be applied to build -resilient -spanners, where  is a general \emph{distortion} function
as defined in~\cite{PettieSchema}, provided that . Furthermore, 
if we wish to compute a -resilient -spanner with , the same algorithm can still be applied starting from a -spanner instead of an -spanner, yielding the same bounds given in Theorem~\ref{th:shvalpreserving}.
}

\commento{
Our results can be extended to weighted graphs\nota{riportare la prova per i weighted},
since Theorems~\ref{th:fewhighshval} and \ref{th:smallcycles} also hold for graphs with positive edge weights.
Let  and  be respectively the maximum and minimum edge weight in the graph, and  let .
For either  or  and ,  we can compute
a -resilient -spanner
with  edges.
In the remaining cases (either   and larger  or ), the
total number of edges becomes  \nota{PGF: perch\'e questo non si accorda con la nuova prova?}. 
}

\section{Conclusions and further work}\label{se_conclusions}

In this paper, we have investigated a new notion of resilience in graph spanners by introducing the concept of -resilient spanners. In particular, we have shown that it is possible to compute small stretch -resilient spanners of optimal size for graphs with small positive edge weights.

The techniques introduced for small stretch -resilient -spanners can be used to turn any generic spanner (e.g., a fault-tolerant spanner, or, in the unweighted case, an -spanner, for ) into a -resilient spanner, by adding a suitably chosen set of at most  edges (that is,  in the unweighted case). 

We expect that in practice  
our -resilient -spanners, for , will be substantially sparser than what it is implied by the bounds given in Theorem~\ref{th:shvalpreserving}, and thus of higher value in applicative scenarios. Towards this aim, we plan to perform a thorough experimental study.
Another intriguing question is whether our theoretical analysis on the number of edges that need to be added to a -spanner in order to make it -resilient provides tight bounds, or whether it can be further improved for . 

\bibliographystyle{plain}
\bibliography{vital}

\end{document}
