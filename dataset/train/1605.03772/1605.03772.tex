\RequirePackage{fix-cm} \let\oldvec\vec \documentclass{sig-alternate-05-2015}


\newif\ifshort
\shortfalse \ifshort
\newcommand{\shortversion}{true}
\else
\newcommand{\shortversion}{false}
\fi
\newcommand{\shortver}[1]{\ifthenelse{\equal{\shortversion}{true}}{{#1}}{}}
\newcommand{\longver}[1] {\ifthenelse{\equal{\shortversion}{false}}{{#1}}{}}

\ifshort
\else
\pagenumbering{arabic}
\fi

\usepackage[small,bf]{caption} 
\usepackage[labelformat=simple]{subcaption}
\renewcommand\thesubfigure{(\alph{subfigure})}
\usepackage{times}

\newcommand{\descr}[1]{\smallskip \noindent \textbf{#1}}

\newtheorem{definition}{Definition}
\newtheorem{corollary}{Corollary}
\newtheorem{theorem}{Theorem}

\usepackage{color}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{balance}

\usepackage{algorithmic}
\usepackage[ruled, noend,lined,linesnumbered]{algorithm2e} 


\newcommand\mycommfont[1]{\ttfamily\textcolor{Gray}{#1}}

\newcommand{\emiliano}[1]{ \textbf{\em\color{blue} #1}}
\newcommand{\luca}[1]{ \textbf{\em\color{red} #1}}
\newcommand{\hassan}[1]{ \textbf{\em\color{Green} #1}}
\newcommand{\cyril}[1]{ \textbf{\em\color{magenta} #1}}


\newcommand{\EMB}{\ensuremath{\mbox{}}}
\newcommand{\CMB}{\ensuremath{\mbox{}}}
\newcommand{\TMB}{\ensuremath{\mbox{}}}
\usepackage{url}
	\makeatletter
	\def\url@leostyle{\@ifundefined{selectfont}{\def\UrlFont{\normalsize}}{\def\UrlFont{\normalsize}}}
	\makeatother	
\urlstyle{leo}

\usepackage{cite}	\usepackage{graphicx}
\graphicspath{{figures/}}
\definecolor{darkgreen}{RGB}{47,109,79}
\definecolor{darkblue}{RGB}{57,79,99}
\usepackage[bookmarks=false, colorlinks=true, plainpages = false, linkcolor = darkgreen,  citecolor = darkgreen, urlcolor = darkblue, filecolor = blue]{hyperref}

\newcommand{\subparagraph}{}


\def\labelitemi{--} 

\begin{document}

\CopyrightYear{2016} \setcopyright{acmcopyright}
\conferenceinfo{HotMiddlebox'16}{August 22-26, 2016, Florianopolis, Brazil}
\isbn{978-1-4503-4078-6/16/03}
\acmPrice{\5{\mu}s\EMB\CMB_1\CMB_2\CMB_3\TMB\CMB(t)\EMB\CMB(t)t = 3t\TMB\EMB\CMB(t)\EMBt \ge 2\CMB(t)\TMB\EMBtj\CMB_j\in\CMB(t)\CMB_j\TMB\EMB\TMB\EMBt-1\CMB(t)\EMB\CMB(t)\EMB\CMB(t)\CMB(t)\TMBxx \in \{0, 1\}^*nx|x| < nxnm : \{0, 1\}^{n} \rightarrow \{0, 1\}1 - m\overline{m}a :  \{0, 1\}^{n} \rightarrow \{0, 1\}^{n}m(x)a(x)max(1, n)nx|x| > nax(n + 1, *)xI(x) = xMAI \in A\psi = (M, A)MAa \in Am \in M\overline{m}m \in MIm \in M\overline{m}IMA(m, a)\psi\overline{m}ma(m, a)\psi\psi\psi(m, a)\psix \in \{0, 1\}^*\psi(x){x}_\mathtt{w}xxx_\mathtt{r}{x}_\mathtt{w}k3(m_1, a_1), (m_2, a_2)(m_3, a_3)(m_2, a_2)m_1m_2a \circ I = I \circ a = ax\psix_\mathtt{r}{x}_{\mathtt{w}}x{x}_\mathtt{w} \leftarrow a({x}_\mathtt{w})a{x}_\mathtt{w}m(x_\mathtt{r})mm(x_\mathtt{r}) = 1IIa_1Ia_2IIa_k\overline{m}_1m_1\overline{m}_2m_2\overline{m}_km_kkIIa_1Ia_2\overline{m}_1m_1\overline{m}_2m_2Ia_2\overline{m}_2m_2Ia_3\overline{m}_3m_33(m_2, a_2)IIa\overline{m}m(m,a)IIa_1Ia_2IIa_k\overline{m}_1m_1\overline{m}_2m_2\overline{m}_km_kkIIa_1Ia_2\overline{m}_1m_1\overline{m}_2m_2Ia_2\overline{m}_2m_2Ia_3\overline{m}_3m_33(m_2, a_2)\psi_1\psi_2\CMB(t)\psi_2\psi_1\psi_2xx_\mathtt{w}\psi_2\psi_1ma*x \in \{0, 1\}^ny \in \{0, 1, * \}^nx = yx(i) = y(i)i \in [n]y(i) \ne *x \in \{0, 1\}^*mm(x)=1x(1, n) = \mu0\mu \in \{0, 1, *\}^n\mumx \in \{0, 1\}^nz \in \{0, 1, *\}^nx \leftarrow zx(i)z(i)z(i) \ne *x(i)z(i) = *i \in [n]x \in \{0, 1\}^*aa(x) = x(1, n) \leftarrow \alpha\alpha \in \{0, 1, *\}^n\alphaaI\alpha = *^nII(x) = x(1, n) \leftarrow \alpha\alpha = *^nz \in \{0, 1, * \}^nz\pi_z\in \{0, 1\}^n\pi_z(i) = 1z(i) \in \{0, 1\}\pi_z(i) = 0z(i) = *x \in \{0, 1, *\}^nx \in \{0, 1\}^n\pi_z \in \{0, 1\}^n\omega(\pi_z, x)x'x'(i) = x(i)\pi_z(i) = 1x'(i) = 0\pi_z(i) = 0\omega(\pi_z, x)x \in \{0, 1, *\}^nx \in \{0, 1\}^n\mathbb{H}: \{0, 1\}^n \rightarrow \{0, 1\}^q\oplusx \in \{0, 1\}^n\text{wt}(x)x \leftarrow_{\ means sampling a binary string of length  uniformly at random. 


\section{Introducing SplitBox}\label{sec:solution}

\longver{\subsection{Privacy Requirements}}
\shortver{\descr{Privacy Requirements.}}
We start by describing an \emph{ideal} setting in which a trusted third party, , computes a network function  for the client. Upon receiving a packet ,  forwards it to , which provides the result of  to . Here  learns  but not  and  neither  nor . In this section, we introduce our private NFV solution, SplitBox, aiming to simulate this ideal setting. However, we fall slightly short in that the MBs  learn the projection  and the output  for each , however, they do not learn the match  for any  beyond what is learnable from . Although this could reveal information such as which field of the packet the current matching function corresponds to, we do not consider it to be a strong limitation since this might be obvious from the type of NFV considered anyway. For example, if it is a firewall, then it is common knowledge that the fields it operates on will include IP address fields.

\longver{\subsection{The System}}
\descr{Design Aims.}
We consider the following design aims, i.e., the solution should: (a) 
be secure; (b) be computationally fast; (c) 
limit MB-to-MB communication complexity.

\begin{figure}[!tb]
\centering
\resizebox{1\columnwidth}{!}{
\begingroup \makeatletter \providecommand\color[2][]{\errmessage{(Inkscape) Color is used for the text in Inkscape, but the package 'color.sty' is not loaded}\renewcommand\color[2][]{}}\providecommand\transparent[1]{\errmessage{(Inkscape) Transparency is used (non-zero) for the text in Inkscape, but the package 'transparent.sty' is not loaded}\renewcommand\transparent[1]{}}\providecommand\rotatebox[2]{#2}\ifx\svgwidth\undefined \setlength{\unitlength}{200.85478516bp}\ifx\svgscale\undefined \relax \else \setlength{\unitlength}{\unitlength * \real{\svgscale}}\fi \else \setlength{\unitlength}{\svgwidth}\fi \global\let\svgwidth\undefined \global\let\svgscale\undefined \makeatother \begin{picture}(1,0.7)\put(0,0){\includegraphics[scale=0.5,width=\unitlength]{algo-breakdown-compress.pdf}}\put(0.23,0.635){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{\scriptsize }}}\put(0.47,0.635){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{\scriptsize }}}\put(0.82,0.635){\color[rgb]{0,0,0}\makebox(0,0)[lb]{\smash{\scriptsize }}}\end{picture}\endgroup }
\caption{Breakdown of algorithms executed by each MB in SplitBox.}
\vspace{-0.1cm}
\label{fig:algo-breakdown}
\end{figure} 

\descr{High-Level Overview.}
In a nutshell, if we assume that  includes a single policy , our strategy to hide  
is to let  \emph{blind}  by XORing it with a random binary string  and sending the hash of the result to each MB in ; whereas, to hide ,  computes  \emph{shares} of the action  using a -out-of- secret sharing scheme and sends share  to . In addition,  encrypts the contents of a packet  by XORing it with the blind , and sends it to the MBs in , which can then compute matches and actions on this encrypted packet. 
We present the details of SplitBox using a set of algorithms, grouped based on the MB executing them. Figure~\ref{fig:algo-breakdown} shows a high-level overview of all the algorithms computed by each MB. We assume  to be the private version of the network function  whose matching and action functions are replaced by unique identifiers. 


\descr{Middlebox \texorpdfstring{}{C)}.}
The initial setup is performed by  via Algorithm~\ref{alg:glob_setup}.
This includes creating lookup tables (Algorithm~\ref{alg:lookup_setup}), hiding
the matching functions (Algorithm~\ref{alg:hide_match}), and splitting the
action functions (Algorithm~\ref{alg:split_action}). There are two lookup
tables in Algorithm~\ref{alg:lookup_setup}:  for  and
 for . Table  contains  ``blinds'' which are random
binary strings used to encrypt a packet by XORing. For each blind  and
for each , the portion of the blind corresponding to the projection of
the match  is extracted and then XORed with . Finally this value is
hashed using  and stored in the corresponding row of .
The \texttt{Hide Match} algorithm simply sends the projection  of each
match  to . This tells  which locations of the incoming
packet are relevant for the current match. The \texttt{Split Action} algorithm
computes  shares of the action  and action projection ,
for each  and sends them to .  uses one more algorithm,
Algorithm~\ref{alg:merge_shares} to reconstruct the transformed packet. This
algorithm XORs the cumulative action shares  and cumulative action
projection shares  from  to compute the final action
 and action projection . It also XORs the
encrypted packet received from  with the current blind  in the lookup table , in order to
reconstruct the final packet. Note that we have modelled dropping a packet as setting  to . 

\begin{algorithm}[t]
\caption{\texttt{Global Setup} ()}
\label{alg:glob_setup}
\SetAlgoLined
\SetCommentSty{mycommfont}
\SetAlCapSkip{1em}
\DontPrintSemicolon{}
\SetKwInOut{Input}{Input}
\let\oldnl\nl \newcommand{\nonl}{\renewcommand{\nl}{\let\nl\oldnl}}\Input{Parameters  and , network function .}
\For{ \KwTo }{
	Send  to . \;
}
Run \texttt{Setup Lookup Tables} with parameter , .\;
\For{each }{
	Run \texttt{Hide Match} algorithm.\;
}
\For{each }{
	Run \texttt{Split Action} algorithm.\;
}
\end{algorithm}

\begin{algorithm}[t]
\caption{\texttt{Setup Lookup Tables} ()}
\label{alg:lookup_setup}
\SetAlgoLined
\SetCommentSty{mycommfont}
\SetAlCapSkip{1em}
\DontPrintSemicolon{}
\SetKwInOut{Input}{Input}
\let\oldnl\nl \newcommand{\nonl}{\renewcommand{\nl}{\let\nl\oldnl}}\Input{Parameter , set .}
Initialize empty table  with  cells.\;
Initialize empty table  with  cells.\;
\For{ \KwTo }{
	Sample } \{0, 1\}^ns_{i}iSj = 1| M |\tilde{s}_{i, j} = \omega(\pi_{\mu_j}, s_i)\mu_jm_j\mathbb{H}(\mu_j \oplus \tilde{s}_{i, j})\mathbb{H}(\mu_j \oplus \tilde{s}_{i, j})(i, j)\tilde{S}S\EMB\tilde{S}\CMB(t)\TMBm \in M\mu\pi_{\mu}\CMB(t)\TMBa \in A\alpha\alpha_1, \alpha_2, \ldots, \alpha_{t-1} \leftarrow_{\.\;
Let . Compute .\;
Sample } \{0, 1\}^n\beta_t = \pi_{\alpha} \oplus \beta_1 \oplus \cdots \oplus \beta_{t-1}j = 1t\alpha_j, \beta_j\CMB_j\TMBi{x}_{\mathtt{w}}\alpha'_j\beta'_j\CMB_jj \in [t]\alpha' \leftarrow \alpha'_1 \oplus \cdots \oplus \alpha'_t\beta' \leftarrow \beta'_1 \oplus \cdots \oplus \beta'_tx \leftarrow {x}_{\mathtt{w}} \oplus s_is_i\in Si = 1n\beta'(i) = 1x(i) \leftarrow \alpha'(i)x(1, n) = 0^{n}xx\EMB0xS[l]0xx_\mathtt{r}\CMB(t){x}_\mathtt{w}\TMBx_\mathtt{r}x_\mathtt{w}S\CMB(t)\TMB\EMBxSi \in [l]x_{\mathtt{w}} \leftarrow x \oplus s_is_i\in Sx_\mathtt{r} \leftarrow x(1, n) \oplus s_is_i \in Sj = 1tx_\mathtt{r}i\CMB_jx_\mathtt{w}i\TMB\CMB(t)\CMB_j\CMB_j\alpha'_j\beta'_j\CMB_j\alpha'_j\beta'_jx_\mathtt{r}x_\mathtt{r}\pi_\mui\EMB\tilde{S}x_\mathtt{r}\CMB(t)ix_\mathtt{r}\psi_{\text{priv}}\alpha'_j \leftarrow 0^n\beta'_j \leftarrow 0^n\alpha'_j\beta'_jai\alpha'_j\beta'_j\TMBimx_\mathtt{r}m\CMB(t)(\alpha'_j, \beta'_j)\CMB_j(\alpha_j, \beta_j)a \in A\CMB_j\alpha'_j \leftarrow \alpha'_j \oplus \alpha_j\beta'_j \leftarrow \beta'_j \oplus \beta_j\alpha'_j\beta'_j\CMB(t)x_\mathtt{r}i \in [l]\tilde{S}j \in [|M|]m_j \in M\mu_j\tilde{S}(i, j)\mathbb{H}(\tilde{s}_{i, j})\tilde{x}_\mathtt{r} \leftarrow \omega(\pi_{\mu_j}, x_\mathtt{r})\mathbb{H}(\tilde{x}_\mathtt{r})m(x) = 1\mathbb{H}(\tilde{x}_\mathtt{r}) = \mathbb{H}(\mu_j \oplus \tilde{s}_{i, j})m(x) = 0\psi = (M, A)m \in Mmm\mathtt{127.*.*.32}\mathtt{127.*.*.64}m\psix\beta_i\beta_jI0^n\CMB(t)\mathbb{H}\mu \oplus ssmm(x) = 0x\mathbb{H}\CMB(t)mlll0 < 1 - \rho < 1\EMB\{0, 1\}^n\CMB(t)i \in [l] \rho^2\rhol\EMB\TMB\CMB(t)\TMBtt\CMB(t) \rho^2\rho\EMB\TMB\CMB(t)\TMBtt\EMB\CMB\TMB\EMB\CMB_j\TMB\TMB\mathbb{H}0^nt = 2\mathcal{B}(t)\mathcal{A}\mathcal{C}\mathcal{C}\mathcal{B}_j\mathcal{B}_jllkttt\mathcal{E}\mathcal{A}t - 1\mathcal{B}(t)\Pi\Pin\mathcal{A}\psi = (M, A)|M||A|x\mathcal{B}_j \in \mathcal{B}(t)\pi_\mu\mum \in M\mum \in M\pi_\mu\psi(x)x\psix\mathcal{B}_j\mathbb{H}m \in M\psi\mathcal{B}_j \in \mathcal{B}(t)xx_1x_2x_1x_2\psi(x_1)\psi(x_2)m\pi_{\mu}\mu\pi_{\mu}m(x_1) = m(x_2) = 1m(x_1) \ne m(x_2)\mathcal{B}_j\pi_{\mu}\text{wt}(\pi_\mu) = 1\mathbb{H}t - 1\mathcal{B}(t)\alpha\betaa \in AIO\mathcal{E}IXxD\psi\psiX\psi(X)\textsc{ideal}(\psi, \mathcal{S})\mathcal{T}\mathcal{T}\psi = (M, A)\mathcal{B}(t)M\{1, 2, \ldots, |M|\}\pi_\mu\mum \in M\mathcal{A}x\mathcal{T}\mathcal{T}x' = \psi(x)x'\mathcal{C}\mathcal{T}m \in M\mathcal{B}(t)\mathcal{S}\textsc{ideal}(\psi, \mathcal{S})(I, O, X, \psi(X), D)\mathcal{S}\textsc{real}(\Pi, \mathcal{E})\mathcal{E}(I, O, X, \psi(X), D)\mathcal{E}\mathcal{E}\mathcal{A}t-1\mathcal{B}(t)\mathcal{S}(I, O, X, \psi(X), D)\mathcal{E}\mathcal{S}\approx_c\Pi\psicc_1, \ldots, c_tc_1, \ldots, c_{t-1}\{0, 1\}^nc_t = c_1 \oplus \cdots \oplus c_{t - 1} \oplus cc_1, \ldots, c_tC(t-1)\le t - 1\mathbb{P}[c | C(t-1)] = \mathbb{P}[c] = 2^{-n}tt\Pi\psi\mathcal{E} = \mathcal{A}\mathcal{S}ls_i \in \{0, 1\}^nS\mathcal{E}0x\mathcal{S}\mathcal{T}\mathcal{E}\mathcal{S}i \in [l]r \in \{0, 1\}^nx_{\mathtt{w}} \leftarrow x \oplus rtrjr_jx_\mathtt{r} \leftarrow x(1, n) \oplus s_iiS\mathcal{S}x_{\mathtt{r}}ix_{\mathtt{w}}tr\mathcal{E}il\mathcal{S}0\mathcal{A}xI = XO\psiD\psi\textsc{real}(\Pi, \mathcal{E}) =\vspace{-0.1cm}\textsc{ideal}(\psi, \mathcal{S}) \Rightarrow \textsc{real}(\Pi, \mathcal{E})	 \approx_{\text{c}} \textsc{ideal}(\psi, \mathcal{S})\mathbb{H}\mathcal{E} \subset \mathcal{B}(t)\muM\le l\delta = \min_\mu \text{wt}(\pi_\mu)m \in M\Pi\psil\mathcal{E} \subset \mathcal{B}(t)\mathcal{R}: \{0, 1\}^* \rightarrow \{0, 1\}^{q}\mathcal{S}\tilde{S}m \in M\pi_\mu\mul\pi_\mu(i) = 10\mathcal{S}q\mathcal{S}\tilde{S}\hat{S}\hat{S}\tilde{S}\tilde{S}\mathcal{E}(m, a) \in \psi|\mathcal{E}|\alpha_j\beta_jn1 \le j \le |\mathcal{E}|(\alpha_j, \beta_j)\mathcal{E}\mathcal{S}i0M\mathcal{T}\mathcal{S}x_{\mathtt{w}}|\mathcal{E}|nr_j\mathcal{S}x_{\mathtt{r}}m\mathcal{S}\hat{S}\pi_{\mu}\mux_{\mathtt{r}}\hat{S}x_{\mathtt{r}}\mathcal{S}x_{\mathtt{w}}x_{\mathtt{r}}r_j\mathcal{E}i\mathcal{B}_j \in \mathcal{E}\mathcal{S}\hat{S}\mathcal{S}\hat{S}\mathcal{E}q\hat{S}(I, O, X, \psi(X), D)\mathcal{E}\mathcal{E}|\mathcal{E}| < ti \le l\delta\textsc{real}(\Pi, \mathcal{E})	 \approx_{\text{c}} \textsc{ideal}(\psi, \mathcal{S})$.
\end{proof}

\fi

\end{document}
