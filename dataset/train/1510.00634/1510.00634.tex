

\documentclass[3p]{elsarticle}
\usepackage{ALgo}
\usepackage{amsmath,amssymb}
\usepackage{url}
\usepackage{tikz, pgfplots}
\usepackage{multirow}

\usepackage[position=top]{subfig}

\def\sa#1{\mbox{\tt #1}}
\def\pp{\mathinner{\ldotp\ldotp}}
\def\PV{\mathcal{P}}
\def\PVW{\mathcal{P}_{\s{w}}}
\def\QV{\mathcal{Q}} 

\def\Div{\mathit{Div}}
\def\Mult{\mathit{Mult}}
\def\FILTER{\mathit{FILTER}}

\def\myCount{\textit{count}}

\sloppy

\newtheorem{example}{Example}

\newtheorem{thm}{Theorem}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
\newdefinition{defi}{Definition}
\newdefinition{obs}{Observation}
\newproof{pf}{Proof}

\newcommand{\todo}[1]{\marginpar{\tiny \flushleft{#1}}}

\def\s#1{\mbox{\boldmath }}
\def\itbf#1{\textit{\textbf{#1}}}

\renewcommand{\epsilon}{\varepsilon}

\begin{document}

\title{\textbf{A Note on Easy and Efficient Computation \\of Full Abelian Periods of a Word}\footnote{The results in this note have been presented in preliminary form in \cite{FiLeLePrSm12}.}}

\author[palermo]{G. Fici}
\ead{Gabriele.Fici@unipa.it}

\author[rouen]{T. Lecroq}
\ead{Thierry.Lecroq@univ-rouen.fr}

\author[rouen]{A. Lefebvre}
\ead{Arnaud.Lefebvre@univ-rouen.fr}

\author[rouen]{\'E. Prieur-Gaston}
\ead{Elise.Prieur@univ-rouen.fr}

\author[mcmaster]{W.\ F.\ Smyth}
\ead{smyth@mcmaster.ca}

\address[palermo]{Dipartimento di Matematica e Informatica, Universit\`a di Palermo, Italy}

\address[rouen]{LITIS EA4108, Universit\'e de Rouen, 76821 Mont-Saint-Aignan Cedex, France}

\address[mcmaster]{Dept of Computing and Software, McMaster University,
Hamilton ON L8S 4K1, Canada and Faculty of Engineering \& Information Technology,
 Murdoch University, Murdoch WA 6150, Australia}

\begin{abstract}
Constantinescu and Ilie (Bulletin of the EATCS 89, 167--170, 2006) introduced the idea of an Abelian period with head and tail of a finite word. An Abelian period is called full if both the head and the tail are empty.
We present a simple and easy-to-implement -time algorithm for computing all the full Abelian periods of a word of length  over a constant-size alphabet. Experiments show that our algorithm significantly outperforms the  algorithm proposed by Kociumaka et al.~(Proc.~of STACS, 245--256, 2013) for the same problem.
\end{abstract}

\begin{keyword}
Abelian period; Abelian power; weak repetition; design
 of algorithms; text algorithms; combinatorics on words.
\end{keyword}

\maketitle

\section{Introduction}

The study of repetitions in words is a classical topic in Stringology. A word is called an (integer) power if it can be written as the concatenation of two or more copies of another word, like \sa{barbar}. However, any word can be written as a \emph{fractional} power; that is, given a word , one can always find a word  such that , where  is a (possible empty) prefix of  and  is an integer greater than or equal to one. In this case, the length of  is called \emph{a period} of the word . A word  can have different periods, the least of which is usually called \emph{the period} of .

Recently, a natural extension of this setting has been considered involving the notion of commutative equivalence. Two words are called commutatively equivalent if they have the same number of occurrences of each letter; that is, if one is an anagram of the other. An Abelian power (also called a weak repetition~\cite{Cummings_weakrepetitions}) is a word that can be written as the concatenation of two or more words that are commutatively equivalent, like  \sa{iceddice}.

Recall that the Parikh vector  of a word  is the vector whose th entry is the 
 number of occurrences of the th letter of the alphabet in . 
 For example, given the (ordered) alphabet , the Parikh vector
 of the word  is . Two words are therefore commutatively equivalent if and only if they have the same Parikh vector.

Constantinescu and Ilie~\cite{CI2006} introduced the definition of an Abelian period with head and tail of a word  over a
 finite ordered alphabet : An integer  is an Abelian period of   if one can write
  where for 
 all the factors 's have the same Parikh vector  such that
 
 and the Parikh vectors of  and  are ``contained''
 in , in the sense that they are proper sub-Parikh vectors of  (see next section for the formal definition of ``contained''). In this case,  and  are called the head and the tail of the Abelian period , respectively. 
This definition of an Abelian period matches that of an
Abelian power when  and  are both  empty  and
 .
 
 As an example, the word  over the alphabet  can be written as
 , where
 , , , , with  the empty word,
 so that  is an Abelian period of  with Parikh vector 
 (the Parikh vector of  is  and that of 
 is  which are both ``contained'' in ). Notice that  has also Abelian period , since it can be written as , with , , , , .

This example shows that a word can have different Abelian periods. Moreover, a word can have the same Abelian period  corresponding to different factorizations; that is, with different heads. Actually, a word of length  can have  many different Abelian periods \cite{DAM}, if these are represented in the form , where  is the length of the head---the length of the tail is uniquely determined by  and .

Recently~\cite{PSC2011-16,DAM} we described algorithms for computing all the
 Abelian periods
 of a word of length  in time .
This was improved to time  in~\cite{MichalisChrist2012}.
In~\cite{CIKKPRRTW2012} the authors derived an 
 efficient
 algorithm for computing the Abelian periods 
based on prior computation of the Abelian squares.

An Abelian period is called \emph{full} if both the head and the tail are empty. Clearly, a full Abelian period is a divisor of the length of the word.

A preliminary version of the present paper appeared in~\cite{FiLeLePrSm12}
 where we presented brute force algorithms to compute full Abelian periods
 and Abelian periods without head and with tail in  time and a 
 quasi-linear time algorithm QLFAP for
 computing all the full Abelian periods of a word.
In \cite{KoRaRy13} Kociumaka et al.~gave a linear time algorithm LFAP for the same problem.
Here we first briefly outline LFAP,
followed by a description of QLFAP.
Then, extending the presentation in~\cite{FiLeLePrSm12},
we add an experimental section to demonstrate that our algorithm
significantly outperforms LFAP in practice,
both on pseudo-randomly generated and genomic data.
Our method has the additional
advantage of being conceptually simple and easy to implement.
  
\section{Notation}
\label{sec-def}

Let  be a finite ordered
 alphabet of cardinality  and  the set of finite words
 over . 
We let  denote the length of the word .
Given a word  of length , we write  for the -th symbol of 
 and, for , we write  for the factor of 
 from the -th symbol to the -th symbol, both included.
We let  denote the number of occurrences of the symbol
  in the word . 

The \emph{Parikh vector} of , denoted by ,
 counts the
 occurrences of each letter of  in , that is, 
 .
Notice that two words have the same Parikh vector if and only if
 one word is a permutation of the other (in other words, an anagram).

Given the Parikh vector  of a word , we let  denote its
 -th component and  its norm, defined as the sum of its components.
Thus, for  and , we have
  and .

Finally, given two Parikh vectors , we write  if
 
 for every  and . 
This makes precise the notion of ``contained'' used in the Introduction.
 
\begin{defi}[Abelian period \cite{CI2006}]
\label{def-ap}
A word  has an Abelian period  if
  
 such that:

\begin{itemize}
 \item ,
 \item , .
\end{itemize}

\end{defi}

We call  and  respectively the \emph{head} and the
 \emph{tail}  of the Abelian period.
 Notice that the length  of the tail is uniquely determined
 by ,  and , namely . 

The following lemma gives a bound on the maximum number of Abelian periods
 of a word.
\begin{lem}[\cite{PSC2011-16}]
\label{lemma-max}
The maximum number of different Abelian periods  for a word of length  over
 an alphabet of size 
 is .
\end{lem}

\begin{pf}
The word  has Abelian period
  for any  and every  such that 
 . \qed
\end{pf}

An Abelian period is called \emph{full} if it has head and tail both empty.
We are interested in computing all the full Abelian periods of a word. Notice that a full Abelian period of a word of length  is a divisor of .
In the remainder of this note, we will therefore write that a word 
 has an Abelian period  if and only if it has full Abelian period . 
 
\section{Previous work}\label{sec-prev-work}


We now outline the linear algorithm LFAP given in~\cite{KoRaRy13}.

Let  be a word of length .
Let .
Two positions  are called proportional,
 which is denoted by , if 
 for each , where  is a real number independent of .
 
An integer  is called a candidate (as a potential Abelian period) if
  for each  where  is the set
  of multiples of  not exceeding , or equivalently
 .

A positive integer  is a full Abelian period of 
 if and only if  and  is a candidate.

The algorithm first computes the set  and
 then the set
 .

 
Let  be the rank in the alphabet of a least frequent letter  of .
Let  be the position of the first occurrence of  in .
For  let 
 .
Vectors  are used in order to deal with vector equality
 instead of vector proportionality.

If  then  is equivalent to 
 .
The problem of computing the set 
 reduces to check if 
 is equal to  for .
This is done in linear time by using what the authors called
 a diff-representation of the 's (see~\cite{KoRaRy13}
 for details).

The authors show that the set  can be computed
 in linear time.
This can be done by showing that after an  time preprocessing,
 the value  for any  can be computed
 in constant time (see~\cite{KoRaRy13}
 for details).
 
 
\section{The new algorithm}\label{sec-nohead-notail}


In this section, we describe our algorithm QLFAP for computing all the full Abelian periods of a word  of length  over a constant-size alphabet .

In a linear-time preprocessing phase, we compute  for , 
 i.e., the components of the Parikh vector of the word .
Let  denote the greatest common divisor of the
 elements of the Parikh vector of , computable in
  time~\cite{Bradley1970}.
Then we compute .
We can suppose  and , otherwise the solution is trivial.
In  time we compute a stack  of all divisors  of 
 in increasing order. 

\begin{obs}
\label{obs-poss}
The only possible full Abelian periods of 
 are of the form , where  is an entry in .
Therefore, the smallest possible full Abelian period of  is .
\end{obs}

\begin{defi}[scaled]
\label{def-scaled}
A factor  of a word  is \itbf{scaled} if and only if there exists  such that , where  is
 the smallest possible Abelian period of .
\end{defi}

\begin{obs}
\label{obs-scaled}
If  and  is scaled, then  is scaled.
\end{obs}

A scaled factor is called \emph{irreducible} if it cannot itself be factored into scaled factors. According to Definition~\ref{def-scaled} and 
 Observation~\ref{obs-scaled}, 
 every word 
 can be factored uniquely into irreducible scaled factors by computing the shortest scaled 
 prefix  of  and then factoring the suffix  recursively, 
 until this suffix is empty. This factorization is computed by calling procedure
\textsc{ComputeL} given in \figurename~\ref{algo-computel}, which computes the scaled prefixes of  (or analogously, by the previous observation, the scaled suffixes of ). 
It returns a boolean array  of length  defined by:  if and only if  is the starting position of a scaled suffix of . 
It also returns the value  such that the longest scaled factor computed is of length .

\begin{obs}
\label{obs-fact}
Consider two positions , with , such that . Then  is scaled.
\end{obs}

\begin{obs}
\label{obs-T}
A full Abelian period of  must be greater than or equal to .
\end{obs}

\begin{figure}
\begin{algo}[numcom]{ComputeL}{\s{w},s,g,\PVW}
  \SET{(i,T,L)}{(0,0,0^{|\s{w}|})}
  \DOWHILE{i\leqslant|\s{w}|-s}
    \SET{j}{0}
    \SET{t}{0}
    \SET{\myCount}{0^{\sigma}}
    \label{loop-scaled}
    \DOWHILE{j<\sigma}
      \INCR{t}
      \label{loop-PV}
      \DOFORI{k}{1}{s}
        \INCR{\myCount[w[i]]}
        \INCR{i}
      \OD
      \SET{j}{0}
      \label{internalloop}
      \DOWHILE{j<\sigma \AND \lfloor \myCount[j]/t\rfloor=\PVW[j]/g}
        \INCR{j}
      \OD
    \OD
    \SET{L[i-t\times s]}{1}
    \SET{T}{\max(T,t)}
  \OD  
  \RETURN{(L,T)}
\end{algo}
\caption{\label{algo-computel}Algorithm computing 
array  such that  iff  is the starting position of a scaled
suffix of .
}
\end{figure}

\begin{prop}
The algorithm \textsc{ComputeL} computes the boolean array  of a word 
 of length 
 over an alphabet of size  in time .
\end{prop}

\begin{pf}
The internal loop in line~\ref{loop-scaled} is performed until a scaled factor
 of length  is found: the loop in line~\ref{loop-PV} computes the Parikh vector of
 the factor  and the loop in line~\ref{internalloop} verifies that this
 factor is scaled: its length is equal to  and it should hold for every letter 
 that .
This can be rewritten as  since .
Since, by definition of ,  is an integer the test can be reduced to
  since it should hold for every letter.
This avoids to use real numbers.
Furthermore the  are constant for a given  and can thus be 
 precomputed.
When such a scaled factor is found, its starting position is 
 and  is set to . Since the algorithm starts from 
 position , therefore, according to Observation~\ref{obs-scaled}, array  is filled correctly.

The algorithm visits each position  in  exactly once,
 and corresponding to each  performs a constant-time processing.
The internal loop in line~\ref{internalloop} is performed at most 
 times, every  positions.
It is performed  times and since , each
 iteration costs  time.
Thus the algorithm runs in time .\qed
\end{pf}

\begin{example}
, .
\begin{center}
\scalebox{0.775}{
\setlength{\tabcolsep}{.09cm}
\begin{tabular}{|l|cccccccccccccccccccccccccccccc|}
\hline
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\\
\hline
&\sa{a}&\sa{b}&\sa{a}&\sa{a}&\sa{b}&\sa{a}&\sa{b}&\sa{b}&\sa{b}&\sa{a}&
\sa{b}&\sa{a}&\sa{a}&\sa{b}&\sa{b}&\sa{a}&\sa{b}&\sa{b}&\sa{a}&\sa{a}&
\sa{a}&\sa{b}&\sa{b}&\sa{a}&\sa{b}&\sa{a}&\sa{b}&\sa{b}&\sa{a}&\sa{a}\\
\hline
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\\
\hline
\end{tabular}
}
\end{center}
\noindent
The word  is factored into irreducible scaled factors in the following way:
. Since the length of the longest word in this factorization is  and , the
value of  is .
\end{example}

\begin{lem}
\label{lem-seg}
The word  has full Abelian period  
 if and only if for every
 ,  is the starting position
 of a scaled suffix of .
 \end{lem}

\begin{pf}
Suppose that  
is an Abelian period of .
According to Observation~\ref{obs-fact},  
we have that for every
  the position
  is the starting position
 of a scaled factor and then of a scaled suffix of . 
 
Conversely, if  is the starting position
 of a scaled suffix of  for every , it follows from Observation~\ref{obs-fact} that  is scaled and consequently  
 that  is an Abelian period of .\qed
\end{pf}

The algorithm \CALL{QuasiLinearFullAbelianPeriods}{\s{w}},
 given in \figurename~\ref{alg-Arep}, computes all the full
 Abelian periods 
 of a word .
It first computes the greatest common divisor  of the elements of
  (line~\ref{inst1}).
Then it computes  (line~\ref{inst2}).
This is followed by the computation of the array  giving the starting positions of the scaled
 suffixes and of the threshold  (line~\ref{inst3}). 
Then it computes the stack  of all the divisors of  greater than or equal to 
 (line~\ref{inst4}).
Then it checks for every divisor  of  in , whether all the multiples
 of  are starting positions of scaled suffixes  (lines~\ref{inst5}--\ref{inst6}).

\begin{example}
. We have
, , , , .
When ,  and  is not a starting position of a scaled suffix.
When ,  and  is not a starting position of a scaled suffix.
When ,  and ,  are starting positions of 
 scaled suffixes, hence  is a full Abelian period of .
The case where  is trivial since it corresponds to Abelian period .
Thus the algorithm returns , which is the set of full Abelian periods of .
\end{example}

\begin{thm}
The algorithm \CALL{QuasiLinearFullAbelianPeriods}{\s{w}} computes all the full
 Abelian periods of a word  of length  
over an alphabet of size   in time  and space .
\end{thm}

\begin{pf}
The correctness comes from Observation~\ref{obs-poss} 
 and from Lemma~\ref{lem-seg}.
The algorithm \CALL{QuasiLinearFullAbelianPeriods}{\s{w}}
 scans all the multiples of
 the divisors , whose number is equal to the sum of the
 divisors of , which in turn is ~\cite{gronwall}.
The algorithm requires  space for  and .
\qed
 \end{pf}

\begin{figure}
\begin{algo}[numcom]{QuasiLinearFullAbelianPeriods}{\s{w}=[\s{w}_0\ldotp\ldotp \s{w}_{n-1}]}
  \label{inst1}\SET{g}{\text{greatest common divisor of elements of }\PVW}
  \label{inst2}\SET{s}{n/g}
  \label{inst3}\SET{(L,T)}{\CALL{ComputeL}{\s{w},s,g,\PVW}}
  \label{inst4}\SET{D}{\text{divisors of  greater or equal than }}
  \SET{R}{\emptyset}
  \label{inst5}\DOWHILE{d<g}
    \SET{k}{1}
    \DOWHILE{k\times d\times s<n \AND L[k\times d\times s]=1}
       \INCR{k}
    \OD 
    \IF{n\leqslant k\times d\times s}
      \SET{R}{R\cup \{i\}}
    \FI
    \label{inst6}\SET{d}{\CALL{Pop}{D}}
  \OD
  \SET{R}{R\cup \{n\}}
  \RETURN{R}
\end{algo}
\caption{\label{alg-Arep}Algorithm computing the set of Abelian periods of word .}
\end{figure}

\section{Experimental results}\label{sec:res}


\subsection{Implementation}

We implemented both \textsc{QuasiLinearFullAbelianPeriods} (QLFAP)
and the algorithm \textsc{LinearFullAbelianPeriods} (LFAP) of~\cite{KoRaRy13}
in a homogeneous way in \texttt{C}.

LFAP requires seven integer arrays of space  to compute
the diff-representation plus five more for the preprocessing of the set B
(see Sect.~\ref{sec-prev-work} for terminology).
On the other hand, QLFAP requires only
two integer arrays  and  of length ,
together with the Parikh vector of length 
and the stack  (implemented as an integer array of length ).

In both algorithms, the memory space for the different arrays has been
 allocated one by one.

All the experiments have been performed on a computer with a  GHz Intel Core i5 processor and 4 Go 1600 MHz DDR3 RAM.

\subsection{Results}

\figurename s~\ref{fig-expe1} and~\ref{fig-expe2} plots the raw execution times 
 versus the word length (in logarithmic scale)
while 
\figurename s~\ref{fig-ratio1}--\ref{fig-ratio3} shows execution time ratios
for LFAP over QLFAP.
Experiments were performed on alphabet sizes , ,  and , and input words of lengths , , \ldots, . 
For each alphabet size and word length,  words were randomly generated.

In order to verify the correct execution of both algorithms, words have been generated in such a way that they have at least one non trivial Abelian period. Both algorithms have been compiled with the same options and run on the same machine under the same conditions.

\begin{figure}

  \subfloat[]{\label{fig:2:5}
\includegraphics[width=5.5cm,angle=-90]{expe-2-5.eps}
  }\hspace{.3cm}
  \subfloat[]{\label{fig:5:5}
\includegraphics[width=5.5cm,angle=-90]{expe-5-5.eps}
}

  \subfloat[]{\label{fig:10:5}
\includegraphics[width=5.5cm,angle=-90]{expe-10-5.eps}
  }\hspace{.3cm}
  \subfloat[]{\label{fig:20:5}
\includegraphics[width=5.5cm,angle=-90]{expe-20-5.eps}
}
\caption{
\label{fig-expe1}
Running times of the LFAP and QLFAP algorithms for
 \protect\subref{fig:2:5} alphabet of size 2 and at least one non trivial Abelian period 5; 
 \protect\subref{fig:5:5} alphabet of size 5 and at least one non trivial Abelian period 5; 
 \protect\subref{fig:10:5} alphabet of size 10 and at least one non trivial Abelian period 5; 
 \protect\subref{fig:20:5} alphabet of size 20 and at least one non trivial Abelian period 5.
}
\end{figure}

\begin{figure}
  \subfloat[]{\label{fig:2:20}
\includegraphics[width=5.5cm,angle=-90]{expe-2-20.eps}
  }\hspace{.3cm}
  \subfloat[]{\label{fig:5:20}
\includegraphics[width=5.5cm,angle=-90]{expe-5-20.eps}
}

  \subfloat[]{\label{fig:10:20}
\includegraphics[width=5.5cm,angle=-90]{expe-10-20.eps}
  }\hspace{.3cm}
  \subfloat[]{\label{fig:20:20}
\includegraphics[width=5.5cm,angle=-90]{expe-20-20.eps}
}

\caption{
\label{fig-expe2}
Running times of the LFAP and QLFAP algorithms for
 \protect\subref{fig:2:20} alphabet of size 2 and at least one non trivial Abelian period 20; 
 \protect\subref{fig:5:20} alphabet of size 5 and at least one non trivial Abelian period 20; 
 \protect\subref{fig:10:20} alphabet of size 10 and at least one non trivial Abelian period 20; 
 \protect\subref{fig:20:20} alphabet of size 20 and at least one non trivial Abelian period 20.
}
\end{figure}

\begin{figure}
\begin{center}
\large{(A) period 5}
\scalebox{.78}{
\begin{tabular}{c*{11}{c|}}
\cline{3-12}
&&\multicolumn{10}{|c|}{Word length}\\
\cline{3-12}
&&{\small 1000}&{\small 2000}&{\small 3000}&{\small 4000}&{\small 5000}&{\small 6000}&{\small 7000}&{\small 8000}&{\small 9000}&{\small 10000}\\
\hline
\multicolumn{1}{|c|}{\multirow{4}{.4cm}{\rotatebox{90}{~Alphabet~}}}&\multicolumn{1}{|c|}{2} & 
7.90 &
9.64&
10.51&
11.50 &
11.45&
11.42&
12.02&
11.64&
11.38&
11.62
\\
\multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{5} & 
7.38 &
9.03&
9.50 &
10.32&
10.26 &
10.32 &
10.54&
10.38 &
10.34&
10.46
\\
\multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{10} & 
7.04&
8.28 &
8.67 &
9.37 &
9.03 &
9.13 &
9.55&
9.47&
9.33&
9.47
\\
\multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{20} & 
6.13&
6.66&
6.93&
7.08&
7.14 &
7.16 &
7.31 &
7.30&
7.18 &
7.20
\\
\hline
\end{tabular}
}
~\\
\large{(B) period 20}
\scalebox{.78}{
\begin{tabular}{c*{11}{c|}}
\cline{3-12}
&&\multicolumn{10}{|c|}{Word length}\\
\cline{3-12}
&&{\small 1000}&{\small 2000}&{\small 3000}&{\small 4000}&{\small 5000}&{\small 6000}&{\small 7000}&{\small 8000}&{\small 9000}&{\small 10000}\\
\hline
\multicolumn{1}{|c|}{\multirow{4}{.4cm}{\rotatebox{90}{~Alphabet~}}}&\multicolumn{1}{|c|}{2} & 
8.88 &
10.72 &
11.06 &
11.88 &
11.67&
11.87 &
12.32 &
12.48&
12.32&
12.90
\\
\multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{5} & 
11.33&
13.98 &
15.47 &
15.99 &
15.91 &
16.70 &
16.71 &
16.98&
16.57 &
16.77
\\
\multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{10} & 
10.93 &
13.30 &
14.45&
14.95&
14.69&
15.57&
15.62 &
15.90 &
15.44&
16.03
\\
\multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{20} & 
8.81 &
11.72 &
12.46&
12.74&
12.46&
13.06 &
13.07 &
13.17 &
13.35&
13.59
\\
\hline
\end{tabular}
}
\end{center}
\caption{\label{fig-ratio1}Execution time ratios for LFAP over QLFAP algorithms. 
 (A) Ratios computed on random words with at least one non trivial Abelian period 5. (B) Ratios computed on random words with at least one non trivial Abelian period 20.}
\end{figure}

\begin{figure}
\begin{center}
\large{(A) period 5}
\scalebox{.78}{
\begin{tabular}{c*{11}{c|}}
\cline{3-12}
&&\multicolumn{10}{|c|}{Word length}\\
\cline{3-12}
&&{\small 10000}&{\small 20000}&{\small 30000}&{\small 40000}&{\small 50000}&{\small 60000}&{\small 70000}&{\small 80000}&{\small 90000}&{\small 100000}\\
\hline
\multicolumn{1}{|c|}{\multirow{4}{.4cm}{\rotatebox{90}{~Alphabet~}}}&\multicolumn{1}{|c|}{2} & 
11.62&
12.38 &
12.32 &
15.82 &
15.86 &
15.84 &
16.27&
16.65 &
15.94&
16.72
\\
\multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{5} & 
10.46&
10.85 &
11.25&
13.67 &
13.84 &
13.90&
14.34&
14.31&
13.98 &
14.46
\\
\multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{10} & 
9.47 &
10.07 &
10.30&
11.86 &
11.86&
11.86&
12.13&
12.08&
11.86&
12.20
\\
\multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{20} & 
7.20 &
7.65&
7.71 &
8.54&
8.57&
8.59 &
8.71 &
9.24&
8.75&
8.92
\\
\hline
\end{tabular}
}
~\\
\large{(B) period 20}
\scalebox{.78}{
\begin{tabular}{c*{11}{c|}}
\cline{3-12}
&&\multicolumn{10}{|c|}{Word length}\\
\cline{3-12}
&&{\small 10000}&{\small 20000}&{\small 30000}&{\small 40000}&{\small 50000}&{\small 60000}&{\small 70000}&{\small 80000}&{\small 90000}&{\small 100000}\\
\hline
\multicolumn{1}{|c|}{\multirow{4}{.4cm}{\rotatebox{90}{~Alphabet~}}}&\multicolumn{1}{|c|}{2} & 
12.90 &
13.43&
13.44 &
17.00&
17.23&
17.46 &
17.63&
17.21&
18.37 &
18.10
\\
\multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{5} & 
16.77&
17.80 &
18.45 &
24.27&
24.58&
24.69 &
26.55 &
27.07 &
27.20 &
28.42
\\
\multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{10} & 
16.03&
16.50 &
17.17&
21.80&
22.46&
22.85 &
24.47&
25.31 &
25.09&
25.45
\\
\multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{20} & 
13.59 &
13.73 &
14.37 &
17.41&
18.27 &
18.49 &
19.43 &
19.07 &
19.02&
19.33
\\
\hline
\end{tabular}
}
\end{center}
\caption{\label{fig-ratio2}Execution time ratios for LFAP over QLFAP algorithms. 
 (A) Ratios computed on random words with at least one non trivial Abelian period 5. (B) Ratios computed on random words with at least one non trivial Abelian period 20.}
\end{figure}

\begin{figure}
\begin{center}
\large{(A) period 5}
\scalebox{.78}{
\begin{tabular}{c*{8}{c|}}
\cline{3-8}
&&\multicolumn{6}{|c|}{Word length}\\
\cline{3-8}
&&{\small 50000}&{\small 100000}&{\small 200000}&{\small 400000}&{\small 800000}&{\small 1600000}\\
\hline
\multicolumn{1}{|c|}{\multirow{4}{.4cm}{\rotatebox{90}{~Alphabet~}}}&\multicolumn{1}{|c|}{2} & 
15.86&16.72&17.87&19.29&19.50&20.35
\\
\multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{5} & 
13.84&14.42&15.44&16.24&16.99&17.66
\\
\multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{10} & 
11.86&12.20&12.88&13.89&14.44&15.08
\\
\multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{20} & 
8.54&8.92&9.53&9.34&10.07&10.57
\\
\hline
\end{tabular}
}
~\\
\large{(B) period 20}
\scalebox{.78}{
\begin{tabular}{c*{8}{c|}}
\cline{3-8}
&&\multicolumn{6}{|c|}{Word length}\\
\cline{3-8}
&&{\small 50000}&{\small 100000}&{\small 200000}&{\small 400000}&{\small 800000}&{\small 1600000}\\
\hline
\multicolumn{1}{|c|}{\multirow{4}{.4cm}{\rotatebox{90}{~Alphabet~}}}&\multicolumn{1}{|c|}{2} & 
17.23&18.10&20.04&20.82&21.49&23.39
\\
\multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{5} & 
24.58&29.42&30.21&30.76&31.16&34.13
\\
\multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{10} & 
22.46&25.45&27.84&29.42&28.33&31.23
\\
\multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{20} & 
18.27&19.33&21.17&22.05&22.42&24.45
\\
\hline
\end{tabular}
}
\end{center}
\caption{\label{fig-ratio3}Execution time ratios for LFAP over QLFAP algorithms. 
 (A) Ratios computed on random words with at least one non trivial Abelian period 5. (B) Ratios computed on random words with at least one non trivial Abelian period 20.}
\end{figure}

The plots show that, on the range of tested values, the two algorithms
 have a linear behaviour.
The results show that our algorithm is significantly faster than 
 \textsc{LinearFullAbelianPeriods} algorithm. 
One can also observe that the ratio increases both with word length
 and with the length of the Abelian period (see \figurename~\ref{fig-ratio3}).
This may be due to the larger number of arrays needed by the  \textsc{LinearFullAbelianPeriods} algorithm. 

Similar results were obtained with the \texttt{E.coli} file from the Canterbury Large Corpus
 (\figurename s~\ref{fig-expe-ecoli} and \ref{fig-ratio-ecoli}).

\begin{figure}
\centering{
  \subfloat[]{\label{fig:1000}
\includegraphics[width=5.5cm,angle=-90]{expe-ecoli.eps}
}
}
\caption{
\label{fig-expe-ecoli}
Running times of the LFAP and QLFAP algorithms for
the \texttt{E.coli} file from the Canterbury Large Corpus.
}
\end{figure}

\begin{figure}
\begin{center}
\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|}
\hline
Word length & {\small 1000}&{\small 2000}&{\small 3000}&{\small 4000}&{\small 5000}&{\small 6000}&{\small 7000}&{\small 8000}&{\small 9000}&{\small 10000}\\
\hline
Ratio &
19.72 &
24.79&
26.04 &
26.95&
25.23&
28.31 &
28.79 &
31.93&
30.24&
31.51
\\
\hline
\end{tabular}

\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|}
\hline
Word length &
{\small 20000}&{\small 30000}&{\small 40000}&{\small 50000}&{\small 60000}&{\small 70000}&{\small 80000}&{\small 90000}&{\small 100000}\\
\hline
Ratio &
34.75 &
37.10 &
95.35 &
101.73 &
102.57 &
107.82&
108.00&
116.06&
114.54
\\
\hline
\end{tabular}
\end{center}
\caption{\label{fig-ratio-ecoli}Execution time ratio between LFAP and QLFAP algorithms on
 words taken from the \texttt{E.coli} file from the Canterbury Large Corpus.
}
\end{figure}

The source codes of LFAP and QLFAP algorithms can be found at
 \url{bioinfo.univ-rouen.fr/qlfap}.

\section{Conclusions and perspectives}\label{sec-conc}


In this note we presented an algorithm for computing all the full Abelian periods of a word of length  in time  and space . We showed that this algorithm is very efficient in practice, even if its theoretical worst-case behavior is superlinear.

Our experiments show that it is between 6 to 19 times faster than the linear time algorithm of~\cite{KoRaRy13} and we can expect that the ratio will be even larger for longer strings.
Our method requires less space.
In addition the latter algorithm needs to compare real numbers, which can be tricky in practice, while
our method avoids this difficulty.
Furthermore, our algorithm is conceptually simple, and stems from the notion of scaled factorization of a word, which could be of some interest in other related problems on abelian combinatorics on words.

A possible direction of further investigation could be that of extending the same approach to the computation of all the abelian periods with empty head but non-empty tail, or even to compute the smallest of such abelian periods.

\section*{Acknowledgements}


The authors thank the anonymous reviewers that greatly improved a first version
 of this paper.        

\begin{thebibliography}{10}
\expandafter\ifx\csname url\endcsname\relax
  \def\url#1{\texttt{#1}}\fi
\expandafter\ifx\csname urlprefix\endcsname\relax\def\urlprefix{URL }\fi
\expandafter\ifx\csname href\endcsname\relax
  \def\href#1#2{#2} \def\path#1{#1}\fi

\bibitem{FiLeLePrSm12}
G.~Fici, T.~Lecroq, A.~Lefebvre, E.~Prieur-Gaston, W.~F. Smyth, Quasi-linear
  time computation of the {A}belian periods of a word, in: J.~Holub,
  J.~Zd{\'a}rek (Eds.), Prague Stringology Conference, {PSC} 2012. Prague,
  Czech Republic, August 27--28, 2012. Proceedings, Czech Technical University
  in Prague, 2012, pp. 103--110.

\bibitem{Cummings_weakrepetitions}
L.~J. Cummings, W.~F. Smyth, Weak repetitions in strings, {Journal of
  Combinatorial Mathematics and Combinatorial Computing} 24 (1997) 33--48.

\bibitem{CI2006}
S.~Constantinescu, L.~Ilie, {F}ine and {W}ilf's theorem for abelian periods,
  Bulletin of the European Association for Theoretical Computer Science 89
  (2006) 167--170.

\bibitem{DAM}
G.~Fici, T.~Lecroq, A.~Lefebvre, {\'{E}}.~Prieur-Gaston, Algorithms for
  computing {A}belian periods of words, Discrete Applied Mathematics 163 (2014)
  287--297.

\bibitem{PSC2011-16}
G.~Fici, T.~Lecroq, A.~Lefebvre, {\'{E}}.~Prieur-Gaston, Computing {A}belian
  periods in words, in: J.~Holub, J.~{\v{Z}}{\v{d}}{\'{a}}rek (Eds.),
  Proceedings of the Prague Stringology Conference 2011, Czech Technical
  University in Prague, Czech Republic, 2011, pp. 184--196.

\bibitem{MichalisChrist2012}
M.~Christou, M.~Crochemore, C.~S. Iliopoulos, Identifying all abelian periods
  of a string in quadratic time and relevant problems, International Journal of
  Foundations of Computer Science 23~(6) (2012) 1371--1384.

\bibitem{CIKKPRRTW2012}
M.~Crochemore, C.~Iliopoulos, T.~Kociumaka, M.~Kubica, J.~Pachocki,
  J.~Radoszewski, W.~Rytter, W.~Tyczy\'nski, T.~Wale\'n, A note on efficient
  computation of all abelian periods in a string, Information Processing
  Letters 113~(3) (2013) 74--77.

\bibitem{KoRaRy13}
T.~Kociumaka, J.~Radoszewski, W.~Rytter, Fast algorithms for abelian periods in
  words and greatest common divisor queries, in: Proc.~of {STACS}, 2013, pp.
  245--256, available from http://stacs-conf.org.

\bibitem{Bradley1970}
G.~Bradley, Algorithm and bound for the greatest common divisor of 
  integers, Comm. ACM 13~(7) (1970) 433--436.

\bibitem{gronwall}
T.~H. Gronwall, Some asymptotic expressions in the theory of numbers,
  Transactions of the American Mathematical Society 14 (1913) 113--122.

\end{thebibliography}


\end{document}
