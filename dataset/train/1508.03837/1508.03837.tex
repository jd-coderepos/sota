\documentclass[12pt]{article}


\title{}

\makeatletter
\long\def\@makemyfntext#1{ #1}

\long\def\@myfootnotetext#1{\insert\footins{\footnotesize
    \interlinepenalty\interfootnotelinepenalty 
    \splittopskip\footnotesep
    \splitmaxdepth \dp\strutbox \floatingpenalty \@MM
    \hsize\columnwidth \@parboxrestore
   \edef\@currentlabel{\csname p@footnote\endcsname\@thefnmark}\@makemyfntext
    {\rule{\z@}{\footnotesep}\ignorespaces
      #1\strut}}}

\def\myfootnotetext{\@ifnextchar
     [{\@xfootnotenext}{\xdef\@thefnmark{\thempfn}\@myfootnotetext}}
\makeatother



\newenvironment{describe}{\begin{list}{}{\setlength\leftmargin{80pt}}\setlength\labelsep{10pt}\setlength\labelwidth{70pt}}{\end{list}}

\newenvironment{flag}{\begin{list}{\makebox[20pt]{\hss\enspace}}
                                  {\labelwidth 20pt}}{\end{list}}





\newenvironment{numberedlist}
{\begin{list}{\makebox[20pt]{\hss(\arabic{itemno})\enspace}}
             {\usecounter{itemno}\labelwidth 20pt}}{\end{list}}

\newenvironment{alphabetlist}
{\begin{list}{\makebox[20pt]{\hss(\alph{itemno1})\enspace}}
             {\usecounter{itemno1}\labelwidth 20pt}}{\end{list}}

\newenvironment{romanlist}
{\begin{list}{\makebox[20pt]{\hss(\roman{itemno2})\enspace}}
             {\usecounter{itemno2}\labelwidth 20pt}}{\end{list}}

\newcounter{itemno}

\newcounter{itemno1}

\newcounter{itemno2}
\newcounter{lemma}
\newcounter{exno}

\newcounter{defno}













\newenvironment{defn}{\refstepcounter{defno}\medskip \noindent {\bf
Definition \thedefno.\ }}{\medskip}

\newenvironment{ex}{\refstepcounter{exno}\medskip \noindent {\bf
Example \theexno.\ }}{\medskip} 













\newenvironment{millerexample}{
 \begingroup \begin{tabbing} \hspace{2em}\= \hspace{5em}\= \hspace{5em}\=
\hspace{5em}\= \kill}{
 \end{tabbing}\endgroup}

\newenvironment{wideexample}{
 \begingroup \begin{tabbing} \hspace{2em}\= \hspace{10em}\= \hspace{10em}\=
\hspace{10em}\= \kill}{
 \end{tabbing}\endgroup}

\newcommand{\sep}{\;\vert\;}

\newcommand{\ra}{\rightarrow}
\newcommand{\app}{\ }
\newcommand{\appt}{\ }
\newcommand{\tup}[1]{\langle\nobreak#1\nobreak\rangle}

\newcommand{\hu}{{\cal H}^+}
\newcommand{\Free}{{\cal F}}
\newcommand{\oprove}{\vdash\kern-.6em\lower.7ex\hbox{}\,}
\newcommand{\true}{\top}

\newcommand{\Dscr}{{\cal D}}
\newcommand{\Pscr}{{\cal P}}
\newcommand{\Gscr}{{\cal G}}
\newcommand{\Fscr}{{\cal F}}
\newcommand{\Vscr}{{\cal V}}
\newcommand{\Uscr}{{\cal U}}
\newcommand{\pderivation}{{\cal P}\kern -.1em\hbox{\rm -derivation}}
\newcommand{\pderivationl}{{\cal P}\kern -.1em\hbox{\em -derivation}}
\newcommand{\pderivable}{{\cal P}\kern -.1em\hbox{\rm -derivable}}
\newcommand{\pderivablel}{{\cal P}\kern -.1em\hbox{\em -derivable}}
\newcommand{\pderivations}{{\cal P}\kern -.1em\hbox{\rm -derivations}}
\newcommand{\pderivability}{{\cal P}\kern -.1em\hbox{\rm -derivability}}
\newcommand{\eqm}[1]{=_{\scriptscriptstyle #1}}
\newcommand\subsl{\preceq}
\newcommand{\fnrestr}{\uparrow}

\newcommand{\match}{{\rm MATCH}}
\newcommand{\triv}{{\rm TRIV}}
\newcommand{\imit}{{\rm IMIT}}
\newcommand{\proj}{{\rm PROJ}}
\newcommand{\simpl}{{\rm SIMPL}}
\newcommand{\failed}{{\bf F}}

\newcommand{\Dsiginst}[1]{{[#1]_\Sigma}}
\newcommand{\Psiginst}[1]{{[#1]_\Sigma}}
\newcommand{\lnorm}{{\lambda}norm}
\newcommand{\seq}[2]{#1 \supset #2}
\newcommand{\dseq}[2]{#1_1,\ldots,#1_{#2}}

\newcommand{\all}{\forall}
\newcommand{\some}{\exists}
\newcommand{\lambdax}[1]{\lambda #1\,}
\newcommand{\somex}[1]{\some#1\,}
\newcommand\allx[1]{\all#1\,}

\newcommand{\subs}[3]{[#1/#2]#3}
\newcommand{\rep}[3]{S^{#2}_{#1}{#3}}
\newcommand{\ie}{{\em i.e.}}
\newcommand{\eg}{{\em e.g.}}

\newcommand{\lbotr}{-R}
\newcommand{\ldbotr}{\bot\mbox{\rm -R}}
\newcommand{\landl}{-L}
\newcommand{\ldandl}{\land\mbox{\rm -L}}
\newcommand{\landr}{-R}
\newcommand{\ldandr}{\land\mbox{\rm -R}}
\newcommand{\lorl}{-L}
\newcommand{\ldorl}{\lor\mbox{\rm -L}}
\newcommand{\lorr}{-R}
\newcommand{\ldorr}{\lor\mbox{\rm -R}}
\newcommand{\limpl}{-L}
\newcommand{\ldimpl}{\supset\mbox{\rm -L}}
\newcommand{\limpr}{-R}
\newcommand{\ldimpr}{\supset\mbox{\rm -R}}
\newcommand{\lnegl}{-L}
\newcommand{\ldnegl}{\neg\mbox{\rm -L}}
\newcommand{\ldnegr}{\neg\mbox{\rm -R}}
\newcommand{\lalll}{-L}
\newcommand{\ldalll}{\forall\mbox{\rm -L}}
\newcommand{\lallr}{-R}
\newcommand{\ldallr}{\forall\mbox{\rm -R}}
\newcommand{\lsomel}{-L}
\newcommand{\ldsomel}{\exists\mbox{\rm -L}}
\newcommand{\lsomer}{-R}
\newcommand{\ldsomer}{\exists\mbox{\rm -R}}
\newcommand{\ldlamlr}{\lambda}
\newcommand{\sequent}[2]{\hbox{{}}}
\newcommand{\prog}[2]{\hbox{{}}}
\newcommand{\run}{\Gamma}


\newcommand{\Ibf}{{\bf I}}
\newcommand{\Cbf}{{\bf C}} 
\newcommand{\Cbfpr}{{\bf C'}}

\newcommand{\cprove}{\vdash_C}
\newcommand{\iprove}{\vdash_I}

\newsavebox{\lpartfig}
\newsavebox{\rpartfig}




\newenvironment{exmple}{
 \begingroup \begin{tabbing} \hspace{2em}\= \hspace{3em}\= \hspace{3em}\=
\hspace{3em}\= \hspace{3em}\= \hspace{3em}\= \kill}{
 \end{tabbing}\endgroup}
\newenvironment{example2}{
 \begingroup \begin{tabbing} \hspace{8em}\= \hspace{2em}\= \hspace{2em}\=
\hspace{10em}\= \hspace{2em}\= \hspace{2em}\= \hspace{2em}\= \kill}{
 \end{tabbing}\endgroup}

\newenvironment{example}{
\begingroup  \begin{tabbing} \hspace{2em}\= \hspace{3em}\= \hspace{3em}\=
\hspace{3em}\= \hspace{3em}\= \hspace{3em}\= \hspace{3em}\= \hspace{3em}\= 
\hspace{3em}\= \hspace{3em}\= \hspace{3em}\= \hspace{3em}\= \kill}{
 \end{tabbing} \endgroup }


\newcommand{\sand}{sand} \newcommand{\pand}{pand} \newcommand{\cor}{cor} 

\newcommand{\lb}{\langle}
\newcommand{\rb}{\rangle}
\newcommand{\pr}{prov}
\newcommand{\prG}{intp}
\newcommand{\prSG}{intp_E}
\newcommand{\intp}{intp_o}
\newcommand{\prove}{exec} \newcommand{\np}{invalid} \newcommand{\Ra}{\supset}  
\newcommand{\add}{\oplus} \newcommand{\adc}{\&} \newcommand{\Cscr}{{\cal C}}
\newcommand{\seqweb}{SProlog}
\newcommand{\sprog}{{SProlog}}

\newtheorem{theorem}[lemma]{Theorem}

\newtheorem{proposition}[lemma]{Proposition}

\newtheorem{corollary}[lemma]{Corollary}
\newenvironment{proof}
     {\begin{trivlist}\item[]{\it Proof. }}{\\* \hspace*{\fill} \end{trivlist}}

\newcommand{\seqand}{\prec}
\newcommand{\seqor}{\cup}
\newcommand{\seqandq}[2]{\prec_{#1}^{#2}}
\newcommand{\parandq}[2]{\land_{#1}^{#2}}
\newcommand{\exq}[2]{\exists_{#1}^{#2}}
\newcommand{\ext}{intp_G} 
\newcommand{\muprolog}{{Java}}
\newcommand{\uch}{kchoose}
\newcommand{\kch}{kchoose}
\renewcommand{\pr}{ex}
\renewcommand{\prove}{ex} 



\begin{document}
	
\begin{center}
{\Large {\bf 
Incorporating  User Interaction  into Imperative  Languages}}
\20pt] 
Keehang Kwon \\
khkwon@dau.ac.kr
\end{center}
	
\noindent {\bf Abstract}: 
In this paper, we  present two new forms of the  statement: one  of the form 
where  is a statement and the other of the form  where  is a module.
The former is a generalization of traditional  statement and is
quite useful.  The latter is useful for implementing interactive modules.








\section{Introduction}\label{sec:intro}

In this article, we describe a variant of C with some features that are 
inspired by the work of \cite{Jap03}.
These features include

\begin{numberedlist}

\item A  statement dual to the  statement which has the form of
     . This statement  has the following  semantics: the machine finds
    a value  for  so that the statement   can be successfully completed.

\item A  module of the form  where  is a set of procedure declarations.
This  statement  has the following interchanged semantics:  the  chooses 
    a value  for .

\end{numberedlist}

The notion of interactive methods/modules is quite indispensable in modern imperative languages. 
Interactive  methods interact with the environment, therefore providing some form of 
interactive computing. This paper aims to achieve interaction by providing {\it interactive modules}
 to imperative languages. Thus we allow, within a module, declarations of the form  where  is a variable.
 The intended meaning is that  the value of  is obtained dynamically from the environment.
  To see the usefulness of interactive modules, let us consider the following method which produces the mobile phone number of each employee.

\begin{example}
	write(y); \\
	phone(x) = 		\\
	\>	case Tom : number = 8375;\\
	\>	case Jill : number = 2312;\\
	\>	case Kim : number = y;
\end{example}

In the above, the variable   - which is Kim's Phone - will be obtained at run time by
requesting the environment to type in Kim's phone number.


Implementing our language poses no serious problem.
 In this paper, we introduce one 
 way of implementing interaction.
Our implementation scheme is the following; when a module is loaded, the variables in the 
statements   will be replaced by the input values typed in by the environment.


\section{The Language}\label{sec:logic}

The language is a subset of the core (untyped) C
 with some extensions. It is described
by -, - and -formulas given by the syntax rules below:
\begin{exmple}
\> \>    \\  
\> \>  \\
\> \>  \\
\end{exmple}
\noindent
 In the above, 
  represents a head of an atomic procedure definition of the form . 
A -formula is a set
of procedure declarations. A -formula is an {\it interactive module}.

In the transition system to be considered, a -formula will function as a statement 
and an   -formula  enhanced with the
machine state (a set of variable-value bindings) will constitute  a program.
Thus, a program is a pair   
where   represents the machine state.
 is initially  empty  and will be updated dynamically during execution
via the assignment statements. 

 We will  present an interpreter for our language via a proof theory \cite{Khan87,MNPS91}.
 Note that in the initialization phase (denoted by ), our interpreter
 replaces all the variables in  in 
 with new input values from the environment. 
After that, our interpreter proceeds like traditional C interpreter.
 To be specific, it alternates between 
 the  execution phase 
and the backchaining phase.  
In  the  execution phase (denoted by ), it  
executes a statement   with respect to
  and
produce a new program 
by reducing  
to simpler forms. The rules
(6)-(9) deal with this phase.
If  becomes a procedure call, the machine switches to the backchaining mode. This is encoded in the rule (5). 
In the backchaining mode (denoted by ), the interpreter tries 
to find a matching procedure  for a procedure call  inside the module 
 by decomposing  into a smaller unit (via rule (4)-(5)) and
 reducing  to  its instance
 (via rule (2)) and then backchaining on the resulting 
definition (via rule (1)).
 To be specific, the rule (2) basically deals with argument passing: it eliminates the universal quantifier  in 
by picking a value  for
 so that the resulting instantiation,  , matches the procedure call .
The notation \ seqand\  denotes the  sequential execution of two tasks. To be precise, it denotes
the following: execute  and execute
 sequentially. It is considered a success if both executions succeed.
Similarly, the notation \ parand\  denotes the  parallel execution of two tasks. To be precise, it denotes
the following: execute  and execute
  in any order.  It is considered a success if both executions succeed.
The notation  denotes  reverse implication, \ie, .





\begin{defn}\label{def:semantics}
Let  be a statement and let  be a program.
Then the notion of   executing  and producing a new
program --  --
 is defined as follows:

\begin{numberedlist}




\item      \\
 . \% A matching procedure for  is found.

\item      \\
  . \% argument passing

\item      \\
  . \% look for  a matching procedure in .

\item      \\
  . \% look for a matching procedure in 


\item         . \%  is a procedure call 

\item  . \% True is always a success.





\item   . \\
 \% In the assignment statement, it evaluates  to get .
  The symbol
 denotes a set union but  in  will be replaced by .

\item   \\
    seqand  .
\%  a sequential composition 

\item   \\
  choose (and print) a value  for  so that  .
\%  write statement 

\item    \\
    seqand .  \%
  In the initialization phase,  each  is replaced with a new input value  typed by the
environment.


\end{numberedlist}
\end{defn}

\noindent
If  has no derivation, then the interpreter returns  the failure.
The rule (9)  deals with the new feature. 


\section{Examples }\label{sec:modules}

The following  code displays the employee's age to be determined at run time.

\begin{exmple}
 write(y1); \\
 write(y2); \\
 write(y3); \\
 age(x) =  \\
  \>      switch (x) \{ \\
 \>           case tom:  age = y1;   break; \\
  \>          case kim: age = y2;   break;\\
 \>           case sue: age = y3;    break;\\
 \>           default: age = 0;          \\
        \}\\
\end{exmple}

Now consider the procedure call age(tom). The above code will be changed to the one below in the initialization phase assuming
the environment typed in 30,40,22 for y1,y2,y3 respectively.

\begin{exmple}
 age(x) =  \\
\>        switch (x) \{ \\
 \>           case tom:  age = 30;   break; \\
  \>          case kim: age = 40;   break;\\
 \>           case sue: age = 22;    break;\\
 \>           default: age = 0;          \\
        \}\\
\end{exmple}


\noindent Then execution proceeds in the usual way.




\section{Conclusion}\label{sec:conc}

In this paper, we have presented a new form of the  statement of the form .
This statement is a generalization of traditional write statement 
, as we can write the latter as . Here we assume that
 we allow boolean expressions as statements.
In addition, we have presented a notion of  interactive
 modules.  The notion of interactive modules is an indispensable tool in
modern interactive programming.

\section{Acknowledgements}

This work  was supported by Dong-A University Research Fund.

\bibliographystyle{ieicetr}
\begin{thebibliography}{1}

\bibitem{Khan87}
G.~Kahn,  ``Natural Semantics'', In the 4th Annual Symposium on Theoretical Aspects of Computer Science, 
LNCS vol. 247,  1987.



\bibitem{Jap03}
G.~Japaridze, ``Introduction to computability logic'', Annals  of Pure and
 Applied  Logic, vol.123, pp.1--99, 2003.

\bibitem{Jap08}
G.~Japaridze,   ``Sequential operators in computability logic'',
 Information and Computation, vol.206, No.12, pp.1443-1475, 2008.  

\bibitem{KHP13}
K.~Kwon, S.~Hur and M.~Park,  ``Improving Robustness via Disjunctive Statements in Imperative  Programming'', IEICE Transations on Information and Systems, vol.E96-D,No.9, pp.2036-2038, September, 2013.  

\bibitem{HM94}
J.~Hodas and D.~Miller,   ``Logic Programming in a Fragment of Intuitionistic Linear Logic'', 
 Information and Computation, vol.110, No.2, pp.327-365, 1994. 



\bibitem{MNPS91}
D.~Miller, G.~Nadathur, F.~Pfenning, and A.~Scedrov, ``Uniform proofs as a
  foundation for logic programming'', Annals of Pure and Applied Logic, vol.51,
  pp.125--157, 1991.

\bibitem{MN12}
D.~Miller, G.~Nadathur, Programming with higher-order logic, Cambridge University Press,   2012.
\end{thebibliography}







\end{document}
