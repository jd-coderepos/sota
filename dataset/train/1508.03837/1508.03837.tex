\documentclass[12pt]{article}


\title{}

\makeatletter
\long\def\@makemyfntext#1{$^{\rm *}\ $ #1}

\long\def\@myfootnotetext#1{\insert\footins{\footnotesize
    \interlinepenalty\interfootnotelinepenalty 
    \splittopskip\footnotesep
    \splitmaxdepth \dp\strutbox \floatingpenalty \@MM
    \hsize\columnwidth \@parboxrestore
   \edef\@currentlabel{\csname p@footnote\endcsname\@thefnmark}\@makemyfntext
    {\rule{\z@}{\footnotesep}\ignorespaces
      #1\strut}}}

\def\myfootnotetext{\@ifnextchar
     [{\@xfootnotenext}{\xdef\@thefnmark{\thempfn}\@myfootnotetext}}
\makeatother



\newenvironment{describe}{\begin{list}{}{\setlength\leftmargin{80pt}}\setlength\labelsep{10pt}\setlength\labelwidth{70pt}}{\end{list}}

\newenvironment{flag}{\begin{list}{\makebox[20pt]{\hss$\circ$\enspace}}
                                  {\labelwidth 20pt}}{\end{list}}





\newenvironment{numberedlist}
{\begin{list}{\makebox[20pt]{\hss(\arabic{itemno})\enspace}}
             {\usecounter{itemno}\labelwidth 20pt}}{\end{list}}

\newenvironment{alphabetlist}
{\begin{list}{\makebox[20pt]{\hss(\alph{itemno1})\enspace}}
             {\usecounter{itemno1}\labelwidth 20pt}}{\end{list}}

\newenvironment{romanlist}
{\begin{list}{\makebox[20pt]{\hss(\roman{itemno2})\enspace}}
             {\usecounter{itemno2}\labelwidth 20pt}}{\end{list}}

\newcounter{itemno}

\newcounter{itemno1}

\newcounter{itemno2}
\newcounter{lemma}
\newcounter{exno}

\newcounter{defno}













\newenvironment{defn}{\refstepcounter{defno}\medskip \noindent {\bf
Definition \thedefno.\ }}{\medskip}

\newenvironment{ex}{\refstepcounter{exno}\medskip \noindent {\bf
Example \theexno.\ }}{\medskip} 













\newenvironment{millerexample}{
 \begingroup \begin{tabbing} \hspace{2em}\= \hspace{5em}\= \hspace{5em}\=
\hspace{5em}\= \kill}{
 \end{tabbing}\endgroup}

\newenvironment{wideexample}{
 \begingroup \begin{tabbing} \hspace{2em}\= \hspace{10em}\= \hspace{10em}\=
\hspace{10em}\= \kill}{
 \end{tabbing}\endgroup}

\newcommand{\sep}{\;\vert\;}

\newcommand{\ra}{\rightarrow}
\newcommand{\app}{\ }
\newcommand{\appt}{\ }
\newcommand{\tup}[1]{\langle\nobreak#1\nobreak\rangle}

\newcommand{\hu}{{\cal H}^+}
\newcommand{\Free}{{\cal F}}
\newcommand{\oprove}{\vdash\kern-.6em\lower.7ex\hbox{$\scriptstyle O$}\,}
\newcommand{\true}{\top}

\newcommand{\Dscr}{{\cal D}}
\newcommand{\Pscr}{{\cal P}}
\newcommand{\Gscr}{{\cal G}}
\newcommand{\Fscr}{{\cal F}}
\newcommand{\Vscr}{{\cal V}}
\newcommand{\Uscr}{{\cal U}}
\newcommand{\pderivation}{{\cal P}\kern -.1em\hbox{\rm -derivation}}
\newcommand{\pderivationl}{{\cal P}\kern -.1em\hbox{\em -derivation}}
\newcommand{\pderivable}{{\cal P}\kern -.1em\hbox{\rm -derivable}}
\newcommand{\pderivablel}{{\cal P}\kern -.1em\hbox{\em -derivable}}
\newcommand{\pderivations}{{\cal P}\kern -.1em\hbox{\rm -derivations}}
\newcommand{\pderivability}{{\cal P}\kern -.1em\hbox{\rm -derivability}}
\newcommand{\eqm}[1]{=_{\scriptscriptstyle #1}}
\newcommand\subsl{\preceq}
\newcommand{\fnrestr}{\uparrow}

\newcommand{\match}{{\rm MATCH}}
\newcommand{\triv}{{\rm TRIV}}
\newcommand{\imit}{{\rm IMIT}}
\newcommand{\proj}{{\rm PROJ}}
\newcommand{\simpl}{{\rm SIMPL}}
\newcommand{\failed}{{\bf F}}

\newcommand{\Dsiginst}[1]{{[#1]_\Sigma}}
\newcommand{\Psiginst}[1]{{[#1]_\Sigma}}
\newcommand{\lnorm}{{\lambda}norm}
\newcommand{\seq}[2]{#1 \supset #2}
\newcommand{\dseq}[2]{#1_1,\ldots,#1_{#2}}

\newcommand{\all}{\forall}
\newcommand{\some}{\exists}
\newcommand{\lambdax}[1]{\lambda #1\,}
\newcommand{\somex}[1]{\some#1\,}
\newcommand\allx[1]{\all#1\,}

\newcommand{\subs}[3]{[#1/#2]#3}
\newcommand{\rep}[3]{S^{#2}_{#1}{#3}}
\newcommand{\ie}{{\em i.e.}}
\newcommand{\eg}{{\em e.g.}}

\newcommand{\lbotr}{$\bot$-R}
\newcommand{\ldbotr}{\bot\mbox{\rm -R}}
\newcommand{\landl}{$\land$-L}
\newcommand{\ldandl}{\land\mbox{\rm -L}}
\newcommand{\landr}{$\land$-R}
\newcommand{\ldandr}{\land\mbox{\rm -R}}
\newcommand{\lorl}{$\lor$-L}
\newcommand{\ldorl}{\lor\mbox{\rm -L}}
\newcommand{\lorr}{$\lor$-R}
\newcommand{\ldorr}{\lor\mbox{\rm -R}}
\newcommand{\limpl}{$\supset$-L}
\newcommand{\ldimpl}{\supset\mbox{\rm -L}}
\newcommand{\limpr}{$\supset$-R}
\newcommand{\ldimpr}{\supset\mbox{\rm -R}}
\newcommand{\lnegl}{$\neg$-L}
\newcommand{\ldnegl}{\neg\mbox{\rm -L}}
\newcommand{\ldnegr}{\neg\mbox{\rm -R}}
\newcommand{\lalll}{$\forall$-L}
\newcommand{\ldalll}{\forall\mbox{\rm -L}}
\newcommand{\lallr}{$\forall$-R}
\newcommand{\ldallr}{\forall\mbox{\rm -R}}
\newcommand{\lsomel}{$\exists$-L}
\newcommand{\ldsomel}{\exists\mbox{\rm -L}}
\newcommand{\lsomer}{$\exists$-R}
\newcommand{\ldsomer}{\exists\mbox{\rm -R}}
\newcommand{\ldlamlr}{\lambda}
\newcommand{\sequent}[2]{\hbox{{$#1\ \longrightarrow\ #2$}}}
\newcommand{\prog}[2]{\hbox{{$#1\ \supset\ #2$}}}
\newcommand{\run}{\Gamma}


\newcommand{\Ibf}{{\bf I}}
\newcommand{\Cbf}{{\bf C}} 
\newcommand{\Cbfpr}{{\bf C'}}

\newcommand{\cprove}{\vdash_C}
\newcommand{\iprove}{\vdash_I}

\newsavebox{\lpartfig}
\newsavebox{\rpartfig}




\newenvironment{exmple}{
 \begingroup \begin{tabbing} \hspace{2em}\= \hspace{3em}\= \hspace{3em}\=
\hspace{3em}\= \hspace{3em}\= \hspace{3em}\= \kill}{
 \end{tabbing}\endgroup}
\newenvironment{example2}{
 \begingroup \begin{tabbing} \hspace{8em}\= \hspace{2em}\= \hspace{2em}\=
\hspace{10em}\= \hspace{2em}\= \hspace{2em}\= \hspace{2em}\= \kill}{
 \end{tabbing}\endgroup}

\newenvironment{example}{
\begingroup  \begin{tabbing} \hspace{2em}\= \hspace{3em}\= \hspace{3em}\=
\hspace{3em}\= \hspace{3em}\= \hspace{3em}\= \hspace{3em}\= \hspace{3em}\= 
\hspace{3em}\= \hspace{3em}\= \hspace{3em}\= \hspace{3em}\= \kill}{
 \end{tabbing} \endgroup }


\newcommand{\sand}{sand} \newcommand{\pand}{pand} \newcommand{\cor}{cor} 

\newcommand{\lb}{\langle}
\newcommand{\rb}{\rangle}
\newcommand{\pr}{prov}
\newcommand{\prG}{intp}
\newcommand{\prSG}{intp_E}
\newcommand{\intp}{intp_o}
\newcommand{\prove}{exec} \newcommand{\np}{invalid} \newcommand{\Ra}{\supset}  
\newcommand{\add}{\oplus} \newcommand{\adc}{\&} \newcommand{\Cscr}{{\cal C}}
\newcommand{\seqweb}{SProlog}
\newcommand{\sprog}{{SProlog}}

\newtheorem{theorem}[lemma]{Theorem}

\newtheorem{proposition}[lemma]{Proposition}

\newtheorem{corollary}[lemma]{Corollary}
\newenvironment{proof}
     {\begin{trivlist}\item[]{\it Proof. }}{\\* \hspace*{\fill} \end{trivlist}}

\newcommand{\seqand}{\prec}
\newcommand{\seqor}{\cup}
\newcommand{\seqandq}[2]{\prec_{#1}^{#2}}
\newcommand{\parandq}[2]{\land_{#1}^{#2}}
\newcommand{\exq}[2]{\exists_{#1}^{#2}}
\newcommand{\ext}{intp_G} 
\newcommand{\muprolog}{{Java$^{BI}$}}
\newcommand{\uch}{kchoose}
\newcommand{\kch}{kchoose}
\renewcommand{\pr}{ex}
\renewcommand{\prove}{ex} 



\begin{document}
	
\begin{center}
{\Large {\bf 
Incorporating  User Interaction  into Imperative  Languages}}
\\[20pt] 
Keehang Kwon \\
khkwon@dau.ac.kr
\end{center}
	
\noindent {\bf Abstract}: 
In this paper, we  present two new forms of the $write$ statement: one  of the form $write(x);G$
where $G$ is a statement and the other of the form $write(x);D$ where $D$ is a module.
The former is a generalization of traditional $write$ statement and is
quite useful.  The latter is useful for implementing interactive modules.








\section{Introduction}\label{sec:intro}

In this article, we describe a variant of C with some features that are 
inspired by the work of \cite{Jap03}.
These features include

\begin{numberedlist}

\item A $write$ statement dual to the $read$ statement which has the form of
     $write(x); G$. This statement  has the following $new$ semantics: the machine finds
    a value $v$ for $x$ so that the statement $G$  can be successfully completed.

\item A $interactive$ module of the form $write(x); D$ where $D$ is a set of procedure declarations.
This $write$ statement  has the following interchanged semantics:  the $user$ chooses 
    a value $v$ for $x$.

\end{numberedlist}

The notion of interactive methods/modules is quite indispensable in modern imperative languages. 
Interactive  methods interact with the environment, therefore providing some form of 
interactive computing. This paper aims to achieve interaction by providing {\it interactive modules}
 to imperative languages. Thus we allow, within a module, declarations of the form $write(x)$ where $x$ is a variable.
 The intended meaning is that  the value of $x$ is obtained dynamically from the environment.
  To see the usefulness of interactive modules, let us consider the following method which produces the mobile phone number of each employee.

\begin{example}
	write(y); \\
	phone(x) = 		\\
	\>	case Tom : number = 8375;\\
	\>	case Jill : number = 2312;\\
	\>	case Kim : number = y;
\end{example}

In the above, the variable  $y$ - which is Kim's Phone - will be obtained at run time by
requesting the environment to type in Kim's phone number.


Implementing our language poses no serious problem.
 In this paper, we introduce one 
 way of implementing interaction.
Our implementation scheme is the following; when a module is loaded, the variables in the $write$
statements   will be replaced by the input values typed in by the environment.


\section{The Language}\label{sec:logic}

The language is a subset of the core (untyped) C
 with some extensions. It is described
by $G$-, $D$- and $E$-formulas given by the syntax rules below:
\begin{exmple}
\>$G ::=$ \>   $true \sep A \sep x = exp \sep  G;G  \sep write(x);G$ \\  
\>$D ::=$ \>  $ A = G\ \sep \all x\ D \sep D \land D $\\
\>$E ::=$ \>  $ D \sep write(x); E$\\
\end{exmple}
\noindent
 In the above, 
$A$  represents a head of an atomic procedure definition of the form $p(x_1,\ldots,x_n)$. 
A $D$-formula is a set
of procedure declarations. A $E$-formula is an {\it interactive module}.

In the transition system to be considered, a $G$-formula will function as a statement 
and an   $E$-formula  enhanced with the
machine state (a set of variable-value bindings) will constitute  a program.
Thus, a program is a pair   $\lb  E,  \theta\rb$
where  $\theta$ represents the machine state.
$\theta$ is initially  empty  and will be updated dynamically during execution
via the assignment statements. 

 We will  present an interpreter for our language via a proof theory \cite{Khan87,MNPS91}.
 Note that in the initialization phase (denoted by $exec(\Pscr,G,\Pscr')$), our interpreter
 replaces all the variables in $write$ in $\Pscr$
 with new input values from the environment. 
After that, our interpreter proceeds like traditional C interpreter.
 To be specific, it alternates between 
 the  execution phase 
and the backchaining phase.  
In  the  execution phase (denoted by $ex(\Pscr,G,\Pscr')$), it  
executes a statement $G$  with respect to
 $\Pscr$ and
produce a new program $\Pscr'$
by reducing $G$ 
to simpler forms. The rules
(6)-(9) deal with this phase.
If $G$ becomes a procedure call, the machine switches to the backchaining mode. This is encoded in the rule (5). 
In the backchaining mode (denoted by $bc(D,\Pscr,A,\Pscr')$), the interpreter tries 
to find a matching procedure  for a procedure call $A$ inside the module $D$
 by decomposing $D$ into a smaller unit (via rule (4)-(5)) and
 reducing $D$ to  its instance
 (via rule (2)) and then backchaining on the resulting 
definition (via rule (1)).
 To be specific, the rule (2) basically deals with argument passing: it eliminates the universal quantifier $x$ in $\all x D$
by picking a value $t$ for
$x$ so that the resulting instantiation,  $[t/x]D$, matches the procedure call $A$.
The notation $S$\ seqand\ $R$ denotes the  sequential execution of two tasks. To be precise, it denotes
the following: execute $S$ and execute
$R$ sequentially. It is considered a success if both executions succeed.
Similarly, the notation $S$\ parand\ $R$ denotes the  parallel execution of two tasks. To be precise, it denotes
the following: execute $S$ and execute
$R$  in any order.  It is considered a success if both executions succeed.
The notation $S \leftarrow R$ denotes  reverse implication, \ie, $R \rightarrow S$.





\begin{defn}\label{def:semantics}
Let $G$ be a statement and let $\Pscr$ be a program.
Then the notion of   executing $\lb \Pscr,G \rb$ and producing a new
program $\Pscr'$-- $exec(\Pscr,G,\Pscr')$ --
 is defined as follows:

\begin{numberedlist}




\item    $bc((A = G_1),\Pscr,A,\Pscr_1)\ \leftarrow$  \\
 $ex(\Pscr,G_1,\Pscr_1)$. \% A matching procedure for $A$ is found.

\item    $bc(\all x D,\Pscr,A,\Pscr_1,)\ \leftarrow$  \\
  $bc([t/x]D,\Pscr, A,\Pscr_1)$. \% argument passing

\item    $bc( D_1\land D_2,\Pscr,A,\Pscr_1)\ \leftarrow$  \\
  $bc(D_1,\Pscr, A,\Pscr_1)$. \% look for  a matching procedure in $D_1$.

\item    $bc( D_1\land D_2,\Pscr,A,\Pscr_1)\ \leftarrow$  \\
  $bc(D_2,\Pscr, A,\Pscr_1)$. \% look for a matching procedure in $D_2$


\item    $ex(\lb D,\theta\rb,A,\Pscr_1)\ \leftarrow$     $bc(D,\Pscr, A,\Pscr_1)$. \% $A$ is a procedure call 

\item  $ex(\Pscr,true,\Pscr)$. \% True is always a success.





\item  $ex(\Pscr,x = exp,\Pscr\uplus \{ \lb x,exp' \rb \}) \leftarrow$ $eval(\Pscr,exp,exp')$. \\
 \% In the assignment statement, it evaluates $exp$ to get $exp'$.
  The symbol
$\uplus$ denotes a set union but $\lb x,V\rb$ in $\Pscr$ will be replaced by $\lb x,E' \rb$.

\item  $ex(\Pscr,G_1; G_2,\Pscr_2)\ \leftarrow$ \\
  $ex(\Pscr,G_1,\Pscr_1)$  seqand  $ex(\Pscr_1,G_2,\Pscr_2)$.
\%  a sequential composition 

\item  $ex(\Pscr, write(x); G_1,\Pscr_1)\ \leftarrow$ \\
  choose (and print) a value $v$ for $x$ so that  $ex(\Pscr_1,[v/x]G_1,\Pscr_1)$.
\%  write statement 

\item  $exec(\lb write(x_1)\ldots write(x_n) D, \theta \rb, G,\Pscr_1)\ \leftarrow$  \\
  $read(y_1)\ldots \ldots read(y_n)$  seqand $ex(\lb [y_1,\ldots,y_n]D,\theta \rb, G ,\Pscr_1)$.  \%
  In the initialization phase,  each $x_i$ is replaced with a new input value $y_i$ typed by the
environment.


\end{numberedlist}
\end{defn}

\noindent
If $ex(\Pscr,G,\Pscr_1)$ has no derivation, then the interpreter returns  the failure.
The rule (9)  deals with the new feature. 


\section{Examples }\label{sec:modules}

The following  code displays the employee's age to be determined at run time.

\begin{exmple}
 write(y1); \\
 write(y2); \\
 write(y3); \\
 age(x) =  \\
  \>      switch (x) \{ \\
 \>           case tom:  age = y1;   break; \\
  \>          case kim: age = y2;   break;\\
 \>           case sue: age = y3;    break;\\
 \>           default: age = 0;          \\
        \}\\
\end{exmple}

Now consider the procedure call age(tom). The above code will be changed to the one below in the initialization phase assuming
the environment typed in 30,40,22 for y1,y2,y3 respectively.

\begin{exmple}
 age(x) =  \\
\>        switch (x) \{ \\
 \>           case tom:  age = 30;   break; \\
  \>          case kim: age = 40;   break;\\
 \>           case sue: age = 22;    break;\\
 \>           default: age = 0;          \\
        \}\\
\end{exmple}


\noindent Then execution proceeds in the usual way.




\section{Conclusion}\label{sec:conc}

In this paper, we have presented a new form of the $write$ statement of the form $write(x);S$.
This statement is a generalization of traditional write statement 
$write(exp)$, as we can write the latter as $write(x); x == exp$. Here we assume that
 we allow boolean expressions as statements.
In addition, we have presented a notion of  interactive
 modules.  The notion of interactive modules is an indispensable tool in
modern interactive programming.

\section{Acknowledgements}

This work  was supported by Dong-A University Research Fund.

\bibliographystyle{ieicetr}
\begin{thebibliography}{1}

\bibitem{Khan87}
G.~Kahn,  ``Natural Semantics'', In the 4th Annual Symposium on Theoretical Aspects of Computer Science, 
LNCS vol. 247,  1987.



\bibitem{Jap03}
G.~Japaridze, ``Introduction to computability logic'', Annals  of Pure and
 Applied  Logic, vol.123, pp.1--99, 2003.

\bibitem{Jap08}
G.~Japaridze,   ``Sequential operators in computability logic'',
 Information and Computation, vol.206, No.12, pp.1443-1475, 2008.  

\bibitem{KHP13}
K.~Kwon, S.~Hur and M.~Park,  ``Improving Robustness via Disjunctive Statements in Imperative  Programming'', IEICE Transations on Information and Systems, vol.E96-D,No.9, pp.2036-2038, September, 2013.  

\bibitem{HM94}
J.~Hodas and D.~Miller,   ``Logic Programming in a Fragment of Intuitionistic Linear Logic'', 
 Information and Computation, vol.110, No.2, pp.327-365, 1994. 



\bibitem{MNPS91}
D.~Miller, G.~Nadathur, F.~Pfenning, and A.~Scedrov, ``Uniform proofs as a
  foundation for logic programming'', Annals of Pure and Applied Logic, vol.51,
  pp.125--157, 1991.

\bibitem{MN12}
D.~Miller, G.~Nadathur, Programming with higher-order logic, Cambridge University Press,   2012.
\end{thebibliography}







\end{document}
