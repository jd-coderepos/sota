\documentclass[a4paper,11pt]{article}

\usepackage{a4wide}
\addtolength{\topmargin}{-12mm}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}

\hyphenation{equi-va-lent}

\sloppy

\usepackage{dpda-macros}

\title{Bisimulation equivalence  
	of first-order grammars is Ackermann-hard}

\author{Petr Jan\v{c}ar\\
 \ \\
Dept Comp. Sci., FEI,	Techn. Univ. Ostrava, Czech Republic,
 \\
 http://www.cs.vsb.cz/jancar/,
 \\
 email: petr.jancar@vsb.cz
}

\date{}

\begin{document}

\maketitle


\begin{abstract}
\noindent	
Bisimulation equivalence 
(or bisimilarity)
of
first-order grammars is decidable, as follows from  
the decidability result 
by S\'enizergues (1998, 2005) that has been given
in an equivalent framework of 
equational graphs with finite out-degree, or of 
pushdown automata (PDA)
with
only deterministic and popping -transitions.
Benedikt, G\"oller, Kiefer, and Murawski (2013) have shown that the
bisimilarity problem for PDA (even) without -transitions is
nonelementary. 
Here we show Ackermann-hardness for bisimilarity of first-order grammars. 
The grammars do not use explicit -transitions, but they
correspond to the above mentioned PDA with (deterministic and popping)  
-transitions, and this feature is substantial in the
presented lower-bound proof.
The proof is based on
a (polynomial) reduction from the reachability problem of reset (or
lossy) counter machines, for which  the Ackermann-hardness has been
shown by Schnoebelen (2010); in fact, this reachability problem is known to be 
Ackermann-complete, i.e.,
-complete in the hierarchy of fast-growing
complexity classes defined by Schmitz (2013).
\end{abstract}

\noindent
\textbf{Keywords:}
\\
first-order grammar, term rewriting, pushdown
automaton, bisimulation, complexity 


\subsection*{Introduction}

Bisimulation equivalence, 
also called bisimilarity, has been recognized as a fundamental behavioural equivalence 
of systems. It is thus natural to explore the related decidability and
complexity questions for various computational models. 

The involved result by S\'enizergues~\cite{Seni05}, showing the decidability of
bisimilarity for equational graphs of finite out-degree, or
equivalently for 
pushdown automata (PDA)
with
only deterministic and popping -transitions, surely
belongs to the most fundamental results in this area. (This result
generalized S\'enizergues's solving of the famous DPDA equivalence
problem.)
The complexity of the bisimilarity problem has been recently shown to
be nonelementary, by
Benedikt, G\"oller, Kiefer, and Murawski~\cite{BGKM12}, even for PDA
with no -transitions.

Here we look at the bisimilarity problem in the framework of 
first-order grammars (i.e., finite sets of term root-rewriting rules). 
This framework is long known as equivalent to the PDA framework.
(We can refer, e.g., to~\cite{JancarLICS12} for a recent use of a concrete
respective transformation.)
Hence  S\'enizergues's decidability proof applies to the grammars as
well.
We show that the problem for grammars is
``Ackermann-hard'', and thus not primitive recursive. 
Though the grammars do not use explicit -transitions, they
correspond to the above mentioned PDA with deterministic and popping
-transitions, and this feature is substantial in the
presented lower-bound proof.
Hence the nonelementary bound of~\cite{BGKM12} remains
the best known lower bound for bisimilarity of pushdown systems
without -transitions.

The presented proof is based on
a (polynomial) reduction from the reachability problem of reset (or
lossy) counter machines, for which  the Ackermann-hardness has been
shown by Schnoebelen (see~\cite{DBLP:conf/mfcs/Schnoebelen10} and the
reference therein).
In fact, we also know an ``Ackermannian'' upper bound for this
reachability problem~\cite{DBLP:conf/lics/FigueiraFSS11}, 
and the problem is thus -complete (or 
-complete) 
 in the hierarchy of fast-growing
complexity classes defined by Schmitz~\cite{Schmitz2013}.
The question of a similar
upper bound for the bisimilarity problem is not addressed in this
paper.


\subsection*{Definitions, and the result}

We briefly recall the notions 
that are needed for stating the result. We use the forms that are
convenient here; e.g., we (harmlessly) 
define bisimulations as symmetric, though
this is usually not required. 

\textbf{First-order terms.}
We assume a fixed set of 
\emph{variables} .
Given a set  of function symbols with arities,
by  we
denote the set of \emph{terms over} .
A \emph{term} 
is either  a variable  
or   where 
, 
, and  are terms.

\textbf{First-order grammars.}
A (first-order) \emph{grammar} is a tuple 
where  is a finite set of ranked \emph{nonterminals}
(or function symbols with arities),
 is a finite set of  \emph{actions} (or terminals),
and  is a finite set of (root-rewriting) \emph{rules} of the form
 where 
, ,
, and
 is a 
term
in which all occurring variables are from the set 
.
(Some example rules are ,
,
; here
 the arities of  are , respectively.)

\textbf{LTSs associated with grammars.}
A grammar  defines the \emph{labelled
transition system} 
in which each rule  from  induces 
transitions 
 for all substitutions
.
(The above example rules thus induce, e.g., 
 (here ),
 (here
, , ),
, ,
etc.)

\textbf{Bisimulation equivalence.}
Given , a set (or a relation)
 is a
\emph{bisimulation} if it is \emph{symmetric} ( implies
), and for any  and  there is
 such that   and .
Two \emph{terms}  are \emph{bisimilar}, written , if there is a
bisimulation containing .
\\
The \emph{bisimilarity problem for first-order grammars} asks, given a grammar  and
terms , whether .


\textbf{Ackermann-hardness.}
We refer to~\cite{Schmitz2013} for detailed definitions of the class
  (or )
of decision problems, and of the problems that are 
-complete
or -hard.
Here we just recall the ``Ackermannian'' function
 (where ) defined as
follows: we first define  the family  
by putting  and 
where  is applied  times; then we put .
The problem  that asks,
given a Turing machine , an input , and some
, whether  halts on  within  steps, is an
example of an \emph{Ackermann-complete problem}. 
We say (in this paper) that a \emph{problem}
 is
\emph{Ackermann-hard} if  is reducible 
to , or to the complementary problem co-, 
by a standard polynomial
many-one reduction.
(The notion is more general in~\cite{Schmitz2013}, and it also 
includes primitive-recursive reductions.)

\begin{theorem}\label{th:bisackhard}
The bisimilarity problem for
first-order grammars is Ackermann-hard. 
\end{theorem}


\subsection*{Proof of the theorem}

A direct reduction from  would require many
technicalities. Fortunately, these have been already handled in 
deriving  Ackermann-hardness (or Ackermann-completeness) of other
problems.
For our reduction we thus choose a more convenient
Ackermann-hard problem (which is Ackermann-complete, in
fact), namely the reachability problem for reset counter machines.

\textbf{Reset Counter Machines (RCMs).}
An \emph{RCM} is a tuple   where 
 is the \emph{dimension}, yielding  nonnegative
\emph{counters} ,
 is a
finite set of \emph{(control) states},
and  is a finite set of
\emph{instructions}, where the set 
 of \emph{operations} contains  (increment ),
 (decrement ), 
and  (set  to ),
for .
We view  
as the set  of 
\emph{configurations} of . 
The \emph{transition relation}  is
induced by  in the obvious way:
If  then we have 
in the following cases: 
\begin{itemize}
	\item
		, , and  for
		all ; or 
	\item
, , , and  for
		all ; or 
	\item
, , and  for
		all .
\end{itemize}		
By  we denote the reflexive and transitive closure of
.

\textbf{Complexity of the reachability problem for RCMs.}
We define the \emph{RCM-reachability problem} in the following
convenient form: given an RCM  and (control) states
, , we ask if  is reachable from
, i.e., if there are 
such that
.
The known results yield:

\begin{theorem}\label{th:RCMAck}
RCM-reachability problem is Ackermann-complete.
\end{theorem}

It is the lower bound, the  Ackermann-hardness, which is important
for us here; we refer to~\cite{DBLP:conf/mfcs/Schnoebelen10} for a proof 
and further references.
(See also~\cite{DBLP:journals/jsyml/Urquhart99}
for an independent proof related to relevance logic.)
The upper bound follows from~\cite{DBLP:conf/lics/FigueiraFSS11}.
Hence the problem is
-complete in the sense of~\cite{Schmitz2013}.
We note that the same result holds for
\emph{lossy counter machines}; they have the zero-test instead of the
reset, and any counter can spontaneously decrease at any time.
(We prefer RCMs since they are a slightly simpler model.)

\textbf{RCM-reachability reduces to first-order bisimilarity.}
We finish by proving  the next lemma; this establishes 
Theorem~\ref{th:bisackhard}, by 
using the hardness part of Theorem~\ref{th:RCMAck}.
The reduction in the proof of the lemma is obviously polynomial; in
fact, it can be checked to be a logspace reduction, 
but this is a minor point in the view of the fact that even a 
primitive-recursive reduction would suffice here.

\begin{lemma}
The RCM-reachability problem is polynomially reducible to the complement 
of the bisimilarity problem for
first-order grammars.
\end{lemma}

\begin{proof}
Let us consider an instance ,
,  of the RCM-reachability problem,
and imagine the
following game between Attacker (he) and Defender (she). This is the first
version of a game that will be afterwards
implemented as a standard bisimulation game.
Attacker aims to show that  is reachable from 
, while 
Defender opposes this.

The game uses  \emph{game-counters}, which are never decremented;
each counter  of  yields two game-counters, namely 
 and , for counting the numbers of Increments and
Decrements of , respectively, since the last
reset or since the beginning if there has been no reset of  so
far.
The \emph{initial position} is 
, with all 
 game-counters (organized in pairs) having the value .

A game \emph{round} from position 
proceeds as described below.
It will become clear that 
it suffices to consider only the cases ;
the position then corresponds to the 's configuration
.

If , then Attacker wins;
if   and there is no instruction , then 
Defender wins.
Otherwise Attacker chooses , and the continuation
depends on :
\begin{enumerate}
\item
If , then the next-round position arises (from the
previous one) by replacing  with  and by performing 
 (the counter of increments of  is
incremented, i.e.,  is replaced with ).
\item
If , then the next-round position arises 
by replacing  with  and by performing 
 and  (hence both  and  are replaced
with ).
\item
If , then \emph{Defender chooses} one of the following
options:
\begin{enumerate}
\item
the next-round position arises 
by replacing  with  and by performing 
 (the counter of decrements of  is
incremented, i.e.,  is replaced with ), or
\item
	(Defender claims that this decrement is \emph{illegal} since  and)
the next position becomes just . 
In this case a (deterministic) check if  
is performed, by successive
synchronized decrements at both sides. If indeed
 (the counter-bottoms are reached at the same moment),
then Defender wins; otherwise (when )
Attacker wins.
\end{enumerate}
\end{enumerate}
If
 for some
, i.e., if the answer to RCM-reachability is YES,
then Attacker has a winning strategy: he just follows the
corresponding
sequence of instructions. He thus also always chooses 
\emph{legally},
i.e. only in the cases where , and Defender loses if
she ever chooses 3(b).
If the answer is NO ( is not reachable), and Attacker
follows a legal sequence of instructions, then he
either loses in a ``dead'' state or the play is infinite; if Attacker
chooses an illegal decrement, then in the first such situation we
obviously have
 for the respective counter , and Defender can force
her win via 3(b).


Since the game-counters can be only incremented or reset, it is a
routine
to implement the above game as a bisimulation game in the
grammar-framework
(using a standard
method of ``Defender's forcing'' for implementing the choice in 3).
We now describe the corresponding 
grammar .

The set  of nonterminals will include 
a unary nonterminal , a nullary nonterminal , and the
nonterminals with arity   that are induced by control states of
 as follows:
each  induces 
, where .

We intend that 
a game-position  corresponds to the
pair of terms 

where  is a shorthand for 
 with  occurring  times; we put
.
The RCM-reachability instance  will be
reduced to the (non)bisimilarity-problem instance , 
, .


We put , i.e., the actions of
 correspond to the instructions (or instruction names)
of , and we also use
auxiliary actions , .

The set of rules  contains a sole rule for , namely
, and no rule for ;
hence  iff .
Each instruction    induces the rules in  as
follows:

\begin{enumerate}
		\item
If , then the induced rules are
\\
, and
\\
.
\item
If , then the induced rules are
\\
,
\\
.
\item
If , then the induced rules are below;
here we use the shorthand  when meaning 
:
\\
,
,
,
,
,
\\
,
\\
,
\\
,
\\
,
,
.
\end{enumerate}
Moreover,  will also contain
 
(but \emph{not} ). 

Now we recall the standard (turn-based) \emph{bisimulation game}, starting
with the pair
.
In the round starting with , Attacker chooses a transition
 and then Defender chooses  (for
the same ); the
next round starts with the pair . If a player gets
stuck, then (s)he loses; an infinite play is a win of Defender.
It is obvious that Defender has a winning strategy in this game iff 
.

We now easily check that this bisimulation game indeed implements the
above described game; a game-position  
 is implemented as the
pair~(\ref{eq:pairposition}). The points 1 and 2 directly correspond
to the previous points 1 and 2.
If Attacker chooses an instruction , 
then he
must use the respective rule  in 3, since
otherwise Defender installs syntactic equality, i.e. a pair .
It is now Defender who chooses  (corresponding
to the previous 3(a)) or  (corresponding
to 3(b)). Attacker then must
choose action  in the first case, and action  in the second
case; otherwise we get syntactic equality.
The first case thus results in the pair 
 corresponding to the next game-position
(where  has been incremented), and the second case results in
the pair ; we have already observed that 
 iff .

Finally we observe that in any pair 
 Attacker wins immediately
(since the transition  can not be
matched).

We have thus established that  is reachable from
 if, and only if, 
.
\end{proof}

\subsection*{Additional remarks}

In the above bisimulation game we obviously encounter ``unbalanced'' terms; 
the syntactic tree of an unbalanced term has branches of different lengths. 
This feature is related to deterministic popping
-transitions in the pushdown automata corresponding to
our grammars.
Hence the nonelementary bound shown in~\cite{BGKM12} remains
the best known lower bound for bisimilarity of pushdown systems
without -transitions.


We can add that introducing (popping) -rules
 in our grammars (where such a
rule might be not the only one with  at the
left-hand side) already yields undecidability of
bisimilarity~\cite{DBLP:journals/jacm/JancarS08}.

\subsection*{Author's acknowledgement}

The reported result has been achieved during my visit at LSV ENS
Cachan, and 
I am grateful to Sylvain Schmitz and Philippe Schnoebelen for
fruitful discussions.



\bibliographystyle{abbrv}
\bibliography{root}

\end{document}
