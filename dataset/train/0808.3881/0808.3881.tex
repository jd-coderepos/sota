

\documentclass{llncs} 

\usepackage{amssymb}
\usepackage{algorithm}
\usepackage{color}
\usepackage{graphicx}
\usepackage{mathptmx} 

\newcommand{\bs}{\backslash}
\newcommand{\PF}{{\bf Proof: }}
\newcommand{\QED}{\hspace*{\fill}{}\medskip}



\def\notat#1{{}\marginpar{\raggedright{\small }}}
\def\term#1{{\em #1}\marginpar{\raggedright{\small\it #1}}}

\newcommand{\BW}{\mathcal{B}}
\newcommand{\AS}{\mathcal{A}}
\newcommand{\ri}{\mbox{right}}
\newcommand{\INP}{\mbox{\sc Input}}
\newcommand{\convex}{\mbox{\sc Right}}
\newcommand{\concave}{\mbox{\sc Left}}
\newcommand{\MP}{\mathcal{P}}
\newcommand{\Bo}{B'}
\newcommand{\Bt}{B''}
\newcommand{\Ao}{A^1}
\newcommand{\At}{A^2}
\newcommand{\id}{\mbox{id}}

\newcommand{\EC}{\mathcal{C}}
\newcommand{\npa}{p}
\newcommand{\elcyc}{elementary cycle}
\newcommand{\mcI}{\mathcal{I}}


\newcommand{\yo}{y'}
\newcommand{\xt}{x'}

\newcommand{\GPA}{G^{W}}


\newtheorem{thm}{Theorem}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{obs}[thm]{Observation}
\newtheorem{defi}[thm]{Definition}
\newtheorem{corol}[thm]{Corollary}
\newtheorem{propo}[thm]{Proposition}
\newtheorem{prop}[thm]{Property}
\newtheorem{ques}{Question}
\newtheorem{repeatlem}{Lemma}




\begin{document}


\title{Counting hexagonal patches and independent sets in circle graphs}
\titlerunning{counting hexagonal patches}
\date{\today}


\author{Paul Bonsma\inst{1}\thanks{Both authors are supported by the Graduate School ``Methods for Discrete Structures'' in Berlin, DFG grant GRK 1408.} \and Felix Breuer\inst{2}}

\institute{
Technische Universit\"{a}t Berlin, Institut f\"{u}r Mathematik,\\
Sekr. MA 5-1, Stra\ss{}e des 17. Juni 136, 10623 Berlin, Germany.\\ \texttt{bonsma@math.tu-berlin.de}
\and
Freie Universit\"{a}t Berlin, Institut f\"{u}r Mathematik,\\
Arnimallee 3, 14195 Berlin, Germany.\\
\texttt{felix.breuer@fu-berlin.de}
}


\maketitle

\begin{abstract}
A hexagonal patch is a plane graph in which inner faces have length 6, inner vertices have degree 3, and boundary vertices have degree 2 or 3. 
We consider the following counting problem: given a sequence of twos and threes, how many hexagonal patches exist with this degree sequence along the outer face?
This problem is motivated by the enumeration of benzenoid hydrocarbons and fullerenes in computational chemistry.
We give the first polynomial time algorithm for this problem. We show that it can be reduced to counting maximum independent sets in circle graphs, and give a simple and fast algorithm for this problem.\\
\\
Keywords: graph algorithms, computational complexity, counting problem, planar graph, circle graph, fullerene, hexagonal patch, fusene, polyhex. 
\end{abstract}

\section{Introduction}


The notions used and problems introduced in this section are defined more formally in Section~\ref{sec:prelim}.
A plane graph  is a graph together with a fixed planar embedding in the plane. The unbounded face is called the {\em outer face} and the other faces are called {\em inner faces}. The boundary of the outer face is simply called the {\em boundary} of .
A {\em hexagonal patch} is a 2-connected plane graph in which all inner faces have length 6, boundary vertices have degree 2 or 3, and non-boundary vertices have degree 3. These graphs are also known as {\em fusenes}~\cite{GHZ02}, {\em hexagonal systems}~\cite{DFG01}, {\em polyhexes}~\cite{Gra03} and {\em -polycycles}~\cite{DDS08} in the literature. These graphs are well-studied in mathematical and computational chemistry since they model benzenoid hydrocarbons and graphite fragments (see e.g.~\cite{GHZ02} and the references therein). A central question is that of enumerating hexagonal patches, either of a given size~\cite{BCH03}, or with a given boundary form.



A sequence  of twos and threes is a {\em boundary code} of a hexagonal patch  if there is a way to label the boundary vertices of  with  such that  is a boundary cycle of , and the degree  for all . Note that cyclic permutations and/or inversions of the sequence can yield different boundary codes for the same patch, but for the question we study this fact is not important.
It is well-known and easily observed using Euler's formula that the boundary code of a hexagonal patch satifies , where  is the number of boundary vertices with degree . We define the parameters  and  also for sequences  of twos and threes, as expected.
One may ask whether a hexagonal patch exists that satisfies a given boundary code.
A result by Guo, Hansen and Zheng~\cite{GHZ02} shows that this question is not as easy as was first expected: in Figure~\ref{fig:nontriv} their example is shown which shows that 
different patches may exist with the same boundary code. This can be verified by comparing the degree of  with ,  with , etc. 
Our drawing of this graph is taken from~\cite{BDN05}. (In~\cite{GHZ02} it is also shown that although multiple solutions may exist, they all have the same size.)
\begin{figure}
\centering
\scalebox{0.8}{v_1v_2u_2u_1}
\caption{Two different patches with the same boundary code.}
\label{fig:nontriv}
\end{figure}
Therefore the following question should be asked: given a sequence  of twos and threes, {\em how many} hexagonal patches exist with boundary code ? This counting problem is called {\em Hexagonal Patch}. Guo et al~\cite{GHZ02} and Graver~\cite{Gra03} give conditions for when solutions are unique, if they exist. Deza et al~\cite{DFG01} give an algorithm for deciding whether at least one solution exist. The complexity of their algorithm is however superexponential.
In addition they give a polynomial time algorithm for a very restricted case (see Section~\ref{sec:representations}).
These results have been generalized to various problem variants, mainly by varying the conditions on the face lengths and vertex degrees, see e.g.~\cite{DDS08,BC09,BDN05,BGJ09}. However, the question whether the counting problem can be answered efficiently remained open. 


\medskip

{\em In this paper we show that the counting problem Hexagonal Patch can be solved in time  where  is the length of the sequence.} This is surprising since the number of solutions may be exponential in , as can easily be seen by generalizing the example from Figure~\ref{fig:nontriv}.
Therefore, we can only return the {\em number} of solutions in polynomial time, and not return a {\em list} of all corresponding patches. The algorithm can however be extended to generate all patches in time , where  is the number of returned solutions.
We remark that it is not hard to generalize our result to the generalizations introduced in~\cite{BDN05}:
A 2-connected plane graph is an {\em -patch} if all inner faces have length , inner vertices have degree  and boundary vertices have degree at most . 
Our methods work for instance for  and -patches in addition to -patches, but for simplicity we restrict to hexagonal patches.




An additional motivation for this result is the following: {\em fullerene patches} generalize hexagonal patches by also allowing 5-faces in addition to 6-faces. Such patches model fragments of fullerene molecules, and therefore their enumeration is another important problem from computational chemistry. Fullerene molecules have at most twelve 5-faces. 
The current result is an essential ingredient for the result we give in a second paper~\cite{BB2}, where we give a polynomial time algorithm for deciding whether a given boundary code belongs to a fullerene patch with at most five 5-faces.



Our algorithm is based on the following idea: with a few intermediate steps, we transform the problem Hexagonal Patch to the problem of counting maximum independent sets in circle graphs. A \term{circle graph}  is the intersection graph of chords of a circle (detailed definitions are given below). Algorithms are known for the optimization problem of finding maximum independent sets in circle graphs~\cite{Gav73}, but counting problems on circle graphs have not been studied to our knowledge.

{\em In this paper we give a simple dynamic programming algorithm for counting independent sets in circle graphs}. In addition this algorithm improves the complexity for the optimization problem.
Circle graphs can be represented as follows
(see Figure~\ref{fig:circlegraph}(a),(b)): Every vertex of  is associated with a {\em chord} of a circle drawn in the plane, which is a straight line segment between two points on the circle, such that two vertices are adjacent if and only if the two chords overlap (possibly only in a common end).
We will represent chord diagrams with graphs as follows (see Figure~\ref{fig:circlegraph}(d)).
Number the points on the circle that are ends of chords with , in order around the circle, and view these as vertices. View a chord from  to  as an edge . 
Call the resulting graph  the \term{chord model graph}.
Note that (maximum) independent sets of the circle graph correspond bijectively to \term{(maximum) planar matchings} or (M)PMs of , which are (maximum) matchings  that do not contain edges  and  with .
Hence counting MPMs in  is polynomially equivalent to counting maximum independent sets in circle graphs. 


\begin{figure}
\centering
\scalebox{1}{fbcdfedcbaeaabcdef}
\caption{A circle graph, (simple) chord diagram and (simple) chord model graph.}
\label{fig:circlegraph}
\end{figure}




Circle graphs are extensively studied and generalize permutation graphs and distance hereditary graphs, see e.g.~\cite{BLS99}. Recognizing them and constructing a chord representation can be done in polynomial time~\cite{Bou87,GSH89}, and the current fastest algorithm uses time , where  is the number of vertices~\cite{Spi94}. A number of problems that are NP-hard on general graphs are easy on circle graphs, such as in particular finding maximum independent sets~\cite{Gav73,Sup87,Val03,NLG09}. 



The first algorithm for the optimization problem by Gavril~\cite{Gav73} has time complexity , where  is the number of vertices of the circle graph, which is the number of edges of the corresponding chord model graph.
This was improved to  by Supowit~\cite{Sup87}. Recently this has been improved further by Valiente~\cite{Val03} in the way we will explain now. 
All of these algorithms work with the chord model graph (or chord diagram), and as a first step, transform it into a 1-regular graph as shown in Figure~\ref{fig:circlegraph}(e):
for a vertex of degree ,  new vertices are introduced, and the  incident edges are distributed among these in such a way only one of these edges can appear in a PM of . This does not change the size and number of MPMs. The resulting graph  has  vertices and  edges, and is called the {\em simple chord model graph}. We assume the vertices are numbered , in the proper order. Then the {\em length} of an edge  is . The algorithm from~\cite{Val03} has complexity , where  is the sum of all edge lengths of the simple chord model graph obtained this way. Clearly this is at most , and in many cases better. However, when {\em dense} chord model graphs are given on  vertices and  edges, this algorithm may need  steps. 
Our transformation from Hexagonal Patch yields a chord model graph , which in fact may be dense.

We give a simple algorithm with complexity , which not only determines the size of a MPM, but also counts the number of MPMs of the chord model graph. 
This improvement in time complexity is possible by working with arbitrary degrees, and not using the simple chord model graph, in contrast to all previous algorithms for this problem~\cite{Val03}.







The outline of the paper is as follows. In Section~\ref{sec:prelim} we give definitions, and a precise formulation of the problem. In Section~\ref{sec:representations} we define locally injective homomorphisms to the hexagonal lattice (the brickwall) as a way of representing problem instances and solutions and reduce the counting problem to a problem on walks in the brickwall. 
In Section~\ref{sec:assignments} we reduce that problem to that of counting {\em proper assignment sets} of the walk, which is in fact the problem of counting MPMs in chord model graphs.
In Section~\ref{sec:circlegraphs} we present our algorithm for counting MPMs, and in Section~\ref{sec:alg} we give a summary of our algorithm for Hexagonal Patch.
We end in Section~\ref{sec:discussion} with a discussion, where we also discuss a similar problem from topology.
Statements for which proofs are omitted are marked with a star, the proofs appear in the appendix.




\section{Preliminaries}
\label{sec:prelim}



For basic graph theoretic notions not defined here we refer to~\cite{Die}.
A \term{walk} of {\em length } in a (simple) graph  is a sequence of  vertices  such that  and  are adjacent in  for all .
 are the \term{internal} vertices and  the \term{end} vertices of the walk. The walk is \term{closed} if .
Throughout this paper we will in addition assume that  for all , and if the walk is closed,  (i.e. we will assume walks {\em do not turn back}).
If  for all  
then the walk is a \term{path}. If the walk is closed and  for all distinct  then it is also called a \term{cycle}. A cycle of length  is also called a \term{-cycle}.
For a walk , \notat{W_x} denotes .
If  is a closed walk, then  denotes . 
We will also talk about the {\em vertices} and {\em edges} of a walk, which are defined as expected. In a slight abuse of terminology, the graph consisting of these vertices and edges will also be called a walk (or path or cycle if applicable).





Let  be a hexagonal patch, and  be a boundary cycle of  of length . Let  be a sequence of twos and threes. We say that the tuple  is a {\em solution for the boundary code } if  for all .
Two solutions  and  are considered \term{equivalent} if there is an isomorphism  from  to  such that  for all .
Formally, when we ask for the number of {\em different} pairs  that satisfy some property, we want to know how many equivalence classes contain a pair  satisfying this property.
The counting problem Hexagonal Patch is now defined as follows: given a sequence , how many different solutions  to  exist?





\section{From Boundary Codes to Walks in the Brickwall}
\label{sec:representations}


\begin{figure}
\centering
\scalebox{0.40}{}
\caption{The brickwall .}
\label{fig:brickwalls}
\end{figure}

An (infinite) 3-regular plane graph where every face has length 6 is called a \term{brickwall}. It can be shown that the facial cycles are the only 6-cycles of a brickwall, and that all brickwalls are isomorphic.


We will use \notat{\BW} to denote the brickwall as drawn in Figure~\ref{fig:brickwalls}. Edges that are horizontal (vertical) in this drawing are called the \term{horizontal} (\term{vertical}) edges of .
Paths consisting of horizontal edges are called \term{horizontal paths}. Two vertices joined by a horizontal path are said to have the same \term{height}.

The reason that we study brickwalls is because the following mapping of hexagonal patches into them is very useful.
Let  be a hexagonal patch. A \term{locally injective homomophism (LIH)} of  into  is a mapping of the vertices of  to vertices of , such that adjacent vertices are mapped to adjacent vertices in , and such that all neighbors of any vertex in  are mapped to different vertices in .
Since the shortest cycles in  are of length 6, a LIH into  maps 6-cycles to 6-cycles. Since the faces of  are the only 6-cycles in , we see that a LIH of  into  also maps inner faces to faces.


Loosely speaking, the idea behind these mappings is as follows. 
Let  be a hexagonal patch of which we fix a boundary cycle . When we map  with a LIH  into , then the boundary  is mapped to some walk  in . 
But now it can be shown that this walk  is only determined by the choice of the initial vertices and the boundary code of .
Hence instead of asking how many hexagonal patches exist with a certain boundary code, we may ask how many patches exist that can be mapped properly to the brickwall, such that the boundary coincides with the walk that is deduced from the boundary code. 
Below we will go into more detail. 


The technique of mapping patches to brickwalls is not new, and is actually considered folklore to some extent~\cite{DFG01}. 
For instance, Deza et al~\cite{DFG01} observe that Hexagonal Patch can be solved in polynomial time if the LIH is bijective, and Graver~\cite{Gra03} shows that the problem Hexagonal Patch can only have multiple solutions if there is a brickwall vertex that has at least three preimages in such a LIH.
We will however study these mappings more in more detail than has been done before, and develop new concepts, and prove new statements which we feel are of independent interest. 


Let  be a walk in a 3-regular plane graph . We say \term{ makes a right (left) turn at } when 
edge  immediately follows edge  in the clockwise (anticlockwise) order around .
Note that since we assume that walks do not turn back and  is 3-regular,  makes either a left or a right turn at every .





{\em Walk construction:}
Using a given sequence  of twos and threes, we construct a walk  in  as follows. 
For  and , choose two (arbitrary) adjacent vertices.
For , choose  such that  makes a left turn at  if , and makes a right turn at  if .


Let  be a closed walk in  of length ,  be a hexagonal patch,  a LIH from  to  and  a boundary walk of  of length . Then the tuple  is said to be a \term{solution for } when    for all .
Two solutions  and  are considered to be \term{equivalent} if and only if there is an isomorphism  from  to  such that  for all . We say that  is an (or demonstrates the) equivalence between  and .
The LIH  allows us to use the terminology defined for  for the graph  as well; we will for instance call edges of  {\em horizontal} or {\em vertical} if their images under  are horizontal or vertical, respectively. 

Let the boundary  of a hexagonal patch  be mapped to the closed walk  in  by the LIH . This is a \term{clockwise solution} if and only if for every , 
    if  makes a right turn at , and
    if  makes a left turn at .
It is {\em anticlockwise} when these conditions are reversed.
Let \notat{\convex(W)} and \notat{\concave(W)} denote the number of indices  such that  makes a right turn or left turn at , respectively. 
The \term{turning number} of  is \notat{t(W)}.
Using the fact that for a solution ,  maps faces of  to faces of , it can be shown that every solution is either clockwise or anticlockwise. Since a hexagonal patch has  ( is the number of degree  vertices on the boundary), Lemma~\ref{lem:cw_or_acw} then follows. Variants of Lemma~\ref{lem:unique_phi} have been proved in~\cite{BDN05,Gra03}.


\begin{lem}[*]
\label{lem:cw_or_acw}
Let  be a closed walk in .
If , then every solution to  is clockwise. If  then every solution to  is anticlockwise. If , then no solution exists.
\end{lem}


\begin{lem}
\label{lem:unique_phi}
Let  be a solution to a boundary code  and let  be a walk in  that is constructed using . Then there exists a unique LIH  such that  is a clockwise solution to .
\end{lem}

Because of Lemma~\ref{lem:unique_phi}, we may rephrase the problem Hexagonal Patch in terms of solutions  to a closed walk  in the brickwall. 

\begin{thm}
\label{thm:equiv_boundary_walk}
The number of different (hexagonal) solutions for a boundary code  with  is the same as the number of different clockwise solutions for the walk  in  that is constructed using .
\end{thm}
\PF
For any solution  for , a unique LIH  exists such that  is a clockwise solution to  (Lemma~\ref{lem:unique_phi}). For any clockwise solution  to , the characterization of clockwise solutions and the construction of  shows that  is a solution to . 
(Since  and  by Lemma~\ref{lem:cw_or_acw},  turns at  as prescribed by .)
Note that the definitions of equivalence for pairs  and triples  coincide and, in particular, do not depend on .
\QED






\section{From Walks in the Brickwall to Assignment Sets}
\label{sec:assignments}



Throughout Section~\ref{sec:assignments},  denotes a closed walk in  with length .
We first sketch the main idea of this section.
If we consider a solution  to , then we mentioned above that this defines which edges of  are horizontal and vertical. Now if we start at a boundary vertex  of  that is incident with a horizontal interior edge of , then we can continue following this horizontal path of  until we end in a different boundary vertex . We will say that this solution {\em assigns}  to . If we only know all assignments defined by the solution this way, we can reconstruct the unique solution. We will deduce properties of such sets of assignments such that there is a solution if and only if these properties are satisfied. The purpose is to show that we may focus on counting such assignment sets instead of solutions to the walk.



For all  where  and  lie on the same height, \notat{H_{i,j}} denotes the horizontal walk in  from  to .
Consider an index  and the vertex . Let  be the neighbor of  in  not equal to  or . 
If  has the same height as  and  makes a left turn at , then index  is called a \term{PA-index}. 
In Figure~\ref{fig:PAindices}(b) an example 
is shown, where vertices corresponding to PA-indices are encircled, and their indices are shown.
Note that if  has a 
clockwise
solution , then the PA-indices are precisely those indices  such that  has degree 3 and the interior edge incident with  is horizontal (see Figure~\ref{fig:PAindices}(a)).

A \term{possible assignment (PA)} is a pair  of PA-indices with  such that  and  have the same height and  
does not contain any of  (note that  has non-zero length). 
For instance, in Figure~\ref{fig:PAindices}(b) some PAs are ,  and , but  is not.




\begin{figure}
\centering
\scalebox{0.7}{\phiHW}
\caption{Assignment paths of a solution and PA-indices of a walk.}
\label{fig:PAindices}
\end{figure}





Let  be a clockwise solution to a closed walk  in . An \term{assignment path}  is a horizontal path in  from  to  where , and all edges and internal vertices of  are interior edges and vertices of . In Figure~\ref{fig:PAindices}(a) the assignment paths of the given solution are shown in bold.


\begin{propo}[*]
\label{propo:assignments_are_PAs}
If a clockwise solution  to  contains an assignment path from  to , then  is a PA of .
\end{propo}





This motivates the following definition. A clockwise solution  to a walk  \term{assigns  to } if there is an assignment path from  to . For each clockwise solution , we define the set
\notat{\AS(S)}WSij
This is the \term{assignment set} defined by the solution .

\begin{lem}[*]
\label{lem:well-def}
Let  denote a closed walk in  and let  be clockwise solutions of . If  and  are equivalent, then .
\end{lem}




Now we will deduce the properties of a set .
Proposition~\ref{propo:apath_partition} shows that assignment paths do not share vertices. Combining this with planarity yields Proposition~\ref{propo:separation}.

\begin{propo}[*]
\label{propo:apath_partition}
Let  be a clockwise solution to . Every interior vertex of  and every vertex , where  is a PA-index, lies on a unique assignment path. 
\end{propo}



\begin{propo}[*]
\label{propo:separation}
Let  be a solution to a closed walk  that assigns  to . For any  with  or ,  does not assign  to .
\end{propo}



These two propositions give us properties a set of the form  for a clockwise solution  necessarily has to have. Given , a set  of possible assignments of  is a \term{perfect matching} on the set of PA-indices if for every PA-index  of  there is exactly one pair .  is \term{non-crossing} if there do not exist assignments  such that .
An \term{assignment set} for  is a set of possible assignments of . It is a \term{proper assignment set} if it is a non-crossing, perfect matching on the set of PA-indices of . Combining Proposition~\ref{propo:assignments_are_PAs}, Proposition~\ref{propo:apath_partition} and Proposition~\ref{propo:separation} yields Lemma~\ref{lem:necessary}.
Lemma~\ref{lem:surjective} states more or less the reverse; the long proof appears in Appendix~\ref{sec:surjective}.

\begin{lem}
\label{lem:necessary}
If  is a clockwise solution of  then  is a
proper assignment set for .
\end{lem}

\begin{lem}[*]
\label{lem:surjective}
Let  denote a closed walk in  with , and let  be a proper assignment set of . Then there exists a clockwise solution  of  with .
\end{lem}


It remains to establish the converse of Lemma~\ref{lem:well-def}.
Suppose we have two solutions  and  with .
Every vertex of  and  lies on the boundary or on an assignment path (Proposition~\ref{propo:apath_partition}).
Therefore we can use the boundary and the assignment paths to define a bijection . When doing this appropriately, it can be shown that  an equivalence. 

\begin{lem}[*]
\label{lem:injective}
Let  be a closed walk in , and let  and  denote clockwise solutions of . If , then  and  are equivalent.
\end{lem}




\begin{thm}
\label{thm:equivalence}
Let  be a walk in  with . The number of equivalence classes of solutions to  is the same as the number of different proper assignment sets for .
\end{thm}
\PF
The above lemmas show that  gives a bijection from
the set of equivalence classes of clockwise solutions of 
to the set of proper assignment sets for , since the following properties are satisfied:
(1) \emph{ is well-defined:} Let  and  denote clockwise solutions of . If  and  are equivalent, then  (Lemma~\ref{lem:well-def}).
(2) \emph{The range of  is correct:} For any clockwise solution  of  the set  is a proper assignment set for  (Lemma~\ref{lem:necessary}).
(3) \emph{ is injective:}  Let  and  denote clockwise solutions of . If , then  and  are equivalent (Lemma~\ref{lem:injective}).
(4) \emph{ is surjective:} For any proper assignment set  for , there exists a clockwise solution  of  with  (Lemma~\ref{lem:surjective}).
\QED

It follows that for solving the Hexagonal Patch problem, we may focus on counting proper assignment sets for the walk  (assuming ).

\section{Counting Maximum Planar Matchings}
\label{sec:circlegraphs}


In this section we will observe that the remaining algorithmic problem is that of counting independent sets in circle graphs, and present a fast algorithm for this problem.
We use the closed walk  in  to construct a graph
 with vertex set , where  is the number of PA-indices of . Let  be all PA-indices of , numbered according to their order in . Then the edge set of  will be
.
The following lemma is now easily observed.

\begin{lem}
\label{lem:equiv_to_MPM}
Let  be the graph as constructed above from the walk .
If  has no perfect planar matching, then  has no proper assignment sets. Otherwise the number of proper assignment sets for  is equal to the number of MPMs in .
\end{lem}



Now we will present an algorithm for counting MPMs of a graph  with . As mentioned in the introduction, this is equivalent to counting maximum independent sets in a circle graph , where  is the chord model graph of .
We will present this algorithm for the general case where  has edge weights:  denotes the edge weight of , and a PM  is {\em maximum} if  is maximum.

For  with , let \notat{G_{i,j}}.
If , then  is the empty graph.
For , let \notat{S_{i,j}} denote the size of a MPM in . In particular,  is the size of a MPM in .
We now give a subroutine  for calculating , which considers the sizes of various PMs for , and returns the size of the largest PM. 

\begin{tabbing}
\qquad \=\quad \=\quad \= \quad \kill
A subroutine  for calculating :\\


(1) \> \\

(2) \> {\bf If}  {\bf then} \\

(3) \> {\bf For}  with :\\

(4) \> \> \\

(5) \> {\bf If}  and  {\bf then}\\

(6) \> \> \\

(7) \> Return 

\end{tabbing}


\begin{lem}[*]
\label{lem:Sroutine}
Let  be a graph with  and .
If the values  are known for all  with , then the subroutine  computes  in time .
\end{lem}



Let \notat{N_{i,j}} denote the number of MPMs in . 
Below is a similar subroutine  for calculating , which considers various PMs for , checks whether they are maximum by comparing the size with , and keeps track of the number of MPMs using the variable .


\begin{tabbing}
\qquad \=\quad \=\quad \= \quad \kill
A subroutine  for calculating :\\

(1) \> {\bf If}  {\bf then} Return 1, {\bf exit}.\\

(2) \> \\

(3) \> {\bf If}  {\bf then} \\

(4) \> {\bf For}  with :\\

(5) \> \> {\bf If}  {\bf then}

		\\

(6) \> {\bf If}  and  {\bf then}

 \\

(7) \> Return 

\end{tabbing}



\begin{lem}[*]
\label{lem:Nroutine}
Let  be a graph with  and .
If the values  and  are known for all  with , and  is known,
then the subroutine  computes  in time .
\end{lem}


\begin{thm}
\label{thm:MPM}
Let  be a graph with  on  edges.
The size and number of MPMs of  can be computed in time .
\end{thm}
\PF
For  to , we consider all  with , and calculate  and  using the above subroutines.
This way, for every value of , every vertex of  is considered at most once in the role of . For this choice of , calculating  and  takes time  (Lemma~\ref{lem:Sroutine}, Lemma~\ref{lem:Nroutine}).
Hence for one value of  this procedure takes time .\QED



We remark that Valiente's algorithm~\cite{Val03} for simple (1-regular) chord model graphs can also be extended by using Subroutine  to calculate  in constant time, immediately any time after a value  is calculated. This then yields time complexity  and space complexity . In some cases it may be better to transform to a simple chord model graph and use this algorithm. 


\section{Summary of the Algorithm}
\label{sec:alg}

We now summarize how counting the number of hexagonal patches that satisfy a given boundary code  of length  can be done in time . 
W.l.o.g. .
First use  to construct a walk  in  of length , as shown in Section~\ref{sec:representations}. Theorem~\ref{thm:equiv_boundary_walk} shows that we may now focus on counting clockwise solutions to . If  is not closed it clearly has no solution.
Since  we may now assume . Then Theorem~\ref{thm:equivalence} shows we may focus on counting proper assignment sets for . Now construct  as shown in Section~\ref{sec:circlegraphs}.  has  vertices where  is the number of PA-indices of  (and  edges). By Lemma~\ref{lem:equiv_to_MPM}, the number of proper assignment sets for  is equal to the number of MPMs of , provided that  has a perfect PM. This number and property can be determined in time  (Theorem~\ref{thm:MPM}).




\section{Discussion}
\label{sec:discussion}


Our first question is whether the complexity of  can be improved.
Secondly, considering the motivation from benzenoid hydrocarbons, it is interesting to study whether a patch exists that has a `reasonably flat' embedding in  using {\em regular} hexagons. More precisely, this is the brickwall walk problem, but requires in addition giving a consistent linear order (`depth') for all vertices 
mapped to the same vertex of .
It may also be interesting to study generalizations 
such as to surfaces of higher genus. 

After we presented an early version of this work~\cite{BB08}, Jack Graver 
pointed us to a similar well-studied problem in topology. 
Let  denote the unit circle and  the unit disk in . An {\em immersion} is a continuous function  such that for every  in  there is a neighborhood  of  such that  is a homeomorphism. 
(A {\em curve} when , .)
An immersion  of the circle into the plane is {\em normal} if  has only finitely many double-points and  crosses itself at each of these. Two immersions ,  are
{\em equivalent} if there exists a homeomorphism  such that .
Now the {\em Immersion Extension} problem is this: given an immersion , how many immersions  exist that extend ?  
Note that this problem is not combinatorial, therefore it makes no sense to study its computational complexity. One can turn it into a combinatorial problem by restricting the input to {\em piecewise linear (PL)} curves .

When viewing the walk constructed in Section~\ref{sec:representations} as a curve, there are obvious similarities between the Hexagonal Patch problem and the Immersion Extension problem. However, to our knowledge it is an open problem to prove that these problems are in fact equivalent. 
The ideas introduced here may be helpful for giving such a proof.
Establishing this would provide insight to both problems, since
the Immersion Extension problem is well-studied -- at least on normal curves -- see e.g.~\cite{Bla67,EM08,SW92}. 
Interestingly, Blank~\cite{Bla67,Fra70} reduces the Immersion Extension problem problem to a combinatorial problem that is essentially the same as counting MPMs in simple chord model graphs. He does not address the complexity of this problem. Shor and Van Wyk~\cite{SW92} were the first to study the complexity of the combinatorial Immersion Extension problem on normal curves. They give an  algorithm where  is the number of pieces of the PL curve .
Assuming the equivalence of the Immersion Extension problem and the Hexagonal Patch problem, this would give an alternative algorithm for Hexagonal Patch; note that there are methods for transforming general PL curves to equivalent normal PL curves~\cite{Sei98}.
Since our algorithm does not need such a step, it is not only faster but also much easier to implement (see also~\cite{Sei98}).
However, the question of equivalence of these problems is still interesting because many generalizations of the Immersion Extension problem have been studied~\cite{EM08}.
Finally, we believe that in fact our method can be adapted to give a simple and fast 
for the combinatorial Immersion Extension problem that does not require the assumption that the given curve is normal, but that is beyond the scope of this paper.

\noindent
{\bf Acknowledgement} We thank Gunnar Brinkmann for introducing us to this subject and his suggestions, and Hajo Broersma for the discussions on this topic.
\begin{thebibliography}{10}

\bibitem{Bla67}
S.J. Blank.
\newblock {\em Extending immersions of the circle}.
\newblock PhD thesis, Brandeis University, 1967.

\bibitem{BB2}
P.~Bonsma and F.~Breuer.
\newblock Finding fullerene patches in polynomial time.
\newblock submitted.

\bibitem{BB08}
P.~Bonsma and F.~Breuer.
\newblock Finding fullerene patches in polynomial time {I}: Counting hexagonal
  patches.
\newblock http://arxiv.org/abs/0808.3881v1, 2008.

\bibitem{Bou87}
A.~Bouchet.
\newblock Reducing prime graphs and recognizing circle graphs.
\newblock {\em Combinatorica}, 7(3):243--254, 1987.

\bibitem{BLS99}
A.~Brandst\"{a}dt, V.B. Le, and J.P. Spinrad.
\newblock {\em Graph classes, a survey}.
\newblock SIAM, 1999.

\bibitem{BCH03}
G.~Brinkmann, G.~Caporossi, and P.~Hansen.
\newblock A survey and new results on computer enumeration of polyhex and
  fusene hydrocarbons.
\newblock {\em J. Chem. Inf. Comput. Sci.}, 43:842--851, 2003.

\bibitem{BC09}
G.~Brinkmann and B.~Coppens.
\newblock An efficient algorithm for the generation of planar polycyclic
  hydrocarbons with a given boundary.
\newblock {\em MATCH Commun. Math. Comput. Chem.}, 2009.

\bibitem{BDN05}
G.~Brinkmann, O.~Delgado-Friedrichs, and U.~von Nathusius.
\newblock Numbers of faces and boundary encodings of patches.
\newblock In {\em Graphs and discovery}, volume~69 of {\em DIMACS Ser. Discrete
  Math. Theoret. Comput. Sci.}, pages 27--38. Amer. Math. Soc., Providence, RI,
  2005.

\bibitem{BGJ09}
G.~Brinkmann, J.E. Graver, and C.~Justus.
\newblock Numbers of faces in disordered patches.
\newblock {\em Journal of mathematical chemistry}, 45:263--278, 2009.

\bibitem{DFG01}
M.~Deza, P.~W. Fowler, and V.~Grishukhin.
\newblock Allowed boundary sequences for fused polycyclic patches and related
  algorithmic problems.
\newblock {\em J. Chem. Inf. Comput. Sci.}, 41:300--308, 2001.

\bibitem{Die}
R.~Diestel.
\newblock {\em Graph theory}.
\newblock Springer-Verlag, Berlin, third edition, 2005.

\bibitem{DDS08}
M.~Dutour~Sikiri\'{c}, M.~Deza, and M.~Shtogrin.
\newblock Filling of a given boundary by -gons and related problems.
\newblock {\em Discrete Applied Mathematics}, 156:1518--1535, 2008.

\bibitem{EM08}
D.~Eppstein and E.~Mumford.
\newblock Self-overlapping curves revisited.
\newblock http://arxiv.org/abs/0806.1724, 2008.

\bibitem{Fra70}
G.K. Francis.
\newblock Extensions to the disk of properly nested plane immersions of the
  circle.
\newblock {\em Michigan Math. J.}, 17(4):377--383, 1970.

\bibitem{GSH89}
C.P. Gabor, K.J. Supowit, and W.L. Hsu.
\newblock Recognizing circle graphs in polynomial time.
\newblock {\em Journal of the ACM}, 36(3):435--473, 1989.

\bibitem{Gav73}
F.~Gavril.
\newblock Algorithms for a maximum clique and a maximum independent set of a
  circle graph.
\newblock {\em networks}, 3(3):261--273, 1973.

\bibitem{Gra03}
J.~E. Graver.
\newblock The {}-patch boundary code problem.
\newblock {\em MATCH Commun. Math. Comput. Chem.}, (48):189--196, 2003.

\bibitem{GHZ02}
X.~Guo, P.~Hansen, and M.~Zheng.
\newblock Boundary uniqueness of fusenes.
\newblock {\em Discrete Applied Mathematics}, 118:209--222, 2002.

\bibitem{NLG09}
N.~Nash, S.~Lelait, and D.~Gregg.
\newblock Efficiently implementing maximum independent set algorithms on circle
  graphs.
\newblock {\em Journal of experimental algorithmics}, 13, 2009.

\bibitem{Sei98}
R.~Seidel.
\newblock The nature and meaning of perturbations in geometric computing.
\newblock {\em Discrete and Computational Geometry}, 19(1):1--17, 1998.

\bibitem{SW92}
P.W. Shor and C.J. Van~Wyk.
\newblock detecting and decomposing self-overlapping curves.
\newblock {\em Computational Geometry}, 2:31--50, 1992.

\bibitem{Spi94}
J.P. Spinrad.
\newblock Recognition of circle graphs.
\newblock {\em Journal of algorithms}, 16(2):264--282, 1994.

\bibitem{Sup87}
K.J. Supowit.
\newblock Finding a maximum planar subset of a set of nets in a channel.
\newblock {\em IEEE Transactions on computer-aided design}, 6(1):93--94, 1987.

\bibitem{Val03}
G.~Valiente.
\newblock A new simple algorithm for the maximum-weight independent set problem
  on circle graphs.
\newblock In {\em ISAAC 2003}, volume 2906 of {\em LNCS}, pages 129--137, 2003.

\end{thebibliography}
 
\newpage
\appendix

\section{Proofs of Section~\ref{sec:representations} and Section~\ref{sec:assignments}}

{\bf Proof} of Lemma~\ref{lem:cw_or_acw}:
Let  be a LIH from a hexagonal patch  with boundary cycle  of length  to , and let .
We first show that  is either a clockwise solution to the walk  or an anticlockwise solution to .

An index  is called {\em locally clockwise} if either  and  makes a right turn at , or  and  makes a left turn at .

We show that if some  is locally clockwise, then every index is locally clockwise. Suppose this is not true, so then there is an  that is locally clockwise such that  is not.
Assume first that  and . Then  makes a right turn at , but a left turn at . Therefore  and  do not lie at a common facial cycle of . Since  and  both have degree 2 in , all of the vertices  lie at a common inner face of . This is a contradiction since  maps faces of  to faces of .

In the case where , we consider the neighbor  of  that is not equal to  or , and the neighbor  of  that is not equal to  or . These again lie at a common face of , but if  makes a left turn at  and a right turn at , are mapped to two vertices that do not lie at a common face, which again yields a contradiction. The two other cases are analogous.
We conclude that if a solution contains a locally clockwise vertex, it is clockwise.

Now we relate this to the turning number.
Let  denote the number of vertices of degree  on the boundary of . If  is a clockwise solution then  and . 
We know that  since  contains no 5-faces. Hence . Similarly, if an anticlockwise solution exists then  follows, which proves the statement.\QED



{\bf Proof} of Proposition~\ref{propo:assignments_are_PAs}:
We show that if a clockwise solution  to  assigns  to , then  is a PA of .
Let  be an assignment path from  to . We have that  and  have the same height, since  is horizontal. 
 holds since  is 2-connected.  is then mapped to a non-zero length path in  (it does not turn back, since  is a LIH), so  follows.
All edges of  are interior edges of , so  and  have degree 3, and therefore  makes a left turn at  and . It follows that
 and  are PA-indices.
Since  is a LIH and  contains no boundary edges,  does not contain any of .
\QED


{\bf Proof} of Lemma~\ref{lem:well-def}:
We show that if two clockwise solutions  and  of  are equivalent, then .
Let  and , and let  demonstrate their equivalence. 
Note that  and  are both LIHs from  into  that map  to . As the LIH with this property is uniquely determined by Lemma~\ref{lem:unique_phi}, we conclude that .
In particular, any edge  is horizontal in  if and only if  is horizontal . Clearly an analogous statement holds for vertices being interior. Therefore  maps assignment paths to assignment paths. Since  for all  it follows that .
\QED


{\bf Proof} of Proposition~\ref{propo:apath_partition}:
Let  be a clockwise solution to . We show that every interior vertex of  and every vertex , where  is a PA-index, lies on a unique assignment path.
Let  be the set of horizontal non-boundary edges of , 
and let . 
Since  is a LIH,  has maximum degree at most 2.  contains no cycles, because these would have to be mapped to cycles of  but  contains no cycles with only horizontal edges. Hence  is a set of paths and isolated vertices.

It can be seen that vertices with degree 2 in  are interior vertices of , and that vertices with degree 1 in  are equal to  for some PA-index .
Hence the path components of  (paths of non-zero length)
are all assignment paths. 
Since all assignment paths in  are also part of , we see that there is a one-to-one correspondence between assignment paths in  and non-trivial components of . 
We also see that every interior vertex of  and every vertex  where  is a PA-index lies on one such path. The statement follows.\QED


{\bf Proof} of Proposition~\ref{propo:separation}:
We show that if a solution  assigns  to  and , then it does not assign  to .
Suppose  contains an assignment path  from  to , and an assignment path  from  to . 
By Proposition~\ref{propo:apath_partition},  and  have no vertices in common.
But since the (distinct) end vertices of the paths appear in the order , ,  and  along a boundary cycle of the plane graph , this is impossible.
(Formally, to obtain a contradiction, we may use ,  and the boundary cycle of  to exhibit a subdivision of  that is embedded with all vertices on the boundary, which then would yield a planar embedding of .)
\QED


For the proof below and later proofs in the appendix, it is important to distinguish between two different kinds of horizontal edges of : \term{horizontal left} (\term{horizontal right}) edges are edges that follow a vertical edge after turning left (right). Note that this partitions the edges of  into vertical edges, horizontal left edges, and horizontal right edges, and that every face contains two of each. The same holds for faces in a solution ;
Recall that if patch  is mapped by a LIH  to , this allows us to define vertical and horizontal (left / right) edges in . Similarly, we will talk about vertices of  that lie to the left / below etc.\ other vertices. This is also defined by  and the chosen drawing of .

\medskip

{\bf Proof} of Lemma~\ref{lem:injective}:
We show that if  for two solutions  and , then these solutions are equivalent.
Let  and .
We construct the isomophism  from  to  that will demonstrate the equivalence as follows. For all , . This defines  for boundary vertices. Every non-boundary vertex lies on a unique assignment path (Proposition~\ref{propo:apath_partition}). Suppose such a vertex  lies on an assignment path  from  to . Then  and thus . The assignment path  from  to  in  is also mapped by  to  and therefore has the same length as  (since  and  are LIHs). Now if  is the -th vertex on ,  will map  to the -th vertex of . This defines . Since every vertex of  lies on the boundary or on an assignment path, the function  is defined for every vertex of , and since the same holds for ,  is a bijection. By definition  maps boundary vertices to the correct boundary vertices, so to demonstrate that  is an equivalence between  and , it only remains to show that it is an isomorphism.


We only show that edges of  are mapped to edges of  by . By symmetry a similar statement then follows for , which proves that  is an isomorphism. Clearly  maps boundary edges of  to boundary edges of . Observe that every horizontal non-boundary edge of  
lies on an assignment path. Therefore  also maps horizontal edges of  to edges of . What remains are vertical edges of  that do not lie on the boundary. Note that  maps horizontal left (right) edges of  to edges of  of the same type, and by observing the same for , it also follows that if a vertical edge is mapped to an edge, it is mapped to a vertical edge again.


Suppose there exists a (vertical, interior) edge of  that is not mapped to an edge of  by . Let  be such an edge such that all edges that lie to the left of it
are mapped to edges of . Suppose  lies below .
 is incident with two inner faces of , so we may choose  to be the inner face of  on the left side of . Note that all other edges of  are mapped to edges of ; four edges are horizontal, and the other vertical edge is mapped by our choice of .

Let , , , ,  and  respectively be the images under  of the vertices of . 
The edges  and  lie on a common face of  (since  has degree at most 3). We show that they lie on a common {\em inner} face of . If not, then both  and  are boundary edges. Then the corresponding edges  and  of  are boundary edges too, and thus these two edges share both an inner face and the outer face. Since  is 2-connected, it follows that . Because both  and  are clockwise solutions, . Hence the two edges in  also share two faces, and thus one inner face. 


Let  be the inner face of  on which these two edges lie. Since  maps to edges of the same type,  and  are horizontal left and horizontal right edges respectively.
Since  maps inner faces of  to inner faces of ,  is a vertical edge.  is incident with at most one vertical edge ( is a LIH), so we may conclude that  (here we use the fact that vertical edges are not mapped to horizontal edges, so  is vertical). Continuing this reasoning shows that . Hence , a contradiction with the choice of . We conclude that  is an isomorphism, which concludes the proof.\QED



\section{The proof of Lemma~\ref{lem:surjective}}
\label{sec:surjective}

Before we can prove Lemma~\ref{lem:surjective} we need to introduce some new terminology and lemmas.
For a closed walk , the {\em subwalk of  from  to } is the walk  of length . 
If  then, more precisely, this is the walk .
The subwalk of  from  to  will be denoted by \notat{W_{i,j}}.
If  is a closed walk, then for any , the walk  is called a \term{rotation} of . We will write \notat{W'\approx W} to express that  is a rotation of .
For a pair of walks  and  with  and , \notat{W\circ W'} denotes the \term{concatenation} of  and , which is .
In sequences, the notation \notat{(a)^b} means that  copies of  are inserted in the sequence at this point. For instance,  denotes the sequence .


Let  be a closed walk in .
For indices , let \notat{n(i)} be the first PA-index after  (not equal to ). So with respect to the walk  shown in Figure~\ref{fig:PAindices}(b), , , etc.
The subwalks of the form  for any PA-index  are called the \term{pieces} of .


\paragraph{Elementary Cycles}
Let  be a proper assignment set of a closed walk  in . 
We will now define how such a tuple  gives {\em elementary cycles}, which correspond to closed walks in . Informally, for any index  the unique elementary cycle that contains  can be found as follows. This is illustrated in Figure~\ref{fig:elcycs}, where the proper assignment given by the solution shown in Figure~\ref{fig:PAindices}(a) is used. Arcs are shown to indicate the direction of the elementary cycles, and the head of the arc indicates the first vertex.
 
\begin{figure}
\centering
\scalebox{0.75}{WAW,A}
\caption{Elementary cycles in  given by a proper assignment  of .}
\label{fig:elcycs}
\end{figure} 
 
 
Start at , and continue along  (in the direction of increasing indices) until the first PA-index  is found. Let  be the (unique) assignment in  that contains . Then continue along the horizontal path  in . At , follow  again until the next PA-index , and then follow  where , etc. Continue with this procedure, taking alternatingly pieces of  and horizontal paths that correspond to assignments in  until we arrive again at . 
Observe that this procedure ends and that we do actually arrive at  again this way. We consider the choice of starting vertex to be irrelevant, hence in the following formal definition we fix a canonical rotation.
An \term{elementary cycle} of  is a walk in  of the form

where  for all , and . In addition, we require that  for all . This last condition fixes the canonical rotation. 
Note that elementary cycles that start at different indices of  may still yield the same walk in .
Therefore we also consider a sequence  of numbers that give the corresponding indices of . We insert  in this sequence for the vertices that correspond to vertices of horizontal paths instead of parts of . For example, for the above choice of ,

where  and  are the length of  and  respectively. 
 (Obviously, if , then  should be read as , where  is the length of , etc.)

Formally, an elementary cycle is now a pair  of a closed walk  in  and sequence of numbers  that are of the form explained above. 
This formal definition is needed to clearly define what the {\em number} of elementary cycles of  is: elementary cycles are still considered different even if they yield the same walk, but admitting different rotations is irrelevant.
However, below we will often informally denote elementary cycles just by ; the index sequence  is clear from how we denote . 
Note that for every  there is a unique elementary cycle  such that  contains  and  consecutively. In a slight abuse of notation, from now on we will often simply express this statement as follows: there is a unique \elcyc\  that contains the walk edge .
In the special case where , there is only one elementary cycle , which has .


\medskip

A walk in  in which every vertical edge is followed by a horizontal right edge and preceded by a horizontal left edge is called a \term{right-turn walk}.


\begin{propo}
\label{propo:elcyc_rightturn}
Let  be a proper assignment set for a walk  in . Then every elementary cycle  of  is a right-turn walk.
\end{propo}
\PF
Any vertical edge of  must come from a piece of . So let  be this vertical edge. If  turns left at , then  is a PA-index and  turns right. If  turns right at , then  is not a PA-index and  turns right as well. Hence in both cases, a vertical edge in  is followed by a horizontal right edge.
Similarly,  turns right at  in both the case that it is a PA-index and the case that it is not, hence vertical edges in  are preceded by horizontal left edges.
\QED

For the following proof, 
we use the following vertex labelling for . See also Figure~\ref{fig:rightturn}, which illustrates the next Proposition.




\begin{figure}
\centering
\scalebox{0.75}{b_{2,0}b_{5,1}b_{4,0}b_{7,1}b_{6,0}b_{2,1}b_{1,0}b_{3,1}W_0W_1b_{5,0}b_{3,0}b_{4,1}b_{6,1}b_{7,0}b_{8,1}}
\caption{A right-turn walk  in  with .}
\label{fig:rightturn}
\end{figure}

\begin{propo}
\label{propo:turnnum_closedrightturnwalk}
Let  be a closed right-turn walk in . Then . If , then  has a clockwise solution.
\end{propo}

\PF
For a closed walk  in  of length  and any  we define  to be the number of indices  with  such that  makes a right turn at  minus the number of those indices where  makes a left turn. So  and , and for every , .

Every closed walk in  contains a vertical edge (since walks do not turn back), so w.l.o.g. assume . Since  is a right-turn walk, after this a horizontal right edge follows, which is part of an alternating sequence of horizontal right and left edges. This sequence continues until a horizontal left edge is followed by a vertical edge, and after that an alternating sequence of horizontal right and left edges again follows (note that the walk cannot close before this point).
So for some  and  we have 

(In Figure~\ref{fig:rightturn},  and . Note that in general  is also possible.)
Choose  maximum, so either the walk  closes at this point (), or  continues with another vertical edge.
In either case, the sequence  is then .
Continuing this reasoning shows that  can never decrease below 6 when , so we conclude . In addition, if , then the walk cannot contain another vertical edge, so

It is easily seen that in this case the subgraph of  induced by the vertices of  is a clockwise solution to .
\QED






\paragraph{Splitting a walk}
\begin{figure}
\centering
\scalebox{0.75}{yW'=W_{0,32}\circ H_{32,0}A'W''=W_{32,0}\circ H_{0,23}}
\caption{Splitting the walk  and assignment set  into two.}
\label{fig:split}
\end{figure}
In the following lemmas we use the following notations. Let  again be a proper assignment set for the closed walk  in . 
We assume  contains a PA  such that  (i.e.  is a piece of ).
We now consider the two new closed walks \notat{W'} and \notat{W''} in . Note that  is in fact an \elcyc\ of , and that for all , . Figure~\ref{fig:split} illustrates this for the walk and assignment from Figure~\ref{fig:elcycs} (note that ).

We remark that although we consider various walks in  in this section, the notations  and  are always defined with respect to .
Let
\notat{A'}. 
(We denote  and  as  and  respectively.)
Observe that  is a PA-index of  if and only if it is a PA-index of  and . Thus it is easily seen that:
\begin{propo}
\label{propo:newASisproper}
 is a proper assignment set for .
\end{propo}

The above construction of smaller walks and corresponding assignment sets from a given pair  allows various induction proofs, justified by the next lemma.


\begin{lem}
\label{lem:inductionable}
Let , ,  and  be as defined above. 
Then
\begin{enumerate}
\item
For every \elcyc\  of , there is an \elcyc\  of  with .
\item
 has one more \elcyc\ than .
\end{enumerate}
\end{lem} 
\PF
We use the notation  and  for the walk , which are similar to the notations  and  for , so  denotes the next PA-index of  after , and  denotes the horizontal path between  and .
Let  be an \elcyc\ of  with

All PAs in  also appear in , and all PA-indices of  are PA-indices of . It follows that  is also an \elcyc\ of , unless one of the pieces, say  contains the part of  corresponding to . More precisely, this happens when  and . 
(In Figure~\ref{fig:split},  but .)
But in that case, we may replace  with , and choose the appropriate rotation (starting with ), which yields an elementary cycle  of  with . This proves the first statement.


The above construction maps \elcyc s of  to \elcyc s of . It is easy to see that they are all mapped to different \elcyc s, which only contain pieces that are subwalks of , and that every \elcyc\ of  that contains a piece of  is covered this way. It remains to consider \elcyc s of  that contain a piece of . Since  and , there is only one such \elcyc\  (with , as defined above). This proves the second statement.\QED



As a first application of Lemma~\ref{lem:inductionable}, we can determine the number of \elcyc s.

\begin{corol}
\label{cor:num_elcycs}
Let  be a proper assignment set for closed walk  in , and let  be the number of PA-indices of . Then the number of elementary cycles of  is .
\end{corol}
\PF
If  then there are no PA-indices, and  itself is the only elementary cycle, which proves the statement. 

Otherwise we can use induction: choose a PA  with . Such a PA exists since  is a non-crossing perfect matching on the PA-indices. W.l.o.g we may assume that , since considering a different rotation of  and changing  accordingly does not change  or the number of \elcyc s.
 
Now consider ,  and  as defined above using .
Let  denote the number of PA-indices of .
 is an \elcyc\ of , hence a right-turn walk, which has no PA-indices.
Therefore every PA-index of  other than  or  corresponds to a PA-index in , so .
By Lemma~\ref{lem:inductionable} the number  of \elcyc s in  is equal to , where  is the numbers of \elcyc s of . 
Since  is a proper assignment set for  (Proposition~\ref{propo:newASisproper}) we may use induction, so .
\QED


The above corollary will now be used to deduce that all elementary cycles defined by a {\em proper} assignment set have turning number 1, and hence admit a clockwise solution by Proposition~\ref{propo:turnnum_closedrightturnwalk}.


\begin{lem}
\label{lem:key_counting}
Let  be a proper assignment set for a closed walk  in . Then  if and only if every elementary cycle  of  has 
\end{lem}

\PF
The number of PA-indices of  is denoted by .
The number of left turns that  makes at non-PA-indices is denoted by . Since  makes a left turn at every PA-index, we have 
Let  denote the set of all elementary cycles of .
When summing the difference between right and left turns over all elementary cycles we obtain

Here we used the following observations. (i) Elementary cycles make right turns at PA-indices of , and every PA-index contributes a right turn to two elementary cycles. (ii) Non-PA-indices of  contribute the same type of turn to one elementary cycle. (iii) All indices of elementary walks that do not correspond to pieces of  correspond to internal vertices of assignment paths; these vertices of assignment paths contribute a left turn to one elementary cycle and a right turn to another, hence these terms cancel.
Combining this with  (Corollary~\ref{cor:num_elcycs}) yields



Because  for all  (Proposition~\ref{propo:elcyc_rightturn}, Proposition~\ref{propo:turnnum_closedrightturnwalk}), this proves the statement.
\QED









\medskip

The proof of the next lemma is illustrated in Figure~\ref{fig:SGL} (using the same example as before).
\begin{figure}
\centering
\scalebox{0.9}{v'_1v'_3v'_2v''_2\Bt_x=v''_0v_0v_2v_4v''_1v''_3\Bo_0=v'_4v_3v_1\Bo_y=v''_4=\Bt_0v'_0H''H'H}
\caption{Combining two partial solutions.}
\label{fig:SGL}
\end{figure}
\begin{lem}
\label{lem:gluing-lemma}
Let , ,  and  be as defined above.
If  and  are clockwise solutions of  and  respectively, then a clockwise solution  of  exists with 

\end{lem}
\PF
Let  be a clockwise solution to , and  be a clockwise solution to . 
Let  (recall that  is the length of ), so .

Let , and let .
Note that these paths indeed have the same length  and

Since  is a PA of , we have .
 and  are PA-indices, so  makes left turns at  and , and therefore  makes right turns at  and , and  makes right turns at  and . Because both  and  are clockwise solutions,  and  follows.
Since these two paths are mapped to the same paths in  but in reverse direction, and both  and  are clockwise solutions, we see that  has degree 2 when  has degree 3 and vice versa, for .



Construct  by starting with a copy of  and a copy of , and for all , identify the vertex  of  with the vertex  of . Call the resulting vertex .
For , this results in two parallel edges between  and . Delete one edge of every such parallel pair. 
Because , this gives again a 2-connected graph.
Using the above observations on the degrees of  and , we see that  for all : either a vertex of degree 2 is identified with a vertex of degree 3 and two incident edges are removed (when ), or two vertices of degree 2 are identified and one incident edge is removed (when ).

Choose an embedding of  in which every inner face of  or  is again an inner face of , and which has boundary cycle .
A LIH  from  is constructed by setting  for all  and  for all , and  for the new vertices (see Equation~(\ref{eq:phi})).




We observe that  is a hexagonal patch: 
all inner faces of  correspond to inner faces of  or , and thus all have length 6. The degree constraints hold since the new vertices  have  and boundary vertices of  and  that were not identified remain boundary vertices.



Next we show that  is a LIH. For vertices of  that have no neighbor in  or no neighbor in , the local injectivity follows from the local injectivity of  and . 
The only two vertices of  for which this does not hold are  and . But the three neighbors of  in  are mapped to ,  and a vertex on , which are all different. A similar statement holds for . This proves that  is again a LIH.


 
We observed above that the boundary cycle of  is 
 
which is mapped by  exactly to . 
So  is a solution to . Since we started with clockwise solutions, it is also obviously a clockwise solution.
(By Lemma~\ref{lem:cw_or_acw} we do not have to check this for all boundary vertices.)



	
An assignment path from  to  in  yields an assignment path from  to  in .
In addition, the path  in  is mapped by  to , and no internal vertices of this path lie on the boundary of . Hence this solution assigns  to . Now all PA-indices of  are accounted for ( contains no PA-indices), which shows that 
.
\QED






Finally, we have collected all the ingredients that are necessary to prove the remaining lemma.

\medskip


{\bf Proof} of Lemma~\ref{lem:surjective}:
We show that if a proper assignment set  is given for a walk  with , then a clockwise solution  of  with  exists.

If  then since  is a proper assignment set, this implies that  has no PA-indices and  itself is the only elementary cycle of . 
This is a right-turn walk by Proposition~\ref{propo:elcyc_rightturn}, and since , it has a clockwise solution  by Proposition~\ref{propo:turnnum_closedrightturnwalk}. Note that  since there are no PA-indices.



If , then choose an arbitrary  with  (this exists since  is a non-crossing perfect matching). We may again assume w.l.o.g. that .
Use this to define ,  and  as before.
 is a proper assignment set for  (Proposition~\ref{propo:newASisproper}).
Lemma~\ref{lem:inductionable} shows that for every \elcyc\  of , an \elcyc\  of  with  exists. By Lemma~\ref{lem:key_counting},  follows from , so  for every such \elcyc\ . 
Therefore by applying Lemma~\ref{lem:key_counting} again, we obtain . 
At this point we have a new closed walk  in  with turning number 1, with fewer PA-indices, and a proper assignment set  for it. Hence by induction,  admits a clockwise solution  with .
 itself is an \elcyc\ of , so  (Lemma~\ref{lem:key_counting}), and therefore  admits a clockwise solution  as well (Proposition~\ref{propo:elcyc_rightturn}, Proposition~\ref{propo:turnnum_closedrightturnwalk}). 
Now Lemma~\ref{lem:gluing-lemma} shows that  and  can be combined into a clockwise solution  for  with .
\QED



\section{Proofs of Section~\ref{sec:circlegraphs}}

{\bf Proof} of Lemma~\ref{lem:Sroutine}:
We show that subroutine  correctly calculates  when the stated  values are known, in time .
Clearly, the algorithm only uses values  with  for the calculations.

Observe that throughout the algorithm, the value of  equals the size of some PM of .
We now show that in some line, the size of a MPM is considered, which proves correctness.


Let  be a MPM of . If  then  which is considered in line~1. Now suppose . If  contains no edge incident with , it is a PM of  and considered in line~2. Otherwise, let . If , then  consists of this edge and a PM of , which is considered in line~6. Otherwise, because  is non-crossing, it can be partitioned into a MPM of  and , which is considered in the for-loop.

The complexity of the algorithm is determined by the for-loop, which iterates at most  times.
\QED

{\bf Proof} of Lemma~\ref{lem:Nroutine}:
We show that subroutine  correctly calculates  when the stated  and  values are known, in time .
The algorithm only uses values  with  and values  with  for the calculations. 

Clearly, line~1 returns the correct answer (in this case the empty set is the unique MPM). Otherwise, the algorithm adds  to the number  whenever  different MPMs of  are found that have not been considered earlier. We show that all cases are considered and no MPMs are double counted, which shows that the correct answer is returned in line~7.

If  then all MPMs of  are also MPMs of , which explains line~3. This accounts for all MPMs of  that do not contain an edge incident with .  admits MPMs  that contain an edge  if and only if . Then  is a MPM of , and there is a bijection between such MPMs, which explains line~6. It remains to consider MPMs  of  which contain an edge  with . 
These can be decomposed into a PM of  and a PM of , which must be MPMs, so . In fact, if  then every combination of a MPM of  and a MPM of  gives a unique MPM of  that contains , which explains line~5.
All cases are now considered, so at the end of the algorithm, .

The complexity of the algorithm is determined by the for-loop, which iterates at most  times.
\QED



\end{document}
