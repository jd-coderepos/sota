\documentclass[copyright,creativecommons]{eptcs}
\providecommand{\event}{GandALF 2010} \usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{xspace}
\usepackage{color}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{formal}
\usepackage{tikz}
\usetikzlibrary{automata}
\usetikzlibrary{snakes}
\usetikzlibrary{shapes}
\usetikzlibrary{patterns}
\usetikzlibrary{arrows}
\usepackage{color}
\usepackage{pdfsync}
\usepackage{varioref}
\usepackage{algorithm}
\usepackage{subfigure}
\usepackage{multicol}
\usepackage{amsthm}
\usepackage{rotating}
\usepackage{booktabs,colortbl}
\usepackage{paralist}
\usepackage{courier}
\newcommand{\ie}{i.\,e.~}
\newcommand{\eg}{e.\,g.~}


\pgfrealjobname{paper}

\begin{document}

\title{Exploiting the Temporal Logic Hierarchy and the Non-Confluence Property for Efficient LTL Synthesis}

\author{Andreas Morgenstern and Klaus Schneider
\institute{University of Kaiserslautern\\
	P.O. Box 3049 \\
	67653 Kaiserslautern, Germany \\
	email: \{morgenstern,schneider\}@cs.uni-kl.de}
}
\def\titlerunning{Efficient  Synthesis}
\def\authorrunning{A. Morgenstern \& K. Schneider}

\newtheorem{definition}{Definition}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\newtheorem{remark}{Remark}
\newtheorem{example}{Example}
\def\qed{\hfill \rule{2mm}{2mm}}



\maketitle

\begin{abstract}
The classic approaches to synthesize a reactive system from a linear temporal logic () specification first translate the given  formula to an equivalent -automaton and then compute a winning strategy for the corresponding -regular game. To this end, the obtained -automata have to be (pseudo)-determinized where typically a variant of Safra's determinization procedure is used. In this paper, we show that this determinization step can be significantly improved for tool implementations by replacing Safra's determinization by simpler determinization procedures. In particular, we exploit (1) the temporal logic hierarchy that corresponds to the well-known automata hierarchy consisting of safety, liveness, Büchi, and co-Büchi automata as well as their boolean closures, (2) the non-confluence property of -automata that result from certain translations of  formulas, and (3) symbolic implementations of determinization procedures for the Rabin-Scott and the Miyano-Hayashi breakpoint construction. In particular, we present convincing experimental results that demonstrate the practical applicability of our new synthesis procedure.
\end{abstract}


\begin{section}{Introduction}

In formal verification, we have to check for a given implementation  and a given  property  whether  satisfies  in any environment, which is usually written as . In the more general synthesis problem, we have to check whether an (incomplete) implementation\footnote{It is allowed that  consists of only the environment.}  can be refined by another system (often called a controller)  such that a given property  holds, i.e., whether there exists a system  such that  holds. This means that the combined behavior of  and  satisfies  in \emph{any} environment. This controller synthesis problem can be naturally viewed as an infinite game between the controller and an adversary environment.

Due to the enormous progress made during the past two decades, the tools used in formal verification can now be applied to real-world problems, and therefore are routinely used in industrial practice. In contrast, the so-far known tools for the synthesis of  specifications can only be applied to small examples which is due to the implementation of these tools: The currently available procedures used in these tools consist of two steps: Similar to verification, the first step consists of translating the  formula  to an equivalent nondeterministic -automaton . While this automaton  can be directly used for symbolic model checking, it is favorable to have a deterministic automaton for constructing a -regular game from the obtained automaton  and the incomplete implementation . This determinization step is the main reason for the high complexity of the synthesis problem for .

In particular, Safra's construction \cite{Safr88} is often used for this purpose. This construction generates for a given Büchi automaton with  states an equivalent deterministic Rabin automaton with  states and  acceptance pairs. However, Safra's construction is extremely difficult to implement \cite{KlBa06}, and unfortunately not amenable to a symbolic implementation. Indeed, a major drawback of Safra's construction is that known implementations use an \emph{explicit representation} of the automata, since the states of Safra's automaton consist of trees whose nodes are labeled with sets of states. This is probably the main reason why tools for synthesis lack behind (compared to model checking tools that achieved a significant breakthrough first by symbolic state space representations, and second by the use of efficient SAT solvers). As a consequence, tools for  synthesis are still limited to very small formulas with only few temporal operators.

In this paper, we show how we can always replace Safra's determinization procedure by simpler ones like the Rabin-Scott subset construction and the Miyano-Hayashi breakpoint construction \cite{MiHa84,Schn03}. To this end, we exploit the membership of the subformulas of a given formula to the classes of the temporal logic hierarchy as well as a recently published determinization procedure for non-confluent -automata \cite{MoSc08}.

The \emph{temporal logic hierarchy} \cite{ChMP92,Schn03} has been developed in correspondence to the -automata hierarchy \cite{Land69} that has been inspired by the Borel hierarchy known from descriptive set theory. As the -automata hierarchy, the temporal logic hierarchy distinguishes between six different classes (cf. Figure~\ref{fig:automata_hierarchy}) of properties. It is moreover known that each class can be characterized by a deterministic class of -automata that differ in their acceptance conditions as explained in Section~\ref{AutomataHierarchySec}. While Manna and Pnueli's original definition of the hierarchy was a semantic one (meaning a  formula belongs to a class iff there is an equivalent -automaton in that class), Schneider \cite{Schn01b,Schn03} presented syntactic characterizations of these classes by means of simple grammars for each of these logics (cf. Figure~\ref{fig:grammar}). Clearly, such syntactic characterizations are incomplete (in the sense that an equivalent formula may belong to a different class), but they are sufficient for practical use: In general, the membership test given by these grammars yields an upper bound of the temporal logic class, and in practice, it often yields the precise class, making therefore more expensive tests unnecessary.

In the following, we will therefore also make use of a syntactic, and therefore incomplete, but more efficiently testable definition to come up with a very efficient  synthesis procedure. The key idea of this procedure is thereby based on the following observation: It is well-known since \cite{ChMP92} that for every  formula of each temporal logic class, there is an equivalent deterministic automaton with the corresponding acceptance condition. However, it was \emph{previously not recognized} that we can avoid complex determinization procedures like Safra's one once we can express a given  formula as a boolean combination of lower class subformulas.

In fact, by the syntactic representation, each formula in the highest class is already a boolean combination of co-Büchi properties, so that we can obtain a Safra-less determinization procedure by first computing deterministic co-Büchi automata for these subformulas, and then computing the boolean closure of the obtained deterministic automata (which is simple as outlined in \cite{Schn03}). The translation of the subformulas to symbolically represented non-deterministic co-Büchi automata has been presented in detail in \cite{Schn01b,Schn03}, and their determinization can be performed using the Miyano-Hayashi breakpoint construction \cite{MiHa84,Schn03}. We can even improve this procedure by determining tighter classes like safety and liveness properties so that even the Rabin-Scott subset construction is sufficient for the determinization.

The second major ingredient of our efficient synthesis procedure are \emph{symbolic determinization constructions} we have developed in \cite{MoSL08} for the Rabin-Scott subset construction \cite{RaSc59} and the Miyano-Hayashi breakpoint construction: For a given symbolically represented nondeterministic automaton, we directly construct symbolic descriptions of the corresponding deterministic automata. Although we can not avoid one exponential step (namely the enumeration of the reachable states of the nondeterministic automaton), we achieved that the symbolic description of the deterministic automaton can be obtained without building it explicitly. Thus, we avoid the enumeration of the exponentially larger state space of the \emph{deterministic} automaton.

Thus, we are able to translate every formula of the temporal logic hierarchy to an equivalent deterministic -automaton. Due to results of \cite{ChMP92}, one can translate every  formula to a formula contained at least in the highest class of this hierarchy. However, all known such translations require a determinization step, and therefore, they are not useful for our purpose. Thus, we currently have the restriction that the given  formulas must already syntactically belong to one of the classes of the hierarchy. In practice, we found that this is almost always the case (in more than 95\% in our benchmarks), and in some other cases, it was not too difficult to rewrite the formula to achieve this membership (checking the equivalence of the rewritten  formulas is no problem by verification tools).

To handle the remaining rare cases of formulas that can not be easily rewritten to classes of the temporal logic hierarchy, we use as a final ingredient of our synthesis procedure our recently published determinization procedure for non-confluent automata \cite{MoSc08}. This procedure can be applied to any given  formula, provided we use a translation to -automata that generates non-confluent automata (which exists!).

{\em In this paper, we build upon the mentioned results we developed in our previous work, i.e., we first try to  decompose a given specification into subformulas that syntactically belong to a class of the temporal logic hierarchy, and apply symbolic implementations of the Rabin-Scott and the Miyano-Hayashi constructions to translate these subformulas to deterministic -automata. If this is not directly possible, we make use of a simple translation for full  to non-confluent automata so that we can apply our recently published determinization procedure \cite{MoSc08}.}

Having obtained a deterministic automaton, we use standard automata translations to obtain (generalized) deterministic parity automata for each subformula which has to be combined in one conjunctive generalized parity condition. The obtained generalized parity automaton yields a generalized parity game which is solved in the final step of our algorithm using the symbolic algorithm given in \cite{ChHP07}.

The outline of this paper is at follows: after starting with more details on related work (Section~\ref{RelatedWork}) and some basic definitions (Section~\ref{BasicDefinitions}), we explain how we can make use of the temporal logic hierarchy (Section~\ref{TemporalLogicHierarchySec}). The second ingredient is the exploitation of the non-confluence property that is explained in Section~\ref{NonConfluenceProperty}. The added value and the core of this paper is the combination of these results in Section~\ref{SymbolicControllerSynthesis} to obtain an efficient symbolic synthesis procedure for full . We conclude the paper by experimental results in Section~\ref{ExperimentalResults}.
\end{section}

\begin{section}{Related Work}

\label{RelatedWork}
There are already symbolic implementations of the subset and breakpoint construction \cite{AEFK05,BCPR06}. In \cite{BCPR06}, procedures are described to compute a symbolically represented nondeterministic automaton from a given alternating automaton, i.e., a non-determinization procedure. Although there are some similarities to our procedure, non-determinization of alternating automata and determinization of nondeterministic automata is different for -automata \cite{TuSc05a}. Closer to our determinization procedure is \cite{AEFK05} which generates a deterministic automaton for the safety fragment, and thus implements the subset construction. However, they also start with an alternating automaton which is then translated to an explicitly represented nondeterministic automaton. The nondeterministic automaton is generated on the fly, thus avoiding the construction of the whole explicit automaton. However, this step crucially relies on a translation from alternating automata to the corresponding nondeterministic automata while our procedure is independent of the previous translation from temporal logic to nondeterministic automata. In particular, it is not obvious how the work \cite{AEFK05} could be generalized to more expressive classes like co-Büchi automata.

Since it became clear that the determinization step is the major hurdle in the synthesis of full , a recent research trend aims at avoiding determinization by somehow integrating the synthesis procedure with lightweight `pseudo'-determinization procedures. In \cite{KuVa05a}, Kupferman and Vardi present an approach that avoids Safra's determinization and goes through universal co-Büchi word and weak alternating tree automata instead. This approach has been refined in \cite{KuPV06} to allow compositional synthesis or to allow also controller synthesis. A major disadvantage of the approach presented in \cite{KuVa05a} regarding controller synthesis is that it suffers from an exponential blowup with respect to the size of the system under control, even if this system is deterministic. Our approach avoids this exponential blowup. Jobstmann and Bloem developed in \cite{JoBl06} optimizations for this Safra-less approach and developed the tool `Lily'. This tool was the first implementation that is able to synthesize designs that satisfy arbitrary  specifications. Although Kupferman and Vardi's approach is potentially amenable to a symbolic implementation, the tool Lily is implemented explicitly, so that is also limited to small  formulas only.

In practice, specifications are not given as a single large formula; instead they consist of several relatively small subformulas. In \cite{SoSR08}, an algorithm for  synthesis is presented that assumes that the overall specification is given as a conjunction of  formulas. Instead of performing determinization for the whole specification, the algorithm generates deterministic automata using the approach of \cite{Pite06} explicitly. Those explicitly represented automata are then encoded symbolically to obtain a generalized parity game which is then solved using the generalized parity algorithm given in \cite{ChHP07a}. Our algorithm assumes a similar setting: We also assume that the specification is a conjunction of  formulas. The determinization is also performed only on the nondeterministic automata obtained from these small subformulas, and the final automaton for the overall specification is obtained by combining the single deterministic automata. The main difference is however that we never represent the automata explicitly, so that we expect that our algorithm scales much better (unfortunately, the tool mentioned in \cite{SoSR08} is not publicly available so that we can not perform comparisons).
\end{section}
\begin{section}{Basic Definitions}
\label{BasicDefinitions}
\subsection{Linear Temporal Logic}

For a given set of Boolean variables (propositions) , we define the set of  formulas by the following grammar\footnote{We neglect past temporal operators, although these are also available in our framework.}:
.
Additionally, we define , , , and  as abbreviations for , , , and , respectively.

To define the semantics of an  formula , we consider infinite sequences of truth assignments to its atomic propositions, i.e., words in . We denote the -th element of  by , i.e., . The semantics of  formulas is then defined as follows:
\begin{itemize}
\item for , we have  iff 
\item  iff 
\item  iff  or 
\item  iff 
\item  iff there exists  such that  and for all  with  and , we have 
\end{itemize}
For a formula  and a position  such that  holds, we say that  holds at position  of . If  holds, we say that  holds on , and write simply .




\subsection{-Automata on Infinite Words}

\begin{definition}[-Automata]
Let  be a finite set of state variables. Let  be a finite set of input variables disjoint from  that defines an alphabet . Then, a \emph{-automaton}  over the alphabet  is given by a finite set of states , a set of initial states , a transition relation , a labeling function  with  for  and an acceptance component .
\end{definition}

\noindent Using standard terminology, we say that  is \emph{deterministic}, if exactly one initial state exists and for each  and each input  there exists exactly one  with  .

The acceptance of a word is defined with respect to the set of runs: Given an automaton  and an infinite word  over . Each infinite word  with  and  is called a run of  through . The set of all runs of  through  is defined as follows: We extend the labeling function to runs by defining .
Note that  is a path over , called the \emph{trace} of . Since every trace of a automaton  over a word  is a path over , we can use  to specify the acceptance conditions for -automata. To simplify notation, we identify each run with its trace and write  to mean that . Another form of acceptance conditions are parity conditions that are conveniently defined by a priority function  for some . A run is accepted by a parity condition if the minimal priority seen infinitely often is even. A generalized (conjunctive) parity condition is given by  priority functions and the run is accepted iff it is accepted by each parity condition separately.


Since the states are uniquely identified by the state variables (we have  for )
we can represent each state (set) with a propositional formula.
Hence, we can already represent the set of initial states by a propositional formula  over .
Introducing moreover for each variable  a next-state variable  allows us to represent also
the transition relation by a propositional formula  over .
\end{section}
\begin{section}{Exploiting the Temporal Logic Hierarchy}
\label{TemporalLogicHierarchySec}

\subsection{The Automata Hierarchy}
\label{AutomataHierarchySec}
In the past, several kinds of acceptance conditions have been proposed and their different expressivenesses have been studied in depth. In particular, the following acceptance conditions have been considered \cite{Wagn79,Thom90a,Schn03}:

\begin{itemize}
\item A run is accepted by a safety condition  with a state
set  if the run exclusively runs through the set .
\item A run is accepted by a liveness condition  with
a state set  if the run visits at least one state of the set  at least once.
\item A run is accepted by a Büchi condition  with
a state set  if the run visits at least one state of the set 
infinitely often.
\item A run is accepted by a co-Büchi condition 
with a state set  if the run visits only states of the set 
infinitely often.
\end{itemize}

\noindent The above conditions define the corresponding automaton classes , , , and , respectively. Moreover,  and  automata have acceptance conditions of the form  and , respectively.

The expressiveness of these classes is illustrated in Figure~\ref{fig:automata_hierarchy}, where  means that for any automaton in , there is an equivalent one in . Moreover, we define  and . As can be seen, the hierarchy consists of six different classes, and each class has a deterministic representative.

\begin{figure}
\tikzstyle{tikblock} = [draw, fill=blue!6, rounded corners]
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,auto]
    	 \node[tikblock,minimum height=2cm] (G) at (0,5) {};
	 \node[tikblock,minimum height=2cm] (F) at (0,1)  {};
	\node[tikblock,minimum height=2cm] (Prefix) at (4,3) {};
	\node[tikblock,minimum height=2cm] (GF) at (8,5) {};
	\node[tikblock,minimum height=2cm] (FG) at (8,1) {};
	\node[tikblock,minimum height=2cm] (Streett) at (12,3) {};
								
	\node[tikblock,fill=blue!20,minimum width=1.5cm] at (0.025,4.5) {};
	\node[tikblock,fill=blue!20,minimum width=1.5cm] at (0.025,0.4) {};
	\node[tikblock,fill=blue!20,minimum width=1.5cm] at (4,2.4) {};
	\node[tikblock,fill=blue!20,minimum width=1.5cm] at (12,2.3) {};
	\node[tikblock,fill=blue!20,minimum width=1.4cm] at (8,4.5) {};
	\node[tikblock,fill=blue!20,minimum width=1.5cm] at (8,0.4) {};
	
	\path[->,color=white] (G) edge node [sloped,left=-0.3cm] {\color{black} } (Prefix)
		     (F) edge node [sloped,right=-0.3cm] {\color{black} } (Prefix)
		     (Prefix) edge node [sloped,right=-0.4cm] {\color{black} } (GF)
		     (Prefix) edge node [sloped,left=-0.4cm] {\color{black}  } (FG)	
		     (GF) edge node [sloped,left=-0.4cm] {\color{black} } (Streett)
		     (FG) edge node [sloped,right=-0.3cm] {\color{black} } (Streett)	;		
\end{tikzpicture}	
\caption{(Borel) Hierarchy of -Automata and Temporal Logic}
\label{fig:automata_hierarchy}
\end{figure}









\subsection{The Temporal Logic Hierarchy}

In \cite{ChMP92,Schn01b,Schn03}, corresponding hierarchies for temporal logics have been defined.  Following \cite{Schn01b,Schn03}, we define the hierarchy of temporal logic formulas syntactically by the grammar rules of Fig.~\ref{fig:grammar}:

\begin{figure*}[!th] 
\caption{Syntactic Characterizations of the Classes of the Temporal Logic Hierarchy}
\label{fig:grammar}
\end{figure*}


\begin{definition}[Temporal Logic Classes] \label{temp_borel_1_def}
For , , , , , , we define the logics  by the grammars given in Fig.~\ref{fig:grammar}, where  is the set of formulas that can be derived from the nonterminal  ( represents any variable ).
\end{definition}

\noindent Typical safety conditions like  or  that state that something bad never happens, are contained in . Liveness conditions like  are contained in . Finally, fairness conditions like  that demand that something good infinitely often happens, are contained in  while stabilization/persistence properties like  that demand that after a finite interval, nothing bad happens are contained in .

In our experience, almost all formulas that occur in practice belong to . If a given formula should not belong to , it is often straightforward to rewrite it to an equivalent  formula. For example, the formula  that demands that infinitely often  holds is equivalent to the  formula . Clearly, there are many formulas outside , but we claim that these formulas seldom occur in practice.




\subsection{Relating the Temporal Logic and the Automata Hierarchy}

In \cite{Schn01b,Schn03} several translation procedures are given to translate formulas from  to equivalent  automata. In particular, the following is an important result:

\begin{theorem}[Temporal Logic and Automaton Hierarchy] \label{borel_thm}
Given a formula , we can construct a deterministic -automaton  of the class  in time  with  state variables. Therefore,  is a symbolic representation of a deterministic automaton with  states.
\end{theorem}

\noindent The above results are already proved in detail in \cite{Schn03}, where translation procedures from  to  have been constructed. Moreover, it has been shown in \cite{Schn03} that the subset construction can be used to determinize the automata that stem from the classes  and  and that the Miyano-Hayashi breakpoint construction is sufficient to determinize the automata that stem from the translation of formulas from  and .

Since  and  are the boolean closures of  and , respectively, the remaining results for  and  follow from the boolean combinations of  and , respectively.

The final step consists of computing the boolean closure of the acceptance conditions. To this end, it is shown in \cite{Schn03} how arbitrary boolean combinations of  and  with propositional formulas  are translated to equivalent  automata, and analogously, how arbitrary boolean combinations of  and  with propositional formulas  are translated to equivalent  automata.

\end{section}

\begin{section}{Exploiting the Non-Confluence Property}
\label{NonConfluenceProperty}

It is well-known that the -automata that stem from  formulas are a special class that has already found several characterizations. Due to results of \cite{McPa71}, the automata can be characterized as \emph{non-counting} automata, and in terms of alternating automata, the class of \emph{linear weak} or \emph{very weak} automata has been defined \cite{MeSe03,MuSS86b}. Moreover, many translation procedures from  generate {\em unambiguous automata} \cite{CaMi03} where every accepted word has a unique accepting run \cite{Schn03} (although there may be additional non-accepting runs for the same word). The determinization procedure presented in this chapter makes use of the fact that the automata generated from  are unambiguous. Without useless states, the transition relation of an unambiguous automaton has a certain form that we call \emph{non-confluence}:

\begin{center}
\begin{minipage}{13cm}
\emph{An automaton is non-confluent if whenever two runs of the same infinite word meet at a state , then they must share the entire finite prefix up to state .}
\end{minipage}
\end{center}

\noindent To give an intuitive idea why the automata constructed from  formulas by the `standard translation' procedure are non-confluent, consider the automaton of Figure~\ref{fig:LTLtranslate1} that is obtained by translating the formula  to a non-deterministic automaton.
As explained in \cite{Schn01b,Schn03}, the `standard' translation procedure from LTL to -automata traverses the syntax tree of the LTL formula in a bottom-up manner and abbreviates each subformula that starts with a temporal operator. The subformula  is thereby abbreviated by a new state variable , and the preliminary transition relation  is replaced with .

\begin{figure}
\centering
\begin{tikzpicture}[node distance=3cm,auto]
\node[state] (empty){};
\node[state,right of=empty] (q) {};
\path[->]
      	(empty) edge  [bend left] node        {} (q)
      	(empty) edge [loop left] node {}  ()
	(q) edge [loop right] node {}  ()
	(q) edge  [bend left] node        {} (empty)
	;
	
 \node [right=1 cm,text width=8cm]  at (q)
   {
   	
   };
\end{tikzpicture}
\caption{Nondeterministic Automaton for }
\label{fig:LTLtranslate1}
\end{figure}

As can be seen by Figure~\ref{fig:LTLtranslate1}, the input  demands that the current state is maintained, but allows the automaton to be in any of the two states. The other three classes of inputs uniquely determine the current state, but leave the successor state completely unspecified\footnote{According to the Krohn-Rhodes decomposition theorem, automata that stem from  properties do only have reset and identity inputs \cite{Schn03}.}. As a consequence, input words that infinitely often satisfy , i.e., , do only have one (infinite) run, while the remaining input words that satisfy  from a certain point of time on do have two infinite runs that are of the form  and  with the same finite prefix . Hence, the automaton is non-confluent, since the
two runs never merge after they have split.

An example run tree (that encodes all the runs of a given word) is shown in Fig.~\ref{LTL_Runtree1_fig}. It can be seen that there is a uniquely determined run, since all other nondeterministic choices lead to finite paths. Another example run tree that contains two infinite runs is shown in Figure~\ref{LTL_Runtree2_fig}.

\begin{figure}
\centering
\begin{tikzpicture}[node distance=1.7cm,auto]
\node[state] (q0) {};
\node[state,below of=q0] (q0') {};
\node[state,right of=q0] (q1) {};
\node[state,below of=q1] (q1') {};
\node[state,right of=q1] (q2) {};
\node[state,below of=q2] (q2') {};
\node[state,right of=q2] (q3) {};
\node[state,below of=q3] (q3') {};
\node[state,right of=q3] (q4) {};
\node[state,below of=q4] (q4') {};
\node[state,right of=q4] (q5) {};
\node[state,below of=q5] (q5') {};
\node[state,right of=q5] (q6) {};
\node[state,below of=q6] (q6') {};
\node[state,right of=q6] (q7) {};
\node[state,below of=q7] (q7') {};
\path[->]
	(q0) edge node {} (q1)
	(q0) edge node {} (q1')
	(q1) edge node {} (q2)
	(q1) edge node {} (q2')
	(q2') edge node [left=0.5mm,above=0mm]{} (q3)
	(q2') edge node {} (q3')
	(q3') edge node [left=0.5mm,above=0mm]{} (q4)
	(q3') edge node {} (q4')
	(q4) edge node {} (q5)
	(q4') edge node {} (q5')
	(q5) edge node {} (q6)
	(q5') edge node {} (q6')
	(q6) edge [bend left] node {} (q7)
	(q7) edge [bend left] node [above=0mm]{} (q6)
	(q6) edge node [above=0mm,right=1mm] {} (q7')
	(q7') edge node {} (q6')
	
	;
	
	
\end{tikzpicture}
\caption{Run Tree with a Uniquely Determined Infinite Run}
\label{LTL_Runtree1_fig}
\end{figure}


\begin{figure}
\centering
\begin{tikzpicture}[node distance=1.7cm,auto]
\node[state] (q0) {};
\node[state,below of=q0] (q0') {};
\node[state,right of=q0] (q1) {};
\node[state,below of=q1] (q1') {};
\node[state,right of=q1] (q2) {};
\node[state,below of=q2] (q2') {};
\node[state,right of=q2] (q3) {};
\node[state,below of=q3] (q3') {};
\node[state,right of=q3] (q4) {};
\node[state,below of=q4] (q4') {};
\node[state,right of=q4] (q5) {};
\node[state,below of=q5] (q5') {};
\node[state,right of=q5] (q6) {};
\node[state,below of=q6] (q6') {};
\node[state,right of=q6] (q7) {};
\node[state,below of=q7] (q7') {};
\path[->]
	(q0) edge node {} (q1)
	(q0) edge node {} (q1')
	(q1') edge node [left=0.5mm,above=0mm]{} (q2)
	(q1') edge node {} (q2')
	(q2') edge node [left=0.5mm,above=0mm]{} (q3)
	(q2') edge node {} (q3')
	(q3) edge node {} (q4)
	(q3') edge node {} (q4')
	(q4) edge node {} (q5)
	(q4') edge node {} (q5')
	(q5) edge node {} (q6)
	(q5') edge node {} (q6')
	(q6) edge node {} (q7)
	(q6') edge node {} (q7')
	(q7) edge [loop right] node {}()
	(q7') edge [loop right] node {} ()
	
	;
	
	
\end{tikzpicture}
\caption{Run Tree with two Infinite Runs of the Automaton of Fig.~\ref{fig:LTLtranslate1}}
\label{LTL_Runtree2_fig}
\end{figure}


As every automaton  obtained by the translation of a  formula  is a product of non-confluent automata, and as the product automaton of two non-confluent automata is also non-confluent, it follows that the automata  obtained by the above `standard' translation are non-confluent.

The above non-confluence property has been used in \cite{MoSc08} to develop a determinization procedure that exploits symbolic set representations. In particular, it does not rely on Safra trees as used by Safra's original procedure \cite{Safr88} or by the improved version of Piterman \cite{Pite06}. The states of the deterministic automata obtained by these procedures are trees of subsets of states of the original automaton. In contrast, our procedure generates deterministic automata whose states consist of -tuples of subsets of states, where  is the number of states of the nondeterministic automaton.



\end{section}
\begin{section}{A Symbolic Controller Synthesis Algorithm for Full }
\label{SymbolicControllerSynthesis}

\subsection{The Averest Framework}

Averest \cite{Schn09} is a set of tools for the specification, verification, and implementation of reactive systems. It includes a compiler and a simulator for synchronous programs, a symbolic model checker, and a tool for hardware-software synthesis. Averest can be used for modeling and verifying finite as well as infinite state systems at various levels of abstraction. In particular, Averest is not only well-suited for hardware design, but also for modeling communication protocols, concurrent programs, software in embedded systems, etc.

The design flow using Averest consists of the following steps: First, the system is described as a synchronous program in our language Quartz \cite{Schn09}, a descendent of Esterel. Then, the program is translated to a transition system in the Averest Interchange Format (AIF) using the Quartz compiler. This intermediate description can be directly used for verification with the symbolic model checker to check whether the system satisfies its specifications. If this is the case, code can be generated for an implementation in hardware or software with output formats like VHDL, Verilog or C.

The compiler contained in Averest does not only compile a Quartz program to a corresponding transition system, but also provides procedures to translate  and other specification logics to symbolically represented -automata.

The tool implementing the features of this paper is called Opal and extends the current Averest compiler to deal with controller synthesis. In the following subsections, the different steps of Opal are described in more detail. Opal is implemented in Moscow ML and uses Moscow MLs foreign function interface to connect to the BDD-package CUDD.


\subsection{Decomposing Specifications}

Specifications often consist of several relatively simple components - for instance, a collection of  properties whose conjunction should be satisfied. Thus, we consider specifications of the form .

Instead of translating the entire specification at once, we generate separate deterministic automata for every subformula . Clearly, since we allow any  property, we may have to make use of the determinization procedure outlined in \cite{MoSc08} to translate . For example, this is the case if the top-level operator of  is a temporal operator and  does not belong to one of the lower Borel classes  or .

In practice, this is however nearly never the case. Instead, most often, also the subformulas  are a boolean combination of even smaller formulas. Instead of handling them all at once, we break also these into smaller parts so that we obtain for every  a collection  of  properties that all start with a temporal operator, and that either belong to one of the classes , , ,  or to none of these classes.


\subsection{Handling Safety and Liveness formulas}

Safety formulas  are first translated to a nondeterministic safety automaton. Although safety automata can not be directly transformed to a parity automaton, it is possible to minimize them using direct simulation\footnote{Indeed, the nondeterministic automata generated by the translation procedures given in \cite{Schn03} translates the safety fragment to an automaton with the trivial acceptance condition , so that even the ordinary simulation relation as described in \cite{EtWS05} could be applied.}. After minimization, we perform the ordinary subset construction and afterwards minimize the automaton again using the direct simulation relation. However, one important subclass of properties does not scale well using this approach. Since many specifications are of the form `if something now happens, in the next step something else happens', we treat this subclass separately. This subclass can be formally described by Boolean combinations of formula of the form  or of the form  where both  and  are Boolean formulas over the input variables.

In that case, every  operator doubles the state space of the non-deterministic automaton and thus leads to a blow-up in the number of BDD variables of the deterministic automaton. Even worse, the simulation relations can neither minimize the nondeterministic nor the deterministic automaton since the two states that occur due to an occurrence of  can not be equivalent as one of the two will lead to a non-satisfying loop. Thus, the basic translation procedure really suffers from a double-exponential blowup. Instead, we translate those formulas by abbreviating each variable  that is not under the scope of a  operator by a previous variable  such that  holds and replace any subformula  with .

\begin{proposition}
Given a formula  where  is a boolean combination of state variables  and formulas  where . Then  is initially equivalent to the symbolically represented deterministic automaton  where , ,  and the transition relation is defined by

Here  is obtained from  by replacing any occurrence of  with  and any occurrence of a formula  with . Moreover  is the identity function. \end{proposition}

Obviously, this leads to an automaton that has at most  state variables, thus the automaton is only exponential in the size of the specification. Nevertheless, if many subformulas  exist but only little subformulas , the ordinary translation may give better results, so that this translation is optional in our algorithm.

For liveness formulas , we translate  and dualize the corresponding deterministic safety automaton to obtain a deterministic liveness automaton.


\subsection{Handling Co-Büchi and Büchi specifications}

For co-Büchi specifications, we use the translation from  to nondeterministic co-Büchi automata, minimize this automaton using the minimization techniques of \cite{Frit05b}. Afterwards this automaton is determinized using the breakpoint construction and again minimized. Büchi specifications are translated using the dual deterministic automaton of the formula obtained from negating the formula.


\subsection{Handling  Formulas that do not belong to a lower Borel Class}

If a subformula  does not belong to one of the lower Borel classes, we have to resort on the determinization procedure from \cite{MoSc08}. Thus, we first translate  to a non-confluent Büchi automaton and minimize it. This nondeterministic automaton is determinized using the procedure described in \cite{MoSc08}. However, we do not need to construct the whole automaton at once. Instead, we construct the automaton for a fixed bound  and check whether every marking of a state has been noticed by a state set. If so, we return this automaton, otherwise we do the same with an increased bound. Afterwards, we use the minimization techniques of \cite{Frit05b} to minimize the obtained parity automaton.

Although this procedure gives back a parity automaton that is from a theoretical point of view more efficient than a Street automaton, the heavy complexity of determinization makes even this approach infeasible in practice. Thus, we break up also the formulas  into smaller parts until every subformula starts with a temporal operator. Those subformulas are then translated as explained before. It is well known that every parity automaton can also be interpreted as a Streett or a Rabin automaton. We thus interpret the obtained automaton as a Streett automaton and combine the deterministic Streett automata to obtain a Streett automaton for  that is afterwards translated to a generalized parity automaton.



\subsection{Solving Generalized Parity Games}
Instead of solving the whole generalized parity game at once, we first solve the subgames that are obtained by constructing the game for the subformula . The set of states that are loosing for the controller need not be considered in the overall game. Afterwards, we solve the reduced overall game using the generalized parity game algorithm of \cite{ChHP07a}.

\subsection{Generating Circuits from BDDs}
The output of the generalized parity algorithm is a BDD over the (current state) variables  and over newly introduced state variables  to encode counter variables that are used to switch between the sub-strategies calculated by the generalized parity algorithm. A slight modification of the algorithm given in Figures 2 and 3 of \cite{BGJP07a} allows us to generate for every controllable input variable  a BDD  with the meaning that  should hold whenever  holds. We then write those BDDs to a file in our Averest interchange format. The tool Topaz in our Averest toolset can be used to obtain either Verilog, VHDL or C code from the generated file.

\end{section}
\begin{section}{Experiments and Conclusion}
\label{ExperimentalResults}
This section describes the experiments performed using the controller synthesis algorithm described in this paper. To this end, the  specifications that come with the Lily tool \cite{JoBl06} are used as a benchmark set. Those 23 handwritten formulas are mostly traffic light examples or arbiters.

To analyze the effect of using the all-purpose determinization of \cite{MoSc08} instead of the much simpler breakpoint or subset construction, we performed three different experiments on each of the formulas where the runtimes are summarized in Figure~\ref{table:det_table}. The first column lists the identification number of the example. The second column gives some measures of the specification in terms of number of temporal operators, boolean operators, and the number of input variables. The third column gives the number of subformulas, \ie the number of top-level conjunctions. The conjunction of those formula form the overall specification. Notice that the number of boolean operators do not include the top-level conjuncts. The next column indicates how many subformulas are not safety formulas\footnote{In the considered experiments, any subformula is at least contained in the Büchi or co-Büchi class so that we obtain a formula of the temporal logic hierarchy.}. The next two columns give the time for determinization followed by the overall time needed to synthesize the specification.

Algorithm Opal uses all optimizations. Every formula is translated with the lowest possible determinization procedure. In contrast, algorithm Nonc translates every formula that is not a safety formula with the all-purpose determinization construction of \cite{MoSc08}. Finally, the last column gives the running time of the Lily algorithm.

\begin{figure}
\centering
\beginpgfgraphicnamed{experiment}
	\pgfkeys{/pgf/number format/.cd,fixed,precision=2}
	\pgfplotstableset{columns={No.,{T,B,AP},subf,O,{NoncDetT},{OpalDetT},{NoncT},{OpalT},{LilyT}}}
	\pgfplotstabletypeset
	[
		every even row/.style={ before row={\rowcolor[gray]{0.9}}},
		every head row/.style={before row=\toprule,after row=\midrule},
		every last row/.style={after row=\bottomrule},
		col sep=semicolon,
		columns/No./.style={string type},
		columns/{T,B,AP}/.style={string type},
		columns/{p}/.style={string type},
	]{Experiments.table}
\endpgfgraphicnamed
\caption{Experiments performed with different Determinization Constructions}
\label{table:det_table}
\end{figure}

As it can be seen, using "'easier"' determinization procedures like the Rabin-Scott subset construction or the Miyano-Hayashi breakpoint construction significantly improves the determinization step itself. When the size of the specification grows as in examples L20-L23, the overall synthesis time is no longer dominated by the determinization, but instead by the time to solve the generalized parity game. In that case using the easier determinization procedures leads to smaller sized automata and thus also to an improvement on the overall synthesis time. With the exception of the small specifications L1 and L2, our tool is significantly faster compared to the explicitly implemented tool Lily.

\end{section}
\bibliographystyle{eptcs}
\bibliography{paper}
\end{document}
