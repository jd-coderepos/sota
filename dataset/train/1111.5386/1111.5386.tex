\documentclass{llncs}

\usepackage{amsmath}
\usepackage{graphicx, amssymb}
\usepackage{amsfonts, enumerate}
\usepackage{algorithm,algorithmic}
\usepackage{multirow}

\newcommand{\mnote}[1]{\marginpar{\scriptsize\it #1}}
\newcommand{\comment}[1]{}
\newcommand{\runtitle}[1]{{\small \textbf{\boldmath #1}}}

\newcommand{\ind}{{\sc Index}}
\newcommand{\disj}{{\sc Disj}}
\newcommand{\hlis}{{\sc Hidden-IS}}

\newcommand{\bx}{\mathbf{x}}
\newcommand{\by}{\mathbf{y}}
\newcommand{\CC}{{\rm CC}}

\newcommand{\ed}{{\rm ed}}
\newcommand{\aed}{\widehat \ed}
\newcommand{\lis}{{\rm lis}}
\newcommand{\alis}{\widehat \lis}

\newcommand{\sw}{\sigma_w}
\newcommand{\swi}{\sigma_{[i-w+1,i]}}
\newcommand{\eps}{\epsilon}


\begin{document}

\title{
  \mbox{Edit Distance to Monotonicity in Sliding Windows}
}


\author{Ho-Leung Chan\inst{1}
\and Tak-Wah Lam\inst{1}\thanks{T.W. Lam was supported by the GRF Grant HKU-713909E.}
\and Lap-Kei Lee\inst{2}
\and Jiangwei Pan\inst{1}
\and \\
Hing-Fung Ting\inst{1}
\and Qin Zhang\inst{2}
}

\institute{Department of Computer Science, University of Hong Kong, Hong Kong \\
\email{\{hlchan, twlam, jwpan, hfting\}@cs.hku.hk}
\and
MADALGO\footnote{\scriptsize Center for Massive Data Algorithmics -- a Center of the Danish National Research Foundation},
Department of Computer Science, Aarhus University, Denmark \\
\email{\{lklee, qinzhang\}@madalgo.au.dk}
}



\vspace{-.3in}
\maketitle

\vspace{-.2in}
\begin{abstract}
Given a stream of items each associated with a numerical value,
its edit distance to monotonicity is the minimum number of items
to remove so that the remaining items are non-decreasing with respect
to the numerical value. The space complexity of estimating the
edit distance to monotonicity of a data stream is becoming well-understood
over the past few years.
Motivated by applications on network quality monitoring,
we extend the study to estimating the edit distance to monotonicity of
a sliding window covering the  most recent items in the stream for any .
We give a deterministic algorithm which can return an estimate within a factor of
 using  space.

We also extend the study in two directions.
First, we consider a stream where
each item is associated with a value from a partial ordered set.
We give a randomized -approximate algorithm
using  space.
Second, we consider an out-of-order stream where each item
is associated with a creation time and a numerical value,
and items may be out of order with respect to their creation times.
The goal is to estimate the edit distance to monotonicity
with respect to the numerical value of items
arranged in the order of creation times.
We show that any randomized constant-approximate algorithm
requires linear space.
\end{abstract}

\section{Introduction}

Estimating the sortedness of a numerical sequence
has found applications in, e.g., sorting algorithms,
database management and webpage ranking (such as Pagerank~\cite{BrP98}).
For example, sorting algorithms can take advantage of
knowing the sortedness of a sequence so as to sort efficiently~\cite{EsW92}.
In relational database, many operations are best performed
when the relations are sorted or nearly sorted over the relevant attributes~\cite{BKF+11}.
Maintaining an estimate on the sortedness of the relations can help determining
whether a given relation is sufficiently nearly-sorted or
a sorting operation on the relation (which is expensive) is needed.
One common measurement of sortedness of a sequence
is its \emph{edit distance to monotonicity} (or ED, in short)~\cite{AJK+02,CMS01,ErJ08,GaG07,GJK+07}:
given a sequence  of  items,
each associated with a value in ,
the ED of , denoted by ,
is the minimum number of edit operations required
to transform  to the sequence obtained
by sorting  in non-decreasing order.
Here, an edit operation involves removing an item and re-insert it into a
new position of the sequence.  Equivalently,
 is the minimum number of items in  to delete
so that the remaining items have non-decreasing values.
A closely related measurement
is the \emph{length of the longest increasing subsequence} (or LIS) of ,
denoted by .
It is not hard to see that .

With the rapid advance of data collection technologies,
the sequences usually appear in the form of a data stream,
where the stream of items is massive in size (containing possibly billions of items)
and the items are rapidly arriving sequentially.
This gives rise to the problem of estimating ED in the data stream model:
An algorithm is only allowed to scan the sequence sequentially in one pass,
and it also needs to be able to return, at any time,
an estimate on ED of the items arrived so far.
The main concern is the space usage and
update time per item arrival, which, ideally, should
both be significantly smaller than the total data size
(preferably polylogarithmic).

Estimating ED of a data stream is becoming well-understood
over the past few years~\cite{ErJ08,GaG07,GJK+07}.
Gopalan et al.~\cite{GJK+07} showed that computing the ED of a stream
exactly requires  space even for randomized algorithms,
where  is the number of items arrived so far.
They also gave a randomized -approximate algorithm
for estimating ED using space ,
where .
Later, Ergun and Jowhari~\cite{ErJ08} improved the result
by giving a deterministic -approximate algorithm
using space .
For the closely related LIS problem,
Gopalan et al.~\cite{GJK+07} also gave a deterministic
-approximate algorithm for estimating LIS
using  space.
This space bound is proven to be optimal in~\cite{GaG07}.


\runtitle{ED in sliding windows.}
The above results consider the sortedness of all items in the stream
arrived so far, which corresponds to the \emph{whole stream model}.
Recently, it is suggested that ED can be an indicator of
network quality~\cite{GKT10}. The items of the stream correspond to
the packets transmitted through a network,
each associated with a sequence number. Ideally, the
packets would arrive in increasing order of the sequence number.
Yet network congestion would result in packet retransmission
and distortion in the packet arrival order, which leads
to a large ED value.
One of the main causes to network congestion is
that traffic is often bursty.
Thus, the network quality can be measured more accurately
if the measurement is based on only recent traffic.
To this end, we propose studying the \emph{sliding window model} where
we estimate the ED of a window covering the latest  items in the stream.
Here  is a positive integer representing the window size.
The sliding window model is no easier than the whole data stream model because
when  is set to be infinity, we need to estimate
ED for all items arrived.

\runtitle{Our results.}
We give a deterministic -approximate algorithm
for estimating ED in a sliding window. The space usage is
, where  is
the window size.
Our algorithm is a generalization
of the algorithm by Gopalan et al. \cite{GJK+07}.
In particular, Gopalan et al. show that ED of the whole stream
can be approximated by the number of ``inverted'' items  such that many items
arrived before  has a value bigger than .
We extend this definition
to the sliding window model. Yet, maintaining the number
of inverted items in a sliding window is non-trivial.
An item  may be inverted when it arrives, but it may
become not inverted due to the expiry of items \emph{arrived earlier}.
We give an interesting algorithm to estimate the number of inverted items
using existing results
on basic counting and quantile estimation over sliding windows.
Our algorithm also incorporates an idea in~\cite{ErJ08}
to remove randomization.

We also consider two extensions of the problem.

{\it  Partial ordered items.}
In some applications, each item arrived is associated
with multiple attributes, e.g., a network packet may contain
both the IP address of the sender and a sequence number.
To measure the network quality,
it is sometimes useful to estimate the \emph{most congested} traffic
coming from a particular sender.
This corresponds to estimating the ED of packets
with respect to sequence number from the same sender IP address.
In this case,
only sequence numbers with the same IP address can be ordered.
We model such a situation by considering items
each associated with a value drawn from a partial ordered universe.
We are interested in estimating the minimum number of
items to delete so that the remaining items are sorted
with respect to the partial order. We give a randomized -approximate algorithm
using  space.


{\it  Out-of-order streams.}
When a sender transmits packets to a receiver through
a network, the packets will go through some intermediate routers.
To measure the quality of the route between
the sender and an intermediate router,
it is desirable to estimate the ED of the packets received
by the router from the sender.
Yet in some cases, the router may not be powerful enough to deploy
the algorithm for estimating the ED.
We consider delegating the task of estimation
to the receiver.
To model the situation, whenever a packet arrives,
the intermediate router marks in the packet a timestamp recording
the number of packets~received~thus far
(which can be done by maintaining a single counter).
Hence, when the packets
arrive at the receiver, each packet has both a sequence number
assigned by the sender and a timestamp marked by the router.
Note that the packets arrived at the receiver may be out-of-order
with respect to the timestamp.
Such stream corresponds to an \emph{out-of-order~stream}.

To measure the
network quality between the sender and the router,
the receiver can estimate the ED with respect to the sequence number
when the items are arranged in increasing order of the timestamps.
Intuitively, the problem is difficult as items can
be inserted in arbitrary positions of the sequence according
to the timestamp.
We show strong space lower bounds even in the whole stream model.
In particular, any randomized constant-approximate
algorithm for estimating ED of an out-of-order stream requires  space,
where  is the number of items arrived so far.
An identical lower bound holds for estimating the LIS.
Like most streaming lower bounds, our lower bounds are proved based on
reductions from two communication problems, namely, the \ind~problem and the
\disj~problem.  Optimal communication lower bounds for randomized protocols are
known for both problems \cite{Abl96,Jay09}.


\comment{
\runtitle{Techniques.}
For the problem of estimating ED in the whole data stream, existing algorithms try to identify a
subset of ``bad'' items, who has a significant effect on the sortedness of the stream.
At the same time, the
size of the subset is a good approximation to the actual ED of the stream.  Therefore, the algorithm
only need to maintain a counter for the number of ``bad'' items, which will never decrease.  However,
for the sliding window version of this problem, as the window slides, ``bad'' items may eventually
become ordinary items even if they have not expired themselves. So one counter will not
work in this case.  We
deal with this situation by modeling those ``bad'' items as an out-of-order substream.  By employing
a basic counting structure for out-of-order streams, the size of the ``bad'' subset can be estimated
dynamically.

For lower bounds in out-of-order streams, we use different methods for ED and LIS.  For
ED, we construct a large set of input streams such that a correct
algorithm needs to differentiate any two of them (i.e. different memory states). Therefore, the
algorithm needs to use space the logarithm of the total number of input streams.  On the other hand,
we prove the lower bound for LIS through a reduction from a communication
problem, whose communication lower bound is known.  Both bounds are deterministic and linear in the
size of the stream for constant approximation.
}

\runtitle{Organization.}
Section~\ref{sec:definitions} and~\ref{sec:main} give the formal problem definitions
and our main algorithm for
estimating ED, respectively.
Section~\ref{sec:extensions} considers out-of-order streams.
Due to the page limit, extension to
partial ordered items is left to the full paper.


\section{Formal problem definitions}\label{sec:definitions}

\runtitle{Sortedness of a stream.}
Consider a stream  of  items,

where each  is drawn
from .
The \emph{edit distance to monotonicity} (ED) of ,
denoted by ,
is the minimum number of items required
to remove so as to obtain an increasing subsequence of ,
i.e., 
such that 
for some .
We use  to denote the
\emph{length of the longest increasing subsequence} (LIS) of .
Note that .
The sortedness can be computed based
on the \emph{whole stream} (all items in  received thus far)
or a \emph{sliding window} covering the most recent  items,
denoted by , for .
Note that the whole stream model can be viewed as
a special case of the sliding window model with window size .
A streaming algorithm has only limited space
and can only maintain an estimate on
the sortedness of .
For any ,
a -approximate algorithm for estimating 
returns, at any time,
an estimate 
such that .
We can define a -approximate algorithm
for estimating  similarly.

\runtitle{Partial ordered universe.}
We also consider a partial ordered universe
with binary relation .
A subsequence of  with length ,
,
is increasing
if for any , .
Then for any window size ,
 and  can be defined analogously as before.

\runtitle{Out-of-order stream.}
The data stream described above is an \emph{in-order} stream,
which assumes items arriving in the same order as their creation time.
In an \emph{out-of-order stream},
each item is associated with a distinct integral time-stamp recording
its creation time, which may be different from its arrival time.
Precisely, an out-of-order stream 
is a sequence of tuples  ()
where  and  are the timestamp and value of the -th item.
The sortedness of  is defined based on the permuted sequence

such that , i.e.,
 and .


\section{A -approximate algorithm for estimating ED}\label{sec:main}

In this section, we consider a stream  of items with values drawn
from a set ,
and we are interested in estimating the ED of a sliding window covering
the most recent  items in~.
We give a deterministic -approximate algorithm
which uses  space.

Our algorithm is based on an estimator , which is a generalization of the estimator in~\cite{GJK+07}
to the sliding window model.
Let  be the index of the latest arrived item.
The sliding window we consider is
.
For any item , let  be the set of items
arrived before  but have greater values than
, i.e., .
We define an estimator  for  as follows.

\begin{definition}
Consider the current sliding window .
We define  to be the set of indices  such that
there exists  with .
\end{definition}



\begin{lemma}[\cite{GJK+07}] \label{lem:estimator}
.
\end{lemma}

Hence, if we know ,
we can return  as an estimation for 
and it gives a 4-approximation algorithm.
However, maintaining  exactly requires space linear
to the window size. In the following, we show how to approximate
 using significantly less space.

\subsection{Estimating }
We first present our algorithm and then show that it
can approximate . Our algorithm will
make use of two data structures.
Let  be a constant in  (which will be
set to  later).

{\bf -approximate quantile data structure
\boldmath }:
Let  be a set of items. The rank of an item in~
is its position in the list formed by sorting 
from the smallest to the biggest. For any ,
the -approximate -quantile of 
is an item with rank in .
We maintain an -approximate -quantile
data structure given in~\cite{LLX+04} which
can return, at any time, an -approximate
-quantile of the most recent  items
for any .
This data structure takes
 space.

{\bf -approximate basic counting data structure \boldmath}:
When an item  arrives, we may
associate a token with some item 
where . The association is permanent and
an item may be associated with more than one token.
At any time, we are interested in the number
of tokens associated with the most recent  items.
We view it as a stream  of tokens,
each of which has a timestamp  if it is associated to ,
and we want to return the number of tokens with timestamp in .
Note that the tokens may be out-of-order with respect to the timestamp,
leading to the basic counting problem for out-of-order stream
considered in~\cite{CKT08}.
We maintain their -approximate basic counting data structure
on  which can return, at any time, an estimate 
such that , where
 is the number of tokens associated with
the latest  items.
It takes
 space,
where  is the maximum number of tokens associated within
any window of  items.
As we may associate one token upon any
item arrival,  is at most~. 

We are now ready to define our algorithm, as follows.
\begin{center}
\vspace{-.1in}
  \begin{tabular}{l}
    \hline
    {\bf Algorithm 1.} Estimating ED in sliding windows\\
    \hline
    {\bf Item arrival:} Upon the arrival of item , do \\
    ~ ~ For \\
    ~ ~ ~ ~ ~Query  for the -quantile of .
             Let  be the returned value.\\
    ~ ~ ~ ~ ~If ,
    associate a token to , i.e., add an item with timestamp \\
    ~ ~ ~ ~ ~to the stream .
                  Break the for loop. \vspace{.1in}\\
   {\bf Query:}
   Query  on the stream  for the number of tokens associated
   with\\
   the last  items and
   let  be the returned answer.
   Return  as\\
   the estimation .   \\
    \hline
  \end{tabular}
\end{center}

Let  be
the set of indices  such that
when  arrives, we associate a token
to an item  where .
Observe that  is an approximation of 
in the following sense.

\begin{lemma}\label{lem:R'}
 contains \emph{all} indices  satisfying
that there exists  such that
.
Furthermore, \emph{all} indices  contained in
 must satisfy that
there exists  such that
.
\end{lemma}

\begin{proof}
An index  is in  if
 when  arrives, where
 is the -approximate -quantile
for some interval . Note that the rank of 
in  is at least .
Therefore, if ,
the rank of  is less than ,
so  and  must be included in .
On the other hand,
the rank of  in  is at most .
Since , we conclude that
all indices  satisfy .
\hfill\qed
\end{proof}

We show that  is a good approximation
for , as follows.

\begin{lemma} \label{lem:approx-estimator}
.
\end{lemma}
\begin{proof}
  We observe that by Lemma~\ref{lem:R'},
  any index  in  must be also
  in . Hence,  and
  
  (by Lemma~\ref{lem:estimator}).

  Now, we show  by giving an iterative pruning procedure to obtain an
  increasing subsequence (may not be the longest).  First let
   and
  .  Find the largest  such that  and
   and delete the interval .
  We then let  and repeat the process
  until no such  is found.
  As each~ is not in ,
  Lemma~\ref{lem:R'} implies that in every interval
  that we delete, the fraction of items of  is at
  least .
  Note that eventually all items in  will be deleted.
  Thus, .
\hfill\qed
\end{proof}

Note that  equals the number of tokens associated
with the most recent  items. Since  is only an -approximate
data structure, the value  returned only satisfies that
.
Since we report  as
the estimation, we conclude with the following approximation ratio.

\begin{lemma}

\end{lemma}

For any , we can set .
Then, .
The total space usage of the two data structures is
.
If , 
and thus the total space usage is .
Otherwise, we can store all items in the window, which
only requires  space.

\vspace{.1in}
\runtitle{Improving the running time.}  The per-item update time of the algorithm is 
because the algorithm checks the interval  for every length .
An observation in~\cite{ErJ08} is that an -approximate
-quantile of an interval with length  is also an -approximate -quantile
for all intervals with length . Hence we only need to check
 intervals of length .
Then we obtain an
-approximate quantile for every interval.
Note that the query time for returning an approximate quantile
is ,
and the per-item update time of the two data structures is
~\cite{CKT08,LLX+04}.
We conclude with the main result of this section.



\begin{theorem}
There is a deterministic -approximate algorithm
for estimating ED in a sliding window of the latest  items.
The space usage is 
and the per-item update time is
.
\end{theorem}

\runtitle{Remark.} For the whole stream model, the state-of-the-art result is a
-approximation in \cite{ErJ08}.  They gave an improved estimator
 as the set
of indices  such that there exists  with . In other words, whether an index belongs to  or not
depends on the number of members of  before that index.  Note that
a member of  could become a nonmember due to window expiration.  Therefore, an
index  that is not a member of  initially, may later become a member
if some of the previous  members become nonmembers.  This makes estimating
this improved  difficult in the sliding window model.

\section{Lower bounds for out-of-order streams}\label{sec:extensions}

In this section, we consider an out-of-order stream 
consisting of a sequence of items  for ,
where  and  are the timestamp and
value of the -th item, respectively.
Recall that the sortedness of the stream is
measured on the derived value sequence by rearranging the items in
non-decreasing order of the timestamps. 
We show that even for the whole data stream model,
any randomized constant-approximate algorithm
for estimating ED or LIS requires  space. 
In fact, a stronger lower bound holds for ED: any randomized algorithm that decides 
whether ED equals 0 uses  space.  Our proofs follow from reductions from
two different communication problems.

\subsection{Estimating ED in an out-of-order stream}


\begin{theorem}\label{thm:lb_ed}
  Consider an out-of-order stream  of size .
  Any randomized algorithm that distinguish between the cases that 
   and that  must use  bits.
  Therefore, for arbitrary constant , any randomized -approximation to
   requires  bits.
\end{theorem}

We prove the above lower bound by showing a reduction from the classical
communication problem \ind, which has strong communication lower bound. 

The problem \ind~is a two-player one-way communication game.  Alice holds a binary
string  and Bob holds an index .
In this communication game, Alice sends one message to Bob and Bob is
required to output the -th bit of , i.e.  , based on 
the message received.  A trivial protocol is for Alice to send all her
input string  to Bob, which has communication complexity of  bits.  It turns
out that this protocol is optimal.  Particularly, Alice must
communicate  bits in any randomized protocol for \ind
~\cite{Abl96}.

\begin{proof}[of Theorem~\ref{thm:lb_ed}]
  Given an out-of-order stream with length , suppose there is a
  randomized algorithm  that can determine whether its ED equals to
  0 or is at least 1 using  memory bits.  We define a randomized
  protocol  for \ind for : Alice constructs
  (hypothetically) an out-of-order stream  with length  by setting
  
  Alice then simulates algorithm  on stream  and sends the
  content of the working memory to Bob.  Bob constructs another stream item
   to continue running algorithm
   on it and obtains the output.  If the output says , Bob outputs 0; otherwise, Bob outputs 1.

  It is not hard to see that \ind implies  and
  \ind implies .  Therefore, if algorithm
   reports the correct answer with high probability, the protocol
   outputs correctly with high probability, and thus is a valid
  randomized protocol for \ind.  In the protocol, the number of bits communicated by Alice is
  at most .  Combining the  lower bound, we obtain
  that , completing the proof.
\hfill\qed
\end{proof}

\subsection{Estimating LIS in an out-of-order stream}

\begin{theorem}\label{thm:lb_lis}
  Consider an out-of-order stream  with size .  Any randomized
  algorithm that outputs an -approximation on  must use
   bits.
\end{theorem}

\begin{proof}
We prove the lower bound by considering the -party set disjointness
problem \disj.  The input to this communication game is a binary 
matrix , and each player  holds one row of
, the 1-entries of which indicate a subset  of .  The input
 is called \emph{disjoint} if the  subsets are pairwise
disjoint, i.e., each column of  contains at most one 1-entry; and it is
called \emph{uniquely intersecting} if the subsets  share a unique common
element  and the sets  are pairwise disjoint, meaning that in
, except one column with entries all equal to 1, all the other columns have at most one
1-entry.  The objective of the game is to distinguish between the two types of
inputs.  To obtain the space lower bound, we only need to consider a restricted 
version of \disj~where, according to some probabilistic protocol, the first
 players in turn send a message privately to his next neighboring player and the last
player  outputs the answer.

An optimal lower bound of  total communication is known for
\disj~even for general randomized protocols (with constant success probability) 
\cite{Jay09}, and thus the lower
bound also holds for our restrited one-way private communication model.  By
giving a reduction and setting the parameters appropriately, we can obtain the
space lower bound.

Given a randomized algorithm that outputs -approximation to the LIS of any out-of-order stream
with length , using  memory bits, we
define a simple randomized protocol for \disj~for  and .  Let  be the input  matrix.  The first player
 creates an out-of-order stream  by going through his row of input
 and inserting a new item  to
the end of the stream
whenever an entry  equals to 1.  He then runs the streaming algorithm on
 and sends the content of the memory to the second player.  In general,
player  appends a new item  to the
stream for each nonzero entry , simulates the streaming algorithm and
communicates the updated memory state to the next player.  Finally, player  obtains
the approximated LIS of stream .  If it is at most  he reports
that the input  is disjoint; else, he reports it is uniquely intersecting.
It's easy to verify that if the input  is disjoint, the correct LIS of stream  is 1,
while if it is uniquely intersecting, the correct LIS of  is .
Consequently, if the streaming algorithm outputs an -approximation to
 with probability at least , the protocol for \disj~is
correct with constant probability, using total communication at most .
Following the lower bound for \disj, this implies ,
i.e., .  Theorem~\ref{thm:lb_lis} follows.
\end{proof}

\runtitle{Remark.} Actually, for deterministic algorithms, we can obtain a
slightly stronger lower bound of  for -approximation, by
a reduction from the \hlis~problem used in \cite{GaG07} to prove the
 lower bound for approximating LIS of an in-order stream.  The
reduction is similar to the above, and if we set the approximation ratio
 to a constant, the lower bounds become linear in both cases.  Therefore, we
neglect the details here.



\section*{Acknowledgement}
We thank the anonymous reviewers for helpful comments and for pointing out the
randomized lower bounds to us.



{\small
\begin{thebibliography}{10}

\bibitem{Abl96}
F.~Ablayev.
\newblock Lower bounds for one-way probabilistic communication complexity and
their application to space complexity.
\newblock In {\em Theoretical Computer Science}, 157(2):139--159, 1996.

\bibitem{AJK+02}
M.~Ajtai, T.~S.~Jayram, R.~Kumar, and D.~Sivakumar.
\newblock Approximate counting of inversions in a data stream.
\newblock In {\em Proc. STOC}, pages 370--379, 2002.

\bibitem{BKF+11}
S.~Ben-Moshe, Y.~Kanza, E.~Fischer, A.~Matsliah, M.~Fischer, and
  C.~Staelin.
\newblock Detecting and exploiting near-sortedness for efficient relational
  query evaluation.
\newblock In {\em Proc. ICDT}, pages 256--267, 2011.

\bibitem{BrP98}
S.~Brin and L.~Page.
\newblock The anatomy of a large-scale hypertextual web search engine.
\newblock {\em Computer Networks}, 30(1-7):107--117, 1998.

\bibitem{Cha10}
A.~Chakrabarti.
\newblock A note on randomized streaming space bounds for the longest increasing
subsequence problem.
\newblock {\em ECCC}, pages 100, 2010.

\bibitem{CKT08}
G.~Cormode, F.~Korn, and S.~Tirthapura.
\newblock Time-decaying aggregates in out-of-order streams.
\newblock In {\em Proc. PODS}, pages 89--98, 2008.

\bibitem{CMS01}
G.~Cormode, S.~Muthukrishnan, and S.~Sahinalp.
\newblock Permutation editing and matching via embeddings.
\newblock In {\em Proc. ICALP}, pages 481--492, 2001.

\bibitem{ErJ08}
F.~Ergun and H.~Jowhari.
\newblock On distance to monotonicity and longest increasing subsequence of a
  data stream.
\newblock In {\em Proc. SODA}, pages 730--736, 2008.

\bibitem{EsW92}
V.~Estivill-Castro and D.~Wood.
\newblock A survey of adaptive sorting algorithms.
\newblock {\em ACM Computing Surveys}, 24:441--476, 1992.

\bibitem{GaG07}
A.~G{\'a}l and P.~Gopalan.
\newblock Lower bounds on streaming algorithms for approximating the length of
  the longest increasing subsequence.
\newblock {\em Proc. FOCS}, pages 294--304, 2007.

\bibitem{GJK+07}
P.~Gopalan, T.~S.~Jayram, R.~Krauthgamer, and R.~Kumar.
\newblock Estimating the sortedness of a data stream.
\newblock In {\em Proc. SODA}, pages 318--327, 2007.

\bibitem{GKT10}
P.~Gopalan, R.~Krauthgamer, and J.~Thathachar.
\newblock Method of obtaining data samples from a data stream and of estimating
  the sortednesss of the data stream based on the samples.
\newblock {\em United States Patent 7,797,326 B2}, 2010.

\bibitem{LLX+04}
X.~Lin, H.~Lu, J.~Xu, and J.~X.~Yu.
\newblock Continuously maintaining quantile summaries of the most recent 
  elements over a data stream.
\newblock In {\em Proc. ICDE}, pages 362--374, 2004.

\bibitem{Jay09}
T.~S.~Jayram.
\newblock Hellinger strikes back: A note on the multi-party information
complexity of AND.
\newblock In {\em RANDOM}, pages 562--573, 2009.
\end{thebibliography}
}

\end{document}
