\newcommand{\capabilities}{\mathtt{c}}
\newcommand{\GQueue}{h}
\newcommand{\monitorSet}{D}
\newcommand{\inTop}{\text{ in }}
\newcommand{\scribble}{Scribble}
\newcommand{\java}{{{\sc Java}}}
\newcommand{\eval}{\downarrow}
\newcommand{\ocaml}{{{\sc Ocaml}}}
\newcommand{\mN}{\mathsf{N}}


    \newcommand{\com}[2]{\par
      \fcolorbox{red}{yellow}{\parbox{\linewidth}{ 
            \color{gray}
            \begin{description}
            \item[{\color{blue} #2:}]{\sf #1}
            \end{description}}}
    }



\spnewtheorem{DEF}[theorem]{Definition}{\bfseries}{\rmfamily}
\spnewtheorem{REM}[theorem]{Remark}{\bfseries}{\rmfamily}
\spnewtheorem{PRO}[theorem]{Proposition}{\bfseries}{\rmfamily}
\spnewtheorem{CON}[theorem]{Convention}{\bfseries}{\rmfamily}
\spnewtheorem{LEM}[theorem]{Lemma}{\bfseries}{\itshape}
\spnewtheorem{THM}[theorem]{Theorem}{\bfseries}{\itshape}
\spnewtheorem{COR}[theorem]{Corollary}{\bfseries}{\itshape}
\spnewtheorem{EX}[theorem]{Example}{\bfseries}{\rmfamily}

\newcommand{\assleft}{\llbracket}
\newcommand{\assright}{\rrbracket}
\newcommand{\INTp}[1]{\II{#1}}
\newcommand{\OUTp}[1]{\OO{#1}}
\newcommand{\PENDINV}[4]{\{\AT{#1}{#2}[#3] \}_{#4}}

\newcommand{\NI}{\noindent}
\newcommand{\CD}{\!\cdot\!}
\newcommand{\CAL}[1]{\mathcal{#1}}
\newcommand{\OL}[1]{\overline{#1}}
\newcommand{\DIFF}{\backslash}
\newcommand{\Dropp}[2]{#1-#2}
\newcommand{\ifthenelse}{}
\newcommand{\VEC}{\tilde}
\newcommand{\VECw}{\widetilde}

\newcommand{\ENCan}[1]{\langle #1 \rangle}
\newcommand{\ENCda}[1]{\langle\!\langle #1 \rangle\!\rangle}
\newcommand{\ENCdp}[1]{(\!( #1 )\!)}

\newcommand{\ASET}[1]{\{#1\}}
\newcommand{\PAR}{\mathrel{\mid}}
\newcommand{\AT}[2]{#1\! : \! #2}

\newcommand{\OP}[2]{#1\ENCan{#2}}
\newcommand{\OT}[2]{#1(#2)} \newcommand{\MSG}[4]{\ENCan{#1, #2, \OP{#3}{#4}}}
\newcommand{\MSGT}[4]{\ENCan{#1, #2, \OT{#3}{#4}}}

\newcommand{\LT}{T} 

\newcommand{\GAbody}{\mathcal{H}}  \newcommand{\GAssert}{G}  \newcommand{\GA}{\GAssert}
\newcommand{\LAssert}{T}  \newcommand{\LA}{\LAssert}
\newcommand{\LAbody}{\mathcal{U}}
\newcommand{\sort}{(\LAssert[\player])}
\newcommand{\MT}{\mathnormal{mv}} \newcommand{\AssertEnv}{\Gamma^A} \newcommand{\REFINES}{\Supset}
\newcommand{\CATCH}{~\mathtt{catch}~}
\newcommand{\CATCHAT}[2]{\CATCH\mathtt{at}~#1~\mathtt{to}~#2}

\newcommand{\mode}[1]{\keyword{m}(#1)}
\newcommand{\Imode}{\mathtt{I}}
\newcommand{\Omode}{\mathtt{O}}
\newcommand{\IOmode}{\mathtt{IO}}
\newcommand{\imode}{\mathsf{}}
\newcommand{\omode}{\mathsf{}}

\newcommand{\rro}{\ROLE{r}_1}
\newcommand{\rrt}{\ROLE{r}_2}
\newcommand{\rr}{\ROLE{r}}
\newcommand{\Buy}{\ROLE{B}}
\newcommand{\Sell}{\ROLE{S}}
\newcommand{\Agency}{\ROLE{A}}
\newcommand{\DB}{\ROLE{DB}}
\newcommand{\pr}{\alpha}
\newcommand{\prb}{\beta}

\newcommand{\brkin}{|}

\newcommand{\U}{\mode{\GA[\p]}}
\newcommand{\UI}{(\LA[\p])^\Imode}
\newcommand{\UO}{(\LA[\p])^\Omode}
\newcommand{\UIO}{(\GA[\p])^\IOmode}
\newcommand{\UIOG}{\GA[\p]}
\newcommand{\UIA}{\Imode(\assleft A\assright\GA[\p])}
\newcommand{\UA}{\mode{\assleft A\assright\GA[\p]}}
\newcommand{\UOA}{\Omode(\assleft A\assright\GA[\p])}

\newcommand{\VAR}[1]{var(#1)} \newcommand{\IVAR}[1]{\mathtt{fv}(#1)}  

\newcommand{\GInter}[2]{#1 \rightarrow #2}
\newcommand{\GForm}[7]{\GInter{#1}{#2}: \ASET{#3 (#4: #5) #6. #7}}
\newcommand{\NGForm}[6]{\GInter{#1}{#2}: \lbrace #3 (#4: #5) #6}
\newcommand{\LFormOut}[6]{#1! \ASET{#2 (#3: #4) #5. #6}}
\newcommand{\LFormIn}[6]{#1? \ASET{#2 (#3: #4) #5. #6}}
\newcommand{\LFormDaggerOne}[6]{#1\dagger_1 \ASET{#2 (#3: #4) #5. #6}}
\newcommand{\LFormDaggerTwo}[6]{#1\dagger_2 \ASET{#2 (#3: #4) #5. #6}}

\newcommand{\LFormOutMarked}[6]{\underline{#1 !} \ASET{#2 (#3: #4) #5. #6}}
\newcommand{\LFormInMarked}[6]{\underline{#1 ?} \ASET{#2 (#3: #4) #5. #6}}

\newcommand{\GInterMarked}[2]{\underline{#1 \rightarrow #2}}
\newcommand{\GFormMarked}[7]{\GInterMarked{#1}{#2}:\ASET{#3 (#4: #5) #6. #7}}

\newcommand{\Rec}[5]{\mu #1 ( #2 ) \ASET{#3} \ENCan{#4} . #5}
\newcommand{\RecDef}[2]{#1 \ENCan{#2}}
\newcommand{\RecDefV}[3]{#1 (#2) \ENCan{#3}}
\newcommand{\GSat}{\mathit{GSat}} 


\newcommand{\typing}[3]{#1\proves #2 \triangleright #3}
\newcommand{\MAssert}[4]{\ENCan{#1, #2, \OT{#3}{#4}}}



\newcommand{\s}{k} \newcommand{\sv}{y} \newcommand{\sn}{s} 


\newcommand{\aname}{u} \newcommand{\av}{x} \newcommand{\af}{a} 

\newcommand{\RecT}{\keyword{t}} 

\newcommand{\participant}[1]{\ensuremath{\mathtt{#1}}}
\newcommand{\q}{\ensuremath{\participant{q}}}
\newcommand{\p}{\ensuremath{\participant{p}}}
\newcommand{\player}{\participant{p}}
\newcommand{\ply}{\player} 

\newcommand{\PInter}[2]{#1 [#2]}
\newcommand{\BRANCHcp}[7]{\PInter{#1}{#2,#3}?\{ #4(#5).#6 \}_{#7}}
\newcommand{\BRANCHsig}[6]{\PInter{#1}{#2,#3}? #4(#5).#6}
\newcommand{\Branch}[6]{\{ #1 (#2\! :\!  #3)\{#4\}.#5\}_{#6}}

\newcommand{\SELECTcp}[6]{\PInter{#1}{#2,#3}! #4\ENCan{#5}; {#6}}
\newcommand{\SELECTdef}[5]{\PInter{#1}{#2,#3}! #4\ENCan{#5}}


\newcommand{\AOUTPUT}[4]{\overline{#1}\ENCan{#2[#3]:#4}} \newcommand{\AINPUT}[5]{{#1} (\AT{#2[#3]}{#4}). #5} \newcommand{\AINPUTT}[4]{{#1} (\AT{#2[#3]}{#4})} \newcommand{\ABOUTPUT}[2]{\overline{#1}(#2)}
\newcommand{\ABINPUT}[2]{{#1}(#2)}

\newcommand{\Qin}[2]{#1^\imode\!\!:\!#2}
\newcommand{\Qout}[2]{#1^\omode\!\!:\!#2}
\newcommand{\Qext}[2]{#1\!:\!#2}

\newcommand{\IF}[1]{{\text{if}}\ #1}
\newcommand{\IFTHENELSE}[3]{\text{if}\ #1\ \text{then}\ #2\ \text{else}\ #3}

\newcommand{\new}[3]{\keyword{new}\: \AT{#1}{#2}\ \keyword{in}\ #3}


\newcommand{\newandjoin}{\keyword{new}\ s : \{a_i : \LA_i[\rr_i]\}_{i\in I} \ \keyword{in}\ P}

\newcommand{\SJOIN}[3]{\mathsf{join}\ #1 [#2] ;#3}
\newcommand{\SLEAVE}[3]{\mathsf{leave}\ #1 [#2] ;#3}
\newcommand{\JOIN}[4]{#1 [#2]:#3 . #4}
\newcommand{\JOINP}[3]{\mathsf{join}\ #1\ \mathsf{as}\ #2\ \mathsf{in}\ #3}
\newcommand{\recur}[6]{(\mu #1 (#2\ \ #3).#4)\ENCan{#5, #6}}
\newcommand{\recurDef}[3]{#1 (#2\ \ #3)}
\newcommand{\recurIn}[2]{\ENCan{#1\ \ #2} }


\newcommand{\Nus}[2]{(\nu #1: #2)}
\newcommand{\Nua}[2]{(\nu #1: #2)}

\newcommand{\INACT}{\mathbf{0}}
\newcommand{\inact}{\mathbf{0}}

\newcommand{\proj}{\pmb{\pmb{\upharpoonright}}}
\newcommand{\Proj}[2]{#1 \upharpoonright {#2}}
\newcommand{\pmt}{\kw{pm}}
\newcommand{\PMForm}[3]{ #1 ! #2 (#3)}
\newcommand{\SelfType}[2]{\keyword{st}(#1, #2)}


\newcommand{\LInter}[2]{#1 [#2]}

\newcommand{\AOUT}[4]{\overline{#1}\ENCan{#2[#3]:#4}}
\newcommand{\AIN}[4]{#1\ENCan{#2[#3]:#4}}

\newcommand{\SOUTPUT}[5]{#1[#2,#3]!\OP{#4}{#5}} \newcommand{\SINPUT}[5]{#1[#2,#3]?\OP{#4}{#5}} 

\newcommand{\newl}[2]{\keyword{new}\ #1\ :\ #2}

\newcommand{\TRANS}[1]{\xrightarrow{#1}}
\newcommand{\TRANSS}[1]{{\xrightarrow{\raisebox{-.3ex}[0pt][0pt]{\scriptsize $#1$}}}}
\newcommand{\TAUTRANS}[1]{\stackrel{#1}{\Longrightarrow}}
\newcommand{\TAUTRANSh}[1]{\stackrel{\hat{#1}}{\Longrightarrow}}

\newcommand{\CHAIN}[1]{ (#1)^{\keyword{c}}}
\newcommand{\LCHAIN}[2]{ (#1)^{\keyword{c}_{#2}}}
\newcommand{\MCHAIN}[1]{ (#1)^{\keyword{cm}}}
\newcommand{\MLCHAIN}[2]{ (#1)^{\keyword{cm}_{#2}}}
\newcommand{\INCHAIN}[1]{ (#1)^{\keyword{ci}}}
\newcommand{\INLCHAIN}[2]{ (#1)^{\keyword{ci}_{#2}}}

\newcommand{\VECL}{\mathfrak{L}} 

\newcommand{\Prod}[1]{\prod_{#1}}

\newcommand{\GW}{{\mathbb{G}}}
\newcommand{\ACTIVE}[1]{#1} \newcommand{\NormalACT}[1]{#1} \newcommand{\INACTIVE}[1]{#1} \newcommand{\INFER}[2]{\frac{\displaystyle{#1}\vspace{2mm}}{
\vspace{2mm}\displaystyle{#2}
}}

\newenvironment{CASES}
{\left\{\begin{array}{lc}}{\end{array}\right.}

\newcommand{\CONFORMS}[2]{#1 \models #2}
\newcommand{\GTRANS}[1]{\TRANS{#1}_\text{g}}
\newcommand{\REL}[1]{\mathcal{#1}}
\newcommand{\RED}{\longrightarrow}


\newcommand{\keyword}[1]{\textsf{\upshape #1}}
\newcommand{\kw}{\keyword} \newcommand{\defk}{\keyword{def}}
\newcommand{\ink}{\keyword{in}}

\newcommand{\andk}{\keyword{and}}
\newcommand{\ork}{\keyword{or}}
\newcommand{\NOT}[1]{\;\;\;\not\!\!\!\!\!\!#1}

\newcommand{\truek}{\keyword{tt}}
\newcommand{\falsek}{\keyword{ff}}
\newcommand{\acceptk}{\keyword{accept}}
\newcommand{\requestk}{\keyword{request}}

\newcommand{\ifk}{\keyword{if}}
\newcommand{\thenk}{\keyword{then}}
\newcommand{\elsek}{\keyword{else}}
\renewcommand{\ifthenelse}[3]{\ifk\ #1\ \thenk\ #2\ \elsek\ #3}
\newcommand{\kend}{\keyword{end}}

\newcommand{\ADD}{\mathfrak{+}} \newcommand{\AND}{\wedge}
\newcommand{\ANDw}{\,\wedge\,}
\newcommand{\OR}{\vee}
\newcommand{\ORw}{\,\vee\,}
\newcommand{\DELETE}{\mathfrak{-} } \newcommand{\Retrv}{\mathfrak{-}}

\newcommand{\fnk}{\keyword{fn}}

\newcommand{\trule}[1]{{\footnotesize{\ensuremath{\lfloor\text{\sc{#1}}\rfloor}}}}
\newcommand{\mrule}[1]{{\footnotesize{\ensuremath{[\text{\sc{#1}}]}}}}

\newcommand{\srule}[1]{{\footnotesize{\ensuremath{(\text{\sc{#1}})}}}}

\newcommand{\monrule}[1]{{\footnotesize{\ensuremath{\lceil{\text{\sc{#1}}}\rceil}}}}

\newcommand{\lprule}[1]{{\footnotesize{\ensuremath{\{\text{\sc{#1}}\}}}}}


\newcommand{\natk}{\kw{nat}}
\newcommand{\boolk}{\kw{bool}}
\newcommand{\intk}{\keyword{int}}
\newcommand{\stringk}{\keyword{string}}

\newcommand{\defink}[2]{\defk\ #1\ \ink\ #2}
\def\eqdef{\;\stackrel{\text{\scriptsize def}}{=}\;}
\def\DEFEQ{\eqdef}

\newcommand{\proves}{\vdash}
\newcommand{\has}{\triangleright}
\newcommand{\IFF}{\Leftrightarrow}
\newcommand{\NULL}{\varepsilon}

\newcommand{\SB}{\sim}
\newcommand{\WB}{\approx}
\newcommand{\LITEQ}{\equiv}              \newcommand{\Cong}{\equiv} \newcommand{\SUBS}[2]{[{#1}/{#2}]}
\newcommand{\MSUBS}[2]{\{{#1}/{#2}\}}
\newcommand{\OFF}[2]{#1 / #2}




\newcommand{\sbj}[1]{\mathsf{sbj}(#1)}
\newcommand{\domain}[1]{\mathsf{dom}(#1)}
\newcommand{\fn}[1]{\mathsf{fn}(#1)}
\newcommand{\bn}[1]{\mathsf{bn}(#1)}

\newcommand{\role}[1]{#1}
\newcommand{\names}[1]{\mathsf{n}(#1)}
\newcommand{\n}[1]{\mathsf{n}(#1)} \newcommand{\num}[1]{\mathsf{num}(#1)}

\newcommand{\erase}[1]{\mathsf{erase}(#1)}
\newcommand{\dom}[1]{\mathsf{dom}(#1)}
\newcommand{\complete}[1]{\keyword{COM}(#1)}
\newcommand{\permutableTo}{\curvearrowright}
\newcommand{\permutableToOnce}{\curvearrowright^1}


\newcommand{\LP}{\mathcal{L}}
\newcommand{\RPP}{RPP}
\newcommand{\Location}{\keyword{L}}
\newcommand{\capability}[1]{\mathsf{capability}(#1)}
\newcommand{\CAPABILITY}[1]{\mathsf{cap}(#1)}
\newcommand{\IMAGINARY}{{imaginary}}
\newcommand{\INNETWORK}{\mbox{in the network}} \newcommand{\OUTNETWORK}{\mbox{out of the network}} 

\newcommand{\Adaptor}{\mathfrak{A}}
\newcommand{\ini}{\keyword{ini}}

\newcommand{\JOINl}[1]{\mathsf{join}(#1)} \newcommand{\JSESS}[1]{#1^\bullet}


\newcommand{\localErr}{\mathsf{localErr}}
\newcommand{\envErr}{\mathsf{envErr}}
\newcommand{\Err}{\mathsf{err}}

\newcommand{\err}{\mathsf{err}}


\newcommand{\EVE}{\mathcal{E}}
\newcommand{\EVEG}{\Theta}
\newcommand{\EVED}{\Delta}
\newcommand{\EveLTS}{\GTRANS}

\newcommand{\pick}[2]{\rightsquigarrow(#1, #2)}

\newcommand{\SBeve}{\sim_{\mathsf{eve}}}
\newcommand{\WBeve}{\approx_{\mathsf{eve}}}

\newcommand{\AOUTNT}[3]{\overline{#1}\ENCan{#2[#3]}}
\newcommand{\NAOUTPUT}[2]{\overline{#1} \ENCan{#2}}
\newcommand{\AOUTPUTNT}[4]{\overline{#1}\ENCan{#2[#3]}; #4} \newcommand{\unmark}[1]{\mathsf{unmark}(#1)}

\newcommand{\GAmarked}{\underline{\GA}}  \newcommand{\LAmarked}{\underline{\LA}}  

\newcommand{\TZ}[1]{#1}
\newcommand{\TZC}[1]{{#1}}

\newcommand{\JOINS}[3]{\kw{join}\ #1\ \kw{as}\ #2:#3}
\newcommand{\MCon}{{C}}

\newcommand{\GF}{\textbf{G}}



\newcommand{\pt}{\kw{pt}}

\newcommand{\namedP}[3]{[#2]_{#3}\mid #1}
\newcommand{\formalM}{\mon{\Gamma; \Delta}@\alpha}
\newcommand{\NP}[2]{[#1]_{#2}}

\newcommand{\namedPmo}[2]{[#1]_{#2}} 

\newcommand{\monitored}[3]{#1[{\mathcal{M}}(#2)\proves #3]}

\newcommand{\field}{\jmath}
\newcommand{\Leffect}[2]{\ENCan{#1\ , #2}}
\newcommand{\Reffect}[2]{\ASET{#1\ , #2}}
\newcommand{\LeffectRole}[3]{\ENCan{#1^{#3}\ , #2^{#3}}}
\newcommand{\ReffectRole}[3]{\ASET{#1^{#3}\ , #2^{#3}}}


\newcommand{\sumtpB}[9]{
#1 \! \rightarrow \! #2: \{ #3 \! (#4)
\! \LEFF{#5} \! \REFF{#7}.#9\}
}

\newcommand{\sumtpBcom}[8]
{
  #1 \! \rightarrow \! #2:
  \{ #3(#4)
  \REFF{{#5}}
}


\newcommand{\lsumOut}[6]{
#1! \{ #2(#3) \REFF{#4}.#6 \}
}

\newcommand{\lsumIn}[6]{
#1? \{ #2(#3) \REFF{#4}.#6 \}}

\newcommand{\rectp}[5]{(\mu #1(#2)\ASET{#3}.#4)\ENCan{#5}}
\newcommand{\insttp}[2]{#1\ENCan{#2}}

\newcommand{\newname}[1]{\pmb{\nu}\, #1}

\newcommand{\prohibited}[2]{\keyword{prohibitedUnder}(#1, #2)}

\newcommand{\allowed}[2]{\keyword{allowed}(#1, #2)}
\newcommand{\after}[2]{\keyword{after}(#1, #2)}

\newcommand{\joinm}[2]{\mathit{join}\ENCan{#1[#2]}}
\newcommand{\jointype}[3]{\mathit{join}\ENCan{#1[#2]:#3}}
\newcommand{\leavem}[2]{\mathit{leave}\ENCan{#1[#2]}}
\newcommand{\leavetype}[3]{\mathit{leave}\ENCan{#1[#2]:#3}}
\newcommand{\newm}[1]{\mathit{new}\ENCan{#1}}

\newcommand{\newmNPD}[4]{\mathit{new}\ENCan{#1:#2[#3],#4}}

\newcommand{\Message}{M}

\newcommand{\newNP}[4]{\mathsf{new}\ #1 \ \mathsf{with} \ #2[#3]\ \mathsf{in} \ #4}

\newcommand{\newNPmo}[3]{\mathsf{new}\ #1 \ \mathsf{with} \ #2\ \mathsf{in} \ #3}

\newcommand{\newNPD}[5]{\mathsf{new}\ #1 \ \mathsf{with} \ #2[#3], #5\ \mathsf{in} \ #4}

\newcommand{\interfacedN}[2]{#1[#2]}

\newcommand{\AddressInterface}{\CAL{A}}
\newcommand{\AI}{\AddressInterface}
\newcommand{\BI}{\CAL{B}}
\newcommand{\Monitor}{\CAL{M}}

\newcommand{\MonitorG}{\mon{\Gamma}}

\newcommand{\namedM}[2]{{#1}}

\newcommand{\WFN}[2]{\proves \interfacedN{#1}{#2}\,:\,\diamond}
\newcommand{\ADR}[1]{\text{adr}(#1)}



\newcommand{\InputAct}[1]{\Downarrow #1}
\newcommand{\OutputAct}[1]{\Uparrow #1}
\newcommand{\TauAct}{\mathbf{\tau}}
\newcommand{\tauact}{\mathbf{\tau}}



\newcommand{\obj}[1]{\mathsf{obj}(#1)}

\newcommand{\NEWP}[2]{\mathsf{new}\ #1\ \mathsf{in}\ #2}

\newcommand{\newP}[2]{\mathsf{new}\ #1\ \mathsf{in}\ #2}

\newcommand{\destination}[1]{\mathsf{dest}(#1)}
\newcommand{\source}[1]{\mathsf{src}(#1)}
\newcommand{\Incoming}{\mathsf{incoming}}
\newcommand{\Outgoing}{\mathsf{outgoing}}

\newcommand{\INW}[2]{#1\proves #2}

\newcommand{\MAP}[1]{[\![#1]\!]}
\newcommand{\MAPenc}[1]{\ENCan{\!\ENCan{#1}\!}}

\newcommand{\monLeft}{\langle\!\langle}
\newcommand{\monRight}{\rangle \!\rangle}
\newcommand{\mon}[1]{\monLeft #1 \monRight}
\newcommand{\unmon}[1]{\mathsf{unmon}(#1)}



\newcommand{\getBI}[1]{\mathsf{int}(#1)}

\newcommand{\COMMENT}[1]{}
\newcommand{\PREDICATE}[1]{{\cal{#1}}}
\newcommand{\EFFECT}[1]{{\ENCan{#1}}}

\newcommand{\midW}{\,\mid\,}
\newcommand{\midWW}{\ \mid\ }

\newcommand{\coherent}{\asymp}

\newcommand{\GQ}[2]{\ENCan{#1\ ;\ #2}}

\newcommand{\smsg}[5]{#1\ENCan{#2,#3,#4\ENCan{#5}}}

\newcommand{\OUTPUT}[3]{\OL{#1}\ENCan{#2};#3}
\newcommand{\INPUT}[3]{#1(#2).#3}

\newcommand{\hastype}{\triangleright}

\newcommand{\effected}[2]{#1\,\mathtt{after}\,#2}

\newcommand{\DSP}{{\sf DSP}}



\newcommand{\PRG}{{P}}
\newcommand{\PRGQ}{{Q}}
\newcommand{\sN}{M}
\newcommand{\dN}{N}

\newcommand{\PRT}{P}

\newcommand{\PRTone}{P_{rt}}

\newcommand{\RInfo}{r}  

\newcommand{\DECLARE}[1]{(\!(#1)\!)}


\newcommand{\ONW}[2]{{#1}} 

\newcommand{\ENV}{\OL{N}}


\newcommand{\IMPLIES}{\Longrightarrow}

\newcommand{\NWSAT}[3]{#1 \models #2 : #3}
\newcommand{\NWSATa}[3]{#1 \models' #2 : #3}
\newcommand{\TRIPLE}[3]{\ENCan{#1, #2, #3}}


\newcommand{\goodP}[3]{#1\, :_#2\, #3}
\newcommand{\goodNW}[2]{#1\, :\, #2}
\newcommand{\goodNWunder}[3]{#1 \,\triangleright\, \goodNW{#2}{#3}}

\newcommand{\NWgood}[2]{#1 \,\triangleright\, #2}
\newcommand{\NLNWgood}[2]{#1 \,:\, #2}
\newcommand{\Ocompose}[2]{#1 \uplus #2}
\newcommand{\Icompose}[2]{#1 , #2}

\newcommand{\principals}[1]{\mathcal{P}(#1)}

\newcommand{\AEnv}{\mathcal{C}}
\newcommand{\InvExtract}[1]{\mathtt{inv}(#1)}
\newcommand{\AllExtract}[1]{\mathtt{inv}(#1)}
\newcommand{\offsession}[3]{#1[\ROLE{#2}]}
\newcommand{\onsession}[3]{#1[\ROLE{#2}]}
\newcommand{\InvNote}[1]{\tiny\blacksquare_{#1}}
\newcommand{\InvNotes}[1]{\tiny\widetilde{\blacksquare}_{#1}}
\newcommand{\InvA}{\textbf{A}}
\newcommand{\newNPmoPR}[3]{\mathsf{new}\ #1 \ \mathsf{with} \ [#2]_{\sigma'}\ \mathsf{in} \ #3}
\newcommand{\SEnv}{\mathcal{S}}
\newcommand{\state}[1]{S^{#1}}
\newcommand{\lstate}[1]{\locked{S}^{#1}}
\newcommand{\ustate}[1]{\unlocked{S}^{#1}}
\newcommand{\statep}[1]{S'^{#1}}
\newcommand{\lstatep}[1]{\locked{S'}^{#1}}
\newcommand{\ustatep}[1]{\unlocked{S'}^{#1}}


\newcommand{\OLtrule}[1]
{{\footnotesize{\ensuremath{\lfloor\OL{\text{\sc{#1}}\rfloor}}}}}

\newcommand{\LINKED}{{dynamic}}
\newcommand{\UNLINKED}{{static}}

\newcommand{\ROLES}[1]{{\mathsf{roles}(#1)}}

\newcommand{\OSPEC}{{\Theta^{\mathsf{ex}}}}
\newcommand{\ISPEC}{{\Theta^{\mathsf{in}}}}

\newcommand{\OSPECi}[1]{{\Theta^{\mathsf{ex}}_#1}}
\newcommand{\ISPECi}[1]{{\Theta^{\mathsf{in}}_#1}}

\newcommand{\NWsat}[3]{#1 \triangleright\, #2 \,:\, #3}

\newcommand{\EC}[1]{{\mathcal E}(#1)}
\newcommand{\EConly}{{\mathcal E}}

\newcommand{\NEC}[1]{{\mathcal N}(#1)}
\newcommand{\NEConly}{{\mathcal N}}

\newcommand{\LockP}{\mathcal{P}}
\newcommand{\LockPOut}{\LockP^\uparrow}
\newcommand{\LockPIn}{\LockP^\downarrow}
\newcommand{\Lock}{\blacktriangledown}
\newcommand{\Unlock}{\blacktriangle}
\newcommand{\Locking}[1]{\Lock #1 \Unlock}
\newcommand{\Evaluate}{\square}
\newcommand{\Read}{\boxdot}
\newcommand{\Write}{\boxtimes}


\newcommand{\GET}{\VEC{x}=get(\VEC{\field});}
\newcommand{\PUT}{put(\VEC{e}, \VEC{\field});}
\newcommand{\PUTUNLOCK}{put(\VEC{e}, \VEC{\field})\Unlock}
\newcommand{\UNLOCK}{\Unlock}

\newcommand{\GETxi}[2]{{#1}=get(#2)}
\newcommand{\PUTxi}[2]{put(#1, #2)}

\newcommand{\Locked}[1]{\underline{#1}}
\newcommand{\LockedInput}[6]
{#1[#2, #3]  ?\Lock \{ #4(#5). #6\}}

\newcommand{\ri}[1]{\mathsf{route}(#1)}
\newcommand{\control}{\mathsf{control}} \newcommand{\addinfo}{\varrho} \newcommand{\newsLabel}[4]{\keyword{new}(s) \{a_i: \LA_i[\rr_i]\} }
\newcommand{\newaLabel}[3]{\keyword{reg}~a :{#2}[#3]}
\newcommand{\newpLabel}[3]{\nu \alpha :{#2}[#3]} \newcommand{\pendingInvitations}[4]{\{a_i\mapsto #1[#2]:#3\}}

\newcommand{\Scribble}{Scribble}
\newcommand{\PARA}[1]{\paragraph*{{\bf #1.}}}

\newcommand{\Ser}{\texttt{S}}
\newcommand{\Cli}{\texttt{C}}
\newcommand{\Agent}{\texttt{A}}
\newcommand{\FON}[1]{{\mathtt{fobj}}(#1)} 

\newcommand{\nEC}[1]{{#1}}

\newcommand{\dual}{\mathit{dual}}
