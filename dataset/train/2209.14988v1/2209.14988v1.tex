
\documentclass{article} \usepackage{iclr2023_conference,times}


\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 \newcommand{\norm}[1]{\left\lVert#1\right\rVert}

\newcommand{\expo}[1]{\exp\left(#1\right)}

\newcommand{\modeltheta}{\mathrm{\Theta}}
\newcommand{\absrp}{\sigma}

\newcommand{\numsamples}{N}
\newcommand{\numsamplescoarse}{N_c}
\newcommand{\numsamplesfine}{N_f}

\newcommand{\distance}{t}
\newcommand{\deltatime}{\delta}
\newcommand{\tinterval}{T}
\newcommand{\sinterval}{S}

\newcommand{\posxy}{xy}
\newcommand{\posxyz}{xyz}
\newcommand{\angletheta}{\theta}
\newcommand{\anglephi}{\phi}
\newcommand{\posall}{\posxyz\angletheta\anglephi}

\newcommand{\numfrequencies}{L}

\newcommand{\Ltrain}{\mathcal{L}}
\newcommand{\raybatch}{\mathcal{R}}
\newcommand{\Ccoarse}{\hat{C}_c(\ray)}
\newcommand{\Cfine}{\hat{C}_f(\ray)}
\newcommand{\Ctrue}{C(\ray)}
\newcommand{\pweight}{w}
\newcommand{\normpweight}{\hat{w}}

\newcommand{\scenename}[1]{\textit{#1}}

\newcommand{\shortpara}[1]{{\bf #1}}

\newcommand{\longmodelname}{\emph{multum in parvo} NeRF\xspace}
\newcommand{\shortmodelname}{Mip-NeRF\xspace}
\newcommand{\shortmodelnamelower}{mip-NeRF\xspace}


\newcommand{\featurename}{integrated positional encoding\xspace}
\newcommand{\shortfeaturename}{IPE\xspace}

\newcommand{\posenc}{positional encoding\xspace}
\newcommand{\shortposenc}{PE\xspace}

\newcommand{\numhidden}{n}

\newcommand{\posencfun}{\gamma}
\newcommand{\coordenc}{\gamma(\mathbf{x})}

\newcommand{\rayorigin}{\mathbf{o}}
\newcommand{\raydir}{\mathbf{d}}
\newcommand{\transpose}{{\operatorname{T}}}

\newcommand\submissionjunk[1]{ #1 }

\newcommand\estimate[1]{\hat{#1}}
\newcommand{\ray}{\mathbf{r}}
\newcommand{\normsq}[1]{\left\lVert#1\right\rVert^2_2}
\newcommand{\position}{\mathbf{x}}
\newcommand{\col}{\mathbf{c}}
\newcommand{\Col}{\mathbf{C}}
\newcommand{\trueCol}{\mathbf{C}^*}
\newcommand{\mlp}{\operatorname{MLP}}
\newcommand{\modelweights}{\theta}\newcommand\decay[1]{\alpha \left( #1 \right)}
\newcommand{\basis}{\mathbf{P}}

\newcommand{\density}{\tau}
\newcommand{\baseradius}{\dot r}
\newcommand{\baseangle}{\theta}
\newcommand{\conefun}{\operatorname{F}}
\newcommand{\zval}{t}
\newcommand{\zvec}{\mathbf{\zval}}

\newcommand{\interpolate}{\operatorname{I}}

\newcommand{\proposal}[1]{\hat{#1}}


\newcommand{\textpyr}[5]{
	\begin{overpic}[width=1.3in]{figures/multiblender_pyrs/#1}
	\put (67,2) {\tiny \sethlcolor{white}\hl{}}
	\put (84,29) {\tiny \sethlcolor{white}\hl{}}
	\put (84,18) {\tiny \sethlcolor{white}\hl{}}
	\put (76,10) {\tiny \sethlcolor{white}\hl{}}
    \end{overpic}
}

\newcommand{\flatim}[1]{
    \includegraphics[width=0.9in]{figures/multiblender_pyrs/#1}
}

\newcommand{\myparagraph}[1]{\noindent {\bf #1}\,\,\,}

\newcommand{\zc}{\zval_\mu}
\newcommand{\zd}{\zval_\delta}

\newcommand{\dirichlet}{\alpha}
\newcommand{\lossmult}{\lambda}

\newcommand{\numsteps}{n}
\newcommand{\learnrate}{\eta}

\newcommand{\thousand}{K}
\newcommand{\million}{M}

\newcommand{\covmat}{\boldsymbol{\Sigma}}
\newcommand{\normal}{\boldsymbol{n}}

\newcommand{\neardist}{\t_\mathit{near}}
\newcommand{\fardist}{t_\mathit{far}}

\newcommand{\albedo}{\boldsymbol{\rho}}

\newcommand{\pointlight}{\boldsymbol{\ell}}
\newcommand{\pointlightcolor}{\boldsymbol{\ell}_{\rho}}
\newcommand{\ambientlightcolor}{\boldsymbol{\ell}_a}

\newcommand{\distloss}{\mathcal{L}_{\mathrm{dist}}}
\newcommand{\proploss}{\mathcal{L}_{\mathrm{prop}}}
\newcommand{\reconloss}{\mathcal{L}_{\mathrm{recon}}}

 
\usepackage{algorithm}
\usepackage{algpseudocode}

\usepackage[hidelinks]{hyperref}
\usepackage{url}
\usepackage{todonotes}
\usepackage{xspace}
\usepackage{subcaption}
\usepackage{graphicx}
\usepackage[autolanguage]{numprint}
\usepackage{wrapfig}
\usepackage[utf8]{inputenc}
\usepackage{microtype}
\usepackage{soul}
\usepackage{float}
\usepackage{gensymb}
\usepackage{amssymb}


\usepackage[group-separator={,}]{siunitx}

\usepackage{booktabs}
\usepackage{multirow}
\usepackage{array}
\newcolumntype{H}{>{\setbox0=\hbox\bgroup}c<{\egroup}@{}}

\newcommand{\imagen}{Imagen\xspace}
\newcommand{\sk}[1]{\todo[inline,color=green!20!white]{\textbf{SK:} #1}}
\newcommand{\bp}[1]{\todo[inline,color=green!20!white]{\textbf{BP:} #1}}
\newcommand{\aj}[1]{\todo[inline,color=green!20!white]{\textbf{AJ:} #1}}
\newcommand{\bmild}[1]{\todo[inline,color=green!20!white]{\textbf{BM:} #1}}
\newcommand{\citex}[1]{{\color{red}{[CITE: #1]}}}
\newcommand{\refx}[1]{{\color{red}{[REF: #1]}}}
\newcommand{\sname}{Score Distillation Sampling\xspace}
\newcommand{\name}{DreamFusion\xspace}
\newcommand{\sacc}{SDS\xspace}
\newcommand{\dreamfusion}{DreamFusion\xspace}
\newcommand{\pretrained}{pretrained\xspace}

\newcommand{\metric}[2]{{\nprounddigits{3}\numprint{#1}\small{\numprint{#2}}}}
\newcommand{\pct}[2]{{\nprounddigits{1}\numprint{#1}\small{\numprint{#2}}}}
\newcommand{\pctm}[2]{{\nprounddigits{1}\numprint{#1}}}  

\newcommand{\tightcaption}[1]{\vspace{-6mm} \caption{#1} \vspace{1mm}}

\newcommand{\x}[0]{\mathbf{x}}
\newcommand{\z}[0]{\mathbf{z}}
\newcommand{\zt}[0]{{\z}_t}
\newcommand{\zT}[0]{{\z}_T}
\newcommand{\zs}[0]{{\z}_{t-1}}
\newcommand{\zp}[0]{{\z}_{t+1}}
\newcommand{\ldiff}[0]{\mathcal{L}_{\text{Diff}}}
\newcommand{\ldist}[0]{\mathcal{L}_{\text{SDS}}}
\newcommand{\xhat}[2]{\hat{x}(#1; #2)}
\newcommand{\epshat}[2]{\hat{\epsilon}_\theta(#1; #2)}
\newcommand{\npos}[0]{\boldsymbol{\mu}}
\newcommand{\websiteURL}[0]{https://dreamfusion3d.github.io/}
\newcommand{\websiteURLText}[0]{dreamfusion3d.github.io}



\newcommand{\websiteLink}[0]{{\color{blue}{\href{\websiteURL}{\texttt{\websiteURLText}}}}\xspace}

\newcommand{\el}{\phi_{\textrm{cam}}}
\newcommand{\az}{\theta_{\textrm{cam}}}

\definecolor{mycyan}{HTML}{D6FDFE}
\definecolor{mypink}{HTML}{F7CECD}

\usepackage{listings}
\usepackage{lstautogobble}  \usepackage{color}          \usepackage{zi4}            \definecolor{bluekeywords}{rgb}{0.13, 0.13, 1}
\definecolor{greencomments}{rgb}{0, 0.5, 0}
\definecolor{redstrings}{rgb}{0.9, 0, 0}
\definecolor{graynumbers}{rgb}{0.5, 0.5, 0.5}
\lstset{
    autogobble,
    columns=fullflexible,
    showspaces=false,
    showtabs=false,
    breaklines=true,
    showstringspaces=false,
    breakatwhitespace=true,
    escapeinside={(*@}{@*)},
    commentstyle=\color{greencomments},
    keywordstyle=\color{bluekeywords},
    stringstyle=\color{redstrings},
    numberstyle=\color{graynumbers},
    basicstyle=\ttfamily\footnotesize,
    frame=l,
    framesep=12pt,
    xleftmargin=12pt,
    tabsize=4,
    captionpos=b
}


\title{DreamFusion: Text-to-3D using 2D Diffusion} 


\author{
Ben Poole, Ajay Jain, Jonathan T. Barron, Ben Mildenhall\\
Google Research, UC Berkeley\\
\texttt{\{pooleb, barron, bmild\}@google.com, ajayj@berkeley.edu}
}


\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}
Recent breakthroughs in text-to-image synthesis have been driven by diffusion models trained on billions of image-text pairs. Adapting this approach to 3D synthesis would require large-scale datasets of labeled 3D data and efficient architectures for denoising 3D data, neither of which currently exist. In this work, we circumvent these limitations by using a pretrained 2D text-to-image diffusion model to perform text-to-3D synthesis. We introduce a loss based on probability density distillation that enables the use of a 2D diffusion model as a prior for optimization of a parametric image generator. Using this loss in a DeepDream-like procedure, we optimize a randomly-initialized 3D model (a Neural Radiance Field, or NeRF) via gradient descent such that its 2D renderings from random angles achieve a low loss. The resulting 3D model of the given text can be viewed from any angle, relit by arbitrary illumination, or composited into any 3D environment. Our approach requires no 3D training data and no modifications to the image diffusion model, demonstrating the effectiveness of \pretrained image diffusion models as priors. See \websiteLink for a more immersive view into our 3D results.








\end{abstract}



\section{Introduction}
Generative image models conditioned on text now support high-fidelity, diverse and controllable image synthesis~\citep{Nichol2022GLIDETP,dalle,dalle2,imagen,palette,parti,sr3}. These quality improvements have come from large aligned image-text datasets \citep{laion5b} and scalable generative model architectures. Diffusion models are particularly effective at learning high-quality image generators with a stable and scalable denoising objective \citep{ddpm, pmlr-v37-sohl-dickstein15, scoresde}. Applying diffusion models to other modalities has been successful, but requires large amounts of modality-specific training data \citep{wavegrad,videodiffusion,diffwave}. In this work, we develop techniques to transfer pretrained 2D image-text diffusion models to 3D object synthesis, without any 3D data (see Figure~\ref{fig:teaser}). Though 2D image generation is widely applicable, simulators and digital media like video games and movies demand thousands of detailed 3D assets to populate rich interactive environments. 3D assets are currently designed by hand in modeling software like Blender and Maya3D, a process requiring a great deal of time and expertise. Text-to-3D generative models could lower the barrier to entry for novices and improve the workflow  of experienced artists.

3D generative models can be trained on explicit representations of structure like voxels~\citep{3dgan, chen2018text2shape} and point clouds~\citep{pointflow, ShapeGF, pointvoxel}, but the 3D data needed is relatively scarce compared to plentiful 2D images.
Our approach learns 3D structure using only a 2D diffusion model trained on images, and sidesteps this issue.
GANs can learn controllable 3D generators from photographs of a single object category, by placing an adversarial loss on 2D image renderings of the output 3D object or scene~\citep{henzler2019platonicgan,HoloGAN2019,orel2022stylesdf}. Though these approaches have yielded promising results on specific object categories such as faces, they have not yet been demonstrated to support arbitrary text.

Neural Radiance Fields, or NeRF \citep{mildenhall2020nerf} are an approach towards inverse rendering in which a volumetric raytracer is combined with a neural mapping from spatial coordinates to color and volumetric density. NeRF has become a critical tool for neural inverse rendering~\citep{tewari2022advances}.
Originally, NeRF was found to work well for ``classic'' 3D reconstruction tasks: many images of a scene are provided as input to a model, and a NeRF is optimized to recover the geometry of that specific scene, which allows for novel views of that scene from unobserved angles to be synthesized.


\newcommand{\teaserwidthb}{.45\textwidth}
\newcommand{\betweencols}{\,\,\,}

\par\vfill\break \renewcommand{\tightcaption}[1]{\vspace{-6mm} \caption{#1} \vspace{1mm}}
\begin{figure}[H]
\vspace{-1.3cm}
\captionsetup[subfigure]{labelformat=empty}
\centering
\makebox[\textwidth][c]{
\begin{tabular}{@{}c@{\quad}c@{\quad}c@{\quad}c@{\quad}c@{}}
    \begin{subfigure}[t]{\teaserwidthb}
    \includegraphics[width=\columnwidth]{figs/teaserv2/a_DSLR_photo_of_an_orangutan_making_a_clay_bowl_on_a_throwing_wheel.jpg}
    \tightcaption{\scriptsize{an orangutan making a clay bowl on a throwing wheel*}}
    \end{subfigure} &
    \begin{subfigure}[t]{\teaserwidthb}
    \includegraphics[width=\columnwidth]{figs/teaserv2/a_zoomed_out_DSLR_photo_of_a_raccoon_astronaut_holding_his_helmet.jpg}
    \tightcaption{\scriptsize{a raccoon astronaut holding his helmet}}
    \end{subfigure} &
    \begin{subfigure}[t]{\teaserwidthb}
    \includegraphics[width=\columnwidth]{figs/teaserv2/a_DSLR_photo_of_a_blue_jay_standing_on_a_large_basket_of_rainbow_macarons.jpg}
    \tightcaption{\scriptsize{a blue jay standing on a large basket of rainbow macarons*}}
    \end{subfigure} \\
    \begin{subfigure}[t]{\teaserwidthb}
    \includegraphics[width=\columnwidth]{figs/teaserv2/a_DSLR_photo_of_a_corgi_taking_a_selfie.jpg}
    \tightcaption{\scriptsize{a corgi taking a selfie*}}
    \end{subfigure} &
    \begin{subfigure}[t]{\teaserwidthb}
    \includegraphics[width=\columnwidth]{figs/teaserv2/a_zoomed_out_DSLR_photo_of_a_table_with_dim_sum_on_it.jpg}
    \tightcaption{\scriptsize{a table with dim sum on it}}
    \end{subfigure} &
    \begin{subfigure}[t]{\teaserwidthb}
    \includegraphics[width=\columnwidth]{figs/teaserv2/a_DSLR_photo_of_a_lion_reading_the_newspaper.jpg}
    \tightcaption{\scriptsize{a lion reading the newspaper*}}
    \end{subfigure} \\
    \begin{subfigure}[t]{\teaserwidthb}
    \includegraphics[width=\columnwidth]{figs/teaserv2/Michelangelo_style_statue_of_dog_reading_news_on_a_cellphone.jpg}
    \tightcaption{\scriptsize{Michelangelo style statue of dog reading news on a cellphone}}
    \end{subfigure} &
    \begin{subfigure}[t]{\teaserwidthb}
    \includegraphics[width=\columnwidth]{figs/teaserv2/a_DSLR_photo_of_a_tiger_dressed_as_a_doctor.jpg}
    \tightcaption{\scriptsize{a tiger dressed as a doctor*}}
    \end{subfigure} &
    \begin{subfigure}[t]{\teaserwidthb}
    \includegraphics[width=\columnwidth]{figs/teaserv2/a_DSLR_photo_of_a_steam_engine_train,_high_resolution.jpg}
    \tightcaption{\scriptsize{a steam engine train, high resolution*}}
    \end{subfigure} \\
    \begin{subfigure}[t]{\teaserwidthb}
    \includegraphics[width=\columnwidth]{figs/teaserv2/a_DSLR_photo_of_a_frog_wearing_a_sweater.jpg}
    \tightcaption{\scriptsize{a frog wearing a sweater*}}
    \end{subfigure} &
    \begin{subfigure}[t]{\teaserwidthb}
    \includegraphics[width=\columnwidth]{figs/teaserv2/a_DSLR_photo_of_a_humanoid_robot_playing_the_cello.jpg}
    \tightcaption{\scriptsize{a humanoid robot playing the cello*}}
    \end{subfigure} &
    \begin{subfigure}[t]{\teaserwidthb}
    \includegraphics[width=\columnwidth]{figs/teaserv2/a_zoomed_out_DSLR_photo_of_Sydney_opera_house,_aerial_view.jpg}
    \tightcaption{\scriptsize{Sydney opera house, aerial view}}
    \end{subfigure} \\
    \begin{subfigure}[t]{\teaserwidthb}
    \includegraphics[width=\columnwidth]{figs/teaserv2/a_zoomed_out_DSLR_photo_of_an_all-utility_vehicle_driving_across_a_stream.jpg}
    \tightcaption{\scriptsize{an all-utility vehicle driving across a stream}}
    \end{subfigure} &
    \begin{subfigure}[t]{\teaserwidthb}
    \includegraphics[width=\columnwidth]{figs/teaserv2/a_DSLR_photo_of_a_chimpanzee_dressed_like_Henry_VIII_king_of_England.jpg}
    \tightcaption{\scriptsize{a chimpanzee dressed like Henry VIII king of England*}}
    \end{subfigure} &
    \begin{subfigure}[t]{\teaserwidthb}
    \includegraphics[width=\columnwidth]{figs/teaserv2/a_zoomed_out_DSLR_photo_of_a_baby_bunny_sitting_on_top_of_a_stack_of_pancakes.jpg}
    \tightcaption{\scriptsize{a baby bunny sitting on top of a stack of pancakes}}
    \end{subfigure} \\
    \begin{subfigure}[t]{\teaserwidthb}
    \includegraphics[width=\columnwidth]{figs/teaserv2/a_sliced_loaf_of_fresh_bread.jpg}
    \tightcaption{\scriptsize{a sliced loaf of fresh bread}}
    \end{subfigure} &
    \begin{subfigure}[t]{\teaserwidthb}
    \includegraphics[width=\columnwidth]{figs/teaserv2/a_DSLR_photo_of_a_bulldozer_clearing_away_a_pile_of_snow.jpg}
    \tightcaption{\scriptsize{a bulldozer clearing away a pile of snow*}}
    \end{subfigure} &
    \begin{subfigure}[t]{\teaserwidthb}
    \includegraphics[width=\columnwidth]{figs/teaserv2/a_DSLR_photo_of_a_classic_Packard_car.jpg}
    \tightcaption{\scriptsize{a classic Packard car*}}
    \end{subfigure} \\
    \begin{subfigure}[t]{\teaserwidthb}
    \includegraphics[width=\columnwidth]{figs/teaserv2/a_wide_angle_zoomed_out_DSLR_photo_of_zoomed_out_view_of_Tower_Bridge_made_out_of_gingerbread_and_candy.jpg}
    \tightcaption{\scriptsize{\!\!\!zoomed out view of Tower Bridge made out of gingerbread and candy\!\!\!\!\!\!\!\!\!\!\!\!\!\!}}
    \end{subfigure} &
    \begin{subfigure}[t]{\teaserwidthb}
    \includegraphics[width=\columnwidth]{figs/teaserv2/a_DSLR_photo_of_a_robot_and_dinosaur_playing_chess,_high_resolution.jpg}
    \tightcaption{\scriptsize{a robot and dinosaur playing chess, high resolution*}}
    \end{subfigure} &
    \begin{subfigure}[t]{\teaserwidthb}
    \includegraphics[width=\columnwidth]{figs/teaserv2/a_squirrel_gesturing_in_front_of_an_easel_showing_colorful_pie_charts.jpg}
    \tightcaption{\scriptsize{\!\!\!a squirrel gesturing in front of an easel showing colorful pie charts\!\!\!}}
    \end{subfigure} 
\end{tabular}
}
\caption{
\dreamfusion uses a \pretrained text-to-image diffusion model to generate realistic 3D models from text prompts. Rendered 3D models are presented from two views, with textureless renders and normals to the right.  See \websiteLink for videos of these results. Symbols indicate the following prompt prefixes which we found helped to improve the quality and realism: \\
\begin{tabular}{@{\quad\quad\quad}c@{\quad\quad}c@{\quad\quad}c}
* {\scriptsize a DSLR photo of...} &
 {\scriptsize a zoomed out DSLR photo of...} & 
 {\scriptsize a wide angle zoomed out DSLR photo of...}
\end{tabular}
}
\label{fig:teaser}
\end{figure}























 
Many 3D generative approaches have found success in incorporating NeRF-like models as a building block within a larger generative system~\citep{graf,chanmonteiro2020pi-GAN,Chan2021eg3d,gu2021stylenerf, https://doi.org/10.48550/arxiv.2203.14622}.
One such approach is Dream Fields~\citep{jain2021dreamfields}, which uses frozen image-text joint embedding models from CLIP and an optimization-based approach to train NeRFs. This work showed that pretrained 2D image-text models may be used for 3D synthesis, though 3D objects produced by this approach tend to lack realism and accuracy. CLIP has been used to guide other approaches based on voxel grids and meshes~\citep{clipforge, clipmatrix, clipnerf}.

We adopt a similar approach to Dream Fields, but replace CLIP with a loss derived from distillation of a 2D diffusion model. Our loss is based on probabilty density distillation, minimizing the KL divergence between a family of Gaussian distribution with shared means based on the forward process of diffusion and the score functions learned by the pretrained diffusion model. The resulting Score Distillation Sampling (\sacc) method enables sampling via optimization in differentiable image parameterizations.
By combining \sacc with a NeRF variant tailored to this 3D generation task, \dreamfusion{} generates high-fidelity coherent 3D objects and scenes for a  diverse set of user-provided text prompts.







\section{Diffusion Models and Score Distillation Sampling}
\label{sec:diffusion_and_sds}

Diffusion models 
are latent-variable generative models that learn to gradually transform a sample from a tractable noise distribution towards a data distribution \citep{pmlr-v37-sohl-dickstein15, ddpm}. Diffusion models consist of a forward process  that slowly removes structure from data  by adding noise, and a reverse process or generative model  that slowly adds structure starting from noise .  The forward process is typically a Gaussian distribution that transitions from the previous less noisy latent at timestep  to a noisier latent at timestep .
We can compute the marginal distribution of the latent variables at timestep  given an initial datapoint  by integrating out intermediate timesteps: . The marginals integrating out the data density  are  , and correspond to smoothed versions of the data distribution. The coefficients  and  are chosen such that  is close to the data density at the start of the process () and close to Gaussian at the end of the forward process (), with  chosen to preserve variance \citep{kingma2021on,scoresde}.

The generative model  is trained to slowly add structure starting from random noise  with transitions . Theoretically, with enough timesteps, the optimal reverse process step is also Gaussian and related to an optimal MSE denoiser \citep{pmlr-v37-sohl-dickstein15}. Transitions are typically parameterized as  where  is a posterior distribution derived from the forward process and   is a learned approximation of the optimal denoiser. Instead of directly predicting , \citet{ddpm} trains an image-to-image U-Net  that predicts the noise content of the latent : .
The predicted noise can be related to a predicted score function for the smoothed density  through Tweedie's formula \citep{Robbins1992}:
. 

Training the generative model with a (weighted) evidence lower bound (ELBO) simplifies to a weighted denoising score matching objective for parameters  \citep{ddpm,kingma2021on}:

where  is a weighting function that depends on the timestep .
Diffusion model training can thereby be viewed as either learning a latent-variable model \citep{pmlr-v37-sohl-dickstein15,ddpm}, or learning a sequence of score functions corresponding to noisier versions of the data \citep{vincent2011connection, song2019gradients,scoresde}. We will use  to denote the approximate marginal distribution whose score function is given by .

Our work builds on text-to-image diffusion models that learn  conditioned on text embeddings  \citep{imagen, dalle2, Nichol2022GLIDETP}. These models use classifier-free guidance (CFG, \citeauthor{classifierfree}, \citeyear{classifierfree}), which jointly learns an unconditional model to enable higher quality generation via a guidance scale parameter :
.
CFG alters the score function to prefer regions where the ratio of the conditional density to the unconditional density is large. In practice, setting  improves sample fidelity at the cost of diversity. We use  and  throughout to denote the guided version of the noise prediction and marginal distribution.




\subsection{How can we sample in parameter space, not pixel space?}
Existing approaches for sampling from diffusion models generate a sample that is the same type and dimensionality as the observed data the model was trained on \citep{scoresde, ddim}.
Though conditional diffusion sampling enables quite a bit of flexibility (e.g.\ inpainting), diffusion models trained on pixels have traditionally been used to sample only pixels.
We are not interested in sampling pixels; \textbf{we instead want to create 3D models that look like good images when rendered from random angles}. Such models can be specified as a differentiable image parameterization (DIP, \citeauthor{mordvintsev2018differentiable}, \citeyear{mordvintsev2018differentiable}), where a differentiable generator  transforms parameters  to create an image . DIPs allow us to express constraints, optimize in more compact spaces (e.g. arbitrary resolution coordinate-based MLPs), or leverage more powerful optimization algorithms for traversing pixel space.  For 3D, we let  be parameters of a 3D volume and  a volumetric renderer. To learn these parameters, we require a loss function that can be applied to diffusion models.

Our approach leverages the structure of diffusion models to enable tractable sampling via optimization --- a loss function that, when minimized, yields a sample. We optimize over parameters  such that  looks like a sample from the frozen diffusion model. To perform this optimization, we need a differentiable loss function where plausible images have low loss, and implausible images have high loss, in a similar style to DeepDream~\citep{deepdream}.
We first investigated reusing the diffusion training loss (Eqn.~\ref{eq:train}) to find modes of the learned conditional density . While modes of generative models in high dimensions are often far from typical samples \citep{mlebad}, the multiscale nature of diffusion model training may help to avoid these pathologies.  Minimizing the diffusion training loss with respect to a {\bf generated datapoint}  gives .
In practice, we found that this loss function did not produce realistic samples even when using an identity DIP where . Concurrent work from \citet{ddpmpnp} shows that this method can be made to work with carefully chosen timestep schedules, but we found this objective brittle and its timestep schedules challenging to tune. 


\begin{figure}[t]
    \centering
    \includegraphics[width=\linewidth]{figs/sampling_schematic_barronfont.pdf}
    \vspace{-7mm}
    \caption{Comparison of 2D sampling methods from a text-to-image diffusion model with text ``{\small\em a photo of a tree frog wearing a sweater}.'' For score distillation sampling, as an example we use an image generator that restricts images to be symmetric by having .}
    \label{fig:image_schematic}
\end{figure}


To understand the difficulties of this approach, consider the gradient of :

where we absorb the constant  into . In practice, the U-Net Jacobian term is expensive to compute (requires backpropagating through the diffusion model U-Net), and poorly conditioned for small noise levels as it is trained to approximate the scaled Hessian of the marginal density. 
We found that omitting the U-Net Jacobian term leads to an effective gradient for optimizing DIPs with diffusion models:

Intuitively, this loss perturbs  with a random amount of noise corresponding to the timestep , and estimates an update direction that follows the score function of the diffusion model to move to a higher density region. While this gradient for learning DIPs with diffusion models may appear ad hoc, in Appendix \ref{sec:appendix:vos_math} we show that it is the gradient of a weighted probability density distillation loss \citep{Oord2018ParallelWF} using the learned score functions from the diffusion model:

We name our sampling approach \sname (\sacc) as it is related to distillation, but uses score functions instead of densities. We refer to it as a sampler because the noise in the variational family  disappears as  and the mean parameter of the variational distribution  becomes the sample of interest.  
Our loss is easy to implement (see Fig.~\ref{fig:score_sampling_code}), and relatively robust to the choice of weighting . Since the diffusion model directly predicts the update direction, \textbf{we do not need to backpropagate through the diffusion model}; the model simply acts like an efficient, frozen critic that predicts image-space edits. 









Given the mode-seeking nature of , it may be unclear if minimizing this loss will produce good samples. In Fig.~\ref{fig:image_schematic}, we demonstrate that \sacc can generate constrained images with reasonable quality. Empirically, we found that setting the guidance weight  to a large value for classifier-free guidance improves quality (Appendix Table~\ref{fig:gwsweep}). \sacc produces detail comparable to ancestral sampling, but enables new transfer learning applications because it operates in parameter space.



\begin{figure}[t]
\centering
\includegraphics[width=\columnwidth,trim={2.2cm 10.25cm 4.7cm 8.25cm},clip]{figs/dreamfusion_diagram_phi.pdf}
  \caption{\dreamfusion generates 3D objects from a natural language caption such as {\footnotesize\em ``a DSLR photo of a peacock on a surfboard.''}
The scene is represented by a Neural Radiance Field that is randomly initialized and trained from scratch for each caption. Our NeRF parameterizes volumetric density and albedo (color) with an MLP. We render the NeRF from a random camera, using normals computed from gradients of the density to shade the scene with a random lighting direction.
Shading reveals geometric details that are ambiguous from a single viewpoint. To compute parameter updates, \dreamfusion diffuses the rendering and reconstructs it with a (frozen) conditional Imagen model to predict the injected noise .
  This contains structure that should improve fidelity, but is high variance. Subtracting the injected noise produces a low variance update direction  that is backpropagated through the rendering process to update the NeRF MLP parameters.}
\label{fig:diagram}
\end{figure}



\section{The \dreamfusion Algorithm}

Now that we have demonstrated how a diffusion model can be used as a loss within a generic continuous optimization problem to generate samples, we will construct our specific algorithm that allows us to generate 3D assets from text. For the diffusion model, we use the Imagen  model from \citet{imagen}, which has been trained to synthesize images from text. We only use the  base model (not the super-resolution cascade for generating higher-resolution images), and use this pretrained model as-is with no modifications. To synthesize a scene from text, we initialize a NeRF-like model with random weights, then repeatedly render views of that NeRF from random camera positions and angles, using these renderings as the input to our score distillation loss function that wraps around Imagen. As we will demonstrate, simple gradient descent with this approach eventually results in a 3D model (parameterized as a NeRF) that resembles the text. See Fig.~\ref{fig:diagram} for an overview of our approach.


\subsection{Neural Rendering of a 3D Model}
\label{sec:nerf}
NeRF is a technique for neural inverse rendering that consists of a volumetric raytracer and a multilayer perceptron (MLP). Rendering an image from a NeRF is done by casting a ray for each pixel from a camera's center of projection through the pixel's location in the image plane and out into the world. Sampled 3D points  along each ray are then passed through an MLP, which produces 4 scalar values as output: a volumetric density  (how opaque the scene geometry at that 3D coordinate is) and an RGB color . These densities and colors are then alpha-composited from the back of the ray towards the camera, producing the final rendered RGB value for the pixel:

In the traditional NeRF use-case we are given a dataset of input images and associated camera positions and the NeRF MLP is trained from random initialization using a mean squared error loss function between each pixel's rendered color and the corresponding ground-truth color from the input image. 
This yields a 3D model (parameterized by the weights of the MLP) that can produce realistic renderings from previously-unseen views. 
Our model is built upon mip-NeRF 360 \citep{Barron2021MipNeRF3U}, which is an improved version of NeRF that reduces aliasing. Though mip-NeRF 360 was originally designed for 3D reconstruction from images,  its improvements are also helpful for our generative text-to-3D task (see Appendix for details).




\myparagraph{Shading.}
Traditional NeRF models emit radiance, which is RGB color conditioned on the ray direction from which the 3D point is being observed.
In contrast, our MLP parameterizes the color of the surface itself, which is then lit by an illumination that we control (a process commonly referred to as ``shading'').
Previous work on generative or multiview 3D reconstruction using NeRF-like models have proposed a variety of reflectance models~\citep{bi2020neural,boss2021nerd,srinivasan2021nerv,pan2022gan2x}.
We use an RGB albedo  (the color of the material) for each point:

where  is volumetric density. Calculating the final shaded output color for the 3D point requires a normal vector indicating the local orientation of the object's geometry. This  surface normal vector can be computed by normalizing the negative gradient of density  with respect to the 3D coordinate :  \citep{yariv2020idr,srinivasan2021nerv}.
With each normal  and material albedo , assuming some point light source with 3D coordinate  and color , and an ambient light color , we render each point along the ray using diffuse reflectance \citep{lambert1760photometria, Ramamoorthi2001ASF} to produce a color  for each point:

With these colors and our previously-generated densities, we approximate the volume rendering integral with the same rendering weights  used in standard NeRF (Equation~\ref{eq:volrend}).
As in previous work on text-to-3D generation~\citep{hong2022avatarclip,text2mesh}, we find it beneficial to randomly replace the albedo color  with white  to produce a ``textureless'' shaded output.
This prevents the model from producing a degenerate solution in which scene content is drawn onto flat geometry to satisfy the text conditioning. For example, this encourages optimization to yield a 3D squirrel instead of a flat surface containing an image of a squirrel, both of which may appear identical from certain viewing angles and illumination conditions. 




\myparagraph{Scene Structure.} While our method can generate some complex scenes, we find that it is helpful to only query the NeRF scene representation within a fixed bounding sphere, and use an environment map generated from a second MLP that takes positionally-encoded ray direction as input to compute a background color. We composite the rendered ray color on top of this background color using the accumulated alpha value.
This prevents the NeRF model from filling up space with density very close to the camera while still allowing it to paint an appropriate color or backdrop behind the generated scene. For generating single objects instead of scenes, a reduced bounding sphere can be useful.



\myparagraph{Geometry regularizers.}
The mip-NeRF 360 model we build upon contains many other details that we omit for brevity. We include a regularization penalty on the opacity along each ray similar to \citet{jain2021dreamfields} to prevent unneccesarily filling in of empty space. To prevent pathologies in the density field where normal vectors face backwards away from the camera we use a modified version of the orientation loss proposed in Ref-NeRF~\citep{verbin2022refnerf}. This penalty is important when including textureless shading as the density field will otherwise attempt to orient normals away from the camera so that the shading becomes darker. Full details on these regularizers and additional hyperparameters of NeRF are presented in the Appendix~\ref{sec:nerf_hparams}.




\begin{figure}[t]
\includegraphics[width=\columnwidth]{figs/squirreljourney_v2.pdf}
\caption{\dreamfusion can be used to create and refine 3D scenes. Here we iteratively refine an example text prompt, while rendering each generated scene from four different viewpoints.}
\label{fig:journey}
\vspace{-5mm}
\end{figure}

\subsection{Text-to-3D synthesis} Given a pretrained text-to-image diffusion model, a differentiable image parameterization in the form of a NeRF, and a loss function whose minima are good samples, we have all the components needed for text-to-3D synthesis using no 3D data. For each text prompt, we train a randomly initialized NeRF from scratch. Each iteration of \dreamfusion optimization performs the following: (1) randomly sample a camera and light, (2) render an image of the NeRF from that camera and shade with the light, (3) compute gradients of the \sacc loss with respect to the NeRF parameters, (4) update the NeRF parameters using an optimizer. We detail each of these steps below, and present pseudocode in Appendix~\ref{fig:score_sampling_code}.  

\myparagraph{1. Random camera and light sampling.} At each iteration, a camera position is randomly sampled in spherical coordinates, with elevation angle , azimuth angle , and distance from the origin in . For reference, the scene bounding sphere described previously has radius . We also sample a ``look-at'' point around the origin and an ``up'' vector, and combine these with the camera position to create a camera pose matrix. We additionally sample a focal length multiplier  such that the focal length is , where  is the image width in pixels. The point light position  is sampled from a distribution centered around the camera position. We found using a wide range of camera locations to be critical for synthesizing coherent 3D scenes, and a wide range of camera distances helps to improve the resolution of the learned scene.

\myparagraph{2. Rendering.}
Given the camera pose and light position, we render the shaded NeRF model at  resolution as described in Section~\ref{sec:nerf}. We randomly choose between the illuminated color render, a textureless render, and a rendering of the albedo without any shading.

\myparagraph{3. Diffusion loss with view-dependent conditioning.} 
Text prompts often describe canonical views of an object that are not good descriptions when sampling different views. We therefore found it beneficial to append view-dependent text to the provided input text based on the location of the randomly sampled camera. For high elevation angles , we append ``overhead view.'' For , we use a weighted combination of the text embeddings for appending ``front view,'' ``side view,'' or ``back view'' depending on the value of the azimuth angle  (see App.~\ref{sec:nerf_hparams} for details).
We use the pretrained  base text-to-image model from \citet{imagen}. This model was trained on large-scale web-image-text data, and is conditioned on T5-XXL text embeddings \citep{2020t5}. We use a weighting function of , but found that a uniform weighting performed similarly. We sample , avoiding very high and low noise levels due to numerical instabilities. For classifier-free guidance, we set , finding that higher guidance weights give improved sample quality. This is much larger than image sampling methods, and is likely required due to the mode-seeking nature of our objective which results in oversmoothing at small guidance weights (see Appendix Table.~\ref{fig:gwsweep}). Given the rendered image and sampled timestep , we sample noise  and compute the gradient of the NeRF parameters  according to Eqn.~\ref{eq:sdsgrad}.

\myparagraph{4. Optimization.}
Our 3D scenes are optimized on a TPUv4 machine with 4 chips. Each chip renders a separate view and evaluates the diffusion U-Net with per-device batch size of 1. We optimize for \num[group-separator={,}]{15000} iterations which takes around \num[group-separator={,}]{1.5} hours. Compute time is split evenly between rendering the NeRF and evaluating the diffusion model. Parameters are optimized using the Distributed Shampoo optimizer \citep{distributedshampoo}. See Appendix~\ref{sec:nerf_hparams} for optimization settings.










\setlength{\tabcolsep}{2pt}
\begin{figure}[t]
\begin{minipage}[c]{0.505\linewidth}
  \centering
  \captionof{table}{Evaluating the coherence of DreamFusion generations with their caption using different CLIP retrieval models. We compare to the ground-truth MS-COCO images in the object-centric subset of \citet{jain2021dreamfields} as well as \citet{clipmesh}. Evaluated with only 1 seed per prompt. Metrics shown in parentheses may be overfit, as the same CLIP model is used during training and eval.}
  \label{tab:main_results}
  \resizebox{\linewidth}{!}{
  \begin{tabular}{@{}lccccccc@{}}
    \toprule
    \multirow{3}{5mm}{Method} & \multicolumn{6}{c}{R-Precision } \\
    & \multicolumn{2}{c}{CLIP B/32} & \multicolumn{2}{c}{CLIP B/16} & \multicolumn{2}{c}{CLIP L/14} \\ 
    & Color & Geo & Color & Geo & Color & Geo\\ 
    \midrule
    GT Images & 77.1 & -- & 79.1 & -- & -- & --\\ \midrule
    Dream Fields & 68.3 &-- & 74.2 & -- & -- & --\\
    ~~(reimpl.) &{\bf 78.6} &\phantom{ }1.3  &(99.9) & (0.8) & {\bf 82.9}&\phantom{ }1.4\\
    CLIP-Mesh &67.8 & --&75.8& -- & 74.5 & --\\
    DreamFusion &75.1 & {\bf 42.5} &{\bf 77.5} & 46.6 & 79.7 &{\bf 58.5}\\
    \bottomrule
  \end{tabular}
  }
\end{minipage}\hfill
\begin{minipage}[c]{0.475\linewidth}
  \centering
  \includegraphics[width=\linewidth,trim={0 6.2cm 35.5cm 0},clip]{figs/comparison_small_compress}
  \caption{Qualitative comparison with baselines.}
  \label{fig:comparison}
\end{minipage}
\end{figure}

\section{Experiments}
\vspace{-1.8mm}
We evaluate the ability of \dreamfusion to generate coherent 3D scenes from a variety of text prompts. We compare to existing zero-shot text-to-3D generative models, identify the key components of our model that enable accurate 3D geometry,  and explore the qualitative capabilities of \dreamfusion such as the compositional generation shown in Figure~\ref{fig:journey}. We present a large gallery of 3D assets, extended videos, and meshes at \websiteLink. 

3D reconstruction tasks are typically evaluated using reference-based metrics like Chamfer Distance, which compares recovered geometry to some ground truth. The view-synthesis literature often uses PSNR to compare rendered views with a held-out photograph. These reference-based metrics are difficult to apply to zero-shot text-to-3D generation, as there is no ``true'' 3D scene corresponding to our text prompts. Following~\citet{jain2021dreamfields}, we evaluate the CLIP R-Precision, an automated metric for the consistency of rendered images with respect to the input caption. The R-Precision is the accuracy with which CLIP~\citep{clip} retrieves the correct caption among a set of distractors given a rendering of the scene. We use the 153 prompts from the object-centric COCO validation subset of Dream Fields. We also measure R-Precision on textureless renders to evaluate geometry since we found existing metrics do not capture the quality of the geometry, often yielding high values when texture is painted on flat geometry.


Table~\ref{tab:main_results} reports CLIP R-Precision for \dreamfusion{} and several baselines. These include Dream Fields, CLIP-Mesh (which optimizes a mesh with CLIP), and an oracle that evaluates the original captioned image pairs in MS-COCO.
We also compare against an enhanced reimplementation of Dream Fields where we use our own 3D representation (Sec.~\ref{sec:nerf}). Since this evaluation is based on CLIP, Dream Fields and CLIP-Mesh have an unfair advantage as they use CLIP during training. Despite this, \dreamfusion outperforms both baselines on color images, and approaches the performance of ground truth images. While our implementation of Dream Fields performs nearly at chance when evaluating geometry (Geo) with textureless renders, \dreamfusion is consistent with captions 58.5\% of the time. See Appendix~\ref{sec:extra_evaluation_setup} for more details of the experimental setup.

\myparagraph{Ablations.} Fig.~\ref{fig:ablation_bar} shows CLIP R-Precision for a simplified \dreamfusion ablation and progressively adds in optimization choices: a large ranges of viewpoints (ViewAug), view-dependent prompts (ViewDep), optimizing illuminated renders in addition to unlit albedo color renders (Lighting), and optimizing textureless shaded geometry images (Textureless). We measure R-Precision on the albedo render as in baselines (left), the full shaded render (middle) and the textureless render (right) to check geometric quality. Geometry significantly improves with each of these choices and full renderings improve by +12.5\%. Fig.~\ref{fig:ablation_qualitative} shows qualitative results for the ablation. This ablation also highlights how the albedo renders can be deceiving: our base model achieves the highest score, but exhibits poor geometry (the dog has multiple heads). Recovering accurate geometry requires view-dependent prompts, illumination and textureless renders.



\newcommand{\barwidth}{0.55\linewidth}
\newcommand{\bulldogwidth}{0.11\linewidth}
\newcommand{\qualablationcaption}[1]{{\footnotesize #1}}
\begin{figure}[t!]
    \begin{minipage}[c]{\barwidth}
        \centering
        \includegraphics[width=\linewidth]{figs/ablations.pdf}
    \end{minipage}\hfill
    \begin{minipage}[c]{\bulldogwidth}
        \centering
        \includegraphics[width=\linewidth]{figs/bulldog_1.png}
        \qualablationcaption{(i)}
    \end{minipage}\hfill
    \begin{minipage}[c]{\bulldogwidth}
        \centering
        \includegraphics[width=\linewidth]{figs/bulldog_2.png}
        \qualablationcaption{(ii)}
    \end{minipage}\hfill
    \begin{minipage}[c]{\bulldogwidth}
        \centering
        \includegraphics[width=\linewidth]{figs/bulldog_3.png}
        \qualablationcaption{(iii)}
    \end{minipage}\hfill
    \begin{minipage}[c]{\bulldogwidth}
        \centering
        \includegraphics[width=\linewidth]{figs/bulldog_4.png}
        \qualablationcaption{(iv)}
    \end{minipage}
    \caption{An ablation study of \dreamfusion. {\bf Left}: We evaluate components of our unlit renderings on albedo, full shaded and illuminated renderings and textureless illuminated geometry using CLIP L/14 on object-centric COCO. {\bf Right}: visualizations of the impact of each ablation for  \textit{\footnotesize ``A bulldog is wearing a black pirate hat.''} on albedo (top), shaded (middle), and textureless renderings (bottom). The base method (i) without view-dependent prompts results in a multi-faced dog with flat geometry. Adding in view-dependent prompts (ii) improves geometry, but the surfaces are highly non-smooth and result in poor shaded renders. Introducing lighting (iii) improves geometry but darker areas (e.g. the hat) remain non-smooth. Rendering without color (iv) helps to smooth the geometry, but also causes some color details like the skull and crossbones to be ``carved'' into the geometry.}
    \label{fig:ablation_bar}
    \label{fig:ablation_qualitative}
\end{figure}

\section{Discussion}
We have presented \dreamfusion{}, an effective technique for text-to-3D synthesis for a wide range of text prompts.
\dreamfusion{} works by transferring scalable, high-quality 2D image diffusion models to the 3D domain through our use of a novel \sname approach and a novel NeRF-like rendering engine. \dreamfusion{} does not require 3D or multi-view training data, and uses only a pre-trained 2D diffusion model (trained on only 2D images) to perform 3D synthesis.



Though \dreamfusion{} produces compelling results and outperforms prior work on this task, it still has several limitations.
\sacc is not a perfect loss function when applied to image sampling, and often produces oversaturated and oversmoothed results relative to ancestral sampling.
While dynamic thresholding~\citep{imagen} partially ameliorates this issue when applying \sacc to images, it did not resolve this issue in a NeRF context.
Additionally, 2D image samples produced using \sacc tend to lack diversity compared to ancestral sampling, and our 3D results exhibit few differences across random seeds.
This may be fundamental to our use of reverse KL divergence, which has been previously noted to have mode-seeking properties in the context of variational inference and probability density distillation.

\dreamfusion uses the  Imagen model, and as such our 3D synthesized models tend to lack fine details. Using a higher-resolution diffusion model and a bigger NeRF would presumably address this, but synthesis would become impractically slow. Hopefully improvements in the efficiency of diffusion and neural rendering will enable tractable 3D synthesis at high resolution in the future.

The problem of 3D reconstruction from 2D observations is widely understood to be highly ill-posed, and this ambiguity has consequences in the context of 3D synthesis. Fundamentally, our task is hard for the same reason that inverse rendering is hard: there exist many possible 3D worlds that result in identical 2D images.
The optimization landscape of our task is therefore highly non-convex, and many of the details of this work are designed specifically to sidestep these local minima. But despite our best efforts we still sometimes observe local minima, such as 3D reconstructions where all scene content is ``painted'' onto a single flat surface. Though the techniques presented in this work are effective, this task of ``lifting'' 2D observations into a 3D world is inherently ambiguous, and may benefit from more robust 3D priors.



\clearpage
\subsubsection*{Ethics Statement}


Generative models for synthesizing images carry with them several ethical concerns, and these concerns are shared by (or perhaps exacerbated in) 3D generative models such as ours.

Because \dreamfusion uses the Imagen diffusion model as a prior, it inherits any problematic biases and limitations that Imagen may have. While Imagen's dataset was partially filtered, the LAION-400M~\citep{laion5b} subset of its data was found to contain undesirable images~\citep{multimodaldatasets}. Imagen is also conditioned on features from a pretrained large language model, which itself may have unwanted biases. It is important to be careful about the contents of datasets that are used in text-to-image and image-to-3D models so as to not propagate hateful media.

Generative models, in the hands of bad actors, could be used to generate disinformation. Disinformation in the form of 3D objects may be more convincing than 2D images (though renderings of our synthesized 3D models are less realistic than the state of the art in 2D image synthesis).


Generative models such as ours may have the potential to displace creative workers via automation. That said, these tools may also enable growth and improve accessibility for the creative industry.

\subsubsection*{Reproducibility Statement}

The mip-NeRF 360 model that we build upon is publicly available through the ``MultiNeRF'' code repository~\citep{multinerf2022}. While the Imagen diffusion model is not publicly available, other conditional diffusion models may produce similar results with the \dreamfusion algorithm. To aid reproducibility, we have included a schematic overview of the algorithm in Figure~\ref{fig:diagram}, pseudocode for \sname in Figure~\ref{fig:score_sampling_code}, hyperparameters in Appendix~\ref{sec:nerf_hparams}, and additional evaluation setup details in Appendix~\ref{sec:extra_evaluation_setup}. Derivations for our loss are also included in Appendix~\ref{sec:appendix:vos_math}.


\subsubsection*{Acknowledgments}
Thank you to Mohammad Norouzi for thoughtful review of our manuscript, valuable discussions throughout this project, and help using the Imagen model. Thank you to William Chan and Chitwan Saharia for valuable discussions on Imagen and code pointers. Thank you to Kevin Murphy for ideas and feedback on our manuscript. We thank Ruiqi Gao and Durk Kingma for helpful discussions on diffusion models and the score distillation sampling loss. Thanks to Jonathan Ho, Daniel Watson, Alex Alemi, Dumitru Erhan, Abhishek Kumar, Han Zhang, David Ha, Luke Metz, Jascha Sohl-Dickstein, Ian Fischer, and Pieter Abbeel for thoughtful and valuable discussions over the course of this project.  Thank you to Sarah Laszlo for help evaluating 3D models, and Rohan Anil for Distributed Shampoo tips. Thank you to Peter Hedman, Dor Verbin, Lior Yariv, Pratul Srinivasan, Christian Reiser, Garrett Tanzer, Harsh Goyal, Will McLeod, Koppany Horvath, Rodrigo Chandia, Puneet Lall, Daniel Castro Chin, Liviu Panait, Alexey Sokolov, Irina Blok, Nick Fisher, and the many other creative Googlers and artists on Twitter for the inspiring text prompt suggestions. Thank you to the Google infrastructure teams for computational support, and all the authors of open-source software packages especially JAX and NumPy that enabled this work.


\bibliography{ref}
\bibliographystyle{iclr2023_conference}

\clearpage
\appendix
\section{Appendix}

\subsection{Pseudocode for ancestral sampling and our \sname.}

\begin{figure}[h]
\begin{lstlisting}[language=Python]
z_t = random.normal(img_shape)
for t in linspace(tmax, tmin, nstep):
  epshat_t = diffusion_model.epshat(z_t, y, t)  # Score function evaluation.
  if t > tmin:
    eps = random.normal(img_shape)
    z_t = ddpm_update(z_t, epshat_t, eps)  # 1 iteration, decreases noise level.
x = diffusion_model.xhat(z_t, epshat_t, t_min)  # Tweedie's formula: denoise the last step.
return x
\end{lstlisting}
\caption{Pseudocode for ancestral sampling from DDPM where \texttt{y} is the optional conditioning signal e.g.\ a caption. Typically,  and . Timestep \texttt{t} monotonically decreases.}
\label{fig:ancestral_sampling_code}
\end{figure}

\begin{figure}[h]
\begin{lstlisting}[language=Python]
params = generator.init()
opt_state = optimizer.init(params)
diffusion_model = diffusion.load_model()
for nstep in iterations:
  t = random.uniform(0., 1.)
  alpha_t, sigma_t = diffusion_model.get_coeffs(t)
  eps = random.normal(img_shape)
  x = generator(params, <other arguments>...)  # Get an image observation.
  z_t = alpha_t * x + sigma_t * eps  # Diffuse observation.
  epshat_t = diffusion_model.epshat(z_t, y, t)  # Score function evaluation.
  g = grad(weight(t) * dot(stopgradient[epshat_t - eps], x), params)
  params, opt_state = optimizer.update(g, opt_state)  # Update params with optimizer.
return params
\end{lstlisting}
\caption{Pseudocode for \sname with an application-specific generator that defines a differentiable mapping from parameters to images. The gradient \texttt{g} is computed without backpropagating through the diffusion model's U-Net. We used the \texttt{stopgradient} operator to express the loss, but the parameter update can also be easily computed with an explicit VJP: {\texttt{g = matmul(weight(t) * (-epshat\_t - eps), grad(x, params))}}.}
\label{fig:score_sampling_code}
\end{figure}







\subsection{NeRF Details and Training Hyperparameters}
\label{sec:nerf_hparams}

Our model builds upon mip-NeRF 360 \citep{Barron2021MipNeRF3U} (starting from the publicly available implementation~\citeyear{multinerf2022}), which is an improved version of NeRF \citep{mildenhall2020nerf}. The main modification this model makes to NeRF is in how 3D point information is passed to the NeRF MLP. In NeRF, each 3D input point is mapped to a higher dimensional space using a sinusoidal positional encoding function~\citep{vaswani2017attention}. In mip-NeRF, this is replaced by an \emph{integrated} positional encoding that accounts for the ``width'' of the ray being rendered (based on its pixel footprint in the image plane) and the length of each interval  sampled along the ray~~\citep{barron2021mip}. This allows each interval along a ray to be represented as a Gaussian distribution with mean  and covariance matrix  that approximates the interval's 3D volume.


\paragraph{Mip-NeRF covariance annealing.} As in mip-NeRF, each mean  is the 3D coordinate of the center of the ray interval, but unlike mip-NeRF we do not use a covariance derived from camera geometry, but instead define each  as:

Where  is a scale parameter that is linearly annealed from a large value to a small value during training. Representative settings are  and  for the initial and final values of , linearly annealed for the first 5k steps of optimization (out of 15k total).
This ``coarse to fine'' annealing of a scale parameter has a similar effect as the annealing used by \citet{park2021nerfies} but uses integrated positional encoding instead of traditional positional encoding. The underlying sinusoidal positional encoding function uses frequencies , where we set .


\paragraph{MLP architecture changes.} Our NeRF MLP consists of 5 ResNet blocks~\citep{he2016deep} with 128 hidden units, Swish/SiLU activation~\citep{hendrycks2016gaussian}, and layer normalization~\citep{ba2016layer} between blocks. We use an  activation to produce density  and a sigmoid activation to produce RGB albedo .

\paragraph{Shading hyperparameters.} For the first 1k steps of optimization we set the ambient light color  to  and the diffuse light color  to , which effectively disables diffuse shading. For the remaining steps we set  and  with probability , otherwise , , \textit{i.e.} we use diffuse shading 75\% of the time. When shading is on (), we choose textureless shading () with probability .


\paragraph{Spatial density bias.} To aid in the early stages of optimization, we add a small ``blob'' of density around the origin to the output of the MLP. This helps focus scene content at the center of the 3D coordinate space, rather than directly next to the sampled cameras. We use a Gaussian PDF to parameterize the added density:

Representative settings are  for the scale parameter and  for the width parameter. This density is added to the  output of the NeRF MLP.



\paragraph{Additional camera and light sampling details.}
Uniformly sampling camera elevation  in angular space does not produce uniform samples over the surface of the sphere --- the area around the pole is oversampled. We  found this bias to be helpful in practice, so we sample  from this biased distribution with probability 0.5, otherwise we sample from a true uniform-in-area distribution on a half-sphere.
The sampled camera position is perturbed by a small uniform offset . The ``look-at'' point is sampled from  and the default ``up'' vector is perturbed by noise sampled from . This noise acts as an additional augmentation, and ensures a wider diversity of viewpoints are seen during training.

We separately sample the direction and norm of the light position vector . To sample the direction, we sample from  where  is the camera position (this ensures that the point light usually ends up on the same side of the object as the camera). The norm  is sampled from , while  .

\paragraph{Regularizer hyperparameters.} 
We use the orientation loss proposed by Ref-NeRF~\citep{verbin2022refnerf} to encourage normal vectors of the density field to face toward the camera when they are visible (so that the camera does not observe geometry that appears to face ``backwards'' when shaded). We place a stop-gradient on the rendering weights , which helps prevent unintended local minima where the generated object shrinks or disappears:

where  is the direction of the ray (the viewing direction).
We also apply a small regularization to the accumulated alpha value (opacity) along each ray: . This discourages optimization from unnecessarily filling in empty space, and improves foreground/background separation.


For orientation loss , we find reasonable weights to lie in . If orientation loss is too high, surfaces become oversmoothed. In most experiments, we set the weight to . This weight is annealed in starting from  over the first 5k (out of 15k) steps.
For accumulated alpha loss  , we find reasonable weights to lie in .

\paragraph{View-dependent prompting.} We interpolate between front/side/back view prompt augmentations based on which quadrant contains the sampled azimuth . We experimented with different ways of interpolating the text embeddings, but found that simply taking the text embedding closest to the sampled azimuth worked well. 

\paragraph{Optimizer.}
We use Distributed Shampoo \citep{distributedshampoo}
 with , , , , , , and a linear warmup of learning rate over 3000 steps from  to  followed by cosine decay down to . We found this long warmup period to be helpful for improving the coherence of generated geometry.

\subsection{Experimental setup}
\label{sec:extra_evaluation_setup}

Our computation of R-Precision differs slightly from baselines. As mentioned, CLIP-based text-to-3D systems are prone to overfitting the evaluation CLIP R-Precision metric since the model used for training is similar to the evaluation model. To minimize this problem, Dream Fields~\citep{jain2021dreamfields} and CLIP-Mesh~\citep{clipmesh} evaluate renderings at a single held out view at a 45 elevation, higher than is seen during training (maximum 30). \dreamfusion evaluates at 30 since it is not prone to this issue, but averages the metric over multiple azimuths to reduce variance. In our main results in Table~\ref{tab:main_results}, we evaluate all captions with 2 generation seeds unless otherwise noted.









\subsection{Deriving the score distillation sampling loss and gradients}
\label{sec:appendix:vos_math}
The score distillation sampling loss  presented in Eqn.~\ref{eq:sds} was inspired by work on probability density distillation~\citep{Huang2019ProbabilityDA, Ping2019ClariNetPW, Oord2018ParallelWF}. We use this loss to find modes of the score functions that are present across all noise levels in the diffusion process. Here we show how the gradient of this loss leads to the same update as optimizing the training loss , but without the term corresponding to the Jacobian of the diffusion U-Net. First, we consider gradients with respect to a single KL term:

The second term (B) can be related to  by the chain rule, relying on :

The first term (A) is the gradient of the entropy of the forward process with respect to the mean parameter, holding the variance fixed. Because of the fixed variance, the entropy is constant for a given  and the total gradient of (A) is 0. However, we can still write out its gradient in terms of the ``score function'' (the gradient of the log probability with respect to parameters) and path derivative (the gradient of the log probability with respect to the sample):

Sticking-the-Landing~\citep{stickingthelanding} shows that keeping the path derivative gradient while discarding the score function gradient can lead to reduced variance as the path derivative term can be correlated with other terms in the loss. Here, the other term (B) corresponds to a prediction of , which is certainly correlated with the RHS of \eqref{eq:sticking}. Putting these together, we can use a ``sticking-the-landing''-style gradient of our loss by thinking of  as a control variate for :

In practice, we find that including  in the gradient leads to lower-variance gradients that speed up optimization and can produce better final results.








In related work, \citet{ddpmpnp} also sample diffusion models by optimization, thereby allowing parameterized samples. Their divergence  reduces to the loss . The squared error requires costly backpropagation through the diffusion model , unlike \sacc. DDPM-PnP also uses an auxiliary classifier , while we use CFG.

A few other works have updates resembling \sname for different applications. Gradients of the entropy of an implicit model have been estimated with an amortized score model at a single noise level~\citep{DBLP:journals/corr/abs-2006-05164}, though that work does not use our control variate based on subtracting the noise from . SDS could also ease optimization by using multiple noise levels. GAN-like amortized samplers can be learned by minimizing the Stein discrepancy~\citep{steinns, pmlr-v119-grathwohl20a}, where the optimal critic resembles the difference of scores in our loss~(Eqn.~\ref{eq:sdsgrad}).


\subsection{Impact of Seed and Guidance Weight}
We find that large guidance weights are important for learning high-quality 3D models. Unlike image synthesis models that use guidance weights , \dreamfusion uses weights up , and works at even larger guidance scales without severe artifacts. This may be due to the constrained nature of the optimization problem: colors output by our MLP are bounded to  by a sigmoid nonlinearity, whereas image samplers need clipping.

We also find that our method does not yield large amounts of diversity across random seeds. This is likely due to the mode-seeking properties of  combined with the fact that at high noise levels, the smoothed densities may not have many distinct modes. Understanding the interplay between guidance strength, diversity, and loss functions remains an important open direction for future research.
\begin{table}[h!]
     \begin{center}
     \begin{tabular}{rccccc}
     & \multicolumn{5}{c}{Guidance weight} \\
     & 25 & 50 & 75 & 100 & 250 \\
     \rotatebox{90}{\quad\quad Seed } &
\includegraphics[width=.18\textwidth]{figs/gw_sweep/gw_0_0.jpg} &
\includegraphics[width=.18\textwidth]{figs/gw_sweep/gw_0_1.jpg} &
\includegraphics[width=.18\textwidth]{figs/gw_sweep/gw_0_2.jpg} &
\includegraphics[width=.18\textwidth]{figs/gw_sweep/gw_0_3.jpg} &
\includegraphics[width=.18\textwidth]{figs/gw_sweep/gw_0_4.jpg} \\
     \rotatebox{90}{\quad\quad Seed } &
\includegraphics[width=.18\textwidth]{figs/gw_sweep/gw_1_0.jpg} &
\includegraphics[width=.18\textwidth]{figs/gw_sweep/gw_1_1.jpg} &
\includegraphics[width=.18\textwidth]{figs/gw_sweep/gw_1_2.jpg} &
\includegraphics[width=.18\textwidth]{figs/gw_sweep/gw_1_3.jpg} &
\includegraphics[width=.18\textwidth]{figs/gw_sweep/gw_1_4.jpg} \\
     \rotatebox{90}{\quad\quad Seed } &
\includegraphics[width=.18\textwidth]{figs/gw_sweep/gw_2_0.jpg} &
\includegraphics[width=.18\textwidth]{figs/gw_sweep/gw_2_1.jpg} &
\includegraphics[width=.18\textwidth]{figs/gw_sweep/gw_2_2.jpg} &
\includegraphics[width=.18\textwidth]{figs/gw_sweep/gw_2_3.jpg} &
\includegraphics[width=.18\textwidth]{figs/gw_sweep/gw_2_4.jpg} \\
     \rotatebox{90}{\quad\quad Seed } &
\includegraphics[width=.18\textwidth]{figs/gw_sweep/gw_3_0.jpg} &
\includegraphics[width=.18\textwidth]{figs/gw_sweep/gw_3_1.jpg} &
\includegraphics[width=.18\textwidth]{figs/gw_sweep/gw_3_2.jpg} &
\includegraphics[width=.18\textwidth]{figs/gw_sweep/gw_3_3.jpg} &
\includegraphics[width=.18\textwidth]{figs/gw_sweep/gw_3_4.jpg}
      \end{tabular}
      \captionof{figure}{A 2D sweep over guidance weights and random seeds for two different prompts (``{\em a zoomed out DSLR photo of a robot couple fine dining}'' and ``{\em a DSLR photo of a chimpanzee dressed like Henry VIII king of England}'').}
      \label{fig:gwsweep}
      \end{center}
      \end{table} 
\end{document}
