\def\final{1}
\def\icalp{0}

\documentclass[11pt]{article}

\usepackage{algorithm, algorithmic}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{fullpage}
\usepackage{verbatim}
\usepackage{color}
\usepackage{hyperref}

\ifnum\final=0
\newcommand{\mynote}[1]{\marginpar{\tiny\sf #1}}
\else
\newcommand{\mynote}[1]{}
\fi
\newcommand{\Jnote}[1]{\mynote{Jon: {#1}}}
\newcommand{\Snote}[1]{\mynote{Salil: {#1}}}
\newcommand{\Justinnote}[1]{\mynote{Justin: {#1}}}

\newcommand\Z{\mathbb{Z}}
\newcommand\N{\mathbb{N}}
\newcommand\R{\mathbb{R}}
\newcommand\cA{\mathcal{A}}
\newcommand\cE{\mathcal{E}}
\newcommand\cF{\mathcal{F}}
\newcommand\cP{\mathcal{P}}
\newcommand\cQ{\mathcal{Q}}
\newcommand\cR{\mathcal{R}}
\newcommand\cX{\mathcal{X}}

\newcommand\san{\mathcal{A}}

\newcommand\poly{\mathrm{poly}}
\newcommand\bits{\{0,1\}}
\newcommand\zo{\bits}
\newcommand{\getsr}{\gets_{\mbox{\tiny R}}}
\newcommand\sanrd[1]{\left| #1 \right|} \newcommand\set[1]{\left\{#1\right\}} \newcommand\eps{\varepsilon}
\newcommand\from{\colon}
\newcommand\Lap{\mathrm{Lap}}

\newcommand{\Prob}[2]{\Pr_{#1}\left[ #2 \right]}
\newcommand{\prob}[1]{\Pr\left[#1\right]}
\newcommand{\Ex}[2]{\mathbb{E}_{#1}\left[#2\right]}
\newcommand{\ex}[1]{\mathbb{E}\left[#1\right]}
\newcommand{\edit}[1]{{\color{red}{#1}}}

\newcommand{\INDSTATE}[1][1]{\STATE\hspace{#1\algorithmicindent}}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{corollary}[theorem]{Corollary}



\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}

\title{Faster Algorithms for Privately \\ Releasing Marginals\thanks{An extended abstract of this work appears in \emph{ICALP '12}~\cite{ThalerUlVa12}.} \ifnum\final=0 \\
{\small \sc Working Draft: Please Do Not Distribute}\fi}
\author{Justin Thaler\thanks{\url{http://seas.harvard.edu/\~jthaler}. Supported by the Department of Defense (DoD) through the National
Defense Science \& Engineering Graduate Fellowship (NDSEG) Program,
and in part by NSF grants CCF-0915922 and IIS-0964473.}
 \and Jonathan Ullman\thanks{
\url{http://seas.harvard.edu/\~jullman}.  Supported by NSF grant CNS-0831289 and a gift from Google, Inc.}
 \and Salil Vadhan\thanks{
\url{http://seas.harvard.edu/\~salil}.  Supported by NSF grant CNS-0831289 and a gift from Google, Inc.}
\\ \\ School of Engineering and Applied Sciences \&\\ Center for Research on Computation and Society\\ Harvard University, Cambridge, MA \\ \texttt{\{jthaler,jullman,salil\}@seas.harvard.edu}}
\begin{document}

\maketitle
\begin{abstract}
We study the problem of releasing \emph{-way marginals} of a database , while preserving differential privacy.  The answer to a -way marginal query is the fraction of 's records  with a given value in each of a given set of up to  columns.  Marginal queries enable a rich class of statistical analyses of a dataset, and designing efficient algorithms for privately releasing marginal queries has been identified as an important open problem in private data analysis (cf.~Barak et.~al., PODS '07).

We give an algorithm that runs in time  and releases a private summary capable of answering any -way marginal query with at most  error on every query as long as .  To our knowledge, ours is the first algorithm capable of privately releasing marginal queries with non-trivial worst-case accuracy guarantees in time substantially smaller than the number of -way marginal queries, which is  (for ).
\end{abstract}

\section{Introduction}
Consider a database  in which each of the  rows corresponds to an individual's record, and each record consists of  binary attributes.  The goal of privacy-preserving data analysis is to enable rich statistical analyses on the database while protecting the privacy of the individuals.  In this work, we seek to achieve \emph{differential privacy}~\cite{DworkMcNiSm06}, which guarantees that no individual's data has a significant influence on the information released about the database.

One of the most important classes of statistics on a dataset is its \emph{marginals}.  A marginal query is specified by a set  and a pattern . The query asks, ``What fraction of the individual records in  has each of the attributes  set to ?''  A major open problem in privacy-preserving data analysis is to \emph{efficiently} create a differentially private summary of the database that enables analysts to answer each of the  marginal queries.  A natural subclass of marginals are \emph{-way marginals}, the subset of marginals specified by sets  such that .

Privately answering marginal queries is a special case of the more general problem of privately answering \emph{counting queries} on the database, which are queries of the form, ``What fraction of individual records in  satisfy some property ?''  Early work in differential privacy~\cite{DinurNi03,BlumDwMcNi05,DworkMcNiSm06} showed how to approximately answer any set of of counting queries  by perturbing the answers with appropriately calibrated noise, providing good accuracy (say, within  of the true answer) as long as .

In a setting where the queries arrive online, or are known in advance, it may be reasonable to assume that .  However, many situations necessitate a non-interactive data release, where the data owner computes and publishes a single differentially private summary of the database that enables analysts to answer a large class of queries, say all -way marginals for a suitable choice of .  In this case , and it may be impractical to collect enough data to ensure .  Fortunately, the remarkable work of Blum et.~al.~\cite{BlumLiRo08} and subsequent refinements~\cite{DworkNaReRoVa09,DworkRoVa10,RothRo10,HardtRo10,HardtLiMc10,GuptaRoUl12}, have shown how to privately release approximate answers to any set of counting queries, even when  is \emph{exponentially larger} than .  For example, these algorithms can release all -way marginals as long as .  Unfortunately, all of these algorithms have running time at least , even when  is the set of -way marginals (and this is inherent for algorithms that produce ``synthetic data''~\cite{UllmanVa11}; as discussed below).

Given this state of affairs, it is natural to seek \emph{efficient} algorithms capable of privately releasing approximate answers to marginal queries even when .  A recent series of works~\cite{GuptaHaRoUl11,CheraghchiKlKoLe12,HardtRoSe12} have shown how to privately release answers to -way marginal queries with small \emph{average error} (over various distributions on the queries) with both running time and minimum database size much smaller than  (e.g.~ for product distributions~\cite{GuptaHaRoUl11,CheraghchiKlKoLe12} and  for arbitrary distributions~\cite{HardtRoSe12}).  Hardt et.~al.~\cite{HardtRoSe12} also gave an algorithm for privately releasing -way marginal queries with small \emph{worst-case error} and minimum database size much smaller than . However the running time of their algorithm is still , which is polynomial in the number of queries.

In this paper, we give the first algorithms capable of releasing -way marginals up to small worst-case error, with both running time and minimum database size substantially smaller than .  Specifically, we show how to create a private summary in time  that gives approximate answers to all -way marginals as long as  is at least .  When , our algorithm runs in time , and is the first algorithm for releasing \emph{all} marginals in time .

\subsection{Our Results and Techniques}

In this paper, we give faster algorithms for releasing marginals and other classes of counting queries.

\begin{theorem}[Releasing Marginals] \label{thm:main1}
There exists a constant  such that for every  with , every , and every , there is an -differentially private sanitizer that, on input a database , runs in time  and releases a summary that enables computing each of the -way marginal queries on  up to an additive error of at most , provided that .\end{theorem}

For notational convenience, we focus on \emph{monotone -way disjunction queries}. However, our results extend straightforwardly to general non-monotone -way disjunction queries (see Section~\ref{sec:monotonedisj}), which are equivalent to -way marginals.  A monotone -way disjunction is specified by a set  of size  and asks what fraction of records in  have at least one of the attributes in  set to .  

Our algorithm is inspired by a series of works reducing the problem of private query release to various problems in learning theory.  
One ingredient in this line of work is a shift in perspective introduced by Gupta, Hardt, Roth, and Ullman~\cite{GuptaHaRoUl11}. 
Instead of viewing disjunction queries as a set of functions on the database, they view the database as a function , in which each vector  is interpreted as the indicator vector of a set , and  equals the evaluation of the disjunction specified by  on the database .  They use the structure of the functions  to privately learn an approximation  that has small \emph{average error} over any product distribution on disjunctions.\footnote{In their learning algorithm, privacy is defined with respect to the rows of the database  that defines , not with respect to the examples given to the learning algorithm (unlike earlier works on ``private learning''~\cite{KasiviswanathanLeNiRaSm07}). }

Cheraghchi, Klivans, Kothari, and Lee~\cite{CheraghchiKlKoLe12} observed that the functions  can be approximated by a low-degree polynomial with small average error over the uniform distribution on disjunctions. They then use a private learning algorithm for low-degree polynomials to release an approximation to ; and thereby obtain an improved dependence on the accuracy parameter, as compared to~\cite{GuptaHaRoUl11}.  

Hardt, Rothblum, and Servedio~\cite{HardtRoSe12} observe that  is itself an average of disjunctions (each row of  specifies a disjunction of bits in the indicator vector  of the query), and thus develop private learning algorithms for threshold of sums of disjunctions.  These learning algorithms are also based on low-degree approximations of sums of disjunctions.
They show how to use their private learning algorithms to obtain a sanitizer with small average error over \emph{arbitrary distributions} with running time and minimum database size .  They then are able to apply the private boosting technique of Dwork, Rothblum, and Vadhan~\cite{DworkRoVa10} to obtain worst-case accuracy guarantees.  Unfortunately, the boosting step incurs a blowup of  in the running time.

We improve the above results by showing how to \emph{directly} compute (a noisy version of) a polynomial  that is privacy-preserving and still approximates  on \emph{all} -way disjunctions, as long as  is sufficiently large. Specifically, the running time and the database size requirement of our algorithm are both polynomial in the number of monomials in , which is .  By ``directly'', we mean that we compute  from the database  itself and perturb its coefficients, rather than using a learning algorithm. Our construction of the polynomial  uses the same low-degree approximations exploited by Hardt et.~al.~in the development
of their private learning algorithms. 





In summary, the main difference between prior work and ours is that prior work used learning algorithms that have restricted access to the database, and released the hypothesis
output by the learning algorithm. In contrast, we do not make use of any learning algorithms, and give our release algorithm direct access to the database. This enables our algorithm to achieve a worst-case error guarantee while maintaining a minimal database size and running time much smaller than the size of the query set.  Our algorithm is also substantially simpler than that of Hardt et.~al.



We also consider other families of counting queries.  We define the class of \emph{-of- queries}.  Like a monotone -way disjunction, an -of- query is defined by a set  such that .  The query asks what fraction of the rows of  have at least  of the attributes in  set to .  For , these queries are exactly monotone -way disjunctions, and -of- queries are a strict generalization.

\begin{theorem}[Releasing -of- Queries] \label{thm:main2}
For every  with , every , and every  there is an -differentially private sanitizer that, on input a database , runs in time  and releases a summary that enables computing each of the -of- queries on  up to an additive error of at most , provided that .
\end{theorem}
Note that monotone -way disjunctions are just -of- queries where , thus Theorem \ref{thm:main2} 
implies a release algorithm for disjunctions with
quadratically better dependence on , at the cost of slightly worse dependence on  (implicit in the switch from  to ).

Finally, we present a sanitizer for privately releasing databases in which
the \emph{rows} of the database are interpreted as decision lists, and the \emph{queries} are inputs to the
decision lists. That is, instead of each record in  being a string of  attributes, each record is an element of the set , which consists of all length- decision lists over  input variables. (See Section~\ref{sec:dls} for a precise definition.) A query is specified by a string  and asks ``What fraction of database participants would make a certain decision based on the input ?''

As an example application, consider a database that allows high school students to
express their preferences for colleges in the form of a decision list.
For example, a student may say, ``If the school is ranked in the top
ten nationwide, I am willing to apply to it. Otherwise, if the school is 
rural, I am unwilling to apply. Otherwise, if the school has a good
basketball team then I am willing to apply to it.'' And so on. Each student is allowed to use up to  attributes out of a set of  binary attributes.  Our sanitizer allows any college (represented by its  binary attributes) to determine the fraction of students willing to apply. 

\begin{theorem}[Releasing Decision Lists] \label{thm:main3}
For any  s.t.~, any , and any , there is an -differentially private sanitizer with running time  that, on input a database , releases a summary that enables computing any length- decision list query up to an additive error of at most  on every query, provided that .
\end{theorem}

For comparison, we note that all the results on releasing -way disjunctions (including ours) also apply to a dual setting where the database \emph{records} specify a -way disjunction over  bits and the \emph{queries} are -bit strings (in this setting  plays the role of ).  Theorem~\ref{thm:main3} generalizes this dual version of Theorem~\ref{thm:main1}, as length- decision lists are a strict generalization of -way disjunctions.

We prove the latter two results (Theorems~\ref{thm:main2} and~\ref{thm:main3}) using the same approach outlined for marginals (Theorem~\ref{thm:main1}), but with different low-degree polynomial approximations appropriate for the different types of queries.
\begin{table}
\begin{minipage}[center]{\textwidth}
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
Paper & Running Time  & Database Size & Error Type\footnote{\emph{Worst case} error indicates that the accuracy guarantee holds for every marginal.  The other types of error indicate that accuracy holds for random marginals over a given distribution from a particular class of distributions (e.g.~product distributions).} & Synthetic Data? \\
\hline
\cite{DinurNi03,DworkNi04,BlumDwMcNi05,DworkMcNiSm06} & &  & Worst case & N \\
\cite{BarakChDwKaMcTa07}  &  &  & Worst case & Y \\
\cite{BlumLiRo08,DworkNaReRoVa09,DworkRoVa10,HardtLiMc10}&  &  & Worst case & Y \\
\cite{GuptaHaRoUl11} &  &  & Product Dists. & N\\
\cite{CheraghchiKlKoLe12} &  &  & Uniform Dist.\footnote{The results of~\cite{CheraghchiKlKoLe12} apply only to the uniform distribution over \emph{all} marginals.} & N \\
\cite{HardtRoSe12} &  &  &Any Dist. & N \\
\cite{HardtRoSe12} &  &  & Worst case & N \\
\cite{HardtRoSe12} &  &  & Any Dist. & N \\
\cite{HardtRoSe12} &  &  & Worst case & N  \\
This paper &  & & Worst case & N \\
\hline
\end{tabular}
\caption{Summary of prior results on differentially private release of -way marginals.  The database size column indicates the minimum database size required to release answers to -way marginals up to an additive error of .  For clarity, we ignore the dependence on the privacy parameters and the failure probability of the algorithms.  Notice that this paper contains the first algorithm capable of releasing -way marginals with running time and worst-case error substantially smaller than the number of queries.}
\end{center}
\end{minipage}
\end{table}
\paragraph{On Synthetic Data.} An attractive type of summary is a \emph{synthetic database}.  A synthetic database is a new database  whose rows are ``fake'', but such that  approximately preserves many of the statistical properties of the database  (e.g.~all the marginals).  Some of the previous work on counting query release has provided synthetic data, starting with Barak et.~al.~\cite{BarakChDwKaMcTa07} and including~\cite{BlumLiRo08,DworkNaReRoVa09,DworkRoVa10,HardtLiMc10}.

Unfortunately, Ullman and Vadhan~\cite{UllmanVa11} (building on~\cite{DworkNaReRoVa09}) have shown that no differentially private sanitizer with running time  can take a database  and output a private synthetic database , all of whose -way marginals are approximately equal to those of  (assuming the existence of one-way functions).  They also showed that there is a constant  such that no differentially private sanitizer with running time  can output a private synthetic database, all of whose -way marginals are approximately equal to those of  (under stronger cryptographic assumptions).

When , our sanitizer runs in time  and releases a private summary that enables an analyst to approximately answer any marginal query on .  Prior to our work it was not known how to release \emph{any} summary enabling approximate answers to all marginals in time .  Thus, our results show that releasing a private summary for all marginal queries can be done considerably more efficiently if we do not require the summary to be a synthetic database (under the hardness assumptions made in~\cite{UllmanVa11}).
\section{Preliminaries}

\subsection{Differentially Private Sanitizers}\label{sec:sans}

Let a \emph{database}  be a collection of  rows  from a \emph{data universe} .  We say that two databases  are \emph{adjacent} if they differ only on a single row, and we denote this by .

A \emph{sanitizer}  takes a database as input and outputs some data structure in .  We are interested in sanitizers that satisfy \emph{differential privacy}.
\begin{definition}[Differential Privacy~\cite{DworkMcNiSm06}]\label{def:dp} A sanitizer  is \emph{-differentially private} if for every two adjacent databases  and every subset ,

In the case where  we say that  is \emph{-differentially private}.
\end{definition}

Since a sanitizer that always outputs  satisfies Definition~\ref{def:dp}, we also need to define what it means for a sanitizer to be accurate.  In particular, we are interested in sanitizers that give accurate answers to \emph{counting queries}.  A counting query is defined by a boolean predicate .  We define the evaluation of the query  on a database  to be

We use  to denote a set of counting queries.

Since  may output an arbitrary data structure, we must specify how to answer queries in  from the output .  Hence, we require that there is an \emph{evaluator}  that estimates  from the output of .  For example, if  outputs a vector of ``noisy answers'' , where  is a random variable for each , then  and  is the -th component of .  Abusing notation, we write  and  as shorthand for  and , respectively.  Since we are interested in the efficiency of the sanitization process as a whole, when we refer to the running time of , we also include the running time of the evaluator .  We say that  is ``accurate'' for the query set  if the values  are close to the answers .  Formally,
\begin{definition}[Accuracy]\label{def:acc}
An output  of a sanitizer  is \emph{-accurate} for the query set  if

for every .  A sanitizer is \emph{-accurate} for the query set  if for every database ,

where the probability is taken over the coins of .
\end{definition}

We will make use of the \emph{Laplace mechanism}.  Let  denote a draw from the random variable over  in which each coordinate is chosen independently according to the density function .  Let  be a database and  be a function such that for every pair of adjacent databases ,   Then we have the following two theorems:
\begin{lemma}[Laplace Mechanism, -Differential Privacy~\cite{DworkMcNiSm06}] \label{thm:laplacemech}
For  as above, the mechanism  satisfies -differential privacy.  Furthermore, for any ,

for

\end{lemma}
The choice of the  norm in the accuracy guarantee of the lemma is for convenience, and doesn't matter for the parameters of Theorems~\ref{thm:main1}-\ref{thm:main3} (except for the hidden constants).

\ifnum\icalp=0
If the privacy requirement is relaxed to -differential privacy (for , then it is sufficient to perturb each coordinate of  with noise from a Laplace distribution of smaller magnitude, leading to smaller error. 
\begin{lemma}[Laplace Mechanism, -Differential Privacy~\cite{DinurNi03,DworkNi04,BlumDwMcNi05,DworkRoVa10}] \label{thm:advcomp}
For  as above, and for every , the mechanism  satisfies -differential privacy.
Furthermore, for any ,

for

\end{lemma}
\else

\fi

\subsection{Query Function Families} \label{sec:countingqueries}

We take the approach of Gupta et.~al.~\cite{GuptaHaRoUl11} and think of the database  as specifying a function  mapping queries  to their answers , which we call the \emph{-representation of }. We now describe this transformation more formally:

\begin{definition}[-Function Family] \label{def:Qfunction}
Let  be a set of counting queries on a data universe , where each query is indexed by an -bit string.  We define the \emph{index set of } to be the set . 

We define the \emph{-function family}  as follows:
For every possible database row , the function  is defined as .  
Given a database  we define the function  where .  When  is clear from context we will drop the subscript  and simply write , , and .
\end{definition}

For some intuition about this transformation, when the queries are monotone -way disjunctions on a database , the queries are defined by sets  , .  In this case each query can be represented by the -bit indicator vector of the set , with at most  non-zero entries.  Thus we can take  and .
\subsection{Polynomial Approximations} \label{sec:polys}

\Jnote{I changed the definition of norm to be , it seemed more natural, and more importantly makes it easier to state an  version}
An -variate real polynomial  of \emph{degree } and \emph{() norm } can be written as

where

for every .
Recall that there are at most  coefficients in an -variate polynomial of total degree . 
Often we will want to associate a polynomial  of degree  and norm  with its coefficient vector .  Specifically,

Given a vector  and a point  we use  to indicate the evaluation of the polynomial described by the vector  at the point .  Observe this is equivalent to computing  where  is defined as  for every , .

Let  be the family of all -variate real polynomials of degree  and norm .  In many cases, the functions  can be approximated well on all the indices in  by a family of polynomials  with low degree and small norm.  Formally:
\begin{definition}[Uniform Approximation by Polynomials] \label{def:approxbypolys}
Given a family of -variate functions  and a set , we say that the family  \emph{uniformly -approximates  on } if for every , there exists  such that .

We say that  \emph{efficiently and uniformly -approximates } if there is an algorithm  that takes  as input, runs in time , and outputs a coefficient vector  such that .
\end{definition}
\section{From Polynomial Approximations to Data Release Algorithms} \label{sec:release}
In this section we present an algorithm for privately releasing any family of counting queries  such that  that can be efficiently and uniformly approximated by polynomials.  The algorithm will take an -row database  and, for each row , constructs a polynomial  that uniformly approximates the function  (recall that , for each ).  From these, it constructs a polynomial  that uniformly approximates .  The final step is to perturb each of the coefficients of  using noise from a Laplace distribution (Theorem~\ref{thm:laplacemech}) and bound the error introduced from the perturbation.

\begin{theorem}[Releasing Polynomials] \label{thm:releasepolys}
Let  be a set of counting queries over , and  be the  function family (Definition~\ref{def:Qfunction}).  Assume that  efficiently and uniformly -approximates  on  (Definition~\ref{def:approxbypolys}).  Then there is a sanitizer  that
\begin{enumerate}
\item is -differentially private,
\item runs in time , and
\item is -accurate for  for

\end{enumerate}
\end{theorem}

\begin{proof}
First we construct the sanitizer . See the relevant codebox below.

\begin{algorithm}
The Sanitizer 
\begin{algorithmic}
\STATE{\textbf{Input}: A database , an explicit family of polynomials , and a parameter .}
\STATE{\textbf{For} }
\INDSTATE[1]{Using efficient approximation of  by , compute a polynomial  that -approximates  on .}
\STATE{\textbf{Let} , where the sum denotes standard entry-wise vector addition.}
\STATE{\textbf{Let} , where  is drawn from an -variate Laplace distribution with parameter  (Section~\ref{sec:sans}).}
\STATE{\textbf{Output}: .}
\end{algorithmic}
\label{codebox1}
\end{algorithm}
\paragraph{Privacy.}
We establish that  is -differentially private.  This follows from the observation that for any two adjacent  that differ only on row ,

The last inequality is from the fact that for every ,  is a vector of  norm at most .  Part~1 of the Theorem now follows directly from the properties of the Laplace Mechanism (Theorem~\ref{thm:laplacemech}).
Now we construct the evaluator .
\begin{algorithm}
The Evaluator  for the Sanitizer 
\begin{algorithmic}
\STATE{\textbf{Input}: A vector  and the description of a query .}
\STATE{\textbf{Output}: .  Recall that we view  as an -variate polynomial, , and  is the evaluation of  on the point .}
\end{algorithmic}
\end{algorithm}

\paragraph{Efficiency.}
Next, we show that  runs in time .  Recall that we assumed the polynomial construction algorithm  runs in time .  The algorithm  needs to run  on each of the  rows, and then it needs to generate  samples from a univariate Laplace distribution with magnitude , which can also be done in time .  We also establish that  runs in time , observe that  needs to expand the input into an appropriate vector of dimension  and take the inner product with the vector , whose entries have magnitude .  These observations establish Part 2 of the Theorem.

\medskip

\noindent
\textit{Accuracy.}
Finally, we analyze the accuracy of the sanitizer .  First, by the assumption that  uniformly -approximates  on , we have
\ifnum\icalp=0

\else

\fi
Now we want to establish that 

for  where the probability is taken over the coins of .  Part (3) of the Theorem will then follow by the triangle inequality.

To see that the above statement is true, observe that by the properties of the Laplace mechanism (Theorem~\ref{thm:laplacemech}), we have

where the probability is taken over the coins of . Given that , it holds that for every ,

The first inequality follows from the fact that every monomial evaluates to  or  at the point .  This completes the proof of the theorem.

\end{proof}

Using Theorem~\ref{thm:advcomp}, we can improve the bound on the error at the expense of relaxing the privacy guarantee to -differential privacy.  This improved error only affects the hidden constants in Theorems~\ref{thm:main1}-\ref{thm:main3}, so we only state those theorems for -differential privacy.
\begin{theorem}[Releasing Polynomials, -Differential Privacy] \label{thm:advreleasepolys}
Let  be a set of counting queries over , and  be the  function family (Definition~\ref{def:Qfunction}).  Assume that  efficiently and uniformly -approximates  on  (Definition~\ref{def:approxbypolys}).  Then there is a sanitizer  that
\begin{enumerate}
\item is -differentially private,
\item runs in time ,
\item is -accurate for  for

\end{enumerate}
\end{theorem}
The proof of this theorem is identical to that of Theorem~\ref{thm:releasepolys}, but using the analysis of the Laplace mechanism from Theorem~\ref{thm:advcomp} in place of that of Theorem~\ref{thm:laplacemech}.
\section{Applications} \label{sec:apps}
In this section we establish the existence of explicit families of low-degree polynomials approximating the families  for some interesting query sets.
\subsection{Releasing Monotone Disjunctions} \label{sec:monotonedisj}

We define the class of monotone -way disjunctions as follows:

\begin{definition}[Monotone -Way Disjunctions] \label{def:monotonedisj}Let .
The query set  of \emph{monotone -way disjunctions over } contains a query  for every .  Each query is defined as .
The  function family  contains a function

for every .
\end{definition}

\ifnum\icalp=0
Thus the family  consists of all disjunctions, and the image of , which we denote , consists of all vectors  with at most  non-zero entries.  We can approximate disjunctions over the set  using a well-known transformation of the Chebyshev polynomials (see, e.g., \cite[Theorem 8]{KlivansSe04} and \cite[Claim 5.4]{HardtRoSe12}).  First we recall the useful properties of the univariate Chebyshev polynomials.

\begin{fact} [Chebyshev Polynomials] \label{lemma:chebyshev}
For every  and , there exists a univariate real polynomial  of degree  such that 
\ifnum\icalp=0
\begin{enumerate}
\item ,
\item for every ,
\item , and
\item for every , .
\end{enumerate}
\else
(1) , (2) for every , (3) , and (4) for every , .
\fi
Moreover, such a polynomial can be constructed in time  (e.g.~using linear programming, though more efficient algorithms are known).
\end{fact}

We can use Lemma \ref{lemma:chebyshev} to approximate -way monotone disjunctions. Note that our result easily extends to monotone -way conjunctions via the identity \\ . 
Moreover, it extends to non-monotone conjunctions and disjunctions: we may extend the data universe
as in \cite[Theorem 1.2]{HardtRoSe12} to , and include the negation of each item in the original domain. Non-monotone conjunctions over domain  correspond to monotone conjunctions over the expanded domain .

The next lemma shows that  can be efficiently and uniformly approximated by polynomials of low degree and low norm.  The statement is a well-known application of Chebyshev polynomials, and a similar statement appears in~\cite{HardtRoSe12} but without bounding the running time of the construction or a bound on the norm of the polynomials.  We include the statement and a proof for completeness, and to verify the additional properties we need. 

\begin{lemma}[Approximating  by polynomials, similar to~\cite{HardtRoSe12}] \label{thm:approxdisj}
For every  such that  and every , the family  of -variate real polynomials of degree  and norm  efficiently and uniformly -approximates the family  on the set .
\end{lemma}
\begin{proof}
The algorithm  for constructing the polynomials appears in the relevant codebox above.
\begin{algorithm}

\begin{algorithmic}
\STATE{\textbf{Input:} a vector .}
\STATE{\textbf{Let:}  be the polynomial described in Lemma~\ref{lemma:chebyshev}.}
\STATE{\textbf{Let:}  be the expansion of }
\STATE{\textbf{Output:} .}
\end{algorithmic}
\end{algorithm}

Since  is a degree- polynomial applied to a degree-1 polynomial (in the variables ), its degree is at most .  To see the stated norm bound, note that every monomial of total degree  in  comes from the expansion of , and every coefficient in this expansion is a non-negative integer less than or equal to . In , each of these terms is multiplied by  (the -th coefficient of ).  Thus the norm of  is at most .  To see that  is efficient, note that we can find every coefficient of  of total degree  by expanding  into all of its  terms and multiplying by , which can be done in time , as is required.

To see that  -approximates , observe that for every ,

and for every ,

This completes the proof.
\end{proof}
\else
Thus the family  consists of all disjunctions, and the index set, , consists of all vectors  with at most  non-zero entries.  

The next lemma shows that  can be efficiently and uniformly approximated by polynomials of low degree and low norm.  The statement is a well-known application of Chebyshev polynomials, and a similar statement appears in~\cite{HardtRoSe12} but without bounding the running time of the construction or a bound on the norm of the polynomials. 
\begin{lemma}[Approximating  by polynomials, similar to~\cite{HardtRoSe12}] \label{thm:approxdisj}
For every  such that  and every , the family  of -variate real polynomials of degree  and norm  efficiently and uniformly -approximates the family  on the set .
\end{lemma}
\fi

Theorem~\ref{thm:main1} in the introduction follows by combining Theorems~\ref{thm:releasepolys} and~\ref{thm:approxdisj}.


\subsection{Releasing Monotone -of- Queries}
We define the class of monotone -of- queries as follows:

\begin{definition}[Monotone -of- Queries] Let  and  such that .
The query set  of \emph{monotone -of- queries over } contains a query  for every .  Each query is defined as .
The  function family  contains a function

for every .
\end{definition}

\ifnum\icalp=0
Sherstov \cite[Lemma 3.11]{Sherstov09} gives an explicit construction of polynomials that can be used to approximate the family  over  with low degree.
It can be verified by inspecting the construction that the coefficients of the resulting polynomial are not too large.


\begin{lemma}[\cite{Sherstov09}] \label{lemma:paturi}
For every  such that  and , there exists a univariate polynomial  of degree  such that  and
\ifnum\icalp=0
\begin{enumerate}
\item ,
\item for every ,
\item for every , , and
\item for every , .
\end{enumerate}
\else
(1) ,
(2) for every ,
(3) for every , , and
(4) for every , .
\fi
Moreover,  can be constructed in time  (e.g.~using linear programming).
\end{lemma}
For completeness we include a proof of Lemma~\ref{lemma:paturi} in the appendix.
We can use these polynomials to approximate monotone -of- queries.

\begin{lemma}[Approximating  on ] \label{thm:approx2}
For every  such that  and every , the family  of -variate real polynomials of degree  and norm  efficiently and uniformly -approximates the family  on the set .
\end{lemma}
\begin{proof}
The construction and proof is identical to that of Theorem~\ref{thm:approxdisj} with the polynomials of Lemma~\ref{lemma:paturi} in place of the polynomials described in Lemma \ref{lemma:chebyshev}.
\end{proof}

Theorem~\ref{thm:main2} in the introduction now follows by combining Theorems~\ref{thm:releasepolys} and~\ref{thm:approx2}. Note that our result also extends easily
to non-monotone -of- queries in the same manner as Theorem \ref{thm:main1}.  
\else
The next lemma shows that  can be efficiently and uniformly approximated over  by low-degree polynomials.  The statement is based on approximation-theoretic results of Sherstov \cite[Lemma 3.11]{Sherstov09}.
\begin{lemma}[Approximating  on ] \label{thm:approx2}
For every  such that  and every , the family  of -variate real polynomials of degree  and norm  efficiently and uniformly -approximates the family  on the set .
\end{lemma}
\fi

\begin{remark}
Using the principle of inclusion-exclusion, the answer to a monotone -of- query can be written as a linear combination of the answers to  monotone -way disjunctions. Thus, a sanitizer that is -accurate for monotone -way disjunctions implies a sanitizer that is -accurate for monotone -of- queries. However, combining this implication with Theorem~\ref{thm:main1} yields a sanitizer with running time , which has a worse dependence on  than what we achieve in Theorem~\ref{thm:main2}.
\end{remark}

\subsection{Releasing Decision Lists} \label{sec:dls}

A \emph{length- decision list} over  variables is a function which can be written in the form
``if  then output  else  else if 
then output  else output ,'' where each
 is a boolean literal in , and each  is an output
bit in  Note that decision lists of length- strictly generalize -way disjunctions and conjunctions.  We use  to denote the set of all length- decision lists over  binary input variables.

\begin{definition}[Evaluations of Length- Decision Lists] Let  such that  and .
The query set  of \emph{evaluations of length- decision lists} contains a query  for every .  Each query is defined as  where  is a length- decision list over  variables.
The  function family  contains functions  for every .  That is, .
\end{definition}


We clarify that in this setting, the records in the database are length- decision lists over  and the queries inputs in .  Thus  and .  Alternatively,  for , since a length- decision list can be described using this many bits.
\ifnum\icalp=0
Klivans and Servedio \cite[Claim 5.4]{KlivansSe04} have shown that decision lists of length  can be uniformly approximated to accuracy  by low-degree polynomials.  We give a self-contained proof of this fact in Appendix \ref{app:dlfact} for completeness.
\else
\fi


\begin{lemma}[\cite{KlivansSe04}] \label{dlfact} For every  such that  and every , the family  of -variate real polynomials of degree  and norm  efficiently and uniformly -approximates the family  on all of .
\end{lemma}


We obtain Theorem \ref{thm:main3} of the introduction by combining Theorems~\ref{thm:releasepolys} and~\ref{dlfact}.  
\ifnum\icalp=0

\section{Generalizations and Limitations of Our Approach}
We note that the approach we take is not specific to low-degree polynomials.  Theorem~\ref{thm:releasepolys} extends to the case where the family  is efficiently and uniformly approximated on  by linear combinations of functions from any efficiently computable set  (In the case of polynomials,  is the set of all monomials of total degree at most ).  The properties we require from the function family  are that it (1) it is relatively small (as it determines our running time and minimum database size), (2) for every , we can efficiently compute  such that , and (3)  is small (say, at most ) for every  and .  In the special case of approximation by -variate real polynomials of degree  and norm , we can take  to be the set of monomials of total degree , thus  and .  If we have those parameters, then similarly to Theorem~\ref{thm:releasepolys} we can obtain an -differentially private sanitizer with running time  and accuracy .

Unfortunately, it turns out that, for all of the query sets considered in this paper, there is not much to be gained from considering more general functions families . Indeed, Klivans and Sherstov \cite[Theorem 1.1]{KlivansSh10} show that even
if  consists of \emph{arbitrary} functions 
whose linear combinations can uniformly approximate every monotone disjunction on  variables to error , then . Note that, up to logarithmic factors, this matches the dependence on  of the upper bound of Lemma \ref{thm:approxdisj}. 
Moreover, Sherstov \cite[Theorem 8.1]{Sh11pattern} broadly extends the result of \cite{KlivansSh10} beyond disjunctions, to \emph{pattern matrices} of any Boolean function 
with high \emph{approximate degree}. Roughly speaking, the pattern matrix of  corresponds to the query set consisting of all restrictions of , with some variables possibly negated (see 
\cite{Sh11pattern} for a precise definition). In particular, \cite[Theorem 8.1]{Sh11pattern} implies a function family independent lower bound for non-monotone -of- queries;
up to logarithmic factors, this lower bound matches the dependence on  and  of the upper bound of Lemma \ref{thm:approx2}.

We also note that our algorithm can be implemented in Kearns' \emph{statistical queries model}.  In the statistical queries model, algorithms can only access the database through a \emph{statistical queries oracle}  that takes as input a predicate  and returns a value  such that .  It can be verified that our algorithm can be implemented using  queries to  for , using one query to obtain each noisy coefficient (scaled to the range ).  In this case of -literal conjunctions, our algorithm makes  queries and requires .

Connections between differentially private data analysis and the statistical queries model have been studied extensively~\cite{BlumDwMcNi05, KasiviswanathanLeNiRaSm07, GuptaHaRoUl11}.  Gupta et.~al.~showed that lower bounds for \emph{agnostic learning} in the statistical queries model also imply lower bounds for data release in the statistical queries model.  Specifically, applying a result of Feldman~\cite{Feldman09}, they show that for every , for , and for every constant , there is no algorithm that makes  queries to , for , and releases -accurate answers to all monotone -way disjunction queries on .  Notice that our algorithm only makes a polynomial number of statistical queries when \emph{both}  and  are constant.

\else
\fi

\section*{Acknowledgements}

We thank Vitaly Feldman, Moritz Hardt, Varun Kanade, Aaron Roth, Guy Rothblum, and Li-Yang Tan for helpful discussions.

\bibliographystyle{splncs03}
\bibliography{./privacyrefs}
\appendix




\ifnum\icalp=0
\section{Polynomial Approximation of Decision Lists}
\label{app:dlfact}
\begin{lemma}[Theorem~\ref{dlfact} restated, \cite{KlivansSe04}]  For every  such that  and every , the family  of -variate real polynomials of degree  and norm  efficiently and uniformly -approximates the family  on all of .
\end{lemma}

\begin{proof} By Theorem \ref{thm:releasepolys}, it is sufficient to show that if  is any length- decision list over , then  can be -approximated 
by an explicit family of polynomials of degree  and norm . To this end, write  in the form,
``if  then output  else  else if 
then output  else output ,'' where each
 is a boolean literal, and each  is an output
bit in  Assume for notational convenience that  for all ; the proof for general decision lists is similar.

Following \cite[Theorem 8]{KlivansSe04}, we may write


At a high level, we treat each term of the above sum independently, using a transformation of the Chebyshev polynomials to approximate each term
within additive error . This ensures that 
that the sum of the resulting polynomials approximates
 within additive error  as desired. Details follow.

Let  be the polynomial described in Lemma \ref{lemma:chebyshev} with error parameter . Then the polynomial  satisfies the following properties:

\begin{enumerate}
\item The degree of  is ,
\item  for every , the -th coefficient, , of  has magnitude ,
\item  , and
\item for every , .
\end{enumerate}
Moreover,  can be constructed in time  (e.g.~using linear programming, though faster algorithms for constructing  are known).

Consider the polynomial  defined as 



It is easily seen that  is has degree  and the absolute value of each of the coefficients is at most . Moreover,  for all . This completes the proof.

\section{Polynomial Approximation of -of- Queries}
\label{sherstovapp}
\begin{lemma}[Lemma~\ref{lemma:paturi} restated,\cite{Sherstov09}]
For every  such that  and , there exists a univariate polynomial  of degree  such that  and:
\begin{enumerate}
\item  ,
\item for every ,
\item for every , , and
\item for every , .
\end{enumerate}
Moreover,  can be constructed in time  (e.g.~using linear programming).
\end{lemma}
We give details for the construction of \cite[Lemma 3.11]{Sherstov09}. We do not prove the approximation properties (which is done in~\cite{Sherstov09}), but just confirm the sizes of the coefficients.  
The result is trivial if  or  since every symmetric function on 
has an exact representation as a polynomial of degree , so assume  and , with . 



Let  be the degree  Chebyshev polynomial of the first kind (Fact~\ref{fact:coeff}). We will use the following well-known properties of Chebyshev polynomials.

\begin{fact} \label{fact:coeff} The Chebyshev polynomials of the first kind satisfy the following properties.

\begin{enumerate}
\item Each coefficient of  has absolute value at most .
\item  for all . 
\end{enumerate}
\end{fact} 

Let , and . 
The construction proceeds in several steps, with the final polynomial  defined in terms of multiple intermediate polynomials. 

\begin{enumerate}
\item For any fixed integer ,  let 
 
All the coefficients of  are bounded in absolute value by .  

\item Define  The coefficients of  are bounded in absolute value by 


\item Define the polynomial 

 has degree at most 

Noting that , it is clear that the coefficients of  are bounded in absolute value by .

\item Define the polynomial . Since  by Part 2 of Fact \ref{fact:coeff}, the absolute values of the coefficients of  are no larger than those of .

\item Define the univariate polynomial  

The coefficients of  have absolute value at most .

\item Define the polynomial 



Noticing that , it is clear that the degree of  is , and the absolute values of the coefficients of  are at most
. 

\item Define the polynomial . The absolute value of the coefficients of  are also 
bounded above by . 

Sherstov's arguments show that  is a -approximation to the function 

\item The final polynomial  is defined as 

The coefficients of  have absolute value at most , and  has the desired degree.
Moreover,  -approximates the function  on the set , since the th term in the sum 
 is a   approximation for the function
.

Since , it holds that . Thus, the coefficients of  have absolute value at most .


\end{enumerate}


\end{proof}
\else
\fi



\end{document}