\documentclass{article}

\PassOptionsToPackage{numbers, compress}{natbib}




\usepackage[preprint]{nips_2018}





\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      

\usepackage{microtype}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{booktabs} \usepackage{ amssymb }
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{arydshln}
\usepackage{xcolor}

\newcommand{\entities}{\ensuremath{\mathcal{E}}}
\newcommand{\relations}{\ensuremath{\mathcal{R}}}
\newcommand{\KG}{\ensuremath{\mathcal{KG}}}
\newcommand{\embedding}[1]{\ensuremath{\mathsf{\mathbf{#1}}}}
\newcommand{\triple}[3]{(\mathit{#1}, \mathit{#2}, \mathit{#3})}
\newcommand{\eye}{\ensuremath{\mathcal{I}}}

\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}
\newtheorem{corollary}{Corollary}
\newtheorem{defn}{Definition}
\newenvironment{definition}{\begin{defn}\em}{\end{defn}}
\newtheorem{exampl}{Example}
\newenvironment{example}{\begin{exampl}\em}{\end{exampl}}
\newenvironment{proofsketch}{  \renewcommand{\proofname}{Proof Sketch}\proof}{\endproof}

\newcommand{\Mehran}[1]{\textcolor{red}{Mehran: #1}}
\newcommand{\David}[1]{\textcolor{green}{David: #1}}

\title{SimplE Embedding for Link Prediction in Knowledge Graphs}



\author{
  Seyed Mehran Kazemi\\
  University of British Columbia\\
 Vancouver, BC, Canada \\
  \texttt{smkazemi@cs.ubc.ca} \\
\And
   David Poole \\
   University of British Columbia\\
  Vancouver, BC, Canada \\ 
    \texttt{poole@cs.ubc.ca} \\
}

\begin{document}


\maketitle

\begin{abstract}
Knowledge graphs contain knowledge about the world and provide a structured representation of this knowledge. 
Current knowledge graphs contain only a small subset of what is true in the world. 
\emph{Link prediction} approaches aim at predicting new links for a knowledge graph given the existing links among the entities. 
\emph{Tensor factorization} approaches have proved promising for such link prediction problems. 
Proposed in 1927, Canonical Polyadic (CP) decomposition is among the first tensor factorization approaches. 
CP generally performs poorly for link prediction as it learns two independent embedding vectors for each entity, whereas they are really tied.
We present a simple enhancement of CP (which we call SimplE) to allow the two embeddings of each entity to be learned dependently. 
The complexity of SimplE grows linearly with the size of embeddings. 
The embeddings learned through \emph{SimplE} are interpretable, and certain types of background knowledge can be incorporated into these embeddings through weight tying. 
We prove \emph{SimplE} is fully expressive and derive a bound on the size of its embeddings for full expressivity. 
We show empirically that, despite its simplicity, \emph{SimplE} outperforms several state-of-the-art tensor factorization techniques.
SimplE's code is available on GitHub at \url{https://github.com/Mehran-k/SimplE}.
\end{abstract}

\section{Introduction}
During the past two decades, several knowledge graphs (KGs) containing (perhaps probabilistic) facts about the world have been constructed. These KGs have applications in several fields including search, question answering, natural language processing, recommendation systems, etc. Due to the enormous number of facts that could be asserted about our world and the difficulty in accessing and storing all these facts, KGs are incomplete. However, it is possible to predict new links in a KG based on the existing ones. \emph{Link prediction} and several other related problems aiming at reasoning with entities and relationships are studied under the umbrella of \emph{statistical relational learning (SRL)} \cite{getoor2007introduction,nickel2016review,StarAI-Book}. The problem of link prediction for KGs is also known as \emph{knowledge graph completion}. A KG can be represented as a set of  triples\footnote{Triples are complete for relations. They are sometimes written as  or .}. The problem of KG completion can be viewed as predicting new triples based on the existing ones.

Tensor factorization approaches have proved to be an effective SRL approach for KG completion \cite{nickel2012factorizing,bordes2013translating,trouillon2016complex,StransE}. These approaches consider embeddings for each entity and each relation. To predict whether a triple holds, they use a function which takes the embeddings for the head and tail entities and the relation as input and outputs a number indicating the predicted probability. Details and discussions of these approaches can be found in several recent surveys \cite{nguyen2017overview,wang2017knowledge}.

One of the first tensor factorization approaches is the \emph{canonical Polyadic (CP)} decomposition \cite{hitchcock1927expression}. This approach learns one embedding vector for each relation and two embedding vectors for each entity, one to be used when the entity is the \emph{head} and one to be used when the entity is the \emph{tail}. 
The head embedding of an entity is learned independently of (and is unrelated to) its tail embedding.
This independence has caused CP to perform poorly for KG completion \cite{trouillon2017knowledge}. In this paper, we develop a tensor factorization approach based on CP that addresses the independence among the two embedding vectors of the entities. Due to the simplicity of our model, we call it \emph{SimplE} (\textbf{Simpl}e \textbf{E}mbedding). 

We show that \emph{SimplE}: 1- can be considered a bilinear model, 2- is fully expressive, 3- is capable of encoding background knowledge into its embeddings through parameter sharing (aka weight tying), and 4- performs very well empirically despite (or maybe because of) its simplicity. We also discuss several disadvantages of other existing approaches. We prove that many existing translational approaches (see e.g., \cite{bordes2013translating,ji2015knowledge,wang2014knowledge,StransE}) are not fully expressive and we identify severe restrictions on what they can represent. We also show that the function used in \emph{ComplEx} \cite{trouillon2016complex,trouillon2017knowledge}, a state-of-the-art approach for link prediction, involves redundant computations.

\section{Background and Notation}
We represent vectors with lowercase letters and matrices with uppercase letters. Let  be vectors of length . We define , where , , and  represent the th element of ,  and  respectively. That is,  where  represents element-wise (Hadamard) multiplication and  represents dot product.  represents an identity matrix of size .  represents the concatenation of  vectors , ,  and .

Let \entities\ and \relations\ represent the set of entities and relations respectively. 
A \textbf{triple} is represented as , where  is the \emph{head},  is the relation, and  is the \emph{tail} of the triple. 
Let  represent the set of all triples that are true in a world (e.g., ), and  represent the ones that are false (e.g., ). 
A \textbf{knowledge graph} \KG\ is a subset of . 
A relation  is \textbf{reflexive} on a set  of entities if  for all entities . A relation  is \textbf{symmetric} on a set  of entities if  for all pairs of entities , and is \textbf{anti-symmetric} if . A relation  is \textbf{transitive} on a set  of entities if  for all . The inverse of a relation , denoted as , is a relation such that for any two entities  and , . 

An \textbf{embedding} is a function from an entity or a relation to one or more vectors or matrices of numbers. 
A \textbf{tensor factorization} model defines two things: 1- the embedding functions for entities and relations, 2- a function  taking the embeddings for ,  and  as input and generating a prediction of whether  is in  or not. The values of the embeddings are learned using the triples in a \KG.
A tensor factorization model is \textbf{fully expressive} if given any ground truth (full assignment of truth values to all triples), there exists an assignment of values to the embeddings of the entities and relations that accurately separates the correct triples from incorrect ones. 

\section{Related Work}
\textbf{Translational Approaches} define additive functions over embeddings. In many translational approaches, the embedding for each entity  is a single vector  and the embedding for each relation  is a vector  and two matrices  and . The dissimilarity function for a triple  is defined as  (i.e. encouraging ) where  represents norm  of vector . Translational approaches having this dissimilarity function usually differ on the restrictions they impose on  and . In TransE \cite{bordes2013translating}, , . In TransR \cite{lin2015learning}, . In STransE \cite{StransE}, no restrictions are imposed on the matrices. FTransE \cite{feng2016knowledge}, slightly changes the dissimilarity function defining it as  for a value of  that minimizes the norm for each triple. In the rest of the paper, we let \emph{FSTransE} represent the FTransE model where no restrictions are imposed over  and .

\textbf{Multiplicative Approaches} define product-based functions over embeddings. DistMult \cite{yang2014embedding}, one of the simplest multiplicative approaches, considers the embeddings for each entity and each relation to be  and  respectively and defines its similarity function for a triple  as . Since DistMult does not distinguish between head and tail entities, it can only model symmetric relations. ComplEx \cite{trouillon2016complex} extends DistMult by considering complex-valued instead of real-valued vectors for entities and relations. For each entity , let  and  represent the real and imaginary parts of the embedding for . For each relation , let  and  represent the real and imaginary parts of the embedding for . Then the similarity function of ComplEx for a triple  is defined as , where   and . One can easily verify that the function used by ComplEx can be expanded and written as . In RESCAL \cite{nickel2011three}, the embedding vector for each entity  is  and for each relation  is  and the similarity function for a triple  is , where  represents the outer product of two vectors and  vectorizes the input matrix. HolE \cite{nickel2016holographic} is a multiplicative model that is isomorphic to ComplEx \cite{hayashi2017equivalence}.

\textbf{Deep Learning Approaches} generally use a neural network that learns how the head, relation, and tail embeddings interact. 
E-MLP \cite{socher2013reasoning} considers the embeddings for each entity  to be a vector , and for each relation  to be a matrix  and a vector . To make a prediction about a triple , E-MLP feeds  into a two-layer neural network whose weights for the first layer are the matrix  and for the second layer are . 
ER-MLP \cite{KnowledgeVault}, 
considers the embeddings for both entities and relations to be single vectors and feeds  into a two layer neural network. In \cite{santoro2017simple}, once the entity vectors are provided by the convolutional neural network and the relation vector is provided by the long-short time memory network, for each triple the vectors are concatenated similar to ER-MLP and are fed into a four-layer neural network. Neural tensor network (NTN) \cite{socher2013reasoning} combines E-MLP with several bilinear parts (see Subsection~\ref{bilinear-subsection} for a definition of bilinear models).

\section{SimplE: A Simple Yet Fully Expressive Model}
In \emph{canonical Polyadic (CP)} decomposition \cite{hitchcock1927expression}, the embedding for each entity  has two vectors , and for each relation  has a single vector . 
 captures 's behaviour as the head of a relation and  captures 's behaviour as the tail of a relation.
The similarity function for a triple  is . 
In CP, the two embedding vectors for entities are learned independently of each other: observing  only updates  and , not  and .

\begin{example}
Let  represent if a person  likes a movie  and  represent who acted in which movie. Which actors play in a movie is expected to affect who likes the movie. In CP, observations about \emph{likes} only update the  vector of movies and observations about \emph{acted} only update the  vector. Therefore, what is being learned about movies through observations about \emph{acted} does not affect the predictions about \emph{likes} and vice versa. 
\end{example}

\emph{SimplE} takes advantage of the inverse of relations to address the independence of the two vectors for each entity in CP. While inverse of relations has been used for other purposes (see e.g., \cite{lao2010relational,lin2015modeling,das2017go}), using them to address the independence of the entity vectors in CP is a novel contribution.

\textbf{Model Definition:} SimplE considers two vectors  as the embedding of each entity  (similar to CP), and two vectors  for each relation . The similarity function of SimplE for a triple  is defined as , i.e. the average of the CP scores for  and .
In our experiments, we also consider a different variant, which we call \emph{SimplE-ignr}. 
During training, for each correct (incorrect) triple , SimplE-ignr updates the embeddings such that each of the two scores  and  become larger (smaller).
During testing, \emph{SimplE-ignr} ignores  and defines the similarity function to be . 

\textbf{Learning SimplE Models:} To learn a SimplE model, we use stochastic gradient descent with mini-batches. In each learning iteration, we iteratively take in a batch of positive triples from the \KG, then for each positive triple in the batch we generate  negative triples by corrupting the positive triple. We use \citet{bordes2013translating}'s procedure to corrupt positive triples. The procedure is as follows. For a positive triple , we randomly decide to corrupt the head or tail. If the head is selected, we replace  in the triple with an entity  randomly selected from  and generate the corrupted triple . If the tail is selected, we replace  in the triple with an entity  randomly selected from  and generate the corrupted triple . We generate a labelled batch  by labelling positive triples as  and negatives as .
Once we have a labelled batch, following \cite{trouillon2016complex} we optimize the  regularized negative log-likelihood of the batch:
, 
where  represents the parameters of the model (the parameters in the embeddings),  represents the label of a triple,  represents the similarity score for triple ,  is the regularization hyper-parameter, and . While several previous works (e.g., TransE, TransR, STransE, etc.) consider a margin-based loss function, \citet{trouillon2017complex} show that the margin-based loss function is more prone to overfitting compared to log-likelihood.

\section{Theoretical Analyses}
In this section, we provide some theoretical analyses of SimplE and other existing approaches. 

\subsection{Fully Expressiveness}
The following proposition establishes the full expressivity of SimplE.

\begin{figure}[t]
\caption{s and s in the proof of Proposition~\ref{fully-expressiveness-prop}.}
\label{full-exp-fig}
\small
\begin{center}
\begin{tabular}{c| @{\hspace{0.05cm}} c @{\hspace{0.05cm}} c @{\hspace{0.05cm}} c @{\hspace{0.05cm}} c @{\hspace{0.05cm}} c @{\hspace{0.05cm}} : @{\hspace{0.05cm}} c @{\hspace{0.05cm}} c @{\hspace{0.05cm}} c @{\hspace{0.05cm}} c @{\hspace{0.05cm}} c @{\hspace{0.05cm}} : @{\hspace{0.05cm}} c @{\hspace{0.05cm}} : @{\hspace{0.05cm}} c @{\hspace{0.05cm}} c @{\hspace{0.05cm}} c @{\hspace{0.05cm}} c @{\hspace{0.15cm}} c}
 & 1 & 0 & 0 &  & 0 & 1 & 0 & 0 &  & 0 &  & 1 & 0 & 0 & & 0 \\
 & 0 & 1 & 0 &  & 0 & 0 & 1 & 0 &  & 0 &  & 0 & 1 & 0 &  & 0 \\
 & 0 & 0 & 1 &  & 0 & 0 & 0 & 1 &  & 0 &  & 0 & 0 & 1 &  & 0 \\
 &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  \\
 & 0 & 0 & 0 &  & 1 & 0 & 0 & 0 &  & 1 &  & 0 & 0 & 0 &  & 1 \\ \hline
 & 1 & 1 & 1 &  & 1 & 0 & 0 & 0 &  & 0 &  & 0 & 0 & 0 &  & 0 \\
 & 0 & 0 & 0&  & 0 & 1 & 1 & 1 &  & 1 &  & 0 & 0 & 0 &  & 0 \\
 &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  \\
 & 0 & 0 & 0 &  & 0 & 0 & 0 & 0 &  & 0 &  & 1 & 1 & 1 &  & 1 \\ 
\end{tabular}
\end{center}
\end{figure}

\begin{proposition} \label{fully-expressiveness-prop}
For any ground truth over entities  and relations  containing  true facts, there exists a SimplE model with embedding vectors of size  that represents that ground truth.
\end{proposition}

\begin{proof}
First, we prove the  bound. With embedding vectors of size , for each entity  we let the n-th element of  if ( \emph{mod}  and  otherwise, and for each relation  we let the n-th element of  if ( \emph{div}  and  otherwise (see Fig~\ref{full-exp-fig}). Then for each  and , the product of  and  is  everywhere except for the -th element. So for each entity , we set the -th element of  to be  if  holds and  otherwise.

Now we prove the  bound. Let  be zero (base of the induction). We can have embedding vectors of size  for each entity and relation, setting the value for entities to  and for relations to . Then  is negative for every entities  and  and relation . So there exists embedding vectors of size  that represents this ground truth.
Let us assume for any ground truth where  , there exists an assignment of values to embedding vectors of size  that represents that ground truth (assumption of the induction). We must prove for any ground truth where , there exists an assignment of values to embedding vectors of size  that represents this ground truth.
Let  be one of the  true facts. Consider a modified ground truth which is identical to the ground truth with  true facts, except that  is assigned false. The modified ground truth has  true facts and based on the assumption of the induction, we can represent it using some embedding vectors of size . Let  where ,  and  are the embedding vectors that represent the modified ground truth. We add an element to the end of all embedding vectors and set it to . This increases the vector sizes to  but does not change any scores. Then we set the last element of  to ,  to , and  to . This ensures that  for the new vectors, and no other score is affected.
\end{proof}

DistMult is not fully expressive as it forces relations to be symmetric. It has been shown in \cite{trouillon2017knowledge} that ComplEx is fully expressive with embeddings of length at most . According to the universal approximation theorem \cite{cybenko1989approximations,hornik1991approximation}, under certain conditions, neural networks are universal approximators of continuous functions over compact sets. Therefore, we would expect there to be a representation based on neural networks that can approximate any ground truth, but the number of hidden units might have to grow with the number of triples. \citet{wang2017multi} prove that \emph{TransE} is not fully expressive. Proposition~\ref{fstranse-prop} proves that not only TransE but also many other translational approaches are not fully expressive. The proposition also identifies severe restrictions on what relations these approaches can represent. 

\begin{proposition} \label{fstranse-prop}
FSTransE is not fully expressive and has the following restrictions.  If a relation  is reflexive on ,  must also be symmetric on ,  If  is reflexive on ,  must also be transitive on , and  If entity  has relation  with every entity in  and entity  has relation  with one of the entities in , then  must have the relation  with every entity in .
\end{proposition}

\begin{proof}
For any entity  and relation , let  and . For a triple  to hold, we should ideally have  for some . We assume , ,  and  are entities in .

 A relation  being reflexive on  implies  and . Suppose  holds as well. Then we know . Therefore, , where .
Therefore,  must holds.

 A relation  being reflexive implies , , and . Suppose  and  hold. Then we know  and . We can conclude , where . The above equality proves  must hold.

 Let  have relation  with . We know , , and . We can conclude , where . Therefore,  must hold.
\end{proof}

\begin{corollary}
Other variants of translational approaches such as TransE, FTransE, STransE, TransH \cite{wang2014knowledge}, and TransR \cite{lin2015learning} also have the restrictions mentioned in Proposition~\ref{fstranse-prop}.
\end{corollary}

\subsection{Incorporating Background Knowledge into the Embeddings} \label{expert-subsection}
In SimplE, each element of the embedding vector of the entities can be considered as a feature of the entity and the corresponding element of a relation can be considered as a measure of how important that feature is to the relation. Such interpretability allows the embeddings learned through SimplE for an entity (or relation) to be potentially transferred to other domains. It also allows for incorporating observed features of entities into the embeddings by fixing one of the elements of the embedding vector of the observed value. \citet{nickel2014reducing} show that incorporating such features helps reduce the size of the embeddings.
 
Recently, incorporating background knowledge into tensor factorization approaches has been the focus of several studies. Towards this goal, many existing approaches rely on post-processing steps or add additional terms to the loss function to penalize predictions that violate the background knowledge \cite{rocktaschel2014low,wang2015knowledge,wei2015large,guo2016jointly,ding2018improving}.  \citet{minervini2017regularizing} show how background knowledge in terms of equivalence and inversion can be incorporated into several tensor factorization models through parameter tying\footnote{Although their incorporation of inversion into DistMult is not correct as it has side effects.}. Incorporating background knowledge by parameter tying has the advantage of guaranteeing the predictions follow the background knowledge for all embeddings.
In this section, we show how three types of background knowledge, namely symmetry, anti-symmetry, and inversion, can be incorporated into the embeddings of SimplE by tying the parameters\footnote{Note that such background knowledge can be exerted on some relations selectively and not on the others. This is different than, e.g., DistMult which enforces symmetry on all relations.} (we ignore the equivalence between two relations as it is trivial).

\begin{proposition} \label{expert-prop1}
Let  be a relation such that for any two entities  and  we have  (i.e.  is symmetric). This property of  can be encoded into SimplE by tying the parameters  to .
\end{proposition}

\begin{proof}
If , then a SimplE model makes  and  positive. By tying the parameters  to , we can conclude that  and  also become positive. Therefore, the SimplE model predicts .
\end{proof}

\begin{proposition} \label{expert-prop2}
Let  be a relation such that for any two entities  and  we have  (i.e.  is anti-symmetric). This property of  can be encoded into SimplE by tying the parameters  to the negative of .
\end{proposition}

\begin{proof}
If , then a SimplE model makes  and  positive. By tying the parameters  to the negative of , we can conclude that  and  become negative. Therefore, the SimplE model predicts .
\end{proof}

\begin{proposition} \label{expert-prop3}
Let  and  be two relations such that for any two entities  and  we have  (i.e.  is the inverse of ). This property of  and  can be encoded into SimplE by tying the parameters  to  and  to .
\end{proposition}

\begin{proof}
If , then a SimplE model makes  and  positive. By tying the parameters  to  and  to , we can conclude that  and  also become positive. Therefore, the SimplE model predicts .
\end{proof}

\subsection{Time Complexity and Parameter Growth}
As described in \cite{bordes2013irreflexive}, to scale to the size of the current KGs and keep up with their growth, a relational model must have a linear time and memory complexity. Furthermore, one of the important challenges in designing tensor factorization models is the trade-off between expressivity and model complexity. Models with many parameters usually overfit and give poor performance.
While the time complexity for TransE is  where  is the size of the embedding vectors, adding the projections as in STransE (through the two relation matrices) increases the time complexity to . Besides time complexity, the number of parameters to be learned from data grows quadratically with . A quadratic time complexity and parameter growth may arise two issues: 1- scalability problems, 2- overfitting. Same issues exist for models such as RESCAL and NTNs that have quadratic or higher time complexities and parameter growths. DistMult and ComplEx have linear time complexities and the number of their parameters grow linearly with . 

The time complexity of both \emph{SimplE-ignr} and \emph{SimplE} is , i.e. linear in the size of vector embeddings. \emph{SimplE-ignr} requires one multiplication between three vectors for each triple. This number is  for \emph{SimplE} and  for \emph{ComplEx}. 
Thus, with the same number of parameters, \emph{SimplE-ignr} and \emph{SimplE} reduce the computations by a factor of  and  respectively compared to \emph{ComplEx}.

\subsection{Family of Bilinear Models} \label{bilinear-subsection}
Bilinear models correspond to the family of models where the embedding for each entity  is , for each relation  is  (with certain restrictions), and the similarity function for a triple  is defined as .  These models have shown remarkable performance for link prediction in knowledge graphs \cite{nickel2016review}. DistMult, ComplEx, and RESCAL are known to belong to the family of bilinear models. We show that SimplE (and CP) also belong to this family. 

DistMult can be considered a bilinear model which restricts the  matrices to be diagonal as in Fig.~\ref{bilinear-fig}(a). For ComplEx, if we consider the embedding for each entity  to be a single vector , then it can be considered a bilinear model with its  matrices constrained according to Fig.~\ref{bilinear-fig}(b). RESCAL can be considered a bilinear model which imposes no constraints on the  matrices. Considering the embedding for each entity  to be a single vector , CP can be viewed as a bilinear model with its  matrices constrained as in Fig~\ref{bilinear-fig}(c). For a triple , multiplying  to  results in a vector  whose first half is zero and whose second half corresponds to an element-wise product of  to the parameters in . Multiplying  to  corresponds to ignoring  (since the first half of  is zeros) and taking the dot-product of the second half of  with . SimplE can be viewed as a bilinear model similar to CP except that the  matrices are constrained as in Fig~\ref{bilinear-fig}(d). The extra parameters added to the matrix compared to CP correspond to the parameters in the inverse of the relations. 

The constraint over  matrices in SimplE is very similar to the constraint in DistMult.  in both SimplE and DistMult can be considered as an element-wise product of the parameters, except that the s in SimplE swap the first and second halves of the resulting vector.  
Compared to ComplEx, SimplE removes the parameters on the main diagonal of s. Note that several other restrictions on the  matrices are equivalent to SimplE, e.g., restricting  matrices to be zero everywhere except on the counterdiagonal. Viewing SimplE as a single-vector-per-entity model makes it easily integrable (or compatible) with other embedding models (in knowledge graph completion, computer vision and natural language processing) such as \cite{santoro2017simple,zhang2017visual,schlichtkrull2018modeling}.

\begin{figure}[t]
\centering
\includegraphics[width=0.9\textwidth]{bilinear}
\caption{The constraints over  matrices for bilinear models (a) DistMult, (b) ComplEx, (c) CP, and (d) SimplE. The lines represent where the parameters are; other elements of the matrices are constrained to be zero. In ComplEx, the parameters represented by the dashed line is tied to the parameters represented by the solid line and the parameters represented by the dotted line is tied to the negative of the dotted-and-dashed line.}
\label{bilinear-fig}
\end{figure}

\subsection{Redundancy in ComplEx}
As argued earlier, with the same number of parameters, the number of computations in ComplEx are 4x and 2x more than SimplE-ignr and SimplE. Here we show that a portion of the computations performed by ComplEx to make predictions is redundant. Consider a ComplEx model with embedding vectors of size  (for ease of exposition). Suppose the embedding vectors for ,  and  are , , and  respectively. Then the probability of  being correct according to ComplEx is proportional to the sum of the following four terms: , , , and .
It can be verified that for any assignment of (non-zero) values to s and s, at least one of the above terms is negative. 
This means for a correct triple, ComplEx uses three terms to overestimate its score and then uses a term to cancel the overestimation.

The following example shows how this redundancy in ComplEx may affect its interpretability:
\begin{example}
Consider a ComplEx model with embeddings of size . Consider entities ,  and  with embedding vectors , , and  respectively, and a relation  with embedding vector .
According to ComplEx, the score for triple  is positive suggesting  probably has relation  with . However the score for triple  is negative suggesting  probably does not have relation  with . Since the only difference between  and  is that the imaginary part changes from  to , it is difficult to associate a meaning to these numbers.
\end{example}

\section{Experiments and Results}
\textbf{Datasets:} We conducted experiments on two standard benchmarks: WN18 a subset of \emph{Wordnet} \cite{miller1995wordnet}, and FB15k a subset of \emph{Freebase} \cite{bollacker2008freebase}. We used the same train/valid/test sets as in \cite{bordes2013translating}. WN18 contains  entities,  relations,  train,  validation and  test triples. FB15k contains  entities,  relations,  train,  validation, and  test triples.

\textbf{Baselines:} We compare SimplE with several existing tensor factorization approaches. Our baselines include canonical Polyadic (CP) decomposition, TransE, TransR,  DistMult, NTN, STransE, ER-MLP, and ComplEx. Given that we use the same data splits and objective function as ComplEx, we report the results of CP, TransE, DistMult, and ComplEx from \cite{trouillon2016complex}. We report the results of TransR and NTN from \cite{nguyen2017overview}, and ER-MLP from \cite{nickel2016holographic} for further comparison.

\textbf{Evaluation Metrics:} To measure and compare the performances of different models, for each test triple  we compute the score of  triples for all  and calculate the ranking  of the triple having , and we compute the score of  triples for all  and calculate the ranking  of the triple having . Then we compute the \emph{mean reciprocal rank (MRR)} of these rankings as the mean of the inverse of the rankings:
,
where  represents the test triples. MRR is a more robust measure than \emph{mean rank}, since a single bad ranking can largely influence \emph{mean rank}.

\citet{bordes2013translating} identified an issue with the above procedure for calculating the MRR (hereafter referred to as \emph{raw MRR}). For a test triple , since there can be several entities  for which  holds, measuring the quality of a model based on its ranking for  may be flawed. That is because two models may rank the test triple  to be second, when the first model ranks a correct triple (e.g., from train or validation set)  to be first and the second model ranks an incorrect triple  to be first. Both these models will get the same score for this test triple when the first model should get a higher score.
To address this issue, \cite{bordes2013translating} proposed a modification to raw MRR. For each test triple , instead of finding the rank of this triple among triples  for all  (or  for all ), they proposed to calculate the rank among triples  only for  such that . Following \cite{bordes2013translating}, we call this measure \emph{filtered MRR}. 
We also report  measures. The  for a model is computed as the percentage of test triples whose ranking (computed as described earlier) is less than or equal .

\textbf{Implementation:} We implemented SimplE in TensorFlow \cite{TensorFlow}. We tuned our hyper-parameters over the validation set. We used the same search grid on embedding size and  as \cite{trouillon2016complex} to make our results directly comparable to their results. We fixed the maximum number of iterations to  and the batch size to . We set the learning rate for WN18 to  and for FB15k to  and used \emph{adagrad} to update the learning rate after each batch. Following \cite{trouillon2016complex}, we generated one negative example per positive example for WN18 and  negative examples per positive example in FB15k. We computed the filtered MRR of our model over the validation set every  iterations for WN18 and every  iterations for  and selected the iteration that resulted in the best validation filtered MRR. The best embedding size and  values on WN18 for SimplE-ignr were  and  respectively, and for SimplE were  and . The best embedding size and  values on FB15k for SimplE-ignr were  and  respectively, and for SimplE were  and .

\begin{table*}[t]
\scriptsize
\caption{Results on WN18 and FB15k. Best results are in bold.}
\label{results-table}
\begin{center}
\begin{tabular}{ccccccccccc}
\toprule
& \multicolumn{5}{c}{WN18} & \multicolumn{5}{c}{FB15k}                   \\
\cmidrule(lr){2-6} \cmidrule(lr){7-11}
& \multicolumn{2}{c}{MRR} & \multicolumn{3}{c}{Hit@} & \multicolumn{2}{c}{MRR} & \multicolumn{3}{c}{Hit@} \\
\cmidrule(lr){2-3} \cmidrule(lr){4-6} \cmidrule(lr){7-8} \cmidrule(lr){9-11}
Model & Filter & Raw & 1 & 3 & 10 & Filter & Raw & 1 & 3 & 10 \\ \hline
CP &   &  &  &  &  &  &   &   &  &  \\
TransE &  &  &  &  &  &  &  &  &  &  \\
TransR &  &  &  &  &  &  &  &  &  &  \\
DistMult &   &  &  &  &  &  &  &  &  &  \\
NTN &  &  &  &  &  &  &  &  &  &  \\
STransE &  &  &  &  &  &  &  &  &  &  \\
ER-MLP &  &  &  &  &  &  &  &  &  &  \\
ComplEx &  &  &  &  &  &  &  &  &  &  \\ \hline
SimplE-ignr &  &  &  &  &  &  &  &  &  &  \\
SimplE &  &  &  &  &  &  &  &  &  &   
\end{tabular}
\end{center}
\end{table*}

\subsection{Entity Prediction Results}
Table~\ref{results-table} shows the results of our experiments. It can be viewed that both SimplE-ignr and SimplE do a good job compared to the existing baselines on both datasets. On WN18, SimplE-ignr and SimplE perform as good as ComplEx, a state-of-the-art tensor factorization model. On FB15k, SimplE outperforms the existing baselines and gives state-of-the-art results among tensor factorization approaches. SimplE (and SimplE-ignr) work especially well on this dataset in terms of filtered MRR and \emph{hit@1}, so SimplE tends to do well at having its first prediction being correct. 

The table shows that models with many parameters (e.g., NTN and STransE) do not perform well on these datasets, as they probably overfit. Translational approaches generally have an inferior performance compared to other approaches partly due to their representation restrictions mentioned in Proposition~\ref{fstranse-prop}. As an example for the \emph{friendship} relation in FB15k, if an entity  is friends with  other entities and another entity  is friends with only one of those 20, then according to Proposition~\ref{fstranse-prop} translational approaches force  to be friends with the other 19 entities as well (same goes for, e.g., \emph{netflix genre} in FB15k and \emph{has part} in WN18). The table also shows that bilinear approaches tend to have better performances compared to translational and deep learning approaches. Even DistMult, the simplest bilinear approach, outperforms many translational and deep learning approaches despite not being fully expressive. We believe the simplicity of embeddings and the scoring function is a key property for the success of SimplE.

\subsection{Incorporating background knowledge} \label{expert-knowledge-experiment-section}
When background knowledge is available, we might expect that a knowledge graph might not include redundant information because it is implied by background knowledge and so the methods that do not include the background knowledge can never learn it.
In section~\ref{expert-subsection}, we showed how background knowledge that can be formulated in terms of three types of rules can be incorporated into SimplE embeddings. 
To test this empirically, we conducted an experiment on WN18 in which we incorporated several such rules into the embeddings as outlined in Propositions~\ref{expert-prop1},~\ref{expert-prop2},~and~\ref{expert-prop3}. The rules can be found in Table~\ref{rules-table}. 
As can be viewed in Table~\ref{rules-table}, most of the rules are of the form . For (possibly identical) relations such as  and  participating in such a rule, if both  and  are in the training set, one of them is redundant because one can be inferred from the other.
We removed redundant triples from the training set by randomly removing one of the two triples in the training set that could be inferred from the other one based on the background rules. Removing redundant triples reduced the number of triples in the training set from (approximately)  to (approximately) , almost  reduction in size. Note that this experiment provides an upper bound on how much background knowledge can improve the performance of a SimplE model.

We trained SimplE-ignr and SimplE (with tied parameters according to the rules) on this new training dataset with the best hyper-parameters found in the previous experiment. We refer to these two models as \emph{SimplE-ignr-bk} and \emph{SimplE-bk}. We also trained another SimplE-ignr and SimplE models on this dataset, but without incorporating the rules into the embeddings. For sanity check, we also trained a ComplEx model over this new dataset. 
We found that the filtered MRR for SimplE-ignr, SimplE, and ComplEx were respectively , , and . For SimplE-ignr-bk and SimplE-bk, the filtered MRRs were  and  respectively, substantially higher than the case without background knowledge. In terms of  measures, SimplE-ignr gave , , and  for ,  and  respectively. These numbers were , , and  for SimplE, and ,  and  for ComplEx. For SimplE-ignr-bk, these numbers were ,  and  and for SimplE-bk they were ,  and , also substantially higher than the models without background knowledge. The obtained results validate that background knowledge can be effectively incorporated into SimplE embeddings to improve its performance. 

\begin{table}[t]
\scriptsize
\caption{Background Knowledge Used in Section~\ref{expert-knowledge-experiment-section}.}
\label{rules-table}
\begin{center}
\begin{tabular}{c|c}
Rule Number & Rule \\ \hline
1 &  \\
2 &  \\
3 &  \\
4 &  \\
5 &  \\
6 &  \\
7 &  \\
8 & 
\end{tabular}
\end{center}
\end{table}

\section{Conclusion}
We proposed a simple interpretable fully expressive bilinear model for knowledge graph completion. We showed that our model, called SimplE, performs very well empirically and has several interesting properties. For instance, three types of background knowledge can be incorporated into SimplE by tying the embeddings. In future, SimplE could be improved or may help improve relational learning in several ways including: 1- building ensembles of SimplE models as \cite{kadlec2017knowledge} do it for DistMult, 2- adding SimplE to the relation-level ensembles of \cite{wang2017multi}, 3- explicitly modelling the analogical structures of relations as in \cite{liu2017analogical}, 4- using \cite{dettmers2018convolutional}'s 1-N scoring approach to generate many negative triples for a positive triple (\citet{trouillon2016complex} show that generating more negative triples improves accuracy), 5- combining SimplE with logic-based approaches (e.g., with \cite{kazemi2018relnn}) to improve property prediction, 6- combining SimplE with (or use SimplE as a sub-component in) techniques from other categories of relational learning as \cite{rocktaschel2017end} do with ComplEx, 7- incorporating other types of background knowledge (e.g., entailment) into SimplE embeddings.

\bibliography{MyBib}
\bibliographystyle{named}

\end{document}