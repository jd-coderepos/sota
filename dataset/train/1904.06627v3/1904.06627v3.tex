\documentclass[10pt,twocolumn,letterpaper]{article}

\usepackage{cvpr}
\usepackage{times}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{amsmath}
\usepackage{amssymb}


\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{$\eta$}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 \usepackage{mathtools}
\usepackage{xcolor}
\usepackage{bbding}
\usepackage{pifont}
\usepackage{multirow}
\usepackage{amsthm}
\usepackage{enumitem}

\usepackage{algorithm}
\usepackage{listings}

\pdfoutput=1
\usepackage{pdfpages}
\usepackage{etoolbox}
\makeatletter
\AfterEndEnvironment{algorithm}{\let\@algcomment\relax}
\AtEndEnvironment{algorithm}{\kern2pt\hrule\relax\vskip3pt\@algcomment}
\let\@algcomment\relax
\newcommand\algcomment[1]{\def\@algcomment{\footnotesize#1}}
\renewcommand\fs@ruled{\def\@fs@cfont{\bfseries}\let\@fs@capt\floatc@ruled
  \def\@fs@pre{\hrule height.8pt depth0pt \kern2pt}\def\@fs@post{}\def\@fs@mid{\kern2pt\hrule\kern2pt}\let\@fs@iftopcapt\iftrue}
\makeatother




\newtheorem{lemma}{Lemma}

\newcommand*{\defeq}{\mathrel{\vcenter{\baselineskip0.5ex \lineskiplimit0pt
			\hbox{\scriptsize.}\hbox{\scriptsize.}}}=}


\definecolor{citecolor}{rgb}{0.133, 0.752, 0.133}
\usepackage[pagebackref=false,breaklinks=true,letterpaper=true,colorlinks,citecolor=citecolor,bookmarks=false]{hyperref}

\definecolor{Highlight}{HTML}{39b54a}  \newcommand{\cgaphl}[2]{
\fontsize{6pt}{1em}\selectfont{\textcolor{Highlight}{(${#1}$\textbf{#2})}}
}

\newlength\savewidth\newcommand\shline{\noalign{\global\savewidth\arrayrulewidth
  \global\arrayrulewidth 1pt}\hline\noalign{\global\arrayrulewidth\savewidth}}
\newcommand{\tablestyle}[2]{\setlength{\tabcolsep}{#1}\renewcommand{\arraystretch}{#2}\centering\footnotesize}

\newcommand{\reshl}[3]{
\tablestyle{1pt}{1} 
\begin{tabular}{z{16}y{18}}
{#1} &
\fontsize{7.5pt}{1em}\selectfont{~\hl{(${#2}$\textbf{#3})}}
\end{tabular}}

\newcommand\blfootnote[1]{\begingroup
  \renewcommand\thefootnote{}\footnote{#1}\addtocounter{footnote}{-1}\endgroup
}

\cvprfinalcopy 

\def\httilde{\mbox{\tt\raisebox{-.5ex}{\symbol{126}}}}

\ifcvprfinal\pagestyle{empty}\fi
\begin{document}
	
	
\title{Multi-Similarity Loss with General Pair Weighting \\for Deep Metric Learning}

\author{Xun Wang, Xintong Han, Weilin Huang$^*$, Dengke Dong, Matthew R. Scott\\
Malong Technologies, Shenzhen, China\\
Shenzhen Malong Artificial Intelligence Research Center, Shenzhen, China\\
{\tt\small \{xunwang,xinhan,whuang,dongdk,mscott\}@malong.com}
}

\maketitle
\begin{abstract}	
A family of loss functions built on pair-based computation have been proposed in the literature which provide a myriad of solutions for deep metric learning.
In this paper, we provide a general weighting framework for understanding recent pair-based loss functions. Our contributions are three-fold: (1) we establish a General Pair Weighting (GPW) framework, which casts the sampling problem of deep metric learning into a unified view of pair weighting through gradient analysis, providing a powerful tool for understanding recent pair-based loss functions; (2) we show that with GPW, various existing pair-based methods can be compared and discussed comprehensively, with clear differences and key limitations identified; (3) we propose a new loss called multi-similarity loss (MS loss) under the GPW, which is implemented in two iterative steps (i.e., mining and weighting). This allows it to fully consider three similarities for pair weighting, providing a more principled approach for collecting and weighting informative pairs.
Finally, the proposed MS loss obtains new state-of-the-art performance on four image retrieval benchmarks,
where it outperforms the most recent approaches, such as  ABE\cite{Kim_2018_ECCV} and HTL \cite{HTL}, by a large margin, {\it e.g.}, , and $80.9\% \rightarrow 88.0\%$ on In-Shop Clothes Retrieval dataset at Recall@$1$. Code is available at \url{https://github.com/MalongTech/research-ms-loss}
\blfootnote{Corresponding author: whuang@malong.com}

\end{abstract}

\section{Introduction}

\begin{figure}[t]
	\vspace{10pt}
	\centering
	\includegraphics[width=0.5\textwidth]{small_overview}
	\caption{\small The proposed multi-similarity loss is able to jointly measure the self-similarity and relative similarities of a pair, which allows it collect informative pairs by implementing iterative pair mining and weighting.}
	\label{overview}
	\vspace{-10pt}
\end{figure}
Metric learning aims to learn an embedding space, where the embedded vectors of similar samples are encouraged to be closer, while dissimilar ones are pushed apart from each other \cite{lowe1995similarity,mika1999fisher,xing2003distance}.
With recent great success of deep neural networks in computer vision, deep metric learning has attracted increasing attention,
and has been applied to various tasks, including image retrieval \cite{wohlhart2015learning,He_2018_CVPR,Grabner_2018_CVPR}, face recognition \cite{Wen2016},
zero-shot learning \cite{zhang2016zero,bucher2016improving,Yelamarthi_2018_ECCV}, visual tracking \cite{leal2016learning,tao2016siamese} and person re-identification \cite{Yu_2018_ECCV,in-defense}.

Many recent deep metric learning approaches are built on pairs of samples. Formally, their loss functions can be expressed in terms of pairwise cosine similarities in the embedding space{\footnote {For simplicity, we use a cosine similarity instead of Euclidean distance, by assuming an embedding vector is $L_2 $ normalized.}}. We refer to this group of methods as {\it pair-based} deep metric learning; and this family includes contrastive loss \cite{contrastive}, triplet loss \cite{Hoffer2015DeepML}, triplet-center loss \cite{He_2018_CVPR}, quadruplet loss \cite{quadruplet}, lifted structure loss \cite{lifted-structured-loss}, N-pairs loss \cite{n-pairs}, binomial deviance loss \cite{binomial}, histogram loss \cite{histogram}, angular loss \cite{angular}, distance weighted margin-based loss \cite{sampling}, hierarchical triplet loss (HTL) \cite{HTL}, \etc.
For these pair-based methods, training samples are constructed into pairs, triplets or quadruplets, resulting a polynomial growth of training pairs which are highly redundant and less informative.
This gives rise to a key issue for pair-based methods, where training with random sampling can be overwhelmed by redundant pairs, leading to slow convergence and model degeneration with inferior performance.

Recent efforts have been devoted to improving sampling schemes for pair-based metric learning techniques. For example, Chopra \etal \cite{contrass1} introduced a contrastive loss which discards negative pairs whose similarities are smaller than a given threshold. In triplet loss  \cite{Hoffer2015DeepML}, a negative pair is sampled by using a margin computed from the similarity of a randomly selected positive pair. Alternatively, lifted structure loss \cite{lifted-structured-loss} and N-pairs loss \cite{n-pairs} introduced new weighting schemes by designing a smooth weighting function to assign a larger weight to a more informative pair.
Though driven by different motivations, these methods share a common goal of learning from more informative pairs.
Thus, sampling such informative pairs is the key to pair-based deep metric learning, while precisely identifying these pairs is particularly challenging, especially for the negative pairs whose number is quadratic to the size of dataset.

In this work, we cast the sampling problem of deep metric learning into a general pair weighting formulation. We investigated various weighting schemes of recent pair-based loss functions, attempted to understand their insights more deeply, and identify key limitations of these approaches. 
We observed that a key factor that impacts pair weighting is to compute multiple types of similarities for a pair, which can be defined  as self-similarity and relative similarity, where the relative similarity is heavily dependent on the other pairs. 
Furthermore, we found that most existing methods only explore this factor partially, which limits their capability considerably. For example, contrastive loss \cite{contrastive} and binomial deviance loss \cite{binomial} only consider the cosine similarity of a pair, while triplet loss \cite{Hoffer2015DeepML} and lifted structure loss \cite{lifted-structured-loss} mainly focus on the relative similarity. We propose a multi-similarity loss which fully considers multiple similarities during sample weighting. The major contributions of this paper are summarized as follows.  
\begin{itemize}
\item[--] We establish a General Pair Weighting (GPW) framework, which formulates deep metric learning into a unified view of pair weighting. It provides a general formulation for understanding and explaining various pair-based loss functions through gradient analysis.
\item[--] We analyze the key factor that impacts pair weighting with GPW, where various pair-based methods can be analyzed comprehensively, with main differences and key limitations clearly identified. This allows us to define three types of similarities for a pair: a self-similarity and two relative similarities. The relative similarities are computed by comparing to other pairs, which are of great importance to existing pair-based methods. 
\item[--] We propose a new multi-similarity (MS) loss,  which is implemented using two iterative steps with sampling and weighting, as shown in Figure \ref{overview}. MS loss considers both self-similarity and relative similarities which enables the model to collect and weight informative pairs more efficiently and accurately, leading to boosts in performance.
\item[--] MS loss is evaluated extensively on a number of benchmarks for image retrieval,
where it outperforms current state-of-the-art approaches by a large margin, {\it e.g.}, improving recent  ABE \cite{Kim_2018_ECCV} with +5.0\% Recall@$1$ on CUB200, and HTL \cite{HTL} with +7.1\% Recall@$1$ on In-Shop Clothes Retrieval dataset.

\end{itemize}

\section{Related Work}


{\textbf{Classical pair-based loss functions.}} {\it Siamese} network \cite{contrastive} is a representative pair-based method that learns an embedding via contrastive loss. It encourages samples from a positive pair to be closer, and pushes samples from a negative pair apart from each other, in the embedding space.
Triplet loss was introduced in \cite{Hoffer2015DeepML} by using triplets as training samples. Each triplet consists of a positive pair and a negative pair by sharing the same anchor point. Triplet loss aims to learn an embedding space where the similarity of a negative pair is lower than that of a positive one, by giving a margin. Extended from triplet loss, quadruplets were also applied in recent work, such as histogram loss \cite{histogram}.

Recently, Song \etal \cite{lifted-structured-loss}  argued that both contrastive loss and triplet loss are difficult to explore full pair-wise relations between samples in a mini-batch. They proposed a lifted structure loss attempted to fully utilize such pairwise relations. However, the lifted structure loss only samples approximately an equal number of negative pairs as the positive ones randomly, and thus discards a large number of informative negative pairs arbitrarily. In \cite{binomial}, Dong \etal  proposed a binomial deviance loss by using a binomial deviance to evaluate the cost between labels and similarity, which emphasizes harder pairs. In this work, we propose a multi-similarity loss able to explore more meaningful pair-wise relations by jointly considering both self-similarity and the relative similarities. 

{\textbf{Hard sample mining.}} Pair-based metric learning often generates a large amount of pair-wise samples, which are highly redundant and include many uninformative samples. Training with random sampling can be overwhelmed by these redundant samples, which significantly degrade the model capability and also slows the convergence. Therefore, sampling plays a key role in pair-based metric learning.

The importance of hard negative mining has been discussed extensively \cite{semi-hard, smart-mining, sampling, HTL}. Schroff \etal \cite{semi-hard} proposed a semi-hard mining scheme by exploring semi-hard triplets, which are defined to have a negative pair farther than the positive one. However, such semi-hard mining method only generates a small number of valid semi-hard triplets, so that it often requires a large batch-size to generate sufficient semi-hard triplets, {\it e.g.}, 1800 as suggested in \cite{semi-hard}.
Harwood \etal \cite{smart-mining} provided a framework named smart mining to collect hard samples from the whole dataset, which suffers from off-line computation burden. Recently, Ge \etal \cite{HTL} proposed a hierarchical triplet loss (HTL) which builds a hierarchical tree of all classes, where hard negative pairs are collected via a dynamic margin.
Sampling matters in deep embedding learning was discussed in \cite{sampling}, and a {\it distance weighted sampling} was proposed to collect negative samples uniformly with respective to the pair-wise distance.
Unlike these methods which mainly focus on sampling or hard sample mining, we provide a more generalized formulation that casts sampling problem into general pair weighting.

{\textbf{Instance weighting.}} Instance weighting has been widely applied to various tasks. For example, Lin \etal \cite{focal_loss} proposed a focal loss that allows the model to focus on hard negative examples during training an object detector.
In \cite{chang2017active}, an active bias learning was developed to emphasize high variance samples in training a neural network for classification.
Self-paced learning \cite{kumar2010self}, which pays more attention on samples with a higher confidence, was explored to design noise-robust algorithms \cite{NIPS2014_5568}. These approaches \cite{focal_loss,jiang2018mentornet,chang2017active,kumar2010self} were developed for weighting individual instances that are only depended on itself (referred as self-similarity), while our method aims to compute both self-similarity and the relative similarities, 
which is a more complicated problem that requires to measure multiple sample correlations within a local data distribution.

\section{General Pair Weighting (GPW)}
\label{section-weighting}
In this section, we formulate the sampling problem of metric learning into a unified weighting view, and provide a General Pair Weighting (GPW) framework for analyzing various pair-based loss functions. 
\subsection{GPW Framework}
\label{subsection-weighting}
 Let $\vx_i \in \R^d$ be a real-value instance vector. Then we have an instance matrix $\mX \in \R^{m\times d}$, and a label vector  $\vy \in \{1, 2, \dots, C \}^m$ for the $m$ training samples respectively.  Then an instance  $\vx_i$ is projected onto a unit sphere in a $l$-dimension space by $ f(\cdot ; \vtheta) : \R^{d} \rightarrow S^{l}$, where $f$ is a neural network parameterized by $\vtheta$.
Formally, we define the similarity of two samples as $S_{ij} \defeq   <f(\vx_i; \vtheta)  , f(\vx_j; \vtheta)>$, where $<\cdot , \cdot>$ denotes dot product, resulting in an $m\times m $ similarity matrix $\mS$ whose element at $(i,j)$ is $S_{ij}$.

Given a {\it pair-based} loss $\mathcal{L}$, it can be formulated as a function in terms of $\mS$ and $\vy$: $\mathcal{L}(\mS, \vy)$. The derivative with respect to model parameters $\vtheta$ at the $t$-th iteration can be calculated as: 
\begin{align}
\begin{split}
	\label{gradient-eq}
	\frac{\partial\mathcal{L}(\mS, \vy)}{\partial \vtheta} \bigg|_{t} &{}=
	\frac{\partial\mathcal{L}({\mS, \vy})}{\partial \mS} \bigg|_{t} \quad
	\frac{\partial{\mS}}{\partial \vtheta} \bigg|_{t} \\
	&{}=
	\sum_{i=1}^{m}  \sum_{j=1}^{m}\frac{\partial\mathcal{L} (\mS, \vy)}{\partial S_{ij}} \bigg|_{t}
	\quad
	\frac{\partial{S_{ij}}}{\partial \vtheta} \bigg|_{t} 	.
\end{split}
\end{align}
 Eqn~\ref{gradient-eq} is computed for optimizing model parameters $\vtheta$ in deep metric learning. In fact, Eqn~\ref{gradient-eq} can be reformulated into a new form for pair weighting through a new function $\mathcal{F}$, whose gradient w.r.t. $\vtheta$ at the $t$-th iteration is computed exactly the same as Eq.~\ref{gradient-eq}. $\mathcal{F}$ is formulated as below:
 
\begin{equation}
\label{weight0}
\mathcal{F}(\mS, \vy)= \sum_{i=1}^{m}  \sum_{j=1}^{m}\frac{
\partial\mathcal{L}(\mS, \vy)}{\partial S_{ij}} \bigg|_{t}  S_{ij}.
\end{equation}
Note that $\frac{\partial\mathcal{L}(\mS, \vy)}{\partial S_{ij}} \big|_{t}$  is regarded as a \textbf{constant scalar} that not involved in the gradient of $\mathcal{F}$ w.r.t. $\vtheta$.

  Since the central idea of deep metric learning is to encourage positive pairs to be closer, and push negatives apart from each other. For a pair-based loss $\mathcal{L}$, we can assume $\frac{\partial\mathcal{L}(\mS, \vy)}{\partial S_{ij}} \big|_{t} \geqslant 0$ for a negative pair, and $\frac{\partial\mathcal{L}(\mS, \vy)}{\partial S_{ij}} \big|_{t} \leqslant 0$ for a positive pair. Thus, $\mathcal{F}$ in Eqn \ref{weight0} can be transformed into the form of pair weighting as follows:
\begin{align}
\begin{split}
\label{weight1}
\mathcal{F} &{}= \sum_{i=1}^{m}\left( \sum_{\vy_j \neq \vy_i}^{m}
\frac{\partial\mathcal{L}(\mS, \vy)}{\partial S_{ij}} \bigg|_{t}  S_{ij}
+ \sum_{\vy_j = \vy_i}^{m} \frac{\partial\mathcal{L}(\mS, \vy)}{\partial S_{ij}} \bigg|_{t}  S_{ij} \right) \\
&{}=  \sum_{i=1}^{m}
\left( \sum_{\vy_j \neq \vy_i}^{m} w_{ij}  S_{ij} - \sum_{\vy_j = \vy_i}^{m} w_{ij} S_{ij} \right),
\end{split}
\end{align}
where $w_{ij} = \bigg| \frac{\partial\mathcal{L}(\mS, \vy)}{\partial S_{ij}} \big|_{t}  \bigg|$.


As indicted in Eqn~\ref{weight1}, a pair-based method can be formulated as weighting of pair-wise similarities, where the weight for pair $\{\vx_i, \vx_j\}$ is $w_{ij}$.
Learning with a pair-based loss function $\mathcal{L}$ is now transformed from Eq.~\ref{gradient-eq} into designing weights for pairs. It is a general pair weighting (GPW) formulation, and sampling is only a special cases. 


\subsection{Revisit Pair-based Loss Functions}
\label{subsection-rethinking}
To demonstrate the generalization ability of GPW framework, we revisit four typical pair-based loss functions for deep metric learning: contrastive loss \cite{contrastive},ï¼Œ triplet loss \cite{Hoffer2015DeepML}, binomial deviance loss \cite{binomial} and lifted structure loss  \cite{lifted-structured-loss}. 

{\bf Contrastive loss.} Hadsell \etal \cite{contrastive} proposed a Siamese network, where a contrastive loss was designed to encourage positive pairs to be as close as possible, and negative pairs to be apart from each other over a given threshold, $\lambda$:
\begin{equation}
\label{contrast-loss}
\mathcal{L}_{contrast} \defeq (1-\mathcal{I}_{ij}) [S_{ij} - \lambda ]_+ - \mathcal{I}_{ij}S_{ij} ,
\end{equation}
where $ \mathcal{I}_{ij}=1$ indicates a positive pair, and $0$ for a negative one.
By computing partial derivative with respect to $S_{ij}$ in Eqn \ref{contrast-loss}, we can find that all positive pairs and hard negative pairs with $S_{ij} > \lambda $ are assigned with an equal weight. This is a simple and special case of our pair weighting scheme, without considering any difference between the selected pairs.

{\bf Triplet loss.}
In \cite{Hoffer2015DeepML}, a triplet loss was proposed to learn a deep embedding, which enforces the similarity of a negative pair to be smaller than that of a randomly selected positive one over a given margin $\lambda$:
\begin{equation}
\label{triplet-eq}
\mathcal{L}_{triplet} \coloneqq [S_{an} - S_{ap} + \lambda]_+,
\end{equation}
where $S_{an}$ and $S_{ap}$ denote the similarity of a negative pair $\{\vx_a, \vx_n\}$, and a positive pair $\{\vx_a, \vx_p\}$, with an anchor sam, e$pl\vx_a$.
According to the gradient computed for Eqn \ref{triplet-eq}, a triplet loss weights all pairs equally on the valid triplets which are selected by $ S_{an} + \lambda > S_{ap} $, while the triplets with $ S_{an} + \lambda \leqslant S_{ap} $ are considered as less informative, and are discarded. Triplet loss is different from contrastive loss on pair selection scheme, but both methods consider all the selected pairs equally, which limits their ability to identify more informative pairs among the selected ones.

{\bf Lifted Structure Loss.} Song \etal \cite{lifted-structured-loss} designed a lifted structure loss, which was further improved to  a more generalized version in \cite{in-defense}. It utilizes all the positive and negative pairs among the mini-batch as follows:
\begin{equation}
	\label{lift-eq}
	\mathcal{L}_{lifted} \defeq \sum_{i=1}^m \bigg[{ \log \sum_{\vy_k=\vy_i } e^ { \lambda -S_{ik}}}  +
	\log  \sum_{\vy_k \neq \vy_i } e^ {S_{ik}}
	\bigg]_+,
\end{equation}
where $\lambda$ is a fixed margin.

In Eqn \ref{lift-eq}, when the hinge function of an anchor $\vx_i$
returns a non-zero value, we can have a weight value,  $w_{ij}$, for the pair
$\{\vx_i, \vx_j\}$,  by differentiating $\mathcal{L}_{lifted}$ on $S_{ij}$, according to Eqn \ref{weight1}. Then the weight for a positive pair is computed as:
\begin{equation}
\label{positive-eq}
	w^{+}_{ij}=  \frac{e^{\lambda-S_{ij}} }{\sum_{\vy_k=\vy_i} e^{\lambda-S_{ik}}} = \frac{1 }{\sum_{\vy_k=\vy_i} e^{S_{ij}-S_{ik}}},
\end{equation}
and the weight for a negative pair is:
\begin{equation}
\label{negative-eq}
w^{-}_{ij}=  \frac{e^{S_{ij}} }{\sum_{\vy_k \neq \vy_i} e^{S_{ik}}} = \frac{1 }{\sum_{\vy_k \neq \vy_i} e^{S_{ik} - S_{ij}}} .
\end{equation}
Eqn \ref{positive-eq} shows that the weight for a positive pair is determined by its relative similarity, measured by comparing it to the remained positive pairs with the same anchor. The weight for a negative pair is computed similarly based on Eqn \ref{negative-eq}.

{\bf Binomial Deviance Loss.}
 Dong \etal introduced binomial deviance loss in \cite{binomial}, which utilizes softplus function instead of hinge function in contrastive loss:
\begin{align}
\begin{split}
\label{bin-equation}
\mathcal{L}_{binomial} = \sum_{i=1}^m  \bigg\{&{}\frac{1}{{P_i}}{\sum_{\vy_j=\vy_i } \log \left[1 + e^{\alpha (\lambda - S_{ij})}
\right] }  + \\
&{}  \frac{1}{N_i} \sum_{\vy_j \neq \vy_i} \log \left[1+
e^{\beta (S_{ij} - \lambda)}\right] \bigg\},
\end{split}
\end{align}
where ${P_i}$ and ${N_i}$ denote the numbers of positive pairs and negative pairs with anchor $\vx_i$, respectively. $\lambda$, $\alpha$, $\beta$ are fixed hyper-parameters.

The weight for pair $\{\vx_i, \vx_j\}$ is $w_{ij}$  in Eqn \ref{gradient-eq}, which can be derived from differentiating $\mathcal{L}_{binomial}$ on $S_{ij}$ as:
\begin{align}
\label{bin-weight-eq}
\begin{split}
	w^{+}_{ij} &{}= \frac{1}{P_i} \frac{\alpha e^{\alpha\left(\lambda - S_{ij} \right)}}
		{1 + e^{ \alpha\left(\lambda - S_{ij} \right) }},  \quad   \quad  \vy_j = \vy_i\\
	w^{-}_{ij} &{}= \frac{1}{N_i} \frac{\beta e ^{ \beta \left(S_{ij} - \lambda \right)}}{1 + e^{\beta \left(S_{ij} - \lambda\right)}}, \quad  \quad \vy_j\neq\vy_i
\end{split}
\end{align}

As can be found, binomial deviance loss is a soft version of contrastive loss. In Eqn \ref{weight1}, a negative pair with a higher similarity is assigned with a larger weight, which means that it is more informative, by distinguishing two similar samples from different classes (which form a negative pair).

\section{Multi-Similarity Loss}
In this section, we first illustrate three types of similarities that carries the information of pairs, and then design a multi-similarity loss that weighting pairs based on full information.

\subsection{Multiple Similarities}

\begin{figure*}[t]
	\vspace{-5pt}
	\centering
	\includegraphics[width=\textwidth]{case.pdf}
	
	\caption{\textbf{Three types of similarities of a negative pair}. From left to right, \textbf{S}: its cosine similarity to the anchor; \textbf{P}: its relative similarity compared with the positive pair; \textbf{N}: its relative similarity compared with other negative pairs. From top to bottom, the similarities becomes higher. Their weights should be larger since they contains more information to improve the current model.}
	\label{cases}
\end{figure*}

\label{section-information}
\begin{table*}[htp]
\tablestyle{11pt}{1.0}
	\begin{center}
		\begin{tabular}{l|c|c|c|c|c|c|c|c|c}
			& Contrastive & Binomial & Triplet & Histogram 
			& N-pairs & Lifted Structure & BinLifted & NCA & \textbf{MS} \\\shline
			\emph{Similarity-S} & \ding{51} &\ding{51} & \ding{55}& \ding{55} & \ding{55} & \ding{55} & \ding{51} & \ding{55}& \ding{51} \\ \hline
			
			\emph{Similarity-P} & \ding{55}&  \ding{55}& \ding{51}& \ding{51}   & \ding{55} & \ding{55} & \ding{55} &\ding{51} & \ding{51}\\ \hline	 
			\emph{Similarity-N} & \ding{55} & \ding{55} & \ding{55}& \ding{55}   & \ding{51} & \ding{51} & \ding{51} & \ding{51} & \ding{51} 
		\end{tabular}
		\vspace{2pt}
		\caption{\textbf{The types of similarities considered by the pair-based methods on weighting negative pairs.} In the table, we can find that most existing pair-based methods only consider the three types of similarities partly, while our MS loss weights the negative pairs by considering all the three perspectives comprehensively. }
		\label{comparasion}	
	\end{center}
\vspace{-10pt}
\end{table*}

Based on GPW, we can find that most pair-based approaches weight the pairs based on either self cosine similarities or relative similarities compared with other pairs. Specifically, we take one negative pair for example and summarize three types of similarities as below. (The analysis of one positive pair is in a similar way.)

{\bf Similarity-S: Self-similarity} defined as the cosine similarity between the negative sample and the anchor is of the most importance. A negative pair with a larger \emph{self similarity} means that it is harder to distinguish two paired samples from different classes. Such pairs are referred as hard negative pairs, which are more informative and meaningful to learn discriminative features. 
Contrastive loss and binomial deviance loss are based on this criterion. In the left of Figure \ref{cases}, the weight of the negative pair in Eq n \ref{bin-weight-eq} increases, since the pair's \emph{self similarity} grows larger as the pair becomes closer.

In fact, self-similarity is not able to fully evaluate the value of a negative pair solely, and correlations of other pairs also make significant impact to weight assignment. Thus, We further introduce two types of relative similarities by considering all other pairs to exploit the potentiality of each pair.

{\bf Similarity-P: Positive relative similarity} is computed by considering the relationship with positive pairs. Specifically, we define it as the differences of its own cosine similarity and that of other positive pairs. In the middle of Figure \ref{cases}, the \emph{Similarity-P} stays the same, while \emph{Similarity-P} increases as the positive pair becomes faraway. Obviously, such case brings more challenge of retrieve the right sample for the anchor, as the negative pair is more closer than the positive. Thus, the negative pair should assigned more weight to learn an embedding. Triplet loss and histogram loss are based on \emph{Similarity-P}.

{\bf Similarity-N: Negative relative similarity} is the differences between its cosine similarity and those of other negative pairs. In the right of Figure \ref{cases}, the \emph{Similarity-N} of the negative pair becomes larger, while its self-similarity is fixed. Indeed, when the \emph{Similarity-N} become larger, the pair carries more valuable information compared with other negatives. Thus, to learn a good embedding, we should focus weights on such pairs. Lifted structure, N-pairs and NCA methods assign weights for each negative pair according to \emph{Similarity-N}.

With the GPW, we analyze the weighting schemes of most existing pair-based approaches, and summarize the similarities they depends on in weighting (in Table \ref{comparasion}). We observe that these commonly used pair-based methods only rely on partial similarities, which cannot cover the information contained in current pair. 
For example, lifted structure method only considers \emph{N-similarity}, compares current pair with other negative pairs for weighting. The weight of current pair will be unchanged when the \emph{S-similarity} becomes larger (in the left of Fig$.$ \ref{cases}) or when negative samples depart from the anchor (in the right of Fig$.$ \ref{cases}). This conclusion can also be verified directly from Eqn \ref{negative-eq}, which only depends on the term: $\sum_{\vy_k=\vy_i} e^{S_{ij}-S_{ik}}$. Thus, to properly weighting one pair, not only the \emph{S-similarity} should be taken into account, but also the \emph{P-similarity} and \emph{N-similarity}.
 
While a weighting or sampling method based on each individual similarity has been explored previously, to the best of our knowledge, none of existing pair-based methods assign weights on pairs considering all the three similarities. In the following, we propose our MS loss, whose weighting strategy is designed by taking a general consideration of all the three types of similarities.

\subsection{Multi-Similarity Loss}
Unlike sampling or weighting schemes developed for classification and detection tasks (\cite{chang2017active,focal_loss}), where the weight of an instance is computed individually based on itself, it is difficult to precisely measure the informativeness of a pair based on itself individually in deep metric learning. Relationships with relevant samples or pairs should also be considered to make the measurement more accurate.  

However, to the best our knowledge, none of the existing pair-based methods can consider all of the three similarities simultaneously (in table \ref{comparasion}). To this end, we propose a Multi-Similarity (MS) loss, which consider all three perspectives by implementing a new pair weighting scheme using two steps: mining and weighting. (i) informative pairs are first sampled by measuring {\it Similarity-P}; and then (ii) the selected pairs are further weighted using {\it Similarity-S} and {\it Similarity-N} jointly. Details of the two steps are described as follows.

{\bf Pair mining.}  We first select informative pairs by computing {\it Similarity-P}, which measures the relative similarity between negative$\leftrightarrow$positive pairs having a same anchor.
Specifically, a negative pair is compared to the {\it hardest} positive pair (with the lowest similarity), while a positive pair is sampled by comparing to a negative one having the largest similarity. Formally, assume $\vx_i$ is an anchor, a negative pair  $\{\vx_i, \vx_j\}$ is selected if $S_{ij}$ satisfies the condition:
\begin{equation}
\label{eq-select-neg}
S^{-}_{ij} > \min_{\vy_k = \vy_i} S_{ik} - \epsilon,
\end{equation}
where $\epsilon$ is a given margin.

If $\{\vx_i, \vx_j\}$ is a positive pair, the condition is:
\begin{equation}
\label{eq-select-pos}
S^{+}_{ij} < \max_{\vy_k \neq \vy_i} S_{ik} + \epsilon.
\end{equation}

For an anchor $\vx_i$, we denote the index set of its selected positive and negative pairs as 
$\mathcal{P}_i$ and $\mathcal{N}_i$  respectively.
Our hard mining strategy is inspired by large margin nearest neighbor (LMNN) \cite{LMNN}, a traditional distance learning approach which targets to seek an embedding space where neighboring positive points are encouraged to have the same class label with the anchor.
The negative samples that satisfy Eqn \ref{eq-select-neg} are approximately identical to  {\it impostors} defined in LMNN \cite{LMNN}. 

{\bf Pair weighting.}
Pair mining with \emph{Similarity-P} can roughly select informative pairs, and discard the less informative ones. We develop a {soft} weighting scheme that further weights the selected pairs more accurately, by considering both {\it Similarity-S} and {\it Similarity-N}. Our weighting mechanism is inspired by binomial deviance loss (considering {\it similarity-S}) and lifted structure loss (using {\it Similarity-N}). Specifically, given a selected negative pair $\{\vx_i, \vx_j\} \in \mathcal{N}_i$, its weight $w_{ij}^-$ can be computed as:
\begin{align}
	\label{eq-neg}
	\begin{split}
	w^{-}_{ij} &{}=  \frac{ 1 }{ e^{\beta \left(\lambda - S_{ij} \right)}  + \sum\limits_{k \in \mathcal{N}_i} e^{\beta \left(S_{ik} - S_{ij} \right)}} \\
	 	&{}= \frac{ e^{\beta \left(S_{ij} - \lambda \right)} }{1 + \sum\limits_{k \in \mathcal{N}_i} e^{\beta \left(S_{ik} - \lambda \right)}}.
	\end{split}
\end{align}
and the weight $w_{ij}^+$ of a positive pair $\{\vx_i, \vx_j\} \in \mathcal{P}_i$ is:
\begin{align}
\label{eq-pos}
\begin{split}
w^{+}_{ij} &{}=  \frac{ 1 }{ e^{ - \alpha \left(\lambda - S_{ij} \right)}  + \sum\limits_{k \in \mathcal{P}_i} e^{ - \alpha \left(S_{ik} - S_{ij} \right)}},
\end{split}
\end{align}
where $\alpha, \beta, \lambda$ are hyper-parameters as in Binomial deviance loss (Eqn \ref{bin-equation}).

In Eqn \ref{eq-neg}, the weight of a negative pair is computed jointly from its self-similarity by $e^{\beta \left(\lambda - S_{ij} \right)}$ - {\it Similarity-S}, and its relative similarity - {\it Similarity-N}, by comparing to its negative pairs. Similar rules are applied for computing the weight for a positive pair, as in Eqn \ref{eq-pos}. With these two considerations, our weighting scheme updates the weights of pairs dramatically to the violation of its self-similarity and relative similarities. 

The weight computed by Eqn \ref{eq-neg} and Eqn \ref{eq-pos} can be considered as a combination of the weight formulations of binomial deviance loss and lifted structure loss. However, it is non-trivial to combine both functions in an elegant and suitable manner. 
We will compare our MS weighting with an average weighting scheme of binomial deviance (Eqn \ref{bin-weight-eq}) and lifted structure (Eqn \ref{negative-eq}), denoted as {\it BinLifted}. We demonstrate by experiments that direct combination of them can not lead to performance improvement (as shown in ablation study). 

Finally, we integrate pair mining and weighting scheme into a single framework, and provide a new pair-based loss function - multi-similarity (MS) loss, whose partial derivative with respect to $S_{ij}$ is the weight defined in Eqn \ref{eq-neg} and Eqn \ref{eq-pos}. Our MS loss is formulated as,
\begin{equation}
\begin{split}
	\label{eq-MS}
	\mathcal{L}_{MS} = \frac{1}{m}\sum_{i=1}^m  \bigg\{\frac{1}{\alpha}  { \log \big[1 + \sum_{k  \in \mathcal{P}_i } e^{-\alpha (S_{ik} - \lambda)}}\big]  \\
	+ \frac{1}{\beta }  { \log \big[1+ \sum_{k \in \mathcal{N}_i}
		 e^{\beta (S_{ik} - \lambda)} \big]} \bigg\}.
\end{split}   
\end{equation}
where $\mathcal{L}_{MS}$ can be minimized with gradient descent optimization, by simply implementing the proposed iterative pair mining and weighting.


\section{Experiments}

\label{experiments-section}
Our MS method is implemented by PyTorch. For network architecture, we use the Inception network with batch normalization \cite{batchnorm} pre-trained on ILSVRC 2012-CLS \cite{ILSVRC15},  and fine-tuned it for our task. We add a FC layer on the top of the network following the global pooling layer.
All the input images are cropped to $224 \times 224$.  Random crop with random horizontal flip is used for training, and single center crop for testing. Adam optimizer was used for all experiments.

We conduct experiments on four standard datasets:  CUB200 \cite{CUB_200_2011}, Cars-196 \cite{car-196}, Stanford Online Products (SOP) \cite{lifted-structured-loss} and In-Shop Clothes Retrieval (In-Shop) \cite{DeepFashion}.
We follow the data split protocol applied in \cite{lifted-structured-loss}.
For the CUB200 dataset, we use the first 100 classes
with 5,864 images for training, and the remaining 100 classes with 5,924
images for testing. 
The Cars-196 dataset is composed of 16,185 images of cars from 196 model categories.
The first 98 model categories are used for training, with the rest for testing.
For the SOP dataset, we use 11,318 classes for training, and 11,316 classes for testing. 
For the In-Shop dataset, 3,997 classes with 25,882 images are used for training.
The test set is partitioned to a query set with 14,218 images of 3,985 classes, and a gallery set having  3,985 classes with 12,612 images.

For every mini-batch, we randomly choose a certain number of classes, and then randomly sample $M$ instances from each class with $M = 5$ for all datasets in all experiments. $\epsilon$ in Eqn \ref{eq-select-neg} and Eqn \ref{eq-select-pos} is set to $0.1$  and the hyper-parameters in Eqn \ref{eq-MS} are: $\alpha=2, \lambda=1, \beta=50$, by following \cite{histogram}. 
Our method is evaluated on image retrieval task by using the standard performance metric: Recall$@K$.

\begin{table}[t]
\tablestyle{9pt}{1.1}
	\begin{tabular}{ll|cccc}
		Recall$@K$ (\%) &	  &1 & 2 & 4  & 8\\ \shline
		Binomial	 &S & 71.9& 80.0& 86.4  &91.0    \\  
		LiftedStruct$^*$&N &  69.7&  79.3&  86.2  & 91.0  \\ 
		MS mining		&P  & 67.0& 77.4& 84.7& 90.0\\ \hline
		BinLifted   &SN & 70.4& 79.5& 86.2& 91.1 \\ 
		MS weighting&SN & 73.2& 81.5& 87.6& 92.6 \\ \hline
		Binomial$_{m}$ & SP & 74.6& 83.8& 89.7& 94.1\\
		LiftedStruct$_{m}^{*}$ & NP& 72.2& 81.7& 88.0& 92.4\\ \hline
		MS 		&SNP & \bf 77.3& \bf 85.3& \bf 90.5& \bf 94.2 \\ 
	\end{tabular}
	\vspace{1pt}
	\caption{Results on Cars-196 using \textbf{different pair-based methods}. The first column lists the methods and the types of similarities considered in their weighting. Embedding size is set to 64. Subscript ${m}$ denotes applying our MS mining step before weighting.} 
	\label{tab-ablation}
	\vspace{-10pt}
\end{table}



\subsection{Ablation Study}
\label{ablation}

To  demonstrate the importance of weighting the pairs from multi-similarities, we conduct an ablation study on Cars-196 and results are shown in Table \ref{tab-ablation}.
We describe LiftedStruct$^*$, MS mining and MS weighting here, other methods have already been mentioned in section \ref{section-weighting}.  

{\bf{LiftedStruct$^*$.} }   Lifted structure loss is easy to get stuck in a local optima, resulting in poor performance. To evaluate the efficiency of three similarities more clearly and fairly, we make a minor modification to the lifted structure loss, allowing it to employ {\it Similarity-N} more effectively:
\begin{equation}
\small
\label{eq-lift*}
\mathcal{L}_{lift*} = \frac{1}{m}\sum_{i=1}^m  \bigg\{\frac{1}{\alpha}  { \log  \sum_{\vy_k = \vy_i } e^{-\alpha S_{ik}}}  + 
 \frac{1}{\beta}  { \log \sum_{\vy_k \neq \vy_i}
	e^{\beta S_{ik}}} \bigg\}, 
\end{equation} 
where $\alpha=2$, $\beta=50$. This modification is motivated to make lift structure loss more focus on informative pairs, especially the hard negative pairs, and allows it to get rid of the side effect of enormous easy negative pairs. We found that this modification can boost the performance of lifted-structure loss empirically, e.g., with an over 20\%  improvement of Recall@1 on the CUB200 .

{\bf MS mining.} To investigate the impact of each component of MS Loss, we evaluate the performance of MS mining individually, where the pairs selected into $\mathcal{N}_i$ and $\mathcal{P}_i$ are assigned with an equal weight.

{\bf MS weighting.} Similarly, MS weighting scheme is also evaluated individually without the mining step in the ablation study, allowing us to analyze the effect of each similarity more perspicaciously. In MS weighting, each pair in a mini-batch is assigned with a non-zero weight, according to the weighting strategy described in Eqn \ref{eq-neg} and Eqn \ref{eq-pos}.
 
With the performance reported in Table \ref{tab-ablation}, we analyze the effect of each similarity as below:

{\it Similarity-S:} A cosine self-similarity is of the most importance. Binomial deviance loss, based on the {\it Similarity-S}, achieves the best performance by using a single similarity. Moreover, our MS weighting outperforms LiftedStruct$_m^*$ by $69.7\% \rightarrow 73.2\%$ at recall@1, and  Binomial$_m$ also improves the recall@1 with $67.0\% \rightarrow74.6\%$ over the MS mining,  by adding the {\it Similarity-S} into their weighting schemes. 

{\it Similarity-N:} Relative similarities are also helpful to measuring the importance of a pair more precisely. With {\it Similarity-N}, our MS weighting increases the Recall@1 by 1.3\% over Binomial ($71.9\% \rightarrow73.2\%$). Moreover, with {\it Similarity-N}, LiftedStruct$_m^*$ obtains a significant performance improvement over MS sampling ($ 67\%\rightarrow72.2\%$), by considering both {\it Similarity-P} and {\it Similarity-N}.

{\it Similarity-P:} As shown in Table \ref{tab-ablation}, by adding a mining step based on {\it Similarity-P}, the performances of LiftedStruct$^*$, Binomial and MS weighting are consistently improved by a large margin. For instance, Recall@1 of Binomial is increased by nearly 3\%: $71.9\% \rightarrow 74.6\%$.  

Finally, the proposed MS loss achieves the best performance among these methods, by exploring multi-similarities for pair mining and weighting. However, it is critical to integrate the three similarities effectively into a single framework where the three similarities can be fully explored and optimized jointly by using a single loss function. For example, BinLifted, which uses a weighting scheme considering both {\it similarities-S} and {\it similarities-N}, has lower performance than that of single Binomial, since it implements a simple and straightforward combination of Binomial and LiftedStruct$_m^*$. More discussions on the difference between our MS weighting and the direct combination are presented in Supplementary Material. 


\begin{table*}[t]
    \tablestyle{10pt}{1.1}
	\begin{center}
		\begin{tabular}{l|cccccc|cccccc}
			& \multicolumn{6}{c}{CUB-200-2011}  &\multicolumn{6}{c}{Cars-196}\\
			Recall$@K$  (\%) & 1 & 2 & 4 & 8 & 16 & 32 & 1 & 2 & 4 & 8 & 16 & 32\\ \shline
			{Clustering $^{64}$\cite{struct-clustering}}  &48.2 & 61.4 & 71.8 & 81.9 & - & - & 58.1 & 70.6 & 80.3 & 87.8 & - & -\\ 
			{ProxyNCA$^{64}$ \cite{proxyloss}} &49.2 & 61.9 & 67.9 & 72.4 & - & - & 73.2 & 82.4 & 86.4 & 87.8 & - & -\\
			{Smart Mining$^{64}$ \cite{smart-mining}} &49.8 & 62.3 & 74.1 & 83.3 & - & - & 64.7 & 76.2 & 84.2 & 90.2 & - & -\\ 
			{Margin$^{128}$ \cite{sampling}}& 63.6& 74.4& 83.1& 90.0& 94.2 & - & 79.6& 86.5& 91.9& 95.1& 97.3 & - \\
			HDC$^{384}$ \cite{struct-clustering}& 53.6 & 65.7 & 77.0 & 85.6 & 91.5 & 95.5 & 73.7 & 83.2 & 89.5 & 93.8 & 96.7 & 98.4\\ 
			HTL$^{512}$ \cite{HTL} & 57.1& 68.8& 78.7& 86.5& 92.5& 95.5 & 81.4& 88.0& 92.7& 95.7& 97.4& \bf{99.0} \\\hline
			ABIER$^{512}$ \cite{bier}&57.5 &68.7 &78.3 &86.2 &91.9 &95.5 &82.0 &89.0 &93.2 &96.1 &97.8 &98.7\\
			ABE$^{512}$ \cite{Kim_2018_ECCV}  & 60.6 & 71.5 & 79.8 & 87.4 & - & - & \bf 85.2 & \textbf{90.5} & \textbf{94.0} & 96.1 & - & -\\
\hline 
			MS$^{64}$& 57.4& 69.8&  80.0&  87.8& 93.2& 96.4 & 77.3& 85.3& 90.5& 94.2& 96.9& 98.2\\ 
			MS$^{512}$& \bf65.7& \bf77.0& \bf86.3& \bf91.2& \bf95.0& \bf97.3& 84.1& 90.4 & \bf94.0& \bf96.5& \bf98.0& 98.9\\
\end{tabular}
		\vspace{3pt}
		\caption{\textbf{Recall@$K(\%)$ performance on CUB200 and Cars-196.} Superscript denotes embedding size. ABIER \cite{bier} and ABE \cite{Kim_2018_ECCV} are ensemble methods.}
		\label{cub-car-table}
		\vspace{-15pt}
	\end{center}
\end{table*}
\subsection{On Embedding Size}
\begin{figure}[htp]
	\vspace{-10pt}
	\centering
	\includegraphics[width=0.5\textwidth]{dim}
	\caption{Results on the Cars-196 dataset using \textbf{different embedding sizes} of our MS loss. Larger embedding size can considerably improve recall@1, while embedding sizes larger than 512 are not necessary.}
	\label{fig-embeding-size}
\end{figure} 
By following \cite{semi-hard}, we study the performance of MS loss with varying embedding sizes $\{64, 128, 256, 512, 1024\}$. As shown in Figure \ref{fig-embeding-size}, the performance is increased consistently with the embedding dimension except at  1024. This is different from lifted structure loss, which achieves its best performance at 64 on the Cars-196 dataset  \cite{lifted-structured-loss}. 

\begin{table}[t]
    \tablestyle{7.5pt}{1.1}
	\begin{center}
		\begin{tabular}{l|cccccc}
			Recall$@K$ (\%) & 1 & 10 & 20 & 30 & 40 & 50\\ \shline
			FashionNet$^{4096}$ \cite{DeepFashion}&53.0 & 73.0 & 76.0 & 77.0 & 79.0 & 80.0 \\
			HDC$^{384}$ \cite{struct-clustering}& 62.1 & 84.9 & 89.0 & 91.2 & 92.3 & 93.1\\	 
			HTL$^{128}$ \cite{HTL} & 80.9& 94.3& 95.8& 97.2& 97.4& 97.8\\\hline
			ABIER$^{512}$ \cite{bier}  & 83.1 & 95.1 & 96.9 & 97.5 & 97.8 & 98.0\\	
			ABE$^{512}$ \cite{Kim_2018_ECCV} & 87.3 & 96.7 & 97.9 & 98.2 & 98.5 & 98.7\\ 
			\hline
			{MS}$^{128}$  & 88.0& 97.2& 98.1& 98.5& 98.7& 98.8\\
			{MS}$^{512}$   &\bf89.7 &\bf97.9& \bf98.5& \bf98.8 & \bf99.1 & \bf99.2\\
		\end{tabular}
		\caption{\textbf{Recall@$K(\%)$ performance on In-Shop.}}
		\label{Shop-table}
		\vspace{-10pt}
	\end{center}
\end{table}


\subsection{Comparison with State-of-the-Art}
\begin{table}[htp]
    \tablestyle{12pt}{1.1}
	\begin{center}
		\begin{tabular}{l|cccc}
			Recall$@K$ (\%)& 1 & 10 & 100 & 1000\\ \shline
			{Clustering $^{64}$\cite{struct-clustering}}  & 67.0 & 83.7 & 93.2 & -\\
			{ProxyNCA$^{64}$} \cite{proxyloss} & 73.7 & -& -& -\\
			{Margin$^{128}$ \cite{sampling}} & 72.7 & 86.2 & 93.8 & 98.0\\
			HDC$^{384}$ \cite{struct-clustering}& 69.5 & 84.4 & 92.8 & 97.7 \\	
			HTL $^{512}$ \cite{HTL} & 74.8& 88.3& 94.8& 98.4\\\hline
			ABIER$^{512}$ \cite{bier}  & 74.2 & 86.9 & 94.0 & 97.8 \\	
			ABE$^{512}$ \cite{Kim_2018_ECCV} &76.3 & 88.4 & 94.8 & 98.2\\ 
			\hline
			{MS}$^{64}$   & 74.1& 87.8& 94.7& 98.2 \\
			{MS}$^{128}$   & 76.6& 89.2& 95.2& 98.4\\
			{MS}$^{512}$   & \bf  78.2& \bf  90.5& \bf  96.0& \bf  98.7 \\
\end{tabular}
		\vspace{4pt}
		\caption{\textbf{Recall@$K(\%)$ performance on SOP.}}
		\label{sop-table}
		\vspace{-10pt}
	\end{center}
\end{table}

We further compare the performance of our method with the state-of-the-art techniques on image retrieval task.
As shown in Table \ref{cub-car-table}, our MS loss improves Recall@1 by 7\%  on the CUB200, and 4\% on the Cars-196 over Proxy-NCA at dimension 64.  Compared with ABE employing an embedding size of 512 and attention modules, our MS loss achieves a higher Recall@1 by +5\% improvement at the same dimension on the CUB200.
On the Cars-196, our MS loss obtains the second best performance in terms of Recall@1, while the best results are achieved by ABE, which applies an ensemble method with a much heavier model. Moreover, on the remaining three datasets, our MS loss is of much stronger performance than ABE. 

In Table \ref{Shop-table} and \ref{sop-table}, our MS loss outperforms Proxy-NCA by 0.4\% and Clustering by 7\% at the same embedding size of 64. Furthermore, when compared with ABE, MS loss increases Recall@1 by 1.9\%  and  2.7\% on the SOP and In-Shop respectively. Moreover, even with much compact embedding features of 128 dimension, our MS loss has already surpassed all existing methods, which utilize much higher dimensions of 384, 512 and 4096.

To summarize, on both fine-grained datasets like Cars-196 and CUB200, and large-scale datasets with enormous categories like SOP and In-Shop, our method achieves new state-of-the-art or comparable performance, even taking those methods with ensemble techniques like ABE and BIER into consideration.  

\section{Conclusion}
We have established a General Pair Weighting (GPW) framework and presented a new multi-similarity loss to fully exploit the information of each pair. Our GPW, for the first time, unifies existing pair-based metric learning approaches into general pair weighting through gradient analysis. It provides a powerful tool for understanding and explaining various pair-based loss functions, which allows us to clearly identify the main differences and key limitations of existing methods. Furthermore, we proposed a multi-similarity loss which considers all three similarities simultaneously, and developed an iterative pair mining and weighting scheme for optimizing the multi-similarity loss efficiently. Our method obtains new state-of-the-art performance on a number of image retrieval benchmarks.
{\small
	\bibliographystyle{ieee}
	\bibliography{egbib}
}

\clearpage
\clearpage
\includepdf[pages=1]{2333-supp.pdf}
\includepdf[pages=2]{2333-supp.pdf}
\includepdf[pages=3]{2333-supp.pdf}



\end{document}
