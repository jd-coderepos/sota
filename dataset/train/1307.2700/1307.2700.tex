\documentclass[11pt]{llncs}
\usepackage{yhmath}
\usepackage{url}
\usepackage{amssymb,wasysym}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{subfig}
\usepackage{color}
\usepackage{multirow}
\usepackage{epstopdf}
\usepackage[margin=1in]{geometry}


\usepackage[usenames,dvipsnames]{xcolor,colortbl}



\newcommand{\etal}{\emph{et~al.}}
\newcommand{\ie}{\emph{i.e.}}
\newcommand{\eg}{\emph{e.g.}}


\graphicspath{{images/}}

\urldef{\mailsa}\path||
\urldef{\mailsb}\path||
\urldef{\mailsc}\path||
\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

\renewenvironment{proof}{\emph{Proof.}}{\hfill  \medskip\\}
\newtheorem{observation}{Observation}




\pagestyle{plain}
\setcounter{page}{1}
\pagenumbering{roman}



\mainmatter  

\title{Kinetic Data Structures for the Semi-Yao Graph\\ and All Nearest Neighbors in }


\author{\small
Zahed Rahmati
\and
Mohammad Ali Abam
\and
Valerie King
\and
Sue Whitesides
}

\institute{\small
Dept. of Computer Science, University of Victoria, Canada. \\{\tt \{rahmati,val,sue\}@uvic.ca}\\
Dept. of Computer Engineering, Sharif University of Technology, Iran. \\{\tt abam@sharif.edu}
}


\toctitle{}
\tocauthor{}


\titlerunning{Kinetic Data Structures for the Semi-Yao Graph and All Nearest Neighbors}
\authorrunning{Z. Rahmati, M. A. Abam, V. King, and S. Whitesides}


\begin{document}
\maketitle
\begin{abstract}
This paper presents a simple kinetic data structure for maintaining all the nearest neighbors of a set of  moving points in , where the trajectory of each point is an algebraic function of at most constant degree .  The approach is based on maintaining the edges of the Semi-Yao graph, a sparse graph whose edge set includes the pairs of nearest neighbors as a subset. 

\vspace{+5pt}
Our kinetic data structure (KDS) for maintaining all the nearest neighbors is deterministic. It processes  events with a total cost of . Here,  is an extremely slow-growing function. The best previous KDS for all the nearest neighbors in  is by Agarwal, Kaplan, and Sharir (TALG 2008). It is a randomized result. Our structure and analysis are simpler than theirs. Also, we improve their result by a factor of  in the number of events and by a  factor in the total cost.

\vspace{+5pt}
This paper generalizes and improves the 2013 work of Rahmati, King and Whitesides (SoCG 2013) on maintaining the Semi-Yao graph in ;  its new technique provides the first KDS for the Semi-Yao graph in . Our KDS is local in the worst case, meaning that only a constant number of events is associated with any one point at any time.

\vspace{+5pt}
For maintaining all the nearest neighbors, neither our KDS nor the KDS by Agarwal~\etal~is local, and furthermore, each event in our KDS and in their KDS is handled in polylogarithmic time in an amortized sense. 

\vspace{+5pt}
Finally, in this paper, we also give a KDS for maintenance of all the -nearest neighbors which is local and each event can be handled in a polylogarithmic worst-case time.
\keywords{kinetic data structure, all nearest neighbors, Semi-Yao graph (theta graph), range tree, closest pair, }
\end{abstract}
\newpage
\setcounter{page}{1}
\section{Introduction}
Let  be a set of  points in . Finding the nearest neighbor to a query point, which was called the \textit{post office problem} by Donald Knuth in 1973~\cite{Knuth:1973:ACP}, is fundamental in computational geometry. The \textit{all nearest neighbors} problem, a variant of the post office problem, is to find the nearest neighbor to each point . Given any , the \textit{all -nearest neighbors} problem is to find some  for each point , such that the Euclidean distance  between  and  is within a factor of  of the Euclidean distance between  and its nearest neighbor. The \textit{nearest neighbor graph} is constructed by connecting each point  to its nearest neighbor. The \textit{closest pair} problem is to find the endpoints of the edge in the nearest neighbor graph with minimum length. The \textit{Semi-Yao graph} (or \textit{theta-graph}) is a too long-well-studied sparse proximity graph~\cite{Clarkson:1987:AAS:28395.28402,Keil:1988:ACE:61764.61787}. This graph can be constructed by partitioning the space around each point  into  cones , , with  the shared apex of the cones, and then connecting the point  to a point  inside each of these cones, such that the point  has the minimum length projection on the vector in the direction of the symmetry ; see Figure~\ref{fig:SY6}(b). By treating the number  of cones at each point as a parameter of the Semi-Yao graph, one obtains an important class of sparse graphs, \textit{t-spanners}, with different stretch factors ~\cite{BBCRV2013Theta4,Bonichon:2010:CTD:1939238.1939265,BMRV2013Theta5,BRV2013Theta4k345}. 

The maintenance of attributes (e.g., the closest pair) of sets of moving points has been studied extensively over the past 15 years~\cite{DBLP:conf/swat/RahmatiZ12,Agarwal:2003:IMP:846156.846166,Alexandron:2007:KDD:1219156.1219201,Basch:1997:DSM:314161.314435,Karavelas:2001:SKG:365411.365441,DBLP:conf/gd/RahmatiZ12,DBLP:conf/iwoca/RahmatiZ11,DBLP:conf/socg12/Natin}. A basic framework for this study  is that of a kinetic data structure (KDS), which is in fact a set of data structures and algorithms to track the attributes of moving points. The problem of maintaining all the nearest neighbors, the closest pair, and the Semi-Yao graph on moving points are called the \textit{kinetic all nearest neighbors} problem, the \textit{kinetic closest pair} problem, and the \textit{kinetic Semi-Yao graph}, respectively. 

The kinetic maintenance of attributes is generally considered in two models: the \textit{standard KDS model} and the \textit{black-box KDS model}~\cite{Gao:2006:DSA:1646483.1646577,deBerg:2011:KCH:1998196.1998233}. In the black-box model, the locations of the objects are received at regular time steps. In the standard model, each object has a flight plan known in advance, and during the motion the object can change its flight plan at some times which are not known in advance. This paper considers the all nearest neighbors problem and the Semi-Yao graph in  for the standard KDS model and improves previous results; see Table~\ref{table:RelatedWork} in Appendix A. In addition, it offers results on all -nearest neighbors in .
\vspace{+5pt}
\\
\textbf{Standard KDS framework.}
Basch, Guibas, and Hershberger~\cite{Basch:1997:DSM:314161.314435} introduced a \textit{kinetic data structure framework} to maintain the attributes of moving points in the standard KDS model. In this framework we assume each point  is moving with a trajectory  in , where the  coordinates of the trajectory of  the point , which determine the position of  as a function of time, are  algebraic functions of at most constant degree .  

The correctness of an attribute over time is determined based on correctness of a set of \textit{certificates}. A certificate is a boolean function of time, and its \textit{failure time} is the next time after the current time at which the certificate will become invalid. When a certificate fails, we say that an \textit{event} occurs. Using a \textit{priority queue} of the failure times of the certificates, we can know the next time after the current time that an event occurs. When the failure time of the certificate with highest priority in the priority queue is equal to the current time we invoke the update mechanism to reorganize the data structures and replace the invalid certificates with new valid ones. 

To analyse the performance of a KDS there are four standard criteria. A KDS distinguishes between two types of events: \textit{external events} and \textit{internal events}. An event that changes the desired attribute itself is called an external event and those events that cause only some internal changes in the data structures are called internal events. If the ratio between the total number of events and the number of external events is , the KDS is \textit{efficient}. The efficiency of the KDS gives an intuition of how many more events the KDS processes. If response time of the update mechanism to an event is , the KDS is \textit{responsive}. The compactness of a KDS refers to space complexity: if the KDS uses  space, it is \textit{compact}. The KDS is \textit{local} if the number of events associated with any point in the KDS is . The locality of the KDS is an important criterion; if a KDS satisfies locality, the KDS can be updated quickly and efficiently when an object changes its flight plan (trajectory) at times. 
\vspace{+5pt}
\\
\textbf{Related work.}
Basch, Guibas, and Hershberger (SODA'97)~\cite{Basch:1997:DSM:314161.314435} provided a KDS for maintenance of the closest pair in . Their KDS uses linear space and processes  events, each in time . Here,  is an extremely slow-growing function and  is the maximum length of Davenport-Schinzel sequences of order  on  symbols.

A common way to maintain attributes of moving points in  is to use \textit{kinetic multidimensional range trees}~\cite{Basch:1997:PPM:262839.262998,Agarwal:2008:KDD:1435375.1435379,Abam:2007:KKL:1247069.1247133}.  Basch~\etal~\cite{Basch:1997:PPM:262839.262998} and Agarwal~\etal~\cite{Agarwal:2008:KDD:1435375.1435379} use dynamic balanced trees to implement a kinetic range tree. Using rebalancing operations, they handle events to maintain a range tree. In particular, in their approaches, when an event between two points  and  occurs, we must delete  and  and reinsert them into the range tree. The range tree can be maintained over time using a dynamic range tree. One of the approaches to update the range trees is to carry out local and global rebuilding after a few operations, which gives  amortized time per operation~\cite{Mehlhorn:1984:DSA:1923}. Another approach, which uses merge and split operations, gives worst-case time  per operation~\cite{Willard:1985:ARR:3828.3839}. To avoid rebalancing the range tree after each operation, Abam and de Berg~\cite{Abam:2011:KSX:1971362.1971367} introduced a variant of the range trees, a \textit{rank-based range tree} (RBRT), which gives worst-case time  per operation.

Basch, Guibas, and Zhang (SoCG'97)~\cite{Basch:1997:PPM:262839.262998} used multidimensional range trees to maintain the closest pair. For a fixed dimension , their KDS uses  space and processes  events, each in worst-case time . Their KDS is responsive, efficient, compact, and local.

Agarwal, Kaplan, and Sharir (TALG'08)~\cite{Agarwal:2008:KDD:1435375.1435379} gave KDS's for both maintenance of the closest pair and all the nearest neighbors in . Agarwal~\etal~claimed that their closest pair KDS simplifies the certificates used by Basch, Guibas, and Hershberger~\cite{Basch:1997:DSM:314161.314435}; perhaps Agarwal~\etal~were not aware of the paper by Basch, Guibas, and Zhang~\cite{Basch:1997:PPM:262839.262998}, which independently presented a KDS for maintenance of the closest pair with the same approach to~\cite{Basch:1997:PPM:262839.262998}. The closest pair KDS by Agarwal~\etal, which supports insertions and deletions of points, uses  space and processes  events, each in amortized time ; this KDS is efficient, responsive (in an amortized sense), local, and compact. 
Agarwal~\etal~gave the first efficient KDS to maintain all the nearest neighbors in . For the efficiency of their KDS, they implemented multidimensional range trees by using randomized search trees (treaps). Their randomized kinetic approach uses  space and processes  events; the expected time to process all events is . On average, each point in their KDS participates in  certificates. Their all nearest neighbors KDS is efficient, responsive (in an amortized sense), compact, but in general is not local. 

Rahmati, King, and Whitesides (SoCG'13)~\cite{socg17-rahmati} gave the first KDS for maintenance of the Semi-Yao graph in . Their Semi-Yao graph KDS uses linear space and processes  events with total processing time . Using the kinetic Semi-Yao graph, they improved the previous KDS by Agarwal~\etal~to maintain all the nearest neighbors in . In particular, their \textit{deterministic} kinetic algorithm, which is also arguably simpler than the randomized kinetic algorithm by Agarwal~\etal, uses  space and processes  events with total processing time . With the same complexity as their KDS for maintenance of all the nearest neighbors, they maintain the closest pair over time. On average, each point in their KDS's participates in a constant number of certificates. Their kinetic data structures for maintenance of the Semi-Yao graph, all the nearest neighbors, and the closest pair are efficient, responsive (in an amortized sense), compact, but in general are not local.  
\vspace{+5pt}
\\
\textbf{Our technique and improvements.}
We provide a simple, deterministic KDS for maintenance of both the Semi-Yao graph and all the nearest neighbors in .  Assuming  is fixed, we maintain the Semi-Yao graph in  using a constant number of range trees. Our KDS generalizes the previous KDS for the Semi-Yao graph by Rahmati~\etal~\cite{socg17-rahmati} that only works in . Also, our kinetic approach yields improvements of the KDS for maintenance of the Semi-Yao graph by Rahmati~\etal~\cite{socg17-rahmati} (see Table~\ref{table:RelatedWork} in Appendix A): Our KDS is local, but their KDS is not. In particular, each point in our KDS participates in  certificates, but  in their KDS each point participates in  events. For any fixed dimension , our KDS handles  events, but their KDS handles  events in . 

Our KDS for maintenance of all the nearest neighbors is based on the fact that the Semi-Yao graph is a supergraph of the nearest neighbor graph. For each point  in the Semi-Yao graph we construct a tournament tree to maintain the edge with minimum length among the edges incident to the point . Summing over elements of all the tournament trees in our KDS is linear in , which leads to a total number of events , which is \textit{independent} of . This improves the previous \textit{randomized} kinetic algorithm by Agarwal~\etal~\cite{Agarwal:2008:KDD:1435375.1435379}: The expected total size of the tournament trees in their KDS is ; so their KDS processes  events, which depends on . Also, the structure and analysis by Agarwal~\etal~are more complex than ours.
\vspace{+5pt}
\\
\textbf{Our results.}
For a set of  moving points in , we present simple KDS's to maintain the Semi-Yao graph and all the nearest neighbors. We assume the trajectory of each point is an algebraic function of at most constant degree . Our KDS for maintenance of the Semi-Yao graph uses  space and processes  events with total processing time .  The KDS is compact, efficient, responsive (in an amortized sense), and it is local.


Our all the nearest neighbors KDS uses  space and processes ) events with total processing time .  It is compact, efficient, responsive (in an amortized sense), but it is not local in general. To satisfy the locality criterion and to get a worst-case processing time KDS, we show a KDS for maintenance of all the -nearest neighbors. In particular, for each point  we maintain some point  such that , where  is the nearest neighbor of  and  is the Euclidean distance between  and . This KDS uses  space, and handles  events, each in worst-case time ; it is compact, efficient, responsive, and local.
\vspace{+5pt}
\\
\textbf{Paper organization.}
Section~\ref{sec:prelininary} describes the construction of the Semi-Yao graph and gives a solution to the all nearest neighbors problem in . In Section~\ref{sec:KineticSY}, we show how the Semi-Yao graph can be maintained kinetically. Using the kinetic Semi-Yao graph, we give a KDS for maintenance of all the nearest neighbors in Section~\ref{sec:KineticANN}. Section~\ref{sec:KineticEpsANN} shows how to maintain all the -nearest neighbors.\section{The Construction}\label{sec:prelininary}
In the following we describe the construction of the Semi-Yao graph and construction of all the nearest neighbors, which will aid in understanding how our kinetic approach works.

Let  be a unit vector in  with apex at the origin , and let  be a constant. We define the \textit{infinite right circular cone} with respect to  and  to be the set of points  such that the angle between  and  is at most . A \textit{polyhedral cone} inscribed in this infinite right circular cone is formed by intersection of  distinct half-spaces such that all the half-spaces contain the origin . The angle between any two rays inside the polyhedral cone emanating from  is at most . 
The -dimensional space around the origin  can be covered by a collection of disjoint polyhedral cones , where ~\cite{Agarwal:2008:KDD:1435375.1435379,Abam:2011:KSX:1971362.1971367}. Denote by  the vector in the direction of the unit vector  of , ,  with the origin at . Let  denote a translated copy of  with apex at ; see Figure~\ref{fig:SY6}(a). From now on, we assume  is arbitrary but fixed, so  is constant.

Given a point set  in , the Semi-Yao graph is constructed by connecting each point  to the point in , , whose -coordinate is minimum. Figure~\ref{fig:SY6}(b) depicts some edges incident to the point  in the Semi-Yao graph in  where ; here , , and .



The following lemma is used in~\cite{Basch:1997:DSM:314161.314435,Agarwal:2008:KDD:1435375.1435379,socg17-rahmati} to maintain the closest pair and all the nearest neighbors for a set  of moving points; see Figure~\ref{fig:SY6}(c).
\begin{lemma}{\tt (Lemma 8.1.~\cite{Agarwal:2008:KDD:1435375.1435379})}\label{the:keyLemma}
Let  be the nearest point to  and let  be a cone of opening angle  that contains . Then  has the minimum -coordinate among the points in .
\end{lemma}
\begin{figure}[t]
\centering
\includegraphics[scale=0.7]{3in1.eps}
\vspace{-5pt}
\caption{\small (a) The cone  and its translated copy with apex at . (b) The point  is connected to the point in  that has minimum -coordinate. The dotted lines are orthogonal to the cone axes. (c) The point  is the nearest neighbor to  and, so  has the minimum -coordinate among the points in .}
\vspace{-12pt}
\label{fig:SY6}
\end{figure}
For a set of points in the plane, Rahmati~\etal~\cite{socg17-rahmati} used Lemma~\ref{the:keyLemma} to show that the Semi-Yao graph is a super-graph of the nearest neighbor graph. It is easy to see the same result for a set of points in higher dimensions.
\begin{lemma}\label{the:SYcontainsNNG}
The Semi-Yao graph of a set of points in  is a super-graph of the nearest neighbor graph.
\end{lemma}
\begin{proof}
Let  be an edge in the nearest neighbor graph such that  is the nearest neighbor to . The point  is in some cone . Following the restriction  of the cone  and from Lemma~\ref{the:keyLemma}, the point  has minimum length projection on  among the points in ; this means that  is an edge of the Semi-Yao graph.
\end{proof}

For a fixed dimension , there is a constant number of cones . Denote by  the bounding half-spaces of the cone  and let  be the coordinate axis orthogonal to , ; Figure~\ref{fig:SY6}(a) depicts  and  of the half-spaces  and  of the cone . Corresponding to each cone , we construct a ranked-based range tree (RBRT) ~\cite{Abam:2011:KSX:1971362.1971367}, which describes as follows, and for each point  in , we find the point in  whose -coordinate is minimum; this gives a construction for the Semi-Yao graph. \\
\textbf{Ranked-based range tree.} The RBRT  is a variant of the range trees which has the following property. When two points exchange their order along an axis , the RBRT can be updated without rebalancing the subtrees. The points at the level  of the RBRT  are sorted at the leaves in ascending order according to their -coordinates. The skeleton of a RBRT is independent of the position of the points in  and it depends on the ranks of the points in each of the -coordinates. The rank of a point in a tree at level  of the RBRT is its position in the sorted list of all the points according to their -coordinates. Any tree at any level of the RBRT is a balanced binary tree and no matter how many points are in the tree, it is a tree on  ranks~\cite{Abam:2011:KSX:1971362.1971367}.


Let  be an internal node at level  of the RBRT . Denote by  the set of points at the leaves of the subtree rooted at .  The set  is the union of  sets ; all of these  sets can be reported in time , where  is the cardinality of . 

Corresponding to each node  at level  of  we define another set . Denote by  the path from the parent of  to the root of a tree at level  of . A point  belongs to  if  is the right child of some node ; a point  is in  if  is one of the  sets while reporting the points of .

Let  be the reflection of  through ;  is formed by following the lines through  in the half-spaces of ; see Figure~\ref{fig:SY6}(a). Similar to the way that we report the points of  inside a query cone , we can also report the points of  inside a query cone . The set , where the nodes  are on the paths .




The set of all the pairs , for all of the internal nodes  at level  of , is called a \textit{cone separated pair decomposition} (CSPD) for  with respect to ; denote this set by . The CSPD  for  with respect to  has the following properties~\cite{Abam:2011:KSX:1971362.1971367}:
\begin{itemize}
\item For the two points  and , where , there exists a unique pair  such that  and .
\item For the pair , if  and , then  and .
\end{itemize}
Let  be the point with minimum -coordinate among the points in . Denote by  and  the left and the right child of the node , respectively.  For each node , the value of  is generated from the values of it children,  and ; one which stores the point with minimum -coordinate. So, for all internal nodes  at level  of the RBRT , we can find all of the  in  time. Since for each point  the point with minimum -coordinate in  is chosen among  points , the following lemma results.
\begin{lemma}\label{the:SYConstructionTime}
The Semi-Yao graph of a set of  points in  can be constructed in time .
\end{lemma}
Vaidya~\cite{Vaidya:1989:ONL:70530.70532} gave an  time algorithm to solve the all nearest neighbors problem. Given the Semi-Yao graph in , by examining the edges incident to any point in the Semi-Yao graph, we can find the nearest neighbor to the point. Since the Semi-Yao graph has  edges, we can get the following.
\begin{lemma}\label{the:ANNConstructionTime}
Given the Semi-Yao graph, the all nearest neighbors problem in  can be solved in  time.
\end{lemma}
\section{Kinetic Semi-Yao graph}\label{sec:KineticSY}
Fix a cone  and the corresponding coordinates , and . When the points are moving, the Semi-Yao graph remains unchanged as long as the order of the points in each of the coordinates , and  remains unchanged. To maintain the Semi-Yao graph over time, we distinguish between two types of events:
\begin{itemize}
\item \textit{-swap event:} Such an event occurs if two points exchange their order in the -coordinate. This event can change the structure of the range tree.
\item \textit{-swap event:} This event occurs if two points exchange their order in the -coordinate. The range tree structure remains unchanged when this event occurs.
\end{itemize}
To track the above changes, we maintain sorted lists , and  of the points in each of the coordinates , and , respectively. For each two consecutive points in each sorted list  we define a certificate that certifies the order of the two points in the -coordinate. To track the closest time to the current time we put failure times of all of the certificates in a priority queue; the element with the highest priority in the queue gives the closest time.

Our Semi-Yao graph KDS is based on maintenance of the RBRT . Abam and de Berg describe how to maintain a RBRT. Their approach uses  space, and a -swap event can be handled in the worst-case time  without rebalancing the subtrees of the RBRT~\cite{Abam:2011:KSX:1971362.1971367}.

For the point , the set  where the nodes  are the right child nodes of the nodes on the paths . Denote by  the point in  with minimum -coordinate. To maintain the Semi-Yao graph, for each point  we must track  which in fact is the point in  whose -coordinate is minimum. To apply changes to the , for all , besides , we need to maintain more information at each internal node  at level  of the RBRT  that describes as follows.



Allocate an \textit{id} to each point in . Let  and let  be a sorted list of the pairs of  according to the ids of the second components  of the pairs . This sorted list is used to answer the following query while processing -swap events: Given a query point , find all the points  such that . Since we have insertions/deletions into the sorted lists  over time, we implement them using a dynamic binary search tree (\eg, a \textit{red-black tree}); each insertion/deletion operation is performed in worst-case time . Furthermore, we maintain a set of links between each point  and the pair  in the sorted lists  where ; denote this set by . Since, the point  is in at most  sets , the cardinality of the set  is .

In the preprocessing step before the motion, for any internal node  at level  of the RBRT and for any point , we find  and  and then, we construct  and .


Now, let the points move. The following shows how to maintain and reorganize ,  and   when a -swap event or an -swap event occurs. Note that maintenance of the sets , for all , gives a kinetic maintenance of the Semi-Yao graph.

\begin{wrapfigure}{r}{0.4\textwidth}
\vspace{-25pt}
  \begin{center}
    \includegraphics[width=0.35\textwidth]{Uswap.eps}
  \end{center}
  \vspace{-10pt}
  \caption{\small A -swap between  and  does not change the points in other cones .}
  \vspace{-15pt}
  \label{fig:Uswap}
\end{wrapfigure}
\textbf{-swap event.}
When two points  and  exchange their order in the -coordinate, we swap them in the sorted list  and update the invalid certificates with new valid ones; applying a constant number of changes to the priority queue takes  time. Then, we delete  and  and reinsert them into the RBRT with their new ranks~\cite{Abam:2011:KSX:1971362.1971367}. Next, we update the values  where the nodes  are ancestors of  and . A change to some  can only change  where  is the parent of . So, these updates can easily be done in  time.


Let  (resp. ) before the event. After occurring the event,  moves outside (resp. inside) the cone ; see Figure~\ref{fig:Uswap}. Note that this event does not change the points in cones  of other points . Therefore, the only change that can happen to the Semi-Yao graph is deleting an edge incident to  inside the cone  and adding a new one. 

We perform the following steps when such event occurs. We first delete the pairs  of the sorted lists  where ; by using the links in , this can be done in time . Then, we delete the members of . Next, we find the point  in  whose -coordinate is minimum. Recall that , , are the right child nodes of the nodes on the paths . Since we might get a new value for  among all of the , we must add the new pair , according to the id of the new value of , into all the sorted lists  where . Finally, we construct  of the new links between  and the pair  of the sorted lists  which takes  time.


Since the number of swaps between the points in the sorted lists , , is , the following results.
\begin{lemma}\label{the:Uswap}
For maintenance of the Semi-Yao graph, our KDS handles  -swap events, each in the worst-case time .
\end{lemma}
\textbf{-swap event.} Let  and  be two consecutive points with  preceding  in the sorted list :  before the event. When  and  exchange their order, we swap them in  and update the invalid certificates with new valid ones, which takes  time. This event does not change the structure of the RBRT ; but it might change the second components of the pairs in some sorted lists  and if so, we must apply the changes to the Semi-Yao graph. 

\begin{wrapfigure}{r}{0.4\textwidth}
\vspace{-20pt}
  \begin{center}
    \includegraphics[width=0.43\textwidth]{Xswap.eps}
  \end{center}
  \vspace{-10pt}
  \caption{\small Two cases when an -swap between  and  occurs.}
  \vspace{-20pt}
  \label{fig:Xswap}
\end{wrapfigure}
The number of all changes to the Semi-Yao graph depends on how many points  have both of  and  in their cones . While reporting the points in , such points  can have both of  and  in the same set  (Figure~\ref{fig:Xswap}(a)) or in two different sets  and  (Figure~\ref{fig:Xswap}(b)). To find such points ,  we seek internal nodes  at level  of  where , which means that the nodes  are common ancestors of  and ,  we seek for internal nodes  and  where  and . In the first case, it is obvious that we must find any point  such that  is the point with minimum -coordinate in the cone , meaning that . Then, we replace  by  after the event (). This means that we replace the edge  of the Semi-Yao graph with . 

Note that in the second case there is no point  such that , because . Also note that if there is a point  such that , we change the value of  to  if . Since we can find  in , we do not need to be worry about checking whether such points  are in  or not. Therefore, for the second case, we only need to check whether there is a point  such that ; if so, we change the value of  to  ().

From the above discussion, the following three steps summarize the update mechanism of our KDS for maintenance of the Semi-Yao graph when an -swap event occurs.
\begin{itemize}
\item[1.] Find all the internal nodes  at level  of  such that  and ; see Figure~\ref{fig:Xswap}(a). Also, find all the internal nodes  where ; see Figure~\ref{fig:Xswap}(b).
\item[2.] For each of the internal nodes  (from Step 1), find all the pairs  in the sorted list  where .
\item[3.] For each  (from Step 2), through the links in , find all the corresponding sorted lists , delete the pair  from them, change the value of the second component  to , and add  into the sorted lists according to the id of .
\end{itemize}
The number of edges incident to a point  in the Semi-Yao graph is . So, when an -swap event between  and some point  occurs, it might apply  changes to the Semi-Yao graph. The following lemma shows that an -swap event can be handled in polylogarithmic amortized time.
\begin{lemma}\label{the:Xswap}
For maintenance of the Semi-Yao graph, our KDS handles  -swap events with total processing time .
\end{lemma}
\begin{proof} 
All of the internal nodes  at Step 1 can be found in  time. 

For each internal node  of Step 2, the update mechanism spends  time where  is the number of all the pairs  such that . For all of the internal nodes , the second step takes  time. Note that  is equal to the number of exact changes to the Semi-Yao graph. Since, the number of changes to the Semi-Yao graph of a set of  moving points in a fixed dimension  is ~\cite{socg17-rahmati}, the total processing time of Step 2 for all of the  -swap events is . 

The processing time to apply changes to the KDS for each  of Step 3, which in fact is a change to the Semi-Yao graph, is . So, the update mechanism spends  time to handle all of the  events.

Hence, the total processing time for all the -swap events is .
\end{proof}
The following summarizes the complexity of our Semi-Yao graph KDS.
\begin{theorem}\label{the:KineticSYG}
Our KDS for maintenance of the Semi-Yao graph of a set of  moving points in , where the trajectory of each point is an algebraic function of at most constant degree , uses    space and handles  events with a total cost of . The KDS is compact, efficient, responsive (in an amortized sense), and local.
\end{theorem}
\begin{proof}
From Lemmas~\ref{the:Uswap} and ~\ref{the:Xswap}, all of the  events can be processed in time ; this means that the KDS is responsive in an amortized sense.  and the number of the certificates is ; so, the KDS is compact. A particular point in a sorted list  participates in two certificates, one certificate is created with previous point and one with the next point. So, the number of events associated to a particular point is  which means the KDS is local. Since the number of the external events is  and the number of the events that the KDS processes is , the KDS is efficient.
\end{proof}
\section{Kinetic All Nearest Neighbors}\label{sec:KineticANN}
Given the kinetic Semi-Yao graph, a super-graph of the nearest neighbor graph over time, from Section~\ref{sec:KineticSY}, we can easily maintain the nearest neighbor to each point . Let  be the set of edges in the Semi-Yao graph incident to the point .  Using a \textit{dynamic and kinetic tournament tree} (DKTT)~\cite{Agarwal:2008:KDD:1435375.1435379,Basch:1997:DSM:314161.314435}, we can maintain the nearest neighbor to  over time. Denote by  the DKTT corresponding to the point . The elements of  are the edges in . The root of the  maintains the edge with minimum length between the edges in . Let  be the number of all insertions/deletions into the set  over time. \begin{lemma}\label{the:KineticTT} {\tt (Theorem 3.1.~\cite{Agarwal:2008:KDD:1435375.1435379})}
The dynamic and kinetic tournament tree  can be constructed in linear time. For a sequence of  insertions and deletions into the , whose maximum size  at any time is , the  generates at most  tournament events, for a total cost of . Each event can be handled in the worst-case time .
\end{lemma}
From Lemma~\ref{the:KineticTT}, the number of all events for maintenance of all the nearest neighbors is equal to . Inserting (resp. deleting) an edge  in the Semi-Yao graph makes one insertion (resp. deletion) in  and one in . So,  is in order of the number of exact changes to the Semi-Yao graph. Since , and since the number of all changes (edge insertions and edge deletions) to the Semi-Yao graph is equal to ~\cite{socg17-rahmati}, the following corollary results.
\begin{corollary}\label{the:KineticANN}
Given a KDS for  maintenance of the Semi-Yao graph, all the nearest neighbors can be maintained by using a kinetic algorithm that generates  tournament events, for a total cost of . Each event can be handled in the worst-case time . The number of events associated to a particular point is constant on average.
\end{corollary}
The following theorem, which results from Theorem~\ref{the:KineticSYG} and Corollary~\ref{the:KineticANN}, gives the complexity of the KDS for maintenance of all the nearest neighbors.
\begin{theorem}\label{the:KineticAllNN}
Our kinetic data structure for maintenance of all the nearest neighbors of a set of  moving points in , where the trajectory of each point is an algebraic function of at most constant degree , has the following properties. 
\begin{enumerate}
\item The KDS uses  space.
\item It processes  -swap events, each in the worst-case time .
\item It processes  -swap events, for a total cost of .
\item The KDS processes  tournament events, and processing all the events takes  time.
\item The KDS is compact, efficient, responsive in an amortized sense, and local on average, meaning that each point participates in a constant number of certificates on average.
\end{enumerate}
\end{theorem}
\section{Kinetic All -Nearest Neighbors}\label{sec:KineticEpsANN}
Let  be the nearest neighbor of  and let  be some point such that . We call  the \textit{-nearest neighbor} of . In this section,  we maintain some -nearest neighbor for any point .

\begin{wrapfigure}{r}{0.4\textwidth}
\vspace{-10pt}
  \begin{center}
    \includegraphics[width=0.35\textwidth]{RNNgraph.eps}
  \end{center}
  \vspace{-15pt}
  \caption{\small The point  (resp. ) has minimum (resp. maximum) -coordinate among the points in  (resp. ).}
  \vspace{-10pt}
  \label{fig:RNNgraph}
\end{wrapfigure}
Consider a cone  of opening angle , which is bounded by  half-spaces. Let  be the  vector inside the cone  that passes through the apex of . Recall a CSPD  for  with respect to the cone . Figure~\ref{fig:RNNgraph} depicts the cone  and a pair . Let  (resp. ) be the point with the maximum (resp. minimum) -coordinate among the points in  (resp. ). Let . We call the graph  the \textit{relative nearest neighbor graph} (or RNN graph for short) with respect to . Call the graph  the \textit{RNN graph}.  The RNN graph has the following interesting properties:  It can be constructed in  time by using a -dimensional RBRT,  it has  edges, and  the degree of each point is . Lemma~\ref{the:RNNGlemma} below shows another property of the RNN graph which leads us to find some -nearest neighbor for any point .

\begin{lemma}\label{the:RNNGlemma}
Between all the edges incident to a point  in the RNN graph, there exists an edge  such that  is some -nearest neighbor to .
\end{lemma}
\begin{proof}
Let  be the nearest neighbor to  and let . From the definition of a CSPD with respect to , for  and  there exists a unique pair  such that  and . From Lemma~\ref{the:keyLemma},  has the maximum -coordinate among the points in . 

Let  be the point with the minimum -coordinate among the points in . For any , there exist an appropriate angle  and a vector  such that ~\cite{Abam:2011:KSX:1971362.1971367}; this satisfies that . Therefore, the edge  which is an edge of the RNN graph gives some -nearest neighbor.
\end{proof}


Consider the set  of the edges of the RNN graph. Let . Denote by  the point in  whose -coordinate is minimum. Let  be a sorted list of the points in  in ascending order according to their -coordinates; the first point in  gives . Similar to Section~\ref{sec:KineticSY} we handle two types of events, \textit{-swap events} and \textit{-swap events}. Note that we do not need to define a certificate for each two consecutive points in .  The following shows how to apply changes (\eg, insertion, deletion, and exchanging the order between two consecutive points) to the sorted lists  when an event occurs.

Each event can make  updates to the edges of . Consider an updated pair  that the value of  (resp. ) changes from  to . For this update, we must delete  (resp. ) form the sorted list  (resp. ) and insert  (resp. ) into  (resp. ). If the event is an -swap event, we must find all the  where  and check whether  or not; if so,  and  are in the same set  and we need to exchange their order in the corresponding sorted list . Since each update to a sorted list  can be done in , an event can be handled in worst-case time .



From Lemma~\ref{the:RNNGlemma}, if the nearest neighbor of  is in some cone , then  gives some -nearest neighbor to . Note that we do not know which cone , , of  contains the nearest neighbor of , but it is obvious that the nearest point to  among these  points  gives some -nearest neighbor of . So, for all , we track the distances of all the  to  over time. A tournament tree (or a kinetic sorted list) of size  with  certificates can be used to maintain the nearest point to . Since each event makes  changes to the values of , and since the size of each tournament tree (or a kinetic sorted list) is constant, the number of all events to maintain all the -nearest neighbors is , and each point participates in  certificates.

From the above discussion the following theorem results.
\begin{theorem}\label{the:KinEpsANN}
Our KDS for maintenance of all the -nearest neighbors of a set of  moving points in , where the trajectory of each one is an algebraic function of constant degree , uses  space and handles  events, each in the worst-case time . The KDS is compact, efficient, responsive, and local.
\end{theorem}


Hence, for maintenance of all the -nearest neighbors, as opposed to the all nearest neighbors KDS in Section~\ref{sec:KineticANN}, each event can be handled in a polylogarithmic worst-case time, and the KDS is local.
\bibliographystyle{splncs03}
\bibliography{References}
\newpage
\appendix
\section{The Comparison Table}
\begin{table}[h]
\small
\centering
\begin{tabular}{ | c | p{2cm} | c | c | c | p{1.5cm} |}
\cline{2-6}
\multicolumn{1}{ c| }{} & 
problem & space  &  total number of events &  total processing time&  locality\\ \cline{1-6}
  \multirow{2}{*}{Agarwal~\etal\cite{Agarwal:2008:KDD:1435375.1435379}} & \multirow{2}{*}{all NNs in } &  \multirow{2}{*}{} & \multirow{2}{*}{} & \multirow{2}{*}{} &  on average\\  \hline\hline
\multirow{4}{*}{Rahmati~\etal\cite{socg17-rahmati}} &  \multirow{2}{*}{all NNs  in }& \multirow{2}{*}{} & \multirow{2}{*}{} & \multirow{2}{*}{} &  on average\\  \cline{2-6} 
& Semi-Yao graph  in & \multirow{2}{*}{} & \multirow{2}{*}{} & \multirow{2}{*}{} &  on average\\  \hline\hline
\multirow{4}{*}{{{\color{Mahogany}This paper}}} & \multirow{2}{*}{all NNs  in } & \multirow{2}{*}{} & \multirow{2}{*}{} & \multirow{2}{*}{} &  on average\\ \cline{2-6} & Semi-Yao graph in  & \multirow{2}{*}{} & \multirow{2}{*}{} & \multirow{2}{*}{} &  in worst-case\\  \hline
\end{tabular}
\vspace{+10pt}
\caption{ The comparison between our KDS's and the previous KDS's, assuming  is arbitrary but fixed.}
\label{table:RelatedWork}
\end{table}
\end{document}
