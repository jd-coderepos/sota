\documentclass{article}
\usepackage{fullpage}

\usepackage{color}
\usepackage{epsfig}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{enumerate}
\usepackage{setspace}
\usepackage{wasysym}




\newcommand{\R}{\mathbb{R}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{{\mathbb N}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\alg}{\mathcal{A}}

\newcommand{\E}[1]{{\mathbf E}\left\{#1\right\}}
\newcommand{\e}{{\mathbf E}}
\newcommand{\V}[1]{{\mathbf{Var}}\left\{#1\right\}}
\newcommand{\va}{{\mathbf{Var}}}
\newcommand{\p}[1]{{\mathbf P}\left\{#1\right\}}
\newcommand{\I}[1]{{\mathbf 1}_{[#1]}}
\newcommand{\floor}[1]{\left\lfloor#1\right\rfloor}
\newcommand{\ceil}[1]{\left\lceil#1\right\rceil}
\newcommand{\bibnotes}[1]{\\{\em\small #1}}
\newcommand{\quest}[1]{{\bf Question.} {\em #1 }}

\newcommand{\bea}{}
\newcommand{\eal}{\nonumber\\}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{obs}[theorem]{Observation}
\newtheorem{cor}[theorem]{Corollary}

\newcommand{\ssb}{\mathcal{B}}
\newcommand{\wf}{\mathcal{W}}
\newcommand{\xf}{\mathcal{X}}
\newcommand{\yf}{\mathcal{Y}}
\newcommand{\zf}{\mathcal{Z}}

\newcommand{\ra}{\rightarrow}
\newcommand{\la}{\leftarrow}
\newcommand{\ora}{\overrightarrow}
\newcommand{\ola}{\overleftarrow}
\newcommand{\lngi}{\lim_{n \ra \infty}}
\newcommand{\OPT}{\mathrm{OPT}}
\newcommand{\tw}{w}

\newcommand{\argmax}{\operatornamewithlimits{argmax}} 
\newcommand{\argmin}{\operatornamewithlimits{argmin}} 
\newcommand{\mean}{\operatornamewithlimits{mean}} 
\newcommand{\median}{\operatornamewithlimits{median}} 
\newcommand{\scr}{\mathcal}
\newcommand{\arm}{{\rm arm}}
\newcommand{\depth}{{\rm depth}}



\begin{document}


\title{Improving Robustness of Next-Hop Routing\thanks{This material is based upon work supported by the National Science
  Foundation, under Grant No.\ CCF-0964037.  Sean Kennedy is partially supported by a postdoctoral fellowship from the Natrual Sciences and Engineering Research Council of Canada.}}

\author{
Glencora Borradaile, W.~Sean~Kennedy, Gordon Wilfong, Lisa Zhang
}




\maketitle



\pagenumbering{arabic}

\begin{abstract}
A weakness of next-hop routing is that following a link or router failure there may be no routes between some source-destination pairs, or packets may get stuck in a routing loop as the protocol operates to establish new routes.
In this article, we address these weaknesses by describing mechanisms to choose alternate next hops.

Our first contribution is to model the scenario as the following {\sc tree
augmentation} problem.  Consider a mixed graph where some edges are
directed and some undirected.  The directed edges form a spanning tree
pointing towards the common destination node. Each directed edge
represents the unique next hop in the routing protocol.  Our goal is
to direct the undirected edges so that the resulting graph remains
acyclic and the number of nodes with outdegree two or more is
maximized.  These nodes represent those with alternative next hops
in their routing paths.

We show that {\sc tree augmentation} is NP-hard in general and present
a simple -approximation algorithm.  We also study 3 special
cases.  We give exact polynomial-time algorithms for when the input spanning tree consists of exactly 2 directed
paths or when the input graph has bounded treewidth.  For planar graphs, we present a
polynomial-time approximation scheme when the input tree is a
breadth-first search tree. To the best of our knowledge, {\sc tree
  augmentation} has not been previously studied.

\end{abstract}

\section{Introduction}


In an Internet Protocol (IP) network the header of each packet
contains the intended destination for that packet.  Each router in the
network has a {\em forwarding table} in which, for each destination, there is a corresponding entry stating which port through which to send out packets.  This type of routing is called {\em next-hop routing}.
Since the routings for different destinations are independent, without
loss of generality, we will herein talk about routing to one particular
destination .  A number of different routing protocols are
available for populating routing tables with  destination-port
pairs.  These protocols are called {\em interior gateway protocols}
(IGPs); see References~\cite{rfc:1058,rfc:2178,rfc:1142} for detailed operations of various of these IGPs.


For our purposes, an IP network is modeled as a graph, each node
representing a router and each edge representing a link between
routers.  The entry in the routing table for destination  at router
 is a pair  where  is a directed edge to a neighboring
router  of .  The goal of an IGP is to design routing tables so
that the union of these edges is a tree directed towards ; we call such a table {\em valid}.  The unique directed path from a router  to destination  in this tree implies a {\em route} for a message from  to .

A weakness of next-hop routing is that following a link or router
failure there may be no route from some source router to .  While a
routing protocol operates to establish new routes (by way of new
router table entries), packets may get stuck in a routing loop.  The {\em speed of
  convergence}, i.e.~the time required to recover from such a failure in the
network topology, is of fundamental importance in modern IGPs.
Indeed, real-time applications such as voice-over IP require quick
failure recovery.  

There have been many different methods proposed to
recover from failures; see References~\cite{GSBCSHT12} and~\cite{RI07} for surveys.  
We address a requirement for one such method, {\em Permutation Routing}~\cite{VLK12}.  In permutation routing, there may be multiple entries for destination  at router .  The route used by a message will use the first entry that corresponds to a link or neighbor that is not currently in failure.  To avoid routing loops, the union of the edges given by these entries should be a directed acyclic graph with  as the only sink.   So long as all the neighbors or edges listed in a routers table do not {\em all} fail, the tables will imply at least one route to .  In order to implement permutation routing, we start with a network of communication connections between routers and single-entry routing tables corresponding to a tree, often a shortest-path or breadth-first-search (BFS) tree of the graph.  We use the edges of the network to add entries to the router tables, thus adding the resiliency required for permutation routing.  As we show in this paper, it is the choice of how to add these entries that proves to be challenging.


In this paper, we study a graph theoretic problem which exactly models
this issue. Our contribution
is two-fold. From the networking perspective, we are the first to
offer a rigorous treatment of this approach for improving next-hop
routing robustness. From the graph theoretic perspective, we introduce a
crisply-stated graph problem that appears to be novel.

\subsection{The {\sc tree augmentation} problem}

We formally define the problem in graph terms.  The input is a mixed
graph , where  is the set of nodes,
 is a set of undirected edges and  is a set of
directed edges that form a directed spanning tree pointing towards the
destination node .  (Such a rooted, directed spanning tree is in
fact an arborescence; we use the term tree for convenience.)  The
edges of  give the unique next-hop for the initial
routing paths.  Our goal is to find an orientation of the undirected
edges  so that the resulting directed graph is acyclic and {\em
  maximizes} the number of nodes with outdegree at least two. Those
nodes that, in the resulting orientation, have outdegree at least two
represent those routers with an alternate next hop when a failure occurs. We
refer to this problem as {\sc tree augmentation}.

Herein, an {\em edge}  refers to an undirected edge between nodes
 and  and  and  refer
to directed edges, or arcs, from  to  and  to , respectively. 
For  we use  to denote the set
of arcs corresponding to some orientation of ; the details of that
orientation will be given by context.  We say a node  is {\em
covered} by an orientation if there is an arc .  Our objective is to maximize {\em the number of
covered nodes} over all possible orientations of subsets  of 
such that  is an {\em
acyclic} graph.  Note that the problem statement does not require
every edge in  be directed in the solution. However, we will see
that it never hurts to direct every edge in .

We also consider a weighted version of {\sc tree augmentation}, for
which some nodes may be viewed as more important to be covered. Here,
a positive weight  is given for each node  and the objective
becomes maximizing the total weight of covered nodes.

\subsection{Organization}

In Section~\ref{sec:comp} we present two observations and give simple a
-approximation for {\sc tree augmentation}.  In
Section~\ref{sec:hard} we prove the NP-hardness of {\sc tree augmentation} via a reduction from
the {\sc set cover} problem. The remainder of the paper gives positive
results for some interesting special cases.  In Section
\ref{sec:boundedtw}, we describe a polynomial-time algorithm for
graphs of bounded treewidth.  In Section \ref{sec:planar}, we describe
a polynomial-time approximation scheme for planar graphs when  is a
BFS tree. In Section \ref{sec:twoarm}, we describe a polynomial-time
algorithm for the special case in which the spanning tree consists of
exactly two directed paths.  We point out
that all our algorithmic results generalize to the weighted case.

\section{Observations and a simple approximation}\label{sec:comp}

We first note that, algorithmically, the acyclicity constraint is what
makes this problem challenging.  Consider the connected components of
the graph .  In each component we want to orient the edges
so that each node is covered.  If a connected component is a tree,
root this tree at an arbitrary node and orient every edge towards the
chosen root.  In this way, every node except the root is covered.
Further, it is not possible for every node in a tree to be covered.
If a connected component is not a tree, we begin with an arbitrary
spanning tree .  There must exist one node incident to an edge not
in .  We root the spanning tree  at this node and orient every
edge in  towards the root.  Since the root is incident to an edge
outside , we orient this edge away from the root.  All other edges
outside  can be oriented arbitrarily.  In this way, every node of
the connected component is covered.   Since all these operations are
no more difficult that depth-first search, we get:

\begin{obs}\label{obs:cyclic}
  Finding an orientation of  to maximize the number of covered
  vertices can be done in linear time.
\end{obs}

However, our guiding application requires that we find an acyclic
orientation.  Suppose we have oriented  such that
 is acyclic.  Consider
a topological ordering of the vertices of this acyclic graph and consider any
edge  in which, without loss of generality,
 is before  in the topological ordering.  Then
 is also acyclic.  Augmenting  in this way ensures that  is
covered while not affecting the coverage of any other vertex.  Repeating this for every
edge of  gives:

\begin{obs} \label{obs:complete} Given an orientation of a subset of
   of the non-tree edges , one can always orient the remaining
  edges  while maintaining acyclicity and without decreasing 
  the objective.
\end{obs}

Consider the bipartition of  into the set of {\em back edges} 
(edges  such that  is a descendent of  in
) and the {\em cross edges}  (edges  in  such that  and   have no ancestor/descendent relationship).  Each edge of  can
only be oriented in one way, from descendent to ancestor, without
introducing a cycle.  We let  denote this
orientation.  
Consider two orientations of : let  be the
orientation such that each edge  is oriented from low to
high pre-order (the order given by the first time a vertex is visited
by a depth-first search) and let  be the reverse of
this orientation (it is, in fact, the order such that each edge  is oriented from low to high {\em post}-order).

\begin{lemma}\label{lem:acyc}
  
and  are acyclic.
\end{lemma}

\begin{proof}
  Trivially,  is acyclic.

  For a contradiction, suppose there is a directed cycle  in .  Let  be the cycle obtained from  by contracting the edges in  that are not in  (i.e. .  Let  be the vertices of  in order, starting from an arbitrary vertex  of ; we have that  for otherwise the edges of  could not have a consistent direction.

  By the definition of the orientation of ,  must appear before  in the pre-order used for each .  Likewise, by the definition of the orientation of ,  must appear before  in the pre-order used, hence a contradiction.

  Likewise, reversing the direction of the edges in  results in an acyclic graph . \qed
\end{proof}

We can view these orientations in the
following way: embed  in a non-crossing way with
the root at the top and all edges directed upward; consider a DFS
traversal that explores the branches from left to right;  is the orientation in which all the edges of  are oriented from
left to right in this embedding and  is the
orientation in which all the edges of  are oriented from right to
left in this embedding. These orientations are illustrated in Figure~\ref{fig:tight}(c) and~(d), respectively.  We use this observation to design a simple -approximation to the {\sc tree augmentation} problem; that is, the algorithm is guaranteed to return an orientation that covers at least a half of the number of vertices that can be covered in an optimal orientation.

 \begin{figure}[ht]
\centerline{
\begin{picture}(0,0)\includegraphics{tight_fig}\end{picture}\setlength{\unitlength}{1973sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(7741,3144)(1718,-3347)
\end{picture} 	}
    \caption{The optimal solution (b) to the input problem (a) covers
       vertices whereas the
      left-to-right (c) and right-to-left (d) orientations cover
       vertices each.}
   \label{fig:tight}
 \end{figure}

\begin{theorem}\label{thm:2opt}
  The better of the two orientations  and  gives
  a -approximation to the {\sc tree augmentation} problem.
\end{theorem}

\begin{proof}
  Let  be the subset of vertices that are covered by
  .  Let  be the subset of vertices that
  cannot be covered by any orientation (namely, those vertices that
  are not endpoints of edges in ).  The remaining vertices  are the endpoints of the edges in .
  Each vertex in  is covered either by  or  (or both). Let  and , be the number of vertices
  covered by  and  , respectively.  We have . It follows that the
  number of vertices covered by the better of these two orientations
  has value:
  
  Since the maximum number of vertices that any orientation can cover
  is , the better of the two orientations
   and  is a -approximation to the {\sc tree
    augmentation} problem.  The example in Figure~\ref{fig:tight}~(b)
  illustrates that this analysis is asymptotically tight.
\qed
\end{proof} 

The -approximation algorithm generalizes to the weighted case, 
for which each node  carries a weight .
In the above proof we can simply replace the size of a node set
with the total weight from the set.
\begin{cor}
{\sc Weighted Tree Augmentation} admits a -approximation.
\end{cor}



\section{{\sc Tree Augmentation} is NP-hard}
\label{sec:hard}

In this section, we prove the following.
\begin{theorem}
\label{thm:hard}
{\sc Tree Augmentation} is NP hard.
\end{theorem}
Our reduction is from the well-known NP-hard {\sc set cover} problem~\cite{GJ79}. 
An instance of {\sc set cover} consists of a set of elements , a
collection of subsets of ,  and an
integer .  The {\sc set cover} problem asks: Is there a
subcollection  such that  and ?

We prove Theorem \ref{thm:hard} in three steps. 
First, we start by describing the gadget which models {\sc set cover} as an instance of {\sc tree augmentation}.
Second, we describe the intuition behind our result. 
Finally, we give the formal details of correctness.


\subsubsection*{The Reduction}  
We build an instance  of {\sc tree augmentation}
corresponding to an instance of {\sc set cover} as follows.  The construction is
illustrated in Figure~\ref{bad.fig}.

\paragraph{Vertices :} The root vertex is .  For each set  () we define 5 vertices .
  We call the vertices  the {\em set vertices}.
  For each element  () we
  define a set of  {\em element vertices} .
\paragraph{Tree arcs} : 
The tree  consists of the following arcs.
  \begin{enumerate}
	  \item There is a directed path in  consisting of the arcs 
		  for , followed by the arc .
		  We call this path the {\em collection path}.
	  \item For each set , there is a directed path in  through the vertices
     in order.  We call these the {\em set paths}.
  \item For each element , there is a directed path in  consisting of
	  the arcs  for .
    We call these the {\em element paths}.
  \item The arc  is in .
  \item For each ,  contains the arc 
  \end{enumerate}
\paragraph{Non-tree edges :}  For each set , we connect every
  element vertex (corresponding to the elements in ) to the
  corresponding set vertex with non-tree edges .  For each set  there are 4
  additional non-tree edges: .


\begin{figure}[htb]
\centerline{
\begin{picture}(0,0)\includegraphics[scale=1]{proof_fig}\end{picture}\setlength{\unitlength}{1973sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(11198,3891)(1861,-1030)
\put(9826,2714){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(12901,-361){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(11626,-361){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(10426,-961){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(10576,-361){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(8101,-1000){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6901,-1000){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4126,-1000){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5326,-1000){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2101,-1000){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1876, 14){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(9076,1064){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(8326,1439){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(9676,314){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3526,2039){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}edge in }}}}}
\put(3526,2339){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}arc in }}}}}
\put(2476,1664){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} }
\caption{NP-hardness construction.  The vertices  (and adjacent edges) are only shown for one set .}
\label{bad.fig}
\end{figure}

\subsubsection*{The Idea}
We start by noting that the orientation of  of the non-tree edges are forced in any acyclic orientation.
\begin{obs}\label{obs:forced}
In any feasible solution, i.e., any acyclic orientation, each edge  must
be oriented as  since otherwise  would form a directed cycle.
Similarly, in any feasible solution, each edge  must be oriented as  since otherwise  would form a directed cycle.
\end{obs}
Hence, in any feasible solution the  vertices  and  are covered.
So, the only remaining uncovered vertices are  for each  and the element vertices,  for each .

Notice that if  is oriented as  then no vertex  can
be covered for any ,  without forming a cycle.
However if  is oriented as  then each of those element vertices  can be covered by  and so we ``equate'' this case with choosing the set  as part of a solution to the set cover problem.
Thus minimizing the number of subsets  whose union is  will be seen
to be equivalent to maximizing the number of 's that are not covered.
This is the basic idea of our proof. 

\subsubsection*{The Proof}

  We show that there is a solution to the constructed instance of {\sc
    tree augmentation} that covers at least  vertices if and only
  if there is a solution to the instance of {\sc set cover}.

\paragraph{Solutions to {\sc set cover} imply solutions to {\sc tree
  augmentation}:}
  
Suppose there is a solution  to the {\sc
  set cover} instance, that is,  and .  Note that if  we can always
add subsets to the solution and it will still cover all the elements.
So, without loss of generality, we will assume that .
We orient a subset  so that it covers  vertices. Observation \ref{obs:complete} then says that the orientation of  can
be extended to an orientation of all of  that covers at least  vertices and
hence is a solution to the {\sc tree augmentation} instance.

\begin{description}
\item[: Forced edges] 
	As discussed earlier, the edges  and  are back edges and so must be oriented toward the root: .  	These arcs then cover the  vertices  and  for
	.

\item[: ] 
	For each , orient  and  as ,  respectively. These arcs then cover the  's where .
	Also for each , orient the edges  toward .  
	Since  covers the elements, each  will have at least one non-tree edge oriented away from it, and hence this covers all of the ,  vertices.
	Therefore the orientation of the edges of  cover  additional vertices. 	
	Note that adding the edges of  to  does not introduce any cycles because it only directs edges {\em from} the element paths {\em to} the set paths.
	
\item[: ] 
	For each , we orient the edge  as  and orient all the edges  away from .  
	The edges of  cover the  additional vertices  and  where . 
	Notice the solution is still acyclic, since for each , there is no arc directed into any vertex in the set .
	
\end{description}
It follows  is a feasible solution of size  as desired.  

\paragraph{No solution to {\sc set cover} implies no solution to
  {\sc tree augmentation}:}
Suppose there is no subcollection of  of size at most  that
covers all the elements of .  We will show that any feasible orientation of
the non-tree edges
 will cover less than  vertices.

We have two facts resulting from the existence of the set paths to the
root in  and directed paths from  through
all the element vertices and through the collection path to the root.
Since we assume all the non-tree edges are oriented (w.l.o.g.\ by
Observation~\ref{obs:complete}), the following facts must hold or else
there would be a directed cycle.
\begin{enumerate}[{Fact} 1]
\item If  is covered, then  is not covered. \label{fact1}

\item If  for some
   (), then  and  cannot be covered. \label{fact2}
\end{enumerate}

We have two cases: either some representative vertex  of each 
element  is
covered or there is some element  all of whose representatives
 are not covered.

We start with the former case.  Suppose that for each  there is some  such that  is
covered.  Let  be the subset of indices  such that
the 's are covered by edges oriented to  for .  As we assume that the best set cover requires more than  sets,
.  By Fact~\ref{fact2},  is not covered for any .  Then, by Fact~\ref{fact1}, it follows that for  at most 3
of  are covered.  Also note by Facts~1 and~2, at most  of  can be
covered for .  Therefore,  can cover at
most  vertices.

We now prove the latter case.  Suppose that for some ,  is not covered for any .
By Fact~\ref{fact1}, it follows that at most 4 of  are covered.  Therefore  can cover at
most  vertices.




\section{Bounded treewidth {\sc tree augmentation}}
\label{sec:boundedtw}

We show in this section that for  of bounded treewidth, {\sc tree
augmentation} can be solved optimally via dynamic programming.  {\em
Treewidth} is a measure of how far a graph is from being a tree.  It
is known that many NP-hard graph problems become tractable
in graphs of bounded treewidth~\cite{CM92}.
Formally,  has treewidth
 if there is a tree decomposition  of  where
each node  corresponds to
a subset  of ,
and  is a tree on , satisfying
the following four properties.
\begin{enumerate}
\item No more than  vertices of  are mapped to any one node
  of , i.e.  for .
\item 
 The union of  is  , i.e. every
vertex of  is mapped to some node of .
\item 
 For every edge  in ,  and  are mapped to some
  common node of .
\item 
If, for  and ,  and
 contain a common vertex of , then for all nodes 
of in the (unique) path between  and  in ,
 contains  as well.
\end{enumerate}
We may assume without loss of generality that  is a rooted
binary tree with  nodes~\cite{Bodlaender93}.  
Note that given a graph  and an integer  it is NP-hard to determine if the treewidth of  is at most ~\cite{ACP87}.
However, for any fixed constant , Bodlaender gives a linear time algorithm which determines if a graph  has treewidth at most , and if so, finds a tree-decomposition of  with treewidth at most  in linear time~\cite{Bod96}.


In this section, we prove:
\begin{theorem}\label{thm:tw}
For any constant , and any graph  of treewidth at most ,
{\sc Tree augmentation} 
can be solved in linear time using dynamic programming.
\end{theorem}

\begin{proof}
Let   be a tree decomposition of  of treewidth at most .
Since  is rooted, for each node , we can define  as the subtree of  rooted at .
For a tree node  of , let  be the subgraph of  whose vertex set is  and edge set is .  

For each tree node  of , each permutation  of the vertices of  
and each subset  of , we determine two tables,  and :
\begin{enumerate}
\item [(i)]  is an optimal orientation of the edges 
that is consistent with permutation  and covers exactly the vertices , such that the number of vertices covered by  is maximized.
\item [(ii)]  is the number of vertices covered by 
\end{enumerate}
If a permutation  contradicts the partial order on the vertices enforced by , then we set {\sc Tab} and  for all .  Likewise, if no orientation of  can cover , we set {\sc Tab} and  for all permutations  of .  For simplicity of presentation, we assume that all entries of {\sc Tab} are initialized to  and all entries of  are initialized to .

For the root  of , it follows that the maximum of  taken over all permutations  and subsets  of  is the value of an optimal solution and the corresponding  is an optimal solution.
Hence, to complete the proof of Theorem \ref{thm:tw}, it is enough to show how to determine the entries of our dynamic programming table.
We do so in two steps.
First, we determine the entries of {\sc Tab} for each leaf .
Second, we determine the entries of {\sc Tab} for each non-leaf node  given that the entries of {\sc Tab} and {\sc Tab} for its associated child nodes,  and , have already been determined.  

Assume   is a leaf node.  For each permutation  that is consistent with ,  be the orientation of the edges of  implied by  and let  be the subset of  covered by .  By construction,  {\sc Tab} contains the desired entries.

Assume  is an internal node such that the {\sc Tab} entries associated with the children of , namely  and , have been computed.  
We consider all permutations  of  and  of  together with all subsets  and .
We use the entries of  and  to construct .
Now, not all choices of  and  lead to valid solutions.
Indeed, the partial order given by the permutation  must be consistent with ; analogously  must be consistent with . 
Additionally, if  is in  and  then  must also be ; the analogous condition holds for . 
For , we call  and   {\em good} if they satisfy these conditions.
We now show that 

and  can be determined from the entries of {\sc Tab} and {\sc Tab}.


Fix a permutation  and subset  of .
Let  be any orientation of  that is valid with respect to  and .
Let  be the vertices covered in  and  be the vertices covered in .
By the fourth property of tree decompositions, the number of vertices covered by  is exactly .
Letting  be the restriction of  to , for any good  and  we have 
Hence,  and so, 

Similarly, 
Hence, 
 is at most the righthand side of Equation \ref{eqn1}.

To complete the proof it is enough to show there exists good  and good  such that the corresponding entries of  and  can be used to give an acyclic orientation of value equal to the righthand side of Equation \ref{eqn1}.
Let good  be chosen to maximize , and let good  be chosen to maximize .
We first orient the edges  by the permutation .  
By the fourth property of tree decompositions, every remaining edge is completely contained in either  or completed contained in .
For these edges we use the orientations of  and , respectively.  
Clearly, this orientation covers the desired number of nodes; it only remains to show it is acyclic.  

For the purpose of contradiction, let  be such that the permutation  places  before  but {\sc Path}, a directed path from  to , already exists. 
If there are multiple such paths, we choose the shortest path.
If {\sc Path} contains an internal node , then
{\sc Path} and {\sc Path} are also directed paths. Since
{\sc Path} is the shortest, the permutation  must ensure that  is before  and  is before . However,  also enforces  is before
, which is a contraction.
Therefore, none of the internal nodes in {\sc Path} can be in
. By properties 3 and 4 of the tree decomposition, every
internal node of {\sc Path} must be contained entirely in one
of the subtrees, say the one rooted at . In addition,  and
 must be contained in .  If a permutation
 ensures  is before  then  and  would be
inconsistent; if  ensures  is before  then  would be a
earlier node in which a cycle appears.
It now follows that  is the desired orientation.
Moreover, since we can compute it by considering the  possible choices for  and , it follows that it follows that constructing {\sc Tab} can be done in linear time.
\qed 
\end{proof}
The above dynamic programming argument generalizes to the 
weighted case, if we keep track of the node weights rather than 
the number of nodes.
\begin{cor}
For any constant , and any graph  of treewidth at most ,
{\sc Weighted Tree augmentation} 
can be solved using dynamic programming.
\end{cor}




\section{A PTAS for {\sc BFS tree augmentation} in planar graphs}
\label{sec:planar}

In this section we consider a special case in which the input graph
 is planar and  is the breath-first-search
(BFS) tree of . (Specifically, the  is a BFS tree of the
undirected version of .)  We show that Baker's technique, described in a moment,
can be used to design a polynomial-time approximation scheme (PTAS)
for this special case.  A PTAS is, for a fixed
integer , a polynomial (in ) time algorithm that finds a
solution of value achieving at least a  fraction of
the optimal solution's value.  


Baker's technique is a shifting technique for designing PTASes for
planar graph instances of problems~\cite{Baker1994}.  Baker introduced
this technique to solve NP-hard problems such as {\sc independent set}
and {\sc vertex cover}; the constraints for these problems are defined
locally, for neighborhoods of vertices.  Usually, Baker's technique
cannot be used to solve problems with a global constraints, such as
our acyclicity constraint.  However, the technique involves separating
the graph at BFS layers; when  is a BFS tree, we can guarantee
acyclicity across the separators.  We show how to use Baker's
technique here to prove:

\begin{theorem}\label{thm:planar} There is a PTAS for {\sc Tree augmentation} when the input is a planar graph  such that  is a BFS tree of .
\end{theorem}

\begin{proof}
Label each vertex with its BFS level from the root of .  Let
 be the subset of arcs and edges () that have one
endpoint in level  and one endpoint in level .  Let  for .

Let  be the connected components of .  Consider a component  of  and attach
all the nodes at the smallest level in  to a newly created root
node  by arcs to create ; these new arcs plus the arcs of
 forms a BFS spanning tree  directed toward
.  Since  has depth at most ,  has treewidth at
most  by way of:
\begin{theorem}[Baker~\cite{Baker1994}]
  Given a planar graph  with rooted spanning tree of depth  a
  tree decomposition of width at most  can be found in 
  time.
\end{theorem}


We are now able to describe the PTAS of Theorem \ref{thm:planar}.
By the algorithm of Section~\ref{sec:boundedtw}, we can optimally solve the {\sc tree augmentation} problem in each of the components of  in polynomial time. 
For each , compute the optimal solutions corresponding to each component of .  
Let  be the orientation given by the union of these solutions with the edges of  oriented from high-to-low BFS level.  
Return the best solutions of .
To complete the proof Theorem \ref{thm:planar}, it remains only to prove acyclicity and near-optimality:
\paragraph{Acyclicity} First notice that these orientations are
acyclic.  Any directed cycle in  would have to
include arcs in multiple components of  and, in
particular, would travel from a low BFS-level to a high
BFS-level and back, crossing  in each direction for some .  However, since  is a BFS tree, each arc in  is oriented from level  to level .  By design the edges
of  are also oriented from level  to level .
Therefore  is acyclic.
\paragraph{Near-Optimality} Let  be a minimal subset of  such that an optimal solution
 of  covers as many vertices
as an optimal solution for .  That is, every
vertex is the starting point for at most one arc of  and
so the maximum number of vertices that can be covered is .

 is a partition of a subset of .  Therefore

Consider the index  that is the argument the above minimum.
For each component  of , 
covers at least as many vertices as , since  is optimal for .  Therefore  covers
at least  vertices.  By
Inequality~\ref{ineq},  covers at least  vertices.
This completes the proof.
\qed \end{proof}
\begin{cor}
There is a PTAS for {\sc Weighted Tree augmentation} when the input is
a planar graph  such that  is a BFS
tree of .
\end{cor}

\section{Two-Arm {\sc tree augmentation}}
\label{sec:twoarm}
We consider a special case in which the tree  consists of
exactly two directed paths and give a polynomial-time dynamic program
for finding an optimal solution to {\sc tree augmentation}.  
has root  and two directed paths to the root: the {\em
  left arm} with vertices in order from leaf to root  and the {\em right arm}
with vertices in order from leaf to root .  We use inequalities to compare the indices of
these vertices (i.e.,  if ).

Any edge in  with both endpoints in a single
arm is a back edge and must be oriented toward the root; we denote
this orientation by  as in Section~\ref{sec:comp}.  Each cross
edge  has a left endpoint  and a right
endpoint .  We let  denote the
left-to-right orientation and  denote the
right-to-left orientation of .

We sort the cross edges first by left, then by right endpoint.  Namely
 such that  only if either
 or  and .  (Note that we may assume that there are no parallel edges as
all parallel edges would need to be oriented consistently to maintain
acyclicity.)  For each  and each  we determine
\vspace{-5mm}

(The notation  does not indicate orienting all the edges in
 from left to right.)  
Clearly, the solution to {\sc tree augmentation} is .

Note that the sets  are empty and so the values 
denote the number of vertices covered by .  We denote the
coverage by  by:

For any  and for , we determine  from
 for  and  for .  This
allows us to compute  via dynamic programming.

If , then  and so ; therefore .  If , then  and we take the better of two options:
 or .  
Refer to Figure~\ref{fig:2arm}.

\begin{figure}[ht]
\centerline{
\begin{picture}(0,0)\includegraphics[scale=1]{twoarm_fig}\end{picture}\setlength{\unitlength}{1973sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(4628,3656)(1718,-3634)
\put(5461,-2791){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6286,-2536){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6331,-736){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3136,-2536){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3181,-736){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2050,-3650){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{14.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}(a)}}}}}
\put(5350,-3650){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{14.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}(b)}}}}}
\put(2326,-2761){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} }
  \caption{The case in which  is oriented (a) , from left to right and (b) , from right to left.}
  \label{fig:2arm}
\end{figure}

In the  option, to ensure acyclicity, any edge in  that
shares 's endpoint must also be oriented from left to right.  
We define  such that  is the last edge of  with .
Any
acyclic orientation of  combined with this will also be
acyclic as any introduced cycle would go through 
which we have prevented.  The only additionally covered vertex is
 if it is not already covered by .
Formally, letting  be the last edge of  with :


In the  option, to ensure acyclicity, any edge in 
with right endpoint after  must also be oriented from right to
left. We define  such that . Note that  since
we are considering the case .
Any acyclic orientation of  combined with this will
also be acyclic as any introduced cycle would have to go through
, which we have prevented.  The right endpoints of these newly
oriented edges may become covered if they were not already covered by
.  Formally, letting :

It is not difficult to see that by storing these two options for
each value of  and , one can give a polynomial-time implementation
of the dynamic program.


\begin{theorem}
{\sc Tree augmentation} in the special case of 2 arms can be solved
optimally using dynamic programming in polynomial time.
\end{theorem}
It is easy to see the following generalization to the weighted case.
In the dynamic programming, instead of having binary  we have
 reflect the weight of node .  
\begin{cor}
{\sc Weighted Tree augmentation} in the special case of 2 arms can be
solved optimally using dynamic programming in polynomial time.
\end{cor}



\subsection*{Conclusion}
In this paper we study improving robustness in next-hop routing by
modeling it as a graph theoretic problem {\sc tree augmentation}.
This work leads to a number of open problems. For example, can the
dynamic programming approach be applied to more special cases?  We
note that the special case of multiple arms is not immediately
amenable to dynamic programming. More generally, what is the
complexity when the problem has a bounded number of leaves?  Does the
problem admit a better-than -approximation in the general case?



\bibliographystyle{plain} 
\bibliography{biblio}




\end{document}
