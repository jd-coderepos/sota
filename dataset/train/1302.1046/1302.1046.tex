\documentclass{LMCS}
\bibliographystyle{plain}

\def\doi{9(1:09)2013}
\lmcsheading {\doi}
{1--27}
{}
{}
{Jun.~16, 2011}
{Mar.~\phantom04, 2013}
{}
\usepackage{hyperref,enumerate}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{graphicx}
\usepackage[curve,cmtip]{xypic}
\usepackage{verbatim}
\usepackage{multirow}
\mathcode`:="003A  \mathcode`;="003B  \mathcode`?="003F  \mathcode`|="026A  \mathcode`<="4268  \mathcode`>="5269  

\mathchardef\ls="213C    \mathchardef\gr="213E    \mathchardef\uparrow="0222  \mathchardef\downarrow="0223  \newcommand{\blue}[1]{\textcolor{blue}{#1}}

\def\tr#1{\stackrel{#1}{\to}}
\def\pow#1{{\mathcal P_\omega}#1}
\def\D{{\mathcal D_\omega}}

\def\T{\mathbf{T}}
\def\C{\mathbf{C}}
\def\Set{\mathbf{Set}}

\newcommand{\bb}[1]{[\![ #1 ]\!]}
\setlength{\marginparwidth}{2cm}

\newtheorem*{remark}{Remark}
\begin{document}



\title{Generalizing determinization from automata to coalgebras}


\author[A.~Silva]{Alexandra Silva\rsuper a}   \address{{\lsuper a}Radboud University Nijmegen and Centrum Wiskunde \& Informatica} \email{ams@cwi.nl}  \thanks{{\lsuper a}The work of Alexandra Silva is partially funded by the ERDF through the Programme COMPETE and by the Portuguese Foundation for Science and
Technology, project ref. \texttt{PTDC/EIA-CCO/122240/2010} and \texttt{SFRH/BPD/71956/2010}.
}

\author[F.~Bonchi]{Filippo Bonchi\rsuper b}   \address{{\lsuper b}ENS Lyon, Universit\'{e} de Lyon, LIP (UMR 5668 CNRS ENS Lyon UCBL INRIA)} \email{filippo.bonchi@ens-lyon.fr}  \thanks{{\lsuper b}The work of Filippo Bonchi is supported by the CNRS PEPS project CoGIP and the project ANR 12IS02001 PACE}   

\author[M.~Bonsangue]{Marcello Bonsangue\rsuper c}   \address{{\lsuper c}LIACS - Leiden University} \email{marcello@liacs.nl}  

\author[J.~Rutten]{Jan Rutten\rsuper d}   \address{{\lsuper d}Centrum Wiskunde \& Informatica and Radboud University Nijmegen} \email{janr@cwi.nl}  \thanks{{\lsuper{c,d}}The research of Marcello Bonsangue and Jan Rutten has been carried out under the Dutch NWO project {\em CoRE: Coinductive Calculi for Regular Expressions.},
dossier number 612.063.920.}   


\keywords{Coalgebras, Powerset Construction, Linear Semantics} 
\ACMCCS{[{\bf Theory of computation}]: Models of
  computation---Abstract machines \& Formal languages and automata
  theory---Formalisms---Algebraic language theory \& Semantics and reasoning---Program semantics---Categorical semantics}
\subjclass{F.3.2}



\begin{abstract}
The powerset construction is a standard method for converting a
nondeterministic automaton into a deterministic one recognizing the 
same language. In this paper, we lift the powerset construction
from automata to the more general framework of coalgebras with structured
state spaces. Coalgebra is an abstract framework for the uniform study
of different kinds of dynamical systems. An endofunctor  determines
both the type of systems (-coalgebras) and a notion of behavioural
equivalence () amongst them. Many types of transition systems and
their equivalences can be captured by a functor . For example, for
deterministic automata the derived equivalence is language equivalence,
while for non-deterministic automata it is ordinary bisimilarity.

We give several examples of applications of our generalized determinization 
construction, including partial Mealy machines, (structured) Moore automata, Rabin
probabilistic automata, and, somewhat surprisingly, even pushdown automata.
To further witness the generality of the approach we show how to characterize
coalgebraically several equivalences which have been object of interest in
the concurrency community, such as failure or ready semantics.
\end{abstract}
\maketitle



\section*{Introduction}

\emph{Coalgebra} is by now a well established general framework for
the study of the behaviour of large classes of dynamical systems,
including various kinds of automata (deterministic, probabilistic
etc.) and infinite data types (streams, trees and the like). For a
functor  , an -coalgebra is a pair
, consisting of a set  of states and a function  defining the observations and transitions of the
states. Coalgebras generally come equipped with a standard notion of
equivalence called \emph{-behavioural equivalence} that is fully
determined by their (functor) type . Moreover, for most functors
 there exists a \emph{final} coalgebra into which any
-coalgebra is mapped by a unique homomorphism that identifies all
-equivalent states.

Much of the coalgebraic approach can be nicely illustrated with
deterministic automata (DA), which are coalgebras of the functor
\mbox{}. In a DA, two states are -equivalent
precisely when they accept the same language. The set  of
all formal languages constitutes a final -coalgebra, into which
every DA is mapped by a homomorphism that sends any state to the
language it accepts.

It is well-known that \emph{non-deterministic} automata (NDA)
often provide more efficient (smaller) representations of
formal languages than DA's. Language acceptance of NDA's is typically
defined by turning them into DA's via the \emph{powerset construction}.
Coalgebraically this works as follows.
NDA's are coalgebras of the functor , where
 is the finite powerset. An -coalgebra 
is \emph{determinized} by transforming it into a -coalgebra

(for details see Section~\ref{sec:motiv}).
Then, the language accepted by a state  in the NDA 
is defined as the language accepted by the state  in the DA
.

For a second variation on DA's, we look at
\emph{partial automata} (PA): coalgebras of the functor
, where for certain input letters
transitions may be undefined. Again, one is often interested
in the DA-behaviour (i.e., language acceptance) of PA's. This
can be obtained  by turning them into DA's using \emph{totalization}.
Coalgebraically, this amounts to the transformation of a -coalgebra
 into a -coalgebra
.

Although the two examples above may seem very different, they
are both instances of one and the same phenomenon, which it is
the goal of the present paper to describe at a general level.
Both with NDA's and PA's, two things happen at the
same time: (i) more (or, more generally, different types of)
transitions are allowed, as a consequence of changing
the functor type by replacing  by  and , respectively;
and (ii) the behaviour of NDA's and PA's is still given in
terms of the behaviour of the original DA's (language acceptance).

For a large family of -coalgebras, both (i) and (ii) can be
captured simultaneously with the help of the categorical
notion of \emph{monad}, which generalizes the notion of algebraic theory.
The structuring of the state space  can be expressed as a change of
functor type from  to . In our examples above, both the functors
 and  are monads,
and NDA's and PA's are obtained from DA's by changing the
original functor type  into  and .
Regarding (ii), one assigns -semantics to an -coalgebra
  by transforming it into an -coalgebra ,
again using the monad . In our examples above,
the determinization of NDA's and the totalization of PA's
consists of the transformation of  - and -coalgebras
 into -coalgebras  and ,
respectively.

We shall investigate general conditions on the functor types under
which the above constructions can be applied: for one thing, one has
to ensure that the  -coalgebra map  induces a suitable
-coalgebra map . 
Our results will lead to a uniform
treatment of all kinds of existing and new variations of automata,
that is, -coalgebras, by an algebraic structuring of their state
space through a monad . Furthermore, we shall prove a number of
general properties that hold in all situations similar to the ones
above. For instance, there is the notion of -behavioural
equivalence with which NDA's, being -coalgebras, come equipped.
It coincides with the well-known notion of Park-Milner bisimilarity
from process algebra. A general observation is that if two states in
an NDA are -equivalent then they are also - (that is,
language-) equivalent. For PA's, a similar statement holds. One
further contribution of this paper is a proof of these statements,
once and for all for all -coalgebras under consideration.

Coalgebras of type  were studied in~\cite{Lenisa99,bartels,jacobs05}. In~\cite{bartels,jacobs05}
the main concern was definitions by coinduction, whereas in~\cite{Lenisa99} a proof principle was also presented.
 All in all, the present paper can be seen as the understanding of the aforementioned papers from a new perspective, presenting a uniform view on various automata constructions and equivalences.

The structure of the paper is as follows. After preliminaries
(Section~\ref{sec:prelim}) and
the details of the motivating examples above (Section~\ref{sec:motiv}),
Section~\ref{sec:general} presents the general construction
 as well as many more examples, including the coalgebraic chracterisation of pushdown automata (Section~\ref{pda}).
In Section~\ref{sec:bisim_implies_trace}, a large family of automata
(technically: functors) is characterised to which the constructions
above can be applied. Section~\ref{secbbat} contains the application of the framework in order to recover several 
interesting equivalences stemming from the world of concurrency, such as failure and ready semantics. 
Section~\ref{sec:discussion} discusses related work and presents pointers to future work.

This paper is an extended version of~\cite{FSTTCS}. Compared to the conference version, we include the proofs and more examples. More interestingly, the characterisation of pushdown automata coalgebraically (Section~\ref{pda}) and the
material in Section~\ref{secbbat} are original.



\section{Background}~\label{sec:prelim}
In this section we introduce the preliminaries on coalgebras and
algebras. First, we fix some notation on sets. We will denote sets
by capital letters  and functions by lower case letters
 Given sets  and ,  is the cartesian
product of  and  (with the usual projection maps  and
),  is the disjoint union (with injection maps
 and ) and  is the set of functions . The collection of finite subsets of  is denoted by , while the collection of full-probability distributions with finite
support is f. For a set of letters
,  denotes the set of all words over ;  the
empty word; and  (and ) the concatenation of
words .

\subsection{Coalgebras} A coalgebra is a pair , where  is a set of states and  is a functor.
 The functor , together with the
function , determines the {\em transition structure} (or
dynamics) of the -coalgebra~\cite{Rutten00}.

An {\em -homomorphism\/} from an -coalgebra  to an
-coalgebra  is a function  preserving the
transition structure, {\em i.e.}, .

An -coalgebra  is said to be {\em final} if for
any -coalgebra  there exists a unique -homomorphism
 .
 All the functors considered in examples in this paper have a final coalgebra.

Let  and  be two -coalgebras. We say that the
states  and  are {\em behaviourally equivalent},
written , if and only if they are mapped into the same
element in the final coalgebra, that is .

For weak pullback preserving functors, behavioural equivalence coincides with the usual notion 
of bisimilarity~\cite{Rutten00}.
   
\subsection{Algebras}
Monads can be thought of as a generalization of algebraic theories.
A \emph{monad}  is a triple consisting of an
endofunctor  on  and two natural transformations: a
\emph{unit}  and a \emph{multiplication} .
They satisfy the following commutative laws

Sometimes it is more convenient to represent a monad , equivalently, as a \emph{Kleisli triple}
~\cite{Man76}, where  assigns a set  to each
set , the unit  assigns a function   to each set ,
and the extension operation   assigns  to each
 a function , such that,

for . Monads are frequently referred to
as \emph{computational types}~\cite{Moggi}. We list now a few examples. In what follows,  and .


\paragraph{\textbf{Nondeterminism}} ;  is the singleton map ;  .
\paragraph{\textbf{Partiality}}  where  represents a terminating (or diverging) computation;  is the injection map ;  and .

\smallskip

\noindent\textbf{Further examples} of monads include: exceptions (), side-effects
(), interactive output () and full-probability (). We will use all these monads in our examples and we
will define  and  for each later in
Section~\ref{sec:examples}.

\medskip

A \emph{-algebra} of a monad  is a pair  consisting of a set , called
carrier, and a function   such that 
and . A -homomorphism between two -algebras  and 
is a function  such that . -algebras and their
homomorphisms form the so-called \emph{Eilenberg-Moore category}
. There is a forgetful
functor  defined by



The forgetful functor  has left adjoint ,
mapping a set  to its free -algebra. If  with 
a -algebra, the unique -homomorphism 
with  is given by



The function  coincides with
function extension for a Kleisli triple.
For the monad  the associated Eilenberg-Moore category is the category of
join semi-lattices, whereas for the monad  is the category of pointed sets.
\section{Motivating examples}~\label{sec:motiv}
In this section, we introduce two motivating examples. We will present two constructions,  the determinization of a non-deterministic
automaton and the totalization of a partial automaton, which we will later show to be an instance of the same, more general, construction.

\subsection{Non-deterministic automata}
A deterministic automaton (DA) over the input alphabet  is a pair
, where  is a set of states and  is a function with two components: , the output
function, determines if a state  is final () or not
(); and , the transition function, returns for each
input letter  the next state. DA's are coalgebras for the functor
. The final coalgebra of this functor is
 where  is the set of
languages over  and , given a language ,
determines whether or not the empty word is in the language
( or , resp.) and, for each input
letter , returns the {\em derivative} of : .
From any DA, there is a unique map  into  which assigns
to each state its behaviour (that is, the language that the state
recognizes).

A non-deterministic automaton (NDA) is similar to a DA but the
transition function gives a set of next-states for each input letter
instead of a single state. Thus, an NDA over the input alphabet 
is a pair , where  is a set of states and
 is a pair of functions
with  as before and where  determines for each input
letter  a set of possible next states. In order to compute the
language recognized by a state  of an NDA , it is
usual to first determinize it, constructing a DA
 where the state space is , and
then compute the language recognized by the state  of
. Next, we describe in coalgebraic terms
how to construct the automaton .

Given an NDA , we construct
, where, for
all , , the functions  and  are
 
(Observe that these definitions exploit the join-semilattice structures of  and ).

The automaton
  is such that the language 
recognized by  is the same as the one recognized by  in
the original NDA  (more generally, the language
recognized by state  of  is the union
of the languages recognized by each state  of ).



We summarize the situation above with the following commuting diagram:

We note that the language semantics of NDA's,
presented in the above diagram, can also be obtained as an instance of
the abstract definition scheme of -coinduction~\cite{bartels,jacobs05}.
\subsection{Partial automata}
A partial automaton (PA) over the input alphabet  is a pair
 consisting of a set of states  and a pair of
functions .
Here  is the same as with DA. The second function  is
a transition function that sends any state  to a function
, which for any input letter 
is either undefined (no -labelled transition takes place)
or specifies the next state that is reached.
 PA's are coalgebras for the functor
.  Given a PA , we can
construct a total (deterministic) automaton
 by adding an extra {\em sink} state to
the state space: every undefined -transition from a state  is then
replaced by a -labelled transition from  to the sink state.
More precisely, given a  PA , we construct
,
where

(Observe that these definitions exploit the pointed-set structures of  and ).

The language  recognized by a state  will be precisely the
language recognized by  in the original partial automaton.
Moreover, the new sink state recognizes the empty language. Again we
summarize the situation above with the help of following commuting
diagram, which illustrates the similarities between both
constructions:

\section{Algebraically structured coalgebras}\label{sec:general}

In this section we present a general framework where both motivating
examples can be embedded and uniformly studied. We will consider
coalgebras for which the functor type~ can be decomposed into a
transition type  specifying the relevant dynamics of a system and
a monad  providing the state space with an algebraic structure.
For simplicity, we fix our base category to be .



We study coalgebras  for a functor  and a
monad  such that  is a -algebra, that is  is the carrier of a -algebra
. In the motivating examples,  would be instantiated to
 (in both) and  to , for NDAs, and to  for
PAs. The condition that  is a -algebra would amount to
require that  is a join-semilattice, for NDAs, and
that  is a pointed set, for PAs. This is indeed the
case, since the set  can be regarded both as a join-semilattice
() or as a pointed set () and, moreover,
products and exponentials preserve the algebra structure.

The inter-play between the transition type  and the
computational type  (more precisely, the fact that  is a -algebra) allows each coalgebra  to be extended uniquely to a -algebra
morphism  which
makes the following diagram commute.

Intuitively,  is the
inclusion of the state space of the coalgebra  into the structured state space , and  is the extension of the coalgebra  to .

Next, we study the behaviour of a given state or, more
generally, we would like to say when two states  and  are
equivalent. The obvious choice for an equivalence would be
-behavioural equivalence. However, this equivalence is not
exactly what we are looking for. In the motivating example of
non-deterministic automata we wanted two states to be equivalent if
they recognize the same language. If we would take the equivalence
arising from the functor  we would be
distinguishing states that recognize the same language but have
difference branching types, as in the following example.

We now define a new equivalence, which {\em absorbs} the effect of the monad .

We say that two elements  and  in  are
\emph{-equivalent with respect to a monad} , written , if and only if .
The equivalence  is just -behavioural equivalence for the
-coalgebra .

If the functor  has a final coalgebra   , we can capture the semantic equivalence above in the following commuting diagram

Returning to our first example, two states  and  of an NDA (in
which  is instantiated to  and  to
) would satisfy  if and
only if they recognize the same language (recall that the final
coalgebra of  the functor  is ).

It is also interesting to remark the difference between the two
equivalences in the case of partial automata.
The coalgebraic semantics of PAs~\cite{jan99} is given in terms of pairs of
prefix-closed languages  where  contains the
words that are accepted (that is, are the label of a path leading to
a final state) and  contains all words that label any path (that
is all that are in  plus the words labeling paths leading to
non-final states). We describe  and   in the
following two examples, for the states  and :

Thus, the states  and  would be distinguished by
-equivalence (for  and ) but they are
equivalent with respect to the monad , ,
since they accept the same language.

We will show in Section~\ref{sec:bisim_implies_trace} that the
equivalence  is always contained in .
\subsection{Examples}\label{sec:examples}
In this section we show more examples of applications of the
framework above.


\subsubsection{Partial Mealy machines}
A partial Mealy machine is a set of states  together with a
function , where  is a set of
inputs and  is a set of output values. We assume that
 has a distinguished element
. For each state  and for each input  the automaton
produces an output value and either terminates or continues to a
next state.  Applying the framework above we will be
\emph{totalizing} the automaton, similarly to what happened in the
example of partial automata, by adding an extra state to the state
space which will act as a sink state.  The behaviour of the
totalized automaton is given by the set of causal functions from
 (infinite sequences of ) to , which we
denote by ~\cite{jan_mealy}. A function
 is causal if, for , the -th value of the output stream  depends
only on the first  values of the input stream .
In the diagram below, we define the final map
:

Here , , , ,
, ,
and  denotes the prefixing of the stream  with the element .

\subsubsection{Structured Moore automata}

In the following examples we look at the functor

for arbitrary sets  and  and an arbitrary monad
. The coalgebras of  represents Moore
automata with outputs in  and inputs in . Since  is a -algebra,  is a -algebra 
and the product of -algebras is still a -algebra, then  is a -algebra. 
For this reason, 
the (pair of) functions
 and 
lift to a (pair of) functions

The final coalgebra of  is
. We can characterize the final map ,
for all ,  and , by

Below we shall look at various concrete instances of this scheme,
for different choices of the monad .



\paragraph{\em Moore automata with exceptions}
Let  be an arbitrary set, the elements of which we think of
as exceptions. We consider the \emph{exception monad}
 which has the function  as its unit. We define the lifting
,
for any function ,
by .


An -coalgebra  will
associate with every state  an output value (either in  or an
exception in ) and, for each input , a next state or an
exception. The behaviour of a state , given by ,
will be a formal power series over  with output values in ;
that is, a function from  to . The final map
is defined as follows, for all , , , and
:

\paragraph{\em Moore automata with side effects}
Let  be an arbitrary set of so-called \emph{side-effects}.
We consider the monad , with unit  defined, for all 
and , by .
We define the lifting 
of a function 
by , for any  and ,
and with .

Consider an -coalgebra  and let us explain the intuition behind this
type of automaton type.
The set 
can be interpreted as the configurations of the automaton, where 
contains information about the state of the system and  about the
control of the system.
Using the isomorphism ,
we can think of  as a function that for each configuration in  provides
an output in  and the new state of the system in .
The transition function  gives a new configuration for each input
letter and current configuration, using again the fact that .
In all of this, a concrete instance of the set of side-effects
could be, for example, the set  of
functions associating memory locations to values.

The behaviour of a state  will be given by , where
the final mapping is as follows. For all , ,
 and , and
with , we have





\paragraph{\em Moore automata with interactive output}

Let  be an arbitrary set of \emph{outputs}. Consider the interactive output monad defined by
the functor  together with the natural transformation
, and for which the lifting
 of a function  is given by
.
We consider  -coalgebras

For , the above coalgebras coincide with \emph{(total) subsequential transducers}~\cite{helle}: 
 is the final output function;  is the
pairing of the output function and the next state-function.

The behaviour of a state  will be given by 
, where, for every 
, , is given by



\paragraph{\em Probabilistic Moore automata}
Consider the monad of probability distributions defined,
for any set , by

Its unit is given by the Dirac distribution, defined for  by

The lifting 
of a function  is given,
for any distribution 
and any ,  by

We will consider -coalgebras

More specifically, we take  which implies . For this choice of , the above -coalgebras are precisely
the \emph{(Rabin) probabilistic
automata}~\cite{rabin}.
Each state  has an output value in  and, for each
input ,  is a probability distribution of next states. The
behaviour of a state  is given by , defined below. Intuitively, one can think of 
as a probabilistic language: each word is associated with a value
.
The final mapping

is given, for any , , ,
and , by

It is worth noting that this exactly captures the semantics of
\cite{rabin}, while the ordinary  coincides with
\emph{probabilistic bisimilarity} of \cite{LarsenS91}.
Moreover  coincides 
with the trace semantics of probabilistic transition systems defined in \cite{HJS} (see Section 7.2 of \cite{JSS}). 



\subsection{Pushdown automata, coalgebraically}\label{pda}
\newcommand\pda{{\sc pda}}

Recursive functions in a computer program lead naturally to a stack of recursive function
calls during the execution of the program. In this section, we provide a coalgebraic model
of automata equipped with a stack memory. A \emph{pushdown machine} is a tuple ,
where  is set of control locations (states),  is a set of input symbols,  is a set of stack symbols,
and  is finite subset of , called the set of
transition rules. Note that we do not insist on the sets ,  and  to be finite and
consider only \emph{realtime} pushdown machines, i.e. without internal
transitions (also called -transitions)~\cite{HU79}. A {\em configuration} 
of a pushdown machine  is a pair  denoting the current control state
 and the current content of the stack . In denoting the
stack as a string of stack symbols we assume that the topmost symbol is written
first. There is a transition  if .
A convenient notation is to introduce for any string  the transition relation on configurations
as the least relation such that
\begin{enumerate}[(1)]
\item 
\item  if and only if  and .
\end{enumerate}
A \emph{pushdown automaton} (\pda) is a pushdown machine together with an initial configuration  and a
set  of accepting configurations. The sets of accepting configurations usually considered are
(1)  the set , where  is called the set of accepting states, or
(2) , but also (3)  for , or
(4)  for  a subset of .
A word  is said to be accepted by  a \pda\  if
  for some . A \pda\ with accepting configurations as in (1)
is said to be with accepting states, whereas, when they are as in (2) then the \pda\ is said to be 
accepting by empty stack. They both accept exactly proper context free languages (i.e. context 
free languages without the empty word)~\cite{ABB97}. 

Computations in a pushdown machine are generally non-deterministic and can cause a change in
the control state of the automaton as well as in its stack. For this reason we will model
the effects of the computations by means of the so-called \emph{non-deterministic side-effect}
monad~\cite{BHM00}. For a set of states , let  be the functor . It is a
monad when equipped with the unit , defined by ,
and the multiplication  given by

Note that, for a function , the extension  is defined by

Examples of algebras for this monad are  and . The latter can in fact
be obtained as a quotient of the former by equating those functions 
such that for all ,  if and only if .

Every pushdown machine  together with a set of accepting configurations 
induces a function  where  is  the functor  and
 is the monad defined above specialized for  (intuitively, side effects in a pushdown machine
are changes in its stack). The functions  and  are defined as

The transition function  describes the steps between \pda\ configurations and it is specified in
terms of the transition instructions  of the original machine.

From the above is clear that not every function  defines a pushdown
machine with accepting configurations, as, for example,  may depend on the whole stack  and not just on
the top element . Therefore we restrict our attention to consider functions
 such that
\begin{enumerate}[(1)]
\item 
\item ,
\end{enumerate}
Every  satisfying (1) and (2) above defines the pushdown machine  with
 and with accepting configuration .
The first condition is asserting that a machine is in a deadlock configuration when the stack is empty,
while the last condition ensures that transition steps depend only on the control state
and the top element of the stack. For this reason we will write 
for  indicating that the pushdown machine in the state  by reading an
input symbol  and popping  off the stack, can move to a control state  pushing the string
 on the current stack (here denoted by ).






Similarly to what we have shown in the examples of structured Moore automata, for every function
 there is a unique -coalgebra map ,
which is also a -algebra homomorphism. It is defined for all  and  as

We then have that a word  is \emph{accepted} by the \pda\  with  if
and only if . 

\smallskip

The above definition implies that for a given word  we can decide
if it is accepted by  from an initial configuration 
in exactly  steps (assuming there is a procedure to decide whether ). As a consequence, we cannot
use structured Moore automata to model Turing machines, for which the halting problem is undecidable: in general terms, 
for Turing machines, we would need internal transitions that do not consume input symbols.


\smallskip


We conclude with an example of our construction using a pushdown machine with control states , over an
input alphabet  and using stack symbols . The transitions rules  are given below:
\begin{center}
\end{center}
We take , meaning that ,  
and  in all other cases. By considering  as
initial configuration, we then have

meaning that the empty word is not accepted by the \pda\ . However, the word  is accepted:

In fact, the language accepted by the above pushdown automaton is . 
The structured states , their transitions and their outputs of (part of) the associated Moore automaton are given in Figure \ref{fig:pda1}.
\begin{figure}
\begin{tabular}{lcl}
\multirow{8}{*}{}
& \;\;\; &
\beta = \epsilon
\2em]
& & \beta = x
\2em]
& &  \;\;\;\;\;\;\;\;  
\2em]
\beta = s\beta'\beta = x\beta'
& &
\beta = s\beta'\beta = x\beta'
\
o(*)(\beta) = 1\; \mbox{if and only if}\; \beta = \epsilon
\;\;\;\;\; \mbox{ and }\;\;\;\;\;
t(*)(a)(b\beta) = \{ <*, \alpha\beta> \mid b\to a\alpha \in P \} \,.

\xymatrix{
\mbox{*} \ar@(l,u)^{a,s|sx} \ar@(u,r)^{a,s|x} \ar@(r,d)^-{b,x|\epsilon}
& &
\mbox{with  iff }
}
2em]
& & \beta = s\beta'
\2em]
& & \beta = s\beta'
\2em]
& & \beta = ss\beta'
\2em]
\beta = x& & \beta = xx\beta'
\2em]
\beta = xx& &
\beta = s
\end{tabular}\caption{The structured states , 
their transitions and their output of (part of) the Moore automaton associated to the \pda\  where , , 
,  is depicted on the left top,  and .}
\end{figure}


\medskip

The above characterization of context free languages over an alphabet  is different and complementary
to the coalgebraic account of context-free languages presented in~\cite{WBR11}. The latter, in fact,
uses the functor  for deterministic automata (instead of the Moore automata
with output in  above, for  a set of variables), and the idempotent semiring
monad  (instead of our side effect monad) to study different
but equivalent ways to present context-free languages: using grammars, behavioural differential
equations and generalized regular expressions in which the Kleene star is replaced by a
unique fixed point operator.

\section{Coalgebras and -Algebras}\label{sec:bisim_implies_trace}
In the previous section we presented a framework, parameterized by a
functor  and a monad , in which systems of type  (that
is, -coalgebras) can be studied using a novel equivalence
 instead of the classical . The only
requirement we imposed was that  has to be a -algebra.

In this section, we will present functors  for which the requirement of  being a
-algebra is guaranteed because they can be {\em lifted} to a functor  on -algebra.
For these functors, the equivalence  coincides with . In other words,
working on  -coalgebras in  under the novel  equivalence is the same
as working on -coalgebras on -algebras under the ordinary
 equivalence. Next, we will prove that for this class of functors and an arbitrary monad  the equivalence
 is contained in . Instantiating this result for our first motivating
example of non-deterministic automata will yield the well known fact that bisimilarity implies
trace equivalence.

Let  be a monad. An endofunctor  is
said to be the -\emph{algebra lifting} of a functor  if the following square commutes\footnote{This is
equivalent to the existence of a distributive law  ~\cite{Joh75}.}:

If the functor  has a -algebra
lifting  then  is the carrier of the algebra .  Functors that
have a -algebra lifting are given, for example, by those endo\-functors on 
constructed inductively by the following grammar

where  is an arbitrary set,  is the constant functor mapping
every set  to the carrier of a -algebra , and  is
an arbitrary functor. Since the forgetful functor  creates and preserves limits, both  and  have  a -algebra lifting if , ,
and  have. Finally,  has a -algebra lifting for every
endofunctor  given by the assignment . Note that we do not allow taking coproducts in the
above grammar, because coproducts of -algebras are not preserved
in general by the forgetful functor . Instead, one could
resort to extending the grammar with the carrier of the coproduct
taken directly in . For instance, if  is the (finite)
powerset monad, then we could extend the above grammar with the
functor .

All the functors of the examples in Sections \ref{sec:motiv} and \ref{sec:general}, as well as those in Section \ref{secbbat}, 
can be generated by the above grammar and, therefore, they have a -algebra lifting.

\medskip

Now, let  be a functor with a -algebra lifting and for which a final coalgebra  exists. If
 can be constructed as the limit of the final sequence (for example assuming the functor accessible~\cite{Ada74}),
then, because the forgetful functor  preserves and creates limits,  is the carrier
of a -algebra, and it is the final coalgebra of the lifted functor . Further,
for any -coalgebra , the unique -coalgebra homomorphism 
as in diagram (\ref{F-final}) is a -algebra homomorphism between  and .
Conversely, the carrier of the final -coalgebra (in ) is the final -coalgebra
(in ). 

Intuitively, the above means that for an accessible functor  with a -algebra
lifting , -equivalence in  coincides with -equivalence
with respect to  in . The latter equivalence is coarser than the
-equivalence in , as stated in the following theorem.
\begin{thm}\label{thm:main}
Let  be a monad. If  is an endofunctor on  for which a final coalgebra exists and with a -algebra lifting,
then  implies .
\end{thm}
\begin{proof}
We first show that there exists a functor from the category of
-coalgebras to the category of -coalgebras.

This functor maps each -coalgebra  into the -coalgebra
 and each -homomorphism 
into the -homomorphism .
In order to prove that this is a functor we just have to show that
 is an -homomorphism (i.e., the backward face of the
following diagram commutes).





Note that the front face of the above diagram commutes because  is
an -homomorphism. Also the top face commutes because  is
a natural transformation. Thus 
 and also  
Since  is the
unit of the adjunction, then there exists a unique
 in  such that . Since both  and
 are (by construction) morphisms in
, then .

Let  and  be two -coalgebras and  and  their morphisms into the final -coalgebra .
Let ,  and  be the corresponding -coalgebras and ,  and 
their morphisms into the final -coalgebra .


Since  is an -homomorphism, then by uniqueness,
.


\begin{center}

\end{center}


With the same proof, we obtain . 

Recall that for all  and , by definition,
 iff  and  iff .

Suppose that . Then,  and, finally,
.
\end{proof}


The above theorem  instantiates to the well-known facts: for NDA, where  and ,  that bisimilarity implies language
equivalence; for partial automata,  where  and , that equivalence of pairs of languages, consisting
of defined paths and accepted words, implies
equivalence of accepted words; for probabilistic automata, where  and , that probabilistic
bisimilarity implies probabilistic/weighted language equivalence. Note that, in general, the
above inclusion is strict.

\begin{remark}
Let  be an -coalgebra for a monad  and a functor . If
 is pointwise injective, then
 on the
-coalgebra  coincides with  on the extended
-coalgebra
~\cite{Rutten00,bartels}. If moreover  has a
-algebra
lifting then, by the above theorem (on the extended -coalgebra),   implies
. Combining
the two implications, it follows that hat  on the
-coalgebra  implies
 on the extended  -coalgebra . Finally,
under the assumption that  has a -algebra lifting, we also have
that 
the -coalgebra  implies  on the extended
-coalgebra
. This yields the following hierarchy of equivalences.

\end{remark}



\section{Beyond Bisimilarity and Traces}\label{secbbat}
The operational semantics of interactive systems is
usually specified by labeled transition systems (LTS's). The denotational semantics is given in terms of behavioural
equivalences, which depend the amount of branching structure
considered. Bisimilarity (full branching) is sometimes considered
too strict, while trace equivalence (no
branching) is often considered too coarse. The \emph{linear time / branching time spectrum}
~\cite{Glabbeek90} shows a taxonomy of many interesting equivalences lying in between bisimilarity and traces.



Labeled transition system are coalgebras for the functor  and the coalgebraic equivalence  coincides
with the standard notion of Park-Milner bisimilarity. In~\cite{PowerTuri}, it is shown a coalgebraic
characterization of traces semantics (for LTS's) employing Kleisli categories. 
More recently,~\cite{Monteiro08} have provided a characterization of trace, failure and
ready semantics by mean of ``behaviour objects''. Another coalgebraic approach~\cite{Klin04} relies on ``test-suite'' that, intuitively, 
are fragments of Hennessy-Milner logic.
In this section, we show that (finite) trace equivalence~\cite{Hoare78}, complete trace equivalence~\cite{Glabbeek90},
failures~\cite{BrookesHR84} and ready semantics~\cite{OlderogH86}
can be seen as special cases of .










\bigskip

Before introducing these semantics, we fix some notations. A
labeled transition system is a pair  where  is a set
of states and  is a function assigning to
each state  and to each label  a finite set of possible
successors states:  means that . Given a
word , we write  for 
and . When ,  iff
.
For a function ,  denotes the set
of all labels ``enabled'' by , i.e., , while  denotes the set
.




Let  be a LTS and  be a state. A \emph{trace}
of  is a word  such that  for some . A
trace  of  is \emph{complete} if  and  stops,
i.e., . A \emph{failure pair} of  is a
pair  such that  and . A \emph{ready pair} of  is a pair  such
that  and . We use ,
,  and  to denote,
respectively, the set of all traces, complete traces, failure pairs
and ready pairs of . For  ranging over  and , two states  and 
are -equivalent iff .

\bigskip

For an example, consider the following transition systems
labeled over . They are all trace equivalent because
their traces are . The trace  is also complete for ,
but not for the others. Only  and  are failure equivalent,
since  is a failure pair only of , while 
and  are failure pairs of ,  and , but not of
. Finally they are all ready different, since  is
a ready pair only of ,  is a ready pair of  and
 but not of , and  and  are ready pairs
only of  and .


We can now show that these equivalences are instances of
. We first show ready equivalence in details and
then, briefly, the others.

Take  and . For each set ,
consider the function 
defined for all  by
 This function allows to
transform each LTS  into the -coalgebra
. The latter has the same
transitions of , but each state  is ``decorated''
with the set
.

Now, by employing the powerset construction, we transform
 into the -coalgebra
, where, for all , , the
functions  and 
are


The final -coalgebra is 
where  is defined as usual.

Summarizing, the final map
 maps each  into a
function assigning to each word , the set . In other terms,
 iff .

For the state  depicted above,
, ,  and for all
the other words , .

\bigskip


The other semantics can be characterized in the same way, by
choosing different functors  and different functions
.




For failure semantics, take the same functor as for the ready semantics, that is  
and a new function 
defined  by 
The -coalgebra  has the same
transitions of the LTS , but each state  is ``decorated''
with the set .



For both trace and complete trace equivalence, take  (as for NDA). For trace equivalence,
 maps 
into . Intuitively,  is
an NDA where all the states are accepting.
For complete traces,  maps
 in  if  (and in
 otherwise).

By taking  instead of , we hope to be able to 
 characterize probabilistic trace, complete trace, ready and
failure as defined in \cite{JouS90}. 
















\section{Discussion}\label{sec:discussion}
In this paper, we lifted the powerset construction on automata to the
more general framework of -coalgebras.
Our results lead to a uniform treatment of several kinds of
existing and new variations of automata (that is,
-coalgebras) by an algebraic structuring of their state space through a monad .
 We showed as examples partial Mealy
machines, structured Moore automata, nondeterministic, partial and
 probabilistic automata. Furthermore, we have presented an interesting coalgebraic characterization of pushdown automata and showed how several behavioural equivalences stemming from 
 concurrency theory can be retrieved from the general framework. It is worth
mentioning that the framework instantiates to many other examples,
among which are \emph{weighted automata}~\cite{Schutzenberger61b}. These
are simply structured Moore automata for  and
 (for a semiring
)~\cite{gumm}.
It is easy to see that  coincides with weighted
bisimilarity~\cite{german}, while  coincides with
weighted language equivalence~\cite{Schutzenberger61b}.

\medskip

Some of the aforementioned examples can also be coalgebraically
characterized in the framework of~\cite{HJS,HasuoThesis}. There, instead of
considering -coalgebras on  and -coalgebras on
 (the Eilenberg-Moore category), -coalgebras on
 and -coalgebras on  (the
\emph{Kleisli} category) are studied. The main theorem of~\cite{HJS}
states that under certain assumptions, the initial -algebra is
the final -coalgebra that characterizes (generalized)
trace equivalence. The exact relationship between these two approaches has been studied in~\cite{JSS} 
(and, indirectly, it could be deduced from~\cite{BK} and~\cite{KK}). 
It is  worth to remark that many of our examples do not fit the framework in~\cite{HJS}: for instance, the exception, the
side effect, the full-probability and the interactive output monads do not fulfill their
requirements (the first three do not have a bottom element and the
latter is not commutative). Moreover, we also note
that the example of partial Mealy machines is not purely trace-like,
as all the examples in~\cite{HJS}.



The idea of using monads for modeling automata with non-determinism, 
probabilism or side-effects dates back to the ``-machines'' of~\cite{AM75} that, rather than coalgebras, rely on algebras. 
More precisely, the dynamic of a -machine is a morphism 
, where  is a functor and  is a monad (for instance the transitions of -structured Moore automata are 
a function  mapping a state and an input symbol into an element of ).
Analogously to our approach, each -machine induces an ``implicit -machine'' having  as state space. Many examples of this paper (like Moore automata) can be seen as -machines, but those systems that are essentially coalgebraic (like Mealy machines) 
do not fit the framework in~\cite{AM75}. 



\medskip

There are several directions for future research. On the one hand, we
will try to exploit \emph{-bisimulations up to }~\cite{Lenisa99,LenisaPW00}
as a sound and complete proof technique for .
On the other hand, we would like to lift many of those coalgebraic
tools that have been developed for ``branching equivalences'' (such
as coalgebraic modal logic \cite{ml,Lutz_expressivity} and
(axiomatization for) regular expressions~\cite{BRS09b}) to work with
the ``linear equivalences'' induced by .

We have pursued further the applications to decorated traces and the challenging modeling of the full linear-time spectrum in a separate paper~\cite{mfps}, work which we also plan to extend to probabilistic traces. 
\begin{thebibliography}{10}

\bibitem{Ada74}
J.~Ad\'{a}mek.
\newblock Free algebras and automata realization in the language of categories.
\newblock {\em Comment. Math. Univ. Carolinae}, 15:589--602, 1974.

\bibitem{AM75}
M. Arbib, and E. Manes.
\newblock Fuzzy machines in a category.
\newblock {\em Bull. Austral. Math. Soc.}, 13:169--210, 1975.

\bibitem{ABB97}
J.-M. Autebert, J. Berstel, and L. Boasson.
\newblock Context-Free Languages and Push-Down Automata.
\newblock In G. Rozenberg and  A. Salomaa (eds.), {\em Handbook of Formal Languages},
 Volume 1, pages 111-174. Springer-Verlag, 1997.

\bibitem{bartels}
F. Bartels.
\newblock {\em On generalized coinduction and probabilistic specification formats}.
\newblock PhD thesis, Vrije Universiteit Amsterdam, 2004.

\bibitem{BHM00}
N. Benton, J. Hughes, and E. Moggi.
\newblock Monads and Effects.
\newblock Course notes for {\em APPSEM Summer School}, 2000. Available on line at
  {\tt http://www.disi.unige.it/person/MoggiE/APPSEM00/BHM.ps}.

\bibitem{BK}
A. Balan, and A. Kurz.
\newblock On Coalgebras over Algebras. 
\newblock {\em Electronic Notes in Theoretical Computer Science}. 264(2): 47-62 (2010)

\bibitem{mfps}
F. Bonchi, M.M. Bonsangue, G. Caltais, J.J.M.M. Rutten, and A. Silva.
\newblock Final semantics for decorated traces,
\newblock In {\em Proceedings of MFPS}, ENTCS, Elsevier, 2012, to appear.

\bibitem{BRS09b}
M.M. Bonsangue, J.J.M.M. Rutten, and A. Silva.
\newblock An algebra for {K}ripke polynomial coalgebras.
\newblock In {\em Proceedings of 24th Annual IEEE Symposium on Logic In Computer
   Science (LICS 2009)}, pages 49--58. IEEE Computer Society, 2009.

\bibitem{BrookesHR84}
S.D. Brookes, C.A.R. Hoare and A.W. Roscoe.
\newblock A Theory of Communicating Sequential Processes.
\newblock {\em Journal of the ACM}, 31(3):560--599, ACM 1984.

\bibitem{german}
P. Buchholz.
\newblock Bisimulation relations for weighted automata.
\newblock {\em Theoretical Computer Science}, 393(1-3):109--123, Elsevier, 2008.

\bibitem{Cho62}
N. Chomsky.
\newblock Context Free Grammars and Pushdown Storage.
\newblock {\em Quarterly Progress Report}, volume 65, MIT Research Laboratory
   in Electronics, Cambridge, MA, 1962.

\bibitem{ml}
C. C\^{\i}rstea, A. Kurz, D. Pattinson, L. Schr{\"o}der, and Y. Venema.
\newblock Modal logics are coalgebraic.
\newblock {\em Computer Journal} 54(1):31--41, Oxford University Press, 2011.

\bibitem{Eve63}
R.J. Evey.
\newblock Application of Pushdown Store Machines.
\newblock In {\em Proceedings of the 1963 Fall Joint Computer Conference (AFIPS 1963)}, ACM, 1963.

\bibitem{Glabbeek90}
R.J. van Glabbeek.
\newblock The Linear Time-Branching Time Spectrum.
\newblock In E. Best (Ed.), {\em Proceedings of CONCUR 93}, volume 458 of
    {\em Lecture Notes in Computer Science}, pages 278--297. Springer, 1990.

\bibitem{Gre67}
S. Greibach.
\newblock A Note on Pushdown Store Automata and Regular Systems.
\newblock {\em Proceedings of the American Mathematical Society}, 18:263--268, American
  Mathematical Society 1967.

\bibitem{gumm}
H.P. Gumm and T. Schr{\"o}der.
\newblock Monoid-labeled transition systems.
\newblock {\em Electronic Notes in Theoretical Computer Science}, 44(1):184--203, Elsevier 2001.

\bibitem{helle}
H.H. Hansen.
\newblock Coalgebraising subsequential transducers.
\newblock {\em Electronic Notes in Theoretical Computer Science}, 203(5):109--129, 2008.

\bibitem{HasuoThesis}
I. Hasuo.
\newblock {\em Tracing Anonymity with Coalgebras}.
\newblock PhD thesis, Radboud University Nijmegen, 2008.

\bibitem{HJS}
I. Hasuo, B. Jacobs, and A. Sokolova.
\newblock Generic trace semantics via coinduction.
\newblock {\em Logical Methods in Computer Science}, 3(4):1--36, 2007.

\bibitem{Hoare78}
C. A. R. Hoare.
\newblock Communicating Sequential Processes.
\newblock {\em Communincation of the ACM.}, 21(8):666--677, ACM, 1978.

\bibitem{HU79}
J. Hopcroft, J. Ullman.
\newblock \emph{Introduction to Automata Theory, Languages, and Computation}.
\newblock Addison-Wesley, 1979.

\bibitem{jacobs05}
B. Jacobs.
\newblock Distributive laws for the coinductive solution of recursive equations.
\newblock {\em Information and Computation}, 204(4): 561-587, 2006.

\bibitem{JSS}
B. Jacobs, A. Silva, and A. Sokolova.
\newblock Trace Semantics via Determinization.
\newblock To appear in {\em Proceedings of CMCS 12}, in {\em Lecture Notes in Computer Science}. Springer, 2012. 

\bibitem{Joh75}
P.T. Johnstone.
\newblock Adjoint lifting theorems for categories of algebras.
\newblock {\em Bulletin London Mathematical Society}, 7:294--297, 1975.

\bibitem{JouS90}
C. Jou and S.A. Smolka.
\newblock Equivalences, Congruences, and Complete Axiomatizations for Probabilistic Processes.
\newblock In J. Baeten and J.W. Klop (eds), {\em  proceedings of CONCUR '90}, volume 458 of
  {\em Lecture Notes in Computer Science}, pages 367--383, Springer, 1990.

\bibitem{Klin04}
B. Klin.
\newblock A coalgebraic approach to process equivalence and a coinduction principle for traces.
\newblock \newblock {\em  Electronic Notes in Theoretical Computer Science}, 106:201--218, 2004.

\bibitem{KK}
C. Kissig, and A. Kurz. 
\newblock Generic Trace Logics.
\newblock In {\em arXiv:1103.3239v1 [cs.LO]}, 2011.

\bibitem{LarsenS91}
K.G. Larsen and A. Skou.
\newblock Bisimulation through probabilistic testing.
\newblock {\em Information and Computation}, 94(1):1--28, 1991.

\bibitem{Lenisa99}
M. Lenisa.
\newblock From Set-theoretic Coinduction to Coalgebraic Coinduction: some results, some problems.
\newblock {\em Electronic Notes in Theoretical Computer Science}, 19:2--22, Elsevier, 1999.

\bibitem{LenisaPW00}
M. Lenisa, J. Power and H. Watanabe.
\newblock Distributivity for endofunctors, pointed and co-pointed endofunctors, monads and comonads.
\newblock {\em Electronic Notes in Theoretical Computer Science}, 33:230--260, Elsevier, 2000.



\bibitem{Man76}
E. Manes.
\newblock {\em Algebraic theories}.
\newblock {\em Graduate Texts in Mathematics}, 26, Springer 1976.

\bibitem{Moggi}
E. Moggi.
\newblock Notions of computation and monads.
\newblock {\em Information and Computation}, 93(1):55--92, 1991.

\bibitem{Monteiro08}
L. Monteiro.
\newblock A Coalgebraic Characterization of Behaviours in the Linear Time - Branching Time Spectrum.
\newblock In {\em proceedings of the 19th International Workshop on Recent Trends in Algebraic
  Development Techniques (WADT 2008)}, volume 5486 of {\em Lecture Notes in Computer Science},
  pages 128--140. Springer, 2009.

\bibitem{OlderogH86}
E.-R. Olderog and C.A.R. Hoare.
\newblock Specification-Oriented Semantics for Communicating Processes.
\newblock {\em Acta Informaticae}, 21(1):9--66, 1986.

\bibitem{PowerTuri}
J. Power and D. Turi.
\newblock A Coalgebraic Foundation for Linear Time Semantics.
\newblock {\em  Electronic Notes in Theoretical Computer Science}, 160:305--29, 1999.

\bibitem{rabin}
M.O. Rabin.
\newblock Probabilistic automata.
\newblock {\em Information and Control}, 6(3):230--245, 1963.

\bibitem{Rutten00}
J.J.M.M. Rutten.
\newblock Universal coalgebra: a theory of systems.
\newblock {\em Theoretical Computer Science}, 249(1):3--80, Elsevier, 2000.

\bibitem{jan_mealy}
J.J.M.M. Rutten.
\newblock Algebraic specification and coalgebraic synthesis of mealy automata.
\newblock {\em Electronic Notes in Theoretical Computer Science}, 160:305--319, 2006.

\bibitem{jan99}
J.J.M.M. Rutten.
\newblock Coalgebra, concurrency, and control.
\newblock In R.~Boel and G.~Stremersch (eds.), {\em proceedings of the 5th Workshop
  on Discrete Event Systems (WODES 2000)}, pages 31--38,  Kluwer, 2000.

\bibitem{Lutz_expressivity}
L. Schr{\"o}der.
\newblock Expressivity of coalgebraic modal logic: The limits and beyond.
\newblock {\em Theoretical Computer Science}, 390(2-3):230--247, Elsevier, 2008.

\bibitem{Schutzenberger61b}
M.P. Sch{\"u}tzenberger.
\newblock On the definition of a family of automata.
\newblock {\em Information and Control}, 4(2-3):245--270, 1961.

\bibitem{Sch63}
M.P. Sch\"{u}tzenberger.
\newblock On Context Free Languages and Pushdown Automata.
\newblock {\em Information and Control}, 6:246-264, 1963.

\bibitem{FSTTCS}
A. Silva, F. Bonchi, M. Bonsangue and J. Rutten.
\newblock Generalizing the powerset construction, coalgebraically.
\newblock In proceedings of {\em IARCS Annual Conference on Foundations
  of Software Technology and Theoretical Computer Science, (FSTTCS 2010)},
  volume 8 of {\em LIPIcs}, pages 272 -- 283, Schloss Dagstuhl - Leibniz-Zentrum
  fuer Informatik, 2010.


\bibitem{WBR11}
J. Winter, M.M. Bonsangue, J.J.M.M. Rutten.
\newblock Context-Free Languages, Coalgebraically.
\newblock In A. Corradini, B. Klin, and C. Cirstea, (eds.), {\em Proceedings of
   4th Int. Conference on Algebra and Coalgebra in Computer science (CALCO 2011)},
   volume 6859 of {\em Lecture Notes in Computer Science}, pages 359-376, Springer, 2011.

\end{thebibliography}








\end{document}
