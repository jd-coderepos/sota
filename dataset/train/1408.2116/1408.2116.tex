
\documentclass[11pt,letterpaper,onecolumn]{article}

\usepackage{times}
\usepackage{graphicx}                         
\usepackage{latexsym}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{epsfig}
\usepackage{theorem}
\usepackage{dsfont}
\usepackage{pstricks,pst-node,pst-plot,fancyheadings}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage{multirow}




\newcommand{\N}{\mathds{N}}
\newcommand{\Z}{\mathds{Z}}




\newtheorem{thm}{Theorem}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\newtheorem{lemma}{Lemma}
\newenvironment{proof}{\noindent \begin{rm}{\textbf{Proof.} }}{\hspace*{\fill}\par\end{rm} \vspace{.3cm}}
\newtheorem{spec}{Specification}
\newtheorem{claim}{Claim}
\newtheorem{rem}{Remark}



\newcommand{\id}{\mbox{ID}}



\begin{document}




\title{Self-stabilizing algorithms for Connected Vertex Cover and Clique decomposition problems}

\author{Fran\c{c}ois Delbot\\
Universit\'{e} Paris Ouest Nanterre / LIP6, CNRS UMR 7606.\\4 place Jussieu, 75252 Paris Cedex, France.\\ \texttt{francois.delbot@lip6.fr}\\
\and Christian Laforest\\
Universit\'{e} Blaise Pascal / LIMOS, CNRS UMR 6158, ISIMA.\\Campus scientifique des C\'{e}zeaux, 24 avenue des Landais, 63173 Aubiere cedex, France.\\ \texttt{christian.laforest@isima.fr}\\
\and Stephane Rovedakis\\
Conservatoire National des Arts et M\'{e}tiers / CEDRIC, EA 4629.\\292 rue Saint-Martin, F-75141 Paris Cedex 03, France.\\ \texttt{stephane.rovedakis@cnam.fr}
}


\maketitle


\begin{abstract}
In many wireless networks, there is no fixed physical backbone nor centralized network management. The nodes of such a network have to self-organize in order to maintain a virtual backbone used to route messages. Moreover, any node of the network can be \textit{a priori} at the origin of a malicious attack. Thus, in one hand the backbone must be fault-tolerant and in other hand it can be useful to monitor all network communications to identify an attack as soon as possible. We are interested in the minimum \emph{Connected Vertex Cover} problem, a generalization of the classical minimum Vertex Cover problem, which allows to obtain a connected backbone. Recently, Delbot \emph{et al.}~\cite{DelbotLP13} proposed a new centralized algorithm with a constant approximation ratio of  for this problem. In this paper, we propose a distributed and self-stabilizing version of their algorithm with the same approximation guarantee. To the best knowledge of the authors, it is the first distributed and fault-tolerant algorithm for this problem. The approach followed to solve the considered problem is based on the construction of a connected minimal clique partition. Therefore, we also design the first distributed self-stabilizing algorithm for this problem, which is of independent interest.\\

\textbf{Keywords:} Distributed algorithms, Self-stabilization, Connected Vertex Cover, Connected Minimal Clique Partition.
\end{abstract}



\section{Introduction}

In many wireless networks, there is no fixed physical backbone nor centralized network management. In such networks, the nodes need to regularly flood control messages which leads to the "broadcast  storm  problem"~\cite{NiTCS99}. Thus, the nodes have to self-organize in order to maintain a virtual backbone, used to route messages in the network. Routing messages are only exchanged inside the backbone, instead of being broadcasted to the entire network. To this end, the backbone must be connected.
The construction and the maintenance of a virtual backbone is often realized by constructing a Connected Dominating Set. A \emph{Connected Dominating Set (CDS)} of a graph  is a set of nodes  such that  (the graph induced by  in ) is connected and each node in  has at least one neighbor in . Nodes from  are responsible of routing the messages in the network, whereas nodes in  communicate by exchanging messages through neighbors in . In order to minimize the use of resources, the size of the backbone (and thus of the  CDS) is minimized. This problem is NP-hard~\cite{GJ79} and has been extensively studied due to its importance for communications in wireless networks. Many algorithms have been proposed in centralized systems (e.g., see~\cite{BlumDTC99} for a survey). In addition to message routing, there is the problem of network security. Indeed, a faulty node infected by a virus or an unscrupulous user can be at the origin of flooding or a malicious attack. Thus, it is necessary to monitor all network communications to identify these situations, as soon as possible, in order to isolate this node. A CDS  will not support this feature since two nodes in  can be neighbors, i.e,  is not always an independent set.

In order to monitor all network communications, we can consider the Vertex Cover problem. A \emph{vertex cover} of a graph  is a set of nodes  such that each edge  is \emph{covered} by , i.e.,  or  (or both). A vertex cover is \emph{optimal} if it's size is minimum. This is a classical NP-complete problem~\cite{GJ79} that can be approximated with a ratio of . However, if a vertex cover allows to monitor all network communications, it is not always connected and cannot be used as a backbone. A \emph{Connected vertex cover}  of  is a vertex cover of  with the additional property that  (the graph induced by  in ) is connected. Similarly, an \emph{optimal} connected vertex cover is one of minimum size and the associated problem is also NP-complete. Not a lot of work has been done on this problem (see~\cite{Savage82,EscoffierGouvesMonnot10}). More recently, Delbot \emph{et al.} in~\cite{DelbotLP13} proposed another (centralized) -approximation algorithm based on connected clique partitions of .

In practice, it is more convenient to use distributed and fault-tolerant algorithms, instead of centralized algorithms due to the communications cost to obtain the network topology. \emph{Self-stabilization} introduced first by Dijkstra in~\cite{Dijkstra74,Dolev2000} is one of the most versatile techniques to ensure a distributed system to recover a correct behaviour. A distributed algorithm is self-stabilizing if after faults and attacks hit the system and place it in some arbitrary global state, the system recovers from this catastrophic situation without external (e.g., human) intervention in finite time. Many self-stabilizing algorithms have been proposed to solve a lot of graph optimization problems, e.g., Guellati and Kheddouci~\cite{GuellatiK10} give a survey for several problems related to independence, domination, coloring and matching in graphs. For the minimum CDS problem, Jain and Gupta~\cite{JainG05} design the first self-stabilizing algorithm for this problem. More recently, Kamei \emph{et al.}~\cite{KameiK10,KameiK12,KameiIY13} proposed several self-stabilizing algorithms with a constant approximation ratio and an additional property during the algorithm convergence.\\
However, as explained above a CDS does not meet all the desired properties. This is why we study the minimum connected vertex cover from a distributed and self-stabilizing point of view.

\paragraph{Contributions.}
We consider the minimum \emph{Connected Vertex Cover} problem in a distributed system subject to transient faults. In this paper, we propose a distributed and self-stabilizing version of the algorithm given recently by Delbot \emph{et al.}~\cite{DelbotLP13} for this problem while guaranteeing the same approximation ratio of 2. To the best of our knowledge, it is the first distributed and fault-tolerant algorithm for this problem. The approach followed to solve the considered problem is based on the construction of a \emph{Connected Minimal Clique Partition}. Therefore, we also design the first distributed self-stabilizing algorithm for this problem, which is of independent interest. Moreover, these algorithms works under the distributed daemon without any fairness assumptions (which is the weakest daemon).\\

The rest of this paper is organized as follows. The next section describes the model considered in the paper and the notations used. In Section~\ref{sec:cmcp}, we consider first the Connected Minimal Clique Partition problem. We give a state of the art related to the graph decomposition problem, then we present our self-stabilizing algorithm for this problem and prove its correctness. Section~\ref{sec:cvc} is devoted to the Connected Vertex Cover problem. We introduce first related works associated with this problem, then we give the self-stabilizing connected vertex cover algorithm that we propose and we give the correctness proof. Finally, the last section concludes the paper and present several perspectives.


\section{Model}
\label{sec:model}

\paragraph{Notations.}
We consider a network as an undirected connected graph  where  is a set of nodes (or {\em processors}) and  is the set of {\em bidirectional asynchronous communication links}. We state that  is the size of  () and  is the number of edges (). We assume that the graph  is a simple connected graph. In the network,  and  are neighbors if and only if a communication link (,) exists (i.e., (,)  ). Every processor  can distinguish all its links. To simplify the presentation, we refer to a link (,) of a processor  by the {\em label} . We assume that the labels of , stored in the set , are locally ordered by . We also assume that  is a constant input from the system.  and  are respectively the diameter and the maximum degree of the network (i.e., the maximal value among the local degrees of the processors). Each processor  has a unique identifier in the network, noted .

\paragraph{Programs.}In our model, protocols are {\em uniform}, i.e., each processor executes the same program. We consider the local shared memory model of computation. In this model, the program of every processor consists in a set of {\em variables} and an {\em ordered finite set of actions} inducing a {\em priority}. This priority follows the order of appearance of the actions into the text of the protocol. A processor can write to its own variable only, and read its own variables and that of its neighbors. Each action is constituted as follows:  The guard of an action in the program of  is a boolean expression involving variables of  and its neighbors. The statement of an action of  updates one or more variables of . An action can be executed only if its guard is satisfied. The {\em state} of a processor is defined by the value of its variables. The {\em state} of a system is the product of the states of all processors. We will refer to the state of 
a processor and the system as a ({\em local}) {\em state} and ({\em global}) {\em configuration}, respectively. We note  the set of all possible configuration of the system. Let  and  an action of  ().  is said to be {\em enabled} at  in  if and only if the guard of  is satisfied by  in . Processor  is said to be {\em enabled} in  if and only if at least one action is enabled at  in . When several actions are enabled simultaneously at a processor : only the priority enabled action can be activated.

Let a distributed protocol  be a collection of binary transition relations denoted by , on . A  of a protocol  is a  sequence of configurations ,,...,,,... such that, ,  (called a {\em step}) if  exists, else  is a terminal configuration.  means that the sequence is either finite (and no action of  is enabled in the terminal configuration) or infinite. All computations considered here are assumed to be maximal.  is the set of all possible computations of .

As we already said, each execution is decomposed into steps. Each step is shared into three sequential phases atomically executed:  every processor evaluates its guards,  a {\em daemon} (also called {\em scheduler}) chooses some enabled processors,  each chosen processor executes its priority enabled action. When the three phases are done, the next step begins. 

A {\em daemon} can be defined in terms of {\em fairness} and {\em distributivity}. In this paper, we use the notion of {\em unfairness}: the {\em unfair} daemon can forever prevent a processor from executing an action except if it is the only enabled processor. Concerning the {\em distributivity}, we assume that the daemon is {\em distributed} meaning that, at each step, if one or more processors are enabled, then the daemon chooses at least one of these processors to execute an action.

We consider that any processor  executed a {\em disabling} {\em action} in the computation step  if  was {\em enabled} in  and not enabled in , but did not execute any protocol action in . The disabling action represents the following situation: at least one neighbor of  changes its state in , and this change effectively made the guard of all actions of  false in .

To compute the time complexity, we use the definition of (asynchronous) \emph{round}. This definition captures the execution rate of the slowest processor in any computation. Given a computation  (), the \emph{first round} of  (let us call it ) is the minimal prefix of  containing the execution of one action (an action of the protocol or a disabling action) of every enabled processor from the initial configuration.  Let  be the suffix of  such that . The \emph{second round} of  is the first round of , and so on.


\section{Connected Minimal Clique Partition problem}
\label{sec:cmcp}

In this section, we consider a first problem whose aim is the partitioning of the input graph into subgraphs of maximal size in a distributed fashion, while maintaining a connectivity constraint between some subgraphs. More particularly, the goal is to decompose an input undirected graph  into a set of cliques of maximal size such that all cliques of size at least two are connected. The connectivity constraint can be used for communication facilities. In the following, we define more formally the Connected Minimal Clique Partition problem.

\begin{definition}[Connected Minimal Clique Partition]
\label{def:cmcp}
Let  be any undirected graph, and a \emph{clique} is a complete subgraph of . A clique partition  of  is \emph{minimal} if for all  the graph induced by  is not a clique. A minimal clique partition  is \emph{connected} iff for any pair of nodes  in , with  the non trivial cliques of the partition and , there is a path between  and  in the graph induced by .
\end{definition}

Since we consider that faults can arise in the system, we give in Specification~\ref{spec:cmcp} the conditions that a self-stabilizing algorithm solving the Connected Minimal Clique partition problem have to satisfy.

\begin{spec}[Self-stabilizing Connected Minimal Clique Partition]
\label{spec:cmcp}
Let  be the set of all possible configurations of the system. An algorithm  solving the problem of constructing a stabilizing connected minimal clique partition satisfies the following conditions:
\begin{enumerate}
\item Algorithm  reaches a set of terminal configurations  in finite time, and
\item Every configuration  satisfies Definition~\ref{def:cmcp}.
\end{enumerate}
\end{spec}

\subsection{Related works}

The decomposition of an input graph into patterns or partitions has been extensively studied in the literature, and also in the self-stabilizing context. Most of graph partitioning problems are NP-complete. For the graph decomposition into patterns, Ishii and Kakugawa~\cite{IshiiK02} proposed a self-stabilizing algorithm for the construction of cliques in a connected graph with unique nodes identifier. Each process has to compute the largest set of cliques of same maximum size it can belong to in the graph. A set of cliques is constructed in  computation steps assuming an unfair centralized daemon. Moreover, the authors show that there exists no self-stabilizing algorithm in arbitrary anonymous graphs for this problem. Neggazi \emph{et al.}~\cite{NeggaziHK12} considered the problem of decomposing a graph into a maximal set of disjoint triangles. They give the first self-stabilizing algorithm for this problem whose convergence time is  steps under an unfair central daemon with unique nodes identifier. Neggazi \emph{et al.}~\cite{NeggaziTHK13} studied later the uniform star decomposition problem, i.e., the goal is to divide the graph into a maximum set of disjoint stars of  leaf nodes. This is a generalization of the maximum matching problem which is a NP-complete problem constructing a maximum set of independent edges of the graph. Thus, a 1-star decomposition is equivalent to a maximum matching. The authors proposed a self-stabilizing algorithm constructing a maximal -star decomposition of the input graph in  asynchronous rounds and a (exponential) bounded number of steps under an unfair distributed daemon with unique nodes identifier.\\
A well studied problem related with graph decomposition is the maximum matching problem. Many works address the maximal matching problem which is polynomial. The first self-stabilizing algorithm for this problem has been proposed by Hsu \emph{et al.}~\cite{HsuH92}. The algorithm converges in  steps under a centralized daemon. Hedetniemi \emph{et al.}~\cite{HedetniemiJS01} showed later that the algorithm proposed by Hsu \emph{et al.} has a better convergence time of  steps under a centralized daemon. Goddar \emph{et al.}~\cite{GoddardHJS03} considered the construction of a maximal matching in ad-hoc networks and give a solution which stabilizes in  rounds under a synchronous distributed daemon. Manne \emph{et al.}~\cite{ManneMPT09} have shown that there exists no self-stabilizing algorithm for this problem under a synchronous distributed daemon in arbitrary anonymous networks. They proposed an elegant algorithm which converges in  rounds and  steps under an unfair distributed daemon in arbitrary networks with unique nodes identifier. Recently, several works consider the maximum matching problem to find an optimal or an approximated solution. Hadid \emph{et al.}~\cite{HadidK09} give an algorithm which constructs an optimal solution in  rounds under a weakly fair distributed daemon only in bipartite graphs. Manne \emph{et al.}~\cite{ManneMPT11} presented a self-stabilizing algorithm constructing a -approximated maximum matching in general graphs within  rounds and a (exponential) bounded number of steps under an unfair distributed daemon. Manne \emph{et al.}~\cite{ManneM07} proposed the first self-stabilizing algorithm for the maximum weighted matching problem achieving an approximation ratio of 2 in a (exponential) bounded number of steps under a centralized daemon and a distributed daemon. Turau \emph{et al.}~\cite{TurauH11a} gave a new analysis of the algorithm of Manne \emph{et al.}~\cite{ManneM07}. They showed that this algorithm converges in  steps under a centralized daemon and an unfair distributed daemon.\\
More recently, some self-stabilizing works investigated the graph decomposition into disjoint paths. Al-Azemi \emph{et al.}~\cite{Al-AzemiK11} studied the decomposition of the graph in two edge-disjoint paths in general graphs, while Neggazi \emph{et al.}~\cite{NeggaziHK12b} considered the problem of dividing the graph in maximal disjoint paths of length two.
Finally, the partitioning in clusters of the input graph has been extensively studied. Belkouch \emph{et al.}~\cite{BelkouchBCD02} proposed an algorithm to divide a graph of order  into  partitions of size . The algorithm is based on spanning tree constructions of height  and converges in  rounds under a weakly fair distributed daemon. Johnen \emph{et al.}~\cite{JohnenN09} studied the weighted clustering problem and introduced the notion of robustness allowing to reach quickly (after one round) a cluster partition. A cluster partition is then preserved during the convergence to a partition satisfying the clusterhead's weight. Bein \emph{et al.}~\cite{BeinDJV05} design a self-stabilizing clustering algorithm dividing the network into non-overlapping clusters of depth two, while Caron \emph{et al.}~\cite{CaronDDL10} considered the -clustering problem in which each node is at most at distance  from its clusterhead. Recently, Datta \emph{et al.}~\cite{DattaLDHR12} design a self-stabilizing -clustering algorithm guaranteeing an approximation ratio in unit disk graphs.\\

All the works presented above concern the graph decomposition problem using different patterns. However, none of them allow to construct a disjoint maximal clique partition of the graph. Note that Ishii and Kakugawa~\cite{IshiiK02} computes a set of maximal cliques which are not necessary disjoint. Moreover, the \emph{non trivial} cliques (with at least two nodes) of the partition must be connected. 

 In~\cite{DelbotLP13}, the authors are interested to the decomposition of an input graph in cliques while satisfying a connectivity property. They propose a centralized algorithm for the Connected Minimal Clique Partition problem (see Definition~\ref{def:cmcp}). The proposed algorithm constructs iteratively a set of maximal cliques . At the beginning of the algorithm,  is empty and a node  is randomly (with equiprobability) selected. A first maximal clique  containing  is added to  and all the nodes of  are marked in . Then for any iteration , any non marked node  neighbor of at least one marked node of  is randomly (with equiprobability) selected. As for the first clique, a new maximal clique containing  is greedily built among non marked nodes of . This procedure is executed 
iteratively while there is a non marked node in . As mentioned in~\cite{DelbotLP13}, every \emph{trivial} clique (clique of size one) in the constructed set  is neighbor of no other trivial clique. So the set of trivial cliques of any minimal partition computed by this algorithm induces an independent set of . Otherwise, it could be possible to merge two trivial cliques of  in order to obtain a clique of size two.

\subsection{Self-stabilizing construction}

In this subsection we present the self-stabilizing algorithm called  for the Minimal Clique Partition problem, a formal description is given in Algorithm~\ref{algo}.

\paragraph{General overview}

The self-stabilizing algorithm  is based on the approach proposed by Delbot \emph{et al.}~\cite{DelbotLP13} (see description in the precedent subsection). In order to design a distributed version of this approach, we consider here a designated node in the network called the \emph{root} node, noted  in the following, and distances (in hops) from  given in input at each node  noted . These distance values can be obtained by computing a BFS tree rooted at . Several self-stabilizing BFS algorithms can be used, e.g.,~\cite{HuangC92,DolevIM93,Johnen97,CournierRV11}. As described below, we use these information to define an order on the construction of the clique partition of the graph.\\
In the proposed algorithm, the construction of maximal cliques is performed starting from the root  and following the distances in the graph. Indeed, the pair \emph{(distance, node identifier)} allows to define a construction priority for the cliques. First of all, each node shares the set of its neighbors with its neighborhood, allowing for each node to know its 2-hops neighborhood. The 2-hops neighborhood is used by each node to identify amongs its neighbors the ones which can belong to its maximal clique. For each node , we define by \emph{candidate leaders} the set of neighbors  of  such that the pair  is lexicographically smaller than . In Algorithm , each node  can construct its maximal clique by selecting in a greedily manner a set of neighbors  such that (i) for any  we have  and (ii)  is a complete subgraph. This computation is performed by any node  which has not been selected by one of its candidate leaders. In this case,  is called a \emph{local leader}, otherwise  is no more a local leader and clears out its set . Each node selected by one of its candidate leaders has to accept only the selection of its candidate leader  of smallest pair . Finally, any local leader  which has initiated the construction of its maximal clique considers in its clique only the selected neighbors which have accepted 's selection.\\
The proposed algorithm maintains a connectivity property between non trivial cliques of the constructed partition. This is a consequence of the construction order of the maximal cliques, which follows the distances in the network from . Indeed, every non trivial clique  (that does not contain the root node ) is adjacent to at least another non trivial clique , such that  with  the local leader of the clique . Otherwise, by construction another local leader , with , selects the local leader  to belong to its maximal clique. As a consequence, the maximal clique  is removed. In fact, the algorithm constructs a specific clique partition among the possible partitions that the centralized approach proposed in~\cite{DelbotLP13} can compute.


\paragraph{Detailed description}

In the following, we give more details on the proposed algorithm . Our algorithm is composed of four rules executed by every node and five variables are maintained at each node:

\begin{itemize}
\item : this variable contains the set of neighbors of  which allows to each node to be informed of the 2-hops neighborhood,
\item : this variable is used to exchange the value of  with 's neighbors,
\item : this variable is used by  to indicate in its neighborhood the nodes selected by  (if  is a local leader),
\item : this variable contains the set of nodes which belong to the maximal clique of  (if  is a local leader),
\item : this variable stores the local leader in the neighborhood of .
\end{itemize}

As explained above, each node stores in variable  the set of its 1-hop neighborhood, this is done using the first rule -action of the algorithm which is executed in case we have . The information stored in this variable is used by each node in 's neighborhood for the computation of maximal cliques. For each node, the set of candidate leaders is given by Macro , and among this set of nodes the Macro  indicates the neighbors which have selected  for the construction of their own maximal clique. Every node  which is not selected by a candidate leader does not satisfy Predicate  and can execute -action to start the construction of its own maximal clique. The procedure  selects in a greedily manner the neighbors which forms with  a complete subgraph. By executing -action, a node  becomes a local leader by storing its identifier in its variable  and notifies with its variable  the neighbors it has selected using Procedure . -action can be executed by a node  only if  does not contain the correct set of selected neighbors, i.e., we have . Then, each node  selected by a candidate leader (i.e., which satisfies Predicate ) can execute -action to accept the selection of its candidate leader  of smallest pair . In this case, we say that  has been elected as the local leader of . This is given by Macro  and stored in the variable . -action is only executed if the variable  does not store the correct local leader for , i.e., we have . Finally, -action allows to each local leader  to establish the set of neighbors  which are contained in its maximal clique. This set is stored in variable  and is given by Macro  considering only the neighbors  of  which have elected  as their local leader (i.e., ). This last rule is executed only by local leaders 
which are not selected to belong to another clique (i.e.,  is not satisfied) and have not computed the correct set of neighbors contained in their maximal clique (i.e.,  and ).


\begin{algorithm}[t]
\caption{\quad Self-Stabilizing Connected Minimal Clique Partition algorithm for any \label{algo}}
\smallskip
\begin{scriptsize}
{\bf Inputs:}\\
\hspace*{1cm}: set of (locally) ordered neighbors of ;\\
\hspace*{1cm}: unique identifier of ;\\
\hspace*{1cm}: distance between  and the root (leader node);\\
{\bf Variables:}\\
\hspace*{1cm}: variable used to exchange the neighbor set  in 's neighborhood, ;\\
\hspace*{1cm}: variable used to exchange the distance  in 's neighborhood, ;\\
\hspace*{1cm}: variable used by  to select neighbors for the construction of its maximal clique, ;\\
\hspace*{1cm}: variable used to store the set of neighbors belonging to the maximal clique of , ;\\
\hspace*{1cm}: variable used to store the local leader of , ;

.\dotfill\ 

{\bf Macros:}\\
\begin{tabular}{lll}
 &  & \\
 &  & \\
 &  & \\
 &  & \\
\end{tabular}\\
.\dotfill\

{\bf Predicate:}\\
\begin{tabular}{lll}
 &  & \\
\end{tabular}\\
.\dotfill\

{\bf Procedure:}\\
Clique\_temp()
\begin{algorithmic}[1]
\STATE{}
\FORALL{}
\IF{}
\STATE{}
\ENDIF
\ENDFOR
\RETURN ;

\end{algorithmic}
.\dotfill\


{\bf Actions:}\\
\begin{tabular}{lllllll}
&& -  &  &  &  & ;\\
&& - &  &  &  & ;\\
&& - &  &  &  & ;\\
&& - &  &  &  & ;\\
\end{tabular}
\end{scriptsize}
\end{algorithm}

\paragraph{Example of an execution}

We illustrate with an example given in Figure~\ref{fig:ex_algo1} how the proposed algorithm  constructs a Connected Minimal Clique Partition. In this example, we consider a particular execution following the distances in the graph and we give only the correct cliques which are constructed by the algorithm. We consider the topology given in Figure~\ref{fig:ex_algo1}(a). First of all, each node exchanges its neighbors set using -action. The root node  cannot be selected by one of its neighbors, so by executing -action it becomes a local leader (i.e., ) and selects among its neighbors the nodes to include in its maximal clique, i.e., by indicating in its variable  the nodes 1, 2 and 5. Then, nodes 1, 2 and 5 detect that they have been selected by  (their unique possible candidate leader) and in response they elect  using -action. The node  executes -action to construct its maximal clique by adding in its variable  the nodes which have elected  as their local leader, i.e., nodes 1, 2 and 5, as illustrated in Figure~\ref{fig:ex_algo1}(b). Next, the nodes 3, 4 and 6 elect themselves as local leaders since they are not selected to belong to a clique. They execute -action to select among their neighbors of equal or higher distance those which forms a complete subgraph (including themselves), i.e., neighbors 10 and 15 for node 3, neighbor 7 for node 4 and neighbor 9 for 6. The selected neighbors execute -action to elect the single candidate leader neighbor which has selected them to join a clique. We remind that in case of a selection from multiple candidate leaders a selected node elects the candidate leader  of smallest pair  with Macro . Then, the local leaders 3, 4 and 6 execute -action to construct respectively their maximal clique as illustrated in Figure~\ref{fig:ex_algo1}(c). In the same way, nodes 8 and 12 become local leaders and select respectively no neighbor and neighbors 11 and 14 to join their clique. The neighbors selected by node 12 elect 12 as their local leader and node 12 constructs its maximal clique, while node 8 constructs a trivial clique as illustrated in Figure~\ref{fig:ex_algo1}(d). Finally, node 13 becomes a local leader and constructs a trivial clique as illustrated in Figure~\ref{fig:ex_algo1}(e), which gives the complete clique partition constructed by the algorithm.

\begin{figure}[!ht]
\begin{center}
\includegraphics[scale=0.6]{ex_algo1.eps}
\end{center}
\caption{Execution of Algorithm .}
\label{fig:ex_algo1}
\end{figure}

\subsection{Correctness proof}

\begin{definition}[Rank of a node]
The \emph{rank} of any node  is defined by the pair . Given two nodes , we say that the rank of  is higher than the rank of , noted , iff either , or  and .
\end{definition}

\begin{definition}[Selection of nodes]
A node  is \emph{selected} by a neighbor  of  if we have  and  (i.e., Predicate  is satisfied at ).
\end{definition}

\begin{definition}[Local leader]
\label{def:local_leader}
Given any clique partition  of a graph , a node  is a \emph{local leader} of a clique  if we have  and  is not selected (i.e., we have  at ).
\end{definition}

\begin{definition}[Rank of a clique]
Given any clique partition  of a graph , the rank associated to a clique  is equal to the rank of the local leader  of .
\end{definition}

\begin{rem}
\label{rem:total_order_clique}
Given any clique partition  of a graph , the rank of the cliques define a total order on the cliques of the partition in .
\end{rem}

\begin{definition}[Election of a local leader]
Let  be any graph and  a node selected by a local leader .  has \emph{elected}  to join its clique if we have .
\end{definition}

\begin{definition}[Correct clique]
\label{def:correct_clique}
Given a clique partition  of a graph , a clique  is \emph{correct} iff the following conditions are satisfied:
\begin{enumerate}
\item There is a single local leader  in ;
\item  has selected a subset  of its neighbors such that every neighbor  has a rank lower than 's rank and  is a maximal clique, i.e., ;
\item Every node  selected by  has elected  iff  is the local leader of highest rank in 's neighborhood, i.e., ;
\item Every node selected by  which has elected  belongs to the clique  of , i.e., .
\end{enumerate}
\end{definition}

\begin{definition}[Path]
In a graph , the sequence of nodes  is called a \emph{path} between  if . The nodes  and  are termed as the \emph{extremities} of . The length of  is noted .
\end{definition}

\begin{definition}[Legitimate configuration]
\label{def:config_legitime}
Let  be the set of all possible configuration of the system. A configuration  is legitimate for Algorithm  iff every clique constructed by a local leader in  satisfies Definition~\ref{def:correct_clique}.
\end{definition}


\subsubsection{Proof assuming a weakly fair daemon}

In the following we consider that for each node  the input  is correct, i.e.,  is equal to the distance (in hops) between  and  in . We begin the proof by showing in the above theorem that in an illegitimate configuration of the system there exists a node which can execute an action of Algorithm .

\begin{theorem}
\label{thm:cmcp_enable_action}
Let the set of configurations  such that every configuration  satisfies Definition~\ref{def:config_legitime}.  such that  is enabled in . 
\end{theorem}

\begin{proof}
Assume, by the contradiction, that  such that  no action of Algorithm~\ref{algo} is enabled at  in . According to Definition~\ref{def:config_legitime}, this implies that there exists a local leader  such that its clique  does not satisfy Definition~\ref{def:correct_clique}.\\
If Claim 1 of Definition~\ref{def:correct_clique} is not satisfied in  then this implies that there is at least two local leaders in . By definition of a local leader (see Definition~\ref{def:local_leader}), there is a node  in , , which satisfies Predicate . This implies that  has not been selected by , i.e.,  and . According to the formal description of Algorithm , Macro  returns the selected neighbors of  which has elected . So, since  and  then we have  and -action is enabled at , a contradiction. If Claim 2 of Definition~\ref{def:correct_clique} is not satisfied in  then this implies that either  has selected a subset of its neighbors  which does not form a maximal subgraph, i.e., we have , or the selected subset  does not define with  a complete subgraph, i.e., . According to the formal description of Algorithm , a local leader computes its selected neighbors using Procedure . So, we have  and -action is enabled at , a contradiction. If Claim 3 of Definition~\ref{def:correct_clique} is not satisfied in  then this implies that there exists a neighbor  selected by  such that  has not elected  while  has the highest rank in 's neighborhood, i.e., . According to the formal description of Algorithm , Macro  returns the neighbor of  which has the highest rank. Moreover, we have  since by hypothesis  has the highest rank in 's neighborhood. So, we have  and -action is enabled at , a contradiction. If Claim 4 of Definition~\ref{def:correct_clique} is not satisfied in  then this implies that there exists a selected neighbor  of  which does not belong to  while  has elected , i.e., . According to the formal description of Algorithm , Macro  returns the selected neighbors of  which have elected . So, we have  and -action is enabled at , a contradiction.
\end{proof}

To show the convergence of Algorithm  to a legitimate configuration, we now prove several sub-lemmas allowing to show that Algorithm  constructs a partition of correct cliques following the rank of the cliques (see Lemma~\ref{lem:construct_clique_prio}).

\begin{lemma}
\label{lem:N-action}
After executing -action at any node , -action is disabled at .
\end{lemma}

\begin{proof}
Assume, by the contradiction, that -action is enabled at any node  after its execution. If  can execute -action again then this implies that we have  or  which is due to a modification in 's neighborhood or a fault. This is a contradiction because we assume a static graph  and a system execution without faults until reaching a legitimate configuration starting from an arbitrary configuration. 
\end{proof}

In the following, we note  the set of nodes in  such that every node  is not selected by a neighbor of rank higher than , i.e.,  contains the set of local leaders in .

\begin{rem}
\label{rem:nodes_rank_clique}
A local leader  can only select a node  in its neighborhood such that .
\end{rem}

\begin{proof}
According to the formal description of Algorithm , Macro  returns the neighbors  of  such that . Moreover, Procedure  chooses nodes in the neighborhood of  which are not included in the set given by Macro  (see line 2 of Procedure ).
\end{proof}

\begin{lemma}
\label{lem:C1-action}
When -action is enabled at , it remains enabled until  executes it or .
\end{lemma}

\begin{proof}
Let  be a step. Assume, by the contradiction, that -action is enabled at  in  and not in  (i.e.,  in ) but  did not execute -action in . According to the hypothesis of the lemma, we assume that  in , so we have  in . Since  did not move in  and the variable  can only be modified locally by  by executing -action, we have  at  in , a contradiction.
\end{proof}

\begin{lemma}
\label{lem:select_clique}
The node  of highest rank selects the maximal subset of its neighbors which can belong to its clique  if  does not satisfy Claim 2 of Definition~\ref{def:correct_clique}.
\end{lemma}

\begin{proof}
According to the formal description of Algorithm , a local leader executes -action to select the maximal subset of its neighbors which can belong to its clique. Assume, by the contradiction, that the node  of highest rank does not select the maximal subset of its neighbors to belong to its clique  while  does not satisfy Claim 2 of Definition~\ref{def:correct_clique}. That is, -action is disabled or it is not the enabled action of highest priority at .\\
We first show that -action is enabled at . By definition of , we have  at . Moreover, Procedure  chooses in a deterministic greedy manner a maximal subset of 's neighbors which define with  a complete subgraph, i.e., satisfying . Since Claim 2 of Definition~\ref{def:correct_clique} is not satisfied, we have two cases: (i) either  has not selected a subset of neighbors defining with  a complete subgraph, i.e., we have , or (ii) the subset of neighbors selected by  is not maximal, i.e., we have . Thus, we have  and -action is enabled at , a contradiction.\\
We must show that -action is the enabled action of highest priority at . If -action is not the enabled action of highest priority at  then this implies that -action is always enabled. According to Lemma~\ref{lem:N-action}, after executing -action it is not enabled at , a contradiction. So, -action is disabled at . Moreover, according to Lemma~\ref{lem:C1-action} -action is enabled at  until it is executed.
\end{proof}

\begin{lemma}
\label{lem:C2-action}
When -action is enabled at , it remains enabled until  executes it or .
\end{lemma}

\begin{proof}
Let  be a step. Assume, by the contradiction, that -action is enabled at  and not in  (i.e.,  in ) but  did not execute -action in . According to the hypothesis of the lemma, we assume that  in , so we have  in . Since  did not move in  and the variable  can only be modified locally by  by executing -action (note that -action is disabled at  because we have ), we have  at  in . So, -action is enabled at  in , a contradiction.
\end{proof}

\begin{lemma}
\label{lem:elect_clique}
In any configuration , the nodes selected by the node  of highest rank in  elect  if the clique  constructed by  does not satisfy Claim 3 of Definition~\ref{def:correct_clique} in .
\end{lemma}

\begin{proof}
According to the formal description of Algorithm , a node executes -action to elect among its neighbors the local leader of highest rank which has selected it. Since the clique  of  does not satisfy Claim 3 of Definition~\ref{def:correct_clique}, there is a node  selected by the local leader  of highest rank which has not elected  in . Assume, by the contradiction, that  does not elect . That is, -action is disabled or it is not the enabled action of highest priority at  in .\\
We first show that -action is enabled at  in . Since  is selected by  we have  satisfied at . Assume, by the contradiction, that -action is disabled at . According to the hypothesis of the lemma, we assume that we have  at . According to the formal description of Algorithm , Macro  returns the identifier of the local leader in 's neighborhood of highest rank which has selected , i.e., by hypothesis of the lemma  returns . Thus, we have  and -action is enabled at  in , a contradiction.\\
We must show that -action is the enabled action of highest priority at . If -action is not the enabled action of highest priority at  then this implies that -action or -action are always enabled. According to Lemma~\ref{lem:N-action}, after executing -action it is not enabled at , a contradiction. So, -action is disabled at . Moreover, Predicate  is satisfied at  since it is selected by the local leader  and -action is disabled at , a contradiction. Moreover, according to Lemma~\ref{lem:C2-action} -action is enabled at  until it is executed.
\end{proof}

\begin{rem}
\label{rem:elect_clique}
In any configuration , any node  can belong to at most a single clique.
\end{rem}

\begin{proof}
This comes from the fact that in a configuration  any node  elects a single local leader using its local variable  either by executing -action if  is a local leader or by executing -action otherwise.
\end{proof}

\begin{lemma}
\label{lem:C3-action}
When -action is enabled at , it remains enabled until  executes it unless  or -action is enabled.
\end{lemma}

\begin{proof}
Let  be a step. Assume, by the contradiction, that -action is enabled at  and not in  (i.e.,  in ) but  did not execute -action in . According to the hypothesis of the lemma, we assume that  in , so we have  in . Since  did not move in  and the variable  can only be modified locally by  by executing -action, we have  at  in . So, -action is enabled at  in , a contradiction.
\end{proof}

\begin{lemma}
\label{lem:update_clique}
In any configuration , the node  of highest rank updates the set of nodes included in its clique  if  satisfies Claims 2 and 3 of Definition~\ref{def:correct_clique} but not Claim 4 of Definition~\ref{def:correct_clique}.
\end{lemma}

\begin{proof}
According to the formal description of Algorithm , a local leader executes -action to updates the maximal subset of its neighbors which belongs to its clique . Since the clique  of  satisfies Claims 2 and 3 of Definition~\ref{def:correct_clique} but not Claim 4 of Definition~\ref{def:correct_clique}, there is a neighbor  selected by  which has elected  but  does not consider that  is part of . Assume, by the contradiction, that the node  of highest rank does not updates the maximal subset of its neighbors which belong to its clique  while its clique  does not satisfy Claim 4 of Definition~\ref{def:correct_clique}. That is, -action is disabled or it is not the enabled action of highest priority at  in .\\
We first show that -action is enabled at  in . By definition of , we have . According to the hypothesis of the lemma, we have  since  has selected the subset of its neighbors which can belong to its clique . Since Claim 4 of Definition~\ref{def:correct_clique} is not satisfied, there is a neighbor  of  which has elected  but  does not belong to , i.e., we have . According to the formal description of Algorithm , Macro  returns the set of neighbors selected by  which have elected . So,  belongs to the set given by Macro  since we have  at  in . Thus, we have  and -action is enabled at  in , a contradiction.\\
We must show that -action is the enabled action of highest priority at . If -action is not the enabled action of highest priority at  then this implies that -action, -action or -action are always enabled. According to Lemma~\ref{lem:N-action}, after executing -action it is not enabled at , a contradiction. So, -action is disabled at . Predicate  is not satisfied at  since , so -action is disabled at , a contradiction. Moreover,  by hypothesis so -action is disabled at , a contradiction. Finally, according to Lemma~\ref{lem:C3-action} -action is enabled at  until it is executed.
\end{proof}

\begin{lemma}
\label{lem:construct_prio}
Let  and  be two local leaders such that . The construction by  of the clique  cannot prevent the construction by  of the clique .
\end{lemma}

\begin{proof}
First of all, according to the formal description of Algorithm  -action is executed at any node independently from the construction of the cliques to enable the computation of the 2-neighborhood at each node. Moreover, -action and -action are executed independently at any local leader, so a local leader cannot prevent another local leader to execute these actions. Finally, we have to consider the execution of -action at a node selected by several local leaders. Let  be a node selected by two local leaders  and  such that . Assume, by the contradiction, that  prevents  to join the clique  constructed by . This implies that  cannot execute -action to elect , a contradiction according to Lemma~\ref{lem:elect_clique}.
\end{proof}

\begin{lemma}
\label{lem:construct_clique_prio}
Starting from an arbitrary configuration, the local leader  of highest rank can construct its clique  if  does not satisfy Definition~\ref{def:correct_clique}.
\end{lemma}

\begin{proof}
From Lemmas~\ref{lem:select_clique},~\ref{lem:elect_clique} and~\ref{lem:update_clique}, we have that the clique  of the local leader  of highest rank is constructed such that Claims 2 to 4 of Definition~\ref{def:correct_clique} are satisfied.\\
Finally we consider Claim 1 of Definition~\ref{def:correct_clique}. Assume, by the contradiction, that the constructed clique  contains more than a single local leader. By Definition~\ref{def:local_leader}, there is a node  in , , (i.e., ) which satisfies Predicate . This implies that  has not been selected by , i.e., . Thus, by Lemma~\ref{lem:update_clique}  executes -action since  does not satisfy Claim 4 of Definition~\ref{def:correct_clique}, a contradiction.\\
Finally, according to Lemma~\ref{lem:construct_prio} the construction of the clique  by  cannot be prevented by any other local leader since  is the local leader of highest rank.
\end{proof}

We show in the following that Algorithm  reaches a legitimate configuration (Definition~\ref{def:config_legitime}) in finite time starting from an arbitrary configuration.

\begin{lemma}
\label{lem:correct_clique_round}
Starting from an arbitrary configuration, the local leader of highest rank constructs its clique in at most  (asynchronous) rounds if its clique does not satisfy Definition~\ref{def:correct_clique}.
\end{lemma}

\begin{proof}
Let  be the local leader of highest rank whose clique  does not satisfy Definition~\ref{def:correct_clique}. According to Lemma~\ref{lem:construct_clique_prio},  constructs its clique  in order to satisfy Definition~\ref{def:correct_clique}.

First of all, note that if we have  at a node  then -action is enabled at  in round 0. Therefore, since the daemon is weakly fair and according to Lemma~\ref{lem:N-action} in the first configuration of round 1 we have  at every node .

In the first configuration of round 1, -action is the enabled action of highest priority at . Since the daemon is weakly fair and according to Lemma~\ref{lem:C1-action} in the first configuration of round 2 we have  and  at . In the second configuration of round 1, every neighbor  of  such that  satisfies . If  then -action is the enabled action of highest priority at . Since the daemon is weakly fair and according to Lemma~\ref{lem:C2-action} every such neighbor  executes -action to elect , which is the local leader of highest rank in the neighborhood of . Thus, in the first configuration of round 2 we have , and  at . In the first configuration of round 2, -action is the enabled action of highest priority at . Since the daemon is weakly fair and according to Lemma~\ref{lem:C3-action} in the first configuration of round 3 we have  at . Therefore,  has constructed its clique  in  rounds.
\end{proof}

\begin{lemma}
\label{lem:config_legitime_round}
Starting from any configuration in which for each node  the input  is correct, Algorithm  reaches a configuration satisfying Definition~\ref{def:config_legitime} in at most  (asynchronous) rounds, with  the maximum number of cliques at any distance from  in ,  the diameter of , and  the number of nodes in . Moreover,  bits of memory are necessary at each node, with  the maximum degree of a node in .
\end{lemma}

\begin{proof}
In the following, we define by  a local leader  at distance  (in hops) from the root node .

We first show by induction on the distances in  the following proposition: in at most  rounds every local leader  at distance  from  has constructed its clique  satisfying Definition~\ref{def:correct_clique}, with  the number of maximal cliques constructed at distance .

In base case . We must verify the proposition only at  since there is no other local leader at distance 0 from . According to Lemma~\ref{lem:correct_clique_round} in  rounds  has constructed its clique, which verifies the proposition since .\\
Induction case: We assume the proposition is verified for every local leader at distance  from  in . We have to show the proposition is also verified for every local leader at distance  from . Consider the local leaders  at distance  from , with , following the order of their rank from the highest to the lowest. We can apply iteratively Lemmas~\ref{lem:construct_clique_prio} and~\ref{lem:correct_clique_round} to show that each  constructs its clique in  rounds. Therefore, in at most  rounds the proposition is verified at every local leader at distance  from .\\
Since there are at most  layers with local leaders, in at most  rounds the proposition is verified at every local leader, with . Moreover, we can observe that we cannot have more than  cliques in any clique partition. Therefore, in at most  rounds the proposition is verified at every local leader.

We can observe that in the proposition used for the above induction proof every clique constructed by a local leader satisfies Definition~\ref{def:correct_clique}. Therefore, the configuration  reached by Algorithm  in  rounds satisfies Definition~\ref{def:config_legitime}.

Finally, according to the formal description of Algorithm  at any node  the variables  and  are of size  bits since they store a node identifier and a distance respectively of at most  states. Moreover, the variables ,  and  store a subset of neighbors identifier composed of at most  elements leading to variables of size  bits.
\end{proof}

Finally, we show below that any legitimate configuration reached by Algorithm  is a terminal configuration which defines a solution to the Connected Minimal Clique Partition problem.

\begin{lemma}
\label{lem:no_enable_action}
In any configuration , for every node  which belongs to a clique  satisfying Definition~\ref{def:correct_clique} in  no action of Algorithm~\ref{algo} is enabled at .
\end{lemma}

\begin{proof}
Assume, by the contradiction, that there exists a configuration  such that there exists a node  in a clique  satisfying Definition~\ref{def:correct_clique} with an enabled action of Algorithm~\ref{algo} at .

Let  be the local leader of the clique  in the following. If -action is enabled at  then  or  and  can execute -action in step . In configuration , we must consider two cases: either Definition~\ref{def:correct_clique} is not satisfied in  a contradiction because this implies that  did not satisfy Definition~\ref{def:correct_clique} in , otherwise Definition~\ref{def:correct_clique} is satisfied in  and according to Lemma~\ref{lem:N-action} -action is disabled, a contradiction.
If -action is enabled at  then  and we have . This implies that the nodes selected by  does not form a maximal clique. That is, there exists a neighbor  of  such that  and , or  and . This is in contradiction with Claim 2 of Definition~\ref{def:correct_clique}.
If -action is enabled at  then  is not a local leader and we have . This implies that  has elected  but there exists a local leader  in 's neighborhood such that , a contradiction with Claim 3 of Definition~\ref{def:correct_clique}.
If -action is enabled at  then  and we have . This implies that there exists a node  which has elected  while , i.e., we have . This is in contradiction with Claim 4 of Definition~\ref{def:correct_clique}.
\end{proof}

\begin{corollary}
\label{cor:no_enable_action}
In every configuration  satisfying Definition~\ref{def:config_legitime}, for every node  no action of Algorithm  is enabled in .
\end{corollary}

\begin{proof}
According to Definition~\ref{def:config_legitime}, every clique constructed by a local leader in  satisfies Definition~\ref{def:correct_clique}. Therefore, we can apply Lemma~\ref{lem:no_enable_action} which shows the corollary.
\end{proof}

\begin{lemma}
\label{lem:sol_cmcp_config_legitime}
Let the set of configurations  such that every configuration  satisfies Definition~\ref{def:config_legitime}. , a connected minimal clique partition (Definition~\ref{def:cmcp}) is constructed in .
\end{lemma}

\begin{proof}
According to Definition~\ref{def:cmcp}, to prove the lemma we must show that the clique partition constructed in every configuration  is: (i) minimal for inclusion, and (ii) connected.

Consider first the minimality property of the clique partition. Assume, by the contradiction, that the first property is not satisfied in . This implies that if we take the cliques following their ranks from the highest to the lowest rank then there are two cliques  and  such that  is a clique in . However, according to Remark~\ref{rem:total_order_clique} we have a total order on the cliques and the clique of highest rank, say , is not a maximal clique. However,  satisfies Definition~\ref{def:correct_clique} because . So, according to Claim 2 of Definition~\ref{def:correct_clique}  is a maximal clique, a contradiction.

Consider now the connectivity property of the clique partition. Assume, by the contradiction, that the clique partition constructed in  is not connected. This implies that the graph  induced by the non trivial cliques is not connected in . Thus, there exists a local leader  such that there is no path  between  and  in . Consider the local leader  of highest rank in  such that  in . According to Remark~\ref{rem:nodes_rank_clique}, a correct clique can only contain nodes with a rank lower than the rank of the local leader of the clique. So, by definition of ranks we have only to consider the shortest paths between  and  in . Every shortest path  in  can be decomposed in three parts:  containing the nodes in ,  containing the nodes in , and . In every shortest path , any node  is a local leader of its trivial clique  because . Since ,  is a maximal clique according to Claim 2 of Definition~\ref{def:correct_clique}. However, there is a neighbor  of  in  such that either  or . Thus, we have , a contradiction with Claim 2 of Definition~\ref{def:correct_clique} since  is not maximal.
\end{proof}

\begin{theorem}
Algorithm  is a self-stabilizing algorithm for Specification~\ref{spec:cmcp} under a weakly fair distributed daemon.
\end{theorem}

\begin{proof}
We have to show that starting from any configuration the execution of Algorithm  verifies the two conditions of Specification~\ref{spec:cmcp}.

According to Theorem~\ref{thm:cmcp_enable_action}, Lemma~\ref{lem:config_legitime_round} and Corollary~\ref{cor:no_enable_action}, from any configuration Algorithm  reaches a configuration  in finite time and  is a terminal configuration, which verifies Condition 1 of Specification~\ref{spec:cmcp}. Moreover, according to Lemma~\ref{lem:sol_cmcp_config_legitime} the terminal configuration  reached by Algorithm  satisfies Definition~\ref{def:cmcp}, which verifies Condition 2 of Specification~\ref{spec:cmcp}.
\end{proof}

Finally, from an arbitrary configuration we can establish the following corollary according to Lemma~\ref{lem:config_legitime_round}.

\begin{corollary}
\label{cor:config_legitime_round_avec_BFS}
Starting from an arbitrary configuration, the fair composition of Algorithm  and Algorithm  reach a configuration satisfying Definition~\ref{def:config_legitime} in at most  (asynchronous) rounds, with  the round complexity of self-stabilizing algorithm  constructing a BFS tree,  the maximum number of cliques at any distance from  in ,  the diameter of , and  the number of nodes in .
\end{corollary}

\subsubsection{Proof assuming an unfair daemon}

In the following, we prove that Algorithm  is self-stabilizing under an unfair daemaon by bounding the number of steps needed to reach a legitimate configuration.

\begin{lemma}
\label{lem:N-action_steps}
In an execution, every node  can execute -action at most once.
\end{lemma}

\begin{proof}
According to Lemma~\ref{lem:N-action} if -action is enabled at a node  in the initial configuration then it becomes disabled after its execution at .
\end{proof}

In the following we consider that for each node  the input  is correct, i.e.,  is equal to the distance (in hops) between  and  in .

\begin{definition}[Priority level]
The \emph{priority level} of any node  is equal to the number of nodes  such that  in . The priority level of a clique is defined by the priority level of its local leader.
\end{definition}

\begin{lemma}
Let  be a correct clique (Definition~\ref{def:correct_clique}) of priority level  which belongs to a legitimate configuration . In an execution, a correct clique  may not satisfy Definition~\ref{def:correct_clique} at most  times.
\end{lemma}

\begin{proof}
According to Remark~\ref{rem:total_order_clique}, in any clique partition the rank of the cliques define a total order. Moreover, according to Lemma~\ref{lem:construct_prio} the construction of any clique  cannot prevent the construction of another clique  if . Thus, the construction of the clique  of priority level  can be prevented by at most  cliques. However, as long as these  cliques of rank higher than  do not satisfy Definition~\ref{def:correct_clique} the construction of  can be affected. Consider the following worst case scheduling. The cliques  are constructed following their rank from the lowest to the highest rank, and before the construction of a new clique  the construction of  is performed again in order to satisfy Definition~\ref{def:correct_clique}. Thus, the construction of each clique  involves that  does not satisfy Definition~\ref{def:correct_clique} and this situation happens at most  times.
\end{proof}

According to the formal description of Algorithm , the construction of a correct clique  is performed by executing -action and -action or -action at a node .

\begin{corollary}
\label{cor:other_actions_steps}
Let  be a correct clique (Definition~\ref{def:correct_clique}) of priority level  which belongs to a legitimate configuration . In an execution, a node  can execute -action, -action and -action at most  times.
\end{corollary}

\begin{lemma}
\label{lem:config_legitime_step}
From any configuration in which for each node  the input  is correct, at most  steps are needed by Algorithm  to reach a configuration satisfying Definition~\ref{def:config_legitime}, with  the number of nodes in .
\end{lemma}

\begin{proof}
First of all, according to Lemma~\ref{lem:N-action_steps} in an execution of Algorithm  -action is executed at most  times. Moreover, according to Corollary~\ref{cor:other_actions_steps} in an execution of Algorithm  a node  of priority level  can execute -action, -action and -action at most  times. Moreover, a clique partition contains at most  cliques. So, by summing up we have that in an execution of Algorithm  starting from any configuration in which the input  is correct for each node  -action, -action and -action are executed at most  times.

Therefore, from any configuration in which the input  is correct for each node  Algorithm  executes at most  steps to reach a configuration satisfying Definition~\ref{def:config_legitime}.
\end{proof}

Finally, from any configuration we can establish the following corollary according to Lemma~\ref{lem:config_legitime_step}.

\begin{corollary}
\label{cor:config_legitime_step_avec_BFS}
From any configuration, at most  steps are needed by Algorithms  and  executed following a fair composition to reach a configuration satisfying Definition~\ref{def:config_legitime}, with  the number of nodes in  and  the step complexity of self-stabilizing algorithm  constructing a BFS tree.
\end{corollary}

\section{Self-stabilizing Connected Vertex Cover}
\label{sec:cvc}

We define below an extension of the classical Vertex Cover problem, called Connected Vertex Cover problem.

\begin{definition}[2-approximation Connected Vertex Cover]
\label{def:cvc}
Let  be any undirected graph. A vertex cover  of the graph  is \emph{connected} iff for any pair of node  there is a path between  and  in the graph induced by . Moreover,  is a 2-approximation Connected Vertex Cover, i.e., we have  with  an optimal solution for the Connected Vertex Cover.
\end{definition}

In~\cite{DelbotLP13}, Delbot \emph{et al.} presented a centralized optimization algorithm to solve the Connected Vertex Cover problem which uses a solution obtained for the Connected Minimal Clique Partition problem (see Definition~\ref{def:cmcp}). Given a solution  for the Connected Minimal Clique Partition, the authors have shown in~\cite{DelbotLP13} that we can construct a solution  for the Connected Vertex Cover with an approximation ratio of 2 by selecting in  all the cliques in  which are not \emph{trivial}, i.e., by selecting all the cliques composed of at least two nodes.  

In the following, we define in Specification~\ref{spec:cvc} the Self-stabilizing Connected Vertex Cover problem.

\begin{spec}[Self-stabilizing Connected Vertex Cover]
\label{spec:cvc}
Let  the set of all possible configurations of the system. An algorithm  solving the problem of constructing a stabilizing connected vertex cover satisfies the following conditions:
\begin{enumerate}
\item Algorithm  reaches a set of terminal configurations  in finite time, and
\item Every configuration  satisfies Definition~\ref{def:cvc}.
\end{enumerate}
\end{spec}

\subsection{Related works}

The Vertex Cover problem is a classical optimization problem and many works have been devoted to this problem or to its variations. This problem is known to be APX-complete \cite{PapadimitriouY88} and not approximable within a factor of  \cite{DinurS05}. Some very simple approximation algorithms gives a tight approximation ratio of  \cite{GJ79,Vaz01,Savage82}. Despite a lot of works, no algorithm whose approximation ratio is bounded by a constant less than  has been found and it is conjectured that there is no smaller \emph{constant} ratio unless  \cite{KhotR08}. Monien and Speckenmeyer \cite{Monien1985} and Bar-Yehuda and Even \cite{Bar-YehudaE85} proposed algorithms with an approximation ratio of , with  the number of vertices of the graph and Karakostas \cite{Karakostas05} reduced this ratio to .

From a self-stabilizing point of view, Kiniwa~\cite{Kiniwa05} proposed the first self-stabilizing algorithm for this problem which constructs a 2-approximate vertex cover in general networks with unique nodes identifier and under a fair distributed daemon. This algorithm is based on the construction of a maximal matching which allows to obtain a 2-approximation vertex cover by selecting the extremities of the matching edges. Turau \emph{et al.}~\cite{TurauH11} considered the same problem in anonymous networks and gave an 3-approximation algorithm under a distributed daemon. Since it is impossible to construct a maximal matching in an anonymous network, this algorithm establishes first a bicolored graph of the network allowing then to construct a maximal matching to obtain a vertex cover. Turau~\cite{Turau10} designed a self-stabilizing vertex cover algorithm with approximation ratio of 2 in anonymous networks under an unfair distributed daemon. This algorithm uses the algorithm in~\cite{TurauH11} executed several times on parts of the graph to improve the quality of the constructed solution.

For the Connected Vertex Cover problem, Savage in~\cite{Savage82} proposed a 2-approximation algorithm in general graphs based on the construction of a Depth First Search tree  and selecting in the solution the nodes with at least a child in . In 2010 Escoffier \emph{et al.}~\cite{EscoffierGouvesMonnot10} proved that the problem is NP-complete, even in bipartite graphs (whereas it is polynomial to construct a vertex cover in bipartite graphs), is polynomial in chordal graphs and can be approximated with better ratio than  in several restricted classes of graphs.

To our knowledge, there exists no self-stabilizing algorithm for the Connected vertex cover problem. However, the approach proposed by Savage~\cite{Savage82} can be used to design a self-stabilizing algorithm. Indeed, any self-stabilizing algorithm performing a depth first search traversal of the graph (e.g., see~\cite{CollinD94,CournierDPV06,PetitV07}) executed in parallel with the algorithm described later in this section can be used to select the appropriate set of nodes in the solution. However, this does not enable to obtain the best complexity in terms of time. Although a low memory complexity of  bits per node is reached, this approach has a time complexity of  rounds. Indeed, a low level of parallelism is reached because of the DFS traversal. In contrast, the self-stabilizing algorithm that we propose in this section is based on the algorithm presented in the previous section. Our solution has a better time complexity of  rounds because of the parallel construction of cliques. However, the memory complexity is  bits per node.

\subsection{Self-stabilizing construction}

In this subsection, we present our self-stabilizing Connected Vertex Cover algorithm called  which follows the approach given in~\cite{DelbotLP13}. A solution to the Connected Vertex Cover problem contains all the non trivial cliques of a Connected Minimal Clique Partition. We give in this section a self-stabilizing algorithm allowing to select the nodes of non trivial cliques, a formal description is given in Algorithm~\ref{algo2}. So, Algorithm  is defined as a fair composition~\cite{Dolev2000} of Algorithms~\ref{algo} and~\ref{algo2} which are executed at each node .\\
Algorithm~\ref{algo2} takes in input at each node  the local leader of  and the set of nodes belonging to the maximal clique of  given by Algorithm~\ref{algo} (i.e., variables  and  of Algorithm~\ref{algo}) in case  is a local leader. Moreover, in Algorithm~\ref{algo2} each node maintains a single boolean variable . Any node  belongs to the Connected Vertex Cover if and only if (1) either it is a local leader and its maximal clique is not trivial (i.e.,  and ), or (2) it is contained in a maximal clique constructed by a neighbor which is the local leader of  (i.e., ). Predicate  is satisfied at each node  if  is part of the Connected Vertex Cover. Therefore, Algorithm~\ref{algo2} is composed of a single rule executed by each node  to correct the value of variable  in order to be equal to the value of Predicate . So, a solution to the Connected Vertex Cover problem contains every node  such that .

\begin{algorithm}
\caption{\quad Self-Stabilizing Connected Vertex Cover algorithm for any \label{algo2}}
\smallskip
\begin{scriptsize}
{\bf Inputs:}\\
\hspace*{1cm}: unique identifier of ;\\
\hspace*{1cm}: leader of  computed by Algorithm~\ref{algo};\\
\hspace*{1cm}: maximal clique of  computed by Algorithm~\ref{algo};\\
{\bf Variable:}\\
\hspace*{1cm};

.\dotfill\ 

{\bf Predicate:}\\
\begin{tabular}{lll}
 &  & \\
\end{tabular}\\
.\dotfill\

{\bf Action:}\\
\begin{tabular}{lllllll}
&& -  &  &  &  & ;\\
\end{tabular}
\end{scriptsize}
\end{algorithm}


\subsection{Correctness proof}

\begin{definition}[Legitimate configuration]
\label{def:config_legitime_cvc}
A configuration  is legitimate for Algorithm~\ref{algo2} iff for every node  we have .
\end{definition}

In the following we consider that Algorithm  is stabilized and we have correct inputs for  and  at every node .

\begin{theorem}
\label{thm:cvc_enable_action}
Let the set of configurations  such that every configuration  satisfies Definition~\ref{def:config_legitime_cvc}.  such that  is enabled in .
\end{theorem}

\begin{proof}
Assume, by the contradiction, that  such that  no action of Algorithm~\ref{algo2} is enabled at  in . According to Definition~\ref{def:config_legitime_cvc}, this implies that there exists a node  such that . So, -action is enabled at , a contradiction.
\end{proof}

\begin{lemma}
\label{lem:VC-action}
When -action is enabled at any , it remains enabled until  executes it.
\end{lemma}

\begin{proof}
Let  be a step. Assume, by the contradiction, that -action is enabled at  in  and not in  (i.e.,  in ) but  did not execute -action in . Since  did not move in  and the variable  can only be modified locally by  by executing -action, we have  at  in , a contradiction.
\end{proof}

\begin{lemma}
\label{lem:config_legitime_cvc_round}
Starting from any configuration satisfying Definition~\ref{def:config_legitime}, Algorithm~\ref{algo2} reaches a configuration satisfying Definition~\ref{def:config_legitime_cvc} in at most  (asynchronous) rounds. Moreover,  bits of memory are necessary at each node.
\end{lemma}

\begin{proof}
In any configuration satisfying Definition~\ref{def:config_legitime}, if we have  at a node  then -action is enabled at  in round 0. Therefore, according to Lemma~\ref{lem:VC-action} in the first configuration  of round 1 we have  at every node . Moreover, this implies that  satisfies Definition~\ref{def:config_legitime_cvc}.

We can observe that Algorithm~\ref{algo2} maintains a single boolean variable  at each node . So,  bits of memory are necessary at each node .
\end{proof}

From Corollary~\ref{cor:config_legitime_round_avec_BFS} and Lemma~\ref{lem:config_legitime_cvc_round}, we can establish the round complexity given in the following corollary.

\begin{corollary}
Starting from any configuration, the fair composition of Algorithms  and  reach a configuration satisfying Definition~\ref{def:config_legitime_cvc} in at most  (asynchronous) rounds, with  the round complexity of self-stabilizing algorithm  constructing a BFS tree,  the maximum number of cliques at any distance from  in ,  the diameter of , and  the number of nodes in . Moreover,  bits of memory are necessary at each node, with  the maximum degree of a node.
\end{corollary}

\begin{lemma}
\label{lem:config_legitime_cvc_step}
Starting from any configuration satisfying Definition~\ref{def:config_legitime}, at most  steps are needed by Algorithm~\ref{algo2} to reach a configuration satisfying Definition~\ref{def:config_legitime_cvc}, with  the number of nodes in .
\end{lemma}

\begin{proof}
In any configuration  satisfying Definition~\ref{def:config_legitime}, if we have  at a node  in  then -action is enabled at  in . According to Lemma~\ref{lem:VC-action}, -action is enabled at  until it is executed. -action can be enabled at every node  in . So, each node  can execute -action because it is the action of highest priority at  since Algorithm~\ref{algo2} is composed of a single action. Thus, after at most  steps Algorithm~\ref{algo2} has reached a configuration  such that we have  at every node  in . Moreover, this implies that Definition~\ref{def:config_legitime_cvc} is satisfied in .
\end{proof}

From Corollary~\ref{cor:config_legitime_step_avec_BFS} and Lemma~\ref{lem:config_legitime_cvc_step}, we can establish the step complexity of Algorithm  given in the following corollary.

\begin{corollary}
Starting from any configuration, in at most  steps are needed by Algorithms  and  executed following a fair composition to reach a configuration satisfying Definition~\ref{def:config_legitime_cvc}, with  the step complexity of self-stabilizing algorithm  constructing a BFS tree and  the number of nodes in .
\end{corollary}

\begin{lemma}
\label{lem:no_enable_action_cvc}
In every configuration  satisfying Definition~\ref{def:config_legitime_cvc}, for every node  no action of Algorithm~\ref{algo2} is enabled in .
\end{lemma}

\begin{proof}
Assume, by the contradiction, that there exists a configuration  such that there exists a node  with an enabled action of Algorithm~\ref{algo2}. According to the formal description of Algorithm~\ref{algo2}, the algorithm is only composed of -action. This implies that we have  at  in . However, we have  at every node  because , a contradiction.
\end{proof}

\begin{lemma}
\label{lem:sol_cvc_config_legitime}
Let the set of configurations  such that every configuration  satisfies Definition~\ref{def:config_legitime_cvc}. , a -approximated Connected Vertex Cover (Definition~\ref{def:cvc}) is constructed in .
\end{lemma}

\begin{proof}
According to Definition~\ref{def:cvc}, to prove the lemma we must show that the solution  constructed in every configuration  is: (i) a vertex cover of , (ii) connected, and (iii) a 2-approximation from an optimal solution.

According to Specification~\ref{spec:cmcp}, Algorithm~\ref{algo2} takes in input a Connected Minimal Clique partition. Consider the first property. In any configuration , according to Algorithm~\ref{algo2} only the nodes which belong to a non trivial clique are included in the constructed solution . Assume, by the contradiction, that  is not a vertex cover of . This implies that there exists an edge between two trivial cliques  and  of the clique partition given in input. So, the clique partition given in input is not minimal since we can construct the maximal clique , a contradiction with Specification~\ref{spec:cmcp}. So, the set of trivial cliques forms an independent set and all the edges of the graph are covered by the nodes in . Consider the second property. According to Specification~\ref{spec:cmcp}, the graph induced by the non trivial cliques given in input is connected. This implies that the solution  constructed in  is also connected. Consider the last property. We follow the approach proposed in~\cite{DelbotLP13}. According to Theorem 2 showed in~\cite{DelbotLP13},  is a 2-approximation for the Connected Vertex Cover problem. The approximation ratio comes from the fact that for each clique of size  at least  nodes are in an optimal solution to cover all the  edges of the clique, while  nodes are selected by the algorithm.
\end{proof}

\begin{theorem}
Algorithm  is a self-stabilizing algorithm for Specification~\ref{spec:cvc} under an unfair distributed daemon.
\end{theorem}

\begin{proof}
We have to show that starting from any configuration the execution of Algorithm  verifies the two conditions of Specification~\ref{spec:cvc}.

According to Theorem~\ref{thm:cvc_enable_action}, Lemmas~\ref{lem:config_legitime_cvc_round},~\ref{lem:config_legitime_cvc_step} and~\ref{lem:no_enable_action_cvc}, from any configuration Algorithm  reaches a configuration  in finite time and  is a terminal configuration, which verifies Condition 1 of Specification~\ref{spec:cvc}. Moreover, according to Lemma~\ref{lem:sol_cvc_config_legitime} the terminal configuration  reached by Algorithm  satisfies Definition~\ref{def:cvc}, which verifies Condition 2 of Specification~\ref{spec:cvc}.
\end{proof}

\section{Conclusion}
In this paper, we give the first distributed and self-stabilizing algorithm for the Connected Vertex Cover problem with a constant approximation ratio of 2. Moreover, to solve this problem we propose also a self-stabilizing algorithm for the construction of a Connected Minimal Clique partition of the graph. These two algorithms work under the unfair distributed daemon which is the weakest daemon.
There are two natural perspectives to this work. First, our distributed self-stabilizing clique partition construction a root node is used. This allows to ensure the connectivity property for the clique partition. If this property is not necessary our algorithm can be easily modified in order to remove this hypothesis, but is it also possible while guaranteeing the connectivity property. Second, the self-stabilizing algorithm we propose for the Connected Vertex Cover problem achieves a better time complexity than a self-stabilizing solution based on Savage's approach, but at the price of a higher memory complexity. So, a natural question is to investigate the existence of a distributed algorithm with a low time and memory complexity.




\bibliographystyle{alpha}
\bibliography{Biblio}

\end{document}
