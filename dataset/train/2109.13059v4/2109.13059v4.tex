\documentclass{article} \usepackage{iclr2021_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{$\eta$}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{hyperref}
\usepackage{url}
\usepackage{graphicx}

\usepackage{xspace}
\newcommand{\modelname}{\textsc{Trans-Encoder}\xspace}
\newcommand{\modelnames}{\textsc{Trans-Encoder}s\xspace}
\newcommand{\tenc}{\textsc{TEnc}\xspace}

\usepackage{latexsym}
\usepackage{booktabs} \usepackage{multirow}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{float}

\usepackage{natbib}

\usepackage{cleveref}
\crefformat{section}{\S#2#1#3}
\crefformat{subsection}{\S#2#1#3}
\crefformat{subsubsection}{\S#2#1#3}
\crefrangeformat{section}{\S\S#3#1#4 to~#5#2#6}
\crefmultiformat{section}{\S\S#2#1#3}{ and~#2#1#3}{, #2#1#3}{ and~#2#1#3}
\Crefformat{figure}{#2Fig.~#1#3}
\Crefmultiformat{figure}{Figs.~#2#1#3}{ and~#2#1#3}{, #2#1#3}{ and~#2#1#3}
\Crefformat{table}{#2Tab.~#1#3}
\Crefmultiformat{table}{Tabs.~#2#1#3}{ and~#2#1#3}{, #2#1#3}{ and~#2#1#3}
\Crefformat{equation}{#2Eq.~(#1#3)}
\Crefformat{appendix}{#2App.~\S#1#3}


\usepackage{colortbl}
\newcommand{\CC}[1]{\cellcolor{blue!#1}}
\newcommand{\CCR}[1]{\cellcolor{red!#1}}
\newcommand{\CCG}[1]{\cellcolor{green!#1}}

\usepackage{arydshln}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{xcolor}

\usepackage{microtype}

\usepackage{pifont}\newcommand{\cmark}{\ding{51}}\newcommand{\xmark}{\ding{55}}

\usepackage{hyperref}
\usepackage{tablefootnote}

\usepackage{xcolor,colortbl}
\definecolor{plot_orange}{rgb}{1.0, 0.498, 0.055}
\definecolor{plot_blue}{rgb}{0.121, 0.467, 0.706}
\definecolor{plot_grey}{rgb}{0.501, 0.501, 0.501}
\definecolor{plot_greyblue}{rgb}{0.475, 0.561, 0.725} \definecolor{plot_yellow}{rgb}{0.953, 0.659, 0.231} 

\usepackage{sidecap}




\title{\modelname: \\
Unsupervised sentence-pair modelling\\ through self- and mutual-distillations}



\author{Fangyu Liu$^{1}$\thanks{Work done during internship at Amazon.} \ \ Yunlong Jiao$^2$ \ \  Jordan Massiah$^2$ \ \ Emine Yilmaz$^2$ \ \ Serhii Havrylov$^2$ \\ 
$^1$University of Cambridge \ \
$^2$Amazon \\
\texttt{fl399@cam.ac.uk}\ \ \texttt{\{jyunlong,jormas,eminey,havrys\}@amazon.com} \\
}




\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}
In NLP, a large volume of tasks involve pairwise comparison between two sequences (e.g., sentence similarity and paraphrase identification). 
Predominantly, two formulations are used for sentence-pair tasks: bi-encoders and cross-encoders. 
Bi-encoders produce fixed-dimensional sentence representations and are computationally efficient, however, they usually underperform cross-encoders. 
Cross-encoders can leverage their attention heads to exploit inter-sentence interactions for better performance but they require task finetuning and are computationally more expensive. 
In this paper, we present a completely unsupervised sentence-pair model termed as \modelname that combines the two learning paradigms into an iterative joint framework to simultaneously learn enhanced bi- and cross-encoders. 
Specifically, on top of a pre-trained language model (PLM), we start with converting it to an unsupervised bi-encoder, and then alternate between the bi- and cross-encoder task formulations. 
In each alternation, one task formulation will produce pseudo-labels which are used as learning signals for the other task formulation. We then propose an extension to conduct such self-distillation approach on multiple PLMs in parallel and use the average of their pseudo-labels for mutual-distillation. 
\modelname creates, to the best of our knowledge, the first completely unsupervised cross-encoder and also a state-of-the-art unsupervised bi-encoder for sentence similarity. 
Both the bi-encoder and cross-encoder formulations of \modelname outperform recently proposed state-of-the-art unsupervised sentence encoders such as Mirror-BERT \citep{liu2021fast} and SimCSE \citep{gao2021simcse} by up to $5\%$ on the sentence similarity benchmarks. Code and models are released at \url{https://github.com/amzn/trans-encoder}.

\end{abstract}

\section{Introduction}
Comparing pairwise sentences is fundamental to a wide spectrum of tasks in NLP such as information retrieval (IR), natural language inference (NLI), semantic textual similarity (STS) and clustering. 
Two general architectures usually used for sentence-pair modelling are bi-encoders and cross-encoders. 

In a cross-encoder, two sequences are concatenated and sent into the model (usually deep Transformers like BERT/RoBERTa; \citealt{devlin2019bert,liu2019roberta}) in one pass. 
The attention heads of Transformers could directly model the inter-sentence interactions and output a classification/relevance score. 
However, a cross-encoder needs to recompute the encoding for different combinations of sentences in each unique sequence pair, resulting in a heavy computational overhead. 
It is thus impractical in tasks like IR and clustering where massive pairwise sentence comparisons are involved. 
Also, task finetuning is always required for converting PLMs to cross-encoders. 
By contrast, in a bi-encoder, each sequence is encoded separately and mapped to a common embedding space for similarity comparison. 
The encoded sentences can be cached and reused. 
A bi-encoder is thus much more efficient. 
Also, the output of a bi-encoder can be used off-the-shelf as sentence embeddings for other downstream tasks. 
That said, it is well-known that in supervised learning, bi-encoders underperform cross-encoders \citep{Humeau2020Poly,thakur-etal-2021-augmented} since the former could not explicitly model the interactions between sentences but could only compare them in the embedding space in a \textit{post hoc} manner.

In this work, we ask the question: can we leverage the advantages of both bi- and cross-encoders and bootstrap knowledge from them in an unsupervised manner? 
Our proposed \modelname addresses this question with the following intuition: As a starting point, we can use bi-encoder representations to tune a cross-encoder. 
With more powerful inter-sentence modelling, the cross-encoder should resurface more knowledge from the PLMs than the bi-encoder given the same data. 
In turn, the more powerful cross-encoder can distil its knowledge back to the bi-encoder. 
We can repeat this cycle to iteratively bootstrap from both the bi- and cross-encoders. 


\section{\modelname}

\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{figs/trans-encoder-self-distill-v2.pdf}
    \vspace{-2mm}
    \caption{A graphical illustration of the self-distillation learning scheme in \modelname. Notice that the blue boxes represent the same model architecture trained sequentially. }
    \label{fig:self_distill}
    \vspace{-2.5mm}
\end{figure}

The general idea of \modelname is simple yet extremely effective. 
In \Cref{sec:mirror_bert}, we first transform an off-the-shelf PLM to a strong bi-encoder, serving as an initialisation point. 
Then, the bi-encoder produces pseudo-labels and the PLM subsequently learns from these pseudo-labels in a cross-encoder manner (\Cref{sec:bi_to_cross}). 
Consecutively, the cross-encoder further produces more accurate pseudo-labels for bi-encoder learning (\Cref{sec:cross_to_bi}). 
This self-distillation process is visualised in \Cref{fig:self_distill}. 
Then in, \Cref{sec:mutual_distill}, we propose a further extension called mutual-distillation that stabilises the training process and boosts the encoder performance even more.

\subsection{Transform PLMs into Effective Bi-encoders}\label{sec:mirror_bert}
Off-the-shelf PLMs are unsatisfactory bi-encoders.\footnote{In this work, a \textit{bi-encoder} is the same as a \textit{universal text encoder}. When embedding a pair of sentences under the bi-encoder architecture, the same encoder is used (i.e., the two-branches of bi-encoder share weights).} 
To have a reasonably good starting point, we leverage a simple contrastive tuning procedure to transform existing PLMs to bi-encoders. 
This approach is concurrently proposed in both \citep{liu2021fast} and \citep{gao2021simcse}. 

Let $f(\cdot)$ denote the encoder model (a Transformer-based model); $\mathcal{X}$ be a batch of randomly sampled raw sentences. 
For any sentence $x_i\in\mathcal{X}$, we send it to the encoder twice to create two views of the same data point: $f(x_i)$ and $f(\overline{x}_i)$. 
Note that the two encodings slightly differ due to the dropout layers in the encoder.\footnote{Mirror-BERT has the option to also randomly mask a span in $\overline{x}_i$ and using drophead \citep{zhou-etal-2020-scheduled} to replace dropout as hidden states augmentation.}
We then use the standard InfoNCE loss \citep{oord2018representation} to cluster the positive pairs together and push away the negative pairs in the mini-batch:

\vspace{-2mm}
\begin{equation}
    \mathcal{L}_{\text{infoNCE}} = -\sum_{i=1}^{|\mathcal{X}|}\log\frac{\exp(\cos(f(x_i), f(\overline{x}_i))/\tau)}{\displaystyle \sum_{x_j\in \mathcal{N}_i}\exp(\cos(f(x_i), f(x_j))/\tau)}.
    \label{eq:infonce}
\end{equation}


$\tau$ denotes a temperature parameter; $\mathcal{N}_i$ denotes all positive \& negatives of $x_i$ within the current data batch. Intuitively, the numerator is the similarity of the self-duplicated pair (the positive example) and the denominator is the sum of the similarities between $x_i$ and all other negative strings besides $\overline{x}_i$. The loss encourages the positive pairs to be relatively close compared to the negative ones. In experiments, we use checkpoints released by SimCSE and Mirror-BERT. But in principle, any techniques could be used here as long as the method serves the purpose of transforming BERT to an effective bi-encoder and does not require additional labelled data (see \Cref{sec:related_work}).



\subsection{Self-distillation: Bi- to Cross-encoder}\label{sec:bi_to_cross}

After obtaining a sufficiently good bi-encoder, we leverage it to label sentence pairs sampled from the task of interest. Specifically, for a given sentence-pair (\texttt{sent1}, \texttt{sent2}), we input them to the bi-encoder separately and get two embeddings (we use the embedding of \texttt{[CLS]} from the last layer). The cosine similarity between them is regarded as their relevance score. In this way we have constructed a self-labelled sentence-pair scoring dataset in the format of (\texttt{sent1}, \texttt{sent2}, score).

We then employ the same model architecture to learn from these score, but with a cross-encoder formulation. The cross-encoder weights are initialised from the original PLM.\footnote{We have a design choice to make here, we could either (1) directly use the weights of the bi-encoder or (2) use the weights of the original PLM. We will show in experiments (\Cref{sec:discuss_and_analysis}) that (2) is slightly better than (1).}
For the sentence-pair (\texttt{sent1}, \texttt{sent2}), we concatenate them to produce ``\texttt{[CLS] sent1  [SEP] sent2 [SEP]}'' and input it to the cross-encoder. 
A linear layer (newly initialised) then map the sequence's encoding (embedding of the \texttt{[CLS]} token) to a scalar. 
The learning objective of the cross-encoder is minimising the KL divergence between its predictions and the self-labelled scores from the bi-encoder. This is equivalent to optimising the (soft) binary cross-entropy (BCE) loss:
\begin{equation}
    \mathcal{L}_{\text{BCE}} = - \frac{1}{N}\sum_{n=1}^{N} \Big(y_n\cdot \log(\sigma(x_n)) +(1-y_n)\cdot \log(1-\sigma(x_n))\Big)
    \label{eq:bce_loss}
\end{equation}
where $N$ is the data-batch size; $\sigma(\cdot)$ is the sigmoid activation; $x_n$ is the prediction of the cross-encoder; $y_n$ is the self-labelled ground-truth score from the bi-encoder. 

Note that while the cross-encoder is essentially learning from the data produced by itself (in a bi-encoder form), usually, it outperforms the original bi-encoder on held-out data.
The cross-encoder directly discovers the similarity between two sentences through its attention heads, finding more accurate cues to justify the relevance score. 
The ability of discovering such cues could then generalise to unseen data, resulting in stronger sentence-pair scoring capability than the original bi-encoder. From a knowledge distillation perspective, we can view the bi- and cross-encoder as the teacher and student respectively. In this case the student outperforms the teacher, not because of stronger model capacity, but smarter task formulation. By leveraging this simple yet powerful observation, we are able to design a learning scheme that iteratively boosts the performance of both bi- and cross-encoder.

\subsection{Self-distillation: Cross- to bi-encoder}\label{sec:cross_to_bi}

With the more powerful cross-encoder at hand, a natural next step is distilling the extra gained knowledge back to a bi-encoder form, which is more useful for downstream tasks. Besides, and more importantly, a better bi-encoder could produce even more self-labelled data for cross-encoder learning.  In this way we could repeat \Cref{sec:bi_to_cross} and \Cref{sec:cross_to_bi}, continually bootstrapping the encoder performance.

We create the self-labelled sentence-scoring dataset in the same way as \Cref{sec:bi_to_cross} except that the cross-encoder is used for producing the relevance score. The bi-encoder is initialised with the weights after SimCSE training from \Cref{sec:mirror_bert}.\footnote{Again, we have the choice of using the cross-encoder weights from \Cref{sec:bi_to_cross} (the extra linear layer is disregarded). We will discuss more in experiments.} For every sentence pair, two sentence embeddings are produced separately by the bi-encoder. The cosine similarity between the two embeddings are regarded as their predictions of the relevance score. The aim is to regress the predictions to the self-labelled scores by the cross-encoder. We use a mean square error (MSE) loss:
\begin{equation}
    \mathcal{L}_{\text{MSE}} = - \frac{1}{N}\sum_{n=1}^{N} \Big(x_n - y_n \Big)^2
    \label{eq:mse}
\end{equation}
where $N$ is the batch size; $x_n$ is the cosine similarity between a sentence pair; $y_n$ is the self-labelled ground-truth. In experiments, we will show that this resulting bi-encoder is more powerful than the initial bi-encoder. Sometimes, the bi-encoder will even outperform its teacher (i.e., the cross-encoder). 

\textbf{Choice of loss functions: maintaining student-teacher discrepancy is the key.} Intuitively, MSE allows for more accurate distillations since it punishes any numerical discrepancies between predicted scores and labels on the instance level. However, in practice, we found that using MSE for bi-to-cross distillation aggravates the overfitting issue for cross-encoder: the cross-encoder, with its strong sentence-pair modelling capability, completely overfits to the mapping between concatenated sentence pairs and the pseudo scores. This elimination of discrepancy between model predictions and pseudo labels harms generalisation and the iterative learning cycle cannot continue (as the predicted scores by the student model will be the same as the teacher model). We thus use BCE loss for bi-to-cross since BCE is a more \textit{forgiving} loss function compared with MSE. According to our gradient derivation (\Cref{sec:more_discuss}), BCE essentially is a temperature-sharpened version of MSE, which is more tolerant towards numerical discrepancies. This prevents cross-encoders from overfitting to the pseudo labels completely. Similar issue does not exist for the cross-to-bi distillation as for bi-encoders, two input sequences are separately encoded and the model does not easily overfit to the labels. We have a more thorough discussion in \Cref{sec:more_discuss} and \Cref{tab:loss_choice} to highlight the rationales of the current configuration.

\subsection{Mutual-distillation}\label{sec:mutual_distill}

\begin{figure}
    \centering
    \includegraphics[width=0.6\linewidth]{figs/trans-encoder-mutual-distill-v2.pdf}
    \vspace{-1mm}
    \caption{A graphical illustration of the mutual-distillation learning scheme in \modelname. Note that, for simplicity, only the bi- to cross-encoder mutual-distillation is shown. We also conduct cross- to bi-encoder mutual-distillation in the same manner.}
    \label{fig:mutual_distill}
    \vspace{-2.0mm}
\end{figure}

The aforementioned self-learning approach has a drawback: since the model regresses to its previous predictions, it tends to reinforce its errors. To mitigate this problem, we design a simple mutual-distillation approach to smooth out the errors/biases originated from PLMs. 
Specifically, we conduct self-distillation on multiple PLMs in parallel (for brevity, we use two in this paper: BERT and RoBERTa, however the framework itself is compatible with any number of PLMs). 
Each PLM does not communicate/synchronise with each other except when producing the self-labelled scores. In mutual-distillation, we use the average predictions of all models as the ground-truth for the next round of learning. A graphical illustration is shown in \Cref{fig:mutual_distill}.\footnote{We also experimented with a sequential ensemble strategy: initialising the cross- and bi-encoder with BERT/RoBERTa alternatively (1 cycle of BERT then 1 cycle of RoBERTa) but found the performance worse than mutual-distillation.}

In the following, we call all self-distillation models \modelname (or \tenc for short); all mutual-distillation models \modelname-mutual (or \tenc-mutual for short). Note that one \tenc(-mutual) training produces one best bi-encoder, called \tenc(-mutual) (bi), and one best cross-encoder, called \tenc(-mutual) (cross), based on dev set. We report numbers of both.


\section{Evaluation Tasks}

\textbf{Evaluation task: semantic textual similarity (STS).} 
Following prior works \citep{reimers2019sentence,liu2021fast,gao2021simcse}, we consider seven STS datasets: SemEval STS 2012-2016 (STS12-16, \citealt{agirre2012semeval,agirre2013sem,agirre2014semeval,agirre2015semeval,agirre2016semeval}), STS Benchmark (STS-B, \citealt{cer2017semeval}) and SICK-Relatedness (SICK-R, \citealt{marelli2014sick}). 
In all these datasets, sentence pairs are given a human-judged relevance score from 1 to 5. 
We normalise them to 0 and 1 and models are asked to predict the scores. 
We report Spearman's $\rho$ rank correlation between the two.

\textbf{Evaluation task: binary classification.} 
We also test \modelname on sentence-pair binary classification tasks where the model has to decide if a sentence-pair has certain relations. 
We choose (1) the Quora Question Pair (QQP) dataset, requiring a model to judge whether two questions are duplicated; (2) a question-answering entailment dataset QNLI \citep{rajpurkar2016squad,wang2018glue} in which given a question and a sentence the model needs to judge if the sentence answers the question; (3) the Microsoft Research Paraphrase Corpus (MRPC) which asks a model to decide if two sentences are paraphrases of each other. The ground truth labels of all datasets are either 0 or 1. Following \citep{li-etal-2020-sentence,liu2021fast}, we compute Area Under Curve (AUC) scores using the binary labels and the relevance scores predicted by models.

\section{Experimental Setup}


\textbf{Training and evaluation details.}
For each task, we use all available sentence pairs (from train, development and test sets of all datasets combined) without their labels as training data. 
The original QQP and QNLI datasets are extremely large. 
We thus downsample QQP to have 10k, 1k and 10k pairs for train, dev and test; QNLI to have 10k train set. 
QNLI does not have public ground truth labels for testing. 
So, we use its first 1k examples in the official dev set as our dev data and the rest in the official dev set as test data. 
The dev set for MRPC is its official dev sets. The dev set for STS12-16, STS-B and SICK-R is the dev set of STS-B. 
We save one checkpoint for every 200 training steps and at the end of each epoch. We use the dev sets to select the best model for testing.\footnote{Note that checkpoints of bi- and cross-encoders are independently saved and evaluated on dev set. In the end, one best bi-encoder and one best cross-encoder are obtained.}
Dev sets are also used to tune the hyperprameters in each task.

For clear comparison with SimCSE and Mirror-BERT, we use their released checkpoints as initialisation points (i.e., we do not train models in \Cref{sec:mirror_bert} ourselves). 
We consider four SimCSE variants. Two base variants: SimCSE-BERT-base, SimCSE-RoBERTa-base; and two large variants: SimCSE-BERT-large, SimCSE-RoBERTa-large. We consider two Mirror-BERT variants: Mirror-RoBERTa-base and Mirror-RoBERTa-base-drophead.\footnote{We do not consider BERT-based checkpoints by \citet{liu2021fast} since they adopt mean pooling over all tokens. For brevity, we only experiment with encoders trained with \texttt{[CLS]}.} For brevity, our analysis in the main text focuses on SimCSE models. We list Mirror-BERT results in Appendix.
We train \modelname models for 3 cycles on the STS task and 5 cycles on the binary classification tasks. 
Within each cycle, all bi- and cross-encoders are trained for 10 and 1 epochs respectively for the STS task; 15 and 3 epochs for binary classification.\footnote{We use fewer epochs for cross-encoders since they usually converge much faster than bi-encoders.} 
All models use AdamW \citep{loshchilov2018decoupled} as the optimiser. 
In all tasks, unless noted otherwise, we create final representations using \texttt{[CLS]}. We train our base models on a server with 4 * V100 (16GB) GPUs and large models on a server with 8 * A100 (40GB) GPUs. All main experiments have the same fixed random seed. All other hparams are listed in Appendix.

\textbf{Mutual-distillation setup.} 
For the two models used for mutual-distillation, they are either (1) the base variant of SimCSE-BERT and SimCSE-RoBERTa or (2) the large variant of the two. 
Theoretically, we could mutually distil even more models but we keep the setup simple for fast and clear comparison. 
Also, since mutual-distillation models use information from both PLMs, we also list (in tables) \textit{ensemble results} that use the average of the predictions from two \modelnames.




\section{Results and Discussion}


\begin{table}[!t] \setlength{\tabcolsep}{2.0pt}
\centering
\small
\begin{tabular}{llccccccccccc}
\cmidrule[1.5pt]{1-10}
\# & dataset$\rightarrow$  & STS12 & STS13 & STS14 & STS15 & STS16 & STS-B & SICK-R & avg.\\
\cmidrule[1.5pt]{1-10}
\multicolumn{9}{c}{\textit{single-model results}} \\
\cmidrule[1.0pt]{1-10}
1 & SimCSE-BERT-base$^\ast$ & 68.64 & 82.39 & 74.30 & 80.69 & 78.71 & 76.54 & 72.22 & 76.21 \\
1.1 & + \tenc (bi) & 72.17 & 84.40 & 76.69 & 83.28 & 80.91 & 81.26 & 71.84 & 78.65 \\
1.2 & + \tenc (cross) & 71.94 & 84.14 & 76.39 & 82.87 & 80.65 & 81.06 & 71.16 & 78.32\\
\rowcolor{blue!5}
1.3 & + \tenc-mutual (bi) & 75.09 & 85.10 & 77.90 & \textbf{85.08} & \textbf{83.05} & \textbf{83.90} & \textbf{72.76} & \textbf{80.41} \\
\rowcolor{blue!5}
1.4 & + \tenc-mutual (cross) & \textbf{75.44} & \textbf{85.59} & \textbf{78.03} & 84.44 & 82.65 & 83.61 & 69.52 & 79.90 \\
\hdashline
2 & SimCSE-RoBERTa-base & 68.34 & 80.96 & 73.13 & 80.86 & 80.61 & 80.20 & 68.62 & 76.10 \\
2.1 & + \tenc (bi) &   73.36 & 82.47 & 76.39 & 83.96 & 82.67  & 82.05 & 67.63 & 78.36 \\
2.2 & + \tenc (cross) & 72.59 & 83.24 & 76.83 & 84.20 & 82.82 & 82.85 & 69.51 & 78.86 \\
\rowcolor{blue!5}
2.3 & + \tenc-mutual (bi) & 75.01 & 85.22 & 78.26 & 85.16 & 83.22 & 83.88 & \textbf{72.56} & 80.47 \\
\rowcolor{blue!5}
2.4 & + \tenc-mutual (cross) & \textbf{76.37} & \textbf{85.87} & \textbf{79.03} & \textbf{85.77} & \textbf{83.77} & \textbf{84.65} & 72.62 & \textbf{81.15} \\
\cmidrule[.5pt]{1-10}
3 & SimCSE-BERT-large & 71.30 & 84.32 & 76.32 & 84.28 & 79.78 & 79.04 & \textbf{73.88} & 78.42 \\ 
3.1 & + \tenc (bi) & 75.55 & 84.08 & 77.01 & 85.43 & 81.37 & 82.88 & 71.46 & 79.68 \\
3.2 &+ \tenc (cross) & 75.81 & 84.51 & 76.50 & 85.65 & 82.14 & 83.47 & 70.90 & 79.85 \\
\rowcolor{red!5}
3.3 &+ \tenc-mutual (bi) & \textbf{78.19} & \textbf{88.51} & \textbf{81.37} & \textbf{88.16} & \textbf{84.81} & \textbf{86.16} & 71.33 & \textbf{82.65} \\
\rowcolor{red!5}
3.4 & + \tenc-mutual (cross) & 77.97 & 88.31 & 81.02 & 88.11 & 84.40 & 85.95 & 71.92 & 82.52 \\
\hdashline
4 & SimCSE-RoBERTa-large & 71.40 & 84.60 & 75.94 & 84.36 & 82.22 & 82.67 & 71.23 & 78.92 \\
4.1 & + \tenc (bi) & 77.92 & 86.69 & 79.29 & 87.23 & 84.22 & 86.10 & 68.36 & 81.40 \\
4.2 & + \tenc (cross) &  \textbf{78.32} & 86.20 & 79.61 & 86.88 & 82.93 & 84.48 & 67.90 & 80.90 \\
\rowcolor{red!5}
4.3 & + \tenc-mutual (bi) & 78.15 & \textbf{88.39} & 81.76 & 88.38 & 84.95 & 86.55 & \textbf{72.31} & \textbf{82.93}  \\
\rowcolor{red!5}
4.4 & + \tenc-mutual (cross) & 78.28 & 88.31 & \textbf{81.94} & \textbf{88.63} & \textbf{85.03} & \textbf{86.70} & 71.63 & \textbf{82.93} \\
\cmidrule[1.5pt]{1-10}
\multicolumn{9}{c}{\textit{ensemble results} (average predictions of two models)} \\
\cmidrule[1.0pt]{1-10}
1+2 & SimCSE-base ensemble & 70.71 & 83.49 & 76.45 & 83.13 & 81.79 & 81.51 & 71.94 & 78.43 \\
1.1+2.1 &\tenc-base (bi) ensemble & 73.58 & 85.01 & 78.35 & 85.02 & 83.21 & 84.07 & 70.93 & 80.03 \\
1.2+2.2 & \tenc-base (cross) ensemble &  74.25 & 84.92 & 78.57 & 85.16 & 83.25 & 83.52 & 70.73 & 80.06 \\
\rowcolor{blue!5}
1.3+2.3 & \tenc-mutual-base (bi) ensemble & 75.29 & 85.34 & 78.49 & 85.28 & 83.43 & 84.09 & \textbf{72.75} & 80.67\\
\rowcolor{blue!5}
1.4+2.4 & \tenc-mutual-base (cross) ensemble &  \textbf{76.60} & \textbf{86.18} & \textbf{79.09} & \textbf{85.49} & \textbf{83.64} & \textbf{84.67} & 71.96 & \textbf{81.09} \\
\cmidrule[.5pt]{1-10}
3+4 &SimCSE-large ensemble & 73.22 & 86.03 & 78.15 & 85.95 & 82.83 & 83.05 & \textbf{73.86} & 80.66 \\
3.1+4.1 & \tenc-large (bi) ensemble & 78.49 & 87.02 & 80.31 & 87.85 & 84.31 & \textbf{86.54} & 72.39 & 82.41 \\
3.2+4.2 & \tenc-large (cross) ensemble & 77.93 & 86.91 & 79.83 & 87.82 & 83.74 & 85.58 & 72.02 & 81.98 \\
\rowcolor{red!5}
3.3+4.3 & \tenc-mutual-large (bi) ensemble & 78.42 & 88.60 & \textbf{81.91} & 88.38 & \textbf{85.01} & 86.52 & 72.23 & 83.01 \\
\rowcolor{red!5}
3.4+4.4 & \tenc-mutual-large (cross) ensemble & \textbf{78.52} & \textbf{88.70} & 81.90 & \textbf{88.67} & 84.96  & 86.70 & 72.03 & \textbf{83.07} \\
\cmidrule[1.5pt]{1-10}

\end{tabular}
\vspace{-1.0mm}
\caption{English STS. Spearman's $\rho$ rank correlations are reported. \tenc models use only self-distillation while \tenc-mutual models use mutual-distillation as well. \colorbox{blue!10}{Blue} and \colorbox{red!10}{red} denotes mutual-distillation models that are trained in the \colorbox{blue!10}{base} and \colorbox{red!10}{large} group respectively. Models without colour are not co-trained with any other models. $^\ast$Note that for base encoders, our results can slightly differ from numbers reported in \citep{gao2021simcse} since different evaluation packages are used.}
\label{tab:sts}
\vspace{-2.0mm}
\end{table}

\subsection{Main Results}

\textbf{STS results (\Cref{tab:sts}).} The main results for STS are listed in \Cref{tab:sts}. Compared with the baseline SimCSE, \modelname has brought significant improvements across the board. With various variants of the SimCSE as the base model, \modelname consistently enhances the average score by approximately 4-5\%.\footnote{Similar trends observed on Mirror-BERT, see Appendix (\Cref{app:mirrorbert}).} Self-distillation usually brings an improvement of 2-3\% (e.g., compare line 1.1, 1.2 with 1 in \Cref{tab:sts}). Further, mutual-distillation brings another boost of 1-3\% (e.g., compare line 3.3, 3.4 with 3.1, 3.2 in \Cref{tab:sts}).
Besides single-model results, the ensemble of mutual-distilled models are clearly better than the ensemble models of either (1) naively averaging the two initial SimCSE models' scores or (2) averaging predictions of two self-distilled models in a \textit{post hoc} manner. This demonstrates the benefit of allowing models to communicate/synchronise with each other in all stages of the self-distillation training.

\textbf{Binary classification results (\Cref{tab:binary}).} On QQP, QNLI, and MRPC, we observe similar trends as the STS tasks, and the improvement is sometimes even more significant (see full table in Appendix \Cref{tab:binary_full}). We conjecture it is due to the fact that \modelname training also adapts models to the task domain (since tasks like QQP and QNLI are very different from Wikipedia data, which is where SimCSE models are trained on). We will discuss the domain adaptation effect in more details in analysis. Another point worth discussing is the benefit of mutual-distillation is more inconsistent on binary classification tasks, compared with STS tasks (again, see full table \Cref{tab:binary_full} in Appendix). We suspect it is due to the performance imbalance between the BERT and RoBERTa variants on these tasks (a significant performance gap exists in the first place). 



\begin{table}[!t] \centering
\begin{tabular}{lccccccccccc}
\cmidrule[1.5pt]{1-10}
dataset$\rightarrow$  & QQP & QNLI & MRPC & avg.\\
\cmidrule[1.5pt]{1-10}
  SimCSE-BERT-base & 80.38 & 71.38 & 75.02 & 75.59 \\
  + \tenc (bi) & 82.10 & 75.30 & 75.71 & 77.70 \\
  + \tenc (cross) & 82.10 & 75.61  & 76.21 & 77.97 \\
 \rowcolor{blue!5}
  + \tenc-mutual (bi) &  84.00 & 76.93 & 76.62 & 79.18  \\
   \rowcolor{blue!5}
  + \tenc-mutual (cross) & \textbf{84.29} & \textbf{77.11} & \textbf{77.77} & \textbf{79.72} \\
\cmidrule[1.5pt]{1-10}
\end{tabular}
\vspace{-1mm}
\caption{Binary classification task results. AUC scores are reported. We only demonstrate results for one model for brevity. Full table can be found in Appendix (\Cref{tab:binary_full}).}
\label{tab:binary}
\end{table}




\textbf{Domain transfer setup (\Cref{tab:binary_transfer}).} One of the key questions we are keen to find out is how much of \modelname's success on in-domain tasks generalises/transfers to other tasks/domains. 
Specifically, does \modelname create universally better bi- and cross-encoders, or is it only task/domain-specific?
To answer the question, we directly test models trained with the STS task data on binary classification tasks. 
For bi-encoders, i.e., \tenc (bi), the results are inconsistent across setups. These results hint that training on in-domain data is important for optimal performance gains for unsupervised bi-encoders. This is in line with the finding of \citep{liu2021fast}.
However, for cross-encoders, surprisingly, we see extremely good transfer performance. W/ or w/o mutual-distillation, \tenc (cross) models outperform the SimCSE baselines by large margins, despite the fact that tasks like QQP and QNLI are of a very different domain compared with STS. In fact, they are sometimes even better than models tuned on the in-domain task data (c.f. \Cref{tab:binary_full}). This finding has deep implications. It hints that the cross-encoder architecture (cross-attention) is by design very suitable for sentence-pair modelling (i.e., strong inductive bias is already in the architecture design), and once its sentence-pair modelling capability is `activated', it is an extremely powerful  universal representation that can be transferred to other tasks.
The reason that STS models outperform in-domain models in some tasks hint that more sentence-pairs as raw training data is welcome (since the STS train set is larger than the binary classification ones). As future work, we plan to explore mining sentence pairs for \modelname learning from a general corpus (such as Wikipedia). Both lexical- (such as BM25) and semantic-level (neural models such as bi-encoders) IR systems could be leveraged here.



\begin{table}[!t] \centering
\begin{tabular}{lccccccccccc}
\cmidrule[1.5pt]{1-10}
 dataset$\rightarrow$  & QQP & QNLI & MRPC & avg.\\
\cmidrule[1.0pt]{1-10}
  SimCSE-RoBERTa-base & 81.82 & 73.54 & 75.06 & 76.81  \\
 + \tenc (bi) & 82.56 & 71.67 & 74.24 & 76.16 \\
   + \tenc (cross) & 83.66 & 79.38 & 79.53 & 80.86 \\
    \rowcolor{blue!5}
  + \tenc-mutual (bi) & 81.71 & 72.78 & 75.51 & 76.67 \\
    \rowcolor{blue!5}
 + \tenc-mutual (cross) & \textbf{83.92} & \textbf{79.79} & \textbf{79.96} & \textbf{81.22} \\
  \cmidrule[1.5pt]{1-10}
\end{tabular}
\vspace{-1mm}
\caption{A domain transfer setup: testing \modelname models trained with STS data directly on binary classification tasks. We only demonstrate results for one model for brevity. Full table can be found in Appendix (\Cref{tab:binary_transfer_full}).}
\label{tab:binary_transfer}
\vspace{-2.0mm}
\end{table}



\subsection{Discussions and Analysis}\label{sec:discuss_and_analysis}

In this section we discuss some interesting phenomena we observed, justify design choices we made in an empirical way, and also show a more fine-grained understanding of what exactly happens when using \modelname. 

\textbf{Initialise with the original weights or train sequentially? (\Cref{fig:ablation_sfig1})} As mentioned in \Cref{sec:bi_to_cross} and \Cref{sec:cross_to_bi}, we initialise bi-encoders with SimCSE/Mirror-BERT weights and cross-encoders with PLMs' weights (we call this strategy \textit{refreshing}). We have also tried maintaining the weights of bi- and cross-encoders sequentially. I.e., we initialise the cross-encoder's weights with the bi-encoder which just created the pseudo labels and vice versa (we call this strategy \textit{sequential}). The benefit of doing so is keeping all the legacy knowledge learned in the process of self-distillation in the weights. As suggested in \Cref{fig:ablation_sfig1} (also in Appendix \Cref{tab:sequential}), \textit{refreshing} is slightly better than \textit{sequential}. We suspect it is because initialising with original weights alleviate catastrophic forgetting problem in self-supervised learning (SSL), similar to the moving average and stop-gradient strategy used in contrastive SSL methods such as MoCo \citep{he2020momentum}.


\begin{figure}
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[height=4.0cm]{figs/ablation_seq_ref_v2.pdf}
  \caption{Sequential vs. refreshing (on STS).}
  \label{fig:ablation_sfig1}
\end{subfigure}\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[height=4.0cm]{figs/ablation_sd_qnli_v2.pdf}
  \caption{\tenc vs.standard self-distillation (on QNLI).}
  \label{fig:ablation_sfig2}
\end{subfigure}
\vspace{-0.5mm}
\caption{Ablation studies of \modelname regarding two design choices.}
\label{fig:ablation}
\vspace{-0.5mm}
\end{figure}


\textbf{Self-distillation without alternating between different task formulations? (\Cref{fig:ablation_sfig2})} If we disregard the bi- and cross-encoder alternating training paradigm but using the same bi-encoder architecture all along, the model is then similar to the standard self-distillation model (c.f. Figure 1 by \citet{mobahi2020self}). Theoretically, standard self-distillation could also have helped, especially considering that it adapts the model to in-domain data. However, as seen in \Cref{fig:ablation_sfig2} (and also Appendix \Cref{tab:standard_self_distil}), standard self-distillation lags behind \modelname by a significant amount, and sometimes underperforms the base model. 
Standard self-distillation essentially ensembles different checkpoints (i.e., the same model at different training phases provides different `views' of the data). \modelname can be seen as a type of self-distillation model, but instead of using previous models to provide views of data, we use different task formulations (i.e., bi- and cross-encoder) to provide different views of the data. The fact that standard self-distillation underperforms \modelname by large margins suggests the effectiveness of our proposed bi- and cross-encoder training scheme. 



\textbf{How many cycles is optimal? (\Cref{fig:cycle})} 
Our approach iteratively bootstraps the performance of both bi- and cross-encoders. 
But how many iterations (cycles) are enough? 
We find that it heavily depends on the model and dataset, and could be unpredictable (since the `optimality' depends on a relatively small dev set). 
In \Cref{fig:cycle}, we plot the \tenc models' (self-distillation only) performances on dev sets in three tasks: STS, QQP, and QNLI. 
In general, the patterns are different across datasets and models. 

\begin{figure}
\begin{subfigure}{.4\textwidth}
  \centering
  \includegraphics[height=3cm]{figs/cycle_against_dev_score_sts_v2.pdf}
  \vspace{-4.0mm}
  \caption{STS}
  \label{fig:sfig1}
\end{subfigure}\begin{subfigure}{.28\textwidth}
  \centering
  \includegraphics[height=3cm]{figs/cycle_against_dev_score_qqp_v2.pdf}
  \vspace{-4.0mm}
  \caption{QQP}
  \label{fig:sfig2}
\end{subfigure}
\begin{subfigure}{.28\textwidth}
  \centering
  \includegraphics[height=3cm]{figs/cycle_against_dev_score_qnli_v2.pdf}
  \vspace{-4.0mm}
  \caption{QNLI}
  \label{fig:sfig3}
\end{subfigure}
\vspace{-2.0mm}
\caption{\tenc's performance against distillation cycles under different base models and tasks.}
\label{fig:cycle}
\vspace{-2.0mm}
\end{figure}

\textbf{Does more training data help? (\Cref{fig:num_sample})} We control the number of training samples drawn and test the \modelname model (using SimCSE-BERT-base) on STS test sets. The average performance on all STS tasks are reported in \Cref{fig:num_sample}, with three runs of different random seeds. There are in total 37,081 data points from STS. We only draw from these in-domain data until there is none left. It can be seen that for in-domain training, more data points are usually always beneficial. Next, we test with more samples drawn from another task, SNLI \citep{bowman-etal-2015-large}, containing abundant sentence-pairs. The performance of the model further increases till 30k extra data points and starts to gradually decrease after that point. However, it is worth mentioning that there will be discrepancy of such trends across tasks and models. And when needed, one can mine as many sentence-pairs as desired from a general corpus (such as Wikipedia) for \modelname learning. 




\begin{SCfigure}
  \caption{STS performance against number of training samples. `full' means all STS in-domain data are used. After `full', the samples are drawn from the SNLI dataset. Note that each point in the graph is an individual run.}
  \includegraphics[width=0.4\textwidth]{figs/performance_against_num_sample_v2.pdf}
   \label{fig:num_sample}
   \vspace{-3.0mm}
\end{SCfigure}




\section{Related Work}\label{sec:related_work}

Our work is closely related to (1) unsupervised sentence representation learning; (2) sentence-pair tasks using bi- and cross-encoders; and (3) self-distillation. 
Each has a large body of work which we can only provide a highly selected summary below.

\textbf{Unsupervised sentence representations.} Prior to the emergence of large PLMs such as BERT, popular unsupervised sentence embedding methods included Skip-Thoughts \citep{kiros2015skip}, FastSent \citep{hill2016learning}, and Quick-Thoughts \citep{logeswaran2018an}. 
They all exploit the co-occurrence statistics of sentences in large corpora (i.e., sentences under similar contexts have similar meanings). 
A recent paper DeCLUTR \citep{giorgi-etal-2021-declutr} follows such idea and formulate the training as a contrastive learning task. 
Very recently, there has been a growing interest in using individual raw sentences for self-supervised contrastive learning on top of PLMs. 
Contrastive Tension \citep{carlsson2021semantic}, Mirror-BERT \citep{liu2021fast}, SimCSE \citep{gao2021simcse}, Self-Guided Contrastive Learning \citep{kim-etal-2021-self}, ConSERT \citep{yan-etal-2021-consert}, BSL \citep{zhang-etal-2021-bootstrapped}, \textit{inter alia}, all follow such an idea. Specifically, data augmentations on either input or feature space are used to create two views of the same sentence for contrastive learning. In our experiments, we use such methods as an initial step for creating a reasonably strong bi-encoder.

\textbf{Cross- and bi-encoder for pairwise sentence tasks.}
Sentence-BERT \citep{reimers2019sentence} points out the speed advantage of bi-encoders and proposes to train BERT with a siamese architecture for sentence-pair tasks. Poly-encoder \citep{Humeau2020Poly} proposes a hybrid architecture in which intermediate encodings are cached and a final layer of cross-attention is used to exploit inter-sentence interactions. Conceptually similar to our work, Di-pair \citep{chen-etal-2020-dipair}, augmented Sentence-BERT \citep{thakur-etal-2021-augmented}, RocketQA \citep{qu2021rocketqa}, and DvBERT \citep{cheng2021dual} distil knowledge in supervised cross-encoders to bi-encoders. 
We show that it is also possible to distil knowledge from bi- to cross-encoders.

\textbf{Self-distillation.} In standard self-distillation, models of the same architecture train on predictions by previous checkpoint(s) with the same task formulation \citep{furlanello2018born,mobahi2020self}. However, the standard approach does not alter the training paradigm (task formulation) as we do (bi- and cross-encoder training). 
In experiments, we have shown that alternating task formulation is the key to the success of our method. 



\section{Conclusion}

We propose \modelname, an unsupervised approach of training bi- and cross-encoders for sentence-pair tasks. The core idea of \modelname is self-distillation in a smart way: alternatively training a bi-encoder and a cross-encoder (of the same architecture) with pseudo-labels created from the other. 
We also propose a mutual-distillation extension to mutually bootstrap two self-distillation models trained in parallel. On sentence-pair tasks including sentence similarity, question de-duplication, question-answering entailment, and paraphrase identification, we show strong empirical evidence verifying the effectiveness of \modelname. We also found the surprisingly strong generalisation capability of our trained cross-encoders across domains and tasks. Finally, we conduct thorough ablation studies and analysis to verify our design choices and shed insight on the model mechanism. 

\section{Acknowledgements}
We thank Hanchen Wang, Giorgio Giannone, Arushi Goel for providing useful feedback during internal discussions.


























































































































\bibliography{iclr2021_conference}
\bibliographystyle{iclr2021_conference}

\appendix
\section{Appendix}


\subsection{Results with Other Contrastive Learning Methods}\label{app:mirrorbert}

In the main text, we experimented with SimCSE, but in theory \modelname is compatible with any unsupervised contrastive bi-encoder learning models. In this section, we experiment with Mirror-BERT (which is similar to SimCSE) and also two additional unsupervised contrastive models Contrastive-Tension \citep{carlsson2021semantic} and DeCLUTR \citep{giorgi-etal-2021-declutr} to verify the robustness of \modelname. 

As seen in \Cref{tab:sts_mirrorbert} and \Cref{tab:binary_classification_mirrorbert}, \modelname brings consistent and significant improvements to all base models, similar to what we have observed on SimCSE models. 
After \modelname training, the Mirror-BERT-based models perform even slightly better than SimCSE-based models, on both the STS and binary classification tasks. We suspect it is due to that SimCSE checkpoints are trained for more iterations (with the contrastive learning objective) and thus are more prone to overfit the training corpus.

\begin{table}[!t] \setlength{\tabcolsep}{4.0pt}
\centering
\small
\begin{tabular}{lccccccccccc}
\cmidrule[1.5pt]{1-10}
dataset$\rightarrow$  & STS12 & STS13 & STS14 & STS15 & STS16 & STS-B & SICK-R & avg.\\
\cmidrule[1.5pt]{1-10}
Mirror-RoBERTa-base & 64.67 & 81.53 & 73.05 & 79.78 & 78.16 & 78.36 & \textbf{70.03} & 75.08 \\
 + \tenc (bi) & 71.99 & 81.85 & 75.73 & 83.32 & \textbf{79.97} & 81.19 & 69.47 & 77.64 \\
 + \tenc (cross) & \textbf{73.10} & \textbf{82.31} & \textbf{76.49} & \textbf{83.71} & 79.64 & \textbf{81.70} & 69.70 & \textbf{78.09} \\
\cmidrule[1.0pt]{1-10}
 Mirror-RoBERTa-base-drophead &  68.15 & 82.55 & 73.47 & 82.26 & 79.44 & 79.63 & 71.58 & 76.72\\
 + \tenc (bi) & 74.95 & 83.86 & 77.50 & 85.80 & 83.22 & 83.94 & 72.56 & 80.26  \\
 + \tenc (cross) & \textbf{75.70} & \textbf{84.58} & \textbf{78.35} & \textbf{86.49} & \textbf{83.96} & \textbf{84.26} & \textbf{72.76} & \textbf{80.87} \\
 \cmidrule[1.0pt]{1-10}
Contrastive-Tension-BERT-base & 61.98 & 76.82 & 68.35 & 77.38 & 76.56 & 73.99 & 69.20 & 72.04 \\
+ \tenc (bi) & 69.58 & \textbf{79.38} & \textbf{69.32} & \textbf{77.59} & 77.96 & 78.23 & \textbf{70.70} & 74.68 \\
+ \tenc (cross) & \textbf{70.67} & 79.27 & 69.26 & 76.77 & \textbf{78.78} & \textbf{79.08} & 70.66 & \textbf{74.93} \\
\cmidrule[1.0pt]{1-10}
DeCLUTR-RoBERTa-base & 45.56 & 73.38 & 63.39 & 72.72 & 76.15 & 66.40 & 68.99 & 66.66 \\
+ \tenc (bi) & \textbf{62.40} & 77.55 & \textbf{70.05} & 80.28 & \textbf{81.81} & 77.31 & \textbf{72.60} & \textbf{74.57} \\
+ \tenc (cross) & 60.68 & \textbf{78.11} & 69.23 & \textbf{80.48} & 81.03 & \textbf{78.47} & 70.07 & 74.01 \\
\cmidrule[1.5pt]{1-10}
\end{tabular}
\caption{English STS (models beyond SimCSE).  Spearman's $\rho$ scores are reported.}
\label{tab:sts_mirrorbert}
\end{table}

\begin{table}[!t] \centering
\small
\begin{tabular}{lccccccccccc}
\cmidrule[1.5pt]{1-10}
dataset$\rightarrow$  & QQP & QNLI & MRPC & avg.\\
\cmidrule[1.5pt]{1-10}
 Mirror-RoBERTa-base & 78.89 & 73.73 & 75.44 & 76.02 \\
 + \tenc (bi) & \textbf{82.34} & 79.57 & 77.08 & 79.66 \\
 + \tenc (cross) & 82.00 & \textbf{79.87} & \textbf{78.40} & \textbf{80.09} \\
\cmidrule[1.0pt]{1-10}
 Mirror-RoBERTa-base-drophead & 78.36 & 75.56 & 77.18 & 77.03 \\
 + \tenc (bi) & 82.04 & 82.12 & 79.63 & 81.26 \\
 + \tenc (cross) & \textbf{82.90} & \textbf{82.52} & \textbf{81.38} & \textbf{82.27} \\
 \cmidrule[1.0pt]{1-10}
Contrastive-Tension-BERT-base & 78.95 & 69.73 & \textbf{72.86} & 73.85  \\
 + \tenc (bi) & 80.96 & 68.31 & 72.54 & 73.94 \\
 + \tenc (cross) & \textbf{81.22} & \textbf{74.17} & 71.33 & \textbf{75.57}  \\
\cmidrule[1.0pt]{1-10}
DeCLUTR-RoBERTa-base  & 78.68 & 74.77 & 72.86 & 75.44 \\
 + \tenc (bi) & 83.64 & 82.87 & 74.55 & 80.35 \\
 + \tenc (cross) & \textbf{84.02} & \textbf{83.41} & \textbf{75.55} & \textbf{80.99} \\
\cmidrule[1.5pt]{1-10}
\end{tabular}
\caption{Binary classification  (models beyond SimCSE). AUC scores are reported.}
\label{tab:binary_classification_mirrorbert}
\end{table}




\subsection{More Discussions and Analysis}\label{sec:more_discuss}


\paragraph{How robust is \modelname? (\Cref{tab:standard_sd})} As mentioned, our main experiments used one fixed random seed. Due to the scale of the experiments, performing multiple runs with different random seeds for all setups is overly expensive. We pick STS and the base variants of BERT and RoBERTa as two examples for showing results of five runs (shown in \Cref{tab:standard_sd}). In general, the \modelname approach is quite robust and stable.


\begin{table}[!t] \setlength{\tabcolsep}{3.6pt}
\centering
\begin{tabular}{lccccccccccc}
\cmidrule[1.5pt]{1-10}
 dataset$\rightarrow$  & mean & S.D. & \\
\cmidrule[1.0pt]{1-10}
 SimCSE-BERT-base \\
 + \tenc (bi) & 78.72 & 0.16 \\
 + \tenc (cross) & 78.21 & 0.26  \\
  \cmidrule[.5pt]{1-10}
 SimCSE-RoBERTa-base     \\
 + \tenc (bi) & 78.38 & 0.26 \\
 + \tenc (cross) &  78.90 & 0.34  \\
  \cmidrule[1.5pt]{1-10}
\end{tabular}
\caption{Mean and standard deviation (S.D.) of five runs on STS.}
\label{tab:standard_sd}
\end{table}


\paragraph{STS and SICK-R as different tasks (\Cref{tab:sickr_standalone}, \Cref{fig:sickr_standalone}).}
It is worth noting that in the STS main results table (\Cref{tab:sts}), SICK-R is the only dataset where \modelname models lead to performance worse than the baselines in some settings (e.g., on SimCSE-BERT-large). We believe it is due to that SICK-R is essentially a different task from STS2012-2016 and STS-B since SICK-R is labelled with a different aim in mind. It focuses specifically on compositional distributional semantics.\footnote{SICK-R ``includes a large number of sentence pairs that are rich in the lexical, syntactic and semantic phenomena that Compositional Distributional Semantic Models (CDSMs) are expected to account for (e.g., contextual synonymy and other lexical variation phenomena, active/passive and other syntactic alternations, impact of negation, determiners and other grammatical elements), but do not require dealing with other aspects of existing sentential data sets (e.g., STS, RTE) that are not within the scope of compositional distributional semantics.'' (see \url{http://marcobaroni.org/composes/sick.html}).} To verify our claim, we train SICK-R as a standalone task using its official dev set instead of STS-B. All sentence pairs from SICK-R are used as raw training data. 
The results are shown in \Cref{tab:sickr_standalone} and \Cref{fig:sickr_standalone}. 
As shown, around 3-4\% gain can be obtained by switching to training on SICK-R only, confirming the different nature of the two tasks. 
This suggests that generalisation is also dependent on the standard of how relevance is defined between sequences in the target dataset, and training with an in-domain dev set maybe crucial when the domain shift between training and testing data is significant.



\begin{table}[!t] \setlength{\tabcolsep}{3.6pt}
\centering
\small
\begin{tabular}{llccccccccccc}
\cmidrule[1.5pt]{1-10}
&  Data$\rightarrow$  & & \multicolumn{2}{c}{STS} & & \multicolumn{2}{c}{SICK-R} & \\
\cmidrule[.5pt]{4-5} \cmidrule[.5pt]{7-8}
 & model$\rightarrow$ & off-the-shelf &  +\tenc (bi)  &  +\tenc (cross) & &  +\tenc (bi) & +\tenc (cross) & \\
\cmidrule[1.0pt]{1-10}  
& SimCSE-BERT-base & 72.22 & 71.84 & 71.16 & & 74.13 & 74.43 \\
& SimCSE-RoBERTa-base & 68.62 & 67.63 & 69.51 & & 68.39 & 70.38 \\
& SimCSE-BERT-large & 73.88  & 71.46 & 70.90 & & 74.92 & 74.98 \\
& SimCSE-RoBERTa-large & 71.23 & 68.36 & 67.90 & & 72.63 & 73.13 \\
\cmidrule[1.5pt]{1-10}
\end{tabular}
\caption{Compare \modelname models trained with all STS data (using STS-B's dev set) and SICK-R data only (using SICK-R's dev set). Large performance gains can be obtained when treating SICK-R as a standalone task. }
\label{tab:sickr_standalone}
\end{table}


\begin{figure}
    \centering
    \includegraphics[width=1.0\linewidth]{figs/discuss_sickr_standalone.pdf}
    \caption{Graphical presentation of \Cref{tab:sickr_standalone}.}
    \label{fig:sickr_standalone}
\end{figure}

\paragraph{Gradient derivation of BCE and MSE loss.} We show that BCE is essentially a normalised version of MSE where the gradient of $x_i$ is scaled by the sigmoid function ($\sigmoid(\cdot)$). Here are the gradients of the two loss functions:
\begin{equation}
    \begin{split}
    \frac{\partial \mathcal{L}_{\text{BCE}}}{\partial x_i} &= -\frac{1}{N}\Big(y_i (\sigma(x_i)-1) + (1-y_i)\sigma(x_i)\Big) \\
    &=  -\frac{1}{N}\Big(\sigma(x_i)- y_i\Big) \\
    \frac{\partial \mathcal{L}_{\text{MSE}}}{\partial x_i} &= -\frac{2}{N}\Big(x_i- y_i\Big).
\end{split}
\label{eq:gradient}
\end{equation}
As can be seen, the only difference lies in whether $x_i$ is scaled by $\sigmoid(\cdot)$. This gives a greater degree of freedom to $\mathcal{L}_{\text{BCE}}$ especially at the areas in the two ends (close to $0$ or $1$): a large change of $x_i$ results in a small change of $\sigma(x_i)$, making the approximation of $y_i$ an easier task. In other words, in $\mathcal{L}_{\text{BCE}}$, it is in general easier for the model to push the gradient to $0$, while in  $\mathcal{L}_{\text{MSE}}$, only a strict numerical match leads to $0$ gradient.

\paragraph{Loss function configurations (\Cref{tab:loss_choice}).} We experimented with loss function configurations comprehensively and found that it requires caution when choosing learning objectives for cross- to bi-encoder and bi- to cross-encoder distillation. As mentioned in the main text and the paragraph above, choosing MSE for bi-to-cross distillation causes severe overfitting to the pseudo scores and choosing BCE for cross-to-bi distillation fail to make the model converge. As a result, our configuration of using BCE and MSE for bi-to-cross and cross-to-bi distillations respectively becomes the only plausible solution (see \Cref{tab:loss_choice}).

For the regression loss used for cross-to-bi distillation, besides MSE, we also experimented with several other regression loss functions such as Log-Cosh but found no improvement.


\begin{table}[!t] \setlength{\tabcolsep}{4.0pt}
\centering
\small
\begin{tabular}{lccccccccccc}
\cmidrule[1.5pt]{1-10}
loss$_{\small \text{bi-to-cross}}$ &  loss$_{\small \text{cross-to-bi}}$ & result\\
\cmidrule[1.0pt]{1-10}
BCE & MSE & \modelname configuration (\cmark) \\
\hdashline
BCE & BCE & cross-to-bi distillation won't converge (\xmark) \\
\hdashline
MSE & MSE & bi-to-cross distillation overfits completely to pseudo labels (\xmark) \\
\hdashline
\multirow{ 2}{*}{MSE} & \multirow{ 2}{*}{BCE} & bi-to-cross distillation overfits completely to pseudo labels (\xmark) \&   \\
& & cross-to-bi distillation won't converge (\xmark) \\
\cmidrule[1.5pt]{1-10}
\end{tabular}
\caption{Compare different loss function configurations.}
\label{tab:loss_choice}
\end{table}


\paragraph{Do sentence pairs leak label information? (\Cref{tab:label_leak})} \modelname has leveraged the sentence pairs given by the task. One concern is that the sentence pairs may be positively correlated and the model may have exploited this na\"ive bias. We highlight that this work does not have this concern as the tasks in our study test the \textit{relative similarity ranking} of sentence pairs under the evaluation metrics (both spearman's rank used in STS and AUC used in binary classification are ranking-based). Therefore, the overall correlation distribution of sentence pairs does not reveal what is tested by the tasks in this study.
To further verify the model has not learned label distribution from the task, we run a controlled setting where we treat all sentence pairs from the tasks as (pseudo-)positive pairs and apply a standard contrastive finetuning framework (i.e. Mirror-BERT and SimCSE finetuning) with \Cref{eq:infonce} as the loss on these pairs. Performance improvement from this finetuning setup will indicate that the overall positive correlation from the sentence pairs can be exploited by the model. Results are shown in \Cref{tab:label_leak}. Contrastive methods on pseudo-positive pairs almost always\footnote{The only exception is QNLI. We suspect it is because QNLI is from the QA domain and contrastive tuning on QNLI sentence pairs has some domain adaptation effect. According to \citet{liu2021fast}, contrastive tuning on randomly sampled sentences from the target domain can also achieve domain adaptation, and sentence pairs from the task are thus not a must.} underperform the original SimCSE and Mirror-BERT checkpoints significantly while \modelname models improve the checkpoints by large margins.



\begin{table}[!t] \centering
\small
\begin{tabular}{lccccccccccc}
\cmidrule[1.5pt]{1-10}
dataset$\rightarrow$  & STS (avg.) & QQP & QNLI & MRPC & avg.\\
\cmidrule[1.5pt]{1-10}
 SimCSE-RoBERTa-base & 76.10 & 81.82 & 73.54 & 75.06 & 76.63 \\
 + \tenc (bi) & 78.36 & 84.13 & 77.08 & 75.29 & 78.72  \\
 + \tenc (cross) & \textbf{78.86} & \textbf{85.16} & \textbf{80.49} & \textbf{76.09} &  \textbf{80.15} \\
 \hdashline
 + contrastive tuning & 73.93 & 74.00 & 77.56 & 75.25 &  75.19 \\
\cmidrule[1.0pt]{1-10}
 Mirror-RoBERTa-base-drophead & 76.72 & 78.36 & 75.56 & 77.18 & 77.00 \\
 + \tenc (bi) & 80.26 & 82.04 & 82.12 & 79.63 & 81.01 \\
 + \tenc (cross) & \textbf{80.87} & \textbf{82.90} & \textbf{82.52} & \textbf{81.38} & \textbf{82.27} \\
 \hdashline
  + contrastive tuning & 72.21 & 73.51 & 77.50 & 75.63 & 74.71 \\
\cmidrule[1.5pt]{1-10}
\end{tabular}
\caption{Compare \modelname with SimCSE/Mirror-BERT-style contrastive tuning on sentence pairs given by the task.}
\label{tab:label_leak}
\end{table}

\subsection{Training Time}
\paragraph{Overall runtime.} We list the runtime of \modelname models on different tasks and configurations in \Cref{tab:runtime}. All base models can be trained under 2.5 hours and large models can be trained within 5 hours. \tenc-mutual models usually take twice the amount of time training a self-distillation model. Also, \tenc-mutual models require two GPUs while self-distillation models need only one. We have tested running \modelname on three types of Nvidia GPUs: V100 (16 GB), A100 (40 GB) and 3090 (24 GB). The runtimes are similar. 

\paragraph{Cross-encoder vs. bi-encoder.} For training one epoch, bi-encoder takes significantly less time than cross-encoders. However, bi-encoders take much longer time to converge (15 epochs vs. 3 epochs on binary classification tasks and 10 epochs vs. 1 epoch on STS; see \Cref{tab:hparams}). As a result, in practice, bi-to-cross and cross-to-bi distillations take similar amount of time.


\begin{table}[!t] \centering
\small
\begin{tabular}{lccccccccccc}
\cmidrule[1.5pt]{1-10}
  model size & dataset & \# GPU required & time \\
\cmidrule[1.5pt]{1-10}
\tenc (base) & STS & 1 & $\approx$0.5 hrs \\
\tenc (large) & STS & 1 & $\approx$1.5 hrs \\
\tenc-mutual (base) & STS & 2 & $\approx$1.25 hrs \\
\tenc-mutual (large) & STS & 2 & $\approx$3 hrs \\
\cmidrule[1.0pt]{1-10}
\tenc (base) & QQP & 1 & $\approx$1 hrs \\
\tenc (large) & QQP & 1 & $\approx$2.5 hrs \\
\tenc-mutual (base) & QQP & 2 & $\approx$2.25 hrs \\
\tenc-mutual (large) & QQP & 2 & $\approx$5 hrs  \\
\cmidrule[1.0pt]{1-10}
\tenc (base) & QNLI & 1 & $\approx$0.5 hrs \\
\tenc (large) & QNLI & 1 &  $\approx$1.75 hrs \\
\tenc-mutual (base) & QNLI & 2 & $\approx$1.25 hrs \\
\tenc-mutual (large) & QNLI & 2 & $\approx$3.5 hrs \\
\cmidrule[1.0pt]{1-10}
\tenc (base) & MRPC & 1 & $\approx$0.25 hrs \\
\tenc (large) & MRPC & 1 & $\approx$0.75 hrs \\
\tenc-mutual (base) & MRPC & 2 & $\approx$0.5 hrs  \\
\tenc-mutual (large) & MRPC & 2 & $\approx$1.5 hrs  \\
\cmidrule[1.5pt]{1-10}
\end{tabular}
\caption{Running time for all models across different datasets/tasks. We experimented with NVIDIA V100, A100 and 3090 and found the estimated time to be similar.}
\label{tab:runtime}
\end{table}



\subsection{Full Tables}

Here, we list the full tables of SimCSE binary classification results (\Cref{tab:binary_full}); SimCSE domain transfer results (\Cref{tab:binary_transfer_full}); and full tables for ablation studies (\Cref{tab:sequential}, \Cref{tab:standard_self_distil}), which are presented as figures in the main texts in \Cref{fig:ablation}.

\begin{table}[!t] \setlength{\tabcolsep}{3.6pt}
\centering
\begin{tabular}{llccccccccccc}
\cmidrule[1.5pt]{1-10}
\# & dataset$\rightarrow$  & QQP & QNLI & MRPC & avg.\\
\cmidrule[1.5pt]{1-10}
\multicolumn{9}{c}{\textit{single-model results}} \\
\cmidrule[1.0pt]{1-10}
 & SimCSE-BERT-base & 80.38 & 71.38 & 75.02 & 75.59 \\
 & + \tenc (bi) & 82.10 & 75.30 & 75.71 & 77.70 \\
  & + \tenc (cross) & 82.10 & 75.61  & 76.21 & 77.97 \\
 \rowcolor{blue!5}
  & + \tenc-mutual (bi) &  84.00 & 76.93 & 76.62 & 79.18  \\
   \rowcolor{blue!5}
  & + \tenc-mutual (cross) & \textbf{84.29} & \textbf{77.11} & \textbf{77.77} & \textbf{79.72} \\
\hdashline
 & SimCSE-RoBERTa-base & 81.82 & 73.54 & 75.06 & 76.81  \\
 & + \tenc (bi) & 84.13 & 77.08 & 75.29 & 78.83  \\
  & + \tenc (cross) & \textbf{85.16} & \textbf{80.49} & 76.09 & \textbf{80.58}  \\
   \rowcolor{blue!5}
   & + \tenc-mutual (bi) & 84.36 & 77.29 & 76.90 & 79.52  \\
    \rowcolor{blue!5}
  & + \tenc-mutual (cross) & 84.73 & 77.32 & \textbf{78.47} & 80.17 \\
 \cmidrule[.5pt]{1-10}
 & SimCSE-BERT-large & 82.42 & 72.46 & 75.93 & 76.94 \\
  & + \tenc (bi) & 84.53 & 78.22 & 78.42 & 80.39 \\
  & + \tenc (cross) & 84.18 & 79.71 & 79.43 & 81.11 \\
  \rowcolor{red!5}
   & + \tenc-mutual (bi) & 85.72 & \textbf{81.61} & 79.59 & 82.31   \\
     \rowcolor{red!5} 
  & + \tenc-mutual (cross) & \textbf{86.55} & 81.55 & \textbf{79.69} & \textbf{82.60} \\
\hdashline
 & SimCSE-RoBERTa-large & 82.99 & 75.76 & 77.24 & 78.66 \\
   & + \tenc (bi) & 85.65 & 84.49 & 79.34 & 83.16 \\
  & + \tenc (cross) & 86.16 & \textbf{84.69} & 81.00 & \textbf{83.95} \\
    \rowcolor{red!5}
   & + \tenc-mutual (bi) &  85.65 & 81.87 & 79.53 & 82.35 \\
     \rowcolor{red!5}
  & + \tenc-mutual (cross) & \textbf{86.38} & 83.14 & \textbf{81.77} & 83.76 \\
  \cmidrule[1.5pt]{1-10}
  
\multicolumn{9}{c}{\textit{ensemble results} (average predictions of two models)} \\
  \cmidrule[1.0pt]{1-10}
& SimCSE-base ensemble & 81.10 & 72.46 & 75.04 & 76.20 \\
&\tenc-base (bi) ensemble & 83.11 & 76.19 & 75.45 & 78.25 \\
 & \tenc-base (cross) ensemble & 84.15 & \textbf{78.55} & \textbf{78.90} & \textbf{80.53} \\
\rowcolor{blue!5}
& \tenc-mutual-base (bi) ensemble & 84.18 & 77.11 & 76.76 & 79.35  \\
\rowcolor{blue!5}
 & \tenc-mutual-base (cross) ensemble & \textbf{84.68} & 77.92 & 78.22 & 80.27 \\
\cmidrule[.5pt]{1-10}
 & SimCSE-large ensemble & 82.47 & 74.09 & 76.55 & 77.70 \\
  & \tenc-large (bi) ensemble & 85.09 & 81.35 & 78.88 & 81.77 \\
  & \tenc-large (cross) ensemble & 86.22 & \textbf{83.78} & 81.06 & \textbf{83.69} \\
\rowcolor{red!5}
 & \tenc-mutual-large (bi) ensemble & 86.10 & 81.74 & 79.56 & 82.47 \\
\rowcolor{red!5}
 & \tenc-mutual-large (cross) ensemble & \textbf{86.26} & 82.86 & \textbf{81.41} & 83.51 \\
\cmidrule[1.5pt]{1-10}
\end{tabular}
\caption{Binary classification task results (SimCSE models; full table). AUC scores are reported.}
\label{tab:binary_full}
\end{table}

\begin{table}[!t] \setlength{\tabcolsep}{3.6pt}
\centering
\begin{tabular}{lccccccccccc}
\cmidrule[1.5pt]{1-10}
 dataset$\rightarrow$  & QQP & QNLI & MRPC & avg.\\
\cmidrule[1.0pt]{1-10}
  SimCSE-BERT-base & 80.38 & 71.38 & 75.02 & 75.59  \\
  + \tenc (bi) & 80.80 &  72.35 &  74.53 & 75.89 \\
   + \tenc (cross) & 80.84 & \textbf{78.81} & \textbf{79.42} & 79.69 \\
      \rowcolor{blue!5}
   + \tenc-mutual (bi) & \textbf{83.24} &  72.88 & 75.86 & 77.33 \\
      \rowcolor{blue!5}
   + \tenc-mutual (cross) & 82.40 & 78.30 & 78.72 & \textbf{79.81} \\
\hdashline
  SimCSE-RoBERTa-base & 81.82 & 73.54 & 75.06 & 76.81  \\
 + \tenc (bi) & 82.56 & 71.67 & 74.24 & 76.16 \\
   + \tenc (cross) & 83.66 & 79.38 & 79.53 & 80.86 \\
    \rowcolor{blue!5}
  + \tenc-mutual (bi) & 81.71 & 72.78 & 75.51 & 76.67 \\
    \rowcolor{blue!5}
 + \tenc-mutual (cross) & \textbf{83.92} & \textbf{79.79} & \textbf{79.96} & \textbf{81.22} \\
 \cmidrule[.5pt]{1-10}
  SimCSE-BERT-large & 82.42 & 72.46 & 75.93 & 76.94  \\
   + \tenc (bi) & 81.86 & 71.99 & 74.99 & 76.28 \\
   + \tenc (cross) & \textbf{83.31} & \textbf{79.62} & 79.93 & 80.95 \\
    \rowcolor{red!5}
 + \tenc-mutual (bi) & 82.30 & 72.47 & 76.74 & 77.17 \\
  \rowcolor{red!5}
 + \tenc-mutual (cross) & 83.04 & 79.58 & \textbf{81.18} & \textbf{81.27} \\
\hdashline
 SimCSE-RoBERTa-large & 82.99 & 75.76 & 77.24 & 78.66 \\
 + \tenc (bi)  & 82.34 & 70.88 & 76.05 & 76.42 \\
 + \tenc (cross) & 85.98 & 80.07 & 81.20 & 82.42 \\
    \rowcolor{red!5}
 + \tenc-mutual (bi) & 85.28 & 71.56 & 76.81 & 77.88  \\
   \rowcolor{red!5}
 + \tenc-mutual (cross) & \textbf{86.31} &  \textbf{81.77} & \textbf{81.86} & \textbf{83.31} \\
  \cmidrule[1.5pt]{1-10}
\end{tabular}
\caption{Full table for domain transfer setup: testing \modelname (SimCSE models) trained with STS data directly on binary classification tasks. }
\label{tab:binary_transfer_full}
\end{table}


\begin{table}[!t] \setlength{\tabcolsep}{3.6pt}
\centering
\begin{tabular}{lccccccccccc}
\cmidrule[1.5pt]{1-10}
 dataset$\rightarrow$  & STS (avg.)\\
\cmidrule[1.0pt]{1-10}
 SimCSE-BERT-base & 76.21    \\
 + \tenc (bi) sequential &  78.08  \\
 + \tenc (cross) sequential &  77.92  \\
 + \tenc (bi) refreshing &  \textbf{78.65}  \\
 + \tenc (cross) refreshing & 78.32 \\
  \cmidrule[.5pt]{1-10}
  SimCSE-RoBERTa-base & 76.10  \\
  + \tenc (bi) sequential &   78.32 \\
  + \tenc (cross) sequential &  78.72  \\
  + \tenc (bi) refreshing &  78.36 \\
  + \tenc (cross) refreshing  & \textbf{78.86} \\
  \cmidrule[1.5pt]{1-10}
\end{tabular}
\caption{Ablation: sequential training with the same set of weights vs. refreshing weights for all models.}
\label{tab:sequential}
\end{table}

\begin{table}[!t] \setlength{\tabcolsep}{3.6pt}
\centering
\begin{tabular}{lccccccccccc}
\cmidrule[1.5pt]{1-10}
dataset$\rightarrow$  & STS (avg.) & QNLI & \\
\cmidrule[1.0pt]{1-10}
 SimCSE-BERT-base & 76.21 & 71.38  \\
  + standard-self-distillation & 77.16 & 70.95  \\
 + \tenc (bi) & 78.65 & 75.30 \\
  + \tenc (cross) & 78.32 & 75.61   \\
  \cmidrule[.5pt]{1-10}
SimCSE-RoBERTa-base & 76.10 & 73.54   \\
  + standard-self-distillation & 76.25 & 73.40\\
 + \tenc (bi) & 78.36 & 77.04\\
  + \tenc (cross) &  78.86 & 80.49 \\
  \cmidrule[1.5pt]{1-10}
\end{tabular}
\caption{Ablation: compare \modelname with standard self-distillation.}
\label{tab:standard_self_distil}
\end{table}





\subsection{Data Statistics}\label{sec:data_stats}

A complete listing of train/dev/test stats of all used datasets can be found in \Cref{tab:data_stat}. Note that for STS 2012-2016, we dropped all sentence-pairs without a valid score. And the train sets include all sentence pairs (w/o labels) regardless of split in each task.

\begin{table*}[h] \small
\centering
\begin{tabular}{lcccc}
\toprule
Dataset & $|$Train$|$ & $|$Dev$|$ & $|$Test$|$ \\
\midrule
STS 2012 & - & - & 3,108 \\
STS 2013 & - & - & 1,500 \\
STS 2014 & - & - & 3,750 \\
STS 2015 & - & - & 3,000 \\
STS 2016 & - & - & 1,186 \\
STS-B & - & 1,500  & 1,379 \\
SICK-R & - & 495 & 4,906 \\
STS train (full)$\star$ & 37,081 & - & -\\
\midrule
QQP & 21,000 & 1,000 & 10,000 \\
QNLI & 15,463 & 1,000 & 4,463 \\
MRPC & 5,801 & 408 & 1,725 \\
\bottomrule
\end{tabular}
\caption{A listing of train/dev/test stats of all used datasets. $\star$: a collection of all individual sentence-pairs from all STS tasks.}
\label{tab:data_stat}
\end{table*}


\subsection{Hyperparameters}\label{sec:hparams}
The full listing of hyperparameters is shown in \Cref{tab:hparams}. 
Since performing a grid-search for all these hparams is ultra-expensive, we mainly used the default hparams from the sentence-BERT library.\footnote{\url{www.sbert.net}} 
The hparams for \tenc and \tenc-mutual are the same.

\begin{table*}[h] \small
\centering
\begin{tabular}{lccccccc}
\toprule
 task & direction & learning rate &  batch size & epoch & max token length & cycles \\
\midrule
\multicolumn{7}{c}{\textit{base models}} \\
\midrule
STS & bi $\rightarrow$ cross & 2e-5 & 32 & 1 & 64 & 3\\
STS & cross $\rightarrow$ bi & 5e-5 & 128 & 10 & 32 & 3\\
binary & bi $\rightarrow$ cross & 2e-5 & 32 & 3 & 64 & 5\\
binary & cross $\rightarrow$ bi & 5e-5 & 128 & 15 & 32 & 5 \\
\midrule
\multicolumn{7}{c}{\textit{large models}}  \\
\midrule
STS & bi $\rightarrow$ cross & 2e-5 & 32 & 1 & 64 & 3 \\
STS & cross $\rightarrow$ bi & 5e-5 & 64 & 10 & 32 & 3 \\
binary & bi $\rightarrow$ cross & 2e-5 & 32 & 3 & 64& 5 \\
binary & cross $\rightarrow$ bi & 5e-5 & 64 & 15 & 32 & 5 \\
\bottomrule
\end{tabular}
\caption{A listing of hyperpamters used for all \modelname models.}
\label{tab:hparams}
\end{table*}




\subsection{Pre-trained Encoders}\label{sec:appendix_huggingface_urls}
A complete listing of URLs for all used PLMs is provided in \Cref{tab:model_url}. 


\begin{table*}[h] \scriptsize
\setlength{\tabcolsep}{1pt}
\centering
\begin{tabular}{ll}
\toprule
model & URL \\
\midrule
BERT & \url{https://huggingface.co/bert-base-uncased} \\
RoBERTa & \url{https://huggingface.co/roberta-base} \\
SimCSE-BERT-base & \url{https://huggingface.co/princeton-nlp/unsup-simcse-bert-base-uncased} \\
SimCSE-RoBERTa-base & \url{https://huggingface.co/princeton-nlp/unsup-simcse-roberta-base} \\
SimCSE-BERT-large & \url{https://huggingface.co/princeton-nlp/unsup-simcse-bert-large-uncased} \\
SimCSE-RoBERTa-large & \url{https://huggingface.co/princeton-nlp/unsup-simcse-roberta-large} \\
Mirror-RoBERTa-base & \url{https://huggingface.co/cambridgeltl/mirror-roberta-base-sentence} \\
Mirror-RoBERTa-base-drophead & \url{https://huggingface.co/cambridgeltl/mirror-roberta-base-sentence-drophead} \\
Contrastive-Tension-BERT-base & \url{https://huggingface.co/Contrastive-Tension/BERT-Base-CT} \\
DeCLUTR-RoBERTa-base & \url{https://huggingface.co/johngiorgi/declutr-base} \\
\bottomrule
\end{tabular}
\caption{A listing of HuggingFace URLs of all PLMs used in this work.}
\label{tab:model_url}
\end{table*}


\end{document}
