\documentclass{LMCS}

\theoremstyle{plain}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{xspace}
\usepackage{latexsym}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{hyperref,enumerate}

\def \A             {\mathcal{A}}
\def \aa            {\alpha}
\def \ABT           {\emph{ABT}\xspace}
\def \AGTA          {\emph{AGTA}\xspace}
\def \ann           {\ensuremath{\mathsf{ann}}\xspace}
\def \APT           {\emph{APT}\xspace}
\def \B             {\mathcal{B}}
\def \bottom        {\flat}
\def \C             {\mathcal{C}}
\def \coUP          {\textsc{co--UP}\xspace}
\def \CTL           {\emph{CTL}\xspace}
\def \CTLSTAR       {\emph{CTL}\xspace}
\def \degree        {deg}
\def \edge          {E}
\def \exec          {exec}
\def \EXP           {{\sc Exptime}\xspace}
\def \EXPSPACE      {\textsc{Expspace}\xspace}
\def \EXPTIME       {\textsc{Exptime}\xspace}
\def \F             {\mathcal{F}}
\def \false         {\mathbf{false}}
\def \FEA           {\emph{FEA}\xspace}
\def \forrall       {\textsc{Forall}\xspace}
\def \FSM           {\emph{FSM}\xspace}
\def \FSMC          {\textsc{FSMC}\xspace}
\def \GABT          {\emph{GABT}\xspace}
\def \GAPT          {\emph{GAPT}\xspace}
\def \GAPTA         {\emph{GAPTA}\xspace}
\def \Gb            {\Gamma_{\bottom}}
\def \GNBT          {\emph{GNBT}\xspace}
\def \GNPT          {\emph{GNPT}\xspace}
\def \head          {head}
\def \K             {\mathcal{K}}
\def \L             {\mathcal{L}}
\def \LTL           {\emph{LTL}\xspace}
\def \M             {\mathcal{M}}
\def \Nat           {\mathbb{N}}
\def \Naturals      {\mbox{IN}}
\def \NBT           {\emph{NBT}\xspace}
\def \node          {V}
\def \NPT           {\emph{NPT}\xspace}
\def \NTA           {\emph{NTA}\xspace}
\def \NTA           {\emph{NPT}\xspace}
\def \OPD           {\emph{OPD}\xspace}
\def \P             {\mathcal{P}}
\def \PDABT         {\emph{PD--ABT}\xspace}
\def \PDAPT         {\emph{PD--APT}\xspace}
\def \PDFEA         {\emph{PD--FEA}\xspace}
\def \PDGABT        {\emph{PD--GABT}\xspace}
\def \PDGAPT        {\emph{PD--GAPT}\xspace}
\def \PDGNBT        {\emph{PD--GNBT}\xspace}
\def \PDGNPT        {\emph{PD--GNPT}\xspace}
\def \PDMC          {\textsc{PDMC}\xspace}
\def \PDNBT         {\emph{PD--NBT}\xspace}
\def \PDNFA         {\emph{PD--NFA}\xspace}
\def \PDNGTA        {\emph{PD--NGTA}\xspace}
\def \PDNPT         {\emph{PD--NPT}\xspace}
\def \PDNTA         {{\em PD-NTA}\xspace}
\def \PDNTA         {\emph{PD--NBT}\xspace}
\def \PDTABT        {\emph{PD--ABT}\xspace}
\def \PDTAGTA       {\emph{PD--AGTA}\xspace}
\def \PDTAPT        {\emph{PD--APT}\xspace}
\def \PDTNBT        {\emph{PD--NBT}\xspace}
\def \PDTNPT        {\emph{PD--NPT}\xspace}
\def \PDTGABT       {\emph{PD--GABT}\xspace}
\def \PDTGAPT       {\emph{PD--GAPT}\xspace}
\def \PDTGNBT       {\emph{PD--GNPT}\xspace}
\def \PDTGNPT       {\emph{PD--GNPT}\xspace}
\def \prom          {\ensuremath{\mathsf{pro}}\xspace}
\def \PSPACE        {\textsc{Pspace}\xspace}
\def \PTIME         {\textsc{Ptime}\xspace}
\def \rr            {\mathit{root}}
\def \S             {\mathcal{S}}
\def \safety        {\textsc{Safety}\xspace}
\def \SPMC          {\textsc{SPMC}\xspace}
\def \stack         {stack}
\def \strat         {\ensuremath{\mathsf{str}}\xspace}
\def \TABT          {\emph{ABT}\xspace}
\def \TAPT          {\emph{APT}\xspace}
\def \TAGTA         {\emph{AGTA}\xspace}
\def \TGABT         {\emph{GABT}\xspace}
\def \TGAPT         {\emph{GAPT}\xspace}
\def \TGNBT         {\emph{GNPT}\xspace}
\def \TGNPT         {\emph{GNPT}\xspace}
\def \THREEXP       {{\sc 3ExpTime}\xspace}
\def \THREEEXPTIME  {\textsc{3Exptime}\xspace}
\def \TNBT          {\emph{NBT}\xspace}
\def \TNPT          {\emph{NPT}\xspace}
\def \true          {\mathbf{true}}
\def \TWOEXP        {{\sc 2ExpTime}\xspace}
\def \TWOEXPSPACE   {\textsc{2Expspace}\xspace}
\def \TWOEXPTIME    {\textsc{2Exptime}\xspace}
\def \U             {\mathcal{U}}
\def \UP            {{\sc UP}}
\def \UP            {\textsc{UP}\xspace}
\def \val           {\mathcal{V}}

\newcommand \tpl[1] {\langle #1 \rangle}
\newcommand \ignore[1] {}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}

\def\doi{4 (3:1) 2008}
\lmcsheading {\doi}
{1--21}
{}
{}
{Sep.~24, 2007}
{Jul.~29, 2008}
{}   

\begin{document}

\title{Enriched --Calculi Module Checking\rsuper *}

\author[A.~Ferrante] {Alessandro Ferrante\rsuper a}
\address{{\lsuper{a,c}}Universit\`a di Salerno, Via Ponte don Melillo, 84084 -
Fisciano (SA), Italy} \email{\{ferrante,parente\}@dia.unisa.it}
\thanks{}


\author[A.~Murano]{Aniello Murano\rsuper b}
\address{{\lsuper b}Universit\`{a} di Napoli ``Federico II'', Dipartimento di
Scienze Fisiche, 80126 Napoli, Italy} \email{murano@na.infn.it}
\thanks{}

\author[M.~Parente]{Mimmo Parente\rsuper c}


\subjclass{F.1.1, F.1.2, F.3.1, D.2.4}
\titlecomment{{\lsuper *}The paper is based on \cite{FM07} and \cite{FMP07}}
\keywords{Finite state machine, tree automaton, push down automaton,
  interactive and reactive computation, logics of programs, modal
  logic, -calculus, formal verification, model checking}

\begin{abstract}
The model checking problem for open systems has been widely studied in the
literature, for both finite--state (\emph{module checking}) and infinite--state
(\emph{pushdown module checking}) systems, with respect to \CTL and \CTLSTAR.
In this paper, we further investigate this problem with respect to the
-calculus enriched with nominals and graded modalities (\emph{hybrid
graded -calculus}), in both the finite--state and infinite-state settings.
Using an automata-theoretic approach, we show that \emph{hybrid graded
-calculus module checking} is solvable in exponential time, while
\emph{hybrid graded -calculus pushdown module checking} is solvable in
double-exponential time. These results are also tight since they match the
known lower bounds for \CTL. We also investigate the module checking problem
with respect to the hybrid graded -calculus enriched with inverse programs
(\emph{Fully enriched -calculus}): by showing a reduction from the tiling
problem, we show its undecidability. We conclude with a short overview of the
model checking problem for the Fully enriched -calculus and the fragments
obtained by dropping at least one of the additional constructs.
\end{abstract}

\maketitle

\section{Introduction}\label{sec:Introduction}
\emph{Model-checking} is a formal method, applied in system design, to
automatically verify the ongoing behavior of \emph{reactive systems}
(\cite{CE81,QS81}). In this verification technique the behavior of a system,
formally described by a mathematical model, is checked against a behavioral
constraint, usually specified by a formula in an appropriate temporal logic
(for a survey, see \cite{CGP99}).

In the process of modeling a system, we distinguish between \emph{closed} and
\emph{open} systems~\cite{HP85}. While the behavior of a closed system is
completely determined by the state of the system, the behavior of an open
system depends on the ongoing interaction with its environment~\cite{Hoa85}. In
model checking open systems, introduced and called \emph{module-checking} in
\cite{KVW01}, one should check the system with respect to arbitrary
environments and should take into account uncertainty regarding the
environment. In such a framework, the open finite--state system is described by
a labeled state--transition graph, called in fact \emph{module}, whose set of
states is partitioned into \emph{system states} (where the system makes a
transition) and \emph{environment states} (where the environment makes a
transition). Given a module , describing the system to be verified, and a
temporal logic formula , specifying the desired behavior of the
system, module checking asks whether for all possible environments, 
satisfies . Therefore, in module checking it is not sufficient to
check whether the full computation tree obtained by unwinding  (that
corresponds to the interaction of  with a maximal environment) satisfies
, but it is also necessary to verify that all trees obtained from the
full computation tree by pruning some subtrees rooted in nodes corresponding to
choices disabled by the environment (those trees represent the interactions of
 with all the possible environments), satisfy . We collect all
such trees in a set named . It is worth noticing that each tree in
 represents a ``memoryful'' behavior of the environment. Indeed, the
unwinding of a module  induces duplication of nodes, which allow different
pruning of subtrees. To see an example, consider a two-drink dispenser machine
that serves, upon customer request, tea or coffee. The machine is an open
system and an environment for the system is an infinite line of thirsty people.
Since each person in the line can prefer both tea and coffee, or only tea, or
only coffee, each person suggests a different disabling of the external
choices. Accordingly, there are many different possible environments to
consider. In \cite{KV97,KVW01}, it has been shown that while for linear--time
logics model and module checking coincide, module checking for specification
given in \CTL and \CTLSTAR is exponentially harder than model checking in the
size of the formula and preserves the linearity in the size of the model.
Indeed, \CTL and \CTLSTAR module checking is \EXPTIME--complete and
\TWOEXPTIME--complete, respectively.

In \cite{BMP05,AMV07}, the module checking technique has been extended to
infinite-state systems by considering \emph{open pushdown systems} (\OPD, for
short). These are pushdown systems augmented with finite information that
allows us to partition the set of configurations into \emph{system} and
\emph{environment} configurations. To see an example of an open pushdown
system, consider the above two-drink dispenser machine, with the additional
constraint that a coffee can be served only if the number of coffees served up
to that time is smaller than that of teas served. Such a machine can be clearly
modeled as an open pushdown system (the stack is used to guarantee the
inequality between served coffees and teas). In \cite{BMP05}, it has been shown
that pushdown module checking is \TWOEXPTIME--complete for \CTL and
\THREEEXPTIME--complete for \CTLSTAR. Thus, for pushdown systems, and for
specification given in \CTL and \CTLSTAR, module checking is exponentially
harder than model checking with respect to the size of the formula, while it
preserves the exponential complexity with respect to the size of the
model~\cite{Wal96,Wal00}.

Among the various formalisms used for specifying properties, a valid candidate
is the \emph{-calculus}, a very powerful propositional modal logic
augmented with least and greatest fixpoint operators \cite{Koz83} (for a recent
survey, see also \cite{BS06}). The \emph{Fully enriched
--calculus}~\cite{BP04} is the extension of the --calculus with
\emph{inverse programs}, \emph{graded modalities}, and \emph{nominals}.
Intuitively, inverse programs allow us to travel backwards along accessibility
relations \cite{Var98}, nominals are propositional variables interpreted as
singleton sets \cite{SV01}, and graded modalities enable statements about the
number of successors of a state \cite{KSV02}. By dropping at least one of the
additional constructs, we get a \emph{fragment} of the Fully enriched
-calculus. In particular, by inhibiting backward modalities we get the
fragment we call \emph{hybrid graded -calculus}. In~\cite{BP04}, it has
been shown that satisfiability is undecidable in the \emph{Fully enriched
--calculus}. On the other hand, it has been shown in \cite{SV01,BLMV06}
that satisfiability for each of its fragments is decidable and
\EXPTIME-complete (for more details, see also \cite{BLMV08}). The upper bound
result is based on an automata--theoretic approach via \emph{two-way graded
alternating parity tree automata (\TGAPT)}, along with the fact that each
fragment of the Fully enriched -calculus enjoys the \emph{quasi-forest
model property}. Intuitively, \TGAPT generalize alternating automata on
infinite trees as inverse programs and graded modalities enrich the standard
--calculus: \TGAPT can move up to a node's predecessor and move down to
\emph{at least } or \emph{all but } successors. Moreover, a quasi-forest
is a forest where nodes can have roots as successors and having quasi-forest
model property means that any satisfiable formula has a quasi-forest as model.
Using \TGAPT and the quasi-forest model property, it has been shown in
\cite{SV01,BLMV06} that given a formula  of a fragment of the Fully
enriched -calculus, it is possible to construct a \TGAPT accepting all
trees encodings\footnote{Encoding is done by using a new root node that
connects all roots of the quasi-forest and new atomic propositions which are
used to encode programs and successor nodes corresponding to nominals.}
quasi-forests modeling . Then, the exponential-upper bound follows
from the fact that the emptiness problem for \TGAPT is solvable in \PTIME
\cite{KPV02}.

In this paper, we further investigate the module checking problem and its
infinite-state extension, with respect to the \emph{hybrid graded
-calculus}. To see an example of module checking a finite-state open
system w.r.t. an hybrid graded -calculus specification, consider again the
above two-drink dispenser machine with the following extra feature: whenever a
customer can choose a drink, he can also call the customer service or the
security service. Suppose also that by taking one of these two new choices, the
drink-dispenser machine stops dispensing drinks, up to the moment the customer
finishes operating with the service. Assume that, for the labeled
state--transition graph modeling the system, we label by  the
choosing state and by the nominals  and  the states in which the
interaction with the customer and the security services start, respectively.
Moreover, suppose we want to check the following property: ``whenever the
customer comes at a choice, he can choose for both the customer and the
security services''. This property can be formalized by the hybrid graded
--calculus formula , which reads ``it is always true that whenever the
drink--dispenser is in the \emph{choose} state, there are at least 
\emph{call}--successors in which  holds''. Clearly, the
considered open system does not satisfy this formula. Indeed, it is not
satisfied by the particular behavior that chooses always the same service.

By exploiting an automata--theoretic approach via tree automata, we show that
hybrid graded --calculus module checking is decidable and solvable in
\EXPTIME in the size of the formula and \PTIME in the size of the system. Thus,
as in general, we pay an exponential--time blowup with respect to the model
checking problem (and only w.r.t. the size of the formula) for the module
checking investigation. In particular, we reduce the addressed module checking
problem to the emptiness problem for graded alternating parity tree automata
(\GAPT). In more details, given a model  and an hybrid graded
-calculus formula , we first construct in polynomial time a
B\"uchi tree automaton (\NBT)  accepting . The construction
of  we propose here extends that used in \cite{KVW01} by also taking
into account that  must be unwound in a quasi-forest, rather than a tree,
with both nodes and edges labeled. Thus, the set  is a set of
quasi-forests, and the automaton  we construct will accept all trees
encodings of all quasi-forests of . From the formula side,
accordingly to \cite{BLMV06}, we can construct in a polynomial time a \GAPT
 accepting all models that do not satisfy ,
with the intent to check that none of these models are in . Thus, we
check that  models  for every possible choice of the environment
by checking whether the  is
empty. The results follow from the fact that an \NBT is a particular case of
\GAPT, which are closed under intersection and have the emptiness problem
solvable in \EXP \cite{BLMV06}. We also show a lower bound matching the
obtained upper bound by using a reduction from the module checking for \CTL,
known to be \EXP-hard.

By exploiting again an automata-theoretic approach, we show that hybrid graded
-calculus pushdown module checking is decidable and solvable in
\TWOEXPTIME in the size of the formula and \EXPTIME in the size of the system.
Thus, as in general, with respect to the finite--state model checking case we
pay an exponential--time blowup in the size of both the system and the formula
for the use of pushdown systems, and an another exponential--time blowup in the
size of the formula for the module checking investigation. Our approach allow
us do not take the trivial \TWOEXPTIME result on both the size of the system
and the formula, which can be easily obtained by combining the algorithms
existing in the literature along with that one we introduce in this paper for
the finite--state case. We solve the hybrid graded -calculus pushdown
module checking by using a reduction to the emptiness problem for
nondeterministic pushdown parity tree automata (\PDNPT). The algorithm we
propose extends that given for the finite-state case. In particular, given an
\OPD , a module  induced by the configurations of , and an hybrid
graded -calculus formula , we first construct in polynomial time
a pushdown B\"uchi tree automaton (\PDNBT) , accepting .
From the formula side, accordingly to \cite{BLMV06}, we can construct in a
polynomial time a \GAPT  accepting all models that
do not satisfy . Thus, we can check that  models  for
every possible choice of the environment by checking whether  is empty. By showing a non-trivial exponential
reduction of \TGAPT into \NPT, we show a \TWOEXPTIME upper bound for the
addressed problem. Since the pushdown module checking problem for \CTL is
\TWOEXPTIME-hard, we get that the addressed problem is then
\TWOEXPTIME-complete.


As regarding the Fully enriched -calculus, we also investigate the module
checking problem in a ``rewind'' framework in the following sense. As far as
backward modalities concern, everytime the system goes back to an environment's
node, he is always able to redefine a new pruning choice. Given a module 
and a Fully enriched -calculus formula , we solve the rewind
module checking problem by checking that all trees in , always taking
the same choice in duplicate environment nodes, satisfy . By showing a
reduction from the tiling problem \cite{Ber66}, we show that the addressed
problem is undecidable.

We conclude the paper with short considerations on the model
checking on all of the fragments of the Fully enriched
-calculus. In particular we show the problem to be
\EXPTIME-complete for a pushdown system which is allowed to push
one symbol per time onto the stack, with respect to any fragment
not including the graded modality: for the fragments with the
graded modality, we show a \TWOEXPTIME upper bound.

\ignore{ Ricordarsi di dire qualcosa sul model checking per il
-calculus classico citando i lavori di Igor Walukiewicz e
altri (vedi anche citazioni di Igor Walukiewicz )

Ricordarsi di citare la survey sul -calculus del 2007 di
Stirling e Bradfield. }

The rest of the paper is organized as follows. In
Section~\ref{sec:Preliminaries}, we give all the necessary preliminaries,
Section~\ref{sec:HybridGradedModuleChecking} contains the definition of module
checking w.r.t. hybrid graded -calculus, and
Section~\ref{sec:TreeAutomata} contains definitions and known results about
\TGAPT and \PDNPT. In
Sections~\ref{sec:DecidingHybridGradedModuleChecking}~and~\ref{sec:DecidingHybridGradedPushdownModuleChecking},
we give our main results on module checking for the hybrid graded
-calculus. In Section~\ref{sec:FullyEnrichedModuleChecking}, we show the
undecidability result for the Fully enriched module checking and conclude in
Section~\ref{sec:ModelChecking} with some complexity considerations on model
checking with all the fragments of the Fully enriched -calculus.

\section{Preliminaries}\label{sec:Preliminaries}
In this section, we recall definitions of labeled forests and hybrid graded
--calculus. We refer to \cite{BLMV06} for more technical definitions and
motivating examples.

\subsection{Labeled Forests.}\label{sub:LabeledForests} For a
finite set , we denote the \emph{size} of  by , the set
of words over  by , the empty word by , and
with  we denote . Given a word
 in  and a symbol  of , we use  to denote
the word . Let  be the set of positive integers.
For , let  denote the set . A \emph{forest} is a set  such that if
, where  and , then
also . The elements of  are called \emph{nodes}, and
words consisting of a single natural number are \emph{roots} of
. For each root , the set  is a \emph{tree} of  (the tree
\emph{rooted at }). For , the nodes 
where  are the \emph{successors} of , denoted
, and  is their \emph{predecessor}. The number of
successors of a node  is called the \emph{degree} of 
(). The degree  of a forest  is the maximum of the
degrees of all nodes in  and the number of roots. A forest with
degree  is an \emph{-ary} forest. A full -ary forest is a
forest having  roots and all nodes with degree .

Let  be a forest,  a node in , and . As a convention, we take , , and  as undefined. We call  a \emph{leaf} if it has no
successors. A \emph{path}  in  is a word  of  such that  is a root of  and for every , either  is a leaf (i.e.,  ends in ) or
 is a predecessor of . Given two alphabets
 and , a ()--labeled forest
is a triple , where  is a forest,  maps each node of  to a letter in
, and  is a
partial function that maps each pair , with ,
to a letter in . As a particular case, we consider a
forest without labels on edges as a --labeled forest
, and a \emph{tree} as a forest containing exactly
one tree. A \emph{quasi--forest} is a forest where each node may
also have roots as successors. For a node  of a quasi--forest,
we set  as . All the other
definitions regarding forests easily extend to quasi--forests.
Notice that in a quasi--forest, since each node can have a root as
successor, a root can also have several predecessors, while every
other node has just one. Clearly, a quasi--forest can always be
transformed into a forest by removing root successors.

\subsection{Hybrid Graded --Calculus.}\label{sub:FullyEnrichedMuCalculus}
Let , , , and  be
finite and pairwise disjoint sets of \emph{atomic propositions},
\emph{propositional variables}, \emph{atomic programs} (which allow to travel
the system along accessibility relations), and \emph{nominals} (which are
particular atomic propositions interpreted as singleton sets). The set of
\emph{hybrid graded --calculus} formulas is the smallest set such that
\begin{enumerate}[]
\item
\textbf{true} and \textbf{false} are formulas;

\item
 and , for , are formulas;

\item
 and , for , are formulas;

\item
 is a formula;

\item
if  and  are formulas, ,  is a non
negative integer, and , then the following are also formulas:
    
\end{enumerate}

Observe that we use positive normal form, i.e., negation is applied only to
atomic propositions.

We call  and  \emph{fixpoint operators}. A propositional variable 
occurs \emph{free} in a formula if it is not in the scope of a fixpoint
operator. A \emph{sentence} is a formula that contains no free variables. We
refer often to the \emph{graded modalities}  and
 as respectively \emph{atleast formulas} and
\emph{allbut formulas} and assume that the integers in these operators are
given in binary coding: the contribution of  to the length of the formulas
 and  is 
rather than~.

The semantics of the hybrid graded --calculus is defined with respect to a
\emph{Kripke structure}, i.e., a tuple  where  is a
non--empty set of \emph{states},  is the set of initial
states,  is a function that
assigns to each atomic program a transition relation over , and  is a labeling function that assigns to each
atomic proposition and nominal a set of states such that the sets assigned to
nominals are singletons and subsets of . If , we say
that  is an \emph{--successor} of . Informally, an
\emph{atleast} formula  holds at a state  of  if
 holds in at least  --successors of . Dually, the
\emph{allbut} formula  holds in a state  of  if
 holds in all but at most  --successors of . Note that
 is equivalent to , and
the modalities  and  of the
standard --calculus can be expressed as  and
, respectively.

To formalize semantics, we introduce valuations. Given a Kripke
structure , , ,  and a set
 of variables in , a
\emph{valuation}  is
an assignment of subsets of  to the variables .  For a valuation , a variable , and a set , we denote by  the valuation
obtained from  by assigning  to . A formula 
with free variables among  is interpreted over
 as a mapping  from valuations to , i.e.,
 denotes the set of points that satisfy
 under valuation . The mapping  is
defined inductively as follows:
\begin{enumerate}[]
\item
 and ;

\item
for , we have 
and ;

\item
for , we have ;

\item
 and ;

\item
;

\item
;

\item
;

\item
.
\end{enumerate}

For a state  of a Kripke structure , we say that  \emph{satisfies}
 at  if . In what follows, a formula 
\emph{counts} up to  if the maximal integer in \emph{atleast} and
\emph{allbut} formulas used in  is .

\section{Hybrid graded -calculus module Checking}\label{sec:HybridGradedModuleChecking}
In this paper we consider open systems, i.e., systems that
interact with their environment and whose behavior depends on this
interaction. The (global) behavior of such a system is described
by a \emph{module} , which is a Kripke
structure where the set of states  is
partitioned in \emph{system states}  and \emph{environment
states} .

Given a module , we assume that its states are ordered and the
number of successors of each state  is finite. For each , we denote by  the ordered tuple (possibly empty) of
's -successors, for all . When  is
in a system state , then all states in  are
possible next states. On the other hand, when  is in an
environment state , the possible next states (that are in
) depend on the current environment. Since the behavior
of the environment is not predictable, we have to consider all the
possible sub--tuples of . The only constraint, since we
consider environments that cannot block the system, is that not
all the transitions from  are disabled.

The set of all (maximal) computations of , starting from
, is described by a --labeled quasi--forest
, called \emph{computation
quasi--forest}, which is obtained by unwinding  in the usual
way. The problem of deciding, for a given branching--time formula
 over , whether  satisfies  at a root node,
denoted , is the usual \emph{model--checking
problem} \cite{CE81,QS81}. On the other hand, for an open system
, the quasi--forest 
corresponds to a very specific environment, i.e., a maximal
environment that never restricts the set of its next states.
Therefore, when we examine a branching--time formula 
w.r.t. , the formula  should hold not only in
, but in all quasi-forests
obtained by pruning from 
subtrees rooted at children of environment nodes, as well as
inhibiting some of their jumps to roots (that is, successor nodes
labeled with nominals), if there are any. The set of these
quasi--forests, which collects all possible behaviors of the
environment, is denoted by  and is formally defined as
follows. A quasi--forest  iff

\begin{enumerate}[]
\item
for each , we have ;

\item
for each , with , , and , there exists  sub-tuple of 
such that  and the following hold:

\begin{enumerate}[]
\item
 if ;

\item
 and, for , we have  and  if ;

\item
for , let  such that , then  if .
\end{enumerate}
\end{enumerate}
In the following, we consider quasi--forests in  as labeled with
, i.e., taking the label of a node  as
. For a module  and a formula  of the hybrid graded
--calculus, we say that  \emph{reactively} satisfies ,
denoted  (where ``r'' stands for \emph{reactively}), if all
quasi-forests in  satisfy . The problem of deciding whether
 is called \emph{hybrid graded --calculus module
checking}.

\subsection{Open Pushdown Systems
(\OPD)}\label{sub:OpenPushdownSystems} An \OPD over
,  and 
is a tuple , where  is a finite set of (control)
\emph{states},  is a finite \emph{stack alphabet},
 is the \emph{stack bottom symbol}. We
set ,  to be the set of \emph{(pushdown) configurations},
and for each configuration , we set  to be a \emph{top configuration}. The
function  is a finite set of transition rules such that
 is always present at the bottom of the stack and nowhere
else (thus whenever  is read, it is pushed back). Note
that we make this assumption also about the various pushdown
automata we use later. The set  is a finite
set of \emph{initial configurations},  and  are labeling
functions associating respectively to each atomic proposition 
a set of top configurations in which  holds and to each nominal
exactly one initial configuration. Finally,  specifies the set of \emph{environment
configurations}. The size  of  is .

The \OPD moves in accordance with the transition relation
. Thus,  implies that if the \OPD is in state  and the
top of the stack is , it can move along with an
\emph{--transition} to state , and substitute 
for . Also note that the possible operations of the system, the
labeling functions, and the designation of configurations as
environment configurations, are all dependent only on the current
control state and the top of the stack.

An \OPD  induces a module , where:
\begin{enumerate}[]
\item
, i.e. the set of pushdown configurations,
and ;

\item
.

\item

\emph{iff} there is ;

\item
 for ;
 for .
\end{enumerate}
The \emph{hybrid graded (-calculus) pushdown module checking}
problem is to decide, for a given \OPD  and an enriched
--calculus formula , whether .

\section{Tree Automata}\label{sec:TreeAutomata}
\subsection{Two-way Graded Alternating Parity Tree Automata (\TGAPT)}\label{sub:Tgapt}
These automata have been introduced and deeply investigated in \cite{BLMV06}.
In this section we just recall the main definitions and results and refer to
the literature for more details. Intuitively, \TGAPT are an extension of
nondeterministic tree automata in such a way that a \TGAPT can send several
copies of itself to the same successor (\emph{alternating}), send copies of
itself to the predecessor (\emph{two-way}), specify a number  of successors
to which copies of itself are sent (\emph{graded}), and accept trees along with
a \emph{parity acceptance condition}. To give a more formal definition, let us
recall some technicalities from \cite{BLMV06}.

For a given set , let  be the set of positive Boolean formulas
over  (i.e., Boolean formulas built from elements in  using  and
), where we also allow the formulas \textbf{true} and \textbf{false} and
 has precedence over . For a set  and a formula
, we say that  satisfies  iff assigning
\textbf{true} to elements in  and assigning \textbf{false} to elements in  makes  \textbf{true}.  For , let , , and . Intuitively,  collects
all possible directions in which the automaton can proceed.

Formally, a \TGAPT on -labeled trees is a tuple ,
, , , , , where  is the input alphabet,
 is a counting bound,  is a finite set of states,  is a transition function, 
is an initial state, and  is a parity acceptance condition (see below).
Intuitively, an atom  (resp.\ ) means that  sends
copies in state  to  (resp.\ all but ) different successors of the
current node,  means that  sends a copy (in state ) to
the current node, and  means that  sends a copy to the predecessor
of the current node. A \emph{run} of  on an input -labeled tree
 is a tree  in which each node is labeled by an element
of . Intuitively, a node in  labeled by  describes a
copy of the automaton in state  that reads the node  of . Runs start
in the initial state and satisfy the transition relation. Thus, a run
 with root  has to satisfy the following: (\emph{i})  for the root  of  and (\emph{ii}) for all  with
 and , there is a (possibly empty) set
, such that  satisfies , and for all , the following hold:

\begin{enumerate}[]
    \item
    If , then  is defined, and there is  such that  and ;

    \item
    If , there are at least  distinct indexes  such that for all , there is  such
    that , , and .

    \item
    If , there are at least  distinct indexes  such that for all , there is  such that , , and .
\end{enumerate}

Note that if , then  does not need to
have successors. This is the reason why  may have leaves.
Also, since there exists no set  as required for , we cannot have a run that takes a transition with
.

A run  is \emph{accepting} if all its infinite paths
satisfy the acceptance condition. In the parity acceptance
condition,  is a set  such that  and  is called the
\emph{index} of the automaton. An infinite path  on 
\emph{satisfies}  if there is an even  such that 
contains infinitely many states from  and finitely many
states from . An automaton \emph{accepts} a tree iff
there exists an accepting run of the automaton on the tree. We
denote by  the set of all -labeled trees that 
accepts. The \emph{emptiness} problem for an automaton  is to
decide whether .

A \TGAPT is a \GAPT (i.e., ``\emph{one--way}'') if 
and a \TAPT (i.e., ``\emph{non-graded}'')  if . As a particular case of \TAPT, we also consider
nondeterministic parity tree automata (\NPT) \cite{KVW00}.
Formally, an \NPT on -labeled trees is a tuple , , , , , , where
, and  are as in \TAPT,  is a finite set of
\emph{branching degree} and  is a transition function satisfying
, for each , , and . Finally, we also consider
\emph{B\"uchi acceptance condition} , which simply
is a special parity condition . Thus, we use
in the following the acronym \NBT to denote nondeterministic
B\"uchi tree automata on -labeled trees.

The following results on \TGAPT will be useful in the rest of the
paper.

\begin{theorem}\cite{BLMV06}\label{the:TgaptEmptiness}
The emptiness problem for a \GAPT  can be solved in time linear in the size of  and
, and exponential in the index of the automaton and number of
states.
\end{theorem}

\begin{lemma}\cite{BLMV06}\label{lem:TgaptIntersection}
Given two \GAPT  and , there exists a \GAPT  such
that  and whose size is linear in
the size of  and .
\end{lemma}

We now recall a result on \GAPT and hybrid graded -calculus
formulas.

\begin{lemma}[\cite{BLMV06}]\label{lem:FromFormulasToAutomata}
Given an hybrid graded -calculus sentence  with 
\emph{atleast} subsentences and counting up to , it is possible to construct
a \GAPT with  states, index , and counting
bound  that accepts exactly each tree that encodes a quasi-forest model of
.
\end{lemma}

\subsection{Nondeterministic Pushdown Parity Tree Automata
(\PDNPT)}\label{sub:Pdnpt} A \PDNPT (without -transitions), on
-labeled full -ary trees, is a tuple , , where  is a finite input
alphabet, , , , and  are as in \OPD, 
is the initial configuration,  is a transition function, and  is a parity acceptance
condition over . Intuitively, when  is in state , reading an input
node  labeled by , and the stack contains a word , then  chooses a tuple
 and splits in
 copies such that for each , a copy in configuration  is sent to the node  in the input tree. A
run of  on a -labeled full -ary tree  is a -labeled tree  such that
\begin{enumerate}[]

  \item
  , and

  \item
  for each  with , there is
  
  such that, for all , we have .

\end{enumerate}
The notion of accepting path is defined with respect to the
control states that appear infinitely often in the path (thus
without taking into account any stack content). Then, the notions
given for \TGAPT regarding accepting runs, accepted trees, and
accepted languages, along with the parity acceptance condition,
easily extend to \PDNPT. In the following, we denote with \PDNBT a
\PDNPT with a B\"uchi condition. We now recall two useful results
on the introduced automata.
\begin{prop}[\cite{KPV02}]\label{prop:EmptinessForPD-NBT}
The emptiness problem for a \PDNPT on -labeled full
-ary trees, having index ,  states, and transition
function , can be solved in time exponential in .
\end{prop}
\begin{prop}[\cite{BMP05}]\label{pro:ClosureUnderIntersection}
Given a  , , , ,
, ,  on -labeled full -ary
trees, and an  ,
there is a   on -labeled full -ary trees,
such that . Moreover,  has
 states, the same index as , and the size of
the transition relation is bounded by .
\end{prop}


\section{Deciding Hybrid Graded -calculus Module Checking}\label{sec:DecidingHybridGradedModuleChecking}
In this section, we solve the module checking problem for the
hybrid graded --calculus. In particular, we show that this
problem is decidable and \EXPTIME--complete. For the upper bound,
we give an algorithm based on an automata--theoretic approach, by
extending an idea of \cite{KVW01}. For the lower bound, we give a
reduction from the module checking problem for \CTL, known to be
\EXPTIME--hard. We start with the upper bound.

Let  be a module and  an hybrid graded
--calculus formula. We decide the module checking problem for
 against  by building a \GAPT  as the intersection of two automata.
Essentially, the first automaton, denoted by , is a
B\"{u}chi automaton that accepts trees encoding of labeled
quasi--forests of , and the second automaton is a \GAPT
 that accepts all trees encoding of
labeled quasi--forests that do not satisfy  (i.e,  is satisfied at all initial nodes). Thus,  iff  is empty.

The construction of  proposed here extends that given in
\cite{KVW01} for solving the module checking problem for
finite--state open systems with respect to \CTL and \CTLSTAR. The
extension concerns the handling of forest models instead of trees
and formulas of the hybrid graded --calculus. Before
starting, there are a few technical difficulties to be overcome.
First, we notice that  contains quasi--forests, with
labels on both edges and nodes, while B\"{u}chi automata can only
accept trees with labels on nodes. This problem is overcome by
using the following three step transformation
\begin{enumerate}[(1)]
\item
move the label of each edge to the target node of the edge (formally using a
new propositional symbol , for each atomic program ),

\item
substitute edges to roots with new propositional symbols 
(which represents an --labeled edge from the current node to the unique
root node labeled by the nominal ), and

\item
add a new root, labeled with a new symbol , and connect it with the old roots of the quasi--forest.
\end{enumerate}

Let , we denote
with  the --labeled tree
encoding of a quasi--forest , obtained using
the above transformation.

Another technical difficulty to handle is relate to the fact that
quasi--forests of  (and thus their encoding) may not share the same
structure, since they are obtained by pruning some subtrees from the
computation quasi--forest  of . Let
 the \emph{computation tree} of  obtained from
 using the above encoding. By extending
an idea of \cite{KVW01}, we solve the technical problem by considering each
tree , encoding of a quasi--forest of , as a
--labeled tree 
(where  is a fresh proposition name not belonging to ) such that for each node , if  then , otherwise . Thus, we label each node
pruned in the  with  and recursively, we
label with  its subtrees. In this way, all trees encoding
quasi--forests of  have the same structure of
, and they differ only in their labeling.

Accordingly, we can think of an environment as a strategy for placing
 in , with the aim of preventing the system
to satisfy a desired property while not considering the nodes labeled with
. Moreover, the environment can also disable jumps to roots. This is
performed by removing from nodes corresponding with environment states some of
 labels. Notice that since we consider environments that
do not block the system, each node associated with an environment state has at
least one successor not labeled by , unless it has
 in its label.

Let us denote by  the set of all --labeled  trees obtained from
 in the above described manner. The required
\NBT  must accept all and only the --labeled trees in . The automaton
 is defined for a module   as follows:
\begin{enumerate}[]
    \item
    

    \item
     (that is,  contains, for
    each state in , the number of its successors, but its jumps to roots).

    \item
    , with . Thus
    every state  of  induces three states , , and
     in . Intuitively, when  is in state ,
    it can read only , in state , it can read only letters in
    , and in state , it can read both letters in
     and . In this last case, it is left to the environment
    to decide whether the transition to a state of the form  is
    enabled. The three types of states are used to ensure that the environment
    enables all transitions from enabled system states, enables at least one
    transition from each enabled environment state, and disables transitions from
    disabled states.

    \item
    The transition function  is defined as follows. Let  be a
    node of the input tree.
    \begin{enumerate}[]
    \item
    if  then (let )
        
    that is  contains exactly one --tuple of all
    the roots of the forest. In this case, all transitions cannot be
    disabled;

    \item
    if , let  and  be the set of
    \emph{non--roots successors} of , then we have

\begin{enumerate}[]
\item
for  and  we have
    
that is  contains exactly one --tuple of
all non--roots successors of . In this case, all transitions to
successors of  are recursively disabled;

\item
for  and  we have
    
that is,  contains exactly one --tuple of
all non--roots successors of . In this case all transitions to
successors of  are enabled;

\item
for  and  with  (i.e.,  has no jumps to roots or all of them
have been disabled), we have

that is,  contains  different --tuples
of all non--roots successors of . When  proceeds
according to the --th tuple, the environment can disable all
transitions to successors of , except that to ;

\item
for  and  with  (i.e.,  has at least one jump to roots
enabled), we have
    
that is  contains one --tuple of
non--roots successors of , that can be successively disabled.
\end{enumerate}
\end{enumerate}
\end{enumerate}

Notice that  is not defined when  is different from the
number of non--roots successors of , and when the input does
not meet the restriction imposed by the , , and
 annotations or by the labeling of .

The automaton  has  states,  symbols, and the size of the transition relation
 is bounded by .

We recall that a node labeled by either  or 
stands for a node that actually does not exist. Thus, we have to
take this into account when we interpret formulas of the hybrid
graded --calculus over trees . In order to achieve this, as in \cite{KVW01}
we define a function  that transforms the input formula
 in a formula of the hybrid graded --calculus
 (where  is
an arbitrary atomic program), that restricts path quantification
to only paths that never visit a state labeled with .
The function  we consider extends that given in \cite{KVW01}
and is inductively defined as follows:
\begin{enumerate}[]
\item
 and ;

\item
 and  for all ;

\item
 for all ;

\item
 and

for all hybrid graded --calculus formulas  and
;

\item
 and  for all  and hybrid
graded --calculus formulas ;

\item

for  and for all atomic programs  and hybrid
graded --calculus formulas ;

\item
 for  and for all atomic programs  and hybrid graded
--calculus formulas .
\end{enumerate}

By definition of , it follows that for each formula 
and , 
satisfies  \emph{iff} the
--labeled forest, obtained from 
removing the node labeled with  and all nodes labeled by
, satisfies . Therefore, we solve the module
checking problem of  against an hybrid graded --calculus
formula  by checking (for its negation) that in
 does not exist any tree
 satisfying  (note that ). We reduce the latter to check the
emptiness of a \GAPT  that
is defined as the intersection of the \NBT  with a \GAPT
 accepting exactly the  trees encodings of quasi--forests not
satisfying . By Lemma
\ref{lem:FromFormulasToAutomata}, if  is an hybrid graded
--calculus formula, then  has
 states, index , and counting
bound . Therefore, by Lemma \ref{lem:TgaptIntersection},
 has
 states, index , and
counting bound . By recalling that the emptiness problem for a
\GAPT can be decided in exponential-time (Theorem
\ref{the:TgaptEmptiness}), we obtain that the module checking
problem for hybrid graded --calculus formulas is solvable in
exponential-time. To show a tight lower bound we recall that \CTL
module checking is \EXPTIME--hard \cite{KVW01} and every \CTL
formula can be linearly transformed in a modal --calculus
formula \cite{Jur98}. This leads to the module checking problem
w.r.t. modal --calculus formulas to be \EXPTIME--hard and
thus to the following result.

\begin{theorem}\label{the:HybridGradedFiniteStatesModuleChecking}
The module checking problem with respect to hybrid graded
--calculus formulas is \EXPTIME--complete.
\end{theorem}

\section{Deciding Hybrid Graded -calculus PD-module Checking}\label{sec:DecidingHybridGradedPushdownModuleChecking}
In this section, we show that hybrid graded pushdown module checking is
decidable and solvable in \TWOEXPTIME. Since \CTL pushdown module checking is
\TWOEXPTIME--hard, we get that the addressed problem is \TWOEXPTIME--complete.
For the upper bound, the algorithm works as follows. Given an \OPD  and the
module  induced by , by combining and extending the constructions
given in \cite{BMP05} and Section \ref{sec:DecidingHybridGradedModuleChecking},
we first build in polynomial--time a \PDNBT  accepting each tree that
encodes a quasi--forest belonging to . Then, given an hybrid
graded --calculus formula , according to \cite{BLMV06}, we build
in polynomial--time a \GAPT  (Lemma
\ref{lem:FromFormulasToAutomata}) accepting all models that do not satisfy
, with the intent of checking that none of these models are in
. Then, accordingly to the basic idea of \cite{KVW01}, we check
that  by checking whether  is empty. Finally, we get the result by using an
exponential--time reduction of the latter to the emptiness problem for \PDNPT,
which from Proposition~\ref{prop:EmptinessForPD-NBT} can be solved in \EXPTIME.
As a key step of the above reduction, we use the exponential--time translation
from \GAPT into \NPT\ showed in Lemma~\ref{lem:FromTgaptToNpt}.

Let us start dealing with . Before building the
automaton, there are some technical difficulties to overcome.
First, notice that  is a \PDNBT and it can only deal with
trees having labels on nodes. Also, quasi--forests of
 may not share the same structure, since they are
obtained by pruning subtrees from the computation quasi--forest
 of .
As in Section \ref{sec:DecidingHybridGradedModuleChecking}, we
solve this problem by considering  --labeled trees \emph{encoding} of
quasi--forests , where
.

Another technical difficulty to handle with is related to the fact
that quasi--forests of  (and thus their encodings)
may not be full --ary, since the nodes of the \OPD from which
 is induced may have different degrees. Technically, we
need this property since the emptiness problem for \PDNPT to which
we reduce our problem has been solved in the literature only for
\PDNPT working on full trees. Similarly as we did for pruned
nodes, we transform each tree encoding of a quasi--forest of
 into a full --ary tree by adding missing nodes
labeled with .
Therefore the proposition  is used to denote both
``disabled" states and ``completion" states. In this way, all
trees encodings of quasi--forests of  are all full
--ary trees, and they differ only in their labeling. Let us
denote with  the set of all --labeled full --ary trees obtained
from  using
all the transformations described above.

In \cite{BMP05} it has been shown how to build a \PDNBT accepting
full --ary trees embedded in an \OPD corresponding to all
behaviors of the environment. In particular, the \PDNBT
constructed there already takes into account the above
transformation regarding --labeled nodes. By extending
the construction proposed there in the same way the construction
showed in Section \ref{sec:DecidingHybridGradedModuleChecking}
extends the classical construction of  proposed in
\cite{KVW01}, it is not hard to show that the following result
holds.

\begin{lemma}\label{lem:FromOpdToAutomata}
Given an \OPD  with branching degree , we can build a \PDNBT
, which accepts exactly , such
that , , and  is polynomially
bounded by .
\end{lemma}

Let us now go back to the hybrid graded --calculus formula
. Using the function  introduced in
Section~\ref{sec:DecidingHybridGradedModuleChecking} and
Lemma~\ref{lem:FromFormulasToAutomata}, we get that given an
hybrid graded --calculus formula , we can build in
polynomial--time a \GAPT  accepting
all models of  (as done
in Section \ref{sec:DecidingHybridGradedModuleChecking}).

By using the classical \EXPTIME transformation from \GAPT to \GNPT
\cite{KSV02} and a simple \EXPTIME transformation from \GNPT to
\NPT, we directly get a \THREEEXPTIME algorithm for the hybrid
graded --calculus pushdown module checking. To obtain an
exponential--time improvement, here we show a not trivial \EXPTIME
transformation from \TGAPT to \NPT.
The translation we propose uses the notions of \emph{strategies},
\emph{promises} and \emph{annotations}, which we now recall.

Let  be a \TGAPT with
 and  be a
-labeled tree. Recall that  and . For each control state , let  be the minimal  such that . A
\emph{strategy tree} for  on  is a -labeled tree  such that, defined
 as the set of
\emph{sources} of , it holds that   and  for each node  and state , the set 
satisfies .

A \emph{promise tree} for  on  is a -labeled tree . We say that 
\emph{fulfills}  for  if the states promised to be
visited by  satisfy the obligations induced by  as
it runs on . Formally,  fulfills  for  if for
every node , the following hold: ``for every  (resp. ),
at least  (resp ) successors  of 
have ''.

An \emph{annotation tree} for  on  and  is
a -labeled tree  such
that for each  and  the following hold:

\begin{enumerate}[]

\item
if , then ;

\item
if , then for all  and  such that , we
have ;

\item
if  and , then for all  and all  satisfing  as well as  and , we have that ;

\item
if , , and , then for all  and
 such that  and
, it holds that .
\end{enumerate}

A downward path induced by , , and  on
 is a sequence ,
,  such that ,  is
the initial state of  and, for each , it holds that
, , and  is such that either \emph{(i)}  and , or \emph{(ii)}  and there exists  such that  and
. In the first case we set
 and in the second case we set . Moreover,
for a downward path , we set  as the minimum
index that appears infinitely often in . Finally, we say that
 is \emph{accepting} if  is even.

The following lemma relates languages accepted by \TGAPT with
strategies, promises, and annotations.
\begin{lemma}[\cite{BLMV06}]\label{lem:TgaptAndStrategies}
Let  be a \TGAPT. A -labeled tree  is
accepted by  iff there exist a strategy tree ,
a promise tree  for  on  such that
 fulfills  for , and an annotation tree
 for  on ,  and
 such that every downward path induced by ,
, and  on  is accepting.
\end{lemma}

Given an alphabet  for the input tree of a \TGAPT with transition
function , let  be the subset containing only the
elements of  appearing in . Then we denote by  the
extended alphabet for the combined trees, i.e., .

\begin{lemma}\label{lem:FromTgaptToNpt}
Let  be a \TGAPT running on --labeled trees with 
states, index  and counting bound  that accepts -ary
trees. It is possible to construct in exponential-time an \NPT
 running on --labeled -ary trees that accepts a
tree iff  accepts its projection on .
\end{lemma}

\begin{proof}
Let  with . By Lemma \ref{lem:TgaptAndStrategies}, we
construct  as the intersection of two \NBT , , and
an \NPT . In particular, all these automata have size
exponential in the size of . Moreover, since each \NBT uses as
accepting all its states, it is easy to intersect in
polynomial-time all of them by using a classical automata product.
These automata are defined as follows. Given a -labeled
tree ,
\begin{enumerate}[(1)]
\item
 accepts  iff  is a strategy for  on
 and  fulfills  for ,

\item
 accepts  iff  is an annotation for  on
,  and , and

\item
 accepts  iff every downward path induced by ,
, and  on  is accepting.
\end{enumerate}

The automaton 
works as follows: on reading a node  labeled , then it locally checks whether  satisfies
the definition of strategy for  on . In particular,
when  is in its initial state, we check that  contains
a transition starting from the initial state of . Moreover,
the automaton  sends to each child  the pairs of
states that have to be contained in , in order
to verify that  fulfills . To obtain this, we set
,  and
. To define , we first give the
following definition. For each node  labeled , we set {\small
    }
to be the set of all tuples with size , each
\emph{fulfilling} all graded modalities in . Notice
that . Then we have {\small
    }
\noindent Hence, in  we have , , and index .

 works in a
similar way to . That is, for each node , it first locally
checks whether the constraints of the annotations are verified;
then it sends to the children of  the strategy and annotation
associated with , in order to successively verify whether the
promises associated with the children nodes are consistent with
the annotation of . Therefore, in  we have , , , , and for a state  and a letter  we
have {\small
    }
Hence, in  we have ,
, and index .

Finally, to define  we start by constructing a \TAPT 
whose size is polynomial in the size of  and accepts
 iff there is a non accepting
downward path (w.r.t. ) induced by , , and
 on . The automaton  (which in particular does not need
direction ) essentially chooses, in each state, the downward
path to walk on, and uses an integer to store the index of the
state. We use a special state  not belonging to  to
indicate that  proceeds in accordance with an annotation
instead of a strategy. Therefore, .

To define the transition function on a node , let us introduce
a function  that for each , strategy , and annotation  gives a formula satisfied along
downward paths consistent with  and , starting from
a node reachable in  with the state . That is, in each node
, the function  either proceeds according to the annotation
 or the strategy  (note that  does not check that
the downward path is consistent with any promise). Formally, 
is defined as follows, where  is the minimum  such
that : {\small
    }

Then, we have  and

{\small
}
\noindent A downward path  is non accepting for  if the
minimum index that appears infinitely often in  is odd.
Therefore,  where
 and, for all , we
have . Thus,
, , and
the index is . Then, since  is alternating, we can easily
complement it in polynomial-time into a \TAPT  that
accepts a tree iff all downward paths induced by ,
, and  on  are accepting. Finally,
following \cite{Var98} we construct in exponential-time the
desired automaton .
\end{proof}

By applying the transformation given by Lemma
\ref{lem:FromTgaptToNpt} to the automaton 
defined above, we obtain in exponential time in the size of
, an \NPT that accepts all the trees encoding of
quasi--forests that do not satisfy . From Proposition
\ref{pro:ClosureUnderIntersection}, then we can build a \PDNPT
 with size polynomial in the
size of  and exponential in the size of  such that
. Hence, from Proposition
\ref{the:TgaptEmptiness} we obtain that hybrid graded
--calculus pushdown module checking can be solved in \EXPTIME
in the size of  and in \TWOEXPTIME in the size of .
Finally, from the fact that \CTL pushdown module checking is known
to be \TWOEXPTIME--hard with respect to the size of  and
\EXPTIME--hard with respect to the size of  \cite{BMP05}, we
obtain the following theorem.

\begin{theorem}\label{the:HybridGradedPushdownModuleChecking}
The hybrid graded --calculus pushdown module checking problem
is \TWOEXPTIME--complete with respect to the size of the formula
and \EXPTIME--complete with respect to the size of the system.
\end{theorem}

\section{Fully Enriched -calculus Module Checking}\label{sec:FullyEnrichedModuleChecking}
In this section, we consider a memoryless restriction of the
module checking problem and investigate it with respect to
formulas of the Fully enriched -calculus. Given a formula
, a \emph{memoryless module checking} problem checks
whether all trees in , always taking the same choice in
duplicate environment nodes, satisfy . In this section,
we show that the (memoryless) module checking problem for Fully
enriched -calculus is undecidable.

Fully enriched --calculus is the extension of hybrid graded
--calculus with \emph{inverse programs}. Essentially, inverse
programs allow us to specify properties about predecessors of a
state. Given an atomic program , we denote its inverse
program with  and the syntax of the fully enriched
--calculus is simply obtained from the one we introduced for
hybrid graded --calculus, by allowing both atomic and inverse
programs in the graded modalities. Similarly, the semantics of
fully enriched --calculus is given, identically to the one
for hybrid graded --calculus, with respect to a Kripke
structure  in which, to deal with inverse
programs, we define, for all ,  such that .

Let us note that, since the fully enriched --calculus does
not enjoy the forest model property \cite{BP04}, we cannot unwind
a Kripke structure in a forest. However, it is always possible to
unwind it in an equivalent acyclic graph that we call
\emph{computation graph}. In order to take into account all the
possible behaviors of the environment, we consider all the
possible subgraphs of the computation graph obtained disabling
some transitions from environment nodes but one. We denote with
 the set of this graphs. Given a Fully enriched
--calculus formula , we have that  iff  for all .

To show the undecidability of the addressed problem, we need some
further definitions. An (infinite) \emph{grid} is a tuple  such that  and  are defined as
 and .
Given a finite set of \emph{types} , we will call \emph{tile}
on  a function  that
associates a type from  to each vertex of an infinite grid ,
and we call \emph{tiled infinite grid} the tuple
. A {\em grid model} is an infinite Kripke
structure , on the set of atomic programs
, such that  can be mapped on a grid in such
a way that  corresponds to the vertex , 
corresponds to  and  corresponds to . We say that a
grid model  ``corresponds'' to a tiled infinite grid
 if every state of  is labeled with only
one atomic proposition (and zero or more nominals) and there
exists a bijective function  such that,
if  is the state of  corresponding with the node
 of , then .

\begin{theorem}\label{the:undecidability}
The module checking problem for fully enriched --calculus is
undecidable.
\end{theorem}

\begin{proof}
To show the result, we use a reduction from the tiling problem (also known as
\emph{domino} problem), known to be undecidable \cite{Ber66}. The tiling
problem is defined as follows.

Let  be a finite set of types, and  be two relations
describing the types that cannot be vertically and horizontally adjacent in an
infinite grid. The tiling problem is to decide whether there exists a tiled
infinite grid  such that  preserves the
relations  and . We call such a tile function a \emph{legal tile} for 
on .

In \cite{BP04}, Bonatti and Peron showed undecidability for the satisfiability
problem for fully enriched --calculus by also using a reduction from the
tiling problem. Hence, given a set of types  and relations  and , they
build a (alternation free) fully enriched --calculus formula 
such that  is satisfiable iff the tiling problem has a solution in a
tiled infinite grid, with a legal tile  on  (with respect to  and
). In particular, the formula they build can be only satisfiable on a grid
model  corresponding to a tiled infinite grid with a legal tile  on
. In the reduction we propose here, we use the formula  used in
\cite{BP04}. It remains to define the module.

Let  be the set of all the infinite tiled grids on 
(i.e., ), we build a module  such that
 contains, for each , a grid models corresponding to .
Therefore, we can decide the tiling problem by checking whether . Indeed, if , then all grid models
corresponding to  do not satisfy  and, therefore, there is no
solution for the tiling problem. On the other side, if , then there exists a model for ; since  can be
satisfied only on a grid model corresponding to a tiled infinite grid with a
legal tile on  with respect to  and , we have that the tiling problem
has a solution.

Formally, let  be the set of types, the module  with respect to atomic programs , atomic propositions , and nominals , is defined as follows:
\begin{enumerate}[]
\item
, 
and ;

\item
for all ,  and
;

\item
;

\item

\end{enumerate}

Notice that we duplicate the set of nodes labeled with tiles since
we cannot have pairs of nodes in  labeled with more than one
atomic program (in our case, with both  and ). Moreover
the choice of labeling nodes  with nominals is arbitrary.
Finally, from the fact that the module contains only environment
nodes, it immediately follows that, for each , the grid model
corresponding to the infinite tiled grid  is contained in
.
\end{proof}

\section{Notes on Fully Enriched -calculus Model Checking}\label{sec:ModelChecking}
In this section, for the sake of completeness, we investigate the model
checking problems for Fully enriched -calculus and its fragments, for both
pushdown and finite-states systems.

In particular, we first consider the model checking problem for formulas of the
--calculus enriched with nominal (\emph{hybrid --calculus}) or graded
modalities (\emph{graded --calculus}) or both, for pushdown systems
(\PDMC, for short) and finite states systems (\FSMC, for short), i.e. Kripke
structures. In particular, we show that for graded --calculus, \PDMC is
solvable in \TWOEXPTIME and \FSMC is solvable in \EXPTIME. Moreover we show
that for hybrid --calculus \PDMC is \EXPTIME--complete and \FSMC is in \UP
 \coUP, thus matching the known results for (propositional)
--calculus model checking (see \cite{Wal96} for \PDMC and \cite{Wil01} for
\FSMC), and that, for hybrid graded --calculus, \PDMC is solvable in
\TWOEXPTIME and \FSMC is solvable in \EXPTIME.

By considering also -calculus enriched (among the others) with inverse
programs, we also consider \PDMC w.r.t. a reduced pushdown system that, in each
transition, can increase the size of the stack by at most one
(\emph{single--push system}). To this aim, we define a single--push system with
three stack operations: for ,  changes the top of the
stack into ,  pushes the symbol  on the top of the stack, and
 pops the top symbol of the stack. Formally, a single--push system 
is a pushdown system in which the transition function is . For consistency reasons, we assume that if the top of the stack is
 then  and  has no effect.

We call the model checking problem for single--push systems \emph{single--push
model checking} (\SPMC, for short). In this case, we show that for full hybrid
--calculus (-calculus enriched with inverse programs and nominals),
\SPMC is \EXPTIME--complete and \FSMC is in \UP  \coUP, and that for
Fully enriched and full graded --calculus (-calculus enriched with
inverse programs and graded modalities), \SPMC is in \TWOEXPTIME and \FSMC is
in \EXPTIME. In Figure~\ref{tab:ModelChecking} we report known and new results
on model checking problems for the Fully enriched --calculus and its
fragments.

\begin{figure}[t]
    {\small
    \begin{tabular}{|l|c|c|c|}
        \hline
        -calculus & Pushdown                        & Single--Push         & Finite--State                 \\
        extensions     & Model Checking                  & Model Checking       & Model Checking                \\
        \hline
        propositional  & \EXPTIME--Complete \cite{Wal96} & \EXPTIME--Complete   & \UP  \coUP \cite{Wil01} \\
        hybrid         & \EXPTIME--Complete              & \EXPTIME--Complete   & \UP  \coUP              \\
        graded         & \TWOEXPTIME                     & \TWOEXPTIME          & \EXPTIME                      \\
        full           & ?                               & \EXPTIME--Complete   & \UP  \coUP              \\
        hybrid graded  & \TWOEXPTIME                     & \TWOEXPTIME          & \EXPTIME                      \\
        full hybrid    & ?                               & \EXPTIME--Complete   & \UP  \coUP              \\
        full graded    & ?                               & \TWOEXPTIME          & \EXPTIME                      \\
        Fully enriched & ?                               & \TWOEXPTIME          & \EXPTIME                      \\
        \hline
    \end{tabular}
    \caption{Results on Model Checking Problem.}
    }
    \label{tab:ModelChecking}
\end{figure}

To prove our results, we simply rule out inverse programs and nominals from the
input formula. In particular, we first observe that, from a model checking
point of view, checking a formula with inverse programs on a graph (finite or
infinite) is equivalent to check the formula in ``forward'' on the graph
enriched with opposite edges. That is, we consider inverse programs in the
formula as special atomic programs to be checked on the opposite edges we have
added in the graph. Note that this observation does not apply to \PDMC. Indeed,
to transform previous configurations to inverse next configurations, we need to
limit the power of a \PDMC to be single push. Thus, we obtain the following
result.

\begin{lemma}\label{lem:RemovingInversePrograms}
Let  be an enrichment of the -calculus with inverse programs.
Then a \SPMC (resp., \FSMC) w.r.t.  can be reduced in linear time to
\SPMC (resp., \FSMC) w.r.t.  without inverse programs.
\end{lemma}

\begin{proof}
Here we only show the proof for \FSMC since the one for \SPMC is similar. Let
 be a model that uses atomic programs from
, and let  be a formula of . Then, we define a new
model  and a new formula  as follows:  uses atomic programs from the set  s.t.
 (it doesn't use inverse programs) and has the transition
relation defined as  and  for all . On the other side,  is a formula of  without inverse
programs equal to  except for the fact that  is changed into
 for all . Thus it can be easily seen that  iff  and this completes the proof of this lemma.
\end{proof}

Furthermore, from the model checking point of view, one can consider each
nominal in the input formula as a particular atomic proposition. Thus we obtain
the following result.

\begin{lemma}\label{lem:RemovingNominals}
Let  be the -calculus enriched with nominals and possibly with
graded modalities. Then \PDMC, \SPMC and \FSMC w.r.t.  can be
respectively reduced in linear time to \PDMC, \SPMC and \FSMC w.r.t. 
without nominals.
\end{lemma}

\begin{proof}
In this case too, we show the proof only for \FSMC. Let  be a model that uses atomic propositions from  and nominals
from , and let  be a formula of . Then, we consider the
new model  that uses atomic propositions
from the set  ( does not use nominals); moreover, let
 be the formula  interpreted as a formula of 
without nominals on the set of atomic propositions . Then, it is easy to
see that  iff .
\end{proof}

From Lemmas \ref{lem:RemovingInversePrograms} and \ref{lem:RemovingNominals}
and the fact that for propositional --calculus \PDMC is \EXPTIME--Complete
\cite{Wal96} and \FSMC is in \UP  \coUP \cite{Wil01}, we directly have
that hybrid --calculus \PDMC is \EXPTIME--Complete, (full) hybrid
--calculus \SPMC is solvable in \EXPTIME and (full) hybrid --calculus
\FSMC is in \UP  \coUP. Now, in \cite{Wal96} it has been showed that
-calculus \PDMC is \EXPTIME--hard. The proof used there can be easily
adapted to handle single--push systems without incurring in any complexity
blowup. Thus, we obtain the following result.

\begin{theorem}\label{the:FullHybridMuCalculusModelChecking}
Hybrid --calculus \PDMC is \EXPTIME--Complete, (full) hybrid
--calculus \SPMC is \EXPTIME--Complete and (full) hybrid --calculus
\FSMC is in \UP  \coUP.
\end{theorem}

Finally, from Lemmas \ref{lem:RemovingInversePrograms} and
\ref{lem:RemovingNominals} we have that hybrid graded --calculus \PDMC can
be reduced in linear time to graded --calculus \PDMC, Fully enriched
--calculus \SPMC can be reduced in linear time to graded --calculus
\SPMC (note that \SPMC is a special case of \PDMC) and Fully enriched
-calculus \FSMC can be reduced in linear time to graded -calculus
\FSMC. Since model checking is a special case of module checking, from Theorems
\ref{the:HybridGradedFiniteStatesModuleChecking} and
\ref{the:HybridGradedPushdownModuleChecking} we have the following result.

\begin{theorem}\label{the:ModelCheckingForFullyEnrichedMuCalculus}
\PDMC is solvable in \TWOEXPTIME for (hybrid) graded --calculus, \SPMC is
solvable in \TWOEXPTIME for Fully enriched -calculus and \FSMC is solvable
in \EXPTIME for Fully enriched -calculus.
\end{theorem}

\bibliographystyle{amsalpha}
\bibliography{mucalculusmodule}
\end{document}
