\documentclass{llncs}


\newcommand{\dmft}{\ensuremath{\mathsf{MFT}}\xspace}
\newcommand{\mft}{\ensuremath{\mathsf{dMFT}}\xspace}
\newcommand{\vpa}{\ensuremath{\mathsf{VPA}}\xspace}
\newcommand{\vpas}{\ensuremath{\mathsf{VPAs}}\xspace}
\newcommand{\dvpas}{\ensuremath{\mathsf{dVPAs}}\xspace}
\newcommand{\dvpa}{\ensuremath{\mathsf{dVPA}}\xspace}
\newcommand{\vpt}{\ensuremath{\mathsf{VPT}}\xspace}
\newcommand{\vpts}{\ensuremath{\mathsf{VPTs}}\xspace}
\newcommand{\mtts}{\ensuremath{\mathsf{MTTs}}\xspace}
\newcommand{\mtt}{\ensuremath{\mathsf{MTT}}\xspace}
\newcommand{\wnvpt}{\ensuremath{\mathsf{wnVPT}}\xspace}
\newcommand{\vptla}{\ensuremath{\mathsf{VPT_{la}}}\xspace}
\newcommand{\wn}{\ensuremath{\mathsf{wn}}\xspace}
\newcommand{\wnvpts}{\ensuremath{\mathsf{wnVPTs}}\xspace}
\newcommand{\dvpt}{\ensuremath{\mathsf{dVPT}}\xspace}
\newcommand{\pt}{\ensuremath{\mathsf{PT}}\xspace}
\newcommand{\pts}{\ensuremath{\mathsf{PTs}}\xspace}
\newcommand{\dpt}{\ensuremath{\mathsf{dPT}}\xspace}
\newcommand{\dpts}{\ensuremath{\mathsf{dPTs}}\xspace}
\newcommand{\vpl}{\ensuremath{\mathsf{VPL}}\xspace}
\newcommand{\vpls}{\ensuremath{\mathsf{VPLs}}\xspace}
\newcommand{\regular}{\ensuremath{\mathsf{REG}}\xspace}
\newcommand{\cfl}{\ensuremath{\mathsf{CFL}}\xspace}
\newcommand{\cfls}{\ensuremath{\mathsf{CFLs}}\xspace}
\newcommand{\dcfl}{\ensuremath{\mathsf{dCFL}}\xspace}
\newcommand{\eop}{\ensuremath{\hfill\square}}
\newcommand{\nd}{\ensuremath{\mathsf{nd}}}
\newcommand{\nest}{\ensuremath{\mathsf{nest}}}
\newcommand{\sn}{8} \newcommand{\fsts}{\ensuremath{\mathsf{FSTs}}\xspace}
\newcommand{\fst}{\ensuremath{\mathsf{FST}}\xspace}
\newcommand{\evpt}{\ensuremath{\mathsf{\epsilon\text{-}VPT}}\xspace}
\newcommand{\evpts}{\ensuremath{\mathsf{\epsilon\text{-}VPTs}}\xspace}

\newcommand{\eval}{{\textsc{Eval}}\xspace}
\newcommand{\evalcompact}{\ensuremath{\eval_{\textsc{compact}}}\xspace}
\newcommand{\naivecompact}{\ensuremath{\naive_{\textsc{compact}}}\xspace}
\newcommand{\streamable}{\textsc{Streamable}\xspace}
\newcommand{\B}{\textsc{B}}
\newcommand{\HB}{\textsc{HB}}
\newcommand{\ExpHB}{\textsc{ExpHB}}
\newcommand{\naive}{{\textsc{Naive}}\xspace}
\newcommand{\ist}{\ensuremath{\mathsf{IST}}\xspace}
\newcommand{\dconf}{d-configuration\xspace}
\newcommand{\dconfs}{d-configurations\xspace}
\newcommand{\Dconfs}[1]{\ensuremath{\mathsf{Dconfs}(#1)}\xspace}
\newcommand{\hDconfs}[1]{\ensuremath{\mathsf{hDconfs}(#1)}\xspace}
\newcommand{\hDconfsN}[1]{\ensuremath{\mathsf{hDconfs_{\pm}}(#1)}\xspace}
\newcommand{\SigmaN}{\ensuremath{\Sigma_-}\xspace}
\newcommand{\lcp}[1]{\ensuremath{\mathsf{lcp}(#1)}\xspace}
\newcommand{\lcpin}[2]{\ensuremath{\mathsf{lcp_{in}}(#1,#2)}\xspace}
\newcommand{\lcpe}[1]{\ensuremath{\mathsf{lcp}(#1)}\xspace}
\newcommand{\maxout}{\ensuremath{\mathsf{maxout}}\xspace}
\newcommand{\hmid}{\ \mid\ }
\newcommand{\update}{\ensuremath{\mathsf{update}}\xspace}
\newcommand{\remlcp}{\ensuremath{\mathsf{rem\_lcp}}\xspace}
\newcommand{\EOS}{\\dag\dag\\bigstar\bigstar\bigstar\bigstar
h(h_{i_1}(\dots h_{i_k}(v)\dots)) = 
g(g_{i_1}(\dots g_{i_k}(w)\dots))
f_q^i (\alpha) = \left \{
    \begin{array}{ll}
     \text{subscript}_q(\f_t:A^* \rightarrow A^*t = (q,a,q')\in\delta\} \\
     \epsilon                                        & \text{ otherwise }       
    \end{array}
    \right .        
        f_{q_0}(\alpha) = \left \{
    \begin{array}{ll}
     a              & \text{ if } \alpha = a_{q_0} \text{ with }a\in \Gamma   \\
     \epsilon    & \text{ otherwise}      
    \end{array}
    \right .        
        f_{q_0}(f_{t_1}(\dots f_{t_n}(f_q^i(\#)\dots))) = \pi_i(T(u))h(h_{i_1}(\dots h_{i_k}(\#)\dots)) = \epsilon =  g(g_{i_1}(\dots g_{i_k}(\#)\dots))
f_{q_0}(f_{t_1}(\dots f_{t_n}(f_q^1(\#)\dots))) = 
f_{q_0}(f_{t_1}(\dots f_{t_n}(f_q^2(\#)\dots)))

    \begin{array}{cccccccccccccccccccccccccc}

        h = g & : & a & \rightarrow & e &\qquad h_1 & : & a & \rightarrow & a &
        \qquad g_1 & : &  a & \rightarrow a \\
           &   &  b & \rightarrow & f & & & b & \rightarrow & b & & &
           b & \rightarrow b \\
            &   &  c & \rightarrow & \epsilon & & & c & \rightarrow &
            acb & & & c & \rightarrow & ca\\
            &   & d & \rightarrow & \epsilon & & &  d & \rightarrow &
            \epsilon & & & d & \rightarrow & db 
    \end{array}
    
    \begin{array}{ccccccccccccccccccccccc}
    v = c & \xrightarrow{h_1} & acb
    & \xrightarrow{h_1} & a^2cb^2 & \xrightarrow{h_1} & a^3cb^3
    & \xrightarrow{h} & e^3f^3 \\

    w = cd & \xrightarrow{g_1} & cadb
    & \xrightarrow{g_1} & ca^2db^2 & \xrightarrow{g_1} & ca^3db^3
    & \xrightarrow{g} & e^3f^3 \\
    \end{array}
    
The two constructed SSTs are then the following:

\begin{center}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1cm,
 semithick,scale=0.9]
  \tikzstyle{every state}=[fill=blue!20!white,minimum size=2em]
\tikzstyle{accepting-output}=[accepting by arrow, accepting
  where=below, accepting text=]
 \node[initial, initial text={},state,fill=blue!20!white] at (1,0) (A) {} ;
 \node[state,accepting-output, accepting, fill=blue!20!white] at (5,0) (B) {} ;
 \path(A) edge  node[anchor=south,below]{} (B);
  \path(B) edge [loop above] node[anchor=north,above]  {} (B);
 \node[draw=none] at (-0.5,0) {};

  \tikzstyle{every state}=[fill=blue!20!white,minimum size=2em]
\tikzstyle{accepting-output}=[accepting by arrow, accepting
  where=below, accepting text=]
 \node[initial, initial text={},state,fill=blue!20!white] at (8,0) (A) {} ;
 \node[state,accepting-output, accepting, fill=blue!20!white] at (12,0) (B) {} ;
 \path(A) edge  node[anchor=south,below]{} (B);
  \path(B) edge [loop above] node[anchor=north,above]  {} (B);
 \node[draw=none] at (6.5,0) {};
   \end{tikzpicture}
\end{center}
\end{example}


\end{proof} 






\bibliographystyle{abbrv}


\begin{thebibliography}{1}

\bibitem{AC10}
R.~Alur and P.~{\v C}ern\'y.
\newblock {Expressiveness of streaming string transducers}.
\newblock In {\em FSTTCS}, volume~8, pages 1--12, 2010.

\bibitem{DBLP:conf/icalp/AlurD12}
R.~Alur and L.~D'Antoni.
\newblock Streaming tree transducers.
\newblock In {\em ICALP (2)}, volume 7392 of {\em LNCS}, pages 42--53.
  Springer, 2012.

\bibitem{DBLP:conf/lics/AlurDDRY13}
R.~Alur, L.~D'Antoni, J.~V. Deshmukh, M.~Raghothaman, and Y.~Yuan.
\newblock Regular functions and cost register automata.
\newblock In {\em 28th Annual {ACM/IEEE} Symposium on Logic in Computer
  Science, {LICS} 2013, New Orleans, LA, USA, June 25-28, 2013}, pages 13--22.
  {IEEE} Computer Society, 2013.

\bibitem{conf/icalp/AlurD11}
R.~Alur and J.~V. Deshmukh.
\newblock Nondeterministic streaming string transducers.
\newblock In {\em ICALP}, volume 6756 of {\em LNCS}, pages 1--20. Springer,
  2011.

\bibitem{DBLP:conf/lics/AlurFT12}
R.~Alur, E.~Filiot, and A.~Trivedi.
\newblock Regular transformations of infinite strings.
\newblock In {\em LICS}, pages 65--74. IEEE, 2012.

\bibitem{EH01}
J.~Engelfriet and H.~J. Hoogeboom.
\newblock {MSO} definable string transductions and two-way finite-state
  transducers.
\newblock {\em ACM Trans. Comput. Logic}, 2:216--254, 2001.

\bibitem{MTT}
J.~Engelfriet and S.~Maneth.
\newblock Macro tree transducers, attribute grammars, and mso definable tree
  translations.
\newblock {\em Information and Computation}, 154(1):34--91, 1999.

\bibitem{DBLP:journals/tcs/CulikK86}
K.~C. II and J.~Karhum{\"{a}}ki.
\newblock The equivalence of finite valued transducers (on {HDT0L} languages)
  is decidable.
\newblock {\em Theor. Comput. Sci.}, 47(3):71--84, 1986.

\end{thebibliography}
 
\end{document}
