\documentclass[authoryear]{article}
\usepackage{authblk}
\usepackage{natbib}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{pdfpages}
\usepackage{amsmath,amssymb}



\usepackage{amsthm}

\newtheorem{theorem}{Theorem}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{claim}{Claim}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{observation}[theorem]{Observation}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}

\usepackage{mathtools}
\usepackage{tikz}
\usepackage{graphicx}


\usetikzlibrary{shapes}
\usetikzlibrary{backgrounds}
\usetikzlibrary{decorations.pathmorphing}
\usetikzlibrary{decorations.pathreplacing}
\usetikzlibrary{calc}
\usetikzlibrary{fit}
\usetikzlibrary{positioning}




\newcommand{\Rho}{\mathrm{P}}
\newcommand{\sebastian}[1]{\marginpar{\textcolor{blue}{Sebastian: }#1}}
\newcommand{\Lukasz}[1]{\marginpar{\textcolor{pink}{\L{}ukasz: }#1}}
\newcommand{\Stephan}[1]{\marginpar{\textcolor{red}{Stephan: }#1}}
\newcommand{\Saeed}[1]{\marginpar{\textcolor{orange}{Saeed: }#1}}
\newcommand{\stephan}[1]{\textbf{#1}}
\newcommand{\RR}[1]{\marginpar{\textcolor{green!80!black}{Roman: }#1}}
\newcommand{\RRl}[1]{\reversemarginpar\marginpar{\textcolor{green!80!black}{Roman: }#1}\par\normalmarginpar}



\usepackage{xspace}
\usepackage{enumerate}
\usepackage{mathdots} \usepackage{times}
\usepackage[shortlabels]{enumitem}





 

\newdimen\arrowsize
\newlength{\arrowlength}
\newlength{\arrowangle}
\newlength{\arrowthickness}

\setlength{\arrowlength}{0.15cm}
\setlength{\arrowangle}{5.5cm}
\setlength{\arrowthickness}{0.07cm}


\pgfarrowsdeclare{slim}{slim}
{
\arrowsize=0.7pt
\advance\arrowsize by .5\pgflinewidth
\pgfarrowsleftextend{-4\arrowsize-.5\pgflinewidth}
\pgfarrowsrightextend{.5\pgflinewidth}
}
{
\advance\arrowsize by .5\pgflinewidth
\pgfsetdash{}{0pt} \pgfsetroundjoin \pgfsetroundcap \pgfpathmoveto{\pgfpointpolar{\arrowangle}{\arrowlength}}
\pgfpathlineto{\pgfpointorigin}
\pgfusepathqstroke
\pgfpathmoveto{\pgfpointpolar{\arrowangle}{\arrowlength}}
\pgfpathcurveto{\pgfpointpolar{\arrowangle*1.04}{\arrowthickness+0.5*(\arrowlength-\arrowthickness)}}{\pgfpointpolar{\arrowangle*1.1}{\arrowthickness+0.3*(\arrowlength-\arrowthickness)}}
{\pgfpointpolar{180}{\arrowthickness}}
\pgfpathlineto{\pgfpointorigin}
\pgfusepathqfill
\pgfpathmoveto{\pgfpointpolar{-\arrowangle}{\arrowlength}}
\pgfpathlineto{\pgfpointorigin}
\pgfusepathqstroke
\pgfpathmoveto{\pgfpointpolar{-\arrowangle}{\arrowlength}}
\pgfpathcurveto{\pgfpointpolar{-\arrowangle*1.04}{\arrowthickness+0.5*(\arrowlength-\arrowthickness)}}{\pgfpointpolar{-\arrowangle*1.1}{\arrowthickness+0.3*(\arrowlength-\arrowthickness)}}
{\pgfpointpolar{180}{\arrowthickness}}
\pgfpathlineto{\pgfpointorigin}
\pgfusepathqfill
}





\tikzstyle{vertex}=[circle,inner sep=2.5,minimum size =2mm,semithick,fill=black!20, draw=black]
\tikzstyle{holevertexB}=[circle,inner sep=-0.7,minimum size =2mm,semithick,fill=white, draw=black]
\tikzstyle{holevertexA}=[circle,inner sep=2.5,minimum size =2mm,semithick,fill=white, draw=black]
\tikzstyle{smallcircle}=[circle,inner sep=1.5,fill=white, draw=black]
\tikzstyle{point}=[circle,inner sep=1,fill=black, draw=black]
\tikzstyle{path}=[-slim,thin,rounded corners] \tikzstyle{path1}=[-slim,thin,decorate,decoration={snake,amplitude=6pt,segment length=#1,pre length=#1/20,post length=#1/20}]\tikzstyle{path2}=[-stealth,thin,decorate,decoration={snake,amplitude=6pt,segment length=#1,pre length=#1/10,post length=#1/10}]\tikzstyle{brace}=[thin,decorate,decoration=brace]
\tikzstyle{ie}=[thin,dashed,gray]



\colorlet{fillA}{gray!50}
\colorlet{fillB}{gray!15}
 \makeatletter
\newcommand{\@abbrev}[3]{
  \def\c@a@def##1{
      \if ##1.
        \relax
      \else
        \@ifdefinable{\@nameuse{#1##1}}{\@namedef{#1##1}{#2##1}}
        \expandafter\c@a@def
      \fi
    }
  \c@a@def #3.
}
\@abbrev{bb}{\mathbb}{ABCDEFGHIJKLMNOPQRSTUVWXYZ}
\@abbrev{bf}{\mathbf}{ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz}
\@abbrev{bit}{\boldsymbol}{ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz}
\@abbrev{cal}{\mathcal}{ABCDEFGHIJKLMNOPQRSTUVWXYZ}
\@abbrev{frak}{\mathfrak}{ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz}
\@abbrev{rm}{\mathrm}{ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz}
\@abbrev{scr}{\mathscr}{ABCDEFGHIJKLMNOPQRSTUVWXYZ}
\@abbrev{sf}{\mathsf}{ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz}
\@abbrev{Alg}{\Alg}{ABCDEFGHIJKLMNOPQRSTUVWXYZ}
\@abbrev{Str}{\Str}{ABCDEFGHIJKLMNOPQRSTUVWXYZ}
\@abbrev{set}{\mathbb}{ABCDEFGHIJKLMNOPQRSTUVWXYZ}
\@abbrev{tup}{\tup}{ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz}
\@abbrev{tld}{\tilde}{ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz}
\makeatother

\newcommand{\red}[1]{\textcolor{red}{#1}} 

\DeclareMathOperator{\Reach}{Reach}
\DeclareMathOperator{\Win}{Win}
\DeclareMathOperator{\blocked}{blocked}
\DeclareMathOperator{\nfreecops}{nfreecops}
\DeclareMathOperator{\flap}{cpt}
\DeclareMathOperator{\Tied}{Tied}
\DeclareMathOperator{\Ex}{Ex}
\DeclareMathOperator{\dtwmeasure}{dtw}
\DeclareMathOperator{\otwmeasure}{otw}
\DeclareMathOperator{\supp}{supp}
\DeclareMathOperator{\fx}{fx}
\DeclareMathOperator{\freecops}{freecops}
\DeclareMathOperator{\noutside}{\#_{\mathrm{out}}}
\DeclareMathOperator{\init}{init}
\DeclareMathOperator{\update}{update}
\DeclareMathOperator{\leaf}{leaf}
\DeclareMathOperator{\MCgame}{MCgame}
\DeclareMathOperator{\var}{var}
\DeclareMathOperator{\lev}{lev}




\renewcommand{\mid}{\ensuremath{:}}

\newcommand{\overbar}[1]{\mkern 1mu\overline{\mkern-1mu#1\mkern-1mu}\mkern 1mu}
\renewcommand{\phi}{\varphi}
\renewcommand{\epsilon}{\varepsilon}
\renewcommand{\theta}{\vartheta}
\newcommand{\0}{\emptyset}

\newcommand{\shc}{shc}
\newcommand{\perpcdot}{{\perp}{\kern0.1em{\cdot}\kern0.1em}}
\newcommand{\crsp}{\mathrm{crsp}}
\renewcommand{\split}[1]{\ensuremath{{\mathrm{split}(#1)}}}
\newcommand{\tied}[1]{\ensuremath{\mathrm{tied(#1)}}}
\newcommand{\Succ}[1]{\ensuremath{\mathrm{Succ(#1)}}}
\newcommand{\ot}{\leftarrow}
\newcommand{\dunion}{\mathbin{\dot{\cup}}}
\newcommand{\freeze}{\ensuremath{\text{\scriptsize \SnowflakeChevron}}}
\newcommand{\sigmacomb}{\ensuremath{\sigma^\freeze_\lc}}
\newcommand{\mb}{{\mathrm{mb}}}
\renewcommand{\ss}{\mathrm{ss}}
\newcommand{\nb}{\mathrm{nb}}
\newcommand{\front}{\mathrm{front}}
 \newcommand{\dgr}{\ensuremath{{dgr}}}
 \newcommand{\dpth}{\ensuremath{{dpth}}}
 \newcommand{\Pos}{\mathrm{Pos}}
 \newcommand{\Moves}{\mathrm{Moves}}
 \newcommand{\nonMon}{\neg\mathrm{Mon}}
\newcommand{\wmon}{\textup{wm}}
 \newcommand{\Playsinf}{\mathrm{Plays}_\mathrm{Inf}}
 \newcommand{\Playsfin}{\mathrm{Plays}_\mathrm{Fin}}
\newcommand{\reach}{\mathrm{reach}}
\newcommand{\comp}{\mathrm{comp}}
\newcommand{\Mon}{\textup{Mon}}
\newcommand{\copmon}{\textup{cm}}
\newcommand{\robmon}{\textup{rm}}
\newcommand{\ReachMoves}{\textup{ReachMoves}}
\newcommand{\CompMoves}{\textup{CompMoves}}
\newcommand{\heading}[1]{\textbf{#1}}



\DeclareMathAlphabet{\mathsc}{OT1}{cmr}{m}{sc}

\newcommand{\ptime}{\ensuremath{\mathsc{Ptime}}\xspace}
\newcommand{\np}{\ensuremath{\mathsc{NP}}\xspace}
\newcommand{\conp}{\ensuremath{\text{co-}\mathsc{NP}}\xspace}
\newcommand{\pspace}{\ensuremath{\mathsc{PSpace}}\xspace}
\newcommand{\aptime}{\ensuremath{\mathsc{APTime}}\xspace}
\newcommand{\nptime}{\ensuremath{\mathsc{NPtime}}\xspace}
\newcommand{\DAGWprob}{\ensuremath{\mathsc{DAGW}}\xspace}
\newcommand{\taut}{\ensuremath{\mathsc{Tautology}}\xspace}
\newcommand{\PH}{\ensuremath{\Sigma^p}}
\newcommand{\QBF}{\ensuremath{\mathrm{QBF}}\xspace}

\newcommand{\cupdot}{\mathbin{\mathaccent\cdot\cup}}





\newcommand{\elorder}{\mathbin{\vartriangleleft}}
\newcommand{\elorderg}{\mathbin{\vartriangleright}}
\newcommand{\elordereq}{\mathbin{\unlhd}}
\newcommand{\elordergeq}{\mathbin{\unrhd}}
\newcommand{\setorder}{\mathbin{\sqsubset}}
\newcommand{\setordereq}{\mathbin{\sqsubseteq}}
\newcommand{\topordereq}{\sqsubseteq}

\newcommand{\nearer}{\mathbin{\preceq}}
\newcommand{\totheright}{\mathbin{\vartriangleleft}}
\newcommand{\prefixordereq}{\mathbin{\sqsubseteq}}
\newcommand{\prefixorder}{\mathbin{\sqsubset}}

\DeclareMathOperator{\MCGAME}{MCgame}

 

\newcommand{\tw}{tree {}width\xspace}
\newcommand{\pw}{path {}width\xspace}
\newcommand{\Tw}{Tree {}width\xspace}
\newcommand{\dtw}{directed tree {}width\xspace}
\newcommand{\dpw}{directed path {}width\xspace}
\newcommand{\Dtw}{Directed tree {}width\xspace}
\newcommand{\otw}{oriented tree {}width\xspace}
\newcommand{\Otw}{Oriented tree {}width\xspace}
\newcommand{\dagw}{DAG-{}width\xspace}
\newcommand{\Dagw}{DAG-{}width\xspace}
\newcommand{\kw}{Kelly-{}width\xspace}
\newcommand{\Kw}{Kelly-{}width\xspace}
\newcommand{\dw}{D-{}width\xspace}
\newcommand{\Dw}{D-{}width\xspace}
\newcommand{\DSw}{DS-{}width\xspace}



\newcommand{\dagg}{DAG game\xspace}




\newcommand{\shy}{{\mathrm{shy}}}
\newcommand{\wm}{{\mathrm{wm}}}
\newcommand{\sm}{{\mathrm{sm}}}
\newcommand{\shywm}{{\mathrm{shy}\text{-}\mathrm{wm}}}
\newcommand{\shysm}{{\mathrm{shy}\text{-}\mathrm{sm}}}
\newcommand{\shysim}{{\mathrm{shy}\text{-}\mathrm{sim}}}\newcommand{\lc}{{\mathrm{lc}}} \newcommand{\smon}{\mathrm{smon}} 
\newcommand{\noncopmon}{\neg\mathrm{cm}} 
\newcommand{\nonrobmon}{\neg\mathrm{rm}} 

\DeclareMathOperator{\dTW}{dtw}
\DeclareMathOperator{\dPW}{dpw}
\newcommand{\dTWcops}[1]{cn_{#1}(\dTW)}
\newcommand{\dTWgame}[1]{\mathop{\mathbb{G}}(\dTW,#1)}
\newcommand{\cmdTWcops}[1]{cn_{#1}(\cmdTW)}
\newcommand{\cmdTWgame}[1]{\mathop{\mathbb{G}}(\cmdTW,#1)}
\newcommand{\rmdTWcops}[1]{cn_{#1}(\rmdTW)}
\newcommand{\rmdTWgame}[1]{\mathop{\mathbb{G}}(\rmdTW,#1)}
\newcommand{\shyDAGWcops}[1]{cn_{#1}(\mathrm{shyDAGgame})}
\newcommand{\wmDAGWcops}[1]{cn_{#1}(\mathrm{wmDAGgame})}
\newcommand{\wmshyDAGWcops}[1]{cn_{#1}(\mathrm{wmshyDAG})}
\newcommand{\DAGWcops}[1]{cn_{#1}(\mathrm{DAG})}
\newcommand{\DAGWgame}[1]{\mathop{\mathbb{G}}(\mathrm{DAG},#1)}




\DeclareMathOperator{\wmDAGW}{wmDAG\text{-}\mathrm{w}}
\DeclareMathOperator{\smDAGW}{sm\text{-}DAG\text{-}w}
\DeclareMathOperator{\nmDAGW}{nm\text{-}DAG\text{-}w}
\DeclareMathOperator{\DAGW}{DAG\text{-}w}
\DeclareMathOperator{\KW}{Kelly\text{-}w}
\DeclareMathOperator{\nmKW}{nmKelly\text{-}w}
\DeclareMathOperator{\DW}{D\text{-}w}
\newcommand{\DWcops}{cn(D\text{-}w)}
\DeclareMathOperator{\DS}{DS\text{-}w}
\newcommand{\DScops}{cn(DS\text{-}w)}
\DeclareMathOperator{\oTW}{otw}
\DeclareMathOperator{\STW}{stw}
\DeclareMathOperator{\cmdTW}{cmdtw}
\DeclareMathOperator{\rmdTW}{rmdtw}



\DeclareMathOperator{\dTWG}{\mathrm{dtw}\text{-}\mathrm{game}}
\DeclareMathOperator{\cmdTWG}{\mathrm{cm}\text{-}\mathrm{dtw}\text{-}\mathrm{game}}
\DeclareMathOperator{\DAGGex}{DAG\text{-}game^*}
\DeclareMathOperator{\DAGG}{DAG\text{-}game}
\DeclareMathOperator{\nmDAGG}{nmDAG\text{-}game}
\DeclareMathOperator{\KWG}{Kelly\text{-}game}
\DeclareMathOperator{\DWG}{D\text{-}game}
\DeclareMathOperator{\DTWG}{dtw\text{-}game}
\DeclareMathOperator{\shyDAGG}{\mathrm{shy}\text{-}DAG\text{-}game}
\DeclareMathOperator{\wmDAGG}{\mathrm{wm}DAG\text{-}game}
\DeclareMathOperator{\wmshyDAGG}{\mathrm{wm}\mathrm{shy}DAG\text{-}game}
 


\newcommand{\ie}{i.e.\@\xspace}
\newcommand{\Ie}{I.e.\@\xspace}
\newcommand{\eg}{e.g.,\xspace}
\newcommand{\cf}{c.f.\@\xspace}

\renewcommand{\labelenumi}{(\theenumi)}


\pagestyle{plain}




 \usepackage{hyperref}
\hypersetup{colorlinks=true,linkcolor=blue!60!black,citecolor=blue!70!black}


\begin{document}
  \title{DAG-width is PSPACE-complete\thanks{The research of all authors has
    been supported by the European Research Council (ERC) under the European Unionâ€™s Horizon 2020 research and
    innovation programme (ERC consolidator grant DISTRUCT, agreement No 648527).}}
  \author[ ]{Saeed Akhoondian Amiri}
  \author[ ]{Stephan Kreutzer}
  \author[ ]{Roman~Rabinovich}
  \affil[ ]{Logic and Semantics, Technische Universit\"at Berlin}
  \affil[ ]{\texttt{\{saeed.amiri,stephan.kreutzer,roman.rabinovich\}\\@tu-berlin.de}}
  \date{}

\maketitle
  
\begin{abstract}

  Berwanger et al.\@ show in~\cite{BerwangerDawHunKreObd12} that for
  every graph~ of size~ and \dagw~ there is a DAG
  decomposition of width~ and size . This gives a
  polynomial time algorithm for determining the \dagw of a graph for
  any fixed~. However, if the \dagw of the graphs from a class is
  not bounded, such algorithms become exponential. This raises the
  question whether we can always find a DAG decomposition of size
  polynomial in~ as it is the case for \tw and all generalisations
  of \tw similar to \dagw.

  We show that  there is an infinite class of graphs such that every DAG
  decomposition of optimal width has size super-polynomial in~ and,
  moreover, there is no polynomial size DAG decomposition 
  which would approximate an optimal decomposition up to
  an additive constant.

  In the second part we use our construction to prove that deciding
  whether the DAG-width of a given graph is at most a given constant
  is \pspace-complete.


\end{abstract}

 


\section{Introduction}

In the study of hard algorithmic problems on graphs,
methods derived from structural graph theory have proved to be a
valuable tool. The rich theory of special classes of graphs developed
in this area has been used to identify classes of graphs, such as
classes of bounded tree width or clique width,
on which many computationally hard problems can be solved
efficiently. 
Most of these classes are defined by some structural
property, such as having a tree decomposition of low width, and this structural 
information can be exploited
algorithmically. 

Structural properties of classes of graphs such as tree width, clique
width, definability by excluded minors etc.\@ studied in this context relate to
undirected graphs.
However, in various applications in computer science, directed graphs are
a more appropriate model. 
Given the enormous success
width parameters 
had for problems defined on undirected graphs, it is natural to ask
whether they can also be used to analyse the complexity of hard
algorithmic problems
on digraphs.
While in principle it is 
possible to apply the structure theory for undirected graphs to directed
graphs by ignoring the direction of edges, this implies a significant
information loss. Hence,
for computational problems whose instances are directed graphs,  
methods based on the structure theory for undirected graphs may be
less useful.

\Tw is one of the most successful structural complexity measures. It has several
characterisations coming from seemingly unrelated notions, \eg by
elimination orders or cops and robber games. \Tw is also deeply
connected to graph minors and has numerous algorithmic applications.
The result of several approaches to generalise \tw to digraphs was a
number of structural complexity measures for digraphs. 
Reed \cite{Reed99} and Johnson, Robertson, Seymour and
Thomas~\cite{JohnsonRobSeyTho01} introduced the
concept of \emph{directed tree width} and showed that the -disjoint
paths problem and more general linkage problems can be solved in
polynomial-time on classes of digraphs of bounded directed
tree width. Following this initial proposal, several alternative
notions of width measures for sparse classes of digraphs have been
presented, for instance \emph{directed path width} (see
\cite{Barat06}, initially proposed by Robertson, Seymour and Thomas),
\emph{D-width}~\cite{Safari05},
\emph{DAG-width}~\cite{BerwangerDawHunKreObd12} and
\emph{Kelly-width}~\cite{HunterKre08}. 

In this work we concentrate on \dagw. It distinguishes itself in its
particularly simple definition. DAG decompositions have a clear
structure and the definition of the cops and robber games
characterising \dagw is a straight forward and natural generalisation
of the corresponding game for \tw. However, we show some disadvantages
of \dagw.






A crucial task in designing efficient algorithms for some problems on graphs where some
width is bounded is to find a decomposition of the given graph of
small width. Such decompositions, usually trees or DAGs (directed acyclic graphs), are used to
solve some problem recursively following the decomposition. For \tw and
\dtw one can decompose the graph in fixed parameter tractable
time. For \dw and for \kw such algorithms are not known, but there is
always a decomposition of polynomial size, so it can be found at least
 non-deterministically. 
Only the complexity of \dagw was left as an open problem
as it was not known whether every digraph has a decomposition of
polynomial size.

We show here that deciding the \dagw of a
digraph is not only not in \np (under standard complexity theoretical
assumptions), it is in fact \pspace-complete. In terms of the \dagw
game this exhibits the worst case complexity of such games. This
result is quite unexpected and especially surprising as such a high
complexity was to date only exhibited by a form of cops and robber
games called \emph{domination games} (see
\cite{FominKM03,FominGT11,KreutzerOrd09}). In these games, each cop
not only occupies his current vertex (as in other such games) but a whole neighbourhood of
fixed radius, which essentially allows to simulate set quantification
making the problem \pspace-complete.
The \dagw game, however, is to the best of our
knowledge the only cops and robber game with the usual
capturing condition that exhibits such a complexity.

With the same proof technique we also show that there are classes of
graphs for which any DAG decomposition of optimal width contains a
super-polynomial number of bags. (If \np\pspace, this would
follow from the previous result, but we show this unconditionally.)
Furthermore, we obtain that for every  there are
graphs of DAG-width~ with no polynomial size DAG decomposition
of width at most .



\section{DAG-Width and Cops and Robber Games}
\label{sec:prelims}

\subsection{Preliminaries}
We assume familiarity with basic concepts of graph theory and refer
to~\cite{Diestel12} for background.  All graphs in this paper are
finite, directed and simple, i.e.~they do not have loops or multiple
edges between the same pair of vertices. Undirected graphs are
directed graphs with a symmetric edge relation.  If~ is a graph,
then  is its set of vertices and  is its set of edges. For
a set  we write  for the subgraph of~
induced by~ and  for . If  is a set of
vertices, we write  to denote the set of vertices
reachable from a vertex in~. If , we write
. If , we also write  and 
for the irreflexive variant. A \emph{root} of a graph is a vertex
without incoming edges.
A strongly connected component of a digraph~ is a maximal
subgraph~ of~ which is strongly connected, \ie~between any pair
 there are directed paths from~ to~ and from~
to~. All components considered in this paper will be strong and
hence we simply write \emph{component}.  

\subsection{DAG-Width and Cops and Robber Games}
A \emph{DAG decomposition} of~ is a tuple  where  is a
DAG and  is a set of bags, \ie subsets of , such that
\begin{enumerate}
\item ,

\item for all , if , then ,

\item for every source , 
  where ,

\item for each , .
\end{enumerate}
The width of  is  and its size is . The 
\emph{DAG-width}  of~ is the
minimal width of a DAG decomposition of~.

\paragraph{Cops and Robber Games} \Dagw can be characterised by a cops and
robber game played on a graph~ by a team of cops and a robber. Each cop
occupies a vertex of~ or is outside of the graph. The robber occupies a
component of the graph that arises if we delete vertices occupied by the
cops. Hence, a game position can be described by a pair , where  is
the set of vertices occupied by cops and~ is robber component. At the
beginning the robber chooses an arbitrary component  of the graph and the
game starts at position . The game is played in rounds. In each
round, from a position  the cops first announce their next move, \ie~the
set  of vertices that they will occupy next, and remove the
cops from the vertices  that will not be occupied. Based on the
triple  the robber chooses his new component  that must be
reachable from  via cop free paths, \ie~a path reachable from  that does
not contain a vertex occupied by a cop which remains on the board.  This
completes a round and the play continues at position .

\paragraph{Abstract games}An \emph{abstract game} is a tuple  where  is a
directed graph, in which  denotes the set of all positions and 
the set of moves,  is the set of positions in which
Player~0 has to move,  is the start position and  is the winning condition. A \emph{play} is a maximal sequence  such that for all~, . Player~0 wins a play  if it is finite and ends in a vertex
 without successors (so Player~1 has
to move, but cannot do this) or . A (memoryless)
\emph{strategy} for Player~0 is a partial function  such
that for all  where  is defined, . Strategies for Player~1 are defined analogously. A play  is \emph{consistent} with  if for each  that
has a successor, we have . We say that~
is \emph{winning} if Player 0 wins every play consistent with~
(and analogously for Player~1). We say that a game position
is \emph{consistent} with~ if there is a play consistent
with~ which contains the position.

\paragraph{The \dagw game} 
The \emph{\dagw game}  on a
graph~ is defined as follows. The set of positions is  where 
 
are cop positions and 

are robber positions. The set of robber moves is defned by 

and the set of cop moves by 

where 
is the \emph{monotonicity condition} saying that while making a move, it is forbidden 
to remove cops if this allows the robber to reach vertices that were unreachable for him 
otherwise. 
The whole set of moves is . 
The start position is  and the winning
condition for the cops (\ie for Player~0) is
, \ie the cops lose all infinite plays. 
As the cops always have a possible move (\eg by not changing their vertices), 
they win all finite plays. 

A cop is \emph{free} in a position  if he is outside of the
graph (\ie  in the game with  cops) or on 
a vertex  such that , \ie 
removing this cop does not lead to non-monotonicity and is thus allowed. We say
that the robber is in some set  of vertices, if  is contained in his component.



In~\cite{BerwangerDawHunKreObd12} Berwanger et al.\@ showed that~
cops have a winning strategy~ on a graph if and only if the graph has a
DAG decomposition of width~. From their proof one can easily infur
a correspondence between the number of bags in the decomposition and
the number of possible positions in the game where the cops play
according to .

\begin{lemma}\label{lemma:decs_and_positions}
If there is a DAG decomposition of a graph  of width  and of
size , then~ cops have a winning strategy such that the number
of positions consistent with this strategy is at most~.
\end{lemma}
\begin{proof}
  Consider the strategy obtained from a DAG
  decomposition of width  as described in \cite[Theorem
  16]{BerwangerDawHunKreObd12}. In a play consistent with the strategy, the
  cops occupy only sets of vertices that correspond to some bag. Thus
  there are at most  cop placements that can appear in a play. A
  position can be described by the cop placement and  an arbitrary vertex in the robber
  component. There are at most  vertices, so the total number of
  positions is at most .
\end{proof}


\section{The Basic Construction}\label{sec:constr}

Let  be two non-decreasing
functions with  and let 
such that for all~ we have . We also demand that
for all ,  and  satisfy  and  , and,
furthermore, if  is bounded by a constant, then
. Notice that  depends only on  and , but not on~.

We define a class of graphs  of \dagw~ and size
 (measured in the number of vertices)
such that every DAG decomposition of width  has
super-polynomially many bags in the size of . The
parameters~ and  will be used to determine the difference
between the optimal width of a DAG decomposition and the best possible
width of a polynomial size decomposition. Our proof in the next section works already if
 for all~ and the reader is invited to assume
these values at first. We shall consider what changes if~ and~
are different later.

For , the graph  is a single
vertex without edges. For , the graph  is
constructed as follows (see Figure~\ref{fig:graph}).  Let  and  for
 be pairwise disjoint sets of vertices, each of
 elements. Let  be a set of~ elements disjoint from
all  and , and let . Let  be a set
of~ new vertices, and let  be a
set of~ new vertices.  The graph  has vertices

 We say that vertices from 
are in level~. If  and  are levels, then level~ is
\emph{bigger} than level  if .

For a set  let  be the set
. The edges are defined by

In other words, the first line says that  has all edges from
, and that , all~
for  and  are cliques of sizes~, 
and~, respectively (\ie every two distinct vertices are connected in both directions). Note also that  induces an independent set.


\begin{figure}
  \centering
  \begin{tikzpicture}[scale=0.8]
    \node[draw,circle,inner sep=5mm] (C_0) at (0,0){};
    \node[gray] at (0,-0.4){};

\node[draw,circle,minimum height=5mm,minimum width=10mm] (D) at (2.5,0){};
\draw (C_0) -- (D);

    \node[draw,circle,inner sep=5mm] (C_1) at (3,-3){};
    \node[gray] at (3,-3.4){};
      \node at (5,-3){};
    \node[draw,circle,inner sep=2.6mm] (C_t) at (7,-3){};
    \node[gray] at (7,-3.4){};
   \draw[-slim] (C_0) to (C_1);
   \draw[-slim] (C_0) to (C_t);
   \draw[-slim] (D) to (C_1);
   \draw[-slim] (D) to (C_t);
   \draw[-slim,bend right] (C_1) to (D);
   \draw[-slim,bend right] (C_t) to (D);

\node[draw,circle,minimum height=5mm,minimum width=10mm] (A) at (-3,-2){};
\draw[-slim] (A) to (C_0);

  \node[vertex] (b_1) at (-4,-5){};
    \node at (-3,-5){};
  \node[vertex] (b_t) at (-2,-5){};
    \node[draw,ellipse,minimum height=5mm,minimum width=30mm] (B) at
    (-3,-5){};
  \node at (-5.2,-5.7){};
  \draw (B) to (A);
  \draw[-slim,bend left=40] (C_1) to (b_1);
  \draw[-slim,bend left=40] (C_t) to (b_t);

   \node[draw,rectangle,minimum width=20mm,minimum height=15mm]
   (G_n-3) at (0,-3){};
   \draw[-slim] (C_0) to (G_n-3);
   \draw[-slim] (D) to (G_n-3);
   \draw            (A) to (G_n-3);
   \draw[-slim] (G_n-3) to (B);

   \node[draw,ellipse,minimum height=2.4cm,minimum width=5cm,opacity=0.5] (N) at
    (1,0){};
    \node at (1.3,1){};

  \end{tikzpicture}
  \caption{The construction of . Indices  are
    omitted. A directed edge between two subgraphs such as  and
     represents an edge from every vertex in  to every vertex
    in . An undirected edge represents edges in both directions.}
  \label{fig:graph}
\end{figure}

For the following lemma the precise definition of~ and  in
 is inessential.

\begin{lemma}
  \label{lemma:dagw}
The \dagw of  is  for .
\end{lemma}
\begin{proof}
  The  cops have the following winning strategy for the \dagw game on
  . The initial move of the robber must be to choose the whole graph
  as a component. Then the cops occupy  and we can assume that the
  robber chooses some  (for ) because
  all other strongly connected components of  have
  incoming edges from all~. (So the robber can go to every
  other component that is reachable now also later, see Lemma~5.21
  in~\cite{RabinovichPhD}.)  Then the remaining cop occupies
  . If the robber stays in , the cops from 
  capture him there (recall that  has the same size  as
  every , ). So we can assume that
  the robber goes to . 
  The cops from  move to  and
  force the robber to proceed to . If the robber
  remains in , he is captured in the next move. From now on,
  the  cops in  stay there until the end
  of the play and the robber cannot leave , which has
  outgoing edges only to  and to . The remaining  cops play in
   in the same way as on  until the
  robber is captured or expelled to a  for . There he
  will be captured in one move.

  A winning robber strategy against~ cops is to stay in 
  until all~ cops are there and then to go to . Due to
  the monotonicity of the winning condition, in that
  position of the game, no cop can be removed from his vertex as every
  vertex of  is reachable from every vertex of .
\end{proof}


\section{Big DAG Decompositions}\label{sec:bigdec}

In this section we prove that the described winning strategy for~
cops from Section~\ref{sec:constr}
(let
us call it~) is the only possible one up to some irrelevant
changes. Then we count the number of positions that are consistent
with~ and observe that there are super-polynomially many of
them. It will follow that every DAG decomposition of the optimal width
has a super-polynomial size.

The first kind of change is to occupy the vertices within the sets
,  (),  and  or
to remove cops from them in
a different order than according to~. The second kind of a change is to
place cops on and then to remove them from vertices that are already
unavailable for the robber. (Note that~ never lets cops stay
on such vertices.) Both changes can obviously only increase the number of
possible positions.

\begin{observation}\label{obs:irrelevant-changes}
Let  be as , but with some irrelevant changes applied.
Then  uses as many cops as  and there are at least as
many positions consistent with  as with~.
\end{observation}

\begin{lemma}\label{lemma:unique-sigma}
Up to irrelevant changes, there is only one winning strategy for 
cops on .
\end{lemma}
\begin{proof}
  We describe a family  of robber strategies that enforces the
  cops to play according to~ (the cops strategy from
  Lemma~\ref{lemma:decs_and_positions}) up to irrelevant changes. If
   cops play in a different way, they lose. By
  Observation~\ref{obs:irrelevant-changes} we can ignore those
  possible changes. The strategies in  differ only in the
  choice of components  (for all levels  and
  ) the robber visits during a play. Every
  choice is made independently of any other cop or robber move. Thus
   can be described as a set of strategies 
  parameterised by a sequence of choices
   (the indexes are the levels in
  decreasing order) where each  is in
  .

  Let some  be fixed.  The robber remains in  until it is completely
  occupied by cops. If a cop was placed on a vertex  before 
  was completely occupied, the cops lose. Indeed, consider the position where
  all vertices of  are occupied for the first time. Because~ (whatever
  it is) has been occupied and because it is still reachable now from ,
  the last -st cop is still on~, otherwise the monotonicity is
  violated at~. The robber goes to some  from which~ is reachable
  via paths avoiding  (such a  always exists) and the cops have no
  legal move. Thus the first moves of the cops are to occupy  and the last
  cop remains outside of the graph. (An irrelevant change can be made here:
   can also be occupied in many steps. However, this ends in the same
  position in that the whole  is occupied. The second kind of irrelevant
  changes cannot ber applied here.)

  The robber chooses some  and the cops have no other possible move
  than to place the last remaining cop on  (otherwise we have the
  situation discussed in the previous paragraph). The robber goes to
  . In this position, the cops in
   cannot be removed. So the cops from  must
  be used and they can be placed either in  or in ,
  or in , or in some . Placing the cops
  in  belongs to the second kind of irrelevant changes. In this case the
  robber component does not change, so after some number of such moves the cops
  have to play in a different way (or they lose). If at least one cop is placed
  in  or in , the robber
  remains in  until all cops are placed. Then the cops have no legal
  move and lose. It follows that the cops from  must occupy the whole
   (as above, regardless in which order) and the robber goes to
  . From now on, all cops occupying  and 
  will be reachable from the robber component and must stay there. It follows by
  induction on~ that~ is the unique winning strategy for  cops
  up to irrelevant changes.
\end{proof}

\begin{theorem}\label{thm:super-poly}
Every DAG decomposition of  of width  has
super-po\-ly\-no\-mial\-ly many bags.
\end{theorem}
\begin{proof}
We count the number of positions that are consistent
with~. When the robber goes to the level~, the cops are
occupying  for all levels  that appear as indices of
. Additionally, for each , the cops occupy exactly
one of . (If they occupy more
of them, the remaining cops do not suffice to capture the robber due
to Lemma~\ref{lemma:dagw}.)  Thus every  induces a new position and 
there are  possible positions with the robber in 
level~, each corresponding to a particular choice of  for
. By Lemma~\ref{lemma:decs_and_positions}, the number of bags in
  an DAG decomposition of optimal width is at least . We set  for all
 and . Then
. On the other hand the size of  is 

 so  is super-polynomial in
. 
\end{proof}


\section{Consider an Additive Constant Error}

In the simplest case we can set  for all
levels. Then we obtain at least  levels and the
size of an optimal decomposition is at least
.  However, at the cost of one additional
cop we can construct a DAG decomposition with polynomially many
bags. We change~ to occupy  with two cops instead of
placing one cop on . We need one extra cop for this, but this
is not repeated in each level. Already in the first level, when the
robber goes to , we have cops only
on , but not
on~. So one cop is saved for  and we can
continue to play in all levels in the same manner.

We can change our choice of~ and  to make the number of
additional cops needed to obtain a polynomial size decomposition
unbounded. Let  for
all~. Then there are at least  levels and

It remains to estimate the number of bags in an optimal
decomposition. Let  be the indices in 
appearing in , \ie , and for  we have . Then for ,  which is easy to prove by induction
on~. For all  we have 
 
and thus for ,
  So for  many levels  and thus the number
of bags in any DAG decomposition is at least .


We can define a winning cop strategy with only
polynomially many positions with the same trick as before investing
 new cops, \ie using  cops. Occupy  and when the
robber goes to some , occupy . The robber has to go to
the lower levels (otherwise he will be captured in
 or in ) and we do not need cops in
. In the following theorem we show that less than  cops
do not have a winning strategy with polynomially many positions. Thus
there is no polynomial approximation of an optimal DAG decomposition
by an additive constant.

\begin{theorem}
  For all  with , every DAG decomposition of width at most 
  has size at least .
\end{theorem}
\begin{proof}
  We describe a robber strategy against  cops that allows
  him to enforce at least  positions (dependent on his choices of
  ). The robber waits in  until it is occupied
  by~ cops and goes to some  for  such that 
  is not occupied by the cops. As  (recall that
  ) and only  cops are left, in all
   there is a cop free vertex. Similarly, the remaining~
  cops cannot occupy all  (there are  many of them), so going to such a  is
  possible. Now the cops in  cannot move,  free cops
  cannot expel the robber from  and the robber waits in
   for  to be occupied. When the cops announce to do
  this, he runs via  and  (which also has a free
  vertex) to  and plays there in the same
  way recursively.

  If the cops do not occupy all vertices in  when the robber
  is in the subgraph , they cannot use the cops
  from , so they cannot expel the robber from 
  (\ie  in the highest but one level). Indeed, 
  and there are at most  free
  cops (namely  cops are in  and~ cop is on
  ), so we only need to choose an appropriately large~, the
  least possible being~. Hence we can assume that the
  cops occupy all , \ie  cops are tied in level~ and
  there are at most  cops for
  .

  Let us count the number of possible positions that may appear in a
  play consistent with the described strategy of the robber. We first
  count the number of levels~ where the cops have more than one
  cop in . When playing according to~, which uses
   cops, exactly one cop is in each  and now we have
   cops more, so there are at least  levels  with
  . Then there are  levels  with at
  most  cops in each of them. In order to cover
   in each such level with  cops, we need
   times. As , we
  obtain . Summing
  up, there are  levels where the cops have to choose one
  among at least  placements depending of the robber's
  choice of the corresponding . Thus the size of any DAG
  decomposition of width at most  is at least . Recall that the size of  is polynomial in
   for .


\end{proof}

\begin{corollary}
There is no polynomial size approximation of an optimal DAG
decomposition of  with an additive constant error. 
\end{corollary}
 
\section{\dagw is \pspace-complete}
\label{sec:pspace}

The construction of  shows how the robber can save the history of the
play in the current position. In each level  he chooses one of the
, which is stored as a cop occupying  until the end of the
play. In the first step we extend the construction to reduce the \taut problem
to \DAGWprob (the problem, given a graph~ and a number~, is
?).  \taut is the problem, given a formula of propositional
logic, to decide whether it is satisfied by all variable interpretations. In
general, \taut is \conp-hard~\cite[Problem {[}LO8{]}]{GareyJoh79}, but in our
version the formula is given in CNF. This is a restriction, as CNF-\taut is in
\ptime, but we use it only as a part of our construction which proves that
\DAGWprob is \pspace-hard. Later we extend it to reduce QBF (which is
\pspace-complete) to \DAGWprob where CNF is the general case~\cite[Theorem
7.10]{GareyJoh79} and is more convenient for our purposes. For a technical
reason we also restrict the formulae by forbidding a variable to appear twice in
a clause.

Let  be a formula with~ variables and  clauses. The graphs 
are based on the graphs  from Section~\ref{sec:constr} such that
\begin{itemize}
\item (obviously) the number  of non-trivial levels in  is
  the number of variables in~,

\item  for all levels~.
\end{itemize}

It will be convenient to define functions that relate variables and levels.
Let the variables of~ be enumerated as , , \ldots, . Let 
 be a set of level numbers. Let  be the function mapping a level to an 
index of a variable such that  if and only if .

Consider  as a starting point. We replace 
(which is a single vertex) by the following gadget~. It has a vertex 
and for every clause  an -clique
 with vertices , , \ldots, . The edges go from
 to every vertex of  and back, \ie we have edges  and
 for all clauses  and all . 

From outside of , all vertices that had outgoing edges to the vertex of
 now have outgoing edges to all vertices of . So those
edges build the set  for
every level~. Additionally we have edges from every vertex of
 to every vertex of every , \ie the set of edges
 for every level~. 

Finally, the edges from  leaving  reflect the
clause~. For all levels~ we add the following edges.
\begin{enumerate}
\item If  does not appear in , then there are edges
   and  for all  from . 
\item If  for some~ (\ie  appears in 
  positively), then there is an edge .
\item If  (\ie  appears in  negatively), then there is
  an edge .
\end{enumerate}
\begin{observation}\label{obs:two-or-one}
By assumption, a variable can appear in a clause at most
once, so either it does not appear there at all, and we have two edges
from every vertex in the clique to the corresponding , or it appears once
and we have exactly one edge from the whole clique to .
\end{observation}

We claim that  cops capture the robber in  if and only if
 is a tautology. 
\begin{lemma}\label{lemma:in-F-phi}
  \begin{enumerate}
  \item If  cops win in , then they must play according
    to the strategy~ as in the proof of Lemma~\ref{lemma:dagw} until
    a first position  in that the robber component is .
  \item The cops can play according to~ until position 
    (also if the robber wins).
  \item In position  the only possible move for the cops is to occupy 
with the only free cop.
  \end{enumerate}
\end{lemma}
\begin{proof}
  The first two claims were proven in Lemma~\ref{lemma:dagw} and in
  Lemma~\ref{lemma:unique-sigma}. For the third claim, the only free
  cop is the one that would capture the robber on
 if we played on .
\end{proof}

The robber
chooses a component . Let the new position be .
\begin{lemma}\label{lemma:use_one_cop}
  In position ,  cops win if and only if there is a
  cop on a vertex  for some level  such that
  \begin{enumerate}
  \item  is not reachable from  (via cop free
    paths) and 
  \item  appears in .
  \end{enumerate}
\end{lemma}
\begin{proof}
  Let  be some position as described above. If the cops
  win, in~ a cop is free  and
  the cops occupy all  (in all levels) and, in each level
  , one of the two vertices  and . The
  free cop is placed on  in  (there is no other legal move
  that cops occupy a vertex in  which does not lead to an immediate loss for the cops)
  and the robber chooses some  for a clause
  . Let  be the variable in
  the literal . Now for all levels  no cops from any
   can be removed and reused as this would violate the
  monotonicity: there are edges from all vertices of  to all
  vertices of all . The cops from every level  such
  that  does not appear in  cannot be removed for
  the same reason. Thus only cops from  can
  potentially be reused. If no cop from any  can be reused,
  the robber wins, otherwise the cops win as follows. Let this cop be
  in level  and assume without loss of generality that
  . The cop is placed on , then the cop from
   is placed on . Now the cop from
   is placed on  and so on, the last cop
  occupying .

  To see that  must appear in , note that otherwise the cop
  from  cannot be removed due to the monotonicity condition.
\end{proof}


\begin{lemma}\label{lemma:tautology}
   cops win on  if and only if  is a tautology.
\end{lemma} 
\begin{proof}
  Assume that  is true under every valuation. The cops have the following
  winning strategy. Until the robber component is  they play as
  described in Lemma~\ref{lemma:dagw}. Then by Lemma~\ref{lemma:in-F-phi} they
  have a free cop that is placed no . The robber chooses some
  clique  for a clause .

  Let, without loss of generality,  be the set
  of indices~ of  appearing in . Let
   be the valuation of those
   defined by the choices of the robber during the previous part
  of the play as follows. For all levels~, if  appears in
   and the robber chose the component  in level  (for
  ), then  if  and
   if . Let  be a valuation of
   extending . By assumption , so
   and thus there is some  in  with .
  Let  be such that  or 
  (we have ). If , then
   and thus the robber chose
   in level~. Then a cop occupies  in the current
  position. As  occurs in  positively, there is an edge from
   to  and by Observation~\ref{obs:two-or-one}, there is no edge
  from  to . The cop from  can be reused and the cops
  win by Lemma~\ref{lemma:in-F-phi}. If , the situation is symmetric.

  If  is not a tautology, let  be a valuation with
  . The robber winning strategy is to choose in level
   the component  if  and the
  component  otherwise. When the cops occupy , the robber chooses
  the clique  corresponding a clause  with
  . Then  for all
  . Let  be the variable in . If
  , then there is an edge from  to . As
  , the robber chose , so there is
  a cop on , which cannot be removed. By
  Observation~\ref{obs:two-or-one} there is no other cop in
  . 

  By Lemma~\ref{lemma:use_one_cop} the cops from levels corresponding to
  variables that do not occur in  cannot be reused. Thus all cops in all
   is still reachable from the robber component and the cops lose.
\end{proof}

We extend our construction again to model choices of the cops that are still
recognisable at the end of the play. This leads to a reduction from \QBF, which
is \pspace-complete, to \DAGWprob. A \emph{quantified boolean formula}  is
of the form  where  is
either  or  and  is a propositional formula in CNF with
variables from .

The semantics of  can be defined by means of a two-player game
with perfect information, which is convenient for our reduction. It is
the model-checking game  for  on the fixed structure
 with no relations. The
players are called  (the universal player) and  (the
existential player). A play is played as follows. First, the
quantifier prefix of the formula is read from left to right and, for
, player  chooses a value
 for . In other words, we have
positions~ of the form

where  means that we replace all occurrences of
 in  by . If , then~
is a position of the universal player, otherwise  belongs to the
existential player. Successor positions have the form 


The remaining positions of the game are of the form 
where  is a subformula of~ and  is the valuation
of the variables as chosen in the first part of the play. The second part
starts in position .  If ,
the existential player moves to  or to 
and if , then the universal player moves
to  or to . In positions
, the existential player wins if  and
loses of . In positions , the
universal player wins if  and loses if . The formula  is true if and only of the existential player has a
winning strategy in the game.

It is very well known that deciding whether a given quantified formula
is true is \pspace-complete. 

The rest of the section is devoted to proof of the following theorem.

\begin{theorem}\label{thm:dagw-pspace-c}
 \DAGWprob is \pspace-complete.
\end{theorem}
The easier part is to show that \DAGWprob is in \pspace. It suffices to prove
that any play in the cops and robber game has polynomial length. Then deciding
the winner of the game is in \aptime (alternating \ptime) and thus in
\pspace. If~ cops have a winning strategy on a graph, they also have a
winning strategy that always prescribes to place cops in a way that the space
available for the robber shrinks by at least one vertex. We consider a version
of the game where the cops \emph{have} to play in this manner. Then they win if
and only if they win in at most~ moves where~ is the number of vertices
of the graph (the robber can also make  moves). Thus any play lasts at most  steps.

For the hardness we reduce \QBF to \DAGWprob. Let  be a quantified
boolean formula. Our construction of the graph  extends the
construction of . For every universal
quantifier we add a new level as in~. For each existential quantifier we add a
level that is depicted in Figure~\ref{fig:existential}. The only
difference to a universal level is that we replace edges from
 to  by paths of length two which share the middle
vertex . We now give a formal
description of the reduction.


\begin{figure}
  \centering
  \begin{tikzpicture}[scale=0.9]
    \node[draw,circle,inner sep=5mm] (C_0) at (0,0){};
    \node[gray] at (0,-0.4){};

\node[draw,circle,minimum height=5mm,minimum width=10mm] (D) at 
(2.5,0){};
\draw (C_0) -- (D);

    \node[draw,circle,inner sep=5mm] (C_1) at (3,-3){};
    \node[gray] at (3,-3.4){};
\node[draw,circle,inner sep=5mm] (C_t) at (6,-3){};
    \node[gray] at (6,-3.4){};
\node[vertex] (c_1) at (2,-1.5){};
\node at (1.8,-1.8){};
\node[vertex] (c_t) at (5,-1.5){};
\node at (4.8,-1.8){};

\draw[-slim] (C_0) to (c_1);
\draw[-slim] (c_1) to (C_1);
\draw[-slim] (D) to (c_1);

\draw[-slim] (C_0) to (c_t);
\draw[-slim] (c_t) to (C_t);
\draw[-slim] (D) to (c_t);



   \draw[-slim,bend right] (C_1) to (D);
   \draw[-slim,bend right] (C_t) to (D);

\node[draw,circle,minimum height=5mm,minimum width=10mm] (A) at 
(-3,-2){};
\draw[-slim] (A) to (C_0);

  \node[vertex] (b_1) at (-4,-5){};
\node[vertex] (b_t) at (-2,-5){};
    \node[draw,ellipse,minimum height=5mm,minimum width=30mm] (B) at
    (-3,-5){};
  \node at (-4.9,-5.5){};
  \draw (B) to (A);
  \draw[-slim,bend left=40] (C_1) to (b_1);
  \draw[-slim,bend left=40] (C_t) to (b_t);

   \node[draw,rectangle,minimum width=20mm,minimum height=15mm]
   (G_n-3) at (0,-3){};
   \draw[-slim] (C_0) to (G_n-3);
   \draw[-slim,bend right] (D) to (G_n-3);
   \draw            (A) to (G_n-3);
   \draw[-slim] (G_n-3) to (B);



  \end{tikzpicture}
  \caption{The existential level of . Indices  are omitted.}
  \label{fig:existential}
\end{figure}

If  has no variables, then if  is true,  is a single 
vertex, and if  is false,  is a 2-clique. (So one cop wins if and 
only if  is true.) Otherwise we start the construction of  with 
 and for  we construct graphs  
such that . Assume that  is already 
constructed, then  is the following graph. There are two cases. If 
, then the vertex set is 
 
Here  and  
are as , ,  and  in , \ie  for 
all  and . Furthermore, . Analogously to the graphs  we call the set of vertices
  an \emph{existential level.}

The set of edges is

Here , the edges connecting  to the new level are
defined as follows. Let  be a
clique in  corresponding to a clause . If , then . If , then . Otherwise (\ie if  does not
appear in )  for all .

In the second case . Then  and the edges are defined as in 
. We call the set of the new vertices a \emph{universal level.} 

We are going to show that  cops win on  if and only if the 
existential player wins . For that we need some 
lemmata. Our global assumption is that there are  cops in total.

Let  be the
set of level numbers and let  be a tuple of
bits. (Recall that the levels are numbered such that the biggest is in
, but not in .) Define





The first lemma states what the cops can achieve in an existential level.

\begin{lemma}\label{lemma:cops_invariant}
  Let  be the number of an existential level.  Let the cops occupy
   for some bit vector  and let the robber component be
  .  For both  the cops have a strategy that allows
  them either to capture the robber or to expel him from level~ such that
  the cops occupy precisely .
\end{lemma}
\begin{proof}
  Note that all cops in  are all tied and there are  free
  cops.  The strategy is as follows. One cop is placed on . This
  creates two components of : the one induced by  and
  the one induced by , , ,  and
  . If the robber is in , the remaining free cops
  expel him from there and the robber is in the other component. Then the cops
  occupy  and then the cop from  occupies
  . If the robber is in  and stays there, he is captured
  there by the cops from , so assume that the robber goes either to the
  component induced by  or to the component induced by 
  and . In any case the cops leave  and occupy
  . If the robber remains in , he is captured by the cop
  from , so assume that he goes to . We obtain the
  required position.
\end{proof}

The following lemma describes what the robber can achieve in a level.

\begin{lemma}\label{lemma:robber_invariant}
  Let  be the number of a level.  Let the cops occupy
   for some bit vector  and let the robber component be
  . The robber has a strategy that permits him either to win or
  to reach a position where the robber is in  and the cops
  occupy ,  and at least one of . If the level is
  universal, the robber can additionally enforce  or . Furthermore,
  this robber strategy is winning if there are only  free cops.
\end{lemma}
\begin{proof}
  Again, all cops in  are all tied and there are  free cops.
  The robber stays in  until it is completely occupied by the cops. In
  that position, one of  is not occupied by cops, and the robber runs
  to  and plays as in the proof of
  Theorem~\ref{thm:super-poly}. Note that the cops from  and from
   for all  cannot be removed.
\end{proof}


\begin{lemma}
  There is a winning strategy for  cops on  if and only if
   is true.
\end{lemma}
\begin{proof}
  Assume that~ cops have a winning strategy~ on~. Without
  loss of generality we assume that one cop is placed in  in every
  level , even if not enforced by the robber. In , the
  existential player simulates the cops and robber game on  by
  translating the moves of the universal player into robber moves and
  translating cop moves (according to~) into his choices of the
  existentially quantified variables. Assume that we reached a position~ in
  the cops and robber game and a position  (for ) in the
   such that the following invariant (INV) holds.
\begin{itemize}
 \item Exactly the values  for the variables  where 
 are already chosen;

\item in the cops and robber game, the robber component is  with
  the biggest level number ;

\item the cops occupy  for the tuple  and nothing else. 
\end{itemize}
Then there are exactly  free cops. If , the
universal player chooses a value  for . Then
the existential player simulates the cops and robber game playing for
the cops according to~ from position~ and for the robber as in
Lemma~\ref{lemma:robber_invariant} such that the robber is expelled
from level  and  and  are occupied by cops. The number of
free cops suffices for that. It is straightforeward to check that the
above invariant holds for  and for the position of the cops and
robber game where the robber is blocked in the next level, \ie in level~.

If , the existential player simulates the cops and robber 
game from~ until the robber is expelled from level~ according to 
Lemma~\ref{lemma:cops_invariant}. Here, the cops play according
to~ and the robber plays arbitrarily, but such that he is not
captured in level~. For example, the robber goes directly to
. Again, there are enough free cops for 
the simulation. Then exactly one of  and  is  occupied
by a cop. If it is , the existential player sets , 
otherwise . Again, the invariant holds.

When all variables have their values, the universal player chooses a
clause~ and the existential player simulates in the cops and robber
game the move of the free cop to vertex~ in  and the move
of the robber to~. 

Let us revise the current position. As the cops have played according to~
and~ is a winning strategy, there is still a free cop. The cops completely 
occupy every  and for all
 exactly one of  and . Every vertex in all
 and  are still reachable from the robber component, so the free cop
is in some . As the cop is free, there is no edge from any
 to , \ie there is the edge from some  to
. By construction of ,  appears
in~ and if , then  is negativ and if , then
 is positiv in~. In the first case  and
, so~ is satisfied and the existential
player wins by choosing . The second case is
symmetric.

For the other direction assume that the existential player has a winning 
strategy. We show that~ cops have a winning strategy. The cops simulate 
the game  while playing on  by translating the moves of 
the 
robber to choices of the universal player and the choices of the existential 
player to their moves. Assume as before that (INV) holds for
some~.

There are two cases: level~ is either existential or universal. In any
case, there are  free cops and if the level is universal,~ of
them occupy . The robber escapes to some  for an
 or goes to the component consisting of ,  and
. If the robber is in  the last remaining cop is
placed on  and the robber proceeds to
, otherwise the cop is
placed on  and the robber is in
. Now the cops from 
occupy  and the robber goes to  (if he goes to the
component induced by the free vertex of , he loses
immediately). Finally, the cops simulate the choice of the universal player:
. It is easy to see that the invariant holds.

If the level is existential, the cops look up what value the strategy for the 
existential player in  prescribes to choose for 
: . Then according to 
Lemma~\ref{lemma:cops_invariant} the cops can play such that the invariant 
holds again.

When the play arrives , there is one free cop that is placed on~ and 
the robber goes to some  for a clause~. As the existential player has a 
winning strategy, there is some literal  in~ that is satisfied 
by~. Without loss of generality,  and . Then 
 is occupied by a cop, but there is no edge from~ to 
. Recall that in  every variable appears at most once, so 
there is no edge from~ to  and the cop from  is 
free. The cops win by Lemma~\ref{lemma:use_one_cop}.
\end{proof}



\section{Conclusion}
We showed that \dagw cannot be computed efficiently in the classical
sense (assuming \ptime\pspace).  It would be interesting to
find (fixed-parameter tractable) algorithms computing constant factor
approximations of an optimal DAG decomposition. Another approach to
\dagw would be to show that \dagw and \kw are bounded in each other,
as deciding \kw is in \nptime. It is known that \dagw is
bounded in \kw by a quadratic function~\cite{KaiserKreRabSie14}.


\section*{References}
\bibliographystyle{elsarticle-harv}
\bibliography{bibl}

































\end{document}
