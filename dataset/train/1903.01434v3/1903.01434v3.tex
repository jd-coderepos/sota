\documentclass{article} \usepackage{iclr2020_conference,times}
\definecolor{navy}{HTML}{2F729C} 
\usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{siunitx}
\usepackage{comment}

\usepackage[T1]{fontenc}
\usepackage[font=small,labelfont=bf,tableposition=top]{caption}

\DeclareCaptionLabelFormat{andtable}{#1~#2  \&  \tablename~\thetable}

\usepackage{blindtext}
\usepackage{longtable}
\usepackage{todonotes}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{hyperref}
 \hypersetup{
     colorlinks=true,
     allcolors=black,
     urlcolor=navy,
     }
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{comment}
\usepackage{csquotes}
\usepackage[framemethod=tikz]{mdframed}
\usepackage{mathtools}

\usepackage{appendix}
\usepackage{wrapfig}
\usepackage{chngcntr}
\usepackage{etoolbox}

\usepackage[ruled]{algorithm2e}
\usepackage{algpseudocode}

\usepackage{lettrine}

\usepackage{tabularx}

\usepackage{listings}
\usepackage{color}





\newcommand{\durk}[1]{{\textcolor{green}{[#1]}}}
\newcommand{\manoj}[1]{{\textcolor{red}{[#1]}}}

\newcommand{\bb}[1]{\mathbf{#1}}
\newcommand{\bbb}{\bb{b}}
\newcommand{\ba}{\bb{a}}
\newcommand{\bx}{\bb{x}}
\newcommand{\bxi}{\bx^{(i)}}
\newcommand{\bxl}{\bx^{(l)}}
\newcommand{\bt}{\bb{t}}
\newcommand{\by}{\bb{y}}
\newcommand{\bv}{\bb{v}}
\newcommand{\bw}{\bb{w}}
\newcommand{\bW}{\bb{W}}
\newcommand{\bc}{\bb{c}}
\newcommand{\bd}{\bb{d}}
\newcommand{\bg}{\bb{g}}
\newcommand{\bh}{\bb{h}}
\newcommand{\br}{\bb{r}}
\newcommand{\bu}{\bb{u}}
\newcommand{\bp}{\bb{p}}
\newcommand{\byl}{\by^{(l)}}
\newcommand{\bz}{\bb{z}}
\newcommand{\bzi}{\bz^{(i)}}
\newcommand{\bzl}{\bz^{(l)}}
\newcommand{\bzil}{\bz^{(i,l)}}
\newcommand{\bpa}{\bb{pa}}
\newcommand{\bbf}{\bb{f}}

\newcommand{\bT}{\boldsymbol{\theta}}
\newcommand{\bTl}{\boldsymbol{\theta}^{(l)}}
\newcommand{\boldeta}{\boldsymbol{\eta}}
\newcommand{\balpha}{\boldsymbol{\alpha}}
\newcommand{\bphi}{\boldsymbol{\phi}}
\newcommand{\beps}{\boldsymbol{\epsilon}}
\newcommand{\bepsilon}{\boldsymbol{\epsilon}}
\newcommand{\bepsl}{\beps^{(l)}}
\newcommand{\bepsil}{\beps^{(i,l)}}
\newcommand{\bzeta}{\boldsymbol{\zeta}}
\newcommand{\bzetal}{\zeta^{(l)}}
\newcommand{\bsigma}{\boldsymbol{\sigma}}
\newcommand{\bmu}{\boldsymbol{\mu}}
\newcommand{\bzero}{\bb{0}}
\newcommand{\bs}{\mathbf{s}}
\newcommand{\bmm}{\mathbf{m}}

\newcommand{\btPa}{\widetilde{\bb{Pa}}}
\newcommand{\btpa}{\widetilde{\bb{pa}}}

\newcommand{\tz}{\widetilde{z}}
\newcommand{\tZ}{\widetilde{Z}}
\newcommand{\tf}{\widetilde{f}}
\newcommand{\btZ}{\widetilde{\bb{Z}}}
\newcommand{\btz}{\widetilde{\bz}}
\newcommand{\btT}{\widetilde{\bT}}
\newcommand{\tPa}{\widetilde{Pa}}

\newcommand{\pT}{p_{\bT}}
\newcommand{\pTl}{p_{\bT^{(l)}}}
\newcommand{\pA}{p_{\balpha}}
\newcommand{\qT}{q_{\bT}}
\newcommand{\qPhi}{q_{\bphi}}
\newcommand{\qP}{q_{\bphi}}
\newcommand{\qD}{q_\mathcal{D}}
\newcommand{\qDP}{q_{\mathcal{D},\bphi}}
\newcommand{\fT}{\bbf_{\bT}}
\newcommand{\gT}{\bg_{\bT}}
\newcommand{\fPhi}{f_{\bphi}}
\newcommand{\fTPhi}{\bbf_{\bT,\bphi}}
\newcommand{\gPhi}{g_{\bphi}}
\newcommand{\hPhi}{h_{\bphi}}
\newcommand{\rPhi}{r_{\bphi}}
\newcommand{\figref}[1]{\figurename~\ref{#1}}

\usepackage{hyperref}
\usepackage{url}


\title{VideoFlow: A Conditional Flow-Based Model for Stochastic Video Generation}






\author{Manoj Kumar\thanks{A majority of this work was done as part of the Google AI Residency Program.} , Mohammad Babaeizadeh, Dumitru Erhan, \\
\textbf{Chelsea Finn, Sergey Levine, Laurent Dinh, Durk Kingma} \\
Google Research, Brain Team \\
\texttt{\{mechcoder,mbz,dumitru,chelseaf,slevine,laurentdinh,durk\}@google.com} \\
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}
Generative models that can model and predict
sequences of future events can, in principle, learn to capture complex real-world phenomena, such as physical interactions. However, a central challenge in video prediction is that the future is highly uncertain: a sequence of past observations of events can imply many possible futures. Although a number of recent works have studied probabilistic models that can represent uncertain futures, such models are either extremely expensive computationally as in the case of pixel-level autoregressive models, or do not directly optimize the likelihood of the data. To our knowledge, our work is the first to propose multi-frame video prediction with normalizing flows, which allows for direct optimization of the data likelihood, and produces high-quality stochastic predictions. We describe an approach for modeling the latent space dynamics, and demonstrate that flow-based generative models offer a viable and competitive approach to generative modeling of video.
\end{abstract}

\section{Introduction}

Exponential progress in the capabilities of computational hardware, paired with a relentless effort towards greater insights and better methods, has pushed the field of machine learning from relative obscurity into the mainstream. Progress in the field has translated to improvements in various capabilities, such as classification of images~\citep{krizhevsky2012imagenet}, machine translation~\citep{vaswani2017attention} and super-human game-playing agents~\citep{mnih2013playing,silver2017mastering}, among others. However, the application of machine learning technology has been largely constrained to situations where large amounts of supervision is available, such as in image classification or machine translation, or where highly accurate simulations of the environment are available to the learning agent, such as in game-playing agents. An appealing alternative to supervised learning is to utilize large unlabeled datasets, combined with predictive generative models. In order for a complex generative model to be able to effectively predict future events, it must build up an internal representation of the world. For example, a predictive generative model that can predict future frames in a video would need to model complex real-world phenomena, such as physical interactions. This provides an appealing mechanism for building models that have a rich understanding of the physical world, without any labeled examples. Videos of real-world interactions are plentiful and readily available, and a large generative model can be trained on large unlabeled datasets containing many video sequences, thereby learning about a wide range of real-world phenoma. Such a model could be useful for learning representations for further downstream tasks~\citep{mathieu2015deep}, or could even be used directly in applications where predicting the future enables effective decision making and control, such as robotics~\citep{finn2016unsupervised}. A central challenge in video prediction is that the future is highly uncertain: a short sequence of observations of the present can imply many possible futures. Although a number of recent works have studied probabilistic models that can represent uncertain futures, such models are either extremely expensive computationally (as in the case of pixel-level autoregressive models), or do not directly optimize the likelihood of the data.

In this paper, we study the problem of stochastic prediction, focusing specifically on the case of conditional video prediction: synthesizing raw RGB video frames conditioned on a short context of past observations~\citep{ranzato2014video, srivastava2015unsupervised,vondrick2015anticipating,xingjian2015convolutional,boots2014learning}. Specifically, we propose a new class of video prediction models that can provide exact likelihoods, generate diverse stochastic futures, and accurately synthesize realistic and high-quality video frames. The main idea behind our approach is to extend flow-based generative models~\citep{dinh2014nice,dinh2016density} into the setting of conditional video prediction. To our knowledge, flow-based models have been applied only to generation of non-temporal data, such as images~\citep{kingma2018glow}, and to audio sequences~\citep{waveglow2018}. Conditional generation of videos presents its own unique challenges: the high dimensionality of video sequences makes them difficult to model as individual datapoints. Instead, we learn a latent dynamical system model that predicts future values of the flow model's latent state. This induces Markovian dynamics on the latent state of the system, replacing the standard unconditional prior distribution. We further describe a practically applicable architecture for flow-based video prediction models, inspired by the Glow model for image generation~\citep{kingma2018glow}, which we call VideoFlow.

Our empirical results show that VideoFlow achieves results that are competitive with the state-of-the-art in stochastic video prediction on the action-free BAIR dataset, with quantitative results that rival the best VAE-based models. VideoFlow also produces excellent qualitative results, and avoids many of the common artifacts of models that use pixel-level mean-squared-error for training (e.g., blurry predictions), without the challenges associated with training adversarial models. Compared to models based on pixel-level autoregressive prediction, VideoFlow achieves substantially faster test-time image synthesis \footnote{We generate 64x64 videos of 20 frames in less than 3.5 seconds on a NVIDIA P100 GPU as compared to the fastest autoregressive model for video~\citep{reed2017parallel} that generates a frame every 3 seconds}, making it much more practical for applications that require real-time prediction, such as robotic control~\citep{finn2017deep}. Finally, since VideoFlow directly optimizes the likelihood of training videos, without relying on a variational lower bound, we can evaluate its performance directly in terms of likelihood values.

\section{Related Work}
\label{related}



Early work on prediction of future video frames focused on deterministic predictive models~\citep{ranzato2014video, srivastava2015unsupervised,vondrick2015anticipating,xingjian2015convolutional,boots2014learning}. Much of this research on deterministic models focused on architectural changes, such as predicting high-level structure \citep{villegas2017learning}, energy-based models \citep{Xie_2017_CVPR}, generative cooperative nets \citep{Xie_2020}, ABPTT \citep{Xie_2019}, incorporating pixel transformations~\citep{finn2016unsupervised,de2016dynamic,liu2017video} and predictive coding architectures~\citep{prednet}, as well as different generation objectives~\citep{mathieu2015deep,vondrick2017generating,optical_flow_pred} and disentangling representations \citep{villegas2017decomposing,denton2017unsupervised}.
With models that can successfully model many deterministic environments, the next key challenge is to address stochastic environments by building models that can effectively reason over uncertain futures.
Real-world videos are always somewhat stochastic, either due to events that are inherently random, or events that are caused by unobserved or partially observable factors, such as off-screen events, humans and animals with unknown intentions, and objects with unknown physical properties. In such cases, since deterministic models can only generate one future, these models either disregard potential futures or produce blurry predictions that are the superposition or averages of possible futures.

A variety of methods have sought to overcome this challenge by incorporating stochasticity, via three types of approaches: models based on variational auto-encoders (VAEs)~\citep{kingma2013auto,rezende2014stochastic}, generative adversarial networks~\citep{goodfellow2014generative}, and autoregressive models~\citep{hochreiter1997long,graves2013generating,pixelrnn,oord2016conditional,van2016wavenet}.

Among these models, techniques based on variational autoencoders which optimize an evidence lower bound on the log-likelihood have been explored most widely~\citep{babaeizadeh2017stochastic,denton2018stochastic,lee2018stochastic,xue2016visual,li2018flow}. To our knowledge, the only prior class of video prediction models that directly maximize the log-likelihood of the data are auto-regressive models~\citep{hochreiter1997long,graves2013generating,pixelrnn,oord2016conditional,van2016wavenet}, that generate the video one pixel at a time~\citep{kalchbrenner2016video}. However, synthesis with such models is typically inherently sequential, making synthesis substantially inefficient on modern parallel hardware. Prior work has aimed to speed up training and synthesis with such auto-regressive models~\citep{reed2017parallel,ramachandran2017fast}. However, \citep{babaeizadeh2017stochastic} show
that the predictions from these models are sharp but noisy
and that the proposed VAE model produces substantially
better predictions, especially for longer horizons. In contrast to autoregressive models, we find that our proposed method exhibits faster sampling, while still directly optimizing the log-likelihood and producing high-quality long-term predictions.

\section{Preliminaries: Flow-Based Generative Models}
\label{sec:prelim}



\emph{Flow-based generative models}~\citep{dinh2014nice,dinh2016density} have a unique set of advantages: exact latent-variable inference, exact log-likelihood evaluation, and parallel sampling. In \emph{flow-based generative models}~\citep{dinh2014nice,dinh2016density}, we infer the latent variable  corresponding to a datapoint , by transforming  through a composition of invertible functions . We assume a tractable prior  over latent variable , for eg. a Logistic or a Gaussian distribution. By constraining the transformations to be invertible, we can compute the log-likelihood of  exactly using the \emph{change of variables} rule. Formally,



where , ,  and  is the Jacobian determinant when  is transformed to  by . We learn the parameters of  by maximizing the log-likelihood, i.e Equation \eqref{eq:loglike2}, over a training set. Given , we can now generate a sample  from the data distribution, by sampling  and 
computing .

\section{Proposed Architecture}
\label{video-glow}



We propose a generative flow for video, using the standard multi-scale flow architecture in \citep{dinh2016density,kingma2018glow} as a building block. In our model, we break up the latent space  into separate latent variables per timestep: . The latent variable  at timestep  is an invertible transformation of a corresponding frame of video: . Furthermore, like in \citep{dinh2016density,kingma2018glow}, we use a multi-scale architecture for  (Fig.~\ref{fig:cond_flow}): the latent variable  is composed of a stack of multiple levels: where each level  encodes information about frame  at a particular scale:  , one component  per level.

\begin{figure*}
\centering
\begin{tabular}{cc}

\includegraphics[width=0.45\textwidth,height=0.1\textheight]{levels.pdf} & \includegraphics[width=0.35\textwidth,height=0.2\textheight]{generative_time.pdf} \\
\end{tabular}

\caption{\textbf{Left: Multi-scale prior} The flow model uses a multi-scale architecture using several levels of stochastic variables. \textbf{Right: Autoregressive latent-dynamic prior} The input at each timestep  is encoded into multiple levels of stochastic variables . We model those levels through a sequential process .}
\label{fig:cond_flow}
\end{figure*}

\subsection{Invertible multi-scale architecture}

We first briefly describe the invertible transformations used in the multi-scale architecture to infer  and refer to \citep{dinh2016density,kingma2018glow} for more details. For convenience, we omit the subscript  in this subsection. We choose invertible transformations whose Jacobian determinant in Equation \ref{eq:loglike2} is simple to compute, that is a triangular matrix, diagonal matrix or a permutation matrix as explored in prior work \citep{rezende2015variational,deco1995higher}. For permutation matrices, the Jacobian determinant is one
and for triangular and diagonal Jacobian matrices, the determinant is simply the product of diagonal terms.

\begin{itemize}
\item{Actnorm: We apply a learnable per-channel scale and shift with data-dependent initialization.}
\item{Coupling: We split the input  equally across channels to obtain  and . We compute  where  and  are deep networks. We concat  and  across channels.}
\item{SoftPermute: We apply a 1x1 convolution that preserves the number of channels.}
\item{Squeeze: We reshape the input from  to  which allows the flow to operate on a larger receptive field.}
\end{itemize}

We infer the latent variable  at level  using:


where  is the number of steps of flow. In Equation \eqref{eq:split}, via Split, we split the output of Flow equally across channels into , the input to Flow\textsubscript{(l+1)}(.) and , the latent variable at level . We, thus enable the flows at higher levels to operate on a lower number of dimensions and larger scales. When ,  is just the input frame  and for  we omit the Split operation. Finally, our multi-scale architecture  is a composition of the flows at multiple levels from  from which we obtain our latent variables i.e .


\subsection{Autoregressive latent dynamics model}

We use the multi-scale architecture described above to infer the set of corresponding latent variables for each individual frame of the video:
; see Figure~\ref{fig:cond_flow} for an illustration. As in Equation~\eqref{eq:loglike2}, we need to choose a form of latent prior . We use the following autoregressive factorization for the latent prior:

where  denotes the latent variables of frames prior to the -th timestep: . We specify the conditional prior  as having the following factorization:

where  is the set of latent variables at previous timesteps and at the same level , while  is the set of latent variables at the same timestep and at higher levels. See Figure \ref{fig:cond_flow} for a graphical illustration of the dependencies. 

We let each  be a conditionally factorized Gaussian density:

where  is a deep 3-D residual network \citep{he2015deep} augmented with dilations and gated activation units and modified to predict the mean and log-scale. We describe the architecture and our ablations of the architecture in Section \ref{sec:res_net_arch} and \ref{sec:ablations} of the appendix.

In summary, the log-likelhood objective of Equation \eqref{eq:loglike2} has two parts. The invertible multi-scale architecture contributes  via the sum of the log Jacobian determinants of the invertible transformations mapping the video  to ; the latent dynamics model contributes , i.e Equation \eqref{eq:prior}. We jointly learn the parameters of the multi-scale architecture and latent dynamics model by maximizing this objective.

Note that in our architecture we have chosen to let the prior , as described in eq.~\eqref{eq:prior}, model temporal dependencies in the data, while constraining the flow  to act on separate frames of video. We have experimented with using 3-D convolutional flows, but found this to be computationally overly expensive compared to an autoregressive prior; in terms of both number of operations and number of parameters. Further, due to memory limits, we found it only feasible to perform SGD with a small number of sequential frames per gradient step. In case of 3-D convolutions, this would make the temporal dimension considerably smaller during training than during synthesis; this would change the model's input distribution between training and synthesis, which often leads to various temporal artifacts. Using 2-D convolutions in our flow  with autoregressive priors, allows us to synthesize arbitrarily long sequences without introducing such artifacts. 


\section{Experiments}

All our generated videos and qualitative results can be viewed at \href{https://sites.google.com/corp/view/videoflow/home}{this website}. In the generated videos, a border of blue represents the conditioning frame, while a border of red represents the generated frames.


\subsection{Video modelling with the Stochastic Movement Dataset}


\begin{table}
	\begin{minipage}{0.5\linewidth}
		\centering
		\begin{tabular}{c c c}
		    \hline
			Model & Fooling rate \\
			\hline\hline
			SAVP-VAE & 16.4 \% \\
			VideoFlow & \textbf{31.8 \%} \\
			SV2P & 17.5 \% \\
			\hline
		\end{tabular}
		\caption{We compare the realism of the generated trajectories using a real-vs-fake 2AFC Amazon Mechanical Turk with SAVP-VAE and SV2P.}
	\end{minipage}\hfill
	\begin{minipage}{0.45\linewidth}
		\centering
		\includegraphics[width=40mm]{ss_shapes}
		\captionof{figure}{We condition the VideoFlow model with the frame at t = 1 and display generated trajectories at t = 2 and t = 3 for three different shapes.}
	\end{minipage}
\label{tab:ss_shapes}
\end{table}

We use VideoFlow to model the Stochastic Movement Dataset used in \citep{babaeizadeh2017stochastic}. The first frame of every video consists of a shape placed near the center of a 64x64x3 resolution gray background with its type, size and color randomly sampled. The shape then randomly moves in one of eight directions with constant speed. \citep{babaeizadeh2017stochastic} show that conditioned on the first frame, a deterministic model averages out all eight possible directions in pixel space. Since the shape moves with a uniform speed, we should be able to model the position of the shape at the  step using only the position of the shape at the  step. Using this insight, we extract random temporal patches of 2 frames from each video of 3 frames. We then use VideoFlow to maximize the log-likelihood of the second frame given the first, i.e the model looks back at just one frame. We observe that the bits-per-pixel on the holdout set reduces to a very low  bits-per-pixel for this model. On generating videos conditioned on the first frame, we observe that the model consistently predicts the future trajectory of the shape to be one of the eight random directions. We compare our model with two state-of-the-art stochastic video generation models SV2P and SAVP-VAE \citep{babaeizadeh2017stochastic,lee2018stochastic} using their Tensor2Tensor implementation \citep{vaswani2018tensor2tensor}. We
assess the quality of the generated videos using a real vs fake Amazon Mechanical Turk test. In the test, we inform the rater that a "real" trajectory is one in which the shape is consistent in color and congruent throughout the video. We show that VideoFlow outperforms the baselines in terms of fooling rate in Table 1 consistently generating plausible "real" trajectories at a greater rate.





\subsection{Video Modeling with the BAIR Dataset}

\label{sec:svgb}

We use the action-free version of the BAIR robot pushing dataset \citep{ebert2017self} that contain videos of a Sawyer robotic arm with resolution 64x64. In the absence of actions, the task of video generation is completely unsupervised with multiple plausible trajectories due to the partial observability of the environment and stochasticity of the robot actions. We train the baseline models, SAVP-VAE, SV2P and SVG-LP to generate 10 target frames, conditioned on 3 input frames. We extract random temporal patches of 4 frames, and train VideoFlow to maximize the log-likelihood of the 4th frame given a context of 3 past frames. We, thus ensure that all models have seen a total of 13 frames during training.

\begin{table}
	\begin{minipage}{0.5\linewidth}
		\centering
		\begin{tabular}{c c}
        \hline
        Model & Bits-per-pixel \\
        \hline\hline
        VideoFlow & \textbf{1.87} \\
        SAVP-VAE &  6.73 \\
        SV2P &  6.78 \\ 
        \hline
        \end{tabular}
		\caption{\textbf{Left:} We report the average bits-per-pixel across 10 target frames with 3 conditioning frames for the BAIR action-free dataset.}
	\end{minipage}\hfill
	\begin{minipage}{0.45\linewidth}
		\centering
		\includegraphics[width=40mm]{quality_diversity}
		\captionof{figure}{We measure realism using a 2AFC test and diversity using mean pairwise cosine distance between generated samples in VGG perceptual space.}
	\end{minipage}
\label{tab:bair_bpp_diversity}
\end{table}



\textbf{Bits-per-pixel}: We estimated the variational bound of the bits-per-pixel on the test set, via importance sampling, from the posteriors for the SAVP-VAE and SV2P models. We find that VideoFlow outperforms these models on bits-per-pixel and report these values in Table 2. We attribute the high values of bits-per-pixel of the baselines to their optimization objective. They do not optimize the variational bound on the log-likelihood directly due to the presence of a  term in their objective and scheduled sampling \citep{bengio2015scheduled}.

\begin{figure}[h]
\begin{tabular}{ccc}
\includegraphics[height=3.8cm,width=3.8cm]{bair_vgg} & \includegraphics[height=3.8cm,width=3.8cm]{bair_ssim} & \includegraphics[height=3.8cm,width=3.8cm]{bair_psnr} \\
\end{tabular}

\caption{For a given set of conditioning frames on the BAIR action-free we sample 100 videos from each of the stochastic video generation models. We choose the video closest to the ground-truth on the basis of PSNR, SSIM and VGG perceptual metrics and report the best possible value for each of these metrics. All the models were trained using ten target frames but are tested to generate 27 frames. For all the reported metrics, \textbf{higher is better}.}
\label{fig:bair_comp}
\end{figure}

\phantomsection
\label{subsec:accuracy}
\textbf{Accuracy of the best sample}: The BAIR robot-pushing dataset is highly stochastic and the number of plausible futures are high. Each generated video can be super realistic, can represent a plausible future in theory but can be far from the single ground truth video perceptually. To partially overcome this, we follow the metrics proposed in prior work \citep{babaeizadeh2017stochastic, lee2018stochastic,denton2018stochastic} to evaluate our model. For a given set of conditioning frames in the BAIR action-free test-set, we generate 100 videos from each of the stochastic models. We then compute the 
closest of these generated videos to the ground truth according to three different metrics, PSNR (Peak Signal to Noise Ratio), SSIM (Structural Similarity) \citep{wang2004image} and cosine similarity using features obtained from a pretrained VGG network \citep{dosovitskiy2016generating,johnson2016perceptual} and report our findings in \figref{fig:bair_comp}. This metric helps us understand if the true future lies in the set of all plausible futures according to the video model.

In prior work, \citep{lee2018stochastic,babaeizadeh2017stochastic,denton2018stochastic} effectively tune the pixel-level variance as a hyperparameter and sample from a deterministic decoder. They obtain training stabiltiy and improve sample quality by removing pixel-level noise using this procedure. We can remove pixel-level noise in our VideoFlow model resulting in higher quality videos at the cost of diversity by sampling videos at a lower temperature, analogous to the procedure in~\citep{kingma2018glow}. For a network trained with additive coupling layers, we can sample the  frame  from  with a temperature  simply by scaling the standard deviation of the latent gaussian distribution  by a factor of . We report results with both a temperature of 1.0 and the optimal temperature tuned on the validation set using VGG similarity metrics in \figref{fig:bair_comp}. Additionally, we also applied low-temperature sampling to the latent gaussian priors of SV2P and SAVP-VAE and empirically found it to hurt performance. We report these results in \figref{fig:temp_video_vae}

For SAVP-VAE, we notice that the hyperparameters that perform the best on these metrics are the ones that have disappearing arms. For completeness, we report these numbers as well as the numbers for the best performing SAVP models that do not have disappearing arms. Our model with optimal temperature performs better or as well as the SAVP-VAE and SVG-LP models on the VGG-based similarity metrics, which correlate well with human perception \citep{zhang2018unreasonable} and SSIM. Our model with temperature  is also competent with state-of-the-art video generation models on these metrics. PSNR is explicitly a pixel-level metric, which the VAE models incorporate as part of its optimization objective. VideoFlow on the other-hand models the conditional probability of the joint distribution of frames, hence as expected it underperforms on PSNR.

\begin{figure}[h]
\centering
\begin{tabular}{cc}
\includegraphics[height=0.2\textheight,width=0.4\textwidth]{diversity_id1} &
\includegraphics[height=0.2\textheight,width=0.4\textwidth]{diversity_id2} \\
\end{tabular}
\caption{We display three different futures for two sets of conditioning frames (left and right) at  showcasing diversity in outcomes}
\label{fig:diversity}
\end{figure}

\textbf{Diversity and quality in generated samples:} For each set of conditioning frames in the test set, we generate 10 videos and compute the mean distance in VGG perceptual space across these 45 different pairs. We average this across the test-set for  and  and report these numbers in Figure 3. We also assess the quality of the generated videos at  and , using a real vs fake Amazon Mechanical Turk test and report fooling rates. We observe that VideoFlow outperforms diversity values reported in prior work \citep{lee2018stochastic} while being competitive in the realism axis. 
We also find that VideoFlow at  has the highest fooling rate while being competent with state-of-the-art VAE models in diversity.

On inspection of the generated videos, we find that at lower temperatures,
the arm exhibits less random behaviour with the background objects remaining static and clear achieving higher realism scores. At higher
temperatures, the motion of arm is much more stochastic, achieving high diversity scores with the background objects becoming much noisier leading to a drop in realism.

\begin{table}[h!]
\centering
\begin{tabular}{  c  c  c  c  c }
\hline
\addlinespace[0.05cm]
\multicolumn{5}{c}{\textbf{\# Frames Seen: Training}} \\
\addlinespace[0.05cm]
\hline\hline
\addlinespace[0.05cm]
Conditioning & 3 & 3 & 3 & 2 \\
Total & 13 & 13 & 13 & 16 \\
\addlinespace[0.05cm]
\hline
\addlinespace[0.05cm]
\multicolumn{5}{c}{\textbf{\# Frames: Evaluation}} \\
\addlinespace[0.05cm]
\hline\hline
\addlinespace[0.05cm]
Ground truth & 3 & 3 & 2 & 2 \\
Total & 13 & 16 & 16 & 16 \\
\addlinespace[0.05cm]
\hline
 \addlinespace[0.05cm]
 \textbf{Model} & \multicolumn{4}{|c}{\textbf{FVD}} \\
 \addlinespace[0.05cm]
 \hline\hline
 \addlinespace[0.05cm]
 VideoFlow (T=0.8) & 954 & 127  & 1315 & - \\
 VideoFlow (T=1.0) & 1496 & 2218 & 2517 & - \\
SAVP & - & - & - & 116 \\
SV2P & - & - & - &  263 \\
\addlinespace[0.05cm]
\hline
\addlinespace[0.05cm]
\end{tabular}
\caption{\textbf{Fr\'{e}chet Video Distance:}. We report the mean and standard deviation across 5 runs for 3 different frame settings. Results are not directly comparable across models due to the differences between the total number of frames seen during training and the number of conditioning frames.}
\label{table:fvd}
\end{table}

\textbf{Fr\'{e}chet Video Distance (FVD):} We evaluate VideoFlow using the recently proposed Fr\'{e}chet Video Distance (FVD) metric \citep{unterthiner2018accurate}, an adaptation of the  Fr\'{e}chet Inception Distance (FID) metric \citep{heusel2017gans} for video generation. \citep{unterthiner2018accurate} report results with models trained on a total of 16 frames with 2 conditioning frames; while we train our VideoFlow model on a total of 13 frames with 3 conditioning frames, making our results not directly comparable to theirs. We evaluate FVD for both shorter and longer rollouts in Table \ref{table:fvd}. We show that, even in the settings that are disadvantageous to VideoFlow, where we compute the FVD on a total of 16 frames, when trained on just 13 frames, VideoFlow performs comparable to SAVP.

\subsection{Latent space interpolation}

\textbf{BAIR robot pushing dataset}: We encode the first input frame and the last target frame into the latent space using our trained VideoFlow encoder and perform interpolations. We find that the motion of the arm is interpolated in a temporally cohesive fashion between the initial and final position. Further, we use the multi-level latent representation to interpolate representations at a particular level while keeping the representations at other levels fixed. We find that the bottom level interpolates the motion of background objects which are at a smaller scale while the top level interpolates the arm motion.
\begin{figure}[h]
\begin{tabular}{cc}
\includegraphics[height=3.2cm,width=6.5cm]{ss_interp} & \includegraphics[height=3.2cm,width=6.5cm]{bair_interp} \\
\end{tabular}

\caption{\textbf{Left:} We display interpolations between a) a small blue rectangle and a large yellow rectangle b) a small blue circle and a large yellow circle. \textbf{Right:} We display interpolations between the first input frame and the last target frame of two test videos in the BAIR robot pushing dataset.}
\label{fig:vf_interp}
\end{figure}

\textbf{Stochastic Movement Dataset:} We encode two different shapes with their type fixed but a different size and color into the latent space. We observe that the size of the shape gets smoothly interpolated. During training, we sample the colors of the shapes from a uniform discrete distribution which is reflected in our experiments. We observe that all the colors in the interpolated space lie in the set of colors in the training set.

\subsection{Longer predictions}

\begin{figure}[h]
\begin{tabular}{cc}
\includegraphics[height=3.2cm,width=6.5cm]{long_term_pred} & \includegraphics[height=3.2cm,width=4.5cm]{temporal_anomaly} \\
\end{tabular}

\caption{\textbf{Left:} We generate 100 frames into the future with a temperature of 0.5. The top and bottom row correspond to generated videos in the absence and presence of occlusions respectively. \textbf{Right:} We use VideoFlow to detect the plausibility of a temporally inconsistent frame to occur in the immediate future.}
\label{fig:long_temporal}
\end{figure}

We generate 100 frames into the future using our model trained on 13 frames with a temperature of 0.5 and display our results in \figref{fig:long_temporal}. On the top, even 100 frames into the future, the generated frames remain in the image manifold maintaining temporal consistency. In the presence of occlusions, the arm remains super-sharp but the background objects become noisier and blurrier. Our VideoFlow model has a bijection between the  and  meaning that the latent state  cannot store information other than that present in the frame . This, in combination with the Markovian assumption in our latent dynamics means that the model can forget objects if they have been occluded for a few frames. In future work, we would address this by incorporating longer memory in our VideoFlow model; for example by parameterizing  as a recurrent neural network in our autoregressive prior (eq. \ref{eq:condgaussianprior}) or using more memory-efficient backpropagation algorithms for invertible neural networks \citep{gomez2017reversible}.

\subsection{Out-of-sequence detection}
\label{oos-dec}
We use our trained VideoFlow model, conditioned on 3 frames as explained in Section \ref{sec:svgb}, to detect the
plausibility of a temporally inconsistent frame to occur in the immediate future. We condition the model on the first three frames of a test-set video  to obtain a distribution  over its 4th frame . We then compute the likelihood of the  frame  of the same video to occur as the 4th time-step using this distribution. i.e,  for . We average the corresponding bits-per-pixel values across the test set and report our findings in Figure \ref{fig:long_temporal}. We find that our model 
assigns a monotonically decreasing log-likelihood to frames that are more far out in the future and hence less likely to occur in the 4th time-step.

\section{Open source code and checkpoints}

We open-source the implementation of our code in the \href{https://github.com/tensorflow/tensor2tensor/blob/master/tensor2tensor/models/video/next_frame_glow.py}{Tensor2Tensor codebase}. We additionally open-source various components of our trained VideoFlow model, to evaluate log-likelihood, to generate frames and compute latent codes as reusable \href{https://tfhub.dev/s?q=videoflow}{TFHub modules}

\section{Conclusion and Discussion}
We describe a practically applicable architecture for flow-based video prediction models, inspired by the Glow model for image generation~\cite{kingma2018glow}, which we call VideoFlow. We introduce a latent dynamical system model that predicts future values of the flow model's latent state replacing the standard unconditional prior distribution. Our empirical results show that VideoFlow achieves results that are competitive with the state-of-the-art VAE models in stochastic video prediction. Finally, our model optimizes log-likelihood directly making it easy to evaluate while achieving faster synthesis compared to pixel-level autoregressive video models, making our model suitable for practical purposes.
In future work, we plan to incorporate memory in VideoFlow to model arbitrary long-range dependencies and apply the model to challenging downstream tasks.

\subsubsection*{acknowledgements}

We would like to thank Ryan Sepassi and Lukasz Kaiser for their extensive help in using Tensor2Tensor, Oscar T\"ackstr\"om for finding a bug in our evaluation pipeline that improved results across all models, Ruben Villegas for providing code for the SVG-LP baseline and Mostafa Dehghani for providing feedback on a draft of the rebuttal. 



 \bibliography{iclr2020_conference}
\bibliographystyle{iclr2020_conference}
\appendix

\section{Moving MNIST - Qualitative Experiments}

\begin{figure}[h]
\centering
\includegraphics[height=0.3\textheight,width=\textwidth]{mnist.pdf}
\caption{We display ten frame rollouts conditioned on a single frame on the Moving MNIST dataset.}
\label{mnist}
\end{figure}

Similar to the Stochastic Movement Dataset as described in Section 5.1, we extract random temporal patches of 2 frames on the Moving MNIST dataset \citep{srivastava2015unsupervised}. We train our VideoFlow model to maximize the log-likelihood of the second frame, given the first. Our rollouts over 10 frames capture realistic digit movement. 

\section{Human3.6M - Qualitative Experiments}

\begin{figure}[h]
\centering
\includegraphics[height=0.3\textheight,width=\textwidth]{humans.pdf}
\caption{We display ten frame rollouts conditioned on 3 frames on the Human3.6M dataset.}
\label{human_36m}
\end{figure}

We model the Human3.6M dataset \citep{ionescu2014human3}, by  maximizing the log-likelihood of the 4th frame given the first three frames, in a random temporal patch of 4 frames. We observe that on this dataset, our model fails to capture reasonable human motion. We hope that by increasing model capacity and using more expressive priors, we can acheive better performance on this dataset in the future.



\section{Discretization and Uniform quantization}

Let  be our dataset of i.i.d. observations of a random variable  with an unknown true distribution . Our data consist of 8-bit videos, with each dimension rescaled to the domain . We add a small amount of uniform noise to the data, , matching its discretization level~\citep{dinh2016density,kingma2018glow}. Let  be the resulting empirical distribution corresponding to this scaling and addition of noise. Note that additive noise is required to prevent  from having infinite densities at the datapoints, which can result in ill-behaved optimization of the log-likelihood; it also allows us to recast maximization of the log-likelihood as minimization of a KL divergence.


\section{Residual network architecture}
\label{sec:res_net_arch}
Here we'll describe the architecture for the residual network  that maps  to () (Left: \figref{fig:residual_architecture}). As shown in the left of \figref{fig:residual_architecture}, let  be the tensor representing  after the split operation between levels in the multi-scale architecture. We apply a  convolution over  and concatenate this across channels to each latent from the previous time-step and the same-level independently. In this way, we obtain .
We transform these values into () via a stack of residual blocks. We obtain a reduction in parameter count by sharing parameters across every 2 time-steps via 3-D convolutions in our residual blocks.

As shown in the right of \figref{fig:residual_architecture}, each 3-D residual block consists of three layers. The first layer has a filter size of 2x3x3 with 512 output channels followed by a ReLU activation.
The second layer has two  convolutions via the Gated Activation Unit
\cite{van2016wavenet,van2016conditional}. The third layer has a filter size of  with the number of output channels determined by the level. This block is replicated three times in parallel, with dilation rates 1, 2 and 4, after which the results of each block, in addition to the input of the residual block, are summed. 


The first two layers are initialized using a Gaussian distribution and the last layer is initialized to zeroes. In that way, the residual network behaves as an identity network during initialization allowing stable optimization. After applying a sequence of residual blocks, we use the last temporal activation that should capture all context. We apply a final  convolution to this activation to obtain (). We then add  to  to a \textit{temporal skip connection} to output 
. This way, the network learns to predict the change in latent variables for a given level. We have provided visualizations of the network architecture in \href{https://sites.google.com/corp/view/videoflow/home}{this website}

\begin{figure}
    \hspace{0.1\textwidth}
    \includegraphics[width=0.25\textwidth,height=0.35\textheight]{3d_residual_2}
    \hspace{0.15\textwidth}
    \includegraphics[width=0.4\textwidth,height=0.3\textheight]{3d_residual_1}
    \hspace{0.1\textwidth}
    \caption{\textbf{Left:} We predict a gaussian distribution over  via a 3-D Residual network conditioned on  and . \textbf{Right:} Our 3-D residual network architecture is augmented with dilations and gated activation units improving performance.}
    \label{fig:residual_architecture}
\end{figure}

\section{Ablation Studies}
\label{sec:ablations}
Through an ablation study, we experimentally evaluate the importance of the following components of our VideoFlow model: (1) the use of temporal skip connections, (2) the use Gated Activation Unit (GATU) instead of ReLUs in the residual network and (3) the use of dilations in  in Section \ref{sec:res_net_arch}

We start with a VideoFlow model with 256 channels in the coupling layer, 16 steps of flow and remove the components mentioned above to create our baseline. We use four different combinations of our components (described in Fig.~\ref{fig:ablation}) and keep the rest of the hyperparameters fixed across those combinations. For each combination we plot the mean bits-per-pixel on the holdout BAIR-action free dataset over 300K training steps for both affine and additive coupling in \figref{fig:ablation}. 
For both the coupling layers, we observe that the VideoFlow model with all the components provide a significant boost in bits-per-pixel over our baseline.

\begin{figure*}[h]
\begin{tabular}{cc}
\centering
\includegraphics[height=4.2cm,width=6.2cm]{affine_ablation} &
\includegraphics[height=4.2cm,width=6.2cm]{additive_ablation} \\
\end{tabular}
\caption{\textbf{B: baseline}, \textbf{A: Temporal Skip Connection}, \textbf{C: Dilated Convolutions + GATU}, \textbf{D: Dilation Convolutions + Temporal Skip Connection}, \textbf{E: Dilation Convolutions + Temporal Skip Connection + GATU}. We plot the holdout bits-per-pixel on the BAIR action-free dataset for different ablations of our VideoFlow model.}
\label{fig:ablation}
\end{figure*}

We also note that other combinations---dilated convolutions + GATU (C) and dilated convolutions + the temporal skip connection ---improve over the baseline. Finally, we experienced that increasing the receptive field in  using dilated convolutions alone in the absence of the temporal skip connection or the GATU makes training highly unstable.

\section{Effect of temperature on SAVP-VAE and SV2P}

\begin{figure}[h]
\begin{tabular}{ccc}
\includegraphics[height=3.8cm,width=3.8cm]{vgg_sim_savp_t} &
\includegraphics[height=3.8cm,width=3.8cm]{ssim_savp_t} & \includegraphics[height=3.8cm,width=3.8cm]{psnr_savp_t} \\
\includegraphics[height=3.8cm,width=3.8cm]{sv2p_vgg_t} &
\includegraphics[height=3.8cm,width=3.8cm]{sv2p_ssim_t} & \includegraphics[height=3.8cm,width=3.8cm]{sv2p_psnr_t} \\
\end{tabular}
\caption{We repeat our evaluations described on the SV2P and SAVP-VAE model in \figref{fig:bair_comp} using temperatures from 0.0 to 1.0 while sampling from the latent gaussian prior.}
\label{fig:temp_video_vae}
\end{figure}

We repeat our evaluations described in \figref{fig:bair_comp} applying low temperature to the latent gaussian priors of SV2P and SAVP-VAE. We empirically find that decreasing temperature from 1.0 to 0.0 monotonically decreases the performance of the VAE models. Our insight is that the VideoFlow model gains by low-temperature sampling due to the following reason. At lower T, we obtain a tradeoff between a performance gain by noise removal from the background and a performance hit due to reduced stochasticity of the robot arm. On the other hand, the VAE models have a clear but slightly blurry background throughout from  to . Reducing T in this case, solely reduces the stochasticity of the arm motion thus hurting performance.

\section{Likelihood vs Quality}

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{bpp_vs_quality_v2}
\caption{We provide a comparison between training progression (measured in the mean bits-per-pixel objective on the test-set) and the quality of generated videos.}
\label{bpp_vs_quality}
\end{figure}

We show correlation between training progression (measured in bits per pixel) and quality of the generated videos in \figref{bpp_vs_quality}. We display the videos generated by conditioning on frames from the test set for three different values of bits-per-pixel on the test-set. As we approach lower bits-per-pixel, our VideoFlow model learns to model the structure of the arm with high quality as well as its motion resulting in high quality video.





\section{VideoFlow - BAIR Hyperparameters}

\subsection{Quantitative - Bits-per-pixel}

To report bits-per-pixel we use the following set of hyperparameters. We use a learning rate schedule of linear warmup for the first 10000 steps and apply a linear-decay schedule for the last 150000 steps.

\begin{center}
\begin{tabular}{ |c|c| } 
 \hline
 \textbf{Hyperparameter} & \textbf{Value} \\
 \hline
 Flow levels & 3 \\
 \hline
 Flow steps per level & 24 \\
 \hline
 Coupling & Affine \\
 \hline
 Number of coupling layer channels & 512 \\
 \hline
 Optimier & Adam \\
 \hline
 Batch size & 40 \\
 \hline
 Learning rate & 3e-4 \\
 \hline
 Number of 3-D residual blocks & 5 \\
 \hline
 Number of 3-D residual channels & 256 \\
 \hline
 Training steps & 600K \\
 \hline
\end{tabular}
\end{center}

\subsection{Qualitative Experiments}

For all qualitative experiments and quantitative comparisons with the baselines, we used the following sets of hyperparameters.

\begin{center}
\begin{tabular}{ |c|c| } 
 \hline
 \textbf{Hyperparameter} & \textbf{Value} \\
 \hline
 Flow levels & 3 \\
 \hline
 Flow steps per level & 24 \\
 \hline
 Coupling & Additive \\
 \hline
 Number of coupling layer channels & 392 \\
 \hline
 Optimier & Adam \\
 \hline
 Batch size & 40 \\
 \hline
 Learning rate & 3e-4 \\
 \hline
 Number of 3-D residual blocks & 5 \\
 \hline
 Number of 3-D residual channels & 256 \\
 \hline
 Training steps & 500K \\
 \hline
\end{tabular}
\end{center}

\section{Hyperparameter grid for the baseline video models.}

We train all our baseline models for 300K steps using the Adam optimizer. Our models were tuned using the maximum VGG cosine similarity metric with the ground-truth across 100 decodes.

\textbf{SAVP-VAE and SV2P:} We use three values of latent loss multiplier 1e-3, 1e-4 and 1e-5. For the SAVP-VAE model, we additionally apply linear decay on the learning rate for the last 100K steps.\\
\textbf{SAVP-GAN:} We tune the gan loss multiplier and the learning rate on a logscale from 1e-2 to 1e-4 and 1e-3 to 1e-5 respectively.

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{bpp_vs_vgg}
\caption{We compare  and VGG cosine similarity between  and  for }
\label{fig:bpp_vs_vgg}
\end{figure}

\section{Correlation between VGG perceptual similarity and bits-per-pixel}
We plot correlation between cosine similarity using a pretrained VGG network and bits-per-pixel using our trained VideoFlow model. We compare  as done in Section \ref{oos-dec} and the VGG cosine similarity between  and  for . We report our results for every video in the test set in Figure  \ref{fig:bpp_vs_vgg}. We notice a weak correlation between VGG perceptual metrics and bits-per-pixel with a correlation factor of . 

\section{VideoFlow: Low parameter regime}

We repeated our evaluations described in Figure 4, with a smaller version of our VideoFlow model with 4x parameter reduction. Our model remains competetive with SVG-LP on the VGG perceptual metrics.


\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{smaller_param}
\caption{We repeat our evaluations described in Figure 4 with a smaller version of our VideoFlow model.}
\label{fig:bpp_vs_vgg}
\end{figure} 

\end{document}
