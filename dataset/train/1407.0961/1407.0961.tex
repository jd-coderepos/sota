\documentclass[10pt,journal,cspaper,compsoc]{IEEEtran}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{multirow,cite}
\usepackage{epsfig}
\usepackage{algorithm,algorithmic}
\usepackage{balance}
\newcommand{\mb}[1]{\ensuremath{\mathbf{#1}}}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicreturn}{\textbf{Output:}}
\newtheorem{thm}{Theorem}[section]
\newtheorem{lemma}{Lemma}[section]


\usepackage{colortbl}

\def\x{{\mathbf x}}
\def\L{{\cal L}}
\def\d{\downarrow}
\def\u{\uparrow}
\def\mb{\mathbf}


\begin{document}
\title{An Enhanced Multiway Sorting Network\\
Based on -Sorters}

\author{Feng Shi, Zhiyuan Yan, and Meghanad Wagh

  \IEEEcompsocitemizethanks{\IEEEcompsocthanksitem Feng Shi, Zhiyuan Yan, and Meghanad Wagh
    are with the Department of ECE,
    Lehigh University, PA 18015, USA. E-mails:\{fes209, yan, mdw0\}@lehigh.edu.}}



\IEEEcompsoctitleabstractindextext{
\begin{abstract}
Merging-based sorting networks are an important family of sorting networks. Most merge sorting networks are based on 2-way or multi-way merging algorithms using 2-sorters as basic building blocks.
An alternative is to use -sorters, instead of 2-sorters, as the basic building blocks so as to greatly reduce the number of sorters as well as the latency. Based on a modified Leighton's columnsort algorithm, an -way merging algorithm, referred to as SS-Mk, that uses -sorters as basic building blocks was proposed.
In this work, we first propose a new multiway merging algorithm with -sorters as basic building blocks that merges  sorted lists of  values each in  stages (). Based on our merging algorithm, we also propose a sorting algorithm, which requires  basic sorters to sort  inputs. While the asymptotic complexity (in terms of the required number of sorters) of our sorting algorithm is the same as the SS-Mk, for wide ranges of , our algorithm requires fewer sorters than the SS-Mk.
Finally, we consider a binary sorting network, where the basic sorter is implemented in threshold logic and scales linearly with the number of inputs, and compare the complexity in terms of the required number of gates. For wide ranges of , our algorithm requires fewer gates than the SS-Mk.
\end{abstract}
\begin{keywords}
Multiway, sorting, merging
\end{keywords}
}

\maketitle


\section{Introduction}
\IEEEPARstart{S}orting is one important operation in data processing, and hence its efficiency greatly affects the overall performance of a wide variety of applications \cite{knuth1973art,Bat68sorting}.
Sorting networks can achieve high throughput rates by performing operations simultaneously.
These parallel sorting networks have attracted attention of researchers due to increasing hardware speed and decreasing hardware cost. One of the most popular sorting algorithm is called merge-sort algorithm, which performs the sorting in two steps~\cite{Bat68sorting}. First, it divides the input \textbf{list} (a sequence of values) into multiple \textbf{sublists} (a smaller sequence of values) and sorts each sublist simultaneously. Then, the sorted sublists are merged as a single sorted list. The sorting process of sublists can then be decomposed recursively into the sorting and merging of even smaller sublists, which are then merged as a single sorted list. Hence, the merging operation is the key procedure for the decomposition-based sorting approach.
One popular 2-way merging algorithm called odd-even merging~\cite{Bat68sorting} merges two sorted lists (odd and even lists) into one sorted list. In \cite{liszka1992modulo}, a modulo merge sorting was introduced as a generalization of the odd-even merge by dividing the two sorted input lists into multiple sublists with a modulo not limited to 2. Another popular 2-way merging algorithm is bitonic merging algorithm \cite{batcher1990bitonic}. Two sorted lists are first arranged as a bitonic list, which is then converted to obtain a sorted list.
These 2-way merging algorithms employ 2-way merge procedure recursively and have a capability of sorting  values in  stages \cite{Bat68sorting}.
In \cite{ajtai19830}, a sorting network, named AKS sorting network, with  stages was proposed. However, there is a very large constant in the depth expression, which makes it impractical. Recently, a modular design of high-throughput low-latency sorting units are proposed in \cite{farmahini2013modular}.
However, the basic building block in these 2-way merging algorithm is a 2-sorter, which is simply a  switching element or comparator as shown in Fig.~\ref{fig:2ksorter}(a).

Instead of using 2-sorters, -sorters can be used as basic building blocks. This was first proposed as a generalization of the Batcher's odd-even merging algorithm~\cite{Lee95multiway}. It was also motivated by the use of -sorters, which sort  () values in unit time \cite{parker1989constructing,beigel1990sorting}. Since large sorters are used as basic building blocks, the number of sorters as well as the latency is expected to be reduced greatly.
An -way merging algorithm was first proposed by Lee and Batcher~\cite{Lee95multiway}, where  is not restricted to 2. A version of the bitonic -way merging algorithm was proposed by Nakatani \textit{et al.} \cite{nakatani1989e1,lee1994sorting}. However, the combining operation in the -way merging algorithms still use 2-sorters as basic building blocks. Leighton proposed an algorithm for sorting  lists of  values each, represented as an  matrix~\cite{leighton1984tight}. This algorithm is a generalization of the odd-even merge-sort and named columnsort, since it merges all sorted columns to obtain a single sorted list in row order. In the original columnsort, no specific operation was provided for sorting columns and no recursive construction of sorting network was provided. In \cite{parker1989constructing}, a modified columnsort algorithm was proposed with sorting networks constructed from -sorters () \cite{liszka1993generalized}. However, a 2-way merge is still used for the merging process.
In~\cite{gao1997sloping}, an -way merging algorithm, named SS-Mk, based on the modified columnsort was proposed with -sorters as basic building blocks, where  is prime. For  sorted lists of  values each, the idea is to sort the  values first in each row and then in slope lines with decreasing slope rates. An improved version of the SS-Mk merge sort, called ISS-Mk, was provided in~\cite{zhao1998efficient}, where  can be any integer. We compare our sorting scheme with the SS-Mk but not the ISS-Mk, because for our interested ranges of , the ISS-Mk requires larger latency due to a large constant.

In this work, we propose an -way merging algorithm, which generalizes the odd-even merge by using -sorters as basic building blocks, where  () is prime. Based on this merging algorithm, we also propose a sorting algorithm. For  input values,  stages are needed. The complexity of the sorting network is evaluated by the total number of -sorters. The closed-form expression for the number of sorters is also derived.

Instead of 2-sorters, -sorters () are used as basic blocks in this work. This is because larger sorters have some efficient implementation. For example, for binary sorting in threshold logic, the area of an -sorter scales linearly with the number of inputs , while the latency stays as a constant. Hence, a smaller number of sorters and latency of the whole sorting network can be achieved. However, we cannot use arbitrary large sorters as basic blocks, since larger sorters are more complex and difficult to be implemented. Hence, the benefit of using a larger block diminishes with increasing .
We assume that the size of basic sorter  20 and 10 when evaluating the number of sorters and latency. Our algorithm works for any upper bound on , and one can plug any upper bound on  into our algorithm. Asymptotically, the number of sorters required by our sorting algorithm is on the same order of  as the SS-Mk~\cite{gao1997sloping} for sorting  inputs. Our sorting algorithm requires fewer sorters than the SS-Mk in~\cite{gao1997sloping} in wide ranges of .
For instance, for , when , our algorithm requires up to 46\% fewer sorters than the SS-Mk. When , our algorithm has fewer sorters for some segments of 's. When , our algorithm needs more sorters.

The work in this paper is different from previous works~\cite{Lee95multiway,gao1997sloping,zhao1998efficient} in the following aspects:
\begin{itemize}
  \item While the multiway merge \cite{Lee95multiway} uses 2-sorters in the combining network, our proposed -way merging algorithm uses -sorters as basic building blocks. By using larger sorters (), the number of sorters as well as the latency would be reduced greatly.
  \item The merge-based sorting algorithms in \cite{gao1997sloping,zhao1998efficient} are based on the modified columnsort \cite{liszka1993generalized}, which merges sorted columns as a single sorted list in row order. Our -way merge sorting algorithm is a direct generalization of the multiway merge sorting in \cite{Lee95multiway}.
\item We analyze the performance of our approach by deriving the closed-form expressions of the latency and the number of sorters. We also derive the closed-form expression of the number of sorters for the SS-Mk~\cite{gao1997sloping}, since it was not provided in~\cite{gao1997sloping}. Then we present extensive comparisons between  the latency and the number of sorters required by our approach and the SS-Mk~\cite{gao1997sloping}.
  \item Finally, we show an implementation of a binary sorting network in threshold logic. With an implementation of a large sorter in threshold logic, we compare the performance of sorting networks in terms of the number of gates.
\end{itemize}


The rest of the paper is organized as following. In Sec.~\ref{sec:bg}, we briefly review the background of sorting networks. In Sec.~\ref{sec:kmerge}, we propose a multiway merging algorithm with -sorters as basic blocks. In Sec.~\ref{sec:ksort}, we introduce a multiway sorting algorithm based on the proposed merging algorithm, and show extensive results for the comparison of our sorting algorithm and previous works. In Sec.~\ref{sec:appl}, we focus on a binary sorting network, where basic sorters are implemented by threshold logic and have complexity linear with the input size, and measure the complexity in terms of number of gates. Finally Sec.~\ref{sec:conclusion} presents the conclusion of this work.



\section{Background}
\label{sec:bg}
A sorting network is a feedforward network, which gives a sorted list for unsorted inputs. It is composed of two items: \textbf{switching elements (or comparators)} and \textbf{wires}. The depth of a comparator is defined to be the longest length from the inputs of the sorting network to that comparator's outputs. The \textbf{latency} of the sorting network is the maximum depth of all comparators.
The network is \textbf{oblivious} in the sense that the time and location of input and output are fixed ahead of time and not dependent on the values~\cite{Bat68sorting}.
We use the Knuth diagram in \cite{knuth1973art} for easy representation of the sorting networks, where switching elements are denoted by connections on a a set of wires. The inputs enter at one side and sorted values are output at the other side, and what remains is how to arrange the switching elements. The sorting network is measured in two aspects, latency (number of stages) and complexity (number of sorters).
The basic building block used by the odd-even merge~\cite{Bat68sorting} is a 2-by-2 comparator (compare-exchange element). It receives two inputs and outputs the minimum and maximum in an ordered way.
The symbol for a 2-sorter is shown in Fig.~\ref{fig:2ksorter}(a), where  and  for  are input and output, respectively.
Similarly, an -sorter is a device sorting  values in unit time. The symbol for an -sorter is shown in Fig.~\ref{fig:2ksorter}(b), where  and  for  are input and output, respectively, and the output satisfies .
In this work, we denote the sorted values  by  and use -sorters as basic blocks for sorting.


\begin{figure}[!t]
\centering
\includegraphics[width=6.5cm]{2ksorter}
\caption{(a) 2-sorter (); (b) -sorter ().}
\label{fig:2ksorter}
\end{figure}

Merging-based sorting networks are an important family of sorting networks, where the merging operation is the key. There are two classes of merging algorithms, the odd-even merging \cite{Bat68sorting} and the bitonic merging \cite{batcher1990bitonic}. The former is an efficient sorting technique based on the divide-and-conquer approach, which decomposes the inputs into two sublists (odd and even), sorts each sublist, and then merges two sorted lists into one. Further decomposition and merging operations are applied on the sublists.
An example of odd-even merging network using 2-sorters is shown in Fig.~\ref{fig:oddeven}, where two sorted lists,  and , are merged as a single list  in two stages.
\begin{figure}[!t]
\centering
\includegraphics[width=7.5cm]{oddevenmerge}
\caption{The odd-even merge of two sorted lists of 4 values each using 2-sorters.}
\label{fig:oddeven}
\end{figure}

\begin{figure}[!t]
\centering
\includegraphics[width=8.5cm]{kway}
\caption{Iterative construction rule for the -way merger \cite{Lee95multiway}.}
\label{fig:kway}
\end{figure}


Instead of merging two lists, multiple sorted lists can be merged as a single sorted list simultaneously.
An \textbf{-way merger} () of size  is a network merging  sorted lists of size  ( values) each into a single sorted list in multiple stages.
This was first proposed as a generalization of the Batcher's odd-even merging algorithm. It is also motivated by the use of -sorters, which sort  () values in unit time \cite{parker1989constructing,beigel1990sorting}. Since large sorters are used as basic building blocks, the number of sorters as well as the latency is expected to be reduced greatly.
Many multiway merging algorithms exist in the literature \cite{drysdale1975improved, van1974economical, Lee95multiway, nakatani1989e1, lee1994sorting, leighton1984tight, parker1989constructing, liszka1993generalized, gao1997sloping, zhao1998efficient}. The algorithms in \cite{drysdale1975improved, van1974economical} implement multiway merge using 2-sorters. In \cite{Lee95multiway}, a generalization of Batcher's odd-even is introduced as shown in Fig.~\ref{fig:kway}, where an -way merger of  lists of size  is decomposed into  -way mergers of  sublists of size  plus a combining network. Each of the small -way mergers is further decomposed similarly. However, the combining network in the merging network in Fig.~\ref{fig:kway} still uses 2-sorters as basic blocks.
In \cite{leighton1984tight}, Leighton proposed a columnsort algorithm, which showed how to sort an  matrix denoting the  sorted lists of  values each. A modification of Leighton's columnsort algorithm was given in \cite{parker1989constructing}.
In \cite{gao1997sloping,zhao1998efficient}, merging networks with -sorters as basic blocks are introduced based on the modified Leighton's columnsort algorithm.

In this work, we focus on multiway merge sort with binary values as inputs. Our merge sort also works for arbitrary values, which is justified by the following theorem.
\begin{thm}[Zero-one principle~\cite{Bat68sorting}]
  If a network with  input lines sorts all  lists of 0s and 1s into nondecreasing order, it will sort any arbitrary list of  values into nondecreasing order.
\end{thm}


\section{Multiway Merging}
\label{sec:kmerge}
In the following, we propose an -way merging algorithm with -sorters as basic building blocks as shown in Alg.~\ref{alg:nway}.
We consider a sorting network, where all iterations of Alg.~\ref{alg:nway} are simultaneously instantiated (loop unrolling). We refer to the instantiation of iteration  of Alg.~\ref{alg:nway} as stage  of the sorting network.
The sorters in the last for loop in Alg.~\ref{alg:nway} consist of the last stage.
Let the  sorted input lists be  for . Denote the values of -th list after stage  by . After  stages, all input lists are sorted as a single list, , .


For convenience of describing and proving our algorithm, we introduce some notations and definitions. Denote the number of zeros in the -th list after stage  as , where  and . A sorter is called a \textbf{-spaced sorter} if its adjacent inputs span  other wires and each connection of the same sorter comes from different lists of  wires, where . For simplicity, we arrange the sorters in the order of their first connections in each stage. Denote  as . Two -spaced sorters are said to be \textbf{adjacent} if they connect adjacent two wires,  and , respectively, for some  and .
Then, our -way merging Alg.~\ref{alg:nway} can be intuitively understood as flooding lists with zeros in descending order. The correctness of Alg.~\ref{alg:nway} can be shown by first proving the following lemmas. See the appendix for the proofs of the following lemmas and theorems.


\begin{algorithm}[!tp]
  \caption{Algorithm for -way merging network.}
  \begin{algorithmic}
    \REQUIRE  sorted lists  for ;
    \STATE ;
    \WHILE{}
        \FOR{ to }
            \STATE Apply -spaced sorters between lists  and ;
        \ENDFOR
        \STATE Merge all -spaced sorters;
        \STATE Update  sorted lists  for ;
        \STATE ;
    \ENDWHILE
    \FOR{ to }
        \STATE Apply -sorters on  adjacent lines with first half, , from list  and second half, , from list , where ;
    \ENDFOR
\RETURN Sorted lists.
  \end{algorithmic}
  \label{alg:nway}
\end{algorithm}


\begin{figure}[!t]
\centering
\includegraphics[width=8.5cm]{mnsort}
\caption{The network for  sorted lists of  wires.}
\label{fig:mnsort}
\end{figure}



\begin{lemma}
  Apply -spaced sorters to  lists of  values, , for . The outputs of each list are still sorted, , for .
\label{lm:subgroupsort}
\end{lemma}
For  sorted lists of  values, there are  -spaced sorters as illustrated in Fig.~\ref{fig:mnsort}(a). The proof of the lemma can be reduced to showing that any two wires  of each list connected by the - and -th sorters are sorted. The simplified network is shown in Fig.~\ref{fig:mnsort}(b). Without lose of generality, we can choose .

\begin{figure*}[!t]
\centering
\includegraphics[width=17.5cm]{msort4case}
\caption{Adjacent two sorters  and  in each stage of Alg.~\ref{alg:nway} can be classified into four four cases. (a) Case I (); (b) Case II (); (c) Case III (); (d) Case IV ().}
\label{fig:m2sort}
\end{figure*}

\begin{lemma}
  In each stage of Alg.~\ref{alg:nway}, there are at most four cases of adjacent two sorters as shown in Fig.~\ref{fig:m2sort}. If  is prime, case IV is impossible.
\label{lm:sorter4case}
\end{lemma}
We first show that the first connections of adjacent two sorters,  and , belong to either the same list or adjacent two lists. The same relation is true for the last connections of  and . This gives us a total of four cases as shown in Fig.~\ref{fig:m2sort}, where  for Fig.~\ref{fig:m2sort}(a)-(c), and  for Fig.~\ref{fig:m2sort}(d) such that  and  have a size of at least two.

The following theorem proves the correctness of Alg.~\ref{alg:nway}.
\begin{thm}
  For a prime  in Alg.~\ref{alg:nway}, all lists are self-sorted after every stage. In particular, all lists are sorted after the final stage.
\label{thm:groupsort}
\end{thm}
The theorem can be proved by induction on .




In Alg.~\ref{alg:nway}, the latency increases linearly with . When  is large, the latency is also very large. By further decomposing  into a product of small factors, we can reduce the latency significantly.
In the following, we propose Alg.~\ref{alg:nwaymerge} for merging  lists of  values, where  for . When  is not a power of , we can use a larger network of  inputs.
For any  in stage  (), denote the number of zeros in each new formed list after stage  as , where . Assume two dummy lists with  and  are appended to the two ends of  lists.
The correctness of Alg.~\ref{alg:nwaymerge} can be shown by first proving the following lemma.

\begin{algorithm}[!tp]
  \caption{Algorithm for combining  lists of  values.}
  \begin{algorithmic}
    \REQUIRE  sorted lists  for  and ;
    \STATE ;
\FOR{ to }
            \STATE Apply Alg.~\ref{alg:nway} on   for  and obtain a single sorted list ,
            , ;
        \ENDFOR
\FOR{ to }
        \FOR{ to }
            \STATE Group  neighboring values of  for  and denote the new lists as  for ;
            \FOR{ to }
                \STATE Apply -spaced sorters between lists  and ;
            \ENDFOR
            \STATE Apply -sorters between lists  and  for ;
            \STATE Obtain a single sorted list   ;
        \ENDFOR
    \ENDFOR
    \RETURN Sorted list.
  \end{algorithmic}
  \label{alg:nwaymerge}
\end{algorithm}

\begin{lemma}
  In Alg.~\ref{alg:nwaymerge}, the new lists in stage  with respect to  are self-sorted. The numbers of zeros of all new lists after stage  are non-increasing,
  
  where  and . Furthermore, there are at most  consecutive lists that have between 1 and  zeros,
  
  where  and .
\label{lm:mergen0s}
\end{lemma}
See Sec.~\ref{pf:mergen0s} for the proof.

The following theorem proves the correctness of Alg.~\ref{alg:nwaymerge}.
\begin{thm}
  Alg.~\ref{alg:nwaymerge} combines  sorted lists of  values as a single sorted list.
  \label{thm:nwaymerge}
\end{thm}
In Alg.~\ref{alg:nwaymerge}, the latency is reduced to  for  sorted lists of  values.

\begin{figure}[!t]
\centering
\includegraphics[width=8.5cm]{3by7merger}
\caption{A 3-way merging network of  inputs implemented via 7 stages.}
\label{fig:3by7merger}
\end{figure}

\begin{figure}[!t]
\centering
\includegraphics[width=6cm]{3by9merger}
\caption{A 3-way merging network of  inputs implemented via 5 stages.}
\label{fig:3by9merger}
\end{figure}

In the following, we show two examples for comparison of the two algorithms.
First, a 3-way merging network of  inputs via Alg.~\ref{alg:nway} is shown in Fig.~\ref{fig:3by7merger}.
Then, a 3-way merging network of  inputs via Alg.~\ref{alg:nwaymerge} is shown in Fig.~\ref{fig:3by9merger}. Though there are more inputs in Fig.~\ref{fig:3by9merger} than that in Fig.~\ref{fig:3by7merger}, the latency of Alg.~\ref{alg:nwaymerge} is smaller due to recursive decomposition. The numbers of sorters in Figs.~\ref{fig:3by7merger} and \ref{fig:3by9merger} are given by 40 and 41, respectively. For six more inputs, it requires only one more sorter in Fig.~\ref{fig:3by9merger}. Hence, Alg.~\ref{alg:nwaymerge} can be more efficient than Alg.~\ref{alg:nway} for a large .

\begin{figure}[!t]
\centering
\includegraphics[width=8.5cm]{27sorter}
\caption{A 3-way sorting network of  inputs implemented via 9 stages.}
\label{fig:27sorter}
\end{figure}

\section{Multiway Sorting}
\label{sec:ksort}
In this section, we first focus on how to construct sorting networks with -sorters using the multiway merging algorithm in Sec.~\ref{sec:kmerge}. Then, we analyze the latency and the number of sorters of the proposed sorting networks by deriving the closed-form expressions. We compare them with previously proposed SS-Mk in \cite{gao1997sloping} but not the ISS-Mk \cite{zhao1998efficient}, because for our interested ranges of , the ISS-Mk requires larger latency due to a large constant.
\subsection{Multiway sorting algorithm}
Based on the multiway merging algorithm in Sec.~\ref{sec:kmerge}, we proposed a parallel sorting algorithm using a divide-and-conquer method. The idea is to first decompose large list of inputs into smaller sublists, then sort each sublist, and finally merge them into one sorted list. The sorting of each sublist is done by further decomposition.
For instance, for  inputs, we first divide the  inputs into  lists of  values. Then we sort each of these  lists and combine them with Alg.~\ref{alg:nwaymerge}. The sorting operation of each of the  lists is done by dividing the  inputs into  smaller lists of  values. We repeat the above operations until that each of  smaller lists contains only  values, which can be sorted by a single -sorter.
The detailed procedures are shown in Alg.~\ref{alg:nwaysort}.

\begin{algorithm}[!h]
  \caption{Algorithm for sorting  values.}
  \begin{algorithmic}
    \REQUIRE  values, ;
\STATE Partition the  values as  lists of  values each,  for ;
    \STATE Apply one -sorter on each of  lists and obtain  for ;
    \FOR{ to }
        \FOR{ to }
            \STATE Apply Alg.~\ref{alg:nway} on   for , and obtain a single sorted list ;
        \ENDFOR
    \ENDFOR
    \RETURN Sorted list.
  \end{algorithmic}
  \label{alg:nwaysort}
\end{algorithm}



For example, a 3-way sorting network of  inputs is shown in Fig.~\ref{fig:27sorter}. The first stage contains 9 3-sorters. The second stage contains 3 three-way mergers with a depth of 3. The last stage contains a three-way merger with a depth of 5. The total depth is given by 9.


\subsection{Latency analysis}
First, we focus on the latency for sorting  values. The latency is defined as the number of basic sorters in the longest paths from the inputs to the sorted output. In Alg.~\ref{alg:nwaysort}, there are  iterations. In iteration , there are  merging networks, each of which is to merge  sorted lists of  values. For iteration , the latency is given by .
For a sorting network of  values via Alg.~\ref{alg:nwaysort}, by summing up the latencies of all levels, we obtain the total latency

The closed-form expression of latency for the SS-Mk given in \cite{gao1997sloping} is


We compare our latency for sorting  values with that for the SS-Mk in \cite{gao1997sloping}. From Eqs.~(\ref{eq:our_L}) and (\ref{eq:ssMk_L}), for  inputs,  should be as small as possible to obtain small latencies.
In Table~\ref{tab:latency}, we compare the latencies of Eqs.~(\ref{eq:our_L}) and (\ref{eq:ssMk_L}) for small  (). It is easily seen that our implementation has a smaller latency than the SS-Mk in \cite{gao1997sloping} for a prime greater than 3. It is also observed that  for , which is the same as the odd-even merge sort in \cite{Bat68sorting}.

\begin{table}[!th]
\caption{Comparison of latencies of sorting networks of  inputs via the SS-Mk in \cite{gao1997sloping} and our implementation.}\label{tab:latency}
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
&  &  &  \\
\hline
\cite{gao1997sloping} &  &  &  \\
\hline
Ours &  &  & \\
\hline
\end{tabular}
\end{center}
\end{table}

\subsection{Analysis of the number of sorters}
\label{sec:compsorter}
In the following, we compare the number of sorters of our algorithms with the SS-Mk in \cite{gao1997sloping}.
Since the distribution of sorters for an arbitrary sorting network of  inputs is not known, we assume that any -sorter () has the same delay and area as the basic -sorter and count the number of sorters.
We first derive the closed-form expression of the number of sorters for sorting  values via our Alg.~\ref{alg:nwaysort}.
Since the expression of the number of sorters for the SS-Mk was not provided in \cite{gao1997sloping}, we also derive the corresponding closed-form expression and compare it with our algorithm. The whole sorting network is constructed recursively by merging small sorted lists into a larger sorted list. We first derive the number of sorters of a merging network of  lists of  values, which is given by

where  and .
By summing up the numbers of sorters of all mergers in all stages, we obtain the total number of sorters, which is given by

As ,  is on the order of .
Similarly for the SS-Mk in \cite{gao1997sloping}, the number of sorters of the merging network of  lists of  values each is given by

where  , , and .
The total number of sorters of the sorting network via the SS-Mk in \cite{gao1997sloping} is given by

As ,  is on the order of .


According to the big-O expressions of  and , when  is bounded, the asymptotic bounds on the number of sorters required by both our Alg.~\ref{alg:nwaysort} and the SS-Mk in \cite{gao1997sloping} are given by , which is also the asymptotical bound for the odd-even and bitonic sorting algorithms~\cite{Bat68sorting, batcher1990bitonic}.
When  is fixed and  increases, the first term of the big-O expressions of  and  decreases first, then increases, and decreases to zero when . While other terms decrease monotonically with . Hence, if  is not constrained, the minimum value of  and  is one when , meaning a single -sorter is used.

\subsection{Comparison of the number of sorters}
\label{sec:comp}
According to the analysis of both our Alg.~\ref{alg:nwaysort} and the SS-Mk in \cite{gao1997sloping}, the number of sorters for sorting  inputs can be reduced by using a larger basic sorter. However, a very large basic sorter is not feasible due to some practical concerns, such as fan-in and cost. In this work, we assume that the basic sorter size is limited.
For a given , we take the total number of sorters in Eqs.~(\ref{eq:our_T}) and (\ref{eq:ssMk_T}) as a function of  with , where  is the upper bound of the basic sorter size.
When  is not a power of a prime, we append redundant inputs of 0's and get a larger  such that  is a power of a prime. Hence, we have , where  denotes the smallest prime larger than or equal to .
There exists an optimal  such that the total number of sorters is the minimum.
We search for the optimal 's for our Alg.~\ref{alg:nwaysort} and the SS-Mk~\cite{gao1997sloping} using MATLAB. By plugging the optimal 's into Eqs.~(\ref{eq:our_T}) and (\ref{eq:ssMk_T}), we obtain the total number of sorters for sorting networks of  inputs.

We compare the number of sorters for sorting networks via the Batcher's odd-even algorithm \cite{Bat68sorting}, our Alg.~\ref{alg:nwaysort}, and the SS-Mk \cite{gao1997sloping} for wide ranges of . The results are show in Fig.~\ref{fig:complexity_n1020}. The numbers of sorters are illustrated by staircase curves, because we use a larger sorting network for  not being a power of prime.
From Fig.~\ref{fig:complexity_n1020}, the Batcher's odd-even algorithm using 2-sorters always requires more sorters than both our Alg.~\ref{alg:nwaysort} and the SS-Mk in \cite{gao1997sloping}.
For both our Alg.~\ref{alg:nwaysort} and the SS-Mk \cite{gao1997sloping}, the number of sorters is smaller for a larger , meaning that using larger basic sorters reduces the number of sorters.
For the comparison of the number of sorters required by our Alg.~\ref{alg:nwaysort} and the SS-Mk \cite{gao1997sloping}, there are three scenarios with respect to three ranges of . We first focus on . For , our Alg.~\ref{alg:nwaysort} has fewer or the same number of sorters than the SS-Mk as shown in Fig.~\ref{fig:complexity_n1020}. For some segments in , our Alg.~\ref{alg:nwaysort} has fewer sorters than the SS-Mk.
For , the SS-Mk in \cite{gao1997sloping} needs fewer sorters.
For , we have similar results.
For , our Alg.~\ref{alg:nwaysort} has fewer or the same number of sorters than the SS-Mk as shown in Fig.~\ref{fig:complexity_n1020}. For some segments in , our Alg.~\ref{alg:nwaysort} has fewer sorters than the SS-Mk. For , the SS-Mk in \cite{gao1997sloping} needs fewer sorters.


Similarly, we compare the latency of the Batcher's odd-even algorithm, our Alg.~\ref{alg:nwaysort}, and the SS-Mk in \cite{gao1997sloping}. The latencies are obtained by plugging the corresponding optimal 's into Eqs.~(\ref{eq:our_L}) and (\ref{eq:ssMk_L}) and shown in Fig.~\ref{fig:latency_n1020} for .
From Fig.~\ref{fig:latency_n1020}, the Batcher's odd-even algorithm using 2-sorters has the largest latency. For both our Alg.~\ref{alg:nwaysort} and the SS-Mk \cite{gao1997sloping}, the latency can be reduced by having a larger .
The latency of our Alg.~\ref{alg:nwaysort} is not greater than the SS-Mk for  for both  and  as shown in Fig.~\ref{fig:latency_n1020}. This is because our Alg.~\ref{alg:nwaysort} tends to use large sorters, leading to less stages of sorters. We note that the latency goes up and down for some  in Fig.~\ref{fig:latency_n1020}. This is because of the switching from a smaller basic sorter to a larger one to reduce the number of sorters.


\begin{figure}[!h]
\centering
\includegraphics[width=8.5cm]{comp_capped_10and20_oddeven1}
\caption{Comparison of the number of sorters ( and ) for sorting  inputs via the SS-Mk in \cite{gao1997sloping} and our Alg.~\ref{alg:nwaysort}.}
\label{fig:complexity_n1020}
\end{figure}

\begin{figure}[!h]
\centering
\includegraphics[width=8.5cm]{latency_capped_10and20_oddeven1}
\caption{Comparison of the latency for sorting  inputs with  and  via the SS-Mk in \cite{gao1997sloping} and our Alg.~\ref{alg:nwaysort}.}
\label{fig:latency_n1020}
\end{figure}


To some researchers' interest, we also compare the number of sorters for  being a power of two. The results are shown in Table~\ref{tab:complexity_n20}, where columns two and three show the numbers of sorters for the SS-Mk and our Alg.~\ref{alg:nwaysort}, respectively, and column five shows the reduction by our Alg.~\ref{alg:nwaysort} compared with the SS-Mk \cite{gao1997sloping}. For our Alg.~\ref{alg:nwaysort}, there are up to 46\% fewer sorters than the SS-Mk in \cite{gao1997sloping} for , for .
It is also observed that a greater reduction is obtained for small , meaning our approach is more efficient for networks with larger sorters as basic blocks.

\begin{table}[!t]
\caption{Comparison of the number of sorters for sorting  inputs () with  via the SS-Mk in \cite{gao1997sloping} and our Alg.~\ref{alg:nwaysort}.}\label{tab:complexity_n20}
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
 & SS-Mk & Ours & Rd. (\%)\\
\hline
2	&	1   &   1	&	0.0	\\
\hline
4	&	5   &   5	&	0.0	\\
\hline
8	&	11   &     11	&	0.0	\\
\hline
16	&	38  &   30	&	21.05\\
\hline
32	&	95  &   65	&	31.58\\
\hline
64	&	347    &   207	&	40.35\\
\hline
128	&	566   &   326	&	42.40\\
\hline
256	&	1250	&    690	&	44.80\\
\hline
512	&	3952   &   3500	&	11.44\\
\hline
1024	&	8287   &   6378	&	23.04	\\
\hline
2048	&	15595	&   12039	&	22.80 \\
\hline
4096	&	44652	&   33891	&	24.10 \\
\hline
8192	&	143762	&   136574	&	5.00\\
\hline
16384   &   179631  &   183143  &   -1.96 \\
\hline
32768   &   1176250 &   1134692 &   3.53 \\
\hline
65536   &   1176250 &   1134692 &   3.53 \\
\hline
\end{tabular}
\end{center}
\end{table}



\section{Application in Threshold Logic}
\label{sec:appl}
In Sec.~\ref{sec:comp}, we assume all basic sorters in the sorting network are the same and measure the complexity by the number of sorters, since the distribution of sorters is unknown. This would overestimate the total complexity.
In this section, we focus on the threshold logic and measure the complexity by the number of threshold gates.
In the following, we first briefly introduce the threshold logic, which is very powerful for computing complex functions, such as parity function, addition, multiplication, and sorting, with significantly reduced number of gates. Then, we present an implementation of a large sorter in threshold logic. Last, we compare the complexity of sorting networks in terms of the number of gates.
This is a very narrow application in the sense that sorters are implemented by threshold logic and the inputs are binary values.

\subsection{Threshold logic}
A threshold function \cite{Mur71}  with  inputs (), , is a Boolean function whose output is determined by

where  is called the {\em weight} of  and  the {\em threshold}. In this paper we denote this threshold function as , and for simplicity sometimes denote it as , where   and . The physical entity realizing a threshold function is called a threshold gate, which can be realized with CMOS or nano technology. Fig.~\ref{fig:TG} shows the symbol of a threshold gate realizing (\ref{eq:threshold-def}).

\begin{figure}[!h]
\centering
\includegraphics[width=3.0cm]{TG}
\caption{Threshold gate realizing  for  inputs, , with corresponding weights  and a threshold .}
\label{fig:TG}
\end{figure}

\subsection{-sorter}
Binary sorters can be easily implemented in threshold logic. In \cite{Beiu1993enhanced}, a 2-by-2 comparator (2-sorter) was implemented by two threshold gates as shown in Fig.~\ref{fig:sorterTH}(a). Similarly, we introduce a threshold logic implementation of an -sorter as shown in Fig.~\ref{fig:sorterTH}(b), where  threshold gates are required. As shown in Fig.~\ref{fig:sorterTH}, the number of gates of an -sorter scales linearly with the number of inputs .
Hence, large sorters are preferred to be used as basic blocks. However, larger sorters are more complex and expensive to be implemented.
For practical concerns, such as fan-in and cost, some limit on the size of basic sorters is assumed.

\begin{figure}[!h]
\centering
\includegraphics[width=7.5cm]{sorterTH}
\caption{Sorters implemented in threshold logic (a) 2-sorter; (b) -sorter.}
\label{fig:sorterTH}
\end{figure}

\subsection{Analysis of number of gates}
In the following, we assume all gates are the same and derive the total number of gates. The sorting network of  inputs is composed of multiple stages, of which each partially sorts  values. Not all values in each stage participate the comparison-and-switch operation.
A simple way to count the gates is to insert buffer gates in each stage to store values without involving any sorting operation. Buffer insertion is also needed for implementation of threshold logic in some nanotechnology, where synchronization is required for correction operation.
Hence, each stage contains  gates and the total number of gates is obtained by multiplying  to the latency.
Note that  does not have to be a power of .
Hence, the total number of gates of our Alg.~\ref{alg:nwaysort} and the SS-Mk \cite{gao1997sloping} are simply given by

and

If  is bounded, the total numbers of gates in Eqs.~(\ref{eq:Gour_L}) and (\ref{eq:GssMk_L}) have an order of , which is the same as the order for the numbers of sorters via our Alg.~\ref{alg:nwaysort} and the SS-Mk in \cite{gao1997sloping} in Sec.~\ref{sec:compsorter}.

To derive the accurate number of gates, we first derive the number of buffers added for Eqs.~(\ref{eq:Gour_L}) and (\ref{eq:GssMk_L}).
When  is a power of prime, the number of buffers for sorting  values via our Alg.~\ref{alg:nwaysort} and the SS-Mk \cite{gao1997sloping} can be easily obtained due to a regular structure.
For our Alg.~\ref{alg:nwaysort}, the number of buffers is given by  for  and  for . Similarly, we derive the number of buffers for the SS-Mk in \cite{gao1997sloping}, which is given by  for  and  for .
By subtracting the number of buffers from Eqs.~(\ref{eq:Gour_L}) and (\ref{eq:GssMk_L}), we obtain the total numbers of gates for our algorithm and the SS-Mk as shown in the following,

and

Though it would overestimate the total number of gates by adding buffers. However, the asymptotic gate counts are not affected, since both  and  have the same order of .

\subsection{Comparison of the number of gates}
In the following, we first compare the number of gates with consideration of buffers.
Using the same idea as in Sec.~\ref{sec:compsorter}, we search for the optimal 's of Eqs.~(\ref{eq:Gour_L}) and (\ref{eq:GssMk_L}) using MATLAB.
For  and , the numbers of gates of the SS-Mk and our two implementations are illustrated in Fig.~\ref{fig:comp_cap_n1020TG}. We also plot the odd-even sorting for comparison.
The curves in Fig.~\ref{fig:comp_cap_n1020TG} are segmented linear lines. This can be explained by Eqs.~(\ref{eq:Gour_L}) and (\ref{eq:GssMk_L}), which are functions of  and latency.
From Fig.~\ref{fig:comp_cap_n1020TG}, the Batcher's odd-even algorithm using 2-sorters has more gates than both our algorithm and the SS-Mk in \cite{gao1997sloping}.
For both our Alg.~\ref{alg:nwaysort} and the SS-Mk \cite{gao1997sloping}, the number of gates  is smaller with a larger , meaning that using larger basic sorters reduces the number of gates.
For the comparison of the number of gates required by our Alg.~\ref{alg:nwaysort} and the SS-Mk \cite{gao1997sloping}, there are also three scenarios with respect to three ranges of .
We first focus on . For , our Alg.~\ref{alg:nwaysort} has fewer or the same number of gates than the SS-Mk as shown in Fig.~\ref{fig:comp_cap_n1020TG}. For , our Alg.~\ref{alg:nwaysort} has the same number of gates as the SS-Mk. For , the SS-Mk in \cite{gao1997sloping} needs fewer gates.
For , we have similar results.
For , our Alg.~\ref{alg:nwaysort} has fewer or the same number of gates than the SS-Mk. For some segments in , our Alg.~\ref{alg:nwaysort} has fewer gates than the SS-Mk. For , the SS-Mk in \cite{gao1997sloping} needs fewer gates.


Similarly, we compare the latency of our sorting algorithm with the SS-Mk in \cite{gao1997sloping}. The latencies are obtained by plugging the corresponding optimal 's into Eqs.~(\ref{eq:Gour_L}) and (\ref{eq:GssMk_L}) and shown in Fig.~\ref{fig:latency_cap_n1020TG} for .
Note that the minimization of the number of gates is essentially to minimize the latency, since each  is fixed in Eqs.~(\ref{eq:Gour_L}) and (\ref{eq:GssMk_L}).
Fig.~\ref{fig:latency_cap_n1020TG} also shows the minimal latencies of the Batcher's odd-even algorithm. All the latencies are illustrated by staircase curves. From Fig.~\ref{fig:comp_cap_n1020TG}, the Batcher's odd-even algorithm using 2-sorters has the largest latency.
For both our Alg.~\ref{alg:nwaysort} and the SS-Mk \cite{gao1997sloping}, the latency can be reduced by having a larger .
The latency of our Alg.~\ref{alg:nwaysort} is not greater than the SS-Mk for  for both  and  as shown in Fig.~\ref{fig:latency_cap_n1020TG}. This is because our Alg.~\ref{alg:nwaysort} tends to use large basic sorters, leading to less stages.

\begin{figure}[!t]
\centering
\includegraphics[width=8.5cm]{comp_capped_10and20TG_oddeven1}
\caption{Comparison of the number of gates ( and ) for sorting  inputs via the SS-Mk in \cite{gao1997sloping} and our Alg.~\ref{alg:nwaysort}.}
\label{fig:comp_cap_n1020TG}
\end{figure}

\begin{figure}[!t]
\centering
\includegraphics[width=8.5cm]{latency_capped_10and20TG_oddeven1}
\caption{Comparison of the latency ( and ) for sorting  inputs via the SS-Mk in \cite{gao1997sloping} and our Alg.~\ref{alg:nwaysort}.}
\label{fig:latency_cap_n1020TG}
\end{figure}

We also compare the number of gates with buffers for  being a power of two.
The numbers of gates are minimized by varying  according to Eqs.~(\ref{eq:Gour_L}) and (\ref{eq:GssMk_L}) for our algorithm and the SS-Mk \cite{gao1997sloping}. Note the optimal 's are different from those in Sec.~\ref{sec:comp}.
The results are shown in Table~\ref{tab:comp_n2010TG}, where columns two to four show the numbers of gates for the SS-Mk, our Alg.~\ref{alg:nwaysort}, and the reduction of our Alg.~\ref{alg:nwaysort}, respectively, with , and columns five to seven show those with . For  and , there are up to 25\% and 39\% fewer gates, respectively, than the SS-Mk in \cite{gao1997sloping} for  with .
It is observed that fewer and the same number of gates are needed for  than for  for all  with . The reduction percentage of  is also greater than or equal to that of  for all  with  but .
This means our sorting network takes better advantage of larger basic sorters.


\begin{table}[!t]
\caption{Comparison of the number of gates with buffers for sorting  inputs () with  via the SS-Mk in \cite{gao1997sloping} and our Alg.~\ref{alg:nwaysort}.}\label{tab:comp_n2010TG}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
\multirow{3}{*}{} & \multicolumn{3}{c|}{} & \multicolumn{3}{c|}{}\\
\cline{2-7}
& \multirow{2}{*}{SS-Mk} & \multirow{2}{*}{Ours} & Rd. & \multirow{2}{*}{SS-Mk} & \multirow{2}{*}{Ours} & Rd. \\
& & & (\%) & & & (\%)\\
\hline
	&	1   &   1	&	0.00	    &	1	 &	 1  &   0.00\\
\hline
	&	4   &   4	&	0.00		&	4    &   4	&	0.00\\
\hline
	&	8   &     8	&	0.00	    &	32   &   32	&	0.00\\
\hline
	&	16  &   16	&	0.00		&	96	&	 80  &    16.67\\
\hline
	&	256  &   192	&	25.00		&	256 & 192	&	25.00\\
\hline
	&	768    &   512	&	33.33		&	896	&	768 & 14.29\\
\hline
	&	1792   &   1152	&	35.71		&	2304	&	1920 & 16.67\\
\hline
	&	4608	&    2816	&	38.89	&	4608	&	3840 & 16.67	\\
\hline
	&	12800   &   11264	&	12.00		&	12800	&	11264    & 12.00\\
\hline
	&	27648   &   21504	&	22.22		&	31744	&	28672 & 9.68\\
\hline
	&	63488	&   49152	&	22.58 	&	63488	&	57344 & 9.68\\
\hline
	&	163840	&   122880	&	25.00 	&	192512	&	184320 & 4.26\\
\hline
	&	376832	&   327680	&	13.04	&	385024	&	368640 & 4.26\\
\hline
   &   770048  &   737280  &   4.26   &   770048  &  737280 &  4.26\\
\hline
   &   2162688  &   1900544  &   12.12   &   2162688  &  2162688 &  0.00 \\
\hline
   &   4325376  &   3801088  &   12.12   &   4325376  &  4325376 &  0.00 \\
\hline
\end{tabular}
\end{center}
\end{table}

For  being a power of prime, we compare the number of gates without buffers according to Eqs.~(\ref{eq:GBour_L}) and (\ref{eq:GBssMk_L}).
For , we search for the same 's for our Alg.~\ref{alg:nwaysort} and the SS-Mk with the minimum number of gates. The results are shown in Tables~\ref{tab:comp_n10TGwoBuf} and \ref{tab:comp_n20TGwoBuf} for  and , respectively, where columns three and four show the numbers of gates for the SS-Mk and our Alg.~\ref{alg:nwaysort}, and column five shows the reduction of our Alg.~\ref{alg:nwaysort}.
For all 's except for , our Alg.~\ref{alg:nwaysort} has no more gates than the SS-Mk in \cite{gao1997sloping}.
There are up to 13\% and 23\% fewer gates than the SS-Mk in \cite{gao1997sloping} for  and , respectively. This means our sorting network takes better advantage of larger basic sorters.
We also remark that using a larger sorter size  may reduce the number of gates for sorting  inputs.
For all common 's for  in Table~\ref{tab:comp_n10TGwoBuf} and  in Table~\ref{tab:comp_n20TGwoBuf}, the same number of gates is needed, since the same sorter size  is used.
For all remaining 's except for  in Table~\ref{tab:comp_n10TGwoBuf}, there is a  corresponding larger 's in Table~\ref{tab:comp_n20TGwoBuf} with fewer gates.
For  in Table~\ref{tab:comp_n10TGwoBuf} and  in Table~\ref{tab:comp_n20TGwoBuf}, the latter has about 1\% more gates than the former, but accounts for 45\% more inputs.


\begin{table}[!t]
\caption{Comparison of the number of gates without buffers for sorting  inputs for  via the SS-Mk in \cite{gao1997sloping} and our Alg.~\ref{alg:nwaysort}.}\label{tab:comp_n10TGwoBuf}
\begin{center}
\scalebox{0.95}{
\begin{tabular}{|c|c|c|c|c|}
\hline
\multirow{2}{*}{} & \multirow{2}{*}{} & \multicolumn{3}{c|}{} \\
\cline{3-5}
& & \multirow{1}{*}{SS-Mk} & \multirow{1}{*}{Ours} & Rd. (\%)\\
\hline
 & 	    &	2   &   2	&	0.00	    \\
\hline
 & 	    &	3   &   3	&	0.00		\\
\hline
 & 	    &	5   &   5	&	0.00	    \\
\hline
 & 	    &	7   &   7	&	0.00		\\
\hline
 &    &   29	&	29    & 0.00\\
\hline
 &    &   118	&	110 & 6.78\\
\hline
 &   &   197	&	188 & 4.57\\
\hline
 &    &   305	&	269 & 11.80\\
\hline
 &    &   1067 &	998 & 6.47\\
\hline
 &     &   1450  &  1315 &  9.31\\
\hline
 &     &   2942  &  2942 &  0.00 \\
\hline
 &     &   5072  &  4728 &  6.78 \\
\hline
 &    &   13489  &  12140 &  10.00 \\
\hline
 &    &   22801  &  20411 &  10.48 \\
\hline
 &  &  48126  &  48126 &  0.00 \\
\hline
 &    &   63354  &  62254 &  1.74 \\
\hline
 &    &   108175  &  97265 &  10.09 \\
\hline
 &  & 278526  &  278526 &  0.00 \\
\hline
 &  &   377375  &  330236 &  12.49 \\
\hline
 &  & 655358  &  655358 &  0.00 \\
\hline
 &  & 688713  &  704693 &  -2.32 \\
\hline
 &  &   1443791  &  1259711 &  12.75 \\
\hline
\end{tabular}
}
\end{center}
\end{table}

\begin{table}[!t]
\caption{Comparison of the number of gates without buffers for sorting  inputs for  via the SS-Mk in \cite{gao1997sloping} and our Alg.~\ref{alg:nwaysort}.}\label{tab:comp_n20TGwoBuf}
\begin{center}
\scalebox{0.95}{
\begin{tabular}{|c|c|c|c|c|}
\hline
\multirow{2}{*}{} & \multirow{2}{*}{} & \multicolumn{3}{c|}{} \\
\cline{3-5}
& & \multirow{1}{*}{SS-Mk} & \multirow{1}{*}{Ours} & Rd. (\%)\\
\hline
 & 	    &	2   &   2	&	0.00	    \\
\hline
 & 	    &	3   &   3	&	0.00		\\
\hline
 & 	    &	5   &   5	&	0.00	    \\
\hline
 & 	    &	7   &   7	&	0.00		\\
\hline
 & 	&	11  &   11	&	0.00		\\
\hline
 & 	&	13    &   13	&	0.00		\\
\hline
 & 	&	17   &   17	     &	0.00         \\
\hline
 & 	&	19	&    19	      &	0.00         \\
\hline
 & 	&	118   &   110	&	6.78		 \\
\hline
 & 	&	197   &   188	&	4.57		 \\
\hline
 & 	&	305	&   269	      &	11.80 	     \\
\hline
 & 	&	1117	&   917	&	17.91 	 \\
\hline
 & 	&	1450	&   1315	&	9.31	 \\
\hline
 &    &   1814  &   1454  &   19.85     \\
\hline
 &    &   3970  &   3074  &   22.57     \\
\hline
 &    &   5501  &   4205  &   23.56     \\
\hline
 &    &   13489  &   12140  &   10.00    \\
\hline
 &    &   22801  &   20411  &   10.48    \\
\hline
 &    &   29107  &   26668  &   8.38    \\
\hline
 &    &   54703  &   50763  &   7.20    \\
\hline
 &    &   63354  &   62254  &   1.74     \\
\hline
 &    &   108175  &   97265  &   10.09   \\
\hline
 &    &   156812  &   143443  &   8.53  \\
\hline
 &    &   239590  &   221052  &   7.74  \\
\hline
 &    &   564513  &   562214  &   0.41  \\
\hline
 &    &   688713  &   704693 &  -2.32 \\
\hline
 &   &   1230724 &   1271788 &   -3.34\\
\hline
\end{tabular}
}
\end{center}
\end{table}


\section{Conclusion}
\label{sec:conclusion}
In this work, we proposed a new merging algorithm based on -sorters for parallel sorting networks, where  is prime. Based on the -way merging, we also proposed a merge sorting algorithm. Our sorting algorithm is a direct generalization of odd-even merge sort with -sorters as basic blocks.
By using larger sorters (), the number of sorters as well as the latency is reduced greatly. In comparison with other multiway sorting networks in \cite{gao1997sloping}, our implementation has a smaller latency and fewer sorters for wide ranges of . We also showed an application of sorting networks implemented by linearly scaling sorters in threshold logic and have a similar conclusion that the number of gates can be greatly reduced by using larger sorters.




\appendices
\section{Proofs}
\subsection{Proof of Lemma~\ref{lm:subgroupsort}}
\label{pf:subgroupsort}
\begin{proof}
  The proof of the lemma can be reduced to showing that for  any two wires  of each list are sorted as shown in Fig.~\ref{fig:mnsort}(b). We prove the lemma by contradiction.
  The inputs satisfy  for  and .
  Suppose there exist  and  such that . Since the sorter for   acts as a permutation of the index , we denote such permutation of the sorter connecting wire  as . Because  is bijection, an inverse  exists. Then we have  for , where the ``'' is because the inputs are sorted and the ``'' is due to the permutation.
  There are  inputs of  satisfying . However, at most  outputs satisfy  for , resulting in a contradiction. Hence, all lists are self sorted after applying -sorters.
\end{proof}


\subsection{Proof of Lemma~\ref{lm:sorter4case}}
\label{pf:sorter4case}
\begin{proof}
 First, we show that the first connections of adjacent two sorters belong to either the same list or adjacent two lists. Let  and  be the first connections of adjacent two sorters  and , respectively, where  denotes wire  in list .
 If , the connection of  in list  should be wire ; otherwise,  would have a valid connection in list . For lists  to , only wires  in each list are connected by , since wire  can be connected to the preceding list only by a -spaced sorter. Hence,  is the last -spaced sorter in stage 1 and  does not exist.
 Similarly, we can show that the last connections of adjacent two sorters  and  belong to either the same list or adjacent two lists. This gives us a total of four cases as shown in Fig.~\ref{fig:m2sort}, where  for Fig.~\ref{fig:m2sort}(a)-(c), and  for Fig.~\ref{fig:m2sort}(d) such that  and  have a size of at least two.

 If  is prime, no adjacent two sorters belong to case IV, which is equivalent to showing that  is a composite number if case IV in Fig.~\ref{fig:m2sort} exists. Assume two adjacent sorters  and  belong to case IV. Let the first connection of  be  and the last connection of  be . The last connection of  satisfies . We have . Since case IV is not possible in the first stage, we have . Since two adjacent sorters connect two adjacent wires in at least one list, we have .
 If ,  would connect the last and first wires of adjacent lists, respectively, in which case  does not exist. We have .
So  should have a proper factor dividing  or . Hence,  is a composite number.
\end{proof}

\subsection{Proof of Theorem~\ref{thm:groupsort}}
\label{pf:groupsort}
\begin{proof}
  The theorem can be proved by induction on .
  In stage 1, -sorters are applied on corresponding wires of all  lists. According to Lemma~\ref{lm:subgroupsort}, the outputs of each list are sorted.
  Assume any two adjacent wires  and  in list  are sorted after stage ,  for  and . We will show that  for  and .

  According to Lemma~\ref{lm:sorter4case}, for a prime , there are three cases of two adjacent sorters  and  as shown in Fig.~\ref{fig:m2sort}(a)-(c).
  \begin{enumerate}
    \item For case I, let  and  be the two adjacent wires in list  connected by adjacent two sorters in stage  for . According to Lemma~\ref{lm:subgroupsort} (), the outputs of each list are sorted.
    \item For case II, there is an additional single wire  connected by . If , we have . The last connection of  can be removed without changing the order of others in .
         and the revised  reduce to case I and the outputs are sorted according to Lemma~\ref{lm:subgroupsort}. If , we have . This is because they are connected by the same sorter in stage . Then, we have , which are sorted outputs in list . Remove , and , the remaining of  and  reduce to a smaller configuration of case II. With recursively applying the above approach,  and  either reduce to a smaller case I or a single wire, both of which gives sorted outputs.
    \item For case III, there is an additional single wire  connected by the first sorter. Similarly, the two sorters can be reduced to either a case I or a smaller configuration of case III and the outputs of two adjacent wires in each list are sorted.
  \end{enumerate}
  Assume all lists are self-sorted after stage , we have  for .
  For stage , all wires in lists  have connections with some sorters.
  We have  for  and . Hence, lists  are self-sorted after stage .
  For list 1,  and , we have . We have , since list 1 is self-sorted after stage  and  for . We also have . Hence, list 1 is self-sorted after stage , . Due to symmetry, list  is also self-sorted after stage , .



  To prove that the outputs of  sorted lists  for  after stage  are combined as a single sorted list in stage , we need to show that  for  and  for . Since  and , we have  for . Similarly, we have  for 
\end{proof}


\subsection{Proof of Lemma~\ref{lm:mergen0s}}
\label{pf:mergen0s}
\begin{proof}
  In stage , there are  sorted lists of  values with respect to each  ().
  Since the outputs of each merging network are sorted after stage , we can replace each merging network by an -sorter.
  According to Lemma~\ref{lm:subgroupsort}, the outputs of each new formed list after stage  are sorted,  for .
  Since the corresponding wires in the new lists are connected by the same -sorter in stage , we have  for . Hence,  for .

  For , it is equivalent to prove that  if  for .
  For any  in stage , there are  lists of  values. Suppose  for  and .
  If  () zeros of  are from the same list of the original  sorted lists, there are at most  zeros of  from that same list. Since  for  are from at most  original lists, there are at most  zeros in , implying that .
  Hence,  if  for .
\end{proof}

\subsection{Proof of Theorem~\ref{thm:nwaymerge}}
\label{pf:nwaymerge}
\begin{proof}
  In stage 1, all outputs with respect to the operation of the same Alg.~\ref{alg:nway} are sorted.
  For any  in stage , according to Lemma~\ref{lm:mergen0s}, at most  consecutive lists are not full of zeros. All preceding lists are all-zero lists and all following lists are all-one lists.
  Hence, the combining network in stage  is to sort  lists of  values, which is reduced to Alg.~\ref{alg:nway}. In stage , we have  and the single sorted list,  , , contains  values, implying all inputs are sorted as a single list.
\end{proof}


\bibliographystyle{IEEEtran}
\bibliography{TL}

\end{document} 