\documentclass{LMCS}

\overfullrule=2 pt

\usepackage{array}
\usepackage{epic, eepic}
\usepackage{amssymb,amsmath,stmaryrd}
\usepackage[ruled, vlined]{algorithm2e}
\usepackage{slashbox}

\usepackage{gastex,hyperref,enumerate}







\newcounter{compressEnum}
\renewcommand{\thecompressEnum}{$\roman{compressEnum}$}
\newenvironment{compressEnum}
{\setcounter{compressEnum}{0}}

{}

\newcommand{\itCompress}{\stepcounter{compressEnum}{(\thecompressEnum) }}



\def\frp#1{\ensuremath{\langle #1\rangle}}


\makeatletter

\let\c@lemm\c@theo
\let\c@coro\c@theo
\let\c@defi\c@theo
\let\c@assu\c@theo

\makeatother



\def\eodsymbol{\ensuremath\square}
\def\eopsymbol{\ensuremath\blacksquare}









\def\sg{\mathrel[\joinrel\mathrel[}
\def\sd{\mathrel]\joinrel\mathrel]}



\def\abs#1{\ensuremath{\lvert #1\rvert}}
\def\norm#1{\ensuremath{\lVert #1\rVert}}
\def\normeinf#1{\ensuremath{\lVert #1\rVert_{\infty}}}

\newcommand{\pre}{\mathsf{pre}}
\newcommand{\cpre}[2]{\mathsf{Cpre}_{#1}^{#2}}
\newcommand{\cprestar}[1]{\mathsf{Cpre}_{#1}^*}
\newcommand{\Post}{\mathsf{Post}}
\newcommand{\Pre}{\mathsf{Pre}}
\newcommand{\CPre}{\mathsf{CPre}}

\newcommand{\nat}{\mathbb N} 
\newcommand{\sposrat}{{\mathbb Q}^{> 0}}
\newcommand{\posrat}{{\mathbb Q}^{\geq 0}}
\newcommand{\posreal}{{\mathbb R}^{\geq 0}}
\newcommand{\sposreal}{{\mathbb R}^{> 0}}
\newcommand{\real}{{\mathbb R}}
\newcommand{\zed}{{\mathbb Z}}

\newcommand{\closure}[1]{\downarrow \!\!#1}
\newcommand{\sem}[1]{\sg \mathrel{#1} \sd}

\newcommand{\ar}[1]{\lfloor \mathrel {#1} \rfloor}
\newcommand{\arup}[1]{\lceil \mathrel {#1} \rceil}
\newcommand{\bigar}[1]{\big\lfloor \!  \mathrel{#1}\!\! \big\rfloor}
\newcommand{\bigarup}[1]{\big\lceil \! \mathrel{#1}\!\! \big\rceil}
\newcommand{\bigarupL}{\big\lceil}
\newcommand{\bigarupR}{\big\rceil}
\newcommand{\Bigarup}[1]{\Big\lceil \! \mathrel{#1}\!\! \Big\rceil}


\renewcommand{\l}{{\ell}}

\newcommand{\Loc}{{\sf Loc}} 

\def\intp#1{\ensuremath{\lfloor #1\rfloor}}
\newcommand{\tuple}[1]{\langle #1 \rangle}

\newcommand{\last}{\mathsf{last}}
\renewcommand{\inf}{\mathsf{inf}}

\newcommand{\A}{\mathcal{A}}
\newcommand{\B}{\mathcal{B}}
\newcommand{\F}{\mathcal{F}}
\newcommand{\G}{{\mathcal{G}}}
\renewcommand{\L}{\mathcal{L}}
\newcommand{\N}{\mathcal{N}}
\newcommand{\W}{\mathcal{W}}

\newcommand{\DAG}{{\sc dag}}


\newcommand{\odd}{\mathsf{odd}}

\newcommand{\ceilOdd}[1]{\lceil \mathrel {#1} \rceil^{\mathsf{odd}}}
\newcommand{\ceilEven}[1]{\lceil \mathrel {#1} \rceil^{\mathsf{ even}}}
\newcommand{\true}{{\sf true}}
\newcommand{\false}{{\sf false}}

\newcommand{\MH}{{\sf MH}}
\newcommand{\KV}{{\sf KV}}
\newcommand{\KVMH}{{\sf KVMH}}
\newcommand{\Max}{{\sf Max}}


\def\doi{5 (1:5) 2009}
\lmcsheading {\doi}
{1--20}
{}
{}
{Aug.~13, 2007}
{Mar.~\phantom{0}2, 2009}
{}   

\begin{document}



\title[]{Antichains for the Automata-Based Approach to Model-Checking\rsuper*}

\author[L.~Doyen]{Laurent Doyen\rsuper a} \address{{\lsuper a}CCS,
  \'{E}cole Polytechnique F\'ed\'erale de Lausanne, Switzerland}
\email{laurent.doyen@epfl.ch}



\author[J.-F.~Raskin]{Jean-Fran\c{c}ois Raskin\rsuper b}	\address{{\lsuper b}CS, Universit\'{e} Libre de Bruxelles, Belgium}	\email{jraskin@ulb.ac.be}  


\keywords{alternating B\"uchi automata, nondeterministic B\"uchi automata, emptiness, universality, language inclusion, antichains.}
\subjclass{F.4.1, I.1.2}
\titlecomment{{\lsuper *}A preliminary version of this paper appeared in the
  \emph{Proceedings of the 13th International Conference on Tools and
    Algorithms for the Construction and Analysis of Systems} (TACAS),
  Lecture Notes in Computer Science 4424, Springer-Verlag, 2007,
  pp. 451-465.\\\indent This research was supported in part by the FRFC
  project ``Centre F\'ed\'er\'e en V\'erification'' funded by the
  Belgian National Science Foundation (FNRS) under grant nr 2.4530.02,
  by the PAI program Moves supported by the Belgian Federal
  Gouvernment: ``Fundamental Issues in Modelling, Verification and
  Evolution of Software'' ({\tt http://moves.vub.ac.be}), by the Swiss
  National Science Foundation, and by the European COMBEST project.  }




\begin{abstract}
  We propose and evaluate antichain algorithms to solve the universality and
  language inclusion problems for nondeterministic B\"uchi automata,
  and the emptiness problem for alternating B\"uchi automata.
  To obtain those algorithms, we establish the existence of
  simulation pre-orders that can be exploited to efficiently evaluate fixed
  points on the automata defined during the complementation step (that
  we keep implicit in our approach). We evaluate the performance of the
  algorithm to check the universality of B\"uchi automata
  using the random automaton model recently proposed by
  Tabakov and Vardi.  We show that on the difficult instances of this
  probabilistic model, our algorithm outperforms the standard ones by
  several orders of magnitude. 
\end{abstract} 

\maketitle

\section{Introduction}

In the automata-based approach to model-checking~\cite{vw86,vw94},
programs and properties are modeled by finite automata. Let $A$ be a
finite automaton that models a program and let $B$ be a finite
automaton that models a specification that the program should satisfy.
Correctness is defined by the language inclusion $\L(A) \subseteq \L(B)$,
that is all traces of the program (executions) should be traces of the
specification.  To solve the inclusion problem, the classical automata-theoretic 
solution constructs an automaton for $\L^c(B)$ the complement of
the language of the automaton $B$ and then checks
that $\L(A) \cap {\L^c(B)}$ is empty (the later intersection being
computed as a synchronised product).  

In the finite case, the program and the specification are
automata over finite words (NFA) and the construction for the
complementation is conceptually simple: it is achieved by a classical
subset construction.  In the case of infinite words, the program and
(or at least) the specification are nondeterministic B\"uchi automata
(NBW). The NBW are also complementable; this was first proved
by B\"uchi~\cite{buechi62}.  However, the result is
much harder to obtain than in the case of NFA.  The original
construction of B\"uchi has a $2^{O({2^n})}$ worst case complexity (where~$n$ 
is the size of the automaton to complement) which is not optimal.
In the late eighties Safra in~\cite{Safra88}, and later Kupferman and
Vardi in~\cite{kupferman97weak}, have given optimal complementation
procedures that have $2^{O({n \log n})}$ complexity (see~\cite{Michel88} for the
lower bound).  While for finite words, the classical algorithm
has been implemented and shown practically usable, for infinite
words, the theoretically optimal solution is difficult to
implement and very few results are known about their practical
behavior. 
Recent implementations have shown that applying these algorithms for automata 
with more than around ten states is hard~\cite{TabakovV07,GurumurthyKSV03}.
Such sizes are clearly not sufficient in practice. 
As a consequence, tools like {\sc Spin}~\cite{spin} that
implement the automata-theoretic approach to model-checking ask
either that the complement of the specification is explicitly given
or they limit the specification to properties that are expressible in {\sc LTL}.

In this paper, we propose a new approach to check $\L(A) \subseteq \L(B)$ 
that can handle much larger B\"uchi automata. In a recent paper, 
we have shown that the classical subset construction can
be avoided and kept implicit for checking language inclusion and
language universality for NFA and their alternating extensions~\cite{cav06}. 
Here, we adapt and extend that technique to the more intricate case of
automata on infinite words.

To present the intuition behind our new techniques, let us consider a
simpler setting of the problem. Assume that we
are given a NBW $B$ and we want to check if $\Sigma^{\omega}
\subseteq \L(B)$, that is to check if $\L(B)$ is universal.  First,
remember that $\L(B)$ is universal when its complement $\L^c(B)$ is empty.  The
classical algorithm first complements $B$ and then checks for
emptiness. The language of a NBW is nonempty if there exists an
infinite run of the automaton that visits accepting locations
infinitely often.  The existence of such a run can be established
in polynomial time by computing the following fixed point $\F \equiv \nu y \cdot \mu x \cdot ( \Pre(x)
\cup ( \Pre(y) \cap \alpha ))$ where $\Pre$ is the predecessor
operator of the automaton (given a set $L$ of locations it returns the
set of locations that can reach $L$ in one step) and $\alpha$ is the set
of accepting locations of the automaton. The automaton is non-empty if
and only if its initial location is a member of the fixed
point $\F$.  This well-known algorithm is quadratic in the size of the automaton.  
Unfortunately, the automaton that accepts the language $\L^c(B)$ is usually 
huge and the evaluation of the fixed point is unfeasible for all but the smallest 
specifications~$B$.  To overcome this difficulty, we make the following observation:
if $\preceq$ is a \emph{simulation} pre-order on the locations of $B^c$ 
($\l_1 \preceq \l_2$ means $\l_1$ can simulate $\l_2$) which is compatible with
the accepting condition (if $\l_1 \preceq \l_2$ and $\l_2 \in \alpha$
then $\l_1 \in \alpha$), then the sets that are computed during the
evaluation of $\F$ are all \emph{$\preceq$-downward-closed} (if an element
$\l$ is in the set then all $\l' \preceq \l$ are also in the set). Then
$\preceq$-downward-closed sets can be represented by their $\preceq$-maximal elements 
and if operations on such sets can be computed directly on their representation, 
we have the ingredients to evaluate the fixed point in a more efficient way.
For an automaton~$\B$ over finite words, set inclusion would be a typical example 
of a simulation relation for~$\B^c$~\cite{cav06}. The same technique can be applied
to avoid subset constructions in games of imperfect information~\cite{DDR06,CDHR07}.
We generically call \emph{antichain algorithms} the techniques that are based
on compact representation of downward-closed because when the simulation
is a partial order (and it usually is), the maximal elements form an antichain,
i.e., a set of incomparable elements.


We show that the classical constructions for B\"uchi automata that are
used in the automata-theoretic approach to model-checking are all
equipped with a simulation pre-order that exists by construction and
does not need to be computed. On that basis we propose antichain algorithms
to check universality of NBW, language inclusion for NBW, and
emptiness of alternating B\"uchi automata (ABW). Each of these problems
reduces to emptiness checking of NBW, via classcial constructions.

The novelty of our antichain algorithms is to realize that only downward-closed
sets can be computed by the fixed point for emptiness, and therefore to use more 
succinct representations of those downward-closed sets, by storing maximal elements only. 
Moreover, such compact representations do not come at the price of an increase 
in the time complexity for the basic operations that are necessary to check emptiness
(such as $\cap$, $\cup$, and $\Pre$), i.e., we show that they are computable in time
polynomial in the size of the compact representation, while this size can be exponentially
smaller than the actual downward-closed set.
Note that, while a compact representation exists in general (i.e., for any
simulation pre-order), we have no generic result that would show that efficient
computations can be done symbolically in all cases. Therefore, we have to instantiate
the approach for each class of problem, and find efficient algorithms for
the basic operations.






We evaluate an implementation of our algorithm for the
universality problem of NBW and on a randomized model recently
proposed by Tabakov and Vardi.  We show that the performance of the
antichain algorithm on this randomized model outperforms by several order of
magnitude the existing implementations of the Kupferman-Vardi
algorithm~\cite{TabakovV07,GurumurthyKSV03}.  While the classical
solution is limited to automata of size 8 for some parameter values of
the randomized model, we are able to handle automata with more than
one hundred locations for the same parameter values. We have
identified the hardest instances of the randomized model for our
algorithms and show that we can still handle problems with several
dozens of locations for those instances.

\paragraph{{\it Structure of the paper.}}
In Section~\ref{sec:definitions}, we give all necessary definitions related to 
B\"uchi automata, and we recall the Kupferman-Vardi and
Miyano-Hayashi constructions that are used for complementation of NBW.
The reader interested in the general theory behind our technique can read 
Section~\ref{sec:fixed-point} without going into the details of those constructions
(only the definitions of NBW and emptiness are useful to understand Section~\ref{sec:fixed-point}). 
The notion of simulation pre-order for a B\"uchi automaton is presented and we prove 
that the fixed point needed to establish emptiness of nondeterministic B\"uchi automata
handles only downward closed sets for such pre-orders. 
We use this observation in Section~\ref{sec:emptiness-alternating} to define an antichain algorithm
to decide emptiness of ABW. In Section~\ref{sec:universality}, we
adapt the technique for the universality problem of NBW. In
Section~\ref{sec:implementation}, we report on the performances of the
algorithm for universality, and in Section~\ref{sec:inclusion-NBW},
we extend those ideas to obtain an antichain algorithm for language inclusion
of NBW. 



\section{B\"uchi Automata and Classical Algorithms}\label{sec:definitions}


\begin{defi}\label{def:ABW}
An \emph{alternating B\"uchi automaton} (ABW) is a tuple 
$\A = \tuple{\Loc, \iota, \Sigma, \delta, \alpha}$ where: 

\begin{enumerate}[$\bullet$]

\item $\Loc$ is a finite set of states (or locations). 
The \emph{size} of $\A$ is $\abs{\A} = \abs{\Loc}$; 

\item $\iota \in \Loc$ is the \emph{initial} state;

\item $\Sigma$ is a finite \emph{alphabet};

\item $\delta: \Loc \times \Sigma \to \B^+(\Loc)$ is the \emph{transition function} 
where $\B^+(\Loc)$ is the set of positive boolean formulas over $\Loc$, 
{\it i.e.} formulas built from elements in  $\Loc \cup \{\true, \false\}$ 
using the boolean connectives $\land$ and $\lor$; 

\item $\alpha \subseteq \Loc$ is the set of accepting states.

\end{enumerate}
\end{defi}












We say that a set $X \subseteq \Loc$ \emph{satisfies} a
formula $\varphi \in \B^+(\Loc)$ (noted $X \models \varphi$) iff the
truth assignment that assigns $\true$ to the members of $X$ and
assigns $\false$ to the members of $\Loc \backslash X$ satisfies
$\varphi$.  A \emph{run} of $\A$ on an infinite word $w =
\sigma_0\cdot\sigma_1 \dots$ is a \DAG\/ $T_w = \tuple{V, v_{\iota},
  \to}$ where:

\begin{enumerate}[$\bullet$]

\item $V = \Loc \times \nat$ is the set of nodes. A node $(\l,i)$ represents the
state $\l$ after the first $i$ letters of the word $w$ have been read by $\A$. 
Nodes of the form $(\l,i)$ with $\l \in \alpha$ are called \emph{$\alpha$-nodes};

\item $v_{\iota} = (\iota,0) \in V$ is the root of the \DAG;

\item and $\to\, \subseteq V \times V$ is such that \begin{compressEnum} 
\itCompress if $(\l,i)\to(\l',i')$ then $i'=i+1$ and 
\itCompress for every $(\l,i) \in V$, the set $\{\l' \mid (\l,i) \to (\l',i+1)\}$ 
satisfies the formula $\delta(\l,\sigma_i)$.
\end{compressEnum}
We say that $(\l',i+1)$ is a \emph{successor} of $(\l,i)$ if $(\l,i) \to (\l',i+1)$, 
and we say that $(\l',i')$ is \emph{reachable} from $(\l,i)$ if $(\l,i) \to^* (\l',i')$.

\end{enumerate}
\noindent
A run $T_w = \tuple{V, v_{\iota}, \to}$ of $\A$ on an infinite word $w$ is
\emph{accepting} iff all its infinite paths $\pi$ rooted at $v_{\iota}$
visit $\alpha$-nodes infinitely often.
An infinite word $w \in \Sigma^\omega$ is \emph{accepted} by~$\A$ if
there exists an accepting run on it. We denote by~$\L(\A)$ the set
of infinite words accepted by~$\A$, and by~$\L^c(\A)$  the set of infinite words that are not accepted by~$\A$.

\begin{defi}\label{def:NBW}
A \emph{nondeterministic B\"uchi automaton} (NBW) is an ABW whose
transition function is restricted to disjunctions over $\Loc$. 
\end{defi}

Runs of NBW reduce to (linear) traces.  The transition function of NBW is
often seen as a function $[Q \times \Sigma \to 2^Q]$ and we write
$\delta(\l,\sigma) = \{\l_1, \dots, \l_n\}$ instead of
$\delta(\l,\sigma) = \l_1 \lor \l_2 \lor \dots \lor \l_n$. 
We note by $\Pre^{\A}_{\sigma}(L)$ the set of \emph{predecessors} by $\sigma$ 
of the set $L$: $\Pre^{\A}_{\sigma}(L)=\{\l \in \Loc \mid \exists \l' \in L:
\l' \in \delta(\l,\sigma) \}$. Let $\Pre^{\A}(L) = \{\l \in \Loc \mid \exists
\sigma \in \Sigma: \l \in \Pre^{\A}_{\sigma}(L) \}$.



\paragraph{{\bf Problems}} 
The \emph{emptiness problem} for NBW is to decide, given an NBW $\A$,
whether $\L(\A) = \emptyset$. This problem is solvable in
polynomial time. The symbolic approach through
fixed point computation is quadratic in the size of $\A$~\cite{EmmersonLei86}.
Other symbolic approaches have been proposed with better complexity bounds~\cite{BloemGS00,GentiliniPP03}, 
but the fixed point computation shows better performances in practice~\cite{RaviBS00}.

The \emph{universality problem} for NBW is to decide, given an NBW
$\A$ over the alphabet $\Sigma$ whether $\L(\A) = \Sigma^{\omega}$
where $\Sigma^{\omega}$ is the set of all infinite words on $\Sigma$.
This problem is {\sc PSpace}-complete~\cite{SVW87}.  The classical algorithm to
decide universality is to first complement the NBW and then to check
emptiness of the complement. The difficult step is the complementation
as it may cause an exponential blow-up in the size of the automaton.
There exist two types of construction, one is based on a
determinization of the automaton~\cite{Safra88} and the other uses ABW
as an intermediate step~\cite{kupferman97weak}. We review the second 
construction below.

The \emph{language inclusion problem} for NBW is to decide, given two
NBW $\A$ and $\B$, whether $\L(\A) \subseteq \L(\B)$. This
problem is central in model-checking and it is {\sc PSpace}-complete in the size of $\B$. 
The classical solution consists in checking the
emptiness of $\L(\A) \cap \L^c(\B)$, which again requires the
expensive complementation of $\B$.

The \emph{emptiness problem} for ABW is to decide, given an ABW $\A$,
whether $\L(\A) = \emptyset$. This problem is also {\sc
  PSpace}-complete and it can be solved using a translation from ABW
to NBW that preserves the language of the automaton~\cite{MiyanoH84}.
Again, this construction involves an exponential blow-up that makes
explicit implementations feasible only for automata limited to around
ten states. However, the emptiness problem for ABW is very important
in practice for LTL model-checking as there exist efficient polynomial
translations from LTL formulas to ABW~\cite{GastinOddoux}. The classical
construction is presented below.

\paragraph{{\bf Kupferman-Vardi construction}} 
Complementation of ABW is straightforward by dualizing the transition
function (by swapping $\land$ and $\lor$, and swapping $\true$ and
$\false$ in each formulas) and interpreting the accepting condition
$\alpha$ as a co-B\"uchi condition, {\it i.e.} a run $T_w$ is accepted
if all its infinite paths have a suffix that contains no $\alpha$-nodes.


The result is an alternating co-B\"uchi automaton (ACW). The accepting runs of
ACW have a layered structure that has been studied
in~\cite{kupferman97weak}, where the notion of \emph{rank} is
defined.  The rank is a nonnegative integer associated to each node of an accepting
run $T_w$ of an ACW on a word $w$.  Let $G_0 = T_w$. Nodes of rank $0$
are those nodes from which only finitely many nodes are reachable in
$G_0$. Let $G_1$ be the run $T_w$ from which all nodes of rank $0$
have been removed. Then, nodes of rank $1$ are those nodes of $G_1$
from which no $\alpha$-node is reachable in $G_1$. For all $i\geq 2$, let
$G_{i}$ be the run $T_w$ from which all nodes of rank
$0,\dots,i-1$ have been removed. Then, nodes of rank $2i$ are those
nodes of $G_{2i}$ from which only finitely many nodes are reachable in
$G_{2i}$, and nodes of rank $2i+1$ are those nodes of $G_{2i+1}$ from
which no $\alpha$-node is reachable in $G_{2i+1}$. Intuitively, the
rank of a node $(\l,i)$ hints how difficult it is to prove that all
the paths of $T_w$ that start in $(\l,i)$ visit $\alpha$-nodes only
finitely many times. It can be shown that every node has a rank
between $0$ and $2(\abs{\Loc} - \abs{\alpha})$, and all $\alpha$-nodes
have an even rank~\cite{GurumurthyKSV03}. The layered structure of the 
runs of ACW induces a construction to complement ABW~\cite{kupferman97weak}. 
We present this construction directly for NBW. 

\begin{defi}[\cite{kupferman97weak}]\label{def:KV-construction}
Given a NBW $\A = \tuple{\Loc, \iota, \Sigma, \delta,
  \alpha}$ and an even number $k \in \nat$, let $\KV(\A,k) = \tuple{\Loc',
  \iota', \Sigma, \delta', \alpha'}$ be an ABW such that:

\begin{enumerate}[$\bullet$]
\item $\Loc' = \Loc \times [k]$ where $[k] = \{0,1,\dots,k\}$.
  Intuitively, the automaton $\KV(\A,k)$ is in state $(\l,n)$
  after the first $i$ letters of the input word $w$ have been read if
  it guesses that the rank of the node $(\l,i)$ in a run of $\A$ on
  $w$ is at most $n$;
\item $\iota'  = (\iota, k)$;
\item $\delta'((\l,i),\sigma) = \left\{\begin{array}{ll} \false  & \text{ if } \l\in\alpha \text{ and } i \text{ is odd} \\ 
						\bigwedge_{\l' \in \delta(\l,\sigma)} \bigvee_{0 \leq i'\leq i} (\l',i') & \text{ otherwise }
				\end{array}\right.$ 

\medskip
\noindent For example, if $\delta(\l,\sigma) = \{\l_1, \l_2\}$, then 
$$\delta'((\l,2),\sigma) = ((\l_1,2) \lor (\l_1,1) \lor (\l_1,0)) \land ((\l_2,2) \lor (\l_2,1) \lor (\l_2,0))$$
\item $\alpha' = \Loc \times [k]^{odd}$ where $[k]^{odd}$ is the set of odd numbers in $[k]$.
\end{enumerate}
\end{defi}

The ABW specified by the Kupferman-Vardi construction accepts the
complement language of $\L(\A)$ and its size is quadratic in the size of the
original automaton~$\A$.

\begin{thm}[\cite{kupferman97weak}]\label{theo:complement}
For all NBW $\A = \tuple{\Loc, \iota, \Sigma, \delta,
\alpha}$, for all $0\leq k' \leq k$, we have $\L(\KV(\A,k')) \subseteq \L(\KV(\A,k))$ and 
for $k = 2(\abs{\Loc} - \abs{\alpha})$, we have $\L(\KV(\A,k)) = \L^c(\A)$.
\end{thm}



\paragraph{{\bf Miyano-Hayashi construction}}
Classically, to check emptiness of ABW, a variant 
of the subset construction is applied that transforms the ABW into a NBW 
that accepts the same language~\cite{MiyanoH84}. Intuitively, the NBW 
maintains a set $s$ of states of the ABW that corresponds to a whole
level of a guessed run \DAG\/ of the ABW. In addition, the NBW maintains
a set $o$ of states that ``owe'' a visit to an accepting state. Whenever
the set $o$ gets empty, meaning that every path of the guessed run has visited
at least one accepting state, the set $o$ is initiated with the current
level of the guessed run. It is asked that $o$ gets empty infinitely often
in order to ensure that every path of the run \DAG\/ visits accepting states
infinitely often. The construction is as follows.

\begin{defi}[\cite{MiyanoH84}]\label{def:MH-construction}
Given an ABW $\A = \tuple{\Loc, \iota, \Sigma, \delta,
\alpha}$, define $\MH(\A)$ as the NBW $\tuple{2^{\Loc} \times 2^{\Loc},
(\{\iota\},\emptyset), \Sigma, \delta', \alpha'}$ where
$\alpha' = 2^{\Loc} \times \{\emptyset\}$ and $\delta'$ is defined,
for all $\tuple{s,o} \in 2^{\Loc} \times 2^{\Loc}$ and $\sigma \in
\Sigma$, as follows:

\begin{enumerate}[$\bullet$] 

\item If $o\neq \emptyset$, then
$$\delta'(\tuple{s,o},\sigma) = \{ \tuple{s',o'\setminus \alpha} \mid o'\subseteq s', 
s' \models \bigwedge_{\l \in s} \delta(\l,\sigma) \textrm{ and }\penalty-1000 o' \models \bigwedge_{\l \in o}
\delta(\l,\sigma)\}$$

\item If $o= \emptyset$, then $\delta'(\tuple{s,o},\sigma) = \{ \tuple{s',s'\setminus \alpha} \mid  
s' \models \bigwedge_{\l \in s} \delta(\l,\sigma)\}$.
\end{enumerate} 

\end{defi}

The size of the Miyano-Hayashi construction is exponential in the 
size of the original automaton. 

\begin{thm}[\cite{MiyanoH84}]\label{theo:subset-construction}
For all ABW $\A$, we have $\L(\MH(\A)) = \L(\A)$.
\end{thm}

The size of the automaton obtained after the Kupferman-Vardi
and the Miyano-Hayashi construction is an obstacle to the
direct implementation of the method.  


\paragraph{{\bf Direct complementation}}\label{sec:direct-complementation}
In our solution, we \emph{implicitly} use the two constructions to
complement B\"uchi automata but, as we will see, we do not construct
the automata. For the sake of clarity, we give below the
specification of the automaton that would result from the composition of
the two constructions. In the definition of the state space, we omit the
states $(\l,i)$ for $\l \in \alpha$ and $i$ odd, as those states have no 
successor in the Kupferman-Vardi construction.
 


\begin{defi}\label{def:direct-complementation}
Given a NBW $\A = \tuple{\Loc, \iota, \Sigma, \delta, \alpha}$ 
and an even number $k \in \nat$, let 
$\KVMH(\A,k) = \tuple{Q_k \times Q_k, q_{\iota}, \Sigma, \delta', \alpha'}$ be a NBW such that:
\begin{enumerate}[$\bullet$] 
\item $Q_k = 2^{(\Loc \times [k]) \setminus (\alpha \times \nat^{odd})}$ where
$\nat^{odd}$ is the set of odd natural numbers;
\item $q_{\iota} = (\{(\iota, k)\}, \emptyset)$;
\item Let $\odd = \Loc \times [k]^{odd}$; $\delta'$ is defined for all $s,o \in Q_k$ and 
$\sigma \in \Sigma$, as follows:
\begin{enumerate}[$-$] 
\item If $o \neq \emptyset$, then $\delta'(\tuple{s,o},\sigma)$ is the set of pairs $\tuple{s',o'\setminus \odd}$ such that:
	\begin{enumerate}[$(i)$] 
	\item $o'\subseteq s'$; 
	\item $\forall (\l,n) \in s \cdot \forall \l' \in \delta(\l,\sigma)\cdot \exists n' \leq n: (\l',n') \in s'$;
\item $\forall (\l,n) \in o \cdot \forall \l' \in \delta(\l,\sigma)\cdot \exists n' \leq n: (\l',n') \in o'$.
\end{enumerate}
\item If $o= \emptyset$, then $\delta'(\tuple{s,o},\sigma)$ is the set of pairs $\tuple{s',s'\setminus \odd}$ such that:
	\begin{enumerate}[$(i)$]
	\item[] $\forall (\l,n) \in s \cdot \forall \l' \in \delta(\l,\sigma)\cdot \exists n' \leq n: (\l',n') \in s'$.
	\end{enumerate}
\end{enumerate} 
\item $\alpha' = Q_k \times \{\emptyset\}$;
\end{enumerate} 
\end{defi}

 We write $\tuple{s,o} \xrightarrow{\sigma}_{\delta'} \tuple{s',o'}$ to 
denote $\tuple{s',o'} \in \delta'(\tuple{s,o},\sigma)$.

\begin{thm}[\cite{kupferman97weak,MiyanoH84}]\label{theo:direct-complement}
For every NBW $\A = \tuple{\Loc, \iota, \Sigma, \delta, \alpha}$ and
for all $\,0\leq k' \leq k$, we have $\L(\KVMH(\A,k')) \subseteq
\L(\KVMH(\A,k))$.  In case of $k = 2(\abs{\Loc} - \abs{\alpha})$, we
also have $\L(\KVMH(\A,k)) = \L^c(\A)$.
\end{thm}

In the sequel, we denote by $\KVMH(\A)$ the automaton $\KVMH(\A,2(\abs{\Loc} - \abs{\alpha}))$,
and we denote by $Q \times Q$ its set of states (we omit the subscript $k$).

\section{Simulation Pre-Orders and Fixed Points}\label{sec:fixed-point}

Let $\A = \tuple{\Loc, \iota, \Sigma, \delta, \alpha}$ be a NBW.  Let
$\langle 2^{\Loc},\subseteq, \cup,\cap,\emptyset,\Loc \rangle$ be the
powerset lattice of locations. The fixed point formula
$\F_{\A} \equiv \nu y \cdot \mu x \cdot ( \Pre^{\A}(x) \cup ( \Pre^{\A}(y) \cap \alpha ))$
can be used to check emptiness of $\A$ as we have $\L(\A)\not= \emptyset$ iff $\iota \in \F_{\A}$.
Intuitively, the greatest fixed point $\nu y$ in $\F_{\A}$ computes in the
$n$-th iteration the set of states from which $n$ accepting states can be visited
with some word. When this set stabilizes, infinitely many visits to an accepting
state are possible.


We show in this section that a certain structural property of the NBW
is tightly correlated to the structure of the sets that are computed by the 
fixed point $\F_{\A}$. The key property is the notion of simulation relation
for finite automata. Let $\preceq \subseteq \Loc \times \Loc$ be a pre-order and let $\l_1
\prec \l_2$ iff $\l_1 \preceq \l_2$ and $\l_2 \not\preceq \l_1$.

\begin{defi}\label{def:simulation}
  A pre-order $\preceq$ is a \emph{simulation} for $\A$ iff the following
  properties hold:
  \begin{enumerate}[$\bullet$]
    
    \item for all $\l_1,\l_2,\l_3 \in \Loc$, for all $\sigma \in \Sigma$, if
    $\l_3 \preceq \l_1$ and $\l_2 \in \delta(\l_1,\sigma)$ then there exists
    $\l_4 \in \Loc$ such that $\l_4 \preceq \l_2$ and $\l_4 \in \delta(\l_3,\sigma)$ (see illustration in \figurename~\ref{fig:simulation});

    \item for all $\l \in \alpha$, for all $\l' \in \Loc$, if $\l' \preceq \l$ 
     then $\l' \in \alpha$.

  \end{enumerate}
\end{defi}

\begin{figure}[!tb]
  \unitlength=.8mm
\def\fsize{\normalsize}

\hrule
\begin{picture}(160,46)(0,0)



{\fsize

\node[Nmarks=n](q1)(20,38){$\l_1$}
\node[Nmarks=n](q2)(60,38){$\l_2$}
\node[Nmarks=n](q3)(20,8){$\l_3$}
\node[Nframe=n](dummy)(5,23){If}
\node[Nframe=n, Nadjust=wh, Nadjustdist=2.2](dummy)(20,23){\rotatebox{90}{$\preceq$}}


\node[Nmarks=n](r2)(150,38){$\l_2$}
\node[Nmarks=n](r3)(110,8){$\l_3$}
\node[Nmarks=n](r4)(150,8){$\l_4$}
\node[Nframe=n](eummy)(83,23){then}
\node[Nframe=n, Nadjust=wh, Nadjustdist=2.2](eummy)(150,23){\rotatebox{90}{$\preceq$}}




\drawedge[ELpos=50, ELside=l, ELdist=1, curvedepth=0](q1,q2){$\sigma$}
\drawedge[ELpos=50, ELside=l, ELdist=1, curvedepth=0](r3,r4){$\sigma$}

\drawedge[dash={1}0, ELpos=50, ELside=l, ELdist=1, curvedepth=0, AHnb=0](q1,dummy){}
\drawedge[dash={1}0, ELpos=50, ELside=l, ELdist=1, curvedepth=0, AHnb=0](q3,dummy){}

\drawedge[dash={1}0, ELpos=50, ELside=l, ELdist=1, curvedepth=0, AHnb=0](r2,eummy){}
\drawedge[dash={1}0, ELpos=50, ELside=l, ELdist=1, curvedepth=0, AHnb=0](r4,eummy){}









}
\end{picture}
\hrule


 \caption{Simulation (Definition~\ref{def:simulation}).}
  \label{fig:simulation}
\end{figure}
  
\paragraph{{\bf Downward-closed sets}} A set $L \subseteq \Loc$ is \emph{$\preceq$-closed} iff for all
$\l_1,\l_2 \in \Loc$, if $\l_1 \preceq \l_2$ and $\l_2 \in L$ then $\l_1 \in
L$. The \emph{$\preceq$-closure} of $L$, is the set $\closure{L}=\{ \l
\in \Loc \mid \exists \l' \in L : \l \preceq \l' \}$.  We denote by 
$\Max(L)$ the set of \emph{$\preceq$-maximal} elements of $L$: 
$\Max(L)=\{ \l \in L \mid \nexists \l' \in L : \l \prec \l' \}$. 
For any $\preceq$-closed set $L \subseteq \Loc$, we have 
$L=\closure{\Max(L)}$. Furthermore, if $\preceq$ is a partial order, 
then $\Max(L)$ is an \emph{antichain} of elements and it can serve as a canonical 
representation of~$L$. 

Our goal is to show that the operators involved in the fixed
point formula $\F_{\A}$ preserve $\preceq$-closedness. This is
true for union and intersection, for all relations $\preceq$.

\begin{lem}\label{lem:closure-properties-a}
  For all relations $\preceq$, for all $\preceq$-closed sets $L_1,L_2$,
  the sets $L_1 \cup L_2$ and $L_1 \cap L_2$ are $\preceq$-closed.
\end{lem}
 
The next lemma shows that simulation relations are necessary (and also sufficient) to
guarantee preservation of $\preceq$-closedness under the $\Pre$ operator.
Note that many other notions of simulation pre-orders have been defined 
for B\"uchi automata, see~\cite{simulations}.\footnote{In ~\cite{simulations},
the simulation of Definition~\ref{def:simulation} is called \emph{direct simulation}.}


\begin{lem}\label{lem:closure-properties-b}
  Let $\A = \tuple{\Loc, \iota, \Sigma, \delta, \alpha}$ be a NBW.
  A pre-order $\preceq \subseteq \Loc \times \Loc$ is a simulation for $\A$
  if and only if the following two properties hold:
  \begin{enumerate}[\em(a)]
    \item the set $\alpha$ is $\preceq$-closed.
    \item for all $\preceq$-closed sets $L \subseteq \Loc$, for all $\sigma \in \Sigma$, $\Pre^{\A}_{\sigma}(L)$ is $\preceq$-closed;
  \end{enumerate}
\end{lem}


\proof 
First, assume that $\preceq$ is a simulation for $\A$.
Then, the set $\alpha$ is $\preceq$-closed by Definition~\ref{def:simulation}, which establishes (a).
To prove (b), let $L \subseteq \Loc$ be a $\preceq$-closed set and let $\sigma \in \Sigma$.
For all $\l_1 \in \Pre^{\A}_{\sigma}(L)$ there exists $\l_2 \in L$ such that 
$\l_2 \in \delta(\l_1,\sigma)$. By Definition~\ref{def:simulation},
for all $\l_3 \preceq \l_1$ there exists $\l_4 \in \Loc$ such that 
$\l_4 \preceq \l_2$ and $\l_4 \in \delta(\l_3,\sigma)$ (see \figurename~\ref{fig:simulation}). 
So $\l_4 \in L$ since $L$ is $\preceq$-closed and $\l_2 \in L$, and thus $\l_3 \in \Pre^{\A}_{\sigma}(L)$
which shows that $\Pre^{\A}_{\sigma}(L)$ is $\preceq$-closed. 

Second, assume that (a) and (b) hold, and show that $\preceq$ satisfies Definition~\ref{def:simulation}.
By (a), for all $\l \in \alpha$ and for all $\l' \preceq \l$, we have $\l' \in \alpha$.
Now, let $\l_1,\l_2,\l_3 \in \Loc$ and $\sigma \in \Sigma$ such that 
$\l_3 \preceq \l_1$ and $\l_2 \in \delta(\l_1,\sigma)$. Consider the 
$\preceq$-closed set $L_2 = \closure{\{\l_2\}}$.
By (b), the set $\Pre^{\A}_{\sigma}(L_2)$ is $\preceq$-closed and thus
$\l_3 \in \Pre^{\A}_{\sigma}(L_2)$. Therefore, there exists $\l_4 \in L_2$ (i.e. 
$\l_4 \preceq \l_2$) such that $\l_4 \in \delta(\l_3,\sigma)$. 
Hence, $\preceq$ is a simulation for $\A$.
\qed








Lemmas~\ref{lem:closure-properties-a} and~\ref{lem:closure-properties-b} 
entail that all sets computed in the iterations of the fixed point formula~$\F_{\A}$
are $\preceq$-closed for any simulation $\preceq$ for $\A$.
We can take advantage of this fact to use a compact representation of those
sets, namely their maximal elements. This would indeed reduce the size of the 
sets to manipulate by the fixed point algorithms (possibly exponentially as we 
will see later). Notice that in general, this compact representation can make 
more difficult the computation of the $\Pre$ operator. To illustrate this, consider
the example in \figurename~\ref{fig:example-max} where we want to compute 
$\Pre_\sigma(\closure{\{\l\}})$. More precisely, given $\l$ we need to compute
the maximal elements of the $\preceq$-closed set $\Pre_\sigma(\closure{\{\l\}})$.
The set $\closure{\{\l\}}$ is delimited by the dashed curve in the figure. 
First, note that applying $\Pre_\sigma$ to $\{\l\}$ would give the empty set
from which the correct result can obviously not be extracted. Second, if we assume
that the states $\l_1, \dots, \l_k$ are $\preceq$-incomparable, then the result 
is $\Max(\Pre_\sigma(\closure{\{\l\}})) = \{ \l_1, \dots, \l_k \}$, which shows 
that essentially any set can be obtained, including sets of maximal elements that 
are huge or difficult to manipulate symbolically. Third, even if the result is compact 
(e.g., if $\l_i \preceq \l_1$
for all $1 \leq i \leq k$, then the result is the singleton $\{\l_1\}$), the computation
may somehow require to enumerate all the $\l_i$ for $i=1,2,\dots,k$ where $k$
may be for instance exponential in the size of the problem. 

The above remarks show that for \emph{each particular} application (i.e., for
each class of automata, and each particular simulation $\preceq$ that we use),
we need $(1)$ to define a predecessor operator $\Pre^{{\sf abs}}$
that applies to maximal elements, such that $\Pre^{{\sf abs}}(\Max(L)) = \Max(\Pre(L))$ 
for all $\preceq$-closed sets $L$, $(2)$ to present an algorithm to compute this 
operator, and establish its correctness, and $(3)$ to study the complexity of 
such an algorithm.

Finally, note that the way to compute $\Max(L_1 \cap L_2)$ given $\Max(L_1)$ 
and $\Max(L_2)$ should also be defined for each application, while for union,
the following general rule applies:
$\Max(L_1 \cup L_2) = \Max(\Max(L_1) \cup \Max(L_2))$.

In the next sections, we show that the NBW that we have to analyze
in the automata-based approach to model-checking are all equipped with
a simulation pre-order that can be exploited to compute efficiently
the intersection and the predecessor operators. Hence, we show that 
the expected efficiency in terms of space consumption 
of the antichain representation does not come at the price of a blow-up in the 
computation times of these operators. 
We do so for the emptiness problem of ABW,
and for the universality and language inclusion problems for NBW. All these problems
can be reduced to the emptiness problem of NBW that are obtained by specific 
constructions (analogous of the powerset construction), for which simulation relations 
\emph{need not to be computed} for each instance of the problems, but can be defined \emph{generically}
(like set inclusion is such a relation for the classical powerset construction).













\begin{figure}[!tb]
  \unitlength=.8mm
\def\fsize{\normalsize}

\hrule
\begin{picture}(115,85)(0,0)



{\fsize


\gasset{Nw=9,Nh=9,Nmr=4.5}

\node[Nmarks=n](q1)(85,75){$\l$}

\node[Nmarks=n](q2)(80,60){}\node[Nmarks=n](q3)(93,50){}\node[Nmarks=n](q4)(71,38){}\node[Nmarks=n](q5)(100,32){}\node[Nmarks=n](q6)(88,25){}\node[Nmarks=n](q7)(66,15){}\node[Nmarks=n](q8)(95,8){}

\node[Nframe=n](left)(55,-1){}
\node[Nframe=n](right)(115,-1){}
\drawbpedge[dash={1.5 2.5}0, AHnb=0](left,82,112,right,98,112){}


\node[Nmarks=n](l1)(10,48){$\l_1$}
\node[Nmarks=n](l2)(40,40){$\l_2$}
\node[Nframe=n](dots)(25,32){$\vdots$}
\node[Nmarks=n](l3)(25,18){$\l_k$}

\drawedge[ELpos=25, ELside=l, ELdist=1, curvedepth=10](l1,q5){$\sigma$}
\drawedge[ELpos=50, ELside=l, ELdist=1, curvedepth=6](l2,q2){$\sigma$}
\drawedge[ELpos=50, ELside=l, ELdist=1, curvedepth=6](l3,q7){$\sigma$}














}
\end{picture}
\hrule


 \caption{Computing the predecessors of a $\preceq$-closed set.}
  \label{fig:example-max}
\end{figure}


\section{Emptiness of ABW}\label{sec:emptiness-alternating}

We now show how to apply Lemmas~\ref{lem:closure-properties-a} and~\ref{lem:closure-properties-b} to check more efficiently the
emptiness of ABW. Let $\A_1=\tuple{\Loc_1, \iota_1, \Sigma, \delta_1,
  \alpha_1}$ be an ABW for which we want to decide whether
$\L(\A_1)=\emptyset$.  We know that the (exponential) Miyano-Hayashi
construction gives a NBW $\A_2=\MH(\A_1)$ such that $\L(\A_2) =
\L(\A_1)$. The emptiness of $\A_1$ (or equivalently of
$\A_2$) can be decided more efficiently by computing the fixed point
$\F_{\A_2}$ and without constructing explicitly $\A_2$. To do
so, we establish the existence of a simulation for $\A_2$ for which we can
compute $\cup$, $\cap$ and $\Pre$ by manipulating only maximal
elements of closed sets of locations.




\begin{defi}\label{def:simulation-for-MH}
Let $\MH(\A_1) = \tuple{\Loc_2, \iota_2, \Sigma, \delta_2, \alpha_2}$.
Remember that $\Loc_2 \subseteq 2^{\Loc_1} \times 2^{\Loc_1}$. 
Define the pre-order $\preceq_{{\sf alt}} \subseteq \Loc_2 \times
\Loc_2$ such that $\tuple{s,o} \preceq_{{\sf alt}} \tuple{s',o'}$ iff 
$(i)$ $s \subseteq s'$, $(ii)$ $o \subseteq o'$, and $(iii)$ $o=\emptyset$ iff $o'=\emptyset$. 
\end{defi}

Note that the pre-order $\preceq_{{\sf alt}}$ is a partial order. 
As a consequence, given a set of pairs $L=\{ \tuple{s_1,o_1},\tuple{s_2,o_2}, \dots, \tuple{s_n,o_n} \}$, 
the set $\Max(L)$ is an \emph{antichain} and identifies~$L$.

\begin{lem}\label{lem:alt-simulation-relation}
For all ABW $\A_1$, the partial order $\preceq_{{\sf alt}}$ is a simulation 
for $\MH(\A_1)$.
\end{lem}

\proof 
Let $\A_1=\tuple{\Loc_1, \iota_1, \Sigma, \delta_1, \alpha_1}$ and
  $\MH(\A_1) = \tuple{\Loc_2, \iota_2, \Sigma, \delta_2, \alpha_2}$.
  First, let $\sigma \in \Sigma$ and $\tuple{s_1,o_1}$, $\tuple{s_2,o_2}$, 
 $\tuple{s_3,o_3} \in \Loc_2$ be such that 
 $\tuple{s_1,o_1} \xrightarrow{\sigma}_{\delta_2} \tuple{s_2,o_2}$ and
 $\tuple{s_3,o_3} \preceq_{{\sf alt}} \tuple{s_1,o_1}$.
 We show that there exists $\tuple{s_4,o_4} \in \Loc_2$ such that 
 $\tuple{s_3,o_3} \xrightarrow{\sigma}_{\delta_2} \tuple{s_4,o_4}$
 and $\tuple{s_4,o_4} \preceq_{{\sf alt}} \tuple{s_2,o_2}$. 
 Let us consider the case where $o_1=\emptyset$. Then we have 
  $o_3=\emptyset$ by definition of $\preceq_{{\sf alt}}$ and 
  $\delta_2(\tuple{s_1,o_1},\sigma)=\{ \tuple{s',s' \setminus \alpha_1} \mid 
  s' \models \bigwedge_{l \in s_1} \delta_1(l,\sigma)\}$, 
  this set being contained in $\delta_2(\tuple{s_3,o_3},\sigma)=
  \{ \tuple{s',s' \setminus \alpha_1} \mid s' \models \bigwedge_{l \in s_3}
  \delta_1(l,\sigma) \}$ as $s_3$ puts less constraints than $s_1$ since
  $s_3 \subseteq s_1$. A similar reasoning holds if $o_1 \not=
  \emptyset$. Second, let $\tuple{s_1,o_1} \in \alpha_2$ and let $\tuple{s_2,o_2}
  \preceq_{{\sf alt}} \tuple{s_1,o_1}$. By definition of $\alpha_2$, we know
  that $o_1=\emptyset$, and by definition of $\preceq_{{\sf alt}}$ we have 
  $o_2=\emptyset$ and so $\tuple{s_2,o_2} \in \alpha_2$.
\qed

According to Lemmas~\ref{lem:closure-properties-a} and~\ref{lem:closure-properties-b}, 
all the sets that we compute to evaluate $\F_{\A_2}$ are \mbox{$\preceq_{{\sf alt}}$-closed}.  
We need to compute intersection and $\Pre$ by only manipulating maximal elements. 
Given $\tuple{s_1,o_1}, \tuple{s_2,o_2}$, we take $\tuple{s,o}$ such
that $\closure{\tuple{s,o}}=\closure{\tuple{s_1,o_1}}\, \cap \closure{\tuple{s_2,o_2}}$ as follows:
\begin{equation}\tuple{s,o} = \left\{\begin{array}{ll}\tuple{s_1 \cap s_2,o_1 \cap o_2} & \text{ if } o_1 \cap o_2 \not=\emptyset, \\
					\tuple{s_1 \cap s_2,\emptyset}    & \text{ if } o_1=o_2=\emptyset, \\
\end{array}\right.\label{eq:intersection}\end{equation}
and otherwise the intersection is empty. 

Algorithm~1 computes the maximal elements of the set of
$\sigma$-predecessors of the $\preceq_{{\sf alt}}$-clo\-sure of a pair
$\tuple{s',o'}$. This allows to compute the maximal elements of the
set of predecessors of any $\preceq_{{\sf alt}}$-closed set by just
manipulating its maximal elements, since $\Pre^{\A}(L_1 \cup L_2) =
\bigcup_{\sigma \in \Sigma} \Pre^{\A}_{\sigma}(L_1) \cup
\Pre^{\A}_{\sigma}(L_2)$.

Note that our algorithm runs in polynomial time, more precisely in $O(\abs{\Loc_1}\cdot\norm{\delta_1})$ 
where $\norm{\delta_1}$ is the size of the transition relation, defined as
the maximal number of boolean connectives in a formula $\delta_1(\l,\sigma)$.

\begin{algorithm}[!tbp]
\AlgData{An ABW $\A_1 = \tuple{\Loc_1, \iota_1, \Sigma, \delta_1, \alpha_1}$, 
  $\sigma \in \Sigma$ and $\tuple{s',o'} \in 2^{\Loc_1} \times 2^{\Loc_1}$ such that $o' \subseteq s'$.}  

  \AlgResult{The $\preceq_{{\sf alt}}$-antichain $\Pre^{{\sf alt}}_{\sigma}(\tuple{s',o'})$.}
  \flushleft
  \Begin { 
    \nl $L_{\sf Pre} \gets \emptyset$\;


    \nl $o \gets \{ \l \in \Loc_1 \mid o' \cup (s' \cap \alpha_1) \models \delta_1(\l,\sigma) \}$ \label{alg:pre-alt-o}\;

    \nl \If{$o' \not\subseteq \alpha_1 \lor o' = \emptyset$ \label{alg:pre-alt-simulation-test}}
	{
	   \nl $L_{\sf Pre} \gets \{ \tuple{o,\emptyset} \}$ \label{alg:pre-alt-o-added}\; 		
	}

    \nl \If{$o \neq \emptyset$ \label{alg:pre-alt-line-emtpiness-test}}
        {
	    \nl $s \gets \{ \l \in \Loc_1 \mid s' \models \delta_1(\l,\sigma) \}$ \label{alg:pre-alt-s} \;
	    \nl $L_{\sf Pre} \gets L_{\Pre} \cup \{ \tuple{s,o} \}$ \label{alg:pre-alt-s-added}\;
	}


\nl \KwRet{$L_{{\sf Pre}}$}\; }\medskip

\caption{Algorithm for $\Pre^{{\sf alt}}_{\sigma}(\cdot)$. \label{alg:pre-alt}}

\end{algorithm}

\begin{thm}\label{theo:correctness-alg-pre-alt}
  Given an ABW $\A_1 = \tuple{\Loc_1, \iota_1, \Sigma, \delta_1, \alpha_1}$, 
  $\sigma \in \Sigma$ and $\tuple{s',o'} \in 2^{\Loc_1} \times 2^{\Loc_1}$ such that $o' \subseteq s'$, 
  the set $L_{\Pre} = \Pre^{{\sf alt}}_{\sigma}(\tuple{s,o})$
  computed by Algorithm~1 is an $\preceq_{{\sf alt}}$-antichain such that
  $\closure{L_{\Pre}}= \Pre^{\A_2}_{\sigma}(\closure{\{\tuple{s',o'}\}})$ where 
  $\A_2 = \MH(\A_1)$.
\end{thm}

\proof 
Let $\A_2 = \MH(\A_1) = \tuple{\Loc_2, \iota_2, \Sigma, \delta_2, \alpha_2}$.
The following entails that $\closure{L_{\Pre}}=
\Pre^{\A_2}_{\sigma}(\closure{\{\tuple{s',o'}\}})$:
\begin{enumerate}[(a)]
\item $L_{\Pre} \subseteq
  \Pre^{\A_2}_{\sigma}(\closure{\{\tuple{s',o'}\}})$, and 
\item[(b)] for all $\tuple{s_1,o_1} \in
  \Pre^{\A_2}_{\sigma}(\closure{\{\tuple{s',o'}\}})$, 
\end{enumerate}
there exists $\tuple{s,o} \in L_{\Pre}$ such that $\tuple{s_1,o_1} \preceq_{{\sf alt}} \tuple{s,o}$.

To prove (a), we first show that $\tuple{s,o} \xrightarrow{\sigma}_{\delta_2} \tuple{s',o'}$
where $\tuple{s,o}$ is added to $L_{\Pre}$ at line~\ref{alg:pre-alt-s-added} of 
Algorithm~1.
By the test of line~\ref{alg:pre-alt-line-emtpiness-test}, we have $o \neq \emptyset$. 
According to Definition~\ref{def:MH-construction} of $\MH(\cdot)$, we check that 
there exists a set $o'' \subseteq s'$ such that $o' = o'' \setminus \alpha_1$
(we take $o'' = o' \cup (s' \cap \alpha_1)$), and the following conditions hold:
\begin{enumerate}[$(i)$]
\item $s' \models \bigwedge_{\l \in s} \delta_1(\l,\sigma)$ since 
we have $s' \models \delta_1(\l,\sigma)$ for all $\l \in s$ 
by line~\ref{alg:pre-alt-s} of Alg.~1.\item $o'' \models \bigwedge_{\l \in o} \delta_1(\l,\sigma)$ since
we have $o'' \models \delta_1(\l,\sigma)$ for all $\l \in o$
by line~\ref{alg:pre-alt-o} of Alg.~1.\end{enumerate}

Second, we show that $\tuple{o,\emptyset} \xrightarrow{\sigma}_{\delta_2} \tuple{s'',o''}$ for 
some $\tuple{s'',o''} \preceq_{{\sf alt}} \tuple{s',o'}$ where $\tuple{o,\emptyset}$
is added to $L_{\Pre}$ at line~\ref{alg:pre-alt-o-added} of Algorithm~1.
We take $s'' = o' \cup (s' \cap \alpha_1)$ and $o'' = s'' \setminus \alpha_1$. 
Since $o' \subseteq s'$, we  have $(a)$ $s'' \subseteq s'$,
and we have $(b)$ $o'' = o' \setminus \alpha_1 \subseteq o'$. 
Let us establish that $(c)$ $o' = \emptyset$ iff $o'' = \emptyset$.
If $o' = \emptyset$ then $o'' = \emptyset$ since $o'' \subseteq o'$.
If $o' \neq \emptyset$ then by the test of line~\ref{alg:pre-alt-simulation-test},
we have $o' \not\subseteq \alpha_1$ and thus $o'' = o' \setminus \alpha_1 \neq \emptyset$.
Hence we have $\tuple{s'',o''} \preceq_{{\sf alt}} \tuple{s',o'}$,
and by line~\ref{alg:pre-alt-o} of the algorithm, we have 
$s'' \models \delta_1(\l,\sigma)$ for all $\l \in o$, and thus 
$s'' \models \bigwedge_{\l \in o} \delta_1(\l,\sigma)$. Therefore
$\tuple{o,\emptyset} \xrightarrow{\sigma}_{\delta_2} \tuple{s'',o''}$.

To prove (b), assume that there exist $\tuple{s_1,o_1}$ and $\tuple{s_1',o_1'}$
such that $\tuple{s_1,o_1} \xrightarrow{\sigma}_{\delta_2} \tuple{s_1',o_1'}$ and 
$\tuple{s_1',o_1'} \preceq_{{\sf alt}} \tuple{s',o'}$.
We have to show that there exists $\tuple{s,o} \in L_{\Pre}$ such that 
$\tuple{s_1,o_1} \preceq_{{\sf alt}} \tuple{s,o}$.

First, assume that $o_1 \neq \emptyset$.
Since $\tuple{s_1,o_1} \xrightarrow{\sigma}_{\delta_2} \tuple{s_1',o_1'}$,
we have:
\begin{enumerate}[$(i)$]  
\item for all $\l \in s_1$, $s_1' \models \delta_1(\l,\sigma)$ and since 
$s_1' \subseteq s'$ also $s' \models \delta_1(\l,\sigma)$. Let $s$
be the set defined at line~\ref{alg:pre-alt-s} of Algorithm~1.
For all $\l \in \Loc$, if $s' \models \delta_1(\l,\sigma)$ then $\l \in s$.
Hence, $s_1 \subseteq s$.

\item for all $\l \in o_1$, $o_1'' \models \delta_1(\l,\sigma)$
for some $o_1'' \subseteq s'_1$ such that $o_1' = o_1'' \setminus \alpha_1$. 
Hence necessarily $o_1'' \subseteq o_1' \cup (s_1' \cap \alpha_1) \subseteq o' \cup (s' \cap \alpha_1)$
and thus for all $\l \in o_1$, $o' \cup (s' \cap \alpha_1) \models \delta_1(\l,\sigma)$.
Let $o$ be the set defined at line~\ref{alg:pre-alt-o} of Algorithm~1.
For all $\l \in \Loc$, if $o' \cup (s' \cap \alpha_1) \models \delta_1(\l,\sigma)$ 
then $\l \in o$. Hence, $o_1 \subseteq o$ and $o \neq \emptyset$.
\end{enumerate}
\noindent
Hence, $\tuple{s,o}$ which is added to $L_{\Pre}$ by Alg.~1 at 
line~\ref{alg:pre-alt-s-added} satisfies $\tuple{s_1,o_1} \preceq_{{\sf alt}} \tuple{s,o}$.

Second, assume that $o_1 = \emptyset$. 
Since $\tuple{s_1,o_1} \xrightarrow{\sigma}_{\delta'} \tuple{s_1',o_1'}$ and $o_1 = \emptyset$,
we know that for all $\l \in s_1$, $s_1' \models \delta_1(\l,\sigma)$ and 
$o_1' = s_1' \setminus \alpha_1$. Let $s'' = o' \cup (s' \cap \alpha_1)$ so we have 
$(a)$ $s_1' \cap \alpha_1 \subseteq s' \cap \alpha_1 \subseteq s''$ and 
$(b)$ $s_1' \setminus \alpha_1 = o_1' \subseteq o'  \subseteq s''$.
Hence, $s_1' \subseteq s''$ and thus for all $\l \in s_1$, $s'' \models \delta_1(\l,\sigma)$.
Let $o$ be the set defined at line~\ref{alg:pre-alt-o} of Algorithm~1.
For all $\l \in \Loc$, if $s'' \models \delta_1(\l,\sigma)$ 
then $\l \in o$. Hence, $s_1 \subseteq o$ and 
$\tuple{s_1,\emptyset} \preceq_{{\sf alt}} \tuple{o, \emptyset}$ where $\tuple{o, \emptyset}$
is added to $L_{\Pre}$ by Algorithm~1 at line~\ref{alg:pre-alt-o-added}.
Notice that the test at line~\ref{alg:pre-alt-simulation-test} is satisfied because
$o_1' = s_1' \setminus \alpha_1$ implies that $o_1' \not\subseteq \alpha_1 \lor 
o_1' = \emptyset$ and since $\tuple{s_1',o_1'} \preceq_{{\sf alt}} \tuple{s',o'}$,
we have $o' \not\subseteq \alpha_1 \lor o' = \emptyset$.
\qed





\section{Universality of NBW}\label{sec:universality}

We present a new algorithm to check universality of NBW, based
the existence of a simple simulation relation for the complement
automaton of NBW given by Definition~\ref{def:direct-complementation}.

\begin{defi}\label{def:simulation-for-KVMH}
Given an NBW $\A = \tuple{\Loc, \iota, \Sigma, \delta, \alpha}$,
let $\KVMH(\A) = \tuple{Q \times Q, q_{\iota}, \Sigma, \delta', \alpha'}$.
Define the pre-order $\preceq_{{\sf univ}}\, \subseteq (Q \times Q) \times (Q \times Q)$ as follows: 
for all $s,s',o,o' \in Q$, let 
$\tuple{s,o} \preceq_{{\sf univ}} \tuple{s',o'}$ 
iff the following conditions hold:
  \begin{enumerate}[$\bullet$]
    \item for all $(\l,n) \in s$, there exists $n' \leq n$ such that $(\l,n') \in s'$;
    \item for all $(\l,n) \in o$, there exists $n' \leq n$ such that $(\l,n') \in o'$;
    \item $o=\emptyset$ iff $o'=\emptyset$.
  \end{enumerate}
\end{defi}

This relation formalizes the intuition that it is easier to accept a word 
in $\KVMH(\A)$ from a given location with a high rank than with a small rank. 
This is because the rank is always decreasing along every path of the runs 
of $\KV(\A)$, and so a small rank is always simulated by a greater rank.
Hence, essentially the minimal rank of each location of $s$ and $o$ is relevant
to define the pre-order $\preceq_{{\sf univ}}$. The third condition requires
that only accepting states simulate accepting states.



\begin{lem}\label{lem:univ-simulation-relation}
For all NBW $\A$, 
the pre-order $\preceq_{{\sf univ}}$ is a simulation for the NBW $\KVMH(\A)$.
\end{lem} 

\proof Let $\A = \tuple{\Loc, \iota, \Sigma, \delta, \alpha}$ and 
$\KVMH(\A) = \tuple{Q \times Q, q_{\iota}, \Sigma, \delta', \alpha'}$.
First, we show that for all 
$\tuple{s_1,o_1}, \tuple{s_2,o_2}, \tuple{s_3,o_3} \in Q \times Q$, for all $\sigma \in \Sigma$,
if $\tuple{s_1,o_1} \xrightarrow{\sigma}_{\delta'} \tuple{s_2,o_2}$ 
and $\tuple{s_3,o_3} \preceq \tuple{s_1,o_1}$ 
then $\tuple{s_3,o_3} \xrightarrow{\sigma}_{\delta'} \tuple{s_2,o_2}$. Notice that we have trivially 
$\tuple{s_2,o_2} \preceq_{{\sf univ}} \tuple{s_2,o_2}$.
We give the proof for $o_1 \neq \emptyset$. 
The case $o_1 = \emptyset$ is proven similarly.
According to Definition~\ref{def:direct-complementation}, 
since $\tuple{s_1,o_1} \xrightarrow{\sigma}_{\delta'} \tuple{s_2,o_2}$ we have
$$ \begin{array}{rl}
$(i)$ & \forall (\l,n_1) \in s_1 \cdot \forall \l' \in \delta(\l,\sigma)\cdot \exists n_2 \leq n_1: (\l',n_2) \in s_2 \text{ and}\\
$(ii)$& \forall (\l,n_1) \in o_1 \cdot \forall \l' \in \delta(\l,\sigma)\cdot \exists n_2 \leq n_1: (\l',n_2) \in o_2
\end{array} 
$$
Since $\tuple{s_3,o_3} \preceq \tuple{s_1,o_1}$, we have $o_3 \neq \emptyset$ and
$$ \begin{array}{rl}
(i') & \forall (\l,n_3) \in s_3 \cdot \exists n_1 \leq n_3: (\l,n_1) \in s_1 \text{ and}\\
(ii')& \forall (\l,n_3) \in o_3 \cdot \exists n_1 \leq n_3: (\l,n_1) \in o_1
\end{array} 
$$
Combining $(i)$ and $(i')$ yields 
$\forall (\l,n_3) \in s_3 \cdot \forall \l' \in \delta(\l,\sigma)\cdot \exists n_2  \leq n_3: (\l',n_2) \in s_2:$, 
and combining $(ii)$ and $(ii')$ yields
$\forall (\l,n_3) \in o_3 \cdot \forall \l' \in \delta(\l,\sigma)\cdot \exists n_2 \leq n_3: (\l',n_2) \in o_2$. 
Since $o_3 \neq \emptyset$, this implies that $\tuple{s_3,o_3} \xrightarrow{\sigma}_{\delta'} \tuple{s_2,o_2}$.

Second, for all $\tuple{s,o} \in \alpha'$ we have $o = \emptyset$, and
thus for all $\tuple{s',o'} \in Q \times Q$, if
$\tuple{s',o'} \preceq \tuple{s,o}$ then $o' = \emptyset$ so that
$\tuple{s',o'} \in \alpha'$.

Hence $\preceq_{{\sf univ}}$ is a simulation for $\KVMH(\A)$.
\qed

According to Lemmas~\ref{lem:closure-properties-a} and~\ref{lem:closure-properties-b}, 
all intermediate sets that are computed by the fixed point $\F_{\A^c}$ to check emptiness of
$\A^c = \KVMH(\A)$ (and thus universality of~$\A$) are $\preceq_{{\sf univ}}$-closed. 
Since~$\preceq_{{\sf univ}}$ is not a partial order, 
the set $\Max(L)$ for a $\preceq_{{\sf univ}}$-closed set~$L$
may contain several $\preceq_{{\sf univ}}$-equivalent elements ($x$ and $y$ are 
$\preceq_{{\sf univ}}$-equivalent if $x \preceq_{{\sf univ}} y$ and $y \preceq_{{\sf univ}} x$).
For example, the set $\{\tuple{\{(\l,3),(\l',4)\},\emptyset}\}$ is 
$\preceq_{{\sf univ}}$-equivalent to the set 
$\{\tuple{\{(\l,3),(\l,4),(\l',4)\},\emptyset}\}$.
In fact $\Max(L)$ is a union of $\preceq_{{\sf univ}}$-equivalent classes.
Hence, the size of $\Max(L)$ can be reduced by keeping only one canonical 
element for each $\preceq_{{\sf univ}}$-equivalent class.
Given a set $s \in Q$, define its \emph{characteristic function} $f_s:\Loc \to \nat
\cup \{ \infty \}$ such that $f_s(\l) = \inf\{n \mid (\l,n) \in s\}$
with the usual convention that $\inf\; \emptyset = \infty$.
Note that if $f_s(\l) \neq \infty$, then $f_s(\l)$ is even for all $\l \in \alpha$.

Let $f,g,f',g'$ be characteristic functions. Let $\max(f,f')$ be the function~$f''$ 
such that $f''(\l) = \max\{f(\l), f'(\l)\}$ for all $\l \in \Loc$.
We denote by $f_{\emptyset}$ the function such that $f_{\emptyset}(\l) = \infty$ for all $\l \in \Loc$.  
We write $f \leq f'$ if for all $\l \in \Loc$, $f(\l) \leq f'(\l)$ and we write 
$\tuple{f,g} \leq \tuple{f',g'}$ if $f \leq f'$, $g \leq g'$ and $g = f_{\emptyset}$ iff $g = f_{\emptyset}$.
Notice that~$\leq$ is partial order over characteristic functions,
and that if $s \subseteq s'$, then $f_{s'} \leq f_s$ for all $s,s' \in Q$.
The following lemma is a corollary of Definition~\ref{def:simulation-for-KVMH}.

\begin{lem}\label{lem:characteristic-function}
  For all sets $s,s',o,o' \in Q$, $\tuple{f_{s'},f_{o'}} \leq  \tuple{f_{s},f_{o}}$
  if and only if $\tuple{s,o} \preceq_{{\sf univ}} \tuple{s',o'}$.
\end{lem}


Define $\sem{f} = \{s \in Q \mid \exists s' \in Q: s \subseteq s' \land f_{s'} = f\}$ and 
$\sem{\tuple{f,g}} = \{\tuple{s,o} \mid \tuple{f,g} \leq  \tuple{f_{s},f_{o}} \}$.
We extend the operator $\sem{\cdot}$ to sets of pairs of characteristic
functions as expected. 
Notice that $f \leq f'$ iff $\sem{f'} \subseteq \sem{f}$, that $\sem{\max(f,f')} = \sem{f} \cap \sem{f'}$, and 
a corollary of Lemma~\ref{lem:characteristic-function} is that 
the $\leq$-minimal elements of a set $L$ of pairs of characteristic functions
represents exactly the $\preceq_{{\sf univ}}$-maximal pairs $\tuple{s,o}$ of $\sem{L}$.








Now, we show how to compute efficiently $\cup$, $\cap$ and $\Pre$ for
$\preceq_{{\sf univ}}$-closed sets that are represented by
characteristic functions. 
Let $L_1, L_2$ be two sets of pairs of
characteristic functions, let $L_{\cup}$ be the set
of $\leq$-minimal elements of $L_1 \cup L_2$, and let $L_{\cap}$ be the $\leq$-minimal elements
of the union of:
\begin{enumerate}[$\bullet$]
\item[] $\{\tuple{\max(f_s,f_{s'}), \max(f_o,f_{o'})} \mid 
\tuple{f_s,f_o} \in L_1 \land \tuple{f_{s'},f_{o'}} \in L_2 \land \max(f_o,f_{o'}) \not= f_{\emptyset} \}$ and
\item[] $\{\tuple{\max(f_s,f_{s'}), f_{\emptyset}} \mid 
\tuple{f_s,f_{\emptyset}} \in L_1 \land \tuple{f_{s'},f_{\emptyset}} \in L_2 \}$.
\end{enumerate}
By Equation~\eqref{eq:intersection} and by the previous remarks, we have:
\begin{enumerate}[$\bullet$]
\item[] $\sem{L_{\cup}} = \sem{L_1} \cup \sem{L_2}$ and $\sem{L_{\cap}} = \sem{L_1} \cap \sem{L_2}$.
\end{enumerate}\medskip

\noindent To compute $\Pre_{\sigma}(\cdot)$ of a single pair of
characteristic functions, we propose Algorithm~2 whose correctness is
established by Theorem~\ref{theo:correctness-alg-pre}. Computing the
predecessors of a set of characteristic functions is then
straightforward using the algorithm for union of sets of pairs of
characteristic functions since
$$\Pre^{\KVMH(\A)}(L) = \bigcup_{\sigma \in \Sigma} \bigcup_{\l \in L} \Pre^{\KVMH(\A)}_{\sigma}(\l).$$
In Algorithm~2, we represent $\infty$ by any number
strictly greater than $k = 2(\abs{\Loc} - \abs{\alpha})$, and we adapt the definition of $\leq$ as
follows: $f \leq f'$ iff for all $\l \in \Loc$, either $f(\l) \leq
f'(\l)$ or $f'(\l) > k$. In the algorithm, we use the notations
$\ceilOdd{n}$ for the least odd number $n'$ such that $n' \geq n$, and
$\ceilEven{n}$ for the least even number $n'$ such that $n' \geq n$.

The structure of Algorithm~2
is similar to Algorithm~1, but the computations are expressed 
in terms of characteristic functions, thus in terms of ranks. For example,
\mbox{lines~\ref{alg:pre-line-o-alpha}-\ref{alg:pre-line-o-not-alpha}} compute
the equivalent of line~\ref{alg:pre-alt-o} in Algorithm~1,
where $\alpha_1$ corresponds here to the set of odd-ranked locations,
and thus contains no $\alpha$-nodes. Details are given in the proof of 
Theorem~\ref{theo:correctness-alg-pre}.

\begin{thm}\label{theo:correctness-alg-pre}
  Let $\A = \tuple{\Loc, \iota, \Sigma, \delta, \alpha}$ be a NBW, 
  $\sigma \in \Sigma$, and $\tuple{f_{s'},f_{o'}}$ be a pair of characteristic functions 
  such that $f_{s'} \leq f_{o'}$.
  The set $L_{\Pre} = \Pre^{{\sf univ}}_{\sigma}(\tuple{f_{s'},f_{o'}})$ computed by
  Algorithm~2 is such that 
  $\sem{L_{\Pre}} = \Pre^{\KVMH(\A)}_{\sigma}(\sem{\tuple{f_{s'},f_{o'}}})$
  and for all $\tuple{f_{s},f_{o}} \in L_{\Pre}$, we have $f_{s} \leq f_{o}$
  and $f_{s}(\l)$ and $f_{o}(\l)$ are even for all $\l \in \alpha$.
\end{thm} 

\proof 
Let $\A^c = \KVMH(\A) = \tuple{Q \times Q, q_{\iota}, \Sigma, \delta', \alpha'}$,
and let $\tuple{s',o'}$ be a pair of sets whose characteristic functions
are $\tuple{f_{s'},f_{o'}}$ and $o'\subseteq s'$ (such a pair exists because
$f_{s'} \leq f_{o'}$).
We show that (a) $\sem{L_{\Pre}} \subseteq \Pre^{\A^c}_{\sigma}(\sem{\tuple{f_{s'},f_{o'}}})$ and
(b) $\Pre^{\A^c}_{\sigma}(\sem{\tuple{f_{s'},f_{o'}}}) \subseteq \sem{L_{\Pre}}$.

To prove (a), first consider a pair $\tuple{f_s,f_o}$ added to $L_{\Pre}$ at 
line~\ref{alg:pre-line-Z-one} of Algorithm~2 and let 
$\tuple{s,o} \in \sem{\tuple{f_s,f_o}}$. We show that 
$\tuple{s,o} \xrightarrow{\sigma}_{\delta'} \tuple{s',o'}$ and $f_s \leq f_o$.

By the test of line~\ref{alg:pre-line-emtpiness-test}, we have $f_o \neq f_{\emptyset}$
and therefore $o \neq \emptyset$. 
According to Definition~\ref{def:direct-complementation} of $\KVMH(\A)$, 
we have to check that there exists a set $o'' \subseteq s'$ such that 
$o' = o'' \setminus \odd$ (we take $o'' = o' \cup (s' \cap \odd)$), 
and the following conditions hold:
\begin{enumerate}[$(i)$]
\item $\forall (\l,n) \in s \cdot \forall \l' \in \delta(\l,\sigma)\cdot \exists n' \leq n: (\l',n') \in s'$.

		Observe that for all $\l \in \Loc$, for all $\l' \in \delta(\l,\sigma)$, 
		we have $f_{s'}(\l') \leq f_s(\l)$ (lines~\ref{alg:pre-line-f-s},\ref{alg:pre-line-s-ceileven} 
		of Algorithm~2). 
		Since $f_s(\l) \leq n$ (by definition of characteristic functions), 
		we take $n' = f_{s'}(\l')$ so that we have $n' \leq f_s(\l) \leq n$ and $(\l',n') \in s'$. 
		
\item $\forall (\l,n) \in o \cdot \forall \l' \in \delta(\l,\sigma)\cdot \exists n' \leq n: (\l',n') \in o''$.

		Since $o'' = o' \cup (s' \cap \odd)$, we have $f_{o''}(\l') = f_{o'}(\l')$ for $\l' \in \alpha$
		and $f_{o''}(\l') = \min\{ f_{o'}(\l'), \ceilOdd{f_{s'}(\l')} \}$ for $\l' \not\in \alpha$.
		Now, for all $\l \in \Loc$, for all $\l' \in \delta(\l,\sigma)$, 
		we have either $\l' \in \alpha$ and then $f_o(\l) \geq n'$ for $n' = f_{o'}(\l')$, 
		or $\l' \not\in \alpha$ and then $f_o(\l) \geq n'$ for $n' = \min\{ f_{o'}(\l'), \ceilOdd{f_{s'}(\l')} \}$
		(lines~\ref{alg:pre-line-o-alpha}-\ref{alg:pre-line-o-ceileven} 
		of Algorithm~2).
		In both cases, for $(\l,n) \in o$ we have $f_{o''}(\l') \leq n' \leq f_o(\l) \leq n$ and $(\l',n') \in o''$.
\end{enumerate}
Moreover, we prove that:
\begin{enumerate}[$(i)$]
\item[$(iii)$] $f_s \leq f_o$.

Since $f_{s'} \leq f_{o'}$, we have for all $\l' \in \Loc$ either 
$f_{o'}(\l') > k$ or $f_{o'}(\l') \geq f_{s'}(\l')$.
By lines~\ref{alg:pre-line-o-alpha}-\ref{alg:pre-line-o-ceileven} of Algorithm~2,
we have for all $\l \in \Loc$, for all $\l' \in \delta(\l,\sigma)$ 
either $f_o(\l) \geq f_{o'}(\l')$ or $f_o(\l) \geq \ceilOdd{f_{s'}(\l')}$,
and thus either $f_o(\l) > k$ or $f_o(\l) \geq f_{s'}(\l')$. 
Hence, we have for all $\l \in \Loc$ either $f_o(\l) > k$ or 
$f_o(\l) \geq \max \{f_{s'}(\l') \mid \l' \in \delta(\l,\sigma) \}$.
Therefore, by lines~\ref{alg:pre-line-f-s}-\ref{alg:pre-line-s-ceileven} of 
Algorithm~2, if $\l \not\in \alpha$, then $f_o(\l) > k$ or $f_o(\l) \geq f_{s}(\l)$,
and if $\l \in \alpha$, then $f_o(\l)$ is even (line~\ref{alg:pre-line-o-ceileven})
and thus either $f_o(\l) > k$ or $f_o(\l) \geq \ceilEven{\max \{f_{s'}(\l') \mid \l' \in \delta(\l,\sigma) \}} = f_{s}(\l)$.
In all cases, $f_s \leq f_o$.

\item[(iv)] $\forall \l \in \alpha: f_s(\l)$ and $f_o(\l)$ are even. 

This is enforced by line~\ref{alg:pre-line-s-ceileven} and line~\ref{alg:pre-line-o-ceileven} of the algorithm.
\end{enumerate}


\noindent Second, consider a pair $\tuple{f_o,f_{\emptyset}}$ added to
$L_{\Pre}$ at line~\ref{alg:pre-line-Z-two}, and let
$\tuple{s,\emptyset} \in \sem{\tuple{f_o,f_{\emptyset}}}$.  Notice
that $f_o \leq f_{\emptyset}$ and that $f_o(\l)$ is even for all $\l
\in \alpha$ by $(iv)$.  We show that there exists $\tuple{s'',o''}
\preceq_{{\sf univ}} \tuple{s',o'}$ such that $\tuple{s,\emptyset}
\xrightarrow{\sigma}_{\delta'} \tuple{s'',o''}$.  We take $s'' = o'
\cup (s' \cap \odd)$ and $o'' = s'' \setminus \odd$.  Since $o'
\subseteq s'$, we have $(1)$ $s'' \subseteq s'$, and we have $(2)$
$o'' = o' \setminus \odd \subseteq o'$.  Moreover, if $o' \neq
\emptyset$, then there exists let $(\l,n) \in o'$ for some $\l \in
\Loc$ and even number $n$, since the maximal rank $k = 2(\abs{\Loc} -
\abs{\alpha})$ is even. So $(\l,n) \in o''$ and thus $o'' \neq
\emptyset$.  Since $o'' \subseteq o'$, we have $(3)$ $o' \neq
\emptyset$ iff $o'' \neq \emptyset$.  Hence $\tuple{s'',o''}
\preceq_{{\sf univ}} \tuple{s',o'}$. The fact that
$\tuple{f_o,\emptyset} \xrightarrow{\sigma}_{\delta'} \tuple{s'',o''}$
is proven similarly to $(ii)$.

To prove (b), assume that there exist $\tuple{s_1,o_1}$ and $\tuple{s_1',o_1'}$
such that $\tuple{s_1,o_1} \xrightarrow{\sigma}_{\delta'} \tuple{s_1',o_1'}$ and 
$\tuple{s_1',o_1'} \in \sem{\tuple{f_{s'},f_{o'}}}$.
We have to show that $\tuple{s_1,o_1} \in \sem{L_{\Pre}}$, i.e., 
$\tuple{f_{s_1},f_{o_1}} \geq \tuple{f_s,f_o}$ for some $\tuple{f_s,f_o} \in L_{\Pre}$.

First, assume that $o_1 \neq \emptyset$. 
Notice that $f_{s_1'} \geq f_{s'}$ and $f_{o_1'} \geq f_{o'}$ 
since $\tuple{s_1',o_1'} \in \sem{\tuple{f_{s'},f_{o'}}}$,
From the fact that $\tuple{s_1,o_1} \xrightarrow{\sigma}_{\delta'} \tuple{s_1',o_1'}$,
we get:
\begin{enumerate}[$(i)$] 
\item for all $(\l,n_1) \in s_1$, for all $\l' \in \delta(\l,\sigma)$, $n_1 \geq f_{s_1}(\l) \geq f_{s_1'}(\l')$ 
and thus $n_1 \geq f_{s'}(\l')$. Hence, for all $\l \in \Loc$ we have
$f_{s_1}(\l) \geq \max\{f_{s'}(\l') \mid \l' \in \delta(\l,\sigma)\} = f_s(\l)$,
where $f_s$ is computed by line~\ref{alg:pre-line-f-s} of Algorithm~2) for $\l \not\in \alpha$. 
We also have $f_{s_1}(\l) \geq f_s(\l)$ (see line~\ref{alg:pre-line-s-ceileven} of Algorithm~2) 
for $\l \in \alpha$, as $f_{s_1}(\l)$ is even in that case.
Thus, $f_s \leq f_{s_1}$.
 
\item for all $(\l,n_2) \in o_1$, for all $\l' \in \delta(\l,\sigma)$, $n_2 \geq f_{o_1}(\l) \geq f_{o_1''}(\l')$ 
for some set $o_1''$ such that $o_1'' \subseteq s_1'$ and $o_1'' \setminus \odd = o_1'$. 
Therefore $o_1'' \subseteq o_1' \cup (s_1' \cap \odd)$
and thus $f_{o_1''} \geq f_{o_1' \cup (s_1' \cap \odd)} \geq f_{o' \cup (s' \cap \odd)}$
since $f_{s_1'} \geq f_{s'}$ and $f_{o_1'} \geq f_{o'}$.
Hence, for all $\l \in \Loc$ 
either $f_{o_1}(\l) > k$ or $f_{o_1}(\l) \geq f_o(\l)$ (where $f_o$ is computed 
at lines~\ref{alg:pre-line-f-o-begin}-\ref{alg:pre-line-f-o-end} of Algorithm~2).
Thus, $f_o \leq f_{o_1}$.

\item By our assumption that $o_1 \neq \emptyset$, we have $f_{o_1} \neq f_{\emptyset}$, and 
so $f_{o} \neq f_{\emptyset}$ by $(ii)$.
\end{enumerate}\medskip

\noindent Hence, the pair $\tuple{f_s,f_o}$ added to $L_{\Pre}$ by
Algorithm~2 at line~\ref{alg:pre-line-Z-one} satisfies
$\tuple{f_{s_1},f_{o_1}} \geq \tuple{f_s,f_o}$ and thus
$\tuple{s_1,o_1} \in \sem{L_{\Pre}}$.



Second, assume that $o_1 = \emptyset$. Let $s'' = o' \cup (s' \cap \odd)$. 
Since $\tuple{s_1,o_1} \xrightarrow{\sigma}_{\delta'} \tuple{s_1',o_1'}$ and $o_1 = \emptyset$,
we have $o_1' = s_1' \setminus \odd$. 
Next, we use several times the fact that $u \subseteq v$ implies $f_v \leq f_u$. 
Since $f_{s_1'} \geq f_{s'}$ and $f_{o_1'} \geq f_{o'}$, we have 
$(1)$ $f_{s_1' \cap \odd} \geq f_{s' \cap \odd} \geq f_{s''}$ 
and $(2)$ $f_{s_1' \setminus \odd} = f_{o_1'} \geq f_{o'} \geq f_{s''}$. 
By $(1)$ and $(2)$, we get easily $f_{s_1'} \geq f_{s''}$.
Now, by the fact that 
$\tuple{s_1,o_1} \xrightarrow{\sigma}_{\delta'} \tuple{s_1',o_1'}$, we know that
for all $(\l,n_1) \in s_1$, for all $\l' \in \delta(\l,\sigma)$, $n_1 \geq f_{s_1'}(\l')$ 
and thus $n_1 \geq f_{s''}(\l')$. 
Notice that $f_o(\l) = \max\{f_{s''}(\l') \mid \l' \in\delta(\l,\sigma)\}$,
where $f_o$ is computed at lines~\ref{alg:pre-line-f-o-begin}-\ref{alg:pre-line-f-o-end} of Algorithm~2. 
Thus, $n_1 \geq f_{o}(\l)$ for all $\l \in \Loc$ 
and therefore $f_{s_1} \leq f_{o}$ so that $\tuple{s_1,o_1} \in \sem{\tuple{f_o,f_{\emptyset}}}$
where $\tuple{f_o,f_{\emptyset}}$ is added to $L_{\Pre}$ by Algorithm~2 at line~\ref{alg:pre-line-Z-one}. 
\qed


Algorithm~2 computes the predecessors of a pair $\tuple{f_{s'},f_{o'}}$
in time $O(\abs{\Loc}^2)$, which is polynomial in the size of the input, even though
the number of pairs $\tuple{s',o'}$ that are represented by the pair $\tuple{f_{s'},f_{o'}}$
and by the computed set $L_{\Pre}$ can be of exponential size.
For example, the set $\alpha'= Q \times \{\emptyset\}$ 
with an exponential number of elements is represented by the unique
pair $\tuple{f_s,f_{\emptyset}}$ where $f_s(\l) = 0$ for all $\l \in \Loc$.
Hence the compact representation that we propose does not come
with an execution time blow-up, which makes the new approach much more efficient 
in practice.


\begin{algorithm}[!tbp]
\AlgData{A NBW $\A = \tuple{\Loc, \iota, \Sigma, \delta, \alpha}$, $\sigma \in \Sigma$,
   and a pair $\tuple{f_{s'},f_{o'}}$ of characteristic functions.} 
  \AlgResult{The set $\Pre^{{\sf univ}}_{\sigma}(\tuple{f_{s'},f_{o'}})$.}
  \flushleft
  \Begin { 
\nl \ForEach{$\l \in \Loc$ \label{alg:pre-line-f-o-begin}}
	{
		\nl $f_o(\l) \gets 0$ \;
	    	\nl \ForEach{$\l' \in \delta(\l,\sigma)$}
		{
			\nl \lIf{$\l' \in \alpha$}{$f_o(\l) \gets \max \{f_o(\l), f_{o'}(\l')\}$} \label{alg:pre-line-o-alpha} \;
			\nl \lElse{$f_o(\l) \gets \max \{f_o(\l), \min\{f_{o'}(\l'), \ceilOdd{f_{s'}(\l')}\}\}$} \label{alg:pre-line-o-not-alpha}\;
		}
		\nl \lIf{$\l \in \alpha$}{$f_o(\l) \gets \ceilEven{f_o(\l)}$ \label{alg:pre-line-o-ceileven} \label{alg:pre-line-f-o-end}} \;
	}
	\nl $L_{\Pre} \gets \{\tuple{f_o,f_{\emptyset}}\}$ \label{alg:pre-line-Z-two}\;
	\nl $k \gets 2(\abs{\Loc} - \abs{\alpha})$ \;
	\nl \If{$\exists \l: f_o(\l) \leq k$ ({\it i.e.} $o \neq \emptyset$) \label{alg:pre-line-emtpiness-test}}
	{
		\nl \ForEach{$\l \in \Loc$}
		{
			\nl $f_s(\l) \gets \max \{f_{s'}(\l') \mid \l' \in \delta(\l,\sigma) \}$ \label{alg:pre-line-f-s} \;
			\nl \lIf{$\l \in \alpha$}{$f_s(\l) \gets \ceilEven{f_s(\l)}$ \label{alg:pre-line-s-ceileven}} \;
			
		}
		\nl $L_{\Pre} \gets L_{\Pre} \cup \{\tuple{f_s,f_o}\}$ \label{alg:pre-line-Z-one}\;
	}
	


  \nl \KwRet{$L_{\Pre}$}\; }\medskip

\caption{Algorithm for $\Pre^{{\sf univ}}_{\sigma}(\cdot)$. \label{alg:pre}}

\end{algorithm}








\section{Implementation and Practical Evaluation}\label{sec:implementation}

\paragraph{{\bf The randomized model}}
To evaluate our new algorithm for universality of NBW and compare with
the existing implementations of the Kupferman-Vardi and Miyano-Hayashi
constructions, we use a random model to generate NBW.  This model was
first proposed by Tabakov and Vardi to compare the efficiency of
some algorithms for automata in the context of finite words 
automata~\cite{TabakovV05} and more recently in the context of infinite
words automata~\cite{TabakovV07}.
In the model, the input alphabet is fixed to $\Sigma=\{0,1\}$, and for
each letter $\sigma \in \Sigma$, a number $k_\sigma$ of different
state pairs $(\l, \l') \in \Loc \times \Loc$ are chosen uniformly at
random before the corresponding transitions $(\l,\sigma,\l')$ are
added to the automaton.  The ratio $r_\sigma=\frac{k_\sigma}{|\Loc|}$
is called the \emph{transition density} for~$\sigma$.  This ratio
represents the average outdegree of each state for~$\sigma$.  In all
experiments, we choose $r_0=r_1$, and denote the transition density
by~$r$.  The model contains a second parameter: the \emph{density $f$
  of accepting states}.  There is only one initial state, and the
number $m$ of accepting states is linear in the total number of
states, as determined by $f=\frac{m}{|\Loc|}$.  The accepting states
themselves are chosen uniformly at random.  Observe that since the
transition relation is not always total, automata with $f=1$ are not
necessarily universal.

Tabakov and Vardi have studied the space of parameter values for this
model and argue that ``interesting'' automata are generated by the
model as the two parameters $r$ and $f$ vary. They also study the 
density of universal automata.

\paragraph{{\bf Performance comparison}}
We have implemented our algorithm to check the universality of
randomly generated NBW. The code is written in {\tt C} with an
explicit representation for characteristic functions, as arrays of
integers.  All the experiments are conducted on a biprocessor Linux
station (two $3.06$Ghz Intel Xeons with $4$GB of RAM).

\figurename~\ref{fig:median-time} shows as a function of $r$
(transition density) and $f$ (density of accepting states) the median
execution times for testing universality of $100$ random automata with
$\abs{\Loc}=30$.  It shows that the universality test was the most
difficult for $r=1.8$ and $f=0.1$ with a median time of $11$ seconds.
The times for $r \leq 1$ and $r \geq 2.8$ are not plotted because they
were always less than $250$ms.  A similar shape and maximal median
time is reported by Tabakov for automata
of size $6$, that is for automata that are five times smaller~\cite{TabakovV07}.  Another previous work reports prohibitive execution times for
complementing NBW of size $6$, showing that explicitly constructing
the complement is not a reasonable approach~\cite{GurumurthyKSV03}.
The density of universal automata in the samples is shown in \figurename~\ref{fig:density}.
The density increases when states have more transitions, while 
it seems less sensitive to the density of accepting states. The difficult 
instances correspond to the values of the densities of transitions and 
accepting states for which the probability to be universal is close to a half.
Analogous results have been observed in~\cite{TabakovV07}.


To evaluate the scalability of our algorithm, 
we have run the following experiment. For a set of
parameter values, we have evaluated the maximal size of automata
(measured in term of number of locations) for which our algorithm 
could analyze $50$ over $100$ instances in less than 20 seconds. 
We have tried automata sizes from $10$ to $1500$, with a fine granularity
for small sizes (from $10$ to $100$ with an increment of $10$, from 
$100$ to $200$ with an increment of $20$, and from $200$ to $500$ 
with an increment of $30$) and a rougher granularity for
large sizes (from $500$ to $1000$ with an increment of $50$, and
from $1000$ to $1500$ with an increment of $100$). 




\begin{figure}[!tbp]
  \begin{minipage}[b]{.45\linewidth}
    \scalebox{0.5}{\begingroup
  \catcode`\@=11\relax
  \def\GNUPLOTspecial{\def\do##1{\catcode`##1=12\relax}\dospecials
    \catcode`\{=1\catcode`\}=2\catcode\%=14\relax\special}\expandafter\ifx\csname GNUPLOTpicture\endcsname\relax
  \csname newdimen\endcsname\GNUPLOTunit
  \gdef\GNUPLOTpicture(#1,#2){\vbox to#2\GNUPLOTunit\bgroup
    \def\put(##1,##2)##3{\unskip\raise##2\GNUPLOTunit
      \hbox to0pt{\kern##1\GNUPLOTunit ##3\hss}\ignorespaces}\def\ljust##1{\vbox to0pt{\vss\hbox to0pt{##1\hss}\vss}}\def\cjust##1{\vbox to0pt{\vss\hbox to0pt{\hss ##1\hss}\vss}}\def\rjust##1{\vbox to0pt{\vss\hbox to0pt{\hss ##1}\vss}}\def\stack##1{\let\\=\cr\tabskip=0pt\halign{\hfil ####\hfil\cr ##1\crcr}}\def\lstack##1{\hbox to0pt{\vbox to0pt{\vss\stack{##1}}\hss}}\def\cstack##1{\hbox to0pt{\hss\vbox to0pt{\vss\stack{##1}}\hss}}\def\rstack##1{\hbox to0pt{\vbox to0pt{\stack{##1}\vss}\hss}}\vss\hbox to#1\GNUPLOTunit\bgroup\ignorespaces}\gdef\endGNUPLOTpicture{\hss\egroup\egroup}\fi
\GNUPLOTunit=0.1bp
\GNUPLOTpicture(3600,2160)
{\GNUPLOTspecial{"
/gnudict 256 dict def
gnudict begin
/Color false def
/Solid false def
/gnulinewidth 5.000 def
/userlinewidth gnulinewidth def
/vshift -33 def
/dl {10.0 mul} def
/hpt_ 31.5 def
/vpt_ 31.5 def
/hpt hpt_ def
/vpt vpt_ def
/Rounded false def
/M {moveto} bind def
/L {lineto} bind def
/R {rmoveto} bind def
/V {rlineto} bind def
/N {newpath moveto} bind def
/C {setrgbcolor} bind def
/f {rlineto fill} bind def
/vpt2 vpt 2 mul def
/hpt2 hpt 2 mul def
/Lshow { currentpoint stroke M
  0 vshift R show } def
/Rshow { currentpoint stroke M
  dup stringwidth pop neg vshift R show } def
/Cshow { currentpoint stroke M
  dup stringwidth pop -2 div vshift R show } def
/UP { dup vpt_ mul /vpt exch def hpt_ mul /hpt exch def
  /hpt2 hpt 2 mul def /vpt2 vpt 2 mul def } def
/DL { Color {setrgbcolor Solid {pop []} if 0 setdash }
 {pop pop pop 0 setgray Solid {pop []} if 0 setdash} ifelse } def
/BL { stroke userlinewidth 2 mul setlinewidth
      Rounded { 1 setlinejoin 1 setlinecap } if } def
/AL { stroke userlinewidth 2 div setlinewidth
      Rounded { 1 setlinejoin 1 setlinecap } if } def
/UL { dup gnulinewidth mul /userlinewidth exch def
      dup 1 lt {pop 1} if 10 mul /udl exch def } def
/PL { stroke userlinewidth setlinewidth
      Rounded { 1 setlinejoin 1 setlinecap } if } def
/LTw { PL [] 1 setgray } def
/LTb { BL [] 0 0 0 DL } def
/LTa { AL [1 udl mul 2 udl mul] 0 setdash 0 0 0 setrgbcolor } def
/LT0 { PL [] 1 0 0 DL } def
/LT1 { PL [4 dl 2 dl] 0 1 0 DL } def
/LT2 { PL [2 dl 3 dl] 0 0 1 DL } def
/LT3 { PL [1 dl 1.5 dl] 1 0 1 DL } def
/LT4 { PL [5 dl 2 dl 1 dl 2 dl] 0 1 1 DL } def
/LT5 { PL [4 dl 3 dl 1 dl 3 dl] 1 1 0 DL } def
/LT6 { PL [2 dl 2 dl 2 dl 4 dl] 0 0 0 DL } def
/LT7 { PL [2 dl 2 dl 2 dl 2 dl 2 dl 4 dl] 1 0.3 0 DL } def
/LT8 { PL [2 dl 2 dl 2 dl 2 dl 2 dl 2 dl 2 dl 4 dl] 0.5 0.5 0.5 DL } def
/Pnt { stroke [] 0 setdash
   gsave 1 setlinecap M 0 0 V stroke grestore } def
/Dia { stroke [] 0 setdash 2 copy vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath stroke
  Pnt } def
/Pls { stroke [] 0 setdash vpt sub M 0 vpt2 V
  currentpoint stroke M
  hpt neg vpt neg R hpt2 0 V stroke
  } def
/Box { stroke [] 0 setdash 2 copy exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V closepath stroke
  Pnt } def
/Crs { stroke [] 0 setdash exch hpt sub exch vpt add M
  hpt2 vpt2 neg V currentpoint stroke M
  hpt2 neg 0 R hpt2 vpt2 V stroke } def
/TriU { stroke [] 0 setdash 2 copy vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath stroke
  Pnt  } def
/Star { 2 copy Pls Crs } def
/BoxF { stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V  hpt2 0 V  0 vpt2 V
  hpt2 neg 0 V  closepath fill } def
/TriUF { stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath fill } def
/TriD { stroke [] 0 setdash 2 copy vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath stroke
  Pnt  } def
/TriDF { stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath fill} def
/DiaF { stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath fill } def
/Pent { stroke [] 0 setdash 2 copy gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath stroke grestore Pnt } def
/PentF { stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath fill grestore } def
/Circle { stroke [] 0 setdash 2 copy
  hpt 0 360 arc stroke Pnt } def
/CircleF { stroke [] 0 setdash hpt 0 360 arc fill } def
/C0 { BL [] 0 setdash 2 copy moveto vpt 90 450  arc } bind def
/C1 { BL [] 0 setdash 2 copy        moveto
       2 copy  vpt 0 90 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C2 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 90 180 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C3 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 0 180 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C4 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 180 270 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C5 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 0 90 arc
       2 copy moveto
       2 copy  vpt 180 270 arc closepath fill
               vpt 0 360 arc } bind def
/C6 { BL [] 0 setdash 2 copy moveto
      2 copy  vpt 90 270 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C7 { BL [] 0 setdash 2 copy moveto
      2 copy  vpt 0 270 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C8 { BL [] 0 setdash 2 copy moveto
      2 copy vpt 270 360 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C9 { BL [] 0 setdash 2 copy moveto
      2 copy  vpt 270 450 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C10 { BL [] 0 setdash 2 copy 2 copy moveto vpt 270 360 arc closepath fill
       2 copy moveto
       2 copy vpt 90 180 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C11 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 0 180 arc closepath fill
       2 copy moveto
       2 copy  vpt 270 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C12 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 180 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C13 { BL [] 0 setdash  2 copy moveto
       2 copy  vpt 0 90 arc closepath fill
       2 copy moveto
       2 copy  vpt 180 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C14 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 90 360 arc closepath fill
               vpt 0 360 arc } bind def
/C15 { BL [] 0 setdash 2 copy vpt 0 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/Rec   { newpath 4 2 roll moveto 1 index 0 rlineto 0 exch rlineto
       neg 0 rlineto closepath } bind def
/Square { dup Rec } bind def
/Bsquare { vpt sub exch vpt sub exch vpt2 Square } bind def
/S0 { BL [] 0 setdash 2 copy moveto 0 vpt rlineto BL Bsquare } bind def
/S1 { BL [] 0 setdash 2 copy vpt Square fill Bsquare } bind def
/S2 { BL [] 0 setdash 2 copy exch vpt sub exch vpt Square fill Bsquare } bind def
/S3 { BL [] 0 setdash 2 copy exch vpt sub exch vpt2 vpt Rec fill Bsquare } bind def
/S4 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt Square fill Bsquare } bind def
/S5 { BL [] 0 setdash 2 copy 2 copy vpt Square fill
       exch vpt sub exch vpt sub vpt Square fill Bsquare } bind def
/S6 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill Bsquare } bind def
/S7 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill
       2 copy vpt Square fill
       Bsquare } bind def
/S8 { BL [] 0 setdash 2 copy vpt sub vpt Square fill Bsquare } bind def
/S9 { BL [] 0 setdash 2 copy vpt sub vpt vpt2 Rec fill Bsquare } bind def
/S10 { BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt Square fill
       Bsquare } bind def
/S11 { BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt2 vpt Rec fill
       Bsquare } bind def
/S12 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill Bsquare } bind def
/S13 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill
       2 copy vpt Square fill Bsquare } bind def
/S14 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill
       2 copy exch vpt sub exch vpt Square fill Bsquare } bind def
/S15 { BL [] 0 setdash 2 copy Bsquare fill Bsquare } bind def
/D0 { gsave translate 45 rotate 0 0 S0 stroke grestore } bind def
/D1 { gsave translate 45 rotate 0 0 S1 stroke grestore } bind def
/D2 { gsave translate 45 rotate 0 0 S2 stroke grestore } bind def
/D3 { gsave translate 45 rotate 0 0 S3 stroke grestore } bind def
/D4 { gsave translate 45 rotate 0 0 S4 stroke grestore } bind def
/D5 { gsave translate 45 rotate 0 0 S5 stroke grestore } bind def
/D6 { gsave translate 45 rotate 0 0 S6 stroke grestore } bind def
/D7 { gsave translate 45 rotate 0 0 S7 stroke grestore } bind def
/D8 { gsave translate 45 rotate 0 0 S8 stroke grestore } bind def
/D9 { gsave translate 45 rotate 0 0 S9 stroke grestore } bind def
/D10 { gsave translate 45 rotate 0 0 S10 stroke grestore } bind def
/D11 { gsave translate 45 rotate 0 0 S11 stroke grestore } bind def
/D12 { gsave translate 45 rotate 0 0 S12 stroke grestore } bind def
/D13 { gsave translate 45 rotate 0 0 S13 stroke grestore } bind def
/D14 { gsave translate 45 rotate 0 0 S14 stroke grestore } bind def
/D15 { gsave translate 45 rotate 0 0 S15 stroke grestore } bind def
/DiaE { stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath stroke } def
/BoxE { stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V closepath stroke } def
/TriUE { stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath stroke } def
/TriDE { stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath stroke } def
/PentE { stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath stroke grestore } def
/CircE { stroke [] 0 setdash 
  hpt 0 360 arc stroke } def
/Opaque { gsave closepath 1 setgray fill grestore 0 setgray closepath } def
/DiaW { stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V Opaque stroke } def
/BoxW { stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V Opaque stroke } def
/TriUW { stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V Opaque stroke } def
/TriDW { stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V Opaque stroke } def
/PentW { stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  Opaque stroke grestore } def
/CircW { stroke [] 0 setdash 
  hpt 0 360 arc Opaque stroke } def
/BoxFill { gsave Rec 1 setgray fill grestore } def
/BoxColFill {
  gsave Rec
  /Fillden exch def
  currentrgbcolor
  /ColB exch def /ColG exch def /ColR exch def
  /ColR ColR Fillden mul Fillden sub 1 add def
  /ColG ColG Fillden mul Fillden sub 1 add def
  /ColB ColB Fillden mul Fillden sub 1 add def
  ColR ColG ColB setrgbcolor
  fill grestore } def
/PatternFill { gsave /PFa [ 9 2 roll ] def
    PFa 0 get PFa 2 get 2 div add PFa 1 get PFa 3 get 2 div add translate
    PFa 2 get -2 div PFa 3 get -2 div PFa 2 get PFa 3 get Rec
    gsave 1 setgray fill grestore clip
    currentlinewidth 0.5 mul setlinewidth
    /PFs PFa 2 get dup mul PFa 3 get dup mul add sqrt def
    0 0 M PFa 5 get rotate PFs -2 div dup translate
	0 1 PFs PFa 4 get div 1 add floor cvi
	{ PFa 4 get mul 0 M 0 PFs V } for
    0 PFa 6 get ne {
	0 1 PFs PFa 4 get div 1 add floor cvi
	{ PFa 4 get mul 0 2 1 roll M PFs 0 V } for
    } if
    stroke grestore } def
/Symbol-Oblique /Symbol findfont [1 0 .167 1 0 0] makefont
dup length dict begin {1 index /FID eq {pop pop} {def} ifelse} forall
currentdict end definefont pop
end
gnudict begin
gsave
0 0 translate
0.100 0.100 scale
0 setgray
newpath
1.000 UL
LTb
1.000 UP
1.000 UL
LT0
1225 1305 M
233 147 V
1.000 UL
LT0
1690 1420 M
-232 32 V
1.000 UL
LT0
1456 1259 M
234 161 V
1.000 UL
LT0
1920 1408 M
-230 12 V
1.000 UL
LT0
1687 1214 M
233 194 V
1.000 UL
LT0
2151 1394 M
-231 14 V
1.000 UL
LT0
991 1164 M
234 141 V
1.000 UL
LT0
1456 1259 M
-231 46 V
1.000 UL
LT0
1222 1119 M
234 140 V
1.000 UL
LT0
1687 1214 M
-231 45 V
1.000 UL
LT0
1918 1183 M
233 211 V
1.000 UL
LT0
2383 1741 M
2151 1394 L
1.000 UL
LT0
1453 1072 M
234 142 V
1.000 UL
LT0
1918 1183 M
-231 31 V
1.000 UL
LT0
2383 1741 M
231 -515 V
1.000 UL
LT0
2380 1231 M
234 -5 V
1.000 UL
LT0
2845 1166 M
-231 60 V
1.000 UL
LT0
2612 1028 M
233 138 V
1.000 UL
LT0
3077 1120 M
-232 46 V
1.000 UL
LT0
757 1024 M
234 140 V
1.000 UL
LT0
1222 1119 M
-231 45 V
1.000 UL
LT0
1685 1028 M
233 155 V
1.000 UL
LT0
2149 1247 M
-231 -64 V
1.000 UL
LT0
2843 981 M
234 139 V
1.000 UL
LT0
988 978 M
234 141 V
1.000 UL
LT0
1453 1072 M
-231 47 V
1.000 UL
LT0
1220 932 M
233 140 V
1.000 UL
LT0
1685 1028 M
-232 44 V
1.000 UL
LT0
2383 1741 M
2149 1247 L
1.000 UL
LT0
1915 981 M
234 266 V
1.000 UL
LT0
2380 1231 M
-231 16 V
1.000 UL
LT0
2380 1231 M
232 -203 V
1.000 UL
LT0
2378 893 M
234 135 V
1.000 UL
LT0
2843 981 M
-231 47 V
1.000 UL
LT0
523 884 M
234 140 V
1.000 UL
LT0
988 978 M
-231 46 V
1.000 UL
LT0
1451 886 M
234 142 V
1.000 UL
LT0
1915 981 M
-230 47 V
1.000 UL
LT0
2609 841 M
234 140 V
1.000 UL
LT0
755 838 M
988 978 L
1.000 UL
LT0
1220 932 M
988 978 L
1.000 UL
LT0
1682 840 M
233 141 V
1.000 UL
LT0
2147 955 M
-232 26 V
1.000 UL
LT0
2147 955 M
233 276 V
1.000 UL
LT0
986 792 M
234 140 V
1.000 UL
LT0
1451 886 M
-231 46 V
1.000 UL
LT0
1913 797 M
234 158 V
1.000 UL
LT0
2378 893 M
-231 62 V
1.000 UL
LT0
1217 746 M
234 140 V
1.000 UL
LT0
1682 840 M
-231 46 V
1.000 UL
LT0
755 838 M
523 884 L
1.000 UL
LT0
2144 748 M
234 145 V
1.000 UL
LT0
2609 841 M
-231 52 V
1.000 UL
LT0
2375 702 M
234 139 V
1.000 UL
LT0
1449 700 M
233 140 V
1.000 UL
LT0
1913 797 M
-231 43 V
1.000 UL
LT0
986 792 M
755 838 L
1.000 UL
LT0
1217 746 M
986 792 L
1.000 UL
LT0
1680 654 M
233 143 V
1.000 UL
LT0
2144 748 M
-231 49 V
1.000 UL
LT0
1910 608 M
234 140 V
1.000 UL
LT0
2375 702 M
-231 46 V
1.000 UL
LT0
1449 700 M
-232 46 V
1.000 UL
LT0
2142 562 M
233 140 V
1.000 UL
LT0
1680 654 M
-231 46 V
1.000 UL
LT0
1910 608 M
-230 46 V
1.000 UL
LT0
2142 562 M
-232 46 V
1.000 UL
LT0
LTb
1.000 UL
LT0
3124 1996 M
263 0 V
1.000 UL
LTb
2142 305 M
935 559 V
1.000 UL
LTb
2142 305 M
523 628 L
1.000 UL
LTb
523 628 M
845 820 L
1.000 UL
LTb
3077 864 M
-322 64 V
1.000 UL
LTb
523 1396 M
0 -768 V
1.000 UL
LTa
523 628 M
845 820 L
1.000 UL
LTb
523 628 M
59 35 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTa
755 582 M
321 192 V
1.000 UL
LTb
755 582 M
58 35 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTa
986 536 M
322 192 V
1.000 UL
LTb
986 536 M
59 35 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTa
1217 490 M
322 192 V
1.000 UL
LTb
1217 490 M
59 35 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTa
1449 443 M
322 193 V
1.000 UL
LTb
1449 443 M
58 36 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTa
1680 397 M
321 193 V
1.000 UL
LTb
1680 397 M
59 35 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTa
1910 351 M
935 559 V
1.000 UL
LTb
1910 351 M
59 35 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTb
2787 875 M
58 35 V
1.000 UL
LTa
2142 305 M
935 559 V
1.000 UL
LTb
2142 305 M
58 35 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTb
3018 829 M
59 35 V
LTb
1.000 UL
LTa
2142 305 M
523 628 L
1.000 UL
LTb
2142 305 M
-55 11 V
1.000 UL
LTb
1.000 UL
LTb
578 617 M
-55 11 V
1.000 UL
LTa
2375 445 M
757 768 L
1.000 UL
LTb
2375 445 M
-54 11 V
1.000 UL
LTb
1.000 UL
LTb
812 757 M
-55 11 V
1.000 UL
LTa
2609 585 M
-322 64 V
1.000 UL
LTb
2609 585 M
-54 10 V
1.000 UL
LTb
1.000 UL
LTa
2843 724 M
-322 64 V
1.000 UL
LTb
2843 724 M
-55 11 V
1.000 UL
LTb
1.000 UL
LTa
3053 850 M
-321 64 V
1.000 UL
LTb
3053 850 M
-54 11 V
1.000 UL
LTb
LTb
1.000 UL
LTb
586 884 M
-63 0 V
1.000 UL
LTb
1.000 UL
LTb
586 970 M
-63 0 V
1.000 UL
LTb
1.000 UL
LTb
586 1055 M
-63 0 V
1.000 UL
LTb
1.000 UL
LTb
586 1140 M
-63 0 V
1.000 UL
LTb
1.000 UL
LTb
586 1225 M
-63 0 V
1.000 UL
LTb
1.000 UL
LTb
586 1310 M
-63 0 V
1.000 UL
LTb
1.000 UL
LTb
586 1396 M
-63 0 V
1.000 UL
LTb
LTb
1.000 UP
stroke
grestore
end
showpage
}}\put(522,1588){\cjust{Median Time (s)}}\put(397,1396){\rjust{ 12}}\put(397,1225){\rjust{ 8}}\put(397,1055){\rjust{ 4}}\put(397,884){\rjust{ 0}}\put(2960,490){\special{ps: gsave currentpoint currentpoint translate
-34.5 rotate neg exch neg exch translate}\cstack{\cjust{f - accepting density}}\special{ps: currentpoint grestore moveto}}\put(3157,823){\cjust{0.1}}\put(2946,697){\cjust{0.3}}\put(2713,557){\cjust{0.5}}\put(2479,418){\cjust{0.7}}\put(2245,278){\cjust{0.9}}\put(1099,280){\special{ps: gsave currentpoint currentpoint translate
10.5 rotate neg exch neg exch translate}\cstack{\cjust{r - transition density}}\special{ps: currentpoint grestore moveto}}\put(1864,296){\rjust{1.4}}\put(1402,388){\rjust{1.8}}\put(939,480){\rjust{2.2}}\put(477,572){\rjust{2.6}}\put(3074,1996){\rjust{Median execution time}}\endGNUPLOTpicture
\endgroup
%
 }
    \caption{\protect\parbox[t]{45mm}{Median time to check universality of $100$ automata of size $30$ for each sample point.}}
    \label{fig:median-time}
 \end{minipage} \hfill 
 \begin{minipage}[b]{.47\linewidth}
    \scalebox{0.5}{\begingroup
  \catcode`\@=11\relax
  \def\GNUPLOTspecial{\def\do##1{\catcode`##1=12\relax}\dospecials
    \catcode`\{=1\catcode`\}=2\catcode\%=14\relax\special}\expandafter\ifx\csname GNUPLOTpicture\endcsname\relax
  \csname newdimen\endcsname\GNUPLOTunit
  \gdef\GNUPLOTpicture(#1,#2){\vbox to#2\GNUPLOTunit\bgroup
    \def\put(##1,##2)##3{\unskip\raise##2\GNUPLOTunit
      \hbox to0pt{\kern##1\GNUPLOTunit ##3\hss}\ignorespaces}\def\ljust##1{\vbox to0pt{\vss\hbox to0pt{##1\hss}\vss}}\def\cjust##1{\vbox to0pt{\vss\hbox to0pt{\hss ##1\hss}\vss}}\def\rjust##1{\vbox to0pt{\vss\hbox to0pt{\hss ##1}\vss}}\def\stack##1{\let\\=\cr\tabskip=0pt\halign{\hfil ####\hfil\cr ##1\crcr}}\def\lstack##1{\hbox to0pt{\vbox to0pt{\vss\stack{##1}}\hss}}\def\cstack##1{\hbox to0pt{\hss\vbox to0pt{\vss\stack{##1}}\hss}}\def\rstack##1{\hbox to0pt{\vbox to0pt{\stack{##1}\vss}\hss}}\vss\hbox to#1\GNUPLOTunit\bgroup\ignorespaces}\gdef\endGNUPLOTpicture{\hss\egroup\egroup}\fi
\GNUPLOTunit=0.1bp
\GNUPLOTpicture(3600,2160)
{\GNUPLOTspecial{"
/gnudict 256 dict def
gnudict begin
/Color false def
/Solid false def
/gnulinewidth 5.000 def
/userlinewidth gnulinewidth def
/vshift -33 def
/dl {10.0 mul} def
/hpt_ 31.5 def
/vpt_ 31.5 def
/hpt hpt_ def
/vpt vpt_ def
/Rounded false def
/M {moveto} bind def
/L {lineto} bind def
/R {rmoveto} bind def
/V {rlineto} bind def
/N {newpath moveto} bind def
/C {setrgbcolor} bind def
/f {rlineto fill} bind def
/vpt2 vpt 2 mul def
/hpt2 hpt 2 mul def
/Lshow { currentpoint stroke M
  0 vshift R show } def
/Rshow { currentpoint stroke M
  dup stringwidth pop neg vshift R show } def
/Cshow { currentpoint stroke M
  dup stringwidth pop -2 div vshift R show } def
/UP { dup vpt_ mul /vpt exch def hpt_ mul /hpt exch def
  /hpt2 hpt 2 mul def /vpt2 vpt 2 mul def } def
/DL { Color {setrgbcolor Solid {pop []} if 0 setdash }
 {pop pop pop 0 setgray Solid {pop []} if 0 setdash} ifelse } def
/BL { stroke userlinewidth 2 mul setlinewidth
      Rounded { 1 setlinejoin 1 setlinecap } if } def
/AL { stroke userlinewidth 2 div setlinewidth
      Rounded { 1 setlinejoin 1 setlinecap } if } def
/UL { dup gnulinewidth mul /userlinewidth exch def
      dup 1 lt {pop 1} if 10 mul /udl exch def } def
/PL { stroke userlinewidth setlinewidth
      Rounded { 1 setlinejoin 1 setlinecap } if } def
/LTw { PL [] 1 setgray } def
/LTb { BL [] 0 0 0 DL } def
/LTa { AL [1 udl mul 2 udl mul] 0 setdash 0 0 0 setrgbcolor } def
/LT0 { PL [] 1 0 0 DL } def
/LT1 { PL [4 dl 2 dl] 0 1 0 DL } def
/LT2 { PL [2 dl 3 dl] 0 0 1 DL } def
/LT3 { PL [1 dl 1.5 dl] 1 0 1 DL } def
/LT4 { PL [5 dl 2 dl 1 dl 2 dl] 0 1 1 DL } def
/LT5 { PL [4 dl 3 dl 1 dl 3 dl] 1 1 0 DL } def
/LT6 { PL [2 dl 2 dl 2 dl 4 dl] 0 0 0 DL } def
/LT7 { PL [2 dl 2 dl 2 dl 2 dl 2 dl 4 dl] 1 0.3 0 DL } def
/LT8 { PL [2 dl 2 dl 2 dl 2 dl 2 dl 2 dl 2 dl 4 dl] 0.5 0.5 0.5 DL } def
/Pnt { stroke [] 0 setdash
   gsave 1 setlinecap M 0 0 V stroke grestore } def
/Dia { stroke [] 0 setdash 2 copy vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath stroke
  Pnt } def
/Pls { stroke [] 0 setdash vpt sub M 0 vpt2 V
  currentpoint stroke M
  hpt neg vpt neg R hpt2 0 V stroke
  } def
/Box { stroke [] 0 setdash 2 copy exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V closepath stroke
  Pnt } def
/Crs { stroke [] 0 setdash exch hpt sub exch vpt add M
  hpt2 vpt2 neg V currentpoint stroke M
  hpt2 neg 0 R hpt2 vpt2 V stroke } def
/TriU { stroke [] 0 setdash 2 copy vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath stroke
  Pnt  } def
/Star { 2 copy Pls Crs } def
/BoxF { stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V  hpt2 0 V  0 vpt2 V
  hpt2 neg 0 V  closepath fill } def
/TriUF { stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath fill } def
/TriD { stroke [] 0 setdash 2 copy vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath stroke
  Pnt  } def
/TriDF { stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath fill} def
/DiaF { stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath fill } def
/Pent { stroke [] 0 setdash 2 copy gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath stroke grestore Pnt } def
/PentF { stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath fill grestore } def
/Circle { stroke [] 0 setdash 2 copy
  hpt 0 360 arc stroke Pnt } def
/CircleF { stroke [] 0 setdash hpt 0 360 arc fill } def
/C0 { BL [] 0 setdash 2 copy moveto vpt 90 450  arc } bind def
/C1 { BL [] 0 setdash 2 copy        moveto
       2 copy  vpt 0 90 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C2 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 90 180 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C3 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 0 180 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C4 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 180 270 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C5 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 0 90 arc
       2 copy moveto
       2 copy  vpt 180 270 arc closepath fill
               vpt 0 360 arc } bind def
/C6 { BL [] 0 setdash 2 copy moveto
      2 copy  vpt 90 270 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C7 { BL [] 0 setdash 2 copy moveto
      2 copy  vpt 0 270 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C8 { BL [] 0 setdash 2 copy moveto
      2 copy vpt 270 360 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C9 { BL [] 0 setdash 2 copy moveto
      2 copy  vpt 270 450 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C10 { BL [] 0 setdash 2 copy 2 copy moveto vpt 270 360 arc closepath fill
       2 copy moveto
       2 copy vpt 90 180 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C11 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 0 180 arc closepath fill
       2 copy moveto
       2 copy  vpt 270 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C12 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 180 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C13 { BL [] 0 setdash  2 copy moveto
       2 copy  vpt 0 90 arc closepath fill
       2 copy moveto
       2 copy  vpt 180 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C14 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 90 360 arc closepath fill
               vpt 0 360 arc } bind def
/C15 { BL [] 0 setdash 2 copy vpt 0 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/Rec   { newpath 4 2 roll moveto 1 index 0 rlineto 0 exch rlineto
       neg 0 rlineto closepath } bind def
/Square { dup Rec } bind def
/Bsquare { vpt sub exch vpt sub exch vpt2 Square } bind def
/S0 { BL [] 0 setdash 2 copy moveto 0 vpt rlineto BL Bsquare } bind def
/S1 { BL [] 0 setdash 2 copy vpt Square fill Bsquare } bind def
/S2 { BL [] 0 setdash 2 copy exch vpt sub exch vpt Square fill Bsquare } bind def
/S3 { BL [] 0 setdash 2 copy exch vpt sub exch vpt2 vpt Rec fill Bsquare } bind def
/S4 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt Square fill Bsquare } bind def
/S5 { BL [] 0 setdash 2 copy 2 copy vpt Square fill
       exch vpt sub exch vpt sub vpt Square fill Bsquare } bind def
/S6 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill Bsquare } bind def
/S7 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill
       2 copy vpt Square fill
       Bsquare } bind def
/S8 { BL [] 0 setdash 2 copy vpt sub vpt Square fill Bsquare } bind def
/S9 { BL [] 0 setdash 2 copy vpt sub vpt vpt2 Rec fill Bsquare } bind def
/S10 { BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt Square fill
       Bsquare } bind def
/S11 { BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt2 vpt Rec fill
       Bsquare } bind def
/S12 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill Bsquare } bind def
/S13 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill
       2 copy vpt Square fill Bsquare } bind def
/S14 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill
       2 copy exch vpt sub exch vpt Square fill Bsquare } bind def
/S15 { BL [] 0 setdash 2 copy Bsquare fill Bsquare } bind def
/D0 { gsave translate 45 rotate 0 0 S0 stroke grestore } bind def
/D1 { gsave translate 45 rotate 0 0 S1 stroke grestore } bind def
/D2 { gsave translate 45 rotate 0 0 S2 stroke grestore } bind def
/D3 { gsave translate 45 rotate 0 0 S3 stroke grestore } bind def
/D4 { gsave translate 45 rotate 0 0 S4 stroke grestore } bind def
/D5 { gsave translate 45 rotate 0 0 S5 stroke grestore } bind def
/D6 { gsave translate 45 rotate 0 0 S6 stroke grestore } bind def
/D7 { gsave translate 45 rotate 0 0 S7 stroke grestore } bind def
/D8 { gsave translate 45 rotate 0 0 S8 stroke grestore } bind def
/D9 { gsave translate 45 rotate 0 0 S9 stroke grestore } bind def
/D10 { gsave translate 45 rotate 0 0 S10 stroke grestore } bind def
/D11 { gsave translate 45 rotate 0 0 S11 stroke grestore } bind def
/D12 { gsave translate 45 rotate 0 0 S12 stroke grestore } bind def
/D13 { gsave translate 45 rotate 0 0 S13 stroke grestore } bind def
/D14 { gsave translate 45 rotate 0 0 S14 stroke grestore } bind def
/D15 { gsave translate 45 rotate 0 0 S15 stroke grestore } bind def
/DiaE { stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath stroke } def
/BoxE { stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V closepath stroke } def
/TriUE { stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath stroke } def
/TriDE { stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath stroke } def
/PentE { stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath stroke grestore } def
/CircE { stroke [] 0 setdash 
  hpt 0 360 arc stroke } def
/Opaque { gsave closepath 1 setgray fill grestore 0 setgray closepath } def
/DiaW { stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V Opaque stroke } def
/BoxW { stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V Opaque stroke } def
/TriUW { stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V Opaque stroke } def
/TriDW { stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V Opaque stroke } def
/PentW { stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  Opaque stroke grestore } def
/CircW { stroke [] 0 setdash 
  hpt 0 360 arc Opaque stroke } def
/BoxFill { gsave Rec 1 setgray fill grestore } def
/BoxColFill {
  gsave Rec
  /Fillden exch def
  currentrgbcolor
  /ColB exch def /ColG exch def /ColR exch def
  /ColR ColR Fillden mul Fillden sub 1 add def
  /ColG ColG Fillden mul Fillden sub 1 add def
  /ColB ColB Fillden mul Fillden sub 1 add def
  ColR ColG ColB setrgbcolor
  fill grestore } def
/PatternFill { gsave /PFa [ 9 2 roll ] def
    PFa 0 get PFa 2 get 2 div add PFa 1 get PFa 3 get 2 div add translate
    PFa 2 get -2 div PFa 3 get -2 div PFa 2 get PFa 3 get Rec
    gsave 1 setgray fill grestore clip
    currentlinewidth 0.5 mul setlinewidth
    /PFs PFa 2 get dup mul PFa 3 get dup mul add sqrt def
    0 0 M PFa 5 get rotate PFs -2 div dup translate
	0 1 PFs PFa 4 get div 1 add floor cvi
	{ PFa 4 get mul 0 M 0 PFs V } for
    0 PFa 6 get ne {
	0 1 PFs PFa 4 get div 1 add floor cvi
	{ PFa 4 get mul 0 2 1 roll M PFs 0 V } for
    } if
    stroke grestore } def
/Symbol-Oblique /Symbol findfont [1 0 .167 1 0 0] makefont
dup length dict begin {1 index /FID eq {pop pop} {def} ifelse} forall
currentdict end definefont pop
end
gnudict begin
gsave
0 0 translate
0.100 0.100 scale
0 setgray
newpath
1.000 UL
LTb
gsave /maxcolors 0 def
/HSV2RGB {  exch dup 0.0 eq {pop exch pop dup dup} { /HSVs exch def /HSVv exch def 6.0 mul dup floor dup 3 1 roll sub
     /HSVf exch def /HSVi exch cvi def /HSVp HSVv 1.0 HSVs sub mul def
	 /HSVq HSVv 1.0 HSVs HSVf mul sub mul def 
	 /HSVt HSVv 1.0 HSVs 1.0 HSVf sub mul sub mul def
	 /HSVi HSVi 6 mod def 0 HSVi eq {HSVv HSVt HSVp}
	 {1 HSVi eq {HSVq HSVv HSVp}{2 HSVi eq {HSVp HSVv HSVt}
	 {3 HSVi eq {HSVp HSVq HSVv}{4 HSVi eq {HSVt HSVp HSVv}
	 {HSVv HSVp HSVq} ifelse} ifelse} ifelse} ifelse} ifelse
  } ifelse} def
/Constrain {
  dup 0 lt {0 exch pop}{dup 1 gt {1 exch pop} if} ifelse} def
/YIQ2RGB {
  3 copy -1.702 mul exch -1.105 mul add add Constrain 4 1 roll
  3 copy -0.647 mul exch -0.272 mul add add Constrain 5 1 roll
  0.621 mul exch -0.956 mul add add Constrain 3 1 roll } def
/CMY2RGB {  1 exch sub exch 1 exch sub 3 2 roll 1 exch sub 3 1 roll exch } def
/XYZ2RGB {  3 copy -0.9017 mul exch -0.1187 mul add exch 0.0585 mul exch add
  Constrain 4 1 roll 3 copy -0.0279 mul exch 1.999 mul add exch
  -0.9844 mul add Constrain 5 1 roll -0.2891 mul exch -0.5338 mul add
  exch 1.91 mul exch add Constrain 3 1 roll} def
/SelectSpace {ColorSpace (HSV) eq {HSV2RGB}{ColorSpace (XYZ) eq {
  XYZ2RGB}{ColorSpace (CMY) eq {CMY2RGB}{ColorSpace (YIQ) eq {YIQ2RGB}
  if} ifelse} ifelse} ifelse} def
/maxcolorsLast {maxcolors 1 sub maxcolors div} def
/pm3dround {maxcolors 0 gt {dup maxcolorsLast ge {pop 1}
{maxcolors mul floor maxcolors div} ifelse} if} def
/pm3dGamma 1.0 1.5 div def
/ColorSpace (RGB) def
Color false and { InterpolatedColor { /g {stroke pm3dround /grayv exch def interpolate
        SelectSpace setrgbcolor} bind def
  }{
  /g {stroke pm3dround dup cF7 Constrain exch dup cF5 Constrain exch cF15 Constrain 
       SelectSpace setrgbcolor} bind def
  } ifelse
}{
  /g {stroke pm3dround pm3dGamma exp setgray} bind def
} ifelse
/h {rlineto rlineto rlineto fill} bind def
stroke gsave	maxcolors 0 gt {/imax maxcolors def} {/imax 1024 def} ifelse
3125 982 translate 129 646 scale 0 setlinewidth
/ystep 1 imax div def /y0 0 def /ii 0 def
{ y0 g 0 y0 N 1 0 V 0 ystep V -1 0 f
/y0 y0 ystep add def /ii ii 1 add def
ii imax ge {exit} if } loop
grestore 0 setgray
1.000 UL
LTb
3125 982 M
129 0 V
0 646 V
-129 0 V
0 -646 V
1.000 UL
LTb
1.000 UL
LTb
3254 982 M
-63 0 V
1.000 UL
LTb
3125 982 M
63 0 V
66 71 R
-63 0 V
1.000 UL
LTb
3125 1053 M
63 0 V
66 72 R
-63 0 V
1.000 UL
LTb
3125 1125 M
63 0 V
66 72 R
-63 0 V
1.000 UL
LTb
3125 1197 M
63 0 V
66 72 R
-63 0 V
1.000 UL
LTb
3125 1269 M
63 0 V
66 71 R
-63 0 V
1.000 UL
LTb
3125 1340 M
63 0 V
66 72 R
-63 0 V
1.000 UL
LTb
3125 1412 M
63 0 V
66 72 R
-63 0 V
1.000 UL
LTb
3125 1484 M
63 0 V
66 72 R
-63 0 V
1.000 UL
LTb
3125 1556 M
63 0 V
66 71 R
-63 0 V
1.000 UL
LTb
3125 1627 M
63 0 V
1.000 UP
2.000 UL
LT0
2267 1259 M
116 -108 V
2.000 UL
LT0
2149 1012 M
234 139 V
2.000 UL
LT0
2498 1107 M
-115 44 V
2.000 UL
LT0
2265 989 M
233 118 V
2.000 UL
LT0
2614 1084 M
-116 23 V
2.000 UL
LT0
2036 1498 M
115 -194 V
2.000 UL
LT0
1918 1164 M
233 140 V
2.000 UL
LT0
2267 1259 M
-116 45 V
2.000 UL
LT0
2380 945 M
234 139 V
2.000 UL
LT0
2730 1061 M
-116 23 V
2.000 UL
LT0
2033 1162 M
234 97 V
2.000 UL
LT0
2496 922 M
234 139 V
2.000 UL
LT0
2845 1038 M
-115 23 V
2.000 UL
LT0
2612 899 M
233 139 V
2.000 UL
LT0
2961 1015 M
-116 23 V
2.000 UL
LT0
2727 876 M
234 139 V
2.000 UL
LT0
3077 992 M
-116 23 V
2.000 UL
LT0
1804 1758 M
116 -237 V
2.000 UL
LT0
1687 1424 M
233 97 V
2.000 UL
LT0
2036 1498 M
-116 23 V
2.000 UL
LT0
2843 853 M
234 139 V
2.000 UL
LT0
1802 1315 M
234 183 V
2.000 UL
LT0
2033 1162 M
116 -150 V
2.000 UL
LT0
1915 872 M
234 140 V
2.000 UL
LT0
2265 989 M
-116 23 V
2.000 UL
LT0
2031 828 M
234 161 V
2.000 UL
LT0
2380 945 M
-115 44 V
2.000 UL
LT0
1802 1315 M
116 -151 V
2.000 UL
LT0
1685 1068 M
233 96 V
2.000 UL
LT0
2033 1162 M
-115 2 V
2.000 UL
LT0
2147 805 M
233 140 V
2.000 UL
LT0
2496 922 M
-116 23 V
2.000 UL
LT0
1225 1708 M
233 140 V
2.000 UL
LT0
1574 1804 M
-116 44 V
2.000 UL
LT0
1574 1804 M
116 -66 V
2.000 UL
LT0
1456 1619 M
234 119 V
2.000 UL
LT0
1804 1758 M
-114 -20 V
2.000 UL
LT0
1340 1664 M
234 140 V
2.000 UL
LT0
2262 782 M
234 140 V
2.000 UL
LT0
2612 899 M
-116 23 V
2.000 UL
LT0
1800 1002 M
233 160 V
2.000 UL
LT0
2378 759 M
234 140 V
2.000 UL
LT0
2727 876 M
-115 23 V
2.000 UL
LT0
1572 1468 M
232 290 V
2.000 UL
LT0
1687 1424 M
115 -109 V
2.000 UL
LT0
1569 1261 M
233 54 V
2.000 UL
LT0
2494 736 M
233 140 V
2.000 UL
LT0
2843 853 M
-116 23 V
2.000 UL
LT0
2609 713 M
234 140 V
2.000 UL
LT0
1456 1619 M
116 -151 V
2.000 UL
LT0
1338 1371 M
234 97 V
2.000 UL
LT0
1687 1424 M
-115 44 V
2.000 UL
LT0
1453 1241 M
234 183 V
2.000 UL
LT0
1800 1002 M
1915 872 L
2.000 UL
LT0
1682 754 M
233 118 V
2.000 UL
LT0
2031 828 M
-116 44 V
2.000 UL
LT0
1798 688 M
233 140 V
2.000 UL
LT0
2147 805 M
-116 23 V
2.000 UL
LT0
1913 665 M
234 140 V
2.000 UL
LT0
2262 782 M
-115 23 V
2.000 UL
LT0
991 1526 M
234 182 V
2.000 UL
LT0
1340 1664 M
-115 44 V
2.000 UL
LT0
1106 1567 M
234 97 V
2.000 UL
LT0
1456 1619 M
-116 45 V
2.000 UL
LT0
1685 1068 M
115 -66 V
2.000 UL
LT0
1567 756 M
233 246 V
2.000 UL
LT0
1222 1458 M
234 161 V
2.000 UL
LT0
2028 642 M
234 140 V
2.000 UL
LT0
2378 759 M
-116 23 V
2.000 UL
LT0
1569 1261 M
116 -193 V
2.000 UL
LT0
1451 971 M
234 97 V
2.000 UL
LT0
2144 619 M
234 140 V
2.000 UL
LT0
2494 736 M
-116 23 V
2.000 UL
LT0
2260 596 M
234 140 V
2.000 UL
LT0
2609 713 M
-115 23 V
2.000 UL
LT0
1338 1371 M
115 -130 V
2.000 UL
LT0
1220 1273 M
233 -32 V
2.000 UL
LT0
1569 1261 M
-116 -20 V
2.000 UL
LT0
1451 971 M
1567 756 L
2.000 UL
LT0
1333 702 M
234 54 V
2.000 UL
LT0
1682 754 M
-115 2 V
2.000 UL
LT0
2375 573 M
234 140 V
2.000 UL
LT0
757 1386 M
234 140 V
2.000 UL
LT0
1106 1567 M
991 1526 L
2.000 UL
LT0
1682 754 M
116 -66 V
2.000 UL
LT0
1564 549 M
234 139 V
2.000 UL
LT0
1913 665 M
-115 23 V
2.000 UL
LT0
1449 593 M
233 161 V
2.000 UL
LT0
1222 1458 M
116 -87 V
2.000 UL
LT0
1104 1253 M
234 118 V
2.000 UL
LT0
1335 1058 M
234 203 V
2.000 UL
LT0
1680 526 M
233 139 V
2.000 UL
LT0
2028 642 M
-115 23 V
2.000 UL
LT0
1106 1567 M
116 -109 V
2.000 UL
LT0
988 1276 M
234 182 V
2.000 UL
LT0
1796 502 M
232 140 V
2.000 UL
LT0
2144 619 M
-116 23 V
2.000 UL
LT0
873 1406 M
233 161 V
2.000 UL
LT0
1910 479 M
234 140 V
2.000 UL
LT0
2260 596 M
-116 23 V
2.000 UL
LT0
1335 1058 M
116 -87 V
2.000 UL
LT0
1217 853 M
234 118 V
2.000 UL
LT0
2026 478 M
234 118 V
2.000 UL
LT0
2375 573 M
-115 23 V
2.000 UL
LT0
1220 1273 M
115 -215 V
2.000 UL
LT0
1102 919 M
233 139 V
2.000 UL
LT0
2142 433 M
233 140 V
2.000 UL
LT0
1333 702 M
1449 593 L
2.000 UL
LT0
1564 549 M
-115 44 V
2.000 UL
LT0
523 1268 M
234 118 V
2.000 UL
LT0
873 1406 M
757 1386 L
2.000 UL
LT0
873 1406 M
988 1276 L
2.000 UL
LT0
755 1158 M
233 118 V
2.000 UL
LT0
1104 1253 M
-116 23 V
2.000 UL
LT0
1680 526 M
-116 23 V
2.000 UL
LT0
870 1156 M
234 97 V
2.000 UL
LT0
1220 1273 M
-116 -20 V
2.000 UL
LT0
1796 502 M
-116 24 V
2.000 UL
LT0
1217 853 M
1333 702 L
2.000 UL
LT0
1910 479 M
-114 23 V
2.000 UL
LT0
639 1287 M
234 119 V
2.000 UL
LT0
2026 478 M
-116 1 V
2.000 UL
LT0
986 984 M
234 289 V
2.000 UL
LT0
1102 919 M
115 -66 V
2.000 UL
LT0
986 984 M
116 -65 V
2.000 UL
LT0
2142 433 M
-116 45 V
2.000 UL
LT0
870 1156 M
986 984 L
2.000 UL
LT0
639 1287 M
523 1268 L
2.000 UL
LT0
639 1287 M
755 1158 L
2.000 UL
LT0
870 1156 M
-115 2 V
.9074 g 1457 1848 N -115 44 -234 -140 116 -44 h
.9074 g 1224 1708 N -115 -41 -234 -97 115 -44 h
.8981 g 990 1526 N -116 -20 -233 -161 115 41 h
.9074 g 756 1386 N -116 -19 -234 -119 116 20 h
.8611 g 1573 1804 N -116 45 -234 -119 116 -66 h
.8796 g 1339 1664 N -116 109 -234 -161 116 -45 h
.8611 g 1105 1567 N -115 130 -234 -182 116 -109 h
.8519 g 872 1406 N -116 129 -233 -118 115 -130 h
.7963 g 1689 1738 N -116 151 -233 -290 115 20 h
.75 g 1455 1619 N -116 87 -234 -97 116 -151 h
.75 g 1221 1458 N -116 23 -234 -118 116 -87 h
.7685 g 987 1276 N -115 2 -234 -97 116 -23 h
.6574 g 1804 1758 N -115 44 -234 -97 116 -237 h
.6111 g 1571 1468 N -115 130 -234 -183 115 -44 h
.6944 g 1337 1371 N -116 -20 -233 32 115 -130 h
.7315 g 1103 1253 N -116 173 -234 -290 116 20 h
.5185 g 1920 1521 N -116 109 -234 -183 116 -23 h
.537 g 1686 1424 N -116 -20 -234 -54 116 -109 h
.6019 g 1452 1241 N -115 216 -234 -204 116 20 h
.5833 g 1219 1273 N -116 65 -233 -139 115 -216 h
.3519 g 2036 1498 N -116 151 -233 -140 115 -194 h
.3889 g 1802 1315 N -116 194 -234 -97 116 -151 h
.4352 g 1568 1261 N -116 87 -234 -97 116 -194 h
.4352 g 1334 1057 N -115 66 -234 -118 116 -87 h
.2222 g 2151 1304 N -115 2 -234 -97 116 -45 h
.25 g 1918 1164 N -115 66 -234 -161 115 -2 h
.2315 g 1684 1067 N -116 215 -233 -246 115 -66 h
.25 g 1450 970 N -116 151 -234 -54 116 -215 h
.1296 g 2267 1259 N -116 151 -234 -140 116 -108 h
.1389 g 2033 1162 N -116 130 -234 -140 116 -151 h
.0926 g 1799 1001 N -115 2 -234 -118 116 -130 h
.0833 g 1566 755 N -116 109 -233 -161 115 -2 h
.0278 g 2383 1151 N -116 23 -233 -118 115 -45 h
.0278 g 2149 1011 N -116 44 -234 -161 116 -23 h
.0278 g 1915 871 N -116 66 -234 -140 116 -44 h
.0278 g 1681 753 N -115 44 -234 -139 116 -66 h
.0093 g 2498 1106 N -115 44 -234 -139 116 -23 h
.0093 g 2265 988 N -116 23 -233 -140 115 -44 h
0 g 2031 827 N -116 23 -234 -140 116 -23 h
0 g 1797 687 N -116 23 -234 -139 116 -23 h
0 g 2614 1083 N -116 23 -234 -139 116 -23 h
0 g 2380 944 N -115 23 -234 -140 116 -23 h
0 g 2147 804 N -115 23 -234 -140 115 -23 h
0 g 1913 664 N -116 24 -233 -140 115 -23 h
0 g 2730 1060 N -116 23 -233 -139 115 -23 h
0 g 2496 921 N -116 23 -234 -140 116 -23 h
0 g 2262 781 N -116 23 -234 -140 116 -23 h
0 g 2028 641 N -115 23 -234 -140 116 -23 h
0 g 2845 1037 N -115 23 -234 -139 116 -23 h
0 g 2612 898 N -116 23 -233 -140 115 -23 h
0 g 2378 758 N -116 23 -234 -140 116 -23 h
.0093 g 2144 618 N -116 1 -234 -118 116 -23 h
0 g 2961 1014 N -116 23 -234 -139 116 -23 h
0 g 2727 875 N -115 23 -234 -140 116 -23 h
0 g 2494 735 N -115 23 -234 -140 115 -23 h
.0093 g 2260 595 N -116 45 -233 -140 115 -23 h
2.000 UL
LT0
1.000 UL
LTb
2142 305 M
935 559 V
1.000 UL
LTb
2142 305 M
523 628 L
1.000 UL
LTb
523 628 M
531 317 V
1.000 UL
LTb
3077 864 M
-161 32 V
1.000 UL
LTb
523 1396 M
0 -768 V
1.000 UL
LTb
3077 992 M
0 -128 V
1.000 UL
LTb
2142 433 M
0 -128 V
1.000 UL
LTa
1968 340 M
163 97 V
1.000 UL
LTb
1968 340 M
59 35 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTa
1680 397 M
160 96 V
1.000 UL
LTb
1680 397 M
59 35 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTa
1391 455 M
163 98 V
1.000 UL
LTb
1391 455 M
59 35 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTa
1102 513 M
264 158 V
1.000 UL
LTb
1102 513 M
58 35 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTa
812 570 M
427 255 V
1.000 UL
LTb
812 570 M
59 35 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTa
523 628 M
531 317 V
1.000 UL
LTb
523 628 M
59 35 V
1.000 UL
LTb
1.000 UL
LTb
LTb
1.000 UL
LTa
2142 305 M
523 628 L
1.000 UL
LTb
2142 305 M
-55 11 V
1.000 UL
LTb
1.000 UL
LTb
578 617 M
-55 11 V
1.000 UL
LTa
1399 640 M
757 768 L
1.000 UL
LTa
2375 445 M
-160 32 V
1.000 UL
LTb
2375 445 M
-54 11 V
1.000 UL
LTb
1.000 UL
LTb
812 757 M
-55 11 V
1.000 UL
LTa
1192 867 M
991 907 L
1.000 UL
LTa
2609 585 M
-161 32 V
1.000 UL
LTb
2609 585 M
-54 10 V
1.000 UL
LTb
1.000 UL
LTb
1045 896 M
-54 11 V
1.000 UL
LTa
2843 724 M
-161 32 V
1.000 UL
LTb
2843 724 M
-55 11 V
1.000 UL
LTb
1.000 UL
LTa
3077 864 M
-161 32 V
1.000 UL
LTb
3077 864 M
-55 11 V
1.000 UL
LTb
LTb
1.000 UL
LTb
586 1396 M
-63 0 V
1.000 UL
LTb
1.000 UL
LTb
586 1268 M
-63 0 V
1.000 UL
LTb
1.000 UL
LTb
586 1140 M
-63 0 V
1.000 UL
LTb
1.000 UL
LTb
586 1012 M
-63 0 V
1.000 UL
LTb
1.000 UL
LTb
586 884 M
-63 0 V
1.000 UL
LTb
1.000 UL
LTb
586 756 M
-63 0 V
1.000 UL
LTb
1.000 UL
LTb
586 628 M
-63 0 V
1.000 UL
LTb
LTb
1.000 UP
grestore stroke
grestore
end
showpage
}}\put(522,1610){\cjust{Density of universal}}\put(397,756){\rjust{0}}\put(397,884){\rjust{0.2}}\put(397,1012){\rjust{0.4}}\put(397,1140){\rjust{0.6}}\put(397,1268){\rjust{0.8}}\put(397,1396){\rjust{1}}\put(2960,490){\special{ps: gsave currentpoint currentpoint translate
-34.5 rotate neg exch neg exch translate}\cstack{\cjust{f - accepting density}}\special{ps: currentpoint grestore moveto}}\put(3157,823){\cjust{0.1}}\put(2946,697){\cjust{0.3}}\put(2713,557){\cjust{0.5}}\put(2479,418){\cjust{0.7}}\put(2245,278){\cjust{0.9}}\put(1099,280){\special{ps: gsave currentpoint currentpoint translate
10.5 rotate neg exch neg exch translate}\cstack{\cjust{r - transition density}}\special{ps: currentpoint grestore moveto}}\put(477,572){\rjust{ 3}}\put(766,515){\rjust{ 2.5}}\put(1055,457){\rjust{ 2}}\put(1344,399){\rjust{ 1.5}}\put(1633,342){\rjust{ 1}}\put(1922,284){\rjust{ 0.5}}\put(3304,1627){\ljust{ 0.9}}\put(3304,1484){\ljust{ 0.7}}\put(3304,1340){\ljust{ 0.5}}\put(3304,1197){\ljust{ 0.3}}\put(3304,1053){\ljust{ 0.1}}\endGNUPLOTpicture
\endgroup
%
 }
    \caption{\protect\parbox[t]{45mm}{Density of universal automata for the samples of \figurename~\ref{fig:median-time}.}}
    \label{fig:density}
 \end{minipage}
\end{figure}

\begin{figure}[!tbp]
    \scalebox{0.5}{\begingroup
  \catcode`\@=11\relax
  \def\GNUPLOTspecial{\def\do##1{\catcode`##1=12\relax}\dospecials
    \catcode`\{=1\catcode`\}=2\catcode\%=14\relax\special}\expandafter\ifx\csname GNUPLOTpicture\endcsname\relax
  \csname newdimen\endcsname\GNUPLOTunit
  \gdef\GNUPLOTpicture(#1,#2){\vbox to#2\GNUPLOTunit\bgroup
    \def\put(##1,##2)##3{\unskip\raise##2\GNUPLOTunit
      \hbox to0pt{\kern##1\GNUPLOTunit ##3\hss}\ignorespaces}\def\ljust##1{\vbox to0pt{\vss\hbox to0pt{##1\hss}\vss}}\def\cjust##1{\vbox to0pt{\vss\hbox to0pt{\hss ##1\hss}\vss}}\def\rjust##1{\vbox to0pt{\vss\hbox to0pt{\hss ##1}\vss}}\def\stack##1{\let\\=\cr\tabskip=0pt\halign{\hfil ####\hfil\cr ##1\crcr}}\def\lstack##1{\hbox to0pt{\vbox to0pt{\vss\stack{##1}}\hss}}\def\cstack##1{\hbox to0pt{\hss\vbox to0pt{\vss\stack{##1}}\hss}}\def\rstack##1{\hbox to0pt{\vbox to0pt{\stack{##1}\vss}\hss}}\vss\hbox to#1\GNUPLOTunit\bgroup\ignorespaces}\gdef\endGNUPLOTpicture{\hss\egroup\egroup}\fi
\GNUPLOTunit=0.1bp
\GNUPLOTpicture(3600,2160)
{\GNUPLOTspecial{"
/gnudict 256 dict def
gnudict begin
/Color false def
/Solid false def
/gnulinewidth 5.000 def
/userlinewidth gnulinewidth def
/vshift -33 def
/dl {10.0 mul} def
/hpt_ 31.5 def
/vpt_ 31.5 def
/hpt hpt_ def
/vpt vpt_ def
/Rounded false def
/M {moveto} bind def
/L {lineto} bind def
/R {rmoveto} bind def
/V {rlineto} bind def
/N {newpath moveto} bind def
/C {setrgbcolor} bind def
/f {rlineto fill} bind def
/vpt2 vpt 2 mul def
/hpt2 hpt 2 mul def
/Lshow { currentpoint stroke M
  0 vshift R show } def
/Rshow { currentpoint stroke M
  dup stringwidth pop neg vshift R show } def
/Cshow { currentpoint stroke M
  dup stringwidth pop -2 div vshift R show } def
/UP { dup vpt_ mul /vpt exch def hpt_ mul /hpt exch def
  /hpt2 hpt 2 mul def /vpt2 vpt 2 mul def } def
/DL { Color {setrgbcolor Solid {pop []} if 0 setdash }
 {pop pop pop 0 setgray Solid {pop []} if 0 setdash} ifelse } def
/BL { stroke userlinewidth 2 mul setlinewidth
      Rounded { 1 setlinejoin 1 setlinecap } if } def
/AL { stroke userlinewidth 2 div setlinewidth
      Rounded { 1 setlinejoin 1 setlinecap } if } def
/UL { dup gnulinewidth mul /userlinewidth exch def
      dup 1 lt {pop 1} if 10 mul /udl exch def } def
/PL { stroke userlinewidth setlinewidth
      Rounded { 1 setlinejoin 1 setlinecap } if } def
/LTw { PL [] 1 setgray } def
/LTb { BL [] 0 0 0 DL } def
/LTa { AL [1 udl mul 2 udl mul] 0 setdash 0 0 0 setrgbcolor } def
/LT0 { PL [] 1 0 0 DL } def
/LT1 { PL [4 dl 2 dl] 0 1 0 DL } def
/LT2 { PL [2 dl 3 dl] 0 0 1 DL } def
/LT3 { PL [1 dl 1.5 dl] 1 0 1 DL } def
/LT4 { PL [5 dl 2 dl 1 dl 2 dl] 0 1 1 DL } def
/LT5 { PL [4 dl 3 dl 1 dl 3 dl] 1 1 0 DL } def
/LT6 { PL [2 dl 2 dl 2 dl 4 dl] 0 0 0 DL } def
/LT7 { PL [2 dl 2 dl 2 dl 2 dl 2 dl 4 dl] 1 0.3 0 DL } def
/LT8 { PL [2 dl 2 dl 2 dl 2 dl 2 dl 2 dl 2 dl 4 dl] 0.5 0.5 0.5 DL } def
/Pnt { stroke [] 0 setdash
   gsave 1 setlinecap M 0 0 V stroke grestore } def
/Dia { stroke [] 0 setdash 2 copy vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath stroke
  Pnt } def
/Pls { stroke [] 0 setdash vpt sub M 0 vpt2 V
  currentpoint stroke M
  hpt neg vpt neg R hpt2 0 V stroke
  } def
/Box { stroke [] 0 setdash 2 copy exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V closepath stroke
  Pnt } def
/Crs { stroke [] 0 setdash exch hpt sub exch vpt add M
  hpt2 vpt2 neg V currentpoint stroke M
  hpt2 neg 0 R hpt2 vpt2 V stroke } def
/TriU { stroke [] 0 setdash 2 copy vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath stroke
  Pnt  } def
/Star { 2 copy Pls Crs } def
/BoxF { stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V  hpt2 0 V  0 vpt2 V
  hpt2 neg 0 V  closepath fill } def
/TriUF { stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath fill } def
/TriD { stroke [] 0 setdash 2 copy vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath stroke
  Pnt  } def
/TriDF { stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath fill} def
/DiaF { stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath fill } def
/Pent { stroke [] 0 setdash 2 copy gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath stroke grestore Pnt } def
/PentF { stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath fill grestore } def
/Circle { stroke [] 0 setdash 2 copy
  hpt 0 360 arc stroke Pnt } def
/CircleF { stroke [] 0 setdash hpt 0 360 arc fill } def
/C0 { BL [] 0 setdash 2 copy moveto vpt 90 450  arc } bind def
/C1 { BL [] 0 setdash 2 copy        moveto
       2 copy  vpt 0 90 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C2 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 90 180 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C3 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 0 180 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C4 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 180 270 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C5 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 0 90 arc
       2 copy moveto
       2 copy  vpt 180 270 arc closepath fill
               vpt 0 360 arc } bind def
/C6 { BL [] 0 setdash 2 copy moveto
      2 copy  vpt 90 270 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C7 { BL [] 0 setdash 2 copy moveto
      2 copy  vpt 0 270 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C8 { BL [] 0 setdash 2 copy moveto
      2 copy vpt 270 360 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C9 { BL [] 0 setdash 2 copy moveto
      2 copy  vpt 270 450 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C10 { BL [] 0 setdash 2 copy 2 copy moveto vpt 270 360 arc closepath fill
       2 copy moveto
       2 copy vpt 90 180 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C11 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 0 180 arc closepath fill
       2 copy moveto
       2 copy  vpt 270 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C12 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 180 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C13 { BL [] 0 setdash  2 copy moveto
       2 copy  vpt 0 90 arc closepath fill
       2 copy moveto
       2 copy  vpt 180 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C14 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 90 360 arc closepath fill
               vpt 0 360 arc } bind def
/C15 { BL [] 0 setdash 2 copy vpt 0 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/Rec   { newpath 4 2 roll moveto 1 index 0 rlineto 0 exch rlineto
       neg 0 rlineto closepath } bind def
/Square { dup Rec } bind def
/Bsquare { vpt sub exch vpt sub exch vpt2 Square } bind def
/S0 { BL [] 0 setdash 2 copy moveto 0 vpt rlineto BL Bsquare } bind def
/S1 { BL [] 0 setdash 2 copy vpt Square fill Bsquare } bind def
/S2 { BL [] 0 setdash 2 copy exch vpt sub exch vpt Square fill Bsquare } bind def
/S3 { BL [] 0 setdash 2 copy exch vpt sub exch vpt2 vpt Rec fill Bsquare } bind def
/S4 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt Square fill Bsquare } bind def
/S5 { BL [] 0 setdash 2 copy 2 copy vpt Square fill
       exch vpt sub exch vpt sub vpt Square fill Bsquare } bind def
/S6 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill Bsquare } bind def
/S7 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill
       2 copy vpt Square fill
       Bsquare } bind def
/S8 { BL [] 0 setdash 2 copy vpt sub vpt Square fill Bsquare } bind def
/S9 { BL [] 0 setdash 2 copy vpt sub vpt vpt2 Rec fill Bsquare } bind def
/S10 { BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt Square fill
       Bsquare } bind def
/S11 { BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt2 vpt Rec fill
       Bsquare } bind def
/S12 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill Bsquare } bind def
/S13 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill
       2 copy vpt Square fill Bsquare } bind def
/S14 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill
       2 copy exch vpt sub exch vpt Square fill Bsquare } bind def
/S15 { BL [] 0 setdash 2 copy Bsquare fill Bsquare } bind def
/D0 { gsave translate 45 rotate 0 0 S0 stroke grestore } bind def
/D1 { gsave translate 45 rotate 0 0 S1 stroke grestore } bind def
/D2 { gsave translate 45 rotate 0 0 S2 stroke grestore } bind def
/D3 { gsave translate 45 rotate 0 0 S3 stroke grestore } bind def
/D4 { gsave translate 45 rotate 0 0 S4 stroke grestore } bind def
/D5 { gsave translate 45 rotate 0 0 S5 stroke grestore } bind def
/D6 { gsave translate 45 rotate 0 0 S6 stroke grestore } bind def
/D7 { gsave translate 45 rotate 0 0 S7 stroke grestore } bind def
/D8 { gsave translate 45 rotate 0 0 S8 stroke grestore } bind def
/D9 { gsave translate 45 rotate 0 0 S9 stroke grestore } bind def
/D10 { gsave translate 45 rotate 0 0 S10 stroke grestore } bind def
/D11 { gsave translate 45 rotate 0 0 S11 stroke grestore } bind def
/D12 { gsave translate 45 rotate 0 0 S12 stroke grestore } bind def
/D13 { gsave translate 45 rotate 0 0 S13 stroke grestore } bind def
/D14 { gsave translate 45 rotate 0 0 S14 stroke grestore } bind def
/D15 { gsave translate 45 rotate 0 0 S15 stroke grestore } bind def
/DiaE { stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath stroke } def
/BoxE { stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V closepath stroke } def
/TriUE { stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath stroke } def
/TriDE { stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath stroke } def
/PentE { stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath stroke grestore } def
/CircE { stroke [] 0 setdash 
  hpt 0 360 arc stroke } def
/Opaque { gsave closepath 1 setgray fill grestore 0 setgray closepath } def
/DiaW { stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V Opaque stroke } def
/BoxW { stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V Opaque stroke } def
/TriUW { stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V Opaque stroke } def
/TriDW { stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V Opaque stroke } def
/PentW { stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  Opaque stroke grestore } def
/CircW { stroke [] 0 setdash 
  hpt 0 360 arc Opaque stroke } def
/BoxFill { gsave Rec 1 setgray fill grestore } def
/BoxColFill {
  gsave Rec
  /Fillden exch def
  currentrgbcolor
  /ColB exch def /ColG exch def /ColR exch def
  /ColR ColR Fillden mul Fillden sub 1 add def
  /ColG ColG Fillden mul Fillden sub 1 add def
  /ColB ColB Fillden mul Fillden sub 1 add def
  ColR ColG ColB setrgbcolor
  fill grestore } def
/PatternFill { gsave /PFa [ 9 2 roll ] def
    PFa 0 get PFa 2 get 2 div add PFa 1 get PFa 3 get 2 div add translate
    PFa 2 get -2 div PFa 3 get -2 div PFa 2 get PFa 3 get Rec
    gsave 1 setgray fill grestore clip
    currentlinewidth 0.5 mul setlinewidth
    /PFs PFa 2 get dup mul PFa 3 get dup mul add sqrt def
    0 0 M PFa 5 get rotate PFs -2 div dup translate
	0 1 PFs PFa 4 get div 1 add floor cvi
	{ PFa 4 get mul 0 M 0 PFs V } for
    0 PFa 6 get ne {
	0 1 PFs PFa 4 get div 1 add floor cvi
	{ PFa 4 get mul 0 2 1 roll M PFs 0 V } for
    } if
    stroke grestore } def
/Symbol-Oblique /Symbol findfont [1 0 .167 1 0 0] makefont
dup length dict begin {1 index /FID eq {pop pop} {def} ifelse} forall
currentdict end definefont pop
end
gnudict begin
gsave
0 0 translate
0.100 0.100 scale
0 setgray
newpath
1.000 UL
LTb
gsave /maxcolors 0 def
/HSV2RGB {  exch dup 0.0 eq {pop exch pop dup dup} { /HSVs exch def /HSVv exch def 6.0 mul dup floor dup 3 1 roll sub
     /HSVf exch def /HSVi exch cvi def /HSVp HSVv 1.0 HSVs sub mul def
	 /HSVq HSVv 1.0 HSVs HSVf mul sub mul def 
	 /HSVt HSVv 1.0 HSVs 1.0 HSVf sub mul sub mul def
	 /HSVi HSVi 6 mod def 0 HSVi eq {HSVv HSVt HSVp}
	 {1 HSVi eq {HSVq HSVv HSVp}{2 HSVi eq {HSVp HSVv HSVt}
	 {3 HSVi eq {HSVp HSVq HSVv}{4 HSVi eq {HSVt HSVp HSVv}
	 {HSVv HSVp HSVq} ifelse} ifelse} ifelse} ifelse} ifelse
  } ifelse} def
/Constrain {
  dup 0 lt {0 exch pop}{dup 1 gt {1 exch pop} if} ifelse} def
/YIQ2RGB {
  3 copy -1.702 mul exch -1.105 mul add add Constrain 4 1 roll
  3 copy -0.647 mul exch -0.272 mul add add Constrain 5 1 roll
  0.621 mul exch -0.956 mul add add Constrain 3 1 roll } def
/CMY2RGB {  1 exch sub exch 1 exch sub 3 2 roll 1 exch sub 3 1 roll exch } def
/XYZ2RGB {  3 copy -0.9017 mul exch -0.1187 mul add exch 0.0585 mul exch add
  Constrain 4 1 roll 3 copy -0.0279 mul exch 1.999 mul add exch
  -0.9844 mul add Constrain 5 1 roll -0.2891 mul exch -0.5338 mul add
  exch 1.91 mul exch add Constrain 3 1 roll} def
/SelectSpace {ColorSpace (HSV) eq {HSV2RGB}{ColorSpace (XYZ) eq {
  XYZ2RGB}{ColorSpace (CMY) eq {CMY2RGB}{ColorSpace (YIQ) eq {YIQ2RGB}
  if} ifelse} ifelse} ifelse} def
/maxcolorsLast {maxcolors 1 sub maxcolors div} def
/pm3dround {maxcolors 0 gt {dup maxcolorsLast ge {pop 1}
{maxcolors mul floor maxcolors div} ifelse} if} def
/pm3dGamma 1.0 1.5 div def
/ColorSpace (RGB) def
Color false and { InterpolatedColor { /g {stroke pm3dround /grayv exch def interpolate
        SelectSpace setrgbcolor} bind def
  }{
  /g {stroke pm3dround dup cF7 Constrain exch dup cF5 Constrain exch cF15 Constrain 
       SelectSpace setrgbcolor} bind def
  } ifelse
}{
  /g {stroke pm3dround pm3dGamma exp setgray} bind def
} ifelse
/h {rlineto rlineto rlineto fill} bind def
stroke gsave	maxcolors 0 gt {/imax maxcolors def} {/imax 1024 def} ifelse
3125 982 translate 129 646 scale 0 setlinewidth
/ystep 1 imax div def /y0 0 def /ii 0 def
{ y0 g 0 y0 N 1 0 V 0 ystep V -1 0 f
/y0 y0 ystep add def /ii ii 1 add def
ii imax ge {exit} if } loop
grestore 0 setgray
1.000 UL
LTb
3125 982 M
129 0 V
0 646 V
-129 0 V
0 -646 V
1.000 UL
LTb
1.000 UL
LTb
3254 982 M
-63 0 V
1.000 UL
LTb
3125 982 M
63 0 V
66 80 R
-63 0 V
1.000 UL
LTb
3125 1062 M
63 0 V
66 81 R
-63 0 V
1.000 UL
LTb
3125 1143 M
63 0 V
66 81 R
-63 0 V
1.000 UL
LTb
3125 1224 M
63 0 V
66 81 R
-63 0 V
1.000 UL
LTb
3125 1305 M
63 0 V
66 80 R
-63 0 V
1.000 UL
LTb
3125 1385 M
63 0 V
66 81 R
-63 0 V
1.000 UL
LTb
3125 1466 M
63 0 V
66 81 R
-63 0 V
1.000 UL
LTb
3125 1547 M
63 0 V
66 81 R
-63 0 V
1.000 UL
LTb
3125 1628 M
63 0 V
1.000 UP
1.000 UL
LT0
1588 1113 M
-81 173 V
1.000 UL
LT0
1638 1396 M
1507 1286 L
1.000 UL
LT0
1375 1303 M
132 -17 V
1.000 UL
LT0
1456 1164 M
-81 139 V
1.000 UL
LT0
1244 1361 M
131 -58 V
1.000 UL
LT0
1719 1135 M
-81 261 V
1.000 UL
LT0
1770 1527 M
1638 1396 L
1.000 UL
LT0
1325 1213 M
-81 148 V
1.000 UL
LT0
1112 1466 M
132 -105 V
1.000 UL
LT0
1850 1168 M
-80 359 V
1.000 UL
LT0
1900 1637 M
1770 1527 L
1.000 UL
LT0
1669 937 M
-81 176 V
1.000 UL
LT0
1719 1135 M
-131 -22 V
1.000 UL
LT0
1456 1164 M
132 -51 V
1.000 UL
LT0
1800 945 M
-81 190 V
1.000 UL
LT0
1850 1168 M
-131 -33 V
1.000 UL
LT0
1931 999 M
-81 169 V
1.000 UL
LT0
1981 1253 M
-131 -85 V
1.000 UL
LT0
2639 1518 M
-81 159 V
1.000 UL
LT0
2426 1669 M
132 8 V
1.000 UL
LT0
1193 1307 M
-81 159 V
1.000 UL
LT0
980 1581 M
132 -115 V
1.000 UL
LT0
2508 1510 M
-82 159 V
1.000 UL
LT0
2295 1661 M
131 8 V
1.000 UL
LT0
2376 1502 M
-81 159 V
1.000 UL
LT0
2163 1653 M
132 8 V
1.000 UL
LT0
2244 1449 M
-81 204 V
1.000 UL
LT0
2032 1645 M
131 8 V
1.000 UL
LT0
2113 1349 M
-81 296 V
1.000 UL
LT0
1900 1637 M
132 8 V
1.000 UL
LT0
1537 1007 M
-81 157 V
1.000 UL
LT0
1325 1213 M
131 -49 V
1.000 UL
LT0
1981 1253 M
-81 384 V
1.000 UL
LT0
2063 1039 M
-82 214 V
1.000 UL
LT0
2113 1349 M
-132 -96 V
1.000 UL
LT0
1406 1055 M
-81 158 V
1.000 UL
LT0
1193 1307 M
132 -94 V
1.000 UL
LT0
2194 1047 M
-81 302 V
1.000 UL
LT0
2244 1449 M
2113 1349 L
1.000 UL
LT0
1062 1422 M
-82 159 V
1.000 UL
LT0
849 1573 M
131 8 V
1.000 UL
LT0
930 1414 M
-81 159 V
1.000 UL
LT0
717 1565 M
132 8 V
1.000 UL
LT0
799 1406 M
-82 159 V
1.000 UL
LT0
1881 709 M
-81 236 V
1.000 UL
LT0
1931 999 M
1800 945 L
1.000 UL
LT0
1669 937 M
131 8 V
1.000 UL
LT0
1750 733 M
-81 204 V
1.000 UL
LT0
1537 1007 M
132 -70 V
1.000 UL
LT0
2407 896 M
-81 159 V
1.000 UL
LT0
2457 1080 M
-131 -25 V
1.000 UL
LT0
2244 1449 M
82 -394 V
1.000 UL
LT0
2194 1047 M
132 8 V
1.000 UL
LT0
2012 749 M
-81 250 V
1.000 UL
LT0
2063 1039 M
1931 999 L
1.000 UL
LT0
2538 936 M
-81 144 V
1.000 UL
LT0
2589 1156 M
-132 -76 V
1.000 UL
LT0
2376 1502 M
81 -422 V
1.000 UL
LT0
2376 1502 M
-132 -53 V
1.000 UL
LT0
2275 867 M
-81 180 V
1.000 UL
LT0
2063 1039 M
131 8 V
1.000 UL
LT0
2720 1237 M
-81 281 V
1.000 UL
LT0
2508 1510 M
131 8 V
1.000 UL
LT0
2144 820 M
-81 219 V
1.000 UL
LT0
1274 1148 M
-81 159 V
1.000 UL
LT0
1062 1422 M
131 -115 V
1.000 UL
LT0
2589 1156 M
-81 354 V
1.000 UL
LT0
2376 1502 M
132 8 V
1.000 UL
LT0
2670 957 M
-81 199 V
1.000 UL
LT0
2720 1237 M
-131 -81 V
1.000 UL
LT0
1619 827 M
-82 180 V
1.000 UL
LT0
1406 1055 M
131 -48 V
1.000 UL
LT0
1962 583 M
-81 126 V
1.000 UL
LT0
2012 749 M
1881 709 L
1.000 UL
LT0
1750 733 M
131 -24 V
1.000 UL
LT0
2801 977 M
-81 260 V
1.000 UL
LT0
1487 897 M
-81 158 V
1.000 UL
LT0
1274 1148 M
132 -93 V
1.000 UL
LT0
2093 558 M
-81 191 V
1.000 UL
LT0
2144 820 M
2012 749 L
1.000 UL
LT0
1143 1263 M
-81 159 V
1.000 UL
LT0
930 1414 M
132 8 V
1.000 UL
LT0
1830 620 M
-80 113 V
1.000 UL
LT0
1619 827 M
131 -94 V
1.000 UL
LT0
1011 1255 M
-81 159 V
1.000 UL
LT0
799 1406 M
131 8 V
1.000 UL
LT0
880 1247 M
-81 159 V
1.000 UL
LT0
2225 599 M
-81 221 V
1.000 UL
LT0
2275 867 M
2144 820 L
1.000 UL
LT0
2356 631 M
-81 236 V
1.000 UL
LT0
2407 896 M
2275 867 L
1.000 UL
LT0
2488 639 M
-81 257 V
1.000 UL
LT0
2538 936 M
2407 896 L
1.000 UL
LT0
2620 685 M
-82 251 V
1.000 UL
LT0
2670 957 M
2538 936 L
1.000 UL
LT0
2751 721 M
-81 236 V
1.000 UL
LT0
2801 977 M
2670 957 L
1.000 UL
LT0
2883 741 M
-82 236 V
1.000 UL
LT0
1356 991 M
-82 157 V
1.000 UL
LT0
1143 1263 M
131 -115 V
1.000 UL
LT0
1700 689 M
-81 138 V
1.000 UL
LT0
1487 897 M
132 -70 V
1.000 UL
LT0
2225 599 M
2093 558 L
1.000 UL
LT0
1962 583 M
131 -25 V
1.000 UL
LT0
2356 631 M
2225 599 L
1.000 UL
LT0
2620 685 M
2488 639 L
1.000 UL
LT0
2356 631 M
132 8 V
1.000 UL
LT0
1568 738 M
-81 159 V
1.000 UL
LT0
1356 991 M
131 -94 V
1.000 UL
LT0
1830 620 M
132 -37 V
1.000 UL
LT0
2751 721 M
2620 685 L
1.000 UL
LT0
1224 1105 M
-81 158 V
1.000 UL
LT0
1011 1255 M
132 8 V
1.000 UL
LT0
1092 1097 M
-81 158 V
1.000 UL
LT0
880 1247 M
131 8 V
1.000 UL
LT0
2883 741 M
2751 721 L
1.000 UL
LT0
961 1089 M
-81 158 V
1.000 UL
LT0
1700 689 M
130 -69 V
1.000 UL
LT0
1437 842 M
-81 149 V
1.000 UL
LT0
1224 1105 M
1356 991 L
1.000 UL
LT0
1568 738 M
132 -49 V
1.000 UL
LT0
1437 842 M
1568 738 L
1.000 UL
LT0
1305 946 M
-81 159 V
1.000 UL
LT0
1092 1097 M
132 8 V
1.000 UL
LT0
1174 938 M
-82 159 V
1.000 UL
LT0
961 1089 M
131 8 V
1.000 UL
LT0
1042 930 M
-81 159 V
1.000 UL
LT0
1305 946 M
1437 842 L
1.000 UL
LT0
1174 938 M
131 8 V
1.000 UL
LT0
1042 930 M
132 8 V
.9375 g 2639 1518 N 132 8 -82 159 -131 -8 h
.5875 g 2720 1237 N 131 8 -81 354 -131 -81 h
.1781 g 2801 976 N 131 81 -81 200 -131 -20 h
.0891 g 2883 740 N 131 20 -81 236 -132 -20 h
.9375 g 2508 1510 N 131 8 -81 159 -132 -8 h
.5313 g 2589 1156 N 132 8 -81 423 -132 -77 h
.1156 g 2670 956 N 132 77 -81 144 -132 -21 h
.0781 g 2751 720 N 132 21 -82 251 -131 -36 h
.8594 g 2376 1502 N 132 8 -81 204 -132 -53 h
.4312 g 2457 1079 N 132 53 -82 395 -131 -25 h
.0844 g 2538 935 N 131 25 -81 159 -131 -40 h
.0625 g 2620 684 N 131 40 -81 257 -132 -46 h
.6937 g 2244 1449 N 131 8 -81 296 -131 -100 h
.2625 g 2326 1054 N 131 100 -81 303 -132 -8 h
.0719 g 2407 895 N 132 8 -81 180 -132 -29 h
.05 g 2488 638 N 132 29 -81 236 -132 -8 h
.5687 g 2113 1349 N 132 8 -81 384 -132 -96 h
.1375 g 2194 1046 N 132 96 -82 215 -131 -8 h
.0641 g 2275 866 N 131 8 -81 219 -131 -47 h
.0406 g 2356 630 N 131 47 -81 221 -131 -32 h
.375 g 1981 1253 N 131 110 -81 359 -131 -85 h
.0797 g 2063 1038 N 131 85 -81 170 -132 -40 h
.05 g 2144 819 N 132 40 -81 250 -132 -71 h
.0281 g 2225 598 N 132 71 -81 191 -132 -41 h
.1531 g 1850 1168 N 132 131 -81 261 -132 -33 h
.0516 g 1931 998 N 132 33 -82 191 -131 -54 h
.0344 g 2012 748 N 131 54 -81 236 -131 -40 h
.0219 g 2093 557 N 131 40 -81 126 -131 25 h
.0672 g 1718 1135 N 131 110 -81 174 -131 -23 h
.0422 g 1800 944 N 131 23 -81 176 -132 -8 h
.0297 g 1881 708 N 132 8 -81 204 -132 24 h
.0266 g 1962 582 N 132 -24 -81 113 -132 37 h
.0578 g 1587 1112 N 132 -17 -81 139 -132 52 h
.0578 g 1668 936 N 132 -52 -81 158 -132 70 h
.05 g 1749 732 N 132 -70 -82 180 -131 94 h
.05 g 1830 619 N 131 -94 -81 138 -131 69 h
.0937 g 1455 1164 N 131 -58 -81 148 -131 49 h
.1 g 1536 1006 N 131 -49 -81 159 -131 48 h
.0969 g 1618 826 N 131 -48 -81 158 -132 70 h
.0969 g 1699 688 N 132 -70 -81 159 -132 49 h
.2156 g 1324 1213 N 132 -105 -81 159 -132 94 h
.2187 g 1405 1054 N 132 -94 -81 159 -132 94 h
.2187 g 1486 896 N 132 -94 -82 158 -131 94 h
.2266 g 1567 737 N 131 -94 -81 149 -131 104 h
.625 g 1192 1307 N 132 -115 -82 159 -131 115 h
.625 g 1273 1148 N 131 -115 -81 159 -131 115 h
.625 g 1355 990 N 131 -115 -81 159 -132 114 h
.6328 g 1436 841 N 132 -114 -81 159 -132 104 h
.9375 g 1061 1422 N 131 8 -81 159 -132 -8 h
.9375 g 1142 1263 N 132 8 -81 159 -132 -8 h
.9375 g 1223 1104 N 132 8 -81 159 -132 -8 h
.9375 g 1304 945 N 132 8 -82 159 -131 -8 h
.9375 g 929 1414 N 132 8 -82 159 -131 -8 h
.9375 g 1010 1255 N 131 8 -81 159 -131 -8 h
.9375 g 1091 1096 N 131 8 -81 159 -131 -8 h
.9375 g 1173 937 N 131 8 -81 159 -132 -8 h
1.000 UL
LT0
1.000 UL
LTb
1042 372 M
2883 484 L
1.000 UL
LTb
1042 372 M
717 1008 L
1.000 UL
LTb
717 1008 M
277 17 V
1.000 UL
LTb
2883 484 M
2761 722 L
1.000 UL
LTb
717 1565 M
0 -557 V
1.000 UL
LTb
717 1776 M
0 -211 V
1.000 UL
LTb
2883 741 M
0 -257 V
1.000 UL
LTb
1042 930 M
0 -558 V
1.000 UL
LTa
2870 483 M
2749 720 L
1.000 UL
LTb
2870 483 M
-21 40 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTa
2620 468 M
-95 184 V
1.000 UL
LTb
2620 468 M
-21 40 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTa
2356 452 M
-81 159 V
1.000 UL
LTb
2356 452 M
-20 40 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTa
2093 436 M
-69 135 V
1.000 UL
LTb
2093 436 M
-20 40 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTa
1830 420 M
1693 691 L
1.000 UL
LTb
1830 420 M
-20 40 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTa
1568 404 M
1292 945 L
1.000 UL
LTb
1568 404 M
-20 40 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTa
1305 388 M
980 1024 L
1.000 UL
LTb
1305 388 M
-20 40 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTb
1001 984 M
-21 40 V
1.000 UL
LTa
1042 372 M
717 1008 L
1.000 UL
LTb
1042 372 M
-20 40 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTb
738 968 M
-21 40 V
LTb
1.000 UL
LTa
717 1008 M
277 17 V
1.000 UL
LTb
717 1008 M
62 3 V
1.000 UL
LTb
1.000 UL
LTa
799 849 M
584 35 V
1.000 UL
LTb
799 849 M
62 4 V
1.000 UL
LTb
1.000 UL
LTa
880 690 M
702 43 V
1.000 UL
LTb
880 690 M
62 4 V
1.000 UL
LTb
1.000 UL
LTa
2275 611 M
526 32 V
1.000 UL
LTa
961 531 M
973 59 V
1.000 UL
LTb
961 531 M
62 4 V
1.000 UL
LTb
1.000 UL
LTb
2739 639 M
62 4 V
1.000 UL
LTa
1034 388 M
2875 500 L
1.000 UL
LTb
1034 388 M
62 4 V
1.000 UL
LTb
1.000 UL
LTb
2812 496 M
63 4 V
LTb
1.000 UL
LTb
780 1776 M
-63 0 V
1.000 UL
LTb
1.000 UL
LTb
740 1519 M
-23 0 V
1.000 UL
LTb
1.000 UL
LTb
780 1263 M
-63 0 V
1.000 UL
LTb
1.000 UL
LTb
780 1008 M
-63 0 V
1.000 UL
LTb
LTb
1.000 UP
grestore stroke
grestore
end
showpage
}}\put(716,1968){\cjust{Number of locations}}\put(591,1263){\rjust{100}}\put(591,1519){\rjust{1000}}\put(591,1776){\rjust{10000}}\put(489,662){\special{ps: gsave currentpoint currentpoint translate
64.5 rotate neg exch neg exch translate}\cstack{\cjust{f - accepting density}}\special{ps: currentpoint grestore moveto}}\put(985,382){\rjust{0.1}}\put(912,525){\rjust{0.3}}\put(830,684){\rjust{0.5}}\put(749,843){\rjust{0.7}}\put(668,1002){\rjust{0.9}}\put(2043,200){\special{ps: gsave currentpoint currentpoint translate
-3.5 rotate neg exch neg exch translate}\cstack{\cjust{r - transition density}}\special{ps: currentpoint grestore moveto}}\put(1058,309){\cjust{0.2}}\put(1321,325){\cjust{0.6}}\put(1584,341){\cjust{1}}\put(1846,357){\cjust{1.4}}\put(2110,373){\cjust{1.8}}\put(2373,389){\cjust{2.2}}\put(2636,405){\cjust{2.6}}\put(2886,420){\cjust{3}}\put(3304,1628){\ljust{ $\propto$}}\put(3304,1466){\ljust{ 1200}}\put(3304,1305){\ljust{ 800}}\put(3304,1143){\ljust{ 400}}\put(3304,982){\ljust{ 0}}\endGNUPLOTpicture
\endgroup
%
 }
    \caption{\protect\parbox[t]{80mm}{Automata size for which the median execution time to
check universality is less than 20 seconds (log scale). See also Table~\ref{tab:max-size}.}}
    \label{fig:max-size} 
\end{figure}

\begin{table}[!tbp]
\caption{Automata size (NBW) for which the median execution time for 
checking universality is less than 20 seconds. The symbol $\propto$ means \emph{more than 1500}.} \label{tab:max-size}
\begin{center}
\begin{tabular}{|c||*{11}{p{5mm}|}p{7mm}|*{3}{p{5mm}|} }\hline
{\scriptsize \backslashbox[0mm]{{\normalsize f}}{{\normalsize r{\strut}}}}
    & \centering 0.2       & \centering 0.4       & \centering 0.6       & \centering 0.8 & \centering 1.0 & \centering 1.2 & \centering 1.4 & \centering 1.6 & \centering 1.8 & \centering 2.0  & \centering 2.2  & \centering 2.4  & \centering 2.6  & \centering 2.8  & \multicolumn{1}{c|}{3.0}  \\\hline\hline
0.1 & \centering $\propto$ & \centering $\propto$ & \centering $\propto$ & \centering 550 & \centering 200 & \centering 120 & \centering 60  & \centering 40  & \centering 30  & \centering 40   & \centering 50   & \centering 50   & \centering 70   & \centering 90   & \multicolumn{1}{c|}{100}  \\\hline
0.3 & \centering $\propto$ & \centering $\propto$ & \centering $\propto$ & \centering 500 & \centering 200 & \centering 100 & \centering 40  & \centering 30  & \centering 40  & \centering 70   & \centering 100  & \centering 120  & \centering 160  & \centering 180  & \multicolumn{1}{c|}{200}  \\\hline
0.5 & \centering $\propto$ & \centering $\propto$ & \centering $\propto$ & \centering 500 & \centering 200 & \centering 120 & \centering 60  & \centering 60  & \centering 90  & \centering 120  & \centering 120  & \centering 120  & \centering 140  & \centering 260  & \multicolumn{1}{c|}{500}  \\\hline
0.7 & \centering $\propto$ & \centering $\propto$ & \centering $\propto$ & \centering 500 & \centering 200 & \centering 120 & \centering 70  & \centering 80  & \centering 100 & \centering 200  & \centering 440  & \centering 1000 & \centering $\propto$ & \centering $\propto$ & \multicolumn{1}{c|}{$\propto$} \\\hline
0.9 & \centering $\propto$ & \centering $\propto$ & \centering $\propto$ & \centering 500 & \centering 180 & \centering 100 & \centering 80  & \centering 200 & \centering 600 & \centering $\propto$ & \centering $\propto$ & \centering $\propto$ & \centering $\propto$ & \centering $\propto$ & \multicolumn{1}{c|}{$\propto$} \\\hline
\end{tabular}
\end{center}
\end{table}

The results are shown in Fig.~\ref{fig:max-size}, and the corresponding 
values are given in Table~\ref{tab:max-size}. The vertical scale is logarithmic.
For example, for $r=2$ and $f=0.5$, our algorithm was able to handle at least $50$ automata of size $120$ 
in less than 20 seconds and was not able to do so for automata of size $140$.
In comparison, Tabakov and Vardi have studied the behavior of
Kupferman-Vardi and Miyano-Hayashi constructions for different
implementation schemes. We compare with the performances of their
symbolic approach which is the most efficient. 
For the same parameter values ($r=2$ and $f=0.5$), they
report that their implementation can handle NBW with at most 8 states 
in less than $20$ seconds~\cite{TabakovV07}.     

In \figurename~\ref{fig:scalability}, we show the median execution time to 
check universality for relatively difficult instances ($r=2$ and $f$ vary from
$0.3$ to $0.7$). The vertical scale is logarithmic, so the behavior is roughly 
exponential in the size of the automata. Similar analyzes are reported 
in~\cite{TabakovV07} but for sizes below $10$.

Finally, we give in \figurename~\ref{fig:distribution} the
distribution of execution times for $100$ automata of size $50$ with
$r=2.2$ and $f=0.5$, so that roughly half of the instances are
universal. Each point represents one automaton, and one point lies
outside the figure with an execution time of $675$s for a non
universal automaton. The existence of very few instances that are very
hard was often encountered in the experiments, and this is why we use
the median for the execution times. If we except this hard instance,
\figurename~\ref{fig:distribution} shows that universal automata
(average time $350$ms) are slightly easier to analyze than
non-universal automata (average time $490$ms).  This probably comes
from the fact that we stop the computation of the (greatest) fixed
point whenever the initial state is not in the $\preceq_{{\sf univ}}$-closure
of the current approximation. Indeed, in such
case, since the approximations are $\preceq_{{\sf univ}}$-decreasing,
we know that the initial state would also not lie in the fixed point.
Of course, this optimization applies only for universal automata.




\begin{figure}[!tbp]
  \begin{minipage}[b]{.47\linewidth}
    \scalebox{0.5}{\begingroup
  \catcode`\@=11\relax
  \def\GNUPLOTspecial{\def\do##1{\catcode`##1=12\relax}\dospecials
    \catcode`\{=1\catcode`\}=2\catcode\%=14\relax\special}\expandafter\ifx\csname GNUPLOTpicture\endcsname\relax
  \csname newdimen\endcsname\GNUPLOTunit
  \gdef\GNUPLOTpicture(#1,#2){\vbox to#2\GNUPLOTunit\bgroup
    \def\put(##1,##2)##3{\unskip\raise##2\GNUPLOTunit
      \hbox to0pt{\kern##1\GNUPLOTunit ##3\hss}\ignorespaces}\def\ljust##1{\vbox to0pt{\vss\hbox to0pt{##1\hss}\vss}}\def\cjust##1{\vbox to0pt{\vss\hbox to0pt{\hss ##1\hss}\vss}}\def\rjust##1{\vbox to0pt{\vss\hbox to0pt{\hss ##1}\vss}}\def\stack##1{\let\\=\cr\tabskip=0pt\halign{\hfil ####\hfil\cr ##1\crcr}}\def\lstack##1{\hbox to0pt{\vbox to0pt{\vss\stack{##1}}\hss}}\def\cstack##1{\hbox to0pt{\hss\vbox to0pt{\vss\stack{##1}}\hss}}\def\rstack##1{\hbox to0pt{\vbox to0pt{\stack{##1}\vss}\hss}}\vss\hbox to#1\GNUPLOTunit\bgroup\ignorespaces}\gdef\endGNUPLOTpicture{\hss\egroup\egroup}\fi
\GNUPLOTunit=0.1bp
\GNUPLOTpicture(3600,2160)
{\GNUPLOTspecial{"
/gnudict 256 dict def
gnudict begin
/Color false def
/Solid false def
/gnulinewidth 5.000 def
/userlinewidth gnulinewidth def
/vshift -33 def
/dl {10.0 mul} def
/hpt_ 31.5 def
/vpt_ 31.5 def
/hpt hpt_ def
/vpt vpt_ def
/Rounded false def
/M {moveto} bind def
/L {lineto} bind def
/R {rmoveto} bind def
/V {rlineto} bind def
/N {newpath moveto} bind def
/C {setrgbcolor} bind def
/f {rlineto fill} bind def
/vpt2 vpt 2 mul def
/hpt2 hpt 2 mul def
/Lshow { currentpoint stroke M
  0 vshift R show } def
/Rshow { currentpoint stroke M
  dup stringwidth pop neg vshift R show } def
/Cshow { currentpoint stroke M
  dup stringwidth pop -2 div vshift R show } def
/UP { dup vpt_ mul /vpt exch def hpt_ mul /hpt exch def
  /hpt2 hpt 2 mul def /vpt2 vpt 2 mul def } def
/DL { Color {setrgbcolor Solid {pop []} if 0 setdash }
 {pop pop pop 0 setgray Solid {pop []} if 0 setdash} ifelse } def
/BL { stroke userlinewidth 2 mul setlinewidth
      Rounded { 1 setlinejoin 1 setlinecap } if } def
/AL { stroke userlinewidth 2 div setlinewidth
      Rounded { 1 setlinejoin 1 setlinecap } if } def
/UL { dup gnulinewidth mul /userlinewidth exch def
      dup 1 lt {pop 1} if 10 mul /udl exch def } def
/PL { stroke userlinewidth setlinewidth
      Rounded { 1 setlinejoin 1 setlinecap } if } def
/LTw { PL [] 1 setgray } def
/LTb { BL [] 0 0 0 DL } def
/LTa { AL [1 udl mul 2 udl mul] 0 setdash 0 0 0 setrgbcolor } def
/LT0 { PL [] 1 0 0 DL } def
/LT1 { PL [4 dl 2 dl] 0 1 0 DL } def
/LT2 { PL [2 dl 3 dl] 0 0 1 DL } def
/LT3 { PL [1 dl 1.5 dl] 1 0 1 DL } def
/LT4 { PL [5 dl 2 dl 1 dl 2 dl] 0 1 1 DL } def
/LT5 { PL [4 dl 3 dl 1 dl 3 dl] 1 1 0 DL } def
/LT6 { PL [2 dl 2 dl 2 dl 4 dl] 0 0 0 DL } def
/LT7 { PL [2 dl 2 dl 2 dl 2 dl 2 dl 4 dl] 1 0.3 0 DL } def
/LT8 { PL [2 dl 2 dl 2 dl 2 dl 2 dl 2 dl 2 dl 4 dl] 0.5 0.5 0.5 DL } def
/Pnt { stroke [] 0 setdash
   gsave 1 setlinecap M 0 0 V stroke grestore } def
/Dia { stroke [] 0 setdash 2 copy vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath stroke
  Pnt } def
/Pls { stroke [] 0 setdash vpt sub M 0 vpt2 V
  currentpoint stroke M
  hpt neg vpt neg R hpt2 0 V stroke
  } def
/Box { stroke [] 0 setdash 2 copy exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V closepath stroke
  Pnt } def
/Crs { stroke [] 0 setdash exch hpt sub exch vpt add M
  hpt2 vpt2 neg V currentpoint stroke M
  hpt2 neg 0 R hpt2 vpt2 V stroke } def
/TriU { stroke [] 0 setdash 2 copy vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath stroke
  Pnt  } def
/Star { 2 copy Pls Crs } def
/BoxF { stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V  hpt2 0 V  0 vpt2 V
  hpt2 neg 0 V  closepath fill } def
/TriUF { stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath fill } def
/TriD { stroke [] 0 setdash 2 copy vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath stroke
  Pnt  } def
/TriDF { stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath fill} def
/DiaF { stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath fill } def
/Pent { stroke [] 0 setdash 2 copy gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath stroke grestore Pnt } def
/PentF { stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath fill grestore } def
/Circle { stroke [] 0 setdash 2 copy
  hpt 0 360 arc stroke Pnt } def
/CircleF { stroke [] 0 setdash hpt 0 360 arc fill } def
/C0 { BL [] 0 setdash 2 copy moveto vpt 90 450  arc } bind def
/C1 { BL [] 0 setdash 2 copy        moveto
       2 copy  vpt 0 90 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C2 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 90 180 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C3 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 0 180 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C4 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 180 270 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C5 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 0 90 arc
       2 copy moveto
       2 copy  vpt 180 270 arc closepath fill
               vpt 0 360 arc } bind def
/C6 { BL [] 0 setdash 2 copy moveto
      2 copy  vpt 90 270 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C7 { BL [] 0 setdash 2 copy moveto
      2 copy  vpt 0 270 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C8 { BL [] 0 setdash 2 copy moveto
      2 copy vpt 270 360 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C9 { BL [] 0 setdash 2 copy moveto
      2 copy  vpt 270 450 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C10 { BL [] 0 setdash 2 copy 2 copy moveto vpt 270 360 arc closepath fill
       2 copy moveto
       2 copy vpt 90 180 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C11 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 0 180 arc closepath fill
       2 copy moveto
       2 copy  vpt 270 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C12 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 180 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C13 { BL [] 0 setdash  2 copy moveto
       2 copy  vpt 0 90 arc closepath fill
       2 copy moveto
       2 copy  vpt 180 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C14 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 90 360 arc closepath fill
               vpt 0 360 arc } bind def
/C15 { BL [] 0 setdash 2 copy vpt 0 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/Rec   { newpath 4 2 roll moveto 1 index 0 rlineto 0 exch rlineto
       neg 0 rlineto closepath } bind def
/Square { dup Rec } bind def
/Bsquare { vpt sub exch vpt sub exch vpt2 Square } bind def
/S0 { BL [] 0 setdash 2 copy moveto 0 vpt rlineto BL Bsquare } bind def
/S1 { BL [] 0 setdash 2 copy vpt Square fill Bsquare } bind def
/S2 { BL [] 0 setdash 2 copy exch vpt sub exch vpt Square fill Bsquare } bind def
/S3 { BL [] 0 setdash 2 copy exch vpt sub exch vpt2 vpt Rec fill Bsquare } bind def
/S4 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt Square fill Bsquare } bind def
/S5 { BL [] 0 setdash 2 copy 2 copy vpt Square fill
       exch vpt sub exch vpt sub vpt Square fill Bsquare } bind def
/S6 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill Bsquare } bind def
/S7 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill
       2 copy vpt Square fill
       Bsquare } bind def
/S8 { BL [] 0 setdash 2 copy vpt sub vpt Square fill Bsquare } bind def
/S9 { BL [] 0 setdash 2 copy vpt sub vpt vpt2 Rec fill Bsquare } bind def
/S10 { BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt Square fill
       Bsquare } bind def
/S11 { BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt2 vpt Rec fill
       Bsquare } bind def
/S12 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill Bsquare } bind def
/S13 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill
       2 copy vpt Square fill Bsquare } bind def
/S14 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill
       2 copy exch vpt sub exch vpt Square fill Bsquare } bind def
/S15 { BL [] 0 setdash 2 copy Bsquare fill Bsquare } bind def
/D0 { gsave translate 45 rotate 0 0 S0 stroke grestore } bind def
/D1 { gsave translate 45 rotate 0 0 S1 stroke grestore } bind def
/D2 { gsave translate 45 rotate 0 0 S2 stroke grestore } bind def
/D3 { gsave translate 45 rotate 0 0 S3 stroke grestore } bind def
/D4 { gsave translate 45 rotate 0 0 S4 stroke grestore } bind def
/D5 { gsave translate 45 rotate 0 0 S5 stroke grestore } bind def
/D6 { gsave translate 45 rotate 0 0 S6 stroke grestore } bind def
/D7 { gsave translate 45 rotate 0 0 S7 stroke grestore } bind def
/D8 { gsave translate 45 rotate 0 0 S8 stroke grestore } bind def
/D9 { gsave translate 45 rotate 0 0 S9 stroke grestore } bind def
/D10 { gsave translate 45 rotate 0 0 S10 stroke grestore } bind def
/D11 { gsave translate 45 rotate 0 0 S11 stroke grestore } bind def
/D12 { gsave translate 45 rotate 0 0 S12 stroke grestore } bind def
/D13 { gsave translate 45 rotate 0 0 S13 stroke grestore } bind def
/D14 { gsave translate 45 rotate 0 0 S14 stroke grestore } bind def
/D15 { gsave translate 45 rotate 0 0 S15 stroke grestore } bind def
/DiaE { stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath stroke } def
/BoxE { stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V closepath stroke } def
/TriUE { stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath stroke } def
/TriDE { stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath stroke } def
/PentE { stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath stroke grestore } def
/CircE { stroke [] 0 setdash 
  hpt 0 360 arc stroke } def
/Opaque { gsave closepath 1 setgray fill grestore 0 setgray closepath } def
/DiaW { stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V Opaque stroke } def
/BoxW { stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V Opaque stroke } def
/TriUW { stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V Opaque stroke } def
/TriDW { stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V Opaque stroke } def
/PentW { stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  Opaque stroke grestore } def
/CircW { stroke [] 0 setdash 
  hpt 0 360 arc Opaque stroke } def
/BoxFill { gsave Rec 1 setgray fill grestore } def
/BoxColFill {
  gsave Rec
  /Fillden exch def
  currentrgbcolor
  /ColB exch def /ColG exch def /ColR exch def
  /ColR ColR Fillden mul Fillden sub 1 add def
  /ColG ColG Fillden mul Fillden sub 1 add def
  /ColB ColB Fillden mul Fillden sub 1 add def
  ColR ColG ColB setrgbcolor
  fill grestore } def
/PatternFill { gsave /PFa [ 9 2 roll ] def
    PFa 0 get PFa 2 get 2 div add PFa 1 get PFa 3 get 2 div add translate
    PFa 2 get -2 div PFa 3 get -2 div PFa 2 get PFa 3 get Rec
    gsave 1 setgray fill grestore clip
    currentlinewidth 0.5 mul setlinewidth
    /PFs PFa 2 get dup mul PFa 3 get dup mul add sqrt def
    0 0 M PFa 5 get rotate PFs -2 div dup translate
	0 1 PFs PFa 4 get div 1 add floor cvi
	{ PFa 4 get mul 0 M 0 PFs V } for
    0 PFa 6 get ne {
	0 1 PFs PFa 4 get div 1 add floor cvi
	{ PFa 4 get mul 0 2 1 roll M PFs 0 V } for
    } if
    stroke grestore } def
/Symbol-Oblique /Symbol findfont [1 0 .167 1 0 0] makefont
dup length dict begin {1 index /FID eq {pop pop} {def} ifelse} forall
currentdict end definefont pop
end
gnudict begin
gsave
0 0 translate
0.100 0.100 scale
0 setgray
newpath
1.000 UL
LTb
1.000 UL
LTa
500 300 M
2836 0 V
1.000 UL
LTb
500 300 M
63 0 V
2773 0 R
-63 0 V
1.000 UL
LTb
500 400 M
31 0 V
2805 0 R
-31 0 V
500 532 M
31 0 V
2805 0 R
-31 0 V
500 600 M
31 0 V
2805 0 R
-31 0 V
1.000 UL
LTa
500 632 M
2836 0 V
1.000 UL
LTb
500 632 M
63 0 V
2773 0 R
-63 0 V
1.000 UL
LTb
500 732 M
31 0 V
2805 0 R
-31 0 V
500 864 M
31 0 V
2805 0 R
-31 0 V
500 932 M
31 0 V
2805 0 R
-31 0 V
1.000 UL
LTa
500 964 M
2836 0 V
1.000 UL
LTb
500 964 M
63 0 V
2773 0 R
-63 0 V
1.000 UL
LTb
500 1064 M
31 0 V
2805 0 R
-31 0 V
500 1196 M
31 0 V
2805 0 R
-31 0 V
500 1264 M
31 0 V
2805 0 R
-31 0 V
1.000 UL
LTa
500 1296 M
2836 0 V
1.000 UL
LTb
500 1296 M
63 0 V
2773 0 R
-63 0 V
1.000 UL
LTb
500 1396 M
31 0 V
2805 0 R
-31 0 V
500 1528 M
31 0 V
2805 0 R
-31 0 V
500 1596 M
31 0 V
2805 0 R
-31 0 V
1.000 UL
LTa
500 1628 M
52 0 V
856 0 R
1928 0 V
1.000 UL
LTb
500 1628 M
63 0 V
2773 0 R
-63 0 V
1.000 UL
LTb
500 1728 M
31 0 V
2805 0 R
-31 0 V
500 1860 M
31 0 V
2805 0 R
-31 0 V
1.000 UL
LTa
500 300 M
0 1560 V
1.000 UL
LTb
500 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1.000 UL
LTa
672 300 M
0 1121 V
0 300 R
0 139 V
1.000 UL
LTb
672 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1.000 UL
LTa
844 300 M
0 1121 V
0 300 R
0 139 V
1.000 UL
LTb
844 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1.000 UL
LTa
1016 300 M
0 1121 V
0 300 R
0 139 V
1.000 UL
LTb
1016 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1.000 UL
LTa
1188 300 M
0 1121 V
0 300 R
0 139 V
1.000 UL
LTb
1188 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1.000 UL
LTa
1359 300 M
0 1121 V
0 300 R
0 139 V
1.000 UL
LTb
1359 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1.000 UL
LTa
1531 300 M
0 1560 V
1.000 UL
LTb
1531 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1.000 UL
LTa
1703 300 M
0 1560 V
1.000 UL
LTb
1703 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1.000 UL
LTa
1875 300 M
0 1560 V
1.000 UL
LTb
1875 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1.000 UL
LTa
2047 300 M
0 1560 V
1.000 UL
LTb
2047 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1.000 UL
LTa
2219 300 M
0 1560 V
1.000 UL
LTb
2219 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1.000 UL
LTa
2391 300 M
0 1560 V
1.000 UL
LTb
2391 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1.000 UL
LTa
2563 300 M
0 1560 V
1.000 UL
LTb
2563 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1.000 UL
LTa
2734 300 M
0 1560 V
1.000 UL
LTb
2734 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1.000 UL
LTa
2906 300 M
0 1560 V
1.000 UL
LTb
2906 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1.000 UL
LTa
3078 300 M
0 1560 V
1.000 UL
LTb
3078 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1.000 UL
LTa
3250 300 M
0 1560 V
1.000 UL
LTb
3250 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1.000 UL
LTb
500 300 M
2836 0 V
0 1560 V
-2836 0 V
500 300 L
LTb
LTb
LTb
0.900 UP
0.900 UP
1.000 UL
LT2
LTb
LT2
1102 1671 M
256 0 V
844 558 M
172 284 V
172 237 V
171 173 V
172 58 V
172 119 V
172 93 V
172 170 V
172 -26 V
172 12 V
844 558 Star
1016 842 Star
1188 1079 Star
1359 1252 Star
1531 1310 Star
1703 1429 Star
1875 1522 Star
2047 1692 Star
2219 1666 Star
2391 1678 Star
1230 1671 Star
0.900 UP
1.000 UL
LT3
LTb
LT3
1102 1571 M
256 0 V
844 300 M
172 281 V
172 194 V
171 108 V
172 121 V
172 86 V
172 57 V
172 76 V
172 43 V
172 97 V
172 57 V
171 46 V
172 0 V
172 100 V
172 42 V
844 300 Box
1016 581 Box
1188 775 Box
1359 883 Box
1531 1004 Box
1703 1090 Box
1875 1147 Box
2047 1223 Box
2219 1266 Box
2391 1363 Box
2563 1420 Box
2734 1466 Box
2906 1466 Box
3078 1566 Box
3250 1608 Box
1230 1571 Box
0.900 UP
1.000 UL
LT5
LTb
LT5
1102 1471 M
256 0 V
1016 400 M
172 58 V
171 250 V
172 44 V
172 69 V
172 34 V
172 -6 V
172 83 V
172 125 V
172 105 V
171 52 V
172 -72 V
172 159 V
172 -51 V
1016 400 Circle
1188 458 Circle
1359 708 Circle
1531 752 Circle
1703 821 Circle
1875 855 Circle
2047 849 Circle
2219 932 Circle
2391 1057 Circle
2563 1162 Circle
2734 1214 Circle
2906 1142 Circle
3078 1301 Circle
3250 1250 Circle
1230 1471 Circle
1.000 UL
LTb
500 300 M
2836 0 V
0 1560 V
-2836 0 V
500 300 L
0.900 UP
stroke
grestore
end
showpage
}}\put(1052,1471){\rjust{r=2, f=0.7}}\put(1052,1571){\rjust{r=2, f=0.5}}\put(1052,1671){\rjust{r=2, f=0.3}}\put(1918,2010){\cjust{Scalability analysis}}\put(1918,50){\cjust{Automata size}}\put(100,1080){\special{ps: gsave currentpoint currentpoint translate
270 rotate neg exch neg exch translate}\cstack{Median execution time (s)}\special{ps: currentpoint grestore moveto}}\put(3250,200){\cjust{ 160}}\put(3078,200){\cjust{ 150}}\put(2906,200){\cjust{ 140}}\put(2734,200){\cjust{ 130}}\put(2563,200){\cjust{ 120}}\put(2391,200){\cjust{ 110}}\put(2219,200){\cjust{ 100}}\put(2047,200){\cjust{ 90}}\put(1875,200){\cjust{ 80}}\put(1703,200){\cjust{ 70}}\put(1531,200){\cjust{ 60}}\put(1359,200){\cjust{ 50}}\put(1188,200){\cjust{ 40}}\put(1016,200){\cjust{ 30}}\put(844,200){\cjust{ 20}}\put(672,200){\cjust{ 10}}\put(500,200){\cjust{ 0}}\put(450,1628){\rjust{ 100}}\put(450,1296){\rjust{ 10}}\put(450,964){\rjust{ 1}}\put(450,632){\rjust{ 0.1}}\put(450,300){\rjust{ 0.01}}\endGNUPLOTpicture
\endgroup
%
 }
    \caption{\protect\parbox[t]{40mm}{Median time to check universality (of $100$ automata for each sample point).}}
    \label{fig:scalability}
 \end{minipage} \hfill 
 \begin{minipage}[b]{.47\linewidth}
    \scalebox{0.5}{\begingroup
  \catcode`\@=11\relax
  \def\GNUPLOTspecial{\def\do##1{\catcode`##1=12\relax}\dospecials
    \catcode`\{=1\catcode`\}=2\catcode\%=14\relax\special}\expandafter\ifx\csname GNUPLOTpicture\endcsname\relax
  \csname newdimen\endcsname\GNUPLOTunit
  \gdef\GNUPLOTpicture(#1,#2){\vbox to#2\GNUPLOTunit\bgroup
    \def\put(##1,##2)##3{\unskip\raise##2\GNUPLOTunit
      \hbox to0pt{\kern##1\GNUPLOTunit ##3\hss}\ignorespaces}\def\ljust##1{\vbox to0pt{\vss\hbox to0pt{##1\hss}\vss}}\def\cjust##1{\vbox to0pt{\vss\hbox to0pt{\hss ##1\hss}\vss}}\def\rjust##1{\vbox to0pt{\vss\hbox to0pt{\hss ##1}\vss}}\def\stack##1{\let\\=\cr\tabskip=0pt\halign{\hfil ####\hfil\cr ##1\crcr}}\def\lstack##1{\hbox to0pt{\vbox to0pt{\vss\stack{##1}}\hss}}\def\cstack##1{\hbox to0pt{\hss\vbox to0pt{\vss\stack{##1}}\hss}}\def\rstack##1{\hbox to0pt{\vbox to0pt{\stack{##1}\vss}\hss}}\vss\hbox to#1\GNUPLOTunit\bgroup\ignorespaces}\gdef\endGNUPLOTpicture{\hss\egroup\egroup}\fi
\GNUPLOTunit=0.1bp
\GNUPLOTpicture(3600,2160)
{\GNUPLOTspecial{"
/gnudict 256 dict def
gnudict begin
/Color false def
/Solid false def
/gnulinewidth 5.000 def
/userlinewidth gnulinewidth def
/vshift -33 def
/dl {10.0 mul} def
/hpt_ 31.5 def
/vpt_ 31.5 def
/hpt hpt_ def
/vpt vpt_ def
/Rounded false def
/M {moveto} bind def
/L {lineto} bind def
/R {rmoveto} bind def
/V {rlineto} bind def
/N {newpath moveto} bind def
/C {setrgbcolor} bind def
/f {rlineto fill} bind def
/vpt2 vpt 2 mul def
/hpt2 hpt 2 mul def
/Lshow { currentpoint stroke M
  0 vshift R show } def
/Rshow { currentpoint stroke M
  dup stringwidth pop neg vshift R show } def
/Cshow { currentpoint stroke M
  dup stringwidth pop -2 div vshift R show } def
/UP { dup vpt_ mul /vpt exch def hpt_ mul /hpt exch def
  /hpt2 hpt 2 mul def /vpt2 vpt 2 mul def } def
/DL { Color {setrgbcolor Solid {pop []} if 0 setdash }
 {pop pop pop 0 setgray Solid {pop []} if 0 setdash} ifelse } def
/BL { stroke userlinewidth 2 mul setlinewidth
      Rounded { 1 setlinejoin 1 setlinecap } if } def
/AL { stroke userlinewidth 2 div setlinewidth
      Rounded { 1 setlinejoin 1 setlinecap } if } def
/UL { dup gnulinewidth mul /userlinewidth exch def
      dup 1 lt {pop 1} if 10 mul /udl exch def } def
/PL { stroke userlinewidth setlinewidth
      Rounded { 1 setlinejoin 1 setlinecap } if } def
/LTw { PL [] 1 setgray } def
/LTb { BL [] 0 0 0 DL } def
/LTa { AL [1 udl mul 2 udl mul] 0 setdash 0 0 0 setrgbcolor } def
/LT0 { PL [] 1 0 0 DL } def
/LT1 { PL [4 dl 2 dl] 0 1 0 DL } def
/LT2 { PL [2 dl 3 dl] 0 0 1 DL } def
/LT3 { PL [1 dl 1.5 dl] 1 0 1 DL } def
/LT4 { PL [5 dl 2 dl 1 dl 2 dl] 0 1 1 DL } def
/LT5 { PL [4 dl 3 dl 1 dl 3 dl] 1 1 0 DL } def
/LT6 { PL [2 dl 2 dl 2 dl 4 dl] 0 0 0 DL } def
/LT7 { PL [2 dl 2 dl 2 dl 2 dl 2 dl 4 dl] 1 0.3 0 DL } def
/LT8 { PL [2 dl 2 dl 2 dl 2 dl 2 dl 2 dl 2 dl 4 dl] 0.5 0.5 0.5 DL } def
/Pnt { stroke [] 0 setdash
   gsave 1 setlinecap M 0 0 V stroke grestore } def
/Dia { stroke [] 0 setdash 2 copy vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath stroke
  Pnt } def
/Pls { stroke [] 0 setdash vpt sub M 0 vpt2 V
  currentpoint stroke M
  hpt neg vpt neg R hpt2 0 V stroke
  } def
/Box { stroke [] 0 setdash 2 copy exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V closepath stroke
  Pnt } def
/Crs { stroke [] 0 setdash exch hpt sub exch vpt add M
  hpt2 vpt2 neg V currentpoint stroke M
  hpt2 neg 0 R hpt2 vpt2 V stroke } def
/TriU { stroke [] 0 setdash 2 copy vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath stroke
  Pnt  } def
/Star { 2 copy Pls Crs } def
/BoxF { stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V  hpt2 0 V  0 vpt2 V
  hpt2 neg 0 V  closepath fill } def
/TriUF { stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath fill } def
/TriD { stroke [] 0 setdash 2 copy vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath stroke
  Pnt  } def
/TriDF { stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath fill} def
/DiaF { stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath fill } def
/Pent { stroke [] 0 setdash 2 copy gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath stroke grestore Pnt } def
/PentF { stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath fill grestore } def
/Circle { stroke [] 0 setdash 2 copy
  hpt 0 360 arc stroke Pnt } def
/CircleF { stroke [] 0 setdash hpt 0 360 arc fill } def
/C0 { BL [] 0 setdash 2 copy moveto vpt 90 450  arc } bind def
/C1 { BL [] 0 setdash 2 copy        moveto
       2 copy  vpt 0 90 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C2 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 90 180 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C3 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 0 180 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C4 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 180 270 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C5 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 0 90 arc
       2 copy moveto
       2 copy  vpt 180 270 arc closepath fill
               vpt 0 360 arc } bind def
/C6 { BL [] 0 setdash 2 copy moveto
      2 copy  vpt 90 270 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C7 { BL [] 0 setdash 2 copy moveto
      2 copy  vpt 0 270 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C8 { BL [] 0 setdash 2 copy moveto
      2 copy vpt 270 360 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C9 { BL [] 0 setdash 2 copy moveto
      2 copy  vpt 270 450 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C10 { BL [] 0 setdash 2 copy 2 copy moveto vpt 270 360 arc closepath fill
       2 copy moveto
       2 copy vpt 90 180 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C11 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 0 180 arc closepath fill
       2 copy moveto
       2 copy  vpt 270 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C12 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 180 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C13 { BL [] 0 setdash  2 copy moveto
       2 copy  vpt 0 90 arc closepath fill
       2 copy moveto
       2 copy  vpt 180 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C14 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 90 360 arc closepath fill
               vpt 0 360 arc } bind def
/C15 { BL [] 0 setdash 2 copy vpt 0 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/Rec   { newpath 4 2 roll moveto 1 index 0 rlineto 0 exch rlineto
       neg 0 rlineto closepath } bind def
/Square { dup Rec } bind def
/Bsquare { vpt sub exch vpt sub exch vpt2 Square } bind def
/S0 { BL [] 0 setdash 2 copy moveto 0 vpt rlineto BL Bsquare } bind def
/S1 { BL [] 0 setdash 2 copy vpt Square fill Bsquare } bind def
/S2 { BL [] 0 setdash 2 copy exch vpt sub exch vpt Square fill Bsquare } bind def
/S3 { BL [] 0 setdash 2 copy exch vpt sub exch vpt2 vpt Rec fill Bsquare } bind def
/S4 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt Square fill Bsquare } bind def
/S5 { BL [] 0 setdash 2 copy 2 copy vpt Square fill
       exch vpt sub exch vpt sub vpt Square fill Bsquare } bind def
/S6 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill Bsquare } bind def
/S7 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill
       2 copy vpt Square fill
       Bsquare } bind def
/S8 { BL [] 0 setdash 2 copy vpt sub vpt Square fill Bsquare } bind def
/S9 { BL [] 0 setdash 2 copy vpt sub vpt vpt2 Rec fill Bsquare } bind def
/S10 { BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt Square fill
       Bsquare } bind def
/S11 { BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt2 vpt Rec fill
       Bsquare } bind def
/S12 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill Bsquare } bind def
/S13 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill
       2 copy vpt Square fill Bsquare } bind def
/S14 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill
       2 copy exch vpt sub exch vpt Square fill Bsquare } bind def
/S15 { BL [] 0 setdash 2 copy Bsquare fill Bsquare } bind def
/D0 { gsave translate 45 rotate 0 0 S0 stroke grestore } bind def
/D1 { gsave translate 45 rotate 0 0 S1 stroke grestore } bind def
/D2 { gsave translate 45 rotate 0 0 S2 stroke grestore } bind def
/D3 { gsave translate 45 rotate 0 0 S3 stroke grestore } bind def
/D4 { gsave translate 45 rotate 0 0 S4 stroke grestore } bind def
/D5 { gsave translate 45 rotate 0 0 S5 stroke grestore } bind def
/D6 { gsave translate 45 rotate 0 0 S6 stroke grestore } bind def
/D7 { gsave translate 45 rotate 0 0 S7 stroke grestore } bind def
/D8 { gsave translate 45 rotate 0 0 S8 stroke grestore } bind def
/D9 { gsave translate 45 rotate 0 0 S9 stroke grestore } bind def
/D10 { gsave translate 45 rotate 0 0 S10 stroke grestore } bind def
/D11 { gsave translate 45 rotate 0 0 S11 stroke grestore } bind def
/D12 { gsave translate 45 rotate 0 0 S12 stroke grestore } bind def
/D13 { gsave translate 45 rotate 0 0 S13 stroke grestore } bind def
/D14 { gsave translate 45 rotate 0 0 S14 stroke grestore } bind def
/D15 { gsave translate 45 rotate 0 0 S15 stroke grestore } bind def
/DiaE { stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath stroke } def
/BoxE { stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V closepath stroke } def
/TriUE { stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath stroke } def
/TriDE { stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath stroke } def
/PentE { stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath stroke grestore } def
/CircE { stroke [] 0 setdash 
  hpt 0 360 arc stroke } def
/Opaque { gsave closepath 1 setgray fill grestore 0 setgray closepath } def
/DiaW { stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V Opaque stroke } def
/BoxW { stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V Opaque stroke } def
/TriUW { stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V Opaque stroke } def
/TriDW { stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V Opaque stroke } def
/PentW { stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  Opaque stroke grestore } def
/CircW { stroke [] 0 setdash 
  hpt 0 360 arc Opaque stroke } def
/BoxFill { gsave Rec 1 setgray fill grestore } def
/BoxColFill {
  gsave Rec
  /Fillden exch def
  currentrgbcolor
  /ColB exch def /ColG exch def /ColR exch def
  /ColR ColR Fillden mul Fillden sub 1 add def
  /ColG ColG Fillden mul Fillden sub 1 add def
  /ColB ColB Fillden mul Fillden sub 1 add def
  ColR ColG ColB setrgbcolor
  fill grestore } def
/PatternFill { gsave /PFa [ 9 2 roll ] def
    PFa 0 get PFa 2 get 2 div add PFa 1 get PFa 3 get 2 div add translate
    PFa 2 get -2 div PFa 3 get -2 div PFa 2 get PFa 3 get Rec
    gsave 1 setgray fill grestore clip
    currentlinewidth 0.5 mul setlinewidth
    /PFs PFa 2 get dup mul PFa 3 get dup mul add sqrt def
    0 0 M PFa 5 get rotate PFs -2 div dup translate
	0 1 PFs PFa 4 get div 1 add floor cvi
	{ PFa 4 get mul 0 M 0 PFs V } for
    0 PFa 6 get ne {
	0 1 PFs PFa 4 get div 1 add floor cvi
	{ PFa 4 get mul 0 2 1 roll M PFs 0 V } for
    } if
    stroke grestore } def
/Symbol-Oblique /Symbol findfont [1 0 .167 1 0 0] makefont
dup length dict begin {1 index /FID eq {pop pop} {def} ifelse} forall
currentdict end definefont pop
end
gnudict begin
gsave
0 0 translate
0.100 0.100 scale
0 setgray
newpath
1.000 UL
LTb
1.000 UL
LTa
150 1340 M
2836 0 V
1.000 UL
LTb
150 1340 M
63 0 V
2773 0 R
-63 0 V
1.000 UL
LTb
1.000 UL
LTa
150 820 M
2836 0 V
1.000 UL
LTb
150 820 M
63 0 V
2773 0 R
-63 0 V
1.000 UL
LTb
150 300 M
0 31 V
0 1529 R
0 -31 V
223 300 M
0 31 V
0 1529 R
0 -31 V
285 300 M
0 31 V
0 1529 R
0 -31 V
338 300 M
0 31 V
0 1529 R
0 -31 V
385 300 M
0 31 V
0 1529 R
0 -31 V
1.000 UL
LTa
427 300 M
0 1560 V
1.000 UL
LTb
427 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
705 300 M
0 31 V
0 1529 R
0 -31 V
867 300 M
0 31 V
0 1529 R
0 -31 V
982 300 M
0 31 V
0 1529 R
0 -31 V
1071 300 M
0 31 V
0 1529 R
0 -31 V
1144 300 M
0 31 V
0 1529 R
0 -31 V
1206 300 M
0 31 V
0 1529 R
0 -31 V
1259 300 M
0 31 V
0 1529 R
0 -31 V
1306 300 M
0 31 V
0 1529 R
0 -31 V
1.000 UL
LTa
1348 300 M
0 1560 V
1.000 UL
LTb
1348 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1626 300 M
0 31 V
0 1529 R
0 -31 V
1788 300 M
0 31 V
0 1529 R
0 -31 V
1903 300 M
0 31 V
0 1529 R
0 -31 V
1992 300 M
0 31 V
0 1529 R
0 -31 V
2065 300 M
0 31 V
0 1529 R
0 -31 V
2127 300 M
0 31 V
0 1529 R
0 -31 V
2180 300 M
0 31 V
0 1529 R
0 -31 V
2227 300 M
0 31 V
0 1529 R
0 -31 V
1.000 UL
LTa
2269 300 M
0 1280 V
0 200 R
0 80 V
1.000 UL
LTb
2269 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
2547 300 M
0 31 V
0 1529 R
0 -31 V
2709 300 M
0 31 V
0 1529 R
0 -31 V
2824 300 M
0 31 V
0 1529 R
0 -31 V
2913 300 M
0 31 V
0 1529 R
0 -31 V
2986 300 M
0 31 V
0 1529 R
0 -31 V
1.000 UL
LTb
150 300 M
2836 0 V
0 1560 V
-2836 0 V
150 300 L
LTb
LTb
0.900 UP
0.900 UP
1.000 UL
LT2
LTb
LT2
1814 820 Star
1348 820 Star
1561 820 Star
1681 820 Star
1882 820 Star
2051 820 Star
1206 820 Star
1872 820 Star
1730 820 Star
2218 820 Star
1605 820 Star
1967 820 Star
1992 820 Star
2097 820 Star
1664 820 Star
1746 820 Star
427 820 Star
427 820 Star
705 820 Star
1664 820 Star
2044 820 Star
1893 820 Star
1306 820 Star
2143 820 Star
2257 820 Star
2072 820 Star
2109 820 Star
2154 820 Star
2000 820 Star
1730 820 Star
427 820 Star
2257 820 Star
982 820 Star
1386 820 Star
1386 820 Star
1453 820 Star
2336 820 Star
2304 820 Star
427 820 Star
1861 820 Star
1922 820 Star
1386 820 Star
1583 820 Star
1626 820 Star
1746 820 Star
1605 820 Star
2227 820 Star
1605 820 Star
1730 820 Star
2000 820 Star
1510 820 Star
2837 1730 Star
0.900 UP
1.000 UL
LT3
LTb
LT3
1536 1340 Box
427 1340 Box
1814 1340 Box
1826 1340 Box
1967 1340 Box
1206 1340 Box
2160 1340 Box
1583 1340 Box
1760 1340 Box
1950 1340 Box
1715 1340 Box
1536 1340 Box
2132 1340 Box
1882 1340 Box
2249 1340 Box
1992 1340 Box
2336 1340 Box
1483 1340 Box
1626 1340 Box
1922 1340 Box
1536 1340 Box
2730 1340 Box
1932 1340 Box
867 1340 Box
1561 1340 Box
1483 1340 Box
982 1340 Box
1626 1340 Box
2285 1340 Box
2261 1340 Box
2281 1340 Box
1306 1340 Box
1664 1340 Box
2495 1340 Box
2091 1340 Box
2023 1340 Box
2839 1340 Box
2383 1340 Box
1626 1340 Box
2121 1340 Box
1144 1340 Box
2837 1630 Box
1.000 UL
LTb
150 300 M
2836 0 V
0 1560 V
-2836 0 V
150 300 L
0.900 UP
stroke
grestore
end
showpage
}}\put(2659,1630){\rjust{Not Universal}}\put(2659,1730){\rjust{Universal}}\put(1568,2010){\cjust{f=2.2, r=0.5}}\put(1568,50){\cjust{Execution time (s)}}\put(2269,200){\cjust{ 1}}\put(1348,200){\cjust{ 0.1}}\put(427,200){\cjust{ 0.01}}\endGNUPLOTpicture
\endgroup
%
 }
    \caption{\protect\parbox[t]{40mm}{Execution time to check universality of 100 automata, 57 of which were universal.}}
    \label{fig:distribution}
 \end{minipage}
\end{figure}










\section{Language Inclusion for B\"uchi automata}\label{sec:inclusion-NBW}


Let $\A_1 = \tuple{\Loc_1, \iota_1, \Sigma, \delta_1, \alpha_1}$ and $\A_2$ 
be two NBW defined on the same alphabet $\Sigma$ for which we want
to check language inclusion: $\L(\A_1) \subseteq^? \L(\A_2)$. To solve
this problem, we check emptiness of $\L(\A_1) \cap \L^c(\A_2)$. 
As we have seen, we can use the Kupferman-Vardi and Miyano-Hayashi construction
to specify a NBW $\A_2^c = \tuple{\Loc_2, \iota_2, \Sigma, \delta_2, \alpha_2}$ 
that accepts the complement of the language of $\A_2$.

Using the classical product construction, let $\B = \A_1 \times \A_2^c$ be a finite automaton
with set of locations $\Loc_{\B} = \Loc_1 \times \Loc_2$, initial state 
$\iota_{\B} = (\iota_1, \iota_2)$, and transition function $\delta_{\B}$ such that 
$\delta_{\B}((\l_1, \l_2), \sigma) = \delta_1(\l_1,\sigma) \times \delta_2(\l_2,\sigma)$.
We equip $\B$ with the generalized B\"uchi condition 
$\{\beta_1,\beta_2\} = \{\alpha_1 \times \Loc_2, \Loc_1 \times \alpha_2\}$, thus asking 
for a run of $\B$ to be accepting that it visits $\beta_1$ and $\beta_2$
infinitely often. It is routine to show that we have $\L(\B) = \L(\A_1) \cap \L(\A_2^c)$. 
The following fixed point
$$\F'_{\B} \equiv \nu y \cdot \Big( 
		\mu x_1 \cdot \big[ \Pre^{\B}(x_1) \cup ( \Pre^{\B}(y) \cap \beta_1 ) \big] \cap
		\mu x_2 \cdot \big[ \Pre^{\B}(x_2) \cup ( \Pre^{\B}(y) \cap \beta_2 ) \big]
	\Big)
$$
\noindent
can be used to check emptiness of $\B$ as we have $\L(\B) \neq \emptyset$ 
iff $\iota_{\B} \in \F'_{\B}$.  
We now define the pre-order $\preceq_{{\sf inc}}$ over the locations of $\B$: 
for all $(\l_1,\l_2),(\l_1',\l_2') \in \Loc_{\B}$, 
let $(\l_1,\l_2) \preceq_{{\sf inc}} (\l_1',\l_2')$ iff $\l_1 = \l'_1$ and 
$\l_2 \preceq_{{\sf univ}} \l_2'$. 


We extend the definition of simulation relation $\preceq$ (Definition~\ref{def:simulation})
to generalized B\"uchi automata $\B$ by asking that for each $\beta_i$, 
the relation~$\preceq$ is a simulation for $\B$ with accepting states $\beta_i$.

\begin{lem}
The relation $\preceq_{{\sf inc}}$ is a simulation for $\B$.
\end{lem} 

\proof 
First, observe that equality is a simulation relation for $\A_1$. Then, the
first condition of Definition~\ref{def:simulation} is a direct consequence
of the fact that equality (resp. $\preceq_{{\sf univ}}$) is a simulation 
relation for $\A_1$ (resp. for $\A_2^c$), and that $\B = \A_1 \times \A_2^c$ 
is the product of these automata.
Second, it is easy to see that the sets $\beta_1$ and $\beta_2$ are 
$\preceq_{{\sf inc}}$-closed.
\qed

As a consequence of the last lemma, we know that all sets that we
have to manipulate to solve the language inclusion problem using the
fixed point $\F'_{\B}$ are $\preceq_{{\sf inc}}$-closed. The operators
$\cup$, $\cap$ and $\Pre$ can be thus computed efficiently, using the same 
algorithms and data structures as for universality. In particular, let 
$\Pre^{{\sf inc}}_\sigma(\l_1',\l_2') = \Pre^{\A_1}_\sigma(\l_1')
 \times
 \Pre^{{\sf univ}}_\sigma(\l_2')
$
where
$\Pre^{{\sf univ}}_{\sigma}$ is computed by Algorithm~2 (with input $\A_2$).
It is easy to show as a corollary of Theorem~\ref{theo:correctness-alg-pre} that 
$\closure{\Pre^{{\sf inc}}_\sigma(\l_1',\l_2')} = \Pre^{\B}_{\sigma}(\closure{\{(\l_1',\l_2')\}})$.


\section{Conclusion}\label{sec:conclusion}

We have shown that the prohibitive complementation constructions
for nondeterministic B\"uchi automata can be avoided for solving 
classical problems like universality and language inclusion. 
Our approach is based on fixed points computation and the existence of simulation relations 
for the (exponential) constructions used in complementation of 
B\"uchi automata. Those simulations are used to dramatically 
reduce the amount of computations needed to decide classical problems.
Their definition relies on the structure of the original automaton
and do not require explicit complementation. 

The resulting algorithms evaluate a fixed point formula and avoid
redundant computations by maintaining sets of maximal elements
according to the simulation relation. In practice, the computation of
the predecessor operator, which is the key of the approach, is
efficient because it is done on antichains of elements only. Even though
the classical approaches (as well as ours) have the same worst case
complexity, our prototype implementation outperforms those approaches
where the structural properties of the complement automaton (witnessed by the 
existence of simulation relations) is not exploited. The huge gap of performances holds
over the entire parameter space of the randomized model proposed by
Tabakov and Vardi.

Applications of this paper go beyond universality and language inclusion 
for NBW, as we have shown that the methodology applies to alternating 
B\"uchi automata for which efficient translations from LTL formula are 
known~\cite{GastinOddoux}. Significant improvements in the model-checking 
and satisfiability problem of LTL can be achieved with the same ideas~\cite{DDMR08a,DDMR08c}.


\paragraph{{\bf Acknowledgment.}} We thank two anonymous reviewers for helpful 
comments and suggestions.




\bibliography{biblio}
\bibliographystyle{alpha}


\iffalse
\begin{thebibliography}{DDHR06]}

\bibitem[BL69]{buechi69}
J.~Richard B{\"u}chi and Lawrence~H. Landweber.
\newblock Definability in the monadic second-order theory of successor.
\newblock {\em J. Symb. Log.}, 34(2):166--170, 1969.



\bibitem[DDHR06]{cav06}
M. {De Wulf}, L. Doyen, T.~A. Henzinger, and J.-F. Raskin.
\newblock Antichains: A new algorithm for checking universality of finite
  automata. \newblock In {\em Proceedings of CAV 2006}, {\em LNCS} 4144, pp. 17--30. Springer.



\bibitem[DR06]{TR-DR}
L. Doyen and J.-F. Raskin.
\newblock Improved Algorithms for the Automata-Based Approach to Model-Checking (extended version)
\newblock Tech. Rep.~76, U.L.B. -- Federated Center in Verification, 2006.
\newblock http://www.ulb.ac.be/di/ssd/cfv/publications.html.


\bibitem[EWS05]{simulations}
K. Etessami, T. Wilke, and R.~A. Schuller.
\newblock Fair simulation relations, parity games, and state space reduction
  for bu"chi automata.
\newblock {\em SIAM J. Comput.}, 34(5):1159--1175, 2005.

\bibitem[GKSV03]{GurumurthyKSV03}
S. Gurumurthy, O. Kupferman, F. Somenzi, and M.~Y. Vardi.
\newblock On complementing nondeterministic b{\"u}chi automata.
\newblock In {\em Proc. of CHARME 2003}, {\em LNCS} 2860, pp. 96--110. Springer.

\bibitem[GO01]{GastinOddoux}
P. Gastin and D. Oddoux.
\newblock Fast {\sc LTL} to B{\"u}chi automata translation.
\newblock In {\em Proc. of CAV 2001}, {\em LNCS} 2102, pp. 53--65. Springer.

\bibitem[KV97]{kupferman97weak}
O. Kupferman and M.~Y. Vardi.
\newblock Weak alternating automata are not that weak.
\newblock In {\em Proceedings of {ISTCS}'97}, pp. 147--158. IEEE Computer Society Press.

\bibitem[MH84]{MiyanoH84}
Satoru Miyano and Takeshi Hayashi.
\newblock Alternating finite automata on omega-words.
\newblock In {\em CAAP}, pages 195--210, 1984.

\bibitem[Mic88]{Michel88}
Max Michel.
\newblock Complementation is more difficult with automata on infinite words.
\newblock CNET, Paris, 1988.

\bibitem[RH04]{spin}
Theo~C. Ruys and Gerard~J. Holzmann.
\newblock Advanced spin tutorial.
\newblock In {\em SPIN}, {\em LNCS} 2989, pp. 304--305. Springer, 2004.

\bibitem[Saf88]{Safra88}
Shmuel Safra.
\newblock On the complexity of $\omega$-automata.
\newblock In {\em Proc. of FOCS: Foundations of Computer Science}, pages
  319--327. IEEE, 1988.

\bibitem[SVW87]{SVW87}
A. P. Sistla, M. Y. Vardi and P. Wolper.
\newblock The Complementation Problem for B{\"u}chi Automata with Applications to Temporal Logic.
\newblock {\em Theor. Comput. Sci.}, 49:217--237, 1987.


\bibitem[Tab06]{talk-tabakov}
D. Tabakov.
\newblock Experimental evaluation of explicit and symbolic approaches to
  complementation of non-deterministic buechi automata.
\newblock {\em Talk at ``Games and Verification'' workshop, 
  Newton Institute for Math. Sciences}. July 2006.

\bibitem[TV05]{TabakovV05}
D. Tabakov and M.~Y. Vardi.
\newblock Experimental evaluation of classical automata constructions.
\newblock In {\em LPAR} 2005, {\em LNCS} 3835, pp. 396--411. Springer.

\bibitem[VW86]{vw86}
M.~Y. Vardi and P. Wolper.
\newblock An automata-theoretic approach to automatic program verification
  (prelim. report).
\newblock In {\em LICS} 1986, pp. 332--344. IEEE.

\bibitem[VW94]{vw94}
Moshe~Y. Vardi and Pierre Wolper.
\newblock Reasoning about infinite computations.
\newblock {\em Inf. Comput.}, 115(1):1--37, 1994.

\end{thebibliography}
\fi



\end{document} 
