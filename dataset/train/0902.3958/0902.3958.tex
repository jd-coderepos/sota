\documentclass{LMCS}

\overfullrule=2 pt

\usepackage{array}
\usepackage{epic, eepic}
\usepackage{amssymb,amsmath,stmaryrd}
\usepackage[ruled, vlined]{algorithm2e}
\usepackage{slashbox}

\usepackage{gastex,hyperref,enumerate}







\newcounter{compressEnum}
\renewcommand{\thecompressEnum}{}
\newenvironment{compressEnum}
{\setcounter{compressEnum}{0}}

{}

\newcommand{\itCompress}{\stepcounter{compressEnum}{(\thecompressEnum) }}



\def\frp#1{\ensuremath{\langle #1\rangle}}


\makeatletter

\let\c@lemm\c@theo
\let\c@coro\c@theo
\let\c@defi\c@theo
\let\c@assu\c@theo

\makeatother



\def\eodsymbol{\ensuremath\square}
\def\eopsymbol{\ensuremath\blacksquare}









\def\sg{\mathrel[\joinrel\mathrel[}
\def\sd{\mathrel]\joinrel\mathrel]}



\def\abs#1{\ensuremath{\lvert #1\rvert}}
\def\norm#1{\ensuremath{\lVert #1\rVert}}
\def\normeinf#1{\ensuremath{\lVert #1\rVert_{\infty}}}

\newcommand{\pre}{\mathsf{pre}}
\newcommand{\cpre}[2]{\mathsf{Cpre}_{#1}^{#2}}
\newcommand{\cprestar}[1]{\mathsf{Cpre}_{#1}^*}
\newcommand{\Post}{\mathsf{Post}}
\newcommand{\Pre}{\mathsf{Pre}}
\newcommand{\CPre}{\mathsf{CPre}}

\newcommand{\nat}{\mathbb N} 
\newcommand{\sposrat}{{\mathbb Q}^{> 0}}
\newcommand{\posrat}{{\mathbb Q}^{\geq 0}}
\newcommand{\posreal}{{\mathbb R}^{\geq 0}}
\newcommand{\sposreal}{{\mathbb R}^{> 0}}
\newcommand{\real}{{\mathbb R}}
\newcommand{\zed}{{\mathbb Z}}

\newcommand{\closure}[1]{\downarrow \!\!#1}
\newcommand{\sem}[1]{\sg \mathrel{#1} \sd}

\newcommand{\ar}[1]{\lfloor \mathrel {#1} \rfloor}
\newcommand{\arup}[1]{\lceil \mathrel {#1} \rceil}
\newcommand{\bigar}[1]{\big\lfloor \!  \mathrel{#1}\!\! \big\rfloor}
\newcommand{\bigarup}[1]{\big\lceil \! \mathrel{#1}\!\! \big\rceil}
\newcommand{\bigarupL}{\big\lceil}
\newcommand{\bigarupR}{\big\rceil}
\newcommand{\Bigarup}[1]{\Big\lceil \! \mathrel{#1}\!\! \Big\rceil}


\renewcommand{\l}{{\ell}}

\newcommand{\Loc}{{\sf Loc}} 

\def\intp#1{\ensuremath{\lfloor #1\rfloor}}
\newcommand{\tuple}[1]{\langle #1 \rangle}

\newcommand{\last}{\mathsf{last}}
\renewcommand{\inf}{\mathsf{inf}}

\newcommand{\A}{\mathcal{A}}
\newcommand{\B}{\mathcal{B}}
\newcommand{\F}{\mathcal{F}}
\newcommand{\G}{{\mathcal{G}}}
\renewcommand{\L}{\mathcal{L}}
\newcommand{\N}{\mathcal{N}}
\newcommand{\W}{\mathcal{W}}

\newcommand{\DAG}{{\sc dag}}


\newcommand{\odd}{\mathsf{odd}}

\newcommand{\ceilOdd}[1]{\lceil \mathrel {#1} \rceil^{\mathsf{odd}}}
\newcommand{\ceilEven}[1]{\lceil \mathrel {#1} \rceil^{\mathsf{ even}}}
\newcommand{\true}{{\sf true}}
\newcommand{\false}{{\sf false}}

\newcommand{\MH}{{\sf MH}}
\newcommand{\KV}{{\sf KV}}
\newcommand{\KVMH}{{\sf KVMH}}
\newcommand{\Max}{{\sf Max}}


\def\doi{5 (1:5) 2009}
\lmcsheading {\doi}
{1--20}
{}
{}
{Aug.~13, 2007}
{Mar.~\phantom{0}2, 2009}
{}   

\begin{document}



\title[]{Antichains for the Automata-Based Approach to Model-Checking\rsuper*}

\author[L.~Doyen]{Laurent Doyen\rsuper a} \address{{\lsuper a}CCS,
  \'{E}cole Polytechnique F\'ed\'erale de Lausanne, Switzerland}
\email{laurent.doyen@epfl.ch}



\author[J.-F.~Raskin]{Jean-Fran\c{c}ois Raskin\rsuper b}	\address{{\lsuper b}CS, Universit\'{e} Libre de Bruxelles, Belgium}	\email{jraskin@ulb.ac.be}  


\keywords{alternating B\"uchi automata, nondeterministic B\"uchi automata, emptiness, universality, language inclusion, antichains.}
\subjclass{F.4.1, I.1.2}
\titlecomment{{\lsuper *}A preliminary version of this paper appeared in the
  \emph{Proceedings of the 13th International Conference on Tools and
    Algorithms for the Construction and Analysis of Systems} (TACAS),
  Lecture Notes in Computer Science 4424, Springer-Verlag, 2007,
  pp. 451-465.\\\indent This research was supported in part by the FRFC
  project ``Centre F\'ed\'er\'e en V\'erification'' funded by the
  Belgian National Science Foundation (FNRS) under grant nr 2.4530.02,
  by the PAI program Moves supported by the Belgian Federal
  Gouvernment: ``Fundamental Issues in Modelling, Verification and
  Evolution of Software'' ({\tt http://moves.vub.ac.be}), by the Swiss
  National Science Foundation, and by the European COMBEST project.  }




\begin{abstract}
  We propose and evaluate antichain algorithms to solve the universality and
  language inclusion problems for nondeterministic B\"uchi automata,
  and the emptiness problem for alternating B\"uchi automata.
  To obtain those algorithms, we establish the existence of
  simulation pre-orders that can be exploited to efficiently evaluate fixed
  points on the automata defined during the complementation step (that
  we keep implicit in our approach). We evaluate the performance of the
  algorithm to check the universality of B\"uchi automata
  using the random automaton model recently proposed by
  Tabakov and Vardi.  We show that on the difficult instances of this
  probabilistic model, our algorithm outperforms the standard ones by
  several orders of magnitude. 
\end{abstract} 

\maketitle

\section{Introduction}

In the automata-based approach to model-checking~\cite{vw86,vw94},
programs and properties are modeled by finite automata. Let  be a
finite automaton that models a program and let  be a finite
automaton that models a specification that the program should satisfy.
Correctness is defined by the language inclusion ,
that is all traces of the program (executions) should be traces of the
specification.  To solve the inclusion problem, the classical automata-theoretic 
solution constructs an automaton for  the complement of
the language of the automaton  and then checks
that  is empty (the later intersection being
computed as a synchronised product).  

In the finite case, the program and the specification are
automata over finite words (NFA) and the construction for the
complementation is conceptually simple: it is achieved by a classical
subset construction.  In the case of infinite words, the program and
(or at least) the specification are nondeterministic B\"uchi automata
(NBW). The NBW are also complementable; this was first proved
by B\"uchi~\cite{buechi62}.  However, the result is
much harder to obtain than in the case of NFA.  The original
construction of B\"uchi has a  worst case complexity (where~ 
is the size of the automaton to complement) which is not optimal.
In the late eighties Safra in~\cite{Safra88}, and later Kupferman and
Vardi in~\cite{kupferman97weak}, have given optimal complementation
procedures that have  complexity (see~\cite{Michel88} for the
lower bound).  While for finite words, the classical algorithm
has been implemented and shown practically usable, for infinite
words, the theoretically optimal solution is difficult to
implement and very few results are known about their practical
behavior. 
Recent implementations have shown that applying these algorithms for automata 
with more than around ten states is hard~\cite{TabakovV07,GurumurthyKSV03}.
Such sizes are clearly not sufficient in practice. 
As a consequence, tools like {\sc Spin}~\cite{spin} that
implement the automata-theoretic approach to model-checking ask
either that the complement of the specification is explicitly given
or they limit the specification to properties that are expressible in {\sc LTL}.

In this paper, we propose a new approach to check  
that can handle much larger B\"uchi automata. In a recent paper, 
we have shown that the classical subset construction can
be avoided and kept implicit for checking language inclusion and
language universality for NFA and their alternating extensions~\cite{cav06}. 
Here, we adapt and extend that technique to the more intricate case of
automata on infinite words.

To present the intuition behind our new techniques, let us consider a
simpler setting of the problem. Assume that we
are given a NBW  and we want to check if , that is to check if  is universal.  First,
remember that  is universal when its complement  is empty.  The
classical algorithm first complements  and then checks for
emptiness. The language of a NBW is nonempty if there exists an
infinite run of the automaton that visits accepting locations
infinitely often.  The existence of such a run can be established
in polynomial time by computing the following fixed point  where  is the predecessor
operator of the automaton (given a set  of locations it returns the
set of locations that can reach  in one step) and  is the set
of accepting locations of the automaton. The automaton is non-empty if
and only if its initial location is a member of the fixed
point .  This well-known algorithm is quadratic in the size of the automaton.  
Unfortunately, the automaton that accepts the language  is usually 
huge and the evaluation of the fixed point is unfeasible for all but the smallest 
specifications~.  To overcome this difficulty, we make the following observation:
if  is a \emph{simulation} pre-order on the locations of  
( means  can simulate ) which is compatible with
the accepting condition (if  and 
then ), then the sets that are computed during the
evaluation of  are all \emph{-downward-closed} (if an element
 is in the set then all  are also in the set). Then
-downward-closed sets can be represented by their -maximal elements 
and if operations on such sets can be computed directly on their representation, 
we have the ingredients to evaluate the fixed point in a more efficient way.
For an automaton~ over finite words, set inclusion would be a typical example 
of a simulation relation for~~\cite{cav06}. The same technique can be applied
to avoid subset constructions in games of imperfect information~\cite{DDR06,CDHR07}.
We generically call \emph{antichain algorithms} the techniques that are based
on compact representation of downward-closed because when the simulation
is a partial order (and it usually is), the maximal elements form an antichain,
i.e., a set of incomparable elements.


We show that the classical constructions for B\"uchi automata that are
used in the automata-theoretic approach to model-checking are all
equipped with a simulation pre-order that exists by construction and
does not need to be computed. On that basis we propose antichain algorithms
to check universality of NBW, language inclusion for NBW, and
emptiness of alternating B\"uchi automata (ABW). Each of these problems
reduces to emptiness checking of NBW, via classcial constructions.

The novelty of our antichain algorithms is to realize that only downward-closed
sets can be computed by the fixed point for emptiness, and therefore to use more 
succinct representations of those downward-closed sets, by storing maximal elements only. 
Moreover, such compact representations do not come at the price of an increase 
in the time complexity for the basic operations that are necessary to check emptiness
(such as , , and ), i.e., we show that they are computable in time
polynomial in the size of the compact representation, while this size can be exponentially
smaller than the actual downward-closed set.
Note that, while a compact representation exists in general (i.e., for any
simulation pre-order), we have no generic result that would show that efficient
computations can be done symbolically in all cases. Therefore, we have to instantiate
the approach for each class of problem, and find efficient algorithms for
the basic operations.






We evaluate an implementation of our algorithm for the
universality problem of NBW and on a randomized model recently
proposed by Tabakov and Vardi.  We show that the performance of the
antichain algorithm on this randomized model outperforms by several order of
magnitude the existing implementations of the Kupferman-Vardi
algorithm~\cite{TabakovV07,GurumurthyKSV03}.  While the classical
solution is limited to automata of size 8 for some parameter values of
the randomized model, we are able to handle automata with more than
one hundred locations for the same parameter values. We have
identified the hardest instances of the randomized model for our
algorithms and show that we can still handle problems with several
dozens of locations for those instances.

\paragraph{{\it Structure of the paper.}}
In Section~\ref{sec:definitions}, we give all necessary definitions related to 
B\"uchi automata, and we recall the Kupferman-Vardi and
Miyano-Hayashi constructions that are used for complementation of NBW.
The reader interested in the general theory behind our technique can read 
Section~\ref{sec:fixed-point} without going into the details of those constructions
(only the definitions of NBW and emptiness are useful to understand Section~\ref{sec:fixed-point}). 
The notion of simulation pre-order for a B\"uchi automaton is presented and we prove 
that the fixed point needed to establish emptiness of nondeterministic B\"uchi automata
handles only downward closed sets for such pre-orders. 
We use this observation in Section~\ref{sec:emptiness-alternating} to define an antichain algorithm
to decide emptiness of ABW. In Section~\ref{sec:universality}, we
adapt the technique for the universality problem of NBW. In
Section~\ref{sec:implementation}, we report on the performances of the
algorithm for universality, and in Section~\ref{sec:inclusion-NBW},
we extend those ideas to obtain an antichain algorithm for language inclusion
of NBW. 



\section{B\"uchi Automata and Classical Algorithms}\label{sec:definitions}


\begin{defi}\label{def:ABW}
An \emph{alternating B\"uchi automaton} (ABW) is a tuple 
 where: 

\begin{enumerate}[]

\item  is a finite set of states (or locations). 
The \emph{size} of  is ; 

\item  is the \emph{initial} state;

\item  is a finite \emph{alphabet};

\item  is the \emph{transition function} 
where  is the set of positive boolean formulas over , 
{\it i.e.} formulas built from elements in   
using the boolean connectives  and ; 

\item  is the set of accepting states.

\end{enumerate}
\end{defi}












We say that a set  \emph{satisfies} a
formula  (noted ) iff the
truth assignment that assigns  to the members of  and
assigns  to the members of  satisfies
.  A \emph{run} of  on an infinite word  is a \DAG\/  where:

\begin{enumerate}[]

\item  is the set of nodes. A node  represents the
state  after the first  letters of the word  have been read by . 
Nodes of the form  with  are called \emph{-nodes};

\item  is the root of the \DAG;

\item and  is such that \begin{compressEnum} 
\itCompress if  then  and 
\itCompress for every , the set  
satisfies the formula .
\end{compressEnum}
We say that  is a \emph{successor} of  if , 
and we say that  is \emph{reachable} from  if .

\end{enumerate}
\noindent
A run  of  on an infinite word  is
\emph{accepting} iff all its infinite paths  rooted at 
visit -nodes infinitely often.
An infinite word  is \emph{accepted} by~ if
there exists an accepting run on it. We denote by~ the set
of infinite words accepted by~, and by~  the set of infinite words that are not accepted by~.

\begin{defi}\label{def:NBW}
A \emph{nondeterministic B\"uchi automaton} (NBW) is an ABW whose
transition function is restricted to disjunctions over . 
\end{defi}

Runs of NBW reduce to (linear) traces.  The transition function of NBW is
often seen as a function  and we write
 instead of
. 
We note by  the set of \emph{predecessors} by  
of the set : . Let .



\paragraph{{\bf Problems}} 
The \emph{emptiness problem} for NBW is to decide, given an NBW ,
whether . This problem is solvable in
polynomial time. The symbolic approach through
fixed point computation is quadratic in the size of ~\cite{EmmersonLei86}.
Other symbolic approaches have been proposed with better complexity bounds~\cite{BloemGS00,GentiliniPP03}, 
but the fixed point computation shows better performances in practice~\cite{RaviBS00}.

The \emph{universality problem} for NBW is to decide, given an NBW
 over the alphabet  whether 
where  is the set of all infinite words on .
This problem is {\sc PSpace}-complete~\cite{SVW87}.  The classical algorithm to
decide universality is to first complement the NBW and then to check
emptiness of the complement. The difficult step is the complementation
as it may cause an exponential blow-up in the size of the automaton.
There exist two types of construction, one is based on a
determinization of the automaton~\cite{Safra88} and the other uses ABW
as an intermediate step~\cite{kupferman97weak}. We review the second 
construction below.

The \emph{language inclusion problem} for NBW is to decide, given two
NBW  and , whether . This
problem is central in model-checking and it is {\sc PSpace}-complete in the size of . 
The classical solution consists in checking the
emptiness of , which again requires the
expensive complementation of .

The \emph{emptiness problem} for ABW is to decide, given an ABW ,
whether . This problem is also {\sc
  PSpace}-complete and it can be solved using a translation from ABW
to NBW that preserves the language of the automaton~\cite{MiyanoH84}.
Again, this construction involves an exponential blow-up that makes
explicit implementations feasible only for automata limited to around
ten states. However, the emptiness problem for ABW is very important
in practice for LTL model-checking as there exist efficient polynomial
translations from LTL formulas to ABW~\cite{GastinOddoux}. The classical
construction is presented below.

\paragraph{{\bf Kupferman-Vardi construction}} 
Complementation of ABW is straightforward by dualizing the transition
function (by swapping  and , and swapping  and
 in each formulas) and interpreting the accepting condition
 as a co-B\"uchi condition, {\it i.e.} a run  is accepted
if all its infinite paths have a suffix that contains no -nodes.


The result is an alternating co-B\"uchi automaton (ACW). The accepting runs of
ACW have a layered structure that has been studied
in~\cite{kupferman97weak}, where the notion of \emph{rank} is
defined.  The rank is a nonnegative integer associated to each node of an accepting
run  of an ACW on a word .  Let . Nodes of rank 
are those nodes from which only finitely many nodes are reachable in
. Let  be the run  from which all nodes of rank 
have been removed. Then, nodes of rank  are those nodes of 
from which no -node is reachable in . For all , let
 be the run  from which all nodes of rank
 have been removed. Then, nodes of rank  are those
nodes of  from which only finitely many nodes are reachable in
, and nodes of rank  are those nodes of  from
which no -node is reachable in . Intuitively, the
rank of a node  hints how difficult it is to prove that all
the paths of  that start in  visit -nodes only
finitely many times. It can be shown that every node has a rank
between  and , and all -nodes
have an even rank~\cite{GurumurthyKSV03}. The layered structure of the 
runs of ACW induces a construction to complement ABW~\cite{kupferman97weak}. 
We present this construction directly for NBW. 

\begin{defi}[\cite{kupferman97weak}]\label{def:KV-construction}
Given a NBW  and an even number , let  be an ABW such that:

\begin{enumerate}[]
\item  where .
  Intuitively, the automaton  is in state 
  after the first  letters of the input word  have been read if
  it guesses that the rank of the node  in a run of  on
   is at most ;
\item ;
\item  

\medskip
\noindent For example, if , then 

\item  where  is the set of odd numbers in .
\end{enumerate}
\end{defi}

The ABW specified by the Kupferman-Vardi construction accepts the
complement language of  and its size is quadratic in the size of the
original automaton~.

\begin{thm}[\cite{kupferman97weak}]\label{theo:complement}
For all NBW , for all , we have  and 
for , we have .
\end{thm}



\paragraph{{\bf Miyano-Hayashi construction}}
Classically, to check emptiness of ABW, a variant 
of the subset construction is applied that transforms the ABW into a NBW 
that accepts the same language~\cite{MiyanoH84}. Intuitively, the NBW 
maintains a set  of states of the ABW that corresponds to a whole
level of a guessed run \DAG\/ of the ABW. In addition, the NBW maintains
a set  of states that ``owe'' a visit to an accepting state. Whenever
the set  gets empty, meaning that every path of the guessed run has visited
at least one accepting state, the set  is initiated with the current
level of the guessed run. It is asked that  gets empty infinitely often
in order to ensure that every path of the run \DAG\/ visits accepting states
infinitely often. The construction is as follows.

\begin{defi}[\cite{MiyanoH84}]\label{def:MH-construction}
Given an ABW , define  as the NBW  where
 and  is defined,
for all  and , as follows:

\begin{enumerate}[] 

\item If , then


\item If , then .
\end{enumerate} 

\end{defi}

The size of the Miyano-Hayashi construction is exponential in the 
size of the original automaton. 

\begin{thm}[\cite{MiyanoH84}]\label{theo:subset-construction}
For all ABW , we have .
\end{thm}

The size of the automaton obtained after the Kupferman-Vardi
and the Miyano-Hayashi construction is an obstacle to the
direct implementation of the method.  


\paragraph{{\bf Direct complementation}}\label{sec:direct-complementation}
In our solution, we \emph{implicitly} use the two constructions to
complement B\"uchi automata but, as we will see, we do not construct
the automata. For the sake of clarity, we give below the
specification of the automaton that would result from the composition of
the two constructions. In the definition of the state space, we omit the
states  for  and  odd, as those states have no 
successor in the Kupferman-Vardi construction.
 


\begin{defi}\label{def:direct-complementation}
Given a NBW  
and an even number , let 
 be a NBW such that:
\begin{enumerate}[] 
\item  where
 is the set of odd natural numbers;
\item ;
\item Let ;  is defined for all  and 
, as follows:
\begin{enumerate}[] 
\item If , then  is the set of pairs  such that:
	\begin{enumerate}[] 
	\item ; 
	\item ;
\item .
\end{enumerate}
\item If , then  is the set of pairs  such that:
	\begin{enumerate}[]
	\item[] .
	\end{enumerate}
\end{enumerate} 
\item ;
\end{enumerate} 
\end{defi}

 We write  to 
denote .

\begin{thm}[\cite{kupferman97weak,MiyanoH84}]\label{theo:direct-complement}
For every NBW  and
for all , we have .  In case of , we
also have .
\end{thm}

In the sequel, we denote by  the automaton ,
and we denote by  its set of states (we omit the subscript ).

\section{Simulation Pre-Orders and Fixed Points}\label{sec:fixed-point}

Let  be a NBW.  Let
 be the
powerset lattice of locations. The fixed point formula

can be used to check emptiness of  as we have  iff .
Intuitively, the greatest fixed point  in  computes in the
-th iteration the set of states from which  accepting states can be visited
with some word. When this set stabilizes, infinitely many visits to an accepting
state are possible.


We show in this section that a certain structural property of the NBW
is tightly correlated to the structure of the sets that are computed by the 
fixed point . The key property is the notion of simulation relation
for finite automata. Let  be a pre-order and let  iff  and .

\begin{defi}\label{def:simulation}
  A pre-order  is a \emph{simulation} for  iff the following
  properties hold:
  \begin{enumerate}[]
    
    \item for all , for all , if
     and  then there exists
     such that  and  (see illustration in \figurename~\ref{fig:simulation});

    \item for all , for all , if  
     then .

  \end{enumerate}
\end{defi}

\begin{figure}[!tb]
  \unitlength=.8mm
\def\fsize{\normalsize}

\hrule
\begin{picture}(160,46)(0,0)



{\fsize

\node[Nmarks=n](q1)(20,38){}
\node[Nmarks=n](q2)(60,38){}
\node[Nmarks=n](q3)(20,8){}
\node[Nframe=n](dummy)(5,23){If}
\node[Nframe=n, Nadjust=wh, Nadjustdist=2.2](dummy)(20,23){\rotatebox{90}{}}


\node[Nmarks=n](r2)(150,38){}
\node[Nmarks=n](r3)(110,8){}
\node[Nmarks=n](r4)(150,8){}
\node[Nframe=n](eummy)(83,23){then}
\node[Nframe=n, Nadjust=wh, Nadjustdist=2.2](eummy)(150,23){\rotatebox{90}{}}




\drawedge[ELpos=50, ELside=l, ELdist=1, curvedepth=0](q1,q2){}
\drawedge[ELpos=50, ELside=l, ELdist=1, curvedepth=0](r3,r4){}

\drawedge[dash={1}0, ELpos=50, ELside=l, ELdist=1, curvedepth=0, AHnb=0](q1,dummy){}
\drawedge[dash={1}0, ELpos=50, ELside=l, ELdist=1, curvedepth=0, AHnb=0](q3,dummy){}

\drawedge[dash={1}0, ELpos=50, ELside=l, ELdist=1, curvedepth=0, AHnb=0](r2,eummy){}
\drawedge[dash={1}0, ELpos=50, ELside=l, ELdist=1, curvedepth=0, AHnb=0](r4,eummy){}









}
\end{picture}
\hrule


 \caption{Simulation (Definition~\ref{def:simulation}).}
  \label{fig:simulation}
\end{figure}
  
\paragraph{{\bf Downward-closed sets}} A set  is \emph{-closed} iff for all
, if  and  then . The \emph{-closure} of , is the set .  We denote by 
 the set of \emph{-maximal} elements of : 
. 
For any -closed set , we have 
. Furthermore, if  is a partial order, 
then  is an \emph{antichain} of elements and it can serve as a canonical 
representation of~. 

Our goal is to show that the operators involved in the fixed
point formula  preserve -closedness. This is
true for union and intersection, for all relations .

\begin{lem}\label{lem:closure-properties-a}
  For all relations , for all -closed sets ,
  the sets  and  are -closed.
\end{lem}
 
The next lemma shows that simulation relations are necessary (and also sufficient) to
guarantee preservation of -closedness under the  operator.
Note that many other notions of simulation pre-orders have been defined 
for B\"uchi automata, see~\cite{simulations}.\footnote{In ~\cite{simulations},
the simulation of Definition~\ref{def:simulation} is called \emph{direct simulation}.}


\begin{lem}\label{lem:closure-properties-b}
  Let  be a NBW.
  A pre-order  is a simulation for 
  if and only if the following two properties hold:
  \begin{enumerate}[\em(a)]
    \item the set  is -closed.
    \item for all -closed sets , for all ,  is -closed;
  \end{enumerate}
\end{lem}


\proof 
First, assume that  is a simulation for .
Then, the set  is -closed by Definition~\ref{def:simulation}, which establishes (a).
To prove (b), let  be a -closed set and let .
For all  there exists  such that 
. By Definition~\ref{def:simulation},
for all  there exists  such that 
 and  (see \figurename~\ref{fig:simulation}). 
So  since  is -closed and , and thus 
which shows that  is -closed. 

Second, assume that (a) and (b) hold, and show that  satisfies Definition~\ref{def:simulation}.
By (a), for all  and for all , we have .
Now, let  and  such that 
 and . Consider the 
-closed set .
By (b), the set  is -closed and thus
. Therefore, there exists  (i.e. 
) such that . 
Hence,  is a simulation for .
\qed








Lemmas~\ref{lem:closure-properties-a} and~\ref{lem:closure-properties-b} 
entail that all sets computed in the iterations of the fixed point formula~
are -closed for any simulation  for .
We can take advantage of this fact to use a compact representation of those
sets, namely their maximal elements. This would indeed reduce the size of the 
sets to manipulate by the fixed point algorithms (possibly exponentially as we 
will see later). Notice that in general, this compact representation can make 
more difficult the computation of the  operator. To illustrate this, consider
the example in \figurename~\ref{fig:example-max} where we want to compute 
. More precisely, given  we need to compute
the maximal elements of the -closed set .
The set  is delimited by the dashed curve in the figure. 
First, note that applying  to  would give the empty set
from which the correct result can obviously not be extracted. Second, if we assume
that the states  are -incomparable, then the result 
is , which shows 
that essentially any set can be obtained, including sets of maximal elements that 
are huge or difficult to manipulate symbolically. Third, even if the result is compact 
(e.g., if 
for all , then the result is the singleton ), the computation
may somehow require to enumerate all the  for  where 
may be for instance exponential in the size of the problem. 

The above remarks show that for \emph{each particular} application (i.e., for
each class of automata, and each particular simulation  that we use),
we need  to define a predecessor operator 
that applies to maximal elements, such that  
for all -closed sets ,  to present an algorithm to compute this 
operator, and establish its correctness, and  to study the complexity of 
such an algorithm.

Finally, note that the way to compute  given  
and  should also be defined for each application, while for union,
the following general rule applies:
.

In the next sections, we show that the NBW that we have to analyze
in the automata-based approach to model-checking are all equipped with
a simulation pre-order that can be exploited to compute efficiently
the intersection and the predecessor operators. Hence, we show that 
the expected efficiency in terms of space consumption 
of the antichain representation does not come at the price of a blow-up in the 
computation times of these operators. 
We do so for the emptiness problem of ABW,
and for the universality and language inclusion problems for NBW. All these problems
can be reduced to the emptiness problem of NBW that are obtained by specific 
constructions (analogous of the powerset construction), for which simulation relations 
\emph{need not to be computed} for each instance of the problems, but can be defined \emph{generically}
(like set inclusion is such a relation for the classical powerset construction).













\begin{figure}[!tb]
  \unitlength=.8mm
\def\fsize{\normalsize}

\hrule
\begin{picture}(115,85)(0,0)



{\fsize


\gasset{Nw=9,Nh=9,Nmr=4.5}

\node[Nmarks=n](q1)(85,75){}

\node[Nmarks=n](q2)(80,60){}\node[Nmarks=n](q3)(93,50){}\node[Nmarks=n](q4)(71,38){}\node[Nmarks=n](q5)(100,32){}\node[Nmarks=n](q6)(88,25){}\node[Nmarks=n](q7)(66,15){}\node[Nmarks=n](q8)(95,8){}

\node[Nframe=n](left)(55,-1){}
\node[Nframe=n](right)(115,-1){}
\drawbpedge[dash={1.5 2.5}0, AHnb=0](left,82,112,right,98,112){}


\node[Nmarks=n](l1)(10,48){}
\node[Nmarks=n](l2)(40,40){}
\node[Nframe=n](dots)(25,32){}
\node[Nmarks=n](l3)(25,18){}

\drawedge[ELpos=25, ELside=l, ELdist=1, curvedepth=10](l1,q5){}
\drawedge[ELpos=50, ELside=l, ELdist=1, curvedepth=6](l2,q2){}
\drawedge[ELpos=50, ELside=l, ELdist=1, curvedepth=6](l3,q7){}














}
\end{picture}
\hrule


 \caption{Computing the predecessors of a -closed set.}
  \label{fig:example-max}
\end{figure}


\section{Emptiness of ABW}\label{sec:emptiness-alternating}

We now show how to apply Lemmas~\ref{lem:closure-properties-a} and~\ref{lem:closure-properties-b} to check more efficiently the
emptiness of ABW. Let  be an ABW for which we want to decide whether
.  We know that the (exponential) Miyano-Hayashi
construction gives a NBW  such that . The emptiness of  (or equivalently of
) can be decided more efficiently by computing the fixed point
 and without constructing explicitly . To do
so, we establish the existence of a simulation for  for which we can
compute ,  and  by manipulating only maximal
elements of closed sets of locations.




\begin{defi}\label{def:simulation-for-MH}
Let .
Remember that . 
Define the pre-order  such that  iff 
 ,  , and   iff . 
\end{defi}

Note that the pre-order  is a partial order. 
As a consequence, given a set of pairs , 
the set  is an \emph{antichain} and identifies~.

\begin{lem}\label{lem:alt-simulation-relation}
For all ABW , the partial order  is a simulation 
for .
\end{lem}

\proof 
Let  and
  .
  First, let  and , , 
  be such that 
  and
 .
 We show that there exists  such that 
 
 and . 
 Let us consider the case where . Then we have 
   by definition of  and 
  , 
  this set being contained in  as  puts less constraints than  since
  . A similar reasoning holds if . Second, let  and let . By definition of , we know
  that , and by definition of  we have 
   and so .
\qed

According to Lemmas~\ref{lem:closure-properties-a} and~\ref{lem:closure-properties-b}, 
all the sets that we compute to evaluate  are \mbox{-closed}.  
We need to compute intersection and  by only manipulating maximal elements. 
Given , we take  such
that  as follows:

and otherwise the intersection is empty. 

Algorithm~1 computes the maximal elements of the set of
-predecessors of the -clo\-sure of a pair
. This allows to compute the maximal elements of the
set of predecessors of any -closed set by just
manipulating its maximal elements, since .

Note that our algorithm runs in polynomial time, more precisely in  
where  is the size of the transition relation, defined as
the maximal number of boolean connectives in a formula .

\begin{algorithm}[!tbp]
\AlgData{An ABW , 
   and  such that .}  

  \AlgResult{The -antichain .}
  \flushleft
  \Begin { 
    \nl \;


    \nl  \label{alg:pre-alt-o}\;

    \nl \If{ \label{alg:pre-alt-simulation-test}}
	{
	   \nl  \label{alg:pre-alt-o-added}\; 		
	}

    \nl \If{ \label{alg:pre-alt-line-emtpiness-test}}
        {
	    \nl  \label{alg:pre-alt-s} \;
	    \nl  \label{alg:pre-alt-s-added}\;
	}


\nl \KwRet{}\; }\medskip

\caption{Algorithm for . \label{alg:pre-alt}}

\end{algorithm}

\begin{thm}\label{theo:correctness-alg-pre-alt}
  Given an ABW , 
   and  such that , 
  the set 
  computed by Algorithm~1 is an -antichain such that
   where 
  .
\end{thm}

\proof 
Let .
The following entails that :
\begin{enumerate}[(a)]
\item , and 
\item[(b)] for all , 
\end{enumerate}
there exists  such that .

To prove (a), we first show that 
where  is added to  at line~\ref{alg:pre-alt-s-added} of 
Algorithm~1.
By the test of line~\ref{alg:pre-alt-line-emtpiness-test}, we have . 
According to Definition~\ref{def:MH-construction} of , we check that 
there exists a set  such that 
(we take ), and the following conditions hold:
\begin{enumerate}[]
\item  since 
we have  for all  
by line~\ref{alg:pre-alt-s} of Alg.~1.\item  since
we have  for all 
by line~\ref{alg:pre-alt-o} of Alg.~1.\end{enumerate}

Second, we show that  for 
some  where 
is added to  at line~\ref{alg:pre-alt-o-added} of Algorithm~1.
We take  and . 
Since , we  have  ,
and we have  . 
Let us establish that   iff .
If  then  since .
If  then by the test of line~\ref{alg:pre-alt-simulation-test},
we have  and thus .
Hence we have ,
and by line~\ref{alg:pre-alt-o} of the algorithm, we have 
 for all , and thus 
. Therefore
.

To prove (b), assume that there exist  and 
such that  and 
.
We have to show that there exists  such that 
.

First, assume that .
Since ,
we have:
\begin{enumerate}[]  
\item for all ,  and since 
 also . Let 
be the set defined at line~\ref{alg:pre-alt-s} of Algorithm~1.
For all , if  then .
Hence, .

\item for all , 
for some  such that . 
Hence necessarily 
and thus for all , .
Let  be the set defined at line~\ref{alg:pre-alt-o} of Algorithm~1.
For all , if  
then . Hence,  and .
\end{enumerate}
\noindent
Hence,  which is added to  by Alg.~1 at 
line~\ref{alg:pre-alt-s-added} satisfies .

Second, assume that . 
Since  and ,
we know that for all ,  and 
. Let  so we have 
  and 
 .
Hence,  and thus for all , .
Let  be the set defined at line~\ref{alg:pre-alt-o} of Algorithm~1.
For all , if  
then . Hence,  and 
 where 
is added to  by Algorithm~1 at line~\ref{alg:pre-alt-o-added}.
Notice that the test at line~\ref{alg:pre-alt-simulation-test} is satisfied because
 implies that  and since ,
we have .
\qed





\section{Universality of NBW}\label{sec:universality}

We present a new algorithm to check universality of NBW, based
the existence of a simple simulation relation for the complement
automaton of NBW given by Definition~\ref{def:direct-complementation}.

\begin{defi}\label{def:simulation-for-KVMH}
Given an NBW ,
let .
Define the pre-order  as follows: 
for all , let 
 
iff the following conditions hold:
  \begin{enumerate}[]
    \item for all , there exists  such that ;
    \item for all , there exists  such that ;
    \item  iff .
  \end{enumerate}
\end{defi}

This relation formalizes the intuition that it is easier to accept a word 
in  from a given location with a high rank than with a small rank. 
This is because the rank is always decreasing along every path of the runs 
of , and so a small rank is always simulated by a greater rank.
Hence, essentially the minimal rank of each location of  and  is relevant
to define the pre-order . The third condition requires
that only accepting states simulate accepting states.



\begin{lem}\label{lem:univ-simulation-relation}
For all NBW , 
the pre-order  is a simulation for the NBW .
\end{lem} 

\proof Let  and 
.
First, we show that for all 
, for all ,
if  
and  
then . Notice that we have trivially 
.
We give the proof for . 
The case  is proven similarly.
According to Definition~\ref{def:direct-complementation}, 
since  we have

Since , we have  and

Combining  and  yields 
, 
and combining  and  yields
. 
Since , this implies that .

Second, for all  we have , and
thus for all , if
 then  so that
.

Hence  is a simulation for .
\qed

According to Lemmas~\ref{lem:closure-properties-a} and~\ref{lem:closure-properties-b}, 
all intermediate sets that are computed by the fixed point  to check emptiness of
 (and thus universality of~) are -closed. 
Since~ is not a partial order, 
the set  for a -closed set~
may contain several -equivalent elements ( and  are 
-equivalent if  and ).
For example, the set  is 
-equivalent to the set 
.
In fact  is a union of -equivalent classes.
Hence, the size of  can be reduced by keeping only one canonical 
element for each -equivalent class.
Given a set , define its \emph{characteristic function}  such that 
with the usual convention that .
Note that if , then  is even for all .

Let  be characteristic functions. Let  be the function~ 
such that  for all .
We denote by  the function such that  for all .  
We write  if for all ,  and we write 
 if ,  and  iff .
Notice that~ is partial order over characteristic functions,
and that if , then  for all .
The following lemma is a corollary of Definition~\ref{def:simulation-for-KVMH}.

\begin{lem}\label{lem:characteristic-function}
  For all sets , 
  if and only if .
\end{lem}


Define  and 
.
We extend the operator  to sets of pairs of characteristic
functions as expected. 
Notice that  iff , that , and 
a corollary of Lemma~\ref{lem:characteristic-function} is that 
the -minimal elements of a set  of pairs of characteristic functions
represents exactly the -maximal pairs  of .








Now, we show how to compute efficiently ,  and  for
-closed sets that are represented by
characteristic functions. 
Let  be two sets of pairs of
characteristic functions, let  be the set
of -minimal elements of , and let  be the -minimal elements
of the union of:
\begin{enumerate}[]
\item[]  and
\item[] .
\end{enumerate}
By Equation~\eqref{eq:intersection} and by the previous remarks, we have:
\begin{enumerate}[]
\item[]  and .
\end{enumerate}\medskip

\noindent To compute  of a single pair of
characteristic functions, we propose Algorithm~2 whose correctness is
established by Theorem~\ref{theo:correctness-alg-pre}. Computing the
predecessors of a set of characteristic functions is then
straightforward using the algorithm for union of sets of pairs of
characteristic functions since

In Algorithm~2, we represent  by any number
strictly greater than , and we adapt the definition of  as
follows:  iff for all , either  or . In the algorithm, we use the notations
 for the least odd number  such that , and
 for the least even number  such that .

The structure of Algorithm~2
is similar to Algorithm~1, but the computations are expressed 
in terms of characteristic functions, thus in terms of ranks. For example,
\mbox{lines~\ref{alg:pre-line-o-alpha}-\ref{alg:pre-line-o-not-alpha}} compute
the equivalent of line~\ref{alg:pre-alt-o} in Algorithm~1,
where  corresponds here to the set of odd-ranked locations,
and thus contains no -nodes. Details are given in the proof of 
Theorem~\ref{theo:correctness-alg-pre}.

\begin{thm}\label{theo:correctness-alg-pre}
  Let  be a NBW, 
  , and  be a pair of characteristic functions 
  such that .
  The set  computed by
  Algorithm~2 is such that 
  
  and for all , we have 
  and  and  are even for all .
\end{thm} 

\proof 
Let ,
and let  be a pair of sets whose characteristic functions
are  and  (such a pair exists because
).
We show that (a)  and
(b) .

To prove (a), first consider a pair  added to  at 
line~\ref{alg:pre-line-Z-one} of Algorithm~2 and let 
. We show that 
 and .

By the test of line~\ref{alg:pre-line-emtpiness-test}, we have 
and therefore . 
According to Definition~\ref{def:direct-complementation} of , 
we have to check that there exists a set  such that 
 (we take ), 
and the following conditions hold:
\begin{enumerate}[]
\item .

		Observe that for all , for all , 
		we have  (lines~\ref{alg:pre-line-f-s},\ref{alg:pre-line-s-ceileven} 
		of Algorithm~2). 
		Since  (by definition of characteristic functions), 
		we take  so that we have  and . 
		
\item .

		Since , we have  for 
		and  for .
		Now, for all , for all , 
		we have either  and then  for , 
		or  and then  for 
		(lines~\ref{alg:pre-line-o-alpha}-\ref{alg:pre-line-o-ceileven} 
		of Algorithm~2).
		In both cases, for  we have  and .
\end{enumerate}
Moreover, we prove that:
\begin{enumerate}[]
\item[] .

Since , we have for all  either 
 or .
By lines~\ref{alg:pre-line-o-alpha}-\ref{alg:pre-line-o-ceileven} of Algorithm~2,
we have for all , for all  
either  or ,
and thus either  or . 
Hence, we have for all  either  or 
.
Therefore, by lines~\ref{alg:pre-line-f-s}-\ref{alg:pre-line-s-ceileven} of 
Algorithm~2, if , then  or ,
and if , then  is even (line~\ref{alg:pre-line-o-ceileven})
and thus either  or .
In all cases, .

\item[(iv)]  and  are even. 

This is enforced by line~\ref{alg:pre-line-s-ceileven} and line~\ref{alg:pre-line-o-ceileven} of the algorithm.
\end{enumerate}


\noindent Second, consider a pair  added to
 at line~\ref{alg:pre-line-Z-two}, and let
.  Notice
that  and that  is even for all  by .  We show that there exists  such that .  We take  and .  Since , we have  , and we have 
.  Moreover, if , then there exists let  for some  and even number , since the maximal rank  is even. So  and thus .  Since , we have   iff .  Hence . The fact that

is proven similarly to .

To prove (b), assume that there exist  and 
such that  and 
.
We have to show that , i.e., 
 for some .

First, assume that . 
Notice that  and  
since ,
From the fact that ,
we get:
\begin{enumerate}[] 
\item for all , for all ,  
and thus . Hence, for all  we have
,
where  is computed by line~\ref{alg:pre-line-f-s} of Algorithm~2) for . 
We also have  (see line~\ref{alg:pre-line-s-ceileven} of Algorithm~2) 
for , as  is even in that case.
Thus, .
 
\item for all , for all ,  
for some set  such that  and . 
Therefore 
and thus 
since  and .
Hence, for all  
either  or  (where  is computed 
at lines~\ref{alg:pre-line-f-o-begin}-\ref{alg:pre-line-f-o-end} of Algorithm~2).
Thus, .

\item By our assumption that , we have , and 
so  by .
\end{enumerate}\medskip

\noindent Hence, the pair  added to  by
Algorithm~2 at line~\ref{alg:pre-line-Z-one} satisfies
 and thus
.



Second, assume that . Let . 
Since  and ,
we have . 
Next, we use several times the fact that  implies . 
Since  and , we have 
  
and  . 
By  and , we get easily .
Now, by the fact that 
, we know that
for all , for all ,  
and thus . 
Notice that ,
where  is computed at lines~\ref{alg:pre-line-f-o-begin}-\ref{alg:pre-line-f-o-end} of Algorithm~2. 
Thus,  for all  
and therefore  so that 
where  is added to  by Algorithm~2 at line~\ref{alg:pre-line-Z-one}. 
\qed


Algorithm~2 computes the predecessors of a pair 
in time , which is polynomial in the size of the input, even though
the number of pairs  that are represented by the pair 
and by the computed set  can be of exponential size.
For example, the set  
with an exponential number of elements is represented by the unique
pair  where  for all .
Hence the compact representation that we propose does not come
with an execution time blow-up, which makes the new approach much more efficient 
in practice.


\begin{algorithm}[!tbp]
\AlgData{A NBW , ,
   and a pair  of characteristic functions.} 
  \AlgResult{The set .}
  \flushleft
  \Begin { 
\nl \ForEach{ \label{alg:pre-line-f-o-begin}}
	{
		\nl  \;
	    	\nl \ForEach{}
		{
			\nl \lIf{}{} \label{alg:pre-line-o-alpha} \;
			\nl \lElse{} \label{alg:pre-line-o-not-alpha}\;
		}
		\nl \lIf{}{ \label{alg:pre-line-o-ceileven} \label{alg:pre-line-f-o-end}} \;
	}
	\nl  \label{alg:pre-line-Z-two}\;
	\nl  \;
	\nl \If{ ({\it i.e.} ) \label{alg:pre-line-emtpiness-test}}
	{
		\nl \ForEach{}
		{
			\nl  \label{alg:pre-line-f-s} \;
			\nl \lIf{}{ \label{alg:pre-line-s-ceileven}} \;
			
		}
		\nl  \label{alg:pre-line-Z-one}\;
	}
	


  \nl \KwRet{}\; }\medskip

\caption{Algorithm for . \label{alg:pre}}

\end{algorithm}








\section{Implementation and Practical Evaluation}\label{sec:implementation}

\paragraph{{\bf The randomized model}}
To evaluate our new algorithm for universality of NBW and compare with
the existing implementations of the Kupferman-Vardi and Miyano-Hayashi
constructions, we use a random model to generate NBW.  This model was
first proposed by Tabakov and Vardi to compare the efficiency of
some algorithms for automata in the context of finite words 
automata~\cite{TabakovV05} and more recently in the context of infinite
words automata~\cite{TabakovV07}.
In the model, the input alphabet is fixed to , and for
each letter , a number  of different
state pairs  are chosen uniformly at
random before the corresponding transitions  are
added to the automaton.  The ratio 
is called the \emph{transition density} for~.  This ratio
represents the average outdegree of each state for~.  In all
experiments, we choose , and denote the transition density
by~.  The model contains a second parameter: the \emph{density 
  of accepting states}.  There is only one initial state, and the
number  of accepting states is linear in the total number of
states, as determined by .  The accepting states
themselves are chosen uniformly at random.  Observe that since the
transition relation is not always total, automata with  are not
necessarily universal.

Tabakov and Vardi have studied the space of parameter values for this
model and argue that ``interesting'' automata are generated by the
model as the two parameters  and  vary. They also study the 
density of universal automata.

\paragraph{{\bf Performance comparison}}
We have implemented our algorithm to check the universality of
randomly generated NBW. The code is written in {\tt C} with an
explicit representation for characteristic functions, as arrays of
integers.  All the experiments are conducted on a biprocessor Linux
station (two Ghz Intel Xeons with GB of RAM).

\figurename~\ref{fig:median-time} shows as a function of 
(transition density) and  (density of accepting states) the median
execution times for testing universality of  random automata with
.  It shows that the universality test was the most
difficult for  and  with a median time of  seconds.
The times for  and  are not plotted because they
were always less than ms.  A similar shape and maximal median
time is reported by Tabakov for automata
of size , that is for automata that are five times smaller~\cite{TabakovV07}.  Another previous work reports prohibitive execution times for
complementing NBW of size , showing that explicitly constructing
the complement is not a reasonable approach~\cite{GurumurthyKSV03}.
The density of universal automata in the samples is shown in \figurename~\ref{fig:density}.
The density increases when states have more transitions, while 
it seems less sensitive to the density of accepting states. The difficult 
instances correspond to the values of the densities of transitions and 
accepting states for which the probability to be universal is close to a half.
Analogous results have been observed in~\cite{TabakovV07}.


To evaluate the scalability of our algorithm, 
we have run the following experiment. For a set of
parameter values, we have evaluated the maximal size of automata
(measured in term of number of locations) for which our algorithm 
could analyze  over  instances in less than 20 seconds. 
We have tried automata sizes from  to , with a fine granularity
for small sizes (from  to  with an increment of , from 
 to  with an increment of , and from  to  
with an increment of ) and a rougher granularity for
large sizes (from  to  with an increment of , and
from  to  with an increment of ). 




\begin{figure}[!tbp]
  \begin{minipage}[b]{.45\linewidth}
    \scalebox{0.5}{\begingroup
  \catcode`\@=11\relax
  \def\GNUPLOTspecial{\def\do##1{\catcode`##1=12\relax}\dospecials
    \catcode`\{=1\catcode`\}=2\catcode\%=14\relax\special}\expandafter\ifx\csname GNUPLOTpicture\endcsname\relax
  \csname newdimen\endcsname\GNUPLOTunit
  \gdef\GNUPLOTpicture(#1,#2){\vbox to#2\GNUPLOTunit\bgroup
    \def\put(##1,##2)##3{\unskip\raise##2\GNUPLOTunit
      \hbox to0pt{\kern##1\GNUPLOTunit ##3\hss}\ignorespaces}\def\ljust##1{\vbox to0pt{\vss\hbox to0pt{##1\hss}\vss}}\def\cjust##1{\vbox to0pt{\vss\hbox to0pt{\hss ##1\hss}\vss}}\def\rjust##1{\vbox to0pt{\vss\hbox to0pt{\hss ##1}\vss}}\def\stack##1{\let\\=\cr\tabskip=0pt\halign{\hfil ####\hfil\cr ##1\crcr}}\def\lstack##1{\hbox to0pt{\vbox to0pt{\vss\stack{##1}}\hss}}\def\cstack##1{\hbox to0pt{\hss\vbox to0pt{\vss\stack{##1}}\hss}}\def\rstack##1{\hbox to0pt{\vbox to0pt{\stack{##1}\vss}\hss}}\vss\hbox to#1\GNUPLOTunit\bgroup\ignorespaces}\gdef\endGNUPLOTpicture{\hss\egroup\egroup}\fi
\GNUPLOTunit=0.1bp
\GNUPLOTpicture(3600,2160)
{\GNUPLOTspecial{"
/gnudict 256 dict def
gnudict begin
/Color false def
/Solid false def
/gnulinewidth 5.000 def
/userlinewidth gnulinewidth def
/vshift -33 def
/dl {10.0 mul} def
/hpt_ 31.5 def
/vpt_ 31.5 def
/hpt hpt_ def
/vpt vpt_ def
/Rounded false def
/M {moveto} bind def
/L {lineto} bind def
/R {rmoveto} bind def
/V {rlineto} bind def
/N {newpath moveto} bind def
/C {setrgbcolor} bind def
/f {rlineto fill} bind def
/vpt2 vpt 2 mul def
/hpt2 hpt 2 mul def
/Lshow { currentpoint stroke M
  0 vshift R show } def
/Rshow { currentpoint stroke M
  dup stringwidth pop neg vshift R show } def
/Cshow { currentpoint stroke M
  dup stringwidth pop -2 div vshift R show } def
/UP { dup vpt_ mul /vpt exch def hpt_ mul /hpt exch def
  /hpt2 hpt 2 mul def /vpt2 vpt 2 mul def } def
/DL { Color {setrgbcolor Solid {pop []} if 0 setdash }
 {pop pop pop 0 setgray Solid {pop []} if 0 setdash} ifelse } def
/BL { stroke userlinewidth 2 mul setlinewidth
      Rounded { 1 setlinejoin 1 setlinecap } if } def
/AL { stroke userlinewidth 2 div setlinewidth
      Rounded { 1 setlinejoin 1 setlinecap } if } def
/UL { dup gnulinewidth mul /userlinewidth exch def
      dup 1 lt {pop 1} if 10 mul /udl exch def } def
/PL { stroke userlinewidth setlinewidth
      Rounded { 1 setlinejoin 1 setlinecap } if } def
/LTw { PL [] 1 setgray } def
/LTb { BL [] 0 0 0 DL } def
/LTa { AL [1 udl mul 2 udl mul] 0 setdash 0 0 0 setrgbcolor } def
/LT0 { PL [] 1 0 0 DL } def
/LT1 { PL [4 dl 2 dl] 0 1 0 DL } def
/LT2 { PL [2 dl 3 dl] 0 0 1 DL } def
/LT3 { PL [1 dl 1.5 dl] 1 0 1 DL } def
/LT4 { PL [5 dl 2 dl 1 dl 2 dl] 0 1 1 DL } def
/LT5 { PL [4 dl 3 dl 1 dl 3 dl] 1 1 0 DL } def
/LT6 { PL [2 dl 2 dl 2 dl 4 dl] 0 0 0 DL } def
/LT7 { PL [2 dl 2 dl 2 dl 2 dl 2 dl 4 dl] 1 0.3 0 DL } def
/LT8 { PL [2 dl 2 dl 2 dl 2 dl 2 dl 2 dl 2 dl 4 dl] 0.5 0.5 0.5 DL } def
/Pnt { stroke [] 0 setdash
   gsave 1 setlinecap M 0 0 V stroke grestore } def
/Dia { stroke [] 0 setdash 2 copy vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath stroke
  Pnt } def
/Pls { stroke [] 0 setdash vpt sub M 0 vpt2 V
  currentpoint stroke M
  hpt neg vpt neg R hpt2 0 V stroke
  } def
/Box { stroke [] 0 setdash 2 copy exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V closepath stroke
  Pnt } def
/Crs { stroke [] 0 setdash exch hpt sub exch vpt add M
  hpt2 vpt2 neg V currentpoint stroke M
  hpt2 neg 0 R hpt2 vpt2 V stroke } def
/TriU { stroke [] 0 setdash 2 copy vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath stroke
  Pnt  } def
/Star { 2 copy Pls Crs } def
/BoxF { stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V  hpt2 0 V  0 vpt2 V
  hpt2 neg 0 V  closepath fill } def
/TriUF { stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath fill } def
/TriD { stroke [] 0 setdash 2 copy vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath stroke
  Pnt  } def
/TriDF { stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath fill} def
/DiaF { stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath fill } def
/Pent { stroke [] 0 setdash 2 copy gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath stroke grestore Pnt } def
/PentF { stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath fill grestore } def
/Circle { stroke [] 0 setdash 2 copy
  hpt 0 360 arc stroke Pnt } def
/CircleF { stroke [] 0 setdash hpt 0 360 arc fill } def
/C0 { BL [] 0 setdash 2 copy moveto vpt 90 450  arc } bind def
/C1 { BL [] 0 setdash 2 copy        moveto
       2 copy  vpt 0 90 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C2 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 90 180 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C3 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 0 180 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C4 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 180 270 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C5 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 0 90 arc
       2 copy moveto
       2 copy  vpt 180 270 arc closepath fill
               vpt 0 360 arc } bind def
/C6 { BL [] 0 setdash 2 copy moveto
      2 copy  vpt 90 270 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C7 { BL [] 0 setdash 2 copy moveto
      2 copy  vpt 0 270 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C8 { BL [] 0 setdash 2 copy moveto
      2 copy vpt 270 360 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C9 { BL [] 0 setdash 2 copy moveto
      2 copy  vpt 270 450 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C10 { BL [] 0 setdash 2 copy 2 copy moveto vpt 270 360 arc closepath fill
       2 copy moveto
       2 copy vpt 90 180 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C11 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 0 180 arc closepath fill
       2 copy moveto
       2 copy  vpt 270 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C12 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 180 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C13 { BL [] 0 setdash  2 copy moveto
       2 copy  vpt 0 90 arc closepath fill
       2 copy moveto
       2 copy  vpt 180 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C14 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 90 360 arc closepath fill
               vpt 0 360 arc } bind def
/C15 { BL [] 0 setdash 2 copy vpt 0 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/Rec   { newpath 4 2 roll moveto 1 index 0 rlineto 0 exch rlineto
       neg 0 rlineto closepath } bind def
/Square { dup Rec } bind def
/Bsquare { vpt sub exch vpt sub exch vpt2 Square } bind def
/S0 { BL [] 0 setdash 2 copy moveto 0 vpt rlineto BL Bsquare } bind def
/S1 { BL [] 0 setdash 2 copy vpt Square fill Bsquare } bind def
/S2 { BL [] 0 setdash 2 copy exch vpt sub exch vpt Square fill Bsquare } bind def
/S3 { BL [] 0 setdash 2 copy exch vpt sub exch vpt2 vpt Rec fill Bsquare } bind def
/S4 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt Square fill Bsquare } bind def
/S5 { BL [] 0 setdash 2 copy 2 copy vpt Square fill
       exch vpt sub exch vpt sub vpt Square fill Bsquare } bind def
/S6 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill Bsquare } bind def
/S7 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill
       2 copy vpt Square fill
       Bsquare } bind def
/S8 { BL [] 0 setdash 2 copy vpt sub vpt Square fill Bsquare } bind def
/S9 { BL [] 0 setdash 2 copy vpt sub vpt vpt2 Rec fill Bsquare } bind def
/S10 { BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt Square fill
       Bsquare } bind def
/S11 { BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt2 vpt Rec fill
       Bsquare } bind def
/S12 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill Bsquare } bind def
/S13 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill
       2 copy vpt Square fill Bsquare } bind def
/S14 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill
       2 copy exch vpt sub exch vpt Square fill Bsquare } bind def
/S15 { BL [] 0 setdash 2 copy Bsquare fill Bsquare } bind def
/D0 { gsave translate 45 rotate 0 0 S0 stroke grestore } bind def
/D1 { gsave translate 45 rotate 0 0 S1 stroke grestore } bind def
/D2 { gsave translate 45 rotate 0 0 S2 stroke grestore } bind def
/D3 { gsave translate 45 rotate 0 0 S3 stroke grestore } bind def
/D4 { gsave translate 45 rotate 0 0 S4 stroke grestore } bind def
/D5 { gsave translate 45 rotate 0 0 S5 stroke grestore } bind def
/D6 { gsave translate 45 rotate 0 0 S6 stroke grestore } bind def
/D7 { gsave translate 45 rotate 0 0 S7 stroke grestore } bind def
/D8 { gsave translate 45 rotate 0 0 S8 stroke grestore } bind def
/D9 { gsave translate 45 rotate 0 0 S9 stroke grestore } bind def
/D10 { gsave translate 45 rotate 0 0 S10 stroke grestore } bind def
/D11 { gsave translate 45 rotate 0 0 S11 stroke grestore } bind def
/D12 { gsave translate 45 rotate 0 0 S12 stroke grestore } bind def
/D13 { gsave translate 45 rotate 0 0 S13 stroke grestore } bind def
/D14 { gsave translate 45 rotate 0 0 S14 stroke grestore } bind def
/D15 { gsave translate 45 rotate 0 0 S15 stroke grestore } bind def
/DiaE { stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath stroke } def
/BoxE { stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V closepath stroke } def
/TriUE { stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath stroke } def
/TriDE { stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath stroke } def
/PentE { stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath stroke grestore } def
/CircE { stroke [] 0 setdash 
  hpt 0 360 arc stroke } def
/Opaque { gsave closepath 1 setgray fill grestore 0 setgray closepath } def
/DiaW { stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V Opaque stroke } def
/BoxW { stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V Opaque stroke } def
/TriUW { stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V Opaque stroke } def
/TriDW { stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V Opaque stroke } def
/PentW { stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  Opaque stroke grestore } def
/CircW { stroke [] 0 setdash 
  hpt 0 360 arc Opaque stroke } def
/BoxFill { gsave Rec 1 setgray fill grestore } def
/BoxColFill {
  gsave Rec
  /Fillden exch def
  currentrgbcolor
  /ColB exch def /ColG exch def /ColR exch def
  /ColR ColR Fillden mul Fillden sub 1 add def
  /ColG ColG Fillden mul Fillden sub 1 add def
  /ColB ColB Fillden mul Fillden sub 1 add def
  ColR ColG ColB setrgbcolor
  fill grestore } def
/PatternFill { gsave /PFa [ 9 2 roll ] def
    PFa 0 get PFa 2 get 2 div add PFa 1 get PFa 3 get 2 div add translate
    PFa 2 get -2 div PFa 3 get -2 div PFa 2 get PFa 3 get Rec
    gsave 1 setgray fill grestore clip
    currentlinewidth 0.5 mul setlinewidth
    /PFs PFa 2 get dup mul PFa 3 get dup mul add sqrt def
    0 0 M PFa 5 get rotate PFs -2 div dup translate
	0 1 PFs PFa 4 get div 1 add floor cvi
	{ PFa 4 get mul 0 M 0 PFs V } for
    0 PFa 6 get ne {
	0 1 PFs PFa 4 get div 1 add floor cvi
	{ PFa 4 get mul 0 2 1 roll M PFs 0 V } for
    } if
    stroke grestore } def
/Symbol-Oblique /Symbol findfont [1 0 .167 1 0 0] makefont
dup length dict begin {1 index /FID eq {pop pop} {def} ifelse} forall
currentdict end definefont pop
end
gnudict begin
gsave
0 0 translate
0.100 0.100 scale
0 setgray
newpath
1.000 UL
LTb
1.000 UP
1.000 UL
LT0
1225 1305 M
233 147 V
1.000 UL
LT0
1690 1420 M
-232 32 V
1.000 UL
LT0
1456 1259 M
234 161 V
1.000 UL
LT0
1920 1408 M
-230 12 V
1.000 UL
LT0
1687 1214 M
233 194 V
1.000 UL
LT0
2151 1394 M
-231 14 V
1.000 UL
LT0
991 1164 M
234 141 V
1.000 UL
LT0
1456 1259 M
-231 46 V
1.000 UL
LT0
1222 1119 M
234 140 V
1.000 UL
LT0
1687 1214 M
-231 45 V
1.000 UL
LT0
1918 1183 M
233 211 V
1.000 UL
LT0
2383 1741 M
2151 1394 L
1.000 UL
LT0
1453 1072 M
234 142 V
1.000 UL
LT0
1918 1183 M
-231 31 V
1.000 UL
LT0
2383 1741 M
231 -515 V
1.000 UL
LT0
2380 1231 M
234 -5 V
1.000 UL
LT0
2845 1166 M
-231 60 V
1.000 UL
LT0
2612 1028 M
233 138 V
1.000 UL
LT0
3077 1120 M
-232 46 V
1.000 UL
LT0
757 1024 M
234 140 V
1.000 UL
LT0
1222 1119 M
-231 45 V
1.000 UL
LT0
1685 1028 M
233 155 V
1.000 UL
LT0
2149 1247 M
-231 -64 V
1.000 UL
LT0
2843 981 M
234 139 V
1.000 UL
LT0
988 978 M
234 141 V
1.000 UL
LT0
1453 1072 M
-231 47 V
1.000 UL
LT0
1220 932 M
233 140 V
1.000 UL
LT0
1685 1028 M
-232 44 V
1.000 UL
LT0
2383 1741 M
2149 1247 L
1.000 UL
LT0
1915 981 M
234 266 V
1.000 UL
LT0
2380 1231 M
-231 16 V
1.000 UL
LT0
2380 1231 M
232 -203 V
1.000 UL
LT0
2378 893 M
234 135 V
1.000 UL
LT0
2843 981 M
-231 47 V
1.000 UL
LT0
523 884 M
234 140 V
1.000 UL
LT0
988 978 M
-231 46 V
1.000 UL
LT0
1451 886 M
234 142 V
1.000 UL
LT0
1915 981 M
-230 47 V
1.000 UL
LT0
2609 841 M
234 140 V
1.000 UL
LT0
755 838 M
988 978 L
1.000 UL
LT0
1220 932 M
988 978 L
1.000 UL
LT0
1682 840 M
233 141 V
1.000 UL
LT0
2147 955 M
-232 26 V
1.000 UL
LT0
2147 955 M
233 276 V
1.000 UL
LT0
986 792 M
234 140 V
1.000 UL
LT0
1451 886 M
-231 46 V
1.000 UL
LT0
1913 797 M
234 158 V
1.000 UL
LT0
2378 893 M
-231 62 V
1.000 UL
LT0
1217 746 M
234 140 V
1.000 UL
LT0
1682 840 M
-231 46 V
1.000 UL
LT0
755 838 M
523 884 L
1.000 UL
LT0
2144 748 M
234 145 V
1.000 UL
LT0
2609 841 M
-231 52 V
1.000 UL
LT0
2375 702 M
234 139 V
1.000 UL
LT0
1449 700 M
233 140 V
1.000 UL
LT0
1913 797 M
-231 43 V
1.000 UL
LT0
986 792 M
755 838 L
1.000 UL
LT0
1217 746 M
986 792 L
1.000 UL
LT0
1680 654 M
233 143 V
1.000 UL
LT0
2144 748 M
-231 49 V
1.000 UL
LT0
1910 608 M
234 140 V
1.000 UL
LT0
2375 702 M
-231 46 V
1.000 UL
LT0
1449 700 M
-232 46 V
1.000 UL
LT0
2142 562 M
233 140 V
1.000 UL
LT0
1680 654 M
-231 46 V
1.000 UL
LT0
1910 608 M
-230 46 V
1.000 UL
LT0
2142 562 M
-232 46 V
1.000 UL
LT0
LTb
1.000 UL
LT0
3124 1996 M
263 0 V
1.000 UL
LTb
2142 305 M
935 559 V
1.000 UL
LTb
2142 305 M
523 628 L
1.000 UL
LTb
523 628 M
845 820 L
1.000 UL
LTb
3077 864 M
-322 64 V
1.000 UL
LTb
523 1396 M
0 -768 V
1.000 UL
LTa
523 628 M
845 820 L
1.000 UL
LTb
523 628 M
59 35 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTa
755 582 M
321 192 V
1.000 UL
LTb
755 582 M
58 35 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTa
986 536 M
322 192 V
1.000 UL
LTb
986 536 M
59 35 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTa
1217 490 M
322 192 V
1.000 UL
LTb
1217 490 M
59 35 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTa
1449 443 M
322 193 V
1.000 UL
LTb
1449 443 M
58 36 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTa
1680 397 M
321 193 V
1.000 UL
LTb
1680 397 M
59 35 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTa
1910 351 M
935 559 V
1.000 UL
LTb
1910 351 M
59 35 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTb
2787 875 M
58 35 V
1.000 UL
LTa
2142 305 M
935 559 V
1.000 UL
LTb
2142 305 M
58 35 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTb
3018 829 M
59 35 V
LTb
1.000 UL
LTa
2142 305 M
523 628 L
1.000 UL
LTb
2142 305 M
-55 11 V
1.000 UL
LTb
1.000 UL
LTb
578 617 M
-55 11 V
1.000 UL
LTa
2375 445 M
757 768 L
1.000 UL
LTb
2375 445 M
-54 11 V
1.000 UL
LTb
1.000 UL
LTb
812 757 M
-55 11 V
1.000 UL
LTa
2609 585 M
-322 64 V
1.000 UL
LTb
2609 585 M
-54 10 V
1.000 UL
LTb
1.000 UL
LTa
2843 724 M
-322 64 V
1.000 UL
LTb
2843 724 M
-55 11 V
1.000 UL
LTb
1.000 UL
LTa
3053 850 M
-321 64 V
1.000 UL
LTb
3053 850 M
-54 11 V
1.000 UL
LTb
LTb
1.000 UL
LTb
586 884 M
-63 0 V
1.000 UL
LTb
1.000 UL
LTb
586 970 M
-63 0 V
1.000 UL
LTb
1.000 UL
LTb
586 1055 M
-63 0 V
1.000 UL
LTb
1.000 UL
LTb
586 1140 M
-63 0 V
1.000 UL
LTb
1.000 UL
LTb
586 1225 M
-63 0 V
1.000 UL
LTb
1.000 UL
LTb
586 1310 M
-63 0 V
1.000 UL
LTb
1.000 UL
LTb
586 1396 M
-63 0 V
1.000 UL
LTb
LTb
1.000 UP
stroke
grestore
end
showpage
}}\put(522,1588){\cjust{Median Time (s)}}\put(397,1396){\rjust{ 12}}\put(397,1225){\rjust{ 8}}\put(397,1055){\rjust{ 4}}\put(397,884){\rjust{ 0}}\put(2960,490){\special{ps: gsave currentpoint currentpoint translate
-34.5 rotate neg exch neg exch translate}\cstack{\cjust{f - accepting density}}\special{ps: currentpoint grestore moveto}}\put(3157,823){\cjust{0.1}}\put(2946,697){\cjust{0.3}}\put(2713,557){\cjust{0.5}}\put(2479,418){\cjust{0.7}}\put(2245,278){\cjust{0.9}}\put(1099,280){\special{ps: gsave currentpoint currentpoint translate
10.5 rotate neg exch neg exch translate}\cstack{\cjust{r - transition density}}\special{ps: currentpoint grestore moveto}}\put(1864,296){\rjust{1.4}}\put(1402,388){\rjust{1.8}}\put(939,480){\rjust{2.2}}\put(477,572){\rjust{2.6}}\put(3074,1996){\rjust{Median execution time}}\endGNUPLOTpicture
\endgroup
%
 }
    \caption{\protect\parbox[t]{45mm}{Median time to check universality of  automata of size  for each sample point.}}
    \label{fig:median-time}
 \end{minipage} \hfill 
 \begin{minipage}[b]{.47\linewidth}
    \scalebox{0.5}{\begingroup
  \catcode`\@=11\relax
  \def\GNUPLOTspecial{\def\do##1{\catcode`##1=12\relax}\dospecials
    \catcode`\{=1\catcode`\}=2\catcode\%=14\relax\special}\expandafter\ifx\csname GNUPLOTpicture\endcsname\relax
  \csname newdimen\endcsname\GNUPLOTunit
  \gdef\GNUPLOTpicture(#1,#2){\vbox to#2\GNUPLOTunit\bgroup
    \def\put(##1,##2)##3{\unskip\raise##2\GNUPLOTunit
      \hbox to0pt{\kern##1\GNUPLOTunit ##3\hss}\ignorespaces}\def\ljust##1{\vbox to0pt{\vss\hbox to0pt{##1\hss}\vss}}\def\cjust##1{\vbox to0pt{\vss\hbox to0pt{\hss ##1\hss}\vss}}\def\rjust##1{\vbox to0pt{\vss\hbox to0pt{\hss ##1}\vss}}\def\stack##1{\let\\=\cr\tabskip=0pt\halign{\hfil ####\hfil\cr ##1\crcr}}\def\lstack##1{\hbox to0pt{\vbox to0pt{\vss\stack{##1}}\hss}}\def\cstack##1{\hbox to0pt{\hss\vbox to0pt{\vss\stack{##1}}\hss}}\def\rstack##1{\hbox to0pt{\vbox to0pt{\stack{##1}\vss}\hss}}\vss\hbox to#1\GNUPLOTunit\bgroup\ignorespaces}\gdef\endGNUPLOTpicture{\hss\egroup\egroup}\fi
\GNUPLOTunit=0.1bp
\GNUPLOTpicture(3600,2160)
{\GNUPLOTspecial{"
/gnudict 256 dict def
gnudict begin
/Color false def
/Solid false def
/gnulinewidth 5.000 def
/userlinewidth gnulinewidth def
/vshift -33 def
/dl {10.0 mul} def
/hpt_ 31.5 def
/vpt_ 31.5 def
/hpt hpt_ def
/vpt vpt_ def
/Rounded false def
/M {moveto} bind def
/L {lineto} bind def
/R {rmoveto} bind def
/V {rlineto} bind def
/N {newpath moveto} bind def
/C {setrgbcolor} bind def
/f {rlineto fill} bind def
/vpt2 vpt 2 mul def
/hpt2 hpt 2 mul def
/Lshow { currentpoint stroke M
  0 vshift R show } def
/Rshow { currentpoint stroke M
  dup stringwidth pop neg vshift R show } def
/Cshow { currentpoint stroke M
  dup stringwidth pop -2 div vshift R show } def
/UP { dup vpt_ mul /vpt exch def hpt_ mul /hpt exch def
  /hpt2 hpt 2 mul def /vpt2 vpt 2 mul def } def
/DL { Color {setrgbcolor Solid {pop []} if 0 setdash }
 {pop pop pop 0 setgray Solid {pop []} if 0 setdash} ifelse } def
/BL { stroke userlinewidth 2 mul setlinewidth
      Rounded { 1 setlinejoin 1 setlinecap } if } def
/AL { stroke userlinewidth 2 div setlinewidth
      Rounded { 1 setlinejoin 1 setlinecap } if } def
/UL { dup gnulinewidth mul /userlinewidth exch def
      dup 1 lt {pop 1} if 10 mul /udl exch def } def
/PL { stroke userlinewidth setlinewidth
      Rounded { 1 setlinejoin 1 setlinecap } if } def
/LTw { PL [] 1 setgray } def
/LTb { BL [] 0 0 0 DL } def
/LTa { AL [1 udl mul 2 udl mul] 0 setdash 0 0 0 setrgbcolor } def
/LT0 { PL [] 1 0 0 DL } def
/LT1 { PL [4 dl 2 dl] 0 1 0 DL } def
/LT2 { PL [2 dl 3 dl] 0 0 1 DL } def
/LT3 { PL [1 dl 1.5 dl] 1 0 1 DL } def
/LT4 { PL [5 dl 2 dl 1 dl 2 dl] 0 1 1 DL } def
/LT5 { PL [4 dl 3 dl 1 dl 3 dl] 1 1 0 DL } def
/LT6 { PL [2 dl 2 dl 2 dl 4 dl] 0 0 0 DL } def
/LT7 { PL [2 dl 2 dl 2 dl 2 dl 2 dl 4 dl] 1 0.3 0 DL } def
/LT8 { PL [2 dl 2 dl 2 dl 2 dl 2 dl 2 dl 2 dl 4 dl] 0.5 0.5 0.5 DL } def
/Pnt { stroke [] 0 setdash
   gsave 1 setlinecap M 0 0 V stroke grestore } def
/Dia { stroke [] 0 setdash 2 copy vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath stroke
  Pnt } def
/Pls { stroke [] 0 setdash vpt sub M 0 vpt2 V
  currentpoint stroke M
  hpt neg vpt neg R hpt2 0 V stroke
  } def
/Box { stroke [] 0 setdash 2 copy exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V closepath stroke
  Pnt } def
/Crs { stroke [] 0 setdash exch hpt sub exch vpt add M
  hpt2 vpt2 neg V currentpoint stroke M
  hpt2 neg 0 R hpt2 vpt2 V stroke } def
/TriU { stroke [] 0 setdash 2 copy vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath stroke
  Pnt  } def
/Star { 2 copy Pls Crs } def
/BoxF { stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V  hpt2 0 V  0 vpt2 V
  hpt2 neg 0 V  closepath fill } def
/TriUF { stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath fill } def
/TriD { stroke [] 0 setdash 2 copy vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath stroke
  Pnt  } def
/TriDF { stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath fill} def
/DiaF { stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath fill } def
/Pent { stroke [] 0 setdash 2 copy gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath stroke grestore Pnt } def
/PentF { stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath fill grestore } def
/Circle { stroke [] 0 setdash 2 copy
  hpt 0 360 arc stroke Pnt } def
/CircleF { stroke [] 0 setdash hpt 0 360 arc fill } def
/C0 { BL [] 0 setdash 2 copy moveto vpt 90 450  arc } bind def
/C1 { BL [] 0 setdash 2 copy        moveto
       2 copy  vpt 0 90 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C2 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 90 180 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C3 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 0 180 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C4 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 180 270 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C5 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 0 90 arc
       2 copy moveto
       2 copy  vpt 180 270 arc closepath fill
               vpt 0 360 arc } bind def
/C6 { BL [] 0 setdash 2 copy moveto
      2 copy  vpt 90 270 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C7 { BL [] 0 setdash 2 copy moveto
      2 copy  vpt 0 270 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C8 { BL [] 0 setdash 2 copy moveto
      2 copy vpt 270 360 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C9 { BL [] 0 setdash 2 copy moveto
      2 copy  vpt 270 450 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C10 { BL [] 0 setdash 2 copy 2 copy moveto vpt 270 360 arc closepath fill
       2 copy moveto
       2 copy vpt 90 180 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C11 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 0 180 arc closepath fill
       2 copy moveto
       2 copy  vpt 270 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C12 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 180 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C13 { BL [] 0 setdash  2 copy moveto
       2 copy  vpt 0 90 arc closepath fill
       2 copy moveto
       2 copy  vpt 180 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C14 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 90 360 arc closepath fill
               vpt 0 360 arc } bind def
/C15 { BL [] 0 setdash 2 copy vpt 0 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/Rec   { newpath 4 2 roll moveto 1 index 0 rlineto 0 exch rlineto
       neg 0 rlineto closepath } bind def
/Square { dup Rec } bind def
/Bsquare { vpt sub exch vpt sub exch vpt2 Square } bind def
/S0 { BL [] 0 setdash 2 copy moveto 0 vpt rlineto BL Bsquare } bind def
/S1 { BL [] 0 setdash 2 copy vpt Square fill Bsquare } bind def
/S2 { BL [] 0 setdash 2 copy exch vpt sub exch vpt Square fill Bsquare } bind def
/S3 { BL [] 0 setdash 2 copy exch vpt sub exch vpt2 vpt Rec fill Bsquare } bind def
/S4 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt Square fill Bsquare } bind def
/S5 { BL [] 0 setdash 2 copy 2 copy vpt Square fill
       exch vpt sub exch vpt sub vpt Square fill Bsquare } bind def
/S6 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill Bsquare } bind def
/S7 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill
       2 copy vpt Square fill
       Bsquare } bind def
/S8 { BL [] 0 setdash 2 copy vpt sub vpt Square fill Bsquare } bind def
/S9 { BL [] 0 setdash 2 copy vpt sub vpt vpt2 Rec fill Bsquare } bind def
/S10 { BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt Square fill
       Bsquare } bind def
/S11 { BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt2 vpt Rec fill
       Bsquare } bind def
/S12 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill Bsquare } bind def
/S13 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill
       2 copy vpt Square fill Bsquare } bind def
/S14 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill
       2 copy exch vpt sub exch vpt Square fill Bsquare } bind def
/S15 { BL [] 0 setdash 2 copy Bsquare fill Bsquare } bind def
/D0 { gsave translate 45 rotate 0 0 S0 stroke grestore } bind def
/D1 { gsave translate 45 rotate 0 0 S1 stroke grestore } bind def
/D2 { gsave translate 45 rotate 0 0 S2 stroke grestore } bind def
/D3 { gsave translate 45 rotate 0 0 S3 stroke grestore } bind def
/D4 { gsave translate 45 rotate 0 0 S4 stroke grestore } bind def
/D5 { gsave translate 45 rotate 0 0 S5 stroke grestore } bind def
/D6 { gsave translate 45 rotate 0 0 S6 stroke grestore } bind def
/D7 { gsave translate 45 rotate 0 0 S7 stroke grestore } bind def
/D8 { gsave translate 45 rotate 0 0 S8 stroke grestore } bind def
/D9 { gsave translate 45 rotate 0 0 S9 stroke grestore } bind def
/D10 { gsave translate 45 rotate 0 0 S10 stroke grestore } bind def
/D11 { gsave translate 45 rotate 0 0 S11 stroke grestore } bind def
/D12 { gsave translate 45 rotate 0 0 S12 stroke grestore } bind def
/D13 { gsave translate 45 rotate 0 0 S13 stroke grestore } bind def
/D14 { gsave translate 45 rotate 0 0 S14 stroke grestore } bind def
/D15 { gsave translate 45 rotate 0 0 S15 stroke grestore } bind def
/DiaE { stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath stroke } def
/BoxE { stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V closepath stroke } def
/TriUE { stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath stroke } def
/TriDE { stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath stroke } def
/PentE { stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath stroke grestore } def
/CircE { stroke [] 0 setdash 
  hpt 0 360 arc stroke } def
/Opaque { gsave closepath 1 setgray fill grestore 0 setgray closepath } def
/DiaW { stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V Opaque stroke } def
/BoxW { stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V Opaque stroke } def
/TriUW { stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V Opaque stroke } def
/TriDW { stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V Opaque stroke } def
/PentW { stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  Opaque stroke grestore } def
/CircW { stroke [] 0 setdash 
  hpt 0 360 arc Opaque stroke } def
/BoxFill { gsave Rec 1 setgray fill grestore } def
/BoxColFill {
  gsave Rec
  /Fillden exch def
  currentrgbcolor
  /ColB exch def /ColG exch def /ColR exch def
  /ColR ColR Fillden mul Fillden sub 1 add def
  /ColG ColG Fillden mul Fillden sub 1 add def
  /ColB ColB Fillden mul Fillden sub 1 add def
  ColR ColG ColB setrgbcolor
  fill grestore } def
/PatternFill { gsave /PFa [ 9 2 roll ] def
    PFa 0 get PFa 2 get 2 div add PFa 1 get PFa 3 get 2 div add translate
    PFa 2 get -2 div PFa 3 get -2 div PFa 2 get PFa 3 get Rec
    gsave 1 setgray fill grestore clip
    currentlinewidth 0.5 mul setlinewidth
    /PFs PFa 2 get dup mul PFa 3 get dup mul add sqrt def
    0 0 M PFa 5 get rotate PFs -2 div dup translate
	0 1 PFs PFa 4 get div 1 add floor cvi
	{ PFa 4 get mul 0 M 0 PFs V } for
    0 PFa 6 get ne {
	0 1 PFs PFa 4 get div 1 add floor cvi
	{ PFa 4 get mul 0 2 1 roll M PFs 0 V } for
    } if
    stroke grestore } def
/Symbol-Oblique /Symbol findfont [1 0 .167 1 0 0] makefont
dup length dict begin {1 index /FID eq {pop pop} {def} ifelse} forall
currentdict end definefont pop
end
gnudict begin
gsave
0 0 translate
0.100 0.100 scale
0 setgray
newpath
1.000 UL
LTb
gsave /maxcolors 0 def
/HSV2RGB {  exch dup 0.0 eq {pop exch pop dup dup} { /HSVs exch def /HSVv exch def 6.0 mul dup floor dup 3 1 roll sub
     /HSVf exch def /HSVi exch cvi def /HSVp HSVv 1.0 HSVs sub mul def
	 /HSVq HSVv 1.0 HSVs HSVf mul sub mul def 
	 /HSVt HSVv 1.0 HSVs 1.0 HSVf sub mul sub mul def
	 /HSVi HSVi 6 mod def 0 HSVi eq {HSVv HSVt HSVp}
	 {1 HSVi eq {HSVq HSVv HSVp}{2 HSVi eq {HSVp HSVv HSVt}
	 {3 HSVi eq {HSVp HSVq HSVv}{4 HSVi eq {HSVt HSVp HSVv}
	 {HSVv HSVp HSVq} ifelse} ifelse} ifelse} ifelse} ifelse
  } ifelse} def
/Constrain {
  dup 0 lt {0 exch pop}{dup 1 gt {1 exch pop} if} ifelse} def
/YIQ2RGB {
  3 copy -1.702 mul exch -1.105 mul add add Constrain 4 1 roll
  3 copy -0.647 mul exch -0.272 mul add add Constrain 5 1 roll
  0.621 mul exch -0.956 mul add add Constrain 3 1 roll } def
/CMY2RGB {  1 exch sub exch 1 exch sub 3 2 roll 1 exch sub 3 1 roll exch } def
/XYZ2RGB {  3 copy -0.9017 mul exch -0.1187 mul add exch 0.0585 mul exch add
  Constrain 4 1 roll 3 copy -0.0279 mul exch 1.999 mul add exch
  -0.9844 mul add Constrain 5 1 roll -0.2891 mul exch -0.5338 mul add
  exch 1.91 mul exch add Constrain 3 1 roll} def
/SelectSpace {ColorSpace (HSV) eq {HSV2RGB}{ColorSpace (XYZ) eq {
  XYZ2RGB}{ColorSpace (CMY) eq {CMY2RGB}{ColorSpace (YIQ) eq {YIQ2RGB}
  if} ifelse} ifelse} ifelse} def
/maxcolorsLast {maxcolors 1 sub maxcolors div} def
/pm3dround {maxcolors 0 gt {dup maxcolorsLast ge {pop 1}
{maxcolors mul floor maxcolors div} ifelse} if} def
/pm3dGamma 1.0 1.5 div def
/ColorSpace (RGB) def
Color false and { InterpolatedColor { /g {stroke pm3dround /grayv exch def interpolate
        SelectSpace setrgbcolor} bind def
  }{
  /g {stroke pm3dround dup cF7 Constrain exch dup cF5 Constrain exch cF15 Constrain 
       SelectSpace setrgbcolor} bind def
  } ifelse
}{
  /g {stroke pm3dround pm3dGamma exp setgray} bind def
} ifelse
/h {rlineto rlineto rlineto fill} bind def
stroke gsave	maxcolors 0 gt {/imax maxcolors def} {/imax 1024 def} ifelse
3125 982 translate 129 646 scale 0 setlinewidth
/ystep 1 imax div def /y0 0 def /ii 0 def
{ y0 g 0 y0 N 1 0 V 0 ystep V -1 0 f
/y0 y0 ystep add def /ii ii 1 add def
ii imax ge {exit} if } loop
grestore 0 setgray
1.000 UL
LTb
3125 982 M
129 0 V
0 646 V
-129 0 V
0 -646 V
1.000 UL
LTb
1.000 UL
LTb
3254 982 M
-63 0 V
1.000 UL
LTb
3125 982 M
63 0 V
66 71 R
-63 0 V
1.000 UL
LTb
3125 1053 M
63 0 V
66 72 R
-63 0 V
1.000 UL
LTb
3125 1125 M
63 0 V
66 72 R
-63 0 V
1.000 UL
LTb
3125 1197 M
63 0 V
66 72 R
-63 0 V
1.000 UL
LTb
3125 1269 M
63 0 V
66 71 R
-63 0 V
1.000 UL
LTb
3125 1340 M
63 0 V
66 72 R
-63 0 V
1.000 UL
LTb
3125 1412 M
63 0 V
66 72 R
-63 0 V
1.000 UL
LTb
3125 1484 M
63 0 V
66 72 R
-63 0 V
1.000 UL
LTb
3125 1556 M
63 0 V
66 71 R
-63 0 V
1.000 UL
LTb
3125 1627 M
63 0 V
1.000 UP
2.000 UL
LT0
2267 1259 M
116 -108 V
2.000 UL
LT0
2149 1012 M
234 139 V
2.000 UL
LT0
2498 1107 M
-115 44 V
2.000 UL
LT0
2265 989 M
233 118 V
2.000 UL
LT0
2614 1084 M
-116 23 V
2.000 UL
LT0
2036 1498 M
115 -194 V
2.000 UL
LT0
1918 1164 M
233 140 V
2.000 UL
LT0
2267 1259 M
-116 45 V
2.000 UL
LT0
2380 945 M
234 139 V
2.000 UL
LT0
2730 1061 M
-116 23 V
2.000 UL
LT0
2033 1162 M
234 97 V
2.000 UL
LT0
2496 922 M
234 139 V
2.000 UL
LT0
2845 1038 M
-115 23 V
2.000 UL
LT0
2612 899 M
233 139 V
2.000 UL
LT0
2961 1015 M
-116 23 V
2.000 UL
LT0
2727 876 M
234 139 V
2.000 UL
LT0
3077 992 M
-116 23 V
2.000 UL
LT0
1804 1758 M
116 -237 V
2.000 UL
LT0
1687 1424 M
233 97 V
2.000 UL
LT0
2036 1498 M
-116 23 V
2.000 UL
LT0
2843 853 M
234 139 V
2.000 UL
LT0
1802 1315 M
234 183 V
2.000 UL
LT0
2033 1162 M
116 -150 V
2.000 UL
LT0
1915 872 M
234 140 V
2.000 UL
LT0
2265 989 M
-116 23 V
2.000 UL
LT0
2031 828 M
234 161 V
2.000 UL
LT0
2380 945 M
-115 44 V
2.000 UL
LT0
1802 1315 M
116 -151 V
2.000 UL
LT0
1685 1068 M
233 96 V
2.000 UL
LT0
2033 1162 M
-115 2 V
2.000 UL
LT0
2147 805 M
233 140 V
2.000 UL
LT0
2496 922 M
-116 23 V
2.000 UL
LT0
1225 1708 M
233 140 V
2.000 UL
LT0
1574 1804 M
-116 44 V
2.000 UL
LT0
1574 1804 M
116 -66 V
2.000 UL
LT0
1456 1619 M
234 119 V
2.000 UL
LT0
1804 1758 M
-114 -20 V
2.000 UL
LT0
1340 1664 M
234 140 V
2.000 UL
LT0
2262 782 M
234 140 V
2.000 UL
LT0
2612 899 M
-116 23 V
2.000 UL
LT0
1800 1002 M
233 160 V
2.000 UL
LT0
2378 759 M
234 140 V
2.000 UL
LT0
2727 876 M
-115 23 V
2.000 UL
LT0
1572 1468 M
232 290 V
2.000 UL
LT0
1687 1424 M
115 -109 V
2.000 UL
LT0
1569 1261 M
233 54 V
2.000 UL
LT0
2494 736 M
233 140 V
2.000 UL
LT0
2843 853 M
-116 23 V
2.000 UL
LT0
2609 713 M
234 140 V
2.000 UL
LT0
1456 1619 M
116 -151 V
2.000 UL
LT0
1338 1371 M
234 97 V
2.000 UL
LT0
1687 1424 M
-115 44 V
2.000 UL
LT0
1453 1241 M
234 183 V
2.000 UL
LT0
1800 1002 M
1915 872 L
2.000 UL
LT0
1682 754 M
233 118 V
2.000 UL
LT0
2031 828 M
-116 44 V
2.000 UL
LT0
1798 688 M
233 140 V
2.000 UL
LT0
2147 805 M
-116 23 V
2.000 UL
LT0
1913 665 M
234 140 V
2.000 UL
LT0
2262 782 M
-115 23 V
2.000 UL
LT0
991 1526 M
234 182 V
2.000 UL
LT0
1340 1664 M
-115 44 V
2.000 UL
LT0
1106 1567 M
234 97 V
2.000 UL
LT0
1456 1619 M
-116 45 V
2.000 UL
LT0
1685 1068 M
115 -66 V
2.000 UL
LT0
1567 756 M
233 246 V
2.000 UL
LT0
1222 1458 M
234 161 V
2.000 UL
LT0
2028 642 M
234 140 V
2.000 UL
LT0
2378 759 M
-116 23 V
2.000 UL
LT0
1569 1261 M
116 -193 V
2.000 UL
LT0
1451 971 M
234 97 V
2.000 UL
LT0
2144 619 M
234 140 V
2.000 UL
LT0
2494 736 M
-116 23 V
2.000 UL
LT0
2260 596 M
234 140 V
2.000 UL
LT0
2609 713 M
-115 23 V
2.000 UL
LT0
1338 1371 M
115 -130 V
2.000 UL
LT0
1220 1273 M
233 -32 V
2.000 UL
LT0
1569 1261 M
-116 -20 V
2.000 UL
LT0
1451 971 M
1567 756 L
2.000 UL
LT0
1333 702 M
234 54 V
2.000 UL
LT0
1682 754 M
-115 2 V
2.000 UL
LT0
2375 573 M
234 140 V
2.000 UL
LT0
757 1386 M
234 140 V
2.000 UL
LT0
1106 1567 M
991 1526 L
2.000 UL
LT0
1682 754 M
116 -66 V
2.000 UL
LT0
1564 549 M
234 139 V
2.000 UL
LT0
1913 665 M
-115 23 V
2.000 UL
LT0
1449 593 M
233 161 V
2.000 UL
LT0
1222 1458 M
116 -87 V
2.000 UL
LT0
1104 1253 M
234 118 V
2.000 UL
LT0
1335 1058 M
234 203 V
2.000 UL
LT0
1680 526 M
233 139 V
2.000 UL
LT0
2028 642 M
-115 23 V
2.000 UL
LT0
1106 1567 M
116 -109 V
2.000 UL
LT0
988 1276 M
234 182 V
2.000 UL
LT0
1796 502 M
232 140 V
2.000 UL
LT0
2144 619 M
-116 23 V
2.000 UL
LT0
873 1406 M
233 161 V
2.000 UL
LT0
1910 479 M
234 140 V
2.000 UL
LT0
2260 596 M
-116 23 V
2.000 UL
LT0
1335 1058 M
116 -87 V
2.000 UL
LT0
1217 853 M
234 118 V
2.000 UL
LT0
2026 478 M
234 118 V
2.000 UL
LT0
2375 573 M
-115 23 V
2.000 UL
LT0
1220 1273 M
115 -215 V
2.000 UL
LT0
1102 919 M
233 139 V
2.000 UL
LT0
2142 433 M
233 140 V
2.000 UL
LT0
1333 702 M
1449 593 L
2.000 UL
LT0
1564 549 M
-115 44 V
2.000 UL
LT0
523 1268 M
234 118 V
2.000 UL
LT0
873 1406 M
757 1386 L
2.000 UL
LT0
873 1406 M
988 1276 L
2.000 UL
LT0
755 1158 M
233 118 V
2.000 UL
LT0
1104 1253 M
-116 23 V
2.000 UL
LT0
1680 526 M
-116 23 V
2.000 UL
LT0
870 1156 M
234 97 V
2.000 UL
LT0
1220 1273 M
-116 -20 V
2.000 UL
LT0
1796 502 M
-116 24 V
2.000 UL
LT0
1217 853 M
1333 702 L
2.000 UL
LT0
1910 479 M
-114 23 V
2.000 UL
LT0
639 1287 M
234 119 V
2.000 UL
LT0
2026 478 M
-116 1 V
2.000 UL
LT0
986 984 M
234 289 V
2.000 UL
LT0
1102 919 M
115 -66 V
2.000 UL
LT0
986 984 M
116 -65 V
2.000 UL
LT0
2142 433 M
-116 45 V
2.000 UL
LT0
870 1156 M
986 984 L
2.000 UL
LT0
639 1287 M
523 1268 L
2.000 UL
LT0
639 1287 M
755 1158 L
2.000 UL
LT0
870 1156 M
-115 2 V
.9074 g 1457 1848 N -115 44 -234 -140 116 -44 h
.9074 g 1224 1708 N -115 -41 -234 -97 115 -44 h
.8981 g 990 1526 N -116 -20 -233 -161 115 41 h
.9074 g 756 1386 N -116 -19 -234 -119 116 20 h
.8611 g 1573 1804 N -116 45 -234 -119 116 -66 h
.8796 g 1339 1664 N -116 109 -234 -161 116 -45 h
.8611 g 1105 1567 N -115 130 -234 -182 116 -109 h
.8519 g 872 1406 N -116 129 -233 -118 115 -130 h
.7963 g 1689 1738 N -116 151 -233 -290 115 20 h
.75 g 1455 1619 N -116 87 -234 -97 116 -151 h
.75 g 1221 1458 N -116 23 -234 -118 116 -87 h
.7685 g 987 1276 N -115 2 -234 -97 116 -23 h
.6574 g 1804 1758 N -115 44 -234 -97 116 -237 h
.6111 g 1571 1468 N -115 130 -234 -183 115 -44 h
.6944 g 1337 1371 N -116 -20 -233 32 115 -130 h
.7315 g 1103 1253 N -116 173 -234 -290 116 20 h
.5185 g 1920 1521 N -116 109 -234 -183 116 -23 h
.537 g 1686 1424 N -116 -20 -234 -54 116 -109 h
.6019 g 1452 1241 N -115 216 -234 -204 116 20 h
.5833 g 1219 1273 N -116 65 -233 -139 115 -216 h
.3519 g 2036 1498 N -116 151 -233 -140 115 -194 h
.3889 g 1802 1315 N -116 194 -234 -97 116 -151 h
.4352 g 1568 1261 N -116 87 -234 -97 116 -194 h
.4352 g 1334 1057 N -115 66 -234 -118 116 -87 h
.2222 g 2151 1304 N -115 2 -234 -97 116 -45 h
.25 g 1918 1164 N -115 66 -234 -161 115 -2 h
.2315 g 1684 1067 N -116 215 -233 -246 115 -66 h
.25 g 1450 970 N -116 151 -234 -54 116 -215 h
.1296 g 2267 1259 N -116 151 -234 -140 116 -108 h
.1389 g 2033 1162 N -116 130 -234 -140 116 -151 h
.0926 g 1799 1001 N -115 2 -234 -118 116 -130 h
.0833 g 1566 755 N -116 109 -233 -161 115 -2 h
.0278 g 2383 1151 N -116 23 -233 -118 115 -45 h
.0278 g 2149 1011 N -116 44 -234 -161 116 -23 h
.0278 g 1915 871 N -116 66 -234 -140 116 -44 h
.0278 g 1681 753 N -115 44 -234 -139 116 -66 h
.0093 g 2498 1106 N -115 44 -234 -139 116 -23 h
.0093 g 2265 988 N -116 23 -233 -140 115 -44 h
0 g 2031 827 N -116 23 -234 -140 116 -23 h
0 g 1797 687 N -116 23 -234 -139 116 -23 h
0 g 2614 1083 N -116 23 -234 -139 116 -23 h
0 g 2380 944 N -115 23 -234 -140 116 -23 h
0 g 2147 804 N -115 23 -234 -140 115 -23 h
0 g 1913 664 N -116 24 -233 -140 115 -23 h
0 g 2730 1060 N -116 23 -233 -139 115 -23 h
0 g 2496 921 N -116 23 -234 -140 116 -23 h
0 g 2262 781 N -116 23 -234 -140 116 -23 h
0 g 2028 641 N -115 23 -234 -140 116 -23 h
0 g 2845 1037 N -115 23 -234 -139 116 -23 h
0 g 2612 898 N -116 23 -233 -140 115 -23 h
0 g 2378 758 N -116 23 -234 -140 116 -23 h
.0093 g 2144 618 N -116 1 -234 -118 116 -23 h
0 g 2961 1014 N -116 23 -234 -139 116 -23 h
0 g 2727 875 N -115 23 -234 -140 116 -23 h
0 g 2494 735 N -115 23 -234 -140 115 -23 h
.0093 g 2260 595 N -116 45 -233 -140 115 -23 h
2.000 UL
LT0
1.000 UL
LTb
2142 305 M
935 559 V
1.000 UL
LTb
2142 305 M
523 628 L
1.000 UL
LTb
523 628 M
531 317 V
1.000 UL
LTb
3077 864 M
-161 32 V
1.000 UL
LTb
523 1396 M
0 -768 V
1.000 UL
LTb
3077 992 M
0 -128 V
1.000 UL
LTb
2142 433 M
0 -128 V
1.000 UL
LTa
1968 340 M
163 97 V
1.000 UL
LTb
1968 340 M
59 35 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTa
1680 397 M
160 96 V
1.000 UL
LTb
1680 397 M
59 35 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTa
1391 455 M
163 98 V
1.000 UL
LTb
1391 455 M
59 35 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTa
1102 513 M
264 158 V
1.000 UL
LTb
1102 513 M
58 35 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTa
812 570 M
427 255 V
1.000 UL
LTb
812 570 M
59 35 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTa
523 628 M
531 317 V
1.000 UL
LTb
523 628 M
59 35 V
1.000 UL
LTb
1.000 UL
LTb
LTb
1.000 UL
LTa
2142 305 M
523 628 L
1.000 UL
LTb
2142 305 M
-55 11 V
1.000 UL
LTb
1.000 UL
LTb
578 617 M
-55 11 V
1.000 UL
LTa
1399 640 M
757 768 L
1.000 UL
LTa
2375 445 M
-160 32 V
1.000 UL
LTb
2375 445 M
-54 11 V
1.000 UL
LTb
1.000 UL
LTb
812 757 M
-55 11 V
1.000 UL
LTa
1192 867 M
991 907 L
1.000 UL
LTa
2609 585 M
-161 32 V
1.000 UL
LTb
2609 585 M
-54 10 V
1.000 UL
LTb
1.000 UL
LTb
1045 896 M
-54 11 V
1.000 UL
LTa
2843 724 M
-161 32 V
1.000 UL
LTb
2843 724 M
-55 11 V
1.000 UL
LTb
1.000 UL
LTa
3077 864 M
-161 32 V
1.000 UL
LTb
3077 864 M
-55 11 V
1.000 UL
LTb
LTb
1.000 UL
LTb
586 1396 M
-63 0 V
1.000 UL
LTb
1.000 UL
LTb
586 1268 M
-63 0 V
1.000 UL
LTb
1.000 UL
LTb
586 1140 M
-63 0 V
1.000 UL
LTb
1.000 UL
LTb
586 1012 M
-63 0 V
1.000 UL
LTb
1.000 UL
LTb
586 884 M
-63 0 V
1.000 UL
LTb
1.000 UL
LTb
586 756 M
-63 0 V
1.000 UL
LTb
1.000 UL
LTb
586 628 M
-63 0 V
1.000 UL
LTb
LTb
1.000 UP
grestore stroke
grestore
end
showpage
}}\put(522,1610){\cjust{Density of universal}}\put(397,756){\rjust{0}}\put(397,884){\rjust{0.2}}\put(397,1012){\rjust{0.4}}\put(397,1140){\rjust{0.6}}\put(397,1268){\rjust{0.8}}\put(397,1396){\rjust{1}}\put(2960,490){\special{ps: gsave currentpoint currentpoint translate
-34.5 rotate neg exch neg exch translate}\cstack{\cjust{f - accepting density}}\special{ps: currentpoint grestore moveto}}\put(3157,823){\cjust{0.1}}\put(2946,697){\cjust{0.3}}\put(2713,557){\cjust{0.5}}\put(2479,418){\cjust{0.7}}\put(2245,278){\cjust{0.9}}\put(1099,280){\special{ps: gsave currentpoint currentpoint translate
10.5 rotate neg exch neg exch translate}\cstack{\cjust{r - transition density}}\special{ps: currentpoint grestore moveto}}\put(477,572){\rjust{ 3}}\put(766,515){\rjust{ 2.5}}\put(1055,457){\rjust{ 2}}\put(1344,399){\rjust{ 1.5}}\put(1633,342){\rjust{ 1}}\put(1922,284){\rjust{ 0.5}}\put(3304,1627){\ljust{ 0.9}}\put(3304,1484){\ljust{ 0.7}}\put(3304,1340){\ljust{ 0.5}}\put(3304,1197){\ljust{ 0.3}}\put(3304,1053){\ljust{ 0.1}}\endGNUPLOTpicture
\endgroup
%
 }
    \caption{\protect\parbox[t]{45mm}{Density of universal automata for the samples of \figurename~\ref{fig:median-time}.}}
    \label{fig:density}
 \end{minipage}
\end{figure}

\begin{figure}[!tbp]
    \scalebox{0.5}{\begingroup
  \catcode`\@=11\relax
  \def\GNUPLOTspecial{\def\do##1{\catcode`##1=12\relax}\dospecials
    \catcode`\{=1\catcode`\}=2\catcode\%=14\relax\special}\expandafter\ifx\csname GNUPLOTpicture\endcsname\relax
  \csname newdimen\endcsname\GNUPLOTunit
  \gdef\GNUPLOTpicture(#1,#2){\vbox to#2\GNUPLOTunit\bgroup
    \def\put(##1,##2)##3{\unskip\raise##2\GNUPLOTunit
      \hbox to0pt{\kern##1\GNUPLOTunit ##3\hss}\ignorespaces}\def\ljust##1{\vbox to0pt{\vss\hbox to0pt{##1\hss}\vss}}\def\cjust##1{\vbox to0pt{\vss\hbox to0pt{\hss ##1\hss}\vss}}\def\rjust##1{\vbox to0pt{\vss\hbox to0pt{\hss ##1}\vss}}\def\stack##1{\let\\=\cr\tabskip=0pt\halign{\hfil ####\hfil\cr ##1\crcr}}\def\lstack##1{\hbox to0pt{\vbox to0pt{\vss\stack{##1}}\hss}}\def\cstack##1{\hbox to0pt{\hss\vbox to0pt{\vss\stack{##1}}\hss}}\def\rstack##1{\hbox to0pt{\vbox to0pt{\stack{##1}\vss}\hss}}\vss\hbox to#1\GNUPLOTunit\bgroup\ignorespaces}\gdef\endGNUPLOTpicture{\hss\egroup\egroup}\fi
\GNUPLOTunit=0.1bp
\GNUPLOTpicture(3600,2160)
{\GNUPLOTspecial{"
/gnudict 256 dict def
gnudict begin
/Color false def
/Solid false def
/gnulinewidth 5.000 def
/userlinewidth gnulinewidth def
/vshift -33 def
/dl {10.0 mul} def
/hpt_ 31.5 def
/vpt_ 31.5 def
/hpt hpt_ def
/vpt vpt_ def
/Rounded false def
/M {moveto} bind def
/L {lineto} bind def
/R {rmoveto} bind def
/V {rlineto} bind def
/N {newpath moveto} bind def
/C {setrgbcolor} bind def
/f {rlineto fill} bind def
/vpt2 vpt 2 mul def
/hpt2 hpt 2 mul def
/Lshow { currentpoint stroke M
  0 vshift R show } def
/Rshow { currentpoint stroke M
  dup stringwidth pop neg vshift R show } def
/Cshow { currentpoint stroke M
  dup stringwidth pop -2 div vshift R show } def
/UP { dup vpt_ mul /vpt exch def hpt_ mul /hpt exch def
  /hpt2 hpt 2 mul def /vpt2 vpt 2 mul def } def
/DL { Color {setrgbcolor Solid {pop []} if 0 setdash }
 {pop pop pop 0 setgray Solid {pop []} if 0 setdash} ifelse } def
/BL { stroke userlinewidth 2 mul setlinewidth
      Rounded { 1 setlinejoin 1 setlinecap } if } def
/AL { stroke userlinewidth 2 div setlinewidth
      Rounded { 1 setlinejoin 1 setlinecap } if } def
/UL { dup gnulinewidth mul /userlinewidth exch def
      dup 1 lt {pop 1} if 10 mul /udl exch def } def
/PL { stroke userlinewidth setlinewidth
      Rounded { 1 setlinejoin 1 setlinecap } if } def
/LTw { PL [] 1 setgray } def
/LTb { BL [] 0 0 0 DL } def
/LTa { AL [1 udl mul 2 udl mul] 0 setdash 0 0 0 setrgbcolor } def
/LT0 { PL [] 1 0 0 DL } def
/LT1 { PL [4 dl 2 dl] 0 1 0 DL } def
/LT2 { PL [2 dl 3 dl] 0 0 1 DL } def
/LT3 { PL [1 dl 1.5 dl] 1 0 1 DL } def
/LT4 { PL [5 dl 2 dl 1 dl 2 dl] 0 1 1 DL } def
/LT5 { PL [4 dl 3 dl 1 dl 3 dl] 1 1 0 DL } def
/LT6 { PL [2 dl 2 dl 2 dl 4 dl] 0 0 0 DL } def
/LT7 { PL [2 dl 2 dl 2 dl 2 dl 2 dl 4 dl] 1 0.3 0 DL } def
/LT8 { PL [2 dl 2 dl 2 dl 2 dl 2 dl 2 dl 2 dl 4 dl] 0.5 0.5 0.5 DL } def
/Pnt { stroke [] 0 setdash
   gsave 1 setlinecap M 0 0 V stroke grestore } def
/Dia { stroke [] 0 setdash 2 copy vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath stroke
  Pnt } def
/Pls { stroke [] 0 setdash vpt sub M 0 vpt2 V
  currentpoint stroke M
  hpt neg vpt neg R hpt2 0 V stroke
  } def
/Box { stroke [] 0 setdash 2 copy exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V closepath stroke
  Pnt } def
/Crs { stroke [] 0 setdash exch hpt sub exch vpt add M
  hpt2 vpt2 neg V currentpoint stroke M
  hpt2 neg 0 R hpt2 vpt2 V stroke } def
/TriU { stroke [] 0 setdash 2 copy vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath stroke
  Pnt  } def
/Star { 2 copy Pls Crs } def
/BoxF { stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V  hpt2 0 V  0 vpt2 V
  hpt2 neg 0 V  closepath fill } def
/TriUF { stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath fill } def
/TriD { stroke [] 0 setdash 2 copy vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath stroke
  Pnt  } def
/TriDF { stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath fill} def
/DiaF { stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath fill } def
/Pent { stroke [] 0 setdash 2 copy gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath stroke grestore Pnt } def
/PentF { stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath fill grestore } def
/Circle { stroke [] 0 setdash 2 copy
  hpt 0 360 arc stroke Pnt } def
/CircleF { stroke [] 0 setdash hpt 0 360 arc fill } def
/C0 { BL [] 0 setdash 2 copy moveto vpt 90 450  arc } bind def
/C1 { BL [] 0 setdash 2 copy        moveto
       2 copy  vpt 0 90 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C2 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 90 180 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C3 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 0 180 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C4 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 180 270 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C5 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 0 90 arc
       2 copy moveto
       2 copy  vpt 180 270 arc closepath fill
               vpt 0 360 arc } bind def
/C6 { BL [] 0 setdash 2 copy moveto
      2 copy  vpt 90 270 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C7 { BL [] 0 setdash 2 copy moveto
      2 copy  vpt 0 270 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C8 { BL [] 0 setdash 2 copy moveto
      2 copy vpt 270 360 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C9 { BL [] 0 setdash 2 copy moveto
      2 copy  vpt 270 450 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C10 { BL [] 0 setdash 2 copy 2 copy moveto vpt 270 360 arc closepath fill
       2 copy moveto
       2 copy vpt 90 180 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C11 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 0 180 arc closepath fill
       2 copy moveto
       2 copy  vpt 270 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C12 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 180 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C13 { BL [] 0 setdash  2 copy moveto
       2 copy  vpt 0 90 arc closepath fill
       2 copy moveto
       2 copy  vpt 180 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C14 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 90 360 arc closepath fill
               vpt 0 360 arc } bind def
/C15 { BL [] 0 setdash 2 copy vpt 0 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/Rec   { newpath 4 2 roll moveto 1 index 0 rlineto 0 exch rlineto
       neg 0 rlineto closepath } bind def
/Square { dup Rec } bind def
/Bsquare { vpt sub exch vpt sub exch vpt2 Square } bind def
/S0 { BL [] 0 setdash 2 copy moveto 0 vpt rlineto BL Bsquare } bind def
/S1 { BL [] 0 setdash 2 copy vpt Square fill Bsquare } bind def
/S2 { BL [] 0 setdash 2 copy exch vpt sub exch vpt Square fill Bsquare } bind def
/S3 { BL [] 0 setdash 2 copy exch vpt sub exch vpt2 vpt Rec fill Bsquare } bind def
/S4 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt Square fill Bsquare } bind def
/S5 { BL [] 0 setdash 2 copy 2 copy vpt Square fill
       exch vpt sub exch vpt sub vpt Square fill Bsquare } bind def
/S6 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill Bsquare } bind def
/S7 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill
       2 copy vpt Square fill
       Bsquare } bind def
/S8 { BL [] 0 setdash 2 copy vpt sub vpt Square fill Bsquare } bind def
/S9 { BL [] 0 setdash 2 copy vpt sub vpt vpt2 Rec fill Bsquare } bind def
/S10 { BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt Square fill
       Bsquare } bind def
/S11 { BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt2 vpt Rec fill
       Bsquare } bind def
/S12 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill Bsquare } bind def
/S13 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill
       2 copy vpt Square fill Bsquare } bind def
/S14 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill
       2 copy exch vpt sub exch vpt Square fill Bsquare } bind def
/S15 { BL [] 0 setdash 2 copy Bsquare fill Bsquare } bind def
/D0 { gsave translate 45 rotate 0 0 S0 stroke grestore } bind def
/D1 { gsave translate 45 rotate 0 0 S1 stroke grestore } bind def
/D2 { gsave translate 45 rotate 0 0 S2 stroke grestore } bind def
/D3 { gsave translate 45 rotate 0 0 S3 stroke grestore } bind def
/D4 { gsave translate 45 rotate 0 0 S4 stroke grestore } bind def
/D5 { gsave translate 45 rotate 0 0 S5 stroke grestore } bind def
/D6 { gsave translate 45 rotate 0 0 S6 stroke grestore } bind def
/D7 { gsave translate 45 rotate 0 0 S7 stroke grestore } bind def
/D8 { gsave translate 45 rotate 0 0 S8 stroke grestore } bind def
/D9 { gsave translate 45 rotate 0 0 S9 stroke grestore } bind def
/D10 { gsave translate 45 rotate 0 0 S10 stroke grestore } bind def
/D11 { gsave translate 45 rotate 0 0 S11 stroke grestore } bind def
/D12 { gsave translate 45 rotate 0 0 S12 stroke grestore } bind def
/D13 { gsave translate 45 rotate 0 0 S13 stroke grestore } bind def
/D14 { gsave translate 45 rotate 0 0 S14 stroke grestore } bind def
/D15 { gsave translate 45 rotate 0 0 S15 stroke grestore } bind def
/DiaE { stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath stroke } def
/BoxE { stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V closepath stroke } def
/TriUE { stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath stroke } def
/TriDE { stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath stroke } def
/PentE { stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath stroke grestore } def
/CircE { stroke [] 0 setdash 
  hpt 0 360 arc stroke } def
/Opaque { gsave closepath 1 setgray fill grestore 0 setgray closepath } def
/DiaW { stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V Opaque stroke } def
/BoxW { stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V Opaque stroke } def
/TriUW { stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V Opaque stroke } def
/TriDW { stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V Opaque stroke } def
/PentW { stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  Opaque stroke grestore } def
/CircW { stroke [] 0 setdash 
  hpt 0 360 arc Opaque stroke } def
/BoxFill { gsave Rec 1 setgray fill grestore } def
/BoxColFill {
  gsave Rec
  /Fillden exch def
  currentrgbcolor
  /ColB exch def /ColG exch def /ColR exch def
  /ColR ColR Fillden mul Fillden sub 1 add def
  /ColG ColG Fillden mul Fillden sub 1 add def
  /ColB ColB Fillden mul Fillden sub 1 add def
  ColR ColG ColB setrgbcolor
  fill grestore } def
/PatternFill { gsave /PFa [ 9 2 roll ] def
    PFa 0 get PFa 2 get 2 div add PFa 1 get PFa 3 get 2 div add translate
    PFa 2 get -2 div PFa 3 get -2 div PFa 2 get PFa 3 get Rec
    gsave 1 setgray fill grestore clip
    currentlinewidth 0.5 mul setlinewidth
    /PFs PFa 2 get dup mul PFa 3 get dup mul add sqrt def
    0 0 M PFa 5 get rotate PFs -2 div dup translate
	0 1 PFs PFa 4 get div 1 add floor cvi
	{ PFa 4 get mul 0 M 0 PFs V } for
    0 PFa 6 get ne {
	0 1 PFs PFa 4 get div 1 add floor cvi
	{ PFa 4 get mul 0 2 1 roll M PFs 0 V } for
    } if
    stroke grestore } def
/Symbol-Oblique /Symbol findfont [1 0 .167 1 0 0] makefont
dup length dict begin {1 index /FID eq {pop pop} {def} ifelse} forall
currentdict end definefont pop
end
gnudict begin
gsave
0 0 translate
0.100 0.100 scale
0 setgray
newpath
1.000 UL
LTb
gsave /maxcolors 0 def
/HSV2RGB {  exch dup 0.0 eq {pop exch pop dup dup} { /HSVs exch def /HSVv exch def 6.0 mul dup floor dup 3 1 roll sub
     /HSVf exch def /HSVi exch cvi def /HSVp HSVv 1.0 HSVs sub mul def
	 /HSVq HSVv 1.0 HSVs HSVf mul sub mul def 
	 /HSVt HSVv 1.0 HSVs 1.0 HSVf sub mul sub mul def
	 /HSVi HSVi 6 mod def 0 HSVi eq {HSVv HSVt HSVp}
	 {1 HSVi eq {HSVq HSVv HSVp}{2 HSVi eq {HSVp HSVv HSVt}
	 {3 HSVi eq {HSVp HSVq HSVv}{4 HSVi eq {HSVt HSVp HSVv}
	 {HSVv HSVp HSVq} ifelse} ifelse} ifelse} ifelse} ifelse
  } ifelse} def
/Constrain {
  dup 0 lt {0 exch pop}{dup 1 gt {1 exch pop} if} ifelse} def
/YIQ2RGB {
  3 copy -1.702 mul exch -1.105 mul add add Constrain 4 1 roll
  3 copy -0.647 mul exch -0.272 mul add add Constrain 5 1 roll
  0.621 mul exch -0.956 mul add add Constrain 3 1 roll } def
/CMY2RGB {  1 exch sub exch 1 exch sub 3 2 roll 1 exch sub 3 1 roll exch } def
/XYZ2RGB {  3 copy -0.9017 mul exch -0.1187 mul add exch 0.0585 mul exch add
  Constrain 4 1 roll 3 copy -0.0279 mul exch 1.999 mul add exch
  -0.9844 mul add Constrain 5 1 roll -0.2891 mul exch -0.5338 mul add
  exch 1.91 mul exch add Constrain 3 1 roll} def
/SelectSpace {ColorSpace (HSV) eq {HSV2RGB}{ColorSpace (XYZ) eq {
  XYZ2RGB}{ColorSpace (CMY) eq {CMY2RGB}{ColorSpace (YIQ) eq {YIQ2RGB}
  if} ifelse} ifelse} ifelse} def
/maxcolorsLast {maxcolors 1 sub maxcolors div} def
/pm3dround {maxcolors 0 gt {dup maxcolorsLast ge {pop 1}
{maxcolors mul floor maxcolors div} ifelse} if} def
/pm3dGamma 1.0 1.5 div def
/ColorSpace (RGB) def
Color false and { InterpolatedColor { /g {stroke pm3dround /grayv exch def interpolate
        SelectSpace setrgbcolor} bind def
  }{
  /g {stroke pm3dround dup cF7 Constrain exch dup cF5 Constrain exch cF15 Constrain 
       SelectSpace setrgbcolor} bind def
  } ifelse
}{
  /g {stroke pm3dround pm3dGamma exp setgray} bind def
} ifelse
/h {rlineto rlineto rlineto fill} bind def
stroke gsave	maxcolors 0 gt {/imax maxcolors def} {/imax 1024 def} ifelse
3125 982 translate 129 646 scale 0 setlinewidth
/ystep 1 imax div def /y0 0 def /ii 0 def
{ y0 g 0 y0 N 1 0 V 0 ystep V -1 0 f
/y0 y0 ystep add def /ii ii 1 add def
ii imax ge {exit} if } loop
grestore 0 setgray
1.000 UL
LTb
3125 982 M
129 0 V
0 646 V
-129 0 V
0 -646 V
1.000 UL
LTb
1.000 UL
LTb
3254 982 M
-63 0 V
1.000 UL
LTb
3125 982 M
63 0 V
66 80 R
-63 0 V
1.000 UL
LTb
3125 1062 M
63 0 V
66 81 R
-63 0 V
1.000 UL
LTb
3125 1143 M
63 0 V
66 81 R
-63 0 V
1.000 UL
LTb
3125 1224 M
63 0 V
66 81 R
-63 0 V
1.000 UL
LTb
3125 1305 M
63 0 V
66 80 R
-63 0 V
1.000 UL
LTb
3125 1385 M
63 0 V
66 81 R
-63 0 V
1.000 UL
LTb
3125 1466 M
63 0 V
66 81 R
-63 0 V
1.000 UL
LTb
3125 1547 M
63 0 V
66 81 R
-63 0 V
1.000 UL
LTb
3125 1628 M
63 0 V
1.000 UP
1.000 UL
LT0
1588 1113 M
-81 173 V
1.000 UL
LT0
1638 1396 M
1507 1286 L
1.000 UL
LT0
1375 1303 M
132 -17 V
1.000 UL
LT0
1456 1164 M
-81 139 V
1.000 UL
LT0
1244 1361 M
131 -58 V
1.000 UL
LT0
1719 1135 M
-81 261 V
1.000 UL
LT0
1770 1527 M
1638 1396 L
1.000 UL
LT0
1325 1213 M
-81 148 V
1.000 UL
LT0
1112 1466 M
132 -105 V
1.000 UL
LT0
1850 1168 M
-80 359 V
1.000 UL
LT0
1900 1637 M
1770 1527 L
1.000 UL
LT0
1669 937 M
-81 176 V
1.000 UL
LT0
1719 1135 M
-131 -22 V
1.000 UL
LT0
1456 1164 M
132 -51 V
1.000 UL
LT0
1800 945 M
-81 190 V
1.000 UL
LT0
1850 1168 M
-131 -33 V
1.000 UL
LT0
1931 999 M
-81 169 V
1.000 UL
LT0
1981 1253 M
-131 -85 V
1.000 UL
LT0
2639 1518 M
-81 159 V
1.000 UL
LT0
2426 1669 M
132 8 V
1.000 UL
LT0
1193 1307 M
-81 159 V
1.000 UL
LT0
980 1581 M
132 -115 V
1.000 UL
LT0
2508 1510 M
-82 159 V
1.000 UL
LT0
2295 1661 M
131 8 V
1.000 UL
LT0
2376 1502 M
-81 159 V
1.000 UL
LT0
2163 1653 M
132 8 V
1.000 UL
LT0
2244 1449 M
-81 204 V
1.000 UL
LT0
2032 1645 M
131 8 V
1.000 UL
LT0
2113 1349 M
-81 296 V
1.000 UL
LT0
1900 1637 M
132 8 V
1.000 UL
LT0
1537 1007 M
-81 157 V
1.000 UL
LT0
1325 1213 M
131 -49 V
1.000 UL
LT0
1981 1253 M
-81 384 V
1.000 UL
LT0
2063 1039 M
-82 214 V
1.000 UL
LT0
2113 1349 M
-132 -96 V
1.000 UL
LT0
1406 1055 M
-81 158 V
1.000 UL
LT0
1193 1307 M
132 -94 V
1.000 UL
LT0
2194 1047 M
-81 302 V
1.000 UL
LT0
2244 1449 M
2113 1349 L
1.000 UL
LT0
1062 1422 M
-82 159 V
1.000 UL
LT0
849 1573 M
131 8 V
1.000 UL
LT0
930 1414 M
-81 159 V
1.000 UL
LT0
717 1565 M
132 8 V
1.000 UL
LT0
799 1406 M
-82 159 V
1.000 UL
LT0
1881 709 M
-81 236 V
1.000 UL
LT0
1931 999 M
1800 945 L
1.000 UL
LT0
1669 937 M
131 8 V
1.000 UL
LT0
1750 733 M
-81 204 V
1.000 UL
LT0
1537 1007 M
132 -70 V
1.000 UL
LT0
2407 896 M
-81 159 V
1.000 UL
LT0
2457 1080 M
-131 -25 V
1.000 UL
LT0
2244 1449 M
82 -394 V
1.000 UL
LT0
2194 1047 M
132 8 V
1.000 UL
LT0
2012 749 M
-81 250 V
1.000 UL
LT0
2063 1039 M
1931 999 L
1.000 UL
LT0
2538 936 M
-81 144 V
1.000 UL
LT0
2589 1156 M
-132 -76 V
1.000 UL
LT0
2376 1502 M
81 -422 V
1.000 UL
LT0
2376 1502 M
-132 -53 V
1.000 UL
LT0
2275 867 M
-81 180 V
1.000 UL
LT0
2063 1039 M
131 8 V
1.000 UL
LT0
2720 1237 M
-81 281 V
1.000 UL
LT0
2508 1510 M
131 8 V
1.000 UL
LT0
2144 820 M
-81 219 V
1.000 UL
LT0
1274 1148 M
-81 159 V
1.000 UL
LT0
1062 1422 M
131 -115 V
1.000 UL
LT0
2589 1156 M
-81 354 V
1.000 UL
LT0
2376 1502 M
132 8 V
1.000 UL
LT0
2670 957 M
-81 199 V
1.000 UL
LT0
2720 1237 M
-131 -81 V
1.000 UL
LT0
1619 827 M
-82 180 V
1.000 UL
LT0
1406 1055 M
131 -48 V
1.000 UL
LT0
1962 583 M
-81 126 V
1.000 UL
LT0
2012 749 M
1881 709 L
1.000 UL
LT0
1750 733 M
131 -24 V
1.000 UL
LT0
2801 977 M
-81 260 V
1.000 UL
LT0
1487 897 M
-81 158 V
1.000 UL
LT0
1274 1148 M
132 -93 V
1.000 UL
LT0
2093 558 M
-81 191 V
1.000 UL
LT0
2144 820 M
2012 749 L
1.000 UL
LT0
1143 1263 M
-81 159 V
1.000 UL
LT0
930 1414 M
132 8 V
1.000 UL
LT0
1830 620 M
-80 113 V
1.000 UL
LT0
1619 827 M
131 -94 V
1.000 UL
LT0
1011 1255 M
-81 159 V
1.000 UL
LT0
799 1406 M
131 8 V
1.000 UL
LT0
880 1247 M
-81 159 V
1.000 UL
LT0
2225 599 M
-81 221 V
1.000 UL
LT0
2275 867 M
2144 820 L
1.000 UL
LT0
2356 631 M
-81 236 V
1.000 UL
LT0
2407 896 M
2275 867 L
1.000 UL
LT0
2488 639 M
-81 257 V
1.000 UL
LT0
2538 936 M
2407 896 L
1.000 UL
LT0
2620 685 M
-82 251 V
1.000 UL
LT0
2670 957 M
2538 936 L
1.000 UL
LT0
2751 721 M
-81 236 V
1.000 UL
LT0
2801 977 M
2670 957 L
1.000 UL
LT0
2883 741 M
-82 236 V
1.000 UL
LT0
1356 991 M
-82 157 V
1.000 UL
LT0
1143 1263 M
131 -115 V
1.000 UL
LT0
1700 689 M
-81 138 V
1.000 UL
LT0
1487 897 M
132 -70 V
1.000 UL
LT0
2225 599 M
2093 558 L
1.000 UL
LT0
1962 583 M
131 -25 V
1.000 UL
LT0
2356 631 M
2225 599 L
1.000 UL
LT0
2620 685 M
2488 639 L
1.000 UL
LT0
2356 631 M
132 8 V
1.000 UL
LT0
1568 738 M
-81 159 V
1.000 UL
LT0
1356 991 M
131 -94 V
1.000 UL
LT0
1830 620 M
132 -37 V
1.000 UL
LT0
2751 721 M
2620 685 L
1.000 UL
LT0
1224 1105 M
-81 158 V
1.000 UL
LT0
1011 1255 M
132 8 V
1.000 UL
LT0
1092 1097 M
-81 158 V
1.000 UL
LT0
880 1247 M
131 8 V
1.000 UL
LT0
2883 741 M
2751 721 L
1.000 UL
LT0
961 1089 M
-81 158 V
1.000 UL
LT0
1700 689 M
130 -69 V
1.000 UL
LT0
1437 842 M
-81 149 V
1.000 UL
LT0
1224 1105 M
1356 991 L
1.000 UL
LT0
1568 738 M
132 -49 V
1.000 UL
LT0
1437 842 M
1568 738 L
1.000 UL
LT0
1305 946 M
-81 159 V
1.000 UL
LT0
1092 1097 M
132 8 V
1.000 UL
LT0
1174 938 M
-82 159 V
1.000 UL
LT0
961 1089 M
131 8 V
1.000 UL
LT0
1042 930 M
-81 159 V
1.000 UL
LT0
1305 946 M
1437 842 L
1.000 UL
LT0
1174 938 M
131 8 V
1.000 UL
LT0
1042 930 M
132 8 V
.9375 g 2639 1518 N 132 8 -82 159 -131 -8 h
.5875 g 2720 1237 N 131 8 -81 354 -131 -81 h
.1781 g 2801 976 N 131 81 -81 200 -131 -20 h
.0891 g 2883 740 N 131 20 -81 236 -132 -20 h
.9375 g 2508 1510 N 131 8 -81 159 -132 -8 h
.5313 g 2589 1156 N 132 8 -81 423 -132 -77 h
.1156 g 2670 956 N 132 77 -81 144 -132 -21 h
.0781 g 2751 720 N 132 21 -82 251 -131 -36 h
.8594 g 2376 1502 N 132 8 -81 204 -132 -53 h
.4312 g 2457 1079 N 132 53 -82 395 -131 -25 h
.0844 g 2538 935 N 131 25 -81 159 -131 -40 h
.0625 g 2620 684 N 131 40 -81 257 -132 -46 h
.6937 g 2244 1449 N 131 8 -81 296 -131 -100 h
.2625 g 2326 1054 N 131 100 -81 303 -132 -8 h
.0719 g 2407 895 N 132 8 -81 180 -132 -29 h
.05 g 2488 638 N 132 29 -81 236 -132 -8 h
.5687 g 2113 1349 N 132 8 -81 384 -132 -96 h
.1375 g 2194 1046 N 132 96 -82 215 -131 -8 h
.0641 g 2275 866 N 131 8 -81 219 -131 -47 h
.0406 g 2356 630 N 131 47 -81 221 -131 -32 h
.375 g 1981 1253 N 131 110 -81 359 -131 -85 h
.0797 g 2063 1038 N 131 85 -81 170 -132 -40 h
.05 g 2144 819 N 132 40 -81 250 -132 -71 h
.0281 g 2225 598 N 132 71 -81 191 -132 -41 h
.1531 g 1850 1168 N 132 131 -81 261 -132 -33 h
.0516 g 1931 998 N 132 33 -82 191 -131 -54 h
.0344 g 2012 748 N 131 54 -81 236 -131 -40 h
.0219 g 2093 557 N 131 40 -81 126 -131 25 h
.0672 g 1718 1135 N 131 110 -81 174 -131 -23 h
.0422 g 1800 944 N 131 23 -81 176 -132 -8 h
.0297 g 1881 708 N 132 8 -81 204 -132 24 h
.0266 g 1962 582 N 132 -24 -81 113 -132 37 h
.0578 g 1587 1112 N 132 -17 -81 139 -132 52 h
.0578 g 1668 936 N 132 -52 -81 158 -132 70 h
.05 g 1749 732 N 132 -70 -82 180 -131 94 h
.05 g 1830 619 N 131 -94 -81 138 -131 69 h
.0937 g 1455 1164 N 131 -58 -81 148 -131 49 h
.1 g 1536 1006 N 131 -49 -81 159 -131 48 h
.0969 g 1618 826 N 131 -48 -81 158 -132 70 h
.0969 g 1699 688 N 132 -70 -81 159 -132 49 h
.2156 g 1324 1213 N 132 -105 -81 159 -132 94 h
.2187 g 1405 1054 N 132 -94 -81 159 -132 94 h
.2187 g 1486 896 N 132 -94 -82 158 -131 94 h
.2266 g 1567 737 N 131 -94 -81 149 -131 104 h
.625 g 1192 1307 N 132 -115 -82 159 -131 115 h
.625 g 1273 1148 N 131 -115 -81 159 -131 115 h
.625 g 1355 990 N 131 -115 -81 159 -132 114 h
.6328 g 1436 841 N 132 -114 -81 159 -132 104 h
.9375 g 1061 1422 N 131 8 -81 159 -132 -8 h
.9375 g 1142 1263 N 132 8 -81 159 -132 -8 h
.9375 g 1223 1104 N 132 8 -81 159 -132 -8 h
.9375 g 1304 945 N 132 8 -82 159 -131 -8 h
.9375 g 929 1414 N 132 8 -82 159 -131 -8 h
.9375 g 1010 1255 N 131 8 -81 159 -131 -8 h
.9375 g 1091 1096 N 131 8 -81 159 -131 -8 h
.9375 g 1173 937 N 131 8 -81 159 -132 -8 h
1.000 UL
LT0
1.000 UL
LTb
1042 372 M
2883 484 L
1.000 UL
LTb
1042 372 M
717 1008 L
1.000 UL
LTb
717 1008 M
277 17 V
1.000 UL
LTb
2883 484 M
2761 722 L
1.000 UL
LTb
717 1565 M
0 -557 V
1.000 UL
LTb
717 1776 M
0 -211 V
1.000 UL
LTb
2883 741 M
0 -257 V
1.000 UL
LTb
1042 930 M
0 -558 V
1.000 UL
LTa
2870 483 M
2749 720 L
1.000 UL
LTb
2870 483 M
-21 40 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTa
2620 468 M
-95 184 V
1.000 UL
LTb
2620 468 M
-21 40 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTa
2356 452 M
-81 159 V
1.000 UL
LTb
2356 452 M
-20 40 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTa
2093 436 M
-69 135 V
1.000 UL
LTb
2093 436 M
-20 40 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTa
1830 420 M
1693 691 L
1.000 UL
LTb
1830 420 M
-20 40 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTa
1568 404 M
1292 945 L
1.000 UL
LTb
1568 404 M
-20 40 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTa
1305 388 M
980 1024 L
1.000 UL
LTb
1305 388 M
-20 40 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTb
1001 984 M
-21 40 V
1.000 UL
LTa
1042 372 M
717 1008 L
1.000 UL
LTb
1042 372 M
-20 40 V
1.000 UL
LTb
1.000 UL
LTb
1.000 UL
LTb
738 968 M
-21 40 V
LTb
1.000 UL
LTa
717 1008 M
277 17 V
1.000 UL
LTb
717 1008 M
62 3 V
1.000 UL
LTb
1.000 UL
LTa
799 849 M
584 35 V
1.000 UL
LTb
799 849 M
62 4 V
1.000 UL
LTb
1.000 UL
LTa
880 690 M
702 43 V
1.000 UL
LTb
880 690 M
62 4 V
1.000 UL
LTb
1.000 UL
LTa
2275 611 M
526 32 V
1.000 UL
LTa
961 531 M
973 59 V
1.000 UL
LTb
961 531 M
62 4 V
1.000 UL
LTb
1.000 UL
LTb
2739 639 M
62 4 V
1.000 UL
LTa
1034 388 M
2875 500 L
1.000 UL
LTb
1034 388 M
62 4 V
1.000 UL
LTb
1.000 UL
LTb
2812 496 M
63 4 V
LTb
1.000 UL
LTb
780 1776 M
-63 0 V
1.000 UL
LTb
1.000 UL
LTb
740 1519 M
-23 0 V
1.000 UL
LTb
1.000 UL
LTb
780 1263 M
-63 0 V
1.000 UL
LTb
1.000 UL
LTb
780 1008 M
-63 0 V
1.000 UL
LTb
LTb
1.000 UP
grestore stroke
grestore
end
showpage
}}\put(716,1968){\cjust{Number of locations}}\put(591,1263){\rjust{100}}\put(591,1519){\rjust{1000}}\put(591,1776){\rjust{10000}}\put(489,662){\special{ps: gsave currentpoint currentpoint translate
64.5 rotate neg exch neg exch translate}\cstack{\cjust{f - accepting density}}\special{ps: currentpoint grestore moveto}}\put(985,382){\rjust{0.1}}\put(912,525){\rjust{0.3}}\put(830,684){\rjust{0.5}}\put(749,843){\rjust{0.7}}\put(668,1002){\rjust{0.9}}\put(2043,200){\special{ps: gsave currentpoint currentpoint translate
-3.5 rotate neg exch neg exch translate}\cstack{\cjust{r - transition density}}\special{ps: currentpoint grestore moveto}}\put(1058,309){\cjust{0.2}}\put(1321,325){\cjust{0.6}}\put(1584,341){\cjust{1}}\put(1846,357){\cjust{1.4}}\put(2110,373){\cjust{1.8}}\put(2373,389){\cjust{2.2}}\put(2636,405){\cjust{2.6}}\put(2886,420){\cjust{3}}\put(3304,1628){\ljust{ }}\put(3304,1466){\ljust{ 1200}}\put(3304,1305){\ljust{ 800}}\put(3304,1143){\ljust{ 400}}\put(3304,982){\ljust{ 0}}\endGNUPLOTpicture
\endgroup
%
 }
    \caption{\protect\parbox[t]{80mm}{Automata size for which the median execution time to
check universality is less than 20 seconds (log scale). See also Table~\ref{tab:max-size}.}}
    \label{fig:max-size} 
\end{figure}

\begin{table}[!tbp]
\caption{Automata size (NBW) for which the median execution time for 
checking universality is less than 20 seconds. The symbol  means \emph{more than 1500}.} \label{tab:max-size}
\begin{center}
\begin{tabular}{|c||*{11}{p{5mm}|}p{7mm}|*{3}{p{5mm}|} }\hline
{\scriptsize \backslashbox[0mm]{{\normalsize f}}{{\normalsize r{\strut}}}}
    & \centering 0.2       & \centering 0.4       & \centering 0.6       & \centering 0.8 & \centering 1.0 & \centering 1.2 & \centering 1.4 & \centering 1.6 & \centering 1.8 & \centering 2.0  & \centering 2.2  & \centering 2.4  & \centering 2.6  & \centering 2.8  & \multicolumn{1}{c|}{3.0}  \\\hline\hline
0.1 & \centering  & \centering  & \centering  & \centering 550 & \centering 200 & \centering 120 & \centering 60  & \centering 40  & \centering 30  & \centering 40   & \centering 50   & \centering 50   & \centering 70   & \centering 90   & \multicolumn{1}{c|}{100}  \\\hline
0.3 & \centering  & \centering  & \centering  & \centering 500 & \centering 200 & \centering 100 & \centering 40  & \centering 30  & \centering 40  & \centering 70   & \centering 100  & \centering 120  & \centering 160  & \centering 180  & \multicolumn{1}{c|}{200}  \\\hline
0.5 & \centering  & \centering  & \centering  & \centering 500 & \centering 200 & \centering 120 & \centering 60  & \centering 60  & \centering 90  & \centering 120  & \centering 120  & \centering 120  & \centering 140  & \centering 260  & \multicolumn{1}{c|}{500}  \\\hline
0.7 & \centering  & \centering  & \centering  & \centering 500 & \centering 200 & \centering 120 & \centering 70  & \centering 80  & \centering 100 & \centering 200  & \centering 440  & \centering 1000 & \centering  & \centering  & \multicolumn{1}{c|}{} \\\hline
0.9 & \centering  & \centering  & \centering  & \centering 500 & \centering 180 & \centering 100 & \centering 80  & \centering 200 & \centering 600 & \centering  & \centering  & \centering  & \centering  & \centering  & \multicolumn{1}{c|}{} \\\hline
\end{tabular}
\end{center}
\end{table}

The results are shown in Fig.~\ref{fig:max-size}, and the corresponding 
values are given in Table~\ref{tab:max-size}. The vertical scale is logarithmic.
For example, for  and , our algorithm was able to handle at least  automata of size  
in less than 20 seconds and was not able to do so for automata of size .
In comparison, Tabakov and Vardi have studied the behavior of
Kupferman-Vardi and Miyano-Hayashi constructions for different
implementation schemes. We compare with the performances of their
symbolic approach which is the most efficient. 
For the same parameter values ( and ), they
report that their implementation can handle NBW with at most 8 states 
in less than  seconds~\cite{TabakovV07}.     

In \figurename~\ref{fig:scalability}, we show the median execution time to 
check universality for relatively difficult instances ( and  vary from
 to ). The vertical scale is logarithmic, so the behavior is roughly 
exponential in the size of the automata. Similar analyzes are reported 
in~\cite{TabakovV07} but for sizes below .

Finally, we give in \figurename~\ref{fig:distribution} the
distribution of execution times for  automata of size  with
 and , so that roughly half of the instances are
universal. Each point represents one automaton, and one point lies
outside the figure with an execution time of s for a non
universal automaton. The existence of very few instances that are very
hard was often encountered in the experiments, and this is why we use
the median for the execution times. If we except this hard instance,
\figurename~\ref{fig:distribution} shows that universal automata
(average time ms) are slightly easier to analyze than
non-universal automata (average time ms).  This probably comes
from the fact that we stop the computation of the (greatest) fixed
point whenever the initial state is not in the -closure
of the current approximation. Indeed, in such
case, since the approximations are -decreasing,
we know that the initial state would also not lie in the fixed point.
Of course, this optimization applies only for universal automata.




\begin{figure}[!tbp]
  \begin{minipage}[b]{.47\linewidth}
    \scalebox{0.5}{\begingroup
  \catcode`\@=11\relax
  \def\GNUPLOTspecial{\def\do##1{\catcode`##1=12\relax}\dospecials
    \catcode`\{=1\catcode`\}=2\catcode\%=14\relax\special}\expandafter\ifx\csname GNUPLOTpicture\endcsname\relax
  \csname newdimen\endcsname\GNUPLOTunit
  \gdef\GNUPLOTpicture(#1,#2){\vbox to#2\GNUPLOTunit\bgroup
    \def\put(##1,##2)##3{\unskip\raise##2\GNUPLOTunit
      \hbox to0pt{\kern##1\GNUPLOTunit ##3\hss}\ignorespaces}\def\ljust##1{\vbox to0pt{\vss\hbox to0pt{##1\hss}\vss}}\def\cjust##1{\vbox to0pt{\vss\hbox to0pt{\hss ##1\hss}\vss}}\def\rjust##1{\vbox to0pt{\vss\hbox to0pt{\hss ##1}\vss}}\def\stack##1{\let\\=\cr\tabskip=0pt\halign{\hfil ####\hfil\cr ##1\crcr}}\def\lstack##1{\hbox to0pt{\vbox to0pt{\vss\stack{##1}}\hss}}\def\cstack##1{\hbox to0pt{\hss\vbox to0pt{\vss\stack{##1}}\hss}}\def\rstack##1{\hbox to0pt{\vbox to0pt{\stack{##1}\vss}\hss}}\vss\hbox to#1\GNUPLOTunit\bgroup\ignorespaces}\gdef\endGNUPLOTpicture{\hss\egroup\egroup}\fi
\GNUPLOTunit=0.1bp
\GNUPLOTpicture(3600,2160)
{\GNUPLOTspecial{"
/gnudict 256 dict def
gnudict begin
/Color false def
/Solid false def
/gnulinewidth 5.000 def
/userlinewidth gnulinewidth def
/vshift -33 def
/dl {10.0 mul} def
/hpt_ 31.5 def
/vpt_ 31.5 def
/hpt hpt_ def
/vpt vpt_ def
/Rounded false def
/M {moveto} bind def
/L {lineto} bind def
/R {rmoveto} bind def
/V {rlineto} bind def
/N {newpath moveto} bind def
/C {setrgbcolor} bind def
/f {rlineto fill} bind def
/vpt2 vpt 2 mul def
/hpt2 hpt 2 mul def
/Lshow { currentpoint stroke M
  0 vshift R show } def
/Rshow { currentpoint stroke M
  dup stringwidth pop neg vshift R show } def
/Cshow { currentpoint stroke M
  dup stringwidth pop -2 div vshift R show } def
/UP { dup vpt_ mul /vpt exch def hpt_ mul /hpt exch def
  /hpt2 hpt 2 mul def /vpt2 vpt 2 mul def } def
/DL { Color {setrgbcolor Solid {pop []} if 0 setdash }
 {pop pop pop 0 setgray Solid {pop []} if 0 setdash} ifelse } def
/BL { stroke userlinewidth 2 mul setlinewidth
      Rounded { 1 setlinejoin 1 setlinecap } if } def
/AL { stroke userlinewidth 2 div setlinewidth
      Rounded { 1 setlinejoin 1 setlinecap } if } def
/UL { dup gnulinewidth mul /userlinewidth exch def
      dup 1 lt {pop 1} if 10 mul /udl exch def } def
/PL { stroke userlinewidth setlinewidth
      Rounded { 1 setlinejoin 1 setlinecap } if } def
/LTw { PL [] 1 setgray } def
/LTb { BL [] 0 0 0 DL } def
/LTa { AL [1 udl mul 2 udl mul] 0 setdash 0 0 0 setrgbcolor } def
/LT0 { PL [] 1 0 0 DL } def
/LT1 { PL [4 dl 2 dl] 0 1 0 DL } def
/LT2 { PL [2 dl 3 dl] 0 0 1 DL } def
/LT3 { PL [1 dl 1.5 dl] 1 0 1 DL } def
/LT4 { PL [5 dl 2 dl 1 dl 2 dl] 0 1 1 DL } def
/LT5 { PL [4 dl 3 dl 1 dl 3 dl] 1 1 0 DL } def
/LT6 { PL [2 dl 2 dl 2 dl 4 dl] 0 0 0 DL } def
/LT7 { PL [2 dl 2 dl 2 dl 2 dl 2 dl 4 dl] 1 0.3 0 DL } def
/LT8 { PL [2 dl 2 dl 2 dl 2 dl 2 dl 2 dl 2 dl 4 dl] 0.5 0.5 0.5 DL } def
/Pnt { stroke [] 0 setdash
   gsave 1 setlinecap M 0 0 V stroke grestore } def
/Dia { stroke [] 0 setdash 2 copy vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath stroke
  Pnt } def
/Pls { stroke [] 0 setdash vpt sub M 0 vpt2 V
  currentpoint stroke M
  hpt neg vpt neg R hpt2 0 V stroke
  } def
/Box { stroke [] 0 setdash 2 copy exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V closepath stroke
  Pnt } def
/Crs { stroke [] 0 setdash exch hpt sub exch vpt add M
  hpt2 vpt2 neg V currentpoint stroke M
  hpt2 neg 0 R hpt2 vpt2 V stroke } def
/TriU { stroke [] 0 setdash 2 copy vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath stroke
  Pnt  } def
/Star { 2 copy Pls Crs } def
/BoxF { stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V  hpt2 0 V  0 vpt2 V
  hpt2 neg 0 V  closepath fill } def
/TriUF { stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath fill } def
/TriD { stroke [] 0 setdash 2 copy vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath stroke
  Pnt  } def
/TriDF { stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath fill} def
/DiaF { stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath fill } def
/Pent { stroke [] 0 setdash 2 copy gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath stroke grestore Pnt } def
/PentF { stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath fill grestore } def
/Circle { stroke [] 0 setdash 2 copy
  hpt 0 360 arc stroke Pnt } def
/CircleF { stroke [] 0 setdash hpt 0 360 arc fill } def
/C0 { BL [] 0 setdash 2 copy moveto vpt 90 450  arc } bind def
/C1 { BL [] 0 setdash 2 copy        moveto
       2 copy  vpt 0 90 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C2 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 90 180 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C3 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 0 180 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C4 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 180 270 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C5 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 0 90 arc
       2 copy moveto
       2 copy  vpt 180 270 arc closepath fill
               vpt 0 360 arc } bind def
/C6 { BL [] 0 setdash 2 copy moveto
      2 copy  vpt 90 270 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C7 { BL [] 0 setdash 2 copy moveto
      2 copy  vpt 0 270 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C8 { BL [] 0 setdash 2 copy moveto
      2 copy vpt 270 360 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C9 { BL [] 0 setdash 2 copy moveto
      2 copy  vpt 270 450 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C10 { BL [] 0 setdash 2 copy 2 copy moveto vpt 270 360 arc closepath fill
       2 copy moveto
       2 copy vpt 90 180 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C11 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 0 180 arc closepath fill
       2 copy moveto
       2 copy  vpt 270 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C12 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 180 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C13 { BL [] 0 setdash  2 copy moveto
       2 copy  vpt 0 90 arc closepath fill
       2 copy moveto
       2 copy  vpt 180 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C14 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 90 360 arc closepath fill
               vpt 0 360 arc } bind def
/C15 { BL [] 0 setdash 2 copy vpt 0 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/Rec   { newpath 4 2 roll moveto 1 index 0 rlineto 0 exch rlineto
       neg 0 rlineto closepath } bind def
/Square { dup Rec } bind def
/Bsquare { vpt sub exch vpt sub exch vpt2 Square } bind def
/S0 { BL [] 0 setdash 2 copy moveto 0 vpt rlineto BL Bsquare } bind def
/S1 { BL [] 0 setdash 2 copy vpt Square fill Bsquare } bind def
/S2 { BL [] 0 setdash 2 copy exch vpt sub exch vpt Square fill Bsquare } bind def
/S3 { BL [] 0 setdash 2 copy exch vpt sub exch vpt2 vpt Rec fill Bsquare } bind def
/S4 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt Square fill Bsquare } bind def
/S5 { BL [] 0 setdash 2 copy 2 copy vpt Square fill
       exch vpt sub exch vpt sub vpt Square fill Bsquare } bind def
/S6 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill Bsquare } bind def
/S7 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill
       2 copy vpt Square fill
       Bsquare } bind def
/S8 { BL [] 0 setdash 2 copy vpt sub vpt Square fill Bsquare } bind def
/S9 { BL [] 0 setdash 2 copy vpt sub vpt vpt2 Rec fill Bsquare } bind def
/S10 { BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt Square fill
       Bsquare } bind def
/S11 { BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt2 vpt Rec fill
       Bsquare } bind def
/S12 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill Bsquare } bind def
/S13 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill
       2 copy vpt Square fill Bsquare } bind def
/S14 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill
       2 copy exch vpt sub exch vpt Square fill Bsquare } bind def
/S15 { BL [] 0 setdash 2 copy Bsquare fill Bsquare } bind def
/D0 { gsave translate 45 rotate 0 0 S0 stroke grestore } bind def
/D1 { gsave translate 45 rotate 0 0 S1 stroke grestore } bind def
/D2 { gsave translate 45 rotate 0 0 S2 stroke grestore } bind def
/D3 { gsave translate 45 rotate 0 0 S3 stroke grestore } bind def
/D4 { gsave translate 45 rotate 0 0 S4 stroke grestore } bind def
/D5 { gsave translate 45 rotate 0 0 S5 stroke grestore } bind def
/D6 { gsave translate 45 rotate 0 0 S6 stroke grestore } bind def
/D7 { gsave translate 45 rotate 0 0 S7 stroke grestore } bind def
/D8 { gsave translate 45 rotate 0 0 S8 stroke grestore } bind def
/D9 { gsave translate 45 rotate 0 0 S9 stroke grestore } bind def
/D10 { gsave translate 45 rotate 0 0 S10 stroke grestore } bind def
/D11 { gsave translate 45 rotate 0 0 S11 stroke grestore } bind def
/D12 { gsave translate 45 rotate 0 0 S12 stroke grestore } bind def
/D13 { gsave translate 45 rotate 0 0 S13 stroke grestore } bind def
/D14 { gsave translate 45 rotate 0 0 S14 stroke grestore } bind def
/D15 { gsave translate 45 rotate 0 0 S15 stroke grestore } bind def
/DiaE { stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath stroke } def
/BoxE { stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V closepath stroke } def
/TriUE { stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath stroke } def
/TriDE { stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath stroke } def
/PentE { stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath stroke grestore } def
/CircE { stroke [] 0 setdash 
  hpt 0 360 arc stroke } def
/Opaque { gsave closepath 1 setgray fill grestore 0 setgray closepath } def
/DiaW { stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V Opaque stroke } def
/BoxW { stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V Opaque stroke } def
/TriUW { stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V Opaque stroke } def
/TriDW { stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V Opaque stroke } def
/PentW { stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  Opaque stroke grestore } def
/CircW { stroke [] 0 setdash 
  hpt 0 360 arc Opaque stroke } def
/BoxFill { gsave Rec 1 setgray fill grestore } def
/BoxColFill {
  gsave Rec
  /Fillden exch def
  currentrgbcolor
  /ColB exch def /ColG exch def /ColR exch def
  /ColR ColR Fillden mul Fillden sub 1 add def
  /ColG ColG Fillden mul Fillden sub 1 add def
  /ColB ColB Fillden mul Fillden sub 1 add def
  ColR ColG ColB setrgbcolor
  fill grestore } def
/PatternFill { gsave /PFa [ 9 2 roll ] def
    PFa 0 get PFa 2 get 2 div add PFa 1 get PFa 3 get 2 div add translate
    PFa 2 get -2 div PFa 3 get -2 div PFa 2 get PFa 3 get Rec
    gsave 1 setgray fill grestore clip
    currentlinewidth 0.5 mul setlinewidth
    /PFs PFa 2 get dup mul PFa 3 get dup mul add sqrt def
    0 0 M PFa 5 get rotate PFs -2 div dup translate
	0 1 PFs PFa 4 get div 1 add floor cvi
	{ PFa 4 get mul 0 M 0 PFs V } for
    0 PFa 6 get ne {
	0 1 PFs PFa 4 get div 1 add floor cvi
	{ PFa 4 get mul 0 2 1 roll M PFs 0 V } for
    } if
    stroke grestore } def
/Symbol-Oblique /Symbol findfont [1 0 .167 1 0 0] makefont
dup length dict begin {1 index /FID eq {pop pop} {def} ifelse} forall
currentdict end definefont pop
end
gnudict begin
gsave
0 0 translate
0.100 0.100 scale
0 setgray
newpath
1.000 UL
LTb
1.000 UL
LTa
500 300 M
2836 0 V
1.000 UL
LTb
500 300 M
63 0 V
2773 0 R
-63 0 V
1.000 UL
LTb
500 400 M
31 0 V
2805 0 R
-31 0 V
500 532 M
31 0 V
2805 0 R
-31 0 V
500 600 M
31 0 V
2805 0 R
-31 0 V
1.000 UL
LTa
500 632 M
2836 0 V
1.000 UL
LTb
500 632 M
63 0 V
2773 0 R
-63 0 V
1.000 UL
LTb
500 732 M
31 0 V
2805 0 R
-31 0 V
500 864 M
31 0 V
2805 0 R
-31 0 V
500 932 M
31 0 V
2805 0 R
-31 0 V
1.000 UL
LTa
500 964 M
2836 0 V
1.000 UL
LTb
500 964 M
63 0 V
2773 0 R
-63 0 V
1.000 UL
LTb
500 1064 M
31 0 V
2805 0 R
-31 0 V
500 1196 M
31 0 V
2805 0 R
-31 0 V
500 1264 M
31 0 V
2805 0 R
-31 0 V
1.000 UL
LTa
500 1296 M
2836 0 V
1.000 UL
LTb
500 1296 M
63 0 V
2773 0 R
-63 0 V
1.000 UL
LTb
500 1396 M
31 0 V
2805 0 R
-31 0 V
500 1528 M
31 0 V
2805 0 R
-31 0 V
500 1596 M
31 0 V
2805 0 R
-31 0 V
1.000 UL
LTa
500 1628 M
52 0 V
856 0 R
1928 0 V
1.000 UL
LTb
500 1628 M
63 0 V
2773 0 R
-63 0 V
1.000 UL
LTb
500 1728 M
31 0 V
2805 0 R
-31 0 V
500 1860 M
31 0 V
2805 0 R
-31 0 V
1.000 UL
LTa
500 300 M
0 1560 V
1.000 UL
LTb
500 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1.000 UL
LTa
672 300 M
0 1121 V
0 300 R
0 139 V
1.000 UL
LTb
672 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1.000 UL
LTa
844 300 M
0 1121 V
0 300 R
0 139 V
1.000 UL
LTb
844 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1.000 UL
LTa
1016 300 M
0 1121 V
0 300 R
0 139 V
1.000 UL
LTb
1016 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1.000 UL
LTa
1188 300 M
0 1121 V
0 300 R
0 139 V
1.000 UL
LTb
1188 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1.000 UL
LTa
1359 300 M
0 1121 V
0 300 R
0 139 V
1.000 UL
LTb
1359 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1.000 UL
LTa
1531 300 M
0 1560 V
1.000 UL
LTb
1531 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1.000 UL
LTa
1703 300 M
0 1560 V
1.000 UL
LTb
1703 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1.000 UL
LTa
1875 300 M
0 1560 V
1.000 UL
LTb
1875 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1.000 UL
LTa
2047 300 M
0 1560 V
1.000 UL
LTb
2047 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1.000 UL
LTa
2219 300 M
0 1560 V
1.000 UL
LTb
2219 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1.000 UL
LTa
2391 300 M
0 1560 V
1.000 UL
LTb
2391 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1.000 UL
LTa
2563 300 M
0 1560 V
1.000 UL
LTb
2563 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1.000 UL
LTa
2734 300 M
0 1560 V
1.000 UL
LTb
2734 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1.000 UL
LTa
2906 300 M
0 1560 V
1.000 UL
LTb
2906 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1.000 UL
LTa
3078 300 M
0 1560 V
1.000 UL
LTb
3078 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1.000 UL
LTa
3250 300 M
0 1560 V
1.000 UL
LTb
3250 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1.000 UL
LTb
500 300 M
2836 0 V
0 1560 V
-2836 0 V
500 300 L
LTb
LTb
LTb
0.900 UP
0.900 UP
1.000 UL
LT2
LTb
LT2
1102 1671 M
256 0 V
844 558 M
172 284 V
172 237 V
171 173 V
172 58 V
172 119 V
172 93 V
172 170 V
172 -26 V
172 12 V
844 558 Star
1016 842 Star
1188 1079 Star
1359 1252 Star
1531 1310 Star
1703 1429 Star
1875 1522 Star
2047 1692 Star
2219 1666 Star
2391 1678 Star
1230 1671 Star
0.900 UP
1.000 UL
LT3
LTb
LT3
1102 1571 M
256 0 V
844 300 M
172 281 V
172 194 V
171 108 V
172 121 V
172 86 V
172 57 V
172 76 V
172 43 V
172 97 V
172 57 V
171 46 V
172 0 V
172 100 V
172 42 V
844 300 Box
1016 581 Box
1188 775 Box
1359 883 Box
1531 1004 Box
1703 1090 Box
1875 1147 Box
2047 1223 Box
2219 1266 Box
2391 1363 Box
2563 1420 Box
2734 1466 Box
2906 1466 Box
3078 1566 Box
3250 1608 Box
1230 1571 Box
0.900 UP
1.000 UL
LT5
LTb
LT5
1102 1471 M
256 0 V
1016 400 M
172 58 V
171 250 V
172 44 V
172 69 V
172 34 V
172 -6 V
172 83 V
172 125 V
172 105 V
171 52 V
172 -72 V
172 159 V
172 -51 V
1016 400 Circle
1188 458 Circle
1359 708 Circle
1531 752 Circle
1703 821 Circle
1875 855 Circle
2047 849 Circle
2219 932 Circle
2391 1057 Circle
2563 1162 Circle
2734 1214 Circle
2906 1142 Circle
3078 1301 Circle
3250 1250 Circle
1230 1471 Circle
1.000 UL
LTb
500 300 M
2836 0 V
0 1560 V
-2836 0 V
500 300 L
0.900 UP
stroke
grestore
end
showpage
}}\put(1052,1471){\rjust{r=2, f=0.7}}\put(1052,1571){\rjust{r=2, f=0.5}}\put(1052,1671){\rjust{r=2, f=0.3}}\put(1918,2010){\cjust{Scalability analysis}}\put(1918,50){\cjust{Automata size}}\put(100,1080){\special{ps: gsave currentpoint currentpoint translate
270 rotate neg exch neg exch translate}\cstack{Median execution time (s)}\special{ps: currentpoint grestore moveto}}\put(3250,200){\cjust{ 160}}\put(3078,200){\cjust{ 150}}\put(2906,200){\cjust{ 140}}\put(2734,200){\cjust{ 130}}\put(2563,200){\cjust{ 120}}\put(2391,200){\cjust{ 110}}\put(2219,200){\cjust{ 100}}\put(2047,200){\cjust{ 90}}\put(1875,200){\cjust{ 80}}\put(1703,200){\cjust{ 70}}\put(1531,200){\cjust{ 60}}\put(1359,200){\cjust{ 50}}\put(1188,200){\cjust{ 40}}\put(1016,200){\cjust{ 30}}\put(844,200){\cjust{ 20}}\put(672,200){\cjust{ 10}}\put(500,200){\cjust{ 0}}\put(450,1628){\rjust{ 100}}\put(450,1296){\rjust{ 10}}\put(450,964){\rjust{ 1}}\put(450,632){\rjust{ 0.1}}\put(450,300){\rjust{ 0.01}}\endGNUPLOTpicture
\endgroup
%
 }
    \caption{\protect\parbox[t]{40mm}{Median time to check universality (of  automata for each sample point).}}
    \label{fig:scalability}
 \end{minipage} \hfill 
 \begin{minipage}[b]{.47\linewidth}
    \scalebox{0.5}{\begingroup
  \catcode`\@=11\relax
  \def\GNUPLOTspecial{\def\do##1{\catcode`##1=12\relax}\dospecials
    \catcode`\{=1\catcode`\}=2\catcode\%=14\relax\special}\expandafter\ifx\csname GNUPLOTpicture\endcsname\relax
  \csname newdimen\endcsname\GNUPLOTunit
  \gdef\GNUPLOTpicture(#1,#2){\vbox to#2\GNUPLOTunit\bgroup
    \def\put(##1,##2)##3{\unskip\raise##2\GNUPLOTunit
      \hbox to0pt{\kern##1\GNUPLOTunit ##3\hss}\ignorespaces}\def\ljust##1{\vbox to0pt{\vss\hbox to0pt{##1\hss}\vss}}\def\cjust##1{\vbox to0pt{\vss\hbox to0pt{\hss ##1\hss}\vss}}\def\rjust##1{\vbox to0pt{\vss\hbox to0pt{\hss ##1}\vss}}\def\stack##1{\let\\=\cr\tabskip=0pt\halign{\hfil ####\hfil\cr ##1\crcr}}\def\lstack##1{\hbox to0pt{\vbox to0pt{\vss\stack{##1}}\hss}}\def\cstack##1{\hbox to0pt{\hss\vbox to0pt{\vss\stack{##1}}\hss}}\def\rstack##1{\hbox to0pt{\vbox to0pt{\stack{##1}\vss}\hss}}\vss\hbox to#1\GNUPLOTunit\bgroup\ignorespaces}\gdef\endGNUPLOTpicture{\hss\egroup\egroup}\fi
\GNUPLOTunit=0.1bp
\GNUPLOTpicture(3600,2160)
{\GNUPLOTspecial{"
/gnudict 256 dict def
gnudict begin
/Color false def
/Solid false def
/gnulinewidth 5.000 def
/userlinewidth gnulinewidth def
/vshift -33 def
/dl {10.0 mul} def
/hpt_ 31.5 def
/vpt_ 31.5 def
/hpt hpt_ def
/vpt vpt_ def
/Rounded false def
/M {moveto} bind def
/L {lineto} bind def
/R {rmoveto} bind def
/V {rlineto} bind def
/N {newpath moveto} bind def
/C {setrgbcolor} bind def
/f {rlineto fill} bind def
/vpt2 vpt 2 mul def
/hpt2 hpt 2 mul def
/Lshow { currentpoint stroke M
  0 vshift R show } def
/Rshow { currentpoint stroke M
  dup stringwidth pop neg vshift R show } def
/Cshow { currentpoint stroke M
  dup stringwidth pop -2 div vshift R show } def
/UP { dup vpt_ mul /vpt exch def hpt_ mul /hpt exch def
  /hpt2 hpt 2 mul def /vpt2 vpt 2 mul def } def
/DL { Color {setrgbcolor Solid {pop []} if 0 setdash }
 {pop pop pop 0 setgray Solid {pop []} if 0 setdash} ifelse } def
/BL { stroke userlinewidth 2 mul setlinewidth
      Rounded { 1 setlinejoin 1 setlinecap } if } def
/AL { stroke userlinewidth 2 div setlinewidth
      Rounded { 1 setlinejoin 1 setlinecap } if } def
/UL { dup gnulinewidth mul /userlinewidth exch def
      dup 1 lt {pop 1} if 10 mul /udl exch def } def
/PL { stroke userlinewidth setlinewidth
      Rounded { 1 setlinejoin 1 setlinecap } if } def
/LTw { PL [] 1 setgray } def
/LTb { BL [] 0 0 0 DL } def
/LTa { AL [1 udl mul 2 udl mul] 0 setdash 0 0 0 setrgbcolor } def
/LT0 { PL [] 1 0 0 DL } def
/LT1 { PL [4 dl 2 dl] 0 1 0 DL } def
/LT2 { PL [2 dl 3 dl] 0 0 1 DL } def
/LT3 { PL [1 dl 1.5 dl] 1 0 1 DL } def
/LT4 { PL [5 dl 2 dl 1 dl 2 dl] 0 1 1 DL } def
/LT5 { PL [4 dl 3 dl 1 dl 3 dl] 1 1 0 DL } def
/LT6 { PL [2 dl 2 dl 2 dl 4 dl] 0 0 0 DL } def
/LT7 { PL [2 dl 2 dl 2 dl 2 dl 2 dl 4 dl] 1 0.3 0 DL } def
/LT8 { PL [2 dl 2 dl 2 dl 2 dl 2 dl 2 dl 2 dl 4 dl] 0.5 0.5 0.5 DL } def
/Pnt { stroke [] 0 setdash
   gsave 1 setlinecap M 0 0 V stroke grestore } def
/Dia { stroke [] 0 setdash 2 copy vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath stroke
  Pnt } def
/Pls { stroke [] 0 setdash vpt sub M 0 vpt2 V
  currentpoint stroke M
  hpt neg vpt neg R hpt2 0 V stroke
  } def
/Box { stroke [] 0 setdash 2 copy exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V closepath stroke
  Pnt } def
/Crs { stroke [] 0 setdash exch hpt sub exch vpt add M
  hpt2 vpt2 neg V currentpoint stroke M
  hpt2 neg 0 R hpt2 vpt2 V stroke } def
/TriU { stroke [] 0 setdash 2 copy vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath stroke
  Pnt  } def
/Star { 2 copy Pls Crs } def
/BoxF { stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V  hpt2 0 V  0 vpt2 V
  hpt2 neg 0 V  closepath fill } def
/TriUF { stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath fill } def
/TriD { stroke [] 0 setdash 2 copy vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath stroke
  Pnt  } def
/TriDF { stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath fill} def
/DiaF { stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath fill } def
/Pent { stroke [] 0 setdash 2 copy gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath stroke grestore Pnt } def
/PentF { stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath fill grestore } def
/Circle { stroke [] 0 setdash 2 copy
  hpt 0 360 arc stroke Pnt } def
/CircleF { stroke [] 0 setdash hpt 0 360 arc fill } def
/C0 { BL [] 0 setdash 2 copy moveto vpt 90 450  arc } bind def
/C1 { BL [] 0 setdash 2 copy        moveto
       2 copy  vpt 0 90 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C2 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 90 180 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C3 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 0 180 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C4 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 180 270 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C5 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 0 90 arc
       2 copy moveto
       2 copy  vpt 180 270 arc closepath fill
               vpt 0 360 arc } bind def
/C6 { BL [] 0 setdash 2 copy moveto
      2 copy  vpt 90 270 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C7 { BL [] 0 setdash 2 copy moveto
      2 copy  vpt 0 270 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C8 { BL [] 0 setdash 2 copy moveto
      2 copy vpt 270 360 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C9 { BL [] 0 setdash 2 copy moveto
      2 copy  vpt 270 450 arc closepath fill
              vpt 0 360 arc closepath } bind def
/C10 { BL [] 0 setdash 2 copy 2 copy moveto vpt 270 360 arc closepath fill
       2 copy moveto
       2 copy vpt 90 180 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C11 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 0 180 arc closepath fill
       2 copy moveto
       2 copy  vpt 270 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C12 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 180 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C13 { BL [] 0 setdash  2 copy moveto
       2 copy  vpt 0 90 arc closepath fill
       2 copy moveto
       2 copy  vpt 180 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/C14 { BL [] 0 setdash 2 copy moveto
       2 copy  vpt 90 360 arc closepath fill
               vpt 0 360 arc } bind def
/C15 { BL [] 0 setdash 2 copy vpt 0 360 arc closepath fill
               vpt 0 360 arc closepath } bind def
/Rec   { newpath 4 2 roll moveto 1 index 0 rlineto 0 exch rlineto
       neg 0 rlineto closepath } bind def
/Square { dup Rec } bind def
/Bsquare { vpt sub exch vpt sub exch vpt2 Square } bind def
/S0 { BL [] 0 setdash 2 copy moveto 0 vpt rlineto BL Bsquare } bind def
/S1 { BL [] 0 setdash 2 copy vpt Square fill Bsquare } bind def
/S2 { BL [] 0 setdash 2 copy exch vpt sub exch vpt Square fill Bsquare } bind def
/S3 { BL [] 0 setdash 2 copy exch vpt sub exch vpt2 vpt Rec fill Bsquare } bind def
/S4 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt Square fill Bsquare } bind def
/S5 { BL [] 0 setdash 2 copy 2 copy vpt Square fill
       exch vpt sub exch vpt sub vpt Square fill Bsquare } bind def
/S6 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill Bsquare } bind def
/S7 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill
       2 copy vpt Square fill
       Bsquare } bind def
/S8 { BL [] 0 setdash 2 copy vpt sub vpt Square fill Bsquare } bind def
/S9 { BL [] 0 setdash 2 copy vpt sub vpt vpt2 Rec fill Bsquare } bind def
/S10 { BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt Square fill
       Bsquare } bind def
/S11 { BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt2 vpt Rec fill
       Bsquare } bind def
/S12 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill Bsquare } bind def
/S13 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill
       2 copy vpt Square fill Bsquare } bind def
/S14 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill
       2 copy exch vpt sub exch vpt Square fill Bsquare } bind def
/S15 { BL [] 0 setdash 2 copy Bsquare fill Bsquare } bind def
/D0 { gsave translate 45 rotate 0 0 S0 stroke grestore } bind def
/D1 { gsave translate 45 rotate 0 0 S1 stroke grestore } bind def
/D2 { gsave translate 45 rotate 0 0 S2 stroke grestore } bind def
/D3 { gsave translate 45 rotate 0 0 S3 stroke grestore } bind def
/D4 { gsave translate 45 rotate 0 0 S4 stroke grestore } bind def
/D5 { gsave translate 45 rotate 0 0 S5 stroke grestore } bind def
/D6 { gsave translate 45 rotate 0 0 S6 stroke grestore } bind def
/D7 { gsave translate 45 rotate 0 0 S7 stroke grestore } bind def
/D8 { gsave translate 45 rotate 0 0 S8 stroke grestore } bind def
/D9 { gsave translate 45 rotate 0 0 S9 stroke grestore } bind def
/D10 { gsave translate 45 rotate 0 0 S10 stroke grestore } bind def
/D11 { gsave translate 45 rotate 0 0 S11 stroke grestore } bind def
/D12 { gsave translate 45 rotate 0 0 S12 stroke grestore } bind def
/D13 { gsave translate 45 rotate 0 0 S13 stroke grestore } bind def
/D14 { gsave translate 45 rotate 0 0 S14 stroke grestore } bind def
/D15 { gsave translate 45 rotate 0 0 S15 stroke grestore } bind def
/DiaE { stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath stroke } def
/BoxE { stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V closepath stroke } def
/TriUE { stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath stroke } def
/TriDE { stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath stroke } def
/PentE { stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath stroke grestore } def
/CircE { stroke [] 0 setdash 
  hpt 0 360 arc stroke } def
/Opaque { gsave closepath 1 setgray fill grestore 0 setgray closepath } def
/DiaW { stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V Opaque stroke } def
/BoxW { stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V Opaque stroke } def
/TriUW { stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V Opaque stroke } def
/TriDW { stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V Opaque stroke } def
/PentW { stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  Opaque stroke grestore } def
/CircW { stroke [] 0 setdash 
  hpt 0 360 arc Opaque stroke } def
/BoxFill { gsave Rec 1 setgray fill grestore } def
/BoxColFill {
  gsave Rec
  /Fillden exch def
  currentrgbcolor
  /ColB exch def /ColG exch def /ColR exch def
  /ColR ColR Fillden mul Fillden sub 1 add def
  /ColG ColG Fillden mul Fillden sub 1 add def
  /ColB ColB Fillden mul Fillden sub 1 add def
  ColR ColG ColB setrgbcolor
  fill grestore } def
/PatternFill { gsave /PFa [ 9 2 roll ] def
    PFa 0 get PFa 2 get 2 div add PFa 1 get PFa 3 get 2 div add translate
    PFa 2 get -2 div PFa 3 get -2 div PFa 2 get PFa 3 get Rec
    gsave 1 setgray fill grestore clip
    currentlinewidth 0.5 mul setlinewidth
    /PFs PFa 2 get dup mul PFa 3 get dup mul add sqrt def
    0 0 M PFa 5 get rotate PFs -2 div dup translate
	0 1 PFs PFa 4 get div 1 add floor cvi
	{ PFa 4 get mul 0 M 0 PFs V } for
    0 PFa 6 get ne {
	0 1 PFs PFa 4 get div 1 add floor cvi
	{ PFa 4 get mul 0 2 1 roll M PFs 0 V } for
    } if
    stroke grestore } def
/Symbol-Oblique /Symbol findfont [1 0 .167 1 0 0] makefont
dup length dict begin {1 index /FID eq {pop pop} {def} ifelse} forall
currentdict end definefont pop
end
gnudict begin
gsave
0 0 translate
0.100 0.100 scale
0 setgray
newpath
1.000 UL
LTb
1.000 UL
LTa
150 1340 M
2836 0 V
1.000 UL
LTb
150 1340 M
63 0 V
2773 0 R
-63 0 V
1.000 UL
LTb
1.000 UL
LTa
150 820 M
2836 0 V
1.000 UL
LTb
150 820 M
63 0 V
2773 0 R
-63 0 V
1.000 UL
LTb
150 300 M
0 31 V
0 1529 R
0 -31 V
223 300 M
0 31 V
0 1529 R
0 -31 V
285 300 M
0 31 V
0 1529 R
0 -31 V
338 300 M
0 31 V
0 1529 R
0 -31 V
385 300 M
0 31 V
0 1529 R
0 -31 V
1.000 UL
LTa
427 300 M
0 1560 V
1.000 UL
LTb
427 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
705 300 M
0 31 V
0 1529 R
0 -31 V
867 300 M
0 31 V
0 1529 R
0 -31 V
982 300 M
0 31 V
0 1529 R
0 -31 V
1071 300 M
0 31 V
0 1529 R
0 -31 V
1144 300 M
0 31 V
0 1529 R
0 -31 V
1206 300 M
0 31 V
0 1529 R
0 -31 V
1259 300 M
0 31 V
0 1529 R
0 -31 V
1306 300 M
0 31 V
0 1529 R
0 -31 V
1.000 UL
LTa
1348 300 M
0 1560 V
1.000 UL
LTb
1348 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
1626 300 M
0 31 V
0 1529 R
0 -31 V
1788 300 M
0 31 V
0 1529 R
0 -31 V
1903 300 M
0 31 V
0 1529 R
0 -31 V
1992 300 M
0 31 V
0 1529 R
0 -31 V
2065 300 M
0 31 V
0 1529 R
0 -31 V
2127 300 M
0 31 V
0 1529 R
0 -31 V
2180 300 M
0 31 V
0 1529 R
0 -31 V
2227 300 M
0 31 V
0 1529 R
0 -31 V
1.000 UL
LTa
2269 300 M
0 1280 V
0 200 R
0 80 V
1.000 UL
LTb
2269 300 M
0 63 V
0 1497 R
0 -63 V
1.000 UL
LTb
2547 300 M
0 31 V
0 1529 R
0 -31 V
2709 300 M
0 31 V
0 1529 R
0 -31 V
2824 300 M
0 31 V
0 1529 R
0 -31 V
2913 300 M
0 31 V
0 1529 R
0 -31 V
2986 300 M
0 31 V
0 1529 R
0 -31 V
1.000 UL
LTb
150 300 M
2836 0 V
0 1560 V
-2836 0 V
150 300 L
LTb
LTb
0.900 UP
0.900 UP
1.000 UL
LT2
LTb
LT2
1814 820 Star
1348 820 Star
1561 820 Star
1681 820 Star
1882 820 Star
2051 820 Star
1206 820 Star
1872 820 Star
1730 820 Star
2218 820 Star
1605 820 Star
1967 820 Star
1992 820 Star
2097 820 Star
1664 820 Star
1746 820 Star
427 820 Star
427 820 Star
705 820 Star
1664 820 Star
2044 820 Star
1893 820 Star
1306 820 Star
2143 820 Star
2257 820 Star
2072 820 Star
2109 820 Star
2154 820 Star
2000 820 Star
1730 820 Star
427 820 Star
2257 820 Star
982 820 Star
1386 820 Star
1386 820 Star
1453 820 Star
2336 820 Star
2304 820 Star
427 820 Star
1861 820 Star
1922 820 Star
1386 820 Star
1583 820 Star
1626 820 Star
1746 820 Star
1605 820 Star
2227 820 Star
1605 820 Star
1730 820 Star
2000 820 Star
1510 820 Star
2837 1730 Star
0.900 UP
1.000 UL
LT3
LTb
LT3
1536 1340 Box
427 1340 Box
1814 1340 Box
1826 1340 Box
1967 1340 Box
1206 1340 Box
2160 1340 Box
1583 1340 Box
1760 1340 Box
1950 1340 Box
1715 1340 Box
1536 1340 Box
2132 1340 Box
1882 1340 Box
2249 1340 Box
1992 1340 Box
2336 1340 Box
1483 1340 Box
1626 1340 Box
1922 1340 Box
1536 1340 Box
2730 1340 Box
1932 1340 Box
867 1340 Box
1561 1340 Box
1483 1340 Box
982 1340 Box
1626 1340 Box
2285 1340 Box
2261 1340 Box
2281 1340 Box
1306 1340 Box
1664 1340 Box
2495 1340 Box
2091 1340 Box
2023 1340 Box
2839 1340 Box
2383 1340 Box
1626 1340 Box
2121 1340 Box
1144 1340 Box
2837 1630 Box
1.000 UL
LTb
150 300 M
2836 0 V
0 1560 V
-2836 0 V
150 300 L
0.900 UP
stroke
grestore
end
showpage
}}\put(2659,1630){\rjust{Not Universal}}\put(2659,1730){\rjust{Universal}}\put(1568,2010){\cjust{f=2.2, r=0.5}}\put(1568,50){\cjust{Execution time (s)}}\put(2269,200){\cjust{ 1}}\put(1348,200){\cjust{ 0.1}}\put(427,200){\cjust{ 0.01}}\endGNUPLOTpicture
\endgroup
%
 }
    \caption{\protect\parbox[t]{40mm}{Execution time to check universality of 100 automata, 57 of which were universal.}}
    \label{fig:distribution}
 \end{minipage}
\end{figure}










\section{Language Inclusion for B\"uchi automata}\label{sec:inclusion-NBW}


Let  and  
be two NBW defined on the same alphabet  for which we want
to check language inclusion: . To solve
this problem, we check emptiness of . 
As we have seen, we can use the Kupferman-Vardi and Miyano-Hayashi construction
to specify a NBW  
that accepts the complement of the language of .

Using the classical product construction, let  be a finite automaton
with set of locations , initial state 
, and transition function  such that 
.
We equip  with the generalized B\"uchi condition 
, thus asking 
for a run of  to be accepting that it visits  and 
infinitely often. It is routine to show that we have . 
The following fixed point

\noindent
can be used to check emptiness of  as we have  
iff .  
We now define the pre-order  over the locations of : 
for all , 
let  iff  and 
. 


We extend the definition of simulation relation  (Definition~\ref{def:simulation})
to generalized B\"uchi automata  by asking that for each , 
the relation~ is a simulation for  with accepting states .

\begin{lem}
The relation  is a simulation for .
\end{lem} 

\proof 
First, observe that equality is a simulation relation for . Then, the
first condition of Definition~\ref{def:simulation} is a direct consequence
of the fact that equality (resp. ) is a simulation 
relation for  (resp. for ), and that  
is the product of these automata.
Second, it is easy to see that the sets  and  are 
-closed.
\qed

As a consequence of the last lemma, we know that all sets that we
have to manipulate to solve the language inclusion problem using the
fixed point  are -closed. The operators
,  and  can be thus computed efficiently, using the same 
algorithms and data structures as for universality. In particular, let 

where
 is computed by Algorithm~2 (with input ).
It is easy to show as a corollary of Theorem~\ref{theo:correctness-alg-pre} that 
.


\section{Conclusion}\label{sec:conclusion}

We have shown that the prohibitive complementation constructions
for nondeterministic B\"uchi automata can be avoided for solving 
classical problems like universality and language inclusion. 
Our approach is based on fixed points computation and the existence of simulation relations 
for the (exponential) constructions used in complementation of 
B\"uchi automata. Those simulations are used to dramatically 
reduce the amount of computations needed to decide classical problems.
Their definition relies on the structure of the original automaton
and do not require explicit complementation. 

The resulting algorithms evaluate a fixed point formula and avoid
redundant computations by maintaining sets of maximal elements
according to the simulation relation. In practice, the computation of
the predecessor operator, which is the key of the approach, is
efficient because it is done on antichains of elements only. Even though
the classical approaches (as well as ours) have the same worst case
complexity, our prototype implementation outperforms those approaches
where the structural properties of the complement automaton (witnessed by the 
existence of simulation relations) is not exploited. The huge gap of performances holds
over the entire parameter space of the randomized model proposed by
Tabakov and Vardi.

Applications of this paper go beyond universality and language inclusion 
for NBW, as we have shown that the methodology applies to alternating 
B\"uchi automata for which efficient translations from LTL formula are 
known~\cite{GastinOddoux}. Significant improvements in the model-checking 
and satisfiability problem of LTL can be achieved with the same ideas~\cite{DDMR08a,DDMR08c}.


\paragraph{{\bf Acknowledgment.}} We thank two anonymous reviewers for helpful 
comments and suggestions.




\bibliography{biblio}
\bibliographystyle{alpha}


\iffalse
\begin{thebibliography}{DDHR06]}

\bibitem[BL69]{buechi69}
J.~Richard B{\"u}chi and Lawrence~H. Landweber.
\newblock Definability in the monadic second-order theory of successor.
\newblock {\em J. Symb. Log.}, 34(2):166--170, 1969.



\bibitem[DDHR06]{cav06}
M. {De Wulf}, L. Doyen, T.~A. Henzinger, and J.-F. Raskin.
\newblock Antichains: A new algorithm for checking universality of finite
  automata. \newblock In {\em Proceedings of CAV 2006}, {\em LNCS} 4144, pp. 17--30. Springer.



\bibitem[DR06]{TR-DR}
L. Doyen and J.-F. Raskin.
\newblock Improved Algorithms for the Automata-Based Approach to Model-Checking (extended version)
\newblock Tech. Rep.~76, U.L.B. -- Federated Center in Verification, 2006.
\newblock http://www.ulb.ac.be/di/ssd/cfv/publications.html.


\bibitem[EWS05]{simulations}
K. Etessami, T. Wilke, and R.~A. Schuller.
\newblock Fair simulation relations, parity games, and state space reduction
  for bu"chi automata.
\newblock {\em SIAM J. Comput.}, 34(5):1159--1175, 2005.

\bibitem[GKSV03]{GurumurthyKSV03}
S. Gurumurthy, O. Kupferman, F. Somenzi, and M.~Y. Vardi.
\newblock On complementing nondeterministic b{\"u}chi automata.
\newblock In {\em Proc. of CHARME 2003}, {\em LNCS} 2860, pp. 96--110. Springer.

\bibitem[GO01]{GastinOddoux}
P. Gastin and D. Oddoux.
\newblock Fast {\sc LTL} to B{\"u}chi automata translation.
\newblock In {\em Proc. of CAV 2001}, {\em LNCS} 2102, pp. 53--65. Springer.

\bibitem[KV97]{kupferman97weak}
O. Kupferman and M.~Y. Vardi.
\newblock Weak alternating automata are not that weak.
\newblock In {\em Proceedings of {ISTCS}'97}, pp. 147--158. IEEE Computer Society Press.

\bibitem[MH84]{MiyanoH84}
Satoru Miyano and Takeshi Hayashi.
\newblock Alternating finite automata on omega-words.
\newblock In {\em CAAP}, pages 195--210, 1984.

\bibitem[Mic88]{Michel88}
Max Michel.
\newblock Complementation is more difficult with automata on infinite words.
\newblock CNET, Paris, 1988.

\bibitem[RH04]{spin}
Theo~C. Ruys and Gerard~J. Holzmann.
\newblock Advanced spin tutorial.
\newblock In {\em SPIN}, {\em LNCS} 2989, pp. 304--305. Springer, 2004.

\bibitem[Saf88]{Safra88}
Shmuel Safra.
\newblock On the complexity of -automata.
\newblock In {\em Proc. of FOCS: Foundations of Computer Science}, pages
  319--327. IEEE, 1988.

\bibitem[SVW87]{SVW87}
A. P. Sistla, M. Y. Vardi and P. Wolper.
\newblock The Complementation Problem for B{\"u}chi Automata with Applications to Temporal Logic.
\newblock {\em Theor. Comput. Sci.}, 49:217--237, 1987.


\bibitem[Tab06]{talk-tabakov}
D. Tabakov.
\newblock Experimental evaluation of explicit and symbolic approaches to
  complementation of non-deterministic buechi automata.
\newblock {\em Talk at ``Games and Verification'' workshop, 
  Newton Institute for Math. Sciences}. July 2006.

\bibitem[TV05]{TabakovV05}
D. Tabakov and M.~Y. Vardi.
\newblock Experimental evaluation of classical automata constructions.
\newblock In {\em LPAR} 2005, {\em LNCS} 3835, pp. 396--411. Springer.

\bibitem[VW86]{vw86}
M.~Y. Vardi and P. Wolper.
\newblock An automata-theoretic approach to automatic program verification
  (prelim. report).
\newblock In {\em LICS} 1986, pp. 332--344. IEEE.

\bibitem[VW94]{vw94}
Moshe~Y. Vardi and Pierre Wolper.
\newblock Reasoning about infinite computations.
\newblock {\em Inf. Comput.}, 115(1):1--37, 1994.

\end{thebibliography}
\fi



\end{document} 
