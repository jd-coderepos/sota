\documentclass[submission,copyright,creativecommons]{eptcs}
\providecommand{\event}{SR 2013} 

\usepackage{amssymb}
\setcounter{tocdepth}{3}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[babel]{csquotes}

\usepackage{amsmath}
\usepackage{stmaryrd}\usepackage{mathtools}\usepackage{amsthm}
\usepackage{enumitem}\usepackage{listings}
\usepackage{tikz}
\usepackage{caption}\usepackage{subcaption}\usepackage{calc}\usepackage{underscore}\usepackage{framed}

\usetikzlibrary{automata}
\usetikzlibrary{backgrounds}\usetikzlibrary{shapes}\usetikzlibrary{patterns}


\tikzstyle{every picture}+=[shorten >=1pt, node distance=2cm, inner sep=1mm, auto]
\tikzstyle{initial}+=[initial text=]
\tikzstyle{every state}+=[minimum size=5mm]

\DeclareSymbolFont{extra}{OML}{cmm}{m}{it}
\DeclareMathSymbol{\varrho}{\mathord}{extra}{'045}

\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}
\newtheorem*{remark}{Remark}

\newtheorem{definition}{Definition}[section]


\tikzstyle{every picture}+=[node distance=2cm, inner sep=1mm, auto]
\tikzstyle{initial}+=[initial text=]
\tikzstyle{every state}+=[minimum size=8mm]
\tikzstyle{active}+=[fill=red!40]
\tikzstyle{channel_cell}+=[rectangle, draw, minimum size=7mm]
\tikzstyle{marked}+=[draw=blue, line width=1]

\lstdefinelanguage{reactivelanguage}{
	morekeywords={while,input,output,skip,if,then,else,;,assign,call},
	morekeywords=[2]{True,False,iff,xor},
	sensitive=false,
	morecomment=[l]{//},
	morecomment=[s]{/*}{*/},
	morestring=[b]",
}

\lstset{
	language=reactivelanguage,
	basicstyle=\ttfamily,
	keywordstyle={},
	keywordstyle=[2]{},
	mathescape=true,
	escapechar=§,
	tabsize=4,
	alsoletter={;},
}

\lstdefinelanguage{pseudolanguage}{
	morekeywords={while,input,output,skip,if,then,else,assign,call,
	              repeat,until,do,return,end},
	morekeywords=[2]{True,False,iff,xor},
	sensitive=false,
	morecomment=[l]{//},
	morecomment=[s]{/*}{*/},
	morestring=[b]",
	alsoletter={chr(32)},
}

\newcommand*\phantomas[3][c]{\ifmmode
     \makebox[\widthof{}][#1]{}\else
     \makebox[\widthof{#2}][#1]{#3}\fi
}

\newcommand{\overbar}[1]{\mkern 1.5mu\overline{\mkern-1.5mu#1\mkern-1.5mu}\mkern 1.5mu}\newcommand{\nothing}{}
\newcommand{\ignore}[1]{}
\newcommand{\z}[1]{\text{#1}}
\newcommand{\ind}{\hspace{1cm}}
\newcommand{\ld}{\operatorname{ld}}
\newcommand{\set}[1]{\left\{ #1 \right\}}
\newcommand{\condset}[2]{\left\{ \, #1 \, \mid \, #2 \, \right\}}
\newcommand{\condsetm}[3]{\ensuremath{ \left\{ \text{ \parbox[t]{\widthof{}}{} } }}
\newcommand{\aut}[1]{\mathcal{#1}}
\newcommand{\specaut}{\aut{A}_{\overbar{R}}}
\newcommand{\lang}[1]{\mathcal{#1}}
\newcommand{\tlang}[1]{\mathit{#1}}
\newcommand{\opname}[1]{\operatorname{#1}}
\newcommand{\oper}[1]{\mathit{#1}}
\newcommand{\f}[1]{\mathit{#1}}
\newcommand{\sembrack}[1]{\llbracket #1 \rrbracket}
\newcommand{\sembrackk}[1]{\langle\langle #1 \rangle\rangle}\newcommand{\lbar}[1]{\overline{#1}}
\newcommand{\squeezetrans}[1]{#1}\newcommand{\transt}[2][]{\xrightarrow{\squeezetrans{#2}}_{#1}}
\newcommand{\transtinf}[2][]{\xrightarrow{\squeezetrans{#2}}_{#1}}
\newcommand{\trans}[2][]{\xrightarrow{\squeezetrans{#2}}_{#1}}
\newcommand{\transend}[2][]{\xrightarrow{\squeezetrans{#2}}\hspace{-4pt}\rule{0.5pt}{0.5\baselineskip}_{#1}\hspace{4pt}}
\newcommand{\transinf}[2][]{\xrightharpoonup{\squeezetrans{#2}}_{#1}}
\newcommand{\transs}[2][]{\stackrel{#2}{\rightsquigarrow}_{#1}}
\newcommand{\transsinf}[2][]{\twoheadrightarrow{#2}_{#1}}
\newcommand{\bigo}{\mathcal{O}}
\newcommand{\pcode}[1]{\textup{\tt{#1}}}\newcommand{\tup}[1]{\overline{#1}}
\newcommand{\notup}[1]{#1}
\newcommand{\cocfg}{\f{CoCfg}(B,\specaut)}
\newcommand{\cocfgk}{\f{CoCfg}_k(B,\specaut)}
\newcommand{\fincoex}[1]{\f{CoEx}^\z{fin}(#1,\specaut)}
\newcommand{\fincoexk}[1]{\f{CoEx}^\z{fin}_k(#1,\specaut)}
\newcommand{\fincomcoex}[1]{\f{CoEx}^\z{com}(#1,\specaut)}
\newcommand{\fincomcoexk}[1]{\f{CoEx}^\z{com}_k(#1,\specaut)}
\newcommand{\infcoex}[1]{\f{CoEx}^\infty(#1,\specaut)}
\newcommand{\infcoexk}[1]{\f{CoEx}^\infty_k(#1,\specaut)}
\newcommand{\kfg}{\gamma}
\newcommand{\prog}[1]{\text{``}{#1}\text{''}}

\newcommand{\sigmain}{\mathbb{B}}
\newcommand{\sigmaout}{\mathbb{B}}
\newcommand{\ioiin}{\mathbb{B}}
\newcommand{\ioiout}{\mathbb{B}}


\title{Synthesizing Structured Reactive Programs \\ via Deterministic Tree Automata}
\author{Benedikt Brütsch
	\institute{RWTH Aachen University, Lehrstuhl für Informatik 7, Germany}
	\email{bruetsch@automata.rwth-aachen.de}
}
\def\titlerunning{Synthesizing Structured Reactive Programs via Deterministic Tree Automata}
\def\authorrunning{Benedikt Brütsch}

\AtBeginDocument{
	\hypersetup{
		pdftitle = {\titlerunning},
		pdfauthor = {\authorrunning},
		pdfkeywords = {synthesis, reactive programs, tree automata}
	}
}

\begin{document}

\maketitle


\begin{abstract}
Existing approaches to the synthesis of reactive systems typically involve the
construction of transition systems such as Mealy automata.
However, in order to obtain a succinct representation of the desired system,
structured programs can be a more suitable model.
In 2011, Madhusudan proposed an algorithm to construct a structured
reactive program for a given -regular specification without
synthesizing a transition system first.
His procedure is based on two-way alternating -automata on finite
trees that recognize the set of "correct" programs.

We present a more elementary and direct approach using only deterministic
bottom-up tree automata that compute so-called \emph{signatures}
for a given program.
In doing so, we extend Madhusudan's results to the wider class
of programs with bounded delay, which may read several input symbols before
producing an output symbol (or vice versa).
As a formal foundation, we inductively define a semantics for such programs.
\end{abstract}

\vspace{2mm}
\section{Introduction}

Algorithmic synthesis is a rapidly developing field with many application
areas such as reactive sytems, planning and economics.
Most approaches to the synthesis of reactive systems, for instance
\cite{buchi_solving_1969,Rabin:1972:AIO:540412,DBLP:conf/popl/PnueliR89,kupferman_churchs_1999},
revolve around synthesizing transition systems such as Mealy or Moore
automata.
Unfortunately, the resulting transition systems can be very large.
This has motivated the development of techniques for the reduction of their
state space (for example, \cite{DBLP:journals/corr/abs-1102-4120}).
Furthermore, the method of bounded synthesis
\cite{schewe_bounded_2007,ehlers_symbolic_2010} can be used to synthesize
minimal transition systems by iteratively increasing the bound on the size
of the resulting system until a solution is found.\ignore{TODO: Is this an appropriate description?}
However, it is not always possible to obtain small transition systems.
For example, for certain specifications in linear temporal logic
(LTL), the size of the smallest transition systems satisfying these
specifications is doubly exponential in the length of the formula
\cite{rosner}.

Aminof, Mogavero and Murano \cite{aminof_synthesis_2012} provide a
round-based algorithm to synthesize hierarchical transition systems, which can be
exponentially more succinct than corresponding "flat" transition systems.
The desired system is constructed in a bottom-up manner:
In each round, a specification is provided and the algorithm constructs a
corresponding hierarchical transition system from a given library of available
components and the hierarchical
transition systems created in previous rounds.
Thus, in order to obtain a small system in the last
round, the specifications in the previous rounds have to be chosen in an
appropriate way.

Current techniques for the synthesis of (potentially) succinct implementations in the form
of circuits or programs typically proceed in an
indirect way, by converting a transition system into such an implementation.
For example, Bloem et al.\ \cite{Bloem20073}
first construct a symbolic representation (a binary decision diagram) of an
appropriate transition system and then extract a corresponding circuit.
However, this indirect approach does not necessarily yield a succinct result.

Madhusudan addresses this issue in \cite{madhusudan:LIPIcs:2011:3247}, where
he proposes a procedure to synthesize programs
without computing a transition system first. He considers
\emph{structured reactive programs} over a given set of Boolean variables,
which can be significantly smaller (regarding the length of the
program code) than equivalent transition systems.
To some degree, these programs separate control flow
from memory.
Such a separation can also be found in a related approach that has recently
been introduced by Gelderie \cite{Gelderie12}, where strategies for
infinite games are represented by \emph{strategy machines}, which are
equipped with control states and a memory tape.

Given a finite set of Boolean variables and a nondeterministic Büchi automaton
recognizing the complement of the specification,
Madhusudan constructs a two-way
alternating -automaton on finite trees that recognizes the set of
\emph{all} programs over these variables that satisfy the specification.
This automaton can be transformed into a nondeterministic tree automaton (NTA)
to check for emptiness and extract a minimal program
(regarding the height of the corresponding tree) from that set.
In contrast to the transition systems constructed by classical synthesis
algorithms, the synthesized program does not depend on the specific syntactic
formulation of the specification, but only on its meaning.

In this paper, we present a direct construction of a deterministic bottom-up
tree automaton (DTA) recognizing the set of correct programs, without a detour
via more intricate types of automata.
The DTA inductively computes a representation of the behavior of a given
program in the form of so-called \emph{signatures}.
A similar representation is used by Lustig and Vardi in their work on the
synthesis of reactive systems from component libraries
\cite{Lustig09} to characterize the behavior of\ignore{TODO: Adjective here?}
the components.

Our approach is not limited to programs that read input and write output in
strict alternation, but extends Madhusudan's results to the more general class
of programs with \emph{bounded delay}:
In general, a program may read multiple input symbols before writing the next
output symbol, or vice versa, causing a delay between the input sequence and
the output sequence.
In a game-theoretic context, such a program corresponds to a strategy for a
controller in a game against the environment where in each move
the controller is allowed to either choose at least one output symbol or
skip and wait for the next input (see \cite{Holtmann10}).
\ignore{Reading multiple input symbols in a row is necessary to satisfy specifications
that require a certain amount of lookahead on the input sequence.
On the other hand, writing multiple output symbols in a row may
reduce\ignore{TODO! Other word?} the required number of program variables,
because once an output symbol has been written, no information about that
symbol has to be stored anymore.}
We consider programs that never cause a delay greater than a given bound
.

\ignore{
Note that reading multiple input symbols in a row can be necessary if the
specification requires a certain amount of lookahead on the input sequence.
On the other hand, writing multiple output symbols before reading the next
input symbol may reduce the required number of program variables.
For example, consider the specification that requires for some fixed
 that the th output symbol agrees with the th
input symbol, for all .
Any program that reads input and writes output in strict alternation needs at
least  Boolean variables to satisfy the specification.
However, if the first  output symbols are written
before reading the first input symbol, a single variable suffices.
}

For a fixed , the complexity of our construction matches that of
Madhusudan's algorithm.
In particular, the size of the resulting DTA is exponential in the size of the
given nondeterministic Büchi automaton recognizing the complement of the
specification, and doubly exponential in the number of program variables.
In fact, we establish a lower bound, showing that the set of all programs
over  Boolean variables that satisfy a given specification cannot even be
recognized by an NTA with less than  states,
if any such programs exist.
However, note that a DTA (or NTA) accepting precisely these programs enables
us to extract a minimal program for the given specification and the given set
of program variables.
Hence, the synthesized program itself might be rather small.

To lay a foundation for our study of the synthesis of structured reactive
programs, we define a formal semantics for such programs, which is only
informally indicated by Madhusudan.
To that end, we introduce the concept of
\emph{Input/Output/Internal machines (IOI machines)},
which are composable in the same way as structured programs.
This allows for an inductive definition of the semantics.
\ignore{TODO: Point to technical report?}

\vspace{5mm}
\section{Syntax and Semantics of Structured Programs}

We consider a slight modification of the structured
programming language defined in \cite{madhusudan:LIPIcs:2011:3247},
using only single Boolean values as input and output symbols to simplify
notation.
\emph{Expressions} and \emph{programs} over a finite set  of
Boolean variables
are defined by the following grammar, where :
\vspace{6pt}
\newcommand{\tbar}{\enspace\,|\,\enspace}\newcommand{\ph}[1]{\langle\mathit{#1}\rangle}
2pt]
	\begin{array}{ccl}
		\ph{prog} & \Coloneqq & b \coloneqq \ph{expr} \tbar \pcode{input }b \tbar \pcode{output }b \tbar
								\ph{prog}\pcode{;}\ph{prog} \\
				&			&	\pcode{if } \ph{expr} \pcode{ then } \ph{prog} \pcode{ else } \ph{prog} \tbar
								\pcode{while } \ph{expr} \pcode{ do } \ph{prog}
	\end{array}

	\varrho = q_1 \transt{(a_1,b_1)} q_2 \transt{(a_2,b_2)} q_3 \transt{(a_3,b_3)} \cdots

The \emph{label} of  is the pair of finite or
infinite words
.
An \emph{initial computation} starts at the unique entry
state where all variables have the value .
The \emph{infinite behavior}  of a program 
is the set of infinite input/output sequences

that can be produced by an initial computation of .
Furthermore, we call a program \emph{reactive} if all its initial computations
can be extended to infinite computations that yield an infinite input
and output sequence.

At any given time during a computation  as above, the length of the
input sequence  and the output sequence 
might differ.
The supremum of these length differences along a computation is called the
\emph{delay} of the computation.
If the delay of a computation does not exceed a given bound
 then we call this computation \emph{-bounded}.
A program is said to be -bounded if all its computations are -bounded.
By restricting the infinite behavior of a program  to labels of
-bounded initial computations,
we obtain the \emph{-bounded infinite behavior}  of .


\section{Solving the Synthesis Problem Using Deterministic Tree Automata}

The synthesis problem for structured reactive programs with bounded delay
can be formulated as follows:
Given an -regular specification
 representing
the permissible input/output sequences,
a finite set of Boolean variables  and a delay bound ,
the task is to construct a structured reactive program  over  with
-bounded delay such that  -- or detect that
no such program exists.
(However, our results can easily be generalized to finite input and
output alphabets other than  by allowing input and output
statements that process multiple Boolean values as in
\cite{madhusudan:LIPIcs:2011:3247}.)
In the following we assume that the specification  is provided in the
form of a \emph{nondeterministic Büchi automaton (NBA)} 
over the alphabet  that recognizes the
complement of the specification, i.e.,
,
which is always possible for -regular specifications.

Our synthesis procedure is based on the fact that programs can be
viewed as trees.
Figure \ref{progtreeex} shows an example for a tree representation of a
program.
We use \emph{deterministic bottom-up tree automata} (\emph{DTAs},
see, for example, \cite{rozenberg_languages_1997})
to recognize sets of programs.
More specifically, we show the following theorem:
\begin{theorem}\label{dtatheorem}
	Let  be a finite set of Boolean variables,
	let  and
	let  be a nondeterministic Büchi automaton recognizing the
	complement of a specification
	.
	We can construct a DTA that accepts
	a tree  iff  is a reactive program over  with -bounded delay
	and , such that the size of this DTA
	is doubly exponential in  and  and exponential in the size of
	.
\end{theorem}\ignore{TODO: Time complexity?}
\begin{figure}[h!]
\centering

\setlength{\FrameSep}{\fboxsep-0.5mm}\begin{subfigure}[h]{0.3\linewidth}\ignore{TODO: Better example?}
\begin{framed}
\begin{minipage}[c][3.8cm][c]{\linewidth}\begin{lstlisting}[linewidth=\dimexpr\linewidth-8mm\relax,xleftmargin=2mm]
 while true do {
     input ;
     ;
     output 
 }
\end{lstlisting}
\end{minipage}
\end{framed}
\end{subfigure}
\begin{subfigure}[h]{0.6\linewidth}
\begin{framed}
\begin{minipage}[c][3.8cm]{\linewidth}
\centering
\vspace{2mm}
\resizebox{\dimexpr\linewidth-5mm\relax}{!}{
\begin{tikzpicture}
\tikzstyle{every node}+=[inner sep=2mm,rectangle,draw]
\tikzstyle{level}+=[sibling distance=50mm,level distance=7mm]
\tikzstyle{level 4}+=[level distance=9mm]
\tikzstyle{level 5}+=[sibling distance=25mm,level distance=5mm]

\node (while) {\texttt{while}}
        child {node (true) {\texttt{true}}}
        child {node (semi1) {\texttt{;}}
            child {node (input) {\texttt{input }}}
            child {node (semi2) {\texttt{;}}
                child {node (assign) {\texttt{assign}-}
                    child {node (and) {}
                        child {node (b1) {}}
                        child {node (b2) {}}
                    }
                }
                child {node [rectangle,draw] (output) {\texttt{output }}}
            }
        };
\end{tikzpicture}
}
\vspace{2mm}
\end{minipage}
\end{framed}
\end{subfigure}

\caption{Example: A program and its tree representation.}
\label{progtreeex}
\end{figure}

An emptiness test on this DTA yields a solution to the synthesis problem.
We obtain the desired tree automaton by intersecting three DTAs:
The first DTA  recognizes
the set of programs over  whose -bounded computations satisfy the
specification . That means, a program  is accepted iff
.
The second DTA  recognizes the reactive
programs over .
Finally, we use a third DTA  to recognize the programs
over  with -bounded delay.
We only consider the construction of  here,
as the other two DTAs can be constructed in a very similar way.

The DTA  evaluates a given program  in a
bottom-up manner, thereby assigning one of its states to each node of the
program tree.
The state reached at the root node must provide
enough information to decide whether ,
or equivalently, whether
.
To that end, we are interested in the possible runs of 
on the input/output sequences generated by the program.
Thus, we consider pairs of program computations and corresponding runs of
, which we call \emph{co-executions}.
Intuitively,  inductively computes a
representation of the possible co-executions of a given program and
.
We define these representations, called \emph{co-execution signatures},
in the following.

The beginning and end of a co-execution can be indicated by
a valuation of the program variables and a state of .
However, we have to consider the following:
The input sequence of a computation might be longer or shorter than
its output sequence, but a run of  only consumes input and
output sequences of the same length.
The suffix of the input/output sequence after the end of the shorter sequence,
called the \emph{overhanging suffix}, is hence still waiting to be
consumed by .
Thus, we indicate the start and end of a co-execution by tuples of the
form , called \emph{co-configurations},
where  is a variable valuation,  is a state of  and
 is an
overhanging suffix.
Since we are only interested in -bounded computations, we only
consider co-configurations with  and .
The set of these co-configurations for a given set of variables  and a
given NBA  is denoted by .

A finite co-execution is called \emph{complete} if the program terminates at
the end of the computation.
The \emph{finite co-execution signature} 
of a program  (with respect to ) is a relation consisting of
tuples of the form  with ,
which indicate that there exists a complete -bounded co-execution that\ignore{TODO: k-bounded co-execution? Definition?}
starts with the co-configuration  and ends with  such that the corresponding
run of  visits a final state iff .
The \emph{infinite co-execution signature}
 of  is a set of co-configurations with
 iff there exists an infinite
-bounded co-execution starting with  such that the run of 
visits a final state infinitely often.
We use pairs consisting of a finite and infinite co-execution signature as
states of the DTA .
The size of the DTA is hence determined by the number of possible
co-execution signatures, which is doubly exponential in the number of
variables and  and exponential in the size of .
For a fixed , this matches the complexity of Madhusudan's construction
\cite{madhusudan:LIPIcs:2011:3247}.

If  is the initial variable valuation (where all variables have the value
) and  is the initial state of , then

iff there is an initial -bounded computation of  such that some
corresponding run of  visits a final state infinitely often,
so  is indeed sufficient to decide whether
.
It remains to be shown that the co-execution signatures can be computed
inductively.
Exemplarily, we consider the case of programs of the form
.
First, we construct a representation 
of all finite sequences of consecutive
co-executions of  that are compatible with the loop condition .
To that end, we consider only
those tuples  in 
where the variable valuation in 
satisfies the loop condition , and compute the reflexive transitive closure
of the resulting relation.
Formally, we have
 with
.
Here,  denotes the set of variable valuations that satisfy ,
and  is the smallest relation

\,such that
\begin{itemize}
	\item  for all , and
	\item  implies .
\end{itemize}

Using ,
the co-execution signatures for  can be
computed by the following reasoning:
A finite co-execution of
 (and )
can be decomposed into a finite sequence of co-executions of .
An infinite co-execution of  can either eventually stay
inside a loop iteration forever or traverse infinitely many iterations.
It can therefore be decomposed either into a finite sequence of
co-executions of  followed by an infinite co-execution
of ,
or into a finite sequence of co-executions of  followed by
a cycle of co-executions of , leading back to a previous
co-configuration.
Thus, we obtain the following formal representation of the co-execution
signatures for :

\begin{itemize}
	\item  \; iff \;
		
		and .
	\item  iff at least one of the following holds:
		\begin{itemize}
			\item There exist  and
				 \\
				such that
				, \,
				 and
				.
			\item There exist  and
				 \\
				such that
				, \,
				 and
				.
		\end{itemize}
\end{itemize}


\section{Lower Bound for the Size of the Tree Automata}\label{optimality}

We show the following lower bound for the size of any nondeterministic tree
automaton (NTA) recognizing the desired set of programs:
\begin{theorem}\label{lowerboundnta}
	Let  be a set of  Boolean variables,
	let  and
	let 
	be a specification that is realizable by some program over  with
	-bounded delay.
	Let  be an NTA that accepts
	a tree  iff  is a reactive program over  with -bounded delay
	and .
	Then  has at least  states.
\end{theorem}

For a sketch of the proof,
consider a set of Boolean variables .
There are  functions of the type
.
Each of these functions can be implemented by a program that checks the values
of  and sets  to the corresponding function value.
An NTA as in Theorem \ref{lowerboundnta} must be able to distinguish
all of these programs.
Otherwise, let  and  be two such programs that cannot be
distinguished by the NTA.
We could then construct a program that satisfies the specification and
contains  as a subprogram, but runs into a non-reactive infinite loop
if this subprogram is replaced by .
The NTA would accept both variants, including the non-reactive program,
which contradicts the premise.


\section{Conclusion}

The contributions of this paper are threefold,
advancing the study of structured reactive programs:
We introduced a formal semantics for structured reactive programs in the sense
of \cite{madhusudan:LIPIcs:2011:3247}.
Furthermore, we presented a new synthesis algorithm for structured reactive
programs with bounded delay, using the elementary concept of deterministic
bottom-up tree automata.
Finally, we showed a lower bound for the size of any nondeterministic tree
automaton that recognizes the set of specification-compliant programs,
emphasizing the importance of choosing a small yet still sufficient set of
program variables.
Estimating the number of Boolean variables that are needed to realize a given
specification is a major open problem.
While \cite{rosner} implies an exponential upper bound for the required
number of variables in the case of LTL specifications, a corresponding lower
bound is still to be determined.

\ignore{
We presented a new synthesis algorithm for structured reactive programs with
bounded delay using the elementary concept of deterministic bottom-up tree
automata.
Our approach yields a characterization of the behavior of a program in the
form of signatures, which can be deduced from the signatures of the
subprograms.
We showed a lower bound for the size of any nondeterministic tree automaton
that recognizes the set of specification-compliant programs,
emphasizing the importance of choosing a small yet still sufficient set of
program variables.
A major open problem is the estimation of the number of Boolean variables
that are needed to realize a given specification.
While \cite{rosner} implies an exponential upper bound for the required
number of variables in the case of LTL specifications, a corresponding lower
bound is still to be determined.
}

\paragraph*{Acknowledgments.}
The author would like to thank Wolfgang Thomas for his helpful advice and
Marcus Gelderie\ignore{TODO: Insert.} for fruitful discussions.


\bibliographystyle{eptcs}
\bibliography{bibliography}

\end{document}
