\documentclass[natbib,sort,smallextended,envcountsame,envcountsect,numbook]{svjour3}
\pdfoutput=1
\smartqed
\usepackage{amssymb,amsmath}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{txfonts}
\usepackage{microtype}
\usepackage{mathtools}
\usepackage{mathtools}
\usepackage{hyperref}
\usepackage[capitalize,noabbrev]{cleveref}
\usepackage{doi}



\Crefname{observation}{Observation}{Observations}
\Crefname{assumption}{Assumption}{Assumptions}
\Crefname{problem}{Problem}{Problems}

\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{paralist}
\usepackage[textsize=scriptsize]{todonotes}
\hypersetup{colorlinks,allcolors=blue}
\spnewtheorem{observation}[theorem]{Observation}{\bfseries}{\normalfont}
\spnewtheorem{assumption}[theorem]{Assumption}{\bfseries}{\normalfont}
\spnewtheorem{algorithm}[theorem]{Algorithm}{\bfseries}{\normalfont}
\newcommand{\HC}{H}
\newcommand{\bigO}{O}
\newcommand{\Ostern}{\bigO^*}
\newcommand{\ps}{pre-stay}
\newcommand{\psc}{pre-schedule}
\newcommand{\rsc}{relative schedule}
\newcommand{\las}{length assignment}
\newcommand{\dis}{displacement}

\newcommand{\queues}[1]{{g_{#1}}}
\newcommand{\MsVQ}[1]{\Ms_{\smash{#1}}^{\smash{g_{#1}}}}
\newcommand{\TsvM}[2]{\Ts_{\smash{#1}}^{\smash{R_{M_{#2}}}}}
\newcommand{\TsvMp}[2]{\Ts_{\smash{#1}}^{\smash{R'_{M_{#2}}}}}
\newcommand{\TsJS}[2]{\Ts_{\smash{J_{#1}}}^{\smash{#2}}}
\newcommand{\TsMS}[2]{\Ts_{\smash{M_{#1}}}^{\smash{#2}}}
\newcommand{\JsMS}[2]{\Js_{\smash{M_{#1}}}^{\smash{#2}}}
\newcommand{\MsJS}[2]{\Ms_{\smash{J_{#1}}}^{\smash{#2}}}
\newcommand{\depo}{v^*}
\newcommand{\ROS}{\textsc{ROS}}
\newcommand{\ROSUPT}{\textsc{ROS-UET}}
\newcommand{\TSP}{\textsc{Metric TSP}}
\newcommand{\OS}{Open Shop}
\newcommand{\sched}{S}
\newcommand{\loc}{\text{loc}}
\newcommand{\poly}{\text{poly}}
\newcommand{\ptrt}{n \log n}
\newcommand{\dist}{\text{dist}}
\newcommand{\Js}{\mathcal J}
\newcommand{\Ms}{\mathcal M}
\newcommand{\Ts}{\mathcal T}
\newcommand{\njobs}{n}
\newcommand{\nmach}{m}
\newcommand{\nverts}{g}
\newcommand{\nedgs}{|E|}
\newcommand{\setjobsin}[1]{\mathcal J_{#1}}
\newcommand{\jobsin}[1]{n_{#1}}
\newcommand{\cry}[1]{k(#1)}
\newcommand{\tcry}{K}
\newcommand{\arr}{a}
\newcommand{\dep}{b}
\newcommand{\stops}{s}
\newcommand{\len}{L}
\newcommand{\Pro}{P}
\newcommand{\Gr}{G}
\def\pvstays{\ensuremath{{m+2g-3}}}
\def\totstays{\ensuremath{{m^2+(2g-3)m}}}
\def\pvfinstances{\ensuremath{(\nverts\nmach)^{\nmach\cdot(\pvstays)}}}

\title{A fixed-parameter algorithm for a routing open shop problem: unit processing times, few machines and locations\thanks{A preliminary version of this work appeared at CSR'16 \citep{BP16}.  This version provides simpler proofs, a faster algorithm that runs in ~time for fixed  and~, and replaces the incorrect upper bound given in Lemma~5.5 of the old version by an asymptotically stronger upper bound.}}
\titlerunning{A fixed-parameter algorithm for routing open shop with unit processing times}

\author{René van Bevern\thanks{René van Bevern is supported
by the Russian Foundation for Basic Research, grant~16-31-60007 mol\textunderscore{}a\textunderscore{}dk.}
\and
Artem V.\ Pyatkin\thanks{Artem V.\ Pyatkin is supported
by the Russian Foundation for Basic Research, grants~17-01-00170 and~15-01-00976.}}

\institute{René van Bevern \and Artem V.\ Pyatkin \at Novosibirsk
  State University, Novosibirsk, Russian Federation,
  \email{rvb@nsu.ru, artem@math.nsc.ru} \and René van Bevern \and
  Artem V.\ Pyatkin \at Sobolev Institute of Mathematics of the
  Siberian Branch of the Russian Academy of Sciences, Novosibirsk,
  Russian Federation}

\date{Submitted: \today{}}

\begin{document}

\maketitle
\begin{abstract}
  \noindent\looseness=-1
  The open shop problem is
  to find a minimum makespan schedule
  to process each job~
  on each machine~
  for ~time
  such that,
  at any time,
  each machine processes at most one job
  and
  each job is processed by at most one machine.
  We study a problem variant in which the jobs are located
  in the vertices
  of an edge-weighted graph.
  The weights determine the time needed
  for the machines
  to travel between jobs in different vertices.
  We show that the problem with ~machines and
  ~unit-time jobs in ~vertices
  is solvable in ~time.
  \keywords{routing\and
    scheduling\and
    setup times\and
    UET\and
    NP-hard problem
  }
\end{abstract}
\section{Introduction} 
\noindent
\citet{GS76} introduced the open shop problem:
given
a set~ of jobs,
a set~ of machines,
and the processing time~ that job~ needs on machine~,
the goal is
to process each job on each machine
in a minimum total amount of time
such that
each machine processes at most one job at a time
and
each job is processed by at most one machine at a time.

\citet{ABC06} introduced a problem variant
where the jobs are located
in the vertices of an edge-weighted graph.
The edge weights determine
the time needed for the machines to travel between jobs in different vertices.
In their setting, all machines have the same travel speed
and
the travel times are symmetric.
Initially,
the machines are located in a vertex called the \emph{depot}.
The goal is to minimize
the time needed for processing
each job by each machine and
returning all machines to the depot.
This problem variant models, for example, scenarios
where machines or specialists
have to perform maintenance work
on objects in several places.
The travel times have also been interpreted
as sequence-dependent machine-independent
batch setup times \citep{ANCK08,ZW06}.

In order to formally define the problem,
we first give a formal model for a transportation network
and machine routes.
Throughout this work,
we use~.

\begin{definition}[network, depot, routes]
  A \emph{network}~ consists of
  a set~ of \emph{vertices} and
  a set~ of \emph{edges}
  such that  is a connected simple graph,
  travel times~,
  and a vertex~ called the \emph{depot}.
  We denote the number of vertices in a network
  by~. 
  
  A \emph{route with ~stays} is
  a sequence~
  of \emph{stays}~
  from time~ to time~
  in vertex~ for 
  such that , ,
  
  The \emph{length} of~ is the end~ of the last stay.  
\end{definition}

\noindent
\looseness=-1
Note that a route is actually fully determined
by the  and  for each~,
yet it will be convenient to refer to both
\emph{arrival time~} and \emph{departure time~} directly.
We now define the routing open shop variant (ROS) introduced by \citet{ABC06}.

\begin{definition}[\ROS{}]\label[definition]{def:ros}
  An \emph{instance}~
  of the \ROS{} problem
  consists of a network~,
  a set  of~\emph{jobs},
  a set  of~\emph{machines},
  job \emph{locations}~,
  and an -matrix~
  determining the \emph{processing time}~
  of each job~ on each machine~.

  \looseness=-1
  A \emph{schedule}  is
  a function determining the \emph{start time}~
  of each job~ on each machine~.
  A job~ is \emph{processed}
  by a machine~
  in the half-open time interval~.
  A schedule is \emph{feasible} if and only if
  \begin{enumerate}[(i)]
  \item\label{def:feas2} no machine~ processes two jobs~ at the same time, that is,  or  for all jobs~ and machines~,
  \item\label{def:feas3} no job~ is processed by two machines~ at the same time, that is,  or  for all jobs~ and machines~, and
  \item\label{def:feas4} there are routes~
    \emph{compatible with~}, that is,
    for each job~ and each machine~
    with route~,
    there is a 
    such that
    
    with  and .
  \end{enumerate}
  The \emph{makespan} of a feasible schedule~
  is the minimum value~
  such that
  there are routes~ compatible with~
  and each having length at most~.
  An \emph{optimal solution} to \ROS{}
  is a feasible schedule with minimum makespan.
\end{definition}

\noindent
\looseness=-1
Note that a schedule for \ROS{} only
determines the start time of each job on each machine,
not the times and destinations of machine movements.
Yet the start times of each job on each machine
fully determine the order
in which each machine processes its jobs.
Thus,
one can easily construct compatible routes if they exist:
each machine simply takes the shortest path
from one job to the next
if they are located in distinct vertices.


\paragraph{Preemption and unit processing times} 
The open shop problem is NP-hard even in the special cases
of ~machines \citep{GS76} or if all processing times are one or two \citep{KSS12}.
Naturally, these results transfer to \ROS{} with
with ~vertex.
\ROS{} remains (weakly) NP-hard
even for  \citep{ABC06}
and there are approximation algorithms
both for this special and the general case of \ROS{}
\citep{ABC05,YLWF11,CKS13,Kon15}.
However, the open shop problem is solvable in polynomial time if
\begin{enumerate}[(1)]
\item\label{case1}job preemption is allowed, or
\item\label{case2}all jobs~ have unit processing time~  on all machines~.
\end{enumerate}

\looseness=-1
\noindent
It is natural to ask how these results
transfer to \ROS{}.
Regarding~\eqref{case1},
\citet{PCh12} have shown that
\ROS{} with allowed preemption
is solvable in polynomial time
if ,
yet NP-hard for  and
an unbounded number~ of machines.
Regarding \eqref{case2}, our work studies
the following special case of \ROS{} with unit execution times (\ROSUPT):

\begin{problem}
  By \ROSUPT{}, we denote \ROS{} restricted to instances
  where each job~ has unit processing time~ on each
  machine~.
\end{problem}

\noindent
\ROSUPT{} models scenarios where machines or specialists
process batches of roughly equal-length jobs
in several locations and
movement between the locations
takes significantly longer
than processing each individual job in a batch.
\ROSUPT{} is NP-hard even for  machine
since it generalizes the metric travelling salesman problem.
It is not obvious whether it is solvable in polynomial time
even when both  and~ are fixed.
We show that, in this case,
\ROSUPT{} is solvable even in ~time, that is, \ROSUPT{} is
\emph{fixed-parameter tractable} parameterized by~.


\paragraph{Fixed-parameter algorithms}
Fixed-parameter algorithms are an approach towards
efficiently and optimally solving NP-hard problems:
the main idea is to accept the exponential running time
for finding optimal solutions,
yet to confine it
to some small problem parameter~.
A problem with parameter~
is called \emph{fixed-parameter tractable~(FPT)}
if there is an algorithm that solves any instance~
in ~time,
where ~is an arbitrary computable function.
The corresponding algorithm is called \emph{fixed-parameter algorithm}.  
For more detail,
we refer the reader to the recent text book by \citet{CFK+15}.

\looseness=-1
Note that a fixed-parameter algorithm
running in ~time
runs in polynomial time for~,
whereas an algorithm with running time~
runs in polynomial time only if ~is constant.
The latter algorithm is not a fixed-parameter algorithm.


Recently, the field of fixed-parameter algorithmics
has shown increased interest in scheduling and routing
\citep{CMY+17,BBB+16b,BCH+15,BMNW15,BNS16,BF95,FM03,HK06,
  HKS+15,MW15,BKS17,BNSW14,DMNW13,GWY17,GJW16,GJS17,GMY13,JMS17,KM14,
  SBNW11,SBNW12},
whereas fixed-parameter algorithms for problems
containing elements of both routing and scheduling
seem rare \citep{BHKK07}.


\paragraph{Input encoding}
Encoding a \ROS{} instance
requires ~bits
in order to encode the processing time of each of ~jobs
on each of ~machines
and the travel time along each of at least ~edges.
We call this the \emph{standard encoding}.
In contrast, a \ROSUPT{} instance
can be encoded using
 bits
by encoding only the number of jobs in each vertex, where  is the maximum travel time.  We call this the \emph{compact encoding}.

All running times in this article are stated
for computing a minimum makespan schedule,
whose encoding requires ~bits
for the start time of each job on each machine.
Thus,
outputting the schedule is impossible
in time polynomial in the size of the compact encoding.
We therefore assume
to get the input instance in standard encoding,
like for the general \ROS{} problem.


However, we point out that the \emph{decision version} of \ROSUPT{}
is fixed-parameter tractable
parameterized by~
even when assuming the compact encoding:
our algorithm can decide whether
there \emph{exists} a schedule of given makespan~
in ~time
if ~is a \ROSUPT{} instance given in compact encoding
(when replacing line~\ref{lin:complsched} of \cref{alg:outline}
by ``return '', it will simply output the minimum makespan
instead of constructing the corresponding schedule).

\paragraph{Organization of this work}
In \cref{sec:preprop},
we apply some basic preprocessing
that allows us to
assume  that travel times
satisfy the triangle inequality.
In \cref{sec:ubo},
we prove upper and lower bounds
on the minimum makespan of schedules
and on the number and length of stays
of routes compatible with some optimal schedule.
In \cref{sec:fpt}, we present our fixed-parameter algortihm.


\section{Preprocessing for metric travel times}\label{sec:preprop}
\noindent
In this section,
we transform \ROS{} instances
into equivalent instances
with travel times
satisfying the triangle inequality.
This will allow us to assume that,
in an optimal schedule,
a machine only stays in a vertex
if it processes at least one job there:
otherwise, it could take a ``shortcut'',
bypassing the vertex.

\begin{lemma}\label[lemma]{lem:metric}
  Let ~be a \ROS{} instance
  and
  let ~be obtained from~
  by replacing the network~ in~
  by the network~
  such that
   is a complete graph and
  ,
  where ~is the length
  of a shortest path
  between~ and~ in~ with respect to~.

  Then,  any feasible schedule for~
  is a feasible schedule for 
  with the same makespan and vice versa.
\end{lemma}

\begin{proof}
  Clearly, any feasible schedule~ of makespan~ for~
  is a feasible schedule of makespan at most~ for~. We show that any feasible schedule~ of makespan~ for~
  is a feasible schedule of makespan at most~ for~.
  This is because, for any route~ compatible with~
  in~,
  we get a route~ of the same length compatible with~ in~:
  between each pair of consecutive
  stays~ and~ on~
  and a path~
  of length~
  with respect to~  in~,
  add zero-length stays in the vertices
  
  of~.  This yields a route~ for~
  of the same length as~ since the end of the last stay has not changed.
\qed\end{proof}

\noindent
The travel times~
in the network~ created in \Cref{lem:metric}
satisfy the triangle inequality.
Thus,
one can assume that, except for the depot, a machine
never visits a vertex of~ that has no jobs.
Since one can delete such vertices,
in the following,
we will make the
following simplifying assumption without loss of generality.

\begin{assumption}\label[assumption]{obs:delverts}
  Let ~be a \ROS{} instance
  on a network~.
  Then,
  \begin{enumerate}[(i)]
  \item\label{ass1} the travel times~ satisfy the triangle inequality,
  \item\label{ass2} each vertex~ contains at least one job.
  \end{enumerate}
\end{assumption}


\section{Upper and lower bounds on makespan, number and lengths of stays}\label{sec:ubo}
\noindent
In this section,
we show lower and upper bounds on the makespan
of optimal \ROSUPT{} schedules,
as well as
on the number and the lengths of stays
of routes compatible with optimal schedules.
These will be exploited
in our fixed-parameter algorithm.


By \cref{obs:delverts}\eqref{ass1},
the travel times in the network~ of a \ROSUPT{} instance
satisfy the triangle inequality.
Thus, the minimum cost of a cycle
visiting each vertex of~ \emph{at least once}
coincides with the minimum cost of a cycle
doing so \emph{exactly once} \citep{Ser78},
that is, with that of a minimum-cost \emph{Hamiltonian cycle}.

A trivial lower bound
on the makespan of optimal \ROSUPT{} schedules
is given by the fact that,
in view of \cref{obs:delverts}\eqref{ass2},
each machine has to visit
all vertices at least once
and has to process ~jobs.
A trivial upper bound is given by
the fact that the machines can process the jobs sequentially.
We thus obtain the following:
\begin{observation}\label[observation]{obs:lobo}
  Let ~be a \ROSUPT{} instance on a network~
  with a minimum-cost Hamiltonian cycle~.
   Then, the makespan of an optimal schedule to~ lies in
   

    Moreover, a schedule with makespan  for
    \ROSUPT{} is computable in
    ~time if a Hamiltonian
    cycle~ for the network of the input
    instance is also given as input.
\end{observation}

\noindent
We can improve the upper bound
on the makespan
if :
\begin{proposition}\label[proposition]{thm:artem}
  A feasible schedule of length 
  for \ROSUPT{} is computable in ~time
  if a Hamiltonian
  cycle~ for the network of the input
  instance is also given as input.
\end{proposition}
\begin{proof}
  Without loss of generality, assume that .  Otherwise, we
  can simply add
  ~additional jobs to the depot and finally remove them from the
  constructed schedule.  We will construct a feasible schedule~
  of length~.

  Let~,
  where ~is the depot.
  Without loss of generality,
  let the jobs~ be ordered so that,
  for jobs~ with~, one has 
  and  with~.
  That is, the first jobs are in~,
  then follow jobs in~, and so on.  
  We will construct our schedule from the
  matrix~, where
  i< q
  \looseness=-1
  Figuratively, each row of~ is a cyclic right-shift of the previous row.
Call a cell  \textit{red} if  and \textit{green} otherwise. Note that, if  and  are of the same color and  or , then . Moreover, the number in a red cell is larger than the number in any green cell in the same row or column: if ~is red and  is green, then from
 
and if ~is red and ~is green, then from

Let  be the travel time from  to  along~.  Clearly, the sequence~ is non-decreasing and~.  Our schedule~ is now given by

Let us prove that this schedule is feasible in terms of \cref{def:ros}. Indeed, by construction, for two elements  and  with  or  and , one has  since the value added to  is not smaller than the value added to  due to our sorting of jobs by non-decreasing vertex indices and because the value added to any red cell is larger than any value added to a green cell.  Therefore, conditions~\eqref{def:feas2} and \eqref{def:feas3} are satisfied.

It remains to verify \eqref{def:feas4}, that is,
that there are compatible routes~
for each machine~.
We let machine~ follow~ twice.
During the first stay~ in a vertex~,
machine~ processes all jobs~
such that  is green.
During the second stay~,
it processes all jobs~
such that ~is red.
By the choice of~ for red cells, the machines have enough time to go around~ a second time. 
The length of the schedule is :
each machine uses ~time for traveling,
~time for processing the ~jobs,
and is never idle.
\qed\end{proof}

\noindent
\looseness=-1
The machines in the proof of
\cref{thm:artem} visit vertices twice.
The following example shows a \ROSUPT{} instance
for which \cref{thm:artem} computes an optimal schedule
and where the machines in an optimal schedule
\emph{have} to visit vertices repeatedly.
\begin{example}\label[example]{ex:badhamilton}
  Consider a \ROSUPT{} instance on a network~
  with two vertices~ and~
  and one edge~ with .
  Vertex~ contains one job~,
  vertex~ contains ~jobs~.
  A machine visiting~ only once
  either has to process first  and then ,
  or first all of  and then~.
  
  Assume that we have ~machines,
  where a set~ of ~machines processes~ first
  and a set~ of ~machines processes~ last.
  Then one of the machines in~ has to wait
  for the ~other machines in order to start~.
  Similarly, after finishing all jobs~,
  one of the machines in~ has to wait
  for the ~other machines in order to start~.
Thus, this schedule has makespan at least~:
  there is a machine that spends
  ~time for travelling, ~time for processing,
  and at least ~time for idling.

  \cref{thm:artem} gives a schedule with makespan
  , which is smaller than 
  if .
  Thus, in this instance, at least one machine in an optimal schedule
  has to visit ~twice, which incurs a travel time of~.
  Since this machine also has to process ~jobs,
  it follows that the bound  given by \cref{thm:artem}
  is optimal in this case.
\end{example}

\noindent The above example shows that,
in an optimal solution to \ROSUPT{},
it can be necessary that machines visit vertices several times.
The following lemma gives and upper bound
on the number and length of stays of a machine in an optimal schedule.

\begin{lemma}\label[lemma]{lem:vislength}\label[lemma]{lem:shortcyc}
  Let ~be an optimal schedule
  for a \ROSUPT{} instance on a network~.
  Let ~be the makespan of~ and ~be routes
  of length at most~ compatible to~.
  Then, for each machine~,
  the route 
  \begin{enumerate}[(i)]
  \item has at most  stays, and
    
  \item the total length of the stays
    in any vertex~ with ~jobs is
  
\end{enumerate}
\end{lemma}
\begin{proof}
  Let ~be a minimum-cost Hamiltonian cycle in~.
  We show that, if one of (i) or (ii) is violated,
  then ~has makespan at least ,
  contradicting \cref{obs:lobo}.

  (i)
  If  had at least ~stays,
  then,
  by \cref{prop:longcyc} in our graph-theoretic \cref{appendix},
  machine~ would be traveling
  for at least ~time.
  Since the machine~ is processing jobs
  for ~time units,
  the makespan of  is at least ,
  a contradiction.
  
  (ii)
  Machine~ takes at least ~time just
  for visiting all vertices and processing all jobs.
  If \eqref{slen} does not hold,
  then machine~ is neither travelling nor processing
  for at least ~time units.
  Thus, the length of route~ and,
  therefore,
  the makespan of ,
  is at least , again a contradiction.
  \qed
\end{proof}

\section{Fixed-parameter algorithm}\label{sec:fpt}
\noindent 
In this section, we present a fixed-parameter algorithm for \ROSUPT{}.
The following simple algorithm shows
that our main challenge will be ``bottleneck vertices'' that
contain less jobs than there are machines.

\begin{proposition}\label[proposition]{thm:trivsched}
  \ROSUPT{} is solvable in ~time if each vertex
  contains at least ~jobs.
\end{proposition}
\begin{proof}
  First, compute a minimum-cost Hamiltonian cycle~
  in the input network~ in ~time
  using the algorithm of \citet{Bell62}, \citet{HelK62},
  where ~is the depot.

  Denote by ~the number of jobs in~.
  Each machine will follow the same route~
  of ~stays ,  where , ,
  
  That is, all machines will stay in vertex~ for the same ~time units.
  Now consider the schedule~ that
  schedules each job~ in a vertex~
  on each machine~ at time
  
  Since , it is easy to verify
  that 
  for  and 
  and for  and  if  and  are in the same vertex~
  (we did this for \eqref{eq:shift} in the proof of \cref{thm:artem}).
  For a job  in a vertex~
  and a job  in a vertex~
  with , 
  easily follows 
  from .

  It is obvious that ~is compatible to route~.
  The length of~ is , which is optimal by \cref{obs:lobo}.
  \qed
\end{proof}

\noindent
For the general \ROSUPT{} problem, we prove the following theorem,
which is our main algorithmic result.

\begin{theorem}\label{thm:ros-fpt}
  \ROSUPT{} is solvable in 
\end{theorem}

\noindent
In view of \cref{thm:trivsched} and \cref{ex:badhamilton},
the main challenge for our algorithm
are ``bottleneck vertices'' with few jobs,
which may force machines to idle.
\begin{definition}[critical vertices, \boldmath]\label[definition]{def:crit}
  For a vertex~ in the network of a \ROSUPT{} instance, let ~denote the number of jobs in~.   A vertex~ is \emph{critical} if .
\end{definition}

\noindent
To handle critical vertices,
we exploit that,
by \cref{lem:vislength},
the ~routes compatible to an optimal schedule
together have at most ~stays
and stay in critical vertices last at most ~time.
In time that depends only on~ and~, 
we can thus try all possibly optimal chronological sequences
of stays of machines in vertices,
lengths of stays in critical vertices,
and time differences between stays in critical vertices
if they intersect.
Thus, we can essentially try all possibilities of fixing
everything in the routes
except for the exact arrival and departure times of stays.
For each such possibility,
we will try to compute the arrival and departure times
using integer linear programming,
a schedule in critical vertices using brute force,
and a schedule in uncritical vertices using edge colorings of bipartite graphs.

In the following, we first formalize
these partially fixed schedules and routes
and then give a description of our algorithm in pseudo-code.

\begin{definition}[critical schedule]
  A \emph{critical schedule} is a
  function~
  determining the \emph{start time}~
  of each job~ in a critical vertex on each machine~
  and having  for all jobs~ in non-critical vertices.

  A critical schedule has to satisfy \cref{def:ros}\eqref{def:feas2}--\eqref{def:feas4}
  for all jobs~ and machines~ with .
\end{definition}

\noindent
We now formally define \emph{pre-schedules},
which fix routes up to the exact arrival and departure times of stays.
The definition is illustrated in \cref{fig:presc}:

\begin{figure*}
  \centering
  \includegraphics{stay-order-1.pdf}
  \caption{Shown is a part of a schedule for three
    machines~, and~.
    The horizontal axis is time.
    Uniformly gray boxes are stays in critical vertices that comply with some pre-schedule (the pre-schedule is not shown).
    Hatched squares correspond to jobs being processed.
    Illustrated are the lengths of stays and displacements between stays in critical vertices that are consecutive in the pre-stay sequence
    (stays in non-critical vertices are not shown).
    Herein, this displacement is either smaller
    than~,
    in which case the time difference between the stays
    is fixed for \emph{any} complying set of routes,
    or at least , in which case the stays cannot
    intersect in time for \emph{any} set of complying routes
    since stays in critical vertices have length at most
     by \cref{def:presc}\eqref{la1}.}
  \label{fig:presc}
\end{figure*}
\begin{definition}[pre-schedule]\label[definition]{def:presc}
  A \emph{pre-schedule} is a triple~.  Herein,
  \begin{itemize}[]
  \item[] is a \emph{pre-stay sequence}~ with 
    and will fix a chronological order of all machine stays
    (by non-decreasing arrival times).
    The \emph{-th pre-stay}~
    will require machine~ to stay in vertex~.
  \end{itemize}
  For the definition of the components~ and~ of a pre-schedule, let
   be the indices~ of pre-stays~
  such that ~is critical.  Then,
  \begin{itemize}[]
  \item[] is
    called \emph{length assignment}
    and will fix the length of the stay corresponding
    to the -th pre-stay to be~, and
  \item[] is
    called \emph{displacement} and
    will fix the time difference
    between the stays corresponding to the -th pre-stay
    and the previous pre-stay in a critical vertex
    to be   if 
    or to be at least  if  (which means
    that it will prevent the two stays from intersecting).
  \end{itemize}
  We now formalize routes that \emph{comply} with a pre-schedule.
  To this end, we denote by
  \begin{itemize}[]
  \item[]  the number such that  for some vertex~ is
    the -th pre-stay
    of machine~ in the pre-stay sequence~.
    We omit the subscript~ if the pre-stay sequence is clear from context.
  \end{itemize}
  Routes~, where , \emph{comply} with the \ps{} sequence~ if and only if
\begin{enumerate}[(i)]
\item\label{presc1}  for all , that is,  makes its -th stay in~, and
\item\label{presc2} for \ps{}s~ and~ with ,
  one has~, that is,
  the stays in all routes~ are chronologically ordered according to~.
\end{enumerate}
  Routes~  \emph{comply} with a \las~ if,
\begin{enumerate}[(i)]
\setcounter{enumi}{2}
\item\label{la1} each \ps{}~ in~ with~
has length .
\end{enumerate}
Routes~  \emph{comply} with a \dis~ if
\begin{enumerate}[(i)]
\setcounter{enumi}{3}
\item\label{dis1} for two \ps{}s~ and~ such that , , and  for each , one has
  D(j)=2\nmachD(j)<2\nmach
\end{enumerate}
Routes \emph{comply} with  if they comply with each of~, , and~.
\end{definition}

\noindent
\cref{lem:vislength} implies that there is a pre-schedule
complying with some routes compatible
to an optimal schedule.
We thus enumerate all possible pre-schedules and, for each,
try to find routes complying with
the pre-schedule and compatible to an optimal schedule.
This leads to the following algorithm.
\begin{algorithm}\small\leavevmode
  \label[algorithm]{alg:outline}
  \begin{compactdesc}
  \item[\it Input:] A \ROSUPT{} instance~ on a network~.
    
  \item[\it Output:] A minimum-makespan schedule for~.
  \end{compactdesc}
  \begin{compactenum}
  \item Preprocess ~to establish the triangle inequality.\hfill// \cref{lem:metric}\label{lin:metric}

  \item minimum-cost Hamiltonian
    cycle~ in~.\label{lin:hamcyc}

    
  \item \textbf{for}  \textbf{to}  \textbf{do}
    \hfill// Try to find schedule with makespan~ (Obs.~\ref{obs:lobo})\label{lin:chooseL}

  \item \label{lin:preschloop}\quad\textbf{foreach} pre-schedule
     \textbf{do}\hfill// \cref{numprescheds}

    
  \item \qquad\textbf{if} there are routes~ that
    comply with~, \hfill// \cref{lem:complroutes}\label{lin:consroute}

    \qquad\qquad that     have length at most~ each, and

    \qquad\qquad stay in each \emph{non-critical} vertex~ at least ~time,
    \textbf{then}
    
  \item\quad\qquad\textbf{if} there is a critical
    schedule~ compatible with~, \textbf{then}
    \hfill// 
    \cref{lem:enumscheds}\label{lin:conspartsched}

  \item
    \qquad\qquad complete~ into a feasible schedule  compatible with~.
          \hfill// \cref{lem:brf}\label{lin:complsched}
          
  \item\qquad\qquad \textbf{return} .\label{lin:retsched}
\end{compactenum}
\end{algorithm}

\noindent
To prove the correctness and the running time of \cref{alg:outline},
we prove the lemmas named in its comments.
We already proved \cref{lem:metric,obs:lobo}
and we continue proving lemmas in the order appearing in the algorithm.
First,
we bound the number of pre-schedules
and thus
the number of repetitions of the loop in line~\ref{lin:preschloop}.

\begin{lemma}\label[lemma]{numprescheds}
  In line~\ref{lin:preschloop} of \cref{alg:outline},
  there are at most  pre-schedules,
  which can be enumerated in ~time.
\end{lemma}
\begin{proof}
  There are at most  pre-stay sequences:
  a pre-stay sequence consists of at most  pre-stays,
  each of which is a pair of one of ~machines and one of ~vertices.
  For each pre-stay sequence, there are at most  length assignments
and at most  displacements.
Thus, the number  of pre-schedules is at most
.
They can obviously be enumerated in the stated running time
using a recursive algorithm.
  \qed
\end{proof}

\noindent
We realize the check in line~\ref{lin:consroute}
by testing
the feasibility of an integer linear program
whose number of variables, number of constraints, and
absolute value of coefficients is bounded by
.
By Lenstra's theorem, this works in ~time:
\begin{proposition}[\citet{Len83}; see also \citet{Kan87}]\label[proposition]{thm:lenstra}
  A feasible solution to an integer linear program of size~ with ~variables
  is computable using ~arithmetical operations,
  if such a feasible solution exists.
\end{proposition}

\begin{lemma}\label[lemma]{lem:complroutes}
  The  routes in line~\ref{lin:consroute} of \cref{alg:outline}
  are computable in 
  time, if they exist.
\end{lemma}
\begin{proof}
  Let  be the pre-stay sequence
  in the pre-schedule~ enumerated in line~\ref{lin:preschloop}.
  By , denote the number of pre-stays of a machine~ in~.
  We compute the routes ,
  where , as follows.
For each pre-stay  on~,
we let~.  If  or 
for some machine~, where ~is the depot, then there are no routes
complying with~ and  we return ``no'' accordingly.

Otherwise, by \cref{def:presc}, the  and 
for all machines~ and  together
are at most ~variables.
They can be determined by a feasible solution to an integer linear program.
This, together with \cref{thm:lenstra} directly yields the running time stated in \cref{lem:complroutes}. 
The linear program consists of the following constraints.
  We want each route to have length at most~, that is,
  M_q\in\MsM_q\in\Ms1\leq k\leq s_q-1M_q\in\Ms1\leq k\leq s_qv\in Vn_vM_q\in\Msv\in VT{q_k},v_k){q_\ell},v_\ell)k\leq \ellA{q_k},v_k)v_kD\mathcal KT{q_k},w_k){q_\ell},w_\ell)k<\ell\{k,\ell\}\subseteq\mathcal Ki\notin\mathcal Ki\in\{k+1,\dots,\ell-1\}D(\ell)=2\nmachD(\ell)<2\nmach
\end{proof}

\noindent
Next, we show how to realize the check in \ref{lin:conspartsched} of \cref{alg:outline}.

\begin{lemma}\label[lemma]{lem:enumscheds}
  The critical schedule~ in line~\ref{lin:conspartsched}
  is computable
  in ~time,
  if such a schedule exists.
\end{lemma}
\begin{proof}
  In total, there are at most ~jobs in critical vertices.
  Thus, we determine the starting time~
  for at most ~pairs .
  By \cref{lem:vislength},
  each machine can process all of its jobs in a critical vertex staying there
  no longer than ~units of time.
  Thus, for each of at most ~pairs ,
  we enumerate all possibilities of choosing  among the
  smallest ~time units where~ stays in vertex~.

  There are 
  possibilities to do so.  The feasibility's of each variant
  can be checked in ~time and
  they can all be enumerated in ~total time:
  since the routes~ comply with~,
  they
  have at most ~stays in total,
  thus we can list the first ~time units
  that a concrete machine stays in a concrete vertex
  in ~time.
\qed\end{proof}

\noindent
In the following, we provide the last building block
for proving the correctness and the running time of \cref{alg:outline}:
\cref{lem:vislength} already shows that there is a pre-schedule
that complies with some routes that are compatible with
an optimal schedule.
Thus, it is sufficient to try, for each pre-schedule~,
to search for schedules compatible with routes
complying with~.
However, the algorithm only searches for schedules
compatible to \emph{one} collection of machine routes
complying with~.
The following lemma shows that this is sufficient.

\begin{lemma}\label[lemma]{lem:brf}
  If a \ROSUPT{} instance on a network~
  allows for a feasible schedule
  compatible to routes
  complying with a pre-schedule~, then
  \begin{enumerate}[(i)]
  \item\label{brf:psched} for any collection of routes~ complying with~,
    there is a critical schedule compatible with , and
  \item\label{brf:completable} any such critical schedule
    can be extended into a feasible schedule compatible to~
    if each route~ stays in each vertex~
    for at least~~time.
  \end{enumerate}
  Moreover, line~\ref{lin:complsched} can be carried out in ~time.
\end{lemma}
\begin{proof}
  \eqref{brf:psched}
  Let ~be a feasible schedule compatible to
  some routes~
  complying with~.  Denote the pre-stay sequence~.
  We show how to construct a critical schedule~
  compatible with respect to the routes~.
  Denote ,
  and 
  for each machine~.
  By \cref{def:presc}\eqref{presc1} and \cref{def:ros}\eqref{def:feas4}, for each job~ and machine~ there is an index  of a pre-stay~ on~ such that
  
  Since the routes  and  comply with~, by \cref{def:presc}\eqref{presc1}, one has  and, moreover,  for each machine~ and .
For each job~ and machine~, we define
  \loc(J_i)
where .

We show that ~is a critical schedule compatible with the routes .
For each job~ in a critical vertex and each machine~,
we first show that machine~ stays in~ when processing job~.
More precisely, for  ,
we show  as follows.
By adding  to both sides of

which holds since ~is chosen so as to satisfy \eqref{leqeq}, one gets

 Moreover, since both  and  comply with the length assignment~, by \cref{def:presc}\eqref{la1}, one has  for all pre-stays  such that ~is critical. Thus, by adding  to both sides of

which holds since ~is chosen so as to satisfy \eqref{leqeq}, one gets

It remains to show that~ processes no two jobs at the same time and that no two machines process one job at the same time.  To this end, consider jobs~ in critical vertices and machines~.  If \emph{either}  or , then .  Thus, it is sufficient to show that  implies .  
To this end, let  and .
Without loss of generality, assume that~.  
By \cref{def:presc}\eqref{presc2}, one has . 

If , then  follows from

Otherwise, since  by \cref{def:presc}\eqref{la1}, one has .  Thus, for  is a pre-stay of~ in a critical vertex,  one has, by \cref{def:presc}\eqref{presc2} and \eqref{dis1},

since both tours~ and~
comply with the displacement~.  
By adding  to both sides of

which is true by the definition of~ from~, one obtains

and, therefore,   from \eqref{equality}.


\eqref{brf:completable}
We complete any critical schedule~ compatible
with the routes~ into a feasible schedule
compatible with  as follows.

For each machine~
and each non-critical vertex~,
let ~be a set of ~arbitrary times
where machine~ stays in~ according to
route~ and let .
For each vertex~, create a bipartite
graph~,
where ~contains an edge~ between a machine~ and a time 
if and only if  is in~ at time~.
Each vertex of~ has degree~ or~, where 
since ~is non-critical.
Thus, ~allows for a proper edge coloring~:
if one of  or , then .
This coloring will tell us which job machine~ will process at time~.
Let the jobs in each vertex~
be~.
Then, for any machine~ and job~
in a non-critical vertex~,
there is a unique~ such that .
We thus define our schedule~ as
v
By construction from schedule~ for critical vertices,
which is compatible to the routes~,
and
from the edge-coloring~ for non-critical vertices~,
schedule ~is compatible to~.
Moreover, from this, 
follows if  are in the same vertex.
If  are in different vertices,
then this follows from the compatibility of~
with the routes~: machine~
cannot stay in two vertices at the same time.
Finally,  for 
follows from  if ~is in a critical vertex.
If ~is a job in a non-critical vertex, say ,
then  implies  and,
in turn, ,
contradicting the fact that ~is a proper edge coloring.

We analyze the running time for this completion step.
Since the routes~ have at most
~stays, one can compute the sets~
for all vertices~ and machines~ in
~time.
For each vertex~,
the bipartite graph~ can be generated
in ~time and an edge-coloring into ~colors
can be computed in ~time~\citep{COS01}.
Thus, in total,
we can compute schedule~ in

\end{proof}

\noindent
We can now prove the correctness and running time of \cref{alg:outline}.

\begin{proof}[of \cref{thm:ros-fpt}]
  Let ~be the makespan of an optimal schedule~
  for the \ROSUPT{} instance input to \cref{alg:outline}.
  We only have to show that (and in which time) \cref{alg:outline} outputs
  a feasible schedule~ with makespan at most~.
  To this end, let ~be routes compatible to~,
  each of length at most~.
  Line~\ref{lin:metric} of \cref{alg:outline}
  can be carried out in  time
  using the Floyd-Warshall algorithm,
  line~\ref{lin:hamcyc} in ~time using
  the algorithm of \citet{Bell62}, \citet{HelK62}.  By
  \cref{obs:lobo},  in at least one iteration of the loop in
  line~\ref{lin:chooseL}.
  We now consider this iteration.
  By \cref{numprescheds},  in line~\ref{lin:preschloop}, we enumerate
  ~pre-schedules.
  By \cref{lem:vislength}, among them there is a pre-schedule~
  that complies with~.
  Since ~processes all jobs, the routes~
  stay in each vertex~ at least ~time.
  Thus, the test in line~\ref{lin:consroute} succeeds for~ and 
  and, by \cref{lem:complroutes}, 
  can be carried out in ~time.
  By \cref{lem:enumscheds} the test in line~\ref{lin:conspartsched}
  can be carried out in ~time
  and, by \cref{lem:brf}\eqref{brf:psched}, it succeeds. We get the
  the feasible schedule~ in line~\ref{lin:complsched}
  in ~time by \cref{lem:brf}\eqref{brf:completable}.
  Its makespan is at most~.
  The overall running time of the algorithm is .\qed
\end{proof}

\section{Open questions}\label{sec:conclusion}
\noindent
We have shown that \ROSUPT{} is fixed-parameter tractable
with respect to the parameter~ and,
in the absence of critical vertices,
also with respect to the parameter~.
However, the question
whether \ROSUPT{} with critical vertices
and an unbounded number of machines
is polynomial-time solvable is open even for two vertices.



\begin{acknowledgements}
  We are thankful 
  to Mikhail Khachay for pointing out the work of \citet{Mad74}.
\end{acknowledgements}

\bibliographystyle{spbasic}
\bibliography{ros-upt}

\appendix
\section{On the minimum weight of long closed walks containing all vertices}
\label{appendix}
In the following,
we prove \cref{prop:longcyc},
which we used to prove \cref{lem:shortcyc}.
For its formal statement and proof,
we have to formally distinguish two different kinds of paths and cycles:

\begin{definition}[closed walks, cycles]
  Let ~be a multigraph with edge weights~.
  A~\emph{walk of length}~ in~
  is an alternating sequence~
  of vertices and edges
  such that
  ~and ~are the end points of~
  for each .
  Its \emph{weight} is , its
  \emph{internal vertices} are , and
  it is \emph{closed} if .

  \looseness=-1
  A graph is \emph{Eulerian} if it contains an \emph{Euler tour}---a closed walk
  that contains each edge of~ \emph{exactly} once.
  It is known that a connected undirected multigraph is Eulerian
  if and only if each vertex has even degree.
  A \emph{(simple) path} is a walk that contains each edge
  and
  internal vertex at most once.
  A \emph{cycle} is a closed path.
\end{definition}

\begin{proposition}\label[proposition]{prop:longcyc}
  Let ~be a connected -vertex graph with positive integer edge
  weights and let ~be
  a closed walk of length  containing
  all vertices of~.  Then, the weight of~ is at least ,
  where ~is the minimum weight
  of any closed walk containing all vertices of~.
\end{proposition}

\noindent
To prove \cref{prop:longcyc}, we exploit the following theorem.
\begin{theorem}[{\citet[Satz~1]{Mad74}}]\label{mader}
  Every simple graph with minimum degree~ contains a cycle~
  such that there are ~mutually internally vertex-disjoint paths
  between any pair of vertices of~.
\end{theorem}

\begin{corollary}\label[corollary]{cor:shortcut}
  Let ~be a connected -vertex multigraph without loops
  such that
  the deletion of the edges of any cycle disconnects~.
  Then ~has at most ~edges.
\end{corollary}

\begin{proof}
  We prove the statement by induction on~.
  The statement is trivial for ,
  since such a graph has no edges.
  Now, let .
  If ~contains a \emph{cutset}~
  of cardinality at most 2
  (that it, its deletion disconnects the graph), then
  ~consists of
  two connected components~ and~.
  By induction, we have 
  .
  It remains to prove that ~indeed contains
  a cutset~ of cardinality at most 2.

  If ~contains a vertex~ of degree at most~2,
  then its incident edges form the sought cutset of cardinality~2.
  If ~contains at least two distinct edges~ and~
  between the same pair~ and~ of vertices,
  then 
  is a cycle and, thus,  is the sought cutset of cardinality~2.
  
  If none of the above apply,
  then ~is a simple graph with minimum degree three.
  Thus, by \cref{mader},
  ~contains a cycle~ whose edges can be deleted
  without disconnecting the graph:
  deleting the edges of~ removes
  at most two out of three pairwise internally vertex-disjoint paths
  between any pair of vertices of~.
  This contradicts our assumption that deleting the edges of any cycle disconnects~.
  \qed
\end{proof}

\noindent We can now prove \cref{prop:longcyc}.
 
\begin{proof}[of \cref{prop:longcyc}]
  Consider the following multigraph~:
  the vertices of~ are the vertices of~
  and
  the number of edges in~ between
  each pair~ and~ of vertices
  is equal to the number of times
  the closed walk~ contains the edge~ of~.
  The multigraph~ is connected, Eulerian, has ~vertices
  and  edges.
  If , then, by \cref{cor:shortcut},
  there is a cycle~ in~ whose removal results
  in a connected multigraph~.
  Multigraph~ is still Eulerian.
  Thus,
  we can iterate the process until
  we get an Eulerian submultigraph~ of~ with at most ~edges.
  The Euler tour~ of~
  is a closed walk for~ containing all its vertices
  and thus
  has weight at least~.
  Since the total weight of the deleted cycles is at least~,
  the weight of~ is at least .
 \qed
\end{proof}
Finally, note that the bound given by \cref{prop:longcyc}
is tight for each~ and even~:
consider a unit-weight path graph~ on ~vertices .
The minimum weight of any closed walk containing all vertices is~.
The closed walk visiting the vertices

with  in this order
has length~ and its weight is~.




\end{document}
