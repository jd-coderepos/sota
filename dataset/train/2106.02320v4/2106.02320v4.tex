\documentclass{article}







\usepackage[final,nonatbib]{neurips_2021}



\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}
\hypersetup{colorlinks,allcolors=green}
\usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{xcolor}         \usepackage{multirow}
\usepackage{color}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage{mathtools}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{wrapfig,lipsum,booktabs}

\DeclareMathOperator*{\argmin}{argmin}
\DeclareMathOperator*{\argmax}{argmax} 


\title{Few-Shot Segmentation via Cycle-Consistent Transformer}





\author{
  Gengwei Zhang\thanks{Part of this work was done when Gengwei Zhang was an intern at Baidu Research.} ,\quad Guoliang Kang,\quad Yi Yang,\quad Yunchao Wei\thanks{Corresponding author.} \\
   Baidu Research \\ 
   ReLER, Centre for Artificial Intelligence, University of Technology Sydney\\
   University of Texas, Austin\\
   CCAI, College of Computer Science and Technology, Zhejiang University \\
   Institute of Information Science, Beijing Jiaotong University \\
   Beijing Key Laboratory of Advanced Information Science and Network \\
  \small{\{zgwdavid, kgl.prml, wychao1987, yee.i.yang\}@gmail.com}
}


\begin{document}

\maketitle

\begin{abstract}
  Few-shot segmentation aims to train a segmentation model that can fast adapt to novel classes with few exemplars. 
  The conventional training paradigm is to learn to make predictions on query images conditioned on the features from support images.
  Previous methods only utilized the semantic-level prototypes of support images 
  as the conditional information. 
  These methods cannot utilize all pixel-wise support information for the query predictions, which is however critical for the segmentation task.
  In this paper, we focus on utilizing pixel-wise relationships between support and query images to facilitate the 
  few-shot segmentation task. 
  We design a novel \textbf{Cy}cle-\textbf{C}onsistent \textbf{TR}ansformer (CyCTR) module to aggregate pixel-wise support features 
  into query ones. 
  CyCTR performs cross-attention between features from different images, \emph{i.e.} support and query images.
  We observe that there may exist unexpected irrelevant pixel-level support features. 
  Directly performing cross-attention may aggregate these features from support to query and bias the query features.
  Thus, we propose using a novel cycle-consistent attention mechanism to filter out possible harmful support features and encourage query features to attend to the most informative pixels from support images. 
  Experiments on all few-shot segmentation benchmarks demonstrate that our proposed CyCTR leads to remarkable improvement compared to previous state-of-the-art methods. 
  Specifically, on Pascal- and COCO- datasets, we achieve 67.5\% and 45.6\% mIoU for 5-shot segmentation, outperforming previous state-of-the-art method by 5.6\% and 7.1\% respectively. 
  
\end{abstract}

\section{Introduction}
\label{sec:intro}

Recent years have witnessed great progress in semantic segmentation~\cite{long2015fcn,chen2017deeplab,pspnet}. 
The success can be largely attributed to large amounts of annotated data~\cite{zhou2017ade20k,mscoco}.
However, labeling dense segmentation masks are very time-consuming~\cite{zhang2020interactive}. Semi-supervised segmentation~\cite{huang2018weakly,wei2018revisiting,wei2017object} has been broadly explored to alleviate this problem, which assumes a large amount of unlabeled data is accessible. However, semi-supervised approaches may fail to generalize to novel classes with very few exemplars. In the extreme low data regime, few-shot segmentation~\cite{shaban2017oslsm,wang2019panet} is introduced to train a segmentation model that can quickly adapt to novel categories. 

Most few-shot segmentation methods follow a learning-to-learn paradigm where predictions of query images are made conditioned on the features and annotations of support images.
The key to the success of this training paradigm lies in how to effectively utilize the information provided by support images. 
Previous approaches extract semantic-level prototypes from support features and follow a metric learning~\cite{sung2018relationnet,dong2018FSSPL,wang2019panet} pipeline extending from PrototypicalNet~\cite{snell2017prototypical}. 
According to the granularity of utilizing support features, these methods can be categorized into two groups, as illustrated in Figure \ref{fig:intro}: 
1) Class-wise mean pooling~\cite{wang2019panet,zhang2020sgone,zhang2019canet} (Figure~\ref{fig:intro}(a)). Support features within regions of different categories are averaged to serve as prototypes to facilitate the classification of query pixels. 
2) Clustering~\cite{liu2020ppnet,yang2020PMM} (Figure~\ref{fig:intro}(b)). Recent works attempt to generate multiple prototypes via EM algorithm or K-means clustering \cite{yang2020PMM,liu2020ppnet}, 
in order to extract more abundant information from support images. 
These prototype-based methods need to ``compress" support information into different prototypes (\emph{i.e.} class-wise or cluster-wise), 
which may lead to various degrees of loss of beneficial support information and thus harm segmentation on query image. 
Rather than using prototypes to abstract the support information, \cite{zhang2019pgnet,cao2020dan} (Figure~\ref{fig:intro}(c)) propose to employ the attention mechanism to extract information from support foreground pixels for segmenting query.
However, such methods ignore all the background support pixels that can be beneficial for segmenting query image, and incorrectly consider partial foreground support pixels that are quite different from the query ones, leading to sub-optimal results.  



\begin{figure*}[t]
    \centering
    \includegraphics[width=1.0\linewidth]{figs/intro.pdf}
    \caption{Different learning frameworks for few-shot segmentation, from the perspective of ways to utilize support information. (a) Class-wise mean pooling based method. (b) Clustering based method. (c) Foreground pixel attention method. (d) Our Cycle-Consistent TRansformer (CyCTR) framework that enables all beneficial support pixel-level features (foreground and background) to be considered.}
    \label{fig:intro}
\end{figure*}



\begin{wrapfigure}{r}{0.5\textwidth}
    \centering
    \vspace{-4mm}
    \includegraphics[width=1.0\linewidth]{figs/motivation.pdf}
    \caption{The motivation of our proposed method. Many pixel-level support features are quite different from the query ones, and thus may confuse the attention. We incorporate cycle-consistency into attention to filter such confusing support features. 
    Note that the confusing support features may come from foreground and background.}
    \label{fig:motivation}
    \vspace{-2mm}
\end{wrapfigure}

In this paper, we focus on equipping each query pixel with relevant information from support images to facilitate the query pixel classification.
Inspired by the transformer architecture ~\cite{vaswani2017transformer} which performs feature aggregation through attention,
we design a novel \textbf{Cy}cle-\textbf{C}onsistent \textbf{Tr}ansformer (CyCTR) module (Figure~\ref{fig:intro}(d)) to aggregate pixel-wise support features into query ones. 
Specifically, our CyCTR consists of two types of transformer blocks: the self-alignment block and the cross-alignment block. The self-alignment block is employed to encode the query image features by aggregating its relevant context information, while the cross-alignment aims to aggregate the pixel-wise features of support images into the pixel-wise features of query image. Different from self-alignment where Query\footnote{To distinguish from the phrase "query" in few-shot segmentation, we use "Query" with capitalization to note the query sequence in the transformer.}, Key and Value come from the same embedding, cross-alignment takes features from query images as Query, and those from support images as Key and Value.
In this way, CyCTR provides abundant pixel-wise support information for pixel-wise features of query images to make predictions.


Moreover, we observe that due to the differences between support and query images, \textit{e.g.}, scale, color and scene, only a small proportion of support pixels can be beneficial for the segmentation of query image. In other words, in the support image, some pixel-level information may confuse the attention in the transformer. Figure~\ref{fig:motivation} provides a visual example of a support-query pair together with the label masks. The confusing support pixels may come from both foreground pixels and background pixels. 
For instance, point  in the support image located in the plane afar, which is indicated as foreground by the support mask. However, 
the nearest point  in the query image (\emph{i.e.}  has the largest feature similarity with ) belongs to a different category, \emph{i.e.} background.  
That means, there exists no query pixel which has both high similarity and the same semantic label with .
Thus,  is likely to be harmful for segmenting "plane" and should be ignored when performing the attention. 
To overcome this issue, in CyCTR, we propose to equip the cross-alignment block with a novel cycle-consistent attention operation. 
Specifically, as shown in Figure \ref{fig:motivation}, starting from the feature of one support pixel, we find its nearest neighbor in the query features. 
In turn, this nearest neighbor finds the most similar support feature.
If the starting and the end support features come from the same category, a cycle-consistency relationship is established. 
We incorporate such an operation into attention to force query features only attend to cycle-consistent support features to extract information. 
In this way, the support pixels that are far away from query ones are not considered.
Meanwhile, cycle-consistent attention enables us to more safely utilize the information from background support pixels, 
without introducing much bias into the query features.



In a nutshell, our contributions are summarized as follows: 
(1) We tackle few-shot segmentation from the perspective of providing each query pixel with relevant information from support images through pixel-wise alignment.
(2) We propose a novel Cycle-Consistent TRansformer (CyCTR) to aggregate the pixel-wise support features into the query ones.
In CyCTR, we observe that many support features may confuse the attention and bias pixel-level feature aggregation, 
and propose incorporating cycle-consistent operation into the attention to deal with this issue. 
(3) Our CyCTR achieves state-of-the-art results on two few-shot segmentation benchmarks, \textit{i.e.}, Pascal- and COCO-. Extensive experiments validate the effectiveness of each component in our CyCTR. 




 

\section{Related Work}
\label{sec:related}
\subsection{Few-Shot Segmentation}
Few-shot segmentation~\cite{shaban2017oslsm} is established to perform segmentation with very few exemplars. Recent approaches formulate few-shot segmentation from the view of metric learning~\cite{sung2018relationnet,dong2018FSSPL,wang2019panet}. For instance, ~\cite{dong2018FSSPL} first extends PrototypicalNet~\cite{snell2017prototypical} to perform few-shot segmentation. PANet~\cite{wang2019panet} simplifies the framework with an efficient prototype learning framework. SG-One~\cite{zhang2020sgone} leverage the cosine similarity map between the single support prototype and query features to guide the prediction. CANet~\cite{zhang2019canet} replaces the cosine similarity with an additive alignment module and iteratively refines the network output. PFENet~\cite{tian2020pfenet} further designs an effective feature pyramid module and leverages a prior map to achieve better segmentation performance. 
Recently, ~\cite{yang2020PMM,liu2020ppnet,zhang2019pgnet} point out that only a single support prototype is insufficient to represent a given category. Therefore, they attempt to obtain multiple prototypes via EM algorithm to represent the support objects and the prototypes are compared with query image based on cosine similarity~\cite{liu2020ppnet,yang2020PMM}. Besides, ~\cite{zhang2019pgnet,cao2020dan} attempt to use graph attention networks~\cite{velivckovic2017gat,wu2020bidirectional} to utilize all foreground support pixel features. However, they ignore all pixels in the background region by default. Besides, due to the large difference between support and query images, not all support pixels will benefit final query segmentation. Recently, some concurrent works propose to learn dense matching through Hypercorrelation Squeeze Networks~\cite{min2021hypercorrelation} or mining latent classes~\cite{yang2021mining} from the background region. Our work aims at mining information from the whole support image, but exploring to use the transformer architecture and from a different perspective, \textit{i.e.,} reducing the noise in the support pixel-level features. 

\subsection{Transformer}
Transformer and self-attention were firstly introduced in the fields of machine translation and natural language processing~\cite{devlin2018bert,vaswani2017transformer}, and are receiving increasing interests recently in the computer vision area. Previous works utilize self-attention as additional module on top of existing convolutional networks, \textit{e.g., }Nonlocal~\cite{wang2018nonlocal} and CCNet~\cite{huang2019ccnet}. ViT~\cite{dosovitskiy2020vit} and its following work~\cite{touvron2020deit} demonstrate the pure transformer architecture can achieve state-of-the-art for image recognition. On the other hand, DETR~\cite{carion2020detr} builds up an end-to-end framework with a transformer encoder-decoder on top of backbone networks for object detection. And its deformable vairents~\cite{zhu2020deformabledetr} improves the performance and training efficiency.  
Besides, in natural language processing, a few works~\cite{beltagy2020longformer,child2019generating,shi2021sparsebert} have been introduced for long documents processing with sparse transformers. In these works, each Query token only attends to a pre-defined subset of Key positions.



\subsection{Cycle-consistency Learning}
Our work is partially inspired by cycle-consistency learning~\cite{zhu2017cyclegan,dwibedi2019temporalCYC} that is explored in various computer vision areas. For instance, in image translation, CycleGAN~\cite{zhu2017cyclegan} uses cycle-consistency to align image pairs. It is also effective in learning 3D correspondence~\cite{zhou2016corr3Dlearning}, consistency between video frames~\cite{wang2019timecycle} and association between different domains~\cite{kang2020pixelcycle}. These works typically constructs cycle-consistency loss between aligned targets (\textit{e.g.}, images). However, the simple training loss cannot be directly applied to few-shot segmentation because the test categories are unseen from the training process and no finetuning is involved during testing. In this work, we incorporate the idea of cycle-consistency into transformer to eliminate the negative effect of confusing or irrelevant support pixels.
 
\section{Methodology}
\label{sec:method}
\subsection{Problem Setting}

Few-shot segmentation aims at training a segmentation model that can segment novel objects with very few annotated samples. Specifically, given dataset  and  with category set  and  respectively, where , the model trained on  is directly used to test on . In line with previous works~\cite{tian2020pfenet,wang2019panet,zhang2019canet}, episode training is adopted in this work for few-shot segmentation. Each episode is composed of  support images  and a query image  to form a -shot episode , in which all  and  contain objects from the same category. Then the training set and test set are represented by  and , where  and  is the number of episodes for training and test set. During training, both support masks  and query masks  are available for training images, and only support masks are accessible during testing.


\subsection{Revisiting of Transformer} \label{basic-trans}
Following the general form in~\cite{vaswani2017transformer}, a transformer block is composed of alternating layers of multi-head attention (MHA) and multi-layer perceptron (MLP). LayerNorm (LN)~\cite{ba2016ln} and residual connection~\cite{he2015resnet} are applied at the end of each block. Specially, an attention layer is formulated as

where , in which  is the input Query sequence,  is the input Key/Value sequence,  denote the learnable parameters,  is the hidden dimension of the input sequences and we assume all sequences have the same dimension  by default. For each Query element, the attention layer computes its similarities with all Key elements. Then the computed similarities are normalized via , which are used to multiply the Value elements to achieve the aggregated outputs. When , it functions as self-attention mechanism. 


The multi-head attention layer is an extention of attention layer, which performs  attention operations and concatenates consequences together. Specifically,


where  and the inputs  are the  group from  with dimension .


\begin{figure*}[t]
    \centering
    \includegraphics[width=1.0\linewidth]{figs/framework.pdf}
    \caption{Framework of our proposed Cycle-Consistent TRansformer (CyCTR). Each encoder of CyCTR consists of two transformers blocks, \emph{i.e.}, the self-alignment block for utilizing global context within the query feature map and 
    the cross-alignment block for aggregate information from support images. In the cross-alignment block, we introduce the multi-head cycle-consistent attention (shown on the right, with the number of heads  for simplicity). The attention operation is guided by the cycle-consistency among query and support features.}
    \label{fig:framework}
\end{figure*}

\subsection{Cycle-Consistent Transformer}
Our framework is illustrated in Figure~\ref{fig:framework}(a). Generally, an encoder of our Cycle-Consistent TRansformer (CyCTR) consists of a self-alignment transformer block for encoding the query features and a cross-alignment transformer block to enable the query features to attend to the informative support features. The whole CyCTR module stacks  encoders. 

Specifically, for the given query feature  and support feature , we first flatten them into 1D sequences (with shape ) as inputs for transformer, in which a \textit{token} is represented by the feature  at one pixel location. The self-alignment block only takes the flattened query feature as input.
As context information of each pixel has been proved beneficial for segmentation~\cite{chen2017deeplab,pspnet}, 
we adopt the self-alignment block to pixel-wise features of query image to aggregate their global context information. 
We don't pass support images through the self-alignment block, as we mainly focus on the segmentation performance of query images. 
Passing through the support images which don't coordinate with the query mask may do harm to the self-alignment on query images.

In contrast, the cross-alignment block performs attention between query and support pixel-wise features to 
aggregate relevant support features into query ones. It takes the flattened query feature and a subset of support feature (the sampling procedure is discussed latter) with size  as Key/Value sequence . 

With these two blocks, it is expected to better encoder the query features to facilitate the subsequent pixel-wise classification. When stacking  encoders, the output of the previous encoder is fed into the self-alignment block. The outputs of self-alignment block and the sampled support features are then fed into the cross-alignment block. 

\subsubsection{Cycle-Consistent Attention}
According to the aforementioned discussion, the pure pixel-level attention may be confused by excessive irrelevant support features. To alleviate this issue, as shown in Figure~\ref{fig:framework}(b), a cycle-consistent attention operation is proposed. We first go through the proposed approach for 1-shot case for presentation simplicity and then discuss it in the multiple shot setting. 

Formally, an affinity map  
is first calculated to measure the correspondence between all query and support pixels. Then, for an arbitrary support pixel/token  (,  is the number of support pixels), its most similar query pixel/token  is obtained by

where  denotes the spatial index of query pixels. Since the query mask is not accessible, the label of query pixel  is unknown. However, we can in turn find its most similar support pixel  in the same way: 
Given the sampled support label , cycle-consistency is satisfied if . 
Previous work~\cite{kang2020pixelcycle} attempts to encourage the feature similarity between cycle-consistent pixels 
to improve the model's generalization ability within the same set of categories.
However, in few-shot segmentation, the goal is to enable the model to fast adapt to novel categories rather than making the model fit better to training categories. Thus, we incorporate the cycle-consistency into the attention operation to encourage the cycle-consistent cross-attention. 
First, by traversing all support tokens, an additive bias 
 is obtained by

where . Then, for a single query token  at location , the support information is aggregated by

where  and  is obtained by . In the forward process,  is element-wise added with the affinity  for  to aggregate support features. 
In this way, the attention weight for the cycle-inconsistent support features become zero, implying that these irrelevant information will not be considered.
Besides, the cycle-consistent attention implicitly encourages the consistency between the most relevant query and support pixel-wise features through backpropagation. Note that our method aims at removing support pixels with certain inconsistency, rather than ensuring all support pixels to form cycle-consistency, which is impossible without knowing the query ground truth labels.




When performing self-attention in the self-alignment block, there may also exist the same issue, 
\textit{i.e.} the query token may attend to irrelevant or even harmful features (especially when background is complex). According to our cycle-consistent attention, each query token should receive information from more consistent pixels than aggregating from all pixels. Due to the lack of query mask , it is impossible to establish the cycle-consistency among query pixels/tokens. Inspired by DeformableAttention~\cite{zhu2020deformabledetr}, the consistent pixels can be obtained via a learnable way as
 and , 
where  is the predicted consistent pixels, in which each element  in  represents the relative offset from each pixel and  represents the number of pixels to aggregate. And  is the attention weights.  is the positional encoding~\cite{parmar2018imageTR} to make the prediction be aware of absolute position, and  and  are two fully connected layers that predict the offsets\footnote{The offsets are predicted as 2d coordinates and transformed into 1d coordinates.} and attention weights. Therefore, the self-attention within the self-alignment transformer block is represented as 

where  is the index of the flattened query feature, both  and  are obtained by multiplying the flattened query feature with the learnable parameter.

Generally speaking, the cycle-consistent transformer effectively avoids the attention being biased by irrelevant features to benefit the training of few-shot segmentation.


\textbf{Mask-guided sparse sampling and -shot Setting}: Our proposed cycle-consistency transformer can be easily extended to -shot setting where . When multiple support feature maps are provided, all support features are flattened and concatenated together as input. As the attention is performed at the pixel-level, the computation load will be high if the number of support pixels/tokens is large, which is usually the case under -shot setting.
In this work, we apply a simple mask-guided sampling strategy to reduce the computation complexity and make our method more scalable. Concretely, given the -shot support sequence  and the flattened support masks , the support pixels/tokens are obtained by uniformly sampling  tokens (, where ) from the foreground regions and  tokens from the background regions in all support images. With a proper , the sampling operation reduces the computational complexity, and makes our algorithm more scalable with the increase of spatial size of support images. Additionally, this strategy helps balance the foreground-background ratio and also implicitly considers different sizes of various object regions in support images. 

\subsection{Overall Framework}
\label{sec:overall}
Following previous works~\cite{tian2020pfenet,wang2019panet,zhang2019canet}, both query and support images are first feed into a shared backbone (\textit{e.g.,} ResNet~\cite{he2015resnet}) which is initialized with weights pretrained from ImageNet~\cite{russakovsky2015imagenet} to obtain general image features. Similar to~\cite{tian2020pfenet}, middle-level query features (the concatenation of query features from the  and the  blocks of ResNet) are processed by a 11 convolution to reduce the hidden dimension. The high-level query features (from the  block) are used to generate a prior map (the prior map is generated by calculating the pixel-wise similarity between query and support features, details can be found in the supplementary materials) and then are concatenated with the middle-level query features. The average masked support feature is also concatenated to provide global support information. The concatenated features are processed by a 11 convolution. 
The output query features are then fed into our proposed CyCTR encoders. 
The output of CyCTR encoders is fed into a classifier to obtain the final segmentation results. The classifier consists of a 33 convolutional layer, a ReLU layer and a 11 convolutional layer. 
More details about our network structure can be found in the supplementary materials. 
\section{Experiments}
\label{sec:exp}

\begin{table}[t]
\caption{Comparison with other state-of-the-art methods for 1-shot and 5-shot segmentation on PASCAL-5 using the mIoU (\%) evaluation metric. Best results are shown in bold.}
\label{tab:pascal}
\small
\centering
\tabcolsep 0.08in\begin{tabular}{l|c|ccccc|ccccc}
\toprule[1pt]
\multirow{2}{*}{Method} & \multirow{2}{*}{Backbone} & \multicolumn{5}{c|}{1-shot} & \multicolumn{5}{c}{5-shot} \\ \cline{3-12} 
	&  &  &  &  &  & Mean &  &  &  &  & Mean \\
\hline
PANet~\cite{wang2019panet} \ & \multirow{4}{*}{Vgg-16}  &42.3 & 58.0 & 51.1 & 41.2 & 48.1 & 51.8 & 64.6 & 59.8 & 46.5 & 55.7  \\
FWB~\cite{nguyen2019FWB} \ & &47.0 & 59.6 & 52.6 & 48.3 & 51.9 & 50.9 & 62.9 & 56.5 & 50.1 & 55.1  \\
SG-One~\cite{zhang2020sgone} \ & & 40.2 & 58.4 & 48.4 & 38.4 & 46.3 & 41.9 & 58.6 & 48.6 & 39.4 & 47.1\\
RPMM~\cite{yang2020PMM} \ & & 47.1 & 65.8 & 50.6 & 48.5 & 53.0 & 50.0&  66.5 & 51.9 & 47.6 & 54.0 \\
\hline
CANet~\cite{zhang2019canet} \ & \multirow{5}{*}{Res-50} & 52.5 & 65.9 & 51.3 & 51.9 &  55.4 & 55.5 & 67.8 & 51.9 & 53.2  & 57.1 \\
PGNet~\cite{zhang2019pgnet} \  &  &  56.0 & 66.9 & 50.6 & 50.4 &  56.0 & 57.7 & 68.7 & 52.9 & 54.6  & 58.5 \\
RPMM~\cite{yang2020PMM} \ & &55.2 & 66.9 & 52.6 & 50.7 & 56.3 & 56.3 & 67.3 &  54.5 & 51.0 & 57.3  \\
PPNet~\cite{liu2020ppnet} \* & &47.8 & 58.8 & 53.8 & 45.6 & 51.5 & 58.4 & 67.8 &  \textbf{64.9} & 56.7 &  62.0  \\
PFENet~\cite{tian2020pfenet} \ & & 61.7 & 69.5 & 55.4 & 56.3 & 60.8 & 63.1 & 70.7 & 55.8 & 57.9 & 61.9 \\

\hline
CyCTR (Ours) \ & Res-50 & \textbf{65.7} & \textbf{71.0} & \textbf{59.5} & \textbf{59.7} & \textbf{64.0} & \textbf{69.3} & \textbf{73.5} & 63.8 & \textbf{63.5} & \textbf{67.5} \\
\hline
FWB~\cite{nguyen2019FWB} \ & \multirow{3}{*}{Res-101} &51.3 & 64.5 & 56.7 & 52.2 & 56.2 & 54.9 & 67.4 &  \textbf{62.2} & 55.3 & 59.9  \\
DAN~\cite{cao2020dan} \ &  & 54.7 &  68.6 & \textbf{57.8} & 51.6 & 58.2 & 57.9 &  69.0 & 60.1 & 54.9 & 60.5  \\
PFENet~\cite{tian2020pfenet} \  &  & 60.5 & 69.4 & 54.4 & 55.9 & 60.1 & 62.8 & 70.4 & 54.9 & 57.6 & 61.4 \\
\hline
CyCTR (Ours) \ & Res-101 & \textbf{67.2} & \textbf{71.1} & 57.6 & \textbf{59.0} & \textbf{63.7} & \textbf{71.0} & \textbf{75.0} & 58.5 & \textbf{65.0} & \textbf{67.4} \\

\bottomrule[1pt]
\end{tabular}
\end{table}


\subsection{Dataset and Evaluation Metric}
\label{sec:datasets}
We conduct experiments on two commonly used few-shot segmentation datasets, Pascal-~\cite{everingham2010pascal} (which is combined with SBD~\cite{hariharan2014sbd} dataset) and COCO-~\cite{mscoco}, to evaluate our method. For Pascal-, 20 classes are separated into 4 splits. For each split, 15 classes are used for training and 5 classes for test. At the test time, 1,000 pairs that belong to the testing classes are sampled from the validation set for evaluation. In COCO-, we follow the data split settings in FWB~\cite{nguyen2019FWB} to divide 80 classes evenly into 4 splits, 60 classes for training and test on 20 classes, and 5,000 validation pairs from the 20 classes are sampled for evaluation. Detailed data split settings can be found in the supplementary materials. Following common practice~\cite{tian2020pfenet,wang2019panet,zhang2020sgone}, the mean intersection over union (mIoU) is adopted as the evaluation metric, which is the averaged value of IoU of all test classes. We also report the foreground-background IoU (FB-IoU) for comparison.


\subsection{Implementation Details}
\label{sec:detail}
In our experiments, the training strategies follow the same setting in~\cite{tian2020pfenet}: training for 50 epochs on COCO- and 200 epochs on Pascal-. Images are resized and cropped to  for both datasets and we use random rotation from  to  as data augmentation. Besides, we use ImageNet~\cite{russakovsky2015imagenet} pretrained ResNet~\cite{he2015resnet} as the backbone network and its parameters (including BatchNorms) are freezed.  For the parameters except those in the transformer layers, we use the initial learning rate , momentum , weight decay  and SGD optimizer with poly learning rate decay~\cite{chen2017deeplab}. The mini batch size on each gpu is set to 4. Experiments are carried out on Tesla V100 GPUs. For Pascal-, one model is trained on a single GPU, while for COCO-, one model is trained with 4 GPUs. We construct our baseline as follows: as stated in Section~\ref{sec:overall}, the middle-level query features from backbone network are concatenated and merged with the global support feature and the prior map. This feature is processed by two residule blocks and input to the same classifier as our method. Dice loss~\cite{milletari2016diceloss} is used as the training objective. Besides, the middle-level query feature is averaged using the ground truth and concatenated with support feature to predict the support segmentation map, which produces an auxiliary loss for aligning features. The same settings are also used in our method except that we use our cycle-consistent transformer to process features rather than the residule blocks. For the proposed cycle-consistent transformer, we set the number of sampled support tokens  to 600 for 1-shot and  for 5-shot setting. The number of sampled tokens is obtained according to the averaged number of foreground pixels among Pascal- training set. For the self-attention block, the number of points  
is set to 9. For other hyper-parameters in transformer blocks, we use  transformer encoders. We set the hidden dimension of MLP layer to 3256 and that of input to 256.
The number of heads for all attention layers is set to 8 for Pascal- and 1 for COCO-.
Parameters in the transformer blocks are optimized with AdamW~\cite{loshchilov2017decoupled} optimizer following other transformer works~\cite{carion2020detr,dosovitskiy2020vit,touvron2020deit}, with learning rate  and weight decay . Besides, we use Dropout with the probability 0.1 in all attention layers.



\begin{table}[t]
\caption{Comparison with other state-of-the-art methods for 1-shot and 5-shot segmentation on COCO-20 using the mIoU (\%) evaluation metric. Best results are shown in bold.}
\label{tab:coco}
\small
\centering
\tabcolsep 0.08in\begin{tabular}{l|c|ccccc|ccccc}
\toprule[1pt]
\multirow{2}{*}{Method} & \multirow{2}{*}{Backbone} & \multicolumn{5}{c|}{1-shot} & \multicolumn{5}{c}{5-shot} \\ \cline{3-12} 
	&  &  &  &  &  & Mean &  &  &  &  & Mean \\
\hline
FWB~\cite{nguyen2019FWB} & Res-101 & 19.9 & 18.0 & 21.0 & 28.9 & 21.2 & 19.1 & 21.5 & 23.9 & 30.1 & 23.7\\
PPNet~\cite{liu2020ppnet} & Res-50& 28.1 & 30.8 & 29.5 & 27.7 & 29.0 & 39.0 & 40.8 & 37.1 & 37.3 & 38.5\\
RPMM \cite{yang2020PMM}  & Res-50 & 29.5 & 36.8 & 29.0 & 27.0 & 30.6 & 33.8 & 42.0 & 33.0 & 33.3 &  35.5\\
PFENet~\cite{tian2020pfenet} & Res-101  & 34.3 & 33.0 & 32.3 & 30.1 & 32.4 & 38.5 & 38.6 & 38.2 & 34.3 & 37.4 \\ 
\hline
CyCTR (Ours) \ & Res-50 & \textbf{38.9} & \textbf{43.0} & \textbf{39.6} &  \textbf{39.8} & \textbf{40.3} & \textbf{41.1} & \textbf{48.9} & \textbf{45.2} &  \textbf{47.0} & \textbf{45.6}   \\
\bottomrule[1pt]
\end{tabular}
\end{table}

\subsection{Comparisons with State-of-the-Art Methods}
In Table~\ref{tab:pascal} and Table~\ref{tab:coco}, we compare our method with other state-of-the-art few-shot segmentation approaches on Pascal- and COCO- respectively. It can be seen that our approach achieves new 
\begin{wraptable}{r}{0.5\textwidth}
	\centering
	\vspace{-0.5mm}
	\caption{Comparison with other methods using FB-IoU (\%) on Pascal- for 1-shot and 5-shot segmentation. }
	\label{tab:fbiou}
	\begin{tabular}{lccc}
		\hline
		\multirow{2}{*}{Method} &\multirow{2}{*}{Backbone}& \multicolumn{2}{c}{FB-IoU (\%)} \\ \cline{3-4} 
		&& 1-shot         & 5-shot         \\ \hline
		A-MCG ~\cite{hu2019A-MCG}&Res-101& 61.2 & 62.2\\
		DAN~\cite{cao2020dan} & Res-101 & 71.9 & 72.3\\
		PFENet ~\cite{tian2020pfenet} &Res-101& \underline{72.9} & 73.5 \\ \hline  
		CyCTR (Ours) & Res-101 & \underline{73.0} & \textbf{75.4} \\ \hline
	\end{tabular}
\end{wraptable}
state-of-the-art performance on both Pascal- and COCO-. 
Specifically, on Pascal-, to make fair comparisons with other methods, we report results with both ResNet-50 and ResNet-101. Our CyCTR achieves 64.0\% mIoU with ResNet-50 backbone and 63.7\% mIoU with ResNet-101 backbone for 1-shot segmentation, significantly outperforming previous state-of-the-art results by 3.2\% and 3.6\% respectively. For 5-shot segmentation, our CyCTR can even surpass state-of-the art methods by 5.6\% and 6.0\% mIoU when using ResNet-50 and ResNet-101 backbones respectively. For COCO- results in Table~\ref{tab:coco}, our method also outperforms other methods by a large margin due to the capability of the transformer to fit more complex data. Besides, Table~\ref{tab:fbiou} shows the comparison using FB-IoU on PASCAL- for 1-shot and 5-shot segmentation, our method also obtains the state-of-the-art performance. 



\subsection{Ablation Studies}
To provide a deeper understanding of our proposed method, we show ablation studies in this section. The experiments are performed on Pascal- 1-shot setting with ResNet-50 as the backbone network, and results are reported in terms of mIoU. 
 
\subsubsection{Component-Wise Ablations}
We perform ablation studies regarding each component of our CyCTR in Table~\ref{tab:ablation}. The first line is the result of our baseline, where we use two residual blocks to merge features as stated in Section~\ref{sec:detail}. For all ablations in Table~\ref{tab:ablation}, the hidden dimension is set to 128 and two transformer encoders are used. The mIoU results are averaged over four splits. Firstly, we only use the self-alignment block that only encodes query features. The support information in this case comes from the concatenated global support feature and the prior map used in~\cite{zhang2019canet}. It can already bring decent results, showing that the transformer encoder is effective for modeling context for few-shot segmentation. Then, we utilize the  cross-alignment block but only with the vanilla attention operation in Equation~\ref{eq:attention}. The mIoU increases by 0.4\%, indicating that pixel-level features from support can provide additional performance gain. By using our proposed cycle-consistent attention module, the performance can be further improved by a large margin, \emph{i.e.} 0.6\% mIoU compared to the vanilla attention.  This result demonstrates our cycle-consistent attention's capability to suppress possible harmful information from support. Besides, we assume some background support features may also benefit the query segmentation and therefore use the cycle-consistent transformer to aggregate pixel-level information from background support features as well. 
Comparing the last two lines in Table~\ref{tab:ablation}, we show that our way of utilizing beneficial background pixel-level support information brings 0.5\% mIoU improvement, validating our assumption and the effectiveness of our proposed cycle-consistent attention operation.


\begin{table}[t]
\caption{Ablation studies that validate the effectiveness of each component in our Cycle-Consistent TRansformer. The first result is obtained by our baseline (see Section~\ref{sec:detail} for details). }
\label{tab:ablation}
\centering
{
\begin{tabular}{ccccc|c}
\hline
\toprule[1pt]
self-alignment & cross-alignment & CyCTR (pred) & CyCTR (fg. only) & CyCTR & mIoU (\%) \\ \hline
&  &  &  & & 59.3 \\ \checkmark &  &  &  & & 62.5 \\ \checkmark & \checkmark  &  & & & 62.9 \\ \checkmark & \checkmark & \checkmark & & & 62.6 \\ \checkmark & \checkmark &  & \checkmark & &  63.0 \\ \checkmark & \checkmark &  &  & \checkmark  &  63.5 \\ 

\bottomrule[1pt]
\end{tabular}
}
\end{table}

Besides, one may be curious about whether the noise can also be removed by predicting the aggregation position like the way in Equation~\ref{eq:dfatten} for aggregating support features to query. Therefore, we use predicted aggregation  instead of the cycle-consistent attention in the cross-alignment block, as denoted by \textit{CyCTR(pred)} in Table~\ref{tab:ablation}. It does benefit the few-shot segmentation by aggregating useful information from support but is 0.9\% worse than the proposed cycle-consistent attention. The reason lies in the dramatically changing support images under few-shot segmentation testing. The cycle-consistency is better than the learnable way as it can globally consider the varying conditional information from both query and support. 

\begin{wraptable}{r}{0.5\textwidth}
\vspace{-4.4mm}
		 \caption{Effect of varying (a) number of encoders  and (b) hidden dimensions .
		  When varying ,  is fixed to 128; while varying ,  is fixed to 2.}
		\begin{subtable}[h]{0.25\textwidth}
		\centering
		\tabcolsep 0.06in\begin{tabular}{ccc}
		\toprule[1pt]
		\#Encoder  & mIoU (\%) \\
		\hline
			1 &  62.4 \\
			2 &  63.5 \\
			3 &  63.7 \\
		\bottomrule[1pt]
		\end{tabular}
		   \caption{}
		   \label{tab:blocks}
		\end{subtable} \hspace{-1.5mm}
		\hfill
		\tabcolsep 0.06in\begin{subtable}[h]{0.25\textwidth}
			\centering
			\begin{tabular}{cc}
				\toprule[1pt]
				\#Dim  & mIoU (\%) \\
				\hline
					128 & 63.5 \\
					256 & 64.0 \\
					384 & 63.9 \\
\bottomrule[1pt]
				\end{tabular}
			\caption{}
			\label{tab:channels}
		 \end{subtable}\vspace{-5mm}
		 \label{tab:temps}
\end{wraptable}

\subsubsection{Effect of Model Capacity}
We can stack more encoders or increase the hidden dimension of encoders to increase its capacity and validate the effectiveness of our CyCTR.
The results with different numbers of encoders (denoted as ) or hidden dimensions (denoted as ) are shown in Table~\ref{tab:blocks} and ~\ref{tab:channels}. 
While increasing  or  within a certain range, CyCTR achieves better results. 
We chose  as our default choice for accuracy-efficiency trade-off. 

\subsection{Qualitative results}
In Figure~\ref{fig:vis}, we show some qualitative results generated by our model on Pascal-. Our cycle-consistent attention can improve the segmentation quality by suppressing possible harmful information from support. For instance, without cycle-consistency, the model misclassifies trousers as “cow” in the first row, baby's hair as “cat” in the second row, and a fraction of mountain as “car” in the third row, while our model rectifies these part as background. However, in the first row, our CyCTR still segments part of the trousers as "cow" and the right boundary of the segmentation mask is slightly worse than the model without cycle-consistency. The reason comes from the extreme differences between query and support, \textit{i.e.} the support image shows a "cattle" but the query image contains a milk cow. The cycle-consistency may over-suppress the positive region in support images. Solving such issue may be a potential direction to investigate to improve our method further. 


	\begin{figure*}[t]
		\centering
		\includegraphics[width=1.0\linewidth]{figs/vis.pdf}
		\caption{Qualitative results on Pascal-. From left to right, each column shows the examples of: Support image with mask region in red; Query image with ground truth mask region in blue; Result produced by the model without cycle-consistency in CyCTR; Result produced by our method. }
		\vspace{-4mm}
		\label{fig:vis}
	\end{figure*} 
\section{Conclusion}
In this paper, we design a CyCTR module to deal with the few-shot segmentation problem. Different from previous practices that either adopt semantic-level prototype(s) from support images or only use foreground support features to encode query features, 
our CyCTR utilizes all pixel-level support features and can effectively eliminate aggregating confusing and harmful support features with the proposed novel cycle-consistency attention. We conduct extensive experiments on two popular benchmarks, and our CyCTR outperforms previous state-of-the-art methods by a significant margin. We hope this work can motivate researchers to utilize pixel-level support features to design more effective algorithms to advance the few-shot segmentation research.


\bibliographystyle{plain}
\bibliography{egbib}




\appendix

\section{More Details}
\subsection{Implementation}

\begin{figure*}[ht]
    \centering
    \includegraphics[width=1.0\linewidth]{figs/net.pdf}
    \caption{The network structure used in our experiments. The backbone network first extracts features for query and support images. To enable the pixel-wise comparison in transformer, the averaged foreground support feature is expanded and concatenated with both query and support features. Our Cycle-Consistent TRansformer (CyCTR) takes the flattened query and support features as well as the flattened support mask as input and produces the encoded query feature for prediction.}
    \label{fig:net}
\end{figure*}

The overall network architecture used in our experiments is shown in Figure~\ref{fig:net}. Following the common practice~\cite{tian2020pfenet,wang2019panet,zhang2019canet}, query and support image are first feed into a shared backbone network to obtain general image features. Similar to~\cite{tian2020pfenet}, the backbone network is pretrained on ImageNet~\cite{russakovsky2015imagenet} and then completely kept fixed during few-shot segmentation training. Following~\cite{liu2020ppnet,tian2020pfenet,yang2020PMM}, we use dilated version of ResNet~\cite{he2015resnet} as the backbone network. Besides, middle-level features are processed by a 1x1 convolution to reduce the hidden dimension and high-level features are used to generate a prior map that concatenated with the middle-level feature. In details, the middle-level feature consists of the concatenation of features from the  and the  block of ResNet (total 5 blocks including the stem block) with shape  and is feed into a  convolution to reduce the dimension to , where  is the hidden dimension that can be adjusted in our experiments. The high-level feature (from the  block of ResNet) with shape  is used to generate the prior mask as in~\cite{tian2020pfenet}, which compute the pixel-wise similarity between the query and support high-level features and keep the maximum similarity at each pixel and normalize (using min-max normalization) the similarity map to the range of . To enable the pixel-wise comparison, we also concatenate the mask averaged support feature to both query and support feature and processed by a 1x1 convolution before inputting into the transformer. The final segmentation result is obtained by reshaping the output sequence back to spatial dimensions and predicted by a small convolution head that is consisted of one 3x3 convolution, one ReLU activation, and a 1x1 convolution. Dice loss~\cite{milletari2016diceloss} is used as the training objective. 

\textbf{Baseline setup}: 
For the baseline of our method, we use two residual blocks~\cite{he2015resnet} to merge the query feature. The support information comes from the concatenated support global feature and the prior map. 
During training, the foreground middle-level query feature from backbone network is averaged and concatenated with the middle-level support feature to predict the support mask for feature alignment. This auxiliary supervision is included in all of our experiments. 

\subsection{Dataset Settings}
In this Table~\ref{tab:vocsplit} and Table~\ref{tab:cocosplit}, we provide the detailed split settings for datasets (Pascal  and COCO-) used in our experiments, which follow the split settings proposed in~\cite{nguyen2019FWB}.


\begin{table}[ht]
  \centering
  \begin{tabular}{l|l}
    \toprule[1pt]
    Split & Test classes \\ \hline
    PASCAL-5\textsuperscript{0} & aeroplane, bicycle, bird, boat, bottle \\
PASCAL-5\textsuperscript{1} & bus, car, cat, chair, cow \\
PASCAL-5\textsuperscript{2} & diningtable, dog, horse, motorbike, person \\
PASCAL-5\textsuperscript{3} & potted plant, sheep, sofa, train, tv/monitor \\
    \bottomrule[1pt]
  \end{tabular}
  \caption{Data split for  PASCAL-, which follows the 4-fold cross-validation. Each row contains 5 classes for test and the rest 15 classes in the PASCAL dataset are used for training.}\label{tab:vocsplit}
\end{table}

\begin{table}[ht]
\centering
\small
\begin{tabular}{l|l}
\toprule[1pt]
Split & Test classes \\ \hline
\multirow{3}{*}{COCO-} & Person, Airplane, Boat, Park meter, Dog, Elephant, Backpack, Suitcase, Sports ball,  \\
& Skateboard, W. glass, Spoon, Sandwich, Hot dog, Chair, D. table, Mouse, Microwave, \\
& Fridge, Scissors,  \\ \hline
\multirow{2}{*}{COCO-} & Bicycle, Bus, T.light, Bench, Horse, Bear, Umbrella, Frisbee, Kite, Surfboard, Cup, Bowl, \\
& Orange, Pizza, Couch, Toilet, Remote, Oven, Book, Teddy,  \\ \hline
\multirow{2}{*}{COCO-} & Car, Train, Fire H., Bird, Sheep, Zebra, Handbag, Skis, B. bat, T. racket, Fork, Banana, \\
& Broccoli, Donut, P. plant, TV, Keyboard, Toaster, Clock, Hairdrier,  \\ \hline
\multirow{2}{*}{COCO-} & Motorcycle, Truck, Stop, Cat, Cow, Giraffe, Tie, Snowboard, B. glove, Bottle, Knife, Apple, \\
& Carrot, Cake, Bed, Laptop, Cellphone, Sink, Vase, Toothbrush, \\
\bottomrule[1pt]
\end{tabular}
\caption{Data split for COCO-, which follows the 4-fold cross-validation. Each row contains 20 classes for test and the rest classes in the COCO dataset are used for training.}
\label{tab:cocosplit}
\end{table}

\section{More Visualizations}
We provide more visualizations in Figure~\ref{fig:more_vis}. We also provide the visualization of cycle-consistency relationships. In the first row, only a small part of the foreground region is activated while most foreground regions are valid in the second row. And in the second row, pixels on the "person" are shown in gray, which indicates that these pixels may have a negative impact on segmenting "cat".

\begin{figure*}[ht]
    \centering
    \includegraphics[width=1.0\linewidth]{figs/add_vis.pdf}
    \caption{More Qualitative results on Pascal-. The cycle-consistency is visualized in the  column, in which red points are cycle-consistent foreground pixels, blue points are cycle-consistent background pixels, and gray points are cycle-inconsistent pixels. Best viewed in color and with zoom-in. }
    \label{fig:more_vis}
\end{figure*}


 


\end{document}