\maketitle



\begin{abstract}
The Resource -calculus is a variation of the -calculus 
where arguments can be superposed and must be linearly used.
Hence it is a model for linear and non-deterministic programming languages, 
and the target language of Taylor-Ehrhard expansion of -terms.
In a strictly typed restriction of the  Resource -calculus, we study 
the notion of path persistence,
and we define a Geometry of Interaction that characterises it,
is invariant under reduction,
and counts addends in normal forms.
\end{abstract}

\section*{Introduction}

\paragraph{Geometry of Interaction}
The dynamics of -reduction or cut elimination can be described in a 
purely geometric way ---studying paths in the graphs that represent terms 
or proofs, and looking at those which are \textit{persistent}, i.e. that have a 
residual path in any reduct.
The quest for an effective semantical characterisation of persistence 
separately produced three notions of paths:
\textit{legality}, formulated by topological conditions about symmetries on 
some 
cycles \cite{AspertiLaneve:1995:TCS};
\textit{consistency}, expressed similarly to a token-machine execution 
\cite{GonthierAbadiLevy:1992:optimal} and developed to study the optimal 
reduction;
and \textit{regularity}, defined by a dynamic algebra
\cite{Girard:1989, DanosRegnier:1995}.
The notions are equivalent \cite{AspertiDanosLaneveRegnier:1994}, and their
common core idea ---describing computation by local and asynchronous 
conditions on routing of paths--- inspired the design of efficient parallel 
abstract machines 
\cite[for instance]{Mackie:1995, Pinto:2001}.
More recently, the Geometry of Interaction (GoI) approach has been fruitfully 
employed for semantical investigations which characterised quantitative 
properties of programs, mainly the complexity of their execution time 
\cite{DalLago:2009}.

\paragraph{Taylor-Ehrhard expansion of -terms and the Resource 
Calculus}
Linear Logic's decomposition of the intuitionistic implication unveiled the 
relation between the algebraic concept of linearity to the computational 
property of a function argument to be used exactly once.
Such a decomposition was then applied not only at the level of types, but also 
at the level of terms, in particular extending the -calculus with 
differential constructors and linear combinations of ordinary terms 
\cite{EhrhardRegnier:2003}.
These constructions allow to consider the complete Taylor expansion of a term, 
i.e. the infinite series of all the approximations of the reduction of a term, 
which was thus shown to commute with computation of Böhm trees.
The ideal target language for the expansion was isolated as the Resource 
-calculus (RC), which is a promotion-free restriction of the 
Differential -calculus \cite{EhrhardRegnier:2006}.
Taylor-Ehrhard expansion originated various investigations on quantitative 
semantics, using the concept of power series for describing program evaluation, 
and has been applied in various non-standard models of computation, e.g.
\cite[for instance]{DanosEhrhard:2011,PaganiSelingerValiron:2014}.

\paragraph{Aim and results}
How can the two aforementioned semantics approaches interact?
What is the relation between the GoI's execution formula and the expansion of 
-reduction?
We present the first steps towards this direction.
After having concisely introduced RC (§\ref{sec:terms}),
we consider the Resource Interaction Nets (RINs),
that are the type-restricted translation of 
resource terms into Differential Interaction Nets (§\ref{sec:nets}).
We then study the appropriate notion of paths (§\ref{sec:paths}), extending the 
notion of persistence to paths in RINs dealing with the fact that 
the reduct of a term  is a sum of nets .
In particular, we observe that every path of  has to be a residual of some 
path in , and that the reduction strongly normalises.
Thus, we say a path of  to be persistent whenever it has a residual in at 
least one of the addends of the reduct of .
Restricting the calculus to the constant type, whose only inhabitant is the 
value , we have .
Now there is only one persistent path of , the trivial one, therefore 
we prove that persistent paths of  are as many as persistent paths of its 
normal form (\autoref{thm:RIN:path-red:bij}).
Furthermore, we define a suitable GoI for RC, in order to characterise 
persistence (§\ref{sec:Ex}).
We define the notion of regularity by , an appropriate variant of 
the Dynamic Algebra, where exponentials ( and ) become a sort of 
-ary multiplicatives (resp.  and ), whose premises are 
not ordered.
Morally, they are the sum of the multiplicatives we obtain by considering all 
the  permutations of their premises.
We show our algebra is invariant under reduction 
(\autoref{thm:RIN:weight-inv}), 
from which we obtain the equivalence of persistence to regularity
(\autoref{thm:RIN:regular}) and also that the number of addends in a normal 
form is 
equal to the number of regular paths (\autoref{cor:RIN:path-red:number}).

\paragraph{Related works}
In a very closely related work by De Falco \cite{DeFalco:2008}, a GoI 
construction for DINs is formulated.
Besides the similarities in the technical setting of DINs, our formulation 
turns out to be simpler and more effective, mainly thanks to:
(1) the restriction to closed and ground-typed resource nets,
(2) the associative syntax we adopted for exponential links, and
(3) the stronger notion of path we use.
The first simplifies the shape of paths being persistent, because it implies 
that they are palindrome ---they go from the root to the  and back to 
the root--- and unique in every normal net/term.
The second simplifies the management of the exponential links, because 
it ensures associativity and delimits their dynamics in only one pair of links, 
while in \cite{DeFalco:2008} this property was completely lost and the system 
more verbose.
De Falco uses binary exponential links and introduces a syntactical embedding 
of the sum in nets by mean of binary links of named sums, and then recover 
associativity with an equivalence on nets.
Compared to ours, their choice results in a drastically more complex 
GoI construction, even though the paper hints at the extensibility with 
promotion (corresponding to the full Differential -calculus) or even 
additives.
The third ingredient allows us to consider full reduction, 
i.e. including the annihilating rule, while in \cite{DeFalco:2008} a 
``weak'' variant is studied, where this kind of redexes are frozen, and 
the GoI only characterises the corresponding notion of ``weak-persistence''.
Indeed, we restrict to paths that cross every exponential in the net (we 
prove it is always true, in case of persistence), thus whenever  
a path necessarily crosses the annihilating redex, and the dynamic algebra is 
able to detect it.

\section{Resource calculus}
\label{sec:terms}

The Resource Calculus is, on one hand, a linear and thus finitary restriction 
of the -calculus: an argument  must be used by an application 
 exactly once, i.e. it cannot be duplicated nor erased, so every 
reduction enjoys strong normalisation.
On the other hand, it adds non-determinism to the -calculus, because 
the argument is a finite multiset of ordinary terms.
The reduct is then defined as the superposition of all the possible ways of 
substituting each of the arguments, i.e. a sum.
When arguments provided to a function are insufficient or excess the 
function's request, i.e. the number of variable occurrences, then the 
computation is deadlocked and the application reduces to .
We shall omit the ``resource'' qualification in the terminology.

\begin{definition}[Syntax]\label{def:terms:syntax}
Let  be the grammar of a denumerable set of variable symbols
.
Then, the set  of the \textit{simple terms} and the set 
 of \textit{simple polyterms} are inductively and mutually 
generated by the following grammars.

Where:  is the constant dummy value, brackets delimit multisets, 
 is the multiset union (associative and commutative),  is the empty 
multiset (neutral element of ).
So that .
Simple terms are denoted by the lowercase letters of the latin alphabet 
around , polyterms in uppercase letters around .
The set  of \textit{terms} (resp. the set  of 
\textit{polyterms}) is the set of finite formal sums of simple terms
(resp. polyterms) over the semiring  of natural numbers.
We also assume all syntactic constructors of simple terms and polyterms to be 
extended to sums by (bi-) linearity.
E.g.
 is a notational convention for
.
\end{definition}

\begin{definition}[Reduction]\label{def:RT:reduction}
A redex is a simple term in the form: .
Let the free occurrences of  in  be .
The \textit{reduction} is the relation  between polyterms 
obtained by the context closure and the linear extension to sum of the 
following elementary reduction rule.

Where  denotes the set of permutations of the first  naturals,
and  is the usual capture-avoiding substitution.
If , where  is the reflexive transitive 
closure of , we write .
\end{definition}

\begin{example}
\label{ex:terms}
Let
  
and also let
  .
Then
  
that is ,
normalising to
  .
Note also a case of annihilation in .
Finally, observe that if  then  
must be  (otherwise ).
\end{example}


\section{Resource nets}
\label{sec:nets}

A resource net is a graphical representation of a typed term by means of a 
syntax borrowed from Linear Logic proof nets, where -ary  links have 
a symmetrical dual.
The exponential modality is however deprived of promotion, so that it merely 
represents superposition of proofs and contexts.

\subsection{Pre-nets}
\label{sec:nets:prenets}

\begin{definition}[Links] \label{def:link}
Given a denumerable set of symbols called \textit{vertices}, a \textit{link} 
is a triple , where:
 is a sequence of vertices, called premises;
 is a kind, i.e. an element in the set
  ;
 is a singleton of a vertex, called conclusion, disjoint from .
A link  will be denoted 
as , or depicted as in 
\autoref{fig:net:links}.
The \textit{polarity} of a vertex associated by a link is an element in 

and we say they are opposite,
and the \textit{arity} of a link is the length of its premises' sequence;
both are determined by the link's kind,
as shown in \autoref{fig:net:links}.
When  for some vertex  and link , we write that 
 is linked by , or .
The exponential links  and  whose arity is  are 
respectively called co-weakening and weakening.
In the graphical representations, vertices of a link shall be placed following 
the usual convention for graphs of -calculus (s on the top, 
and s on the bottom); the arrow line shall be used to distinguish 
the conclusion of a link.
\end{definition}

\begin{figure}
  \caption{Links: kind, arity and polarity associated to vertices.}
  \label{fig:net:links}
  \centering
  \begin{tikzpicture}[
    auto, scale=1,
    link/.style = { circle, minimum size=5mm, draw },
    ]
{ [xshift=0cm,yshift=1cm]
    \node[link] (star) at (1,0) {}; \node at (star) {};
    \node (v) at (1,0.8) {};
    \draw[->] (star) -- (v);
  }{ [xshift=3.5cm,yshift=1cm]
    \node[link] (lambda) at (1,0) {}; \node at (lambda) {};
    \node (v) at (1,0.8) {};
    \node (u1) at (1,-0.8) {};
    \node (u2) at (.2,-0.8) {};
    \draw[->] (lambda) -- (v);
    \draw (lambda) -- (u1);
    \draw [rounded corners=5pt]
      (lambda)
      -- ++(-1.3,-0.5)
      -- ++(0,-0.5)
      -- ++(.5,-.3)
      -- (u2);
  }{ [xshift=6cm,yshift=1cm]
    \node[link] (app) at (1,0) {}; \node at (app) {};
    \node (u2) at (1,0.8) {};
    \node (u1) at (1.5,-0.8) {};
    \node (v)  at (.5,-0.8) {};
    \draw (app) -- (u2);
    \draw [rounded corners=3pt]
      (app)[->] -- ++(-.5,-.3) -- (v);
    \draw [rounded corners=3pt]
      (app) -- ++(.5,-.3) -- (u1);
  }{ [xshift=9cm,yshift=1cm]
      \node[link] (oc) at (1,0) {}; \node at (oc) {};
      \node (v) at (1,0.8) {};
      \node (u1)  at (.5,-0.8) {};
      \node (un) at (1.5,-0.8) {};
      \node at (1,-0.8) {};
      \draw[->] (oc) -- (v);
      \draw [rounded corners=3pt]
        (oc) -- ++(-.5,-.3) -- (u1);
      \draw [rounded corners=3pt]
        (oc) -- ++(.5,-.3) -- (un);
  }{ [xshift=12cm,yshift=1cm]
      \node[link] (wn) at (1,0) {}; \node at (wn) {};
      \node (u1)  at (.5,0.8) {};
      \node (un) at (1.5,0.8) {};
      \node (v) at (1,-0.8) {};
      \node at (1,0.8) {};
      \draw [rounded corners=3pt]
        (wn) -- ++(-.5,.3) -- (u1);
      \draw [rounded corners=3pt]
        (wn) -- ++(.5,.3) -- (un);
      \draw[->] (wn) -- (v);
    }
  \end{tikzpicture}
\end{figure}

\begin{definition}[Types]\label{def:types}
A \textit{type}, or formula, is a word of the grammar given by

and
  ,
where  is the only \textit{ground} type.
A \textit{typing function}  is a map from vertices to types such 
that, if  are types, then  respects the following constraints.
Constant:
  .
Linear implications:
   and .
Exponentials:
   and .
\end{definition}

\begin{definition}[Pre-nets] \label{def:prenet}
A \textit{simple pre-net}  is a triple ,
where  is a set of vertices,  is a set of links and  a 
typing function on , such that for every vertex  the followings 
holds:
\begin{enumerate}
\item
  there are at least one and at most two links  such that
  , and when there is only , then  is called a 
  \textit{conclusion} of ;
\item 
  the set  of conclusions is non empty and when it is the singleton 
  , then  is called \textit{closed} and  must be ;
\item
  if , then  associate opposite polarities to .
\end{enumerate}
We shall write  to denote the set .
The type of a pre-net  is the type  associated to its only  
conclusion, so we write .
The \textit{interface} of a simple pre-net  is the set  of 
all ordered pairs  such that for all ,  
is of type  and has polarity .
A general \textit{pre-net} is a linear combination of simple pre-nets
, where for any , we have:
 and 
.
We shall simply use  to denote each of the empty sums of pre-nets having 
the same interface , for every interface .
\end{definition}

\subsection{Term translation and net reduction}
\label{sec:nets:transl}

As the usual translation of the -calculus into MELL proof nets, 
the -link is used for translating -abstraction, the 
-link for application, and the -link for contracting together all 
the occurrences of the same variable.
In addition, we use -link for polyterm and formal sum of nets for\ldots 
formal sum of terms.

\begin{definition}[Term translation]\label{def:RIN:transl}
Given a simple term , the \textit{translation}  is a pre-net 
having one  conclusion and a possibly empty set of  conclusions.
The translation is defined in \autoref{fig:net:transl} where: the final step 
only adds a -link on every occurrence of a free variable , for all free 
variables of ; and the actual work is performed by the ,
by induction on the syntax of .
Moreover a sum of simple terms is translated to the sum of their translation, 
i.e.:
.
\end{definition}

\begin{figure}
  \caption{Pre-translation and translation of simple terms into simple nets.}
  \label{fig:net:transl}
  \centering
  \begin{tikzpicture}[auto, scale=1,
    subnet/.style = {
      rectangle,
      rounded corners=5pt,
      very thick,
      draw
    },
    link/.style = { circle, minimum size=5mm, draw },
    contr/.style = {
      isosceles triangle,
      isosceles triangle apex angle=60,
      draw
  }]
{ [xshift=0.4cm,yshift=5.1cm]
    \node at (0.1,0.3) {};
    \node[link] (star) at (1,0) {}; \node at (star) {};
    \node (v) at (1,0.7) {};
    \draw [->] (star) -- (v);
  }{ [xshift=0.5cm,yshift=4cm]
    \node at (0.9,0) {};
    \node[subnet] (sub) at (3,0) {};
    \node[link] (lambda) at (3,1) {}; \node at (lambda) {};
    \node (v) at (3,1.8) {};
    \node[link] (contr) at (3,-1.4) {}; \node at (contr) {};
\draw[->] (lambda) -- (v);
    \draw (lambda) -- node {} (sub);
    \draw[<-, rounded corners=10pt]
      (lambda) -- ++(-1.2,-0.7) -- ++(0,-1) --
      (3,-2) node {} -- (contr);
    \draw[rounded corners=10pt]
      (sub.west) -- ++(0,-0.5) -- (contr);
    \node at (3,-0.6) {};
    \draw[rounded corners=10pt]
      (sub.east) -- ++(0,-0.5) -- (contr);
  }{ [xshift=4.7cm,yshift=3.8cm]
    \node at (1,1) {};
    \node[subnet] (sub1) at (1.9,0) {};
    \node at (3,0) {};
    \node[subnet] (subn) at (4.1,0) {};
    \node[link] (cocontr) at (3,1.1) {}; \node at (cocontr) {};
    \node (v) at (3,2) {};
    \node at (3,0.6) {};
    \draw [<-] (v) -- (cocontr);
    \draw[rounded corners=5pt] (sub1) -- ++(0,0.5) -- (cocontr);
    \draw[rounded corners=5pt] (subn) -- ++(0,0.5) -- (cocontr);
  }{ [xshift=8.2cm,yshift=2.3cm]
    \node at (0.8,0.4) {};
    \node[subnet] (subt) at (2.2,0) {};
    \node[subnet] (subS) at (3.8,0) {};
    \node[link] (nimp) at (3,1) {}; \node at (nimp) {};
    \node (v) at (3,1.8) {};
    \node at (3,0.6) {};
    \draw (v) -- (nimp);
    \draw[<-, rounded corners=4pt] (subt) -- ++(0,0.5) -- (nimp);
    \draw[rounded corners=4pt] (subS) -- ++(0,0.5) -- (nimp);
  }{ [xshift=11.3cm,yshift=5.6cm]
    \node at (1,-0.9) {};
    \node[subnet] (sub) at (3,0) {};
    \node[link] (contr1) at (2.5,-1.4) {}; \node at (contr1) {};
    \node[link] (contrl) at (3.5,-1.4) {}; \node at (contrl) {};
    \node (v1) at (2.5,-2.3) {};
    \node (vl) at (3.5,-2.3) {};
    \draw[->] (contr1) -- (v1);
    \draw[->] (contrl) -- (vl);
    \draw[rounded corners=15pt] (sub.west) -- ++(0,-0.5) -- (contr1);
    \draw[rounded corners=15pt] (sub.south) -- ++(0,-0.5) -- (contr1);
    \draw[rounded corners=15pt] (sub.south) -- ++(0,-0.5) -- (contrl);
    \draw[rounded corners=15pt] (sub.east) -- ++(0,-0.5) -- (contrl);
    \node at (2.5,-.9) {};
    \node at (3.5,-.9) {};
    \node at (3,-2.3) {};
    \node at (1.8,-.6) {};
    \node at (2.7,-.6) {};
    \node at (3.3,-.6) {};
    \node at (4.3,-.6) {};
  }{ [xshift=0.8cm,yshift=2.2cm]
    \node at (0,0) {};
  }
  \end{tikzpicture}
\end{figure}

Note that a net translation is always defined for simple terms while it is 
not for general terms, because of possible incompatibility in the interfaces of 
translated addends.

\begin{definition}[Resource permutations]\label{def:RIN:permnet}
Given a simple pre-net , a \textit{resource permutation}  
is a total function from the set of -links in  to  such that
if a link  has arity ,
  then  is an element  of .
We shall also write  for  and denote the set of 
resource permutation of  as .
\end{definition}

\begin{definition}[Resource net reduction]\label{def:nets:red}
The \textit{redex} of a cut  in a simple pre-net is the pair of links having 
 as conclusion.
The \textit{simple reduction}  is the graph-rewrit\-ing relation from 
simple pre-nets to pre-nets defined by the following elementary reduction steps,
also depicted in \autoref{fig:nets:red}, omitting contexts.

Where  denotes the -th copy of the pre-net ,
where the vertices  have been equated.
In such a case, we say then there is a \textit{simple reduction step} , where  is a sum of simple pre-nets and is 
also written as .
The \textit{reduction} is the extension of the simple reduction to formal sums 
of simple pre-nets: if
  ,
then
  .
If
  ,
we write .
\end{definition}

\begin{figure}
  \caption{Cut elimination rules: linear implication, and exponential.}
  \label{fig:nets:red}
  \centering
  \begin{tikzpicture}[
    auto, scale=1,
    link/.style = { circle, minimum size=5mm, draw },
    subnet/.style = { rectangle, rounded corners=5pt, very thick, draw}]
{ [xshift=-2cm,yshift=.7cm]
    \node[link] (lambda) at (0,0) {}; \node at (lambda) {};
    \node[link] (app) at (.7,1) {}; \node at (app) {};
    \node (vroot)  at (.7,1.8) {};
    \node (varg) at (1.4,.2) {};
    \node (vbody)  at (0,-.8) {};
    \node (vvar)  at (-.4,-1) {};
\draw [rounded corners=5pt] (app) -- ++(-.7,-.3) -- node {} (lambda);
    \draw [<-, rounded corners=5pt] (app) -- ++(.7,-.3) -- (varg);
    \draw [->] (vroot) -- (app);
    \draw [<-] (lambda) -- (vbody);
    \draw [<-, rounded corners=5pt]
      (lambda) -- ++(-.8,-.8) -- ++ (0,-.6) -- ++ (.4,0) -- (vvar);
\node at (2.3,.4) {\Large };
\node at (3.5,0.7) {};
    \node at (3,-.7) {};
}{ [xshift=5.5cm,yshift=0cm]
    \node[link] (ccontr) at (1,1.5) {}; \node at (ccontr) {};
    \node[link] (contr)   at (1,.5) {}; \node at (contr) {};
    \node (v1)  at (.3,2.2) {};
    \node at (1,2.2) {};
    \node (vn) at (1.7,2.2) {};
    \node (u1)  at (.3,-.2) {};
    \node at (1,-.2) {};
    \node (um) at (1.7,-.2) {};
    \draw (contr) -- node {} (ccontr);
    \draw [rounded corners=5pt] (v1) -- ++(0,-.5) -- (ccontr);
    \draw [rounded corners=5pt] (vn) -- ++(0,-.5) -- (ccontr);
    \draw [rounded corners=5pt] (u1) -- ++(0,.5) -- (contr);
    \draw [rounded corners=5pt] (um) -- ++(0,.5) -- (contr);
\node at (4,0.7) {
      {\Large }

    };
  \node at (-1,1) {
    {\Large } };}
  \end{tikzpicture}
\end{figure}

\begin{definition}[Resource interaction nets]\label{def:RIN}
Let  and , for a sum
,
where each  is a pre-net.
Then  is called a \textit{simple resource interaction net}
and  a \textit{resource interaction net}.
From now on we shall again avoid to repeat the ``resource interaction'' naming 
of nets.
\end{definition}

We recall that the net reduction can simulate the term reduction and strongly 
normalises.

\begin{example}\label{ex:nets}
Consider 
and notice  is not a pre-net,
because a typing function on the structure of vertices and links does not exist.
Recall the terms  and  from \autoref{ex:terms}
and look at \autoref{fig:ex}.
On the left extremity:
   is closed and .
On the middle left:  is not a translation of a term,
but it is a net,
  because  by eliminating a linear implication 
cut.
Also,  is not a closed net,
 because it has three conclusions: .
On the right side: an exponential reduction step involving index permutation,
that rewrite  into a sum of two normal simple nets.
Observe the reduct is equal to
  .
Consider ,
that is a closed net of type ,
and observe the reduct  of the only linear implication cut
that is depicted in \autoref{fig:ex2}.
The normalisation requires: one exponential step (on the left),
two linear implication steps (on the right),
and finally four exponential steps (not showed) to reach the net
.
\end{example}

\begin{figure}[b]
  \centering
  \caption{Example: nets and reduction.}
  \label{fig:ex}
  \begin{tikzpicture}[
    auto, scale=1,
    link/.style = { circle, minimum size=5mm, draw },
    subnet/.style = { rectangle, rounded corners=5pt, very thick, draw} ]
\node at (4.2,2.5) {};
  { [xshift=-1.1cm,yshift=2cm]
    \node at (2,0.5) {};
    \node[link] (lambda) at (3,1) {}; \node at (lambda) {};
    \node (v) at (3,1.8) {};
    \node[link] (contr) at (3,0) {}; \node at (contr) {};
\draw[->] (lambda) -- (v);
    \draw (lambda) -- node {} (contr);
    \draw[<-, rounded corners=5pt]
      (lambda) -- ++(-.5,-.5) -- ++(0,-1) --
      (3,-.8) -- node[swap] {} (contr);
  }{ [xshift=4.7cm,yshift=1cm]
    \node (v1) at (1,3.8) {};
    \node[link] (app1)    at (1,3) {}; \node at (app1) {};
    \node[link] (ccontr1) at (1.8,2) {}; \node at (ccontr1) {};
    \node[link] (app2)    at (1.8,1) {}; \node at (app2) {};
    \node[link] (contr)   at (1,0) {}; \node at (contr) {};
    \node[link] (ccontri) at (1,-1) {}; \node at (ccontri) {};
    \node[link] (ccontr)  at (2.6,0) {}; \node at (ccontr) {};
    \node[link] (star)    at (2.6,-1) {}; \node at (star) {};
    \node (u1)  at (.3,-1.5) {};
    \node (u1') at (1.7,-1.5) {};
\draw [<-] (app1) -- (v1);
    \draw[->, rounded corners=10pt]
      (app1) -- ++(-.5,-.5) -- ++(0,-2) -- node[swap] {}  (contr);
    \draw[<-, rounded corners=10pt]
      (app1) -- ++(.7,-.3) -- node {} (ccontr1);
    \draw (app2) -- node {} (ccontr1);
    \draw[->, rounded corners=8pt]
      (app2) -- ++(-.5,-.5) -- node {} (contr);
    \draw[<-, rounded corners=10pt]
      (app2) -- ++(.5,-.5) -- node {} (ccontr);
    \draw (contr) -- node {}(ccontri);
    \draw [<-] (ccontr) -- node {}(star);
    \draw [<-](ccontri) -- (u1);
    \draw [<-](ccontri) -- (u1');
  }
  \node at (7.9,2.4) {\Large };
  { [xshift=11cm,yshift=0.7cm]
    { [xshift=-2cm,yshift=0cm]
    \node (v1) at (1,3.8) {};
    \node[link] (app1)    at (1,3) {}; \node at (app1) {};
    \node[link] (ccontr1) at (1.8,2) {}; \node at (ccontr1) {};
    \node[link] (app2)    at (1.8,1) {}; \node at (app2) {};
    \node[link] (ccontr)  at (2.6,0) {}; \node at (ccontr) {};
    \node[link] (star)    at (2.6,-1) {}; \node at (star) {};
    \node (u1)  at (0,0.2) {};
    \node (u1') at (1.3,0.2) {};
\draw [<-] (app1) -- (v1);
    \draw[->, rounded corners=15pt] (app1) -- ++(-1,-.5) -- (u1);
    \draw[<-, rounded corners=8pt]
      (app1) -- ++(.7,-.3) -- node {} (ccontr1);
    \draw (app2) -- node {} (ccontr1);
    \draw [->, rounded corners=1pt] (app2) -- ++(-.4,-.4) -- (u1');
    \draw[<-, rounded corners=10pt] (app2) -- ++(.5,-.5) -- node {} 
(ccontr);
    \draw [<-] (ccontr) -- node {}(star);
    }
    \node at (1.2,1.8) {\Large};
    { [xshift=2cm,yshift=0cm]
    \node (v1) at (1,3.9) {};
    \node[link] (app1)    at (1,3) {}; \node at (app1) {};
    \node[link] (ccontr1) at (1.8,2) {}; \node at (ccontr1) {};
    \node[link] (app2)    at (1.8,1) {}; \node at (app2) {};
    \node[link] (ccontr)  at (2.6,0) {}; \node at (ccontr) {};
    \node[link] (star)    at (2.6,-1) {}; \node at (star) {};
    \node (u1')  at (0,0.2) {};
    \node (u1) at (1.3,0.2) {};
\draw [<-] (app1) -- (v1);
    \draw[->, rounded corners=8pt]
      (app1) -- ++(-.7,-.3) -- ++(0,-1) -- ++(.8,-.5) -- (u1);
    \draw[<-, rounded corners=10pt]
      (app1) -- ++(.7,-.3) -- node {} (ccontr1);
    \draw (app2) -- node {} (ccontr1);
    \draw [->, rounded corners=10pt] (app2) -- ++(-1,-.2) -- (u1');
    \draw[<-, rounded corners=10pt] (app2) -- ++(.5,-.5) -- node {} 
(ccontr);
    \draw [<-] (ccontr) -- node {}(star);
    }
  }
  \end{tikzpicture}
\end{figure}

\begin{figure}
  \centering
  \caption{Example: nets reduction. Rightmost reduction is made of four steps, 
two on each addend.}
  \label{fig:ex2}
  \begin{tikzpicture}[
    auto, scale=1,
    link/.style = { circle, minimum size=5mm, draw },
    subnet/.style = { rectangle, rounded corners=5pt, very thick, draw} ]
{ [xshift=2.2cm,yshift=-1.8cm]
\node[link] (lambda) at (3,1) {}; \node at (lambda) {};
    \node[link] (contr) at (3,0) {}; \node at (contr) {};
\draw (lambda) -- node {} (contr);
    \draw[<-, rounded corners=5pt]
      (lambda) -- ++(-.4,-.4) -- ++(0,-1) --
      (3,-.8) -- node[swap] {} (contr);
  }
  { [xshift=3.3cm,yshift=-1.8cm]
\node[link] (lambda1) at (3,1) {}; \node at (lambda1) {};
    \node[link] (contr1) at (3,0) {}; \node at (contr1) {};
\draw (lambda1) -- node {} (contr1);
    \draw[<-, rounded corners=5pt]
      (lambda1) -- ++(-.4,-.4) -- ++(0,-1) --
      (3,-.8) -- node[swap] {} (contr1);
  }
  { [xshift=4.7cm,yshift=1cm]
\node (v1) at (1,3.8) {};
    \node[link] (app1)    at (1,3) {}; \node at (app1) {};
    \node[link] (ccontr1) at (1.8,2) {}; \node at (ccontr1) {};
    \node[link] (app2)    at (1.8,1) {}; \node at (app2) {};
    \node[link] (contr)   at (1,0) {}; \node at (contr) {};
    \node[link] (ccontri) at (1,-1) {}; \node at (ccontri) {};
    \node[link] (ccontr)  at (2.6,0) {}; \node at (ccontr) {};
    \node[link] (star)    at (2.6,-1) {}; \node at (star) {};
\draw [<-] (app1) -- (v1);
    \draw[->, rounded corners=10pt]
      (app1) -- ++(-.5,-.5) -- ++(0,-2) -- node[swap] {}  (contr);
    \draw[<-, rounded corners=10pt]
      (app1) -- ++(.7,-.3) -- node {} (ccontr1);
    \draw (app2) -- node[swap] {} (ccontr1);
    \draw[->, rounded corners=8pt]
      (app2) -- ++(-.5,-.5) -- node {} (contr);
    \draw[<-, rounded corners=10pt]
      (app2) -- ++(.5,-.5) -- node {} (ccontr);
    \draw (contr) -- node {}(ccontri);
    \draw [<-] (ccontr) -- node {}(star);
    \draw [<-, rounded corners=5pt]
      (ccontri) -- ++(-.5,-.2) -- node[swap] {} (lambda);
    \draw [<-, rounded corners=5pt]
      (ccontri) -- ++(.5,-.2) -- node[] {}  (lambda1);
  }
\node at (8.3,1.5) {\Large };
  { [xshift=11.1cm,yshift=0cm]
    { [xshift=-5cm,yshift=-1cm]
\node[link] (lambda) at (3,1) {}; \node at (lambda) {};
      \node[link] (contr) at (3,0) {}; \node at (contr) {};
\draw (lambda) -- node {} (contr);
      \draw[<-, rounded corners=5pt]
        (lambda) -- ++(-.4,-.4) -- ++(0,-1) --
        (3,-.8) -- node[swap] {} (contr);
    }
    { [xshift=-3.8cm,yshift=-1cm]
\node[link] (lambda1) at (3,1) {}; \node at (lambda1) {};
      \node[link] (contr1) at (3,0) {}; \node at (contr1) {};
\draw (lambda1) -- node {} (contr1);
      \draw[<-, rounded corners=5pt]
        (lambda1) -- ++(-.4,-.4) -- ++(0,-1) --
        (3,-.8) -- node[swap] {} (contr1);
    }
    { [xshift=-2cm,yshift=0cm]
\node (v1) at (1,3.8) {};
      \node[link] (app1)    at (1,3) {}; \node at (app1) {};
      \node[link] (ccontr1) at (1.8,2) {}; \node at (ccontr1) {};
      \node[link] (app2)    at (1.8,1) {}; \node at (app2) {};
      \node[link] (ccontr)  at (2.6,0) {}; \node at (ccontr) {};
      \node[link] (star)    at (2.6,-1) {}; \node at (star) {};
\draw [<-] (app1) -- (v1);
      \draw[->, rounded corners=15pt]
        (app1) -- ++(-1,-.5) -- node {} (lambda);
      \draw[<-, rounded corners=8pt]
        (app1) -- ++(.7,-.3) -- node {} (ccontr1);
      \draw (app2) -- node[swap] {} (ccontr1);
      \draw [->, rounded corners=10pt]
        (app2) -- ++(-.4,-.4) -- node[swap] {} (lambda1);
      \draw[<-, rounded corners=10pt]
        (app2) -- ++(.5,-.5) -- node {} (ccontr);
      \draw [<-] (ccontr) -- node {}(star);
    }
\node at (1,3.1) {\Large};
    { [xshift=-.9cm,yshift=-1cm]
\node[link] (lambda) at (3,1) {}; \node at (lambda) {};
      \node[link] (contr) at (3,0) {}; \node at (contr) {};
\draw (lambda) -- node {} (contr);
      \draw[<-, rounded corners=5pt]
        (lambda) -- ++(-.4,-.4) -- ++(0,-1) --
        (3,-.8) -- node[swap] {} (contr);
    }
    { [xshift=0.3cm,yshift=-1cm]
\node[link] (lambda1) at (3,1) {}; \node at (lambda1) {};
      \node[link] (contr1) at (3,0) {}; \node at (contr1) {};
\draw (lambda1) -- node {} (contr1);
      \draw[<-, rounded corners=5pt]
        (lambda1) -- ++(-.4,-.4) -- ++(0,-1) --
        (3,-.8) -- node[swap] {} (contr1);
    }
    { [xshift=1.9cm,yshift=0cm]
\node (v1) at (1,3.9) {};
      \node[link] (app1)    at (1,3) {}; \node at (app1) {};
      \node[link] (ccontr1) at (1.8,2) {}; \node at (ccontr1) {};
      \node[link] (app2)    at (1.8,1) {}; \node at (app2) {};
      \node[link] (ccontr)  at (2.6,0) {}; \node at (ccontr) {};
      \node[link] (star)    at (2.6,-1) {}; \node at (star) {};
\draw [<-] (app1) -- (v1);
      \draw[->, rounded corners=8pt]
        (app1) -- ++(-.7,-.3) --  node {} ++(0,-1) --
        ++(.8,-.5) -- (lambda1);
      \draw[<-, rounded corners=10pt]
        (app1) -- ++(.7,-.3) -- node {} (ccontr1);
      \draw (app2) -- node[swap] {} (ccontr1);
      \draw [->, rounded corners=10pt]
        (app2) -- ++(-1,-.2) -- node[swap] {} (lambda);
      \draw[<-, rounded corners=10pt]
        (app2) -- ++(.5,-.5) -- node {} (ccontr);
      \draw [<-] (ccontr) -- node {}(star);
    }
  }
\node at (16.1,1.5) {\Large };
  { [xshift=17cm,yshift=0cm]
    \node (v1) at (0,3.8) {};
    \node[link] (contr) at (0,3) {}; \node at (contr) {};
    \node[link] (ccontr) at (0,2) {}; \node at (ccontr) {};
    \node[link] (contr1) at (0,1) {}; \node at (contr1) {};
    \node[link] (ccontr1) at (0,0) {}; \node at (ccontr1) {};
    \node[link] (star)    at (0,-1) {}; \node at (star) {};
\draw [->] (v1) -- (contr);
    \draw (contr) -- node {} (ccontr);
    \draw (ccontr) -- node {} (contr1);
    \draw (contr1) -- node {} (ccontr1);
    \draw (ccontr1) -- node {} (star);
  }
  \node at (18.2,3.1) {\Large };
  { [xshift=19.1cm,yshift=0cm]
    \node (v1) at (0,3.8) {};
    \node[link] (contr) at (0,3) {}; \node at (contr) {};
    \node[link] (ccontr) at (0,2) {}; \node at (ccontr) {};
    \node[link] (contr1) at (0,1) {}; \node at (contr1) {};
    \node[link] (ccontr1) at (0,0) {}; \node at (ccontr1) {};
    \node[link] (star)    at (0,-1) {}; \node at (star) {};
\draw [->] (v1) -- (contr);
    \draw (contr) -- node {} (ccontr);
    \draw (ccontr) -- node {} (contr1);
    \draw (contr1) -- node {} (ccontr1);
    \draw (ccontr1) -- node {} (star);
  }
  \end{tikzpicture}
\end{figure}

\section{Paths}
\label{sec:paths}

\subsection{Definitions}
We introduce some basic definitions about the paths, where the most notable 
characterise the paths where the computation is visible (straightness) 
in its entirety (maximality and comprehensiveness).
This last notion is the only substantial difference with respect to the 
classic notion of path as formulated in \cite{DanosRegnier:1995}.
A superficial technical difference is the choice of using concatenation 
instead of composition as the basic relation on paths.

\begin{definition}[Path] \label{def:path}
  Given a simple net , two vertices  are \textit{linked}, 
  or connected, if there is a link  s.t.  .
  A \textit{path}  with  in 
  is a sequence of vertices s.t.
    for all ,
    the vertices  are connected.
  We call  \textit{trivial} if its lenght is ; 
  we say  \textit{unitary} if is , so that there is only one link
  crossed by .
  \\
  Moreover, if  crosses consecutively the same link  more that once, 
  then  is called \textit{bouncing}.
  If  is not a -link and  crosses  through  such that
     or ,
  then  is \textit{twisting}.
  When  is both non-bouncing and non-twisting,  is \textit{straight}.
  Moreover,  is \textit{maximal} if there is no other path
   s.t. , where  is the 
  prefix order on sequences.
  Also,  is \textit{comprehensive} when it crosses all the premises of all 
  the exponential links.
  Finally if  is both straight and maximal, then  is an 
  \textit{execution} path.
  In a net , we denote with 
  (or with ) 
  the set of execution paths (respectively also comprehensive)
  in some simple  addend of .
  \\
  Given two paths 
  we denote the \textit{reversal} of  as ,
  while the \textit{concatenation} of  to  as .
\end{definition}

We can now concretely aim to define a proper notion of path persistence, that 
intuitively means ``having a residual'', so first we inspect and define the 
action of residual of path.
The case of linear implication is straightforward, because the rewriting is 
local and we only have to ensure that a path does not partially belong to 
a redex.
The case of exponential, instead, is rather more delicate, because the 
rewriting is global: a simple net rewrites to a sum of simple nets, hence a 
path may be duplicated in several addends or destroyed.
Which addends contain the residual(s) of a given crossing?
The net reduction consists of the sum of all the permutation of the indices of 
the -links (cf. \autoref{def:nets:red}), thus each addend contains all 
and only the paths that respect the addend's own permutation, for any crossing 
of the redex.
If a path  is persistent, then, there must be a permutation such that 
 always crosses the redex respecting the correspondences fixed by the 
permutation.



\begin{definition}[Path residual]
\label{def:RIN:path-red}
Given a net  and a reduction  on a redex ,
we say a path  is \textit{long enough} for  when neither its 
first nor its last vertex is the cut of .
In such a case, we can express  by isolating every \textit{crossing} of 
, that is a maximal sub-sequence of  entirely contained in  as:

where for any , the subpath  is a crossing for .
This last is called the \textit{redex crossing form} (RCF) of  for .
\\
The \textit{path reduction} is a function from paths in  to sums 
of paths in .
The residual of , written , is defined according to the 
reduction rule used by  and by extension of the case of .
\begin{enumerate}
\item \label{def:RIN:path-red:imp}
  Linear implication cut.
  If  is as in \autoref{eq:RIN:red:impl},
  then  is defined as follows.\\
  \begin{minipage}{0.45\textwidth}
    
  \end{minipage}
  \begin{minipage}{0.45\textwidth}
    
  \end{minipage}\\\vspace{\lineskip}

  The residual of the whole  is defined as:
  
\item \label{def:RIN:path-red:exp}
  Exponential cut.
  Let  be as in \autoref{eq:RIN:red:exp} and .
  First, we define the residual of  with respect to ,
  for every pair of indices , and :
  
  Now, similarly to \autoref{eq:RIN:path-red:imp}, we can define the residual 
  of the path  with respect to :
  
  Finally, we can define the residual of  as the sum of all the residuals, 
  for any :
  
\end{enumerate}
If , then  is \textit{persistent to }.
If, for every reduction sequence , and for 
every , the path  is persistent to , then  
is \textit{persistent}.
\end{definition}

\begin{example}\label{ex:path}
Recall the nets discussed in \autoref{ex:nets} and let
  ,
respectively be the left and the right addend of \autoref{fig:ex}.
Look at the net  and notice the paths  and  
are not straight -- the former is twisting, while the latter is bouncing.
Consider the net  and the path .
It is straight and also maximal.
Indeed, .
What about ?
If we start from  we find two paths seeking for the head variable:
   and
  .
Both are straight and persistent, since:
   and
  .
On the other hand they are not comprehensive, since they do not cross  nor 
.
Remark also  cross the exponential redex differently,
and they do not belong to the same addend of the reduct,
for , while .
If otherwise we begin with , which morally represents a free variable, 
the walk searches for the term that is going to substitute it.

is not persistent, because crosses the same redex twice, each of those belongs 
to a distinct permutation.
Morally  is trying to use the same variable as the function of both 
the applications.
\end{example}

\subsection{Results}

A persistent execution path travels through every vertex of a net that either 
belongs to the normal form of the net, or is eliminated by the normalisation.
Since RINs represent a linear calculus without erasing, we show that 
comprehensiveness of paths is a natural property for execution paths.
Moreover RINs have no duplication, despite what sum creation looks like,
so we can also show that the exponential reduction rule indeed partitions 
persistent execution paths among the addends it creates ---its action is a 
bijection.

\begin{lemma}
\label{lem:RIN:exponentials}
In a closed simple net ,
the conclusion of an exponential link is either
the first premise of a linear implication link, or
a cut with another exponential link.
\end{lemma}
\begin{proof}
Given \autoref{def:RIN} of nets, we proceed by induction on the length of 
the reduction sequence , 
for some term  and net .
\begin{enumerate}
\item \textit{Base.} Suppose .
  Thesis holds for , by immediate verification of 
  \autoref{def:RIN:transl}.
\item \textit{Step.} Suppose .
  Let 
    be an exponential link in  
  and suppose ,
    for some reduction sequence 
      where the thesis holds by inductive hypothesis (IH),
        for some reduction step  that is of our interest.
  \begin{enumerate}
  \item If  does not affect , then IH is trivially preserved.
  \item If  is a linear implication step involving , then, by IH, the
    redex has to contain  and 
    (if  is negative), or 
    by  and 
    (if  is positive).
    In both cases, observe now that, by definition of nets, and in particular 
    by \autoref{def:prenet} and \ref{def:types},
     must be the conclusion of an exponential link  dual to .
    Therefore in the reduct of ,  will be the conclusion 
    of  (i.e. an exponential cut).
  \item If  is an exponential implication step involving , then 
    notice that, by IH,  has to be the reduced cut.
    In such a case  is erased,
    either with, or without, the whole net , 
    (depending on whether the arity mismatches or not),
    hence preserving the thesis.
  \end{enumerate}
\end{enumerate}
\vspace{-1.5em}
\end{proof}



\begin{lemma}
\label{lem:comprehensiveness}
For any term  such that ,
any persistent path  is comprehensive.
\end{lemma}
\begin{proof}
We shall prove a stronger thesis:
given a persistent path ,
a vertex  if and only if
there exists a (co-)weakening  such that .
\begin{itemize}
\item
  The ``if'' direction of the thesis follows from a mere observation of the 
  \autoref{def:path} of execution paths.
  If  includes a conclusion of a (co-)weakening,
  then  is necessarily bouncing or non-maximal,
  in both cases contradicting the hypothesis that  is an execution path.

\item 
  In order to prove the ``only if'' part of the thesis,
  let us first recall that, by \autoref{def:RIN},
  a simple net is either a translation of a term, or an addend in its reduct.
  We now go by induction on a sequence  of expansion (or an 
  anti-sequence of reduction) from a normal form 
  back to a simple net , for some term .
  If  there is nothing to prove,
  so we shall assume it to be non-zero.

  \begin{enumerate}
  \item \textit{Base.}
    Suppose .
    Then .
    Therefore , because the only closed term whose translation is 
    normal with respect to net reduction is .
    Then , and .
  \item \textit{Step.}
    Suppose .
    Let  and .
    We then distinguish two sub-cases depending on the rule employed by .
    \begin{enumerate}
    \item \textit{Linear implication cut.}
      Suppose  to be an addend of  containing the 
      vertices , and the expansion step to be the following, where the 
       are introduced.
      
      Now  cannot be the conclusion of a (co-)weakening,
      as established by \autoref{lem:RIN:exponentials}.
      Hence, by inductive hypothesis (IH),  and it is enough to 
      observe, by \autoref{def:RIN:path-red}, \autoref{def:RIN:path-red:imp},
      that also .
      Let's now discuss .
      \begin{enumerate}
      \item If , then,
        because of \autoref{lem:RIN:exponentials}, 
         must be an exponential redex containing a weakening.
        So, first we clearly have .
        Moreover, we also have that  because 
         must be the conclusion of a co-weakening.
        Otherwise  would be a net-neutralisation redex,
        which contradicts the persistence hypothesis we have for .
        In such a case, the expansion is admissible, and we can verify both
        .
      \item Otherwise .
        Then again by inspection of
        \autoref{def:RIN:path-red} and \ref{def:RIN:path-red:imp},
        we verify that .
      \end{enumerate}
    \item \textit{Exponential cut.}
      If the expansion affect  addends,
       is unaffected, hence IH is trivially preserved.
      Otherwise, let  be as follows.
      
      For any ,
      the vertices  cannot be the conclusion 
      of some (co-)weakening (cf. \autoref{lem:RIN:exponentials}).
      Thus, by IH, for any  such that
      , we also have
      .
    \end{enumerate}
  \end{enumerate}
\end{itemize}
\vspace{-1.5em}
\end{proof}

\begin{theorem}
\label{thm:RIN:path-red:bij}
For any closed , every reduction step  induces a 
bijection between persistent paths in  and persistent paths 
.
\end{theorem}


\begin{proof}
Let  be persistent, and suppose its RCF is
.
There are two reduction rules possibly used by .
\begin{enumerate}
\item
  \textit{Linear implication cut.}
  Because of the persistence of  to , and by the
  definition given by \autoref{eq:RIN:path-red:imp}, we have , 
  for all , and
    .
  By an inspection of the definition of crossing path reduction, we first 
  notice that, for each of the four possible extrema of , there is a 
  unique reduct that corresponds to a particular direction
  (from  to , or \textit{vice versa})
  of one of the two cut vertices in : 
  , and .
  Namely, let  be as in \autoref{eq:RIN:red:impl}.
  Then, the bijection is given as follows:
  \begin{enumerate}
  \item
     if and only if
     from  to ;
  \item
     if and only if
     from  to ;
  \item
     if and only if
     from  to ;
  \item
     if and only if
     from  to .
  \end{enumerate}
  Such a bijection holds between  and , so we also
  have a bijection between  and .
\item
  \textit{Exponential cut.}
  Suppose the redex  being as in \autoref{eq:RIN:red:exp}.
  Because of the persistence of  to , and by the definition given by 
  \autoref{eq:RIN:path-red-sigma:exp} and \ref{eq:RIN:path-red:exp}, it must be 
  the case that  and that there exist a permutation  
  such that for all , we have .
  Moreover, by \autoref{lem:comprehensiveness},  is 
  comprehensive, therefore 
   is unique and for any other , we have 
  .
  Let  be as in \autoref{eq:RIN:crossing-red:exp}, and observe it 
  must be also the case that  so that
  .
  We then obtained a one-to-one relation between  and .
\end{enumerate}
\vspace{-1.5em}
\end{proof}

\section{Execution} \label{sec:Ex}

\subsection{Definitions}
We are ready to formulate the GoI construction for RINs.
We followed the spirit of the formulation for the case of MELL as formulated in 
\cite{DanosRegnier:1995}, but we characterise our resource exponentials,
which have no promotion, as a sort of superposition of -ary multiplicatives.
We define a weight assignment for paths, so that the execution of a net is
the sum of the weights of any execution path within it, and we formulate a 
Dynamic Algebra  on weights representing the computation.
A crossing of an exponential link is weighted spanning over the space of 
permutations of the indices of link's premises, and exponential weights 
interacts exactly as multiplicatives weights, i.e. by nullification or 
neutralisation.

\begin{definition}[Dynamic Algebra]\label{def:rlstar}
The  algebra is defined over symbols in
, where  is a natural number.
A word of its alphabet, called \textit{weight}, is generated by an unary 
\textit{inversion} operator  and a binary \textit{concatenation} 
operator with infix implicit notation.
The concatenation operator is a monoid, whose identity element is , and 
whose absorbing element is  (cf. \autoref{fig:rlstar:monoid}).
Moreover, the inversion operator is idempotent and involutive for concatenation
(cf. \autoref{fig:rlstar:conc-inv}), and satisfies the neutralisation and 
two annihilation equations in \autoref{fig:rlstar:neutr-ann}.
\end{definition}

\begin{figure}
  \vspace{0.3em}
  \begin{subfigure}{0.28\textwidth}
    \caption{Monoid rules.}
    \label{fig:rlstar:monoid}
    \vspace{-1.5em}
    
  \end{subfigure}
  \hfill
  \begin{subfigure}{0.23\textwidth}
    \caption{Inversion rules.}
    \label{fig:rlstar:conc-inv}
    \vspace{-1.5em}
    
  \end{subfigure} 
  \hfill
  \begin{subfigure}{0.28\textwidth}
    \caption{Computation rules.}
    \label{fig:rlstar:neutr-ann}
    \vspace{-1.5em}
    
  \end{subfigure}
  \caption{The  algebra.}
\end{figure}

\begin{definition}[Weighting]\label{def:RIN:weight}
  The \textit{permuted base weighting} is a map 
  from a unitary straight path 
    and a resource permutation 
  to a weight of , written as .
  
  Straightness of the unitary path  implies that  goes either:
  (i) from a premise vertex to a conclusion one, i.e. crossing a link in one of 
  the five possible ways that are covered by the first five clauses;
  (ii) vice versa, from a conclusion vertex to a premise one, covered by the 
  last clause.\\
  The \textit{permuted weighting} is the lifting of the permuted base weighting 
  to generic straight paths, and the \textit{path weighting} is the sum of all 
  the permuted weights of a path, for any resource permutation:
  
\end{definition}

\begin{definition}[Execution]
\label{def:RIN:path:compr}
A path  is \textit{regular} if .
The \textit{execution} of a net , is defined as:

\end{definition}

\begin{example}\label{ex:exec}
Consider the again the closed net , whose reduction has been discusssed 
in previous \autoref{ex:nets}, and that is depicted in the leftmost extremity 
of 
\autoref{fig:ex2}.
To have an idea of the execution of  and of the behaviour of the 
algebra, let us consider an execution comprehensive path, one of the 
persistent two, and compute its weight.
Given that the path is palindromic, i.e. has the form , we 
will consider only its first half, that goes from the root of the term to the 
constant.
Moreover we will break lines when a path invert its polarity direction, i.e. if 
it walks from  to  or viceversa.
-2ex]
  &
    w_1,v_3,v_2,
  &&
    p\ e_{\sigma(2)}\ e^*_1\cdot
  \\
  &
    v_4,v_5,v_6,v_3,z_1,z_2,z_3,
  &&
    p^*\ e^*_1\ q\ e_2\ e^*_{\sigma(1)}\ q^*\ e_1 \cdot
  \\
  &
    z_1,v_3,v_6,
  &&
    p\ e_{\sigma(1)}\ e^*_2\ \cdot
  \\
  &
    v_7,v_8)
  &&
    p^*\ e^*_1\ \star
  \\
\intertext{On the path: reduce it using the exponential rule.
  On the weight:
  apply \autoref{eq:rlstar:annihil:exp} and then \ref{eq:lstar:zero}
  on the addend s.t. ,
  apply \autoref{eq:lstar:neutr} and then \ref{eq:lstar:one}
  on the one s.t. .}
  \reduce\ (&
    v_1,v_2 \eqtd w_1,w_2,w_3,
  &=_{\rlstar}\ &
    q\ q^*\ e_1 \cdot
  \\
  &
    w_1 \eqtd v_2,
  &&
    p\ \cdot
  \\
  &
    v_4,v_5,v_6 \eqtd z_1,z_2,z_3,
  &&
    p^*\ e^*_1\ q\ q^*\ e_1 \cdot
  \\
  &
    z_1 \eqtd v_6,
  &&
    p\ \cdot
  \\
  &
    v_7,v_8)\;+
  &&
    p^*\ e^*_1\ \star \;+
 \\
  &
    0
  &&
    0
\intertext{Forget zeros on both side.
  On the path: reduce it using the leftmost linear implication rule.
  On the weight: apply \autoref{eq:lstar:neutr} and then \ref{eq:lstar:one}.}
  \reduce\ (&
    v_1 \eqtd w_2,w_3 \eqtd v_4, v_5,v_6 \eqtd z_1,z_2,z_3,
  &=_{\rlstar}\ &
    e_1 e^*_1\ q\ q^*\ e_1 \cdot
  \\
  &
    z_1 \eqtd v_6,
  &&
    p\ \cdot
  \\
  &
    v_7,v_8)
  &&
    p^*\ e^*_1\ \star
 \\
\intertext{On the path: reduce it using the linear implication rule.
  On the weight: apply \autoref{eq:lstar:neutr} and then \ref{eq:lstar:one}.}
  \reduce\ (&
    v_1 \eqtd w_2,w_3 \eqtd v_4,v_5 \eqtd z_2,z_3 \eqtd v_7,v_8)
  &=_{\rlstar}\ &
    e_1\ e^*_1\ e_1\ e^*_1\ \star
\\
\intertext{On the path: reduce it twice using exponential rules.
  On the weight: apply \autoref{eq:lstar:neutr} and then \ref{eq:lstar:one}, 
  and repeat.}
  \reduce\ (&
    v_1 \eqtd w_2 \eqtd v_5 \eqtd z_2,z_3 \eqtd v_7,v_8)
  &=_{\rlstar}\ &
    e_1\ e^*_1\ \star
\\
  \reduce\ (&
    v_1 \eqtd w_2 \eqtd v_5 \eqtd z_2 \eqtd v_8)
  &=_{\rlstar}\ &
    \star

    \weight{\pi}
    &= \sum_{\permnet\in\permnets}
      \permweight{\permnet}{\pi_0}\ 
      \permweight{\permnet}{\chi_1}\ 
      \permweight{\permnet}{\pi_1}\ 
      \ldots
      \permweight{\permnet}{\chi_k}\ 
      \permweight{\permnet}{\pi_k}\ 
    \\
    &= \sum_{\permnet\in\permnets}
      \permweight{\permnet}{\pi_0}\ 
      \permweight{\permnet}{\pi_1}\ 
      \ldots
      \permweight{\permnet}{\pi_k}\ 
    \\
    &= \weight{\rho(\pi)}
    
     \weight{\pi}
&= \sum_{\permnet'\in\permnets'} \permweight{\permnet'}{\pi}\ +\ 
        \sum_{\permnet''\in\permnets''} \permweight{\permnet''}{\pi}
      \\
      &=
        \sum_{\permnet'\in\permnets'}
          \permweight{\permnet'}{\pi_0}\ 
          \permweight{\permnet'}{\chi_1}\ 
          \permweight{\permnet'}{\pi_1}\ 
          \ldots\ 
          \permweight{\permnet'}{\chi_k}\ 
          \permweight{\permnet'}{\pi_k}\ 
        \ +\\
        &\phantom{=\ }
        \sum_{\permnet''\in\permnets''}
          \permweight{\permnet''}{\pi_0}\ 
          \permweight{\permnet''}{\chi_1}\ 
          \permweight{\permnet''}{\pi_1}\ 
          \ldots\ 
          \permweight{\permnet''}{\chi_k}\ 
          \permweight{\permnet''}{\pi_k}
      \text{.}
    \intertext{
      In the leftmost series, by \autoref{eq:lstar:neutr},
      .
      While in the rightmost, by \autoref{eq:rlstar:annihil:exp},
      ,
      so it neutralises to .
      Therefore we concluded:
    }
      &=_\rlstar
        \sum_{\permnet'\in\permnets'}
          \permweight{\permnet'}{\pi_0}\ 
          \permweight{\permnet'}{\pi_1}\ 
          \ldots\ 
          \permweight{\permnet'}{\pi_k}
      \\
      &= \weight{\rho(\pi)}
      \text{.}
    
  \end{enumerate}
\end{enumerate}
\vspace{-1.5em}
\end{proof}

\begin{lemma}\label{lem:RIN:weight-inv:seq}
For any closed simple net ,
any reduction sequence , and
any path :
\begin{itemize}
  \item , \  and \ 
    ; or
  \item , \ and \ 
    .
\end{itemize}
\end{lemma}

\begin{proof}
A straightforward induction on the length  of the sequence .
\begin{enumerate}
\item \textit{Base.}
  Suppose .
  Trivially, , so .
\item \textit{Step.}
  Suppose .
  Let , with 
     a single step,
     a sequence.
  \begin{enumerate}
  \item If both  and , then, by 
    \autoref{def:RIN:path-red} of path reduction, 
    .
    In this case, by previous \autoref{lem:RIN:weight-inv},
    .
    But, by inductive hypothesis we have that
     
    so we conclude.
  \item Otherwise  or  are zero.
    \begin{enumerate}
    \item If , then by definition of path 
      reduction, .
      But by inductive hypothesis, , that is our 
      thesis.
    \item Otherwise  while .
      Then  and, again by previous \autoref{lem:RIN:weight-inv}, 
      .
      Hence, the thesis.
    \end{enumerate}
\end{enumerate}
\end{enumerate}
\end{proof}

\begin{theorem}
\label{thm:RIN:regular}
For any closed net , a path  is 
persistent if and only if  is regular.
\end{theorem}
\begin{proof}
  Immediate from \autoref{lem:RIN:weight-inv:seq}.
\end{proof}

\begin{theorem}
\label{thm:RIN:weight-inv}
For any closed net  and any reduction sequence
, .
\end{theorem}

\begin{proof}
  Consider a pair  of paths respectively belonging to 
  .
  Recall that, thanks to \autoref{thm:RIN:path-red:bij},
  there is a bijection between the two, so it does not matter which we choose 
  first.
  \begin{enumerate}
  \item
    If  are not persistent, there is nothing left to prove, 
    for their weights are both , as proven
    by \autoref{lem:RIN:weight-inv:seq},
    and consequently they are neutral with respect to both
    .
  \item
    Otherwise  are persistent,
    so they both are regular.
    Moreover, once again by \autoref{lem:RIN:weight-inv:seq},
    .
    Hence the thesis.
  \end{enumerate}
\vspace{-1.5em}
\end{proof}

\begin{corollary}
\label{cor:RIN:path-red:number}
  For any term , regular paths in 
   are as many as (non-zero) addends in .
\end{corollary}
\begin{proof}
  By definition of the calculus and of its nets syntax,
  , for some natural number .
  Clearly,  contains a unique path, bouncing on the 
  unique vertex of .
  Then .
  But from last \autoref{thm:RIN:weight-inv},
  ,
  therefore the thesis.
\end{proof}

\section*{Conclusion}

\paragraph{Summary}
We studied the notion of path persistence in a restriction of the Resource 
Calculus (RC) showing that, in spite of the non-determinism,
the reduction induces a bijection between paths.
We defined a proper Geometry of Interaction construction that:
characterises persistence by an algebra of weights, which are 
non-deterministically assigned to paths;
is invariant under reduction;
accurately counts addends of normal forms.
In the restricted setting where we are placed, the formulation is 
considerably simpler and stronger with respect to similar works.

\paragraph{Further research} 
Future investigations may easily extend the minimalist formulation from RC to 
a PCF-like resource calculus, where the restriction to ground types remains 
innocuous although allowing a real-programming-language-class expressivity.
Directions of ongoing investigation by the author includes 
the study of the connection between Taylor-Ehrhard expansion and GoI, 
exploiting the resource construction hereby presented.
This could offer a technique to represent approximations of 
infinite, but still meaningful, paths in a -term,
as in the spirit of B\"{o}hm trees.
Indeed, paths, expansion and B\"{o}hm trees, they all intimately share a 
particular strategy of computation, that is the head reduction.
Lastly, a deep study of paths in presence of both superposition 
and duplication, i.e. in the full differential -calculus,
is still missing.
In such a case, the shape of persistent crossings of an exponential redex 
does not necessarily respect the definition we gave by mean of fixed 
permutations, because different copies of the redex may want different 
resource assignments.