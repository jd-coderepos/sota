\documentclass[12pt]{article}
\usepackage{color,epsfig,citesort,amsmath,fullpage}
\usepackage{algorithm}
\usepackage{algorithmic}


\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

\def\myendproof{{\hfill \vbox{\hrule\hbox{\vrule height1.3ex\hskip0.8ex\vrule}\hrule }}\par}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newenvironment{proof}{{\it Proof. }}{\myendproof}



\newcommand{\algo}[1]{\mbox{\sf{#1}}}
\newcommand{\setof}[1]{\{{#1}\}}
\newcommand{\Xomit}[1]{}



\title{{\bf Linear-Time Algorithms for the Paired-Domination Problem in Interval Graphs and Circular-Arc Graphs}}
\author{Ching-Chi Lin\thanks{Department of Computer Science and Engineering,
                             National Taiwan Ocean University,
                             Keelung 20224, Taiwan. Corresponding author.
                             Email: lincc@mail.ntou.edu.tw}
        \and
        Hai-Lun Tu\thanks{Department of Computer Science and
                          Information Engineering,
                          National Taiwan University,
                          Taipei 10617, Taiwan.
                          Email:d95019@csie.ntu.edu.tw}
        }

\date{\today}

\begin{document}
\maketitle

\begin{abstract}
In a graph , a vertex subset  is said to be a
dominating set of  if every vertex not in  is adjacent to a
vertex in . A dominating set  of a graph  is called a
paired-dominating set if the induced subgraph  contains a
perfect matching. The paired-domination problem involves finding a
smallest paired-dominating set of . Given an intersection model
of an interval graph  with sorted endpoints, Cheng~{\em et
al.}~\cite{CKN07} designed an -time algorithm for interval
graphs and an -time algorithm for circular-arc graphs.
In this paper, to solve the paired-domination problem in interval
graphs, we propose an -time algorithm that searches for a
minimum paired-dominating set of  incrementally in a greedy
manner. Then, we extend the results to design an algorithm for
circular-arc graphs that also runs in  time.

\bigskip

\noindent \textbf{Keywords:} paired-domination problem, perfect
matching, interval graph, circular-arc graph.


\end{abstract}

\newpage

\def\skippt{23pt}
\baselineskip \skippt

\section{Introduction}\label{section:intro}
The museum protection problem can be accurately represented by a
graph . The vertex set of , denoted by ,
represents the sites to be protected; and the edge set of ,
denoted by , represents the set of protection capabilities.
There exists an edge  connecting vertices  and  if a
guard at site  is capable of protecting site  and vice
versa. In the classical domination problem, it is necessary to
minimize the number of guards such that each site has a guard or
is in the protection range of some guard. For the
paired-domination problem, in addition to protecting the sites,
the guards must be able to back each other up~\cite{HS98}.
Throughout this paper, we let  and .

In a graph , a vertex subset  is said to be a
{\em dominating set} of  if every vertex not in  is adjacent
to a vertex in . A dominating set  of a graph  is called
a paired-dominating set if the induced subgraph  contains a
perfect matching. The paired-domination problem involves finding a
smallest paired-dominating set of . Haynes and
Slater~\cite{HS98} defined the paired-domination problem and
showed that it is NP-complete in general graphs. More recently,
Chen~{\em et al.}~\cite{Chen10} demonstrated that the problem is
also NP-complete in bipartite graphs, chordal graphs, and split
graphs. Panda and Pradhan~\cite{Panda12} strengthened the above
results by showing that the problem is NP-complete for perfect
elimination bipartite graphs. In addition, McCoy and
Henning~\cite{McCoy09} investigated variants of the
paired-domination problem in graphs.



Meanwhile, several polynomial-time algorithms have been developed
for some special classes of graphs such as tree graphs, interval
graphs, strongly chordal graphs, and circular-arc graphs.
Qiao~{\em et al.}~\cite{QKCD03} proposed an -time algorithm
for tree graphs; Kang~{\em et al.}~\cite{KSC04} presented an
-time algorithm for inflated trees; Chen~{\em et
al.}~\cite{Chen09} designed an -time algorithm for
strongly chordal graphs; and Cheng~{\em et al.}~\cite{CKS09}
developed an -time algorithm for permutation graphs. To
improve the results in~\cite{CKS09}, Lappas~{\em et
al.}~\cite{Lappas09} introduced an -time algorithm. In
addition, Hung~\cite{Hung12} described an -time algorithm
for convex bipartite graphs; Panda and Pradhan~\cite{Panda12}
proposed an -time algorithm for chordal bipartite graphs;
Chen~{\em et al.}~\cite{Chen10} introduced -time
algorithms for block graphs and interval graphs; and Cheng~{\em et
al.}~\cite{CKN07} designed an -time algorithm for interval
graphs and an -time algorithm for circular-arc graphs.
In this paper, given an intersection model of interval graph 
with sorted endpoints, we improve the above results with time
complexity  for interval graphs and circular-arc graphs.


Several variants of the classic domination problem, such as the
weighted domination, edge domination, independent domination,
connected domination, locating domination, and total domination
problems, have generated a great deal of research interest in
recent decades~\cite{Chang04,Haynes98,Haynes98-2,Hedetniemi91}. It
has been proved that the above problems are NP-complete in general
graphs but they yield polynomial-time results in some special
classes of
graphs~\cite{Bertossi88,D'Atri88,Chang97,Lu02,Ramalingam88,Chang98}.
In particular, these variants have been studied  intensively in
interval and circular-arc graphs~\cite{Ramalingam88,Chang98}.

For weighted interval graphs, Ramalingam and
Rangan~\cite{Ramalingam88} proposed a unified approach to solve
the independent domination, domination, total domination and
connected domination problems in  time. Subsequently,
Chang~\cite{Chang98} developed an -time algorithm for the
independent domination problem, an -time algorithm for the
connected domination problem and an -time
algorithm for the total domination problem in weighted interval
graphs. The author also extended the results to derive
-time algorithms for the same problems in circular-arc
graphs. Moreover, Hsu and Tsai~\cite{HT91} developed an
-time algorithm for the classic domination problem in
circular-arc graphs. The algorithm, which utilizes a greedy
strategy, motivated the algorithms proposed in this paper. Note
that all the above algorithms assume that an intersection model of
 with sorted endpoints is given.

In this paper, we show that the paired-domination in interval
graphs and circular-arc graphs is solvable in linear time. More
precisely, given an intersection model of a circular-arc graph 
with sorted endpoints, we propose an -time algorithm that
produces a minimum paired-dominating set of . Moreover, because
circular-arc graphs are a natural generalization of interval
graphs, the paired-domination problem in the latter can also be
solved in  time.

The remainder of this paper is organized as follows. In
Section~\ref{section:algo-interval}, we introdece an -time
algorithm for interval graphs; and in
Section~\ref{section:algo-cir}, we extend the result to derive an
-time algorithm for circular-arc graphs.
Section~\ref{section:conclusion} contains some concluding remarks.


\section{The Proposed Algorithm for Interval Graphs
                              \label{section:algo-interval}}
To find a minimum paired-dominating set of an interval graph ,
we designed an -time algorithm that derives the set
incrementally in a greedy manner. Before describing the approach
in detail, we introduce some preliminaries for interval graphs.

\bigskip
\begin{figure}[thb]
\centerline{\begin{picture}(0,0)\includegraphics{fig-1.eps}\end{picture}\setlength{\unitlength}{3947sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(7245,2070)(-22,-1771)
\put(831,-297){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2476,164){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2780,-1024){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5386,-811){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5911,-1261){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5611,-1711){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4861,-1261){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5086,-61){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4261,-286){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5911,164){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6586,164){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1501,-1711){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1589,-660){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(397,-660){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(397,-1024){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1806,-1024){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2130,-297){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} } \caption{ A family of intervals on
a real line.  The corresponding interval graph  for the
family of intervals in .} \label{fig:1}
\end{figure}

A graph  is deemed an {\em interval graph} if there is a
one-to-one correspondence between its vertices and a family of
intervals, , on a real line, such that two vertices in the
graph have an edge between them if and only if their corresponding
intervals overlap. Interval graphs have received considerable
attention because of their application in the real world. Booth
and Lueker~\cite{Booth76} designed an algorithm that can recognize
interval graphs in  time. As a byproduct, an
intersection model  of an interval path graph  can be
constructed in  time. In the remainder of this section,
we assume that  is an interval graph with , where . We also assume that an
intersection model  is available to , as shown by the examle
in Figure~\ref{fig:1}, where Figure~\ref{fig:1} depicts the
corresponding interval graph  for the family of intervals in
Figure~\ref{fig:1}.

The {\em neighborhood}  of a vertex  is the set of all
vertices adjacent to  in ; and the {\em closed neighborhood}
. For each , let 
denote the corresponding interval of  in . Each interval is
represented by , where  and  are,
respectively, the {\em left endpoint} and the {\em right endpoint}
of . It is assumed that the left endpoint  is on
the left of the left endpoint  for all . Without loss of generality, we assume that all interval
endpoints (i.e.,  and ) are distinct. In addition,
each interval endpoint is assigned a positive integer between 
and  in ascending order in a left-to-right traversal. For any
two endpoints  and ,  is said to be lower than ,
denoted by ``", if its label is lower than the label of
, i.e.,  lies on the left of  in ; otherwise,  is
said to be greater than or equal to , denoted by ``".


\subsection{The algorithm
                              \label{section:outline-algo-int}}
As mentioned earlier, our algorithm for finding a minimum
paired-dominating set of an interval graph utilizes a greedy
strategy. With -time preprocessing, the algorithm traverses
the intersection mode  of an interval graph  from left to
right exactly once. For a subset , a vertex 
in  is said to be the {\em next undominated} vertex with
respect to  if  has the leftmost right endpoint among the
corresponding intervals of the vertices that are not in  or
adjacent to any vertex in . For each , let the {\em
partner} of , denoted by , be the neighbor of  such
that  has the rightmost right endpoint in  among the
corresponding intervals of . For the example of
Figure~\ref{fig:1}, we have , ,
and . Initially, we set . Then, the
algorithm iteratively finds the next undominated vertex  with
respect to  and adds a pair  to  until every
vertex not in  is adjacent to a vertex in . The steps of the
algorithm are detailed in Algorithm 1.

\vspace{0.5pt}
\begin{algorithm}
\caption{Finding a minimum paired-dominating set in an interval
graph}
\begin{algorithmic} [1]
\REQUIRE An intersection model  of an interval graph
 with sorted endpoints.
\ENSURE A minimum paired-dominating set  of
.
\STATE let ;
\REPEAT
\STATE find the next undominated vertex  with
respect to ;
\STATE let ;
\UNTIL every vertex not in  is adjacent to a vertex
in 
\RETURN ;
\end{algorithmic}
\end{algorithm}

For the example in Figure~\ref{fig:1}, the algorithm generates a
minimum paired-dominating set  of . In
the following, we demonstrate the correctness of the algorithm;
and then describe an -time implementation of the algorithm
in the next subsection. First, we introduce some necessary
notations. Let  denote the subgraph of  induced by a
subset  of ; and let  represent
the set of all vertices adjacent to  in . In addition, let  be the vertex
in  such that  is the first left endpoint
encountered in a left-to-right traversal from  in . For
the example in Figure~\ref{fig:1}, we have ,
,  and
.

\vspace{-2pt}

\begin{lemma}\label{lemma:partial_dom}
If  and , we have
\\  \quad for .
\end{lemma}

\vspace{-2pt}

\begin{proof}
By the definition of , we have
. For the case where
, the segment  is contained
in . This implies that if , we also
have . The arguments are similar in the
case where .
\end{proof}

\vspace{-2pt}

\begin{lemma} \label{lemma:interval-correctness}
Given an intersection model  of an interval graph  with
sorted endpoints, Algorithm  outputs a minimum
paired-dominating set  of .
\end{lemma}

\vspace{-2pt}

\begin{proof}
Suppose that the algorithm outputs , where  and 
are added to  in the th iteration. Clearly,  is a
paired-dominating set of . We prove that  is a minimum
paired-dominating set of  as follows. Let  be a minimum
paired-dominating set of  such that  is a perfect matching of  and
 for . In addition, let  and . For a subset
, we define that 
. To
prove that  is a minimum paired-dominating set of , it is
sufficient to show that  for .

We prove the above statement by induction on . By the
definitions of the next undominated vertex and , the
statement holds for , and we assume the statement holds for
. Consider the case where . Let  be the next
undominated vertex with respect to . Clearly, . First, we consider the case where . By the definition of , we have
. Next, we consider the case where . According to
Lemma~\ref{lemma:partial_dom}, we have
. It follows that  in both cases, so . By the definition of
, we have ; thus, . The lemma then follows.
\end{proof}


\subsection{An -time implementation of Algorithm 
                              \label{section:implement-int}}
For each , let  denote the vertex in
 whose corresponding right endpoint is the first
right endpoint encountered in a left-to-right traversal from
 in . The algorithm traverses the intersection mode 
of an interval graph  from left to right exactly once.
Therefore, to prove that the algorithm runs in  time, it
suffices to show that, with preprocessing in  time, the
algorithm takes  time to determine  and 
for . In the following, we describe two -time
preprocessing procedures used to determine all  and
, respectively.

To obtain , we traverse the endpoints of  from left to
right and maintain a variable  that represents the
interval containing the rightmost endpoint in the current stage.
Initially, we set . When a left endpoint
 is visited, we compare  with .
If , we set ; otherwise,
we do nothing. When a right endpoint  is visited, we set
. Because there are  endpoints in , the
procedure can be completed in  time.

Next, we describe the -time procedure used to determine
. Let  be the vertex in  such that
 is the first left endpoint encountered in a
left-to-right traversal from  in . In addition, let
 be the vertex in  such that  is the
first right endpoint encountered in a left-to-right traversal from
 in  with . Then,  can be seen
as the composite function of  and , i.e., . The following discussion shows that, with -time
preprocessing,  and  can be determined in 
time.

First, we describe an -time procedure to determine 
for each . Again, we traverse the endpoints of 
from left to right and maintain a set . Initially, we set . When a right endpoint  is visited, we add
 to ; and when a left endpoint  is visited, we
set  for each vertex  in  and set  to be
empty. The arguments for determining  are similar. If we
reach a left endpoint , we insert  into the queue
. When we find a right endpoint , we set 
and remove  from the queue for all  with .
Because there are  endpoints in , the above two procedures
can also be completed in  time.

Combining Lemma~\ref{lemma:interval-correctness} and above
discussion, we have the following theorem, which is one of the key
results presented in this paper.

\begin{theorem} \label{theorem:interval} Given an intersection
model  of an interval graph  with sorted endpoints,
Algorithm 1 outputs a minimum paired-dominating set  of  in
 time.
\end{theorem}



\section{The Algorithm for Circular-arc Graphs
                              \label{section:algo-cir}}


In this section, we extend the previous results to derive an
-time algorithm for finding a minimum paired-dominating
set in a circular-arc graph. The algorithm also exploits a greedy strategy. A graph  is deemed a {\em circular-arc graph} if there is a one-to-one correspondence between  and a set of arcs on a circle such that  if and only if the corresponding arc of  overlaps with the corresponding arc of . An {\em intersection model} of  is a circular ordering of its corresponding arc endpoints when moving in a counterclockwise direction around the circle. McConnell~\cite{McConnell03} proposed an -time algorithm that recognize a circular-arc graph , and simultaneously obtains an intersection model of  as a byproduct. In the following discussion, we assume that   is a circular-arc graph such that  with ; and  the intersection mode  of  is available.

\hspace{1pt}

\begin{figure}[thb]
\centerline{\begin{picture}(0,0)\includegraphics{fig-2.eps}\end{picture}\setlength{\unitlength}{3947sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(5994,3026)(71,-2184)
\put(4929,-2124){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2150,-365){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1621,-907){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1183,477){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1772,-84){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1236,-104){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(842,-34){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(388,-147){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2417,-636){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1164,-1316){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1190,-2124){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2400,570){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(190,-969){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1105,-667){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6047,-769){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4815, 21){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5714,-158){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5450,-1576){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4808,-410){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5101,-655){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4151,166){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4343,-1502){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3776,-539){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4889,661){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5652,452){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} } \caption{ A family of arcs on a
circle.  The corresponding circular-arc graph  for the
family of arcs in .} \label{fig:2}
\end{figure}

For each , let  denote the corresponding arc of
 in . Each arc is represented by , where
 is the {\em head} of ,  is the {\em tail} of
, and  precedes  in a clockwise direction.
Moreover, for any subset  of , we define . It is assumed that all  and  are distinct and no single arc in  covers the whole circle. All endpoints are assigned positive integers between  and
 in ascending order in a clockwise direction.

In addition, we assume that . We also
assume that  is chosen arbitrarily from ; and we let
 be the ordering of arcs in
 such that  is encountered before 
in a clockwise direction from  if .
Figure~\ref{fig:2} shows an illustrative example, in which
Figure~\ref{fig:2} depicts the corresponding circular-arc
graph  for the family of arcs in Figure~\ref{fig:2}.
An ordering of the family of arcs is also provided. For
each , let the {\em tail partner} of , denoted by
, be the neighbor of  such that  contains ; and  is the last tail encountered in clockwise direction from  in . Similarly, let the {\em head partner} of , denoted by , be the neighbor of  such that  contains ; and  is the last head encountered in a counterclockwise direction from  in . For the example in Figure~\ref{fig:2}, we have , , , and .

\subsection{The Algorithm
                              \label{section:outline-algo-arc}}
The algorithm for finding a minimum paired-dominating set of a
circular-arc graph  is similar to the algorithm for interval graphs. An arc is {\em maximal} if it is not contained in any other arc of . Suppose  is the set of neighbors, , of  such that  is a maximal arc in , i.e., ~and~~is a maximal arc in~. Then, we can show that there exists a minimum paired-dominating set  of  such that . If , we are done. Otherwise, let  be a vertex in
 and  be a vertex in  such that 
contains  in . Clearly,  is also a minimum paired-dominating set of .

Based on the above observation, we designed a two-step algorithm
for circular-arc graphs. First, the algorithm computes a paired-dominating set  for each vertex , where  is a minimum paired-dominating set among all paired-dominating sets that contain . Then, a minimum paired-dominating set  of  is chosen from  with . To find , the
algorithm traverses the intersection mode  of a circular-arc
graph  in a clockwise direction. Lemma~\ref{lemma:initial-pair} below proves that there exists a minimum
paired-dominating set  such that we have  or . With the aid of the lemma, the
algorithm first computes two paired-dominating sets  and
 that contain the vertices  and
 respectively. If ,
we have ; otherwise, we have .

To explain the algorithm, we define some notations.
Let  be an ordering of vertices in  such
that  is the last head encountered in a counterclockwise
direction from  in  and 
immediately succeeds  in a clockwise direction for . For a subset , we define . In addition, a
vertex  in  is said to be the {\em next undominated}
vertex with respect to  if  is the first tail encountered
in a clockwise direction from .

Initially, the algorithm sets  and
. Then, it iteratively finds
the next undominated vertex  with respect to
 () and adds two vertices to  () until
every vertex not in  () is adjacent to a vertex in
 (). If , we have
; otherwise, we have . Finally, the algorithm selects a minimum paired-dominating set  of  from
 such that the cardinality of  is the minimum. The steps of the algorithm are detailed below.

\medskip

\begin{algorithm}
\caption{Finding a minimum paired-dominating set in a circular-arc
graph}
\begin{algorithmic} [1]
\REQUIRE An intersection model  of a circular-arc graph
 with sorted endpoints.
\ENSURE A minimum paired-dominating set  of
.

\STATE let  and  is maximal\};
\STATE let ;
\FOR  {each vertex }
\STATE let  and ;
\REPEAT
\STATE find the next undominated vertex  with respect to ;
\STATE if , then let ;
\STATE otherwise, let ;
\UNTIL every vertex not in  is adjacent to a vertex in 
\STATE repeat steps  to  to obtain  by replacing  with ;
\STATE if , then let ; otherwise, let ;
\ENDFOR \STATE choose  from  such that the cardinality of  is the minimum;
\RETURN 
\end{algorithmic}
\end{algorithm}



For the example in Figure~\ref{fig:2}, the
closed neighborhood of  is 
and we have . Then, by the
rules for finding  and  in Steps  to , we
have , , ,  , , and . Consequently, Step  determines the sets , , and . Finally, Step
 generates , which is a
minimum paired-dominating set of .

The properties of the following lemma are useful for finding a
minimum paired-dominating set and help us prove the correctness
of the algorithm.

\begin{lemma}\label{lemma:initial-pair}
Suppose  is a maximal arc in  and  is a minimum
paired-dominating set of  among all the paired-dominating sets
that contains . Then, there exists a minimum paired-dominating set  such that we have  or .
\end{lemma}
\begin{proof}
If  or , we are done;
otherwise, we assume that neither  nor . Furthermore, let  be a vertex in  such that a
perfect matching in  contains the edge . Note
that  is a maximal arc in . Hence, for each vertex , we have  or . For the case where , it is clear that  is a minimum paired-dominating set of . Similarly,
for the case where , it isclear that  is a
minimum paired-dominating set of . The lemma then follows.
\end{proof}

\bigskip

Based on Lemma~\ref{lemma:initial-pair}, we are ready to prove
the following lemma, which provides the correctness of the
algorithm.

\begin{lemma}\label{lemma:Circular-arc-2}
Given an intersection model  of a circular-arc graph  with
sorted endpoints, Algorithm 2 outputs a minimum paired-dominating
set  of .
\end{lemma}
\begin{proof}
Clearly,  is a paired-dominating set of . To prove that
 is a minimum paired-dominating set of , it suffices to show
that, for each vertex ,  is a minimum paired-dominating set of  among all the paired-dominating sets that contain . According to Lemma~\ref{lemma:initial-pair}, there exists a minimum paired-dominating set  of  among all the
paired-dominating sets containing  such that we have
 or . Below, we only show that
the cardinality of  is the minimum when . The
proof for the case where  is similar.

Let  be
a paired-dominating set of  such that , and let the vertices  and
 be added to  in the th iteration of the
repeat-loop for . In addition, let  be a minimum paired-dominating set of  such that  is a perfect matching of  and
 for ; let ; and . For a subset
 and a vertex , we define that   . Hence, to prove that  is a minimum
paired-dominating set of  among all the paired-dominating sets
contain , it suffices to show that  for . Clearly, the above statement can
be proved by induction on . We omit the details of the proof
because they are similar to the arguments used to derive
Lemma~\ref{lemma:interval-correctness}.
\end{proof}

\medskip
\subsection{An -time implementation of Algorithm 
                              \label{section:implement-arc}}
The procedure for finding  can be implemented in  time
by modifying Algorithm  for interval graphs. Therefore, a naive
implementation of algorithm  has a time complexity of 
with . However, by exploiting the elegant properties of
circular-arc graphs, we can design a useful data structure that
helps us find all paired-dominating sets  in
 time. Hence, the time complexity of the algorithm for
finding a minimum paired-dominating set of a circular-arc graph
can be improved to .

To find a minimum paired-dominating set  in , algorithm 
first obtains the paired-dominating sets
 and . Then,
the set  with the minimum cardinality is chosen from the sets.
In the following, we only consider an -time implementation
for finding all the paired-dominating sets
. Using a similar method, it can can be
shown that  can also be obtained in
 time. For simplicity, we denote  and  by
 and  respectively, in the remainder of this section.

For each vertex , the algorithm constructs a
paired-dominating set  containing  and . Suppose
that , where , and that the vertices  and
 are added to  in the th iteration of the
repeat-loop for . In addition, let
 and
 be
two paired-dominating sets of  such that . It is clear that if , then 
, where . Based on the
above observation, we define a digraph  to improve the
complexity of the algorithm from  to .

\vspace{14pt}


\begin{figure}[htb]
\centerline{\begin{picture}(0,0)\includegraphics{fig-3.eps}\end{picture}\setlength{\unitlength}{3947sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(3212,2066)(143,-1625)
\put(3340,-562){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(430,-562){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(430,263){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1375,263){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1375,-562){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1375,-1387){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2320,263){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2320,-1387){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2320,-562){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3340,263){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(430,-1387){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} } \caption{The corresponding digraph 
for the circular-arc graph  in Figure~\ref{fig:2}.}
\label{fig:3}
\end{figure}


Recall that a vertex  in  is deemed the next
undominated vertex with respect to a subset  if
 is the first tail encountered in a clockwise direction from
. We define  for
, where  is the next undominated vertex with respect
to . Let  be a digraph such that

\vspace{-30pt}


\noindent Figure~\ref{fig:3} shows an example of the corresponding
digraph  for the circular-arc graph  in
Figure~\ref{fig:2}.

Next, we show that the graph  is a directed forest graph that
can be constructed in  time. By the definition of ,
there exists no vertex  in  such that the in-degree
of  is greater than or equal to ; and
. Meanwhile, because
every cycle  in  must contain
such a vertex ,  is a directed forest graph.
The -time procedure used to construct  is as follows.
Using similar arguments to those presented in
Section~\ref{section:implement-int}, it can be shown that, with
-time preprocessing,  and  can be
determined in  time for each vertex . Moreover,
because the out-degree of each vertex in  is at most one and
, the digraph  can be constructed in  time.

Let  denote the maximal directed path in  starting from
 for each vertex , and let . The next lemma provides an
important property that can be used to derive the
paired-domination sets  from maximal directed path  for .

\begin{lemma}\label{lemma:implementation-2}
Suppose that  is the maximal directed path in  starting
from  and . Then, we have  and
 for .
\end{lemma}
\begin{proof}
Because  is a directed forest graph, it is clear from the definitions of  and  that  . Suppose  such that  and  for .
Then, by the definition of , we can verify that the vertices
in  are dominated by , where
. This implies that we have
 as desired.
\end{proof}

\medskip

In the following, we show the paired-domination sets  can be obtained in  time by exploiting Lemma~\ref{lemma:implementation-2}. First, we determine whether or not the set  is a paired-domination set of  for . If the answer is positive, we set . Otherwise, we set  and augment  with the vertices  and  until  becomes a
paired-domination set of , where  is the next undominated
vertex with respect to . According to
Lemma~\ref{lemma:implementation-2}, the augmentation will occur twice at most. This implies that the augmentation can be
completed in  time for each vertex . Furthermore,
because  and the digraph  can be
constructed in  time, the paired-dominating sets
 can be obtained in  time. Now that 
is a directed forest, the length of  in  can be determined
in  time by running a depth first search algorithm on all
vertices  in  such
that the in-degree of  is equal to , where
 and . It
follows that a minimum paired-dominating set  of  can be
chosen from  in  time.


Combining Lemma~\ref{lemma:Circular-arc-2} and above discussion,
we have the following theorem.

\begin{theorem} \label{theorem:interval} Given an intersection
model  of a circular-arc graph  with sorted endpoints,
algorithm  outputs a minimum paired-dominating set 
of  in  time.
\end{theorem}

\section{Concluding Remarks  \label{section:conclusion}}
We have proposed two algorithms for the paired-domination problem in interval graphs and circular-arc graphs respectively. The algorithm for interval graphs produces a minimum paired-dominating set incrementally in a greedy manner. We extended the results to design the algorithm for circular-arc graphs. If the input graph is comprised of a family of  arcs, both algorithms can be implemented in  time. However, if the endpoints of the arcs are sorted, both algorithms only require  time. These results are optimal within a constant factor.

Finally, we consider some open questions related to the paired-domination problem. It would be interesting to investigate the weighted analogue of this problem, i.e., to compute a minimum weight paired-dominating set in which each vertex is associated with a weight. Furthermore, many optimization problems are NP-complete if they are defined on general graphs; and they are solvable in polynomial time if they are defined on some special classes of graphs, such as bounded treewidth graphs, co-comparability graphs, and distance-hereditary graphs. Therefore, it would also be interesting to design polynomial-time algorithms for these graph classes. In addition, it would be useful if we could develop a polynomial-time approximation algorithm for general graphs; or prove that the problem remains NP-complete in planar graphs and devise a polynomial-time approximation scheme for it.

\small
\bibliographystyle{abbrv}
\bibliography{PDom}
\end{document}
