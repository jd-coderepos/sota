\documentclass{article}



\usepackage[final]{nips_2017}



\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{natbib}
\bibliographystyle{abbrvnat}
\setcitestyle{authoryear,open={(},close={)}}
\usepackage[pdftex]{graphicx}

\usepackage{graphicx,picture}
\usepackage{mathtools}
\usepackage{amssymb,amsmath,amsthm}

\usepackage{subfigure}
\usepackage{sidecap}

\usepackage{tikz}
\def\checkmark{\tikz\fill[scale=0.4](0,.35) -- (.25,0) -- (1,.7) -- (.25,.15) -- cycle;} 

\usepackage{placeins}

\def\mba{\mathbf{a}}
\def\dR{\mathbb{R}}
\def\cA{\mathcal{A}}
\def\cM{\mathcal{M}}
\def\cP{\mathcal{P}}
\def\cS{\mathcal{S}}
\def\cT{\mathcal{T}}
\def\Qe{Q^{\rm exec}}


\def\argmax{\mathop{\arg\max}}
\def\argmin{\mathop{\arg\min}}

\newtheorem{definition}{Definition}
\newtheorem{proposition}{Proposition}
\newtheorem{remark}{Remark}

\def\E{{\mathbb E}} \def\R{{\cal R}}

\def\A{{\cal A}}
\def\B{{\cal B}}
\def\G{{\cal G}}
\def\O{{\cal O}}
\def\S{{\cal S}}
\def\R{{\cal R}}
\def\H{{\cal H}}
\def\T{{\cal T}}
\def\M{{\cal M}}
\def\C{{\cal C}}
\def\z{z}
\def\a{{\bf a}}
\def\bs{{\mathbf{s}}}
\def\ba{{\mathbf{a}}}
\def\bh{{\mathbf{h}}}



\definecolor{darkgreen}{RGB}{0,125,0}




\title{Value-Decomposition Networks For Cooperative Multi-Agent Learning}



\author{
  Peter Sunehag\\DeepMind\\sunehag@google.com \And Guy Lever\\DeepMind\\guylever@google.com \And Audrunas Gruslys\\DeepMind\\audrunas@google.com \And Wojciech Marian Czarnecki\\DeepMind\\lejlot@google.com \And Vinicius Zambaldi\\DeepMind\\vzambaldi@google.com
  \And Max Jaderberg\\DeepMind\\jaderberg@google.com \And Marc Lanctot\\DeepMind\\lanctot@google.com \And Nicolas Sonnerat\\DeepMind\\sonnerat@google.com \And Joel Z. Leibo\\DeepMind\\jzl@google.com \And Karl Tuyls\\DeepMind \& University of Liverpool\\karltuyls@google.com \And Thore Graepel\\DeepMind\\thore@google.com 
}

\begin{document}

\maketitle

\begin{abstract}
We study the problem of cooperative multi-agent reinforcement learning with a single joint reward signal. This class of learning problems is difficult because of the often large combined action and observation spaces. In the fully centralized and decentralized approaches, we find the problem of spurious rewards and a phenomenon we call the ``lazy agent'' problem, which arises due to partial observability.  We  address these problems by training individual agents with a novel value decomposition network architecture, which learns to decompose the team value function into  agent-wise value functions. We perform an experimental evaluation across a range of partially-observable multi-agent domains and show that learning such value-decompositions leads to superior results, in particular when combined with weight sharing, role information and information channels. 
\end{abstract}


\section{Introduction}


We consider the cooperative multi-agent reinforcement learning (MARL) problem \citep{panait05,Busoniu08MARL,TuylsW12}, in which a system of several learning agents must jointly optimize a single reward signal -- the \emph{team reward} -- accumulated over time. Each agent has access to its own (``local'') observations and is responsible for choosing actions from its own action set. Coordinated MARL problems emerge in applications such as coordinating self-driving vehicles and/or traffic signals in a transportation system, or optimizing the productivity of a factory comprised of many interacting components. More generally, with AI agents becoming more pervasive, they will have to learn to coordinate to achieve common goals.

Although in practice some applications may require local autonomy, in principle the cooperative MARL problem could be treated using a \emph{centralized} approach, reducing the problem to single-agent reinforcement learning (RL) over the concatenated observations and combinatorial action space. We show that the centralized approach consistently fails on relatively simple cooperative MARL problems in practice. We  present a simple experiment in which the centralised approach fails by learning inefficient policies with only one agent active and the other being ``lazy''. This happens when one agent learns a useful policy, but a second agent is discouraged from learning because its exploration would hinder the first agent and lead to worse team reward.\footnote{For example, imagine training a 2-player soccer team using RL with the number of goals serving as the team reward signal. Suppose one player has become a better scorer than the other. When the worse player takes a shot the outcome is on average much worse, and the weaker player learns to avoid taking shots \citep{HausknechtThesis}.} 

An alternative approach is to train \emph{independent learners} to optimize for the team reward. In general each agent is then faced with a non-stationary learning problem because the dynamics of its environment effectively changes as teammates change their behaviours through learning \citep{Laurent11}. Furthermore, since from a single agent's perspective the environment is only partially observed, agents may receive spurious reward signals that originate from their teammates' (unobserved) behaviour. Because of this inability to explain its own observed rewards naive independent RL is often unsuccessful: for example \citet{ClausBoutillierDynamics} show that independent $Q$-learners cannot distinguish teammates' exploration from stochasticity in the environment, and fail to solve even an apparently trivial, 2-agent, stateless, $3\times 3$-action problem and the general Dec-POMDP problem is known to be intractable \citep{BernsteinDecPomdp,OliehoekAmato16book}. Though we here focus on 2 player coordination, we note that the problems with individual learners and centralized approaches just gets worse with more agents since then, most rewards do not relate to the individual agent and the action space grows exponentially for the fully centralized approach.

One approach to improving the performance of independent learners is to design individual reward functions, more directly related to individual agent observations. However, even in the single-agent case, reward shaping is difficult and only a small class of shaped reward functions are guaranteed to preserve optimality w.r.t. the true objective \citep{NgShaping,tumer-devlin_aamas14,EckSDK16}. In this paper we aim for more general autonomous solutions, in which the decomposition of the team value function is learned.



We introduce a novel {\bf learned additive value-decomposition} approach over individual agents. Implicitly, the value decomposition network aims to learn an optimal linear value decomposition from the team reward signal, by back-propagating the total $Q$ gradient through deep neural networks representing the individual component value functions. This additive value decomposition is specifically motivated by avoiding the spurious reward signals that emerge in purely independent learners.The implicit value function learned by each agent depends only on local observations, and so is more easily learned. Our solution also ameliorates the coordination problem of independent learning highlighted in \citet{ClausBoutillierDynamics} because it effectively learns in a centralised fashion at training time, while agents can be deployed individually. 


Further, in the context of the introduced agent, we evaluate weight sharing, role information and information channels as additional enhancements that have recently been reported to improve sample complexity and memory requirements \citep{HausknechtThesis,FoersterCommunicate, SF16}. However, our main comparison is between three kinds of architecture; Value-Decomposition across individual agents, Independent Learners and Centralized approaches. We investigate and benchmark combinations of these techniques applied to a range of new interesting two-player coordination domains. We find that Value-Decomposition is a much better performing approach than centralization or fully independent learners, and that when combined with the additional techniques, results in an agent that consistently outperforms centralized and independent learners by a big margin.





\iffalse
These architectures bring us to a further point about homogeneous approaches.
Besides the obvious homogeneous approach of identical fully individual agents, we see that there is a larger class of options satisfying an agent-invariance property that we introduce here. These can be seen as less naive and more sparsely connected centralized architectures. Though these are able to succeed where the more naively centralized agents fail, it is an important point that our value-decomposition method can train successfully coordinated individual agents.
\fi





\subsection{Other Related Work}

\citet{SchneiderDistributed} consider the optimization of the sum of individual reward functions, by optimizing local compositions of individual value functions learnt from them. \citet{RussellZimdarsQDecomposition} sums the $Q$-functions of independent learning agents with individual rewards, before making the global action selection greedily to optimize for total reward. Our approach works with only a team reward, and \emph{learns} the value-decomposition autonomously from experience, and it similarly differs from the approach with coordination graphs \citep{Guestrin2002} and the max-plus algorithm \citep{KuyerWBV08,Pol16}.



Other work addressing team rewards in cooperative  settings is based on \textit{difference rewards} \citep{tumer-wolpert_cdcs04}, measuring the impact of an agent's action on the full system reward. This reward has nice properties (e.g. high learnability), but can be impractical as it requires knowledge about the system state \citep{tumer-colby_aamas16,tumer-agogino_jaamas08,tumer-proper_aamas12}. Other approaches can be found in \citet{tumer-devlin_aamas14,tumer-holmesparker_ker14,BabesCL08}.





\section{Background}


\subsection{Reinforcement Learning}


We recall some key concepts of the RL setting \citep{SB98}, an agent-environment framework \citep{RN10} in which an agent sequentially interacts with the environment over a sequence of timesteps, $t=1,2,3,\hdots $, by executing actions and receiving observations and rewards, and aims to maximize cumulative reward. This is typically modelled as a Markov decision process (MDP) \citep[e.g.][]{puterman} defined by a tuple $ \langle \mathcal{S,A},\mathcal{T}_1,\mathcal{T},R \rangle$ comprising the state space $\mathcal{S}$, action space $\mathcal{A}$, a (possibly stochastic) reward function $R : \mathcal{S \times A\times S }\to \mathbb{R}$ start state distribution $\mathcal{T}_1 \in \mathcal{P(S)}$ and transition function $\mathcal{T}:\mathcal{S\times A} \rightarrow \mathcal{P(S)}$, where $\mathcal{P(X)}$ denotes the set of probability distributions over the set $\mathcal{X}$. We use $\bar{R}$ to denote the expected value of $R$. The agent's interactions give rise to a trajectory $(S_1,A_1,R_1,S_2,...)$ where $S_{1}\sim \mathcal{T}_1$, $S_{t+1}\sim \mathcal{T}(\cdot|S_t,A_t)$ and $R_t = R(S_t,A_t,S_{t+1})$, and we denote random variables in upper-case, and their realizations in lower-case. At time $t$ the agent observes $ o_t\in\mathcal{O} $ which is typically some function of the state $s_t$, and when the state is not fully observed the system is called a partially observed Markov decision process (POMDP).

\iffalse
If the Markov property $$\Pr(o_t,r_t\ |\ a_1,o_1,r_1, \hdots, a_{t-1},o_{t-1},r_{t-1},a_t ) =$$ $$ \Pr(o_t,r_t\ |\ o_{t-1},a_t)$$ is satisfied, then the environment is called a Markov Decision Process (MDP) and the observations $o_t$ can be viewed as states $s_t$. It is always possible to trivially satisfy the Markov property by letting $$s_t=h_t=a_1o_1r_1,...,a_{t-1}o_{t-1}r_{t-1}$ and then $\Pr(s_t,r_t\ |\ a_1,o_1,r_1, \hdots, a_{t-1},o_{t-1},r_{t-1},a_t ) = \Pr(s_t,r_t\ |\ s_{t-1},a_t)$$.
\fi

The agent's goal is to maximize expected cumulative discounted reward with a discount factor $\gamma$, $\R_t := \sum_{t=1}^{\infty}{\gamma^{t-1} R_{t}}$. The agent chooses actions according to a \emph{policy}: a (stationary)  policy is a function $\pi:\mathcal{S}\to\mathcal{P(A)}$ from states to probability distributions over $\mathcal{A}$. An optimal policy is one which maximizes expected cumulative reward. In fully observed environments, stationary optimal policies exist. In partially observed environments, the policy usually incorporates past agent observations from the \emph{history} $h_t=a_1o_1r_1,...,a_{t-1}o_{t-1}r_{t-1}$ (replacing $s_t$). A practical approach utilized here, is to parameterize policies using recurrent neural networks.

$V^\pi(s) := \mathbb{E} [\sum_{t=1}^\infty \gamma^{t-1} R(S_t, A_t,S_{t+1})|S_1 = s;A_t\sim \pi(\cdot|S_t)]$ is the value function and the action-value function is $Q^\pi(s,a) :=  \mathbb{E}_{S'\sim \mathcal{T}(\cdot|s,a)} [R(S, a,S') + \gamma V(S')]$ (generally, we denote the successor state of $s$ by $s'$). The optimal value function is defined by $V^*(s) = \sup _\pi  V^\pi(s)$ and similarly  $Q^*(s,a) = \sup_\pi Q^\pi(s,a)$. For a given action-value function $Q : \mathcal{S} \times \mathcal{A}\to \mathbb{R}$ we define the (deterministic) greedy policy w.r.t. $Q$ by $\pi(s) := \argmax_ {a\in\mathcal{A}} Q(s, a)$ (ties broken arbitrarily). The greedy policy w.r.t. $Q^*$ is optimal \citep[e.g.][]{SzepesvariAlgorithms}.

\subsection{Deep $Q$-Learning}

One method for obtaining $Q^*$ is $Q$-learning which is based on the update $Q_{i+1}(s_t,a_t)=(1-\eta_t) Q_i(s_t,a_t)+\eta_t(r_t+\gamma \max_a Q_i(s_{t+1},a))$, where $\eta_t\in (0,1)$ is the learning rate. We employ the $\varepsilon$-greedy approach to action selection based on a value function, which means that with $1-\varepsilon$ probability we pick $\argmax_a Q_i(s,a)$ and with probability $\varepsilon$ a random action. Our study focuses on deep architectures for the value function similar to those used by \citet{dqn15}, and our approach incorporates the key techniques of target networks and experience replay employed there, making the update into a stochastic gradient step. Since we consider partially observed environments our $Q$-functions are defined over agent observation histories, $Q(h_t,a_t)$,  and we incorporate a recurrent network similarly to \citet{HausknechtStoneRecurrent}. To speed up learning we add the dueling architecture of \citet{WangDuelling} that represent $Q$ using a value and an advantage function, including multi-step updates with a forward view eligibility trace \citep[e.g.][]{HarbPrecupRecurrance} over a certain number of steps. When training agents the recurrent network is updated with truncated back-propagation through time (BPTT) for this amount of steps. Although we concentrate on DQN-based agent architectures, our techniques are also applicable to policy gradient methods such as A3C \citep{MnihAsynchronous}.

\subsection{Multi-Agent Reinforcement Learning}


We consider problems where observations and actions are distributed across $d$ agents, and are represented as $d$-dimensional tuples of primitive observations in $\mathcal{O}$ and actions in $\mathcal{A}$. As is standard in MARL, the underlying environment is modeled as a Markov game where actions are chosen and executed simultaneously, and new observations are perceived simultaneously as a result of a transition to a new state ~\citep{Littman94,Littman01,HuW03,Busoniu08MARL}.

Although agents have individual observations and are responsible for individual actions, each agent only receives the joint reward, and we seek to optimize $\R_t$ as defined above. This is consistent with the Dec-POMDP framework \citep{OliehoekSV08, OliehoekAmato16book}. 


If we denote $\bar h := (h^1,h^2,...,h^d)$ a tuple of agent histories, a joint policy is in general a map $\pi: \mathcal{H}^d \to \mathcal{P}(\mathcal{A}^d)$; we in particular consider policies where for any history $\bar{h}$, the distribution $\pi(\bar{h})$ has independent components in $\mathcal{P}(\mathcal{A})$. Hence, we write  $\pi:\mathcal{H}^d\to \mathcal{P}(\mathcal{A})^d$. The exception is when we use the most naive centralized agent with a combinatorial action space, aka joint action learners. 





\section{A Deep-RL Architecture for Coop-MARL}


Building on purely independent DQN-style agents (see Figure~\ref{Independent}), we add enhancements to overcome the identified issues with the MARL problem. Our main contribution of value-decomposition is illustrated by the network in Figure~\ref{Value-Decomp}.







\iffalse
\begin{SCfigure}
\centering
\includegraphics[width=8cm]{ind_and_decomp}
\caption{Independent agents (left) and Value-decomposition architecture (right) showing how local observations are processed (three steps shown). In both architectures, observations enter the networks of two agents, pass through the low-level linear layer to the recurrent layer, and then a dueling layer produces individual $Q$-values. In the value decomposition architecture these "values" are summed to a joint $Q$-function for training, while actions are produced independently from the individual outputs.}
\label{IndependentAndDecomp}
\end
\fi


\begin{figure}
\begin{minipage}{.5\textwidth}
\centering
\includegraphics[width=3.5cm]{pg_0002}
\caption{Independent agents architecture showing how local observations enter the networks of two agents over time (three steps shown), pass through the low-level linear layer to the recurrent layer, and then a dueling layer produces individual $Q$-values.}
\label{Independent}
\end{minipage}
\begin{minipage}{.5\textwidth}
\centering
\includegraphics[width=3.5cm]{decomposed_cropped}
\caption{Value-decomposition individual architecture showing how local observations enter the networks of two agents over time (three steps shown), pass through the low-level linear layer to the recurrent layer, and then a dueling layer produces individual "values" that are summed to a joint $Q$-function for training, while actions are produced independently from the individual outputs.}
\label{Value-Decomp}
\end{minipage}
\end{figure}



\iffalse
\begin{figure*}[htb!]
\begin{subfigure}{4cm}
        \centering
        \includegraphics[width=3.5cm]{pg_0002}
        \caption{Independent agents architecture showing how local observations enters the networks of two agents over time (three steps shown), passes through the low-level linear layer to the recurrent layer, and then a dueling layer produces individual $Q$-values.}
        \label{Independent2}
    \end{subfigure}

    \begin{subfigure}{4cm}
        \centering
        \includegraphics[width=3.5cm]{decomposed_cropped}
        \caption{Value-decomposition individual architecture showing how local observations enters the networks of two agents over time (three steps shown), passes through the low-level linear layer to the recurrent layer, and then a dueling layer produces individual "values" that are summed to a joint $Q$-function for training, while actions are produced independently from the individual outputs.}
        \label{Value-Decomp2}
    \end{subfigure}
    \caption{}
\end{figure*}
\fi

\iffalse
\begin{figure*}[htp]
  \centering
  \subfigure[Independent Agents Architecture]{\includegraphics[scale=0.38]{{pg_0002}}\quad
  \subfigure[Value-Decomposition Individual Architecture]{\includegraphics[scale=0.38]{{decomposed_cropped}}
\end{figure*}
\fi










The main assumption we make and exploit is that the joint action-value function for the system can be additively decomposed into value functions across agents,
$$Q((h^1,h^2,...,h^d),(a^1,a^2,...,a^d))\approx \sum_{i=1}^d \tilde Q_i(h^i,a^i)\label{Qsum}
$$where the $\tilde Q_i$ depends only on each agent's local observations. We learn $\tilde Q_i$ by backpropagating gradients from the $Q$-learning rule using the joint reward through the summation, i.e. $\tilde Q_i$ is learned implicitly rather than from any reward specific to agent $i$, and we do not impose constraints that the $\tilde Q_i$ are action-value functions for any specific reward. The value decomposition layer can be seen in the top-layer of Figure~\ref{Value-Decomp}. One property of this approach is that, although learning requires some centralization, the learned agents can be deployed independently, since each agent acting greedily with respect to its local value $\tilde Q_i$ is equivalent to a central arbiter choosing joint actions by maximizing the sum $\sum_{i=1}^d \tilde Q_i$.




For illustration of the idea consider the case with 2 agents (for simplicity of exposition) and where rewards decompose additively across agent observations\footnote{Or, more generally, across agent histories.}, $r(\bs,\ba)=r_1(o^1,a^1)+r_2(o^2,a^2)$, where $(o^1, a^1)$ and $(o^2, a^2)$ are (observations, actions) of agents 1 and 2 respectively. This could be the case in team games for instance, when agents observe their own goals, but not necessarily those of teammates. In this case we have that
$$
Q^\pi(\bs,\ba) = \E [ \sum_{t=1}^\infty \gamma^{t-1} r(\bs_t,\ba_t) | \bs_1 = \bs, \ba_1 = \ba; \pi   ] \nonumber $$ $$
=\E [ \sum_{t=1}^\infty \gamma^{t-1} r_1(o^1_t,a^1_t) | \bs_1 = \bs, \ba_1 = \ba; \pi   ] + \E [ \sum_{t=1}^\infty \gamma^{t-1} r_2(o^2_t,a^2_t) | \bs_1 = \bs, \ba_1 = \ba; \pi   ] \nonumber $$ $$
 =: \bar{Q}^\pi_1(\bs,\ba) + \bar{Q}^\pi_2(\bs,\ba) \nonumber
$$
where $\bar{Q}^\pi_i(\bs,\ba):= \E [ \sum_{t=1}^\infty \gamma^{t-1} r_1(o^i_t,a^i_t) | \bs_1 = \bs, \ba_1 = \ba; \pi   ], i=1,2$. 
The action-value function $\bar{Q}^\pi_1(\bs,\ba)$ -- agent 1's expected future return -- could be expected to depend more strongly on observations and actions $(o^1, a^1)$ due to agent 1 than those due to agent 2. If $(o^1, a^1)$ is not sufficient to fully model $\bar{Q}^\pi_1(\bs,\ba)$ then agent 1 may store additional information from historical observations in its LSTM, or receive information from agent 2 in a communication channel, in which case we could expect the following approximation to be valid
$$
Q^\pi(\bs,\ba) =: \bar{Q}^\pi_1(\bs,\ba) + \bar{Q}^\pi_2(\bs,\ba)  \approx \tilde Q^\pi_1(h^1,a^1) + \tilde Q^\pi_2(h^2,a^2) 
$$
Our architecture therefore encourages this decomposition into simpler functions, if possible. We see that natural decompositions of this type arise in practice (see Section~\ref{LearnedQSection}).



\iffalse
\subsubsection{Policies and Scoring Functions}


More generally this technique can be applied to situations where a policy is derived from any other \emph{scoring function} $\psi:\mathcal{H}^d\to\mathbb{R}^{d|A|}$ which, given a history, produces a score for each agent and action $(i,a)$, such that the policy is then defined based on those scores rather than a $Q$-function. Given a scoring function $\psi:\mathcal{H}^d\to\mathbb{R}^{d|A|}$, and a composition function $\Gamma:\mathbb{R}^d\to\mathbb{R}$, we can compose them by letting $\bar{\psi}(\bar{h})((a_1,...,a_d)) := \Gamma(\psi(\bar{h})^1,...,\psi(\bar{h})^d)$ and we write $\bar{\psi} = \Gamma\circ\psi$. (We are particularly considering $\Gamma(x_1,...,x_d)=\sum_{i=1}^d x_i$.) For instance policy gradient networks would output a probability distribution over actions in any given state, effectively deriving a policy using a softmax of a score, and in that case the log-probability can be considered a such a scoring function. In this way the technique we described above is readily applicable to multi-agent learning using A3C, for instance.


Note that, while we talk about one scoring function $\psi:\mathcal{H}^d\to\mathbb{R}^{d|A|}$, this is a special case of the form $\psi = (\psi^1,...,\psi^d)$ where each $\psi^i:\mathcal{H}\to\mathbb{R}^{|A|}$ is a scoring function for an individual agent. If each is trained individually, we are simply training independent agents, while if we use a $\Gamma$ to combine the individual scores into a total score that is trained as one agent, we are performing centralized training to achieve coordinated individual agents.
\fi


\iffalse
Training of an agent based on a scoring function, can after applying $\Gamma$ be performed  by any update method that applies to a single agent with a scoring function like e.g. (assuming differentiability of the total scoring function) DQN or A3C and their further developments. In DQN, the score is learned as a value, while also in A3C, through the use of a value function as a baseline, we again end up with a decomposition of value. If the total summed score is learned as a value, we can think of the individual scores that are learned in the process as a decomposition of this total value into individual agent values.

We primarily consider that policies that have a scoring function $\psi:\mathcal{H}^d\to\mathbb{R}^{d|A|}$ that given a history, produce a score for each agent and action $(i,a)$. The policy is then defined based on those scores, e.g.\ by (as DQN) for each agent slot $i$ picking, with probability $1-\varepsilon$, the action $a$ with the highest score and with probability $\varepsilon\geq 0$ a uniformly random $a$, or using softmax (as A3C). For the centralized agent with combinatorial action space, there is only agent $(i=1)$ and the actions are tuples, but the agent considered is otherwise of the same form. We denote by $f:\mathhbb{R}^{|A|}\to \mathcal{P}(A}$ the way we sample an action based on a score and we can write
$$\pi(\bar{h})^i = f(\psi(\bar{h})^i)$$
where $x^i$ is the $i$th component of $x\in\mathbb{R}^d$. Here we restrict ourselves to using the same $f$ for all $i$ and we write $\pi=f\circ\psi$.
\fi

\iffalse
\paradot{Putting together a scoring function}
Interesting options for the scoring function $\psi$ are defined by several component functions. We let $\phi:\mathcal{H}\to\mathbb{R}^l$ be a function applied directly on each agent's observation stream and can represent using low level vision processing like one or two neural network layers that can e.g.\ be linear or convolutional but could also contain a recurrent layer. We also consider a centralization function $\xi:(\mathbb{R}^l)^d\to \mathbb{R}^{l'}$ that combines all the processed inputs. Then we complete the definition of the scoring function by letting the $i$th component of $\psi$ be 
\begin{equation}\label{eq:comp}
\psi(\bar{h})^i = g^i(\phi(h^i),\xi(\phi(h^1),..,\phi(h^d))    
\end{equation}
where for each $i=1,...,d$ the function $g^i:\mathbb{R}^l\times\mathbb{R}^{l'}$. 
\fi






One approach to reducing the number of learnable parameters, is to share certain network weights between agents.
Weight sharing also gives rise to the concept of agent invariance, which is useful for avoiding the lazy agent problem.

\begin{definition}[Agent Invariance]
If for any permutation (bijection) $p:\{1,...,d\}\to\{1,...,d\}$, 
$$\pi(p(\bar{h}))=p(\pi(\bar{h}))$$
we say that $\pi$ is \emph{agent invariant}. 
\end{definition}

It is not always desirable to have agent invariance, when for example specialized roles are required to optimize a particular system. In such cases we provide each agent with \emph{role information}, or an identifier. The role information is provided to the agent as a 1-hot encoding of their identity concatenated with every observation at the first layer. When agents share all network weights they are then only \emph{conditionally agent invariant}, i.e.\ have identical policies only when conditioned on the same role. We also consider information channels between agent networks, i.e. differentiable connections between agent network modules. These architectures, with shared weights, satisfy agent invariance.

 
\section{Experiments} \label{ExperimentSection}
We introduce a range of two-player domains, and experimentally evaluate the introduced value-decomposition agents with different levels of enhancements, evaluating each addition in a logical sequence.  We use two centralized agents as baselines, one of which is introduced here again relying on learned value-decomposition, as well as an individual agent learning directly from the joint reward signal. We perform this set of experiments on the same form of two dimensional maze environments used by \citet{leibo2017}, but with different tasks featuring more challenging coordination needs. Agents have a small $3\times5\times5$ observation window, the first dimension being an RGB channel, the second and third are the maze dimensions, and each agent sees a box 2 squares either side and 4 squares forwards, see Figures~\ref{Independent} and \ref{Value-Decomp}. The simple graphics of our domains helps with running speed while, especially due to their multi-agent nature and severe partial observability and aliasing (very small observation window combined with map symmetries), they still pose a serious challenge and is comparable to the state-of-the-art in multi-agent reinforcement learning \citep{leibo2017}, which exceeds what is common in this area \citep{TuylsW12}.

\subsection{Agents}
Our agent's learning algorithm is based on DQN \citep{dqn15} and includes its signature techniques of experience replay and target networks, enhanced with an LSTM value-network as in \citet{HausknechtStoneRecurrent} (to alleviate severe partial observability), learning with truncated back-propagation through time, multi-step updates with forward view eligibility traces \citep{HarbPrecupRecurrance} (which helps propagating learning back through longer sequences) and the dueling architecture \citep{WangDuelling} (which speeds up learning by generalizing across the action space). Since observations are from a local perspective, we do not benefit from convolutional networks, but use a fully connected linear layer to process the observations. 

Our network architectures first process the input using a fully connected linear layer with $32$ hidden units followed by a ReLU layer, and then an LSTM, with $32$ hidden units followed by a ReLU layer, and finally a linear dueling layer, with $32$ units. This produces a value function $V(s)$ and \emph{advantage function} $A(s,a)$, which are combined to compute a $Q$-function $Q(s,a) = V(s) + A(s,a)$ as described in \citet{WangDuelling}. Layers of $32$ units are sufficiently expressive for these tasks with limited observation windows.

The architectures (see Appendix B for detailed diagrams) differ between approaches by what is input into each layer. For architectures without centralization or information channels, one observation of size $3\times 5\times 5$ is fed to the first linear layer of $32$ units, followed by the ReLU layer and the LSTM (see Figure~\ref{Independent}). For the other (information channels and centralized) agents, $d$ such observations are fed separately to identical such linear layers and then concatenated into $64$ dimensional vectors before passing though ReLUs to an LSTM. 


For architectures with information channels we concatenate the outputs of certain layers with those of other agents. To preserve agent invariance, the agent's own previous output is always included first. For low-level communication, the signal's concatenation is after the first fully connected layer, while for high-level communication the concatenation takes place on the output of the LSTM layer. Note, that this has the implication that what starts as one agent's gradients are back-propagated through much of the other agents network, optimizing them to serve the purposes of all agents. Hence, representing in that sense, a higher degree of centralization than the lower-level sharing.




We have found a trajectory length of $8$, determining both the length of the forward view and the length of the back propagation through time is sufficient for these domains. We use an eligibility trace parameter $\lambda=0.9$. In particular, the individual agents learning directly from the joint reward without decomposition or information channels, has worse performance with lower $\lambda$. The Adam \citep{Kingma14} learning rate scheme initialized with $0.0001$ is uniformly used, and further fine-tuning this per agent (not domain) does not dramatically change the total performance. The agents that we evaluate are listed in the table above.











\begin{SCtable}
\begin{tabular}{c c c c c c c}
 \toprule
Agent & V. & S. & Id & L. & H. & C. \\ [0.5ex] 
\midrule
 1 &   &  &   &  &   &  \\
 2 & \checkmark &   &   &   &   &  \\
 3 & \checkmark & \checkmark &   &   &   &  \\
 4 & \checkmark & \checkmark & \checkmark &   &   &  \\
 5 & \checkmark & \checkmark & \checkmark & \checkmark &   &  \\
 6 & \checkmark & \checkmark & \checkmark &   & \checkmark &  \\
 7 & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark &  \\
 8 & \checkmark &   &   &   &   & \checkmark\\
 9 &   &   &   &   &   & \checkmark\\
\bottomrule
\end{tabular}
\caption{Agent architectures. V is value decomposition, S means shared weights and an invariant network, Id means role info was provided, L stands for lower-level communication, H for higher-level communication and C for centralization. These architectures were selected to show the advantages of the independent agent with value-decomposition and to study the benefits of additional enhancements added in a logical sequence.}
\label{tab:archs}
\end{SCtable}


\subsection{Environments}


We use 2D grid worlds with the same basic functioning as \citet{leibo2017}, but with different tasks we call Switch, Fetch and Checkers. We have observations of byte values of size $3\times5\times5$ (RGB), which represent a window depending on the playerâ€™s position and orientation by extending $4$ squares ahead
and $2$ squares on each side. Hence, agents are very short-sighted. The actions are: step forward, step backward,
step left, step right, rotate left, rotate right, use beam
and stand still. The beam has no effect in our games, except for lighting up a row or column of squares straight ahead with yellow. Each player appears as a  blue square in its own observation, and the other player, when in the observation window, is shown in red for Switch and Escape, and lighter blue for Fetch. We use three different maps shown in Figure~\ref{S0} for both Fetch and Switch and a different one for Checkers, also shown in Figure~\ref{S0} (bottom right). The tasks repeat as the agents succeed (either by full reset of the environment in Switch and Checkers or just by pickup being available again in Fetch), in training for 5,000 steps and 2,000 in testing.










\begin{figure}
\begin{minipage}{.5\textwidth}
\centering
\includegraphics[height=1.7cm]{SwitchPicOpen}
\vspace{0.05cm}
\includegraphics[height=1.7cm, width=6.75cm]{sight}


\end{minipage}
\begin{minipage}{.5\textwidth}
\centering
\includegraphics[height=1.7cm]{SwitchPic2Path}
\vspace{0.05cm}
\includegraphics[height=1.7cm, width=6.75cm]{checkers} \end{minipage}
\caption{Maps for Fetch and Switch: open map (top left), map with 1 corridor (bottom left) and 2 corridors (top right). The green square is the goal for the agent to the left (blue). A similar goal is seen for the other agent (red) to the left but not displayed. The agents' observation windows are shown in the bottom left. Bottom right is the map for Checkers. Lemons are orange, apples green and agents red/blue.} \label{S0}
\end{figure}










{\bf Switch:} The task tests if two agents can effectively coordinate their use of available routes on two maps with narrow corridors. The task is challenging because of strong observation aliasing. The two agents appear on different ends of a map, and must reach a goal at the other end. If agents collide in a corridor, then one agent needs to leave the corridor to allow the other to pass. When both players have reached their goal the environment is reset. A point is scored whenever a player reaches a goal. 

{\bf Fetch:} The task tests if two agents can synchronize their behaviour, when picking up objects and returning them to a drop point. In the Fetch task both players start on the same side of the map and have pickup points on the opposite side. A player scores $3$ points for the team for pick-up, and another $5$ points for dropping off the item at the drop point near the starting position. Then the pickup is available to either player again. It is optimal for the agents to cycle such that when one player reaches the pickup point the other returns to base, to be ready to pick up again. 





{\bf Checkers:} 
The map contains apples and lemons. The first player is very sensitive and scores $10$ for the team for an apple (green square) and $-10$ for a lemon (orange square). The second, less sensitive player scores $1$ for the team for an apple and $-1$ for a lemon. There is a wall of lemons between the players and the apples. Apples and lemons disappear when collected, and the environment resets when all apples are eaten. It is important that the sensitive agent eats the apples while the less sensitive agent should leave them to its team mate but clear the way by eating obstructing lemons. 



\subsection{Results}


We compare the eight approaches listed in Table~\ref{tab:archs}, on the seven tasks. Each is run ten times, with different random seeds determining spawn points in the environment, as well as initializations of the neural networks. 
We calculated curves of the average performance over 50,000 episodes (plots in Appendix A) for each approach on each task and we display the normalized area under the curve in Figure \ref{barplot_all}. Figure \ref{heat} displays the normalized final performance averaged over runs and the last 1,000 episodes. Average performance across tasks is also shown for both ways of evaluation.

The very clear conclusion is that architectures based on value-decomposition perform much better, with any combination of other techniques or none, than the centralized approach and individual learners. The centralized agent with value-decomposition is better than the combinatorially centralized as well as individual learners while worse than the more individual agents with value-decomposition. 



\begin{figure*}[t]
\includegraphics[width=14.cm]{barplot_all}
\caption{Barplots showing normalized AUC for each agent and domain over 50000 episodes of training and the mean across domains.}\label{barplot_all}
\end{figure*}


 
 
 \begin{figure}
\begin{minipage}{.5\textwidth}
\includegraphics[width =8.0cm]{final_reward_heatmap_annot}
\caption{Heatmap showing each agent's final performance, averaged over the last 5,000 episodes of 50,000 and across ten runs, normalized by the best architecture per task. The agents are ordered according to average over the domains, which can be seen in the right most column. Value-Decomposition architecture strongly outperform Individual Learners and Centralization} \label{heat}

\end{minipage}
\begin{minipage}{.5\textwidth}
\includegraphics[width=7.0cm]{value_decomp_nips}
\caption{The learned $Q$-decomposition in Fetch. The plot shows the total $Q$-function (yellow), the value of agent~1 (green), the value of agent~2 (purple), rewards from agent~1 (blue) events and agent~2 (red). Highlighted is a situation in which agent~2's $Q$-function spikes (purple line), anticipating reward for an imminent drop-off. The other agent's $Q$-function (green) remains relatively flat.}\label{Qplot}
\end{minipage}

\end{figure}
 
 
We particularly see the benefit of shared weights on the hard task of Fetch with one corridor. Without sharing, the individual value-decomposition agent suffers from the lazy agent problem.  The agent with weight sharing and role information also perfectly learns the one corridor Fetch task. It performs better than the agent just sharing weights on Switch, where coordination, in particular with one corridor, is easier with non-identical agents. Further, shared weights are problematic for the Checkers task because the magnitude of rewards (and hence the value function) from one agent is ten times higher than for the other agent. 

Adding information channels does increase learning complexity because the input comes from more than one agent. However, the checkers task, designed for the purpose, shows that it can be very useful. Overall, the low-level channels where the agent's LSTM processes the combined observations of both agents turned out to learn faster in our experiments than the more centralized high level communication (after the LSTM). 


\subsection{The Learned $Q$-Decomposition}\label{LearnedQSection}



\iffalse
\begin{figure}[h!]
\centering
\includegraphics[height=6.2cm]{value_decomp_nips}
\caption{The learned $Q$-decomposition in Fetch. }\label{Qplot}
\end{figure}
\fi

Figure~\ref{Qplot} shows the learned $Q$-decomposition for the value-decomposition network, using shared weights, in the game of Fetch. A video of the corresponding game can be seen at \citet{B17}. Spikes correspond to pick-up events (short spikes, 3 reward points), and return events (large spikes, 5 reward points). These are separated into events due to agent~1 (blue spikes) and agent~2 (red spikes). This disambiguation is for illustration purposes only: the environment gives a reward to the whole team for all of these events. The total $Q$-function is seen in yellow, clearly anticipating the team reward events, and dropping shortly afterwards. The component $Q$-functions $\tilde Q_1$ and $\tilde Q_2$ for agents~1 and 2 are shown in green and purple. These have generally disambiguated the $Q$-function into rewarding events separately attributable to either player. The system has learned to autonomously decompose the joint $Q$-function into sensible components which, when combined, result in an effective $Q$-function. This would be difficult for independent learners since many rewards would not be observed by both players, see e.g. the situation at 15-16 seconds in the corresponding video available at \citet{B17}.


















\section{Conclusions}
We study cooperative multi-agent reinforcement learning where only a single joint reward is provided to the agents. We found that the two naive approaches, individual agents learning directly from team reward, and fully centralized agents, provide unsatisfactory solutions as previous literature has found in simpler environments, while our value-decomposition networks do not suffer from the same problems and shows much better performance across a range of more complex tasks. Further, the approach can be nicely combined with weight sharing and information channels, leading to agents that consistently optimally solve our new benchmark challenges. 





Value-decomposition networks are a step towards automatically decomposing complex learning problems into local, more readily learnable sub-problems. In future work we will investigate the scaling of value-decomposition with growing team sizes, which make individual learners with team reward even more confused (they mostly see rewards from other agents actions), and centralized learners even more impractical. We will also investigate decompositions based on non-linear value aggregation.

\FloatBarrier




\begin{thebibliography}{40}
\providecommand{\natexlab}[1]{#1}
\providecommand{\url}[1]{\texttt{#1}}
\expandafter\ifx\csname urlstyle\endcsname\relax
  \providecommand{\doi}[1]{doi: #1}\else
  \providecommand{\doi}{doi: \begingroup \urlstyle{rm}\Url}\fi

\bibitem[Agogino and Tumer(2008)]{tumer-agogino_jaamas08}
A.~K. Agogino and K.~Tumer.
\newblock Analyzing and visualizing multiagent rewards in dynamic and
  stochastic environments.
\newblock \emph{Journal of Autonomous Agents and Multi-Agent Systems},
  17\penalty0 (2):\penalty0 320--338, 2008.

\bibitem[Babes et~al.(2008)Babes, de~Cote, and Littman]{BabesCL08}
M.~Babes, E.~M. de~Cote, and M.~L. Littman.
\newblock Social reward shaping in the prisoner's dilemma.
\newblock In \emph{7th International Joint Conference on Autonomous Agents and
  Multiagent Systems {(AAMAS} 2008), Estoril, Portugal, May 12-16, 2008, Volume
  3}, pages 1389--1392, 2008.

\bibitem[Bernstein et~al.(2000)Bernstein, Zilberstein, and
  Immerman]{BernsteinDecPomdp}
D.~S. Bernstein, S.~Zilberstein, and N.~Immerman.
\newblock The complexity of decentralized control of {Markov Decision
  Processes}.
\newblock In \emph{{UAI} '00: Proceedings of the 16th Conference in Uncertainty
  in Artificial Intelligence, Stanford University, Stanford, California, USA,
  June 30 - July 3, 2000}, pages 32--37, 2000.

\bibitem[Busoniu et~al.(2008)Busoniu, Babuska, and Schutter]{Busoniu08MARL}
L.~Busoniu, R.~Babuska, and B.~D. Schutter.
\newblock A comprehensive survey of multiagent reinforcement learning.
\newblock \emph{IEEE Transactions of Systems, Man, and Cybernetics Part C:
  Applications and Reviews}, 38\penalty0 (2), 2008.

\bibitem[Claus and Boutilier(1998)]{ClausBoutillierDynamics}
C.~Claus and C.~Boutilier.
\newblock The dynamics of reinforcement learning in cooperative multiagent
  systems.
\newblock In \emph{Proceedings of the Fifteenth National Conference on
  Artificial Intelligence and Tenth Innovative Applications of Artificial
  Intelligence Conference, {AAAI} 98, {IAAI} 98, July 26-30, 1998, Madison,
  Wisconsin, {USA.}}, pages 746--752, 1998.

\bibitem[Colby et~al.(2016)Colby, Duchow-Pressley, Chung, and
  Tumer]{tumer-colby_aamas16}
M.~Colby, T.~Duchow-Pressley, J.~J. Chung, and K.~Tumer.
\newblock Local approximation of difference evaluation functions.
\newblock In \emph{Proceedings of the Fifteenth International Joint Conference
  on Autonomous Agents and Multiagent Systems}, Singapore, May 2016.

\bibitem[Devlin et~al.(2014)Devlin, Yliniemi, Kudenko, and
  Tumer]{tumer-devlin_aamas14}
S.~Devlin, L.~Yliniemi, D.~Kudenko, and K.~Tumer.
\newblock Potential-based difference rewards for multiagent reinforcement
  learning.
\newblock In \emph{Proceedings of the Thirteenth International Joint Conference
  on Autonomous Agents and Multiagent Systems}, May 2014.

\bibitem[Eck et~al.(2016)Eck, Soh, Devlin, and Kudenko]{EckSDK16}
A.~Eck, L.~Soh, S.~Devlin, and D.~Kudenko.
\newblock Potential-based reward shaping for finite horizon online {POMDP}
  planning.
\newblock \emph{Autonomous Agents and Multi-Agent Systems}, 30\penalty0
  (3):\penalty0 403--445, 2016.

\bibitem[Foerster et~al.(2016)Foerster, Assael, de~Freitas, and
  Whiteson]{FoersterCommunicate}
J.~N. Foerster, Y.~M. Assael, N.~de~Freitas, and S.~Whiteson.
\newblock Learning to communicate with deep multi-agent reinforcement learning.
\newblock In \emph{Advances in Neural Information Processing Systems 29: Annual
  Conference on Neural Information Processing Systems 2016, December 5-10,
  2016, Barcelona, Spain}, pages 2137--2145, 2016.

\bibitem[Guestrin et~al.(2002)Guestrin, Lagoudakis, and Parr]{Guestrin2002}
C.~Guestrin, M.~G. Lagoudakis, and R.~Parr.
\newblock Coordinated reinforcement learning.
\newblock In \emph{Proceedings of the Nineteenth International Conference on
  Machine Learning}, ICML '02, pages 227--234, San Francisco, CA, USA, 2002.
  Morgan Kaufmann Publishers Inc.
\newblock ISBN 1-55860-873-7.
\newblock URL \url{http://dl.acm.org/citation.cfm?id=645531.757784}.

\bibitem[Harb and Precup(2016)]{HarbPrecupRecurrance}
J.~Harb and D.~Precup.
\newblock Investigating recurrence and eligibility traces in deep {Q-}networks.
\newblock In \emph{Deep Reinforcement Learning Workshop, NIPS 2016, Barcelona,
  Spain}, 2016.

\bibitem[Hausknecht(2016)]{HausknechtThesis}
M.~J. Hausknecht.
\newblock \emph{Cooperation and Communication in Multiagent Deep Reinforcement
  Learning}.
\newblock PhD thesis, The University of Texas at Austin, 2016.

\bibitem[Hausknecht and Stone(2015)]{HausknechtStoneRecurrent}
M.~J. Hausknecht and P.~Stone.
\newblock Deep recurrent {Q}-learning for partially observable {MDPs}.
\newblock \emph{CoRR}, abs/1507.06527, 2015.

\bibitem[HolmesParker et~al.(2016)HolmesParker, Agogino, and
  Tumer]{tumer-holmesparker_ker14}
C.~HolmesParker, A.~Agogino, and K.~Tumer.
\newblock Combining reward shaping and hierarchies for scaling to large
  multiagent systems.
\newblock \emph{Knowledge Engineering Review}, 2016.
\newblock to appear.

\bibitem[Hu and Wellman(2003)]{HuW03}
J.~Hu and M.~P. Wellman.
\newblock Nash q-learning for general-sum stochastic games.
\newblock \emph{Journal of Machine Learning Research}, 4:\penalty0 1039--1069,
  2003.

\bibitem[Kingma and Ba(2014)]{Kingma14}
D.~P. Kingma and J.~Ba.
\newblock Adam: {A} method for stochastic optimization.
\newblock \emph{CoRR}, abs/1412.6980, 2014.
\newblock URL \url{http://arxiv.org/abs/1412.6980}.

\bibitem[Kuyer et~al.(2008)Kuyer, Whiteson, Bakker, and Vlassis]{KuyerWBV08}
L.~Kuyer, S.~Whiteson, B.~Bakker, and N.~A. Vlassis.
\newblock Multiagent reinforcement learning for urban traffic control using
  coordination graphs.
\newblock In \emph{Machine Learning and Knowledge Discovery in Databases,
  European Conference, {ECML/PKDD} 2008, Antwerp, Belgium, September 15-19,
  2008, Proceedings, Part {I}}, pages 656--671, 2008.

\bibitem[Laurent et~al.(2011)Laurent, Matignon, and Fort-Piat]{Laurent11}
G.~J. Laurent, L.~Matignon, and N.~L. Fort-Piat.
\newblock The world of independent learners is not {M}arkovian.
\newblock \emph{Int. J. Know.-Based Intell. Eng. Syst.}, 15\penalty0
  (1):\penalty0 55--64, 2011.

\bibitem[Leibo et~al.(2017)Leibo, Zambaldi, Lanctot, Marecki, and
  Graepel]{leibo2017}
J.~Z. Leibo, V.~Zambaldi, M.~Lanctot, J.~Marecki, and T.~Graepel.
\newblock {Multi-agent Reinforcement Learning in Sequential Social Dilemmas}.
\newblock In \emph{Proceedings of the 16th International Conference on
  Autonomous Agents and Multiagent Systems (AAMAS 2017)}, Sao Paulo, Brazil,
  2017.

\bibitem[Littman(1994)]{Littman94}
M.~L. Littman.
\newblock Markov games as a framework for multi-agent reinforcement learning.
\newblock In \emph{Machine Learning, Proceedings of the Eleventh International
  Conference, Rutgers University, New Brunswick, NJ, USA, July 10-13, 1994},
  pages 157--163, 1994.

\bibitem[Littman(2001)]{Littman01}
M.~L. Littman.
\newblock Friend-or-foe q-learning in general-sum games.
\newblock In \emph{Proceedings of the Eighteenth International Conference on
  Machine Learning {(ICML} 2001), Williams College, Williamstown, MA, USA, June
  28 - July 1, 2001}, pages 322--328, 2001.

\bibitem[Mnih et~al.(2015)Mnih, Kavukcuoglu, Silver, Rusu, Veness, Bellemare,
  Graves, Riedmiller, Fidjeland, Ostrovski, Petersen, Beattie, Sadik,
  Antonoglou, King, Kumaran, Wierstra, Legg, and Hassabis]{dqn15}
V.~Mnih, K.~Kavukcuoglu, D.~Silver, A.~Rusu, J.~Veness, M.~Bellemare,
  A.~Graves, M.~Riedmiller, A.~Fidjeland, G.~Ostrovski, S.~Petersen,
  C.~Beattie, A.~Sadik, I.~Antonoglou, H.~King, D.~Kumaran, D.~Wierstra,
  S.~Legg, and D.~Hassabis.
\newblock Human-level control through deep reinforcement learning.
\newblock \emph{Nature}, 518\penalty0 (7540):\penalty0 529--533, 02 2015.

\bibitem[Mnih et~al.(2016)Mnih, Badia, Mirza, Graves, Lillicrap, Harley,
  Silver, and Kavukcuoglu]{MnihAsynchronous}
V.~Mnih, A.~P. Badia, M.~Mirza, A.~Graves, T.~P. Lillicrap, T.~Harley,
  D.~Silver, and K.~Kavukcuoglu.
\newblock Asynchronous methods for deep reinforcement learning.
\newblock In \emph{Proceedings of the 33nd International Conference on Machine
  Learning, {ICML} 2016, New York City, NY, USA, June 19-24, 2016}, pages
  1928--1937, 2016.

\bibitem[Ng et~al.(1999)Ng, Harada, and Russell]{NgShaping}
A.~Y. Ng, D.~Harada, and S.~J. Russell.
\newblock Policy invariance under reward transformations: Theory and
  application to reward shaping.
\newblock In \emph{Proceedings of the Sixteenth International Conference on
  Machine Learning {(ICML} 1999), Bled, Slovenia, June 27 - 30, 1999}, pages
  278--287, 1999.

\bibitem[Oliehoek and Amato(2016)]{OliehoekAmato16book}
F.~A. Oliehoek and C.~Amato.
\newblock \emph{A Concise Introduction to Decentralized POMDPs}.
\newblock SpringerBriefs in Intelligent Systems. Springer, 2016.

\bibitem[Oliehoek et~al.(2008)Oliehoek, Spaan, and Vlassis]{OliehoekSV08}
F.~A. Oliehoek, M.~T.~J. Spaan, and N.~A. Vlassis.
\newblock Optimal and approximate q-value functions for decentralized pomdps.
\newblock \emph{J. Artif. Intell. Res. {(JAIR)}}, 32:\penalty0 289--353, 2008.

\bibitem[Panait and Luke(2005)]{panait05}
L.~Panait and S.~Luke.
\newblock Cooperative multi-agent learning: The state of the art.
\newblock \emph{Autonomous Agents and Multi-Agent Systems}, 11\penalty0
  (3):\penalty0 387--434, 2005.

\bibitem[Proper and Tumer(2012)]{tumer-proper_aamas12}
S.~Proper and K.~Tumer.
\newblock Modeling difference rewards for multiagent learning (extended
  abstract).
\newblock In \emph{Proceedings of the Eleventh International Joint Conference
  on Autonomous Agents and Multiagent Systems}, Valencia, Spain, June 2012.

\bibitem[Puterman(1994)]{puterman}
M.~Puterman.
\newblock \emph{{Markov} Decision Processes: Discrete Stochastic Dynamic
  Programming}.
\newblock Wiley, New York, 1994.

\bibitem[Russell and Norvig(2010)]{RN10}
S.~J. Russell and P.~Norvig.
\newblock \emph{Artificial Intelligence: A Modern Approach}.
\newblock Prentice Hall, Englewood Cliffs, NJ, $3^{nd}$ edition, 2010.

\bibitem[Russell and Zimdars(2003)]{RussellZimdarsQDecomposition}
S.~J. Russell and A.~Zimdars.
\newblock Q-decomposition for reinforcement learning agents.
\newblock In \emph{Machine Learning, Proceedings of the Twentieth International
  Conference {(ICML} 2003), August 21-24, 2003, Washington, DC, {USA}}, pages
  656--663, 2003.

\bibitem[Schneider et~al.(1999)Schneider, Wong, Moore, and
  Riedmiller]{SchneiderDistributed}
J.~G. Schneider, W.~Wong, A.~W. Moore, and M.~A. Riedmiller.
\newblock Distributed value functions.
\newblock In \emph{Proceedings of the Sixteenth International Conference on
  Machine Learning {(ICML} 1999), Bled, Slovenia, June 27 - 30, 1999}, pages
  371--378, 1999.

\bibitem[Sukhbaatar et~al.(2016)Sukhbaatar, Szlam, and Fergus]{SF16}
S.~Sukhbaatar, A.~Szlam, and R.~Fergus.
\newblock Learning multiagent communication with backpropagation.
\newblock \emph{CoRR}, abs/1605.07736, 2016.
\newblock URL \url{http://arxiv.org/abs/1605.07736}.

\bibitem[Sutton and Barto(1998)]{SB98}
R.~Sutton and A.~Barto.
\newblock \emph{Reinforcement Learning}.
\newblock The MIT Press, 1998.

\bibitem[Szepesv{\'{a}}ri(2010)]{SzepesvariAlgorithms}
C.~Szepesv{\'{a}}ri.
\newblock \emph{Algorithms for Reinforcement Learning}.
\newblock Synthesis Lectures on Artificial Intelligence and Machine Learning.
  Morgan {\&} Claypool Publishers, 2010.

\bibitem[Tumer and Wolpert(2004)]{tumer-wolpert_cdcs04}
K.~Tumer and D.~Wolpert.
\newblock A survey of collectives.
\newblock In K.~Tumer and D.~Wolpert, editors, \emph{Collectives and the Design
  of Complex Systems}, pages 1--42. Springer, 2004.

\bibitem[Tuyls and Weiss(2012)]{TuylsW12}
K.~Tuyls and G.~Weiss.
\newblock Multiagent learning: Basics, challenges, and prospects.
\newblock \emph{{AI} Magazine}, 33\penalty0 (3):\penalty0 41--52, 2012.

\bibitem[van~der Pol and Oliehoek(2016)]{Pol16}
E.~van~der Pol and F.~A. Oliehoek.
\newblock Coordinated deep reinforcement learners for traffic light control.
\newblock \emph{NIPS Workshop on Learning, Inference and Control of Multi-Agent
  Systems}, 2016.

\bibitem[{Video}(2017)]{B17}
{Video}.
\newblock Video for the q-decomposition plot.
\newblock 2017.
\newblock URL \url{https://youtu.be/aAH1eyUQsRo}.

\bibitem[Wang et~al.(2016)Wang, Schaul, Hessel, van Hasselt, Lanctot, and
  de~Freitas]{WangDuelling}
Z.~Wang, T.~Schaul, M.~Hessel, H.~van Hasselt, M.~Lanctot, and N.~de~Freitas.
\newblock Dueling network architectures for deep reinforcement learning.
\newblock In \emph{Proceedings of the International Conference on Machine
  Learning (ICML)}, pages 1995--2003, 2016.

\end{thebibliography}

\newpage


\section*{Appendix A: Plots}


\begin{figure}[h!]
\centering
\includegraphics[width=8.0cm]{reward_curve_Fetch_Open_ci_90}
\caption{Average reward with 90\% confidence intervals for ten runs of the nine architectures on the Fetch domain with the open map}
\end{figure}
\begin{figure}[h!]
\centering
\includegraphics[width=8.0cm]{reward_curve_Fetch_Single_ci_90}
\caption{Average reward with 90\% confidence intervals for ten runs of the nine architectures on the Fetch domain with one corridor}
\end{figure}
\begin{figure}[h!]
\centering
\includegraphics[width=8.0cm]{reward_curve_Fetch_Double_ci_90}
\caption{Average reward with 90\% confidence intervals for ten runs of the nine architectures on the Fetch domain with two corridors}
\end{figure}
\begin{figure}[h!]
\centering
\includegraphics[width=8.0cm]{reward_curve_Switch_Open_ci_90}
\caption{Average reward with 90\% confidence intervals for ten runs of the nine architectures on the Switch domain with the open map}
\end{figure}
\begin{figure}[h!]
\centering
\includegraphics[width=8.0cm]{reward_curve_Switch_Single_ci_90}
\caption{Average reward with 90\% confidence intervals for ten runs of the nine architectures on the Switch domain with one corridor}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[width=8.0cm]{reward_curve_Switch_Double_ci_90}
\caption{Average reward with 90\% confidence intervals for ten runs of the nine architectures on the Switch domain with two corridors}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[width=8.0cm]{reward_curve_Checkers_ci_90}
\caption{Average reward with 90\% confidence intervals for ten runs of the nine architectures on the Checkers domain}
\end{figure}







\FloatBarrier
\section*{Appendix B: Diagrams}

\begin{figure}[h!]
 \centering
\includegraphics[height=6.0cm]{Independent}
\caption{Independent Agents Architecture}

\end{figure}

\begin{figure}[h!]
 \centering
\includegraphics[height=6.0cm]{Value-Decomp}
\caption{Value-Decomposition Individual Architecture}

\end{figure}

\begin{figure}[h!]
 \centering
\includegraphics[height=6.0cm]{Low-com}
\caption{Low-level communication Architecture}

\end{figure}

\begin{figure}[h!]
 \centering
\includegraphics[height=6.0cm]{High-com}
\caption{High-level communication Architecture}

\end{figure}
 

\begin{figure}[h!]
 \centering
\includegraphics[height=6.0cm]{Low-com}
\caption{Low-level communication Architecture}

\end{figure}

\begin{figure}[h!]
 \centering
\includegraphics[height=6.0cm]{Independent}
\caption{Independent Agents Architecture}

\end{figure}


\begin{figure}[h!]
 \centering
\includegraphics[height=6.0cm]{CentComb}
\caption{Combinatorially Centralized Architecture}

\end{figure}


\begin{figure}[h!]
 \centering
\includegraphics[height=6.0cm]{L+H-com}
\caption{High+Low-level communication Architecture}

\end{figure}


\end{document}
