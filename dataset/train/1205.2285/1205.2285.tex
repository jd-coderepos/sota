\documentclass{aamas2013}
\usepackage{amssymb,amsmath,amsfonts}
\usepackage{times}

\usepackage{wrapfig}
\usepackage{algorithm}
\usepackage{algorithmic}

\pdfpagewidth=8.5truein
\pdfpageheight=11truein


\newcommand{\pref}{\succ}
\newcommand{\argmin}{{\mathrm argmin}}
\renewcommand{\P}{{\mathrm P}}
\newcommand{\NP}{{\mathrm{NP}}}
\newcommand{\SW}{{\mathrm{SW}}}
\newcommand{\SL}{{\mathrm{SL}}}
\newcommand{\Borda}{{\mathsf{Borda}}}
\newcommand{\Condorcet}{{\mathsf{Condorcet}}}
\newcommand{\Copeland}{{\mathsf{Copeland}}}
\newcommand{\Maximin}{{\mathsf{Maximin}}}
\newcommand{\Plurality}{{\mathsf{Plurality}}}
\newcommand{\Bucklin}{{\mathsf{Bucklin}}}
\newcommand{\Majority}{{\mathsf{Majority}}}
\newcommand{\STV}{{\mathsf{STV}}}
\newcommand{\Veto}{{\mathsf{Veto}}}
\newcommand{\Approval}{{\mathsf{Approval}}}
\newcommand{\coNP}{{\mathrm{coNP}}}
\newcommand{\calE}{{\cal E}}
\newcommand{\calL}{{\cal L}}
\newcommand{\hatF}{{\widehat{\cal F}}}
\newcommand{\calS}{{\cal S}}
\newcommand{\calA}{{\cal A}}
\newcommand{\calB}{{\cal B}}
\newcommand{\calP}{{\cal P}}
\newcommand{\calF}{{\cal F}}
\newcommand{\calD}{{\cal D}}
\newcommand{\calC}{{\cal C}}
\newcommand{\calX}{{\cal X}}
\newcommand{\calM}{{\cal M}}   
\newcommand{\calV}{{\cal V}}
\newcommand{\calR}{{\cal R}}
\newcommand{\calk}{{\cal k}}
\newcommand{\vecR}{{\cal R}}
\newcommand{\vecw}{{\mathbf w}}
\newcommand{\Cl}{{\mathit{Cl}}}
\newcommand{\vecalpha}{{\alpha}}
\newcommand{\safe}{\mathrm{safe}}
\newcommand{\tp}{{\mathrm{top}}}
\newcommand{\swap}{{\mathrm{swap}}}
\newcommand{\poly}{{\mathrm{poly}}}
\newcommand{\rob}{{\mathrm{rob}}}
\newcommand{\defc}{{\mathrm{def}}}
\renewcommand{\mod}{{\ \mathrm{mod}\ }}
\newcommand{\pos}{{\mathrm{pos}}}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}

\def\argmin{\mathop{\rm arg\,min}}
\newcommand{\FFa}{{\calF_{\vecalpha}}}




\title{Complex-Demand Knapsack Problems and \\Incentives in AC Power Systems}
\numberofauthors{2}
\author{
\alignauthor
Lan Yu\\
			 \affaddr{Division of Mathematical Sciences}\\
			 \affaddr{School of Physical and Mathematical Sciences}\\
       \affaddr{Nanyang Technological University, Singapore}\\
       \email{yula0001@ntu.edu.sg}
\alignauthor Chi-Kin Chau\\
			 \affaddr{Computing and Information Science}\\
       \affaddr{Masdar Institute of Science and Technology}\\
       \affaddr{Abu Dhabi,UAE}\\
       \email{ckchau@masdar.ac.ae}
}








\begin{document}

\maketitle



\begin{abstract}
We consider AC electrical systems where each electrical device has a power demand expressed as a complex number, and there is a limit on the magnitude of total power supply.  Motivated by this scenario, we introduce the {\em complex-demand knapsack problem} ({\sc C-KP}), a new variation of the traditional knapsack problem, where each item is associated with a demand as a complex number, rather than a real number often interpreted as weight or size of the item.  While keeping the same goal as to maximize the sum of values of the selected items, we put the capacity limit on the magnitude of the sum of satisfied demands.

For {\sc C-KP}, we prove its inapproximability by FPTAS (unless P = NP), as well as presenting a -approximation algorithm.  Furthermore, we investigate the selfish multi-agent setting where each agent is in charge of one item, and an agent may misreport the demand and value of his item for his own interest.  We show a simple way to adapt our approximation algorithm to be monotone, which is sufficient for the existence of {\em incentive compatible} payments such that no agent has an incentive to misreport.  Our results shed insight on the design of multi-agent systems for smart grid.
\end{abstract}

\category{I.2.11}{Distributed Artificial Intelligence}{Multiagent
  Systems}
\category{F.2}{Theory of Computation}{Analysis of Algorithms and Problem Complexity}
\terms{Algorithms, Theory}
\keywords{knapsack problem, approximation algorithm, FPTAS, incentive compatibility, truthfulness, AC electrical system, smart grid}



\section{Introduction}\label{sec:introduction}
\noindent
Most studies of power allocation only consider devices without minimum power requirements; we focus on those with such requirements, such as electric vehicles (EVs) charging, which will not produce any value unless it is charged enough to travel a threshold distance.  Gerding et al. \cite{gerding2011online} studies online electric vehicle charging by expressing power demands as real numbers.  However, in alternating current (AC) electrical systems, alternating power is provided.  In this paper, we study electrical devices with a power demand expressed as a complex number .  Although  for purely resistive appliances; devices with capacitive or inductive components have non-zero imaginary part  \cite{GS94power}.  


In power allocation, due to the constraint of power generation, there is a limit  on the magnitude of the total power supply, i.e., the magnitude of the sum of satisfied demands should not exceed .  Since only a limited number of devices can be served and different devices produce different values when they receive enough power to work,   
there arises a natural allocation problem: we want to select a subset of devices to provide power subject to the power limit constraint such that the total value produced is maximized.

Moreover, in a multi-agent setting (e.g., in future smart grid, where intelligent devices are automatically controlled by agents), the demand and value of each device are private knowledge of an individual agent.  The power allocation algorithm collects the input information from each agent, and based on that, computes which subset of demands to satisfy.  Depending on the (publicly known) algorithm, each selfish agent may misreport his demand or value to the algorithm in order to get selected.  

Naturally, to guarantee a good realization of our optimization goal (here, maximizing {\em social welfare}, the total value of selected items), we would like to design the algorithm in a way that incentivizes all agents to report their true information.  
This falls into the study of {\em Algorithmic mechanism design} \cite{N07book,NR01alg}, a burgeoning research area that deals with designing algorithms (called {\em mechanisms} here) for settings where inputs are controlled by selfish agents.  
Each agent is modeled to strategize so as to maximize his {\em utility}, a quantity that indicates his overall benefit.
A mechanism is {\em incentive compatible}, or simply {\em truthful}, if no agent has an incentive to misreport.
A general approach in mechanism design is to enforce payment on each agent to adjust his utility so that truth-telling always maximizes his utility.   

Now formally, we have the following mechanism design problem: we have a set  of distinct agents where each agent  owns an item with a positive value  and a complex-valued demand .  Given capacity , our task is to choose a subset  of agents to satisfy their demands and assign each agent  a nonnegative payment .  The goal is to elicit true inputs and maximize the total value of selected items subject to the constraint that .       	
Here we limit our attention to the case where  for all . This assumption is reasonable, since, although demands do not necessarily lie in the first quadrant of the complex plane, they are recommended\footnote{NEC NFPA 70-2005 (a standard for electrical systems and appliances) suggests that high-consumption appliances should conform to restricted power factor, which implies .} to stay within the region , which can be obtained by rotating the first quadrant by .
 
Usually, the design of a truthful mechanism is composed of two steps: first, we solve the pure algorithmic problem; second, we identify certain condition that guarantees the existence of incentive compatible payments and make it satisfied by our algorithm.  

We follow this path for our problem.  Our algorithmic problem is a winner determination optimization problem; we call it the {\em complex-demand knapsack problem} ({\sc C-KP}), as it turns out to be an interesting new variation of the traditional knapsack problem \cite{KPP10book}.  In the original {\em one-dimensional knapsack problem} ({\sc 1-KP}), the demand of an item is simply a nonnegative real number, often interpreted as the weight or size of the item.  The "knapsack", with fixed real-valued capacity to hold the items, represents the limited resource.  The multi-dimensional generalization, the {\em -dimensional knapsack problem} ({\sc -KP}), captures the settings where there are  independent resource constraints on the  dimensions (independent features) of the demands.  1-KP can model the power allocation in direct current (DC) electrical systems, where power demands can be expressed as real numbers, but fails for AC systems, where each demand is a two-dimensional vector.  Our problem is also different from {\sc 2-KP} since our capacity constraint is a quadratic one (on the magnitude of the total satisfiable demand), rather than two independent linear constraints in {\sc 2-KP}.  Moreover, it is natural to modify our problem by including these two linear constraints (on the real and imaginary part of the total satisfiable demand respectively), and thus introduce the {\em generalized complex-demand knapsack problem} ({\sc GC-KP}).  In fact, many power generators do have all three constraints of GC-KP.     

It is well-known that 1-KP is NP-hard, and our complex-demand variations include it as a special case when we set all .  
Hence we are interested in good polynomial-time approximation algorithms.  In this work, we present an algorithm with constant  approximation ratio for both {\sc C-KP} and {\sc GC-KP}, and show the inapproximability of {\sc C-KP} by FPTAS (unless P = NP), based on its connections to well-studied {\sc 1-KP}, {\sc 2-KP} and {\sc 3-KP}.  There is still a gap to close, and we conjecture that {\sc C-KP} admits a PTAS.



 

As to the incentive part, the difficulty lies in the following: VCG mechanisms \cite{N07book} are both social welfare maximizing and truthful; however, they become computationally infeasible when computing optimal social welfare is computationally hard, as in our setting.  Worse still, using algorithms approximating maximum social welfare may not preserve truthfulness.  
To obtain truthful and efficient mechanisms with a good approximation ratio, a leading approach is through "monotonization": First prove that a certain notion of monotonicity suffices for the existence of incentive compatible payments and then design or adapt an existing algorithm to be monotone.  This has been successfully applied to problem settings with {\em single-parameter} \cite{archer2001truthful} and {\em single-minded} agents \cite{LOS99mono}, with efficiently computable payments specified; in fact, for the former, monotonicity is necessary as well, which justifies the necessity of monotonization.  An additional nice property of the specified payments is that they guarantee nonnegative utilities for all agents, which, in mechanism design, is an important desired property called {\em individual rationality} ensuring voluntary participation of the agents. 

For the knapsack problem, if both demand and value of an item are private information, which is the case we investigate here, we do not have single-parameter agents. However, all variations we consider are special cases of single-minded agents, each has a single object  in mind, gets value  if he is assigned an object no worse than  and 0 otherwise.  For example, in our power system setting, the power demand  is the single object the th agent desires, and the value  is produced as long as the power he receives is  (according to comparisons between complex numbers).  The monotonicity property for single-minded agents looks natural and reasonable: If an agent is selected with certain demand and value, he should remain selected with a lower demand and a higher value, while the inputs of other agents are fixed.  Although this property easily holds for exact optimization, 
it may not hold for approximation algorithms.   
For {\sc C-KP}, we succeed in monotonizing our constant approximation algorithm, based on an existing monotone FPTAS for {\sc 1-KP} in \cite{BKV05KS}, and thus achieving incentive compatibility.



\smallskip

\noindent{\bf Related Work\ }
The knapsack problem has many variations with respect to divisibility of items, copies of items, dimensions of constraints, etc \cite{KPP10book}.
In this work, we restrict our attention to the NP-hard {\em one-dimensional knapsack problem} ({\sc 1-KP}) where each indivisible item has only one single copy, and its multi-dimensional generalization, the {\em -dimensional knapsack problem} ({\sc -KP}).

For {\sc 1-KP}, there is a pseudo-polynomial time algorithm using dynamic programming achieving exact optimization when all item values are integers.  There is a simple {\em fully polynomial-time approximation scheme} (FPTAS), which scales and rounds the item values and then applies the pseudo-polynomial time algorithm on small integer values \cite{KPP10book}.  However, this FPTAS is not monotone, since the scale factor involves the maximum item value.  Briest et al. \cite{BKV05KS} monotonized it, by performing the same procedure with a series of different scaling factors irrelevant to item values and taking the best solution out of them.  Hence {\sc 1-KP} admits an incentive compatible FPTAS.       

As to {\sc -KP} with , there is a {\em polynomial-time approximation scheme} (PTAS) by Frieze and Clarke \cite{FC84alg} based on the integer programming formulation, but it is not evident to see whether it is monotone.  On the other hand, {\sc 2-KP} is already inapproximable by FPTAS unless P = NP, by a reduction from {\sc equipartition} \cite{KPP10book}.  In fact, there is no {\em efficient polynomial-time approximation scheme} (EPTAS) for {\sc 2-KP} unless W[1] = FPT (See \cite{kulik2010there}).
 
\smallskip

\noindent{\bf Our Results\ }
We initiate the study of the {\em complex-demand knapsack problem} ({\sc C-KP}) and its hybrid with {\sc 2-KP}, the {\em generalized complex-demand knapsack problem} ({\sc GC-KP}).

In Section \ref{sec:algCKP}, we present an approximation algorithm for C-KP, which projects all demand vectors onto the  line and uses an approximation algorithm for 1-KP as a subroutine.  Since 1-KP admits an FPTAS, we achieve approximation ratio  for any , with running time polynomial in  and the size of the input.  Moreover, the algorithm can be monotonized, as shown in Section \ref{sec:monalg}, due to the existence of the monotone FPTAS for 1-KP.  


On the other hand, in Section \ref{sec:inappr}, we complete our study of C-KP by providing an inapproximability result.  We prove that there is no FPTAS for C-KP unless P = NP, through a modification of the reduction from {\sc equipartition} for 2-KP.  

Finally, for GC-KP, the inapproximability result is inherited since it includes C-KP as a special case.  We also come up with an approximation algorithm by applying the same idea as for C-KP, but we have to use a PTAS for 3-KP as a subroutine (Section \ref{sec:algGCKP}). Again we achieve approximation ratio  for any , but the running time is only guaranteed to be polynomial in the size of the input.   
Regarding monotonization, a similar trick as in Section \ref{sec:monalg} would work for {\sc GC-KP}, if we could find a good monotone approximation algorithm for {\sc 3-KP}.



\section{Preliminaries}\label{sec:prelim}
\noindent
\subsection{The Knapsack Problems}
\noindent
Here we give the integer programming formulation of the knapsack problems discussed in this paper.  The decision of an allocation algorithm is specified by indicator variables  for item , which has a simple correspondence to the selected subset of items: .  We will switch back to the subset representation in later sections for convenience of illustration. 

The {\em one-dimensional knapsack problem} ({\sc 1-KP}) is defined as: 
subject to 
where 
\begin{itemize}

\item  is a set of items;

\item  is the positive value of item  if its demand is satisfied;

\item  is the nonnegative real-valued demand of item ;

\item  is the positive real-valued capacity on the total satisfiable demand;

\item  indicates whether item  is selected:  means that the demand of item  is satisfied, and 0 otherwise.

\end{itemize}



1-KP can be generalized to multi-dimensions.  The {\em -dimensional knapsack problem} ({\sc -KP}) is defined as: 
subject to  independent inequalities
for , where 
\begin{itemize}

\item  is the nonnegative real-valued demand of item  in dimension ;

\item  is the positive real-valued capacity on the total satisfiable demand in dimension .

\end{itemize}
Each -KP is a linear integer program, and -KP is a special case of -KP for all .  We are especially interested in 1-KP, 2-KP and 3-KP, whose previous results will be used to achieve ours.  In particular, the {\em two-dimensional knapsack problem} ({\sc 2-KP}) can also be formulated in terms of complex-valued demands:




subject to 
where 
\begin{itemize}

\item  are the nonnegative real part and imaginary part respectively of the complex-valued demand  of item ;

\item  are the positive real-valued capacities on the real part and imaginary part respectively of the total satisfiable demand.
\end{itemize}





Our study concerns the capacity constraint on the magnitude of the total satisfiable demand, which is no longer linear.  We formulate the {\em complex-demand knapsack problem} ({\sc C-KP}) as follows: 
subject to  
where
\begin{itemize}

\item  is the complex-valued demand of item  where  are both nonnegative;

\item  is the positive real-valued capacity on the magnitude of the total satisfiable demand. 
\end{itemize}

Combining the constraints of C-KP and 2-KP results in the following {\em generalized complex-valued knapsack problem} ({\sc GC-KP}): 
subject to  

\subsection{Approximation Algorithm}
\noindent
For knapsack problems, given a solution represented by the selected subset of items , we denote the total value of selected items by .  Let  denote an optimal solution.

For our value maximization objective, an algorithm is called a {\em -approximation}, if on each input, the output  of the algorithm satisfies .   
Since the knapsack problems considered in this paper are NP-hard, one looks for polynomial-time algorithms with good approximation ratio . 

It is desirable to find constant approximation algorithms with  as close to 1 as possible; stronger than that are algorithms whose approximation ratio can be arbitrarily close to 1: 

One such candidate is a {\em polynomial-time approximation scheme} (PTAS), which is a -approximation algorithm for any .  The running time of a PTAS is polynomial in the input size for every fixed , but the exponent of the polynomial might depend on .  One way of addressing this is to define the {\em efficient polynomial-time approximation scheme} (EPTAS), whose running time is the multiplication of a function in  and a polynomial in the input size independent of .
An even stronger notion is a {\em fully polynomial-time approximation scheme} (FPTAS), which requires the running time to be polynomial in both the input size and .  

In this work, we design constant  approximation algorithms for C-KP and GC-KP based on the FPTAS for 1-KP and PTAS for 3-KP respectively. 
\subsection{Incentive Compatibility}\label{subsec:ic}
\noindent
In this subsection, we give a formal model of mechanism design with single-minded agents based on our C-KP problem setting, state the monotonicity condition, and specify the incentive compatible payments under it.  Single-minded agents are first introduced by Lehmann et al. \cite{LOS99mono}, and here we essentially present the model described in \cite{BKV05KS}.  Readers can refer to \cite{N07book, NR01alg} for a formal definition of the general setting of mechanism design.

We are given a set  of agents, where agent  controls item .  The demand and value of item  is agent 's private information, which is called his {\em type}, denoted by .   Each agent  is single-minded: he has the single demand  in mind, and enjoys value  if and only if his demand is satisfied.  

Here, with selfish behaviors, satisfying the demand of an agent is no longer the same as selecting an agent, since an agent may get selected by reporting a lower demand, but the assignment he receives is only guaranteed to cover his reported demand, which may not be enough for his true demand.  Therefore, we need to modify an outcome  of an allocation algorithm from the indicator variable  for each agent  to a specific assignment  agent  receives (clearly  when ).  Let  denote all complex numbers in the first quadrant of the complex plane, we have  and .  

Now we are able to represent the value agent  derives from an outcome  by his {\em valuation function}:  if  and 0 otherwise.  Conventionally we abuse the notation and use  to denote the valuation function associated with type .  The comparison  interprets the condition that the assignment meets the demand.
For C-KP, it conforms to the partial order between complex numbers:  iff  and .  It can also be generalized to settings where the outcome set admits a partial order and a minimum element.  As required in the general model of mechanism design, our valuation function only depends on the outcomes, which also justifies the necessity to change our representation of outcomes.  

For ease of notation, we let  denote an input, a list of all agents' types  and denote the input except that of agent  by .  Clearly .\footnote{Unless specified as the true type,  may denote any reported type.}

A {\em mechanism}  consists of an allocation algorithm  computing an allocation solution  for each input  and a -tuple  for each  where  is the payment enforced on agent .  If , we say that agent  is selected, i.e., he receives an assignment that meets his input demand.  We represent the set of selected agents as . 
Given the mechanism, the {\em utility}, the overall benefit of agent , when his true type is , equals his valuation minus the payment: .

As mentioned in Section \ref{sec:introduction}, given the mechanism, each agent may not report his true type for his own benefit.  Suppose agent  has true type  and reports .  Here the outcome of the algorithm  is , but his valuation function remains , so he obtains valuation , and his utility is .  On the other hand, if he reports his true type, his utility is .  Each selfish agent intends to maximize his utility, so he will choose to misreport  if it results in higher utility, assuming other agents do not change their input, i.e., .  Therefore, a mechanism is {\em incentive compatible}, or {\em truthful}, if and only if this can not happen, which is equivalent to saying that, for any agent , any  and any true type , truth-telling maximizes agent 's utility, i.e.,  for any possible .    

A sufficient condition to ensure truthfulness for single-minded agents is {\em monotonicity}, specified as follows in our setting:

\begin{definition}\label{def:mon}
An allocation algorithm  is {\em monotone} if  implies  for any  and  with , . 
\end{definition}
Intuitively, in a monotone algorithm, if agent  is selected with demand  and value , he should be also selected when he has smaller demand  and larger value .\footnote{Note that in this definition, the specific assignments  are irrelevant, so in Section \ref{sec:monalg}, we can stay with our original problem formulation when we argue about the monotonicity of our algorithm.}  
The following theorem states the sufficiency of monotonicity \cite{BKV05KS,LOS99mono}:
\begin{theorem}
\label{thm:IC}
Let  be a monotone and exact algorithm for single-minded agents.  Then there exists payment  such that  is incentive compatible.
\end{theorem}

We call a mechanism {\em exact} if for all inputs  and all agents ,  is either  or , i.e., either the exact demand is satisfied or nothing is assigned.  Without exactness, an agent may benefit from underreporting his demand.  It is not difficult to see that we can always modify a truthful mechanism to be exact.  After all, exactness is a reasonable assumption since it is undesirable to waste resource in our allocation.     

The incentive compatible payment  is specified as follows:
Given a monotone algorithm , if we fix  and  for agent , then  defines a {\em critical value} , such that when  is above the critical value,  is selected; and when  is below the critical value,  is not selected.  Then we can define a payment function , where each selected agent pays the critical value:  

By Theorem~\ref{thm:IC}, if we are able to design a monotone algorithm, we can transform it into a truthful mechanism.  Moreover, the critical value for a given input can be computed in polynomial time by a binary search on interval  for each agent  during which we repeatedly test if  is satisfied by running algorithm . Therefore, a monotone polynomial time allocation algorithm  implies a polynomial time truthful mechanism.

In addition, the payment function  guarantees that all agents receive nonnegative utilities.  This property, called {\em individual rationality}, ensures voluntary participation of the agents, thus is also an important desired property in mechanism design.   
 
Therefore, the monotone polynomial time algorithm for C-KP we will present in Section \ref{sec:monalg} implies a polynomial time mechanism that is both individually rational and incentive compatible.  

We need to point out that the mechanism requires the item values  to be integers, because of the binary search needed in the payment computation.  This is a reasonable assumption, since values are usually rounded up to the nearest cent or dollar.  The approximation algorithm in Section \ref{sec:algCKP} does not need this assumption, since the FPTAS for 1-KP rounds the item values.   


\section{Approximation Algorithm for \\C-KP}\label{sec:algCKP}
\noindent
We present a polynomial-time -approximation algorithm for {\sc C-KP}, which relies on a polynomial-time approximation algorithm for {\sc 1-KP} as a subroutine.   
\subsection{Basic Idea} \label{subsec:pic}
\noindent
Graphically, each demand  of item  is a vector in the first quadrant.  A feasible solution of our problem is a subset of items whose sum of demands lies in region , the  disk of radius  in the first quadrant. 
As shown in Fig.~\ref{fig:fig1},  is divided by chord  into a closed triangle  and a circular segment .  The  line intersects chord  at point .  Since we may preprocess the demands and eliminate those whose magnitude exceeds capacity , without loss of generality, we assume all .  

\begin{figure}[htb!]
 \centering 
 \includegraphics[scale=0.5]{fig1.pdf} \caption{Graphical picture for C-KP.} \label{fig:fig1}
\end{figure}



If we project all demands onto the  line, i.e., 

we make all demands one-dimensional.  Now a subset of demands has sum  (i.e., the sum vector does not go beyond point  on the  line) if and only if its original sum vector  lies inside the triangle .  This is because that, the sum of projections, , is the projection of  on the  line.  Therefore, the subproblem on feasible region  can be solved by an approximation algorithm for {\sc 1-KP} with demands changed to  and capacity to .

On the other hand, the subproblem on feasible region  is almost the whole story: First, evidently an optimal solution in  can contain at most one demand in ; second, if an optimal solution consists of more than one demand, its sum can be broken into either two separate subsums lying in , or, the sum of a vector in  and a subsum in .  Our algorithm takes the maximum between an approximate solution for the subproblem on feasible region  and an optimal solution on input demands lying in .  This only reduces the approximation ratio by at most a factor of 2.




\subsection{Approximation Algorithm}
\noindent 
We let  be our algorithm for {\sc C-KP}, where  are the complex-valued demands and values of items and  is the capacity. Moreover, we let  be a polynomial-time approximation algorithm for {\sc 1-KP}, where each demand is real-valued.
We describe our algorithm as follows:

\begin{algorithm}[htb!]
\caption{}
\begin{algorithmic}[1]
\FOR{} 
\STATE Set 
\ENDFOR
\STATE Set 
\STATE Set 
\STATE Set 
\STATE Output 
\end{algorithmic}
\end{algorithm}

In , we first project all demands onto the  line, 
and use an approximation algorithm  for {\sc 1-KP} to compute an allocation (denoted by ) considering the projected demands and capacity .  Then we look at all demands lying in region  and choose one with maximum value as solution .  Note that  only consists of a single item.  Finally, we compare the total value of solutions  and  and pick the larger one.  All ties are broken arbitrarily.   



\subsection{Analysis}
\noindent
It is evident that our algorithm outputs a feasible solution in polynomial time.  For the approximation ratio, our main result is:

\begin{theorem} 
\label{thm:2apx}
If  is a -approximation algorithm for {\sc 1-KP}, then  is a -approximation algorithm for {\sc C-KP}.
\end{theorem}


\begin{corollary}
\label{cor:2apx}
Since {\sc 1-KP} has an FPTAS \cite{BKV05KS, KPP10book}, there is a -approximation algorithm for {\sc C-KP} that runs in polynomial-time in the size of input and , for any .
\end{corollary}   

Now we prove Theorem \ref{thm:2apx}.
\begin{proof}
Let  be an optimal solution to C-KP, for which the feasible region is .  Let ,  be an optimal solution for the subproblem on feasible region  and  respectively.  By our observation in Subsection \ref{subsec:pic},  is an optimal solution to 1-KP on projected demands and capacity .  Since  is a -approximation algorithm to {\sc 1-KP}, we have .  It is also evident that .

Next, we analyze the approximation ratio of  in three cases.  Here for a subset , we define 


\noindent {\bf Case (1): (-approximation) } We consider an optimal solution , such that its sum of demands .  

This is an easy case where .  We have .
\vskip 5pt

\noindent {\bf Case (2):  (-approximation) } We consider an optimal solution , such that , and there exists an item  whose demand .  

Let . Thus, , i.e., the sum of demands of  can be written as the sum of a single demand  and a subset sum .\footnote{It is possible that  only consists of a single item , in which case our algorithm obviously produces the optimal answer.}  Note that  and . Otherwise, the projection of  on the  line would exceed .  

Moreover, we have , because  is an optimal solution for feasible region .  On the other hand,  since item  with  is a candidate for  in our algorithm.  
We obtain:


By the description of our algorithm, the total value of the output solution .  Now it remains to show that it is further .

If , we have that  is at least 

otherwise,  is at least  





\noindent {\bf Case (3): (-approximation) } We consider an optimal solution , such that , and  for every item .

First, we let .  The condition on  is equivalent to the following condition on 
projected demands on the  line: , and  for every item .

We use Lemma \ref{lem:subsetsumA} to show that  can be written as the sum of two demand subset sums in .  Lemma \ref{lem:subsetsumA} is essentially an equivalent statement of this on the projected demands, and will be proved later in this subsection.     

\begin{lemma} \label{lem:subsetsumA}
For a set of  positive real numbers  satisfying ,   for all  and , there exists a subset  such that

\end{lemma}

By Lemma \ref{lem:subsetsumA}, we have  and  for some subset . That is,  and .

Thus,  and .  Moreover, since , we have .  Hence  



Combining Cases (1)-(3): , we complete the proof of the approximation ratio of  as .
\end{proof}

Finally, we prove Lemma \ref{lem:subsetsumA}:

\begin{proof} 
The case  is trivial.  Otherwise, 
let  be the smallest index such that the partial sum exceeds , i.e.,  and .  Clearly  since all .

Let ,  and .  

Note that .  We already have 


The lemma holds if , because we can set .  

If , then we obtain:

because .
Hence, we can set .  
\end{proof}

\section{Monotone Approximation Algorithm for C-KP}\label{sec:monalg}
\noindent
As mentioned in Subsection \ref{subsec:ic}, a monotone polynomial time algorithm for C-KP
implies an incentive compatible polynomial time mechanism.  However, our approximation algorithm  presented in Section \ref{sec:algCKP} does not seem to have an easy proof for monotonicity.
In this section, we give a slight modification of , for which monotonicity becomes immediate and the approximation ratio is preserved.

\subsection{Basic Idea} \label{subsec:pic}
\noindent
In , monotonicity is not guaranteed due to the comparison between  and , the total value of solution  and .  Although we assume  for {\sc 1-KP} is monotone,  can fluctuate since  is an approximate solution.  Our trick here is to transform each solution candidate for , a single item  with demand , to be a solution candidate for : an item of the same value whose demand is exactly the capacity limit  for .  These new items will not combine with each other or with any original items to form new solution candidates for .  Then our new algorithm  only needs to run  on the modified set of items to produce a solution for C-KP.  
  

\subsection{Approximation Algorithm} 

\begin{algorithm}[htb!]
\caption{}
\begin{algorithmic}[1]
\FOR{} 
\STATE Set 
\ENDFOR
\STATE Set 
\STATE Output 
\end{algorithmic}
\end{algorithm}

\noindent Recall that we assume every demand  lies in  ().  The preprocessing  does exactly the transformation mentioned above: For , we simply do the projection onto the  line; otherwise, , its projection is larger than , and we cut it off to .  Then we run  on the modified projected demands and outputs the answer.  

The following theorem states that our modification of the algorithm does not change the approximation ratio:
\begin{theorem} 
\label{thm:2apxb}
If  is a -approximation algorithm for {\sc 1-KP}, then  is a -approximation algorithm for {\sc C-KP}.
\end{theorem}

The proof of Theorem \ref{thm:2apxb} is essentially the same as that of Theorem \ref{thm:2apx}.  The main difference is that, now instead of an explicit comparison between the solutions  and  to the two subproblems on region  and  respectively, our algorithm make it implicit inside the execution of .  Therefore, in the formal proof below, we have to define the two subproblems explicitly and show that the total value of our output .  

The case analysis is easy given this inequality.  Although  has a better approximation guarantee in terms of the inequality , overall, we achieve the same approximation ratio of .  Just for case (2), we can only prove an approximation ratio of , instead of  for .  


\begin{proof}
We partition  into two disjoint sets  and , such that  and . Note that the projection of any demand in  onto the  line is at most , whereas that in  is larger than .


Let  be the output of , when the input is . Let  be the output of , when the input is .  Let  and  be their corresponding optimal solutions.   is an optimal solution to {\sc 1-KP} on projected demands within capacity , hence is an optimal solution to {\sc C-KP} on feasible region .  On the other hand, since each demand in  is changed to one exactly equal to the capacity limit of {\sc 1-KP}, only one of them can be satisfied.  Hence  chooses the one with maximum value .  

Since any demand in  will not combine with any in  to form new feasible solutions to {\sc 1-KP},  outputs either a solution whose sum vector lies in  or a singleton set of a demand in , which is evidently a feasible solution to {\sc C-KP}.

Optimally  would output .  Since  is a -approximation algorithm to {\sc 1-KP}, we have . 

Based on this inequality, it is easy to go through the case analysis in the proof of Theorem \ref{thm:2apx} (with slight modifications), hence we omit the rest of the proof here.  
\end{proof}
On the other hand, our new algorithm is monotone according to Definition \ref{def:mon}. 

\begin{theorem} \label{thm:mon}
If  is a monotone algorithm for {\sc 1-KP}, then  is a monotone algorithm for {\sc C-KP}.
\end{theorem}

\begin{proof}
We need to show that, if item  is selected by  with demand  and value ,  is also selected with demand  and value , where  and  (i.e.,  and ), while all inputs of other agents do not change.  

Item  is selected by  on  and  if and only if it is selected by  on  and . 
Since ,  and  implies . Then from the monotonicity of ,  is selected by , and hence by .
\end{proof}

Combining Theorem \ref{thm:2apxb}, Theorem \ref{thm:mon} with Theorem \ref{thm:IC} gives:\footnote{Note that algorithms are exact under this problem formulation where a solution is specified as the selection of a subset of items.} 
\begin{corollary}
\label{cor:2apxb}
Since {\sc 1-KP} has a monotone FPTAS \cite{BKV05KS}, there is an incentive compatible -approximation algorithm for {\sc C-KP} that runs in polynomial-time in the size of input and , for any .
\end{corollary} 


\section{Inapproximability for C-KP}\label{sec:inappr}
\noindent
In this section, we complete the study of {\sc C-KP} by providing an inapproximability result. We show that {\sc C-KP} does not admit an FPTAS, unless P = NP.

We remark that it is known there is no FPTAS for {\sc 2-KP} (see \cite{KPP10book}), which does not have direct implications for {\sc C-KP}.  However, our proof is an extension of the basic idea in the proof for {\sc 2-KP}. 

As in the reduction for 2-KP, we reduce the {\sc equipartition} problem to {\sc C-KP}:

\begin{definition} ({\sc equipartition} Problem): Given a set of positive integers , with  where  is even, we determine if there is a subset of items  such that

\end{definition}
It is well-known that {\sc equipartition} is NP-complete.


\begin{theorem}
There is no FPTAS for {\sc C-KP}, unless P = NP.
\end{theorem}
\begin{proof}
We define a decision version of {\sc C-KP} with a cardinality objective: given , a capacity bound  and a cardinality bound , we determine if there is a subset of items  such that


Now we map every instance of {\sc equipartition} to an instance of the {\sc C-KP} decision problem that always yields the same answer.
  

Given  from {\sc equipartition}, define 


where , .  Note that in our reduction, .

As shown in Fig.~\ref{fig:inapprox}, the feasible region  for {\sc C-KP} is the  disk of radius  in the first quadrant.  Since for any subset , 
,
the cardinality constraint  imposes all solutions to have its sum vector in the halfplane  .  The dividing line of  goes through point  .  Our main idea is to set  such that the dividing line of  coincides with the tangent line at .  Thus we make the intersection of  and  exactly , which implies    
 and  for any solution  to our reduced {\sc C-KP} decision problem instance.

\begin{figure}[htb!]
 \centering
 \includegraphics[scale=0.5]{inapprox.pdf} \caption{Reduction of inapproximability.} \label{fig:inapprox}
\end{figure}

On the other hand, it is clear that each subset  satisfying conditions of {\sc equipartition} also satisfies conditions of the reduced {\sc C-KP} decision problem.  Therefore, the solution of the reduced {\sc C-KP} decision problem is equivalent to the solution of {\sc equipartition}.

To determine a proper , since the dividing line of halfplane  goes through , it coincides with the tangent line at  if and only if they have the same slope, i.e.,

Solving the above equation, we obtain

which is  unless all weights are equal.  In this case, we set , and it is trivially a "yes" instance for both {\sc equipartition} and our C-KP decision problem.

So far we have shown the NP-hardness of the C-KP decision problem.  So its maximization version, where  is replaced by , is NP-hard.  We use the standard technique to prove the inapproximability of the maximization version by FPTAS. Suppose that there exists an FPTAS for any  in time polynomial in  and . Then we choose . Let the optimal solution be  and that of the approximation solution produced by FPTAS be . We obtain:

because . Moreover, since  is an integer, this implies that the FPTAS can solve the problem exactly in polynomial time, contradicting the NP-hardness of the problem. 

Finally, since the maximization version of C-KP decision problem is a special case of the original C-KP with all , there is no FPTAS to {\sc C-KP}. 
\end{proof} 
\section{Approximation Algorithm for \\GC-KP}\label{sec:algGCKP}
\noindent
We are also able to solve the generalized problem {\sc GC-KP}, by changing our approximation algorithm  in Section \ref{sec:algCKP}. Now, instead of an approximation algorithm  for {\sc 1-KP} as a subroutine, we rely on an approximation algorithm for {\sc 3-KP} (three-dimensional knapsack problem) as a subroutine. 


\subsection{Basic Idea} \label{subsec:picGen}
\noindent
Now a feasible solution of our problem is a subset of items whose sum of demands lies in the intersection of halfplanes , , and the  disk of radius  in the first quadrant.  In the most general case (), both halfplanes cut the circle, which also cut the original regions  and  defined in Section \ref{sec:algCKP}.
Fig.~\ref{fig:fig3} shows the new  (polygon ) and .  Clearly, the feasible region  is the disjoint union of  and .  

\begin{figure}[htb!]
 \centering 
 \includegraphics[scale=0.5]{fig3.pdf} \caption{Graphical Picture for GC-KP.} \label{fig:fig3}
\end{figure}

Recall that  is perpendicular to  and the length of  is .  If we denote the projection of a demand  onto line  by , the region  corresponds to 3-dimensional linear constraint ,
 and .  Thus the subproblem on feasible region  can be solved by a 3-dimensional knapsack algorithm.   

On the other hand, the solutions in polygon  is almost the whole story by the same reason as in Section \ref{sec:algCKP}.  Again our algorithm takes the maximum between an optimal solution for the subproblem on feasible region  and an optimal solution on input demands lying in . This reduces the approximation ratio by at most a factor of 2.


The degenerate cases ( or  or both) can be treated easily by setting  to be the intersection point of the circle and the -axis, or setting  to be the intersection point of the circle and the -axis, or both.  

\subsection{Approximation Algorithm}
\noindent
Let  be our approximation algorithm for {\sc GC-KP}, where  are the capacity on magnitude, real part and imaginary part of total satisfiable demand respectively. Let  be an approximation algorithm for {\sc 3-KP} (e.g., from \cite{FC84alg} or \cite{KPP10book}).   
We describe our approximation algorithm to {\sc GC-KP} as follows:

\begin{algorithm}[htb!]
\caption{}
\begin{algorithmic}[1]
\FOR{} 
\STATE Set 
\ENDFOR
\STATE Set 
\STATE Set 
\STATE Set 
\STATE Output 
\end{algorithmic} 
\end{algorithm} 

Our  follows the same structure as  for C-KP.  The difference is that, for GC-KP, the subproblem on feasible region  is equivalent to an instance of 3-KP, since  is defined by three halfplanes.  And to check if a demand  lies in region , we need to check four inequalities: , ,  and . 

\begin{theorem} 
\label{thm:g2apx}
If  is a -approximation algorithm for {\sc 3-KP},   is a -approximation algorithm for {\sc GC-KP}.
\end{theorem}

\begin{corollary}
\label{cor:g2apx}
Since {\sc 3-KP} has a PTAS \cite{FC84alg}, there is a -approximation algorithm for {\sc GC-KP} that runs in polynomial-time in the size of input, for any .
\end{corollary}  


We omit the proof of Theorem \ref{thm:g2apx} here since it is essentially the same as that of Theorem \ref{thm:2apx} for C-KP.  


\section{Conclusions and Future Work}\label{sec:conc}
\noindent
The knapsack problem has been one of the most popular algorithmic problems since it is a simple abstraction that captures the tradeoff between limited resource and value maximization in resource allocation.  In this paper, motivated by the need to model AC electrical systems, where power demands have to be represented as complex numbers, we initiate the study of a new variation called the {\em complex-demand knapsack problem} (C-KP).  

By investigating its relationship with multi-dimensional knapsack problems (-KP), we provide -approximation algorithms for C-KP and its generalization GC-KP; on the other hand, we also show its inapproximability by FPTAS unless P = NP.  Furthermore, our approximation algorithm for C-KP can be monotonized, which implies the existence of a mechanism/algorithm of the same approximation ratio that is incentive compatible, individually rational, and computationally efficient.                

Our results provide basic insights on efficient power allocation in AC electrical systems, which is a fundamental problem in the design of multi-agent systems for smart grid.
Still, there are interesting directions to continue in the future: First, we hope to find a PTAS for C-KP, closing the gap between constant approximation and FPTAS, and a monotone algorithm for GC-KP.  Second, we will extend the problem to an electrical network setting, where there is an underlying network connecting different devices with links of different capacities on the magnitude of transmitted power.  For mechanism design, we may require an additional property called {\em cancellability}: the total payment to be collected from the agents should always cover the cost to generate the power supply, given a cost function of power generation.  We are not aware of any previous work related to this property in mechanism design, and we expect new insights and techniques coming out of the study on it.       

\medskip
\noindent {\bf Acknowledgments\ } 
We thank Mario Szegedy and anonymous referees for useful suggestions.  Lan Yu is supported by Singapore NRF Research Fellowship 2009-08.  Chi-Kin Chau is supported by MI-MIT Collaborative Research Project (11CAMA1).
\bibliographystyle{abbrv}
\bibliography{reference}






\end{document}