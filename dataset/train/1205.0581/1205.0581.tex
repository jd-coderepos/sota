\documentclass[12pt]{article}

\usepackage{amsthm, amsmath,amsfonts, amssymb}
\usepackage{fullpage,hyperref}

\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{xspace}
\usepackage{graphicx}


\theoremstyle{definition}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{exercise}[theorem]{Exercise}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{conjecture}[theorem]{Conjecture}



\newcommand{\ie}{\emph{i.e.}}
\newcommand{\eg}{\emph{e.g. }}
\newcommand{\Uplus}{U^{+}}
\newcommand{\Uminus}{U^{-}}
\newcommand{\U}{\mathcal{U}}
\newcommand{\E}{\mathcal{E}}
\renewcommand{\S}{\mathcal{S}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\Fq}{\mathbb{F}_q}
\newcommand{\gbar}{\bar{g}}
\newcommand{\findVerificationFunction}{\emph{VerificationFunction}\xspace}
\newcommand{\sand}{\;\land\;}
\newcommand{\Pjt}{P_{j,t}}


\DeclareMathOperator{\polylog}{polylog}
\newcommand{\upStage}{\emph{Up-Stage}\xspace}
\newcommand{\downStage}{\emph{Down-Stage}\xspace}
\newcommand{\recursiveShares}{\emph{RecursiveShares}\xspace}

\newcommand{\fixme}[1]{\emph{\bf ****** #1}}
\newcommand{\jared}[1]{[{\bf Jared:\ } {\em #1}]}
\newcommand{\varsha}[1]{[{\bf Varsha:\ } {\em #1}]}


\begin{document}



\title{Scalable Mechanisms for Rational Secret Sharing}

\author{Varsha Dani \thanks{Department of Computer Science,  
University of New Mexico,  Albuquerque,  NM 87131-1386;
email: {\tt \{varsha, movahedi, saia\}@cs.unm.edu}. 
This research was partially supported by NSF CAREER Award 0644058,
NSF CCR-0313160, and an AFOSR MURI grant.} 
\and Mahnush Movahedi \footnotemark[1] \and Jared Saia \footnotemark[1]}

\date{}

\maketitle
\begin{abstract}

We consider the classical secret sharing problem in the case where all
agents are selfish but rational. In recent work, Kol and Naor show
that, when there are two players, in the non-simultaneous communication model, i.e.\ when rushing is
possible, there is no Nash equilibrium that ensures both players learn
the secret.  However, they describe a mechanism for this problem, for any number of players, that
is an \emph{-Nash equilibrium}, in that no player can gain more than 
utility by deviating from it. Unfortunately, the Kol and Naor
mechanism, and, to the best of our knowledge, all previous mechanisms
for this problem require each agent to send  messages in
expectation, where  is the number of agents.  This may be
problematic for some applications of rational secret sharing such as
secure multi-party computation and simulation of a mediator.

We address this issue by describing mechanisms for rational
 secret sharing that are designed for large .  Both of our results hold for , and are Nash equilbria, rather than just -Nash equilbria.
 Our first result is a mechanism for -out-of- rational secret sharing that is \emph{scalable} in the sense that it requires each agent to
send only an expected  bits.  Moreover, the latency of this
mechanism is  in expectation, compared to  expected
latency for the Kol and Naor result.  Our second result is a mechanism for a
relaxed variant of rational -out-of- secret sharing where .  It requires each processor to send  bits and
has  latency.  Both of our mechanisms are non-cryptographic, and
are not susceptible to backwards induction.
\begin{flushright}
\emph{``Three can keep a secret if two of them are dead.''}\\ -
Benjamin Franklin
\end{flushright}
\end{abstract}


\section{Introduction}
Secret sharing is one of the most fundamental problems in security,
and is an important primitive in many cryptographic protocols,
including secure multiparty computation.  Recently, there has been
interest in solving \emph{rational secret
  sharing}~\cite{kol2008games, gordon2006rational, halpern2004rational, 
abraham2006distributed,lysyanskaya2006rationality}.
In this setting, there are  selfish but rational agents, and we
want to distribute shares of a secret to each agent, and design a
protocol for the agents ensures that: (1) if any group of  agents
follow the protocol they will all learn the secret; and (2) knowledge
of less than  of the shares reveals nothing about the secret.
Moreover, we want our protocol to be a \emph{Nash equilibrium} in the
sense that no player can improve their utility by deviating from the
protocol, given that all other players are following the protocol.

Unfortunately, all previous solutions to this problem require each
agent to send  messages in expectation, and so do not scale to
large networks.  Rational secret sharing is a primitive for rational
multiparty computation, which can be used to compute an arbitrary
function in a completely decentralized manner, without a trusted
external party.  A typical application of rational multiparty
computation might be to either run an auction, or to hold a lottery to
assign resources in a network.  It is easy to imagine such
applications where the number of players is large, and where it is
important to have algorithms whose bandwidth and latency costs scale
well with the number of players.  Moreover, in a game theoretic
setting, standard tricks to circumvent scalability issues, like
running the protocol only on a small subset of the players, may be
undesirable since they could lead to increased likelihood of bribery
attacks.

In this paper, we address this issue by designing scalable mechanisms
for rational secret sharing.  Our main result is a protocol for
rational -out-of- secret sharing that (1) requires each agent to
send only an expected  bits; and (2) has  expected
latency.  We also design scalable mechanisms for a relaxed variant of
-out-of- rational secret sharing in the case where  is
. We note however that we pay for these improvements by requiring 
the payers to send  rather than a constant number of bits per round.


\subsection{The Problem}

Shares of a secret are to be dealt to  rational but selfish
players, who will later reconstruct the secret from the shares. The
players are \emph{learning-preferring,} in the sense that each player
prefers every outcome in which he learns the secret to any outcome in
which he does not learn the secret.  We note that in some previous
work~\cite{kol2008games,abraham2006distributed} it is further assumed
that the players are \emph{competitive}: they prefer that others do
not learn secret. However, this assumption is used mainly for the
purpose of proving lower bounds, and is omitted in the upper bounds.
We will \emph{not} make this additional assumption.

The secret is an arbitrary element of a large (fixed) finite field
.  At the beginning of the game, a dealer provides the shares to
the players.  The dealer has no further role in the game. The players
must then communicate with each other in order to recover the secret.

Communication between the players is \emph{point-to-point} and through
secure private channels. In other words, if player A sends a message
to player B, then a third player C is not privy to the message that
was sent, or indeed even to the fact of a message having been sent.
Communication is \emph{synchronous} in that there is an upper-bound
known on the maximum amount of time required to send a message from
one player to another.  However, we assume \emph{non-simultaneous}
communication, and thus allow for the possibility of \emph{rushing},
where a player may receive messages from other players in a round
before sending out his own messages.

Our goal is to provide protocols for the dealer and rational players
such that the players following the protocol can reconstruct the
secret.  Moreover, we want a protocol that is \emph{scalable} in the
sense that the amount of communication and the latency of the protocol
should be a slow growing function of the number of players.


\subsection{Related Work}

Since its introduction by Halpern and Teague
in~\cite{halpern2004rational}, there has been significant work on the
problem of rational secret sharing, including results of Halpern and
Teague~\cite{halpern2004rational}, Gordon and
Katz~\cite{gordon2006rational}, Abraham et
al.~\cite{abraham2006distributed}, Lysyanskaya and
Triandopoulos~\cite{lysyanskaya2006rationality} and Kol and
Naor~\cite{kol2008games}.  All of this related work except
for~\cite{kol2008games}, assumes the existence of simultaneous
communication, either by broadcast or private channels.  Several of
the protocols proposed~\cite{gordon2006rational,
  abraham2006distributed, lysyanskaya2006rationality} make use of
cryptographic assumptions and achieve equilibria under the assumption
that the players are computationally bounded.  The protocol
from~\cite{abraham2006distributed} is robust to coalitions; and the
protocol from~\cite{lysyanskaya2006rationality} works in the situation
where players may be either rational or adversarial.

The work of Kol and Naor~\cite{kol2008games} is closest to our own
work.  They show that in the non-simultaneous broadcast model (\ie,
when rushing is possible), there is no Nash equilibrium that ensures
all agents learn the secret, at least for the case of two
players. They thus consider and solve the problem of designing an
-Nash equilibrium for the problem in this communication
model.  An -Nash equilibrium is close to an equilibrium in
the sense that no player can gain more than  utility by
unilaterally deviating from it. Furthermore, the equilibrium they
achieve is \emph{everlasting} in the sense that after any history that
is consistent with all players following the protocol, following the
protocol continues to be an -Nash equilibrium.  As we have
already discussed, our protocols make use of several clever ideas from
their result.

The impossibility of a Nash equilibrium for two players carries over
to the setting with secure private channels, since there is no
difference between private channels and broadcast channels when there
are only two players. However, one might hope that the algorithm of
Kol and Naor~\cite{kol2008games} could be simulated over secure
private channels to give an everlasting -Nash
equilibrium. Unfortunately, simulation of broadcast over private
channels is expensive, requiring each player to send 
messages per round.

In \cite{RSSpodc11} we overcame this difficulty, providing a
\emph{scalable} algorithm for rational secret sharing, in which each
player only sends  bits per round and the expected number of
rounds is constant (although each round takes 
time). Moreover, following the protocol is an -Nash
equilibrium. Unfortunately, a certain bad event with small but
constant probability caused some players, when they recognized it, to
deviate from the protocol so that the equilibrium is not everlasting.
This paper is the full version of \cite{RSSpodc11}.  However, we
improve on the work in \cite{RSSpodc11} in two ways.  First, we remove
all probability of error for -out-of- secret sharing, and
improve the probability of error for -out-of- from a constant to
an inverse polynomial.  Second, we show that our new protocol is a
Nash equilibrium, not just an -Nash equilibrium, as long as
.

\subsection{Our Results}

The main result of this paper is presented as Theorem~\ref{thm:main}.
This theorem builds on work from our extended abstract
in~\cite{RSSpodc11}.  It also improves on this result in two ways.
First, our new protocol eliminates the probability of failure when
compared with the protocol in~\cite{RSSpodc11}.  Second, our new
protocol has the added advantage of being a Nash equilibrium, not
merely an -Nash equilibrium.
 
\begin{theorem}\label{thm:main}
Let . There exists a protocol for rational -out-of-
secret sharing with the following properties.
\begin{itemize}
\item The protocol is an everlasting Nash equilibrium in which all
  players learn the secret.
\item The protocol, in expectation, requires each player to send
   bits, and has latency .
\end{itemize}
\label{thm:nofn}
\end{theorem}

We also consider the problem of -out-of- rational secret sharing
for the case where .  Designing scalable algorithms for this
problem is challenging because of the tension between reduced
communication, and the need to ensure that \emph{any} active set of
 players can reconstruct the secret.  For example, consider the
case where each player sends  messages.  If , even if the set of active players is chosen \emph{randomly}, it
is likely that there will be some active player that will never
receive a message from any other active player.  Moreover, even if
, if the set of active players is chosen in a worst case
manner, it is easy to see that a small subset of the active players
can easily be isolated so that they never receive messages from the
other active players, and are thus unable to reconstruct the secret.

Despite the difficulty of the problem, scalable rational secret
sharing for the -out-of- case may still be of interest for
applications like the Vanish peer-to-peer
system~\cite{geambasu2009vanish}.  To determine what might at least be
possible, we consider a significantly relaxed variant of the problem.
In particular, we require  and that the set of 
active players be chosen independently of the random bits of the
dealer.  In this setting we prove the following.

\begin{theorem}
Let .  For any fixed positive , and threshold
, there exists a protocol for rational secret sharing with
absent players, which with probability at least  has
the following properties, provided that the subset of  active
players is chosen independently of the random bits of the dealer:
\begin{itemize}
\item The protocol is a Nash equilibrium.
\item The protocol ensures that if at least a 
  fraction of the players are active, (i.e. \,) then all active players will learn the secret; and if
  less than a  fraction of the players are active,
  (i.e. \,) then the secret can not be
  recovered
\item The protocol requires each player to send  bits,
  and has latency 
\end{itemize}
\label{thm:mofn}
\end{theorem}

This is an improvement to the -out-of- result we proved
in \cite{RSSpodc11}, in the sense that the probability of error
in~\cite{RSSpodc11} is a small constant, but here it is .
However, we cannot completely eliminate the probability of failure.

\subsection{Our Approach}

The difficulty in designing a Nash equilibrium in a communication
model where rushing is possible, is that the last player to send out
his share has no incentive to actually do so.  He already has the
shares of all the other players and can recover the secret alone. To
get around this, it is common (see \cite{halpern2004rational,
  abraham2006distributed, gordon2006rational,
  lysyanskaya2006rationality, kol2008games}) for the protocol to have
a number of fake rounds designed to catch cheaters. The uncertainty in
knowing which is the ``definitive'' round, during which the true
secret will be revealed causes players to cooperate.

In the work of Kol and Naor~\cite{kol2008games} this uncertainty is
created by dealing one player only enough data to play until the round
preceding the definitive one.  Thus, there is a single ``short''
player and  ``long'' players.  None of the players know whether
they are short or long.  The long players must broadcast their
information every round, since they cannot predict the definitive
round in advance. The short player knows the definitive round in
advance, but has no information about the secret. In the definitive
round the short player is the last to speak so that he (and all the
other players) receives the shares of all the long players and can
recover the secret. His failure to broadcast a message is what cues
the other players to the end of the game, and they too can recover the
secret. Moreover, having learned the secret, the short player cannot
pretend that he actually had a share for that round as the messages
sent by all the players are verified by a tag and hash scheme (see,
e.g., ~\cite{wegman1981new,rabin1989verifiable, kol2008games}). In
fact, it is the small but positive chance of cracking the tag and hash
scheme that results in this being an -Nash equilibrium
rather than a Nash equilibrium.

Here, we also use short and long players. However we introduce two
novel techniques to ensure scalable communication and to ensure a Nash
equilibrium.  The first technique is to arrange players at the leaves
and nodes of a complete binary tree, and require that the players only
communicate with their neighbors in the tree. The assignment of
players to the leaves is independently random every round, and their
assignment to internal nodes is related to their assignment to leaves
by a labeling of the tree that is common knowledge.  Every round of
the game, information travels up to the root where it is decoded and
then travels back down again to the leaves. The short players are the
parents of the leaves in the definitive round, so that now about half
the players are short players.

The second main idea is that we make use of an iterated secret sharing
scheme over this tree in order to divide up shares of secrets among
the players.  This scheme is similar to that used in recent work by
King and Saia~\cite{king2010breaking} on the problem of scalable
Byzantine agreement, and suggests a deeper connection between the two
problems.

As in previous works~\cite{wegman1981new,rabin1989verifiable,
  kol2008games} we use a tag-and-hash scheme to ensure that players
cannot forge messages in the protocol. We note however, that unlike in
previous work, our use of the verification scheme is such that even by
breaking it, players who have learned the secret cannot prevent other
players from learning it as well. Thus, in our case the small
probability of forging messages without detection does \emph{not}
translate into the protocol being an -Nash equilibrium.
Instead we show that our protocol is a Nash equilibrium for all the
players.

\subsection{Paper Organization}

The rest of this paper is laid out as follows.  In
Section~\ref{sec:prelim}, we give notation and preliminaries.  In
Section~\ref{s:algnofn}, we describe our algorithm for scalable
-out-of- secret sharing.  In Section~\ref{sec:analysis}, we
analyze this algorithm; the main result of this section is a proof of
Theorem~\ref{thm:nofn}.  In Section~\ref{s:mofn}, we give our
algorithm and analysis for scalable -out-of- secret sharing
where ; the main result of this section is a proof of 
Theorem~\ref{thm:mofn}.  Finally in Section~\ref{s:conclusion}, 
we conclude and give directions for future work.

\section{Notation and Preliminaries}\label{sec:prelim}

The secret to be shared is an arbitrary element of a set . 
There are  players with distinct player IDs in . 
During the course of the algorithm, we will want to do arithmetic 
manipulations with player IDs and shares of the secret, including adding 
in, or multiplying by random elements to preserve secrecy. In order to be 
able to do these sorts of manipulations, we embed the sets  
and  into a finite field  of size .
The latter embedding will be the canonical one; the former may be arbitrary, 
but is assumed to be known to all parties.

The messages sent by players in the algorithm will be elements of . 
The length of any such message is . Since our 
goal is to provide a scalable algorithm we cannot afford the message 
lengths to be much bigger than that. We will choose  to be a prime field
of size . We remark that although generally 
 is of constant size, we can tolerate .


\subsection{Utility Functions}
We will denote the utility function of player  by . As mentioned 
before, we assume that the players are learning preferring, \ie, each player 
prefers any outcome in which he learns the secret to every outcome in 
which he does not learn the secret. More formally, for outcome  
of the game, let  denote the set of players who learn the 
secret. If  and  are outcomes of the game such 
that , then 
. 
As in~\cite{kol2008games}, we denote

Thus  is the utility to player  of the best possible outcome 
for ,  is the utility to  of the worst possible outcome in 
which  still learns the secret, and  is the best possible 
utility to  when he does not learn the secret. By the learning-preferring 
assumption, we have for all ,

We will denote by , the quantity
 
Note that . We assume that  is constant, \ie, that it does 
not depend on .\footnote{Technically, we can achieve scalable (polylog)
communication even if we allow  to be as big as }

We also assume that the utilities are such that \emph{a priori} the players 
have an incentive to play the game rather than just guess the secret at 
random. In other words, we require that 

We have said earlier that  may be as big as .  If that is the case, 
then \eqref{eqn:su} is trivially satisfied since . When  is of 
constant size however, \eqref{eqn:su} is a genuine constraint. 


\subsection{Game Theoretic Concepts}
In this section we review some game theoretic solution concepts.


Recall that an -tuple of strategies for an  player game is called 
a \emph{Nash equilibrium} if no player has an incentive to unilaterally deviate 
from the equilibrium strategy, when all others are following it. 



In games of incomplete information which have multiple rounds, there is 
the further question of whether the players are forced to commit to their 
strategies before the start of the game or whether they have the option to 
change strategies in the middle of the game, after some rounds have been 
played and they may learn some new information. Kol and 
Naor~\cite{kol2008games} defined a Nash equilibrium to be 
\emph{everlasting} if after any history that is consistent with all 
players following the equilibrium strategy, it is still true (despite 
whatever new information the players may have learned over that history) 
that a player choosing to deviate unilaterally cannot gain in expectation, 
\ie, following the prescribed strategy remains a Nash equilibrium. 
This is a stronger concept than the usual Nash equilibrium, where 
the strategies are committed to up front.





\section{Algorithm For All Players Present}
\label{s:algnofn}
We now describe our scalable mechanism for -out-of- secret
sharing. First, in Section~\ref{sec:commtree} we describe the communication 
tree that is used by the dealer and players. An informal description
of the mechanism follows in Section~\ref{sec:alg}. The formal descriptions 
of the dealer's and players' protocols 
appear respectively as Algorithms~\ref{alg:Dealer} and~\ref{alg:Player}.


\subsection{The Communication Tree}\label{sec:commtree}


Recall that a complete binary tree is a binary tree in which all the 
internal nodes have exactly two descendants, all the leaves are at the 
two deepest levels, and the leaves on the deepest level are as far left 
as possible.

Our communication tree is a complete binary tree with  leaves. 
The leaves will be labelled 1 to  from left to right. Next every 
internal node which is a parent of two leaves is labelled with the 
odd label from among its two children. Finally, the remaining internal 
nodes are labelled in order with even numbers, proceeding top to bottom and left to right, starting with 2 at the root. If  is odd, then each even number
appears at some internal node. If  is even, we will place the last 
even number,  at the root, along with 2 (so the root will have two labels.)
The tree thus labelled has the following properties:
\begin{itemize}
\item Every even label occurs at some internal node. (Note that if  is 
odd, there will be an odd label that occurs only at a leaf and not at any 
internal node. This will not matter.)
\item No even labelled internal node has an odd labelled node above it.
\item Every path from root to leaf has exactly one odd label (the same odd 
label may occur once or twice on the path.)
\end{itemize}
Figure~\ref{fig:tree} illustrates the labelling scheme for five and six players.

\begin{figure}
\begin{center}
\includegraphics[scale=0.2]{trees.pdf}
\end{center}
\caption{Communication trees for five players and six players}
\label{fig:tree}
\end{figure}




\subsection{Our Algorithm}\label{sec:alg}


\begin{algorithm}
\caption{Dealer's Protocol} \label{alg:Dealer} 
 field of size  (to represent messages in the algorithm)
 players with distinct identifiers in ,
: geometric distribution parameter.
Complete binary tree with  leaves, labelled as described in 
Section~\ref{sec:commtree} known to everyone.
\begin{enumerate}
\item Choose  independently from a geometric distribution with 
parameter . Round  is the definitive one. Short players will receive 
full input for  rounds and partial input for round . Long players 
will receive full input for  rounds and partial input for round . 
For convenience we will create all the inputs for  rounds, and 
truncate them appropriately before sending them to the players.
\item For each round  between 1 and :
\begin{itemize}
\item If , choose a random permutation . 
If  choose a permutation  which is random subject to the 
constraint that all the long players (determined by ) are assigned 
to odd labels under .
For round  player  
will be assigned to all nodes marked  in the tree. 
\item If ,  // (Otherwise  was set in the previous round)
\item For every player , ,
is a tuple of elements of  representing 's position and the identities 
of his neighbors in the tree for round . 

is a masked version.
\item Choose a random mask  (for the {\bf next} round.)
\item Create shares of  by calling 
\recursiveShares.
\item If   true secret.\\
 Otherwise,  random element of 
\item Create shares of  by calling \recursiveShares.
\item Create tags and verification functions for all the messages to be 
sent in round 
\item For each player , 's (full) input  for round   
consists of , shares of  and  corresponding to node 
, tags to authenticate all messages to be sent by  and 
verification vectors for all the 
messages to be received by . Partial input  consists of 
all of the above except the authentication tags for sending messages to your 
children (in the down-stage).
\end{itemize}
\item Identify the short players as those players  who are at odd numbered 
nodes in the definitive iteration, \ie,  is odd.
\item For each short player , send  the list 
.
\item For each long player , send  the list 
.
\end{enumerate}
\end{algorithm}


\begin{algorithm}
\caption{ \recursiveShares(node  , -element ):}\label{alg:shares}
-leaf complete binary tree global data structure ; for node , 
 denotes the location for the data associated with .\\
Initially called with the root node and the value for which shares are to be 
created, this function populates  with 
intermediate values. The values at the leaves are the shares for the players 
at the corresponding leaves of the  communication tree.
\begin{enumerate}
\item .
\item If  has children  and :
	\begin{enumerate}
	\item Choose random slope  from field .
	\item Let  be the line with slope  and y-intercept .
	\item .
	\item .
	\end{enumerate}
\end{enumerate}
\label{alg:recursiveShares} 
\end{algorithm}

\begin{algorithm}
\caption{Create Authentication Data (-element ,):   
//  is the message to be transmitted} \label{alg:verification}
\begin{enumerate}
\item Choose  and  independently, 
uniformly at random.
\item .
\item  is the tag, to be given to the sender of message ,  is the 
verification vector, to be given to the recipient of the message .  
\end{enumerate}
\end{algorithm}

\begin{algorithm} 
\caption{Protocol for Player } \label{alg:Player} 
S=0; M=0 \\
If at any time you receive spurious messages (messages not expected uder the 
protocol), ignore them. \\
On round :
\begin{itemize}
\item[] \upStage:
\begin{enumerate}
\item 
\item Subtract  from all elements of  to find out your position 
in the tree and the identities of your neighbors for round .
\item (as player at a leaf) Send your shares of  and  along with 
their tags to your parent in the tree.
\item (as player at an internal node) 
\begin{enumerate}
\item Receive (intermediate) shares of  and  and tags from 
left and right chidren. Use the 
appropriate verification vectors to check that correct messages have been sent.
If a fault is detected (missing or incorrect message) output  and quit.
\item For each of  and : interpolate a degree 1 polynomial  
from  and . 
Evaluate . This is your share.
\item If you are not at the root, send the above reconstructed shares of  
and  to your parent(s) along with the appropriate tags. If you 
\emph{are} at the root, these shares are the actual values of  and 
.
\end{enumerate}
\end{enumerate}
\item[] \downStage:
\begin{enumerate}
\item If you are at the root, set  and  and send these 
values along with authentification tags to your left and right children.
\item Else
\begin{enumerate}
\item (as a non-root internal node) Receive  and  and tags from 
your parent and use verificaton vectors to check them. If fault detected, 
output  and quit.
\item Set  and .
\item Send  and  to your children along with the appropriate tags.
If you are a short player and have no authentication tags, output  and 
quit.
\end{enumerate}
\end{enumerate}
\item[] 
\end{itemize}
\end{algorithm}

The dealer is active only once at the beginning of the game, and during 
this phase of the game the players' inputs are prepared.

The dealer independently samples two random variables  and  from 
a geometric distribution with parameter  (to be determined later). 
 will be the definitive iteration, or the round of the game in which 
the true secret is revealed.  will be the amount of padding on the 
long players' input. Note we have two kinds of players: short players 
will receive enough input to last for  rounds of the game while long 
players will receive enough input to last for  rounds of the game.
The partitioning of players into short and long will be random, and the 
players themselves will not know which are which. This is critical in 
our analysis as is discussed in Section~\ref{sec:analysis}.

Communication between the players in our protocol will be restricted 
to sending messages to their neighbors in the communication tree.  
In order not to reveal which players are the short players, the players 
will be reassigned to new positions in the tree in each round. This is 
accomplished by choosing a random permutation of the players each round 
and assigning them to labelled nodes of the tree according to it.
The short players are the ones who are at odd labelled nodes in the 
definitive round. 

Since the players must be at different nodes in the tree each round, their 
input must contain this information. At the same time, the positions of the 
players for all the rounds cannot be revealed up front, since this may give 
away information about who the short players are. A naive idea to solve this 
problem is, in each round, to distribute shares of the permutation for the 
next round. Then 
during each round, the players could reconstruct the permutation from the 
shares and use it to reposition for the next round. Unfortunately, there 
is a problem with this approach. To represent permutations of  symbols, 
we need a field of size at least . To transmit elements of such a field,
players would need to send messages of length .
This is unacceptable if we desire scalability. 

To get around this problem, we note that it is not really necessary for 
players to know the entire permutation. Each player only needs to know 
its own position and the identities of its neighbors. We only need a field 
of size order  to encode this, and so, symbols of this field may be 
transmitted with messages of length . Since it is dificult 
via share reconstruction to transmit different messages to the leaves of 
the tree, we simply provide each player with a list of positional data for the 
entire game. But in order that players do not know their positional data 
for a round before actually getting to that round, this data is masked 
by adding in a random element of the field. Positional data for the first 
round is sent unmasked. The players also receive iterated shares of the masks
for the next round. Thus, in each round, players reconstruct a mask, and use it 
to unmask the positional data and reposition themselves for the next round.

For each round, the full input consists of the following:
\begin{itemize}
\item iterated shares of a purported secret (the true secret in the 
definitive round);
\item masked versions of positional data for the current round 
(position and identities of neighbors in the tree);
\item shares of the mask for the \emph{next round} of positional data;
\item tags for all the messages to be sent; and
\item verification vectors for all the messages to be received.
\end{itemize}

The iterated shares the players receive are constructed by 
starting with the symbol to be reconstructed at the root and 
recursively constructing 2-out-of-2 Shamir shares down the tree, all 
the way down to the leaves. The shares at the leaves are the iterated 
shares the players receive. See Figure~\ref{fig:shares} and 
Algorithm~\ref{alg:recursiveShares} for details of how the iterated shares are 
constructed. At reconstruction time, shares are sent 
up the tree. At each internal node, a pair of shares received from 
the two children is reconstructed into a degree 1 polynomial which is used 
to obtain the value to be sent further up the tree. At the root, the 
original symbol is reconstructed and transmitted down the tree.  
Note that the advantage of this scheme 
over simply using n-out-of-n Shamir shares is that the size of the 
messages does not increase as the messages are transmitted up the tree.

\begin{figure}
\begin{center}
\includegraphics[scale=0.2]{recursiveShares2.pdf}
\end{center}
\caption{Construction of the iterated shares}
\label{fig:shares}
\end{figure}



As mentioned earlier, round  is the definitive round, when the 
encoded symbol is the true secret. Short players receive full input 
for every round prior to this round. For round  they only receive 
partial input. Long players receive input for  rounds. However,
they, too receive only partial input for their last block of input. 
Otherwise, a player would be able to distinguish whether or not he is a 
short player by looking at his last block of input.
Here, partial input consists of all of the pieces of data from the full input, 
\emph{except} the tags to send the decoded message to your children in the 
down stage of the round. 

Since, in the definitive round the short players 
(with odd labels) are in the level above the leaves, and all the long 
players are at internal nodes higher than that in the tree, the long players 
have learned the secret before the short players, although since they have
input for more rounds of the game, they do not know (\ie, cannot guess) that 
it is the definitive round, and that the secret they have learned is in 
fact the  true secret. Thus they send the secret down the tree, and 
eventually it gets to the short players. Thus the short players learn 
the secret as well. Since they have no more input they know that the 
game is over and the secret is the true one. However, since they do not 
have any more authentication data, they cannot gain by remaining in the 
game and trying to fool the others into thinking that the secret has not 
yet been reconstructed. Finally, when the long players do not receive a 
message at the end of the definitive iteration, they too realize the 
game has ended and output the correct secret. 


\section{Analysis of Algorithm for All Players Present}\label{sec:analysis}

In this section we will prove Theorem~\ref{thm:main}, which shows that the secret 
sharing scheme we have described is in fact a scalable -out-of- 
secret sharing scheme, and that it is an everlasting Nash equilibrium 
in which all the players learn the secret. 

We begin by showing that our rescursive scheme for encoding a symbol into  
iterated shares (Algorithm~\ref{alg:shares}) is an -out-of- scheme.

\begin{lemma}\label{lem:shares}
Let  be a symbol that is encoded into  iterated 
shares, , by Algorithm~\ref{alg:shares}. Then 
can be decoded from all  of the shares, but knowledge of fewer than 
 of the shares reveals no information about 
\end{lemma}
\begin{proof}
That  can be decoded from all  shares follows easily from the fact 
that two points on a line determine it. Since the value at a node is the 
-intercept of a line passing through the points 
 and , it 
can be reconstructed using interpolation. Starting with the shares 
 at the leaves of the tree, we can reconstruct the 
values bottom-up, and the value at the root is  since this is 
exactly the reverse of the process used to create these shares.

To see why fewer than  shares give us no information about , 
observe that the values at the two children of the root were created by 
choosing a random slope in  for a line with  intercept , 
and then 
evaluating that line at -1 and 1. Both of these values together determine 
the line, but a single one of them does not eliminate any line as a 
possibility. Thus the values at the children of the root \emph{individually} 
contain no information about the value of the root, and in order to decode 
the value at the root, we need both the values at its children. But now, this 
reasoning applies recursively to all the internal nodes, relative to their 
children. Suppose there is a leaf of the tree at which the share is 
missing. Then the share of its parent cannot be decoded because it is 
equally likely to be any element of the . This propagates up to its 
grandparent, and then its great-grandparent and so on all the way to the root, 
so that the root cannot be decoded.  
Thus, if even one of the shares is missing, the remaining shares provide 
no information about the value of .
\end{proof}

Next, we discuss the tag-and-hash verification scheme used in the protocol. 
This scheme makes it hard for a sender to successfully fool the intended  
recipient of a message by sending a faked message. At the same time, it 
does not give the recipient of the message any information about the message 
prior to receiving it. Such schemes have been used before (see \eg 
~\cite{wegman1981new, rabin1989verifiable, kol2008games}); we include 
the following proposition for completeness.  See Lemma 1 of~\cite{rabin1989verifiable} for the proof.

\begin{proposition}\label{prop:hash}
The verification scheme (Algorithm~\ref{alg:verification}) has the following 
properties:
\begin{enumerate}
\item The verification vector contains no information about the message, \ie, 
the probability of correctly guessing the message given the verification 
vector is the same as the unconditional probability of guessing the message
\item The probability that a faked message will satisfy the verification 
function is 
\end{enumerate}
\end{proposition}









We will now focus our attention on showing that it is a Nash 
equilibrium for all the players to follow our protocol.   
Consider player  and suppose that all other players are committed 
to following the protocol. The next lemma gives a necessary criterion 
for  to have an incentive to cheat.

\begin{lemma}\label{lem:threshold}
If all other players are following the protocol, player  prefers 
to also follow the protocol, unless his probability of successfully 
cheating is at least .
\end{lemma}
\begin{proof}
Suppose  is considering deviating from the protocol. We will consider the 
deviation to be successful if either  learns the secret right away, with 
or without being caught, or he does not get caught
and is therefore still in a position to learn it later. The deviation will 
have failed if it is detected, causing the game to end without  learning 
the secret.
Let  be the probability that the deviation succeeds.
The maximum utility that  can get is . With probability , 
the game ends without  learning the secret,
in which case the maximum payoff possible is . Thus a player's 
expected utility from cheating while everyone else follows the 
protocol is at most .

On the other hand, if everyone else follows the protocol, then following 
the protocol guarantees a utility of at least . 
Thus the protocol will be a Nash equilibrium if 

Rearranging terms, we have a Nash equilibrium if 

\end{proof}

\smallskip

When and how might a player cheat? We note that since players are not 
required to commit to their strategy before starting the game, and
since the progression of the game reveals information, a player may as 
well defer his decision to cheat in a future round until that future round. 
Thus, at any given time, the decision facing the player is whether to 
cheat in the current round. In order to weigh the benefits 
of such a decision, the player needs an estimate of whether the current 
round is likely to be the definitive one. 

As remarked earlier, the purpose of having short and long players is to 
create uncertainty about when the definitive round of the game is, until it 
is too late to gain from this information.  

The players know that  is chosen from a geometric distribution with 
parameter . Thus, \emph{a priori} the 
probability that  takes on any particular value is at most , 
the most likely being , whose probability is exactly . 
As the game progresses, players receive partial information about the 
value of ; as soon as they receive their inputs they can eliminate all
values of  larger than their input length, if the game did not end on 
the first round, they learn that  and so on. Clearly, when a 
player reaches his last block of input, he knows that the current round 
is definitive. The next lemma shows that until that stage, a player's 
estimate that the current round is definitive remains small. 


\begin{lemma}\label{lem:guess}
Let  be a player who initially received input for  rounds of the game.
and let  be the current round. Then 's estimate of the 
probability that the current round is definitive, conditioned on all the 
information he has learned, is at most . 
\end{lemma}
\begin{proof}
\newcommand{\longp}{\mathcal{L}_j}
\newcommand{\shortp}{\mathcal{L}_j^{\mathrm{C}}}
Let  denote the random variable which is the initial input length of 
player . Then we know that 

Also, let  denote the event that  is a long player and 
 the event that  is a short player.  By hypothesis, 
the current round is , and player  received an initial input of 
length . What information does player  know in round ?
\begin{itemize}
\item Since his initial input was of length  he knows that  and  
 and moreover, that  if and only if .
\item Since the game has entered round  he knows that . 
\item He knows his position  and the identities of his neighbors 
in round 
\item He also has learned ,  and using the latter to unmask his 
positional data, he knows  and the identities of his neighbors
in round .  Technically, he learns these just prior to his turn in the 
downstage in round , but this is fine, as we will argue later that 
no player ever has any reason to cheat during the upstage of a round.
\end{itemize}

We note that knowing  does not benefit player  in any way as far as 
estimating the probability that  goes, since  is equally likely to 
be any element of , independently of . Similarly, knowing the 
identities of his neighbors 
does not affect his estimate, since all other players are equally likely to 
be his neighbors independently of . 

On the other hand, knowing  and  does affect the 
estimate. By construction:
\begin{itemize}
\item In the definitive iteration, short players have odd labels, and 
long players have even labels; and
\item Each player has an odd label in his last round of input 
\end{itemize}
Thus if  is odd, then player  knows that the current round is not
definitive, since if , then  implies that  is a long player 
and should have an even label.  In particular, conditioned on everything he knows, 
. Since  the lemma is proved in this case.

\newcommand{\EEE}{\mathcal{E}_t}
\newcommand{\EEEE}{\mathcal{E}^{b}_{t+1}}

For the remainder of the proof we will assume that  is even
and denote this event .


Now what about ? If , then we know that  
is odd by construction and knowing this contains no additional information 
over knowing . On the other hand when , if  
is odd, then player  knows that  cannot be  and this affects the 
probability that .

Let  be the observed parity of  and let 
 denote the event that the 
parity of  is . Note that if  we must have 
.


Let  be player 's estimate that the current round, 
, is definitive, conditioned on everything he knows. Then

where the inequality follows from the fact that the event  is a subset of the event .

Now, if the current round \emph{is} definitive \ie, , then  is not 
a short player, and . So the event  is the same as the event .   Note that  is 
implied  by  and can therefore be dropped.

For the denominator, the event  can be split into the union of disjoint events 
 and 
. The latter summand 
is the same as the numerator, and loses the  term for the same reason.

Making these substitutions in the above expression, we get 

The random variables ,  and the indicator that  is a long player
are independent. Thus the numerator of the above expression becomes

Similarly we tackle the first term in the denominator. Since  and all the 
 are independent and , then  and  
are independent conditioned on . It follows that the events 
 is odd;  is even; and  are 
independent.  Thus, we have the following.


Now, if  then  and  are independent conditioned 
on  being either  or , and hence, the events 
 and  are independent, as are the 
events
 and .
It follows that  and 
 both equal .
On the other hand if  then  and  is implied  in both cases
Thus,  and 
 are both 1. Either way, they are 
equal, and since their common value occurs in the numerator as well as in 
both terms in the denominator, it simply cancels out.  

Putting everything together we see that 
{\belowdisplayskip=-14pt
 \qedhere}
\end{proof}

We remark that although in the above proof we have bounded player 's
estimate during the down-stage,  a nearly identical proof shows the same bound for the 
up-stage (when  is unknown).

We are now ready to prove the main theorem. 

\begin{proof}[Proof of Theorem~\ref{thm:main}]
We will begin by showing that the protocol is a Nash equlibrium 
in which all the players learn the secret.

Suppose all the players follow the protocol. Then every round, during the 
up-stage players send their shares up toward the root where they are decoded, 
and during the down-stage the reconstructed secret and mask are sent back 
toward the leaves.  If the odd players in the round do not drop out at the 
end of the round then play continues into the next round. In the definitive 
round, the real secret is reconstructed at the root and all the even 
labelled players, who are long players learn it first. Once it gets to the 
short players with odd labels, they drop out of the game since they have no 
tags to send any more messages. This signals the end of the game to the long 
players who then realize that the current reconstructed secret is the true one. 
Thus if all the players follow the protocol, everyone learns the secret.

Now suppose all players other than  are following the protocol. We want 
to show that player  prefers following the protocol over 
deviating.  

At the beginning of the game, each player has set their current guess for the 
secret to 0. If no cheating occurred before the current round  then 
during round
 all the players set their current guess to . Thus, at the 
beginning of round , all players have the same guess for the secret. 
(Round  has been eliminated as the definitive one, but  still has 
probability  of being the true secret.) Moreover, since by 
Lemma~\ref{lem:shares} partial information about the shares 
reveals no information about the symbol they encode, throughout 
the up-stage player  has no better guess than  for the secret.
Since , it is strictly better for  not to leave the game in the 
up-stage. If  sends incorrect messages in the up-stage, then even if he 
is not caught(which results in not learning the secret), this deviation will 
cause an incorrect value to be decoded instead of .  This results in 
not learning the secret if  happened to be the definitive round. Thus, 
 has no incentive to deviate in the up-stage. 

Now what about the down-stage? If  is on his last round of input, then he 
is a short player, and knows that the current round is definitive. At the same 
time, this means that he is an odd-labelled player and by the construction 
of the communication tree he cannot prevent anyone from learning the secret. 
Moreover, even if he successfully fakes a tag in order to convince the unique
long player below him that the game has not ended, that player will detect 
in the next round that all other players have left the game and will 
therefore still output the correct secret. Thus this deviation does not 
change the outcome of the game, namely that all players learn the secret. 
It follows that  does not gain anything 
by this deviation. (Although he also does not lose anything by it.) 
Effectively, if  is a short player on his 
last round of input, it is too late for him to improve his payoff by deviating.


If  is not on his last round of input and is at an odd labelled node then, 
as remarked in the proof of Lemma~\ref{lem:guess}, he \emph{knows} the current 
round is not definitive, so cheating would be equivalent to randomly guessing 
the secret, which is correct with probability only , This is worse than following the protocol by equation \eqref{eqn:su}.

Now suppose that the current round, , is not 's last round of input 
and  is at an even labelled node.  Note that any spurious messages sent by Player  to players that are not expecting them, will be ignored.  Also, any action involving not sending a message that is expected will be 
detected immediately, only by the involved players at first, but the knowledge will quickly 
propagates to all the players, before the end of the up-stage of the next 
round. Since detection of deviation causes other players to quit immediately, 
effectively such actions amount to player  leaving the game.  
Thus, the possible deviations we need to analyze for player  are:
\begin{itemize}
\item Leave the game, with or without sending fake messages first, and;
\item Send fake messages to one or both children and hope to stay in the 
game by not being caught.
\end{itemize}

Let 
be 's estimate of the probability that the current round is definitive. 
Then by Lemma~\ref{lem:guess},  . 

If player  leaves the game and outputs the value  then the probability 
that he has output the right value is , and since he 
has left the game, he has no later opportunity to improve that probability.
By Lemma~\ref{lem:threshold}, in order to discourage this deviation it is 
sufficient if 


Now consider the other kind of deviation. Suppose instead of sending  to 
his descendents, player  sends a fake value to one or both of them. Let 
 be the probability that he is not caught. By 
Proposition~\ref{prop:hash} we know that  if he sends 
a fake message to only one of his children, and, since the two verification 
functions are chosen independently by the dealer, 
if he fakes both messages.
If he is not caught, and if the current round is definitive, then
player  has learned the true secret and has prevented some of his descendants from 
learning it.   If the current round was not definitive and his deviation 
was not detected, the game continues and since the values  are all 
independent, it does not affect the next round.\footnote{This is why player  does 
not try to fake the mask  - an successfully transmitted incorrect 
 will wreak havoc in the next round, since some players will be 
talking to the wrong players.} This means that player  can either revert to 
following the protocol and guarantee learning the secret along with everyone 
else, or he may find further opportunities to cheat.

On the other hand, if the faked message is detected, which happens with probability 
, then the game ends right away and player  
outputs . In this case, there is still a  chance that the current 
round was definitive and an additional  chance that the 
value  was correct despite the current round not having been definitive.
So the probability that the deviation succeeds is 

As this quantity is bigger when , faking only one 
message dominates faking both messages.
Thus, again by Lemma~\ref{lem:threshold}, to discourage this deviation, it is 
sufficient if

Moreover, note that \eqref{eqn:cheat2} implies \eqref{eqn:cheat1}.
Thus for a Nash equilibrium, it is sufficient to show \eqref{eqn:cheat2}.

For the remainder of the proof, we are going to assume that  is 
sufficiently large, specifically that . 
We will discuss the modifications required when 
 in Section~\ref{sec:smalln}. 

We have so far not specified . We do this now.
Let 

Then  so that the expected number of rounds in the game 
is constant. 

To show \eqref{eqn:cheat2}, recall that , so that .
We have

as desired.
\smallskip

Finally, we analyze the resource costs of our protocol.  The communication
tree has  nodes. In each round, each player is mapped to one leaf and 
one internal node.  Players only communicate with their neighbors in
the tree. So on each round, during the up-stage each player sends up to three 
messages: one to his parent when he is a leaf; one to his parent when he is 
an non-root internal node; and if he is a child of the root and  is even, 
he has to send an additional message because there are two players at the 
root.

During the down stage each player sends two messages, one each 
to his two children. Thus each player sends at most five messages per round.
Each message consists of four elements of  (shares of ,  and 
two tags) each of which is represented as , since 
Thus each player send  bits per round. 
The expected number of rounds is  which is constant 
and so each player sends only  bits 
during the course of the game. Finally since the tree has depth
 the number of rounds is constant (in expectation) and the 
communication is synchronous, it follows that the expected
latency is .
\end{proof}

\subsection{Some Remarks}
\subsubsection{The Case of a Small Number of Players}\label{sec:smalln}
When the number of players is a constant greater than , then 
scalability is not an issue, and one might hope to simply use the algorithm of 
Kol and Naor~\cite{kol2008games} by simulating non-simultaneous broadcast 
channels with secure private channels. Unfortunately their algorithm only 
provides an -Nash equilibrium, since the unique short player 
has a small chance of successfully pretending the game has not ended. 

In our algorithm,  players are short players. In particular,
even for , there are at least two short players, and none of the short 
players can increase their expected payoff by cheating alone. Thus, we 
obtain a Nash equilibrium, provided that we can prove inequality \eqref{eqn:cheat2}. 
The above proof used the fact that  was at least 
, so we need a separate argument.

However  since when  is constant, scalability is immediate, we have more leeway to 
choose a larger field to work with.\footnote{The upper bound of  on the field 
size came from the desire to keep , which is the size of an individual 
message, small.} So we can work in a prime field of size  where 

and the proof of  \eqref{eqn:cheat2} goes through as before, giving us a Nash 
equilibrium.


\subsubsection{Nash equilibria vs. Strict Nash equilibria}

An -tuple of strategies is called a strict Nash equilibrium
if when all other players are following the prescribed strategy, 
a player unilaterally deviating  achieves a strictly worse expected payoff 
than he would by following the equilibrium strategy. 

Our algorithm fails to be a strict Nash equilibrium, for the following 
reasons:
\begin{itemize}
\item Any player may, at any time, send spurious messages that are not 
part of the protocol, to players that are not his neighbors
in the tree. Such messages will be ignored by their recipients, who are 
following the protocol. 
\item At the end of the definitive round, a short player may try to 
fake a tag and send a message to the long player below him. This may 
go undetected with some small probability, but as noted in the proof,
even in this case, it cannot fool that long player into outputting the 
wrong secret.
\end{itemize}
Our proof shows that our algorithm \emph{does} have the property that 
any player deviating from the protocol in one of the above ways does not increase his 
payoff, and moreover \emph{does not 
affect any other player's payoff either.} In other words, if a player 
deviating unilaterally from our protocol, does so in a manner that 
changes some other player's payoff, then he strictly reduces his own 
expected payoff. 
In this weaker sense, the equilibrium is strict. 

\subsubsection{A Note on Backwards Induction}\label{sec:backind}

The \emph{backwards induction} problem arises when a multi-round
protocol has a last round number that is known to all players.  In
particular, if it is globally known that the last round of the
protocol is , then on the -th round, there is no longer
any fear or reprisal to persuade a player to follow the protocol.  But
then if no player follows the protocol in the -th round, then in
the -th round, there is no reason for any player to follow
the protocol.  This same logic continues backwards to the very first
round.

The backwards induction problem can occur with protocols that make
cryptographic assumptions, since there will always be some round
number, , in which enough time has passed so that even a
computationally bounded player can break the cryptography.  Even
though  may be far off in the future, it is globally known that
the protocol will end at round , and so by backwards induction,
even in the first round, there is no incentive for a player to follow
the protocol.

As in~\cite{kol2008games}, we protect against backwards induction by
having both long and short players.  As the above analysis shows, if
 is chosen sufficiently large, we can ensure that the probability
of making a correct guess as to when the protocol ends is too small to
enable profitable cheating for any player.  Thus, even when a player
gets to the second to the last element in all his lists, he can not be
very sure that the protocol will end in the next round.  All players
are aware of these probabilities at the beginning of the protocol, and
thus each player knows that no other player will be able to accurately
guess when the protocol ends.


\section{Algorithm for Case of Absent Players}
\label{s:mofn}


In this section we discuss -out-of- secret sharing where . Here we want a subset of  or more of the players to be able to
reconstruct the secret even when the remaining players are absent. 
However, fewer than  players should \emph{not} be able to
reconstruct the secret on their own.

As discussed previously, it does
not seem possible to design \emph{scalable} algorithms for secret
sharing in the case when either  is much smaller than , or when the
subset of  active players may be chosen in a completely
arbitrary manner.  We now address the situation where (1) ,
but ; and (2) the subset of active players does not
depend on the random bits of the dealer.  More precisely, we will
present an algorithm with parameters  and  such that when  then with high
probability the algorithm is an Nash equilibrium for the
active players, and all the active players learn the secret. On the
other hand, if ,
then with high probability the active players cannot reconstruct the
secret.

We will assume, as in previous work, that the set of active players is
known to all the active players, before the start of the
players' protocol. However, this set is not known to the dealer at the time of 
share creation.   The set of active players may be arbitrary or randomly 
chosen, but it does
not depend on the randomness used by the dealer for the algorithm.


Since the algorithm is a variant of the -out-of- scheme, for
conciseness, we now describe only the places where the two algorithms
differ.  Let  be a large constant, which we will specify later.
First, the dealer partitions the players into 
pairwise disjoint groups of  players each.\footnote{It is
  convenient to assume that  is an integer and divides
  , and that the quotient  is odd. In fact it is always possible 
  to choose  so that  is odd, and for arbitrary , there will be 
   groups, each 
  with either  or 
  players.}  This is done using a random permutation of the
players, where the first  players in the permutation are the first
group, the next  are the second group and so on. The groups
are labelled . The communication tree used for the 
algorithm is the labelled -out-of- tree, except that all of the 
nodes are \emph{supernodes}, in that they
correspond to groups of  players instead of single
players. An edge of this communication tree will correspond to all-to-all
communication between the active members of the groups at the endpoints 
of the edge.

As in Algorithm~\ref{alg:Dealer}, the dealer samples  and  independently
from . (Here  is the same parameter 
as in the -out-of- algorithm.) For each round , the dealer essentially 
implements the corresponding round of the -out-of- algorithm.  For , he picks 
random secret  for the round.  If ,  is the true secret.  The dealer then picks a random permutation  to determine which group is 
assigned to which node for that round; and picks a random mask  to encode 
positional data.  A key difference is that now the positional data  constitutes 
not only which node your group is at and which groups are you neighbors, but 
also which  players are in all the relevant groups. For this reason 
we still need to work in a field with size bigger than ; a field of size 
merely bigger than  is not enough.

The dealer then creates -out-of- iterated shares for  and . Finally, the values of these 
-out-of- iterated shares at the leaves are further encoded into 
-out-of- shares via Shaimr's scheme~\cite{shamir:how}. 
These are the shares that will be distributed to the players for round .
This last step is to avoid all the players in a group having the same share,
because if that were the case, then the secret could be decoded by 
 players, one from each group. As before, the dealer, creates 
authentication data for all the messages to be sent in the algorithm\footnote{Technically this is not necessary. Since there is all-to-all 
communication between adjacent groups, messages sent by individuals can be 
checked against those sent by other members of the group.};
identifies the short players as the members of the groups at the odd labeled 
nodes in round ; truncates shares appropriately; and sends the shares to 
the players.

The players' protocol is very similar to Algorithm~\ref{alg:Player}. The only 
differences are that each active player must send his messages to all active 
players at neighboring nodes, and at the beginning of each round the active 
players at each leaf node must first reconstruct the value at the leaf using 
their -out-of- Shamir shares. This means that unless 
there are at least  active players in each group, the algorithm 
will fail. Herein lies the reason for the  failure probability of the 
algorithm.

Formal descriptions of the protocols for the dealer and players are presented 
as Algorithms~\ref{alg:mofnDealer} and~\ref{alg:mofnPlayer}.

\begin{algorithm}
{\small
\caption{Dealer's Protocol} \label{alg:mofnDealer} 
 field of size  (to represent messages in the algorithm)
 players with distinct identifiers in ,
: geometric distribution parameter.
 threshold parameters.
\begin{enumerate}
\item Choose  independently from a geometric distribution with 
parameter . Round  is the definitive one. Short players will receive 
full input for  rounds and partial input for round . Long players 
will receive full input for  rounds and partial input for round . 
\item Let  and 
Choose a random permutation , and use it to divide players into 
 groups (numbered ) of size . Use the complete 
binary tree with  leaves described in Section~\ref{sec:commtree}.
\item For each round  between 1 and :
\begin{itemize}
\item If , choose a random permutation . 
If  choose a permutation  which is random subject to the 
constraint that all the long player groups (determined by ) are assigned 
to odd labels under . For round  player  will be assigned to 
all nodes marked  in the tree. If ,  // (Otherwise 
 was set in the previous round)
\item For every group , use  and  to create masked positional 
data for  for round . Positional data consists of the group's position 
and members, neighboring groups and their members.
\item Choose a random mask  (for the {\bf next} round.)
\item Create shares of  by calling 
\recursiveShares.
\item If   true secret.\\
 Otherwise,  random element of 
\item Create shares of  by calling \recursiveShares.
\item Create -out-of- Shamir shares of each of the
leaf values of the shares created by \recursiveShares (one for each player 
in the group corresponding to the leaf.)
\item Create authentication data.
\item For each , for each player , 's (full) input  for 
round   consists of positional data, Shamir shares of recursive shares of 
 and  corresponding to node , and authentication data.
Partial input  consists of 
all of the above except the authentication tags for sending messages to your 
children (in the down-stage).
\end{itemize}
\item Identify the short players as those players  who are in groups at odd 
numbered nodes in the definitive iteration, \ie,  is odd.
\item For each short player , send  the list 
.
\item For each long player , send  the list 
.
\end{enumerate}}
\end{algorithm}

\begin{algorithm}
{\small 
\caption{Protocol for Player } \label{alg:mofnPlayer} 
S=0; M=0 \\
If at any time you receive spurious messages (messages not expected uder the 
protocol), ignore them. \\
On round :
\begin{itemize}
\item[] \upStage:
\begin{enumerate}
\item 
\item Use  to unmask and discover your position in the 
tree and the identities of your group members and neighbors for round .
\item (as player at a leaf)
Send your Shamir share to all active members of your group. Receive Shamir 
shares from all active members of your group. If insufficient shares received, 
output  and quit. Otherwise, reconstruct the leaf values of the recursive  
shares of  and   and send them along with their tags to all 
active members of the group at your 
parent node in the tree.
\item (as player at an internal node) 
\begin{enumerate}
\item Receive copies of (intermediate) shares of  and  
and tags from active members of the groups at your left and right children 
nodes. Check that correct messages have been sent.
If a fault is detected (missing or incorrect message) output  and quit.
\item For each of  and : interpolate a degree 1 polynomial  
from  and . 
Evaluate . This is your share.
\item If you are not at the root, send the above reconstructed shares of  
and  to all active members of the group at your parent node. If you 
\emph{are} at the root, these shares are the actual values of  and 
.
\end{enumerate}
\end{enumerate}
\item[] \downStage:
\begin{enumerate}
\item If you are at the root, set  and  and send these 
values along with authentification tags to all active members of the groups at
your left and right children nodes.
\item Else
\begin{enumerate}
\item (as a non-root internal node) Receive copies of  and  
and tags from all active members of the group at 
your parent node and check them. If fault detected, 
output  and quit.
\item Set  and .
\item Send  and  to all active members of the groups at your 
children nodes.
If you are a short player and have no authentication tags, output  and 
quit.
\end{enumerate}
\end{enumerate}
\item[] 
\end{itemize}
}
\end{algorithm}






\subsection{Analysis}

In order to show correctness of the algorithm, we need to make two
arguments. The first argument is that the active players are well
distributed among the groups, so that at any 
stage of the players' protocol
sufficiently many shares are available to do the desired
reconstruction. The second argument is that, the protocol is an
Nash equilibrium for the active players. The proof of this
part is essentially identical to the proof that the -out-of-
protocol was a Nash equilibrium for all the players, and
we omit it here. In the remainder of this section, we sketch why
reconstruction is possible with high probability, despite absent
players.

We note that in any round, for the value at an internal node to be 
reconstructed it is necessary that the values of both of its children be
received. Therefore, it is necessary that there is at least one active
player at each internal node.  Since no other reconstruction is to be
done at internal nodes, this is also sufficient. However, note that
the group of  players assigned to an internal node is the
same group as those assigned to some leaf node. Hence if there are no
active players at some internal node, then there is a leaf node at
which there are also no active players. Since at the leaf nodes we
will have a more stringent requirement for how many players need to be
active, it is sufficient to consider the failure of the algorithm at
the leaf nodes.

Now, the value at a leaf node is distributed as -out-of- Shamir shares to the  players associated
with that leaf node. Thus, this value can be reconstructed if and only
if there are at least  active players at the leaf
node. Moreover, in order for the protocol to succeed, the values at
all the leaf nodes must be reconstructible.

Recall that the players are assigned to leaf nodes by their group number 
so all leaf node values are reconstructible in a particular round if and 
only if all the groups 
have  at least  active players in that round. Moreover, 
since the same groups are used for all rounds, though not the same 
assignment of them to leaves, and each player is either active or absent for 
the entire game, the following lemma holds.
\begin{lemma}\label{lem:lriffg}
All the leaves are reconstructible throughout the algorithm if and only if 
all the groups have  at least  active players.
\end{lemma}

Now recall that the players are assigned to groups by the 
following random process.  The dealer chooses a random permutation of the 
players, and partition the players into  
pairwise disjoint groups by choosing successive contiguous blocks of 
length  in the permutation. Moreover, the choice of which 
players are active is made \emph{independently} of the above process. 
It turns out that in this case, the number of active players in a 
fixed block (\ie \, group) is tightly
concentrated around its mean. A more precise statement is in the
following lemma, whose proof is a simple application of the Azuma-Hoeffding
inequality. We omit the details here.

\begin{lemma}\label{lem:conc}
Let  be  bits such that exactly  of them
are  and  of them are . Let  be a random
permutation of  symbols and  be the induced permutation on bits. Fix any
contiguous block  of length , and let random variable  denote 
the number of bits in the block which are . 
Then  has expectation  and satisfies the following 
concentration inequalities:

and

\end{lemma}

We apply the above concentration inequality to show the following.

\begin{lemma}\label{lem:m}
Let , and let  denote the number of active players. If all  
the active players follow the algorithm, 
then with probability at least ,
\begin{itemize}
\item If , all active players learn the secret.
\item If , the secret cannot be reconstructed.
\end{itemize}
\end{lemma}
\begin{proof}
As already remarked in Lemma~\ref{lem:lriffg} all the leaf values of the 
iterated shares of the secret can be reconstructed every round if and only if 
each group has at least  players. Also, by 
Lemma~\ref{lem:shares} the iterated shares can be decoded into the secret
if and only if all the shares at the leaves are available. Thus, provided the  
active players  follow the protocol, the secret is recovered if and only if
each group has at least  players, so that is what we 
need to prove.

Imagine the permutation of players is a bit string such that every bit
corresponds to one player. If a bit is 1 it means the corresponding
player is active and if a bit is 0 the corresponding player is
inactive.  There are two cases.\\

\smallskip
\noindent
Case (1) .  Consider a particular group
 and let  denote the number of active players at
. By Lemma~\ref{lem:conc},

Taking a union bound over all the
 groups we see that the probability that the
algorithm fails to recover the secret, which happens only when  
\emph{some} group does not have enough active players, is at most 
. Setting  we see
that the probability that the algorithm fails is at most .\\

\smallskip
\noindent
Case (2) .  Once again consider a particular group
 and let  denote the number of active players at .
 By Lemma~\ref{lem:conc},

Therefore with probability at least ,  does not have enough active players. Since the failure of 
a single group to have enough active players is sufficient to break the
protocol completely (by Lemma~\ref{lem:shares}) it follows that with
probability at least  the algorithm fails to recover 
the secret.
\end{proof}

Why do players follow the protocol? As in the -out-of- case, we can 
argue that a player looking at his remaining input has a very low estimate 
of the current round being definitive, unless he is actually on his last round. 
In his last round of input, there is nothing he can do to prevent others 
from learning the secret that would not also prevent himself from learning 
it. We omit the details, which are essentially the same as in the proofs of 
Lemma~\ref{lem:guess} and Theorem~\ref{thm:main}. We conclude with

\begin{proof}[Proof of Theorem~\ref{thm:mofn}]
Lemma~\ref{lem:m} shows that with high probability, when the fraction of 
active players is higher than , all active players following 
the algorithm leads to their all learning the secret, while if the 
fraction is less than  then nobody learns it. We have also 
remarked that no player can do better by  deviating from the protocol, so 
that it is a Nash equilibrum. 
The communication tree has depth . 
On each round, each player sends messages to  others, and 
the messages  themselves are  bits. The algorithm runs 
for  steps in expectation. It follows that the algorithm has 
latency  and each player sends  bits in expectation.
\end{proof}

\section{Conclusion}
\label{s:conclusion}

We have presented \emph{scalable} mechanisms for rational secret sharing problems.  Our algorithms are scalable in the sense that the number of bits sent by each player is  and the latency is at most logarithmic in the number of players.  For -out-of- rational secret sharing, we give a scalable algorithm that is a Nash equilibrium to solve this problem.  For -out-of- rational secret sharing where (1) ; and (2) the set of active players is chosen independently of the random bits of the dealer, we give a scalable algorithm with threshold parameter  that is a Nash equilibrium and ensures that for any fixed, positive  that if (1) at least a  fraction of the players are active, all players will learn the secret; and (2) if fewer than a  fraction of the players are active, then the secret can not be recovered. 

Several open problems remain.  First, while our algorithms lead to a  multiplicative reduction in communication costs for rational secure multiparty computation (SMPC), the overall bandwidth for this problem is still very high. We ask: Can we design scalable algorithms for rational SMPC?    This is related to our second open problem which is: Can we design scalable algorithms for simulating a class of well-motivated mediators?  In some sense, this problem may be harder than the SMPC problem, since some types of mediators offer different advice to different players.  In other ways, the problem is easier: a simple global coin toss is an effective mediator for many games.  A final important problem is: Can we design coalition-resistant scalable algorithms for rational secret sharing?

\subsection*{Acknowledgments}

We are grateful to Tom Hayes and Jonathan Katz for useful discussions.





\bibliographystyle{plain}
\bibliography{security}
\end{document}
