\documentclass{CSML}

\def\dOi{12(3:3)2016}
\lmcsheading {\dOi}
{1--43}
{}
{}
{Oct.~31, 2015}
{Aug.~17, 2016}
{}

\ACMCCS{[{\bf Theory of computation}]: Models of computation; Semantics and reasoning---Program semantics}
\subjclass{F.1.1 [Computation by Abstract Devices]: Models of Computation; F.3.2 [Logics and Meanings of Programs]: Semantics of Programming Languages}

\usepackage{amssymb,stmaryrd,amsmath}


\usepackage{pstricks}
\usepackage{pst-node}

\usepackage[all]{xy}
\usepackage{wrapfig}

\raggedbottom

\theoremstyle{definition}\newtheorem{definition}[thm]{Definition}
\theoremstyle{definition}\newtheorem{example}[thm]{Example}
\theoremstyle{definition}\newtheorem{proposition}[thm]{Proposition}
\theoremstyle{definition}\newtheorem{lemma}[thm]{Lemma}
\theoremstyle{definition}\newtheorem{theorem}[thm]{Theorem}
\theoremstyle{definition}\newtheorem{corollary}[thm]{Corollary}
\theoremstyle{definition}\newtheorem{remark}[thm]{Remark}


\newcommand\nt[1]{#1}
\newcommand\am[1]{#1}

\newcommand\ev{\mathsf{ev}}
\newcommand\app{\ev}
\newcommand\Scat{\mathcal{S}}
\newcommand\Scatinn{\Scat_{\rm inn}}
\newcommand\Scatinntot{\Scatinn^{t}}
\newcommand\lland{\,\land\,}
\newcommand\qwe{\ \ }
\newcommand\qweq{\ }
\renewcommand\Sigma{\varSigma}
\newcommand\recur{\mathcal{R}}
\newcommand{\nada}{}
\newcommand\justf[3][]{\nccurve[nodesep=.5pt,linewidth=0.4pt,angleA=110,angleB=45,linecolor=darkgray#1]{->}{#2}{#3}}
\newcommand\Tau{T}
\newcommand\ov[1]{\llcorner{#1}\lrcorner}
\newcommand\defn{\triangleq}
\newcommand\Erase[1]{\mathsf{erase}(#1)}
\newcommand\store[1]{\overline{#1}}
\newcommand\pl[1]{\mathsf{plaify}(#1)}
\newcommand\plays[1]{P_{#1}}
\newcommand\arr{\rightarrow}
\newcommand\Arr{\Rightarrow}
\newcommand\nb{\beta}
\newcommand\pref{\sqsubseteq}
\newcommand\subl{\subseteq}
\newcommand\rest{\upharpoonright}
\newcommand\iseq{\mathop{\|}}
\newcommand\mix{\,\raisebox{.25ex}{\scalebox{.5}{}}\,}
\newcommand\ee\epsilon
\newcommand\remv{\setminus}
\newcommand\nice{\boldsymbol\Phi}
\newcommand\actn{\cdot}
\renewcommand\int{\mathsf{int}}
\newcommand\var{\mathsf{var}}
\newcommand\List[1]{\mathsf{List}(#1)}
\newcommand\remove[3]{\mathsf{remove}\ (#1,#2)\ \mathsf{in}\ #3}
\newcommand\add[4]{\mathsf{insert}\ (#1,#2,#3)\ \mathsf{in}\ #4}
\newcommand\Hextend[3]{\mathsf{let}\ #1=\mathsf{cons}\, #2\, #1\ \mathsf{in}\ #3}
\newcommand\Textend[3]{\mathsf{let}\ #1=\mathsf{snoc}\, #1\, #2\ \mathsf{in}\ #3}
\newcommand\indx{\mathsf{indx}}
\newcommand\deindx[1]{\mathsf{deindx}\ #1}
\renewcommand\for{\mathsf{for}}
\newcommand\code[1]{\lceil#1\rceil}
\newcommand\ang[1]{\langle#1\rangle}
\newcommand\V{\mathbb{V}}
\newcommand\one{1}
\newcommand\id{\mathsf{id}}
\newcommand\cell{\mathsf{cell}}
\newcommand\wt[1]{\mathsf{write}_{#1}}
\newcommand\ok{\mathsf{ok}}
\newcommand\rd{\mathsf{read}}
\newcommand\viewf{\mathsf{viewf}}
\newcommand\strat{\mathsf{strat}}
\newcommand\sskip{\mathsf{skip}}
\newcommand\sqleq\sqsubseteq
\newcommand\sqle\sqsubset
\newcommand\preplays[1]{\mathit{PP}_{#1}}
\newcommand\Splays[1]{\mathit{SP}_{#1}}
\newcommand\st[1]{\mathsf{st}(#1)}
\newcommand\Sinter[1]{\mathit{SInt}(#1)}
\newcommand\rel[1]{\mathsf{rel}(#1)}
\newcommand{\HY}{\hspace{2pt}---\hspace{2pt}}
\newcommand\clg[1]{\mathcal{#1}}
\newcommand\boldemph[1]{\emph{\textbf{#1}}}
\newcommand{\BI}[1]{\overline{I}_{#1}}
\newcommand{\BID}[2]{\overline{I}_{#1}^{#2}}

\newcommand{\pls}{\mathbin{+}}
\newcommand{\impl}{\mathbin{\Rightarrow}}
\newcommand{\permg}{{\rm PERM}}
\newcommand\A{\mathbb{A}}
\newcommand\N{\mathbb{N}}
\newcommand\Z{\mathbb{Z}}
\newcommand\rsim{\overset{r}{\sim}}
\newcommand\Prsim{\underset{r}{\sim}}
\newcommand\Prenn[2][\cdot]{(a\ b)^{#2}#1}
\newcommand\Prenni[2][\cdot]{(a_{#2}\ b_{#2})^{m_{#2}}#1}
\newcommand\renn[2][\cdot]{(a\ b)_{#2}#1}
\newcommand\rennba[2][\cdot]{(b\ a)_{#2}#1}
\newcommand\renni[2][\cdot]{(a_{#2}\ b_{#2})_{m_{#2}}#1}
\newcommand\swab{(a\ b)\cdot}
\newcommand\swabi[2][\cdot]{(a_{#2}\ b_{#2})#1}
\newcommand\Av{\mathsf{Av}}
\newcommand\dom[1]{\mathsf{dom}\,#1}
\newcommand\core[1]{\pview{#1}}
\newcommand\wis[1]{\mathsf{WI}(#1)}
\newcommand\is[1]{\mathsf{I}(#1)}
\newcommand\xn[1]{\mathsf{X}(#1)}
\newcommand\on[1]{\mathsf{O}(#1)}
\newcommand\pn[1]{\mathsf{P}(#1)}
\newcommand\oon[1]{\widehat{\mathsf{O}}(#1)}
\newcommand\langp{\mathcal{L}'}
\newcommand\eqmod[1]{\cong_{#1}}



\newcommand\mwrite[1]{\mathsf{write}(#1)}
\newcommand\mread{\mathsf{read}}
\newcommand\mok{\mathsf{ok}}
\newcommand\compi[2]{\mathcal{C}_{#1}^{#2}}
\newcommand\dcompi[2]{\mathcal{D}_{#1}^{#2}}
\newcommand\comp[1]{\mathcal{C}_{#1}}
\newcommand\lrarr\longrightarrow
\newcommand\ctype{\mathit{ctype}}
\newcommand\ttype{\mathit{ttype}}
\newcommand\spinal[1]{P_A^{sp}}
\newcommand\ialoop{\mathsf{IA}_{\circlearrowright}}
\newcommand\iatwo{\ialoop^{2+}}
\newcommand\pcfplus{\mathsf{PCF}^+}
\newcommand\pcf{\mathsf{PCF}}
\newcommand\iacbv{\mathsf{IA}_{\mathsf{cbv}}}
\newcommand\rml{\mathsf{RML}}
\newcommand\full[1]{{#1}^{F}}
\newcommand\suc[1]{\mathsf{succ}(#1)}
\newcommand\pre[1]{\mathsf{pred}(#1)}
\newcommand\ds{\displaystyle}
\newcommand{\mycomment}[1]{\marginpar{\footnotesize #1}}
\newcommand\letin[2]{\mathsf{let}\ #1\ \mathsf{in}\ #2}
\newcommand\laird{\lambda\nu !}
\newcommand\badvar[2]{\mathsf{mkvar}(#1,#2)}
\newcommand\mkvar{\mathsf{mkvar}}
\newcommand\pav[1]{\mathsf{Av}_{\mathrm P}(#1)}
\newcommand\oav[1]{\mathsf{Av}_{\mathrm O}(#1)}
\newcommand\support[1]{\nu(#1)}
\newcommand\substore\leq
\newcommand\Substore{\leq_p}
\newcommand\substorE{\leq_s}
\newcommand\prefix{\sqsubseteq_p}
\newcommand\suffix{\sqsubseteq_s}
\newcommand\subseq\sqsubseteq
\newcommand\fix[1]{\mathsf{Y}(#1)}
\newcommand\refint[1]{\mathsf{ref}\,#1}
\newcommand\inter[1]{\mathit{Int}(#1)}
\newcommand\interfull[1]{\mathit{Int}_F(#1)}
\newcommand{\aasg}{\,\raisebox{0.065ex}{:}{=}\,}
\newcommand\comt{\mathsf{unit}}
\newcommand\Rarr{\Rightarrow}
\newcommand\expt{\mathsf{int}}
\newcommand\vart{\mathsf{var}}
\renewcommand\red[2]{#1 \Downarrow #2}
\newcommand{\capprox}{\,\raisebox{-.5ex}{}\,}
\newcommand\abra[1]{\langle\, #1 \,\rangle}
\newcommand\anglebra[1]{\langle\, #1 \,\rangle}
\newcommand\while[2]{\mathsf{while}\,#1\,\mathsf{do}\,#2}
\newcommand\cond[3]{\mathsf{if}\,#1\,\mathsf{then}\,#2\,\mathsf{else}\,#3}
\newcommand\atomset{\mathcal{A}}
\newcommand{\rarr}{\rightarrow}
\newcommand\pview[1]{\ulcorner{#1}\urcorner}
\newcommand\pv[1]{\pview{#1}}
\newcommand\oview[1]{\llcorner{#1}\lrcorner}
\newcommand\deref{\mathsf{!}}
\newcommand\ul[1]{\underline{#1}}
\newcommand\makeset[1]{\{\,#1\,\}}
\newcommand\cutout[1]{}
\newcommand\eff{\mathsf{eff}}
\newcommand\proj[2]{{#1\restriction#2}}
\newcommand\permsym{\sim_\pi}
\newcommand\perm[2]{#1 \sim_\pi #2}
\newcommand\pren[2]{#1 \sim_\rho #2}
\newcommand\prenperm[2]{#1 \sim_{\pi\rho} #2}
\newcommand\legal[1]{L_{#1}}
\newcommand\erase[1]{\Erase{#1}}
\newcommand\onames[1]{\mathsf{O}(#1)}
\newcommand\pnames[1]{\mathsf{P}(#1)}
\newcommand\natnum{\mathbb N}
\newcommand\intnum{\mathbb Z}
\newcommand\refarena{\mathcal{N}}
\newcommand\domn[1]{\dom\,#1}
\newcommand\newstrat{\mathsf{new}}
\newcommand\strict[1]{\widetilde{#1}}
\newcommand\vf[1]{\mathsf{vf}(#1)}
\newcommand\sem[1]{\llbracket #1 \rrbracket}
\newcommand\ssem[1]{\sem{#1}_{\mathrm{S}}}
\newcommand\redml{\textrm{Reduced ML}}
\newcommand\seq[2]{{#1} \vdash {#2}}
\newcommand\up[1]{\vspace*{-#1mm}}
\newcommand\lpure{L_{\mathrm{base}}}
\newcommand\lstack{L_{\mathrm{stack}}}
\newcommand\lang{\mathcal{L}}
\newcommand\lheap{L_{\mathrm{head}}}
\newcommand\new[2]{\mathsf{new}\,#1\,\mathsf{in}\,#2}
\newcommand\newc{\mathsf{ref}}
\newcommand\loc{\mathsf{Loc}}
\newcommand\na\alpha
\newcommand\can{\mathbb{C}}
\newcommand\splay[1]{\mathit{SP}_{#1}}
\newcommand\knowing[1]{\mathcal{K}_{#1}}
\newcommand\Sbinno[1]{\Scatinn}
\newcommand\binno[1]{\mathcal{B}_{#1}}
\newcommand\inno[1]{\mathcal{I}_{#1}}
\newcommand\ord[1]{\mathsf{ord}(#1)}
\newcommand\xar[2]{\ar@{-}@/_#1mm/[#2]}
 
\begin{document}

\title[Block structure vs scope extrusion]{Block structure vs scope extrusion: between innocence and omniscience\rsuper*}

\author[A.S.~Murawski]{Andrzej S.\ Murawski\rsuper a}
\address{{\lsuper a}University of Warwick}
\email{A.Murawski@warwick.ac.uk}
\thanks{{\lsuper a}Supported by the 
Engineering and Physical Sciences Research Council (EP/C539753/1)}

\author[N.~Tzevelekos]{Nikos Tzevelekos\rsuper b}
\address{{\lsuper b}Queen Mary University of London}
\email{nikos.tzevelekos@qmul.ac.uk}
\thanks{{\lsuper b}Supported by the 
Engineering and Physical Sciences Research Council (EP/F067607/1)
and the Royal Academy of Engineering}
\keywords{Game semantics, references, contextual equivalence}

\titlecomment{{\lsuper*}Extended abstract appeared in FOSSACS~\cite{MT10}.}



\begin{abstract}
We study the semantic meaning of block structure using game semantics.
To that end, we introduce the notion of block-innocent strategies and
characterise call-by-value computation with block-allocated storage
through soundness, finite definability and universality results.
This puts us in a good position to conduct a comparative study of
purely functional computation, computation with block storage as well as
that with dynamic memory allocation.
For example, we can show that dynamic variable allocation
can be replaced with block-allocated variables exactly when the
term involved (open or closed) is of base type and that block-allocated
storage can be replaced with purely functional computation
when types of order two are involved.
To illustrate the restrictive nature of block structure further,
we prove a decidability result for a finitary fragment of call-by-value
Idealized Algol for which it is known that allowing for dynamic memory
allocation leads to undecidability.
\end{abstract}

\maketitle



\section{Introduction}

Most programming languages manage memory
by employing a stack for local variables and heap storage
for data that are supposed to live beyond their initial context.
A prototypical example of the former mechanism is Reynolds's
Idealized Algol~\cite{Rey81}, in which local variables can only
be introduced inside blocks of ground type. Memory is then allocated
on entry to the block and deallocated on exit.
In contrast, languages such as ML permit variables to escape
from their current context under the guise of pointers or references.
In this case, after memory is allocated at the point of reference creation,
the variable must be allowed to persist indefinitely (in practice, garbage collection
or explicit deallocation can be used to put an end to its life).

In this paper we would like to compare the expressivity of the two paradigms.
As a simple example of heap-based memory allocation we consider
the language , introduced by Abramsky and McCusker in~\cite{AM97b},
which is a fragment of ML featuring integer-valued references.  In op.~cit.\ the authors
also construct a fully abstract game model of 
based on strategies (referred to as \emph{knowing} strategies)
that allow the Proponent to base his decisions on the full history of play.
On the other hand, at around the same time Honda and Yoshida~\cite{HY97} showed that the purely functional
core of , better known as call-by-value ~\cite{Plo77}, corresponds to
\emph{innocent} strategies~\cite{HO00}, i.e.\ those that can only
rely on a restricted view of the play when deciding on the next move.
Since block-structured storage of Idealized Algol seems
less expressive than dynamic memory allocation of ML
and more expressive than , it is natural to ask about
its exact position in the spectrum of strategies
between innocence and omniscience.
Our first result is an answer to this question. 
We introduce the family of \emph{block-innocent}
strategies, situated strictly between innocent and knowing strategies, and exhibit a series of results
relating such strategies to a call-by-value variant  of Idealized Algol.

Block-innocence captures the particular kind of uniformity exhibited by
strategies originating from block-structured programs, akin to innocence
yet strictly weaker. In fact, we shall define block-innocence through innocence in
a setting enriched with explicit store annotations added to standard moves.
For instance, in the play shown below\footnote{For the sake of clarity, we only include pointers pointing more
than one move ahead.},
if P follows a block-innocent strategy, P is free to use different moves as the fourth (1) and sixth (2) moves,
but the tenth one (0) and the twelfth one (0) have to be the same.


The above play is present in the strategy representing the term

and the necessity to play the same value ( in this case) in the twelfth move once  has been played in the tenth one
stems from the fact that variables in  can only be allocated in blocks of ground type. For example, the block in which  was allocated cannot extend over .

Additionally, our framework can detect ``storage violations" resulting
from an attempt to access a variable from outside of its block.
For instance, no -term will ever produce the following play.


The last move is the offending one: for the term given above, it would amount to trying to use  after deallocation of the block for .
Note, though, that the very similar play drawn below does originate from an -term. 


Take, e.g.\
.

The notion of block-innocence provides us with a systematic methodology
to address expressivity questions  related to block structure such as
\emph{``Does a given strategy originate from a stack-based memory discipline?''}
or \emph{``Can a given program using dynamic memory allocation be replaced
with an equivalent program featuring stack-based storage?''}.
To illustrate the approach we conduct a complete study of the relationship
between the three classes of strategies (innocent, block-innocent and knowing respectively) 
according to the underpinning type shape.
We find that knowingness implies block-innocence when terms of base types
(open or closed) are involved, that block-innocence implies innocence
exactly for types of order at most two, and that knowingness implies
innocence if the term is of base type and its free identifiers are of order .
\nt{The fact that knowingness and innocence coincide at terms of base types implies, in particular, that  and  contexts have the same expressive power: two -terms can be distinguished by an -context if, and only if, they can be distinguished by an -context.}

As a further confirmation of the restrictive nature of the stack discipline of ,
we prove that program equivalence is decidable for a finitary variant of 
which properly contains all second-order types as well as some third-order types
(interestingly, this type discipline covers the available higher-order types in PASCAL).
In contrast, the corresponding restriction of  is known to be undecidable~\cite{Mur04b}.

\nada\\
\noindent
{\bf Related work.} The stack discipline has always been regarded as part of the essence
of Algol~\cite{Rey81}. \nt{The first languages introduced in that lineage, i.e.\ Algol 58 and 60, 
featured both call-by-name and call-by-value parameters. Call-by-name was abandoned in Algol 68, 
though, and was absent from subsequent designs, such as Pascal and C.
}

On the semantic front, finding models embodying stack-oriented storage management
has always been an important goal of research into Algol-like languages.
In this spirit, in the early 1980s, Reynolds~\cite{Rey81} and Oles~\cite{Ole85} devised a semantic
model of \nt{(call-by-name)} Algol-like languages using a category of functors from a category of store shapes
to the category of predomains. Perhaps surprisingly, in the 1990s, Pitts and Stark~\cite{PS93,Sta95}
managed to adapt the techniques to \nt{(call-by-value)} languages with dynamic allocation.
This would appear to create a common platform suitable for a comparative study
such as ours.  However, despite the valuable structural insights, the relative
imprecision of the functor category semantics (failure of definability and full abstraction)
makes it unlikely that the results obtained by us can be proved via this route.
The semantics of local effects has also been investigated from the category-theoretic
point of view in~\cite{Pow06}.


As for the game semantics literature, Ong's work~\cite{Ong02} based on strategies-with-state
is the work closest to ours. His paper defines a compositional framework that is proved sound
for the third-order fragment of \emph{call-by-name} Idealized Algol. Adapting the results to call-by-value
and all types is far from immediate, though. For a start, to handle higher-order types, we note that
the state of O-moves is no longer determined by their justifier and the preceding move.
Instead, the right state has to be computed globally using the whole history
of play. However, the obvious adaptation of this idea to call-by-value does not capture
the block structure of . Quite the opposite: it seems to be more compatible with .
Consequently,  further changes are needed to characterize . Firstly,
to restore definability, the explicit stores have to become lists instead of sets.
Secondly, conditions controlling state changes must be tightened. In particular,
P must be forbidden from introducing fresh variables at any step and,  in a similar vein,
must be forced to drop some variables from his moves in certain circumstances.

\nt{Another related paper is~\cite{AM99a}, in which Abramsky and McCusker introduce a model of
Idealized Algol with passive (side-effect-free) expressions~\cite{AM99a}.
Their framework is based on a distinction between \emph{active} and \emph{passive} moves, which correspond
to active and passive types respectively. Legal plays must then satisfy a novel correctness condition, called  \emph{activity}, 
and strategies must be \emph{-innocent}. In contrast, our setting does not feature any type support for 
discovering the presence of storage. Moreover, as the sequences discussed in the Introduction demonstrate,
in order to understand legality in our setting, it is sometimes necessary to scrutinise values used in plays:
changing  to  may entail loss of correctness!
This is different from the activity condition (and other conditions used in game semantics), where it suffices
to consider the kind of moves involved (question/answer) or pointer patterns. 
Consequently, in order to capture the desired
shape of plays and associated notion of innocence in our setting,  
we felt it was necessary to  introduce moves explicitly decorated with stores.}

Our paper is also related to the efforts of finding decidable fragments of (finitary)  as far as contextual equivalence is concerned.
Despite several papers in the area~\cite{Ghi01, Mur04b, HMO11,CBHMO15}, no full classification based on type shapes has emerged yet, even though
the corresponding call-by-name case has been fully mapped
out~\cite{MOW05}. We show that, for certain types, moving from 
to  (thus weakening storage capabilities) can help to regain
decidability.



\section{Syntax\label{sec:syntax}}

To set a common ground for our investigations, we introduce a higher-order 
programming language that features syntactic constructs for both
block and dynamic memory allocation. 

\begin{definition}[The language~]
We define types as generated by the grammar below,
where  ranges over the ground types  and .

The syntax of  is given in Figure~\ref{fig:syntax}. 
\end{definition}

Note in particular the first two rules concerning variables and the rule for the  constructor: the latter allows us to build ``bad variables'' in accordance with Idealized Algol. 
\begin{figure}[t]
\renewcommand\arraystretch{2.5}

\caption{Syntax of \label{fig:syntax}}
\makebox[\textwidth][l]{\hrulefill}
\end{figure}
{The order of a type is defined as follows: 
}
For any , 
terms that are typable using exclusively judgments of the
form 
 
where  () and ,
are said to form the th-order fragment.

To spell out the operational semantics of , we need to assume a countable set 
of \emph{locations}, which are added to the syntax as auxiliary constants of type .
We shall write  to range over them.
The semantics then takes the form of judgments , where  are
finite partial functions from  to integers,  is a \nt{closed} term and  is a value.
Terms of the following shapes are values:  , integer constants, elements of , 
-abstractions or terms of the form .

The operational semantics is given via the large-step rules in Figure~\ref{fig:opsem}. 
Most of them take the form 

which is meant to abbreviate:

This is a common semantic convention, introduced in the Definition of Standard ML~\cite{MTH90}.
In particular, it means that the ordering of the hypotheses is significant.
The penultimate rule in the figure encapsulates the state within the newly created block,
while the last one creates a reference to a new memory cell that can
be passed around without restrictions on its scope.
Note that 
is the restriction of  to .


\begin{figure}[t]
\renewcommand\arraystretch{2.5}

\caption{Operational semantics of \label{fig:opsem}}
\makebox[\textwidth][l]{\hrulefill}
\end{figure}

\cutout{
Here we only reproduce the two evaluation rules related to variable creation.

}

Given a closed term , we write  
if there exists  such that .
We shall call two programs equivalent if they behave identically 
in every context. This is captured by the following definition, 
parameterised by the kind of contexts that are considered,
to allow for testing of terms with contexts originating from a designated 
subset of the language.

\begin{definition}
Suppose  is a subset of .
We say that the terms-in-context  
are -equivalent (written )
if, for any -context  such that ,
 if and only if  .
\end{definition}

We shall study three sublanguages of , called
,  and  respectively. The latter two
have appeared in the literature as paradigmatic examples of programming
languages with stack discipline and dynamic memory allocation respectively.
\begin{itemize}
\item 
 is a purely functional language obtained from  by removing
 and . It extends the language ~\cite{Plo77}
with primitives for variable access, but not for memory allocation.
\item 
 is  without the  constant.
It can be viewed as  a call-by-value variant of Idealized Algol~\cite{Rey81}.
Only block-allocated storage is available in .
\item 
 is  save the construct . It is exactly the language
introduced in~\cite{AM97b} as a prototypical language for ML-like integer references.\footnote{\nt{In other words,  is Reduced ML~\cite{Sta95} with the addition of the  construct.}}
\end{itemize}
{We shall often use   as shorthand for . 
Moreover, , where  does not occur in , will be abbreviated to .}
Note also that  is equivalent to .
\nt{\begin{example}
The term  is an example of an -term 
that is not \am{-equivalent} to any term from .
On the other hand, 

is an -term that has no \am{-equivalent} in . All of  the inequivalence claims will follow immediately from our results.
\end{example}}


\nt{
\begin{lemma}
Given any base type \am{-term}\, , we have  .
\end{lemma}
\begin{proof}
The proof is based on the following two claims:
\begin{itemize}
\item if  and  does not appear in , then ;
\item for any closed context , value  and , if
 then there is a set of locations  such that 
 and  contains no locations from  or ;
\end{itemize}
which are proven by straightforward induction.
\cutout{ following fact without proof: if  and  does not appear in , then .
Let us write  for , and  for .
We now show that, for any closed context , value  and , if
 then there is a set of locations  such that 
 and  contains no locations from  or . We argue by induction on . In the base case,  and the claim clearly holds as  is of base type. For the inductive case, consider  and suppose  and  and . Then, by IH, we have that  for some set of names  fresh for . By the above fact, and since  is compatible with , we have 
 and, hence by the IH, 
 for some  extending  with names fresh for . We moreover have , which yields the claim. The other inductive cases are treated similarly.

\nt{Mention the two facts in the proof, say proven by easy induction.}}
\end{proof}}

Hence, 
 and  merely differ on a syntactic level in that 
contains ``syntactic sugar" for blocks. In the opposite direction, 
our results will show that  cannot in general be replaced
with an equivalent term that uses . Indeed, our paper provides 
a general methodology for identifying and studying scenarios 
in which this expressivity gap is real.



\section{Game semantics}


We next introduce the game models used throughout the paper,
which are based on the Honda-Yoshida approach to modelling call-by-value computation~\cite{HY97}.
\begin{definition}
An \boldemph{arena}  is given by
\begin{itemize}\item a set  of moves, and a subset  of \emph{initial} moves,
  \item a justification relation , and
  \item a labelling function \,
\end{itemize}such that  and, whenever ,
we have  and . 
\end{definition}
The role of  is to label moves as \emph{Opponent} or \emph{Proponent} moves and
as \emph{Questions} or \emph{Answers}. We typically write them as , or  when we want to be specific about their kind.
\nt{Note that we abbreviate elements of the codomain of , e.g.\  above is written as .}

The simplest arena is .
Other ``flat'' arenas are  and , defined by:

Below we recall two standard constructions on arenas, 
where  stands for ,
the -complement of  is written as , and  range
over initial moves in the respective arenas.

\bigskip

Types of  can now be interpreted with arenas in the following way.

Note that the type  is translated as a product arena the components of which represent its read and write methods.

Although arenas model types, the actual games will be played in \boldemph{prearenas},
which are defined in the same way as arenas with the exception that initial moves must
be O-questions. Given arenas  and  , we can construct the prearena  by setting:

For , typing judgments  will eventually be interpreted by strategies for the prearena
 (if  we take the left-hand side to be ),
which we shall denote by  or .

A \boldemph{justified sequence} in a prearena  is a finite sequence 
of moves of  satisfying the following condition: the first move must be initial,
but all other moves  must be equipped with a pointer  to an earlier
occurrence of a move  such that .
\nt{We then say that  \emph{justifies} . If  is an answer, we may also say that  \emph{answers} .
If a question remains unanswered in , it is \emph{open}; and the rightmost open question in  is its \emph{pending question}.}

Given a justified sequence , we define its \emph{O-view } and its \emph{P-view}  inductively as follows.
\begin{itemize}
\item \,, \,
\,, \,
\,;
\item
\,,
\,,
\,.
\end{itemize}
Above, \nt{recall that}  ranges over O-moves (i.e.\ moves  such that ), and  ranges over P-moves.

\begin{definition}
A \boldemph{play} in a prearena  is a justified sequence  satisfying
the following conditions.
\begin{itemize}
\item If  then .\ (\emph{Alternation})
\item If  then  is the pending question in .\
(\emph{Well-Bracketing})
\item
If  then  appears in \,;\\ 
if   then  appears in \,.
(\emph{Visibility})
\end{itemize}
We write  to denote the set of plays in .
\end{definition}



We are going to model terms-in-context  as sets of plays in  subject to specific conditions.

\begin{definition}
A \boldemph{(knowing) strategy}  on a prearena  is a {non-empty} prefix-closed set of plays from  satisfying the first two conditions below. A strategy is \boldemph{innocent} if, in addition, the third condition holds.
\begin{itemize}
\item If even-length  and  then .\
(\emph{O-Closure})
 \item If even-length  then .\ (\emph{Determinacy})
 \item If  with odd-length  and  then .\ (\emph{Innocence})
\end{itemize}
We write  to denote that  is a strategy on .
\end{definition}


Note, in particular, that every strategy  contains the empty sequence  as well as the elements of , the latter being the 1-move plays in .
\nt{Moreover, in the last condition above, the move  in  points at the same move it points inside : by visibility and the fact that  and  have the same view, this is always possible.}

{In previous work it has been shown that knowing strategies yield a fully abstract semantics for  in the following sense\footnote{Perhaps it is worth noting that the presentation of the model in~\cite{AM97b} is in a different setting
  (we follow Honda-Yoshida call-by-value games, while~\cite{AM97b} applies the \emph{family construction} on call-by-name games) which, nonetheless, is equivalent to the one presented above.}.
  \nt{
  \begin{theorem}[\cite{AM97b}]
Two -terms are -equivalent
  if and only if their interpretations contain the same complete plays\footnote{A play is called \emph{complete} if each question in that play has been answered.}. 
  \end{theorem}
Moreover, as an immediate consequence of the full abstraction result of~\cite{HY97}, we have that innocent strategies (quotiented by the intrinsic preorder)
yield full abstraction for .}
What remains open is the model for the intermediate language, , which requires one to identify a family of strategies between the innocent and knowing ones.
This is the problem examined in the next section. We address it in two steps.
\begin{itemize}
\item First we introduce a category of strategies that are equipped with explicit stores for registering private variables. 
We show that this category, of so-called innocent \emph{S-strategies}, indeed models block allocation: terms of  translate into innocent S-strategies (Proposition~\ref{prop:model}) and, moreover, in a complete manner (Propositions~\ref{prop:defin} and~\ref{prop:univ}). 
\item The strategies capturing , called \emph{block-innocent} strategies, are then defined by deleting stores from innocent S-strategies.
\end{itemize}
}

\section{Games with stores and the model of \texorpdfstring{}{IAcbv}}

We shall now extend the framework to allow moves to be decorated with
stores that contain name-integer pairs. 
This extension will be necessary for capturing block-allocated storage.
The names should be viewed as semantic analogues of locations.
The stores will be used for carrying the values of private, block-allocated variables.

\subsection{Names and stores in games}

When employing such moves-with-store, we are not interested in what exactly the names are,
but we would like to know how they relate to names that have already been in play. Hence,
the objects of study are rather the induced equivalence classes with respect to name-invariance, and all ensuing constructions and reasoning need to be compatible with it. This overhead can be dealt with robustly using the language of nominal set theory~\cite{GP02}.
Let us fix a countably infinite set , the set of \emph{names}, the elements of which we shall denote by  and variants. Consider the group  of finite permutations of . 

\begin{definition}
A \boldemph{strong nominal set}~\cite{GP02,Tze09}
is a set equipped with a group action\footnote{A group action of  on  is a function\, \, such that, for all  and ,   and , where  is the identity permutation.}
of 
such that each of its elements has \emph{finite strong support}. That is to say, for any ,
there exists a finite set , called \boldemph{the support of }, such that, for all permutations , .
\end{definition}

Intuitively,  is the set of names ``involved'' in .
For example, the set  of finite lists of distinct atoms with permutations acting elementwise is a strong nominal set.
If  and  are strong nominal sets, then so is their cartesian product  (with permutations acting componentwise) and their disjoint union .
Name-invariance in a strong nominal set  is represented by the relation:  if there exists  such that .




We define a strong nominal set of \boldemph{stores}, the elements of which are finite sequences of
name-integer pairs. Formally,

where  and . 
We view stores as finite functions from names to
integers, though their domains are lists rather than sets. Thus, we
define the \boldemph{domain} of a store to be the \emph{list} of
names obtained by applying the first projection to all of its elements. In particular, . If  then we write  for the unique  such that  is an element of . 
For stores  we write:

where , and  denote the subsequence, prefix and suffix relations
respectively.
Note that  implies  but not .
Finally, let us write  for  restricted to .



An \boldemph{S-move} (or \emph{move-with-store}) in a prearena  is a pair consisting of a move and a store. We typically write S-moves as .
The first projection function is viewed as \emph{store erasure} and denoted by .
Note that moves contain no names and therefore, for any ,\
\,.
A \boldemph{justified S-sequence} in  is a sequence of S-moves equipped with justifiers, so that its erasure is a justified sequence. The notions of \emph{O-view} and \emph{P-view} are extended to S-sequences in the obvious manner.
We say that a name  \boldemph{is closed} in 
if there are no open questions in  containing .

\begin{definition}\label{def:splay}
A justified S-sequence  in a prearena  is called an \boldemph{S-play} if it satisfies the following conditions, for all .
\begin{itemize}
  \item If  then .\ ({\em Init})
  \item If  then . If  then  too.\ ({\em Just-P})
 \item If  \ then .\ ({\em Just-O})
  \item If  then  and  and 
  \begin{enumerate}[label=
\begin{aligned}
&\sem{\vart\rarr\beta}\rarr\sem{\beta}\\
&=\ (\sem{\vart}\Rarr\sem{\beta})\to\sem{\beta}\\
&=\ (\sem{\vart}\Rarr_1\sem{\beta})\to_0\sem{\beta}
\\\\\\
\end{aligned}
\qquad\qquad
\begin{aligned}
\xymatrix@R=.5mm@C=2mm{
&q_0\ar@{-}[dd]\ar@{-}[dr] \\
&& a_0 \\
&q_1\ar@{-}[dd]\ar@{-}[ddl]\ar@{-}[dr] \\
&& a_1 \\
\mread\ar@{-}[dd]  & \mwrite{i}\ar@{-}[dd]
\\
~\\
i & \mok
}
\end{aligned}

\begin{aligned}
\\\\\}Note that, although the  strategy is typically non-innocent, it is innocent in our framework, where private variables are explicit in game moves (in their stores).
\end{example}

\begin{example}
Let us consider the prearena , depicted as on the left below.
Had we used sets instead of lists for representing stores, the following ``S-strategy" (right below),
which represents incorrect overlap of scopes ( and  are in scope of one another,
but at the same time have different scopes), would have been valid (and innocent).

{However, the above is not a valid S-strategy in our language setting. Intuitively, it would correspond to a term that determines the scope of its variables on the fly, depending on the value (0 or 1) received after memory allocation.}
\end{example}




\subsection{Composing S-plays}

We next define composition of S-plays, following the approach of~\cite{HY97,Tze09}. Let us introduce some notation on stores. For a sequence of S-moves  and stores , we write  and  for the stores defined by: ,  and

Moreover, we write  for the store of the final S-move in . 
\nt{For instance, by {\em Prev-PQ} and {\em Prev-PA}, if  are consecutive inside an S-play then .}

It will also be convenient 
to introduce the following store-constructor. For stores  we define

Considering  as \emph{consecutive},
the constructor first updates  with values from , removes those names that have been \emph{dropped} in  and then adds those that have been \emph{introduced} in it.

\begin{definition}
Let  be arenas and . We say that  are \emph{compatible}, written , if  and . In such a case, we define their \emph{interaction}, , and their \emph{mix}, , recursively as follows,

where 
justification pointers in  are inherited from  and , and
 is the store of 's justifier in . 
Note that  is the store of the last S-move in . The \emph{composite} of  and  is

We moreover let

be the set of \boldemph{S-interaction sequences} of .
\end{definition}

\nt{
\begin{example}\label{ex:playcomp}
Let us 
demonstrate how to
compose S-plays
from the following strategies: 

We depict the two prearenas below (compared to Example~\ref{ex:cell}, in the prearena on the right we have replaced  and  with concrete moves  and ).

The S-strategy  is given by even-length prefixes of S-plays of the form:
4mm]
&\rnode{A}{\ast_0}\qweq 
\rnode{AA}{\ast_0'}\qweq
\rnode{B}{\ast_1}
\qweq
\rnode{CA}{\mread}\qweq\rnode{DA}{i}
\qweq
\rnode{CB}{\mwrite{i{+}1}}\qweq\rnode{DB}{\mok}
\qweq
\rnode{CA}{\mread}\qweq\rnode{DA}{j}
\qweq
\rnode{C}{j_1}
\justf[,angleA=145]{C}{B}
\qweq
\rnode{XB}{\ast_1}
\qweq
\rnode{XCA}{\mread}\qweq\rnode{XDA}{i'}
\qweq
\rnode{XCB}{\mwrite{i'{+}1}}\qweq\rnode{XDB}{\mok}
\qweq
\rnode{CA}{\mread}\qweq\rnode{DA}{j'}
\qweq
\rnode{XC}{j'_1}
\qweq\cdots
\justf[,angleA=145]{XC}{XB}\justf[,angleA=140]{XB}{AA}
\end{aligned}

&\rnode{A}{\ast'_0}\qwe 
\rnode{B}{\ast_1^{(\na,0)}}
\qweq
\left(\rnode{CA}{\mread}^{(\na,0)}\qweq\rnode{DA}{0}^{(\na,0)}\right)^*
\qweq
\rnode{CB}{\mwrite{i}}^{(\na,0)}\qweq\rnode{DB}{\mok}^{(\na,i)}
\qweq
\left(\rnode{CC}{\mread}^{(\na,i)}\qweq\rnode{DC}{i}^{(\na,i)}\right)^*
\cdots\qweq
\rnode{C}{j_1}^{(\na,k)}
\\
&\quad\;\;
\rnode{B}{\ast_1^{(\na',0)}}
\qweq
\left(\rnode{CA}{\mread}^{(\na',0)}\qweq\rnode{DA}{0}^{(\na',0)}\right)^*
\qweq
\rnode{CB}{\mwrite{i'}}^{(\na',0)}\qweq\rnode{DB}{\mok}^{(\na',i')}
\qweq
\left(\rnode{CC}{\mread}^{(\na',i')}\qweq\rnode{DC}{i}^{(\na',i')}\right)^*
\cdots\qweq
\rnode{C}{j'_1}^{(\na',k')}\qweq
\rnode{D}{(j{+}j')_0}

s&=\, \rnode{A}{\ast_0}\qweq 
\rnode{AA}{\ast_0'}\qweq
\rnode{B}{\ast_1}
\qweq
\rnode{CA}{\mread}\qweq\rnode{DA}{0}
\qweq
\rnode{CB}{\mwrite{1}}\qweq\rnode{DB}{\mok}
\qweq
\rnode{CC}{\mread}\qweq\rnode{DC}{1}
\qweq
\rnode{C}{1_1}
\qweq
\rnode{B}{\ast_1}
\qweq
\rnode{CA}{\mread}\qweq\rnode{DA}{0}
\qweq
\rnode{CB}{\mwrite{1}}\qweq\rnode{DB}{\mok}
\qweq
\rnode{CC}{\mread}\qweq\rnode{DC}{1}
\qweq
\rnode{C}{1_1}
\\
t&=\, \rnode{A}{\ast'_0}
\qweq \rnode{B}{\ast_1}^{(\na,0)}
\qweq
\rnode{CA}{\mread}^{(\na,0)}\qweq\rnode{DA}{0}^{(\na,0)}
\qweq
\rnode{CB}{\mwrite{1}}^{(\na,0)}\qweq\rnode{DB}{\mok}^{(\na,1)}
\qweq
\rnode{CC}{\mread}^{(\na,1)}\qweq\rnode{DC}{1}^{(\na,1)}
\qweq
\rnode{CC}{1_1}^{(\na,1)}\\
&\qquad\qweq\; \rnode{B}{\ast_1}^{(\na',0)}
\qweq
\rnode{CA}{\mread}^{(\na',0)}\qweq\rnode{DA}{0}^{(\na',0)}
\qweq
\rnode{CB}{\mwrite{1}}^{(\na',0)}\qweq\rnode{DB}{\mok}^{(\na',1)}
\qweq
\rnode{CC}{\mread}^{(\na',1)}\qweq\rnode{DC}{1}^{(\na',1)}
\qweq
\rnode{CC}{1_1}^{(\na',1)}\qweq\rnode{DC}{2_0}

s\|t&=\, 
\rnode{A}{\ast_0}
\qweq 
\rnode{A}{\ast'_0}
\qweq 
\rnode{B}{\ast_1}^{(\na,0)}
\qweq
\rnode{CA}{\mread}^{(\na,0)}\qweq\rnode{DA}{0}^{(\na,0)}
\qweq
\rnode{CB}{\mwrite{1}}^{(\na,0)}\qweq\rnode{DB}{\mok}^{(\na,1)}
\qweq
\rnode{CC}{\mread}^{(\na,1)}\qweq\rnode{DC}{1}^{(\na,1)}
\qweq
\rnode{CC}{1_1}^{(\na,1)}\\
&\qquad\qweq\; \rnode{B}{\ast_1}^{(\na',0)}
\qweq
\rnode{CA}{\mread}^{(\na',0)}\qweq\rnode{DA}{0}^{(\na',0)}
\qweq
\rnode{CB}{\mwrite{1}}^{(\na',0)}\qweq\rnode{DB}{\mok}^{(\na',1)}
\qweq
\rnode{CC}{\mread}^{(\na',1)}\qweq\rnode{DC}{1}^{(\na',1)}
\qweq
\rnode{CC}{1_1}^{(\na',1)}\qweq\rnode{DC}{2_0}

\tau' &\defn\sem{\seq{f:\vart\to\int}{\new{x}{fx+fx}:\int}}: (\sem{\vart}\Rarr\Z)\rarr\Z

s'&=\, \rnode{A}{\ast_0}\qweq 
\rnode{AA}{\ast_0'}\qweq
\rnode{B}{\ast_1}
\qweq
\rnode{CA}{\mread}\qweq\rnode{DA}{0}
\qweq
\rnode{CB}{\mwrite{1}}\qweq\rnode{DB}{\mok}
\qweq
\rnode{CC}{\mread}\qweq\rnode{DC}{1}
\qweq
\rnode{C}{1_1}
\qweq
\rnode{B}{\ast_1}
\qweq
\rnode{CA}{\mread}\qweq\rnode{DA}{1}
\qweq
\rnode{CB}{\mwrite{2}}\qweq\rnode{DB}{\mok}
\qweq
\rnode{CC}{\mread}\qweq\rnode{DC}{2}
\qweq
\rnode{C}{2_1}
\\
t'&=\, \rnode{A}{\ast'_0}
\qweq \rnode{B}{\ast_1}^{(\na,0)}
\qweq
\rnode{CA}{\mread}^{(\na,0)}\qweq\rnode{DA}{0}^{(\na,0)}
\qweq
\rnode{CB}{\mwrite{1}}^{(\na,0)}\qweq\rnode{DB}{\mok}^{(\na,1)}
\qweq
\rnode{CC}{\mread}^{(\na,1)}\qweq\rnode{DC}{1}^{(\na,1)}
\qweq
\rnode{CC}{1_1}^{(\na,1)}
\\
&\qquad\qweq\; \rnode{B}{\ast_1}^{(\na,1)}
\qweq
\rnode{CA}{\mread}^{(\na,1)}\qweq\rnode{DA}{0}^{(\na,1)}
\qweq
\rnode{CB}{\mwrite{2}}^{(\na,1)}\qweq\rnode{DB}{\mok}^{(\na,2)}
\qweq
\rnode{CC}{\mread}^{(\na,2)}\qweq\rnode{DC}{2}^{(\na,2)}
\qweq
\rnode{CC}{2_1}^{(\na,2)}\qweq\rnode{DC}{3_0}

  \pv{o} &\defn o  & \ov{\ee} &\defn\ee \\
  \pv{up^\Sigma} &\defn \pv{u}\,p^\Sigma & \ov{uo^\Sigma} &\defn \ov{u}\,o^\Sigma \\
  \pv{u \rnode{A}{m^\Tau}\cdots\rnode{B}{o}^\Sigma\justf[,angleB=20]{B}{A}} &\defn \pv{u}\,m^\Tau o^\Sigma &
  \ov{u \rnode{A}{m^\Tau}\cdots\rnode{B}{p}^\Sigma\justf[,angleB=20]{B}{A}} &\defn \ov{u}\,m^\Tau p^\Sigma

  \ee\iseq\ee\iseq\ee &\defn \ee & \ee\mix\ee\mix\ee &\defn\ee \\
  sm^\Sigma_A\iseq t\iseq r &\defn (s\iseq t\iseq r)m_A^{sm^\Sigma_A\mix t\mix r} &
  sn^\Tau m^\Sigma_{A(P)}\mix t\mix r &\defn \nice(sn^\Tau\mix t\mix r,\Tau,\Sigma) \\ &&
  sm^\Sigma_{A(O)}\mix t\mix r &\defn \tilde\Sigma[s\mix t\mix r] \\
  sm^\Sigma_B\iseq tm^{\Sigma'}_B\iseq r &\defn (s\iseq t\iseq r)m_B^{sm^\Sigma_B\mix tm^{\Sigma'}_B\mix r} &
  sn^\Tau m^\Sigma_{B(P)}\mix tm^{\Sigma'}_{B(O)}\mix r &\defn \nice(sn^\Tau\mix t\mix r,\Tau,\Sigma) \\ &&
  sm^{\Sigma'}_{B(O)}\mix tn^\Tau m^\Sigma_{B(P)}\mix r &\defn \nice(s\mix tn^\Tau\mix r,\Tau,\Sigma) \\
  s\iseq tm^\Sigma_C\iseq rm^{\Sigma'}_C &\defn (s\iseq t\iseq r)m_C^{s\mix tm^\Sigma_C\mix rm^{\Sigma'}_C} &
  s\mix tn^\Tau m^\Sigma_{C(P)}\mix rm^{\Sigma'}_{C(O)} &\defn \nice(s\mix tn^\Tau\mix r,\Tau,\Sigma) \\ &&
  s\mix tm^{\Sigma'}_{C(O)}\mix rn^\Tau m^\Sigma_{C(P)} &\defn \nice(s\mix t\mix rn^\Tau,\Tau,\Sigma) \\
  s\iseq t\iseq rm^\Sigma_D &\defn (s\iseq t\iseq r)m_D^{s\mix t\mix rm^\Sigma_D} &
  s\mix t\mix rn^\Tau m^\Sigma_{D(P)} &\defn \nice(s\mix t\mix rn^\Tau,\Tau,\Sigma) \\ &&
  s\mix t\mix rm^\Sigma_{D(O)} &\defn \tilde\Sigma[s\mix t\mix r]

\nice((s_1;s_2m_{A_1}^{\Sigma});s_3,\st{s_1m_{A_1}^{\Sigma}; s_2},s_1m_{A_1}^{\Sigma}\mix s_2)={\Sigma'[s_1m_{A_1}^{\Sigma}\mix s_2]}=\Sigma'.
s_1m_{A_1}^{\Sigma};(s_2;s_3)=(s_1;(s_2;s_3))m_{A_1}^{\Sigma''}\overset{\text{IH}}{=}(s_1\iseq
s_2\iseq s_3)m_{A_1}^{\Sigma''}\rest A_1A_4
\Sigma''=\nice(s_1\mix(s_2;s_3),\Tau,\Sigma)\overset{\text{IH}}{=}\nice(s_1\mix
s_2\mix s_3,\Tau,\Sigma)=s_1m_{A_1}^\Sigma\mix s_2\mix
s_3\,.
\nice((&s_1m_{A_2}^{\Sigma_1};s_2m_{A_2}^{\Sigma_2})\mix s_3,\st{s_1m_{A_2}^{\Sigma_1};s_2m_{A_2}^{\Sigma_2}},s_1m_{A_2}^{\Sigma_1}\mix s_2m_{A_2}^{\Sigma_2})\\
&= \nice((s_1;s_2)\mix s_3,\st{s_1;s_2},\nice(s_1\mix s_2,\Tau,\Sigma_1)) \\
 s_1m_{A_2}^{\Sigma_1}\mix s_2m_{A_2}^{\Sigma_2}\mix s_3 &= \nice(s_1\mix s_2\mix s_3,\Tau,\Sigma_1)\overset{\text{IH}}{=}
\nice(\nice((s_1;s_2)\mix s_3,\st{s_1;s_2},s_1\mix s_2),\Tau,\Sigma_1)

& \nice(s_1m_{A_2}^{\Sigma_1}\mix(s_2m_{A_2}^{\Sigma_2};s_3),\st{s_2m_{A_2}^{\Sigma_2};s_3},s_2m_{A_2}^{\Sigma_2}\mix s_3)=
(s_1m_{A_2}^{\Sigma_1}\mix(s_2m_{A_2}^{\Sigma_2};s_3))[s_2m_{A_2}^{\Sigma_2}\mix s_3] \\
&\quad\overset{\text{lm.\,\ref{l:inter}(g)}}{=} s_1m_{A_2}^{\Sigma_1}\mix(s_2m_{A_2}^{\Sigma_2};s_3)= \nice(s_1\mix(s_2;s_3),\Tau,\Sigma_1)\\
& s_1m_{A_2}^{\Sigma_1}\mix s_2m_{A_2}^{\Sigma_2}\mix s_3 = \nice(s_1\mix s_2\mix s_3,\Tau,\Sigma_1)\overset{\text{IH}}{=}
\nice(\nice(s_1\mix(s_2;s_3),\st{s_2;s_3},s_2\mix s_3),\Tau,\Sigma_1)\\
&\quad=\nice((s_1\mix(s_2;s_3))[s_2\mix s_3],\Tau,\Sigma_1)\overset{\text{lm.\,\ref{l:inter}(g)}}{=}\nice(s_1\mix(s_2;s_3),\Tau,\Sigma_1)
 \sigma\iseq\tau\defn\{s\iseq t\ |\ s\in\sigma\land t\in\tau\land s\asymp t\} 
\id_A = \makeset{ s\in\Splays{A\arr A}\ |\ \exists s'.\, s\prefix s'\land s'\rest A_l=s'\rest  A_r}
 
\viewf(\sigma)\defn \{\pv{s}\ |\ s\in\sigma\land \mathsf{even}(|s|)\land s\not=\epsilon\} 

\begin{aligned}\
We next make formal the connection between view-functions and innocent S-strategies.
}

A \boldemph{view-function}  on  is a subset of  satisfying:
\begin{itemize}
 \item If  then  is even and .\ ({\em  View})
 \item If  and  then .\ ({\em Even-Prefix Closure})
 \item If  then .\ ({\em Nominal Closure})
 \item If  then .\ ({\em Determinacy})
\end{itemize}
From a view-function  we can derive an innocent S-strategy  by the following procedure. We set , where

and .

\begin{lemma}
If  are an innocent S-strategy and a view-function respectively then  are a view-function and an innocent S-strategy respectively. Moreover,  and . \qed
\end{lemma}

We can show that  exhibits the same kind of categorical structure as that obtained in~\cite{HY97} (in the context of call-by-value PCF),
which can be employed to model call-by-value higher-order computation with recursion.
In particular, let us call an S-strategy  \boldemph{total} if for all  there is . We write  for the wide subcategory of  containing total innocent S-strategies.

For innocent S-strategies  and , we define their \emph{left pairing} to be
, where  is the view-function:

We can show that left pairing yields a product in  with the usual projections:

and dually for .
Moreover, for every , there is a bijection

natural in . In particular, for each innocent , , where

The inverse of  is defined is an analogous manner. We set .

Thus, the functional part of  can be interpreted in  using the same constructions as in~\cite{HY97}.
Assignment, dereferencing and  can in turn be modelled using
the relevant (store-free) innocent strategies of~\cite{AM97b}. 
Finally, the denotation of  is obtained by using  of Example~\ref{ex:cell}.
Let us write  for the resultant semantic map.

\begin{proposition}\label{prop:model}
For any  -term ,
 is an innocent S-strategy. 
\end{proposition}
\begin{proof}
We present here the (inductive) constructions pertaining to variables, 
\begin{itemize}
\item

\item 

\item

\item

\end{itemize}
and refer to~\cite{HY97} for the functional constructions and the treatment of fixpoints.
\end{proof}

\cutout{With the soundness and definability results in place, we could now proceed in the familiar way to define a fully abstract model of  via  taking the intrinsic quotient.
However, this would be somewhat counterproductive.
It turns out that  is a conservative extension of  (Corollary~\ref{cor:conservativity}),
so the (simpler) fully abstract model of  from~\cite{AM97b}, based on knowing
strategies, is already fully abstract for .
In fact, our model can be related to knowing strategies more precisely. Observe that by erasing
storage annotations in an innocent S-strategy  we obtain a knowing strategy,
which we call  (determinism follows from the fact that stores in O-moves
are uniquely determined and from block-allocation). 
Let us write 
for the knowing strategy semantics (cast in~\cite{HY97}). 
}{Our model of , based on innocent -strategies, is closely related to one based on knowing strategies.
First observe that by erasing storage annotations in an innocent S-strategy  one obtains a knowing strategy
(determinacy follows from the fact that stores in O-moves are uniquely determined).
We shall refer to that knowing strategy by .
Next note that the (simpler) fully abstract model of  from~\cite{AM97b}, based on knowing strategies, also yields a model of .
Let us write 
for this knowing-strategy semantics (cast in the Honda-Yoshida setting).
Then we have:}

\begin{lemma}
For any -term ,
.
\end{lemma}

\subsection{Block-innocent strategies}

\begin{definition}
A (knowing) strategy  is \boldemph{block-innocent} if  for some innocent S-strategy .
\end{definition}

\begin{example}
Let us revisit the two plays from the Introduction. The first one
indeed comes from an innocent S-strategy (we reveal the stores below).
3mm]
\rnode{A}{q}&
\rnode{B}{q^{(\na,0)}}&
\rnode{C}{q^{(\na,0)}}&
\rnode{D}{1^{(\na,1)}}&
\rnode{E}{q}^{(\na,1)}&
\rnode{F}{2^{(\na,2)}}&
\rnode{G}{a}^{(\na,2)}&
\rnode{H}{a}&
\rnode{I}{q}&
\rnode{J}{0}&
\rnode{K}{q}&
\rnode{L}{0}
\justf[,angleA=120,angleB=20]{E}{B}\justf[,angleA=140,angleB=20]{G}{B}\justf[,angleA=150,angleB=20]{H}{A}\justf{K}{H}
\end{array}

\begin{array}{l@{\quad\;}l@{\quad\;}l@{\quad\;}l@{\quad\;}l@{\quad\;}l@{\quad\;}l@{\quad\;}l@{\quad\;}l@{\quad\;}l}
\3mm]
\color{gray}
1&
\color{gray}2&\color{gray}3&\color{gray}4&\color{gray}5&\color{gray}6&\color{gray}7&\color{gray}8&\color{gray}9&\color{gray}10
\justf[,angleA=120,angleB=20]{E}{B}\justf[,angleA=140,angleB=20]{G}{B}\justf[,angleA=150,angleB=20]{H}{A}\justf{K}{G}
\end{array}
 
\sigma &= \{(\overline{*}_1^{\,m'},i,\overline{q}_{m'+2}^{\,m})\,s\ |\ (\overline{*}_1^{\,m'},\overline{q}_{m'+2}^{\,m})\,s\in\tau_i\}\\
\text{where\ }
\tau_i &\defn \sem{\overline{\theta}_1^{\,m'}}\otimes\sem{\overline{\theta}_{m'+2}^{\,m}}\xrightarrow{\cong\,;\,\id\otimes i\otimes\id} \sem{\overline{\theta}_1^{\,m'}}\otimes \Z\otimes\sem{\overline{\theta}_{m'+2}^{\,m}}\xrightarrow{\sigma}\sem{\delta}
 \sigma':\sem{\overline{\theta}}\otimes\sem{\delta'}\arr\sem{\delta''}\defn\strat\{(\overline{*},q_{\delta'})\,s\ |\ \overline{*}\,a\,q_{\delta'}s\in\viewf(\sigma)\}  \sigma':\sem{\overline{\theta}_1^{\,l-1}}\otimes\sem{\overline{\theta}_{l+1}^{\,m}}\otimes(1\Arr\Z)\otimes(\Z\Arr1)\longrightarrow\sem{\delta}
 \sigma=\sem{\overline{\theta}}\xrightarrow{\ang{\Lambda(\sigma''),\pi_l,\sigma'}}(\sem{\theta_l''}\Arr \sem{\delta})\otimes(\sem{\theta_l'}\Arr\sem{\theta_l''})\otimes \sem{\theta_l'}\xrightarrow{\id\otimes\app;\,\app}\sem{\delta} 
      \sigma':\sem{\overline{\theta}}\arr\sem{\theta_l'}
&\defn\strat(\{\overline{*}\,a\}\cup\{\overline{*}\,a\,q_l'\,s\ |\ \overline{*}\,q\,q_l'\,s\in\viewf(\sigma)\land q_l'\in M_{\sem{\theta_l'}}\}) \\
      \sigma'':\sem{\overline{\theta}}\otimes\sem{\theta_l''}\arr \sem{\delta} &\defn \strat\{(\overline{*},q_l'')s\ |\ \overline{*}\,q\,a_l'' s\in\viewf(\sigma)\land q_l''=a_l'' \}
     \sigma=\sem{\overline{\theta}}\xrightarrow{\ang{\Lambda(\sigma'),\id}}(\sem{\vart}\rarr\Z)\otimes\sem{\overline{\theta}}\xrightarrow{\cell\otimes\id}
    \Z\otimes\sem{\overline{\theta}}
    \xrightarrow{\sigma''}\sem{\delta}
        \sigma':\sem{\vart}\otimes\sem{\overline{\theta}}\arr\Z &\defn\strat(\,\{\psi(sm^\Tau)\ |\ sm^\Tau\in\viewf(\sigma)\land\na\in\nu(\Tau)\} \\
        &\qquad\qquad\cup \{\psi(s)\code{s}\ |\ sm^\Tau\in\viewf(\sigma)\land\na\in\nu(\st{s}\remv\Tau)\}\,) \\
        \psi(o^{(\na,i)::\Tau} s)&\defn o^\Tau \rd^\Tau i^\Tau\psi(s) \\
        \psi(p^{(\na,i)::\Tau} s)&\defn \mwrite{i}^\Tau \ok^\Tau p^\Tau\psi(s) \\
        \sigma'':\Z\otimes\sem{\overline{\theta}}\arr\sem{\delta} &\defn \strat\{(\code{s},\overline{*})\,m^\Tau t\ |\ s\,m^\Tau t\in\viewf(\sigma)\land\na\in\nu(\st{s}\remv\Tau) \}
    
O(\viewf(\sigma)) = \makeset{\makeset{\pi\cdot s\ |\ \pi\in\permg}\ |\ s\in\viewf(s)}
 
\eff(so^\Sigma)\defn\eff(s)o^{\pi_2(\Sigma)}\,,\quad\eff(sm^\Sigma p^\Tau)\defn\eff(sm^\Sigma)p^{\pi_2(\Tau),|\Tau\remv\Sigma|}\,. 
 z:\List{T_i},\,\Gamma \vdash M:\delta  z^L:\int,\,z^R:\int\arr{T_i},\,\Gamma \vdash M:\delta  z:\List{T_i},\,\Gamma \vdash \letin{z^L=z^L{-}1}{M}:\delta.   z:\List{T_i},\,\Gamma \vdash \remove{z}{j}{M}:\delta   
z:\List{T_i},\,\Gamma \vdash (\lambda z^L.\lambda z^R.\,M)(z^L{-}1)(\lambda x.\ \cond{x<j}{z^Rx}{z^R(x{+}1)}):\delta. 
  
z:\List{T_i},\,\Gamma \vdash \add{z}{j}{N}{M}:\delta 
  
z:\List{T_i},\,\Gamma \vdash (\lambda z^L.\lambda z^R.\,M)(z^L{+}1)(\lambda x.\ 
\cond{x<j}{z^Rx}{\cond{x=j}{N}{z^R(x{-}1)}}):\delta 

\Hextend{z}{N}{M}\qquad
\Textend{z}{N}{M}
 \deindx{M} \defn \letin{\overline{z=\bot}}{(\Hextend{z_{l_m}}{x_m}{(\dots\ (\Hextend{z_{l_1}}{x_1}{M}))})},  \letin{\overline{z=\bot}}{N}\defn \letin{z_{0}^L=0,z_{0}^R=\lambda x.\Omega}{(\dots\ (\letin{z_{n}^L=0,z_{n}^R=\lambda x.\Omega}{N}))}  \sigma = \ssem{\deindx (F_\delta\code{\sigma})}\,.  D,H:\omega\rightharpoonup\omega\text{ and }B:\omega\times\omega\rightharpoonup \omega 
D\code{\sigma}&=\begin{cases}
\,i &\text{ if  falls within the -th case of DL}\\ \bot &\text{ otherwise}
\end{cases}
\\
B(\code{\sigma},i) &= \begin{cases}
\code{\tau_i} &\text{ if  and  are related as in first case of DL}\\
 \bot &\text{ otherwise}
\end{cases}\\
H\code{\sigma} &=\begin{cases}
\,i &\text{ if  are related as in third case of DL}\\
\code{\code{\sigma_1},\code{\sigma_2}} &\text{ if  are related as in fourth case of DL}\\
\code{\sigma'} &\text{ if  are related as in fifth case of DL}\\
\code{i,\code{\sigma'}} &\text{ if  are related as in sixth case of DL}\\
&\text{ and }
\indx(\theta_1,...\,,\theta_{l})=(2,i)
\\	
\code{i_1,i_2,\code{\sigma'},\code{\sigma''}} &\text{ if  are related as in seventh case of DL}\\
&\text{ and }\indx(\theta_1,...\,,\theta_l)=(i_1,i_2)\\	
\code{\code{\sigma'},\code{\sigma''}} &\text{ if  are related as in eighth case of DL}
\end{cases}

z_0:\List{T_0},\dots,z_n:\List{T_n}\vdash F_\delta:\int\arr\delta

  F_\delta \defn \lambda k^\int.\ &\mathsf{if}\ z_{1}^L\neq0\ \mathsf{then}\
  \letin{x=z_1^R1}{\remove{z_1}{1}{F_\delta(\tilde{B}\,k\,x)}}\\
&\mathsf{else}\ \mathsf{case}\ (\tilde{D}\,k)\ \mathsf{of} \\
  &\qquad2:\ \sskip\\
  &\qquad3:\ \tilde{H}k\\
  &\qquad4:\ \letin{\code{k_1,k_2}=\tilde{H}k}{\mkvar(F_{\comt\arr\int}\,k_1,F_{\int\arr\comt}\,k_2)}\\
  &\qquad5:\ \lambda y^{T_{l(\delta)}}.\,\Textend{z_{l(\delta)}}{y}{F_{T_{r(\delta)}}(\tilde{H}\,k)}\\
  &\qquad6:\ \letin{\code{i,k}=\tilde{H}k}{}\\ 
  &\qquad\qquad\Textend{z_3}{\lambda x^\comt.\,!(z_2^Ri)}{}\-2.5mm]
  &\qquad\qquad\,\vdots \-2.5mm]
  &\qquad\qquad\,\vdots \
\end{definition}

\noindent The construction of  follows closely the decomposition of  according to 
the Decomposition Lemma. In particular, on receiving , the term decides,
using the functions  and  of Lemma~\ref{l:DLDL}, to which branch of DL 
 can be matched.
Some branches decompose  into further strategies,
in which case  will recursively call some  to simulate the rest of the strategy.
The use of lists in contexts guarantees that such a call is indeed recursive:  is only parameterised by the output type , and each such  is in .
\begin{proposition}[Universality]\label{prop:univ}
For every  and recursively presentable innocent S-strategy \,,\,
\,.
\end{proposition} 
\begin{proof}
Suppose  receives  in its input , where . Then

recognizes the first branch of the DL. Recall that , so , and therefore  holds iff there is some . If this is so, then  needs to return a term corresponding to the strategy instantiated with the leftmost element in the list .  This is achieved by first applying  to  to obtain  
and applying  to it.

If ,   will call  on , 
which will return the number of the case from DL  ({\bf 2}-{\bf 8}) that applies to .
Subsequently,  will proceed to a case analysis. Below we examine two cases in detail. 
\begin{enumerate}[label={\bf\arabic*}:]
\item[{\bf 5}:]  is the currying of  , so  should return 
`'. Now,  is , i.e.\ , where . In order to preserve typability, we need to add the abstracted variable to the context of , which is what  achieves.
\item[{\bf 8}:]  introduces some fresh name and decomposes to 
as in the Decomposition Lemma. Hence,   should return ', which is exactly what the code achieves.
\end{enumerate}
The other cases are similar.
\end{proof}

\begin{remark}
It is worth noting that the universality result for innocent S-strategies
implies an analogous result for innocent strategies and .
Thanks to call-by-value, the result is actually sharper than the universality results of~\cite{AJM00,HO00}, which had
to be proved ``up to observational equivalence". This was due to the fact that partial
recursive functions could not always be represented in the canonical way (i.e.\ by
terms for which the corresponding strategy contained plays of the form ).
This is no longer the case under the call-by-value
regime, where each partially recursive function  can be coded by a term
whose denotation will be the strategy based on plays of the shape .
\end{remark}



\section{From omniscience to innocence}

In Section~\ref{sec:syntax} we introduced the three languages: ,
 and , interpreted respectively by innocent, block-innocent and knowing 
 strategies. Let  be a \nt{prearena}. We write ,  and 
for the corresponding classes of (store-free) strategies  in .
Obviously, .
 Next we shall study type-theoretic conditions under which
 one kind of strategy collapses to another. Thanks to universality results,
 this corresponds to the existence of an equivalent program in a weaker language.
 \begin{thm}\label{lem:bk}
Let .
Then .
\end{thm}
\begin{proof}
Observe that there exist moves  such that
 and consider
, i.e. 
has no response at . Then .
It is worth remarking that a strategy of the above kind denotes the -term
.
\end{proof}
Theorem~\ref{lem:bk} confirms that, in general, block structure restricts expressivity.
However,  the next result shows this not to be the case for open terms of base type.
\begin{thm}
Let  .
Then .
\end{thm}
\begin{proof}
Observe that any knowing strategy for  becomes block-innocent if
in the second-move P introduces a store with one variable that keeps track of the history of
play (this is reminiscent of the factorization arguments in game semantics).
The variable should be removed from the store by P only when he plays an
answer to the initial question.
\end{proof}
By universality, we can conclude that each -term of base type
is equivalent to an -term. Since contexts used for
testing equivalence are exactly of this kind, we obtain the following corollaries.
The first one amounts to saying that  is a conservative extension of .
The second one states that block-structured contexts suffice to distinguish
terms that might use scope extrusion.

\begin{corollary}\label{cor:conservativity}
For any -terms  and -terms :
\begin{itemize}
\item 
if, and only if, ;
\item 
if, and only if, .
\end{itemize}\qed
\end{corollary}
Now we investigate the boundary between block structure
and lack of state.
\begin{lemma}\label{lem:binno-inno}
Let  be a \nt{prearena} such that each question enables an answer
\footnote{All denotable \nt{prearenas} enjoy this property.}.
The following conditions are equivalent.
\begin{enumerate}
\item .
\item No O-question is enabled by a P-question:
 implies .
\item Store content of O-questions is trivial:
 implies .
\end{enumerate}
\end{lemma}
\begin{proof}\hfill
\begin{itemize}[label=]
\item[]  We prove the contrapositive. Assume 
that there exists a P-question  and an O-question  
such that .
Let  be a chain of hereditary enablers of  (starting from an initial move) 
augmented with pointers from non-initial moves to the respective preceding moves.
Then 


defines a block-innocent strategy that is not innocent.


\item[] Suppose no P-question enables an O-question in 
and let .
Then the sequence of hereditary justifiers of  in ,
in order of their occurrence in ,  must have the form .
Consequently, none of the stores involved can be non-empty, so 
must be empty too.
\item[]
We observe that
, where  justifies ,  
implies . Note that, in presence of block innocence, this
implies innocence because the store content of O-moves 
can be reconstructed uniquely from the P-view.
Thus, it suffices to prove our observation correct.
\begin{itemize}
\item If  is a question, we simply use our assumption: then we must have
 and, because , we can conclude
.
\item If  is an answer then  must be a question. We claim that 
no store in  can contain variables from .
Suppose this is not the case and there is such an occurrence.
Then the earliest such occurrence must be part of an O-move.
This move cannot be a question due to our assumption, so 
it is an answer move. By the bracketing condition, this must be an 
answer that an earlier P-question played after . Moreover, the store
accompanying that question must also contain a variable from 
contradicting our choice of the earliest occurrence.\qedhere
\end{itemize}
\end{itemize}
\end{proof}

\noindent Thanks to the following lemma we will be able to determine precisely at which 
types  block-innocence implies innocence.
\begin{lemma}
 satisfies condition 2.
of Lemma~\ref{lem:binno-inno} iff  ()
and .
\end{lemma}
Consequently, second-order -terms always have
purely functional equivalents.
Finally, we can pinpoint the types at which strategies are bound to be innocent:
it suffices to combine the previous findings.
\begin{thm}
Let . Then 
 iff  () and .
\end{thm}
In the next section we demonstrate that the gap in expressivity between 
and  also bears practical consequences.  The undecidable equivalence
problem for second-order finitary  becomes decidable in second-order finitary 
(as well as at some third-order types).





\section{Decidability of a finitary fragment of \texorpdfstring{}{IAcbv}}

In order to prove program equivalence decidable, we restrict the base
datatype of integers to the finite segment  ()
and replace recursive definitions () with looping ().
Let us call the resultant language .
Our decidability result will hold for a subset  of , in which
type order is restricted.  will reside inside the third-order fragment of 
and contain its second-order fragment. Note that the second-order fragment of 
similarly restricted  is known be undecidable (even without loops)~\cite{Mur04b}.

The decidability of program equivalence in  will be shown by translating terms
to regular languages representing the corresponding \emph{block-innocent} strategies.
We stress that we are \emph{not} going to work with the induced S-plays.
Nevertheless, the translation will rely crucially on insights
gleaned from the semantics with explicit stores. In particular, we shall take advantage of the uniformity inherent in block innocence
to represent only subsets of the strategies in order to overcome technical problems presented by pointers.
We discuss the issue next.

\subsection{Pointer-related issues}

Pointers from answer-moves need not be represented at all, because they are uniquely reconstructible through the well-bracketing condition.
However, this need not apply to pointers from questions. The most obvious way to represent them is to decorate moves
with integers that encode the distance from the target in some way. Unfortunately, there are scenarios in which the distance can grow arbitrarily.

\cutout{
Next we analyse two typing scenarios that look hopeless from the point of view of encoding
pointers, since the distance from the pointer can grow arbitrarily. In the first case, thanks to
block-innocence, we will be able to overcome the difficulties. The other case
must remain a challenge for future work (or an undecidability result). On the basis of 
our discussion we shall subsequently introduce the type system of .
}
Consider, for instance,  the \nt{prearena} .
Due to the presence of the  arrows on the right-hand side we obtain chains of enablers
, where  is initial and 
each  () is initial in . We shall call the moves \emph{spinal}.
Observe that plays in  can have the following shape

and any of the occurrences of  could be used to justify , thus creating several different options for justifying .
If we consider S-plays for , Definition~\ref{def:splay} implies that none of the moves  will ever carry a non-empty store.
Consequently, whenever a play of the above kind comes from a block-innocent strategy, its behaviour in  the  segments
will not depend on that in the other  segments. Thus, in order to explore exhaustively the range of behaviours offered by a block-innocent strategy
(so as to compare them reliably), it suffices to restrict the number of 's  to .
Next, under the assumption that  occurs only once, one can repeat the same argument for  to conclude
that a single occurrence of  will suffice, and so on.
\cutout{
Consider  (i.e. ),
which contains plays of the form  for any . Pointers are still uniquely
determined in these plays, but everything changes once O plays  next.
Then the target might be any of the  occurrences of . The strategy in question actually 
offers responses in all such cases, so it would seem that all of these plays need to be represented
(thus necessitating the use of an infinite alphabet). Fortunately, thanks to block-innocence, we
can restrict ourselves to the case  and make the problem disappear. To see why, 
observe that none of the moves  will ever carry a non-empty store in an S-play,
by Definition~\ref{def:splay}. Thus, because the strategy is block-innocent, its behaviour is already represented faithfully
by the single play . In fact, this is one of the cases when block-innocence implies innocence,
but in general this will not be true for denotations  of -terms.

Hence, we generalize the observation as follows. Since the move  never carries a non-trivial store, it follows that no 
additional information about the strategy is hidden in plays containing two occurrences of . This is because
a block-innocent strategy has to behave uniformly after each  and in general will depend only
on what happened between  and , and not on what happened after a previous copy of 
was played (there can be no communication between the ``threads" started with  because  cannot carry 
a non-trivial store).
Now that it is known that O need only play one occurrence of , we can apply 
a similar reasoning to , and so on. 
}
Altogether this yields the following lemma. Note that, due to Visibility,  
insisting on the presence of a unique copy of  in a play amounts to 
asking that each  be preceded by .
\begin{lemma}
Call a play \emph{spinal} if each spinal question  () occurring in it 
is the immediate successor of .
Let  be the set of spinal plays of .
Let  be block-innocent strategies.
Then  implies .\qed
\end{lemma}
Hence, for the purpose of checking program equivalence, it suffices to compare
the induced sets of \emph{spinal} complete plays. Moreover, the pointer-related problems discussed above will not arise.



Now that we have dealt with one challenge, let us introduce another one, which
cannot be overcome so easily. Consider the \nt{prearena} 
 and the enabling 
sequence  it contains. Now
consider the plays , where . Again, to represent
the pointer from  to one of the  occurrences of , one would need an unbounded number of indices.
This time it is not sufficient to restrict  to , because the behaviour need not be uniform
after each  (this is because in the setting with stores a non-empty store
can be introduced as soon as in the second move ). To see that the concern is real,
consider the term 
,
where  contain some code inspecting and changing the value of .

This leads us to introduce  via a type system that will not generate the configuration
just discussed. Another restriction is to omit third-order types in the context, as
they lead beyond the realm of regular languages 
(cf. ).
Since  leads to identical problems as , we restrict its use
accordingly.

\subsection{\texorpdfstring{}{IA2+}}

\begin{definition}
 consists of -terms whose typing derivations rely solely on typing
judgments of the shape
,
where  and  are defined by the grammar below.

\end{definition}\medskip

\noindent A lot of pointers from questions become uniquely determined in strategies
representing  terms, namely, all pointers from any O-questions and all
pointers from -questions to O-questions.
\begin{lemma}\label{lem:pointers}
Let  and ,  be spinal plays of 
that are equal after all pointers from O-questions and all pointers from P-questions
to O-questions have been erased. Then .
\end{lemma}
\begin{proof}
Observe that whenever a P-question 
is enabled by an O-question in the \nt{prearenas} under consideration, the O-question must be spinal. Hence,
because both  and  are spinal, all such O-questions will
occur only once, so pointers from P-questions to O-questions are 
uniquely reconstructible.

Now let us consider O-questions. Observe that, due to restrictions on the type
system of , whenever an O-question is justified by a P-answer, both will be
spinal. Hence only one copy of each can occur in a spinal position, making pointer
reconstruction unambiguous. Finally, we tackle the case of O-questions justified
by P-questions.

\begin{itemize}
\item If  comes from a type of the context then, due to the shape of types involved,
any sequence of hereditary enablers of  must be of the form 
, where 
is initial and each of the moves listed enables the following one.
If a move  enables  hereditarily, let us define its degree
as the distance from the initial move in the sequence above
(this definition is independent of the actual choice of the chain
of enablers; the degree of  is ,  that of  is ).

By induction on move-degree we show that in any O-view
only one move of a given degree can be present, if at all.
By visibility this makes pointer reconstruction unambiguous. 
\begin{itemize}
\item By definition of a play  can occur in an O-view only once.
Whenever  is present in an O-view, it must preceded by an initial move,
so its  position in an O-view is uniquely determined (always second).
\item Since  occurs only once in an O-view, so does  (questions can be
answered only once). Hence,  can also occur only once, because each
occurrence must be preceded by .
\end{itemize}
Consequently, any move of degree  () 
can only occur once in an O-view and thus the pointer from 
can be reconstructed uniquely.
\item If  originated from the type on the right-hand side of the typing
judgment, we can repeat the reasoning above. The only difference is
that the sequences of enablers are now of the form

where  () are spinal. Then the base case
of the induction () follows from the fact that we are dealing with
spinal plays.\qedhere
\end{itemize}
\end{proof}

\noindent Thus, the only pointers that need to be accounted for are those from P-questions
to O-answers. Here is the simplest scenario illustrating that they can be ambiguous.
Consider the terms 

where .
They lead to the following plays, respectively for  and , which are equal up to 
pointers from P-questions to O-answers.

\medskip


\begin{remark}{
In the conference version of the paper~\cite{MT10} we suggested that justification pointers of the above kind be represented
with numerical indices encoding the target of the pointer inside the current P-view.
More precisely, one could enumerate (starting from ) all question-enabling O-answers in the P-view. Then pointers from P-questions
to O-answers could be encoded by decorating the P-question with the index of the O-answer. The plays above 
could then be coded as  and  respectively.
Unfortunately, there exists terms that  generate plays where such indices would be unbounded, such as

where  and . Because the number of loop iterations is unrestricted, the number needed to represent the
justification pointer corresponding to the rightmost occurrence of  cannot be bounded. Consequently, the representation scheme proposed in~\cite{MT10}
would lead to an infinite alphabet. Next we show that this problem can be overcome, though.
}
\end{remark}
The above-mentioned defect can be patched with the help of a different representation scheme based on annotating targets and sources of 
justification pointers, with  and  respectively. We shall use the same two symbols for each pointer.
This can lead to ambiguities if many pointers are represented at the same time in a single string.  However, to avoid that, we are going to use
multiple strings to represent a single play. More precisely, these will be strings corresponding to the underlying sequence of moves
in which each pointer may or may not be represented, i.e. 
plays featuring  pointers from P-questions to O-answers will be represented by  encoded strings. For example, to represent

\medskip


we shall use the following four strings

Note that the last string represents pointers ambiguously, though the second and third strings identify them uniquely. 
We could have achieved the same effect using strings  in which only one pointer is represented~\cite{HMO11} but, from the technical point of view, it is easier to include 
all possible pointer/no-pointer combinations.

\subsection{Regular-language interpretation}

In order to translate -terms into regular languages representing their game semantics, we 
we restrict our translation to terms in a canonical shape, to be defined next. 
Any -term can be converted effectively to such a form and the conversion
preserves denotation.

The canonical forms are defined by the following grammar. We use types as 
superscripts, whenever we want to highlight the type of an identifier ( 
range over identifier names). Note that the only identifiers in canonical form are those of base type, 
represented by   below.

\begin{lemma}\label{lem:canon}
Let  be an -term. There is
an -term  in canonical form, effectively
constructible from , such that .
\end{lemma}
\begin{proof}
 can be obtained via a series of -expansions, -reductions and
commuting conversions involving  and . We present a detailed argument in Appendix~\ref{apx:canon}.
\end{proof}
A useful feature of the canonical form is that the problems with pointers 
can be related to the syntactic shape: they concern references to -bound identifiers 
such that  is \emph{not} a base type (i.e.  or  is a function type).
\cutout{The representation scheme for pointers corresponds then to enumerating such  bindings
along branches of the syntactic tree of the canonical form (using  for topmost bindings).}
Below we state our representability theorem for -terms.
The definition of  is actually too generous, as we shall only need  to
decorate P-questions enabled by O-answers.
\begin{proposition}\label{prop:regular}
Suppose  is an -term. Let , 
where .
Let  be the set of non-empty spinal complete plays from .
Then  can be represented as a regular language over a \emph{finite} subset of .
\end{proposition}
\begin{proof}
 can be decomposed as . Obviously 
is regular if, and only if, any  is regular (). Hence, it suffices to show
that  is regular for any relevant .

As already discussed, the regular-language representations, which we shall also refer to by ,
will consist of plays in which individual pointers may or may not be represented. However, because all possibilities are covered, 
this will yield a faithful representation of the induced complete plays.
We proceed by induction on the structure of canonical forms. Let  range over . 
\begin{itemize}
\item 
\item 
\item 
\item 
\item , 
where 
\item 
\item 
\item 

\item 

\item  where, \nt{writing  for the shuffle operator on strings,} 

and  is the finite alphabet used to represent .
\end{itemize}
The substitution  highlights the fact that the moves associated with  have to be bijectively relabelled, because
the copy of  moved from the left- to the right-hand side of the context.
 stands for erasure of all moves associated with . Obviously, these (homomorphic) operations preserve regularity. 
Note that the clause for  is correct because we consider spinal plays only.

For  we sometimes refer
to components determined by the following decomposition.

The components  can be extracted from 
by applying operations preserving regularity (intersection, erasure), so the latter is regular iff each of the former is.
\begin{itemize}
\item 
\item 
\end{itemize}


The remaining cases are those of -bindings of the form .
First we explain some notation used throughout.
Consider the following context .
We shall refer to moves contributed by  with .
If we want to range solely over O- or P-moves from the component, we use  and  respectively.
Moreover, we use  to refer to copies of  in the  component.
The most common operation performed using this notation will be the relabelling of  to .
If  is a function type, then there is a unique P-question  enabled by the initial move .
Whenever we have a separate substitution rule for , the rule for  or  will not apply to .
In most cases we will want to substitute  or  for . In the latter case,  stands for 
annotated to represent the source of a pointer to a source move represented by .

First we tackle cases where the bound value is of function type, i.e. those related to possibly ambiguous
pointer reconstruction. Note that we include plays with and without pointer representations.
\begin{itemize}
\item 
given 

\item 
given  and 

where  
\item 
given , as well as  and 

where  
\end{itemize}
To understand the second formula (the third case is analogous) observe that, after  has been played,
plays for  are plays from  interleaved with possible detours to :
such a detour can be triggered by   from  each time the second move () is O-visible. 
Moreover, provided  is O-visible,
such a detour can also take place between  and .
The following auxiliary lemma will help us analyze when detours can occur.
\begin{lemma}
Let  be a \nt{prearena},  be non-empty and   --- the set of P-moves enabled by 
the initial move of . Let  be a prefix of  containing at least two moves.
Then the O-view of  contains exactly one move from .
\end{lemma}
\begin{proof}
Any non-initial move must be either in  or hereditarily enabled by a move from .
By visibility the O-view of  any prefix of  must thus contain
a move from . Because moves from  are enabled by the initial move, they are
always the second moves in O-views. Hence, no two moves from  can occur in the same O-view.
\end{proof}
Let us apply the lemma to the denotation of . Because  is a base type
it follows that at any time non-trivial O-views will contain a move from  enabled
by the initial move or the answer from  (which completes the play).
Returning to the play for , this means that during a detour the second move
 will be hidden from O-view until the detour is completed, i.e.
a single detour has to be completed
before the next one begins. Hence,  has the form .

Also by the lemma above, once the play after  progresses, the second move  will be O-visible if, and only if,
 (which  enables) is. Thus detours will be possible exactly after  
plays a -move hereditarily justified by , which corresponds to  playing
a -move hereditarily justified by  in  (hence the substitutions  restricted
to -moves). A special case is then that of  which, as a question enabled by an answer, should be represented both with and without a pointer.

The above three cases cover all scenarios (that can arise in ) in which 's type 
is of the form .
The cases where  are analogous except that one needs to use  to range
over  rather than the single move enabled by .
It remains to consider cases of . The bound values are of base type, so  no new pointer indices need to be
introduced.
\begin{itemize}
\item 
given 

\item 
given  and 

where  
\item 
given ,  and 

where .\qedhere
\end{itemize}
\cutout{
For brevity, we shall write  instead of  whenever 
it is clear what  should be.
 can be decomposed as . Obviously 
is regular if, and only if, so is any of  (). Hence, it suffices to show
that  is regular for any relevant . The proof proceeds by induction on the structure of canonical forms.
The most difficult cases are those involving . Note that
whenever a canonical form of an -term is of the shape ,
's type must be of the form  (and  is a base type).
We handle this case below. Consider the terms:

Assuming that  and  satisfy the Proposition, we show that so does 
.
We shall refer to moves contributed by  with .
If we want to range solely over O- or P-moves from the component, we use  and  respectively.
Moreover, we use  to refer to copies of  in the  component.
The most common operation performed using this notation will be the relabelling of  to .
If  is a function type, then there is a unique P-question  enabled by the initial move .
Whenever we have a separate substitution rule for , the rule for  or  will not apply to .
In most cases we will want to substitute  ( decorated with index  represent a topmost binding) for .
In addition,  is used to increment all numerical indices by .
Then we have

where  and  ranges over .\qed}
\end{proof}
\begin{theorem}
Program equivalence of -terms is decidable.
\end{theorem}
We remark that adding dynamic memory allocation in the form of  to ,
or its second-order sublanguage, results in undecidability~\cite{Mur04b}. Hence,
at second order, block structure is ``strictly weaker" than scope extrusion.

\section{Summary}



In this paper we have introduced the notion of block-innocence that
has been linked with call-by-value Idealized Algol in a sequence of 
results. Thanks to the faithfulness
of block-innocence, we could investigate the interplay between
type theory, functional computation and stateful computation 
with block structure and dynamic allocation respectively. 
We have also shown a new decidability result for a carefully
designed fragment of . Its extension to product types
poses no particular difficulty. In fact, it suffices to follow the way we have tackled
the  type, which is itself a product type.
The result thus extends those from~\cite{Ghi01} and is a step forward
towards a full classification of decidable fragments of :
the language  we considered features all second-order types
and some third-order types, while finitary  is known to be undecidable
at order ~\cite{Mur03b}. Interestingly,  features restrictions that are 
compatible with the use of higher-order types in PASCAL~\cite{Mit02},
in which procedure parameters cannot be procedures with procedure parameters.
An interesting topic for future work would be to characterise the uniformity inherent in block-innocence in more
abstract, possibly category-theoretic, terms.

\section*{Acknowledgement}

We would like to thank the anonymous referees for their constructive comments and feedback.


\bibliographystyle{plain}
\bibliography{my}

\appendix
\section*{Appendix}
\section{S-plays}\label{apx:plays}
In this section we use the term ``move" and ``S-move" interchangeably.

\begin{lemma}[Prev-PA]\label{l:PrevPA}
If  is an S-play then, for any ,
  \begin{enumerate}[label= s_1\,\rnode{A}{q_0^{\Sigma_0}}\rnode{BA}{q_{1}^{\Tau_1}}\cdots\rnode{BB}{a_{1}^{\Sigma_1}}
\rnode{CA}{q_{2}^{\Tau_2}}\cdots\rnode{CB}{a_{2}^{\Sigma_2}}
\cdots\rnode{DA}{q_{j}^{\Tau_j}}\cdots\rnode{DB}{a_{j}^{\Sigma_j}}\rnode{B}{a^\Tau}\justf{BB}{BA}\justf{CB}{CA}\justf{DB}{DA}
\justf[,angleA=155,angleB=25]{B}{A}  \Sigma'=\Tau'[\Sigma']\remv(\Tau'\remv\Sigma')+(\Sigma'\remv\Tau')\substore (sn^{\Tau'}\mix t)[\Sigma']\remv(\Tau'\remv\Sigma')+(\Sigma'\remv\Tau')=\Sigma\,.
\Tau\remv\Sigma &= (sn^{\Tau'}\mix t)\remv((sn^{\Tau'}\mix t)[\Sigma']\remv(\Tau'\remv\Sigma')+(\Sigma'\remv\Tau')) \\
 &= (sn^{\Tau'}\mix t)\remv((sn^{\Tau'}\mix t)[\Sigma']\remv(\Tau'\remv\Sigma'))=(\Tau'\remv\Sigma')[sn^{\Tau'}\mix t]
 L
&=\Sigma_1[\nice(\Sigma_3,\Sigma_4,\Sigma_5)]\remv(\Sigma_2\remv\nice(\Sigma_3,\Sigma_4,\Sigma_5))+\nice(\Sigma_3,\Sigma_4,\Sigma_5)\remv\Sigma_2 \\
&=\Sigma_1[\nice(\Sigma_3,\Sigma_4,\Sigma_5)]\remv(\Sigma_2\remv(\Sigma_3[\Sigma_5]\remv\Sigma_{45}+\Sigma_{54}))+(\Sigma_3[\Sigma_5]\remv\Sigma_{45}
+\Sigma_{54})\remv\Sigma_2 \\
&=\Sigma_1[\nice(\Sigma_3,\Sigma_4,\Sigma_5)]\remv(\Sigma_2\remv(\Sigma_3\remv\Sigma_{45}))+(\Sigma_3[\Sigma_5]\remv\Sigma_{45})\remv\Sigma_2
+\Sigma_{54}

L_1 = \Sigma_1[\Sigma_3[\Sigma_5]\remv\Sigma_{45}+\Sigma_{54}]\remv(\Sigma_2\remv(\Sigma_3\remv\Sigma_{45}))
= \Sigma_1[\Sigma_3[\Sigma_5]\remv\Sigma_{45}]\remv(\Sigma_2\remv(\Sigma_3\remv\Sigma_{45}))
R
&=\nice(\Sigma_1,\Sigma_2,\Sigma_3)[\Sigma_5]\remv\Sigma_{45}+\Sigma_{54}
=(\Sigma_1[\Sigma_3]\remv\Sigma_{23}+\Sigma_{32})[\Sigma_5]\remv\Sigma_{45}+\Sigma_{54} \\
&=((\Sigma_1[\Sigma_3]\remv\Sigma_{23})\remv\Sigma_{45})[\Sigma_5]+(\Sigma_{32}\remv\Sigma_{45})[\Sigma_5]+\Sigma_{54} \\
&=((\Sigma_1[\Sigma_3]\remv\Sigma_{23})\remv\Sigma_{45})[\Sigma_5]+(\Sigma_{3}[\Sigma_5]\remv\Sigma_{45})\remv\Sigma_2+\Sigma_{54}

R_1 &= ((\Sigma_1[\Sigma_3\remv\Sigma_{45}]\remv\Sigma_{23})\remv\Sigma_{45})[\Sigma_5]
= ((\Sigma_1[\Sigma_3[\Sigma_5]\remv\Sigma_{45}]\remv\Sigma_{23})\remv\Sigma_{45})[\Sigma_5] \\
&= (\Sigma_1[\Sigma_3[\Sigma_5]\remv\Sigma_{45}]\remv\Sigma_{23})\remv\Sigma_{45}
 \Sigma\remv(\Sigma_2\remv(\Sigma_3\remv\Sigma_{45})) = (\Sigma\remv(\Sigma_{2}\remv\Sigma_{3}))\remv\Sigma_{45} 
x^\vart  \lrarr  \badvar{\lambda u^\expt. x\aasg u}{\lambda v^\comt.!x}

x^{\theta_1\rarr\theta_2} \lrarr \lambda z^{\theta_1}. \letin{v^{\theta_2}=xz^{\theta_1}}{v} 
\begin{array}{rcl}
! \badvar{\lambda u^\comt.D_1}{\lambda v^\expt.D_2} &\!\!\!\lrarr\!\!\!& D_1[()/u]\\
\badvar{\lambda u^\comt.D_1}{\lambda v^\expt.D_2}:= z &\!\!\!\lrarr\!\!\!& D_2[z/v]
\end{array}\begin{array}{rcl}
\letin{y=(\cond{x}{D_1}{D_0})}{E}&\!\!\!\lrarr\!\!\! & \cond{x}{(\letin{y=D_1}{E})}{(\letin{y=D_0}{E})}\\
\letin{y=(\letin{x=D}{E})}{F} &\!\!\!\lrarr\!\!\!
                                                     &\letin{x=D}{(\letin{y=E}{F})}
\rlap{\hbox to100 pt{\hfill\qEd}}
\end{array}\begin{array}{rcl}
D_1\oplus D_2 &\!\!\!\lrarr\!\!\!& \letin{x=D_1}{(\letin{y=D_2}{(x\oplus y)})}\\
\cond{D}{D_1}{D_0}&\!\!\!\lrarr\!\!\! &\letin{x=D}{(\cond{x}{D_1}{D_0})}
\end{array}\begin{array}{rcl}
! \badvar{\lambda u^\comt.D_1}{\lambda v^\expt.D_2} &\!\!\!\lrarr\!\!\!& D_1[()/u]\\
\badvar{\lambda u^\comt.D_1}{\lambda v^\expt.D_2}:= E &\!\!\!\lrarr\!\!\!& \letin{x^\expt=E}{D_2[x/v]}\\
!(\cond{x}{D_1}{D_0}) &\!\!\!\lrarr\!\!\! & \cond{x}{!D_1}{!D_0}\\
(\cond{x}{D_1}{D_0} )\aasg D &\!\!\!\lrarr\!\!\! & \cond{x}{(D_1\aasg D)}{(D_0\aasg D)}\\
!(\letin{x=D}{E}) &\!\!\!\lrarr\!\!\! & \letin{x=D}{!E}\\
 (\letin{x=D}{E})\aasg F &\!\!\!\lrarr\!\!\! & \letin{x=D}{(E\aasg F)} 
\end{array}\begin{array}{rcl}
\!\!\badvar{\cond{x}{D_1}{D_0}}{E} &\!\!\!\lrarr\!\!\! & \cond{x}{\badvar{D_1}{E}}{\badvar{D_0}{E}}\\
\!\!\badvar{\letin{x=M}{D}}{E} &\!\!\!\lrarr\!\!\! & \letin{x=M}{\badvar{D}{E}}\\
\!\!\badvar{\lambda u^\comt\!. D}{\cond{x}{E_1}{E_0}} &\!\!\!\lrarr\!\!\! & \cond{x}{\badvar{\lambda u^\comt\!.D}{E_1}}{\badvar{\lambda u^\comt\!.D}{E_0}}\\
\!\!\badvar{\lambda u^\comt\!. D}{\letin{x=M}{E}}&\!\!\!\lrarr\!\!\! & \letin{x=M}{\badvar{\lambda u^\comt\!. D}{E}}
\end{array}\begin{array}{rcl}
(\cond{x}{D_1}{D_0}) E &\!\!\!\lrarr\!\!\! &\cond{x}{(D_1 E)}{(D_2 E)}\\
(\letin{x=D}{E})F &\!\!\!\lrarr\!\!\! &\letin{x=D}{(E F)}
\end{array}
Now it suffices to be able to deal with terms of the form ,
and this is exactly what Lemma~\ref{lem:let} does.

All our transformation preserve denotations: the proofs are simple exercises in the use of Moggi's monadic
approach~\cite{Mog91} to modelling call-by-value languages (the store-free game model is an instance of the monadic framework).\qed



\end{document} 
