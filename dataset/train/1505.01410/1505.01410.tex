\documentclass[a4paper,11pt]{article}
\usepackage[margin=3cm]{geometry}
\usepackage{paralist}
\usepackage{hyperref}
\usepackage{amssymb, amsmath, amsthm}
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage[ruled,lined,algo2e]{algorithm2e}
\usepackage[font=small,labelfont=bf]{caption}
\usepackage[font=small,labelfont=normalfont]{subcaption}
\usepackage{times}
\usepackage{wrapfig}
\usepackage{xspace}
\usepackage{todonotes}


\newenvironment{proofMath}{\par\addvspace\topsep\noindent{\bf Proof:} \ignorespaces }{}

\title{On Monotone Drawings of Trees\thanks{A preliminary version of this work 
	appeared in: Proc.\ 22nd International Symposium on Graph Drawing
	(GD'14)~\cite{kssw-omdt-14}. This research was
    supported by the ESF EuroGIGA project GraDR (DFG grant
    Wo~758/5-1).}}

\author{Philipp~Kindermann\thanks{Lehrstuhl f\"ur Informatik I,
  Universit\"at W\"urzburg, Germany.
  \mbox{http://www1.informatik.uni-wuerzburg.de/en/staff}}
\and
Andr{\'e} Schulz\thanks{Institut f\"ur Mathematische Logik und
  Grundlagenforschung, Universit\"at M\"unster, Germany.
  \mbox{andre.schulz@uni-muenster.de}}
\and
  Joachim Spoerhase\footnotemark[2]
\and
Alexander~Wolff\footnotemark[2]
}

\date{}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem} 
\newtheorem{lemma}{Lemma}

\graphicspath{{figs/}}

 \def\proofWithWrapfig{\par
  \vskip\medskipamount\noindent
  \textit{\proofname}.~\ignorespaces}
 \def\endproofWithWrapfig{\ignorespaces\mbox{}\hspace*{2pt}\mbox{}\hfill\qed
   \par\vskip\medskipamount
 }

\begin{document}
\maketitle

\begin{abstract}
  A crossing-free straight-line drawing of a graph is \emph{monotone} if
  there is a monotone path between any pair of vertices with respect
  to \emph{some} direction.  We show how to construct a monotone drawing 
  of a tree with  vertices on an  grid
  whose angles are close to the best possible angular resolution.  Our
  drawings are \emph{convex}, that is, if every edge to a leaf is
  substituted by a ray, the (unbounded) faces form convex regions.
  It is known that convex drawings are monotone and, in the case of
  trees, also crossing-free.

  A monotone drawing is \emph{strongly monotone} if, for every pair of
  vertices, the direction that witnesses the monotonicity comes from the
  vector that connects the two vertices.  We show that every tree admits
  a strongly monotone drawing.  For biconnected outerplanar graphs,
  this is easy to see.  On the other hand, we present a
  simply-connected graph that does not have a strongly monotone
  drawing in any embedding.
\end{abstract}

\section{Introduction}

A natural requirement for the layout of a connected graph is that
between any source vertex and any target vertex, there should be a
source--target path that approaches the target according to some
distance measure.  A large body of literature deals with problems of
this type; various measures have been studied.  For example, in a
\emph{greedy drawing} you can find a path to a target vertex by iteratively
selecting a neighbor that is closer to the target.  
In a \emph{monotone} drawing, the distance between vertices (on the desired
source-target path) is measured with respect to their projections on
\emph{some} line, which may be different for any source--target pair.
We say that a path~ is \emph{monotone with respect to a vector~}
if the orthogonal projection of the vertices of~ on every line with direction 
vector~ appears on the line in the order as induced by~.
We also refer to~ as a \emph{direction}.
In \emph{strongly monotone} drawings, that line is always the line
from source to target, and in \emph{upward} drawings, the line is
always the vertical line, directed upwards.

In this paper, we focus on monotone and strongly monotone drawings of
trees with additional aesthetic properties such as convexity or small
area.  Given a tree, we call the 
edges incident to the leaves \emph{leaf edges} and all other edges
\emph{interior edges}.  Given a straight-line drawing of a tree, we
substitute each leaf edge by a ray whose initial part coincides with
the edge. The embedding of the tree in the plane defines a combinatorial embedding
of the tree, that is, the order of the edges around every vertex. The
faces are then specified by this combinatorial embedding as leaf--leaf paths. 
If the faces of the augmented drawing are realized as convex nonoverlapping
(unbounded) polygonal regions, then we call the original drawing a
\emph{convex drawing}.  If every region is \emph{strictly convex}
(that is, all interior angles are strictly less than~), we also
call the drawing \emph{strictly convex}.  Note that a strictly convex
drawing is also monotone~\cite{acbfp-mdg-12,acm-mpaoa-SoCG89}, but a
monotone drawing is not necessarily convex.  Strict convexity forbids vertices 
of degree~2. When we talk about (strongly) monotone drawings, 
this always includes the planarity requirement.  Otherwise, as Angelini et
al.~\cite{acbfp-mdg-12} observed, drawing any spanning tree of the given
graph in a (strongly) monotone way and inserting the remaining edges
would yield a (strongly) monotone drawing of the graph.


\paragraph{Previous Work.}
Rao et al.~\cite{rpss-grwli-MOBICOM03} introduced the concept of 
greedy drawings for a coordinate-based routing algorithm that does not rely
on location information. While any 3-connected plane graph has a greedy drawing
in the Euclidean plane~\cite{lm-gems-10} (even without crossing~\cite{d-gdt-10}),
this is, unfortunately, not true for trees.  
N\"ollenburg and Prutkin~\cite{np-egdt-ESA13} gave a complete
characterization for the tree case, which shows that no tree with a
vertex of degree~6 or more admits a greedy drawing.  

Alamdari et al.~\cite{acglp-sag-GD12} studied a subclass of greedy drawings,
so-called \emph{self-approaching drawings} which require that there
always is a source--target path such that the distance decreases for
any triplet of intermediate points on the \emph{edges}, not only for
the vertices on the path.  These drawings are based on the concept of
self-approaching curves~\cite{ikl-sac-MPCPS95}. 

Carlson and Eppstein~\cite{ce-tcfoa-GD06} studied convex drawings of
trees.  They give linear-time algorithms that optimize the angular
resolution of the drawings, both for the fixed- and the
variable-embedding case.  They observe that convexity allows them to
pick edge lengths arbitrarily, without introducing crossings.

For monotone drawings, Angelini et al.~\cite{acbfp-mdg-12} studied the
variable-embed\-ding case.  They showed that any -vertex tree admits
a straight-line monotone drawing on a grid of size  (using a BFS-based algorithm) or 
(using a DFS-based algorithm).  They also showed that any biconnected
planar graph has a monotone drawing (using exponential area).
Further, they observed that not every planar graph admits a monotone
drawing if its embedding is fixed.  They introduced the concept of
\emph{strong monotonicity} and showed that there is a drawing of a
planar triangulation that is not strongly monotone.  Hossain and
Rahman~\cite{hr-mgdpg-FAW14} improve some of the results of Angelini
et al.\ by showing that every connected planar graph
admits a monotone drawing of size  and that such a
drawing can be computed in linear time. 

Both the BFS- and the DFS-based algorithms of Angelini et al.\
precompute a set of  integral vectors in decreasing order 
of slope by using two different partial traversals of the
so-called \emph{Stern--Brocot tree}, an infinite tree whose vertices are in
bijection with the irreducible positive rational numbers.  Such
numbers can be seen as \emph{primitive} vectors in 2D, that is,
vectors with pairwise different slopes.  Then, both algorithms do a
pre-order traversal of the input tree.  Whenever they
hit a new edge, they assign to it the steepest unused vector.  They
place the root of the input tree at the origin and draw each
edge~ by adding its assigned vector to the position
of~.  They call such tree drawings \emph{slope-disjoint}.  We will not
formally define this notion here, but it is not hard to see that it
implies monotonicity.  

Angelini, with a different set of co-authors~\cite{adkmrsw-mdgfe-A15},
investigated the fixed-embedding case.  They showed that, on the
 grid, every connected plane graph admits a
monotone drawing with two bends per edge and any outerplane graph
admits a straight-line monotone drawing.

\paragraph{Our contribution.} 
We present two main results.  First, we show that any -vertex tree
admits a convex and, hence, monotone drawing on the  grid (see Section~\ref{sec:griddrawing}).  As the drawings of
Angelini et al.~\cite{acbfp-mdg-12}, our drawings are slope-disjoint, but
we use a different set of primitive vectors (based on Farey sequences),
which slightly decreases the grid size and helps us achieve better angular resolution.  (This also works
for the BFS-based algorithm of Angelini et al.)  Instead of pre-order,
we use a kind of in-order traversal (first child~-- root~-- other 
children) of the input tree, which helps us to achieve convexity.
Our ideas can be applied to modify the (non-grid) optimal angular resolution 
algorithm of Carlson and Eppstein~\cite{ce-tcfoa-GD06} such that
a drawing on an  grid is constructed at the expense of missing the optimal
angular resolution by a constant factor. 

Second, we show that any tree admits a \emph{strongly} monotone
drawing (see Section~\ref{sec:strong}).  So far, no positive results
have been known for strongly monotone drawings.
In the case of proper binary trees, 
our drawings are additionally strictly convex.  For biconnected outerplanar
graphs, it is easy to construct strongly monotone drawings.  On the
other hand, we present a simply-connected planar
graph that does not have a strongly monotone drawing in any embedding.

\paragraph{Subsequent Work.} Subsequent to our work, He and He~\cite{hh-cmdt-COCOON15} 
improved the area bound for monotone drawings of trees to 
.  Other than the drawings of
  our algorithm, their drawings are not necessarily convex.  Their
algorithm follows our approach  
of using Farey sequences to acquire a set of primitive vectors and then
computing a slope-disjoint
drawing. Recently, the same authors \cite{hh-nomdot-TCS16}
  further reduced the area bound to .
For triconnected planar graphs, He and He~\cite{hh-md3cp-ESA15} proved
that the convex drawings that an algorithm of
Felsner~\cite{f-cdpgo-O01} places on a grid of size 
are even monotone.  Note, however, that augmenting a graph that is not triconnected to triconnectivity, running Felsner's algorithm and then
removing the additional edges will, in general, neither yield a convex
nor a monotone drawing.  Hence, the result for triconnected graphs
does not imply any improvement for trees.
Very recently, Felsner et al.~\cite{fikkms-smdpg-socg16} showed that
all 3-connected planar graphs, outerplanar graphs, and 2-trees admit a strongly
monotone drawing. Their algorithm for outerplanar graphs utilizes an alternate
proof that every tree admits a strongly monotone drawing, but they also achieve
convexity.


\section{Building Blocks: Primitive Vectors}
\label{sec:primitive}

The following algorithms require a set of integral vectors with distinct 
directed slopes and bounded length. In particular, we ask for a set of 
\emph{primitive vectors} .
Our goal is to find the right value of  such that  contains
at least  primitive vectors, where  is a number that we determine later. 
We can then use the reflections on the lines ,  and  to
get a sufficiently large set of integer vectors with  distinct
directed slopes.  The edges of the monotone drawings in
Section~\ref{sec:griddrawing} are translates of these vectors; each edge 
uses a different vector. 

\begin{figure}[tb]
  \centering
  \includegraphics{primitives-polished}
  \caption{The 13 primitive vectors obtained from~. The
    smallest angle of~~ is realized between the
    vectors  and  marked with white dots; the best
    possible angular resolution in this case is . Note that our algorithm would use  to
    acquire~13 primitive vectors.}
  \label{fig:primitive}
\end{figure}

Assume that we have fixed  and want to generate the set~. If we
consider each entry  of~ to be a rational number  and
order these numbers by value, we get the \emph{Farey sequence}~ 
(see, for example, Hardy and Wright's book~\cite{gw-itn-79}). 
The Farey sequence is well understood. In particular, it is known that
~\cite[Theorem~331]{gw-itn-79}. 
Furthermore, the entries of~ can 
be computed in time .  We remark that the set~ coincides with the entries of the
Stern--Brocot tree.  However, collecting the latter level by level is
not the most effective method to build a set of primitive vectors for
our purpose. 

To obtain a set of~ primitive vectors, we use the first~
entries of the Farey sequence~, for~, 
replacing each rational by its corresponding two-dimensional vector.  
We select exactly~ primitive vectors from this set which we denote by~;
see Figure~\ref{fig:primitive}.

If we wish to have more control over the aspect ratio in our final drawing, we 
can pick a set of primitive vectors contained inside a triangle spanned
by the grid points~, . By stretching the triangle and 
keeping its area fixed, we may end up with fewer primitive vectors.
This will result in an (only slightly) smaller constant compared to
the case .  
As proven by B\'ar\'any and Rote~\cite[Theorem~2]{br-scdpg-06}, any such
triangular domain contains at least~ primitive
vectors. This implies that we can adapt
the algorithm easily to control the
aspect ratio by selecting the box for the primitive vectors 
accordingly. For the sake of simplicity, we detail our algorithms only
for the most interesting case ().

\begin{lemma}\label{lem:primitive_angles}
  Let  be a set of  primitive vectors with
  no coordinate greater than~ for some constant~.  Then, any
  two primitive vectors of  are separated by an angle of~.
\end{lemma}

\begin{proofMath}
Since~, we have that~.
Any line with slope~ encloses an angle~ with the -axis, 
such that~. Let~ and~ be the slopes of two lines 
and let~ and~ be the corresponding angles with respect to 
the -axis. By the trigonometric addition formulas we have that the 
separating angle~ of these two lines is such that:
 
For any two neighboring entries~ and~ in 
the Farey sequence, it holds that  \cite[Theorem~3.1.2]{gw-itn-79}, and 
therefore~ and~  differ by exactly~.  Now assume that~ is the angle 
between the vectors~ and~.  As a 
consequence, . Then,~ is minimized if~
is maximized. Clearly, we have that~. By 
the Taylor expansion,  for some 
value~. Substituting~ with~ yields, 
for~, that

\end{proofMath}

Since the best possible resolution for a set of~ primitive vectors 
is~, Lemma~\ref{lem:primitive_angles} shows that the
resolution of our set differs from the optimum by at most a constant.
To estimate this constant, let us assume we use~ primitive vectors
(that is,~ in Lemma~\ref{lem:primitive_angles}). Then, the smallest 
angle~ spanned by these vectors is, according to the proof of the previous 
lemma, at least~ for any . This value should
be compared to  since the primitive vectors span an angle 
of~ in total. We obtain that the ratio  is smaller than~6. 

\section{Monotone Grid Drawings with Large Angles}
\label{sec:griddrawing}

In this section, we present a simple method for drawing a
tree on a grid in a strictly convex, and therefore monotone way.
Lemma~\ref{lem:crossing-free} shows that this drawing is automatically
crossing-free. We name our strategy the \emph{inorder-algorithm}.
We start by ensuring that convex tree drawings are crossing-free.
This has already been stated (without proof) by Carlson and
Eppstein~\cite{ce-tcfoa-GD06}.
\begin{lemma} 
  \label{lem:crossing-free}
  Any convex straight-line drawing of a tree is crossing-free.
\end{lemma}

  \begin{figure}[t]
    \centering
    \includegraphics{convexnoncrossing}
    \caption{An illustration of the situation in the proof of
      Lemma~\ref{lem:crossing-free}} 
    \label{fig:crossingfree}
  \end{figure}

\begin{proof}
  Let  be a tree and  a convex straight-line drawing
  of~.  Assume that two edges~ and~ are
  crossing in  in some point~, see
  Figure~\ref{fig:crossingfree}.  Let~ be the lowest common ancestor
  of~ and~, let  be the path~ via~,
  and let~ the path~ via~. Let us assume
  that the children in~ are ordered such that  starts before
  .  Let~ be the region bounded by~ and~.

  We can assume that  is of minimum area with respect to other
  crossings we may have chosen (and, hence,  has a connected
  interior).  Now, we consider two paths starting from~. The first
  one, , starts with the first edge of  and then
  always continues via the last child until it reaches a leaf. The
  second path, , starts with the first edge of~ and
  continues always using the first child.  Note that the polygonal
  chain~ together with~ forms a face  of the
  given convex drawing of the tree.  Hence, the face is convex, which
  means that~ and~ only meet in~.  Furthermore, we
  either have~ or we have~ since
  otherwise  is self-intersecting.  As a consequence, at least
  one of the two paths, say , enters and leaves~.
  Let~ be the point where~ crosses~ for the first
  time, and let~ be the polygon that is bounded by the parts
  of~ and~ between~ and~.  Then~ has
  smaller area than~, which contradicts our assumption that 
  has minimum area.
\end{proof}

Our inorder-algorithm first computes a reasonable large set of primitive 
vectors, then selects a subset of these vectors, and finally assigns the slopes 
to the edges. The drawing is then generated by translating the selected 
primitive vectors. In the following, an \emph{extended}
subtree will refer to a subtree including the edge leading into the subtree
(if the subtree is not the whole tree).  

We will assign a unique number~ to every edge~.  This number will
refer to the rank of the edge's slope (in circular order) in the final
assignment.  The rank assignment is done in a recursive fashion with increasing integral ranks from~ to~. Starting with the root, for each vertex~,
 we first recursively visit its leftmost child, then assign the next rank
 to the parent edge of~ (unless~ is the root), and then recursively visit
 its other children from left to right. For an example of a tree with its edge 
 ranks, see Figure~\ref{fig:slopetree}.

\begin{figure}[tb]
  \begin{subfigure}[b]{.5\columnwidth}
    \centering
    \includegraphics{slopetree}
    \caption{a tree with edge numbers~ }
    \label{fig:slopetree}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{.47\columnwidth}
    \centering
    \includegraphics{slopetree-drawn}
    \caption{our grid drawing of the tree}
    \label{fig:slopetree-drawn}
  \end{subfigure}
  \caption{A strictly convex drawing of a tree}
\end{figure}

Second, we assign actual slopes to the edges.  Let~ be an edge
with~.  Then, we assign some vector~ to~ and 
draw~ as a translate of~.  We pick the
vectors~ by selecting a sufficiently large
set of primitive vectors and their reflections in counterclockwise
order; see Section~\ref{sec:primitive}.  
Our drawing algorithm has the following requirements:

\begin{enumerate}[label=(R\arabic*),ref=R\arabic*]
\item \label{enum:root}Edges that are incident to the root and consecutive in circular
  order are assigned to vectors that together span  an angle less than~.
\item \label{enum:subtrees}In every extended subtree hanging off the root, the edges 
  (including the edge incident to the root) 
  are assigned to a set of vectors that spans an angle less than~.
\end{enumerate}

These requirements can always be fulfilled, as the following lemma shows.

\begin{lemma}\label{lem:slope-preselection}
  We can select  vectors with distinct directed slopes 
  from a  grid with 
  such that the requirements~\ref{enum:root}
  and~\ref{enum:subtrees} are fulfilled.
\end{lemma}

\begin{proof}
	We first preprocess our tree by adding temporary edges at some
	leaves. These edges will receive slopes, but are immediately discarded
	after the assignment.

	First, our objective is to ensure that the tree can be split up into three 
	parts that all have~ edges. In particular, we adjust the sizes of the 
	extended subtrees hanging off the root by adding temporary edges such that we 
	can partition them into three sets of consecutive extended subtrees which all 
	contain~ edges.  Note that we have to add~ edges to achieve this.

	Second, we define three cones~, , and~; see 
	Figure~\ref{fig:slope-preselection}.  Each cone
	has its apex at the origin and spans an angle of~.  The angular
	ranges are~, , and ; 
	angles are measured from the -axis pointing
	in positive direction.  Note that~ is separated from the two
	other cones by an angle of~.  As mentioned in
	Section~\ref{sec:primitive}, the set~ contains~ primitive
	vectors in the~ grid. 
	When reflected on the  line, these vectors lie in~. 
	Reflecting the vectors in~, we further generate~ vectors
	in~ and~ vectors in~.  In every cone, we ``need'' at most~ 
	edges. Hence, we can remove the vectors on the boundary of each cone.
	After removing the temporary edges, the number of vectors will drop from~ 
	to~. 

	\begin{figure}[t]
		\centering
		\includegraphics{slope-preselection}
		\caption{The cones that contain the slopes used in the algorithm}  
		\label{fig:slope-preselection}
	\end{figure}

	Now, we observe the following.  Every two consecutive edges incident to
	the root lie in the \emph{interiors} of our cones.  Given the sizes and angular 
	distances of the cones, this yields requirement~\ref{enum:root}.  
	Furthermore, any extended subtree is assigned slopes
	from a single cone.  This yields requirement~\ref{enum:subtrees}.
\end{proof}

For the example tree of Figure~\ref{fig:slopetree}, it suffices to pick
the~16 vectors that one gets from reflecting the primitive vectors
from the  grid.  These vectors already fulfill
requirements~\ref{enum:root} and~\ref{enum:subtrees}.  Hence, we
do not have to apply the more involved slope selection as described
in Lemma~\ref{lem:slope-preselection}.  The resulting drawing is shown
in Figure~\ref{fig:slopetree-drawn}.

Every face in the drawing contains two leaves. The leaves are ordered by 
their appearance in some DFS-sequence~ respecting some rooted 
combinatorial embedding of~. For a face~, we call the leaf that comes 
first in~ the \emph{left leaf} and the other leaf of~  the 
\emph{right leaf} of~. The only exception is the face whose leaves are the 
first and last child of~. Here, we call the first vertex 
in~ the right leaf and the last vertex in~ the left 
leaf.

\begin{lemma}\label{lem:inc_slopes}
  Let~ be the left leaf, and let~ be the right leaf of a face of~. 
  Further, let~ be the lowest common ancestor of~ and~. The above assignment 
  of slope ranks~ to the tree edges implies the following.
  \begin{enumerate}[label=(a)]
		\item If edge~ is on the path 
			and edge~ is on the path ,
			then .
		\item The ordered sequence of edges on the path~ is increasing in~.
		\item The ordered sequence of edges on the path~ is decreasing in~.
  \end{enumerate}
\end{lemma}

\begin{proof}
  Let~ be an edge that links the parent~ to its child~, 
  let~ be the edge that links~ to its leftmost child, and let~ be
  the edge that links~ to its rightmost child;
  see~Figure~\ref{fig:slopelem2}. In the assignment, we first picked
  the slope in the subtree rooted at the leftmost children of~,
  then we selected the slope for~, and later we picked the slopes
  for the subtree rooted at the rightmost children of~. Since we
  select the slopes in their radial order, we have .

  Now, note that the slopes on the path~ have been assigned
  before the slopes on the path~, which proves~(a).  When
  traversing the path~, we follow the rightmost children,
  except maybe for~'s child; see~Figure~\ref{fig:slopelem1}. Hence,
  the sequence of slopes is increasing, and~(b) follows. Statement~(c)
  follows by a similar argument: We traverse the path~ by
  taking the leftmost child, except maybe for~'s child.  Hence, the
  sequence of slopes is decreasing.
\end{proof}

  \begin{figure}[tb]
    \hfill
    \begin{subfigure}[b]{.45\columnwidth}
      \centering
      \includegraphics{lemma-slopes-1}
      \caption{paths spanned by~ }
      \label{fig:slopelem1}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{.45\columnwidth}
      \centering
      \includegraphics{lemma-slopes-2}
      \caption{local assignments in the proof}
      \label{fig:slopelem2}
    \end{subfigure}
    \hfill
    \caption{Situation analyzed in Lemma~\ref{lem:inc_slopes}}
  \end{figure}

We now prove the correctness of our algorithm.

\begin{theorem}\label{thm:correctness}
  Given an embedded tree with  vertices (none of degree~2), the 
	in\-order-algorithm produces a strictly convex and crossing-free drawing with
  angular resolution  on a grid of size .  The algorithm runs in  time.
\end{theorem}
\begin{proof}
	We first show that no face in the drawing is incident to an angle larger 
	than~. Let~ be a face, let~ and~ be two consecutive edges on 
	the boundary of~, and let~ be the angle formed by~ and~ in 
	the interior of~.  If~ and~ are incident to the root, 
	requirement~\ref{enum:root} implies~. If both edges contain the
	lowest common ancestor of the leafs belonging to~, then, by 
	requirement~\ref{enum:subtrees}, also~. In the remaining 
	case,~ and~ both lie on a path to the left leaf of~, or both lie on 
	a path to the right leaf of~. Let  be the vertex shared by  and .  At vertex~, we have at least two outgoing 
	edges. Let~ be the first outgoing edge and~ be the last outgoing 
edge at~---one of the edges is~. By the selection of the slope ranks,
	we have . Consequently, the supporting line of~ 
	separates~ and~, and hence both faces containing~ have an angle 
	less than~ at~. Therefore, it holds that~.
   
	Next, we show that the edges and rays of a face do not intersect. Then, by 
	Lemma~\ref{lem:crossing-free}, no edges will cross. Assume that there are two 
	edges/rays~ and~ in a common face that intersect in some point~. 
	Let~ be the lowest common ancestor of~ and~, and assume 
	that~ lies on the path to the left leaf and~ on the path to the 
	right leaf. We define a closed polygonal chain~ as follows. The chain 
	starts with the path~, continues via~ to~, and 
	finally returns to~. We direct the edges according to this walk (for 
	measuring the directed slopes) and call them . We may 
	assume that~ is simple; otherwise, we find another intersection point.  By 
	Lemma~\ref{lem:inc_slopes}, the slopes are monotone when we traverse~.  
	For~, let~ be the difference between the directed 
	slopes of the edges~ and~. Then, the sum~ 
	equals the angle between the slopes of~ and~.  Due to 
	requirement~\ref{enum:subtrees}, this angle is less than~. 
	Let~ be the angle between~ and~ in~,
	and let~ be the ``interior'' angle at~. We have that 
	 
	This, however, contradicts the fact that the angle sum of the polygon with 
	boundary~ is~. Thus, our assumption that two edges/rays cross was
	invalid.
   
  Since the drawing is assembled from~ integral vectors whose absolute coordinates
  are at most~, the complete drawing uses a grid of dimension
  .
  Since all vectors are reflections of (a subset of) vectors defined by a Farey
  sequence with at most~ entries, Lemma~\ref{lem:primitive_angles}
  yields that the angular resolution is bounded by~. 
\end{proof}

We conclude this section with comparing our result with the drawing algorithm 
of Carlson and Eppstein~\cite{ce-tcfoa-GD06}. Their algorithm 
produces a drawing with optimal angular resolution. It draws trees 
convex, but, in contrast to our algorithm, not necessarily strictly
convex.  Allowing parallel leaf edges can have a great impact on the
angular resolution.  However, our ideas can be applied to modify the
algorithm of Carlson and Eppstein.  For the leaf edges, their algorithm uses  
a set of~ slopes and picks the slopes such that they are separated by an 
angle of~. The slopes of interior edges have either one of the slopes
of the leaf edges, or are chosen such that they bisect the 
wedge spanned by their outermost child edges. However, it suffices to
assure that the slope of an interior edge differs from the 
extreme slopes in the following subtree by at least~. 

We can now modify the algorithm as follows.
We pick~ primitive vectors and reflect them such that
they fill the whole angular space with~ distinct integral vectors. 
We use every other vector of this set for the leaf edges.
For an interior edge, we take any vector from our preselected set 
whose slope lies in between the extreme slopes of the edges in its subtree. 
Since we have sufficiently spaced out our set of primitive vectors, we can 
always find such a vector. Thus, we obtain a drawing on the
 grid. Clearly, the drawing does not have optimal 
angular resolution. However, since we use~ integral vectors, which have by 
Lemma~\ref{lem:primitive_angles} an angular resolution of~,
we differ from the best possible angular resolution~ only by 
a constant factor.  Note that the drawings produced by the algorithm of 
Carlson and Eppstein do not lie on the grid, that is, they do not compute 
rational coordinates for the vertices (by design, since otherwise perfect 
angular resolution cannot be achieved).

\begin{figure}[tb]
  \centering
  \begin{subfigure}[b]{.44\columnwidth}
    \centering
    \includegraphics[page=1]{angelini-tree}
    \caption{tree with two dummy vertices}
    \label{fig:example-tree-1}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{.44\columnwidth}
    \centering
     \includegraphics{angelini-tree-ce}
    \caption{drawing by Carlson and Eppstein~\cite{ce-tcfoa-GD06}}
    \label{fig:example-tree-3}
  \end{subfigure}

  \medskip
  \begin{subfigure}[b]{.44\columnwidth}
    \centering
    \includegraphics[page=3]{angelini-tree}
    \caption{drawing by Angelini et al.~\cite{acbfp-mdg-12}}
    \label{fig:example-tree-2}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{.44\columnwidth}
    \centering
    \includegraphics[page=2]{angelini-tree}
    \caption{drawing by our algorithm}
    \label{fig:example-tree-4}
  \end{subfigure}

  \caption{Example tree of Angelini et al.~\cite{acbfp-mdg-12}, drawn by
    various algorithms. We treat the degree-2 vertices as dummy
    vertices because of the degree restriction.}
  \label{fig:example}
\end{figure}

To conclude this section, we present an example that compares our
approach to that of Carlson and Eppstein~\cite{ce-tcfoa-GD06} and to
that of Angelini et al.~\cite{acbfp-mdg-12}; see
Figure~\ref{fig:example}.

\section{Strongly Monotone Drawings}
\label{sec:strong}

In this section, we show how to draw trees in a strongly monotone fashion.
We first show how to draw any proper binary tree, that is, any
internal vertex has exactly two children.  We name our strategy
the \emph{disk algorithm}.  Then, we generalize our
result to arbitrary trees. Further, we show that connected planar
graphs do not necessarily have a strongly monotone drawing.  Finally,
we show how to construct strongly monotone drawings for biconnected outerplanar graphs. 

Let~ be a proper binary tree, let~ be any disk with center~,
and let~ be the boundary of~.  Recall that a strictly convex
drawing cannot have a vertex of degree~2.  Thus, we consider the root
of~ a dummy vertex and ensure that the angle at the root
is~.  We draw~ inside~.  We start by  
mapping the root of~ to~.  Then, we draw a horizontal line~
through~ and place the children of the root on~ such that they lie on opposite sites relative to~.
We cut off two circular segments by dissecting~ with two vertical
lines running through points representing the children of the root.
We inductively draw the right subtree of~ into the right circular
segment and the left subtree into the left circular segment.

In any step of the inductive process, we are given a vertex~
of~, its position in~ (which we also denote by~) and a 
circular segment~; see Figure~\ref{fig:construction-ind}.  
The preconditions for our construction are that
\begin{enumerate}[label=(\roman*)]
  \item  lies in the relative interior of the chord~ that 
    delimits~, and
  \item  is empty, that is, the interiors of~ and~ are disjoint 
    for any vertex~ that does not lie on a root--leaf path through~.
\end{enumerate}
In order to place the two children~ and~ of~ (if any), we
shoot a ray~ from~ perpendicular to~ into~.
Let~ be the point where~ hits~.  Consider the chords
that connect the endpoints of~ to~.  The chords and~ form
a triangle with height~.  The ``height'' is contained in the interior of the 
triangle and splits it into two right subtriangles.  The chords are the
hypotenuses of the subtriangles.  We construct~ and~ by connecting~ to
these chords perpendicularly.  Note that, since the subtriangles are right 
triangles, the heights lie inside the subtriangles.  Hence,~ and~ lie in 
the relative interiors of the chords.  Further, note that the circular 
segments~ and~ delimited by the two chords are disjoint and
both are contained in~.  Hence,~ and~ are empty, and the
preconditions for applying the above inductive process to~ and~
with~ and~ are fulfilled.  See Figure~\ref{fig:construction-final} for 
the output of our algorithm for a tree of height~3.

Note that our algorithm does not place the vertices on a grid. However, 
no edge on a strongly monotone path is perpendicular to its monotone direction.
Hence, the vertices can be moved slightly to rational coordinates.
Further, the drawings computed by our algorithms require more than polynomial 
area; in fact, they even require super-exponential area, as the ratio 
between~ and~ in the inductive step depicted in 
Figure~\ref{fig:construction-ind} cannot be bounded by a constant.
N\"ollenburg et al.~\cite{npr-saicd-GD14} have recently shown that 
exponential area is required for strongly monotone drawings
of trees, which justifies that we cannot produce a drawing on a grid of
polynomial size.


\begin{figure}[tb]
  \begin{subfigure}[b]{.38\columnwidth}
    \centering
    \includegraphics{tree_construction}
    \caption{sketch of the inductive step}
    \label{fig:construction-ind}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{.58\columnwidth}
    \centering
    \includegraphics{strict-monotone-bintree}
    \caption{output of our algorithm for a tree of height~3}
    \label{fig:construction-final}
  \end{subfigure}
  \caption{Strongly monotone drawings of proper binary trees}
  \label{fig:construction}
\end{figure}

\begin{lemma}\label{lem:strict-conv-bintree-proof}
  For a proper binary tree rooted in a dummy vertex,
  the disk algorithm yields a strictly convex drawing.
\end{lemma}

\begin{proof}
  Let~ be a proper binary tree and let~ be a face of the
  drawing generated by the algorithm described above.  Clearly,~ is
  unbounded.  Let~ and~ be the leaves of~ that are incident
  to the two unbounded edges of~, and let~ be the lowest common
  ancestor of~ and~; see Figure~\ref{fig:construction-final}.
  Consider the two paths~ and~.  
  We assume that the path from~ through its left child
  ends in~ and the path through its right child ends in~.

  Due to our inductive construction that uses disjoint disk sections
  for different subtrees, it is clear that the two paths do not
  intersect.  Moreover, each vertex on the two paths is convex, that
  is, the angle that such a vertex forms inside~ is less
  than~.  This is due to the fact that we always turn right when
  we go from~ to~, and we always turn left when we go to~.
  Vertex~ is also convex since the two edges from~ to its
  children lie in the same half-plane (bounded by~).
  
  It remains to show that the two rays~ and~
  (defined analogously to~ above) do not intersect.  To this
  end, recall that~.  By our construction,~
  and~ are orthogonal to two chords of~ that are
  both incident to~.  Clearly, the two chords form an angle of
  less than~ in~.  Hence, the two rays diverge, and the
  face~ is strictly convex.
\end{proof}
  
For the proof that the algorithm described above yields a strongly monotone 
drawing, we need the following tools. Let~ and~ be two 
vectors. We say that~ \emph{lies between}~ and~ 
if~ is a positive linear combination of~ and~.
For two vectors~ and~, we 
define~ as the 
scalar product of~ and~.

\begin{lemma}\label{lem:between}
  If a path~ is monotone with respect to two vectors~ 
  and~, then it is monotone with respect to any vector~
  between~ and~.
\end{lemma}

\begin{proof}
  Let~ 
  with~. Assume that the path~ is given by the 
  sequence of vectors .
  Since~ is monotone with respect to vectors~ and~, we 
  have that  and 
   for all~. This yields, for 
  all~,
  
  since~. It follows that~ is monotone with respect 
  to~.
\end{proof}

\begin{lemma}\label{lem:strict-mon-bintree-proof}
  For a proper binary tree rooted in a dummy vertex,
  the disk algorithm yields a strongly monotone drawing.
\end{lemma}
  
\begin{proof}
  We split the drawing into four sectors: I, II, III and IV; see
  Figure~\ref{fig:construction-final}. Let~ and~ be two vertices in the 
  graph. We will show that the path~ in the
  output drawing of our algorithm is strongly monotone. 
  Let~ be the root of the tree. Without loss of generality, assume that~ 
  lies in sector III. Then, we distinguish three cases. 
  
  \textbf{Case 1}:  and~ lie on a common root--leaf path; see~ and~ 
    in Figure~\ref{fig:construction-final}. Obviously,~ lies in sector III.
    Without loss of generality, assume that~ lies on the path~.
    By construction, all edges in sector III, seen as vectors
    directed towards~, lie between~ 
    and~. Thus, all edges on the path~, and in
    particular~, lie between~ and~.
    Since~ is perpendicular to~, the path~ is
    monotone with respect to~ and~. Following
    Lemma~\ref{lem:between}, the path  is monotone with
    respect to~, and thus strongly monotone.
  
  \textbf{Case 2}:  lies in sector I; see~ and~ in
    Figure~\ref{fig:construction-final}. In Case 1, we have shown that
    the all edges on the path~ lie
    between~ and~. Analogously, the same holds
    for the path~. Thus, the path~ is monotone
    with respect to~ and~ and, following
    Lemma~\ref{lem:between}, strongly monotone.
  
    \textbf{Case 3}:  and~ do not lie on a common root--leaf
    path, and~ does not lie in sector~I; see~ and~ in
    Figure~\ref{fig:construction-final}.  Let~ be the lowest
    common ancestor of~ and~. Let~
    be the path~ to~.
    Further, let~ be the path~. 
    Finally, let 
    be the path~.
    
    \begin{figure}[t]
      \centering
      \includegraphics{strict-mon-bintree-case3}
      \caption{Illustration of case~3 in the proof of
        Lemma~\ref{lem:strict-mon-bintree-proof}}
      \label{fig:strict-mon-bintree-case3}
    \end{figure}
    
    Below, we describe how to rotate and mirror the drawing such that
    any vector~ with  lies
    between~ and~, and any
    vector~ with  lies
    between~ and~. This statement is equivalent
    to~
    and~;
    see Figure~\ref{fig:strict-mon-bintree-case3}.
    If~ lies in sector~IV, then~ and this statement is true by
    construction. If~ lies in sector~II, then~ is a child
    of~. We rotate the drawing by~ in counterclockwise
    direction and then mirror it horizontally.
    If~ lies in sector~III, let~ be the parent of~. 
    We rotate the drawing such that the edge~ is drawn vertically. 
    Recall that, by construction, the ray from~ in 
    direction~ separates the subtrees of the two  
    children of~; see Figure~\ref{fig:construction-ind}. Further, the angle 
    between any edge (directed away from~) in the subtree of~ 
    and~ is at most~, that is, they are 
    directed downwards.
   
    For , let~ be the straight line through~ perpendicular 
    to~. Let~ be the line parallel to~ 
    that passes through~. Due to the -monotonicity of~, the point~ 
    lies below~. During the construction of the tree, the line~
    defined a circular sector in which the subtree rooted at~ including~ 
    was exclusively drawn. It follows that~ and~ lie on opposite sites 
    of~. Thus,~ lies above~ and also above~. 
    Let~ be the straight line through~ perpendicular 
    to~. Let~ be the parallel line to~ 
    that passes through~. By construction,~ lies below~ and~ lies
    above~. Thus,~ lies below~.
    
    Let~ be the line~ with maximum slope and let~ be the line~
    with minimum slope. First, we will show that the path is monotone with 
    respect to the unit vector~ on~ directed to the right. By our choice 
    of~, the angle between  and any vector~
    with 
    is at most~. Recall that any vector~
    with  lies between~ and~. Since~ is 
    perpendicular to one of these edges and directed to the right, it lies 
    between~ and~. Since any 
    vector~ with  also lies 
    between~ and~, the angle between~ and
    any such vector~
    is also at most~. Thus, the angle between~ and any edge on the
    path~ is at most~, which shows that the path is monotone with respect 
    to~.
    
    Analogously, it can be shown that the path is monotone with respect 
    to~. Recall that~ lies above~ and below~ and 
    that~ lies above~ and below~.  Hence, the 
    vector~ lies between~ and~. Following 
    Lemma~\ref{lem:between}, the path is monotone with respect 
    to~ and, thus, strongly monotone.
\end{proof}

Lemmas~\ref{lem:strict-conv-bintree-proof} 
and~\ref{lem:strict-mon-bintree-proof} immediately imply the following.

\begin{theorem}\label{thm:strict-mon-bintree-proof}
  Any proper binary tree rooted in a dummy vertex
  has a strongly monotone and strictly convex drawing.
\end{theorem}

Next, we (partially) extend this result to arbitrary trees.

\begin{theorem}\label{thm:strict-mon-tree-proof}
  Any tree has a strongly monotone drawing.
\end{theorem}

\begin{proof}
  Let~ be a tree. If~ has a vertex of degree~2, we root~ in this 
  vertex. Otherwise, we subdivide any edge by creating a vertex of degree~2, 
  which we pick as root. Then, we add a leaf to every vertex of degree~2, 
  except the root. Now, let~ be a vertex with out-degree~. 
  Let~ be the outgoing edges of~ ordered from right to 
  left. We substitute~ by a path~, 
  where~ is the left child of~, for . Then, we 
  substitute the edges~ by~; see 
  Figure~\ref{fig:subdivision}.
  
  \begin{figure}[tb]
    \hfill
    \begin{subfigure}[b]{.45\textwidth}
      \centering
      \includegraphics[page=1]{subdivision}
      \caption{a tree~}
      \label{fig:subdivision-1}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{.45\textwidth}
      \centering
      \includegraphics[page=2]{subdivision}
      \caption{the subdivided tree~}
      \label{fig:subdivision-2}
    \end{subfigure}
    \hfill
    \caption{Subdivision of a vertex~ with~ outgoing edges}
    \label{fig:subdivision}
  \end{figure}
   
  Let~ be the resulting binary tree.  Clearly, all vertices of~, 
  except its root, have degree~1 or~3, so~ is a proper binary tree.
  We use Theorem~\ref{thm:strict-mon-bintree-proof} to get a strongly monotone
  drawing~ of~. Then, we remove the dummy vertices inserted
  above and draw as straight-line segments the edges of the original
  tree~ that have been substituted or subdivided.
  This yields a drawing~ of~ that is crossing-free
  since the only new edges form a set of stars that are drawn in disjoint
  areas of the drawing.
  
  Now, we show that~ is strongly monotone. Let~ be an edge
  in~. Let~ be the path~ in~.
  Suppose~ is monotone with respect to some direction~. 
  Thus,~ 
  for~. 
  Clearly,~
  is a positive linear combination
  of~
  and, hence,~.
  It follows that the path~ for some vertices~ in~ is monotone
  with respect to a direction~ in~ if the path~ is
  monotone to~ in~. With~, 
  it follows that~ is strongly monotone.
\end{proof}

We add to this another positive result concerning biconnected
outerplanar graphs.

\begin{theorem}
  Any biconnected outerplanar graph has a strongly monotone and
  strictly convex drawing on the  grid.
\end{theorem}

\begin{proof}
  Let~ be a biconnected outerplanar graph with outer cycle
  .
  We place the vertices~
  in order on an - and -monotone convex chain~ that
  has~ and~ as its endpoints. The chain is assembled by
  translations of  primitive vectors, which are sorted by slope
  (see Figure~\ref{fig:biconnected-outerplanar} for a sketch).
  Since the outer cycle is drawn strictly convex, the drawing is planar
  and strictly convex.
Also, every vector~ lies between~
  and~. Thus, by Lemma~\ref{lem:between}, the drawing is
  strongly monotone. 
  
  For our construction we can use a set of
primitive vectors whose coordinates are bounded by .
  Since we have linked  such vectors, the
  asserted bound follows.
\end{proof}

We close with a negative result.  Angelini et
al.~\cite[p.~33]{acbfp-mdg-12} stated that they are ``not aware of any
planar graph not admitting a planar monotone drawing for any of its
embeddings''.  We give the first family of graphs that
  do not admit any \emph{strongly} monotone drawing.  Note that the
graphs in the family that we construct are neither outerplanar nor
biconnected.

\begin{theorem}
  There is an infinite family of connected planar graphs
  that do not have a strongly monotone drawing in any combinatorial embedding.
\end{theorem}

\begin{proof}
  Let~ be the graph that arises by attaching to each vertex
  of~ a ``leaf''; see Figure~\ref{fig:nostrict-connected}.
    \begin{figure}[tb]
    \begin{minipage}[t]{.5\columnwidth}
      \centering
      \includegraphics{biconnected-outerplanar}
      \caption{A strongly monotone drawing of a biconnected outerplanar graph}
      \label{fig:biconnected-outerplanar}
    \end{minipage}
    \hfill
    \begin{minipage}[t]{.43\columnwidth}
      \centering
      \includegraphics{nostrict-connected}
      \caption{A planar graph without any strongly monotone drawing}
      \label{fig:nostrict-connected}
    \end{minipage}
  \end{figure}
  Let~ be the vertices of~. For~ to be
  crossing-free, one of its vertices, say~, lies in the interior.
  Let~ be the leaf incident to~. 
  Because of planarity,~ has to be placed inside
  a triangular face incident to~. Without loss of generality, assume
  that~ is placed in the face~. If the drawing is
  strongly monotone, 
  then~
  and~,
  and thus~.
  However, this means that~ does not lie inside the triangle~,
  which is a contradiction to the assumption. Thus,~ does not have
  a strongly monotone drawing in any combinatorial embedding.
  We create an infinite family from~ by adding more leaves to the
  vertices of~. 
\end{proof}


\section{Conclusion}
\label{sec:open}

We have shown that any tree has a convex monotone drawing on a grid with area
 and a strongly monotone drawing, but several problems remain open.
It is an open question whether any tree has a strongly monotone drawing on a grid 
of exponential size. We have shown that not every connected planar graph admits a strongly
monotone drawing, while Felsner et al.~\cite{fikkms-smdpg-socg16} showed that every
triconnected planar graph does so.
It is still open whether there is a biconnected planar 
graph that does not have any strongly monotone drawing. If yes, it is
interesting whether this can be tested efficiently. 

\bibliographystyle{abbrvurl}
\bibliography{abbrv,monotone}

\end{document}
