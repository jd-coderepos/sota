\documentclass{article}



\usepackage{mathptmx}
\usepackage[scaled=.9]{helvet}
\usepackage{type1cm} \usepackage{courier}

\usepackage[all]{xy}
\usepackage{graphicx}
\usepackage[font=small]{caption}
\usepackage{subcaption}
\captionsetup{compatibility=false}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{url}
\usepackage{float}
\usepackage{wrapfig}

\allowdisplaybreaks

\usepackage{xcolor}
\usepackage{proof}
\usepackage{listings}
\usepackage{fancyvrb}
\usepackage{relsize}


\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\theoremstyle{definition}
\newtheorem{notation}[theorem]{Notation}
\newtheorem{convention}[theorem]{Convention}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{example}[theorem]{Example}


\newcommand{\PCF}{\mbox{}}

\newcommand{\bit}{{\tt bit}}
\newcommand{\bool}{{\tt bool}}
\newcommand{\Ttrue}{\mathtt{TT}}
\newcommand{\Ffalse}{\mathtt{FF}}

\newcommand{\cnotgate}[2]{{\tt N}({#1}\cdot{#2})}
\newcommand{\notgate}[1]{{\tt N}({#1})}
\newcommand{\wires}[1]{{\it Wires}({#1})}

\newcommand{\define}[1]{{\em #1}}

\newcommand{\bor}{\,{|}\,}

\newcommand{\listtype}[1]{{[}{#1}{]}}
\newcommand{\unittype}{{\tt 1}}
\newcommand{\tunit}{\unittype}


\newcommand{\lettermx}[3]{{{\it let}~{#1}~=~{#2}~{\it in}~{#3}}}
\newcommand{\punit}{\mathtt{skip}}\newcommand{\prodterm}[1]{{\langle{#1}\rangle}}
\newcommand{\letprodterm}[3]{{{\it let}~\prodterm{#1}~=~{#2}~{\it in}~{#3}}}
\newcommand{\letunitterm}[2]{{#1}\mathtt{;}{#2}}

\newcommand{\ttrue}{\mathtt{t\!t}}
\newcommand{\ffalse}{\mathtt{f\!f}}
\newcommand{\ifterm}{{\it bitCase}}
\newcommand{\matchterm}{{\it listCase}}
\newcommand{\iftermx}[3]{{{\mathtt{if}}~{#1}~\mathtt{then}~{#2}~\mathtt{else}~{#3}}}
\newcommand{\iftermX}[3]{{{\mathtt{IF}}~{#1}~\mathtt{THEN}~{#2}~\mathtt{ELSE}~{#3}}}
\newcommand{\matchcase}[5]{{{\it match}~{#1}~{\it with}~\nil\,\mapsto\,{#2}\bor\cons{#3}
{#4}\mapsto{#5}}}

\newcommand{\inj}{{\tt inj}}
\newcommand{\injl}{\inj_1}
\newcommand{\injr}{\inj_2}
\newcommand{\match}[5]{{{\mathtt{match}}~{#1}~{\mathtt{with}}~({#2\,\mapsto\,#3}\vert{#4\,\mapsto\,#5})}}
\newcommand{\letrec}[4]{{{\mathtt{letrec}}~{#1}\,{#2}={#3}~{\mathtt{in}}~{#4}}}
\newcommand{\letrecn}[5]{{{\mathtt{letrec}}^{#1}~{#2}\,{#3}={#4}~{\mathtt{in}}~{#5}}}

\newcommand{\errorlist}{{\tt Err}}

\newcommand{\nil}{{\mathtt{nil}}}
\newcommand{\cons}[3][]{{{#2}\,{\mathtt :}{\mathtt :}^{#1}\,{#3}}}
\newcommand{\unfold}[2][]{{\mathtt{unfold}^{#1}}~{#2}}
\newcommand{\iterator}[1][]{{\mathtt{iter}^{#1}}}
\newcommand{\splitlist}[1][]{{\mathtt{split}^{#1}}}

\newcommand{\emptyam}{\textrm{{\it EmptyAM}}}
\newcommand{\rwam}{\mathrel{\to_{\it am}}}
\newcommand{\cbvam}{\mathrel{\to_{\it cbv}}}
\newcommand{\monadreturn}{{\tt return}}
\newcommand{\monadapp}{{\tt app}}

\newcommand{\Lift}[1]{{\it Lift}_{\mathcal{#1}}}

\newcommand{\wiretype}{{\tt wire}}
\newcommand{\monadttrue}{{\tt mtt}}
\newcommand{\monadffalse}{{\tt mff}}
\newcommand{\monadif}{{\tt mif}}
\newcommand{\monadand}{{\tt mand}}
\newcommand{\monadxor}{{\tt mxor}}
\newcommand{\monadnot}{{\tt mnot}}

\newcommand{\nattype}{{\tt nat}}
\newcommand{\gatetype}{{\tt gate}}
\newcommand{\circuittype}{{\tt circuit}}
\newcommand{\statetype}{{\tt state}}
\newcommand{\circtype}{{\tt circ}}

\newcommand{\succterm}{{\bf S}}

\newcommand{\void}[1]{}

\setlength{\textfloatsep}{2ex} 
\setlength{\floatsep}{0ex} 

\newcommand\blfootnote[1]{\begingroup
  \renewcommand\thefootnote{}\footnote{#1}\addtocounter{footnote}{-1}\endgroup
}


\title{Generating reversible circuits from higher-order functional
  programs}

\author{Beno\^{i}t Valiron}

\date{March 20, 2016}

\begin{document}

\maketitle

\begin{abstract}
Boolean reversible circuits are boolean circuits made of reversible
elementary gates. Despite their constrained form, they can simulate
any boolean function. The synthesis and validation of a reversible
circuit simulating a given function is a difficult problem. In 1973,
Bennett proposed to generate reversible circuits from traces of
execution of Turing machines.
In this paper, we propose a novel presentation of this approach,
adapted to higher-order programs. Starting with a PCF-like language,
we use a monadic representation of the trace of execution to turn a
regular boolean program into a circuit-generating code. We show that a
circuit traced out of a program computes the same boolean function as
the original program.
This technique has been successfully applied to generate large oracles
with the quantum programming language Quipper.
\end{abstract}


\section{Introduction}
\label{sec:introduction}

Reversible circuits are linear, boolean circuits with no loops, whose
elementary gates are reversible. 
In quantum computation, reversible circuits are mostly used as oracle:
the {\em description} of the problem to solve. Usually, this
description is given as a classical, conventional algorithm: the graph
to explore~\cite{TF}, the matrix coefficients to process~\cite{QLSA},
{\em etc}. These algorithms use arbitrarily complex structures, and if some
are rather simple, for example~\cite{shor}, others are quite complicated and make use of
analytic functions~\cite{QLSA}, memory registers~\cite{BF} (which
thus have to be simulated), {\em etc}.

This paper\footnote{A shorter preprint has been  accepted for publication in the Proceedings of {\em Reversible Computation 2016}.
The final publication is available at
  \url{http://link.springer.com}.} is concerned with the design of reversible circuits as {\em
  operational semantics} of a higher-order purely functional
programming language. The language is
 expressive enough to encode most algorithms: it features
recursion, pairs, booleans and lists, and it can easily be extended
with additional structures if needed. This operational semantics can be
understood as the {\em compilation} of a program into a reversible
circuit.

Compiling a program into a reversible circuit is fundamentally
different from compiling on a regular back-end: there is no notion of
``loop'', no real control flow, and all branches will be explored
during the execution.  In essence, a reversible circuit is the {\em
  trace} of all possible executions of a given program. Constructing a
reversible circuit out of the trace of execution of a program is what
Bennett~\cite{bennett73logical} proposed in 1973, using Turing
machines. In this paper, we refer to it as Landauer
embeddings~\cite{landauer61irreversibility}.

In this paper, we build up on this idea of circuit-as-trace-of-program
and formalize it into an operational semantics for our higher-order
language. This semantics is given externally as an abstract machine,
and internally, as a {\em monadic interpretation}.

The strength of our approach to circuit synthesis is to be able to
reason on a regular program independently from the constraints of the
circuit construction. The approach we follow is similar to what is
done in Geometry of synthesis~\cite{ghica07gos} for hardware synthesis, but
since the back-end we aim at is way simpler, we can devise a very
natural and compact monadic operational semantics.

\smallskip
\noindent
{\bf Contribution.}
The main contribution of this paper is a monadic presentation of
Landauer embeddings~\cite{landauer61irreversibility} in the context of
higher-order programs. Its main strength is its parametricity: a
program really represents a {\em family} of circuits, parametrized on
the size of the input. Furthermore, we demonstrate a compositional
monadic procedure for generating a reversible circuit out of a
regular, purely functional program. The generated circuit is then
provably computing the same thing as the original program. This can be
used to internalize the generation of a reversible circuit out of a
functional program. It has been implemented in Quipper~\cite{Quipper}
and used for building complex quantum oracles.


\smallskip
\noindent
{\bf Related works.}
From the description of a conventional function it is always possible
to design a reversible circuit computing the function out of its
truth table or properties thereof and several methods have been
designed to generate compact
circuits (see e.g.~\cite{rev-survey-2011,maslov-templates-iccad03,synth4,synth13,synth2,synth17}).
However, if these techniques allow one to write
reversible functions with arbitrary truth tables~\cite{revlib}, they
do not usually scale well as the size of the input grows.

Synthesis of reversible circuits can be seen as a small branch of the
vast area of hardware synthesis. In general, hardware synthesis can be
structural (description of the structure of the circuit) or behavioral
(description of algorithm to encode). Functional programming languages
have been used for both. On the more structural side one finds
Lava~\cite{Claessen-2001}, BlueSpec~\cite{bluespec}, functional
netlists~\cite{park08functional}, {\em etc}.  On the behavioral side
we have the Geometry of Synthesis~\cite{ghica07gos},
Esterel~\cite{esterel}, ForSyDe~\cite{forsyde}, {\em etc}. Two more
recent contributions sitting in between structural and behavioral
approaches are worth mentioning. First, the imperative, {\em
  reversible} synthesis language SyRec~\cite{syrec}, specialized for
reversible circuits. Then, Thomsen's proposal~\cite{thomsen}, allowing
to represent a circuit in a functional manner, highlighting
the behavior of the circuit out of its structure.

On the logic side, the geometry of interaction~\cite{goi} is a
methodology that can be used to turn functional programs into
reversible computation~\cite{abramsky,ghica07gos,terui}: it is based on
the idea of turning a typing derivation into a reversible automaton.

There have also been attempts to design reversible abstract machines
and to compile regular programs into reversible computation. For
example, a reversible version of the SEMCD machine has been
designed~\cite{kluge99}. More recently, the compiler REVS~\cite{revs}
aims at compiling conventional computation into reversible circuits.

Monadic semantics for representing circuits is something relatively
common, specially among the DSL community: Lava~\cite{Claessen-2001},
Quipper~\cite{PLDI}, Fe-Si~\cite{braibant13formal}, {\em etc}. Other
approaches use more sophisticated constructions, with type systems
based on arrows~\cite{James} in order to capture reversibility. 

In the present work, the language is circuit-agnostic, and the
interest of the method lies more in the fact that the monadic
semantics to build reversible circuits is completely {\em implicit}
and only added at circuit-generation time, following the approach
in~\cite{MLmonad}, rather than in the choice of the language. Compared
to~\cite{James}, our approach is also parametric in the sense that a
program does not describe one fixed-size circuit but a family of
circuits, parametrized by the size of the input.




\smallskip
\noindent
{\bf Plan of the paper.}
Section~\ref{sec:reversible-circuits} presents the definition of
reversible circuits and how to perform computation with them.
Section~\ref{sec:progr-revers-circ} describes a PCF-like
lambda-calculus and proposes two operational semantics: one as a
simple beta-reduction and one using an abstract machine and a partial
evaluation procedure generating a
circuit. Section~\ref{sec:internalizing} describes the call-by-value
reduction strategy and explains how to internalize the
abstract-machine within the language using a
monad. Section~\ref{sec:use-cases} discusses the use of this technique
in the context of the generation of quantum oracles, and discusses the
question of optimizing the resulting circuits.  Finally,
Section~\ref{sec:conclusion} concludes and proposes some future
investigations.



\section{Reversible circuits}
\label{sec:reversible-circuits}

\begin{wrapfigure}{r}{0.3\textwidth}
\vspace{-10pt}
\includegraphics[width=0.28\textwidth]{rev-circ-ex-eps-converted-to.pdf}
\vspace{-10pt}
\end{wrapfigure}
A reversible boolean circuit consists in a set of \define{open wires}
and \define{elementary gates} attached onto the wires. Schematically,
a reversible boolean circuit is of the form shown on the right.
To each gate is associated a boolean operation, supposed to be
reversible. In this circuit example,  is a one-bit operation (for
example a not-gate, flipping a bit) while  is a two-bit
operation. In each wire, a bit ``flows'' from left to right. All the
bits go at the same pace. When a gate is met, the corresponding
operation is applied on the wires attached to the gate. Since the
gates are reversible, the overall circuit is reversible by making the
bits flow backward. 

\paragraph{\bf Choice of elementary gates.}

Many gates have been considered in the
literature~\cite{rev-survey-2011}. In this paper, we will consider
multi-controlled-not gates. A not gate, represented by

is flipping the value of the wire on which it is attached. The
operator  stands for the bit-flip operation. Given a
gate  acting on  wires, a controlled-F is a gate acting on 
wires. The control can be positive or negative, represented
\begin{wrapfigure}{r}{0.35\textwidth}
\vspace{-10pt}
\begin{minipage}{0.33\textwidth}
  
\end{minipage}
\vspace{-10pt}
\end{wrapfigure}
respectively as shown on the right.
In both cases, the top wire is not modified. On the bottom wires, the
gate  is applied if  is true for the positive control, and
false for the negative control. Otherwise, no gate is applied: the
values  flow unchanged through the gate.
A positively-controlled not gate will be denoted CNOT.


A reversible circuit runs a computation on some query: some input
wires correspond to the query, and some output wires correspond to the
answer. The auxiliary input wires that are not part of the query are
initially fed with the boolean ``false'' (also written ).


\paragraph{\bf Computing with reversible circuits.}
As described by Landauer\,\cite{landauer61irreversibility} and
Bennett\,\cite{bennett73logical}, a conventional, classical algorithm
that computes a boolean function  can be mechanically
transformed into a reversible circuit sending the triplet
 to , as in
Figure~\ref{fig:Tf}. Its input wires are not modified by the circuit,
and the trace of all intermediate results are kept in garbage wires.

Because of their particular structure, two Landauer embeddings  and
 can be composed to give a Landauer embedding of
the composition . Figure~\ref{fig:TgTh} shows the process:
the wires of the output of  are fed to the input of , and
the output of the global circuit is the one of . The garbage
wires now contain all the ones of  and .

Note that it is easy to build elementary Landauer embeddings for
negation and conjunction: the former is a negatively-controlled not
while the latter is a positively doubly-controlled not. 
Any boolean function can then be computed with Landauer embeddings.


\def\multiline#1#2#3#4{\save
(#1,#4#2);(#3,#2)**\dir{-};
(#1,#4#2.9999);(#3,#4#2.9999)**\dir{-};
(#1,#4#2.5);(#3,#4#2.5)**\dir[|(0.5)]{-};
(#1,#4#2.25);(#3,#4#2.25)**\dir{-};
(#1,#4#2.75);(#3,#4#2.75)**\dir{-};
(#1,#4#2.625);(#3,#4#2.625)**\dir[|(0.5)]{-};
(#1,#4#2.375);(#3,#4#2.375)**\dir[|(0.5)]{-};
(#1,#4#2.55);(#3,#4#2.55)**\dir[|(0.5)]{-};
(#1,#4#2.45);(#3,#4#2.45)**\dir[|(0.5)]{-};
\restore}
\begin{figure}[tb]
\scriptsize\centering
\begin{subfigure}{.35\textwidth}
  \centering
  
  \caption{Landauer embedding of .}
  \label{fig:Tf}
\end{subfigure}
\qquad
\begin{subfigure}{.5\textwidth}
\centering
\caption{Composing two Landauer embeddings.}
\label{fig:TgTh}
\end{subfigure}
\caption{Landauer embeddings.}
\label{fig:class-shape-to-closed}
\end{figure}


\section{Reversible circuits as trace of programs}
\label{sec:progr-revers-circ}

In this section, we present an implementation of Landauer embeddings
to the context of a higher-order functional programming language, and
show how it can be understood through an abstract machine.



\subsection{Simple formalization of reversible circuits}

A reversible circuit has a very simple structure. As a linear sequence
of elementary gates, it can be represented as a simple list of gates.

\begin{definition}\rm
  A \define{reversible gate}  is a term 
  
  where , ,\ldots, are natural numbers such that for all
  , , and where ,\ldots, are booleans. If the list of
   is empty, we simply write  in place of
  .
The \define{wires} of the gate
   is the set of natural
  numbers . The wire  is called
  \define{active} and the 's are called the \define{control
    wires}.
Given a list  of gates, the union of
  the sets of wires of the elements of  is written .
  Finally, the boolean values True and False flowing in the wires are
  respectively represented with  and  throughout the paper.
\end{definition}


\begin{definition}
  A \define{reversible boolean circuit} is a triplet  where
   is a list of reversible gates and where  and  are sets of
  wires. The list  is the \define{raw circuit},  is the set of
  \define{inputs wires} and  the set of \define{outputs wires}. We
  also call  the \define{auxiliary wires} and
   the \define{garbage wires}.
\end{definition}

Executing a reversible circuit on a given tuple of booleans
computes as follows.

\begin{definition}\label{def:exec-circ}
  Consider a circuit  and a family of bits .
A \define{valuation} for the circuit is an indexed family
   of booleans.
The \define{execution of a gate 
    on the valuation } is the valuation  such that for all
  ,  and
  
  if  and  otherwise.
  The execution of the circuit  with input  is
  the succession of the following operations:
  (1) Initialization of a valuation  such that for all ,
    , and for all the other values of ,  is false.
  (2) Execution of every gate in  on , {\em in reverse order}.
  (3) The execution of the circuit returns the sub-family
    .
\end{definition}


\subsection{A PCF-like language with lists of booleans}

In this section, we present the functional language \PCF{} that we use
to describe the regular computations that we eventually want to
perform with a reversible circuit. The language is simply-typed and it
features booleans, pairs and lists.
1ex]
  A,B & {:}{:}{=} &
  \bit \bor A \oplus B \bor A\times B \bor 
  \unittype \bor A \to B \bor \listtype{A}.
\end{array}

  \infer{\Delta,x:A\vdash x:A}{}
  \quad
  \infer{\Delta\vdash \ttrue:\bit}{}
  \quad
  \infer{\Delta\vdash \ffalse:\bit}{}
  \quad
  \infer{\Delta\vdash \punit:\tunit}{}
  \quad
  \infer{\Delta\vdash \errorlist:A}{}
  
  \infer{\Delta\vdash {\tt not}:\bit\to\bit}{}
  \quad
  \infer{\Delta\vdash {\tt and}:\bit\times\bit\to\bit}{}
  \quad
  \infer{\Delta\vdash {\tt xor}:\bit\times\bit\to\bit}{}
  
  \infer{\Delta\vdash \splitlist:\listtype{A}\to\tunit\oplus(A\times\listtype{A})}{}
  
  \infer{\Delta\vdash\lambda x.M : A\to B}{
    \Delta,x:A\vdash M:B
  }
  \qquad
  \infer{\Delta\vdash\pi_i(M):A_i}{
    \Delta\vdash M:A_1\times A_2
  }
  \qquad
  \infer{\Delta\vdash\inj_i(M):A_1\oplus A_2}{
    \Delta\vdash M:A_i
  }
  
  \infer{\Delta\vdash MN : B}{
    \Delta\vdash M : A \to B
    &
    \Delta\vdash N : A
  }
  \qquad
  \infer{\Delta\vdash \prodterm{M,N} : A\times B}{
    \Delta\vdash M : A
    &
    \Delta\vdash N : B
  }
  \qquad
  \infer{\Delta\vdash \letunitterm{M}{N} : B}{
    \Delta\vdash M : \tunit
    &
    \Delta\vdash N : B
  }
  
  \infer{\Delta\vdash \match{P}{x^A}{M}{y^B}{N} : C}{
    \Delta\vdash P : A\oplus B
    &
    \Delta,x:A\vdash M : C
    &
    \Delta,y:B\vdash N : C
  }
  \qquad
  \infer{\Delta\vdash M:\listtype{A}}{
    \Delta\vdash M:\tunit\oplus(A\times\listtype{A})
  }
  
  \infer{\Delta\vdash Y(M):A}{
    \Delta\vdash M : A\to A
  }
  \qquad
  \infer{\Delta\vdash \iftermx{P}{M}{N} : C}{
    \Delta\vdash P : \bit
    &
    \Delta\vdash M : C
    &
    \Delta\vdash N : C
    &
    \textrm{the type  is first-order}
  }
  
    \begin{array}{c}
    \begin{array}{r@{}lr@{}lr@{}l}
    (\lambda x.M)N &\to M{[}N/x{]}
    &
    \pi_i\prodterm{M_1,M_2} &\to M_i
    &
    \letunitterm{\punit}{M}
    &\to M
    \2.5ex]
    \begin{array}{r@{}lr@{}l}
    \match{\inj_i(P)}{x_1}{M_1}{x_2}{M_2}
    &\to
    M_i{[}P/x_i{]}
    &
    Y(M)
    &\to
    M(Y(M))
    \end{array}
    \end{array}
    \begin{array}{r@{~}l}
        (C[(\lambda x.M)N], RC, L) &\rwam (C[M{[}N/x{]}], RC, L)
        \.5ex]
        (C[\letunitterm{\punit}{M}], RC, L)  &\rwam (C[M], RC, L)
        \.5ex]
        (C[\match{\inj_i(P)}{x_1}{M_1}{x_2}{M_2}], RC, L)
        &\rwam
        (C[M_i{[}P/x_i{]}], RC, L)
        \
  \caption{Rewrite rules for circuit-generating abstract-machine:
    generic rules.}
  \label{tab:ambetagen}
\end{table}

\begin{table}[t]
  {}
\caption{Rewrite rules for circuit-generating abstract-machines: rules
for booleans}
\label{tab:rw-abm}
\end{table}


The set of circuit-generating abstract machines is equipped with a
rewrite-system  defined using a notion of
\define{beta-context} , that is, a term with a hole, as follows.

The constructor  is the \define{hole} of the context. Given a
context  and a term , we define  as the
variable-capturing substitution of the hole  by .


The rewrite rules can then be split in two sets. The first set
concerns all the term constructs unrelated to the type . In
these cases, the state of the abstract machine is not modified, only
the term is rewritten. The rules, presented in
Table~\ref{tab:ambetagen}, are the same as for the small-step
semantics of Table~\ref{tab:betared}: apart from the two rules
concerning --, all the others are
the same.



The second set of rules concerns the terms dealing with the type
, and can be seen as partial-evaluation rules: we only record
in the circuit
the operations that would need to be done. The rules are shown
in Table~\ref{tab:rw-abm}.  The linking function  is
, where  is a new wire. The
variable  is assumed to be fresh. 
For the case of the --, we assume
 and  are first-order extensions of  with the same shape. The
term  is a first-order extension of  with the same shape as 
and  containing only (pairwise-distinct) free variables and mapping
to new distinct garbage wires.  is  updated with this new
data.  Suppose that  contains the variables , that
 contains the variables  and that  contains the
variables .  Then  is  with the following
additional series of gates:
 and
.

\begin{remark}
  Note that the set  is never modified by the rules
\end{remark}

Safety properties hold for this new semantics, in the sense that the
only error uncaught by the type system is the term  that
might be spawned.

\begin{theorem}[Type preservation]
  If , if
   is an abstract machine and if , then we have the judgement 
  .\qed
\end{theorem}

\begin{theorem}[Progress]
  Suppose that  is valid and that  is an abstract
  machine. Then either  is a value, or  contains , or
   reduces through ().\qed
\end{theorem}



\subsection{Simulations}

The abstract machine  generates a circuit computing the same
function as the small-step reduction of  in the following sense.

\begin{definition}
  Let  be an abstract machine. 
We write  for the circuit defined as .
Let  be the execution of the circuit
   on the valuation . We
  define  as the term  where each free
  variable  has been replaced with .
\end{definition}

Intuitively, if  is seen as a term where some boolean
operations have been delayed in , then  corresponds to the
term resulting from the evaluation of the delayed operations.

\begin{theorem}\label{th:sim}
  \label{th:eq-am-beta}
  Consider a judgment  and
  suppose that
  
  Then , and provided that , the term
   is
  equal to  if and only if the
  term 
  reduces to .
\end{theorem}

The proof is done using an invariant on a single step of the rewriting
of abstract machines, stated as follows.


\begin{lemma}\label{lem:inv1}
  Consider a judgment  and
  suppose that
  
  Let  be a valuation.
Then either the term
   is equal to  if the rewrite corresponds to the
  elimination of a boolean  or , or , or  contains the
  error term 
  .
  \qed
\end{lemma}

\begin{proof}[Proof of Theorem~\ref{th:sim}]
  If
  ,
  then there is a sequence of intermediate rewrite steps where none of
  the terms involved is the term . From Lemma~\ref{lem:inv1}, one
  concludes that for all valuations  on ,
  .
Choosing , 
   is the term  where each free
  variable  has been substituted with its corresponding
  boolean . 
Similarly,
   is equal to the value. We can conclude the proof by
  remarking that the term   reduces to   where each of the free
  variables  have been substituted with , that is, 
  the term .
\end{proof}


One would have also hoped to have a simulation result in the other
direction, stating that if a (closed) term  reduces to a
tuple of booleans, then  generates a circuit computing
the same tuple. Unfortunately this is not the case, and the reason is
the particular status of the type  and the way the {\tt if}-{\tt
  then}-{\tt else} behaves.


\begin{remark}\label{rem:if1storderbis}
  Let us re-visit the first-order constraint of the {\tt if}-{\tt
    then}-{\tt else} discussed in Remark~\ref{rem:if1storder} in the
  light of this operational semantics. Here, this test behaves as a
  regular boolean operator acting on three arguments: they need to be
  all reduced to values before continuing. This test is ``internal''
  to the circuit: both branches are evaluated during a run of the
  program.  Because it is ``internal'', the type of the branches have
  to be ``representable'': thus the constraint on first-order. This
  test does not control the execution of the program: its
  characteristic only appears at circuit-evaluation time.
  
  With this operational semantics, it is also interesting
  to note that there are two kinds of booleans: the ``internal'' type
  , and the ``external'' type defined e.g. as . If the former does not control the flow, the
  latter does with the {\tt match} constructor. And unlike {\tt if}-{\tt
    then}-{\tt else}, {\tt match} does not have type
  constraints on its branches.
  
  The term  can be explained in the light of this
  discussion. Thanks to the condition on the shape of the output
  branches of the test, it is used to enforce the fact that 
  cannot be coerced to a . Indeed, consider the term
  : using a {\tt match} against the
  result of the test, it would allow one to use the bit  for
  controlling the shape of the rest of the circuit. 
As there is not such construct for reversible circuits, it therefore
  has to be forbidden: it is not possible to control the flow of
  execution of the program through the type . And the fact that
  a well-typed term can produce an error is simply saying that the
  type-system is not ``strong enough'' to capture such a problem. It
  is very much related to the fact that the {\tt zip} operator on
  lists cannot be ``safely'' typed without dependent types.
\end{remark}




\section{Internalizing the abstract machine}
\label{sec:internalizing}

Instead of defining an external operational semantics as we did in
Section~\ref{sec:op-sem-rev-circ}, one can internalize the definition
of circuits in the language \PCF{}. Given a program,
provided that one chooses a reduction strategy, one can simulate the
abstract-machine semantics inside \PCF{} using a generic {\em monadic
  lifting}, close to what was proposed in~\cite{MLmonad}.


\subsection{Monadic lifting}
\label{sec:monadic-lifting}

Before going ahead with the full abstract-machine semantics, we present the
monadic lifting of \PCF{} for a monadic function-type. It is the
transposition of Haskell's monads to our language \PCF{}. The main
characteristic of the reversible abstract-machine is to change the
operational behavior of the type : the terms ,
, the inline -combinators and the term construct
 do not reduce as regular lambda-terms. Instead,
they trigger a side-effect, which can be simulated within a
monad.


\begin{definition}\rm
  A \define{monad} is a function-type  together with
  two terms  and
  .
A \define{reversible-circuit monad} is a monad together with a type
   and the terms
  ,
  ,
  and
  ,
  and finally .
\end{definition}


\begin{definition}\rm
  Given a reversible-circuit monad , we inductively define the
  \define{-monadic lifting of a type }, written
  . We omit the index
   for legibility.
  {}
  The \define{-monadic lifting of a term }, denoted with
  , is defined as follows. First, we set ,
    , 
    ,
     and 
    . Then
  {}
\end{definition}

\begin{remark}\label{rem:cbv}
  Note that in this definition of the lifting, we followed a
  call-by-value approach: the argument  of a function
   is first reduced to a value before being fed
  to the function. This will be discussed in Section~\ref{sec:cbv}.
\end{remark}

The fact that a monad is equipped with , ,
, ,  and  is not a
guarantee that the lifting will behave as expected. One has to choose
the right monad for it. It is the topic of
Section~\ref{sec:rev-circ-from-monad}.  However, in general this
monadic-lifting operation preserves types (proof by induction on the
typing derivation).

\begin{theorem}
  Provided that  is valid, so is the judgment
  \qed
\end{theorem}




\subsection{Reversible circuits from monadic lifting}
\label{sec:rev-circ-from-monad}



All the structure of the abstract machine can be encoded in
the language \PCF{}.
A wire is a natural number. A simple way to represent them
is with the type . The number
 is the empty list while the successor of  is
.
A gate is then .
A raw circuit is  .

We now come to the abstract machine. In the formalization of
Section~\ref{sec:op-sem-rev-circ}, we were using a state with a circuit and a
linking function. In this internal representation, the linking
function is not needed anymore: the computation directly acts on
wires. However, the piece of information that is still needed is the
next fresh value. The state is encapsulated in .
Finally, given a type , we write  for the type
: this is a computation
generating a reversible circuit.

The type operator  can be equipped with the structure of
a reversible-circuit monad, as follows. First, it is obviously a
state-monad, making the two first constructs automatic:

The others are largely relying on the fact that \PCF{} is expressive
enough to emulate what was done in Section~\ref{sec:op-sem-rev-circ}.
Provided that  stands for the successor function, we can
 as the lambda-term

and  as  the lambda-term
.
Note how the definition reflects the reduction rules corresponding to
 and  in Table~\ref{tab:rw-abm}: in the case of
, the returned wire is the next fresh one, and the state is
updated by increasing the ``next-fresh'' value by one unit. In the
case of , on top of this we add a not-gate to the list of
gates in order to flip the value of the returned wire.
The definitions of ,  and  are
similar. For , one capitalizes on the fact that we know the
structure of the branches of the test, as they are of first-order
types. One can then define a zip-operator  for
each first-order type .

\subsection{Call-by-value reduction strategy}
\label{sec:cbv}

As was mentioned in Remark~\ref{rem:cbv}, the monadic lifting
intuitively follows a call-by-value approach. It can be formalized by
developing a call-by-value reduction strategy for circuit-abstract
machines.
Such a definition follows the one of the reduction proposed in
Section~\ref{sec:op-sem-rev-circ}: we first design a notion of {\em
  call-by-value evaluation context}  characterizing the
call-by-value redex that can be reduced.

\begin{table}
  1ex]}
    \begin{array}{r@{}l}
    (E[(\lambda x.M)V], RC, L) &\cbvam (E[M{[}V/x{]}], RC, L)
    \nl
    (E[\pi_i\prodterm{V_1,V_2}], RC, L) &\cbvam (E[V_i], RC, L)
    \nl
    (E[\letunitterm{\punit}{M}], RC, L)
    &\cbvam (E[M], RC, L)
      \nl
    (E[\splitlist\,V], RC, L) &\cbvam (E[V], RC, L)
                                \nl
   (E[\match{\inj_i(V)}{x_1}{M_1}{x_2}{M_2}], RC, L)
    \hspace{-10ex}\nl &\cbvam
    (E[M_i{[}V/x_i{]}], RC, L)
    \nl
    (E[Y(\lambda x.M)], RC, L)
    &\cbvam
    (E[M[Y(\lambda x.M)/x]], RC, L)
    \end{array}
  
  (E[\ffalse],RC,L)\cbvam(E[p_{i_0}], RC, L')
  ~~&~~
  (E[\ttrue],RC,L)\cbvam(E[p_{i_0}], (\notgate{i_0})::RC,
  L')
  \\
  (E[{\tt not}~p_i],RC,L)&\cbvam(E[p_{i_0}],\cnotgate{i_0}{\ffalse^i}::RC,
  L')
  \\
  (E[{\tt and}~p_i~p_j],RC,L)&\cbvam(E[p_{i_0}],
  \cnotgate{i_0}{\ttrue^i\ttrue^j} :: RC, L')
  \\
  (E[{\tt xor}~p_i~p_j],RC,L)&\cbvam(E[p_{i_0}],\cnotgate{i_0}{(i,\ttrue)}::
  \cnotgate{i_0}{\ttrue^j}::RC, L')
  \\
  (E[\iftermx{p_i}{V}{W}], RC, L)&\cbvam
                                   \\
&\hspace{-10ex}
  \left\{
    \begin{array}{l@{\quad}l}
      (E[U], RC',L'') & \textrm{ and  of the same shape}
      \\
      \errorlist & \textrm{otherwise}
    \end{array}\right.
  
\begin{array}{lll}
E[-]
&{:}{:}{=}&
[-]
\bor
(E[-])N \bor V(E[-]) \bor
\prodterm{E[-],N} \bor
\prodterm{V,E[-]} \bor
\\
&&
\pi_1(E[-]) \bor
\pi_2(E[-]) \bor
\letunitterm{E[-]}{N} \bor
\letunitterm{V}{E[-]} \bor
\iftermx{E[-]}{N}{P} \bor
\\
&&
\iftermx{V}{E[-]}{P} \bor
\iftermx{V}{W}{E[-]} \bor
\inj_1(E[-]) \bor 
\\
&&
\inj_2(E[-]) \bor
\match{E[-]}{x}{M}{y}{N} \bor
Y(E[-]).
\end{array}
\vspace{-2ex}
    \left(\Lift{}(M)[\overline{L(x_{n+1})}/x_{n+1}\ldots
    \overline{L(x_{n+k})}/x_{n+k}]\right)
    \prodterm{\overline{C},\succterm\,\overline{\max({\rm
        Range}(L))}},
  
\lettermx{z_1}{{\tt xor}\,x\,y}{\lettermx{z_2}{f(x,y)}{g(z_1,z_2)}}
\lettermx{z_2}{f(x,y)}{}\lettermx{z_1}{{\tt xor}\,x\,y}{
g(z_1,z_2)}.

As  does not use  nor , one of the algebraic optimization
might apply.


\begin{figure}[tb]
  \centering
  \includegraphics[width=2in]{adder4-optim-eps-converted-to.pdf}
  \caption{Reversible adder for 4-bit integers, optimized.}
  \label{fig:adder-4-optim}
\end{figure}

\begin{example}
  By applying these optimization schemes on the reversible adder of
  Figure~\ref{fig:adder-4-raw}, one gets the circuit presented in
  Figure~\ref{fig:adder-4-optim}. One can now clearly see the
  carry-ripple structure, and it is in fact very close to known
  reversible ripple-carry adders (see
  e.g.~\cite{feynman85quantum}). These optimizations were implemented
  in Quipper: applied on larger circuits such as the ones of
  Example~\ref{ex:sin}, we get in general a size reduction by a factor
  of 10.
\end{example}




\section{Conclusion and future work}
\label{sec:conclusion}
In this paper, we presented a simple and scalable mechanism to turn a
higher-order program acting on booleans into into a family of
reversible circuits using a monadic semantics. The main feature of
this encoding is that an automatically-generated circuit is guaranteed
to perform the same computation as the original program.
The classical description we used is a small PCF-like language, but it
is clear from the presentation that another choice of language can be
made. In particular, an interesting question is whether it is possible
to use a language with a stronger type system for proving
properties of the encoded functions.

A second avenue of research is the question of the parallelization of
the generated circuits. The circuits we produce are so far completely
linear. Following the approach in~\cite{ghica07gos}, using parallel
higher-order language might allow one to get parallel reversible
circuits, therefore generating circuits with smaller depths.

Finally, the last avenue for research is the design of generic
compiler with a dedicated code optimizations.  Indeed, an analysis of
the specific optimizations described in Section~\ref{sec:optim}
suggests that these could be designed at the level of code, therefore
automatically generating leaner circuits up front. This opens the door
to the design of specific type systems and code manipulations in a
future full compiler.  and back-end, specific circuit optimizations.





\begin{thebibliography}{10}

\bibitem{abramsky}
S.~Abramsky.
\newblock A structural approach to reversible computation.
\newblock {\em Theor. Comput. Sci.}, 347(3):441--464, 2005.

\bibitem{BF}
A.~Ambainis, A.~M. Childs, {\em et~al.}
\newblock Any {AND}-{OR} formula of size  can be evaluated in time
   on a quantum computer.
\newblock {\em SIAM J. Comput.}, 39:2513â€“--2530, 2010.

\bibitem{bennett73logical}
C.~H. Bennett.
\newblock Logical reversibility of computation.
\newblock {\em {IBM} J. Res. Dev.}, 17:525--532, 1973.

\bibitem{esterel}
G.~Berry.
\newblock The foundations of esterel.
\newblock In {\em Proof, Language, and Interaction, Essays in Honour of Robin
  Milner}. MIT Press, 2000.

\bibitem{braibant13formal}
T.~Braibant and A.~Chlipala.
\newblock Formal verification of hardware synthesis.
\newblock In {\em Computer Aided Verification}, volume 8044 of {\em LNCS},
  pp. 213--228, 2013.

\bibitem{Claessen-2001}
K.~Claessen.
\newblock {\em Embedded Languages for Describing and Verifying Hardware}.
\newblock PhD thesis, Chalmers University of Technology and G{\"o}teborg
  University, 2001.

\bibitem{synth2}
K.~Fazel, M.A. Thornton, and J.~E. Rice.
\newblock {ESOP}-based {T}offoli gate cascade generation.
\newblock In {\em Proc. PacRim}, pp. 206--209, 2007.

\bibitem{feynman85quantum}
R.~P. Feynman.
\newblock Quantum mechanical computers.
\newblock {\em Optics News}, 11:11--20, 1985.

\bibitem{ghica07gos}
D.~R. Ghica.
\newblock Geometry of synthesis.
\newblock In {\em Proc. POPL}, pp. 363--375, 2007.

\bibitem{goi}
J.-Y.~Girard.
\newblock Towards a geometry of interaction.
\newblock {\em Contemp. Math.}, 92:69--108, 1989.

\bibitem{PLDI}
A.~S. Green, P.~L. Lumsdaine {\em et al.},
\newblock Quipper: a scalable quantum programming language.
\newblock In {\em Proc. PLDI}, pp. 333--342, 2013.

\bibitem{synth4}
P.~Gupta, A.~Agrawal, and N.~K. Jha.
\newblock An algorithm for synthesis of reversible logic circuits.
\newblock {\em IEEE Trans. on CAD of Int. Circ. and Sys.},
  25(11):2317--2330, 2006.

\bibitem{QLSA}
A.~W. Harrow, A.~Hassidim, and S.~Lloyd.
\newblock Quantum algorithm for linear systems of equations.
\newblock {\em Phys. Rev. Lett.}, 103(15):150502, 2009.

\bibitem{James}
Roshan~P. James and A. Sabry.
\newblock Information effects.
\newblock In {\em Proc. POPL}, pp. 73--84, 2012.

\bibitem{kluge99}
W.~Kluge.
\newblock A reversible {SE(M)CD} machine.
\newblock In {\em Proc. IFL}, LNCS 1868, pp.
  95--113, 1999.

\bibitem{landauer61irreversibility}
R.~Laundauer.
\newblock Irreversibility and heat generation in the computing process.
\newblock {\em {IBM} J. Res. Dev.}, 5:261--269, 1961.

\bibitem{TF}
F.~Magniez, M.~Santha, and M.~Szegedy.
\newblock Quantum algorithms for the triangle problem.
\newblock {\em SIAM J. Comput.}, 37(2):413--424, 2007.

\bibitem{maslov-templates-iccad03}
D.~Maslov, G.~W. Dueck, and D.~M. Miller.
\newblock {F}redkin/{T}offoli templates for reversible logic synthesis.
\newblock In {\em Proceedings of ICCAD}, pp. 256--261, 2003.

\bibitem{grover}
M.~A. Nielsen and I.~L. Chuang.
\newblock {\em Quantum Computation and Quantum Information}.
\newblock Cambridge Univ. Press, 2002.

\bibitem{bluespec}
R.~S. Nikhil.
\newblock Bluespec: A general-purpose approach to high-level synthesis based on
  parallel atomic transactions.
\newblock In {\em High-Level Synthesis}, pp. 129--146. Springer, 2008.

\bibitem{revs}
A. Parent, M. Roetteler, and K.~M. Svore.
\newblock Reversible circuit compilation with space constraints.
\newblock arXiv:1510.00377, 2015.

\bibitem{park08functional}
S.~Park, J.~Kim, and H.~Im.
\newblock Functional netlists.
\newblock In {\em Proc. ICFP}, pp. 353--366, 2008.

\bibitem{Quipper}
Quipper.
\newblock \url{http://www.mathstat.dal.ca/~selinger/quipper/}.

\bibitem{rev-survey-2011}
M.~Saeedi and I.~L. Markov.
\newblock Synthesis and optimization of reversible circuits -- a survey.
\newblock {\em ACM Comput. Surv.}, 45(2):21:1--21:34, March 2013.

\bibitem{synth13}
Y.~Sanaee, M.~Saeedi, and M.~S. Zamani.
\newblock Shared-pprm: A memory-efficient representation for boolean reversible
  functions.
\newblock In {\em Proc. of ISVLSI}, pp. 471--474, 2008.

\bibitem{forsyde}
I.~Sander.
\newblock {\em System Modeling and Design Refinement in {ForSyDe}}.
\newblock PhD thesis, Royal Institute of Technology, Stockholm, Sweden, 2003.

\bibitem{QLSAnous}
A.~Scherer, B.~Valiron {\em et al.}
\newblock Resource analysis of the quantum linear system algorithm.
\newblock arxiv:1505.06552, 2015.

\bibitem{shor}
P~Shor.
\newblock Algorithms for quantum computation: discrete logarithm and
  factoring.
\newblock In {\em Proc. FOCS}, 1994.

\bibitem{revkit}
M.~Soeken, S.~Frehse {\em et al.}
\newblock {RevKit}: An open source toolkit for the design of reversible
  circuits.
\newblock In {\em Proc. RC}, vol. 7165 of {\em LNCS},
  pp. 64--76, 2012.

\bibitem{soeken13white}
M.~Soeken and M.~K. Thomsen.
\newblock White dots do matter: Rewriting reversible logic circuits.
\newblock In {\em Proc. RC}, vol. 7948 of {\em LNCS}, pp.
  193--208, 2013.

\bibitem{MLmonad}
N.~Swamy, N.~Guts {\em et al.}
\newblock Lightweight monadic programming in {ML}.
\newblock In {\em Proc. ICFP}, pp. 15--27,  2011.

\bibitem{terui}
K.~Terui.
\newblock Proof nets and boolean circuits.
\newblock In {\em Proc. LICS}, pp. 182--191, 2004.

\bibitem{thomsen}
M. K. Thomsen.
\newblock A functional language for describing reversible logic.
\newblock In {\em Proc. FDL}, pp. 135--142, 2012.

\bibitem{revlib}
R.~Wille, D.~Gro{\ss}e, {\em et al.}.
\newblock {RevLib}: An online resource for reversible functions and reversible
  circuits.
\newblock In {\em {Int'l Symp. on Multi-Valued Logic}}, pp. 220--225, 2008.

\bibitem{synth17}
R.~Wille, H.~M. Le, G.~W. Dueck, and D.~Grosse.
\newblock Quantified synthesis of reversible logic.
\newblock In {\em Proc. DATE}, pp. 1015--1020, 2008.

\bibitem{syrec}
R.~Wille, S.~Offermann, and R.~Drechsler.
\newblock {SyReC}: A programming language for synthesis of reversible circuits.
\newblock In {\em Forum on Specification Design Languages}, pp. 1--6, 2010.

\end{thebibliography}

\end{document}
