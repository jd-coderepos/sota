\documentclass[runningheads,a4paper]{llncs}

\setcounter{tocdepth}{3}

\usepackage{amssymb,amsmath,makeidx,enumerate,stmaryrd,textcomp}
\usepackage[all]{xy}
\usepackage{tabls}
\usepackage{pslatex}

\usepackage{color,graphicx,xcolor}

\newif\ifcscomp
  \cscomptrue
  \cscompfalse

\newif\ifcost
  \costfalse
  \costtrue

\newif\ifnat
  \natfalse
  \nattrue

\newif\ifemi
  \emitrue
  \emifalse

\newif\ifthm
  \thmfalse
  \thmtrue

\newif\ifllncs
  \llncsfalse
  \llncstrue

\newif\ifarticle
  \articletrue
  \articlefalse

\newif\iftesi
  \tesitrue
  \tesifalse

\newif\ifmod
  \modtrue
  \modfalse

\newif\ifqapl
  \qapltrue
  \qaplfalse

\newif\ifqapl
  \qaplfalse
  \qapltrue

\newif\ifpar
  \partrue
  \parfalse

\newcommand{\hdof}[1]{\mathcal H_{\nretohds{#1}}}
\newcommand{\nrebinder}[1]{\tuple{#1}}
\newcommand{\q}{\mathsf{q}}
\newcommand{\x}{\mathsf{x}}
\newcommand{\y}{\mathsf{y}}


\newcommand{\longversion}[1]{#1}
\newcommand{\oscope}{\mbox{\tiny}}
\newcommand{\cscope}{\mbox{\tiny}}
\newcommand{\nretohds}[1]{\llparenthesis #1 \rrparenthesis}
\newcommand{\mybinder}[2]{\oscope {#1} . {#2} \cscope}
\newcommand{\addname}[2]{#1 \dag  #2}
\newcommand{\ltype}{\mbox{-type}}
\newcommand{\alp}{\mathcal S} 

\newcommand{\stk}{\Sigma}
\newcommand{\pushtr}{\curvearrowright}
\newcommand{\poptr}{\curvearrowleft}
\newcommand{\popstk}[1]{\stackrel{\poptr}{#1}}
\newcommand{\popstktwo}[1]{\stackrel{2\poptr}{#1}}
\newcommand{\topstk}[1]{{#1}^\top}
\newcommand{\stkupd}[2]{{#1} \bullet {#2}}
\def\finex{{\unskip\nobreak\hfil
\penalty50\hskip1em\null\nobreak\hfil
\parfillskip=0pt\finalhyphendemerits=0\endgraf}}

\usepackage{fge}

\newcommand{\estk}{\fgestruckzero}

\newcommand{\str}[1]{#1^{\star}}
\newcommand{\words}{\str{\alp}}
\newcommand{\step}[3]{#2 \stackrel{#1}{\to} #3}
\newcommand{\states}{\mathit{Q}}
\newcommand{\trans}{\mathit{tr}}
\newcommand{\accs}{\mathit{G}}
\newcommand{\rec}{\mathit{rec}}
\newcommand{\emptystr}{\epsilon}
\newcommand{\cat}{\mathit{::}}
\newcommand{\lang}[1]{\mathcal{L}_{#1}}
\newcommand{\fmhd}[1]{\mathcal{H}[{#1}]}
\newcommand{\fresh}{\star}
\newcommand{\pop}[1]{\mathtt{pop}}
\newcommand{\push}[1]{\mathtt{push}}
\newcommand{\nrehd}[1]{\llparenthesis \ #1 \ \rrparenthesis}

\newcommand{\ps}{\mathtt{Autf}}
\newcommand{\atons}[1]{#1{}^{\bullet}}
\newcommand{\nstoa}[1]{#1{}^{\circ}}
\newcommand{\unorder}[1]{\hat #1}
\newcommand{\pa}[1]{\mbox{}}
\newcommand{\nalp}{\atons{\alp}}

\newcommand{\arel}{\mathcal{R}}

\newcommand{\weight}[1]{|#1|}
\newcommand{\hist}{\mathcal{H}}
\newcommand{\gmaps}{\mathit{Hist}}
\newcommand{\ninj}{\mathit{in}} \newcommand{\mcp}[1]{\mathit{mcp}(#1)}
\newcommand{\abst}[2]{[#1]#2}


\newcommand{\hst}[3]{#1 :: #2 \to #3}
\newcommand{\lreq}{req}
\def\act#1#2{#1 @ #2}

 \newcommand{\exend}{\hfill}
\newcommand{\ie}{i.e.}
 \newcommand{\eg}{e.g.}
 \newcommand{\Real}[1]{\mathrm{Real}}

 \newcommand{\hide}[2]{{#1} \setminus {#2}}

\newcommand{\bla}{bla, bla, bla...}
  \newcommand{\compile}[2]{\ifthenelse{\equal{#1}{yes}}{#2}{}}

  \newcommand{\cf}[2]{
    \fontsize{#1}{#1}{\selectfont{#2}}
  }
  \ifemi
  \usepackage{ulem}\normalem
    \newcommand{\emi}[1]{{\marginpar{\cf{6}{{#1}}}}}
    \newcommand{\emic}[2]{\ \.1em]}
    \newcommand{\answ}[2]{\fbox{\parbox{.8\textwidth}{\begin{description}\item[\cf{8}{\sc\bf
                #2}]\cf{8}{#1}\end{description}}}}
    \else
    \newcommand{\emi}[1]{}
    \newcommand{\emic}[2]{}
    \newcommand{\answ}[2]{#1}
    \fi
\newcommand{\togliere}[1]{\emic{\sout{#1}}{}}
    \newcommand{\change}[1]{\emic{#1}{\color{green}{\sc modificare}}}
    \newcommand{\controllare}[1]{\emic{#1}{\color{violetto}{\sc Check}}}
    \newcommand{\epsrc}[1]{\emic{#1}{\fbox{\sc From epsrc site}}}



  \ifemi
    \newcommand{\evd}[1]{{{\bf #1}}}
    \newcommand{\referee}[1]{
      \\{{\bf #1}}\\
    }
  \else
    \newcommand{\referee}[1]{#1}
    \newcommand{\evd}[1]{#1}
  \fi

  \newcommand{\tbc}{\emi{To Be Continued}}
  \newcommand{\mono}{\hookrightarrow}
  \newcommand{\epi}{\twoheadrightarrow}

  \newcommand{\st}{\ \ \big| \ \ }
  \newcommand{\setof}[1]{\{#1\}}
  \newcommand{\setdef}[2]{\{#1 \st #2\}}
  \newcommand{\multiset}[1]{[#1]}
  \newcommand{\setvec}[1]{{\{\!|}\vec{#1}{|\!}\}}
  \newcommand{\asetvec}[1]{{\{\!|}{#1}{|\!}\}}
\newcommand{\veclen}[1]{\mod{\vec{#1}}}
  \newcommand{\aveclen}[1]{\mod{{#1}}}
  \newcommand{\myvectorlen}[1]{\mod{\vec{#1}}}
  \newcommand{\veceq}[2]{\vec{#1}=\vec{#2}}
  \newcommand{\rangeto}[1]{\in \{1,\ldots,{#1}\}}
  \newcommand{\ranges}[2]{\in \{{#1},\ldots,{#2}\}}
  \newcommand{\rng}[2]{\{{#1},\ldots,{#2}\}}
  \newcommand{\range}[1]{\mathrm{range}(#1)}
  \newcommand{\puntini}[3]{{#1}_{#2},\ldots,{#1}_{#3}}

  \newcommand{\ptrn}{\rightarrow}
  \newcommand{\strn}{\longmapsto}

\def\ured{\rightarrow}
     \def\tred#1{\overstackrel{\rightarrowfill}{#1}}
     \def\iured#1{\rightarrow_{\descr{\scriptsize #1}}}
     \def\itred#1#2{\mathrel{{\overstackrel{\rightarrowfill}{#2}}_{\descr
       {\scriptsize #1}}}}
     \def\sytr#1{\overstackrel{\longmapsto}{#1}}
\def\actr#1#2{\overstackrel{\rightarrowfill}{\act {#1}{#2}}}
     \def\iactr#1#2#3{\overstackrel{\rightarrowfill}{\act {#2}{#3}}_{\descr
       {\scriptsize #1}}}
     \def\dlarrow#1#2{\overunderstackrel{\rightarrowfill}{#1}{#2}}
     \def\ddlarrow#1#2{\overunderstackrel{\longmapsto}{#1}{#2}}
     \def\Dlarrow#1#2{\overunderstackrel{\Longrightarrow}{#1}{#2}}
     \def\dmtarrow#1#2{\overunderstackrel{\longmapsto}{#1}{#2}}
     \def\mtarrow#1{\overstackrel{\longmapsto}{#1}}
     \newcommand{\mylarrow}[1]{\overstackrel{\rightarrowfill}{#1}}
     \ifmod
       \newcommand{\mod}[1]{\ensuremath{\mathopen{\mid}#1\mathclose{\mid}}}
     \else
       \renewcommand{\mod}[1]{\ensuremath{\mathopen{\mid}#1\mathclose{\mid}}}
     \fi
     \newcommand{\partarrow}[2]{\overunderstackrel{\rightarrowfill}{\ \ \mbox{\scriptsize }\ \ }{\ \mbox{\scriptsize }\ }\!\!\!>}
     \newcommand{\arw}[1]{\overstackrel{\rightarrowfill}{#1}}
     \newcommand{\newpartarrow}[2]{\partarrow{#1}{}}
     \newcommand{\spartarrow}[1]{\overstackrel{\rightarrowfill}{\ \ \mbox{\scriptsize }\ \ \ }\!\!\!\!\!>}
     \newcommand{\trlts}[1]{\overstackrel{\rule[.8mm]{7mm}{.2mm}}{#1}\!\!\blacktriangleright}
     \newcommand{\trred}{\overstackrel{\rule[.8mm]{7mm}{.2mm}}\!\!\vartriangleright}

     \newcommand{\Dom}[1]{\mathrm{dom}[{#1}]}


  \newcommand{\namedef}[2]
    {\begin{center}\begin{tabular}{lr}
       {}
      & \qquad
       {\emph{#1}}
     \end{tabular}\end{center}
    }
\ifcscomp
    \newcommand{\comp}[2]{#1 ; #2}
  \else
    \newcommand{\comp}[2]{#2 \circ #1}
  \fi
  \newcommand{\id}[1]{\mathrm{id}_{#1}}
  \newcommand{\seq}{\stackrel{\cdot}{=}}
  \newcommand{\pws}[1]{\wp({#1})}
  \newcommand{\pwsf}[1]{\wp_{\mbox{\tiny fin}}({#1})}
  \newcommand{\pwsh}[1]{\wp^H({#1})}
  \newcommand{\newredlabel}[4]{\ensuremath{\mathbf{#1}(#3,#4)}}
\newcommand{\mypair}[2]{\langle #1, #2 \rangle}
  \newcommand{\proofend}{\mbox{}}
  \newenvironment{prova}{{\sc Proof.}}{\hfill\proofend}
  \newcommand{\smod}{\mid\!\equiv}
  \newcommand{\mmdef}{\mbox{}}
  \newcommand{\notd}{\stackrel{\mbox{\tiny Not}}{=}}
  \newcommand{\lar}[1]{\overstackrel{\longleftarrow}{#1}}
  \newcommand{\defuguale}{:=}
  \newcommand{\deduz}[2]{\frac{\displaystyle #1}{\displaystyle #2}}
  \newcommand{\dtr}[2]{\mathrel{\stackoverunder{\longrightarrow}{#1}{#2}}}






  \newcommand{\tool}{{\sc SPAS}{\tt y}{\sc A}}
  \newcommand{\trust}{TRUST}
  \newcommand{\sta}{STA}
  \newcommand{\pcs}{PCS}

\newcommand{\casla}{
    \texttt{casla} (CAlculus for SLA),
    \texttt{CSS} (C-Semiring for SLA)
  }
  \newcommand{\caslaprog}[2]{{#1} \vdash {#2}}
  \newcommand{\decsep}{\wedge}
  \newcommand{\piu}{\oplus}
  \newcommand{\per}{\otimes}
  \newcommand{\opiu}{\oplus}
  \newcommand{\oper}{\odot}
  \newcommand{\zero}{\mathbf{0}}
  \newcommand{\uno}{\mathbf{1}}
  \newcommand{\zzero}{{\underline\zero}}
  \newcommand{\uuno}{{\underline\uno}}


  \newcommand{\cip}{cIP}
  \newcommand{\pl}{}

\newcommand{\Aarw}[2]{{#1}^{#2}}
  \newcommand{\Aarr}{{\mathbf\mu}}
  \newcommand{\Farw}{{\sigma}}
  \newcommand{\Sarw}{{\gamma}}
  \newcommand{\Agarw}{{p}}
  \newcommand{\Parw}{{\pi}}
  \newcommand{\lproc}{{P}}
  \newcommand{\Larw}{{P}}
  \newcommand{\garw}{{\theta}}
  \newcommand{\pac}{\mbox{{\bf PAC}}}
  \newcommand{\type}[1]{\mathtt{#1}}
  \ifnat
\fi
  \newcommand{\natseg}[1]{\underline{#1}}
  \newcommand{\natstar}{\nat_{\star}}
  \newcommand{\enumtype}{\,\cdot\cdot\,}
  \newcommand{\fst}[1]{\mathrm{I}({#1})}
  \newcommand{\snd}[1]{\mathrm{II}({#1})}
  \newcommand{\h}[1]{\mathrm{h}_{#1}}
  \newcommand{\sig}[1]{\Sigma_{#1}}
\newcommand{\supp}{\mathit{supp}}
   \newcommand{\orb}{\mathit{Orb}\,}
\newcommand{\upd}[2]{[{#1} \mapsto {#2}]}
  \newcommand{\update}[2]{{#1}[{#2}]}
  \newcommand{\fnres}[2]{{#1}|_{#2}}
  \newcommand{\cp}{D[P]}
  \newcommand{\ccp}{D[P']}
  \newcommand{\qp}{Q_{{\cp}}}
  \newcommand{\qqp}{Q_{{\ccp}}}
  \newcommand{\Aut}{\mathit{Aut}}
  \newcommand{\hdimp}{\mbox{\sf Mihda}}
\newcommand{\hda}{HDA}
  \newcommand{\hds}{HDS}
\newcommand{\hdn}{HDN}
  \newcommand{\hdns}{HDS}
  \newcommand{\hdA}{HD-Au\-tom\-a\-ta}
  \newcommand{\hdN}{HD-Au\-tom\-a\-ton}
  \newcommand{\emptysub}{\mathbf{0}}
  \newcommand{\parfun}{ \ \ \circ\!\!\!\!\!\!\!\!\longrightarrow}
  \newcommand{\pf}{\rightharpoonup}
\newcommand{\myint}{\mathtt{int}}
  \newcommand{\boutput}{BOUT(x)}
  \newcommand{\hd}{\mbox{HD-automata}}
  \newcommand{\est}[1]{\ensuremath{#1^{\ast}}}
\newcommand{\lnorm}[1]{\hat{#1}}
  \newcommand{\wlnorm}[1]{\widehat{#1}}
  \newcommand{\snorm}[1]{\sigma_{#1}}
  \newcommand{\idfus}{\varepsilon}
  \newcommand{\sfus}[3]{[a_{#1} = a_{#2}]_{#3}}
  \newcommand{\lsin}{\in}
  \newcommand{\camlid}[1]{{\tt #1\/}}
  \newcommand{\mcamlid}[1]{\mathtt{#1}}
  \newcommand{\fldname}[1]{\mbox{}}
  \newcommand{\cmd}[1]{{\bf #1}}
  \newcommand{\keyw}[1]{{\sl #1}}
  \newcommand{\costr}[1]{{{\sf #1}}}
  \newcommand{\iter}[2]{}
  \newcommand{\mlfun}[1]{\mbox{\small{\sl #1}}}
\newcommand{\elle}{\mbox{}}
  \newcommand{\pii}{\mbox{}}
  \newcommand{\sigmaa}{\mbox{}}
  \newcommand{\unit}{\mbox{}}
  \newcommand{\mlfunn}[2]
   {
    
 }
  \newcommand{\listrem}{\setminus}
  \newcommand{\listdiff}{\setminus\!\!\setminus}
  \newcommand{\append}{\setminus}
  \newcommand{\ocaml}{\mbox{\sf ocaml}}
  \newcommand{\ml}{\mbox{\sf ML}}
  \newcommand{\zope}{\mbox{\sf Zope}}
  \newcommand{\hal}{\mbox{\sf HAL}}
  \newcommand{\actl}{{\sf Actl}}
  \newcommand{\jack}{{\sf Jack}}
  \newcommand{\atg}{{\sf Autograph}}
  \newcommand{\xmlrpc}{{\sf XML-RPC}}
  \newenvironment{mihda}[2]{\begin{center} \begin{boxedminipage}{#1}\small\sl }{\end{boxedminipage}\end{center}}
  \newenvironment{mihdanobox}[2]{\begin{center} \begin{minipage}{#1}\small\sl }{\end{minipage}\end{center}}



\newcommand{\sysset}{\mbox{}}
 \newcommand{\procset}{\mbox{}}
 \newcommand{\lprocset}{\mbox{}}
 \newcommand{\nprocset}{\mbox{}}
 \newcommand{\dotp}{\,.\,}
\newcommand{\outp}[2]{#1!#2}
 \newcommand{\inb}[2]{{#1}({#2})}
 \newcommand{\boutb}[2]{\overline{{#1}}({#2})}
 \newcommand{\outb}[2]{\bar{#1}\langle#2\rangle}
\newcommand{\join}{\mbox{{\tt join-calculus}}}
  \newcommand{\mmpi}{\mbox{-calculus}}
  \newcommand{\smallpi}{}
  \newcommand{\fn}[1]{\mathrm{fn}(#1)}
  \newcommand{\bn}[1]{\mathrm{bn}(#1)}
  \newcommand{\fv}[1]{\mathrm{fv}(#1)}
  \newcommand{\bv}[1]{\mathrm{bv}(#1)}
  \newcommand{\sbj}{\mathbf{s}}
\newcommand{\obis}{\sim}
  \newcommand{\rbis}{\bumpeq}
  \newcommand{\gbis}{\simeq}
  \newcommand{\synbis}{\backsimeq}

  \ifpar
    \newcommand{\n}[1]{\mathrm{n}(#1)}
  \else
    \DeclareMathOperator{\n}{\mathrm{n}}
  \fi
  \newcommand{\fcalc}{Fusion calculus}
  \newcommand{\match}[2]{[{#1} = {#2}]}
  \newcommand{\unmatch}[1]{\neg {#1}}


\newcommand{\bcalc}{}
  \newcommand{\bterms}{\mathcal{T}_\Omega}
  \newcommand{\binder}{\lambda}
  \newcommand{\void}{\bot}
  \newcommand{\prefvar}{\alpha}
  \newcommand{\chop}{+}
  \newcommand{\parop}{|}
  \newcommand{\fuse}[2]{\{{#1}={#2}\}}
  \newcommand{\oop}{!}
  \newcommand{\occurr}[2]{\oop^{\mbox{\tiny }}{#2}}
  \newcommand{\bact}[2]{{#1}\;{#2}}


\newcommand{\coaction}[1]{\overline{#1}}
  \newcommand{\user}[1]{U_{#1}}
  \newcommand{\router}[1]{R_{#1}}
  \newcommand{\server}{S}
  \newcommand{\remote}{rem}
  \newcommand{\ambu}{amb}
  \newcommand{\ract}[4]{({#1},({#2},{#3}),\conf{#4})}
  \newcommand{\idract}[1]{({#1},\uno,\conf{})}

  \newcommand{\Fin}{\mathit{Fin}}
  \newcommand{\shreq}{SHReQ}
  \newcommand{\Sync}{\mathit{Sync}}
  \newcommand{\reqset}{\mathcal{R}}
  \newcommand{\noSync}{\mathit{NoSync}}
  \newcommand{\production}[4]{{#1}\triangleright{#2}\tr{#3}{#4}}
  \newcommand{\prodset}{\mathcal{P}}
  \newcommand{\qprodset}{\mathcal{QP}}
  \newcommand{\actof}[1]{\mathfrak{s}{#1}}
  \newcommand{\nameof}[1]{\mathfrak{n}{#1}}
  \newcommand{\newof}[1]{\mathrm{new}({#1})}
  \newcommand{\mgu}[1]{\mathbf{mgu}({#1})}
  \newcommand{\syncact}[1]{\underline{#1}}
  \newcommand{\wfreq}[2]{{{#1}_{#2}}}
  \newcommand{\val}[1]{\mathcal{W}_{{#1}}}
  \newcommand{\meno}[2]{{#1}_{/{#2}}}
  \newcommand{\onlyon}[2]{({#1})|_{{#2}}}




\newcommand{\vs}[2]{{#2} \mbox{\scriptsize @} {#1}}
  \newcommand{\undef}[2]{{#1}({#2})\uparrow}
  \newcommand{\var}[1]{?#1}
\newcommand{\intruso}{\mathbf{I}}
  \newcommand{\secpair}[2]{#1 , #2}
  \newcommand{\gen}{\Join}
  \newcommand{\degen}[1]{\stackrel{#1}{\rightharpoondown}}
  \newcommand{\enc}[2]{\{#1\}_{#2}}
  \newcommand{\inv}[1]{{#1}^{-1}}
  \newcommand{\dec}{\}\{}
  \newcommand{\sm}{\underline{M}}
  \newcommand{\sx}{\underline{X}}
  \newcommand{\bx}[1]{\mathcal{B}(#1)}
  \newcommand{\hx}{\underline{\hat{X}}}
  \newcommand{\size}[1]{\#{#1}}
  \newcommand{\syntchk}[1]{[#1]}
\newcommand{\ide}[1]{\mbox{\tt #1}}
\newcommand{\ov}[1]{\mathrm{ov}(#1)}



\newcommand{\tarzan}{\mbox{\sf Tarzan}}



\newcommand{\strans}[1]{\xymatrix{\ar@{~>}[r]^{#1} &}}
  \newcommand{\dstrans}[1]{\xymatrix{\ar@{~>}[d]^{#1} \\ \ }}
  \newcommand{\redarrow}[1]{\succ\!\!\overstackrel{\rightarrowfill}{#1}}
  \def\sphline{\noalign{\vskip3pt}\hline\noalign{\vskip3pt}}
  \newcommand{\neigh}[2]{{#1;#2}}
  \newcommand{\Node}{\mbox{}}
  \newcommand{\ginfty}{G_\infty}
  \newcommand{\varset}{\mathcal{V}}
  \newcommand{\pvarset}{\mathcal{P}}
  \newcommand{\siteset}{\mathcal{S}}
  \newcommand{\sitevar}{\mathcal{N}}
  \newcommand{\tuplemv}{\mathfrak{t}}
  \newcommand{\rights}{\mathcal{R}}
  \newcommand{\costset}{\mathcal{C}}
  \newcommand{\linkset}{\mathcal{L}}
  \newcommand{\barb}[2]{{#1}\!\!\downarrow_{#2}}
  \newcommand{\newl}[2]{\mbox{}}
  \newcommand{\news}[2]{node_{#2}\conf{#1}}
  \newcommand{\newsitename}{node}
  \newcommand{\newsite}[3]{\newsitename_{#1}^{#2}\conf{#3}}
  \newcommand{\dtc}[2]{\delta_{#1}\,{#2}}
  \newcommand{\caos}{{\sc Kaos}}
  \newcommand{\cpb}{\kappa}
  \newcommand{\mucaos}{{}}
  \newcommand{\site}[3]{{#1}::_{#2}{#3}}
  \newcommand{\pequiv}{\equiv_P}
  \newcommand{\ptrans}[3]{{#1}\tr{#2}{#3}}
  \newcommand{\ntrans}[4]{{#1} \partarrow{#2}{{#3}} {#4}}
  \newcommand{\ntransname}{\partarrow{}{}}
  \newcommand{\pama}[2]{\subs{{#1}}{#2}}
  \newcommand{\mumatch}{\bowtie}
  \newcommand{\addr}{\mathtt{addr}}


  \newcommand{\comment}[1]{}
  \iftesi
    \newcommand{\mmaccept}{{\bf accept}}
    \newcommand{\mmout}{{\bf out}}
    \newcommand{\mmlogin}{{\bf login}}
  \else
    \newcommand{\mmaccept}[2]{\mathbf{accept}(\link{#1}{#2})}
    \newcommand{\mmout}[1]{\conf{#1}}
    \newcommand{\mmlogin}[2]{\mathbf{link}(\link{#1}{#2})}
  \fi
  \newcommand{\lnk}[3]{{#1} \overstackrel{\frown}{#2} {#3}}
  \newcommand{\cnt}[2]{con_{#2}\conf{#1}}
  \newcommand{\lft}[2]{con_{#2}\conf{#1}}
  \newcommand{\rgt}[2]{acc_{#2}\conf{#1}}
  \newcommand{\verso}[3]{{#1}_{{#2},{#3}}}
  \renewcommand{\neigh}[1]{{#1}}
  \newcommand{\klaimu}{\caos}
  \newcommand{\emptynet}{\mathbf{0}}
  \newcommand{\emptyptr}{\varepsilon}
  \newcommand{\link}[2]{{#1}_{#2}}
  \newcommand{\linklab}[2]{{#1}\;link\;{#2}}
  \newcommand{\disclab}[2]{{#1}\ disc\conf{#2}}
  \newcommand{\cntlab}[3]{{#1}\ con_{#2}\conf{#3}}
  \newcommand{\lftlab}[3]{{#1}\ con_{#2}\conf{#3}}
  \newcommand{\rgtlab}[3]{{#1}\ acc_{#2}\conf{#3}}
  \newcommand{\evallab}[5]{{#1}\ \mmeval^{#2}_{#3}\conf{#4}@{#5}}
  \newcommand{\linkadd}[2]{\uplus\link{#1}{#2}}
  \newcommand{\from}[1]{\mathbf{from}({#1})}
  \newcommand{\ptype}{T}
  \newcommand{\detc}[1]{\mathbf{disc}\conf{#1}}
  \newcommand{\evlab}[3]{{#1}[{#2}]@{#3}}
  \newcommand{\costs}[3]{\mathcal{P}_{#1}({#2},{#3})}
  \newcommand{\diverge}{\setminus}





\newcommand{\nredli}[4]{\mbox{}}
\newcommand{\nredac}[4]{\mbox{}}
\newcommand{\che}[1]{\mbox{\sc #1}}
\newcommand{\eqv}{\simeq_{\mbox{\tiny }}}
\newcommand{\resf}[2]{#1_{\mbox{\tiny }}}
\newcommand{\newredlo}[3]{\mbox{}}
\newcommand{\newreddis}[3]{\mbox{}}


\newcommand{\conf}[1]{\langle {#1} \rangle}
\newcommand{\defi}{\stackrel{\mathrm{def}}{=}}    \newcommand{\self}{{\tt self}}
\newcommand{\prlaw}[1]{(\mbox{{\sc #1}})}
\newcommand{\Klava}{{\sf Klava}}
\newcommand{\java}{{\sf Java}}
\newcommand{\dotnet}{{\sf .NET}}
\newcommand{\wt}{\widetilde}
\newcommand{\Cpro}{\Psi}
\newcommand{\sep}{\;\;\mid\;\;}
\newcommand{\ippar}{\;\mid\!\mid\;}
\newcommand{\ppar}{\;\;\mid\;\;}
\iftesi
  \newcommand{\mmeval}{{\bf eval}}
\else
  \newcommand{\mmeval}{\varepsilon}
\fi
\newcommand{\spawn}[3]{\varepsilon_{#1}[{#2}]\mbox{\scriptsize @}{#3}}
\newcommand{\spawnlab}[2]{{#1}@{#2}}
\newcommand{\mmread}{{\bf read}}
\newcommand{\valt}[1]{\mbox{}}
\newcommand{\mmdcl}{{\bf declare}}
\newcommand{\mmin}{{\bf in}}
\newcommand{\mmrec}{{\bf rec}}
\newcommand{\mmnew}{{\bf new}}
\newcommand{\linedge}{\lambda}
\newcommand{\mmlogout}{{\bf logout}}
\newcommand{\mmdisc}[1]{{\bf disc}(#1)}
\newcommand{\Sp}{\mathbb{P}}
\newcommand{\Sa}{\mathbb{A}}
\newcommand{\mmbind}{{\bf bind}}
\newcommand{\mmnil}{{\bf 0}}
\newcommand{\rulelab}[1]{\mbox{\scriptsize #1}}
\newcommand{\rulelabel}[1]{(\textsc{#1})}
\newcommand{\globrulelabel}[1]{\rulelabel{N#1}}
\newcommand{\mmnnet}{{\bf 0}}
\newcommand{\labset}{\mbox{}}
\newcommand{\labb}[2]{\mbox{}}
\newcommand{\nodeset}{\mbox{}}
\newcommand{\judg}[2]{#1 \vdash #2}
\newcommand{\ktrans}[3]{\mbox{}}
\newcommand{\gtrans}[4]{\mbox{}}
\newcommand{\irule}[2]{
   \begin{array}{c}
       #1  \\ \hline
       #2
    \end{array}}
\newcommand{\res}{\mbox{}}
\newcommand{\trd}[2]{\mbox{}}
\newcommand{\trdp}[3]{\mbox{}}
\newcommand{\parnet}{\mbox{}}
\newcommand{\mmnewl}{{\bf newloc}}
\newcommand{\mmlin}{{\bf login}}
\newcommand{\mmacc}{{\bf accept}}
\newcommand{\mmlout}{{\bf logout}}

\newcommand{\newrednl}[3]{\mbox{\small }}
\newcommand{\newredb}[3]{\mbox{\small }}
\newcommand{\newredr}[3]{\mbox{\small }}
\newcommand{\newredo}[1]{\mbox{\small }}
\newcommand{\newredi}[3]{\mbox{\small }}
\newcommand{\newredev}[3]{\mbox{\small }}

\newcommand{\action}[1]{#1}\newcommand{\alab}{a}
\newcommand{\definedas}{\ensuremath{\stackrel{\textit{def}}{=}}}

\newcommand{\names}{\mbox{}}
\newcommand{\namestar}{\mbox{}}
\newcommand{\Sites}{\mathcal{S}}
\newcommand{\sedge}[1]{\mathfrak{S}_{#1}}


\newcommand{\pia}{\mbox{-agents}}
\newcommand{\Klaim}{{\sc Klaim}}
\newcommand{\qlaim}{{\sc Qlaim}}
\newcommand{\XKlaim}{{\sc X-Klaim}}
\newcommand{\lps}{\mbox{}}
\newcommand{\lab}[1]{\mbox{\small\tt #1}}

\ifarticle
  \newtheorem{theorem}{Theorem}[section]
  \newtheorem{definition}{Theorem}[section] 
  \newtheorem{proposition}{Theorem}[section] 
  \newtheorem{lemma}{Theorem}[section]
  \newtheorem{corollary}{Theorem}[lemma] 
  \newtheorem{remark}{Theorem}[section]
  \newtheorem{observation}{Theorem}[section]
  \newtheorem{notation}{Theorem}[section]
  \newtheorem{example}{Theorem}[section]
\else
  \ifthm
\else
    \newtheorem{theorem}{Theorem}[section]
    \newtheorem{definition}{Definition}[section] 
    \newtheorem{proposition}{Proposition}[section] 
    \newtheorem{lemma}{Lemma}[section]
    \newtheorem{corollary}{Corollary}[lemma] 
    \newtheorem{remark}{Remark}[section]
    \newtheorem{observation}{Observation}[section]
    \newtheorem{notation}{Notation}[section]
    \newtheorem{example}{Example}[section]
  \fi
\fi




\ifpar
\else
\newcommand{\defeq}{\mathrel{\mathop{=}\limits^{\rm def}}}
\fi
\newcommand{\trar}{\longrightarrow}
\newcommand{\mydeduce}[2]{\frac{\displaystyle #1}{\displaystyle #2}}
\newcommand{\ident}[1]{\textsc{[#1]}}
\newcommand{\orbar}{\:\mathrel{\big|}\:}
\newcommand{\as}{\:\mathrel{::=}\:}
\newcommand{\Names}{\mathfrak{N}}
\newcommand{\Var}{\mathit{Var}}
\newcommand{\nil}{\mathbf{0}}
\newcommand{\respi}[1]{(\pmb{\nu} #1)\,}
\newcommand{\relfont}{\mathcal}
\newcommand{\Rrel}{\mathrel{\relfont{R}}}
\newcommand{\pto}{\rightharpoonup}
\newcommand{\ns}[2]{{#1}: {#2} \to \nat}
\newcommand{\nsq}[1]{Q_\nset{#1}}
\newcommand{\nsw}[2]{\weight{#1}_{\nset{#2}}}
\newcommand{\nssubset}{\sqsubseteq}
\newcommand{\nscup}{\sqcup}
\newcommand{\nscap}{\sqcap}
\newcommand{\nstimes}{\otimes}
\newcommand{\nsto}{\to \mkern-20mu \leftharpoondown}
\newcommand{\Fun}{\texttt{Fun}}


\newcommand{\ori}[1]{\mathbf{#1}}



\def \overunderstackrel#1#2#3{\mathrel{\mathop{#1}\limits^{#2}_{#3}}}
\def \overstackrel#1#2{\mathrel{\mathop{#1}\limits^{#2}}}
\def \understackrel#1#2{\mathrel{\mathop{#1}\limits_{#2}}}

\newcommand{\conslab}{{\mathit{Cons}}}
\newcommand{\group}[1]{{\mathcal{G}}_{#1}}
\newcommand{\cardinal}[2]{{\mod {#1}}_{#2}}
\newcommand{\varst}[1]{\ensuremath{\{v_{1}..v_{\mod{#1}}\}}}
\newcommand{\varpe}[2]{\ensuremath{\{#1\}_{#2}}}
\newcommand{\parti}[1]{\ensuremath{\mathcal{P}(#1)}}
\newcommand{\partif}[1]{\ensuremath{\mathcal{P}_{f}(#1)}}
\newcommand{\fpart}[1]{\ensuremath{\mathcal{P}_{\omega}\ {#1}}}
\newcommand{\fun}[3]{\ensuremath{#2\stackrel{#1}{\longrightarrow}#3}}
\newcommand{\funp}[3]{\ensuremath{#2\stackrel{#1}{\rightharpoonup}#3}}
\newcommand{\poli}[3]{\ensuremath{\prod_{#1:#2}{#3}}}
\newcommand{\polim}[3]{\ensuremath{\displaystyle \prod_{#1:#2}{#3}}}
\newcommand{\tsum}[3]{\ensuremath{\displaystyle \sum_{#1:#2}#3}}
\newcommand{\capp}[1]{\ensuremath{\widehat{#1}}}
\iftesi
  \newcommand{\quadr}[4]{\ensuremath{\conf{#1,#2,#3,#4}}}
\else
  \newcommand{\quadr}[4]{\ensuremath{\conf{#4,#1,#2,#3}}}
\fi
\newcommand{\quadri}[1]{\ensuremath{\conf{\ell_{#1},\pi_{#1},\sigma_{#1},q_{#1}}}}
\newcommand{\tripli}[1]{\ensuremath{\conf{\ell_{#1},\pi_{#1},\sigma_{#1}}}}
\newcommand{\modb}[1]{\ensuremath{\lfloor#1\rfloor}}
\newcommand{\varb}[1]{\ensuremath{\{\!\mid\!#1\!\mid\!\}}}
\newcommand{\qdn}[2]{\ensuremath{(\!\mid \!#1\! \mid\!)_{#2}}}
\newcommand{\eqnf}{\overline{\sim}}
\newcommand{\leqnf}{\preceq}
\newcommand{\leqn}{\leq}
\newcommand{\leqns}{\lesssim}
\newcommand{\leqd}{\sqsubseteq}
\newcommand{\leqb}{\precsim}
\newcommand{\leqfn}{\unlhd}





\newcommand{\ext}[2]{[^{#1}/_{#2}]}
   \newcommand{\ain}[1]{\mbox{\em in }}
   \newcommand{\aout}[1]{\mbox{\em out }}
   \newcommand{\open}[1]{\mathit{open}\:#1}
   \newcommand{\Amb}{\mbox{{\tt Ambient}}}
   \newcommand{\ambient}{\mbox{{\tt Ambient}}}
\newcommand{\mvin}[1]{\mbox{\em mv in }}
   \newcommand{\mvout}[1]{\mbox{\em mv out }}
   \newcommand{\ambupdown}{\mbox{}}
   \newcommand{\ambup}{\mbox{}}
   \newcommand{\ambdown}{\mbox{}}


\newcommand{\msgset}{\mbox{}}
\newcommand{\txtset}{\mbox{}}
\newcommand{\keyset}{\mbox{}}
\newcommand{\ind}[1]{\mbox{{\sl index}}}
\newcommand{\trm}[1]{\mbox{{\sl term}}}
\newcommand{\abs}[1]{\mbox{{\sl abs}}}
\newcommand{\ptr}[1]{\mbox{{\tt #1}}}


\newcommand{\redlabel}[4]{\ensuremath{\mathbf{#1}(#2,#3,#4)}}
\newcommand{\redev}[3]{\mbox{}}
\newcommand{\redlo}[3]{\mbox{}}
\newcommand{\reddis}[3]{\mbox{}}
\newcommand{\redi}[3]{\mbox{}}
\newcommand{\redr}[3]{\mbox{}}
\newcommand{\rednl}[3]{\mbox{}}




\newcommand{\Q}{{\cal Q}}
\newcommand{\pardeg}{\mathop{\mathrm{deg}}}













\newcommand{\csemvar}{\mbox{}}
\newcommand{\csemleq}{\leq_A}



\newcommand{\sidebyside}[2]{
    \begin{tabular}{ll}
      \begin{minipage}{.5\linewidth} {#1}  \end{minipage}
      &
      \begin{minipage}{.5\linewidth} {#2}  \end{minipage}
    \end{tabular}
}


\newcommand{\obj}[1]{\left|#1\right|}
\newcommand{\homset}[3]{#1\left[#2,#3\right]}
\newcommand{\source}{source}
\newcommand{\target}{target}
\newcommand{\PB}{PB}
\newcommand{\PO}{PO}
\newcommand{\mC}[1]{\mathbf{#1}}
\newcommand{\Fam}[1]{\mC{Fam}(#1)}
\newcommand{\C}{\mC{C}}
\newcommand{\A}{\mC{A}}
\newcommand{\B}{\mC{B}}
\newcommand{\Symset}{\mC{Symset}}
\newcommand{\SSO}{\Symset^{\omega}}
\newcommand{\Set}{\mC{Set}}
\newcommand{\I}{\mC{I}}
\newcommand{\schtop}{\mC{Sh(\I^{op})}}
\newcommand{\F}{\mC{F}}
\newcommand{\NSet}{\mC{NSet}}
\newcommand{\FSAlg}{\mC{FSAlg^{\pi}}}
\newcommand{\Coalg}[1]{\mC{Coalg(#1)}}
\newcommand{\ShI}{\mC{Sh(I)}}

\newcommand{\mF}[1]{\mathbf{#1}}
\newcommand{\fF}{\mF{F}}
\newcommand{\fG}{\mF{G}}
\newcommand{\fT}{\mF{T}}
\newcommand{\fH}{\mF{H}}
\newcommand{\fP}{\mF{P}}
\newcommand{\fS}{\mF{S}}
\newcommand{\fU}{\mF{U}}

\newcommand{\Autf}{\mathit{Autf}}
\newcommand{\fs}{\mathit{fs}}
\newcommand{\palg}[2]{\langle#1,\left\{#2\right\}  \rangle}
\newcommand{\orbcr}[1]{\mathit{Rep}(#1)}
\newcommand{\gfix}{\mathit{gfix}}
\newcommand{\fix}{\mathit{fix}}
\newcommand{\grp}{\mathit{Grp}}
\newcommand{\sym}{\mathit{Sym}\,}
\newcommand{\swap}[2]{\sigma^{(#1,#2)}}
\newcommand{\old}{old}
\newcommand{\hidden}[1]{hid^{#1}}
\newcommand{\reveal}[2]{#1\circledR#2}
\newcommand{\bind}[3]{\lambda_{#1}#2.#3}

\newcommand{\nsym}{\mathtt{G}}
\newcommand{\nsupp}[1]{\left\Vert #1\right\Vert }
\newcommand{\completion}[1]{#1^{c}}

\newcommand{\out}[2]{\overline{#1}#2}
\newcommand{\binp}{\mathit{binp}}
\newcommand{\inp}{\mathit{inp}}

\newcommand{\Nat}{\mathbb{N}}
\newcommand{\subarg}[2]{^{#1}/_{#2}}
\newcommand{\sub}[2]{\left[\subarg{#1}{#2}\right]}
\newcommand{\modulus}[2]{#1/_{#2}}
\newcommand{\class}[1]{[#1]}
\newcommand{\parts}{\mathcal{P}}
\newcommand{\pfin}{\parts_{\mathit{fin}}}
\newcommand{\pcnt}{\parts_{\mathit{cnt}}}
\newcommand{\card}[1]{\left|#1\right|}
\newcommand{\toinj}{\stackrel{inj}{\to}}
\newcommand{\dom}[1]{\mathit{dom}(#1)}
\newcommand{\cod}[1]{\mathit{cod}(#1)}
\newcommand{\im}{\mathit{Im}}
\newcommand{\restr}[1]{_{\mid_{#1}}}
\newcommand{\labels}{\mathcal{L}}
\newcommand{\mcl}{MCL}
\newcommand{\MCP}{MCL}
\newcommand{\inj}{\mathit{in}}
\newcommand{\tuple}[1]{\langle#1\rangle}
\newcommand{\hdtr}[3]{\tuple{#2,#1,#3}}
\newcommand{\copair}[2]{\left[#1;#2\right]}
\newcommand{\sem}[1]{\left\llbracket #1\right\rrbracket }
\newcommand{\nset}[1]{#1^{\mathfrak{N}}}
\newcommand{\norm}[1]{\mathit{Norm}\, #1}
\newcommand{\new}{\reflectbox{\ensuremath{\mathsf{N}}}}
\newcommand{\mtrue}{\mathit{true}}
\newcommand{\terminal}{\mathbf{1}}
\newcommand{\discharger}[1]{\mathbf{!}_{#1}}
\newcommand{\two}{\mathbf{2}}
\newcommand{\SO}{\mathit{\mathcal{SO}}}
\newcommand{\FV}{\mathit{FV}}
\newcommand{\Eq}{\mathit{Eq}}
\newcommand{\subs}[2]{\mathit{sub}^{(#1,#2)}}
\newcommand{\fixsigma}[3]{\mathit{Fix}^{#1}_{#2,#3}}
\newcommand{\objSS}{\Phi}
\newcommand{\arrSS}{F}
\newcommand{\clos}{\mathit{clos}}
\newcommand{\fin}{\mathit{fin}}
\newcommand{\fr}{\mathit{fr}}
\newcommand{\tr}[1]{\xrightarrow{#1}}






\newcommand{\bbtwo}{\mathbbm{2}}

\newcommand{\abb}{{\ensuremath{\mathbb{ A}}} }
\newcommand{\bbb}{{\ensuremath{\mathbb{ B}}} }
\newcommand{\cbb}{{\ensuremath{\mathbb{ C}}} }
\newcommand{\dbb}{{\ensuremath{\mathbb{ D}}} }
\newcommand{\ebb}{{\ensuremath{\mathbb{ E}}} }
\newcommand{\fbb}{{\ensuremath{\mathbb{ F}}} }
\newcommand{\ibb}{{\ensuremath{\mathbb{ I}}} }
\newcommand{\jbb}{{\ensuremath{\mathbb{ J}}} }
\newcommand{\lbb}{{\ensuremath{\mathbb{ L}}} }
\newcommand{\lbbc}{{\ensuremath{\mathbb{ L}_C}} }
\newcommand{\lbbd}{{\ensuremath{\mathbb{ L}_D}} }
\newcommand{\mbb}{{\ensuremath{\mathbb{ M}}} }
\newcommand{\nbb}{{\ensuremath{\mathbb{ N}}} }
\newcommand{\pbb}{{\ensuremath{\mathbb{ P}}} }
\newcommand{\rbb}{{\ensuremath{\mathbb{ R}}} }
\newcommand{\qbb}{{\ensuremath{\mathbb{ Q}}} }
\newcommand{\sbb}{{\ensuremath{\mathbb{ S}}} }
\newcommand{\xbb}{{\ensuremath{\mathbb{ X}}} }
\newcommand{\ybb}{{\ensuremath{\mathbb{ Y}}} }
\newcommand{\zbb}{{\ensuremath{\mathbb{ Z}}} }


\newcommand{\acal}{\mathcal{ A}}
\newcommand{\bcal}{\mathcal{ B}}
\newcommand{\ccal}{\mathcal{ C}}
\newcommand{\dcal}{\mathcal{ D}}
\newcommand{\ecal}{\mathcal{ E}}
\newcommand{\fcal}{\mathcal{ F}}
\newcommand{\gcal}{\mathcal{ G}}
\newcommand{\hcal}{\mathcal{ H}}
\newcommand{\ical}{\mathcal{ I}}
\newcommand{\jcal}{{\mathcal J}}
\newcommand{\kcal}{{\mathcal K}}
\newcommand{\lcal}{\mathcal{ L}}
\newcommand{\mcal}{\mathcal{ M}}
\newcommand{\ncal}{\mathcal{ N}}
\newcommand{\ocal}{\mathcal{ O}}
\newcommand{\pcal}{\mathcal{ P}}
\newcommand{\qcal}{\mathcal{ Q}}
\newcommand{\rcal}{\mathcal{ R}}
\newcommand{\scal}{\mathcal{ S}}
\newcommand{\tcal}{\mathcal{ T}}
\newcommand{\ucal}{\mathcal{ U}}
\newcommand{\vcal}{\mathcal{ V}}
\newcommand{\wcal}{\mathcal{ W}}
\newcommand{\xcal}{\mathcal{ X}}
\newcommand{\ycal}{\mathcal{ Y}}
\newcommand{\zcal}{\mathcal{ Z}}


\newcommand{\Asf}{\mathsf{A}}
\newcommand{\Bsf}{\mathsf{B}}
\newcommand{\Csf}{\mathsf{C}}
\newcommand{\Dsf}{\mathsf{D}}
\newcommand{\Esf}{\mathsf{E}}
\newcommand{\Fsf}{\mathsf{F}}
\newcommand{\Gsf}{\mathsf{G}}
\newcommand{\Ksf}{\mathsf{K}}
\newcommand{\Psf}{\mathsf{P}}
\newcommand{\Ssf}{\mathsf{S}}
\newcommand{\Tsf}{\mathsf{T}}
\newcommand{\Xsf}{\mathsf{X}}
\newcommand{\Zsf}{\mathsf{Z}}

\newcommand{\esf}{\mathsf{e}}
\newcommand{\isf}{\mathsf{i}}
\newcommand{\ssf}{\mathsf{s}}
\newcommand{\tsf}{\mathsf{t}}

\DeclareMathOperator{\neww}{\new}


\usepackage{url}
\urldef{\mailsa}\path|{kurz, tomoyuki.suzuki, emilio}@mcs.le.ac.uk|
\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

\begin{document}

\mainmatter  

\title{Towards Nominal Formal Languages \\ (long version)}

\titlerunning{Towards Nominal Formal Languages}

\author{Alexander Kurz \and Tomoyuki Suzuki\thanks{The author's PhD research is supported by Yoshida Scholarship Foundation.} \and Emilio Tuosto}
\authorrunning{A.~Kurz, T.~Suzuki and E.~Tuosto}


\institute{Department of Computer Science, University of Leicester, UK
}



\toctitle{Lecture Notes in Computer Science}
\tocauthor{Authors' Instructions}
\maketitle

\begin{abstract}
  We introduce formal languages over infinite alphabets where words
  may contain binders. We define the notions of nominal language,
  nominal monoid, and nominal regular expressions.  Moreover, we
  extend history-dependent automata (HD-automata) by adding stack, and
  study the recognisability of nominal languages.
\comment{
  Finally, we show how our framework can be used to model
  correctness of a cryptographic protocol models in a -like
  calculus.
}

\end{abstract}


\section{Introduction}

Automata over infinite alphabets have been receiving an increasing
amount of attention, see eg
\cite{kaminskifrancez94,segoufin:csl06,bojanczyk:stacs11,tze11}. In
these approaches, the countably infinite alphabet  can be
considered as a set of `names', which can be tested only for
equality. Typically, languages of interest such as

from \cite{kaminskifrancez94} are invariant under name-permutations:
If eg  is in the language, then so is ,
where  stands for the application of the transposition
 to the word . This suggests to think of the names as
being bound and languages to be closed under -equivalence. On
the other hand, we may fix a name  and consider the language

from \cite{tze11}; we can think of  as a free name and of the
 as bound. This suggests to study not only words over
names, but also words which contain binders and allow us to make
explicit the distinction between bound and free names. Automata on
words with binders already appear in \cite{stirling:fossacs09} in the
study of the -calculus. \emph{In this paper we begin the
  systematic study of words with binders from the point of view of the
  classical theory of formal languages and automata.}

\medskip\noindent In particular, our contributions are:
\begin{itemize}
\item \emph{nominal languages} of words with binders
  (\S~\ref{sec:nomlang}) as a natural generalisation of formal
  languages over infinite alphabets;
\item \emph{nominal monoids} (\S~\ref{sec:nom-monoid}) as the
  corresponding algebraic structures;
\item \emph{nominal regular expressions} (\S~\ref{nomre:sec}) as a
  generalisation of regular expressions;
\item \emph{HD-automata with stack} (\hdns) (\S~\ref{sec:hdns}) and
  Theorem~\ref{thm:hdnsnre} showing that nominal regular expressions
  can be faithfully encoded into \hdns.
\end{itemize}

\noindent One of the motivations to study words with binders comes
from verification. For instance, consider the Needham-Schroeder
protocol

The (correct) runs of the protocol can be characterised by a nominal
regular expression

where the alphabet is now  with 
and  a finite set of
`letters'; finally,  binds all the free
occurrences of  in  and \emph{generates a fresh name} .
From~(\ref{equ:ns}) one could obtain an \hdns\ for monitoring the
execution of a protocol, i.e.\ the \hdns\ would be able to detect if
something goes wrong during the execution (e.g., an intruder is
performing an attack). From an automata theoretic point of view, the
interesting new feature appears more clearly if we abstract
(\ref{equ:ns}) to

and note that binding (fresh name generation) 
appears under the Kleene star, which is the reason why automata
accepting such languages need to have a stack.

\section{Nominal Languages}\label{sec:nomlang}
\newcommand{\letters}{\mathcal{S}}
\newcommand{\mwords}{\mathbf{M}}
\newcommand{\gwords}{\mathbf{G}}
\newcommand{\lwords}{\mathbf{L}}
\newcommand{\swords}{\mathbf{S}}
\newcommand{\sltr}{\mathrm{sl}}
\newcommand{\lgtr}{\mathrm{lg}}
\newcommand{\gmtr}{\mathrm{gm}}
\newcommand{\mpwtr}{f_\mwords}



We introduce languages with name binders. This section appeals to our
intuitive understanding of binding and -equivalence as known
from eg -calculus or first-order logic, but see the next
section for a formal treatment.
To start with, the \emph{alphabet} is divided disjointly into a
countably infinite set  (of \emph{names}) and a finite set
 (of \emph{letters}).

\begin{definition}[m-word]
  An \emph{m-word} is a term built from constants
  , and two binary operations
  , according to

where  ranges over  and  over . We denote by
 the set of all m-words.
\end{definition}
As in the classical case we assume that  (the empty word)
is the neutral element wrt  and that  is associative. We
often write  for the concatenation . Furthermore, we let
 bind the free occurrences of  in  and take
m-words up to -equivalence.

The notion of m-word is the \emph{m}ost general notion of word with
binders: We only require from words to form a monoid and behave well
wrt -equivalence. Due to the scope introduced by binding,
words now have a tree structure. This motivates the following, more
special, but perhaps more naturally \emph{g}eneralised, notion of
words.
\begin{definition}[g-word]
  A \emph{g-word} is a term built from , unary operations
  ,  for each , and a binary operation
  , according to

We denote by  the set of all g-words.
\end{definition}
Regarding binding and -equivalence, we follow the same
conventions as for m-words. To consider  as a monoid, we
define  as
follows:

where  is fresh for  and  is an
-renaming of .
Intuitively speaking, we extrude the scope of the binding to the end
of the word.

Next we allow binders to appear only at the beginning of a word.
\begin{definition}[l-word]
  An \emph{l-word} is a pair  where  and
  . We denote by  the set
  of all l-words.
\end{definition}
We interpret  as a prefix of name binders and  as the part of
the word that has no binders.
 is given
on the left below 

where we assume that  and ,  and , and  and  have no
names in common.
Whereas previously name-binding was built into the syntax via , we now define explicitly, anticipating notation from
\S~\ref{sec:nom-monoid}, a binding operation  via the clause on the right of
\eqref{equ:l-concat-binding}.

\begin{definition}[s-word]
  An \emph{s-word} is a pair  where
   and  is a subset of the
  names appearing in . We denote by  the set of all
  s-words.
\end{definition}
On , we define the two operations  and  as
follows, assuming that  and ,  and ,  and  have no
names in common.



\begin{remark}\label{rmk:slgm}
We have embeddings 
.
For  we assume that names are ordered; the other main clauses
are  and
.
\end{remark}



\section{Nominal monoids}\label{sec:nom-monoid}

The somewhat informal treatment of \S~\ref{sec:nomlang} should be
sufficient to understand how automata process words with binders in
\S~\ref{sec:hdns} and \S~\ref{sec:hsnre}. On the other hand, from a
conceptual point of view, it is important to have a unifying
account. The presence of names and binders suggests to employ nominal
sets \cite{gp02}. This not only provides us with a mathematical
theory, but also a clear conceptual guidance: Follow the classical
universal algebraic account of languages and automata, but replace
sets by nominal sets. Here, we apply this to languages and monoids.

Nominal sets and their logics come in different versions. We follow
\cite{gabb-math:nom-alg}, for which we need to refer to for
details. More details can also be found in \cite{kst10}. Let us just
recall

\begin{definition}[Nominal set]
  Denote by  the group of permutations of
   generated from the set of transpositions . A set  equipped with a
  -action  is a \emph{nominal set}, if
  every element in  is finitely supported. This means that for each
   there is finite set  (called a support of
  ) such that  for all
   (where  denotes the
  restriction of  to ). Maps between nominal sets are required
  to be equivariant, that is, they respect the permutation action.
\end{definition}
It follows 
that each element  has a minimal support  and one
writes  ( is \emph{fresh} for ) for
. This allows us to define abstraction \cite[Lemma
5.1]{gp02} as 
and 
.


A \textbf{nominal algebra} , see \cite[Def
4.13]{gabb-math:nom-alg}, consists of a nominal set , constants
, and a map . As in universal algebra,
further operations and equations may be added:
\begin{definition}
  A \emph{nominal monoid} is a nominal algebra  with
  additional constants  and (equivariant) operations
   so that  is a monoid.
\end{definition}
We say that  is \textbf{closed}, or that  contains no free
names, if  is empty. 
\begin{definition}
  Write  for the class of all nominal monoids.  We
  consider the following axioms where , ,
  and  are variables ranging over carriers of algebras.
       
  ,
  ,  are axiomatised by Ax1, Ax1-3,
  Ax1-5, respectively.
\end{definition}

\begin{remark}\label{rmk:axioms}
  One possible reading of the operations and the axioms is as
  follows. In , we have sequential composition ,
  allocation  of a resource named , and deallocation
  . In , we don't care about deallocation (garbage
  collection). In , the timing of the allocation does not
  matter and all resources may be allocated at the start. In
  , the order of allocation does not matter and the
  allocation of an unused resource is redundant.

  But other interpretations are possible. With  as the  of
  the -calculus and  as , Ax6 becomes the familiar
  law of scope extrusion. Interpreting  as , Ax4-5 are
  familiar laws of the universal quantifier. In \cite{pitts:popl10}, a
  binder satisfying Ax4-5 is called a name-restriction operator.
\end{remark}
We can now summarise the previous section conveniently in
Table~\ref{tb:axioms} and
\begin{theorem}\label{thm:monoids}
   are the initial monoids in,
  respectively, , , 
  and .
\end{theorem}
\begin{proof}
  The detailed proof can be found in~\cite{kst10}.
\qed
\end{proof}
\begin{table}[t]
\begin{center}
 \caption{Summary of nominal monoids and the axioms}
 \label{tb:axioms}
\begin{tabular}{|c|p{4cm}|c|p{3.6cm}|}
  \hline
  Classes & Axioms & Initial monoid & Typical example \\
  \hline 
   & &  &   \\
  \hline
   & Ax1 &  
   &  \\
  \hline
  & Ax1-3 
                   &  
                   &   \\
  \hline
  & Ax1-5
                   &  
                   & \\
  \hline
\end{tabular}
\end{center}
\end{table}
\begin{remark}\label{rmk:plain-words}
  We have a mapping  to
  \textbf{plain words} (ie words without binders) determined by
.
With the embedding  from
Remark~\ref{rmk:slgm} this induces a map  from languages
of s-words to subsets of , eg
.
\end{remark}

\section{Nominal Regular Expressions}\label{nomre:sec}

In analogy to the classical definition, we introduce \emph{nominal
  regular expressions}:

where  and .
The semantic interpretation  is defined as follows.
\begin{enumerate}
 \item , \qquad , \qquad , \qquad ,
 \item ,
 \item ,
 \item .
 \item , where ,
\end{enumerate}
\begin{remark}\label{rmk:nre}
      The definitions of  and  are dependent on the
      choice of row in Table~\ref{tb:axioms}, compare
      \eqref{equ:g-concat}, \eqref{equ:l-concat-binding},
      \eqref{equ:s-concat-binding}.
For example, on  we have

and on  we have
. From \S~\ref{sec:hdns}
onwards, we will interpret regular expressions in  only.
    \end{remark}


\begin{example}\label{exle:lang-bind}
  We have seen in \eqref{equ:ns2} how  arises from the Needham-Schroeder protocol.
In \S~\ref{sec:hsnre} we consider the simpler expression
   which intuitively represent the
  computations of a security protocol where (an unbound number of) new
  `nonces'  are generated within a session  and should always be
  paired up with .
\finex
\end{example}

We can also interpret nominal regular expressions in plain words. For
example, let  take values in  and let

denote the map of Remark~\ref{rmk:plain-words}.

\begin{example}\label{exle:tzev-lang}
  If we interpret  in  
  (or  or ) 
  we obtain the language
 
which is the complement of  from
\eqref{exle:lang-kf1}.  is not recognised by the FMAs
of \cite{kaminskifrancez94} but it is recognised by the FRAs of
\cite{tze11}. The latter notes that  shows that languages recognised by
FRAs are not closed under composition. On the other hand, the presence
of binders allows us to use  (respecting the 'hidden' binders)
instead of  and we obtain , where the second equality is our
definition of `nominal concatenation' on languages of
plain words. This indicates that even for languages without binders
the composition with binders is a natural concept.

Similarly, if we interpret  in 
we obtain another example of Tzevelekos:

\end{example}

\section{History-dependent Automata with Stack}\label{sec:hdns}
We build our nominal automata theory on \hda\ (after
\emph{history-dependent automata})~\cite{pis99}.
\hda\ are a computational model of nominal calculi defined on the
notion of \emph{named sets} and extend classical automata with finite
sets of names \emph{local} to states and transitions.
We equip \hda\ with stack; this renders them suitable for recognising
nominal languages interpreted in .
We argue that \hda\ are natural candidates to build a theory of
automata of nominal languages with binders.
In fact, they are equipped with mechanisms to capture name restriction
of nominal calculi~\cite{fmt05,fmtkv04,fmt03-b} and formally linked to
the nominal set theory in~\cite{gmm06,fs:cmcs04}.


Let  be a distinguished name; a \emph{stack}
 is a sequence of finite partial maps  (we use  to denote the empty map).
The empty stack is denoted by , a stack with head  is
written , and

respectively are the pop, pop twice, and top operations.

\begin{definition}[\cite{pis99}]\label{def:nset}
  A \emph{(basic) named set}  is a set 
  (of states) with a map  sending
   to a finite set of names  (called
  \emph{local names of }).
\end{definition}
\longversion{
  Basically, the elements  of a named set are equipped with a set
  of \emph{local} names .
}
Hereafter we omit subscripts when clear from the context and write a
named set  as , in which case
 is understood as the map of local names of ; also,
the \emph{update of a map  at  with } is the map


Before giving the formal definition, we intuitively present \hda\ with
stack.
A transition  from a state  consists of
the target state , a label , and a map  keeping
track of the correspondences of names.
Labels  can be a local name  of the source
state , letters , or any of the distinguished symbols

respectively representing internal transitions, push, pop, \emph{name
  allocation}, and \emph{name deallocation}.
Example~\ref{ex:hdns} gives a convenient graphical representation of
an \hdns.
\begin{example}\label{ex:hdns}
  Let , , and  be states with
  , , and
  .
The \hdns
  \begin{center}
    \begin{minipage}{\linewidth}\centering
      \includegraphics[scale=.4]{hdns}
    \end{minipage}
  \end{center}
has initial (resp. final) state 
  (resp. ).
Both  and  have a transition exposing
  their (unique) local name ( and 
  respectively).
Maps among local names are represented by dashed arrows.
Also,  has  transition to 
  with the empty map of local names.
\finex
\end{example}

\begin{definition}\label{def:hd-automaton}
  A (non-deterministic) \emph{history-dependent automaton with stack
    on } (\hdns) is a tuple
   where
  \begin{itemize}
  \item  is a named set of \emph{states} (the states of the
    automaton);
  \item  is the \emph{initial state};
  \item  is a partial function from  to
    ;
  \item  is the named set of \emph{final states}
    with  being the restriction of  to ;
  \item  is the \emph{transition function} returning for each
     a finite set  of \emph{transitions}, namely
    tuples  such that
    \begin{itemize}
    \item if  then 
    \item if  then 
    \item if  then 
    \item otherwise 
    \end{itemize}
    and, in either case,  is a partial injective map (see
    Remark~\ref{rmk:eta} on page~\pageref{rmk:eta}).
  \end{itemize}
\end{definition}
Transitions in Def~\ref{def:hd-automaton} allow \hdns\ to accept
names or letters or to manipulate the stack.
Besides the usual \emph{push} () and \emph{pop} ()
operations, \hdns\ feature allocation () and deallocation
() of names.

\begin{example}\label{hdns:ex}
  Let , .
The \hdns\ 
   where 
  
  formally defines the \hdns\ in Example~\ref{ex:hdns} (where 
  is not represented for simplicity).
\finex
\end{example}

We now define how \hds\ can recognise languages of .
Hereafter, we fix an \hdns

and, for any stack  and any name mapping , we define
 by

that basically updates  by post-composing its top map  (if any) with .
Note that this requires  to be updated to allow
composition when .

A \emph{configuration of } in~(\ref{eq:H}) is a triple
 where ,  is an , and  is
a stack.
Call \emph{initial} a configuration  and
\emph{accepting}  if .
\begin{definition}\label{def:hdstep}
  Given  and two configurations 
  and ,  in~(\ref{eq:H})
  \emph{moves from  to } (written )
  iff there is  such that
  either of the following cases applies
  

  The set  of states reached by 
  from  on  is defined as
  
  A \emph{run of  on an m-word } is a sequence of moves
  of  from .
\end{definition}
Intuitively, \hdns\ ``consume'' the word in input \emph{moving}
from one configuration to another (likewise classical automata).
However, when the current word starts with a name , the automaton
can progress only if the name ``is known''; namely, it is necessary to
find a transition from the current state  for which the stack maps
a local name of  to .

\hdns\ use a stack () to keep track of the names of the current
state and, noticeably, () to (de)allocate bound names in input
strings.
More precisely, a binder is consumed using a  transition
which updates the meaning of the names.
This is basically done by post-composing the mapping  in the
selected transition with the map on the top of the stack (opportunely
updated to take into account the allocation of ).
Instead, a  transition will pop the stack so reassigning
previous meanings to names in the current state by post-composing the
map  of the transition with ``the second one'' in the stack.

\longversion{
  An automaton  recognises  if it has a run from its
  initial state to a final state that consumes .
}
\begin{definition}\label{alang:def}
  The \hdns\  in~(\ref{eq:H}) \emph{accepts} (or
  \emph{recognises})  if .
The \emph{language of } (written ) is
  the set of words accepted by .
\end{definition}
\begin{example}
  If  is the \hdns\ in Example~\ref{hdns:ex} and , then .
\finex
\end{example}

Defs~\ref{def:hdstep} and~\ref{alang:def} contain some
subtleties worth spelling out.
First, observe that the language recognised by  depends on
 which intuitively sets the meaning of the local names of the
initial state ; instead, the language of  does not
depend on the identities of the local names of the states in .
Secondly, an alternative definition would allow the initial stack to
be empty and the correspondence between local names of the states of
 and those in the input word is incrementally built during
recognition.
This class of \hdns s would be equivalent to the one in
Defs~\ref{def:hd-automaton} and~\ref{def:hdstep}, but it would have
made our constructions more complex.
Finally, as for classical push-down automata, we could have
equivalently required that an \hdns\ recognises an m-word  only
when it has a run leading to a final state that consumes  and
empties the stack.
We opted for Def~\ref{alang:def} as it is conceptually simpler.
For instance, the following lemma (used to prove
Proposition~\ref{prop:H*}) states that only the top of the stack
is relevant for accepting words.
\begin{lemma}\label{lemma:top}
  Any configuration reachable by an \hdns\ as in~(\ref{eq:H}) from
   is also reachable from
   for any stack .
\qed
\end{lemma}

In \S~\ref{sec:hsnre} we show how a nominal regular expression  can
be mapped on an \hdns\  that recognises the language of
.
Theorem~\ref{thm:hdnsnre} is the main result
\begin{theorem}\label{thm:hdnsnre}
  For each nominal regular expression , 
  interpreted on .
\end{theorem}
\longversion{
  \begin{proof}
   The proof is by induction on the structure of .
The base cases are trivial while the other cases follow by
   Propositions~\ref{prop:hdsum}, \ref{prop:H1H2}, \ref{prop:H*},
   and~\ref{prop:[n]H}.
\qed
 \end{proof}
}

\section{\hdns\ and Nominal Regular Expressions}\label{sec:hsnre}
We use nominal regular expressions~(\ref{eq:nre}) to establish a
correspondence between \hdns\ and nominal formal languages.
More precisely, we give (Def~\ref{def:nretohdns}) the map mentioned in
Theorem~\ref{thm:hdnsnre} as the homomorphic image of nominal regular
expression on an algebra of \hdns\ given in the rest of this section.
\begin{definition}\label{def:nretohdns}
   The map  from nominal regular expressions to \hdns\
  is defined as:
  
  where the operations on \hdns\ in the last four cases are defined in
  the following.
\end{definition}
The operations on \hdns\ in Def~\ref{def:nretohdns} allow to combine
them so that the language of the resulting \hdns\ has a clear relation
with those the operations act upon as per
Propositions~\ref{prop:hdsum}, \ref{prop:H1H2}, \ref{prop:H*},
and~\ref{prop:[n]H} below.
Theorem~\ref{thm:hdnsnre} can be proved by induction on the structure
of nominal regular expressions using such propositions.
\begin{remark}\label{rmk:nretohdns}
  The map  in Def~\ref{def:nretohdns} depends
  on the choice of local names; however, as noted in
  \S~\ref{sec:hdns}, recognisability does not depend on the identity
  of such names.
\end{remark}

The first two clauses in Def~\ref{sec:hsnre} do not involve names and
stack.
Notably, the third clause states that the \hdns\ corresponding to an
expression  has simply a transition from the initial to accepting
state and in the initial configuration the unique name of the former
is mapped to .

The set  of \emph{(local) names} of an \hdns\
 as in~(\ref{eq:H}) is defined as .
In the following, we fix two \hdns

and, without loss of generality, we assume that 
and .

\begin{definition}\label{def:hdsum}
  Let  be a new state.
We define  to be the automaton
   where
  \begin{itemize}
  \item  where
     and 
  \item  and  for , where  is the identity from  to 
  \item , namely  if
    .
  \end{itemize}
\end{definition}
\begin{proposition}\label{prop:hdsum}
  
\end{proposition}
\longversion{
  \begin{proof}
    The statement trivially follows from Def~\ref{def:hdstep} as
    (i)
     has only two outgoing -transitions which lead
    to the initial states of either of  or 
    and (ii)
     preserves the name assignments  and .
    \qed
  \end{proof}
}

\begin{lemma}\label{lemma:uniquefinal}
  For each \hdns\  there is an \hdns\  with a
  unique final states and such that .
\end{lemma}
\longversion{
  \begin{proof}
    Given  in~(\ref{eq:H}) and  such
    that , we define  where
    ,  when restricted to
    , and  for each .
The proof that  is similar
    to the proof of Proposition~\ref{prop:hdsum}.
    \qed
  \end{proof}
}
Lemma~\ref{lemma:uniquefinal} allows, without loss of generality,
 in~(\ref{eq:H}) and each of  and  in~(\ref{twohdns:eq}) to have a single final state, namely ,  and , respectively.

The following construction extends the names of an \hdns\ without
altering its language and is used in Def~\ref{def:hdcomp}.
\begin{definition}\label{def:hdaddname}
  Given  as in~(\ref{eq:H}) and ,  is the \hdns\
  such that
  \begin{itemize}
  \item  is the named set having the same elements of  with
    
  \item  is the named set with the same states of  and
    
  \item 
  \item  is the partial
    map undefined on  and behaving as  otherwise.
  \end{itemize}
\end{definition}
Hereafter, we assume that 
when writing ; in fact, by the locality of the
names in the states of an \hdns, if  is a state of 
such that , we can replace  with any name not in
 by rearranging all the maps in the transitions reaching
.
\begin{lemma}\label{prop:hdaddname}
  .
\end{lemma}
\longversion{
\begin{proof}
  The proof that  is trivial as all the transitions of  have a
  correspondent in  with exactly the same labels
  and name mappings.
The converse also hold trivially as  cannot play any role in the
  recognition of a word in  as  is not
  defined on .
  \qed
\end{proof}
}

\begin{definition}\label{def:hdcomp}
  Let  and
  .
The \hdns\  is defined as
   where
   and
  
\end{definition}
The \hdns\  is built by
connecting the accepting state of  to , the
initial state of , after adding  to
.
Note that the newly introduced -transition maintains the
initial meaning of the names in  since 
acts as  on  (and by
Def~\ref{def:hdaddname}).
\begin{remark}\label{rmk:eta}
  A definition more complex than Def~\ref{def:hdcomp} can be given to
  preserve the injectivity of the initial mapping  when
   and  are injective.
This requires to relax the injectivity condition on  in
  Def~\ref{def:hd-automaton} requiring  for any .
We opted for the simpler Def~\ref{def:hdcomp} as it just allows more
  non-determism without altering the expressiveness of \hdns.
\end{remark}
\begin{proposition}\label{prop:H1H2}
  .
\end{proposition}
\longversion{
  \begin{proof}
    The automaton  reaches a final
    state iff  where  for
    .
In fact, to reach  it is necessary to reach 
    first and the unique transition from  to 
    maintains on the stack the meaning assigned to the names
     as per the stack.
\qed
  \end{proof}
}

\begin{definition}\label{def:H*}
  Let  be as in~(\ref{eq:H}) with .
The \hdns\  is such that
  
\end{definition}
The construction of  simply adds an
-transition from  (the initial state of )
to  (the accepting state of ) and a
-transition from  to  that re-establish the mapping
of the initial configuration preserving in the stack the meaning of
the names.
\begin{proposition}\label{prop:H*}
    
\end{proposition}
\longversion{
  \begin{proof}(Sketch.)
First, observe that trivially  because  has a
    transition  from .

    We now prove that .
If  then  reaches a configuration 
    for a suitable .
By construction and Def~\ref{def:hdstep}, 
    can visit  only a finite number of times .
Hence,  where  is the word
    processed between the -th visit of  and the previous visit
    of  (or of  if ).
    
    Observing that each visit of  is preceded by a visit of
     (since  can only be reached trough ), we have
    that  (and hence in ) because there  can be reached from the configuration
    .
For the same reason, we can conclude that  for each ; in fact, the
    -th visit of  yields  in the
    configuration 
    for some stack .
Hence, using the unique transition  from
    , the automaton ``resets'' to the configuration
    , which
    basically amounts to say that  can be recognised by  and the next work  is processed from a configuration
    where  is on the top of the stack and the thesis follows
    by Lemma~\ref{lemma:top}.

    We prove that .
Any word  has the form  where  for each , so we proceed  by induction on .
If  the thesis follows trivially.
If  then, from the configuration ,  reaches a
    configuration  since
     by hypothesis.
Since , the
    configuration  is reachable from .
Therefore,  reaches the configuration  which
    yields the thesis by Lemma~\ref{lemma:top}.
\qed
  \end{proof}
}

\begin{definition}\label{def:[n]H}
  Let ,  be as in~(\ref{eq:H}) with , and let  be new states with
   and
  .
The \hdns\  is such that
  
  where , if
  , otherwise .
\end{definition}

\begin{proposition}\label{prop:[n]H}
  .
\end{proposition}
\longversion{
\begin{proof}
  By construction, 
  reaches  iff there is a word  such that  and  reaches reaches  where
   is built as in Def~\ref{def:hdstep}.
Again by construction, this is possible iff  visits  and the last transition which consumes the
  word is a (deallocation) -transition from  to .
This is equivalent to say that there is 
  such that  which, by Remark\ref{rmk:nre}, yields
  the thesis.
\qed
\end{proof}
}



\section{Mapping Nominal Regular Expressions to \hdns}
We build the \hdns\  corresponding
to the expression  by applying the
constructions of \S~\ref{sec:hsnre}.
By Definition~\ref{def:nretohdns}, the \hdns\ corresponding to the
expression  is  with

where , ,
, , and .
Analogously, the \hdns\ corresponding to the expression  is  with

where , ,
, , and .

To compose  and , we first have to compute
; by Def~\ref{def:hdaddname},
 where  and


By Def~\ref{def:hdcomp},  where ,


We now build ; let
 and  be two new states with  and
, as prescribed by Def~\ref{def:[n]H}, we
have  where  and
 the initial setting  by restricting
 on , i.e.~;
moreover,


Further, by Def~\ref{def:H*},  is obtained
by adding two extra transitions  and .

Finally, by Def~\ref{def:hdcomp}, we obtain the \hds\  as follows.
First, let  be obtained as in~(\ref{eq:Hm})
by defining , , , , and .
Then, we set 
where  and



  \begin{center}
    \begin{minipage}{\linewidth}\centering
      \includegraphics[scale=.4]{hds}
    \end{minipage}
  \end{center}



We conclude with some final remarks.
Equivalent definitions could have been adopted; for instance, 
above is not required to be injective (adding some non-determinism in
Def~\ref{def:hdstep}) or some of the new states introduced by the
constructions above could be avoided to obtain more compact \hdns.
We decided to use conceptually simpler constructions instead of more
effective, but more complex ones.


\section{Conclusion}

This paper developed the beginnings of a general theory of words with
binders: nominal languages, nominal monoids, nominal regular
expressions, HD-automata with stacks. We sketch some further work.

Coming back to Table~\ref{tb:axioms} further classes maybe relevant,
for example words satisfying Ax4-5 but not Ax1-3; it will also be of
interest to mix different binders each obeying its own axioms plus
further axioms of their interaction.

HD-automata with stacks are more powerful than necessary if one is
only interested in recognising regular languages; a restricted class
of HD-automata characterising regular languages of m-words can be
described; the same should be done for g-words, l-words, and s-words.

We will also investigate the connections (cf.
Example~\ref{exle:tzev-lang}) of our nominal languages with languages
(on infinite alphabets) without binders~\cite{bojanczyk:stacs11,tze11,gabbayciancia,ct09}.


Further, closure properties and decidability results for these classes
of automata should be studied; for verification purposes deterministic
and minimal automata will be of interest. 

Last but not least, case studies showing the relevance of this line of
research to verification will have to be explored.

\bibliographystyle{abbrv}
\begin{thebibliography}{10}

\bibitem{bojanczyk:stacs11}
M.~Bojanczyk.
\newblock Data monoids.
\newblock In {\em STACS'11}.

\bibitem{ct09}
V.~Ciancia and E.~Tuosto.
\newblock A novel class of automata for languages on infinite alphabets.
\newblock Technical Report CS-09-003, Leicester, 2009.

\bibitem{fmt05}
G.~Ferrari, U.~Montanari, and E.~Tuosto.
\newblock {Model Checking for Nominal Calculi}.
\newblock In {\em FoSSaCS'05}.

\bibitem{fmt03-b}
G.~Ferrari, U.~Montanari, and E.~Tuosto.
\newblock {Coalgebraic Minimisation of HD-automata for the {}-Calculus in
  a Polymorphic {}-Calculus}.
\newblock {\em TCS}, 331, 2005.

\bibitem{fmtkv04}
G.~Ferrari, U.~Montanari, E.~Tuosto, B.~Victor, and K.~Yemane.
\newblock {Modelling and Minimising the Fusion Calculus Using HD-Automata}.
\newblock In {\em CALCO'05}.

\bibitem{fs:cmcs04}
M.~Fiore and S.~Staton.
\newblock {Comparing Operational Models of Name-Passing Process Calculi}.
\newblock {\em Inf. \& Comp.}, 204.

\bibitem{gabbayciancia}
M.~Gabbay and V.~Ciancia.
\newblock Freshness and name-restriction in sets of traces with names.
\newblock In {\em FoSSaCS'11}.

\bibitem{gp02}
M.~Gabbay and A.~Pitts.
\newblock A new approach to abstract syntax with variable binding.
\newblock {\em J. of Formal Aspects of Computing}, 13, 2002.

\bibitem{gabb-math:nom-alg}
M.~J. Gabbay and A.~Mathijssen.
\newblock Nominal (universal) algebra: Equational logic with names and binding.
\newblock {\em J. Log. Comput.}, 2009.

\bibitem{gmm06}
F.~Gadducci, M.~Miculan, and U.~Montanari.
\newblock About permutation algebras, (pre)sheaves and named sets.
\newblock {\em {Higher-Order and Symbolic Computation}}, 19, 2006.

\bibitem{kaminskifrancez94}
M.~Kaminski and N.~Francez.
\newblock Finite-memory automata.
\newblock {\em TCS}, 134, 1994.

\bibitem{kst10}
A.~Kurz, T.~Suzuki, and E.~Tuosto.
\newblock Nominal monoids.
\newblock Technical Report CS-10-004, Leicester, 2010.

\bibitem{pis99}
M.~Pistore.
\newblock {\em {History Dependent Automata}}.
\newblock PhD thesis, Dip. di Informatica - Pisa, 1999.

\bibitem{pitts:popl10}
A.~M. Pitts.
\newblock Nominal system {T}.
\newblock In {\em POPL'10}.

\bibitem{segoufin:csl06}
L.~Segoufin.
\newblock Automata and logics for words and trees over an infinite alphabet.
\newblock In {\em CSL'06}.

\bibitem{stirling:fossacs09}
C.~Stirling.
\newblock Dependency tree automata.
\newblock In {\em FoSSaCS'09}.

\bibitem{tze11}
N.~Tzevelekos.
\newblock Fresh-{R}egister {A}utomata.
\newblock In {\em POPL'11}.

\end{thebibliography}


\end{document}
