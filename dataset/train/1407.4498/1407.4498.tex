\def\conf{0}



\documentclass[11pt]{article}
\usepackage{enumerate}
\usepackage{comment}
\usepackage{url}
\usepackage{subfig}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{wrapfig}
\usepackage{graphicx}
\usepackage{paralist}
\usepackage[active]{srcltx}
\usepackage{algorithm}
\usepackage{fullpage}
\usepackage[english]{babel}
\newtheorem{theorem}{Theorem}
\newtheorem{rem}[theorem]{Remark}
\newtheorem{coro}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}




\newtheorem{observation}[theorem]{observation}
\newtheorem{defn}[theorem]{Definition}


\newcommand{\eps}{\varepsilon}
\newcommand{\route}{\text{\sc{ipp}}}
\newcommand{\IPP}{\route}
\newcommand{\MDPR}{\text{\sc{Mmega}}}
\newcommand{\INJECT}{\text{\sc{inject}}}
\newcommand{\flow}{\text{\emph{flow}}}
\newcommand{\poly}{\text{\emph{poly}}}
\newcommand{\source}{\text{\emph{source}}}
\newcommand{\target}{\text{\emph{target}}}
\newcommand{\demand}{\text{\emph{demand}}}
\newcommand{\reject}{\text{\emph{reject}}}
\newcommand{\opt}{\text{\textsc{opt}}}
\newcommand{\iopt}{I^*}
\newcommand{\pmax}{p_{\max}}
\newcommand{\pmaxst}{p_{\max}^{st}}
\newcommand{\ctr}{\text{ctr}}
\newcommand{\eqdf}{\triangleq}
\newcommand{\cube}{\text{\emph{cube}}}
\newcommand{\alg}{\text{\sc{alg}}}
\newenvironment{proof sketch}[1]{\noindent {\emph{Proof sketch of #1:}}}{\hfill \qed}
\newcommand{\cut}{\textit{cut}}
\newcommand{\diam}{\textit{diam}}
\newcommand{\dist}{\textit{dist}}

\newcommand{\far}{\text{\emph{Far}}}
\newcommand{\near}{\text{\emph{Near}}}
\newcommand{\algf}{\alg_{\far^+}}
\newcommand{\algn}{\alg_{\near}}
\newcommand{\RIPP}{\IPP(\far^+ \mid \pmax)}\newcommand{\RIPPt}{\IPP^{\lambda}}
\newcommand{\Rinj}{\RIPPt_{1/4}}
\newcommand{\algfar}{\algf}
\newcommand{\hl}{\tau}
\newcommand{\vl}{Q}


\begin{document} \title{Online Packet-Routing in Grids with Bounded Buffers \thanks{Preliminary
    versions of this manuscript appeared in the proceedings of ICALP
    2010~\cite{DBLP:conf/icalp/EvenM10} and SPAA 2011~\cite{DBLP:conf/spaa/EvenM11}.}
}

\author{Guy Even
\thanks{School of Electrical Engineering, Tel-Aviv Univ., Tel-Aviv 69978, Israel. ({\tt guy@eng.tau.ac.il}).}
\and
Moti Medina
\thanks{School of Electrical Engineering, Tel-Aviv Univ., Tel-Aviv 69978, Israel. ({\tt medinamo@eng.tau.ac.il}).
Partially funded
by the Israeli Ministry of Science and Technology.}}

\maketitle
\begin{abstract}

We present deterministic and randomized algorithms for the problem
  of online packet routing in grids in the competitive network throughput
  model~\cite{AKOR}. In this model the network  has nodes with bounded buffers and bounded
  link capacities. The goal in this model is to maximize the throughput, i.e., the
  number of delivered packets.

  Our deterministic algorithm is the first online
  algorithm with an 
  competitive ratio for uni-directional grids (where 
  denotes the size of the network).  The deterministic
  online algorithm is centralized and handles packets
  with deadlines.  This algorithm is applicable to
  various ranges of values of buffer sizes and
  communication link capacities. In particular, it holds
  for buffer size and communication link capacity in the
  range .

Our randomized algorithm achieves an expected competitive ratio of  for
the uni-directional line. This algorithm is applicable to a wide range of buffer
  sizes and communication link capacities. In particular, it holds also for unit size
  buffers and unit capacity links.  This algorithm improves the best previous
  -competitive ratio of Azar and Zachut~\cite{AZ}.
\end{abstract}

\paragraph{Keywords.}
Online Algorithms, Packet Routing,  Bounded Buffers, Admission Control, Grid Networks
\thispagestyle{empty}
\section{Introduction}
Large scale communication networks partition messages into packets so that high
bandwidth links can support multiple sessions simultaneously. Packet routing is used
by the Internet as well as telephony networks and cellular networks. Thus, the
development of algorithms that can route packets between different pairs of nodes is
a fundamental problem in networks. In a typical setting, requests for routing packets
arrive over time, thus calling for the development of online packet routing
algorithms. The holy grail of packet routing is to develop online distributed
algorithms whose performance is competitive with respect to multiple criteria, such
as: throughput (i.e., deliver as many packets as possible), delay (i.e., guarantee
arrival of packets on time), stability (e.g., constant rate, avoid buffer overflow) ,
fairness (i.e., fair sharing of resources among users), etc.  From a theoretical
point of view, there is still a huge gap between known lower bounds and upper bounds
for packet routing even in the simple setting of directed paths and centralized
algorithms.


We study the ``Competitive Network Throughput Model'' introduced by~\cite{AKOR} for
dynamic routing on networks with bounded buffers.  The goal is to route packets
(i.e., constant length formatted data) in a network of  nodes.  Nodes in this
model are switches with local memories called buffers.  An incoming packet is either
forwarded to a neighbor switch, stored in the buffer, or erased. The resources of a
packet network are specified by two parameters:  - the capacity of links and  -
the size of buffers.  The capacity of a link is an upper bound on the number of
packets that can be transmitted in one time step along the link.  The buffer size is
the maximum number of packets that can be stored in a node.


\subsection{Previous Work}
Algorithms for dynamic routing on networks with bounded
buffers have been studied both in theory and in practice.
The networks we study are uni-directional grids of 
dimensions. Such -dimensional grids with or without
buffers serve as crossbars in networks
(see~\cite{ARSU,AKRR,T} for many references from the
networking community). Thus, even centralized algorithms
for this task are of interest since they can be used to
control a crossbar.

\paragraph{Online Algorithms for Uni-directional Lines.}
Our work on uni-directional line networks is based on a
sequence of papers starting with~\cite{AKOR}.
In~\cite{AKOR}, a lower bound of  was
proved for the greedy algorithm on uni-directional lines if
the buffer size  is at least two. For the case  (in
a slightly different model), an  lower bound for
any deterministic algorithm was proved by~\cite{AZ,AKK}.
Both~\cite{AZ} and~\cite{AKK} developed, among other
things, online randomized centralized algorithms for
uni-directional lines with . In~\cite{AKK} an
-competitive randomized centralized algorithm
was presented for buffer size  at least . For the
case , ~\cite{AKK} proved that nearest-to-go is
-competitive. For the case ,
~\cite{AKK} presented a randomized
-competitive distributed algorithm.
(This algorithm also applies to rooted trees when the
packet destinations are the root.) In~\cite{AZ}, an
-competitive randomized algorithm was
presented for the case . (This algorithm also
applies to rings and trees.)


\paragraph{Online Algorithms for Uni-directional Grids.}
Angelov et al.~\cite{AKK} showed that the competitive ratio
of greedy algorithms in uni-directional -dimensional
grids is  and that nearest-to-go policy
achieves a competitive ratio of .

\paragraph{Other Related Results.}
Kleinberg and Tardos~\cite{KT} studied the disjoint path problem in undirected planar
graphs (see~\cite{KT} for a formal description of the family of graphs for which
their results hold).  They presented constant approximation randomized algorithm for
this problem as well as an online algorithm with logarithmic competitive ratio.

Leighton et al.~\cite{leighton1994packet} and subsequent
works~\cite{leighton1999fast,RT, srinivasan1997constant} deal with a different model
for packet routing. In this model, there are unbounded input queues and bounded
intermediate buffers. In addition, each packet comes with a path along which it is
sent. The latency of each packet is , where  denotes the maximum
congestion and  denotes the length of a longest path.

Offline algorithms for trees and meshes were studied in~\cite{AKRR} . They obtained a
logarithmic approximation ratio for unbounded buffers and a constant approximation
ratio for bufferless networks. Offline packet routing for uni-directional lines was
studied in~\cite{RR}.

\renewcommand{\arraystretch}{1.3}
\begin{table}
\begin{centering}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
Paper &  & Competitive Ratio  & Det.  Rand.&  & Remarks \tabularnewline
\hline
\hline
\cite{AKK}  &  &   & det. &  &  distributed, nearest-to-go,
-bend routing\tabularnewline
\cite{AKK}  &  &   &det.  &  & distributed, nearest-to-go\tabularnewline
\cite{AKK}  &  &   &rand.  &  & shared randomness, distributed\tabularnewline
\cite{AKK}  &  &   &rand.  &  &  centralized\tabularnewline
\cite{AZ}   &  &  & rand. &   &  centralized, FIFO buffers\tabularnewline
\hline
\end{tabular}
\par\end{centering}
\caption{Previous online algorithms for packet routing. The networks are
  uni-directional lines or two dimensional directed grids with
  unit link capacities.}
\label{table:previous work}
\end{table}
\renewcommand{\arraystretch}{1}

\subsection{Our Results}
We present online algorithms for packet routing in
-dimensional uni-directional grids (for ) as
follows.

\paragraph{Deterministic Online algorithm.}
We present a centralized \emph{deterministic} online
algorithm for packet routing in uni-directional grids with
 nodes. Our algorithm achieves a polylogarithmic
competitive ratio for a wide combination of parameters
described below. (The buffer size is denoted by  and the
link capacities are denoted by .) The deterministic
packet-routing algorithm handles requests with deadlines,
allows  preemptions (i.e., packets may be dropped before
they reach their destination), and employs adaptive routing
(i.e., part of the route is computed while the packet is
traveling to its destination).

\begin{enumerate}[(i)]
\item For , the competitive
    ratio of the algorithm is  for
    uni-directional grids of dimension .
\item For  and , the competitive ratio of
    the algorithm is  for
    uni-directional grids of  dimensions. In the
    trivial case of a uni-directional line (i.e., ),
    our algorithm is degenerated to the nearest-to-go
    policy~\cite{AKOR} and is optimal.
\item For  and  the
    algorithm reduces to online integral path
    packing~\cite{BN06,AAP}. The competitive ratio of the
    algorithm is  for uni-directional grids,
    independent of the dimension . In this algorithm,
    packets are either rejected or routed but not
    preempted.
\end{enumerate}
In the rest of the paper, we address the algorithm for
uni-directional grids as the `deterministic' algorithm.

\paragraph{A Randomized Algorithm for the One Dimensional Case.}
We present a centralized online \emph{randomized} packet
routing algorithm for maximizing throughput in
uni-directional lines\footnote{We remark that the
randomized
  algorithm can be generalized to -dimensional grids to obtain competitive ratios
  that are . In light of similar competitive ratios with the
  deterministic algorithm, we omit the description and analysis of the randomized
  algorithm for -dimensional grids.}. Our algorithm is \emph{nonpreemptive};
rejection is determined upon arrival of a packet. Our algorithm is centralized and
randomized and achieves an -competitive ratio. In addition to handling the
case that  and , our algorithm improves over previous algorithms as
follows:
\begin{enumerate}[(i)]
\item The competitive ratio is  compared to the best  previous competitive ratio of  by Azar and Zachut~\cite{AZ}.
\item Our algorithm works also for buffers of size  (with no restriction on
  the link capacities).
\item We consider also the parameter  of the capacity of the links (\cite{AZ,AKK} considered only the case ).
\item The  competitive ratio applies for the following combination of parameters:
  (1)~ and , or (2)~ .
\end{enumerate}
In the rest of the paper, we address the algorithm for
uni-directional lines as the `randomized' algorithm.

\subsection{Techniques}\label{sec:tech}

\paragraph{Reduction of Packet-Routing to Circuit Switching.}
Packet routing is reduced to a circuit switching problem~\cite{KT,AAP} by applying a
\emph{space-time transformation}~\cite{AAF,ARSU,AZ,RR}.  We extend the space-time
transformation of~\cite{AZ} so that it also supports deadlines.

The reduction of packet routing to circuit switching relies on the ability to bound
the path lengths without losing too much throughput. In~\cite{AZ} a bound on the path
lengths that incurs only a constant fraction loss of throughput is proven for routing
in a uni-directional line. We extend the lemma of~\cite{AZ} to -dimensional grids
and to general values of buffer sizes  and link capacities .

This implies that online packet-routing is reduced to the well studied problem of
online packing of paths~\cite{AAP, BN06}.  Algorithms for online packing of paths
either reject a request or assign a path to a request (i.e., perform call admission).  The
edge capacities of the space-time graph are  and .  If the capacities are
large, i.e., , then the online path packing algorithm by Awerbuch
et. al~\cite{AAP} achieves a  competitive ratio, where  is number of
vertices of the (original) graph, as required.  In the case where the capacities are
small, i.e., , the algorithm by~\cite{AAP} does not apply, hence we
coalesce groups of nodes by \emph{tiling}~\cite{KT,BL}. This induces a new graph,
called a \emph{sketch graph} in which the capacities are (again) large.  We apply the
online path packing algorithm over the sketch graph, but are left with the problem of
translating paths over the sketch graph to paths over the space-time graph. We refer
to this translation as \emph{detailed routing}. We use the framework of Buchbinder
and Naor~\cite{BN06,BNsurvey} for \emph{online path packing} because it helps us
point out the tradeoffs between the path lengths, the competitive ratios, and the
overloading of edges.

\paragraph{Detailed Routing.}
The path packing algorithm computes a path over the sketch graph, and the algorithm
must translate this sketch path to a detailed path over the space-time graph. The
detailed path traverses the same tiles that are traversed by the sketch path and
bends whenever the sketch path bends.  Detailed routing has been addressed before in
undirected graphs~\cite{KT,BL} as well as in space-time graphs of
the uni-directional line~\cite{RR}.

Detailed routing is not always successful; indeed, we need to bound the fraction of
the requests that are lost during detailed routing.  In the deterministic algorithm,
the detailed routing technique partitions each path in the sketch graph into three
parts, and reserves only a unit of capacity for each part. This is the reason why the
algorithm requires .  In some parts of the detailed routing, we reduce
the problem of detailed routing to \emph{online interval packing}.  This reduction
uses an online procedure for packing intervals on a line (which is, in fact, a
nearest-to-go routing policy). We apply an online distributed simulation of the
optimal interval packing algorithm~\cite{GLL}. The correctness of this simulation is
based on the ability of the packet-routing algorithm to preempt (i.e., drop) packets.

\paragraph{Classify and Select.}
Requests are categorized as \emph{near} or \emph{far}, and the algorithm randomly chooses to deal
with one category of requests.
The categorization is based on the tiles. A request that can be routed within a tile
is considered near; otherwise it is a far request.

Randomization is also employed to choose a random subset of the requests so as to
further weaken the adversary. We use \emph{random phase shifts} that determine the quadrants
within tiles from which paths may start.


\paragraph{Random Sparsification.}
Requests that are assigned
sketch paths by the online path packing algorithm are randomly sparsified. This
\emph{random sparsification} has two roles: (1)~Reduction of loads of sketch graph edges
incurred by the path packing algorithm to a small constant fraction with high
probability.  (2)~Solving the problem that the source nodes of requests may be
densely packed in an area .  The capacity of the edges that enable routing paths
out of  is proportional to the ``perimeter'' of , while the number of source
nodes in  is proportional to the ``area'' of .  In a  dimensional grid, the
area of a subregion can be as large as the perimeter of the subregion to the power
.  By applying random sparsification, the number of remaining paths whose source
node is in a quadrant of a tile roughly equals the perimeter of the quadrant.

\subsection{Organization}
The formal definition of the problem is stated in Sec.~\ref{sec:problem}.
In Sec.~\ref{sec:prelim}, the reduction of packet-routing to path packing is presented.
In Sec.~\ref{sec:outline}, we outline the steps of the deterministic algorithm.
In Sec.~\ref{sec:alg}, we elaborate on each step of the deterministic algorithm with respect to uni-directional lines and prove that the algorithm is -competitive, where  is the number of nodes. In Sec.~\ref{sec:generalizations} we present a
generalization of the deterministic algorithm to the
-dimensional case and extensions to special cases, such
as: bufferless grids, and grids with large buffers and
large link capacities. In Sec.~\ref{sec:randalg} we design
and analyze a randomized algorithm for uni-directional
lines. Our randomized algorithm achieves a competitive
ratio of .


\section{Problem Definition}\label{sec:problem}
\label{sect:problem}

\subsection{Store-and-Forward Packet Routing Networks}
We consider a synchronous store-and-forward packet
routing network~\cite{AKOR,AKK,AZ}.

Each packet is specified by a -tuple , where  is the source node of the packet,  is the destination node,   is the time step in which the packet is input to , and  is the deadline.  Since we consider an online setting, no information is known about a packet  before time .  Deadlines mean that the algorithm is only credited for delivering packet  to its destination  before time .

The network is a directed graph .
Each edge has a capacity  that specifies the number of packets that can be transmitted along the edge in one time step.  Each node has a local buffer of size  that can store at most  packets.
Each node has a local input through which multiple packets may be input in each time step.  The network operates in a synchronous fashion with a delay of one time step for communication. This means that a single time step is needed for a packet to traverse a single link.


In each time step, a node  considers the packets arriving via the local input, the packets arriving from incoming edges, and the packets stored in the buffer.  Packets destined to node  (i.e., ) are removed from the network (this is considered a success provided that the deadline has not passed, and no further routing of the packet is required). As for the other packets, the node determines which packets are sent along outgoing edges (i.e., forwarded) and which packets are stored in the buffer. The remaining packets are \emph{deleted}.

The literature contains two different models of node functionality. We use the model used by~\cite{ARSU,RR}. The reader is referred to Appendix~\ref{sec:model} for a comparison between two different models of node functionality; this comparison is mostly of interest for the case .

We use the following terminology.  A packet is \emph{rejected} if it is locally input to a node and the node deletes it. A packet that is locally input but not rejected is called an \emph{injected} packet. A packet is \emph{preempted} or \emph{dropped} if it was injected and deleted before it reached its destination.


The task of \emph{admission control} is to determine which packets are injected and which are rejected.  An algorithm that drops packets is a \emph{preemptive algorithm}; an algorithm that does not drop packets is called a \emph{non-preemptive algorithm}.

\subsection{Grid Networks}
A two dimensional  uni-directional
grid network is a directed graph  defined as
follows (see Fig.~\ref{fig:grid}). The set of vertices is
, where 
denotes the set of integers .  We denote
the number of vertices by  (i.e., .  There are two types of edges: horizontal edges
 and vertical edges
. For each packet, the source
node  and the destination node
 satisfy  (i.e.,
 and ).  We refer to
an  two dimensional directed grid
network simply as a grid.

A -dimensional grid is defined analogously over a vertex set
. Our analysis applies to the case
that  is a constant.

\paragraph{Capacities and Buffers.}
We assume uniform capacities and buffer sizes. Namely, (i)~all edges in the grid have
the same capacity, denoted by ; and (ii)~all nodes have the same buffer size,
denoted by .

  \begin{figure}[H]
    \begin{center}
      \includegraphics[width=0.2\textwidth]{grid.eps}
    \end{center}
    \caption{A  grid network.}
    \label{fig:grid}
  \end{figure}

\subsection{Online Maximum Throughput in Networks}
The \emph{throughput} of a packet routing algorithm is the number of packets that are delivered to their destination \emph{before their deadline}.
We consider the problem of maximizing the throughput of an online centralized deterministic packet-routing algorithm.

Let  denote an input sequence. Let  denote a packet-routing
algorithm. Let  denote the subset of requests in  that
are delivered on time by . The throughput obtained by  on input
 is the size of the set , i.e., . Let
 denote the subset of requests in  that are delivered
by an optimal throughput routing. An online deterministic \alg\ is
\emph{-competitive} if for every input sequence ,
. An online randomized
algorithm is -competitive with respect to an oblivious adversary, if
for every input sequence , , where the expected value is over the random choices made by
\alg~\cite{be}.

\subsection{Problem Statement}\label{sec:problem statement}
\paragraph{The Input.}
The online input is a sequence of packet requests . Each
packet request is  specified by a -tuple  over a
grid network . We consider an online setting, namely, the requests
arrive one-by-one, and no information is known about a packet request 
before its arrival.

\paragraph{The Output.}
In each time step, the packet-routing algorithm decides what each of the packets in
the network should do. This decision can be either reject a new packet,
preempt an existing packet, store a packet in a buffer of the node which the
packet has reached, or forward the packet to a neighboring node.

\paragraph{The Objective.}
The goal is to maximize the number of packets that are
successfully routed (i.e., reach their destination before
the deadline expires).

\section{Reduction of Packet-Routing to Path Packing}
\label{sec:prelim}

\subsection{Space-Time Transformation}
\label{sec:spacetime}

A\emph{ space-time transformation} is a method to map traffic in a directed graph over time into a directed acyclic graph~\cite{AAF,ARSU,AZ,RR}. Consider a directed graph  with edge capacities  and buffer size .
The space-time transformation of  is the acyclic directed infinite graph  with edge capacities , where:
\begin{inparaenum}[(i)]
\item .
\item  where  and .
\item The capacity of all edges in  is , and all edges in  have capacity . Note that the space-time graph corresponding to a -dimensional grid is a -dimensional grid.
\end{inparaenum}
Figure~\ref{fig:st} depicts the space-time transformation in the one dimensional case.

\paragraph{Adding Sink Nodes.}
Following~\cite{AZ}, we add sink nodes to define a specific destination node for each request. For every vertex  in the line, we define a sink node
 (see Figure~\ref{fig:stsink}).
A \emph{copy of a vertex}  in the space-time graph  is a space-time vertex  for some .
We add an incoming edge of infinite capacity to the sink node  from each tile  that contains a copy  of .

\begin{figure}[h]\centering
\includegraphics[width=0.5\textwidth]{st.eps}
\caption{The space-time graph  with the new sink nodes (shown on the rightmost column).
}
\label{fig:stsink}
\end{figure}

\subsection{Untilting}
A standard drawing\footnote{For , the  has a
    -dimensional standard drawing in which: (i)~ a node  is mapped to the point , and (ii)~edges are mapped
    to straight segments between their endpoints.}  of the space-time graph of a grid is a lattice generated by non-orthogonal vectors. This drawing is hard to depict and deal with, hence we apply a transformation called untilting defined as follows (see~\cite{RR} for untilting in two dimensions).


We rectify the drawing of the space-time graph of a grid by applying
an automorphism  defined by
. We refer to this
transformation as \emph{untilting}. The sole purpose of applying
untilting is to obtain a drawing of the space-time graph of a grid in which the edges are axis parallel. Such an axis parallel drawing
simplifies the definition of tiles.
Note that the image of some of the vertices in  is outside the positive quadrant.
Figure~\ref{fig:stuntilt} depicts the untilted space-time graph in the one dimensional case. (e.g., the node  is mapped to .)


\subsection{Tiling}\label{sect:tiling}
The term \emph{tiling} refers to a partitioning of the nodes of the
space-time graph  into finite sets with identical geometric
``shape''.

Tiling is obtained by a partitioning of  by disjoint
-dimensional cubes with side-length .  (For the sake of simplicity
 is partitioned to cubes. One can save a logarithmic factor in the
competitive ratio by a partitioning to boxes with unequal side
length. See Section~\ref{sect:prelimline} for an example of such a partitioning.)


A tile  is a maximal subset of  such that its image  (after untilting) is contained in a cube.
Formally, given a cube side-length , a tile is defined by its \emph{lower corner}
, where the coordinates of  are integral multiples of .
The lower corner  defines the tile , where  is the all ones vector. Note that some of the
tiles in  are \emph{partial}, namely contain less than  vertices (see
Figures~\ref{fig:dtile},~\ref{fig:dtiletilt}). In this case, we augment partial tiles
by dummy vertices so that they are complete.
Note that a dummy vertex is never an internal vertex in a path between non-dummy
vertices, and hence, this augmentation has no effect on routing.
\subsection{The Sketch Graph}\label{sect:sketchgraph}
The sketch graph is the graph obtained from the space-time graph after coalescing
each tile into a single node (sink nodes remain unchanged).  There is a directed edge
 between two tiles  in the sketch graph if there is a directed
edge  such that  and . The
capacity  of an edge  in the sketch graph is simply the sum of
the capacities of the edges in  from vertices in  to vertices in 
(i.e., the capacity of a vertical edge between two tiles  and the capacity of a
horizontal edge is ).  Figure~\ref{fig:dsketch} depicts an untilted sketch graph
of a space-time graph of a one dimensional grid.

The sketch graph also has node capacities for nodes that correspond to tiles (i.e.,
not sinks). The capacity of every node that corresponds to a tile is .
\paragraph{Notation.}
We denote the sketch graph by .
We abuse notation and often refer to the nodes of  (that are not sinks) as tiles.


\begin{figure}\centering
  \subfloat[Space-time graph ]{\label{fig:st}
\includegraphics[width=0.5\textwidth]{stnosinks.eps}
} \qquad
  \subfloat[Untilted space-time graph ]{\label{fig:stuntilt}
\includegraphics[width=0.75\textwidth]{stuntilt.eps}
}\\\subfloat[Tiles in ]{\label{fig:dtiletilt}
\includegraphics[width=0.4\textwidth]{dtiletilt.eps}
} \quad
\subfloat[Tiles in ]{\label{fig:dtile}
\includegraphics[width=0.4\textwidth]{dtileuntilt.eps}
}\quad
  \subfloat[Sketch graph ]{\label{fig:dsketch}
\includegraphics[width=0.4\textwidth]{dsketchuntilt.eps}
}
\caption{\footnotesize(a) The tilted space-time graph . The  horizontal axis is the (infinite) time axis and the vertical axis is the (finite) node axis.
(b) The untilted space-time graph . The encapsulated path in (a) corresponds to the encapsulated path in (b).
Diagonal edges depict edges in . Edges in  are depicted by horizontal edges.
(c) The corresponding tiling of the (tilted) space-time graph . The bolded parallelogram in (c) corresponds to the bolded rectangle in (d).
(d) Tiling of the untilted space-time graph  by  rectangles.
(e) The sketch graph over the tiles .
}
\end{figure}

\subsection{Online Packing of Paths}
\label{sect:routing}

A reduction of packet routing to packing of paths is presented in Section~\ref{sec:reduce}. We briefly overview the topic of online packing of paths.

Consider a graph  with edge capacities . Edges have soft capacity constraints (i.e., the capacity constraint may be violated, and one goal is to minimize the
violation).
The adversary introduces a sequence of connection requests
, where each request is a source-destination pair
. The online packing algorithm must either return a path
 from  to  or reject the request.

Consider a sequence  of requests. A sequence
 is a (partial) \emph{routing} with respect to  if
 and each path  connects the
source-destination pair .  The \emph{load} of an edge  induced
by a routing  is the ratio .
A routing  with respect to  is called a \emph{-packing} (or \emph{-feasible}) if the
load of each edge is at most . The \emph{throughput} of a packing
 is simply .

An online path packing algorithm is \emph{-competitive} if it computes a -packing  whose throughput is at least  times the maximum   throughput over all -packings.

If each request is served by a single path, then the routing is
\emph{nonsplittable}.

A \emph{fractional} packing is a multi-commodity flow. Each
demand can be (partly) served by a combination of fractions
of flows along paths. A sequence  is
a \emph{fractional (splittable) routing} with respect to
 if each path  connects the
source-destination pair , and the total flow allocated
by paths in  is at most one. The \emph{throughput} of
a fractional splittable path packing 
is the sum of the allocated flows along every path in
. An optimal offline fractional packing can be
computed by solving a linear program. Obviously, the
throughput of an optimal fractional packing is an upper
bound on the throughput of an optimal integral packing.


The proof of the following theorem appears in Appendix~\ref{sect:routealg}.
The proof is based on techniques from~\cite{AAP, BN06}.
We refer to the online algorithm for online integral path packing by .

\begin{theorem}\label{thm:IPP}
  Consider an infinite graph with edge capacities such that .  Consider an online path packing problem in which a
  path is legal if it contains at most  edges.
Assume that there is an oracle, that given edge weights and a
  connection request, finds a
  lightest legal path from the source to the destination. Then, there
exists a -competitive online
  integral path packing algorithm.  Moreover, the throughput is at least
 times the maximum throughput over all fractional packings.
\end{theorem}

\subsection{Polynomial Path Lengths}
\paragraph{Notation.}
Consider a directed graph  with edge capacities  and
buffer size  in each vertex.  Let  denote the space-time
graph of  (see Section~\ref{sec:spacetime}).  Let .  Let
 denote the length of a shortest path from  to  in
. Let  denote the diameter of  defined as follows


Consider a sequence  of routing requests (without deadlines) over , i.e., each request is a three-tuple  that requires a path from  to a copy of  in , that is,  for .

Let  denote an optimal fractional path packing in  with respect to .
Let  denote an optimal fractional path packing in  with respect to  under the constraint that each request is routed along a path of length at most .
Let  denote the throughput of a fractional path packing .


The following lemma shows that bounding path lengths (in a fractional
path packing problem over a space-time graph) by a polynomial
decreases the throughput only by a constant factor.  The
lemma is an extension of a similar lemma from~\cite{AZ}.
The proof of Lemma~\ref{lemma:nB} appears in Appendix~\ref{sec:proofnB}.

\begin{lemma}\label{lemma:nB}
  Let , , and .  Then, 
\end{lemma}


\subsubsection{Remarks}
\begin{inparaenum}[(1)]
\item If  is the space-time graph of a
    uni-directional line, then we set  
\item If  is the space-time graph of a
    -dimensional uni-directional grid, then we set
    
    and 
\item
 A trivial lower bound on the path lengths is  if we want to be
  able to route a constant fraction of the optimal throughput. Indeed, if  packets
  are injected simultaneously to the same node in a line, then at most  packets
  can be forwarded in each step. Hence  steps are required to forward a
  constant fraction of the packets. This justifies the term  in the definition
  of the maximum path length (see Lemmas~\ref{lemma:nB} and \ref{lemma:nBline}).
\end{inparaenum}

\begin{comment}
  \item Using the same technique, one can prove that  for
  .
\end{comment}


\section{Outline of the Deterministic Algorithm}\label{sec:outline}
The listing of the deterministic framework appears in
Algorithm~\ref{alg:algDet}.  Upon arrival of a request , the
algorithm reduces the packet request to an online integral path
packing over the sketch graph with bounded paths. The algorithm then
executes the online algorithm for online integral path packing (\IPP)
with respect to this path request. If the path request is rejected by
the \IPP\ algorithm, then the algorithm rejects .  Otherwise, let
 denote the sketch path assigned to the request . The
algorithm injects the request  with its sketch path 
and performs detailed routing in the space-time graph .
Detailed routing in  may fail (see
Section~\ref{sec:detailed}). In case of failure, the algorithm
preempts .


To simplify the description, we begin in, Sec.~\ref{sec:alg}, by
presenting a detailed description and proof for the one-dimensional
case.  The required modifications for higher dimensions are described
in Sec.~\ref{sec:algd}.  We also assume that there are no deadlines
(i.e., ), hence each packet is specified by a -tuple
; we reintroduce deadlines in
Section~\ref{sec:d_i}.


\begin{algorithm}[H]
    \textbf{Upon arrival} of a packet request , for  (if  is rejected or preempted in any step, then the algorithm does not continue with the next steps), the algorithm proceeds as follows:
        \begin{enumerate}
            \item \label{item:reduce}Reduce  to a path request  in the -sketch graph  as follows:
                \begin{enumerate}
                  \item The source of the path request  is the half  tile , where the tile  contains the vertex .
                  \item The destination of the path request  is simply the sink .
                \end{enumerate}
            \item Execute the \IPP\ algorithm over  with respect to the reduced path request .
             \begin{enumerate}
               \item If the \IPP\ algorithm rejects the  then \textbf{reject} .
               \item Else, let  denote the path output by \IPP, i.e., the sketch path assigned to .
             \end{enumerate}
            \item \label{item:I} \textbf{Inject} the request  (the request ``includes'' its sketch path  ) and perform detailed routing in the space-time graph .
                Detailed routing proceeds by processing the \emph{first segment} of , the \emph{internal segments} of , the \emph{last segment} of , and finally the \emph{last tile} of .
                Failure in one of these parts causes a \textbf{preemption} of .
\begin{comment}
                  \begin{enumerate}
                  \item Perform detailed routing in the \emph{first segment} of . If the detailed routing in this segment fails then \textbf{preempt} .
                  \item Perform detailed routing in the \emph{internal segments} of  (this part of detailed routing always succeeds).
                  \item Perform detailed routing in the \emph{last segment} of . If the detailed routing in this segment fails then \textbf{preempt} .
                  \item Perform detailed routing in the \emph{last tile} of . If the detailed routing in this segment fails then \textbf{preempt} .
                \end{enumerate}
\end{comment}
            \item Packet request  \textbf{arrives} to its destination  if it is not rejected or preempted.
        \end{enumerate}
\caption{The deterministic framework. The algorithm receives a sequence of packet requests over the network  and it either rejects, injects, or preempts these packet requests. A packet arrives to its destination if it is not rejected or preempted. The deterministic algorithm executes the \IPP\ algorithm as a sub-procedure.}\label{alg:algDet}
\end{algorithm}

\section{The One Dimensional Case}\label{sec:alg}
In this section we present the details of Algorithm~\ref{alg:algDet} for .
We refer to Algorithm~\ref{alg:algDet} by \alg.

\paragraph{Parameters.}The parameters of the uni-directional line network  are:
 nodes, buffer size  in each node, and the capacity
of each link is . We assume that .
Let .
Let . The length of a
tile's side is .

\begin{proposition}\label{prop:tiling}
If , then
\begin{inparaenum}[(i)]
\item, and
\item the capacity of each edge in the sketch graph is at most
  .
\end{inparaenum}
\end{proposition}


\subsection{Reduction to Online Integral Path Packing}\label{sec:reduce}
\begin{comment}
  The reduction to path packing has to deal with these issues:
  \begin{inparaenum}[(i)]
  \item Handling requests \emph{inside} a tile.
  \item bounding the loads on the sketch edges.
  \item Determining a specific destination node per request.
  \end{inparaenum} To deal with these issues, we augment the sketch graph as follows.
\end{comment}

\paragraph{Downscaling of Capacities.}
We regulate the number of paths that traverse each edge and node in the sketch graph
by downscaling capacities.  There are three types of capacities: (1)~edges between
tiles are assigned unit capacities, (2)~incoming edges to sink nodes are unchanged
and remain with infinite capacities, and (3)~each tile is assigned two units of
capacity\footnote{In the case of -dimensional grid, the capacity of a tile is
  . This saves a factor of  in the competitive ratio.}.

To apply a reduction to integral path packing, we reduce node capacities to edge
capacities. Namely, each node  is split to two ``halves''  and
. After the split, edges are ``redirected'' as follows: the incoming edges
of  enter  and the outgoing edges of  emanate from . We add an
additional edge called an \emph{interior edge} between  and .  All
interior edges are assigned two units of capacity (see Figure~\ref{fig:dsketchcaps}).  We refer to the augmented sketch
graph with these capacities as the \emph{-sketch graph}. We denote
the -sketch graph by .
Let  denote the downscaled capacity function of the -sketch graph .

Note that, since nodes are split and sinks are added, we need to increase the maximum path length to .

\begin{figure}[h]
  \centering
\includegraphics[width=0.45\textwidth]{dsketchcaps.eps}
\caption{
Capacity assignment in the -sketch graph . Unit capacities are assigned to sketch edges and capacity of  is assigned to interior edges.}
\label{fig:dsketchcaps}
\end{figure}

\paragraph{The Reduction.}
A request  to deliver a packet is reduced to a path request  in the -sketch graph . The source of the path request  is the vertex  , where the vertex  is in tile . The destination of the path request is simply the sink node .


The sole purpose of the sink node is for a clean reduction to path packing. Once the \IPP\ algorithm returns the sketch path , the sink node is removed from , and the last tile in the sketch path is regarded as the end of the sketch path.

\begin{comment}
A reduction of (fractional) packet routing to (fractional) packing of
paths was presented in~\cite{AZ}.  In this reduction, a packet request
 is reduced to a connection request  in the space-time graph ,
where  is the sink node associated with .
This reduction preserves the (fractional) throughput.
\end{comment}

Theorem~\ref{thm:IPP} implies that the \IPP\ algorithm returns an integral packing of paths in  that is
-competitive with respect to the optimal fractional path packing in . The length of each path in the packing is at most .

\subsection{Detailed Routing}\label{sec:detailed}
This section deals with the translation of paths in the sketch graph to paths in the space-time graph. This translation, called \emph{detailed routing}, is adaptive and computed in a distributed on-the-fly fashion.
The detailed path respects the sketch path in the sense that it traverses the same tiles and bends only where the sketch path bends.
Note that, some of the packets are dropped during detailed routing.


More formally, the goal in detailed routing is to compute a (detailed) path  in
the space-time graph  given a sketch path  in the -sketch graph .
The projection of  on
 equals .


\subsubsection{Preliminaries}

\paragraph{Terminology.}
A \emph{bend} in the sketch path is a node in which the sketch path changes direction, i.e., vertical to horizontal or horizontal to vertical.

A \emph{segment} of a path in a grid is a maximal subpath, all the vertices of which belong to the same row or column of the grid.
A segment is \emph{special} if it is the first or the last segment of a path. Otherwise, it is an \emph{internal} segment.

We refer to the side through which the detailed path enters a tile as the \emph{entry side}.
Similarly, we refer to the side through which the detailed path exits a tile as the \emph{exit side}.

\paragraph{Packing Intervals Online.}\label{sec:intervalp}
The problem of packing intervals in a line is defined as follows.
  \begin{enumerate}
  \item Input: A set , where each  is an open interval
    .\footnote{We consider open intervals rather than
      closed intervals. One could define the problem with respect to closed
      intervals, but then instead of requiring disjoint intervals in the packing,
      one would need to require that intervals may only share endpoints.}
          \item Output: A maximum cardinality subset  of pairwise
            disjoint intervals.
    \end{enumerate}
    In the online setting, we assume that the
    intervals appear one by one, and that . The online algorithm must maintain a maximum subset  such that
    (i)~ is a subset of the prefix of the intervals input so far, and (ii)~the
    intervals in  are pairwise disjoint.


    The online algorithm is based on an optimal algorithm for maximum independent
    sets in interval graphs~\cite{GLL}.  Upon arrival of an interval ,
    the algorithm proceeds as follows: (1)~If  does not intersect the intervals
    in , then  is added to .  (2)~Else,  intersects an interval
    . If , then  is rejected (namely,  remains
    unchanged). Otherwise, if , then  preempts  (namely,
    ).

    Note, that this online algorithm can be executed in a distributed fashion in a
    line. Namely, the local input of each processor  is the interval  (or the empty input). Additionally,  receives   from its neighbor . Now,  can verify by itself whether to preempt an interval from  and accept  or to reject . After  completes his local computation,  sends  to its neighbor .



\paragraph{Partitioning of Detailed Routing.}
Detailed routing is partitioned into at most three parts\footnote{Degenerate cases of detailed routing consist of two parts or just a single part; for example, detailed routing of requests whose sketch path is a single tile consists only of part (III).
}
, as follows (See Figure~\ref{fig:detailedpath}).
\begin{enumerate}[(I)]
\item Special segments,
\item Internal segments, and
\item Last tile: detailed routing in the last tile deals with routing the request from the point that it enters the last tile till a copy of the  destination vertex within the tile.
\end{enumerate}
Preemptions may occur in parts (I) and (III) of the detailed routing. Preemptions are caused by conflicts between detailed routing of packets that belong to the same part. Namely, a special segment can only preempt another special segment. Similarly, detailed routing in the last tile preempts only routes that end in the same tile.


\paragraph{Reservation of Capacities.}
The algorithm reserves one unit of capacity in each edge  for each part of detailed routing. This is the reason for the requirement that .
Note that the algorithm is wasteful in the sense that it only uses  units of capacity in each edge.
We refer to each of these  units of capacity as a \emph{track}, i.e., each part uses a different track.

\begin{comment}
  \bigskip
  \noindent
  We now elaborate on the detailed routing of every part, i.e.,
  special segments, internal segments and the last tile. We also
  elaborate on the transition between parts.
\end{comment}

\subsubsection{Detailed Routing in Special Segments}\label{sec:first detailed}
Consider the first segment of a sketch path  (see
Fig.~\ref{fig:sketchpath}).  The detailed routing corresponding to this segment is a
straight path that starts in the source-vertex  and ends in the tile in
which  bends for the first time. As there may be contention for capacity
allocated for special segments, detailed routing needs to decide which request is
dropped. We reduce the problem of routing the first segment of detailed paths to the
problem of packing intervals in a line (described in detail in
Section~\ref{sec:intervalp}).

A separate reduction to interval packing in a line takes place for every row and column of the
untilted space-time grid.

Detailed routing in the last segment of  (before the last tile) is similar.
Consider a last segment of a sketch path  that starts in tile  and
ends in tile .  The detailed routing of a last segment
begins in the entry side of  that is reached by the detailed routing of
the previous segment, and ends in the entry side of . Between these two
endpoint, detailed routing is along a straight path. As in the case of detailed
routing of the first segment, routing in the last segment is reduced to interval
packing in a line.

Consider a sketch path  whose first bend is in tile .  If the detailed
routing of the first segment of  is not preempted before it enters the tile ,
then  is not preempted before the first bend. Indeed, there are two types of
conflicting requests whose first segment conflicts with the first segment of 
depending on the location of the source vertex (either before or after the entry to
tile ). If the source vertex of  appears before the entry to , then 
``wins'' and  is preempted. If the source vertex of  appears after the entry
to , then  ``wins'' again because  requests an interval that ends
outside the tile  while  requests an interval that ends in tile . We also
need to consider a conflict with a last segment of a request : (1)~If  ends
inside , then it must also begin in  (because it is not possible for  and
 to enter the tile through the same edge). If  begins and ends , then it
is routed using only the third track (reserved for detailed routing in the last tile)
and  does not conflict with the first segment of . (2)~If  ends outside
, then it is preempted by  because  requests an interval that ends
inside .

\begin{figure}
  \centering
  \subfloat[The sketch path ]{
    \includegraphics[width=0.47\textwidth]{sketchpath2.eps}
  \label{fig:sketchpath}}
  \qquad
  \subfloat[The detailed path ]{
    \includegraphics[width=0.44\textwidth]{detailedpath.eps}
  \label{fig:detailedpath}}
  \caption{The untilted space-time graph  is partitioned into tiles depicted by square rectangles. These tiles are the vertices of the -sketch graph , in fact, two neighboring squares correspond to two neighboring vertices in . (a) The sketch path  is overlayed on . We partition  into three parts: (I)~first and last segments, which are depicted by solid segments, (II)~internal segments, which are depicted by dashed segments, and (III) routing in the last tile, which is depicted by a grey line. The source node of the packet request is in the first tile of the sketch path, the target node of the packet request is in the last tile of the sketch path. (b) The detailed path  is depicted by a thin line that traverses the same tiles traversed by the sketch path . The detailed routing  of the first segment is depicted by the horizontal line emanating from the source  node. The dashed line depicts the detailed routing after the first segment. The detailed routing of the last segment takes a turn on the entry side of the tile that contains the last bend. The detailed routing in the last tile is depicted by an straight dotted thin line.  The space-time copies of  are depicted by the grey rectangle that surrounds the target node.
  The intervals that are input to the interval packing algorithm are depicted by braces.}
  \label{fig:ddetail}
\end{figure}

\subsubsection{Detailed Routing in Internal Segments}\label{sec:detailed internal}
Detailed routing of internal segments takes place in a tile as follows. Fix a node
. The node  has two incoming edges and two outgoing edges. We denote these
edges by  and .  We refer to the
request that traverses an edge  by .  For example,  is the name
of the request that enters  via the horizontal edge. If an edge  is not
assigned to a request, then we set  to null. The rules for detailed routing of
these paths are as follows:
\begin{enumerate}
\item If one of the incoming edges  is not assigned to a request, then the other
  edge  (if  is not null) chooses the outgoing edge according to its
  exit side.
\item (Precedence to straight traffic.) Else, if the exit side of  is east or the
  exit side of  is north, then the paths continue without a bend,
  namely,  and .
\item (Simultaneous bends.) Else, a knock-knee bend takes place, namely,
   and . (see
  Figure~\ref{fig:knockknee}).
\end{enumerate}

We claim that detailed routing in an internal segment always succeeds.  If the
detailed path is headed towards its exit side (e.g., traverses the tile without a
bend), then detailed routing gives it priority so that it reaches its exit
side.  If the sketch path bends in the tile, then the detailed path must encounter
either a null path or another detailed path that also bends in the tile (in which
case the path takes the required turn). This is true because, otherwise, there would
be more than  paths that exit the tile from the same side, contradicting the
congestion guarantee by the \IPP\ algorithm (that at most  paths traverses the edges
between tiles).

\begin{figure}[H]
  \centering
    \includegraphics[width=0.4\textwidth]{knockknee.eps}
  \caption{A knock-knee bend in detailed routing in . Space-time nodes are depicted by white circles. The detailed route of  makes a turn in the vertical direction, thus freeing the suffix of the row . The conflicting detailed route takes a turn in horizontal direction, thus freeing the suffix of the column in the vertical direction.}
    \label{fig:knockknee}
\end{figure}


We now deal with transitions from part (I) to part (II) of detailed routing.
Recall, that each part of the detailed path uses a different track.
Consider a sketch path  whose first bend is in tile .
If the detailed routing of  reaches , then it is not preempted by
another special segment (see Sec.~\ref{sec:first detailed}).
As in detailed routing in internal segments, the detailed route of  in tile
 bends when it meets a null path or a detailed path that also wants to bend.
The same argument shows that such a bend is always successful.
After the bend, the path transitions from the first track to the second track.

We conclude that detailed routing is always successful in internal
segments.
\begin{comment}
We claim that detailed routing in internal segments is always successful also for
partial tiles.  This is true because straight paths (``rays'') are unblocked in
partial tiles, and if a turn needs to take place, then all  ``crossings'' exist
even if the tile is a partial tile. See Figure~\ref{fig:turn in partial tile} for a depiction of detailed
routing in partial tiles.




\begin{figure}[H]
  \centering
    \includegraphics[width=0.5\textwidth]{detailedint.eps}
    \caption{Detailed routing in internal segments for partial tiles. Although the
      tiles are partial, detailed routing works as if the tiles are complete. Two
      prefixes of detailed routing are depicted in the figure by black and grey
      curves. The top path is a first segment and the bottom path bends in a partial
      tile. Note that all possible crossings in the tile in which the bend takes
      place exist in the partial tile.}
\label{fig:turn in partial tile}
\end{figure}

\end{comment}



\subsubsection{Detailed Routing in the Last Tile}
We refer to requests whose sketch path is a single tile as \emph{near} requests.
Note that detailed routing of a near request consists only of part (III).

Detailed routing in the last tile routes a path along a straight vertical path from
the entry point to the row in the tile that corresponds to the destination node.
Note that if the destination vertex of  is , then it suffices to route the
path to one of the space-time copies of . Hence, every copy of  in the tile
is a valid destination. Contentions occur only in each column, and a path with a
closest destination preempts the conflicting paths.

\subsection{Analysis of the Algorithm for }\label{sec:analysis}

Recall that the length of a tile's side is . Moreover, in the case where  , it follows that .



\begin{theorem}\label{thm:alg}
  The competitive ratio of the algorithm for uni-directional line networks is  provided
  that .
\end{theorem}

\begin{proof sketch}{Theorem~\ref{thm:alg}}
The algorithm starts with the path packing algorithm \IPP\ over the -sketch graph.
This means that capacities are reduced by a factor of at most  (by the capacity assignment ``inside'' a tile and ``between'' tiles).
The fact that path lengths are bounded by  reduces the throughput only by a constant factor. The throughput of algorithm \IPP\ is -competitive.

Detailed routing succeeds in routing at least a  fraction of the sketch paths. There are two causes for loss of packets: routing of special segments and routing in the last tile.
Routing of special segments (i.e., first and last segment) succeeds for a fraction of .
we show that the success rate is not multiplied and that the success rate for special segments is . Routing in the last tile succeeds for a fraction of  per tile.
Putting things together we get a competitive ratio of , as required.
\end{proof sketch}

Note that the Theorem~\ref{thm:alg} actually applies for . The constant in the  linearly affects the constant in the competitive ratio of the algorithm.

\paragraph{Notation.}
Let  be a fixed sequence of packet requests introduced by the adversary.
Let  denote the set of requests whose sketch path ends in tile .
For every  and for every tile  let .
We interpret requests in  as path requests in .  Let  (respectively
) denote a maximum integral (respectively fractional) packing of paths from
 in .
Let  denote the set of requests that algorithm \IPP\ injected when
given input .  For brevity, we denote  simply by .
Similarly, let  denote the set of requests that \alg\ routed to their
destination.  Let  denote the set of requests that are not
preempted before they reach the entry side of their last tile.
(Note that .)
Let  denote an optimal fractional flow with respect to  over the sketch graph .
Let  denote an optimal fractional flow with respect to 
over the -sketch graph .
(Note that  and  are packings of paths in , while  and
 are packings in sketch graphs.)
Let  denote an  optimal fractional path packing in  with respect to  under the constraint that each request is routed along a path of length at most .
Let  denote an
optimal fractional flow in the sketch graph  with respect to
 under the constraint that flow paths have a length of at most .
Let  denote an
optimal fractional flow in the -sketch graph  with respect to
 under the constraint that flow paths have a length of at most .
Let  denote the throughput of flow .

\medskip
\noindent
We now present a detailed proof of Theorem~\ref{thm:alg}, based on the following propositions.
\begin{proposition}\label{prop:opt}
.
\end{proposition}
\begin{proof}
  Consider a fractional packing  of paths in  in which
  paths lengths are bounded by .  Let  denote the flow in
  sketch graph  where  is simply the sum of the flows of
   along the edges in  that are coalesced to  in
  . Clearly, . We claim that  is a feasible
  fractional flow in the sketch graph  whose flow paths are not
  longer than the flow paths in . (In fact, they are shorter by a factor of .)

  We show that the flow  satisfies the capacity constraints in 
  as follows. If  is a sketch edge between tiles, then, by
  linearity, the capacity constraint is satisfied.  We now focus on
  interior edges.  The amount of flow in  that traverses a tile in
   is bounded by the sum of the capacities of the
  edges in the tile, namely, it is at most . It
  follows that the amount of flow in  that traverses a node (that
  corresponds to a tile) in the sketch graph is bounded by the node's
  capacity (which equals ). We conclude that  is a feasible flow in , and the proposition follows.
\end{proof}

\begin{proposition}\label{prop:scaled}
    
\end{proposition}

\begin{proof}
  Recall that  is a maximum flow in the sketch graph  while
   is a maximum flow in .
The proof is a direct consequence of the following bounds between capacities in 
and in .

  For every edge  that is both in  and in , we have
  

 For every node  that corresponds to a tile, we have
  
\end{proof}

\begin{proposition}\label{prop:fipp}
    
\end{proposition}
\begin{proof}
By    Theorem~\ref{thm:IPP} (i.e., -competitiveness of \IPP),

Downscaling of capacities implies

and the proposition follows.
\end{proof}


The following proposition proves that a fraction of at most  of the
requests in \IPP\ are preempted before they reach their last tile.
\begin{proposition}\label{prop:preemptions}
    
\end{proposition}

\begin{proof}
  Consider a row or a column  of nodes in . Let  denote the set of requests that contain special
  segments that compete over edges in . From the point of view of
  , each request  is a request for an interval
  .
  As described in Section~\ref{sec:intervalp}, the detailed routing of the requests  along   simulates an optimal interval packing algorithm. In
  particular, the simulation has the property that if an interval
   preempts an interval , then the intervals overlap
  and . Hence, the edge  is in .


  Focus on preemptions that occur during the detailed routing of first segments (the
  case of last segments is similar). Consider the ``forest of preemptions'' over the
  intervals, where the set of intervals that were preempted by  are children of
  .  We claim that if interval  is a descendant of  in this forest,
  then the edge  is in .  The proof is by induction on the distance
  between  and  in the forest of preemptions. The induction basis holds for
  a child  by the discussion above.  Suppose that  preempted  (hence
  ). Since  is a descendent of , by the induction hypothesis
   is an edge in . Because  is preempted by  in a vertex
  to the left of , it follows that the edge  is in , as
  required.  By Theorem~\ref{thm:IPP}, the load induced by  on each
  -sketch edge is at most .  Therefore, the maximum number of
  proper descendants of  in the forest is  (not including ).

  Consider a bipartite graph of preemptions over 
  (now we consider both first segments and last segments). There is an edge
   if the request  is an ancestor of the request  in the forest of preemptions corresponding to detailed
  routing. Since a preempted request is preempted only once, the degree of the nodes
  in  is one.  Recall that each sketch path contains at most 
  special segments.  By the discussion above, the degree of a node in  is
  bounded by . By counting edges in the bipartite graph, we conclude that , and the proposition follows.
\end{proof}

The following proposition states that a fraction of at least  of the requests
that reach their last tile are successfully routed.
\begin{proposition}\label{prop:last}\label{prop:Rs}
    
\end{proposition}

\begin{proof}
  Since  is a partition of  and   is a partition of , it suffices to prove
  that  for every tile .

  Fix a tile .  Every sketch path of a request in  traverses the interior
  edge of  in  whose capacity is . Theorem~\ref{thm:IPP} implies that
  this capacity is violated by at most a factor of , hence .

  Detailed routing in the last tile successful routes at least one request from
   if , and the proposition follows.
\end{proof}

\noindent
We now put things together to complete the proof of Theorem~\ref{thm:alg}.
\begin{proof}[proof of Theorem~\ref{thm:alg}]
The proof is as follows.
  
The last line holds because every integral path packing is also a fractional one.
The theorem follows.
\end{proof}



\subsection{Requests With Deadlines}\label{sec:d_i}
In this section we present the modification needed to deal with packet
requests with deadlines.  The change to the algorithm is in the
reduction to online integral path packing (see Section~\ref{sec:reduce}), i.e., we need to change the sink node in the reduction as described below.

\newcommand{\sink}{\textit{sink}}

\paragraph{Adding Sink Nodes for Requests with Deadlines.}
A request to deliver a packet is of the form ,
where  is the deadline.  In terms of a path request in the space-time
graph , this means that we need to assign a path from
 to a vertex , where .
Thus, the destination is a set of vertices rather than one specific
vertex.
We connect this set of destinations to a new sink. Formally, for every
request , introduce a new vertex  and connect every vertex
in  to  with an edge of infinite
capacity.

Now, a packet request  is reduced to a path
request in the -sketch graph from the half-tile
 (where the tile  contains ) to .
A path from  to  contains at most  edges. We still bound the path length by , as before, to obtain a load of  by .

We claim that a request that is not preempted by detailed routing reaches its destination on time.
To see this fix a packet request  that is not preempted by detailed routing, and
let  denote its sketch path. Let  denote the tile in which  ends.  We now show that the detailed path  ends in a vertex  such
that .  There are  cases (see
Figure~\ref{fig:dltile}): (1)~ enters  via a last segment from
the south-west corner of , (2)~ enters  via a first segment from the west,
or (3)~ enters  via a first segment from the south\footnote{ Note that
  cases (2) and (3) are degenerate cases in the sense that the detailed routing
  consists only of the a first segment and routing in the last tile.}.  In the first two cases,  enters  and moves north
until it reaches a copy of .  The copy  of  that is reached must
satisfy  if  is in the tile.  Indeed, because  is the last
tile of , the copy of  in the leftmost column of  lies below the
``time-zone''  in the untilted space-time graph. Moreover, the entry point
of  to tile  lies below this copy of  (if it were above this copy of
, then it has already reached ).  In the third case,  enters via the
south side. This means that (before entering )  consists only of a first
segment, i.e., starting from its arrival the packet was forwarded and was not
buffered at all.  Since the deadlines are ``feasible'', i.e., the deadline , where  is the distance between  to .
The packet keeps moving north and reaches the copy of  at time . It follows that the packet reaches its destination on time in this
case as well.  We conclude that requests that are not preempted reach their
destination on time, as required.

\begin{figure}[H]
  \centering
    \includegraphics[width=0.5\textwidth]{dltile.eps}
  \caption{The  possible starting points of detailed routing in a tile.}
    \label{fig:dltile}
\end{figure}

\section{Generalizations}\label{sec:generalizations}
In this section we present a generalization of the algorithm to the -dimensional case as well as extensions to the special cases: bufferless grids and grids with large buffers\textbackslash capacities.

\paragraph{The -Dimensional Case.}\label{sec:algd}
The following modifications are needed to extend the algorithm to -dimensional grids.
\begin{enumerate}[(1)]
\item , where in the
    -dimensional case
  
    In the case where , it follows that .


\item Apply tiling with side length , e.g., a face of a cube contains  vertices.

\item Similarly to the -dimensional case, the sketch graph also has node capacities for nodes that correspond to tiles (i.e.,
not sinks). The capacity of every node that corresponds to a tile is .
Edges in the sketch path have unit capacities.

\item Similarly to the definition of -sketch graph, we define the
  -sketch graph by assigning a capacity of  (instead of )
  to the interior edges.

\item Detailed routing of internal segments is generalized as follows. Each node has
   incoming edges and  outgoing edges. Fix a node . Let
   denote edges that enter .  Similarly, let
   denote edges that exit .  Detailed routing in 
  proceeds as follows:
For every , let  denote the exit side of request
     in the tile  that contains .
  \begin{enumerate}
  \item (Precedence to straight paths.) If , then .
  \item (Try next crossing.) Else, if the exit side of  is not  or null, then
    .
  \item Else, if  or ( and  is the smallest index  for which ), then a knock-knee takes place:  and .
  \item (Try next crossing.) Else, .
  \end{enumerate}

  The key observation for detailed routing in an internal segment is that if a
  request  fails to bend at node , then another request proceeds in 
  toward its exit side (in the tile that contains ). Thus, as a request 
  continues to try to turn in the next crossing, it crosses a new request that will
  exit the tile successfully. Since the number of requests in  that traverse the same sketch edge is at most , it follows that  is bound to find a crossing in which it turns
  toward its exit side.

\end{enumerate}
The following theorem bounds the competitive ratio of the algorithm for general dimensionality . The proof of Theorem~\ref{thm:algd} is outlined in Appendix~\ref{sec:proofdd}.

\begin{theorem}\label{thm:algd}
  The competitive ratio of the algorithm for -dimensional grid
networks is  provided that .
\end{theorem}
\begin{comment}
  \begin{proof sketch}{Theorem~\ref{thm:algd}}
    Bounding path lengths incurs a constant loss to the competitive
    ratio. Algorithm \IPP\ incurs an additional constant loss to the
    competitive ratio. The capacity assignment of  reduces
    the throughput by a factor of . Finally, preemptions and detailed
    routing in the last tile incur a  loss to the
    competitive ratio. The theorem follows since .
  \end{proof sketch}
\end{comment}
\label{sec:extend}
\paragraph{Bufferless Grids.}
For the case  and  (no upper bound on ), we obtain
the following result. The proof of the following theorem is sketched in Appendix~\ref{sec:proofs}.
\begin{theorem}\label{thm:bufferless}
  There exists an online deterministic preemptive algorithm for packet
  routing in bufferless -dimensional grids with a competitive ratio of .
\end{theorem}

In the one dimensional case without buffers, the optimality of online interval
packing implies that the nearest-to-go policy~\cite{AKOR} is optimal.
\begin{proposition}
Nearest-to-go is an optimal policy for packet routing in a line when .
\end{proposition}

\paragraph{Large Buffers \& Large Link Capacities.}\label{sec:largeBc}
In this section we consider the case that the size of the buffers and the capacities
of the links are at least logarithmic.

Redefine the parameter , by   This of course influences  and 
because  and .
However, in this setting  is polynomial in  and .

The following theorem shows that it is easy to achieve a logarithmic competitive
ratio if  and .
\begin{theorem}\label{thm:largeBc}
  There exists an online deterministic algorithm for packet routing in
  -dimensional grids with a competitive ratio of  if ,
  and . In this algorithm, packets are either rejected or routed but not
  preempted.
\end{theorem}

\begin{proof}Scale  and  by setting  and .  Run the \IPP\ algorithm over the space-time graph
   with the scaled capacities  and  to decide which requests are
  rejected and which are routed. We claim that the routes computed by the \IPP\
  algorithm are a valid routing. Indeed, \IPP\ is -competitive with respect to
   and . Hence, the same packing of paths is -competitive
  with respect to  and .
  The theorem follows since .
\end{proof}


\section{A Randomized Algorithm for the One Dimensional Case}
\label{sec:randalg} In this section we design and analyze a
randomized algorithm for routing packets in uni-directional
line networks. Our randomized algorithm achieves a
competitive ratio of .

\begin{comment}
Recall that a unidirectional line network with  nodes is a directed path
. The vertices are denoted by .  The set of
directed edges is .
The parameters of the line network are:  nodes, buffer size  in
each node, and link capacity .  We assume that .

We assume that (i)~all edges have identical capacities, denoted by ,
(ii)~all nodes have the same buffer size, denoted by , and (iii)
\end{comment}
The randomized algorithm applies only to the setting in which requests are {without} deadlines (i.e., ),
hence each packet is specified by a -tuple .

The randomized algorithm deals with all values of buffer sizes and communication link
capacities in the range . We do not require that  as in the
deterministic algorithm.

In particular, it holds also for unit buffers.  In
Sec.~\ref{sec:preprocess}-\ref{sec:together} we deal with
the case that both  and  are in . We
consider this case to be the most interesting one. In
Sec.~\ref{sec:largeB} we deal with the case of .  In Sec.~\ref{sec:smallBlargec} we deal
with the case of  and .

\renewcommand{\arraystretch}{2}
\begin{table}[H]
\begin{centering}
\begin{tabular}{|c|c|c|}
\hline
 &  & Sections\tabularnewline
\hline
\hline
 &  & \ref{sec:preprocess}-\ref{sec:together} \tabularnewline
\hline
 &  & \ref{sec:largeB}\tabularnewline
\hline
 &  & \ref{sec:smallBlargec}\tabularnewline
\hline
\end{tabular}
\par\end{centering}
\caption{Values of  and  in which our algorithm achieves logarithmic competitive ratio. In particular, it holds also for unit buffers, i.e., . We consider the first case to be the most interesting one.}
\label{table:discussion}
\end{table}
\renewcommand{\arraystretch}{1}
\subsection{Outline of Modifications}\label{sec:comparison}
Our goal is to reduce the   competitive ratio of the deterministic algorithm (see
Theorem~\ref{thm:alg}) to a logarithmic competitive ratio with
the help of randomization.  In this section we outline the techniques that are
employed to achieve this goal.

In the randomized algorithm, the online integral packing algorithm is
applied to the sketch graph (without downscaling of capacities). To
simplify the discussion assume that .  Since the load on every
edge in the sketch graph is at most , and  also equals the length of
the tile side, this implies that  paths traverse each tile side.

The ratio between the area and the perimeter of a tile is .
As the number of requests that start in a tile is proportional to the
area of a tile, and the number of requests that can enter or exit a tile
is proportional to the perimeter of a tile, we need to avoid losing a
factor of  in the competitive ratio. We do this by
\emph{randomly sparsifying} the requests. The goal of this
sparsification is to leave a  fraction of the requests so
that a constant fraction of the remaining requests can be routed out
of their starting tile.

To facilitate detailed routing, we consider three (non-disjoint) areas within each
tile: (1)~a part in which new requests may start, (2)~a part dedicated to routing,
and (3)~a part in which requests reach their destination.  The tiles are randomly
shifted so that a constant fraction of the requests ``agree'' with the designated
parts in the tiles.

Detailed routing of requests not rejected by the \IPP\
algorithm or by random sparsification is simpler and always
succeeds.

\subsection{Preliminaries}\label{sect:prelimline}


\begin{comment}
\begin{figure}\centering
\includegraphics[width=0.6\textwidth]{sketchuntilt.eps}
\caption{
Tiling of the untilted space-time graph  by rectangles. Only the shaded tiles are nodes of the sketch graph. Note that if the SW-quadrant of a tile does not contain nodes from , then this tile is removed.
The sketch graph over the tiles is depicted by the black circles and the incident directed edges.}
\label{fig:sketch}
\end{figure}
\end{comment}

\paragraph{Tiling.}
The untilted space-time graph  is partitioned into rectangular
tiles.  We denote length of each tile by  and the height by 
(we also require that  and  are even).  Note that tiles may
not be squares as in the deterministic algorithm.  Dummy nodes are
added to the space-time graph  so that all the tiles are
complete.

\paragraph{Random Shifting.}
The tiling is specified by two additional parameters  and , called the \emph{phase shifts}.  The phase shifts determine the position of the ``first'' rectangle; namely, the node  is the bottom left corner of the first rectangle.

\medskip\noindent
Recall that the sketch graph has a node for every tile in the space-time graph (see
Section~\ref{sect:sketchgraph}).
Each horizontal edge has a capacity of , and
each vertical edge has a capacity of ,

\paragraph{Near and Far Requests.}
A request  is classified as a \emph{near request} if the tile that
contains  also contains a copy of  (namely, the tile contains a
vertex  for some ). A request that is not a near request is classified
as a \emph{far request}. We denote the set of near and far requests by \near\ and
\far, respectively.

A routing of a request  cannot be confined to a single tile. A
routing of a request  may be within a tile or may span more than one
tile (our algorithm attempts to route near requests only within a single tile).

\paragraph{SW-Far requests.}
We partition each tile of the untilted space-time graph into four ``quadrants'' as depicted
Fig.~\ref{fig:quad}.
\begin{figure}[h]
  \centering
    \includegraphics[width=0.3\textwidth]{parallel.eps}
  \caption{The south-west (SW) quadrant of a tile.}
\label{fig:quad}
\end{figure}


The tiling and random shifting defines the following random subset of the requests. Let
 denote the subset of requests whose source vertex is in SW-quadrant of a tile.
The subset  is defined by


\paragraph{Online Integral Packing of Paths of Far Requests.}
The \IPP\ algorithm is applied only to  requests
over the sketch graph  (see Line~\ref{line:IPP} in
Algorithm~\ref{alg:algRand}).

\begin{comment}
In the randomized algorithm the reduction deals with the following issues: (1)~Handling requests only \emph{between} tiles (we deal with requests inside a tile separately), (2)~the \IPP\ algorithm the capacities of the sketch graph  are \emph{not changed}, and (iii)~as before, a specific sink destination is added for each request. Hence, all we need is to add  sink nodes (see Figure~\ref{fig:st}).
\end{comment}

\paragraph{Multiple Simultaneous Requests from The Same Node.}
If multiple requests arrive simultaneously to the same
node, then even the optimal routing can serve at most 
packets among these packets. Since this limitation is
imposed on the optimal solution, the path packing algorithm
can abide this limitation as well without decreasing its
competitiveness. The online algorithm chooses  packets
whose destination is closest to the source node, as
formalized in the following proposition.

\begin{proposition}\label{prop:filter}
    W.l.o.g. each node injects at most the closest  requests at each time step.
\end{proposition}


\subsection{Randomized Algorithm: Preprocessing}\label{sec:preprocess}

\paragraph{Tiling parameters.}
The tile side lengths are set so that the trivial greedy routing algorithm is -competitive for requests classified as near. Each tile has length  and
height .
Recall that .
\begin{defn}\label{def:xy}
    \begin{enumerate}[(i)]
    \item
    If , then
     and .
    \item
    If , then
      and .
\end{enumerate}
\end{defn}

\begin{proposition}\label{prop:tiling}
The choice of the tiling parameters implies the following:
  \begin{enumerate}
\item .
  \item The capacity of each sketch edge is at least .
  \item The ratio of maximum capacity to minimum capacity in the sketch graph is bounded by .
 \end{enumerate}
\end{proposition}

\begin{proof}
  The first part of the proposition follows from the assumption that .  The capacity  of a horizontal edge  in the sketch graph is .
If , then  and all the sketch edges have the same capacity.
If , then .
Moreover, the ratio of maximum capacity to minimum capacity is bounded
by . Indeed,
      
Similarly, the ratio , and the proposition follows.
\end{proof}

To simplify the presentation, we assume that 
(we can obtain this by reducing the capacities by a factor
of at most , which affects the competitive ratio only by
a factor of ). Let  denote the capacity of the
sketch edges to the neighboring tiles.



\begin{proposition} \label{prop:class}
  If the phase shifts  and  are
  chosen independently and uniformly at random, then .  By a reverse Markov inequality, 
\end{proposition}


\begin{proof}
  Since the phase shifts  and  are independent
  and uniformly distributed, the probability that a request 
  is also in  is .  By linearity of expectation, .

  Plugging ,  and
   in Lemma~\ref{lemma:revMarkov} (See
  Appendix~\ref{sec:RevMarkovproof}) yields the second part of the
  proposition, i.e., .
\end{proof}


\subsection{Algorithm for Requests in \far}\label{sec:far}
In this section we present an online algorithm for the
requests in the subset . Similarly to the
deterministic algorithm in Section~\ref{sec:outline}, the
-Algorithm invokes the \route\ algorithm (in
Step~\ref{line:IPP}) and applies detailed routing (in
Step~\ref{line:I}). The additional randomized steps are
employed in Step~\ref{line:toss}, and Step~\ref{line:load}.
Note that randomized algorithm is non-preemptive, that is,
if a packet is not rejected then it is guaranteed to arrive
to its destination.

\subsubsection{Description of The -Algorithm}
\paragraph{Parameters.}
Set the maximal path length in the sketch graph to be . We set
the probability  of the biased coin in step~\ref{line:toss} of
 to be , where .

\begin{algorithm}
    \textbf{Upon arrival} of a packet request  in 
    proceeds as follows (if  is rejected in any step, then the algorithm does not continue with the next steps):
\begin{enumerate}
\item
\label{line:IPP}


Reduce the packet requests to an online integral path
packing over the sketch graph with paths of length at
most . Execute the \route\ algorithm with respect
to these path requests. If the path request is rejected
by the \route\ algorithm then \textbf{reject} .
Otherwise, let  denote the sketch path assigned
to request .

\item \label{line:toss} Toss a biased - coin  such that
  . If , then \textbf{reject} .
\item
\label{line:load}\label{item:quarter}
If the addition of  causes the load of any sketch edge to be at least
, then \textbf{reject} .
\item\label{line:I} Apply -routing to .  If -routing fails,
  then \textbf{reject} . Otherwise, \textbf{inject}  with
  the sketch path  and alternate between -routing and
  -routing.
\end{enumerate}
\caption{The -Algorithm. The input to the algorithm is a sequence of packet requests in  and it either rejects or injects.}\label{alg:algRand}
\end{algorithm}


The listing of the randomized algorithm appears in
Algorithm~\ref{alg:algRand}.
The input to the algorithm is the sequence of requests in  which is processed as follows:
\begin{inparaenum}[(1)]
\item The \route\ algorithm computes an integral packing of paths over the sketch graph 
  under the constraint that the length of a path is at most
  . In Proposition~\ref{lemma:nB}, we show that this
  constraint reduces the optimal fractional throughput by a factor of
  at most two. Algorithm \IPP\ remembers all accepted requests, even
  those that are rejected in subsequent steps. By
  Theorem~\ref{thm:IPP}, the computed paths constitute an
  -competitive packing, for .
\item The probability  is set to .
\item We maintain the invariant that after line~\ref{line:load}, the
  load of every sketch edge is at most .
\item -routing deals with routing the request out of the initial
  SW-quadrant and is described in Sec.~\ref{sec:detail}.  The rest of
  the path is computed based on the sketch path . This
  computation is performed locally and on-the-fly by alternating between two routing
  algorithms called -routing and -routing (described in
  Section~\ref{sec:detail}).
\end{inparaenum}

\paragraph{Remark.}
One may consider applying random sparsification before the \route\ algorithm is
  invoked. The motivation for such a variation is to avoid congesting the network
  with requests destined to be rejected. Apart from reducing the load of sketch
  edges, random sparsification facilitates successful -routing (see
  Lemma~\ref{lemma:sparse}). This means that sparsification needs to be applied after
  the online path packing algorithm.

\subsubsection{Detailed Routing}\label{sec:detail}
The \IPP\ Algorithm computes a sketch path . If we wish to
route the packet, we need to compute a path in . We refer
to this path as the \emph{detailed path}.
Three routing algorithms are employed for computing different parts the detailed path (see Fig.~\ref{fig:detail}):
\begin{inparaenum}[(1)]
  \item -routing: from  to the north or east boundaries of the SW-quadrant.
  \item -routing: deals with routing in the north-west quadrant (NW-quadrant) and  the south-east quadrant (SE-quadrant) of a tile.
  \item -routing: -routing deals with routing in the north-east quadrant (NE-quadrant).
\end{inparaenum}
Let  denote the subset of requests that were successfully routed by -routing.
Let  denote the detailed path of a request .
The packing  satisfies the following
invariants:
    \begin{figure}[h]
      \centering
        \includegraphics[width=0.35\textwidth]{detail.eps}
      \caption{Allowed detailed routes in tile quadrants. Paths may not
        cross the thick lines.}
      \label{fig:detail}
    \end{figure}
\begin{enumerate}
\item The source of  is in the SW-quadrant of a rectangle.
\item The prefix of  till it exits the SW-quadrant is straight.
\item For every tile,  may enter the tile only through the right half of the south side or the upper half of the west side.
\item For every tile,  may exit the tile only through the right half of the north side  or the upper half of the east side.
\item Except for the first bend of , every bend
    corresponds to a bend in the sketch path .
\item At most  paths are routed out of the
    SW-quadrant.
\item The load of every edge in  is at most one (i.e., all capacity constraints are satisfied).
\end{enumerate}

\paragraph{-Routing.}
The goal of -routing is simply to exit the SW-quadrant
either from its east side or its north side. -routing
deals with routing paths that start in the SW-quadrant of a
tile till the north or east side of the SW-quadrant.
-routing uses only straight paths.


By Proposition~\ref{prop:filter}, at most  requests
are input at each node of  to Algorithm \route.
These requests are ordered arbitrarily.  We therefore
consider each SW-quadrant as a three dimensional cube of
dimensions  where each node in the quadrant has  copies.
The th request that arrives to node  is input to
node  in the cube.  We refer to each copy of the
quadrant in the cube as a \emph{plane}.  Namely, the th
plane is the set of nodes  in the cube.
-routing deals with each  plane separately,

-routing tries to route horizontally the first  requests that
start at a node. Similarly, -routing tries to vertically route the
 requests that arrive after that.  By trying to route a request,
we mean that if the corresponding row or column in the plane is free,
then the request is routed (and that row or column in the plane is
marked as occupied); otherwise the request is rejected.

Finally, we  limit the number of paths that emanate from each
side of the SW-quadrant by , where  denotes the capacity
of the sketch edges to the neighboring tiles. Thus after  requests have been successfully
-routed out of the SW-quadrant, all subsequent requests from this
SW-quadrants fail.

 Note that -routing is computed
before the packet is injected and does not preempt packets (after they are injected) since
precedence is given to existing paths.

\paragraph{-routing.}
The NW-quadrant and the SE-quadrant have a ``blocked'' side
that is depicted by a thick link in
Figure~\ref{fig:detail}. Paths may not traverse the blocked
side. -routing deals with routing in these two
quadrants. Paths may enter these quadrants from two sides
but must exit through a third side (unless they reach a
copy of their destination).  We show that -routing is
always successful (in fact, -routing is similar to
detailed routing in internal segments described in
Sec.~\ref{sec:detailed internal}).

Consider a SE-quadrant: each path enters through the south or west sides of the
quadrant, and should be routed to the north side of the quadrant. The detailed paths
of south-to-north paths are simply vertical paths without bends (such paths are given
precedence). The detailed paths of west-to-north paths are obtained by traveling
eastward until a bend can be made, namely, the vertical path to the north side is not
saturated.  Since both path types contain at most  paths, and since 
paths can cross the north side of the quadrant, -routing never fails.

\paragraph{-routing.}
-routing deals with routing in the NE-quadrant. Note
that a path may enter the  NE-quadrant from its west side
or from its south side. Moreover, a path may exit the
NE-quadrant from its east or north side. We show that
-routing is always successful.

-routing is implemented by super-positioning two
instances of -routing (see Fig.~\ref{fig:X-routing}). We
partition the traffic in a NE-quadrant to two parts based
on the side from which the path exits the quadrant. As in
-routing, precedence is given to straight traffic.  A
bend takes place whenever a free path is available.
Clearly, a straight path is successfully routed. Paths that
needs to turn are blocked by at most  paths from the
other part. There are at most  paths that need to
turn, and the capacity of the side of the quadrant is
, hence -routing is always successful. (Note that
knock-knee bends are not required, although they could be
incorporated.)

    \begin{figure}[h]
      \centering
        \includegraphics[width=0.36\textwidth]{xrouting.eps}
      \caption{-routing is implemented by super-positioning two instances of -routing depicted by black and grey arrow.}
      \label{fig:X-routing}
    \end{figure}

\paragraph{Last Tile.}
Detailed routing in the last tile employs greedy shortest path routing.  If a packet
enters the last tile from the south side, then it simply continues north until it
reaches its destination. Note that no such packet may enter the last tile from the
west side. Indeed, if a sketch path enters  from the west side and  is the last
tile in the sketch path, then the neighboring tile from the west contains a copy of the
destination, and hence  is not the last tile in the sketch path.

\subsubsection{Analysis}

\paragraph{Notation.}
We define the following chain subsets of requests
 as follows.   is the
subset of requests accepted by the  algorithm in
Line~\ref{line:IPP}.  is the subset
of requests for which the biased coin flip  equals 
in Line~\ref{line:toss}.   is the
subset of requests whose addition did not cause a sketch
edge to be at least  loaded in Line~\ref{line:load}.
 is the subset of requests for
which detailed routing is successful in Line~\ref{line:I}
(recall, that only -routing may fail).

Let  (respectively, ) denote an optimal fractional
(respectively, integral) packing of paths in  with respect to the
requests . An optimal packing of paths in the space-time graph  in
which the length of the paths in the packing is bounded by  is
denoted by .


The following theorem states that the invocation of the \IPP\ algorithm
assigns routes to a constant fraction of an optimal solution.
\begin{theorem}\label{thm:IPP rand}
  
\end{theorem}
\begin{proof}
  The proof of the theorem is divided into three parts (summarized by
  Equations~\eqref{eq:part 1}-\eqref{eq:part 3}).  The first part states that a fractional
  packing is not smaller than an integral one.
  

  The second part shows that bounding the path lengths reduces the throughput only by
  a factor of .
  \begin{lemma}[\protect{\cite[Claim 4.5]{AZ}}]\label{lemma:nBline} Let
    .  Then,
    \end{lemma}

  The third part shows that paths of length at most  in the space-time graph
  are mapped to paths of length at most  in the sketch graph.
  \begin{proposition}\label{prop:4n}
    Every path  in  of length at most  is mapped to a path  in the sketch graph  of length at most . Hence, by the
    -competitiveness of the \IPP\ Algorithm, it follows that:
    
  \end{proposition}

\begin{proof}
  Let  denote a path of length at most  in
  . We partition the edges of  into horizontal edges and vertical
  edges in .  The number of vertical edges in  is bounded is  and the
  same holds also for .

  We now prove that the number of horizontal edges in  is at most . For
  every row  in , let  denote the number of horizontal edges of 
  in the th row.
  Similarly, for every row  in the sketch graph, let 
  denote the length of the intersection of  with the th row of the sketch graph.  Let  denote the interval of rows of
   that are mapped to the th row of the sketch graph (note that
   is simply the height of a tile).

  By Def.~\ref{def:xy}, the length of every tile is at least . Indeed, if , then the length  equals .  If , then the length
  .  It follows that
  
  Hence, . We conclude that the length of the path  is at most , as required.
\end{proof}
Equations~\eqref{eq:part 1}-~\eqref{eq:part 3} completes the proof of Theorem~\ref{thm:IPP rand}
\end{proof}


The following proposition shows that, in expectation  over the biased coins
tosses in Line~\ref{line:toss}, at most a quarter of the sketch paths are
rejected due to ``-loaded''  edges in line~\ref{line:load} of the
-Algorithm.
\begin{lemma}\label{lemma:Rinj}
If , then

\end{lemma}

\begin{proof}
The idea it to show that, after random sparsification, the load of every sketch edge is at
most  with high probability. This implies that few requests are rejected
as a result of causing the load of an edge to be greater than .

Let  denote the sketch path of .  Given a sketch edge , let  denote the set of sketch
paths that traverse .  Similarly, let  denote the set of paths that traverse  after random
sparsification.  We first claim that, for a constant , for , and
for every sketch edge , 
We now prove Equation~\eqref{eq:1}.  Since  is -competitive, it follows
that  The tossing of the biased coins with  with , implies that


\noindent
The following sequence of equations is explained below.
    
    The first line holds if  satisfies .
The second line is due to a multiplicative Chernoff bound~\cite{MU}.
The third line is implied by Proposition~\ref{prop:tiling} since
    .
The last line follows by the definition of .

Since  and , then  and therefore,  and Equation~\eqref{eq:1}
    holds.


Since , the length of each sketch path is at most .  By
    Equation~\eqref{eq:1} and by applying a union bound it follows that

The lemma follows by linearity of expectation.
\end{proof}

The following theorem states that, in expectation, a  fraction
of the requests that are accepted by the \route\ algorithm are successfully routed.
\begin{theorem}\label{theorem:Rinjt}
  .
\end{theorem}

\begin{proof}
  We first prove a Lemma and a Proposition. Lemma~\ref{lemma:sparse} deals with a
  projection of a random sparsification of a - matrix. This
  lemma helps estimate the number of requests from  for which
  -routing is successful in each plane (ignoring the effect of
  line~\ref{line:load} in the algorithm).
Proposition~\ref{proposition:dom} helps analyze the effect of
  line~\ref{line:load} on the number of requests for which
  -routing is successful.

\paragraph{Definitions.}

Let  be an operator over - matrices defined as follows.  is all
zeros except for the first nonzero entry in each row of . Namely,

The motivation for this definition is as follows. Suppose
that the matrix  indicates the existence of packets in a
plane of a SW-quadrant in which packets are routed by
-routing along rows out of the quadrant. The only
packets for which -routing succeeds in this plane are
the packets that correspond to ones in .

Let  denote the matrix obtained by the coordinate-wise
conjunction of  and . For a matrix , let  denote the number of
's in .

In the following lemma we analyze the effect of random sparsification on -routing along the rows of the SW-quadrant.
A similar effect occurs when considering -routing along the columns of the SW-quadrant.
\begin{lemma}\label{lemma:sparse}
  Let  and  be - matrices whose dimensions are . Assume that the entries of  are i.i.d. -
  random variables with .  Let . Then,
  
\end{lemma}
\begin{proof}
  Consider each row  of  and  of  separately.  The expectation of the
  - random variable  equals the probability that it equals .
  Note that

Since , it follows that ,
and hence

The lemma follows by linearity of expectation.
\end{proof}

We now return to the proof of Theorem~\ref{theorem:Rinjt}.  For every tile
consider its SW-quadrant as a three dimensional cube of dimensions
. Recall that -routing deals with
each  plane separately.

The lengths  and  of each tile are at most .  Recall that
 where . Hence,
if , then .

Assume that we skip Step~\ref{item:quarter} of the algorithm (namely, we do not check
that the load is bounded by ), and apply directly -routing to the requests in
. Let  denote the set Ir_i.  We consider each of the  planes separately, and by
Lemma~\ref{lemma:sparse} and linearity of expectation, we obtain


Furthermore, Lemma~\ref{lemma:Rinj} implies that:


Hence,


\paragraph{Notations.}
For a - matrix , let  denote negated matrix
.  For matrices  and , let 
denote , for every  and .

\begin{proposition}\label{proposition:dom}
If   then:
  
\end{proposition}

\begin{proof}
  It suffices to deal with each row separately. Let  denote the th row
  of the matrix . We claim that if , then  or
  .  Indeed, assume that  and
  . Then,  is all zeros. Hence, , and
  the proposition follows.
\end{proof}

\noindent
We now prove the following lemma.
\begin{lemma}\label{lemma:combine}
    For every outcome of the random biased coins:
  
\end{lemma}
\begin{proof}
  Consider a specific tile  and its SW-quadrant.  Fix an -plane used by
  -routing. W.l.o.g this -plane corresponds to a horizontal -routing. Define
  three - matrices  and  with dimensions , as
  follows:
  \begin{enumerate}
  \item Let  be the matrix whose entries indicate the existence of a request  whose source vertex is in the th plane of the SW-quadrant of the tile
    . Namely,  iff node  receives at least  requests in
    .
  \item Let  denote a random matrix in which the entries are i.i.d. Bernoulli
    random variables with . These Bernoulli random variables
    correspond to the outcomes of the biased coin tosses in Step~\ref{line:toss} of
    the algorithm.
  \item Let  be the matrix whose entries indicate the existence of a request  whose source vertex is in the th plane of the SW-quadrant of the
    tile .
  \end{enumerate}


  For a subset  of requests, a tile , and a plane index , let
   denote the subset of requests in  whose source vertex is in
  the th plane of the tile .  Let  denote the negation of .  By
  definition the following identities hold:
  \begin{enumerate}[(i)]
    \item ,
    \item ,
    \item ,
    \item .
  \end{enumerate}

It suffices to prove that

Since , Equation~\eqref{eq:suffice} follows from Proposition~\ref{proposition:dom}, and the
lemma follows.
\end{proof}

We now complete the proof of Theorem~\ref{theorem:Rinjt}. By
Lemma~\ref{lemma:combine} and Equation~\eqref{eq:almostqed}, it follows that
. Theorem~\ref{theorem:Rinjt}
follows since .
\end{proof}


\begin{theorem}\label{thm:far}
  .
  \end{theorem}
  \begin{proof}
 By Theorem~\ref{theorem:Rinjt}, it follows that
    . By
    Theorem~\ref{thm:IPP rand}, . The theorem follows since .
  \end{proof}
\subsection{Algorithm for Requests in \near}\label{sec:near}
In this section we present an online algorithm for the requests in the
subset .  The algorithm is a straightforward greedy vertical
routing algorithm.
Given a request , the algorithm
attempts to routs the request vertically.

\begin{comment}
Upon arrival of a request , the computation of the path
for  proceeds as follows:
\begin{enumerate}
    \item Let .
    \item While the vertical path from  to  is saturated:
    \begin{enumerate}
        \item If the horizontal edge is not saturated move to the right (i.e, ).
        \item Else, if the horizontal edge saturated then \textbf{reject}.
        \item If  is outside the tile, then \textbf{reject} .
    \end{enumerate}
    \item If a nonsaturated vertical path is found, then the path consists of the
        concatenation of the horizontal path from  to  and
        the vertical path from  to .
\end{enumerate}
\end{comment}
We emphasize that an optimal routing is not restricted to routing a
request  within the tile.

\paragraph{Notations.}
Let  denote the set of requests successfully routed by the \near-Algorithm
with respect to the requests in .  Let  denote the set of requests
routed by the \near-Algorithm within the tile . Let  denote the set of
requests in  whose starting node is in the tile . We abuse notation and
refer to the set of routed packets in an optimal routing with respect to \
also by .

\begin{theorem} \label{thm:near}
For every tile ,
  .
\end{theorem}



\begin{proof}
    It suffices to prove that

We consider a bipartite conflict graph between requests in 
and . There is an edge  if
the vertical path of  shares an edge with the path of  in .

Since at most  requests  can traverse the same vertical
edge, it follows that a route of a request in 
conflicts with at most


If , then it either encountered a saturated
horizontal edge or a saturated vertical edge. Hence, the degree of
 is at least

By counting edges on each side we conclude that

By Definition~\ref{def:xy}, , and
the theorem follows.
\end{proof}


\begin{coro}\label{coro:near}
.
\end{coro}
\subsection{Putting Things Together}\label{sec:together}
The online randomized algorithm \alg\ for packet routing on a directed
line proceeds as follows.
\begin{enumerate}
\item Choose the tiling parameters  according to Definition~\ref{def:xy}.
\item Choose the phase shifts  of
  tiling independently and uniformly at random.
\item Flip a random fair coin .
\item If , then consider only requests in , and apply the
  -algorithm to these requests.
\item If , then consider only requests in , and apply the
  -algorithm to these requests.
\end{enumerate}

\begin{theorem}\label{thm:algrand}
  If , then the competitive ratio of \alg\ is .
\end{theorem}
\begin{proof sketch}{Theorem~\ref{thm:algrand}}
    The chosen tiling parameters and phase shifts induce a classification of the requests to two classes:  and .
    With probability  the random fair coin  chooses the bigger class.
    Theorem~\ref{thm:far} and Corollary~\ref{coro:near} state that  and  are  competitive, and the theorem follows.
\end{proof sketch}

\subsection{Large Buffers} \label{sec:largeB}

In this section we consider a special setting in which the buffers are large.
Note that the Algorithm fails if  both with near and far requests.
Formally, assume that .

We briefly mention the required modifications.  The tiling parameters are 
and .  This implies that there are no near requests and all requests are
classified as far.  Each tiles is partitioned in to a left half and a right half.
The algorithm considers only requests whose source vertex is in the left half of a
tile; such requests are denoted by . Note that random shifting is employed so
that on the average  contains half the requests.

The north and south side of the left half of each tile are ``blocked'' so that
detailed routing does not traverse these sides.  This means that -routing is only
along horizontal edges.  In the right half of each tile, three -routing are super
imposed. The first -routing is for the paths that enter the tile from the west
side. These paths traverse the left half horizontally and then in the right half
undergo -routing (so that they exit from the east or north side of the right
half).  The second -routing is for the paths that enter the tile from the south
side of the right half. Finally, the third -routing is for continuing the paths of
the -routing from the border between the halves to the north and east sides of
the right half of the tile.

Path lengths are bounded as before (this is why we require
that  is polynomial).  In addition the random
sparsification parameter  is the same.

The algorithm proceeds as follows:
\begin{enumerate}
\item Execute the \route\ algorithm with respect to the path requests in  over
  the sketch graph.

\item \label{line:toss 2} Toss a biased - coin  such that . If , then \textbf{reject} .

\item
\label{line:load 2}\label{item:quarter 2}
If the addition of  causes the load of any sketch edge to be at least
, then \textbf{reject} .

\item\label{line:I 2} Apply -routing to .  If -routing fails, then
  \textbf{reject} . Otherwise, \textbf{inject}  with the sketch path  and apply -routing till the destination is reached.
\end{enumerate}

In this setting, the ratio between the capacity of the sketch edges that emanate from
a tile to the number of requests whose source vertex is in the tile is constant. This
constant ratio simplifies the proof of the following theorem compared to the proof of
Theorem~\ref{thm:algrand}.

\begin{theorem}
  If , then there exists a randomized online algorithm
  that achieves a logarithmic competitive ratio for packet routing in a
  uni-directional line.
\end{theorem}

Recall that for the case where  and , there is an even simpler
and \emph{deterministic} online algorithm with 
competitive ratio, as stated in Theorem~\ref{thm:largeBc}.

\subsection{Small Buffers \& Large Link Capacities}\label{sec:smallBlargec}
The case  and  is dealt with
by simplifying the algorithm. We briefly mention the required
modifications. The tile size is  and .  The maximum
path length is set to  which is polynomial (i.e.,
tiling is not needed to reduce the path length).  Instead of
partitioning a tile into quadrants, we partition each tile into an
upper half and a lower half. The set  is defined to the set of
requests whose origin is in the lower half of a tile.

The set  is dealt by a vertical path. Since in every
tile ,  and
since , it follows that .

The set  is dealt by invoking a variation of the
-Algorithm. The modified invariants for detailed
routing are that paths may not enter or exit horizontally
through the lower half of a tile (but, of course, may
traverse the tile vertically).  -routing simply routes
the first  requests vertically. The
remaining capacity of  is reserved for incoming
paths from the south side. In the upper half of each tile,
-routing on a single column is employed.

We conclude with the following theorem.
\begin{theorem}
  If  and , then there exists a randomized
  online algorithm that achieves a logarithmic competitive ratio for packet routing
  in a uni-directional line.
\end{theorem}


\begin{comment}
\begin{verbatim}

b<logn and n^2 > c > log n

B > m^{O(1)} and c > \log n

for the case of \section{Large Buffers \& Large Link Capacities} the requirement on c is
not required.

Superpoly B...maybe using the poly(n) pipelining?
\end{verbatim}
\end{comment}

\paragraph{Remark.}
The space-time graph seems to assign symmetric roles to the time axis and the space
axis.  Such a symmetry would imply that one could reduce the case of large buffers to
the case of large link capacities. However, this is not true due to the definition of
a destination.  A destination (in the space-time graph) is a row of
vertices (namely, the set of copies of an original vertex).
This implies that one cannot simply transpose the graph and exchange the roles of
space and time.


\section{Open Problems}
Two basic problems related to the design and analysis of
online packet routing remain open even for uni-directional
lines.
\begin{inparaenum}[(i)]
\item Achieve a constant competitive ratio or prove a lower
    bound that rules out a
  constant competitive ratio.
\item Achieve a logarithmic competitive ratio by a distributed algorithm (as opposed
  to a centralized algorithm).
\end{inparaenum}

\subsection*{Acknowledgments}
We thank  Niv Buchbinder, Boaz Patt-Shamir and Adi Ros{\'e}n for useful discussions.

\bibliographystyle{alpha}
\bibliography{bib_sicomp}




\appendix

\section{Proof of Lemma~\ref{lemma:nB}}\label{sec:proofnB}

The following lemma shows that bounding path lengths in a fractional
path packing problem over a space-time graph to a polynomial
length decreases the fractional throughput only by a constant factor.  The
lemma is an extension of a similar lemma from~\cite{AZ}.

Consider a directed graph  with edge capacities  and
buffer size  in each vertex.  Let  denote the space-time
graph of  (see Section~\ref{sec:spacetime}).  Let .  Let
 denote the length of a shortest path from  to  in
. Let  denote the diameter of  defined as follows


\textbf{Lemma~\ref{lemma:nB}} \emph{Let , , and .  Then, }

\begin{proof}
  Let  denote an optimal fractional path packing in  with respect to a set of flow
  requests , that is .   The flow  has a
  throughput that is half the throughput of  and the load of each edge
  is at most .

  Consider the following pipelining scheme. The time dimension is partitioned into
  intervals at multiples of . Let  denote the set of edges in  defined by
  
  The fractional flow we construct is the sum of two flows  and 
  defined as follows.  The flow  is based on the flow ,
  where flow paths that traverse , for , are modified as
  follows:
  \begin{inparaenum}[(i)]
  \item If a flow path  in  traverses , then split the
    path  as follows: keep a fraction  of  in
    the flow  and transfer an -fraction of  to .
  \item Cancel what is left of flow paths in  that traverse
     if they started at time .
    Such flow paths correspond to packets that have been buffered
    (instead of forwarded) during many time steps.
  \end{inparaenum}
  Note that path flows of  that start between cuts are added
  to . The flow  is a simple routing along shortest paths in which incoming
  flow (that needs to be further routed) is forwarded towards its
  destination without any buffering. (Note that  does not use edges in .)

  We claim that the choice of parameters implies that  is a legal
  flow that succeeds in shipping all the flow that is transferred to
  it.  Consider all the flow that is transferred to  in .
  We show all this flow reaches its destination without any need to
  cross the next cut .  Moreover,  incurs a load of at
  most  on each edge. Thus, the flow  can be viewed as
  separate flows between consecutive cuts.

  Note that the time that elapses between two consecutive cuts equals
  the diameter of .  This means that every flow path can be
  augmented by a shortest path to its destination before the next cut.

  To show that the load incurred by  on each edge is at most ,
  suppose that all the flow that is transferred to  in 
  traverses the same edge in .  The amount of flow
  transferred to  is bounded by , and hence the load in  is bounded by  as required.

  We claim that the throughput of  is at least  times
  the throughput of . Indeed, flow is lost only when a residue
  of a flow path is canceled.  This happens only after a flow path
  traverses  cuts.  By this time, the flow along this
  path has been decimated to a fraction of  of its initial amount.

To complete the proof, note that the length of each flow path in 
is at most . The number of edges of a flow path
in  that are in  is at most . The number of edges of a flow path in 
that are in  is less than , and flow paths in  lack edges in .
\end{proof}


\begin{comment}
\section{Partial Tiles for }\label{appendix:partial}

In this appendix we discuss partial tiles for the case of .
In this case the standard drawing of the space-time graph  is -dimensional, thus tiles are cubes.


A cube in the untilted space-time graph is \emph{partial} if it intersects the plane .
When  there are  types of partial cubes as depicted in Figure~\ref{fig:hard-caps}. Note that when  there is only one type of partial cubes.

We now show that partial cubes do not pose a problem to detailed routing. Every detailed path that traverses a cube of Type- must originate from that cube.
Every path that traverses cube of Type- and Type-, has the property that from each entry point the cube seems to be complete. Namely, all reachable nodes exist.

Note that, if a detailed path traverses partial cubes, it traverses them from Type- to Type-, from Type- to Type-, and from Type- to a ``full'' cube.
\begin{figure}[h!]
     \centering
     \includegraphics[width=1\textwidth]{hard-caps3.eps}
     \caption{ Three types of partial cubes that intersect with the boundary of
        after untilting. The hatched plane corresponds to vertices with  before untilting. Note that a partial tile consists of the vertices that are above the hatched plane. }
     \label{fig:hard-caps}
\end{figure}
\end{comment}

\section{Proof sketch of Theorem~\ref{thm:algd}}\label{sec:proofdd}

The proof of Theorem~\ref{thm:algd} follows the proof of Theorem~\ref{thm:alg}.
The proof of the propositions below follows the analogous proofs in Section~\ref{sec:analysis}.

\begin{proposition}\label{prop:optd}
    .
\end{proposition}

\begin{proposition}\label{prop:scaledd}
    
\end{proposition}

\begin{proposition}\label{prop:fippd}
    
\end{proposition}

\begin{proposition}\label{prop:preemptionsd}
    
\end{proposition}

\begin{proposition}\label{prop:lastd}\label{prop:Rsd}
    
\end{proposition}

\noindent \textbf{Theorem~\ref{thm:algd}.} \emph{The competitive ratio of the
algorithm for -dimensional grid networks is  provided that
.}
\medskip

\begin{proof sketch}{Theorem~\ref{thm:algd}}
    Bounding path lengths incurs a constant loss to the competitive
    ratio. Algorithm \IPP\ incurs an additional constant loss to the
    competitive ratio. The capacity assignment of  reduces
    the throughput by a factor of .
    Similarly to the uni-dimensional case, a fraction of at most  of the requests in  are preempted before they reach their last cube.
    Finally, a fraction of at least  of the requests that reach their last tile are successfully routed, i.e.,  by detailed routing in the last tile.
    Hence, the total fraction of requests that are successful routed is .
    The theorem follows since .
\end{proof sketch}


\section{Proof of Theorem~\ref{thm:bufferless}}\label{sec:proofs}

\paragraph{Theorem~\ref{thm:bufferless}.}
  \emph{There exists an online deterministic preemptive algorithm for packet
  routing in bufferless -dimensional grids with a competitive ratio of .}
\medskip

\begin{proof}Since , the space-time graph  after untilting
    consists of unconnected -dimensional grids.
Within each such -dimensional grid, we apply a version of our algorithm.  Note that since , trivially  (i.e., the diameter of the grid) and does not depend
    on . Note also that the destination is a single node
    , where . Thus we need not
    introduce sink nodes. The edge capacities are  to every interior edge (instead of
    ). Hence, the capacity assignment reduces the throughput by
    a factor of  (instead of ).
  \end{proof}



\section{Proof of Lemma~\ref{lemma:revMarkov}}\label{sec:RevMarkovproof}
\begin{lemma}[\protect{\textbf{A Reverse Markov Inequality}}]\label{lemma:revMarkov}
  Let  be a nonnegative bounded random variable attaining values in . For every ,
  
\end{lemma}

\begin{proof}
    We prove that . Let Y be a random variable such that . Note that,  is also a nonnegative bounded random variable attaining values in . Hence,  if and only if . The expected value of  is . The lemma follows by applying Markov Inequality~\cite{MU}, as follows:
    
\end{proof}




\section{Online Integral Path Packing Algorithm \route}
\label{sect:routealg} \label{sec:IPP} In this section we present algorithm \route\
and prove Theorem~\ref{thm:IPP}. The presentation follows the framework
of~\cite{BN06,BNsurvey}. The presentation emphasizes two points: (1)~The graph over
which the requests arrive may be infinite. (2)~There is an upper bound  on the length
of a path that may serve a request.

\paragraph{Linear Programming Formulation.}
Fractional path packing is a multi-commodity flow problem, and is formulated by a
linear program (LP). In Figure~\ref{fig:LP}, the dual LP corresponds to the
fractional path packing problem as well as the corresponding primal LP are listed.

The notation in the LPs is as follows. For each request , let  denote the set
of paths in  that can serve the request . The length of every path
 is at most .  The variables  denote the amount of flow
allocated to request  along the path . The demand constraint in the dual LP
states that at most one unit of flow can be jointly allocated to all the paths in
. The capacity constraint states that at most  units of flow can traverse
an edge . The objective is to maximize the flow amount.

The primal LP has two types of variables: one variable  per request  and
one variable  per edge . The variable  can be interpreted as a weight
assigned to the edge . The covering constraint states that for every request 
and every path , the weight of the path  plus  should be at least
. The objective is to minimize the sum of edge weights times their capacities plus
the sum of the variables .



\begin{figure}
\centering
  \begin{tabular}{c}
  \centerline{\fbox{\begin{minipage}{0.7\textwidth}
\begin{center}
        
 \end{center}
\end{minipage}}}
    \\ (I) \\
    \centerline{\fbox{\begin{minipage}{0.7\textwidth}
\begin{center}
        
\end{center}
\end{minipage}}}
 \\ (II) \\
  \end{tabular}
  \caption{
(I) The Primal linear program.
(II) The Dual linear program.}
   \label{fig:LP}
\end{figure}


\paragraph{The Online Algorithm for Integral Packing of Paths.}
The listing of algorithm \route\ appears in
Figure~\ref{fig:route}.  Note that the graph  may
be infinite.  This implies that the primal LP has an
infinite number of variables (however, all but a finite
subset of the primal LP variables are zero).  We assume
that there exists a lightest path oracle that, given edge
weights  and a request , finds a lightest path .

\begin{algorithm}
    Input:  (possibly infinite), sequence of requests  where .
    \\
    \textbf{Upon arrival} of request :
        \begin{enumerate}
            \item Let .
            \item  (find a lightest path from  to  using an oracle).
            \item If  then, \textbf{route}  along :
            \begin{enumerate}
                    \item .
                    \item \label{step:xupdate}For each  do
                  
                  \item .
            \end{enumerate}
            \item Else, \textbf{reject} .
            \begin{enumerate}
              \item.
            \end{enumerate}
        \end{enumerate}
\caption{The \route\ algorithm.  We assume that all the
  variables are initialized to zero using lazy initialization. We assume that given edge variables , there exist an oracle that returns a lightest path in . }
  \label{fig:route}
\end{algorithm}


For a given sequence  of requests let 
denote the maximum flow of the dual LP.  An online integral
path packing algorithm is said to be
\emph{-competitive} if for every sequence
 of requests (1)~its total throughput is at least
, and (2)~the load of every edge is at
most .


\medskip
\noindent
The proof of the following theorem follows the framework of~\cite{BN09,BNsurvey}.

\paragraph{Theorem~\ref{thm:IPP}.}
\emph{ Algorithm \route\ is a -competitive online integral
  path packing algorithm under the following assumptions: (1)~ .  (2)~A path is legal if it contains at most  edges.
(3)~There is an oracle, that given edge weights and a
  request, finds a
  lightest legal path from the source to the destination.
}

\begin{proof}Let us denote by  (respectively, ) the change in the primal
  (respectively, dual) cost function after request  is processed.
We claim that .

If  is rejected, then .  If  is accepted, then
 and .  Step (3b) increases the cost  as follows:
    

Hence after step (3c):


Since  it follows that , as
required.

After dealing with each request, the primal variables  constitute a feasible primal solution. Given a dual solution
, let . Let 
denote an optimal dual solution.  Using weak duality and since  it follows that:
        
    which proves -competitiveness; namely .

    We now prove -feasibility of the dual solution, i.e. for each , .
    The update rule of the primal variables  in Step~\ref{step:xupdate} implies,
      The update rule requires that  for every .  Hence, before the
     update , and after the update .  Since , it follows that .

By Equation~\eqref{eq:xe} it follows that
    
    Implying that , as required.
\end{proof}


\section{Two Models For Nodes in Store-and-Forward Networks}\label{sec:model}
\newcommand{\comb}{\text{\emph{comb}}} The literature contains two
different models of node functionality. In an effort to make the
comparison concrete and perhaps clearer, we present schematic
implementations of the nodes in each model.

To simplify the discussion, we use two type of packets: regular packets and ghost
packets. A regular packet contributes a unit to the throughput (if delivered) and a
ghost packet does not contribute to the throughput and acts as a ``place holder''.
We therefore may treat a buffer as if it always contains  packets.
If a buffer contains only ghost packets, then it is empty in reality.
A reasonable policy does not drop a regular packet while keeping a ghost packet.

\paragraph{Model 1.}
This model is used by~\cite{ARSU,RR}. Figure~\ref{fig:node1}
depicts a block diagram of a node. A node contains a combinational
circuit \comb, a buffer consisting of  flip-flops, and 
flip-flops on each  link that emanates the node.

In each clock cycle, the combinational circuit  receives 
packets from each incoming link,  packets from its buffer, and
 packets from its local inputs. It outputs  packets to the
buffer and  packets along each outgoing link. Packets that were
input but not output are considered dropped packets unless the node is
their destination.

\paragraph{Model 2.}
This model is used by~\cite{AKK,AZ}. Figure~\ref{fig:node2} depicts a
block diagram of a node. A node contains two combinational circuits
 and , two sets of  latches, and one latch
on the link that emanates the node. Note that this implementation uses a
two-phase clock. The phases are denoted by  and .

In the first phase of each clock cycle, the combinational circuit  receives
one packet from the incoming link,  packets from its buffer, and  packets from its
local input. In total  packets (either regular or ghost packets) are fed to the
 circuit. The  circuit outputs  packets and the rest are dropped
unless this is their destination.  In the
second clock phase of each clock cycle, the combinational circuit  outputs
one packet along the outgoing link and  packets are sent back to .

\paragraph{Remarks:}
\begin{enumerate}
\item The setting  in Model 1 is strictly stronger than  in Model 2.
  Indeed, in Model 1, if a node receives a regular packet from its neighbor and is
  also input a regular packet locally, then it may store one packet and forward the
  other one.  On the other hand, in Model 2, one of the packets must be dropped.

\item We could also allow for more injected packets in each node. In
  this case, the node must drop some of them. Of course, the online
  algorithm has to decide which packets should be dropped.
\item The linear lower bounds for  in~\cite{AZ,AKK} hold only with
  respect to Model 2.
\item It is not clear how to extend Model 2 for the case that  or .
\item Under the common assumption that the cost of a flip-flop is
  roughly twice the cost of a latch, the hardware needed for the
  latches of a node in Model 2 is roughly the same as the cost of
  flip-flops of a node in Model 1 (with ).
\end{enumerate}

\begin{figure}[h!]\centering
  \subfloat[]{
\includegraphics[width=0.9\textwidth]{node1.eps}
\label{fig:node1}
}\\
  \subfloat[]{
\includegraphics[width=0.9\textwidth]{node2.eps}
\label{fig:node2}
}\caption{(a) A schematic of a node in Model-1. (b) A schematic of a node in Model-2.}
\end{figure}
\end{document}
