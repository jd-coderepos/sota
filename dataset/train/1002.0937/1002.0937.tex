

\documentclass[copyright,creativecommons]{eptcs}
\providecommand{\event}{PLACES 2009} \providecommand{\volume}{??}
\providecommand{\anno}{2009}
\providecommand{\eid}{??}

\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{xspace}
\usepackage{graphics, graphicx}
\usepackage{amsmath,amsthm}
\usepackage{stmaryrd}




\usepackage{listings}

\def\eg{\emph{e.g.}\;}
\def\ie{\emph{i.e.}\;}
\def\cf{\emph{c.f.}\;}

\newcommand{\keyw}[1]{\textbf{\textsf{#1}}\,}
\newcommand{\inaction}{\textbf{\textsf{0}}}
\newcommand{\netTypek}{\keyw{Net}}
\newcommand{\netk}{\keyw{net}}
\newcommand{\installk}{\keyw{install}}
\newcommand{\postk}{\keyw{post}}
\newcommand{\ink}{\keyw{in}}
\newcommand{\systemk}{\keyw{extern}}
\newcommand{\ifk}{\keyw{if}}
\newcommand{\letk}{\keyw{let}}
\newcommand{\thenk}{\keyw{then}}
\newcommand{\elsek}{\keyw{else}}
\newcommand{\sendk}{\keyw{send}}
\newcommand{\tok}{\keyw{to}}
\newcommand{\firek}{\keyw{timer}}
\newcommand{\everyk}{\keyw{every}}
\newcommand{\expirek}{\keyw{expire}}
\newcommand{\receivek}{\keyw{receive}}
\newcommand{\withk}{\keyw{with}}
\newcommand{\branek}{\keyw{sensor}}
\newcommand{\foreverk}{\keyw{forever}}
\newcommand{\selfk}{\text{self}}
\newcommand{\loadk}{\keyw{load}}
\newcommand{\storek}{\keyw{store}}




\newcommand{\offline}{\offk}
\newcommand{\inactionp}{\idlek}
\newcommand{\sensor}[6]{[{#1} \triangleright {#2}]^{{#3}, {#4}}_{{#5}, {#6}}}
\newcommand{\sensord}{\sensor {P,R} {M, T} I O t p}
\newcommand{\tagsensor}[7]{[{#1}\triangleright{#2}]^{{#3}, {#4}}_{{#5}, {#6}}\{{#7}\}}
\newcommand{\tagsensord}{\tagsensor {P,R} {M,T} I O p t S}
\newcommand{\off}[5]{\langle {#1} \triangleright {#2} \rangle^{{#3}}_{{#4}}}
\newcommand{\offd}{\off {\vec P} {M} p t}
\newcommand{\moduled}{ X :: \{ \function {l_i} {\vec{x_i}} {P_i}\}_{i\in I}}
\newcommand{\amodule}[2]{\{{#1}\,\dots\,{#2}\}}
\newcommand{\amoduled}{\{ {l_i} = {\abstr {\vec x_i}{P_i}}\}_{i\in I}}
\newcommand{\abstr}[2]{({#1})\,{#2}}
\newcommand{\abstrd}{\abstr {\vec{x_i}}{P_i}}
\newcommand{\function}[3]{{#1} = \abstr {#2} {#3}}
\newcommand{\functiond}{\function l {\vec x} P}
\newcommand{\invk}[3]{{#1}.{#2}({#3})}
\newcommand{\invkd}{\invk {v}{l}{\vec v}}
\newcommand{\system}[1]{\systemk\ {#1}}
\newcommand{\systemd}{\system {\msgd}}
\newcommand{\fire}[3]{\firek\ {#1}\ \everyk\ {#2}\ \expirek\ {#3}}
\newcommand{\firef}[2]{\firek\ {#1}\ \everyk\ {#2}\ \foreverk{}}
\newcommand{\fired}{\fire {\msgd} v v}
\newcommand{\firefd}{\firef {\msgd} v}
\newcommand{\handle}[2]{\handlek\ {#1}\ \withk\ {#2}}
\newcommand{\handled}{\handle l A}
\newcommand{\send}[1]{\sendk\ {#1}}
\newcommand{\sendd}{\send {\msgd}}
\newcommand{\msg}[2]{{#1}({#2})}
\newcommand{\msgd}{\msg l {\vec v}}
\newcommand{\receivedd}{\receivek}
\newcommand{\post}[1]{\postk\ {#1}}
\newcommand{\postd}{\post P}
\newcommand{\install}[2]{{#1}.\installk\ {#2}}
\newcommand{\installd}{\install v v}
\newcommand{\Let}[3]{\letk\ {#1} = {#2}\ \ink\ {#3}}
\newcommand{\Letd}{\Let x P P}
\newcommand{\Def}[3]{\defk\ {#1} = {#2}\ \ink\ {#3}}
\newcommand{\Defd}{\Def X M P}
\newcommand{\Value}[2]{\langle {{#1}} \rangle^{{#2}}}
\newcommand{\Valued}{\Value {\vec v} p}
\newcommand{\parn}{\,\vert\,}
\newcommand{\parp}{\, \vert\, }
\newcommand{\seq}{\;;\;}
\newcommand{\ldb}{\{\makebox[.1ex][r]{}} \newcommand{\rdb}{|\makebox[-.03ex]{}} \newcommand{\ldsq}{[\![} \newcommand{\rdsq}{]\!]} \def\context#1{\mathcal{C}\ldsq#1\rdsq}
\def\emptycontext{[\;]}
\def\contextd{\context { }}



\def\obj#1{\{#1\}}
\def\typeamodd{\obj {l_i \colon \vec \tau_i \rightarrow \tau_i}_{i \in I}}
\def\typesmodd{\anyObj {l_i \colon \vec \tau_i \rightarrow \tau_i}_{i \in I}}
\def\typemodd{[X_j :: \typeamodd]_{j \in J}}
\def\senObj#1{[#1]}
\def\senObjd{\senObj {l_i \colon \vec T_i \rightarrow T_i}_{i \in I}}
\def\anyObj#1{\langle {#1} \rangle}
\def\anyObjd{\anyObj {l_i \colon \vec T_i \rightarrow T_i}_{i \in I}}
\newcommand{\heapType}{\{ {x_i}:{\tau_i}\}_{i\in I}}
\newcommand{\functionType}[2]{{#1} \rightarrow {#2}}
\newcommand{\functionTyped}{\functionType {\vec \tau} {\tau}}
\newcommand{\recType}[2]{\mu {#1}.{#2}}
\newcommand{\recTyped}{\recType{\alpha} {\tau}}
\newcommand{\dom}{\operatorname{dom}}
\newcommand{\disj}{\operatorname{,}}
\def\rest#1#2{#1\vert_{#2}}

\newcommand{\bottom}{\perp}
\newcommand{\dist}{\operatorname{inRange}}
\newcommand{\route}{\operatorname{networkRoute}}
\newcommand{\fn}{\operatorname{fn}}
\newcommand{\fv}{\operatorname{fv}}
\newcommand{\untag}{\operatorname{untag}}
\newcommand{\energyIn}{\mathsf{e_{in}}}
\newcommand{\energyOut}{\mathsf{e_{out}}}
\newcommand{\maxProc}{\mathsf{N_{proc}}}
\newcommand{\methJoin}{+}
\newcommand{\subs}[2]{[{#1}/{#2}]}
\newcommand{\bind}[2]{\{{#1}:{#2}\}}
\newcommand{\update}[2]{\{{#1}\colon {#2}\}}
\newcommand{\congr}{\equiv}
\newcommand{\reduces}{\rightarrow}
\newcommand{\tagreduces}[4]{\rightarrow^{{#1},{#2}}_{{#3},{#4}}}
\newcommand{\tagreducesd}{\tagreduces p {r} {l_i} {\vec v}}
\newcommand{\reducesn}{\reduces^{*}}
\newcommand{\disprule}[2]{
    #2 \tag{#1}
}
\newcommand{\err}{\overset{\text{err}}{\longmapsto}}
\newcommand{\errpi}[1]{\err_{#1}}


\newcommand{\ltsreduces}[1]{\stackrel{{#1}}\longrightarrow}
\newcommand{\labelLocal}[3]{{#1}[{#2}]\rightarrow {#3}}
\newcommand{\labelLocald}{\labelLocal{l_i}{\vec v}{(\vec x_i) P_i}}
\newcommand{\labelNet}[2]{{#1}[{#2}]\uparrow}
\newcommand{\labelNetd}{\labelNet{l_i}{\vec v}}
\newcommand{\labelNetNet}[4]{\labelNet{{#1}}{{#2}} ({#3}, {#4})}
\newcommand{\labelNetNetd}{\labelNetNet {l_i} {\vec v} p r}
\newcommand{\labelInst}[1]{{#1}\rightleftharpoons}
\newcommand{\labelInstd}{\labelInst{v}}
\newcommand{\labelSense}[3]{\subs {#1} {#2}\downarrow{#3}}
\newcommand{\labelSensed}{\labelSense v x {}}
\newcommand{\labelSenseNetd}{\labelSense v x p}
\newcommand{\labelTau}{\tau}
\newcommand{\labelAny}{\gamma}

\newcommand{\mkRrule}[1]{{\footnotesize \textsc{R-#1}}}
\newcommand{\mkTrule}[1]{{\footnotesize \textsc{T-#1}}}
\newcommand{\mkSrule}[1]{{\footnotesize \textsc{S-#1}}}
\newcommand{\mkErule}[1]{{\footnotesize \textsc{E-#1}}}
\newcommand{\Rfunction}{\mkRrule{function}}
\newcommand{\RnoFunction}{\mkRrule{no-function}}
\newcommand{\RinstallS}{\mkRrule{install-sensor}}
\newcommand{\RinstallM}{\mkRrule{install-module}}
\newcommand{\Rlet}{\mkRrule{let}}
\newcommand{\Rload}{\mkRrule{load}}
\newcommand{\Rstore}{\mkRrule{store}}
\newcommand{\Rfire}{\mkRrule{timer}}
\newcommand{\RcallS}{\mkRrule{call-sensor}}
\newcommand{\RcallM}{\mkRrule{call-module}}
\newcommand{\Rnocall}{\mkRrule{no-function}}
\newcommand{\Rtrigger}{\mkRrule{trigger}}
\newcommand{\Rdiscard}{\mkRrule{expire}}
\newcommand{\Rsend}{\mkRrule{send}}
\newcommand{\Rreceive}{\mkRrule{receive}}
\newcommand{\Rsystem}{\mkRrule{extern}}
\newcommand{\Rnext}{\mkRrule{next}}
\newcommand{\Ridle}{\mkRrule{idle}}
\newcommand{\RreceiveN}{\mkRrule{no-message}}
\newcommand{\Rdelay}{\mkRrule{delay}}
\newcommand{\RsendCall}{\mkRrule{send}}
\newcommand{\RsendRelease}{\mkRrule{release}}
\newcommand{\RsenseDef}{\mkRrule{sense-def}}
\newcommand{\Rstructural}{\mkRrule{structural}}
\newcommand{\Rmove}{\mkRrule{move}}
\newcommand{\Rpar}{\mkRrule{parallel}}
\newcommand{\Rseq}{\mkRrule{seq}}
\newcommand{\Rnetwork}{\mkRrule{network}}
\newcommand{\Rsensor}{\mkRrule{sensor}}
\newcommand{\Rtrans}{\mkRrule{Transmission}}
\newcommand{\Rtagstructural}{\mkRrule{Tag-Structural}}
\newcommand{\Rcongr}{\mkRrule{congr}}
\newcommand{\Rbroadcast}{\mkRrule{broadcast}}
\newcommand{\Rrelease}{\mkRrule{release}}

\newcommand{\SmonoidProgram}{\mkSrule{monoid-Program}}
\newcommand{\SmonoidSensor}{\mkSrule{monoid-Sensor}}
\newcommand{\SinitSend}{\mkSrule{init-Send}}
\newcommand{\Soff}{\mkSrule{bat-exhausted}}
\newcommand{\Son}{\mkSrule{bat-charged}}
\newcommand{\Sseq}{\mkSrule{idle-seq}}
\newcommand{\Sprogram}{\mkSrule{program-stru}}

\newcommand{\type}{\vdash}
\newcommand{\is}{\colon}
\newcommand{\TSinaction}{\mkTrule{off}}
\newcommand{\Tparallel}{\mkTrule{par}}
\newcommand{\TseqP}{\mkTrule{seqP}}
\newcommand{\TrunQueue}{\mkTrule{run-queue}}
\newcommand{\TcallStack}{\mkTrule{call-stack}}
\newcommand{\TcommQueue}{\mkTrule{comm-queue}}
\newcommand{\TeventQueue}{\mkTrule{event-queue}}
\newcommand{\Theap}{\mkTrule{heap}}
\newcommand{\TSsensor}{\mkTrule{sensor}}
\newcommand{\TSbSensor}{\mkTrule{bSensor}}
\newcommand{\TSoSensor}{\mkTrule{oSensor}}
\newcommand{\TPinaction}{\mkTrule{idle}}
\newcommand{\TPpar}{\mkTrule{pPar}}
\newcommand{\Tlet}{\mkTrule{let}}
\newcommand{\Tpost}{\mkTrule{post}}
\newcommand{\Tfire}{\mkTrule{timer}}
\newcommand{\Treceive}{\mkTrule{receive}}
\newcommand{\Tcall}{\mkTrule{call}}
\newcommand{\TsCall}{\mkTrule{extern}}
\newcommand{\Tmcall}{\mkTrule{mcall}}
\newcommand{\TinstS}{\mkTrule{sInstall}}
\newcommand{\TinstM}{\mkTrule{mInstall}}
\newcommand{\Tbcast}{\mkTrule{send}}
\newcommand{\TVvar}{\mkTrule{var}}
\newcommand{\TVlabel}{\mkTrule{label}}
\newcommand{\TVseq}{\mkTrule{seq}}
\newcommand{\TVsensor}{\mkTrule{sensor}}
\newcommand{\Tamod}{\mkTrule{amod}}
\newcommand{\Tcode}{\mkTrule{code}}
\newcommand{\Tmod}{\mkTrule{mod}}
\newcommand{\Tbin}{\mkTrule{built-in}}
\newcommand{\Tmname}{\mkTrule{mname}}
\newcommand{\Tnetabs}{\mkTrule{netabs}}
\newcommand{\Tloc}{\mkTrule{loc}}
\newcommand{\seqSets}[3]{{#1}; {#2}; {#3}}
\newcommand{\seqSetsd}{\seqSets {\tau_S} {\tau_M} {\Gamma}}
\newcommand{\arrowType}[2]{{#1} \rightarrow {#2}}
\newcommand{\arrowTyped}{\arrowType {\vec \tau} {\tau}}


\newcommand{\Emodule}{\mkErule{module}}
\newcommand{\Efunction}{\mkErule{cFunction}}
\newcommand{\Ecall}{\mkErule{call}}
\newcommand{\Einstall}{\mkErule{install}}
\newcommand{\Epar}{\mkErule{par}}
\newcommand{\Estr}{\mkErule{str}}
\newcommand{\nerr}{\overset{\text{err}}{\,\,\arrownot\!\!\longmapsto}}




\newcommand{\pad}{\;\;}
\newcommand{\Space}[1]{\pad{#1}\pad}
\newcommand{\grmeq}{\Space{::=}}
\newcommand{\Eq}{\Space=}
\newcommand{\grmor}{\;\mid\;}

\newenvironment{myfigure}{
  \begin{figure}[t]\centering\hrulefill\par\vspace{-4ex}}{
    \hrulefill\end{figure}}

\newcommand{\myparagraph}[1]{\vspace*{0.2cm}\noindent\textbf{#1}}

\newcommand{\todo}[1]{[\textbf{Todo:} #1]}

\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}

\lstset{language=Java,
  extendedchars=true,
  showstringspaces=false,
  basicstyle=\sffamily,
  morekeywords={extern,send,receive,install,let,in,timer,every,expire,if,then,else,not,forever,sensor},
  sensitive=false,
  morecomment=[s]{\{-}{-\}},
  morecomment=[l]--,
literate={senS}{}1 
           {senX}{}2
           {senY}{}2
           {vx}{}1
           {vy}{}1
           {pz}{}1 {bz}{}1 {rz}{}1
           {px}{}1 {py}{}1
           {fz}{}1
}
\lstset{backgroundcolor=,rulecolor=,showstringspaces=false, frame=tb, texcl}




\newcommand{\rulespace}{0.2cm}

\newcommand{\noEvent}[2]{\mathop{\mathrm{noEvent}}\nolimits ({#1}, {#2})}
\newcommand{\noEventd}{\noEvent T t}



\def\lastname{Martins, Lopes, and Barros}
\def\authorrunning{Martins, Lopes, and Barros}
\def\titlerunning{Towards Safe Programming of WSN}

\begin{document}

\title{Towards the Safe Programming of \\ Wireless Sensor Networks}

\author{Francisco Martins
\institute{LASIGE \& DI-FCUL,\\
   Lisbon, Portugal
   \email{fmartins@di.fc.ul.pt} 
}
\and
Lu\'{\i}s Lopes
\institute{CRACS/INESC-Porto \& DCC-FCUP,\\
  Porto, Portugal
  \email{lblopes@dcc.fc.up.pt}
}
\and
Jo\~ao Barros
\institute{IT \& FEUP,\\
  Porto, Portugal
  \email{jbarros@fe.up.pt}
}
}
\maketitle
\begin{abstract}
Sensor networks are rather challenging to deploy, program, and
debug. Current programming languages for these platforms suffer from a
significant semantic gap between their specifications and underlying
implementations. This fact precludes the development of (type-)safe
applications, which would potentially simplify the task of programming and
debugging deployed networks. In this paper we define a core calculus
for programming sensor networks and propose to use it as an assembly
language for developing type-safe, high-level programming languages.
\end{abstract}


\textbf{keywords}: Sensor Networks, Programming Languages,
Process-Calculi.




\section{Introduction and Motivation}
\label{sec:introduction}

Wireless sensor networks are composed of huge numbers of small
physical devices capable of sensing the environment and connected
using ad-hoc networking protocols over radio links~\cite{survey:akyildiz:etal:02}.
These platforms have several unique characteristics when compared with
other ad-hoc networks.
First, sensor networks are often designed for specific applications or
application domains making software re-usability and portability an
issue.
Sensor devices have very limited processing power (CPU), available
memory, and battery lifetime, and are often deployed at remote
locations making physical access to the devices (\eg for maintenance)
difficult or even impossible.
For these reasons, programming such large scale distributed systems
can be daunting. Programs must be \emph{lightweight}, produce a
\emph{small memory footprint}, be \emph{power conservative}, be
\emph{self-reconfigurable} (\ie may be reprogrammed dynamically
without physical intervention on the devices) and, we argue, be
\emph{(type-)safe}.

To date several programming languages and run-time systems have been
proposed for wireless sensor networks (see~\cite{bookchapter} and
references therein) that address some of the above issues, but few
tackle the \emph{safety} issue. Regiment~\cite{regiment2}, a strongly
typed functional \emph{macroprogramming} language, is the closest to
achieve this goal by providing a type-safe compiler.
However, Regiment is then compiled into a low-level \emph{token
 machine language} that is not type-safe. This intermediate language
is itself compiled into a nesC implementation of the run-time based on
the \emph{distributed token machine} model, for which no safety
properties are available.
In fact, in general, an underlying model with well-studied operational
semantics for sensor networks seems to be lacking. The absence of such
a model reveals itself as a considerable semantic gap between the
semantics of the (sometimes high-level) programming languages and their
respective implementations.

In this paper we propose Callas, a calculus for programming sensor
networks, based on the formalism of process
calculi~\cite{async-pi:honda:tokoro:91,pi:milner:parrow:walker:92},
that aims to establish a basic computational model for sensor
networks. The goal is to diminish the above mentioned semantic gap
by proceeding bottom-up, using Callas as a basic assembly language
upon which high-level programming abstractions may be encoded as
semantics preserving, derived constructs.
Callas is an evolution from a previous proposal~\cite{sensorcomm07} by
the authors, which unlike its original sibling  provides: (a)
decoupled semantics for in-sensor computation (associated with the
\emph{application layer}) and networking (associated with the
\emph{data-link} and \emph{network} layers); b) support for a form of
timed \emph{events}; and c) \emph{event-driven} semantics.






\section{Overview of Callas}
\label{sec:calculus}

The syntax of Callas is provided by the grammar in
Figure~\ref{fig:syntax}. Let  denote a possibly empty
sequence  of elements of some syntactic
category . We let~ range over a countable set of
\emph{labels} representing function names, and let  range
over a countable set of \emph{variables}. These sets are pairwise
disjoint.



\begin{figure}
0.5cm]
v & \grmeq                          & & \text{\emph{Values}}\\
        & \quad \; b                   & & \text{built-in value}\\
        & \grmor x                        & & \text{variable}\\
        & \grmor M                        & & \text{module}\\
        & \grmor \branek                  & & \text{installed functions}\0.4cm]
R & \grmeq P_1::\dots::P_n  & & \text{run-queue} \\
      I,O & \grmeq m_1::\dots::m_n        & & \text{message queues} 
    \end{aligned}
    \qquad
    \begin{aligned}
      M & \grmeq              & & \text{\emph{Modules}}\\                
        & \quad \; \amoduled  & & \text{module}\0.3cm]
T & \grmeq \{(l_i(\vec v_i),v_i,v_i,v_i)\}_{i \in I} & & \text{timed calls} 
\end{aligned}
  
    \tag{\SmonoidSensor} S_1 \parn S_2 \congr S_2 \parn S_1, \qquad S \parn \inaction \congr S, \qquad  S_1 \parn (S_2 \parn S_3)  \congr (S_1 \parn S_2) \parn S_3 \\ \\
    \sensor {P,R} {M,T} I O p t \congr \tagsensor {P,R} {M,T} I O p
t {\inaction} \qquad \tag{\SinitSend}
  
    \tag{\Rsystem}
    \frac{
      \noEventd
    }{
      \sensor {\context{\systemd},R} {M,T} I O p t 
      \reduces
      \sensor {\context{v},R} {M, T} I O p {t+1} 
    }
\\rulespace]
    \tag{\RinstallM}
    \frac{
      \noEventd
    }
    {
      \sensor {\context{\install {M'} {M''}},R} {M, T} I O p t 
      \reduces
      \sensor {\context{M' + M''},R} {M, T} I O  p {t+1} 
    }
    \\rulespace]
    \tag{\Rreceive}
    \frac{
       \noEventd
    }
    {
      \sensor {\context{\receivedd},R} {M, T} {\langle \msgd \rangle :: I} O p t 
      \reduces
      \sensor {\context{\obj{}},R:: \invk \branek l {\vec v}} {M, T} I O p {t+1}
    }
   \\rulespace]
    \tag{\Rnext,\Rmove}
    \frac{
      \noEventd
    }
    {
      \sensor {v,P::R} {M, T} I O p t 
      \reduces
      \sensor {P,R} {M, T} I O p {t+1}
    }
    \qquad
    \frac{
      \noEventd
    }
    {
      \sensor {P,R} {M, T} I O p t 
      \reduces
      \sensor {P,R} {M, T} I O {p'} t
    }
    \\rulespace]
    \tag{\RcallS}
     \frac{
      M(l) = (\selfk\ \vec x) P
       \quad 
       \noEventd
     }{
       \sensor {\context{\invk \branek l {\vec v}},R} {M,T} I O p t 
       \reduces
       \sensor {\context{P\subs {M\ \vec v} {\selfk\ \vec x}},R} {M, T} I O p {t+1} 
     }
     \\rulespace]
     \tag{\Rnocall}
     \frac{
       l \not\in \dom(M) \quad  \noEventd
     }{
       \sensor {\context{\invk \branek l {\vec v}},R} {M,T} I O p t 
       \reduces
       \sensor {\obj{},R::\context{\invk \branek l {\vec v}}} {M, T} I O p {t+1} 
     }
    \\rulespace]
    \tag{\Rtrigger}
     \frac{
       t \le v'  \quad  T' = T \uplus (\msgd, v, v', t + v) 
     }{
       \sensor {P,R} {M,T \uplus (\msgd, v, v', t)} I O p t 
       \reduces
       \sensor {P,\invk \branek l {\vec v}::R} {M, T'} I O p t 
     }
     \
\center See Definition~\ref{def:plus} for the formal meaning of operator .
\caption{Reduction semantics for sensors.}
\label{fig:reduction}
\end{figure}



Within sensors reduction proceeds without obstacle while the internal
clock  is not such that a timed call must be triggered. This is
controlled by the predicate 
that checks the time of the next activation for every timed call
against the current time.
There is no special reason
why the increments in the clock are unitary. One could easily assume
that each instruction consumes a different number of processor cycles
and reflect that scenario in the rules. Some rules (\eg \Rlet{})
simply re-structure a process and thus we assume that no cycles are
consumed.

Rule \Rsystem{} calls a synchronous external function and receives a
value as the result. The rules \RinstallS{} and \RinstallM{} handle
module updates. The former takes the module with the code installed at
the sensor and updates it with the code of another module . The
resulting new module is installed in the sensor. The latter applies
only to volatile anonymous modules and therefore the resulting module
is not installed in the sensor. The rule \Rsend{} (\Rreceive{})
handles the interaction with the network by putting (getting) messages
in (from) the outgoing (incoming) queue. Notice that receiving a 
message is non-blocking (\RreceiveN).
The rules \RcallS{}, \RcallM{} and \Rnocall{} handle calls to
functions in modules. \RcallS{} selects the function in the
sensor's module, gets its code and replaces the parameters with the
arguments passing the sensor's module  as the first argument
in variable \selfk. \RcallM{} is similar to \RcallS{} but uses 
module  instead of the sensor's module .
Rule \Rnocall{} handles the case of a call to a
function that is not yet installed. The call is deferred to the end of
the run-queue. The idea is that the module containing the function
may not have arrived at the sensor to be installed and so we postpone
the execution of the function.

When a value of  is reached such that it implies the triggering of
a call, the rules \Rtrigger{} and \Rdiscard{} come into action. Rule
\Rtrigger{} places a timed function call  at the front of
the run-queue. The execution of the call is delegated to rule
\RcallS{}. Note that only calls to functions installed in the
sensor~(in ) are allowed. Other calls are deferred to the end of the
run-queue by the rule \Rnocall{}. If the timer has expired, rule
\Rdiscard{} removes the corresponding tuple from .



\begin{figure}
\rulespace]
     \tag{\Rnetwork, \Rcongr}
     \frac{
       S \reduces S'
    }
    {
      S \parn S''
      \reduces
      S' \parn S''
    }
    \qquad
    \frac{
      S_1 \congr S_2 
      \qquad
      S_2 \reduces S_3
      \qquad
      S_3 \congr S_4
    }{
      S_1 \reduces S_4
    }
     \\rulespace]
    \tag{\Rbroadcast}
    \frac{
      \dist(p,p') 
      \qquad (I'',O'') = \route(m, I', O')
}
    {
      \tagsensor {P,R} 
      {M, T} I {m::O} p t S \parn
      \sensor{P',R'}{M', T'} {I'} {O'} {p'}{t'}  
      \reduces
      \tagsensor {P,R}  
      {M, T} I {m::O} p t 
      {S \parn \sensor{P', R'}
        {M', T'} {I''} {O''} {p'}{t'}}
    }
    \\rulespace]
    \tag{\Rrelease}
    {
      \tagsensor {P,R} {M, T} I {m::O} p t S
      \reduces
      \sensor {P,R} {M, T} I O p t \parn S
    }

  & \tau \grmeq & & \text{\emph{Types}}
  \\
  & \qquad \; \beta & & \text{built-in type}
  \\
  & \quad \grmor \arrowTyped & & \text{recursive function type}
  \\
  & \quad \grmor   \typesmodd & & \text{sensor code type}
  \\
  & \quad \grmor   \typeamodd & & \text{anonymous code type}
  \\
  & \quad \grmor   \recTyped & & \text{recursive type}
  \\
  & \quad \grmor   \alpha & & \text{type variable}

    \seqSetsd \type b \colon \beta
    \qquad
    \seqSetsd \disj x \colon \tau \type x \colon \tau
    \qquad
    \seqSetsd \type \branek \colon \tau_M
    \tag{\Tbin, \TVvar, \TVsensor}
    \\rulespace]
   \frac{
     \forall i \in I.\seqSetsd
     \disj s_i \colon \tau_{M'} \disj \vec x_i \colon \vec \tau_i \type P_i \colon \tau_i
     \qquad 
     \tau_{M'} = \recType \alpha {\obj{l_i \colon 
         \functionType{\alpha \vec{\tau_i}} \tau_i}_{i \in I}}
   }
   {
     \seqSetsd \type \obj{l_i = {\abstr {s_i,\vec x_i}{P_i}}}_{i \in I} \colon \tau_{M'}
   }
   \tag{\Tcode}
 
    \tag{\TsCall,\Tbcast}
    \frac{
      \tau_S \type l \colon \functionTyped
      \qquad
      \seqSetsd \type \vec v \colon \vec \tau
    }
    {
      \seqSetsd \type \systemd \colon \tau
    }
    \qquad
    \frac{
      \seqSetsd \type \invk \branek l {\vec v} \colon \obj{}
    }
    {
      \seqSetsd \type \sendd \colon \obj{}
    }
    \\rulespace]
   \tag{\Tcall,\Tlet}
    \frac{
      \seqSetsd \type v_1 \colon \tau_1
      \quad
      \tau_1 \type l \colon \functionType {\tau_1 \vec \tau}{\tau_2}
      \quad 
      \seqSetsd \type \vec v_2 \colon \vec \tau
    }
    {
      \seqSetsd \type \invk {v_1} {l} {\vec v_2} \colon \tau_2
    }
    \qquad
    \frac{
      \seqSetsd \type P_1 \colon \tau_1
      \quad
      \seqSetsd \disj x \colon \tau_1 \type P_2 \colon \tau_2
    }
    {
      \seqSetsd \type \Let x {P_1} {P_2} \colon \tau_2
    }
    \
\caption{Typing rules for processes.}
\label{fig:type-system-processes}
\end{figure}






\begin{figure}
\rulespace]
   \frac{
     \tau_S;\tau_M \type \sensord
     \qquad
     \tau_S;\tau_M \type S
   }
   {
     \tau_S;\tau_M \type \tagsensord 
   }
   \qquad
   \frac{
     \tau_S;\tau_M \type S_1 
     \qquad
     \tau_S;\tau_M \type S_2
   }
   {
     \tau_S;\tau_M \type S_1 \parn S_2
   }
   \tag{\TSbSensor, \Tparallel}
 
    \frac{
      \tau_s;\tau_M;\emptyset \type P \colon \_
      \qquad
      \tau_s;\tau_M \type R
    }
    {
      \tau_S;\tau_M \type P::R
    }
    \qquad \qquad
    \frac{
      \tau_S;\tau_M;\emptyset \type \invk \branek l {\vec v} \colon \_
      \qquad
      \tau_S;\tau_M \type I
    }
    {
      \tau_S;\tau_M \type \langle \msgd \rangle :: I
    }
    \tag{\TrunQueue, \TcommQueue}
    \
  \caption{Typing rules for queues of messages, processes, and events.}
  \label{fig:type-system-queues}
\end{figure}



The proofs for our main results (Theorem~\ref{teo:subject-reduction},
Theorem~\ref{teo:type-safety}, and Corollary~\ref{cor:type-safety})
are based on the following auxiliary results.
We call \textit{context process}, denoted , the
processes resulting from filling its context hole.
Informally, Lemma~\ref{lemma:context-process} states that if a context
process is well typed, then the same also holds for the process that
fills its hole, although not necessarily with an identical type.
Lemma~\ref{lemma:process-context} states that the typability of a
context process holds and its type is preserved if we fill the context's
hole with processes of the same type.
Lemma~\ref{lemma:module-substitution} handles module's substitution.
Lemmas~\ref{lemma:substitution-lemma} and~\ref{lemma:congruence} are
discussed below.

\begin{lemma}
  \label{lemma:context-process}
  If , then .
\end{lemma}

\begin{proof}
  The proof proceeds by induction on the contexts' structure and
  both cases are straightforward. 
\end{proof}

\begin{lemma}
  \label{lemma:process-context}
  If , , and , then .
\end{lemma}

\begin{proof}
  We proceed by induction on the contexts' structure analysing each 
  definition case. Both cases follow easily.
\end{proof}

\begin{lemma}
  \label{lemma:module-substitution}
  If  and , 
  then .
\end{lemma}

\begin{proof}
  Directly from the definition of  and using Rule~\Tcode.
\end{proof}

The Substitution Lemma is used in the proof of the Subject Reduction
Theorem, to show the cases that involve the replacement of formal by
actual parameters, specifically for function call and for the let
construct.
The proof is standard, so we omit it, but the interested reader may
find similar proofs in the literature, for instance
in~\cite[Section 6.3]{sangiorgi.walker:theory-mobile}.

\begin{lemma}[Substitution Lemma]
  \label{lemma:substitution-lemma}
  If  and , then .
\end{lemma}

The following results state type invariance during reduction.

\begin{lemma}[Congruence Lemma]
  \label{lemma:congruence}
  If  and , then .
\end{lemma}

\begin{proof}
  We proceed by induction on the derivation tree for .
  The proof is straightforward.
\end{proof}

\begin{theorem}[Subject Reduction]
  \label{teo:subject-reduction}
  If  and , then .
\end{theorem}

\begin{proof}
  By induction on the derivation tree for . 
In each case, we proceed by case analysis on the last typing rule of
  the inference tree for .
\end{proof}


\paragraph{Type safety.}
\label{sec:type-safety}
Our claim is that well-typed sensor networks are free from run-time errors.
The unary relation , defined as the least relation on
networks closed under the rules in Figure
\ref{fig:runtime-errors}, identifies processes that would get ``stuck''
during computation (reduction).
We write  for .

Our Sensor Networks may exhibit two kinds of failures upon
computing: when calling a function or when installing a module.
In the former, the call may result in a run-time error when the target
of the call is neither \lstinline{sensor}, nor an anonymous module (Rule
\Ecall);
or when the function name is unknown or there is a mismatch
between the number of arguments () and the number
parameters () (Rule \Efunction).
In the latter, an error may occur if we are installing some value
that is not a module (Rule \Einstall).

As an example, recall the \lstinline{gather} function from the
streaming data example that we sketched below.
\begin{lstlisting}[frame=none]
  { gather = (self,x,y) ...}
\end{lstlisting}
The process
\begin{lstlisting}[frame=none]
  let t = extern getTime() in send gather(t)
\end{lstlisting}
exhibits a run-time error, since function
\lstinline|gather| is being called with two arguments instead of three.
In fact, the above network may reduce using Rules~\Rsystem{} and~\Rlet, but
then we cannot apply Rule \Rfunction, since the substitution is not
defined.
Run-time error Rule \Efunction{} captures this kind of failure.



\begin{figure}
0.07cm]
\sensor {\context{\invk {M'} l {v_1 \dots v_n}}, R} {M,T} I O p t & \err & &
  \text{if } l \not \in \dom(M') \text{ or }
  \\
  & & &  (M'(l) = \abstr {x_1 \dots x_m} {P} \text{ and }\\
  & & & n \neq m)
    \tag{\Efunction}\-1cm]
  
  \frac{
    S \err
  }
  {
    S \parn S' \err
  }
  \qquad \qquad
  \frac{
    S \congr S' \quad
    S \err
  }
  {
    S' \err
  }
  \tag{\Epar, \Estr}
-0.8cm]





\begin{thebibliography}{10}
\providecommand{\bibitemstart}[1]{\bibitem{#1}}
\providecommand{\bibitemend}{}
\providecommand{\bibliographystart}{}
\providecommand{\bibliographyend}{}
\providecommand{\url}[1]{\texttt{#1}}
\providecommand{\urlprefix}{Available at }
\providecommand{\bibinfo}[2]{#2}
\bibliographystart

\bibitemstart{survey:akyildiz:etal:02}
\bibinfo{author}{I.~Akyildiz}, \bibinfo{author}{W.~Su},
  \bibinfo{author}{Y.~Sankarasubramaniam} \& \bibinfo{author}{E.~Cayirci}
  (\bibinfo{year}{2002}): \emph{\bibinfo{title}{{A Survey on Sensor
  Networks}}}.
\newblock {\sl \bibinfo{journal}{IEEE Communications Magazine}}
  \bibinfo{volume}{40}(\bibinfo{number}{8}), pp. \bibinfo{pages}{102--114}.
\bibitemend

\bibitemstart{contiki}
\bibinfo{author}{A.~Dunkels}, \bibinfo{author}{B.~Gr\"{o}nvall} \&
  \bibinfo{author}{T.~Voigt} (\bibinfo{year}{2004}):
  \emph{\bibinfo{title}{{Contiki - a Lightweight and Flexible Operating System
  for Tiny Networked Sensors}}}.
\newblock In: {\sl \bibinfo{booktitle}{EmNets'04 Workshop}}.
\bibitemend

\bibitemstart{agilla:fok:roman:lu:05}
\bibinfo{author}{C.-L. Fok}, \bibinfo{author}{G.-C. Roman} \&
  \bibinfo{author}{C.~Lu} (\bibinfo{year}{2005}): \emph{\bibinfo{title}{{Rapid
  Development and Flexible Deployment of Adaptive Wireless Sensor Network
  Applications}}}.
\newblock In: {\sl \bibinfo{booktitle}{{ICDCS'05}}}. \bibinfo{publisher}{IEEE
  Press}, pp. \bibinfo{pages}{653--662}.
\bibitemend

\bibitemstart{cougar}
\bibinfo{author}{W.~F. Fung}, \bibinfo{author}{D.~Sun} \&
  \bibinfo{author}{J.~Gehrke} (\bibinfo{year}{2002}):
  \emph{\bibinfo{title}{{COUGAR}: The Network is the Database}}.
\newblock In: {\sl \bibinfo{booktitle}{SIGMOD'02}}. \bibinfo{publisher}{ACM
  Press}.
\bibitemend

\bibitemstart{nesc:gay:levis:etal}
\bibinfo{author}{D.~Gay}, \bibinfo{author}{P.~Levis}, \bibinfo{author}{R.~von
  Behren}, \bibinfo{author}{M.~Welsh}, \bibinfo{author}{E.~Brewer} \&
  \bibinfo{author}{D.~Culler} (\bibinfo{year}{2003}):
  \emph{\bibinfo{title}{{The nesC Language: A Holistic Approach to Network
  Embedded Systems}}}.
\newblock In: {\sl \bibinfo{booktitle}{{PLDI'03}}}. \bibinfo{publisher}{{ACM}
  Press}, pp. \bibinfo{pages}{1--11}.
\bibitemend

\bibitemstart{async-pi:honda:tokoro:91}
\bibinfo{author}{K.~Honda} \& \bibinfo{author}{M.~Tokoro}
  (\bibinfo{year}{1991}): \emph{\bibinfo{title}{{A}n {O}bject {C}alculus for
  {A}synchronous {C}ommunication}}.
\newblock In: {\sl \bibinfo{booktitle}{ECOOP'91}}, number \bibinfo{number}{512}
  in \bibinfo{series}{LNCS}. \bibinfo{publisher}{Springer-Verlag}, pp.
  \bibinfo{pages}{133--147}.
\bibitemend

\bibitemstart{deluge:hui:culler:04}
\bibinfo{author}{J.~W. Hui} \& \bibinfo{author}{D.~Culler}
  (\bibinfo{year}{2004}): \emph{\bibinfo{title}{{The Dynamic Behavior of a Data
  Dissemination Protocol for Network Programming at Scale}}}.
\newblock In: {\sl \bibinfo{booktitle}{{ENSS'04}}}. \bibinfo{publisher}{{ACM}
  Press}, pp. \bibinfo{pages}{81--94}.
\bibitemend

\bibitemstart{mate:levis:culler:02}
\bibinfo{author}{P.~Levis} \& \bibinfo{author}{D.~Culler}
  (\bibinfo{year}{2002}): \emph{\bibinfo{title}{{Mat\'{e}: A Tiny Virtual
  Machine for Sensor Networks}}}.
\newblock In: {\sl \bibinfo{booktitle}{{ASPLOS X}}}. \bibinfo{publisher}{{ACM}
  Press}, pp. \bibinfo{pages}{85--95}.
\bibitemend

\bibitemstart{pushpin}
\bibinfo{author}{J.~Lifton}, \bibinfo{author}{D.~Seetharam},
  \bibinfo{author}{M.~Broxton} \& \bibinfo{author}{J.~Paradiso}
  (\bibinfo{year}{2002}): \emph{\bibinfo{title}{{Pushpin Computing System
  Overview: a Platform for Distributed}}}.
\newblock In: {\sl \bibinfo{booktitle}{Pervasive'02}}.
  \bibinfo{publisher}{Springer-Verlag}.
\bibitemend

\bibitemstart{bookchapter}
\bibinfo{author}{L.~Lopes}, \bibinfo{author}{F.~Martins} \&
  \bibinfo{author}{J.~Barros} (\bibinfo{year}{2009}):
  \emph{\bibinfo{title}{{Middleware for Network Eccentric and Mobile
  Applications}}}, chapter~\bibinfo{chapter}{2}, pp. \bibinfo{pages}{25--41}.
\newblock \bibinfo{publisher}{Springer-Verlag}.
\bibitemend

\bibitemstart{sensorcomm07}
\bibinfo{author}{L.~Lopes}, \bibinfo{author}{F.~Martins},
  \bibinfo{author}{M.~S. Silva} \& \bibinfo{author}{João Barros}
  (\bibinfo{year}{2007}): \emph{\bibinfo{title}{{A Process Calculus Approach to
  Sensor Network Programming}}}.
\newblock In: {\sl \bibinfo{booktitle}{SENSORCOMM '07}}.
  \bibinfo{publisher}{IEEE Computer Society}, pp. \bibinfo{pages}{451--456}.
\bibitemend

\bibitemstart{tinydb}
\bibinfo{author}{S.~Madden}, \bibinfo{author}{M.~J. Franklin},
  \bibinfo{author}{J.~M. Hellerstein} \& \bibinfo{author}{W.~Hong}
  (\bibinfo{year}{2005}): \emph{\bibinfo{title}{{TinyDB: An Acquisitional Query
  Processing System for Sensor Networks}}}.
\newblock {\sl \bibinfo{journal}{ACM Transactions on Database Systems}} .
\bibitemend

\bibitemstart{wireless:mezzetti:sangiorgi:06}
\bibinfo{author}{N.~Mezzetti} \& \bibinfo{author}{D.~Sangiorgi}
  (\bibinfo{year}{2006}): \emph{\bibinfo{title}{{Towards a Calculus for
  Wireless Systems}}}.
\newblock In: {\sl \bibinfo{booktitle}{{MFPS}'06}}, {\sl
  \bibinfo{series}{ENTCS}} \bibinfo{volume}{158}. \bibinfo{publisher}{Elsevier
  Science}, pp. \bibinfo{pages}{331--354}.
\bibitemend

\bibitemstart{ccs:milner:80}
\bibinfo{author}{R.~Milner} (\bibinfo{year}{1980}): \emph{\bibinfo{title}{{A
  Calculus of Communicating Systems}}}.
\newblock Number~\bibinfo{number}{92} in \bibinfo{series}{LNCS}.
  \bibinfo{publisher}{Springer-Verlag}.
\bibitemend

\bibitemstart{pi:milner:parrow:walker:92}
\bibinfo{author}{R.~Milner}, \bibinfo{author}{J.~Parrow} \&
  \bibinfo{author}{D.~Walker} (\bibinfo{year}{1992}): \emph{\bibinfo{title}{{A}
  {C}alculus of {M}obile {P}rocesses, ({P}arts {I} and {II})}}.
\newblock {\sl \bibinfo{journal}{Information and Computation}}
  \bibinfo{volume}{100}, pp. \bibinfo{pages}{1--77}.
\bibitemend

\bibitemstart{regiment2}
\bibinfo{author}{R.~Newton}, \bibinfo{author}{Arvind} \&
  \bibinfo{author}{M.~Welsh} (\bibinfo{year}{2005}):
  \emph{\bibinfo{title}{{Building up to Macroprogramming: An Intermediate
  Language for Sensor Networks.}}}
\newblock In: {\sl \bibinfo{booktitle}{IPSN'05}}. pp. \bibinfo{pages}{37--44}.
\bibitemend

\bibitemstart{regiment}
\bibinfo{author}{R.~Newton} \& \bibinfo{author}{M.~Welsh}
  (\bibinfo{year}{2004}): \emph{\bibinfo{title}{{Region Streams: Functional
  Macroprogramming for Sensor Networks}}}.
\newblock In: {\sl \bibinfo{booktitle}{{DMSN'04} Workshop}}.
\bibitemend

\bibitemstart{broadcast-high-order:ostrovsky:prasad:taha:02}
\bibinfo{author}{K.~Ostrovsk\'y}, \bibinfo{author}{K.~V.~S. Prasad} \&
  \bibinfo{author}{W.~Taha} (\bibinfo{year}{2002}):
  \emph{\bibinfo{title}{{Towards a Primitive Higher Order Calculus of
  Broadcasting Systems}}}.
\newblock In: {\sl \bibinfo{booktitle}{{PPDP'02}}}. \bibinfo{publisher}{{ACM}
  Press}, pp. \bibinfo{pages}{2--13}.
\bibitemend

\bibitemstart{pierce:types-programming-languages}
\bibinfo{author}{B.~C. Pierce} (\bibinfo{year}{2002}):
  \emph{\bibinfo{title}{Types and Programming Languages}}.
\newblock \bibinfo{publisher}{MIT Press}.
\bibitemend

\bibitemstart{broadcast:prasad:91}
\bibinfo{author}{K.~V.~S. Prasad} (\bibinfo{year}{1991}):
  \emph{\bibinfo{title}{{A Calculus of Broadcasting Systems}}}.
\newblock In: {\sl \bibinfo{booktitle}{{TAPSOFT}'91}}, number
  \bibinfo{number}{493} in \bibinfo{series}{LNCS}.
  \bibinfo{publisher}{Springer-Verlag}, pp. \bibinfo{pages}{338--358}.
\bibitemend

\bibitemstart{sangiorgi.walker:theory-mobile}
\bibinfo{author}{D.~Sangiorgi} \& \bibinfo{author}{D.~Walker}
  (\bibinfo{year}{2001}): \emph{\bibinfo{title}{The -calculus: a Theory of
  Mobile Processes}}.
\newblock \bibinfo{publisher}{Cambridge University Press}.
\bibitemend

\bibitemstart{tinyos}
\bibinfo{author}{TinyOS}.
\newblock \emph{\bibinfo{title}{{The TinyOS Documentation Project}}}.
\newblock \bibinfo{note}{Available at \textsf{http://www.tinyos.org}}.
\bibitemend

\bibliographyend
\end{thebibliography}




\end{document}
