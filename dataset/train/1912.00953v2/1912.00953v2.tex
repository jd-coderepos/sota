
\documentclass{article} \usepackage{iclr2020_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{url}
\usepackage{algorithm}
\usepackage{algorithmic}



\newcommand{\norm}[1]{\left\lVert #1 \right\rVert}
\newcommand{\logan}{LOGAN}
\newcommand{\G}[1]{G\left( #1 ; \theta_G \right)}
\newcommand{\D}[1]{D\left( #1 ; \theta_D \right)}
\newcommand{\Dz}{\Delta z}
\newcommand{\pG}{\theta_G}
\newcommand{\zpG}{\bar{\theta}_G}
\newcommand{\pD}{\theta_D}
\newcommand{\fz}{f(z)}
\newcommand{\fzp}{f(z')}
\newcommand{\ff}{f(z;\theta_D, \theta_G)}
\newcommand{\ffe}[3]{f(z #1 ;\theta_D #2, \theta_G #3)}
\newcommand{\expt}[2]{\mathbb{E}_{#1} \left[ #2 \right]}

\newcommand{\yan}[1]{{\color{red} Yan: {#1}}}
\newcommand{\jeff}[1]{{\color{blue} JD: {#1}}}
\newcommand{\tim}[1]{{\color{teal} Tim: {#1}}}
\newcounter{dbaCounter}
\newcommand{\dba}[1]{{\small \color{purple} \refstepcounter{dbaCounter}\textsf{[dba]:{#1}}}}

\newtheorem{theorem}{Theorem}

\title{LOGAN: Latent Optimisation for Generative Adversarial Networks}







\author{Yan Wu, Jeff Donahue, David Balduzzi, Karen Simonyan, Timothy Lillicrap\\
DeepMind\\
London, UK \\
\texttt{\{yanwu,jeffdonahue,dbalduzzi,simonyan,countzero\}@google.com} \\
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}
Training generative adversarial networks requires balancing of delicate adversarial dynamics. 
Even with careful tuning, training may diverge or end up in a bad equilibrium with dropped modes. 
In this work, we improve CS-GAN with natural gradient-based latent optimisation and show that it improves adversarial dynamics by enhancing interactions between the discriminator and the generator. 
Our experiments demonstrate that latent optimisation can significantly improve GAN training, obtaining state-of-the-art performance for the ImageNet () dataset. Our model achieves an Inception Score (IS) of  and an Fr\'{e}chet Inception Distance (FID) of , an improvement of  and  in IS and FID respectively, compared with the baseline BigGAN-deep model with the same architecture and number of parameters.
\end{abstract}




\section{Introduction}

Generative Adversarial Nets (GANs) are implicit generative models that can be trained to match a given data distribution.  GANs were originally developed by~\citet{goodfellow2014generative} for image data.
As the field of generative modelling has advanced, GANs remain at the frontier, generating high-fidelity images at large scale \citep{brock2018large,karras2019style}. 
However, despite growing insights into the dynamics of GAN training, much of the progress in GAN-based image generation come from network architecture improvements \citep{radford2015unsupervised,zhang2019self}, or regularisation of particular parts of the model \citep{miyato2018spectral,miyato2018cgans}.

Build on the compressed sensing view of GANs (CS-GAN; \citealp{wu2019deep}), we improve the efficacy of latent optimisation in adversarial games, using natural gradient descent to optimise the latent variable (usually denoted ) towards the direction favoured by the discriminator during training.
This results in a scalable and easy to implement approach that improves the dynamic interaction between the discriminator and the generator.
We generally call these approaches latent optimised GANs (LOGAN).

\begin{figure}[htb]
    \centering
    \begin{tabular}{c c}
    \includegraphics[width=0.45\linewidth]{figures/samples/fig2_BD.jpeg} &
    \includegraphics[width=0.45\linewidth]{figures/samples/fig2_LOGAN.jpeg} \\
    (\textbf{a}) &
    (\textbf{b}) \\
    \end{tabular}
    \caption{Samples from BigGAN-deep (\textbf{a}) and LOGAN (\textbf{b}) with similarly high IS. Samples from the two panels were drawn from truncation levels corresponding to points C and D in Figure~\ref{fig:model-truncation} \textbf{b} respectively. (FID/IS: (\textbf{a}) 27.97/259.4, (\textbf{b}) 8.19/259.9)}
    \label{fig:samples-high-IS}
\end{figure}

To summarise our contributions:
\begin{enumerate}
    \item We propose an improved, efficient approach to latent optimisation using natural gradient descent.
    \item Our algorithm improves the state-of-the-art BigGAN~\citep{brock2018large} by a significant margin, without introducing any architectural change, resulting in higher quality images and more diverse samples (see Table~\ref{tab:scores}, Figure~\ref{fig:samples-high-IS} and \ref{fig:samples-low-FIDs}).
    \item To provide theoretical insight, we analyse latent optimisation in GANs from the perspective of differentiable games~\citep{balduzzi2018mechanics}. We argue that latent optimisation can be viewed as improving the dynamics of adversarial training.
\end{enumerate}

\begin{figure}[ht]
    \centering
    \begin{tabular}{cc}
    \includegraphics[width=0.45\linewidth]{figures/samples/fig1_BD_1.jpeg} &
    \includegraphics[width=0.45\linewidth]{figures/samples/fig1_LOGAN_2.jpeg} \\
    (\textbf{a}) &
    (\textbf{b}) \end{tabular}
    \caption{Samples from BigGAN-deep (\textbf{a}) and LOGAN (\textbf{b}) with  similarly low FID. Samples from the two panels were drawn from truncation levels corresponding to points A and B in Figure~\ref{fig:model-truncation} \textbf{b} respectively. (FID/IS: (\textbf{a}) 5.04/126.8, (\textbf{b}) 5.09/217.0)}
    \label{fig:samples-low-FIDs}
\end{figure}

\section{Background}

\subsection{Notation}
We use  and  to denote the vectors representing parameters of the generator and discriminator. We use  for images, and  for the latent source generating an image. We use prime  to denote a variable after one update step, e.g., .  and  denote the data distribution and source distribution respectively.  indicates taking the expectation of function  over the distribution .

\subsection{Generative Adversarial Nets}

\begin{table}[tb]
\caption{Comparison of model scores. BigGAN-deep results are reproduced from \cite{brock2018large}. ``baseline" indicates our reproduced BigGAN-deep with small modifications. The 3rd and 4th columns are from the gradient descent (GD, ablated) and natural gradient descent (NGD) versions of LOGAN respectively. We report the Inception Score (IS, higher is better, \citealt{salimans2016improved}) and Fr{\'e}chet Inception Distance (FID, lower is better, \citealt{heusel2017gans}).}
\label{sample-table}
\begin{center}
\begin{tabular}{l|ll}
         & FID & IS \\
\hline
BigGAN-deep  &  &  \\
baseline &  &  \\
LOGAN (GD) &  &  \\
LOGAN (NGD) &  & 
\end{tabular}
\end{center}
\label{tab:scores}
\end{table}

A GAN consists of a generator that generates image  from a latent source , and a discriminator that scores the generated images as  \citep{goodfellow2014generative}. Training GANs involves an adversarial game: while the discriminator tries to distinguish generated samples  from data , the generator tries to fool the discriminator.
This procedure can be summarised as the following min-max game:

The exact form of  depends on the choice of loss function \citep{goodfellow2014generative,arjovsky2017wasserstein,nowozin2016f}. To simplify our presentation and analysis, we use the Wasserstein loss~\citep{arjovsky2017wasserstein}, so that  and . Our experiments with BigGAN-deep use the hinge loss \citep{lim2017geometric,tran2017hierarchical}, which is identical to this form in its linear regime. 
Our analysis can be generalised to other losses as in previous theoretical work (e.g., \citealt{arora2017generalization}).
To simplify notation, we abbreviate , which may be further simplified as  when the explicit dependency on  and  can be omitted.

Training GANs requires carefully balancing updates to  and , and is sensitive to both architecture and algorithm choices \citep{salimans2016improved,radford2015unsupervised}. A recent milestone is BigGAN (and BigGAN-deep, \citealt{brock2018large}), which pushed the boundary of high fidelity image generation by scaling up GANs to an unprecedented level. BigGANs use an architecture based on residual blocks \citep{he2016deep}, in combination with regularisation mechanisms and self-attention \citep{saxe2013exact, miyato2018spectral,zhang2019self}.

Here we aim to improve the adversarial dynamics during training. We focus on the second term in eq.~\ref{eq:minmax} which is at the heart of the min-max game. For clarity, we explicitly write the losses for  as  and  as , so the total loss vector can be written as


Computing the gradients with respect to  and  gives the following vector field, which \emph{cannot} be expressed as the gradient of any single function \citep{balduzzi2018mechanics}:


The fact that  is not the gradient of a function implies that gradient updates in GANs can exhibit cycling behaviour which can slow down or prevent convergence. 
\citet{balduzzi2018mechanics} refer to vector fields of this form as the \emph{simultaneous gradient}. Although many GAN models use alternating update rules (e.g., \citealt{goodfellow2014generative,brock2018large}), following the gradient with respect to  and  alternatively in each step, they share the same problem from gradients of this form. Therefore, we use the simpler simultaneous gradient (eq.~\ref{eq:sg}) for our analysis (see also \citealt{mescheder2017,mescheder2018training}).


\begin{figure}[ht]
    \centering
    \begin{tabular}{cc}
    \includegraphics[width=0.3\linewidth]{figures/logan_model.png}  &
    \includegraphics[width=0.5\linewidth]{figures/truncate_labelled.png} \\
    (\textbf{a}) &
    (\textbf{b}) 
    \end{tabular}
    \caption{(\textbf{a}) Schematic of LOGAN. We first compute a forward pass through  and  with a sampled latent . Then, we use gradients from the generator loss (dashed red arrow) to compute an improved latent, . After we use this optimised latent code in a second forward pass, we compute gradients of the discriminator back through the latent optimisation into the model parameters , . We use these gradients to update the model.
    (\textbf{b}) Truncation curves illustrate the FID/IS trade-off for each model by altering the range of the noise source . GD: gradient descent. NGD: natural gradient descent. Points A, B, C, D correspond to samples shown in Figure~\ref{fig:samples-high-IS} and \ref{fig:samples-low-FIDs}.}
    \label{fig:model-truncation}
\end{figure}



\subsection{Latent Optimised GANs}

\begin{algorithm}[tb]
   \caption{Latent Optimised GANs with Automatic Differentiation}
\begin{algorithmic}
   \STATE {\bfseries Input:} data distribution , latent distribution , , , learning rate , batch size 
   \REPEAT
   \STATE Initialise discriminator and generator parameters , 
   \FOR{ {\bfseries to} }
       \STATE Sample , 
       \STATE Compute the gradient  and use it to obtain  from eq.~\ref{eq:lo} (GD) or eq.~\ref{eq:ng-g} (NGD)
       \STATE Optimise the latent ,  indicates clipping the value between  and  
       \STATE Compute generator loss 
       \STATE Compute discriminator loss 
   \ENDFOR
   \STATE Compute batch losses
        and
       
   \STATE Update  and  with the gradients , 
   \UNTIL{reaches the maximum training steps}
\end{algorithmic}
\label{alg}
\end{algorithm}

Inspired by compressed sensing \citep{candes2006stable,donoho2006compressed}, \citet{wu2019deep} introduced latent optimisation for GANs. Latent optimisation exploits knowledge from  to refine the latent source . Intuitively, the gradient  points in the direction that better satisfies the discriminator , which implies better samples. Therefore, instead of using the randomly sampled , \citet{wu2019deep} uses the optimised latent

in eq.~\ref{eq:minmax} for training \footnote{Although multiple gradient descent steps can be employed for optimising , we found one step works well in training and justify this choice in section \ref{sec:analysis}.}. 

Historically, compressed sensing has been developed as a signal processing technique mostly without any concern on training. However, here we emphasise the influence of this procedure on training, which we will show dominates the effects on large scale models --- in contrast, the run-time optimisation that is central in compressed sensing may be unnecessary after training. Therefore, we call this type of models latent-optimised GANs (LOGAN) to avoid any confusion, except when explicitly referring to the results from \cite{wu2019deep}. Latent optimisation has been shown to improve the stability of training as well as the final performance for medium-sized models such as DCGANs and Spectral Normalised GANs \citep{radford2015unsupervised,miyato2018spectral}. The general algorithm is summarised in Algorithm~\ref{alg} and illustrated in Figure~\ref{fig:model-truncation} \textbf{a}. However, we found that the potential of latent optimisation remained largely untapped in this setting, and develop the natural gradient descent form of latent update in Section~\ref{sec:logan-ngd}.

\section{Analysis of the Algorithm}
\label{sec:analysis}
To understand how latent optimisation interacts with GAN training, we analyse LOGAN as a differentiable game following \citet{balduzzi2018mechanics, gemp:18, letcher2019differentiable}.
The Appendix~\ref{app:analysis} provides a complementary analysis form the perspective of stochastic approximation \citep{heusel2017gans,borkar1997stochastic}. 
We can explicitly compute the gradients for the discriminator and generator at  after one step of latent optimisation by differentiating  (where  from eq.~\ref{eq:lo}):

In both equations, the first terms represent how  depends on the parameters directly, which also appear in the gradients from vanilla GANs (eq.~\ref{eq:sg}). However, the second terms are introduced from latent optimisation, accounting for how  depends on the parameters via the change . For the second equality, we substitute  as the gradient-based update of  and use .
Further differentiating  results in the second-order terms  and .
The original GAN's gradient (eq.~\ref{eq:sg}) does not include any second-order term, since  without latent optimisation. LOGAN computes these extra terms by automatic differentiation when back-propagating through the latent optimisation process (see Algorithm \ref{alg}). 

\subsection{Relation with SGA}

\citet{balduzzi2018mechanics, gemp:18} proposed Symplectic Gradient Adjustment (SGA) to improve the dynamics of gradient-based methods in adversarial games. SGA addresses an important problem with gradient-based optimisation in GANs: the vector-field generated by the losses of the discriminator and generator is not a gradient vector field. It follows that gradient descent is not guaranteed to find a local optimum and can cycle, which can slow down convergence or lead to phenomena like mode collapse and mode hopping. 

For a game with gradient  (eq.~\ref{eq:sg}), the Hessian is the second order derivatives with respect to the parameters, . SGA uses the adjusted gradient

where  is a positive constant and  is the anti-symmetric component of the Hessian. Applying SGA to GANs yields the adjusted updates (see Appendix~\ref{app:analysis}.1 for details):

Compared with  in eq.~\ref{eq:sg}, the adjusted gradient  has second-order terms reflecting the interactions between  and . SGA significantly improves GAN training in simple examples \citep{balduzzi2018mechanics}, allowing faster and more robust convergence to stable fixed points (local Nash equilibria). 
Unfortunately, SGA is expensive to scale because computing the second-order derivatives with respect to all parameters is expensive. It remains unclear whether SGA can be incorporated into very large scale models using more efficient implementation (e.g., Hessian-vector products from modified back propagation \cite{pearlmutter1994fast}).

The SGA updates in eq.~\ref{eq:adjust-g} and the LOGAN updates in eq.~\ref{eq:lo-g} are strikingly similar, suggesting that the latent step used by LOGAN reduces the negative effects of cycling by introducing a symplectic gradient adjustment into the optimisation procedure. The role of the latent step can be formalised in terms of a third player, whose goal is to help the generator (see appendix~\ref{app:analysis} for details).  
Crucially, latent optimisation approximates SGA using only second-order derivatives with respect to the latent  and parameters of the discriminator and generator \emph{separately}. The second order terms involving parameters of both the discriminator and the generator -- which are expensive to compute -- are not used. In short, with a simple modification of the original GAN training algorithm, latent optimisation couples the gradients of the discriminator and generator in a way similar to SGA.

\subsection{Relation with Unrolled GANs}
\label{app:unroll}

In addition, latent optimisation can be seen as unrolling GANs \citep{DBLP:journals/corr/MetzPPS16} in the space of the latent source, rather than the parameters. Unrolling in the latent space has the advantages that:
\begin{enumerate}
    \item LOGAN is more scalable than Unrolled GANs because it avoids unrolling the parameter updating process, which is prohibitively expensive for models with a large number of parameters.
    \item While unrolling the update of  only affects the parameters of  (as in \citealt{DBLP:journals/corr/MetzPPS16}), latent optimisation effects  both  and  as shown in eq.~\ref{eq:lo-g}.
\end{enumerate}
We next formally present this connection by first showing that SGA can be seen as approximating Unrolled GANs \citep{DBLP:journals/corr/MetzPPS16}. For the update , we have the Taylor expansion approximation at :

Substitute the gradient descent parameter update , and take the derivatives with respect to  on both sides:

which has the same form as eq.~\ref{eq:adjust-g} (taking the negative sign).
Compared with the exact gradient from the unroll:

The approximation in eq.~\ref{eq:ugan-g} comes from using  and  as a result of additional linear approximation.

At this point, unrolling  update only affects
. Although it is expensive to unroll both  and , in principle, we can unroll  update and compute the gradient of  similarly using :

which gives us the same update rule as SGA (eq.~\ref{eq:adjust-g}). This correspondence based on first order Taylor expansion is unsurprising, as SGA is based on linearising the adversarial dynamics \citep{balduzzi2018mechanics}.

Therefore, given the previous section, we can view LOGAN as further approximating Unrolled GAN, by unrolling the update of latent source  instead of the parameters. Although the information from  is limited compared with all the parameters, the intuition from Unrolled GANs applies here: unrolling the update of  gives  and  extra information to react to their opponents, thus avoiding the circular behaviour.




\section{LOGAN with Natural Gradient Descent}
\label{sec:logan-ngd}

Our analysis explains why latent optimisation may help GAN training. In practice, we expect more benefit from latent optimisation from \emph{stronger} optimiser for , which can better capture the coupling between  and .
\cite{wu2019deep} only used basic gradient descent (GD) with a fixed step-size. This choice limits the size  can take: in order not to overshoot when the curvature is large, the step size would be too conservative when the curvature is small. We hypothesis that GD is more detrimental for larger models, which have complex loss surfaces with highly varying curvatures. Consistent with this hypothesis, we observed only marginal improvement over the baseline using GD (section~\ref{sec:exp-ablation}, Table~\ref{tab:scores}, Figure~\ref{fig:model-truncation} \textbf{b}).

In this work, we propose using natural gradient descent (NGD, \citealt{amari1998natural}) for latent optimisation. NGD is an approximate second-order optimisation method, and has been applied successfully in many domains \citep{pascanu2013revisiting,martens2014new}. By using the positive semi-definite (PSD) Gauss-Newton matrix to approximate the (possibly negative definite) Hessian, NGD often works even better than exact second-order methods. NGD is expensive in high dimensional parameter spaces, even with approximations \citep{martens2014new}. However, we demonstrate that it is efficient for latent optimisation, even in very large models.


Given the gradient of , , NGD computes the update as

where the Fisher information matrix  is defined as

The log-likelihood function  typically corresponds to commonly used error functions such as the cross entropy loss. This correspondence is not necessary when we interpret NGD as an approximate second-order method, as has long been done \citep{martens2014new}. Nevertheless, Appendix~\ref{app:poisson-ll} provides a Poisson log-likelihood interpretation for the hinge loss commonly used in GANs \citep{lim2017geometric,tran2017hierarchical}.
An important difference between latent optimisation and commonly seen scenarios using NGD is that the expectation over the condition () is absent. Since each  is only responsible for generating one image, it only minimises the loss  for this particular instance.

More specifically, we use the \emph{empirical} Fisher  with Tikhonov damping, as in TONGA~\citep{roux2008topmoumoute}

 is cheaper to compute compared with the full Fisher, since  is already available.
The \emph{damping factor}  regularises the step size, which is important when  only poorly approximates the Hessian or when the Hessian changes too much across the step.
Using the Sherman-Morrison formula, the NGD update can be simplified into the following closed form:

which does not involve any matrix inversion. Thus, NGD adapts the step size according to the curvature estimate .
When  is small, NGD normalises the gradient by its squared L2-norm.
NGD automatically smooths the scale of updates by down-scaling the gradients as their norm grows, which also contributes to the smoothed norms of updates (Appendix~\ref{app:analysis}.2). Since the NGD update remains proportional to , our analysis based on gradient descent in section~\ref{sec:analysis} still holds. 

\subsection*{Additional Regularisation}

Various regularisation techniques are often necessary to ensure the stable training of GANs. Here we highlight two of them that we found particularly useful in combination with LOGAN. First, we found regularising the Euclidean norm of optimisation step,

where the scalar weight  is a parameter, as introduced by \citet{wu2019deep} is necessary, especially for large models. This term is added to both the generator loss and discriminator loss in training. \citet{wu2019deep} suggested this term is related to optimal transport; more recently, \citet{tanaka2019discriminator} formalised this connection in Discriminator Optimal Transport (DOT). We left the exact connection between our work and DOT to future investigation, but here note that while DOT improves evaluation performance, our method mainly focuses on training. Consequently, although the regulariser  shares the same form as that in DOT, they function differently: it regularises the update of parameters here, but the latent code  in DOT.

In addition, we found it is more stable to optimise only a portion  of , leaving some of its elements completely random, which can be seem an additional damping mechanism while preserve more randomness from the latent source.

\section{Experiments and Analysis}
\label{sec:experiments}

We tested our algorithm for both medium (DCGAN, \citealt{radford2015unsupervised,miyato2018spectral}) and large scale (BigGAN, \citealt{brock2018large}) models. We use the standard hyper-parameter settings for each GAN model, without further optimising them with LOGAN. We performed grid-search over the four parameters introduced in LOGAN: the latent step size , damping factor , the regularisation weight , and the portion of  being optimised as . Details of the grid search are summarised in Appendix~\ref{app:hyper}. Additional empirical analysis of latent optimisation is presented in Appendix \ref{app:analyse-logan}.

\subsection{Experiments with DCGAN on CIFAR}
\label{app:dcgan}

To verify if our proposed NGD optimiser works well for latent optimisation, we first test LOGAN at more moderate scales for direct comparison with \citet{wu2019deep} using basic GD. Here we apply latent optimisation on Spectral Normalised GANs (SN-GANs, \citealt{miyato2018spectral}). 

The experiments follows the same basic setup and hyper-parameter settings as the CS-GAN in \cite{wu2019deep}. There is no class conditioning in this model. With NGD, we use a large step size of  and the damping factor  for optimising . We found the weight of  for the regulariser  (eq.~\ref{eq:z_reg}), and optimising  of the latent source worked best for SN-GANs. All other parameters are same as in \citealt{wu2019deep}.

In addition, we found running extra latent optimisation steps benefited evaluation, so we use ten steps of latent optimisation in evaluation for results in this section, although the models were still trained with a single optimisation step. This is different from in larger models, where optimisation is unnecessary in evaluation (see section~\ref{sec:biggan-basic} for more details).

Table~\ref{tab:dcgan-scores} shows the FID and IS alongside SN-GAN and CS-CAN which used the same architecture. The scores are computed based on  samples following the same procedure as in \citet{wu2019deep}. We observe that NGD brought significant improvement over CS-GAN (i.e., LOGAN with GD for optimising ). Compared with the baseline SN-GAN model without employing any latent optimisation, there is an improvement of  in IS and  in FID.
Figure~\ref{fig:app_samples} compares random samples from these two models. Overall, samples from LOGAN (NGD) have higher contrasts and sharper contours.

\begin{table}[htb]
\caption{Comparison of Scores. The first and second columns are reproduced from \cite{miyato2018spectral} and \cite{wu2019deep} respectively. We report the Inception Score (IS, higher is better, \citealt{salimans2016improved}) and Fr{\'e}chet Inception Distance (FID, lower is better, \citealt{heusel2017gans}).}
\label{tab:app}
\begin{center}
\begin{tabular}{l|lll}
         & SN-GAN & CS-GAN & LOGAN (NGD) \\
\hline
FID  &  &  &  \\
IS   &  &  &  \\
\end{tabular}
\end{center}
\label{tab:dcgan-scores}
\end{table}

\begin{figure}[htb]
    \centering
    \begin{tabular}{cc}
    \includegraphics[width=0.45\linewidth]{figures/samples/app_samples_logan.jpeg} &
    \includegraphics[width=0.45\linewidth]{figures/samples/app_samples_sn.jpeg} \\
    (\textbf{a}) &
     (\textbf{b})
    \end{tabular}
    \caption{(\textbf{a}) Samples from SN-GAN. (\textbf{b}) Samples from LOGAN.}
    \label{fig:app_samples}
\end{figure}

\subsection{Experiments with BigGAN on ImageNet}
\label{sec:biggan}

To illustrate the scalability of our algorithm, we next focus on large scale models based on BigGAN-deep \citep{brock2018large} trained on  size images from the ImageNet dataset \citep{imagenet_cvpr09}.

\subsubsection{Model Configuration}

We used the standard BigGAN-deep architecture with three minor modifications:
1. We increased the size of the latent source from  to , to compensate the randomness of the source lost when optimising . 2. We use the uniform distribution  instead of the standard normal distribution  for  to be consistent with the clipping operation (Algorithm \ref{alg}). 3. We use \texttt{leaky~ReLU} (with the slope of  for the negative part) instead of \texttt{ReLU} as the non-linearity for smoother gradient flow for . 

Consistent with the detailed findings in \cite{brock2018large}, our experiment with this baseline model obtains only slightly better scores compared with those in \cite{brock2018large} (Table~\ref{tab:scores}, see also Figure~\ref{fig:all_truncate} in Appendix~\ref{app:samples_and_truncation}). We computed the FID and IS as in \cite{brock2018large}, and computed IS values from checkpoints with the lowest FIDs. Finally, we computed the means and standard deviations for both measures from 5 models with different random seeds.

To apply latent optimisation with NGD, we use the same large step size of  as in SN-GAN (section~\ref{app:dcgan}). However, we found much heavier damping is essential for BigGAN, so we use the damping factor , and only optimise  of 's elements. Consistent with \citet{tanaka2019discriminator}, we found a much larger weight of  for the regulariser  (eq.~\ref{eq:z_reg}) works best, since deeper models generally have larger Lipschitz constants. All other hyper-parameters, including learning rates and a large batch size of 2048, remain the same as in BigGAN-deep. We call this model LOGAN (NGD).

\subsubsection{Basic Results}
\label{sec:biggan-basic}

Employing the same architecture and number of parameters as the BigGAN-deep baseline, LOGAN (NGD) achieved better FID and IS (Table~\ref{tab:scores}). As observed by \citet{brock2018large}, BigGAN training eventually collapsed in every experiment. Training with LOGAN also collapsed, perhaps due to higher-order dynamics beyond the scope we have analysed, but it took significantly longer (600k steps versus 300k steps with BigGAN-deep). 

During training, LOGAN was about  times slower per step compared with BigGAN-deep because of the additional forward and backward passes. In contrast to experiments with smaller models (section~\ref{app:dcgan}), we found that optimising  during evaluation did not improve sample scores (even up to 10 steps), so we do not optimise  for evaluation. Therefore, LOGAN has the same evaluation cost as original BigGAN-deep. To help understand this behaviour, we plot the change from  during training in Figure~\ref{fig:train} \textbf{a}. Although the movement in Euclidean space  grew until training collapsed, the movement in 's output space, measured as , remained unchanged (see Appendix~\ref{app:comp-distance} for details). As shown in our analysis, optimising  improves the training dynamics, so LOGANs work well after training without requiring latent optimisation. 
We reckon that smaller models might not be ``over-parametrised'' enough to fully amortise the computation from optimising , which can then further exploit the architecture in evaluation time.
Appendix~\ref{app:analyse-logan} further illustrates these different behaviours. We aim to further investigate this difference in future studies.

Given the criticism of FID and IS as heuristics metrics for sample distributions, we further measure how these samples directly contribute to downstream classification task via the recently proposed Classification Accuracy Score (CAS, \citealt{ravuri2019classification}). Unlike FID and IS, this metric favours likelihood-based models, which are more likely cover all modes representing different classes. The CAS from LOGAN nearly halved the gap between the state-of-the-art GANs and VQ-VAE2 \citep{razavi2019generating}. See Appendix~\ref{app:cas} for more details.

\subsubsection{Ablation Studies}
\label{sec:exp-ablation}

\begin{figure}[htb]
    \centering
    \begin{tabular}{cc}
    \includegraphics[width=0.4\linewidth]{figures/distance_z.png} &
    \includegraphics[width=0.4\linewidth]{figures/ablation_grad.png} \\
    (\textbf{a}) &
    (\textbf{b})
    \end{tabular}
    \caption{(\textbf{a}) The change from  across training, in 's output space and 's Euclidean space. The distances are normalised by their standard derivations computed from a moving window of size  ( data points in total). (\textbf{b}) Training curves from models with different ``\texttt{stop\_gradient}'' operations. For reference, the training curve from an unablated model is plotted as the dashed line. All instances with \texttt{stop\_gradient} collapsed (FID went up) early in training.}
    \label{fig:train}
\end{figure}

We verify our theoretical analysis in section~\ref{sec:analysis} by examining key components of Algorithm~\ref{alg} via ablation studies. First, we experiment with using basic GD to optimising , as in \cite{wu2019deep}, and call this model LOGAN (GD). A smaller step size of  was required; larger values were unstable and led to premature collapse of training. As shown in Table~\ref{tab:scores}, the scores from LOGAN (GD) were worse than LOGAN (NGD) and similar to the baseline model.

We then evaluate the effects of removing those terms depending on  in eq.~\ref{eq:lo-g}, which are not in the ordinary gradient (eq.~\ref{eq:sg}). Since we computed these terms by back-propagating through the latent optimisation procedure, we removed them by selectively blocking back-propagation with ``\texttt{stop\_gradient}'' operations (e.g., in TensorFlow, \citealt{abadi2016tensorflow}). Figure~\ref{fig:train} \textbf{b} shows the change of FIDs for the three models corresponding to removing , removing  and removing both terms.
As predicted by our analysis (section \ref{sec:analysis}), both terms help stabilise training; training diverged early for all three ablations.

\subsubsection{Truncation and Samples}

Truncation is a technique introduced by \cite{brock2018large} to illustrate the trade-off between the FID and IS in a trained model. For a model trained with  from a source distribution symmetric around , such as the standard normal distribution  and the uniform distribution , down-scaling (truncating) the source  with  gives samples with higher visual quality but reduced diversity. We see this quantified in higher IS scores and lower FID when evaluating samples from truncated distributions.

Figure~\ref{fig:model-truncation} \textbf{b} plots the truncation curves for the baseline BigGAN-deep model, LOGAN (GD) and LOGAN (NGD), obtained by varying the truncation (value of ) from  (no truncation, upper-left ends of the curves) to  (extreme truncation, bottom-right ends). Each curve shows the trade-off between FID and IS for an individual model; curves towards the upper-right corner indicate better overall sample quality. The relative positions of curves in figure~\ref{fig:model-truncation} (\textbf{b}) shows LOGAN (NGD) has the best sample quality. Interestingly, although LOGAN (GD) and the baseline model have similar scores without truncation (upper-left ends of the curves, see also Table~\ref{tab:scores}), LOGAN (GD) was better behaved with increasing truncation, suggesting LOGAN (GD) still converged to a better equilibrium. For further reference, we plot truncation curves from additional baseline models in Figure~\ref{fig:all_truncate} (Appendix~\ref{app:samples_and_truncation}).

Figure~\ref{fig:samples-high-IS} and Figure~\ref{fig:samples-low-FIDs} show samples from selected points along the truncation curves. 
In the high IS regime, C and D on the truncation curves both have similarly high IS of near 260. Samples from batches with such high IS have almost photo-realistic image quality. Figure~\ref{fig:samples-high-IS} shows that while the baseline model produced nearly uniform samples, LOGAN (NGD) could still generate highly diverse samples.
On the other hand, A and B from Figure~\ref{fig:model-truncation} \textbf{b} have similarly low FID of near 5, indicating high sample diversity. Samples in Figure~\ref{fig:samples-low-FIDs} \textbf{b} show higher quality compared with those in \textbf{a} (e.g., the interfaces between the elephants and ground, the contours around the pandas).

\section{Conclusion}

In this work, we present LOGAN, which significantly improves the state of the art in large scale GAN training for image generation by optimising the latent source .
Our results illustrate improvements in quantitative evaluation and samples with higher quality and diversity. 
Moreover, our analysis suggests that LOGAN fundamentally improves adversarial training dynamics.
LOGAN is related to the energy-based formulation of a GAN's discriminator \citep{dai2017calibrating,kumar2019maximum,du2019implicit}, when latent optimisation is viewed as descending the energy function defined by the discriminator.
From this view, sampling from the distribution implicitly defined by this energy function, via, e.g., Langevin sampling \citep{welling2011bayesian}, may bring further benefits.
Another class of approaches regularises the entropy of the generator outputs to reduce mode collapse~\citep{mine,presgan}.
Such techniques could be combined with LOGAN to further improve coverage of the underlying data distribution.
Moreover, we expect our method to be useful in other tasks that involve adversarial training, including representation learning and inference \citep{donahue2016adversarial,ali,bigbigan}, text generation \citep{zhang2019self}, style learning \citep{zhu2017unpaired,karras2019style}, audio generation \citep{donahue2018adversarial} and video generation \citep{vondrick2016generating,clark2019efficient}.

\subsubsection*{Acknowledgments}
We thank Mihaela Rosca, Suman Ravuri and James Martens for comments on the draft and insightful discussions.


\bibliography{iclr2020_conference}
\bibliographystyle{iclr2020_conference}



\appendix

\section{Detailed Analysis of Latent Optimisation}
\label{app:analysis}
In this section we present complementary of LOGAN. In particular, we show how the algorithm brings together ideas from symplectic gradient adjustment and stochastic approximation with two time scales. 

\subsection{Approximate Symplectic Gradient Adjustment}
\label{app:approx-sga}

To analyse LOGAN as a differentiable game we treat the latent step  as adding a \emph{third player} to the original game played by the discriminator and generator. The third player's parameter, , is optimised online for each . Together the three players (latent player, discriminator, and generator) have losses \emph{averaged over a batch of samples}:

where  ( is the batch size) reflects the fact that each  is only optimised for a single sample , so its contribution to the total loss across a batch is small compared with  and  which are directly optimised for batch losses. This choice of  is essential for the following derivation, and has important practical implication. It means that the per-sample loss , instead of the loss summed over a batch , should be the only loss function guiding latent optimisation. Therefore, when using natural gradient descent (Section~4), the Fisher information matrix should only be computed using the current sample .

The resulting simultaneous gradient is

Following \cite{balduzzi2018mechanics}, we can write the Hessian of the game as:


The presence of a non-zero anti-symmetric component in the Hessian

implies the dynamics have a rotational component which can cause cycling or slow down convergence. 
Since  for typical batch sizes (e.g.,  for DCGAN and  for BigGAN-deep), we abbreviate  to simplify notations. 

Symplectic gradient adjustment (SGA) counteracts the rotational force by adding an adjustment term to the gradient to obtain , which for the discriminator and generator has the form:

The gradient with respect to  is ignored since the convergence of training only depends on  and . 

If we drop the last terms in eq.\ref{eq:sga-d} and \ref{eq:sga-g}, which are expensive to compute for large models with high-dimensional  and , and use , the adjusted updates can be rewritten as

Because of the third player, there are still the terms depend on  to adjust the gradients. Efficiently computing  and  is non-trivial (e.g., \citealt{pearlmutter1994fast}). 
However, if we introduce the local approximation

then the adjusted gradient becomes identical to eq.~6 from latent optimisation.

In other words, automatic differentiation by commonly used machine learning packages can compute the adjusted gradient for  and  when back-propagating through the latent optimisation process.
Despite the approximation involved in this analysis, both our experiments in section~5 and the results from \cite{wu2019deep} verified that latent optimisation can significantly improve GAN training. 

\subsection{Stochastic Approximation with Two Time Scales}
\label{sec:a-stoch-approx}

This section shows that latent optimisation accelerates the speed of updating  relative to the speed of updating , facilitating convergence according to~\citet{heusel2017gans} (see also Figure~\ref{fig:grad-scale-update} \textbf{b}). Intuitively, the generator  requires less updating compared with  to achieve the same reduction of loss because latent optimisation ``helps'' .


\begin{figure}[ht]
    \centering
    \begin{tabular}{c}
    \includegraphics[width=0.5\linewidth]{figures/g_speed.png}
    \end{tabular}
    \caption{The update speed of the discriminator relative to the generator shown as the difference  after each update step. Lines are smoothed with a moving average using window size 20 (in total, there are 3007, 1659 and 1768 data points for each curve). All curves oscillated strongly after training collapsed.}
    \label{fig:grad-scale-update}
\end{figure}


\cite{heusel2017gans} used the theory of stochastic approximation to analyse GAN training. Viewing the training process as stochastic approximation with two time scales \citep{borkar1997stochastic,konda1999actor}, they suggest that the update of  should be fast enough compared with that of . Under mild assumptions, \cite{heusel2017gans} proved that such two time-scale update converges to local Nash equilibrium.
Their analysis follows the idea of  perturbation \citep{hirsch1989convergent}, where the slow updates () are interpreted as a small perturbation over the ODE describing the fast update (). Importantly, the size of perturbation  is measured by the magnitude of parameter change, which is affected by both the learning rate and gradients.

Here we show, in accordance with \cite{heusel2017gans}, that LOGAN accelerates discriminator updates and slows down generator updates, thus helping the convergence of discriminator.
We start from analysing the change of . We assume that, without LO, it takes  to make a small constant amount of reduction in loss : 

Now using the optimised , we assess the change  required to achieve the same amount of reduction:

Intuitively, when  ``helps''  to achieve the same goal of increasing  by , the responsible of  becomes smaller, so it does not need to change as much as , thus .

Formally,   and  have the following Taylor expansions around  and :

Where 's are higher order terms of the increments.
Using the assumption of eq.~\ref{eq:rho_1} and \ref{eq:rho_2}, we can combine eq.~\ref{eq:f-o-taylor} and \ref{eq:f-taylor}:

where . Since  in gradient descent (eq.~3), 

Therefore, we have the inequality

If we further assume  and   are obtained from stochastic gradient descent with identical learning rate,

substituting eq.~\ref{eq:sgd} into eq.~\ref{eq:ieq_1} gives

The same analysis applies to the discriminator. The similar intuition is that it takes the discriminator additional effort to compensate the exploitation from the optimised . We then obtain

However, since the adversarial loss , we have
 and

taking the opposite signs of eq.\ref{eq:sgd}.  
For sufficiently small ,  and ,  is close to zero, 
so  under our assumptions of small ,  and .

Importantly, the bigger the product  is, the more robust the inequality is to the error from . Moreover, bigger steps increase the speed gap between updating D and G, further facilitating convergence (in accordance with~\cite{heusel2017gans}). Overall, our analysis suggests:
\begin{enumerate}
    \item More than one gradient descent step may not be helpful, since  from multiple GD steps may deviate from the direction of .
    \item A large step of  is helpful in facilitating convergence by widening the gap between D and G updates \citep{heusel2017gans}.
    \item However, the step of  cannot be too large. In addition to the linear approximation we used throughout our analysis, the approximate SGA breaks down when eq.\ref{eq:sga-z-approx} is strongly violated when ``overshoot'' brings the gradients at  to the opposite sign of .
\end{enumerate}

\section{Additional Analysis of Latent Optimisation}
\label{app:analyse-logan}

Here we analyse the relationship between the number of latent optimisation steps during evaluation and the final FIDs and inception scores. As in the main paper, we train the SN-GAN model with only 1 latent optimisation step, but test them with  steps during evaluation. For lower variance in computing the scores, we use  samples for evaluation (as oppose to  samples used in the main paper for direct comparison with other baselines). The inception scores are taken from checkpoints with the best (lowest) FIDs, and the error bars indicate standard deviations obtained from 3 different random seeds.

Figure~\ref{fig:lo-scores} shows that the scores can be substantially improved with extra optimisation steps in evaluation. Although only 1 step was used in training, up to around 20 steps at evaluation could still improve sample quality. Beyond that, the return from extra computation became diminishing.
\begin{figure}[ht]
    \centering
    \begin{tabular}{cc}
    \includegraphics[width=0.45\linewidth]{figures/os_FID.png} &
    \includegraphics[width=0.45\linewidth]{figures/os_IS.png} \\
    (\textbf{a}) &
    (\textbf{b}) \end{tabular}
    \caption{FIDs (\textbf{a}) and Inception Scores (\textbf{b}) obtained with different latent optimisation steps \emph{at evaluation}.}
    \label{fig:lo-scores}
\end{figure}

We did not observe similar improvement with BigGANs in evaluation. To contrast the difference between them, Figure~\ref{fig:dcgan-lo-diff} and \ref{fig:biggan-lo-diff} illustrate the change of samples made by latent optimisation. In both cases, 10 latent optimisation steps were applied in evaluation, after the models were trained with 1 optimisation step. While the effect of improvement is clear in Figure~\ref{fig:dcgan-lo-diff} (from SN-GAN), the changes in Figure~\ref{fig:biggan-lo-diff} are barely observable from inspecting the samples alone before and after latent optimisation.

\begin{figure}[ht]
    \centering
    \begin{tabular}{ccc}
    \includegraphics[width=0.3\linewidth]{figures/samples/lo_before.png} &
    \includegraphics[width=0.3\linewidth]{figures/samples/lo_diff.png} &
    \includegraphics[width=0.3\linewidth]{figures/samples/lo_after.png} \\
    \textbf{before} &
    \textbf{difference} &
    \textbf{after} \end{tabular}
    \caption{CIFAR samples from SN-GAN before, after latent optimisation, and the differences between them.}
    \label{fig:dcgan-lo-diff}
\end{figure}

\begin{figure}[ht]
    \centering
    \begin{tabular}{ccc}
    \includegraphics[width=0.3\linewidth]{figures/samples/biggan_before.png} &
    \includegraphics[width=0.3\linewidth]{figures/samples/biggan_diff.png} &
    \includegraphics[width=0.3\linewidth]{figures/samples/biggan_after.png} \\
    \textbf{before} &
    \textbf{difference} &
    \textbf{after} \end{tabular}
    \caption{ImageNet samples from BigGAN-deep before, after latent optimisation, and the differences between them.}
    \label{fig:biggan-lo-diff}
\end{figure}

\section{Evaluating Classification Accuracy Score}
\label{app:cas}

To compute CAS, a ResNet classifier \citep{he2016deep} is trained on samples from our model instead of the ImageNet dataset. Each data sample is replaced by a sample from the model conditioned on the same class. The trained model is then evaluated on the ImageNet dataset as in a standard classification task. We use the same schedule as in \cite{ravuri2019classification} for training the ResNet classifier, but stopped earlier at about 10k steps, where the classification accuracy peaked. See \cite{ravuri2019classification} for the motivation of CAS and more details of the training and evaluation procedure. We report both top-5 and top-1 classification accuracy in Table~\ref{tab:cas}. Although higher resolution generally brings better CAS, we use the  model as in the main paper due to limited computational resource. Despite this, the CAS from LOGAN nearly halved the gaps between BigGAN-deep and VQ-VAE2 at a higher resolution of .

\begin{table}[htb]
\caption{CAS for different models. Except LOGAN, numbers from all other models are reproduced from \cite{razavi2019generating}.}
\label{tab:cas}
\begin{center}
\begin{tabular}{l|c|c}
         & Top-5 Accuracy & Top-1 Accuracy \\
\hline
BigGAN-deep ()  &  &  \\
BigGAN-deep () &  & \\
LOGAN ()  &  &  \\
VQ-VAE2 ()  &  &  \\
Real Data ()  &  &  \\
\end{tabular}
\end{center}
\end{table}

\section{Poisson Likelihood from Hinge loss}
\label{app:poisson-ll}

Here we provide a probabilistic interpretation of the hinge loss for the generator, which leads naturally to the scenario of a family of discriminators. Although this interpretation is not necessary for our current algorithm, it may provides useful guidance for incorporating multiple discriminators.

We introduce the label  for real data and  fake samples.
This section shows that the generator hinge loss

can be interpreted as a negative log-likelihood function:

Here  is the probability that the  generated image  can fool the discriminator .

The original GAN's discriminator can be interpreted as outputting a Bernoulli distribution . In this case, if we parameterise , the generator loss is the negative log-likelihood


Bernoulli, however, is not the only valid choice as the discriminator's output distribution. Instead of sampling ``1" or ``0", we assume that there are \emph{many} identical discriminators that can independently vote to reject an input sample as fake. The number of votes  in a given interval can be described by a Poisson distribution with parameter  with the following PMF:


The probability that a generated image can fool \emph{all} the discriminators is the probability of  receiving no vote for rejection

Therefore, we have the following negative log-likelihood as the generator loss if we parameterise :

This interpretation has a caveat that when  the Poisson distribution is not well defined. However, in general the discriminator's hinge loss

pushes  via training.

\section{Hyper-parameter Search}
\label{app:hyper}

We first searched the hyper-parameters for the DCGAN (section~5.1) over the following range:
\begin{table}[htb]
\caption{Hyper-parameter grid for the DCGAN. Best values from the grid search are highlighted.}
\begin{center}
\begin{tabular}{l|c}
         & values \\
\hline
  &  \\
  &  \\
  &  \\
  &  \\
\end{tabular}
\end{center}
\end{table}

Base on the results from DCGANs, hyper-parameter search on the following grid was performed for the BigGAN-deep (section~5.2):
\begin{table}[htb]
\caption{Hyper-parameter grid for the BigGAN-deep. Best values from the grid search are highlighted.}
\begin{center}
\begin{tabular}{l|c}
         & values \\
\hline
  &  \\
  &  \\
  &  \\
 &  \\
  &  \\
\end{tabular}
\end{center}
\end{table}

\section{Details in Computing Distances in Figure 5 \textbf{a}}
\label{app:comp-distance}

For a temporal sequence  (e.g. the changes of  or  at each training step in this paper),
to normalise its variance while accounting for the non-stationarity, we process it as follows. We first compute the moving average and standard deviation over a window of size :

Then normalise the sequence as:

The result in Figure 5\textbf{a} is robust to the choice of window size. Our experiments with  from  to  yielded visually similar plots.

\section{Additional Samples and Results}
\label{app:samples_and_truncation}

Figure~1 and 2 provide additional samples, organised similar to Figure~1 and 2. Figure~3 shows additional truncation curves.

\begin{figure}[htb]
    \centering
    \begin{tabular}{cc}
    \includegraphics[width=0.43\linewidth]{figures/samples/IS_bird_B.jpeg}
    &   
    \includegraphics[width=0.43\linewidth]{figures/samples/IS_bird_L.jpeg} \\
    \includegraphics[width=0.43\linewidth]{figures/samples/IS_dog_B.jpeg}
    &   
    \includegraphics[width=0.43\linewidth]{figures/samples/IS_dog_L.jpeg} \\
    \includegraphics[width=0.43\linewidth]{figures/samples/IS_nature_B.jpeg}
    &   
    \includegraphics[width=0.43\linewidth]{figures/samples/IS_nature_L.jpeg} \\
    \includegraphics[width=0.43\linewidth]{figures/samples/IS_stone_B.jpeg}
    &   
    \includegraphics[width=0.43\linewidth]{figures/samples/IS_stone_L.jpeg} \\
    (\textbf{a}) & (\textbf{b}) \\
    \end{tabular}
    \caption{Samples from BigGAN-deep (\textbf{a}) and LOGAN (\textbf{b}) with similarly high Inception scores. Samples from the two panels were drawn from truncations correspond to points C, D in Figure~3. (FID/IS: (\textbf{a}) 27.97/259.4, (\textbf{b}) 8.19/259.9)}
    \label{fig:app-samples-high-IS}
\end{figure}

\begin{figure}[htb]
    \centering
    \begin{tabular}{cc}
    \includegraphics[width=0.47\linewidth]{figures/samples/FID_lion_B.jpeg}
    &   \includegraphics[width=0.47\linewidth]{figures/samples/FID_lion_L.jpeg} \\
\includegraphics[width=0.47\linewidth]{figures/samples/FID_car_B.jpeg}
    &   \includegraphics[width=0.47\linewidth]{figures/samples/FID_car_L.jpeg} \\
    \includegraphics[width=0.47\linewidth]{figures/samples/FID_bridge_B.jpeg}
    &   \includegraphics[width=0.47\linewidth]{figures/samples/FID_bridge_L.jpeg} \\
    (\textbf{a}) & (\textbf{b}) \end{tabular}
    \caption{Samples from BigGAN-deep (\textbf{a}) and LOGAN (\textbf{b}) with similarly low FID. Samples from the two panels were draw from truncations correspond to points A, B in figure~3\textbf{b}. (FID/IS: (\textbf{a}) 5.04/126.8, (\textbf{b}) 5.09/217.0)}
    \label{fig:app-samples-low-FIDs}
\end{figure}


\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{figures/all_truncate.png}
    \caption{Truncation curves with additional baselines. In addition to the truncation curves reported in Figure~3\textbf{b}, here we also include the Spectral-Normalised GAN \citep{miyato2018spectral}, Self-Attention GAN \citep{zhang2019self}, original BigGAN and BigGAN-deep as presented in \cite{brock2018large}.}
    \label{fig:all_truncate}
\end{figure}



\end{document}
