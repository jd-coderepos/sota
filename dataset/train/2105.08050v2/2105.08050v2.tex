\documentclass{article}



\usepackage[final, nonatbib]{neurips_2021}








\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{xcolor}         \usepackage{xspace}

\usepackage[colorlinks=true,citecolor=blue]{hyperref}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{multirow}
\usepackage{todonotes}
\usepackage{placeins}

\lstset{
  backgroundcolor=\color{white},
  basicstyle=\fontsize{7.5pt}{8.5pt}\fontfamily{lmtt}\selectfont,
  columns=fullflexible,
  breaklines=true,
  captionpos=b,
  commentstyle=\fontsize{8pt}{9pt}\color{gray},
  keywordstyle=\fontsize{8pt}{9pt}\color{blue},
  stringstyle=\fontsize{8pt}{9pt}\color{purple},
  frame=tb,
  otherkeywords = {self},
}

\newcommand{\gffn}{gMLP\xspace}

\newcommand{\edit}[1]{\textcolor{red}{#1}}


\usepackage{threeparttable}

\title{Pay Attention to MLPs}

\author{
Hanxiao Liu, Zihang Dai, David R. So, Quoc V. Le \\
Google Research, Brain Team \\
\texttt{\{hanxiaol,zihangd,davidso,qvl\}@google.com}
}

\begin{document}

\maketitle

\begin{abstract}
Transformers~\cite{vaswani2017attention} have become one of the most important architectural innovations in deep learning and have enabled many breakthroughs over the past few years.  
Here we propose a simple network architecture, \gffn, based on MLPs with gating, and show that it can perform as well as Transformers in key language and vision applications. 
Our comparisons show that self-attention is not critical for Vision Transformers, as \gffn can achieve the same accuracy. For BERT, our model achieves parity with Transformers on pretraining perplexity
and is better on some downstream NLP tasks.
On finetuning tasks where \gffn performs worse, making the \gffn model substantially larger can close the gap with Transformers.
In general, our experiments show that \gffn can scale as well as Transformers over increased data and compute.

\end{abstract}

\section{Introduction}
\label{sec:intro}

Transformers~\cite{vaswani2017attention} have enabled many  breakthroughs in natural language processing (e.g.,~\cite{devlin2018bert, yang2019xlnet,liu2019roberta,raffel2019exploring,brown2020language}) and have been shown to work well for computer vision (e.g., \cite{dosovitskiy2020image, touvron2020training,carion2020end, liu2021swin}). Thanks to this success, Transformers have largely replaced LSTM-RNN~\cite{lstm} as the default architecture in NLP, and have become an appealing alternative to ConvNets~\cite{lecun,krizhevsky2012imagenet,simonyan2014very,szegedy2015going,he2016deep,tan2019efficientnet} in computer vision.

The Transformer architecture combines two important concepts: (1) a recurrent-free architecture which computes the representations for each individual token in parallel, and (2) multi-head self-attention blocks which aggregate spatial information across tokens.
On one hand,
the attention mechanism~\cite{bahdanau2014neural} introduces the inductive bias that the spatial interactions should be 
dynamically parameterized based on the input representations.
On the other hand, it is known that MLPs with static parameterization can represent arbitrary functions~\cite{hornik1989multilayer}.
It therefore remains an open question whether the inductive bias in self-attention is essential to the remarkable effectiveness of Transformers.

Here we study the necessity of self-attention modules in key language and vision applications of Transformers.
Specifically,
we propose an MLP-based alternative to Transformers without self-attention, which simply consists of channel projections and spatial projections with static parameterization.
We experiment with several design choices for this architecture and find spatial projections
work well when they are linear and paired with multiplicative gating (Figure~\ref{fig:architecture}).
We name the model \textbf{\gffn} because it is built out of basic MLP layers with gating.


We apply \gffn to image classification and obtain strong results on ImageNet. \gffn achieves comparable performance with DeiT~\cite{touvron2020training}, namely Vision Transformer (ViT)~\cite{dosovitskiy2020image} with improved regularization,
in a similar training setup. 
With 66\% less parameters, a \gffn model is 3\% more accurate than MLP-Mixer~\cite{tolstikhin2021mlpmixer}. Together with Tolstikhin et al.~\cite{tolstikhin2021mlpmixer}, Melas-Kyriazi~\cite{melaskyriazi2021doyou}, Touvron et al.~\cite{touvron2021resmlp} and Ding et. al.~\cite{ding2021repmlp}, our results question the necessity of self-attention layers in Vision Transformers.

We apply \gffn to masked language modeling (MLM) in the BERT~\cite{devlin2018bert} setup, one of the most well-established applications of Transformers,
and find that it is as good as Transformers at minimizing perplexity during pretraining.
Our experiments indicate that perplexity is only correlated with model capacity and is insensitive to the presence of self-attention.
As capacity increases, we observe that both pretraining and finetuning metrics for \gffn{s} improve as quickly as for Transformers.
This is remarkable because it indicates \gffn{s} scale just as well as Transformers despite the absence of self-attention, and any performance gap can always be offset by training a larger model with increased data and compute.
With a standard 256-batch size  1M-step training setup as in original BERT, a large gMLP model achieves 87.7\% accuracy on MNLI and 82.1\% F1 on SQuAD v2.0.
Note, these are better than the BERT\textsubscript{large} results reported in Devlin et al.~\cite{devlin2018bert} obtained using Transformers.

For BERT's finetuning, Transformers can be more practically advantageous over \gffn{s} 
on tasks that require cross-sentence alignment (e.g., by 0.8\% on MNLI-m in the 300M-param regime), even with similar pretraining perplexity. This problem can be addressed by making \gffn{s} substantially larger---3 as large as Transformers. A more practical solution is to blend in only a tiny bit of self-attention---a single-head self-attention with size up to 128 is sufficient to make \gffn{s} outperform Transformers on all NLP tasks we evaluated with even better parameter efficiency.
The improvement is sometimes very significant (e.g., +4.4\% on SQuAD v2.0 over BERT\textsubscript{large}).

Overall,
the surprising effectiveness of \gffn{s} in both vision and NLP domains suggest that self-attention is not a necessary ingredient for scaling up machine learning models,
although it can be a useful addition depending on the task.
With increased data and compute,
models with simpler spatial interaction mechanisms such as gMLP can be as powerful as Transformers and
the capacity allocated to self-attention can be either removed or substantially reduced.

\begin{figure}[t]
    \centering
    \begin{minipage}{0.5\linewidth}
        \includegraphics[width=0.95\linewidth]{figures/gmlp-overview.pdf}
    \end{minipage}
    \begin{minipage}{0.475\linewidth}
    \begin{lstlisting}[
  language=python,
  title={Pseudo-code for the \gffn block}, captionpos=t]
def gmlp_block(x, d_model, d_ffn):
  shortcut = x
  x = norm(x, axis="channel")
  x = proj(x, d_ffn, axis="channel")
  x = gelu(x)
  x = spatial_gating_unit(x)
  x = proj(x, d_model, axis="channel")
  return x + shortcut
  
 def spatial_gating_unit(x):
   u, v = split(x, axis="channel")
   v = norm(v, axis="channel")
   n = get_dim(v, axis="spatial")
   v = proj(v, n, axis="spatial", init_bias=1)
   return u * v
\end{lstlisting}
    \end{minipage}
    \caption{Overview of the \gffn architecture with Spatial Gating Unit (SGU). The model consists of a stack of  blocks with identical structure and size. All projection operations are linear and ``'' refers to element-wise multiplication (linear gating). The input and output protocols follow BERT for NLP and ViT for vision. Unlike Transformers, \gffn{s} do not require positional encodings, nor is it necessary to mask out the paddings during NLP finetuning.}
    \label{fig:architecture}
\end{figure}

\section{Model}

Our model, \gffn, consists of a stack of  blocks with identical size and structure.
Let  be the token representations with sequence length  and dimension .
Each block is defined as:

where  is an activation function such as GeLU~\cite{hendrycks2016gaussian}.
 and  define linear projections along the channel dimension---the same as those in the FFNs of Transformers (e.g., their shapes are 768 3072 and 3072 768 for BERT\textsubscript{base}).
Shortcuts, normalizations and biases are omitted for brevity.

A key ingredient in the aforementioned formulation is ,
a layer which captures spatial interactions (see below).
When  is an identity mapping,
the above transformation degenerates to a regular FFN, where individual tokens are processed independently without any cross-token communication.
One of our major focuses
is therefore to design a good  capable of capturing complex spatial interactions across tokens.
The overall block layout is inspired by inverted bottlenecks~\cite{sandler2018mobilenetv2} which define  as a spatial depthwise convolution.
Note, unlike Transformers, our model \emph{does not require position embeddings} because such information will be captured in .

Our model uses exactly the same input and output protocols as BERT (for NLP) and ViT (for vision).
For example,
when finetuning on language tasks, we concatenate together multiple text segments followed by paddings,
and the predictions are deduced from the last-layer representation of a reserved \texttt{<cls>} symbol.
Although many of these protocols were introduced for Transformers and hence can be suboptimal for \gffn{s}, strictly following them helps avoid confounding factors in our experiments and makes our layers more compatible with existing Transformer implementations.


\subsection{Spatial Gating Unit}
\label{subsec:spatial-interaction}
To enable cross-token interactions,
it is necessary for the layer  to contain a contraction operation over the spatial dimension.
The simplistic option would be a linear projection:

where  is a matrix for which the size is the same as the sequence length, , and  refers token-specific biases.
For example, if the padded input sequence has 128 tokens,
the shape for  will be 128128.
Unlike self-attention where  is dynamically generated from ,
the spatial projection matrix  here in Equation~\eqref{eq:spatial-proj} is independent from the input representations.

In this work,
we formulate layer  as the output of linear gating:

where  denotes element-wise multiplication.
For training stability,
we find it critical to initialize  as near-zero values and  as ones,
meaning that  and therefore 
at the beginning of training. This initialization ensures each \gffn block behaves like a regular FFN at the early stage of training, where each token is processed independently,
and only gradually injects spatial information across tokens during the course of learning.

We further find it effective to split  into two independent parts (, ) along the channel dimension for the gating function and for the multiplicative bypass:

We also normalize the input to  which empirically improves stability of large NLP models.
This gives us the unit illustrated in Figure~\ref{fig:architecture}, which we refer to as the \emph{Spatial Gating Unit} (SGU) in the rest of the paper.
In Table~\ref{tab:baselines}, we provide ablation studies to compare SGU with several other variants of ,
showing that it works better and narrows the performance gap with self-attention.

\paragraph{Connections to Existing Layers.}
The overall formulation of SGU resembles Gated Linear Units (GLUs)~\cite{dauphin2017language, shazeer2020glu, wu2019pay} as well as earlier works including Highway Networks~\cite{srivastava2015highway} and LSTM-RNNs~\cite{lstm}. A key distinction is that our gating is computed based on a projection over the spatial (cross-token) dimension rather than the channel (hidden) dimension.
SGU is also related to Squeeze-and-Excite (SE) blocks~\cite{hu2018squeeze} in terms of element-wise multiplication. However, different from SE blocks, SGU does not contain cross-channel projections at all, nor does it enforce permutation invariance (a key feature for content-based attentive modules) due to its static parameterization for the spatial transformation.
The spatial projection in SGU could in theory learn to express superficial depthwise convolutions---unlike typical depthwise convolutions with channel-specific filters,
SGU learns only a single transformation shared across channels.
Finally,
we note SGUs offer an alternative mechanism to capture high-order relationships other than self-attention. Specifically, the output for Equation~\eqref{eq:spatial-gating} contains up to 2nd-order interactions (e.g., ) whereas output for self-attention (assuming no nonlinearity) contains up to 3rd-order interactions (e.g., ).
In terms of computation cost,
SGU has  multiply-adds which is comparable to the  of dot-product self-attention.\footnote{The input channel size  for SGU is typically larger than the input channel size  for self-attention, because the former is applied in the middle of the block after a channel expansion.} Both are linear over the input channel size and quadratic over the sequence length .

\FloatBarrier
\section{Image Classification}
\label{sec:vision}
Here we examine \gffn in the vision domain by applying it to the image classification task on ImageNet~\cite{deng2009imagenet} without using extra data.
We compare our MLP-like models with recent attentive models based on vanilla Transformers, including Vision Transformer (ViT)~\cite{dosovitskiy2020image}, DeiT~\cite{touvron2020training} (ViT with improved regularization),
and several other representative convolutional networks.

Table~\ref{tab:vision-configs} summarizes the configurations of our \gffn image classification models. The input and output protocols follow ViT/B16 where the raw image is converted into 1616 patches at the stem. The depth and width are chosen so that the models are comparable with ViT/DeiT in capacity.
Like Transformers,
we find \gffn{s} tend to drastically overfit the training data.
We therefore apply a similar regularization recipe as the one used in DeiT.\footnote{Unlike DeiT, we do not use repeated augmentation or random erasing.}
To avoid extensive tuning, we adjust only the strengths of stochastic depth~\cite{huang2016deep} as we move from smaller to larger models in Table~\ref{tab:vision-configs}.
All the other hyperparameters remain shared across our three models.
See Appendix~\ref{sec:vision-hparams} for details.
\begin{table}[h]
\centering
\small
\caption{Architecture specifications of \gffn models for vision. The survival probability of stochastic depth is the only hyperparameter change as we move from smaller to larger models.}
\begin{tabular}{@{}l|ccc|cc|c@{}}
\toprule
\multicolumn{1}{c}{} & \#L &  &  & Params (M) & FLOPs (B) & Survival Prob \\ \midrule
\gffn-Ti & 30 & 128 & 768 & 5.9 & 2.7 & 1.00 \\
\gffn-S & 30 & 256 & 1536 & 19.5 & 8.9 & 0.95 \\
\gffn-B & 30 & 512 & 3072 & 73.4 & 31.6 & 0.80 \\ \bottomrule
\end{tabular}
\label{tab:vision-configs}
\end{table}
\vspace{-0.3cm}


Our ImageNet results are summarized in Table~\ref{tab:vision-configs} and Figure~\ref{fig:vision-main}.
It is interesting to see that
\gffn{s} are comparable with DeiT~\cite{touvron2020training},
namely ViT~\cite{dosovitskiy2020image} trained using improved regularization.
The results suggest that models without self-attention can be as data-efficient as Transformers for image classification.
In fact,
when the models are properly regularized, their accuracies seem better correlated with capacity instead of the presence of self-attention.
Moreover,
the accuracy-parameter/FLOPs tradeoff of
\gffn{s} surpasses all concurrently proposed MLP-like architectures~\cite{tolstikhin2021mlpmixer, melaskyriazi2021doyou, touvron2021resmlp},
which we attribute to the effectiveness of our Spatial Gating Unit (see Table~\ref{tab:baselines} in the next section for an ablation). We also note while \gffn{s} are competitive with vanilla Transformers, their performance is behind the best existing ConvNet models (e.g., \cite{brock2021high, tan2021efficientnetv2}) or hybrid models (e.g., \cite{bello2021lambdanetworks, vaswani2021scaling, srinivas2021bottleneck, wu2021cvt, liu2021swin}).

\begin{table}[h]
\centering
\caption{ImageNet-1K results without extra data.}
 \resizebox{.805\textwidth}{!}{
\begin{threeparttable}
\begin{tabular}{@{}l|cccc@{}}
\toprule
\multirow{2}{*}{Model} & ImageNet Top-1 (\%) & Input Resolution & Params (M) & MAdds (B) \\ \cmidrule(l){2-5}
& \multicolumn{4}{c}{ConvNets} \\ \midrule
ResNet-152~\cite{he2016deep} & 78.3 & 224 & 60 & 11.3 \\
RegNetY-8GF~\cite{radosavovic2020designing} & 81.7 & 224 & 39 & 8.0 \\
EfficientNet-B0~\cite{tan2019efficientnet} & 77.1 & 224 & 5 & 0.39 \\
EfficientNet-B3~\cite{tan2019efficientnet} & 81.6 & 300 & 12 & 1.8 \\
EfficientNet-B7~\cite{tan2019efficientnet} & 84.3 & 600 & 66 & 37.0 \\ 
NFNet-F0~\cite{brock2021high} & 83.6 & 192 & 72 & 12.4 \\
\midrule
& \multicolumn{4}{c}{Transformers} \\ \midrule
ViT-B/16~\cite{dosovitskiy2020image} & 77.9 & 384 & 86 & 55.4 \\
ViT-L/16~\cite{dosovitskiy2020image} & 76.5 & 384 & 307 & 190.7 \\
DeiT-Ti~\cite{touvron2020training} (ViT+reg) & 72.2 & 224 & 5 & 1.3 \\
DeiT-S~\cite{touvron2020training} (ViT+reg) & 79.8 & 224 & 22 & 4.6 \\
DeiT-B~\cite{touvron2020training} (ViT+reg) & 81.8 & 224 & 86 & 17.5 \\ \midrule
& \multicolumn{4}{c}{MLP-like} \\ \midrule
Mixer-B/16~\cite{tolstikhin2021mlpmixer} & 76.4 & 224 & 59 & 12.7 \\
Mixer-B/16 (our setup) & 77.3 & 224 & 59 & 12.7 \\
Mixer-L/16~\cite{tolstikhin2021mlpmixer} & 71.8 & 224 & 207 & 44.8 \\
ResMLP-12~\cite{touvron2021resmlp} & 76.6 & 224 & 15 & 3.0 \\
ResMLP-24~\cite{touvron2021resmlp} & 79.4 & 224 & 30 & 6.0 \\
ResMLP-36~\cite{touvron2021resmlp} & 79.7 & 224 & 45 & 8.9 \\
\gffn-Ti (ours) & 72.3 & 224 & 6 & 1.4 \\
\gffn-S (ours) & 79.6 & 224 & 20 & 4.5 \\
\gffn-B (ours) & 81.6 & 224 & 73 & 15.8 \\ \bottomrule
\end{tabular}
\begin{tablenotes}
  \small
  \item[*] Standard deviation across multiple independent runs is around 0.1.
  \item[] Tokenization \& embedding process at the stem can be viewed as a convolution.
\end{tablenotes}
\end{threeparttable}
}
\label{tab:vision-main}
\end{table}


\begin{figure}[h]
    \begin{minipage}{0.51\linewidth}
        \centering
        \includegraphics[width=0.94\linewidth]{figures/gffn-imagenet.pdf}
        \caption{ImageNet accuracy vs model capacity.}
        \label{fig:vision-main}
    \end{minipage}
    \hfill
    \begin{minipage}{0.475\linewidth}
        \centering
        \includegraphics[width=1.0\linewidth]{figures/vision-learned-filters.png}
    \caption{
    Spatial projection weights in gMLP-B.
    Each row shows the filters (reshaped into 2D) for a selected set of tokens in the same layer.}
    \label{fig:vision-filters}
    \end{minipage}
\end{figure}


Figure~\ref{fig:vision-filters} visualizes the spatial projection matrices in \gffn-B.
Remarkably,
the spatial weights after learning exhibit both locality and spatial invariance.
In other words,
each spatial projection matrix effectively learns to perform convolution with a data-driven, irregular (non-square) kernel shape.

\section{Masked Language Modeling with BERT}
\label{sec:mlm}
Here we conduct empirical studies over the masked language modeling (MLM) task. The input/output protocol for both pretraining and finetuning follows BERT~\cite{devlin2018bert}. 
Different from Transformer-based models, we do not use positional encodings. We also find it unnecessary to mask out \texttt{<pad>} tokens in \gffn blocks during finetuning as the model can quickly learn to ignore them.
For ablations and case studies,
all models are trained with batch size 2048, max length 128 for 125K steps over the RealNews-like subset of C4~\cite{raffel2019exploring}.
For main results, models are trained with batch size 256, max length 512 for 1M steps over the full English C4 dataset.
See Appendix~\ref{sec:mlm-hparams} for details.

Our preliminary MLM experiments show that gMLPs always learn Toeplitz-like matrices as the spatial weights (Appendix~\ref{sec:shift-invariance}).
This means gMLPs are able to learn the notion of shift invariance from data, a property naturally implied by the MLM task where any offset of the input sequence does not affect the slot filling outcome.
In this case,
the learned  acts like a 1-d convolution whose kernel size equals the entire sequence length (unlike depthwise convolution with channel-specific filters, here the same  is shared across channels).
In the following MLM experiments,
we restrict  to be a Toeplitz matrix to avoid redundant model parameterization (since  will be Toeplitz-like regardless after learning).
Note this constraint is empirically quality-neutral.

\subsection{Ablation: The Importance of Gating in \gffn for BERT's Pretraining}
\label{sec:baselines}

In Table~\ref{tab:baselines} below, we establish baselines for our ablation studies.
These include:
\begin{enumerate}
\item BERT with a Transformer architecture and learnable absolute position embeddings.
\item BERT with a Transformer architecture and T5-style learnable relative position biases~\cite{raffel2019exploring}.
The biases are both layer- and head-specific as we find this yields the best results.
\item Same as above, but we remove all content-dependent terms inside the softmax and only retain the relative positional biases. This baseline is a straightforward variant of Transformers without self-attention,
which can also be viewed as a Random Synthesizer~\cite{tay2020synthesizer}.
\item MLP-Mixer~\cite{tolstikhin2021mlpmixer} which replaces the multi-head self-attention module in Transformers with a two-layer spatial MLP.
This model was developed for image classification and here we investigate it on MLM tasks using the same training setup with BERT and gMLP.
\end{enumerate}

\begin{table}[h]
\centering\small
\caption{MLM validation perplexities of Transformer baselines and four versions of \gffn{s}.  refers to the spatial linear projection in Equation~\eqref{eq:spatial-proj} with input normalization.
The MLP-Mixer baseline model has L=24 layers with =768, =384 and =3072.
Each \gffn model has L=36 layers with =512 and  = 3072. No positional encodings are used for Mixer or \gffn{s}.}
\begin{threeparttable}
\begin{tabular}{@{}l|c|c@{}}
\toprule
Model & Perplexity & Params (M) \\ \midrule
BERT\textsubscript{base} &  4.37 &  110 \\
BERT\textsubscript{base} + rel pos & 4.26 & 110 \\ 
BERT\textsubscript{base} + rel pos - attn & 5.64 & 96 \\ \midrule
MLP-Mixer & 5.34 & 112 \\
\midrule
Linear \gffn,  & 5.14 & 92 \\
Additive \gffn,  & 4.97 & 92 \\
Multiplicative \gffn,   & 4.53 & 92 \\ 
Multiplicative, Split \gffn, ,   & 4.35 & 102 \\

\bottomrule
\end{tabular}
\begin{tablenotes}
  \small
  \item[*] Standard deviation across multiple independent runs is around 0.01.
\end{tablenotes}
\end{threeparttable}
\vspace{-0.525cm}
\label{tab:baselines}
\end{table}

We compare these baselines against several versions of \gffn{s} with similar sizes in Table~\ref{tab:baselines}. Note that Multiplicative, Split (last row) is the Spatial Gating Unit we describe in the method section and use in the rest of the paper. First, SGU outperforms other variants in perplexity. Secondly and remarkably, \gffn with SGU also achieves perplexity comparable to Transformer.
Note the difference between the strongest baseline (perplexity=4.26) and ours (perplexity=4.35) is insignificant relative to the perplexity change when the models are scaled (see Table~\ref{tab:depth-scaling} in the next section).
Spatial projection weights
learned by \gffn{s} are visualized in Figure~\ref{fig:mlm-filters}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\linewidth]{figures/mlm-filters.png}
    \caption{Visualization of the spatial filters in \gffn learned on the MLM task. For each layer in the model we plot the row in  associated with the token in the middle of the sequence. The x-axis of each subplot has a length of 128 which equal the number of tokens in the sequence.
    The learned filters appear to be smooth and have several types: forward-looking (e.g., 1st in 2nd row), backward-looking (e.g., 5th in 2nd row) and bi-directional (e.g., 2nd last in the last row).}
    \label{fig:mlm-filters}
    \vspace{-0.2cm}
\end{figure}

\subsection{Case Study: The Behavior of \gffn as Model Size Increases}
\label{sec:scaling}

In Table~\ref{tab:depth-scaling},
we investigate the scaling properties of Transformers and \gffn{s} in BERT as their model capacity grows.
Specifically,
we scale the depth of these models by a factor of  and report the their pretraining MLM perplexities on the validation set as well as finetuning results on the dev sets of two tasks in GLUE~\cite{wang2018glue}.
Note each individual Transformer layer is effectively two consecutive blocks: one for self-attention and one for FFN. In the table below we use the notation of 12 + 12 to refer to 12 of self-attention blocks plus 12 of FFN blocks in the Transformer baselines.

\begin{table}[h]
\centering
\small
\caption{Pretraining and dev-set finetuning results over increased model capacity.
We use the relative positional encoding scheme for Transformers which performs the best in Table~\ref{tab:baselines}.}
\begin{tabular}{@{}l|c|c|c|cc@{}}
\toprule
Model & \#L & Params (M) & Perplexity & SST-2 & MNLI-m \\ \midrule
Transformer & 6+6 & 67 & \textbf{4.91} & 90.4 & 81.5 \\
\gffn  & 18  & 59 & 5.25 & 91.2 & 77.7 \\
\midrule
Transformer  & 12+12  & 110 & \textbf{4.26} & 91.3 & 83.3 \\
\gffn & 36 & 102 & 4.35 & 92.3 & 80.9 \\
\midrule
Transformer  & 24+24 & 195 & 3.83 & 92.1 & 85.2 \\ 
\gffn & 72 & 187 & \textbf{3.79} & 93.5 & 82.8 \\
\midrule
Transformer & 48+48 & 365  & 3.47 & 92.8 & 86.3 \\
\gffn  & 144 & 357 & \textbf{3.43} & 95.1 & 84.6 \\
 \bottomrule
\end{tabular}
\label{tab:depth-scaling}
\vspace{-0.2cm}
\end{table}

The results above show that a deep enough \gffn
is able to match and even outperform the perplexity of Transformers with comparable capacity.\footnote{We also experimented with deeper-and-thinner Transformers (with capacity fixed) but found increasing depth further does not improve perplexity. See Appendix~\ref{sec:deeper-thinner-tfm} for more details.}
In addition,
the perplexity-parameter relationships for both architecture families approximately follow a power law (left of Figure~\ref{fig:scaling}).
This implies the empirical scaling laws originally observed for Transformer-based language models~\cite{kaplan2020scaling} might be broadly applicable across different model families.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.9\linewidth]{figures/scaling.pdf}
    \caption{Scaling properties with respect to perplexity and finetuning accuracies. The figures show that for pretraining, \gffn{s} are equally good at optimizing perplexity as Transformers. For finetuning, the two model families exhibit comparable scalability despite task-specific offsets.}
    \label{fig:scaling}
\end{figure}

Table~\ref{tab:depth-scaling} also leads to an interesting observation that the pretraining perplexities across different model families are not equal in terms of finetuning.
While
\gffn{s} outperform Transformers on SST-2,
they are worse on MNLI. The results imply that the finetuning performance for NLP tasks is a function of not only the perplexity but also the inductive bias in the architecture.
Figure~\ref{fig:scaling} shows that despite the architecture-specific discrepancies between pretraining and finetuning,
\gffn{s} and Transformers exhibit comparable scalability (slope) on both finetuning tasks. This means one can always offset the gap by enlarging the model capacity.
In other words,
the results indicate that model scalability with respect to downstream metrics can be independent from the presence of self-attention.

\subsection{Ablation: The Usefulness of Tiny Attention in BERT's Finetuning}
So far we have
found that self-attention is not a required component to achieve strong MLM perplexity or scalability.
At the meantime,
we also identified NLP finetuning tasks where \gffn{s} transfer less well than Transformers (Table~\ref{tab:depth-scaling}). The fact that our MLP-like model is advantageous on SST-2 but worse on MNLI is particularly informative---the former is a single-sentence task whereas the latter involves sentence pairs (premise and hypothesis)~\cite{williams2017broad}.
We suspect the role of self-attention during finetuning is related to cross-sentence alignment.

To isolate the effect of self-attention,
we experiment with a hybrid model where a tiny self-attention block is attached to the gating function of \gffn (Figure~\ref{fig:tiny-attn}).
Since \gffn itself is already capable in capturing spatial relationships,
we hypothesize that this extra self-attention module does not have to be heavy, and that its presence is more relevant than its capacity.
A typical tiny attention module in our experiments has only a single head with size 64,
significantly smaller than a typical multi-head self-attention in Transformers with 12 heads and a total size of 768.
In the following,
we refer to the hybrid model, namely gMLP with a tiny self-attention, as \emph{aMLP} (``a'' for attention).

\begin{figure}[h]
    \centering
    \begin{minipage}{0.4\linewidth}
        \includegraphics[width=0.7\linewidth]{figures/tiny-attention.pdf}
    \end{minipage}
    \begin{minipage}{0.5\linewidth}
        \begin{lstlisting}[
  language=python,
  title={Pseudo-code for the tiny attention module}, captionpos=t]
def tiny_attn(x, d_out, d_attn=64):
  qkv = proj(x, 3 * d_attn, axis="channel")
  q, k, v = split(qkv, 3, axis="channel")
  w = einsum("bnd,bmd->bnm", q, k)
  a = softmax(w * rsqrt(d_attn))
  x = einsum("bnm,bmd->bnd", a, v)
  return proj(x, d_out, axis="channel")

\end{lstlisting}
    \end{minipage}
    \caption{Hybrid spatial gating unit with a tiny self-attention module. We use the normalized input of the \gffn block (endpoint after the input normalization and right before the channel expansion) as the input to the tiny self-attention. For SGU we have  due to the channel split.}
    \label{fig:tiny-attn}
\end{figure}

In Figure~\ref{fig:transferability}, we investigate the transferability of MLM models via the calibration plots between their pretraining perplexities and finetuning metrics.
Models evaluated include BERT\textsubscript{base},
\gffn and its hybrid version aMLP with a 64-d single-head self-attention (Figure~\ref{fig:tiny-attn}).
The data points were collected by varying the model depth by \{0.5, 1, 2\} or data by \{1, 2, 4, 8\}.
It can be seen that \gffn{s} transfer better to SST-2 than Transformers regardless of the presence of self-attention,
While \gffn performs worse on MNLI, attaching a tiny bit of self-attention is sufficient to close the gap.
In Appendix~\ref{sec:visualize-tiny-attn} we visualize the tiny self-attention modules in aMLP over MNLI examples,
showing that they are primarily responsible for the alignment between sentence pairs.

\begin{figure}[h]
    \centering
    \begin{minipage}{0.4\linewidth}
        \includegraphics[width=0.9\linewidth]{figures/pplx-vs-sst.pdf}
    \end{minipage}
    \begin{minipage}{0.4\linewidth}
        \includegraphics[width=0.9\linewidth]{figures/pplx-vs-mnli.pdf}
    \end{minipage}
    \caption{Transferability from MLM pretraining perpexity to finetuning accuracies on GLUE. aMLP refers to gMLP enhanced with a 64-d single-head self-attention, as illustrated in Figure~\ref{fig:tiny-attn}. In contrast, each self-attention module in the BERT baseline contains 12 heads with a total size of 768.}
    \label{fig:transferability}
\end{figure}

In Figure~\ref{fig:scaling-with-tinyattn}
we put together the scaling properties of the three models,
showing that aMLP (gMLP + tiny attention) consistently outperforms Transformer on both finetuning tasks.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.9\linewidth]{figures/scaling-with-tinyattn.pdf}
    \caption{Comparing the scaling properties of Transformers, \gffn{s} and aMLPs (with 64-d, single-head attention). Results were obtained using the same setup in Section~\ref{sec:scaling}.}
    \label{fig:scaling-with-tinyattn}
\end{figure}

\FloatBarrier
\subsection{Main Results for MLM in the BERT Setup}
Below we present pretraining and finetuning results in the full BERT setup. Different from ablation and case studies, here we use the full English C4 dataset and adopt a common MLM setup with batch size 256, max length 512 and 1M training steps.
For fair comparison, we adjust the depth and width of \gffn{s} to ensure comparable model capacity with the Transformer baselines.
The model specifications are given in Table~\ref{tab:perplexity-full-bert} and hyperparameters are detailed in Appendix~\ref{sec:mlm-hparams}.
For finetuning, we report the dev-set performance for SST-2 and MNLI in GLUE~\cite{wang2018glue} and each result entry was obtained by taking the median of five independent runs.
In addition,
we report finetuning results on SQuAD~\cite{rajpurkar2016squad, rajpurkar2018know} to test the models' ability in reasoning over a longer context.

\begin{table}[h]
\caption{Model specifications in the full BERT setup.}
\label{tab:perplexity-full-bert}
\small
\centering
\begin{tabular}{@{}l|cc|cccc@{}}
\toprule
 & Params (M) & FLOPs (B) & \#L &  &  \\
\midrule
BERT\textsubscript{base} & 110 & 100.8  & 12+12 & 768 & 3072 \\
gMLP\textsubscript{base} & 130 & 158.0 & 48 & 512 & 3072  \\
aMLP\textsubscript{base} & 109 & 128.9 & 36 & 512 & 3072  \\
\midrule
BERT\textsubscript{large} & 336 & 341.2 &  24+24 & 1024 & 4096  \\
gMLP\textsubscript{large} & 365 & 430.1 & 96 & 768 & 3072  \\
aMLP\textsubscript{large} & 316 & 370.3 & 72 & 768 & 3072 \\
\midrule
gMLP\textsubscript{xlarge} & 941 & 1091.3 & 144 & 1024 & 4096 \\
\bottomrule
\end{tabular}
\end{table}


\begin{table}[h]
\centering
\caption{Pretraining perplexities and dev-set results for finetuning. ``ours'' indicates models trained using our setup. We report accuracies for SST-2 and MNLI, and F1 scores for SQuAD v1.1/2.0.}
\begin{tabular}{@{}l|c|cccc|cc@{}}
\toprule
 & \multirow{2}{*}{Perplexity} & \multirow{2}{*}{SST-2} & \multirow{2}{*}{MNLI} & \multicolumn{2}{c|}{SQuAD} & \multirow{2}{*}{Attn Size} & Params \\ \cmidrule(l){5-6}
 & & & (m/mm) & v1.1 & v2.0 & & (M)\\
\midrule
\midrule
BERT\textsubscript{base}~\cite{devlin2018bert} & -- & 92.7 & 84.4/- & 88.5 & 76.3 & 768 (64  12) & 110 \\
\midrule
BERT\textsubscript{base} (ours) & 4.17 & 93.8 & 85.6/85.7 & 90.2 & 78.6 & 768 (64  12) & 110  \\
gMLP\textsubscript{base} & 4.28 & 94.2 & 83.7/84.1 & 86.7 & 70.1 & -- & 130 \\
aMLP\textsubscript{base} & 3.95 & 93.4 & 85.9/85.8 & 90.7 & 80.9 & 64 & 109 \\
\midrule
\midrule
BERT\textsubscript{large}~\cite{devlin2018bert} & -- & 93.7 & 86.6/- & 90.9 & 81.8 & 1024 (64  16) & 336 \\
\midrule
BERT\textsubscript{large} (ours) & 3.35 & 94.3 & 87.0/87.4 & 92.0 & 81.0 & 1024 (64  16) & 336 \\
gMLP\textsubscript{large} & 3.32 & 94.8 & 86.2/86.5 & 89.5 & 78.3 & -- & 365 \\
aMLP\textsubscript{large} & 3.19 & 94.8 & 88.4/88.4 & 92.2 & 85.4 & 128 & 316 \\
\midrule\midrule
gMLP\textsubscript{xlarge} & 2.89 & 95.6 & 87.7/87.7 & 90.9 & 82.1 & -- & 941 \\
\bottomrule
\end{tabular}
\label{tab:finetune-full-bert}
\end{table}

Results are presented in Table~\ref{tab:finetune-full-bert}. Consistent with our findings earlier in Section~\ref{sec:baselines} and Section~\ref{sec:scaling}, \gffn{s} are competitive with Transformers in terms of perplexity, especially in the larger scale setup. There are several observations related to the finetuning results:

First,
on finetuning tasks where \gffn{s} underperform Transformers,
the performance gap tends to narrow as the model capacity increases.
For example,
while \gffn performs worse by 8.5\% on SQuAD-v2.0 in the base scale,
the performance gap relative to the baseline decreases to 2.7\% at the larger scale.
Notably,
our gMLP\textsubscript{large} achieves 89.5\% F1 on SQuAD-v1.1 without any self-attention or dynamic spatial parameterization~\cite{wu2019pay},
which is well above the 88.5\% reported for BERT\textsubscript{base} in Devlin et al.~\cite{devlin2018bert} and is only 1.4\% away from the original result for BERT\textsubscript{large}.
We also include one additional data point by scaling up gMLP even further.
The resulting model, gMLP\textsubscript{xlarge}, outperforms BERT\textsubscript{large} on SQuAD-v2.0---a difficult task involving question-answer pairs---without any self-attention.
While this is not a fair comparison due to different model sizes,
it is an existence proof that MLP-like models can be competitive with Transformers on challenging NLP tasks.

Furthermore,
we show that blending in a tiny single-head self-attention of size either 64 or 128 is sufficient to make \gffn{s} outperform Transformers of similar capacity,
sometimes by a significant margin.
For example,
our hybrid model aMLP\textsubscript{large} achieves 4.4\% higher F1 than Transformers on SQuAD-v2.0.
The results suggest that the capacity in the multi-head self-attention of Transformers can be largely redundant,
and that the majority of its functionalities can be captured by the spatial gating unit in \gffn{s}.
The results also imply that the inductive biases in the spatial gating unit of \gffn{s} and the tiny attention are complementary to each other.
While the benefits of architectural inductive bias may vanish over increased compute,
tiny attention does improve the practical value of \gffn{s} in the regime that we investigate in this work.


\section{Conclusion}
Since the seminal work of Vaswani et al.~\cite{vaswani2017attention}, Transformers have been widely adopted across NLP and computer vision. This adoption has enabled many impressive results especially in NLP. To date, it is still unclear what empowers such success: is it the feedforward nature of Transformers or is it the multi-head self-attention layers in Transformers?

Our work suggests a simpler alternative to the multi-head self-attention layers in Transformers. We show that \gffn{s}, a simple variant of MLPs with gating, can be competitive with Transformers in terms of BERT's pretraining perplexity and ViT's accuracy.
\gffn{s} are also comparable with Transformers in terms of the scalability over increased data and compute.
As for BERT finetuning,
we find \gffn{s} can achieve appealing results on challenging tasks such as SQuAD without self-attention, and can significantly outperform Transformers in certain cases.
We also find the inductive bias in Transformer's multi-head self-attention useful on downstream tasks that require cross-sentence alignment.
However in those cases, making \gffn substantially larger closes the gap with Transformers. More practically, blending a small single-head self-attention into \gffn allows for an even better architecture without the need for increasing model size.


\section*{Acknowledgements}
We thank Gabriel Bender, Neil Houlsby, Thang Luong, Niki Parmar, Hieu Pham, Noam Shazeer, Ilya Sutskever, Jakob Uszkoreit and Ashish Vaswani for their feedback to the paper.

\bibliographystyle{unsrt}
\bibliography{main}


\appendix

\FloatBarrier
\section{Hyperparameters}

\FloatBarrier
\subsection{Image Classification}
\label{sec:vision-hparams}
All ImageNet models are trained using TPUv2 with 128 cores. Each run takes 1-4 hours to complete.

\begin{table}[h]
\centering
\begin{tabular}{@{}l|cccc@{}}
\toprule
 & \gffn-Ti & \gffn-S & \gffn-B & Mixer-B \\ \midrule
Stochastic depth survival prob & 1.00 & 0.95 & 0.80 & 0.95 \\
\midrule
Data augmentation & \multicolumn{4}{c}{AutoAugment} \\
Repeated Augmentation & \multicolumn{4}{c}{off} \\
Input resolution & \multicolumn{4}{c}{224} \\
Epochs & \multicolumn{4}{c}{300} \\
Batch size & \multicolumn{4}{c}{4096} \\
Warmup steps & \multicolumn{4}{c}{10K} \\
Hidden dropout & \multicolumn{4}{c}{0} \\
GeLU dropout & \multicolumn{4}{c}{0} \\
Attention dropout (if applicable) & \multicolumn{4}{c}{0} \\
Classification dropout & \multicolumn{4}{c}{0} \\
Random erasing prob & \multicolumn{4}{c}{0} \\
EMA decay & \multicolumn{4}{c}{0} \\
Cutmix  & \multicolumn{4}{c}{1.0} \\
Mixup  & \multicolumn{4}{c}{0.8} \\
Cutmix-Mixup switch prob & \multicolumn{4}{c}{0.5} \\
Label smoothing & \multicolumn{4}{c}{0.1} \\
Peak learning rate & \multicolumn{4}{c}{1e-3} \\
Learning rate decay & \multicolumn{4}{c}{cosine} \\
Optimizer & \multicolumn{4}{c}{AdamW} \\
Adam  & \multicolumn{4}{c}{1e-6} \\
Adam  & \multicolumn{4}{c}{(0.9, 0.999)} \\
Weight decay & \multicolumn{4}{c}{0.05} \\
Gradient clipping & \multicolumn{4}{c}{1.0} \\
\bottomrule
\end{tabular}
\caption{Hyperparameters for Image classification on ImageNet-1K}
\end{table}

\FloatBarrier
\subsection{Masked Language Modeling}
\label{sec:mlm-hparams}
MLM models for ablation studies are trained using TPUv3 with 32 cores. Each run takes 1-2 days to complete. Models in the full BERT setup are trained using TPUv2 with 128 cores. Each run takes 1-5 days to complete depending on the model size. The vocabulary consists of 32K cased SentencePieces.

\begin{table}[t]
\centering
\begin{tabular}{@{}l|c|c@{}}
\toprule
 & Ablation Studies & Full Results (Table~\ref{tab:perplexity-full-bert}) \\ \midrule
Data & C4/RealNews & C4/English \\
Max sequence length & 128 & 512 \\
Batch size & 2048 & 256 \\
Peak learning rate & 7e-4 & 1e-4 \\
Number of steps & 125K & 1M \\
\midrule
Warmup steps & \multicolumn{2}{c}{10K} \\
Hidden dropout & \multicolumn{2}{c}{0} \\
GeLU dropout & \multicolumn{2}{c}{0} \\
Attention dropout (if applicable) & \multicolumn{2}{c}{0} \\
Learning rate decay & \multicolumn{2}{c}{Linear} \\
Optimizer & \multicolumn{2}{c}{AdamW} \\
Adam  & \multicolumn{2}{c}{1e-6} \\
Adam  & \multicolumn{2}{c}{(0.9, 0.999)} \\
Weight decay & \multicolumn{2}{c}{0.01} \\ 
Gradient clipping & \multicolumn{2}{c}{0} \\
\bottomrule
\end{tabular}
\caption{Hyperparameters for MLM pretraining on C4.}
\end{table}

\begin{table}[t]
\centering
\begin{tabular}{@{}l|cc|c@{}}
\toprule
 & SST-2 & MNLI & SQuAD v1.1/v2.0 \\ \midrule
Max sequence length & \multicolumn{2}{c|}{128} & 512 \\
Batch size & \multicolumn{2}{c|}{\{16, 32\}} & 32 \\
Peak learning rate & \multicolumn{2}{c|}{\{1e-5, 2e-5, 3e-5\}} & 5e-5 \\
Number of steps/epochs & \multicolumn{2}{c|}{5 epochs} & 8K \\
Warmup steps/portion & \multicolumn{2}{c|}{10\%} & 1K \\
\midrule
Hidden dropout & \multicolumn{3}{c}{0.1} \\
GeLU dropout & \multicolumn{3}{c}{0} \\
Attention dropout (if applicable) & \multicolumn{3}{c}{0.1} \\
Learning rate decay & \multicolumn{3}{c}{Linear} \\
Optimizer & \multicolumn{3}{c}{AdamW} \\
Adam  & \multicolumn{3}{c}{1e-6} \\
Adam  & \multicolumn{3}{c}{(0.9, 0.999)} \\
Weight decay & \multicolumn{3}{c}{0.01} \\
Gradient clipping & \multicolumn{3}{c}{0} \\
\bottomrule
\end{tabular}
\caption{Hyperparameters for MLM finetuning on GLUE and SQuAD.}
\end{table}


\FloatBarrier
\section{Deep-and-Thin Transformers}
\label{sec:deeper-thinner-tfm}
\begin{table}[h]
\centering
\begin{tabular}{@{}ccccc@{}}
\toprule
Perplexity & \#L &  & \#heads & Params (M) \\ \midrule
4.83 & 12 + 12 & 768 & 12 & 110 \\
5.08 & 24 + 24 & 512 & 8 & 92 \\
4.99 & 48 + 48 & 384 & 12 & 98 \\
5.30 & 96 + 96 & 256 & 8 & 84 \\ \bottomrule
\end{tabular}
\caption{MLM results with increasingly deeper \& thinner Transformers. As the depth increases,
we adjust the model width accordingly to maintain comparable capacity. We observe that the perplexity is insensitive to the model depth at a fixed capacity, and worsens beyond 48 layers. Note these results were obtained using a similar yet different training setup from the rest of the paper.}
\end{table}

\FloatBarrier
\section{Shift Invariance in MLM}
\label{sec:shift-invariance}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.9\linewidth]{figures/tplz.png}
    \caption{Spatial projection matrices learned on the MLM pretraining task without the shift invariance prior (that each individual  being a Toeplitz matrix). The plots show that \gffn learns Toeplitz-like matrices (hence the notion of shift invariance) regardless.}
    \label{fig:mlm-no-tplz}
\end{figure}

\FloatBarrier

\begin{lstlisting}[
  language=python,
  title={Creating a Toeplitz Matrix (used in MLM experiments)},
  captionpos=t]
def create_toeplitz_matrix(n):
  w = tf.get_variable(
    "weight",
    shape=[2 * n - 1],
    initializer=WEIGHT_INITIALIZER)
  r = w.shape[0].value // 2
  t = tf.pad(w, [[0, n]])
  t = tf.tile(t, [n])
  t = t[:-n]
  t = tf.reshape(t, [n, n + w.shape[0] - 1])
  return t[:, r:-r]
\end{lstlisting}

\FloatBarrier
\section{Visualizing Tiny Attention}
\label{sec:visualize-tiny-attn}
Here we visualize the attention maps of the tiny attention modules in aMLP, after finetuning on MNLI-m. Each element in the heatmap below denotes the maximum attention weight of the corresponding token pair ever received during the first half of the network.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.73\linewidth]{figures/amlp-heatmap-1.pdf}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.73\linewidth]{figures/amlp-heatmap-2.pdf}
    \caption{Attention maps in aMLP over selected examples in MNLI-m.}
\end{figure}
    
\end{document}
