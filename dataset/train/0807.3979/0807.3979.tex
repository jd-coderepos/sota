
\documentclass[final]{acmtrans2e}




\usepackage{graphicx}
\usepackage{ulem}
\usepackage{color}
\usepackage{latexsym}
\usepackage{amsmath}
\usepackage{amsfonts}

\normalem





\newtheorem{theorem}{Theorem}[section]
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newdef{definition}[theorem]{Definition}
\newdef{remark}[theorem]{Remark}


\newtheorem{define}[theorem]{Definition}

\newtheorem{exa}[theorem]{Example}
\newenvironment{example}{\begin{exa}}{\end{exa}}


\newtheorem{note}[theorem]{Note}
\newtheorem{fact}{Fact}
\newtheorem{claim}{Claim}
\newtheorem{exe}{Exercise}
\newenvironment{exercise}{\begin{exe} \rm }{\end{exe}}

\def\smallromani{\renewcommand{\theenumi}{\roman{enumi}}
        \renewcommand{\labelenumi}{(\theenumi)}}



\newcommand{\diag}[2]{d_{{#1}{#2}}}

\newcommand{\Exists}{\exists\!\!\exists}
\newcommand{\rarrow}{\rightarrow}
\newcommand{\longar}{\longrightarrow}
\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
\newcommand{\lan}{\langle}
\newcommand{\ran}{\rangle}
\newcommand{\os}{[\![}
\newcommand{\cs}{]\!]}
\newcommand{\rrarrow}{\longrightarrow}
\newcommand{\hiding}{\\exists}
\newcommand{\restr}{\mid}
\newcommand{\lrarrow}{{\longrightarrow}}
\newcommand{\tell}{{\bf tell}}
\newcommand{\atell}{{\bf atell}}
\newcommand{\ask}{{\bf ask}}
\newcommand{\nask}{{\it nask}}
\newcommand{\update}{{\bf update}}
\newcommand{\sat}{{\it sat}}
\newcommand{\nil}{{\it nil}}
\newcommand{\true}{{\it true}}
\newcommand{\false}{{\it false}}
\newcommand{\vars}{{\it Var}}
\newcommand{\form}{P \; sat \; \phi}
\newcommand{\NI}{\noindent}


\long\def\comment#1{}






\markboth{Maurizio Gabbrielli, Maria Chiara Meo and Paolo Tacchella}{Unfolding in CHR}


\title{Unfolding in CHR}

\author{Maurizio Gabbrielli\\
  Universit\`{a} di Bologna
  \and
  Maria Chiara Meo\\
  Universit\`a ``G. D'Annunzio'' di Chieti-Pescara
  \and
  Paolo Tacchella\\
   Universit\`{a} di Bologna}



\begin{abstract}
Program transformation is an appealing technique which allows to
improve  run-time efficiency, space-consumption and more generally
to optimize a given program. Essentially it consists of a sequence
of syntactic program manipulations which preserves some kind of
semantic equivalence.  One of the basic operations which is used
by most program transformation systems is unfolding  which
consists in the replacement of a procedure call by its definition.
While there is a large body of literature on transformation and
unfolding of sequential programs, very few papers have addressed
this issue for concurrent languages and, to the best of our
knowledge, no other has considered unfolding of CHR programs.

This paper defines a correct unfolding system
for CHR programs. We define an unfolding rule, show its
correctness and discuss some conditions which can be used to
delete an unfolded rule while preserving the program meaning.
We prove that confluence and termination properties
are preserved by the above transformations.
\end{abstract}
\category{I.2.2}{Artificial Intelligence}{Automatic Programming}[Program transformation]\category{D.3.1}{Programming Languages}{Formal Definitions and
Theory}[Semantics] \category{D.3.3}{Programming
Languages}{Language Constructs and Features}[Constraints]
\terms{Languages, Theory, Semantics}


            \begin{document}

            \begin{bottomstuff}
             Author's address:
             \newline
             Maurizio Gabbrielli,
  Dipartimento di Scienze dell'Informazione, Mura A. Zamboni 7, 40127 Bologna, Italy.
  {\tt gabbri@cs.unibo.it.}
  \newline Maria Chiara Meo, Dipartimento di Scienze, Viale Pindaro 42,
  65127 Pescara, Italy.
{\tt cmeo@unich.it.}
 \newline Paolo Tacchella, Dipartimento di Scienze dell'Informazione, Mura A. Zamboni 7, 40127 Bologna, Italy.
{\tt Paolo.Tacchella@cs.unibo.it} \end{bottomstuff}

\maketitle
\section{Introduction}
Program transformation was initially developed as a
technique which assist in writing correct and efficient programs \cite{BD77}.
Said technique consists of many intermediate transformation steps until the final
one is reached. Every transformed program is equivalent (gives the same results) of
the initial one, when an input is fixed. The transformation between various algorithms
which compute Fibonacci succession can be considered as an example of program transformation.
In fact, the time complexity of the previous succession ranges from the exponential to the logarithmic
depending on the chosen  algorithm \cite{SP95}.

CHR is a general purpose \cite{SSD05d}, declarative, concurrent, committed-choice
constraint logic programming language, consisting of guarded rules, which
transform multisets of atomic formulas (constraints) into simpler ones to the point of
exhaustion \cite{Fru06}, that was initially designed for writing
constraint solvers \cite{Fru98,FA03}.
There is nowadays a very  large literature on
CHR, ranging from theoretical aspects to implementations and
applications. \\
In fact, the website
http:/\!/www.cs.kuleuven.ac.be/\,\lower 3.5pt\hbox{\~{}} \,dtai/projects/CHR/
reports more than 1000 papers mentioning CHR. However,
only a few papers, notably \cite{FH03,Fru04,SSD05b}, consider  source
to source transformation of CHR programs. This is not surprising,
since program transformation is in general very difficult for
(logic) concurrent languages and in case of CHR it is even more
complicated, as we discuss later.

While  \cite{Fru04}  focuses on specialization of a program for a
given  goal, here we consider unfolding.  This is a basic
operation of any source to source transformation (and
specialization) system and essentially consists in the replacement
of a procedure call by its definition. While this operation can be
performed rather easily for sequential languages, and indeed  in
the field of logic programming it was first investigated by Tamaki
and Sato more than twenty years ago \cite{TS84}, when considering
logic concurrent languages it becomes quite difficult to define
reasonable conditions which ensure its correctness. This is mainly
due to three problems. The first one is the presence of guards in the rules.
Intuitively, when
unfolding a rule  by using a rule  (i.e. when replacing in
the body of  a ``call'' of a procedure by its definition )
it could happen that some guard in  is not satisfied
``statically'' (i.e. when we perform the unfold), even though it
could become satisfied later when the unfolded rule is actually
used. If we move the guard of  in the unfolded version of 
we can then loose some computations (because the guard is
anticipated). This means that if we want to preserve the meaning
of a program we cannot replace the rule  by its unfolded
version, and we have to keep both the rules.
The second source of difficulties consists in matching substitution
mechanism. Only the variables in the atoms of the head of a rule
 can be instantiated to become equal to the goal terms following
the previous mechanism. From the other side, the unification mechanism
permits also the instantiation of the variables in the atoms of the
goal. Considering the matching substitution, the deletion of , when
a rule  could be used to unfold  if strong enough hypotheses
would be considered, can cause computation loss also if  is unfolded
by another rule . Finally, for CHR, the situation is further complicated by
the presence of multiple heads in the rules.
In fact, let  be the body of a rule  and let  be the (multiple)
head of a rule , which can be used to unfold , we cannot be sure
that at run-time all the atoms in  will be used to rewrite ,
since in general  could be in a conjunction with other atoms even
though the guards are satisfied. This technical point, that one can legitimately find
obscure now, will be further clarified in Chapter
\ref{sec:safty-rule-deletion}.

Despite these technical problems, the study of unfolding techniques
for concurrent languages, and for CHR in particular, is important
as it could lead to significant improvements in the efficiency and
in non-termination analysis of programs.

In this paper we then define an unfolding rule for CHR programs
and show that it preserves the semantics of the program in terms
of qualified answers, a notion already defined in the literature
\cite{Fru98}.
We also provide a syntactic condition which allows to replace in a
programs a rule by its unfolded version  while preserving
qualified answers. Even though the idea of the unfolding is
straightforward, its technical development is complicated by the
presence of guards, multiple heads and matching substitution,
as previously mentioned. In
particular, it is not immediate to identify conditions which
allow to replace the original rule by its unfolded version.
Moreover, a further reason of complication comes from the fact
that we consider the reference semantics (called )
defined in \cite{DSGH04} which avoids trivial non termination by
using a, so called, token store or history. Due
to the presence of this token store,  in order to define correctly
the unfolding we have to slightly modify the syntax of CHR programs
by adding to each rule  a local token store. The resulting programs
are called annotated and we define their semantics by providing a
(slightly) modified version of the semantics , which is
proven to preserve the qualified answers. Finally, the maintenance
of confluence and termination of property between the original and
the ones, which are modified following the above techniques, is proven.

The remaining of this paper is organized as follows. Next section
contains some notations used in the paper and the syntax of CHR.
The operational semantics of  \cite{DSGH04} and of the
modified semantics   are presented  in
Section~\ref{sec:semantics}. Section~\ref{sec:unfolding} defines
the unfolding rule and prove its correctness.
Section~\ref{sec:safty-rule-deletion}  discuss the problems
related to the replacement of a rule by its unfolded version and
gives a correctness condition which holds for a specific class of
rules. Then Section~\ref{sec:confluence&termination} proves that
confluence and termination are preserved by the program modifications
introduced. Finally Section~\ref{sec:conclusion_and_future} concludes
by discussing also some related work.




\section{Preliminaries}\label{sec:notation}

In this section we introduce the syntax of CHR and some notations
and definitions we will need in the paper. CHR uses two kinds
of constraints: the built-in and the CHR ones, also called
user-defined.

Built-in constraints are defined by

where  is an atomic built-in constraint\footnote{We could
consider more generally first order formulas as built-in
constraints, as far as the results presented here are concerned.}.
These constraints are handled by an existing solver and we assume
given a (first order) theory CT which describes their meaning.
We assume also that built-in constraints contain  which is described, as usual, by the Clark Equality Theory.

We use  to denote built-in constraints,  to denote CHR
constraints and  to denote both built-in and user-defined
constraints (we will call these generically constraints).  We also
denote by  any inconsistent (conjunction of)
constraints and by  the empty set of
constraints. The capital versions will be used to denote multisets
(or sequences) of constraints.


The notation , where  is a set of variables,
denotes the existential closure of a formula  with the
exception of the variables in  which remain unquantified.
 denotes the free variables appearing in .
Moreover, if  and  are sequences of terms then the notation

represents the set of equalities  if , and it is undefined otherwise.
Analogously, if  and  are sequences of constraints, the notation
 represents the set of equalities .
Finally, multiset union is represented by symbol .

\subsection{CHR syntax}\label{sec:syntax}
As shown by the following definition, a  \emph{CHR program}
consists of a set of rules which can be divided into three types:
\emph{simplification}, \emph{propagation} and \emph{simpagation}
rules. The first kind of rules is used to rewrite
CHR constraints into simpler ones, while second one allows to add new redundant
constraints which may cause further simplification. Simpagation rules allow to represent both simplification and propagation rules.

\begin{definition}\textsc{CHR Syntax} \cite{Fru98}.
A CHR program is a finite set of CHR rules.
There are three kinds of CHR rules:

\noindent{A \textbf{simplification} rule has the form: }\\
\noindent{A \textbf{propagation} rule has the form:
}\\
\noindent{A \textbf{simpagation} rule has the form:
}\noindent where  is a unique identifier of the rule, ,  and  are
sequences of user-defined constraints (called heads),  is a
possibly empty multiset of built-in constraints (guard) and  is
a possibly empty multiset of (built-in and user-defined)
constraints (body). A \emph{CHR goal} is a multiset of (both
user-defined and built-in) constraints.
\end{definition}

A  \emph{simpagation} rule can simulate both simplification and
propagation rule by considering, respectively, either  or
 empty (with ). In the following we
will then consider in the formal treatment only simpagation rules.

When considering unfolding we need to consider a slightly
different syntax,  where rule identifiers are not necessarily
unique, atoms in the body are associated with an identifier,
that is unique in the rule, and
where each rule is associated  with a local token store .
More precisely, we define an identified CHR constraint  (or
identified atom)  as a CHR constraint , associated with
an integer  which allows to distinguish different copies of the
same constraint.

\begin{definition}\textsc{CHR Annotated syntax.}
Let us define a token as an object of the form , where 
is the name of a rule and  is a sequence of identifiers.
A token store (or history) is a set of tokens.


\noindent An \textbf{annotated} rule has then the form:
 where 
is an identifier,  and  are
sequences of user-defined constraints, 
is a sequence of built-in and identified CHR constraints
such that different (occurrences of) CHR constraints have different identifiers,
and  is a token store, called the local token store of rule .
An annotated CHR program is a finite set of annotated CHR rules.
\end{definition}
We will also use the functions {\em chr(hi)=h} and the overloaded
function {\em id(hi)=i}, [and ]
possibly extended to sets and sequences of identified CHR constraints [or tokens] in
the obvious way. Given a goal , we denote by  one of the
possible identified versions of .  is the set of all (possibly
identified) goals.


Intuitively, identifiers are used to distinguish different
occurrences of the same atom in a rule. The identified atoms can
be obtained by using a suitable function which associates a
(unique) integer to each atom. More precisely, let  be a goal
which contains  CHR-constraints. We assume that the function
 identifies each CHR constraint in  by
associating to it a unique integer in  according to the
lexicographic order.

On the other hand, the token store allows to memorize  some tokens,
where each token describes which (propagation) rule has been used
for reducing which identified atoms.
As we discuss
in the next section, the use of this information was originally proposed
in \cite{Abd97} and then further elaborated in the semantics defined
in \cite{DSGH04} in order to avoid trivial  non termination
arising from the repeated application of the same propagation rule
to the same constraints. Here we simply incorporate this
information in the syntax, since we will need to manipulate it in
our unfolding rule.

Given a CHR program , by using the function  and
an initially empty local token store we can construct its annotated
version as the next definition explains.


\begin{definition}
Let  be a CHR program. Then its annotated version is defined as follows:

\end{definition}


\noindent {\bf Notation} \\
In the following examples, given a
(possibly annotated) rule
   we write it as
 if  is empty and
we write it as
 if  is empty.

That is, we maintain also the notation previously introduced for
simplification and propagation rules. Moreover, if , then  is omitted.
Finally,  if in an annotated rule the token store is empty we
simply  omit it.


\section{CHR operational semantics}\label{sec:semantics}

This section introduces the reference semantics 
\cite{DSGH04}, in particular the variant that modifies the token
set only after the application of a propagation rule (for the sake
of simplicity, we omit indexing the relation with the name of the
program).


Afterward we define a slightly different operational  semantics,
called , which considers annotated programs and which
will be used to prove the correctness of our unfolding rules (via some form of
equivalence between   and ).


\begin{table*}[tbp]
\caption{The transition  system  for the  semantics}
\centering
\label{omega-t}


\begin{tabular}{lll}
\hline\noalign{\smallskip}
&\mbox{   }&\mbox{   }
\\
\mbox{\bf Solve} &  



&\mbox{ }
\\
&\mbox{   }&\mbox{   }
\\

\mbox{\bf Introduce}&  &\mbox{ }
\\
&\mbox{   }&\mbox{   }
\\

\mbox{\bf Apply}& &\mbox{ }
\\
&\mbox{   }&\mbox{   }
\\
&\mbox{where }
\mbox{ and }\\
&&\mbox{
}
\\
&\mbox{   }&\mbox{   }
\\
\noalign{\smallskip}\hline
\end{tabular}
\end{table*}


We describe the operational semantics , introduced in
\cite{DSGH04}, by using a transition system
 Configurations in  are
tuples of the form  with the
following meaning. The \emph{goal}  is a multiset of constraints to
be evaluated. The \emph{CHR constraint store}  is the set of
identified CHR constraints that can be matched with the head of the
rules in the program . The \emph{built-in constraint store}  is a
conjunction of built-in constraints. The {\em propagation history}
 is a set of tokens of the form , where 
is the name of the applied propagation rule and  is the
sequence of identifiers associated to the constraints to which the
head of the rule is applied. This is needed to prevent trivial
non-termination for propagation rules. If one do not consider
tokens (as in the original semantics of \cite{Fru98}) it is clear
from the transition system that if a propagation rule can be
applied once it can be applied infinitely many times thus
originating an infinite computation (no fairness assumptions are
made here). On the other hand, by using tokens one can ensure that
a propagation rule is used to reduce a sequence of constraints
only if the same rule has not been used before on the same
sequence of constraints, thus avoiding trivial infinite
computations (arising from the application of the same rule to the
same constraints). As previously mentioned, the first idea of using
a token store to avoid trivial non termination was described in
\cite{Abd97}. Finally the \emph{counter}  represents the next
free integer which can be used to number a CHR constraint.


Given a goal , the  {\em initial configuration} has the form

A {\em final configuration} has either the form  when it is {\em failed} or it
has the form  when it
represents a successful termination (since there are no more
applicable rules).


The relation  (of the transition system
of the operational semantics ) is defined  by the rules
in Table \ref{omega-t}: the \textbf{Solve} rule moves a
built-in constraint from goal store to the built-in constraint
store; the \textbf{Introduce} identifies and moves a CHR (or used
defined) constraint from the goal store to the CHR constraint
store and the \textbf{Apply} rule chooses a program rule , for
which matching between constraints in CHR store and the ones in
the head of  exists, it checks that the guard of  is
entailed by the built-in constraint store, considering the
matching substitution, and it verifies that the token that would be
eventually added by \textbf{Apply} in the token store is not already
present, than it fires the rule. After the application of 
the constraints which match with the right hand side of the head
of  are deleted from , the body of  is added to
the CHR constraint store and the matching substitution between
the head of  and the atoms in  is added to the
built-in constraint store.


\subsection{The  modified semantics }
We now define the semantics  which considers annotated rules.
This semantics differs from  in two aspects.

First, in 
the goal store and the CHR store are fused in a unique generic \emph{store}, where
CHR constraints are immediately labeled. As a consequence, we do not
need anymore the Introduce rule and every CHR
constraint in the body of an applied rule is immediately
utilizable for rewriting.

The second difference concerns the shape of the rules. In fact,
each annotated rule  has  a local token store (which can be
empty) that is associated to it and which is used to keep trace of
the propagation rules that are used to unfold the body of .
Note also that here, differently from the case of the propagation
history in , the token store associated to
 the real computation can be updated
by adding more tokens at once (because an unfolded rule with many
token in its local token store has been used).

In order to define formally 
we need a function   which updates
the formal identifiers of a rule to the actual computation ones and it
is defined as follows.

\begin{definition}\label{definst}
 Let  be the set of all possible token
set and let  be the set of natural numbers. We denote
by  the function such that
), where
\begin{itemize}
    \item  is an identified CHR goal,
    \item  is obtained from  by
    incrementing each identifier in  with  and
    \item  is the greatest identifier in .
\end{itemize}
\end{definition}

We describe now the operational semantics   for annotated CHR
programs  by using, as usual, a transition system
 Configurations in
 are tuples of the form  with the following meaning.   is the set of
identified CHR constraints that can be matched with rules in the
program  and built-in constraints. The built-in constraint
store  is a conjunction of built-in constraints and  is a
set of tokens, while the counter  represents the last integer
which  was used to number  the CHR constraints in .


Given a goal , the  {\em initial configuration} has the form

where  is the number of CHR constraints in . A {\em final
configuration} has either the form  when it is {\em failed} or it has the form  when it represents a successful
termination, since there are no more applicable rules.

The relation  (of the transition system of
the operational semantics ) is defined  by the rules in
Table \ref{tab:operational-semantics}.  Let us discuss briefly
the rules.

\begin{description}
\item[Solve']{moves a built-in constraint from the store to the
built-in constraint store;}

\item[Apply']{uses the rule  provided that exists a matching
substitution  such that ,  is entailed by the built-in constraint
store of the computation and ;  is replaced by , where the identifier
are suitably incremented by  function and  is added to built-in constraint
store.}
\end{description}

\begin{table*}[t]
\caption{The transition system  for the  semantics}
\centering
\label{tab:operational-semantics}

\end{table*}






In order to show the equivalence of the semantics  and
 we now define the  notion of observables that we
consider: these are the ``qualified answers'' (already used in
\cite{Fru98}).



\begin{definition}\textsc{(Qualified answers)}. Let  be a CHR program and let
 be a goal. The set  of
qualified answers for the query  in the program  is defined
as follows:

\end{definition}

Analogously we can define the qualified answer of an annotated
program.

\begin{definition}\textsc{(Qualified answers for annotated programs)}.
Let  be an annotated CHR program and let  be a goal with 
CHR constraints. The set  of qualified answers
for the query  in the annotated program  is defined as follows:

\end{definition}

The following definition is introduced to describe the equivalence
of two intermediate states and it is used only in the proofs.
We consider two state equivalent when they are identical up to
renaming of local variables and renaming of identifiers and logical
equivalence of built-in constraints.

\begin{definition}[{\sc Inter-semantics State equivalence}]\label{def:PLQA}
 Let
  be a state in the transition system  and let   be a state in the transition system .

 and  are \emph{equivalent} (and we write
) if:
\begin{enumerate}
\item  there exist  and , such that ,  and ,
\item for each ,  does not occur in ,
\item there exists a renaming of identifier  s.t.  and .
\end{enumerate}
\end{definition}


The following result shows the equivalence of the two introduced
semantics proving the equivalence (w.r.t. Definition \ref{def:PLQA})
of intermediate states. The proof
is easy by definition of  and .


\begin{lemma}\label{lemma:intermequiv}
Let  and  be respectively a CHR program and its annotated version.
Moreover, let
 and let   such that
.
Then the following holds
\begin{itemize}
  \item there exists a derivation  in  if and only if
there exists a derivation  in  such  
  \item the number of \textbf{Solve} (\textbf{Apply}) transition steps in  and the number of \textbf{Solve'} (\textbf{Apply'}) transition steps in  are equal.
\end{itemize}
\end{lemma}
\textsc{Proof.}
 We show that any transition step from any state in one system can be imitated from a (possibly empty) sequence of  transition steps from an equivalent state in the other system to achieve an equivalent state.
 Moreover there exists a \textbf{Solve} (\textbf{Apply}) transition step in  if and only if there exists a  \textbf{Solve'} (\textbf{Apply'}) transition step in .

 Then the proof follows by a straightforward inductive argument.

Let 
and let   such that
.

\begin{description}
\item[Solve and Solve':] they move a built-in constraint from the Goal store or the Store
respectively to the built-in constraint store. In this case let . By definition of the two transition systems

By definition of , it is easy to check that .


\item[Introduce:] this kind of transition exists only in  semantics and its
application labels a CHR constraint in the goal store and moves it in the CHR store.
In this case let  and


Let us denote  by .
By definition of ,  there exist  and , such that ,  and . Therefore
there exists an identified atom .
Let  (where  if  is not in the domain of ).
By construction and by hypothesis,  and  are such that ,  and .

Moreover, by definition of , for each ,  does not occur in . Therefore, since by construction , we have that for each ,  does not occur in .

Now, to prove that , we have only to prove that there exists a renaming , such that
 and .

We can consider the new renaming . By definition  is a renaming of identifiers.
Since by construction, , we have that if there exists , then . Moreover, since , if there is no  then .  By the previous observations, we have that .
Finally, since  does not occur in , we have that , where the last equality follows by hypothesis. Moreover  since , we have that  does  not occur in .
Therefore  and then the thesis.


\item[Apply and Apply':] Let  and
  be its annotated version which can
be applied to the considered state . In particular  match respectively with  and
. Without loss of generality, by using a suitable number of Introduce steps, we can assume that
 can be applied to . In particular, we can assume for , there exists  such that  and  match respectively with  and
.

By definition of , there exist  and  such that
,
,
 and  let .

By construction, since  and , we have that
\\
\begin{itemize}
\item  if and only if
 and
\item  if and only if
.
\end{itemize}


Therefore, by definition of {\bf Apply} and of {\bf Apply'}

if and only if

where
\begin{itemize}
  \item  if ,
 otherwise ,
  \item  and
  \item  if ,
 otherwise .
\end{itemize}

Let  and
. \\

Now, to prove the thesis, we have to prove that
.

The following holds.

\begin{enumerate}
\item  There exist  and , such that ,
     and .
\item Since for each ,  does not occur in ,
  and by definition of \textbf{Apply'} transition, we have that for each ,  does not occur in ,
\item By construction and since , we have that .
Moreover, by construction  .
\end{enumerate}
By definition, we have that  and then the thesis.
\end{description}
\noindent{}


\begin{proposition}\label{lemma:nequality}
Let  and  be respectively a CHR program and its annotated version.
Then, for every goal ,

holds.
\end{proposition}
\textsc{Proof.} By definition of  and of ,
the initial states of the two transition system are equivalent. Then the proof follows by Lemma \ref{lemma:intermequiv}.

\section{The unfolding rule}\label{sec:unfolding}


In this section we define the \emph{unfold operation} for CHR
simpagation rules. As a particular case we obtain also
unfolding for  simplification and propagation rules, as these can
be seen as particular cases of the former.

The unfolding allows to replace  a  conjunction  of constraints
(which can be seen as a procedure call) in the body of a rule 
by the body of a rule  ,  provided that the head of  matches
with , by assuming the built-in constraints in
the guard and in the body of the rule . More precisely, assume that
the built-in constraints in the guard and in the body
of the rule  imply that the head  of ,
instantiated by a substitution , matches with the
conjunction   (in the body of  ). Then the unfolded rule is
obtained from  by performing the following steps:  1) the new
guard in the unfolded rule is the conjunction of the guard of 
with the guard of , the latter instantiated by  and
without  those constraints that are entailed by the built-in
constraints which are in ; 2) the body of  and the equality
 are added to the body of ; 3) the conjunction of constraints  can
be removed, partially removed or left in the body of  the unfolded
rule, depending on the fact that  is a simplification, a
simpagation or a propagation rule, respectively; 4) as for the
local token store   associated to every rule , this is
updated consistently during the unfolding operations in order to
avoid that a propagation rule is used twice to unfold the same
sequence of constraints.


Before formally defining the unfolding we need to define the
function  as
follows:  deletes from  all the tokens for
which at least one identifier is not present in the identified
goal . More formally

Recall also that we defined  {\em chr(hi)=h}.

\begin{definition}\textsc{(Unfold).}\label{def:unf}
Let  be an annotated CHR program  and let  be two
annotated rules such that:

where  is the conjunction of all the built-in constraints in the body
of  and , that is, the constraints   in the head of rule
 match with  and  matches with  by using the substitution ,
once the built-in constraints in  are assumed. Furthermore assume that
 is the greatest identifier which appears in the
rule  and that .
Then the \emph{unfolded} rule is:
 where ,   is the greatest set of built-in constraints , such that ,
, the
constraint  is satisfiable and
\begin{itemize}
    \item if  then 
    \item if  then .
    \end{itemize}
\end{definition}

Note that we use  the function   (Definition~\ref{definst})
in order to increment the value of the
identifiers associated to atoms in the unfolded rule. This allows
us to distinguish the new identifiers introduced in the unfolded
rule from the old ones. Note also that the condition on the token
store is needed to obtain a correct rule.  Consider for example a ground annotated
program   and let
 be  the start goal. In this case the unfolding could change
the semantics if the token store were not used. In fact, according
to the semantics proposed in Table \ref{omega-t} or
\ref{tab:operational-semantics}, we have the following
computation: . On the other hand,  considering an
unfolding without the update of  the token store one would have
r_2r_2r_3
so, starting from the constraint  we could arrive to constraint , that
is not possible in the original program (the clause obtained after
the wrongly applied unfolding rule is underlined).


As previously mentioned, the unfolding rules for simplification
and propagation can be obtained as particular cases of
Definition~\ref{def:unf}, by setting  and  , respectively, and by considering accordingly the
resulting unfolded rule. In the following examples we will use
 to denote both   and .

\begin{example}\label{ex:gen_adam}
The following program   deduces
information  about genealogy. Predicate  is considered as
father,  as grandfather,  as grandson and  as
great-grandfather. The following rules are such that we can unfold
some constraints in the body of  using the rule  .

Now we  unfold the body of rule  by using the rule
 where we assume  (so we have a simplification rule).  We use
 and a renamed version of 

 in order to avoid variable clashes.
So the new unfolded rule is:


Now, we unfold the body of rule  by using the simpagation
rule . As before,
 and a renamed version of 

is used to avoid variable clashes. The new unfolded rule is:



Finally we unfold the body of  by using the  rule where  =  is assumed (so we have a propagation rule).
As usual,  and a renamed version of  is used to avoid variable clashes:

and so the new unfolded rule is:

\end{example}

The following example considers more specialized rules  with guards which are not .

\begin{example}\label{ex:gen_adam_refined}
The following  program  specializes the rules introduced in Example \ref{ex:gen_adam}
to the genealogy of Adam. So here we remember that Adam was father of Seth; Seth was father
of Enosh; Enosh was father of Kenan. As before, we consider the predicate  as father,
 as grandfather,  as grandson and  as great-grandfather.


If we unfold  by using (a suitable renamed version of) ,
where we assume , we obtain:

When  is considered to unfold  we have

Finally if we assume  in  from the unfolding we obtain


Note that   are not
added to the guard of the unfolded rule  because  is
entailed by the guard of  and  is entailed
by the built-in constraints in the body of .
\end{example}

We prove now the correctness of our unfolding definition.
Before the introduction of the proposition which proves the correctness of our unfolding, three new
definitions are given. The first one presents the concept of built-in
free state. Said state either has no built-in constraints in the first component
or the built-in store is unsatisfiable.

\begin{definition}[{\sc Built-in free State}]\label{def:BFS}
Let   ().
The state  is built-in free  if either   or
 () is a multiset of (identified) CHR-constraints.
\end{definition}

The second definition introduces the state equivalence between states in .
Note that in such definition, the
equivalence operator is represented with the symbol .


\begin{definition}[{\sc State equivalence}]\label{def:SE}
Let   and   be states in .
 and  are equivalent and we write  if one of the following facts hold.
\begin{itemize}
  \item either  and 
  \item or ,  and .
\end{itemize}
\end{definition}

Finally the third definition presents the normal derivation. A derivation
is called normal if no other \textbf{Solve} (\textbf{Solve'}) transition are possible
when an \textbf{Apply} (\textbf{Apply'}) one happens.

\begin{definition}[{\sc Normal derivation}]\label{def:ND}
Let   be a (possibly annotated) CHR program  and let
 be a derivation in .
We say that  is normal if it uses a transition
\textbf{Solve} (\textbf{Solve'}) as soon as possible, namely it is possible to use a transition
\textbf{Apply} (\textbf{Apply'})
on a state  only if  is built-in free.
\end{definition}


Note that, by definition, given a CHR program ,  can be calculated by
considering only normal derivations. Analogously for an annotated CHR program .
The proof  of the following proposition is straightforward and hence it is omitted.

\begin{proposition}\label{prop:solonorm}
Let  be CHR program  and let  an annotated CHR program.
Then

and

\end{proposition}

\begin{proposition}\label{prop:servequality}
Let  be annotated CHR rules and   be the result
of the unfolding of  with respect to . Let  be a generic built-in free state such that we can use the transition \textbf{Apply'} with the clause  obtaining the state  and then the built-in free state . Then we can construct a derivation which uses at most the clauses  and  and obtain a built-in free state  such that .
\end{proposition}


\textsc{Proof.}
Assume that


The labeled arrow  means that only solve transitions are applied.
Moreover
\begin{itemize}
           \item if  has the form
 then the derivation between the parenthesis is not present and .
           \item the derivation between the parenthesis is present and , otherwise.
         \end{itemize}



\noindent{\textbf{Preliminaries}:}
Let   be a built-in free state
and let
 and

where  is the conjunction of all the built-in constraints in the body
of  and

Furthermore assume that  is the greatest identifier which appears in the
rule  and that .
Then the \emph{unfolded} rule is:

where ,
 is the greatest set of built-in constraints ,
such that

, the
constraint  is satisfiable and
\begin{itemize}
    \item if  then 
    \item if  then .
    \end{itemize}
    By previous observations, we have that
    
\noindent{\textbf{The proof}:} By definition of the transition \textbf{Apply'}, we have that

where  and

     where
     , with
      and
\begin{itemize}
    \item if  then 
    \item if  then .
    \end{itemize}
    Therefore, by definition
    
    where
    

On the other hand, since by (\ref{10dic1}),

by definition of the transition \textbf{Apply'}, we have that


     where ,\\
      and
\begin{itemize}
    \item if  then 
    \item if  then .
    \end{itemize}
    Therefore, by definition
    
  where


Now, we have two possibilities
\begin{description}
  \item[().] In this case, by construction we have that . Therefore  and then the thesis.
  \item[().]
  By definition, since
, by (\ref{13marzo1}), (\ref{10dic2}) and (\ref{10dic1}), we have that

where . Therefore
by (\ref{13marzo2})


and

     where
     , with
      and
\begin{itemize}
    \item if  then 
    \item if  then .
    \end{itemize}
    Finally by definition, we have that

  where
  

  If  then the proof is analogous to the previous case and hence it is omitted.
  Otherwise, observe that by construction,
, where
 is obtained from  by adding the natural  to each identifier in
 and by adding the natural  to each identifier in
.
Analogously, by construction,
, where
  are obtained from  by adding the natural  to each identifier in
 and  is obtained from  by adding the natural   to each identifier in .

Therefore  and then, to prove the thesis, we have only to prove that 

Let us introduce the function  as
the restriction of the function  to token sets and natural numbers, namely
, where  is obtained from  by
incrementing each identifier in  with . So, since
,
 and
, we have that


Analogously, ,
 and , we have that

Now, since by construction  is obtained from  by adding the natural  to each identifier, we have that .
Moreover, by definition of annotated rule 
and , where
 is obtained from  by adding the natural  to each identifier in
 and by adding the natural  to each identifier in
. Then  and then the thesis.
\end{description}
\noindent{}



We prove now the correctness of our unfolding rule.

\begin{proposition}\label{lemma:equality}
Let  be an annotated CHR program with . Let   be the result
of the unfolding of  with respect to  and let  be the program
obtained from  by adding rule . Then, for every goal ,
 holds.
\end{proposition}


\textsc{Proof.}
We prove the two inclusions separately.
\begin{description}
  \item[{\bf ()}] The proof follows from Propositions \ref{prop:solonorm} and \ref{prop:servequality} and by a straightforward inductive argument.
  \item[{\bf ()}]
  The proof is by contradiction. Assume that there exists . By definition there exists a derivation
   in , such that . Since , we have that there exists the derivation
 in . Moreover, since  and by hypothesis , we have that there exists a derivation step  by using the clause .
Then, by definition of unfolding there exists a derivation step  in , by using the clause  and then we have a contradiction.
\end{description}

\noindent{}\\
	

\section{Safe rule replacement}\label{sec:safty-rule-deletion}
Previous corollary shows that we can safely add to a program 
a rule resulting from the unfolding, while preserving the
semantics of   (in terms of qualified answers).
However, when a rule  in program  has been unfolded producing
the new rule , in some cases we would like also to replace  by  in ,
since this could improve the efficiency of the resulting program.
Performing such a replacement while preserving the semantics
is in general a very difficult task for three reasons.

First of all, anticipating the guard of  in the guard of 
(as we do in the unfold operation) could lead to loose some
computations  when the unfolded rule   is used rather than the
original rule . This is shown by the following example.




\begin{example}\label{esempio:mau}
Let us consider the program

where we do not consider the identifiers (and the local token store) in
the body of rules, because we do not have propagation rules in
.

The unfolding  of  by using the rule  returns the new
rule . The
program

is not semantically equivalent to  in terms of qualified
answers. In fact, given the goal  we have , while 
\end{example}


The second problem is related to multiple heads. In fact, the
unfolding that we have defined  assume that the head of a rule
matches completely with the body of another one, while in general,
during a CHR computation, a rule can match with constraints
produced by more than one rule and/or  introduced by the initial
goal. The following example illustrates this point.

\begin{example}\label{ex:unicatesta}
Let us consider the program

where we do not consider the identifiers and the token store in
the body of rules, because we do not have propagation rules in
.

The unfolding  of  by using   returns the new
rule
 Now the
the program

where we substitute the original rule by its  unfolded version is
not semantically equivalent to . In fact, given the goal , we have that  
( is a qualified answer for  in ) while 
\end{example}

The final problem is related to the matching substitution. In fact,
following Definition \ref{def:unf}, there are some matching that could become
possible only at run time, and not at compile time, because a more powerful
built-in constraint store is needed. Also in this case, a rule elimination could lead to lose
possible answers as illustrated in the following example.

\begin{example}\label{ex:matching}
Let  be a program

where we do not consider the identifiers and the token store in the
body of rules, because we do not have propagation rules in .
Let  be the program where the rule , that is unfolded using  in ,
substitutes the original  (note that other unfolding are not possible, in
particular the rule  can not be used to unfold )

Let be  the goal, we can see that
 and   because,
with the considered goal (and consequently
the considered built-in constraint store)  can fire in  but can not fire in
.
\end{example}

We have individuated a case in which we can safely replace the
original rule  by its unfolded version while maintaining the
qualified answers semantics. Intuitively, this holds when: 1)  the
constraints of the body of   can
 be rewritten only by CHR rules with a single-head, 2) there exists
no rule  which has a multiple head  such that a part of 
can match with a part of the constraints introduced in the body of
 (that is, there exists no rule  which can be fired by using
a part of constraints introduced in the body of  plus some
other constraints) and 3) all the rules, that can be applied at run
time to the body of the original rule , can also be applied at
transformation time (so unfolding avoidance for built-in constraint
store and guard-anticipation problems are solved).

Before defining formally these conditions we need some further
notations. First of all, given a rule
, we define
two sets. The first one contains a set of pairs, whose first
component is a rule that can be used to unfold , while the second one is the
sequence of the identifiers of the atoms in the body of , which
are used in the unfolding.

The second set contains all the rules that can be used for the
{\em partial unfolding} of , namely is the set of rules that can fire by
using at least an atom in the body  of the rule and
some others CHR and built-in constraints. It moreover contains
the rules that can fire if an opportune built-in constraint
store is given by the computation but that can not be unfolded
following Definition \ref{def:unf}.



\begin{definition}\label{def:Pposeneg}

Let  be an annotated CHR program and let

be two annotated rules, such that  and   is renamed
apart with respect to . We define  and  as follows:
\begin{enumerate}
    \item\label{uno}  
 if and only if
 can be
unfolded with  (by Definition~\ref{def:unf}) by using the sequence
of the identified atoms in  with identifiers .
    \item\label{due}  if and only if one of the
following holds: \\
\begin{enumerate}
\item\label{ai} either there exist  and
     a built in constraint  such that
    , the constraint
     is satisfiable,
    ,  and\\
  \\
\item\label{bi} or there exist , a multiset of CHR constraints
     and
     a built in constraint  such that ,
    , the constraint
     is satisfiable, 
    and
    .\\
\end{enumerate}
\end{enumerate}
\end{definition}
Some explanations are in order here.

The set  contains all the couples composed by rules, that can be used to unfold a
fixed rule , and the identifiers of the constraints considered in the unfolding,
introduced in Definition \ref{def:unf}.

Let us consider now the set .
The conjunction of built-in constraints 
represents a generic set of built-in constraints
(said set naturally can be equal to every possible built-in constraint store that can
be generated by a real computation before the application of rule ); the
condition  is required to avoid free variable capture,
it represents the fresh variable rename of a rule  with respect to the computation
before the use of the  itself in an \textbf{Apply} transition;
the condition  grants the propagation rules
trivial non-termination avoidance;
the conditions  and
 secure that a strong enough built-in constraint
is possessed by the computation, before the application of rule ;
the conditions  and  assure respectively that
at least one constraint in the body of rule  and that at least
one constraint form the initial goal or introduced by the body of other rules are unfolded;
finally the following condition
 is required
to avoid the consideration of the rules that can be correctly unfolded in the body of .
There are two kinds of rules that are added to .
The first one, introduced by the Example \ref{ex:matching}, points out the
matching substitution problem (Condition \ref{ai} of Definition \ref{def:Pposeneg}).
The second kind, introduced by the Example \ref{ex:unicatesta}, points out the multiple
heads problem: the rule  can match with the body of  but can also match with
other constraints introduced by the initial goal or generated by other rules
(Condition \ref{bi} of Definition \ref{def:Pposeneg}).

Note also that if  contains a pair, whose first component is not
a rule with a single atom in the head, then by definition,
.


Finally, given an annotated CHR program  and an annotated rule
, we
define  as the set of all annotated rules obtained by unfolding
the rule  with a rule in , by using Definition~\ref{def:unf}.

We can now give the central definition of this section.

\begin{definition}\textsc{(Safe rule replacement)}\label{def:nsafedel}
Let  be an annotated CHR program and let , such that the following
holds
\begin{enumerate}
\item[i)]    and

\item[ii)]   and
\item[iii)] for each

we have that .
\end{enumerate}
Then we say that the rule 
can be safely replaced (by its unfolded version) in .
\end{definition}

Some explanations are in order here.

Condition  of previous definition implies that
 can be
safely deleted from  only if:
\begin{itemize}
\item  contains only pairs, whose
first component is a rule with a single atom in the head.

\item  a sequence of identified atoms of
body of the rule  can be used to fire a rule 
only if  can be unfolded with   by using the same sequence
of the identified atoms.

\end{itemize}

Condition {\bf ii)} states that exist at least one rule that unfold
the rule .

Condition {\bf iii)}  states that each annotated clause obtained by the
unfolding of  in  must have guard equivalent to that of : in fact
the condition   in {\bf iii)} avoids the
problems discussed in Example \ref{esempio:mau}, thus allows the anticipation
of the guard in the unfolded rule.


We can now provide the result which shows the correctness of the safe rule replacement condition.

\begin{proposition}\label{lemma:servcomplete}
Let  and  be annotated CHR rules such that the following holds
\begin{itemize}
  \item  is a rule with a single atom in the head
  \item (  is the result
of the unfolding of  with respect to ,  and the identified atom .
\end{itemize}
Moreover, let  be a generic built-in free state such that we can
construct a derivation  from  such that
\begin{itemize}
  \item  uses at most the clauses  and  in the order,
  \item obtain a built-in free state  and
  \item if  is used, then  rewrites the atom  corresponding to .
\end{itemize}
Then we can use the transition \textbf{Apply'} with the clause  obtaining the state  and then the built-in free state  such that .
\end{proposition}


\textsc{Proof.}
Assume that


The labeled arrow  means that only solve transitions are applied.
Moreover
\begin{itemize}
           \item if  has the form
 then the derivation between the parenthesis is not present and .
           \item the derivation between the parenthesis is present and , otherwise.
         \end{itemize}
We have two cases since the clause  is either of the form 
or of the form . We consider only the first case. The other one is analogous and hence it is omitted.


\noindent{\textbf{Preliminaries}:} Let   be a built-in free state
and let
 and

where ,  is the conjunction of all the built-in constraints in the body
of  and

Furthermore assume that  is the greatest identifier which appears in the
rule  and that .
Then the \emph{unfolded} rule is:

where ,
 is the greatest set of built-in constraints ,
such that

, the
constraint  is satisfiable and
 then .
 Since by hypothesis, , we have that
    
\noindent{\textbf{The proof}:} By definition of the transition \textbf{Apply'}, we have that

where  and

     where ,
      and
\begin{itemize}
    \item if  then 
    \item if  then .
    \end{itemize}
    Therefore, by definition
    
  where

On the other hand, by (\ref{110dic1}), (\ref{110dic2}) and
by definition of the transition \textbf{Apply'}, we have that

     where
     , with
      and
\begin{itemize}
    \item if  then 
    \item if  then .
    \end{itemize}
    Therefore, by definition
    
    where
    
Now, we have two possibilities
\begin{description}
  \item[().] In this case, by construction we have that . Therefore  and then the thesis.
  \item[().]
  By definition, since
, by (\ref{113marzo1}), (\ref{110dic2}) and (\ref{110dic1}), we have that

where . Therefore
by (\ref{13marzo21})


and since by hypothesis  rewrites the atom  corresponding to , we have that

     where
     , with
      and .

    Finally by definition, we have that

  where
  

  If  then the proof is analogous to the previous case and hence it is omitted.

  Otherwise, the proof is analogous to that given for Proposition \ref{prop:servequality} and hence it is omitted.
\end{description}
\noindent{}


\begin{theorem}\label{lemma:n1completeness}
Let  be an annotated program, \\  be a rule in  such that
 can be safely replaced
in  according to Definition \ref{def:nsafedel}. Assume also that


Then  for any arbitrary
goal .
\end{theorem}

\textsc{Proof.} By using a straightforward inductive argument and by
Proposition \ref{lemma:equality}, we have that
 where
 
for any arbitrary goal .

Then to prove the thesis, we have only to prove that

We prove the two inclusions separately.
\begin{description}
  \item[{\bf () }]
  The proof is by contradiction. Assume that there exists . By definition there exists a derivation
  
in , such that . Since , we have that there exists the derivation
 in . Moreover, since  and , we have that there exists a derivation step  by using the clause . \\
Since  can be safely replaced
in , we have that there exists  such that
. \\
Then there exists a derivation step  in  (by using the clause ) and then we have a contradiction.


  \item[{\bf () }]
  First of all, observe that by Proposition \ref{prop:solonorm},
   can be calculated by
considering only normal terminating derivations. \\
Moreover, since  by hypothesis
 can be safely replaced
in , following Definition \ref{def:nsafedel} (Safe rule replacement), we have that

and
 if and only if there exists a rule
      with a single atom in the head such that
 
and .\\
Then for each normal terminating derivation , which uses the clause  after the application of , we obtain the state  and then the built-in free state . Now, we have two cases

\begin{itemize}
\item either 
\item or . In this case, since by hypothesis
 can be safely replaced
in , following Definition \ref{def:nsafedel}, we have there exists an atom
, such that  is rewritten in  by using a clause ,
 and .
Without loss of generality we can assume that in the derivation , the clause  is applied to the considered state  (in order to rewrite the atom  corresponding to ).

\end{itemize}
In both the cases, the proof is straightforward, by using previous observations and by Proposition \ref{lemma:servcomplete}.
\end{description}

\noindent{}



Of course, previous result can be applied to a sequence of program transformations.
Let us define such a sequence as follows.

\begin{definition}[U-sequence]\label{def:uno}
Let  be an annotated CHR program. An \emph{U-sequence} of programs
starting from  is a sequence of annotated CHR programs , such that

 where ,  and   is
safety deleting from 
\end{definition}

Then from  Theorem~\ref{lemma:n1completeness} and
Proposition~\ref{lemma:nequality} we have immediately the
following.

\begin{corollary}\label{lemma:ncompleteness}
Let  be a program and let  be an U-sequence starting from . Then
 for any arbitrary goal
.
\end{corollary}

{\sc Proof.} Proposition~\ref{lemma:nequality} proves that , for every goal , where  .
Theorem \ref{lemma:n1completeness} proves that, for every goal  and for ,
. Then the proof follows by a straightforward inductive argument.
\\
\noindent{}


\section{Confluence and Termination}\label{sec:confluence&termination}

It is also possible to prove that our unfolding preserves normal termination and normal confluence.


The formal definition of termination from \cite{Fru04}
is introduced and adapted to our  semantics.

\begin{definition}[Termination]
A CHR program  is called \emph{terminating}, if there are no infinite computations.
\end{definition}

\begin{definition}[Normal Termination]
A (possibly annotated) CHR program  is called  \emph{normal terminating}, if there are no infinite normal computations.
\end{definition}

\begin{proposition}[Normal Termination]\label{prop:termination} Let  be a CHR program and
let  be an U-sequence starting from .  satisfies
normal termination if and only if   satisfies normal termination.
\end{proposition}
\textsc{Proof.}
By Lemma \ref{lemma:intermequiv}, we have that  is normal terminating if and only if  is normal terminating.
Moreover from Proposition \ref{prop:servequality} and Proposition \ref{lemma:servcomplete} and by using a straightforward inductive argument, we have that
for each , if  satisfies normal termination if and only if  satisfies the normal termination too and then the thesis.
\\
\noindent{} \\


When (standard) termination is considered instead of normal termination, program
transformation, defined in Definition \ref{def:uno} (U-sequence), can introduce
problems connected to the guard elimination process of Definition \ref{def:unf}
(Unfold) as showed in the following example.

\begin{example}
Let us consider the following program:

where we do not consider the identifiers and the token store in the
body of rules, because we do not have propagation rules in .
Then the following possible unfolded program , where the previous
 is unfolded using  (following Definition \ref{def:unf}) and where the
(original clause)  is deleted because safe rule replacement holds, so results of Theorem
\ref{lemma:n1completeness} can be applied, is given:

It is easy to check that the program  satisfies the (standard) termination.
If instead the program  and the start goal  are
considered, the following state can be reached

where  (in the order) can be applied infinite times if the built-in constraint 
is not moved by \textbf{Solve'} rule into the built-in store, where it would be
evaluated. This can happen because of the non determinism in rule application of
 semantics.
\end{example}

The confluence property guarantees that any computation for a goal
results in the same final state, no matter which of the applicable
rules are applied \cite{AF04}. This means that  has
cardinality  at the most one for each goal .
The formal definition of confluence from \cite{Fru04}
is introduced and adapted to our  semantics.
Confluence is considered only for normal terminating programs and in this case  has
cardinality exactly one for each goal .
In the following  means either  or .


\begin{definition}[Confluence]
A CHR [annotated] program is \emph{confluent} if for all states
:
if  and  then exist states 
and  such that  and  and
 and  are identical up to renaming of local variables,
identifiers and logical equivalence of built-in constraints.
\end{definition}

We now introduce the concept of normal confluence.


\begin{definition}
Let
 and let  be a set of variables.  if the following holds:
\begin{itemize}
  \item either  and  are both failed configurations
  \item or  and  are identical up to renaming of variables not in ,
identifiers, up to cleaning the token store (namely, up to deleting from the token store all the tokens for
which at least one identifier is not present in the set of
identified CHR constraints) and logical equivalence of built-in constraints.
\end{itemize}
\end{definition}




\begin{definition}[Normal Confluence]
A CHR [annotated] program is \emph{normal confluent} if for all states
:
if there exist two normal derivations  and  then  and , where .
\end{definition}


Observe that, by definition, if a CHR [annotated] program is confluent, then it is normal confluent.


\begin{lemma}\label{relrel}
Let  be final configurations in ,  and let  be a set of variables.
\begin{itemize}
  \item If ,  then   if and only if .
  \item If ,  and   then .
\end{itemize}
\end{lemma}
\textsc{Proof.}
The proof of the first statement follows by definition of  and by observing that if  is a final configuration in , then 
has either the form   or it
has the form .

The proof of the second statement is straightforward, by observing that if , then
 for each set of variables .




\begin{lemma}\label{conflnorm}
Let  be a CHR [annotated] program.  is normal confluent if for all states
:
if there exist two normal derivations  and  then there exists two normal derivations  and  such that .
\end{lemma}
\textsc{Proof.}
 In the following we assume that  is a CHR annotated program.
If  is a standard CHR program, the proof is analogous and hence it is omitted.


The proof is by contradiction.
Assume that  is normal confluent and there exists the states
 such that there exists  two normal derivations  and  such that there are no two normal derivations  and  such that
.
Since  is normal confluent, there exists two built-in free states  and  such that  and  and
.

Let  () be the built-in free state obtained from  () by evaluating all the built-in constraints in  (). Since  it is easy to check that .

Now, we have two possibilities
\begin{itemize}
  \item  and . In this case, it is easy to check that there exists two normal derivation  and  obtained form  and  by evaluating the built-in constraints as soon as possible.
  \item  and . In this case, we that there exists two normal derivations, such that  and
      ,
      where
      
 \end{itemize}
In both the case, by definition of , we have a contradiction to the hypothesis that there are no two normal derivations  and  such that
 and then the thesis.

\noindent{}

The following Lemma is a straightforward consequence of the previous one.

\begin{lemma}\label{conflnormterm}
Let  be a CHR [annotated] normal terminating program. If  is not normal confluent there exist a state
 and two normal derivations  and  such that
.
\end{lemma}
\textsc{Proof.}
Assume that  is not normal confluent. By Lemma \ref{conflnorm},
there exist the states
 such that
there exist two normal derivations  and  and there are no two normal derivations  and  in  such that .


Since  is normal terminating, there are two normal derivations

in . By previous observation, we have that  and then the thesis.

\noindent{}



\begin{corollary}[Normal Confluence] Let  be a normal terminating CHR program and let 
be an U-sequence starting from .  satisfies normal confluence if and only if 
satisfies normal confluence too.
\end{corollary}
\textsc{Proof.}
\begin{itemize}
  \item Assume that  is a normal terminating CHR program and that  satisfies normal confluence. We prove that 
satisfies normal confluence too.
First of all, observe, that by hypothesis and by Proposition \ref{prop:termination}, we have that  is normal terminating.


Let us assume by contrary that  does not satisfy normal confluence.
By Lemma \ref{conflnormterm},  there exists a state  and two normal derivations  and  in  such that
.

Then, by using arguments similar to that given in Proposition \ref{prop:servequality}, we have that there exist two normal derivations

in , where
 and .

Therefore,by  Proposition~\ref{lemma:nequality}  there exist two normal derivations

in , where
,  and . Since  by hypothesis  is normal confluent, we have that  and therefore, by Lemma \ref{relrel} we have a contradiction to the fact that  and then the thesis.



  \item Assume that  is a normal terminating CHR program and that  satisfies normal confluence. The proof that 
satisfies normal confluence is analogous to the previous one, by using Proposition \ref{lemma:servcomplete} instead of Proposition \ref{prop:servequality}.
\end{itemize}

\noindent{}


\section{Weak safe rule replacement}
In this subsection we consider only normal terminating and normal confluent programs and we give a weaker condition in order to safely replace the original rule  by its unfolded version while maintaining the qualified answers semantics. Intuitively this holds when there exists a rule obtained by the unfolding of  in  whose guard is equivalent to that of .

\begin{definition}\textsc{(Weak safe rule replacement)}\label{def:wsafedel}
Let  be an annotated CHR program and let , such that there exists

with .


Then we say that the rule 
can be weakly safe replaced (by its unfolded version) in .
\end{definition}

\begin{definition}[WU-sequence]\label{def:wuno}
Let  be an annotated CHR program. An \emph{WU-sequence} of programs
starting from  is a sequence of annotated CHR programs , such that

 where ,  and   is
weakly safety deleting from .
\end{definition}

\begin{proposition}\label{prop:wterm}
Let  be an annotated CHR program and let  such that 
can be weakly safe replaced (by its unfolded version) in . Moreover let


    If  is normal terminating and normal confluent then   is normal terminating and normal confluent too.
\end{proposition}
\textsc{Proof.}
First, we prove that if  is normal terminating and normal confluent then   is normal terminating and normal confluent too, where

   Then we prove that if  is normal terminating and
   normal confluent then  is normal terminating and normal confluent and then the thesis.
\begin{itemize}
   \item Assume that  is normal terminating.
  The proof of the normal termination of  follows by Proposition \ref{prop:servequality}.

   \item Now, assume that  is normal terminating and normal confluent and by the contrary that  does not satisfy normal confluence.


       By Lemma \ref{conflnormterm} and since by previous result  is normal terminating, there exist a state
 and two normal derivations
 in 
such that
.


Then, by using arguments similar to that given in Proposition \ref{prop:servequality} and since , we have that there exist two normal derivations

in , where
  and . Since by hypothesis  is normal confluent, we have that .
  Therefore, by Lemma \ref{relrel} we have a contradiction to the assumption that there exist two states  and  as previously defined.
 \end{itemize}


 \noindent Now, we prove that if  is normal terminating and normal confluent then  is normal terminating and normal confluent too and then the thesis.
 \begin{itemize}
   \item If  is normal terminating then, since , we have that
   is normal terminating too.
   \item Now, assume that  is normal terminating and normal confluent and  by the contrary that  does not satisfy normal confluence. By Lemma \ref{conflnormterm} and since by previous result  is normal terminating, there exist a state
 and two normal derivations

 in  such that
.


Since , we have that there exist two normal derivations

in . Then, since  is normal confluent and  there exists  such that
 in  by using the clause . In this case, by definition of weakly safe replacement, there exists

with . Therefore  in  by using the clause  and then we have a contradiction.
 \end{itemize}

\noindent{}

\begin{theorem}\label{prop:wqualified}
Let  be a normal terminating and normal confluent annotated program and let  be a rule in  such that
 can be weakly safely replaced
in  according to Definition \ref{def:wsafedel}. Assume also that


Then  for any arbitrary
goal .
\end{theorem}

\textsc{Proof.} Analogously to Theorem \ref{lemma:n1completeness}, we can prove that
 where
 
for any arbitrary goal .

Then to prove the thesis, we have only to prove that

We prove the two inclusions separately.
\begin{description}
  \item[{\bf () }]
  The proof is the same of the case  of Theorem \ref{lemma:n1completeness} and hence it is omitted.


  \item[{\bf () }]
  The proof is by contradiction. Assume that there exists . Since  is normal terminating and normal confluent and since by previous point
  , we have that .
  This means that each normal derivation in  is not terminating and hence, by using Proposition \ref{prop:wterm}, we have a contradiction.

\end{description}
\noindent{}

\begin{corollary}\label{lemma:wcompleteness}
 Let  be a normal terminating and normal confluent program and let  be an WU-sequence starting from                                                 . Then
 for any arbitrary goal
.
\end{corollary}

{\sc Proof.} We prove by induction on , that for each ,  is a normal terminating and normal confluent program and that  for any arbitrary goal
.
\begin{description}
  \item[)] Proposition~\ref{lemma:nequality} proves that the qualified answer for
a program  and its annotated version , fixed a start goal, is the same. Moreover, by using Proposition~\ref{lemma:nequality} it is easy to check that if  is normal terminating and normal confluent, then  is normal terminating and normal confluent.
  \item[)] Assume that the thesis holds for , namely  is a normal terminating and normal confluent program and that  for any arbitrary goal
. Then, by using Proposition \ref{prop:wterm}, we have that  is a normal terminating and normal confluent program. Moreover by Theorem \ref{prop:wqualified} we have that  Therefore by inductive hypothesis  and then the thesis.
\end{description}



\section{Conclusions}\label{sec:conclusion_and_future}

In this paper we have defined an unfold operation for CHR which preserves the qualified answers of a program.

This was obtained by transforming a CHR program into an
annotated one which is then unfolded. The equivalence of the unfolded
program and the original (non annotated) one is proven (Proposition~\ref{lemma:nequality}),
by using  a slightly modified operational
semantics for annotated programs (as defined in Section~\ref{sec:semantics}).
We then provided a condition that could be used to safely replace a
rule with its unfolded version, whilst simultaneously preserving qualified answers, for a
restricted class of rules. Confluence and termination maintenance of
the program modified in the previous way are proven.

There are only few other papers that consider source to source transformation
of CHR programs. \cite{Fru04}, rather than considering a generic transformation
system focuses on the specialization of rules regarding a specific goal, analogously
to what happens in partial evaluation. In \cite{FH03}, CHR rules are transformed
in a relational normal form, over which a source to source transformation is performed.
However, the correctness of such a transformation was not proven. Some form of
transformation for probabilistic CHR is considered in \cite{FDPW02}, while
guard optimization was studied in \cite{SSD05b}.

Both the general and the goal specific approaches are important in order
to define practical transformation systems for CHR. In fact, on the
one hand of course one needs some general unfold rule, on the other
hand, given the difficulties in removing rules from the transformed
program, some goal specific techniques can help to improve the
efficiency of the transformed program for specific classes of
goals. A method for deleting redundant CHR rules is considered
in \cite{AF04}. However it is based on a semantic check and it
is not clear whether it can be transformed into a specific syntactic
program transformation rule.

When considering more generally the field of concurrent logic
languages, we find a few papers which address the issue of program
transformation. Notable examples include  \cite{EGM01} that deals with
the transformation of  concurrent constraint programming (ccp) and
\cite{UF88} that considers Guarded Horn Clauses (GHC).  The
results in these papers are not directly applicable to CHR  because
neither ccp not GHC allow rules with  multiple heads.

The third section of this paper can be considered as a first step
in the direction of defining a transformation system for CHR programs,
based on unfolding. This step could be improved in several directions.
First of all, the unfolding operation could be extended to also take
into consideration the constraints in the propagation part of the head
of a rule instead of only the body ones.
In addition, the condition that we have provided for safely
replacing a rule could be generalized to include more cases.
Also, we could extend to CHR some of the other transformations,
notably folding, which have been defined  in \cite{EGM01} for ccp.
Finally, we would like to investigate from a practical perspective
to what extent program transformation can improve the
performances of the CHR solver. Clearly the application of an
unfolded rule avoids some computational steps assuming of course that
unfolding is done at the time of compilation, even though the
increase in the number of rules could eliminate this improvement
when the original rule cannot be removed.
Here it would probably be important to consider some unfolding
strategy, in order to decide which rules have to be unfolded.

\bibliographystyle{acmtrans}
\begin{thebibliography}{}

\bibitem[\protect\citeauthoryear{Abdennadher}{Abdennadher}{1997}]{Abd97} {\sc Abdennadher, S.} 1997.
\newblock Operational semantics and confluence of constraint propagation rules.
\newblock In Proc. of the {\em Third Int'l Conf. on
Principles and Practice of Constraint Programming (CP 97)},
Lecture Notes in Computer Science 1330. Springer-Verlag.


\bibitem[\protect\citeauthoryear{Abdennadher and Fr\"uhwirth}{Abdennadher and Fr\"uhwirth}{2003}]{AF04}
 {\sc Abdennadher, S.} {\sc and} {\sc Fr\"uhwirth, T.}  2003.
\newblock Integration and optimization of rule-based constraint solvers. \newblock In Proc. of the  {\em 13th International Symposium on  Logic Based Program Synthesis and
        Transformation (LOPSTR 2003)}, LNCS, pages 198--231. Springer-Verlag.


\bibitem[\protect\citeauthoryear{Burstall and Darlington}{Burstall and Darlington}{1977}]{BD77}
 {\sc Burstall, R.~M.} {\sc and} {\sc Darlington, J.}  1977.
\newblock A Transformation System for Developing Recursive Programs.
\newblock {\em Journal of the ACM (JACM)}, 1(24):44-67.


\bibitem[\protect\citeauthoryear{Duck, Stuckey, de~la~Banda, and Holzbaur}{Duck  et~al\mbox{.}}{2004}]{DSGH04}
{\sc Duck, G.~J.}, {\sc
Stuckey, P.~J.}, {\sc de~la~Banda, M.~G.}, {\sc and}  {\sc Holzbaur, C.} 2004.
\newblock The Refined Operational Semantics of Constraint Handling Rules.
\newblock In Proc. of  the {\em  20th
International Conference on Logic Programming, (ICLP'04)}, pages 90--104.



\bibitem[\protect\citeauthoryear{Etalle, Gabbrielli, and Meo}{Etalle  et~al\mbox{.}}{2001}]{EGM01}
{\sc Etalle, S.}, {\sc Gabbrielli, G.}, {\sc and}  {\sc Meo, M.~C.} 2001.
\newblock Transformations of ccp programs.
\newblock {\em ACM Trans. Program. Lang. Syst.}, 23(3):304--395.

\bibitem[\protect\citeauthoryear{Fr\"uhwirth}{Fr\"uhwirth}{1998}]{Fru98}
{\sc Fr\"uhwirth, T.} 1998.
\newblock Theory and practice of Constraint Handling Rules.
\newblock {\em Journal of Logic Programming}, 37(1-3):95--138.

\bibitem[\protect\citeauthoryear{Fr\"uhwirth}{Fr\"uhwirth}{2004}]{Fru04}
{\sc Fr\"uhwirth, T.} 2004.
\newblock Specialization of concurrent guarded multi-set transformation rules.
\newblock In Proc. of the  {\em 14th International Symposium on  Logic Based Program Synthesis and
  Transformation (LOPSTR)}, LNCS, pages 133 -- 148.

\bibitem[\protect\citeauthoryear{Fr\"uhwirth}{Fr\"uhwirth}{2006}]{Fru06}
{\sc Fr\"uhwirth, T.} 2006.
  \newblock Constraint Handling Rules: The Story So Far.
  \newblock In Proc. of the {\em 8th ACM SIGPLAN symposium on Principles and practice of declarative
  programming (PPDP '06)} ACM, pages 13--14.


\bibitem[\protect\citeauthoryear{Fr\"uhwirth}{Fr\"uhwirth and Abdennadher}{2003}]{FA03}
{\sc Fr\"uhwirth, T.} {\sc and} {\sc
Abdennadher, S.} 2003.
\newblock {\em Essentials of Constraint Programming}.
\newblock Springer.

\bibitem[\protect\citeauthoryear{Fr{\"u}hwirth, Di~Pierro, and Wiklicky}{Fr{\"u}hwirth  et~al\mbox{.}}{2002}]{FDPW02}
{\sc Fr{\"u}hwirth, T.}, {\sc Di~Pierro, A.}, {\sc and}  {\sc Wiklicky, H.} 2002.
\newblock Probabilistic Constraint Handling Rules.
\newblock \emph{11th International Workshop on Functional and (Constraint) Logic Programming (WFLP 2002)}
\newblock Selected Papers. Vol. 76 of \emph{Electronic Notes in Theoretical Computer Science (ENTCS)}.

\bibitem[\protect\citeauthoryear{Fr\"uhwirth and Holzbaur}{Fr\"uhwirth and Holzbaur}{2003}]{FH03}
{\sc Fr\"uhwirth, T.} {\sc and} {\sc Holzbaur, C.}  2003.
\newblock Source-to-Source Tranformation for a Class of Expressive Rules.
\newblock \emph{APPIA-GULP-PRODE 2003 (AGP 2003)}.

\bibitem[\protect\citeauthoryear{Holzbaur, de~la~Banda, Jeffery, and Stuckey}{Holzbaur  et~al\mbox{.}}{2001}]{HGdlBJS01}
{\sc Holzbaur, C.}, {\sc de~la~Banda, M.~G.},  {\sc Jeffery, D.}, {\sc and} {\sc
Stuckey, P.~J.} 2001.
\newblock Optimizing Compilation of Constraint Handling Rules.
\newblock In Proc. of the 17th International Conference on Logic Programming, pages 74 -- 89, LNCS 2237, Springer Verlag.

\bibitem[\protect\citeauthoryear{Mart\'{\i}n-S\'{a}nchez and Pareja-Flores}{Mart\'{\i}n-S\'{a}nchez and Pareja-Flores}{1995}]{SP95}
{\sc Mart\'{\i}n-S\'{a}nchez, \'{O}.} {\sc and} {\sc Pareja-Flores, C.}  1995.
 \newblock A gentle introduction to algorithm complexity for CS1 with nine variations on a theme by Fibonacci.
\newblock {\em SIGCSE Bull. ACM} 27(2):49--56.


\bibitem[\protect\citeauthoryear{Sneyers, Schrijvers, and Demoen}{Sneyers  et~al\mbox{.}}{2005}]{SSD05b}
{\sc Sneyers, J.}, {\sc Schrijvers, T.}, {\sc and}  {\sc Demoen, B.} 2005.
 \newblock Guard and continuation optimization for occurrence representations of CHR, Logic Programming.
 \newblock In Proc. of the {\em 21st International Conference, ICLP 2005} LNCS 3668, pages 83--79. Springer.

\bibitem[\protect\citeauthoryear{Sneyers, Schrijvers, and Demoen}{Sneyers  et~al\mbox{.}}{2008}]{SSD05d}
{\sc Sneyers, J.}, {\sc Schrijvers, T.}, {\sc and}  {\sc Demoen, B.} 2008.
 \newblock The Computational Power and Complexity of Constraint Handling Rules.
 \newblock {\em TOPLAS} ACM, to appear.

\bibitem[\protect\citeauthoryear{Tamaki and Sato}{Tamaki and Sato}{1984}]{TS84}
{\sc Tamaki, H.} {\sc and} {\sc Sato, T.}  1984.
\newblock {U}nfold/{F}old transformations of logic programs.
\newblock In Proc. of the {\em  {I}nternational {C}onference on {L}ogic
  {P}rogramming}, pages 127--138.

\bibitem[\protect\citeauthoryear{Ueda and Furukawa}{Ueda and Furukawa}{1988}]{UF88}
{\sc Ueda, K.} {\sc and} {\sc Furukawa, K.}  1988.
\newblock Transformation rules for {GHC} programs.
\newblock In Proc. of the {\em Int. Conf. on Fifth Generation Computer Systems 1988
  {(FGCS'88})}, pages 582--591.

\end{thebibliography}
\end{document}
