\documentclass{llncs}




\usepackage{graphicx}

\usepackage{amsmath}


\newcommand{\comment}[1]{}

\newcommand{\shortdividerline}{
\begin{center} \line(1,0){150} \end{center}
}
\newcommand{\dividerline}{\begin{center}\hrule\end{center}}
\newcommand{\fillbox}{\hspace*{\fill}}

\usepackage{graphicx}
\usepackage{latexsym}




\newcommand{\BSB}{{\em Broadcast\_Single\_Bit~}}
\newcommand{\DG}{{\em Diag\_Graph~}}
\newcommand{\TRUE}{{\bf true~}}
\newcommand{\FALSE}{{\bf false~}}




\newcommand{\nchoosek}[2]{{#1 \choose #2}}

\newcommand{\scriptf}{\mathcal{F}}
\newcommand{\scripte}{\mathcal{E}}
\newcommand{\scriptv}{\mathcal{V}}
\newcommand{\scriptl}{\mathcal{L}}
\newcommand{\scripts}{\mathcal{S}}
\newcommand{\graphh}{\textit{H}}


\newcommand{\bfA}{{\bf A}}
\newcommand{\bfH}{{\bf H}}
\newcommand{\bfQ}{{\bf Q}}
\newcommand{\bfM}{{\bf M}}
\newcommand{\bfv}{v}

\newcommand{\matrixm}{\textbf{M}}
\newcommand{\matrixh}{\textbf{H}}



\newcommand{\BlackBox}{\rule{2.6mm}{2.6mm}}


\begin{document}

\title{Iterative Approximate Consensus in the presence of Byzantine Link Failures
\thanks{\normalsize This research is supported in part by National Science Foundation award CNS 1329681. Any opinions, findings, and conclusions or recommendations expressed here are those of the authors and do not necessarily reflect the views of the funding agencies or the U.S. government.}}




\author{Lewis Tseng, and Nitin Vaidya}

\institute{ \normalsize  Department of Computer Science,\\
 \normalsize  Department of Electrical and Computer Engineering,
 and\\ \normalsize University of Illinois at Urbana-Champaign\\ \normalsize Email: \{ltseng3, nhv\}@illinois.edu\\~\\~\\~Technical Report} 




\maketitle

\begin{abstract}{\normalfont
This paper explores the problem of reaching approximate consensus in synchronous point-to-point networks, where each directed link of the underlying communication graph represents a communication channel between a pair of nodes. We adopt the {\em transient Byzantine link} failure model \cite{Santoro_link,Santoro_link2}, where an omniscient adversary controls a subset of the {\em directed} communication links, but the nodes are assumed to be {\em fault-free}.

~

Recent work has addressed the problem of reaching approximate consensus in incomplete graphs with Byzantine {\em nodes} using a {\em restricted class} of iterative algorithms that maintain only a small amount of memory across iterations \cite{vaidya_PODC12,Tseng_general,vaidya_icdcn14,Sundaram_condition}. However, to the best of our knowledge, we are the first to consider approximate consensus in the presence of Byzantine {\em links}. We extend our past work that provided exact characterization of graphs in which the iterative approximate consensus problem in the presence of Byzantine {\em node} failures is solvable \cite{vaidya_PODC12,Tseng_general}. In particular, we prove a {\em tight} necessary and sufficient condition on the underlying communication graph for the existence of iterative approximate consensus algorithms under {\em transient Byzantine link} model. The condition answers (part of) the open problem stated in \cite{Santoro_link2}.
}
\end{abstract}











\section{Introduction}
\label{s_intro}
Approximate consensus can be related to many distributed computations in networked systems, such as data aggregation \cite{Kempe_gossip}, decentralized estimation  \cite{noisy_link}, and flocking \cite{Jadbabaie}. Extensive work has addressed the problem in the presence of {\em Byzantine nodes} \cite{psl_BG_1982} in either complete networks \cite{AA_Dolev_1986,AA_optimal} or arbitrary directed networks \cite{vaidya_PODC12,Sundaram_condition,Tseng_general}. As observed in \cite{Biely_hybrid,Schmid_link}, link failures become more and more prevalent. Thus, it is of interest to consider the problem of approximate consensus in the presence of Byzantine {\em link} failures.

This paper explores such problem in synchronous point-to-point networks, where each directed link of the underlying communication graph represents a communication channel between a pair of nodes. The link failures are modeled using a {\em transient Byzantine link} failure model (formal definition in Section \ref{s_models}) \cite{Santoro_link,Santoro_link2}, in which different sets of link failures may occur at different time. We consider the problem in arbitrary directed graphs using a {\em restricted class} of iterative algorithms that maintain only a small amount of memory across iterations, e.g., the algorithms do not require the knowledge of the network topology. Such iterative algorithms are of interest in networked systems, since they have low complexity and do not rely on global knowledge \cite{Sundaram_condition}. In particular, the iterative algorithms have the following properties, which we will state more formally later:

\begin{itemize}
\item {\bf Initial state} of each node is equal to a real-valued {\em input} provided to that node.

\item {\bf Termination}: The algorithm terminates in finite number of iterations.

\item {\bf Validity}: After each iteration of the algorithm, the state of each node must stay in the {\em convex hull} of the states of all the nodes at the end of the {\em previous} iteration.

\item {\bf -agreement}: For any , when the algorithm terminates, the difference between any pair of nodes is guaranteed to be within .
\end{itemize}


\paragraph{Main Contribution}

This paper extends our recent work on approximate consensus under node failures \cite{vaidya_PODC12,Tseng_general}. The main contribution is identifying a {\em tight} necessary and sufficient condition for the graphs to be able to reach approximate consensus under {\em transient Byzantine link} failure models \cite{Santoro_link,Santoro_link2} using restricted iterative algorithms; our proof of correctness follows a structure previously used in our work to prove correctness of other consensus algorithms in incomplete networks \cite{Tseng_general,vaidya_icdcn14}. The use of matrix analysis is inspired by the prior work on non-fault-tolerant consensus (e.g., \cite{Jadbabaie,AA_convergence_markov}).



\paragraph{Related Work}

Approximate consensus has been studied extensively in synchronous as well as asynchronous systems. Bertsekas and Tsitsiklis explored reaching approximate consensus without failures in synchronous dynamic network, where the underlying communication graph is time-varying \cite{AA_convergence_markov}. Dolev et al. considered approximate consensus in the presence of {\em Byzantine nodes} in both synchronous and asynchronous systems \cite{AA_Dolev_1986}, where the network is assumed to be a clique, i.e., a complete network. Subsequently, for complete graphs, Abraham et al. proposed an algorithm to achieve approximate consensus with {\em Byzantine nodes} in asynchronous systems using optimal number of nodes \cite{AA_optimal}. 

Recent work has addressed approximate consensus in incomplete graphs with faulty {\em nodes} \cite{vaidya_PODC12,Sundaram_condition,Tseng_general}. \cite{vaidya_PODC12,Tseng_general} and \cite{Sundaram_condition} showed exact characterizations of graphs in which the approximate consensus problem is solvable in the presence of Byzantine nodes and malicious nodes, respectively. Malicious node is a restricted type of Byzantine node in which every node is forced to send the identical message to all of its neighbors. 

Much effort has also been devoted to the problem of achieving consensus in the presence of link failures \cite{HeardOf,Biely_hybrid,Schmid_link,Santoro_link,Santoro_link2}. Charron-Bost and Schiper proposed a HO (Heard-Of) model that captures both the link and node failures at the same time \cite{HeardOf}. However, the failures are assumed to be benign in the sense that no corrupted message will ever be received in the network. Santoro and Widmayer proposed the {\em transient} Byzantine link failure model: a different set of links can be faulty at different time \cite{Santoro_link,Santoro_link2}. They characterized a necessary condition and a sufficient condition for undirected networks to achieve consensus in the transient link failure model; however, the conditions are {\em not} tight (i.e., do not match): necessary and sufficient conditions are specified in terms of node degree and edge-connectivity,\footnote{A graph  is said to be -edge connected, if  is connected for all  such that .} respectively. Subsequently, Biely et al. proposed another link failure model that imposes an upper bound on the number of faulty links incident to each node \cite{Biely_hybrid}. As a result, it is possible to tolerate  link failures with  nodes in the new model. Under this model, Schmid et al. proved lower bounds on number of nodes, and number of rounds for achieving consensus \cite{Schmid_link}. However, incomplete graphs were not considered in \cite{Biely_hybrid,Schmid_link}.

For consensus problem, it has been shown in \cite{impossible} and \cite{Santoro_link2}, respectively, that an undirected graph of  node-connectivity\footnote{A graph  is said to be -node connected, if  is connected for all  such that .} and edge-connectivity is able to tolerate  Byzantine nodes and  Byzantine links. Independently, researchers showed that  node-connectivity is both necessary and sufficient for the problem of information dissemination in the presence of either  faulty nodes \cite{SS_node} or  {\em fixed} faulty links \cite{SS_link}.\footnote{Unlike the ``transient" failures in our model, the faulty links are assumed to be fixed throughout the execution of the algorithm in \cite{SS_link}.} However, both node-connectivity and edge-connectivity are not adequate for our problem as illustrated in Section \ref{sec:iacbl}. 

Link failures have also been addressed under other contexts, such as distributed method for wireless control network \cite{control}, reliable transmission over packet network \cite{packet}, or estimation over noisy links \cite{noisy_link}.

\section{System Model}
\label{s_models}


{\em Communication model:}
The system is assumed to be {\em synchronous}. The communication network is modeled as a simple {\em directed} graph , where  is the set of  nodes, and  is the set of directed edges between the nodes in .
With a slight abuse of terminology, we will use the terms {\em edge}
and {\em link} interchangeably in our presentation.
In simple graph, there is at most one directed edge from any node  to some other node  (But our results can be extended to multi-graph).
We assume that , since the consensus problem for  is trivial.
Node  can reliably transmit messages to node  if and only if
the directed edge  is in .
Each node can send messages to itself as well; however,
for convenience, we exclude {\em self-loops} from set .
That is,  for .




For each node , let  be the set of nodes from which  has incoming edges.
That is, .
Similarly, define  as the set of nodes to which node 
has outgoing edges. That is, .
Since we exclude self-loops from ,
 and . 
However, we note again that each node can indeed send messages to itself. Similarly, let  be the set of incoming links incident to node . That is,  contains all the links from nodes in  to node , i.e., .\\


{\em Failure Model:}
We consider the transient Byzantine {\em link} failure model \cite{Santoro_link,Santoro_link2} for iterative algorithms in directed network. All nodes are assumed to be {\em fault-free}, and only send a single message once in each iteration. 
A link  is said to be faulty if the message sent by node  is different from the message received by node  in some iteration. Note that in our model, it is possible that link  is faulty while link  is fault-free.\footnote{For example, the described case is possible in wireless network, if node 's transmitter is broken while node 's receiver and node 's transmitter and receiver all function correctly.} In every iteration, up to  links may be faulty, at most  links may deliver incorrect message or drop message. Note that different sets of link failures may occur in different iterations.

A faulty link may tamper or drop messages. Also, the faulty links may be controlled by a single omniscient adversary. That is, the adversary is assumed to have a complete knowledge of the execution of
the algorithm, including the states of all the nodes,
contents of messages the other nodes send to each other,
the algorithm specification, and the network topology. 





\section{IABC Algorithms and Example Network}
\label{sec:iacbl}

In this section, we describe the structure of the
{\em Iterative Approximate Byzantine Consensus} (IABC) algorithms of interest, and state conditions that they must satisfy. The IABC structure is identical to the one in our prior work on node failures \cite{vaidya_PODC12,Tseng_general,vaidya_icdcn14}.

Each node  maintains state , with  denoting the state
of node  at the {\em end}\, of the -th iteration of the algorithm ().
Initial state of node , , is equal to the initial {\em input}\, provided to node . At the {\em start} of the -th iteration (), the state of
node  is . We assume that the input at each node is lower bounded by a constant  and upper bounded by a constant . The
iterative algorithm may terminate after a number of iterations that is a function of  and .  and  are assumed to be known a priori. 

The IABC algorithms of interest will require each node 
to perform the following three steps in iteration , where .
Note that the message sent via faulty links may deviate from this specification.

\begin{enumerate}
\item {\em Transmit step:} Transmit current state, namely , on all outgoing edges
 (to nodes in ).

\item {\em Receive step:} Receive values on all incoming edges (from nodes in ). 
Denote by  the vector of values received by node  from its
neighbors. The size of vector  is . The values sent in iteration  are received in the same iteration (unless dropped by the faulty links).

\item {\em Update step:} Node  updates its state using a transition function  as
follows.  is a part of the specification of the algorithm, and takes
as input the vector  and state .




\end{enumerate}

~

The following properties must be satisfied by an IABC algorithm
in the presence of up to  Byzantine faulty links:
\begin{itemize}
\item {\bf Termination}: the algorithm terminates in finite number of iterations.\\

\item {\bf Validity:} 
 and \\
.\\

\item {\bf -agreement:} If the algorithm terminates after  iterations, then .
\end{itemize}
The objective in this paper is to identify the necessary and sufficient
conditions for the existence of a {\em correct} IABC algorithm (i.e.,
an algorithm satisfying the above properties) for a given .




\paragraph{Example Network}

We give an example showing that node- and edge-connectivity are not adequate for specifying the {\em tight} condition in directed graphs. Consider the case when  in the network in Figure \ref{f:eg}. In the network, nodes  form a clique, while node  has only incoming edges from nodes . It is obvious that the node- and edge-connectivity of the network are less than , since node  does not have any outgoing links to any other node. However, the approximate consensus is solvable using IABC algorithms under one (directed) faulty link, since the network satisfies the sufficient condition proved later. The proof is presented in \ref{a:example}. Therefore,  node- and edge-connectivity are not necessary for the existence of IABC algorithms.

\begin{figure}[hbt!]
\centering
\includegraphics[width=5cm]{example.jpg}
\vspace*{-10pt}
\caption{Example Network}
\label{f:eg}
\end{figure}


\section{Necessary Condition}
\label{s_necessary}





For a correct iterative approximate consensus algorithm to exists in the presence of Byzantine link failures, the graph  must satisfy the necessary condition proved in this section.
We now define relations 
and  that are used frequently in our proofs.

\begin{definition}
\label{def:absorb}
For non-empty disjoint sets of nodes  and  in ,  iff there exists a node  that has at least  incoming links from nodes in , i.e., ;  iff  is {\em not} true.






\end{definition}

~

\noindent {\em Condition P}~: Consider graph . Denote by  a subset of  such that .
Let sets  form a partition of , such that
both  and  are non-empty. Then, in , at least one of the two conditions below must be true: (i) ; (ii) .


\begin{theorem}
\label{thm:nc}
Suppose that a correct IABC algorithm exists for . Then  satisfies {\em Condition P}.
\end{theorem}
\begin{proof}



The proof is by contradiction.
Let us assume that a correct IABC algorithm exists,
and for some node partition  and a subset  such that ,  and  in .
Thus, for any , . Similarly,
for any  , .



Also assume that the links in  (if  is non-empty) all behave faulty, and the rest of the links are all fault-free in every iteration. Note that the nodes are not aware of the identity of the faulty links.

Consider the case when (i) each node in  has initial input , (ii) each
node in  has initial input , such that ,
and (iii) each node in , if  is non-empty,
has an input in the interval . Define  and  such that .

In the {\em Transmit Step} of iteration 1, each node , sends to nodes in  value ; however, some values sent via faulty links may be tampered. Suppose that the faulty links in  (if non-empty) tamper the messages sent via them in the following way (i) if the link is an incoming link to a node in , then  is deliver to that node;
(ii) if the link is an incoming link to a node in , then  is deliver to that node; and (iii) if the link is an incoming link to a node in , then some arbitrary value in interval  is deliver to that node. This behavior is possible since links in  are Byzantine faulty by assumption. Note that . 

Consider any node . Recall that  the set of all the node 's incoming links. Let  be the subset of  that are incident to nodes in , i.e., 



Since , .
Moreover, by assumption ; thus, .
Node  will then receive  via the links in  (if non-empty)
and values in  via the links in , and
 via the rest of the links, i.e., links in .

Consider the following two cases:
\begin{itemize}

\item Both  and  are non-empty:

In this case, recall that  and .
From node 's perspective, consider two possible scenarios:
(a) links in  are faulty, and the other
links are fault-free, and (b) links in  are faulty, and the
other links are fault-free.

In scenario (a), from node 's perspective, all the nodes may have sent values
in interval , but the faulty links have delivered  to node . According to the validity
property, . On the other hand, in scenario (b), all the
nodes may have sent values  or , where ; so , according to
the validity property. Since node  does not know whether the
correct scenario is (a) or (b), it must update its state to satisfy the
validity property in both cases. Thus, it follows that .

\item
At most one of  and  is non-empty: 

Recall that by assumption,  and . Since at most one of the set is non-empty, 
.
From node 's perspective,
it is possible that the links in  are all faulty,
and the rest of the links are fault-free. 
In this situation, the values sent to node  via all the fault-free links are all , and therefore,  must be set to 
as per the validity property.

\end{itemize}
Thus,  for each node .
Similarly, we can show that  for each node .

Now consider the nodes in set , if  is non-empty.
All the values received by the nodes in  are in , therefore,
their new state must also remain in , as per the {\em validity} property.

The above discussion implies that, at the end of iteration 1,
the following conditions hold true: (i) state of each node in  is
, (ii) state of each node in  is , and (iii) state of each node
in  is in the interval . These conditions are identical to the initial conditions
listed previously. Then, by a repeated application of the above
argument (proof by induction), it follows that for
any ,  for all , 
for all  and  for all .

Since both  and  are non-empty, the {\em -agreement} property
is not satisfied. A contradiction.
\fillbox
\end{proof}








Theorem \ref{thm:nc} shows that {\em Condition P} is necessary. However, {\em Condition P} is not intuitive. Below, we state an equivalent condition {\em Condition S} that is
easier to interpret. To facilitate the
statement, we introduce the notions of ``source component'' and ``link-reduced graph'' using the following three definitions. The link-reduced graph is analogous to the similar concept introduced in our prior work on node failures \cite{vaidya_PODC12,Tseng_general,vaidya_icdcn14}. 

\begin{definition}
\label{def:decompose}
{\bf Graph decomposition:}
Let  be a directed graph. Partition graph  into non-empty strongly connected components,
, where  is a non-zero integer dependent on graph ,
such that
\begin{itemize}
\item every pair of nodes {within} the same strongly connected component has directed
paths in  to each other, and
\item for each pair of nodes, say  and , that belong to
two {\em different} strongly connected components, either  does not have a
directed path to  in , or  does not have a directed path to  in .
\end{itemize}
Construct a graph  wherein each strongly connected component  above is represented
by vertex , and there is an edge from vertex  to vertex  if and only if
the nodes in  have directed paths in  to the nodes in .
\end{definition}
It is known that the decomposition
graph  is a directed {\em acyclic} graph \cite{dag_decomposition}.

\begin{definition}
{\bf Source component}:
Let  be a directed graph, and let  be its decomposition as per
Definition~\ref{def:decompose}. 
Strongly connected component  of  is said to be a {\em source component}
if the corresponding vertex  in  is \underline{not} reachable from any
other vertex in . 
\end{definition}

\begin{definition}
\label{def:reduced} {\bf Link-Reduced Graph:}
For a given graph  and ,
a graph 
is said to be a {\em link-reduced graph}, if
 is obtained by first removing from  all the links in , and {\em then} removing up to  other incoming
links at each node in .
\end{definition}
Note that for a given  and a given ,
multiple link-reduced graphs  may exist. \\

Now, we state {\em Condition S}:

~

\noindent {\em Condition S}: Consider graph . For any  such that , every
link-reduced graph  obtained as per Definition \ref{def:reduced} 
must contain exactly one {\em source component}.


Then, we show that {\em Condition S} and {\em Condition P} specify the equivalent property of the graph.

\begin{lemma}
\label{lemma:p-to-s}
Suppose that {\em Condition P} holds for graph . Then  satisfies {\em Condition S}.

\end{lemma}

\begin{proof}
By assumption, 
 contains at least two node, and so does ;
therefore, at least one
source component must exist in . We now prove that  cannot
contain more than one source component. The proof is by contradiction.
Suppose that there exists a subset  with ,
and the link-reduced graph 
 corresponding to  such
that the decomposition of  includes at least two source components.

Let the sets of nodes in two such source components of 
be denoted  and , respectively. Let .
Observe that  form a partition of the nodes in .
Since  is a source component in , it follows that
there are no directed links in  from any node in
 to the nodes in .
Similarly, since  is a source component in , it follows that
there are no directed links in  from any node in  to
the nodes in .
These observations, together with the manner in which 
is defined, imply that (i) there are at most  links in  from
the nodes in  to each node in , and
(ii) there are at most  links in  from
the nodes in  to each node in .
Therefore, in graph ,  and . Thus,  does not satisfies {\em Condition P}, since  and , a contradiction.
\fillbox
\end{proof}

\begin{lemma}
\label{lemma:s-to-p}
Suppose that {\em Condition S} holds for graph .
Then,  satisfies {\em Condition P}.
\end{lemma}

\begin{proof}
The proof is by contradiction. Suppose that {\em Condition P} does not hold for graph . Thus, there exist a subset , where , and a node partition , where  and  are both non-empty, such that  and  in .

We now constructed a link-reduced graph  corresponding to set . First, remove all links in  from . Then since , the number of links at each node in  from nodes in  is at most ; remove all these links. Similarly, for every node , remove all links from nodes in  to  (recall that by assumption, there are at most  such links). The remaining links form the set . It should be obvious that  satisfies Definition \ref{def:reduced}; hence,  is a valid link-reduced graph.

Now, observe that by construction, in the link-reduced graph  , there are no incoming links to nodes in  from nodes in ; similarly, in , there are no incoming links to nodes in  from nodes in . It follows that for each , there is no path using links in  from  to nodes in ; similarly, for each , there is no path using links in  from  to nodes in . Thus,  must contain at least two source components. Therefore, the existence of  implies that  violates {\em Condition S}, a contradiction.
\fillbox
\end{proof}

~

Lemmas \ref{lemma:p-to-s} and \ref{lemma:s-to-p} imply that {\em Condition P} is equivalent to {\em Condition S}. An alternate interpretation of {\em Condition S} is that in every link-reduced graph , non-fault-tolerant iterative consensus must be possible.



\subsection{Useful Properties}
\label{s:useful}

Suppose  satisfies {\em Condition P} and {\em Condition S}. We provide two lemmas below to state some properties of  that are useful for analyzing the iterative algorithm presented later. Lemma \ref{lemma:path} intuitively states that at least one node can propagate its value to all the other nodes (over enough number of iterations). Lemma \ref{lemma:2f+1} states that each node needs to have enough incoming neighbors for achieving approximate consensus. 

\begin{lemma}
\label{lemma:path}
Suppose that graph  satisfies {\em Condition S}. Then, in any link-reduced graph , there exists a node that has a directed path to all the other nodes in .
\end{lemma}


\begin{proof}
Recall that {\em Condition S} states that any link-reduced graph  has a single source component. By the definition of source component, any node in the source component (say node ) has directed paths using edges in  to all the other nodes in the source component, since the source component is a strongly connected component. Also, by the uniqueness of the source component, all other strongly connected components in  (if any exist) are not source components, and hence reachable from the source component using the edges in . Therefore, node  also has directed paths to all the nodes in  that are not in the source component as well. Therefore, node  has directed paths to all the other nodes in . This proves the lemma.
\fillbox
\end{proof}



\begin{lemma}
\label{lemma:2f+1}
For , if graph  satisfies {\em Condition P}, then each node in  has in-degree at least , i.e., for each .
\end{lemma}




\begin{proof}
The proof is by contradiction. By assumption in the lemma, , and graph  satisfies {\em Condition P}.

Suppose that there exists a node  such that . Define , and . Note that sets  form a partition of . Now, define an edge set  such that , and  contains  incoming links from nodes in  to node .

Observe that , and . Thus,  there can be at most  link from  to any node in  in . Therefore,  in . 
Then, recall that  is the set of all the node 's incoming links. Since  and , . Also, since , and  contains  links in , . Therefore,  in .
Thus,  does not satisfy {\em Condition P}, a contradiction. 
\fillbox
\end{proof}




\section{Algorithm 1}
\label{s:algorithm1}

We will prove that there exists a correct IABC algorithm – particularly Algorithm 1 below – that satisfies the termination, validity and
-agreement properties provided that the graph  satisfies {\em Condition S}. This implies that
{\em Condition P} and {\em Condition S} ares also sufficient. Algorithm 1 has the iterative structure described in Section \ref{sec:iacbl}, and
it is similar to algorithms that were analyzed in prior work as
well \cite{vaidya_PODC12,Tseng_general} (although correctness of the algorithm under
the necessary condition ({\em Conditions P} and {\em S}) has not been proved previously).




~

\hrule
{\bf Algorithm 1}
\vspace*{4pt}\hrule

\begin{enumerate}

\item {\em Transmit step:} Transmit current state  on all outgoing edges and self-loop.

\item {\em Receive step:} Receive values on all incoming edges and self-loop. These values form vector  of size  (including the value from node  itself). When a node expects to receive a message from an incoming neighbor but does not receive the message, the message value is assumed to be equal to its own state, i.e., .

\item {\em Update step:}
Sort the values in  in an increasing order (breaking ties arbitrarily), and eliminate the smallest and largest  values. 
Let  denote the set of nodes from whom the remaining  values in  were received. Note that as proved in Lemma \ref{lemma:2f+1}, each node has at least  incoming neighbors. Thus, when , .
Let  denote the value received from node . Note that . Hence, for convenience, define  to be the value node  receives from itself.  Observe that
if the link from  is fault-free, then .

Define

where
 

The ``weight'' of each term on the right-hand side of
(\ref{e_T}) is . Note that , and  because . Thus, the weights on the right-hand side add to 1. Also, .\footnote{Although  and  may be different for each iteration , for simplicity, we do not explicitly represent this dependence on  in the notations.} 




\end{enumerate}

\noindent {\bf Termination}: Each node terminates after completing iteration , where  is a constant defined later in Equation (\ref{eq:tend}). The value of  depends on graph , constants  and  defined earlier in Section \ref{sec:iacbl} and parameter  in -agreement property.

\hrule



\section{Sufficiency (Correctness of Algorithm 1)}
\label{s:sufficiency}

We will prove that given a graph  satisfying {\em Condition S}, Algorithm 1 is correct, i.e., Algorithm 1 satisfies {\em termination, validity, -agreement} properties. Therefore, {\em Condition S} and {\em Condition P} are proved to be sufficient. We borrow the matrix analysis from the work on non-fault-tolerant consensus \cite{Jadbabaie,AA_convergence_markov}. The proof below follows the same structure in our prior work on node failures \cite{Tseng_general,vaidya_icdcn14}; however, such analysis has not been applied in the case of link failures.

In the rest of the section, we assume that  satisfies {\em Condition S}  and {\em Condition P}. We introduce standard matrix tools to facilitate our proof. Then, we use transition matrix to represent the {\em Update} step in Algorithm 1, and show how to use these tools to prove the correctness of Algorithm 1 in .



\subsection{Matrix Preliminaries}


In the discussion below, we use boldface upper case letters to denote matrices,
rows of matrices, and their elements. For instance,
 denotes a matrix,  denotes the -th row of
matrix , and  denotes the element at the
intersection of the -th row and the -th column
of matrix .

\begin{definition}
\label{d_stochastic}
A vector is said to be {\em stochastic} if all the elements
of the vector are non-negative, and the elements add up to 1.
A matrix is said to be {\em row stochastic} if each row of the matrix is a
stochastic vector. 
\end{definition}

When presenting matrix products, for convenience of presentation, we adopt the ``backward'' product convention below, where ,




For a row stochastic matrix ,
 coefficients of ergodicity  and  are defined as
follows \cite{Wolfowitz}:



\begin{lemma}
\label{lemma:ergodicity}
For any  square row stochastic matrices ,


\end{lemma}

Lemma \ref{lemma:ergodicity} is proved in \cite{Hajnal58}. Lemma \ref{lemma:ergodicity2} below follows from the definition of .

\begin{lemma}
\label{lemma:ergodicity2}
If all the elements in any one column of matrix \bfA are lower bounded by a constant , then . That is, if , such that , then .
\end{lemma}

It is easy to show that   and , and that the rows
of  are all identical iff . Also,  iff .



\subsection{Correctness of Algorithm 1}
Denote by  the column vector consisting of the initial states at all nodes. The -th element of , , is the initial state of node . Denote by , for , the column vector consisting of the states of all nodes at the end
of the -th iteration. The -th element of vector  is state . 

For , define  to be the set of all links behaving faulty in iteration . Recall that link  is said to be faulty in iteration  if the value received by node  is different from what node  sends in iteration . Then, define  as the set of all nodes whose outgoing links to node  is faulty in iteration , i.e., .\footnote{ may be different for each iteration . For simplicity, the notation does not explicitly represent this dependence.}


Define  as a subset of incoming neighbors at node  of size at most , i.e.,\footnote{As will be seen later,  corresponds to the links removed in some link-reduced graph. Thus, the superscript  in the notation stands for ``removed."  may be different for each . For simplicity, the notation does not explicitly represent this dependence.}



Now, we state the key lemma that helps prove the correctness of Algorithm 1. In particular, Lemma \ref{lemma:tm2cm} allows us to use results for non-homogeneous Markov chains to prove the correctness of Algorithm 1.  The proof is presented in Appendix \ref{a:tm2cm}.



\begin{lemma}
\label{lemma:tm2cm}
The {\em Update} step in iteration  of Algorithm 1 at the nodes can be expressed as 


where {\normalfont} is an  row stochastic transition matrix with the following property: there exist a constant  that depends only on graph , and  such that for each , and  for all , 


\end{lemma}

~

Matrix  is said to be a \underline{transition matrix} for iteration . Aa the lemmas states,  is a row stochastic matrix. The proof of Lemma \ref{lemma:tm2cm} shows how to construct a suitable row stochastic matrix  for each iteration .  depends not only on  but also on the behavior of the faulty links in iteration . 


\begin{theorem}
\label{thm:correctness}
Algorithm 1 satisfies the {\em Termination, Validity}, and {\em -agreement} properties.
\end{theorem}

\begin{proof}
Sections \ref{s:validity}, \ref{s:termination} and \ref{s:agreement} provide the proof that Algorithm 1 satisfies the three properties for iterative approximate consensus in the presence of Byzantine links. This proof follows a structure used to prove correctness
of other consensus algorithms in our prior work \cite{Tseng_general,vaidya_icdcn14}.
\fillbox
\end{proof}


\subsection{Validity Property}
\label{s:validity}

Observe that . Therefore, by repeated application of (\ref{matrix:e_T}), we obtain for ,



Since each  is row stochastic as shown in Lemma \ref{lemma:tm2cm}, the matrix product  is also a row stochastic matrix. Thus, (\ref{eq:matrixT}) implies that the state of each node  at the end of iteration  can be expressed as a convex combination of the initial states at all the nodes. Therefore, the validity property is satisfied.

\subsection{Termination Property}
\label{s:termination}

Algorithm 1 terminates after  iterations, where  is a finite constant depending only on , and . Recall that  and  are defined as upper and lower bounds of the initial inputs at all nodes, respectively. Therefore, trivially, the algorithm satisfies the termination property. Later, using (\ref{eq:tend}), we define a suitable value for .


\subsection{-agreement Property}
\label{s:agreement}

The proof below follows the same structure in our prior works on node failures \cite{Tseng_general,vaidya_icdcn14} for proving correctness of other consensus algorithms with Byzantine nodes.

Denote by  the set of all the link-reduced graph of  corresponding to some faulty link set . Let



Note that  only depends on  and , and is a finite integer.

Consider iteration . Recall that  denote the set of faulty links in iteration . Then for each link-reduced graph , define connectivity matrix  as follows, where :

\begin{itemize}
\item , if either , or edge  exists in link-reduced graph ;
\item , otherwise.
\end{itemize}

Thus, the non-zero elements of row  correspond to the incoming links at node  in the link-reduced graph , or the self-loop at . Observe that  has a non-zero diagonal.


Based on {\em Condition S} and Lemma \ref{lemma:tm2cm}, we can show the following key lemmas. 


\begin{lemma}
\label{lemma:non-zero}
For any , and  has at least one non-zero column, i.e., a column with all elements non-zero.
\end{lemma}



\begin{proof}
 satisfies the {\em Condition S}. Therefore, by Lemma \ref{lemma:path},
there exists at least one node  in the link-reduced graph  that has directed paths to all the nodes in  (consisting of the edges in ).  of product  is  if and only if node  has a directed path to node  consisting of at most  edges in . Since the length of the path from  to any other node in  is at most , and  has directed paths to all the nodes, for  the -th column of matrix  will be non-zero.\footnote{That is, all the elements of the column will be non-zero. Also, such a non-zero column will exist in , too. We use the loose bound of  to simplify the presentation.} 
\fillbox
\end{proof}



For matrices  and  of identical dimension, we say that  iff  for all . Lemma below relates the transition matrices with the connectivity matrices. Constant  used in the lemma below was introduced in
Lemma \ref{lemma:tm2cm}.


\begin{lemma}
\label{lemma:cm}
For any , there exists a link-reduced graph  such  that , where  is the connectivity matrix for .
\end{lemma}


\begin{proof}
First, let us construct a link-reduced graph  by first removing  from . Recall that  is the set of faulty links in iteration . Then for each , remove a set of at most  node 's incoming links as defined in Lemma \ref{lemma:tm2cm} (). As a result, we have obtained a link-reduced graph  such that , if  or edge
 is in the link-reduced graph .

Denote by  the connectivity matrix for the link-reduced graph . Then,  denotes the element
in -th row and -th column of . By definition of the connectivity matrix, we know that , if  or edge  is in the link-reduced graph; otherwise, .

The statement in the lemma then follows from the above two observations.
\fillbox
\end{proof}



\begin{lemma}
\label{l_product_H}
For any ,
at least one column in the matrix product  is non-zero. 
\end{lemma}



\begin{proof}
Since  consists of  connectivity matrices
corresponding to link-reduced graphs, and the number of all link-reduced graphs for  () is ,
connectivity matrices corresponding to at least one link-reduced graph, say matrix \,, will appear in the above product at least  times.

Now observe that: (i)
By Lemma \ref{lemma:non-zero},  contains a non-zero
column, say the -th column is non-zero,
and (ii) by definition, all the  matrices in the product contain a non-zero diagonal. These two observations together imply that the -th column in the above product is non-zero.\footnote{The product  can be viewed as the product of  instances of  ``interspersed" with matrices with non-zero diagonals.}
\fillbox
\end{proof}


Let us now define a sequence of matrices , , such that
each of these matrices is a product of  of the
 matrices. Specifically,

From (\ref{eq:matrixT}) and (\ref{e_Q_i})
observe that



\begin{lemma}
\label{l_Q}
For ,  is a scrambling row stochastic matrix,
and 
\end{lemma}

\begin{proof}

 is a product of row stochastic matrices (); therefore,
 is row stochastic.
From Lemma \ref{lemma:cm}, for each ,

Therefore, 

By using  in Lemma \ref{l_product_H},
we conclude that the matrix product on the left side
of the above inequality contains a non-zero column. Therefore, since ,  on the
right side of the inequality also contains
a non-zero column.

Observe that  is finite, and hence, 
is non-zero. Since the non-zero terms in  matrices are all 1,
the non-zero elements in 
must each be  1. Therefore, there exists a non-zero column in 
with all the elements in the column being .
Therefore, by Lemma \ref{lemma:ergodicity2}, , and  is a scrambling matrix. 
\fillbox
\end{proof}

Let us now continue with the proof of -agreement. Consider the coefficient of ergodicity .






Observe that the upper bound on right side of (\ref{eq:t}) depends only on graph  and , and is
independent of the input states, and the behavior of the faulty links. Moreover, the
upper bound on the right side of (\ref{eq:t}) is a non-increasing function of . Define  as the smallest positive integer such that the right hand side of (\ref{eq:t}) is smaller than . Recall that  and  are defined as the upper and lower bound of the inputs at all nodes. Thus,



Recall that  and  depend only on . Thus,  depends only on graph , and constants  and .

Recall that  is an  row stochastic matrix. let . From \ref{eq:matrixT}, we have . That is, the state of any node  can be obtained as the product of the -th row of  and . Now, consider any two nodes , we have





Therefore, by (\ref{eq:tend}) and (\ref{eq:delta}), we have



Since the output of the nodes equal its state at termination (after  iterations). Thus, (\ref{eq:final}) implies that Algorithm 1 satisfies the -agreement property.

\section{Summary}

This paper explores approximate consensus problem under transient Byzantine link failure model. We address a particular class of iterative algorithms in arbitrary directed graphs, and prove a necessary and sufficient condition for the graphs to be able to solve the approximate consensus problem iteratively.





\begin{thebibliography}{10}
\bibitem{AA_optimal}
I. Abraham,~Y. Amit,~and~D. Dolev. 
\newblock Optimal resilience asynchronous approximate agreement. 
\newblock In OPODIS, 2004.



\bibitem{Biely_hybrid}
M.~Biely, U.~Schmid, and B.~Weiss. 
\newblock {\em Synchronous consensus under hybrid process and link failures}. \newblock Theoretical Computer Science, 412(40):5602 – 5630, 2011.

\bibitem{AA_convergence_markov}
D.~P. Bertsekas and J.~N. Tsitsiklis.
\newblock {\em Parallel and Distributed Computation: Numerical Methods}.
\newblock Optimization and Neural Computation Series. Athena Scientific, 1997.

\bibitem{HeardOf}
B. Charron-Bost and A. Schiper. 
\newblock The Heard-Of model: computing in distributed systems with benign faults.
\newblock Distributed Computing, 22(1):49–71, April 2009.

\bibitem{dag_decomposition}
S.~Dasgupta, C.~Papadimitriou, and U.~Vazirani.
\newblock {\em Algorithms}.
\newblock McGraw-Hill Higher Education, 2006.

\bibitem{AA_Dolev_1986}
D.~Dolev, N.~A. Lynch, S.~S. Pinter, E.~W. Stark, and W.~E. Weihl.
\newblock Reaching Approximate Agreement in the presence of Faults.
\newblock {\em J. ACM}, May 1986.

\bibitem{impossible}
M. J. Fischer, N. A. Lynch, and M. Merritt. 
\newblock Easy impossibility proofs for distributed consensus problems.
\newblock PODC '85, 1985. ACM.

\bibitem{Hajnal58}
J.~Hajnal.
\newblock Weak Ergodicity in non-homogeneous Markov Chains.
\newblock In {\em Proceedings of the Cambridge Philosophical Society},
  volume~54, pages 233--246, 1958.

\bibitem{Jadbabaie}
A.~Jadbabaie, J. Lin, and A. Morse. 
\newblock Coordination of Groups of Mobile Autonomous Agents using Nearest Neighbor Rules. 
\newblock Automatic Control, IEEE Transactions on, 48(6):988--1001, June 2003.


\bibitem{Kempe_gossip}
D.~Kempe,~A.~Dobra,~and J. Gehrke.
\newblock Gossip-based computation of aggregate information.
\newblock IEEE Symposium on Foundations of Computer Science, Oct. 2003.

\bibitem{psl_BG_1982}
L.~Lamport, R.~Shostak, and M.~Pease.
\newblock The Byzantine Generals Problem.
\newblock {\em ACM Trans. on Programming Languages and Systems}, 1982.

\bibitem{Sundaram_condition}
H. J. LeBlanc, H. Zhang, X. Koutsoukos, S. Sundaram.
\newblock Resilient Asymptotic Consensus in Robust Networks.
\newblock Selected Areas in Communications, IEEE Journal on , vol.31, no.4, pp.766,781, April 2013.

\bibitem{packet}
D. S. Lun, M. M{\'e}dard, R. Koetter, and M. Effros.
\newblock On coding for reliable communication over packet networks.
\newblock Physical Communication, 2008.

\bibitem{control}
M. Pajic, S. Sundaram, J. Le Ny, G. J. Pappas, and R. Mangharam.
\newblock Closing the Loop: A Simple Distributed Method for Control
over Wireless Networks.
\newblock international conference on Information Processing in Sensor Networks, 2012.


\bibitem{Santoro_link}
N. Santoro, and P. Widmayer. 
\newblock Time is not a healer.
\newblock in: Proc. 6th Ann. Symposium on Theoretical Aspects of Computer Science, STACS '89, 1989.

\bibitem{Santoro_link2}
N. Santoro and P. Widmayer.
\newblock Agreement in synchronous networks with ubiquitous faults.
\newblock Theor. Comput. Sci. 384 (2-3) (2007) 232–249.

\bibitem{noisy_link}
I. D. Schizas, A. Ribeiro, and G. B. Giannakis. 
\newblock Consensus in Ad Hoc WSNs With Noisy Links- Part I: Distributed Estimation of Deterministic Signals.
\newblock IEEE Transactions on Signal Processing, 2008.

\bibitem{Schmid_link}
U. Schmid, B. Weiss, I. Keidar.
\newblock Impossibility results and lower bounds for consensus under link failures.
\newblock SIAM Journal on Computing 38 (5) 1912–1951, 2009..

\bibitem{SS_link}
S. Sundaram, S. Revzen, and G. Pappas.
\newblock A control-theoretic approach to disseminating values and overcoming malicious links in wireless networks
\newblock Automatica, 2012.

\bibitem{SS_node}
S. Sundaram and C. N. Hadjicostis.
\newblock Distributed function calculation via linear iterative strategies in the presence of malicious agent.
\newblock IEEE Transactions on Automatic Control, 2011.

\bibitem{Tseng_general}
L. Tseng and N. H. Vaidya. 
\newblock Iterative approximate byzantine consensus under a generalized fault model.
\newblock In International Conference on Distributed Computing and Networking (ICDCN), January 2013.

\bibitem{vaidya_PODC12}
N.~H. Vaidya, L.~Tseng, and G.~Liang.
\newblock Iterative Approximate Byzantine Consensus in Arbitrary Directed
  Graphs.
\newblock PODC '12, 2012. ACM.

\bibitem{vaidya_icdcn14}
N.~H. Vaidya.
\newblock Iterative Byzantine Vector Consensus in Incomplete Graphs.
\newblock In International Conference on Distributed Computing and Networking (ICDCN), January 2014.


\bibitem{Wolfowitz}
J.~Wolfowitz.
\newblock Products of Indecomposable, Aperiodic, Stochastic Matrices.
\newblock In {\em Proceedings of the American Mathematical Society}, volume~14,
  pages 733--737, 1963.
\end{thebibliography}



\appendix

\section*{Appendix}

\section{Example Network}
\label{a:example}


\begin{lemma}
The graph in Figure \ref{f:eg} satisfies {\em Condition P} when .
\end{lemma}

\begin{proof}
Denote by  the graph in Figure \ref{f:eg}. First observe that a clique of  nodes satisfies {\em Condition P} when . Thus, for , we only need to consider the case when node  is in either  or ; otherwise, some node in  (or ) from the clique (formed by nodes ) will have at least  incoming links from  (or ) excluding link in . 

Without loss of generality, consider the case when  is in . Consider the following cases:

\begin{itemize}
\item One of the nodes  is in : say node  is in  besides . Then node  has at least  incoming links from  excluding link in .

\item Two of the nodes  are in : say nodes  are in  besides . Then either node  or  has at least  incoming links from  excluding link in .

\item Three of the nodes  are in : say node  is the only node in , since all the other nodes are in . Then node  has at least  incoming links from  excluding link in .

\end{itemize}
In every case, either  or . Thus,  satisfies {\em Condition P}.

\fillbox
\end{proof}


\section{Proof of Lemma \ref{lemma:tm2cm}}
\label{a:tm2cm}

We prove the following Lemma in Section \ref{s:sufficiency}.

~

\noindent {\bf Lemma} \ref{lemma:tm2cm}.
{\em 
The {\em Update} step in iteration  of Algorithm 1 at the nodes can be expressed as 


where {\normalfont} is an  row stochastic transition matrix with the following property: there exist a constant  that depends only on graph , and  such that for each , and  for all , 


}



\begin{proof}

We prove the correctness of Lemma \ref{lemma:tm2cm} by constructing  for  that satisfies the conditions in Lemma \ref{lemma:tm2cm}. Recall that  denotes the set of faulty links in the -th iteration.

Consider a node  in iteration . In the {\em Update} step of Algorithm 1, recall that the smallest and the largest  values are removed from  by node . Denote by  and , respectively, the set of nodes\footnote{Although  and  may be different for each iteration , for simplicity, we do not explicitly represent this dependence on  in the notations  and .} from whom the smallest and the largest  values were received by node  in iteration . Define sets  and  to be subsets of  and  that contain all the nodes from whom node  receives the correct value in  and , respectively. That is,  and .

Construction of  differs somewhat depending on whether
sets  and  are empty or not.
We divide the possibilities into 3 separate cases:

\begin{itemize}
\item Case I: , and .

\item Case II: , and .

\item Case III: at most one of  and , and .

\end{itemize}
Observe that if  () is empty, then  and  (), since there are at most  faulty links and . Therefore, the 3 cases above cover all the possible scenarios.


\noindent {\bf Case I}

~
In Case I,
, and . Let  and  be defined as shown below. Recall that the incoming links from the nodes in  and  to node  are all fault-free, and therefore, for any node ,  (in the notation of Algorithm 1). That is, the value received by node  from node  is exactly the state at node  in iteration .


Now, consider any node . By the definition of sets  and ,
. Therefore, we can find weights  and  such that , and


Clearly, at least one of  and  must be .

~


We now define elements  of row :

\begin{itemize}
\item For  : In this case, either the edge  is fault-free, or .
For each such , define . This is obtained by observing
in (\ref{e_T}) that the contribution of such a node  to the new state
 is .

The elements of  defined here add up to 



\item For  : In this case, the edge  is a fault-free.

For each ,

and for each node ,

To obtain these two expressions, we represent value  sent via faulty link  for each  using (\ref{eq:caseI}).  
Recall that this node  contributes  to (\ref{e_T}).
The above two expressions are then obtained by summing (\ref{eq:caseI})
over all the nodes in , and replacing this sum
by equivalent contributions by nodes in  and .

The elements of  defined here add up to 



\item For  :
These nodes have not yet been considered above.
For each such node , define .
\end{itemize}
With the above definition of , it should be easy to see
that  is, in fact, identical to  obtained using (\ref{e_T}). Thus, the above construction of  results in the values sent via faulty links to (\ref{e_T}) being replaced by an equivalent contribution from the nodes in  and .

~

\paragraph{Properties of :}


First, we show that  is row stochastic. Observe that all
the elements of  are non-negative.
Also, all the elements of  above add up to

because  as defined in Algorithm 1.
Thus,  is a stochastic row vector.

Recall that from the above discussion, for ,
one of  and  must be .
Without loss of generality, assume that  for all nodes .
Consequently, for each node , . Also,
for each node  in ,
.
Thus, if  is chosen such that

and  is defined to be , then the condition in the
lemma holds for node . That is, 
for all , 






~


\noindent {\bf Case II}

~

Now, we consider the case when , and . That is, when each of  and  contains at least one node from which the node  receives correct value, and node  receives correct value(s) from all the node(s) in . In fact, the analysis of Case II is very similar to the analysis presented above in Case I. We now discuss how the analysis of Case I can be applied to Case II. Rewrite (\ref{e_T}) as follows:



In the above equation,  is to be viewed as a ``virtual'' incoming
neighbor of node , which has sent value 
to node  in iteration .
With the above rewriting of state update,
the value received by node  from itself should
be viewed as  instead of . 
With this transformation, Case II now becomes identical
to Case I, with virtual node  being treated
as an incoming neighbor of node .


In essence, a part of node 's contribution (half, to be precise) is now replaced by equivalent contribution by nodes in  and . 
We now define elements  of row :

\begin{itemize}
\item For : . This is obtained by observing in (\ref{e_T}) that node 's contribution to the new state  is .


\item For  : In this case,  is a node from which node  receives correct value. For each such , define . This is obtained by observing in (\ref{e_T}) that the contribution of node  to the new state  is .


\item For  : In this case,  is a node in  or   from which node  receives correct value. 

For each ,

and for each node ,


where  and  are chosen such that  and . Note that such  and  exist because by definition of  and ,  and . Then the two expressions above are obtained by replacing the contribution of the virtual node  by an equivalent contribution by the nodes in  and , respectively.

\item For  :
 These nodes have not yet been considered above.
For each such node , define .
\end{itemize}

~

\paragraph{Properties of :}


By argument similar to that in {\em Case I},  is row stochastic. Without loss of generality, suppose that . Then for each node , . Also, for node  in , , and . Recall that by definition, . Hence, if  is chosen such that 


and  is defined to be equal to , then the condition in the Lemma \ref{lemma:tm2cm} holds for node . That is,
 for . 

~






\noindent {\bf Case III}

Here, we consider the case when at most one of  and  is empty, and . Without loss of generality, suppose that  contains only nodes whose outgoing links to node  is faulty in iteration , i.e., . Since there are at most  faulty links and , . That is, the value received from each node in  by node  is correct.

In this case, define  for ;
define  for all other nodes .


~

\noindent {\em Properties of :}


All the elements of  are non-negative.
The elements of  defined above add up to

Thus,  is a stochastic row vector.

In Case III, recall that for any node  in , .
Thus, if  is chosen such that

and  is defined to be equal to ,
then the condition in the
Lemma \ref{lemma:tm2cm} holds for node . 

~

\noindent {\bf Putting Cases Together} 


Now, let us consider Cases I-III together. From the definition of  in Algorithm 1, observe that  (because ). Let us define

Moreover, observe that  and . Then define  as 

This definition satisfies constraints on  in Cases I through III (conditions (\ref{eq:beta_caseI}), (\ref{eq:beta-caseII}) and (\ref{eq:beta-caseIII})). Thus, Lemma \ref{lemma:tm2cm} holds for all three cases with this choice in (\ref{eq:beta}).

\fillbox
\end{proof}






\end{document}
