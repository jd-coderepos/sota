
\documentclass{article} 

\usepackage[dvipsnames]{xcolor}    

\usepackage{iclr2022_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{$\eta$}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak













 
\usepackage{hyperref}
\usepackage{url}

\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      

\usepackage{amssymb}
\usepackage{multicol}
\usepackage{sidecap}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{csquotes}
\usepackage{floatrow}
\usepackage{adjustbox}
\usepackage{xfrac}

\usepackage{enumitem}
\usepackage{multirow}

\usepackage{float}
\floatstyle{plaintop}
\restylefloat{table}

\usepackage{wrapfig}
\usepackage{chngcntr}

\usepackage{amssymb}\usepackage{pifont}\newcommand{\cmark}{\ding{51}}\newcommand{\xmark}{\ding{55}}

\usepackage{MnSymbol}\usepackage{wasysym}\usepackage{multirow}
\usepackage{xspace}
\usepackage[capitalise]{cleveref}
\creflabelformat{equation}{#2#1#3}
\newcommand{\creflastconjunction}{,\nobreakspace}
\newcommand{\crefpairconjunction}{,\nobreakspace}
\def\arrvline{\hfil\kern\arraycolsep\vline\kern-\arraycolsep\hfilneg}
\usepackage[cal=dutchcal,
 calscaled=1,
scr=euler]{mathalfa}
\newcommand{\ie}[0]{\emph{i.e.},~}
\newcommand{\eg}[0]{\emph{e.g.},~}
\newcommand{\aka}[0]{a.k.a.~}
\newcommand{\etal}{\emph{et al.~}}
\newcommand{\etc}{\emph{etc.~}}
\newcommand{\wrt}{w.r.t.~}
\def\old#1{{\color{gray}{{old:\ #1\ }}}}
\newcommand{\defeq}{\ensuremath{\doteq}}

\usepackage{dsfont}
\newcommand{\kw}[1]{{\small\textsc{\MakeLowercase{#1}}}}
\newcommand{\mat}[1]{\ensuremath{{\mathbf{\MakeUppercase{{#1}}}}}}
\renewcommand{\vec}[1]{\ensuremath{\mathbf{\MakeLowercase{{#1}}}}}
\newcommand{\set}[1]{\ensuremath{\mathbb{#1}}}
\newcommand{\gr}[1]{\ensuremath{\mathcal{#1}}}
\newcommand{\prm}[1]{\ensuremath{^{#1}}}
\newcommand{\ly}[1]{\ensuremath{^{(#1)}}}
\newcommand{\grn}[2]{\ensuremath{\gr{#1}\prm{#2}}}
\newcommand{\tuple}[1]{\ensuremath{\langle{#1} \rangle}}
\newcommand{\Reals}{\mathds{R}}
\renewcommand{\Re}{\gr{R}}
\newcommand{\Nat}{\set{N}}
\newcommand{\eye}{\mat{I}}
\newcommand{\ones}{\vec{1}}
\newcommand{\Vs}{\set{V}}
\newcommand{\Ws}{\set{W}}
\newcommand{\Ps}{\set{P}}
\newcommand{\Qs}{\set{Q}}
\newcommand{\Sg}{\gr{S}}
\newcommand{\Ig}{\gr{I}}
\newcommand{\Cg}{\gr{C}}
\newcommand{\Gg}{\gr{G}\xspace}
\renewcommand{\gg}{\gr{g}}
\newcommand{\gi}{\gr{i}}
\newcommand{\gj}{\gr{j}}
\newcommand{\gh}{\gr{h}}
\newcommand{\Hg}{\gr{H}}
\newcommand{\hg}{\gr{h}}
\newcommand{\Kg}{\gr{K}}
\newcommand{\Ng}{\gr{N}}
\newcommand{\Bg}{\gr{B}}
\newcommand{\bg}{\gr{b}}
\newcommand{\kg}{\gr{k}}
\newcommand{\Ug}{\gr{U}}
\newcommand{\ug}{\gr{u}}
\newcommand{\Wm}{\mat{W}}
\newcommand{\Xm}{\mat{X}}
\newcommand{\Ym}{\mat{Y}}
\newcommand{\Am}{\mat{A}}
\newcommand{\Gm}{\mat{G}}
\newcommand{\Vm}{\mat{V}}
\newcommand{\Um}{\mat{U}}
\newcommand{\Pm}{\mat{P}}

\newcommand{\xv}{\vec{x}}
\newcommand{\yv}{\vec{y}}
\newcommand{\hv}{\vec{h}}
\newcommand{\ov}{\vec{o}}
\newcommand{\bv}{\vec{b}}
\newcommand{\wv}{\vec{w}}
\newcommand{\W}{\Wm}
\newcommand{\X}{\Xm}
\newcommand{\Y}{\Ym}
\newcommand{\A}{\Am}
\newcommand{\x}{\xv}
\newcommand{\Ns}{\set{N}}
\newcommand{\Ms}{\set{M}}
\newcommand{\As}{\set{N}}
\newcommand{\Bs}{\set{M}}

\def\ct{\mathrm{c}}
\def\Ct{\mathrm{C}}
\def\Lt{\mathrm{L}}
\def\Nt{\mathrm{N}}
\def\Kt{\mathrm{K}}
\def\Xt{\mathrm{X}}

\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sR{{\mathbb{R}}}
\def\sZ{{\mathbb{Z}}}

\def\bpsi{{\boldsymbol{\psi}}}

\newcommand{\eu}{\mathrm{e}\mkern1mu}
\newcommand{\du}{\mathrm{d}\mkern1mu}
\newcommand{\iu}{{i\mkern1mu}}
\newcommand{\ltwo}{\boldsymbol{{\rm L}^{2}}}


\font\btt=rm-lmtk10
\newcommand{\mlp}{{\btt MLP}}
\newcommand{\mlppsi}{\mlp$^{\bpsi}$}

\newcommand{\todo}[1]{\textcolor{red}{#1}}

\definecolor{mydarkblue}{rgb}{0,0.08,0.45}
\definecolor{mathematicablue}{rgb}{0.11, 0.25, 0.467}
\hypersetup{colorlinks,citecolor={mydarkblue},urlcolor={mydarkblue}, linkcolor={red}} 

\usepackage[ruled,vlined]{algorithm2e}



\title{CKConv: Continuous Kernel Convolution For \centerline{Sequential Data}}



\author{\centerline{David W. Romero$^{1}$, Anna Kuzina$^{1}$, Erik J. Bekkers$^{2}$, Jakub M. Tomczak$^{1}$, Mark Hoogendoorn$^{1}$}\\
    \centerline{${^1}$\hspace{0.5mm}Vrije Universiteit Amsterdam \quad $^{2}$\hspace{0.5mm}University of Amsterdam}\\
  \centerline{The Netherlands}\\
  \centerline{\texttt{\{d.w.romeroguzman, a.kuzina\}@vu.nl}}\\
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}

\maketitle

\begin{abstract}
   Conventional neural architectures for sequential data present important limitations. Recurrent neural networks suffer from exploding and vanishing gradients, small effective memory horizons, and must be trained sequentially. Convolutional neural networks cannot handle sequences of unknown size and their memory horizon must be defined a priori. In this work, we show that these problems can be solved by formulating the convolutional kernels of CNNs as continuous functions. The resulting \textit{Continuous Kernel Convolution} (CKConv) handles arbitrarily long sequences in a parallel manner, within a single operation, and without relying on any form of recurrence. We show that \textit{Continuous Kernel Convolutional Networks} (CKCNNs) obtain state-of-the-art results in multiple datasets, e.g., permuted MNIST, and, thanks to their continuous nature, are able to handle non-uniformly sampled datasets and irregularly-sampled data natively. CKCNNs match or perform better than neural ODEs designed for these purposes in a faster and simpler manner.
\end{abstract}

\vspace{-3mm}
\section{Introduction}
\vspace{-1mm}
Recurrent Neural Networks (RNNs) have long governed tasks with sequential data \citep{rumelhart1985learning, hochreiter1997long, chung2014empirical}. Their main ingredient are \textit{recurrent units}: network components with a recurrence formulation which grants RNNs the ability to be unrolled for arbitrarily many steps and handle sequences of arbitrary size. In practice, however, the effective \textit{memory horizon} of RNNs, i.e., the number of steps the network retains information from, has proven to be surprisingly small, most notably due to the \textit{vanishing gradients problem} \citep{hochreiter1991untersuchungen, bengio1994learning}. Interstingly, it is the very recurrent nature of RNNs that allows them to be unrolled for arbitrarily many steps which is responsible for vanishing gradients \citep{pascanu2013difficulty}. This, in turn, hinders learning from the far past and induces a~small~effective~memory~horizon.

Convolutional Neural Networks (CNNs) \citep{lecun1998gradient} have proven a strong alternative to recurrent architectures as long as relevant input dependencies fall within their memory horizon, e.g., \citet{conneau2016very, oord2016wavenet, dai2017very, dauphin2017language, bai2018empirical}. CNNs avoid the training instability and vanishing / exploding gradients characteristic of RNNs by avoiding \textit{back-propagation through time} \citep{werbos1990backpropagation} altogether.
However, these architectures model convolutional kernels as a sequence of independent weights. As a result, their memory horizon must be defined \textit{a-priori}, and larger memory horizons induce a proportional growth of the model size.

In this work, we provide a solution to these limitations. We propose to view a convolutional kernel as a continuous function parameterized by a small neural network instead of a sequence of independent weights. The resulting \textit{Continuous Kernel Convolution} (CKConv) enjoys the following properties:
\begin{itemize}[topsep=0pt, leftmargin=*]
    \item CKConvs can define arbitrarily large memory horizons within a single operation. Consequently, \textit{Continuous Kernel Convolutional Neural Networks} (CKCNNs) detach their memory horizon from \emph{(i)} the depth of the network, \emph{(ii)} the dilation factors used, and \emph{(iii)} the size of the network. 
    \item CKConvs do not rely on any form of recurrence. As a result, CKCNNs (\textit{i}) can be trained in parallel, and (\textit{ii}) do not suffer from vanishing / exploding gradients or small effective memory horizons.
    \item Continuous convolutional kernels can be evaluated at arbitrary positions. Consequently, CKConvs and CKCNNs can be readily used on irregularly sampled data, and data at different resolutions.
\end{itemize}
We observe that continuous kernel parameterizations previously used to handle irregular data \textit{locally}, e.g., \citet{schutt2017schnet, wu2019pointconv}, are not adequate to model long-term dependencies. This is due to the inability of their kernels to model long spatial complex functions (Sec.~\ref{sec:ckconvkernel}). Contrarily, CKConvs perfectly describe long complex non-linear, non-smooth functions by parameterizing their kernels as SIRENs \citep{sitzmann2020implicit}: implicit neural representations with $\mathrm{Sine}$ nonlinearities. Shallow CKCNNs match or outperform state-of-the-art approaches on several tasks comprising stress tests, continuous, discrete and irregular data, as well as resolution changes. To the best of our knowledge, we are first to observe the potential of continuous convolutional kernels to model long-term dependencies, and to provide an useful parameterization to this end.
\begin{figure}
    \centering
    \hfill
         \begin{subfigure}[b]{0.115\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/mlp_graphic.png}
\end{subfigure}
     \hfill
     \begin{subfigure}[b]{0.75\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/ckconv_3.png}
\end{subfigure}
     \hfill
    \vspace{-2mm}
    \caption{Continuous Kernel Convolution (CKConv). CKConv views a convolutional kernel as a vector-valued continuous function $\boldsymbol{\psi}: \sR \rightarrow \sR^{\mathrm{N_{out}}\times \mathrm{N_{in}}}$ parameterized by a small neural network \mlppsi. \mlppsi\ receives a time-step and outputs the value of the convolutional kernel at that position. We sample convolutional kernels by passing a set of relative positions $\{ \Delta\tau_i\}$ to \mlppsi, and perform convolution\break with the sampled kernel next. Since \mlppsi\ is a continuous function, CKConvs can (\textit{i}) construct arbitrarily large kernels, (\textit{ii}) generate kernels at different resolutions, and (\textit{iii}) handle irregular data.\vspace{-2.5mm}}
    \label{fig:ckconv}
\end{figure}
\vspace{-2mm}
\section{Related Work}\label{sec:related_work}
\vspace{-2mm}
\textbf{Continuous kernel formulation.} Continuous formulations for convolutional kernels were introduced to handle irregularly sampled 3D data \textit{locally} \citep{schutt2017schnet, simonovsky2017dynamic, wang2018deep, wu2019pointconv}. As discrete convolutions learn independent weights for specific relative positions, they cannot handle irregularly sampled data effectively. Following work focuses on point-cloud applications \citep{fuchs2020se, hu2020randla, shi2019points, thomas2018tensor}. Other approaches include Monte Carlo approximations of continuous operations \citep{finzi2020generalizing}.
Our work proposes a new broad flavor of applications for which continuous kernels are advantageous.

\textbf{Implicit neural representations.} Implicit neural representations construct continuous data representations by encoding the input in the weights of a neural network \citep{mescheder2019occupancy, park2019deepsdf, sitzmann2020implicit}. This leads to numerous advantages over conventional (discrete) data representations, e.g., memory efficiency, analytic differentiability, with interesting properties for several applications, e.g., generative modelling \citep{dupont2021generative, schwarz2020graf}.

Since we model convolutional kernels as continuous functions and parameterize them via neural networks, our approach can be understood as \textit{implicitly representing the convolutional kernels of a conventional CNN}.
Different is the fact that these convolutional kernels are not known a-priori, but learned as a part of the optimization task of the CNN. Making the connection between implicit neural representations and continuous kernel formulations explicitly brings substantial insights for the construction of these kernels. In particular, it motivates the use of $\mathrm{Sine}$ nonlinearities \citep{sitzmann2020implicit} to parameterize them, which leads to significant improvements over the $\mathrm{ReLU}$, $\mathrm{LeakyReLU}$, and $\mathrm{Swish}$ nonlinearities used so far for this purpose (Sec.~\ref{sec:ckconvkernel}).

\vspace{-2mm}
\section{The Convolution and Common Kernel Parameterizations}\label{sec:convolution}
\vspace{-2mm}
\textbf{Notation.} $[n]$ denotes the set $\{0, 1, \ldots, n\}$. Bold capital and lowercase letters depict vectors and matrices, e.g., $\xv$, $\Wm$, sub-indices index vectors, e.g., $\xv {=} \{x_{\ct}\}_{\ct = 1}^{\Nt_{\mathrm{in}}}$, parentheses index time, e.g., $\xv(\tau)$ is the value of $\xv$ at time-step $\tau$, and calligraphic letters depict sequences, e.g., $\gX {=} \{\xv(\tau) \}_{\tau {=} 0}^{\Nt_{\Xt}}$. 


\textbf{Centered and causal convolutions.} 
Let $\xv: \sR \rightarrow \sR^{\Nt_{\mathrm{in}}}$ and $\boldsymbol{\psi}:\sR \rightarrow \sR^{\Nt_{\mathrm{in}}}$ be a vector valued signal and kernel on $\sR$, such that $\xv{=}\{x_{\ct}\}_{\ct {=} 1}^{\Nt_{\mathrm{in}}}$ and $\boldsymbol{\psi} {=} \{ \psi_{\ct} \}_{c {=} 1}^{\Nt_{\mathrm{in}}}$. The convolution is defined as:
\begin{equation}
\setlength{\abovedisplayskip}{1pt}
\setlength{\belowdisplayskip}{1pt}
    (\xv * \boldsymbol{\psi})(t) = \sum_{\ct = 1}^{\Nt_{\mathrm{in}}} \int_{\sR} x_{\ct}(\tau) \psi_{\ct}(t - \tau) \, \du \tau. \label{eq:conv_def1}
\end{equation}
In practice, the input signal $\xv$ is gathered via some sampling procedure. Resultantly, the convolution is effectively performed between the sampled input signal described as a sequence of finite length $\gX {=} \{\xv(\tau) \}_{\tau {=} 0}^{\Nt_{\Xt}}$ and a convolutional kernel $\gK {=} \{\boldsymbol{\psi}(\tau) \}_{\tau {=} 0}^{\Nt_{\Xt}}$ described the same way:
\begin{equation}
\setlength{\abovedisplayskip}{1pt}
\setlength{\belowdisplayskip}{1pt}
    (\xv * \boldsymbol{\psi})(t) = \sum_{\ct = 1}^{\Nt_{\mathrm{in}}} \sum_{\tau = -\nicefrac{\Nt_{\Xt}}{2}}^{\nicefrac{\Nt_{\Xt}}{2}} x_{\ct}(\tau) \psi_{\ct}(t - \tau). \label{eq:conv_centered}
\end{equation}
Values $\xv(\tau)$ falling outside of $\gX$ are \textit{padded} by a constant value often defined as zero (Fig.~\ref{fig:centered_conv}).

\begin{figure}[t]
     \centering
     \begin{subfigure}[b]{0.26\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/normalconv.png}
         \caption{}
         \label{fig:centered_conv}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{0.26\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/causalconv.png}
         \caption{}
         \label{fig:causal_conv}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{0.35\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/dilated_kernel.png}
         \caption{}
         \label{fig:dilated_conv}
     \end{subfigure}
     \vspace{-2mm}
     \caption{Discrete centered, causal, and dilated causal convolutions.
     \vspace{-3.5mm}}
        \label{fig:causal_vs_centered}
\end{figure}
The convolutional kernel is commonly \textit{centered} around the point of calculation $t$. For sequence modeling this can be undesirable as future input values $\{ \xv(t - \tau)\}_{\tau {=} \nicefrac{-\Nt_{\Xt}}{2}}^{-1}$ are considered during the operation. This is solved by providing a \textit{causal formulation to the convolution}: a formulation in which the convolution at time-step $t$ only depends on input values at time-steps $(t - \tau) \leq t$ (Fig.~\ref{fig:causal_conv}):
\begin{equation}
\setlength{\abovedisplayskip}{0pt}
\setlength{\belowdisplayskip}{3pt}
    (\xv * \boldsymbol{\psi})(t) = \sum_{\ct = 1}^{\Nt_{\mathrm{in}}} \sum_{\tau = 0}^{t} x_{\ct}(\tau) \psi_{\ct}(t - \tau). \label{eq:causal_conv}
\end{equation}
In practice, causal convolutions are easily implemented via asymmetrical padding. In this work, we consider causal convolutions as default. Nevertheless, our analyses are also valid for centered ones.

\textbf{Discrete convolutional kernels.}
By a large margin, most convolutional kernels $\boldsymbol{\psi}$ in literature are parameterized as a finite sequence of $\Nt_{\Kt} + 1$ independent learnable weights $\gK {=} \{ \boldsymbol{\psi}(\tau) \}_{\tau {=} 0}^{\Nt_{\Kt}}$ (Fig.~\ref{fig:causal_vs_centered}). As these weights are independent of one another, $\Nt_{\Kt}$ must be kept small to keep the parameter count of the model tractable. Hence, the kernel size is often much smaller than the input length: $\Nt_{\Kt} \ll \Nt_{\Xt}$. 
This parameterization presents important limitations:
\begin{itemize}[topsep=0pt, leftmargin=*]
\item The memory horizon $\Nt_{\Kt}$ must be defined a priori.
\item Since $\Nt_{\Kt} \ll \Nt_{\Xt}$, this parameterization implicitly assumes that the convolution $(\xv * \boldsymbol{\psi})$ at position $t$ \emph{only depends on input values at positions up to $\tau {=} \Nt_{\Kt}$ steps in the past}. Consequently, no functions depending on inputs $\xv(t-\tau)$ for $\tau > \Nt_{\Kt}$ can be modeled.
\item The most general selection of $\Nt_{\Kt}$ is given by a \textit{global memory horizon}: $\Nt_{\Kt} {=} \Nt_{\Xt}$. Unfortunately, as discrete convolutional kernels are modeled as a sequence of independent weights, this incurs an extreme growth of the model size and rapidly becomes statistically unfeasible.
\end{itemize}
\textbf{Dilated convolutional kernels.}
To alleviate these limitations, previous works propose to interleave kernel weights with zeros in order to cover larger memory horizons without additional weights (Fig.~\ref{fig:dilated_conv}). This formulation alleviates some of the previous limitations, but introduces additional ones:
\begin{itemize}[topsep=0pt, leftmargin=*]
\item Dilated kernels are unable to model dependencies of input values falling in the interleaved regions.\item Several authors use dilated convolutions with varying dilation factors as a function of depth, e.g., \citep{bai2018empirical, dai2017very, oord2016wavenet, romero2020wavelet}. By carefully selecting layer-wise dilation factors, one can assure that some kernel hits each input within the memory horizon of the network. However, due to the extreme sparsity of the formulation, it is difficult to estimate the effective amount of processing applied to the input. In addition, this layout ties together (\textit{i}) the memory horizon, (\textit{ii}) the depth, and (\textit{iii}) the layer-wise dilation factors of the network, which effectively constraints the flexibility of the neural architecture design.
\end{itemize}
In contrast to the (dilated) discrete convolutions presented in this section, our proposed formulation allows handling arbitrarily long sequences with arbitrarily large, dense memory horizons in a single layer and under a fixed parameter budget.
\vspace{-2mm}
\section{Continuous Kernel Convolution}\label{sec:continuous_kernel_conv}
\vspace{-2mm}
In this section, we introduce our approach. First, we define it formally, analyze its properties, illustrate its connection to recurrent units, and elaborate on the functional family they can describe. Next, we discuss concrete parameterizations of continuous convolutional kernels, illustrate their connection to implicit neural representations, and show that our final kernels are able to fit complex functions.
\vspace{-2mm}
\subsection{Formulation and Properties}\label{sec:overview}
\vspace{-2mm}
\textbf{Arbitrarily large convolutional kernels.} We formulate the convolutional kernel $\boldsymbol{\psi}$ as a continuous vector-valued function parameterized by a small neural network \mlp$^{\boldsymbol{\psi}}: \sR \rightarrow \sR^{\Nt_{\mathrm{out}} \times \Nt_{\mathrm{in}}}$ (Fig.~\ref{fig:ckconv}, left).\break \mlp$^{\boldsymbol{\psi}}$ receives a relative position $(t {-}\tau)$ and outputs the value of the convolutional kernel at that position $\boldsymbol{\psi}(t {-} \tau)$. As a result, an arbitrarily large convolutional kernel $\gK {=} \{\boldsymbol{\psi}(t {-} \tau)\}_{\tau {=} 0}^{\Nt_{\Kt}}$ can be constructed by providing an equally large sequence of relative positions $\{ t {-} \tau \}_{\tau = 0}^{\Nt_{\Kt}}$ to \mlp$^{\boldsymbol{\psi}}$.
For $\Nt_{\Kt} {=} \Nt_{\Xt}$, the size of the resulting kernel is equal to that of the input sequence $\gX$, and thus it is able to model (global) long-term dependencies.
The \textit{Continuous Kernel Convolution} (CKConv) is given by:
\begin{equation}
\setlength{\abovedisplayskip}{2pt}
\setlength{\belowdisplayskip}{3pt}
    (\xv * \boldsymbol{\psi}) (t) = \sum_{\ct = 1}^{\Nt_{\mathrm{in}}} \sum_{\tau = 0}^{t} x_{\ct}(\tau) \texttt{MLP}^{\boldsymbol{\psi}}_{\ct}(t - \tau).
\end{equation}
\textbf{Irregularly sampled data.} CKConvs are able to handle irregularly-sampled and partially observed data. To this end, it is sufficient to sample \mlp$^{\boldsymbol{\psi}}$ at positions for which the input signal is known and perform the convolution operation with the sampled kernel. For very non-uniformly sampled inputs, an inverse density function over the samples can be incorporated in order to provide an unbiased estimation of the convolution response (see Appx. \ref{appx:irregularly_sampled}, \citet{wu2019pointconv} for details). 


\textbf{Data at different resolutions.} CKConvs can also process data at different resolutions. Consider the convolution $(\xv *\boldsymbol{\psi})_\mathrm{sr_1}$ between an input signal $\xv$ and a continuous convolutional kernel $\boldsymbol{\psi}$ sampled at a sampling rate $\mathrm{sr}_1$. Now, if the convolution receives the same input signal sampled at a different sampling rate $\mathrm{sr}_2$, it is sufficient to sample the convolutional kernel at the sampling rate $\mathrm{sr_2}$ in order to perform an \enquote{equivalent} operation:~$(\xv *\boldsymbol{\psi})_\mathrm{sr_2}$. As shown in Appx.~\ref{appx:diff_sampling_rates}, it holds that:
\begin{equation}\label{eq:diff_sampling_rates}
\setlength{\abovedisplayskip}{3pt}
\setlength{\belowdisplayskip}{3pt}
    (\xv *\boldsymbol{\psi})_\mathrm{sr_2}(t) \approx \frac{\mathrm{sr_2}}{\mathrm{sr_1}}(\xv *\boldsymbol{\psi})_\mathrm{sr_1}(t).
\end{equation}
That is, convolutions calculated at different resolutions $\mathrm{sr_1}$ and $\mathrm{sr_2}$ are approximately equal up to a factor given by the resolution change. As a result, CKCNNs \emph{(i)} can be trained in datasets with data at varying resolutions, and \emph{(ii)} can be deployed at resolutions other than those seen during training.

We note that the previous features are hardly attainable by regular architectures, with an exception being RNNs with continuous-time interpretations, e.g., \citet{gu2020hippo,kidger2020neural}.

\begin{figure}
     \centering
     \begin{subfigure}[b]{0.24\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/RNN_vanishing.png}
         \caption{Recurrent unit ($\lambda {\leq} 1$)}
         \label{fig:vanishing_rnn}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{0.24\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/RNN_exploding.png}
         \caption{Recurrent unit (($\lambda {\geq} 1$)}
         \label{fig:exploding_rnn}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{0.24\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/exploding_CNN.png}
         \caption{Discrete kernel}
         \label{fig:exploding_conv}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{0.24\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/exploding_CKCNN.png}
         \caption{Continuous kernel}
         \label{fig:exploding_ckconv}
     \end{subfigure}
     \vspace{-2.8mm}
        \caption{Functional family of recurrent units, discrete convolutions and CKConvs. For max. eigenvalues of $\Wm$, $\lambda{\neq}1$, recurrent units are restricted to exponentially decreasing ($\lambda {\leq} 1$) or increasing ($\lambda {\geq} 1$) functions  (Figs.~\ref{fig:vanishing_rnn},~\ref{fig:exploding_rnn}). Discrete convolutions can describe arbitrary functions within their memory horizon but are zero otherwise (Fig.~\ref{fig:exploding_conv}). Conversely, CKConvs define arbitrary long memory horizons, and thus are able to describe arbitrary functions upon the entire input sequence (Fig.~\ref{fig:exploding_ckconv}).
        \vspace{-3.5mm}}
        \label{fig:vanishing_exploding_analysis}
\end{figure}
\textbf{(Linear)~recurrent~units~are~continuous~kernel~convolutions.}~Consider~a~recurrent~unit~of~the~form:
\begin{align}
 \hv(\tau) &= \sigma (\Wm \hv(\tau - 1) + \Um \xv(\tau))\label{eq:hidden_repr_formulation}\\[0 \jot]
 \tilde{\yv}(\tau) &= \mathrm{softmax}( \Vm \hv (\tau) ),
\end{align}
where $\Um, \Wm, \Vm$ depict the \textit{input-to-hidden}, \textit{hidden-to-hidden} and \textit{hidden-to-output} connections of the unit, $\hv(\tau)$,  $\tilde{\yv}(\tau)$ the hidden representation and the output at time-step $\tau$, and $\sigma$ a pointwise nonlinearity. As shown in Appx.~\ref{appx:linrecunitsasckconvs}, we can express the hidden representation $\hv$ of a linear recurrent unit, i.e., with $\sigma{=}\mathrm{Id}$, as a convolution between the input $\xv$ and a convolutional kernel $\boldsymbol{\psi}(\tau) {=} \Wm^{\tau} \Um$ of size equal to the input. That is, as a continuous kernel convolution with an exponentially increasing or decreasing kernel (Fig.~\ref{fig:vanishing_exploding_analysis}). Different authors show that nonlinear recurrent units are also restricted to the same functional family \citep{pascanu2013difficulty, arjovsky2016unitary, zhao2020rnn}.

\textbf{The functional family of continuous kernel convolutions.} From the previous observation, we can conclude that CKConvs are not only more general than discrete convolutions, but that the functional family they describe is also more general than that of (linear) recurrent units (Fig.~\ref{fig:vanishing_exploding_analysis}).
\vspace{-2mm}
\subsection{The Continuous Convolutional Kernel {\btt MLP}$^{\psi}$}\label{sec:ckconvkernel}
\vspace{-2mm}
\textbf{Convolutional kernels as point-wise \mlp s.} Let $\{\Delta\tau_{i}{=}(t {-} \tau_{i})\}_{i= 0}^{\Nt}$ be a sequence of relative positions. The continuous vector-valued convolutional kernel $\boldsymbol{\psi}: \sR \rightarrow \sR^{\mathrm{N_{out}}\times \mathrm{N_{in}}}$ is parameterized as a neural network \mlppsi which maps each relative position $\Delta\tau_{i}$ to the value of the convolutional kernel at that position (Fig. \ref{fig:ckconv}, left). We refer to the nonlinearity used in \mlppsi as $\sigma$.


\textbf{What kind of kernels can \mlppsi generate?} Our method relies on the assumption that the neural network \mlppsi is able to model complex dependencies densely among all elements within the memory horizon. That is, it assumes that \mlppsi is able to generate arbitrary convolutional kernels.
\begin{figure}
    \centering
    \includegraphics[width=0.70 \textwidth]{images/summary_maintext_kernelfit_2.png}
    \vspace{-2mm}
    \caption{Approximation quality of \mlp s with $\mathrm{ReLU}$, $\mathrm{LeakyReLU}$, $\mathrm{Swish}$, and $\mathrm{Sine}$ nonlinearities. Networks with (smooth) piece-wise nonlinearities are unable to approximate non-smooth, non-linear functions. $\mathrm{Sine}$ networks, on the other hand, quickly approximate all target functions to near perfection. All networks share the same structure and vary only in the nonlinearity used.
    \vspace{-3.5mm}}
    \label{fig:summary_maintext_kernelfit}
\end{figure}

To test this hypothesis, we fit existing \mlp\ parameterizations, i.e., with $\mathrm{ReLU}$, $\mathrm{LeakyReLU}$ and $\mathrm{Swish}$ nonlinearities, to long target functions of varying level of smoothness and non-linearity (Fig.~\ref{fig:splineapprox}).
We observe that existing parameterizations can approximate simple functions, e.g., Gaussian, step functions, but for increasing levels of non-linearity and non-smoothness, they fail by a large margin.\break For our analysis, this means that CKConvs with $\mathrm{ReLU}$, $\mathrm{LeakyReLU}$ and $\mathrm{Swish}$ parameterizations are \textit{not} able to represent complex input dependencies. In our ablation studies (Appx.~\ref{appx:ablation}) we verify that CKCNNs with these kernels consistently perform worse than our proposed parameterization.

\textbf{Convolutional kernels as implicit neural representations.} We notice that parameterizing a convolutional kernel with a neural network is equivalent to constructing an implicit neural representation of the kernel, with the subtle difference that our target objective is not known a-priori, but learned as part of the optimization task of the CNN. Implicit neural representations study generic ways to represent data living in low-dimensional spaces, e.g., $\sR^{2}$, via neural networks, and thus, despite this difference, constitute an interesting starting point for the parameterization of continuous convolutional kernels.\break
In particular, recent works noticed that neural networks with piece-wise activation functions are unable to model high-frequencies. To alleviate this limitation, they introduce random Fourier features \citep{tancik2020fourier} and $\mathrm{Sine}$ nonlinearities \citep{sitzmann2020implicit}.

Based on these observations, we repeat the fitting experiment for a SIREN \citep{sitzmann2020implicit}: a \mlp\ with hidden layers of the form $\yv=\mathrm{Sine}(\omega_0 [\Wm\xv + \bv])$.  That is with $\mathrm{Sine}$ nonlinearities, and a non-learnable value $\omega_0$ that serves as a prior for the oscillations of the output. 
We observe that a SIREN quickly approximates \textit{all} target functions to near perfection regardless of their grade of smoothness or nonlinearity. Even a sequence of random noise. This implies that, contrary to other parameterizations, CKConvs with SIREN kernels have the ability to model complex input dependencies across large memory horizons. Our experimental results verify this statement. Our ablation studies in Appx.~\ref{appx:ablation} show that SIREN kernels consistently outperform all other variants. In addition, our experimental results in Sec.~\ref{sec:experiments} show that \textit{shallow} CKCNNs with SIREN kernels achieve state-of-the-art across datasets of different nature, i.e., with continuous and discrete data.


\textbf{The success of $\mathrm{Sine}$ nonlinearites: A spline basis interpretation.} \citet{sitzmann2020implicit} motivates the usage of Sine nonlinearities for implicit neural representations. However, there is no clear understanding as of \textit{why} Sine nonlinearities are better suited for this task than (smooth) piece-wise nonlinearities. For the interested reader, we provide an interpretation to this phenomenon from a spline function approximation perspective in Appx.~\ref{appx:spline_interpretation}.

Of most practical relevance from this analysis is the observation that proper initialization of the network parameters, particularly of the bias term $\{\bv^{(l)}\}$, is important to create a well-spread set of basis functions suited for function approximation. For SIRENs, this is achieved by initializing the bias term uniformly across the period of each of the $\mathrm{Sine}$ components: $\bv_{i} \sim \mathcal{U}(-\pi \| \Wm_{i,:}\|^{-1},\pi \| \Wm_{i,:}\|^{-1})$. We observe that this initialization leads to better results and faster convergence for all tasks considered.

\vspace{-2.5mm}
\section{Experiments}\label{sec:experiments}
\vspace{-2mm}
We validate our approach against several existing models and across several tasks selected from the corresponding papers. Specifically, we benchmark its ability to handle long-term dependencies, data at different resolutions and irregularly-sampled data. A complete description of the datasets used as well as additional experiments and ablation studies can be found in the Appendix (Appx.~\ref{appx:datadescription},~\ref{appx:ablation}).
\footnote{Our code is publicly available at \url{https://github.com/dwromero/ckconv}.}

\textbf{Network details.} We parameterize our convolutional kernels as 3-layer SIRENs. Weight normalization \citep{salimans2016weight} leads to better and faster convergence when applied to the layers in \mlp, and we use it across all experiments. All our CKCNNs follow the structure shown in Fig.~\ref{fig:ckcnn_structure} and vary only in the number of blocks and channels. We use two residual blocks for all experiments reported in this section. Specifications on the architectures and hyperparameters used are given in Appx.~\ref{appx:expdetails}.
We speed up the convolution operations in our networks via the \textit{convolution theorem}: $(f * \psi)\hspace{-0.7mm} = \hspace{-0.3mm}\mathcal{F}^{-1}\hspace{-0.5mm}\big\{\mathcal{F}\{f\} \hspace{-0.3mm}\cdot\hspace{-0.3mm} \overline{\mathcal{F}\{\psi\}}\big\}$, with $\mathcal{F}$ the Fourier transform.



\textbf{Stress experiments.}
First, we validate that CKCNNs can readily model memory horizons of different lengths. To this end, we evaluate if a shallow CKCNN is able to solve the \textit{Copy Memory} and \textit{Adding Problem} tasks \citep{hochreiter1997long} for sequences of sizes in the range $[100, 6000]$. Success is achieved if 100\% accuracy, or a loss $\leq$ 1e-4 are obtained, for the copy memory and adding problem, respectively. Random predictions for the adding problem lead to a loss of approx. $0.17$.

Our results show that a shallow CKCNN is able to solve both problems for all sequence lengths considered without requiring structural modifications (Tab.~\ref{tab:addcopyprob}). Recurrent architectures are not able not solve the copy problem at all and could solve the sum problem up to 200 steps. TCNs with $k{=}7$, $n{=}7$ were able to solve both tasks for up to 1000 steps. However, larger lengths were out of reach as their memory horizon is constrained a priori. To handle larger sequences, TCNs must modify their network structure based on prior knowledge regarding the expected length of the input sequence. 

\textbf{Discrete sequences.} The continuous nature of our kernels might give the impression that CKCNNs are only suited for continuous data, i.e., time-series. However, $\mathrm{Sine}$ nonlinearities allow our convolutional kernels to model complex non-smooth non-linear functions (Fig.~\ref{fig:summary_maintext_kernelfit}). Consequently, we validate whether CKCNNs can be applied for discrete sequence modeling on the following tasks: \textit{sMNIST}, \textit{pMNIST} \citep{le2015simple}, \textit{sCIFAR10} \citep{trinh2018learning} and \textit{Char-level PTB} \citep{marcinkiewicz1994building}.

Shallow CKCNNs outperform recurrent, self-attention and convolutional models on sMNIST and pMNIST (Tab.~\ref{tab:smnist}). On sMNIST, a small CKCNN (100{\sc{k}} params.) achieves state-of-the-art results with a model 80$\times$ smaller than the current state-of-the-art. A wider CKCNN (1{\sc{m}} params.) slightly increases this result further. On pMNIST, we see an improvement of $0.8\%$ over the best model of size $\leq$100{\sc{k}}, and our wider shallow CKCNN achieves state-of-the-art on this dataset. For sCIFAR10, our small CKCNN obtains similar results to a self-attention model 5$\times$ bigger, and our wider variant improves performance by an additional $1\%$. Our best results are obtained with an even wider model (2.5{\sc{m}} params) with which an accuracy of $65.59\%$ is obtained. On Char-level PTB a CKCNN with 3{\sc{m}} parameters outperforms all models considered as well as the state-of-the-art: Mogrifier LSTMs \citep{melis2019mogrifier}, while being 13.3$\times$ smaller.
\begin{table}
\caption{Test results on discrete sequential datasets.}
\label{tab:smnist}
\vskip -4mm
\begin{small}
\scalebox{0.8}{
\begin{tabular}{cccccc}
\toprule
\multirow{2}{*}{\sc{Model}} & \multirow{2}{*}{\sc{Size}}  & \sc{sMNIST} & \sc{pMNIST} & \sc{sCIFAR10} & \sc{Char-PTB} \\
 &  & Acc (\%) & Acc (\%) & Acc (\%) & bpc\\
 \midrule
 TCN \citep{bai2018empirical} &70\sc{k}& \textbf{99.0} & \textbf{97.2}  & - & \textbf{1.31}$^{\dagger}$  \\
  LSTM \citep{bai2018empirical} &70\sc{k}& 87.2 & 85.7  & - & 1.36$^{\dagger}$ \\
 GRU \citep{bai2018empirical} &70\sc{k}&   96.2 & 87.3  & - & 1.37$^{\dagger}$ \\
 IndRNN \citep{li2018independently} & 83\sc{k} & \textbf{99.0} & 96.0& - & - \\
 DilRNN \citep{chang2017dilated} & 44\sc{k} & 98.0 & 96.1 & - & - \\
 \midrule
 HiPPO \citep{gu2020hippo} & 0.5\sc{m} & - & \textbf{98.30} & - & - \\
  r-LSTM \citep{trinh2018learning} & 0.5\sc{m} & 98.4 & 95.2 & 72.2 & - \\
 Self-Att. \citep{trinh2018learning} &0.5\sc{m} & 98.9 & 97.9 & 62.2 & - \\
 TrellisNet \citep{bai2018trellis}& 8\sc{m} & \textbf{99.20} & 98.13 & \textbf{\underline{73.42}} & \textbf{1.158}$^{\dagger}$\\
\midrule
CKCNN & 98\sc{k} & \textbf{99.31} & \textbf{98.00} & 62.25 & - \\
CKCNN-Big & 1\sc{m} & \textbf{\underline{99.32}} & \textbf{\underline{98.54}} & 63.74 & \textbf{\underline{1.045}}$^{\dagger}$\\
\bottomrule
\multicolumn{6}{l}{$^{\dagger}$ Model sizes are 3{\sc{m}} for TCN, LSTM and GRU, 13.4{\sc{m}} for TrellisNet and 1.8{\sc{m}} for CKCNN-Big.}
\end{tabular}}
\end{small}
\vspace{-3mm}
\end{table}
\begin{table}
\RawFloats
\centering
\begin{minipage}{0.44 \textwidth}
\begin{center}
\caption{Evaluation on stress tasks. {\color{Green}\cmark} marks if the problem has been solved.}
\label{tab:addcopyprob}
\vskip -3mm
\begin{small}
\scalebox{0.8}{
\begin{tabular}{ccccccc}
\toprule
\multirow{2.5}{*}{\sc{Model}} & \multirow{2.5}{*}{\sc{Size}} & \multicolumn{5}{c}{\sc{Seq. Length}} \\
\cmidrule{3-7}
 & & $100$  & $200$  & $1000$ & $3000$ & $6000$  \\
 \toprule
 \multicolumn{7}{c}{\sc{{Copy Memory}}} \vspace{0.5mm}\\
 GRU &16\sc{k}& - & - & - & - & - \\
 TCN &16\sc{k}& {\color{Green}\cmark }  & {\color{Green}\cmark } & {\color{Green}\cmark } & - & -  \\
CKCNN & 16\sc{k} & {\color{Green}\cmark }& {\color{Green}\cmark}& {\color{Green}\cmark } & {\color{Green}\cmark } &{\color{Green}\cmark } \\
\toprule
\multicolumn{7}{c}{\sc{{Adding Problem (Loss)}}} \vspace{0.5mm}\\
 GRU &70\sc{k}& {\color{Green}\cmark } & {\color{Green}\cmark }  & - \\
  TCN &70\sc{k}& {\color{Green}\cmark } &{\color{Green}\cmark } & {\color{Green}\cmark } & - & - \\
CKCNN & 70\sc{k} &{\color{Green}\cmark } &{\color{Green}\cmark } & {\color{Green}\cmark } & {\color{Green}\cmark } & {\color{Green}\cmark }  \\
\bottomrule
\end{tabular}}
\end{small}
\end{center}
\end{minipage}\hfill
\begin{minipage}{0.53 \textwidth}
\centering
\caption{Test accuracies on CT, SC and SC\_raw.}
\label{tab:timeseries}
\begin{center}
\vskip -5mm
\begin{small}
\scalebox{0.8}{
\begin{tabular}{cccccc}
\toprule
\sc{Model} & \sc{Size} & \sc{CT} & \sc{SC} & \sc{SC\_raw} \\
 \midrule
GRU-ODE &  \multirow{2}{*}{89\sc{k}} &  \multirow{2}{*}{96.2} &  \multirow{2}{*}{44.8} &  \multirow{2}{*}{$\sim$ 10.0} \\
 \citep{de2019gru} \\
GRU-$\Delta t$ & \multirow{2}{*}{89\sc{k}} & \multirow{2}{*}{97.8} & \multirow{2}{*}{20.0} &  \multirow{2}{*}{$\sim$ 10.0} \\
 \citep{kidger2020neural}\\
GRU-D & \multirow{2}{*}{89\sc{k}} & \multirow{2}{*}{95.9} & \multirow{2}{*}{23.9} &  \multirow{2}{*}{$\sim$ 10.0} \\
 \cite{che2018recurrent} \\
ODE-RNN & \multirow{2}{*}{88\sc{k}} & \multirow{2}{*}{97.1} & \multirow{2}{*}{93.2} &  \multirow{2}{*}{$\sim$ 10.0}\\
 \citep{rubanova2019latent}\\
NCDE & \multirow{2}{*}{89\sc{k}} & \multirow{2}{*}{98.8} & \multirow{2}{*}{88.5} &  \multirow{2}{*}{$\sim$ 10.0} \\
  \citep{kidger2020neural}\\
 \midrule
 CKCNN & 100\sc{k}& \textbf{99.53} & \textbf{95.27} & \textbf{71.66}\\
\bottomrule
\end{tabular}}
\end{small}
\end{center}
\end{minipage}
\vspace{-2mm}
\end{table}

\textbf{Time-series modeling.} Next, we evaluate CKCNNs on time-series data. To this end, we consider the \textit{CharacterTrajectories (CT)} \citep{bagnall2018uea} and the \textit{Speech Commands (SC)} \citep{warden2018speech} datasets. We follow \citet{kidger2020neural} to obtain a balanced classification dataset with precomputed mel-frequency cepstrum coefficients. In addition, we evaluate the ability of CKCNNs to model long-term dependencies by training on the raw SC dataset (\textit{SC\_raw}), whose records have length 16k.

We compare CKCNNs with representative sequential models with continuous-time interpretations: GRU-ODE \citep{de2019gru}, GRU-$\Delta t$ \citep{kidger2020neural}, ODE-RNN \citep{rubanova2019latent}, and NCDE \citep{kidger2020neural}. Continuous-time sequential models were selected as they are only sequential methods also able to handle irregularly-sampled data, and data at different resolutions. 
Our results show that shallow CKCNNs outperform all continuous-time models considered for both the CT and SC datasets (Tab.~\ref{tab:timeseries}). In addition, CKCNNs obtain promising results on SC\_raw, which validates their ability to handle very-long-term dependencies. In fact, CKCNNs trained on SC\_raw are able outperform several Neural ODE models trained on the preprocessed data (SC).

In addition, we observed that neural ODE methods considered in Tab.~\ref{tab:timeseries} were prohibitively slow for long sequences. For instance, NCDEs were $228\times$ slower than a CKCNN of equivalent size on SC\_raw, taking 17 hours per epoch to train. Consequently, training a NCDE on SC\_raw for a matching number of epochs would take more than $212$ days to conclude. In order to provide results for these models, we train them under the same computational budget than CKCNNs. This is enough to train them for a single epoch. All obtained results are at best only marginally better than random.

\textbf{Testing at different sampling rates.} We now consider the case where a network is trained with data at a sampling rate $\mathrm{sr}_1$, and tested with data at a different sampling rate $\mathrm{sr}_2$. Our results show that the performances of CKCNNs remains stable for large sampling rate fluctuations (Tab.~\ref{tab:diffsr}). This behaviour contrasts with most previous continuous-time models, whose performance rapidly decays upon these changes. CKCNNs outperform HiPPO \citep{gu2020hippo} and set a new state-of-the-art in this setting. Importantly, depending on the sampling, additional care may be needed to account for spatial displacements and high-frequencies of our kernels (see Appx.~\ref{appx:spatialdisplacement} for details).

\textbf{Irregularly-sampled data.} To conclude, we validate CKCNNs for irregularly-sampled data. To this end, consider the PhysioNet sepsis challenge \citep{reyna2019early} as well as the CT dataset with drops of 30\%, 50\% and 70\% of the data as in \citet{kidger2020neural}. In addition, we provide results under the same methodology for the SC\_raw dataset. As in \cite{kidger2020neural} we add an additional channel to the input to indicate whether the value at that position is known. \begin{table}
\centering
\caption{Test results on irregular data.}
\label{tab:irregsampled}
\begin{center}
\vskip -4mm
\begin{small}
\scalebox{0.81}{
\begin{tabular}{cccccccccc}
\toprule
\multirow{2.5}{*}{\sc{Model}} &\multirow{1.5}{*}{\sc{PhysioNet}} & \multicolumn{4}{c}{\sc{{CharacterTrajectories}}} & \multicolumn{4}{c}{\sc{{SpeechCommands\_raw}}} \\
\cmidrule{3-6}
\cmidrule{7-10}
& AUC & \sc{(0\%)} & \sc{(30\%)} & \sc{(50\%)} & \sc{(70\%)} & \sc{(0\%)} & \sc{(30\%)} & \sc{(50\%)} & \sc{(70\%)} \\
 \midrule
 GRU-ODE & 0.852 & 96.2 & 92.6 & 86.7 & 89.9 & $\sim$ 10.0 & $\sim$ 10.0 & $\sim$ 10.0 & $\sim$ 10.0 \\
 GRU-$\Delta t$ & 0.878 & 97.8 & 93.6 & 91.3 & 90.4 & \multirow{4}{*}{$\vdots$} & \multirow{4}{*}{$\vdots$}  & \multirow{4}{*}{$\vdots$}  & \multirow{4}{*}{$\vdots$} \\
 GRU-D  & 0.871 & 95.9 & 94.2 & 90.2 & 91.9 \\
 ODE-RNN & 0.874 & 97.1 & 95.4 & 96.0 & 95.3 \\
 NCDE & 0.880 & 98.8  & 98.7 & \textbf{98.8} & \textbf{98.6}\\
 CKCNN & \textbf{0.895} & \textbf{99.53} & \textbf{99.30} & \textbf{98.83} & 98.14 & \textbf{71.66} & \textbf{63.46} & \textbf{60.55} & \textbf{57.50}  \\
\bottomrule
\end{tabular}}
\end{small}
\end{center}
\vspace{-4mm}
\end{table}
\begin{table}
\centering
\caption{Results for different train and test resolutions. Fractions depict resolutions proportional to the original one of the dataset. The accuracy of all models on the original resolution surpasses $90\%$.}
\label{tab:diffsr}
\begin{center}
\vskip -3mm
\begin{small}
\begin{sc}
\scalebox{0.85}{
\begin{tabular}{ccccccc}
\toprule
 \multicolumn{7}{c}{\textbf{CKCNN} -- Size${=}${100k}}\\
 \toprule
 \multirow{2}{*}{Dataset} & \multirow{2}{*}{Train Freq.} & \multicolumn{5}{c}{Test Freq.}\\
 \cmidrule{3-7}
 & & $1$ & $\nicefrac{1}{2}$ & $\nicefrac{1}{4}$ & $\nicefrac{1}{8}$ & $\nicefrac{1}{16}$ \\
 \midrule
 \multirow{3}{*}{CT} & $1$ & \textbf{99.53} & 99.30 & 99.30 & 95.80 & 76.45 \\
 & $\nicefrac{1}{2}$ & 98.83 & \textbf{99.07} & 98.37 &96.97 & 80.42 \\
 & $\nicefrac{1}{4}$ & 96.74 & 96.97 & \textbf{99.30} &98.83 &84.85  \\
 & $\nicefrac{1}{8}$ & 96.97 & 97.44 & 97.20 & \textbf{99.30} & 73.43 \\
  \midrule
 \multirow{3}{*}{SC\_raw} & $1$ & \textbf{71.66} & 65.96 & 52.11 & 40.33 & 30.87\\
  & $\nicefrac{1}{2}$& 72.09 & \textbf{72.06} & 69.03 & 63.00 & 29.67 \\
 & $\nicefrac{1}{4}$ & 68.25 & 68.40 & \textbf{69.47} & 67.09 & 37.91\\
 & $\nicefrac{1}{8}$ & 40.48 & 42.00 & 54.91 & \textbf{66.44} & 22.29\\
 \bottomrule
\end{tabular}}
\vskip -0mm
\scalebox{0.81}{
\begin{tabular}{ccccccc}
\toprule
\multicolumn{7}{c}{\textbf{Model Comparison - Character Trajectories}}\\
\toprule
 Model  & GRU-D & ODE-RNN & LMU & NCDE & HiPPO & CKCNN \\
\midrule
$1 \rightarrow \nicefrac{1}{2}$  &23.1 & 41.8 & 44.7 & 6.0 & 88.8 & \textbf{99.30} \\
$\nicefrac{1}{2} \rightarrow 1$ & 25.5 & 31.5 & 11.3 & 13.1 & 90.1 & \textbf{98.83} \\
\bottomrule
\end{tabular}}
\end{sc}
\end{small}
\end{center}
\vspace{-3mm}
\end{table}

Our results show that CKCNNs outperform NCDEs and obtain state-of-the-art performance on the PhysioNet dataset.  In addition, CKCNNs exhibit stable performance for varying quantities of missing data, and perform better than several models explicitly developed to this end (Tab.~\ref{tab:irregsampled}). On the CT dataset, NCDEs perform slightly better than CKCNNs for large data drop rates. However, we argue that our method is still advantageous due to the gains in training speed --see Section~\ref{sec:discussion} for details--.
\vspace{-2mm}
\section{Discussion and Limitations}\label{sec:discussion}
\vspace{-2mm}
\textbf{Parameter-efficient large convolutional kernels.}  CKConvs construct large complex kernels with a fixed parameter budget. For large input sequences, this results in large savings in the number of parameters required to construct global kernels with conventional CNNs. For sequences from the pMNIST (length {=} 784) and SC\_raw (length {=} 16000) datasets, a conventional CNN with global kernels would require 2.14{\sc{m}} and 46.68{\sc{m}} of parameters, respectively, for a model equivalent to our CKCNN (100{\sc{k}}). In other words, our kernel parameterization allows us to construct CKCNNs that are $21,84$ and $445,71$ times smaller than corresponding conventional CNNs for these datasets. 
Detailed exploration on the effect of our efficient  continuous kernel parameterizations in optimization, overfitting and generalization is an interesting direction for future research.

\textbf{Is depth important? Shallow global memory horizons.} Our results are obtained with CKCNNs built with two residual blocks only. Additional experiments (Appx.~\ref{appx:depthvsshallow}) indicate that our models do not benefit from larger depth, and suggest that CKCNNs do not rely on very deep features. Though further analysis is required to draw consistent conclusions, it is intriguing to explore if it is sufficient to equip neural networks with global memory horizons even if this happens in a shallow manner.

\textbf{High-frequency components.} Interestingly, our kernels often contain frequency components higher than the resolution of the grid used during training (Fig.~\ref{fig:high_freq}). As a result, transitions to finer resolutions benefit from smoothing (see Appx.~\ref{appx:high_freq}). Nevertheless, we believe that, if tuned properly, these high-frequency components might prove advantageous for tasks such as super-resolution and compression.

\textbf{Faster continuous-time models.} CKCNNs rely on convolutions, and thus can be executed in parallel. As a result, CKCNNs can be trained faster than recurrent architectures. This difference becomes more pronounced with concurrent continuous-time models for sequential data, which are based on neural ODEs and require at least 5$\times$ slower than RNNs \citep{kidger2020neural}. At the cost of larger memory costs, CKCNNs can be further sped up by using the convolution theorem. 

\textbf{Neural networks parameterizing spatial functions should be able to model high-frequencies.} 
Our findings indicate that, common nonlinearities do not provide MLPs modelling spatial continuous functions the ability to model high-frequencies. Consequently, architectures that model continuous spatial functions via neural networks should transition towards models endowed with this ability, e.g., MLPs with $\mathrm{Sine}$ nonlinearities. These models encompass convolutional networks with continuous kernels, e.g., \cite{schutt2017schnet, thomas2018tensor, wu2019pointconv}, positional encodings in transformers, e.g., \cite{romero2020group, hutchinson2020lietransformer}, and graph neural networks, e.g., \cite{defferrard2020deepsphere}. $\mathrm{Sine}$ nonlinearities can be used to reduce the number of parameters needed to model local functions, or to extend the receptive field of the operations efficiently.


\textbf{Memory requirements.}  Although, CKCNNs can be deployed and trained in parallel, CKCNNs must store the convolution responses at each layer and for all input positions. This induces a linear memory complexity with regard to the sequence length, and largely contrasts with recurrent continuous-time models, whose memory complexity is constant. The memory consumption of the operation is further incremented if the convolution theorem is applied because it requires multiplying the Fourier transform of the convolution and the kernel, and taking them back to the temporal representation.
On the other hand, large convolutional kernels seem to allow CNNs to perform well without using many layers, which has a positive effect on memory consumption.

\textbf{Selection of $\boldsymbol{\omega_0}$.} We observe that CKCNNs are very susceptible to the selection of $\omega_0$. For instance, performance on pMNIST may vary from $98.54$ to $65.22$ for values of $\omega_0$ in $[1, 100]$. Consequently, finding a good value of $\omega_0$ induces an important cost in hyperpararameter search (see Appx.~\ref{appx:hyperparams}). 
$\omega_0$ acts as a prior on the variability of the target function. However, it is not obvious which value of $\omega_0$ is optimal for the internal (unknown) features of a network. Learning layer-wise $\omega_0$ values yielded sub-optimal results, and better results were obtained by using a predefined $\omega_0$ value across all layers.


\vspace{-2mm}
\section{Conclusion and Future Work}
\vspace{-2mm}
We introduced the Continuous Kernel Convolution (CKConv), a simple, yet powerful approach able to model global long-term dependencies effectively in a parameter-efficient manner. Aside from the ability to get good accuracy, CKConvs are readily able to handle irregularly-sampled data, and data at different resolutions. CKCNNs achieve state-of-the-art results on multiple datasets, and often surpass neural architectures designed for particular settings, e.g., for irregularly-sampled data. 

We are intrigued about the potential of CKCNNs for tasks in which (global) long-term dependencies play a crucial role, e.g., audio, video, reinforcement learning, (autoregressive) generative modeling. The usage of CKConvs to model long-term interactions in images is also very promising.
 In addition, CKConvs provide a convenient way to study the effect of the receptive field size of convolutional architectures, as no network modifications are required for different sizes. Our findings may also be useful for specific problems with irregularly-sampled data, e.g., medical, point clouds. We are also excited about structural advances of CKConvs. For instance, attentive versions of CKCNNs, or formulations that further improve computation and parameter efficiency

 \textbf{Alleviating limitations.} Reducing the memory consumption of CKConvs is vital for its application on a broad range of scenarios, e.g., embedded devices. Moreover, finding kernel parameterizations more stable to hyperparameter changes is desirable to reduce the need for hyperparameter search.
 
 \textbf{What is the best implicit kernel parameterization for convolutional kernels?} Despite the success of SIRENs, we believe that better kernel parameterizations might still be constructed, e.g., with Random Fourier Features \citep{tancik2020fourier}. Aside from improvements in implicit neural representations, which are directly transferable to CKConvs, we consider important to analyze the effect that having unknown, changing target objectives has on the approximation. A thorough empirical study of possible kernel parameterizations is an important direction for future research. A parameterization with which additional desiderata, e.g., smoothness, can be imposed is also desirable.
\newpage
\section*{Reproducibility Statement}
We believe in reproducibility. In order to make our paper reproducible, we have release the source code used in our experiments to the public. In addition to the code, our repository includes the explicit command lines used to execute each of our experiments, as well as the corresponding pretrained models. Appx.~\ref{appx:expdetails} provides the experimental details of our approach. This section includes details regarding the hardware used, the specification of neural architecture as well as the inputs of \mlppsi. It also states the method used for hyperparameter tuning and the hyperparameters of our final models. Details regarding the smoothing of high-frequency artifacts are also provided in this section. Details regarding the datasets and any preprocessing steps used are provided in Appx.~\ref{appx:datadescription}. The proofs of our claims can be found in Appx.~\ref{appx:properties}.

\section*{Acknowledgements}
We gratefully acknowledge Gabriel Dernbach for interesting analyses on the knot distribution of ReLU networks.
We thank Emiel van Krieken and Ali el Hasouni as well
for interesting questions and motivating comments at the
beginning of this project.

David W. Romero is financed as part of the Efficient Deep
Learning (EDL) programme (grant number P16-25), partly
funded by the Dutch Research Council (NWO) and Semiotic
Labs. Anna Kuzina is funded by the Hybrid Intelligence
Center, a 10-year programme funded by the Dutch Ministry
of Education, Culture and Science through the Netherlands
Organisation for Scientific Research. Erik J. Bekkers is
financed by the research programme VENI (grant number
17290) funded by the Dutch Research Council. All authors
sincerely thank everyone involved in funding this work.

This work was carried out on the Dutch national einfrastructure with the support of SURF Cooperative

\bibliography{iclr2022_conference}
\bibliographystyle{iclr2022_conference}

\newpage
\appendix

\section*{{\LARGE Appendix}} \vspace{2mm}

\section{Properties of CKConvs}\label{appx:properties}

\subsection{Very Irregularly Sampled Data}\label{appx:irregularly_sampled}
CKConvs can readily handle irregularly-sampled, and partially observed data. This is a result of the convolutional kernel \mlp$^{\boldsymbol{\psi}}$ being able to be sampled at arbitrary positions. For very non-uniformed sampled inputs, however, the corresponding sampling of the convolutional kernel can provide a biased estimation of the operation. To overcome this, one can follow the strategy proposed by \citet{wu2019pointconv}, which we summarize here for completeness.

For very non-uniformly sampled inputs, the continuous convolution $(x * \psi)(t) = \int_{\sR} x(\tau) \psi(t - \tau) \, \du \tau$, must account for the distribution of samples in the input. Specifically, it is reformulated as:
\begin{equation}
\setlength{\abovedisplayskip}{3.5pt}
\setlength{\belowdisplayskip}{3.5pt}
     (x * \psi)(t) = \int_{\sR} s(\tau) x(\tau) \psi(t - \tau) \, \du \tau, \label{eq:irreg_sampled}
\end{equation}
where $s(\tau)$ depicts the inverse sample density of the input at point $\tau$. Intuitively, $s(\tau)$ controls the contribution of points $x(\tau)$ to the output response. If multiple points are close to one another, their contribution should be smaller than the contribution of points in regions where the sample distribution is much sparser. This provides a Monte Carlo estimate of $(x * \psi)$ from biased samples. In particular, one has that:
\begin{equation*}
\setlength{\abovedisplayskip}{-2pt}
\setlength{\belowdisplayskip}{3.5pt}
    \int \hspace{-1mm} f(\tau) \, \du \tau= \int \hspace{-1mm} \frac{f(\tau)}{p(\tau)} p(\tau) \, \du \tau \approx \sum_{i}\frac{f(\tau_i)}{p(\tau_i)}, \ \text{for}\  \tau_{i} \sim p(\tau). 
\end{equation*}
With  $s(\tau) = \tfrac{1}{p(\tau)}$, Eq.~\ref{eq:irreg_sampled} provides an unbiased estimation of $(x * \psi)$.
\subsection{Data Sampled at Different Sampling Rates}\label{appx:diff_sampling_rates}

In addition, CKConvs are readily able to handle data at different resolutions. In particular, the continuous kernel convolution between an input signal $\xv$ and a continuous convolutional kernel $\boldsymbol{\psi}$ calculated at sampling rates $\mathrm{sr}_1$: $(\xv *\boldsymbol{\psi})_\mathrm{sr_1}$, and $\mathrm{sr_2}$: $(\xv *\boldsymbol{\psi})_\mathrm{sr_2}$, are approximately equal up to a normalization factor given by $\tfrac{\mathrm{sr_2}}{\mathrm{sr_1}}$:
\begin{equation*}
\setlength{\abovedisplayskip}{3.5pt}
\setlength{\belowdisplayskip}{3.5pt}
    (\xv *\boldsymbol{\psi})_\mathrm{sr_2}(t) \approx \frac{\mathrm{sr_2}}{\mathrm{sr_1}}(\xv *\boldsymbol{\psi})_\mathrm{sr_1}(t).
\end{equation*}
Consequently, CKCNNs \emph{(i)} can be deployed at sampling rates different than those seen during training, and \emph{(ii)} can be trained on data with varying spatial resolutions. The later is important for tasks in which data can be given at different resolutions such as super-resolution and segmentation. 

\textit{Proof.} To prove the previous statement, we start with the continuous definition of the convolution:
\begin{equation*}
\setlength{\abovedisplayskip}{3.5pt}
\setlength{\belowdisplayskip}{3.5pt}
    (x * \psi)(t) = \int_{\sR} x(\tau) \psi(t - \tau) \, \du \tau,
\end{equation*}
where we assume for simplicity and without loss of generality that the functions $x$, $\psi$ are scalar-valued. 

In practice, an integral on a continuous function $f: \sR \rightarrow \sR$ cannot be computed on finite time. Consequently, it is approximated via a Riemann integral defined on a finite grid $\{ \tau_{\mathrm{sr}, i} \}_{i = 1}^{\Nt_\mathrm{sr}}$ obtained by sampling $\tau$ at a sampling rate $\mathrm{sr}$:
\begin{equation*}
\setlength{\abovedisplayskip}{1pt}
\setlength{\belowdisplayskip}{1pt}
    \int f(\tau) \, \du \tau \approx \sum_{i = 1}^{\Nt_\mathrm{sr}} f(\tau_{\mathrm{sr}, i}) \Delta_{\mathrm{sr}},
\end{equation*}
where $\Delta_{\mathrm{sr}} = \tfrac{1}{\mathrm{sr}}$ depicts the distance between sampled points. For two sampling rates $\mathrm{sr}_1$, $\mathrm{sr}_2$, the convolution can be approximated through the corresponding Riemann integrals:
\begin{align}
\setlength{\abovedisplayskip}{0pt}
\setlength{\belowdisplayskip}{0pt}
   \int_{\sR} x(\tau) \psi\big(t - \tau) \,  \du \tau  & \approx \sum_{i = 1}^{\Nt_{\mathrm{sr}_{1}}} x(\tau_{\mathrm{sr}_{1}, i}) \psi\big(t - \tau_{\mathrm{sr}_{1}, i}) \Delta_{\mathrm{sr}_{1}}  \nonumber \\[-0.5\jot]
    & \approx \sum_{i = 1}^{\Nt_{\mathrm{sr}_{2}}} x(\tau_{\mathrm{sr}_{2}, i}) \psi\big(t - \tau_{\mathrm{sr}_{2}, i}) \Delta_{\mathrm{sr}_{2}}  \nonumber 
\end{align}
As a result, we have that both approximations are approximately equal to the continuous integral at positions $t$ defined on both discrete grids. By equating both approximations, we obtain that: 
\begin{align}
\setlength{\abovedisplayskip}{0pt}
\setlength{\belowdisplayskip}{0pt}
    \sum_{i = 1}^{\Nt_{\mathrm{sr_2}}} \hspace{-1mm} x(\tau_{\mathrm{sr_2}, i}) \psi\big(t - \tau_{\mathrm{sr_2}, i}) \Delta_{\mathrm{sr_2}} & \approx  \sum_{i = 1}^{\Nt_{\mathrm{sr_1}}} \hspace{-1mm} x(\tau_{\mathrm{sr_1}, i}) \psi\big(t - \tau_{\mathrm{sr_1}, i})  \Delta_{\mathrm{sr_1}} \nonumber \\[-0.5\jot]
    \underbrace{\sum_{i = 1}^{\Nt_{\mathrm{sr_2}}} \hspace{-1mm} x(\tau_{\mathrm{sr_2}, i}) \psi\big(t - \tau_{\mathrm{sr_2}, i})}_{(x * \psi)_{\mathrm{sr_2}}(t)} \tfrac{1}{\mathrm{sr_2}} & \approx \underbrace{\sum_{i = 1}^{\Nt_{\mathrm{sr}_{1}}} \hspace{-1mm} x(\tau_{\mathrm{sr_1}, i}) \psi\big(t - \tau_{\mathrm{sr_1}, i})}_{(x * \psi)_{\mathrm{sr_1}}(t)} \tfrac{1}{\mathrm{sr_1}} \nonumber \\[-0.5\jot]
    (x *\psi)_\mathrm{sr_2}(t) &\approx \frac{\mathrm{sr_2}}{\mathrm{sr_1}}(x *\psi)_\mathrm{sr_1}(t)  \nonumber
\end{align}
which concludes the proof. 
\vspace{-1mm}
\subsection{Linear Recurrent Units Are CKConvs}\label{appx:linrecunitsasckconvs}
\vspace{-1mm}
Interesting insights can be obtained by drawing connections between convolutions and recurrent units. In particular, we can show that linear recurrent units are equal to a CKConv with a particular family of convolutional kernels: exponential functions. Besides providing a generalization to recurrent units, this equality provides a fresh and intuitive view to the analysis of vanishing and exploding gradients.

\textbf{Recurrent unit.} Given an input sequence $\gX = \{ \xv(\tau) \}_{\tau = 0}^{\Nt_{\Xt}}$, a recurrent unit is constructed as:
\begin{align}
 \hv(\tau) &= \sigma (\Wm \hv(\tau - 1) + \Um \xv(\tau))\label{eq:hidden_repr_formulation}\\[0 \jot]
 \tilde{\yv}(\tau) &= \mathrm{softmax}( \Vm \hv (\tau) ),
\end{align}
where $\Um, \Wm, \Vm$ parameterize the \textit{input-to-hidden}, \textit{hidden-to-hidden} and \textit{hidden-to-output} connections of the unit. $\hv(\tau)$,  $\tilde{\yv}(\tau)$ depict the hidden representation and the output at time-step $\tau$, and $\sigma$ represents a point-wise non-linearity. 

The hidden representation $\hv$ of a \textit{linear recurrent unit}, i.e., with $\sigma{=}\mathrm{Id}$, can be written as a convolution. To see this, consider the hidden representation of the unit unrolled for $t$ steps:
\begin{equation}
\setlength{\abovedisplayskip}{0pt}
\setlength{\belowdisplayskip}{1pt}
    \hv(t) = \Wm^{t+1} \hv(-1) + \sum_{\tau = 0}^{t} \Wm^{\tau}\Um \xv(t - \tau).\label{eq:unroll_t_steps}
\end{equation}
Here, $\hv(-1)$ is the initial state of the hidden representation. We see that in fact it corresponds to a convolution between an input signal $\xv$ and a convolutional kernel $\boldsymbol{\psi}$ given by:\footnote{We discard $\hv(-1)$ as it only describes the initialization of $\hv$.}
\vspace{0.0mm}
\begin{align}
     &\ \xv = [\xv(0) , \xv(1) , ... , \xv(t - 1), \xv(t) ] \label{eq:correspondence1} \\[0 \jot]
      &\ \ \boldsymbol{\psi} =  [ \Um  , \Wm \Um,  ... ,  \Wm^{t - 1} \Um, \Wm^{t} \Um] \label{eq:correspondence2}\\[-1.5\jot]
       \hv(t)& =  \sum_{\tau=0}^{t}\xv(\tau) \boldsymbol{\psi}(t-\tau)  = \sum_{\tau=0}^{t}\xv(t - \tau) \boldsymbol{\psi}(\tau) . \label{eq:correspondence3}      
\end{align}
Drawing this equality yields some important insights:

\textbf{The cause of the exploding and vanishing gradients.} Eqs.~\ref{eq:correspondence1}-\ref{eq:correspondence3} intuitively depict the root of the exploding and vanishing gradient problem. It stems from sequence elements $\xv(t - \tau)$ $\tau$ steps back in the past being multiplied with an effective convolutional weight $\boldsymbol{\psi}(\tau) {=} \Wm^{\tau} \Um$. 
For eigenvalues of $\Wm$, $\lambda$, other than one, the resulting convolutional kernel $\boldsymbol{\psi}$ can only represent functions that either grow ($\lambda{\geq}1)$ or decrease ($\lambda{\leq}1)$ exponentially as a function of the sequence length (Figs.~\ref{fig:vanishing_rnn},~\ref{fig:exploding_rnn}).
As a result, the contribution of input values in the past either rapidly fades away or governs the updates of the model parameters. As exponentially growing gradients lead to divergence, the eigenvalues of $\Wm$ for converging architectures are often smaller than 1. This explains the effective small effective memory horizon of recurrent networks.

\textbf{Linear recurrent units are a subclass of CKConvs.} Linear recurrent units can be described as a convolution between the input and a very specific class of convolutional kernels: exponential functions (Eq.~\ref{eq:correspondence2}). In general, however, convolutional kernels are not restricted to this functional class. This can be seen in conventional (discrete) convolutions, whose kernels are able to model complex functions within their memory horizon. Unfortunately, discrete convolutions use a predefined, small kernel size, and thus possess a restricted memory horizon. This is equivalent to imposing an effective magnitude of zero to all input values outside the memory horizon (Fig.~\ref{fig:exploding_conv}). CKConvs, on the other hand, are able to define arbitrary large memory horizons. For memory horizons of size equal to the input length, CKConvs are able to model complex functions upon the entire input (Fig.~\ref{fig:exploding_ckconv}).

In conclusion, we illustrate that CKConvs are also a generalization of (linear) recurrent architectures which allows for parallel training and enhanced expressivity.

\section{An Spline Interpretation Of ReLU and Sine Networks}\label{appx:spline_interpretation}

\citet{sitzmann2020implicit} motivates the usage of Sine nonlinearities for implicit neural representations. However, there is no clear understanding as of \textbf{\textit{why}} Sine nonlinearities are better suited for this task than (smooth) piece-wise nonlinearities. Here, we provide an interpretation to this phenomenon from a spline function approximation perspective.

\subsection{Kernel Parameterization via $\mathrm{ReLU}$ Networks} \label{appx:relu}
\textbf{The importance of initialization.} There is an important
distinction between implicit neural representations and conventional neural applications regarding the assumed distribution of the input. Conventional applications assume the distribution of the input features to be centered around the origin. This is orthogonal to implicit neural representations, where the spatial distribution of the output, i.e., the value of the function being implicitly represented, is \textit{uniformly
distributed}. 

\begin{wrapfigure}{r}{7.1cm}
    \centering
    \includegraphics[width=1.0\textwidth]{images/approx_both.png}
    \caption{An step function approximated via a spline basis (left) and a periodic basis (right). As the target function is defined uniformly on a given interval, uniformly initializing the knots of the spline basis provides faster and better approximations. Periodic bases, on the other hand, periodically bend space, and thus can be tuned easier to approximate the target function at arbitrary points in space.}
    \label{fig:splineapprox}
\end{wrapfigure}
For $\mathrm{ReLU}$ networks, function approximation is equivalent to an approximation via a max-spline basis \citep{balestriero2018mad}, and its expressiveness is determined by the number of \emph{knots} the basis provides, i.e., places where a non-linearity bends the space. Naturally, the better the placing of these knots at initialization, the faster the approximation may converge. For applications in which the data is centered around zero, initializing the knots around zero is a good inductive bias.\footnote{This is why $\bv{=}\vec{0}$ is common in regular initialization schemes.} However, for spatially uniform distributed inputs, the knots should be uniformly distributed (Fig.~\ref{fig:splineapprox}). As a result, conventional initializations lead to very poor reconstructions ($\mathrm{ReLU}$ $\mathrm{0}$-$\mathrm{Init}$, Fig.~\ref{fig:summary_maintext_kernelfit}), and explicitly aggregating positional encodings to the mappings leads to important improvements, e.g, \cite{mildenhall2020nerf}.

For $\mathrm{ReLU}$ layers $\yv {=} \mathrm{max}\{\vec{0}, \Wm \xv + \bv\}$ knots appear at the point where $\vec{0} {=} \Wm \xv + \bv$. To place the knots at $\xv{=}\vec{0}$, it is sufficient to set the bias to zero: $\bv{=}\vec{0}$. For uniformly distributed knots in a range $[\xv_{\text{min}}, \xv_{\text{max}}]$, however, one must solve the $\mathrm{ReLU}$ equation for uniformly distributed points in that range: $\vec{0} {=} \Wm \xv_{\text{unif}} + \bv$. It results that $\bv {=} - \Wm \xv_{\text{unif}}$, for arbitrary values of $\Wm$.

In multilayered networks, the approximation problem can be understood as reconstructing the target function in terms of a basis $\hv^{(\Lt-1)}$. Consequently, the expressivity of the network is determined by the number of knots in $\hv^{(\Lt-1)}$. In theory, each $\mathrm{ReLU}$ layer is able to divide the linear regions of the previous layer in exponentially many sub-regions \citep{montufar2014number, serra2018bounding}, or equivalently, to induce an exponential layer-wise increase in the number of knots. For the first layer, the positions of the knots are described by the bias term, and for subsequent layers, these positions also depend on $\Wm^{(l)}$. Unfortunately, as depicted by \citet{hanin2019complexity}, slight modifications of $\{\Wm^{(l)}, \bv^{(l)}\}$ can strongly simplify the landscape of the linear regions, and thus the knots (Fig.~\ref{fig:sawtooth_hanin}). More importantly,  \citet{hanin2019complexity} showed that the number of linear regions at initialization is actually equal to a constant times the number of neurons in the network (with a constant very close to one in their experiments). In addition, they show that this behavior barely changes throughout training.

\textbf{An improved initialization scheme.} Following the previous reasoning, we explore inducing a uniformly distributed initialization of the knots. However, we observe that finding an initialization with an exponential number of knots is a cumbersome and unstable procedure. In fact, it is not always possible, and, whenever possible, it strongly restricts the values the weights $\Wm^{(l)}$ can assume.

Following the findings of \citet{hanin2019complexity}, we instead employ an initialization procedure with which the total number of knots is equal to the number of neurons of the network. 
This is obtained by replicating the initialization procedure of the first layer throughout the network: For randomly initialized weights $\Wm^{(l)}$, the bias term $\bv^{(l)}$ is given by the equality $\bv^{(l)} {=} - \Wm^{(l)} \hv^{(l)}(\xv_{\text{unif}})$, where $\xv_{\text{unif}}$ is a vector of uniformly distributed points in $[\xv_{\text{min}}, \xv_{\text{max}}]$.
Interestingly, we observe that this initialization strategy consistently outperforms the standard initialization for a large range of target functions ($\mathrm{ReLU}$ $\mathrm{Unif}$-$\mathrm{Init}$, Fig.~\ref{fig:kernelfitting_all}). Unfortunately however, we note that $\mathrm{ReLU}$ networks still show large difficulties in representing very nonlinear and non-smooth functions. In Fig.~\ref{fig:kernelfitting_all}, we illustrate that other popular nonlinearities: $\mathrm{LeakyReLU}$, $\mathrm{Swish}$, exhibit the same behavior.

\subsection{Kernel Parameterization via $\mathrm{Sine}$ Networks} \label{appx:sine}
Recently, \citet{sitzmann2020implicit} proposed to replace $\mathrm{ReLU}$ nonlinearities by $\mathrm{Sine}$ for the task of implicit neural representation learning. Based on their relation with implicit neural representations, we explore using $\mathrm{Sine}$ networks to parameterize our continuous kernels. Intriguingly, we observe that this slight modification allows our kernels to approximate \textit{any} provided function to near perfection, and leads to a consistent improvement for all tasks considered in this paper (Appx.~\ref{appx:sinevsothers}, Fig.~\ref{fig:kernelfitting_all}).  

A possible explanation to these astonishing results can be provided via our prior analysis:
\begin{figure}[t]
\includegraphics[width=.25\textwidth]{images/sawtooth_crop}\hspace{2mm}
\includegraphics[width=.25\textwidth]{images/sawtooth_perturbed_crop}
\vskip.1in
\includegraphics[width=.45\textwidth]{images/sawtooth_network.png}
\vspace{-2mm}
\caption{The sensitivity of networks with layer-wise exponential growing to slight changes. Taken from \citet{hanin2019complexity}. The sawtooth function with $2^n$ teeth (left) can be easily expressed via a $\mathrm{ReLU}$ network with $3n+4$ neurons (bottom). However, a slight perturbation of the network parameters --Gaussian noise with standard deviation $0.1$-- greatly simplifies the linear regions captured by the network, and thus the distribution of the knots in the basis (right).}
\label{fig:sawtooth_hanin}
\end{figure}

\textbf{Periodic bending of the space.} A $\mathrm{Sine}$ layer is given by: $\yv=\mathrm{Sin}(\omega_0[\Wm \xv + \bv])$, where $\omega_0$ works as a prior on the variability of the target function. Orthogonal to $\mathrm{ReLU}$ layers, $\mathrm{Sine}$ layers periodically bend the space. As a result, the same $\yv$ value is obtained for all bias values $\bv_{i}'{=} \bv_{i} + n 2\pi \| \Wm_{i,:}\|^{-1}$, $\forall n \in \sZ$. This is important from a spline approximation perspective. While for $\mathrm{ReLU}$ layers a unique value of $\bv$ exists that bends the space at a desired position, infinitely many values of $\bv$ do so for $\mathrm{Sine}$ ones. Resultantly, $\mathrm{Sine}$ layers are much more robust to parameter selection, and can be tuned to benefit pattern approximation at arbitrary --or even multiple-- positions in space (Fig.~\ref{fig:splineapprox}, right). We conjecture that this behavior leads to much more reliable approximations and faster convergence. 

\textbf{An exponentially big Fourier basis.} It is not surprising for a (large) basis of phase-shifted sinusoidal functions to be able to approximate arbitrary functions with high fidelity. This result was first observed over two centuries ago by \citet{fourier1807memoire} and lies at the core of the well-known \textit{Fourier transform}: any integrable function can be described as a linear combination of a (possibly) infinite basis of phase-shifted sinusoidal functions. \citet{sitzmann2020implicit} proposed an initialization of $\{ \Wm^{(l)} \}$ that allows for the construction of deep $\mathrm{Sine}$ networks able to periodically divide the space into exponentially many regions as a function of depth. Intuitively, approximations via $\mathrm{Sine}$ networks can be seen in terms of an exponentially large Fourier-like basis.
We conjecture that this exponential growth combined with the periodicity of sine is what allows for astonishingly good approximations: the more terms in a Fourier transform, the better the approximation becomes.

Interestingly, we find that a uniformly distributed initialization of the bias term $\bv_{i} \sim \mathcal{U}(-\pi \| \Wm_{i,:}\|^{-1},\pi \| \Wm_{i,:}\|^{-1})$ also leads to better and faster convergence for $\mathrm{Sine}$ networks.


\section{Dataset Description}\label{appx:datadescription}

\textbf{Copy Memory Problem.} The copy memory task consists of sequences of length $T +$20, for which the first 10 values are chosen randomly among the digits $\{1, . . . , 8\}$, the subsequent $T -$1 digits are set to zero, and the last 11 entries are filled with the digit 9. The goal is to generate an output of the same size of the input filled with zeros everywhere except for the last 10 values, for which the model is expected to predict the first 10 elements of the input sequence. 

\textbf{The Adding Problem.} The adding problem consists of input sequences of length $T$ and depth 2. The first dimension is filled with random values in $[0, 1]$, whereas the second dimension is set to zeros except for two elements marked by 1. The objective is to sum the random values for which the second dimension is equal to 1. Simply predicting the sum to be 1 results in a MSE of about 0.1767. 

\textbf{Sequential and Permuted MNIST.} The MNIST dataset \citep{lecun1998gradient} consists of 70{\sc{k}} gray-scale $28\times28$ handwritten digits divided into training and test sets of 60{\sc{k}} and 10{\sc{k}} samples, respectively. The sequential MNIST dataset (sMNIST) presents MNIST images as a sequence of 784 pixels for digit classification. Consequently, good predictions require preserving long-term dependencies up to 784 steps in the past: much longer than most language modelling~tasks~\citep{bai2018trellis}.

The permuted MNIST dataset (pMNIST) additionally permutes the order or the sMNIST sequences at random. Consequently, models can no longer rely on on local features to perform classification. As a result, the classification problem becomes more difficult and the importance of long-term dependencies more pronounced.   

\textbf{Sequential CIFAR10.} The CIFAR10 dataset \citep{krizhevsky2009learning} consists of 60{\sc{k}} real-world $32\times32$ RGB images uniformly drawn from 10 classes divided into training and test sets of 50{\sc{k}} and 10{\sc{k}} samples, respectively. Analogously to the sMNIST dataset, the sequential CIFAR10 (sCIFAR10) dataset presents CIFAR10 images as a sequence of 1024 pixels for image classification. This dataset is more difficult than sMNIST, as \emph{(i)} even larger memory horizons are required to solve the task, and \emph{(ii)} more complex structures and intra-class variations are present in the images \citep{trinh2018learning}. 

\textbf{CharacterTrajectories.} The CharacterTrajectories dataset is part of the UEA time series classification archive \citep{bagnall2018uea}. It consists of 2858 time series of different lengths and 3 channels representing the $x,y$ positions and the pen tip force while writing a Latin alphabet character in a single stroke The goal is to classify which of the different 20 characters was written using the time series data. The maximum length of the time-series is 182.

\textbf{Speech Commands.} The Speech Commands dataset \citep{warden2018speech} consists of 105809 one-second audio recordings of 35 spoken words sampled at $16$kHz. Following \citet{kidger2020neural}, we extract 34975 recordings from ten spoken words to construct a balanced classification problem. We refer to this dataset as \textbf{SC\_raw}. In addition, we utilize the preprocessing steps of \citet{kidger2020neural} and extract mel-frequency cepstrum coefficients from the raw data. The resulting dataset, named \textbf{SC}, consists of time series of length 161 and 20 channels. 

\textbf{PhysioNet.} The PhysioNet 2019 challenge on sepsis prediction \citep{goldberger2000physiobank, reyna2019early} is a irregularly sampled, partially observed dataset consisting of 40335 time series of variable length describing the stay of patients within an ICU. Time-series are made out of 5 static features, e.g., age, and 34 time-dependent features, e.g., respiration rate, creatinine blood concentration, and 10.3\% of the values are observed. We follow \citet{kidger2020neural} and consider the first 72 hours of a patient's stay to predict whether sepsis is developed over the course of their entire stay --which can extend for a month for some patients--. 

\textbf{PennTreeBank.} The PennTreeBank (PTB) \citep{marcinkiewicz1994building} is a language corpus which consists of 5,095K characters for training, 396K for validation and 446K for testing. On a char lever that we use in our experiment the vocabulary size is 50 characters (or the size of the alphabet, including end-of-string char). We follow \cite{bai2018empirical} in performing character-level language modeling task on this dataset.

\section{Ablation Studies}\label{appx:ablation}
In this section, we perform an ablative study of our approach. Specifically, we analyze the effect of multiple components of our network, and provide additional comparisons with alternative architectures. Specifications on the architectures and hyperparameters used are given in Appx.~\ref{appx:expdetails}.

\subsection{Using Sine Non-Linearities Over Popular Alternatives}\label{appx:sinevsothers}
As shown in Sec.~\ref{sec:ckconvkernel}, Sine nonlinearities provide astonishing improvements over equivalent networks with $\mathrm{ReLU}$ nonlinearities for function reconstruction. In this section, we provide additional experiments to highlight the suitability of Sine nonlinearities over other popular alternatives both for function approximation and the rest of the tasks considered in this work. The same architectures are used across all experiments and vary only in the nonlinearity used in \mlp$^{\boldsymbol{\psi}}$. We find that nonlinearities other than $\mathrm{Sine}$ benefit from layer normalization and thus we incorporate it in these variants.

\textbf{Case I: Function Approximation via \mlp$^{\boldsymbol{\psi}}$.} First, we evaluate the problem of function approximation in Sec.~\ref{sec:ckconvkernel}, Fig.~\ref{fig:summary_maintext_kernelfit}, for nonlinearities other than $\mathrm{ReLU}$ and $\mathrm{Sine}$. In particular, we approximate several functions with a \mlp$^{\boldsymbol{\psi}}$ network which varies only in the type of nonlinearity used: $\mathrm{ReLU}$ \citep{nair2010rectified}, $\mathrm{LeakyReLU}$ \citep{xu2015empirical}, $\mathrm{Swish}$ \citep{ramachandran2017searching}, and $\mathrm{Sine}$ \citep{sitzmann2020implicit}. 

Our results (Fig.~\ref{fig:kernelfitting_all}), illustrate that Sine provides astonishing approximation capabilities over all other nonlinearities considered. In particular, we observe that Sine is the only nonlinearity able to reconstruct very nonlinear and very non-smooth functions, while all other alternatives fail poorly.
\begin{figure*}
    \centering
    \includegraphics[width=0.99\textwidth]{images/kernelfit_all.png}
    \vspace{2mm}
    \caption{Function approximation via $\mathrm{ReLU}$, $\mathrm{LeakyReLU}$, $\mathrm{Swish}$ and $\mathrm{Sine}$ networks. All network variants perform a decent job in approximating simple functions. However, for non-linear, non-smooth functions, all networks using nonlinearities other than $\mathrm{Sine}$ provide very poor approximations. Interestingly, the uniform knot initialization proposed in Sec.~\ref{sec:ckconvkernel} provides consistent improvements for all network variants. However, despite this improvement, the approximation results remain insufficient. Contrarily, $\mathrm{Sine}$ networks quickly and seamlessly approximate all functions. All network configurations are equal up to the non-linearities used.}
    \label{fig:kernelfitting_all}
\end{figure*}

\textbf{Case II: CKCNNs with nonlinearities other than $\mathrm{Sine}$.} 
Next, we consider the case in which CKCNNs with nonlinearities other than $\mathrm{Sine}$ are used to solve the tasks considered in Sec.~\ref{sec:experiments}. In particular, we train CKCNNs on sMNIST, pMNIST, SC and SC\_raw for four different nonlinearities: $\mathrm{ReLU}$, $\mathrm{LeakyReLU}$, $\mathrm{Swish}$, $\mathrm{Sine}$. We utilize the same backbone architecture used in the main text for the corresponding dataset. 

Our results (Tab.~\ref{tab:nonlinearitiescomp}) indicate that $\mathrm{Sine}$ outperform CKCNNs using any of the other nonlinearities. 

\textbf{Analysis of the results.} Our findings indicate $\mathrm{Sine}$ is much better suited to describe continuous spatial functions via neural networks than all other nonlinearities considered. This result motivates replacing popular nonlinearities by $\mathrm{Sine}$ for applications in which neural networks are used to describe continuous positional functions. This family of models encompass --but is not restricted to-- continuous types of convolutions, e.g., \cite{schutt2017schnet, thomas2018tensor, finzi2020generalizing, fuchs2020se}, as well as positional encodings in transformers, e.g., \cite{dai2019transformer, ramachandran2019stand, romero2020group}, and graph neural networks, e.g., \cite{defferrard2020deepsphere}. We consider this result to be of large relevance to the deep learning community.

\begin{table}
\RawFloats
\centering
\begin{minipage}{0.49 \textwidth}
\centering
\caption{Test accuracies of CKCNNs with multiple \mlp$^{\boldsymbol{\psi}}$ nonlinearities. Model size ${=}$ 100{\sc{k}}.}
\label{tab:nonlinearitiescomp}
\begin{center}
\vskip -5mm
\begin{small}
\scalebox{0.8}{
\begin{tabular}{ccccc}
\toprule
\multirow{2.5}{*}{\sc{Non-Linearity}} & \multicolumn{4}{c}{\sc{Dataset}} \\
\cmidrule{2-5}
& \sc{sMNIST} & \sc{pMNIST} & \sc{SC} & \sc{SC\_raw} \\
 \midrule
 \sc{ReLU} & 81.21 & 59.15 & 94.97 & 49.15 \\
 \sc{LeakyReLU} & 80.57 & 55.85 & 95.03 & 38.67 \\
 \sc{Swish} & 85.20 & 61.77 & 93.43 & 62.23 \\
 \sc{Sine} & \textbf{99.31} & \textbf{98.00} & \textbf{95.27} & \textbf{71.66} \\
\bottomrule
\end{tabular}}
\end{small}
\end{center}
\end{minipage}\hfill
\begin{minipage}{0.49 \textwidth}
\centering
\caption{Test accuracy of CKCNNs for various depths and widths.}
\label{tab:depthcomp}
\begin{center}
\vskip -5mm
\begin{small}
\scalebox{0.8}{
\begin{tabular}{ccccc}
\toprule
 \multicolumn{5}{c}{\sc{pMNIST}} \\
\midrule
\multirow{2}{*}{\sc{Depth}} & \multicolumn{2}{c}{\sc{Fixed Width}} &  \multicolumn{2}{c}{\sc{Fixed Size}}   \\
 & \sc{Size} & \sc{Acc.}(\%) &   \sc{Size} & \sc{Acc.}(\%) \\
 \midrule
2 Blocks   & 98k & 99.21& 98k  & \textbf{99.21}\\
4 Blocks   & 225k& \textbf{99.26}& 95k  & \textbf{99.19}\\
8 Blocks   & 480k& \textbf{99.29}& 105k & 99.12\\
16 Blocks  & 990k& 99.19& 107k & 99.02\\
\bottomrule
\end{tabular}}
\end{small}
\end{center}
\end{minipage}
\vspace{-2mm}
\end{table}

\subsection{Going Deeper with CKCNNs}\label{appx:depthvsshallow}
The experimental results shown in Sec.~\ref{sec:experiments} are obtained with shallow CKCNNs composed of 2 residual blocks only. An interesting question is whether going deeper can be used to improve the performance of CKCNNs. To analyze this, we compare deep and shallow CKCNNs  with the same architecture for equal width, and equal number of parameters. 

Our results (Tab.~\ref{tab:depthcomp}) indicate that deep CKCNNs do not provide improvements over shallow CKCNNs. In fact, deep CKCNNs of fixed size underperform their shallow counterparts. This is an interesting results as shallow CKCNNs do not strongly rely on deep-wise compositionality of features, which is largely considered indispensable in deep learning. 

\textbf{Analysis of the results.} The dynamics governing these results are not yet fully understood. However, our findings may lead to two different conclusions, both of which we consider important for the development and understanding of CKCNNs and deep learning in general:

\textbf{\textit{Outcome I: Deep CKCNNs.}} The first possible outcome is that our current parameterization does not correctly leverage depth. In this case, efforts to construct proper \textit{deep} CKCNNs will likely lead to performance improvements over the current architectures, and thus have the potential to advance the state-of-the-art further.

\textbf{\textit{Outcome II: Depth is not needed when global memory horizons are provided with shallow networks.}} The second possible outcome is that depth is used mainly as a means to construct global memory horizons. Consequently, neural networks do not have to be very deep at all provided that global memory horizons are defined by shallow neural networks. Interestingly, this conclusion is in line with the predominant design of recurrent architectures, for which a moderate number of layers are used, e.g., \cite{pascanu2013construct, graves2013speech, gu2020improving, gu2020hippo}. This possible outcome is very exciting as depth is largely considered indispensable in the deep learning community.


\section{Experimental Details}\label{appx:expdetails}
In this section, we provide extended details over our implementation as well as the exact architectures and optimization schemes used in our experiments.

\subsection{General Remarks}
 Our models follow the structure shown in Fig.~\ref{fig:ckcnn_structure} and vary only in the number of channels. We use layer normalization \citep{ba2016layer} in our backbone network, and use the Adam optimizer \citep{kingma2014adam} across all our experiments. Our code is implemented in {\btt PyTorch} and is publicly available at \textit{link removed for the sake of the double-blind review}.
We utilize {\btt wandb} \citep{wandb} to log our results, and use NVIDIA TITAN RTX GPUs throughout our experiments. 

\textbf{Continuous Convolutional Kernel \mlp$^{\boldsymbol{\psi}}$.}
All our convolutional kernels are parameterized by a vector-valued 3-layer neural network with 32 hidden units and $\mathrm{Sine}$ nonlinearities: 
$$1 \rightarrow 32 \rightarrow 32 \rightarrow \Nt_{\mathrm{out}} \times \Nt_{\mathrm{in}},$$
where $\Nt_{\mathrm{in}}$, $\Nt_{\mathrm{Cout}}$ are the number of input and output channels of the convolutional layer. We utilize weight normalization \citep{salimans2016weight} in our \mlp$^{\boldsymbol{\psi}}$ networks, and select a hidden size of 32 based on empirical evidence and findings from previous works, e.g., \cite{finzi2020generalizing}.

\textbf{Normalized relative positions.} The \mlp s parameterizing our convolutional kenels receive relative positions as input. However, considering unitary step-wise relative positions, i.e., 0, 1, 2, ... , $\Nt$, can be problematic from a numerical stability perspective as $\Nt$ may grow very large, e.g., $\Nt{=}$16000 for the SC\_raw dataset. Consequently, we follow good practices from works modelling continuous functions with neural networks, and map the largest unitary step-wise relative positions seen during training $[0, \Nt]$ to a uniform linear space in $[-1, 1]$. 

\textbf{Hyperparameter tuning.} We tune the hyperparameters of our models via the {\btt bayes} method given in {\btt wandb} Sweeps, which selects hyperparameter values via a Gaussian process over the results obtained so far. We perform tuning on a validation dataset until a predefined maximum number of runs of $100$ is exhausted. Further improvements upon our results may be obtained by leveraging more sophisticated tuning methods as well as additional runs. 
 \begin{figure}
     \centering
     \includegraphics[width=0.8\textwidth]{images/net_structure.png}
     \vspace{-4mm}
     \caption{Graphical description of continuous kernel convolutional networks. Dot-lined blocks depict optional blocks, and blocks without borders depict variables. {\btt KernelNet} blocks use $\mathrm{Sine}$ nonlinearities. We replace spatial convolutions by Fourier Convolutions ({\btt FFTConv}), which leverages the convolution theorem to speed up computations.
     \vspace{-2mm}}
     \label{fig:ckcnn_structure}
 \end{figure}

\textbf{Selecting $\boldsymbol{\omega_0}$.} CKCNNs are very susceptible to the value of $\omega_0$. In order to obtain a reasonable $\omega_0$, we first perform a random search on a large interval $\omega_0 \in [0, 3000]$. After a few runs, we stop the random search and select the subinterval in which the validation accuracy is most promising. Next, we restart the random search on this sub-interval and repeat the process until a $\omega_0$ value is obtained, for which the validation accuracy is sufficiently high. Surprisingly, we found optimal values of $\omega_0$ to be always enclosed in the interval $[1, 70]$ even for very long sequences as in SC\_raw.

\subsection{Accounting for Spatial Displacements of the Sampled Convolutional Kernels}\label{appx:spatialdisplacement}
We follow the sampling procedure of
\citet{gu2020hippo} throughout our test sampling rate discrepancy experiments. Specifically, for a sequence {\btt seq} of length $\Nt$, subsampling by a factor {\btt n} is performed by running {\btt seq[::n]}. That is, by taking the {\btt n}-th element of the sequence starting from its first element. For example, for a sequence of length $\Nt{=}182$, different values of {\btt n} would yield the following sequences:

{(\btt n = 1)} $\rightarrow$ {\btt [1, 2, 3, \ ... , 180, 181, 182]}\newline
{(\btt n = 2)} $\rightarrow$ {\btt [1, 3, 5, \   ... , 177, 179, 181]}\newline
{(\btt n = 4)} $\rightarrow$ {\btt [1, 5, 9, \  ... , 173, 177, 181]}\newline
{(\btt n = 8)} $\rightarrow$ {\btt [1, 9, 17, ... , 161, 169, 177]}

Recall that \mlp$^{\boldsymbol{\psi}}$ takes normalized relative positions in $[-1, 1]$ as input, which are computed based on the max input length seen during training. However, some of these subsampling transitions \textit{change} the max value of the sequence, e.g., for {(\btt n = 8)} the maximum is given by 177, whereas for {(\btt n = 1)} this value corresponds to 182. Consequently, a naive approach would consider the last position in each subsampled sequence to correspond to the maximum normalized relative position $1$. This effectively induces an spatial displacement, and a re-scaling of the sampled convolutional kernel used during training.

This misalignment is automatically handled under the hood in our {\btt CKConv} implementation. Nevertheless, we highlight this subtle phenomenon to prevent it in future applications.

\subsection{Dealing with High-Frequency Components}\label{appx:high_freq}
Interestingly, our experiments revealed that our continuous kernels often contain frequency components of frequency higher than the resolution of the sampling grid used during training (Fig.~\ref{fig:high_freq}). As these high-frequency components are not observed during training, we observe that they hurt performance when evaluated at higher resolutions. 

In order to neutralize their influence, we filter these components before performing the convolution by means of blurring. This is performed by applying a convolution upon the convolutional kernel with a Gaussian filter $G$ of length $2 \tfrac{\mathrm{sr}_\text{test}}{\mathrm{sr}_\text{train}} + 1$ and parameters $\mu{=}0$, $\sigma{=}0.5$:
$$\Big[G\big( - \tfrac{\mathrm{sr}_\text{test}}{\mathrm{sr}_\text{train}} \big) , G\big(-\tfrac{\mathrm{sr}_\text{test}}{\mathrm{sr}_\text{train}}+1\big), ... , G\big(0\big), ... , G\big(\tfrac{\mathrm{sr}_\text{test}}{\mathrm{sr}_\text{train}}-1\big), G\big(\tfrac{\mathrm{sr}_\text{test}}{\mathrm{sr}_\text{train}}\big)\Big]$$

\vspace{-2mm}
Note that blurring is only used when the test sampling rate is higher than the train sampling rate, as opposed to the normalization factor $\tfrac{\mathrm{sr}_\text{test}}{\mathrm{sr}_\text{train}}$ discussed in Eq.~\ref{eq:diff_sampling_rates}, Appx.~\ref{appx:diff_sampling_rates}, which is applied whenever the sampling rates differ.

\subsection{Hyperparameters and Experimental Details}\label{appx:hyperparams}
In this section, we provide further specifications of the hyperparameter configurations with with our models are trained. An overview of these hyperparameters is provided in Tab.~\ref{tab:hyperparams}.

\begin{table*}[t!]
\caption{Hyperparameter specifications of the best performing CKCNN models.}
\label{tab:hyperparams}
\begin{center}
\vskip -3mm
\begin{small}
\scalebox{0.72}{
\begin{adjustbox}{center}
\begin{tabular}{lccccccccc}
\toprule
\multirow{2}{*}{\sc{Params.}} & \multirow{2}{*}{\sc{Copy Memory}} & \multirow{2}{*}{\sc{Adding Problem}} & {\sc{sMNIST}} & {\sc{pMNIST}} & {\sc{sCIFAR10}} & \multirow{2}{*}{\sc{CT$^\dagger$}} & \multirow{2.25}{*}{\sc{SC}} & \multirow{2}{*}{\sc{SC\_raw}$^\dagger$}  & \multirow{2}{*}{\sc{PTB}}   \\
 & & & Small / Big & Small / Big & Small / Big \\
\midrule
Epochs & See Appx.~\ref{appx:hyperparams} &  See Appx.~\ref{appx:hyperparams} & 200 & 200 & 200 & 200 & 200 & 300 & 200\\
Batch Size & 32 & 32 & 64 & 64 & 64 & 32 & 64 & 32 & 24\\
Optimizer & Adam & Adam & Adam & Adam & Adam & Adam & Adam & Adam & Adam\\
Learning Rate & 5e-4 & 0.001 & 0.001 & 0.001 & 0.001 & 0.001 & 0.001 & 0.001 & 0.002\\
\# Blocks & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2\\
Hidden Size & 10 & 25 & 30 / 100  & 30 / 100  & 30 / 100 & 30 & 30 & 30 & 128\\
$\omega_0$ & See Appx.~\ref{appx:hyperparams} & See Appx.~\ref{appx:hyperparams} & 31.09 / 30.5 & 43.46 / 42.16  &  25.67 & 21.45 & 30.90 & 39.45 & 25.78\\
Dropout & -  & - & 0.1 / 0.2 & - & 0.2 / 0.3  & 0.1  & 0.2 & - & - \\
Input Dropout & -  & - & 0.1 / 0.2 & 0.1 / 0.2 & 0.0 / 0.0 & -  & - & - & 0.1\\
Embedding Dropout & - & - & - & - & - & - & - & - & 0.1 \\
Weight Dropout & -  & - & - & - & - / 0.1 & - & - & -& - \\
Weight Decay & -  & - & - & - & - / 1e-4 & - & - & 1e-4 & 1e-6\\
Scheduler & -  & - & Plateau & Plateau & Plateau & Plateau & Plateau & Plateau & Plateau \\
Patience & - & - & 20 & 20 & 20 & 20  & 15 & 20 & 5\\
Scheduler Decay & - & - & 5 & 5 & 5 & 5  & 5  & 5 & 5\\
\midrule
Model Size & 15.52{\sc{k}} & 70.59{\sc{k}} & 98.29{\sc{k}} / 1.03{\sc{m}} & 98.29{\sc{k}} / 1.03{\sc{m}} & 100.04{\sc{k}} / 1.04{\sc{m}} & 100.67{\sc{k}} & 118.24{\sc{k}} &  98.29{\sc{k}}& 1.8{\sc{m}}\\ 
\bottomrule
\multicolumn{9}{l}{$^\dagger$ Hyperparameter values for the classification and varying sampling rate tasks. For hyperparameters w.r.t. irregularly-sampled data please see Tab.~\ref{tab:hyperparams_irreg}. }
\end{tabular}
\end{adjustbox}
}
\end{small}
\end{center}
\vspace{-4.0mm}

\end{table*}
 \textbf{Copy Memory.} We set the number of channels of our CKCNN as to roughly match the number of parameters of the GRU and TCN networks of \citet{bai2018empirical}. This is obtained with 10 hidden channels at every layer. We observe that the time to convergence grew proportional to the length of the sequence considered. Whereas for sequences of length 100 convergence was shown after as few as 10 epochs, for sequences of length 6000 approximately 250 epochs were required. The maximum number of epochs is set to 50, 50, 100, 200 and 300 for sequences of size 100, 200, 1000, 3000 and 6000. We observe that different values of $\omega_0$ are optimal for different sequence lengths. The optimal $\omega_0$ values found are 19.20, 34.71, 68.69, 43.65 and 69.97 for the corresponding sequence lengths.
 
\textbf{Adding Problem.} We set the number of channels of our CKCNN as to roughly match the number of parameters of the GRU and TCN networks of \citet{bai2018empirical}. This is obtained with 25 hidden channels at every layer. Similarly to the Copy Memory task, we observe that the time to convergence grew proportional to the length of the sequence considered. Interestingly, this task was much easier to solve for our models, with convergence for sequences of length 6000 observed after 38 epochs. The maximum number of epochs is set to 20, 20, 30, 50 and 50 for sequences of size 100, 200, 1000, 3000 and 6000. We observe that different values of $\omega_0$ are optimal for different sequence lengths. The optimal $\omega_0$ values found are 14.55, 18.19, 2.03, 2.23 and 4.3 for the corresponding sequence lengths. 

\textbf{sMNIST, pMNIST and sCIFAR10.} We construct two models of different sizes for these datasets: CKCNN and CKCNN-Big. The first is constructed to obtain a parameter count close to 100{\sc{k}}. The second model, is constructed to obtain a parameter count close to 1{\sc{m}}. The parameters utilized for these datasets are summarized in Tab.~\ref{tab:hyperparams}. Despite our efforts, we observed that our models heavily overfitted sCIFAR10. Combinations of weight decay, dropout and weight dropout were not enough to counteract overfitting. 

\textbf{CT, SC and SC\_raw.} The parameters utilized for classification on these datasets are summarized in Tab.~\ref{tab:hyperparams}. For hyperparameters regarding experiments with irregularly-sampled data please refer to Tab.~\ref{tab:hyperparams_irreg}. Any non-specified parameter value in Tab.~\ref{tab:hyperparams_irreg} can be safely consider to be the one listed for corresponding dataset in Tab.~\ref{tab:hyperparams}.

\textbf{PennTreeBank} For a character-level language modeling on PTB dataset we use hyperparameters specified in Tab.~\ref{tab:hyperparams}. We use embedding of size 100 following the TCN model from \cite{bai2018empirical}.

\begin{table}[t]
\centering
\caption{Hyperparameter values for experiments on irregularly sampled data. Non-listed parameters correspond to those in Tab.~\ref{tab:hyperparams}.}
\label{tab:hyperparams_irreg}
\begin{center}
\vskip -3mm
\begin{small}
\scalebox{0.69}{
\begin{tabular}{lccccccc}
\toprule
\multirow{2.5}{*}{\sc{Params.}}  & \multirow{2.5}{*}{\sc{PhysioNet}} & \multicolumn{3}{c}{\sc{CT}} & \multicolumn{3}{c}{\sc{SC\_raw}}  \\
\cmidrule{3-8}
 & & \sc{(30\%)} & \sc{(50\%)} & \sc{(70\%)} & \sc{(30\%)} & \sc{(50\%)} & \sc{(70\%)} \\
\midrule
$\omega_0$ & 4.38 & 17.24 & 12.00 & 4.24 & 35.66 & 31.70 & 25.29\\
Dropout & 0.0 & 0.2  & 0.2 & 0.0 & 0.1 & 0 & 0\\
Weight Decay & 0.0 & 0.0 & 1e-4 & 0.0 & 1e-4 & 1e-4 & 1e-4 \\ 
Batch Size & 1024 \\
\midrule
Model Size & 175.71{\sc{k}} & \multicolumn{3}{c}{101.75{\sc{k}}} & \multicolumn{3}{c}{99.34{\sc{k}}}  \\ 
\bottomrule
\end{tabular}}
\end{small}
\end{center}
\vspace{-5.0mm}
\end{table}

 \begin{figure}
     \centering
     \includegraphics[width=0.95\textwidth]{images/high_res.png}
     \vspace{-2mm}
     \caption{High-frequency components in $\mathrm{Sine}$ continuous kernels. We observe that continuous kernels parameterized by Sine networks often contain frequency components of frequency higher than the resolution of the grid used during training. Here, for instance, the kernel looks smooth on the training grid. However, several high-frequency components appear when sampled on a finer grid. Though this may be a problematic phenomenon, we believe that, if tuned properly, these high-frequency components can prove advantageous to model fine details in tasks such as super-resolution and compression cheaply.
     \vspace{-4mm}}
     \label{fig:high_freq}
 \end{figure}












\end{document}
