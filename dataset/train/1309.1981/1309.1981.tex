\documentclass{llncs}

\usepackage{llncsdoc}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{graphicx}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amssymb}
\usepackage{rotating}




\spnewtheorem{fact}{Fact}{\bfseries}{\itshape}
\spnewtheorem*{my_definition}{Definition}{\bfseries}{\itshape}

\spnewtheorem*{swap}{Problem ``SM"
 (Pattern Matching with Swaps)}{\bfseries}{\itshape}
\newcommand{\rom}[1]{\uppercase\expandafter{\romannumeral #1\relax}}




\begin{document}
\pagestyle{headings}


\pagestyle{headings}


\mainmatter

\title{The Swap Matching Problem Revisited}

\titlerunning{Lecture Notes in Computer Science}



\author{ \and  \and  \and }




\institute{AEDA Group,\\
Department of Computer Science, BUET, Dhaka,\\
\email{\{pritom.11,sohansayed\}@gmail.com, msrahman@cse.buet.ac.bd}\\
\texttt{http://teacher.buet.ac.bd/msrahman}
\and 
Algorithm Design Group,\\
Department of Computer Science, King's College London, University of London\\
\email{csi@dcs.kcl.ac.uk}\\
http://www.dcs.kcl.ac.uk/staff/csi}



\maketitle


\begin{abstract}
In this paper, we revisit the much studied problem of Pattern
Matching with Swaps (Swap Matching problem, for short). We first
present a graph-theoretic model, which
opens a new and so far unexplored avenue to solve the problem. Then,
using the model, we devise two efficient algorithms to solve the swap
matching problem. The resulting algorithms are adaptations of the
classic shift-and algorithm. For patterns having length similar to
the word-size of the target machine, both the algorithms run in linear time considering a fixed alphabet.
\end{abstract}

\keywordname{ Algorithms; Strings; Swap Matching; Graphs.}

\section{\label{intro}Introduction}
The classical pattern matching problem is to find all the occurrences of a given pattern  of length  in a text  of length , both being sequences of characters drawn from a finite character set . This problem is interesting as a fundamental computer science problem and is a basic need of many practical applications such as text retrieval, music information retrieval, computational biology, data mining, network security, among many others. In this paper, we revisit the Pattern Matching with Swaps problem (the Swap Matching problem, for short), which is a well-studied variant of the classic pattern matching problem. In this problem, the pattern  is said to  the text  at a given location , if adjacent pattern characters can be swapped, if necessary, so as to make the pattern identical to the substring of the text ending (or equivalently, starting) at location . All the swaps are constrained to be disjoint, i.e., each character is involved in at most one swap. 


Amir et al.~\cite{DBLP:journals/jal/AmirALLL00} obtained the first non-trivial results for this problem. They showed how to solve the problem in time , where . Amir et al.~\cite{DBLP:journals/ipl/AmirLLL98} also studied certain special cases for which  time solution can be obtained. However, these cases are rather restrictive. Later, Amir et al.~\cite{DBLP:journals/iandc/AmirCHLP03} solved the Swap Matching problem in time . We remark that all the above solutions to swap matching depend on Fast Fourier Transformation (FFT) technique. Recently, Cantone and Faro~\cite{CS} presented a dynammic programming approach to solve the swap matching problem which runs in linear time for finite character set , when patterns are compatible with the word size of the target machine. Notably the work of~\cite{CS} avoids the use of FFT technique. Cantone, Faro and Campanelli presented another approach in~\cite{CCS} to solve the Swap matching problem. Though the algorithm of~\cite{CCS} runs in  time for patterns compatible with the word size of the target machine, in practice it achieves quite good result. In fact as it turns out, the algorithm of~\cite{CCS} outperforms the algorithm of~\cite{CS} most of the time.  
Notably, approximate swapped matching~\cite{DBLP:journals/ipl/AmirLP02} and swap matching in weighted sequences~\cite{DBLP:conf/cis/ZhangGI04} have also been studied in the literature.





\subsection{Our Contribution}
The contribution of this paper is as follows. We first present a graph-theoretic approach to model the swap matching problem. Using this model, we devise two efficient algorithms to solve the swap matching problem. The resulting algorithms are adaptation of the classic shift-and algorithm~\cite{CharrasL04} and runs in linear time if the pattern size is similar to the size of word in the target machine, assuming a fixed alphabet size. Notably, some preliminary results of this paper were presented in~\cite{IR}. In~\cite{IR}, an algorithm running in  time was presented, where  is the machine word size. For short patterns, i.e., pattern size similar to machine word size, this runtime becomes . Hence the result in this paper clearly improves the results of~\cite{IR} and matches the result of~\cite{CS}. Finally, we present experimental results to compare the non-FFT algorithms of~\cite{CS,CCS} and our work.  



\subsection{RoadMap}
The rest of the paper is organized as follows. In Section~\ref{Pre}, we present some preliminary notations and definitions. In Section~\ref{Model}, we present our model to solve the swap matching problem. In Section~\ref{Algo}, we present two different algorithms to solve the swap matching problem. Section~\ref{experiment}, presents the experimental results. Finally, we briefly conclude in Section~\ref{conclusion}.



\section{\label{Pre}Preliminaries}
A \emph{string} is a sequence of zero or more symbols from an alphabet, . A string  of length  is denoted by , where  for . The \emph{length} of  is denoted by . A string  is called a \emph{factor} of  if  for ; in this case, the string  occurs at position  in . The factor  is denoted by . A \emph{-factor} is a factor of length . A \emph{prefix (or suffix)} of  is a factor  such that , . We define the -th prefix to be the prefix ending at position , i.e., . On the other hand, the -th suffix is the suffix starting at position , i.e., .


\begin{definition}
A \emph{swap permutation} for  is a permutation
 such that:
\begin{enumerate}
\item if  (characters are swapped).
\item for all  (only adjacent characters are swapped).
\item if  (identical characters are not
swapped).
\end{enumerate}
\end{definition}

For a given string  and a swap permutation  for , we use
 to denote the \emph{swapped version} of , where
.

\begin{definition}
Given a text  and a pattern ,  is said to swap match at location  of 
if there exists a swapped version  of  that matches  at
location\footnote{Note that, we are using the end position of the
match to identify it.} , i.e.  for
.
\end{definition}



\begin{swap}
Given a text  and a pattern , we want to find each location  such that
 swap matches with  at location .
\end{swap}

\begin{definition}\label{Def_Degenerate_String}
A string  is said to be degenerate, if it is built over the
potential  non-empty sets of letters belonging to
.
\end{definition}


\begin{example}
Suppose we are considering DNA alphabet, i.e., . Then we have 15 non-empty sets of letters belonging to . In what follows, the set containing  and  will be denoted by  and the singleton  will be simply denoted by  for ease of reading. The set containing all the letters, namely , is known as the don't care character in the literature.
\end{example}



\begin{definition}\label{Def_Degenerate_Match}
Given two degenerate strings  and  each of length , we say
 \emph{matches}  if, and only if, .
\end{definition}



\begin{example}\label{Ex_Deg_Match}
Suppose we have degenerate strings  and . Here,  matches  because . 
\end{example}
















\section{\label{Model}The Graph-Theoretic Model for Swap Matching}In this section, we propose the graph-theoretic model to solve the swap matching problem. In this model, both the text and the pattern are viewed as two separate graphs. We start with the following definitions.

\begin{definition}
The \textbf{\emph{-graph}} is defined in the following way:


Given a text  of Problem SM, a
\textbf{\emph{-graph}}, denoted by ,
is a directed graph with  vertices and  edges such that  and . For each
, we define  and for each edge , we define .
\end{definition}


Note that, the labels in the above definition may not be unique.
Also, we normally use the labels of the vertices and the edges to
refer to them.

\begin{figure}[h!]
\begin{center}

\begin{tabular}{ccccccccccccccccccccccccccccc}
a&&c&&a&&c&&b&&a&&c&&c&&b&&a&&c&&a&&c&&b&&a\\
\end{tabular}
 \caption{The corresponding -graph of Example~\ref{Ex_T_Graph}}
\label{Fig_T_Graph}
\end{center}
\end{figure}

\begin{example}\label{Ex_T_Graph}
Suppose, . Then the corresponding -graph is
shown in Figure~\ref{Fig_T_Graph}.
\end{example}

\begin{definition}


The \textbf{\emph{-graph}} is defined in the following way:



Given a text  of Problem SM, a
\textbf{\emph{-graph}}, denoted by ,
is a directed graph with  vertices and at most  edges.
The vertex set  can be partitioned into three disjoint vertex
sets, namely,  such that . The partition
is defined in a  matrix  as follows. For the sake
of notational symmetry we use  and  to denote
respectively the rows  and  of the matrix .
\begin{enumerate}
\item 
\item 
\item 
\end{enumerate}
The labels of the vertices are derived from  as follows:



\begin{enumerate}
\item For each vertex ,
label(M[-1,i]) =  

\item For each vertex 
\item For each vertex ,
label(M[+1,i]) = 


\end{enumerate}

The edge set  is defined as the union of the sets  and  as follows:

\begin{enumerate}
\item 
\item 
\item 
\end{enumerate}

The labels of the edges are derived from using the labels of the
vertices in the obvious way.
\end{definition}


\begin{figure}[hbtp]
\begin{center}
\includegraphics[width=0.8\textwidth,angle=0]{Pgraph.jpg}
\caption{-graph of the Pattern P = acbab} \label{Fig_P_Graph1}
\end{center}
\end{figure}



\begin{example}\label{Ex_P_Graph}
Suppose, . Then the corresponding -graph
 is shown in Figure~\ref{Fig_P_Graph1}.
\end{example}




\begin{definition}


Given a -graph , a path  is a sequence of consecutive
directed edges  in  starting at node  and ending at node
. The length of the path , denoted by , is the
number of edges on the path and hence is  in this case. It
is easy to note that the length of a longest path in  is .
\end{definition}

\begin{definition}


Given a -graph  and a -graph , we
say that  matches  at position  if, and only if,
there exists a path  in  having
 and  such that
for  we have .
\end{definition}



This completes the definition of the graph theoretic model. The following Lemma presents the idea to solve the swap matching problem using the presented model.


\begin{lemma}Given a pattern  of length  and a text  of length ,
suppose  and  are the -graph and -graph of  and , respectively. Then,  swap matches  at
location  of  if and only if  matches  at
position  of .
\end{lemma}

\begin{proof}
The proof basically follows easily from the definition of the
-graph. At each column of the matrix , we have all
the characters as nodes considering the possible swaps as explained
below. Each node in row  and  represents a swapped
situation. Now consider column  of  corresponding to .
According to definition, we have  and . These two nodes represents the swap of  and
. Now, if this swap takes place, then in the resulting
pattern,  must be followed by . To ensure that, in
, the only edge starting at , goes to . On
the other hand, from  we can either go to  or to
: the former is when there is no swap for the next pair
and the later is when there is another swap for the next pair.
Recall that, according to the definition, the swaps are disjoint.
Finally, the nodes in row  represents the normal (non-swapped)
situation. As a result, from each  we have an edge to
 and an edge to : the former is when there is
no swap for the next pair as well and the later is when there is a
swap for the next pair. So it is easy to see that all the paths of
length  in  represents all combinations considering all
possible swaps in . Hence the result follows.~
\end{proof}


Since the number of the possible paths of length  in  is exponential in , we exploit the above model in a different way and apply a modified version of the classic shift-and~\cite{BG92} algorithm to solve the swap matching problem.



















\section{\label{Algo}Our Algorithms for Swap Matching}
In this section, we use the model proposed in Section~\ref{Model} to devise two novel efficient algorithms for the swap matching problem. Both of the algorithms are modified versions of the classic shift-and algorithm for pattern matching. We start with a brief review of the shift-and algorithm below. In Sections~\ref{AIIR} and~\ref{NewAlgo} we present the modifications needed to adapt it to solve the swap matching problem.


\subsection{\label{shift-and}Shift-And Algorithm}
The shift-and algorithm uses the bitwise techniques and is very
efficient if the size of the pattern is no greater than the word
size of the target processor. The following description of the
shift-and algorithm is taken from~\cite{CharrasL04} after slight
adaptation to accommodate our notations.

Let  be a bit array of size . Vector  is the value of the
array  after text character  has been processed. It contains
information about all matches of prefixes of  that end at
position  in the text. So, for  we have:


The vector  can be computed after  as follows. For
each :


and



If  then a complete match can be reported. The transition from  to  can be computed very fast as
follows. For each  let  be a bit array of size 
such that for ,  if and only if .The
array  denotes the positions of the character  in the
pattern . Each  for all  can be preprocessed
before the pattern search. Then the computation of  reduces
to two simple operations, namely, \textbf{shift} and \textbf{and} as follows: 
















\subsection{The First Algorithm: SMALGO-\rom{1}}{\label{AIIR}

In this section, we present a modification of  the shift-and algorithm to solve the swap matching problem using the graph model presented in Section~\ref{Model}. In what follows the resulting algorithm shall be referenced to as SMALGO-\rom{1}. The idea of SMALGO-\rom{1} is described below.

 
First of all, the shift-and algorithm can be extended easily for the degenerate patterns~\cite{BG92}. In our swap matching model the pattern can be thought of having a set of letters at each position as follows: . Note that we have used  instead of  above because, in our case, the sets of characters in the consecutive positions in the pattern  don't have the same relation as in a usual degenerate pattern. In particular, in our case, a match at position  of  will depend on the previous match of position  as the following example shows.


\begin{example}\label{Ex_Diff}
Suppose,  and . The -graph of
 is shown in Figure~\ref{Fig_P_Graph1}. So, in line of above
discussion, we can say that . Now, as can be easily seen, if we consider
degenerate match, then  matches  at Positions 
and . However,  swap matches  only at Position ; not at
Position . To elaborate, note that at Position , the match is
due to `'. So, according to the graph  the next match has to
be an `' and hence at Position 2 we can't have a swap match.
\end{example}



For the sake of convenience, in the discussion that
follows, we refer to both  and the pattern  as
though they were equivalent; but it will be clear from the context
what we really mean. Suppose we have a match up to position 
of  in . Now we have to check whether
there is a match between  and . For simple
degenerate match, we only need to check whether 
or not. However, as Example~\ref{Ex_Diff} shows, for our case we
need to do more than that. 



In what follows, we present a novel technique to adapt the shift-and algorithm to tackle the above situation. Suppose that . Now, from the -graph we know which
of the  will follow  and which
of the  will follow . So, for
example, even if  we can't continue if there is 
no edge from  to  or from  to  in the -graph. 


To tackle this, we define a new notion. Consider 3-member vertex sets  and  of -graph such that there exist edges  and , for all  where . Then the edge  and  are considered to be  if and only if,  for all  where .


Also, given an edge , we say
that edge  `belongs to' column , i.e., where the edge
ends; and we say . Now we traverse all the edges and construct a set of sets
 such that each  contains the edges that are `same'. The set  is named by
 and we may refer to 
using its name. Now, we construct -masks  such that  if and only if, there is a set of  vertices  such that there exists an edge between each  where  and  having . With the -masks at our hand, we compute  as follows:



Here, RSHIFT indicates right shift, LSHIFT indicates left shift and AND is the usual bitwise AND operation. Note that, to locate the appropriate -mask, we again need to perform a look up in the database constructed during the construction of the -masks. Since a particular -mask involves a set of  (consecutive) vertices, we need a D array to ensure constant time reference to it. Note that in Equation~\ref{Rj+1}, we have referred to the -mask using the  vertices of the corresponding vertex set. Example~\ref{Ex_match1} presents a complete execution of our algorithm.

\begin{example}\label{Ex_match1}
Suppose,  and . The -masks of
 are shown in Table~\ref{common Dmask}. The -masks of
 are shown in Table~\ref{oldP_mask}. Table~\ref{calculation} shows the detail computation of . Explanation of the terms used in the Table~\ref{calculation} are as follows:   

\begin{itemize}
\item[] Right Shift Operation on the previous column
\item[] -Mask value for character `x'
\item[ ] Left Shift Operation on 
\item[] -Mask value of the set (x,y,z)
\item[] Value of  after  has processed ( `1' in - th row of  column indicates that a match has been found ending at the corresponding column.)
\end{itemize}
\end{example}
The preprocessing is formally presented in Algorithm~\ref{algorithm for preprocessing1}. The main algorithm is presented in Algorithm~\ref{Algorithm for Swap matching(Short and Improved)}. 


\begin{table}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
~ ~ ~ ~ &~ ~ D~ ~ &~ ~ &~ ~ &~ ~ &~ ~ \\
\hline
1&[ac]&1&0&1&0\\
\hline
2&[acb]&1&1&1&0\\
\hline
3&[cba]&1&1&1&0\\
\hline
4&[bab]&1&1&0&0\\
\hline
5&[ab]&1&1&0&0\\
\hline
\end{tabular}
\caption{The -masks for pattern in Examples~\ref{Ex_match1} and~\ref{Ex_match2} }
\label{common Dmask}
\end{center}
\end{table}

\begin{table}
\begin{center}
\begin{minipage}{\textwidth}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
&&&&&&&&&&&&&&&\footnote{Here,  indicates the edges that are not present in the -graph.}\\
\hline
1&1&1&1&1&1&1&1&1&1&1&1&1&1&1&1\\
\hline
2&0&0&0&1&1&1&0&0&0&0&1&1&0&0&0\\
\hline
3&1&1&1&0&0&0&0&0&1&1&0&1&1&1&0\\
\hline
4&0&0&1&0&0&0&1&1&0&0&0&1&1&0&0\\
\hline
5&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0\\
\hline
\end{tabular}
\end{minipage}
\caption{-masks for pattern in Example~\ref{Ex_match1} for SMALGO-\rom{1}}
\label{oldP_mask}
\end{center}
\end{table}


\begin{sidewaystable}
\tiny 
\tabcolsep 0.1pt
\begin{minipage}{\textwidth}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
&-&&& \footnote{Here,  indicates the edges that are not present in the -graph.}&   &&& &&&&& &&&&& && 
&&& &&&&& &&&&& &&&&& &&&&& &&&&& && \\
\hline
1&0&1&1&1&1 &1&1&1&1&1  &1&0&1&1&0  &1&0&1&1&0  &1&1&1&1&1  &1&0&1&1&0  &1&1&1&1&1  &1&1&1&1&1  &1&0&1&1&0  &1&1&1&1&1\\
\hline
2&0&0&1&0&0 &1&1&1&1&1  &1&1&1&0&0  &0&1&1&0&0  &0&1&1&0&0  &1&1&1&1&1  &0&1&1&0&0  &1&1&1&1&1  &1&1&1&0&0  &0&1&1&0&0\\
\hline
3&0&0&1&0&0 &0&1&1&0&0  &1&1&1&1&1  &0&1&1&0&0  &0&1&1&0&0  &0&1&0&0&0  &1&1&1&1&1  &0&1&1&1&0  &1&1&1&1&1  &0&1&1&0&0\\
\hline
4&0&0&1&0&0 &0&0&1&0&0  &0&1&1&0&0  &1&1&1&1&1  &0&1&1&1&0  &0&1&0&0&0  &0&0&1&0&0  &1&1&1&1&1  &0&1&1&0&0  &1&1&1&1&1\\
\hline 
5&0&0&1&0&0 &0&0&0&0&0  &0&1&0&0&0  &0&1&0&0&0  &1&1&0&0&0  &0&1&0&0&0  &0&0&0&0&0  &0&1&0&0&0  &1&1&0&0&0  &0&1&0&0&0\\
\hline
\end{tabular}
\end{minipage}
\caption{Detailed Calculation for text in Example~\ref{Ex_match1} for SMALGO-\rom{1}} \label{calculation}
\end{sidewaystable}


\begin{algorithm}
\caption{Computation of Preprocessing [-masks] for SMALGO-\rom{1}}
\label{algorithm for preprocessing1}
\begin{algorithmic}[1]
\REQUIRE{\textbf{Pattern p}}
\STATE{}
\FOR{ to }\STATE{}
\STATE{{}}
\ENDFOR
\FOR{ to }\STATE{}
\ENDFOR
\FOR{ to }\STATE{}
\ENDFOR
\FOR{ to }\STATE{}
\ENDFOR
\FOR{ to }\STATE{}
\ENDFOR
\FOR{ to }\STATE{}
\ENDFOR
\FOR{ to }\STATE{}
\ENDFOR
\RETURN{\textbf{-mask pmask[]} for Pattern p}
\end{algorithmic}
\end{algorithm}



\begin{algorithm}
\caption{SMALGO-\rom{1}}
\label{Algorithm for Swap matching(Short and Improved)}
\begin{algorithmic}[1]
\STATE{}
\STATE{ \& }
\STATE{}
\STATE{}
\STATE{}
\FOR{ to }\STATE{find  for }
	\STATE{ \&  \& \& }
	\IF{ \& } \STATE{Match found ending at position }
	\ENDIF
	\STATE{}
\ENDFOR
\end{algorithmic}
\end{algorithm}


\subsection{Analysis of SMALGO-\rom{1}}

\begin{table}
\begin{center}
\begin{tabular}{|c|c|}
\hline
Phase&Running Time\\
\hline
Computation of -masks&\\
\hline
Computation of -masks&\\
\hline
Running time of Algorithm~\ref{Algorithm for Swap matching(Short and Improved)}&\\
\hline
\end{tabular}
\caption{Running times of the different phases of SMALGO-\rom{1}}
\label{Table_RunningTime1}
\end{center}
\end{table}


The running times of the different phases of SMALGO-\rom{1} is listed in Table~\ref{Table_RunningTime1}. In the algorithm, we first initialize all the entries of -masks which requires  time. Then, we start traversing the edges and corresponding -masks in a name database (-D array). Finding and updating the -mask of corresponding edges can be done in constant time. As we have  edges, the total time needed for the computation of -masks is . 
The computation of -masks takes  time~\cite{BG92} when pattern is not degenerate. However, in our case, we need to assume that our pattern has a set of letters in each position. In this case, we require  time where  is the sum of the cardinality of the sets at each position~\cite{BG92}. In general degenerate strings,  can be  in the worst case. However, in our case, , where  is the vertex set of the -graph. So, computation of the -mask requires  time in the worst case. So the whole preprocessing takes  time. Assuming constant alphabet  and pattern of size compatible with machine word length the preprocessing time becomes .


With the -masks and -masks at our hand, for our problem, we simply need to compute  using Equation~\ref{Rj+1}. So, in total the construction of  values require  which is  if . Therefore, in total the running time for SMALGO-\rom{1}, is linear 
assuming a constant alphabet and a pattern size similar to the word size of the target machine.
















\subsection{\label{NewAlgo}The Second Algorithm : SMALGO-\rom{2}} 

In this section, we present another algorithm which is more space efficient. Instead of a -D array we need only -D arrays here. In order to understand the new algorithm, we need the following definitions.

\begin{definition}\label{levelchange}
A \emph{level change} indicates a change of row in the Matrix M having one of the following cases :
\begin{itemize}
\item A \textbf{Upward Change}, i.e., going from a position  to ; 

\item A \textbf{Downward Change}, i.e., going from a position  to  where 

 or ; 

\item A \textbf{End of Swap/Middle-ward Change}, i.e., going from a position  to . 
\end{itemize}

\end{definition}
In this approach, we only need to know which
of the  will follow  in the -graph. Thus we have to generate -masks in the following way. Here we change the notion of two edges being `same' as follows.


Two edges  of the -graph are said to be `same' if  and
, i.e., if the two edges have the same labels.
Also, given an edge , we say
that edge  `belongs to' column , i.e., where the edge
ends; and we say . 
Now we traverse all the edges and construct a set of sets
 such that each  contains the edges that are `same'. The set  is named by
the (same) label of the edges it contains and we may refer to 
using its name. Now, we construct -masks  such that  if, and only if, there is an
edge  having . Clearly here, .


Note that, to locate the appropriate -mask, we again need to perform a look up in the database constructed during the construction of the -masks. To maintain all -masks we are keeping a D array indexed by the consecutive vertices of an edge.


\begin{table}
\begin{center}
\begin{minipage}{\textwidth}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
\hline
~ ~ ~ &~ ~ &~ ~ &~ ~ &~ ~ &~ ~ &~ ~ &~ ~ &~ ~ &~ \footnote{Here,  indicates the edges that are not present in the -graph.}\\
\hline
1&1&1&1&1&1&1&1&1&1\\
\hline
2&0&1&1&0&0&0&1&0&0\\
\hline
3&1&1&0&0&0&1&1&1&0\\
\hline
4&0&1&0&1&1&0&1&1&0\\
\hline
5&0&1&0&1&1&0&0&0&0\\
\hline
\end{tabular}
\end{minipage}
\caption{-masks for patern }
\label{newP_mask}
\end{center}
\end{table}


\begin{figure}[hbtp]
\begin{center}
\includegraphics[width=0.6\textwidth,angle=0]{swapproblem.jpg}
\caption{Partial -graph for pattern  } \label{swapproblem}
\end{center}
\end{figure}


However, the -masks as defined above, and -masks defined before are not sufficient to solve the SM problem as shown below with an example. Please note that the definition of -mask in SMALGO-\rom{2} (i.e., the current algorithm) is different than that of SMALGO-\rom{1} (i.e., the algorithm presented in section~\ref{AIIR}).

\begin{example}\label{columnProblem}
In Table~\ref{newP_mask}, at the column named `P(b,b)', the value is  for pattern . The `' in the rightmost bit indicates that either one or both edge ,  exists, as shown in Figure~\ref{swapproblem}. We can not find out which one actually exists because our -mask values are only dependent on the column positions ( i.e., the edge starts at Column  and ends at Column  ) irrespective of row positions (). So the algorithm will accept  as a swapped version
of the pattern  which is clearly a false match.
\end{example} 




To solve the problem we need to be able to tell which \emph{level change} has occurred, \emph{Upward Change} or \emph{Middleward Change}. So, we introduce three new masks called -, - and - as discussed below. 

\begin{enumerate}
\item We construct \textbf{up-masks}, ,  such that  if and only if  exists with . 


\item We construct \textbf{down-masks}, ,  such that  if and only if either  or  exists with .  


\item We construct \textbf{middle-masks}, ,  such that  if and only if either  or  exists with .

\end{enumerate}




The motivation and usefulness of the  masks defined above will be clear from the following discussion.
It is easy to see that, to get a match, after a \emph{level change} at a particular position , another \emph{level change} must occur at the next position, i.e., at position  in the Matrix ; otherwise there can be no match. So we do the following based on the structure of the -graph.


\begin{enumerate}

\item If a \emph{Downward change} has occurred  then we have to check whether an \emph{Upward Change} occurs at the next position. We can do that by saving the previous \emph{down-mask} () and matching that value with the current \emph{up-mask} () and . Otherwise there can be no match.


\item If an \emph{Upward Change} has occurred then we have to check whether \emph{Downward change} or a \emph{Middle-ward change} occurs at the next position. We can do that by saving the previous \emph{up-mask} () and matching that value with current \emph{down-mask}  (), \emph{middle-mask} () and . Otherwise there can be no match.


\item This process continues repeatedly until either an \emph{End of Swap} occurs or an end of pattern is encountered. To check whether an end of swap occurs we have to keep previous \emph{up-mask} () and match that value with current \emph{middle-mask} () and . 
\end{enumerate}  




In our algorithm, each of the previous checkings have to be done while we process each character. The algorithm is formally presented in Algorithm~\ref{Algorithm for Approximate String Matching Allowing for Fixed Length Translocation(Improved)}. The preprocessing of the algorithm is presented in Algorithm~\ref{algorithm for preprocessing}. In the algorithm, we are using a -D array for -masks, up-masks, down-masks and middle-masks. Example~\ref{Ex_match2} shows a complete execution of our algorithm.

\begin{example}\label{Ex_match2}
Suppose,  and . The -masks of  are shown in Table~\ref{common Dmask}. The -masks of  are shown in Table~\ref{newP_mask}. The new mask values are shown in Table~\ref{ournewmask} and Table~\ref{ourrightresult} shows the detail computation of  bit array. Explanation of the terms used in Table~\ref{ourrightresult} are as follows:   

\begin{itemize}
\item[SH] Right Shift Operation on the previous column
\item[] -Mask value for character `x'
\item[] -Mask value of the set (x,y)
\item[] Value of  after  has been proceed ( `1' in -th row of  column indicates that a match has been found )
\end{itemize}
\end{example}





\begin{table}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
~  ~&~ up-mask~ &~ middle-mask~ &~ down-mask~ \\
\hline
~ (a,a)~ &~ 00000~ &~ 00000~ &~ 00100~ \\
\hline
~ (a,b)~ &~ 00010~ &~ 00101~ &~ 01000~ \\
\hline
~ (a,c)~ &~ 00000~ &~ 01000~ &~ 10000~ \\
\hline
~ (b,a)~ &~ 00001~ &~ 00011~ &~ 00000~ \\
\hline 
~ (b,b)~ &~ 00000~ &~ 00001~ &~ 00010~ \\
\hline
~ (b,c)~ &~ 00100~ &~ 00000~ &~ 10000~ \\
\hline
~ (c,a)~ &~ 01000~ &~ 00010~ &~ 00100~ \\
\hline
~ (c,b)~ &~ 00000~ &~ 00100~ &~ 00010~ \\
\hline
\end{tabular}
\caption{Masks for Algorithm 2 of the pattern in Example~\ref{Ex_match2}} \label{ournewmask}
\end{center}
\end{table}





\begin{sidewaystable}
\scriptsize 
\tabcolsep 0.4pt
\begin{minipage}{\textwidth}
\begin{tabular}
{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
~ ~ &~ ~ &SH&&\footnote{Here,  indicates the edges that are not present in the -graph.} &  &SH&&&&SH&&&&SH&&&&SH&&&&SH&&&&SH&&
&&SH&&&&SH&&&&SH&&&&SH&&&\\
\hline
1&0&1&1&1&1&1&1&1&1&1&0&1&0&1&0&1&0&1&1&1&1&1&0&1&0&1&1&1&1&1&1&1&1&1&0&1&0&1&1&1&1&1&0&1&0\\
\hline
2&0&0&1&0&0&1&1&1&1&1&1&0&0&0&1&0&0&0&1&0&0&1&1&1&1&0&1&0&0&1&1&1&1&1&1&1&1&0&1&0&0&1&1&1&1\\
\hline
3&0&0&1&0&0&0&1&0&0&0&1&1&1&0&1&0&0&0&1&0&0&0&1&1&0&1&1&1&1&0&1&1&0&1&1&1&1&1&1&0&0&0&1&1&0\\
\hline
4&0&0&1&0&0&0&0&0&0&0&1&1&0&1&1&1&1&0&1&1&0&0&1&1&0&0&0&0&0&1&1&1&1&0&1&1&0&1&1&1&1&0&1&1&0\\
\hline 
5&0&0&1&0&0&0&0&0&0&0&1&0&0&0&1&1&0&1&1&1&1&0&1&1&0&0&0&0&0&0&1&0&0&1&1&1&1&0&1&1&0&1&1&1&1\\
\hline
\end{tabular}
\end{minipage}
\caption{Detailed Calculation for text in Example~\ref{Ex_match2}} \label{ourrightresult}
\end{sidewaystable}


\begin{algorithm}
\caption{Algorithm for Computation of all the Masks [Preprocessing] for SMALGO-\rom{2}}
\label{algorithm for preprocessing}
\begin{algorithmic}[1]
\REQUIRE{\textbf{Pattern p}}
\STATE{}
\FOR{ to }\STATE{}
\STATE{{}}
\ENDFOR
\FOR{ to }\STATE{}
\STATE{{}}
\STATE{{}}
\ENDFOR
\FOR{ to }\STATE{}
\STATE{{}}
\ENDFOR
\FOR{ to }\STATE{}
\STATE{{}}
\ENDFOR
\FOR{ to }\STATE{}
\ENDFOR
\RETURN{\textbf{-masks pmask[]}, \textbf{-masks d[]}, \textbf{up-masks up[]}, \textbf{down-masks down[]} and \textbf{middle-masks middle[]} for Pattern p}
\end{algorithmic}
\end{algorithm}



\begin{algorithm}
\caption{SMALGO-\rom{2}}
\label{Algorithm for Approximate String Matching Allowing for Fixed Length Translocation(Improved)}
\begin{algorithmic}[1]
\REQUIRE{\textbf{Text T}, \textbf{up-mask up}, \textbf{down-mask down}, \textbf{middle-mask middle}, \textbf{P-mask pmask},   \textbf{D-mask D}  for given pattern p}
\STATE{}
\STATE{}
\STATE{ \& }
\STATE{}
\STATE{}
\FOR{ to }\STATE{ \&  \& }
	\STATE{}
	\STATE{   }
	\STATE{ \&  \& }
	\STATE{}
	\STATE{ \&  \& }
	\STATE{}
	\STATE{   }
	\STATE{ \& }
	\STATE{}
	\STATE{ \&  \& }
	\IF{ \& } \STATE{Match found ending at position }
	\ENDIF
	\STATE{}
	\STATE{}
	\STATE{}
\ENDFOR
\end{algorithmic}
\end{algorithm}


\subsection{Analysis of SMALGO-\rom{2}}\label{analysis}



\begin{table}
\begin{center}
\begin{tabular}{|c|c|}
\hline
Phase&Running Time\\
\hline
Computation of -masks&\\
\hline
Computation of -masks&\\
\hline
Computation of -masks&\\
\hline
Computation of -masks&\\
\hline
Computation of -masks&\\
\hline
Running time of Algorithm~\ref{Algorithm for Approximate String Matching Allowing for Fixed Length Translocation(Improved)}&\\
\hline
\end{tabular}
\caption{Running times of the different phases of of SMALGO-\rom{2}}
\label{Table_RunningTime2}
\end{center}
\end{table}




The running times of the different phases of SMALGO-\rom{2} is listed in Table~\ref{Table_RunningTime2}. In SMALGO-\rom{2}, we first initialize all the entries of -masks which requires  time. Then, we start traversing the edges and corresponding -masks in a name database (-D array). Finding and updating the -mask of corresponding edges can be done in constant time. As we have  edges, the total time needed for computation of -mask is . 
Similarly, the computation of up-masks, down-masks and middle-masks can be done in  time as well. The computation of -mask takes  time.
So the whole preprocessing takes  time. Assuming constant alphabet  and pattern of size compatible with machine word length the preprocessing time becomes .


With all the masks at our hand, for our problem, we simply need to compute  by some simple calculation. Each step of the calculation, including locating the appropriate masks, needs constant amount of time. So, in total the construction of  values require  which is  when .

 
Therefore, in total the running time for SMALGO-\rom{2}, is linear
assuming a constant alphabet and a pattern size similar to the word size of the target machine.

















\section{Experimental Results}\label{experiment}

We have conducted extensive experiments to compare the actual running time of the existing (non FFT) swap matching algorithms in the literature~\cite{CS,CCS} with ours. In this section, we present our findings based on the experiments conducted. The following acronyms are used in the presented results to identify different algorithms.


\begin{itemize}
\item[CS] CROSS-SAMPLING algorithm of~\cite{CS}
\item[BPCS] BP-CROSS-SAMPLING algorithm of~\cite{CS}
\item[BCS] BACKWARD-CROSS-SAMPLING algorithm of~\cite{CCS}
\item[BPBCS] BP-BACKWARD-CROSS-SAMPLING algorithm of~\cite{CCS}
\item[ALG-\rom{1}] SMALGO-\rom{1} of this paper
\item[ALG-\rom{2}] SMALGO-\rom{2} of this paper
\end{itemize} 

 


We have chosen to exclude the naive algorithm and all algorithms in the literature based on FFT techniques from our experiments, because, the overhead of such algorithms is quite high resulting in a bad performance. All algorithms have been implemented in Microsoft Visual C++ in Release Mode on a PC with Intel Pentium D processor of 2.8 GHz having a memory of 2GB.

\subsection{Datasets}
All algorithms have been tested on random texts, on a Genome sequence, on a Protein sequence and on a natural language text buffer with patterns of length,  = 4, 8, 12, 16, 20, 24, 28, 32. In the Tables below running times have been expressed in the hundredth of a second and best results are highlighted.


In the case of random texts we have adopted a similar strategy of~\cite{CS,CCS}. In particular, the algorithm has been tested on six  problem sets (for  = 4, 8, 16, 32, 64 and 128). Each  problem consists in searching a set of 100 random patterns for any given length value in a 4MB long random text over a common alphabet of size . In order to make the test more effective, in our experiments half of the patterns are randomly chosen and rests are picked from the text randomly so that they surely appear in the text at least once. 



We also follow a strategy similar to that of~\cite{CS,CCS} for the tests on real world problems. 
We have been performed tests on a Genome sequence, on a protein sequence and on a natural text buffer. The genome sequence we used for the tests is a sequence of 4,638,690 base pairs of  taken from the file \emph{E.coli} of the large Canterbury Corpus~\cite{corpus}.
The tests on the Protein sequence have been performed using a 2.4MB file containing a protein sequence from the Human Genome with 22 different characters. The experiments on the natural language text buffer have been done on the file \emph{world192.txt} (The CIA World Fact Book) of the Large Canterbury Corpus~\cite{corpus}. This file contains 2,473,400 characters drawn from an alphabet of 93 different characters.


\subsection{Running Times of Random Problems}

The running times for different algorithms for this experiment are reported in Tables~\ref{Rand4} -~\ref{Rand128}. From the results, we see that, in general, ALG-\rom{1} (SMALGO-\rom{1}) runs faster than BPBCS for smaller patterns and small alphabet size whereas BPBCS performs better when pattern and alphabet size are relatively large.




\begin{table}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
m&4&8&12&16&20&24&28&32\\
\hline
CS &~ 61.247~ &~ 61.137~ &~ 61.252~ &~ 61.043~ &~ 61.468~ &~ 63.472~ &~ 68.489~ &~ 66.090~ \\
\hline
BCS &~ 33.366~ &~ 22.865~ &~ 18.523~ &~ 16.580~ &~ 15.289~ &~ 14.585~ &~ 13.628~ &~ 13.087~ \\
\hline
BPCS &~ 1.914~ &~ 1.867~ &~ 1.849~ &~ 1.864~ &~ 1.861~ &~ 1.908~ &~ 1.859~ &~ 1.860~ \\
\hline
~ BPBCS~ &~ 3.552~ &~ 2.001~ &~ 1.451~ &~ 1.124~ &~ 0.968~ &~ 0.835~ &~ 0.737~ &~ 0.672~ \\
\hline 
ALG-\rom{2} &~ 4.062~ &~ 4.081~ &~ 4.090~ &~ 4.093~ &~ 4.124~ &~ 4.082~ &~ 4.085~ &~ 4.095~ \\
\hline
ALG-\rom{1} &~ \textbf{0.631}~ &~ \textbf{0.626}~ &~ \textbf{0.631}~ &~ \textbf{0.631}~ &~ \textbf{0.636}~ &~ \textbf{0.636}~ &~ \textbf{0.640}~ &~ \textbf{0.629}~ \\
\hline
\end{tabular}
\caption{Running time for Rand4 problems}
\label{Rand4}
\end{center}
\end{table}

\begin{table}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
m&4&8&12&16&20&24&28&32\\
\hline
CS &~ 52.447~ &~ 52.407~ &~ 52.356~ &~ 52.357~ &~ 52.457~ &~ 52.424~ &~ 52.443~ &~ 52.424~ \\
\hline
BCS &~ 23.139~ &~ 16.532~ &~ 12.539~ &~ 10.810~ &~ 9.701~ &~ 9.111~ &~ 8.502~ &~ 7.996~ \\
\hline
BPCS &~ 1.861~ &~ 1.858~ &~ 1.857~ &~ 1.864~ &~ 1.896~ &~ 1.905~ &~ 2.001~ &~ 1.853~ \\
\hline
~ BPBCS~ &~ 2.156~ &~ 1.319~ &~ 0.944~ &~ 0.743~ &~ \textbf{0.621}~ &~ \textbf{0.533}~ &~ \textbf{0.476}~ &~ \textbf{0.421}~ \\
\hline 
ALG-\rom{2} &~ 4.061~ &~ 4.066~ &~ 4.051~ &~ 4.062~ &~ 4.060~ &~ 4.059~ &~ 4.064~ &~ 4.063~ \\
\hline
ALG-\rom{1} &~ \textbf{0.674}~ &~ \textbf{0.684}~ &~ \textbf{0.671}~ &~ \textbf{0.675}~ &~ 0.654~ &~ 0.676~ &~ 0.633~ &~ 0.633~ \\
\hline
\end{tabular}
\caption{Running time for Rand8 problems}
\label{Rand8}
\end{center}
\end{table}

\begin{table}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
m&4&8&12&16&20&24&28&32\\
\hline
CS &~ 51.632~ &~ 52.622~ &~ 53.139~ &~ 53.450~ &~ 51.829~ &~ 55.243~ &~ 53.136~ &~ 52.847~ \\
\hline
BCS &~ 18.718~ &~ 13.350~ &~ 11.130~ &~ 9.084~ &~ 7.711~ &~ 7.045~ &~ 6.578~ &~ 6.103~ \\
\hline
BPCS &~ 1.864~ &~ 1.870~ &~ 1.857~ &~ 1.844~ &~ 1.862~ &~ 1.851~ &~ 1.856~ &~ 1.864~ \\
\hline
~ BPBCS~ &~ 1.340~ &~ 0.917~ &~ 0.700~ &~ \textbf{0.555}~ &~ \textbf{0.459}~ &~ \textbf{0.393}~ &~ \textbf{0.349}~ &~ \textbf{0.314}~ \\
\hline 
ALG-\rom{2} &~ 4.063~ &~ 4.062~ &~ 4.066~ &~ 4.063~ &~ 4.075~ &~ 4.083~ &~ 4.062~ &~ 4.074~ \\
\hline
ALG-\rom{1} &~ \textbf{0.636}~ &~ \textbf{0.634}~ &~ \textbf{0.662}~ &~ 0.631~ &~ 0.635~ &~ 0.640~ &~ 0.632~ &~ 0.643~ \\
\hline
\end{tabular}
\caption{Running time for Rand16 problems}
\label{Rand16}
\end{center}
\end{table}




\begin{table}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
m&4&8&12&16&20&24&28&32\\
\hline
CS &~ 52.644~ &~ 54.104~ &~ 51.123~ &~ 51.296~ &~ 50.795~ &~ 53.045~ &~ 54.296~ &~ 53.458~ \\
\hline
BCS &~ 16.628~ &~ 11.472~ &~ 8.682~ &~ 7.618~ &~ 6.684~ &~ 5.966~ &~ 5.474~ &~ 5.318~ \\
\hline
BPCS &~ 1.862~ &~ 1.863~ &~ 1.866~ &~ 1.858~ &~ 1.862~ &~ 1.851~ &~ 1.910~ &~ 1.856~ \\
\hline
~ BPBCS~ &~ 0.950~ &~ 0.637~ &~ \textbf{0.532}~ &~ \textbf{0.453}~ &~ \textbf{0.394}~ &~ \textbf{0.363}~ &~ \textbf{0.307}~ &~ \textbf{0.274}~ \\
\hline 
ALG-\rom{2} &~ 4.100~ &~ 4.094~ &~ 4.104~ &~ 4.093~ &~ 4.102~ &~ 4.108~ &~ 4.099~ &~ 4.101~ \\
\hline
ALG-\rom{1} &~ \textbf{0.636}~ &~ \textbf{0.633}~ &~ 0.630~ &~ 0.632~ &~ 0.629~ &~ 0.631~ &~ 0.631~ &~ 0.629~ \\
\hline
\end{tabular}
\caption{Running time for Rand32 problems}
\label{Rand32}
\end{center}
\end{table}


\begin{table}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
m&4&8&12&16&20&24&28&32\\
\hline
CS &~ 49.482~ &~ 47.775~ &~ 50.448~ &~ 49.668~ &~ 52.965~ &~ 51.000~ &~ 52.663~ &~ 53.103~ \\
\hline
BCS &~ 14.892~ &~ 9.850~ &~ 7.615~ &~ 6.481~ &~ 6.692~ &~ 5.484~ &~ 5.242~ &~ 5.066~ \\
\hline
BPCS &~ 1.846~ &~ 1.855~ &~ 1.864~ &~ 1.919~ &~ 1.923~ &~ 1.851~ &~ 1.917~ &~ 1.863~ \\
\hline
~ BPBCS~ &~ 0.739~ &~ \textbf{0.475}~ &~ \textbf{0.370}~ &~ \textbf{0.334}~ &~ \textbf{0.294}~ &~ \textbf{0.282}~ &~ \textbf{0.271}~ &~ \textbf{0.233}~ \\
\hline
ALG-\rom{2} &~ 4.334~ &~ 4.341~ &~ 4.342~ &~ 4.336~ &~ 4.347~ &~ 4.355~ &~ 4.390~ &~ 4.341~ \\
\hline
ALG-\rom{1} &~ \textbf{0.635}~ &~ 0.635~ &~ 0.686~ &~ 0.626~ &~ 0.637~ &~ 0.636~ &~ 0.632~ &~ 0.630~ \\
\hline
\end{tabular}
\caption{Running time for Rand64 problems}
\label{Rand64}
\end{center}
\end{table}



\begin{table}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
m&4&8&12&16&20&24&28&32\\
\hline
CS &~ 49.939~ &~ 48.608~ &~ 50.570~ &~ 52.593~ &~ 50.797~ &~ 50.075~ &~ 49.481~ &~ 49.640~ \\
\hline
BCS &~ 14.411~ &~ 9.541~ &~ 7.513~ &~ 6.546~ &~ 6.769~ &~ 5.242~ &~ 4.743~ &~ 4.573~ \\
\hline
BPCS &~ 1.855~ &~ 1.866~ &~ 1.849~ &~ 1.851~ &~ 1.855~ &~ 1.858~ &~ 1.861~ &~ 1.864~ \\
\hline
~ BPBCS~ &~ 0.688~ &~ \textbf{0.430}~ &~ \textbf{0.325}~ &~ \textbf{0.288}~ &~ \textbf{0.274}~ &~ \textbf{0.229}~ &~ \textbf{0.216}~ &~ \textbf{0.204}~ \\
\hline
ALG-\rom{2} &~ 4.429~ &~ 4.431~ &~ 4.426~ &~ 4.477~ &~ 4.408~ &~ 4.032~ &~ 4.422~ &~ 4.422~ \\
\hline
ALG-\rom{1} &~ \textbf{0.651}~ &~ 0.661~ &~ 0.661~ &~ 0.640~ &~ 0.653~ &~ 0.638~ &~ 0.633~ &~ 0.644~ \\
\hline
\end{tabular}
\caption{Running time for Rand128 problems}
\label{Rand128}
\end{center}
\end{table}



\begin{table}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
m&4&8&12&16&20&24&28&32\\
\hline
CS &~ 74.771~ &~ 74.729~ &~ 74.890~ &~ 74.564~ &~ 73.251~ &~ 77.605~ &~ 71.991~ &~ 73.472~ \\
\hline
BCS &~ 78.499~ &~ 52.828~ &~ 43.492~ &~ 38.730~ &~ 35.401~ &~ 33.078~ &~ 31.815~ &~ 30.234~ \\
\hline
BPCS &~ 2.224~ &~ 2.157~ &~ 2.152~ &~ 2.152~ &~ 2.146~ &~ 2.152~ &~ 2.159~ &~ 2.164~ \\
\hline
~ BPBCS~ &~ 3.977~ &~ 2.228~ &~ 1.619~ &~ 1.283~ &~ 1.084~ &~ 0.930~ &~ 0.830~ &~ 0.749~ \\
\hline
ALG-\rom{2} &~ 4.732~ &~ 4.734~ &~ 4.739~ &~ 4.744~ &~ 4.745~ &~ 4.730~ &~ 4.709~ &~ 4.711~ \\
\hline
ALG-\rom{1} &~ \textbf{0.600}~ &~ \textbf{0.619}~ &~ \textbf{0.639}~ &~ \textbf{0.596}~ &~ \textbf{0.611}~ &~ \textbf{0.606}~ &~ \textbf{0.582}~ &~ \textbf{0.583}~ \\
\hline
\end{tabular}
\caption{Running time for a genome sequence ( = )} \label{genome}
\end{center}
\end{table}


\begin{table}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
m&4&8&12&16&20&24&28&32\\
\hline
CS &~ 55.764~ &~ 54.316~ &~ 55.594~ &~ 51.737~ &~ 50.797~ &~ 50.491~ &~ 50.154~ &~ 50.889~ \\
\hline
BCS &~ 33.825~ &~ 24.180~ &~ 21.250~ &~ 17.179~ &~ 14.344~ &~ 13.464~ &~ 12.506~ &~ 12.075~ \\
\hline
BPCS &~ 1.852~ &~ 1.853~ &~ 1.866~ &~ 1.866~ &~ 1.878~ &~ 1.859~ &~ 1.859~ &~ 2.027~ \\
\hline
~ BPBCS~ &~ 1.107~ &~ 0.771~ &~ 0.617~ &~ \textbf{0.504}~ &~ \textbf{0.428}~ &~ \textbf{0.367}~ &~ \textbf{0.314}~ &~ \textbf{0.282}~ \\
\hline
ALG-\rom{2} &~ 4.064~ &~ 4.086~ &~ 4.098~ &~ 4.062~ &~ 4.068~ &~ 4.056~ &~ 4.076~ &~ 4.075~ \\
\hline
ALG-\rom{1} &~ \textbf{0.613}~ &~ \textbf{0.606}~ &~ \textbf{0.599}~ &~ 0.611~ &~ 0.618~ &~ 0.602~ &~ 0.613~ &~ 0.622~ \\
\hline
\end{tabular}
\caption{Running time for a protein sequence ( = )} \label{protein}
\end{center}
\end{table}


\begin{table}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
m&4&8&12&16&20&24&28&32\\
\hline
CS &~ 30.205~ &~ 33.177~ &~ 30.626~ &~ 33.344~ &~ 28.872~ &~ 31.382~ &~ 30.744~ &~ 29.362~ \\
\hline
BCS &~ 29.917~ &~ 26.244~ &~ 25.232~ &~ 28.203~ &~ 30.407~ &~ 26.468~ &~ 30.966~ &~ 26.778~ \\
\hline
BPCS &~ 1.178~ &~ 1.166~ &~ 1.181~ &~ 1.154~ &~ 1.146~ &~ 1.150~ &~ 1.146~ &~ 1.132~ \\
\hline
~ BPBCS~ &~ 0.793~ &~ 0.701~ &~ .657~ &~ 0.723~ &~ 0.768~ &~ 0.691~ &~ 0.738~ &~ 0.694~ \\
\hline
ALG-\rom{2} &~ 2.508~ &~ 2.510~ &~ 2.506~ &~ 2.507~ &~ 2.546~ &~ 2.501~ &~ 2.510~ &~ 2.505~ \\
\hline
ALG-\rom{1} &~ \textbf{0.632}~ &~ \textbf{0.620}~ &~ \textbf{0.625}~ &~ \textbf{0.616}~ &~ \textbf{0.609}~ &~ \textbf{0.634}~ &~ \textbf{0.618}~ &~ \textbf{0.608}~ \\
\hline
\end{tabular}
\caption{Running time for a natural language text buffer ( = )} \label{natural}
\end{center}
\end{table}




\subsection{Running Times for Real World Problems}

The running time of different algorithms in these different experiments are reported in Tables~\ref{genome} -~\ref{natural}. From the experiments, we see that ALG-\rom{1} runs faster for all pattern lengths in genome sequence and natural language text buffer. However in protein sequence, ALG-\rom{1} performs best for smaller patterns whereas BPBCS performs better for larger patterns.  














\section{\label{conclusion}Conclusion}
In this paper, we have revisited the Swap Matching problem, a well-studied variant of the classic pattern matching problem. In particular, we have presented a graph theoretic model to solve the swap matching problem and devised two novel algorithms based on this model. The resulting algorithms are adaptations of the classic shift-and algorithm~\cite{CharrasL04} and runs in linear time for finite alphabet if the pattern-length is similar to the word-size in the target machine. Note that our algorithms like the work of~\cite{CS,CCS} does not use FFT techniques. Though both algorithms are based on the same classic shift-and algorithm, they are different in their technique/approach. Moreover, the techniques used in our algorithms are quite simple and easy to implement as well as understand. 


We believe that our graph theoretic model could be used to devise more efficient algorithms and a similar approach can be taken to model similar other variants of the classic pattern matching problem. Furthermore, it would be interesting to `swap' the definitions of - graph and - graph and investigate whether efficient pattern matching techniques for Directed Acyclic Graphs can be employed to devise efficient off-line and online algorithms for swap matching.

\bibliography{swap}
\bibliographystyle{abbrv}

\end{document}
