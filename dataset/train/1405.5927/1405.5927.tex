\documentclass{llncs}

\usepackage{amsmath,amssymb,amsfonts,mathrsfs,stmaryrd,comment}
\usepackage{bussproofs}
\usepackage{multirow}

\usepackage{url}

\usepackage{wrapfig,blindtext}



\usepackage{fancyhdr}
\usepackage{pbox}

\usepackage{graphicx}
\usepackage{color,soul}

\usepackage{textcomp}

\usepackage{graphs}
 \graphnodesize{0.55}
 \grapharrowlength{0.2}
 \grapharrowwidth{0.6}
 \autodistance{1.0}
 \setlength{\unitlength}{0.5in}
 \graphnodecolour{1}


\newcommand{\fillednodes}{\fillednodestrue \graphnodecolour{0} \graphnodesize{0.125} \graphlinewidth{0.015} \grapharrowwidth{0.6}}

\newcommand{\gpindent}{\hspace*{20 mm}}
\newcommand{\bignode}{\graphnodesize{0.65}}
\newcommand{\hugenode}{\graphnodesize{.85}}
\newcommand{\veryhugenode}{\graphnodesize{1}}
\newcommand{\normalnode}{\graphnodesize{0.55}}
\newcommand{\smallnormalnode}{\graphnodesize{0.485}}
\newcommand{\smallnode}{\graphnodesize{0.30}}
\newcommand{\smallnodebigger}{\graphnodesize{0.35}}
\newcommand{\smallarrow}{\grapharrowwidth{0.5}\grapharrowlength{0.15}}
\newcommand{\ife}{-- }
\newcommand{\lvar}[1]{\mathtt{#1}}

\newcommand{\Alpha}{\mathfrak{A}}
\renewcommand{\L}{\mathcal{L}}
\newcommand{\List}{\mathbb{L}}
\newcommand{\RS}{\text{RS}}
\newcommand{\EC}{\text{EC}}
\newcommand{\G}{\mathcal{G}}
\newcommand{\R}{\mathcal{R}}
\newcommand{\Exp}{\text{Exp}}

\newcommand{\VE}{V\!E}

\newcommand{\dder}{\Rightarrow}


\newcommand{\PGP}{\emph{PGP} }
\newcommand{\WTGP}{\emph{WTGP} }
\newcommand{\TGP}{\emph{TGP} }

\newcommand{\descref}[1]{\textbf{\ref{#1}}}

\newcommand{\mt}[1]{\text{\tt{#1}}}
\newcommand{\grey}{\graphnodecolour{.75}}
\newcommand{\dashed}{\graphlinedash{4 2}}
\newcommand{\pathline}{\graphlinewidth{0.05}}


\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\newcommand{\tuple}[1]{\langle#1\rangle}
\newcommand{\failrm}{\mathrm{fail}}



\newcommand{\skiptt}{\mathtt{skip}}
\newcommand{\failtt}{\mathtt{fail}}
\newcommand{\gp}{\mathrm{GP}}
\newcommand{\ifte}[3]{\mathtt{if}\ #1\ \mathtt{then}\ #2\ \mathtt{else}\ #3}
\newcommand{\ift}[2]{\mathtt{if}\ #1\ \mathtt{then}\ #2}
\newcommand{\tryt}[2]{\mathtt{try}\ #1\ \mathtt{then}\ #2}
\newcommand{\tryte}[3]{\mathtt{try}\ #1\ \mathtt{then}\ #2\ \mathtt{else}\ #3}
\newcommand{\whiled}[2]{\mathtt{while}\ #1\ \mathtt{do}\ #2}
\newcommand{\Ssos}{\mathcal{S}_{\mathrm{sos}}}
\newcommand{\Sds}{\mathcal{S}_{ds}}
\newcommand{\fail}{\mathrm{fail}}
\newcommand{\lrsem}[1]{\llbracket#1\rrbracket}
\newcommand{\skipc}{\mathtt{skip}}
\newcommand{\failc}{\mathtt{fail}}
\newcommand{\rmfail}{\mathrm{fail}}
\newcommand{\gf}{\mathtt{\widehat{\G}}}
\newcommand{\cond}{\mathrm{cond}}
\newcommand{\Efunc}{\mathcal{E}}
\newcommand{\fix}{\mathrm{FIX}}
\newcommand{\idfunc}{\mathrm{id}}
\newcommand{\F}{\mathrm{F}}
\newcommand{\Power}{\mathcal{P}}
\newcommand{\M}{\mathrm{M}}
\newcommand{\X}{\mathrm{X}}

\newcommand{\mrm}{\mathrm}
\newcommand{\mtt}[1]{\mathtt{#1}}

\newcommand{\todo}[1]{\textcolor{red}{#1}}

\begin{document}
	
	\title{Verifying Monadic Second-Order Properties of Graph Programs}
	\subtitle{\vspace{10pt}\emph{---\ extended version\ ---}}
	\author{Christopher M. Poskitt\inst{1} and Detlef Plump\inst{2}}


	
	\institute{Department of Computer Science, ETH Z\"{u}rich, Switzerland
	\and Department of Computer Science, The University of York, UK
	}

	\maketitle
	
	\begin{center}\textbf{Updated:} 16th June 2014\end{center}

	\begin{abstract}
		The core challenge in a Hoare- or Dijkstra-style proof system for graph programs is in defining a weakest liberal precondition construction with respect to a rule and a postcondition. Previous work addressing this has focused on assertion languages for first-order properties, which are unable to express important global properties of graphs such as acyclicity, connectedness, or existence of paths. In this paper, we extend the nested graph conditions of Habel, Pennemann, and Rensink to make them equivalently expressive to monadic second-order logic on graphs. We present a weakest liberal precondition construction for these assertions, and demonstrate its use in verifying non-local correctness specifications of graph programs in the sense of Habel et al.
	\end{abstract}
	
	
	\section{Introduction}
	
	Many problems in computer science and software engineering can be modelled in terms of graphs and graph transformation, including the specification and analysis of pointer structures, object-oriented systems, and model transformations; to name just a few. These applications, amongst others, motivate the development of techniques for verifying the functional correctness of both graph transformation rules and programs constructed over them.
	
	A recent strand of research along these lines has resulted in the development of \emph{proof calculi} for graph programs. These, in general, provide a means of systematically proving that a program is correct relative to a specification. A first approach was considered by Habel, Pennemann, and Rensink \cite{Habel-Pennemann-Rensink06a,Pennemann09a}, who contributed weakest precondition calculi -- in the style of Dijkstra -- for simple rule-based programs, with specifications expressed using \emph{nested conditions} \cite{Habel-Pennemann09a}. Subsequently, we developed Hoare logics \cite{Poskitt-Plump12a,Poskitt13a} for the graph transformation language GP 2 \cite{Plump12a}, which additionally allows computation over labels, and employed as a specification language an extension of nested conditions with support for expressions.
	
	Both approaches suffer from a common drawback, in that they are limited to first-order structural properties. In particular, neither of them support proofs about important \emph{non-local} properties of graphs, e.g.\ acyclicity, connectedness, or the existence of arbitrary-length paths. Part of the difficulty in supporting such assertions is at the core of both approaches: defining an effective construction for the weakest property guaranteeing that an application of a given rule will establish a given postcondition (i.e.\ the construction of a \emph{weakest liberal precondition} for graph transformation rules).
	
	Our paper addresses exactly this challenge. We define an extension of nested conditions that is equivalently expressive to monadic second-order (MSO) logic on graphs \cite{Courcelle-Engelfriet12a}. For this assertion language, and for graph programs similar to those of \cite{Habel-Pennemann-Rensink06a,Pennemann09a}, we define a weakest liberal precondition construction that can be integrated into Dijkstra- and Hoare-style proof calculi. Finally we demonstrate its use in verifying non-local correctness specifications (properties including that the graph is bipartite, acyclic) of some simple programs.
	
	The paper is organised as follows. In Section \ref{sec:preliminaries} we provide some preliminary definitions and notations. In Section \ref{sec:expressing_mso_properties} we define an extension of nested conditions for MSO properties. In Section \ref{sec:graph_programs} we define graph programs, before presenting our weakest liberal precondition construction in Section \ref{sec:constructing_wlps}, and demonstrating in Section \ref{sec:example_proofs} its use in Hoare-style correctness proofs. Finally, Section \ref{sec:related_work} presents some related work before we conclude the paper in Section \ref{sec:conclusion}.
	
	This is an extended version of \cite{Poskitt-Plump14a}, and includes the semantics of graph programs as well as the missing proofs.
	
	\section{Preliminaries}\label{sec:preliminaries}
	
	Let  denote the set of Boolean values,  denote (disjoint) sets of node and edge identifiers (which shall be written in lowercase typewriter font, e.g.\ ), and  denote (disjoint) sets of node- and edge-set variables (which shall be written in uppercase typewriter font, e.g.\ ).
	
	A \emph{graph}\/ over a label alphabet  is defined as a system , where  and  are finite sets of \emph{nodes} (or \emph{vertices}) and \emph{edges},  are the \emph{source} and \emph{target} functions for edges,  is the node labelling function and  is the edge labelling function. The \emph{empty graph}, denoted by , has empty node and edge sets. For simplicity, we fix the label alphabet throughout this paper as , where  denotes the blank label (which we render as  and  in pictures). We note that our technical results hold for any fixed finite label alphabet.
	
	Given a graph , the \emph{(directed) path predicate}  is defined inductively for nodes  and sets of edges . If , then  holds. If , then  holds if there exists an edge  such that  and .

	A \emph{graph morphism}  between graphs  consists of two functions  and \/ that preserve sources, targets and labels; that is, , , , and . We call  the \emph{domain} (resp.\ \emph{codomain}) of . Morphism  is an \emph{inclusion} if  for all nodes and edges . It is \emph{injective}\/ (\emph{surjective}) if  and  are injective (surjective). It is an \emph{isomorphism} if it is both injective and surjective. In this case  and \/ are \emph{isomorphic}, which is denoted by .


	\section{Expressing Monadic Second-Order Properties}\label{sec:expressing_mso_properties}
	
	We extend the nested conditions of \cite{Habel-Pennemann09a} to a formalism equivalently expressive to MSO logic on graphs. The idea is to introduce new quantifiers for node- and edge-set variables, and equip morphisms with constraints about set membership. The definition of satisfaction is then extended to require an interpretation of these variables in the graph such that the constraint evaluates to true. Furthermore, constraints can also make use of a predicate for explicitly expressing properties about directed paths. Such properties can of course be expressed in terms of MSO expressions, but the predicate is provided as a more compact alternative.

	

	
	\begin{definition}[Interpretation; interpretation constraint]\label{def:interpretation}\rm
		Given a graph , an \emph{interpretation  in } is a partial function , such that for all variables  on which it is defined,  if  (resp.\ , ESetVar). An \emph{(interpretation) constraint} is a Boolean expression that can be derived from the syntactic category Constraint of the following grammar:
	

	\begin{center}
			\begin{tabular}{lcl}
		Constraint & ::= & VertexVSetVar   EdgeESetVar\\
					& &  \verb#path# '\verb#(#' Vertex '\verb#,#' Vertex ['\verb#,#'  Edge \{'\verb#|#' Edge\}] '\verb#)#'\\
					& &   Constraint  Constraint (  ) Constraint   \\
			\end{tabular}
	\end{center}

	
	Given a constraint , an interpretation  in , and a morphism  with codomain , the value of  in  is defined inductively. If  contains a set variable for which  is undefined, then . Otherwise, if  is , then . If  has the form  with  a node or edge identifier and  a set variable, then  if . If  has the form  with  node identifiers, then  if the predicate  holds. If  has the form  with  node identifiers and  edge identifiers, then  if it is the case that the path predicate  holds. If  has the form  with  a constraint, then  if . If  has the form  (resp.\ ) with  constraints, then  if both (resp.\ at least one of)  and  evaluate(s) to true.
		\qed
	\end{definition}


	
	
	
	\begin{definition}[M-condition; M-constraint]\rm\label{defn:M-condition}
		An \emph{MSO condition} (short.\ \emph{M-condition}) over a graph  is of the form , , , or , where  (resp.\ ESetVar),  is an M-condition over ,  is an injective morphism (since we consider programs with injective matching),  is an interpretation constraint over items in , and  is an M-condition over . Furthermore, Boolean formulae over M-conditions over  are also M-conditions over ; that is, , , and  are M-conditions over  if  are M-conditions over~.
		
		An M-condition over the empty graph  in which all set variables are bound to quantifiers is called an .
		\qed
	\end{definition}

		For brevity, we write  for ,  for ,  for ,  for ,  for ,  for  (analogous for other set quantifiers),  for ,  for , and  for .
		
		In our examples, when the domain of a morphism  can unambiguously be inferred, we write only the codomain . For instance, an M-constraint  can be written as .
	
	
	\begin{definition}[Satisfaction of M-conditions]\rm
		Let  denote an injective morphism,  an M-condition over , and  an interpretation in . We define inductively the meaning of , which denotes that  \emph{satisfies}  \emph{with respect to} . If  has the form , then . If  has the form  (resp.\ ), then  if , where  for some  (resp.\  for some ). If  has the form , then  if there is an injective morphism  such that , , and .
		
		A graph  \emph{satisfies} an M-constraint , denoted , if , where  is the \emph{empty interpretation in} , i.e.\ undefined on all set variables.		
	\qed
	\end{definition}
	
	We remark that model checking for both first-order and monadic second-order logic is known to be PSPACE-complete \cite{Flum-Grohe06a}. However, the model checking problem for monadic second-order logic on graphs of bounded treewidth can be solved in linear time \cite{Courcelle90b}.

	
	\begin{example}\label{eg:2colouring}\rm
		The following M-constraint  (translated from the corresponding formula \S 1.5 of \cite{Courcelle90a}) expresses that a graph is 2-colourable (or bipartite); i.e.\ every node can be assigned one of two colours such that no two adjacent nodes have the same one. Let  denote .\\
		
		\begin{tabular}{rll}
			\hspace{-7pt}\vspace{5pt} & &\mathtt{v}  \mathtt{v} \\
			
			\vspace{5pt}&& \mathtt{v}\mathtt{w}\mathtt{v}\mathtt{w}\mathtt{v}\mathtt{w} \\
			
		\end{tabular}\\
				
		\noindent A graph  will satisfy  if there exist two subsets of  such that: (1) every node in  belongs to \emph{exactly one} of the two sets; and (2) if there is an edge from one node to another, then those nodes are not in the same set. Intuitively, one can think of the sets  and  as respectively denoting the nodes of colour one and colour two. If two such sets do not exist, then the graph cannot be assigned a 2-colouring.
		\qed
	\end{example}
	
	\begin{theorem}[M-constraints are equivalent to MSO formulae]\label{thm:formulae_equiv}\rm
		The assertion languages of M-constraints and MSO graph formulae are equivalently expressive: that is, given an M-constraint , there exists an MSO graph formula  such that for all graphs ,  if and only if ; and vice versa.
		\qed
	\end{theorem}
	
	\begin{proof}
		See Appendix \ref{app:proofs:expressiveness}.
	\end{proof}
	

	
	
		\section{Graph Programs}\label{sec:graph_programs}

		In this section we define rules, rule application, and graph programs. Whilst the syntax and semantics of the control constructs are based on those of GP 2 \cite{Plump12a}, the rules themselves follow \cite{Habel-Pennemann-Rensink06a,Pennemann09a}, i.e.\ are labelled over a fixed finite alphabet, and do not support relabelling or expressions. We equip the rules with application conditions (M-conditions over the left- and right-hand graphs), and define \emph{rule application} via the standard double-pushout construction \cite{Ehrig-Ehrig-Prange-Taentzer06a}.
		
		\begin{definition}[Rule; direct derivation]\label{def:rule}\rm
			A \emph{plain rule}  comprises two inclusions , . We call  the left- (resp.\ right-) hand graph and  the interface. An \emph{application condition}  for  consists of two M-conditions over  and  respectively. A \emph{rule}  is a plain rule  and an application condition  for .
			
			
			For a plain rule  and a morphism , a \emph{direct derivation}  (short.\  or ) is given by the pushouts  and . For a rule , there is a \emph{direct derivation}  if , , and . We call  a \emph{match} (resp.\ \emph{comatch}) for . Given a set of rules , we write  if  for some .
			\qed
		\end{definition}
		
		It is known that, given a (plain) rule , graph , and morphism  as above, there exists a direct derivation if and only if  satisfies the \emph{dangling condition}, i.e.\ that no node in  is incident to an edge in . In this case,  and  are determined uniquely up to isomorphism, constructed from  as follows: first, remove all edges in  obtaining . Then add disjointly all nodes and edges from  retaining their labels. For ,  if , otherwise , (targets defined analogously) resulting in the graph .

		We will often give rules without the interface, writing just . In such cases we number nodes that correspond in  and , and establish the convention that  comprises exactly these nodes and that  (i.e.\  can be completely inferred from ). Furthermore, if the application condition of a rule is , then we will only write the plain rule component.
		
		We consider now the syntax and semantics of graph programs, which provide a mechanism to control the application of rules to some graph provided as input.

			\begin{definition}[Graph program]\label{def:graph_program}\rm
				\emph{(Graph) programs} are defined inductively. First, every rule (resp.\ rule set)  and  are programs. Given programs , we have that , , , and  are programs.
				\qed
			\end{definition}

			Graph programs are \emph{nondeterministic}, and their execution on a particular graph could result in one of several possible outcomes. That outcome could be a graph, or it could be the special state ``fail'' which occurs when a rule (set) is not \emph{applicable} to the current graph.

			An operational semantics for programs is given in Appendix \ref{app:semantics}, but the informal meaning of the constructs is as follows. Let  denote an input graph. Programs  correspond to rule (resp.\ rule set) application, returning  if there exists some  (resp.\ ); otherwise fail. Program  denotes sequential composition. Program  denotes as-long-as-possible iteration of . Finally, the conditional programs execute the first or second branch depending on whether executing  returns a graph or fail, with the distinction that the  construct does not retain any effects of , whereas the  construct does.		


	\begin{example}\label{eg:grow_tree}\rm
		Consider the program  defined by the rules:


				\begin{center}
				\fbox{\emptyset\dder\dder


			}
		\end{center}


\noindent	where  is an (unspecified) M-condition over  expressing some termination condition for the iteration (proving termination is not our concern here, see e.g.\ \cite{Poskitt-Plump13a}). The program, if executed on the empty graph, nondeterministically constructs and returns a tree. It applies the rule  exactly once, creating an isolated node. It then iteratively applies the rule  (each application adding a leaf to the tree) until the termination condition  holds. An example program run, with \mathtt{1}, is:

	\qed
	\end{example}
	

	
	
	
	
\section{Constructing a Weakest Liberal Precondition}\label{sec:constructing_wlps}
	
In this section, we present a construction for the \emph{weakest liberal precondition} relative to a rule  and a postcondition  (which is an M-constraint). In our terminology, if a graph satisfies a weakest liberal precondition, then: (1) any graphs resulting from applications of  will satisfy ; and (2) there does not exist another M-constraint with this property that is weaker. (Note that we do not address termination or existence of results in this paper.)

The construction is adapted from the one for nested conditions in \cite{Habel-Pennemann09a}, and as before, is broken down into a number of stages. First, a translation of postconditions into M-conditions over  (transformation ``A''); then, from M-conditions over  into M-conditions over  (transformation ``L''); and finally, from M-conditions over  into an M-constraint expressing the weakest liberal precondition (via transformations ``App'' and ``Pre'').

First, we consider transformation A, which constructs an M-condition over  from a postcondition (an M-constraint) by computing a disjunction over all the ways that the M-constraint and comatches might ``overlap''.

\begin{theorem}[M-constraints to M-conditions over ]\label{thm:A}\rm
	There is a transformation A, such that for all M-constraints , all rules  with right-hand side , and all injective morphisms ,
	
\end{theorem}

\noindent	\emph{Construction.} Let  denote an M-constraint, and  a rule with right-hand side . We define  where  is defined inductively as follows. For injective graph morphisms  and M-conditions over , define:


	\\


	

	\noindent	The final equation relies on the following. First, construct the pushout  of  and  leading to injective graph morphisms  and .

\begin{wrapfigure}[10]{r}{0.35\textwidth}
	\centering
		\vspace{-25pt}
		\includegraphics[width=0.3\textwidth]{construction-A.eps}
\end{wrapfigure}
	\noindent The disjunction then ranges over the set , which we define to contain every surjective graph morphism  such that  and  are injective graph morphisms (we consider the codomains of each  up to isomorphism, hence the disjunction is finite).

	The transformations  are extended for Boolean formulae over M-conditions in the usual way, that is, , , and  (analogous for ).
	\qed






\begin{example}\label{eg:grow_A_new}\rm
	Recall the rule  from Example \ref{eg:grow_tree}. Let  denote the M-constraint:
	
	
	\noindent for , which expresses that there are two sets of nodes  in the graph, such that if there is a path from some node  to some node , then  belongs only to  and  only to . Applying transformation A:
	

	\begin{center}
		\begin{tabular}{r c l}
			\multicolumn{3}{l}{} \\

			&& \vspace{5pt}\mathtt{1}\mathtt{2}\\
			
			&& \mathtt{1}\mathtt{2}\mathtt{v}\mathtt{w}\\
			
			&& \vspace{5pt}\hspace{0.125in}\mathtt{v}\mathtt{w}\mathtt{v}\mathtt{w}\\
			
			
			
			
			&& \mathtt{1}\mathtt{2}\\
		\end{tabular}
	\end{center}
	
	\noindent where the graphs  are as given in Figure \ref{fig:eg-A-L}.
	\qed
\end{example}

\begin{figure}[htb]
	\centering
	\includegraphics[width=0.95\textwidth]{eg-A.eps}
	\caption{Applying the construction in Examples \ref{eg:grow_A_new} and \ref{eg:grow_L_new}}\label{fig:eg-A-L}
\end{figure}






In order to prove the statement of Theorem \ref{thm:A}, we first prove a more general lemma stating that an M-condition over  can be shifted over a morphism  with domain . It is a generalised version of Lemma 3 in \cite{Habel-Pennemann09a}, but the proof is almost identical as interpretation constraints are not manipulated by this transformation, and both sides of the statement are interpreted in the same graph.

\begin{lemma}[Shifting M-conditions over morphisms]\rm\label{lemma:shifting}
	For all M-conditions  over , all interpretations  in , and all injective morphisms , we have:
	
	\qed
\end{lemma}

\begin{proof}
	See Appendix \ref{lemma:shifting:PROOF}.
	\qed
\end{proof}

Theorem \ref{thm:A} then follows as an instance of Lemma \ref{lemma:shifting}.

\begin{proof}[of Theorem \ref{thm:A}]
	With the construction of A, Lemma \ref{lemma:shifting}, and the definition of , we have:  iff  iff  iff  iff .
	\qed
\end{proof}


Transformation L, adapted from \cite{Habel-Pennemann09a}, takes an M-condition over  and constructs an M-condition over  that is satisfied by a match if and only if the original is satisfied by the comatch. The transformation is made more complex by the presence of path and MSO expressions, because nodes and edges referred to on the right-hand side may no longer exist on the left. For clarity, we separate the handling of these two types of expressions, and in particular, define a \emph{decomposition} LPath of path predicates according to the items that the rule is creating or deleting. For example, if an edge is created by a rule, a path predicate decomposes to a disjunction of path predicates collectively asserting the existence of paths to and from the nodes that will eventually become its source and target; whereas if an edge is to be deleted, the predicate will exclude it.



\begin{proposition}[Path decomposition]\label{prop:LPath}\rm
	There is a transformation LPath such that for every rule , direct derivation , path predicate  over , and interpretation ,
	
\end{proposition}

\noindent \emph{Construction.} Let  and . For simplicity, we will treat the syntactic construct  as a set of edges and identify  and  when  is empty. Then, define:


\noindent Here,  is constructed from  by adding edges , i.e.\ that the rule will delete. Furthermore,  decomposes to path predicates according to whether  and  exist in . If  holds, then  returns . Otherwise, if both , then it returns . If , it returns:


\noindent for each  such that . Case  analogous. If , then it returns  for all  such that  and .

Finally,  denotes  in disjunction with:
\begin{center}
	\begin{tabular}{c}
		\\
		
	\end{tabular}
\end{center}

\noindent over all non-empty sequences of distinct pairs  drawn from:

	\qed
	
\begin{proof}
	See Section \ref{prop:LPath:PROOF}.
	
	\qed
\end{proof}

In addition to paths, transformation L must handle MSO expressions that refer to items present in  but absent in . To achieve this, it computes a disjunction over all possible ``future'' (i.e.\ immediately after the rule application) set memberships of these missing items. The idea being, that if a set membership exists for these missing items that satisfies the interpretation constraints \emph{before} the rule application, then one will still exist once they have been created. The transformation keeps track of such potential memberships via sets of pairs as follows.


\begin{definition}[Membership set]\rm
	A \emph{membership set}  is a set of pairs  of node or edge identifiers  with set variables of the corresponding type. Intuitively,  encodes that , whereas  encodes that .
	\qed
\end{definition}

\begin{theorem}[From M-conditions over  to ]\label{thm:L}\rm
	There is a transformation L such that for every rule , every M-condition  over  (with no free variables, and distinct variables for distinct quantifiers), and every direct derivation ,
	
\end{theorem}
	
	\noindent \emph{Construction.} Let  denote a rule and  an M-condition over . We define . For such an , and membership set , the transformation  is defined inductively as follows:
	




	\noindent where  and .
	
	For case , we define:
		
	
	\noindent if  has no pushout complement; otherwise:

	


	
	\begin{wrapfigure}[6]{r}{0.5\textwidth}
		\centering
			\vspace{-2.5pt}
			\includegraphics[width=0.45\textwidth]{construction-L.eps}
	\end{wrapfigure}
	\noindent which relies on the following. First, construct the pushout , with  the ``derived'' rule obtained by constructing pushout . The interpretation constraint  is obtained from  as follows. First, consider each predicate  such that . If  for some , replace the predicate with ; otherwise . Then, replace each path predicate  with .
	
	The transformation L is extended for Boolean formulae in the usual way, that is, , , and  (analogous for ).	
	\qed

\begin{example}\label{eg:grow_L_new}\rm
	Take , ,  and  as considered in Example \ref{eg:grow_A_new}. Applying transformation L: 
	
	\begin{center}
		\begin{tabular}{r c l}
			\multicolumn{3}{l}{} \\

			
			&& \vspace{5pt}\mathtt{1}\mathtt{2}\\
			
			&& \vspace{5pt}\hspace{0.25in}\\
			
			&& \mathtt{1}\\

			&& \mathtt{1}\mathtt{v}\mathtt{1}\mathtt{v}\mathtt{1}\mathtt{v}\\
			
			&& \mathtt{1}\mathtt{w}\mathtt{1}\mathtt{w}\\
			
			&& \mathtt{1}\mt{=}\mathtt{v}\mathtt{1}\mt{=}\mathtt{v}\\
			
			&& \vspace{5pt}\mathtt{1}\mt{=}\mathtt{w}\mathtt{1}\mt{=}\mathtt{w}\\
			
			
			
			
			
			
			
			
			
			
			&& \mathtt{1}\\

			&& \mathtt{1}\mathtt{v}\mathtt{1}\mathtt{v}\mathtt{1}\mathtt{v}\\
					
			&& \vspace{5pt}\mathtt{1}\mt{=}\mathtt{v}\mathtt{1}\mt{=}\mathtt{v}\\
			
			

			
			
			
			
			&& \mathtt{1}\\
			
			&& \mathtt{1}\mathtt{v}\mathtt{1}\mathtt{v}\mathtt{1}\mathtt{v}\\
			
			&& \mathtt{1}\mt{=}\mathtt{v}\mathtt{1}\mt{=}\mathtt{v}\\
			
		\end{tabular}
	\end{center}
	
	\noindent where the graphs  and  are as given in Figure \ref{fig:eg-A-L} and . Here, only one of the subsets ranged over yields a satisfiable disjunct: , i.e.  for .
	\qed
\end{example}

In order to prove the statement about L (which is interpreted over ), we need to prove a more general lemma.

\begin{lemma}\label{lemma:L}\rm
	There is a transformation L such that for every rule , every M-condition  over  with distinct variables for distinct quantifiers, every interpretation  in  defined for all free set variables of , every membership set  such that  implies , and every direct derivation ,
	
	
	\noindent Here,  is defined as  except for all , where  if and only if .
	\qed
\end{lemma}

\begin{proof}
	See Appendix \ref{lemma:L:PROOF}.
	\qed
\end{proof}

\begin{proof}[of Theorem \ref{thm:A}]\rm
	With the construction of L, Lemma \ref{lemma:L}, and the definition of , we have:  iff  iff .
	\qed
\end{proof}

Transformation App, adapted from Def in \cite{Pennemann09a}, takes as input a rule set  and generates an M-constraint that is satisfied by graphs for which  is applicable.

\begin{theorem}[Applicability of a rule]\label{thm:A}\rm
	There is a transformation App such that for every rule set  and every graph ,
	

\noindent \emph{Construction.} If  is empty, define ; otherwise, for , define:
	
	
	\noindent For each rule  with , we define . Here, , where the index set  ranges over all injective graph morphisms  (up to isomorphic codomains) such that the pair  has no pushout complement; each  a graph that can be obtained from  by adding either (1) a loop; (2) a single edge between distinct nodes; or (3) a single node and a non-looping edge incident to that node.
	\qed
\end{theorem}

\begin{proof}
	See the corresponding proofs in \cite{Pennemann09a} and \cite{Poskitt13a} for nested conditions and E-conditions respectively. (The difference is in the application conditions, i.e.\ M-conditions over  and . Correctness follows from the definition of  for M-conditions and Theorem \ref{thm:L}.)
	\qed
\end{proof}

Finally, transformation Pre (adapted from \cite{Habel-Pennemann-Rensink06a}) combines the other transformations to construct a weakest liberal precondition relative to a rule and postcondition.

\begin{theorem}[Postconditions to weakest liberal preconditions]\label{thm:Pre}\rm
	There is a transformation Pre such that for every rule , every M-constraint , and every direct derivation ,
	
	
	\noindent Moreover,  is the \emph{weakest liberal precondition} relative to  and .\\

\noindent \emph{Construction.} Let  denote a rule and  denote an M-constraint. Then:
	
	\qed
\end{theorem}
	
\begin{proof}
	As for nested conditions (see \cite{Pennemann09a}), but adapted for the definition of  for M-conditions and Theorem \ref{thm:L}. That Pre and App can be used to construct the weakest liberal precondition is shown in \cite{Poskitt13a}.
	\qed
\end{proof}
	
\begin{example}\label{eg:grow_Pre_new}\rm
	Take , ,  and  as considered in Example \ref{eg:grow_L_new}. Applying transformation Pre:
	
	\begin{center}
		\begin{tabular}{r c l}
			\multicolumn{3}{l}{} \\

			
			&& \mathtt{1}\mathtt{1}\\
			
			&& \hspace{0.125in}\mathtt{1}\mathtt{v}\mathtt{1}\mathtt{v}\mathtt{1}\mathtt{v}\\

			&& \hspace{0.125in}\mathtt{1}\mt{=}\mathtt{v}\mathtt{1}\mt{=}\mathtt{v}\\
		\end{tabular}
	\end{center}
	
	\noindent where the graphs  are as given in Figure \ref{fig:eg-A-L}. This M-constraint is only satisfied by graphs that do not have any edges between distinct nodes, because of the assertion that every match (i.e.\ every node) must be in  and not in . Were an edge to exist -- i.e.\ a path -- then the M-constraint asserts that its target is in ; a contradiction.
	\qed
\end{example}














	\section{Proving Non-Local Specifications}\label{sec:example_proofs}
	
	In this section we show how to systematically prove a non-local correctness specification using a Hoare logic adapted from \cite{Poskitt-Plump12a,Poskitt13a}. The key difference is the use of M-constraints as assertions, and our extension of Pre in constructing weakest liberal preconditions for rules. (We note that one could just as easily adapt the Dijkstra-style systems of \cite{Habel-Pennemann-Rensink06a,Pennemann09a}.)
	
	We will specify the behaviour of programs using \emph{(Hoare) triples}, , where  is a program, and  are \emph{pre-} and \emph{postconditions} expressed as M-constraints. We say that this specification holds in the sense of \emph{partial correctness}, denoted by , if for any graph  satisfying , every graph  resulting from the execution of  on  satisfies .
	
	For systematically proving a specification, we present a \emph{Hoare logic} in Figure \ref{fig:a_hoare_logic}, where  range over M-constraints,  over programs,  over rules, and  over rule sets. If a triple  can be instantiated from an axiom or deduced from an inference rule, then it is \emph{provable} in the Hoare logic and we write . Proofs shall be displayed as trees, with the specification as the root, axiom instances as the leaves, and inference rule instances in-between.
	
	\begin{figure}[htb]
	\vspace{-25pt}
	{\footnotesize\begin{center}
	\begin{tabular}{ p{0.5\textwidth} p{0.5\textwidth} }

	\vspace{2pt}\begin{prooftree}
\AxiomC{[ruleapp]\ \ }
	\end{prooftree}
	&
	\begin{prooftree}
	\AxiomC{r\in\R}
	\LeftLabel{[]}
	\UnaryInfC{}
	\end{prooftree}
	\-15pt]

	\multicolumn{2}{p{\textwidth}}{


	\begin{prooftree}
	\AxiomC{}
	\LeftLabel{[cons]} \UnaryInfC{}
	\end{prooftree}
	
	}\\
	\end{tabular}\end{center}\vspace*{-4mm}
	}
	\caption{A Hoare logic for partial correctness}\label{fig:a_hoare_logic}
	\end{figure}
	
	 For simplicity in proofs we will typically treat [ruleapp] as two different axioms (one for each disjunct). Note that we have omitted, due to space, the proof rules for the conditional constructs. Note also the restriction to rule sets in [!], because the applicability of arbitrary programs cannot be expressed in a logic for which the model checking problem is decidable \cite{Poskitt13a}.
	
	\begin{theorem}[Soundness]\rm
		Given a program  and M-constraints , we have that  implies .
		\qed
	\end{theorem}
	
\begin{proof}
	See \cite{Poskitt13a} for a soundness proof of the corresponding extensional partial correctness calculus.
	\qed
\end{proof}	
	
	
	
	The remainder of this section demonstrates the use of our constructions and Hoare logic in proving non-local specifications of two programs. For the first, we will consider a property expressed in terms of MSO variables and expressions, whereas for the second, we will consider properties expressed in terms of  predicates. Both programs are simple, as our focus here is not on building intricate proofs but rather on illustrating the main novelty of this paper: a Pre construction for MSO properties.
	
	\begin{example}\rm
	Recall the program  of Example \ref{eg:grow_tree} that nondeterministically constructs a tree. A known non-local property of trees is that they can be assigned a 2-colouring (i.e.\ they are bipartite), a property that the M-constraint  of Example \ref{eg:2colouring} precisely expresses. Hence we will show that , where  expresses that the graph is empty. A proof tree for this specification is given in Figure \ref{eg:trees_2col}, where the interpretation constraints  and  in  are respectively   and .
	
	
\begin{figure}[htb]
	\centering	
	{\small
		\begin{prooftree}


\AxiomC{}

	\UnaryInfC{}


\AxiomC{}




	\UnaryInfC{}

	\UnaryInfC{}


	\BinaryInfC{}
	\end{prooftree}}

	

	

	

		\begin{tabular}{r c l}
			 &&  \\
			
			
			 && \mathtt{1}\\
			
			&& \hspace{0.25in}\mathtt{1}\mathtt{v}\mathtt{1}\mathtt{v}\mathtt{1}\mt{=}\mathtt{v}\mathtt{1}\mt{=}\mathtt{v} \\
			
		
		

			&& \hspace{0.25in}\mathtt{1}\mathtt{v}\mathtt{w}\mathtt{1}\mathtt{v}\mathtt{w}\mathtt{1}\mathtt{v}\mathtt{w}\\
			
			&& \hspace{0.25in}\mathtt{1}\mt{=}\mathtt{v}\mathtt{w}\mathtt{1}\mt{=}\mathtt{v}\mathtt{w}\mathtt{1}\mt{=}\mathtt{v}\mathtt{w}\\
			

			

			&& \hspace{0.25in}\mathtt{1}\mt{=}\mathtt{w}\mathtt{v}\mathtt{1}\mt{=}\mathtt{w}\mathtt{v}\mathtt{1}\mt{=}\mathtt{w}\mathtt{v}\\
			
			&& \hspace{0.25in}\mathtt{1}\mt{=}\mathtt{v}\mathtt{1}\mt{=}\mathtt{v}\\
			
			&& \hspace{0.375in}\mathtt{1}\mt{=}\mathtt{v}\mathtt{1}\mt{=}\mathtt{v} 

		\end{tabular}
	\caption{Trees are 2-colourable}\label{eg:trees_2col}
\end{figure}

	Observe that  is essentially an ``embedding'' of the postcondition  within the context of possible matches for . The second line expresses that every node (whether the node of the match or not) is coloured  or . The following three conjuncts then express that any edges in the various contexts of the match connect nodes that are differently coloured. The final conjunct is of the same form, but is ``pre-empting'' the creation of a node and edge by . To ensure that the graph remains 2-colourable, node  of the match must not belong to both sets; this, of course, is already established by the first nested conjunct. Hence the first implication arising from instances of [cons], , is valid. The second implication, , is also valid since a graph satisfying  will not have any nodes to quantify over.
	\qed
\end{example}
	
	
	\begin{example}\rm	
		An \emph{acyclic graph} is a graph that does not contain any \emph{cycles}, i.e.\ non-empty paths starting and ending on the same node. One way to test for acyclicity is to apply the rule \mathtt{1}\mathtt{2}\mathtt{1}\mathtt{2} for as long as possible; the resulting graph being edgeless if the input graph was acyclic. Here,  denotes the left application condition \mathtt{1}\mathtt{2}\mathtt{1}\mathtt{2}\mathtt{1}\mathtt{2}\mathtt{1}\mathtt{2}, expressing that in matches, either the source node has indegree  or the target node has outdegree  (we do not consider the special case of looping edges for simplicity). Note that nodes \emph{within} a cycle would not satisfy this: if a source node has an indegree of  for example, there would be no possibility of an outgoing path ever returning to the same node.
		
		We prove two claims about this rule under iteration: first, that it deletes all edges in an acyclic graph; second, that if applied to a graph containing cycles, the resulting graph would not be edgeless. That is,  and , for M-constraints  (for \underline{c}ycles),  (for \underline{e}dgeless), , and proofs as in Figure \ref{fig:proof_trees_acyclicity}.
	
	
	\begin{figure}[htb]
		\centering
		
		
	\vspace{-25pt}{\small\begin{tabular}{ p{0.5\textwidth} p{0.5\textwidth} }
				
					\begin{prooftree}


			\AxiomC{}

			\UnaryInfC{}


				\UnaryInfC{}

				\UnaryInfC{}
				\end{prooftree}

		    &
				
					\begin{prooftree}


						\AxiomC{}

			\UnaryInfC{}


				\UnaryInfC{}

				\UnaryInfC{}
				\end{prooftree}\end{tabular}}
			
			\begin{tabular}{r c l}
				 && \mathtt{v}\mathtt{w}\\

				 && \mathtt{v}\mathtt{w}\\
				
				 && \mathtt{1}\mathtt{2}\mathtt{e}\\

				&&  \hspace{0.125in}\mathtt{1}\mathtt{2}\mathtt{e}\mathtt{v}\mathtt{w}\mathtt{1}\mt{=}\mathtt{v}\mathtt{2}\mathtt{e}\mathtt{w}\\

				&& \hspace{0.125in}\mathtt{1}\mathtt{2}\mt{=}\mathtt{v}\mathtt{e}\mathtt{w}\mathtt{1}\mt{=}\mathtt{w}\mathtt{2}\mathtt{e}\mathtt{v}\\

				&& \hspace{0.125in}\mathtt{1}\mathtt{2}\mt{=}\mathtt{w}\mathtt{e}\mathtt{v}\mathtt{1}\mt{=}\mathtt{v}\mathtt{2}\mt{=}\mathtt{w}\mathtt{e}\\

				&& \hspace{0.125in}\mathtt{1}\mt{=}\mathtt{w}\mathtt{2}\mt{=}\mathtt{v}\mathtt{e}\\
			
				
				 && \mathtt{1}\mathtt{2}\\
			\end{tabular}
	
		\caption{Acyclity (or lack thereof) is invariant}\label{fig:proof_trees_acyclicity}
	\end{figure}
		
		
	First, observe that  is essentially an ``embedding'' of the postcondition  within the context of possible matches for . The path predicates in  now additionally assert (as a result of the L transformation) that paths do not include images of edge : this is crucially important for establishing the postcondition because the rule deletes the edge. For space reasons we did not specify , but this can be constructed from  by replacing each  with  and removing each  in the nested part.
	
	The instances of [cons] give rise to implications that we must show to be valid. First,  is valid: a graph satisfying  does not contain any cycles, hence it also does not contain cycles outside of the context of matches for . Second,  is valid: a graph satisfying the antecedent does not contain any cycles and also no pair of incident nodes for which  holds. If the graph is not edgeless, then there must be some such pair satisfying ; otherwise the edges are within a cycle. Hence the graph must be edgeless, satisfying .
	
	In the second proof tree,  is valid. A graph satisfying  contains a cycle: clearly, no edge (with its source and target) in this cycle satisfies ; hence the graph satisfies the consequent, since images of edge  cannot be part of the cycle in the graph. Finally,  is valid: if a graph satisfies the antecedent, then it contains a cycle, the edges of which  will never be applicable to because of ; hence the graph cannot be edgeless, and satisfies .
	\qed
	\end{example}
	











	
	\section{Related Work}\label{sec:related_work}
	
	We point to a few related publications addressing the verification of non-local graph properties through proofs / theorem proving and model checking.
	
	Habel and Radke have considered HR conditions \cite{Habel-Radke10a}, an extension of nested conditions embedding hyperedge replacement grammars via graph variables. The formalism is more expressive than MSO logic on graphs (it is able, for example, to express node-counting MSO properties such as ``the graph has an even number of nodes'' \cite{Radke13a}) but it is not yet clear whether an effective construction for weakest liberal preconditions exists. Percebois et al. \cite{Percebois-Strecker-Tran13a} demonstrate how one can verify global invariants involving paths, directly at the level of rules. Rules are modelled with (a fragment of) first-order logic on graphs in the interactive theorem prover Isabelle. Inaba et al. \cite{Inaba-et-al11a} address the verification of type-annotated Core UnCAL -- a query algebra for graph-structured databases -- against input/output graph schemas in MSO. They first reformulate the query algebra itself in MSO, before applying an algorithm that reduces the verification problem to the validity of MSO over trees.
	
	The GROOVE model checker \cite{Ghamarian-Mol-Rensink-Zambon-Zimakova12a} supports rules with paths in the left-hand side, expressed as a regular expression over edge labels. One can specify such rules to match only when some (un)desirable non-local property holds, and then verify automatically that the rule is never applicable. Augur 2 \cite{Koenig-Kozioura08a} also uses regular expressions, but for expressing forbidden paths that should not occur in any reachable graph.
	
	\section{Conclusion}\label{sec:conclusion}
	
	This paper has contributed the means for systematic proofs of graph programs with respect to non-local specifications. In particular, we defined M-conditions, an extension of nested conditions equivalently expressive to MSO logic on graphs, and defined for this assertion language an effective construction for weakest liberal preconditions of rules. We demonstrated the use of this work in some Hoare-style proofs of programs relative to non-local invariants, i.e.\ the existence of 2-colourings, and the existence of arbitrary-length cycles. Some interesting topics for future work include: extending M-conditions and Pre to support other useful predicates (e.g.\ an \emph{undirected} path predicate), adding support for attribution (e.g.\ along the lines of \cite{Poskitt-Plump12a,Poskitt13a}), implementing the construction of Pre, and generalising the resolution- and tableau-based reasoning systems for nested conditions \cite{Pennemann08a,Lambers-Orejas14a} to M-conditions.\\
	
	\noindent \textbf{Acknowledgements.} The research leading to these results has received funding from the
	European Research Council under the European Union's Seventh Framework
	Programme (FP7/2007-2013) / ERC Grant agreement no. 291389.

	\bibliographystyle{splncs03}
	
	\bibliography{references}
	
	\newpage\appendix
	
	\section*{Appendix: Proofs and Semantics}
	
	\section{Expressive Equivalence to MSO Formulae}\label{app:proofs:expressiveness}
	
	In this section we prove that M-conditions and MSO formulae on graphs are equivalently expressive. We define a many-sorted MSO logic on graphs (in the spirit of \cite{Courcelle90a}), and show that there are translations from this logic to M-conditions and vice versa. The logic and translations are based on those of \cite{Poskitt13a} for nested conditions with expressions. (An alternative approach is to use a single-sorted logic, e.g. \cite{Habel-Radke10a}.) Throughout this section we will assume that graphs are labelled over some fixed label alphabet .
	
	\subsection{Syntax and Semantics}
	
	We define the syntax and semantics of a many-sorted MSO logic on graphs. The idea is to assign sorts (or types) -- edge, vertex, edge set, or vertex set -- to every expression of the logic, and prevent at the syntactic level the composition of formulae that do not ``make sense'' under interpretation. For example, we discard as syntactically ill-formed any expression  in which  is not an edge expression (since this will be interpreted as the source function of some graph).

	\begin{definition}[Expressions]\label{defn:ms_logic:expressions}\rm
		The grammar in Figure \ref{fig:app:expressions} defines four syntactic categories of \emph{expressions}: Edge, Vertex, EdgeSet, and VertexSet. They respectively contain (disjoint) syntactic categories of \emph{variables}: EVar, VVar, ESetVar, and VSetVar.

	\vspace*{-.25\baselineskip} \begin{figure}[htb]
	\renewcommand{\arraystretch}{1.2}
	\begin{center}
	\begin{tabular}{lcl}
	Expression & ::= & Edge  Vertex  EdgeSet  VertexSet \\
	Edge & ::= & EVar \\
	Vertex & ::= & VVar  (  ) '' Edge ''\\
	EdgeSet & ::= & ESetVar \\
	VertexSet & ::= & VSetVar \\
	\end{tabular}
	\end{center}
	\caption{Abstract syntax of expressions \label{fig:app:expressions}}
	\end{figure}
	\qed
	\end{definition}
	
	
	
	
	
	\begin{definition}[Sorts, sort function]\label{defn:app:sorts}\rm
		Every expression is associated with a \emph{sort} (or \emph{type}), determined by the syntactic category it is contained within. We use the name of that category to denote its sort. The function  is the \emph{sort function}, that takes an expression  as input and returns its sort.
	\qed
	\end{definition}
	
	The formulae of the logic can quantify over first-order and MSO (i.e. set) variables, and express the existence of edges and nodes in sets of the corresponding type. Note that we do not include equality of set variables, since this can be defined precisely in terms of set membership over individual elements.
	
	
	\begin{definition}[Formulae]\label{defn:app:formulae}\rm
		Figure \ref{fig:app:ms_formula_syntax} defines \emph{formulae}, where  and .

	\begin{figure}[htb]
	\renewcommand{\arraystretch}{1.2}
	\begin{center}
	\begin{tabular}{lcl}
	Formula & ::= &     Edge '\verb#=#' Edge  Vertex '\verb#=#' Vertex\\
	&&   '' Edge ''   '' Vertex '' \\
	&&  Edge '' EdgeSet  Vertex '' VertexSet \\
	&& \ '' Formula  Formula BoolOp Formula  \\
	&& \ Quantifier (VVar '\texttt{:}'  EVar '\texttt{:}'\\
	&& \hspace{0.25in} \ ESetVar '\texttt{:}'  VSetVar '\texttt{:}' ) '\mt{.}' Formula \\
	BoolOp & ::= &        \\
	Quantifier & ::= &   
	\end{tabular}
	\end{center}
	\caption{Abstract syntax of formulae}\label{fig:app:ms_formula_syntax}
	\end{figure}

	\qed
	\end{definition}
	
The symbols ,  are \emph{function symbols} of arity one, and are syntactic representations of source and target functions. The symbols  are \emph{predicate symbols} of arity one, expressing that an item is labelled by . The symbols  are predicate symbols of arity two, and are syntactic representations of equality and set membership.
	
	The \emph{free variables} of a formula are those that are not bound by a quantifier. Note that such variables still have sorts. If a formula contains no such free variables, then we call it a sentence.

	\begin{definition}[Sentence]\label{defn:sentence}\rm
		A \emph{sentence} (or a \emph{closed formula}) is a formula that contains no free variables.
	\qed
	\end{definition}
	
	Sentences of the logic are evaluated with respect to interpretations. These map the sorts to disjoint semantic domains, function symbols to functions, and predicate symbols to Boolean-valued functions. In particular, given some graph, we build an interpretation from its nodes, edges, source, target, and labelling functions. (Note that interpretations here are different from interpretations for M-conditions, which map only set variables to elements of the corresponding semantic domains.)


	\begin{definition}[Satisfaction of sentences]\label{defn:app:graph_structure}\label{defn:app:interpretation_function}\label{defn:app:satisfaction_structures}\rm
		An \emph{interpretation}  is a mapping from (1) sorts to semantic domains, (2) expressions , with  a function symbol and each  an expression, to functions of arity:
	

	\noindent and (3) formulae , with  a predicate symbol and each  an expression, to Boolean-valued functions of arity:
	


		Let  be an interpretation function, and  be a sentence. The \emph{satisfaction} of  by , denoted , is defined inductively as follows.

		If  is  (resp. ), then  (resp.  does not hold). If  is  with  a predicate symbol and each  an expression, then  if .

		Let  be sentences. If  is , then  if  does not hold. If  is  (resp. ), then  if  and (resp. or) . If  is , then  if  or . If  is , then  if  and .

		Let  be a variable of sort , and  be a formula with  as its only free variable. Let also  denote the symbol that corresponds with sort . If  has the form , then  if there is some  such that  where  is equal to  but with the addition that . If  is , then  if for every , .

	\qed
	\end{definition}


	\begin{definition}[Satisfaction of sentences by graphs]\label{defn:interpretation_function}\label{defn:satisfaction_graphs}\rm
		Let  be a graph and  be a sentence. We say that  \emph{satisfies} , denoted by , if , where  is the \emph{interpretation induced by }, defined as follows:


		\emph{Sorts.} We define , , , and  .
		
		\emph{Function symbols.} We define  and . We define  and  to be the functions  and  respectively.

		\emph{Predicate symbols.} We define  where  returns true for inputs  if ; false otherwise. (Analogous for node label predicates.) We define  to be equality in the standard sense. We define  where  returns true for inputs  if ; false otherwise.

	\qed
	\end{definition}
	
	
	
	\subsection{From Formulae to M-Conditions}
	
	In this subsection we prove that formulae can be translated into equivalent M-conditions. We define a translation over the abstract syntax of formulae and expressions. It is assumed that distinct quantifiers bind distinct variables in formulae, allowing us to use node and edge variables as identifiers in the corresponding M-condition. This correspondence is very important in the translation: a node variable  will correspond to a node identifier  in the M-condition, and an edge variable  will correspond to an edge identifier  with source and target nodes .
	
	First, we define a helper function that takes a Vertex-sorted expression as input, and returns the node identifier that will be associated with it in the M-condition.
	
	
	\begin{definition}[Helper function VertexID]\label{def:VertexID}\rm
		Let  denote an expression in Vertex. We define:

			
		\qed
	\end{definition}
	
	\begin{theorem}[Sentences can be expressed as M-constraints]\label{thm:Cond}\rm
		Let  denote a sentence. There is a transformation Cond such that for all graphs ,

	

	\noindent \emph{Construction.} We assume that quantifiers in  bind distinct variables (otherwise one can always rename the variables), which allows for variables to correspond to node and edge identifiers. For all sentences , let . The transformation  takes the formula that remains to be translated as its first input, and the domain of the next morphism in the generated M-condition as its second input. We define it inductively over the abstract syntax of formulae (Figure \ref{fig:app:ms_formula_syntax}) and expressions (Figure \ref{fig:app:expressions}).

	Let  denote a graph over . Let  denote formulae (not necessarily sentences).

	If  (resp.\ ), then  (resp.\ ). If , then . If  with , then .
	
	If  with , then  if edges  are identified in , otherwise false.

	If  with  in Vertex, then  if ,  are identified in , otherwise .
	
	If  with  and  in EVar, then  if , otherwise false. (Analogous for node label predicates.)

	If  with  in EVar and  in ESetVar, then:
	
		
	If  with  in Vertex and  in VSetVar, then:
		

	If , then:

	

	\noindent Here,  is the (finite) set of graphs constructed from  by disjointly adding a single node  with some label in , and every graph obtainable from these by identifying a node with .

	If , then:

	

	\noindent Here,  is the (finite) set of graphs defined as follows. Let  denote a graph obtained from  by disjointly adding nodes with identifiers ,  and an edge with identifier  such that , , , , and . The set  contains all such graphs , and all other graphs obtainable from them by identifying  with nodes and edges. (Note that  and  can be identified to create a loop.)
	
	If , then:
	
	
	
	If , then:
	
	

	If , then:
	
	\qed
	\end{theorem}
	
	To prove the theorem, we first prove a more general lemma about the translation of formulae.
	
	
	\begin{lemma}[Formulae can be expressed as M-conditions]\label{lemma:Cond}\rm
		Let  denote a formula,  an interpretation defined for the free set variables of , and  a graph in which every identifier  corresponds to a free (node or edge) variable  in . For all injective graph morphisms , we have:
		

		\noindent Here,  is defined as  but with the following mappings for free variables in : (1) for each set variable  in the domain of , ; (2) for each node  in , ; and (3) for each edge  in , .
	\qed
	\end{lemma}
	
	\begin{proof}
		\emph{Basis.} Most cases are easily adapted from the proof of Lemma 6.18 in \cite{Poskitt13a}. In the case that  has the form  with  in EVar,\\
		
		\begin{center}\begin{tabular}{r c l }
			 &  &  \\
			
			&&   \\
			
			&  &   \\
			
			&  &  \\
			
			&& 
		\end{tabular}\end{center}
		
		\noindent (Analogous for node label predicates.)
		
		In the case that  has the form  with  in EVar and  in ESetVar,
		
		\begin{center}\begin{tabular}{r c l }
			 &  &  \\
			
			&&   \\
			
			&  &   \\
			
			&  &  \\
			
			&  &  \\
			
			&& 
		\end{tabular}\end{center}
		
		\noindent \emph{Step. Only if.} Assume that . Most cases are easily adapted from the proof of Lemma 6.18 in \cite{Poskitt13a}. In the case that  has the form , by assumption, there exists some  such that . Define . Then , and by induction hypothesis, . Finally, with the definition of  for M-conditions, we get the result that . (Case for node set quantification is analogous.)  \\
		
		\noindent \emph{Step. If.} Assume that . Most cases are easily adapted from the proof of Lemma 6.18 in \cite{Poskitt13a}. In the case that  has the form , by assumption and construction, we have . Then there is some  with  (equiv.\ ) such that . By induction hypothesis, we have . Finally, with the definition of  for formulae, we have the result that . (Case for node set quantification is analogous.)		
		\qed
	\end{proof}
	
	\begin{proof}[of Theorem \ref{thm:Cond}]
		Define . We have that:
		
		\begin{center}\begin{tabular}{r c l}
			 &&  \\
			&&  \\
			&&  \\
			&&  \\
			&& .
		\end{tabular}\end{center}
		
		\noindent from the definition of  for formulae and M-conditions, and Lemma \ref{lemma:Cond}.
		\qed
	\end{proof}
	
	
	
	
	
	
	
	
	
	
	
	
	\subsection{From M-Conditions to Formulae}
	
	In this subsection we prove that M-conditions can be translated into equivalent formulae. To simplify the translation, we define a normal form for M-conditions that allows us to assume one new node or edge per level of nesting, as well as the absence of path predicates.
	
	\begin{definition}[Normal form for M-conditions]\rm
		An M-condition  is in \emph{normal form} if all of the following hold:
		
		\begin{enumerate}
			\item all morphisms are inclusions;
			
			\item all morphisms  are either identity morphisms (), or  is the graph  but with one additional node or one additional edge;
					
			\item no interpretation constraint contains a path predicate.
		\end{enumerate}
		\qed
	\end{definition}
	
	\begin{proposition}[M-conditions can be normalised]\rm
		For every M-condition , there is an M-condition  in normal form such that  and  are equivalent, i.e.\ for every morphism , and every interpretation ,
		
		\qed
	\end{proposition}
	
	\begin{proof}[sketch]\rm
		Section 6.4.1 of \cite{Poskitt13a} shows how morphisms can be replaced and decomposed to satisfy (1) and (2) of normal form. For (3), observe that an M-condition  can be replaced by the equivalent M-condition , where  is defined as follows:\\
		
		\begin{center}\begin{tabular}{r c l}
			 && \vspace{5pt}\\
			
			&& \vspace{5pt}\hspace{0.5in}\\
			
			&& \vspace{5pt}\hspace{0.25in}\\
			
			&& \vspace{5pt}\hspace{0.5in}\\
			
			&& \vspace{5pt}\hspace{0.25in}
		\end{tabular}\end{center}
		
		\noindent i.e.\ path predicates can be expressed in terms of MSO expressions.
			\qed
	\end{proof}
	
	Now, we define and prove the correctness of a translation from M-conditions (in normal form) to formulae. The assumption that morphisms are inclusions allows us to establish a correspondence between identifiers and variables. For example, a node with identifier  will be translated into a variable  from VVar.
	
	\begin{theorem}[M-conditions can be expressed as formulae]\label{thm:Form}\rm
		There is a transformation Form such that for all M-constraints , and all graphs , we have:

		

		\noindent \emph{Construction.} We assume that M-constraint  is in normal form (otherwise replace it with an equivalent M-constraint that is). Define . Here, the second parameter can understood as the set of all node and edge variables that have already been bound to quantifiers by the transformation. Then  is defined inductively as follows, where  denotes a set of sorted variables.

		If , then . If , then  (analogous for edge set quantification). If , then there are three possible outputs for  defined for the three forms that  may take in normal form.

		Suppose that , i.e.\ an M-condition with a morphism that is an identity. Then,  is equal to:\\
		


	\noindent Here (and in the following),  denotes the formula obtained from  by replacing node identifiers  (resp.\ edge identifiers ) with variables  in VVar (resp.\  in EVar), and by replacing  respectively with .



		Suppose that , where  denotes a morphism with codomain  equal to domain , except for an additional node  labelled with . Then,  is equal to:

		\begin{center}
		\begin{tabular}{l}
			\vspace{5pt}
		\end{tabular}
		\end{center}

		Suppose that , where  denotes a morphism with codomain  equal to domain , except for an additional edge  with label , source node , and target node . Then,  is equal to:

		\begin{center}
		\begin{tabular}{l}
			\vspace{5pt}\\
			
			\vspace{5pt}\hspace{0.5in}
		\end{tabular}
		\end{center}


	\noindent Note that this exploits the correspondence between node identifiers and node variables established in the previous case.

	For Boolean formulae over M-conditions, the transformation  is defined in the standard way, that is, , , and .

	\qed
	\end{theorem}
	
	To prove the theorem, we first prove a more general lemma about the translation of M-conditions.
	
	\begin{lemma}[M-conditions can be expressed as formulae]\label{lemma:Form}\rm
		For every M-condition  in normal form, injective graph morphism , and interpretation  in  (defined for the free variables of ), we have:
		
		
		\noindent where  is the set of node and edge variables corresponding to the identifiers in . Furthermore,  is defined as  but with the following mappings for free variables in : (1) for each set variable  in the domain of , ; (2) for each node  in , ; and (3) for each edge  in , .
		\qed
	\end{lemma}
	
	\begin{proof}
		Cases  and  are clear from the definition of , the construction, and induction hypothesis. All other cases are easily adapted from the proof of Lemma 6.33 in \cite{Poskitt13a}.
		\qed
	\end{proof}
	
	
	\begin{proof}[of Theorem \ref{thm:Form}]
		Define . We have that:
		
		\begin{center}\begin{tabular}{r c l}
			 &&  \\
			&&  \\
			&&  \\
			&& .
		\end{tabular}\end{center}
		
		\noindent from the definition of  for M-conditions and formulae, and Lemma \ref{lemma:Form}.
		\qed
	\end{proof}
	
	\subsection{Proof of Theorem \ref{thm:formulae_equiv}}\label{thm:formulae_equiv:PROOF}
	
	\begin{proof}
		We obtain the result directly from Theorems \ref{thm:Cond} and \ref{thm:Form}.
		\qed
	\end{proof}












	\newpage\section{Semantics of Graph Programs}\label{app:semantics}
	
	This appendix contains an operational semantics -- in the style of GP 2 \cite{Plump12a} -- for the graph programs defined in this paper. The semantics consists of inference rules, which inductively define a small-step transition relation  on \emph{configurations}. Intuitively, configurations represent the current state (a graph or special failure state) paired with a program that remains to be executed.

	\begin{definition}[Configuration]\rm
		Let  denote the class of all graph programs and  the set of all graphs over . A \emph{program configuration} is either a program with a graph in , just a graph in , or the special element fail.	
		\qed
	\end{definition}

	\begin{definition}[Transition relation]\rm
	    A \emph{small-step transition relation}
	
	\noindent over configurations defines the individual steps of computation. The transitive and reflexive-transitive closures of  are written  and  respectively.
		\qed
	\end{definition}

	Configurations in  represent states of unfinished computations, whereas graphs in  are proper results. The configuration fail represents a failure state. A configuration  is said to be \emph{terminal} if there is no configuration  such that .

	We provide semantic inference rules for the commands of programs. Each inference rule has a premise and conclusion, separated by a horizontal bar. Both contain (implicitly) universally quantified meta-variables for programs and graphs, where  stands for a rule set call,  for programs in , and  for graphs in .

	\begin{definition}[Semantic inference rules for core commands]\label{def:core_sos_rules}\rm
		The \emph{inference rules for core commands} of programs are given in Figure \ref{fig:core_sos_rules}. The notation  expresses that for a graph , there is no graph  such that .

	\begin{figure}[htb]
	\centering
	\begin{tabular}{lcl}
	  
	&&
	 
	\\\\
	  
	&&
	 
	\\\\
	 
	\\\\
	\multicolumn{3}{c}{ }
	\\\\
	\multicolumn{3}{c}{ }
	\\\\
	\multicolumn{3}{c}{ }
	\\\\
	\multicolumn{3}{c}{ }
	\\\\
	 
	&&
	 
	\end{tabular} 
	\caption{Inference rules for core commands}\label{fig:core_sos_rules}
	\end{figure}
		\qed
	\end{definition}

	To convey an intuition as to how the rules should be read, consider the rule [call]. This reads: ``for all sets of rules  and all graphs ,  implies that ''.


	By inspection of the inference rules, we note that a program execution can only result in a failure state if a set of rules is applied to a graph for which no rule in the set is applicable.

	The meaning of programs is given by the semantic function , which assigns to each program  the function  mapping an input graph  to the set of all possible results of executing  on . The application of function  to graph  is denoted . As well as graphs, this set may contain the special values fail and . The former indicates a program run ending in failure, whereas  indicates that at least one execution diverges (does not terminate), or ``gets stuck''.

	\begin{definition}[Divergence]\rm
		A program  \emph{can diverge from} graph  if there is an infinite sequence:
		
		\qed
	\end{definition}

	\begin{definition}[Getting stuck]\rm
		A program  \emph{can get stuck from} graph  if there is a terminal configuration  such that .
		\qed
	\end{definition}

	A program can get stuck if the guard program  of a conditional can diverge on some graph , neither producing a graph nor failing, or if the same property is true for a program that is iterated. The execution in these cases gets stuck because none of the inference rules for conditionals and iteration can be applied.


	\begin{definition}[Semantic function]\label{def:semantic_function}\rm
	The \emph{semantic function} , given a graph  and a program , is defined by:


	
	\noindent	\qed
	\end{definition}

	Finally, we provide a straightforward definition of program equivalence which is based on the definition of semantic functions.

	\begin{definition}[Semantic equivalence]\rm
		Two graph programs  and  are \emph{semantically equivalent}, denoted by , if .
		\qed
	\end{definition}
	
	
	











	
	
	\newpage\section{Weakest Liberal Precondition Constructions}
	
	\subsection{Proof of Lemma \ref{lemma:shifting}}\label{lemma:shifting:PROOF}
	
	\begin{proof}
		By structural induction.\\

		\noindent \emph{Basis.} Let . Then . All morphisms satisfy true.\\

		\noindent \emph{Step. Only if.} Let . Assume that:
		
		
		\noindent Then there exists an interpretation  for some  such that . By induction hypothesis, we have . By definition of , we get the result that . Analogous for case .

		Let . Assume that:
		
		
		\noindent i.e.\ there exists an  such that . By the definition of , there exists a morphism  with , , and . Directly from the proof of Lemma 3 in \cite{Habel-Pennemann09a}, we get . Using the induction hypothesis,  implies . Define  as . With the definition of , we have . Finally, with the assumption that , that  is defined only for nodes and edges in , and that , we have that . Together, we have the result that .\\

		\noindent \emph{Step. If.} Let . Assume that . Then there exists an interpretation  for some  such that . By induction hypothesis, we have that . By definition of  and the construction of , we get the result that . Analogous for case .

		Let . As for the ``only if'' direction, one can derive  directly from the proof of Lemma 3 in \cite{Habel-Pennemann09a}, with the additional requirement that  for the satisfying morphisms  and  (simple to show, because  is defined only over items in , and the proof in \cite{Habel-Pennemann09a} shows that ).\\

		For Boolean formulae over M-conditions, the statement follows from the definition of  and the induction hypothesis.
		\qed
	\end{proof}
	
	
	
	
	
	
	\newpage\subsection{Proof of Proposition \ref{prop:LPath}}\label{prop:LPath:PROOF}
	
	\begin{proof}
		Let  with  denoting some nodes in , and  a set of edges in . Furthermore, given some morphism , let  abbreviate the set . We show that the equality holds for all contexts of  and all types of rules  (in the sense of what the rules create and/or delete).\\
		
		\noindent\emph{Case (1).} Suppose that  and . Then  returns the predicate . By the definition of interpretations, the equality holds if . If such a path exists in  then the same path exists in  (and vice versa), since the rule does not create or delete edges, and since any nodes created or deleted would not be part of such paths (by the dangling condition).\\
		
		\noindent\emph{Case (2).} Suppose that  and . Then  returns the predicate . By the definition of interpretations, the equality holds if . The argument is similar to that of the previous case, noting that edges  deletes are included in  and hence are never part of such a path in .\\
		
		\noindent\emph{Case (3).} Suppose that  and . Then  returns:
		
		
		\noindent For paths along edges , the argument is as before. For paths including edges , the equality then holds if:
		
		
		\noindent By construction,  expands to a disjunction of:
		\begin{center}
			\begin{tabular}{c}
				\\
				
			\end{tabular}
		\end{center}

		\noindent over all non-empty sequences of distinct pairs  drawn from:
		
		
		\noindent Assume that one such disjunct is satisfied in . Then there are paths from  to , \dots  to , \dots and  to  (all excluding edges in ). These paths also exist in , since each  pair is in the interface of , since  does not delete edges, and since any nodes deleted would not have been part of the paths in  (to satisfy the dangling condition, all incident edges must also be deleted, which would lead to a contradiction). Furthermore, each endpoint  of these paths is connected to the beginning of the next one  (since , and each element of the path is injectively mapped to ). Together, we have a witness for .
		
		Assume now that  holds by some path consisting of edges  in sequence, with , and . Let this path be denoted by the pair . Assume that at least one of its edges is in , i.e.\ is created by . The path contains path segments  in , denoted by , such that if there is an edge  (resp.\ ) in , that edge is in the set . Since nodes created by  can only be incident to edges in  (by the dangling condition), there exists in  the same sequence of edges  but with ``gaps'' for all such path segments . Each pair of nodes  corresponds to a pair  such that  and . The construction returns a disjunct:		
		
		
		\noindent for all such pairs , since paths between them are created by  (that is,  holds and  does not). As the disjunct evaluates to true under  and , so does .\\
		
		
		\noindent\emph{Case (4).} Suppose that  and , i.e.\ including the previous cases but also rules that both delete and create edges. Here,  returns:
		
		
		\noindent with  expanding as before but with  replacing . The argument is as in the previous case, but noting that edges  deletes are included in , and hence are not considered in  (nor in any corresponding path segments in ).\\
		
		\noindent\emph{Case (5).} Now, suppose that , , and  (the rule must create at least one edge from from  in ). Then  returns the constraint:
		
		\begin{center}\begin{tabular}{c}
			\\
		 
		\end{tabular}\end{center}
		
		\noindent for each  such that , and the equality holds if: 
		
		\noindent Assume that . Suppose that . Then from the construction, there exists some  with  such that . By induction we get . From the assumption  and the definition of morphisms we derive that , and hence the result that . Suppose  instead, i.e. 
		
		
		\noindent for some  such that . Let . Then:
		
		
		\noindent By induction, we have that . As before we derive that , and hence the result that .
		

	
		Assume that . There is a node  such that  and . (Suppose there is no such node. Then every node reachable from the image of  in  will also have been created by the rule, and in particular, none of these nodes will be the image of  since . A contradiction.) Let . By induction, we have that:
		
		
		\noindent If the first disjunct evaluates to true, then so does  since the construction yields a disjunct  where . If the second disjunct evaluates to true, i.e.\
		
		
		\noindent then so does  since the above is yielded by the construction, i.e.
		
		
		
		\noindent \emph{Case (6).} Suppose that , and . Analogous to Case (5). \\
		
		\noindent \emph{Case (7).} Finally, suppose that  and . There are two subcases: (A) there are nodes in  which are reachable from  in ; and (B) there are no such nodes in . For the former subcase, the proof is along the lines of Cases (5)-(6). For the latter subcase, a path can only exist in  if there is a path from  to  in . If there is, the construction returns the disjunct ; otherwise . The equality clearly holds.
		\qed
	\end{proof}
	
	
	
	
	
	
	
	
	
	
	
	
	
	\newpage
	\subsection{Proof of Lemma \ref{lemma:L}}\label{lemma:L:PROOF}
	
	\begin{proof}
		By structural induction. Note that the construction distinguishes two cases in the step, according to whether a pushout complement exists or not. We will consider the case that one does; the other proceeds analogously to the proof of Theorem 6 in \cite{Habel-Pennemann09a}.\\
		
		\noindent\emph{Basis.} Let . Then . All morphisms satisfy true.\\
		
		\noindent\emph{Step. Only if.} Let . By assumption,
		
		
		\noindent There exists an  such that . By the definition of , there exists some  such that   and . By induction, we get that . Observe that: 
		
		
		\noindent By definition of , we get the result that . (Analogous for case .)
		
		Now let . By assumption,
		
		
		\noindent i.e.\ there is a morphism  such that , , and . Following the proof of Theorem 6 in \cite{Habel-Pennemann09a}, we derive a morphism  with , i.e.\ . Consider now the construction of  from . Each MSO expression  for  is replaced in  by  (resp.\ ) if  (resp.\ ) for some . Observe that each  evaluates to the same Boolean value as the corresponding replacement ( or ) in  under . Moreover, each path predicate  in  is replaced with . By Proposition \ref{prop:LPath},
		
		
		\noindent Together, we have  and . From the induction hypothesis,  implies . With this, we get the result that .\\
		



		
		\noindent\emph{Step. If.} Let . By assumption, . By the definition of , there exists some  such that . Define:
		
		
		\noindent and . Now define:
		
		
		\noindent and hence:
		
		
		\noindent Observe that . By induction hypothesis, we get . Clearly,  is in  from the construction, hence:
		
		
		\noindent By the definition of , we get the result that:
		
		
		
		\noindent (Analogous for case .)
		
		Now let . By assumption, , i.e.\ there is a morphism  with , , and . Following the proof of Theorem 6 in \cite{Habel-Pennemann09a}, we derive a morphism  with , i.e.\ . Consider now the construction of  from . Each MSO expression  for  is replaced in  by  (resp.\ ) if  (resp.\ ) for some . Observe that each  evaluates to the same Boolean value as the corresponding replacement ( or ) in  under . Moreover, each path predicate  in  is replaced with . By Proposition \ref{prop:LPath},
		
		
		\noindent Together, we have  and . From the induction hypothesis,  implies . Finally, we get the result that:
		
		
	
		For Boolean formulae over M-conditions, the statement follows from the definition of  and the induction hypothesis.
		\qed
	\end{proof}
	
	
	
\end{document}
