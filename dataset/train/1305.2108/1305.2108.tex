
\begin{abstract}
We consider the {\ks}problem under the advice model of computation when the underlying metric space is sparse. On one side, we show that an advice of size  is required to obtain a -competitive algorithm for sequences of size , even for the 2-server problem on a path metric of size . Through another lower bound argument, we show that at least  bits of advice is required to obtain an optimal solution\footnote{We use  to denote .} for metric spaces of treewidth , where . On the other side, we introduce -competitive algorithms for a wide range of sparse graphs, which require advice of (almost) linear size. Namely, we show that for graphs of size  and treewidth , there is an online algorithm which receives  bits of advice and optimally serves a sequence of length . With a different argument, we show that if a graph admits a system of  collective tree -
spanners, then there is a -competitive algorithm which receives  bits of advice. Among other results, this gives a -competitive algorithm for planar graphs, provided with  bits of advice. 
\end{abstract}



\section{Introduction}\label{secIntro}
Online algorithms have been extensively studied in the last few decades. In the standard setting, the input to an online algorithm is a sequence of \textit{requests}, which should be \textit{answered} sequentially. To answer each request, the algorithm has to take an irreversible decision without looking at the incoming requests. For minimization problems, such a decision involves a \textit{cost} and the goal is to minimize the total cost. 

The standard method for analysis of online algorithms is the \textit{competitive analysis}, which compares an online algorithm with an optimal offline algorithm, \OPT. The competitive ratio of an online algorithm\footnote{In this paper we only consider deterministic algorithms.} \ALG is defined as the maximum ratio between the cost of \ALG for serving a sequence and the cost of \OPT for serving the same sequence, within an additive constant factor. 

Although the {\ca} is accepted as the main tool for analysis of online algorithms, its limitations have been known since its introduction; the prime critique being that it is not a good predictor of commonly observed behaviour.
{\Ca}' limitations go to the very heart of the technique itself. Inputs adversarially produced to draw out the worst performance of a particular algorithm are not commonplace in real life applications. Therefore, in essence {\ca} mostly measures the benefit of knowing the future, and not the true difficulty of instances. From the perspective of an online algorithm, the algorithm is overcharged for its complete lack of knowledge about the future.
Advice complexity quantifies this {\it gap in information} that gives \OPT an unassailable advantage over any online strategy. 

Under the advice model for online algorithms \cite{Emek2011,Bock11}, the input sequence  is accompanied by  bits of advice recorded on an advice tape . For answering the request , the algorithm takes an irreversible decision which is a function of  and the advice provided on .  The advice complexity of an online problem is the minimum number of bits which is required to optimally solve any instance of the problem.  In the context of the communication complexity, it is desirable to provide an advice of small size, while achieving high quality solutions. 

We are interested in the advice complexity of the -{\sc Server} problem, as well as the relationship between the size of advice and the competitive ratio of online algorithms. 
To this end, we study the problem for a wide variety of sparse graphs. 

\subsection{Preliminaries}
An instance of the \kc problem includes a metric space ,  mobile servers, and a request 
sequence . The metric space can be modelled as an undirected, weighted graph of size  (we interchangeably use terms `metric space' and `graph'). Each request 
in the input sequence  denotes a vertex of , and an online algorithm should move one of the servers to the requested vertex to 
\textit{serve} the request. The cost of the algorithm is defined as the total distance moved by all  servers over . 

For any graph , a tree decomposition of  with width  is a pair  where  is a family of subsets of  (bags), and  is a rooted tree whose nodes are the subsets  such that
\begin{itemize}
	\item  and  
	\item for all edges , there exists an  with  and . 
	\item for all : if  is on the path from  to  in , then .
\end{itemize}

The treewidth of a graph  is the minimum width among all tree decompositions of . 
Informally speaking, the tree decomposition is a mapping a graph to a tree so that the vertices associated to each node (bag) of the tree are close to each other, and the treewidth measures how close the graph is to such tree. 

We say that a graph  admits a system of  collective tree -spanners if there is a set  of at most  spanning trees of  such that for any two vertices ,  of , there exists a spanning tree  such that .

For the ease of notation, we assume  denotes the number of servers, , the size of metric space (graph), , the length of input sequence, and , the treewidth of the metric space. 

\subsection{Existing Results}

The advice model for the analysis of the online algorithm was first proposed in \cite{Emek2011}. Under that model, each request is accompanied by an advice of fixed length. A slight variation of the model was proposed in \cite{ISSAC09,Bock11}, which assumes that the online algorithm has access to an advice tape. At any time step, the algorithm may refer to the tape and read any number of advice bits. 
The advice-on-tape model has an advantage that enables algorithms to use sublinear advice (an advantage over the original model). This model has been used to analyze the advice complexity of many online problems, which includes paging~\cite{ISSAC09,MFCS10,SOFSEM11}, 
disjoint path allocation~\cite{ISSAC09}, job shop scheduling~\cite{ISSAC09,SOFSEM11}, -server~\cite{Bock11}, knapsack~\cite{LATIN12}, bipartite graph coloring \cite{COCOON12}, online coloring of paths~\cite{LATA12}, 
set cover~\cite{CSR12,ECCC12}, maximum clique~\cite{ECCC12}, and graph exploration~\cite{SIROCCO12}. In this paper, we adopt this definition of the advice model.

For the \kc problem on general metrics, there is an algorithm which achieves a competitive ratio of  for , when provided with  bits of advice \cite{Emek2011}. This ratio was later improved to  in \cite{Bock11}, and then to  in \cite{WAOA11}. Comparing these results with the lower bound  for the competitive ratio of any online algorithm \cite{Mana88}, one can see how an advice of linear size can dramatically improve the competitive ratio. 

Since the introduction of the \kc problem, there has been an interest in studying the problem under specific metric spaces. These metric spaces include trees \cite{Chrob91}, metric spaces with  points \cite{Bart00}, Manhattan space \cite{Bein02}, the Euclidean space \cite{Bein02}, and the cross polytope space (a generalization of a uniform space) \cite{Bein07}. For trees, it is known that the competitive ratio of any online algorithm is at least , while there are online algorithms which achieve this ratio \cite{Chrob91}. Under the advice model, the \kc problem has been studied when the metric space is the Euclidean plane, and an algorithm with constant competitive ratio is presented, which receives  bits of advice for sequences of length  \cite{Bock11}. In \cite{WAOA11}, tree metric spaces are considered and a -competitive algorithm is introduced which receives  bits of advice, where  is the \textit{caterpillar dimension} of the tree. There are trees for which  is as large as . Thus, the -competitive algorithm of \cite{WAOA11} needs roughly  bits of advice. Also in \cite{WAOA11}, it is proved that  bits of advice are sufficient to obtain an optimal algorithm for paths.

\subsection{Contribution}
Our first result implies that a sublinear advice does not suffice to provide close-to-optimal solution, even if we restrict the problem to 2-server problem on paths of size . Precisely, we show that  bits of advice are required to obtain a -competitive algorithm for any value of  ( is an arbitrary small constant). Since there is a 1-competitive algorithm which receives  bits of advice for paths \cite{WAOA11}, we conclude that  bits of advice are necessary and sufficient to obtain a 1-competitive algorithm for these metrics.
Through another lower bound argument, we show that any online algorithm requires an advice of size at least  bits to be optimal on a metric of treewidth , where .

On the positive side, we introduce an online algorithm which optimally serves any input sequence, when provided  bits of advice. For graphs with constant treewidth, the advice size is almost linear. Considering that an advice of linear size is required for 1-competitive algorithms (our first lower bound), the algorithm has an advice of nearly optimal size.
For graphs with treewidth 
the advice size is , which is asymptotically tight when , because at least  bits are required to be optimal in this case (our second lower bound). 

We provide another algorithm that achieves a competitive ratio of at most , when the metric space admits a system of  collective tree -spanners. This 
algorithm receives  bits of advice. This yields competitive algorithms for a large family of graphs, e.g., a 3-competitive algorithm for planar graphs, which reads  bits of advice.



\section{Lower Bounds}

\subsection{2-server Problem on Path Metric Spaces}
In this section, we show that an advice of sublinear size does not suffice to achieve close-to-optimal solutions, even for the 2-server problem on a path metric space of size . 
Without loss of generality, we only consider online algorithms which are \textit{lazy} in the sense that they move only one server at the time of serving a request. 
It is not hard to see that any online algorithm can be converted to a lazy algorithm without an increase in its cost. Hence, a lower bound for the performance of lazy algorithms applies to all online algorithms. In the reminder of this section, the term {\it online algorithm} means a lazy algorithm.

Consider a path of size  which is horizontally aligned and the vertices are indexed from  to . Assume that the servers are initially positioned at vertices  and . We build a set of instances of the problem, so that each instance is formed by  \textit{round}s of requests. Each round is defined by requests to vertices , where the second request of a round can be either to vertex  or vertex . Each round ends with consecutive requests to vertices 2 and 4. So, it is reasonable to move servers to these vertices for serving the last requests of each round. This intuition is formalized in the following lemma.

\begin{lemma}
Consider an algorithm  that serves an instance of the problem as defined above. There is another algorithm  with a cost which is not more than that of , for which the servers are positioned at vertices  and  before starting to serve each round.
\end{lemma}

\begin{proof}
Consider the first round  such that  does not have a server positioned at vertex  before serving the requests in  (since the last request of the previous round has been to vertex , there is necessarily  a vertex located at vertex 4). This implies that the last four requests of the previous round  (to vertices ) are served by the same server . So,  pays a cost of at least 6 for serving these requests. Consider an algorithm , which moves the same servers as  does for serving all requests before the last four requests of . To serve the last four requests of ,  moves the servers to vertices  and . This requires a cost of at most  (The worst case happens when the servers are positioned at 4 and 5 before the first request to 2; in this case the algorithm pays a cost of 2 to move the left server to position 2 and a cost of 1 to move the right server to position 4 on the next request). Hence,  pays a cost of at most three for the last four requests in  and, when compared to , saves a cost of at least 3 units in round . At the beginning of round , the servers of  are positioned at  and  (), and the servers of  are at  and . 
In future rounds,  moves the server positioned at 2 (resp. 4) in the same way that  moves the server position at  (resp. 4). The total cost would be the same for both algorithms, except that the cost for the first request which is served by the server positioned at  in  might be at most 3 units more when served by the server positioned at vertex 2 in . This is because the distance from vertex  to any other vertex is at most .  

To summarize, when compared to ,  saves a cost of at least  units on the requests in the  and pays an extra cost of at most  for the rounds after . Hence, the cost of  is not more than that of . To prove the lemma, it suffices apply the above procedure on all rounds for which there is no server at position 2 at the beginning of the round. The result would be an algorithm which has servers located at positions 2 and 4 before the start of any round. \qed
\end{proof}

According to the above lemma, to provide a lower bound on the performance of online algorithms, we can consider only those algorithms which keep servers at positions  and  before each round.
For any input sequence, we say a round  has type 0 if the round is formed by requests to vertices  and has type  otherwise, i.e., when it is formed by requests to vertices .
The first request of a round is to vertex . Assume the second request is to vertex , i.e., the round has type 1. An algorithm can move the left vertex  positioned at  to serve the first request (to vertex 3) and the right server  positioned at 4 to serve the second request (to vertex 5). For serving other requests of the round, the algorithm can move the servers to their initial positions, and pay a total cost of 4 for the round (see Figure \ref{fig:rightGuess}). Note that this is the minimum cost that an algorithm can pay for a round. This is because there are four requests to distinct vertices and the last two are request to the initial positions of the servers (i.e., vertices 2 and 4).

Now assume that the algorithm moves the right vertex  to serve the first request (to vertex 3). The algorithm has to serve the second request (to vertex 5) also with . The third request (to vertex 3) can be served by any of the servers. Regardless, the cost of the algorithm will not be less than 6 for the round (see Figure \ref{fig:wrongGuess}). 
With a symmetric argument, in case the second request is to vertex  (i.e., the round has type 0), if an algorithm moves the right server to serve the first request it can pay a total cost of 4, and if it moves the left server for the first request, it pays a cost of at least 6 for the round. 

In other words, an algorithm should `guess' the type of a round at the time of serving the first request of the round. In case it makes a right guess, it can pay a total cost of 4 for that round, and if it makes a wrong guess, it pays a cost of at least 6. This relates the problem to the \textit{Binary String Guessing Problem}. 

\begin{figure}[!t]
\centering
 \subfigure[In case of a right guess for the type of a round, the algorithm can pay a cost of 4.]{\includegraphics[width=0.4\columnwidth]{2}\label{fig:rightGuess}}
\hspace{.095\columnwidth}
 \subfigure[In case of a wrong guess for the type of a round, the algorithm pays a cost of at least 6.]{\includegraphics[width=0.4\columnwidth]{3}\label{fig:wrongGuess}}
\caption{The cost of an algorithm for a round of type 1, i.e., request to vertices . The servers are initially located at 2 and 4.}
\label{packs}\end{figure}


\begin{definition}[\cite{Emek2011,ECCC12}]
The {\em Binary String Guessing Problem with known history (-SGKH)} is the following online problem. The input is a bitstring of size , and the bits are revealed one by one. For each bit , the online algorithm \alg must guess if it is a  or a . After the algorithm has made a guess, the value of  is revealed to the algorithm.
\end{definition}

\begin{lemma}[\cite{ECCC12}] \label{servi}
On an input of length , any deterministic algorithm for -SGKH that is guaranteed to guess correctly on more than  bits, for , 
needs to read at least  bits of advice.
\end{lemma}

We reduce the -SGKH problem to the -server problem on paths. 
\begin{lemma}\label{redu1}
If there is a 2-server algorithm with cost at most  () for an instance of length  (as defined earlier), then 
there is a 2-SKGH algorithm which guesses at least  bits correctly for any input bit string of size .
\end{lemma}

\begin{proof}
Let  denote a bit string of length , which is the input for the 2-SKGH problem. Consider the instance of the -server problem in which the types of rounds are defined by . Precisely, the 'th round has type 0 if the 'th bit of  is 0, and has type 1 otherwise. We run the -server algorithm on such an instance. At the time of serving the first request of the 'th round, the -server algorithm guesses the type of round  by moving the left or right server. In particular, it guesses the type of the round to be 0 if it moves the right server for the first request, and 1, otherwise. Define a -SGKH algorithm which performs according to the 2-server algorithm, i.e., it guesses the 'th bit of  as being 0 (resp. 1) if the 2-server algorithm guesses the 'th round as having type 0 (resp. 1). As mentioned earlier, the -server algorithm pays a cost of 4 for the round for each right guess, and pays cost of at least 6 for each wrong guess. So, the cost of the algorithm is at least , in which  is the number of correct guesses (). Consequently, if an algorithm has cost at most equal to this value, it correctly guesses the types of at least  rounds, i.e., it correctly guesses at least  bits of a bit string of length . Defining  as  completes the proof. \qed
\end{proof}

Lemmas \ref{servi} and \ref{redu1} give the following theorem.

\begin{theorem} \label{lowerMain}
On input of length , any deterministic algorithm for the -server problem which has a competitive ratio smaller than  (), needs to read at least  bits of advice, even if the metric space is restricted to being a path of size . 
\end{theorem}

\begin{proof}
There is an offline 2-server algorithm which pays a cost of 4 for each round and consequently pays a total cost of . Hence, in order to have a competitive ratio of , the cost of an algorithm should be at most . According to Lemma \ref{redu1}, this requires the existence of a 2-SKGH algorithm which correctly guesses at least  bits of a bit string of length . By Lemma \ref{servi}, this needs reading at least  bits of advice. Note that  is in the range required by the lemma when . \qed
\end{proof}


For a competitive ratio of , the formula in Theorem \ref{lowerMain} takes the value 0 and thus does not provide a non-trivial bound. However, for doing strictly better than 5/4, a linear number of bits of advice is required. For example, to achieve a competitive ratio of , at least  bits of advice are needed, and for the improved ratio of , at least  bits of advice are needed. To achieve a -competitive algorithm,  bits of advice are required.

\subsection{Metrics with Small Treewidth}
We show that there are instances of the \ks problem in a metric space with treewidth , for which any online algorithm requires at least  bits of advice to perform optimally. Our construction is based on the one described in \cite{Bock11}, where a lower bound for a general metric space is provided. 

We introduce \textit{units graphs} and \textit{module graphs} as follows. A -unit graph is a bipartite graph  where  contains  vertices, and  contains  vertices each representing a proper subset of . There is an edge between two vertices  and  iff , where  denotes the set associated with a vertex . 
Let  denote the set of vertices of  whose associate sets have size . i.e., for  we have . A \textit{valid request sequence} is defined as  so that for each ,  and . In other words, a valid sequence starts with a request to the vertex associated with the empty set, and with each step one element is added to get a larger set defining the next request. With this definition, one can associate every input sequence  with a unique permutation  of set .

A -module graph  includes two -unit graphs  and . In such a graph, those vertices in  which represent sets of size  are connected to the 'th vertex of ; the vertices of  and  are connected in the same manner (see Figure \ref{fig:module}). Consider an instance of the \ks problem defined on a -module graph, where initially all servers are located at the vertices of . A valid sequence for the module graph is defined by repetition of \textit{rounds of requests}. Each round starts with a valid sequence for  denoted by , followed by  requests to distinct vertices of , a valid sequence for , and  requests to distinct vertices of . It can be verified that there is a unique optimal solution for serving any valid sequence on , and consequently a separate advice string is required for each sequence \cite{Bock11}. Since there are  valid sequences of length , 
at least  bits of advice are required to separate all valid sequences. 

The following lemma implies that the treewidth of the graphs used in the above construction is at most . 

\begin{figure}[t] 
\begin{minipage}{0.6 \linewidth}
\centering
\includegraphics[scale=0.4]{module}
\label{fig:module1}
\end{minipage}
\hspace{.2cm}
\begin{minipage}{0.4\linewidth}
\centering
\includegraphics[scale=0.4]{moduleDecom}
\label{fig:module2}
\end{minipage}
\caption{A -module graph and a tree decomposition of it with treewidth .  and  are the unit graphs involved in construction of the module graph. \label{fig:module}}
\end{figure}


\begin{lemma} \label{mytd}
 Any -module graph has a tree decomposition of width .
\end{lemma}

\begin{proof}
Let  and  be the unit graphs which define the -module graph. 
Define a tree decomposition as follows. Consider  bags so that each bag contains all vertices from  and  , and exactly one vertex from  or . Any tree which spans all these  bags is a valid tree decomposition (See Figure \ref{fig:module}). Moreover, there are exactly  vertices in each bag which completes the proof.
\qed 
\end{proof}

For metrics with treewidth , the lower bound of  is tight, as  bits of advice are sufficient to serve each sequence optimally (by simply indicating the server that \opt would move to serve each request). In what follows, we consider metric spaces with treewidth  such that . Assume that  is an even integer and we have  for some positive integer . 
Consider a metric space  defined by a set of -modules where . There are  such modules in . Let  denote these modules, and let  denote the unit graphs involved in the construction of  (). For each module , select exactly one vertex from , and connect all of the selected vertices to a common \textit{source}. This makes  a connected graph (see Figure \ref{fig:GB}).

\begin{figure}[t]
\begin{minipage}{0.5 \linewidth}
\centering
\includegraphics[width=0.8\columnwidth]{GB}
\label{fig:figure1}
\end{minipage}
\begin{minipage}{0.5\linewidth}
\centering
\includegraphics[width=0.8\columnwidth]{GBTree}
\label{fig:figure2}
\end{minipage}
\caption{The metric space  and a tree decomposition associated with it. The source  is connected to the selected vertex  of module . \label{fig:GB}}
\end{figure}

\begin{lemma} \label{lemunlab}
The metric space  has a tree decomposition of width .
\end{lemma}

\begin{proof}
By Lemma \ref{mytd}, each module has a tree decomposition of width . Let  denote the tree associated with the decomposition of the th module. For any tree , consider a bag  of 
size 2 which contains the source  and the other endpoint of the edge between  and . Connect  to an arbitrary bag of . Add  arbitrary edges between all s to form a connected tree. Such a tree represents a valid tree decomposition of  with width  \mbox{(see Figure \ref{fig:GB}).} \qed
\end{proof}


Since there are  modules and in the 'th module  contains  vertices, there are  vertices in all of the s. Assume that the  servers are initially placed at separate nodes in the s. A valid sequence for  is defined by a sequence of rounds of requests in which each round has the following structure: \\

\footnotesize{\hspace{-.45cm}
}\\
\normalsize

Here,  is a function that combines the requests from  permutations. Let  denote  permutations such that  
contains  requests  which defines a permutation in the module . Thus,  gives a sequence of length  starting with  requests to s, followed 
by  requests to s, and so on. For each , () we have fixed orderings on the vertices such that  and . With this definition, when a valid sequence of  is projected to the requests arising in a module , the resulting subsequence is a valid sequence for . 

\begin{lemma} \label{khast}
There is a unique optimal solution to serve a valid sequence on the metric space . Also, each valid sequence requires a distinct advice string in order to be served optimally.
\end{lemma} 

\begin{proof}
 We present an algorithm \sol and show that its solution is the unique optimal solution for serving any valid sequence. To serve a request in  (resp. ), \sol moves a server from  (resp. ) to act according to the corresponding permutation  (resp. ). To be precise, to serve a request  (for ) it moves the server positioned at , and thus leaving a unique choice for the last request . To serve a request  in  (resp. ), \sol moves the single server which is located at an adjacent node in  (resp. ). Therefore, \sol incurs a cost of one for each request. 

There are  servers initially located in each  module, and \sol never moves a server from one module to another (no server passes the common source). To show that the solution of \sol is the unique optimal for serving any valid sequence, it is sufficient to show the following conditions: 

\begin{itemize}
\item No optimal algorithm moves a server from one module to another. 
\item Among all algorithms which do not move a server between modules, \sol provides the unique optimal solution.
\end{itemize}

Assume that there is an optimal algorithm \A which moves a server from one module to another. So at some point after serving the 'th request, there is a -module  which has  servers stationed on it, for some . We show that the cost incurred by \A for serving the requests of  in each round after the 'th request is lower bounded by . Note that \sol incurs a total cost of  in each round for the requests of any module. Assume that the cost incurred by  \A for serving a round in  is strictly less than . This implies that strictly more than  requests incur no cost in that round. Since the same vertex is not requested twice in the same round, more than  servers must not be moved in that round. So there is at least one server  which is moved by \sol and not by \A. We show that moving  in the same way as \sol does decreases the cost for \A. Assume that \A keeps  at some vertex in  of . Thus, \sol moves  from  to serve a request in , and then moves it to serve some request in , followed by a move to serve a request in , and finally a move to serve a request in . Each of these moves cost one for \sol. However, each of the involved requests imposes a cost of 2 for \A since it has to use some server to serve at least two requests arising in  in that round, thus, requiring a move via some vertex in  or . The same holds for the requests in ,  and . We can make similar arguments when \A keeps  at some vertex in  or  of , and conclude that \A saves a cost of  by not moving  in a round while incurring a cost of  in the remainder of the round. Hence, \A must incur a cost of at least  for requests arising in .

Let  be a  module in which \A has stationed  servers after serving the 'th request. We show that the cost incurred by \A to serve the requests from  in each round starting after the 'th request is lower bounded by . Similar to the previous argument, since at least one server is missing, for some request(s) arising in , \A has to use server(s) already located in . So instead of incurring a cost of 1 as \sol, \A incurs a cost of 2 for each of those requests (the same holds for requests in ,, and ).

To conclude, if \A moves  servers between modules, compared to \sol, it saves at most   units of cost on the requests arising in the modules which receive extra servers, while it has to pay at least an extra  units for the requests in modules which lose their servers. This is in addition to the cost involved in moving servers from one module to another. We conclude that an optimal algorithm never moves servers between modules -condition 1.  

Inside each module, \sol acts the same as the unique optimal algorithm presented in \cite{Bock11}. Recall that the requests projected to each module form a valid sequence for that module, and can be treated independently (since servers do not move between modules in an optimal scheme). Hence, both conditions 1 and 2 are met, and \sol is the unique optimal for 
serving any valid request in . 

Next, we show that each valid sequence requires a distinct advice string. Assume that two valid sequences  and  differ for the first time at the 'th request. Note that two valid sequences of  can only differ on the requests which define the permutations. Hence,  should be a request belonging to  or  of some module , i.e, one of the permutations representing a valid subsequence for the unit graphs defining . Let  denote the index of the previous request to an item in the same unit graph (that is, the previous request in the same permutation). While serving the request indexed  in the two sequences,  an optimal algorithm will move different servers in anticipation of the 'th request. Hence an online algorithm should receive different advice strings to perform optimally for both sequences. \qed 
\end{proof}

To find a lower bound for the length of the advice string, we count the number of distinct valid sequences for the metric space .
In each round there are  valid sequences for each -module. Since there are  such modules, there are  possibilities for each round. A valid sequence of length  involves  rounds; hence there are  valid sequences of length . Each of these sequences need a distinct advice string. Hence, at least  bits of advice are required to serve a valid sequence optimally. This proves the following theorem.

\begin{theorem}\label{mainLowTreeWidth}
Consider the \ks problem on a metric space of treewidth , such that . At least  bits of advice are required to optimally serve an input sequence of length .
\end{theorem}
\section{Upper Bounds}

\subsection{Graphs with Small Treewidth}
We introduce an algorithm called \textit{Graph-Path-Cover}, denoted by \npc, to show that  bits of advice are sufficient to optimally serve a sequence of length  on any metric space of treewidth . We start with the following essential lemma. 

\begin{lemma} \label{lemmaMMT} Let  be a tree decomposition of a graph . Also, let  and  be two nodes of  and  be the shortest path between  and . Let  and  be two bags in  which respectively contain  and . Any bag on the unique path between  and  in  contains at least one node  ) from .
\end{lemma} 

\begin{proof}
By the definition of the tree decomposition, each vertex  of  is listed in the bags of a contiguous subtree  of . Consider two vertices  and  in . Since  and  are neighbors, there is a bag in  which contains both of them. So the union of the subtrees  and  forms a (connected) subtree of . Similarly, the union of all the subtrees of the nodes  form a (connected) subtree in . Such a subtree contain  and  and hence, any bag on the path between them. So any bag between  and  contain at least one vertex  of .\qed 
\end{proof}

Similar to the \pcv algorithm introduced for trees in \cite{WAOA11}, \npc moves its servers on the same trajectories as \opt moves its. Suppose that \OPT uses a server  to serve the requests  (). So,  is moved on the unique path from its initial position to , and then from  to , and so on. Algorithm \pcv tends to move  on the same path as \opt.

For any node  in , \npc treats one of the bags  which contains  as the \textit{representative bag} of . Moreover, it assumes an ordering of the the nodes in each bag. Each node in  is \textit{addressed} via 
its representative bag, and its index among the nodes of that bag. A server , located at a vertex  of , is addressed via a bag which contains  (not necessarily the representative bag of ) and the index of  in that bag. Note that while there may be a unique way to address a node, there might be several different ways to address a server.

Assume that for serving a request , \opt moves a server  from a node  to  in . Let  and  be respectively the representative bags of  and ,
and  be the least common ancestor of  and  in .  By Lemma \ref{lemmaMMT}, the shortest path between  and  passes at least one node  in ,  and 
that node can be indicated by  bits of advice (  denotes the height of the tree associated with the tree 
decomposition), with  bits indicating  and  bits indicating the index of the said node  in . After serving , \npc moves  to , provided that the address of  is given as part of the advice for . For serving , \npc moves  to , provided that the address of  (address of ) is given as part of the advice for . In what follows, we elaborate this formally.

Before starting to serve an input sequence, \npc moves each server  from its initial position  to a node  on the shortest path between  and the first node  served by  in \opt's scheme. \npc selects  in a way that it will be among the vertices in the least common ancestor of the representative bags of  and  in the tree decomposition (by Lemma \ref{lemmaMMT} such a  exists). To move all servers as described, \npc reads  bits of advice. After these \textit{initial} moves, \npc moves servers on the same trajectories of \opt as argued earlier. 
Assume that ,  and  denote three requests which are consecutively served by  in \opt's scheme. The advice for serving  contains  bits which represents a node ,  which lies on the shortest path between  and  and is situated inside the least common ancestor of the respective bags in . \npc moves  to  after serving . The first part of advice for  contains  bits indicating the node  from which  is moved to serve . The second part of advice for  indicates a node  on the shortest path between  and  in the least common ancestor of their bags in . This way,  bits of advice per request are sufficient to move servers on the same trajectories as \opt. 

The above argument implies that an advice of size   is sufficient to achieve an optimal algorithm. The value of  (the height of the tree decomposition) can be as large as , 
however we can apply the following lemma to obtain height-restricted tree decompositions.

\begin{lemma} \cite{Bodlaender93atourist,ICALP11} \label{lem:depthtc}
Given a tree decomposition with treewidth  for a graph  with  vertices, one can obtain a tree decomposition of  with height  and width at most .
\end{lemma}

If we apply \npc on a height-restricted tree decomposition, we get the following theorem.

\begin{theorem}\label{UpperBoundTreeWidth}
 For any metric space of size  and treewidth , there is an online algorithm which optimally serves any input sequence of size , provided with  bits of advice.
\end{theorem}


\subsection{Graphs with Small Number of Collective Tree Spanners}

In this section we introduce an algorithm which receives an advice of almost linear size and achieves constant competitive ratio for a large family of graphs. 



\begin{theorem}\label{thspan}
If a metric space of size  admits a system of  collective tree -spanners, then there is a deterministic online algorithm which on receiving 
 bits of advice, achieves a competitive ratio of at most  on any sequence of length .
\end{theorem}

\begin{proof} 
When there is only one tree  in the collection (i.e., ), we can apply the \pc algorithm of \cite{WAOA11} on  to obtain the desired result. To be precise, 
for the optimal algorithm \opt, we denote the path taken by it to serve a sequence of requests with the server  to be .



\pc algorithm moves  on the path  in . Since 
 is a spanner of , the total length of  does not exceed that of  by more than a factor of  for each edge in , and consequently the cost of 
the algorithm is at most  times that of {\opt}'s. Thus, the algorithm is -competitive. 

After serving a request  with server , \pc can move  to the least common ancestor of  and , where  is the next request at which \opt uses . This 
requires  bits of advice per request ( being the height of the tree). Instead, the algorithm can use the caterpillar decomposition of  
and move servers on the same set of paths while using only  bits of advice. The main idea is the same, whether we use a rooted tree or the caterpillar decomposition. Here for the ease of explanation, we will only argue for the rooted tree, but the 
statement of the theorem holds when the caterpillar decomposition is used. 

We introduce an algorithm that mimics  \opt's moves for each server,  by picking suitable trees from the collection to move the server through.The advice provided with each request indicates which tree from the collection would best approximate the 
edges traversed by the server in \OPT's scheme to reach the next node at which it is used. To this end, we look at the tree spanners as rooted trees. If \opt moves a server  on the path , then for each edge  on this path, our algorithm moves  on the shortest path of (one of) the tree spanners which best 
approximates the distance between the vertices  and .  As explained below the selection of suitable spanners at every step can be ensured by providing  bits of advice with each request.

Let us denote the initial location of the  servers by , and let  respectively denote the first requested nodes 
served by them. Before starting to serve the sequence, for any server , the algorithm reads  bits of advice to detect the 
tree  that preserves the distance between  and  in , and moves  to the least common ancestor of  and . 
Moreover, the algorithm labels  with index . These labels are used to move the correct servers on the trees in order to cover the same paths as \opt. Let  and 
 be two vertices which are served respectively before and after  with the same server in \opt's scheme. To serve the request to  the algorithm works as 
follows:

\begin{itemize}
	\item Find the spanner  which best approximates the length of the shortest path between  and  in . This can be done if provided with 
	 bits of advice with .
	\item Read  bits of advice to locate a server  labeled as  on the path between node  and the root of . Move  to serve 
	. In case of caterpillar decomposition, the algorithm reads roughly  bits.
	\item After serving , find the spanner  which best approximates the length of the shortest path between  and  in . This can be done if provided with  bits of advice with .
	\item Find the least common ancestor of  and  in . This can be done by adding  bits of advice for , where  is the 
	height of . In case of caterpillar decomposition, this would require roughly  bits.
	\item Move  to the least common ancestor of  and  and label it as .
\end{itemize}

Thus, since \opt moves the server  on the path , our algorithm moves  from  to 
 for each  (), on the path in the tree which approximates the distance between these two vertices within a multiplicative factor 
of . The labels on the servers ensure that the algorithm moves the `correct' servers on the trees. i.e, the ones which were intended to be used. Consequently, the
cost of an algorithm for each server is increased by a multiplicative factor, at most . Therefore, the total cost of the algorithm is at most . 
The size of advice for each request is , assuming that the caterpillar decomposition is used. Adding to that an additional  
 bits for the initial movement of servers completes the proof. \qed
\end{proof}

In recent years, there has been wide interest in providing collective tree spanners for various families of graphs, mostly in the context of message routing in networks. The algorithms which create these spanners run in polynomial time and in some cases linear time. For example, it any planar graph of size  has a system of  collective (3,0)-spanners \cite{pezdisp}; every AT-free graph (including interval, permutation, trapezoid, and co-comparability graphs) admits a system of two (1,2)-spanners \cite{WG04}; every chordal graph admits a system of at most  collective (1,2)-spanners \cite{SWAT04}; and every Unit Disk Graphs admits a system of  collective (3,12)-spanners \cite{DUGSPANNER}. 

\begin{coro}
For metric spaces of size  and sequences of length ,  bits of advice are sufficient to obtain I) a 3-competitive algorithm for planar graphs 
II) a 3-competitive algorithm for AT-free graph (including interval, permutation, trapezoid, and co-comparability graphs)
III) a 3-competitive algorithm for chordal graphs 
IV) a 15-competitive algorithm for Unit Disk Graphs.
\end{coro}

\section*{Concluding Remarks}
For path metric spaces, we showed any 1-competitive algorithm requires an advice of size . This bound is tight as there is an optimal algorithm \cite{WAOA11} which receives  bits of advice.
The same lower bound applies for trees, however, the best algorithm for tree receives an advice of . We conjecture that the lower bound argument can be improved for trees to match it with upper bound, and leave this as future work.

