\documentclass{article}


\usepackage{iclr2021_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 






\usepackage{times}
\usepackage{latexsym}

\usepackage{url}





\usepackage{verbatim}
\usepackage{microtype}
\usepackage{graphicx}
\usepackage{booktabs} 

\usepackage{hyperref}

\newcommand{\theHalgorithm}{\arabic{algorithm}}

\usepackage{amsmath, amssymb, amsfonts, amsthm}
\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{bbm}
\usepackage{graphicx}
\usepackage{color}
\usepackage{bm}
\usepackage{float}
\usepackage{graphicx}
\usepackage{mathabx}
\usepackage{multirow}
\usepackage{setspace}


\usepackage{booktabs}
\usepackage{nicefrac}       \usepackage{microtype}      \usepackage{graphicx} \usepackage{subfig}
\usepackage{adjustbox}  
\usepackage{wrapfig,lipsum,booktabs}
\usepackage{tikz}
\usetikzlibrary{arrows,shapes,automata,backgrounds,petri}
\usepackage{multirow}\usepackage{hhline}



\usepackage{wrapfig}
\usepackage{makecell}
\usepackage{svg}

\usepackage{multirow}
\usepackage{balance}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{microtype}
\usepackage{xspace}
\usepackage{wrapfig,lipsum}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{makecell}
\usepackage[T1]{fontenc}
\usepackage{soul}
\usepackage{tabularx, booktabs}
\usepackage{trimclip}

\usepackage{hyperref}
\usepackage{todonotes}
\usepackage{caption}
\newcommand{\xiaodl}[2][]{\todo[color=yellow,size=\scriptsize,fancyline,caption={},#1]{Xiaodong:#2}}
\newcommand{\hepc}[2][]{\todo[color=orange,size=\scriptsize,fancyline,caption={},#1]{Hepc:#2}}

\newcommand{\cbb}{\mathbf{c}}
\newcolumntype{Y}{>{\centering\arraybackslash}X}
\newcolumntype{L}{>{\arraybackslash}X}

\algnewcommand\algorithmicinput{\textbf{Input:}}
\algnewcommand\algorithmicoutput{\textbf{Output:}}
\algnewcommand\algorithmicparameter{\textbf{Parameters:}}
\algnewcommand\INPUT{\item[\algorithmicinput]}
\algnewcommand\OUTPUT{\item[\algorithmicoutput]}
\algnewcommand\PARAMETER{\item[\algorithmicparameter]}
\newcommand\BibTeX{B{\sc ib}\TeX}

\newcommand{\sj}[1]{{\color{blue}{[{\bf SJ}: #1]}}}

\newcommand\ModelName{DeBERTa}
\newcommand\DecoderName{EMD}

\newcommand{\shorttextrightarrow}{\clipbox*{{.25\width} 0pt {\width} {\height}} \textrightarrow}
\newcommand{\shorttextleftarrow}{\clipbox*{0pt 0pt {.75\width} {\height}} \textleftarrow}

\iclrfinalcopy
\title{\ModelName: Decoding-enhanced BERT with Disentangled Attention}


\author{Pengcheng He, Xiaodong Liu, Jianfeng Gao,  Weizhu Chen \\
     Microsoft Dynamics 365 AI  ~~~~~~~~   Microsoft Research \\
  {\tt \{penhe,xiaodl,jfgao,wzchen\}@microsoft.com}
}

\date{December 2019}
\graphicspath{figures/}
\DeclareGraphicsExtensions{.png,.pdf,.svg}

\begin{document}

\maketitle

\begin{abstract}
Recent progress in pre-trained neural language models has significantly improved the performance of many natural language processing (NLP) tasks. In this paper we propose a new model architecture \textbf{DeBERTa}
(\textbf{D}ecoding-\textbf{e}nhanced \textbf{BERT} with disentangled \textbf{a}ttention) 
that improves the BERT and RoBERTa models using two novel techniques.
The first is the disentangled attention mechanism, where each word is represented using two vectors that encode its content and position, respectively, and the attention weights among words are computed using disentangled matrices on their contents and relative positions, respectively.
Second, 
an enhanced mask decoder is used to incorporate absolute positions in the decoding layer to predict the masked tokens in model pre-training.
In addition, a new virtual adversarial training method is used for fine-tuning to improve models' generalization.  
We show that these techniques significantly improve the efficiency of model pre-training and the performance of both natural language understand (NLU) and natural langauge generation (NLG) downstream tasks. 
Compared to RoBERTa-Large, a DeBERTa model 
trained on half of the training data
performs consistently better on a wide range of NLP tasks, 
achieving improvements on MNLI by +0.9\% (90.2\% vs. 91.1\%), on SQuAD v2.0 by +2.3\% (88.4\% vs. 90.7\%) and RACE by +3.6\% (83.2\% vs. 86.8\%). 
Notably, we scale up DeBERTa by training a larger version that consists of 48 Transform layers with 1.5 billion parameters. 
The significant performance boost makes the single DeBERTa model surpass the human performance on the SuperGLUE benchmark~\citep{wang2019superglue} for the first time in terms of macro-average score (89.9 versus 89.8), and the ensemble DeBERTa model sits atop the SuperGLUE leaderboard as of January 6, 2021, outperforming the human baseline by a decent margin (90.3 versus 89.8). The pre-trained DeBERTa models and the source code were released at: \url{https://github.com/microsoft/DeBERTa}\footnote{Our code and models are also available at HuggingFace Transformers: \url{https://github.com/huggingface/transformers}, \url{https://huggingface.co/models?filter=deberta} }.






\end{abstract}

 
\section{Introduction}
The Transformer has become the most effective neural network architecture for neural language modeling. 
Unlike recurrent neural networks (RNNs) that process text in sequence, Transformers apply self-attention to compute in parallel every word from the input text an attention weight that gauges the influence each word has on another, thus allowing for much more parallelization than RNNs for large-scale model training \citep{vaswani2017attention}. 
Since 2018, we have seen the rise of a set of large-scale Transformer-based Pre-trained Language Models (PLMs), such as 
GPT \citep{radford2019language,brown2020language},
BERT \citep{devlin2018bert}, 
RoBERTa \citep{liu2019roberta}, 
XLNet \citep{yang2019xlnet}, 
UniLM \citep{dong2019unilm},
ELECTRA \citep{clark2020electra},
T5 \citep{raffel2019t5},
ALUM \citep{liu2020alum},
StructBERT \citep{wang2019structbert} and
ERINE \citep{sun2019ernie}
. 
These PLMs have been fine-tuned using task-specific labels and created new state of the art in
many downstream natural language processing (NLP) tasks \citep{liu2019mt-dnn,minaee2020deep, jiang2019smart,he2019hnn,he2019x,shen2020exploiting}. 

In this paper, we propose a new Transformer-based neural language model \textbf{DeBERTa} (\textbf{D}ecoding-\textbf{e}nhanced \textbf{BERT} with disentangled \textbf{a}ttention), which 
improves previous state-of-the-art PLMs using two novel techniques: a disentangled attention mechanism, and an enhanced mask decoder.


\paragraph{Disentangled attention.}
Unlike BERT where each word in the input layer is represented using a vector which is the sum of its word (content) embedding and position embedding, each word in DeBERTa is represented using two vectors that encode its content and position, respectively, and the attention weights among words are computed using disentangled matrices based on their contents and relative positions, respectively. This is motivated by the observation that the attention weight of a word pair depends on not only their contents but their relative positions. For example, the dependency between the words ``deep'' and ``learning'' is much stronger when they occur next to each other than when they occur in different sentences. 

\paragraph{Enhanced mask decoder.}
Like BERT, DeBERTa is pre-trained using masked language modeling (MLM). MLM is a fill-in-the-blank task, where a model is taught to use the words surrounding a mask token to predict what the masked word should be. DeBERTa uses the content and position information of the context words for MLM. The disentangled attention mechanism already considers the contents and relative positions of the context words, but not the absolute positions of these words, which in many cases are crucial for the prediction.
Consider the sentence “a new store opened beside the new mall” with the italicized words “store” and “mall” masked for prediction. Although the local contexts of the two words are similar, they play different syntactic roles in the sentence. (Here, the subject of the sentence is “store” not “mall,” for example.) These syntactical nuances depend, to a large degree, upon the words’ absolute positions in the sentence, and so it is important to account for a word’s absolute position in the language modeling process. DeBERTa incorporates absolute word position embeddings right before the softmax layer where the model decodes the masked words based on the aggregated contextual embeddings of word contents and positions.













In addition, we propose a new virtual adversarial training method for fine-tuning PLMs to downstream NLP tasks. The method is effective in improving models’ generalization.



We show through a comprehensive empirical study that these techniques substantially improve the efficiency of pre-training and the performance of downstream tasks. 
In the NLU tasks, compared to RoBERTa-Large, a DeBERTa model trained on half the training data performs consistently better on a wide range of NLP tasks, 
achieving improvements on MNLI by +0.9\% (90.2\% vs. 91.1\%), on SQuAD v2.0 by +2.3\%(88.4\% vs. 90.7\%), and RACE by +3.6\% (83.2\% vs. 86.8\%). 
In the NLG tasks, DeBERTa reduces the perplexity from 21.6 to 19.5 on the Wikitext-103 dataset. 
We further scale up DeBERTa by pre-training a larger model that consists of 48 Transformer layers with 1.5 billion parameters. 
The single 1.5B-parameter DeBERTa model substantially outperforms T5 with 11 billion parameters on the SuperGLUE benchmark \citep{wang2019superglue} by 0.6\%(89.3\% vs. 89.9\%), and surpasses the human baseline (89.9 vs. 89.8) for the first time.
The ensemble DeBERTa model sits atop the SuperGLUE leaderboard as of January 6, 2021, outperforming the human baseline by a decent margin (90.3 versus 89.8). 
 











 
\section{Background}
\subsection{Transformer}
A Transformer-based language model is composed of stacked Transformer blocks \citep{vaswani2017attention}.
Each block contains a multi-head self-attention layer followed by a fully connected positional feed-forward network. 
The standard self-attention mechanism lacks a natural way to encode word position information.  
Thus, existing approaches add  a positional bias to each input word embedding so that each input word is represented by a vector whose value depends on its content and position.
The positional bias can be implemented using absolute position embedding \citep{vaswani2017attention,radford2019language,devlin2018bert} or relative position embedding \citep{huang2018music,yang2019xlnet}.
It has been shown that relative position representations are more effective for natural language understanding and generation tasks \citep{dai2019transformer,shaw2018self}.
The proposed disentangled attention mechanism differs from all existing approaches in that we represent each input word using two separate vectors that encode a word's content and position, respectively, and attention weights among words are computed using disentangled matrices on their contents and relative positions, respectively. 




\subsection{Masked Language Model}



Large-scale Transformer-based PLMs 
are typically pre-trained on large amounts of text to learn contextual word representations using a self-supervision objective, known as Masked Language Model (MLM)~\citep{devlin2018bert}. Specifically, given a sequence , we corrupt it into  by masking 15\% of its tokens at random and then train a language model parameterized by  to reconstruct  by predicting the masked tokens  conditioned on : 

where  is the index set of the masked tokens in the sequence. The authors of BERT propose to keep 10\% of the masked tokens unchanged, another 10\% replaced with randomly picked tokens and the rest replaced with the \texttt{[MASK]} token.









 
\section{The DeBERTa Architecture}
\subsection{Disentangled Attention: A Two-Vector Approach to Content and Position Embedding}
For a token at position  in a sequence, we represent it using two vectors,  and , 
which represent its content and relative position with the token at position , respectively.
The calculation of the cross attention score between tokens  and  can be decomposed into four components as

That is, the attention weight of a word pair can be computed as a sum of four attention scores using disentangled matrices on their contents and positions as  
\textit{content-to-content}, \textit{content-to-position}, \textit{position-to-content}, and \textit{position-to-position}
\footnote{In this sense, our model shares some similarity to Tensor Product Representation \citep{smolensky1990ptr,schlag2019enhancing,chen2019natural} where a word is represented using a tensor product of its filler (content) vector and its role (position) vector.}. 



Existing approaches to relative position encoding use a separate embedding matrix to compute the relative position bias in computing attention weights~\citep{shaw2018self, huang2018music}. 
This is equivalent to computing the attention weights using only the  content-to-content and content-to-position terms in \eqref{decomposition}.
We argue that the position-to-content term is also important since the attention weight of a word pair depends not only on their contents but on their relative positions, which can only be fully modeled using both the content-to-position and position-to-content terms.
Since we use \emph{relative} position embedding, the position-to-position term does not provide much additional information and is removed from \eqref{decomposition} in our implementation.





Taking single-head attention as an example, the standard self-attention operation~\citep{vaswani2017attention} can be formulated as:  
  
where  represents the input hidden vectors,  the output of self-attention,  the projection matrices,  the attention matrix,  the length of the input sequence, and  the dimension of hidden states.

Denote  as the maximum relative distance,
 as the relative distance from token  to token , which is defined as:


We can represent the disentangled self-attention with relative position bias as \eqref{dis-att}, 
where  and   are the projected content vectors generated using projection matrices  respectively, 
 represents the relative position embedding vectors shared across all layers (i.e., staying fixed during forward propagation), 
and  and  are projected relative position vectors generated using projection matrices , respectively.   





 is the element of attention matrix , representing the attention score from token  to token . 
 is the -th row of .  is the -th row of . 
 is the -th row of  with regarding to relative distance .
 is the -th row of  with regarding to relative distance . 
Note that we use  rather than  here. This is because for a given position , position-to-content computes the attention weight of the key content at  with respect to the query position at , thus the relative distance is . 
The position-to-content term is calculated as .
The content-to-position term is calculated in a similar way.

Finally, we apply a scaling factor of  on .
The factor is important for stabilizing model training~\citep{vaswani2017attention}, especially for large-scale PLMs. 




\begin{algorithm}[H]
\caption{Disentangled Attention}
\label{DA}
\begin{algorithmic}[1]
    \INPUT Hidden state , relative distance embedding , relative distance matrix .
    Content projection matrix , , ,
    position projection matrix , . 

    \State {, , ,   , }
    \State {} 
    \For{} 
        \State {} 
    \EndFor
    \For {}
        \For {}
        \State {} 
        \EndFor
    \EndFor
    \For{}
        \State {} 
    \EndFor
    \For {}
        \For {}
        \State {} 
        \EndFor
    \EndFor
    \State {}
    \State {}
    \OUTPUT 
 \end{algorithmic}

\end{algorithm}
\subsubsection{Efficient implementation}
For an input sequence of length , it requires a space complexity of  \citep{shaw2018self,huang2018music,dai2019transformer} to store the relative position embedding for each token. 
However, taking content-to-position as an example, we note that since  and the embeddings of all possible relative positions are always a subset of , then we can reuse  in the attention calculation for all the queries.

In our experiments, we set the maximum relative distance  to 512 for pre-training.
The disentangled attention weights can be computed efficiently using Algorithm~\ref{DA}.
Let  be the relative position matrix according to \eqref{dist}, i.e., .
Instead of allocating a different relative position embedding matrix for each query, we multiply each  vector  by , as in line . 
Then, we extract the attention weight using the relative position matrix  as the index, as in line . 
To compute the position-to-content attention score, we  calculate , i.e., the column vector of the attention matrix , by multiplying each  vector  by , as in line . 
Finally, we extract the corresponding attention score via the relative position matrix  as the index, as in line . 
In this way, we do not need to allocate memory to store a relative position embedding for each query and thus reduce the space complexity to  (for storing  and ). 












\subsection{Enhanced Mask Decoder Accounts for Absolute Word Positions}
\label{EMD}


DeBERTa is pretrained using MLM, where a model is trained to use the words surrounding a mask token to predict what the masked word should be. 
DeBERTa uses the content and position information of the context words for MLM. The disentangled attention mechanism already considers the contents and relative positions of the context words, but not the absolute positions of these words, which in many cases are crucial for the prediction.

Given a sentence ``a new \textbf{store} opened beside the new \textbf{mall}'' with the words ``store'' and ``mall'' masked for prediction. Using only the local context (e.g., relative positions and surrounding words) is insufficient for the model to distinguish \textit{store} and \textit{mall} in this sentence, since both follow the word \textit{new} with the same relative positions. 
To address this limitation, the model needs to take into account absolute positions, as complement information to the relative positions. 
For example, the subject of the sentence is “store” not “mall”. These syntactical nuances depend, to a large degree, upon the words’ absolute positions in the sentence.

There are two methods of incorporating absolute positions. The BERT model incorporates absolute positions in the input layer. 
In DeBERTa, we incorporate them right after all the Transformer layers but before the \emph{softmax} layer for masked token prediction, as shown in Figure \ref{fig:emd}. 
In this way, DeBERTa captures the relative positions in all the Transformer layers and only uses absolute positions as complementary information when decoding the masked words. Thus, we call DeBERTa's decoding component an Enhanced Mask Decoder (EMD). 
In the empirical study, we compare these two methods of incorporating absolute positions and observe that EMD works much better. 
We conjecture that the early incorporation of absolute positions used by BERT might undesirably hamper the model from learning sufficient information of relative positions. In addition, EMD also enables us to introduce other useful information, in addition to positions, for pre-training. We leave it to future work.

















































\section{Scale Invariant Fine-Tuning}

This section presents a new virtual adversarial training algorithm, Scale-invariant-Fine-Tuning (SiFT), a variant to the algorithm described in~\cite{miyato2018vat,jiang2019smart}, for fine-tuning. 

Virtual adversarial training is a regularization method for improving models’ generalization. It does so by improving a model’s robustness to adversarial examples, which are created by making small perturbations to the input. The model is regularized so that when given a task-specific example, the model produces the same output distribution as it produces on an adversarial perturbation of that example. 

For NLP tasks, the perturbation is applied to the word embedding instead of the original word sequence. However, the value ranges (norms) of the embedding vectors vary among different words and models. The variance gets larger for bigger models with billions of parameters, leading to some instability of adversarial training. 

Inspired by layer normalization~\citep{ba2016layer}, we propose the SiFT algorithm that improves the training stability by applying the perturbations to the \emph{normalized} word embeddings. 
Specifically, when fine-tuning DeBERTa to a downstream NLP task in our experiments, SiFT first normalizes the word embedding vectors into stochastic vectors, and then applies the perturbation to the normalized embedding vectors. We find that the normalization substantially improves the performance of the fine-tuned models. The improvement is more prominent for larger DeBERTa models. 
Note that we \textbf{only} apply SiFT to  {\ModelName} on SuperGLUE tasks in our experiments and we will provide a more comprehensive study of SiFT in our future work.

 \section{Experiment}
This section reports {\ModelName} results on various NLU tasks. 




\subsection{Main Results on NLU tasks}
\label{subsec:main}
Following previous studies of PLMs,
we report results using large and base models.
\subsubsection{Performance on Large Models}
\begin{table*}[htb!]
    \centering
    \begin{tabular}{@{\hskip3pt}l@{\hskip2pt}|@{\hskip2pt} c@{\hskip2pt}| @{\hskip2pt}c@{\hskip2pt}|c@{\hskip2pt}|c@{\hskip2pt}|c@{\hskip2pt}|c@{\hskip2pt}|c@{\hskip2pt}|c@{\hskip2pt}|c@{\hskip2pt}}
        \toprule
        \multirow{2}{*}{\bf Model} & {CoLA} &{QQP} &{MNLI-m/mm} &SST-2 &STS-B&QNLI&RTE&MRPC& Avg.\\ 
        & Mcc & Acc & Acc & Acc &Corr&Acc&Acc&Acc\\
        \midrule
        BERT &60.6 &91.3  & 86.6/- & 93.2 &90.0&92.3&70.4&88.0 &84.05 \\ \hline
        RoBERTa &68.0 & 92.2  & 90.2/90.2 & 96.4 &92.4&93.9&86.6&90.9& 88.82 \\ \hline
        XLNet& 69.0 & 92.3  & 90.8/90.8 & 97.0 &92.5&94.9&85.9&90.8 & 89.15 \\ \hline


ELECTRA\textsubscript{large}&69.1 & 92.4 &90.9/- &96.9& 92.6&95.0 & 88.0&90.8 &89.46 \\ \hline
        {\ModelName} &70.5 & 92.3 & 91.1/91.1 & 96.8 & 92.8 &95.3&88.3& 91.9 &90.00\\
        \bottomrule
        \end{tabular}
    \caption{
    Comparison results on the GLUE development set. 
    }
    \label{tab:glue}
    \vspace{-2mm}
\end{table*}






We pre-train our large models following the setting of BERT~\citep{devlin2018bert}, except that we use the BPE vocabulary of ~\cite{radford2019language,liu2019roberta}.
For training data, we use Wikipedia (English Wikipedia dump\footnote{https://dumps.wikimedia.org/enwiki/}; 12GB), BookCorpus~\citep{bookcorpus} (6GB), OPENWEBTEXT (public Reddit content~\citep{Gokaslan2019OpenWeb}; 38GB), and STORIES (a subset of CommonCrawl~\citep{trinh2018simple}; 31GB). 
The total data size after data deduplication~\citep{shoeybi2019megatron} is about 78G. 
Refer to Appendix A.2 for a detailed description of the pre-training dataset.

We use 6 DGX-2 machines (96 V100 GPUs) to train the models. 
A single model trained with 2K batch size and 1M steps takes about 20 days.
Refer to Appendix \ref{sec:appendix} for the detailed hyperparamters. 


We summarize the results on eight NLU tasks of GLUE~\citep{wang2018glue} in Table~\ref{tab:glue}, where DeBERTa is compared {\ModelName} with previous Transform-based PLMs of similar structures (i.e. 24 layers with hidden size of 1024) including BERT, RoBERTa, XLNet, ALBERT and ELECTRA.
Note that RoBERTa, XLNet and ELECTRA are pre-trained on 160G training data while {\ModelName} is pre-trained on 78G training data. RoBERTa and XLNet are pre-trained for 500K steps with 8K samples in a step, which amounts to four billion training samples. 
{\ModelName} is pre-trained for one million steps with 2K samples in each step.  
This amounts to two billion training samples, approximately half of either RoBERTa or XLNet.  
Table~\ref{tab:glue} shows that compared to BERT and RoBERTa, {\ModelName} performs consistently better across all the tasks. 
Meanwhile, {\ModelName} outperforms XLNet in six out of eight tasks. 
Particularly, the improvements on MRPC (1.1\% over XLNet and 1.0\% over RoBERTa), RTE (2.4\% over XLNet and 1.7\% over RoBERTa) and CoLA (1.5\% over XLNet and 2.5\% over RoBERTa) are significant. 
{\ModelName} also outperforms other SOTA PLMs, i.e., ELECTRA\textsubscript{large} and XLNet\textsubscript{large}, in terms of average GLUE score.  


Among all GLUE tasks, MNLI is most often used as an indicative task to monitor the research progress of PLMs. 
{\ModelName} significantly outperforms all existing PLMs of similar size on MNLI and creates a new state of the art. \begin{table*}[htb!]
    \centering
    \begin{tabular}{@{\hskip2pt}l@{\hskip3pt}|@{\hskip2pt} c@{\hskip2pt}|| @{\hskip2pt}c@{\hskip2pt}@{\hskip2pt}c@{\hskip2pt}|@{\hskip2pt}c@{\hskip2pt}|@{\hskip2pt}c@{\hskip2pt}||@{\hskip2pt}c@{\hskip2pt}||@{\hskip2pt}c@{\hskip2pt}}
        \toprule
        \multirow{2}{*}{\bf Model} &{MNLI-m/mm} & {SQuAD v1.1} &{SQuAD v2.0} &RACE &ReCoRD  &SWAG & NER\\ 
        & Acc & F1/EM & F1/EM &Acc&F1/EM& {Acc}   & F1\\
        \midrule
        BERT & 86.6/-& 90.9/84.1 &81.8/79.0  &72.0 &-   &86.6 &92.8\\ \hline
        ALBERT & 86.5/-& 91.8/85.2 & 84.9/81.8 &75.2 &-  &-&- \\ \hline
        RoBERTa & 90.2/90.2& 94.6/88.9 & 89.4/86.5 &83.2 &90.6/90.0   &89.9 &93.4\\ \hline
        XLNet & 90.8/90.8& 95.1/89.7 & 90.6/87.9 &85.4 &-  &-&- \\ \hline
        Megatron\textsubscript{336M} & 89.7/90.0 & 94.2/88.0 & 88.1/84.8 &83.0 &-   &-&- \\ \hline
        {\ModelName} & \textbf{91.1/91.1} &\textbf{95.5/90.1} & \textbf{90.7/88.0} & \textbf{86.8} &\textbf{91.4/91.0}   &\textbf{90.8} &\textbf{93.8}\\ \hline \hline
        ALBERT & 90.8/-& 94.8/89.3 & 90.2/87.4 &86.5 &-  &-&- \\ \hline
        Megatron\textsubscript{1.3B} & 90.9/91.0 & 94.9/89.1 & 90.2/87.1 & 87.3 &- &-&- \\ \hline
        Megatron\textsubscript{3.9B} & 91.4/91.4 & 95.5/90.0 & 91.2/88.5 &89.5&-  &-&- \\      
        \bottomrule
        \end{tabular}
    \caption{
    Results on MNLI in/out-domain,  SQuAD v1.1, SQuAD v2.0, RACE, ReCoRD, SWAG, CoNLL 2003 NER development set. Note that missing results in literature are signified by ``-''.}
    \label{tab:large}
    \vspace{-4mm}
\end{table*}



In addition to GLUE, DeBERTa is evaluated on three categories of NLU benchmarks: 
(1) Question Answering: SQuAD v1.1 \citep{squad1}, SQuAD v2.0 \citep{squad2}, RACE \citep{lai2017race}, ReCoRD \citep{zhang2018record} and SWAG \citep{zellers2018swag}; 
(2) Natural Language Inference: MNLI \citep{mnli2018}; and 
(3) NER: CoNLL-2003.
For comparison, we include 
ALBERT\textsubscript{xxlarge}~\citep{lan2019albert}
\footnote{ The hidden dimension of ALBERT\textsubscript{xxlarge} is 4 times of DeBERTa and the computation cost is about 4 times of DeBERTa.} and 
Megatron~\citep{shoeybi2019megatron} with three different model sizes, denoted as Megatron\textsubscript{336M}, Megatron\textsubscript{1.3B} and Megatron\textsubscript{3.9B}, respectively, which are trained using the same dataset as RoBERTa. 
Note that Megatron\textsubscript{336M} has a similar model size as other models mentioned above\footnote{T5~\citep{raffel2019t5} has more parameters (11B). \cite{raffel2019t5} only report the test results of T5 which are not comparable with other models.}. 

We summarize the results in Table~{\ref{tab:large}}. 
Compared to the previous SOTA PLMs with a similar model size (i.e., BERT, RoBERTa, XLNet,  ALBERT\textsubscript{large}, and Megatron\textsubscript{336M}),  {\ModelName} shows superior performance in all seven tasks. 
Taking the RACE benchmark as an example, {\ModelName} significantly outperforms XLNet by +1.4\% (86.8\% vs. 85.4\%). 
Although Megatron\textsubscript{1.3B} is three times larger than {\ModelName}, {\ModelName} outperforms it in three of the four benchmarks. We further report {\ModelName} on text generation tasks in Appendix~\ref{subsec:generation}.


\subsubsection{Performance on Base Models}
Our setting for base model pre-training is similar to that for large models. 
The base model structure follows that of the BERT base model, i.e., . 
We use 4 DGX-2 with 64 V100 GPUs to train the base model. 
It takes 10 days to finish a single pre-training of 1M training steps with batch size 2048. 
We train {\ModelName} using the same 78G dataset, and compare it to RoBERTa and XLNet trained on 160G text data. 


We summarize the base model results in Table~\ref{tab:base-dev}. 
Across all three tasks, {\ModelName} consistently outperforms RoBERTa and XLNet by a larger margin than that in large models.  
For example, on MNLI-m, {\ModelName\textsubscript{base}} obtains +1.2\%  (88.8\% vs. 87.6\%) over RoBERTa\textsubscript{base}, and +2\% (88.8\% vs. 86.8\%) over XLNet\textsubscript{base}.
\begin{table*}[htb!]
    \centering
    \begin{tabular}{@{\hskip2pt}l| c | c | c @{\hskip2pt}}
        \toprule
{\bf Model} &{MNLI-m/mm (Acc)} & {SQuAD v1.1 (F1/EM)} &{SQuAD v2.0 (F1/EM)}  \\ 
\midrule
RoBERTa & 87.6/- & 91.5/84.6 & 83.7/80.5  \\ \hline
        XLNet & 86.8/- & -/- & -/80.2  \\ \hline
        {\ModelName} & \textbf{88.8/88.5}  &\textbf{93.1/87.2} & \textbf{86.2/83.1}  \\
        \bottomrule
        \end{tabular}
    \caption{
    Results on MNLI in/out-domain (m/mm), SQuAD v1.1 and v2.0   development set. 
    }
    \label{tab:base-dev}
    \vspace{-3mm}
\end{table*}






\subsection{Model Analysis}
In this section, we first present an ablation study to quantify the relative contributions of different components introduced in {\ModelName}. 
Then, we study the convergence property to characterize the model training efficiency. 
We run experiments for analysis using the base model setting: a model is pre-trained using 
the Wikipedia + Bookcorpus dataset 
for 1M steps with batch size 256 
in 7 days on a DGX-2 machine with 16 V-100 GPUs.
Due to space limit, we visualize the different attention patterns of {\ModelName} and RoBERTa in Appendix A.7. 







\subsubsection{Ablation study}
\label{subsec:abs}
To verify our experimental setting, we pre-train the RoBERTa base model from scratch.  
The re-pre-trained RoBERTa model is denoted as RoBERTa-ReImp\textsubscript{base}. 
To investigate the relative contributions of different components in {\ModelName}, we develop three variations:
\begin{itemize}
\item {-\DecoderName} is the {\ModelName} base model without \DecoderName.
    \item {-C2P} is the  {\ModelName} base model without the content-to-position term ((c) in Eq.~\ref{dis-att}).
    \item {-P2C} is the {\ModelName} base model without the position-to-content term ((b) in Eq.~\ref{dis-att}). As XLNet also uses the relative position bias, this model is close to XLNet plus \DecoderName.
\end{itemize}
\begin{table*}[htb!]
    \centering
    \begin{tabular}{@{\hskip1pt}l| c| cc|c@{\hskip1pt}}
        \toprule
        \multirow{2}{*}{\bf Model} &{MNLI-m/mm}& {SQuAD v1.1} &{SQuAD v2.0} &RACE\\ 
         & { Acc}& F1/EM & F1/EM  & Acc\\
        \midrule
        BERT \cite{devlin2018bert} & 84.3/84.7 & 88.5/81.0 &76.3/73.7   & 65.0 \\ RoBERTa \cite{liu2019roberta} & 84.7/- & 90.6/- &79.7/-   & 65.6\\ XLNet \cite{yang2019xlnet}& 85.8/85.4 & -/- & 81.3/78.5  & 66.7\\ \hline
        RoBERTa-ReImp & 84.9/85.1 & 91.1/84.8 &79.5/76.0   & 66.8\\ \hline {\ModelName} & \textbf{86.3/86.2} &\textbf{92.1/86.1} & \textbf{82.5/79.3}  &\textbf{ 71.7}\\
        -EMD & 86.1/86.1& 91.8/85.8 &81.3/78.0   & 70.3\\ -C2P  & 85.9/85.7 & 91.6/85.8 &81.3/78.3   & 69.3\\ -P2C  & 86.0/85.8 & 91.7/85.7 &80.8/77.6   & 69.6\\ -(EMD+C2P) & 85.8/85.9 & 91.5/85.3 &80.3/77.2   & 68.1\\ -(EMD+P2C)  & 85.8/85.8& 91.3/85.1 &80.2/77.1    & 68.5\\ \bottomrule
        \end{tabular}
    \caption{
    Ablation study of the DeBERTa base model.
    }
    \label{tab:ablation}
\end{table*}
Table~\ref{tab:ablation} summarizes the results on four benchmark datasets. 
First, RoBERTa-ReImp performs similarly to RoBERTa across all  benchmark datasets, verfiying that our setting is reasonable. 
Second, we see that removing any one component in {\ModelName} results in a sheer performance drop. 
For instance, removing EMD (-EMD) results in a loss of 1.4\% (71.7\% vs. 70.3\%) on RACE, 0.3\% (92.1\% vs. 91.8\%) on SQuAD v1.1, 1.2\% (82.5\% vs. 81.3\%) on SQuAD v2.0, 0.2\% (86.3\% vs. 86.1\%) and 0.1\% (86.2\% vs. 86.1\%) on MNLI-m/mm, respectively. 
Similarly, removing either \textit{content-to-position} or  \textit{position-to-content} leads to inferior performance in all the benchmarks.
As expected, removing two components results in even more substantial loss in performance. 










































\subsection{Scale up to 1.5 billion parameters}
Larger pre-trained models have shown better generalization results \citep{raffel2019t5,brown2020language, shoeybi2019megatron}. 
Thus, we have built a larger version of DeBERTa with 1.5 billion parameters, denoted as DeBERTa.
The model consists of 48 layers with a hidden size of 1,536 and 24 attention heads
\footnote{See Table~\ref{tbl:hyper-pre-train} in Appendix for the model hyperparameters.}.
DeBERTa is trained on a pre-training dataset amounting to 160G, similar to that in~\cite{liu2019roberta}, with a new vocabulary of size 128K constructed using the dataset.


To train DeBERTa, we optimize the model architecture as follows. 
First, we share the projection matrices of relative position embedding  with , respectively, in all attention layers to reduce the number of model parameters. Our ablation study in Table \ref{tab:v2} on base models shows that the projection matrix sharing reduces the model size while retaining the model performance.
Second, a convolution layer is added aside the first Transformer layer to induce n-gram knowledge of sub-word encodings and their outputs are summed up before feeding to the next Transformer layer~\footnote{Please refer to Table~\ref{tab:xxlarge} in Appendix \ref{subsec:scale} for the ablation study of different model sizes, and Table \ref{tab:v2} in Appendix \ref{subsec:scale} for the ablation study of new modifications.}.



Table~\ref{tab:superglue} reports the test results of SuperGLUE \citep{wang2019superglue} which is one of the most popular NLU benchmarks. 
SuperGLUE consists of a wide of NLU tasks, including  
Question Answering \citep{clark2019boolq, khashabi2018multirc, zhang2018record}, 
Natural Language Inference \citep{rte1,rte2,rte3, rte5}, Word Sense Disambiguation \citep{pilehvar2019wic}, and Reasoning \citep{levesque2011winograd,roemmele2011choice}. 
Since its release in 2019, top research teams around the world have been developing large-scale PLMs that have driven striking performance improvement on SuperGLUE. 

The significant performance boost due to scaling DeBERTa to a larger model makes the single DeBERTa surpass the human performance on SuperGLUE for the first time in terms of macro-average score (89.9 versus 89.8) as of December 29, 2020, and the ensemble DeBERTa model (DeBERTa) sits atop the SuperGLUE benchmark rankings as of January 6, 2021, outperforming the human baseline by a decent margin (90.3 versus 89.8). 
Compared to T5, which consists of 11 billion parameters, the 1.5-billion-parameter DeBERTa is much more energy efficient to train and maintain, and it is easier to compress and deploy to apps of various settings.



\begin{table*}[htb!]
    \centering
    \begin{tabular}{@{\hskip2pt}l@{\hskip2pt}|@{\hskip2pt} @{\hskip1pt}c@{\hskip1pt}|@{\hskip2pt}c@{\hskip1pt}|@{\hskip2pt}c@{\hskip1pt}|c@{\hskip1pt}|c@{\hskip1pt}|c@{\hskip1pt}|c@{\hskip1pt}|c@{\hskip1pt}|@{\hskip2pt}c@{\hskip1pt}}
        \toprule
        \multirow{2}{*}{\bf Model} & BoolQ &CB&COPA&MultiRC&ReCoRD&RTE&WiC&WSC& Average\\ 
         & Acc & F1/Acc & Acc &F1a/EM&F1/EM&Acc&Acc&Acc& Score\\
        \midrule
RoBERTa\textsubscript{large} & 87.1  & 90.5/95.2 & 90.6 &84.4/52.5&90.6/90.0&88.2&69.9 &89.0 &84.6\\  \hline
        NEXHA-Plus                  & 87.8  & 94.4/96.0 & 93.6 &84.6/55.1&90.1/89.6&89.1&74.6 &93.2 &86.7\\  \hline
        T5 &91.2  & 93.9/96.8 & 94.8 &88.1/63.3&94.1/93.4&92.5&76.9 &93.8 &89.3\\ 
        \hline
        T5+Meena &\textbf{91.3}  & \textbf{95.8/97.6} & 97.4 &88.3/63.0&94.2/93.5&92.7&\textbf{77.9} &95.9 &90.2\\ 
        \hline \hline
        Human  &89.0 & 95.8/98.9 & 100.0 &81.8/51.9&91.7/91.3&93.6&80.0 &100.0 &89.8\\  \hline \hline
        DeBERTa+SiFT &90.4  & 94.9/97.2 & 96.8&\textbf{88.2/63.7}&\textbf{94.5/94.1}&\textbf{93.2}&76.4 &	\textbf{95.9} & 89.9\\  
        DeBERTa &90.4  & 95.7/97.6 & \textbf{98.4}&88.2/63.7&94.5/94.1&93.2&77.5 &	95.9 & \textbf{90.3}\\
        \bottomrule
        \end{tabular}
    \caption{
SuperGLUE test set results scored using the SuperGLUE evaluation server. All the results are obtained from \href{https://super.gluebenchmark.com}{https://super.gluebenchmark.com} on January 6, 2021.
    }
    \label{tab:superglue}
    
\end{table*}


 \section{Conclusions}
\label{sec:conclusion}

This paper presents a new model architecture DeBERTa (Decoding-enhanced BERT with disentangled attention) that improves the BERT and RoBERTa models using two novel techniques. 
The first is the disentangled attention mechanism, where
each word is represented using two vectors that encode its content and position, respectively, and the attention weights among words are computed using disentangled matrices on their contents and relative positions, respectively. 
The second is an enhanced mask decoder which incorporates absolute positions in the decoding layer to predict the masked tokens in model pre-training. 
In addition, a new virtual adversarial training method is used for fine-tuning to improve model's generalization on downstream tasks.

We show through a comprehensive empirical study that these techniques significantly improve the efficiency of model pre-training and the performance of downstream tasks. 
The DeBERTa model with 1.5 billion parameters surpasses the human
performance on the SuperGLUE benchmark for the first time
in terms of macro-average score.

DeBERTa surpassing human performance on SuperGLUE marks an important milestone toward general AI. Despite its promising results on SuperGLUE, the model is by no means reaching the human-level intelligence of NLU. Humans are extremely good at leveraging the knowledge learned from different tasks to solve a new task with no or little task-specific demonstration. This is referred to as \emph{compositional generalization}, the ability to generalize to novel compositions (new tasks) of familiar constituents (subtasks or basic problem-solving skills). Moving forward, it is worth exploring how to make DeBERTa incorporate compositional structures in a more explicit manner, which could allow combining neural and symbolic computation of natural language similar to what humans do.






%
 






 \section{Acknowledgments}


We thank Jade Huang and Nikos Karampatziakis for proofreading the paper and providing insightful comments. We thank Yoyo Liang, Saksham Singhal, Xia Song, and Saurabh Tiwary for their help with large-scale model training. 
We also thank the anonymous reviewers for valuable discussions.  



 
\bibliography{ref,ref_xiaodong}
\bibliographystyle{iclr2021_conference}
\clearpage
\appendix
\section{Appendix}
\label{sec:appendix}















\subsection{Dataset}
\begin{table*}[!htb]
	\begin{center}
		\begin{tabular}{l|l|c|c|c|c|c}
			\toprule 
			\bf Corpus &Task& \#Train & \#Dev & \#Test   & \#Label &Metrics\\ \hline \hline
			\multicolumn{6}{@{\hskip1pt}r@{\hskip1pt}}{\textbf{General Language Understanding Evaluation (GLUE})} \\ \hline
CoLA & Acceptability&8.5k & 1k & 1k & 2 & Matthews corr\\ \hline
			SST & Sentiment&67k & 872 & 1.8k & 2 & Accuracy\\ \hline
MNLI & NLI& 393k& 20k & 20k& 3 & Accuracy\\ \hline
            RTE & NLI &2.5k & 276 & 3k & 2 & Accuracy \\ \hline
            WNLI & NLI &634& 71& 146& 2 & Accuracy \\ \hline
			QQP & Paraphrase&364k & 40k & 391k& 2 & Accuracy/F1\\ \hline
            MRPC & Paraphrase &3.7k & 408 & 1.7k& 2&Accuracy/F1\\ \hline
			QNLI & QA/NLI& 108k &5.7k&5.7k&2& Accuracy\\ \hline 
STS-B & Similarity &7k &1.5k& 1.4k &1 & Pearson/Spearman corr\\ \hline \hline
\multicolumn{6}{@{\hskip1pt}c@{\hskip1pt}}{\textbf{SuperGLUE}} \\ \hline
			WSC & Coreference& 554k & 104 & 146 & 2 & Accuracy\\ \hline
BoolQ & QA& 9,427 & 3,270 & 3,245 & 2 & Accuracy\\ \hline
            COPA & QA &400k & 100 & 500 & 2 & Accuracy \\ \hline
			CB & NLI& 250 & 57 & 250 & 3 & Accuracy/F1\\ \hline
            RTE & NLI &2.5k & 276 & 3k & 2 & Accuracy \\ \hline
            WiC & WSD &2.5k & 276 & 3k & 2 & Accuracy \\ \hline
			ReCoRD & MRC&  101k& 10k&10k &-& Exact Match (EM)/F1\\ \hline 

MultiRC & Multiple choice&  5,100& 953&1,800 &-& Exact Match (EM)/F1\\ \hline \hline
			\multicolumn{5}{@{\hskip1pt}r@{\hskip1pt}}{Question Answering} \\ \hline 
			SQuAD v1.1 & MRC&  87.6k& 10.5k&9.5k &-& Exact Match (EM)/F1\\ \hline 
			SQuAD v2.0 & MRC& 130.3k &11.9k& 8.9k&-& Exact Match (EM)/F1\\ \hline 			
RACE & MRC&  87,866& 4,887&4,934 &4& Accuracy\\ \hline
			SWAG & Multiple choice&  73.5k& 20k&20k &4& Accuracy\\ \hline \hline
			\multicolumn{4}{@{\hskip1pt}r@{\hskip1pt}}{\textbf{Token Classification}} \\ \hline 
			CoNLL 2003 & NER&  14,987& 3,466& 3,684 &8& F1\\
			
			\bottomrule

		\end{tabular}
	\end{center}
	\caption{Summary information of the NLP application benchmarks.
	}
	\label{tab:datasets}
\end{table*}
\noindent  \textbf{GLUE}. The General Language Understanding Evaluation (GLUE) benchmark is a collection of nine natural language understanding (NLU) tasks. As shown in Table~\ref{tab:datasets},
it includes question answering~\citep{squad1}, linguistic acceptability~\citep{cola2018}, sentiment analysis~\citep{sst2013}, text similarity~\citep{sts-b2017}, paraphrase detection~\citep{mrpc2005}, and natural language inference (NLI)~\citep{rte1,rte2,rte3,rte5,winograd2012,mnli2018}. The diversity of the tasks makes GLUE very suitable for evaluating the generalization and robustness of NLU models. 



\noindent  \textbf{SuperGLUE}. SuperGLUE is an extension of the GLUE benchmark, but more difficult, which is a collection of eight NLU tasks. It covers a various of tasks including question answering \citep{zhang2018record,clark2019boolq,khashabi2018multirc}, natural language inference \citep{rte1,rte2,rte3,rte5,de2019cb}, coreference resolution \citep{winograd2012} and word sense disambiguation \citep{pilehvar2019wic}.

\noindent  \textbf{RACE}  is a large-scale machine reading comprehension dataset, collected from English examinations in China, which are designed for middle school and high school students \citep{lai2017race}. 

\noindent  \textbf{SQuAD v1.1/v2.0} is the Stanford Question
Answering Dataset (SQuAD) v1.1 and v2.0 \citep{squad1,squad2} are popular machine reading comprehension benchmarks. Their passages come from approximately 500 Wikipedia articles and the questions and answers are obtained by crowdsourcing. The SQuAD v2.0 dataset includes unanswerable questions about the same paragraphs.

\noindent  \textbf{SWAG} is a large-scale adversarial dataset for the task of grounded commonsense inference, which unifies natural language inference and physically grounded reasoning \citep{zellers2018swag}. SWAG consists of 113k multiple choice questions about grounded situations.

\noindent  \textbf{CoNLL 2003}  is an English dataset consisting of text from a wide variety of sources. It has 4 types of named entity.

\subsection{Pre-training Dataset}
\label{appendix:pre-train}
For DeBERTa pre-training, we use Wikipedia (English Wikipedia dump\footnote{https://dumps.wikimedia.org/enwiki/}; 12GB), BookCorpus \citep{bookcorpus} \footnote{https://github.com/butsugiri/homemade\_bookcorpus} (6GB), OPENWEBTEXT (public Reddit content \citep{Gokaslan2019OpenWeb}; 38GB) and STORIES\footnote{https://github.com/tensorflow/models/tree/master/research/lm\_commonsense} (a subset of CommonCrawl \citep{trinh2018simple}; 31GB). The total data size after data deduplication\citep{shoeybi2019megatron} is about 78GB. For pre-training, we also sample 5\% training data as the validation set to monitor the training process. Table~\ref{tab:data-comp} compares datasets used in different pre-trained models.

\begin{table*}[htb!]
    \centering
    \begin{tabular}{@{\hskip1pt}l@{\hskip3pt}|@{\hskip3pt}c@{\hskip3pt}|@{\hskip3pt} c@{\hskip3pt}|@{\hskip3pt} c@{\hskip3pt}|@{\hskip3pt} c@{\hskip3pt}|@{\hskip3pt}c@{\hskip3pt}|@{\hskip3pt}c@{\hskip3pt}|@{\hskip3pt}c@{\hskip3pt}} 
    \toprule
        \bf Model&  Wiki+Book & OpenWebText & Stories & CC-News&Giga5&ClueWeb&Common Crawl  \\
                 & 16GB & 38GB & 31GB & 76GB & 16GB &19GB & 110GB         \\ \hline
       BERT& \checkmark & & & & &\\ \hline
       XLNet& \checkmark & & & &\checkmark &\checkmark&\checkmark\\ \hline
       RoBERTa& \checkmark & \checkmark& \checkmark& \checkmark& &\\ \hline
       DeBERTa&  \checkmark & \checkmark& \checkmark& & &\\ 
       DeBERTa&  \checkmark & \checkmark& \checkmark& \checkmark & &\\ 
        \bottomrule
        \end{tabular}
    \caption{
    Comparison of the pre-training data.
    }
    \label{tab:data-comp}
\end{table*}

\subsection{Implementation Details}
\label{subsec:details}
Following RoBERTa \citep{liu2019roberta}, we  adopt dynamic data batching. We also include span masking~\citep{joshi2019spanbert} as an additional masking strategy with the span size up to three. 
We list the detailed hyperparameters of pre-training in Table~\ref{tbl:hyper-pre-train}. For pre-training, we use Adam \citep{kingma2014adam} as the optimizer with weight decay \citep{loshchilov2018fixing}. For fine-tuning, even though we can get better and robust results with RAdam\citep{liu2019radam} on some tasks, e.g. CoLA, RTE and RACE, we use Adam\citep{kingma2014adam} as the optimizer for a fair comparison.
For fine-tuning, we train each task with a hyper-parameter search procedure, each run takes about 1-2 hours on a DGX-2 node. All the hyper-parameters are presented in Table~\ref{tbl:hyper-ft}. The model selection is based on the performance on the task-specific development sets. 

Our code is implemented based on Huggingface Transformers\footnote{https://github.com/huggingface/transformers}, FairSeq\footnote{https://github.com/pytorch/fairseq} and Megatron \citep{shoeybi2019megatron}\footnote{https://github.com/NVIDIA/Megatron-LM}.

\begin{table*}[htb!]
    \centering
    \begin{tabular}{@{\hskip3pt}l@{\hskip2pt}|@{\hskip2pt} c@{\hskip2pt}|@{\hskip2pt} c@{\hskip2pt}|@{\hskip2pt} c@{\hskip2pt}|@{\hskip2pt} c@{\hskip2pt}}
        \toprule
          Hyper-parameter & DeBERTa& DeBERTa &  DeBERTa &DeBERTa\\
        \midrule
        Number of Layers& 48& 24 &12 &12\\
        Hidden size&1536 &1024 &768 &768\\
        FNN inner hidden size & 6144& 4096 & 3072& 3072 \\
        Attention Heads &24 & 16 & 12 & 12\\
        Attention Head size &64 & 64 & 64& 64 \\
        Dropout & 0.1& 0.1 & 0.1& 0.1 \\
        Warmup Steps & 10k & 10k & 10k & 10k\\
        Learning Rates & 1.5e-4& 2e-4& 2e-4& 1e-4 \\
        Batch Size & 2k& 2k & 2k & 256\\
        Weight Decay & 0.01& 0.01 & 0.01& 0.01 \\
        Max Steps & 1M& 1M & 1M & 1M\\
        Learning Rate Decay & Linear& Linear & Linear& Linear \\
        Adam  & 1e-6& 1e-6 & 1e-6& 1e-6 \\
        Adam  & 0.9& 0.9 & 0.9& 0.9 \\
        Adam  & 0.999& 0.999 & 0.999& 0.999 \\
        Gradient Clipping & 1.0& 1.0 & 1.0& 1.0 \\ \hline
        Number of DGX-2 nodes & 16& 6 & 4 &1 \\
        Training Time & 30 days& 20 days & 10 days & 7 days \\
        \bottomrule
        \end{tabular}
    \caption{    Hyper-parameters for pre-training DeBERTa. }
    \label{tbl:hyper-pre-train}
\end{table*}

\begin{table*}[htb!]
   
    \centering
    \begin{tabular}{@{\hskip3pt}l@{\hskip2pt}|@{\hskip2pt} c@{\hskip2pt}|@{\hskip2pt} c@{\hskip2pt}|@{\hskip2pt} c@{\hskip2pt}}
        \toprule
          Hyper-parameter & DeBERTa& DeBERTa &  DeBERTa\\
        \midrule
        Dropout of task layer & \{0,0.15,0.3\}& \{0,0.1,0.15\} & \{0,0.1,0.15\} \\
        Warmup Steps & \{50,100,500,1000\}& \{50,100,500,1000\} & \{50,100,500,1000\} \\
        Learning Rates & \{1e-6, 3e-6, 5e-6\}& \{5e-6, 8e-6, 9e-6, 1e-5\} & \{1.5e-5,2e-5, 3e-5, 4e-5\} \\
        Batch Size & \{16,32,64\}& \{16,32,48,64\} & \{16,32,48,64\} \\
        Weight Decay & 0.01 & 0.01 \\
        Maximun Training Epochs & 10& 10 & 10 \\
        Learning Rate Decay & Linear & Linear & Linear \\
        Adam  & 1e-6 & 1e-6 & 1e-6 \\
        Adam  & 0.9 & 0.9 & 0.9 \\
        Adam  & 0.999 & 0.999 & 0.999 \\
        Gradient Clipping & 1.0 & 1.0 & 1.0 \\
        \bottomrule
        \end{tabular}
    \caption{
    Hyper-parameters for fine-tuning DeBERTa on down-streaming tasks. 
    }
     \label{tbl:hyper-ft}
\end{table*}

\subsubsection{Pre-training Efficiency}
\label{subse:eff}
To investigate the efficiency of model pre-training, we plot the performance of the fine-tuned model on downstream tasks 
as a function of the number of pre-training steps. 
As shown in Figure~\ref{fig:conv}, for RoBERTa-ReImp and {\ModelName}, we dump a checkpoint every 150K pre-training steps, and then fine-tune the checkpoint on two representative downstream tasks, MNLI and SQuAD v2.0, and then report the accuracy and F1 score, respectively.  
As a reference, we also report the final model performance of both the original RoBERTa~\citep{liu2019roberta} and XLNet~\citep{yang2019xlnet}. 
The results show that {\ModelName} consistently outperforms RoBERTa-ReImp during the course of pre-training.
\begin{figure}[htb!]
\centering  
\subfloat[Results on MNLI development]{
\includegraphics[width=0.49\linewidth]{figures/deberta_mnli_v3.png}


}
\hfill
\subfloat[Results on SQuAD v2.0 development]{\includegraphics[width=0.49\linewidth]{figures/deberta_squad_v3.png}}
	\caption{Pre-training performance curve between {\ModelName} and its counterparts on the MNLI and SQuAD v2.0 development set.}
\label{fig:conv}
\end{figure}

\subsection{Main Results on Generation Tasks}
\label{subsec:generation}
In addition to NLU tasks, DeBERTa can also be extended to handle NLG tasks.
To allow DeBERTa operating like an auto-regressive model for text generation, we use a triangular matrix for self-attention and set the upper triangular part of the self-attention mask to , following~\cite{dong2019unilm}. 

We evaluate DeBERTa on the task of auto-regressive language model (ARLM) using Wikitext-103~\citep{merity2016pointer}. 
To do so, we train a new version of DeBERTa, denoted as DeBERTa-MT. 
It is jointly pre-trained using the MLM and ARLM tasks as in UniLM \citep{dong2019unilm}. 
The pre-training hyper-parameters follows that of DeBERTa except that we use fewer training steps (200k). For comparison, we use RoBERTa as baseline, and include GPT-2 and Transformer-XL as additional references.  
DeBERTa-AP is a variant of DeBERTa where absolute position embeddings are incorporated in the input layer as RoBERTa. 
For a fair comparison, all these models are base models pre-trained in a similar setting.


\begin{table*}[htb!]
    \centering
    \begin{tabular}{@{\hskip2pt}l|@{\hskip2pt} c @{\hskip2pt}|@{\hskip2pt} c @{\hskip2pt}| c@{\hskip2pt} |@{\hskip2pt}c@{\hskip2pt}|@{\hskip2pt} c@{\hskip2pt}|@{\hskip2pt}c @{\hskip2pt}}
        \toprule
        {\bf Model} &{RoBERTa}& {DeBERTa-AP} & {DeBERTa} & {DeBERTa-MT} &{GPT-2} &{Transformer-XL}  \\ 
        \midrule
        Dev PPL & 21.6 & 20.7 & 20.5 & \textbf{19.5} & -& 23.1  \\ \hline
        Test PPL & 21.6 & 20.0 & 19.9 & \textbf{19.5} &  37.50& 24  \\
        \bottomrule
        \end{tabular}
    \caption{
    Language model results in perplexity (lower is better) on Wikitext-103 . 
    }
    \label{tab:wiki}
\end{table*}
Table~\ref{tab:wiki} summarizes the results on Wikitext-103. 
We see that {\ModelName}\textsubscript{base} obtains lower perplexities on both dev and test data, and joint training using MLM and ARLM reduces perplexity further. That DeBERTa-AP is inferior to DeBERTa indicates that it is more effective to incorporate absolute position embeddings of words in the decoding layer as the EMD in DeBERTa than in the input layer as RoBERTa.

\subsection{Handling long sequence input}
With relative position bias, we choose to truncate the maximum relative distance to  as  in \eqref{dist}. Thus in each layer, each token can attend directly to at most  tokens and itself. By stacking Transformer layers, each token in the th layer can attend to at most  tokens implicitly. Taking {\ModelName} as an example, where , in theory, the maximum sequence length that can be handled is 24,528. This is a byproduct benefit of our design choice and we find it beneficial for the RACE task. 
A comparison of long sequence effect on the RACE task is shown in Table~\ref{tab:race-long}.

\begin{table*}[htb!]
    \centering
    \begin{tabular}{@{\hskip2pt}l@{\hskip3pt}|@{\hskip2pt} c@{\hskip2pt}| @{\hskip2pt}c@{\hskip2pt}| @{\hskip2pt}c@{\hskip2pt}}
        \toprule
        Sequence length& Middle &High &Accuracy \\
        \midrule
        512 & 88.8 & 85.0 & 86.3 \\
        768 & 88.7 & 86.3 & 86.8 \\
        \bottomrule
    \end{tabular}
    \caption{
    The effect of handling long sequence input for RACE task with DeBERTa
    }
    \label{tab:race-long}
\end{table*}

Long sequence handling is an active research area. There have been a lot of studies where the Transformer architecture is extended for long sequence handling\citep{beltagy2020longformer, kitaev2020reformer, child2019generating, dai2019transformer}.  
One of our future research directions is to extend {\ModelName} to deal with extremely long sequences.


\subsection{Performance improvements of different model scales}
\label{subsec:scale}
In this subsection, we study the effect of different model sizes  applied to large models on GLUE. Table \ref{tab:xxlarge} summarizes the results,  showing that larger models can obtain a better result and SiFT also improves the model performance consistently.



\begin{table*}[htb!]
    \centering
    \begin{tabular}{@{\hskip3pt}l@{\hskip2pt}|@{\hskip2pt} c@{\hskip2pt}| @{\hskip2pt}c@{\hskip2pt}|c@{\hskip2pt}|c@{\hskip2pt}|c@{\hskip2pt}|c@{\hskip2pt}|c@{\hskip2pt}|c@{\hskip2pt}|c@{\hskip2pt}}
        \toprule
        \multirow{2}{*}{\bf Model} & {CoLA} &{QQP} &{MNLI-m/mm} &SST-2 &STS-B&QNLI&RTE&MRPC& Avg.\\ 
        & Mcc & Acc & Acc & Acc &Corr&Acc&Acc&Acc\\
        \midrule
        {\ModelName} &70.5 & 92.3 & 91.1/91.1 & 96.8 & 92.8 &95.3&88.3& 91.9 &90.00\\
        {\ModelName} &71.1 & 92.3 & 91.7/91.6 & \textbf{97.5} & 92.0 & 95.8 &93.5& 93.1 &90.86\\
        {\ModelName} &72.0 & 92.7 & 91.7/91.9 & 97.2 & 92.9 &96.0 &93.9& 92.0 &91.17\\
        \hline
        {\ModelName}+SiFT &\textbf{73.5} & \textbf{93.0} & \textbf{92.0/92.1} & 97.5 & \textbf{93.2} &\textbf{96.5} &\textbf{96.5}& \textbf{93.2} &\textbf{91.93}\\
        \bottomrule
        \end{tabular}
    \caption{
    Comparison results of DeBERTa models with different sizes on the GLUE development set. 
    }
    \label{tab:xxlarge}
\end{table*}

\begin{table*}[htb!]
    \centering
    \begin{tabular}{@{\hskip1pt}l|c| c| c| c}
    \toprule
        \bf Model&Parameters &{MNLI-m/mm}& {SQuAD v1.1} &{SQuAD v2.0} \\ 
          &\ &  Acc& F1/EM & F1/EM  \\ \hline
        
        RoBERTa-ReImp & 120M & 84.9/85.1 & 91.1/84.8 &79.5/76.0  \\ 
        \hline
        DeBERTa & 134M& 86.3/86.2 &92.1/86.1 & 82.5/79.3  \\
        + ShareProjection & 120M & 86.3/86.3 &92.2/86.2 & 82.3/79.5  \\
        + Conv & 122M & 86.3/86.5 &92.5/86.4 & 82.5/79.7  \\
        + 128k Vocab & 190M & 86.7/86.9 &93.1/86.8 & 83.0/80.1  \\
       \bottomrule
        \end{tabular}
    \caption{
    Ablation study of the additional modifications in DeBERTa and DeBERTa models. Note that we progressively add each component on the top of DeBERTa\textsubscript{base}. 
    }
    \label{tab:v2}
\end{table*}

\subsection{Model complexity}
With the disentangled attention mechanism, we introduce three additional sets of parameters  and . The total increase in model parameters is . For the large model , this amounts to about  additional parameters, an increase of . 
For the base model, this amounts to  additional parameters, an increase of . 
However, by sharing the projection matrix between content and position embedding, i.e.  , the number of parameters of DeBERTa is the same as RoBERTa. 
Our experiment on base model shows that the results are almost the same, as in Table~\ref{tab:v2}. 




The additional computational complexity is  due to the calculation of the additional \textit{position-to-content} and \textit{content-to-position} attention scores. 
Compared with BERT or RoBERTa, this increases the computational cost by . 
Compared with XLNet which also uses relative position embedding, the increase of computational cost is about . 
A further optimization by fusing the attention computation kernel can significantly reduce this additional cost. 
For , since the decoder in pre-training only reconstructs the masked tokens, it does not introduce additional computational cost for unmasked tokens. 
In the situation where  tokens are masked and we use only two decoder layers, 
the additional cost is  which results in an additional computational cost of only  for base model() and  for large model() in EMD. 


\subsection{Additional Details of Enhanced Mask Decoder}

The structure of EMD is shown in Figure~\ref{fig:emd-b}. There are two inputs for EMD, (i.e., ).  
 denotes the hidden states from the previous Transformer layer, and  can be any necessary information for decoding, e.g., , absolute position embedding or output from previous EMD layer. 
 denotes  stacked layers of EMD where the output of each EMD layer will be the input  for next EMD layer and the output of last EMD layer will be fed to the language model head directly. 
The  layers can share the same weight. 
In our experiment we share the same weight for  layers to reduce the number of parameters and use absolute position embedding as  of the first EMD layer. 
When  and , EMD is the same as the BERT decoder layer. 
However, EMD is more general and flexible as it can take various types of input information for decoding.

\begin{figure}[]
\centering  
\subfloat[BERT decoding layer]{
    \includegraphics[trim={0.5mm 0.5mm 0.5mm 0.5mm},clip,width=0.35\linewidth]{figures/Model_BERT_S.pdf}
    \label{fig:bert-a}
}
\hfill
\subfloat[Enhanced Mask Decoder]{
    \includegraphics[trim={0.5mm 0.5mm 0.5mm 0.5mm},clip,width=0.58\linewidth]{figures/Model_EMD_S.pdf}
    \label{fig:emd-b}
}

\caption{Comparison of the decoding layer.}
\label{fig:emd}
\end{figure}

\subsection{Attention Patterns}
\label{subsec:attention}


\begin{figure}[htb!]
\centering 
\includegraphics[width=1\linewidth]{figures/attention_map_02_v3_1.png}
\caption{Comparison  of attention patterns of the last layer among DeBERTa, RoBERTa and  DeBERTa variants (i.e., DeBERTa without EMD, C2P and P2C respectively). }
\label{fig:att-map}
\end{figure}

To visualize how DeBERTa operates differently from RoBERTa, we present in Figure~\ref{fig:att-map} the attention patterns (taken in the last self-attention layers) of RoBERTa, DeBERTa and three DeBERTa variants.
We observe two differences. 
First, RoBERTa has a clear diagonal line effect for a token  attending to itself. But this effect is not very visible in {\ModelName}. 
This can be attributed to the use of EMD, in which the absolute position embedding is added to the hidden state of content as the query vector,
as verified by the attention pattern of DeBERTa-EMD where the diagonal line effect is more visible  
than that of the original {\ModelName}. 
Second, we observe vertical strips in the attention patterns of RoBERTa, which are mainly caused by high-frequent functional words or tokens (e.g., ``a'', ``the'', and punctuation). 
For {\ModelName}, the strip only appears in the first column, which represents the \texttt{[CLS]} token. 
We conjecture that a dominant emphasis on \texttt{[CLS]} is desirable since the feature vector of \texttt{[CLS]} is often used as a contextual representation of the entire input sequence in downstream tasks. 
We also observe that the vertical strip effect is quite obvious in the patterns of the three {\ModelName} variants. 

We present three additional examples to illustrate the different attention patterns of {\ModelName} and RoBERTa in Figures~\ref{fig:att-01} and~\ref{fig:att}.  
\begin{figure}[htb!]
\centering 
\subfloat[]{
\includegraphics[width=0.65\linewidth]{figures/attention_map_02_1.png}
}
\vfill
\subfloat[]{
\includegraphics[width=0.65\linewidth]{figures/attention_map_04_1.png}
}
\vfill
\subfloat[]{
\includegraphics[width=0.65\linewidth]{figures/attention_map_03_1.png}
}
\caption{Comparison  on attention patterns of the last layer between DeBERTa and RoBERTa.   }
\label{fig:att-01}
\end{figure}

\clearpage

\begin{figure}[htb!]
\centering 
\subfloat[]{
\includegraphics[width=0.98\linewidth]{figures/attention_map_06_1.png}
\label{a1}
}
\vfill
\subfloat[]{
\includegraphics[width=0.98\linewidth]{figures/attention_map_07_1.png}
\label{a2}
}
\vfill
\subfloat[]{
\includegraphics[width=0.98\linewidth]{figures/attention_map_05_1.png}
\label{a3}
}
\caption{Comparison  on attention patterns of last layer between DeBERTa and its variants (i.e. DeBERTa without EMD, C2P and P2C respectively).}
\label{fig:att}
\end{figure}


\subsection{Account for the Variance in Fine-Tuning}
Accounting for the variance of different runs of fine-tuning, in our experiments, we always follow ~\cite{liu2019roberta} to report the results on downstream tasks by averaging over five runs with different random initialization seeds, and perform significance test when comparing results.  
As the examples shown in Table~\ref{tab:var}, DeBERTa significantly outperforms RoBERTa (-value < 0.05).

\begin{table}[ht]
    \centering
    \begin{tabular}{l | c | c | c}
    \toprule
    Model & MNLI-matched (Min/Max/Avg)&  SQuAD v1.1 (Min/Max/Avg) & -value\\ \hline
    RoBERTa &84.7/85.0/84.9 &90.8/91.3/91.1 & 0.02\\ \hline      
    DeBERTa &86.1/86.5/86.3 &91.8/92.2/92.1 & 0.01\\
    \bottomrule
    \end{tabular}
    \caption{Comparison of DeBERTa and RoBERTa on MNLI-matched and SQuAD v1.1. }
    \label{tab:var}
\end{table}



 \end{document}
