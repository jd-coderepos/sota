\documentclass[11pt,a4paper]{article}

\usepackage{amsmath}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{xspace}
\usepackage{graphicx}
\usepackage{url}
\usepackage{subfigure}
\usepackage{mdwlist}
\usepackage{courier}
\usepackage{lscape}
\usepackage{comment}
\usepackage{wrapfig}
\usepackage{multirow}
\usepackage{bussproofs}
\usepackage{pdftricks}
\usepackage{subfigure}
\begin{psinputs}
\usepackage{pstricks}
\usepackage{color}
\usepackage{pstcol}
\usepackage{pst-plot}
\usepackage{pst-tree}
\usepackage{pst-eps}
\usepackage{multido}
\usepackage{pst-node}
\usepackage{pst-eps}
\end{psinputs}
\usepackage{cite}
\makeatletter
\newif\if@restonecol
\makeatother
\let\algorithm\relax
\let\endalgorithm\relax
\usepackage{footmisc}
\usepackage{balance}
\usepackage{enumerate}
\usepackage[normalem]{ulem}
\usepackage{hyperref}
\usepackage{alltt}

\usepackage{epsfig}
\usepackage{manfnt}
\usepackage{graphicx}
\usepackage{color}
\usepackage{multirow}
\usepackage{tabularx,colortbl}
\usepackage{alltt}
\usepackage{bussproofs}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{pifont}
\usepackage{cancel}
\usepackage{rotating}

\usepackage{float,lipsum}
\floatstyle{boxed}
\restylefloat{table}
\restylefloat{figure} \newcommand{\mcmt}{{\sc mcmt}\xspace}
\newcommand{\mcmtd}{\xspace}
\newcommand{\tran}[1]{\ensuremath{\buildrel #1\over\longleftarrow}}
\newcommand{\arco}[1]{\ensuremath{\buildrel #1\over\longrightarrow}}
\newcommand{\arcos}[1]{\ensuremath{\buildrel #1\over\longrightarrow_+}}
\newcommand{\model}{\ensuremath{\zeta}\xspace}


\newcommand{\diff}{\ensuremath{\mathtt{diff}}}
\newcommand{\ARRAY}{\ensuremath{\mathtt{ARRAY}}\xspace}
\newcommand{\INDEX}{\ensuremath{\mathtt{INDEX}}\xspace}
\newcommand{\ELEM}{\ensuremath{\mathtt{ELEM}}\xspace}
\newcommand{\formulae}{formul\ae\xspace}
\newcommand{\unc}{\ensuremath{v}\xspace}
\newcommand{\fresh}{\ensuremath{z}\xspace}
\newcommand{\EQSYMBOL}{=}
\newcommand{\TILDE}{\sim}
\newcommand{\TARRAY}{\ensuremath{\ARRAY^{\TILDE}}}
\newcommand{\EQINDEX}{\ensuremath{\INDEX^{\EQSYMBOL}}}
\newcommand{\EQELEM}{\ensuremath{\ELEM^{\EQSYMBOL}}}
\newcommand{\EQARRAY}{\ensuremath{\ARRAY^{\EQSYMBOL}}}
\newcommand{\EQP}{\ensuremath{\mathcal{P}^{\EQSYMBOL}}}

\newcommand{\LRA}{\ensuremath{\mathcal{LRA}}\xspace}
\newcommand{\EUF}{\ensuremath{\mathcal{EUF}}\xspace}
\newcommand{\LIA}{\ensuremath{\mathcal{LIA}}\xspace}
\newcommand{\IDL}{\ensuremath{\mathcal{IDL}}\xspace}
\newcommand{\AX}{\ensuremath{\mathcal{AX}}\xspace}
\newcommand{\BAX}{\ensuremath{\mathcal{BAX}}\xspace}
\newcommand{\AXEXT}{\ensuremath{\mathcal{AX}_{{\rm ext}}}\xspace}
\newcommand{\AXDIFF}{\ensuremath{\AX_{\diff}}\xspace}
\newcommand{\T}{\ensuremath{\mathcal{T}}\xspace}

\newcommand{\clauseorange}[1]{\colorbox{yellow}{#1}}
\newcommand{\clausered}[1]{\colorbox{red}{#1}}
\newcommand{\clauseblue}[1]{\colorbox{blue}{\textcolor{white}{#1}}}
\newcommand{\clausegreen}[1]{\colorbox{green}{#1}}
\newcommand{\clausemagenta}[1]{\colorbox{magenta}{#1}}

\newcommand{\boxclause}[1]{\box{#1}}

\newcommand{\neglit}{\overline}

\newcommand{\Pivs}{s}
\newcommand{\Pivt}{t}
\newcommand{\Cthree}{E}
\newcommand{\Ctwo}{D}
\newcommand{\Cone}{C}

\newcommand{\s}[1]{\,#1\,}
\newcommand{\ds}[1]{\,\,\,#1\,\,\,}
\newcommand{\tfont}[1]{\mathit{#1}}

\newcommand{\showcite}[1]{\cite{#1}}
\newcommand{\todo}[1]{\fbox{\textcolor{red}{{\bf TODO}: #1}}}

\newcommand{\assign}{\ensuremath{:=}\xspace}

\newcommand{\bv}[2]{\ensuremath{{#1}_{[#2]}}}
\newcommand{\bitvector}{bit-vector\xspace}
\newcommand{\bitvectors}{bit-vectors\xspace}

\newcommand{\bvextr}[3]{\ensuremath{#1[#2:#3]}}
\newcommand{\bvconc}[2]{\ensuremath{#1\,::\,#2}}

\newcommand{\bvplus}[2]{\ensuremath{#1 + #2}}
\newcommand{\bvtimes}[2]{\ensuremath{#1 \cdot #2}}

\newcommand{\bvlt}[2]{\ensuremath{#1 < #2}}
\newcommand{\bvle}[2]{\ensuremath{#1 \leq #2}}

\newcommand{\bitand}[2]{\ensuremath{#1 \bitandsymb #2}}
\newcommand{\bitor}[2]{\ensuremath{#1 \bitorsymb #2}}
\newcommand{\bitnot}[1]{\ensuremath{\bitnotsymb #1}}

\newcommand{\bitandsymb}{\ensuremath{\&}}
\newcommand{\bitorsymb}{\ensuremath{|}}
\newcommand{\bitnotsymb}{\ensuremath{!}}

\newcommand{\tbv}{\ensuremath{\mathcal{BV}}\xspace}
\newcommand{\tbvc}{\ensuremath{\tbv_{C}}\xspace}
\newcommand{\tbva}{\ensuremath{\tbv_{A}}\xspace}
\newcommand{\tbvb}{\ensuremath{\tbv_{B}}\xspace}
\newcommand{\tbvcuf}{\ensuremath{(\tbv_{C}\cup\mathcal{UF})}\xspace}
\newcommand{\te}{\ensuremath{\mathcal{E}}\xspace}

\newcommand{\BVTerm}{\ensuremath{\tbv\mbox{-Term}}\xspace}
\newcommand{\BVTerms}{\ensuremath{\tbv\mbox{-Terms}}\xspace}
\newcommand{\BVAtom}{\ensuremath{\tbv\mbox{-Atom}}\xspace}
\newcommand{\BVAtoms}{\ensuremath{\tbv\mbox{-Atoms}}\xspace}
\newcommand{\BVLit}{\ensuremath{\tbv\mbox{-Literal}}\xspace}
\newcommand{\BVLits}{\ensuremath{\tbv\mbox{-Literals}}\xspace}

\newcommand{\TTerm}{\ensuremath{\T\mbox{-Term}}\xspace}
\newcommand{\TTerms}{\ensuremath{\T\mbox{-Terms}}\xspace}
\newcommand{\TAtom}{\ensuremath{\T\mbox{-Atom}}\xspace}
\newcommand{\BAtom}{\ensuremath{\mathcal{B}\mbox{-Atom}}\xspace}
\newcommand{\TAtoms}{\ensuremath{\T\mbox{-Atoms}}\xspace}
\newcommand{\TLit}{\ensuremath{\T\mbox{-Literal}}\xspace}
\newcommand{\TLits}{\ensuremath{\T\mbox{-Literals}}\xspace}
\newcommand{\TFormula}{\ensuremath{\T\mbox{-Formula}}\xspace}

\newcommand{\Tsolve}{\tsolver}
\newcommand{\tsolver}{\ensuremath{\mathcal{T}\mbox{-solver}}\xspace}
\newcommand{\tsolvers}{\ensuremath{\mathcal{T}\mbox{-solvers}}\xspace}
\newcommand{\bvsolver}{\ensuremath{\mathcal{BV}\mbox{-solver}}\xspace}
\newcommand{\bvsolvers}{\ensuremath{\mathcal{BV}\mbox{-solvers}}\xspace}
\newcommand{\eufsolver}{\ensuremath{\mathcal{EUF}\mbox{-solver}}\xspace}
\newcommand{\eufsolvers}{\ensuremath{\mathcal{EUF}\mbox{-solvers}}\xspace}
\newcommand{\dlsolver}{\ensuremath{\mathcal{DL}\mbox{-solver}}\xspace}
\newcommand{\dlsolvers}{\ensuremath{\mathcal{DL}\mbox{-solvers}}\xspace}
\newcommand{\smt}{SMT\xspace}
\newcommand{\smtt}{SMT\ensuremath{(\T)}\xspace}
\newcommand{\smteuf}{SMT\ensuremath{\mathit{(\euf)}}\xspace}
\newcommand{\smtbv}{SMT\ensuremath{\mathit{(\tbv)}}\xspace}
\newcommand{\smtdl}{SMT\ensuremath{\mathit{(\dl)}}\xspace}
\newcommand{\smtla}{SMT\ensuremath{\mathit{(\la)}}\xspace}
\newcommand{\smtlia}{SMT\ensuremath{\mathit{(\lia)}}\xspace}
\newcommand{\smtlra}{SMT\ensuremath{\mathit{(\lra)}}\xspace}
\newcommand{\smttt}[1]{SMT\ensuremath{(#1)}\xspace}
\newcommand{\smttonettwo}{SMT\ensuremath{(\tonetwo)}\xspace}
\newcommand{\dec}{Dec\xspace}
\newcommand{\dect}{Dec\ensuremath{(\T)}\xspace}
\newcommand{\decbv}{Dec\ensuremath{\mathit{(\tbv})}\xspace}
\newcommand{\declaint}{Dec\ensuremath{\mathit{(\laint)}}\xspace}
\newcommand{\dectt}[1]{Dec\ensuremath{(#1)}\xspace}
\newcommand{\dectonettwo}{Dec\ensuremath{(\tonetwo)}\xspace}
\newcommand{\DecT}[1]{\ensuremath{\mathit{Dec(}{#1}\mathit{)}}\xspace}
\newcommand{\DecTpos}[1]{\ensuremath{\mathit{Dec}^+\mathit{(}{#1}\mathit{)}}\xspace}

\newcommand{\DPe}[1]{\ensuremath{DP^=(#1)}}
\newcommand{\DP}[1]{\ensuremath{DP(#1)}}

\newcommand{\coarser}{\preceq}

\newcommand{\boolabs}[1]{\alpha(#1)}

\renewcommand{\iff}{\Leftrightarrow}
\newcommand{\imp}{\Rightarrow}
\newcommand{\range}[2]{\ensuremath{(0\le #1)\wedge (#1< 2^{#2})}}
\newcommand{\simplify}{{\sc Simplify}\xspace}
\newcommand{\opensmt}{{\sc OpenSMT}\xspace}
\newcommand{\opensmtcbe}{{\sc OpenSMT\_CBE}\xspace}
\newcommand{\opensmtbb}{{\sc OpenSMT\_BB}\xspace}
\newcommand{\mathsat}{{\sc MathSAT}\xspace}
\newcommand{\minisat}{{\sc MiniSAT}\xspace}
\newcommand{\cvctre}{{\sc CVC3}\xspace}
\newcommand{\yices}{{\sc Yices}\xspace}
\newcommand{\ztre}{{\sc Z3}\xspace}
\newcommand{\boolector}{{\sc Boolector}\xspace}
\newcommand{\beaver}{{\sc Beaver}\xspace}
\newcommand{\bat}{{\sc BAT}\xspace}
\newcommand{\spear}{{\sc Spear}\xspace}
\newcommand{\stp}{{\sc MathSAT}\xspace}

\newcommand{\bool}[1]{\ensuremath{\foltoprop(#1)}}

\newcommand{\BoolGen}[1]{\ensuremath{\mathsf{Bool+}{#1}}\xspace}
\newcommand{\BoolT}{\BoolGen{T}}
\newcommand{\proptofol}{\ensuremath{\mathit{Bool2\T}}\xspace}
\newcommand{\foltoprop}{\ensuremath{\T2Bool}\xspace}
\newcommand{\TsatisfiableGen}[1]{\ensuremath{{#1}\textit{-satisfiable}}\xspace}
\newcommand{\Tsatisfiable}{\TsatisfiableGen{T}}
\newcommand{\Psatisfiable}{\TsatisfiableGen{\mathsf{Bool}}}
\newcommand{\picktotalassign}{\ensuremath{\mathit{pick\_total\_assign}}\xspace}
\newcommand{\satres}{\ensuremath{\mathsf{sat}}\xspace}
\newcommand{\unsatres}{\ensuremath{\mathsf{unsat}}\xspace}
\newcommand{\analyzeconflict}{\ensuremath{\mathit{analyze\_conflict}}\xspace}
\newcommand{\analyzededuction}{\ensuremath{\mathit{deduce\&learn}}\xspace}
\newcommand{\backtrack}{\ensuremath{\mathit{backjump\&learn}}\xspace}
\newcommand{\learn}{\ensuremath{\mathit{learn}}\xspace}
\newcommand{\conflict}{\ensuremath{\pi^p}\xspace}
\newcommand{\deduction}{\ensuremath{\pi^p}\xspace}
\newcommand{\reasons}{\ensuremath{\Gamma^p}\xspace}
\newcommand{\currentstack}{\ensuremath{\beta^p}\xspace}
\newcommand{\currentinterp}{\ensuremath{\beta^p}\xspace}
\newcommand{\bcp}{\ensuremath{\textup{BCP}}\xspace}
\newcommand{\preprocess}{\ensuremath{\mathit{Preprocess}}\xspace}
\newcommand{\blevel}{\ensuremath{\mathit{no\_open\_branches}}\xspace}
\newcommand{\decidebranch}{\ensuremath{\mathit{decide\_new\_branch}}\xspace}
\newcommand{\cala}{\ensuremath{\mathcal{A}}\xspace}
\newcommand{\atoms}{\ensuremath{\mathit{Atoms}}}
\newcommand{\tatoms}{\ensuremath{\mathcal{T}\mbox{-atoms}}\xspace}
\newcommand{\tatom}{\ensuremath{\mathcal{T}\mbox{-atom}}\xspace}
\newcommand{\tlit}{\ensuremath{\mathcal{T}\mbox{-literal}}\xspace}
\newcommand{\tlits}{\ensuremath{\mathcal{T}\mbox{-literals}}\xspace}
\newcommand{\eufatoms}{\ensuremath{\mathcal{EUF}\mbox{-atoms}}\xspace}
\newcommand{\eufatom}{\ensuremath{\mathcal{EUF}\mbox{-atom}}\xspace}
\newcommand{\dlatoms}{\ensuremath{\mathcal{DL}\mbox{-atoms}}\xspace}
\newcommand{\dlatom}{\ensuremath{\mathcal{DL}\mbox{-atom}}\xspace}
\newcommand{\bvatoms}{\ensuremath{\mathcal{BV}\mbox{-atoms}}\xspace}
\newcommand{\bvatom}{\ensuremath{\mathcal{BV}\mbox{-atom}}\xspace}
\newcommand{\Tconsequence}{\ensuremath{\mathcal{T}\mbox{-consequence}}\xspace}
\newcommand{\Tconsequences}{\ensuremath{\mathcal{T}\mbox{-consequences}}\xspace}
\newcommand{\tconsequence}{\ensuremath{\mathcal{T}\mbox{-consequence}}\xspace}
\newcommand{\tconsequences}{\ensuremath{\mathcal{T}\mbox{-consequences}}\xspace}
\newcommand{\eufconsequence}{\ensuremath{\mathcal{EUF}\mbox{-consequence}}\xspace}
\newcommand{\eufconsequences}{\ensuremath{\mathcal{EUF}\mbox{-consequences}}\xspace}
\newcommand{\dlconsequence}{\ensuremath{\mathcal{DL}\mbox{-consequence}}\xspace}
\newcommand{\dlconsequences}{\ensuremath{\mathcal{DL}\mbox{-consequences}}\xspace}
\newcommand{\bvconsequence}{\ensuremath{\mathcal{BV}\mbox{-consequence}}\xspace}
\newcommand{\bvconsequences}{\ensuremath{\mathcal{BV}\mbox{-consequences}}\xspace}
\newcommand{\dpll}[1]{{\sc DPLL}\xspace}
\newcommand{\Atm}{{\ensuremath{\mathit{Atoms}}}}
\newcommand{\euf}{\ensuremath{\mathcal{EUF}}\xspace}
\newcommand{\arr}{\ensuremath{\mathcal{A}}\xspace}
\newcommand{\e}{\ensuremath{\mathcal{E}}\xspace}
\newcommand{\dl}{\ensuremath{\mathcal{DL}}\xspace}
\newcommand{\la}{\ensuremath{\mathcal{LA}}\xspace}
\newcommand{\rat}{\ensuremath{\mathit{Rat}}\xspace}
\newcommand{\larat}{\ensuremath{\mathcal{LRA}}\xspace}
\newcommand{\laint}{\ensuremath{\mathcal{LIA}}\xspace}
\newcommand{\lia}{\ensuremath{\mathcal{LIA}}\xspace}
\newcommand{\mia}{\ensuremath{\mathcal{MIA}}\xspace}
\newcommand{\lra}{\ensuremath{\mathcal{LRA}}\xspace}
\newcommand{\Vars}[1]{{\ensuremath\mathit{Var}(#1)}}

\newcommand{\wordcast}[1]{{\wordcastsymb\texttt{(}#1\texttt{)}}}
\newcommand{\boolcast}[1]{{\texttt{bool(}#1\texttt{)}}}
\newcommand{\wordcastsymb}{\texttt{word1}}

\newcommand{\ITE}[3]{\ensuremath{\mbox{ITE}(#1, #2, #3)}}
\newcommand{\TITE}[3]{\ensuremath{\TITEsymb(#1, #2, #3)}}
\newcommand{\BITE}[3]{\ensuremath{\BITEsymb(#1, #2, #3)}}
\newcommand{\TITEsymb}{\ensuremath{\mbox{TITE}}\xspace}
\newcommand{\BITEsymb}{\ensuremath{\mbox{BITE}}\xspace}
\newcommand{\rew}{\ensuremath{\Rightarrow}}
\newcommand{\binconst}[1]{#1}
\newcommand{\vi}{{\ensuremath{\varphi}}\xspace}

\newcommand{\sm}[1]{SMT(#1)\xspace}

\newcommand{\floor}[1]{\ensuremath{\lfloor#1\rfloor}\xspace}

\newcommand{\LSHF}[1]{\ensuremath{\mbox{ LSH}(#1)}}
\newcommand{\RSHF}[1]{\ensuremath{\mbox{ RSH}(#1)}}
\newcommand{\AND}{\ensuremath{\mbox{ AND }}}
\newcommand{\OR}{\ensuremath{\mbox{ OR }}}
\newcommand{\XOR}{\ensuremath{\mbox{ XOR }}}
\newcommand{\NOT}{\ensuremath{\mbox{ NOT }}}
\newcommand{\ADDER}{\ensuremath{\mbox{ ADDER }}}
\newcommand{\MULT}[1]{\ensuremath{\mbox{ MULT}(#1)}}
\newcommand{\EQUAL}{\ensuremath{\mbox{ EQUAL }}}
\newcommand{\LEQ}{\ensuremath{\mbox{ LEQ }}}
\newcommand{\CONCAT}{\ensuremath{\mbox{ CONCAT }}}
\newcommand{\SELECT}[2]{\ensuremath{\mbox{ SELECT}[#1:#2]}}
\newcommand{\MUX}{\ensuremath{\mbox{ MUX }}}

\newcommand{\tracetolia}{\ensuremath{\eta}}

\newcommand{\irule}[2]{\ensuremath{#1 \ \| \ #2}}
\newcommand{\sep}{\ensuremath{\ | \ }}
\newcommand{\sepi}{\ensuremath{\rhd}\xspace}
\newcommand{\ifirule}[3]{\ensuremath{#1 \ \| \ #2 \ \mbox{ if } #3}}
\newcommand{\inA}[1]{\ensuremath{\lfloor #1 \rfloor_A}}
\newcommand{\inB}[1]{\ensuremath{\lfloor #1 \rfloor_B}}
\newcommand{\inX}[1]{\ensuremath{\lfloor #1 \rfloor_X}}

\newcommand{\normalize}[1]{\ensuremath{#1\downarrow}}
\newcommand{\rinfer}[3]{\ensuremath{\infer[#1]{#3}{#2}}}

\newcommand{\zchaff}{{\sc zChaff}\xspace}

\newcommand{\satsolver}{SAT-Solver\xspace}
\newcommand{\satsolvers}{SAT-Solvers\xspace}
\newcommand{\smtsolver}{SMT-Solver\xspace}
\newcommand{\smtsolvers}{SMT-Solvers\xspace}

\newcommand{\smteufut}{\ensuremath{SMT(\euf \cup \T)}}

\newcommand{\Lbrack}{\ensuremath{[\mspace{-3mu}[}}
\newcommand{\Rbrack}{\ensuremath{]\mspace{-3mu}]}}

\newcommand{\inter}[2]{\ensuremath{\Lbrack #1 \Rbrack^#2}}

\newcommand{\coarsest}[1]{\ensuremath{cs(#1)}}

\newcommand{\simp}[1]{\ensuremath{\sigma(#1)}}



\newcommand{\algfunc}{{\bf function}\xspace}
\newcommand{\algvar}{{\bf var}\xspace}
\newcommand{\algif}{{\bf if}\xspace}
\newcommand{\algforeach}{{\bf foreach}\xspace}
\newcommand{\algfor}{{\bf for}\xspace}
\newcommand{\algthen}{{\bf then}\xspace}
\newcommand{\algelse}{{\bf else}\xspace}
\newcommand{\algelseif}{{\bf elseif}\xspace}
\newcommand{\algend}{{\bf end}\xspace}
\newcommand{\algret}{{\bf return}\xspace}
\newcommand{\algand}{{\bf and}\xspace}
\newcommand{\algor}{{\bf or}\xspace}
\newcommand{\algwhile}{{\bf while}\xspace}

\newcommand{\pair}[2]{\ensuremath{\langle #1, #2 \rangle}}

\newcommand{\enode}{\emph{enode}\xspace}
\newcommand{\enodes}{\emph{enodes}\xspace}
\newcommand{\egraph}{\emph{egraph}\xspace}

\newcommand{\paper}[2]{#1}
\newcommand{\report}[2]{#2}

\newcommand{\footnoteremember}[2]
{
  \footnote{#2}
  \newcounter{#1}
  \setcounter{#1}{\value{footnote}}
}
\newcommand{\footnoterecall}[1]
{
  \footnotemark[\value{#1}]
}

\newcommand{\resolution}{\otimes}

\newcommand{\COMMENT}[1]{}

\newcommand{\alocal}{\ensuremath{A}-local\xspace}
\newcommand{\blocal}{\ensuremath{B}-local\xspace}
\newcommand{\astrict}{\ensuremath{A}-strict\xspace}
\newcommand{\bstrict}{\ensuremath{B}-strict\xspace}
\newcommand{\abcommon}{\ensuremath{AB}-common\xspace}
\newcommand{\abpure}{\ensuremath{AB}-pure\xspace}
\newcommand{\abmixed}{\ensuremath{AB}-mixed\xspace}
\newcommand{\correction}[2]{\sout{#1} \textcolor{red}{#2}}
\newcommand{\st}{\; \vert \;}
\newcommand{\idx}[2][i]{\ensuremath {#1 \in \{1,\ldots,\mbox{}\}}}
\newcommand{\ual}{\ensuremath{\underline {\alpha}}}
\newcommand{\ube}{\ensuremath{\underline {\beta}}}
\newcommand{\ua}{\ensuremath{\underline a}}
\newcommand{\ub}{\ensuremath{\underline b}}
\newcommand{\uc}{\ensuremath{\underline c}}
\newcommand{\ud}{\ensuremath{\underline d}}
\newcommand{\ue}{\ensuremath{\underline e}}
\newcommand{\ug}{\ensuremath{\underline g}}
\newcommand{\uh}{\ensuremath{\underline h}}
\newcommand{\ui}{\ensuremath{\underline i}}
\newcommand{\uj}{\ensuremath{\underline j}}
\newcommand{\uk}{\ensuremath{\underline k}}
\newcommand{\ut}{\ensuremath{\underline t}}
\newcommand{\ux}{\ensuremath{\underline x}}
\newcommand{\uu}{\ensuremath{\underline u}}
\newcommand{\uU}{\ensuremath{\underline U}}
\newcommand{\uF}{\ensuremath{\underline F}}
\newcommand{\uH}{\ensuremath{\underline H}}
\newcommand{\uy}{\ensuremath{\underline y}}
\newcommand{\uz}{\ensuremath{\underline z}}
\newcommand{\us}{\ensuremath{\underline s}}
\newcommand{\ul}{\ensuremath{\underline l}}
\newcommand{\up}{\ensuremath{\underline p}}
\newcommand{\cA}{\ensuremath \mathcal A}
\newcommand{\cB}{\ensuremath \mathcal B}
\newcommand{\cM}{\ensuremath \mathcal M}
\newcommand{\cN}{\ensuremath \mathcal N}
\newcommand{\cT}{\ensuremath \mathcal T}
\newcommand{\cS}{\ensuremath \mathcal S}
\newcommand{\cC}{\ensuremath \mathcal C}
\newcommand{\cL}{\ensuremath \mathcal L}
\newcommand{\cV}{\ensuremath \mathcal V}
\newcommand{\cP}{\ensuremath \mathcal P}
\newcommand{\cF}{\ensuremath \mathcal F}
\newcommand{\cI}{\ensuremath \mathcal I}
\newcommand{\cJ}{\ensuremath \mathcal J}
\newcommand{\aze}{\ensuremath T^I_E}
\newcommand{\lnext}{\ensuremath X}
\newcommand{\lbox}{\ensuremath \Box}
\newcommand{\ldiamond}{\ensuremath \Diamond}
\newcommand{\luntil}{\ensuremath U}
\newcommand{\lrelease}{\ensuremath R}
\newcommand{\ltl}{LTL}
\newcommand{\ltlt}{\ltl(\ensuremath {\mathcal T})}
\newcommand{\dpllt}{\textit{DPLL}(\ensuremath {\mathcal T})}
\newcommand{\ltlfor}{\ltl()}
\newcommand{\ltlforci}{\ltl()}
\newcommand{\ltlforc}{\ltl()}
\newcommand{\abstr}[1][\varphi]{\ensuremath {\lbrack\!\lbrack\, #1 \,\rbrack\!\rbrack}}
\renewcommand{\int}{\ensuremath {\mathcal I}}
\newcommand{\closure}{\ensuremath {cl}}
\newcommand{\pre}[1][T]{\ensuremath {Res_{#1}}}
\newcommand{\disjcup}{\ensuremath \oplus}
\newcommand{\bigdisjcup}{\ensuremath \bigoplus}
\newcommand{\sysset}{\ensuremath {\langle \Sigma, T, \Sigma_r, \ua, \uc \rangle}}
\newcommand{\sysspec}{\ensuremath {(\mathcal T, \delta, \iota)}}
\newcommand{\satproc}{\textit{``satisfiable''}}
\newcommand{\unsatproc}{\textit{``unsatisfiable''}}
\newcommand{\prename}{residue enumerator}
\newcommand{\pbename}{\prename}
\newcommand{\secname}{Section~}
\newcommand{\theory}{dataflow theory}\newcommand{\theories}{dataflow theories}\renewcommand{\sp}{\ensuremath{\mathcal{SP}}}
\newcommand{\Tcon}{-constraint\ }
\newcommand{\Tcons}{-constraints\ }
\newcommand{\mywidehat}[1]{\ensuremath{\lbrack\!\lbrack #1 \rbrack\!\rbrack}}
\newcommand{\myparagraph}[1]{\noindent \textbf{#1}}
\newcommand{\rbcomment}[1]{\textcolor{blue}{[RB: #1]}}
\newcommand{\facomment}[1]{\textcolor{cyan}{[FA: #1]}}
\newcommand{\sgcomment}[1]{\textcolor{red}{[SG: #1]}}
\newcommand{\srcomment}[1]{\textcolor{red}{[SR: #1]}}
\newcommand{\nscomment}[1]{\textcolor{black}{[NS: #1]}}
\newcommand{\algoname}{Algorithm}

\newcommand{\sindex}{\ensuremath{{\tt INDEX}}\xspace}
\newcommand{\sint}{\ensuremath{{\tt INT}}\xspace}
\newcommand{\sarray}{\ensuremath{{\tt ARRAY}}\xspace}
\newcommand{\sarrayl}{\ensuremath{{\tt ARRAY}_{\ell}}\xspace}
\newcommand{\sarraylh}{\ensuremath{{\tt ARRAY}_{\ell_h}}\xspace}
\newcommand{\sarraylk}{\ensuremath{{\tt ARRAY}_{\ell_k}}\xspace}
\newcommand{\selem}{\ensuremath{{\tt ELEM}}\xspace}
\newcommand{\seleml}{\ensuremath{{\tt ELEM}_{\ell}}\xspace}
\newcommand{\selemlp}{\ensuremath{{\tt ELEM}_{\ell'}}\xspace}

\def\Examplesize{\fontsize{8pt}{8pt}\selectfont}


\newcommand{\ta}{\ensuremath{{\bf a}}\xspace}
\newcommand{\tc}{\ensuremath{{\bf c}}\xspace}
\newcommand{\td}{\ensuremath{{\bf d}}\xspace}
\newcommand{\tv}{\ensuremath{{\bf v}}\xspace}
\newcommand{\tb}{\ensuremath{{\bf b}}\xspace}
\newcommand{\tk}{\ensuremath{{\bf k}}\xspace}
\newcommand{\tf}{\ensuremath{{\bf f}}\xspace}
\newcommand{\tte}{\ensuremath{{\bf e}}\xspace}
\newcommand{\tr}{\ensuremath{{\bf r}}\xspace}
\newcommand{\tts}{\ensuremath{{\bf s}}\xspace}
\newcommand{\tw}{\ensuremath{{\bf w}}\xspace}
\newcommand{\tu}{\ensuremath{{\bf u}}\xspace}
\newcommand{\ttb}{\ensuremath{{\bf t}}\xspace}
\newcommand{\tU}{\ensuremath{{\bf U}}\xspace}
\newcommand{\tF}{\ensuremath{{\bf F}}\xspace}
\newcommand{\tH}{\ensuremath{{\bf H}}\xspace}
\newcommand{\ti}{\ensuremath{{\bf i}}\xspace}
\newcommand{\tx}{\ensuremath{{\bf x}}\xspace}
\newcommand{\tz}{\ensuremath{{\bf z}}\xspace}

\newcommand{\fakeparagraph}[1]{\\\noindent{\em #1}}

\newcommand{\pres}{\ensuremath{{\mathbb P}}\xspace}
\newcommand{\ARR}{\ensuremath{{\mathtt{ARR}}}\xspace}
 
\usepackage{authblk}

\title{Counting Constraints in Flat Array Fragments}
\author[1]{Francesco Alberti}
\author[2]{Silvio Ghilardi}
\author[2]{Elena Pagani}

\affil[1]{ Fondazione S. Raffaele, Milano, Italy}
\affil[2]{Universit\`a degli Studi di Milano, Milano, Italy}

\newcommand{\decmono}{\ensuremath {\sf SAT}_{\sf MONO}}
\newcommand{\decmulti}{\ensuremath {\sf SAT}_{\sf MULTI}}
\newcommand{\skass}{-assignment\xspace}
\newcommand{\skasss}{-assignments\xspace}
\newcommand{\Skasss}{-assignments\xspace}
\newcommand{\flatprog}{-program\xspace}
\newcommand{\flatprogs}{-programs\xspace}
\newcommand{\zt}{{\sc Z3}\xspace}
\newcommand{\cvc}{{\sc cvc4}\xspace}
\newcommand{\simpleprog}{-program\xspace}
\newcommand{\simpleprogs}{-programs\xspace}
\newcommand{\single}{monic\xspace}
\newcommand{\Single}{Monic\xspace}

\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}

\begin{document}


\maketitle              \setcounter{footnote}{0}

\begin{abstract}
We identify a fragment of Presburger arithmetic enriched with free function symbols and cardinality constraints for interpreted sets, which is amenable to automated analysis. We establish decidability and complexity results for such a fragment and
we implement our algorithms. The experiments run in discharging proof obligations
coming from invariant checking and bounded model-checking benchmarks
show the practical feasibility of our decision procedure.
\end{abstract}


\section{Introduction} 

Enriching logic formalisms with counting capabilities is an important task in view of the needs of many application areas, ranging from database theory to formal verification. 
Such enrichments have been designed both in the description logics area and in the area of Satisfiability Modulo Theories (SMT), where some of the most important recent achievements 
were decidability
and  complexity bounds for BAPA~\cite{KunkakCADE20} - the enrichment of Presburger arithmetic with the ability of talking about finite sets and their cardinalities. 
As pointed out in~\cite{KunkakJAR}, BAPA constraints can be used for program analysis and verification by expressing data structure invariants, simulations between program fragments or termination conditions.
The analysis of BAPA constraints was successfully extended also to formalisms encompassing multisets~\cite{KunkakVMCAI08} as well as direct/inverse images 
along relations and functions~\cite{KunkakVMCAI10}.

A limitation of BAPA and its extensions lies in the fact that only uninterpreted symbols (for sets, relations, functions, etc.) are allowed. On the other hand, 
it is well-known that a different logical formalism, namely
unary counting quantifiers, can be used  in order to reason about the cardinality of definable (i.e. of interpreted) sets.  
Unary counting quantifiers can be added to Presburger arithmetic without compromising  decidability, see~\cite{schweikhart}, 
however they might be quite problematic if combined in an unlimited way with free function symbols.
In this paper, we investigate the extension of Presburger arithmetic including both counting quantifiers and uninterpreted function symbols, and we isolate fragments where we can achieve decidability and in some cases also relatively good complexity bounds. The key ingredient to isolate such fragments is the notion of flatness: roughly, in a flat formula, subterms of the kind  (where  is a free function symbol) can occur only if  is a variable. By itself, this naif flatness requirement is useless (any formula can match it to the price of introducing extra quantified variables); 
in order to make it effective, further 
 syntactic restrictions should be incorporated in it, as witnessed in~\cite{AlbertiGS14}. This is what we are going to do in  this paper, where suitable notions of `flat' and `simple flat' \formulae are introduced
 in the rich context of Presburger arithmetic enriched with free function symbols  and with unary counting quantifiers (we use free function symbols to model arrays, see below).

The fragments we design are all obviously more expressive than BAPA, but they do not come from pure logic motivations, on the contrary they are suggested by an emerging  application area, 
namely the area of verification of fault-tolerant distributed systems.
Such systems (see~\cite{zufferey} for a good account)  are modeled as partially synchronous systems, where a finite number of identical
 processes operate  in lock-step (in each \textit{round} they send messages,
receive messages, and update their local state depending on the local state at the beginning of
the round and the received messages). Messages can be lost, processes may omit to perform some tasks or also behave in a malicious way; for these reasons, 
the fact that some actions  are enabled or not, and the correctness of the algorithms themselves,  are subject to threshold conditions saying for instance  that
some qualified majority of processes are in a certain status or behave in a non-faulty way. Verifications tasks thus have to handle  cardinality constraints
of the kind studied in this paper (the reader interested in full formalization examples can directly go to Section~\ref{sec:experiments}).

The paper is organized as follows: we first present basic syntax (Section~\ref{sec:preliminaries}), then decidability (Section~\ref{sec:sat})  and complexity (Section~\ref{sec:tractable}) results; 
experiments with our prototypical implementation are supplied in Section~\ref{sec:experiments}, and  Section~\ref{sec:conclusions} concludes the work.


\section{Preliminaries}\label{sec:preliminaries}

We work within Presburger arithmetic enriched with free function symbols and cardinality constraints. This is a rather expressive logic, whose syntax is summarized in Figure~\ref{fig:syntax}.
Terms and \formulae are interpreted in the natural way over the domain of integers ; as a consequence, satisfiability of a formula  means that it is 
possible to assign values to parameters, free variables and array-ids so as to make   true in  
(validity of  means that  is not satisfiable, equivalence of  and  means that  is valid, etc.). We nevertheless implicitly assume few constraints (to be explained below) 
about our intended semantics.

To denote integer numbers, we have (besides variables and numerals) also
parameters: the latter denote unspecified integers. 
Among parameters, we always include a specific parameter (named ) 
identifying
the dimension of the system - 
alias the length of our arrays: in other words, it is assumed that for all array identifiers , the value  is  conventional 
(say, zero) outside the interval .
Although binary free function symbols are quite useful in some applications, in this paper we prefer not
to deal with them.
The operator  \emph{indicates the cardinality of the 
finite set formed by the  such that  holds}.

Notice that the cardinality constraint operator , as 
well the  quantifier , 
binds the variable ;   
below, we indicate with  (resp. ) the fact that the formula  (the term ) has free individual variables included in the list . 
When we speak of a substitution, we always mean `substitution without capture', meaning that,
when we replace the free occurrences of a variable  with a term  in a formula
 or in a term  , 
the term  should not contain free variables that might be located inside  the scope of a 
binder for them once the substitution is performed; the result of the substitution is denoted with  and .



The logic of Figure~\ref{fig:syntax} is far from being tractable, because even
the combination of  free function symbols and Presburger arithmetic lands in a highly undecidable class~\cite{halpern}. We are looking for a mild fragment, nevertheless
sufficiently expressive  for our intended applications. These applications mostly come from verification tasks, like bounded model checking or invariant checking. 
Our aim is to design a decidable fragment (so as to be able not only to produce certifications, but also to find bugs) with some minimal closure properties; from this point of view, 
notice that for bounded model checking closure under 
conjunctions is sufficient, but for invariant checking we need also closure under negations in order to discharge entailments.



\begin{figure}[t]
\centering
{\scriptsize
\begin{tabular}{lll}
 
  && numerals (numeric constants) \\ 
 
  && individual variables \\ 
    
  && parameters (free constants)
  \\
    
   && array ids
   (free unary 
   \\&& function symbols)
  \\
  
  &
  & terms
  \\
  
  &  & atoms
  \\
  
  & &formulae
\end{tabular}
}
\caption{Syntax\label{fig:syntax}}
\end{figure}


\subsection{Flat  \formulae}
We now introduce some useful subclasses
of the \formulae built up according to the grammar of Figure~\ref{fig:syntax}.
\begin{description}
  \item[-] \emph{Arithmetic \formulae}: these are built up from the  grammar of Figure~\ref{fig:syntax} without using
 neither array-ids nor cardinality constraint operators; we use letter  for
 arithmetic \formulae. Recall that, according to the well-known quantifier elimination result, arithmetic \formulae are equivalent 
 to \emph{quantifier-free} arithmetic \formulae. 
  \item[-] \emph{Constraint \formulae}: these are built up from the  grammar of Figure~\ref{fig:syntax} without using
 array-ids.
  \item[-] \emph{Basic \formulae}: these are obtained from an arithmetic formula by simultaneously replacing some free variables by terms of the kind , \emph{where  is a variable
  and  an array-id}. When we need to display full information, we may use the notation   to indicate basic \formulae. By this notation, we mean that  are variables,
 are array-ids and that  is obtained from an arithmetic formula  (where )
by replacing  with  ( and ). 
\item[-] \emph{Flat \formulae}: these are recursively defined as follows (i) basic \formulae are flat \formulae; (ii) if  is 
a flat  formula,  is a basic formula,  and  are variables, 
  then  is 
a flat formula.\footnote{ If we want to emphasize the way 
the basic formula
   is built up, 
  following the above conventions,
  we may write it as 
; here, supposing that  
   is , since  is a singleton, the tuple
   is .
  }
 \end{description}

Notice that all the above classes are closed under Boolean operations (in particular, under negations). 
The following result is proved in~\cite{schweikhart} (see also Appendix~\ref{app:counting}):

\begin{theorem}\label{thm:NS}
 For every constraint formula one can compute an arithmetic formula equivalent to it.
\end{theorem} 
 






\section{Satisfiability for flat \formulae}\label{sec:sat}

We shall show that flat \formulae are decidable for satisfiability. In fact, we shall show decidability of the slightly
larger class covered by the following

\begin{definition}
Extended flat \formulae (briefly, E-flat \formulae) are \formulae of the kind
   
where  and  are basic \formulae and  does not occur in .
\end{definition}

Notice that 
 and the  in~\eqref{eq:flatdef} above 
may contain
further free variables  (besides ) as well as the terms   and ; the  may contain occurrences of  and of .

 That 
flat \formulae are also E-flat  can be seen 
as follows: due to the fact that our substitutions avoid captures, we can use equivalences like 
   
 in order to abstract out the terms  occurring in the recursive construction of a flat  formula
 . By repeating this  
linear time transformation, we end up in a formula of the kind~\eqref{eq:flatdef}. However, not all E-flat \formulae are flat because
the dependency graph associated to~\eqref{eq:flatdef}  might not be acyclic (the graph we are talking about has the  as nodes and has
an arc  when  occurs in ). The above conversion of a flat formula into a formula of the form~\eqref{eq:flatdef} on the other hand produces an E-flat formula whose associated graph is acyclic.

  
  
  
  
We  prove a technical lemma showing how we can manipulate
E-flat \formulae without loss of generality.
Formulae 
 are said to be a partition iff the \formulae  and  (for )
are valid. Recall that the existential closure of a formula is the sentence obtained by prefixing it with a string of existential quantifiers binding all variables having a free occurrence in it.

\begin{lemma}\label{lemma:nf}
 The existential closure of an E-flat  formula  is equivalent to a sentence of the kind 
 
 where  and  are  variables,  is arithmetical, and the \formulae   are basic and form a partition.\end{lemma}

\noindent
\textit{Proof.} The differences between (the matrices of)~\eqref{eq:card} and~\eqref{eq:flatdef} are twofold: first in~\eqref{eq:card}, the  form a partition and, second, in~\eqref{eq:flatdef} the terms  and  
(for  and , ) may occur in  
and in the .

We may disregard the  without loss of generality, because we can include them in the : to this aim, it is sufficient to take a fresh , to add
the conjunct  to  and to replace everywhere  by .
  In order 
to  eliminate also a term like , we make a guess and distinguish 
the case where  and the case where  (formally, `making a guess' means to replace~\eqref{eq:flatdef} with a disjunction - the two disjuncts being obtained by adding to  the case description). According to the semantics conventions we made in Section~\ref{sec:preliminaries}, the first case is trivial
because we can just replace  by 0. In the other case, we
first take  a fresh variable  and apply  
 the equivalence

(here  is the whole~\eqref{eq:flatdef});  then we replace  by the equivalent formula 
 
and 
finally the latter by  
 (the result has the desired shape once we move the new existential  quantifiers in front).
 
 
After this, we still need to modify the  so that they form a
 partition (this further step produces an exponential blow-up). Let   be the matrix of a formula of the kind~\eqref{eq:card}, where the  are 
 not a partition. Let us put  and let us consider further variables , for .
 Then it is clear that the existential closure of  is equivalent to the formula obtained by prefixing the existential quantifiers  to the  formula
 
where  (here  is `' if , it is 
a blank space otherwise).



\begin{theorem}\label{thm:main}
 Satisfiability of E-flat  \formulae is decidable.
\end{theorem}

\noindent
\textit{Proof.} 
 We reduce satisfiability of~\eqref{eq:card} to satisfiability of constraint \formulae
which is decidable by Theorem~\ref{thm:NS}; in detail,
 we show that~\eqref{eq:card} is equisatisfiable with 
the constraint formula below (containing extra free variables ):

(according to our notations, the basic \formulae
 from~\eqref{eq:card} 
were supposed to be built up from the arithmetic \formulae  by replacing the variables  with 
the terms ). 




\emph{Suppose that~\eqref{eq:card1} is satisfiable}. Then there is an assignment  to the  free variables occurring in it so that~\eqref{eq:card1} is true 
in the standard structure of the integers (for simplicity, we use the same name for a free variable and for the integer assigned to it by ). If ,
we need to define  for all  and for all .
For every  this must be done in such a way that there are exactly  integer numbers  taken from  satisfying .
The interval  can be partioned by associating with each  the set  
 holds under . For every  the number of the  such that  is ; for every , pick  among them and, for these selected ,  let the -tuple  be equal to an -tuple  such that  holds (for this tuple , since the  are a partition,  does not hold, if ).
Since  and since  is equal to the length of the interval , the definition of the  is
complete. The formula~\eqref{eq:card} is true by construction.



On the other hand \emph{suppose that~\eqref{eq:card} is satisfiable} under an assignment ; we need to find ,  
(we again indicate them simply as )
so that~\eqref{eq:card1} is true. For  there is no choice, since  must be true; for , we take it to be the cardinality of the set of the 
 such that  holds under  and  holds under . In this way, 
for every , the equality  holds and for every , the equality
 holds too. Thus the formula~\eqref{eq:card} becomes true under our extended .
 



\section{A more tractable subcase}\label{sec:tractable}

Thus satisfiability of flat \formulae is decidable; since flat \formulae are closed under Boolean combinations, validity of implications of flat sentences 
is decidable too. This makes
our
result a \emph{complete} algorithm for checking invariants in verification applications.
However, the complexity of the decision procedure is very high:  Lemma~\ref{lemma:nf} introduces an exponential blow-up and other 
exponential blow-ups are introduced by Theorem~\ref{thm:main}
and by the
decision procedure (via quantifier elimination)  from~\cite{schweikhart}. 
Of course, all this might be subject to dramatic optimizations (to be investigated by future reseach); in this paper we show  that there is 
 a much milder 
(and still practically useful) fragment.

\begin{definition}
 Simple flat \formulae are recursively defined as follows: (i) basic \formulae are simple flat \formulae; 
(ii) if  is a simple flat formula,
 is a basic formula and  are variables, then  is a  simple flat formula.
\end{definition}


As an example of a simple flat formula consider the following one 

expressing that  (i.e. that the array  is obtained from  by over-writing  in the entry ). 

\begin{definition}
Simple E-flat \formulae are \formulae of the kind 
  
where  and the  are basic.
\end{definition}


It is easily seen that (once again) simple flat \formulae are closed under Boolean combinations and that simple flat \formulae are simple E-flat \formulae 
(the converse is not true, for ciclicity of the dependence graph of the 's in~\eqref{eq:simpleflatdef}). 

The difference between simple and non simple
flat/E-flat \formulae is that in simple \formulae \emph{the abstraction variable cannot occur outside the read of an array symbol} (in other words,  the  from the
above definition are of the kind  and not of the kind ).
This restriction has an important semantic effect, namely that \formulae~\eqref{eq:simpleflatdef} are equi-satisfiable to \formulae which are \emph{permutation-invariant}, in the following sense. The truth
value of an arithmetical formula or of a formula like  is not affected by a permutation of the values of the  for , because 
 does not occur free in  (permuting the values of the  may on the contrary change the value of a flat non simple sentence like 
). This `permutation invariance' will be exploited in the argument proving the correctness of decision procedure  of Theorem~\ref{thm:flatsimple} below. 
Formulae~\eqref{eq:simpleflatdef} 
themselves 
are not permutation-invariant because of 
subterms , so we first show how to eliminate them up to satisfiability:



\begin{lemma}
 Simple E-flat \formulae are equi-satisfiable to disjunctions of per\-mu\-ta\-tion-invariant \formulae of the kind
  
\end{lemma}


\noindent
\textit{Proof.} Let us take a formula like~\eqref{eq:simpleflatdef}: we convert it to an equi-satisfiabÃ²e disjunction of \formulae of the kind~\eqref{eq:simpleflatdef1}. The task is to eliminate terms ,  by a series of guessings (each guessing will form the content
of a disjunct). Notice that
 we can apply the procedure of Lemma~\ref{lemma:nf} to eliminate the , but for the  we must operate differently (the method used  in Lemma~\ref{lemma:nf} introduced non simple abstraction terms). 
 
 Let us suppose that 
  and that, after a first guess,  contains the conjunct  for each
  (if it contains ,  we replace  by 0); after a second series of guesses, we can suppose also that
  contains
 the conjuncts  for  (if it contains , we replace  by  everywhere, making  to disappear from the whole formula).
 In the next step, (i) we introduce for every  and for every  a fresh variable , (ii) we replace everywhere  by 
  and (iii) we conjoin to  the equalities . In this way we get a formula of the following kind
 
where  is the tuple formed by the  (varying  and ). We now make another series of guesses and conjoin to  either 
 or  for . Whenever  is conjoined,  is replaced by 
everywhere, so that  disappears completely. The resulting formula still has the form~\eqref{eq:tmp}, but now the map  is not injective anymore (otherwise said,
  now indicates the element from the tuple  associated with the pair  and we might have that the same  is associated 
 with different pairs ). 
 
 Starting from~\eqref{eq:tmp} so modified, let us define now the equivalence relation among the  that holds
 between  and 
whenever for all  there is  such that  contains the equalities  and . Each equivalence class 
 is uniquely identified by the corresponding function  from  into   (it is the function that for each  maps  to the  such that  contains 
as a conjunct the equality ). Let  be the equivalence classes and let  be their cardinalities.
We claim that~\eqref{eq:tmp} is equisatisfiable to

In fact, satisfiability of~\eqref{eq:tmp} trivially implies the satisfiability of the formula~\eqref{eq:tmp1};
vice versa, since~\eqref{eq:tmp1} is permutation-invariant, if it is satisfiable we can modify any assignment satisfying it via a simultaneous permutation of the values of the  so as to produce  an assignment satisfying~\eqref{eq:tmp}.

We now need just the  trivial observation that the inequalities  can be 
replaced by the \formulae  (for fresh ) in order
to match the syntactic shape of~\eqref{eq:simpleflatdef1}.
  

 

We can freely assume that quantifiers do not occur in simple flat  \formulae: this is without loss of generality because such \formulae are built up from 
arithmetic and basic \formulae.\footnote{ By the quantifier-elimination result for Presburger arithmetic, it is well-known that arithmetic \formulae 
are equivalent to quantifier-free ones. The same is true for basic \formulae  because they are obtained from arithmetic 
formulae by substitutions without capture. 
}

\begin{theorem}\label{thm:flatsimple}
 Satisfiability of simple flat  \formulae can be decided in NP (and thus it is an NP-complete problem).
\end{theorem}

\noindent
\textit{Proof.} 
 First, by applying the procedure of the 
 previous Lemma we can reduce to the problem of checking the satisfiability of \formulae of the kind
 
where  are basic
(notice also that each formula in the output of the procedure of the previous Lemma comes from a polynomial guess).

Suppose that  are the atoms occurring in 
. For a Boolean assignment  to these atoms, we indicate with  the Boolean value (0 or 1) the 
 formula  has under such assignment. We first claim that~\eqref{eq:card00} is satisfiable iff there exists \emph{a set of assignments}  such that the formula

is satisfiable (we introduced extra fresh variables , for ; notation  is the same as in the proof of Lemma~\ref{lemma:nf}).
In fact, on one side, if~\eqref{eq:card00} is satisfiable under , we can take as  the set of assigments for which 
is true under   for some  and for  the cardinality of the set of the  for which  holds.
This choice makes~\eqref{eq:cards} true. 
Vice versa, if~\eqref{eq:cards} is true under , in order to define the value of the tuple  (for ), pick for every  some  such that  
  holds; then, supposing , let  be equal to  for , to
   for , etc.
  Since we have that , the definition of the interpretation of the  is complete (any other permutation of the values 
   inside  would fit as well).
  In this way, formula~\eqref{eq:card00} turns out to be true.

We so established that our original formula is satisfiable iff there is some  such that~\eqref{eq:cards} is satisfiable;
the only problem we still have to face is that  might be exponentially 
large. To reduce to a polynomial , we use the same technique as in~\cite{cade21}. In fact, if~\eqref{eq:cards} is satisfiable, then the column vector  is a linear combination with positive integer coefficients of the 0/1-vectors 
and it is known from~\cite{ro} that, if this is the case, the same result can be achieved by assuming that at most  of the  are nonzero.  Thus polynomially many  are sufficient and
for such , a satisfying polynomial assignment for the existential Presburger formula~\eqref{eq:cards} is a polynomial certificate. 
 




{\subsection{ Some heuristics}\label{subsec:heuristics}
We discuss here some useful heuristics for  the satisfiability algorithm for simple flat \formulae (these heuristics have been implemented in our prototype).


1.- The satisfiability test involves all \formulae~\eqref{eq:cards} for each set of assignments  having cardinality \emph{at most}    
(actually, one can improve this bound, see~\cite{cade21}). If we replace in~\eqref{eq:cards}, for every , the conjunct 
 by  and the conjunct

by
, 
we can limit ourselves to the  having cardinality \emph{equal to} . This trick is useful if, for some reason, we prefer to go through any sufficient set of assignments (like  the set of all assignments supplied by some Boolean propagation, see below).

2.- There is no need to consider assignments  over the set of the atoms  occurring in the ; any set of \formulae generating the  by 
Boolean combinations fits our purposes. As a consequence, the choice of these
`atoms' is subject to case-by-case evaluations.

3.- Universally quantified \formulae of the kind  can be turned into flat \formulae by rewriting them as
 (and in fact such universally quantified \formulae often occur in our benchmarks suite).
 These \formulae contribute to~\eqref{eq:card00} via the conjuncts of the kind
. It is quite useful to
consider the  arising in this way as atoms (in the sense of point 2 above) and restrict to the assignments  
such that . 

4.- Boolean propagation is a quite effective strategy to prune useless assignments; in our context, as soon as a partial assignment  is produced inside the assignments enumeration subroutine, 
an SMT solver is invoked to test the satisfiability of 
; since this is a (skolemized) conjunct of~\eqref{eq:cards}, if 
the test is negative the current partial assignment is discarded and next partial assignment (obtained by complementing the value of the last assigned literal) is taken instead.


\section{Examples and experiments}\label{sec:experiments}

We implemented a prototype \textsc{ArCa-Sat}\footnote{\textsc{ArCa} stands for \emph{Array with Cardinalities}.} producing out of  simple E-flat \formulae~\eqref{eq:card00} the  proof obbligations~\eqref{eq:cards} (written  in SMT-LIB2 format), exploiting the heuristics 
explained in Section~\ref{subsec:heuristics}. To experiment the feasibility of our approach for concrete verification problems, we also implemented a (beta) version of a tool called \textsc{ArCa} producing out of the
specification of a parametric distributed system and of a safety-like problem, some E-flat simple \formulae whose unsatisfiability formalizes invariant-checking and bounded-model checking problems. A script executing in sequence 
\textsc{ArCa},  \textsc{ArCa-Sat} and \textsc{z3} can then solve such problems by reporting a `sat/unsat' answer.

A system is specified via a pair of flat (simple) \formulae  and 
and a safety problem via a further formula  (here the  are parameters and array-ids, the  are renamed copies of the ).
A bounded model checking problem is the problem of checking whether the formula

is satisfiable for a fixed . An invariant-cheking problem, given also a formula , is the problem of checking whether the three \formulae

are unsatisfiable. Notice that since all our algorthms terminate and are sound and complete, the above  problems are always solved by the above tool combination (if enough
computation resources are available). Thus, our technique is able \emph{both to make safety certifications and to find bugs}.

To validate our technique, in the following we describe in detail the formalization of the send-receive broadcast primitive (SRBP) in \cite{Srikanth87}.  SRBP  is used as a basis to synchronize clocks in systems where  processes may fail in sending and/or receiving messages.  Periodically, processes broadcast the virtual time to be adopted by all, as a \textit{(session s)} message.  Processes that accept this message set  as their current time.  SRBP aims at guaranteeing the following properties:
\begin{description}
\item [Correctness:] if at least  correct processes broadcast the message \textit{(session s)}, all correct processes accept the message.
\item [Unforgeability:] if no correct process broadcasts \textit{(session s)}, no correct process accepts the message.
\item [Relay:] if a correct process accepts \textit{(session s)}, all correct processes accept it.
\end{description}
where  is the number of processes failing during an algorithm run, with  the number of processes in the system.  Algorithm \ref{SRBPcode} shows the pseudo-code.

\begin{algorithm}[t]
\begin{footnotesize}
\begin{tabbing}
aaaa\=bb\=cccc\=dddd\=eeee\=ffff   \kill
{\bf Initialization:}  \\
\> To broadcast a \textit{(session s)} message, a correct process sends \textit{(init, session s)} to all.  \\
{\bf{End Initialization}}  \\
{\bf for} each correct process:  \\
1.\> \textbf{if} received \textit{(init, session s)} from at least  distinct processes \textbf{or}  \\
2.\> \> received  \textit{(echo, session s)} from any process \textbf{then}  \\
3.\> \> \> accept  \textit{(session s)};  \\
4.\> \> \> send  \textit{(echo, session s)} to all;  \\
5.\> \textbf{endif}  \\
{\bf end for}
\end{tabbing}
\end{footnotesize}
\caption{\label{SRBPcode}Pseudo-code for the send-receive broadcast primitive.}
\end{algorithm}


We model SRBP as follows:  is the initial state of a process ; it is  when  broadcasts a \textit{(init, session s)} message, and 0 otherwise.   indicates that  has broadcast its own echo.  indicates that  has accepted \textit{(session s)}.  Let  be the program counter,  the round number, and  a flag indicating whether one round has been executed.  We indicate with  the fact that  is faulty, and  otherwise.  Finally,  and  are the number of respectively inits and echoes received.  
In the following,  means .  
Some sentences are conjoined to all our proof obligations, namely:
.
For the Correctness property, we write  as follows:
{\footnotesize

}
where we impose that the number of correct processes broadcasting the init message is at least the number of faulty processes, , plus 1.  It is worth to notice that -- from the above definition -- our tool produces a specification that is checked for any  number of processes.  The constraints on  allow to verify all admissible assignments of 0 or  to the variables.  Similarly for .

The algorithm safety is verified by checking that
the bad properties 
cannot be reached from the initial state.  For Correctness, we set
,
that is, Correctness is not satisfied if -- after one round -- some correct process exists that has yet to accept.
The algorithm evolution is described by two transitions:  and .  The former allows to choose the number of both inits and echoes received by each process.  The latter describes the actions in Algorithm \ref{SRBPcode}.

{\footnotesize

}

The same two transitions are used to verify both the Unforgeability and the Relay properties, for which however we have to change the initial and final formula.  For Unforgeability, (13) in  changes as ; while .
In  we say that all non-faulty processes have .  Unforgeability is not satisfied if some correct process accepts.  For Relay, we use:
{\footnotesize

}
while .  In this case, we start the system in the worst condition: by the hypothesis, we just know that one correct process has accepted.  Upon acceptance, by the pseudo-code, it must have sent an echo.  All the other processes are initialized in an idle state.  We also produce an unsafe model of Correctness: we modify  by imposing that just  correct processes broadcast the init message.

\begin{table}
\caption{\label{tabellone}Evaluated algorithms and experimental results.}
\centering
{\scriptsize
\begin{tabular}{|l|c|c|c|c|c|} \hline
\textbf{Algorithm} & \textbf{Property} & \textbf{Condition} & \textbf{Problem} & \textbf{Outcome} & \textbf{Time (s.)} \\ \hline
SRBP \cite{Srikanth87} & Correctness &  init's & \textsc{bmc} & safe & 0.82   \\ \hline
SRBP \cite{Srikanth87} & Correctness &  init's &  \textsc{bmc} & unsafe & 2.21  \\ \hline
SRBP \cite{Srikanth87} & Unforgeability &  init's & \textsc{bmc} & safe & 0.85  \\ \hline
SRBP \cite{Srikanth87} & Relay &  init's & \textsc{bmc} & safe & 1.93   \\ \hline
BBP \cite{toueg87} & Correctness &  & \textsc{bmc} & safe & 6.17  \\ \hline
BBP \cite{toueg87} & Unforgeability &  & \textsc{bmc} & safe & 0.25  \\ \hline
BBP \cite{toueg87} & Unforgeability &  & \textsc{bmc} & unsafe & 0.25 \\ \hline
BBP \cite{toueg87} & Relay &  & \textsc{bmc} & safe & 1.01  \\ \hline
OT \cite{sharpie} & Agreement & threshold  & \textsc{ic} & safe & 4.20 \\ \hline
OT \cite{sharpie} & Agreement & threshold  & \textsc{bmc} & safe & 278.95  \\ \hline
OT \cite{sharpie} & Agreement & threshold  & \textsc{bmc} & unsafe & 17.75  \\ \hline
OT \cite{sharpie} & Irrevocability & threshold  & \textsc{bmc} & safe & 8.72  \\ \hline
OT \cite{sharpie} & Irrevocability & threshold  & \textsc{bmc} & unsafe & 9.51  \\ \hline
OT \cite{sharpie} & Weak Validity & threshold  & \textsc{bmc} & safe & 0.45  \\ \hline
OT \cite{sharpie} & Weak Validity & threshold  & \textsc{bmc} & unsafe & 0.59  \\ \hline
UV \cite{heardof} & Agreement &  violated & \textsc{bmc} & unsafe & 4.18  \\ \hline
UV \cite{heardof} & Irrevocability &  violated & \textsc{bmc} & unsafe & 2.04  \\ \hline
UV \cite{heardof} & Integrity & - & \textsc{bmc} & safe & 1.02 \\ \hline
U  \cite{Biely07} & Integrity &  & \textsc{bmc} & safe & 1.16  \\ \hline
U  \cite{Biely07} & Integrity &  & \textsc{bmc} & unsafe & 0.83  \\ \hline
U  \cite{Biely07} & Integrity &  & \textsc{bmc} & safe & 5.20  \\ \hline
U  \cite{Biely07} & Integrity &  & \textsc{bmc} & unsafe & 4.93  \\ \hline
U  \cite{Biely07} & Agreement &  & \textsc{bmc} & safe & 59.80  \\ \hline
U  \cite{Biely07} & Agreement &  & \textsc{bmc} & unsafe & 7.78  \\ \hline
U  \cite{Biely07} & Agreement &  & \textsc{bmc} & safe & 179.67  \\ \hline
U  \cite{Biely07} & Agreement &  & \textsc{bmc} & unsafe & 31.94  \\ \hline
MESI \cite{Patel84} & cache coherence & - & \textsc{ic} & safe & 0.11  \\ \hline
MOESI \cite{MOESI} & cache coherence & - & \textsc{ic} & safe & 0.08  \\ \hline
Dekker \cite{Dekker} & mutual exclusion & - & \textsc{ic} & safe & 2.05  \\ \hline
\end{tabular}
}
\end{table}
In Table \ref{tabellone}, we report the results of validating these and other models with our tool.  In the first column, the considered algorithm is indicated.  The second column indicates the property to be verified; the third column reports the conditions of verification.  In the fourth column, we indicate whether we consider either a bounded model checking (\textsc{bmc}) or an invariant-checking (\textsc{ic}) problem.  The fifth column supplies the obtained results.  The sixth column shows the time jointly spent by \textsc{ArCa},  \textsc{ArCa-Sat} and \textsc{z3} for the verification, considering for \textsc{bmc} the sum of the times spent for every traces of length up to 10.  We used a PC equipped with Intel Core i7  processor and operating system Linux Ubuntu 14.04 64 bits.
We focused on \textsc{bmc} problems as they produce longer formulas thus stressing more the tools.
Specifically, following the example above, we modeled: 
\begin{itemize}
\item the byzantine broadcast primitive (BBP) \cite{toueg87} used to simulate authenticated broadcast in the presence of malicious failures of the processes, 
\item the one-third algorithm (OT) \cite{sharpie} for consensus in the presence of benign transmission failures, 
\item the Uniform Voting (UV) algorithm \cite{heardof} for consensus in the presence of benign transmission failures, 
\item the U algorithm \cite{Biely07} for consensus in the presence of malicious transmission failures, 
\item the MESI \cite{Patel84} and MOESI \cite{MOESI} algorithms for cache coherence,
\item the Dekker's algorithm \cite{Dekker} for mutual exclusion. 
\end{itemize}
All the models, together with our tools to verify them, are available at \url{http://users.mat.unimi.it/users/ghilardi/arca}.

As far as the processing times are concerned, we observed that on average z3 accounts for around 68 of the processing time, while \textsc{ArCa} and \textsc{ArCa-Sat} together account for the remaining 32.
Indeed, the SMT tests performed by \textsc{ArCa-Sat} are lightweight -- as they only prune assignments -- yet effective, as they succeed in reducing the number of assignments of at least one order of magnitude. 
 
\section{Conclusions, related and further work}\label{sec:conclusions}

We identified two  fragments of the rich syntax of Figure~\ref{fig:syntax} 
and we showed their decidability (for the second fragment we showed also a tight complexity bound). Since our fragments are closed under Boolean connectives, it is possible to use them not only in  bounded model checking
(where they can both give certifications and find bugs), but also
in order to decide whether an invariant holds or not. We implemented our algorithm for the weaker fragment and used it in some experiments.
As far as we know, this is the first implementation of a \emph{complete} algorithm for a fragment of arithmetic with arrays and counting capabilities for interpreted sets.   
 
 Since one of the major intended applications concerns fault-tolerant distributed systems, we  briefly review and compare here some recent work in the area.
Papers~\cite{konnov_cav},~\cite{konnov_concur},~\cite{konnov_fmcad} represent a very interesting and effective research line, where cardinality constraints are not directly handled but abstracted away 
using interval abstract domains and counters. As a result, a remarkable amount of algorithms are certified, although the method might suffer of some lack of expressiveness for more complex examples.

On the contrary, paper~\cite{sharpie} directly handles cardinality constraints for interpreted sets; nontrivial  invariant properties are synthesized and checked, 
based on Horn constraint solving technology. At the level of decision procedures, some incomplete inference schemata are employed (completeness is nevertheless showed for 
array updates against difference bounds constraints).

Paper~\cite{consensus} introduces a very expressive logic, specifically tailored to handle consensus problems (whence the name `consensus logic' ). Such logic employs arrays with values into power set types, hence it is
situated in a higher order logic context. Despite this, our flat fragment is not fully included into , because we allow arithmetic constraints on the sort of 
indexes  and also mixed constraints between indexes and data: in fact, we have a unique sort for indexes and data, leading to the possibility of writing typically non permutation-invariant \formulae like . As pointed out in~\cite{AlbertiGS14}, this mono-sorted approach is useful in the analysis of programs, when pointers to the memory (modeled
as an array) are stored into array variables. From the point of view of deduction, the paper~\cite{consensus} uses an incomplete algorithm in order to certify   invariants. A smaller decidable fragment (identified via several syntactic restrictions) is introduced in the final part of the paper; 
the sketch of the decidability proof supplied for this smaller fragment uses bounds for minimal solutions of Presburger \formulae as well as Venn regions decompositions in order to build models 
where all  nodes in the same Venn region share the same value for their function symbols.

In future, we plan to extend both our tool \textsc{ArCa} and our results in order  to deal with more complex verification problems. Although it won't be easy to find richer fragments inheriting all the nice properties we discovered in this paper, we are confident that concrete applications will suggest viable effective extensions.

\bibliographystyle{plain}
\bibliography{FASGEP_2016}


\vfill\eject 
\appendix


\section{Counting constraints in Presburger arithmetic}\label{app:counting}

We report here a proof of Theorem~\ref{thm:NS}. This is not an original result and we will not try to optimize it, rather we just rewrite  proofs inside our notations, 
trying at the same time to supply the reader some intuitive evidence about the reasons why the theorem
holds.


Take a constraint formula   (this is a formula built up from the  grammar of Figure~\ref{fig:syntax} without using
 array-ids). For every atom  occurring in it (i.e. for every subformula of the kind  ot )
 and for every outermost occurrence of a subterm of the kind  in , pick a fresh variable  and replace 
 in  with 
 , where  is obtained from  replacing the occurrence of the 
 subterm  by . If we call  the resulting formula, it is clear that  and  are equivalent.
 
 By repeating this procedure, we can transform any constraint formula (up to equivalence) into a constraint formula built up according to the following
 more restricted instructions:
\begin{description}
  \item[{\rm (i)}] \emph{arithmetic terms} are built up from numerals , individual variables  and parameters  using  and ;
  \item[{\rm (ii)}] \emph{arithmetic atoms} are expressions of the kind , where  are arithmetic terms;
  \item[{\rm (iii)}] \emph{arithmetic \formulae} are built up from arithmetic atoms using  (actually,  is redundant, given that quantifier-elimination holds);
  \item[{\rm (iv)}] \emph{constraint atoms} are either arithmetic atoms or expressions of the form , where  is an arithmetic formula;
  \item[{\rm (v)}] \emph{constraint \formulae} are built up from constraint atoms using  .
 \end{description}

Recall that we interpret   as the cardinality of the set formed by the  such that  and  is true. Thus, if we want to translate our 
constraint atoms into the terminology of~\cite{schweikhart}, we must translate  as 
(in this sense, our formalism apparently looks slightly less expressive and the procedure below has few less cases than~\cite{schweikhart}).
 
 
 It is then evident that Theorem~\ref{thm:NS} is proved once 
we show the following 
\begin{theorem}\label{thm:NS1}
 Every constraint atom is equivalent to an arithmetic formula.
\end{theorem}

\noindent
\textit{Proof.}
The following \emph{special case} of Theorem~\ref{thm:NS1} is easy: if  does not occur in the arithmetic terms , then 
the constraint atom  

 is equivalent to the formula
 
What formula~\eqref{eq:basicright} says is that either there is no  such that  (and then ) or there is such a  (and then, taking the minimum such ,
we have that ). Notice that the condition   can be expressed in Presburger arithmetic via .\footnote{
We use obvious abbreviations like  (-times).
}

We now show how to reduce to the above special case, using the series of Lemmas of Subsection~\ref{subsec:lemmmas} below.

Consider in fact a constraint atom ; we can suppose that  is quantifier-free because Presburger arithmetic enjoys quantifier elimination. We can also eliminate negations using the equivalences  , and ,\footnote{
Here  stands for .} 
and .
Using Lemma~\ref{lem:pairwise} and  disjunctive normal forms arising from Venn's regions analysis, we can freely assume that  is a conjunction
of arithmetic atoms; atoms in which  does not occur can be eliminated using Lemma~\ref{lem:independent}.
By normalizing terms as linear polynomials, we can further limit to atoms of the kinds

where   and where  is an arithmetic term in which  does not occur. 
By Lemma~\ref{lem:unique}, we can solve the case where there are atoms of the kind . If there are no atoms like that,
using Lemmas~\ref{lem:ineq2},\ref{lem:ineq1},\ref{lem:c},\ref{lem:congruence}, we can freely assume that .\footnote{ In case an inconsistent condition
arises according to Lemma~\ref{lem:congruence}(i), the constraint atom is replaced by .}


To sum up, we are left with a constraint atom  where  is of the kind

(we  used  obvious equivalences like ).
We can now reduce to  and  by making a disjunctive guess for determining the biggest  and the lowest  
(Lemma~\ref{lem:independent} is then used to eliminate atoms where  does not occur).\footnote{We  assume that 
because  and  must be included among the conjuncts of .}
By Lemma~\ref{lem:lcm} and Lemmas~\ref{lem:pairwise},\ref{lem:independent}, we can also freely assume that . Thus we finally end up in the special case above.
 


\subsection{Ingredient Lemmas}\label{subsec:lemmmas}

We collect here the facts we used  in the above proof (they are all almost obvious).

\begin{lemma}\label{lem:pairwise} If the formulae  are pairwise inconsistent, then 
  is equivalent to
 
\end{lemma}

\begin{lemma}\label{lem:independent}
 If  does not occur in , then  is equivalent to
 
\end{lemma}

\begin{lemma}\label{lem:unique}
 If  does not occur in , then  is equivalent to
 
\end{lemma}

\begin{lemma}\label{lem:c}
 Let  be an arithmetic term where  does not occur; then the constraint atom   is equivalent to
 
\end{lemma}

Next two lemmas just report basic arithmetic facts:


\begin{lemma}\label{lem:congruence}
 For  and , let ; consider the linear congruence  ; we have that
 \begin{description}
  \item[{\rm (i)}] if  does not hold, then  is inconsistent (i.e. it does not have a solution);
  \item[{\rm (ii)}] if  holds, then one can compute  such that
  is equivalent to .
 \end{description}
\end{lemma}

\noindent
\textit{Proof.}
Item (i) is obvious, because, if 
 has a solution, then we have  for some . Suppose now that   holds and
 let , , . Since  and since gcd's can be expressed as linear combinations, there exists  such that .
  But then   is the same as 
  which is equivalent to , i.e. to , for .
 



\begin{lemma}\label{lem:lcm}
Let ,  and ; then
 is equivalent to

\end{lemma}



\begin{lemma}\label{lem:impl}
 Let  be an arithmetic term,  and ; the following implications are valid
 
\end{lemma}

\noindent
\textit{Proof.} We prove the validity of the first implication (the second is shown in an analogous way). Assume ; then  is equivalent to
. This is the same as  (i.e. to , as wanted), because otherwise we have  which implies , absurd.
  


\begin{lemma}\label{lem:ineq1}
 Let  be an arithmetic term where  does not occur; then the constraint atom   is equivalent to
 
\end{lemma}

\noindent
\textit{Proof.}  By the existence of quotients and remainders,   is equivalent to
 , i.e. to

Now it is sufficient to apply the previous lemma.
 

 
 
\begin{lemma}\label{lem:ineq2}
 Let  be an arithmetic term where  does not occur; then the constraint atom   is equivalent to
 
\end{lemma}

\noindent
\textit{Proof.}  The same as for the previous lemma.
 

  


\end{document}
