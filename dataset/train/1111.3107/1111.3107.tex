\documentclass[copyright,creativecommons]{eptcs}
\providecommand{\event}{Infinity 2011} \usepackage{breakurl}             

\title{Trees over Infinite Structures \\ and Path Logics with Synchronization}
\author{Alex Spelten \qquad Wolfgang Thomas \qquad Sarah Winter
\institute{RWTH Aachen University\\ Germany}
\email{\{spelten,thomas,winter\}@automata.rwth-aachen.de}
}
\def\titlerunning{Trees over Infinite Structures}
\def\authorrunning{A. Spelten, W. Thomas \& S. Winter}

\usepackage{gastex}
\usepackage{amsmath,amssymb}
\usepackage{stmaryrd}
\usepackage{float}
\usepackage{subfigure}
\usepackage{graphicx}
\usepackage{multirow} 
\usepackage[amsmath,thmmarks]{ntheorem}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{fact}[theorem]{Fact}
\theoremstyle{plain}
\theorembodyfont{\normalfont}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}
\newtheorem{remark}[theorem]{Remark}
\theoremstyle{nonumberplain}
\theoremsymbol{{\footnotesize\ensuremath{\blacksquare}}}
\newtheorem{proof}{Proof}



\newcommand{\eat}[1]{}
\newcommand{\underbr}[1]{\ensuremath{\underbracket[.5pt][1pt]{#1}}}
\renewcommand{\emptyset}{\protect\raisebox{.15ex}{\ensuremath{\not}}\ensuremath{\mathnormal{O}}}


\DeclareMathSymbol{\epsilon}{\mathalpha}{letters}{"22}
\DeclareMathSymbol{\varepsilon}{\mathalpha}{letters}{"0F}
\DeclareMathSymbol{\theta}{\mathalpha}{letters}{"23}
\DeclareMathSymbol{\vartheta}{\mathalpha}{letters}{"12}
\DeclareMathSymbol{\phi}{\mathalpha}{letters}{"27}
\DeclareMathSymbol{\varphi}{\mathalpha}{letters}{"1E}
\makeatletter
\newcommand{\charfusion}[2]{\def\ch@rfusion##1##2{\ooalign{\hfil\hfil\cr\hfil\hfil\crcr}}\mathop{\vphantom{#1}\mathpalette\ch@rfusion#2}\displaylimits}
\makeatother
\newcommand{\bigcupcdot}{\charfusion{\bigcup}{\cdot}}
\newcommand{\cupcdot}{\charfusion{\cup}{\cdot}}
\newcommand{\m}{\ensuremath{\mathcal{M}}}
\newcommand{\el}{\ensuremath{\mathcal{L}}}
\newcommand{\ml}{\ensuremath{\m\textrm{-}\el}}
\newcommand{\mpadl}{\ensuremath{\m_{\#}\textrm{-}\el}}
\newcommand{\mll}{\ensuremath{\m\textrm{-}\el\textrm{-}\el}}
\def\padd{_{\#}}
\newcommand{\msom}{MSO\ensuremath{^\m}}
\newcommand{\msoexp}{\ensuremath{\m_{\mathit{MSO}}^*}}
\newcommand{\msoexpe}{\ensuremath{\m_{\mathit{MSO,E}}^*}}
\newcommand{\Sing}{\ensuremath{\textrm{Sing}}}
\newcommand{\Succ}{\ensuremath{\textrm{Succ}}}
\newcommand{\Mweak}{\ensuremath{\m^{\#}}}
\newcommand{\MweakE}{\ensuremath{\m^{\#}_E}}
\newcommand{\Mstrong}{\ensuremath{\m^*}}
\newcommand{\MstrongE}{\ensuremath{\m^*_E}}
\newcommand{\convo}{\ensuremath{\langle\alpha\rangle}}
\newcommand{\tp}{\ensuremath{\mathit{tp}}}
\newcommand{\Suc}{\ensuremath{\mathit{Suc}}}
\def\chain{chain}
\def\chainnull{chain\ensuremath{_0}}
\def\chaine{chain\ensuremath{_E}}
\def\chainnulle{chain\ensuremath{_{0,E}}}
\def\chainesib{chain\ensuremath{_E^{sib}}}
\def\chainnullesib{chain\ensuremath{_{0,E}^{sib}}}
\def\msos1s{MSO\ensuremath{^{\mathrm{S1S}}}}
\def\PEqDir{P_{eqDir_{i,j}}}
\newcommand{\Pmem}[1]{P_{member,#1}}
\begin{document}
\maketitle

\begin{abstract}
We provide decidability and undecidability results on 
the model-checking problem for infinite tree structures. 
These tree structures are built from sequences of  
elements of infinite relational structures. More 
precisely, we deal with the tree iteration of a relational 
structure  in the sense of Shelah-Stupp. 
In contrast to classical results, where 
model-checking is shown decidable for MSO-logic, we 
show decidability of the tree model-checking problem 
for logics that allow only path quantifiers and chain 
quantifiers (where chains are subsets of paths), as they appear 
in branching time logics; however, at the same time,  
the tree is enriched by the equal-level relation 
(which holds between vertices ,  if they are on 
the same tree level). We separate cleanly the tree logic 
from the logic used for expressing properties of the underlying 
structure . 
We illustrate the scope of the decidability results by showing 
that two slight extensions of the framework lead to undecidability.
In particular, this applies to the (stronger) tree iteration in 
the sense of Muchnik-Walukiewicz. 

\end{abstract}



\section{Introduction}\label{sec_intro}



A key result in the field of ``infinite-state model-checking'' is 
Rabin's Tree Theorem \cite{rab69}. 
It says that the monadic second-order theory (short: MSO-theory) 
of the binary tree 
is decidable. Many decidability results on theories of infinite
structures have been obtained by a reduction to Rabin's Tree Theorem. 
It is also well-known that a slight extension of the signature of 
the binary tree leads to undecidability: The expansion of the binary tree by the ``equal-level relation''  
has an undecidable monadic theory. 

The situation changes when set quantification is restricted to ``chains'', 
i.e., sets that are linearly ordered by the partial tree ordering. It is known 
(\cite{tho90}) that for the unlabeled binary tree and also for any regular binary 
tree, the chain logic theory of the tree is decidable in the presence of . 
This result is of interest in verification since a large number of logical 
concepts that occur in specifications of nonterminating systems refer to 
computation paths and their subsets (i.e., to chains), for example in branching time 
logics. The second-order quantifiers in these applications do not refer to global colorings 
of computation trees (for which monadic logic would be invoked) but rather 
to quantification over chains. The equal-level relation adds the feature 
of synchronization to computation paths. 

In recent years, a theory of words and trees over infinite alphabets emerged
(\cite{nsv04,bmssd,cg09}) that opens a way for generalizations. 
Here,  a computation 
path is a sequence of letters chosen from a relational structure 
, which is infinite in general, rather than 
from a finite alphabet . Instead of the binary tree obtained from 
the words of  built from the two element alphabet , 
the infinitely branching infinite tree with vertices in  is considered.  

There are two fundamental constructions of a tree structure built from an ``alphabet structure''
, called ``weak'', respectively ``strong'' tree iteration of 
, and denoted here , respectively . 
For , let

where  holds if  for some , 
 is the reflexive transitive closure of , and, for -ary , we have  
 iff for some ,  for  such
that  holds in . 
This iteration is also called Shelah-Stupp iteration, going back 
to \cite{she75,stu75}. 

The strong tree iteration  is obtained from the weak one by adjoining 
the ``clone predicate'' 
 
to the 
signature. It allows to connect two levels of the tree structure in a way that 
``unfolding'' becomes definable. 

As shown by Shelah and Stupp \cite{she75,stu75}, respectively Muchnik and Walukiewicz (see the 
announcement in \cite{sem84} and the proof in \cite{wal02}), the MSO-theory 
of  and the MSO-theory of  are decidable if the 
MSO-theory of  is. In the present paper we show the decidability of the 
chain logic theory of structures , 
obtained by adjoining the equal level relation  to , 
under mild assumptions on the structure .   
Our results extend work of Kuske and Lohrey \cite{kl06} on structures 
and of B{\`e}s \cite{bes08} on structures . Furthermore, we show -- in contrast 
to the Muchnik-Walukiewicz result for MSO-logic --  that a transfer 
of this decidability result to tree structures  is not possible.

B{\`e}s shows the decidability of 
the chain logic theory of  if the first-order theory of  is
decidable. Here we refine his result: We refer to any logic  
such that the -theory of  is decidable, and we consider an 
{\em extension} of the chain theory of  in which further quantifications 
are allowed, namely quantifiers of  restricted to the set of siblings of 
any element . (Thus one allows quantifiers over elements  that are -successors 
of any given element .) We call the corresponding theory the {\em chain logic theory 
of  with  on siblings}. We show that this theory is decidable 
if the -theory of  is. 

In our framework two logics play together: The logic  
allows to express relations between -elements as they appear as sons 
of some given node of the tree, and chain logic is used to speak about (sets of) 
tree elements arranged along paths. Referring to the standard graphical representation
of trees,  captures the horizontal dimension and chain logic the vertical 
dimension. On the level of signatures, the predicate  of the tree signature
refers to the horizontal while the successor and the prefix relation refer to the vertical aspect; 
finally,  the signature of  enters in the horizontal dimension, restricted to the 
children of a tree node. 

Standard examples of logics  are first-order logic FO, monadic second-order logic MSO 
and its weak fragment WMSO, transitive closure logic TC, or extensions of FO by counting 
operators. (In this paper we do not present a precise definition of the concept of a ``logic'' and just refer the reader to~\cite{eft07}.) Standard examples of models  originate in arithmetic and analysis, e.g.\   
 (whose
first-order theory is decidable). In 
applications, one may work with structures  that are 
direct products of finite transition graphs with infinite value structures such as 
  or the real field ). 

The method to show the main result rests on a simple observation, first exploited 
in \cite{tho90}: Consider the tree with domain  where  is ordered of order type . 
A formula  of chain logic -- with chains  
as possible interpretations of the  -- can be viewed as a statement about 
-tuples of -words as follows. 
Any single chain  is encoded by two -words; the 
first is from  and describes the (leftmost) full path of which
 is a subset. The second is a 0-1-sequence describing by its entries 0 and 1 
which elements of the path belong to . Now the obtained  -tuple  of -words 
over , respectively , can be viewed as a single -word 
with alphabet letters from . Using this translation 
of -tuples of chains of  into -words over , 
we obtain a translation of 
chain logic formulas into MSO-formulas interpreted in -words, i.e., 
structures with domain . More precisely, when  is the logic 
used for , we obtain a formula of ``\ml-MSO''. 

This framework of \ml-MSO is in turn equivalent to B\"uchi automata (over 
-words with entries from ). We develop these 
\ml-B\"uchi automata as a preparation for the main result. 
 It turns out that these automata allow 
closure and decidability results in precise analogy to the classical 
theory over finite alphabets. As a consequence we obtain that the chain theory of  with  on siblings is decidable if the -theory of  is. 

While the setting of \ml-B\"uchi automata 
is sufficient for the study of tree models , it has to be extended 
to cope with strong tree iterations  where the clone predicate
enters. We define ``strong \ml-B\"uchi automata'' for this purpose. 
Here a remarkable difference occurs between the cases of 
an input alphabet  (with infinite ) and an input alphabet  
for . We give a brief explanation that in the first case 
strong B\"uchi automata behave as \ml-B\"uchi automata (however
using just  MSO), whereas in the second case of input alphabets  with , 
 undecidability phenomena enter (in the form that the emptiness 
 problem becomes undecidable). Along this line we show that the chain theory (and even the first-order theory) of  is undecidable if  is infinite -- in fact already for the case that  is the successor structure of the natural numbers.
  
A last result of the paper shows that the decidability result 
(on the chain theory of  with  on siblings) 
also fails when quantification extends over an entire tree level 
rather than just siblings of a fixed node. We obtain this 
for the weak tree iteration of the two element alphabet  
when the logic  is MSO.   

The paper is structured as follows. In the subsequent section we 
collect the necessary terminology. Section~\ref{sec_mlaut} develops the theory 
of B\"uchi automata over -words whose letters are 
-tuples from an infinite structure  and using a logic  to specify 
properties of such letters in . 
In Section~\ref{sec_weaktree} we deduce the decidability 
of the chain theory of  with  on siblings when the 
-theory of  is decidable. Section~\ref{sec_equlev} gives the two mentioned
undecidability results. We conclude with remarks on further work. 



\section{Terminology}\label{sec_term}



We consider relational structures with finite signature. Such a structure 
is presented in the format  where  is of arity . 
We focus on structures called ``admissible'': In this case there are 
two designated elements (usually called 0 and 1), represented by 
two singleton predicates  that belong to the tuple .
Then we can view bit sequences as special sequences over . 

For an -word  (where  may be infinite), 
written ,  
we denote by  the segment .

We introduce two tree models built from a relational structure . 
The first is the weak tree iteration 
 
where 
  is a prefix of ,  is the successor relation 
containing all pairs  with , and  
for every , say of arity , we have  iff 
there exists ,  such that 
for  and . (In~\cite{bes08}
a variant of this definition is used, namely that there exist
 of same length and  
such  with .) 

As mentioned in the introduction, the strong tree iteration of  is the structure 

where everything is as above for  and . 
The expansions of ,  by the equal level relation  (with  iff 
) are denoted , , respectively. 

If  is finite, we assume that each individual letter of  is definable.
The usual approach is to introduce a constant in the signature of  for each 
element of . In the present paper we stick to relational structures and 
use a singleton predicate  for each element . So the binary 
alphabet  is coded by the structure  with 
, . In the case of finite structures  
there is no essential difference between 
 and , since the clone predicate  becomes definable in  by 
the equivalence 


Let us introduce chain logic over the tree structures  and  
built from .
A path (through the tree domain  
) is a maximal set linearly ordered by ; it may be identified with 
an -word in , obtained as the common extension of all 
the words  forming the path. A chain is a subset of a path. 
So a singleton set in  is a chain, and we can easily simulate first-order quantification 
by quantification over chains restricted to singletons. We call chain logic the fragment 
of MSO logic in which set quantification is restricted to chains. 

Sometimes it is convenient to eliminate first-order variables and quantifiers in 
terms of (singleton) chain quantifiers. This simplifies the setting since only one 
kind  of variables remains, ranging over chains. 
In order to simulate first-order logic, the signature 
of tree models has to be adapted. As atomic formulas  one uses
\begin{itemize}
\item  for `` is a singleton''
\item  with its standard meaning,
\item  for `` is a singleton ,  is a singleton , with ;
similarly for . 
\end{itemize}
The resulting formalism is called chain logic; it has the same expressive 
power as chain logic. 

 For an 
admissible alphabet  (containing two identifiable elements 0,1) we 
encode a chain  as a pair  where 
  \begin{itemize}
    \item  encodes the path of which  is a subset. As  can be finite, we set  to be the path  where  is the last -element of which  is a subset; it can be interpreted as a sequence of ``directions''. Note that for each element  in  it holds that  is a prefix of .
    \item  codes membership in  along the path , i.e.,  iff .
  \end{itemize}

So if ,  is the path  through the tree  and  also is 
the sequence that is constant . 

The technical treatment below is simplified when viewing an -tuple  
of -words 
over  as a single -word over , the \emph{convolution} of 
:  
Similarly, we define the \emph{convolution of a relation  of 
-words} to be the -language 


So the -tuples of -elements just considered will be used as 
letters of -words and input letters of B\"uchi automata. Transitions 
of automata will be specified in a logic  by means of 
-formulas . Each of these 
formulas defines a unary predicate  over :  


In general we consider -models over  for a signature that is given by a 
finite set  of -formulas: 
Given a tuple  of words over an alphabet  and 
a finite set  of -formulas  with  free 
variables each, we define the structure 
  
with the usual interpretations of  (the latter for the successor relation), 
and the letter predicates 
. 
 Thus,   collects all letter positions of  
 which carry a letter from  that shares the property described by .

For these -models over , equipped with predicates  defined 
in , we shall use a generalized form of MSO-logic, where -- as usual in -language theory --
the first-order quantifiers range over  and the monadic second-order
quantifiers over sequences of letters (here from ). The system will be called \ml-MSO. 

For an \ml-MSO-sentence , where the predicates  are introduced via 
-formulas  with  free variables, we set 
 
as the -language defined by . 
We say a relation  is \emph{\ml-MSO definable} 
if there is a \ml-MSO sentence  with .

Later on, it will be convenient to refer to the component entries of an -word  in a more readable way than via an index . So, when a sequence variable  is used for the -th component , we shall write  to indicate the element  for .

Analogous definitions can be given for the case of finite words over . 



\section{\ml-B{\"u}chi Automata}\label{sec_mlaut}




In this section we introduce finite automata over words and -words 
whose letters are -tuples from  which is the  
domain of a (in general infinite) relational structure . 
Transitions of the automata are defined in 
a logic . Mentioning both parameters (the structure  and the logic ), 
we speak of \ml-automata and \ml-B\"uchi automata. In the first subsection we obtain, 
not surprisingly, an 
equivalence between \ml-automata and \ml-MSO. In the second subsection we add some 
remarks  on an extended model (``strong B\"uchi automata'') that allows to capture 
the clone predicate between successive letters. 



\subsection{The standard case}



Let  be a structure with domain . 
An \emph{\ml-B{\"u}chi automaton} over -tuples of -elements is of the form 
 
with a finite set  of states, the input alphabet ,  
the initial state , the set  of accepting states and 
the finite transition relation 
, where  is the set of -formulas with  free variables. 

Let us define acceptance of -words. If 
 is an -word over ,  
a \emph{run} of  on  is an infinite sequence of states 
 with  such that for every  there 
exists an \ml-formula  and a transition  satisfying

A run  of  on  is \emph{successful} 
if there exist infinitely many  such that . We say that  \emph{accepts}  if there exists a successful run of  on . 
We denote by  the set of -words over  accepted by .

Similarly, we define \ml-automata for the case of finite words (as done in~\cite{bes08}). 
Languages accepted by these automata will be denoted as \ml-recognizable languages. 
We note some basic properties. 
\begin{lemma}\label{lem:mlprops}\ 
\begin{itemize}
  \item The class of \ml-recognizable languages (of finite words) is closed under union, projection, and complementation.
  \item For an \ml-recognizable language (of finite words)  and an \ml-B{\"u}chi recognizable -language , we have 
    \begin{enumerate}
    \item  is \ml-B{\"u}chi recognizable.
    \item  is \ml-B{\"u}chi recognizable.
  \end{enumerate}
\end{itemize}
\end{lemma}

\begin{proof}
The closure properties of \ml-recognizable languages (of finite words) are shown by slight 
adaptions of the classical case (where the alphabet is finite). 
Here, we concentrate on pointing out the adaptions rather than the actual constructions. 
For example, an automaton for the projection from  to  can easily be 
obtained by replacing the ``label'' 
 of a transition by . 
For the complementation, we follow the strategy of a determinization via a powerset construction and then simply swapping the sets  and  (as 
outlined in~\cite{bes08}). The idea is as follows\eat{ (for a full work-out see~\cite{win11})}: 
Given an \ml\ automaton  (on finite words),  does not 
necessarily provide a run (accepting or not accepting) for every possible 
input letter in , i.e., there might be a letter that does not satisfy 
any of the formulas of the transitions. For the construction of the complement automaton, 
one modifies the set of formulas for the transitions such that each input word
leads to a complete run, and additionally, one prepares for determinism: 
Let  be the formulas which occur in the transitions 
of . For each subset , introduce 
the formula . 
Note that for , there is no symbol  
with , 
 and for each , there is a set  such that . 
 Then we construct  by replacing each transition 
  by  with . 
Then , and one can continue with the usual 
powerset construction. 

Concerning the second part of the Lemma, 
for a given \ml-recognizable , 
the construction of an \ml-B{\"u}chi automaton recognizing  can be done 
in a straightforward way by isolating the initial state such that it has no incoming 
transitions and for each transition from a state  to some state in , adding a transition from  to the initial state over the same letter, where the initial state will be the only final state in the new automaton. 
For the concatenation , we again follow a well-known idea by composing 
the two automata with additional transitions to cross over from one to the other 
at the appropriate positions.
\end{proof}

The basic decidability result on \ml-automata is the following. We state it 
for both kinds of automata: 

\begin{proposition}\label{prop:emptinessbuechi}
If the -theory of  is decidable, then the nonemptiness problem 
for \ml-automata on finite words as well as for \ml-B{\"u}chi automata is decidable.
\end{proposition}

\begin{proof}
For both kinds of \ml-automata, we have to determine whether there exists 
a word which is the label of a finite successful run. As a preparation, 
we have to check for each of the finitely many transitions  
whether it is ``useful'', i.e., whether 
there is an input letter  satisfying 
. This is done by invoking decidability of the -theory of , 
namely by checking whether . 
Now one considers the directed graph  where  if there is a useful
transition from  to . For an \ml-automaton over finite words, it remains to check whether 
in  there is a path from  to ; for an \ml-B\"uchi automaton one verifies whether
in  there is a path from  to a strongly connected component containing a state from .
\end{proof}

We now show basic closure properties of \ml-B\"uchi automata.


\begin{lemma}\label{lem:mlbuechiclosure}
If the -theory of  is decidable, 
the class of \ml-B{\"u}chi-recognizable -languages is effectively closed 
under union, projection, and complementation.
\end{lemma}

\begin{proof}
For union and projection the same construction as in Lemma~\ref{lem:mlprops} works. 
We sketch the construction for complementation, using the original 
approach of B\"uchi \cite{buc62}. 

Let  be an \ml-B\"uchi automaton.
We introduce an equivalence relation over finite -words such that 
 is representable as a finite union of 
sets  with \ml-recognizable sets . 
By Lemma~\ref{lem:mlprops}, this suffices to show B\"uchi recognizability of .

The desired equivalence relation is defined in terms of 
\emph{transition profiles}. We write for a finite word  and : 
\begin{itemize}
 \item  if there is a run on  from  to  in ,
 \item  if there is a run on  from  to  in  that visits an accepting state from .
\end{itemize}

A transition profile  is then given by two sets ,  of pairs of states,  containing those pairs  where , and  containing those pairs  where . Two words  are called -equivalent, written , if . This equivalence relation is of finite index: For this, note that each equivalence class (i.e., a language  for a type ) is a Boolean combination of the -recognizable languages 
, , in fact, we have


Since the set of pairs  is finite, we get only finitely many equivalence classes. Moreover, by Lemma~\ref{lem:mlprops} and Proposition~\ref{prop:emptinessbuechi}, we can compute those  which are nonempty and hence obtain an effective presentation of the equivalence classes in terms of the corresponding finite sets , .

We identify the equivalence classes with the transition profiles and denote the set of these transition profiles of  by . 
 
The following ``saturation property'' is now immediate: 

\begin{lemma}\label{saturation}
For any -equivalence classes , the -language 
 is either contained in  or in its 
complement.  
\end{lemma}

It remains to show that any -word over  belongs to some set 
 where  are -classes. For this we 
use the transition profiles as ``colors'' of segments  for . 
By Ramsey's Infinity Lemma \cite{ram30} there is for any  and any 
B\"uchi automaton  a pair of transition profiles  from 
 and an infinite set  such that 
 
This shows that , where ,  denote the equivalence classes of  corresponding to  resp.\ . 
Let  
 
Again, by decidability of the -theory of , this set is computable. 
Then 

\ 
\end{proof}

As a consequence of Lemma~\ref{lem:mlprops} and Lemma~\ref{lem:mlbuechiclosure} we obtain the following result. 

\begin{proposition}\label{prop:inclusionEquivBuechi}
If the -theory of  is decidable, the inclusion problem and the equivalence problem for 
\ml-B{\"u}chi recognizable languages are decidable. 
\end{proposition}


After these preparations, one can easily infer an equivalence between \ml-B{\"u}chi automata 
and \ml-MSO.

\begin{remark}\label{rem:AtoFBuechi}
Let  be an \ml-B{\"u}chi automaton, then there exists an \ml-MSO sentence  with .
\end{remark}

Again, the construction of an \ml-MSO formula describing a successful run of a given \ml-B{\"u}chi automaton  is a straightforward adaption of the well-known proof (\cite{tho97}). 
The only modification occurs in the formulas describing the transitions of : 
for  a transition , one uses the predicates  as introduced above 
in the definition of \ml-MSO.

Let us turn to the translation from \ml-MSO sentences to \ml-B{\"u}chi automata. 

\begin{proposition}\label{prop:FtoABuechi}
Let  be an \ml-MSO sentence, then there exists an \ml-B{\"u}chi-automaton  with .
\end{proposition}

\begin{proof}
We first modify \ml-MSO to the expressively equivalent formalism of \ml-MSO-formulas in complete 
analogy to the definition of chain logic in Section~\ref{sec_term}. We proceed by induction over MSO-formulas. 

For the induction basis, we consider the atomic formulas , , , , and  and specify \ml-B{\"u}chi automata that recognize the sets of -words defined by these formulas. To exemplify, we give the automaton for , which checks that when the -th component is , the letter vector satisfies the \ml-formula , which defines the letter predicate .
\begin{center}
  \setlength{\unitlength}{.8ex}
  \begin{picture}(6,8)
    \label{fig:XsubsetP}
    \gasset{Nframe=y,AHnb=1}
    \node[Nmarks=ir](q0)(3,4){}
    \drawloop[loopangle=0](q0){}
  \end{picture}
\end{center}
For the induction step, we consider the connectives  and , as well as the existential quantifier . Here, we can exploit the closure properties of \ml-B{\"u}chi automata from Lemma~\ref{lem:mlbuechiclosure}, and employ the constructions for the union, complementation, and projection, respectively.
\end{proof}

As a relation  is representable by a convolution as an -word over , Remark~\ref{rem:AtoFBuechi} and Proposition~\ref{prop:FtoABuechi} yield the following result.

\begin{theorem}\label{theo:maintheobuechi}
A relation  with  of -words is \ml-MSO definable  iff 
it is \ml-B{\"u}chi-recognizable. The transformation in both directions is effective.
\end{theorem}

As a consequence of the \ml-B{\"u}chi theory, we obtain that satisfiability and 
equivalence of \ml-MSO-formulas over models from  are 
decidable if the -theory of the structure  is decidable.



\subsection{Strong --B\"uchi automata}



In the second part of this section, we extend -- as far as possible -- 
the techniques and results to a 
slightly stronger model of B\"uchi automaton. While the B\"uchi automata above 
are appropriate for treating the structures , a stronger model is motivated by 
the study of strong tree iterations  in which the clone predicate 
enters. Recall that it allows to single out those elements of  which are 
of the form . Thus, when reading a ``letter''  along a path, we need to incorporate 
the feature to ``remember'' whether this current input letter  coincides with the 
previous one.  

We define the notion of {\em strong --B\"uchi automaton} over 
-tuple input letters (i.e., with input alphabet ,  being the domain of ). The format is the same as for standard B{\"u}chi automata over  as mentioned above, except for the transitions. 
For each state pair  
 the possible transitions are defined by a formula  -- or, in the special case of an initial transition, by 
a formula . Starting with the latter case, 
the automaton can proceed from  to  with input letter  
if . For a transition of the first case, 
in which a previous input letter exists and is , 
the automaton can move from  to  if .
All other notions are copied from the case of (standard) --B\"uchi automata. 

We can reprove the basic decidability and closure properties only under rather radical 
restrictions, namely just for the logic  = MSO 
and for the case of input letters from  (rather than -tuples of such 
letters). We only give a rough outline; in the present paper 
we do not apply these automata to chain logic over tree structures. 
  
First let us state the basic decidability result.

\begin{lemma}
If the MSO-theory of  is decidable, 
the emptiness problem for strong  -MSO-B\"uchi automata over  
is decidable. 
\end{lemma}

\begin{proof}
The proof of this lemma can either be given directly, or by invoking the 
above-mentioned Muchnik-Walukiewicz result (\cite{sem84,wal02}). 
It states -- under the assumption that 
the MSO-theory of  is decidable -- that the MSO-theory of  is 
decidable. The nonemptiness of a strong B\"uchi automaton over  can be 
decided by checking existence of a suitable path through . 
\end{proof}

\begin{lemma}
If the MSO-theory of  is decidable, the 
class of -languages recognized by strong -MSO-B\"uchi automata 
over  is effectively closed under the Boolean operations and 
definable projections .
\end{lemma}

\begin{proof}
This claim is shown in precise analogy to the case of standard 
--B\"uchi automata (and we skip here the repetition of proofs), 
except for the closure under complement. Here we describe the necessary 
modifications. 

The approach is the same as for the standard case, 
i.e., via B\"uchi's original method involving finite colorings and 
Ramsey's Theorem. However, the coloring of a segment of an 
-word over the alphabet , i.e., the transition profile, is 
defined differently. Given a strong B\"uchi automaton , 
the ``strong transition profile'' 
of the segment  
of an -word  refers also to the 
last previous letter  if . This extra context 
information is needed in order to capture the clone predicate on the 
 components of , and we define the transition profile of a segment 
relative to this context information within . So an appropriate 
notation for a strong transition profile is  rather than 
. Such profiles, however, are of the same type as the previously 
defined profiles (namely, presented as two sets of pairs of states). The
transition profile of a segment  is fixed from the 
state pairs  that allow a run of the automaton from  to  
(respectively, a run from  to  via a final state), where   
in the first move the letter  is used. (This condition 
is dropped for the case .) 

There is, of course, a definite conceptual difference to the usual 
coloring of segments in terms of standard transition profiles: 
There, one may concatenate any sequence of segments (for given transition 
profiles) to obtain a new composed segment whose transition profile 
is induced by the given ones. In the new setting, the composition 
of segments  and  only works when the clone information on 
the last letter of  agrees with the first letter of . However, 
this does not affect the argument in B\"uchi's complementation proof: 
Here we only need that for any {\em given}  one can obtain 
a sequence  such that all segments 
 share the same transition profile, 
and that for such a sequence, the transition profiles of 
 and of  determine 
 either to be accepted of not to be accepted by 
the B\"uchi automaton.  

Also the sets  can be used as before
when defined properly:  
Such a set is {not} obtained by freely concatenating 
a segment  and a sequence of segments from ; 
rather, it is the set 

The effective presentation of the complement of  is now completed
as in the preceding subsection for \ml-B\"uchi automata.  
\end{proof}

In Section~\ref{sec_equlev} below we shall see that these results fail for the case of an infinite alphabet  with infinite  and .



\section{Weak Tree Iterations}\label{sec_weaktree}



In this section, we want to show that for the weak tree iteration with 
equal level relation, the chain theory with  on siblings is decidable if the 
-theory of  is. 

With the preparations of Section~\ref{sec_mlaut}, we will establish 
a reduction from chain logic formulas over tree models to \ml-MSO 
over -sequences (and then to B\"uchi automata).

To avoid heavy notation, we employ chain logic as introduced in 
Section~\ref{sec_term}, and provide the following construction. Recall that for 
a chain  in , the object  is a pair of sequences over 
coding the path underlying the chain , respectively the membership 
of nodes of this path in . 
 
\begin{lemma}
For any chain-formula   over  
with  on siblings, one can construct an -MSO-formula  interpreted in -words over  such that for all chains  we have:
\begin{center}
 \\
 
\end{center}
\end{lemma}

\begin{proof}
We proceed by induction over the structure of chain-formulas with  on siblings over .

For the induction basis we have to consider the atomic formulas, namely of the form 
, , , , , and also the -formulas .

As a first example, we present the translation into -MSO-formulas for the formula : Given the encoding  of a chain , the formula  has to express that  indicates membership in  exactly once. Thus, we obtain . 

For the case of an -formula , we capture  by corresponding singletons , and these in turn by pairs  consisting of a path  and a singleton set indicator  each. We have to define a corresponding predicate  by an -MSO-formula\eat{} that expresses in terms of the ,  that there is a common -predecessor  of the elements  and that the tuple  satisfies . In intuitive notation, we have


In some more detail:


The induction step then is straightforward, as -MSO is closed under the Boolean operations and projection. \end{proof}
Thus, we obtain a reduction of the chain-theory  with  on siblings of  to the -MSO theory, which with Theorem~\ref{theo:maintheobuechi} is decidable if the -theory of  is decidable. This leaves us to conclude this section with the following theorem:

\begin{theorem}\label{theo:weaktreeiterations}
If the -theory of  is decidable, the 
chain-theory of  with  on siblings is decidable.
\end{theorem}



\section{Undecidability Results}\label{sec_equlev}



In the previous sections we showed decidability of the model-checking problem
for chain logic with  on siblings over tree structures , given a 
structure  with decidable -theory for some logic . 

The first result of this section shows that this does not 
extend to strong tree iterations  (even if we confine ourselves 
to first-order logic in place of chain logic). 

The second result shows another limitation to decidability:
In the  ``horizontal dimension'' of tree models, we may (in Theorem \ref{theo:weaktreeiterations})
use 
 -quantifiers ranging over children of given nodes. We show 
  that for the case  MSO we lose decidability when the horizontal quantification 
 is extended to an entire tree level. Here we get undecidability for the weak 
 tree iteration.
 
For the first result we use a reduction 
from the termination problem of 2-counter machines (or 2-register machines). 
Such a machine  is given by a finite sequence 

where each instruction  is of the form 
\begin{itemize}
\item 
Inc, Inc 
(increment the value of , respectively  by 1),  or
\item 
Dec, Dec (similarly for decrement by 1, with the 
convention that a decrement of 0 is 0), or 
\item 
If  goto  else to  (where  and , with the natural
interpretation).
\end{itemize}
An -configuration is a triple , indicating 
that the -th instruction is to be executed and the values 
of  are , respectively. A terminating 
-computation (for  as above) 
is a sequence  of -configurations where in each step the update is done
according to the instructions in  and the last 
instruction is the stop-instruction (formally: ). 
The termination problem for 2-counter machines asks to 
decide, for any given 2-counter machine , whether 
there exists a terminating -computation that starts with 
 (abbreviated as ).
It is well-known that the termination problem for
2-counter machines is undecidable (\cite{min67}).

We turn to the model-checking problem over structures . We show 
undecidability when 
 is the structure  (where  is successor). 

\begin{theorem}
The first-order theory of  with FO on siblings is undecidable. 
\end{theorem}

\begin{proof}
For any 2-register machine  we construct a first-order formula 
 with FO on siblings such that  
iff . 

The idea is to code a computation 
by three finite paths of same length, one for each of the 
three components. Each of these paths (namely ) is determined by its 
last point in the tree structure , i.e., by a triple , ,  of -elements.

We use a formula which expresses
  

In order to obtain a formalization of the condition in squared brackets, we have to express 
\begin{enumerate}
\item 
the initial condition that  starts with the son  of the root 
and  with the son  of the root, 
\item
the progress condition that for each  (giving an instruction number), the corresponding 
-instruction is executed, which involves the vertex  and the vertices  on the same level as  and their respective successors  
on , respectively, 
\item 
the termination condition that  is the number .
\end{enumerate}

Accordingly, we can formalize the condition in squared brackets by a conjunction of three formulas , ,  in the free variables , , , making use of the (definable) tree successor relation . 
\begin{itemize}
  \item The formula  expresses (in first-order logic with FO on siblings) for the root  of the tree model and those three -successors , , , where , , , that  is the number  and ,  are the number  (of the model ).
  \item The formula  is of the form: 
  \begin{quotation}\noindent
    ``for all , ,  with  and , there are tree-successors , ,  (i.e., with , ,  with , , ) that represent the correct update of the configuration .''
  \end{quotation}
  The condition on update is expressed by a disjunction over all program instructions; we present, as an example, the disjunction member for the statement ``~Inc'':
  
  It is easy to formalize this in first-order logic with FO on siblings, similarly for the Dec-instructions and the jump instructions.
  \item The formula  expresses the third condition and is clearly formalizable in first-order logic with FO on siblings.
\end{itemize}
\end{proof}

This result can also be stated in the framework of strong 
B\"uchi automata (or even strong automata on finite words) when 
the alphabet consists of pairs of natural numbers: 
With each 2-register machine  one associates 
a strong -MSO-automaton  over 
which accepts an input word  if this represents 
the sequence of register values of a terminating computation of ; the 
existence of an appropriate sequence of instruction numbers (from )
can be expressed by a block  of MSO-quantifiers. 
(In fact, weak MSO-quantifiers suffice.)    
   
Let us turn to the second undecidability result. We shall confine ourselves to the 
 simplest setting, where the structure  is just , 
 i.e.,  and  are \emph{both} the binary tree with 
 equal level relation (see also~\cite{tho09}). 
 
\begin{theorem}
The chain theory of the binary tree with equal level relation and 
MSO on tree levels is undecidable. 
\end{theorem}

\begin{proof}
We use an idea of~\cite{pt93} that allows to 
code a tuple of finite sets of the binary tree up to (and excluding) level  
by a tuple of subsets of level  itself. In other words, we code 
a subset  of tree nodes before level  by an ``antichain''  which is a subset of the level  (see Figure~\ref{fig:coding}). 

\begin{figure}
\begin{center}
  \setlength{\unitlength}{.8ex}
  \begin{picture}(40,24)(6,10)
    \gasset{Nframe=y,AHnb=0,Nadjust=wh}
    \drawpolygon(6,12)(21,34)(36,12)			\drawccurve(16,19)(20,26)(24,22.5)(22.5,20)		\drawccurve(8,12)(16,13.5)(24,12)(16,10.5)		\gasset{Nframe=n}
    \node(bul)(22,22.5){}
    \node(v)(20,22.5){}
    \node(vp)(17.5,10){}
    \drawline[AHnb=1](23,22)(25,20.5)(17.5,12)		\node(dummy1)(20,24){}
    \node(S)(41,28){}
    \drawedge[curvedepth=3](dummy1,S){}
    \node(dummy2)(22,12){}
    \node(A)(41,17){}
    \drawedge[curvedepth=3](dummy2,A){}
    \put(40,33){level }
    \put(40,12){level }
  \end{picture}
  \caption{\label{fig:coding}Coding an element of a set  by an element of an antichain .}
\end{center}
\end{figure} 

We simply map a vertex  (before level ) to the unique vertex  which 
belongs to  (i.e., belongs to the leftmost path from 
the right successor of ; see again Figure~\ref{fig:coding}). The map  is injective
and definable in chain logic (even in FO-logic), given the level . 
Moreover, it is easy to see that the relations of being 
left or right successor in the tree are translated to FO-definable 
relations over the level  under consideration. 

Using this coding, an existential quantifier over finite sets  
in the binary tree is captured by an existential quantifier 
over subsets of an appropriate level of the tree (namely, of  
a level that is beyond all maximal elements of the finite set under
consideration). 

Thus, the weak MSO-theory of the binary tree with  is interpretable 
in the FO-theory of the  binary tree  
with  and with MSO restricted to levels.
 
Since the weak MSO-theory of the binary tree with  is undecidable 
(see e.g.~\cite{tho90b}), we obtain the claim.  
\end{proof}



\section{Conclusion}\label{sec_con}



In this work, we outlined a theory of generalized B\"uchi automata 
over infinite alphabets. These alphabets are represented by relational structures 
, the transitions being specified by formulas of a logic  over . 
In this setting of --B\"uchi automata (which only slightly generalizes 
that of \cite{bes08}), the nonemptiness problem becomes decidable if the -theory 
of  is. An extended model of strong --B\"uchi automata was introduced 
in which a transition via an -input may depend on the previous  input. Here 
an essential difference appears between the cases where input letters are from  
and where  input letters are in  for . 

We applied this theory to show that the chain logic theory of the weak tree 
iteration  of  (with  chosen as above) 
is decidable where the equal level relation is adjoined, and quantifications 
of  over siblings of the tree model are allowed. On the other hand, we showed limits 
for generalization. For example, we showed undecidability 
for the corresponding theory of the strong tree iteration when the underlying 
model is the successor structure of the natural numbers.  

Several problems are raised by this study. Since the logics considered here all 
have nonelementary complexity, it may be interesting to set up fragments and ``dialects''
(e.g.\ in temporal logics) of chain logic where the complexity is better. 
Also, it seems that variants of the model of strong (B\"uchi-) automaton 
should be studied in more depth, for instance by an integration with the 
theory of automata over ``data words'' as developed in \cite{nsv04,bmssd,cg09}.








\bibliographystyle{eptcs}
\bibliography{infbib}
\end{document}
