\begin{fortechnicalreport}
\section{Formalization of execution}
\end{fortechnicalreport}
\begin{forjournal}
\section{Formalization of Execution}
\end{forjournal}
\label{sec:execution-formalization}
This section formalizes the execution of a SCOOP program. It explains the general approach, defines the starting point of the execution, and explains the rules that drive the execution. The rules are divided into rules for mechanisms and rules for code elements.

\begin{fortechnicalreport}
\subsection{General approach}
\end{fortechnicalreport}
\begin{forjournal}
\subsection{General Approach}
\end{forjournal}
The formalization is based on \emph{structural operational semantics} \cite{plotkin:2004:structural_operational_semantics}, combined with parts of the terminology from Ostroff et al. \cite{ostroff-torshizi-huang-schoeller:2008:formal_semantics_for_SCOOP}. The idea behind a structural operational semantics is to define the behavior of a program in terms of its parts, i.e., the syntactical elements of the program. Such a semantics is intuitive because it talks directly about elements in the code. It is a very powerful semantics because it allows us to apply structural induction as a proof technique.

\subsubsection{Computations}
A \emph{computation} models the execution of a SCOOP program. It is a sequence of configurations, where each non-initial configuration is derived from a previous configuration through a transition. Each configuration defines a state and a list of statements for each processor. Each transition is described by an inference rule that maps one configuration to another. The transition from one configuration to the next models an atomic step of one processor. The concurrent execution of a SCOOP program is modeled by the interleaved transitions taken by different processors.
\begin{example}[Modeling of parallel execution]
Suppose there are two processors  and . Processor  executes the following sequence of statements: . In parallel, processor  executes the following sequence of statements: . This execution is modeled by any of the following simplified computations:  or  or .
\end{example}

\subsubsection{Configurations}
A \emph{configuration} models a snapshot in the execution of a SCOOP program. A configuration consists of a state and a set of processors, each with a queue of statements. The state is an instance of . A \emph{schedule} models the processors and the associated queues, called \emph{action queues}. Each processor must execute the statements in its action queue in a FIFO order. The beginning of the action queue contains the statements for the features that are being executed at the moment. The order of these statements models the way the call stack orders feature executions. The tail of the action queue is the request queue of the processor. A call stack lock is the right to add a feature request to the beginning of the action queue and a request queue lock is the right to add a feature request to the end of the action queue. The notation for a configuration with processors , respective action queues , and state  is:

\isolatedsinglelineconfiguration{p_{1} :: s_{1} \processorseparator \ldots \processorseparator p_{n} :: s_{n}}{\state}

The processor separator  is commutative and associative, i.e.,  and . Within an action queue,  separates statements. The configuration is \emph{well-defined} if and only if .

\subsubsection{Statements}
A \emph{statement} is an element of the action queue. A statement is either an instruction or an operation. An \emph{instruction} is user syntax, i.e.\ an action that occurs explicitly in the SCOOP program. An \emph{operation} is run-time syntax, i.e.\ an action that does not explicitly occur in a SCOOP program. For example, locking of request queues is not an action that is explicit in a SCOOP program. Instead, locking is based on the formal argument list. It is done implicitly before a feature gets executed.

\subsubsection{Transitions}
A \emph{transition} takes a system in a start configuration and leaves it in a result configuration. The following shows the general form of a transition definition that declares a start configuration  with schedule  and a result configuration  with schedule :

\isolatedsinglelinetransition
	{\configuration{P}{\state}}
	{\configuration{P'}{\state'}}

The typing environment  can be used in the transition definition to access static information about the SCOOP program.

\subsubsection{Inference rules}
An \emph{inference rule} describes the circumstances under which a transition can be used. The inference rule has a premise and a conclusion. The \emph{conclusion} is the transition and the \emph{premise} describes the circumstances under which the transition can be used. The premise consists of a number of transitions and a side condition. The premise is satisfied if all transitions in the premise can be taken and if the side condition is true.
\begin{fortechnicalreport}
The following shows a template for inference rules:

\singlelineinferencerule
	{General Inference Rule Template}
	{
		\mbox{\it{side condition}} \\
		\singlelinetransition{\configuration{P_{1}}{\state_{P_{1}}}}{\configuration{P_{1}'}{\state_{P_{1}}'}} \\
		\ldots \\
		\singlelinetransition{\configuration{P_{n}}{\state_{P_{n}}}}{\configuration{P_{n}'}{\state_{P_{n}}'}}
	}
	{\configuration{P_{n + 1}}{\state_{P_{n + 1}}}}
	{\configuration{P_{n + 1}'}{\state_{P_{n + 1}}'}}

\end{fortechnicalreport}
In this formalization, most of the rules have no transition in the premise. The following \emph{simplified inference rule template} takes this into account:

\singlelineinferencerule
	{Simplified Inference Rule Template}
	{
		\mbox{\it{condition}} \\
		\mbox{\it{new state}} \thinspace \state' \thinspace \mbox{\it{definition}}\\
		\mbox{\it{fresh channels definitions}}
	}
	{\configuration{P}{\state}}
	{\configuration{P'}{\state'}}

The side condition has three parts. The first part defines a \emph{condition} that is based on the typing environment and the start configuration. The second part is the \emph{new state definition} that defines the state of the result configuration. This new state is based on the state in the start configuration. The last part consists of the \emph{fresh channels definitions}. Auxiliary definitions can be used in the condition, the new state definition, and the fresh channels definitions. The inference rule can mention features of . The preconditions of these features serve as additional conditions in the side condition.

The following inference rule generalizes transitions by adding processors both to the start configuration and to the result configuration. These additional processors run in parallel but do not take any actions during the generalized transition.

\singlelineinferencerule
	{Parallelism}
	{
		\singlelinetransition
			{\configuration{P}{\state}}
			{\configuration{P'}{\state'}}
	}
	{\configuration{P \processorseparator Q}{\state}}
	{\configuration{P' \processorseparator Q}{\state'}}
 
\subsubsection{Scheduling}\label{sec:scheduling}
Before a processor can execute a feature it must obtain locks and it must wait until the wait condition is satisfied. A locking request encapsulates these two requirements; it consists of the requested locks and the wait condition. At every moment, multiple processors can have conflicting locking requests. The scheduler is the arbiter for these conflicts. The scheduler takes locking requests and stores them in a queue. It then approves locking requests according to a certain scheduling algorithm.

The model permits a number of possible scheduling algorithms. The algorithms differ in their level of fairness and their performance. This formalization does not focus on a particular scheduling algorithm. Instead, it uses the conditions of the inference rules to express locking requests. If more than one processor satisfies the conditions, then any of these processors can proceed.

\begin{fortechnicalreport}
\subsection{Initial configuration}
\end{fortechnicalreport}
\begin{forjournal}
\subsection{Initial Configuration}
\end{forjournal}
The initial configuration is defined by the SCOOP program. Each SCOOP program defines a root class type  and a root procedure . The root procedure is a creation procedure of the root class type that has no formal arguments and no precondition.

In the beginning, the runtime generates a bootstrap processor  and root processor  with a root object of the root class type. The request queue of the root processor is locked on behalf of the bootstrap processor. This defines our initial state :

\isolateddefinition
	{
		& \state_{x} \mathematicaldefinition \creation{\statetype}{\makefeature} \\
		& \state_{y} \mathematicaldefinition \state_{x}.\addprocessorfeature(\state_{x}.\newprocessorfeature) \\
		& p \mathematicaldefinition \state_{y}.\lastaddedprocessorfeature \\
		& \state_{z} \mathematicaldefinition \state_{y}.\addprocessorfeature(\state_{y}.\newprocessorfeature) \\
		& q \mathematicaldefinition \state_{z}.\lastaddedprocessorfeature \\
		& \state_{w} \mathematicaldefinition \state_{z}.\addobjectfeature(q, \state_{z}.\newobjectfeature(c)) \\
		& r \mathematicaldefinition \state_{w}.\referencefeature(\state_{w}.\lastaddedobjectfeature) \\
		& \state \mathematicaldefinition \state_{w}.\lockrequestqueuesfeature(p, \set{q})
	}

The bootstrap processor first asks the root processor to execute the root procedure on the root object and then asks the root processor to unlock its request queue as soon as it finished the execution. The bootstrap processor can do this because it has the request queue lock on the root processor. Finally, the bootstrap processor removes the request queue lock from its stack of obtained request queue locks. This is shown in the following initial configuration:

\isolatedconfiguration
	{
		p :: \ &\calloperation(r, f, \tuple{}, \tuple{}) \statementseparator \\
		& \issueoperation(q, \unlockrequestqueueoperation) \statementseparator \\
		& \popobtainedrequestqueuelocksoperation \processorseparator \\
		q :: &
	}
	{\state}

The statements , , , and  are operations. In a nutshell, the  operation asks the handler of the target  to make a call to the feature  on target . The  operation unlocks the request queue of the processor that executes the operation. The  operation adds the  operation to 's action queue. The  operation removes the top element from the stack of obtained request queue locks.

\begin{fortechnicalreport}
\begin{example}[Initial configuration]
This example defines the initial configuration of a share market application. The domain of the application consists of a number of markets, a number of investors, and a number of issuers. Each issuer can offer a number of shares on each market. Each investor can have an amount of cash available on each market. With this cash, the investor can buy the shares that are available on the market. Investors can sell a share on the market where they bought the share. Selling shares increases the investor's amount of cash on the market. Each market determines the price for each share. Financial regulations require the investors to keep track of the markets on which they operate. For simplicity, the price is constant and the application is restricted to one market, two investors, and one issuer with one share.

The class \lstinline[language=SCOOP]!MARKET! represents the market; the class \lstinline[language=SCOOP]!INVESTOR! represents the investor. The issuers are represented through identifiers of class \lstinline[language=SCOOP]!INTEGER!. The root class \lstinline[language=SCOOP]!APPLICATION! contains the root procedure \lstinline[language=SCOOP]!make!, where the actors get created and where the trade begins.

The execution starts with a bootstrap processor , a root processor  and a root object  of root class type . The root object is referenced by . The following initial configuration shows this:

\isolatedconfiguration
	{
		p_{0} :: \ & \calloperation(r_{0}, \mathit{make}, \tuple{}, \tuple{}) \statementseparator \\
		& \issueoperation(p_{1}, \unlockrequestqueueoperation) \statementseparator \\
		& \popobtainedrequestqueuelocksoperation \processorseparator \\
		p_{1} :: \ &
	}
	{
		\simplifiedstate
			{
				& \simplifiedstatelocksentry
					{p_{0}}
					{\set{p_{1}}}
					{}
					{}
					{\simplifiedstateunlockedindicator}
					{\simplifiedstatenopassedlocksindicator} \\
				& \simplifiedstatelocksentry
					{p_{1}}
					{}
					{}
					{}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator}
			}
			{
				& \simplifiedstateobjectsentry
					{p_{0}}
					{} \\
				& \simplifiedstateobjectsentry
					{p_{1}}
					{
						\simplifiedstatereferencedobject{r_{0}}{o_{0}}
					}
			}
			{}
			{
				& \simplifiedstateenvironmentsentry
					{p_{0}}
					{} \\
				& \simplifiedstateenvironmentsentry
					{p_{1}}
					{}			
			}
	}

\end{example}
\end{fortechnicalreport}

\subsection{Mechanisms}\label{sec:mechanisms}
Mechanisms are the machinery for the execution of code elements. This section studies these mechanisms.

\subsubsection{Issuing mechanism}
With the issuing mechanism, a processor  can add statements to the action queue of a processor . It uses the  operation to get a result configuration in which a processor's action queue is extended with the new statements. There are two main cases:  adds the statements to its own action queue, i.e., , or  adds the statements to the action queue of a different processor, i.e., . The first case is the non-separate case and the second one is the separate case.

For the non-separate case  puts the statements to the beginning of 's action queue, which is the same as putting the statements on top of the call stack. This requires that  is in possession of its own call stack lock.

\singlelineinferencerule
	{Issue Operation -- Non-Separate}
	{
		q = p \\
		\neg \state.\arelockspassedfeature(p) \\
		\state.\callstacklocksfeature(p).\containsfeature(q)
	}
	{\configuration{p :: \issueoperation(q, s_{w}) \statementseparator s_{p}}{\state}}
	{\configuration{p :: s_{w} \statementseparator s_{p}}{\state}}
 
For the separate case there is a difference between a normal and a callback case. In the normal case,  adds the statements to the end of 's action queue. This case requires that  is in possession of 's request queue lock. To distinguish the normal case from the callback case, this case also requires that  does not have a lock on .

\singlelineinferencerule
	{Issue Operation -- Separate}
	{
		q \neq p \\
		\neg \state.\arelockspassedfeature(p) \\
		\state.\requestqueuelocksfeature(p).\containsfeature(q) \\
		\neg (\state.\requestqueuelocksfeature(q).\containsfeature(p) \vee \state.\callstacklocksfeature(q).\containsfeature(p))
	}
	{\configuration{p :: \issueoperation(q, s_{w}) \statementseparator s_{p} \processorseparator q :: s_{q}}{\state}}
	{\configuration{p :: s_{p} \processorseparator q :: s_{q} \statementseparator s_{w}}{\state}}
 
The callback case occurs if  has a lock on . In this situation,  could issue a statement  on  and then wait for  to complete. On the other side, processor  could already be waiting for  to complete. Processor  would be waiting for  to finish and  would be waiting for  to finish. However, since  would be at the end of 's action queue and  would be waiting there cannot be any progress. This type of deadlock can be prevented by adding  not to the of 's action queue but to the beginning. This will make sure that  can execute the statement right away and hence  can continue. This in return will enable  to continue. As a prerequisite,  must possess 's call stack lock.

\singlelineinferencerule
	{Issue Operation -- Separate Callback}
	{
		q \neq p \\
		\neg \state.\arelockspassedfeature(p) \\
		\state.\callstacklocksfeature(p).\containsfeature(q) \\
		\state.\requestqueuelocksfeature(q).\containsfeature(p) \vee \state.\callstacklocksfeature(q).\containsfeature(p)
	}
	{\configuration{p :: \issueoperation(q, s_{w}) \statementseparator s_{p} \processorseparator q :: s_{q}}{\state}}
	{\configuration{p :: s_{p} \processorseparator q :: s_{w} \statementseparator s_{q}}{\state}}
 
\subsubsection{Delegated execution mechanism}
This section discusses how a processor  can delegate the execution of statements to a different processor . This mechanism is useful for the evaluation of asynchronous postconditions. Processor  must make sure that the statements make sense in the context of processor . The names that occur in these statements must be defined in the top environment of  and  must have the necessary locks to execute the statements. 
Statements that fulfill the following conditions can be delegated:
\begin{itemize}
	\item All names that occur in the statements are defined in 's top environment.
	\item Their execution only requires the top set of 's stack of obtained request queue locks.
\end{itemize}
These conditions exclude statements that involve non-separate calls or separate callbacks because such calls require a call stack lock. If these conditions are met,  can transfer its top environment and the top of its obtained request queue locks to . Given this context,  can then execute the delegated statements instead of .

The  operation sets up a new context on  with an environment  and obtained request queue locks . To set up the new context, the operation uses a combination of the commands  and . The command  requires that the request queue locks  are not in possession of another processor anymore. It also requires that the request queues of  are locked. Once the context is set up, processor  executes the statements  and then gets rid of the context, using the  operation.

To delegate the execution of the statements , processor  must make sure that its top environment  is set up correctly and it must make sure that the top set of its obtained request queue locks contains all locks  that are necessary for the execution of . Processor  must then issue a  operation to processor . Processor  must then remove  from its stack of obtained request queue locks so that the  operation can take place.

\inferencerule
	{Execute Delegated Operation}
	{
		\forall x \in \set{q_{1}, \ldots, q_{m}} \colon \neg \exists y \in \state.\processorsfeature \colon \state.\requestqueuelocksfeature(y).\containsfeature(x) \\
		\forall x \in \set{q_{1}, \ldots, q_{m}} \colon \state.\isrequestqueuelockedfeature(x) \\
		\state' \mathematicaldefinition \state.\pushenvironmentfeature(p, x).\delegateobtainedrequestqueuelocksfeature(p, \set{q_{1}, \ldots, q_{m}})
	}
	{\configuration{p :: \executedelegatedoperation(s_{w}, x, \set{q_{1}, \ldots, q_{m}}) \statementseparator s_{p}}{\state}}
	{\configuration{p :: s_{w} \statementseparator \leavedelegatedexecutionoperation \statementseparator s_{p}}{\state'}}

\singlelineinferencerule
	{Leave Delegated Execution Operation}
	{
		\neg \state.\environmentsfeature(p).\isemptyfeature \\
		\neg \state.\obtainedrequestqueuelocksfeature(p).\isemptyfeature \\
		\state' \mathematicaldefinition \state.\popenvironmentfeature(p).\popobtainedrequestqueuelocksfeature(p)
	}
	{\configuration{p :: \leavedelegatedexecutionoperation \statementseparator s_{p}}{\state}}
	{\configuration{p :: s_{p}}{\state'}}
 
\subsubsection{Notification mechanism}\label{sec:notification mechanism}
Processors can notify each other. A notification can optionally include a value. The formalization uses channels to describe such communication. Channels are described in Milner's -calculus \cite{milner:1999:Pi_calculus}. In the -calculus, the expression  denotes a process that is waiting for a notification sent on a channel . Once the notification has been received, the value of the notification is bound to the variable  and the process continues with the expression . The notification comes from a process that executes  to emit the value  on the channel  before executing .

The formalization reuses the channel idea in two flavors: once as a notification mechanism with a value and once as a notification mechanism without a value. A processor sends a notification with a value  over a channel  as it executes the operation . Similarly, the process sends a notification without a value over a channel  by executing the operation . For both cases, any processor can wait for a notification by executing the operation . In case a notification on a channel  carries a value, the value can be accessed with . This way of accessing the value of a channel is different from the way it is done in the -calculus. In the -calculus, each value is bound to a variable. This formalization does not define a new variable for the value. Instead, it uses  to identify the value of a channel .

A number of inference rules describe the interaction between a processor that sent a notification over a channel and a processor that is waiting for a notification over the same channel. Two main cases can be distinguished: either a processor sends a notification to itself or it sends a notification to a different processor. The first case is the non-separate case and the latter case is the separate case. In each of these two main cases, the channel carries a notification with or without a value. For each of these sub cases, there is one inference rule.

In the non-separate case, one processor has a  operation or a  operation at the beginning of its action queue and a  operation on the same channel later in the action queue. In this case, the  operation can be removed along with the  operation, respectively the  operation. If the channel carries a value, then the value must be installed on the processor, by substituting all occurrences of  with the posted value in all the statements  after the  operation.

\singlelineinferencerule
	{Wait and Result Operation -- Non-Separate}
	{}
	{\configuration{p :: \resultoperation(a, r) \statementseparator s_{w} \statementseparator \waitoperation(a) \statementseparator s_{p}}{\state}}
	{\configuration{p :: s_{w} \statementseparator s_{p} \substitution{r}{a.\datafeature}}{\state}}
 
\singlelineinferencerule
	{Wait and Notify Operation -- Non-Separate}
	{}
	{\configuration{p :: \notifyoperation(a) \statementseparator s_{w} \statementseparator \waitoperation(a) \statementseparator s_{p}}{\state}}
	{\configuration{p :: s_{w} \statementseparator s_{p}}{\state}}
 
In the separate case, one processor has a  or a  operation at the beginning of its action queue and a different processor has a  somewhere in its action queue. In this situation, the , , and  can be removed from the action queues. In case the notification has a value, the value can be installed in the statements , after the  operation.

\singlelineinferencerule
	{Wait and Result Operation -- Separate}
	{}
	{\configuration{p :: s_{w} \statementseparator \waitoperation(a) \statementseparator s_{p} \processorseparator q :: \resultoperation(a, r) \statementseparator s_{q}}{\state}}
	{\configuration{p :: s_{w} \statementseparator s_{p} \substitution{r}{a.\datafeature} \processorseparator q :: s_{q}}{\state}}
 
\singlelineinferencerule
	{Wait and Notify Operation -- Separate}
	{}
	{\configuration{p :: s_{w} \statementseparator \waitoperation(a) \statementseparator s_{p} \processorseparator q :: \notifyoperation(a) \statementseparator s_{q}}{\state}}
	{\configuration{p :: s_{w} \statementseparator s_{p} \processorseparator q :: s_{q}}{\state}}
 
The operations presented here must be used so that each  operation can be resolved with exactly one  or  operation. To define this condition more precisely, we define that one statement  weakly precedes a statement  if and only if  occurs earlier than  in the same action queue or  and  occur in different action queues. One statement  strongly precedes a statement  if and only if  occurs earlier than  in the same action queue. With these definitions, the condition says:
\begin{itemize}
	\item For each  operation there must be either exactly one  or exactly one  operation.
	\item For each  or  operation there must be exactly one  operation.
	\item Each  or  operation weakly precedes the  operation.
\end{itemize}

\subsubsection{Expression evaluation mechanism}\label{sec:expression evaluation mechanism}
An expression can either be a literal, an entity, or a query call. The query call can contain actual arguments that are expressions themselves. This section discusses the general mechanism to evaluate expressions. It focuses on the general approach and defers the evaluation of particular expressions to later sections.

The operation  takes a channel  and an expression . Each  operation determines the value  of the expression  and then sends a notification with value  on channel . This means that each  operation creates a  operation in the action queue. It is therefore important to follow each  operation with exactly one  to receive the notification with the value.
\subsubsection{Locking and unlocking mechanism}
A processor  that wants to execute a feature must first obtain the request queue locks of a number of processors . Only then can  issue statements to these processors. The  operation serves this purpose. It requires that none of the request queues is already locked.

\singlelineinferencerule
	{Lock Operation}
	{
		\neg \exists q_{i} \in \set{q_{1}, \ldots, q_{m}} \colon \state.\isrequestqueuelockedfeature(q_{i}) \\
		\state' \mathematicaldefinition \state.\lockrequestqueuesfeature(p, \set{q_{1}, \ldots, q_{m}})
	}
	{\configuration{p :: \lockrequestqueuesoperation(\set{q_{1}, \ldots, q_{m}}) \statementseparator s_{p}}{\state}}
	{\configuration{p :: s_{p}}{\state'}}
 
Once  is done with the execution of the feature, it asks  to unlock their request queues once they are done with the issued statements. For this purpose,  issues the  operation to processors . This operation requires that the request queue is indeed locked and that no processor possesses the request queue lock.

\singlelineinferencerule
	{Unlock Operation}
	{
		\state.\isrequestqueuelockedfeature(p) \\
		\forall q \in \state.\processorsfeature \colon \neg \state.\requestqueuelocksfeature(q).\containsfeature(p) \\
		\state' \mathematicaldefinition \state.\unlockrequestqueuefeature(p)
	}
	{\configuration{p :: \unlockrequestqueueoperation \statementseparator s_{p}}{\state}}
	{\configuration{p :: s_{p}}{\state'}}
 
After  issued the  operations, it can remove  from its stack of obtained request queue locks using the  operation. This ensures that the  operations can proceed.

\singlelineinferencerule
	{Pop Obtained Request Queue Locks}
	{
		\state' \mathematicaldefinition \state.\popobtainedrequestqueuelocksfeature(p)
	}
	{\configuration{p :: \popobtainedrequestqueuelocksoperation \statementseparator s_{p}}{\state}}
	{\configuration{p :: s_{p}}{\state'}}
 
Brooke, Paige, and Jacob \cite{brooke-paige-jacob:2007:formal_semantics_for_SCOOP} noticed that  operations are not optimal. In essence, it could be possible to unlock the request queue of a processor  directly after  issued all statements. The request queue lock is important to guarantee exclusive access on 's request queue. However, as soon as  issued all statements on , this lock is no longer needed. Unlocking the request queue right away could improve the performance in some situations because 's request queue could be locked again earlier and hence another processor that is waiting for this lock could proceed earlier.

\subsubsection{Write and read mechanism}
A processor  can use the  operation to set a value  of an entity with name . This operation uses the  command. Hence,  can both set attribute values of its current object and values of entities in its top environment.

\singlelineinferencerule
	{Write Value Operation}
	{\state' \mathematicaldefinition \state.\setvaluefeature(p, x, v)}
	{\configuration{p :: \writevalueoperation(x, v) \statementseparator s_{p}}{\state}}
	{\configuration{p :: s_{p}}{\state'}}

 
Similarly, processor  can execute the  operation to read a value of an entity with name  and send the value over channel . The  operation does not present its result in a  operation because, unlike an  operation, a  operation always produces a result for the surrounding action queue. It is easier to do the substitution of the channel access directly. A later section introduces the  operation for entity expressions. This variant of the  operation makes use of the  operation and presents the result in a  operation.

\singlelineinferencerule
	{Read Value Operation}
	{}
	{\configuration{p :: \readvalueoperation(x, a) \statementseparator s_{p}}{\state}}
	{\configuration{p :: s_{p} \substitution{\state.\valuefeature(p, x)}{a.\datafeature}}{\state}}
 
Finally, there is the  operation in two variants for once functions and one variant for once procedures. This operation sets the once status of a once routine. The variant  sets the once status of a once function  to non-fresh with value . If  is of separate type, then the once function becomes non-fresh on all processors in the system. If  has a non-separate type, then  becomes non-fresh only on processor . The variant  sets the once status of a once procedure  to non-fresh on processor . The variant  uses the value of the result entity to set the once status of a once function.

\singlelineinferencerule
	{Set Once Routine Not Fresh Operation -- Function}
	{
		f \in \functiontype \wedge f.\isonceroutinefeature \\
		\state' \mathematicaldefinition \state.\setoncefunctionnotfreshfeature(p, f, r)
	}
	{\configuration{p :: \setonceroutinenotfreshoperation(f, r) \statementseparator s_{p}}{\state}}
	{\configuration{p :: s_{p}}{\state'}}

\singlelineinferencerule
	{Set Once Routine Not Fresh Operation -- Procedure}
	{
		f \in \proceduretype \wedge f.\isonceroutinefeature \\
		\state' \mathematicaldefinition \state.\setonceprocedurenotfreshfeature(p, f)
	}
	{\configuration{p :: \setonceroutinenotfreshoperation(f) \statementseparator s_{p}}{\state}}
	{\configuration{p :: s_{p}}{\state'}}

\inferencerule
	{Set Once Routine Not Fresh Operation -- Function With Result}
	{
		f \in \functiontype \wedge f.\isonceroutinefeature \\
		\state.\environmentsfeature(p).\topfeature.\namesfeature.\containsfeature(\resultentityname) \\
		\freshchanneldefinition{a}
	}
	{\configuration{p :: \setonceroutinenotfreshwithresultoperation(f) \statementseparator s_{p}}{\state}}
	{\configuration{p :: \readvalueoperation(\resultentityname, a) \statementseparator \setonceroutinenotfreshoperation(f, a.\datafeature) \statementseparator s_{p}}{\state}}
 
\subsubsection{Flow control mechanism}
In addition to flow control instructions in the user code, there are flow control operations, which implement flow control in the inference rules. This way, fewer inference rules are required because multiple variants can be handled in one inference rule.

The  operation takes the condition  as an argument. The operation either executes  if  indicates that the condition is true or  if  indicates that the condition is false. For each possibility there is one inference rule. The condition  can either be an instance of  or it can be a reference that points to an object of class type . To decide which branch to take, the operation must evaluate . If  is an instance of , then it can determine which instance  is, i.e.,  or . If  is a reference, then it must get the referenced object and see which boolean value it represents. For this purpose, it evaluates the attribute  of the referenced object.

\singlelineinferencerule
	{Conditional Operation -- True}
	{
		y \mathematicaldefinition 
			\left\{
				\begin{array}{ll}
					x & \condition{x \in \booleantype} \\
					\state.\attributevaluefeature(\state.\referencedobjectfeature(x), \booleanclasstypeitemattributename) & \condition{x \in \referencetype \wedge \state.\referencedobjectfeature(x).\classtypefeature = \booleanclasstype} \\
					\falsevalue & \otherwisecondition
				\end{array}
			\right. \\
		y = \truevalue
	}
	{
		\configuration
			{
				p :: \ \singlelineconditionaloperation
					{x}
					{s_{t}}
					{s_{f}} \statementseparator
				s_{p}
			}
			{\state}
	}
	{\configuration{p :: s_{t} \statementseparator s_{p}}{\state}}

\singlelineinferencerule
	{Conditional Operation -- False}
	{
		y \mathematicaldefinition 
			\left\{
				\begin{array}{ll}
					x & \condition{x \in \booleantype} \\
					\state.\attributevaluefeature(\state.\referencedobjectfeature(x), \booleanclasstypeitemattributename) & \condition{x \in \referencetype \wedge \state.\referencedobjectfeature(x).\classtypefeature = \booleanclasstype} \\
					\truevalue & \otherwisecondition
				\end{array}
			\right. \\
		y = \falsevalue
	}
	{
		\configuration
			{
				p :: \ \singlelineconditionaloperation
					{x}
					{s_{t}}
					{s_{f}} \statementseparator
				s_{p}
			}
			{\state}
	}
	{\configuration{p :: s_{f} \statementseparator s_{p}}{\state}}
 
The  operation has two branches. Sometimes it is necessary to only have one branch. The  operation can be executed without an effect. It can be used in the conditional operation to define an empty branch. The  operation can also be used to indicate that an action queue is empty.

\singlelineinferencerule
	{No Operation}
	{}
	{\configuration{p :: \nooperation \statementseparator s_{p}}{\state}}
	{\configuration{p :: s_{p}}{\state}}
 
\begin{fortechnicalreport}
\subsection{Code elements}
\end{fortechnicalreport}
\begin{forjournal}
\subsection{Code Elements}
\end{forjournal}
This section explains the semantics of code elements: entity expressions, literal expressions, feature calls, feature applications, creation instructions, flow control instructions, and assignment instructions.

\subsubsection{Entity expressions}
A variant of the  operation evaluates entity expressions. The operation uses the  operation to send a notification with the value of the entity over a new channel . It then uses the value of this channel to define the result of the  operation.

\singlelineinferencerule
	{Entity Expression}
	{
		e \in \entitytype \\
		\freshchanneldefinition{a'}
	}
	{\configuration{p :: \evaluateoperation(a, e) \statementseparator s_{p}}{\state}}
	{\configuration{p :: \readvalueoperation(e.\namefeature, a') \statementseparator \resultoperation(a, a'.\datafeature) \statementseparator s_{p}}{\state}}
 
\subsubsection{Literal expressions}
Another variant of the  operation evaluates literal expressions. To evaluate a non-void literal expression, the operation creates a new object of the literal class type so that the new object represents the literal value. For this purpose, it uses the query  of . Since the type of every literal is non-separate, it creates the new object on the processor that evaluates the literal expression. The reference  to the new object is the result of the evaluation. To evaluate a void literal, the operation takes the void reference.

\singlelineinferencerule
	{Literal Expression}
	{
		e \in \literaltype \\
		\state' \mathematicaldefinition
			\left\{
				\begin{array}{ll}
					 \state & \condition{e = \voidliteral} \\
					 \state.\addobjectfeature(p, e.\objectfeature) & \otherwisecondition
				\end{array}
			\right. \\
		r \mathematicaldefinition
			\left\{
				\begin{array}{ll}
					 \voidvalue & \condition{e = \voidliteral} \\
					 \state'.\referencefeature(\state'.\lastaddedobjectfeature) & \otherwisecondition
				\end{array}
			\right.
	}
	{\configuration{p :: \evaluateoperation(a, e) \statementseparator s_{p}}{\state}}
	{\configuration{p :: \resultoperation(a, r) \statementseparator s_{p}}{\state'}}
 
\subsubsection{Feature calls}\label{sec:feature calls}
A feature call can occur in two ways. First, a feature call can be a call to a command in a command instruction. Second, a feature call can be a call to a query in an expression. This section studies both variants. A processor  that executes a feature call  goes through the following steps:
\begin{enumerate}
	\item Target evaluation. Evaluate the target expression  and let  denote the handler of the target.
	\item Argument passing. Evaluate the actual arguments expressions .
	\item Lock passing. Determine which locks to pass to .
		\begin{itemize}
			\item Take all request queue locks and call stack locks if a controlled actual argument gets attached to an attached formal argument of reference type.
			\item Take all request queue locks and call stack locks if the feature call is a separate callback, i.e.,  has a lock on .
			\item Otherwise, take no locks.
		\end{itemize}
	\item Feature request.
		\begin{itemize}
			\item Ask  to apply  to the target immediately and wait until the execution terminates if any of the following conditions holds:
				\begin{itemize}
					\item The feature call is non-separate, i.e., .
					\item The feature call is a separate callback, i.e.,  has a lock on .
				\end{itemize}
			\item Otherwise, ask  to apply  to the target after the previous feature requests.
		\end{itemize}
	\item Wait by necessity. If  is a query, then wait for the result.
	\item Lock revocation. If lock passing happened, then wait for the locks to come back.
\end{enumerate}
A command instruction is a statement in the action queue. A query is an expression on the right hand side of an assignment, a condition in a flow control instruction, or an actual argument in a feature call. Whenever a query occurs in one of these constructs, the inference rule of the construct encloses the query in an  operation. To handle feature calls, there is an inference rule for command instructions and a variant of the  operation for query calls.

In each case, the statement first evaluates the target expression and all actual argument expressions. For each of these expressions , it uses one  operation and a corresponding  operation with a fresh channel . Each of the channel values gets used in the subsequent  operation. With this, the statement handled the target evaluation and the argument passing step. It defers the attachment of the actual arguments to the formal arguments to the point where the called feature gets applied. The reason for this is simple: at this point the context for the feature application does not exist yet.

The  operation takes care of the remaining steps. The operation exists in two variants, one for command instructions and one for queries. The variant for queries takes a channel  and uses it for the result of the query. Since a call to a command does not produce a result, such a channel is not required for command instructions. Both  variants take the reference to the target , the feature  to be called, the references to the actual arguments , and the actual argument expressions . The actual argument expressions are used to check whether there is a controlled actual argument. This information determines whether the locks should be passed.

\inferencerule
	{Command Instruction}
	{\forall {i \in \set{0, \ldots, n}} \colon {\freshchanneldefinition{a_{e_{i}}}}}
	{\configuration{p :: e_{0}.f(e_{1}, \ldots, e_{n}) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ & \evaluateoperation(a_{e_{0}}, e_{0}) \statementseparator \evaluateoperation(a_{e_{1}}, e_{1}) \statementseparator \ldots \statementseparator \evaluateoperation(a_{e_{n}}, e_{n}) \statementseparator \\
				& \waitoperation(a_{e_{0}}) \statementseparator \waitoperation(a_{e_{1}}) \statementseparator \ldots \statementseparator \waitoperation(a_{e_{n}}) \statementseparator \\
				& \calloperation(a_{e_{0}}.\datafeature, f, \tuple{a_{e_{1}}.\datafeature, \ldots, a_{e_{n}}.\datafeature}, \tuple{e_{1}, \ldots, e_{n}}) \statementseparator \\
				& s_{p}
			}
			{\state}
	}
 
\inferencerule
	{Query Expression}
	{
		\forall {i \in \set{0, \ldots, n}} \colon {\freshchanneldefinition{a_{e_{i}}}} \\
		\freshchanneldefinition{a'}
	}
	{\configuration{p :: \evaluateoperation(a, e_{0}.f(e_{1}, \ldots, e_{n})) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ & \evaluateoperation(a_{e_{0}}, e_{0}) \statementseparator \evaluateoperation(a_{e_{1}}, e_{1}) \statementseparator \ldots \statementseparator \evaluateoperation(a_{e_{n}}, e_{n}) \statementseparator \\
				& \waitoperation(a_{e_{0}}) \statementseparator \waitoperation(a_{e_{1}}) \statementseparator \ldots \statementseparator \waitoperation(a_{e_{n}}) \statementseparator \\
				& \calloperation(a', a_{e_{0}}.\datafeature, f, \tuple{a_{e_{1}}.\datafeature, \ldots, a_{e_{n}}.\datafeature}, \tuple{e_{1}, \ldots, e_{n}}) \statementseparator \\
				& \resultoperation(a, a'.\datafeature) \statementseparator \\
				& s_{p}
			}
			{\state}
	}
 
Both variants of the  operation take the reference to the target , the feature  to be called, the references to the actual arguments , and the actual argument expressions . The variant for queries takes an additional channel  to be used for the result of the query. In a first step, the operation must evaluate the handler  of the target. The handler is used in an  operation to issue a feature request on the responsible processor. The feature request comes in the form of an  operation. The  operation takes a channel  for the communication between  and , the target reference , the called feature , the references to the actual arguments , the caller processor , and the passed locks .

\begin{clarification}[Lock passing]
Processor  passes all its request queue locks and all its call stack locks either if there is a controlled actual argument that will get attached to an attached formal argument of reference type or if the feature call is a separate callback. An attached formal argument of reference type means that the request queue lock or the call stack lock on the actual argument's handler is required during the application of . A controlled actual argument means that  has a request queue lock or a call stack lock on the handler of the actual argument. In short,  has a lock that is required by  and thus  has to pass the locks. A separate callback occurs if  has a lock on . In this situation,  can issue a statement to  and then wait for  to complete. However, processor  could already be waiting for  to complete. To handle this case, the  operation in the  operation triggers an immediate execution by adding the  to the beginning of 's action queue. The  operation requires that  has the call stack lock of . To enable  to perform an immediate execution,  has to give back 's call stack lock.

In both cases,  has to wait for the locks to come back. Thus it does not hurt to pass all the locks in both cases. In contrast to Nienaltowski's \cite{nienaltowski:2007:SCOOP} description of SCOOP,  only passes the locks that it really has. In particular,  does not pass its own request queue lock in situations where  does not possess this lock, such as when the processor that called  possesses 's request queue lock.
\end{clarification}

In the cases where the operation passes the locks,  is . In all other cases there is no lock passing and thus . The operation just determines which locks to pass. The actual lock passing action will be executed by . Similarly, the actual lock revocation action will be executed by .

For command calls, lock passing is the only reason to wait. In this case, the operation creates a fresh channel  to wait for a notification from . The notification arrives when  is ready to return the locks. For query calls, the operation has to wait for the result. The operation uses the given channel  to wait for the result. This has the advantage that once the result arrives, it will be substituted after the  operation, i.e.\ in the  operation of the  operation.

\inferencerule
	{Call Operation -- Command}
	{
		q \mathematicaldefinition \state.\handlerfeature(r_{0}) \\
		\overline{l} \mathematicaldefinition 
			\left\{
				\begin{split}
					& \multilinecondition{
						& q \neq p \wedge 
						\exists i \in \set{1, \ldots, n} \colon \typingenvironmentderivation{e_{i}: t \wedge \iscontrolledfeature(t)} \wedge 
						\typingenvironmentderivation{f.\formalargumentsfeature(i): (!, g, c) \wedge c.\isreferenceclasstypefeature}
					} \\
					& \indentation \tuple{\state.\requestqueuelocksfeature(p), \state.\callstacklocksfeature(p)} \\
					& \multilinecondition{
						& q \neq p \wedge
						(\state.\requestqueuelocksfeature(q).\containsfeature(p) \vee \state.\callstacklocksfeature(q).\containsfeature(p))
					} \\
					& \indentation \tuple{\state.\requestqueuelocksfeature(p), \state.\callstacklocksfeature(p)} \\
					& \otherwisecondition \\
					& \indentation \tuple{\set{}, \set{}}
				\end{split}
			\right. \\
		\freshchanneldefinition{a}
	}
	{\configuration{p :: \calloperation(r_{0}, f, \tuple{r_{1}, \ldots, r_{n}}, \tuple{e_{1}, \ldots, e_{n}}) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ & \issueoperation(q, \applyoperation(a, r_{0}, f, \tuple{r_{1}, \ldots, r_{n}}, p, \overline{l})) \statementseparator \\
				& \singlelineconditionaloperation
					{\overline{l} \neq \tuple{\set{}, \set{}}}
					{\waitoperation(a)}
					{\nooperation} \statementseparator \\
				& s_{p}
			}
			{\state}
	}
 
\inferencerule
	{Call Operation -- Query}
	{
		q \mathematicaldefinition \state.\handlerfeature(r_{0}) \\
		\overline{l} \mathematicaldefinition 
			\left\{
				\begin{split}
					& \multilinecondition{
						& q \neq p \wedge
						\exists i \in \set{1, \ldots, n} \colon \typingenvironmentderivation{e_{i}: t \wedge \iscontrolledfeature(t)} \wedge
						\typingenvironmentderivation{f.\formalargumentsfeature(i): (!, g, c) \wedge c.\isreferenceclasstypefeature}
					} \\
					& \indentation \tuple{\state.\requestqueuelocksfeature(p), \state.\callstacklocksfeature(p)} \\
					& \multilinecondition{
						& q \neq p \wedge
						(\state.\requestqueuelocksfeature(q).\containsfeature(p) \vee \state.\callstacklocksfeature(q).\containsfeature(p))
					} \\
					& \indentation \tuple{\state.\requestqueuelocksfeature(p), \state.\callstacklocksfeature(p)} \\
					& \otherwisecondition \\
					& \indentation \tuple{\set{}, \set{}}
				\end{split}
			\right.
	}
	{\configuration{p :: \calloperation(a, r_{0}, f, \tuple{r_{1}, \ldots, r_{n}}, \tuple{e_{1}, \ldots, e_{n}}) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{p ::
				\issueoperation(q, \applyoperation(a, r_{0}, f, \tuple{r_{1}, \ldots, r_{n}}, p, \overline{l})) \statementseparator
				\waitoperation(a) \statementseparator
				s_{p}
			}
			{\state}
	}
 
\begin{fortechnicalreport}
\begin{example}[Feature call]
This example demonstrates the inference rules for feature calls. For this purpose, consider again the share market example. Suppose the root processor  started with the execution of the procedure  on the root object . This procedure is shown in \listingreference{lst:application class with implementation}.

\begin{lstlisting}[caption=Application class with implementation, label=lst:application class with implementation, language=SCOOP, escapechar=\%]
class APPLICATION

create
  make

feature -- Initialization
  make
    do
      ...
    end

feature {APPLICATION} -- Implementation
  market: separate MARKET
      -- The market.
			
  do_transaction (
    first_investor: separate INVESTOR;
    second_investor: separate INVESTOR;
    issuer_id: INTEGER
  )
      -- Make each of the two investors buy and then sell a share of the issuer.
    do
      first_investor.buy (Current.market, issuer_id)
      second_investor.buy (Current.market, issuer_id)
      first_investor.sell (Current.market, issuer_id)
      second_investor.sell (Current.market, issuer_id)
    end
end
\end{lstlisting}

The following configuration is our starting point. Processor  has one environment for the callee procedure  and one for the called procedure . Processor  handles the market object , processor  handles the first investor object , and processor  handles the second investor object . The market object references three arrays. The cash array  shows that each investor has the same amount of cash. The available shares array  shows that there is one issuer with one available share. The owned shares array  shows that none of the investors owns a share. The action queue of  indicates that  is about to make the feature calls on the two investors. For this purpose,  obtained the request queue locks of their handlers.

\isolatedconfiguration
	{
		p_{1} :: \ & first\_investor.buy(\currententity.market, issuer\_id) \statementseparator \\
		& second\_investor.buy(\currententity.market, issuer\_id) \statementseparator \\
		& first\_investor.sell(\currententity.market, issuer\_id) \statementseparator \\
		& second\_investor.sell(\currententity.market, issuer\_id) \statementseparator \\
		& \ldots \processorseparator \\
		p_{2} :: & \processorseparator
		p_{3} :: \processorseparator
		p_{4} ::
	}
	{
		\simplifiedstate
			{
				& \simplifiedstatelocksentry
					{p_{1}}
					{\set{}, \set{p_{3}, p_{4}}}
					{\set{}, \set{}}
					{\set{}, \set{}}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator} \\
				& \simplifiedstatelocksentry
					{p_{2}}
					{}
					{}
					{}
					{\simplifiedstateunlockedindicator}
					{\simplifiedstatenopassedlocksindicator} \\
				& \simplifiedstatelocksentry
					{p_{3}}
					{}
					{}
					{}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator} \\
				& \simplifiedstatelocksentry
					{p_{4}}
					{}
					{}
					{}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator}
			}
			{
				& \simplifiedstateobjectsentry
					{p_{1}}
					{
						\simplifiedstatereferencedobject{r_{0}}{o_{0}(\simplifiedstateentityvalue{market}{r_{1}})}, \simplifiedstatereferencedobject{r_{39}}{o_{48}(1)}
					} \\
				& \simplifiedstateobjectsentry
					{p_{2}}
					{
						& \simplifiedstatereferencedobject{r_{1}}{o_{35}(\simplifiedstateentityvalue{cash}{r_{16}}, \simplifiedstateentityvalue{available\_shares}{r_{23}}, \simplifiedstateentityvalue{owned\_shares}{r_{29}})}, \\
						& \simplifiedstatereferencedobject{r_{16}}{o_{25}[r_{21}, r_{22}]}, \simplifiedstatereferencedobject{r_{21}}{o_{23}(100)}, \simplifiedstatereferencedobject{r_{22}}{o_{24}(100)}, \\
						& \simplifiedstatereferencedobject{r_{23}}{o_{33}[r_{28}]}, \simplifiedstatereferencedobject{r_{28}}{o_{32}(1)}, \\
						& \simplifiedstatereferencedobject{r_{29}}{o_{38}[[r_{34}], [r_{35}]]}, \simplifiedstatereferencedobject{r_{34}}{o_{41}(0)}, \simplifiedstatereferencedobject{r_{35}}{o_{42}(0)}
					} \\
				& \simplifiedstateobjectsentry
					{p_{3}}
					{
						\simplifiedstatereferencedobject{r_{6}}{o_{44}(\simplifiedstateentityvalue{id}{r_{36}})},
						\simplifiedstatereferencedobject{r_{36}}{o_{43}(1)}
					} \\
				& \simplifiedstateobjectsentry
					{p_{4}}
					{
						\simplifiedstatereferencedobject{r_{8}}{o_{46}(\simplifiedstateentityvalue{id}{r_{37}})},
						\simplifiedstatereferencedobject{r_{37}}{o_{45}(2)}
					}
			}
			{}
			{
				& \simplifiedstateenvironmentsentry
					{p_{1}}
					{
						& \simplifiedstateentityvalue{first\_investor}{r_{6}}, \simplifiedstateentityvalue{second\_investor}{r_{8}}, \simplifiedstatecurrententityvalue{r_{0}} \simplifiedstateenvironmentsentryseparator \\
						& \simplifiedstateentityvalue{first\_investor}{r_{6}}, \simplifiedstateentityvalue{second\_investor}{r_{8}}, \simplifiedstateentityvalue{issuer\_id}{r_{39}}, \simplifiedstatecurrententityvalue{r_{0}}
					} \\
				& \simplifiedstateenvironmentsentry
					{p_{2}}
					{} \\
				& \simplifiedstateenvironmentsentry
					{p_{3}}
					{} \\
				& \simplifiedstateenvironmentsentry
					{p_{4}}
					{}
			}
	}

The inference rule for command instructions leads to the following configuration, with fresh channels , , and :

\isolatedconfiguration
	{
		p_{1} :: \ & \evaluateoperation(a_{59}, first\_investor) \statementseparator \\
		& \evaluateoperation(a_{60}, \currententity.market) \statementseparator \\
		& \evaluateoperation(a_{61}, issuer\_id) \statementseparator \\
		& \waitoperation(a_{59}) \statementseparator \\
		& \waitoperation(a_{60}) \statementseparator \\
		& \waitoperation(a_{61}) \statementseparator \\
		& \calloperation(a_{59}.\datafeature, buy, \tuple{a_{60}.\datafeature, a_{61}.\datafeature}, \tuple{\currententity.market, issuer\_id}) \statementseparator \\
		& second\_investor.buy(\currententity.market, issuer\_id) \statementseparator \\
		& first\_investor.sell(\currententity.market, issuer\_id) \statementseparator \\
		& second\_investor.sell(\currententity.market, issuer\_id) \statementseparator \\
		& \ldots \processorseparator \\
		p_{2} :: & \processorseparator
		p_{3} :: \processorseparator
		p_{4} ::
	}
	{\ldots}

First  has to evaluate the target expression and the actual argument expressions. This leads to the following configuration:

\isolatedconfiguration
	{
		p_{1} :: \ & \calloperation(r_{6}, buy, \tuple{r_{1}, r_{39}}, \tuple{\currententity.market, issuer\_id}) \statementseparator \\
		& second\_investor.buy(\currententity.market, issuer\_id) \statementseparator \\
		& first\_investor.sell(\currententity.market, issuer\_id) \statementseparator \\
		& second\_investor.sell(\currententity.market, issuer\_id) \statementseparator \\
		& \ldots \processorseparator \\
		p_{2} :: & \processorseparator
		p_{3} :: \processorseparator
		p_{4} ::
	}
	{\ldots}

During the execution of the  operation,  determines that no locks need to be passed. Then  executes an  operation to enqueue an  operation to the action queue of the first investor's handler.
\end{example}
\end{fortechnicalreport}

\subsubsection{Feature applications}\label{sec:feature applications}
A feature call by a client processor  results in a feature request for a supplier processor . A \emph{feature application} is the serving of the feature request. This section discusses how  applies a feature  on a target referenced by . Processor  takes the following steps:
\begin{enumerate}
	\item Once status update. If  is a once routine, then set its status to non-fresh.
	\item Lock passing. Pass the locks from  to .
	\item Argument passing. Bind the actual arguments to the formal arguments. Arguments of expanded type that are handled by a different processor than  must be deep imported by .
	\item Synchronization. Involve the scheduler to wait until the following synchronization conditions are satisfied atomically:
		\begin{itemize}
			\item Processor  owns the request queue lock of each processor  such that:
				\begin{itemize}
					\item Processor  handles an actual argument of  and the corresponding formal argument has an attached reference type.
					\item Processor  and processor  are different.
					\item Processor  does not have 's request queue lock.
					\item Processor  does not have 's request queue lock.
				\end{itemize}
			\item The precondition of  holds.
		\end{itemize}
	\item Execution.
		\begin{itemize}
			\item If  is a non-once routine or a fresh once routine, then run its body.
			\item If  is a non-fresh procedure, then do nothing. If  is a non-fresh function, then take its once value as the result.
			\item If  is an attribute, then evaluate it.
		\end{itemize}
	\item Postcondition evaluation. Evaluate the postcondition if any of the following conditions is satisfied:
		\begin{itemize}
			\item A feature call in the postcondition requires a lock that was not obtained in the synchronization step.
			\item The evaluation of the postcondition involves lock passing.
		\end{itemize}
		Otherwise ask any processor whose request queue lock was obtained in the synchronization step to evaluate the postcondition.
	\item Lock releasing. Ask each processor whose request queue has been locked in the synchronization step to unlock its request queue after it is done with the feature requests issued by .
	\item Invariant evaluation. If  is a routine, then evaluate the invariant.
	\item Result returning. If  is a query, then return the result to . If the result is of expanded type and , then the result must be deep imported by .
	\item Lock revocation. Return the passed locks from  to .
\end{enumerate}
Each feature application starts with an operation  in the action queue of processor . The channel  is used to communicate with the client processor . If the called feature  is a procedure and the caller processor  passed some locks, then  is used to signal that the locks returned. If  is query, then  is used to return the value. The reference  points to the target of the call. The references  point to the actual arguments. The tuple  contains the locks to be passed from  to .

If one takes a look at the execution step, one can differentiate three cases:
\begin{itemize}
	\item The feature  is a non-once routine or a fresh once routine.
	\item The feature  is a non-fresh once routine.
	\item The feature  is an attribute.
\end{itemize}
For each of these cases, there is one inference rule. Each inference rule covers one variant of the  operation. The discussion continues with the most involved case: the feature  is a non-once routine or a fresh once routine.

\inferencerule
	{Application Operation -- Non-Once Routine or Fresh Once Routine}
	{
		f \in \routinetype \wedge f.\isonceroutinefeature \rightarrow \state.\isonceroutinefreshfeature(p, f) \\
		\state.\handlerfeature(r_{0}) = p \\
		\neg \state.\passlocksfeature(q, p, \overline{l}).\arelockspassedfeature(p) \\
		\state' \mathematicaldefinition
			\left\{
				\begin{array}{ll}
					\state.\setoncefunctionnotfreshfeature(p, f, \voidvalue) & \condition{f \in \functiontype \wedge f.\isonceroutinefeature} \\
					\state.\setonceprocedurenotfreshfeature(p, f) & \condition{f \in \proceduretype \wedge f.\isonceroutinefeature} \\
					\state & \otherwisecondition
				\end{array}
			\right. \\
		\state'' \mathematicaldefinition \state'.\passlocksfeature(q, p, \overline{l}).\pushenvironmentwithfeaturefeature(p, f, r_{0}, \tuple{r_{1}, \ldots, r_{n}}) \\
		\begin{split}
			& \overline{g}_{required\_locks} \mathematicaldefinition \set{p} \cup \\
			& \indentation \setinference{x \in \processortype}{\exists i \in \set{1, \ldots, n}, g, c \colon \typingenvironmentderivation{f.\formalargumentsfeature(i): (!, g, c) \wedge c.\isreferenceclasstypefeature} \wedge x = \state''.\handlerfeature(r_{i})}
		\end{split} \\
		\begin{split}
			& \overline{g}_{required\_cs\_locks} \mathematicaldefinition \\
			& \indentation \setinference{x \in \overline{g}_{required\_locks}}{x = p \vee (x \neq p \wedge (\state''.\requestqueuelocksfeature(x).\containsfeature(p) \vee \state''.\callstacklocksfeature(x).\containsfeature(p)))}
		\end{split} \\
		\overline{g}_{required\_rq\_locks} \mathematicaldefinition \overline{g}_{required\_locks} \setminus \overline{g}_{required\_cs\_locks} \\
		\overline{g}_{missing\_rq\_ locks} \mathematicaldefinition \setinference{x \in \overline{g}_{required\_rq\_locks}}{\neg \state''.\requestqueuelocksfeature(p).\containsfeature(x)} \\
		\forall x \in \overline{g}_{required\_cs\_locks} \colon \state''.\callstacklocksfeature(p).\containsfeature(x) \\
		\freshchanneldefinition{a_{inv}} \wedge \freshchanneldefinition{a'}
	}
	{\configuration{p :: \applyoperation(a, r_{0}, f, \tuple{r_{1}, \ldots, r_{n}}, q, \overline{l}) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ & \checkpreconditionandlockrequestqueuesoperation(\overline{g}_{missing\_rq\_ locks}, f) \statementseparator \\
				\multilineconditionaloperation
					{f \in \functiontype \wedge f.\isonceroutinefeature}
					{
						\begin{split}
							& f.\bodyfeature \\
							& \indentation \begin{split}
								& \begin{split}
									\substitution
										{
											\resultentity \eassignment y \statementseparator
											\setonceroutinenotfreshwithresultoperation(f)
										}
										{
											\resultentity \eassignment y
										}
								\end{split} \\
								& \begin{split}
									\substitution
										{
											\ecreate \resultentity.y \statementseparator
											\setonceroutinenotfreshwithresultoperation(f)
										}
										{
											\ecreate \resultentity.y
										}
								\end{split}
							\end{split}
						\end{split}
					}
					{f.\bodyfeature} \statementseparator \\
				& \checkpostconditionandunlockrequestqueuesoperation(\overline{g}_{missing\_rq\_ locks}, f) \statementseparator \\
				\multilineconditionaloperation
					{f.\classtypefeature.\invariantexistsfeature \wedge f.\isexportedfeature}
					{\evaluateoperation(a_{inv}, f.\classtypefeature.\invariantfeature) \statementseparator \waitoperation(a_{inv})}
					{\nooperation} \statementseparator \\
				\multilineconditionaloperation
					{f \in \functiontype}
					{\readvalueoperation(\resultentityname, a') \statementseparator \returnoperation(a, a'.\datafeature, q)}
					{\returnoperation(a, q)} \statementseparator \\
				& s_{p}}
			{\state''}
	}
 
The condition of the inference rule states that each processor can only apply a feature on one of its own objects. The condition also states the  must not have passed its locks. This part of the condition is always given because  waits whenever it passes its locks. In a first step, the operation defines an updated state  to set 's once status to non-fresh, in case  is a once routine. The operation does this before deep importing the actual arguments to avoid the following contradiction.

\begin{clarification}[When to change the status of a fresh once routine]
Assume  is either a once procedure or a non-separate once routine. The feature  was fresh at the beginning of the  operation. Assume that the caller passed an expanded actual argument that is handled by a processor . Therefore  has to deep import the actual argument. Assume furthermore that the class type of the actual argument has the once routine  and that  is non-fresh on . If the operation would deep import before setting  as non-fresh on , then the deep import operation would take over the once status of  from processor  to processor . But then the  operation on  would not make much sense anymore because  would now be non-fresh on . If the operation sets  as non-fresh at the beginning of the  operation, then the deep import operation does not take over the once status from  because  is already non-fresh on .
\end{clarification}

The operation defines an updated state  in which the locks are passed from  to  and in which there is a new environment with the actual arguments . The call to the  feature takes care of copying and deep importing actual arguments of expanded type. The caller processor  can also pass an empty tuple  which simply means that  did not pass any locks.

In the next step, the operation synchronizes. For each target expressions in the body of , the operation can get the controlling entity. Each of these controlling entities is mapped to an object and each of these objects is handled by a processor. For each of these processors the operation must either get a request queue lock or a call stack lock. There are three types of calls: non-separate calls, separate calls, and separate callbacks. Non-separate calls and separate callbacks require a call stack lock. Separate calls require a request queue lock. This leads to two sets of required locks: one set with required request queue locks and another set with required call stack locks. The set of required call stack locks is composed of  that will lead to a non-separate call and all the processors that will lead to separate callbacks. The set of required request queue locks is composed of the processors that will lead to separate calls. The operation defines two sets for these two categories:  and .

Each processor initially has its own call stack lock as its obtained call stack lock. This call stack never gets unlocked. This means that other call stack locks cannot be obtained; they must be retrieved through lock passing. The condition of the inference rule expresses this: . The operation can be assured that  did not pass its own call stack lock because otherwise  would be waiting. The remaining required call stack locks are the ones for the processors that will lead to separate callbacks. Note that the lock passing conditions are not sufficient to guarantee that the call stack locks for separate callbacks are always available.

As for the request queue locks, the operation calculates  as the required request queue locks minus the already owned request queue locks. The already owned request queue locks are the previously obtained request queue locks and the retrieved request queue locks. In the synchronization step, the operation must obtain the difference. If this is not possible because some of the missing request queue locks are not available, then the operation must wait. The  operation takes care of this; it takes  and the feature . Once the execution succeeds,  has the request queue locks of  and the precondition of  holds.

The  operation can be assured that each processor , whose obtained request queue lock the operation got in the synchronization step, must be in possession of its call stack lock. If  was not in possession of its call stack lock, it must have passed its locks. This means that  is executing a feature call and still waiting for the locks to return. In order to execute the feature call, there must have been a lock on 's request queue lock so that its action queue can contain the feature call. The request queue must still be locked because  is still executing the feature call. Hence, it would not have been possible to obtain 's request queue lock. The only exception is the bootstrap processor. However this processor only plays a role in the system setup and it never passes its own call stack lock.

Once the operation got all the required locks, it can execute the body. For once functions it must update the once status whenever it writes to the result entity as part of an assignment instruction or as part of a creation instruction. For this purpose, it adds a  operation after each assignment instruction or creation instruction.

After the execution of the body, the operation has to evaluate the postcondition and it has to make sure that the locked request queues get unlocked at the right time. These two steps are performed by another operation  that takes the missing request queue locks  and the feature . This operation evaluates the postcondition either synchronously or asynchronously. After the evaluation of the postcondition, the operation enqueues an  operation to each request queue in .

SCOOP relies on the Eiffel invariant mechanism. This mechanism is described in \externalsectionreference{7.5} and \externalsectionreference{8.9.16} of the Eiffel ECMA standard \cite{ecma:2006:Eiffel}. On one hand, \externalsectionreference{7.5} describes the semantics of invariants: invariants must be satisfied after the execution of every exported routine and after the execution of every creation procedure. On the other hand, \externalsectionreference{8.9.16} describes the runtime monitoring of invariants: invariants get evaluated on both start and termination of a qualified call to a routine and after every call to a creation procedure. We had to decide whether to rely on the semantics of invariants or on the runtime monitoring of invariants. We decided to rely on the semantics of invariants for two reasons. First, the runtime invariant monitoring mechanism is only one possible implementation of the invariant semantics. Second, the runtime invariant monitoring mechanism relies on the notion of unqualified calls. However, for simplicity this work assumes feature calls to be in the canonical qualified form. The  operation reflects this decision: the operation evaluates the invariant whenever  is exported. Note that the invariant can only contain non-separate target expressions. Hence, each call in the invariant will only require 's call stack lock.

Finally, the operation has to return the locks and it has to return the result if  is a function. The  operation takes care of this. It comes in a variant for queries and in a variant for commands. Both variants take the channel  and the caller processor  in order to communicate with . The variant for queries additionally takes the value to be returned to .

Before explaining the variants of the  operation for non-fresh once routines and attributes, the discussion continues with the operations that have not been discussed in detail so far, namely , , and .

\begin{fortechnicalreport}
\inferencerule
	{Check Precondition and Lock Request Queues Operation}
	{\freshchanneldefinition{a}}
	{\configuration{p :: \checkpreconditionandlockrequestqueuesoperation(\set{q_{1}, \ldots, q_{m}}, f) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ & \lockrequestqueuesoperation(\set{q_{1}, \ldots, q_{m}}) \statementseparator \\
				\multilineconditionaloperation
					{f.\preconditionexistsfeature}
					{
						\begin{split}
							& \evaluateoperation(a, f.\preconditionfeature) \statementseparator \\
							& \waitoperation(a) \statementseparator \\
							\multilineconditionaloperation
								{a.\datafeature}
								{\nooperation}
								{
									\begin{split}
										& \issueoperation(q_{1}, \unlockrequestqueueoperation) \statementseparator \\
										& \ldots \\
										& \issueoperation(q_{m}, \unlockrequestqueueoperation) \statementseparator \\
										& \popobtainedrequestqueuelocksoperation \statementseparator \\
										& \checkpreconditionandlockrequestqueuesoperation(\set{q_{1}, \ldots, q_{m}}, f)
									\end{split}
								}
						\end{split}
					}
					{\nooperation} \statementseparator \\
				& s_{p}}
			{\state}
	}
 \end{fortechnicalreport}

\begin{forjournal}
\inferencerule
	{Check Precondition and Lock Request Queues Operation}
	{\freshchanneldefinition{a}}
	{\configuration{p :: \checkpreconditionandlockrequestqueuesoperation(\set{q_{1}, \ldots, q_{m}}, f) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ & \lockrequestqueuesoperation(\set{q_{1}, \ldots, q_{m}}) \statementseparator \\
				\multilineconditionaloperation
					{f.\preconditionexistsfeature}
					{
						\begin{split}
							& \evaluateoperation(a, f.\preconditionfeature) \statementseparator \\
							& \waitoperation(a) \statementseparator \\
							\multilineconditionaloperation
								{a.\datafeature}
								{\nooperation}
								{
									\begin{split}
										& \issueoperation(q_{1}, \unlockrequestqueueoperation) \statementseparator \\
										& \ldots \\
										& \issueoperation(q_{m}, \unlockrequestqueueoperation) \statementseparator \\
										& \popobtainedrequestqueuelocksoperation \statementseparator \\
										& \checkpreconditionandlockrequestqueuesoperation(\set{q_{1}, \ldots, q_{m}}, f)
									\end{split}
								}
						\end{split}
					}
					{\nooperation} \statementseparator \\
				& s_{p}}
			{\state}
	}
 \end{forjournal}

The  operation, executed by processor , takes a processor set  whose request queues must be locked on behalf of  and it takes a feature  whose precondition must be satisfied. The operation treats the precondition as a wait condition. It goes through a number of iterations. Each iteration obtains the request queue locks and then evaluates the precondition. If the precondition is satisfied, then the  operation finishes. Otherwise it unlocks the request queues and then starts a new iteration.

\begin{fortechnicalreport}
\inferencerule
	{Check Postcondition and Unlock Request Queues Operation}
	{
		\overline{q} \mathematicaldefinition \set{q_{1}, \ldots, q_{m}} \\
		p \notin \overline{q} \\
		\targetsfeature(e) \mathematicaldefinition
		\left\{
			\begin{array}{ll}
				\set{e_{0}} \cup \bigcup_{i = 0 \ldots n}^{}{\targetsfeature(e_{i})} & \condition{e = e_{0}.w(e_{1}, \ldots, e_{n})} \\
				\set{} & \otherwisecondition
			\end{array}
		\right. \\
		\actualargumentsfeature(e) \mathematicaldefinition
		\left\{
			\begin{array}{ll}
				\bigcup_{i = 1 \ldots n}^{}{\set{\tuple{e_{i}, w, i}} \cup \actualargumentsfeature(e_{i})} & \condition{e = e_{0}.w(e_{1}, \ldots, e_{n})} \\
				\set{} & \otherwisecondition
			\end{array}
		\right. \\
		g_{0} \mathematicalelementdefinition
			\left\{
				\begin{split}
					& \multilinecondition{
						& \overline{q} \neq \set{} \wedge \\
						& \forall {x \in \targetsfeature(f.\postconditionfeature)} \colon (\typingenvironmentderivation{\state.\handlerfeature(\state.\valuefeature(p, \controllingentityfeature(x).\namefeature)) \in \overline{q}}) \wedge \\
						& \begin{split}
							& \neg \exists \tuple{x, y, z} \in \actualargumentsfeature(f.\postconditionfeature), t, h, c \colon \\
							& \indentation (\typingenvironmentderivation{x: t \wedge \iscontrolledfeature(t) \wedge y.\formalargumentsfeature(z): (!, h, c) \wedge c.\isreferenceclasstypefeature})
						\end{split}
					} \\
					& \indentation \overline{q} \\
					& \otherwisecondition \\
					& \indentation \set{p}
				\end{split}
			\right. \\
		\set{g_{1}, \ldots, g_{j}} \mathematicaldefinition \overline{q} \setminus g_{0} \\
		\freshchanneldefinition{a}
	}
	{\configuration{p :: \checkpostconditionandunlockrequestqueuesoperation(\set{q_{1}, \ldots, q_{m}}, f) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ \multilineconditionaloperation
					{f.\postconditionexistsfeature \wedge g_{0} \neq p}
					{
						\begin{split}
							& \begin{split}
								& \issueoperation( \\
								& \indentation \begin{split}
									& g_{0}, \\
									& \executedelegatedoperation( \\
									& \indentation \begin{split}
										& \indentation \begin{split}
											& \evaluateoperation(a, f.\postconditionfeature) \statementseparator \waitoperation(a) \statementseparator \\
											& \issueoperation(g_{1}, \unlockrequestqueueoperation) \statementseparator \ldots \statementseparator \issueoperation(g_{j}, \unlockrequestqueueoperation)
										\end{split} \\
										& , \\
										& \indentation \state.\environmentsfeature(p).\topfeature, \set{q_{1}, \ldots, q_{m}}
									\end{split} \\
									& ) \statementseparator \\
									& \unlockrequestqueueoperation
								\end{split}	\\
								& ) \statementseparator
							\end{split} \\
							& \popobtainedrequestqueuelocksoperation
						\end{split}
					}
					{
						\begin{split}
							\multilineconditionaloperation
								{f.\postconditionexistsfeature}
								{\evaluateoperation(a, f.\postconditionfeature) \statementseparator \waitoperation(a)}
								{\nooperation} \statementseparator \\
							& \issueoperation(q_{1}, \unlockrequestqueueoperation) \statementseparator \ldots \statementseparator \issueoperation(q_{m}, \unlockrequestqueueoperation) \statementseparator \\
							& \popobtainedrequestqueuelocksoperation
						\end{split}
					} \statementseparator \\
				& s_{p}
			}
			{\state}
	}
 \end{fortechnicalreport}

The  operation also takes a processor set  and a feature . The processor set is the same as for the   operation, i.e., the set of processors whose request queues got locked in the synchronization step. The operation first determines whether the postcondition should be evaluated synchronously or asynchronously. Then the operation starts the evaluation. Finally, the operation enqueues an  operation to each request queue in .

\begin{forjournal}
\inferencerule
	{Check Postcondition and Unlock Request Queues Operation}
	{
		\overline{q} \mathematicaldefinition \set{q_{1}, \ldots, q_{m}} \\
		p \notin \overline{q} \\
		\targetsfeature(e) \mathematicaldefinition
		\left\{
			\begin{array}{ll}
				\set{e_{0}} \cup \bigcup_{i = 0 \ldots n}^{}{\targetsfeature(e_{i})} & \condition{e = e_{0}.w(e_{1}, \ldots, e_{n})} \\
				\set{} & \otherwisecondition
			\end{array}
		\right. \\
		\actualargumentsfeature(e) \mathematicaldefinition
		\left\{
			\begin{array}{ll}
				\bigcup_{i = 1 \ldots n}^{}{\set{\tuple{e_{i}, w, i}} \cup \actualargumentsfeature(e_{i})} & \condition{e = e_{0}.w(e_{1}, \ldots, e_{n})} \\
				\set{} & \otherwisecondition
			\end{array}
		\right. \\
		g_{0} \mathematicalelementdefinition
			\left\{
				\begin{split}
					& \multilinecondition{
						& \overline{q} \neq \set{} \wedge \\
						& \forall {x \in \targetsfeature(f.\postconditionfeature)} \colon (\typingenvironmentderivation{\state.\handlerfeature(\state.\valuefeature(p, \controllingentityfeature(x).\namefeature)) \in \overline{q}}) \wedge \\
						& \begin{split}
							& \neg \exists \tuple{x, y, z} \in \actualargumentsfeature(f.\postconditionfeature), t, h, c \colon \\
							& \indentation (\typingenvironmentderivation{x: t \wedge \iscontrolledfeature(t) \wedge y.\formalargumentsfeature(z): (!, h, c) \wedge c.\isreferenceclasstypefeature})
						\end{split}
					} \\
					& \indentation \overline{q} \\
					& \otherwisecondition \\
					& \indentation \set{p}
				\end{split}
			\right. \\
		\set{g_{1}, \ldots, g_{j}} \mathematicaldefinition \overline{q} \setminus g_{0} \\
		\freshchanneldefinition{a}
	}
	{\configuration{p :: \checkpostconditionandunlockrequestqueuesoperation(\set{q_{1}, \ldots, q_{m}}, f) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ \multilineconditionaloperation
					{f.\postconditionexistsfeature \wedge g_{0} \neq p}
					{
						\begin{split}
							& \begin{split}
								& \issueoperation( \\
								& \indentation \begin{split}
									& g_{0}, \\
									& \executedelegatedoperation( \\
									& \indentation \begin{split}
										& \indentation \begin{split}
											& \evaluateoperation(a, f.\postconditionfeature) \statementseparator \waitoperation(a) \statementseparator \\
											& \issueoperation(g_{1}, \unlockrequestqueueoperation) \statementseparator \ldots \statementseparator \issueoperation(g_{j}, \unlockrequestqueueoperation)
										\end{split} \\
										& , \\
										& \indentation \state.\environmentsfeature(p).\topfeature, \set{q_{1}, \ldots, q_{m}}
									\end{split} \\
									& ) \statementseparator \\
									& \unlockrequestqueueoperation
								\end{split}	\\
								& ) \statementseparator
							\end{split} \\
							& \popobtainedrequestqueuelocksoperation
						\end{split}
					}
					{
						\begin{split}
							\multilineconditionaloperation
								{f.\postconditionexistsfeature}
								{\evaluateoperation(a, f.\postconditionfeature) \statementseparator \waitoperation(a)}
								{\nooperation} \statementseparator \\
							& \issueoperation(q_{1}, \unlockrequestqueueoperation) \statementseparator \ldots \statementseparator \issueoperation(q_{m}, \unlockrequestqueueoperation) \statementseparator \\
							& \popobtainedrequestqueuelocksoperation
						\end{split}
					} \statementseparator \\
				& s_{p}
			}
			{\state}
	}
 \end{forjournal}

\begin{clarification}[Asynchronous postcondition evaluation]
The postcondition can be evaluated asynchronously if every feature call in the postcondition only requires a request queue lock that was obtained in the synchronization step and if the postcondition does not involve lock passing. If the postcondition has a feature call that requires a lock different from the obtained request queue locks, then  cannot delegate its obtained request queue lock and then continue because the required lock would be required in another feature execution context as well. Hence the postcondition must be evaluated synchronously in this case. If the postcondition involves lock passing, then one of 's lock might be necessary for the evaluation of the postcondition. Hence,  must pass its locks and cannot proceed until the postcondition is evaluated and the passed locks returned. Once again, the postcondition must be evaluated synchronously. In Nienaltowski's description of SCOOP \cite{nienaltowski:2007:SCOOP} a postcondition can be evaluated asynchronously if the current processor is not involved in the postcondition evaluation. This rule permits configurations in which the evaluating processor does not have the necessary locks for the evaluation.
\end{clarification}

If the postcondition can be evaluated asynchronously, then the operation can take one of the processors in . This set does not contain processor  because processor  never obtains its own request queue lock. Each processor in this set is exclusively available in the current execution context and can thus be used to evaluate the postcondition asynchronously. The  operation defines  to be the evaluating processor according to the rule just presented. It also defines  to be the set  minus the request queue lock of . If  is the evaluating processor, then this set is the same as . As a result of these definitions, the postcondition can be evaluated asynchronously if . Otherwise, the postcondition must be evaluated synchronously.

In the synchronous case, processor  evaluates the postcondition, enqueues  operations to each request queue in , and then removes the corresponding locks from its stack of obtained request queue locks. The  operations will not proceed until the locks have been removed from 's stack of obtained request queue locks. In the asynchronous case, processor  must delegate the postcondition evaluation to processor . For this purpose,  enqueues an  operation to . The workload involves the postcondition evaluation along with the subsequent issuing of  operations to all processor in . Processor  unlocks its own request queue after the delegated execution. The evaluation of the postcondition on  requires the environment that defines the values of the entities in the postcondition. Furthermore, the evaluation requires the request queue locks . These locks are sufficient because the postcondition only gets evaluated asynchronously if the evaluation only requires these locks. To satisfy these two requirements,  gives its top environment and  to . After  performed the delegated execution, it can unlock its own request queue. In the meantime, processor  removes  from its obtained request queue locks to enable  to proceed with the delegated execution.

The  operation comes in two variants: one for queries and one for commands.

\singlelineinferencerule
	{Return Operation -- Query}
	{
		\begin{split}
			& \tuple{\state', r'} \mathematicaldefinition
				\left\{
					\begin{split}
						& \condition{r \neq \voidvalue \wedge \state.\referencedobjectfeature(r).\classtypefeature.\isexpandedclasstypefeature \wedge \state.\handlerfeature(r) \neq q} \\
						& \indentation \where
							{\tuple{\state_{x}, \state_{x}.\lastimportedreferencefeature}}
							{\state_{x} \mathematicaldefinition \state.\deepimportfeature(q, r)} \\
							& \otherwisecondition \\
							& \indentation \tuple{\state, r}
					\end{split}
				\right.
		\end{split} \\
		\state'' \mathematicaldefinition \state'.\popenvironmentfeature(p).\revokelocksfeature(q, p)
	}
	{\configuration{p :: \returnoperation(a, r, q) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{p :: \resultoperation(a, r') \statementseparator s_{p}}
			{\state''}
	}
 
\inferencerule
	{Return Operation -- Command}
	{\state' \mathematicaldefinition \state.\popenvironmentfeature(p).\revokelocksfeature(q, p)}
	{\configuration{p :: \returnoperation(a, q) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ & \singlelineconditionaloperation
					{\state.\arelockspassedfeature(q)}
					{\notifyoperation(a)}
					{\nooperation} \statementseparator
				s_{p}
			}
			{\state'}
	}
 
The variant for queries returns the result and the locks. The variant for commands only returns the locks. Both variants take a channel  and the caller processor . For queries, the channel is used to return the result. For this purpose, the operation takes a reference  that points to the result. Processor  is waiting for this result on channel . This can be seen in the  operation, which issues an  operation and a subsequent  operation. The  operation calls the  operation with the same channel . To return the result to , processor  executes a  on . The value to be returned is not always  directly. If  points to an object of expanded class type and , then  must deep import the object. In all other cases,  can take  as the return value. An explanation why the deep import operation is necessary can be found in \sectionreference{sec:setting values}. For commands, the channel is used to signal to  that the locks have been returned in case  passed its locks. This can be determined by looking at the state: . In both variants of the  operation,  removes the passed locks from the stacks of retrieved locks. In case  did not pass any locks, the removed entries might be the empty set. Processor  also removes its top environment because this environment is no longer needed. In case of an asynchronous postcondition evaluation, this environment temporarily gets delegated to the evaluating processor.

Until now, the discussion left out the non-fresh once routines and the attributes. Non-fresh once functions already have a result. The  operation just needs to get this result from the state and return it. For non-fresh once procedures it does not even have to do this. The only obligation is the evaluation of the invariant. The evaluation of the invariant requires the call stack lock of . This lock is given if the condition  holds. For attributes, note that an instance of  is also an instance of . Hence, the operation evaluates the attribute expression and returns the result of the evaluation. The invariant does not have to be evaluated in this case.

\inferencerule
	{Application Operation -- Non-Fresh Once Routine}
	{
		f \in \routinetype \wedge f.\isonceroutinefeature \wedge \neg \state.\isonceroutinefreshfeature(p, f) \\
		\state.\handlerfeature(r_{0}) = p \\
		\neg \state.\passlocksfeature(q, p, \overline{l}).\arelockspassedfeature(p) \\
		\state' \mathematicaldefinition \state.\passlocksfeature(q, p, \overline{l}).\pushenvironmentwithfeaturefeature(p, f, r_{0}, \tuple{r_{1},\ldots, r_{n}}) \\
		\freshchanneldefinition{a_{inv}}
	}
	{\configuration{p :: \applyoperation(a, r_{0}, f, \tuple{r_{1}, \ldots, r_{n}}, q, \overline{l}) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ \multilineconditionaloperation
					{f.\classtypefeature.\invariantexistsfeature \wedge f.\isexportedfeature}
					{\evaluateoperation(a_{inv}, f.\classtypefeature.\invariantfeature) \statementseparator \waitoperation(a_{inv})}
					{\nooperation} \statementseparator \\
				\multilineconditionaloperation
					{f \in \functiontype}
					{\returnoperation(a, \state'.\oncefunctionresultfeature(p, f), q)}
					{\returnoperation(a, q)} \statementseparator \\
				& s_{p}}
			{\state'}
	}
 
\inferencerule
	{Application Operation -- Attribute}
	{
		f \in \attributetype \\
		\state.\handlerfeature(r_{0}) = p \\
		\neg \state.\passlocksfeature(q, p, \overline{l}).\arelockspassedfeature(p) \\
		\state' \mathematicaldefinition \state.\passlocksfeature(q, p, \overline{l}).\pushenvironmentwithfeaturefeature(p, f, r_{0}, \tuple{}) \\
		\freshchanneldefinition{a'}
	}
	{\configuration{p :: \applyoperation(a, r_{0}, f, \tuple{}, q, \overline{l}) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ & \evaluateoperation(a', f) \statementseparator \\
				& \waitoperation(a') \statementseparator \\
				& \returnoperation(a, a'.\datafeature, q) \statementseparator \\
				& s_{p}}
			{\state'}
	}
 
\begin{fortechnicalreport}
\newpage
\begin{example}[Feature application]
This example looks at the application of the feature  on the first investor. This feature is shown in \listingreference{lst:investor class}.

\begin{lstlisting}[caption=Investor class, label=lst:investor class, language=SCOOP]
class INVESTOR

create
  make
	
feature -- Initialization
  make (new_id: INTEGER)
      -- Create an investor with a new identifier.
    do
      id := new_id
    end
		
feature -- Access
  id: INTEGER
      -- The identifier.
	
  log: separate UUID
      -- The identifier of the last market.

  buy (market: separate MARKET; issuer_id: INTEGER)
      -- Buy a share of the issuer on the market.
    require
      market.can_buy (Current.id, issuer_id)
    do
      market.buy (Current, issuer_id)
      log := market.id
    ensure
      market.can_sell (Current.id, issuer_id)
    end

    ...		
end
\end{lstlisting}

The execution starts with a configuration where processor  finished executing the feature calls in feature . These feature calls led to one  operation for the  feature and one for the  feature in each investor's action queue.

\isolatedconfiguration
	{
		p_{1} :: \ & \ldots \processorseparator \\
		p_{2} :: \ & \processorseparator \\
		p_{3} :: \ & \applyoperation(a_{62}, r_{6}, buy, \tuple{r_{1}, r_{39}}, p_{1}, \tuple{\set{}, \set{}}) \statementseparator \\
		& \applyoperation(a_{70}, r_{6}, sell, \tuple{r_{1}, r_{39}}, p_{1}, \tuple{\set{}, \set{}}) \processorseparator \\
		p_{4} :: \ & \applyoperation(a_{66}, r_{8}, buy, \tuple{r_{1}, r_{39}}, p_{1}, \tuple{\set{}, \set{}}) \statementseparator \\
		& \applyoperation(a_{74}, r_{8}, sell, \tuple{r_{1}, r_{39}}, p_{1}, \tuple{\set{}, \set{}})
	}
	{
		\simplifiedstate
			{
				& \simplifiedstatelocksentry
					{p_{1}}
					{\set{}, \set{p_{3}, p_{4}}}
					{\set{}, \set{}}
					{\set{}, \set{}}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator} \\
				& \simplifiedstatelocksentry
					{p_{2}}
					{}
					{}
					{}
					{\simplifiedstateunlockedindicator}
					{\simplifiedstatenopassedlocksindicator} \\
				& \simplifiedstatelocksentry
					{p_{3}}
					{}
					{}
					{}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator} \\
				& \simplifiedstatelocksentry
					{p_{4}}
					{}
					{}
					{}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator}
			}
			{
				& \simplifiedstateobjectsentry
					{p_{1}}
					{
						\simplifiedstatereferencedobject{r_{0}}{o_{0}(\simplifiedstateentityvalue{market}{r_{1}})}, \simplifiedstatereferencedobject{r_{39}}{o_{48}(1)}
					} \\
				& \simplifiedstateobjectsentry
					{p_{2}}
					{
						& \simplifiedstatereferencedobject{r_{1}}{o_{35}(\simplifiedstateentityvalue{cash}{r_{16}}, \simplifiedstateentityvalue{available\_shares}{r_{23}}, \simplifiedstateentityvalue{owned\_shares}{r_{29}})}, \\
						& \simplifiedstatereferencedobject{r_{16}}{o_{25}[r_{21}, r_{22}]}, \simplifiedstatereferencedobject{r_{21}}{o_{23}(100)}, \simplifiedstatereferencedobject{r_{22}}{o_{24}(100)}, \\
						& \simplifiedstatereferencedobject{r_{23}}{o_{33}[r_{28}]}, \simplifiedstatereferencedobject{r_{28}}{o_{32}(1)}, \\
						& \simplifiedstatereferencedobject{r_{29}}{o_{38}[[r_{34}], [r_{35}]]}, \simplifiedstatereferencedobject{r_{34}}{o_{41}(0)}, \simplifiedstatereferencedobject{r_{35}}{o_{42}(0)}
					} \\
				& \simplifiedstateobjectsentry
					{p_{3}}
					{
						\simplifiedstatereferencedobject{r_{6}}{o_{44}(\simplifiedstateentityvalue{id}{r_{36}})},
						\simplifiedstatereferencedobject{r_{36}}{o_{43}(1)}
					} \\
				& \simplifiedstateobjectsentry
					{p_{4}}
					{
						\simplifiedstatereferencedobject{r_{8}}{o_{46}(\simplifiedstateentityvalue{id}{r_{37}})},
						\simplifiedstatereferencedobject{r_{37}}{o_{45}(2)}
					}
			}
			{}
			{
				& \simplifiedstateenvironmentsentry
					{p_{1}}
					{
						& \simplifiedstateentityvalue{first\_investor}{r_{6}}, \simplifiedstateentityvalue{second\_investor}{r_{8}}, \simplifiedstatecurrententityvalue{r_{0}} \simplifiedstateenvironmentsentryseparator \\
						& \simplifiedstateentityvalue{first\_investor}{r_{6}}, \simplifiedstateentityvalue{second\_investor}{r_{8}}, \simplifiedstateentityvalue{issuer\_id}{r_{39}}, \simplifiedstatecurrententityvalue{r_{0}}
					} \\
				& \simplifiedstateenvironmentsentry
					{p_{2}}
					{} \\
				& \simplifiedstateenvironmentsentry
					{p_{3}}
					{} \\
				& \simplifiedstateenvironmentsentry
					{p_{4}}
					{}
			}
	}

At this point, processors  and  can each take the transition that is described by the inference rule for the  operation for non-once routines. Each processor can then take an additional transition by executing the  operation. The result configuration is shown below. The channel  is a fresh channel. Both processors added a new environment that maps the expanded formal argument to a copy of the expanded actual argument. In case of processor , the copied object is referenced by . On processor , the copied object is referenced by . Since processor  did not pass its locks, both  and  added empty lock sets to their stack of retrieved locks.

\isolatedconfiguration
	{
		p_{1} :: \ & \ldots \processorseparator \\
		p_{2} :: \ & \processorseparator \\
		p_{3} :: \ & \lockrequestqueuesoperation(\set{p_{2}}) \statementseparator \\
		& \evaluateoperation(a_{75}, market.can\_buy(\currententity.id, issuer\_id)) \statementseparator \\
		& \waitoperation(a_{75}) \statementseparator \\
		\multilineconditionaloperation
				{a_{75}.\datafeature}
				{\nooperation}
				{
					\begin{split}
						& \issueoperation(p_{2}, \unlockrequestqueueoperation) \statementseparator \\
						& \popobtainedrequestqueuelocksoperation \statementseparator \\
						& \checkpreconditionandlockrequestqueuesoperation(\set{p_{2}}, buy)
					\end{split}
				} \statementseparator \\
		& market.buy (\currententity, issuer\_id) \statementseparator \\
		& log \eassignment market.id \statementseparator \\
		& \checkpostconditionandunlockrequestqueuesoperation(\set{p_{2}}, buy) \statementseparator \\
		& \returnoperation(a_{62}, p_{1}) \statementseparator \\
		& \applyoperation(a_{70}, r_{6}, sell, \tuple{r_{1}, r_{39}}, p_{1}, \tuple{\set{}, \set{}}) \processorseparator \\
		p_{4} :: \ & \lockrequestqueuesoperation(\set{p_{2}}) \statementseparator \\
		& \ldots
	}
	{
		\simplifiedstate
			{
				& \simplifiedstatelocksentry
					{p_{1}}
					{\set{}, \set{p_{3}, p_{4}}}
					{\set{}, \set{}}
					{\set{}, \set{}}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator} \\
				& \simplifiedstatelocksentry
					{p_{2}}
					{}
					{}
					{}
					{\simplifiedstateunlockedindicator}
					{\simplifiedstatenopassedlocksindicator} \\
				& \simplifiedstatelocksentry
					{p_{3}}
					{}
					{\set{}}
					{\set{}}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator} \\
				& \simplifiedstatelocksentry
					{p_{4}}
					{}
					{\set{}}
					{\set{}}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator}
			}
			{
				& \simplifiedstateobjectsentry
					{p_{1}}
					{
						\simplifiedstatereferencedobject{r_{0}}{o_{0}(\simplifiedstateentityvalue{market}{r_{1}})}, \simplifiedstatereferencedobject{r_{39}}{o_{48}(1)}
					} \\
				& \simplifiedstateobjectsentry
					{p_{2}}
					{
						& \simplifiedstatereferencedobject{r_{1}}{o_{35}(\simplifiedstateentityvalue{cash}{r_{16}}, \simplifiedstateentityvalue{available\_shares}{r_{23}}, \simplifiedstateentityvalue{owned\_shares}{r_{29}})}, \\
						& \simplifiedstatereferencedobject{r_{16}}{o_{25}[r_{21}, r_{22}]}, \simplifiedstatereferencedobject{r_{21}}{o_{23}(100)}, \simplifiedstatereferencedobject{r_{22}}{o_{24}(100)}, \\
						& \simplifiedstatereferencedobject{r_{23}}{o_{33}[r_{28}]}, \simplifiedstatereferencedobject{r_{28}}{o_{32}(1)}, \\
						& \simplifiedstatereferencedobject{r_{29}}{o_{38}[[r_{34}], [r_{35}]]}, \simplifiedstatereferencedobject{r_{34}}{o_{41}(0)}, \simplifiedstatereferencedobject{r_{35}}{o_{42}(0)}
					} \\
				& \simplifiedstateobjectsentry
					{p_{3}}
					{
						\simplifiedstatereferencedobject{r_{6}}{o_{44}(\simplifiedstateentityvalue{id}{r_{36}})},
						\simplifiedstatereferencedobject{r_{36}}{o_{43}(1)},
						\simplifiedstatereferencedobject{r_{40}}{o_{49}(1)}
					} \\
				& \simplifiedstateobjectsentry
					{p_{4}}
					{
						\simplifiedstatereferencedobject{r_{8}}{o_{46}(\simplifiedstateentityvalue{id}{r_{37}})},
						\simplifiedstatereferencedobject{r_{37}}{o_{45}(2)},
						\simplifiedstatereferencedobject{r_{41}}{o_{50}(1)}
					}
			}
			{}
			{
				& \simplifiedstateenvironmentsentry
					{p_{1}}
					{
						& \simplifiedstateentityvalue{first\_investor}{r_{6}}, \simplifiedstateentityvalue{second\_investor}{r_{8}}, \simplifiedstatecurrententityvalue{r_{0}} \simplifiedstateenvironmentsentryseparator \\
						& \simplifiedstateentityvalue{first\_investor}{r_{6}}, \simplifiedstateentityvalue{second\_investor}{r_{8}}, \simplifiedstateentityvalue{issuer\_id}{r_{39}}, \simplifiedstatecurrententityvalue{r_{0}}
					} \\
				& \simplifiedstateenvironmentsentry
					{p_{2}}
					{} \\
				& \simplifiedstateenvironmentsentry
					{p_{3}}
					{
						& \simplifiedstateentityvalue{market}{r_{1}}, \simplifiedstateentityvalue{issuer\_id}{r_{40}}, \simplifiedstatecurrententityvalue{r_{6}}
					} \\
				& \simplifiedstateenvironmentsentry
					{p_{4}}
					{
						& \simplifiedstateentityvalue{market}{r_{1}}, \simplifiedstateentityvalue{issuer\_id}{r_{41}}, \simplifiedstatecurrententityvalue{r_{8}}
					}
			}
	}

The inference rule for the  operation shows that both  and  require the request queue lock of . We decide to give priority to . This leads to the following configuration, where 's request queue is locked on behalf of :

\isolatedconfiguration
	{
		p_{1} :: \ & \ldots \processorseparator \\
		p_{2} :: \ & \processorseparator \\
		p_{3} :: \ & \evaluateoperation(a_{75}, market.can\_buy(\currententity.id, issuer\_id)) \statementseparator \\
		& \waitoperation(a_{75}) \statementseparator \\
		\multilineconditionaloperation
			{a_{75}.\datafeature}
			{\nooperation}
			{
				\begin{split}
					& \issueoperation(p_{2}, \unlockrequestqueueoperation) \statementseparator \\
					& \popobtainedrequestqueuelocksoperation \statementseparator \\
					& \checkpreconditionandlockrequestqueuesoperation(\set{p_{2}}, buy)
				\end{split}
			} \statementseparator \\
		& market.buy (\currententity, issuer\_id) \statementseparator \\
		& log \eassignment market.id \statementseparator \\
		& \checkpostconditionandunlockrequestqueuesoperation(\set{p_{2}}, buy) \statementseparator \\
		& \returnoperation(a_{62}, p_{1}) \statementseparator \\
		& \applyoperation(a_{70}, r_{6}, sell, \tuple{r_{1}, r_{39}}, p_{1}, \tuple{\set{}, \set{}}) \processorseparator \\
		p_{4} :: & \ldots
	}
	{
		\simplifiedstate
			{
				& \simplifiedstatelocksentry
					{p_{1}}
					{\set{}, \set{p_{3}, p_{4}}}
					{\set{}, \set{}}
					{\set{}, \set{}}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator} \\
				& \simplifiedstatelocksentry
					{p_{2}}
					{}
					{}
					{}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator} \\
				& \simplifiedstatelocksentry
					{p_{3}}
					{\set{p_{2}}}
					{\set{}}
					{\set{}}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator} \\
				& \simplifiedstatelocksentry
					{p_{4}}
					{}
					{\set{}}
					{\set{}}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator}
			}
			{\ldots}
			{}
			{\ldots}
	}

The evaluation of the precondition produces a result on , which is awaited by . The result is a deep imported object of class type , referenced by . The boolean value of this object indicates that the precondition is satisfied and hence  can continue with the execution of the body. In the following configuration, the arrays referenced by , , and  have been updated; the first investor bought a share of the issuer. Consequently, the first investor has a lower amount of cash and there is one fewer share available. Furthermore, the  attribute of the first investor object has been updated with the identifier of the market. This identifier object, referenced by , has been created by  in a once function of separate type. Hence the object is available as a once result on all processors in the system.

\isolatedconfiguration
	{
		p_{1} :: \ & \ldots \processorseparator
		p_{2} :: \processorseparator \\
		p_{3} :: \ & \checkpostconditionandunlockrequestqueuesoperation(\set{p_{2}}, buy) \statementseparator \\
		& \returnoperation(a_{62}, p_{1}) \statementseparator \\
		& \applyoperation(a_{70}, r_{6}, sell, \tuple{r_{1}, r_{39}}, p_{1}, \tuple{\set{}, \set{}}) \processorseparator
		p_{4} :: \ldots
	}
	{
		\simplifiedstate
			{\ldots}
			{
				& \simplifiedstateobjectsentry
					{p_{1}}
					{
						\simplifiedstatereferencedobject{r_{0}}{o_{0}(\simplifiedstateentityvalue{market}{r_{1}})}, \simplifiedstatereferencedobject{r_{39}}{o_{48}(1)}
					} \\
				& \simplifiedstateobjectsentry
					{p_{2}}
					{
						& \simplifiedstatereferencedobject{r_{1}}{o_{35}(\simplifiedstateentityvalue{cash}{r_{16}}, \simplifiedstateentityvalue{available\_shares}{r_{23}}, \simplifiedstateentityvalue{owned\_shares}{r_{29}})}, \\
						& \simplifiedstatereferencedobject{r_{16}}{o_{71}[r_{61}, r_{22}]}, \simplifiedstatereferencedobject{r_{61}}{o_{70}(90)}, \simplifiedstatereferencedobject{r_{22}}{o_{24}(100)}, \\
						& \simplifiedstatereferencedobject{r_{23}}{o_{73}[r_{62}]}, \simplifiedstatereferencedobject{r_{62}}{o_{72}(0)}, \\
						& \simplifiedstatereferencedobject{r_{29}}{o_{75}[[r_{63}], [r_{35}]]}, \simplifiedstatereferencedobject{r_{63}}{o_{74}(1)}, \simplifiedstatereferencedobject{r_{35}}{o_{42}(0)}, \\
						& \simplifiedstatereferencedobject{r_{65}}{o_{77}}
					} \\
				& \simplifiedstateobjectsentry
					{p_{3}}
					{
						\simplifiedstatereferencedobject{r_{6}}{o_{78}(\simplifiedstateentityvalue{id}{r_{36}}, \simplifiedstateentityvalue{log}{r_{65}})},
						\simplifiedstatereferencedobject{r_{36}}{o_{43}(1)},
						\simplifiedstatereferencedobject{r_{40}}{o_{49}(1)},
						\simplifiedstatereferencedobject{r_{58}}{o_{67}(true)}
					} \\
				& \simplifiedstateobjectsentry
					{p_{4}}
					{
						\simplifiedstatereferencedobject{r_{8}}{o_{46}(\simplifiedstateentityvalue{id}{r_{37}})},
						\simplifiedstatereferencedobject{r_{37}}{o_{45}(2)},
						\simplifiedstatereferencedobject{r_{41}}{o_{50}(1)}
					}
			}
			{
				& \simplifiedstateoncestatusentry
					{\simplifiedstateallprocessorsindicator}
					{
						\simplifiedstateoncefunctionstatus{MARKET}{id}{r_{65}}
					}
			}
			{\ldots}
	}

The postcondition of  contains the expression  with target . The handler of the controlling entity is . Because  did not obtain its own request queue lock, it must evaluate the postcondition synchronously. After the postcondition evaluation,  issues the  operation to  and removes 's request queue lock. This enables  to unlock its request queue lock. Processor  then executes the  operation to get rid of its top environment and its retrieved locks:

\isolatedconfiguration
	{
		p_{1} :: \ & \ldots \processorseparator
		p_{2} :: \processorseparator 
		p_{3} :: \applyoperation(a_{70}, r_{6}, sell, \tuple{r_{1}, r_{39}}, p_{1}, \tuple{\set{}, \set{}}) \processorseparator
		p_{4} :: \ldots
	}
	{
		\simplifiedstate
			{
				& \simplifiedstatelocksentry
					{p_{1}}
					{\set{}, \set{p_{3}, p_{4}}}
					{\set{}, \set{}}
					{\set{}, \set{}}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator} \\
				& \simplifiedstatelocksentry
					{p_{2}}
					{}
					{}
					{}
					{\simplifiedstateunlockedindicator}
					{\simplifiedstatenopassedlocksindicator} \\
				& \simplifiedstatelocksentry
					{p_{3}}
					{}
					{}
					{}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator} \\
				& \simplifiedstatelocksentry
					{p_{4}}
					{}
					{\set{}}
					{\set{}}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator}
			}
			{\ldots}
			{\ldots}
			{
				& \simplifiedstateenvironmentsentry
					{p_{1}}
					{
						& \simplifiedstateentityvalue{first\_investor}{r_{6}}, \simplifiedstateentityvalue{second\_investor}{r_{8}}, \simplifiedstatecurrententityvalue{r_{0}} \simplifiedstateenvironmentsentryseparator \\
						& \simplifiedstateentityvalue{first\_investor}{r_{6}}, \simplifiedstateentityvalue{second\_investor}{r_{8}}, \simplifiedstateentityvalue{issuer\_id}{r_{39}}, \simplifiedstatecurrententityvalue{r_{0}}
					} \\
				& \simplifiedstateenvironmentsentry
					{p_{2}}
					{} \\
				& \simplifiedstateenvironmentsentry
					{p_{3}}
					{} \\
				& \simplifiedstateenvironmentsentry
					{p_{4}}
					{
						& \simplifiedstateentityvalue{market}{r_{1}}, \simplifiedstateentityvalue{issuer\_id}{r_{41}}, \simplifiedstatecurrententityvalue{r_{8}}
					}
			}
	}
\end{example}
\end{fortechnicalreport}

\subsubsection{Creation instructions}
A creation instruction has the form  where  is the target entity,  is the creation procedure, and  are the actual arguments. Assume that  is of type . A processor  that executes this instruction takes the following steps:
\begin{enumerate}
	\item Processor  creation.
		\begin{itemize}
			\item If  is separate, i.e., , then create a new processor.
			\item If  has an explicit processor specification, i.e., , then
				\begin{itemize}
					\item take the processor denoted by  if it already exists.
					\item create a new processor if the processor denoted by  does not exist yet.
				\end{itemize}
			\item If  is non-separate, i.e., , then take .
		\end{itemize}
	\item Locking. Lock the request queue of  if the following conditions hold:
		\begin{itemize}
			\item Processor  and processor  are different.
			\item Processor  does not have 's request queue lock.
			\item Processor  does not have 's request queue lock.
		\end{itemize}
	\item Object creation. Ask  to create a new instance with class type  using the creation procedure . Attach the newly created object to .
	\item Invariant evaluation. If  is not exported, then ask  to evaluate the invariant.
	\item Lock releasing. If 's request queue has been locked in the locking step, then ask  to unlock its request queue after it is done with the feature request.
\end{enumerate}
There are four cases in the processor creation step:
\begin{itemize}
	\item The entity  has a separate type.
	\item The entity  has an explicit processor specification and the denoted processor already exists.
	\item The entity  has an explicit processor specification and the denoted processor does not yet exist.
	\item The entity  has a non-separate type.
\end{itemize}
For each of these cases, there is one inference rule. The discussion starts with the variant where  has a separate type. In this case, the instruction defines  as a new processor and  as a new object of class type . The reference  points to this object. First the instruction obtains a request queue lock on the new processor  so that it can issue statements on . Next, it writes the value  into the entity . To make a call to the creation procedure, it executes a command instruction. Once this is done, it checks whether there is an invariant to evaluate. If  is exported, then the invariant will be evaluated as part of 's feature application. In this case the instruction does nothing. However, if  is not exported, then it must issue the invariant evaluation to . After this step, it can issue an  operation to  and remove the request queue lock from 's obtained request queue locks.

\inferencerule
	{Create Instruction -- Top}
	{
		(d, h, c) \mathematicaldefinition \typefromtypingenvironment(\typingenvironment, b) \\
		h = \top \\
		q \mathematicaldefinition \state.\newprocessorfeature \\
		o \mathematicaldefinition \state.\newobjectfeature(c) \\
		\state' \mathematicaldefinition \state.\addprocessorfeature(q).\addobjectfeature(q, o) \\
		r \mathematicaldefinition \state'.\referencefeature(o) \\
		\freshchanneldefinition{a}
	}
	{\configuration{p :: \ecreate b.f(e_{1}, \ldots, e_{n}) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ & \lockrequestqueuesoperation(\set{q}) \statementseparator \\
				& \writevalueoperation(b.\namefeature, r) \statementseparator \\
				& b.f(e_{1}, \ldots, e_{n}) \statementseparator \\
				\multilineconditionaloperation
					{\neg f.\classtypefeature.\invariantexistsfeature \vee f.\isexportedfeature}
					{\nooperation}
					{\issueoperation(q, \evaluateoperation(a, f.\classtypefeature.\invariantfeature) \statementseparator \waitoperation(a))} \statementseparator \\
				& \issueoperation(q, \unlockrequestqueueoperation) \statementseparator \\
				& \popobtainedrequestqueuelocksoperation \statementseparator \\
				& s_{p} \processorseparator q :: \nooperation
			}
			{\state'}
	}
 
The following discussion looks at the two variants for the cases where  has an explicit processor specification. There are two forms of explicit processor specifications: unqualified and qualified. An unqualified explicit processor specification, i.e., , is based on a processor attribute  with an attached type. The processor denoted by this explicit processor specification is the processor stored in . A qualified explicit processor specification, i.e., , is based on a non-writable entity  of attached type. The processor denoted by this explicit processor specification is the same processor as the one handling the object referenced by . A qualified explicit processor specification always denotes an existing processor because this specification is based on an attached entity. This means that there is already an object attached to this entity and thus its handler must exist. This insight helps to write the conditions for the two inference rule variants.

\begin{forjournal}
\inferencerule
	{Create Instruction -- Existing Explicit Processor}
	{
		(d, h, c) \mathematicaldefinition \typefromtypingenvironment(\typingenvironment, b) \\
		h = <x> \vee h = <y.\handlerfeature> \\
		q \mathematicaldefinition 
			\left\{
				\begin{array}{ll}
					\state.\valuefeature(p, x) & \condition{t = (d, <x>, c)} \\
					\state.\handlerfeature(\state.\valuefeature(p, y)) & \condition{t = (d, <y.\handlerfeature>, c)}
				\end{array}
			\right. \\
		\state.\processorsfeature.\containsfeature(q) \\
		\overline{g}_{required\_cs\_locks} \mathematicaldefinition 
			\left\{
				\begin{array}{ll}
					\set{q} & \condition{q \neq p \wedge (\state.\requestqueuelocksfeature(q).\containsfeature(p) \vee \state.\callstacklocksfeature(q).\containsfeature(p))} \\
					\set{} & \otherwisecondition
				\end{array}
			\right. \\
		\forall x \in \overline{g}_{required\_cs\_locks} \colon \neg \state.\arelockspassedfeature(p) \wedge \state.\callstacklocksfeature(p).\containsfeature(x) \\
		o \mathematicaldefinition  \state.\newobjectfeature(c) \\
		\state' \mathematicaldefinition \state.\addobjectfeature(q, o) \\
		r \mathematicaldefinition  \state'.\referencefeature(o) \\
		\freshchanneldefinition{a}
	}
	{\configuration{p :: \ecreate b.f(e_{1}, \ldots, e_{n}) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ \multilineconditionaloperation
					{q \neq p \wedge \neg \state'.\requestqueuelocksfeature(p).\containsfeature(q) \wedge \neg \state'.\requestqueuelocksfeature(q).\containsfeature(p)}
					{\lockrequestqueuesoperation(\set{q})}
					{\nooperation} \statementseparator \\
				& \writevalueoperation(b.\namefeature, r) \statementseparator \\
				& b.f(e_{1}, \ldots, e_{n}) \statementseparator \\
				\multilineconditionaloperation
					{\neg f.\classtypefeature.\invariantexistsfeature \vee f.\isexportedfeature}
					{\nooperation}
					{\issueoperation(q, \evaluateoperation(a, f.\classtypefeature.\invariantfeature) \statementseparator \waitoperation(a))} \statementseparator \\
				\multilineconditionaloperation
					{q \neq p \wedge \neg \state'.\requestqueuelocksfeature(p).\containsfeature(q) \wedge \neg \state'.\requestqueuelocksfeature(q).\containsfeature(p)}
					{
						\begin{split}
							& \issueoperation(q, \unlockrequestqueueoperation) \statementseparator \\
							& \popobtainedrequestqueuelocksoperation 
						\end{split}
					}
					{\nooperation} \statementseparator \\
				& s_{p}
			}
			{\state'}
	}
 \end{forjournal}

The variant that handles existing processors states that the specified processor must exist. To check this, one must consider both the qualified and the unqualified possibility. For the qualified option, one can simply lookup the value of the attribute . For the unqualified option, one first looks up the value of the entity  and then determines the handler of the referenced object. In either case, the result  is either the denoted processor or the void value. One then checks whether  is in the set of processors of our system. The overall idea of this inference rule is the same as in the case where  has a separate type. The difference is in the processor creation, locking, and lock releasing steps. Instead of creating a new processor, the instruction takes the existing processor . If , then the call to the creation procedure will be a non-separate call. In this case, the instruction requires 's call stack lock. This lock is given because otherwise  would be waiting. If  and  has a lock on , then the call to the creation procedure will be a separate callback. In this case, the instruction requires 's call stack lock. This is expressed in the condition with the help of the set . If  and  does not have 's request queue lock, then the call to the creation procedure will be a separate call. In this case, the instruction must obtain 's request queue lock, provided it does not already have this lock. Only when it obtained 's request queue lock, does the instruction have to issue an  operation and remove  from 's stack of obtained request queue locks.

\begin{forjournal}
\inferencerule
	{Create Instruction -- Non-Existing Explicit Processor}
	{
		(d, h, c) \mathematicaldefinition \typefromtypingenvironment(\typingenvironment, b) \\
		h = <x> \\
		\neg \state.\processorsfeature.\containsfeature(\state.\valuefeature(p, x)) \\
		q \mathematicaldefinition \state.\newprocessorfeature \\
		o \mathematicaldefinition \state.\newobjectfeature(c) \\
		\state' \mathematicaldefinition \state.\addprocessorfeature(q).\addobjectfeature(q, o) \\
		r \mathematicaldefinition \state'.\referencefeature(o) \\
		\freshchanneldefinition{a}
	}
	{\configuration{p :: \ecreate b.f(e_{1}, \ldots, e_{n}) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ & \writevalueoperation(x.\namefeature, q) \statementseparator \\
				& \lockrequestqueuesoperation(\set{q}) \statementseparator \\
				& \writevalueoperation(b.\namefeature, r) \statementseparator \\
				& b.f(e_{1}, \ldots, e_{n}) \statementseparator \\
				\multilineconditionaloperation
					{\neg f.\classtypefeature.\invariantexistsfeature \vee f.\isexportedfeature}
					{\nooperation}
					{\issueoperation(q, \evaluateoperation(a, f.\classtypefeature.\invariantfeature) \statementseparator \waitoperation(a))} \statementseparator \\
				& \issueoperation(q, \unlockrequestqueueoperation) \statementseparator \\
				& \popobtainedrequestqueuelocksoperation  \statementseparator \\
				& s_{p} \processorseparator q :: \nooperation
			}
			{\state'}
	}
 \end{forjournal}

For the variant that handles non-existing processors, one has to verify that the specified processor does not exist. To do so, one considers only unqualified processor specifications. In this case, the instruction creates a new processor  with a new object  and reference . The steps in this variant are similar to those in the variant where  has a separate type. However, the instruction has to set the value of the processor attribute  to the newly created processor. This ensures that the denoted processor will be found to exist in the future.

\begin{fortechnicalreport}
\inferencerule
	{Create Instruction -- Existing Explicit Processor}
	{
		(d, h, c) \mathematicaldefinition \typefromtypingenvironment(\typingenvironment, b) \\
		h = <x> \vee h = <y.\handlerfeature> \\
		q \mathematicaldefinition 
			\left\{
				\begin{array}{ll}
					\state.\valuefeature(p, x) & \condition{t = (d, <x>, c)} \\
					\state.\handlerfeature(\state.\valuefeature(p, y)) & \condition{t = (d, <y.\handlerfeature>, c)}
				\end{array}
			\right. \\
		\state.\processorsfeature.\containsfeature(q) \\
		\overline{g}_{required\_cs\_locks} \mathematicaldefinition 
			\left\{
				\begin{array}{ll}
					\set{q} & \condition{q \neq p \wedge (\state.\requestqueuelocksfeature(q).\containsfeature(p) \vee \state.\callstacklocksfeature(q).\containsfeature(p))} \\
					\set{} & \otherwisecondition
				\end{array}
			\right. \\
		\forall x \in \overline{g}_{required\_cs\_locks} \colon \neg \state.\arelockspassedfeature(p) \wedge \state.\callstacklocksfeature(p).\containsfeature(x) \\
		o \mathematicaldefinition  \state.\newobjectfeature(c) \\
		\state' \mathematicaldefinition \state.\addobjectfeature(q, o) \\
		r \mathematicaldefinition  \state'.\referencefeature(o) \\
		\freshchanneldefinition{a}
	}
	{\configuration{p :: \ecreate b.f(e_{1}, \ldots, e_{n}) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ \multilineconditionaloperation
					{q \neq p \wedge \neg \state'.\requestqueuelocksfeature(p).\containsfeature(q) \wedge \neg \state'.\requestqueuelocksfeature(q).\containsfeature(p)}
					{\lockrequestqueuesoperation(\set{q})}
					{\nooperation} \statementseparator \\
				& \writevalueoperation(b.\namefeature, r) \statementseparator \\
				& b.f(e_{1}, \ldots, e_{n}) \statementseparator \\
				\multilineconditionaloperation
					{\neg f.\classtypefeature.\invariantexistsfeature \vee f.\isexportedfeature}
					{\nooperation}
					{\issueoperation(q, \evaluateoperation(a, f.\classtypefeature.\invariantfeature) \statementseparator \waitoperation(a))} \statementseparator \\
				\multilineconditionaloperation
					{q \neq p \wedge \neg \state'.\requestqueuelocksfeature(p).\containsfeature(q) \wedge \neg \state'.\requestqueuelocksfeature(q).\containsfeature(p)}
					{
						\begin{split}
							& \issueoperation(q, \unlockrequestqueueoperation) \statementseparator \\
							& \popobtainedrequestqueuelocksoperation 
						\end{split}
					}
					{\nooperation} \statementseparator \\
				& s_{p}
			}
			{\state'}
	}
 \inferencerule
	{Create Instruction -- Non-Existing Explicit Processor}
	{
		(d, h, c) \mathematicaldefinition \typefromtypingenvironment(\typingenvironment, b) \\
		h = <x> \\
		\neg \state.\processorsfeature.\containsfeature(\state.\valuefeature(p, x)) \\
		q \mathematicaldefinition \state.\newprocessorfeature \\
		o \mathematicaldefinition \state.\newobjectfeature(c) \\
		\state' \mathematicaldefinition \state.\addprocessorfeature(q).\addobjectfeature(q, o) \\
		r \mathematicaldefinition \state'.\referencefeature(o) \\
		\freshchanneldefinition{a}
	}
	{\configuration{p :: \ecreate b.f(e_{1}, \ldots, e_{n}) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ & \writevalueoperation(x.\namefeature, q) \statementseparator \\
				& \lockrequestqueuesoperation(\set{q}) \statementseparator \\
				& \writevalueoperation(b.\namefeature, r) \statementseparator \\
				& b.f(e_{1}, \ldots, e_{n}) \statementseparator \\
				\multilineconditionaloperation
					{\neg f.\classtypefeature.\invariantexistsfeature \vee f.\isexportedfeature}
					{\nooperation}
					{\issueoperation(q, \evaluateoperation(a, f.\classtypefeature.\invariantfeature) \statementseparator \waitoperation(a))} \statementseparator \\
				& \issueoperation(q, \unlockrequestqueueoperation) \statementseparator \\
				& \popobtainedrequestqueuelocksoperation  \statementseparator \\
				& s_{p} \processorseparator q :: \nooperation
			}
			{\state'}
	}
 \end{fortechnicalreport}

Lastly, there is a variant for the case where  has a non-separate type. In this case, the instruction creates the object on . Processor creation, locking, and lock releasing is not necessary. The required call stack lock on  is given because otherwise  would be waiting.

\inferencerule
	{Create Instruction -- Non-Separate}
	{
		(d, h, c) \mathematicaldefinition \typefromtypingenvironment(\typingenvironment, b) \\
		h = \bullet \\
		o \mathematicaldefinition \state.\newobjectfeature(c) \\
		\state' \mathematicaldefinition \state.\addobjectfeature(p, o) \\
		r \mathematicaldefinition \state'.\referencefeature(o) \\
		\freshchanneldefinition{a}
	}
	{\configuration{p :: \ecreate b.f(e_{1}, \ldots, e_{n}) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ & \writevalueoperation(b.\namefeature, r) \statementseparator \\
				& b.f(e_{1}, \ldots, e_{n}) \statementseparator \\
				\multilineconditionaloperation
						{\neg f.\classtypefeature.\invariantexistsfeature \vee f.\isexportedfeature}
						{\nooperation}
						{\evaluateoperation(a, f.\classtypefeature.\invariantfeature) \statementseparator \waitoperation(a)} \statementseparator \\
				& s_{p}
			}
			{\state'}
	}
 
\begin{fortechnicalreport}
\begin{example}[Object creation]
To illustrate object creation, consider a configuration where the root processor  is executing the root procedure  on the root object . This procedure is shown in \listingreference{lst:application class with initialization}.

\begin{lstlisting}[caption=Application class with initialization, label=lst:application class with initialization, language=SCOOP]
class APPLICATION

create
  make

feature -- Initialization
  make
      -- Create a market with investors and issuers. Then do some transactions.
    local
      first_investor: separate INVESTOR
      second_investor: separate INVESTOR
    do
      -- Create the market with two investors and one issuer. Each investor has 100 units of cash. The issuer has one share.
      create market.make (2, 100, 1, 1)
      create first_investor.make (1)
      create second_investor.make (2)
			
      -- Do a transaction.
      Current.do_transaction (first_investor, second_investor, 1)
    end

feature {APPLICATION} -- Implementation
  market: separate MARKET
      -- The market.
	
  do_transaction
    ...	
end
\end{lstlisting}

The following configuration is our starting point:

\isolatedconfiguration
	{
		p_{1} :: \ & \ecreate market.make(2, 100, 1, 1) \statementseparator \\
		& \ldots
	}
	{
		\simplifiedstate
			{
				& \simplifiedstatelocksentry
					{p_{1}}
					{\set{}}
					{\set{}}
					{\set{}}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator}
			}
			{
				& \simplifiedstateobjectsentry
					{p_{1}}
					{
						\simplifiedstatereferencedobject{r_{0}}{o_{0}(\simplifiedstateentityvalue{market}{\voidvalue})}
					}
			}
			{}
			{
				& \simplifiedstateenvironmentsentry
					{p_{1}}
					{
						& \simplifiedstateentityvalue{first\_investor}{\voidvalue}, \simplifiedstateentityvalue{second\_investor}{\voidvalue}, \simplifiedstatecurrententityvalue{r_{0}}
					}
			}
	}

Processor  starts executing the creation instruction. The result is a new configuration, where  is the new market object handled by a new processor :

\isolatedconfiguration
	{
		p_{1} :: \ & \lockrequestqueuesoperation(\set{p_{2}}) \statementseparator \\
		& \writevalueoperation(market.\namefeature, r_{1}) \statementseparator \\
		& market.make(2, 100, 1, 1) \statementseparator \\
		& \issueoperation(p_{2}, \unlockrequestqueueoperation) \statementseparator \\
		& \popobtainedrequestqueuelocksoperation \statementseparator \\
		& \ldots \processorseparator p_{2} :: \nooperation
	}
	{
		\simplifiedstate
			{
				& \simplifiedstatelocksentry
					{p_{1}}
					{\set{}}
					{\set{}}
					{\set{}}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator} \\
				& \simplifiedstatelocksentry
					{p_{2}}
					{}
					{}
					{}
					{\simplifiedstateunlockedindicator}
					{\simplifiedstatenopassedlocksindicator}
			}
			{
				& \simplifiedstateobjectsentry
					{p_{1}}
					{
						\simplifiedstatereferencedobject{r_{0}}{o_{0}(\simplifiedstateentityvalue{market}{\voidvalue})}
					} \\
				& \simplifiedstateobjectsentry
					{p_{2}}
					{
						\simplifiedstatereferencedobject{r_{1}}{o_{1}}
					}
			}
			{}
			{
				& \simplifiedstateenvironmentsentry
					{p_{1}}
					{
						& \simplifiedstateentityvalue{first\_investor}{\voidvalue}, \simplifiedstateentityvalue{second\_investor}{\voidvalue}, \simplifiedstatecurrententityvalue{r_{0}}
					} \\
				& \simplifiedstateenvironmentsentry
					{p_{2}}
					{}
			}
	}

Now processor  locks the request queue of processor . It then stores the reference  into the entity . With these two steps, processor  set up the context to execute a feature call to the creation procedure . The resulting feature request will be executed by processor . Processor  then asks processor  to unlock its request queue after it is done with the feature request. Then processor  removes the obtained request queue lock from its stack.
\end{example}
\end{fortechnicalreport}

\subsubsection{Flow control instructions}
The  instruction executes  if the expression  evaluates to true. Otherwise the instruction executes . There is one inference rule for this instruction. In a first step, the instruction evaluates the expression  using a fresh channel  and then waits for a notification on . In a second step, it uses the  operation to either execute  or , depending on the value of the expression.

\inferencerule
	{If Instruction}
	{\freshchanneldefinition{a}}
	{\configuration{p :: \eif{e}{s_{t}}{s_{f}} \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ & \evaluateoperation(a, e) \statementseparator \\
				& \waitoperation(a) \statementseparator \\
				\multilineconditionaloperation
					{a.\datafeature}
					{s_{t}}
					{s_{f}} \statementseparator \\
				& s_{p}
			}
			{\state}
	}
 
The  instruction executes a sequence of  instructions until the expression  evaluates to true. If  is true initially, then  never gets executed. There is one inference rule for this instruction. First, the instruction evaluates  using a fresh channel . Then it waits for a notification on . Next, it uses the  operation to check whether  evaluates to true or false. If  is true, then it is done. Otherwise, it executes  followed by another  operation.

\inferencerule
	{Loop Instruction}
	{\freshchanneldefinition{a}}
	{\configuration{p :: \euntil{e}{s_{l}} \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ & \evaluateoperation(a, e) \statementseparator \\
				& \waitoperation(a) \statementseparator \\
				\multilineconditionaloperation
					{a.\datafeature}
					{\nooperation}
					{s_{l} \statementseparator \euntil{e}{s_{l}}} \statementseparator \\
				& s_{p}
			}
			{\state}
	}
 
\subsubsection{Assignment instructions}
An assignment instruction  assigns the value of the expression  to the entity . The instruction first evaluates the expression  and then waits for a notification on a fresh channel . Once it gets this notification, it uses the  operation to set the value to the entity .

\singlelineinferencerule
	{Assignment}
	{\freshchanneldefinition{a}}
	{\configuration{p :: b \eassignment e; s_{p}}{\state}}
	{
		\configuration
			{p :: \evaluateoperation(a, e) \statementseparator \waitoperation(a) \statementseparator \writevalueoperation(b.\namefeature, a.\datafeature) \statementseparator s_{p}}
			{\state}
	}
 
\subsection{Termination}
The system terminates when it reaches a configuration where all action queues are empty, i.e., when there is no more work to do.
