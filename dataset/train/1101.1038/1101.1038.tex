\begin{fortechnicalreport}
\section{Formalization of execution}
\end{fortechnicalreport}
\begin{forjournal}
\section{Formalization of Execution}
\end{forjournal}
\label{sec:execution-formalization}
This section formalizes the execution of a SCOOP program. It explains the general approach, defines the starting point of the execution, and explains the rules that drive the execution. The rules are divided into rules for mechanisms and rules for code elements.

\begin{fortechnicalreport}
\subsection{General approach}
\end{fortechnicalreport}
\begin{forjournal}
\subsection{General Approach}
\end{forjournal}
The formalization is based on \emph{structural operational semantics} \cite{plotkin:2004:structural_operational_semantics}, combined with parts of the terminology from Ostroff et al. \cite{ostroff-torshizi-huang-schoeller:2008:formal_semantics_for_SCOOP}. The idea behind a structural operational semantics is to define the behavior of a program in terms of its parts, i.e., the syntactical elements of the program. Such a semantics is intuitive because it talks directly about elements in the code. It is a very powerful semantics because it allows us to apply structural induction as a proof technique.

\subsubsection{Computations}
A \emph{computation} models the execution of a SCOOP program. It is a sequence of configurations, where each non-initial configuration is derived from a previous configuration through a transition. Each configuration defines a state and a list of statements for each processor. Each transition is described by an inference rule that maps one configuration to another. The transition from one configuration to the next models an atomic step of one processor. The concurrent execution of a SCOOP program is modeled by the interleaved transitions taken by different processors.
\begin{example}[Modeling of parallel execution]
Suppose there are two processors $p$ and $q$. Processor $p$ executes the following sequence of statements: $s_{p, 1} \statementseparator s_{p, 2}$. In parallel, processor $q$ executes the following sequence of statements: $s_{q, 1}$. This execution is modeled by any of the following simplified computations: $s_{p, 1} \statementseparator s_{p, 2} \statementseparator s_{q, 1}$ or $s_{p, 1} \statementseparator s_{q, 1} \statementseparator s_{p, 2}$ or $s_{q, 1} \statementseparator s_{p, 1} \statementseparator s_{p, 2}$.
\end{example}

\subsubsection{Configurations}
A \emph{configuration} models a snapshot in the execution of a SCOOP program. A configuration consists of a state and a set of processors, each with a queue of statements. The state is an instance of $\statetype$. A \emph{schedule} models the processors and the associated queues, called \emph{action queues}. Each processor must execute the statements in its action queue in a FIFO order. The beginning of the action queue contains the statements for the features that are being executed at the moment. The order of these statements models the way the call stack orders feature executions. The tail of the action queue is the request queue of the processor. A call stack lock is the right to add a feature request to the beginning of the action queue and a request queue lock is the right to add a feature request to the end of the action queue. The notation for a configuration with processors $p_{1}, \ldots, p_{n}$, respective action queues $s_{1}, \ldots, s_{n}$, and state $\state$ is:

\isolatedsinglelineconfiguration{p_{1} :: s_{1} \processorseparator \ldots \processorseparator p_{n} :: s_{n}}{\state}

The processor separator $\processorseparator$ is commutative and associative, i.e., $p_{1} :: s_{1} \processorseparator p_{2} :: s_{2} = p_{2} :: s_{2} \processorseparator p_{1} :: s_{1}$ and $p_{1} :: s_{1} \processorseparator (p_{2} :: s_{2} \processorseparator p_{3} :: s_{3}) = (p_{1} :: s_{1} \processorseparator p_{2} :: s_{2}) \processorseparator p_{3} :: s_{3}$. Within an action queue, $\statementseparator$ separates statements. The configuration is \emph{well-defined} if and only if $\neg \exists i, j \in \set{1, \ldots, n} \colon p_{i} = p_{j}$.

\subsubsection{Statements}
A \emph{statement} is an element of the action queue. A statement is either an instruction or an operation. An \emph{instruction} is user syntax, i.e.\ an action that occurs explicitly in the SCOOP program. An \emph{operation} is run-time syntax, i.e.\ an action that does not explicitly occur in a SCOOP program. For example, locking of request queues is not an action that is explicit in a SCOOP program. Instead, locking is based on the formal argument list. It is done implicitly before a feature gets executed.

\subsubsection{Transitions}
A \emph{transition} takes a system in a start configuration and leaves it in a result configuration. The following shows the general form of a transition definition that declares a start configuration $\singlelineconfiguration{P}{\state}$ with schedule $P \mathematicaldefinition p_{1} :: s_{1} \processorseparator \ldots \processorseparator p_{n} :: s_{n}$ and a result configuration $\singlelineconfiguration{P'}{\state'}$ with schedule $P' \mathematicaldefinition p'_{1} :: s'_{1} \processorseparator \ldots \processorseparator p'_{m} :: s'_{m}$:

\isolatedsinglelinetransition
	{\configuration{P}{\state}}
	{\configuration{P'}{\state'}}

The typing environment $\typingenvironment$ can be used in the transition definition to access static information about the SCOOP program.

\subsubsection{Inference rules}
An \emph{inference rule} describes the circumstances under which a transition can be used. The inference rule has a premise and a conclusion. The \emph{conclusion} is the transition and the \emph{premise} describes the circumstances under which the transition can be used. The premise consists of a number of transitions and a side condition. The premise is satisfied if all transitions in the premise can be taken and if the side condition is true.
\begin{fortechnicalreport}
The following shows a template for inference rules:

\singlelineinferencerule
	{General Inference Rule Template}
	{
		\mbox{\it{side condition}} \\
		\singlelinetransition{\configuration{P_{1}}{\state_{P_{1}}}}{\configuration{P_{1}'}{\state_{P_{1}}'}} \\
		\ldots \\
		\singlelinetransition{\configuration{P_{n}}{\state_{P_{n}}}}{\configuration{P_{n}'}{\state_{P_{n}}'}}
	}
	{\configuration{P_{n + 1}}{\state_{P_{n + 1}}}}
	{\configuration{P_{n + 1}'}{\state_{P_{n + 1}}'}}

\end{fortechnicalreport}
In this formalization, most of the rules have no transition in the premise. The following \emph{simplified inference rule template} takes this into account:

\singlelineinferencerule
	{Simplified Inference Rule Template}
	{
		\mbox{\it{condition}} \\
		\mbox{\it{new state}} \thinspace \state' \thinspace \mbox{\it{definition}}\\
		\mbox{\it{fresh channels definitions}}
	}
	{\configuration{P}{\state}}
	{\configuration{P'}{\state'}}

The side condition has three parts. The first part defines a \emph{condition} that is based on the typing environment and the start configuration. The second part is the \emph{new state definition} that defines the state of the result configuration. This new state is based on the state in the start configuration. The last part consists of the \emph{fresh channels definitions}. Auxiliary definitions can be used in the condition, the new state definition, and the fresh channels definitions. The inference rule can mention features of $\statetype$. The preconditions of these features serve as additional conditions in the side condition.

The following inference rule generalizes transitions by adding processors both to the start configuration and to the result configuration. These additional processors run in parallel but do not take any actions during the generalized transition.

\singlelineinferencerule
	{Parallelism}
	{
		\singlelinetransition
			{\configuration{P}{\state}}
			{\configuration{P'}{\state'}}
	}
	{\configuration{P \processorseparator Q}{\state}}
	{\configuration{P' \processorseparator Q}{\state'}}
 
\subsubsection{Scheduling}\label{sec:scheduling}
Before a processor can execute a feature it must obtain locks and it must wait until the wait condition is satisfied. A locking request encapsulates these two requirements; it consists of the requested locks and the wait condition. At every moment, multiple processors can have conflicting locking requests. The scheduler is the arbiter for these conflicts. The scheduler takes locking requests and stores them in a queue. It then approves locking requests according to a certain scheduling algorithm.

The model permits a number of possible scheduling algorithms. The algorithms differ in their level of fairness and their performance. This formalization does not focus on a particular scheduling algorithm. Instead, it uses the conditions of the inference rules to express locking requests. If more than one processor satisfies the conditions, then any of these processors can proceed.

\begin{fortechnicalreport}
\subsection{Initial configuration}
\end{fortechnicalreport}
\begin{forjournal}
\subsection{Initial Configuration}
\end{forjournal}
The initial configuration is defined by the SCOOP program. Each SCOOP program defines a root class type $c$ and a root procedure $f$. The root procedure is a creation procedure of the root class type that has no formal arguments and no precondition.

In the beginning, the runtime generates a bootstrap processor $p$ and root processor $q$ with a root object of the root class type. The request queue of the root processor is locked on behalf of the bootstrap processor. This defines our initial state $\state$:

\isolateddefinition
	{
		& \state_{x} \mathematicaldefinition \creation{\statetype}{\makefeature} \\
		& \state_{y} \mathematicaldefinition \state_{x}.\addprocessorfeature(\state_{x}.\newprocessorfeature) \\
		& p \mathematicaldefinition \state_{y}.\lastaddedprocessorfeature \\
		& \state_{z} \mathematicaldefinition \state_{y}.\addprocessorfeature(\state_{y}.\newprocessorfeature) \\
		& q \mathematicaldefinition \state_{z}.\lastaddedprocessorfeature \\
		& \state_{w} \mathematicaldefinition \state_{z}.\addobjectfeature(q, \state_{z}.\newobjectfeature(c)) \\
		& r \mathematicaldefinition \state_{w}.\referencefeature(\state_{w}.\lastaddedobjectfeature) \\
		& \state \mathematicaldefinition \state_{w}.\lockrequestqueuesfeature(p, \set{q})
	}

The bootstrap processor first asks the root processor to execute the root procedure on the root object and then asks the root processor to unlock its request queue as soon as it finished the execution. The bootstrap processor can do this because it has the request queue lock on the root processor. Finally, the bootstrap processor removes the request queue lock from its stack of obtained request queue locks. This is shown in the following initial configuration:

\isolatedconfiguration
	{
		p :: \ &\calloperation(r, f, \tuple{}, \tuple{}) \statementseparator \\
		& \issueoperation(q, \unlockrequestqueueoperation) \statementseparator \\
		& \popobtainedrequestqueuelocksoperation \processorseparator \\
		q :: &
	}
	{\state}

The statements $\calloperation$, $\issueoperation$, $\unlockrequestqueueoperation$, and $\popobtainedrequestqueuelocksoperation$ are operations. In a nutshell, the $\calloperation(r, f, \tuple{}, \tuple{})$ operation asks the handler of the target $r$ to make a call to the feature $f$ on target $r$. The $\unlockrequestqueueoperation$ operation unlocks the request queue of the processor that executes the operation. The $\issueoperation(q, \unlockrequestqueueoperation)$ operation adds the $\unlockrequestqueueoperation$ operation to $q$'s action queue. The $\popobtainedrequestqueuelocksoperation$ operation removes the top element from the stack of obtained request queue locks.

\begin{fortechnicalreport}
\begin{example}[Initial configuration]
This example defines the initial configuration of a share market application. The domain of the application consists of a number of markets, a number of investors, and a number of issuers. Each issuer can offer a number of shares on each market. Each investor can have an amount of cash available on each market. With this cash, the investor can buy the shares that are available on the market. Investors can sell a share on the market where they bought the share. Selling shares increases the investor's amount of cash on the market. Each market determines the price for each share. Financial regulations require the investors to keep track of the markets on which they operate. For simplicity, the price is constant and the application is restricted to one market, two investors, and one issuer with one share.

The class \lstinline[language=SCOOP]!MARKET! represents the market; the class \lstinline[language=SCOOP]!INVESTOR! represents the investor. The issuers are represented through identifiers of class \lstinline[language=SCOOP]!INTEGER!. The root class \lstinline[language=SCOOP]!APPLICATION! contains the root procedure \lstinline[language=SCOOP]!make!, where the actors get created and where the trade begins.

The execution starts with a bootstrap processor $p_{0}$, a root processor $p_{1}$ and a root object $o_{0}$ of root class type $\mathit{APPLICATION}$. The root object is referenced by $r_{0}$. The following initial configuration shows this:

\isolatedconfiguration
	{
		p_{0} :: \ & \calloperation(r_{0}, \mathit{make}, \tuple{}, \tuple{}) \statementseparator \\
		& \issueoperation(p_{1}, \unlockrequestqueueoperation) \statementseparator \\
		& \popobtainedrequestqueuelocksoperation \processorseparator \\
		p_{1} :: \ &
	}
	{
		\simplifiedstate
			{
				& \simplifiedstatelocksentry
					{p_{0}}
					{\set{p_{1}}}
					{}
					{}
					{\simplifiedstateunlockedindicator}
					{\simplifiedstatenopassedlocksindicator} \\
				& \simplifiedstatelocksentry
					{p_{1}}
					{}
					{}
					{}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator}
			}
			{
				& \simplifiedstateobjectsentry
					{p_{0}}
					{} \\
				& \simplifiedstateobjectsentry
					{p_{1}}
					{
						\simplifiedstatereferencedobject{r_{0}}{o_{0}}
					}
			}
			{}
			{
				& \simplifiedstateenvironmentsentry
					{p_{0}}
					{} \\
				& \simplifiedstateenvironmentsentry
					{p_{1}}
					{}			
			}
	}

\end{example}
\end{fortechnicalreport}

\subsection{Mechanisms}\label{sec:mechanisms}
Mechanisms are the machinery for the execution of code elements. This section studies these mechanisms.

\subsubsection{Issuing mechanism}
With the issuing mechanism, a processor $p$ can add statements to the action queue of a processor $q$. It uses the $\issueoperation$ operation to get a result configuration in which a processor's action queue is extended with the new statements. There are two main cases: $p$ adds the statements to its own action queue, i.e., $p = q$, or $p$ adds the statements to the action queue of a different processor, i.e., $p \neq q$. The first case is the non-separate case and the second one is the separate case.

For the non-separate case $p$ puts the statements to the beginning of $q$'s action queue, which is the same as putting the statements on top of the call stack. This requires that $p$ is in possession of its own call stack lock.

\singlelineinferencerule
	{Issue Operation -- Non-Separate}
	{
		q = p \\
		\neg \state.\arelockspassedfeature(p) \\
		\state.\callstacklocksfeature(p).\containsfeature(q)
	}
	{\configuration{p :: \issueoperation(q, s_{w}) \statementseparator s_{p}}{\state}}
	{\configuration{p :: s_{w} \statementseparator s_{p}}{\state}}
 
For the separate case there is a difference between a normal and a callback case. In the normal case, $p$ adds the statements to the end of $q$'s action queue. This case requires that $p$ is in possession of $q$'s request queue lock. To distinguish the normal case from the callback case, this case also requires that $q$ does not have a lock on $p$.

\singlelineinferencerule
	{Issue Operation -- Separate}
	{
		q \neq p \\
		\neg \state.\arelockspassedfeature(p) \\
		\state.\requestqueuelocksfeature(p).\containsfeature(q) \\
		\neg (\state.\requestqueuelocksfeature(q).\containsfeature(p) \vee \state.\callstacklocksfeature(q).\containsfeature(p))
	}
	{\configuration{p :: \issueoperation(q, s_{w}) \statementseparator s_{p} \processorseparator q :: s_{q}}{\state}}
	{\configuration{p :: s_{p} \processorseparator q :: s_{q} \statementseparator s_{w}}{\state}}
 
The callback case occurs if $q$ has a lock on $p$. In this situation, $p$ could issue a statement $s_{w}$ on $q$ and then wait for $q$ to complete. On the other side, processor $q$ could already be waiting for $p$ to complete. Processor $q$ would be waiting for $p$ to finish and $p$ would be waiting for $q$ to finish. However, since $s_{w}$ would be at the end of $q$'s action queue and $q$ would be waiting there cannot be any progress. This type of deadlock can be prevented by adding $s_{w}$ not to the of $q$'s action queue but to the beginning. This will make sure that $q$ can execute the statement right away and hence $p$ can continue. This in return will enable $q$ to continue. As a prerequisite, $p$ must possess $q$'s call stack lock.

\singlelineinferencerule
	{Issue Operation -- Separate Callback}
	{
		q \neq p \\
		\neg \state.\arelockspassedfeature(p) \\
		\state.\callstacklocksfeature(p).\containsfeature(q) \\
		\state.\requestqueuelocksfeature(q).\containsfeature(p) \vee \state.\callstacklocksfeature(q).\containsfeature(p)
	}
	{\configuration{p :: \issueoperation(q, s_{w}) \statementseparator s_{p} \processorseparator q :: s_{q}}{\state}}
	{\configuration{p :: s_{p} \processorseparator q :: s_{w} \statementseparator s_{q}}{\state}}
 
\subsubsection{Delegated execution mechanism}
This section discusses how a processor $q$ can delegate the execution of statements to a different processor $p$. This mechanism is useful for the evaluation of asynchronous postconditions. Processor $q$ must make sure that the statements make sense in the context of processor $p$. The names that occur in these statements must be defined in the top environment of $p$ and $p$ must have the necessary locks to execute the statements. 
Statements that fulfill the following conditions can be delegated:
\begin{itemize}
	\item All names that occur in the statements are defined in $q$'s top environment.
	\item Their execution only requires the top set of $q$'s stack of obtained request queue locks.
\end{itemize}
These conditions exclude statements that involve non-separate calls or separate callbacks because such calls require a call stack lock. If these conditions are met, $q$ can transfer its top environment and the top of its obtained request queue locks to $p$. Given this context, $p$ can then execute the delegated statements instead of $q$.

The $\executedelegatedoperation(s_{w}, x, \set{q_{1}, \ldots, q_{m}})$ operation sets up a new context on $p$ with an environment $x$ and obtained request queue locks $\set{q_{1}, \ldots, q_{m}}$. To set up the new context, the operation uses a combination of the commands $\pushenvironmentfeature$ and $\delegateobtainedrequestqueuelocksfeature$. The command $\delegateobtainedrequestqueuelocksfeature$ requires that the request queue locks $\set{q_{1}, \ldots, q_{m}}$ are not in possession of another processor anymore. It also requires that the request queues of $\set{q_{1}, \ldots, q_{m}}$ are locked. Once the context is set up, processor $p$ executes the statements $s_{w}$ and then gets rid of the context, using the $\leavedelegatedexecutionoperation$ operation.

To delegate the execution of the statements $s_{w}$, processor $q$ must make sure that its top environment $x$ is set up correctly and it must make sure that the top set of its obtained request queue locks contains all locks $\set{q_{1}, \ldots, q_{m}}$ that are necessary for the execution of $s_{w}$. Processor $q$ must then issue a $\executedelegatedoperation(s_{w}, x, \set{q_{1}, \ldots, q_{m}})$ operation to processor $p$. Processor $q$ must then remove $\set{q_{1}, \ldots, q_{m}}$ from its stack of obtained request queue locks so that the $\delegateobtainedrequestqueuelocksfeature$ operation can take place.

\inferencerule
	{Execute Delegated Operation}
	{
		\forall x \in \set{q_{1}, \ldots, q_{m}} \colon \neg \exists y \in \state.\processorsfeature \colon \state.\requestqueuelocksfeature(y).\containsfeature(x) \\
		\forall x \in \set{q_{1}, \ldots, q_{m}} \colon \state.\isrequestqueuelockedfeature(x) \\
		\state' \mathematicaldefinition \state.\pushenvironmentfeature(p, x).\delegateobtainedrequestqueuelocksfeature(p, \set{q_{1}, \ldots, q_{m}})
	}
	{\configuration{p :: \executedelegatedoperation(s_{w}, x, \set{q_{1}, \ldots, q_{m}}) \statementseparator s_{p}}{\state}}
	{\configuration{p :: s_{w} \statementseparator \leavedelegatedexecutionoperation \statementseparator s_{p}}{\state'}}

\singlelineinferencerule
	{Leave Delegated Execution Operation}
	{
		\neg \state.\environmentsfeature(p).\isemptyfeature \\
		\neg \state.\obtainedrequestqueuelocksfeature(p).\isemptyfeature \\
		\state' \mathematicaldefinition \state.\popenvironmentfeature(p).\popobtainedrequestqueuelocksfeature(p)
	}
	{\configuration{p :: \leavedelegatedexecutionoperation \statementseparator s_{p}}{\state}}
	{\configuration{p :: s_{p}}{\state'}}
 
\subsubsection{Notification mechanism}\label{sec:notification mechanism}
Processors can notify each other. A notification can optionally include a value. The formalization uses channels to describe such communication. Channels are described in Milner's $\pi$-calculus \cite{milner:1999:Pi_calculus}. In the $\pi$-calculus, the expression $c(x).P$ denotes a process that is waiting for a notification sent on a channel $c$. Once the notification has been received, the value of the notification is bound to the variable $x$ and the process continues with the expression $P$. The notification comes from a process that executes $\overline{c}y.Q$ to emit the value $y$ on the channel $c$ before executing $Q$.

The formalization reuses the channel idea in two flavors: once as a notification mechanism with a value and once as a notification mechanism without a value. A processor sends a notification with a value $r$ over a channel $a$ as it executes the operation $\resultoperation(a, r)$. Similarly, the process sends a notification without a value over a channel $a$ by executing the operation $\notifyoperation(a)$. For both cases, any processor can wait for a notification by executing the operation $\waitoperation(a)$. In case a notification on a channel $a$ carries a value, the value can be accessed with $a.\datafeature$. This way of accessing the value of a channel is different from the way it is done in the $\pi$-calculus. In the $\pi$-calculus, each value is bound to a variable. This formalization does not define a new variable for the value. Instead, it uses $a.\datafeature$ to identify the value of a channel $a$.

A number of inference rules describe the interaction between a processor that sent a notification over a channel and a processor that is waiting for a notification over the same channel. Two main cases can be distinguished: either a processor sends a notification to itself or it sends a notification to a different processor. The first case is the non-separate case and the latter case is the separate case. In each of these two main cases, the channel carries a notification with or without a value. For each of these sub cases, there is one inference rule.

In the non-separate case, one processor has a $\resultoperation(a, r)$ operation or a $\notifyoperation(a)$ operation at the beginning of its action queue and a $\waitoperation(a)$ operation on the same channel later in the action queue. In this case, the $\waitoperation(a)$ operation can be removed along with the $\resultoperation(a, r)$ operation, respectively the $\notifyoperation(a)$ operation. If the channel carries a value, then the value must be installed on the processor, by substituting all occurrences of $a.\datafeature$ with the posted value in all the statements $s_{p}$ after the $\waitoperation(a)$ operation.

\singlelineinferencerule
	{Wait and Result Operation -- Non-Separate}
	{}
	{\configuration{p :: \resultoperation(a, r) \statementseparator s_{w} \statementseparator \waitoperation(a) \statementseparator s_{p}}{\state}}
	{\configuration{p :: s_{w} \statementseparator s_{p} \substitution{r}{a.\datafeature}}{\state}}
 
\singlelineinferencerule
	{Wait and Notify Operation -- Non-Separate}
	{}
	{\configuration{p :: \notifyoperation(a) \statementseparator s_{w} \statementseparator \waitoperation(a) \statementseparator s_{p}}{\state}}
	{\configuration{p :: s_{w} \statementseparator s_{p}}{\state}}
 
In the separate case, one processor has a $\resultoperation(a, r)$ or a $\notifyoperation(a)$ operation at the beginning of its action queue and a different processor has a $\waitoperation(a)$ somewhere in its action queue. In this situation, the $\waitoperation(a)$, $\resultoperation(a, r)$, and $\notifyoperation(a)$ can be removed from the action queues. In case the notification has a value, the value can be installed in the statements $s_{p}$, after the $\waitoperation(a)$ operation.

\singlelineinferencerule
	{Wait and Result Operation -- Separate}
	{}
	{\configuration{p :: s_{w} \statementseparator \waitoperation(a) \statementseparator s_{p} \processorseparator q :: \resultoperation(a, r) \statementseparator s_{q}}{\state}}
	{\configuration{p :: s_{w} \statementseparator s_{p} \substitution{r}{a.\datafeature} \processorseparator q :: s_{q}}{\state}}
 
\singlelineinferencerule
	{Wait and Notify Operation -- Separate}
	{}
	{\configuration{p :: s_{w} \statementseparator \waitoperation(a) \statementseparator s_{p} \processorseparator q :: \notifyoperation(a) \statementseparator s_{q}}{\state}}
	{\configuration{p :: s_{w} \statementseparator s_{p} \processorseparator q :: s_{q}}{\state}}
 
The operations presented here must be used so that each $\waitoperation$ operation can be resolved with exactly one $\resultoperation$ or $\notifyoperation$ operation. To define this condition more precisely, we define that one statement $s_{1}$ weakly precedes a statement $s_{2}$ if and only if $s_{1}$ occurs earlier than $s_{2}$ in the same action queue or $s_{1}$ and $s_{2}$ occur in different action queues. One statement $s_{1}$ strongly precedes a statement $s_{1}$ if and only if $s_{1}$ occurs earlier than $s_{2}$ in the same action queue. With these definitions, the condition says:
\begin{itemize}
	\item For each $\waitoperation(a)$ operation there must be either exactly one $\resultoperation(a, r)$ or exactly one $\notifyoperation(a)$ operation.
	\item For each $\resultoperation(a, r)$ or $\notifyoperation(a)$ operation there must be exactly one $\waitoperation(a)$ operation.
	\item Each $\resultoperation(a, r)$ or $\notifyoperation(a)$ operation weakly precedes the $\waitoperation(a)$ operation.
\end{itemize}

\subsubsection{Expression evaluation mechanism}\label{sec:expression evaluation mechanism}
An expression can either be a literal, an entity, or a query call. The query call can contain actual arguments that are expressions themselves. This section discusses the general mechanism to evaluate expressions. It focuses on the general approach and defers the evaluation of particular expressions to later sections.

The operation $\evaluateoperation(a, e)$ takes a channel $a$ and an expression $e$. Each $\evaluateoperation(a, e)$ operation determines the value $r$ of the expression $e$ and then sends a notification with value $r$ on channel $a$. This means that each $\evaluateoperation(a, e)$ operation creates a $\resultoperation(a, r)$ operation in the action queue. It is therefore important to follow each $\evaluateoperation(a, e)$ operation with exactly one $\waitoperation(a)$ to receive the notification with the value.
\subsubsection{Locking and unlocking mechanism}
A processor $p$ that wants to execute a feature must first obtain the request queue locks of a number of processors $\set{q_{1}, \ldots, q_{m}}$. Only then can $p$ issue statements to these processors. The $\lockrequestqueuesoperation(\set{q_{1}, \ldots, q_{m}})$ operation serves this purpose. It requires that none of the request queues is already locked.

\singlelineinferencerule
	{Lock Operation}
	{
		\neg \exists q_{i} \in \set{q_{1}, \ldots, q_{m}} \colon \state.\isrequestqueuelockedfeature(q_{i}) \\
		\state' \mathematicaldefinition \state.\lockrequestqueuesfeature(p, \set{q_{1}, \ldots, q_{m}})
	}
	{\configuration{p :: \lockrequestqueuesoperation(\set{q_{1}, \ldots, q_{m}}) \statementseparator s_{p}}{\state}}
	{\configuration{p :: s_{p}}{\state'}}
 
Once $p$ is done with the execution of the feature, it asks $\set{q_{1}, \ldots, q_{m}}$ to unlock their request queues once they are done with the issued statements. For this purpose, $p$ issues the $\unlockrequestqueueoperation$ operation to processors $\set{q_{1}, \ldots, q_{m}}$. This operation requires that the request queue is indeed locked and that no processor possesses the request queue lock.

\singlelineinferencerule
	{Unlock Operation}
	{
		\state.\isrequestqueuelockedfeature(p) \\
		\forall q \in \state.\processorsfeature \colon \neg \state.\requestqueuelocksfeature(q).\containsfeature(p) \\
		\state' \mathematicaldefinition \state.\unlockrequestqueuefeature(p)
	}
	{\configuration{p :: \unlockrequestqueueoperation \statementseparator s_{p}}{\state}}
	{\configuration{p :: s_{p}}{\state'}}
 
After $p$ issued the $\unlockrequestqueueoperation$ operations, it can remove $\set{q_{1}, \ldots, q_{m}}$ from its stack of obtained request queue locks using the $\popobtainedrequestqueuelocksoperation$ operation. This ensures that the $\unlockrequestqueueoperation$ operations can proceed.

\singlelineinferencerule
	{Pop Obtained Request Queue Locks}
	{
		\state' \mathematicaldefinition \state.\popobtainedrequestqueuelocksfeature(p)
	}
	{\configuration{p :: \popobtainedrequestqueuelocksoperation \statementseparator s_{p}}{\state}}
	{\configuration{p :: s_{p}}{\state'}}
 
Brooke, Paige, and Jacob \cite{brooke-paige-jacob:2007:formal_semantics_for_SCOOP} noticed that $\unlockrequestqueueoperation$ operations are not optimal. In essence, it could be possible to unlock the request queue of a processor $q_{i}$ directly after $p$ issued all statements. The request queue lock is important to guarantee exclusive access on $q_{i}$'s request queue. However, as soon as $p$ issued all statements on $q_{i}$, this lock is no longer needed. Unlocking the request queue right away could improve the performance in some situations because $q_{i}$'s request queue could be locked again earlier and hence another processor that is waiting for this lock could proceed earlier.

\subsubsection{Write and read mechanism}
A processor $p$ can use the $\writevalueoperation(x, v)$ operation to set a value $v$ of an entity with name $x$. This operation uses the $\setvaluefeature$ command. Hence, $p$ can both set attribute values of its current object and values of entities in its top environment.

\singlelineinferencerule
	{Write Value Operation}
	{\state' \mathematicaldefinition \state.\setvaluefeature(p, x, v)}
	{\configuration{p :: \writevalueoperation(x, v) \statementseparator s_{p}}{\state}}
	{\configuration{p :: s_{p}}{\state'}}

 
Similarly, processor $p$ can execute the $\readvalueoperation(x, a)$ operation to read a value of an entity with name $x$ and send the value over channel $a$. The $\readvalueoperation$ operation does not present its result in a $\resultoperation$ operation because, unlike an $\evaluateoperation$ operation, a $\readvalueoperation$ operation always produces a result for the surrounding action queue. It is easier to do the substitution of the channel access directly. A later section introduces the $\evaluateoperation$ operation for entity expressions. This variant of the $\evaluateoperation$ operation makes use of the $\readvalueoperation$ operation and presents the result in a $\resultoperation$ operation.

\singlelineinferencerule
	{Read Value Operation}
	{}
	{\configuration{p :: \readvalueoperation(x, a) \statementseparator s_{p}}{\state}}
	{\configuration{p :: s_{p} \substitution{\state.\valuefeature(p, x)}{a.\datafeature}}{\state}}
 
Finally, there is the $\setonceroutinenotfreshoperation$ operation in two variants for once functions and one variant for once procedures. This operation sets the once status of a once routine. The variant $\setonceroutinenotfreshoperation(f, r)$ sets the once status of a once function $f$ to non-fresh with value $r$. If $f$ is of separate type, then the once function becomes non-fresh on all processors in the system. If $f$ has a non-separate type, then $f$ becomes non-fresh only on processor $p$. The variant $\setonceroutinenotfreshoperation(f)$ sets the once status of a once procedure $f$ to non-fresh on processor $p$. The variant $\setonceroutinenotfreshwithresultoperation$ uses the value of the result entity to set the once status of a once function.

\singlelineinferencerule
	{Set Once Routine Not Fresh Operation -- Function}
	{
		f \in \functiontype \wedge f.\isonceroutinefeature \\
		\state' \mathematicaldefinition \state.\setoncefunctionnotfreshfeature(p, f, r)
	}
	{\configuration{p :: \setonceroutinenotfreshoperation(f, r) \statementseparator s_{p}}{\state}}
	{\configuration{p :: s_{p}}{\state'}}

\singlelineinferencerule
	{Set Once Routine Not Fresh Operation -- Procedure}
	{
		f \in \proceduretype \wedge f.\isonceroutinefeature \\
		\state' \mathematicaldefinition \state.\setonceprocedurenotfreshfeature(p, f)
	}
	{\configuration{p :: \setonceroutinenotfreshoperation(f) \statementseparator s_{p}}{\state}}
	{\configuration{p :: s_{p}}{\state'}}

\inferencerule
	{Set Once Routine Not Fresh Operation -- Function With Result}
	{
		f \in \functiontype \wedge f.\isonceroutinefeature \\
		\state.\environmentsfeature(p).\topfeature.\namesfeature.\containsfeature(\resultentityname) \\
		\freshchanneldefinition{a}
	}
	{\configuration{p :: \setonceroutinenotfreshwithresultoperation(f) \statementseparator s_{p}}{\state}}
	{\configuration{p :: \readvalueoperation(\resultentityname, a) \statementseparator \setonceroutinenotfreshoperation(f, a.\datafeature) \statementseparator s_{p}}{\state}}
 
\subsubsection{Flow control mechanism}
In addition to flow control instructions in the user code, there are flow control operations, which implement flow control in the inference rules. This way, fewer inference rules are required because multiple variants can be handled in one inference rule.

The $\singlelineconditionaloperation{x}{s_{t}}{s_{f}}$ operation takes the condition $x$ as an argument. The operation either executes $s_{t}$ if $x$ indicates that the condition is true or $s_{f}$ if $x$ indicates that the condition is false. For each possibility there is one inference rule. The condition $x$ can either be an instance of $\booleantype$ or it can be a reference that points to an object of class type $\booleanclasstype$. To decide which branch to take, the operation must evaluate $x$. If $x$ is an instance of $\booleantype$, then it can determine which instance $x$ is, i.e., $\truevalue$ or $\falsevalue$. If $x$ is a reference, then it must get the referenced object and see which boolean value it represents. For this purpose, it evaluates the attribute $\booleanclasstypeitemattributename$ of the referenced object.

\singlelineinferencerule
	{Conditional Operation -- True}
	{
		y \mathematicaldefinition 
			\left\{
				\begin{array}{ll}
					x & \condition{x \in \booleantype} \\
					\state.\attributevaluefeature(\state.\referencedobjectfeature(x), \booleanclasstypeitemattributename) & \condition{x \in \referencetype \wedge \state.\referencedobjectfeature(x).\classtypefeature = \booleanclasstype} \\
					\falsevalue & \otherwisecondition
				\end{array}
			\right. \\
		y = \truevalue
	}
	{
		\configuration
			{
				p :: \ \singlelineconditionaloperation
					{x}
					{s_{t}}
					{s_{f}} \statementseparator
				s_{p}
			}
			{\state}
	}
	{\configuration{p :: s_{t} \statementseparator s_{p}}{\state}}

\singlelineinferencerule
	{Conditional Operation -- False}
	{
		y \mathematicaldefinition 
			\left\{
				\begin{array}{ll}
					x & \condition{x \in \booleantype} \\
					\state.\attributevaluefeature(\state.\referencedobjectfeature(x), \booleanclasstypeitemattributename) & \condition{x \in \referencetype \wedge \state.\referencedobjectfeature(x).\classtypefeature = \booleanclasstype} \\
					\truevalue & \otherwisecondition
				\end{array}
			\right. \\
		y = \falsevalue
	}
	{
		\configuration
			{
				p :: \ \singlelineconditionaloperation
					{x}
					{s_{t}}
					{s_{f}} \statementseparator
				s_{p}
			}
			{\state}
	}
	{\configuration{p :: s_{f} \statementseparator s_{p}}{\state}}
 
The $\singlelineconditionaloperation{x}{s_{t}}{s_{f}}$ operation has two branches. Sometimes it is necessary to only have one branch. The $\nooperation$ operation can be executed without an effect. It can be used in the conditional operation to define an empty branch. The $\nooperation$ operation can also be used to indicate that an action queue is empty.

\singlelineinferencerule
	{No Operation}
	{}
	{\configuration{p :: \nooperation \statementseparator s_{p}}{\state}}
	{\configuration{p :: s_{p}}{\state}}
 
\begin{fortechnicalreport}
\subsection{Code elements}
\end{fortechnicalreport}
\begin{forjournal}
\subsection{Code Elements}
\end{forjournal}
This section explains the semantics of code elements: entity expressions, literal expressions, feature calls, feature applications, creation instructions, flow control instructions, and assignment instructions.

\subsubsection{Entity expressions}
A variant of the $\evaluateoperation(a, e)$ operation evaluates entity expressions. The operation uses the $\readvalueoperation$ operation to send a notification with the value of the entity over a new channel $a'$. It then uses the value of this channel to define the result of the $\evaluateoperation$ operation.

\singlelineinferencerule
	{Entity Expression}
	{
		e \in \entitytype \\
		\freshchanneldefinition{a'}
	}
	{\configuration{p :: \evaluateoperation(a, e) \statementseparator s_{p}}{\state}}
	{\configuration{p :: \readvalueoperation(e.\namefeature, a') \statementseparator \resultoperation(a, a'.\datafeature) \statementseparator s_{p}}{\state}}
 
\subsubsection{Literal expressions}
Another variant of the $\evaluateoperation(a, e)$ operation evaluates literal expressions. To evaluate a non-void literal expression, the operation creates a new object of the literal class type so that the new object represents the literal value. For this purpose, it uses the query $\objectfeature$ of $\literaltype$. Since the type of every literal is non-separate, it creates the new object on the processor that evaluates the literal expression. The reference $r$ to the new object is the result of the evaluation. To evaluate a void literal, the operation takes the void reference.

\singlelineinferencerule
	{Literal Expression}
	{
		e \in \literaltype \\
		\state' \mathematicaldefinition
			\left\{
				\begin{array}{ll}
					 \state & \condition{e = \voidliteral} \\
					 \state.\addobjectfeature(p, e.\objectfeature) & \otherwisecondition
				\end{array}
			\right. \\
		r \mathematicaldefinition
			\left\{
				\begin{array}{ll}
					 \voidvalue & \condition{e = \voidliteral} \\
					 \state'.\referencefeature(\state'.\lastaddedobjectfeature) & \otherwisecondition
				\end{array}
			\right.
	}
	{\configuration{p :: \evaluateoperation(a, e) \statementseparator s_{p}}{\state}}
	{\configuration{p :: \resultoperation(a, r) \statementseparator s_{p}}{\state'}}
 
\subsubsection{Feature calls}\label{sec:feature calls}
A feature call can occur in two ways. First, a feature call can be a call to a command in a command instruction. Second, a feature call can be a call to a query in an expression. This section studies both variants. A processor $p$ that executes a feature call $e_{0}.f(e_{1}, \ldots, e_{n})$ goes through the following steps:
\begin{enumerate}
	\item Target evaluation. Evaluate the target expression $e_{0}$ and let $q$ denote the handler of the target.
	\item Argument passing. Evaluate the actual arguments expressions $(e_{1}, \ldots, e_{n})$.
	\item Lock passing. Determine which locks to pass to $q$.
		\begin{itemize}
			\item Take all request queue locks and call stack locks if a controlled actual argument gets attached to an attached formal argument of reference type.
			\item Take all request queue locks and call stack locks if the feature call is a separate callback, i.e., $q$ has a lock on $p$.
			\item Otherwise, take no locks.
		\end{itemize}
	\item Feature request.
		\begin{itemize}
			\item Ask $q$ to apply $f$ to the target immediately and wait until the execution terminates if any of the following conditions holds:
				\begin{itemize}
					\item The feature call is non-separate, i.e., $p = q$.
					\item The feature call is a separate callback, i.e., $q$ has a lock on $p$.
				\end{itemize}
			\item Otherwise, ask $q$ to apply $f$ to the target after the previous feature requests.
		\end{itemize}
	\item Wait by necessity. If $f$ is a query, then wait for the result.
	\item Lock revocation. If lock passing happened, then wait for the locks to come back.
\end{enumerate}
A command instruction is a statement in the action queue. A query is an expression on the right hand side of an assignment, a condition in a flow control instruction, or an actual argument in a feature call. Whenever a query occurs in one of these constructs, the inference rule of the construct encloses the query in an $\evaluateoperation$ operation. To handle feature calls, there is an inference rule for command instructions and a variant of the $\evaluateoperation$ operation for query calls.

In each case, the statement first evaluates the target expression and all actual argument expressions. For each of these expressions $e_{i}$, it uses one $\evaluateoperation(a_{e_{i}}, e_{i})$ operation and a corresponding $\waitoperation(a_{e_{i}})$ operation with a fresh channel $a_{e_{i}}$. Each of the channel values gets used in the subsequent $\calloperation$ operation. With this, the statement handled the target evaluation and the argument passing step. It defers the attachment of the actual arguments to the formal arguments to the point where the called feature gets applied. The reason for this is simple: at this point the context for the feature application does not exist yet.

The $\calloperation$ operation takes care of the remaining steps. The operation exists in two variants, one for command instructions and one for queries. The variant for queries takes a channel $a'$ and uses it for the result of the query. Since a call to a command does not produce a result, such a channel is not required for command instructions. Both $\calloperation$ variants take the reference to the target $a_{e_{0}}$, the feature $f$ to be called, the references to the actual arguments $\tuple{a_{e_{1}}.\datafeature, \ldots, a_{e_{n}}.\datafeature}$, and the actual argument expressions $\tuple{e_{1}, \ldots, e_{n}})$. The actual argument expressions are used to check whether there is a controlled actual argument. This information determines whether the locks should be passed.

\inferencerule
	{Command Instruction}
	{\forall {i \in \set{0, \ldots, n}} \colon {\freshchanneldefinition{a_{e_{i}}}}}
	{\configuration{p :: e_{0}.f(e_{1}, \ldots, e_{n}) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ & \evaluateoperation(a_{e_{0}}, e_{0}) \statementseparator \evaluateoperation(a_{e_{1}}, e_{1}) \statementseparator \ldots \statementseparator \evaluateoperation(a_{e_{n}}, e_{n}) \statementseparator \\
				& \waitoperation(a_{e_{0}}) \statementseparator \waitoperation(a_{e_{1}}) \statementseparator \ldots \statementseparator \waitoperation(a_{e_{n}}) \statementseparator \\
				& \calloperation(a_{e_{0}}.\datafeature, f, \tuple{a_{e_{1}}.\datafeature, \ldots, a_{e_{n}}.\datafeature}, \tuple{e_{1}, \ldots, e_{n}}) \statementseparator \\
				& s_{p}
			}
			{\state}
	}
 
\inferencerule
	{Query Expression}
	{
		\forall {i \in \set{0, \ldots, n}} \colon {\freshchanneldefinition{a_{e_{i}}}} \\
		\freshchanneldefinition{a'}
	}
	{\configuration{p :: \evaluateoperation(a, e_{0}.f(e_{1}, \ldots, e_{n})) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ & \evaluateoperation(a_{e_{0}}, e_{0}) \statementseparator \evaluateoperation(a_{e_{1}}, e_{1}) \statementseparator \ldots \statementseparator \evaluateoperation(a_{e_{n}}, e_{n}) \statementseparator \\
				& \waitoperation(a_{e_{0}}) \statementseparator \waitoperation(a_{e_{1}}) \statementseparator \ldots \statementseparator \waitoperation(a_{e_{n}}) \statementseparator \\
				& \calloperation(a', a_{e_{0}}.\datafeature, f, \tuple{a_{e_{1}}.\datafeature, \ldots, a_{e_{n}}.\datafeature}, \tuple{e_{1}, \ldots, e_{n}}) \statementseparator \\
				& \resultoperation(a, a'.\datafeature) \statementseparator \\
				& s_{p}
			}
			{\state}
	}
 
Both variants of the $\calloperation$ operation take the reference to the target $r_{o}$, the feature $f$ to be called, the references to the actual arguments $\tuple{r_{1}, \ldots, r_{n}}$, and the actual argument expressions $\tuple{e_{1}, \ldots, e_{n}}$. The variant for queries takes an additional channel $a$ to be used for the result of the query. In a first step, the operation must evaluate the handler $q$ of the target. The handler is used in an $\issueoperation$ operation to issue a feature request on the responsible processor. The feature request comes in the form of an $\applyoperation$ operation. The $\applyoperation$ operation takes a channel $a$ for the communication between $p$ and $q$, the target reference $r_{0}$, the called feature $f$, the references to the actual arguments $\tuple{r_{1}, \ldots, r_{n}}$, the caller processor $p$, and the passed locks $\overline{l}$.

\begin{clarification}[Lock passing]
Processor $p$ passes all its request queue locks and all its call stack locks either if there is a controlled actual argument that will get attached to an attached formal argument of reference type or if the feature call is a separate callback. An attached formal argument of reference type means that the request queue lock or the call stack lock on the actual argument's handler is required during the application of $f$. A controlled actual argument means that $p$ has a request queue lock or a call stack lock on the handler of the actual argument. In short, $p$ has a lock that is required by $q$ and thus $p$ has to pass the locks. A separate callback occurs if $q$ has a lock on $p$. In this situation, $p$ can issue a statement to $q$ and then wait for $q$ to complete. However, processor $q$ could already be waiting for $p$ to complete. To handle this case, the $\issueoperation$ operation in the $\calloperation$ operation triggers an immediate execution by adding the $\applyoperation$ to the beginning of $q$'s action queue. The $\issueoperation$ operation requires that $p$ has the call stack lock of $q$. To enable $q$ to perform an immediate execution, $p$ has to give back $q$'s call stack lock.

In both cases, $p$ has to wait for the locks to come back. Thus it does not hurt to pass all the locks in both cases. In contrast to Nienaltowski's \cite{nienaltowski:2007:SCOOP} description of SCOOP, $p$ only passes the locks that it really has. In particular, $p$ does not pass its own request queue lock in situations where $p$ does not possess this lock, such as when the processor that called $p$ possesses $p$'s request queue lock.
\end{clarification}

In the cases where the operation passes the locks, $\overline{l}$ is $\tuple{\state.\requestqueuelocksfeature(p), \state.\callstacklocksfeature(p)}$. In all other cases there is no lock passing and thus $\overline{l} = \tuple{\set{}, \set{}}$. The operation just determines which locks to pass. The actual lock passing action will be executed by $q$. Similarly, the actual lock revocation action will be executed by $q$.

For command calls, lock passing is the only reason to wait. In this case, the operation creates a fresh channel $a$ to wait for a notification from $q$. The notification arrives when $q$ is ready to return the locks. For query calls, the operation has to wait for the result. The operation uses the given channel $a$ to wait for the result. This has the advantage that once the result arrives, it will be substituted after the $\calloperation$ operation, i.e.\ in the $\resultoperation$ operation of the $\evaluateoperation$ operation.

\inferencerule
	{Call Operation -- Command}
	{
		q \mathematicaldefinition \state.\handlerfeature(r_{0}) \\
		\overline{l} \mathematicaldefinition 
			\left\{
				\begin{split}
					& \multilinecondition{
						& q \neq p \wedge 
						\exists i \in \set{1, \ldots, n} \colon \typingenvironmentderivation{e_{i}: t \wedge \iscontrolledfeature(t)} \wedge 
						\typingenvironmentderivation{f.\formalargumentsfeature(i): (!, g, c) \wedge c.\isreferenceclasstypefeature}
					} \\
					& \indentation \tuple{\state.\requestqueuelocksfeature(p), \state.\callstacklocksfeature(p)} \\
					& \multilinecondition{
						& q \neq p \wedge
						(\state.\requestqueuelocksfeature(q).\containsfeature(p) \vee \state.\callstacklocksfeature(q).\containsfeature(p))
					} \\
					& \indentation \tuple{\state.\requestqueuelocksfeature(p), \state.\callstacklocksfeature(p)} \\
					& \otherwisecondition \\
					& \indentation \tuple{\set{}, \set{}}
				\end{split}
			\right. \\
		\freshchanneldefinition{a}
	}
	{\configuration{p :: \calloperation(r_{0}, f, \tuple{r_{1}, \ldots, r_{n}}, \tuple{e_{1}, \ldots, e_{n}}) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ & \issueoperation(q, \applyoperation(a, r_{0}, f, \tuple{r_{1}, \ldots, r_{n}}, p, \overline{l})) \statementseparator \\
				& \singlelineconditionaloperation
					{\overline{l} \neq \tuple{\set{}, \set{}}}
					{\waitoperation(a)}
					{\nooperation} \statementseparator \\
				& s_{p}
			}
			{\state}
	}
 
\inferencerule
	{Call Operation -- Query}
	{
		q \mathematicaldefinition \state.\handlerfeature(r_{0}) \\
		\overline{l} \mathematicaldefinition 
			\left\{
				\begin{split}
					& \multilinecondition{
						& q \neq p \wedge
						\exists i \in \set{1, \ldots, n} \colon \typingenvironmentderivation{e_{i}: t \wedge \iscontrolledfeature(t)} \wedge
						\typingenvironmentderivation{f.\formalargumentsfeature(i): (!, g, c) \wedge c.\isreferenceclasstypefeature}
					} \\
					& \indentation \tuple{\state.\requestqueuelocksfeature(p), \state.\callstacklocksfeature(p)} \\
					& \multilinecondition{
						& q \neq p \wedge
						(\state.\requestqueuelocksfeature(q).\containsfeature(p) \vee \state.\callstacklocksfeature(q).\containsfeature(p))
					} \\
					& \indentation \tuple{\state.\requestqueuelocksfeature(p), \state.\callstacklocksfeature(p)} \\
					& \otherwisecondition \\
					& \indentation \tuple{\set{}, \set{}}
				\end{split}
			\right.
	}
	{\configuration{p :: \calloperation(a, r_{0}, f, \tuple{r_{1}, \ldots, r_{n}}, \tuple{e_{1}, \ldots, e_{n}}) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{p ::
				\issueoperation(q, \applyoperation(a, r_{0}, f, \tuple{r_{1}, \ldots, r_{n}}, p, \overline{l})) \statementseparator
				\waitoperation(a) \statementseparator
				s_{p}
			}
			{\state}
	}
 
\begin{fortechnicalreport}
\begin{example}[Feature call]
This example demonstrates the inference rules for feature calls. For this purpose, consider again the share market example. Suppose the root processor $p_{1}$ started with the execution of the procedure $do\_transaction$ on the root object $o_{0}$. This procedure is shown in \listingreference{lst:application class with implementation}.

\begin{lstlisting}[caption=Application class with implementation, label=lst:application class with implementation, language=SCOOP, escapechar=\%]
class APPLICATION

create
  make

feature -- Initialization
  make
    do
      ...
    end

feature {APPLICATION} -- Implementation
  market: separate MARKET
      -- The market.
			
  do_transaction (
    first_investor: separate INVESTOR;
    second_investor: separate INVESTOR;
    issuer_id: INTEGER
  )
      -- Make each of the two investors buy and then sell a share of the issuer.
    do
      first_investor.buy (Current.market, issuer_id)
      second_investor.buy (Current.market, issuer_id)
      first_investor.sell (Current.market, issuer_id)
      second_investor.sell (Current.market, issuer_id)
    end
end
\end{lstlisting}

The following configuration is our starting point. Processor $p_{1}$ has one environment for the callee procedure $make$ and one for the called procedure $do\_transaction$. Processor $p_{2}$ handles the market object $o_{35}$, processor $p_{3}$ handles the first investor object $o_{44}$, and processor $p_{4}$ handles the second investor object $o_{46}$. The market object references three arrays. The cash array $o_{25}$ shows that each investor has the same amount of cash. The available shares array $o_{33}$ shows that there is one issuer with one available share. The owned shares array $o_{38}$ shows that none of the investors owns a share. The action queue of $p_{1}$ indicates that $p_{1}$ is about to make the feature calls on the two investors. For this purpose, $p_{1}$ obtained the request queue locks of their handlers.

\isolatedconfiguration
	{
		p_{1} :: \ & first\_investor.buy(\currententity.market, issuer\_id) \statementseparator \\
		& second\_investor.buy(\currententity.market, issuer\_id) \statementseparator \\
		& first\_investor.sell(\currententity.market, issuer\_id) \statementseparator \\
		& second\_investor.sell(\currententity.market, issuer\_id) \statementseparator \\
		& \ldots \processorseparator \\
		p_{2} :: & \processorseparator
		p_{3} :: \processorseparator
		p_{4} ::
	}
	{
		\simplifiedstate
			{
				& \simplifiedstatelocksentry
					{p_{1}}
					{\set{}, \set{p_{3}, p_{4}}}
					{\set{}, \set{}}
					{\set{}, \set{}}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator} \\
				& \simplifiedstatelocksentry
					{p_{2}}
					{}
					{}
					{}
					{\simplifiedstateunlockedindicator}
					{\simplifiedstatenopassedlocksindicator} \\
				& \simplifiedstatelocksentry
					{p_{3}}
					{}
					{}
					{}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator} \\
				& \simplifiedstatelocksentry
					{p_{4}}
					{}
					{}
					{}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator}
			}
			{
				& \simplifiedstateobjectsentry
					{p_{1}}
					{
						\simplifiedstatereferencedobject{r_{0}}{o_{0}(\simplifiedstateentityvalue{market}{r_{1}})}, \simplifiedstatereferencedobject{r_{39}}{o_{48}(1)}
					} \\
				& \simplifiedstateobjectsentry
					{p_{2}}
					{
						& \simplifiedstatereferencedobject{r_{1}}{o_{35}(\simplifiedstateentityvalue{cash}{r_{16}}, \simplifiedstateentityvalue{available\_shares}{r_{23}}, \simplifiedstateentityvalue{owned\_shares}{r_{29}})}, \\
						& \simplifiedstatereferencedobject{r_{16}}{o_{25}[r_{21}, r_{22}]}, \simplifiedstatereferencedobject{r_{21}}{o_{23}(100)}, \simplifiedstatereferencedobject{r_{22}}{o_{24}(100)}, \\
						& \simplifiedstatereferencedobject{r_{23}}{o_{33}[r_{28}]}, \simplifiedstatereferencedobject{r_{28}}{o_{32}(1)}, \\
						& \simplifiedstatereferencedobject{r_{29}}{o_{38}[[r_{34}], [r_{35}]]}, \simplifiedstatereferencedobject{r_{34}}{o_{41}(0)}, \simplifiedstatereferencedobject{r_{35}}{o_{42}(0)}
					} \\
				& \simplifiedstateobjectsentry
					{p_{3}}
					{
						\simplifiedstatereferencedobject{r_{6}}{o_{44}(\simplifiedstateentityvalue{id}{r_{36}})},
						\simplifiedstatereferencedobject{r_{36}}{o_{43}(1)}
					} \\
				& \simplifiedstateobjectsentry
					{p_{4}}
					{
						\simplifiedstatereferencedobject{r_{8}}{o_{46}(\simplifiedstateentityvalue{id}{r_{37}})},
						\simplifiedstatereferencedobject{r_{37}}{o_{45}(2)}
					}
			}
			{}
			{
				& \simplifiedstateenvironmentsentry
					{p_{1}}
					{
						& \simplifiedstateentityvalue{first\_investor}{r_{6}}, \simplifiedstateentityvalue{second\_investor}{r_{8}}, \simplifiedstatecurrententityvalue{r_{0}} \simplifiedstateenvironmentsentryseparator \\
						& \simplifiedstateentityvalue{first\_investor}{r_{6}}, \simplifiedstateentityvalue{second\_investor}{r_{8}}, \simplifiedstateentityvalue{issuer\_id}{r_{39}}, \simplifiedstatecurrententityvalue{r_{0}}
					} \\
				& \simplifiedstateenvironmentsentry
					{p_{2}}
					{} \\
				& \simplifiedstateenvironmentsentry
					{p_{3}}
					{} \\
				& \simplifiedstateenvironmentsentry
					{p_{4}}
					{}
			}
	}

The inference rule for command instructions leads to the following configuration, with fresh channels $a_{59}$, $a_{60}$, and $a_{61}$:

\isolatedconfiguration
	{
		p_{1} :: \ & \evaluateoperation(a_{59}, first\_investor) \statementseparator \\
		& \evaluateoperation(a_{60}, \currententity.market) \statementseparator \\
		& \evaluateoperation(a_{61}, issuer\_id) \statementseparator \\
		& \waitoperation(a_{59}) \statementseparator \\
		& \waitoperation(a_{60}) \statementseparator \\
		& \waitoperation(a_{61}) \statementseparator \\
		& \calloperation(a_{59}.\datafeature, buy, \tuple{a_{60}.\datafeature, a_{61}.\datafeature}, \tuple{\currententity.market, issuer\_id}) \statementseparator \\
		& second\_investor.buy(\currententity.market, issuer\_id) \statementseparator \\
		& first\_investor.sell(\currententity.market, issuer\_id) \statementseparator \\
		& second\_investor.sell(\currententity.market, issuer\_id) \statementseparator \\
		& \ldots \processorseparator \\
		p_{2} :: & \processorseparator
		p_{3} :: \processorseparator
		p_{4} ::
	}
	{\ldots}

First $p_{1}$ has to evaluate the target expression and the actual argument expressions. This leads to the following configuration:

\isolatedconfiguration
	{
		p_{1} :: \ & \calloperation(r_{6}, buy, \tuple{r_{1}, r_{39}}, \tuple{\currententity.market, issuer\_id}) \statementseparator \\
		& second\_investor.buy(\currententity.market, issuer\_id) \statementseparator \\
		& first\_investor.sell(\currententity.market, issuer\_id) \statementseparator \\
		& second\_investor.sell(\currententity.market, issuer\_id) \statementseparator \\
		& \ldots \processorseparator \\
		p_{2} :: & \processorseparator
		p_{3} :: \processorseparator
		p_{4} ::
	}
	{\ldots}

During the execution of the $\calloperation$ operation, $p_{1}$ determines that no locks need to be passed. Then $p_{1}$ executes an $\issueoperation$ operation to enqueue an $\applyoperation$ operation to the action queue of the first investor's handler.
\end{example}
\end{fortechnicalreport}

\subsubsection{Feature applications}\label{sec:feature applications}
A feature call by a client processor $q$ results in a feature request for a supplier processor $p$. A \emph{feature application} is the serving of the feature request. This section discusses how $p$ applies a feature $f$ on a target referenced by $r_{0}$. Processor $p$ takes the following steps:
\begin{enumerate}
	\item Once status update. If $f$ is a once routine, then set its status to non-fresh.
	\item Lock passing. Pass the locks from $q$ to $p$.
	\item Argument passing. Bind the actual arguments to the formal arguments. Arguments of expanded type that are handled by a different processor than $p$ must be deep imported by $p$.
	\item Synchronization. Involve the scheduler to wait until the following synchronization conditions are satisfied atomically:
		\begin{itemize}
			\item Processor $p$ owns the request queue lock of each processor $q$ such that:
				\begin{itemize}
					\item Processor $q$ handles an actual argument of $f$ and the corresponding formal argument has an attached reference type.
					\item Processor $p$ and processor $q$ are different.
					\item Processor $p$ does not have $q$'s request queue lock.
					\item Processor $q$ does not have $p$'s request queue lock.
				\end{itemize}
			\item The precondition of $f$ holds.
		\end{itemize}
	\item Execution.
		\begin{itemize}
			\item If $f$ is a non-once routine or a fresh once routine, then run its body.
			\item If $f$ is a non-fresh procedure, then do nothing. If $f$ is a non-fresh function, then take its once value as the result.
			\item If $f$ is an attribute, then evaluate it.
		\end{itemize}
	\item Postcondition evaluation. Evaluate the postcondition if any of the following conditions is satisfied:
		\begin{itemize}
			\item A feature call in the postcondition requires a lock that was not obtained in the synchronization step.
			\item The evaluation of the postcondition involves lock passing.
		\end{itemize}
		Otherwise ask any processor whose request queue lock was obtained in the synchronization step to evaluate the postcondition.
	\item Lock releasing. Ask each processor whose request queue has been locked in the synchronization step to unlock its request queue after it is done with the feature requests issued by $p$.
	\item Invariant evaluation. If $f$ is a routine, then evaluate the invariant.
	\item Result returning. If $f$ is a query, then return the result to $q$. If the result is of expanded type and $p \neq q$, then the result must be deep imported by $q$.
	\item Lock revocation. Return the passed locks from $p$ to $q$.
\end{enumerate}
Each feature application starts with an operation $\applyoperation(a, r_{0}, f, \tuple{r_{1}, \ldots, r_{n}}, q, \overline{l})$ in the action queue of processor $p$. The channel $a$ is used to communicate with the client processor $q$. If the called feature $f$ is a procedure and the caller processor $q$ passed some locks, then $a$ is used to signal that the locks returned. If $f$ is query, then $a$ is used to return the value. The reference $r_{0}$ points to the target of the call. The references $\tuple{r_{1}, \ldots, r_{n}}$ point to the actual arguments. The tuple $\overline{l}$ contains the locks to be passed from $q$ to $p$.

If one takes a look at the execution step, one can differentiate three cases:
\begin{itemize}
	\item The feature $f$ is a non-once routine or a fresh once routine.
	\item The feature $f$ is a non-fresh once routine.
	\item The feature $f$ is an attribute.
\end{itemize}
For each of these cases, there is one inference rule. Each inference rule covers one variant of the $\applyoperation$ operation. The discussion continues with the most involved case: the feature $f$ is a non-once routine or a fresh once routine.

\inferencerule
	{Application Operation -- Non-Once Routine or Fresh Once Routine}
	{
		f \in \routinetype \wedge f.\isonceroutinefeature \rightarrow \state.\isonceroutinefreshfeature(p, f) \\
		\state.\handlerfeature(r_{0}) = p \\
		\neg \state.\passlocksfeature(q, p, \overline{l}).\arelockspassedfeature(p) \\
		\state' \mathematicaldefinition
			\left\{
				\begin{array}{ll}
					\state.\setoncefunctionnotfreshfeature(p, f, \voidvalue) & \condition{f \in \functiontype \wedge f.\isonceroutinefeature} \\
					\state.\setonceprocedurenotfreshfeature(p, f) & \condition{f \in \proceduretype \wedge f.\isonceroutinefeature} \\
					\state & \otherwisecondition
				\end{array}
			\right. \\
		\state'' \mathematicaldefinition \state'.\passlocksfeature(q, p, \overline{l}).\pushenvironmentwithfeaturefeature(p, f, r_{0}, \tuple{r_{1}, \ldots, r_{n}}) \\
		\begin{split}
			& \overline{g}_{required\_locks} \mathematicaldefinition \set{p} \cup \\
			& \indentation \setinference{x \in \processortype}{\exists i \in \set{1, \ldots, n}, g, c \colon \typingenvironmentderivation{f.\formalargumentsfeature(i): (!, g, c) \wedge c.\isreferenceclasstypefeature} \wedge x = \state''.\handlerfeature(r_{i})}
		\end{split} \\
		\begin{split}
			& \overline{g}_{required\_cs\_locks} \mathematicaldefinition \\
			& \indentation \setinference{x \in \overline{g}_{required\_locks}}{x = p \vee (x \neq p \wedge (\state''.\requestqueuelocksfeature(x).\containsfeature(p) \vee \state''.\callstacklocksfeature(x).\containsfeature(p)))}
		\end{split} \\
		\overline{g}_{required\_rq\_locks} \mathematicaldefinition \overline{g}_{required\_locks} \setminus \overline{g}_{required\_cs\_locks} \\
		\overline{g}_{missing\_rq\_ locks} \mathematicaldefinition \setinference{x \in \overline{g}_{required\_rq\_locks}}{\neg \state''.\requestqueuelocksfeature(p).\containsfeature(x)} \\
		\forall x \in \overline{g}_{required\_cs\_locks} \colon \state''.\callstacklocksfeature(p).\containsfeature(x) \\
		\freshchanneldefinition{a_{inv}} \wedge \freshchanneldefinition{a'}
	}
	{\configuration{p :: \applyoperation(a, r_{0}, f, \tuple{r_{1}, \ldots, r_{n}}, q, \overline{l}) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ & \checkpreconditionandlockrequestqueuesoperation(\overline{g}_{missing\_rq\_ locks}, f) \statementseparator \\
				\multilineconditionaloperation
					{f \in \functiontype \wedge f.\isonceroutinefeature}
					{
						\begin{split}
							& f.\bodyfeature \\
							& \indentation \begin{split}
								& \begin{split}
									\substitution
										{
											\resultentity \eassignment y \statementseparator
											\setonceroutinenotfreshwithresultoperation(f)
										}
										{
											\resultentity \eassignment y
										}
								\end{split} \\
								& \begin{split}
									\substitution
										{
											\ecreate \resultentity.y \statementseparator
											\setonceroutinenotfreshwithresultoperation(f)
										}
										{
											\ecreate \resultentity.y
										}
								\end{split}
							\end{split}
						\end{split}
					}
					{f.\bodyfeature} \statementseparator \\
				& \checkpostconditionandunlockrequestqueuesoperation(\overline{g}_{missing\_rq\_ locks}, f) \statementseparator \\
				\multilineconditionaloperation
					{f.\classtypefeature.\invariantexistsfeature \wedge f.\isexportedfeature}
					{\evaluateoperation(a_{inv}, f.\classtypefeature.\invariantfeature) \statementseparator \waitoperation(a_{inv})}
					{\nooperation} \statementseparator \\
				\multilineconditionaloperation
					{f \in \functiontype}
					{\readvalueoperation(\resultentityname, a') \statementseparator \returnoperation(a, a'.\datafeature, q)}
					{\returnoperation(a, q)} \statementseparator \\
				& s_{p}}
			{\state''}
	}
 
The condition of the inference rule states that each processor can only apply a feature on one of its own objects. The condition also states the $p$ must not have passed its locks. This part of the condition is always given because $p$ waits whenever it passes its locks. In a first step, the operation defines an updated state $\state'$ to set $f$'s once status to non-fresh, in case $f$ is a once routine. The operation does this before deep importing the actual arguments to avoid the following contradiction.

\begin{clarification}[When to change the status of a fresh once routine]
Assume $f$ is either a once procedure or a non-separate once routine. The feature $f$ was fresh at the beginning of the $\applyoperation$ operation. Assume that the caller passed an expanded actual argument that is handled by a processor $g \neq p$. Therefore $p$ has to deep import the actual argument. Assume furthermore that the class type of the actual argument has the once routine $f$ and that $f$ is non-fresh on $g$. If the operation would deep import before setting $f$ as non-fresh on $p$, then the deep import operation would take over the once status of $f$ from processor $g$ to processor $p$. But then the $\applyoperation$ operation on $p$ would not make much sense anymore because $f$ would now be non-fresh on $p$. If the operation sets $f$ as non-fresh at the beginning of the $\applyoperation$ operation, then the deep import operation does not take over the once status from $g$ because $f$ is already non-fresh on $p$.
\end{clarification}

The operation defines an updated state $\state''$ in which the locks are passed from $q$ to $p$ and in which there is a new environment with the actual arguments $\tuple{r_{1}, \ldots, r_{n}}$. The call to the $\pushenvironmentwithfeaturefeature$ feature takes care of copying and deep importing actual arguments of expanded type. The caller processor $q$ can also pass an empty tuple $\tuple{\set{}, \set{}}$ which simply means that $q$ did not pass any locks.

In the next step, the operation synchronizes. For each target expressions in the body of $f$, the operation can get the controlling entity. Each of these controlling entities is mapped to an object and each of these objects is handled by a processor. For each of these processors the operation must either get a request queue lock or a call stack lock. There are three types of calls: non-separate calls, separate calls, and separate callbacks. Non-separate calls and separate callbacks require a call stack lock. Separate calls require a request queue lock. This leads to two sets of required locks: one set with required request queue locks and another set with required call stack locks. The set of required call stack locks is composed of $p$ that will lead to a non-separate call and all the processors that will lead to separate callbacks. The set of required request queue locks is composed of the processors that will lead to separate calls. The operation defines two sets for these two categories: $\overline{g}_{required\_cs\_locks}$ and $\overline{g}_{required\_rq\_locks}$.

Each processor initially has its own call stack lock as its obtained call stack lock. This call stack never gets unlocked. This means that other call stack locks cannot be obtained; they must be retrieved through lock passing. The condition of the inference rule expresses this: $\forall x \in \overline{g}_{required\_cs\_locks} \colon \state''.\callstacklocksfeature(p).\containsfeature(x)$. The operation can be assured that $p$ did not pass its own call stack lock because otherwise $p$ would be waiting. The remaining required call stack locks are the ones for the processors that will lead to separate callbacks. Note that the lock passing conditions are not sufficient to guarantee that the call stack locks for separate callbacks are always available.

As for the request queue locks, the operation calculates $\overline{g}_{missing\_rq\_ locks}$ as the required request queue locks minus the already owned request queue locks. The already owned request queue locks are the previously obtained request queue locks and the retrieved request queue locks. In the synchronization step, the operation must obtain the difference. If this is not possible because some of the missing request queue locks are not available, then the operation must wait. The $\checkpreconditionandlockrequestqueuesoperation$ operation takes care of this; it takes $\overline{g}_{missing\_rq\_ locks}$ and the feature $f$. Once the execution succeeds, $p$ has the request queue locks of $\overline{g}_{missing\_rq\_ locks}$ and the precondition of $f$ holds.

The $\applyoperation$ operation can be assured that each processor $g$, whose obtained request queue lock the operation got in the synchronization step, must be in possession of its call stack lock. If $g$ was not in possession of its call stack lock, it must have passed its locks. This means that $g$ is executing a feature call and still waiting for the locks to return. In order to execute the feature call, there must have been a lock on $g$'s request queue lock so that its action queue can contain the feature call. The request queue must still be locked because $g$ is still executing the feature call. Hence, it would not have been possible to obtain $g$'s request queue lock. The only exception is the bootstrap processor. However this processor only plays a role in the system setup and it never passes its own call stack lock.

Once the operation got all the required locks, it can execute the body. For once functions it must update the once status whenever it writes to the result entity as part of an assignment instruction or as part of a creation instruction. For this purpose, it adds a $\setonceroutinenotfreshwithresultoperation$ operation after each assignment instruction or creation instruction.

After the execution of the body, the operation has to evaluate the postcondition and it has to make sure that the locked request queues get unlocked at the right time. These two steps are performed by another operation $\checkpostconditionandunlockrequestqueuesoperation$ that takes the missing request queue locks $\overline{g}_{missing\_rq\_locks}$ and the feature $f$. This operation evaluates the postcondition either synchronously or asynchronously. After the evaluation of the postcondition, the operation enqueues an $\unlockrequestqueueoperation$ operation to each request queue in $\overline{g}_{missing\_rq\_locks}$.

SCOOP relies on the Eiffel invariant mechanism. This mechanism is described in \externalsectionreference{7.5} and \externalsectionreference{8.9.16} of the Eiffel ECMA standard \cite{ecma:2006:Eiffel}. On one hand, \externalsectionreference{7.5} describes the semantics of invariants: invariants must be satisfied after the execution of every exported routine and after the execution of every creation procedure. On the other hand, \externalsectionreference{8.9.16} describes the runtime monitoring of invariants: invariants get evaluated on both start and termination of a qualified call to a routine and after every call to a creation procedure. We had to decide whether to rely on the semantics of invariants or on the runtime monitoring of invariants. We decided to rely on the semantics of invariants for two reasons. First, the runtime invariant monitoring mechanism is only one possible implementation of the invariant semantics. Second, the runtime invariant monitoring mechanism relies on the notion of unqualified calls. However, for simplicity this work assumes feature calls to be in the canonical qualified form. The $\applyoperation$ operation reflects this decision: the operation evaluates the invariant whenever $f$ is exported. Note that the invariant can only contain non-separate target expressions. Hence, each call in the invariant will only require $p$'s call stack lock.

Finally, the operation has to return the locks and it has to return the result if $f$ is a function. The $\returnoperation$ operation takes care of this. It comes in a variant for queries and in a variant for commands. Both variants take the channel $a$ and the caller processor $q$ in order to communicate with $q$. The variant for queries additionally takes the value to be returned to $q$.

Before explaining the variants of the $\applyoperation$ operation for non-fresh once routines and attributes, the discussion continues with the operations that have not been discussed in detail so far, namely $\checkpreconditionandlockrequestqueuesoperation$, $\checkpostconditionandunlockrequestqueuesoperation$, and $\returnoperation$.

\begin{fortechnicalreport}
\inferencerule
	{Check Precondition and Lock Request Queues Operation}
	{\freshchanneldefinition{a}}
	{\configuration{p :: \checkpreconditionandlockrequestqueuesoperation(\set{q_{1}, \ldots, q_{m}}, f) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ & \lockrequestqueuesoperation(\set{q_{1}, \ldots, q_{m}}) \statementseparator \\
				\multilineconditionaloperation
					{f.\preconditionexistsfeature}
					{
						\begin{split}
							& \evaluateoperation(a, f.\preconditionfeature) \statementseparator \\
							& \waitoperation(a) \statementseparator \\
							\multilineconditionaloperation
								{a.\datafeature}
								{\nooperation}
								{
									\begin{split}
										& \issueoperation(q_{1}, \unlockrequestqueueoperation) \statementseparator \\
										& \ldots \\
										& \issueoperation(q_{m}, \unlockrequestqueueoperation) \statementseparator \\
										& \popobtainedrequestqueuelocksoperation \statementseparator \\
										& \checkpreconditionandlockrequestqueuesoperation(\set{q_{1}, \ldots, q_{m}}, f)
									\end{split}
								}
						\end{split}
					}
					{\nooperation} \statementseparator \\
				& s_{p}}
			{\state}
	}
 \end{fortechnicalreport}

\begin{forjournal}
\inferencerule
	{Check Precondition and Lock Request Queues Operation}
	{\freshchanneldefinition{a}}
	{\configuration{p :: \checkpreconditionandlockrequestqueuesoperation(\set{q_{1}, \ldots, q_{m}}, f) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ & \lockrequestqueuesoperation(\set{q_{1}, \ldots, q_{m}}) \statementseparator \\
				\multilineconditionaloperation
					{f.\preconditionexistsfeature}
					{
						\begin{split}
							& \evaluateoperation(a, f.\preconditionfeature) \statementseparator \\
							& \waitoperation(a) \statementseparator \\
							\multilineconditionaloperation
								{a.\datafeature}
								{\nooperation}
								{
									\begin{split}
										& \issueoperation(q_{1}, \unlockrequestqueueoperation) \statementseparator \\
										& \ldots \\
										& \issueoperation(q_{m}, \unlockrequestqueueoperation) \statementseparator \\
										& \popobtainedrequestqueuelocksoperation \statementseparator \\
										& \checkpreconditionandlockrequestqueuesoperation(\set{q_{1}, \ldots, q_{m}}, f)
									\end{split}
								}
						\end{split}
					}
					{\nooperation} \statementseparator \\
				& s_{p}}
			{\state}
	}
 \end{forjournal}

The $\checkpreconditionandlockrequestqueuesoperation(\set{q_{1}, \ldots, q_{m}}, f)$ operation, executed by processor $p$, takes a processor set $\set{q_{1}, \ldots, q_{m}}$ whose request queues must be locked on behalf of $p$ and it takes a feature $f$ whose precondition must be satisfied. The operation treats the precondition as a wait condition. It goes through a number of iterations. Each iteration obtains the request queue locks and then evaluates the precondition. If the precondition is satisfied, then the $\checkpreconditionandlockrequestqueuesoperation$ operation finishes. Otherwise it unlocks the request queues and then starts a new iteration.

\begin{fortechnicalreport}
\inferencerule
	{Check Postcondition and Unlock Request Queues Operation}
	{
		\overline{q} \mathematicaldefinition \set{q_{1}, \ldots, q_{m}} \\
		p \notin \overline{q} \\
		\targetsfeature(e) \mathematicaldefinition
		\left\{
			\begin{array}{ll}
				\set{e_{0}} \cup \bigcup_{i = 0 \ldots n}^{}{\targetsfeature(e_{i})} & \condition{e = e_{0}.w(e_{1}, \ldots, e_{n})} \\
				\set{} & \otherwisecondition
			\end{array}
		\right. \\
		\actualargumentsfeature(e) \mathematicaldefinition
		\left\{
			\begin{array}{ll}
				\bigcup_{i = 1 \ldots n}^{}{\set{\tuple{e_{i}, w, i}} \cup \actualargumentsfeature(e_{i})} & \condition{e = e_{0}.w(e_{1}, \ldots, e_{n})} \\
				\set{} & \otherwisecondition
			\end{array}
		\right. \\
		g_{0} \mathematicalelementdefinition
			\left\{
				\begin{split}
					& \multilinecondition{
						& \overline{q} \neq \set{} \wedge \\
						& \forall {x \in \targetsfeature(f.\postconditionfeature)} \colon (\typingenvironmentderivation{\state.\handlerfeature(\state.\valuefeature(p, \controllingentityfeature(x).\namefeature)) \in \overline{q}}) \wedge \\
						& \begin{split}
							& \neg \exists \tuple{x, y, z} \in \actualargumentsfeature(f.\postconditionfeature), t, h, c \colon \\
							& \indentation (\typingenvironmentderivation{x: t \wedge \iscontrolledfeature(t) \wedge y.\formalargumentsfeature(z): (!, h, c) \wedge c.\isreferenceclasstypefeature})
						\end{split}
					} \\
					& \indentation \overline{q} \\
					& \otherwisecondition \\
					& \indentation \set{p}
				\end{split}
			\right. \\
		\set{g_{1}, \ldots, g_{j}} \mathematicaldefinition \overline{q} \setminus g_{0} \\
		\freshchanneldefinition{a}
	}
	{\configuration{p :: \checkpostconditionandunlockrequestqueuesoperation(\set{q_{1}, \ldots, q_{m}}, f) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ \multilineconditionaloperation
					{f.\postconditionexistsfeature \wedge g_{0} \neq p}
					{
						\begin{split}
							& \begin{split}
								& \issueoperation( \\
								& \indentation \begin{split}
									& g_{0}, \\
									& \executedelegatedoperation( \\
									& \indentation \begin{split}
										& \indentation \begin{split}
											& \evaluateoperation(a, f.\postconditionfeature) \statementseparator \waitoperation(a) \statementseparator \\
											& \issueoperation(g_{1}, \unlockrequestqueueoperation) \statementseparator \ldots \statementseparator \issueoperation(g_{j}, \unlockrequestqueueoperation)
										\end{split} \\
										& , \\
										& \indentation \state.\environmentsfeature(p).\topfeature, \set{q_{1}, \ldots, q_{m}}
									\end{split} \\
									& ) \statementseparator \\
									& \unlockrequestqueueoperation
								\end{split}	\\
								& ) \statementseparator
							\end{split} \\
							& \popobtainedrequestqueuelocksoperation
						\end{split}
					}
					{
						\begin{split}
							\multilineconditionaloperation
								{f.\postconditionexistsfeature}
								{\evaluateoperation(a, f.\postconditionfeature) \statementseparator \waitoperation(a)}
								{\nooperation} \statementseparator \\
							& \issueoperation(q_{1}, \unlockrequestqueueoperation) \statementseparator \ldots \statementseparator \issueoperation(q_{m}, \unlockrequestqueueoperation) \statementseparator \\
							& \popobtainedrequestqueuelocksoperation
						\end{split}
					} \statementseparator \\
				& s_{p}
			}
			{\state}
	}
 \end{fortechnicalreport}

The $\checkpostconditionandunlockrequestqueuesoperation$ operation also takes a processor set $\set{q_{1}, \ldots, q_{m}}$ and a feature $f$. The processor set is the same as for the  $\checkpreconditionandlockrequestqueuesoperation$ operation, i.e., the set of processors whose request queues got locked in the synchronization step. The operation first determines whether the postcondition should be evaluated synchronously or asynchronously. Then the operation starts the evaluation. Finally, the operation enqueues an $\unlockrequestqueueoperation$ operation to each request queue in $\set{q_{1}, \ldots, q_{m}}$.

\begin{forjournal}
\inferencerule
	{Check Postcondition and Unlock Request Queues Operation}
	{
		\overline{q} \mathematicaldefinition \set{q_{1}, \ldots, q_{m}} \\
		p \notin \overline{q} \\
		\targetsfeature(e) \mathematicaldefinition
		\left\{
			\begin{array}{ll}
				\set{e_{0}} \cup \bigcup_{i = 0 \ldots n}^{}{\targetsfeature(e_{i})} & \condition{e = e_{0}.w(e_{1}, \ldots, e_{n})} \\
				\set{} & \otherwisecondition
			\end{array}
		\right. \\
		\actualargumentsfeature(e) \mathematicaldefinition
		\left\{
			\begin{array}{ll}
				\bigcup_{i = 1 \ldots n}^{}{\set{\tuple{e_{i}, w, i}} \cup \actualargumentsfeature(e_{i})} & \condition{e = e_{0}.w(e_{1}, \ldots, e_{n})} \\
				\set{} & \otherwisecondition
			\end{array}
		\right. \\
		g_{0} \mathematicalelementdefinition
			\left\{
				\begin{split}
					& \multilinecondition{
						& \overline{q} \neq \set{} \wedge \\
						& \forall {x \in \targetsfeature(f.\postconditionfeature)} \colon (\typingenvironmentderivation{\state.\handlerfeature(\state.\valuefeature(p, \controllingentityfeature(x).\namefeature)) \in \overline{q}}) \wedge \\
						& \begin{split}
							& \neg \exists \tuple{x, y, z} \in \actualargumentsfeature(f.\postconditionfeature), t, h, c \colon \\
							& \indentation (\typingenvironmentderivation{x: t \wedge \iscontrolledfeature(t) \wedge y.\formalargumentsfeature(z): (!, h, c) \wedge c.\isreferenceclasstypefeature})
						\end{split}
					} \\
					& \indentation \overline{q} \\
					& \otherwisecondition \\
					& \indentation \set{p}
				\end{split}
			\right. \\
		\set{g_{1}, \ldots, g_{j}} \mathematicaldefinition \overline{q} \setminus g_{0} \\
		\freshchanneldefinition{a}
	}
	{\configuration{p :: \checkpostconditionandunlockrequestqueuesoperation(\set{q_{1}, \ldots, q_{m}}, f) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ \multilineconditionaloperation
					{f.\postconditionexistsfeature \wedge g_{0} \neq p}
					{
						\begin{split}
							& \begin{split}
								& \issueoperation( \\
								& \indentation \begin{split}
									& g_{0}, \\
									& \executedelegatedoperation( \\
									& \indentation \begin{split}
										& \indentation \begin{split}
											& \evaluateoperation(a, f.\postconditionfeature) \statementseparator \waitoperation(a) \statementseparator \\
											& \issueoperation(g_{1}, \unlockrequestqueueoperation) \statementseparator \ldots \statementseparator \issueoperation(g_{j}, \unlockrequestqueueoperation)
										\end{split} \\
										& , \\
										& \indentation \state.\environmentsfeature(p).\topfeature, \set{q_{1}, \ldots, q_{m}}
									\end{split} \\
									& ) \statementseparator \\
									& \unlockrequestqueueoperation
								\end{split}	\\
								& ) \statementseparator
							\end{split} \\
							& \popobtainedrequestqueuelocksoperation
						\end{split}
					}
					{
						\begin{split}
							\multilineconditionaloperation
								{f.\postconditionexistsfeature}
								{\evaluateoperation(a, f.\postconditionfeature) \statementseparator \waitoperation(a)}
								{\nooperation} \statementseparator \\
							& \issueoperation(q_{1}, \unlockrequestqueueoperation) \statementseparator \ldots \statementseparator \issueoperation(q_{m}, \unlockrequestqueueoperation) \statementseparator \\
							& \popobtainedrequestqueuelocksoperation
						\end{split}
					} \statementseparator \\
				& s_{p}
			}
			{\state}
	}
 \end{forjournal}

\begin{clarification}[Asynchronous postcondition evaluation]
The postcondition can be evaluated asynchronously if every feature call in the postcondition only requires a request queue lock that was obtained in the synchronization step and if the postcondition does not involve lock passing. If the postcondition has a feature call that requires a lock different from the obtained request queue locks, then $p$ cannot delegate its obtained request queue lock and then continue because the required lock would be required in another feature execution context as well. Hence the postcondition must be evaluated synchronously in this case. If the postcondition involves lock passing, then one of $p$'s lock might be necessary for the evaluation of the postcondition. Hence, $p$ must pass its locks and cannot proceed until the postcondition is evaluated and the passed locks returned. Once again, the postcondition must be evaluated synchronously. In Nienaltowski's description of SCOOP \cite{nienaltowski:2007:SCOOP} a postcondition can be evaluated asynchronously if the current processor is not involved in the postcondition evaluation. This rule permits configurations in which the evaluating processor does not have the necessary locks for the evaluation.
\end{clarification}

If the postcondition can be evaluated asynchronously, then the operation can take one of the processors in $\set{q_{1}, \ldots, q_{m}}$. This set does not contain processor $p$ because processor $p$ never obtains its own request queue lock. Each processor in this set is exclusively available in the current execution context and can thus be used to evaluate the postcondition asynchronously. The $\checkpostconditionandunlockrequestqueuesoperation$ operation defines $g_{0}$ to be the evaluating processor according to the rule just presented. It also defines $\set{g_{1}, \ldots, g_{j}}$ to be the set $\set{q_{1}, \ldots, q_{m}}$ minus the request queue lock of $g_{0}$. If $p$ is the evaluating processor, then this set is the same as $\set{q_{1}, \ldots, q_{m}}$. As a result of these definitions, the postcondition can be evaluated asynchronously if $g_{0} \neq p$. Otherwise, the postcondition must be evaluated synchronously.

In the synchronous case, processor $p$ evaluates the postcondition, enqueues $\unlockrequestqueueoperation$ operations to each request queue in $\set{q_{1}, \ldots, q_{m}}$, and then removes the corresponding locks from its stack of obtained request queue locks. The $\unlockrequestqueueoperation$ operations will not proceed until the locks have been removed from $p$'s stack of obtained request queue locks. In the asynchronous case, processor $p$ must delegate the postcondition evaluation to processor $g_{0}$. For this purpose, $p$ enqueues an $\executedelegatedoperation$ operation to $g_{0}$. The workload involves the postcondition evaluation along with the subsequent issuing of $\unlockrequestqueueoperation$ operations to all processor in $\set{g_{1}, \ldots, g_{j}}$. Processor $g_{0}$ unlocks its own request queue after the delegated execution. The evaluation of the postcondition on $g_{0}$ requires the environment that defines the values of the entities in the postcondition. Furthermore, the evaluation requires the request queue locks $\set{q_{1}, \ldots, q_{m}}$. These locks are sufficient because the postcondition only gets evaluated asynchronously if the evaluation only requires these locks. To satisfy these two requirements, $p$ gives its top environment and $\set{q_{1}, \ldots, q_{m}}$ to $g_{0}$. After $g_{0}$ performed the delegated execution, it can unlock its own request queue. In the meantime, processor $p$ removes $\set{q_{1}, \ldots, q_{m}}$ from its obtained request queue locks to enable $g_{0}$ to proceed with the delegated execution.

The $\returnoperation$ operation comes in two variants: one for queries and one for commands.

\singlelineinferencerule
	{Return Operation -- Query}
	{
		\begin{split}
			& \tuple{\state', r'} \mathematicaldefinition
				\left\{
					\begin{split}
						& \condition{r \neq \voidvalue \wedge \state.\referencedobjectfeature(r).\classtypefeature.\isexpandedclasstypefeature \wedge \state.\handlerfeature(r) \neq q} \\
						& \indentation \where
							{\tuple{\state_{x}, \state_{x}.\lastimportedreferencefeature}}
							{\state_{x} \mathematicaldefinition \state.\deepimportfeature(q, r)} \\
							& \otherwisecondition \\
							& \indentation \tuple{\state, r}
					\end{split}
				\right.
		\end{split} \\
		\state'' \mathematicaldefinition \state'.\popenvironmentfeature(p).\revokelocksfeature(q, p)
	}
	{\configuration{p :: \returnoperation(a, r, q) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{p :: \resultoperation(a, r') \statementseparator s_{p}}
			{\state''}
	}
 
\inferencerule
	{Return Operation -- Command}
	{\state' \mathematicaldefinition \state.\popenvironmentfeature(p).\revokelocksfeature(q, p)}
	{\configuration{p :: \returnoperation(a, q) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ & \singlelineconditionaloperation
					{\state.\arelockspassedfeature(q)}
					{\notifyoperation(a)}
					{\nooperation} \statementseparator
				s_{p}
			}
			{\state'}
	}
 
The variant for queries returns the result and the locks. The variant for commands only returns the locks. Both variants take a channel $a$ and the caller processor $q$. For queries, the channel is used to return the result. For this purpose, the operation takes a reference $r$ that points to the result. Processor $q$ is waiting for this result on channel $a$. This can be seen in the $\calloperation$ operation, which issues an $\applyoperation$ operation and a subsequent $\waitoperation(a)$ operation. The $\applyoperation$ operation calls the $\returnoperation$ operation with the same channel $a$. To return the result to $q$, processor $p$ executes a $\resultoperation$ on $a$. The value to be returned is not always $r$ directly. If $r$ points to an object of expanded class type and $q \neq p$, then $q$ must deep import the object. In all other cases, $q$ can take $r$ as the return value. An explanation why the deep import operation is necessary can be found in \sectionreference{sec:setting values}. For commands, the channel is used to signal to $q$ that the locks have been returned in case $q$ passed its locks. This can be determined by looking at the state: $\state.\arelockspassedfeature(q)$. In both variants of the $\returnoperation$ operation, $p$ removes the passed locks from the stacks of retrieved locks. In case $q$ did not pass any locks, the removed entries might be the empty set. Processor $p$ also removes its top environment because this environment is no longer needed. In case of an asynchronous postcondition evaluation, this environment temporarily gets delegated to the evaluating processor.

Until now, the discussion left out the non-fresh once routines and the attributes. Non-fresh once functions already have a result. The $\applyoperation$ operation just needs to get this result from the state and return it. For non-fresh once procedures it does not even have to do this. The only obligation is the evaluation of the invariant. The evaluation of the invariant requires the call stack lock of $p$. This lock is given if the condition $\neg \state.\arelockspassedfeature(p)$ holds. For attributes, note that an instance of $\attributetype$ is also an instance of $\expressiontype$. Hence, the operation evaluates the attribute expression and returns the result of the evaluation. The invariant does not have to be evaluated in this case.

\inferencerule
	{Application Operation -- Non-Fresh Once Routine}
	{
		f \in \routinetype \wedge f.\isonceroutinefeature \wedge \neg \state.\isonceroutinefreshfeature(p, f) \\
		\state.\handlerfeature(r_{0}) = p \\
		\neg \state.\passlocksfeature(q, p, \overline{l}).\arelockspassedfeature(p) \\
		\state' \mathematicaldefinition \state.\passlocksfeature(q, p, \overline{l}).\pushenvironmentwithfeaturefeature(p, f, r_{0}, \tuple{r_{1},\ldots, r_{n}}) \\
		\freshchanneldefinition{a_{inv}}
	}
	{\configuration{p :: \applyoperation(a, r_{0}, f, \tuple{r_{1}, \ldots, r_{n}}, q, \overline{l}) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ \multilineconditionaloperation
					{f.\classtypefeature.\invariantexistsfeature \wedge f.\isexportedfeature}
					{\evaluateoperation(a_{inv}, f.\classtypefeature.\invariantfeature) \statementseparator \waitoperation(a_{inv})}
					{\nooperation} \statementseparator \\
				\multilineconditionaloperation
					{f \in \functiontype}
					{\returnoperation(a, \state'.\oncefunctionresultfeature(p, f), q)}
					{\returnoperation(a, q)} \statementseparator \\
				& s_{p}}
			{\state'}
	}
 
\inferencerule
	{Application Operation -- Attribute}
	{
		f \in \attributetype \\
		\state.\handlerfeature(r_{0}) = p \\
		\neg \state.\passlocksfeature(q, p, \overline{l}).\arelockspassedfeature(p) \\
		\state' \mathematicaldefinition \state.\passlocksfeature(q, p, \overline{l}).\pushenvironmentwithfeaturefeature(p, f, r_{0}, \tuple{}) \\
		\freshchanneldefinition{a'}
	}
	{\configuration{p :: \applyoperation(a, r_{0}, f, \tuple{}, q, \overline{l}) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ & \evaluateoperation(a', f) \statementseparator \\
				& \waitoperation(a') \statementseparator \\
				& \returnoperation(a, a'.\datafeature, q) \statementseparator \\
				& s_{p}}
			{\state'}
	}
 
\begin{fortechnicalreport}
\newpage
\begin{example}[Feature application]
This example looks at the application of the feature $buy$ on the first investor. This feature is shown in \listingreference{lst:investor class}.

\begin{lstlisting}[caption=Investor class, label=lst:investor class, language=SCOOP]
class INVESTOR

create
  make
	
feature -- Initialization
  make (new_id: INTEGER)
      -- Create an investor with a new identifier.
    do
      id := new_id
    end
		
feature -- Access
  id: INTEGER
      -- The identifier.
	
  log: separate UUID
      -- The identifier of the last market.

  buy (market: separate MARKET; issuer_id: INTEGER)
      -- Buy a share of the issuer on the market.
    require
      market.can_buy (Current.id, issuer_id)
    do
      market.buy (Current, issuer_id)
      log := market.id
    ensure
      market.can_sell (Current.id, issuer_id)
    end

    ...		
end
\end{lstlisting}

The execution starts with a configuration where processor $p_{1}$ finished executing the feature calls in feature $do\_transaction$. These feature calls led to one $\applyoperation$ operation for the $buy$ feature and one for the $sell$ feature in each investor's action queue.

\isolatedconfiguration
	{
		p_{1} :: \ & \ldots \processorseparator \\
		p_{2} :: \ & \processorseparator \\
		p_{3} :: \ & \applyoperation(a_{62}, r_{6}, buy, \tuple{r_{1}, r_{39}}, p_{1}, \tuple{\set{}, \set{}}) \statementseparator \\
		& \applyoperation(a_{70}, r_{6}, sell, \tuple{r_{1}, r_{39}}, p_{1}, \tuple{\set{}, \set{}}) \processorseparator \\
		p_{4} :: \ & \applyoperation(a_{66}, r_{8}, buy, \tuple{r_{1}, r_{39}}, p_{1}, \tuple{\set{}, \set{}}) \statementseparator \\
		& \applyoperation(a_{74}, r_{8}, sell, \tuple{r_{1}, r_{39}}, p_{1}, \tuple{\set{}, \set{}})
	}
	{
		\simplifiedstate
			{
				& \simplifiedstatelocksentry
					{p_{1}}
					{\set{}, \set{p_{3}, p_{4}}}
					{\set{}, \set{}}
					{\set{}, \set{}}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator} \\
				& \simplifiedstatelocksentry
					{p_{2}}
					{}
					{}
					{}
					{\simplifiedstateunlockedindicator}
					{\simplifiedstatenopassedlocksindicator} \\
				& \simplifiedstatelocksentry
					{p_{3}}
					{}
					{}
					{}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator} \\
				& \simplifiedstatelocksentry
					{p_{4}}
					{}
					{}
					{}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator}
			}
			{
				& \simplifiedstateobjectsentry
					{p_{1}}
					{
						\simplifiedstatereferencedobject{r_{0}}{o_{0}(\simplifiedstateentityvalue{market}{r_{1}})}, \simplifiedstatereferencedobject{r_{39}}{o_{48}(1)}
					} \\
				& \simplifiedstateobjectsentry
					{p_{2}}
					{
						& \simplifiedstatereferencedobject{r_{1}}{o_{35}(\simplifiedstateentityvalue{cash}{r_{16}}, \simplifiedstateentityvalue{available\_shares}{r_{23}}, \simplifiedstateentityvalue{owned\_shares}{r_{29}})}, \\
						& \simplifiedstatereferencedobject{r_{16}}{o_{25}[r_{21}, r_{22}]}, \simplifiedstatereferencedobject{r_{21}}{o_{23}(100)}, \simplifiedstatereferencedobject{r_{22}}{o_{24}(100)}, \\
						& \simplifiedstatereferencedobject{r_{23}}{o_{33}[r_{28}]}, \simplifiedstatereferencedobject{r_{28}}{o_{32}(1)}, \\
						& \simplifiedstatereferencedobject{r_{29}}{o_{38}[[r_{34}], [r_{35}]]}, \simplifiedstatereferencedobject{r_{34}}{o_{41}(0)}, \simplifiedstatereferencedobject{r_{35}}{o_{42}(0)}
					} \\
				& \simplifiedstateobjectsentry
					{p_{3}}
					{
						\simplifiedstatereferencedobject{r_{6}}{o_{44}(\simplifiedstateentityvalue{id}{r_{36}})},
						\simplifiedstatereferencedobject{r_{36}}{o_{43}(1)}
					} \\
				& \simplifiedstateobjectsentry
					{p_{4}}
					{
						\simplifiedstatereferencedobject{r_{8}}{o_{46}(\simplifiedstateentityvalue{id}{r_{37}})},
						\simplifiedstatereferencedobject{r_{37}}{o_{45}(2)}
					}
			}
			{}
			{
				& \simplifiedstateenvironmentsentry
					{p_{1}}
					{
						& \simplifiedstateentityvalue{first\_investor}{r_{6}}, \simplifiedstateentityvalue{second\_investor}{r_{8}}, \simplifiedstatecurrententityvalue{r_{0}} \simplifiedstateenvironmentsentryseparator \\
						& \simplifiedstateentityvalue{first\_investor}{r_{6}}, \simplifiedstateentityvalue{second\_investor}{r_{8}}, \simplifiedstateentityvalue{issuer\_id}{r_{39}}, \simplifiedstatecurrententityvalue{r_{0}}
					} \\
				& \simplifiedstateenvironmentsentry
					{p_{2}}
					{} \\
				& \simplifiedstateenvironmentsentry
					{p_{3}}
					{} \\
				& \simplifiedstateenvironmentsentry
					{p_{4}}
					{}
			}
	}

At this point, processors $p_{3}$ and $p_{4}$ can each take the transition that is described by the inference rule for the $\applyoperation$ operation for non-once routines. Each processor can then take an additional transition by executing the $\checkpreconditionandlockrequestqueuesoperation$ operation. The result configuration is shown below. The channel $a_{75}$ is a fresh channel. Both processors added a new environment that maps the expanded formal argument to a copy of the expanded actual argument. In case of processor $p_{3}$, the copied object is referenced by $r_{40}$. On processor $p_{4}$, the copied object is referenced by $r_{41}$. Since processor $p_{1}$ did not pass its locks, both $p_{3}$ and $p_{4}$ added empty lock sets to their stack of retrieved locks.

\isolatedconfiguration
	{
		p_{1} :: \ & \ldots \processorseparator \\
		p_{2} :: \ & \processorseparator \\
		p_{3} :: \ & \lockrequestqueuesoperation(\set{p_{2}}) \statementseparator \\
		& \evaluateoperation(a_{75}, market.can\_buy(\currententity.id, issuer\_id)) \statementseparator \\
		& \waitoperation(a_{75}) \statementseparator \\
		\multilineconditionaloperation
				{a_{75}.\datafeature}
				{\nooperation}
				{
					\begin{split}
						& \issueoperation(p_{2}, \unlockrequestqueueoperation) \statementseparator \\
						& \popobtainedrequestqueuelocksoperation \statementseparator \\
						& \checkpreconditionandlockrequestqueuesoperation(\set{p_{2}}, buy)
					\end{split}
				} \statementseparator \\
		& market.buy (\currententity, issuer\_id) \statementseparator \\
		& log \eassignment market.id \statementseparator \\
		& \checkpostconditionandunlockrequestqueuesoperation(\set{p_{2}}, buy) \statementseparator \\
		& \returnoperation(a_{62}, p_{1}) \statementseparator \\
		& \applyoperation(a_{70}, r_{6}, sell, \tuple{r_{1}, r_{39}}, p_{1}, \tuple{\set{}, \set{}}) \processorseparator \\
		p_{4} :: \ & \lockrequestqueuesoperation(\set{p_{2}}) \statementseparator \\
		& \ldots
	}
	{
		\simplifiedstate
			{
				& \simplifiedstatelocksentry
					{p_{1}}
					{\set{}, \set{p_{3}, p_{4}}}
					{\set{}, \set{}}
					{\set{}, \set{}}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator} \\
				& \simplifiedstatelocksentry
					{p_{2}}
					{}
					{}
					{}
					{\simplifiedstateunlockedindicator}
					{\simplifiedstatenopassedlocksindicator} \\
				& \simplifiedstatelocksentry
					{p_{3}}
					{}
					{\set{}}
					{\set{}}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator} \\
				& \simplifiedstatelocksentry
					{p_{4}}
					{}
					{\set{}}
					{\set{}}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator}
			}
			{
				& \simplifiedstateobjectsentry
					{p_{1}}
					{
						\simplifiedstatereferencedobject{r_{0}}{o_{0}(\simplifiedstateentityvalue{market}{r_{1}})}, \simplifiedstatereferencedobject{r_{39}}{o_{48}(1)}
					} \\
				& \simplifiedstateobjectsentry
					{p_{2}}
					{
						& \simplifiedstatereferencedobject{r_{1}}{o_{35}(\simplifiedstateentityvalue{cash}{r_{16}}, \simplifiedstateentityvalue{available\_shares}{r_{23}}, \simplifiedstateentityvalue{owned\_shares}{r_{29}})}, \\
						& \simplifiedstatereferencedobject{r_{16}}{o_{25}[r_{21}, r_{22}]}, \simplifiedstatereferencedobject{r_{21}}{o_{23}(100)}, \simplifiedstatereferencedobject{r_{22}}{o_{24}(100)}, \\
						& \simplifiedstatereferencedobject{r_{23}}{o_{33}[r_{28}]}, \simplifiedstatereferencedobject{r_{28}}{o_{32}(1)}, \\
						& \simplifiedstatereferencedobject{r_{29}}{o_{38}[[r_{34}], [r_{35}]]}, \simplifiedstatereferencedobject{r_{34}}{o_{41}(0)}, \simplifiedstatereferencedobject{r_{35}}{o_{42}(0)}
					} \\
				& \simplifiedstateobjectsentry
					{p_{3}}
					{
						\simplifiedstatereferencedobject{r_{6}}{o_{44}(\simplifiedstateentityvalue{id}{r_{36}})},
						\simplifiedstatereferencedobject{r_{36}}{o_{43}(1)},
						\simplifiedstatereferencedobject{r_{40}}{o_{49}(1)}
					} \\
				& \simplifiedstateobjectsentry
					{p_{4}}
					{
						\simplifiedstatereferencedobject{r_{8}}{o_{46}(\simplifiedstateentityvalue{id}{r_{37}})},
						\simplifiedstatereferencedobject{r_{37}}{o_{45}(2)},
						\simplifiedstatereferencedobject{r_{41}}{o_{50}(1)}
					}
			}
			{}
			{
				& \simplifiedstateenvironmentsentry
					{p_{1}}
					{
						& \simplifiedstateentityvalue{first\_investor}{r_{6}}, \simplifiedstateentityvalue{second\_investor}{r_{8}}, \simplifiedstatecurrententityvalue{r_{0}} \simplifiedstateenvironmentsentryseparator \\
						& \simplifiedstateentityvalue{first\_investor}{r_{6}}, \simplifiedstateentityvalue{second\_investor}{r_{8}}, \simplifiedstateentityvalue{issuer\_id}{r_{39}}, \simplifiedstatecurrententityvalue{r_{0}}
					} \\
				& \simplifiedstateenvironmentsentry
					{p_{2}}
					{} \\
				& \simplifiedstateenvironmentsentry
					{p_{3}}
					{
						& \simplifiedstateentityvalue{market}{r_{1}}, \simplifiedstateentityvalue{issuer\_id}{r_{40}}, \simplifiedstatecurrententityvalue{r_{6}}
					} \\
				& \simplifiedstateenvironmentsentry
					{p_{4}}
					{
						& \simplifiedstateentityvalue{market}{r_{1}}, \simplifiedstateentityvalue{issuer\_id}{r_{41}}, \simplifiedstatecurrententityvalue{r_{8}}
					}
			}
	}

The inference rule for the $\lockrequestqueuesoperation$ operation shows that both $p_{3}$ and $p_{4}$ require the request queue lock of $p_{2}$. We decide to give priority to $p_{3}$. This leads to the following configuration, where $p_{2}$'s request queue is locked on behalf of $p_{3}$:

\isolatedconfiguration
	{
		p_{1} :: \ & \ldots \processorseparator \\
		p_{2} :: \ & \processorseparator \\
		p_{3} :: \ & \evaluateoperation(a_{75}, market.can\_buy(\currententity.id, issuer\_id)) \statementseparator \\
		& \waitoperation(a_{75}) \statementseparator \\
		\multilineconditionaloperation
			{a_{75}.\datafeature}
			{\nooperation}
			{
				\begin{split}
					& \issueoperation(p_{2}, \unlockrequestqueueoperation) \statementseparator \\
					& \popobtainedrequestqueuelocksoperation \statementseparator \\
					& \checkpreconditionandlockrequestqueuesoperation(\set{p_{2}}, buy)
				\end{split}
			} \statementseparator \\
		& market.buy (\currententity, issuer\_id) \statementseparator \\
		& log \eassignment market.id \statementseparator \\
		& \checkpostconditionandunlockrequestqueuesoperation(\set{p_{2}}, buy) \statementseparator \\
		& \returnoperation(a_{62}, p_{1}) \statementseparator \\
		& \applyoperation(a_{70}, r_{6}, sell, \tuple{r_{1}, r_{39}}, p_{1}, \tuple{\set{}, \set{}}) \processorseparator \\
		p_{4} :: & \ldots
	}
	{
		\simplifiedstate
			{
				& \simplifiedstatelocksentry
					{p_{1}}
					{\set{}, \set{p_{3}, p_{4}}}
					{\set{}, \set{}}
					{\set{}, \set{}}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator} \\
				& \simplifiedstatelocksentry
					{p_{2}}
					{}
					{}
					{}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator} \\
				& \simplifiedstatelocksentry
					{p_{3}}
					{\set{p_{2}}}
					{\set{}}
					{\set{}}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator} \\
				& \simplifiedstatelocksentry
					{p_{4}}
					{}
					{\set{}}
					{\set{}}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator}
			}
			{\ldots}
			{}
			{\ldots}
	}

The evaluation of the precondition produces a result on $p_{2}$, which is awaited by $p_{3}$. The result is a deep imported object of class type $\booleanclasstype$, referenced by $r_{58}$. The boolean value of this object indicates that the precondition is satisfied and hence $p_{3}$ can continue with the execution of the body. In the following configuration, the arrays referenced by $r_{16}$, $r_{23}$, and $r_{29}$ have been updated; the first investor bought a share of the issuer. Consequently, the first investor has a lower amount of cash and there is one fewer share available. Furthermore, the $log$ attribute of the first investor object has been updated with the identifier of the market. This identifier object, referenced by $r_{65}$, has been created by $p_{2}$ in a once function of separate type. Hence the object is available as a once result on all processors in the system.

\isolatedconfiguration
	{
		p_{1} :: \ & \ldots \processorseparator
		p_{2} :: \processorseparator \\
		p_{3} :: \ & \checkpostconditionandunlockrequestqueuesoperation(\set{p_{2}}, buy) \statementseparator \\
		& \returnoperation(a_{62}, p_{1}) \statementseparator \\
		& \applyoperation(a_{70}, r_{6}, sell, \tuple{r_{1}, r_{39}}, p_{1}, \tuple{\set{}, \set{}}) \processorseparator
		p_{4} :: \ldots
	}
	{
		\simplifiedstate
			{\ldots}
			{
				& \simplifiedstateobjectsentry
					{p_{1}}
					{
						\simplifiedstatereferencedobject{r_{0}}{o_{0}(\simplifiedstateentityvalue{market}{r_{1}})}, \simplifiedstatereferencedobject{r_{39}}{o_{48}(1)}
					} \\
				& \simplifiedstateobjectsentry
					{p_{2}}
					{
						& \simplifiedstatereferencedobject{r_{1}}{o_{35}(\simplifiedstateentityvalue{cash}{r_{16}}, \simplifiedstateentityvalue{available\_shares}{r_{23}}, \simplifiedstateentityvalue{owned\_shares}{r_{29}})}, \\
						& \simplifiedstatereferencedobject{r_{16}}{o_{71}[r_{61}, r_{22}]}, \simplifiedstatereferencedobject{r_{61}}{o_{70}(90)}, \simplifiedstatereferencedobject{r_{22}}{o_{24}(100)}, \\
						& \simplifiedstatereferencedobject{r_{23}}{o_{73}[r_{62}]}, \simplifiedstatereferencedobject{r_{62}}{o_{72}(0)}, \\
						& \simplifiedstatereferencedobject{r_{29}}{o_{75}[[r_{63}], [r_{35}]]}, \simplifiedstatereferencedobject{r_{63}}{o_{74}(1)}, \simplifiedstatereferencedobject{r_{35}}{o_{42}(0)}, \\
						& \simplifiedstatereferencedobject{r_{65}}{o_{77}}
					} \\
				& \simplifiedstateobjectsentry
					{p_{3}}
					{
						\simplifiedstatereferencedobject{r_{6}}{o_{78}(\simplifiedstateentityvalue{id}{r_{36}}, \simplifiedstateentityvalue{log}{r_{65}})},
						\simplifiedstatereferencedobject{r_{36}}{o_{43}(1)},
						\simplifiedstatereferencedobject{r_{40}}{o_{49}(1)},
						\simplifiedstatereferencedobject{r_{58}}{o_{67}(true)}
					} \\
				& \simplifiedstateobjectsentry
					{p_{4}}
					{
						\simplifiedstatereferencedobject{r_{8}}{o_{46}(\simplifiedstateentityvalue{id}{r_{37}})},
						\simplifiedstatereferencedobject{r_{37}}{o_{45}(2)},
						\simplifiedstatereferencedobject{r_{41}}{o_{50}(1)}
					}
			}
			{
				& \simplifiedstateoncestatusentry
					{\simplifiedstateallprocessorsindicator}
					{
						\simplifiedstateoncefunctionstatus{MARKET}{id}{r_{65}}
					}
			}
			{\ldots}
	}

The postcondition of $buy$ contains the expression $current.id$ with target $current$. The handler of the controlling entity is $p_{3}$. Because $p_{3}$ did not obtain its own request queue lock, it must evaluate the postcondition synchronously. After the postcondition evaluation, $p_{3}$ issues the $\unlockrequestqueueoperation$ operation to $p_{2}$ and removes $p_{2}$'s request queue lock. This enables $p_{2}$ to unlock its request queue lock. Processor $p_{3}$ then executes the $\returnoperation$ operation to get rid of its top environment and its retrieved locks:

\isolatedconfiguration
	{
		p_{1} :: \ & \ldots \processorseparator
		p_{2} :: \processorseparator 
		p_{3} :: \applyoperation(a_{70}, r_{6}, sell, \tuple{r_{1}, r_{39}}, p_{1}, \tuple{\set{}, \set{}}) \processorseparator
		p_{4} :: \ldots
	}
	{
		\simplifiedstate
			{
				& \simplifiedstatelocksentry
					{p_{1}}
					{\set{}, \set{p_{3}, p_{4}}}
					{\set{}, \set{}}
					{\set{}, \set{}}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator} \\
				& \simplifiedstatelocksentry
					{p_{2}}
					{}
					{}
					{}
					{\simplifiedstateunlockedindicator}
					{\simplifiedstatenopassedlocksindicator} \\
				& \simplifiedstatelocksentry
					{p_{3}}
					{}
					{}
					{}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator} \\
				& \simplifiedstatelocksentry
					{p_{4}}
					{}
					{\set{}}
					{\set{}}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator}
			}
			{\ldots}
			{\ldots}
			{
				& \simplifiedstateenvironmentsentry
					{p_{1}}
					{
						& \simplifiedstateentityvalue{first\_investor}{r_{6}}, \simplifiedstateentityvalue{second\_investor}{r_{8}}, \simplifiedstatecurrententityvalue{r_{0}} \simplifiedstateenvironmentsentryseparator \\
						& \simplifiedstateentityvalue{first\_investor}{r_{6}}, \simplifiedstateentityvalue{second\_investor}{r_{8}}, \simplifiedstateentityvalue{issuer\_id}{r_{39}}, \simplifiedstatecurrententityvalue{r_{0}}
					} \\
				& \simplifiedstateenvironmentsentry
					{p_{2}}
					{} \\
				& \simplifiedstateenvironmentsentry
					{p_{3}}
					{} \\
				& \simplifiedstateenvironmentsentry
					{p_{4}}
					{
						& \simplifiedstateentityvalue{market}{r_{1}}, \simplifiedstateentityvalue{issuer\_id}{r_{41}}, \simplifiedstatecurrententityvalue{r_{8}}
					}
			}
	}
\end{example}
\end{fortechnicalreport}

\subsubsection{Creation instructions}
A creation instruction has the form $\ecreate b.f(e_{1}, \ldots, e_{n})$ where $b$ is the target entity, $f$ is the creation procedure, and $e_{1}, \ldots, e_{n}$ are the actual arguments. Assume that $b$ is of type $(d, g, c)$. A processor $p$ that executes this instruction takes the following steps:
\begin{enumerate}
	\item Processor $q$ creation.
		\begin{itemize}
			\item If $b$ is separate, i.e., $g = \top$, then create a new processor.
			\item If $b$ has an explicit processor specification, i.e., $g = \alpha$, then
				\begin{itemize}
					\item take the processor denoted by $\alpha$ if it already exists.
					\item create a new processor if the processor denoted by $\alpha$ does not exist yet.
				\end{itemize}
			\item If $b$ is non-separate, i.e., $g = \bullet$, then take $p$.
		\end{itemize}
	\item Locking. Lock the request queue of $q$ if the following conditions hold:
		\begin{itemize}
			\item Processor $p$ and processor $q$ are different.
			\item Processor $p$ does not have $q$'s request queue lock.
			\item Processor $q$ does not have $p$'s request queue lock.
		\end{itemize}
	\item Object creation. Ask $q$ to create a new instance with class type $c$ using the creation procedure $f$. Attach the newly created object to $b$.
	\item Invariant evaluation. If $f$ is not exported, then ask $q$ to evaluate the invariant.
	\item Lock releasing. If $q$'s request queue has been locked in the locking step, then ask $q$ to unlock its request queue after it is done with the feature request.
\end{enumerate}
There are four cases in the processor creation step:
\begin{itemize}
	\item The entity $b$ has a separate type.
	\item The entity $b$ has an explicit processor specification and the denoted processor already exists.
	\item The entity $b$ has an explicit processor specification and the denoted processor does not yet exist.
	\item The entity $b$ has a non-separate type.
\end{itemize}
For each of these cases, there is one inference rule. The discussion starts with the variant where $b$ has a separate type. In this case, the instruction defines $q$ as a new processor and $o$ as a new object of class type $c$. The reference $r$ points to this object. First the instruction obtains a request queue lock on the new processor $q$ so that it can issue statements on $q$. Next, it writes the value $r$ into the entity $b$. To make a call to the creation procedure, it executes a command instruction. Once this is done, it checks whether there is an invariant to evaluate. If $f$ is exported, then the invariant will be evaluated as part of $f$'s feature application. In this case the instruction does nothing. However, if $f$ is not exported, then it must issue the invariant evaluation to $q$. After this step, it can issue an $\unlockrequestqueueoperation$ operation to $q$ and remove the request queue lock from $p$'s obtained request queue locks.

\inferencerule
	{Create Instruction -- Top}
	{
		(d, h, c) \mathematicaldefinition \typefromtypingenvironment(\typingenvironment, b) \\
		h = \top \\
		q \mathematicaldefinition \state.\newprocessorfeature \\
		o \mathematicaldefinition \state.\newobjectfeature(c) \\
		\state' \mathematicaldefinition \state.\addprocessorfeature(q).\addobjectfeature(q, o) \\
		r \mathematicaldefinition \state'.\referencefeature(o) \\
		\freshchanneldefinition{a}
	}
	{\configuration{p :: \ecreate b.f(e_{1}, \ldots, e_{n}) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ & \lockrequestqueuesoperation(\set{q}) \statementseparator \\
				& \writevalueoperation(b.\namefeature, r) \statementseparator \\
				& b.f(e_{1}, \ldots, e_{n}) \statementseparator \\
				\multilineconditionaloperation
					{\neg f.\classtypefeature.\invariantexistsfeature \vee f.\isexportedfeature}
					{\nooperation}
					{\issueoperation(q, \evaluateoperation(a, f.\classtypefeature.\invariantfeature) \statementseparator \waitoperation(a))} \statementseparator \\
				& \issueoperation(q, \unlockrequestqueueoperation) \statementseparator \\
				& \popobtainedrequestqueuelocksoperation \statementseparator \\
				& s_{p} \processorseparator q :: \nooperation
			}
			{\state'}
	}
 
The following discussion looks at the two variants for the cases where $b$ has an explicit processor specification. There are two forms of explicit processor specifications: unqualified and qualified. An unqualified explicit processor specification, i.e., $<x>$, is based on a processor attribute $x$ with an attached type. The processor denoted by this explicit processor specification is the processor stored in $x$. A qualified explicit processor specification, i.e., $<y.\handlerfeature>$, is based on a non-writable entity $y$ of attached type. The processor denoted by this explicit processor specification is the same processor as the one handling the object referenced by $y$. A qualified explicit processor specification always denotes an existing processor because this specification is based on an attached entity. This means that there is already an object attached to this entity and thus its handler must exist. This insight helps to write the conditions for the two inference rule variants.

\begin{forjournal}
\inferencerule
	{Create Instruction -- Existing Explicit Processor}
	{
		(d, h, c) \mathematicaldefinition \typefromtypingenvironment(\typingenvironment, b) \\
		h = <x> \vee h = <y.\handlerfeature> \\
		q \mathematicaldefinition 
			\left\{
				\begin{array}{ll}
					\state.\valuefeature(p, x) & \condition{t = (d, <x>, c)} \\
					\state.\handlerfeature(\state.\valuefeature(p, y)) & \condition{t = (d, <y.\handlerfeature>, c)}
				\end{array}
			\right. \\
		\state.\processorsfeature.\containsfeature(q) \\
		\overline{g}_{required\_cs\_locks} \mathematicaldefinition 
			\left\{
				\begin{array}{ll}
					\set{q} & \condition{q \neq p \wedge (\state.\requestqueuelocksfeature(q).\containsfeature(p) \vee \state.\callstacklocksfeature(q).\containsfeature(p))} \\
					\set{} & \otherwisecondition
				\end{array}
			\right. \\
		\forall x \in \overline{g}_{required\_cs\_locks} \colon \neg \state.\arelockspassedfeature(p) \wedge \state.\callstacklocksfeature(p).\containsfeature(x) \\
		o \mathematicaldefinition  \state.\newobjectfeature(c) \\
		\state' \mathematicaldefinition \state.\addobjectfeature(q, o) \\
		r \mathematicaldefinition  \state'.\referencefeature(o) \\
		\freshchanneldefinition{a}
	}
	{\configuration{p :: \ecreate b.f(e_{1}, \ldots, e_{n}) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ \multilineconditionaloperation
					{q \neq p \wedge \neg \state'.\requestqueuelocksfeature(p).\containsfeature(q) \wedge \neg \state'.\requestqueuelocksfeature(q).\containsfeature(p)}
					{\lockrequestqueuesoperation(\set{q})}
					{\nooperation} \statementseparator \\
				& \writevalueoperation(b.\namefeature, r) \statementseparator \\
				& b.f(e_{1}, \ldots, e_{n}) \statementseparator \\
				\multilineconditionaloperation
					{\neg f.\classtypefeature.\invariantexistsfeature \vee f.\isexportedfeature}
					{\nooperation}
					{\issueoperation(q, \evaluateoperation(a, f.\classtypefeature.\invariantfeature) \statementseparator \waitoperation(a))} \statementseparator \\
				\multilineconditionaloperation
					{q \neq p \wedge \neg \state'.\requestqueuelocksfeature(p).\containsfeature(q) \wedge \neg \state'.\requestqueuelocksfeature(q).\containsfeature(p)}
					{
						\begin{split}
							& \issueoperation(q, \unlockrequestqueueoperation) \statementseparator \\
							& \popobtainedrequestqueuelocksoperation 
						\end{split}
					}
					{\nooperation} \statementseparator \\
				& s_{p}
			}
			{\state'}
	}
 \end{forjournal}

The variant that handles existing processors states that the specified processor must exist. To check this, one must consider both the qualified and the unqualified possibility. For the qualified option, one can simply lookup the value of the attribute $x$. For the unqualified option, one first looks up the value of the entity $y$ and then determines the handler of the referenced object. In either case, the result $q$ is either the denoted processor or the void value. One then checks whether $q$ is in the set of processors of our system. The overall idea of this inference rule is the same as in the case where $b$ has a separate type. The difference is in the processor creation, locking, and lock releasing steps. Instead of creating a new processor, the instruction takes the existing processor $q$. If $q = p$, then the call to the creation procedure will be a non-separate call. In this case, the instruction requires $p$'s call stack lock. This lock is given because otherwise $p$ would be waiting. If $p \neq q$ and $q$ has a lock on $p$, then the call to the creation procedure will be a separate callback. In this case, the instruction requires $q$'s call stack lock. This is expressed in the condition with the help of the set $\overline{g}_{required\_cs\_locks}$. If $p \neq q$ and $q$ does not have $p$'s request queue lock, then the call to the creation procedure will be a separate call. In this case, the instruction must obtain $q$'s request queue lock, provided it does not already have this lock. Only when it obtained $q$'s request queue lock, does the instruction have to issue an $\unlockrequestqueueoperation$ operation and remove $q$ from $p$'s stack of obtained request queue locks.

\begin{forjournal}
\inferencerule
	{Create Instruction -- Non-Existing Explicit Processor}
	{
		(d, h, c) \mathematicaldefinition \typefromtypingenvironment(\typingenvironment, b) \\
		h = <x> \\
		\neg \state.\processorsfeature.\containsfeature(\state.\valuefeature(p, x)) \\
		q \mathematicaldefinition \state.\newprocessorfeature \\
		o \mathematicaldefinition \state.\newobjectfeature(c) \\
		\state' \mathematicaldefinition \state.\addprocessorfeature(q).\addobjectfeature(q, o) \\
		r \mathematicaldefinition \state'.\referencefeature(o) \\
		\freshchanneldefinition{a}
	}
	{\configuration{p :: \ecreate b.f(e_{1}, \ldots, e_{n}) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ & \writevalueoperation(x.\namefeature, q) \statementseparator \\
				& \lockrequestqueuesoperation(\set{q}) \statementseparator \\
				& \writevalueoperation(b.\namefeature, r) \statementseparator \\
				& b.f(e_{1}, \ldots, e_{n}) \statementseparator \\
				\multilineconditionaloperation
					{\neg f.\classtypefeature.\invariantexistsfeature \vee f.\isexportedfeature}
					{\nooperation}
					{\issueoperation(q, \evaluateoperation(a, f.\classtypefeature.\invariantfeature) \statementseparator \waitoperation(a))} \statementseparator \\
				& \issueoperation(q, \unlockrequestqueueoperation) \statementseparator \\
				& \popobtainedrequestqueuelocksoperation  \statementseparator \\
				& s_{p} \processorseparator q :: \nooperation
			}
			{\state'}
	}
 \end{forjournal}

For the variant that handles non-existing processors, one has to verify that the specified processor does not exist. To do so, one considers only unqualified processor specifications. In this case, the instruction creates a new processor $q$ with a new object $o$ and reference $r$. The steps in this variant are similar to those in the variant where $b$ has a separate type. However, the instruction has to set the value of the processor attribute $x$ to the newly created processor. This ensures that the denoted processor will be found to exist in the future.

\begin{fortechnicalreport}
\inferencerule
	{Create Instruction -- Existing Explicit Processor}
	{
		(d, h, c) \mathematicaldefinition \typefromtypingenvironment(\typingenvironment, b) \\
		h = <x> \vee h = <y.\handlerfeature> \\
		q \mathematicaldefinition 
			\left\{
				\begin{array}{ll}
					\state.\valuefeature(p, x) & \condition{t = (d, <x>, c)} \\
					\state.\handlerfeature(\state.\valuefeature(p, y)) & \condition{t = (d, <y.\handlerfeature>, c)}
				\end{array}
			\right. \\
		\state.\processorsfeature.\containsfeature(q) \\
		\overline{g}_{required\_cs\_locks} \mathematicaldefinition 
			\left\{
				\begin{array}{ll}
					\set{q} & \condition{q \neq p \wedge (\state.\requestqueuelocksfeature(q).\containsfeature(p) \vee \state.\callstacklocksfeature(q).\containsfeature(p))} \\
					\set{} & \otherwisecondition
				\end{array}
			\right. \\
		\forall x \in \overline{g}_{required\_cs\_locks} \colon \neg \state.\arelockspassedfeature(p) \wedge \state.\callstacklocksfeature(p).\containsfeature(x) \\
		o \mathematicaldefinition  \state.\newobjectfeature(c) \\
		\state' \mathematicaldefinition \state.\addobjectfeature(q, o) \\
		r \mathematicaldefinition  \state'.\referencefeature(o) \\
		\freshchanneldefinition{a}
	}
	{\configuration{p :: \ecreate b.f(e_{1}, \ldots, e_{n}) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ \multilineconditionaloperation
					{q \neq p \wedge \neg \state'.\requestqueuelocksfeature(p).\containsfeature(q) \wedge \neg \state'.\requestqueuelocksfeature(q).\containsfeature(p)}
					{\lockrequestqueuesoperation(\set{q})}
					{\nooperation} \statementseparator \\
				& \writevalueoperation(b.\namefeature, r) \statementseparator \\
				& b.f(e_{1}, \ldots, e_{n}) \statementseparator \\
				\multilineconditionaloperation
					{\neg f.\classtypefeature.\invariantexistsfeature \vee f.\isexportedfeature}
					{\nooperation}
					{\issueoperation(q, \evaluateoperation(a, f.\classtypefeature.\invariantfeature) \statementseparator \waitoperation(a))} \statementseparator \\
				\multilineconditionaloperation
					{q \neq p \wedge \neg \state'.\requestqueuelocksfeature(p).\containsfeature(q) \wedge \neg \state'.\requestqueuelocksfeature(q).\containsfeature(p)}
					{
						\begin{split}
							& \issueoperation(q, \unlockrequestqueueoperation) \statementseparator \\
							& \popobtainedrequestqueuelocksoperation 
						\end{split}
					}
					{\nooperation} \statementseparator \\
				& s_{p}
			}
			{\state'}
	}
 \inferencerule
	{Create Instruction -- Non-Existing Explicit Processor}
	{
		(d, h, c) \mathematicaldefinition \typefromtypingenvironment(\typingenvironment, b) \\
		h = <x> \\
		\neg \state.\processorsfeature.\containsfeature(\state.\valuefeature(p, x)) \\
		q \mathematicaldefinition \state.\newprocessorfeature \\
		o \mathematicaldefinition \state.\newobjectfeature(c) \\
		\state' \mathematicaldefinition \state.\addprocessorfeature(q).\addobjectfeature(q, o) \\
		r \mathematicaldefinition \state'.\referencefeature(o) \\
		\freshchanneldefinition{a}
	}
	{\configuration{p :: \ecreate b.f(e_{1}, \ldots, e_{n}) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ & \writevalueoperation(x.\namefeature, q) \statementseparator \\
				& \lockrequestqueuesoperation(\set{q}) \statementseparator \\
				& \writevalueoperation(b.\namefeature, r) \statementseparator \\
				& b.f(e_{1}, \ldots, e_{n}) \statementseparator \\
				\multilineconditionaloperation
					{\neg f.\classtypefeature.\invariantexistsfeature \vee f.\isexportedfeature}
					{\nooperation}
					{\issueoperation(q, \evaluateoperation(a, f.\classtypefeature.\invariantfeature) \statementseparator \waitoperation(a))} \statementseparator \\
				& \issueoperation(q, \unlockrequestqueueoperation) \statementseparator \\
				& \popobtainedrequestqueuelocksoperation  \statementseparator \\
				& s_{p} \processorseparator q :: \nooperation
			}
			{\state'}
	}
 \end{fortechnicalreport}

Lastly, there is a variant for the case where $b$ has a non-separate type. In this case, the instruction creates the object on $p$. Processor creation, locking, and lock releasing is not necessary. The required call stack lock on $p$ is given because otherwise $p$ would be waiting.

\inferencerule
	{Create Instruction -- Non-Separate}
	{
		(d, h, c) \mathematicaldefinition \typefromtypingenvironment(\typingenvironment, b) \\
		h = \bullet \\
		o \mathematicaldefinition \state.\newobjectfeature(c) \\
		\state' \mathematicaldefinition \state.\addobjectfeature(p, o) \\
		r \mathematicaldefinition \state'.\referencefeature(o) \\
		\freshchanneldefinition{a}
	}
	{\configuration{p :: \ecreate b.f(e_{1}, \ldots, e_{n}) \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ & \writevalueoperation(b.\namefeature, r) \statementseparator \\
				& b.f(e_{1}, \ldots, e_{n}) \statementseparator \\
				\multilineconditionaloperation
						{\neg f.\classtypefeature.\invariantexistsfeature \vee f.\isexportedfeature}
						{\nooperation}
						{\evaluateoperation(a, f.\classtypefeature.\invariantfeature) \statementseparator \waitoperation(a)} \statementseparator \\
				& s_{p}
			}
			{\state'}
	}
 
\begin{fortechnicalreport}
\begin{example}[Object creation]
To illustrate object creation, consider a configuration where the root processor $p_{1}$ is executing the root procedure $make$ on the root object $o_{0}$. This procedure is shown in \listingreference{lst:application class with initialization}.

\begin{lstlisting}[caption=Application class with initialization, label=lst:application class with initialization, language=SCOOP]
class APPLICATION

create
  make

feature -- Initialization
  make
      -- Create a market with investors and issuers. Then do some transactions.
    local
      first_investor: separate INVESTOR
      second_investor: separate INVESTOR
    do
      -- Create the market with two investors and one issuer. Each investor has 100 units of cash. The issuer has one share.
      create market.make (2, 100, 1, 1)
      create first_investor.make (1)
      create second_investor.make (2)
			
      -- Do a transaction.
      Current.do_transaction (first_investor, second_investor, 1)
    end

feature {APPLICATION} -- Implementation
  market: separate MARKET
      -- The market.
	
  do_transaction
    ...	
end
\end{lstlisting}

The following configuration is our starting point:

\isolatedconfiguration
	{
		p_{1} :: \ & \ecreate market.make(2, 100, 1, 1) \statementseparator \\
		& \ldots
	}
	{
		\simplifiedstate
			{
				& \simplifiedstatelocksentry
					{p_{1}}
					{\set{}}
					{\set{}}
					{\set{}}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator}
			}
			{
				& \simplifiedstateobjectsentry
					{p_{1}}
					{
						\simplifiedstatereferencedobject{r_{0}}{o_{0}(\simplifiedstateentityvalue{market}{\voidvalue})}
					}
			}
			{}
			{
				& \simplifiedstateenvironmentsentry
					{p_{1}}
					{
						& \simplifiedstateentityvalue{first\_investor}{\voidvalue}, \simplifiedstateentityvalue{second\_investor}{\voidvalue}, \simplifiedstatecurrententityvalue{r_{0}}
					}
			}
	}

Processor $p_{1}$ starts executing the creation instruction. The result is a new configuration, where $o_{1}$ is the new market object handled by a new processor $p_{2}$:

\isolatedconfiguration
	{
		p_{1} :: \ & \lockrequestqueuesoperation(\set{p_{2}}) \statementseparator \\
		& \writevalueoperation(market.\namefeature, r_{1}) \statementseparator \\
		& market.make(2, 100, 1, 1) \statementseparator \\
		& \issueoperation(p_{2}, \unlockrequestqueueoperation) \statementseparator \\
		& \popobtainedrequestqueuelocksoperation \statementseparator \\
		& \ldots \processorseparator p_{2} :: \nooperation
	}
	{
		\simplifiedstate
			{
				& \simplifiedstatelocksentry
					{p_{1}}
					{\set{}}
					{\set{}}
					{\set{}}
					{\simplifiedstatelockedindicator}
					{\simplifiedstatenopassedlocksindicator} \\
				& \simplifiedstatelocksentry
					{p_{2}}
					{}
					{}
					{}
					{\simplifiedstateunlockedindicator}
					{\simplifiedstatenopassedlocksindicator}
			}
			{
				& \simplifiedstateobjectsentry
					{p_{1}}
					{
						\simplifiedstatereferencedobject{r_{0}}{o_{0}(\simplifiedstateentityvalue{market}{\voidvalue})}
					} \\
				& \simplifiedstateobjectsentry
					{p_{2}}
					{
						\simplifiedstatereferencedobject{r_{1}}{o_{1}}
					}
			}
			{}
			{
				& \simplifiedstateenvironmentsentry
					{p_{1}}
					{
						& \simplifiedstateentityvalue{first\_investor}{\voidvalue}, \simplifiedstateentityvalue{second\_investor}{\voidvalue}, \simplifiedstatecurrententityvalue{r_{0}}
					} \\
				& \simplifiedstateenvironmentsentry
					{p_{2}}
					{}
			}
	}

Now processor $p_{1}$ locks the request queue of processor $p_{2}$. It then stores the reference $r_{1}$ into the entity $market$. With these two steps, processor $p_{1}$ set up the context to execute a feature call to the creation procedure $make$. The resulting feature request will be executed by processor $p_{2}$. Processor $p_{1}$ then asks processor $p_{2}$ to unlock its request queue after it is done with the feature request. Then processor $p_{1}$ removes the obtained request queue lock from its stack.
\end{example}
\end{fortechnicalreport}

\subsubsection{Flow control instructions}
The $\eif{e}{s_{t}}{s_{f}}$ instruction executes $s_{t}$ if the expression $e$ evaluates to true. Otherwise the instruction executes $s_{f}$. There is one inference rule for this instruction. In a first step, the instruction evaluates the expression $e$ using a fresh channel $a$ and then waits for a notification on $a$. In a second step, it uses the $\conditionaloperationname$ operation to either execute $s_{t}$ or $s_{f}$, depending on the value of the expression.

\inferencerule
	{If Instruction}
	{\freshchanneldefinition{a}}
	{\configuration{p :: \eif{e}{s_{t}}{s_{f}} \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ & \evaluateoperation(a, e) \statementseparator \\
				& \waitoperation(a) \statementseparator \\
				\multilineconditionaloperation
					{a.\datafeature}
					{s_{t}}
					{s_{f}} \statementseparator \\
				& s_{p}
			}
			{\state}
	}
 
The $\euntil{e}{s_{l}}$ instruction executes a sequence of $s_{l}$ instructions until the expression $e$ evaluates to true. If $e$ is true initially, then $s_{l}$ never gets executed. There is one inference rule for this instruction. First, the instruction evaluates $e$ using a fresh channel $a$. Then it waits for a notification on $a$. Next, it uses the $\conditionaloperationname$ operation to check whether $e$ evaluates to true or false. If $e$ is true, then it is done. Otherwise, it executes $s_{l}$ followed by another $\euntil{e}{s_{t}}$ operation.

\inferencerule
	{Loop Instruction}
	{\freshchanneldefinition{a}}
	{\configuration{p :: \euntil{e}{s_{l}} \statementseparator s_{p}}{\state}}
	{
		\configuration
			{
				p :: \ & \evaluateoperation(a, e) \statementseparator \\
				& \waitoperation(a) \statementseparator \\
				\multilineconditionaloperation
					{a.\datafeature}
					{\nooperation}
					{s_{l} \statementseparator \euntil{e}{s_{l}}} \statementseparator \\
				& s_{p}
			}
			{\state}
	}
 
\subsubsection{Assignment instructions}
An assignment instruction $b \eassignment e$ assigns the value of the expression $e$ to the entity $b$. The instruction first evaluates the expression $e$ and then waits for a notification on a fresh channel $a$. Once it gets this notification, it uses the $\writevalueoperation$ operation to set the value to the entity $b$.

\singlelineinferencerule
	{Assignment}
	{\freshchanneldefinition{a}}
	{\configuration{p :: b \eassignment e; s_{p}}{\state}}
	{
		\configuration
			{p :: \evaluateoperation(a, e) \statementseparator \waitoperation(a) \statementseparator \writevalueoperation(b.\namefeature, a.\datafeature) \statementseparator s_{p}}
			{\state}
	}
 
\subsection{Termination}
The system terminates when it reaches a configuration where all action queues are empty, i.e., when there is no more work to do.
