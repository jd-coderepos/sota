\documentclass[submission,copyright,creativecommons]{eptcs}
\providecommand{\event}{UITP 2014} 



\usepackage{graphicx}

\usepackage{amsmath, amsthm, color}
\definecolor{light-gray}{gray}{0.75}
\newcommand{\ncbox}[1]{\fcolorbox{light-gray}{light-gray}{#1}} 	
\newcommand{\desc}[1]{\small{~~\ncbox{#1}}}

\usepackage{wrapfig}
\usepackage{tikzfig}
\tikzstyle{dotpic}=[scale=0.6]
\tikzstyle{diredges}=[every to/.style={diredge}]
\tikzstyle{dot graph}=[shorten <=-0.1mm,shorten >=-0.1mm,scale=0.6]
\tikzstyle{digraph}=[-latex]
\tikzstyle{plot point}=[circle,fill=black,minimum width=2mm,inner sep=0]
\tikzstyle{string graph}=[]
\tikzstyle{every picture}=[string graph,baseline=-0.25em,scale=0.6]
\tikzstyle{sg diredge}=[-stealth]
\tikzstyle{rewrite edge}=[-open triangle 45]
\tikzstyle{sg bold diredge}=[-stealth,thick,shorten >=-1pt]
\tikzstyle{sg vertex}=[circle,minimum width=2.2mm,fill=white,draw=black,inner sep=0mm]
\tikzstyle{labelled sg vertex}=[circle,minimum width=7mm,fill=white,draw=black,inner sep=0mm]
\tikzstyle{small sg vertex}=[circle,minimum width=4mm,fill=white,draw=black,inner sep=0mm, font=\footnotesize]
\tikzstyle{sg grey vertex}=[sg vertex,fill=gray!30!white]
\tikzstyle{sg white vertex}=[sg vertex,fill=white]
\tikzstyle{sg black vertex}=[sg vertex,fill=black]
\tikzstyle{sg bold vertex}=[circle,minimum width=2.2mm,fill=white,draw=black,very thick,inner sep=0mm]
\tikzstyle{sg wire vertex}=[circle,minimum width=1mm,fill=black,inner sep=0mm]
\tikzstyle{cloud vertex}=[fill=white, draw=black, inner sep=2 mm, shape=cloud, aspect=1.5]
\tikzstyle{tick vertex}=[rectangle,fill=black,minimum height=1mm,minimum width=2.5mm,inner sep=0mm]

\newcommand{\phantombox}[1]{\tikz[baseline=(current bounding box).east]{\path [use as bounding box] (0,0) rectangle #1;}}
\tikzstyle{braceedge}=[decorate,decoration={brace,amplitude=2mm,raise=-1mm}]
\tikzstyle{small braceedge}=[decorate,decoration={brace,amplitude=1mm,raise=-1mm}]
\tikzstyle{left hook arrow}=[left hook-latex]
\tikzstyle{right hook arrow}=[right hook-latex]

\newcommand{\measurement}{\tikz[scale=0.6]{ \draw [use as bounding box,draw=none] (0,-0.1) rectangle (1,0.7); \draw [fill=white] (1,0) arc (0:180:5mm); \draw (0,0) -- (1,0) (0.5,0) -- +(60:7mm);}}

\tikzstyle{bbox edge}=[draw=blue]
\tikzstyle{bbox include}=[->,draw=blue]
\tikzstyle{bbox corner}=[inner sep=0pt,rectangle,fill=blue,draw=blue,minimum width=1.5mm,minimum height=1.5mm]

\tikzstyle{west wire label}=[font=\footnotesize\it,anchor=west,inner sep=1pt,xshift=-3pt]
\tikzstyle{east wire label}=[font=\footnotesize\it,anchor=east,inner sep=1pt,xshift=3pt]


\tikzstyle{dot}=[inner sep=0.7mm,minimum width=0pt,minimum height=0pt,fill=black,draw=black,shape=circle]
\tikzstyle{white dot}=[dot,fill=white]
\tikzstyle{alt white dot}=[white dot,label={[xshift=2.9mm,yshift=-0.1mm]left:}]
\tikzstyle{gray dot}=[dot,fill=gray!50]
\tikzstyle{box vertex}=[draw=black,rectangle]
\tikzstyle{whitebg}=[fill=white,inner sep=2pt]
\tikzstyle{graph state vertex}=[sg vertex,fill=black]



\tikzstyle{square box}=[rectangle,fill=white,draw=black,minimum height=6mm,minimum width=6mm]
\tikzstyle{small square box}=[rectangle,fill=white,draw=black,minimum height=0mm,minimum width=8mm,inner sep=3pt]
\tikzstyle{square gray box}=[rectangle,fill=gray!30,draw=black,minimum height=6mm,minimum width=6mm]
\tikzstyle{point}=[regular polygon,regular polygon sides=3,draw=black,scale=0.75,inner sep=-0.5pt,minimum width=7mm,fill=white]
\tikzstyle{copoint}=[point,regular polygon rotate=180,fill=white]
\tikzstyle{gray point}=[point,fill=gray!40!white]
\tikzstyle{gray copoint}=[copoint,fill=gray!40!white]


\tikzstyle{open graph}=[baseline=-0.25em]
\tikzstyle{greybg}=[background rectangle/.style={fill=black!5,draw=black!30,rounded corners=1ex}, show background rectangle]

\tikzstyle{edge point}=[circle,minimum width=1mm,fill=black,inner sep=0mm]
\tikzstyle{vertex point}=[circle,minimum width=2.2mm,fill=white,draw=black,inner sep=0mm]
\tikzstyle{gray vertex point}=[circle,minimum width=2.2mm,fill=gray!30!white,draw=black,inner sep=0mm]
\tikzstyle{edge label}=[inner sep=2pt, font=\small]
\tikzstyle{on edge label}=[fill=white, font=\footnotesize, inner sep=1 pt]

\newcommand{\edgearrow}{{\arrow[black]{>}}}
\newcommand{\edgetick}{{\arrow[black,scale=0.7,very thick]{|}}}
\tikzstyle{diredge}=[->]
\tikzstyle{gray edge}=[gray!50!white]
\tikzstyle{medium diredge}=[->]
\tikzstyle{short diredge}=[->]
\tikzstyle{halfedge}=[-)]
\tikzstyle{other halfedge}=[(-]
\tikzstyle{freeedge}=[(-)]
\tikzstyle{white edge}=[line width=5pt,white]
\tikzstyle{tick}=[postaction=decorate,decoration={markings, mark=at position 0.5 with \edgetick}]
\tikzstyle{small map edge}=[|-latex, gray!60!blue, shorten <=0.9mm, shorten >=0.5mm]
\tikzstyle{thick dashed edge}=[very thick,dashed,gray!40]
\tikzstyle{map edge}=[|-latex,very thick, gray!40, shorten <=1mm, shorten >=0.5mm]
\tikzstyle{tickedge}=[postaction=decorate,
  decoration={markings, mark=at position 0.5 with \edgetick}]
\tikzstyle{dirtickedge}=[postaction=decorate,
  decoration={markings, mark=at position 0.5 with \edgetick},
  decoration={markings, mark=at position 0.85 with \edgearrow}]
\tikzstyle{dirdoubletickedge}=[postaction=decorate,
  decoration={markings, mark=at position 0.4 with \edgetick},
  decoration={markings, mark=at position 0.6 with \edgetick},
  decoration={markings, mark=at position 0.85 with \edgearrow}]


\tikzstyle{arrs}=[-latex,font=\small,auto]
\tikzstyle{arrow plain}=[arrs]
\tikzstyle{arrow dashed}=[dashed,arrs]
\tikzstyle{arrow bold}=[very thick,arrs]
\tikzstyle{arrow hide}=[draw=white!0,-]
\tikzstyle{arrow reverse}=[latex-]
\tikzstyle{cdnode}=[]





\tikzstyle{cnot}=[fill=white,shape=circle,inner sep=-1.4pt]
\tikzstyle{bang box}=[draw=black,dashed,minimum height=12mm,minimum width=12mm,fill=gray!20]
\tikzstyle{wire label}=[font=\footnotesize, auto]

\newcommand{\emptybox}[2]{\tikz{\node[rectangle,inner sep=0,minimum width=#1,minimum height=#2] {};}}

 \newcommand{\TODOitem}{{\color{blue}\item {\small \bf TODO:}\ }}

\newcommand{\ttac}[1]{\textbf{#1}}
\newcommand{\twire}[1]{\textbf{#1}}


\newcommand{\catC}{\ensuremath{\mathcal{C}}\xspace}
\newcommand{\catCop}{\ensuremath{\mathcal{C}^{\mathrm{op}}}\xspace}
\newcommand{\catD}{\ensuremath{\mathcal{D}}\xspace}
\newcommand{\catDop}{\ensuremath{\mathcal{D}^{\mathrm{op}}}\xspace}


\newcommand{\catSet}{\ensuremath{\textrm{\bf Set}}\xspace}
\newcommand{\catRel}{\ensuremath{\textrm{\bf Rel}}\xspace}
\newcommand{\catFRel}{\ensuremath{\textrm{\bf FRel}}\xspace}
\newcommand{\catVect}{\ensuremath{\textrm{\bf Vect}}\xspace}
\newcommand{\catFVect}{\ensuremath{\textrm{\bf FVect}}\xspace}
\newcommand{\catFHilb}{\ensuremath{\textrm{\bf FHilb}}\xspace}
\newcommand{\catHilb}{\ensuremath{\textrm{\bf Hilb}}\xspace}
\newcommand{\catSuperHilb}{\ensuremath{\textrm{\bf SuperHilb}}\xspace}
\newcommand{\catAb}{\ensuremath{\textrm{\bf Ab}}\xspace}
\newcommand{\catTop}{\ensuremath{\textrm{\bf Top}}\xspace}
\newcommand{\catCHaus}{\ensuremath{\textrm{\bf CHaus}}\xspace}
\newcommand{\catHaus}{\ensuremath{\textrm{\bf Haus}}\xspace}
\newcommand{\catGraph}{\ensuremath{\textrm{\bf Graph}}\xspace}
\newcommand{\catMat}{\ensuremath{\textrm{\bf Mat}}\xspace}
\newcommand{\catGr}{\ensuremath{\textrm{\bf Gr}}\xspace}
\newcommand{\catSpek}{\ensuremath{\textrm{\bf Spek}}\xspace}


\newcommand{\catMonCat}{\ensuremath{\textrm{\bf MonCat}}\xspace}
\newcommand{\catSymMonCat}{\ensuremath{\textrm{\bf SymMonCat}}\xspace}
\newcommand{\catSymTraceCat}{\ensuremath{\textrm{\bf SymTraceCat}}\xspace}
\newcommand{\catCCCat}{\ensuremath{\textrm{\bf CCCat}}\xspace}


\newcommand{\Mon}[1]{\ensuremath{\textrm{\bf Mon}(#1)}\xspace}
\newcommand{\Tr}{\ensuremath{\textrm{Tr}\xspace}}
\newcommand{\Int}{\ensuremath{\textrm{\rm Int}\xspace}}
\newcommand{\op}{{\textrm{op}}}


\newcommand{\catMonSig}{\ensuremath{\textrm{\bf MonSig}}\xspace}
\newcommand{\catSGraph}{\ensuremath{\textrm{\bf SGraph}}\xspace}
\newcommand{\catSGraphT}{\ensuremath{\catSGraph_{T}}}

\newcommand{\dom}{\ensuremath{\textrm{\rm dom}}}
\newcommand{\cod}{\ensuremath{\textrm{\rm cod}}}
\newcommand{\In}{\textrm{\rm In}}
\newcommand{\Out}{\textrm{\rm Out}}
\newcommand{\Bound}{\textrm{\rm Bound}}
\newcommand{\FCsp}{\textrm{\rm FCsp}}
\newcommand{\Csp}{\textrm{\rm Csp}}
\newcommand{\csp}{\textrm{\rm csp}}





\newcommand{\normalised}{\ensuremath{\!\downarrow\,}}

\newcommand{\cmdrewritesto}{\tikz[baseline=-0.25em] { \draw [-open triangle 45, line width=0.2pt] (0,0) -- (0.5,0); }\,}
\newcommand{\cmdrewriteequiv}{\tikz[baseline=-0.25em] { \draw [open triangle 45-open triangle 45, line width=0.2pt] (0,0) -- node [auto,yshift=-1.2mm] {} (0.7,0); }\,}
\newcommand{\cmdrewritetrans}{\tikz[baseline=-0.25em] { \draw [-open triangle 45, line width=0.2pt] (0,0) -- node [auto,pos=0.3,yshift=-1.2mm] {} (0.5,0); }\,}

\newcommand{\cmdleftrewritesto}{\tikz[baseline=-0.25em] { \draw [-open triangle 45, line width=0.2pt] (0,0) -- (-0.5,0); }\,}
\newcommand{\cmdleftrewritetrans}{\tikz[baseline=-0.25em] { \draw [open triangle 45-, line width=0.2pt] (0,0) -- node [auto,pos=0.7,yshift=-1.2mm] {} (-0.5,0); }\,}

\DeclareMathOperator{\rewritesto}{\cmdrewritesto}
\DeclareMathOperator{\rewriteequiv}{\cmdrewriteequiv}
\DeclareMathOperator{\rewritetrans}{\cmdrewritetrans}

\DeclareMathOperator{\leftrewritesto}{\cmdleftrewritesto}
\DeclareMathOperator{\leftrewritetrans}{\cmdleftrewritetrans}




\tikzstyle{cdiag}=[matrix of math nodes, row sep=2em, column sep=2em, text height=1.5ex, text depth=0.25ex,inner sep=0.5em]
\tikzstyle{arrow above}=[transform canvas={yshift=0.5ex}]
\tikzstyle{arrow below}=[transform canvas={yshift=-0.5ex}]

\newcommand{\csquare}[8]{
\begin{tikzpicture}
    \matrix(m)[cdiag,ampersand replacement=\&]{
    #1 \& #2 \\
    #3 \& #4  \\};
    \path [arrs] (m-1-1) edge node {} (m-1-2)
                 (m-2-1) edge node {} (m-2-2)
                 (m-1-1) edge node [swap] {} (m-2-1)
                 (m-1-2) edge node {} (m-2-2);
\end{tikzpicture}
}

\newcommand{\NWbracket}[1]{\draw #1 +(-0.25,0.5) -- +(-0.5,0.5) -- +(-0.5,0.25);}
\newcommand{\NEbracket}[1]{\draw #1 +(0.25,0.5) -- +(0.5,0.5) -- +(0.5,0.25);}
\newcommand{\SWbracket}[1]{\draw #1 +(-0.25,-0.5) -- +(-0.5,-0.5) -- +(-0.5,-0.25);}
\newcommand{\SEbracket}[1]{\draw #1 +(0.25,-0.5) -- +(0.5,-0.5) -- +(0.5,-0.25);}
\newcommand{\THETAbracket}[2]{\draw [rotate=#1] #2 +(0.25,0.5) -- +(0.5,0.5) -- +(0.5,0.25);}

\newcommand{\posquare}[8]{
\begin{tikzpicture}
    \matrix(m)[cdiag,ampersand replacement=\&]{
    #1 \& #2 \\
    #3 \& #4  \\};
    \path [arrs] (m-1-1) edge node {} (m-1-2)
                 (m-2-1) edge node [swap] {} (m-2-2)
                 (m-1-1) edge node [swap] {} (m-2-1)
                 (m-1-2) edge node {} (m-2-2);
    \NWbracket{(m-2-2)}
\end{tikzpicture}
}

\newcommand{\pbsquare}[8]{
\begin{tikzpicture}
    \matrix(m)[cdiag,ampersand replacement=\&]{
    #1 \& #2 \\
    #3 \& #4  \\};
    \path [arrs] (m-1-1) edge node {} (m-1-2)
                 (m-2-1) edge node [swap] {} (m-2-2)
                 (m-1-1) edge node [swap] {} (m-2-1)
                 (m-1-2) edge node {} (m-2-2);
  \SEbracket{(m-1-1)}
\end{tikzpicture}
}

\newcommand{\ctri}[6]{
    \begin{tikzpicture}[-latex]
        \matrix (m) [cdiag,ampersand replacement=\&] { #1 \& #2 \\ #3 \& \\ };
        \path [arrs] (m-1-1) edge node {} (m-1-2)
              (m-1-1) edge node [swap] {} (m-2-1)
              (m-2-1) edge node [swap] {} (m-1-2);
    \end{tikzpicture}
}

\newcommand{\crun}[5]{
\ensuremath{#1 \overset{#2}{\longrightarrow} #3 \overset{#4}{\longrightarrow} #5}
}

\newcommand{\cspan}[5]{
\ensuremath{#1 \overset{#2}{\longleftarrow} #3
               \overset{#4}{\longrightarrow} #5}
}

\newcommand{\ccospan}[5]{
\ensuremath{#1 \overset{#2}{\longrightarrow} #3
               \overset{#4}{\longleftarrow} #5}
}

\newcommand{\cpair}[4]{
\begin{tikzpicture}
    \matrix(m)[cdiag,ampersand replacement=\&]{
    #1 \& #2 \\};
    \path [arrs] (m-1-1.20) edge node {} (m-1-2.160)
                 (m-1-1.-20) edge node [swap] {} (m-1-2.-160);
\end{tikzpicture}
}

\newcommand{\csquareslant}[9]{
\begin{tikzpicture}[-latex]
    \matrix(m)[cdiag,ampersand replacement=\&]{
    #1 \& #2 \\
    #3 \& #4  \\};
    \path [arrs] (m-1-1) edge node {} (m-1-2)
                 (m-2-1) edge node {} (m-2-2)
                 (m-1-1) edge node [swap] {} (m-2-1)
                 (m-1-2) edge node {} (m-2-2)
                 (m-1-2) edge node [swap] {} (m-2-1);
\end{tikzpicture}
}


 


\title{Tinker, tailor, solver, proof\thanks{This work has been supported by EPSRC grants: EP/H023852, EP/H024204 and EP/J001058, the John Templeton Foundation, and the Office of Navel Research.}}
\author{Gudmund Grov
\institute{Heriot-Watt University, Edinburgh, UK} 
\email{G.Grov@hw.ac.uk}
\and
Aleks Kissinger
\institute{University of Oxford, UK} 
\email{alek@cs.ox.ac.uk}
\and 
Yuhui Lin
\institute{Heriot-Watt University, Edinburgh, UK} 
\email{Y.Lin@hw.ac.uk}
}
\def\titlerunning{Tinker, tailor, solver, proof}
\def\authorrunning{G. Grov, A. Kissinger and Y. Lin}
\begin{document}
\maketitle

\begin{abstract}
We introduce Tinker, a tool for designing and evaluating proof strategies based on \textit{proof-strategy graphs}, a formalism introduced by the authors in~\cite{LPAR13}. We represent proof strategies as open-graphs, which are directed graphs with additional input/output edges. Tactics appear as nodes in a graph, and can be `piped' together by adding edges between them. Goals are added to the input edges of such a graph, and flow through the graph as the strategy is evaluated. Properties of the edges ensure that only the right `type' of goals are accepted. In this paper, we detail the Tinker tool and show how it can be integrated with two different theorem provers: Isabelle and ProofPower.
\end{abstract}

\section{Proof strategy graphs -- a framework for tinkering}

Traditionally, the way to build up a proof from atomic tactics is to chain them together (possibly with some repetition, alternation, etc.), letting later tactics act on sub-goals produced by earlier ones. However, without any extra `plumbing' to control the flow of goals through a proof, one tends to depend on semantically irrelevant data, such as the \textit{order} in which tactics produce goals to dictate where those goals might end up, which leads to brittleness in proof strategies. For example, consider a case where we expect three sub-goals from tactic , where the first two are sent to  and the last to . A small improvement of  may result in only two sub-goals. This ``improvement'' causes  to be applied to the second goal when it should have been . The tactic  may then fail or create unexpected new sub-goals that cause some later tactic to fail.

There are a handful of ways one might go about adding this extra plumbing to a proof strategy. The technique provided by the Tinker tool\footnote{
Available at \url{https://github.com/ggrov/psgraph/tree/uitp14}.}, detailed in this paper, makes use of \textit{proof-strategy graphs} (PSGraphs), as defined in~\cite{LPAR13}, which take the notion of goal-plumbing quite literally. Tactics appear as nodes in an open-graph, which is essentially a directed graph with the additional property that we allow dangling edges, i.e. edges without source and/or target nodes. Edges without source or target nodes serve as inputs and outputs to the graph as a whole. One evaluates a PSGraph by placing one or more goal-nodes, each containing a single goal, on input edges of the graph, then applying tactics to consume goals on the in-edges of a tactic-node and producing sub-goals on the out-edges. As a result, the goals appear to flow through the graph, hitting tactics along the way, until they are either consumed (i.e. closed), or reach the output edges of the graph, in which case they become output goals for the overall evaluation. In Figure ~\ref{fig:ripple-ex}, we show some goals making their way through a PSGraph with two nodes, labelled by the tactics they represent (in this case `induct' and `ripple').
\begin{figure}
  \centering
  \scalebox{1.0}{\tikzfig{rewrite_ex}}
  \caption{Some goal-nodes (depicted as circles) making their way through a PSGraph}\label{fig:ripple-ex}
\end{figure}

Note how a single tactic node can have many out-edges. In principle, applying a tactic could send sub-goals to any of the output edges. However, there will typically only be one particular output that is appropriate for a any particular goal. When plumbing a house, pipes comes in all sizes and shapes, and you can only connect the same types of pipes together. The same is true for tactics: they only work for certain goals (although for some tactics this range of goals is rather wide). For example, an `assumption' tactic expects a hypothesis to be unifiable with the goal, and `-intro' expects the goal to start with a  quantifier. 

\begin{wrapfigure}[6]{r}{0.2\textwidth}
  \centering
  \tikzfig{induct}
\end{wrapfigure}
To effectively decide where to send goals, we label edges with \textit{goal-types}, which encode certain properties about a goal which dictate how it should then be handled. We then only allow goals to be output on edges with a matching goal-type. For example, the `induct' tactic might have two output edges: one with type \textit{step}, which matches goals of the form `' where  embeds in , and the other with type \textit{base}, which matches everything else. This output types then direct the flow of goals out of the induction tactic in a bigger PSGraph (Figure ~\ref{fig:unfold-ex} (left)).

One evaluation step works by applying a single tactic node on a single goal. Here, the goal is consumed  from the input edge, the tactic in the tactic node is applied to the goal, and the resulting sub-goals (if any) are sent down the output edges where they match. When all the goal nodes are on output edges of the graph, then it has successfully evaluated.
If no output type matches a goal, then evaluation fails. For evaluation this improves robustness of the tactic in two ways: (1) since composition is over the \emph{type of goals}, we avoid the brittleness arising from defining composition in terms of the number of sub-goals or order of sub-goals, and (2) if an unexpected sub-goal arises then evaluation will fail at the actual point of failure as it will not match any of the output types. In general, we allow this evaluation procedure to be non-deterministic by introducing branching whenever a tactic behaves non-deterministically, or a sub-goal produced by a tactic matches more than one output edge. However, with appropriate choice of goal types and evaluation strategy, this branching can be minimised.

\begin{figure}[h]
  \centering
  \tikzfig{unfold_ex}
  \caption{A simple graph hierarchy. The node marked `fertilise' in this PSGraph is itself a PSGraph, consisting of three atomic tactics. \label{fig:unfold-ex}}
\end{figure}

Figure~\ref{fig:unfold-ex} (left) highlights an example of a proof strategy employing tactics which rely on specific properties of a goal. For example, \emph{rippling}~\cite{rippling-book} is a heuristic rewriting technique most commonly used on step cases of inductive proofs, ensuring that each `ripple' step moves the goal towards the induction hypothesis (IH). This step is repeated until the IH can be applied to simplify or fully discharge the goal -- a process called `fertilisation'. The advantage of rippling is that it is guaranteed to terminate, whilst allowing rewriting behaviour that would not otherwise terminate (e.g. allowing a rewrite rule to be applied in both directions). Termination is ensured by checking that a certain \emph{embedding} property holds for the goal being rippled, while a measure is reduced from a previous goal. Collectively, these properties are captured by a goal type, in this cased called `\textit{can-ripple}'. When a goal is fully `rippled', then  `fertilisation' is applied.

Proof strategies can easily become very large and complex. In PSGraph, we can
reduce this complexity and size by hiding parts of a graph, which is achieved by
boxing a sub-graph up into a single vertex. We do this by introducing \textit{graph hierarchies}. A simple example of a hierarchy is shown in Figure~\ref{fig:unfold-ex}.



In this paper we extend \cite{LPAR13}, by providing details of the architecture and use of the Tinker tool, which implements the PSGraph formalism. In the next section we exhibit the main aspects of the Tinker UI, namely the means by which users can build and evaluate PSGraphs in the theorem provers Isabelle and ProofPower. In section~\ref{sec:arch}, we provide a more detailed overview of the Tinker architecture, including how to integrate Tinker with a new theorem prover.

\section{Using Tinker}\label{sec:ui}

Currently, Tinker operates in two distinct modes: \textit{evaluation}, where the user employs existing PSGraphs to prove conjectures, and \textit{construction}, where the user builds new PSGraphs. We aim to integrate these two modes in the future, so that strategies can be modified and improved on the fly during evaluation.

\subsection{Evaluating PSGraphs}

PSGraphs are designed to guide, rather than replace, an existing proof system. Thus they should be seen as a generic, theorem prover-independent tool. This is reflected in Tinker, which currently has interfaces implemented for both Isabelle and ProofPower. Users still use the existing interfaces of those provers, with certain extensions provided by Tinker, notably for building PSGraphs and stepping through graph evaluation (see Figure  \ref{fig:arch}). The latter is primarily used in the course of designing or debugging strategies, so Tinker can also evaluate PSGraphs in non-interactive mode, which behaves like normal tactic evaluation.

\subsubsection{Tinkering with Isabelle}

\begin{figure}
\begin{center}
\includegraphics[width=0.7\textwidth]{images/tinker-isa-i}
\end{center}
\vspace{-15pt}
\caption{Tinker GUI with Isabelle}\label{fig:eval:isabelle}
\end{figure}

Tinker is integrated with Isabelle as a new theory on top of the 
`Main' Isabelle/HOL theory\footnote{See \url{https://isabelle.in.tum.de/} for details.}. 
On top of this we have created a new proof method for Isabelle/Isar called
\textsf{psgraph}, which can be applied in one of the following ways:
\begin{tabbing}
\sf\qquad\quad\textbf{apply} (psgraph graph-name)\\
\sf\qquad\quad\textbf{apply} (psgraph (interactive) graph-name)\\
\sf\qquad\quad\textbf{apply} (psgraph (current))
\end{tabbing}
There are three different modes to work with this tactic. Firstly, if the only argument given is graph-name, then it enters the `automatic' mode, which from the user's point of view looks exactly like using any other Isabelle method. The two other modes, `interactive' and `current', utilise the Tinker GUI. This enables users to step through the proof and visualise the flow of goal-nodes. Figure~\ref{fig:eval:isabelle} shows an example of the `interactive' mode using the rippling strategy described above. Here, the related goal information will be printed in the Isabelle output panel. The supported actions in the Tinker GUI are `apply the next box / tactic', `backtrack', `replay the previous step' and `terminate the current evaluation'. If a node represents a nested PSGraph, then a new window is opened showing the nested graph, which the user can evaluate as with the parent graph.

The `current' mode is used when the user builds a new PSGraph in the Tinker GUI, which is described below. Here, the graph that is currently open in the GUI is used by the \textsf{psgraph} method. The available operations in this mode are the same as those in the `interactive' mode.  

PSGraphs are stored in Isabelle's theory context, so to use a PSGraph \textsf{graph-name} in `interactive' or `automatic' mode, a graph with the given name first needs to be stored in the theory context.



\subsection{Tinkering with ProofPower}

\begin{figure}
\begin{center}
\centering
\includegraphics[width=0.9\textwidth]{images/tinker-proofpower}
\end{center}
\vspace{-15pt}
\caption{Tinker GUI with ProofPower}\label{fig:eval:pp}
\end{figure}

The second theorem prover that is supported by Tinker is ProofPower. Here, Tinker has been integrated with ProofPower's subgoal package, used to 
handle goals and soundness of tactics via the kernel. A PSGraph is executed by the function `\textbf{run\_psg\_goal}', which is invoked in a manner similar to the Isabelle method:
\begin{tabbing}
\sf\qquad\quad\textbf{run\_psg\_goal} goal graph-name auto\\
\sf\qquad\quad\textbf{run\_psg\_goal} goal graph-name interactive\\
\sf\qquad\quad\textbf{run\_psg\_goal} goal current
\end{tabbing}
Such calls will initiate a proof of goal with the PSGraph \textsf{graph-name}. From this point, Tinker behaves identically to the Isabelle version. Figure~\ref{fig:eval:pp} shows a screenshot of a PSGraph encoding of SuperTac, a powerful and complex ProofPower tactic consisting of thousands lines of ML code and used by D-RisQ\footnote{See \url{www.drisq.com}.} in their ClawZ toolchain \cite{OHalloran13}.


\subsection{Building PSGraphs}

There are effectively two ways to build a PSGraph to be used by the Tinker system. The first is by drawing graphs using the GUI, and the second is by 
programming graphs by combining simpler graphs into more complicated ones, via a handful of \textit{graph combinators}.

\subsubsection{Tinkering by drawing}

\begin{wrapfigure}[11]{r}{0.5\textwidth}
\vspace{-50pt}
\begin{center}
\includegraphics[width=0.5\textwidth]{images/draw-hierarchy}
\end{center}
\vspace{-10pt}
\caption{Tinker Drawing GUI}\label{fig:draw}
\end{wrapfigure}
Drawing a PSGraph in the Tinker GUI is straight forward. Using node and edge tools, the user clicks to place tactic boxes and drags lines to connect boxes with edges. Inputs and outputs are represented using `dummy' vertices (depicted as small grey boxes). Then, double-clicking on nodes or edges allows the user to edit the tactics or goal types, respectively. These tactics and goal types are pre-defined in Tinker, so that they can be looked up by name during evaluation. Also the Tinker GUI allows the user to draw hierarchies as shown in Figure  \ref {fig:draw}. A `Details' window is available to show the name and type of the selected tactics as well as the path of the current hierarchy.

\subsubsection{Tinkering by programming}

In addition to being able to draw new PSGraphs, more complex PSGraphs can be built from simpler ones using a handful of graph combinators.

The atomic tactics available to Tinker correspond to tactics provided by the underlying theorem prover, and a key feature of PSGraph is that it provides a \textbf{type-safe} method to combine the tactics. Graphs are composed by plugging output edges with input edges. These edges are typed and we can only plug ``comparable" types together, where the notion of ``comparable" is goal-type specific. 

Before an atomic tactic can be included in a PSGraph, it must be equipped with a typing on its inputs and outputs. This is achieved by the function \textit{lift}, which produces a graph with a single tactic-node named \textit{node-nm}, with a list of input edges \textit{ins} and output edges \textit{outs}. This tactic-node will then be evaluated by calling the underlying tactic function \textit{tac} in the theorem prover.

\begin{figure}[h]
  \centering
  \tikzfig{combinators}
    \vspace{-7pt}
  \caption{\label{fig:then-and-tensor} THEN, TENSOR, and  combinators}
\end{figure}

One of the most common ways to combine tactics is via a \emph{THEN} tactical, where  first applies tactic  then tactic . PSGraphs have a corresponding combinator, also called \textit{THEN}, where  plugs each output edge of  into an input edge of  
of the same type. This is illustrated on the left-most diagram of Figure  \ref{fig:then-and-tensor}. Note that there could be multiple ways of plugging PSGraphs together, so Tinker provides two versions of the combinator: one version that returns a list of all possible ways  could be plugged into  and one version that simply picks one. Further, note that a \emph{maximal plugging} is always done, meaning if two edges can be connected they will be. Any remaining, un-plugged inputs/outputs will become inputs/outputs of the new graph.

Another combinator is \textit{TENSOR}, which puts  and  side by side in a single graph, without doing any plugging. This is depicted in the middle diagram of Figure~\ref{fig:then-and-tensor}. The right-most diagram shows how repetition can be naturally represented as a feedback edge. This is can be achieved by invoking the  combinator, which plugs an output of goal type  to an input of the same type. If we think of  as a loop-condition, this provides a graphical analogue to the common \emph{REPEAT\_WHILE} or \emph{REPEAT\_UNTIL} tacticals. While it is possible to encode the more common \emph{REPEAT} tactical\footnote{To be precise, repeating  until it fails can be encoded using the existing combinators as:
\vspace{-4pt}

\vspace{-12pt}

\noindent where  is the identity tactic, and  and  are goal types that succeeds for any goal.} we do not see this as a natural way of working with PSGraphs, as the goal is make a proof strategy developer think about why certain choices have been made, and represent this intuition in the goal types.

\begin{figure}[h]
  \centering
  
  \vspace{-7pt}
    \caption{\label{fig:nest} NEST combinator, which collapses a graph  to a single node `g-tac'}
\end{figure}

Hierarchies are supported in PSGraph, and the \textit{NEST} combinator introduces a hierarchy by ``collapsing" the graph into a single graph tactic with the original graph nested. This is illustrated graphically in Figure  \ref{fig:nest}. Two generalisations of \textit{NEST} are the \emph{OR} and \emph{ORELSE} combinators, which rather than nesting a single graph, will nest a pair of graphs. When evaluating , Tinker will branch, trying to evaluate both  and . On the other hand,  will only evaluate  if the evaluation of  fails. In the current version of Tinker,  and  must have the exact same number and types of input and output edges, however a direct generalisation is to produce a nested graph node whose inputs are the intersection of the inputs of  and , and whose outputs are the union of the outputs of  and . 


\section{Tinker tool architecture}\label{sec:arch}


\begin{figure}[h]
\vspace{-15pt}
\begin{center}
\includegraphics[width=0.64\textwidth]{images/architecture.pdf}

\includegraphics[width=0.3\textwidth]{images/tinkerCore}
\end{center}
\vspace{-15pt}
\caption{The Tinker architecture (left) and the Tinker core components (right)}\label{fig:arch}
\end{figure}

\noindent Figure \ref{fig:arch} (left) shows the architecture of the tool. The tool consists of two overall parts, each are in separate grey boxes.
The \textbf{core} is where all the ``magic'' happens, and is implemented in Poly/ML. The \textbf{GUI} is implemented in Scala and provides
a graphical way of creating, modifying, evaluating and debugging PSGraphs. The Tinker tool is independent of the underlying theorem prover and goal types. In both cases, this extra data is provided via ML structures passed to the Tinker core functors.

Figure \ref{fig:arch} (right) shows the main components of the Tinker core, and their dependencies, and each component is detailed below.



\subsection{IsaPlib \& the Quantomatic core}\label{sec:quanto}

The Tinker tool started out as a new language to write proof plans in the IsaPlanner proof planner \cite{paper:Dixon:03} for Isabelle. 
However, Tinker has evolved considerably since then, and the only parts used are those  
 retained in an ML library called IsaPlib, which can either co-exist with Isabelle/ML or provide an Isabelle/ML-like environment and adds some extra functionality.



PSGraphs themselves are open-graphs, and evaluation is done by open-graph rewriting. A formalisation and rewrite theory for open-graphs was provided in~\cite{paper:Dixon:10}. The Quantomatic core~\cite{Quantomatic} provides a general purpose open-graph rewriting library on top of IsaPlib, which is employed by Tinker for PSGraph evaluation.

\subsection{The Tinker GUI \& JSON communication protocol}


\noindent A JSON protocol is used to communicate between the Scala GUI and Poly/ML core. 
As seen in Figure \ref{fig:json protocol}, the GUI communicates with the core over a socket in a client/server mode.
Along with a unique message ID, a JSON message has three relevant fields: \textit{command}, \textit{input} and \textit{output}. 
The command is a string indicating a command defined by the core. 
Both input and output are in the JSON format, thus \begin{wrapfigure}[8]{r}{0.55\textwidth}
\vspace{-15pt}
\begin{center}
\includegraphics[width=0.5\textwidth]{images/protocol}
\end{center}
\vspace{-15pt}
\caption{Communication with JSON protocol}\label{fig:json protocol}
\end{wrapfigure}
data that needs to be communicated between the core and the GUI must always be serialisable as JSON.


The protocol is implemented on top of the interface provided by Quantomatic, with Tinker specific features to work with graphs (such as evaluation and hierarchies).


\subsection{Goal types}

There are two perspectives one can take on goal types. The first, which was presented in~\cite{LPAR13}, is to view a goal type simply as a \textit{predicate} on a goal. In this sense, typing provides a mechanism for filtering goals as they are output from tactics to send them to the right place. A goal type also encodes a strategy-writer's expectation for what goals should look like at various points throughout the proof. This can help to make sense of large and complex proof strategies, and more importantly, \emph{why} and \emph{where} an evaluation has failed. This information can then be used to patch the proof strategy, either manually, or automatically via a \emph{proof critic} mechanism (c.f. \cite{rippling-book}). 

The second perspective on goal types, which subsumes the first, is that they should be used a general mechanism for \emph{guiding} proofs and tactics. Here, instead of just seeing a goal as a predicate it is seen as
a (partial) \emph{function} on goal nodes. It is undefined in cases where the type does not match the goal, but when it does match, this function can be used to augment the goal-node with additional information, which can for example highlight relevant lemmas/hypothesis for a tactic. This data can in turn be used later by other tactics. Such goal types can even be initialised automatically via machine-learning techniques. A first approach to this is discussed in~\cite{grov13a}.  Tinker supports this more general kind of goal type, but for the sake of simplicity, we have chosen to focus mainly on `predicate-style' types for this paper.

\subsubsection{Creating a new goal type -- the GoalType interface}

To create a new goal type the GoalType signature has to be implemented. Firstly, types
\begin{verbatim}
  type T
  type gnode
\end{verbatim}
to represent a goal type and a goal node on the graph must be implemented, as well as a matching function:
\begin{verbatim}
  val match :  gnode -> T -> pnode -> gnode option
\end{verbatim}
where \texttt{match} is the functional view of a goal type, and a predicate will just return the same \texttt{gnode} for success and \texttt{NONE} if it fails.
Note that \texttt{gnode} is the goal node on the graph, while \texttt{pnode} is an element of the underlying proof representation. The key differences between them is that a \texttt{gnode} is on the graph and must be serialisable, while this is not required for a \texttt{pnode}. Note that the  \texttt{gnode}, is the ``previous node" (the one that generated the \texttt{pnode}) and is used to encode features such as `measure-reduction' for rippling. We will return to \texttt{pnode}s below.

For the `basic' goal type \cite{LPAR13}, \texttt{T} is a string. The string is assumed to have a set of predicates separated by `;', and for each of these names a matching function has to be created, which is called by \texttt{match}. One example is  `top\_symbol'. When the substring `top\_symbol' is found then a matching function is called that checks if the top level symbol of the goal matches with a given term. This implementation of goal-types has limited support for logic in the form of `not' and `or' connectives. To work with the GUI, a translation between \texttt{T} and \texttt{gnome} and a JSON representation must also be provided.

\subsection{Graph \& PSGraph representation}

As we mentioned in Section~\ref{sec:quanto}, Tinker uses the Quantomatic library for graph rewriting. This is done by instantiating a \textit{GRAPHICAL\_THEORY} structure called \textit{PSGraph\_Theory}. To instantiate a graphical theory, types for graph nodes and edges need to be provided, along with relevant functions for data matching and I/O. Quantomatic then constructs structures for graphs, graph rewrite rules, matching, rewriting, etc.

For the edges, the data is the \emph{goaltype} already discussed. The nodes are either tactic-nodes, whose data is represented by a \textit{reasoning technique} record, or goal-nodes. The reasoning technique record looks like this:
{\it \begin{tabbing}
\textit{RTechn} := \{ \= name :: name , appf :: app\_data \} \\
\end{tabbing}}
\vspace{-15pt}
\noindent A tactic-node is evaluated according to the contents of the \emph{app\_data} field:
{\it \begin{tabbing}
\textbf{type} app\_data := Tactic name  Nested (name,\{Or,OrElse\}) \\
\end{tabbing}}
\vspace{-15pt}
\noindent 
This field contains the name of an atomic tactic (i.e. a tactic provided by the theorem prover), or the name of a graph tactic, which corresponds to a list of nested PSGraphs. In the latter case, a flag is used to indicate whether multiple nested graphs should be evaluated OR-style or ORELSE-style.
The data on goal-nodes is given by the \texttt{gnode} type, described before.


We define a \emph{PSGraph} as follows:
\newcommand{\fmap}{\mbox{}}
{\it
\begin{tabbing}
\quad\textit{PSGraph} := \{ \= graph :: Graph, 
 atomics :: \textit{name} \fmap{} \textit{tactic},
 graph\_tactics :: name \fmap{} [ Graph ] \} \\
\end{tabbing}}
\vspace{-15pt}
\noindent 
The \emph{graph} field contains the graph of the proof strategy. The \emph{atomics} field is a map from names of atomic tactics to actual tactic functions provided by the prover. The \emph{graph\_tactics} field contains any nested graph tactics.

\subsection{Combinators revisited}

With the underlying PSGraph representation, we can provide more details about how the combinators are implemented. Since PSGraphs all contain their own lookup tables for atomic/graph tactics, it is important to avoid name clashes when we combine multiple graphs into one. To avoid such clashes we define a function type

which is then used to combine PSGraphs. The idea is that given a PSGraph we generate fresh names when required, and this type enables us to linearise this generation by enforcing an order. The combinators then have types given by:


A \textit{psgraph\_fun} can be turned into a PSGraph by applying it to the empty graph:



\subsection{The TP interface... OR how to connect a new theorem prover to Tinker}

To connect a theorem prover, a structure implementing the \emph{TP Config} signature must be provided. These structures for Isabelle and ProofPower are depicted in Figure ~\ref{fig:arch} as \emph{Isa\_Tinker} and \emph{PP\_Tinker}. This structure contains all theorem prover related data types and functions that are required. Firstly, data types for the underlying terms, theorems, proof context and tactics must be provided\footnote{The list is not complete but gives an indication of the interface between Tinker and the underlying theorem prover.}:
\begin{verbatim}
  type term 
  type thm
  type context
  type tactic 
\end{verbatim}
A handful of common functions over these types must also be provided, such as matching of terms:
\begin{verbatim}
  val match : context -> (term * term) -> bool
\end{verbatim}
Tinker assumes that a (partial) proof will be of type \texttt{plan} and it contains a set of open goals of type \texttt{pnode}. A tactic
is then seen as a function from a (partial) proof (\texttt{pplan}) and a goal (\texttt{pnode}) to a list of new goals and 
an updated proof. As there may be multiple branches when applying a tactic, a sequence of each branch is returned. This is captured by 
the \texttt{appf} type:
\begin{verbatim}
  type pplan
  type pnode
  type appf = pnode * pplan -> (pnode list * pplan) Seq.seq
\end{verbatim}
The user also needs to provide a means of producing \texttt{appf} functions from tactics, which are allowed to take a list of theorems as input:
\begin{verbatim}
  val apply_tactic : thm list -> tactic -> appf
\end{verbatim}

This interface was designed to provide the necessary functionality to interface with both Isabelle and ProofPower. We expect these to evolve when connecting more theorem provers in the future. Also note that so far both connected theorem provers are implemented in Poly/ML, making integration easier. For other platforms, integration may need to be done using e.g. socket communication.

\vspace{-5pt}
\subsection{Evaluating PSGraphs}
\vspace{-5pt}

Evaluation makes heavy use of both the prover and goal type functionality provided. A special record \textit{Eval} is used to keep track of the evaluation state of a PSGraph  as it applied to a \texttt{pnode}  of a \texttt{plan} \textit{prf}. \textit{Eval} contains  itself, together with a list of branches of the evaluation. Each branch contains a stack of active graphs (to support hierarchical evaluation of PSGraphs) as well as \textit{prf}.

In general, the graph  may have more than one input edge, so we create a branch for each input edge  by placing a goal-node containing  on  -- as long as this goal-node matches the goal type of .


Evaluation follows by picking a branch  and searching the PSGraph at the top of 's stack for a goal node  situated on an input edge of a tactic-node . Firstly,  is removed from the graph. Then if  is an atomic tactic,  it is applied to , using the \texttt{apply\_tactic} function. 
As a tactic may introduce branching, a sequence of updated \texttt{pplan}s coupled with a list  of newly generated subgoals (\texttt{pnode}s), is returned.  For each element in this sequence, the new subgoals are added to the output edge of  in a type-respecting way, without duplicating or loosing any of the subgoals. There may be multiple ways of achieving this, and each such way becomes a branch. It may also not be possible, which 
means that this element is discarded. To add a \texttt{pnode} to an edge, it must first be converted to a (serialisable) \texttt{gnode}. Such \texttt{gnode} is the return value of the \texttt{match} function of the goal type when it succeeds.

If  is a graph tactic, then  is moved to the corresponding input edge of the graph nested inside of , and this graph is pushed on to the stack of active PSGraphs. A graph evaluation has successfully terminated when all goal nodes are on the output edges of the graph. If this is the only graph on the stack then the evaluation is complete. Otherwise, the top graph is popped from the stack and its output goals are added back to the parent graph on the appropriate edges.

Graph tactics nesting multiple graphs via \textit{OR} or \textit{ORELSE} are evaluated similarly, except branches are created for each subgraph, which are all evaluated (for \textit{OR}) or evaluated until one branch completes successfully (for \textit{ORELSE}).



\vspace{-15pt}
\section{Conclusion, related \& future work}
\vspace{-10pt}

In this paper we have extended \cite{LPAR13}, which introduced the PSGraph formalisation, with details of how PSGraphs have been implemented in the Tinker tool -- with support for the Isabelle and ProofPower theorem provers. 

There are other tools supporting graphical representation of proofs. LUI \cite{SiekmannHBCFHKKMMPS99} and XIsabelle \cite{Ozols97} enable a graphical view of proof trees. They deviate from Tinker by viewing the proof and not the underlying proof strategies, which requires e.g. loops. Moreover, they cannot be used for inspection of the goal flow during evaluation, and crucially, the do not have the necessary goal abstraction via goal types. Moreover, tools such as ProveEasy \cite{Burstall2000} and
Jape \cite{bornat1997jape} have been developed to help students to learn how to do formal proofs, and deviates from Tinker in the same way as XIsabelle and LUI. Finally, as with XBarnacle\cite{Lowe97xbarnacle},  Tinker supports hierarchies, thus one can view a proof (strategy) at different levels of abstraction. Incorporating other features from XBarnacle is future work.

This is the first version of the tool, and we have already started the work on the next version, and we will now summarise features we would like to include in the next version. Firstly, goal types are a topic of active research, both from a theoretical perspective and from the point of view of implementation. The tool has therefore been developed to be flexible in the sense we can easily plug in new goal types. Experiments so far have shown that the predicate-style types described in~\cite{LPAR13} are easy to work with, but do not allow certain desirable features. On the other hand, the more expressive types from~\cite{grov13a} are very powerful, but complex to work with.

Therefore, we are now focusing on defining a new goal type combining the simplicity of~\cite{LPAR13} with the power of~\cite{grov13a}, extended with variables and pattern matching as in e.g. {\cal L}tac \cite{Delahaye02}.

In the next version of Tinker, we would like to integrate the evaluation and development views of the GUI to enable changing graphs during evaluation.
The GUI should also show the proof state, and offer an improved layout mechanism whereby only goal-nodes change position during the course of evaluation. Moreover, more user control during evaluation is desirable, in particular allowing users to easily select which goal should be executed next, and combine `interactive' and `automatic' modes, where the user can choose to `step over' or `step into' hierarchies. Continuing with this `debugger' paradigm, we would also like to add breakpoints in order to start `interactive' mode at a particular step during an otherwise `automatic' evaluation. This will be very useful for debugging large tactics such as SuperTac~\cite{OHalloran13}.

For the building aspect, we would like to make it easier to fold/unfold graphs when building new graphs, combined with a distributed way of defining search and evaluation strategies, where each nested graph may have its own strategy -- configurable in the GUI. We would also like to add `Library' functionality, as in e.g. Simulink\footnote{See \url{www.mathworks.co.uk/products/simulink/}.}, where a user can drag-and-drop existing, pre-made strategies into the current graph or create new Library entries from re-usable graph components.

Finally, we plan to integrate Tinker with more theorem provers. HOL4 should provide fewest obstacles as it is close to ProofPower and written in PolyML. Other provers, such as HOL light and Rodin, will require socket communication between Tinker and the prover core. 



\vspace{-15pt}

\begin{footnotesize}
\bibliographystyle{eptcs}
\bibliography{stratlang}
\end{footnotesize}
\end{document}
