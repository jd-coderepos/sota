\documentclass[11pt]{article}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{framed,algorithm,algorithmic}
\usepackage{amsfonts,amsmath,bm,color}

\long\def\symbolfootnote[#1]#2{\begingroup \def\thefootnote{\fnsymbol{footnote}}\footnote[#1]{#2}\endgroup}

\newcommand{\MP}{\mathbf{P}} \newcommand{\MW}{\mathbf{W}}
\newcommand{\MA}{\mathbf{A}}
\newcommand{\MB}{\mathbf{B}}
\newcommand{\ME}{\mathbf{E}}
\newcommand{\MU}{\mathbf{U}}
\newcommand{\MD}{\mathbf{\Sigma}}\newcommand{\MV}{\mathbf{V}}
\newcommand{\MX}{\mathbf{X}}
\newcommand{\MY}{\mathbf{Y}}
\newcommand{\MQ}{\mathbf{Q}}
\newcommand{\Mbf}{\mathbf{M}}
\newcommand{\MS}{\mathbf{S}}
\newcommand{\MH}{\mathbf{H}}
\newcommand{\MI}{\mathbf{I}}
\newcommand{\ML}{\mathbf{L}}
\newcommand{\MR}{\mathbf{R}}
\newcommand{\MT}{\mathbf{T}}
\newcommand{\MOmega}{\mathbf{\Omega}}
\newcommand{\MPhi}{\mathbf{\Phi}}
\newcommand{\R}{\ensuremath\mathbb{R}}
\newcommand{\mb}{\mathbf}
\newcommand{\Probab}[1]{\mbox{}{\mathbb{P}}\left[#1\right]}
\newcommand{\Expect}[1]{\mbox{}{\mathbb{E}}\left[#1\right]}
\newcommand{\Varnce}[1]{\mbox{}{\bf{Var}}\left[#1\right]}
\newcommand{\Trace }[1]{\mbox{}{\mathrm{Tr}}\left(#1\right)}
\newcommand{\Sqrt  }[1]{\mbox{}\left(#1\right)^{1/2}}
\newcommand{\Qdrt  }[1]{\mbox{}\left(#1\right)^{1/4}}
\newcommand{\FNormB }[1]{\mbox{}\left\|#1\right\|_{\mathrm{F}}  }
\newcommand{\FNormBS}[1]{\mbox{}\left\|#1\right\|_{\mathrm{F}}^2}
\newcommand{\FNorm }[1]{\mbox{}\|#1\|_\mathrm{F}  }
\newcommand{\FNormS}[1]{\mbox{}\|#1\|_\mathrm{F}^2}
\newcommand{\FNormF}[1]{\mbox{}\|#1\|_\mathrm{F}^4}
\newcommand{\FNormQ}[1]{\mbox{}\left\|#1\right\|_\mathrm{F}^4}
\newcommand{\TNormB }[1]{\mbox{}\left\|#1\right\|_2  }
\newcommand{\TNormBS}[1]{\mbox{}\left\|#1\right\|_2^2}
\newcommand{\TNorm }[1]{\mbox{}\|#1\|_2  }
\newcommand{\TNormS}[1]{\mbox{}\|#1\|_2^2}
\newcommand{\TNormF}[1]{\mbox{}\|#1\|_2^4}
\newcommand{\TNormQ}[1]{\mbox{}\left\|#1\right\|_2^4}
\newcommand{\XNormB }[1]{\mbox{}\left\|#1\right\|_{\xi}  }
\newcommand{\XNormBS}[1]{\mbox{}\left\|#1\right\|_{\xi}^2}
\newcommand{\XNorm }[1]{\mbox{}\|#1\|_{\xi}  }
\newcommand{\XNormS}[1]{\mbox{}\|#1\|_{\xi}^2}
\newcommand{\PNorm }[1]{\mbox{}\|#1\|_{p}  }
\newcommand{\PNormS}[1]{\mbox{}\|#1\|_{p}^2}
\newcommand{\XNormQ}[1]{\mbox{}\left\|#1\right\|_{\xi}^4}
\newcommand{\VTNorm }[1]{\mbox{}\left|#1\right|  }
\newcommand{\VTNormS}[1]{\mbox{}\left|#1\right|^2}
\newcommand{\VTNormQ}[1]{\mbox{}\left|#1\right|^4}
\newcommand{\VTTNorm }[1]{\mbox{}\left|#1\right|_2  }
\newcommand{\VTTNormS}[1]{\mbox{}\left|#1\right|_2^2}
\newcommand{\VTTNormQ}[1]{\mbox{}\left|#1\right|_2^4}
\newcommand{\MCNorm}[1]{\mbox{}\|#1\|_{1 \rightarrow 2}}
\newcommand{\MCNormS}[1]{\mbox{}\|#1\|_{1 \rightarrow 2}^2}
\newcommand{\INorm}[1]{\mbox{}\|#1\|_\infty}
\newcommand{\pinv}[1]{ {#1}^\dagger}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{axiom}[theorem]{Axiom}
\newtheorem{thm}[theorem]{\bf Theorem}
\newenvironment{proof}{\begin{trivlist} \item {\bf Proof:~~}}
  {\qed\end{trivlist}}

\newcommand{\qedsymb}{\hfill{\rule{2mm}{2mm}}}
\newcommand{\transp}{^{\textsc{T}}}
\newcommand{\trace}{\text{\rm Tr}}
\newcommand{\mat}[1]{{\ensuremath{\bm{\mathrm{#1}}}}}
\newcommand{\dvc}{\ensuremath{d_{\small \sf VC}}}
\newcommand{\abs }[1]{\left|#1\right|}
\newcommand{\EE}[1]{\ensuremath{\mathbb{E}\left[#1\right] } }
\newcommand{\var}[1]{\text{Var}\ensuremath{\left[#1\right] } }
\newcommand{\lambdamax}[1]{\ensuremath{\lambda_{\mathrm{max}}\left(#1\right)}}
\renewcommand{\vec}[1]{\ensuremath{\bm{#1}}}

\newenvironment{proofof}[1]{\begin{trivlist} \item {\bf Proof
#1:~~}}
  {\qed\end{trivlist}}

\def\gammab{{\bm{\gamma}}}
\def\kappab{{\bm{\kappa}}}
\def\sig{{\bm{\Sigma}}}
\def\sigplus{{\bm{\Sigma}^{+}}}
\def\siginv{{\bm{\Sigma}^{-1}}}
\def\bet{{\bm{\beta}}}
\def\one{{\bm{1}}}
\def\rank{\hbox{\rm rank}}
\def\col{\hbox{\rm col}}
\def\ker{\hbox{\rm ker}}
\def\ahat{{\hat\a}}
\def\b{{\mathbf b}}
\def\e{{\mathbf e}}
\def\expe{{\mathrm e}}
\def\q{{\mathbf q}}
\def\p{{\mathbf p}}
\def\rb{{\mathbf r}}
\def\s{{\mathbf s}}
\def\u{{\mathbf u}}
\def\ve{{\mathbf v}}
\def\d{{\mathbf \delta}}
\def\xhat{{\hat\x}}
\def\yhat{{\hat\y}}
\def\A{\matA}
\def\B{\matB}
\def\C{\matC}
\def\F{\matF}
\def\Ahat{\hat\matA}
\def\Atilde{\tilde\matA}
\def\Btilde{\tilde\matB}
\def\Stilde{\tilde\matS}
\def\Utilde{\tilde\matU}
\def\Vtilde{\tilde\matV}
\def\E{{\cl E}}
\def\G{{\cl G}}
\def\hset{{\cl H}}
\def\Q{{\bm{Q}}}
\def\U{{\bm{U}}}
\def\V{{\bm{V}}}
\def\win{\hat{\w}}
\def\wopt{\w^*}
\def\matAhat{\hat\mat{A}}
\def\matA{\mat{A}}
\def\matB{\mat{B}}
\def\matC{\mat{C}}
\def\matD{\mat{D}}
\def\matE{\mat{E}}
\def\matF{\mat{F}}
\def\matG{\mat{G}}
\def\matH{\mat{H}}
\def\matI{\mat{I}}
\def\matJ{\mat{J}}
\def\matK{\mat{K}}
\def\matL{\mat{L}}
\def\matN{\mat{N}}

\def\matM{\mat{M}}
\def\matP{\mat{P}}
\def\matQ{\mat{Q}}
\def\matR{\mat{R}}
\def\matS{\mat{S}}
\def\matT{\mat{T}}
\def\matU{\mat{U}}
\def\matV{\mat{V}}
\def\matW{\mat{W}}
\def\matX{\mat{X}}
\def\matY{\mat{Y}}
\def\matZ{\mat{Z}}
\def\matOmega{\mat{\Omega}}
\def\matSig{\mat{\Sigma}}
\def\matTh{\mat{\Theta}}
\def\matGam{\mat{\Gamma}}

\def\matOmega{\mat{\Omega}}
\def\matSig{\mat{\Sigma}}
\def\matTh{\mat{\Theta}}
\def\matGamma{\mat{\Gamma}}
\def\matPsi{\mat{\Psi}}
\def\matDelta{\mat{\Delta}}
\def\matXi{\mat{\Xi}}

\def\MatPsi{\mat{\Psi}}
\def\w{{\mathbf{w}}}
\def\ein{{\cl E_{\text{\rm in}}}}
\def\eout{{\cl E}}
\def\scl{{\textsc{l}}}
\def\scu{{\textsc{u}}}
\def\phiu{{\overline{\phi}}}
\def\psiu{{\overline{\psi}}}
\def\phil{{\underbar{\math{\phi}}}}
\newcommand\remove[1]{}

\def\nnz{{ \rm nnz }}

\def\mvec#1#2{[#1_1,\ldots ,#1_#2]}
\def\msum#1#2#3{}
\def\mint#1#2{}
\def\math#1{}
\def\mathd#1{}
\def\mand#1{}
\def\frac#1#2{{#1\over #2}}
\def\ital#1{{\it #1}}
\def\mld#1{}
\def\eqar#1{}
\def\eqan#1{}


\def\Nat{{\mathbf N\hspace*{-1.89ex}\rule{0.07ex}{1.5ex}\hspace*{1.89ex}\hspace*{-1.7ex}\rule{0.1ex}{1.5ex}\hspace*{1.7ex}\hspace*{-.6ex}\rule{0.1ex}{1.5ex}\hspace*{.6ex}}}
\def\qed{\hfill\rule{2mm}{2mm}}
\def\sm{\sum\limits}
\def\choose#1#2{\left({{#1}\atop{#2}}\right)}
\def\cl#1{{\cal #1}}
\def\prob#1{{P\left[{#1}\right]}}
\def\mathbox#1{{\fbox{\math{#1}}}}
\def\mandbox#1{{\fbox{\math{\displaystyle #1}}}}
\def\argmin{\mathop{\hbox{argmin}}\limits}
\def\argmax{\mathop{\hbox{argmax}}\limits}

\def\mbf#1{{\mbox{\boldmath{}}}}
\def\g{{\mathbf g}}
\def\h{{\mathbf h}}
\def\m{{\mathbf m}}
\def\x{{\mathbf x}}
\def\y{{\mathbf y}}
\def\z{{\mathbf z}}
\def\X{{\mathbf X}}
\def\Y{{\mathbf Y}}
\def\a{{\mathbf a}}
\def\b{{\mathbf b}}
\def\E#1{{{\mathbf E}\left[#1\right]}}
\def\norm#1{{\left\|#1\right\|}}
\def\mynorm#1{{\|#1\|}}
\def\floor#1{{\left\lfloor\,#1\,\right\rfloor}}
\def\ceil#1{{\left\lceil\,#1\,\right\rceil}}
\def\r#1{{(\ref{#1})}}
\def\rot#1{{\rotatebox{90}{#1\ }}}

\newcommand{\normF}[1]{{\| #1 \|}_F}
\newcommand{\support}[1]{\mathrm{support}(#1)}
\newcommand{\cE}{\mathcal{E}}
\newcommand{\eps}{\varepsilon}
\newcommand{\poly}{{\mathrm{poly}}}
\newcommand{\polylog}{{\mathrm{polylog}}}
\newcommand{\Exp}{\mathop{\mathrm E}\displaylimits}
\newcommand{\Var}{\mathop{\mathrm Var}\displaylimits}
\newtheorem{property}{Property}
\newtheorem{fact}{Fact}
\newtheorem{claim}{Claim}
\DeclareMathOperator{\tr}{\mathtt{tr}} 


\usepackage{amsmath, amssymb, algorithmic, framed, algorithm}

\title{Sketching as a Tool for Numerical Linear Algebra
\footnote{Version appearing as a monograph in NOW Publishers
``Foundations and Trends in Theoretical Computer Science'' series,
Vol 10, Issue 1--2, 2014, pp 1--157}}

\author{David P. Woodruff\\
IBM Research Almaden\\
dpwoodru@us.ibm.com
}

\begin{document}




\maketitle


\begin{abstract}
This survey highlights the recent advances in algorithms for
numerical linear algebra that have come from the technique of
linear sketching, whereby given a matrix, one first compresses it to
a much smaller matrix by multiplying it by a (usually) random 
matrix with certain
properties. Much of the expensive computation can then be performed on
the smaller matrix, thereby accelerating the solution for the original
problem. 
In this survey we consider least squares as well as robust regression problems,
low rank approximation, and graph sparsification. We also discuss a number
of variants of these problems. Finally, we discuss the limitations of 
sketching methods.
\end{abstract}
\newpage
\tableofcontents
\newpage
\section{Introduction}
To give the reader a flavor of results in this survey, let us
first consider the classical linear regression problem.
In a special case of this problem one attempts to ``fit'' a line through a set
of given points as best as possible. 

For example, the familiar
Ohm's law states that the voltage  is equal to the resistance
 times the electrical current , or . Suppose one is
given a set of  example volate-current pairs 
but does not know the underlying resistance. In this case one is
attempting to find the unknown slope of a line through the origin
which best fits these examples, where best fits can take on a
variety of different meanings. 

More formally, in the standard setting there is one {\it measured variable}
, in the above example this would be the voltage, and a set of
 {\it predictor variables} . In the above example 
and the single predictor variable is the electrical current. 
Further, it is assumed
that the variables are linearly related up to a noise variable, that is
, where 
are the coefficients of a hyperplane we are trying to learn 
(which does not go through the origin
if ), and  is a random variable which may be adversarially
chosen, or may come from a distribution which we may have limited or no 
information about. The  are also known as the {\it model parameters}. By
introducing an additional predictor variable  which is fixed to , 
we can in fact assume that the unknown hyperplane goes through the origin,
that is, it is an unknown subspace of codimension . We will thus assume
that  and ignore the affine component
throughout.

In an experiment one is often given  observations, or 
-tuples , for . It
is more convenient now to think of the problem in matrix form, where
one is given an  matrix  whose rows are the values of the
predictor variables in the  examples, together with an 
column vector  whose entries are the corresponding observations, and
the goal is to output the coefficient vector  so that  and 
are close in whatever the desired sense of closeness may mean. Notice
that as one ranges over all ,  ranges over
all linear combinations of the  columns of , and therefore defines
a -dimensional subspace of , which we refer to as the column
space of . Therefore the regression
problem is equivalent to finding the vector  for which  is the closest
point in the column space of  to the observation vector . 

Much of the focus of this survey will be on the over-constrained case, in which
the number  of examples is much larger than the number  of predictor
variables. Note that in this case there are more constraints than unknowns,
and there need not exist a solution  to the equation . 

Regarding the measure of fit, or closeness of  to , one of the most
common is the least squares method, which seeks to find the closest point
in Euclidean distance, i.e., 

 where  denotes the -th row of , and  the -th
entry of the vector . This error measure
has a clear geometric interpretation, 
as the optimal  satisfies that  is the standard Euclidean
projection of  onto the column space of . Because of this, it is possible
to write the solution for this problem in a closed form. 
That is,
necessarily one has  for the optimal solution  by 
considering the gradient at a point , and observing that in order for it
to be , that is for  to be a minimum, the above equation has to hold. The
equation  is known as the {\it normal equation}, which
captures that the line connecting  to  should be perpendicular to the
columns spanned by . If
the columns of  are linearly independent,  is a full rank 
matrix and the solution is therefore given by . Otherwise,
there are multiple solutions and a solution  of minimum Euclidean norm
is given by , where  is the Moore-Penrose pseudoinverse
of . Recall that if  is the singular value decomposition (SVD)
of , where  is  with orthonormal columns,  is a diagonal
 matrix with non-negative non-increasing diagonal entries, and 
is a  matrix with orthonormal rows, then the Moore-Penrose pseudoinverse of 
is the  matrix , where  is a  diagonal matrix with  if ,
and is  otherwise. 

The least squares measure of closeness, although popular, is somewhat arbitrary and 
there may be better choices depending on the application at hand. Another popular
choice is the method of least absolute deviation, or -regression. Here
the goal is to instead find  so as to minimize 
 
This measure is known 
to be less sensitive to outliers
than the least squares measure. The reason for this is that one squares
the value  in the least squares cost function, while one
only takes its absolute value in the least absolute deviation cost function. Thus,
if  is significantly larger (or smaller) than  for the 
-th observation, due, e.g., to large measurement noise on that observation, this
requires the sought hyperplane  to be closer to the -th observation 
when using the least squares cost function than when using the least absolute deviation
cost function. While there is no closed-form solution for least absolute deviation
regression, one can solve the problem up to machine precision in polynomial time
by casting it as a linear programming problem and using a generic linear programming
algorithm.

The problem with the above solutions is that on massive data sets, they are
often too slow to be of practical value. Using n\"aive matrix multiplication,
solving the normal equations for least squares would take at least 
time. For least absolute deviation regression, when casting the problem as a linear
program one needs to introduce  variables (these are needed to enforce the absolute
value constraints) and  constraints, and generic solvers would take 
 time for an polynomial in  which is at least cubic. 
While these solutions are polynomial time, they are prohibitive for 
large values of . 

The starting point of this survey is a beautiful work by Tam\'{a}s Sarl\'os \cite{S06} which
observed that one could use {\it sketching techniques} to improve upon the
above time complexities, if one is willing to settle for a randomized approximation
algorithm. Here, one relaxes the problem to finding a vector  so that
, where  is the optimal hyperplane, 
with respect to the -norm, for  either  or  as in the discussion above.
Moreover, one allows the algorithm to fail with some small probability , 
which can be amplified by independent repetition and taking the best hyperplane found.

While sketching techniques will be described in great detail in the following sections,
we give a glimpse of what is to come below. Let , 
and suppose one chooses a
 random matrix  from a certain distribution on matrices
to be specified. 
Consider the following algorithm for least squares regression: 
\begin{enumerate}
\item Sample a random matrix .
\item Compute  and .
\item Output the exact solution  to the regression problem . 
\end{enumerate}
Let us highlight some key features of this algorithm. First, notice that it is a 
{\it black box} reduction, in the sense that after computing 
and , we then solve a smaller instance of least squares regression,
replacing the original number  of observations with the smaller value of . For
 sufficiently small, we can then afford to carry out step 3, e.g., by computing
and solving the normal equations as described above. 

The most glaring omission from the above algorithm is which random familes of matrices
 will make this procedure work, and for what values of . Perhaps one of the
simplest arguments is the following. Suppose  and 
is a  matrix of i.i.d. normal random variables with mean 
zero and variance , denoted . Let  be an 
matrix with orthonormal columns for which the column space of  is equal to
the column space of , that is, the space spanned by the columns of 
together with the vector . 

Consider the product . By -stability of the normal
distribution, i.e., if  and ,
then , each of the entries of 
is distributed as  (recall that the column norms of  are equal to ). 
The entries in different rows of  are also independent
since the rows of  are independent. The entries in a row
are also independent by rotational invarance of the normal distribution, that is,
if  is an -dimensional vector of normal random variables
and  are orthogonal vectors, then  are independent. 
Here  is the  identity matrix
(to see this, by rotational invariance, these  random variables are equal in
distribution to , where  are the standard unit vectors,
from which independence follows since the coordinates of  are independent). 

It follows that  is an  matrix of i.i.d. 
random variables. For , it is well-known that with
probability , all the singular
values of  lie in the interval 
. This can be shown by arguing that for any fixed vector , 
 with probability , 
since, by rotational invariance of the normal distribution, 
 is a vector of 
i.i.d.  random variables, and so one can apply a tail bound for
, which itself is a -random variable with  degrees
of freedom. The fact that all singular values of  lie in 
 then follows by placing a sufficiently fine net on the unit sphere
and applying a union bound to all net points; 
see, e.g., Theorem 2.1 of \cite{RV10} for further details. 

Hence, for all vectors
, . But now consider the regression
problem . For each vector ,
 is in the column space of , and therefore by the previous paragraph,
. It follows that by solving the regression
problem , we obtain a -approximation to the original
regression problem with probability . 

The above technique of replacing  by  is known as a sketching technique
and  is referred to as a (linear) sketch of . While the above
is perhaps the simplest instantiation of sketching, notice that it does not in
fact give us a faster solution to the least squares regression problem. This is because,
while solving the regression problem  can now be done n\"aively
in only  time, which no longer depends on the large dimension , the
problem is that  is a dense matrix and computing  may now be too slow,
taking  time. 

Thus, the bottleneck in the above algorithm is the time for matrix-matrix multiplication. 
Tam\'{a}s Sarl\'{o}s observed \cite{S06} that one can in fact
choose  to come from a much more structured random family of matrices, called
fast Johnson-Lindenstrauss transforms \cite{AC06}. These led to roughly 
time algorithms for the least squares regression problem. Recently, Clarkson
and Woodruff \cite{CW13} improved upon the time complexity of this algorithm to obtain 
{\it optimal} algorithms for approximate least squares
regression, obtaining  time, where  denotes
the number of non-zero entries of the matrix . We call such algorithms input-sparsity
algorithms, as they exploit the number of non-zero entries of . 
The  factors
were subsequently optimized in a number of papers \cite{MM13,JH13,bn13}, leading to optimal algorithms
even when  is not too much larger than . 

In parallel, work was done on reducing the dependence on  in these algorithms from polynomial to polylogarithmic. This started with work of Rokhlin and Tygert \cite{RT08} (see also the Blendenpik algorithm \cite{amt10}), and combined with the recent input sparsity algorithms give a running time of  for least squares regression \cite{CW13}. This is significant for high precision applications of least squares regression, for example, for solving an equation of the form . Such equations frequently arise in interior point methods for linear programming, as well as iteratively reweighted least squares regression, which is a subroutine for many important problems, such as logistic regression; see
\cite{M03Compare} for a survey of such techniques for logistic regression. In these examples  is often formed from the Hessian of a Newton step in an iteration. It is clear that such an equation is just a regression problem in disguise (in the form of the normal equations), and the (exact) solution of argmin provides such a solution. By using high precision approximate regression one can speed up the iterations in such algorithms. 

Besides least squares regression, related sketching techniques have also been 
instrumental in providing better robust -regression, low rank approximation, 
and graph sparsifiers, as well as a number of variants of these problems. 
We will cover these applications each in more detail. 
\\\\
{\bf Roadmap:} In the next section we will
discuss least squares regression in full detail, which includes applications to
constrained and structured regression. In Section 3, we will then 
discuss -regression, including least absolute deviation regression. In Section 4
we will dicuss low rank approximation, while in Section 5, we will discuss graph sparsification. 
In Section 6, we will discuss the limitations of sketching techniques. In Section 7, 
we will conclude and briefly discuss a number of other directions in this area.

\section{Subspace Embeddings and Least Squares Regression}
We start with the classical least squares regression problem, which is the following. We are
given an  matrix , which is typically overconstrained, that is, , together
with an  vector , and we would like to find an  
which minimizes . Since the
problem is overconstrained, there need not exist a vector  for which . We
relax the problem and instead allow for outputting a vector  for which with probability , 

We are interested in fast solutions to this problem, which we present in \S\ref{sec:regression}. 
{\bf Section Overview:} In \S\ref{sec:se} we introduce the notion of an -subspace embedding, which is crucial to many of the applications in this book. In this section we will focus on its application to least squares regression. We show several different randomized constructions which vary in the time it takes to construct and apply them, as well as the dimension which they embed into. These constructions turn out to be oblivious to the data set. In \S\ref{sec:mm} we introduce a primitive called matrix product, which is a primitive for performing approximate matrix multiplication. Using this primitive we will show how to construct an -subspace embedding. The primitive will also play a role in \S\ref{sec:regression} in solving regression with a linear in  dependence on the accuracy parameter , as well as in \S\ref{sec:frobenius} on low rank matrix approximation. In \S\ref{sec:whp} we present a trick which takes any constant probability of success subspace embedding and shows how to obtain a high probability success subspace embedding. Thus, to some extent our earlier treatment of constant subspace embeddings is justified. In \S\ref{sec:leverage} we present a completely different way of achieving a subspace embedding, which is non-oblivious and is obtained by sampling rows of a matrix proportional to their so-called leverage scores. In \S\ref{sec:regression} we present a black box application of subspace embeddings to the least squares regression problem.  In \S\ref{sec:machinePrecision} we show how to use subspace embeddings in a different way to solve least squares regression, leading to an algorithm with only a logarithmic dependence on the error parameter . This method, while it has a much better dependence on , does require multiple passes over the data unlike the method of \S\ref{sec:regression}. Finally, in \S\ref{sec:polynomialFit} we show that for regression instances which possess additional structure, such as those that arise in polynomial fitting problems, one can apply subspace embeddings even faster than via generic ways presented before. 

\subsection{Subspace embeddings}\label{sec:se}
We start with the basic notion of an -subspace embedding for the column space of an  matrix . 
As we will see, this will be a powerful hammer for solving least squares regression. 
Throughout, for non-negative real numbers  and , we use the notation  if
. 
\begin{definition}\label{def:subspace}
A  -subspace embedding for the column space of an 
 matrix  
is a matrix  for which for all 

\end{definition}
We will often abuse notation and say that  is an -subspace embedding for  itself, even though it should be understood from the definition that this property does not depend on a particular basis for the representation of the column space of . 

Notice that if  is a  -subspace embedding for , then it is also a
 -subspace embedding for , where  is an orthonormal basis for the column
space of . This is because the sets 
 and 
are equal, where  is the rank of . 
Hence, we could without loss of generality assume that  has orthonormal columns. With 
this interpretation, the requirement of Definition \ref{def:subspace} becomes

where the final equality holds since  has orthonormal columns. If this requirement is satisfied
for unit vectors , then it is satisfied for all vectors  by scaling (since  is a linear
map), so the requirement
of Definition \ref{def:subspace} can be further simplified to

that is, the operator norm , 
should be at most . Here,  is the  identity matrix. 

There are various goals of subspace embeddings. Two of the main goals are finding a matrix  with a small
number of rows. Another goal is to be able to compute  quickly, as this is often a bottleneck
in applications. 

There are a number of ways of constructing -subspace embeddings which achieve various tradeoffs. 
One particularly useful form of an -subspace embedding is an {\it oblivious} -subspace 
embedding.

\begin{definition}\label{def:oblSubspace}
Suppose  is a distribution on  matrices , where 
is a function of , and . 
Suppose that with probability at least , for any fixed  matrix ,
a matrix  drawn from 
distribution  has the property
that  is a 
 -subspace embedding for . Then
we call  an  oblivious -subspace embedding. 
\end{definition}

Definition \ref{def:oblSubspace} 
will be used in applications throughout this book, and sometimes for convenience
we will drop the word oblivious. 

We do want to note that there are other ways of constructing subspace embeddings
though, such as through sampling the rows of  via a certain distribution and reweighting them. 
This is called Leverage Score Sampling \cite{DMM06a,DMM061,DMM062,DMMS07},
which will be discussed later in the section. This also turns out to have a number of applications, for example
to CUR decompositions of a matrix discussed in \S\ref{sec:CUR}. Note that this way of constructing subspace
embeddings is desirable in that it gives an actual ``representative'' subset of rows of  which form
a subspace embedding - this is often called a {\it coreset}. Such representations can sometimes lead to better
data interpretability, as well as preserving sparsity. While we do discuss this kind of sampling to some
extent, our main focus will be on sketching. The reader is encouraged to look at the survey by Mahoney
for more details on sampling-based approaches \cite{m11}. See also \cite{lmp13} and \cite{clmmps14} for 
state of the art subspace embeddings based on this approach. 

Returning to Definition \ref{def:oblSubspace}, the first usage of this in the numerical linear 
algebra community,
to the best of our knowledge, was done by S\'arlos, who proposed using Fast Johnson Lindenstrauss transforms
to provide subspace embeddings. We follow the exposition in Sarl\'{o}s for this \cite{S06}.

\begin{definition}
A random matrix  forms a Johnson-Lindenstrauss transform with parameters 
, or JLT for short, if with probability at least ,
for any -element subset , for all  it holds that
. 

Note when  
we obtain the usual statement that . It turns out that if we scale all  so that they are unit vectors, we could alternatively require 
 and  for all . That is, the requirement of the definition could be based on norms rather than inner products. To see that this
impies the statement above, we have 

which implies all inner products are preserved up to  by rescaling  by a constant. 
\end{definition}

There are many constructions of Johnson-Lindenstrauss transforms, possibly the simplest is given by
the following theorem. 

\begin{theorem}\label{thm:normals} (see e.g., \cite{IM98})
Let  and 
 where the entries
 of  are independent standard normal random variables. 
Then if ,
then  is a JLT(. 
\end{theorem}
We will see a proof of Theorem \ref{thm:normals} in Lemma \ref{lem:jl}. 

We show how Theorem \ref{thm:normals} can be used to provide an -subspace embedding. To do so, we need
the concept of an -net. Let 
.
We seek a finite subset of
, denoted  so that if 

then  for all . 

By an argument of \cite{AHK06,fo05,m07}, it suffices to choose  
so that for all , 
there exists a vector  for which . We will refer to 
as a -net for . 

To see that  suffices, if  is a unit
vector, then we can write 

where  and  is a scalar multiple of a vector in . This is
because we can write  where  and 
 by the definition of . 
Then,  where  and 

The expansion in (\ref{eqn:sequence}) then follows by induction. But then, 

where the first equality follows by (\ref{eqn:sequence}), the second equality follows by expanding the
square, the third equality follows from (\ref{eqn:netProperty}), and the fourth equality is what we want
(after rescaling  by a constant factor). 

We show the existence of a small -net  via a standard argument.  
\begin{lemma}\label{lem:epsL2net}
For any , 
there exists a -net  of  for which . 
\end{lemma}
\begin{proof}
For , we can equivalently express  as 

where  has orthonormal columns and the same column space as . 

We choose a -net  of the unit sphere , where the  net has
size . The intuition for this choice is that  provides an isometry when operating on ,
and so a net for  will give us a net for the image of  under . 

This can
be done by choosing a maximal set  of points on  so that no two points are within
distance  from each other. It follows that the balls of radius  centered at these points are
disjoint, but on the other hand they are all contained in the ball of radius  centered at the origin. 
The volume of the latter ball is a factor  larger than the smaller balls, which
implies . See, e.g., \cite{m02} for more details.

Define 

Since the columns of  are orthonormal, if there were a point  for which there
were no point  with , 
then  would be a point in 
for which there is no point  with , a contradiction. 
\end{proof}

It follows by setting  and  in Theorem \ref{thm:normals}, 
we can then apply Lemma \ref{lem:epsL2net} and (\ref{eqn:netProperty}) to obtain the following theorem. 
Note that the net size
does not depend on , since we just need a -net for the argument, even though the theorem holds for
general . 
\begin{theorem}\label{thm:gaussianSE}
Let  and  where the entries
 of  are independent standard normal random variables. Then if ,
then for any fixed  matrix , with probability ,  is a 
-subspace embedding for , that is, simultaneously for all ,
. Here  is an absolute constant. 
\end{theorem}
It turns out, as we will see in Section \ref{chap:lb}, that Theorem \ref{thm:gaussianSE} provides the
optimal number of rows of  up to a constant factor, namely . This is true of
any oblivious  -subspace embedding, even those achieving only a constant probability
of providing an -subspace embedding of  with constant probability. 

After Theorem \ref{thm:normals} was discovered, there were a number of followups. For instance, it was
shown by Achlioptas that one can replace  in Theorem \ref{thm:normals} with a matrix of i.i.d. sign random variables \cite{Ach03}, 
that is, each entry is independently set to  or  with probability . Further, Achlioptas 
showed that one can change the distribution so that for the same value of , one can set each entry
in  independently to be  with probability ,  with probability , and  
with probability .
The latter is important since it results in a sparse matrix , for which one can then compute  for
a vector  more quickly. A breakthrough was made by Dasgupta, Kumar, and S\'arlos \cite{dks10}
who showed that it suffices for each column of  to have only  non-zero entries
per column. Note that if the  term is much smaller than , this is a significant
improvement over the  number of non-zero entries per column achieved by previous
schemes. The  sparsity was later optimized by Kane and Nelson \cite{kn14}, who got
 non-zero entries per column. The latter was shown to be almost tight by
Nelson and Nguyn \cite{nn13lb}, who showed that  column sparsity is required. 

In short, the above line of work shows that it is possible to apply a JLT  matrix 
to a vector  in  time, where  denotes the number
of non-zero entries of the vector . This results in a significant speedup over Theorem \ref{thm:normals}
when  is small. It also leads to improvements in Theorem \ref{thm:gaussianSE}, though regarding
-subspace embeddings, one can do better as discussed below.

A somewhat different line of work also came about in trying to speed up the basic construction
in Theorem \ref{thm:normals}, and this is due to Ailon and Chazelle \cite{AC06}. Instead of trying to achieve
a sparse matrix , they tried to achieve an  which could be quickly applied to a vector . 
The underlying
intuition here is that for a vector  
whose  mass is spread roughly uniformly across its  coordinates, sampling a small number of
its coordinates uniformly at random and rescaling results in a good estimate of the -norm of . 
However, if  does not have this property, e.g., it is sparse, then sampling is a very poor way to estimate
the -norm of , as typically most samples will be . By the uncertainty principle, though, 
if  is sparse, then  cannot be too sparse, 
where  is the Fourier transform. This is also true for the
Hadamard transform , and for any bounded orthonormal system (i.e., an orthonormal matrix
whose entry of maximum magnitude is bounded by ). Indeed, from results in signal processing due
to Donoho and Stark \cite{DS89}, 
if  is a  matrix such that  has orthonormal rows and columns,
and for any distinct rows  we have , then for any
, it holds that . See, e.g., \cite{i07}, 
for algorithmic applications of this uncertainty principle. 

Unfortunately  can still be sparse enough that a small number of samples will not work, 
so the intuition
is to re-randomize  by applying a cheap rotation - namely, computing  
for a diagonal matrix 
with i.i.d. entries  in which  with probability , 
and  with probability .
If  is an  matrix which implements coordinate sampling, 
then  now provides the desired
Johnson-Lindenstrauss transform. Since  is a diagonal matrix, 
 can be computed in  time. The Hadamard
matrix  can be applied to an -dimensional vector in  time. Finally,  can be applied to
an -dimensional vector in  time. Hence,  
can be applied to a vector in 
time and to an  matrix in  time. 
We call this the {\em Fast Johnson Lindenstrauss Transform}. We note that this is not
quite the same as the construction given by Ailon and Chazelle in \cite{AC06}, who form 
slightly differently to obtain a better dependence on  in the final dimension. 

The Fast Johnson Lindenstrauss Transform 
is significantly faster than the above  time for many
reasonable settings of the parameters, e.g., 
in a number of numerical linear algebra applications in which  can be exponentially
large in . Indeed, the Fast Johnson Lindenstrauss Transform was first used by S\'arlos to obtain the first speedups
for regression and low rank matrix approximation with relative error. S\'arlos used a version of the Fast Johnson
Lindenstrauss Transform due to \cite{AC06}. 
We will use a slightly different version called the {\em Subsampled
Randomized Hadamard Transform}, or SRHT for short. Later we will see a significantly faster transform for sparse
matrices. 

\begin{theorem}\label{thm:srht}(Subsampled Randomized Hadamard Transform 
\cite{AC06,S06,DMM06a,DMMS07,Tro11,DMMW12,ldfu13})
Let , where  
is an  diagonal matrix with i.i.d. diagonal
entries  in which  with probability , and  
with probability . 
 refers to the Hadamard matrix of size , which we assume is a power of . Here, the -th
entry of  is given by , 
where ,
and where  and  are the binary representations of  and
 respectively. The  matrix  samples  coordinates of an -dimensional vector uniformly at random, 
where 
 
Then with probability at least , for any fixed  matrix  with orthonormal columns,
 
Further, for any vector ,  can be computed in  time. 
\end{theorem}
We will not present the proof of Theorem \ref{thm:srht}, instead relying upon the above intuition. The 
proof of Theorem \ref{thm:srht} can be found in the references listed above. 

Using Theorem \ref{thm:srht}, it is possible to compute an oblivious -subspace embedding of a matrix 
in  time (see Definition 2.2 and Theorem 2.1 of \cite{AL08} for details on obtaining
this time complexity, which is a slight improvement to the  time mentioned above), which up to the logarithmic factor, is optimal in the matrix dimensions
of . One could therefore ask if this is the end of the road for subspace embeddings. 
Note that applying Theorem \ref{thm:gaussianSE} to create an oblivious -subspace embedding , 
or also using its optimizations discussed in the paragraphs following Theorem \ref{thm:gaussianSE} due to
Kane and Nelson \cite{kn14}, would
require time at least , since the number of non-zero entries per column of 
would be , 
since the  of Theorem \ref{thm:normals} would need to be set
to equal  to apply a net argument. 

It turns out that many matrices  are sparse, 
that is, the number of non-zero entries, , may be much smaller than . One could therefore
hope to obtain an oblivious -subspace embedding  in which  can be computed 
in 
time and which the number of rows of  is small. 

At first glance this may seem unlikely, since as mentioned
above, it is known that any Johnson Lindenstrauss Transform requires 
  non-zero entries per column. Moreover, the size of any -net
for constant  is at least , and therefore applying the arguments above we see that the ``'' in 
the lower bound needs to be . Alternatively, we could try to use an SRHT-based approach, but 
it is unknown how to adapt such approaches to exploit the sparsity of the matrix . 

Nevertheless, in work with Clarkson \cite{CW13} we show that it is indeed possible to achieve  time to
compute  for an oblivious   
subspace embedding  with only an 
number of rows. The key to bypassing the lower bound mentioned above is that  will {\it not} be a Johnson
Lindenstrauss Transform; instead it will only work for a set of  specially chosen points rather
than an arbitrary set of  points. It turns out if we choose  points from a -dimensional subspace,
then the above lower bound of  non-zero entries per column
does not apply; that is, this set of  points is far from realizing the worst-case for the lower bound. 

In fact  is nothing other than the {\sf CountSkech} matrix from the data stream literature 
\cite{ccf04,tz12}.
Namely,  is constructed via the following procedure: for each of the  columns , 
we first independently choose a 
uniformly random row
. Then, we choose a uniformly random element of , denoted . We set  and set  for all . 
Thus,  has only a single non-zero entry per column. For example, suppose . Then an instance of  could
be:

We refer to such an  as a {\em sparse embedding matrix}. Note that since  has only a single non-zero
entry per column, one can compute  for a matrix  in  time. 
\begin{theorem}\label{thm:cw}(\cite{CW13})
For  a sparse embedding matrix with a total of  rows, for any fixed 
matrix , with probability ,  is a  -subspace embedding for . Further,
 can be computed in  time. 
\end{theorem}
Although the number of rows of  is larger than the  using Theorem \ref{thm:gaussianSE}, 
typically , e.g., in overconstrained regression problems, and so one can reduce 
to a matrix containing  rows by composing it with a matrix  sampled using Theorem \ref{thm:normals}
or Theorem \ref{thm:srht},
computing  in time , and so provided , 
this gives an overall  time algorithm for obtaining an oblivious  -subspace embedding
with the optimal  number of rows. Note here we can assume that 
, as otherwise we can delete the rows of all zeros in . 

The key intuition behind Theorem \ref{thm:cw}, given in \cite{CW13} 
why a sparse embedding matrix provides a subspace embedding, is 
that  need not preserve the norms
of an arbitrary subset of  vectors in , but rather it need only preserve those norms
of a subset of  vectors in  which {\it all sit in a -dimensional subspace} of 
. Such a subset of  vectors is significantly different from an arbitrary such set; 
indeed, the property used in \cite{CW13} which invented this was the following. 
If  is a matrix
with orthonormal columns with the same column space as , then as one ranges over all unit , 
 ranges over all unit vectors in the column space of . Note though that for any coordinate , by the
Cauchy-Schwarz inequality, 

As , since  has orthonormal columns, there is a subset 
 of  of size at most  for which if , then . Notice that  does not
depend on , but rather is just equal to those rows  for which . Hence,  
(\ref{eqn:csIneq}) implies that as one ranges over all unit
vectors , the coordinates of  that are larger than , if any, must lie in this relatively
small set . This
is in sharp contrast to an arbitrary set of  unit vectors, for which every coordinate could be larger than 
 for at least one vector in the collection. It turns out that if  has no heavy coordinates, then a
sparse subspace embedding does have the Johnson-Lindenstrauss property, 
as shown by Dasgupta, Kumar, and S\'arlos \cite{dks10}.
Hence, provided the set of coordinates of  is perfectly hashed by , one can handle the remaining coordinates
by the analysis of \cite{dks10}. 

While the above proof technique has proven useful in generating  subspace embeddings for other -norms
(as we will see in Section \ref{chap:robust} for the -norm), 
and also applies more generally to sets of  vectors with a fixed small number of heavy coordinates, 
it turns out for  one can simplify and sharpen the argument by using 
more direct linear-algebraic methods.
In particular, via a simpler second moment calculation, Theorem \ref{thm:cw} 
was improved in \cite{MM13,JH13} to the following.
\begin{theorem}\label{thm:mmnn}\cite{MM13,JH13}
For any , and for  a sparse embedding matrix with  rows, 
then with probability , for any fixed 
matrix ,  is a  -subspace embedding for . 
The matrix product 
 can be computed in  time. Further, all of this holds if the hash function
 defining  is only pairwise independent, and the sign function  defining  is only
-wise independent. 
\end{theorem}
The proofs of Theorem \ref{thm:mmnn} given in \cite{MM13,JH13} work by bounding, for even integers ,

which is a standard way of bounding operator norms of random matrices, see, e.g., \cite{by93}. 
In the bound above, Markov's inequality is used in the first inequality, while the second inequality
uses that the eigenvalues of  are non-negative for even integers
, one of those eigenvalues is , and the trace is the sum
of the eigenvalues. 
This is also the technique
used in the proof of Theorem \ref{thm:nn} below (we do not present the proof of this), 
though there a larger value of  is used while
for Theorem \ref{thm:mmnn} we will see that it suffices to consider . 

Rather than proving Theorem \ref{thm:mmnn} directly, we will give a 
alternative proof of it observed by Nguyn \cite{n13}
in the next section, showing how it is a consequence of a primitive called approximate matrix multiplication that
had been previously studied, and for which is useful for other applications we consider. 
Before doing so, though, we mention that it is possible to achieve fewer than  rows for constant
probability subspace embeddings 
if one is willing to increase the running time of applying the subspace embedding from 
 to . 
This was shown by Nelson
and Nguyn \cite{JH13}. 
They show that for any , one can achieve  dimensions
by increasing the number of non-zero entries in  to . They also show that 
by increasing the number of non-zero entries in  to , 
one can achieve  dimensions. These results also generalize to failure probability ,
and are summarized by the following theorem. 

\begin{theorem}\label{thm:nn}\cite{JH13}
There are distributions on matrices  with the following properties:

(1) For any fixed  and any fixed  matrix , 
 is a  oblivious -subspace embedding for 
with  rows and error probability . Further,  can be computed
in  time. 

(2) There is a  oblivious -subspace embedding for  
with  rows and error probability . 
Further,  can be computed
in  time. 
\end{theorem}
We note that for certain applications, such as least squares regression, one can
still achieve a -approximation in  time by applying Theorem \ref{thm:nn}
with the value of  in Theorem \ref{thm:nn} set to a fixed constant since the application only
requires a -subspace embedding in order to achieve a -approximation; see 
Theorem \ref{thm:1eps} for further details on this. It is also conjectured in \cite{JH13} that
 can be as small as  with a time for computing 
of , though at the time of this writing the polylogarithmic
factors in Theorem \ref{thm:nn} are somewhat far from achieving this conjecture. 

There has been further work on this by Bourgain and Nelson \cite{bn13}, 
who showed among other things that 
if the columns of  form an orthonormal basis for the column space of , and
if the coherence , then a sparse embedding
matrix provides a  -subspace embedding for . Here the column sparsity
remains  given the incoherence assumption, just as in Theorem \ref{thm:mmnn}. The authors also
provide results for unions of subspaces. 

We note that one can also achieve  success
probability 
bounds in which the sparsity and dimension depend on  using 
these constructions \cite{CW13,MM13,JH13}. For our
applications it will usually not be necessary, as one can often instead repeat the entire procedure 
times and take the best solution found, such as in regression or low rank matrix approximation. 
We also state a different
way of finding an -subspace embedding with high success probability in \S\ref{sec:whp}.

\subsection{Matrix multiplication}\label{sec:mm}
In this section we study the approximate matrix product problem. 

\begin{definition}\label{def:matrixProduct}
Let  be a given approximation parameter. 
In the {\em Matrix Product} Problem matrices  and  are given, 
where  and  each have  rows and a 
total of  columns.  
The goal is to output a 
matrix  so that 

\end{definition}
There are other versions of approximate matrix product, such as those that replace the Frobenius norms
above with operator norms \cite{Zou10,malik11,CEMMP14,CNW14}. 
Some of these works look at
bounds in terms of the so-called stable rank of  and , which
provides a continuous relaxation of the rank. 
For our application we will focus on the version of the
problem given in Definition \ref{def:matrixProduct}. 

The idea for solving this problem is to compute  and  
for a sketching matrix . We will choose  so that

and we could hope that the variance of this estimator is small, namely,
we could hope that the standard deviation of the estimator is . 
To figure out which matrices  are appropriate for this,
we use the following theorem of Kane and Nelson \cite{kn14}. This is a more general result of the 
analogous result for sign matrices of Clarkson and the author \cite{CW09}, and a slight strengthening 
of a result of Sarl\'{o}s \cite{S06}. 

Before giving the theorem, we need a definition.

\begin{definition}\cite{kn14}\label{def:moment}
A distribution  on matrices  has the 
-JL moment property if for all  with ,

\end{definition}

We prove the following theorem for a general value of , since as mentioned it is used in some
subspace embedding proofs including the ones of Theorem \ref{thm:nn}. However, in this section we will only
need the case in which . 

\begin{theorem}\label{thm:jlamp}\cite{kn14}
For , let  be a distribution over matrices with  columns
that satisfies the -JL moment property for some . Then for 
matrices each with  rows,

\end{theorem}
\begin{proof}
We proceed as in the proof of \cite{kn14}. 
For , we have

For a random scalar , let . 
We will sometimes consider  for a random matrix , 
in which case  is a random scalar
and the somewhat cumbersome notation  indicates . 

Minkowski's inequality asserts that the triangle
inequality holds for this definition, namely, that , and as the
other properties of a norm are easy to verify, it follows that  is a norm. Using that it is a norm, we have
for unit vectors , , that  is equal to

By linearity, this implies for arbitrary vectors  and  that
. 

Suppose  has  columns and  has  columns. 
Let the columns of  be  and the columns of  be . 
Define the random variable 

Then, . Again using Minkowski's inequality and that ,

Using that , together with Markov's inequality, we have

\end{proof}
We now show that sparse embeddings matrices satisfy the -JL-moment property. This was originally shown
by Thorup and Zhang \cite{tz12}.
\begin{theorem}\label{thm:tz}
Let  be a sparse embedding matrix, as defined in \S\ref{sec:se}, with at least  rows. Then 
 satisfies the -JL moment property. Further, this holds if the hash function  defining the 
sparse embedding matrix is only -wise independent and the sign function  is -wise independent. 
\end{theorem}
\begin{proof}
As per Definition \ref{def:moment}, we need to show for any unit vector ,

For a sparse embedding matrix , we let  be a random -wise independent 
hash function indicating for each column
, which row in  contains the non-zero entry. Further, we let  be a -wise
independent function, independent of , indicating whether
the non-zero entry in the -th column is  or . For an event , let  be an indicator variable
which is  if  occurs, and is  otherwise. Then,

where the second equality uses that  and  are independent, while the third equality uses that  if , and otherwise
is equal to . 

We also have,

where the second equality uses the independence of  and , and the third equality uses that since  is -wise independent, in order for 
 not to vanish, it must be that either 
\begin{enumerate}
\item  or
\item  and  but  or
\item  and  but  or
\item  and  but .
\end{enumerate}
Note that in the last two cases, for  not to vanish,
we must have . The fourth equality and first inequality are based on regrouping the summations, and the sixth inequality uses that . 

Plugging our bounds on  and  into (\ref{eqn:toshow}), the theorem follows. 
\end{proof}
We now present a proof that sparse embedding matrices provide subspace embeddings, as mentioned in \S\ref{sec:se},
as given by Nguyn \cite{n13}.  
\begin{proofof}{of Theorem \ref{thm:mmnn}}
By Theorem \ref{thm:tz}, we have that  satisfies the -JL moment property. We can thus apply Theorem \ref{thm:jlamp}. 

To prove Theorem \ref{thm:mmnn}, 
recall that 
if  is an orthonormal basis for the column space of  and  for all  in
the column space of , then  for all  in the column space of , since the column
spaces of  and  are the same. 

We apply Theorem \ref{thm:jlamp} to  with the  and  of that theorem equal to , 
and the  of that theorem equal to . Since  and , we have,

which implies that  

Recall that 
the statement that  for all unit  is
equivalent to the statement that  for all unit , that is,
 is a  -subspace embedding. The proof follows by rescaling  by .  
\end{proofof}

\subsection{High probability}\label{sec:whp}
The dependence of Theorem \ref{thm:mmnn} on the error probability  is linear, which is not completely
desirable. One can use Theorem \ref{thm:nn} to achieve a logarithmic dependence, but then the running time
would be at least  and the number of non-zeros per column of  would
be at least . Here we describe an alternative way based on \cite{BKLW14} 
which takes 
time, and preserves the number of non-zero entries per column of  to be . It is, however, a
non-oblivious embedding. 

In \cite{BKLW14}, an approach (Algorithm~\ref{alg:success} below) to boost the success probability 
by computing 
independent sparse oblivious subspace embeddings  is proposed, , 
each with only constant success probability,
and then running a cross validation procedure to find one which succeeds with probability .
More precisely, we compute the SVD of all embedded matrices ,
and find a  such that for at least half of the indices ,
all singular values of  are in .

The reason why such an embedding  succeeds with high probability is as follows.
Any two successful embeddings  and , by definition, satisfy that
 for all ,
which we show is equivalent to passing the test on the singular values.
Since with probability at least , a  fraction of the embeddings are successful,
it follows that the one we choose is successful with probability . One can thus show
the following theorem.

\begin{theorem}\label{thm:success}(\cite{BKLW14})
Algorithm~\ref{alg:success} outputs a subspace embedding with probability at least .
In expectation step 3 is only run a constant number of times.
\end{theorem}

\begin{algorithm}[t]
\caption{Boosting success probability of embedding}
\label{alg:success}
Input: , parameters 
\begin{enumerate}
\item Construct  independent constant success probability sparse subspace embeddings 
with accuracy .
\item Compute SVD  for .
\item For 
\begin{enumerate}
\item Check if for at least half , 
\item If so, output .
\end{enumerate}
\end{enumerate}
\end{algorithm}

\subsection{Leverage scores}\label{sec:leverage}
We now introduce the concept of leverage scores, which provide alternative subspace embeddings based on sampling
a small number of rows of . We will see that they play a crucial role in various applications in this book,
e.g., CUR matrix decompositions and spectral sparsification. Here we use the parameter  instead of  for the dimension
of the subspace, as this will match our use in applications. For an excellent survey on leverage scores, we refer
the reader to \cite{m11}. 

\begin{definition}(Leverage Score Sampling)\label{def:lss}
Let  have orthonormal columns, and let , 
where 
is the -th leverage score of . Note that  is a distribution. 
Let  be a parameter, and suppose we have any distribution  for which for
all , .

Let  be a parameter. Construct an  
sampling matrix  and an  rescaling matrix  as follows. 
Initially, 
and . For each column  of , 
independently, and with replacement, pick a row index
 with probability , and set  and 
. We denote this procedure
{\textsc RandSampling}. 
\end{definition}
Note that the matrices  and  in the {\textsc RandSampling} procedure 
can be computed in  time. 

Definition \ref{def:lss} introduces the concept of the {\it leverage scores}  of a matrix 
 with orthonormal columns. For an  matrix  whose columns need not be orthonormal, we can still
define its leverage scores  as , where  is an  matrix with orthonormal
columns having the same column space of , where  is the rank of . Although there are many choices
 of orthonormal bases for the column space of , it turns out that they all give rise to the same values
. Indeed, if  were another  matrix with orthonormal colums having the same column space
of , then  for an  invertible matrix . But since  and 
have orthonormal columns,  must be orthonormal. Indeed, for every vector  we have

Hence 
so the definition of the leverage scores does not depend on a particular choice of orthonormal basis for the column space
of .

Another useful property, though we shall not need it, is that the leverage scores  are at most . This follows
from the fact that any row  of  must have squared norm at most , as otherwise 

contradicting that  for all  since  has orthonormal columns. 

The following shows that  
is a subspace embedding of the column space of , for  large enough.
To the best of our knowledge, theorems of this form first appeared in \cite{DMM06c,DMM06d}. Here we give a simple
proof along the lines in \cite{Mag10}.   
\begin{theorem}\label{thm:lssPerf}(see, e.g., similar proofs in \cite{Mag10})
Suppose  has orthonormal columns. Suppose  
and  and 
are constructed from the {\textsc RandSampling} procedure. Then with probability
at least , simultaneously for all , 

or equivalently,

\end{theorem}

\begin{proof}
We will use the following matrix Chernoff bound for a sum of random matrices, 
which is a non-commutative Bernstein bound.

\begin{fact}(Matrix Chernoff)\label{fact:chernoff}
Let  be independent copies of a symmetric random matrix  
with , , and . 
Let . Then for any ,
 
\end{fact}
Let  be the -th sampled row of  by the 
{\textsc RandSampling} procedure.
Let
 denote the -th row of . 
Let . Then the  
are independent copies of a matrix random variable, and  

For any ,  is a rank- matrix with 
operator norm bounded by . Hence,

We also have

It follows that . 
Note that . 
Applying Fact \ref{fact:chernoff},

and setting  
implies that with all but  probability,
, 
that is, all of the singular values of  are within , as desired. 
\end{proof}
To apply Theorem \ref{thm:lssPerf} for computing subspace embeddings of an  matrix , one writes
 in its SVD. Then, Theorem \ref{thm:lssPerf} guarantees that for all ,

where the first equality uses the definition of  and the fact that all singular values of 
are . The second equality uses that  has orthonormal columns, so  for all
vectors . 

One drawback of {\textsc RandSampling} is it requires as 
input a distribution  which well-approximates the leverage
score distribution  of . While one could obtain  exactly by computing the SVD of , this would na\"ively take
 time (assuming ). It turns out, as shown in \cite{DMMW12}, one can compute a distribution  with the approximation
parameter  in time  time. This was further improved in \cite{CW13} to  time. 

We need a version of the Johnson-Lindenstrauss lemma, as follows. We give a simple proof for completeness.
\begin{lemma}(Johnson-Lindenstrauss)\label{lem:jl}
Given  points , if  is a  matrix of i.i.d.  random 
variables, then for  simultaneously for all ,

\end{lemma}
\begin{proof}
For a fixed ,  is a -tuple of i.i.d.  random variables. Here we use
the fact that for independent standard normal random variables  and  and scalars  and , 
the random variable  has the same distribution as that of the random variable 
, where . 

It follows that   
is equal, in distribution, to , where  are independent 
random variables. 

The random variable  is  with  degree of freedom. The following tail bounds are known.
\begin{fact}(Lemma 1 of \cite{lm00})\label{fact:c2}
Let  be i.i.d.  random variables. Then for any ,

and

\end{fact}
Setting , we have that

For , the lemma follows by a union bound over .
\end{proof}

\begin{theorem}\label{thm:fastLS}(\cite{CW13})
Fix any constant . 
If  is the leverage score distribution of an  matrix  with orthonormal columns, it is possible to compute
a distribution  on the  rows for which with probability , simultaneously 
for all , . The time complexity is . 
\end{theorem}
\begin{proof}
Let  be a sparse embedding matrix with  rows for a constant  to be specified.  
We can compute  in  time. We then compute a QR-factorization of , where
 has orthonormal columns. This takes  time. Note that  is , and can be computed
from  in  time (or faster using fast matrix multiplication). 

For , 
let  by a  matrix of i.i.d.  random variables. Set  for all .
While we cannot compute  very efficiently, we can first compute  in 
by standard matrix multiplication, and then compute  in  time since
 has a small number of columns. 
Since we will set  to be a constant, the overall time complexity of the theorem follows. 

For correctness, by Lemma \ref{lem:jl}, 
with probability , simultaneously for all , , which we condition on.
We now show that  is approximately . To do so, first consider . The claim is that
all of the singular values of  are in the range . To see this, note that for any ,

where the first equality follows since with probability ,  is a  -subspace embedding for ,
while the second equality uses the definition of , and the third equality uses that  has orthonormal columns. 

Next, if  is an orthonormal basis for the column space of , since  and  have the same column
space,  for a  change of basis matrix . The claim is that the minimum singular
value of  is at least . Indeed, since all of the singular values of  are in 
the range , if there were a singular value of  smaller than  with corresponding right singular
vector , then , but , a contradiction. 

Finally, it follows that for all , 

Hence, , which for an appropriate choice of constant , achieves
, as desired. 
\end{proof}


\subsection{Regression}\label{sec:regression}
We formally define the regression problem as follows. 
\begin{definition}\label{prob:regression}
In the {\it -Regression Problem}, an  matrix  and an 
 column vector  are given, together with an approximation parameter .  
The goal is to output a vector  so that

\end{definition}

The following theorem is an immediate application of -subspace embeddings. The proof actually shows
that there is a direct relationship between the time complexity of computing an -subspace embedding 
and the time complexity of approximately solving -regression. We give one instantiation of this relationship 
in the following theorem statement.
\begin{theorem}\label{thm:regression}
The -Regression Problem can be solved with probability  in  time.
\end{theorem}
\begin{proof}
Consider the at most -dimensional subspace  of  spanned by the columns of  
together with the vector . Suppose we choose  to be a sparse embedding matrix with  rows.
By Theorem \ref{thm:cw}, we have that with probability , 

It follows that we can compute  followed by , and then let

By (\ref{eqn:seBound}), it follows that  solves the -Regression Problem. The number of rows
of  can be improved to  by applying Theorem \ref{thm:mmnn}. 
\end{proof}

We note that Theorem \ref{thm:regression} can immediately be generalized to other versions of regression,
such as {\it constrained regression}. In this problem there is a constraint subset 
and the goal is, given an  matrix  and an  column vector , to output a vector 
for which

Inspecting the simple proof of Theorem \ref{thm:regression} we see that (\ref{eqn:seBound}) in particular implies

from which we have the following corollary. This corollary follows by replacing  and 
with  and , where  has  rows using Theorem \ref{thm:mmnn}. 
\begin{corollary}\label{cor:regression}
The constrained  Regression Problem with constraint set 
can be solved with probability  in  time, 
where  is the time to solve constrained  regression with constraint set  when 
has  rows and  columns. 
\end{corollary}

It is also possible to obtain a better dependence on  than given by Theorem \ref{thm:regression} 
and Corollary \ref{cor:regression} in both the time and space, due to the fact that it is 
possible to choose the sparse subspace embedding
 to have only  rows. We present this as its own separate theorem. We only state the time bound
for unconstrained regression. 

The proof is due to Sarl\'{o}s \cite{S06}. The key concept in the proof is that of the {\it normal equations}, which state
for the optimal solution , , or equivalently, , that is,
 is orthogonal to the column space of . This is easy to see from the fact that the optimal
solution  is such that  is the projection of  onto the column space of , which is the closest
point of  in the column space of  in Euclidean distance. 

\begin{theorem}\label{thm:1eps}
If  is a sparse subspace embedding with  rows, then with probability , the solution

\end{theorem}
\begin{proof}
Let  be , and 
let  be . It will be useful to reparameterize the problem
in terms of an orthonormal basis  for the column space of . Let  and
. 

Because of the normal equations, we may apply the Pythagorean theorem,

which in our new parameterization is,

It suffices to show
, as then the theorem will follow by rescaling  by a constant 
factor. Since  has orthonormal columns, it suffices to show 

Conditioned on  being a  -subspace embedding,
which by Theorem \ref{thm:mmnn} occurs with probability  for an  with an appropriate  number
of rows, we have 


Hence,

where the first inequality is the triangle inequality, the second inequality uses the sub-multiplicativity of the spectral norm, 
and the third inequality uses (\ref{eqn:seReg}). Rearranging, we have

By the normal equations in the sketch space, 

and so plugging into (\ref{eqn:apmp}),

By the normal equations in the original space, .
By Theorem \ref{thm:tz},  has the -JL moment property, and so by Theorem \ref{thm:jlamp},

Since , it follows that with probability , 
, and plugging into (\ref{eqn:apmp2}),
together with a union bound over the two probability  events, completes the proof. 
\end{proof}

\subsection{Machine precision regression}\label{sec:machinePrecision}
Here we show how to reduce the dependence on  to logarithmic in the regression application, 
following the approaches in \cite{RT08,amt10,CW13}. 

A classical approach to finding 
is to solve the normal equations 
 via Gaussian elimination;
for  and ,
this requires  time to
form ,  time to form ,
and  time to solve the resulting linear systems.
(Another method is to factor ,
where  has orthonormal columns and  is
upper triangular; this typically trades a slowdown for a higher-quality solution.)

Another approach to regression is to apply an iterative method
from the general class of Krylov or conjugate-gradient type algorithms to a 
pre-conditioned version of the problem. In such methods,
an estimate  of a solution is maintained,
for iterations ,
using data obtained from previous iterations.
The convergence of these methods depends
on the \emph{condition number}

from the input matrix.
A classical result (\cite{Luen} via \cite{MSM} or Theorem 10.2.6,\cite{GvL}),
is that

Thus the running time of CG-like methods, such as {\tt CGNR} \cite{GvL},
depends on the (unknown)
condition number. The running time per iteration is the time needed
to compute matrix vector products  and ,
plus  for vector arithmetic, or .

Pre-conditioning reduces the number of iterations needed for a given accuracy:
suppose
for a non-singular matrix , the condition number 
is small. Then a conjugate gradient method applied to  would converge quickly,
and moreover for iterate  that has error 
small, the corresponding  would have .
The running time per iteration would have an
additional  for computing products involving .

Suppose we apply a sparse subspace embedding matrix 
to , and  is computed so that   has
orthonormal columns, e.g., via a QR-decomposition of . 
If  is an -subspace
embedding matrix to constant accuracy ,
for all unit ,
.
It follows that the condition number

That is,  is well-conditioned. Plugging this
bound into \eqref{eq:CG accuracy}, after  iterations
 is at most 
times its starting value.

Thus starting with a solution  with 
relative error at most 1, and applying  iterations
of a CG-like method with , the relative error is reduced to 
and the work is , 
plus the work to find . We have

\begin{theorem}\label{thm:it reg}
The -regression problem can be solved up to a -factor with probability at least 
 in

time.
\end{theorem}

The matrix  is so well-conditioned that a simple iterative improvement scheme
has the same running time up to a constant factor. Again start with a solution  with 
relative error at most 1, and for ,
let .
Then using the normal equations,

where  is the SVD of .

For all unit ,
, and so
we have that all singular values  of  are ,
and the diagonal entries of 
are all at most  for 
. Hence 

and by choosing , say,  iterations suffice for this
scheme also to attain  relative error.

\subsection{Polynomial fitting}\label{sec:polynomialFit}
A natural question is if {\it additional structure in } can be non-trivially exploited
to further accelerate the running time of -regression. Given that  is structured,
perhaps we can run in time even faster than . This was studied in \cite{asw13,anw14},
and we shall present the result in \cite{asw13}. 

Perhaps one of the oldest
regression problems is polynomial fitting. In this case, given a set of samples 
, for , we would like to
choose coefficients  of a degree- univariate polynomial
 which best fits our samples. Setting this up as a regression
problem, the corresponding matrix  is  and is a {\it Vandermonde matrix}.
Despite the fact that  may be dense, we could hope to solve regression in time faster
than  using its Vandermonde structure. 

We now describe the problem more precisely, starting with a definition. 

\begin{definition}(Vandermonde Matrix) Let  be real numbers. The Vandermonde matrix,
denoted , has the form:

\end{definition}

Vandermonde matrices of dimension  require only 
implicit storage and admit  matrix-vector multiplication time (see, e.g., Theorem 2.11 of \cite{Tang2004}). 
It is also possible to consider block-Vandermonde matrices as in \cite{asw13}; for simplicity
we will only focus on the simplest polynomial fitting problem here, in which Vandermonde
matrices suffice for the discussion. 

We consider regression problems of the form , or the approximate version,
where we would like to output an  for which 

We call this the {\it -Polynomial Fitting Problem}.

\begin{theorem}(-Polynomial Fitting)\cite{asw13}\label{thm:FastVand}
There is an algorithm that solves the -Polynomial Fitting Problem
in time . By
combining sketching methods with preconditioned iterative solvers, we can
also obtain logarithmic dependence on .  
\end{theorem}
Note that since  and the running time of Theorem \ref{thm:FastVand}
is , this provides a sketching approach that operates faster than ``input-sparsity'' time. It
is also possible to extend Theorem \ref{thm:FastVand} to -regression, see \cite{asw13} for details. 

The basic intuition behind Theorem \ref{thm:FastVand} is to try to compute  for
a sparse embedding matrix . Naively, this would take  time. However, since  contains
a single non-zero entry per column, we can actually think of the product  as
 {\it vector-matrix products} , where  is the vector
with coordinates  for which , and  is the row-submatrix of 
consisting only of those rows  for which .  To compute each of these vector-matrix products,
we can now appeal to the fast matrix-vector multiplication algorithm associated with Vandermonde matrices, which
is similar to the Fast Fourier Transform. Thus, we can compute each  in time proportional
to the number of rows of , times a factor of . In total we can compute all matrix-vector
products in  time, thereby computing , which we know is an -subspace
embedding. We can also compute  in  time, and now can solve the sketched problem
 in  time. 

\section{Least Absolute Deviation Regression}\label{chap:robust}
While least squares regression is arguably the most used form of regression in practice, it
has certain non-robustness properties that make it unsuitable for some applications. For
example, oftentimes the noise in a regression problem is drawn from a normal distribution, in 
which case least squares regression would work quite well, but if there is noise due to 
measurement error or a different underlying noise distribution, the least squares 
regression solution may overfit this noise since the cost function squares each of its 
summands. 

A more robust alternative is least absolute deviation regression, or -regression, 
. The -norm
is much less well-behaved than the -norm, e.g., it is not invariant under rotation,
not everywhere differentiable, etc. There is also no closed-form solution for an
-regression problem in general, as a special case of it is the geometric median
or Fermat-Weber problem, for which there is no closed form solution. 

Nevertheless, -regression is much less sensitive to outliers. It is also the maximum
likelihood estimator (MLE) when the noise in the regression problem is i.i.d. Laplacian of
zero median. In this section we will focus on recent advances in solving -regression
using sketching. To do so, we first describe a sampling-based solution. We note that many of the
results in this section generalize to -regression for . See 
\cite{CW13,MM13,wz13} for works on this. This general line of work was introduced by
Clarkson \cite{Cla05}, though our exposition will mostly follow that of \cite{DDHKM09} and the
sketching speedups built on top of it \cite{sw11,CDMMMW13,MM13,wz13}. 

{\bf Section Overview:} In \S\ref{sec:sampling-Based} we show how one can adapt the idea of leverage score sampling in \S\ref{sec:leverage} for  to provide an initial sampling-based algorithm for -regression. In \S\ref{sec:l1Subspace} we introduce the notion of a subspace embedding for the -norm and show how if we had such an object, it could be used in the context of -regression. We postpone one technical detail in this application to \S\ref{sec:gaussian}, which shows how to combine -subspace embeddings together with Gaussian sketching to make the technique of using -subspace embeddings in \S\ref{sec:l1Subspace} efficient. In \S\ref{sec:cauchy} we turn to the task of constructing -subspace embeddings. We do this using Cauchy random variables. This leads to an -regression algorithm running in . In \S\ref{sec:exponential} we then speed this up even further by replacing the dense matrix of Cauchy random variables in the previous section with a product of a sparse -subspace embedding and a diagonal matrix of exponential random variables. This leads to an overall time of . Finally, in \S\ref{sec:hyperplane} we discuss one application of -regression to -Hyperplane Approximation. 

\subsection{Sampling-Based solution}\label{sec:sampling-Based}
One of the most natural ways of solving a regression problem is by sampling. Let us augment
the  design matrix  in the regression problem to an  matrix
by including the  vector as the -st column. 

Let . 
Suppose we form a submatrix of  by including each row of  in the submatrix independently
with probability . Let us write this as , where  is a diagonal  matrix
with  if row  was included in the sample, and  otherwise. Then
, and so for any fixed , . 

What we would like is that for all 

that is, 
 is an oblivious subspace embedding for . Note that although  is an 
matrix, in expectation it has only  non-zero rows, and so we can throw away
all of the zero rows. It follows that if  is small,
one could then afford to directly solve the {\it constrained} regression problem:

using linear programming. This would now take time , which is a significant savings over
solving the problem directly, e.g., if  is much smaller or independent of . Note that the constraint
 can be directly incorporated into a linear program for solving this problem, and only
slightly increases its complexity. 

We are left with the task of showing (\ref{eqn:l1ose}). To do so, fix a particular vector
. Define the random variable , so that for ,
we have . We would like to understand how large each  can be, and
what the variance of  is. We would like these quantities to be small, which at first glance
seems hard since  cannot depend on . 

One way of bounding  is to write  for an  matrix  and
a  change of basis matrix . Since  does not depend on any particular
vector , one could hope to define  in terms of  for a particularly good choice of basis
 for the column space of . Note that one has

where the inequality follows by H\"older's inequality. 

A natural choice at this point to bound the RHS of (\ref{eqn:bound}) is to define
, where recall  is about the expected
number of rows we wish to sample (the expected number of rows sampled may be less than  since  is a 
probability and so is upper-bounded by ). For later purposes, it will be helpful to instead
allow 
 
where 
can be thought of as a relaxation parameter which will allow for more
efficient algorithms. 

Note that for those  for which 
, 
the -th row  will always be included
in the sample, and therefore will not affect the variance of the sampling process. 

Let us now consider those  for which 
. For such  
one has

where  and 

In order for  to never be too large, 
we would like to choose a  so that  and  are as small as possible. This
motivates the following definition of a well-conditioned basis for the -norm. For ease of notation,
let . 

\begin{definition}(Well-conditioned basis for the -norm)\label{def:wcb}(see \cite{DDHKM09})
Let  be an  matrix. An  matrix  is an -well conditioned
basis for the column space of  if (1) , and (2) for all ,
. 
\end{definition}
Note that our definition of  and  above coincide with that in Definition \ref{def:wcb},
in particular the definition of , 
since  by definition of  and . 

Fortunately, well-conditioned bases with  exist and can be efficiently computed. We
will sometimes simply refer to  as a well-conditioned basis if  and  are both bounded by .
That such bases exist is due to a theorem of Auerbach \cite{a30,ak08}, 
which shows that  and  suffice. 
However,
we are not aware of an efficient algorithm which achieves these values. The
first efficient algorithm for finding a well-conditioned basis is due to Clarkson \cite{Cla05}, 
who achieved a running time of . 
The same running time was achieved by 
Dasgupta et al. \cite{DDHKM09}, who improved the concrete values of  and . 
We will see that one can in fact compute such bases much faster using sketching techniques below, but let us first
see how these results already suffice to solve -regression in  time. 

Returning to (\ref{eqn:wcb}), we have the bound

Using this bound together with independence of the sampled rows, 

We have computed  and bounded  as well as , 
and can now use strong tail bounds to bound the deviation of
 from its expectation. We use the following tail inequalities.

\begin{theorem}[Bernstein inequality \cite{m03}]
\label{thm:bernstein}
Let  be independent random variables with 
, and define
. 
Then, for any ,

Moreover, if  for all , we have

\end{theorem}
Plugging our bounds into \ref{thm:bernstein}, we have

and also

Setting  
for a large enough polynomial in  allows us to conclude that for any fixed ,

While this implies that  is a -approximation with high probability for a fixed , 
we now need an argument for all .
To prove that  
for all , it suffices to prove the statement for all 
for which  for some  and . 
Indeed, since  is a linear map, it will follow that 
for all  by linearity. 

Let . We seek a finite subset of
, denoted , which is an -net, 
so that if  for all , then
it implies that  for all . The argument will be similar
to that in \S\ref{sec:se} for the  norm, though the details are different. 

It suffices to choose  so that for all , 
there exists a vector  for which .
Indeed, in this case note that 

If , we are done. Otherwise, suppose  is such that . 
Observe that , since,  yet . 

Then , and we can
choose a vector  for which , or equivalently,
. Hence,

Repeating this argument, we inductively have that 

By a similar argument, we also have that

Thus, by rescaling  by a constant factor, we have that  
for all vectors . 

\begin{lemma}\label{lem:eps-net}
There exists an -net  for which . 
\end{lemma}
\begin{proof}
For a parameter  and point , 
define 
Then  is a -dimensional polytope with a (-dimensional) volume denoted . 
Moreover, 
 and  are similar polytopes, namely, . 
As such, . 

Let  be a maximal subset of  in the column space of  for which  and 
for all , . Since  is maximal, it follows that for all 
,
there exists a vector  for which . 
Moreover, for all , 
 and  are disjoint, 
as otherwise by the triangle inequality, , a contradicition. 
It follows by the previous paragraph that  can contain at most  points. 
\end{proof}

By applying (\ref{eqn:tail}) and a union bound over the points in , and rescaling  by a constant factor, we have thus
shown the following theorem.
\begin{theorem}\label{thm:slow}
The above sampling algorithm is such that with probability at least , simultaneously for all ,
. The expected number of non-zero rows of  is at most . The 
overall time complexity is , where  is the time to compute a well-conditioned basis. Setting
 suffices. 
\end{theorem}

\subsection{The Role of subspace embeddings for L1-Regression}\label{sec:l1Subspace}
The time complexity of the sampling-based algorithm for -Regression in the previous section is dominated by the computation of 
a well-conditioned basis. In this section we will design subspace embeddings with respect to the -norm and show how they 
can be used to speed up this computation. Unlike for , the distortion of our vectors in our subspace will not be , but
rather a larger factor that depends on . Still, the distortion does not depend on , and this will be sufficient for our applications. This
will be because, with this weaker distortion, we will still be able to form a well-conditioned basis, and then we can apply 
Theorem \ref{thm:slow} to obtain a -approximation to -regression. 

\begin{definition}(Subspace Embedding for the -Norm)
We will say a matrix  is an -subspace embedding for an  matrix 
 if there are constants  so that for all ,

and  has at most  rows. 
\end{definition}
Before discussing the existence of such embeddings, let us see how they can be used to speed up the computation of a well-conditioned basis.
\begin{lemma}\label{lem:wcbse}(\cite{sw11})
Suppose  is an -subspace embedding for an  matrix . Let  
be a QR-decomposition of , i.e.,  has orthonormal
columns (in the standard  sense) and . Then  
is a -well-conditioned basis.
\end{lemma}
\begin{proof}
We have 

Recall we must bound , where  is minimal for which for all ,
. We have

and so . 
\end{proof}
Note that  is a  matrix, and therefore its QR decomposition can be computed in  time. One can also
compute  in  time, which could be sped up with fast matrix multiplication, though we will see a better way
of speeding this up below. By Lemma \ref{lem:wcbse}, provided  is a subspace embedding for  with constants , 
is a -well-conditioned basis, and so we can improve
the time complexity of Theorem \ref{thm:slow} to , 
where  is the time to compute the matrix-matrix
product . 

We are thus left with the task of producing an -subspace embedding for . 
There are many ways to do this non-obliviously \cite{l78,s87,blm89,t90,js03}, 
but they are slower than the time bounds we can achieve using
sketching. 

We show in \S\ref{sec:cauchy} that by using sketching we can achieve 
, which illustrates several main ideas and improves upon Theorem \ref{thm:slow}. 
We will then show how to improve
this to  in \S\ref{sec:exponential}. 
Before doing so, let us first see how, given  for which 
is well-conditioned, we can 
improve the  time for computing a representation of 
 which is sufficient to perform the sampling in Theorem \ref{thm:slow}. 

\subsection{Gaussian sketching to speed up sampling}\label{sec:gaussian}
Lemma \ref{lem:wcbse} shows that if  is an -subspace embedding for an  matrix , 
and  is a QR-decomposition of , then  is a well-conditioned basis.

Computing , on the other hand, naively takes  time. 
However, observe that to do the sampling
in Theorem \ref{thm:slow}, we just need to be able to compute the probabilities , for , where recall

where , and  
is the well-conditioned basis. This is where  comes in to the picture.

Instead of computing the matrix product  directly, one can choose a  matrix
 of i.i.d.  random variables, for  
and first compute . This matrix can be 
computed in  time and only has  columns, and so now 
computing  
can be computed in  time. By choosing
the parameter  of Lemma \ref{lem:jl} we have
for all , that  Therefore,
 and
also 
It follows that for 

we have that (\ref{sampleBound}) holds with . 

We note that a tighter anaylsis is possible, in which  need only have  columns, as shown 
in \cite{CDMMMW13}. 

\subsection{Subspace embeddings using cauchy random variables}\label{sec:cauchy}
The Cauchy distribution, having density function 
, 
is the unique -stable distribution.
That is to say, if  are independent Cauchys, then 
 is distributed as a Cauchy scaled by
.

The absolute value of a Cauchy distribution has density function .
The cumulative distribution function  of it is

Note also that since , we have , so that  is the median of this distribution. 

Although Cauchy random variables do not have an expectation, and have infinite variance, some control over them can be
obtained by clipping them. The first use of such a truncation 
technique in algorithmic applications that we are aware of
is due to Indyk \cite{i06}. 

\begin{lemma}\label{lem:truncated}
Consider the event  that a Cauchy random variable  satisfies
, for some parameter . Then there is a constant  for which 
 and 
where  is an absolute constant.  
\end{lemma}
\begin{proof}

Hence, for , 

where the final bound uses (\ref{eqn:condition}). 
\end{proof}
We will show in Theorem \ref{thm:l1embed} below 
that a matrix of i.i.d. Cauchy random variables is an -subspace embedding. Interestingly, we will use the existence of a
well-conditioned basis in the proof, though we will not need an algorithm for constructing it. This lets us use well-conditioned bases with
slightly better parameters. In particular, we will use the following Auerbach basis.

\begin{definition}(see ``Connection to Auerbach bases'' in Section 3.1 of \cite{DDHKM09})\label{thm:auerbach}
There exists a -well-conditioned basis. 
\end{definition}

For readability, it is useful to separate out the following key lemma that is used in Theorem \ref{thm:l1embed} below.
This analysis largely follows that in \cite{sw11}. 
\begin{lemma}\label{lem:key}(Fixed Sum of Dilations)
Let  be an  matrix of i.i.d. Cauchy random variables, and let  be  arbitrary vectors
in . Then 

where  is an absolute constant. 
\end{lemma}
\begin{proof}
Let the rows of  be denoted . 
For , let  be the event that 

where  is a sufficiently large positive constant. Note that by the -stability of the Cauchy distribution,
 is distributed as  times a Cauchy random variable. 
By Lemma \ref{lem:truncated} applied to , together with a union bound, we
have 
Letting , we have by another union bound that


Given , we would then like to appeal
to Lemma \ref{lem:truncated} to bound the expectations . 
The issue
is that the expectation bound in Lemma \ref{lem:truncated} cannot be applied, since the condition
 additionally conditions  through the remaining columns  
for . A first observation
is that by independence, we have

We also know from Lemma \ref{lem:truncated} that if  is the event that
, then 
, where  is the constant
of that lemma.

We can perform the following manipulation (for an event , we use the notation
 to denote the occurrence of the complement of ):

We also have 

and . Combining these two, we have

for  a sufficiently large constant. Plugging (\ref{eqn:depend}) into the above,

or equivalently, 

as desired. 

We thus have, combining (\ref{eqn:below}) with Markov's inequality,

As  can be chosen sufficiently large, while  is the fixed constant of Lemma \ref{lem:truncated},
we have that

The lemma now follows by appropriately setting the constant  in the lemma statement. 
\end{proof}

\begin{theorem}\label{thm:l1embed}
A matrix  
of i.i.d. Cauchy random variables with 
 rows is an -subspace embedding with constant probability, that is,
with probability at least  simultaneously 
for all , 
\end{theorem}
\begin{proof}
Since we will show that with probability , for all  we have 
 we are free to
choose whichever basis of the column space of  that we like. 
In particular, we can assume the  columns  
of  form an Auerbach basis. We will first bound the dilation, and then bound the contraction.
\\\\
{\bf Dilation:}
We apply Lemma \ref{lem:key} with  for . 
We have with probability at least ,

where the last equality used that  is an Auerbach basis. 

Now let  be an arbitrary vector in the column space of . Then,

where the third inequality uses (\ref{eqn:apply}) and the fourth inequality uses a property of 
 being a -well-conditioned 
basis. It follows that , as needed in the statement of the theorem.
\\\\
{\bf Contraction:} 
We now argue that no vector's norm shrinks by more than a constant factor. 
Let  be an arbitrary vector in the column space of . By the -stability of the Cauchy distribution, 
each entry of  is distributed as a Cauchy scaled by . 

Since the median of the distribution of the absolute value of a Cauchy random variable is , we have that with 
probability at least , . Since the entries of  are independent, 
it follows by a Chernoff bound that the probability that fewer than a  fraction
of the entries are smaller than  is at most . Hence, with probability ,
 is at least , or equivalently, . 

We now use a net argument as in \cite{sw11}. By Lemma \ref{lem:eps-net},
there exists an -net  
for which  and for any  with , 
there exists a  with
. Observe that for a sufficiently
large  number of rows of , we have by a union bound, that with probability
, simultaneously for all , 
. 

For an arbitrary  with , we can write  for a  and 
. 
By the triangle inequality,  

Since we have already shown that  for all , it follows
that 

It follows now that  for all vectors  with . 

Hence, the statement of the theorem holds with probability at least , by a union bound over the events in the 
dilation and contraction arguments. This concludes the proof. 
\end{proof}

\begin{corollary}\label{cor:first}
There is an  time algorithm for solving the -regression problem
up to a factor of  and with error probability . 
\end{corollary}
\begin{proof}
The corollary follows by combining Theorem \ref{thm:slow}, Lemma \ref{lem:wcbse} and its optimization in
\S\ref{sec:gaussian}, and 
Theorem \ref{thm:l1embed}. Indeed, we can compute  in  time, then a QR-factorization as
well as  in  time. Then we can compute  as well as perform
the sampling in Theorem \ref{thm:slow} in  time. Finally, we can solve the -regression
problem on the samples in  time. 
\end{proof}
While the time complexity of Corollary \ref{cor:first} can be improved to roughly
 using algorithms for fast matrix multiplication, there are better
ways of speeding this up, as we shall see in the next section. 

\subsection{Subspace embeddings using exponential random variables}\label{sec:exponential}
We now describe a speedup over the previous section using exponential random variables, as in \cite{wz13}. Other
speedups are possible, using \cite{CDMMMW13,CW13,MM13}, though the results in \cite{wz13} additionally also 
slightly improve the sampling complexity. The use of exponential random variables in \cite{wz13} is inspired
by an elegant work of Andoni, Onak, and Krauthgamer on frequency moments \cite{AKO11,Andoni12}. 

An exponential distribution has support , probability density function 
 and cumulative distribution function . 
We say a random variable  is exponential if  is chosen from the exponential distribution. 
The exponential distribution has the following max-stability property.
\begin{property}
\label{prop:exp}
If  are exponentially distributed, and  are real numbers, then 
,
where  is exponential.
\end{property}
The following lemma shows a relationship between the Cauchy distribution and the exponential distribution. 
\begin{lemma}
\label{lem:tail-squared}
Let  be scalars. 
Let  be  independendent exponential random variables, 
and let . Let  be  independent Cauchy
random variables, and let . 
There is a constant  for which for any . 

\end{lemma}
\begin{proof}
We would like the density function  of . Letting , the inverse function is . Taking the derivative,
we have . Letting  be the density function of the absolute value of a Cauchy random variable,
we have by the change of variable technique,

We would also like the density function  of , where . Letting , the inverse function is . Taking
the derivative, . Letting  be the density function of the reciprocal of an exponential random variable,
we have by the change of variable technique,

We claim that  for a sufficiently small constant . This is equivalent to showing that

which for , is implied by showing that

We distinguish two cases: first suppose . In this case, . Note also that 
 in this case. Hence,
. Therefore, the above is implied by showing

or 

which holds for a sufficiently small constant . 

Next suppose . In this case , and it suffices to show

or equivalently,

Using that  for , it suffices to show

which holds for a small enough . 

We thus have,

where we made the change of variables . Setting  completes the proof. 
\end{proof}
We need a bound on , where  is 
as in Lemma \ref{lem:tail-squared}.

\begin{lemma}\label{lem:cauchy-l2}
There is a constant  so that for any ,

\end{lemma}
\begin{proof}
For , let  be i.i.d. random variables with . 
Let . We will obtain tail bounds for  in two different ways, and use this to establish
the lemma.

On the one hand, by the -stability of the Cauchy distribution, we have that , where  is a standard
Cauchy random variable. Note that this holds for any fixing of the . The cumulative distribution function
of the Cauchy random variable is  Hence for any ,

We can use the identity 

and therefore using the Taylor series for  for ,

Hence,

On the other hand, for any fixing of , we have

and also 

We recall the Paley-Zygmund inequality.
\begin{fact}
If  is a random variable with finite variance, and , then

\end{fact}
Applying this inequality with  and , we have

or equivalently 

Suppose, towards a contradiction, that  for a sufficiently large constant . By independence of the  and the , by
(\ref{eqn:applyPZ}) this implies

By (\ref{eqn:upper}), this is a contradiction for . It follows that , as desired. 
\end{proof} 

\begin{corollary}\label{cor:upper}
Let  be scalars. 
Let  be  independendent exponential random variables, 
and let . There is a constant  for which for any ,

\end{corollary}
\begin{proof}
The corollary follows by combining Lemma \ref{lem:tail-squared} with Lemma \ref{lem:cauchy-l2}, and rescaling the constant  from Lemma \ref{lem:cauchy-l2}
by , where  is the constant of Lemma \ref{lem:tail-squared}. 
\end{proof}


\begin{theorem}\label{thm:expWork}(\cite{wz13})
Let  be an  CountSketch matrix with , and  an  diagonal matrix
with i.i.d. entries  distributed as a reciprocal of a standard exponential random variable. 
Then, with probability at least  simultaneously for all ,

\end{theorem}
\begin{proof}
By Theorem \ref{thm:nn}, with probability at least  over the choice of , 
 is an -subspace embedding for the matrix , 
that is, simultaneously for all ,
. We condition  on this event.

For the dilation, we need Khintchine's inequality.
\begin{fact}\label{fact:khintchine}(\cite{h81}). 
Let  for i.i.d. random variables 
uniform in , and  be scalars. 
There exists a constant  for which for all 

\end{fact}
Let  be  vectors in an Auerbach basis for the column
space of . 
Applying Fact \ref{fact:khintchine} to a fixed entry  of  for a
fixed , and letting  denote the vector whose -th coordinate
is  if , and otherwise , 
we have for a constant , 

By a union bound, with probability 
 for all  and ,

which we denote by event  and condition on. 
Notice that the probability is taken only over
the choice of the , and therefore conditions only the  random variables. 

In the following,  and . 
Let  be the event that 

We also
define 
By Corollary \ref{cor:upper} and union bounds,

and union-bounding over , 

We now bound 
By independence, 

Letting , 
we have by Corollary \ref{cor:upper},

We can perform the following manipulation:

It follows by linearity of expectation that,

Consequently, by a Markov bound, and using that , 
conditioned on , with probability at least , we have the
occurrence of the event 
that 

To bound the dilation, consider a fixed vector .
Then conditioned on ,
and for  
an Auerbach basis (without loss of generality),

where the first inequality follows from the triangle inequality,
the second inequality uses that  for a
well-conditioned basis , the third inequality uses 
(\ref{eqn:dilate}), and in the fourth inequality  is a
sufficiently large constant. Thus for all ,


For the contraction, we have

where  is a standard exponential random variables, and 
where the first inequality uses our conditioning on , the second inequality uses a standard norm inequality, and
the third inequality uses the max-stability of the exponential distribution. Thus, since the cumulative distribution
of an exponential random variable , we have that for any fixed ,
 
By Lemma \ref{lem:eps-net}, there exists a -net  for which ,
where  is a subset of 
. Combining this with (\ref{eqn:tailExp}), by a union bound we have the event  that 
simultaneously for all 
, 

Now consider an arbitrary vector  of the form  
with . By definition of , one can
write , where  and . We have,

where the first inequality uses the triangle inequality, the second the occurrence of , and the third
(\ref{eqn:dilateFinal}). This completes the proof. 
\end{proof}
\begin{corollary}\label{cor:second}
There is an  time algorithm for computing , where 
 is a 
by  matrix satisfying, with probability at least , 
 for all . Therefore, there is also
an  time algorithm for solving the -regression problem
up to a factor of  with error probability . 
\end{corollary}
\begin{proof}
The corollary follows by combining Theorem \ref{thm:slow}, Lemma \ref{lem:wcbse} and its optimization 
in \S\ref{sec:gaussian}, and 
Theorem \ref{thm:expWork}. 
\end{proof}

\subsection{Application to hyperplane fitting}\label{sec:hyperplane}
One application of -regression is to finding the best hyperplane to find a 
set of  points in , presented as an  matrix  
\cite{bd09L1,bdb10,kk03,kk05,sw11,CDMMMW13}. 
One seeks
to find a hyperplane  so that the sum of -distances of the rows  to
 is as small as possible. 

While in general, the points on  are those  for which ,
where  is the normal vector of  and , we can in fact assume that 
. Indeed, this follows by increasing the dimension  by one, placing the value  on
all input points in the new coordinate, and placing the value  on the new coordinate in . As
this will negligibly affect our overall time complexity, we can therefore assume  in what
follows, that is,  contains the origin. 

A nice feature of the -norm is that if one grows an -ball around a point ,
it first touches a hyperplane  at a vertex of the -ball. Hence, there is a coordinate
direction  for which the point of closest -distance to  on  is obtained by
replacing the -th coordinate of  by the unique real number  so that 
 is on . 

An interesting observation is that this coordinate direction  only depends on , that is,
it is independent of , as shown in Corollary 2.3 of \cite{m97}. Let  denote the matrix
 with its -th column removed. Consider a hyperplane  with normal vector . Let 
denote the vector obtained by removing its -th coordinate. Then the
sum of -distances of the rows  of  to  is given by

since  is the negation of the vector of -th coordinates of the points projected
(in the  sense) onto , using that  
for  on the hyperplane. It follows that an optimal
hyperplane  can be obtained by solving

which characterizes the normal vector  of . Hence, by solving  -regression problems,
each up to a -approximation factor and each on an  matrix, 
one can find a hyperplane whose cost is at most  times the cost of the optimal hyperplane.

One could solve each of the  -regression problems independently up to -approximation with error
probability , each taking  time. This would lead to
an overall time of , but we can do better by reusing computation. 

That is, it suffices to compute a subspace embedding  once, using Corollary \ref{cor:second}, which
takes only  time. 

For the subspace approximation problem, we can write

Thus, having computed  once, one can solve the subspace approximation problem with an
additional  amount of time. We summarize our findings in the following theorem. 

\begin{theorem}(-Hyperplane Approximation)
There is an  time algorithm for solving the -Hyperplane
approximation problem with constant probability. 
\end{theorem}

\section{Low Rank Approximation}\label{chap:lowRank}
In this section we study the low rank approximation problem. We are given
an  matrix , and would like to find a matrix 
for which 

where  is the best rank- approximation to  with respect to some
matrix norm, and  has rank . 

Low rank approximation can be used for a variety of problems, such as
Non-Negative Matrix Factorization (NNMF)~\cite{seung2001algorithms}, 
Latent Dirichlet Allocation (LDA)~\cite{blei2003latent}, and face recognition. 
It has also recently been used for -error shape-fitting
problems~\cite{dan2013tiny}, such as -means and projective clustering. 

Here we demonstrate an application to latent semantic analysis (LSA). We define a {\it term-document}
matrix  in which the rows correpond to terms (e.g., words) and columns correspond to documents. The entry
 equals the number of occurrences of term  in document . Two terms  and  can be regarded 
as correlated
if the inner product  of their corresponding rows of  is large. The matrix
 contains all such inner products. Similarly, one can look at document correlation by looking at .
By writing  in its SVD, we have . 

By taking the SVD of low rank approximation  to a matrix , 
one obtains , where
 and  have orthonormal columns, 
and  is a rank- matrix. One can view the columns of  and  as approximations
to the top  left and right singular vectors of .  Note that, as we will see below, the algorithm for generating
 usually generates its factorization into the product of , , and  
so one does not need to perform
an SVD on  (to achieve  time algorithms for low rank approximation, one
cannot actually afford to write down  other than in factored form, since  may be dense). 

There are two well-studied norms in this context, the Frobenius
and the spectral (operator) norm, both of which have the same minimizer 
 given by the singular value decomposition of . That is, if one
writes  in its SVD, where  and  are orthonormal
and  is a non-negative diagonal matrix with 
, 
then , where  agrees with  on its
top  diagonal entries, but is  otherwise. Clearly this is a rank-
matrix, and the Eckart-Young Theorem guarantees that it is the minimizer
for any rotationally-invariant norm, which includes the Frobenius and
spectral norms. The top  rows of  are known as the top  principal 
components of . 

We will show how
to use sketching to speed up algorithms for both problems, and further variants.
Our exposition is based on combinations of several works in this area by S\'arlos,
Clarkson, and the author \cite{S06,CW09,CW13}. 

{\bf Section Overview:} In \S\ref{sec:frobenius} we give an algorithm for computing a low rank approximation achieving error proportional to the Frobenius norm. In \S\ref{sec:CUR} we give a different kind of low rank approximation, called a CUR decomposition, which computes a low rank approximation also achieving Frobenius norm error but in which the column space equals the span of a small subset of columns of the input matrix, while the row space equals the span of a small subset of rows of the input matrix. A priori, it is not even clear why such a low rank approximation should exist, but we show that it not only exists, but can be computed in nearly input sparsity time. We also show that it can be computed deterministically in polynomial time. This algorithm requires several detours into a particular kind of spectral sparsification given in \S\ref{sec:bss}, as well as an adaptive sampling technique given in \S\ref{sec:adaptiveSampling}. Finally in \S\ref{sec:CURWrapup} we show how to put the pieces together to obtain the overall algorithm for CUR factorization. One tool we need is a way to compute the best rank- approximation of the column space of a matrix when it is restricted to lie within a prescribed subspace; we defer the details of this to \S\ref{sec:dislra}, where the tool is developed in the context of an application called Distributed Low Rank Approximation. In \S\ref{sec:spectral} we show how to perform low rank approximation with a stronger guarantee, namely, an error with respect to the spectral norm. While the solution quality is much better than in the case of the Frobenius norm, it is unknown how to compute this as quickly, though one can still compute it much more quickly than the SVD. In \S\ref{sec:dislra} we present the details of the Distributed Low Rank Approximation algorithm.

\subsection{Frobenius norm error}\label{sec:frobenius}
We will say a -dimensional subspace of  spans a 
 rank- approximation to  if 

where  is the projection operator onto that subspace. We will
sometimes abuse notation and refer to  as the subspace as well,
meaning the -dimensional subspace of  spanned
by the rows of . 

One way of interpreting the Frobenius low rank problem is to treat each
of the  rows of  as a point in . A 
particularly nice property about the Frobenius norm is that if one is given
a subspace  of  which is guaranteed to contain a
rank- subspace  spanning a  rank-
approximation to , then it can be found by projecting each of the
rows of  onto , and then finding the best rank- approximation
to the projected points inside of . This is a simple, but very useful
corollary of the Pythagorean theorem.

\begin{lemma}\label{lem:pythagorean}
The best rank- approximation to  in Frobenius norm in the row space
of a matrix  with orthonormal rows is given by , where 
 denotes the best rank- approximation to .
\end{lemma}
\begin{proof}
Let  be an arbitrary matrix of rank  of the same dimensions as . Then,

where the equalities use that the rows of  are orthonormal, while the 
inequality uses that  is the best rank- approximation to . 

Hence, 

where the equalities use the Pythagorean theorem and the inequality uses
the bound above. It follows that the best rank- approximation to  in the rowspace of 
is . 
\end{proof}

The following lemma shows how to use sketching to find a good space . For a matrix
, if its SVD is , then the Moore-Penrose pseudoinverse  of 
is equal to , where  for a diagonal matrix 
satisfies  if , and is  otherwise. 
\begin{lemma}\label{lem:sketching}
Let  be an -subspace embedding for any fixed -dimensional subspace  
with probability at least , so that
 for all . Further, suppose  satisfies
the -JL moment property for some  of Definition \ref{def:moment}, so
that the conclusion of Theorem \ref{thm:jlamp} holds, namely, that for any fixed matrices  and  each with 
 rows, 

Then the rowspace of  contains a  rank- approximation to . 
\end{lemma}
\begin{remark}
An example of a matrix  having both properties as required by the lemma 
is a sparse embedding matrix with
 rows, as follows by Theorem \ref{thm:mmnn} and Theorem \ref{thm:tz}. One
can also use a matrix  of i.i.d. normal random variables with  rows, 
which follows by Theorem
\ref{thm:gaussianSE} and Theorem \ref{thm:jlamp}; for the latter one needs to show that Definition
\ref{def:moment} is satisfied. Also, the product of subspace embeddings is a 
a subspace embedding, and one can show the product of a sparse embedding matrix with
a matrix of i.i.d. normal random variables satisfies Theorem \ref{thm:jlamp}. One advantage of
using the product is that one obtains fast time complexity as well as  overall rows.
See, e.g., \cite{CW13}, where the product of a sparse embedding matrix with the Subsampled
Randomized Hadamard Transform was used. 
\end{remark}
\begin{proof}
Let  denote the  matrix of top  left singular vectors of . 
Consider the quantity

The goal is to show (\ref{eqn:central}) is at most . Note that this
implies the lemma, since  is a rank- matrix inside of the
rowspace of . 

Since the columns of  are orthogonal to the columns of , by the matrix
Pythagorean theorem (applied to columns),

where the second equality uses that the columns of  are orthonormal, and that . 

It suffices to show 
. We use 
that , where 
 is the rank of , the columns of  correspond to the bottom  left singular vectors, while the rows of 
correspond to the bottom  right singular vectors. Hence, it suffices to show
. Now, , and so it suffices to show
.

Note that  and  have the same row space, namely , 
and so we can
write  where  is a  change of basis matrix (of full rank). Hence, it 
is equivalent to show 


We seek an upper bound on , or equivalently a lower bound on . Since 
 has full row rank, we can find an  for which , where
 is the right singular vector of  of minimum singular value. 

With probability at least ,  is an -subspace embedding for the column space
of , that is  for all . 
Since  has orthonormal columns,
this implies that all of the singular values of  are in the range .
Hence, the singular values of
 are in , so we can choose the  above so that . It follows that
. But ,
and so . 
The minimum singular value of  is at least , and so , or
equivalently . Returning to (\ref{eqn:fixBlah}), it suffices to show
.

Since  satisfies the conclusion of Theorem \ref{thm:jlamp}, with probability at least ,

Rescaling  by a constant factor completes
the proof. 
\end{proof}
Lemma \ref{lem:pythagorean} and Lemma \ref{lem:sketching} give a natural way of using sketching to 
speed up low rank approximation. 
Namely, given , first compute , which is a small number of random linear combinations
of the rows of . Using efficient -subspace embeddings, this can be done in  time,
and  need only have  rows. 
Next, compute an orthogonal basis  for the rowspace of , 
which can be done in 
time. 

Next, compute  in  time. 
By invoking Lemma \ref{lem:pythagorean}, we can now compute , and our
overall low rank approximation will be , which is a -approximation. Note that
we can compute the SVD of  in  time, thereby giving us . This allows us
to obtain the SVD  of  in this amount of time as well. 
We don't require
explicitly outputting the product of  and , since this may be a dense matrix and so would
require at least  time to write down. In applications, it is usually better to have a factored form.
Notice that  has orthonormal rows, since  
is the identity.
Therefore, we can output , which is the SVD of a rank-
matrix providing a -approximation. 

The overall time of the above algorithm is . While this is a significant
improvement over computing the SVD of , which would take  time, we could still
hope to achieve a leading order running time of  as opposed to . The dominant
cost is actually in computing , 
the coordinate representation of the rows of  in the rowspace of . That
is, it is inefficient to directly project the rows of  onto . 

Fortunately, we can cast this projection problem as a regression problem, and solve it approximately. 
\begin{theorem}\label{thm:lowrank}
Now let  be a -approximate -subspace embedding for the row space of , where 
is as in Lemma \ref{lem:sketching}. Then  Furthermore, 
 
where  is the projection
matrix onto the rowspace of . 

The time to compute the factorizations 
 or 
, , , 
,
is . Note that in general one can only hope to output
the factorizations in this amount of time, as performing the actual multiplications of the 
factors of the low rank approximation may result in a dense
 matrix. 
\end{theorem}
\begin{proof}
Lemma \ref{lem:sketching} implies that 

The minimizer
of the regression problem  
is equal to , and since  is a subspace
embedding we have 

implying the first part of the theorem after rescaling  by a constant factor. 

For the second part of the theorem, note that Lemma \ref{lem:sketching} gives the stronger guarantee that

By the properties of an -subspace embedding, we thus have if  is the solution to the regression
problem

then 

Therefore, it suffices to find . Note that  is the best rank- approximation to  in the rowspace
of . Therefore, by Lemma \ref{lem:pythagorean}, , where  is the projector onto
the row space of . Note that  since  has fewer rows than columns, and therefore
 
For the time complexity, the dominant cost is in computing  and , 
both of which can be done in  time. 
The remaining operations are on matrices for which at least one dimension is , and therefore can be computed
in  time. 
\end{proof}
While the representation  in Theorem \ref{thm:lowrank} 
might be useful in its own right as a low rank approximation to , given
it is technically a bicriteria solution since its rank may be ,
whereas the original problem formulation wants our representation to have rank at most . 
The second part of Theorem \ref{thm:lowrank}
gives a rank- approximation. 

\subsection{CUR decomposition}\label{sec:CUR}
We now give an alternative to low rank approximation which involves finding a decomposition of an  matrix 
into , where  is a subset of columns of ,  is a subset of rows of 
, and  is a low rank matrix. 
Ideally, we would like the following properties:
\begin{enumerate}
\item 
\item  is  for a small value of . Similarly,  is  for a small value of .
\item  has rank .
\item The matrices , , and  can be found quickly, ideally in  time. 
\end{enumerate}
A CUR decomposition of a matrix is thus a rank- approximation whose column space and row space are spanned by a small subset of 
actual rows and columns
of . This often makes it more interpretable than a generic low rank approximation, or even the SVD, whose column and row spaces are
spanned by arbitrary linear combinations of all of the columns and rows of , respectively, see, e.g., \cite{MD09} for a discussion
of this. 

Before discussing the details of some of the available CUR algorithms in~\cite{DK03,DKM06c,DMM08,DM09,GM13,WZ13CUR,BW14}, we briefly mention a 
similar problem
which constructs factorizations of the form , where  contains columns of  and  has rank at
most . There are also optimal algorithms for this problem~\cite{BDM11a,GS12}, in both the spectral and the Frobenius norm. Indeed, to
obtain a relative-error optimal CUR, one uses a sampling method from~\cite{BDM11a}, which allows to select  columns and rows.
For a more detailed discussion of this CX problem, which is also known as CSSP (Column Subset Selection Problem) see~\cite{BMD09a,BDM11a,GS12}.

Drineas and Kannan brought CUR factorizations to the theoretical computer science community in~\cite{DK03}; we
refer the reader to the jounral version of their work together with Mahoney \cite{DKM06c}. 
Their main algorithm (see Theorem 5 in \cite{DKM06c}) 
is randomized and samples columns and rows from  with probabilities proportional
to their Euclidean length. The running time of this algorithm is linear in  and  and proportional to a
small-degree polynomial in  and  for some ,
but the approximation bound is additive rather than relative 
(see Theorem 3.1 in~\cite{DK03}): with  columns and  rows
the bound is 


The first relative-error CUR algorithm appeared in~\cite{DMM08} (see Theorem 2 of \cite{DMM08}). The
algorithm of~\cite{DMM08} is based on subspace sampling and requires 
 columns and
 rows to construct a relative-error CUR with failure probability .
The running time of the method in~\cite{DMM08} is , since subspace sampling is based on sampling with probabilities
proportional to the so-called leverage scores, i.e., the row norms of the matrix  from the SVD of .

Mahoney and Drineas~\cite{DM09}, using again subspace sampling, improved slightly upon the number of columns and rows,
compared to~\cite{DMM08}, but achieved only a constant factor error (see Eqn.(5) in~\cite{DM09}).
Gittens and Mahoney~\cite{GM13} discuss CUR decompositions on symmetric positive semidefinite (SPSD) 
matrices and present approximation bounds for Frobenius,
trace, and spectral norms (see Lemma 2 in~\cite{GM13}).
Using the near-optimal column subset selection methods in~\cite{BDM11a} along with a novel adaptive sampling technique, Wang and Zhang~\cite{WZ13CUR} present a CUR
algorithm selecting

columns and

rows from 
(see Theorem 8 in~\cite{WZ13CUR}).
The running time of this algorithm is

Boutsidis and the author \cite{BW14} improve this to achieve a simlutaneously optimal , and rank. 
This in fact is optimal up to constant factors, as shown by \cite{BW14} by presenting a matching lower bound. 
Boutsidis and the author also show how to do this in  time. 
There is also some desire to make the CUR decomposition deterministic. 
We will see that this is possible as well, as shown in \cite{BW14}. 

Finally, there are several interesting results on CUR developed within 
the numerical linear algebra community~\cite{Tyr96, Tyr00, GTZ97a, GTZ97b,HP97, Pan03, MG03, GM04,BPSS05,Ste99}.
For example,~\cite{Tyr96, Tyr00, GTZ97a, GTZ97b} discuss the so-called skeleton approximation, which focuses on the spectral norm
version of the CUR problem via selecting exactly  columns and  rows. The algorithms there are deterministic, run
in time proportional to the time to compute the rank  SVD of , and achieve bounds of the order,


We now outline the approach of Boutsidis and the author \cite{BW14}. A key lemma we need is the following, which
is due to Boutsidis, Drineas, and Magdon-Ismail \cite{BDM11a}. 
\begin{lemma}
\label{lem:structural}
Let  
be a low-rank matrix factorization of , with 
and .
Let  () be any matrix such that 
Let . Then,

Here,  
where  has rank at most , 
 is the
best rank  approximation to  in the column space of , and  denotes the Moore-Penrose 
pseudoinverse of .
\end{lemma}
\begin{proof}
First note that 
 since  is the projection of the columns of  onto the column
space of , whereas  is the best rank- approximation to  in the column space of . 

For the second inequality in the lemma statement, 
the main idea in the proof is to consider the matrix . 
Since this matrix is in the column space
of , we have 

since  is the best rank- approximation to  inside the column space of . 

Manipulating , we have that  is equal to 

where the first equality uses that  and that , 
the second equality is a rearrangement of terms,
the third equality uses that rank and so , 
and the last equality follows from
the Pythagorean theorem since  
has rows orthogonal to the row space of , while 
 has rows in the row space of . Finally, noting that 

by submultiplicativity, and that , completes the proof. 
\end{proof}
We will apply Lemma \ref{lem:structural} twice, and adaptively. First, we compute an  matrix  with
orthonormal columns for which . 
This can be done in 
time as shown in the second part of Theorem \ref{thm:lowrank} of the previous section. Specifically, from the statement of that theorem,
for an  matrix , the column space of  spans a  rank- approximation to , where
 satisfies . We can apply that theorem to  to obtain a 
matrix  which spans a  rank- approximation to . 

Given , we will sample  columns of  proportional to the squared row norms, or leverage scores of .
Let  be the -th leverage score. 
Since , the  values
define a probability distribution. 

We now invoke the {\textsc RandSampling} algorithm of
Definition \ref{def:lss} with . By the guarantee of Theorem \ref{thm:lssPerf},
we obtain matrices  and  for which with probability , for all ,

Here  implements sampling  columns of  and re-scaling them by the coefficients
in the diagonal matrix . We also record the following simple fact about the {\textsc RandSampling}
algorithm.
\begin{lemma}\label{lem:FrobLSS}
With probability at least  over the randomness in the algorithm {\textsc RandSampling},

\end{lemma}
\begin{proof}
We show . 
By linearity of expectation, it suffices to show for a fixed column ,
 We have, 

as needed. The lemma now follows by Markov's bound. 
\end{proof}

Our algorithm thus far, is given , to compute , and then to compute  and  via
{\textsc RandSampling}, 
where . At this point, we could look at , which
samples  columns of . While this set of columns can be shown to have good properties, namely, 
its column space contains a -dimensional subspace spanning an  rank- approximation to , which can then
be used as a means for obtaining a -approximation by adaptive sampling, as will be seen in 
\S\ref{sec:adaptiveSampling}. However, the number of columns is , which would result in an overall
CUR decomposition with at least  columns and rows using the techniques below, 
which is larger by a  factor than what we would like (namely,  columns and rows). 

We therefore
wish to first downsample the  columns of  we have now to  columns by right-multiplying by a matrix 
, so that  
has rank  and has a reasonably large -th singular
value. 

To proceed, we need an algorithm in the next subsection, 
which uses a method of Batson, Spielman, and Srivastava \cite{BSS09}
refined for this application by Boutsidis, Drineas, and Magdon-Ismail \cite{BDM11a}.

\subsubsection{Batson-Spielman-Srivastava sparsification}\label{sec:bss}
Define
the parameters

Define the function

Note that  measures how far the eigenvalues of  are from , since the closer they
are to , the more  ``blows up''. 

Also, define the functions

and


These two functions will be used in each iteration of Algorithm \ref{alg1} below to make progress in each iteration. 
What we will be able to show is that in each iteration of the algorithm, the current value of our potential function  will be less 
than the current value of our potential function , and this will enable us to choose a new vector  and add  
in our decomposition of the identity. This corresponds to a rank-one update of our current decomposition , 
and we use the Sherman-Morrison-Woodbury formula to analyze how the eigenvalues of  change, as well as how
the values of  and  change, given this rank-one update. 

\begin{algorithm}[t]
\caption{Deterministic Dual Set Spectral Sparsification}
\label{alg1}
{\bf Input:} 
\begin{itemize}
\item  with 
\item . 
\end{itemize}
{\bf Output:}
A set of  non-negative weights , at most  of which are non-zero. 
\begin{enumerate}
\item Initialize , 
\item For 
\begin{itemize}
\item Set  and . 
\item Find an index  such that
. 
\item Let . 
\item Update the -th component of  and :

\end{itemize}
\item Return .
\end{enumerate}
\end{algorithm}
The following theorem shows correctness of 
the Deterministic Dual Set Spectral Sparsification algorithm
described in Algorithm \ref{alg1}. 

\begin{theorem}(Dual Set Spectral-Frobenius Sparsification)
\label{thm:dualset}
Let  for  with , and
. Let  be an arbitrary set
of vectors, where  for all . Then,
given an integer  such that , 
there exists a set of weights  (), 
at most  of which are non-zero, such that
\eqan{
\lambda_{k}\left(\sum_{i=1}^n s_i \ve_i \ve_i^T\right)
&\ge&
\left(1 - \sqrt{\frac{k}{r}}\right)^2,
\qquad \\
\trace\left(\sum_{i=1}^n s_i \a_i\a_i^T\right)
&\le&
\trace\left(\sum_{i=1}^n \a_i \a_i^T\right)
=
\sum_{i=1}^n \| \a_i\|_2^2.
}
Equivalently,
if  is a matrix whose rows are the vectors ,
 is a matrix whose rows are the vectors , and
 is the sampling matrix containing the weights  then:
\eqan{
\sigma_{k}\left(\matV^T \matS\right)
\ge
(1 - \sqrt{{k}/{r}})^2,
\qquad
\FNormS{\matA^T \matS}
\le \FNormS{\matA^T}.
}
The weights  can be computed in  time. We denote this procedure as

\end{theorem} 
\begin{proof}
First, regarding the time complexity, 
in each of  iterations we need to compute  on each of the  vectors . The costly matrix
inversion in the definition of  can be performed once in  time, which also upper bounds
the time to compute  and . Given these quantities, 
computing  for a single vector  takes  time and so for all  vectors 
 time, and across all  iterations,  time. Computing 
just corresponds to computing the Euclidean norm of , and these can be computed once at the
beginning of the algorithm in  time. This implies the overall time complexity of the lemma.

We now turn to correctness. The crux of the analysis turns out to be 
to show there always exists an index 
in each iteration for which 
 

For a real symmetric matrix  we let  denote 
its -th largest eigenvalue of matrix . It will be 
useful to observe that for  and  as defined by the algorithm, we have chosen the
definitions so that  and . 

We start with a lemma which uses the 
Sherman-Morrison-Woodbury identity to analyze a rank- perturbation. 
\begin{lemma}\label{lem:bss}
Fix , , , and . If
 satisfies  
then 
\begin{enumerate}
\item  and
\item . 
\end{enumerate} 
\end{lemma}
\begin{proof}
Note that by definition of , given that , 
and , this implies that , and so
for any , . This proves the first part of the lemma.

For the second part, we use the following well-known formula.
\begin{fact}(Sherman-Morrison-Woodbury Formula)
If  is an invertible  matrix and  is an -dimensional vector, then

\end{fact}

Letting , we have

where the first equality uses the definition of , the second equality
uses the Sherman-Morrison Formula, the third equality uses that the trace is a linear operator
and satisfies , 
the fourth equality
uses the definition of  and that the trace of a number is the number itself, the fifth
equality follows by rearranging terms, and the final inequality follows by assumption
that . 
\end{proof}
We also need the following lemma concerning properties of the  function.  
\begin{lemma}\label{lem:U}
Let  be a symmetric positive semi-definite matrix, let 
 be a vector, and let  satisfy . If  
satisfies  
then

\end{lemma}
\begin{proof}
By the assumption of the lemma, 

or equivalently, . Hence, 

\end{proof}
Equipped with Lemma \ref{lem:bss} and Lemma \ref{lem:U}, we now prove the main lemma we need.

\begin{lemma}\label{lem:sandwich}
At every iteration , there exists an index 
for which 

\end{lemma}
\begin{proof}
It suffices to show that

Indeed, if we show (\ref{eqn:average}), then by averaging there must exist an index  for which

We first prove the equality in (\ref{eqn:average}) using the definition of . Observe that
it holds that 

We now prove the inequality in (\ref{eqn:average}). Let  denote the -th
largest eigenvalue of . 
Using that  and ,
we have

where

We will show  below. Given this, we have

where the inequality uses Lemma \ref{lem:bss}. Since , we 
have 

which will complete the proof. 

We now turn to the task of showing . The Cauchy-Schwarz inequality implies
that for , one has , 
and therefore

Since  and we have computed above that , 
we have 
since . 

Also, 

Plugging into (\ref{eqn:E}), we conclude that , as desired. 
\end{proof}

By Lemma \ref{lem:sandwich}, the algorithm is well-defined, finding a  at each iteration
(note that  since ). 

It follows by Lemma \ref{lem:bss} and induction that for every , we have . 
Similarly, by
Lemma \ref{lem:U} and induction, for every  it holds that . 

In particular, for  we have

and

Rescaling by  in Step 3 of the algorithm therefore results in the guarantees on 
and  claimed in the theorem statement. 

Finally, note that Algorithm \ref{alg1} runs in  steps. 
The vector  of weights is initialized to the all-zero 
vector, and one of its entries is updated in each iteration. Thus,  will contain at most 
non-zero weights upon termination. As shown above, the value  chosen in each iteration 
is non-negative, so the weights in  are non-negative.

This completes the proof. 
\end{proof}

We will also need the following corollary, which shows how to perform the dual set sparsification much more
efficiently if we allow it to be randomized. 

\begin{corollary}\label{lem:dualnnz}
Let \math{\cl V=\{\ve_1,\ldots,\ve_n\}} be a decomposition of the identity, where \math{\ve_i\in \mathbb{R}^{k}} () and
; let \math{\cl A=\{\a_1,\ldots,\a_n\}} be an arbitrary set
of vectors, where \math{\a_i\in\mathbb{R}^{\ell}}. Let  be a randomly chosen
sparse subspace embedding with , for some . 
Consider a new set of vectors  \math{\cl B = \{\matW\a_1,\ldots, \matW\a_n\}},
with \math{\matW\a_i \in \mathbb{R}^{\xi}}. Run Algorithm \ref{alg1} with \math{\cl V=\{\ve_1,\ldots,\ve_n\}},
\math{\cl B = \{\matW\a_1,\ldots, \matW\a_n\}}, and some integer \math{r} such that \math{k < r \le n}. Let the output
of this be a set of weights \math{s_i\ge 0} (), at most \math{r} of which are non-zero. 
Then, with probability at least 
\eqan{
\lambda_{k}\left(\sum_{i=1}^ns_i \ve_i \ve_i^T\right)
&\ge&
\left(1 - \sqrt{\frac{k}{r}}\right)^2,
\qquad\\
\trace\left(\sum_{i=1}^n s_i \a_i \a_i^T\right)
&\le&
\frac{1 + \varepsilon }{1 - \varepsilon} \cdot
\trace\left(\sum_{i=1}^n \a_i \a_i^T\right) \\
&=&
\frac{1 + \varepsilon }{1 - \varepsilon} \cdot
\sum_{i=1}^n \TNormS{\a_i}.
}
Equivalently,
if  is a matrix whose rows are the vectors ,
 is a matrix whose rows are the vectors ,
 is a matrix whose rows are the vectors ,
and
 is the sampling matrix containing 
the weights  then with probability at least 
\eqan{
\sigma_{k}\left( \matV^T \matS\right)
\ge
1 - \sqrt{{k}/{r}},
\qquad
\FNormS{\matA^T\matS}
\le
\frac{1 + \varepsilon }{1 - \varepsilon} \cdot
\FNormS{\matA}.
}
The weights  can be computed in  time. We denote this procedure as

\end{corollary}
\begin{proof}
The algorithm constructs  as follows,

The lower bound for the smallest singular value of  is immediate from Theorem~\ref{thm:dualset}. That theorem also ensures,
 
i.e.,

Since  is an -subspace embedding, we have that with probability at least  
and for all vectors  simultaneously,

Apply this  times for  being columns from  
and take a sum on the resulting inequalities,

Now, since  is an -subspace embedding, 

which can be seen by applying  to each of the vectors . 
Combining all these inequalities together, we conclude that with probability at least 

\end{proof}

\paragraph{Implications for CUR.} 
Returning to our CUR decomposition algorithm, letting  where
 and  are found using {\textsc RandSampling}, we apply 
Corollary \ref{lem:dualnnz} to compute 
{\textsc BssSamplingSparse},
where  is determined by writing  in its SVD as . 

At this point we set  which contains 
 rescaled columns of . 

\begin{lemma}\label{lem:conk}
With probability at least , 

\end{lemma}
\begin{proof}
We apply Lemma \ref{lem:structural} with  and 
. First, we show that with probability , 
the rank assumption of Lemma \ref{lem:structural} is satisfied for our choice of , namely, that 
rank. We have 

where the first two equalities follow from the definitions, the third equality follows assuming the 
event of (\ref{eqn:rank1}) that , and the last equality follows from
the fact that Corollary \ref{lem:dualnnz} guarantees that with probability at least ,
. 

Now applying Lemma \ref{lem:structural} with the  there equal
to  and the  there equal to , we have

We have that  is
at most
\eqan{
&\buildrel(a)\over\le& \FNormS{\matE_1 \matOmega_1 \matD_1 \matS_1} \cdot \TNormS{(\matZ_1\matOmega_1 \matD_1 \matS_1)^{\dagger}} \\
&\buildrel(b)\over=  & \FNormS{\matE_1 \matOmega_1 \matD_1 \matS_1} \cdot \TNormS{(\matU_{\matM} \matSig_{\matM} \matV_{\matM}\transp \matS_1)^{\dagger}} \\
&\buildrel(c)\over=  & \FNormS{\matE_1 \matOmega_1 \matD_1 \matS_1} \cdot \TNormS{ \left(\matV_{\matM}\transp \matS_1\right)^{\dagger} \left( \matU_{\matM} \matSig_{\matM} \right)^{\dagger}} \\
&\buildrel(d)\over\le& \FNormS{\matE_1 \matOmega_1 \matD_1 \matS_1} \cdot \TNormS{ \left(\matV_{\matM}\transp \matS_1\right)^{\dagger}} \cdot \TNormS{ \left( \matU_{\matM} \matSig_{\matM} \right)^{\dagger}}  \\
&\buildrel(e)\over=  & \FNormS{\matE_1 \matOmega_1 \matD_1 \matS_1}  \cdot \frac{1}{ \sigma_k^2\left(\matV_{\matM}\transp \matS_1\right)}  \cdot \frac{1}{ \sigma_k^2\left( \matU_{\matM} \matSig_{\matM} \right)} \\
&\buildrel(f)\over\le & \FNormS{\matE_1 \matOmega_1 \matD_1 \matS_1} \cdot 8 \\
&\buildrel(g)\over\le&  \FNormS{\matE_1 \matOmega_1 \matD_1} \cdot 8 \\
&\buildrel(h)\over\le& 80 \FNormS{\matE_1}
}
where
(a) follows by the sub-multiplicativity property of matrix norms,
(b) follows by replacing ,
(c) follows by the fact that  is a full rank  matrix
assuming the  probability event of (\ref{eqn:rank1})
(d) follows by the sub-multiplicativity property of matrix norms,
(e) follows by the 
connection of the spectral norm of the pseudo-inverse with the singular values of the matrix to be pseudo-inverted,
(f) follows if the  event of (\ref{eqn:rank1}) occurs and the probability  event of 
Corollary \ref{lem:dualnnz} occurs, 
(g) follows by Corollary \ref{lem:dualnnz}, and
(h) follows by Lemma~\ref{lem:FrobLSS} and by adding a  to the overall failure probability.
So, overall with probability at least 

Hence,
with the same probability,

By our choice of , 
Hence, with probability at least ,

\end{proof}

Lemma \ref{lem:conk} gives us a way to find  columns providing an -approximation. We would like
to refine this approximation to a -approximation using only an additional  number of columns.
To do so, we perform a type of residual sampling from this -approximation, as described in the next section.

\subsubsection{Adaptive sampling}\label{sec:adaptiveSampling}
Given  columns providing a constant factor approximation, we can sample  additional 
columns from their ``residual'' to obtain a -approximation. This was shown in the following
lemma of Deshpande, Rademacher, Vempala, and Wang. It is actually more general in the sense that the matrix 
in the statement of the theorem need not be a subset of columns of . 

\begin{theorem}[Theorem 2.1 of~\cite{DRVW06}]
\label{thm:adaptivecolumns}
Given  and  (with ),
define the residual

For , and some fixed constant   let  be a probability distribution such that for each 

where  is the -th column of the matrix . Sample
 columns from  in \math{c_2} i.i.d. trials, where in each trial the -th column is chosen with probability .
Let  contain the  sampled columns and let 
contain the columns of  and . Then, for any integer ,

We denote this procedure as

Given  and  the above algorithm requires  arithmetic operations to find .
\end{theorem}
Rather than prove Theorem \ref{thm:adaptivecolumns} directly, we will prove the following theorem of Wang and Zhang 
which generalizes
the above theorem. One can think
of the following theorem as analyzing the deviations of  from an
arbitrary space - the row space of , that occur via sampling additional
columns according to the residual from a given set of columns. These columns
may have nothing to do with . This therefore generalizes the result
of Deshpande and Vempala which considered  to be the top  right singular
vectors of  (we will make this generalization precise below). 
\begin{theorem}[Theorem 4 in~\cite{WZ13CUR}]
\label{thm:adaptiverows}
Given  and a matrix  such that 

with 
we let  consist of  columns of  
and define the residual 

For  let  be a probability distribution such that for each 

where  is the -th column of . Sample
 columns from  in \math{c_2} i.i.d. trials, 
where in each trial the -th column is chosen with probability .
Let  
contain the  sampled columns and let .
Then,

We denote this procedure as

Given   
the above algorithm requires  arithmetic operations to find .
\end{theorem}
\begin{proof}
Write  in its SVD as . 
The key to the proof is to define the following matrix

where  is the -th singular value of  with corresponding
left singular vector . The  are random
column vectors which will depend on the sampling and have certain desirable properties described
below.  

To analyze the expected error of the algorithm with respect to the choices made in the sampling
procedure, we have

where the second equality uses the Pythagorean theorem. 

One property of the  we will ensure below is that the  each lie in the span of the columns
of . Given this, we have

Plugging (\ref{eqn:close}) into (\ref{eqn:open}), we have

where note that  is deterministic so we can remove the expectation. 

Let  be the right singular vectors of . As both the rows of
 and of  lie in the span of , we can decompose
(\ref{eqn:combined}) as follows:

where the final equality follows from the fact that  is, by definition, in the row space of , 
and so 
Looking at (\ref{eqn:ultimate}), it becomes clear what the properties of the  are that we want. Namely, 
we want them to be in the column space of  and to have the property that 
is as small as possible. 

To define the  vectors, we begin by defining auxiliary random variables ,
for  and :

with probability , for . 
We have that  is a deterministic linear combination of a random column sampled from the distribution
defined in the theorem statement. Moreover,

and

We now define the average vector

and we have

and

where (\ref{eqn:variance}) follows from the fact that the samples are independent. In fact, pairwise independence
suffices for this statement, which we shall use in our later derandomization of this theorem
(note that while for
fixed , the  are pairwise independent, for two different  we have that  
and  are dependent). 

Notice that  is in the span of the columns of , for every .
This follows since  is a multiple of a column in . 

For , we now define

and we also have that  are in the column space of , as required above. It remains
to bound  as needed for (\ref{eqn:ultimate}). 

We have

where (\ref{eqn:relation}) together with (\ref{eqn:w}) imply that

At long last we have

Plugging (\ref{eqn:varBound}) into (\ref{eqn:ultimate}), we obtain

which completes the proof. 
\end{proof}

\subsubsection{CUR wrapup}\label{sec:CURWrapup}
\paragraph{Obtaining a Good Set of Columns.}
We will apply 
Theorem \ref{thm:adaptivecolumns} with the  
of that theorem set to . For the distribution , we need
to quickly approximate the column norms of 
. To do so, 
by Lemma \ref{lem:jl}
it suffices
to compute , where  is an 
matrix of i.i.d.  random variables, for . By
Lemma \ref{lem:jl}, with probability at least , simultaneously
for all , 

where  is the -th column of . It follows that we
can set  in Theorem \ref{thm:adaptivecolumns} using
the distribution  on  given by

Hence, for a parameter , if we set

if , where  are the columns sampled by 

then by the conclusion of Theorem \ref{thm:adaptivecolumns}, 

By Lemma \ref{lem:conk}, with probability at least , 
, 
which we condition on. It follows by setting , then 
taking expectations with respect to the randomness
in  we have


\paragraph{Running Time.}
A few comments on the running time are in order. We can compute  in
 time via Theorem \ref{thm:lowrank}. Given , we
can run {\textsc RandSampling}, where  and  is the leverage
score distribution defined by . This can be done in  time. 

We then run 
{\textsc BssSamplingSparse}.
To do this efficiently, we can't afford to explicitly compute the matrix
. 
We only form   and  in  time. 
Then, {\textsc BssSamplingSparse} multiplies 

from the left with a sparse subspace embedding matrix  with 
. Computing  takes  time.
Then, computing  and  takes another 
 +  time, respectively. Finally, the sampling algorithm on
 is  time.

Given  and  we then know the matrix  needed to run
 The latter algorithm samples columns of ,
which can be done in  time given the distribution  to sample from. Here to find
 we need to compute , where  and  is 
an  matrix. We can compute this matrix product in time . 

It follows that the entire procedure to find  is  time. 

\paragraph{Simultaneously Obtaining a Good Set of Rows.}
At this point we have a set  of  columns of  for which

If we did not care about running time, we could now find the best -dimensional subspace of the columns of
 for approximating the column space of , that is, if  has orthonormal columns with the
same column space as , then by Lemma \ref{lem:pythagorean},

where  denotes the best rank- approximation to  in Frobenius norm. So if
 is an  matrix with orthonormal columns with the same column space as 
, we could then attempt to execute the analogous algorithm to the one that 
we just ran. That algorithm was for finding a good
set of columns  starting with , and now we would like to find a good set  of rows 
starting with . This is the proof strategy used by Boutsidis and the author in \cite{BW14}. 

Indeed, the algorithm of \cite{BW14} works by first sampling  rows of  according
to the leverage scores of . It then downsamples this to  rows using {\textsc BssSamplingSparse}. Now,
instead of using Theorem \ref{thm:adaptivecolumns}, the algorithm invokes Theorem \ref{thm:adaptiverows}, applied to
, to find  rows. 

Applying Theorem \ref{thm:adaptiverows} to , the error has the form:

where  is the rank of . Note that had we used  here in place of ,  could be ,
and then the number  of samples we would need in (\ref{eqn:rows}) would be , which is more than
the  columns and  rows we could simultaneously hope for. It turns out that these procedures
can also be implemented in  time.

We glossed over the issue of how to find the best -dimensional subspace  of the columns of  for approximating
the column space of , as described above. Na\"ively doing this would involve projecting the columns of 
onto the column space of , which is too costly. Fortunately, by Theorem \ref{thm:kv}
in \S\ref{sec:dislra}, 
in  time it is 
possible to find an  matrix  with orthonormal columns so that

Indeed, Theorem \ref{thm:kv} implies that if  is an -subspace embedding, then we can take
 to be the top  left singular vectors of , and since  has rank ,
this matrix product can be computed in  time using sparse subspace embeddings.  
We can thus use  in place of  in the algorithm for selecting a subset of  rows of . 

\paragraph{Finding a  With Rank .}
The above outline shows how to simultaneously obtain a matrix  and a matrix  with  columns
and rows, respectively. Given such a  and a , we need to find a rank- matrix  which is the
minimizer to the problem

We are guaranteed that there is such a rank- matrix  since crucially, when we apply 
Theorem \ref{thm:adaptiverows}, we apply it with , which has rank . Therefore, the resulting
approximation  is a rank- matrix, and since  is in the span
of , can be expressed as . It turns out one can quickly find , as shown in \cite{BW14}. We omit the details. 

\paragraph{Deterministic CUR Decomposition.}
The main idea in \cite{BW14} 
to achieve a CUR Decomposition with the same  columns and rows and a rank- matrix 
deterministically is to derandomize Theorem \ref{thm:adaptivecolumns} and Theorem \ref{thm:adaptiverows}. The 
point is that the proofs involve the second moment method, and therefore by a certain discretization
of the sampling probabilities, one can derandomize the algorithm using pairwise-independent samples (of either columns
or rows, depending on whether one is derandomizing Theorem \ref{thm:adaptivecolumns} or Theorem \ref{thm:adaptiverows}). This
increases the running time when applied to an  matrix  to , 
versus, say,  using
other deterministic algorithms such as the SVD, but gives an actual subset of rows and columns. 

\subsection{Spectral norm error}\label{sec:spectral}
Here we show how to quickly obtain a  rank-k approximation with respect to the spectral norm
. That is, given an  matrix , compute a rank-
matrix , where . 

It is well-known that , where  is the -st singular
value of , 
and that  is the matrix , where  is the SVD of  and
 is a diagonal matrix with first  diagonal entries equal to those of , and  otherwise. 

Below we present an algorithm, proposed by Halko, Martinsson and Tropp \cite{HMT}, that was shown 
by the authors to be a bicriteria
rank- approximation. That is, they efficiently find an  matrix  with orthonormal columns for which
 . By slightly modifying their analysis, 
this matrix  can be shown to have dimensions  with the same error 
guarantee. 
The analysis of this algorithm was somewhat simplified by
Boutsidis, Drineas, and Magdon-Ismail \cite{BDM11a}, and by slightly modifying their analysis, this results in an 
 matrix  with orthonormal
columns for which . 
We follow the analysis of \cite{BDM11a}, but 
simplify and improve it slightly in order to output 
a true rank- approximation, that is, an  matrix  with orthonormal columns for which 
. This gives us a new result
which has not appeared in the literature to the best of our knowledge. 

Before presenting the algorithm, we need the following lemma. 
Suppose we have an  matriz  with orthonormal
columns for which there exists an  for which . How do we find
such an ? It turns out the optimal such  is equal to .

\begin{lemma}\label{lem:kinside}
If we let , then  
satisfies . 
\end{lemma} 
\begin{proof}
On the one hand, , since  is the minimizer. On the other hand,
for any vector , by the Pythagorean theorem, 

and so . 
\end{proof}
We also collect a few facts about the singular values of a Gaussian matrix. 
\begin{fact}(see, e.g., \cite{RV10})\label{fact:gaussian}
Let  be an  matrix of i.i.d. normal random variables with mean  and variance . 
There exist constants  for which

(1) The maximum singular value  satisfies  with
probability at least . 

(2) If , then the minimum singular value  satisfies 
 with probability at least .
\end{fact}

The algorithm, which we call {\sf SubspacePowerMethod} is as follows. The intuition is, like
the standard power method, if we compute  for a 
random vector , then for large
enough  this very quickly converges to the top left singular vector of . If we instead
compute  for a random  matrix , for large
enough  this also very quickly converges to an  matrix which is close, in a certain
sense, to the top  left singular vectors of . 
\begin{enumerate}
\item Compute  and , where  
is an  matrix of i.i.d.  random variables.
\item Let  be an  matrix with orthonormal columns whose column space is equal to that of .
\item Output . 
\end{enumerate}

In order to analyze {\sf SubspacePowerMethod}, we need a key lemma shown in \cite{HMT} concerning powering of a matrix.
\begin{lemma}\label{lem:tropp}
Let  be a projection matrix, i.e.,  for a matrix  with orthonormal columns. For any matrix  of
the appropriate dimensions and integer ,

\end{lemma}
\begin{proof}
Following \cite{HMT}, we first show that if  is a projection matrix and  a non-negative diagonal matrix,
then . To see this, suppose  is a unit vector for which
. We can assume that , as otherwise since  is a projection matrix,
, and taking the unit vector , we have

contradicting that . We thus have,

where we have used Jensen's inequality to show that , noting
that  and the function  is convex.

Given this claim, let  be a decomposition of 
in which  and  are square matrices with orthonormal columns and rows, 
and  has non-negative entries on the diagonal (such a decomposition can be obtained
from the SVD). Then,

where the first equality follows since ,
the second equality uses that  and rotational
invariance given that  has orthonormal rows and columns, the first inequality
uses the claim
above with , the next equality uses that , the next equality regroups terms, and the final equality
writes the operator norm as the equivalent squared operator norm. 

If we raise both sides to the -th power, then this completes the proof. 
\end{proof}
We can now prove the main theorem about {\sf SubspacePowerMethod}
\begin{theorem}\label{thm:tropp}
For appropriate , 
with probability at least , {\sf SubspacePowerMethod} outputs a rank- matrix  for which
.
Note that {\sf SubspacePowerMethod} can be implemented in  time. 
\end{theorem}
\begin{proof}
By Lemma \ref{lem:kinside},  is the best rank- approximation of  in the column space of 
with respect to the spectral norm. Hence, 

where the inequality follows since  is of rank  and in the column space of . Since
 is a projection matrix, we can apply Lemma \ref{lem:tropp} to infer that  is at most
 , which is
equal to
 
where we use that  since  has orthonormal columns, and thus

Hence, 


Let  be the SVD of . Let 
and , where  denotes the top  rows of , and  the remaining
 rows. Since the rows of  are orthonormal, by rotational invariance of the Gaussian distribution,
 and  are independent matrices of i.i.d.  entries. 

We now apply Lemma \ref{lem:structural} with the  of that lemma equal to  above, the  of that
lemma equal to , and the  of that lemma equal to  above. This implies the  of that
lemma is equal to . Note that to apply the lemma we need  to have full rank, which holds with probability
 since it is a  matrix of i.i.d.  random variables. We thus have, 

where  denotes the  diagonal matrix whose entries are the bottom  diagonal
entries of , and  denotes the rightmost  columns of . Here 
in the second equality we use unitary invariance of , while in the inequality we use
sub-multiplicativity of the spectral norm. By Fact \ref{fact:gaussian} and independence of  and
, we have that  and 
with probability at least . Consequently for a constant , 

Combining (\ref{eqn:bBound}) with (\ref{eqn:abound}), we have

Noting that , and setting  so that
 completes the proof
\end{proof}

\subsection{Distributed low rank approximation}\label{sec:dislra}
In this section we study an algorithm for distributed low rank approximation. The model is called the 
{\it arbitrary partition model}. In this model there are  players (also called servers), 
each locally holding an  
matrix , and we let . We would like for each player to obtain a rank- projection
matrix , for which 

The motivation is that each player can then locally project his/her matrix  by computing 
. It is often useful to have such a partition of the original input matrix . For instance,
consider the case when a customer coresponds to a row of , and a column to his/her purchase of a specific item. 
These purchases could be distributed across servers corresponding to different vendors. The communication is point-to-point,
that is, all pairs of players can talk to each other through a private channel for which the other  players do not
have access to. The assumption is that , though  is still large, so having communication independent of 
and as small in  as possible is ideal. In \cite{kvw14} an  bit communication lower bound was shown. 
Below we show an algorithm of Kannan, Vempala, and the author \cite{kvw14} using  words of communication, 
assuming a word is  bits and the entries of each  are -bit integers. 

We first show the following property about the top  right 
singular vectors of  for a subspace
embedding , as shown in \cite{kvw14}. The property shows that 
the top  right singular
vectors  of  provide a 
-approximation to the best rank- approximation
to . This fact quickly follows from the fact that 
 for the bottom  right singular vectors
 of . It is crucial that  is an -subspace
embedding for , as otherwise there is a dependency issue since 
the vectors  depend on . 

\begin{theorem}\label{thm:kv}
Suppose  is an  matrix. Let  be an  matrix for which
 for all , that is,
 is a subspace embedding for the column space of . Suppose
 is a  matrix which projects vectors in  onto the space of
the top 
singular vectors of . Then

\end{theorem}
\begin{proof}
Form an orthonormal basis of  using the right singular vectors of . Let
 be the basis.

where the first equality follows since  is an orthonormal basis
of ,
the inequality follows using the fact that 
for all , and the final equality follows using that the 
are the right singular vectors of . 

Suppose now  is an orthonormal basis consisting of the singular vectors
of . Then, we have

where the first inequality uses that the rank- matrix  is no better
at approximating  than , the first equality uses that
 is an orthonormal basis of , the second inequality uses
that  for all , 
and the final equality uses that  are the right singular vectors of . 

Thus,

and the theorem follows.
\end{proof}
We will also need a variant of Lemma \ref{lem:sketching} from Section \ref{chap:lowRank}
which intuitively states that for a class of random matrices , if we project
the rows of  onto the row space of , we obtain a good low rank approximation.   
Here we use an  matrix  in which each of the
entries is  or  with probability , 
and the entries of  are -wise independent. We
cite a theorem of Clarkson and Woodruff \cite{CW09} which shows what we need.
It can be shown by showing the following properties:
\begin{enumerate}
\item  is an -subspace embedding for any fixed -dimensional subspace with probability at least , and
\item  has the -JL moment property for some  (see Definition \ref{def:moment}). 
\end{enumerate}
\begin{theorem}\label{thm:sketch}(combining Theorem 4.2 and the second part of Lemma 4.3 of \cite{CW09})
Let  be a random sign matrix with  in which
the entries are -wise independent.
Then with probability at least , if  is the  projection matrix onto the row space of ,
then if  is the best rank- approximation to matrix , we have

\end{theorem}
The main algorithm {\sc AdaptiveCompress} of \cite{kvw14} is given in Algorithm 
{\sf AdaptiveCompress} below.  

Here we state the key idea behind Theorem \ref{thm:low-rank-arbitrary} below. The idea is that
if each of the servers projects their matrix  to  using an 
subspace embedding , then  and by Theorem
\ref{thm:kv}, if we compute the top  right singular vectors of , we can send
these to each server to locally project their data on. Since  is more efficient
to communicate than , this provides a considerable improvement in communication. However,
the communication is proportional to  and we can make it proportional to only  
by additionally using Theorem \ref{thm:sketch} to first ``replace'' the  matrices
with  matrices, where the columns of  are an orthonormal basis
containing a  rank- approximation. 

\begin{algorithm}[p]
\caption{The {\sf AdaptiveCompress}(,,) protocol}
\begin{enumerate}
\item Server  chooses a random seed for an  sketching matrix  
as in Theorem \ref{thm:sketch},
given parameters  and , where  is a small positive constant.
It communicates the seed to the other servers.
\item Server  uses the random seed to compute , and then , 
and sends it to Server .
\item Server  computes . It computes an 
orthonormal basis  for the row space of , and sends  to all the servers.
\item Each server  computes . 
\item Server 1 chooses another random seed for a  matrix  
which is to be -wise independent and communicates this seed to all servers.
\item The servers then agree on a subspace embedding matrix  of Theorem \ref{thm:kv} 
for , 
where  is an  matrix which can be described with  bits.
\item Server  computes  and send it to Server .
\item Server  computes . 
It computes , which is an  projection 
matrix onto the top  singular vectors of , and sends  to all the servers.
\item Server  outputs . 
Let .  is not computed explicitly.
\end{enumerate}
\end{algorithm}

\begin{theorem}\label{thm:low-rank-arbitrary}
Consider the arbitrary partition model where an  matrix  resides in server  and the data matrix
.
For any , there is a protocol {\sc AdaptiveCompress} that, on termination, leaves an
 matrix  in server  such that the matrix  
with arbitrarily large constant probability achieves

using linear space, polynomial time and with total communication complexity  real numbers.
Moreover, if the entries of each 
are  bits each, then the total communication is  words each consisting of  bits.
\end{theorem}
\begin{proof}
By definition of the {\sc AdaptiveCompress} protocol, we have 


Notice
that  and  are projections onto orthogonal subspaces. 
It follows by the Pythagorean theorem applied to each row that

where the second equality uses that , where  is the number of columns of .

Observe that the row spaces of  and  are both in the row space of , and
therefore in the column space of . It follows that since  has orthonormal columns,
 
and therefore

where the second equality uses that . Let  be the best rank- approximation to
the matrix . By Theorem \ref{thm:kv}, with probability ,

and so

Notice that the row space of  is spanned by the top  right singular
vectors of , which are in the row space of . Let us write , 
where  is a rank- matrix.

For any vector ,  is in the row space of , and since the columns of  are orthonormal, 
,
and so 

We apply the Pythagorean theorem to each row in the expression in (\ref{eqn:fourth}), noting that
the vectors  and  are orthogonal, where  and  are the -th rows of  and ,
respectively. Hence,

where the first equality uses that

and 
the last equality uses the definition of . By Theorem \ref{thm:sketch},
with constant probability arbitrarily close to , we have

It follows by combining (\ref{eqn:first}), (\ref{eqn:second}), (\ref{eqn:third}), (\ref{eqn:fourth}), (\ref{eqn:fifth}),
(\ref{eqn:sixth}),
that , 
which shows the correctness property of {\sc AdaptiveCompress}.

We now bound the communication. In the first step, by Theorem \ref{thm:sketch},  can be set to 
and the matrix  can be described using a random seed that is -wise independent. The communication of
steps 1-3 is thus  words. By Theorem \ref{thm:kv}, the remaining steps take  words of communication.

To obtain communication with -bit words if the entries of the matrices  are specified by  bits, Server 1 can
instead send  to each of the servers. The -th server then computes  and sends this to Server 1.
Let , where  is an orthonormal
basis for the row space of , and  is an  change of basis matrix.
Server 1 computes 
 and sends this to each of the servers. Then, since each of the servers
knows , it can compute . 
It can then compute the SVD of this matrix, from which it obtains
, the projection onto its top  right singular vectors. Then, since Server  knows  and , it can compute
, as desired. Notice that in this variant of the algorithm what is sent is 
 and , which
each can be specified with -bit words if the entries of the  are specified by  bits.
\end{proof}

\section{Graph Sparsification}
{\bf Section Overview:} This section is devoted to showing how sketching can be used to perform spectral sparsification of graphs. While -subspace embeddings compress tall and skinny matrices to small matrices, they are not particularly useful at compressing roughly square matrices, as in the case of a graph Laplacian. This section shows how related sketching techniques can still be used to sparsify such square matrices, resulting in a useful compression.

While -subspace embeddings are a powerful tool, such embeddings compress an  
matrix to a  matrix. 
This is not particularly useful if  is not too much larger than . For instance, one natural problem is to compress
a graph  on  vertices using linear sketches so as to preserve all spectral information. In this case one is interested in a subspace embedding of the Laplacian of , which is an  matrix, for which an -subspace embedding does not provide compression.  
In this section we explore
how to use linear sketches for graphs. 

We formally define the problem as follows, following the notation and outlines of \cite{KLMMS14}. 
Consider an ordering on the  vertices, denoted . We will only
consider undirected graphs, though we will often talk about edges  as , where here  is less than
 in the ordering we have placed on the edges. This will be for notational convenience only; the underlying graphs are 
undirected. 

Let  be the vertex edge incidence of the
undirected, unweighted complete graph on  vertices, where the -th row  for edge  has a  in column
, a  in column , and zeroes elsewhere. 

One can then write the vertex edge incidence matrix of an arbitrary undirected graph  as 
, where  is a diagonal matrix with a  in the -th
diagonal entry if and only if  is an edge of  and its weight is . 
The remaining diagonal entries of  are equal to . The
Laplacian is . 

The spectral sparsification problem can then be defined as follows: find a weighted subgraph  of  so that if 
 is the Laplacian of , then 

We call  a {\it spectral sparsifier} of  
The usual notation for (\ref{eqn:spectral}) is

where  means that  is positive semidefinite. We also sometimes use the notation
 
to mean that  for all vectors 
in the row space of , which is a weaker notion since there is no guarantee for vectors 
outside of the row space of . 

One way to solve the spectral sparsification problem is via leverage score sampling. Suppose
we write the above matrix  in its SVD as . Let us look at the leverage scores of ,
where recall the -th leverage score . Recall the definition of Leverage
Score Sampling given in Definition \ref{def:lss}. By Theorem \ref{thm:lssPerf}, if we take
 samples of rows of , constructing the sampling and rescaling matrices
of Definition \ref{def:lss}, then with probability , simultaneously for all ,

Suppose we set

\begin{theorem}\label{thm:lssSimple}
For  defined as in (\ref{eqn:tildeK}), with probability , 

\end{theorem}
\begin{proof}
Using that  and the definition of , it suffices to show for all , 

By (\ref{eqn:guaranteeLSS}), and using that , 

and since  has orthonormal columns,

which completes the proof. 
\end{proof}
Notice that Theorem \ref{thm:lssSimple} shows that if one knows the leverage scores, then
by sampling  edges of  and reweighting them, one obtains a spectral
sparsifier of . One can use algorithms for approximating the leverage scores of general matrices \cite{DMMW12},
though more efficient algorithms, whose overall running time is near-linear in the number of edges
of , are known \cite{SS08,st11}. 

A beautiful theorem of Kapralov, Lee, Musco, Musco, and Sidford is the following \cite{KLMMS14}. 
\begin{theorem}\label{thm:linear}
There exists a distribution  on  matrices
 for which with probability , from , it is possible to recover a
weighted subgraph  with  edges such that  is a spectral sparsifier of . 
The algorithm runs in  time.  
\end{theorem}

We note that Theorem \ref{thm:linear} is not optimal in its time complexity or the number of edges
in . Indeed, Spielman and Srivastava \cite{SS08} show that in  time
it is possible to find an  with the same number  of edges as in Theorem \ref{thm:linear},
where  is the number of edges of . For sparse graphs, this results in significantly less time for finding
. Also, Batson, Spielman, and Srivastava \cite{BSS09} show that it is possible to deterministically find
an  with  edges, improving the  number of edges in Theorem \ref{thm:linear}. This
latter algorithm is a bit slow, requiring  time, with some improvements for dense graphs 
given by Zouzias \cite{z12}, though these are much slower than Theorem \ref{thm:linear}. 

Despite these other works, the key feature of Theorem \ref{thm:linear} is that it is a {\it linear sketch}, namely, it is formed by choosing a random oblivious (i.e., independent of ) linear map  and storing . Then, the sparsifier
 can be found using only , i.e., without requiring
access to . This gives
it a number of advantages, such that it implies the first algorithm for maintaining a spectral sparsifier in a
data stream in the presence of insertions and deletions to the graph's edges. That is, for the other works, it was
unknown how to rebuild the sparsifier if an edge is deleted; in the case when linear sketches are used to summarize
the graph, it is trivial to update the sketch in the presence of an edge deletion. 

In the remainder of the section, we give an outline of the proof of Theorem \ref{thm:linear}, following the exposition given
in \cite{KLMMS14}. We restrict to unweighted graphs for the sake of presentation; the arguments generalize in a natural
way to weighted graphs. 

The main idea, in the author's opinion, is the 
use of an elegant technique due to Li, Miller and Peng \cite{lmp13} called ``Introduction and Removal of Artificial Bases''. 
We suspect this technique should have a number of other applications; Li, Miller and Peng use it for
obtaining approximation algorithms for  and  regression. 
Intuitively, the theorem states that if you take any PSD matrix , you can form a sequence
of matrices , where  has a spectrum which is
within a factor of  of the identity,  has a spectrum within a factor of 
 of , and for
each ,  has a spectrum within a factor of  of . Furthermore
if  is the Laplacian of an unweighted graph, . 

The proof of the following
theorem is elementary. We believe the power in the theorem is its novel
use in algorithm design. 

\begin{theorem}(Recursive Sparsification of \cite{lmp13}, as stated in \cite{KLMMS14})\label{thm:mp}
Let  be a PSD matrix with maximum eigenvalue bounded above by  and minimum eigenvalue bounded from
below by . Let . For , set

Note that  and . Consider the sequence of PSD matrices
, where

Then the following conditions hold.
\begin{enumerate}
\item .
\item  for . 
\item .
\end{enumerate}
If  is the Laplacian of an unweighted graph, then its maximum eigenvalue is at most  and its minimum
eigenvalue is at least . We can thus set 
in the above. 
\end{theorem}
\begin{proof}
For the first condition, for all  in the row space of , 

For the second condition, for all ,

and

Finally, for the third condition, for all ,
 
The bounds on the eigenvalues of a Laplacian are given in \cite{st04} (the bound on the maximum eigenvalue follows from
the fact that  is the maximum eigenvalue of the Laplacian of the complete graph on  vertices. The bound on the minimum
eigenvalue follows from Lemma 6.1 of \cite{st04}). 
\end{proof}
The main idea of the algorithm is as follows. We say a PSD matrix  is a -approximate 
row space sparsifier of a PSD matrix  if . If we also
have the stronger condition that  we say that 
is a -approximate sparsifier of . 

By the first condition of Theorem \ref{thm:mp}, if we had a matrix  which is a -approximate
row space sparsifier of , then  is also a -approximate row space sparsifier to . 

If we were not
concerned with compressing the input graph  with a linear sketch, at this point we could perform
Leverage Score Sampling to obtain a -approximate sparsifier to . Indeed, by 
Theorem \ref{thm:lssPerf}, it is enough to construct a distribution 
for which  for all , where  is a constant. 

To do this, first observe that the leverage score for a potential edge  is given by

As  is in the row space of , it is also in the row space of ,
since  and  have the same row space (to see this, write 
in its SVD and then ). Since  is a 
-approximate row space sparsifier of , for all  in the row space of , 

which implies since  has the same row space as  (to see this, again look at the SVD), 

Since this holds for  for all , it follows that  is within a factor
of  of  for all . It follows 
by setting , we have that , where 
are the leverage scores of . Hence, by Theorem \ref{thm:lssPerf}, 
it suffices to take  samples of the edges of  according to , reweight them,
and one obtains a spectral sparsifier to the graph . 

Hence, if we were not concerned with compressing  with a linear sketch, i.e., 
of computing the sparsifier  from  for a random oblivious
mapping , one approach using
Theorem \ref{thm:mp} would be the following. By the third condition of Theorem \ref{thm:mp}, 
we can start with a sparsifier  which provides a -approximation to , 
in the sense that . Then, we can apply Leverage Score Sampling
and by Theorem \ref{thm:lssPerf}, obtain a sparsifier  for which 

Then, by the second property of Theorem \ref{thm:mp}, 

Hence,  is a -approximation to . We can now apply Leverage Score Sampling
again, and in this way obtain  which is a -approximation to , etc. Note that
the errors do not compound, and the number of samples in  is always . By
the argument above, when  becomes a -approximation to , it is a 
approximation to , and we obtain a spectral sparsifier of  by sampling  edges
according to the leverage scores of . 

Thus, the only task left is to implement this hierarchy of leverage score sampling using linear sketches. 

For this, we need the following standard theorem from the sparse recovery literature. 
\begin{theorem}(see, e.g., \cite{ccf04,GLPS})\label{thm:hh}
For any , there is an algorithm  and a 
distribution on matrices  in 
such that for any , with probability  over the choice of , the output of
 on input  is a vector  with  non-zero entries which satisfies the 
guarantee that 

\end{theorem}
Several standard consequences of this theorem, as observed in \cite{KLMMS14}, 
can be derived by setting  for a constant , which is the setting of 
we use throughout.  
Of particular interest is that for , from  one can determine
if  or  given that it satisfies one of 
these two conditions. We omit the proof of this fact which can be readily verified from the statement
of Theorem \ref{thm:hh}, as shown in \cite{KLMMS14}. 

The basic idea behind the sketching algorithm is the following intuition. 
Let  for an edge  which may or may not occur in , which as we will
see below is a vector with the important property that its -th coordinate is either  or . Then, 

where the first equality follows by definition of the leverage scores, the second equality 
follows by (\ref{eqn:newLabel}) and using that , the third equality
follows by definition of , the fourth equality follows from , and 
the final equality follows by definition of . 

Moreover, by definition of , the -th coordinate of  is  if  does not occur in . 
Otherwise, it is . 
We in general could have that , that is, there can be many other
non-zero entries among the coordinates of  other than the -th entry.

This is where sub-sampling and Theorem \ref{thm:hh} come to the rescue. 
At a given level in the Leverage Score Sampling hierarchy, that is, when trying to construct  from
, we have a -approximation
 to  for a given , and would like a -approximation to . Here
 is a fixed constant. To do this,
suppose we sub-sample the edges of  at rates , where sub-sampling
at rate  means we randomly decide to keep each edge independently with probability . Given ,
if  is our -approximation to , if we sub-sample at rate  where
 is within a factor of  of , then we would expect  to drop by a factor
of  to . Moreover, if edge  is included in the sub-sampling at rate ,
then we will still have . Now we can apply Theorem \ref{thm:hh} on the sub-sampled vector 
and we have that , which implies that in the discussion after 
Theorem \ref{thm:hh}, we will be able to find edge . 
What's more is that the process of dropping each edge with probability 
can serve as the leverage score sampling step itself. Indeed, this process sets the -th coordinate of 
to  with probability , that is, it finds edge  with probability , which
is exactly the probability that we wanted to sample edge  with in the first place. 

Thus, the algorithm is to sub-sample the edges of  at rates , and for each rate
of sub-sampling, maintain the linear sketch given by Theorem \ref{thm:hh}. This involves computing 
where  is a linear sketch of the form , where  is as in Theorem \ref{thm:hh},
and  is a diagonal matrix with each diagonal entry set to  with probability  and set to  otherwise.
We do this entire process independently
 times, as each independent repetition will allow us to build a  from a  for one
value of . 
Then, for each level of the Leverage Score Sampling hierarchy of Theorem \ref{thm:mp}, we
have a . For each possible edge , we compute  using  which determines
a sub-sampling rate . By linearity, we can compute , which is the
sub-sampled version of . We sample edge  
if it is found by the algorithm  in the discussion surrounding Theorem \ref{thm:hh}, for that sub-sampling level. We 
can thus use these sketches to walk up the Leverage Score Sampling hierarchy of Theorem \ref{thm:mp} and 
obtain a -approximate spectral sparsifier to . 
Our discussion has omitted a number of details, but hopefully gives a flavor of the result. 
We refer the reader to \cite{KLMMS14} for futher details
on the algorithm. 

\section{Sketching Lower Bounds for Linear Algebra}\label{chap:lb}
While sketching, and in particular subspace embeddings, have been used for a wide variety of applications, there
are certain limitations. In this section we explain some of them.

{\bf Section Overview:} In \S\ref{sec:schatten} we introduce the Schatten norms as a natural family of matrix norms including the Frobenius and operator norms, and show that they can be approximated pretty efficiently given non-oblivious methods and multiple passes over the data. In \S\ref{sec:oded} we ask what we can do with just a single oblivious sketch of the data matrix, and show that unlike the Frobenius norm, where it can be compressed to a vector of a constant number of dimensions, for approximating the operator norm of an  matrix from the sketch one cannot compress to fewer than  dimensions. In \S\ref{sec:streaming} we discuss streaming lower bounds for numerical linear algebra problems, such as approximate matrix product, -regression, and low rank approximation. In \S\ref{sec:seLB} we mention lower bounds on the dimension of -subspace embeddings themselves. Finally, in \S\ref{sec:adaptiveLower} we show how algorithms which sketch input data, then use the same sketch to adaptively query properties about the input, typically cannot satisfy correctness. That is, we show broad impossibility results for sketching basic properties such as the Euclidean norm of an input vector when faced with adaptively chosen queries. Thus, when using sketches inside of complex algorithms, one should make sure they are not queried adaptively, or if they are, that the algorithm will still succeed. 

\subsection{Schatten norms}\label{sec:schatten}
A basic primitive is to be able to use a sketch to estimate a norm. This is a very well-studied problem with
inspirations from the data stream literature, where sketching -norms has been extensively studied. 

For problems on matrices one is often interested in error measures that depend on a matrix norm. An 
appealing class of such norms is the Schatten -norms of a matrix , which we shall denote . 
\begin{definition}\label{def:schatten}
For , 
the -th Schatten norm  of a rank- matrix  is defined to be 

where  are the singular values of . For
,  is defined to be . 
\end{definition}
Two familiar norms immediately stand out: the Schatten -norm is just the Frobenius norm of , while
the Schatten -norm is the operator norm of . Note that typical convention is to let
 denote the operator norm of , but in this section we shall use  to denote
the operator norm to distinguish it from the Schatten -norm, which is the Frobenius norm. 

The Schatten norms are particularly useful
in that they are rotationally invariant. That is, if  is an  matrix, and if  is
an  orthonormal matrix while  is an  orthonormal matrix, then 
 for any . To see this, we may write  in its
SVD. Then  has orthonormal columns, while  has orthonormal rows. It follows that
the SVD of the matrix  is given in factored form as , and so it has
the same singular values as , and therefore the same Schatten -norm for any . 

One reason one is interested in estimating a matrix norm is to evaluate the quality of an approximation.
For instance, suppose one finds a matrix  which is supposed to approximate  in a certain
norm, e.g., one would like  to be small. To evaluate the quality of the approximation
directly one would need to compute . This may be difficult to do if one is interested
in a very fast running time or using a small amount of space and a small number of passes over the data. 
For instance, for 
it isn't immediately clear there is an algorithm other than computing the SVD of . 

While our focus in this section is on lower bounds, we mention that for integers , there
is the following simple algorithm for estimating Schatten norms which has a good running time but requires multiple passes over
the data. This is given in \cite{lnw14}. 
\begin{theorem}
For any integer , given an  matrix , 
there is an  time algorithm for obtaining a -approximation to
 with probability at least . Further,
the algorithm makes  passes over the data. 
\end{theorem}
\begin{proof}
Let  for a positive constant . 
Suppose  are independent  vectors, that is, they are independent
vectors of i.i.d. normal random variables with mean  and variance . 

We can assume  is symmetric by replacing  with the matrix

A straightforward calculation shows  for all Schatten -norms, and
that the rank of  is , where  is the rank of .

In the first pass we compute . In the second pass we compute , and
in general in the -th pass we compute . 

If  is the SVD
of the symmetric matrix , 
then after  passes we will have computed  for each ,
as well as  for each  where . Using that ,
we can compute  for each . By rotational invariance, these 
values are equal , where  are 
independent vectors of independent  random variables. 

For every , we have

where we use that  for all . We also have that

where the second equality uses independence of the coordinates of  and that the -th moment of an  random variable is , while the third equality uses that the variance
of an  random variable is . It follows by Chebyshev's inequality that if
 and let , then

This shows correctness. The running time follows from our bound on  and the number  of passes. 
\end{proof}

\subsection{Sketching the operator norm}\label{sec:oded}
The algorithm in the previous section 
has the drawback that it is not a linear sketch, and therefore requires multiple passes
over the data. This is prohibitive in certain applications. We now turn our focus to linear sketches. A first
question is what it means to have a linear sketch of a matrix . While some applications could require
a sketch of the form  for random matrices  and , we will not restrict ourselves
to such sketches and instead consider treating an  matrix  as an -dimensional vector, 
and computing , where  is a random linear operator, i.e.,
a  matrix which multiplies  on the left, where  is treated as an -dimensional vector.
Since we will be proving lower bounds, this generalization is appropriate. 

While the Frobenius norm is easy to approximate up to a -factor 
via a sketch, e.g., by taking  to be a random Gaussian matrix with
 rows, another natural, very important Schatten norm is the Schatten-, or operator norm
of . Can the operator norm of  be sketched efficiently?

Here we will prove a lower bound of  for obtaining a fixed constant factor approximation.
Note that this is tight, up to a constant factor, since if  is an -subspace embedding with 
rows, then  preserves all the singular values of  up to a  factor. We prove this formally 
with the following lemma.

The idea is to use the min-max principle for singular values. 
	\begin{lemma}\label{lem:interlace}
Suppose  is a  -subspace embedding for .  
Then, 
it holds that  for all .
	\end{lemma}
\begin{proof}
The min-max principle for singular values says that

where  runs through all -dimensional subspaces. 
Observe that the range of  is a subspace of dimension at most . It follows from the definition of a subspace embedding that 

The lemma now follows from the min-max principle for singular values, since every vector in the range
has its norm preserved up to a factor of , and so this also holds for any -dimensional subspace
of the range, for any . 
\end{proof}
Similarly, if 
is an  susbpace embedding with  columns, then  preserves all the singular values of 
up to a  factor, so  is achievable. 

Hence, we shall, for simplicity focus on the case when  is a square  matrix. The following
 lower bound on the sketching dimension  was shown by Oded Regev \cite{r14}, improving an 
earlier  lower bound of Li, Nguyn, and the author \cite{lnw14}. We will need to describe
several tools before giving its proof. 

Define two distributions: 
\begin{itemize}
\item  is the distribution on  matrices with i.i.d.  entries. 
\item  is the distribution on  matrices obtained by 
(1) sampling  from , (2) sampling  to be independent -dimensional
vectors with i.i.d.  entries, and (3) outputting .
\end{itemize}

We will show that any linear sketch  for 
distinguishing a matrix drawn from  from a matrix drawn from 
 requires  rows. For this to imply a lower bound for approximating the operator norm of
a matrix, we first need to show that with good probability, a matrix drawn from  has an operator
norm which differs by a constant factor from a matrix drawn from . 

\begin{lemma}\label{lem:gap}
Let  be a random matrix drawn from distribution , while  is a random matrix drawn from distribution .
With probability , .   
\end{lemma}
\begin{proof}
It suffices to show that for  drawn from  and , that 
 and  differ by a constant factor with probability . 
We use the following tail bound. 
\begin{fact}[Operator norm of Gaussian Random Matrix  \cite{vershynin2010}]\label{lem:operator norm}
Suppose that . Then with probability at least , it holds that .
\end{fact}
By Fact \ref{lem:operator norm}, with probability , . 

Let . 
Since  is of rank one, the only non-zero singular value of  is equal to . We also have 
 with probability , 
since , where  is the -distribution with  degrees of freedom,
which is tightly concentrated around .

It follows with probability , by the triangle inequality

\end{proof}

In our proof we need the following tail bound due to Lata{\l}a
Suppose that  are i.i.d.  random variables. The following result, due to Lata\l{}a \cite{latala}, bounds the tails of Gaussian chaoses . The proof of Lata\l{}a's tail bound was later simplified by Lehec \cite{Lehec}.

Suppose that  is a finite multi-indexed matrix of order . For  and , define . For disjoint nonempty subsets  define  to be:

Also denote by  the set of all partitions of  into  nonempty disjoint sets . It is not hard to
show that if a partition 
 is finer than another partition , 
then .

\begin{theorem}\label{thm:latala}
For any  and ,

where  are constants depending only on .
\end{theorem}

To prove the main theorem of this section, we need a few facts about distances between distributions. 

Suppose  and  are two probability measures on . 
For a convex function  such that , we define the -divergence

In general  is not a distance because it is not symmetric. 

The \textit{total variation distance} between  and , denoted by , 
is defined as  for . It can be verified that this is indeed a distance. It 
is well known that if , then the probability that any, possibly randomized
algorithm, can distinguish the two distributions is at most . 

The \textit{-divergence} between  and , denoted by , 
is defined as  for  or . 
It can be verified that these two choices of  give exactly the same value of .

We can upper bound total variation distance in terms of the -divergence using the next proposition.
\begin{fact}[{\cite[p90]{Tsybakov}}] \label{prop:TV_chi^2}
.
\end{fact}

The next proposition gives a convenient upper bound on the -divergence between a Gaussian distribution
and a mixture of Gaussian distributions. 
\begin{fact}[{\cite[p97]{IS}}] \label{prop:chi^2}
, where  are independent.
\end{fact}

We can now prove the main impossibility theorem about sketching the operator norm up to a constant factor. 
\begin{theorem}\cite{r14}
Let  be drawn from a distribution on matrices for which for any fixed 
matrix , with probability at least  
there is an algorithm which given , can estimate  up to a constant factor , 
with . Recall here that  is the image (in ) of the linear map  which
takes as input  represented as a vector in .
Under these conditions, it holds that . 
\end{theorem}
\begin{proof}
We can assume the rows of  are orthonormal vectors in . Indeed, this just corresponds to a change
of basis of the row space of , which can be performed in post-processing. That is, given  one
can compute  where  is a  change of basis matrix.

Let the orthonormal rows of
 be denoted . Although these are vectors in , we will sometimes think
of these as  matrices with the orthonormal property expressed by . 

Suppose . Then, since the rows of  are orthonormal, it follows by rotational invariance 
that  is distributed as a -dimensional Gaussian vector . 
On the other hand, if , then 
 is distributed as a -dimensional Gaussian vector with a {\it random mean}, that is, as
 where

We denote the distribution of  by . 
By Lemma \ref{lem:gap} and the definition of total variation distance, 
to prove the theorem it suffices to upper bound  by a constant . We shall
do so for . 

Without loss of generality we may assume that . 
Consider the event . 
Since , it follows by Markov's inequality that 
. 
Let  be the marginal distribution of  conditioned on . Then

and it suffices to bound . 
Resorting to -divergence by invoking Proposition~\ref{prop:TV_chi^2} and Proposition~\ref{prop:chi^2}, we have that

where  conditioned on  and . We first see that 

where  and  is an array of order  such that

We shall compute the partition norms of  as needed in Lata{\l}a's tail bound Theorem \ref{thm:latala}. 

\noindent\textbf{Partition of size 1.}
The only possible partition is . We have


\noindent\textbf{Partitions of size 2.} The norms are automatically upper-bounded by .

\noindent\textbf{Partitions of size 3.} Up to symmetry, there are only two partitions to consider:
, and . We first consider the partition . We have

where the first inequality follows from Cauchy-Schwarz. We now consider the partition . We have

where the second equality follows by Cauchy-Schwarz.

Let  be the  matrix whose columns are the , interpreted as column vectors in . 
Let  be the  matrix whose columns are . 
Similarly,  is the  matrix whose columns are . Then 

Since  and  are obtained from  by applying a contraction, we have that
, and 
. Therefore, . Consequently, 
since  is an  matrix, . 

\noindent\textbf{Partition of size 4.}
The only partition is . Using that for integers , , we have

The last inequality follows the fact that  is a unit vector in  and 's are orthonormal vectors in .

Lata{\l}a's inequality (Theorem~\ref{thm:latala}) states that for , 

The above holds with no conditions imposed on . For convenience, we let 

It follows that

Note that conditioned on  and ,


We now claim that  for all , provided . First, note
that since , . Also, since , . 
Hence, . Since , if  achieves the minimum, then it is larger
than . On the other hand, if  achieves the minimum, then  whenever
, which since , always holds. 

Integrating the tail bound gives that

where the first inequality uses that , the second
inequality uses the above bound that , and the first part of the third inequality uses that . For
the second part of the third inequality, since , we have that . Also, 
 (assuming , which we can assume, since if there is a linear sketch with  
there is also one with ), and so  since the integral is dominated by a geometric
series. Also, since , . 

It follows that  and thus 

\end{proof}

\subsection{Streaming lower bounds}\label{sec:streaming}
In this section, we explain some basic communication complexity,
and how it can be used to prove bit lower bounds for the space
complexity of linear algebra problems in the popular {\it streaming model} of computation.
We refer the reader to Muthukrishnan's survey \cite{m05} for a comprehensive overview on the streaming
model. We state the definition of the model that we need as follows. These results are by Clarkson
and the author \cite{CW09}, and we follow the exposition in that paper.

In the {\it turnstile model} of computation for linear algebra problems, there is an input matrix
 which is initialized to all zeros. We then see a finite sequence of 
additive updates to the coordinates of , where each update has the form 
for , and , with the meaning that 
. We will restrict ourselves to the case when at all
times, all entries of  are integers bounded by , for some fixed polynomial
in  and . We note that the sequence of updates is adversarially chosen, and multiple
updates to each entry  may occur and in an arbitrary order (interleaved with other
updates to entries ). One of the main goals in this computational model is to
compute or approximate a function of  using as little space in bits as possible. 

\subsection{Communication complexity}
For lower bounds in the turnstile model, we use a few definitions and basic results
from two-party communication complexity, described below. We refer the reader to the
book by Kushilevitz and Nisasn for more information \cite{kn97}.
We will call the two parties Alice and Bob.

For a function , we use 
 to denote the randomized communication complexity with 
two-sided error at most  in which only a single message is sent from 
Alice to Bob. Here, only a single message  is sent from Alice to Bob,
where  is Alice's message function of her input  and her random coins. Bob
computes , where  is a possibly randomized function of 
and Bob's input . For every input pair , Bob should output a correct
answer with probability at least , where the probability is taken over the joint
space of Alice and Bob's random coin tosses. If this holds, we say the protocol is correct.
The communication complexity  is then the minimum over correct protocols, 
of the maximum length of Alice's message , over all inputs and all settings to the 
random coins. 

We also use  to denote the minimum 
communication of a protocol, in which a single message from Alice to Bob is 
sent, for solving  with probability at least , where the 
probability now is taken over both the coin tosses of the protocol and an input 
distribution .

In the augmented indexing problem, which we call 
, Alice is given , while Bob is given 
both an  together with . Bob should 
output .
\begin{theorem}(\cite{MNSW98})\label{thm:mnsw}
 and also
,
where  is uniform on .
\end{theorem}

\subsubsection{Matrix product}
We start with an example showing how to use Theorem \ref{thm:mnsw} for proving
space lower bounds for the {\sf Matrix Product} problem, which is the same
as given in Definition \ref{def:matrixProduct}. Here we also include in the definition
the notions relevant for the streaming model.

\begin{definition}\label{def:matrixProduct2}
In the {\em Matrix Product} Problem matrices  and  are presented as an arbitrary stream of
additive updates to their entries, where  and  each have  rows and a 
total of  columns.  At all times in the stream we assume the entries of  and 
are specified by -bit numbers.
The goal is to output a 
matrix  so that 

\end{definition}

\begin{theorem}
Suppose  for an absolute constant , and
that the entries of  and  are represented by -bit numbers.
Then any randomized -pass algorithm which solves Matrix Product with probability 
at least  uses  bits of space.
\end{theorem}
\begin{proof}
Throughout we shall assume that  is an integer, and that
 is an even integer. These conditions can be removed with minor modifications.
Let  be a -pass algorithm which solves Matrix Product with 
probability at least . Let . We 
use  to solve instances of  on strings of size . It will 
follow by Theorem \ref{thm:mnsw} that the space complexity of  must be 
. 

Suppose Alice has . 
She creates a  matrix  as follows. We will have that
, where for each 
,  is a 
 matrix with entries in the set .
Also,  is a  matrix consisting of all zeros.

Each entry of  is associated with a unique entry in a unique . If the
entry in  is , the associated entry in  is , otherwise it is
. Recall that , so we can assume 
that  provided that  is a sufficiently large constant.

Bob is given an index in , and suppose this index of  is associated
with the -th entry of . By the definition of the AIND problem,
we can assume that Bob is given all entries of  for all .
Bob creates a  matrix  as follows. In , all entries in the first
 columns are set to . The entries in the remaining columns
are set to the negation of their corresponding entry in . This is possible 
because Bob has  for all . 
The remaining  columns of 
 are set to . We define . Bob also creates the 
 matrix  which is  in all but the 
-st entry, which is . Then,


Using that , 


 has first column equal to the -th column of , 
and remaining columns equal to zero. Let  be the  approximation 
to the matrix . We say an entry
 is {\it bad} if its sign disagrees with the sign of . 
If an entry  is bad, then 
. Thus, the fraction of bad
entries is at most . Since we may assume that , and 
are chosen independently of , with probability at least , 
sign sign. 

Alice runs  on  in an arbitrary order, transmitting the state to Bob, who 
continues the computation on  and then on , again feeding the entries into 
 in an arbitrary order. Then with probability at least , over 's 
internal coin tosses,  outputs a matrix  for which 
. 

It follows that the parties can solve the AIND problem with probability at least
. The theorem now follows by Theorem \ref{thm:mnsw}.
\end{proof}

\subsubsection{Regression and low rank approximation}
One can similarly use communication complexity to obtain lower bounds in the streaming
model for Regression and Low Rank Approximation. The results are again obtained by reduction
from Theorem \ref{thm:mnsw}. They are a bit more involved than those for matrix product, and
so we only state several of the known theorems regarding these lower bounds. We begin with
the formal statement of the problems, which are the same as defined earlier, 
specialized here to the streaming setting. 

\begin{definition}
In the {\it -Regression Problem}, an  matrix  and an 
 column vector  are presented as a sequence of additive updates to their
coordinates. We assume that at all points in the stream, the entries of  and  
are specified by -bit 
numbers. The goal is to output a vector  so that

\end{definition}

\begin{theorem}(\cite{CW09})
Suppose  and  is sufficiently large. Then any 
randomized -pass algorithm which solves the -Regression Problem with 
probability at least  needs  bits of space.
\end{theorem}

\begin{definition}\label{prob:lowrank}
In the {\it Rank- Approximation Problem}, 
we are given an integer , value , and  matrix  which is presented
as a sequence of additive updates to its coordinates. The goal is to 
find a matrix  of rank at most  so that

where  is the best rank- approximation to .
\end{definition}

\begin{theorem}\label{thm:rankLB}(\cite{CW09})
Let  and  be arbitrary. Then, 

(1) Suppose  for an absolute constant . Then any
randomized -pass algorithm which solves the Rank- Approximation Problem with 
probability at least , and which receives
the entries of  in row-order, must use  bits of space.

(2) Suppose  for an absolute constant . Then any
randomized -pass algorithm which solves the Rank- Approximation Problem with
probability at least , and which receives
the entries of  in column-order must use  bits of space.

\end{theorem}

\subsection{Subspace embeddings}\label{sec:seLB}
We have seen that -subspace embeddings have a number of important applications, 
especially ones that are oblivious to the matrix  they are being applied to. A natural
question is what the minimum dimension of such subspace embeddings needs to be. That is,
we seek to design a distribution  over  matrices , with  as small
as possible, so that for any
fixed  matrix , we have with constant probability over  drawn from ,

We have seen that by choosing  to be a matrix of i.i.d. Gaussians, it suffices to set
, which also achieves (\ref{eqn:selb}) with probability .

A theorem of Nelson and Nguyn \cite{nn14} shows that the above setting of  is best possible
for achieving (\ref{eqn:selb}), even if one desires only constant error probability. 

\begin{theorem}\label{thm:lbnn}
For  for a sufficiently large constant , 
any distribution  satisfying (\ref{eqn:selb}) with constant probability over 
drawn from , satisfies . 
\end{theorem}

While Theorem \ref{thm:lbnn} gives a nice dimension lower bound for subspace embeddings,
it turns out that often one can do better than it in specific applications, such as the  Regression
Problem, where it is possible to achieve a dependence on  that is linear. This is because in the
analysis, only a subspace embedding with constant  is needed, while additional
other properties of the sketching matrix  are used that only incur a  factor in the dimension.  

\subsection{Adaptive algorithms}\label{sec:adaptiveLower}
In this section we would like to point out a word of caution of using a sketch for multiple, adaptively chosen
tasks. 

Suppose, for example, that 
we have a  sketching matrix , with , drawn from some distribution
with the property that there is a, possibly randomized {\it reconstruction function}  
such that for any fixed vector , 

with probability at least  for some parameter . In this section we will focus
on the case in which  for every constant , that is,  shrinks faster
than any inverse polynomial in 

The property in (\ref{eqn:JLproperty}) is a basic property 
that one could ask for a sketching matrix  to satisfy, and we will refer to an  pair satisfying
this property as 
an {\it -sketch}. It is
clear, for example, that an -subspace embedding has this property for certain  and , 
where the function . As
we have seen, such embeddings have a number of applications in linear algebra. 

A natural question is if an -sketch can be reused, 
in the following sense. Suppose we compute

where  is an adaptively chosen sequence of vectors in . We will also assume
 for some fixed constant .  
For each , we obtain . 
Note that if the  were fixed before the choice of , 
by a union bound over the  vectors ,
we should have that with probability at least , 
simultaneously for all , 

A natural question though, is what happens in the adaptive case, where the  
can depend on . 
As an illustrative example that this is a nontrivial issue, 
we first consider the standard estimator . An  sketch with this choice of
estimator is often called a {\it Johnson-Lindenstrauss transform}. 

\begin{theorem}\label{thm:jlBreak}
For any , and any Johnson-Lindenstrauss transform  with  rows and  columns, , 
there is an algorithm which makes
 query vectors , for which with probability , 

Further, the algorithm runs in  time and the first  queries can be chosen 
non-adaptively (so the algorithm makes a single adaptive query, namely, ). 
\end{theorem}
\begin{proof}
The algorithm first queries the sketch on the vectors

where the  are the standard unit vectors in . Since  is a Johnson-Lindenstrauss
transform, it learns  and  for all , where 
denotes the -th column of . Since
, the algorithm learns 
 for all . 

Now consider the  matrix . This matrix
has rank at most , since  has rank at most . By definition, . 
It follows that the algorithm has learned the upper  submatrix of , let us call
this submatrix . As  has rank at most , it follows there is a non-zero vector  
in the kernel of the span of the rows of . 

Consider the non-zero vector  obtained by padding  with  zero coordinates. 
We claim that , which would imply that  cannot provide a relative error approximation
to  for any . 

To prove the claim, write  as a block matrix, where  consists of the first  columns
of , and  consists of the remaining  columns of . Then

where . Writing  in its SVD, we see that  is orthogonal to the row space
of , which implues , as desired. 

To conclude, note that the query algorithm makes  queries, the only adaptive one being , and runs
in  time to compute the SVD of . 
\end{proof}
While Theorem \ref{thm:jlBreak} rules out using a Johnson-Lindenstrauss transform as an  sketch
which supports adaptively chosen query vectors, one could ask if a different, more carefully designed
 sketch, could support adaptively chosen query vectors. Unfortunately, the answer is no, in a very
strong sense, as shown by Hardt and the author \cite{hw13}. Namely, the authors show that for {\it any}  sketch, there is
an efficient query algorithm which can find a distribution on queries  for which with constant
probability, . To avoid introducing additional
notation, we state the theorem of \cite{hw13} informally, and refer the reader to the paper for more details.  

\begin{theorem}\label{thm:adaptive}[Informal version]
There is a randomized algorithm which, given a parameter  and
oracle access to an  sketch that uses at most 
rows, with high probability finds a distribution over queries on which 
the linear sketch fails to satisfy (\ref{eqn:JLproperty}) with constant probability.

The algorithm makes at most  adaptively chosen queries to the
oracle and runs in time  Moreover, the algorithm uses only 
``rounds of adaptivity'' in that the query sequence can be partitioned into at
most  sequences of non-adaptive queries.
\end{theorem}
We state some of the intuition behind the proof of Theorem \ref{thm:adaptive} below. 

The problem of approximating the Euclidean norm of  is captured 
by the following game between two
players, Alice and Bob. Alice chooses an  sketching matrix  from
distribution . Bob makes a sequence of queries  to
Alice, who only sees  on query . This captures the fact that a sketching
algorithm only has access to , rather than to  itself. The multiple
queries  of Bob are the vectors whose Euclidean norm one would like to approximate
using the sketching matrix . 
Alice responds by telling Bob the
value , which is supposed to be a -approximation to the Euclidean
norm of . 

Here  is an arbitrary function that 
need not be efficiently computable. For simplicity of presentation, we'll just focus
on the case in which  uses no randomness, though Theorem \ref{thm:adaptive}
holds also for randomized functions . 
Bob will try to learn the row space  of Alice, namely the at most
-dimensional subspace of  spanned by the rows of .  If Bob
knew , he could, with probability  query  and with probability
 query a vector in the kernel of . Since Alice cannot distinguish the
two cases, and since the norm in one case is  and in the other case
non-zero, she cannot provide a relative error approximation. 

Theorem \ref{thm:adaptive} provides 
an algorithm (which can be executed efficiently by Bob) that learns
 orthonormal vectors that are almost contained in  While this
does not give Bob a vector in the kernel of  it effectively reduces
Alice's row space to be constant dimensional thus forcing her to make a
mistake on sufficiently many queries (since the variance is large). 

\paragraph{The conditional expectation lemma.}
In order to learn , Bob's initial query is drawn from the multivariate
normal distribution , where  is the covariance
matrix, which is just a scalar  times the identity matrix .  This
ensures that Alice's view of Bob's query , namely, the projection  of
 onto , is spherically symmetric, and so only depends on
. Given , Alice needs to output  or  depending
on what she thinks the norm of  is. Since Alice has a
proper subspace of , she will be confused into thinking  has
larger norm than it does when  is slightly larger than its
expectation (for a given ), that is, when  has a non-trivial
correlation with . 

Formally, Theorem \ref{thm:adaptive} makes use of a conditional expectation
lemma showing that there exists a choice of  for which 
 
is non-trivially large. This is done by showing that the sum of this
difference over all possible  in a range  is noticeably
positive. Here  is the approximation factor. 
In particular, there exists a  for which this difference is
large. To show the sum is large, for each possible condition , there is a probability  that the algorithm outputs ,
and as we range over all ,  contributes both positively and
negatively to the above difference based on 's weight in the -distribution 
with mean . The overall contribution of  can be shown to be
zero. Moreover, by correctness of the sketch,  must typically be close to  for
small values of  and typically close to  for large values of  
Therefore  zeros out some of the negative contributions that  would otherwise
make and ensures some positive contributions in total.

\paragraph{Boosting a small correlation.}
Given the conditional expectation lemma, one then finds many independently
chosen  for which each  has a slightly increased expected projection
onto Alice's space . At this point, however, it is not clear how to
proceed unless one can aggregate these slight correlations into a single vector
which has very high correlation with  This is accomplished by arranging
all  positively labeled vectors  into an  matrix  and
computing the top right singular vector~ of  Note that this can be
done efficiently.  One can then show that  In
other words  is almost entirely contained in  This step is crucial
as it gives a way to effectively reduce the dimension of Alice's space
by~. 

\paragraph{Iterating the attack.}
After finding one vector inside Alice's space, one must iterate the argument. In fact 
Alice might initially use only a small fraction of her rows and switch to a new set
of rows after Bob learned her initial rows.
An iteration of the previously described attack is performed as follows. Bob makes
queries from a multivariate normal distribution inside of the subspace
orthogonal to the the previously found vector. In this way one effectively
reduces the dimension of Alice's space by , and repeats the attack
until her space is of constant dimension, at which point a standard
non-adaptive attack is enough to break the sketch. Several complications
arise at this point. For example, each vector that we find is only approximately contained
in  One needs to rule out that this approximation error could help Alice.
This is done by adding a sufficient amount of global Gaussian noise to the query
distribution. This has the effect of making the distribution statistically
indistinguishable from a query distribution defined by vectors that are exactly
contained in Alice's space. A generalized
conditional expectation lemma is then shown for such distributions.

\section{Open Problems}
We have attempted to cover a number of examples where sketching techniques can be used to speed
up numerical linear algebra applications. We could not cover everything and have of course missed out
on some great material. We encourage the reader to look at other surveys in this area, such
as the one by Mahoney \cite{m11}, for a treatment of some of the topics that we missed. 

Here we conclude with some open problems.
\\\\
{\bf Open Question 1 (Spectral Low Rank Approximation)} We have seen in Theorem \ref{thm:lowrank} 
that it is possible to achieve a running time of 
 for solving the low rank approximation problem
with Frobenius norm error, namely, given an  matrix , finding a (factorization of a) 
rank- matrix , where  is a  matrix, for which 

On the other hand, in Theorem \ref{thm:tropp} we see that it is possible to find a projection matrix
 for which

that is the error is with respect to the spectral rather than the Frobenius norm. The latter error
measure can be much stronger than Frobenius norm error. Is it possible to achieve 
time and obtain the guarantee in (\ref{eqn:openSpec})?
\\\\
{\bf Open Question 2. (Robust Low Rank Approximation)} 
We have seen very efficient,  time algorithms
for low rank approximation with Frobenius norm error, that is, for finding a factorization of a rank- matrix
, where  is a  matrix, for which 

As we have seen for regression, often the -norm is a more robust error measure than the -norm, and
so here one could ask instead for finding a factorization of a rank- matrix  for which

where here for an  matrix ,  is the entry-wise -norm of 
. We are not aware of any polynomial time algorithm for this problem, nor are we aware of an NP-hardness
result. Some work in this direction is achieved by Shyamalkumar and Varadarajan \cite{SV07} 
(see also the followup papers \cite{DV07,FMSW10,FL11,VX12}) who give an algorithm which
are polynomial for fixed , for the weaker error measure  that is,
the -norm denotes the sum of Euclidean norms of rows of , and so is more robust than the Frobenius norm,
though not as robust as the entry-wise -norm. 
\\\\
{\bf Open Question 3. (Distributed Low Rank Approximation)}
In \S\ref{sec:dislra} we looked at the arbitrary partition model. Here there
are  players, 
each locally holding an  
matrix . Letting , 
we would like for each player to compute the same rank- projection
matrix , for which 

We presented a protocol due to Kannan, Vempala, and the author
\cite{kvw14} 
which obtained  words of communication
for solving this problem. In \cite{kvw14} a lower bound of  bits
of communication is also presented. Is it possible to prove an 
 communication 
lower bound, which would match the leading term of the
upper bound? Some possibly related work is an  
space lower bound 
for outputting such a  given one pass over the rows of 
presented one at a time in an arbitrary order \cite{w14}, i.e., in the
streaming model of computation. In that model, this bound is
tight up to the distinction between words and bits. 
\\\\
{\bf Open Question 4. (Sketching the Schatten- Norm)}
In Section \S\ref{sec:schatten} we looked at the Schatten norms of an
 matrix
. Recall that for , 
the -th Schatten norm  of a rank- matrix  is 
defined to be 

where  
are the singular values of . For
,  is defined to be .
Some of the
most important cases of a Schatten norm is when , 
in which case it corresponds to the nuclear, Frobenius, and spectral norm,
respectively. For constant factor approximation, 
for  one can sketch  using a constant number
of dimensions, while for , we saw that  dimensions 
are needed. For , there is a lower bound of  for
constant factor approximation, which can be improved to ,
for an arbitrarily small constant , 
if the sketch is of a particular form called a ``matrix sketch'' 
\cite{lnw14}. There is no non-trivial (better than ) upper bound
known. What is the optimal sketching dimension for approximating
 up to a constant factor?
\\\\
{\bf Acknowledgements:} 
I would like to thank Jaroslaw Blasiok, Christos Boutsidis, 
T.S. Jayram, Jelani Nelson, Shusen Wang, Haishan Ye, Peilin Zhong,  
and the anonymous
reviewer for a careful reading and giving many helpful comments. 


\bibliographystyle{plain}
\bibliography{main}
\end{document}
