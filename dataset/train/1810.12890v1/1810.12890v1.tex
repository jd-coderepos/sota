\documentclass{article}

\PassOptionsToPackage{numbers, compress}{natbib}



\usepackage[preprint]{nips_2018}





\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage[pdftex]{graphicx}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{color}
\usepackage{array}
\usepackage[separate-uncertainty = true,multi-part-units = repeat]{siunitx}
\usepackage{subcaption}

\title{DropBlock: A regularization method for convolutional networks}

\author{
  Golnaz Ghiasi \\ Google Brain
  \And
  Tsung-Yi Lin \\ Google Brain
  \And
  Quoc V. Le \\ Google Brain
}

\begin{document}

\maketitle

\begin{abstract}
  Deep neural networks often work well when they are over-parameterized and trained with a massive amount of noise and regularization, such as weight decay and dropout. Although dropout is widely used as a regularization technique for fully connected layers, it is often less effective for convolutional layers. This lack of success of dropout for convolutional layers is perhaps due to the fact that activation units in  convolutional layers are spatially correlated so information can still flow through convolutional networks despite dropout. Thus a structured form of dropout is needed to regularize convolutional networks. In this paper, we introduce DropBlock, a form of structured dropout, where units in a contiguous region of a feature map are dropped together. We found that applying DropbBlock in skip connections in addition to the convolution layers increases the accuracy. Also, gradually increasing number of dropped units during training leads to better accuracy and more robust to hyperparameter choices. Extensive experiments show that DropBlock works better than dropout in regularizing convolutional networks.
  On ImageNet classification, ResNet-50 architecture with DropBlock achieves $78.13\%$ accuracy, which is more than $1.6\%$ improvement on the baseline. On COCO detection, DropBlock improves Average Precision of RetinaNet from $36.8\%$ to $38.4\%$.
\end{abstract}


\section{Introduction}
Deep neural nets work well when they have a large number of parameters and are trained with a massive amount of regularization and noise, such as weight decay and dropout~\cite{dropout2014}. Though the first biggest success of dropout was associated with convolutional networks~\cite{krizhevsky2012imagenet}, recent convolutional architectures rarely use dropout~\cite{ioffe2015batch,he2016deep,szegedy2017inception,xie2017aggregated,han2017deep,zoph2017learning,hu2017squeeze,real2018regularized}. In most cases, dropout was mainly used at the fully connected layers of the convolutional networks~\cite{simonyan2014very,szegedy2015going,szegedy2016rethinking}.

We argue that the main drawback of dropout is that it drops out features randomly. While this can be effective for fully connected layers, it is less effective for convolutional layers, where features are correlated spatially. When the features are correlated, even with dropout, information about the input can still be sent to the next layer, which causes the networks to overfit. This intuition suggests that a more structured form of dropout is needed to better regularize convolutional networks.

In this paper, we introduce DropBlock, a structured form of dropout, that is particularly effective to regularize convolutional networks. In DropBlock, features in a block, i.e., a contiguous region of a feature map, are dropped together. As DropBlock discards features in a correlated area, the networks must look elsewhere for evidence to fit the data (see Figure~\ref{fig:splash}). 


\begin{figure}[h!]
  \centering
  \begin{tabular}{ccc}
      \includegraphics[width=0.3\linewidth]{figs3/splash1.png}&
      \includegraphics[width=0.3\linewidth]{figs3/splash2.png}&
      \includegraphics[width=0.3\linewidth]{figs3/splash3.png}\\
      (a) & (b) & (c)\\
  \end{tabular}
  
  \caption{(a) input image to a convolutional neural network. The green regions in (b) and (c) include the activation units which contain semantic information in the input image. Dropping out activations at random is not effective in removing semantic information because nearby activations contain closely related information. Instead, dropping continuous regions can remove certain semantic information (e.g., head or feet) and consequently enforcing remaining units to learn features for classifying input image.}
  \label{fig:splash}
\end{figure}

In our experiments, DropBlock is much better than dropout in a range of models and datasets.
Adding DropBlock to ResNet-50 architecture improves image classification accuracy on ImageNet from $76.51\%$ to $78.13\%$. On COCO detection, DropBlock improves AP of RetinaNet from $36.8\%$ to $38.4\%$.

\section{Related work}

Since its introduction, dropout~\cite{dropout2014} has inspired a number of regularization methods for neural networks such as DropConnect~\cite{wan2013regularization}, maxout~\cite{goodfellow2013maxout}, StochasticDepth~\cite{huang2016deep}, DropPath~\cite{fractalnet2017},  ScheduledDropPath~\cite{zoph2017learning}, shake-shake regularization~\cite{gastaldi2017shake}, and ShakeDrop regularization~\cite{yamada2018shakedrop}. The basic principle behind these methods is to inject noise into neural networks so that they do not overfit the training data. When it comes to convolutional neural networks, most successful methods require the noise to be structured~\cite{huang2016deep,fractalnet2017,zoph2017learning,gastaldi2017shake,yamada2018shakedrop,tompson2015spatialdropout}. For example, in DropPath, an entire layer in the neural network is zeroed out of training, not just a particular unit. Although these strategies of dropping out layers may work well for layers with many input or output branches, they cannot be used for layers without any branches. Our method, DropBlock, is more general in that it can be applied anywhere in a convolutional network. Our method is closely related to SpatialDropout~\cite{tompson2015spatialdropout}, where an entire channel is dropped from a feature map. Our  experiments show that DropBlock is more effective than SpatialDropout.

The developments of these noise injection techniques specific to the architectures are not unique to convolutional networks. In fact, similar to convolutional networks, recurrent networks require their own noise injection methods. Currently, Variational Dropout~\cite{gal2016theoretically} and ZoneOut~\cite{krueger2016zoneout} are two of the most commonly used methods to inject noise to recurrent connections.   


Our method is inspired by Cutout \cite{Cutout2017}, a data augmentation method where parts of the input examples are zeroed out. DropBlock generalizes Cutout by applying Cutout at every feature map in a convolutional networks. In our experiments, having a fixed zero-out ratio for DropBlock during training is not as robust as having an increasing schedule for the ratio during training. In other words, it's better to set the DropBlock ratio to be small initially during training, and linearly increase it over time during training. This scheduling scheme is related to ScheduledDropPath~\cite{zoph2017learning}.

\section{DropBlock}
DropBlock is a simple method similar to dropout. Its main difference from dropout is that it drops contiguous regions from a feature map of a layer instead of dropping out independent random units. Pseudocode of  DropBlock is shown in Algorithm
\ref{pseudocode}.
DropBlock has two main parameters which are $block\_size$ and $\gamma$. $block\_size$ is the size of the block to be dropped, and $\gamma$, controls how many activation units to drop. 

We experimented with a shared DropBlock mask across different feature channels or each feature channel has its DropBlock mask. Algorithm \ref{pseudocode} corresponds to the latter, which tends to work better in our experiments.

\begin{algorithm}[t!]
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\caption{DropBlock}\label{pseudocode}
\begin{algorithmic}[1]
\State \algorithmicrequire output activations of a layer ($A$), ${block\_size}$, $\gamma$, $mode$


\If {${mode}$ == \textit{Inference} }
    \State {return $A$}
\EndIf

\State Randomly sample mask $M$: $M_{i,j} \sim Bernoulli(\gamma)$
\State For each zero position $M_{i,j}$, create a spatial square  mask with the center being $M_{i,j}$, the width, height being $block\_size$ and set all the values of $M$ in the square to be zero (see Figure~\ref{fig:expand}).
\State Apply the mask: $A = A \times {M}$
\State Normalize the features: $A = A \times \textbf{count} ({M}) / \textbf{count\_ones} (M)$
\end{algorithmic}
\end{algorithm}

\begin{figure}[t!]
  \centering
  \begin{tabular}{cc}
      \includegraphics[width=0.3\linewidth]{figs3/DropBlock_explain1_2.pdf}&
      \includegraphics[width=0.3\linewidth]{figs3/DropBlock_explain2.pdf}\\
      (a) & (b)\\
  \end{tabular}
  
  \caption{Mask sampling in DropBlock. (a) On every feature map, similar to dropout, we first sample a mask $M$. We only sample mask from shaded green region in which each sampled entry can expanded to a mask fully contained inside the feature map. (b) Every zero entry on $M$ is expanded to $block\_size \times block\_size$ zero block.}
  \label{fig:expand}
\end{figure}

Similar to dropout we do not apply DropBlock during inference. This is interpreted as evaluating
an averaged prediction across the exponentially-sized ensemble of sub-networks. These
sub-networks include a special subset of sub-networks covered by dropout where each network
does not see contiguous parts of feature maps.

\paragraph{Setting the value of $block\_size$.} In our implementation, we set a constant $block\_size$ for all feature maps, regardless the resolution of feature map. DropBlock resembles dropout \cite{dropout2014} when $block\_size=1$ and resembles SpatialDropout \cite{tompson2015spatialdropout} when $block\_size$ covers the full feature map.

\paragraph{Setting the value of $\gamma$.} In practice, we do not explicitly set $\gamma$. As stated earlier, $\gamma$ controls the number of features to drop. Suppose that we want to keep every activation unit with the probability of $keep\_prob$, in dropout~\cite{dropout2014} the binary mask will be sampled with the Bernoulli distribution with mean $1-keep\_prob$. However, to account for the fact that every zero entry in the mask will be expanded by $block\_size^2$ and the blocks will be fully contained in feature map, we need to adjust $\gamma$ accordingly when we sample the initial binary mask. In our implementation, $\gamma$ can be computed as

\begin{equation}
\gamma = \frac{1 - keep\_prob}{block\_size^2} \frac{feat\_size^2}{(feat\_size - block\_size + 1)^2}
\end{equation}

where $keep\_prob$ can be interpreted as the probability of keeping a unit in traditional dropout. The size of valid seed region is $(feat\_size - block\_size + 1)^2$ where $feat\_size$ is the size of feature map. The main nuance of DropBlock is that there will be some overlapped in the dropped blocks, so the above equation is only an approximation. In our experiments, we first estimate the $keep\_prob$ to use (between $0.75$ and $0.95$), and then compute $\gamma$ according to the above equation.

\paragraph{Scheduled DropBlock.} We found that DropBlock with a fixed $keep\_prob$ during training does not work well. Applying small value of $keep\_prob$ hurts learning at the beginning. Instead, gradually decreasing $keep\_prob$ over time from $1$ to the target value is more robust and adds improvement for the most values of $keep\_prob$. In our experiments, we use a linear scheme of decreasing the value of $keep\_prob$, which tends to work well across many hyperparameter settings. This linear scheme is similar to ScheduledDropPath~\cite{zoph2017learning}.



\section{Experiments}
In the following sections, we empirically investigate the effectiveness of DropBlock for image classification, object detection, and semantic segmentation. We apply DropBlock to ResNet-50~\cite{he2016deep} with extensive experiments for image classification. To verify the results can be transferred to a different architecture, we perform DropBlock on a state-of-the-art model architecture, AmoebaNet~\cite{real2018regularized}, and show improvements. In addition to image classification, We show DropBlock is helpful in training RetinaNet \cite{lin2017focalloss} for object detection and semantic segmentation.

\subsection{ImageNet Classification}
The ILSVRC 2012 classification dataset \cite{imagenet2009}
contains 1.2 million training images, 50,000 validation images, and 150,000 testing images. Images are labeled with 1,000 categories.
We used horizontal flip, scale, and aspect ratio augmentation for training images as in \cite{szegedy2015going, huang2017densely}. During evaluation, we applied a single-crop rather than averaging results over multiple crops. Following the common practice, we report classification accuracy on the validation set. 

\paragraph{Implementation Details}
We trained models on Tensor Processing Units (TPUs) and used the official Tensorflow implementations for  ResNet-50\footnote{https://github.com/tensorflow/tpu/tree/master/models/official/resnet}
and AmoebaNet\footnote{https://github.com/tensorflow/tpu/tree/master/models/experimental/amoeba\_net}. We used the \textit{default} image size ($224\times224$ for ResNet-50 and $331\times331$ for AmoebaNet), batch size (1024 for ResNet-50 and 2048 for AmoebaNet) and hyperparameters setting for all the models. We only increased number of training epochs from 90 to 270 for ResNet-50 architecture. The learning rate was decayed by the factor of $0.1$ at $125$, $200$  and $250$ epochs.
AmoebaNet models were trained for 340 epochs and exponential decay scheme was used for scheduling learning rate.
Since baselines are usually overfitted for the longer training scheme and have lower
validation accuracy at the end of training, we report the
highest validation accuracy over the full training course for fair comparison.
\subsubsection{DropBlock in ResNet-50}

ResNet-50 \cite{he2016deep} is a widely used Convolutional
Neural Network (CNN) architecture for image recognition. In the following experiments, we apply different regularization techniques on ResNet-50 and compare the results with DropBlock. The results are summarized in Table \ref{resnet50}.


\begin{table}[h!]
\setlength{\tabcolsep}{8pt}
\begin{center}
\small
\begin{tabular}{>{\footnotesize}l|>{\footnotesize}c>{\footnotesize}c}
\hline
  \footnotesize Model  & \footnotesize top-1(\%) & \footnotesize top-5(\%)\\
\hline \hline
\footnotesize ResNet-50                                         & 76.51  $\pm$ 0.07 & 93.20 $\pm$ 0.05\\ 
\hline
\footnotesize ResNet-50 + dropout (kp=0.7) \cite{dropout2014}   & 76.80 $\pm$ 0.04 & 93.41 $\pm$ 0.04 \\ 
\hline
\footnotesize ResNet-50 + DropPath (kp=0.9) \cite{fractalnet2017}          &77.10  $\pm$ 0.08 & 93.50 $\pm$ 0.05\\
\hline
\footnotesize ResNet-50 + SpatialDropout (kp=0.9) \cite{tompson2015spatialdropout}                & 77.41 $\pm$ 0.04 & 93.74 $\pm$ 0.02 \\
\hline
\footnotesize ResNet-50 + Cutout \cite{Cutout2017}                               & 76.52  $\pm$ 0.07 & 93.21  $\pm$ 0.04 \\ 
\hline
\footnotesize ResNet-50 + AutoAugment \cite{cubuk2018autoaugment}                         & 77.63 & 93.82 \\ 
\hline
\footnotesize ResNet-50 + label smoothing (0.1)  \cite{smoothsoftmax2015}                         & 77.17 $\pm0.05$ & 93.45 $\pm 0.03$\\
\hline
\hline
\footnotesize ResNet-50 + DropBlock, (kp=0.9)       & 78.13 $\pm$ 0.05 &  94.02 $\pm$ 0.02\\
\footnotesize ResNet-50 + DropBlock (kp=0.9) + label smoothing (0.1)     & 78.35 $\pm$ 0.05 &  94.15 $\pm$ 0.03\\ 
\hline
\end{tabular}
\end{center}
\caption{Summary of validation accuracy on ImageNet dataset for ResNet-50 architecture. For dropout, DropPath, and SpatialDropout, we trained models with different $keep\_prob$ values and reported the best result. DropBlock is applied with $block\_size=7$. We report average over 3 runs.}
\label{resnet50}
\end{table}

\paragraph{Where to apply DropBlock.}
In residual networks, a building block consists of a few convolution layers and a separate skip connection that performs identity mapping. Every convolution layer is followed by batch normalization layer and ReLU activation. The output of a building block is the sum of outputs from the convolution branch and skip connection.

A residual network can be represented by building groups based on the spatial resolution of feature activation. A building group consists of multiple building blocks. We use group 4 to represent the last group in residual network (i.e., all layers in conv5\_x) and so on. 

In the following experiments, we study where to apply DropBlock in residual networks. We experimented with applying DropBlock only after convolution layers or applying DropBlock after both convolution layers and skip connections. To study the performance of DropBlock applying to different feature groups, we experimented with applying DropBlock to Group 4 or to both Groups 3 and 4.

\begin{figure}[t!]
  \centering
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[width=\textwidth]{figs3/vary_keep_prob.pdf}
    \caption{}
  \end{subfigure}
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[width=\textwidth]{figs3/baselines2.pdf}
    \caption{}
  \end{subfigure}
  \caption{ImageNet validation accuracy against $keep\_prob$ with ResNet-50 model. All methods drop activation units in group 3 and 4.}
  \label{fig:resnet_vary_keepprob}
\end{figure}

\begin{figure}[t!]
  \centering
\begin{tabular}{>{\scriptsize\centering\arraybackslash}m{0.01\linewidth}>{\scriptsize\centering\arraybackslash}m{0.3\linewidth}>{\scriptsize\centering\arraybackslash}m{0.3\linewidth}>{\scriptsize\centering\arraybackslash}m{0.3\linewidth}}
\centering
&DropBlock wo/ scheduling and not on the skip connections& DropBlock wo/ scheduling & DropBlock\\\rotatebox[origin=c]{90}{Group 4 (resolution: 7x7)}&\includegraphics[width=0.95\linewidth]{figs3/group4_nosched_noskip.pdf}&\includegraphics[width=0.95\linewidth]{figs3/group4_noskip.pdf}&\includegraphics[width=0.95\linewidth]{figs3/group4.pdf}\\\rotatebox[origin=c]{90}{Groups 3\&4}&\includegraphics[width=0.95\linewidth]{figs3/groups34_nosched_noskip.pdf}&\includegraphics[width=0.95\linewidth]{figs3/groups34_noskip.pdf}&\includegraphics[width=0.95\linewidth]{figs3/groups34.pdf}\\\end{tabular}

  \caption{Comparison of ResNet-50 trained on ImageNet when DropBlock is applied to group 4 or groups 3 and 4. From left to right, we show performance of applying DropBlock on convolution branches only and progressively improve it by applying DropBlock on skip connections and adding scheduling $keep\_prob$. The best accuracy is achieved by using $block\_size=7$ (bottom right figure).}
  \label{fig:resnet_imagenet}
\end{figure}

\paragraph{DropBlock vs. dropout.}
The original ResNet architecture does not apply any dropout in the model. For the ease of discussion, we define the dropout baseline for ResNet as applying dropout on convolution branches only. We applied DropBlock to both groups 3 and 4 with $block\_size=7$ by default. We decreased $\gamma$ by factor 4 for group 3 in all the experiments. In Figure \ref{fig:resnet_vary_keepprob}-(a), we show that DropBlock outperforms dropout with 1.3\% for top-1 accuracy.
The scheduled $keep\_prob$ makes DropBlock more robust to the change of $keep\_prob$ and adds improvement for the most values of $keep\_prob$ (\ref{fig:resnet_vary_keepprob}-(b)).

With the best $keep\_prob$ found in Figure \ref{fig:resnet_vary_keepprob}, we swept over $block\_size$ from 1 to size covering full feature map. Figure \ref{fig:resnet_imagenet} shows applying larger $block\_size$ is generally better than applying $block\_size$ of 1. The best DropBlock configuration is to apply $block\_size=7$ to both groups 3 and 4.

In all configurations, DropBlock and dropout share the similar trend and DropBlock has a large gain compared to the best dropout result. This shows evidence that the DropBlock is a more effective regularizer compared to dropout. 

\paragraph{DropBlock vs. SpatialDropout.}
Similar as dropout baseline, we define the SpatialDropout \cite{tompson2015spatialdropout} baseline as applying it on convolution branches only. SpatialDropout is better than dropout but inferior to DropBlock. In Figure \ref{fig:resnet_imagenet}, we found SpatialDropout can be too harsh when applying to high resolution feature map on group 3. DropBlock achieves the best result by dropping block with constant size on both groups 3 and 4.

\paragraph{Comparison with DropPath.}
Following ScheduledDropPath~\cite{zoph2017learning} we applied scheduled DropPath on all  connections except the skip connections. We trained models with different values for $keep\_prob$ parameter. Also, we trained models where we applied DropPath in all groups and similar to our other experiments only at group 4 or at group 3 and 4. We achieved best validation accuracy of $77.10\%$ when we only apply it to group 4 with $keep\_prob=0.9$.

\paragraph{Comparison with Cutout.}
We also compared with Cutout \cite{Cutout2017} which is a data augmentation method and randomly drops a fixed size block from the input images. Although Cutout improves accuracy on the CIFAR-10 dataset as suggested by \cite{Cutout2017}, it does not improve the accuracy on the ImageNet dataset in our experiments.

\paragraph{Comparison with other regularization techniques.}
 We compare DropBlock to data augmentation and label smoothing, which are two commonly used regularization techniques. In Table \ref{resnet50}, DropBlock has better performance compared to strong data augmentation \cite{cubuk2018autoaugment} and label smoothing \cite{smoothsoftmax2015}. The performance improves when combining DropBlock and label smoothing and train for 290 epochs, showing the regularization techniques can be complimentary when we train for longer.

\subsubsection{DropBlock in AmoebaNet}
We also show the effectiveness of DropBlock on a recent AmoebaNet-B
architecture which is a state-of-art architecture, found using evolutionary architecture search \cite{real2018regularized}.
This model has dropout with keep probability of 0.5 but only on the the final softmax layer.

We apply DropBlock after all batch normalization layers and also in the skip connections
of the last $50\%$ of the cells. The resolution of the feature maps in these cells are 21x21 or 11x11 for input image with the size of 331x331. Based on the experiments in the last section, we used $keep\_prob$ of 0.9 and set $block\_size=11$ which is the width of the last feature map.
DropBlock improves top-1 accuracy of AmoebaNet-B from $82.25\%$ to $82.52\%$ (Table \ref{fig:AmoebaNet}).

\begin{table}[h!]
  \centering
        \begin{tabular}{l|cc}
            \hline
              \footnotesize Model  & \footnotesize top-1(\%) & \footnotesize top-5(\%)\\
            \hline \hline
            \footnotesize AmoebaNet-B (6, 256)                      & \footnotesize 82.25  &  95.88 \\
            \footnotesize AmoebaNet-B (6, 256) + DropBlock & \footnotesize 82.52  &  96.07 \\
        \hline
        \end{tabular}
  \caption{Top-1 and top-5 validation accuracy of AmoebaNet-B architecture trained on ImageNet.}
  \label{fig:AmoebaNet}
\end{table}

\begin{figure}[h!]
  \centering
  \begin{subfigure}[b]{0.48\textwidth}
      \includegraphics[width=\textwidth]{figs3/analysis_dp_test.pdf}
      \caption{Inference with $block\_size = 1$.}
  \end{subfigure}
  \begin{subfigure}[b]{0.48\textwidth}
      \includegraphics[width=\textwidth]{figs3/analysis_db_test.pdf}
      \caption{Inference with $block\_size = 7$.}
  \end{subfigure}
\caption{ResNet-50 model trained with $block\_size=7$ and $keep\_prob=0.9$ has higher accuracy compared to the ResNet-50 model trained with $block\_size=1$ and $keep\_prob=0.9$:
    (a) when we apply DropBlock with $block\_size=1$ at inference with different $keep\_prob$ or 
    (b) when we apply DropBlock with $block\_size=7$ at inference with different $keep\_prob$.
    The models are trained and evaluated with DropBlock at groups 3 and 4.  
    }
  \label{fig:analysis}
\end{figure}

\begin{figure}[h!]\centering \begin{tabular}{>{\centering\tiny} p{0.05cm}>{\tiny}c>{\tiny}c>{\tiny}c>{\tiny}c>{\tiny}c>{\tiny}c>{\tiny}c}&\bf{\input{figs/cam/188_label.txt}}&\bf{knot }
&\bf{\input{figs/cam/179_label.txt}}&\bf{bookshop }&
\bf{\input{figs/cam/46_label.txt}}&\bf{spiral }\\
\rotatebox{90}{\bf{\ \ \ \ input image}}&\includegraphics[width=0.12\linewidth]{figs/cam/188_image.jpg}&\includegraphics[width=0.12\linewidth]{figs/cam/29_image.jpg}&\includegraphics[width=0.12\linewidth]{figs/cam/86_image.jpg}&\includegraphics[width=0.12\linewidth]{figs/cam/179_image.jpg}&\includegraphics[width=0.12\linewidth]{figs/cam/46_image.jpg}&\includegraphics[width=0.12\linewidth]{figs/cam/39_image.jpg}\\\rotatebox{90}{\bf{\ original model}}&\includegraphics[width=0.12\linewidth]{figs/cam/188_map_orig.jpg}&\includegraphics[width=0.12\linewidth]{figs/cam/29_map_orig.jpg}&\includegraphics[width=0.12\linewidth]{figs/cam/86_map_orig.jpg}&\includegraphics[width=0.12\linewidth]{figs/cam/179_map_orig.jpg}&\includegraphics[width=0.12\linewidth]{figs/cam/46_map_orig.jpg}&\includegraphics[width=0.12\linewidth]{figs/cam/39_map_orig.jpg}\\\rotatebox{90}{\bf{\ \ \ block size: 1}}&\includegraphics[width=0.12\linewidth]{figs/cam/188_map_do.jpg}&\includegraphics[width=0.12\linewidth]{figs/cam/29_map_do.jpg}&\includegraphics[width=0.12\linewidth]{figs/cam/86_map_do.jpg}&\includegraphics[width=0.12\linewidth]{figs/cam/179_map_do.jpg}&\includegraphics[width=0.12\linewidth]{figs/cam/46_map_do.jpg}&\includegraphics[width=0.12\linewidth]{figs/cam/39_map_do.jpg}\\\rotatebox{90}{\bf{\ \ \ block size: 7}}&\includegraphics[width=0.12\linewidth]{figs/cam/188_map_db.jpg}&\includegraphics[width=0.12\linewidth]{figs/cam/29_map_db.jpg}&\includegraphics[width=0.12\linewidth]{figs/cam/86_map_db.jpg}&\includegraphics[width=0.12\linewidth]{figs/cam/179_map_db.jpg}&\includegraphics[width=0.12\linewidth]{figs/cam/46_map_db.jpg}&\includegraphics[width=0.12\linewidth]{figs/cam/39_map_db.jpg}\\\end{tabular}\caption{Class activation mapping (CAM) \cite{zhou2016dcam} for ResNet-50 model trained without DropBlock and trained with DropBlock with the $block\_size$ of 1 or 7. The model trained with DropBlock tends to focus on several spatially distributed regions.}\label{fig:cam}\end{figure}

\subsection{Experimental Analysis}
DropBlock demonstrates strong empirical results on improving ImageNet classification accuracy compared to dropout. We hypothesize dropout is insufficient because the contiguous regions in convolution layers are strongly correlated. Randomly dropping a unit still allows information to flow through neighboring units. In this section, we conduct an analysis to show DropBlock is more effective in dropping semantic information. Subsequently, the model regularized by DropBlock is more robust compared to model regularized by dropout. We study the problem by applying DropBlock with $block\_size$ of $1$ and $7$ during inference and observing the differences in performance.

\paragraph{DropBlock drops more semantic information.}
We first took the model trained without any regularization and tested it with DropBlock with $block\_size=1$ and $block\_size=7$. The green curves in Figure \ref{fig:analysis} show the validation accuracy reduced quickly with decreasing $keep\_prob$ during inference. This suggests DropBlock removes semantic information and makes classification more difficult.
The accuracy drops more quickly with decreasing $keep\_prob$, for $block\_size=1$ in comparison with $block\_size=7$ which suggests DropBlock is more effective to remove semantic information than dropout.

\paragraph{Model trained with DropBlock is more robust.}
Next we show that model trained with large block size, which removes more semantic information, results in stronger regularization. We demonstrate the fact by taking model trained with $block\_size=7$ and applied $block\_size=1$ during inference and vice versa. In Figure \ref{fig:analysis}, models trained with $block\_size=1$ and $block\_size=7$ are both robust with $block\_size=1$ applied during inference. However, the performance of model trained with $block\_size=1$ reduced more quickly with decreasing $keep\_prob$ when applying $block\_size=7$ during inference. The results suggest that $block\_size=7$ is more robust and has the benefit of $block\_size=1$ but not vice versa.

\paragraph{DropBlock learns spatially distributed representations.} We hypothesize model trained with DropBlock needs to learn spatially distributed representations because DropBlock is effective in removing semantic information in a contiguous region. The model regularized by DropBlock should learn multiple discriminative regions instead of only focusing on one discriminative region. We use class activation maps (CAM) introduced in \cite{zhou2016dcam} to visualize $conv5\_3$ class activations of ResNet-50 on ImageNet validation set. Figure \ref{fig:cam} shows the class activations of original model and models trained with DropBlock with $block\_size=1$ and $block\_size=7$. In general, models trained with DropBlock learn spatially distributed representations that induce high class activations on multiple regions, whereas model without regularization tends to focus on one or few regions.


\subsection{Object Detection in COCO}
DropBlock is a generic regularization module for CNNs. In this section, we show DropBlock can also be applied for training object detector in COCO dataset \cite{lin2014coco}. We use RetinaNet \cite{lin2017focalloss} framework for the experiments. Unlike an image classifier that predicts single label for an image, RetinaNet runs convolutionally on multiscale Feature Pyramid Networks (FPNs) \cite{lin2017fpn} to localize and classify objects in different scales and locations. We followed the model architecture and anchor definition in \cite{lin2017focalloss} to build FPNs and classifier/regressor branches.

\paragraph{Where to apply DropBlock to RetinaNet model.}
RetinaNet model uses ResNet-FPN as its backbone model. For simplicity, we apply DropBlock to ResNet in ResNet-FPN and use the best $keep\_prob$ we found for ImageNet classification training. DropBlock is different from recent work \cite{afastrcnn2017} which learns to drop a structured pattern on features of region proposals.

\paragraph{Training object detector from random initialization.}
Training object detector from random initialization has been considered as a challenging task. Recently, a few papers tried to address the issue using novel model architecture \cite{shen2017dsod}, large minibatch size \cite{peng2018dmegdet}, and better normalization layer \cite{wu2018gn}. In our experiment, we look at the problem from the model regularization perspective. We tried DropBlock with $keep\_prob=0.9$, which is the identical hyperparamters as training image classification model, and experimented with different $block\_size$. In Table \ref{table:retinanet}, we show that the model trained from random initialization surpasses ImageNet pre-trained model. Adding DropBlock gives additional 1.6\% AP. The results suggest model regularization is an important ingredient to train object detector from scratch and DropBlock is an effective regularization approach for object detection.

\begin{table}[h!]
\setlength{\tabcolsep}{8pt}
\begin{center}
\small
\begin{tabular}{l|cccccc}
\hline
  \footnotesize Model  & \footnotesize AP & \footnotesize AP50 & \footnotesize AP75 \\
\hline \hline
\footnotesize RetinaNet, fine-tuning from ImageNet & 36.5 & 55.0 & 39.1  \\
\hline
\footnotesize RetinaNet, no DropBlock            & 36.8 & 54.6 & 39.4 \\
\footnotesize RetinaNet, $keep\_prob=0.9$, $block\_size=1$  & 37.9 & 56.1 & 40.6 \\
\footnotesize RetinaNet, $keep\_prob=0.9$, $block\_size=3$  & 38.3 & 56.4 & 41.2 \\
\footnotesize RetinaNet, $keep\_prob=0.9$, $block\_size=5$  & 38.4 & 56.4 & 41.2 \\
\footnotesize RetinaNet, $keep\_prob=0.9$, $block\_size=7$  & 38.2 & 56.0 & 40.9 \\
\hline
\end{tabular}
\end{center}
\caption{Object detection results trained from random initialization in COCO using RetinaNet and ResNet-50 FPN backbone model.}
\label{table:retinanet}
\end{table}


\paragraph{Implementation details.}
We use open-source implementation of RetinaNet\footnote{https://github.com/tensorflow/tpu/tree/master/models/official/retinanet} for experiments. The models were trained on TPU with 64 images in a batch. During training, multiscale jitter was applied to resize images between scales [512, 768] and then the images were padded or cropped to max dimension 640. Only single scale image with max dimension 640 was used during testing. The batch normalization layers were applied after all convolution layers, including classifier/regressor branches. The model was trained using 150 epochs (280k training steps). The initial learning rate 0.08 was applied for first 120 epochs and decayed 0.1 at 120 and 140 epochs. The model with ImageNet initialization was trained for 28 epochs with learning decay at 16 and 22 epochs. We used $\alpha=0.25$ and $\gamma=1.5$ for focal loss. We used a weight decay of 0.0001 and a momentum of 0.9. The model was trained on COCO train2017 and evaluated on COCO val2017.



\subsection{Semantic Segmentation in PASCAL VOC}
We show DropBlock also improves semantic segmentation model. We use PASCAL VOC 2012 dataset for experiments and follow the common practice to train with augmented 10,582 training images \cite{vocdataset2012} and report mIOU on 1,449 test set images. We adopt open-source RetinaNet implementation for semantic segmentation. The implementation uses the ResNet-FPN backbone model to extract multiscale features and attaches fully convolution networks on top to predict segmentation. We use default hyperparameters in open-source code for training.

Following the experiments for object detection, we study the effect of DropBlock for training model from random initialization. We trained model started with pre-trained ImageNet model for 45 epochs and model with random initialization for 500 epochs. We experimented with applying DropBlock to ResNet-FPN backbone model and fully convolution networks and found apply DropBlock to fully convolution networks is more effective. Applying DropBlock greatly improves mIOU for training model from scratch and shrinks performance gap between training from ImageNet pre-trained model and randomly initialized model.


\begin{table}[h!]
\setlength{\tabcolsep}{8pt}
\begin{center}
\small
\begin{tabular}{l|cccccc}
\hline
  \footnotesize Model  & \footnotesize mIOU \\
\hline \hline
\footnotesize fine-tuning from ImageNet & 74.6  \\
\hline
\footnotesize no DropBlock               & 47.2\\
\footnotesize $keep\_prob=0.2$, $block\_size=1$  & 51.0 \\
\footnotesize $keep\_prob=0.2$, $block\_size=4$  & 53.2 \\
\footnotesize $keep\_prob=0.2$, $block\_size=16$  & 53.4 \\
\hline
\end{tabular}
\end{center}
\caption{Semantic segmentation results trained from random initialization in PASCAL VOC 2012 using ResNet-101 FPN backbone model.}
\label{table:retinanetseg}
\end{table}

\section{Discussion}
In this work, we introduce DropBlock to regularize training CNNs. DropBlock is a form of structured dropout that drops spatially correlated information. We demonstrate DropBlock is a more effective regularizer compared to dropout in ImageNet classification and COCO detection. DropBlock consistently outperforms dropout in an extensive experiment setup. We conduct an analysis to show that model trained with DropBlock is more robust and has the benefits of model trained with dropout. The class activation mapping suggests the model can learn more spatially distributed representations regularized by DropBlock.

Our experiments show that applying DropBlock in skip connections in addition to the convolution layers increases the accuracy. Also, gradually increasing number of dropped units during training leads to better accuracy and more robust to hyperparameter choices.


\small
\bibliography{main}
\bibliographystyle{unsrt}


\end{document}
