\documentclass{article} \usepackage{iclr2019_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{$\eta$}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage[colorlinks=true,linkcolor=blue,urlcolor=blue,citecolor=blue]{hyperref}
\usepackage{graphicx}
\usepackage{color}
\usepackage{subcaption}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{multirow}
\usepackage{natbib}

\usepackage{pifont}
\newcommand{\minisection}[1]{\vspace{5pt}\noindent\textbf{#1.}}
\newcommand{\xmark}{\text{\ding{55}}}
\newcommand{\cmark}{\text{\ding{51}}}

\title{ProxylessNAS: Direct Neural Architecture Search on Target Task and Hardware}

\iclrfinalcopy

\author{Han Cai, Ligeng Zhu, Song Han \\
Massachusetts Institute of Technology \\
\texttt{\{hancai, ligeng, songhan\}@mit.edu} \\
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\begin{document}

\maketitle

\begin{abstract}
Neural architecture search (NAS) has a great impact by automatically designing effective neural network architectures. However, the prohibitive computational demand of conventional NAS algorithms (e.g. $10^4$ GPU hours) makes it difficult to \emph{directly} search the architectures on large-scale tasks (e.g. ImageNet). Differentiable NAS can reduce the cost of GPU hours via a continuous representation of network architecture but suffers from the high GPU memory consumption issue (grow linearly w.r.t. candidate set size). As a result, they need to utilize~\emph{proxy} tasks, such as training on a smaller dataset, or learning with only a few blocks, or training just for a few epochs. These architectures optimized on proxy tasks are not guaranteed to be optimal on the target task. 
In this paper, we present \emph{ProxylessNAS} that can \emph{directly} learn the architectures for large-scale target tasks and target hardware platforms.  
We address the high memory consumption issue of differentiable NAS and reduce the computational cost (GPU hours and GPU memory) to the same level of regular training while still allowing a large candidate set. 
Experiments on CIFAR-10 and ImageNet demonstrate the effectiveness of directness and specialization. On CIFAR-10, our model achieves 2.08\% test error with only 5.7M parameters, better than the previous state-of-the-art architecture AmoebaNet-B, while using 6$\times$ fewer parameters. On ImageNet, our model achieves 3.1\% better top-1 accuracy than MobileNetV2, while being 1.2$\times$ faster with measured GPU latency. 
We also apply ProxylessNAS to specialize neural architectures for hardware with direct hardware metrics (e.g. latency) and provide insights for efficient CNN architecture design.\footnote{Pretrained models and evaluation code are released at \href{https://github.com/MIT-HAN-LAB/ProxylessNAS}{https://github.com/MIT-HAN-LAB/ProxylessNAS}.}
\end{abstract}

\section{Introduction}
Neural architecture search (NAS) has demonstrated much success in automating neural network architecture design for various deep learning tasks, such as image recognition
\citep{zoph2017learning,cai2018efficient,liu2017progressive,zhong2018practical} and language modeling \citep{zoph2016neural}.
Despite the remarkable results, conventional NAS algorithms are prohibitively computation-intensive, requiring to train thousands of models on the target task in a single experiment. Therefore, directly applying NAS to a large-scale task (e.g. ImageNet) is computationally expensive or impossible, which makes it difficult for making practical industry impact. 
As a trade-off, \citet{zoph2017learning} propose to search for building blocks on proxy tasks, such as training for fewer epochs, starting with a smaller dataset (e.g. CIFAR-10), or learning with fewer blocks. Then top-performing blocks are stacked and transferred to the large-scale target task. This paradigm has been widely adopted in subsequent NAS algorithms \citep{liu2017progressive,liu2017hierarchical,real2018regularized,cai2018path,liu2018darts,tan2018mnasnet,luo2018neural}. 

However, these blocks optimized on proxy tasks are not guaranteed to be optimal on the target task, especially when taking hardware metrics such as latency into consideration. 
More importantly, to enable transferability, such methods need to search for only a few architectural motifs and then repeatedly stack the same pattern, which restricts the block diversity and thereby harms performance. 

In this work, we propose a simple and effective solution to the aforementioned limitations, called \emph{ProxylessNAS}, which directly learns the architectures on the target task and hardware instead of with proxy (Figure~\ref{fig:proxyless}). We also remove the restriction of repeating blocks in previous NAS works \citep{zoph2017learning,liu2018darts} and allow all of the blocks to be learned and specified. 
To achieve this, we reduce the computational cost (GPU hours and GPU memory) of architecture search to the same level of regular training in the following ways.

GPU hour-wise, inspired by recent works \citep{liu2018darts,bender2018understanding}, we formulate NAS as a path-level pruning process. Specifically, we directly train an over-parameterized network that contains all candidate paths (Figure~\ref{fig:method}). During training, we explicitly introduce architecture parameters to learn which paths are redundant, while these redundant paths are pruned at the end of training to get a compact optimized architecture. In this way, we only need to train a single network without any meta-controller (or hypernetwork) during architecture search.

However, naively including all the candidate paths leads to GPU memory explosion \citep{liu2018darts,bender2018understanding}, as the memory consumption grows linearly w.r.t. the number of choices. Thus, GPU memory-wise, we binarize the architecture parameters (1 or 0) and force only one path to be active at run-time, which reduces the required memory to the same level of training a compact model. We propose a gradient-based approach to train these binarized parameters based on BinaryConnect \citep{courbariaux2015binaryconnect}. Furthermore, to handle non-differentiable hardware objectives (using latency as an example) for learning specialized network architectures on target hardware, we model network latency as a continuous function and optimize it as regularization loss. Additionally, we also present a REINFORCE-based \citep{williams1992simple} algorithm as an alternative strategy to handle hardware metrics.

\begin{figure}[t]
    \vspace{-10pt}
    \centering
    \includegraphics[width=1\linewidth]{figures/proxyless-crop.pdf}
    \caption{ProxylessNAS directly optimizes neural network architectures on target task and hardware. Benefiting from the directness and specialization, ProxylessNAS can achieve remarkably better results than previous proxy-based approaches. On ImageNet, with only 200 GPU hours (200 $\times$ fewer than MnasNet \citep{tan2018mnasnet}), our searched CNN model for mobile achieves the same level of top-1 accuracy as MobileNetV2 1.4 while being 1.8$\times$ faster.}
    \vspace{-10pt}
    \label{fig:proxyless}
\end{figure}

In our experiments on CIFAR-10 and ImageNet, benefiting from the directness and specialization, our method can achieve strong empirical results. On CIFAR-10, our model reaches 2.08\% test error with only 5.7M parameters. On ImageNet, our model achieves 75.1\% top-1 accuracy which is 3.1\% higher than MobileNetV2 \citep{sandler2018mobilenetv2} while being 1.2$\times$ faster. Our contributions can be summarized as follows:

\begin{itemize}
\item ProxylessNAS is the first NAS algorithm that directly learns architectures on the large-scale dataset (e.g. ImageNet) without any proxy while still allowing a large candidate set and removing the restriction of repeating blocks. It effectively enlarged the search space and achieved better performance. 
    \item We provide a new path-level pruning perspective for NAS, showing a close connection between NAS and model compression \citep{han2015deep}. We save memory consumption by one order of magnitude by using path-level binarization.
    \item We propose a novel gradient-based approach (latency regularization loss) for handling hardware objectives (e.g. latency). Given different hardware platforms: CPU/GPU/Mobile, ProxylessNAS enables hardware-aware neural network specialization that's exactly optimized for the target hardware. To our best knowledge, it is the first work to study specialized \emph{neural network architectures} for different \emph{hardware architectures}. \item Extensive experiments showed the advantage of the directness property and the specialization property of ProxylessNAS. It achieved state-of-the-art accuracy performances on CIFAR-10 and ImageNet under latency constraints on different hardware platforms (GPU, CPU and mobile phone). We also analyze the insights of efficient CNN models specialized for different hardware platforms and raise the awareness that specialized neural network architecture is needed on different hardware architectures for efficient inference. 
\end{itemize}
 
\section{Related Work}
The use of machine learning techniques, such as reinforcement learning or neuro-evolution, to replace human experts in designing neural network architectures, usually referred to as neural architecture search, has drawn an increasing interest \citep{zoph2016neural,liu2017progressive,liu2017hierarchical,liu2018darts,cai2018efficient,cai2018path,pham2018efficient,brock2017smash,bender2018understanding,elsken2017simple,elsken2018neural,kamath2018neural}. In NAS, architecture search is typically considered as a meta-learning process, and a meta-controller (e.g. a recurrent neural network (RNN)), is introduced to explore a given architecture space with training a network in the inner loop to get an evaluation for guiding exploration. Consequently, such methods are computationally expensive to run, especially on large-scale tasks, e.g. ImageNet. 

Some recent works \citep{brock2017smash,pham2018efficient} try to improve the efficiency of this meta-learning process by reducing the cost of getting an evaluation. In \cite{brock2017smash}, a hypernetwork is utilized to generate weights for each sampled network and hence can evaluate the architecture without training it. Similarly, \cite{pham2018efficient} propose to share weights among all sampled networks under the standard NAS framework \citep{zoph2016neural}. These methods speed up architecture search by orders of magnitude, however, they require a hypernetwork or an RNN controller and mainly focus on small-scale tasks (e.g. CIFAR) rather than large-scale tasks (e.g. ImageNet).

Our work is most closely related to One-Shot~\citep{bender2018understanding} and DARTS~\citep{liu2018darts}, both of which get rid of the meta-controller (or hypernetwork) by modeling NAS as a single training process of an over-parameterized network that comprises all candidate paths. Specifically, One-Shot trains the over-parameterized network with DropPath \citep{zoph2017learning} that drops out each path with some fixed probability. Then they use the pre-trained over-parameterized network to evaluate architectures, which are sampled by randomly zeroing out paths. DARTS additionally introduces a real-valued architecture parameter for each path and jointly train weight parameters and architecture parameters via standard gradient descent. However, they suffer from the large GPU memory consumption issue and hence still need to utilize proxy tasks. In this work, we address the large memory issue in these two methods through path binarization.

Another relevant topic is network pruning \citep{han2015deep} that aim to improve the efficiency of neural networks by removing insignificant neurons \citep{han2015learning} or channels \citep{liu2017learning}.
Similar to these works, we start with an over-parameterized network and then prune the redundant parts to derive the optimized architecture.  
The distinction is that they focus on layer-level pruning that only modifies the filter (or units) number of a layer but can not change the topology of the network, while we focus on learning effective network architectures through \emph{path-level pruning}. We also allow both pruning and growing the number of layers.

 
\section{Method}
We first describe the construction of the over-parameterized network with all candidate paths, then introduce how we leverage binarized architecture parameters to reduce the memory consumption of training the over-parameterized network to the same level as regular training. We propose a gradient-based algorithm to train these binarized architecture parameters. Finally, we present two techniques to handle non-differentiable objectives (e.g. latency) for specializing neural networks on target hardware.

\begin{figure}[t]
    \vspace{-10pt}
	\centering
	\includegraphics[width=1\linewidth]{figures/method.pdf}
\caption{Learning both weight parameters and binarized architecture parameters.}
	\label{fig:method}
\end{figure}

\subsection{Construction of Over-Parameterized Network}\label{sec:over-parameterized}
Denote a neural network as $\mathcal{N}(e, \cdots, e_n)$ where $e_i$ represents a certain edge in the directed acyclic graph (DAG). Let $\mathcal{O} = \{o_i\}$ be the set of $N$ candidate primitive operations (e.g. convolution, pooling, identity, zero, etc). To construct the over-parameterized network that includes any architecture in the search space, instead of setting each edge to be a definite primitive operation, we set each edge to be a mixed operation that has $N$ parallel paths (Figure~\ref{fig:method}), denoted as $m_\mathcal{O}$. As such, the over-parameterized network can be expressed as $\mathcal{N}(e = m^{1}_\mathcal{O}, \cdots, e_n = m^{n}_\mathcal{O})$. 

Given input $x$, the output of a mixed operation $m_\mathcal{O}$ is defined based on the outputs of its $N$ paths. In One-Shot, $m_\mathcal{O}(x)$ is the sum of $\{o_i(x)\}$, while in DARTS, $m_\mathcal{O}(x)$ is weighted sum of $\{o_i(x)\}$ where the weights are calculated by applying softmax to $N$ real-valued architecture parameters $\{\alpha_i\}$:
\begin{equation}\label{eq:mix_others}
    m_\mathcal{O}^{\text{One-Shot}}(x) = \sum_{i=1}^N o_i(x), \qquad
    m_\mathcal{O}^{\text{DARTS}}(x) = \sum_{i=1}^N p_i o_i(x) = \sum_{i=1}^N \frac{\exp(\alpha_i)}{\sum_{j} \exp(\alpha_j)} o_i(x).
\end{equation}
As shown in Eq.~(\ref{eq:mix_others}), the output feature maps of all N paths are calculated and stored in the memory, while training a compact model only involves one path. Therefore, One-Shot and DARTS roughly need $N$ times GPU memory and GPU hours compared to training a compact model. On large-scale dataset, this can easily exceed the memory limits of hardware with large design space. In the following section, we solve this memory issue based on the idea of path binarization.

\subsection{Learning Binarized Path}
\label{sec:binarized_path_learning}
To reduce memory footprint, we keep only one path when training the over-parameterized network. Unlike \citet{courbariaux2015binaryconnect} which binarize individual weights, we binarize entire paths. We introduce $N$ real-valued architecture parameters $\{\alpha_i\}$ and then transforms the real-valued path weights to binary gates: 
\begin{equation}
\label{eq:gates}
    g = \text{binarize}(p_1, \cdots, p_N) = 
    \begin{cases}
        [1, 0, \cdots, 0] & \text{with probability $p_1$}, \\
        ~~~~~~~~\cdots \\
        [0, 0, \cdots, 1] & \text{with probability $p_N$}. \\
    \end{cases}
\end{equation}
Based on the binary gates $g$, the output of the mixed operation is given as:
\begin{equation}
\label{eq:mix_binary}
    m_\mathcal{O}^{\text{Binary}}(x) = \sum_{i=1}^N g_i o_i(x) = 
    \begin{cases}
    o_1(x) & \text{with probability $p_1$} \\
    ~~\cdots \\
    o_N(x) & \text{with probability $p_N$}. \\
    \end{cases}
    .
\end{equation}

As illustrated in Eq.~(\ref{eq:mix_binary}) and Figure~\ref{fig:method}, by using the binary gates rather than real-valued path weights \citep{liu2018darts}, only one path of activation is active in memory at run-time and the memory requirement of training the over-parameterized network is thus reduced to the same level of training a compact model. That's more than an order of magnitude memory saving. 

\subsubsection{Training Binarized Architecture Parameters}
\label{sec:grad_algo}
Figure~\ref{fig:method} illustrates the training procedure of the weight parameters and binarized architecture parameters in the over-parameterized network. When training weight parameters, we first freeze the architecture parameters and stochastically sample binary gates according to Eq.~(\ref{eq:gates}) for each batch of input data. Then the weight parameters of active paths are updated via standard gradient descent on the training set (Figure~\ref{fig:method} left). When training architecture parameters, the weight parameters are frozen, then we reset the binary gates and update the architecture parameters on the validation set (Figure~\ref{fig:method} right). These two update steps are performed in an alternative manner. Once the training of architecture parameters is finished, we can then derive the compact architecture by pruning redundant paths. In this work, we simply choose the path with the highest path weight.

Unlike weight parameters, the architecture parameters are not directly involved in the computation graph and thereby cannot be updated using the standard gradient descent. In this section, we introduce a gradient-based approach to learn the architecture parameters.

In BinaryConnect~\citep{courbariaux2015binaryconnect}, the real-valued weight is updated using the gradient w.r.t. its corresponding binary gate. In our case, analogously, the gradient w.r.t. architecture parameters can be approximately estimated using $\partial L / \partial g_i$ in replace of $\partial L / \partial p_i$:
\begin{equation}
\label{eq:binary_full}
    \frac{\partial L}{\partial \alpha_i} = \sum_{j = 1}^{N} \frac{\partial L}{\partial p_j} \frac{\partial p_j}{\partial \alpha_i} \approx 
    \sum_{j = 1}^{N} \frac{\partial L}{\partial g_j} \frac{\partial p_j}{\partial \alpha_i} = \sum_{j = 1}^{N} \frac{\partial L}{\partial g_j} \frac{\partial \Big(\frac{\exp(\alpha_j)}{\sum_{k} \exp(\alpha_k)} \Big) }{\partial \alpha_i} = 
    \sum_{j = 1}^{N} \frac{\partial L}{\partial g_j} p_j (\delta_{ij} - p_i),
\end{equation}
where $\delta_{ij} = 1$ if $i = j$ and $\delta_{ij} = 0$ if $i \neq j$. Since the binary gates $g$ are involved in the computation graph, as shown in Eq.~(\ref{eq:mix_binary}), $\partial L / \partial g_j$ can be calculated through backpropagation. However, computing $\partial L / \partial g_j$  requires to calculate and store $o_j(x)$. Therefore, directly using Eq.~(\ref{eq:binary_full}) to update the architecture parameters would also require roughly $N$ times GPU memory compared to training a compact model.

To address this issue, we consider factorizing the task of choosing one path out of N candidates into multiple binary selection tasks. The intuition is that if a path is the best choice at a particular position, it should be the better choice when solely compared to any other path.\footnote{In Appendix~\ref{sec:grad_discussion}, we provide another solution to this issue that does not require the approximation.}

Following this idea, within an update step of the architecture parameters, we first sample two paths according to the multinomial distribution $(p_1, \cdots, p_N)$ and mask all the other paths as if they do not exist. As such the number of candidates temporarily decrease from $N$ to 2, while the path weights $\{p_i\}$ and binary gates $\{g_i\}$ are reset accordingly. Then we update the architecture parameters of these two sampled paths using the gradients calculated via Eq.~(\ref{eq:binary_full}). Finally, as path weights are computed by applying softmax to the architecture parameters, we need to rescale the value of these two updated architecture parameters by multiplying a ratio to keep the path weights of unsampled paths unchanged. As such, in each update step, one of the sampled paths is enhanced (path weight increases) and the other sampled path is attenuated (path weight decreases) while all other paths keep unchanged. In this way, regardless of the value of $N$, only two paths are involved in each update step of the architecture parameters, and thereby the memory requirement is reduced to the same level of training a compact model.

\subsection{Handling Non-differentiable Hardware Metrics}
Besides accuracy, latency (not FLOPs) is another very important objective when designing efficient neural network architectures for hardware. Unfortunately, unlike accuracy that can be optimized using the gradient of the loss function, latency is non-differentiable. In this section, we present two algorithms to handle the non-differentiable objectives. 

\subsubsection{Making Latency Differentiable}
To make latency differentiable, we model the latency of a network as a continuous function of the neural network dimensions \footnote{Details of the latency prediction model are provided in Appendix~\ref{sec:latency_prediction_model}.}. Consider a mixed operation with a candidate set $\{o_j\}$ and each $o_j$ is associated with a path weight $p_j$ which represents the probability of choosing $o_j$. As such, we have the expected latency of a mixed operation (i.e. a learnable block) as:
\begin{equation}\label{eq:expected_latency_block}
    \mathbb{E} [\text{latency}_i] = \sum_j p_j^i \times F(o_j^i),
\end{equation}
where $\mathbb{E} [\text{latency}_i]$ is the expected latency of the $i^{th}$ learnable block, $F(\cdot)$ denotes the latency prediction model and $F(o_j^i)$ is the predicted latency of $o_j^i$. The gradient of $\mathbb{E} [\text{latency}_i]$ w.r.t. architecture parameters can thereby be given as: $\partial \mathbb{E} [\text{latency}_i]~/~\partial p_j^i = F(o_j^i)$.

\begin{figure}[t]
\centering
    \includegraphics[width=1\linewidth]{figures/method_illustration.pdf}
\caption{Making latency differentiable by introducing latency regularization loss.}
    \label{fig:expected_latency}
\end{figure}

For the whole network with a sequence of mixed operations (Figure~\ref{fig:expected_latency} left), since these operations are executed sequentially during inference, the expected latency of the network can be expressed with the sum of these mixed operations' expected latencies:
\begin{equation}\label{eq:expected_latency_net}
    \mathbb{E} [\text{latency}] = \sum_i \mathbb{E} [\text{latency}_i],
\end{equation}
We incorporate the expected latency of the network into the normal loss function by multiplying a scaling factor $\lambda_2 (> 0)$ which controls the trade-off between accuracy and latency. The final loss function is given as (also shown in Figure~\ref{fig:expected_latency} right)
\begin{equation}
    Loss = Loss_{CE} + \lambda_1 ||w||_2^2 +  {\color{red} \lambda_2 \mathbb{E}[\text{latency}]},
\end{equation}
where $Loss_{CE}$ denotes the cross-entropy loss and $\lambda_1 ||w||_2^2$ is the weight decay term. 

\subsubsection{REINFORCE-based Approach}\label{sec:reinforce_algo}
As an alternative to BinaryConnect, we can utilize REINFORCE to train binarized weights as well. Consider a network that has binarized parameters $\alpha$, the goal of updating binarized parameters is to find the optimal binary gates $g$ that maximizes a certain reward, denoted as $R(\cdot)$. Here we assume the network only has one mixed operation for ease of illustration. Therefore, according to REINFORCE \citep{williams1992simple}, we have the following updates for binarized parameters:
\begin{align}
\label{eq:reinforce}
    J(\alpha) &= \mathbb{E}_{g \sim \alpha}[R(\mathcal{N}_g)] 
               = \sum_i p_i R(\mathcal{N}(e = o_i)), \nonumber \\
    \nabla_\alpha J(\alpha) &= \sum_i R(\mathcal{N}(e = o_i)) \nabla_\alpha p_i = \sum_i R(\mathcal{N}(e = o_i)) p_i \nabla_\alpha \log(p_i), \nonumber \\
    &= \mathbb{E}_{g \sim \alpha} [R(\mathcal{N}_g) \nabla_\alpha \log(p(g))]
    \approx \frac{1}{M} \sum_{i=1}^M R(\mathcal{N}_{g^i}) \nabla_\alpha \log(p(g^i)),
\end{align}
where $g^i$ denotes the $i^{th}$ sampled binary gates, $p(g^i)$ denotes the probability of sampling $g^i$ according to Eq.~(\ref{eq:gates}) and $\mathcal{N}_{g^i}$ is the compact network according to the binary gates $g^i$. Since Eq.~(\ref{eq:reinforce}) does not require $R(\mathcal{N}_g)$ to be differentiable w.r.t. $g$, it can thus handle non-differentiable objectives. An interesting observation is that Eq.~(\ref{eq:reinforce}) has a similar form to the standard NAS \citep{zoph2016neural}, while it is not a sequential decision-making process and no RNN meta-controller is used in our case. Furthermore, since both gradient-based updates and REINFORCE-based updates are essentially two different update rules to the same binarized architecture parameters, it is possible to combine them to form a new update rule for the architecture parameters. 
 
\section{Experiments and Results}
We demonstrate the effectiveness of our proposed method on two benchmark datasets (CIFAR-10 and ImageNet) for the image classification task. Unlike previous NAS works \citep{zoph2017learning,liu2018darts} that first learn CNN blocks on CIFAR-10 under small-scale setting (e.g. fewer blocks), then transfer the learned block to ImageNet or CIFAR-10 under large-scale setting by repeatedly stacking it, we directly learn the architectures on the target task (either CIFAR-10 or ImageNet) and target hardware (GPU, CPU and mobile phone) while allowing each block to be specified. 

\begin{table}[t]
    \vspace{-10pt}
    \centering
    \begin{tabular}{l | c | c }
    	\hline
    	Model & Params & Test error (\%) \\
    	\hline
    	DenseNet-BC \citep{huang2017densely} & 25.6M & 3.46 \\ 
    	PyramidNet \citep{han2017deep} & 26.0M & 3.31 \\
    	Shake-Shake + c/o \citep{devries2017improved} & 26.2M & 2.56 \\
    	PyramidNet + SD \citep{yamada2018shakedrop} & 26.0M & 2.31 \\
    	\hline
    	ENAS + c/o \citep{pham2018efficient} & 4.6M & 2.89 \\
    	DARTS + c/o \citep{liu2018darts} & 3.4M & 2.83 \\
    	NASNet-A + c/o \citep{zoph2017learning} & 27.6M & 2.40 \\
    	PathLevel EAS + c/o \citep{cai2018path} & 14.3M & 2.30 \\
    	AmoebaNet-B + c/o \citep{real2018regularized} & 34.9M & 2.13 \\
    	\hline
    	Proxyless-R + c/o (ours) & 5.8M & 2.30 \\ 
    	Proxyless-G + c/o (ours) & 5.7M & \textbf{2.08} \\
    	\hline
    \end{tabular}
    \caption{ ProxylessNAS achieves state-of-the-art performance on CIFAR-10.}\label{tab:cifar_main}
\end{table}

\subsection{Experiments on CIFAR-10}
\minisection{Architecture Space}
For CIFAR-10 experiments, we use the tree-structured architecture space that is introduced by \cite{cai2018path} with PyramidNet \citep{han2017deep} as the backbone\footnote{The list of operations in the candidate set is provided in the appendix.}. Specifically, we replace all $3 \times 3$ convolution layers in the residual blocks of a PyramidNet with tree-structured cells, each of which has a depth of 3 and the number of branches is set to be 2 at each node (except the leaf nodes). 
For further details about the tree-structured architecture space, we refer to the original paper \citep{cai2018path}. Additionally, we use two hyperparameters to control the depth and width of a network in this architecture space, i.e. $B$ and $F$, which respectively represents the number of blocks at each stage (totally 3 stages) and the number of output channels of the final block. 

\minisection{Training Details} We randomly sample 5,000 images from the training set as a validation set for learning architecture parameters which are updated using the Adam optimizer with an initial learning rate of 0.006 for the gradient-based algorithm (Section~\ref{sec:grad_algo}) and 0.01 for the REINFORCE-based algorithm (Section~\ref{sec:reinforce_algo}). In the following discussions, we refer to these two algorithms as \textbf{Proxyless-G} (gradient) and \textbf{Proxyless-R} (REINFORCE) respectively. 

After the training process of the over-parameterized network completes, a compact network is derived according to the architecture parameters, as discussed in Section~\ref{sec:grad_algo}. Next, we train the compact network using the same training settings except that the number of training epochs increases from 200 to 300. Additionally, when the DropPath regularization \citep{zoph2017learning,huang2016deep} is adopted, we further increase the number of training epochs to 600 \citep{zoph2017learning}. 

\minisection{Results} We apply the proposed method to learn architectures in the tree-structured architecture space with $B = 18$ and $F = 400$. Since we do not repeat cells and each cell has 12 learnable edges, totally $12 \times 18 \times 3 = 648$ decisions are required to fully determine the architecture.

The test error rate results of our proposed method and other state-of-the-art architectures on CIFAR-10 are summarized in Table~\ref{tab:cifar_main}, where ``c/o'' indicates the use of Cutout \citep{devries2017improved}. Compared to these state-of-the-art architectures, our proposed method can achieve not only lower test error rate but also better parameter efficiency. Specifically, Proxyless-G reaches a test error rate of 2.08\% which is slightly better than AmoebaNet-B \citep{real2018regularized} (the previous best architecture on CIFAR-10). Notably, AmoebaNet-B uses 34.9M parameters while our model only uses 5.7M parameters which is $6 \times$ fewer than AmoebaNet-B. 
Furthermore, compared with PathLevel EAS \citep{cai2018path} that also explores the tree-structured architecture space, both Proxyless-G and Proxyless-R achieves similar or lower test error rate results with half fewer parameters. 
The strong empirical results of our ProxylessNAS demonstrate the benefits of directly exploring a large architecture space instead of repeatedly stacking the same block. 

\subsection{Experiments on ImageNet}
For ImageNet experiments, we focus on learning efficient CNN architectures \citep{iandola2016squeezenet,howard2017mobilenets,sandler2018mobilenetv2,zhu2018sparsenet} that have not only high accuracy but also low latency on specific hardware platforms. Therefore, it is a multi-objective NAS task \citep{hsu2018monas,dong2018dpp,elsken2018multi,he2018amc,wang2019haq,tan2018mnasnet}, where one of the objectives is non-differentiable (i.e. latency). We use three different hardware platforms, including mobile phone, GPU and CPU, in our experiments. The GPU latency is measured on V100 GPU with a batch size of 8 (single batch makes GPU severely under-utilized). The CPU latency is measured under batch size 1 on a server with two 2.40GHz Intel(R) Xeon(R) CPU E5-2640 v4. The mobile latency is measured on Google Pixel 1 phone with a batch size of 1. For Proxyless-R, we use $ACC(m) \times [ LAT(m) / T]^w$ as the optimization goal, where $ACC(m)$ denotes the accuracy of model $m$, $LAT(m)$ denotes the latency of $m$, $T$ is the target latency and $w$ is a hyperparameter for controlling the trade-off between accuracy and latency. 

Additionally, on mobile phone, we use the latency prediction model (Appendix~\ref{sec:latency_prediction_model}) during architecture search. As illustrated in Figure~\ref{fig:latency_prediction}, we observe a strong correlation between the predicted latency and real measured latency on the test set, suggesting that the latency prediction model can be used to replace the expensive mobile farm infrastructure \citep{tan2018mnasnet} with little error introduced. 

\minisection{Architecture Space} We use MobileNetV2 \citep{sandler2018mobilenetv2} as the backbone to build the architecture space. Specifically, rather than repeating the same mobile inverted bottleneck convolution (MBConv), we allow a set of MBConv layers with various kernel sizes $\{3, 5, 7\}$ and expansion ratios $\{3, 6\}$. To enable a direct trade-off between width and depth, we initiate a deeper over-parameterized network and allow a block with the residual connection to be skipped by adding the zero operation to the candidate set of its mixed operation. In this way, with a limited latency budget, the network can either choose to be shallower and wider by skipping more blocks and using larger MBConv layers or choose to be deeper and thinner by keeping more blocks and using smaller MBConv layers.

\minisection{Training Details} We randomly sample 50,000 images from the training set as a validation set during the architecture search. The settings for updating architecture parameters are the same as CIFAR-10 experiments except the initial learning rate is 0.001. The over-parameterized network is trained on the remaining training images with batch size 256. 

\begin{table}[t]
    \centering
\begin{tabular}{c}
    \begin{minipage}{1\linewidth}
        \begin{tabular}{l | c | c | c | c | c | c | c }
            \hline
            \multirow{2}{*}{Model} & \multirow{2}{*}{Top-1} & \multirow{2}{*}{Top-5} & Mobile & $\!\!$Hardware$\!\!$ & No & No & $\!\!$Search cost$\!\!$ \\
            & & & Latency & -aware & Proxy & Repeat & $\!\!$(GPU hours)$\!\!$ \\
            \hline
            MobileNetV1 [\citenum{howard2017mobilenets}] & 70.6 & 89.5 & 113ms & - & - & \xmark & Manual \\
            MobileNetV2 [\citenum{sandler2018mobilenetv2}] & 72.0 & 91.0 & 75ms & - & - & \xmark & Manual \\
            \hline 
            NASNet-A [\citenum{zoph2017learning}] & 74.0 & 91.3 & 183ms & \xmark & \xmark & \xmark & $48,000$ \\
            AmoebaNet-A [\citenum{real2018regularized}] & 74.5 & 92.0 & 190ms & \xmark & \xmark & \xmark & $75,600$ \\
            MnasNet [\citenum{tan2018mnasnet}] & 74.0 & 91.8 & 76ms & \cmark & \xmark & \xmark & $40,000$  \\
            MnasNet (our impl.) & 74.0 & 91.8 & 79ms & \cmark & \xmark & \xmark & $40,000$ \\
            \hline 
            Proxyless-G (mobile)$\!\!$ & 71.8 & 90.3 & 83ms & \xmark & \cmark & \cmark & $200$ \\
            Proxyless-G + LL & 74.2 & 91.7 & 79ms & \cmark & \cmark & \cmark & $200$ \\
            Proxyless-R (mobile)$\!\!$ & \textbf{74.6} & \textbf{92.2} & 78ms & \cmark & \cmark & \cmark & $200$
            \\
            \hline
        \end{tabular}
    \end{minipage}
    \end{tabular}
\caption{ProxylessNAS achieves state-of-the art accuracy (\%) on ImageNet (under mobile latency constraint $\leq 80ms$) with 200$\times$ less search cost in GPU hours. ``LL'' indicates latency regularization loss. Details of MnasNet's search cost are provided in appendix~\ref{sec:mnas_cost}.}\label{tab:imagenet_mobile}
\end{table}

\begin{figure}[t]
    \centering
    \begin{tabular}{l  r}
    \begin{minipage}{0.40\linewidth}
        \includegraphics[width=\linewidth]{figures/mobile_compare_caption.pdf}
        \caption{ProxylessNAS consistently outperforms MobileNetV2 under various latency settings.}
        \label{fig:mobile_rescale}
    \end{minipage}
    \qquad
    \begin{minipage}{0.42\linewidth}
        \includegraphics[width=\linewidth]{figures/latency_prediction-new.pdf}
        \caption{Our mobile latency model is close to $y=x$. The latency RMSE is 0.75ms.}
        \label{fig:latency_prediction}
    \end{minipage}
    \end{tabular}
\end{figure}

\minisection{ImageNet Classification Results} We first apply our ProxylessNAS to learn specialized CNN models on the mobile phone. The summarized results are reported in Table~\ref{tab:imagenet_mobile}. Compared to MobileNetV2, our model improves the top-1 accuracy by 2.6\% while maintaining a similar latency on the mobile phone. Furthermore, by rescaling the width of the networks using a multiplier \citep{sandler2018mobilenetv2,tan2018mnasnet}, it is shown in Figure~\ref{fig:mobile_rescale} that our model consistently outperforms MobileNetV2 by a significant margin under all latency settings. Specifically, to achieve the same level of top-1 accuracy performance (i.e. around 74.6\%), \textbf{MobileNetV2 has 143ms latency while our model only needs 78ms (1.83$\times$ faster)}. While compared with MnasNet~\citep{tan2018mnasnet}, our model can achieve 0.6\% higher top-1 accuracy with slightly lower mobile latency. More importantly, we are much more resource efficient: the GPU-hour is $200\times$ fewer than MnasNet (Table~\ref{tab:imagenet_mobile}). 

Additionally, we also observe that Proxyless-G has no incentive to choose computation-cheap operations if were not for the latency regularization loss. Its resulting architecture initially has 158ms latency on Pixel 1. After rescaling the network using the multiplier, its latency reduces to 83ms. However, this model can only achieve 71.8\% top-1 accuracy on ImageNet, which is 2.4\% lower than the result given by Proxyless-G with latency regularization loss. Therefore, we conclude that it is essential to take latency as a direct objective when learning efficient neural networks.

Besides the mobile phone, we also apply our ProxylessNAS to learn specialized CNN models on GPU and CPU. Table~\ref{tab:imagenet_gpu} reports the results on GPU, where we find that our ProxylessNAS can still achieve superior performances compared to both human-designed and automatically searched architectures. Specifically, compared to MobileNetV2 and MnasNet, our model improves the top-1 accuracy by 3.1\% and 1.1\% respectively while being 1.2$\times$ faster. Table~\ref{tab:imagenet_discussion} shows the summarized results of our searched models on three different platforms. An interesting observation is that models optimized for GPU do not run fast on CPU and mobile phone, vice versa. Therefore, it is essential to learn specialized neural networks for different hardware architectures to achieve the best efficiency on different hardware.

\minisection{Specialized Models for Different Hardware} Figure~\ref{fig:model_architectures} demonstrates the detailed architectures of our searched CNN models on three hardware platforms: GPU/CPU/Mobile. We notice that the architecture shows different preferences when targeting different platforms:  (i)~The GPU model is shallower and wider, especially in early stages where the feature map has higher resolution; (ii)~The GPU model prefers large MBConv operations (e.g. 7 $\times$ 7 MBConv6), while the CPU model would go for smaller MBConv operations. This is because GPU has much higher parallelism than CPU so it can take advantage of large MBConv operations. Another interesting observation is that our searched models on all platforms prefer larger MBConv operations in the first block within each stage where the feature map is downsampled. We suppose it might because larger MBConv operations are beneficial for the network to preserve more information when downsampling. Notably, such kind of patterns cannot be captured in previous NAS methods as they force the blocks to share the same structure \citep{zoph2017learning,liu2017progressive}. 

\begin{figure}[t]
\centering
    \begin{tabular}{l}
        \begin{minipage}{0.726\linewidth}
            \includegraphics[width=1\linewidth]{figures/arch-gpu.pdf}
        \end{minipage}
        \\
        \multicolumn{1}{c}{ (a) Efficient GPU model found by ProxylessNAS.}
        \vspace{5pt}
        \\
        \begin{minipage}{0.999\linewidth}
            \includegraphics[width=\linewidth]{figures/arch-cpu.pdf}
        \end{minipage}
        \\
        \multicolumn{1}{c}{ (b) Efficient CPU model found by ProxylessNAS.}
        \vspace{5pt}
        \\ 
       \begin{minipage}{1\linewidth}
        \includegraphics[width=\linewidth]{figures/arch-mobile.pdf}
        \end{minipage}
        \\
        \multicolumn{1}{c}{ (c) Efficient mobile model found by ProxylessNAS.}
    \end{tabular}
\caption{Efficient models optimized for different hardware. ``MBConv3'' and ``MBConv6'' denote mobile inverted bottleneck convolution layer with an expansion ratio of 3 and 6 respectively. Insights: GPU prefers shallow and wide model with early pooling; CPU prefers deep and narrow model with late pooling. Pooling layers prefer large and wide kernel. Early layers prefer small kernel. Late layers prefer large kernel.}
    \label{fig:model_architectures}
\end{figure}

\begin{table}[t]
\centering
\begin{tabular}{l | c | c | c }
        	\hline
        	Model & Top-1 & Top-5 & GPU latency \\
        	\hline
        	MobileNetV2 \citep{sandler2018mobilenetv2} & 72.0 & 91.0 & 6.1ms \\
        	ShuffleNetV2 (1.5) \citep{ma2018shufflenet} & 72.6 & - & 7.3ms \\
        	ResNet-34 \citep{he2016deep} & 73.3 & 91.4 & 8.0ms \\
\hline
        	NASNet-A \citep{zoph2017learning} & 74.0 & 91.3 & 38.3ms \\
        	DARTS \citep{liu2018darts} & 73.1 & 91.0 & - \\
        	MnasNet \citep{tan2018mnasnet} & 74.0 & 91.8 & 6.1ms \\
        	\hline 
        	Proxyless (GPU) & \textbf{75.1} & \textbf{92.5} & \textbf{5.1ms}  \\
        	\hline
        \end{tabular}
\caption{ImageNet Accuracy (\%) and GPU latency (Tesla V100) on ImageNet.}\label{tab:imagenet_gpu}
\end{table}

\begin{table}[t]
\centering
\begin{tabular}{l | c | c | c | c }
			\hline
			Model & Top-1 (\%) & GPU latency & CPU latency & Mobile latency \\
			\hline
			Proxyless (GPU)  & 75.1 & \textcolor{blue}{5.1ms} & \textcolor{red}{204.9ms} & \textcolor{red}{124ms} \\
			\hline
			Proxyless (CPU) & 75.3 & \textcolor{red}{7.4ms} & \textcolor{blue}{138.7ms} & \textcolor{red}{116ms} \\
			\hline
			Proxyless (mobile) & 74.6 & \textcolor{red}{7.2ms} & \textcolor{red}{164.1ms} & \textcolor{blue}{78ms} \\
			\hline
		\end{tabular}
\caption{Hardware prefers specialized models. Models optimized for GPU does not run fast on CPU and mobile phone, vice versa. ProxylessNAS provides an efficient solution to search a specialized neural network architecture for a target hardware architecture, while cutting down the search cost by 200$\times$ compared with state-of-the-arts \citep{zoph2016neural, tan2018mnasnet}. }\label{tab:imagenet_discussion}
\end{table}


 
\section{Conclusion}
We introduced ProxylessNAS that can directly learn neural network architectures on the target task and target hardware without any proxy. We also reduced the search cost (GPU-hours and GPU memory) of NAS to the same level of normal training using path binarization. Benefiting from the direct search, we achieve strong empirical results on CIFAR-10 and ImageNet. Furthermore, we allow specializing network architectures for different platforms by directly incorporating the measured hardware latency into optimization objectives. We compared the optimized models on CPU/GPU/mobile and raised the awareness of the needs of specializing neural network architecture for different hardware architectures. 
 
\subsubsection*{Acknowledgments}
We thank MIT Quest for Intelligence, MIT-IBM Watson AI lab, SenseTime, Xilinx, Snap Research for supporting this work. We also thank AWS Cloud Credits for Research Program providing us the cloud computing resources.

\bibliography{proxyless-nas}
\bibliographystyle{iclr2019_conference}

\newpage

\appendix
\section{The List of Candidate Operations Used on CIFAR-10}
We adopt the following $7$ operations in our CIFAR-10 experiments:
{\small
\begin{itemize}
	\setlength\itemsep{0.pt}
	\item $3 \times 3$ dilated depthwise-separable convolution
	\item Identity
	\item $3 \times 3$ depthwise-separable convolution 
	\item $5 \times 5$ depthwise-separable convolution
	\item $7 \times 7$ depthwise-separable convolution
    \item $3 \times 3$ average pooling
    \item $3 \times 3$ max pooling
\end{itemize}
}

\section{Mobile Latency Prediction}\label{sec:latency_prediction_model}
Measuring the latency on-device is accurate but not ideal for scalable neural architecture search. There are two reasons: (i) \emph{Slow.} As suggested in TensorFlow-Lite, 
we need to average hundreds of runs to produce a precise measurement, approximately 20 seconds. This is far more slower than a single forward / backward execution. (ii) \emph{Expensive.} A lot of mobile devices and software engineering work are required to build an automatic pipeline to gather the latency from a mobile farm. Instead of direct measurement, we build a model to estimate the latency. We need only 1 phone rather than a farm of phones, which has only 0.75ms latency RMSE. We use the \emph{latency model} to search, and we use the \emph{measured latency} to report the final model's latency. 

We sampled 5k architectures from our candidate space, where 4k architectures are used to build the latency model and the rest are used for test. We measured the latency on Google Pixel 1 phone using TensorFlow-Lite. The features include (i) type of the operator (ii) input and output feature map size (iii) other attributes like kernel size, stride for convolution and expansion ratio. 

\section{Details of MnasNet's Search Cost}\label{sec:mnas_cost}
Mnas \citep{tan2018mnasnet} trains 8,000 mobile-sized models on ImageNet, each of which is trained for 5 epochs for learning architectures. If these models are trained on V100 GPUs, as done in our experiments, the search cost is roughly 40,000 GPU hours. 

\section{Implementaion of the Gradient-Based Algorithm}\label{sec:grad_discussion}
A naive implementation of the gradient-based algorithm (see Eq.~(\ref{eq:binary_full})) is calculating and storing $o_j(x)$ in the forward step to later compute $\partial L / \partial g_j$ in the backward step:
\begin{align}\label{eq:binary_gate_gradient}
    \partial L / \partial g_j &= \text{reduce\_sum} (\nabla_y L~\circ o_j(x)),
\end{align}
where $\nabla_y L$ denotes the gradient w.r.t. the output of the mixed operation $y$, ``$\circ$'' denotes the element-wise product, and ``reduce\_sum$(\cdot)$'' denotes the sum of all elements.

Notice that $o_j(x)$ is only used for calculating $\partial L / \partial g_j$ when $j^{th}$ path is not active (i.e. not involved in calculating $y$). So we do not need to actually allocate GPU memory to store $o_j(x)$. Instead, we can calculate $o_j(x)$ after getting $\nabla_y L$ in the backward step, use $o_j(x)$ to compute $\partial L / \partial g_j$ following Eq.~(\ref{eq:binary_gate_gradient}), then release the occupied GPU memory. 
In this way, without the approximation discussed in Section~\ref{sec:grad_algo}, we can reduce the GPU memory cost to the same level of training a compact model. 

\end{document}
